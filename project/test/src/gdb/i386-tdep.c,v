head	1.373;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.370
	gdb_7_6-2013-04-26-release:1.370
	gdb_7_6-branch:1.370.0.2
	gdb_7_6-2013-03-12-branchpoint:1.370
	gdb_7_5_1-2012-11-29-release:1.355.2.1
	gdb_7_5-2012-08-17-release:1.355
	gdb_7_5-branch:1.355.0.2
	gdb_7_5-2012-07-18-branchpoint:1.355
	gdb_7_4_1-2012-04-26-release:1.340.2.2
	gdb_7_4-2012-01-24-release:1.340.2.2
	gdb_7_4-branch:1.340.0.2
	gdb_7_4-2011-12-13-branchpoint:1.340
	gdb_7_3_1-2011-09-04-release:1.331
	gdb_7_3-2011-07-26-release:1.331
	gdb_7_3-branch:1.331.0.2
	gdb_7_3-2011-04-01-branchpoint:1.331
	gdb_7_2-2010-09-02-release:1.316
	gdb_7_2-branch:1.316.0.2
	gdb_7_2-2010-07-07-branchpoint:1.316
	gdb_7_1-2010-03-18-release:1.296
	gdb_7_1-branch:1.296.0.2
	gdb_7_1-2010-02-18-branchpoint:1.296
	gdb_7_0_1-2009-12-22-release:1.287.2.1
	gdb_7_0-2009-10-06-release:1.287.2.1
	gdb_7_0-branch:1.287.0.2
	gdb_7_0-2009-09-16-branchpoint:1.287
	arc-sim-20090309:1.249.2.1
	msnyder-checkpoint-072509-branch:1.282.0.2
	msnyder-checkpoint-072509-branchpoint:1.282
	arc-insight_6_8-branch:1.249.2.1.0.4
	arc-insight_6_8-branchpoint:1.249.2.1
	insight_6_8-branch:1.249.2.1.0.2
	insight_6_8-branchpoint:1.249.2.1
	reverse-20081226-branch:1.266.0.6
	reverse-20081226-branchpoint:1.266
	multiprocess-20081120-branch:1.266.0.4
	multiprocess-20081120-branchpoint:1.266
	reverse-20080930-branch:1.266.0.2
	reverse-20080930-branchpoint:1.266
	reverse-20080717-branch:1.261.0.2
	reverse-20080717-branchpoint:1.261
	msnyder-reverse-20080609-branch:1.258.0.2
	msnyder-reverse-20080609-branchpoint:1.258
	drow-reverse-20070409-branch:1.233.0.2
	drow-reverse-20070409-branchpoint:1.233
	gdb_6_8-2008-03-27-release:1.249.2.1
	gdb_6_8-branch:1.249.0.2
	gdb_6_8-2008-02-26-branchpoint:1.249
	gdb_6_7_1-2007-10-29-release:1.239
	gdb_6_7-2007-10-10-release:1.239
	gdb_6_7-branch:1.239.0.2
	gdb_6_7-2007-09-07-branchpoint:1.239
	insight_6_6-20070208-release:1.225
	gdb_6_6-2006-12-18-release:1.225
	gdb_6_6-branch:1.225.0.2
	gdb_6_6-2006-11-15-branchpoint:1.225
	insight_6_5-20061003-release:1.224
	gdb-csl-symbian-6_4_50_20060226-12:1.223
	gdb-csl-sourcerygxx-3_4_4-25:1.219
	nickrob-async-20060828-mergepoint:1.225
	gdb-csl-symbian-6_4_50_20060226-11:1.223
	gdb-csl-sourcerygxx-4_1-17:1.223
	gdb-csl-20060226-branch-local-2:1.223
	gdb-csl-sourcerygxx-4_1-14:1.223
	gdb-csl-sourcerygxx-4_1-13:1.223
	gdb-csl-sourcerygxx-4_1-12:1.223
	gdb-csl-sourcerygxx-3_4_4-21:1.223
	gdb_6_5-20060621-release:1.224
	gdb-csl-sourcerygxx-4_1-9:1.223
	gdb-csl-sourcerygxx-4_1-8:1.223
	gdb-csl-sourcerygxx-4_1-7:1.223
	gdb-csl-arm-2006q1-6:1.223
	gdb-csl-sourcerygxx-4_1-6:1.223
	gdb-csl-symbian-6_4_50_20060226-10:1.223
	gdb-csl-symbian-6_4_50_20060226-9:1.223
	gdb-csl-symbian-6_4_50_20060226-8:1.223
	gdb-csl-coldfire-4_1-11:1.223
	gdb-csl-sourcerygxx-3_4_4-19:1.223
	gdb-csl-coldfire-4_1-10:1.223
	gdb_6_5-branch:1.224.0.10
	gdb_6_5-2006-05-14-branchpoint:1.224
	gdb-csl-sourcerygxx-4_1-5:1.223
	nickrob-async-20060513-branch:1.224.0.8
	nickrob-async-20060513-branchpoint:1.224
	gdb-csl-sourcerygxx-4_1-4:1.223
	msnyder-reverse-20060502-branch:1.224.0.6
	msnyder-reverse-20060502-branchpoint:1.224
	gdb-csl-morpho-4_1-4:1.223
	gdb-csl-sourcerygxx-3_4_4-17:1.223
	readline_5_1-import-branch:1.224.0.4
	readline_5_1-import-branchpoint:1.224
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.223
	gdb-csl-symbian-20060226-branch:1.223.0.6
	gdb-csl-symbian-20060226-branchpoint:1.223
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.223
	msnyder-reverse-20060331-branch:1.224.0.2
	msnyder-reverse-20060331-branchpoint:1.224
	gdb-csl-available-20060303-branch:1.223.0.4
	gdb-csl-available-20060303-branchpoint:1.223
	gdb-csl-20060226-branch:1.223.0.2
	gdb-csl-20060226-branchpoint:1.223
	gdb_6_4-20051202-release:1.219
	msnyder-fork-checkpoint-branch:1.219.0.8
	msnyder-fork-checkpoint-branchpoint:1.219
	gdb-csl-gxxpro-6_3-branch:1.219.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.219
	gdb_6_4-branch:1.219.0.4
	gdb_6_4-2005-11-01-branchpoint:1.219
	gdb-csl-arm-20051020-branch:1.219.0.2
	gdb-csl-arm-20051020-branchpoint:1.219
	msnyder-tracepoint-checkpoint-branch:1.213.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.213
	gdb-csl-arm-20050325-2005-q1b:1.208
	gdb-csl-arm-20050325-2005-q1a:1.208
	csl-arm-20050325-branch:1.208.0.2
	csl-arm-20050325-branchpoint:1.208
	gdb-post-i18n-errorwarning-20050211:1.206
	gdb-pre-i18n-errorwarning-20050211:1.205
	gdb_6_3-20041109-release:1.201
	gdb_6_3-branch:1.201.0.2
	gdb_6_3-20041019-branchpoint:1.201
	drow_intercu-merge-20040921:1.201
	drow_intercu-merge-20040915:1.200
	jimb-gdb_6_2-e500-branch:1.197.0.6
	jimb-gdb_6_2-e500-branchpoint:1.197
	gdb_6_2-20040730-release:1.197
	gdb_6_2-branch:1.197.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.197
	gdb_6_1_1-20040616-release:1.180
	gdb_6_1-2004-04-05-release:1.180
	drow_intercu-merge-20040402:1.182
	drow_intercu-merge-20040327:1.181
	ezannoni_pie-20040323-branch:1.181.0.2
	ezannoni_pie-20040323-branchpoint:1.181
	cagney_tramp-20040321-mergepoint:1.180
	cagney_tramp-20040309-branch:1.180.0.10
	cagney_tramp-20040309-branchpoint:1.180
	gdb_6_1-branch:1.180.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.180
	drow_intercu-20040221-branch:1.180.0.6
	drow_intercu-20040221-branchpoint:1.180
	cagney_bfdfile-20040213-branch:1.180.0.4
	cagney_bfdfile-20040213-branchpoint:1.180
	drow-cplus-merge-20040208:1.180
	carlton_dictionary-20040126-merge:1.180
	cagney_bigcore-20040122-branch:1.180.0.2
	cagney_bigcore-20040122-branchpoint:1.180
	drow-cplus-merge-20040113:1.178
	drow-cplus-merge-20031224:1.178
	drow-cplus-merge-20031220:1.178
	carlton_dictionary-20031215-merge:1.178
	drow-cplus-merge-20031214:1.177
	carlton-dictionary-20031111-merge:1.174
	gdb_6_0-2003-10-04-release:1.158.2.5
	kettenis_sparc-20030918-branch:1.167.0.4
	kettenis_sparc-20030918-branchpoint:1.167
	carlton_dictionary-20030917-merge:1.167
	ezannoni_pie-20030916-branchpoint:1.167
	ezannoni_pie-20030916-branch:1.167.0.2
	cagney_x86i386-20030821-branch:1.166.0.2
	cagney_x86i386-20030821-branchpoint:1.166
	carlton_dictionary-20030805-merge:1.162
	carlton_dictionary-20030627-merge:1.158
	gdb_6_0-branch:1.158.0.2
	gdb_6_0-2003-06-23-branchpoint:1.158
	jimb-ppc64-linux-20030613-branch:1.154.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.154
	cagney_convert-20030606-branch:1.151.0.2
	cagney_convert-20030606-branchpoint:1.151
	cagney_writestrings-20030508-branch:1.142.0.4
	cagney_writestrings-20030508-branchpoint:1.142
	jimb-ppc64-linux-20030528-branch:1.144.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.144
	carlton_dictionary-20030523-merge:1.144
	cagney_fileio-20030521-branch:1.144.0.2
	cagney_fileio-20030521-branchpoint:1.144
	kettenis_i386newframe-20030517-mergepoint:1.144
	jimb-ppc64-linux-20030509-branch:1.142.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.142
	kettenis_i386newframe-20030504-mergepoint:1.140
	carlton_dictionary-20030430-merge:1.140
	kettenis_i386newframe-20030419-branch:1.138.0.2
	kettenis_i386newframe-20030419-branchpoint:1.138
	carlton_dictionary-20030416-merge:1.133
	cagney_frameaddr-20030409-mergepoint:1.132
	kettenis_i386newframe-20030406-branch:1.132.0.2
	kettenis_i386newframe-20030406-branchpoint:1.132
	cagney_frameaddr-20030403-branchpoint:1.131
	cagney_frameaddr-20030403-branch:1.131.0.2
	cagney_framebase-20030330-mergepoint:1.126
	cagney_framebase-20030326-branch:1.122.0.2
	cagney_framebase-20030326-branchpoint:1.122
	cagney_lazyid-20030317-branch:1.119.0.2
	cagney_lazyid-20030317-branchpoint:1.119
	kettenis-i386newframe-20030316-mergepoint:1.118
	offbyone-20030313-branch:1.117.0.2
	offbyone-20030313-branchpoint:1.117
	kettenis-i386newframe-20030308-branch:1.116.0.4
	kettenis-i386newframe-20030308-branchpoint:1.116
	carlton_dictionary-20030305-merge:1.116
	cagney_offbyone-20030303-branch:1.116.0.2
	cagney_offbyone-20030303-branchpoint:1.116
	carlton_dictionary-20030207-merge:1.111
	interps-20030203-mergepoint:1.111
	interps-20030202-branch:1.111.0.4
	interps-20030202-branchpoint:1.111
	cagney-unwind-20030108-branch:1.111.0.2
	cagney-unwind-20030108-branchpoint:1.111
	carlton_dictionary-20021223-merge:1.104
	gdb_5_3-2002-12-12-release:1.85
	carlton_dictionary-20021115-merge:1.94
	kseitz_interps-20021105-merge:1.91
	kseitz_interps-20021103-merge:1.91
	drow-cplus-merge-20021020:1.88
	drow-cplus-merge-20021025:1.88
	carlton_dictionary-20021025-merge:1.88
	carlton_dictionary-20021011-merge:1.88
	drow-cplus-branch:1.88.0.4
	drow-cplus-branchpoint:1.88
	kseitz_interps-20020930-merge:1.88
	carlton_dictionary-20020927-merge:1.88
	carlton_dictionary-branch:1.88.0.2
	carlton_dictionary-20020920-branchpoint:1.88
	gdb_5_3-branch:1.85.0.2
	gdb_5_3-2002-09-04-branchpoint:1.85
	kseitz_interps-20020829-merge:1.85
	cagney_sysregs-20020825-branch:1.84.0.4
	cagney_sysregs-20020825-branchpoint:1.84
	readline_4_3-import-branch:1.84.0.2
	readline_4_3-import-branchpoint:1.84
	gdb_5_2_1-2002-07-23-release:1.52
	kseitz_interps-20020528-branch:1.55.0.2
	kseitz_interps-20020528-branchpoint:1.55
	cagney_regbuf-20020515-branch:1.54.0.2
	cagney_regbuf-20020515-branchpoint:1.54
	jimb-macro-020506-branch:1.53.0.2
	jimb-macro-020506-branchpoint:1.53
	gdb_5_2-2002-04-29-release:1.52
	gdb_5_2-branch:1.52.0.2
	gdb_5_2-2002-03-03-branchpoint:1.52
	gdb_5_1_1-2002-01-24-release:1.36.2.1
	gdb_5_1_0_1-2002-01-03-release:1.36.2.1
	cygnus_cvs_20020108_pre:1.50
	gdb_5_1_0_1-2002-01-03-branchpoint:1.36.2.1
	gdb_5_1_0_1-2002-01-03-branch:1.36.2.1.0.4
	gdb_5_1-2001-11-21-release:1.36.2.1
	gdb_s390-2001-09-26-branch:1.36.2.1.0.2
	gdb_s390-2001-09-26-branchpoint:1.36.2.1
	gdb_5_1-2001-07-29-branch:1.36.0.2
	gdb_5_1-2001-07-29-branchpoint:1.36
	dberlin-typesystem-branch:1.31.0.2
	dberlin-typesystem-branchpoint:1.31
	gdb-post-ptid_t-2001-05-03:1.29
	gdb-pre-ptid_t-2001-05-03:1.29
	insight-precleanup-2001-01-01:1.16
	gdb-post-protoization-2000-07-29:1.15
	gdb-pre-protoization-2000-07-29:1.14
	gdb-premipsmulti-2000-06-06-branch:1.11.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.11
	gdb-post-params-removal-2000-06-04:1.11
	gdb-pre-params-removal-2000-06-04:1.11
	gdb-post-params-removal-2000-05-28:1.11
	gdb-pre-params-removal-2000-05-28:1.10
	gdb_5_0-2000-05-19-release:1.9
	gdb_4_18_2-2000-05-18-release:1.9
	gdb_4_95_1-2000-05-11-snapshot:1.9
	gdb_4_95_0-2000-04-27-snapshot:1.9
	gdb_5_0-2000-04-10-branch:1.9.0.2
	gdb_5_0-2000-04-10-branchpoint:1.9
	repo-unification-2000-02-06:1.1.1.11
	insight-2000-02-04:1.1.1.11
	gdb-2000-02-04:1.1.1.11
	gdb-2000-02-02:1.1.1.11
	gdb-2000-02-01:1.1.1.11
	gdb-2000-01-31:1.1.1.11
	gdb-2000-01-26:1.1.1.11
	gdb-2000-01-24:1.1.1.11
	gdb-2000-01-17:1.1.1.11
	gdb-2000-01-10:1.1.1.11
	gdb-2000-01-05:1.1.1.11
	gdb-1999-12-21:1.1.1.11
	gdb-1999-12-13:1.1.1.11
	gdb-1999-12-07:1.1.1.11
	gdb-1999-12-06:1.1.1.11
	gdb-1999-11-16:1.1.1.11
	gdb-1999-11-08:1.1.1.11
	gdb-1999-11-01:1.1.1.11
	gdb-1999-10-25:1.1.1.11
	gdb-1999-10-18:1.1.1.11
	gdb-1999-10-11:1.1.1.10
	gdb-1999-10-04:1.1.1.10
	gdb-1999-09-28:1.1.1.9
	gdb-1999-09-21:1.1.1.9
	gdb-1999-09-13:1.1.1.8
	gdb-1999-09-08:1.1.1.8
	gdb-1999-08-30:1.1.1.7
	gdb-1999-08-23:1.1.1.7
	gdb-1999-08-16:1.1.1.7
	gdb-1999-08-09:1.1.1.6
	gdb-1999-08-02:1.1.1.5
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.373
date	2013.07.23.07.02.03;	author qiyao;	state Exp;
branches;
next	1.372;

1.372
date	2013.04.08.19.59.09;	author tromey;	state Exp;
branches;
next	1.371;

1.371
date	2013.03.13.16.45.11;	author palves;	state Exp;
branches;
next	1.370;

1.370
date	2013.03.11.08.45.54;	author mmetzger;	state Exp;
branches;
next	1.369;

1.369
date	2013.03.11.08.42.55;	author mmetzger;	state Exp;
branches;
next	1.368;

1.368
date	2013.01.31.18.37.37;	author aristovski;	state Exp;
branches;
next	1.367;

1.367
date	2013.01.01.06.32.45;	author brobecke;	state Exp;
branches;
next	1.366;

1.366
date	2012.12.11.11.32.39;	author palves;	state Exp;
branches;
next	1.365;

1.365
date	2012.12.04.07.43.19;	author kvbhat;	state Exp;
branches;
next	1.364;

1.364
date	2012.11.21.14.09.10;	author palves;	state Exp;
branches;
next	1.363;

1.363
date	2012.11.21.07.39.02;	author kvbhat;	state Exp;
branches;
next	1.362;

1.362
date	2012.11.12.21.59.06;	author brobecke;	state Exp;
branches;
next	1.361;

1.361
date	2012.11.09.10.11.21;	author qiyao;	state Exp;
branches;
next	1.360;

1.360
date	2012.10.26.19.34.09;	author palves;	state Exp;
branches;
next	1.359;

1.359
date	2012.10.24.14.56.01;	author kettenis;	state Exp;
branches;
next	1.358;

1.358
date	2012.10.15.20.37.39;	author hjl;	state Exp;
branches;
next	1.357;

1.357
date	2012.07.20.11.48.18;	author palves;	state Exp;
branches;
next	1.356;

1.356
date	2012.07.20.11.22.32;	author palves;	state Exp;
branches;
next	1.355;

1.355
date	2012.07.04.20.46.20;	author hjl;	state Exp;
branches
	1.355.2.1;
next	1.354;

1.354
date	2012.06.18.17.31.34;	author jkratoch;	state Exp;
branches;
next	1.353;

1.353
date	2012.06.13.21.21.25;	author kettenis;	state Exp;
branches;
next	1.352;

1.352
date	2012.06.13.20.29.15;	author kettenis;	state Exp;
branches;
next	1.351;

1.351
date	2012.05.18.21.02.48;	author sergiodj;	state Exp;
branches;
next	1.350;

1.350
date	2012.05.16.14.35.04;	author macro;	state Exp;
branches;
next	1.349;

1.349
date	2012.05.03.01.42.49;	author qiyao;	state Exp;
branches;
next	1.348;

1.348
date	2012.05.02.04.40.25;	author sergiodj;	state Exp;
branches;
next	1.347;

1.347
date	2012.04.27.20.47.54;	author sergiodj;	state Exp;
branches;
next	1.346;

1.346
date	2012.02.29.14.59.41;	author jkratoch;	state Exp;
branches;
next	1.345;

1.345
date	2012.02.07.04.48.21;	author devans;	state Exp;
branches;
next	1.344;

1.344
date	2012.02.02.20.19.15;	author devans;	state Exp;
branches;
next	1.343;

1.343
date	2012.01.28.18.08.17;	author jkratoch;	state Exp;
branches;
next	1.342;

1.342
date	2012.01.12.15.39.36;	author palves;	state Exp;
branches;
next	1.341;

1.341
date	2012.01.04.08.17.04;	author brobecke;	state Exp;
branches;
next	1.340;

1.340
date	2011.11.14.20.07.20;	author shebs;	state Exp;
branches
	1.340.2.1;
next	1.339;

1.339
date	2011.10.11.19.08.58;	author davem;	state Exp;
branches;
next	1.338;

1.338
date	2011.09.27.13.09.35;	author shebs;	state Exp;
branches;
next	1.337;

1.337
date	2011.09.23.14.50.30;	author jsm28;	state Exp;
branches;
next	1.336;

1.336
date	2011.07.22.15.31.51;	author tromey;	state Exp;
branches;
next	1.335;

1.335
date	2011.06.29.22.19.24;	author jkratoch;	state Exp;
branches;
next	1.334;

1.334
date	2011.06.12.20.46.11;	author kettenis;	state Exp;
branches;
next	1.333;

1.333
date	2011.06.12.18.21.55;	author kettenis;	state Exp;
branches;
next	1.332;

1.332
date	2011.05.05.15.57.35;	author guitton;	state Exp;
branches;
next	1.331;

1.331
date	2011.03.31.16.16.57;	author uweigand;	state Exp;
branches;
next	1.330;

1.330
date	2011.03.18.18.52.30;	author palves;	state Exp;
branches;
next	1.329;

1.329
date	2011.03.18.18.42.41;	author palves;	state Exp;
branches;
next	1.328;

1.328
date	2011.03.18.18.38.43;	author palves;	state Exp;
branches;
next	1.327;

1.327
date	2011.03.18.00.27.48;	author kcy;	state Exp;
branches;
next	1.326;

1.326
date	2011.03.08.23.08.55;	author msnyder;	state Exp;
branches;
next	1.325;

1.325
date	2011.03.08.18.49.16;	author msnyder;	state Exp;
branches;
next	1.324;

1.324
date	2011.02.08.14.01.47;	author jkratoch;	state Exp;
branches;
next	1.323;

1.323
date	2011.02.08.13.58.02;	author jkratoch;	state Exp;
branches;
next	1.322;

1.322
date	2011.01.09.03.08.56;	author msnyder;	state Exp;
branches;
next	1.321;

1.321
date	2011.01.01.15.33.07;	author brobecke;	state Exp;
branches;
next	1.320;

1.320
date	2010.09.13.17.39.48;	author hjl;	state Exp;
branches;
next	1.319;

1.319
date	2010.09.12.21.49.40;	author msnyder;	state Exp;
branches;
next	1.318;

1.318
date	2010.09.12.18.33.17;	author hjl;	state Exp;
branches;
next	1.317;

1.317
date	2010.09.11.19.09.34;	author hjl;	state Exp;
branches;
next	1.316;

1.316
date	2010.06.22.02.15.45;	author teawater;	state Exp;
branches
	1.316.2.1;
next	1.315;

1.315
date	2010.06.22.00.09.10;	author devans;	state Exp;
branches;
next	1.314;

1.314
date	2010.05.26.18.19.27;	author palves;	state Exp;
branches;
next	1.313;

1.313
date	2010.05.05.19.30.35;	author msnyder;	state Exp;
branches;
next	1.312;

1.312
date	2010.04.24.13.12.53;	author palves;	state Exp;
branches;
next	1.311;

1.311
date	2010.04.08.22.32.36;	author hjl;	state Exp;
branches;
next	1.310;

1.310
date	2010.04.08.09.23.06;	author teawater;	state Exp;
branches;
next	1.309;

1.309
date	2010.04.07.18.43.45;	author hjl;	state Exp;
branches;
next	1.308;

1.308
date	2010.04.02.05.09.29;	author teawater;	state Exp;
branches;
next	1.307;

1.307
date	2010.04.02.05.04.57;	author teawater;	state Exp;
branches;
next	1.306;

1.306
date	2010.03.30.15.45.12;	author hjl;	state Exp;
branches;
next	1.305;

1.305
date	2010.03.12.15.12.35;	author hjl;	state Exp;
branches;
next	1.304;

1.304
date	2010.03.09.18.25.41;	author msnyder;	state Exp;
branches;
next	1.303;

1.303
date	2010.03.08.12.57.11;	author teawater;	state Exp;
branches;
next	1.302;

1.302
date	2010.03.08.01.36.56;	author msnyder;	state Exp;
branches;
next	1.301;

1.301
date	2010.03.08.00.53.13;	author msnyder;	state Exp;
branches;
next	1.300;

1.300
date	2010.03.08.00.31.28;	author msnyder;	state Exp;
branches;
next	1.299;

1.299
date	2010.03.04.07.53.20;	author teawater;	state Exp;
branches;
next	1.298;

1.298
date	2010.03.02.13.14.34;	author hjl;	state Exp;
branches;
next	1.297;

1.297
date	2010.03.01.15.33.30;	author hjl;	state Exp;
branches;
next	1.296;

1.296
date	2010.02.01.19.46.46;	author drow;	state Exp;
branches;
next	1.295;

1.295
date	2010.01.06.04.20.26;	author shebs;	state Exp;
branches;
next	1.294;

1.294
date	2010.01.01.07.31.34;	author brobecke;	state Exp;
branches;
next	1.293;

1.293
date	2009.12.17.23.41.07;	author msnyder;	state Exp;
branches;
next	1.292;

1.292
date	2009.12.11.03.39.47;	author msnyder;	state Exp;
branches;
next	1.291;

1.291
date	2009.12.10.19.31.33;	author msnyder;	state Exp;
branches;
next	1.290;

1.290
date	2009.10.12.15.52.28;	author msnyder;	state Exp;
branches;
next	1.289;

1.289
date	2009.10.11.03.20.20;	author msnyder;	state Exp;
branches;
next	1.288;

1.288
date	2009.09.28.07.11.36;	author teawater;	state Exp;
branches;
next	1.287;

1.287
date	2009.09.07.11.09.33;	author teawater;	state Exp;
branches
	1.287.2.1;
next	1.286;

1.286
date	2009.09.05.15.37.02;	author teawater;	state Exp;
branches;
next	1.285;

1.285
date	2009.08.29.05.32.16;	author teawater;	state Exp;
branches;
next	1.284;

1.284
date	2009.08.26.23.59.19;	author msnyder;	state Exp;
branches;
next	1.283;

1.283
date	2009.08.10.03.02.39;	author teawater;	state Exp;
branches;
next	1.282;

1.282
date	2009.07.12.17.46.21;	author msnyder;	state Exp;
branches;
next	1.281;

1.281
date	2009.07.09.23.27.07;	author devans;	state Exp;
branches;
next	1.280;

1.280
date	2009.07.02.17.25.54;	author uweigand;	state Exp;
branches;
next	1.279;

1.279
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.278;

1.278
date	2009.07.02.12.55.30;	author uweigand;	state Exp;
branches;
next	1.277;

1.277
date	2009.07.02.12.52.52;	author uweigand;	state Exp;
branches;
next	1.276;

1.276
date	2009.07.02.12.48.54;	author uweigand;	state Exp;
branches;
next	1.275;

1.275
date	2009.07.02.12.46.19;	author uweigand;	state Exp;
branches;
next	1.274;

1.274
date	2009.05.29.11.38.39;	author eliz;	state Exp;
branches;
next	1.273;

1.273
date	2009.05.17.12.26.44;	author teawater;	state Exp;
branches;
next	1.272;

1.272
date	2009.05.06.11.16.40;	author teawater;	state Exp;
branches;
next	1.271;

1.271
date	2009.05.01.08.09.16;	author eliz;	state Exp;
branches;
next	1.270;

1.270
date	2009.04.30.03.12.17;	author teawater;	state Exp;
branches;
next	1.269;

1.269
date	2009.02.17.06.14.16;	author devans;	state Exp;
branches;
next	1.268;

1.268
date	2009.02.04.14.49.41;	author gingold;	state Exp;
branches;
next	1.267;

1.267
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.266;

1.266
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches
	1.266.2.1
	1.266.6.1;
next	1.265;

1.265
date	2008.09.03.13.39.56;	author aristovski;	state Exp;
branches;
next	1.264;

1.264
date	2008.08.26.17.40.24;	author uweigand;	state Exp;
branches;
next	1.263;

1.263
date	2008.08.24.16.39.56;	author tromey;	state Exp;
branches;
next	1.262;

1.262
date	2008.08.09.16.27.39;	author hjl;	state Exp;
branches;
next	1.261;

1.261
date	2008.07.03.00.19.58;	author palves;	state Exp;
branches
	1.261.2.1;
next	1.260;

1.260
date	2008.06.27.16.22.56;	author jsm28;	state Exp;
branches;
next	1.259;

1.259
date	2008.06.11.22.03.49;	author muller;	state Exp;
branches;
next	1.258;

1.258
date	2008.05.16.00.27.23;	author drow;	state Exp;
branches;
next	1.257;

1.257
date	2008.05.02.16.49.54;	author palves;	state Exp;
branches;
next	1.256;

1.256
date	2008.04.30.21.19.44;	author drow;	state Exp;
branches;
next	1.255;

1.255
date	2008.04.25.14.57.30;	author palves;	state Exp;
branches;
next	1.254;

1.254
date	2008.04.22.11.03.41;	author corinna;	state Exp;
branches;
next	1.253;

1.253
date	2008.03.17.19.32.56;	author deuling;	state Exp;
branches;
next	1.252;

1.252
date	2008.03.13.12.22.13;	author drow;	state Exp;
branches;
next	1.251;

1.251
date	2008.03.11.05.21.38;	author deuling;	state Exp;
branches;
next	1.250;

1.250
date	2008.02.26.22.23.45;	author bauermann;	state Exp;
branches;
next	1.249;

1.249
date	2008.01.25.17.24.49;	author muller;	state Exp;
branches
	1.249.2.1;
next	1.248;

1.248
date	2008.01.11.13.20.00;	author deuling;	state Exp;
branches;
next	1.247;

1.247
date	2008.01.01.22.53.11;	author drow;	state Exp;
branches;
next	1.246;

1.246
date	2007.12.06.16.32.59;	author deuling;	state Exp;
branches;
next	1.245;

1.245
date	2007.11.09.05.32.19;	author deuling;	state Exp;
branches;
next	1.244;

1.244
date	2007.11.07.06.32.59;	author deuling;	state Exp;
branches;
next	1.243;

1.243
date	2007.11.02.14.27.14;	author uweigand;	state Exp;
branches;
next	1.242;

1.242
date	2007.10.24.20.29.14;	author drow;	state Exp;
branches;
next	1.241;

1.241
date	2007.10.19.12.23.20;	author uweigand;	state Exp;
branches;
next	1.240;

1.240
date	2007.10.09.18.18.50;	author uweigand;	state Exp;
branches;
next	1.239;

1.239
date	2007.08.23.18.08.34;	author brobecke;	state Exp;
branches;
next	1.238;

1.238
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.237;

1.237
date	2007.06.16.17.25.59;	author uweigand;	state Exp;
branches;
next	1.236;

1.236
date	2007.06.15.22.41.13;	author uweigand;	state Exp;
branches;
next	1.235;

1.235
date	2007.06.12.16.59.43;	author uweigand;	state Exp;
branches;
next	1.234;

1.234
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.233;

1.233
date	2007.03.30.12.57.43;	author drow;	state Exp;
branches;
next	1.232;

1.232
date	2007.02.27.20.17.19;	author drow;	state Exp;
branches;
next	1.231;

1.231
date	2007.02.16.21.49.59;	author drow;	state Exp;
branches;
next	1.230;

1.230
date	2007.01.29.17.31.06;	author drow;	state Exp;
branches;
next	1.229;

1.229
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.228;

1.228
date	2007.01.05.16.40.48;	author brobecke;	state Exp;
branches;
next	1.227;

1.227
date	2007.01.03.19.01.25;	author drow;	state Exp;
branches;
next	1.226;

1.226
date	2006.12.31.14.50.36;	author brobecke;	state Exp;
branches;
next	1.225;

1.225
date	2006.08.08.21.36.46;	author brobecke;	state Exp;
branches;
next	1.224;

1.224
date	2006.03.17.00.14.24;	author msnyder;	state Exp;
branches
	1.224.8.1;
next	1.223;

1.223
date	2006.02.14.15.41.59;	author kettenis;	state Exp;
branches;
next	1.222;

1.222
date	2006.01.21.20.59.50;	author kettenis;	state Exp;
branches;
next	1.221;

1.221
date	2006.01.18.21.26.47;	author kettenis;	state Exp;
branches;
next	1.220;

1.220
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.219;

1.219
date	2005.10.10.01.08.07;	author brobecke;	state Exp;
branches;
next	1.218;

1.218
date	2005.09.26.06.59.39;	author jbeulich;	state Exp;
branches;
next	1.217;

1.217
date	2005.07.18.19.18.41;	author kettenis;	state Exp;
branches;
next	1.216;

1.216
date	2005.07.18.12.40.13;	author kettenis;	state Exp;
branches;
next	1.215;

1.215
date	2005.06.24.08.12.32;	author corinna;	state Exp;
branches;
next	1.214;

1.214
date	2005.06.11.19.11.32;	author kettenis;	state Exp;
branches;
next	1.213;

1.213
date	2005.05.28.16.44.28;	author drow;	state Exp;
branches;
next	1.212;

1.212
date	2005.05.14.19.46.10;	author kettenis;	state Exp;
branches;
next	1.211;

1.211
date	2005.05.14.11.27.02;	author kettenis;	state Exp;
branches;
next	1.210;

1.210
date	2005.05.08.16.27.34;	author kettenis;	state Exp;
branches;
next	1.209;

1.209
date	2005.04.06.17.01.25;	author jimb;	state Exp;
branches;
next	1.208;

1.208
date	2005.02.21.04.31.57;	author cagney;	state Exp;
branches;
next	1.207;

1.207
date	2005.02.11.18.13.50;	author cagney;	state Exp;
branches;
next	1.206;

1.206
date	2005.02.11.04.05.51;	author cagney;	state Exp;
branches;
next	1.205;

1.205
date	2005.02.02.21.36.11;	author cagney;	state Exp;
branches;
next	1.204;

1.204
date	2005.02.02.20.31.32;	author cagney;	state Exp;
branches;
next	1.203;

1.203
date	2004.10.31.19.52.46;	author cagney;	state Exp;
branches;
next	1.202;

1.202
date	2004.10.29.14.00.55;	author cagney;	state Exp;
branches;
next	1.201;

1.201
date	2004.09.18.20.16.37;	author kettenis;	state Exp;
branches;
next	1.200;

1.200
date	2004.08.01.21.55.44;	author kettenis;	state Exp;
branches;
next	1.199;

1.199
date	2004.07.26.14.53.01;	author cagney;	state Exp;
branches;
next	1.198;

1.198
date	2004.07.24.12.59.52;	author kettenis;	state Exp;
branches;
next	1.197;

1.197
date	2004.06.18.16.06.24;	author kettenis;	state Exp;
branches
	1.197.2.1;
next	1.196;

1.196
date	2004.06.07.02.02.50;	author tausq;	state Exp;
branches;
next	1.195;

1.195
date	2004.05.30.14.13.49;	author kettenis;	state Exp;
branches;
next	1.194;

1.194
date	2004.05.22.15.16.22;	author kettenis;	state Exp;
branches;
next	1.193;

1.193
date	2004.05.21.22.15.09;	author jimb;	state Exp;
branches;
next	1.192;

1.192
date	2004.05.20.00.53.06;	author jimb;	state Exp;
branches;
next	1.191;

1.191
date	2004.05.08.23.02.10;	author kettenis;	state Exp;
branches;
next	1.190;

1.190
date	2004.04.30.21.13.58;	author ford;	state Exp;
branches;
next	1.189;

1.189
date	2004.04.29.16.24.01;	author kettenis;	state Exp;
branches;
next	1.188;

1.188
date	2004.04.29.16.13.21;	author kettenis;	state Exp;
branches;
next	1.187;

1.187
date	2004.04.18.18.38.04;	author kettenis;	state Exp;
branches;
next	1.186;

1.186
date	2004.04.16.16.49.55;	author kettenis;	state Exp;
branches;
next	1.185;

1.185
date	2004.04.09.23.26.19;	author kettenis;	state Exp;
branches;
next	1.184;

1.184
date	2004.04.09.16.28.50;	author kettenis;	state Exp;
branches;
next	1.183;

1.183
date	2004.04.07.16.45.45;	author jimb;	state Exp;
branches;
next	1.182;

1.182
date	2004.04.01.18.14.03;	author jimb;	state Exp;
branches;
next	1.181;

1.181
date	2004.03.23.14.47.56;	author cagney;	state Exp;
branches;
next	1.180;

1.180
date	2004.01.17.22.45.44;	author cagney;	state Exp;
branches
	1.180.6.1;
next	1.179;

1.179
date	2004.01.13.21.38.46;	author cagney;	state Exp;
branches;
next	1.178;

1.178
date	2003.12.14.10.59.08;	author kettenis;	state Exp;
branches;
next	1.177;

1.177
date	2003.11.20.22.37.50;	author kettenis;	state Exp;
branches;
next	1.176;

1.176
date	2003.11.16.15.07.00;	author kettenis;	state Exp;
branches;
next	1.175;

1.175
date	2003.11.16.10.43.07;	author kettenis;	state Exp;
branches;
next	1.174;

1.174
date	2003.10.30.23.03.36;	author kettenis;	state Exp;
branches;
next	1.173;

1.173
date	2003.10.26.13.08.56;	author kettenis;	state Exp;
branches;
next	1.172;

1.172
date	2003.10.11.13.50.25;	author kettenis;	state Exp;
branches;
next	1.171;

1.171
date	2003.10.06.21.58.20;	author schwab;	state Exp;
branches;
next	1.170;

1.170
date	2003.10.05.21.31.33;	author kettenis;	state Exp;
branches;
next	1.169;

1.169
date	2003.09.27.21.57.56;	author kettenis;	state Exp;
branches;
next	1.168;

1.168
date	2003.09.27.17.45.01;	author kettenis;	state Exp;
branches;
next	1.167;

1.167
date	2003.09.09.04.41.32;	author cagney;	state Exp;
branches;
next	1.166;

1.166
date	2003.08.17.23.16.44;	author kettenis;	state Exp;
branches;
next	1.165;

1.165
date	2003.08.12.16.12.33;	author kevinb;	state Exp;
branches;
next	1.164;

1.164
date	2003.08.10.18.06.05;	author kettenis;	state Exp;
branches;
next	1.163;

1.163
date	2003.08.10.12.15.16;	author kettenis;	state Exp;
branches;
next	1.162;

1.162
date	2003.07.18.21.31.50;	author cagney;	state Exp;
branches;
next	1.161;

1.161
date	2003.07.16.22.29.13;	author cagney;	state Exp;
branches;
next	1.160;

1.160
date	2003.07.02.17.20.24;	author cagney;	state Exp;
branches;
next	1.159;

1.159
date	2003.07.01.13.25.19;	author cagney;	state Exp;
branches;
next	1.158;

1.158
date	2003.06.15.11.40.46;	author kettenis;	state Exp;
branches
	1.158.2.1;
next	1.157;

1.157
date	2003.06.15.11.01.46;	author kettenis;	state Exp;
branches;
next	1.156;

1.156
date	2003.06.15.00.27.54;	author cagney;	state Exp;
branches;
next	1.155;

1.155
date	2003.06.14.22.35.25;	author cagney;	state Exp;
branches;
next	1.154;

1.154
date	2003.06.13.20.37.27;	author cagney;	state Exp;
branches;
next	1.153;

1.153
date	2003.06.11.19.38.26;	author cagney;	state Exp;
branches;
next	1.152;

1.152
date	2003.06.09.17.35.57;	author cagney;	state Exp;
branches;
next	1.151;

1.151
date	2003.06.02.02.54.35;	author fedor;	state Exp;
branches
	1.151.2.1;
next	1.150;

1.150
date	2003.05.31.21.13.20;	author kettenis;	state Exp;
branches;
next	1.149;

1.149
date	2003.05.31.16.49.18;	author kettenis;	state Exp;
branches;
next	1.148;

1.148
date	2003.05.31.16.25.13;	author kettenis;	state Exp;
branches;
next	1.147;

1.147
date	2003.05.31.16.08.05;	author kettenis;	state Exp;
branches;
next	1.146;

1.146
date	2003.05.31.14.20.31;	author cagney;	state Exp;
branches;
next	1.145;

1.145
date	2003.05.30.19.24.29;	author kettenis;	state Exp;
branches;
next	1.144;

1.144
date	2003.05.17.05.59.58;	author cagney;	state Exp;
branches;
next	1.143;

1.143
date	2003.05.13.19.27.28;	author cagney;	state Exp;
branches;
next	1.142;

1.142
date	2003.05.08.20.52.47;	author cagney;	state Exp;
branches
	1.142.4.1;
next	1.141;

1.141
date	2003.05.05.17.56.55;	author cagney;	state Exp;
branches;
next	1.140;

1.140
date	2003.04.29.01.49.47;	author cagney;	state Exp;
branches;
next	1.139;

1.139
date	2003.04.21.18.55.52;	author cagney;	state Exp;
branches;
next	1.138;

1.138
date	2003.04.19.14.43.50;	author kettenis;	state Exp;
branches
	1.138.2.1;
next	1.137;

1.137
date	2003.04.19.14.38.47;	author kettenis;	state Exp;
branches;
next	1.136;

1.136
date	2003.04.19.14.34.31;	author kettenis;	state Exp;
branches;
next	1.135;

1.135
date	2003.04.19.14.30.33;	author kettenis;	state Exp;
branches;
next	1.134;

1.134
date	2003.04.19.14.26.15;	author kettenis;	state Exp;
branches;
next	1.133;

1.133
date	2003.04.11.18.15.38;	author cagney;	state Exp;
branches;
next	1.132;

1.132
date	2003.04.05.18.54.38;	author cagney;	state Exp;
branches;
next	1.131;

1.131
date	2003.04.01.17.17.28;	author cagney;	state Exp;
branches
	1.131.2.1;
next	1.130;

1.130
date	2003.04.01.14.38.49;	author cagney;	state Exp;
branches;
next	1.129;

1.129
date	2003.03.31.23.52.38;	author cagney;	state Exp;
branches;
next	1.128;

1.128
date	2003.03.31.21.58.21;	author cagney;	state Exp;
branches;
next	1.127;

1.127
date	2003.03.31.19.01.20;	author cagney;	state Exp;
branches;
next	1.126;

1.126
date	2003.03.30.15.03.46;	author kettenis;	state Exp;
branches;
next	1.125;

1.125
date	2003.03.30.14.59.00;	author cagney;	state Exp;
branches;
next	1.124;

1.124
date	2003.03.30.14.32.09;	author cagney;	state Exp;
branches;
next	1.123;

1.123
date	2003.03.26.22.39.52;	author cagney;	state Exp;
branches;
next	1.122;

1.122
date	2003.03.25.20.38.46;	author cagney;	state Exp;
branches
	1.122.2.1;
next	1.121;

1.121
date	2003.03.25.18.54.15;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2003.03.24.03.54.48;	author cagney;	state Exp;
branches;
next	1.119;

1.119
date	2003.03.16.20.14.57;	author kettenis;	state Exp;
branches;
next	1.118;

1.118
date	2003.03.13.21.45.40;	author cagney;	state Exp;
branches;
next	1.117;

1.117
date	2003.03.12.16.50.44;	author cagney;	state Exp;
branches;
next	1.116;

1.116
date	2003.03.03.20.50.18;	author cagney;	state Exp;
branches
	1.116.4.1;
next	1.115;

1.115
date	2003.03.02.10.40.37;	author kettenis;	state Exp;
branches;
next	1.114;

1.114
date	2003.03.02.04.02.23;	author cagney;	state Exp;
branches;
next	1.113;

1.113
date	2003.02.27.17.48.47;	author cagney;	state Exp;
branches;
next	1.112;

1.112
date	2003.02.25.21.36.18;	author carlton;	state Exp;
branches;
next	1.111;

1.111
date	2003.01.08.15.56.36;	author cagney;	state Exp;
branches;
next	1.110;

1.110
date	2003.01.08.01.53.37;	author cagney;	state Exp;
branches;
next	1.109;

1.109
date	2003.01.05.14.07.02;	author kettenis;	state Exp;
branches;
next	1.108;

1.108
date	2003.01.05.01.39.54;	author drow;	state Exp;
branches;
next	1.107;

1.107
date	2003.01.04.23.38.45;	author drow;	state Exp;
branches;
next	1.106;

1.106
date	2003.01.03.23.53.47;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2003.01.02.22.20.46;	author cagney;	state Exp;
branches;
next	1.104;

1.104
date	2002.12.21.19.58.07;	author kettenis;	state Exp;
branches;
next	1.103;

1.103
date	2002.12.11.14.38.23;	author kettenis;	state Exp;
branches;
next	1.102;

1.102
date	2002.12.11.02.26.36;	author cagney;	state Exp;
branches;
next	1.101;

1.101
date	2002.12.01.19.07.14;	author cagney;	state Exp;
branches;
next	1.100;

1.100
date	2002.11.28.18.15.58;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2002.11.26.19.01.29;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2002.11.24.19.48.12;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2002.11.23.01.39.25;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2002.11.18.22.19.27;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2002.11.16.01.00.06;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2002.11.08.23.59.58;	author cagney;	state Exp;
branches;
next	1.93;

1.93
date	2002.11.08.17.34.31;	author brobecke;	state Exp;
branches;
next	1.92;

1.92
date	2002.11.08.16.52.37;	author cagney;	state Exp;
branches;
next	1.91;

1.91
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2002.10.26.14.58.42;	author kettenis;	state Exp;
branches;
next	1.89;

1.89
date	2002.10.26.14.41.37;	author kettenis;	state Exp;
branches;
next	1.88;

1.88
date	2002.09.17.20.42.01;	author cagney;	state Exp;
branches
	1.88.2.1
	1.88.4.1;
next	1.87;

1.87
date	2002.09.15.13.53.36;	author kettenis;	state Exp;
branches;
next	1.86;

1.86
date	2002.09.06.21.28.18;	author kettenis;	state Exp;
branches;
next	1.85;

1.85
date	2002.08.26.18.35.25;	author kettenis;	state Exp;
branches;
next	1.84;

1.84
date	2002.08.24.00.21.34;	author cagney;	state Exp;
branches
	1.84.4.1;
next	1.83;

1.83
date	2002.08.23.19.26.14;	author kettenis;	state Exp;
branches;
next	1.82;

1.82
date	2002.08.18.17.18.45;	author kettenis;	state Exp;
branches;
next	1.81;

1.81
date	2002.08.17.11.39.38;	author kettenis;	state Exp;
branches;
next	1.80;

1.80
date	2002.08.16.22.44.00;	author brobecke;	state Exp;
branches;
next	1.79;

1.79
date	2002.08.15.17.36.57;	author kettenis;	state Exp;
branches;
next	1.78;

1.78
date	2002.08.13.21.54.18;	author kettenis;	state Exp;
branches;
next	1.77;

1.77
date	2002.08.13.19.14.09;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2002.08.13.14.32.28;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2002.08.13.13.58.50;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2002.08.12.19.05.33;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2002.07.24.14.38.55;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2002.07.04.08.18.20;	author kettenis;	state Exp;
branches;
next	1.71;

1.71
date	2002.07.04.07.22.11;	author kettenis;	state Exp;
branches;
next	1.70;

1.70
date	2002.07.03.09.39.47;	author kettenis;	state Exp;
branches;
next	1.69;

1.69
date	2002.07.02.09.12.37;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2002.07.01.21.16.32;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2002.07.01.10.20.40;	author kettenis;	state Exp;
branches;
next	1.66;

1.66
date	2002.06.17.23.32.30;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.16.15.32.08;	author kettenis;	state Exp;
branches;
next	1.64;

1.64
date	2002.06.15.22.10.58;	author kettenis;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.15.21.15.41;	author kettenis;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.15.20.41.51;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.15.19.59.07;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.15.17.53.24;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.15.17.51.36;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2002.06.15.12.59.09;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2002.06.14.21.17.27;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2002.06.14.19.42.19;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2002.05.27.09.17.24;	author hunt;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2002.05.09.13.53.36;	author kettenis;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2002.03.19.02.51.07;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.19.18.42.27;	author schauer;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2002.02.19.08.44.29;	author muller;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.01.16.29.43;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2001.12.29.19.38.16;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2001.12.27.15.22.27;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.02.18.29.08;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2001.11.18.22.14.13;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.08.20.26.42;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.08.18.32.08;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.08.18.23.43;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2001.11.04.13.51.48;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.31.22.24.05;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2001.10.29.23.49.31;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2001.10.21.17.19.37;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.01.18.39.23;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.30.21.09.44;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.28.17.03.38;	author kettenis;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2001.07.28.16.48.59;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2001.07.15.20.10.02;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.12.18.50.01;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.11.08.43.41;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.09.16.16.33;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.09.09.58.45;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.19.11.39.47;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.17.23.20.55;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.16.13.03.15;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.04.15.09.46;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2001.04.01.12.39.52;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.31.13.05.16;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.26.12.11.13;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.21.11.22.24;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.17.22.28.33;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.06.08.21.08;	author kevinb;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.21.20.52.59;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.12.01.44.35;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.08.00.52.56;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.07.04.38.02;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.28.01.12.27;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.16.03.03.13;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.26.21.21.50;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.22.09.45.01;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.16.22.46.26;	author jimb;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.08.22.34.18;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.04.23.37.33;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.29.13.28.24;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.29.08.16.39;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.23.22.11.07;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.355.2.1
date	2012.11.10.00.50.46;	author hjl;	state Exp;
branches;
next	;

1.340.2.1
date	2012.01.06.04.43.15;	author brobecke;	state Exp;
branches;
next	1.340.2.2;

1.340.2.2
date	2012.01.12.15.48.49;	author palves;	state Exp;
branches;
next	;

1.316.2.1
date	2011.03.18.00.32.13;	author kcy;	state Exp;
branches;
next	;

1.287.2.1
date	2009.09.28.07.20.45;	author teawater;	state Exp;
branches;
next	;

1.266.2.1
date	2008.10.01.04.23.32;	author msnyder;	state Exp;
branches;
next	1.266.2.2;

1.266.2.2
date	2008.10.07.08.33.15;	author teawater;	state Exp;
branches;
next	;

1.266.6.1
date	2008.12.26.21.09.13;	author msnyder;	state Exp;
branches;
next	;

1.261.2.1
date	2008.07.20.14.30.11;	author teawater;	state Exp;
branches;
next	1.261.2.2;

1.261.2.2
date	2008.08.01.20.42.25;	author msnyder;	state Exp;
branches;
next	1.261.2.3;

1.261.2.3
date	2008.08.07.03.04.25;	author teawater;	state Exp;
branches;
next	1.261.2.4;

1.261.2.4
date	2008.09.02.09.18.27;	author teawater;	state Exp;
branches;
next	1.261.2.5;

1.261.2.5
date	2008.09.09.09.26.35;	author teawater;	state Exp;
branches;
next	1.261.2.6;

1.261.2.6
date	2008.09.18.17.17.42;	author teawater;	state Exp;
branches;
next	1.261.2.7;

1.261.2.7
date	2008.10.07.07.37.37;	author teawater;	state Exp;
branches;
next	;

1.249.2.1
date	2008.03.04.19.49.39;	author brobecke;	state Exp;
branches;
next	;

1.224.8.1
date	2006.08.28.07.48.48;	author nickrob;	state Exp;
branches;
next	;

1.197.2.1
date	2004.08.13.19.08.03;	author kettenis;	state Exp;
branches;
next	;

1.180.6.1
date	2004.03.27.17.37.49;	author drow;	state Exp;
branches;
next	1.180.6.2;

1.180.6.2
date	2004.04.02.16.47.46;	author drow;	state Exp;
branches;
next	1.180.6.3;

1.180.6.3
date	2004.09.16.17.01.08;	author drow;	state Exp;
branches;
next	1.180.6.4;

1.180.6.4
date	2004.09.21.20.44.16;	author drow;	state Exp;
branches;
next	;

1.158.2.1
date	2003.07.01.21.44.24;	author cagney;	state Exp;
branches;
next	1.158.2.2;

1.158.2.2
date	2003.07.02.17.15.54;	author cagney;	state Exp;
branches;
next	1.158.2.3;

1.158.2.3
date	2003.07.21.14.28.28;	author cagney;	state Exp;
branches;
next	1.158.2.4;

1.158.2.4
date	2003.08.13.22.03.21;	author kettenis;	state Exp;
branches;
next	1.158.2.5;

1.158.2.5
date	2003.08.18.17.14.16;	author kettenis;	state Exp;
branches;
next	;

1.151.2.1
date	2003.06.09.10.35.18;	author kettenis;	state Exp;
branches;
next	;

1.142.4.1
date	2003.06.03.20.54.37;	author cagney;	state Exp;
branches;
next	;

1.138.2.1
date	2003.04.19.16.40.13;	author kettenis;	state Exp;
branches;
next	1.138.2.2;

1.138.2.2
date	2003.05.04.10.12.14;	author kettenis;	state Exp;
branches;
next	1.138.2.3;

1.138.2.3
date	2003.05.04.11.37.42;	author kettenis;	state Exp;
branches;
next	1.138.2.4;

1.138.2.4
date	2003.05.04.11.42.45;	author kettenis;	state Exp;
branches;
next	1.138.2.5;

1.138.2.5
date	2003.05.04.21.47.01;	author kettenis;	state Exp;
branches;
next	1.138.2.6;

1.138.2.6
date	2003.05.04.22.00.09;	author kettenis;	state Exp;
branches;
next	1.138.2.7;

1.138.2.7
date	2003.05.05.16.18.53;	author kettenis;	state Exp;
branches;
next	1.138.2.8;

1.138.2.8
date	2003.05.10.15.18.06;	author kettenis;	state Exp;
branches;
next	1.138.2.9;

1.138.2.9
date	2003.05.10.21.58.14;	author kettenis;	state Exp;
branches;
next	1.138.2.10;

1.138.2.10
date	2003.05.10.23.18.22;	author kettenis;	state Exp;
branches;
next	1.138.2.11;

1.138.2.11
date	2003.05.17.13.43.29;	author kettenis;	state Exp;
branches;
next	1.138.2.12;

1.138.2.12
date	2003.05.17.15.34.57;	author kettenis;	state Exp;
branches;
next	1.138.2.13;

1.138.2.13
date	2003.05.18.09.44.12;	author kettenis;	state Exp;
branches;
next	1.138.2.14;

1.138.2.14
date	2003.05.18.17.52.02;	author kettenis;	state Exp;
branches;
next	1.138.2.15;

1.138.2.15
date	2003.05.23.20.18.32;	author kettenis;	state Exp;
branches;
next	1.138.2.16;

1.138.2.16
date	2003.05.29.10.35.38;	author kettenis;	state Exp;
branches;
next	1.138.2.17;

1.138.2.17
date	2003.05.29.13.39.48;	author kettenis;	state Exp;
branches;
next	;

1.131.2.1
date	2003.04.10.21.33.48;	author cagney;	state Exp;
branches;
next	;

1.122.2.1
date	2003.03.30.16.35.21;	author cagney;	state Exp;
branches;
next	;

1.116.4.1
date	2003.03.08.12.20.59;	author kettenis;	state Exp;
branches;
next	1.116.4.2;

1.116.4.2
date	2003.03.16.17.33.08;	author kettenis;	state Exp;
branches;
next	1.116.4.3;

1.116.4.3
date	2003.03.16.19.56.22;	author kettenis;	state Exp;
branches;
next	;

1.88.2.1
date	2002.11.15.19.18.48;	author carlton;	state Exp;
branches;
next	1.88.2.2;

1.88.2.2
date	2002.12.23.19.38.28;	author carlton;	state Exp;
branches;
next	1.88.2.3;

1.88.2.3
date	2003.02.07.19.17.49;	author carlton;	state Exp;
branches;
next	1.88.2.4;

1.88.2.4
date	2003.03.06.00.56.29;	author carlton;	state Exp;
branches;
next	1.88.2.5;

1.88.2.5
date	2003.04.16.19.56.52;	author carlton;	state Exp;
branches;
next	1.88.2.6;

1.88.2.6
date	2003.05.01.00.46.50;	author carlton;	state Exp;
branches;
next	1.88.2.7;

1.88.2.7
date	2003.05.23.18.40.40;	author carlton;	state Exp;
branches;
next	1.88.2.8;

1.88.2.8
date	2003.06.27.21.49.58;	author carlton;	state Exp;
branches;
next	1.88.2.9;

1.88.2.9
date	2003.08.05.17.13.10;	author carlton;	state Exp;
branches;
next	1.88.2.10;

1.88.2.10
date	2003.09.17.21.28.22;	author carlton;	state Exp;
branches;
next	1.88.2.11;

1.88.2.11
date	2003.11.11.23.50.46;	author carlton;	state Exp;
branches;
next	1.88.2.12;

1.88.2.12
date	2003.12.16.00.00.36;	author carlton;	state Exp;
branches;
next	1.88.2.13;

1.88.2.13
date	2004.01.26.19.11.26;	author carlton;	state Exp;
branches;
next	;

1.88.4.1
date	2003.12.14.20.27.16;	author drow;	state Exp;
branches;
next	1.88.4.2;

1.88.4.2
date	2003.12.20.18.16.49;	author drow;	state Exp;
branches;
next	1.88.4.3;

1.88.4.3
date	2004.02.09.19.43.40;	author drow;	state Exp;
branches;
next	;

1.84.4.1
date	2002.08.26.19.57.39;	author cagney;	state Exp;
branches;
next	1.84.4.2;

1.84.4.2
date	2002.08.29.03.25.04;	author cagney;	state Exp;
branches;
next	1.84.4.3;

1.84.4.3
date	2002.08.29.18.22.43;	author cagney;	state Exp;
branches;
next	1.84.4.4;

1.84.4.4
date	2002.09.19.16.49.54;	author cagney;	state Exp;
branches;
next	1.84.4.5;

1.84.4.5
date	2002.09.19.16.55.51;	author cagney;	state Exp;
branches;
next	;

1.55.2.1
date	2002.06.20.01.32.35;	author kseitz;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	2002.07.22.21.46.59;	author kseitz;	state Exp;
branches;
next	1.55.2.3;

1.55.2.3
date	2002.08.09.18.34.24;	author kseitz;	state Exp;
branches;
next	1.55.2.4;

1.55.2.4
date	2002.08.30.22.52.44;	author kseitz;	state Exp;
branches;
next	1.55.2.5;

1.55.2.5
date	2002.10.01.00.46.09;	author kseitz;	state Exp;
branches;
next	1.55.2.6;

1.55.2.6
date	2002.11.04.00.17.31;	author ezannoni;	state Exp;
branches;
next	;

1.54.2.1
date	2002.06.15.16.42.52;	author cagney;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2002.06.21.16.19.25;	author cagney;	state Exp;
branches;
next	1.54.2.3;

1.54.2.3
date	2002.07.03.18.43.57;	author cagney;	state Exp;
branches;
next	;

1.52.2.1
date	2002.08.16.23.54.19;	author kevinb;	state Exp;
branches;
next	;

1.36.2.1
date	2001.07.30.21.22.10;	author kettenis;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.25;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.25.18.02.13;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.06.55;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.02.23.45.36;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.09.21.33.33;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.08.16.19.52.52;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.09.08.23.59.15;	author shebs;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.09.22.03.24.36;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.10.05.23.08.20;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.10.19.02.46.36;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.373
log
@gdb/

	* i386-tdep.c (i386_in_stack_tramp_p): Remove unused
	parameter 'gdbarch'.
	(i386_stack_tramp_frame_sniffer): Caller update.
	* i386-linux-tdep.c (i386_linux_core_read_xcr0): Remove
	parameter 'gdbarch' and 'target'.
	(i386_linux_core_read_description): Caller update.
	* amd64-linux-tdep.c (amd64_linux_core_read_description):
	Likewise.
	* i386-linux-tdep.h (i386_linux_core_read_xcr0): Update
	declaration.
@
text
@/* Intel 386 target-dependent stuff.

   Copyright (C) 1988-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "opcode/i386.h"
#include "arch-utils.h"
#include "command.h"
#include "dummy-frame.h"
#include "dwarf2-frame.h"
#include "doublest.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include "inferior.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "gdbtypes.h"
#include "objfiles.h"
#include "osabi.h"
#include "regcache.h"
#include "reggroups.h"
#include "regset.h"
#include "symfile.h"
#include "symtab.h"
#include "target.h"
#include "value.h"
#include "dis-asm.h"
#include "disasm.h"
#include "remote.h"
#include "exceptions.h"
#include "gdb_assert.h"
#include "gdb_string.h"

#include "i386-tdep.h"
#include "i387-tdep.h"
#include "i386-xstate.h"

#include "record.h"
#include "record-full.h"
#include <stdint.h>

#include "features/i386/i386.c"
#include "features/i386/i386-avx.c"
#include "features/i386/i386-mmx.c"

#include "ax.h"
#include "ax-gdb.h"

#include "stap-probe.h"
#include "user-regs.h"
#include "cli/cli-utils.h"
#include "expression.h"
#include "parser-defs.h"
#include <ctype.h>

/* Register names.  */

static const char *i386_register_names[] =
{
  "eax",   "ecx",    "edx",   "ebx",
  "esp",   "ebp",    "esi",   "edi",
  "eip",   "eflags", "cs",    "ss",
  "ds",    "es",     "fs",    "gs",
  "st0",   "st1",    "st2",   "st3",
  "st4",   "st5",    "st6",   "st7",
  "fctrl", "fstat",  "ftag",  "fiseg",
  "fioff", "foseg",  "fooff", "fop",
  "xmm0",  "xmm1",   "xmm2",  "xmm3",
  "xmm4",  "xmm5",   "xmm6",  "xmm7",
  "mxcsr"
};

static const char *i386_ymm_names[] =
{
  "ymm0",  "ymm1",   "ymm2",  "ymm3",
  "ymm4",  "ymm5",   "ymm6",  "ymm7",
};

static const char *i386_ymmh_names[] =
{
  "ymm0h",  "ymm1h",   "ymm2h",  "ymm3h",
  "ymm4h",  "ymm5h",   "ymm6h",  "ymm7h",
};

/* Register names for MMX pseudo-registers.  */

static const char *i386_mmx_names[] =
{
  "mm0", "mm1", "mm2", "mm3",
  "mm4", "mm5", "mm6", "mm7"
};

/* Register names for byte pseudo-registers.  */

static const char *i386_byte_names[] =
{
  "al", "cl", "dl", "bl", 
  "ah", "ch", "dh", "bh"
};

/* Register names for word pseudo-registers.  */

static const char *i386_word_names[] =
{
  "ax", "cx", "dx", "bx",
  "", "bp", "si", "di"
};

/* MMX register?  */

static int
i386_mmx_regnum_p (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int mm0_regnum = tdep->mm0_regnum;

  if (mm0_regnum < 0)
    return 0;

  regnum -= mm0_regnum;
  return regnum >= 0 && regnum < tdep->num_mmx_regs;
}

/* Byte register?  */

int
i386_byte_regnum_p (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  regnum -= tdep->al_regnum;
  return regnum >= 0 && regnum < tdep->num_byte_regs;
}

/* Word register?  */

int
i386_word_regnum_p (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  regnum -= tdep->ax_regnum;
  return regnum >= 0 && regnum < tdep->num_word_regs;
}

/* Dword register?  */

int
i386_dword_regnum_p (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int eax_regnum = tdep->eax_regnum;

  if (eax_regnum < 0)
    return 0;

  regnum -= eax_regnum;
  return regnum >= 0 && regnum < tdep->num_dword_regs;
}

static int
i386_ymmh_regnum_p (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int ymm0h_regnum = tdep->ymm0h_regnum;

  if (ymm0h_regnum < 0)
    return 0;

  regnum -= ymm0h_regnum;
  return regnum >= 0 && regnum < tdep->num_ymm_regs;
}

/* AVX register?  */

int
i386_ymm_regnum_p (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int ymm0_regnum = tdep->ymm0_regnum;

  if (ymm0_regnum < 0)
    return 0;

  regnum -= ymm0_regnum;
  return regnum >= 0 && regnum < tdep->num_ymm_regs;
}

/* SSE register?  */

int
i386_xmm_regnum_p (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int num_xmm_regs = I387_NUM_XMM_REGS (tdep);

  if (num_xmm_regs == 0)
    return 0;

  regnum -= I387_XMM0_REGNUM (tdep);
  return regnum >= 0 && regnum < num_xmm_regs;
}

static int
i386_mxcsr_regnum_p (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (I387_NUM_XMM_REGS (tdep) == 0)
    return 0;

  return (regnum == I387_MXCSR_REGNUM (tdep));
}

/* FP register?  */

int
i386_fp_regnum_p (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (I387_ST0_REGNUM (tdep) < 0)
    return 0;

  return (I387_ST0_REGNUM (tdep) <= regnum
	  && regnum < I387_FCTRL_REGNUM (tdep));
}

int
i386_fpc_regnum_p (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (I387_ST0_REGNUM (tdep) < 0)
    return 0;

  return (I387_FCTRL_REGNUM (tdep) <= regnum 
	  && regnum < I387_XMM0_REGNUM (tdep));
}

/* Return the name of register REGNUM, or the empty string if it is
   an anonymous register.  */

static const char *
i386_register_name (struct gdbarch *gdbarch, int regnum)
{
  /* Hide the upper YMM registers.  */
  if (i386_ymmh_regnum_p (gdbarch, regnum))
    return "";

  return tdesc_register_name (gdbarch, regnum);
}

/* Return the name of register REGNUM.  */

const char *
i386_pseudo_register_name (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  if (i386_mmx_regnum_p (gdbarch, regnum))
    return i386_mmx_names[regnum - I387_MM0_REGNUM (tdep)];
  else if (i386_ymm_regnum_p (gdbarch, regnum))
    return i386_ymm_names[regnum - tdep->ymm0_regnum];
  else if (i386_byte_regnum_p (gdbarch, regnum))
    return i386_byte_names[regnum - tdep->al_regnum];
  else if (i386_word_regnum_p (gdbarch, regnum))
    return i386_word_names[regnum - tdep->ax_regnum];

  internal_error (__FILE__, __LINE__, _("invalid regnum"));
}

/* Convert a dbx register number REG to the appropriate register
   number used by GDB.  */

static int
i386_dbx_reg_to_regnum (struct gdbarch *gdbarch, int reg)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* This implements what GCC calls the "default" register map
     (dbx_register_map[]).  */

  if (reg >= 0 && reg <= 7)
    {
      /* General-purpose registers.  The debug info calls %ebp
         register 4, and %esp register 5.  */
      if (reg == 4)
        return 5;
      else if (reg == 5)
        return 4;
      else return reg;
    }
  else if (reg >= 12 && reg <= 19)
    {
      /* Floating-point registers.  */
      return reg - 12 + I387_ST0_REGNUM (tdep);
    }
  else if (reg >= 21 && reg <= 28)
    {
      /* SSE registers.  */
      int ymm0_regnum = tdep->ymm0_regnum;

      if (ymm0_regnum >= 0
	  && i386_xmm_regnum_p (gdbarch, reg))
	return reg - 21 + ymm0_regnum;
      else
	return reg - 21 + I387_XMM0_REGNUM (tdep);
    }
  else if (reg >= 29 && reg <= 36)
    {
      /* MMX registers.  */
      return reg - 29 + I387_MM0_REGNUM (tdep);
    }

  /* This will hopefully provoke a warning.  */
  return gdbarch_num_regs (gdbarch) + gdbarch_num_pseudo_regs (gdbarch);
}

/* Convert SVR4 register number REG to the appropriate register number
   used by GDB.  */

static int
i386_svr4_reg_to_regnum (struct gdbarch *gdbarch, int reg)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* This implements the GCC register map that tries to be compatible
     with the SVR4 C compiler for DWARF (svr4_dbx_register_map[]).  */

  /* The SVR4 register numbering includes %eip and %eflags, and
     numbers the floating point registers differently.  */
  if (reg >= 0 && reg <= 9)
    {
      /* General-purpose registers.  */
      return reg;
    }
  else if (reg >= 11 && reg <= 18)
    {
      /* Floating-point registers.  */
      return reg - 11 + I387_ST0_REGNUM (tdep);
    }
  else if (reg >= 21 && reg <= 36)
    {
      /* The SSE and MMX registers have the same numbers as with dbx.  */
      return i386_dbx_reg_to_regnum (gdbarch, reg);
    }

  switch (reg)
    {
    case 37: return I387_FCTRL_REGNUM (tdep);
    case 38: return I387_FSTAT_REGNUM (tdep);
    case 39: return I387_MXCSR_REGNUM (tdep);
    case 40: return I386_ES_REGNUM;
    case 41: return I386_CS_REGNUM;
    case 42: return I386_SS_REGNUM;
    case 43: return I386_DS_REGNUM;
    case 44: return I386_FS_REGNUM;
    case 45: return I386_GS_REGNUM;
    }

  /* This will hopefully provoke a warning.  */
  return gdbarch_num_regs (gdbarch) + gdbarch_num_pseudo_regs (gdbarch);
}



/* This is the variable that is set with "set disassembly-flavor", and
   its legitimate values.  */
static const char att_flavor[] = "att";
static const char intel_flavor[] = "intel";
static const char *const valid_flavors[] =
{
  att_flavor,
  intel_flavor,
  NULL
};
static const char *disassembly_flavor = att_flavor;


/* Use the program counter to determine the contents and size of a
   breakpoint instruction.  Return a pointer to a string of bytes that
   encode a breakpoint instruction, store the length of the string in
   *LEN and optionally adjust *PC to point to the correct memory
   location for inserting the breakpoint.

   On the i386 we have a single breakpoint that fits in a single byte
   and can be inserted anywhere.

   This function is 64-bit safe.  */

static const gdb_byte *
i386_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pc, int *len)
{
  static gdb_byte break_insn[] = { 0xcc }; /* int 3 */

  *len = sizeof (break_insn);
  return break_insn;
}

/* Displaced instruction handling.  */

/* Skip the legacy instruction prefixes in INSN.
   Not all prefixes are valid for any particular insn
   but we needn't care, the insn will fault if it's invalid.
   The result is a pointer to the first opcode byte,
   or NULL if we run off the end of the buffer.  */

static gdb_byte *
i386_skip_prefixes (gdb_byte *insn, size_t max_len)
{
  gdb_byte *end = insn + max_len;

  while (insn < end)
    {
      switch (*insn)
	{
	case DATA_PREFIX_OPCODE:
	case ADDR_PREFIX_OPCODE:
	case CS_PREFIX_OPCODE:
	case DS_PREFIX_OPCODE:
	case ES_PREFIX_OPCODE:
	case FS_PREFIX_OPCODE:
	case GS_PREFIX_OPCODE:
	case SS_PREFIX_OPCODE:
	case LOCK_PREFIX_OPCODE:
	case REPE_PREFIX_OPCODE:
	case REPNE_PREFIX_OPCODE:
	  ++insn;
	  continue;
	default:
	  return insn;
	}
    }

  return NULL;
}

static int
i386_absolute_jmp_p (const gdb_byte *insn)
{
  /* jmp far (absolute address in operand).  */
  if (insn[0] == 0xea)
    return 1;

  if (insn[0] == 0xff)
    {
      /* jump near, absolute indirect (/4).  */
      if ((insn[1] & 0x38) == 0x20)
        return 1;

      /* jump far, absolute indirect (/5).  */
      if ((insn[1] & 0x38) == 0x28)
        return 1;
    }

  return 0;
}

static int
i386_absolute_call_p (const gdb_byte *insn)
{
  /* call far, absolute.  */
  if (insn[0] == 0x9a)
    return 1;

  if (insn[0] == 0xff)
    {
      /* Call near, absolute indirect (/2).  */
      if ((insn[1] & 0x38) == 0x10)
        return 1;

      /* Call far, absolute indirect (/3).  */
      if ((insn[1] & 0x38) == 0x18)
        return 1;
    }

  return 0;
}

static int
i386_ret_p (const gdb_byte *insn)
{
  switch (insn[0])
    {
    case 0xc2: /* ret near, pop N bytes.  */
    case 0xc3: /* ret near */
    case 0xca: /* ret far, pop N bytes.  */
    case 0xcb: /* ret far */
    case 0xcf: /* iret */
      return 1;

    default:
      return 0;
    }
}

static int
i386_call_p (const gdb_byte *insn)
{
  if (i386_absolute_call_p (insn))
    return 1;

  /* call near, relative.  */
  if (insn[0] == 0xe8)
    return 1;

  return 0;
}

/* Return non-zero if INSN is a system call, and set *LENGTHP to its
   length in bytes.  Otherwise, return zero.  */

static int
i386_syscall_p (const gdb_byte *insn, int *lengthp)
{
  /* Is it 'int $0x80'?  */
  if ((insn[0] == 0xcd && insn[1] == 0x80)
      /* Or is it 'sysenter'?  */
      || (insn[0] == 0x0f && insn[1] == 0x34)
      /* Or is it 'syscall'?  */
      || (insn[0] == 0x0f && insn[1] == 0x05))
    {
      *lengthp = 2;
      return 1;
    }

  return 0;
}

/* Some kernels may run one past a syscall insn, so we have to cope.
   Otherwise this is just simple_displaced_step_copy_insn.  */

struct displaced_step_closure *
i386_displaced_step_copy_insn (struct gdbarch *gdbarch,
			       CORE_ADDR from, CORE_ADDR to,
			       struct regcache *regs)
{
  size_t len = gdbarch_max_insn_length (gdbarch);
  gdb_byte *buf = xmalloc (len);

  read_memory (from, buf, len);

  /* GDB may get control back after the insn after the syscall.
     Presumably this is a kernel bug.
     If this is a syscall, make sure there's a nop afterwards.  */
  {
    int syscall_length;
    gdb_byte *insn;

    insn = i386_skip_prefixes (buf, len);
    if (insn != NULL && i386_syscall_p (insn, &syscall_length))
      insn[syscall_length] = NOP_OPCODE;
  }

  write_memory (to, buf, len);

  if (debug_displaced)
    {
      fprintf_unfiltered (gdb_stdlog, "displaced: copy %s->%s: ",
                          paddress (gdbarch, from), paddress (gdbarch, to));
      displaced_step_dump_bytes (gdb_stdlog, buf, len);
    }

  return (struct displaced_step_closure *) buf;
}

/* Fix up the state of registers and memory after having single-stepped
   a displaced instruction.  */

void
i386_displaced_step_fixup (struct gdbarch *gdbarch,
                           struct displaced_step_closure *closure,
                           CORE_ADDR from, CORE_ADDR to,
                           struct regcache *regs)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  /* The offset we applied to the instruction's address.
     This could well be negative (when viewed as a signed 32-bit
     value), but ULONGEST won't reflect that, so take care when
     applying it.  */
  ULONGEST insn_offset = to - from;

  /* Since we use simple_displaced_step_copy_insn, our closure is a
     copy of the instruction.  */
  gdb_byte *insn = (gdb_byte *) closure;
  /* The start of the insn, needed in case we see some prefixes.  */
  gdb_byte *insn_start = insn;

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
                        "displaced: fixup (%s, %s), "
                        "insn = 0x%02x 0x%02x ...\n",
                        paddress (gdbarch, from), paddress (gdbarch, to),
			insn[0], insn[1]);

  /* The list of issues to contend with here is taken from
     resume_execution in arch/i386/kernel/kprobes.c, Linux 2.6.20.
     Yay for Free Software!  */

  /* Relocate the %eip, if necessary.  */

  /* The instruction recognizers we use assume any leading prefixes
     have been skipped.  */
  {
    /* This is the size of the buffer in closure.  */
    size_t max_insn_len = gdbarch_max_insn_length (gdbarch);
    gdb_byte *opcode = i386_skip_prefixes (insn, max_insn_len);
    /* If there are too many prefixes, just ignore the insn.
       It will fault when run.  */
    if (opcode != NULL)
      insn = opcode;
  }

  /* Except in the case of absolute or indirect jump or call
     instructions, or a return instruction, the new eip is relative to
     the displaced instruction; make it relative.  Well, signal
     handler returns don't need relocation either, but we use the
     value of %eip to recognize those; see below.  */
  if (! i386_absolute_jmp_p (insn)
      && ! i386_absolute_call_p (insn)
      && ! i386_ret_p (insn))
    {
      ULONGEST orig_eip;
      int insn_len;

      regcache_cooked_read_unsigned (regs, I386_EIP_REGNUM, &orig_eip);

      /* A signal trampoline system call changes the %eip, resuming
         execution of the main program after the signal handler has
         returned.  That makes them like 'return' instructions; we
         shouldn't relocate %eip.

         But most system calls don't, and we do need to relocate %eip.

         Our heuristic for distinguishing these cases: if stepping
         over the system call instruction left control directly after
         the instruction, the we relocate --- control almost certainly
         doesn't belong in the displaced copy.  Otherwise, we assume
         the instruction has put control where it belongs, and leave
         it unrelocated.  Goodness help us if there are PC-relative
         system calls.  */
      if (i386_syscall_p (insn, &insn_len)
          && orig_eip != to + (insn - insn_start) + insn_len
	  /* GDB can get control back after the insn after the syscall.
	     Presumably this is a kernel bug.
	     i386_displaced_step_copy_insn ensures its a nop,
	     we add one to the length for it.  */
          && orig_eip != to + (insn - insn_start) + insn_len + 1)
        {
          if (debug_displaced)
            fprintf_unfiltered (gdb_stdlog,
                                "displaced: syscall changed %%eip; "
                                "not relocating\n");
        }
      else
        {
          ULONGEST eip = (orig_eip - insn_offset) & 0xffffffffUL;

	  /* If we just stepped over a breakpoint insn, we don't backup
	     the pc on purpose; this is to match behaviour without
	     stepping.  */

          regcache_cooked_write_unsigned (regs, I386_EIP_REGNUM, eip);

          if (debug_displaced)
            fprintf_unfiltered (gdb_stdlog,
                                "displaced: "
                                "relocated %%eip from %s to %s\n",
                                paddress (gdbarch, orig_eip),
				paddress (gdbarch, eip));
        }
    }

  /* If the instruction was PUSHFL, then the TF bit will be set in the
     pushed value, and should be cleared.  We'll leave this for later,
     since GDB already messes up the TF flag when stepping over a
     pushfl.  */

  /* If the instruction was a call, the return address now atop the
     stack is the address following the copied instruction.  We need
     to make it the address following the original instruction.  */
  if (i386_call_p (insn))
    {
      ULONGEST esp;
      ULONGEST retaddr;
      const ULONGEST retaddr_len = 4;

      regcache_cooked_read_unsigned (regs, I386_ESP_REGNUM, &esp);
      retaddr = read_memory_unsigned_integer (esp, retaddr_len, byte_order);
      retaddr = (retaddr - insn_offset) & 0xffffffffUL;
      write_memory_unsigned_integer (esp, retaddr_len, byte_order, retaddr);

      if (debug_displaced)
        fprintf_unfiltered (gdb_stdlog,
                            "displaced: relocated return addr at %s to %s\n",
                            paddress (gdbarch, esp),
                            paddress (gdbarch, retaddr));
    }
}

static void
append_insns (CORE_ADDR *to, ULONGEST len, const gdb_byte *buf)
{
  target_write_memory (*to, buf, len);
  *to += len;
}

static void
i386_relocate_instruction (struct gdbarch *gdbarch,
			   CORE_ADDR *to, CORE_ADDR oldloc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[I386_MAX_INSN_LEN];
  int offset = 0, rel32, newrel;
  int insn_length;
  gdb_byte *insn = buf;

  read_memory (oldloc, buf, I386_MAX_INSN_LEN);

  insn_length = gdb_buffered_insn_length (gdbarch, insn,
					  I386_MAX_INSN_LEN, oldloc);

  /* Get past the prefixes.  */
  insn = i386_skip_prefixes (insn, I386_MAX_INSN_LEN);

  /* Adjust calls with 32-bit relative addresses as push/jump, with
     the address pushed being the location where the original call in
     the user program would return to.  */
  if (insn[0] == 0xe8)
    {
      gdb_byte push_buf[16];
      unsigned int ret_addr;

      /* Where "ret" in the original code will return to.  */
      ret_addr = oldloc + insn_length;
      push_buf[0] = 0x68; /* pushq $...  */
      store_unsigned_integer (&push_buf[1], 4, byte_order, ret_addr);
      /* Push the push.  */
      append_insns (to, 5, push_buf);

      /* Convert the relative call to a relative jump.  */
      insn[0] = 0xe9;

      /* Adjust the destination offset.  */
      rel32 = extract_signed_integer (insn + 1, 4, byte_order);
      newrel = (oldloc - *to) + rel32;
      store_signed_integer (insn + 1, 4, byte_order, newrel);

      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog,
			    "Adjusted insn rel32=%s at %s to"
			    " rel32=%s at %s\n",
			    hex_string (rel32), paddress (gdbarch, oldloc),
			    hex_string (newrel), paddress (gdbarch, *to));

      /* Write the adjusted jump into its displaced location.  */
      append_insns (to, 5, insn);
      return;
    }

  /* Adjust jumps with 32-bit relative addresses.  Calls are already
     handled above.  */
  if (insn[0] == 0xe9)
    offset = 1;
  /* Adjust conditional jumps.  */
  else if (insn[0] == 0x0f && (insn[1] & 0xf0) == 0x80)
    offset = 2;

  if (offset)
    {
      rel32 = extract_signed_integer (insn + offset, 4, byte_order);
      newrel = (oldloc - *to) + rel32;
      store_signed_integer (insn + offset, 4, byte_order, newrel);
      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog,
			    "Adjusted insn rel32=%s at %s to"
			    " rel32=%s at %s\n",
			    hex_string (rel32), paddress (gdbarch, oldloc),
			    hex_string (newrel), paddress (gdbarch, *to));
    }

  /* Write the adjusted instructions into their displaced
     location.  */
  append_insns (to, insn_length, buf);
}


#ifdef I386_REGNO_TO_SYMMETRY
#error "The Sequent Symmetry is no longer supported."
#endif

/* According to the System V ABI, the registers %ebp, %ebx, %edi, %esi
   and %esp "belong" to the calling function.  Therefore these
   registers should be saved if they're going to be modified.  */

/* The maximum number of saved registers.  This should include all
   registers mentioned above, and %eip.  */
#define I386_NUM_SAVED_REGS	I386_NUM_GREGS

struct i386_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  int base_p;
  LONGEST sp_offset;
  CORE_ADDR pc;

  /* Saved registers.  */
  CORE_ADDR saved_regs[I386_NUM_SAVED_REGS];
  CORE_ADDR saved_sp;
  int saved_sp_reg;
  int pc_in_eax;

  /* Stack space reserved for local variables.  */
  long locals;
};

/* Allocate and initialize a frame cache.  */

static struct i386_frame_cache *
i386_alloc_frame_cache (void)
{
  struct i386_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct i386_frame_cache);

  /* Base address.  */
  cache->base_p = 0;
  cache->base = 0;
  cache->sp_offset = -4;
  cache->pc = 0;

  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %ebp is supposed to be stored).  */
  for (i = 0; i < I386_NUM_SAVED_REGS; i++)
    cache->saved_regs[i] = -1;
  cache->saved_sp = 0;
  cache->saved_sp_reg = -1;
  cache->pc_in_eax = 0;

  /* Frameless until proven otherwise.  */
  cache->locals = -1;

  return cache;
}

/* If the instruction at PC is a jump, return the address of its
   target.  Otherwise, return PC.  */

static CORE_ADDR
i386_follow_jump (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte op;
  long delta = 0;
  int data16 = 0;

  if (target_read_memory (pc, &op, 1))
    return pc;

  if (op == 0x66)
    {
      data16 = 1;
      op = read_memory_unsigned_integer (pc + 1, 1, byte_order);
    }

  switch (op)
    {
    case 0xe9:
      /* Relative jump: if data16 == 0, disp32, else disp16.  */
      if (data16)
	{
	  delta = read_memory_integer (pc + 2, 2, byte_order);

	  /* Include the size of the jmp instruction (including the
             0x66 prefix).  */
	  delta += 4;
	}
      else
	{
	  delta = read_memory_integer (pc + 1, 4, byte_order);

	  /* Include the size of the jmp instruction.  */
	  delta += 5;
	}
      break;
    case 0xeb:
      /* Relative jump, disp8 (ignore data16).  */
      delta = read_memory_integer (pc + data16 + 1, 1, byte_order);

      delta += data16 + 2;
      break;
    }

  return pc + delta;
}

/* Check whether PC points at a prologue for a function returning a
   structure or union.  If so, it updates CACHE and returns the
   address of the first instruction after the code sequence that
   removes the "hidden" argument from the stack or CURRENT_PC,
   whichever is smaller.  Otherwise, return PC.  */

static CORE_ADDR
i386_analyze_struct_return (CORE_ADDR pc, CORE_ADDR current_pc,
			    struct i386_frame_cache *cache)
{
  /* Functions that return a structure or union start with:

        popl %eax             0x58
        xchgl %eax, (%esp)    0x87 0x04 0x24
     or xchgl %eax, 0(%esp)   0x87 0x44 0x24 0x00

     (the System V compiler puts out the second `xchg' instruction,
     and the assembler doesn't try to optimize it, so the 'sib' form
     gets generated).  This sequence is used to get the address of the
     return buffer for a function that returns a structure.  */
  static gdb_byte proto1[3] = { 0x87, 0x04, 0x24 };
  static gdb_byte proto2[4] = { 0x87, 0x44, 0x24, 0x00 };
  gdb_byte buf[4];
  gdb_byte op;

  if (current_pc <= pc)
    return pc;

  if (target_read_memory (pc, &op, 1))
    return pc;

  if (op != 0x58)		/* popl %eax */
    return pc;

  if (target_read_memory (pc + 1, buf, 4))
    return pc;

  if (memcmp (buf, proto1, 3) != 0 && memcmp (buf, proto2, 4) != 0)
    return pc;

  if (current_pc == pc)
    {
      cache->sp_offset += 4;
      return current_pc;
    }

  if (current_pc == pc + 1)
    {
      cache->pc_in_eax = 1;
      return current_pc;
    }
  
  if (buf[1] == proto1[1])
    return pc + 4;
  else
    return pc + 5;
}

static CORE_ADDR
i386_skip_probe (CORE_ADDR pc)
{
  /* A function may start with

        pushl constant
        call _probe
	addl $4, %esp
	   
     followed by

        pushl %ebp

     etc.  */
  gdb_byte buf[8];
  gdb_byte op;

  if (target_read_memory (pc, &op, 1))
    return pc;

  if (op == 0x68 || op == 0x6a)
    {
      int delta;

      /* Skip past the `pushl' instruction; it has either a one-byte or a
	 four-byte operand, depending on the opcode.  */
      if (op == 0x68)
	delta = 5;
      else
	delta = 2;

      /* Read the following 8 bytes, which should be `call _probe' (6
	 bytes) followed by `addl $4,%esp' (2 bytes).  */
      read_memory (pc + delta, buf, sizeof (buf));
      if (buf[0] == 0xe8 && buf[6] == 0xc4 && buf[7] == 0x4)
	pc += delta + sizeof (buf);
    }

  return pc;
}

/* GCC 4.1 and later, can put code in the prologue to realign the
   stack pointer.  Check whether PC points to such code, and update
   CACHE accordingly.  Return the first instruction after the code
   sequence or CURRENT_PC, whichever is smaller.  If we don't
   recognize the code, return PC.  */

static CORE_ADDR
i386_analyze_stack_align (CORE_ADDR pc, CORE_ADDR current_pc,
			  struct i386_frame_cache *cache)
{
  /* There are 2 code sequences to re-align stack before the frame
     gets set up:

	1. Use a caller-saved saved register:

		leal  4(%esp), %reg
		andl  $-XXX, %esp
		pushl -4(%reg)

	2. Use a callee-saved saved register:

		pushl %reg
		leal  8(%esp), %reg
		andl  $-XXX, %esp
		pushl -4(%reg)

     "andl $-XXX, %esp" can be either 3 bytes or 6 bytes:
     
     	0x83 0xe4 0xf0			andl $-16, %esp
     	0x81 0xe4 0x00 0xff 0xff 0xff	andl $-256, %esp
   */

  gdb_byte buf[14];
  int reg;
  int offset, offset_and;
  static int regnums[8] = {
    I386_EAX_REGNUM,		/* %eax */
    I386_ECX_REGNUM,		/* %ecx */
    I386_EDX_REGNUM,		/* %edx */
    I386_EBX_REGNUM,		/* %ebx */
    I386_ESP_REGNUM,		/* %esp */
    I386_EBP_REGNUM,		/* %ebp */
    I386_ESI_REGNUM,		/* %esi */
    I386_EDI_REGNUM		/* %edi */
  };

  if (target_read_memory (pc, buf, sizeof buf))
    return pc;

  /* Check caller-saved saved register.  The first instruction has
     to be "leal 4(%esp), %reg".  */
  if (buf[0] == 0x8d && buf[2] == 0x24 && buf[3] == 0x4)
    {
      /* MOD must be binary 10 and R/M must be binary 100.  */
      if ((buf[1] & 0xc7) != 0x44)
	return pc;

      /* REG has register number.  */
      reg = (buf[1] >> 3) & 7;
      offset = 4;
    }
  else
    {
      /* Check callee-saved saved register.  The first instruction
	 has to be "pushl %reg".  */
      if ((buf[0] & 0xf8) != 0x50)
	return pc;

      /* Get register.  */
      reg = buf[0] & 0x7;

      /* The next instruction has to be "leal 8(%esp), %reg".  */
      if (buf[1] != 0x8d || buf[3] != 0x24 || buf[4] != 0x8)
	return pc;

      /* MOD must be binary 10 and R/M must be binary 100.  */
      if ((buf[2] & 0xc7) != 0x44)
	return pc;
      
      /* REG has register number.  Registers in pushl and leal have to
	 be the same.  */
      if (reg != ((buf[2] >> 3) & 7))
	return pc;

      offset = 5;
    }

  /* Rigister can't be %esp nor %ebp.  */
  if (reg == 4 || reg == 5)
    return pc;

  /* The next instruction has to be "andl $-XXX, %esp".  */
  if (buf[offset + 1] != 0xe4
      || (buf[offset] != 0x81 && buf[offset] != 0x83))
    return pc;

  offset_and = offset;
  offset += buf[offset] == 0x81 ? 6 : 3;

  /* The next instruction has to be "pushl -4(%reg)".  8bit -4 is
     0xfc.  REG must be binary 110 and MOD must be binary 01.  */
  if (buf[offset] != 0xff
      || buf[offset + 2] != 0xfc
      || (buf[offset + 1] & 0xf8) != 0x70)
    return pc;

  /* R/M has register.  Registers in leal and pushl have to be the
     same.  */
  if (reg != (buf[offset + 1] & 7))
    return pc;

  if (current_pc > pc + offset_and)
    cache->saved_sp_reg = regnums[reg];

  return min (pc + offset + 3, current_pc);
}

/* Maximum instruction length we need to handle.  */
#define I386_MAX_MATCHED_INSN_LEN	6

/* Instruction description.  */
struct i386_insn
{
  size_t len;
  gdb_byte insn[I386_MAX_MATCHED_INSN_LEN];
  gdb_byte mask[I386_MAX_MATCHED_INSN_LEN];
};

/* Return whether instruction at PC matches PATTERN.  */

static int
i386_match_pattern (CORE_ADDR pc, struct i386_insn pattern)
{
  gdb_byte op;

  if (target_read_memory (pc, &op, 1))
    return 0;

  if ((op & pattern.mask[0]) == pattern.insn[0])
    {
      gdb_byte buf[I386_MAX_MATCHED_INSN_LEN - 1];
      int insn_matched = 1;
      size_t i;

      gdb_assert (pattern.len > 1);
      gdb_assert (pattern.len <= I386_MAX_MATCHED_INSN_LEN);

      if (target_read_memory (pc + 1, buf, pattern.len - 1))
	return 0;

      for (i = 1; i < pattern.len; i++)
	{
	  if ((buf[i - 1] & pattern.mask[i]) != pattern.insn[i])
	    insn_matched = 0;
	}
      return insn_matched;
    }
  return 0;
}

/* Search for the instruction at PC in the list INSN_PATTERNS.  Return
   the first instruction description that matches.  Otherwise, return
   NULL.  */

static struct i386_insn *
i386_match_insn (CORE_ADDR pc, struct i386_insn *insn_patterns)
{
  struct i386_insn *pattern;

  for (pattern = insn_patterns; pattern->len > 0; pattern++)
    {
      if (i386_match_pattern (pc, *pattern))
	return pattern;
    }

  return NULL;
}

/* Return whether PC points inside a sequence of instructions that
   matches INSN_PATTERNS.  */

static int
i386_match_insn_block (CORE_ADDR pc, struct i386_insn *insn_patterns)
{
  CORE_ADDR current_pc;
  int ix, i;
  struct i386_insn *insn;

  insn = i386_match_insn (pc, insn_patterns);
  if (insn == NULL)
    return 0;

  current_pc = pc;
  ix = insn - insn_patterns;
  for (i = ix - 1; i >= 0; i--)
    {
      current_pc -= insn_patterns[i].len;

      if (!i386_match_pattern (current_pc, insn_patterns[i]))
	return 0;
    }

  current_pc = pc + insn->len;
  for (insn = insn_patterns + ix + 1; insn->len > 0; insn++)
    {
      if (!i386_match_pattern (current_pc, *insn))
	return 0;

      current_pc += insn->len;
    }

  return 1;
}

/* Some special instructions that might be migrated by GCC into the
   part of the prologue that sets up the new stack frame.  Because the
   stack frame hasn't been setup yet, no registers have been saved
   yet, and only the scratch registers %eax, %ecx and %edx can be
   touched.  */

struct i386_insn i386_frame_setup_skip_insns[] =
{
  /* Check for `movb imm8, r' and `movl imm32, r'.
    
     ??? Should we handle 16-bit operand-sizes here?  */

  /* `movb imm8, %al' and `movb imm8, %ah' */
  /* `movb imm8, %cl' and `movb imm8, %ch' */
  { 2, { 0xb0, 0x00 }, { 0xfa, 0x00 } },
  /* `movb imm8, %dl' and `movb imm8, %dh' */
  { 2, { 0xb2, 0x00 }, { 0xfb, 0x00 } },
  /* `movl imm32, %eax' and `movl imm32, %ecx' */
  { 5, { 0xb8 }, { 0xfe } },
  /* `movl imm32, %edx' */
  { 5, { 0xba }, { 0xff } },

  /* Check for `mov imm32, r32'.  Note that there is an alternative
     encoding for `mov m32, %eax'.

     ??? Should we handle SIB adressing here?
     ??? Should we handle 16-bit operand-sizes here?  */

  /* `movl m32, %eax' */
  { 5, { 0xa1 }, { 0xff } },
  /* `movl m32, %eax' and `mov; m32, %ecx' */
  { 6, { 0x89, 0x05 }, {0xff, 0xf7 } },
  /* `movl m32, %edx' */
  { 6, { 0x89, 0x15 }, {0xff, 0xff } },

  /* Check for `xorl r32, r32' and the equivalent `subl r32, r32'.
     Because of the symmetry, there are actually two ways to encode
     these instructions; opcode bytes 0x29 and 0x2b for `subl' and
     opcode bytes 0x31 and 0x33 for `xorl'.  */

  /* `subl %eax, %eax' */
  { 2, { 0x29, 0xc0 }, { 0xfd, 0xff } },
  /* `subl %ecx, %ecx' */
  { 2, { 0x29, 0xc9 }, { 0xfd, 0xff } },
  /* `subl %edx, %edx' */
  { 2, { 0x29, 0xd2 }, { 0xfd, 0xff } },
  /* `xorl %eax, %eax' */
  { 2, { 0x31, 0xc0 }, { 0xfd, 0xff } },
  /* `xorl %ecx, %ecx' */
  { 2, { 0x31, 0xc9 }, { 0xfd, 0xff } },
  /* `xorl %edx, %edx' */
  { 2, { 0x31, 0xd2 }, { 0xfd, 0xff } },
  { 0 }
};


/* Check whether PC points to a no-op instruction.  */
static CORE_ADDR
i386_skip_noop (CORE_ADDR pc)
{
  gdb_byte op;
  int check = 1;

  if (target_read_memory (pc, &op, 1))
    return pc;

  while (check) 
    {
      check = 0;
      /* Ignore `nop' instruction.  */
      if (op == 0x90) 
	{
	  pc += 1;
	  if (target_read_memory (pc, &op, 1))
	    return pc;
	  check = 1;
	}
      /* Ignore no-op instruction `mov %edi, %edi'.
	 Microsoft system dlls often start with
	 a `mov %edi,%edi' instruction.
	 The 5 bytes before the function start are
	 filled with `nop' instructions.
	 This pattern can be used for hot-patching:
	 The `mov %edi, %edi' instruction can be replaced by a
	 near jump to the location of the 5 `nop' instructions
	 which can be replaced by a 32-bit jump to anywhere
	 in the 32-bit address space.  */

      else if (op == 0x8b)
	{
	  if (target_read_memory (pc + 1, &op, 1))
	    return pc;

	  if (op == 0xff)
	    {
	      pc += 2;
	      if (target_read_memory (pc, &op, 1))
		return pc;

	      check = 1;
	    }
	}
    }
  return pc; 
}

/* Check whether PC points at a code that sets up a new stack frame.
   If so, it updates CACHE and returns the address of the first
   instruction after the sequence that sets up the frame or LIMIT,
   whichever is smaller.  If we don't recognize the code, return PC.  */

static CORE_ADDR
i386_analyze_frame_setup (struct gdbarch *gdbarch,
			  CORE_ADDR pc, CORE_ADDR limit,
			  struct i386_frame_cache *cache)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct i386_insn *insn;
  gdb_byte op;
  int skip = 0;

  if (limit <= pc)
    return limit;

  if (target_read_memory (pc, &op, 1))
    return pc;

  if (op == 0x55)		/* pushl %ebp */
    {
      /* Take into account that we've executed the `pushl %ebp' that
	 starts this instruction sequence.  */
      cache->saved_regs[I386_EBP_REGNUM] = 0;
      cache->sp_offset += 4;
      pc++;

      /* If that's all, return now.  */
      if (limit <= pc)
	return limit;

      /* Check for some special instructions that might be migrated by
	 GCC into the prologue and skip them.  At this point in the
	 prologue, code should only touch the scratch registers %eax,
	 %ecx and %edx, so while the number of posibilities is sheer,
	 it is limited.

	 Make sure we only skip these instructions if we later see the
	 `movl %esp, %ebp' that actually sets up the frame.  */
      while (pc + skip < limit)
	{
	  insn = i386_match_insn (pc + skip, i386_frame_setup_skip_insns);
	  if (insn == NULL)
	    break;

	  skip += insn->len;
	}

      /* If that's all, return now.  */
      if (limit <= pc + skip)
	return limit;

      if (target_read_memory (pc + skip, &op, 1))
	return pc + skip;

      /* The i386 prologue looks like

	 push   %ebp
	 mov    %esp,%ebp
	 sub    $0x10,%esp

	 and a different prologue can be generated for atom.

	 push   %ebp
	 lea    (%esp),%ebp
	 lea    -0x10(%esp),%esp

	 We handle both of them here.  */

      switch (op)
	{
	  /* Check for `movl %esp, %ebp' -- can be written in two ways.  */
	case 0x8b:
	  if (read_memory_unsigned_integer (pc + skip + 1, 1, byte_order)
	      != 0xec)
	    return pc;
	  pc += (skip + 2);
	  break;
	case 0x89:
	  if (read_memory_unsigned_integer (pc + skip + 1, 1, byte_order)
	      != 0xe5)
	    return pc;
	  pc += (skip + 2);
	  break;
	case 0x8d: /* Check for 'lea (%ebp), %ebp'.  */
	  if (read_memory_unsigned_integer (pc + skip + 1, 2, byte_order)
	      != 0x242c)
	    return pc;
	  pc += (skip + 3);
	  break;
	default:
	  return pc;
	}

      /* OK, we actually have a frame.  We just don't know how large
	 it is yet.  Set its size to zero.  We'll adjust it if
	 necessary.  We also now commit to skipping the special
	 instructions mentioned before.  */
      cache->locals = 0;

      /* If that's all, return now.  */
      if (limit <= pc)
	return limit;

      /* Check for stack adjustment 

	    subl $XXX, %esp
	 or
	    lea -XXX(%esp),%esp

	 NOTE: You can't subtract a 16-bit immediate from a 32-bit
	 reg, so we don't have to worry about a data16 prefix.  */
      if (target_read_memory (pc, &op, 1))
	return pc;
      if (op == 0x83)
	{
	  /* `subl' with 8-bit immediate.  */
	  if (read_memory_unsigned_integer (pc + 1, 1, byte_order) != 0xec)
	    /* Some instruction starting with 0x83 other than `subl'.  */
	    return pc;

	  /* `subl' with signed 8-bit immediate (though it wouldn't
	     make sense to be negative).  */
	  cache->locals = read_memory_integer (pc + 2, 1, byte_order);
	  return pc + 3;
	}
      else if (op == 0x81)
	{
	  /* Maybe it is `subl' with a 32-bit immediate.  */
	  if (read_memory_unsigned_integer (pc + 1, 1, byte_order) != 0xec)
	    /* Some instruction starting with 0x81 other than `subl'.  */
	    return pc;

	  /* It is `subl' with a 32-bit immediate.  */
	  cache->locals = read_memory_integer (pc + 2, 4, byte_order);
	  return pc + 6;
	}
      else if (op == 0x8d)
	{
	  /* The ModR/M byte is 0x64.  */
	  if (read_memory_unsigned_integer (pc + 1, 1, byte_order) != 0x64)
	    return pc;
	  /* 'lea' with 8-bit displacement.  */
	  cache->locals = -1 * read_memory_integer (pc + 3, 1, byte_order);
	  return pc + 4;
	}
      else
	{
	  /* Some instruction other than `subl' nor 'lea'.  */
	  return pc;
	}
    }
  else if (op == 0xc8)		/* enter */
    {
      cache->locals = read_memory_unsigned_integer (pc + 1, 2, byte_order);
      return pc + 4;
    }

  return pc;
}

/* Check whether PC points at code that saves registers on the stack.
   If so, it updates CACHE and returns the address of the first
   instruction after the register saves or CURRENT_PC, whichever is
   smaller.  Otherwise, return PC.  */

static CORE_ADDR
i386_analyze_register_saves (CORE_ADDR pc, CORE_ADDR current_pc,
			     struct i386_frame_cache *cache)
{
  CORE_ADDR offset = 0;
  gdb_byte op;
  int i;

  if (cache->locals > 0)
    offset -= cache->locals;
  for (i = 0; i < 8 && pc < current_pc; i++)
    {
      if (target_read_memory (pc, &op, 1))
	return pc;
      if (op < 0x50 || op > 0x57)
	break;

      offset -= 4;
      cache->saved_regs[op - 0x50] = offset;
      cache->sp_offset += 4;
      pc++;
    }

  return pc;
}

/* Do a full analysis of the prologue at PC and update CACHE
   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
   address where the analysis stopped.

   We handle these cases:

   The startup sequence can be at the start of the function, or the
   function can start with a branch to startup code at the end.

   %ebp can be set up with either the 'enter' instruction, or "pushl
   %ebp, movl %esp, %ebp" (`enter' is too slow to be useful, but was
   once used in the System V compiler).

   Local space is allocated just below the saved %ebp by either the
   'enter' instruction, or by "subl $<size>, %esp".  'enter' has a
   16-bit unsigned argument for space to allocate, and the 'addl'
   instruction could have either a signed byte, or 32-bit immediate.

   Next, the registers used by this function are pushed.  With the
   System V compiler they will always be in the order: %edi, %esi,
   %ebx (and sometimes a harmless bug causes it to also save but not
   restore %eax); however, the code below is willing to see the pushes
   in any order, and will handle up to 8 of them.
 
   If the setup sequence is at the end of the function, then the next
   instruction will be a branch back to the start.  */

static CORE_ADDR
i386_analyze_prologue (struct gdbarch *gdbarch,
		       CORE_ADDR pc, CORE_ADDR current_pc,
		       struct i386_frame_cache *cache)
{
  pc = i386_skip_noop (pc);
  pc = i386_follow_jump (gdbarch, pc);
  pc = i386_analyze_struct_return (pc, current_pc, cache);
  pc = i386_skip_probe (pc);
  pc = i386_analyze_stack_align (pc, current_pc, cache);
  pc = i386_analyze_frame_setup (gdbarch, pc, current_pc, cache);
  return i386_analyze_register_saves (pc, current_pc, cache);
}

/* Return PC of first real instruction.  */

static CORE_ADDR
i386_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  static gdb_byte pic_pat[6] =
  {
    0xe8, 0, 0, 0, 0,		/* call 0x0 */
    0x5b,			/* popl %ebx */
  };
  struct i386_frame_cache cache;
  CORE_ADDR pc;
  gdb_byte op;
  int i;
  CORE_ADDR func_addr;

  if (find_pc_partial_function (start_pc, NULL, &func_addr, NULL))
    {
      CORE_ADDR post_prologue_pc
	= skip_prologue_using_sal (gdbarch, func_addr);
      struct symtab *s = find_pc_symtab (func_addr);

      /* Clang always emits a line note before the prologue and another
	 one after.  We trust clang to emit usable line notes.  */
      if (post_prologue_pc
	  && (s != NULL
	      && s->producer != NULL
	      && strncmp (s->producer, "clang ", sizeof ("clang ") - 1) == 0))
        return max (start_pc, post_prologue_pc);
    }
 
  cache.locals = -1;
  pc = i386_analyze_prologue (gdbarch, start_pc, 0xffffffff, &cache);
  if (cache.locals < 0)
    return start_pc;

  /* Found valid frame setup.  */

  /* The native cc on SVR4 in -K PIC mode inserts the following code
     to get the address of the global offset table (GOT) into register
     %ebx:

        call	0x0
	popl    %ebx
        movl    %ebx,x(%ebp)    (optional)
        addl    y,%ebx

     This code is with the rest of the prologue (at the end of the
     function), so we have to skip it to get to the first real
     instruction at the start of the function.  */

  for (i = 0; i < 6; i++)
    {
      if (target_read_memory (pc + i, &op, 1))
	return pc;

      if (pic_pat[i] != op)
	break;
    }
  if (i == 6)
    {
      int delta = 6;

      if (target_read_memory (pc + delta, &op, 1))
	return pc;

      if (op == 0x89)		/* movl %ebx, x(%ebp) */
	{
	  op = read_memory_unsigned_integer (pc + delta + 1, 1, byte_order);

	  if (op == 0x5d)	/* One byte offset from %ebp.  */
	    delta += 3;
	  else if (op == 0x9d)	/* Four byte offset from %ebp.  */
	    delta += 6;
	  else			/* Unexpected instruction.  */
	    delta = 0;

          if (target_read_memory (pc + delta, &op, 1))
	    return pc;
	}

      /* addl y,%ebx */
      if (delta > 0 && op == 0x81
	  && read_memory_unsigned_integer (pc + delta + 1, 1, byte_order)
	     == 0xc3)
	{
	  pc += delta + 6;
	}
    }

  /* If the function starts with a branch (to startup code at the end)
     the last instruction should bring us back to the first
     instruction of the real code.  */
  if (i386_follow_jump (gdbarch, start_pc) != start_pc)
    pc = i386_follow_jump (gdbarch, pc);

  return pc;
}

/* Check that the code pointed to by PC corresponds to a call to
   __main, skip it if so.  Return PC otherwise.  */

CORE_ADDR
i386_skip_main_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte op;

  if (target_read_memory (pc, &op, 1))
    return pc;
  if (op == 0xe8)
    {
      gdb_byte buf[4];

      if (target_read_memory (pc + 1, buf, sizeof buf) == 0)
 	{
	  /* Make sure address is computed correctly as a 32bit
	     integer even if CORE_ADDR is 64 bit wide.  */
 	  struct bound_minimal_symbol s;
 	  CORE_ADDR call_dest;

	  call_dest = pc + 5 + extract_signed_integer (buf, 4, byte_order);
	  call_dest = call_dest & 0xffffffffU;
 	  s = lookup_minimal_symbol_by_pc (call_dest);
 	  if (s.minsym != NULL
 	      && SYMBOL_LINKAGE_NAME (s.minsym) != NULL
 	      && strcmp (SYMBOL_LINKAGE_NAME (s.minsym), "__main") == 0)
 	    pc += 5;
 	}
    }

  return pc;
}

/* This function is 64-bit safe.  */

static CORE_ADDR
i386_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  gdb_byte buf[8];

  frame_unwind_register (next_frame, gdbarch_pc_regnum (gdbarch), buf);
  return extract_typed_address (buf, builtin_type (gdbarch)->builtin_func_ptr);
}


/* Normal frames.  */

static void
i386_frame_cache_1 (struct frame_info *this_frame,
		    struct i386_frame_cache *cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[4];
  int i;

  cache->pc = get_frame_func (this_frame);

  /* In principle, for normal frames, %ebp holds the frame pointer,
     which holds the base address for the current stack frame.
     However, for functions that don't need it, the frame pointer is
     optional.  For these "frameless" functions the frame pointer is
     actually the frame pointer of the calling frame.  Signal
     trampolines are just a special case of a "frameless" function.
     They (usually) share their frame pointer with the frame that was
     in progress when the signal occurred.  */

  get_frame_register (this_frame, I386_EBP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4, byte_order);
  if (cache->base == 0)
    {
      cache->base_p = 1;
      return;
    }

  /* For normal frames, %eip is stored at 4(%ebp).  */
  cache->saved_regs[I386_EIP_REGNUM] = 4;

  if (cache->pc != 0)
    i386_analyze_prologue (gdbarch, cache->pc, get_frame_pc (this_frame),
			   cache);

  if (cache->locals < 0)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  If
	 we're at the start of a function, or somewhere half-way its
	 prologue, the function's frame probably hasn't been fully
	 setup yet.  Try to reconstruct the base address for the stack
	 frame by looking at the stack pointer.  For truly "frameless"
	 functions this might work too.  */

      if (cache->saved_sp_reg != -1)
	{
	  /* Saved stack pointer has been saved.  */
	  get_frame_register (this_frame, cache->saved_sp_reg, buf);
	  cache->saved_sp = extract_unsigned_integer (buf, 4, byte_order);

	  /* We're halfway aligning the stack.  */
	  cache->base = ((cache->saved_sp - 4) & 0xfffffff0) - 4;
	  cache->saved_regs[I386_EIP_REGNUM] = cache->saved_sp - 4;

	  /* This will be added back below.  */
	  cache->saved_regs[I386_EIP_REGNUM] -= cache->base;
	}
      else if (cache->pc != 0
	       || target_read_memory (get_frame_pc (this_frame), buf, 1))
	{
	  /* We're in a known function, but did not find a frame
	     setup.  Assume that the function does not use %ebp.
	     Alternatively, we may have jumped to an invalid
	     address; in that case there is definitely no new
	     frame in %ebp.  */
	  get_frame_register (this_frame, I386_ESP_REGNUM, buf);
	  cache->base = extract_unsigned_integer (buf, 4, byte_order)
			+ cache->sp_offset;
	}
      else
	/* We're in an unknown function.  We could not find the start
	   of the function to analyze the prologue; our best option is
	   to assume a typical frame layout with the caller's %ebp
	   saved.  */
	cache->saved_regs[I386_EBP_REGNUM] = 0;
    }

  if (cache->saved_sp_reg != -1)
    {
      /* Saved stack pointer has been saved (but the SAVED_SP_REG
	 register may be unavailable).  */
      if (cache->saved_sp == 0
	  && deprecated_frame_register_read (this_frame,
					     cache->saved_sp_reg, buf))
	cache->saved_sp = extract_unsigned_integer (buf, 4, byte_order);
    }
  /* Now that we have the base address for the stack frame we can
     calculate the value of %esp in the calling frame.  */
  else if (cache->saved_sp == 0)
    cache->saved_sp = cache->base + 8;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < I386_NUM_SAVED_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;

  cache->base_p = 1;
}

static struct i386_frame_cache *
i386_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  volatile struct gdb_exception ex;
  struct i386_frame_cache *cache;

  if (*this_cache)
    return *this_cache;

  cache = i386_alloc_frame_cache ();
  *this_cache = cache;

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      i386_frame_cache_1 (this_frame, cache);
    }
  if (ex.reason < 0 && ex.error != NOT_AVAILABLE_ERROR)
    throw_exception (ex);

  return cache;
}

static void
i386_frame_this_id (struct frame_info *this_frame, void **this_cache,
		    struct frame_id *this_id)
{
  struct i386_frame_cache *cache = i386_frame_cache (this_frame, this_cache);

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;

  /* See the end of i386_push_dummy_call.  */
  (*this_id) = frame_id_build (cache->base + 8, cache->pc);
}

static enum unwind_stop_reason
i386_frame_unwind_stop_reason (struct frame_info *this_frame,
			       void **this_cache)
{
  struct i386_frame_cache *cache = i386_frame_cache (this_frame, this_cache);

  if (!cache->base_p)
    return UNWIND_UNAVAILABLE;

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return UNWIND_OUTERMOST;

  return UNWIND_NO_REASON;
}

static struct value *
i386_frame_prev_register (struct frame_info *this_frame, void **this_cache,
			  int regnum)
{
  struct i386_frame_cache *cache = i386_frame_cache (this_frame, this_cache);

  gdb_assert (regnum >= 0);

  /* The System V ABI says that:

     "The flags register contains the system flags, such as the
     direction flag and the carry flag.  The direction flag must be
     set to the forward (that is, zero) direction before entry and
     upon exit from a function.  Other user flags have no specified
     role in the standard calling sequence and are not preserved."

     To guarantee the "upon exit" part of that statement we fake a
     saved flags register that has its direction flag cleared.

     Note that GCC doesn't seem to rely on the fact that the direction
     flag is cleared after a function return; it always explicitly
     clears the flag before operations where it matters.

     FIXME: kettenis/20030316: I'm not quite sure whether this is the
     right thing to do.  The way we fake the flags register here makes
     it impossible to change it.  */

  if (regnum == I386_EFLAGS_REGNUM)
    {
      ULONGEST val;

      val = get_frame_register_unsigned (this_frame, regnum);
      val &= ~(1 << 10);
      return frame_unwind_got_constant (this_frame, regnum, val);
    }

  if (regnum == I386_EIP_REGNUM && cache->pc_in_eax)
    return frame_unwind_got_register (this_frame, regnum, I386_EAX_REGNUM);

  if (regnum == I386_ESP_REGNUM
      && (cache->saved_sp != 0 || cache->saved_sp_reg != -1))
    {
      /* If the SP has been saved, but we don't know where, then this
	 means that SAVED_SP_REG register was found unavailable back
	 when we built the cache.  */
      if (cache->saved_sp == 0)
	return frame_unwind_got_register (this_frame, regnum,
					  cache->saved_sp_reg);
      else
	return frame_unwind_got_constant (this_frame, regnum,
					  cache->saved_sp);
    }

  if (regnum < I386_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
    return frame_unwind_got_memory (this_frame, regnum,
				    cache->saved_regs[regnum]);

  return frame_unwind_got_register (this_frame, regnum, regnum);
}

static const struct frame_unwind i386_frame_unwind =
{
  NORMAL_FRAME,
  i386_frame_unwind_stop_reason,
  i386_frame_this_id,
  i386_frame_prev_register,
  NULL,
  default_frame_sniffer
};

/* Normal frames, but in a function epilogue.  */

/* The epilogue is defined here as the 'ret' instruction, which will
   follow any instruction such as 'leave' or 'pop %ebp' that destroys
   the function's stack frame.  */

static int
i386_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  gdb_byte insn;
  struct symtab *symtab;

  symtab = find_pc_symtab (pc);
  if (symtab && symtab->epilogue_unwind_valid)
    return 0;

  if (target_read_memory (pc, &insn, 1))
    return 0;	/* Can't read memory at pc.  */

  if (insn != 0xc3)	/* 'ret' instruction.  */
    return 0;

  return 1;
}

static int
i386_epilogue_frame_sniffer (const struct frame_unwind *self,
			     struct frame_info *this_frame,
			     void **this_prologue_cache)
{
  if (frame_relative_level (this_frame) == 0)
    return i386_in_function_epilogue_p (get_frame_arch (this_frame),
					get_frame_pc (this_frame));
  else
    return 0;
}

static struct i386_frame_cache *
i386_epilogue_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  volatile struct gdb_exception ex;
  struct i386_frame_cache *cache;
  CORE_ADDR sp;

  if (*this_cache)
    return *this_cache;

  cache = i386_alloc_frame_cache ();
  *this_cache = cache;

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      cache->pc = get_frame_func (this_frame);

      /* At this point the stack looks as if we just entered the
	 function, with the return address at the top of the
	 stack.  */
      sp = get_frame_register_unsigned (this_frame, I386_ESP_REGNUM);
      cache->base = sp + cache->sp_offset;
      cache->saved_sp = cache->base + 8;
      cache->saved_regs[I386_EIP_REGNUM] = cache->base + 4;

      cache->base_p = 1;
    }
  if (ex.reason < 0 && ex.error != NOT_AVAILABLE_ERROR)
    throw_exception (ex);

  return cache;
}

static enum unwind_stop_reason
i386_epilogue_frame_unwind_stop_reason (struct frame_info *this_frame,
					void **this_cache)
{
  struct i386_frame_cache *cache =
    i386_epilogue_frame_cache (this_frame, this_cache);

  if (!cache->base_p)
    return UNWIND_UNAVAILABLE;

  return UNWIND_NO_REASON;
}

static void
i386_epilogue_frame_this_id (struct frame_info *this_frame,
			     void **this_cache,
			     struct frame_id *this_id)
{
  struct i386_frame_cache *cache =
    i386_epilogue_frame_cache (this_frame, this_cache);

  if (!cache->base_p)
    return;

  (*this_id) = frame_id_build (cache->base + 8, cache->pc);
}

static struct value *
i386_epilogue_frame_prev_register (struct frame_info *this_frame,
				   void **this_cache, int regnum)
{
  /* Make sure we've initialized the cache.  */
  i386_epilogue_frame_cache (this_frame, this_cache);

  return i386_frame_prev_register (this_frame, this_cache, regnum);
}

static const struct frame_unwind i386_epilogue_frame_unwind =
{
  NORMAL_FRAME,
  i386_epilogue_frame_unwind_stop_reason,
  i386_epilogue_frame_this_id,
  i386_epilogue_frame_prev_register,
  NULL, 
  i386_epilogue_frame_sniffer
};


/* Stack-based trampolines.  */

/* These trampolines are used on cross x86 targets, when taking the
   address of a nested function.  When executing these trampolines,
   no stack frame is set up, so we are in a similar situation as in
   epilogues and i386_epilogue_frame_this_id can be re-used.  */

/* Static chain passed in register.  */

struct i386_insn i386_tramp_chain_in_reg_insns[] =
{
  /* `movl imm32, %eax' and `movl imm32, %ecx' */
  { 5, { 0xb8 }, { 0xfe } },

  /* `jmp imm32' */
  { 5, { 0xe9 }, { 0xff } },

  {0}
};

/* Static chain passed on stack (when regparm=3).  */

struct i386_insn i386_tramp_chain_on_stack_insns[] =
{
  /* `push imm32' */
  { 5, { 0x68 }, { 0xff } },

  /* `jmp imm32' */
  { 5, { 0xe9 }, { 0xff } },

  {0}
};

/* Return whether PC points inside a stack trampoline.   */

static int
i386_in_stack_tramp_p (CORE_ADDR pc)
{
  gdb_byte insn;
  const char *name;

  /* A stack trampoline is detected if no name is associated
    to the current pc and if it points inside a trampoline
    sequence.  */

  find_pc_partial_function (pc, &name, NULL, NULL);
  if (name)
    return 0;

  if (target_read_memory (pc, &insn, 1))
    return 0;

  if (!i386_match_insn_block (pc, i386_tramp_chain_in_reg_insns)
      && !i386_match_insn_block (pc, i386_tramp_chain_on_stack_insns))
    return 0;

  return 1;
}

static int
i386_stack_tramp_frame_sniffer (const struct frame_unwind *self,
				struct frame_info *this_frame,
				void **this_cache)
{
  if (frame_relative_level (this_frame) == 0)
    return i386_in_stack_tramp_p (get_frame_pc (this_frame));
  else
    return 0;
}

static const struct frame_unwind i386_stack_tramp_frame_unwind =
{
  NORMAL_FRAME,
  i386_epilogue_frame_unwind_stop_reason,
  i386_epilogue_frame_this_id,
  i386_epilogue_frame_prev_register,
  NULL, 
  i386_stack_tramp_frame_sniffer
};

/* Generate a bytecode expression to get the value of the saved PC.  */

static void
i386_gen_return_address (struct gdbarch *gdbarch,
			 struct agent_expr *ax, struct axs_value *value,
			 CORE_ADDR scope)
{
  /* The following sequence assumes the traditional use of the base
     register.  */
  ax_reg (ax, I386_EBP_REGNUM);
  ax_const_l (ax, 4);
  ax_simple (ax, aop_add);
  value->type = register_type (gdbarch, I386_EIP_REGNUM);
  value->kind = axs_lvalue_memory;
}


/* Signal trampolines.  */

static struct i386_frame_cache *
i386_sigtramp_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  volatile struct gdb_exception ex;
  struct i386_frame_cache *cache;
  CORE_ADDR addr;
  gdb_byte buf[4];

  if (*this_cache)
    return *this_cache;

  cache = i386_alloc_frame_cache ();

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      get_frame_register (this_frame, I386_ESP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 4, byte_order) - 4;

      addr = tdep->sigcontext_addr (this_frame);
      if (tdep->sc_reg_offset)
	{
	  int i;

	  gdb_assert (tdep->sc_num_regs <= I386_NUM_SAVED_REGS);

	  for (i = 0; i < tdep->sc_num_regs; i++)
	    if (tdep->sc_reg_offset[i] != -1)
	      cache->saved_regs[i] = addr + tdep->sc_reg_offset[i];
	}
      else
	{
	  cache->saved_regs[I386_EIP_REGNUM] = addr + tdep->sc_pc_offset;
	  cache->saved_regs[I386_ESP_REGNUM] = addr + tdep->sc_sp_offset;
	}

      cache->base_p = 1;
    }
  if (ex.reason < 0 && ex.error != NOT_AVAILABLE_ERROR)
    throw_exception (ex);

  *this_cache = cache;
  return cache;
}

static enum unwind_stop_reason
i386_sigtramp_frame_unwind_stop_reason (struct frame_info *this_frame,
					void **this_cache)
{
  struct i386_frame_cache *cache =
    i386_sigtramp_frame_cache (this_frame, this_cache);

  if (!cache->base_p)
    return UNWIND_UNAVAILABLE;

  return UNWIND_NO_REASON;
}

static void
i386_sigtramp_frame_this_id (struct frame_info *this_frame, void **this_cache,
			     struct frame_id *this_id)
{
  struct i386_frame_cache *cache =
    i386_sigtramp_frame_cache (this_frame, this_cache);

  if (!cache->base_p)
    return;

  /* See the end of i386_push_dummy_call.  */
  (*this_id) = frame_id_build (cache->base + 8, get_frame_pc (this_frame));
}

static struct value *
i386_sigtramp_frame_prev_register (struct frame_info *this_frame,
				   void **this_cache, int regnum)
{
  /* Make sure we've initialized the cache.  */
  i386_sigtramp_frame_cache (this_frame, this_cache);

  return i386_frame_prev_register (this_frame, this_cache, regnum);
}

static int
i386_sigtramp_frame_sniffer (const struct frame_unwind *self,
			     struct frame_info *this_frame,
			     void **this_prologue_cache)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));

  /* We shouldn't even bother if we don't have a sigcontext_addr
     handler.  */
  if (tdep->sigcontext_addr == NULL)
    return 0;

  if (tdep->sigtramp_p != NULL)
    {
      if (tdep->sigtramp_p (this_frame))
	return 1;
    }

  if (tdep->sigtramp_start != 0)
    {
      CORE_ADDR pc = get_frame_pc (this_frame);

      gdb_assert (tdep->sigtramp_end != 0);
      if (pc >= tdep->sigtramp_start && pc < tdep->sigtramp_end)
	return 1;
    }

  return 0;
}

static const struct frame_unwind i386_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  i386_sigtramp_frame_unwind_stop_reason,
  i386_sigtramp_frame_this_id,
  i386_sigtramp_frame_prev_register,
  NULL,
  i386_sigtramp_frame_sniffer
};


static CORE_ADDR
i386_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct i386_frame_cache *cache = i386_frame_cache (this_frame, this_cache);

  return cache->base;
}

static const struct frame_base i386_frame_base =
{
  &i386_frame_unwind,
  i386_frame_base_address,
  i386_frame_base_address,
  i386_frame_base_address
};

static struct frame_id
i386_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  CORE_ADDR fp;

  fp = get_frame_register_unsigned (this_frame, I386_EBP_REGNUM);

  /* See the end of i386_push_dummy_call.  */
  return frame_id_build (fp + 8, get_frame_pc (this_frame));
}

/* _Decimal128 function return values need 16-byte alignment on the
   stack.  */

static CORE_ADDR
i386_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  return sp & -(CORE_ADDR)16;
}


/* Figure out where the longjmp will land.  Slurp the args out of the
   stack.  We expect the first arg to be a pointer to the jmp_buf
   structure from which we extract the address that we will land at.
   This address is copied into PC.  This routine returns non-zero on
   success.  */

static int
i386_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)
{
  gdb_byte buf[4];
  CORE_ADDR sp, jb_addr;
  struct gdbarch *gdbarch = get_frame_arch (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int jb_pc_offset = gdbarch_tdep (gdbarch)->jb_pc_offset;

  /* If JB_PC_OFFSET is -1, we have no way to find out where the
     longjmp will land.  */
  if (jb_pc_offset == -1)
    return 0;

  get_frame_register (frame, I386_ESP_REGNUM, buf);
  sp = extract_unsigned_integer (buf, 4, byte_order);
  if (target_read_memory (sp + 4, buf, 4))
    return 0;

  jb_addr = extract_unsigned_integer (buf, 4, byte_order);
  if (target_read_memory (jb_addr + jb_pc_offset, buf, 4))
    return 0;

  *pc = extract_unsigned_integer (buf, 4, byte_order);
  return 1;
}


/* Check whether TYPE must be 16-byte-aligned when passed as a
   function argument.  16-byte vectors, _Decimal128 and structures or
   unions containing such types must be 16-byte-aligned; other
   arguments are 4-byte-aligned.  */

static int
i386_16_byte_align_p (struct type *type)
{
  type = check_typedef (type);
  if ((TYPE_CODE (type) == TYPE_CODE_DECFLOAT
       || (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type)))
      && TYPE_LENGTH (type) == 16)
    return 1;
  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
    return i386_16_byte_align_p (TYPE_TARGET_TYPE (type));
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      || TYPE_CODE (type) == TYPE_CODE_UNION)
    {
      int i;
      for (i = 0; i < TYPE_NFIELDS (type); i++)
	{
	  if (i386_16_byte_align_p (TYPE_FIELD_TYPE (type, i)))
	    return 1;
	}
    }
  return 0;
}

/* Implementation for set_gdbarch_push_dummy_code.  */

static CORE_ADDR
i386_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp, CORE_ADDR funaddr,
		      struct value **args, int nargs, struct type *value_type,
		      CORE_ADDR *real_pc, CORE_ADDR *bp_addr,
		      struct regcache *regcache)
{
  /* Use 0xcc breakpoint - 1 byte.  */
  *bp_addr = sp - 1;
  *real_pc = funaddr;

  /* Keep the stack aligned.  */
  return sp - 16;
}

static CORE_ADDR
i386_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[4];
  int i;
  int write_pass;
  int args_space = 0;

  /* Determine the total space required for arguments and struct
     return address in a first pass (allowing for 16-byte-aligned
     arguments), then push arguments in a second pass.  */

  for (write_pass = 0; write_pass < 2; write_pass++)
    {
      int args_space_used = 0;

      if (struct_return)
	{
	  if (write_pass)
	    {
	      /* Push value address.  */
	      store_unsigned_integer (buf, 4, byte_order, struct_addr);
	      write_memory (sp, buf, 4);
	      args_space_used += 4;
	    }
	  else
	    args_space += 4;
	}

      for (i = 0; i < nargs; i++)
	{
	  int len = TYPE_LENGTH (value_enclosing_type (args[i]));

	  if (write_pass)
	    {
	      if (i386_16_byte_align_p (value_enclosing_type (args[i])))
		args_space_used = align_up (args_space_used, 16);

	      write_memory (sp + args_space_used,
			    value_contents_all (args[i]), len);
	      /* The System V ABI says that:

	      "An argument's size is increased, if necessary, to make it a
	      multiple of [32-bit] words.  This may require tail padding,
	      depending on the size of the argument."

	      This makes sure the stack stays word-aligned.  */
	      args_space_used += align_up (len, 4);
	    }
	  else
	    {
	      if (i386_16_byte_align_p (value_enclosing_type (args[i])))
		args_space = align_up (args_space, 16);
	      args_space += align_up (len, 4);
	    }
	}

      if (!write_pass)
	{
	  sp -= args_space;

	  /* The original System V ABI only requires word alignment,
	     but modern incarnations need 16-byte alignment in order
	     to support SSE.  Since wasting a few bytes here isn't
	     harmful we unconditionally enforce 16-byte alignment.  */
	  sp &= ~0xf;
	}
    }

  /* Store return address.  */
  sp -= 4;
  store_unsigned_integer (buf, 4, byte_order, bp_addr);
  write_memory (sp, buf, 4);

  /* Finally, update the stack pointer...  */
  store_unsigned_integer (buf, 4, byte_order, sp);
  regcache_cooked_write (regcache, I386_ESP_REGNUM, buf);

  /* ...and fake a frame pointer.  */
  regcache_cooked_write (regcache, I386_EBP_REGNUM, buf);

  /* MarkK wrote: This "+ 8" is all over the place:
     (i386_frame_this_id, i386_sigtramp_frame_this_id,
     i386_dummy_id).  It's there, since all frame unwinders for
     a given target have to agree (within a certain margin) on the
     definition of the stack address of a frame.  Otherwise frame id
     comparison might not work correctly.  Since DWARF2/GCC uses the
     stack address *before* the function call as a frame's CFA.  On
     the i386, when %ebp is used as a frame pointer, the offset
     between the contents %ebp and the CFA as defined by GCC.  */
  return sp + 8;
}

/* These registers are used for returning integers (and on some
   targets also for returning `struct' and `union' values when their
   size and alignment match an integer type).  */
#define LOW_RETURN_REGNUM	I386_EAX_REGNUM /* %eax */
#define HIGH_RETURN_REGNUM	I386_EDX_REGNUM /* %edx */

/* Read, for architecture GDBARCH, a function return value of TYPE
   from REGCACHE, and copy that into VALBUF.  */

static void
i386_extract_return_value (struct gdbarch *gdbarch, struct type *type,
			   struct regcache *regcache, gdb_byte *valbuf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int len = TYPE_LENGTH (type);
  gdb_byte buf[I386_MAX_REGISTER_SIZE];

  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    {
      if (tdep->st0_regnum < 0)
	{
	  warning (_("Cannot find floating-point return value."));
	  memset (valbuf, 0, len);
	  return;
	}

      /* Floating-point return values can be found in %st(0).  Convert
	 its contents to the desired type.  This is probably not
	 exactly how it would happen on the target itself, but it is
	 the best we can do.  */
      regcache_raw_read (regcache, I386_ST0_REGNUM, buf);
      convert_typed_floating (buf, i387_ext_type (gdbarch), valbuf, type);
    }
  else
    {
      int low_size = register_size (gdbarch, LOW_RETURN_REGNUM);
      int high_size = register_size (gdbarch, HIGH_RETURN_REGNUM);

      if (len <= low_size)
	{
	  regcache_raw_read (regcache, LOW_RETURN_REGNUM, buf);
	  memcpy (valbuf, buf, len);
	}
      else if (len <= (low_size + high_size))
	{
	  regcache_raw_read (regcache, LOW_RETURN_REGNUM, buf);
	  memcpy (valbuf, buf, low_size);
	  regcache_raw_read (regcache, HIGH_RETURN_REGNUM, buf);
	  memcpy (valbuf + low_size, buf, len - low_size);
	}
      else
	internal_error (__FILE__, __LINE__,
			_("Cannot extract return value of %d bytes long."),
			len);
    }
}

/* Write, for architecture GDBARCH, a function return value of TYPE
   from VALBUF into REGCACHE.  */

static void
i386_store_return_value (struct gdbarch *gdbarch, struct type *type,
			 struct regcache *regcache, const gdb_byte *valbuf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int len = TYPE_LENGTH (type);

  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    {
      ULONGEST fstat;
      gdb_byte buf[I386_MAX_REGISTER_SIZE];

      if (tdep->st0_regnum < 0)
	{
	  warning (_("Cannot set floating-point return value."));
	  return;
	}

      /* Returning floating-point values is a bit tricky.  Apart from
         storing the return value in %st(0), we have to simulate the
         state of the FPU at function return point.  */

      /* Convert the value found in VALBUF to the extended
	 floating-point format used by the FPU.  This is probably
	 not exactly how it would happen on the target itself, but
	 it is the best we can do.  */
      convert_typed_floating (valbuf, type, buf, i387_ext_type (gdbarch));
      regcache_raw_write (regcache, I386_ST0_REGNUM, buf);

      /* Set the top of the floating-point register stack to 7.  The
         actual value doesn't really matter, but 7 is what a normal
         function return would end up with if the program started out
         with a freshly initialized FPU.  */
      regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM (tdep), &fstat);
      fstat |= (7 << 11);
      regcache_raw_write_unsigned (regcache, I387_FSTAT_REGNUM (tdep), fstat);

      /* Mark %st(1) through %st(7) as empty.  Since we set the top of
         the floating-point register stack to 7, the appropriate value
         for the tag word is 0x3fff.  */
      regcache_raw_write_unsigned (regcache, I387_FTAG_REGNUM (tdep), 0x3fff);
    }
  else
    {
      int low_size = register_size (gdbarch, LOW_RETURN_REGNUM);
      int high_size = register_size (gdbarch, HIGH_RETURN_REGNUM);

      if (len <= low_size)
	regcache_raw_write_part (regcache, LOW_RETURN_REGNUM, 0, len, valbuf);
      else if (len <= (low_size + high_size))
	{
	  regcache_raw_write (regcache, LOW_RETURN_REGNUM, valbuf);
	  regcache_raw_write_part (regcache, HIGH_RETURN_REGNUM, 0,
				   len - low_size, valbuf + low_size);
	}
      else
	internal_error (__FILE__, __LINE__,
			_("Cannot store return value of %d bytes long."), len);
    }
}


/* This is the variable that is set with "set struct-convention", and
   its legitimate values.  */
static const char default_struct_convention[] = "default";
static const char pcc_struct_convention[] = "pcc";
static const char reg_struct_convention[] = "reg";
static const char *const valid_conventions[] =
{
  default_struct_convention,
  pcc_struct_convention,
  reg_struct_convention,
  NULL
};
static const char *struct_convention = default_struct_convention;

/* Return non-zero if TYPE, which is assumed to be a structure,
   a union type, or an array type, should be returned in registers
   for architecture GDBARCH.  */

static int
i386_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum type_code code = TYPE_CODE (type);
  int len = TYPE_LENGTH (type);

  gdb_assert (code == TYPE_CODE_STRUCT
              || code == TYPE_CODE_UNION
              || code == TYPE_CODE_ARRAY);

  if (struct_convention == pcc_struct_convention
      || (struct_convention == default_struct_convention
	  && tdep->struct_return == pcc_struct_return))
    return 0;

  /* Structures consisting of a single `float', `double' or 'long
     double' member are returned in %st(0).  */
  if (code == TYPE_CODE_STRUCT && TYPE_NFIELDS (type) == 1)
    {
      type = check_typedef (TYPE_FIELD_TYPE (type, 0));
      if (TYPE_CODE (type) == TYPE_CODE_FLT)
	return (len == 4 || len == 8 || len == 12);
    }

  return (len == 1 || len == 2 || len == 4 || len == 8);
}

/* Determine, for architecture GDBARCH, how a return value of TYPE
   should be returned.  If it is supposed to be returned in registers,
   and READBUF is non-zero, read the appropriate value from REGCACHE,
   and copy it into READBUF.  If WRITEBUF is non-zero, write the value
   from WRITEBUF into REGCACHE.  */

static enum return_value_convention
i386_return_value (struct gdbarch *gdbarch, struct value *function,
		   struct type *type, struct regcache *regcache,
		   gdb_byte *readbuf, const gdb_byte *writebuf)
{
  enum type_code code = TYPE_CODE (type);

  if (((code == TYPE_CODE_STRUCT
	|| code == TYPE_CODE_UNION
	|| code == TYPE_CODE_ARRAY)
       && !i386_reg_struct_return_p (gdbarch, type))
      /* Complex double and long double uses the struct return covention.  */
      || (code == TYPE_CODE_COMPLEX && TYPE_LENGTH (type) == 16)
      || (code == TYPE_CODE_COMPLEX && TYPE_LENGTH (type) == 24)
      /* 128-bit decimal float uses the struct return convention.  */
      || (code == TYPE_CODE_DECFLOAT && TYPE_LENGTH (type) == 16))
    {
      /* The System V ABI says that:

	 "A function that returns a structure or union also sets %eax
	 to the value of the original address of the caller's area
	 before it returns.  Thus when the caller receives control
	 again, the address of the returned object resides in register
	 %eax and can be used to access the object."

	 So the ABI guarantees that we can always find the return
	 value just after the function has returned.  */

      /* Note that the ABI doesn't mention functions returning arrays,
         which is something possible in certain languages such as Ada.
         In this case, the value is returned as if it was wrapped in
         a record, so the convention applied to records also applies
         to arrays.  */

      if (readbuf)
	{
	  ULONGEST addr;

	  regcache_raw_read_unsigned (regcache, I386_EAX_REGNUM, &addr);
	  read_memory (addr, readbuf, TYPE_LENGTH (type));
	}

      return RETURN_VALUE_ABI_RETURNS_ADDRESS;
    }

  /* This special case is for structures consisting of a single
     `float', `double' or 'long double' member.  These structures are
     returned in %st(0).  For these structures, we call ourselves
     recursively, changing TYPE into the type of the first member of
     the structure.  Since that should work for all structures that
     have only one member, we don't bother to check the member's type
     here.  */
  if (code == TYPE_CODE_STRUCT && TYPE_NFIELDS (type) == 1)
    {
      type = check_typedef (TYPE_FIELD_TYPE (type, 0));
      return i386_return_value (gdbarch, function, type, regcache,
				readbuf, writebuf);
    }

  if (readbuf)
    i386_extract_return_value (gdbarch, type, regcache, readbuf);
  if (writebuf)
    i386_store_return_value (gdbarch, type, regcache, writebuf);

  return RETURN_VALUE_REGISTER_CONVENTION;
}


struct type *
i387_ext_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->i387_ext_type)
    {
      tdep->i387_ext_type = tdesc_find_type (gdbarch, "i387_ext");
      gdb_assert (tdep->i387_ext_type != NULL);
    }

  return tdep->i387_ext_type;
}

/* Construct vector type for pseudo YMM registers.  We can't use
   tdesc_find_type since YMM isn't described in target description.  */

static struct type *
i386_ymm_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->i386_ymm_type)
    {
      const struct builtin_type *bt = builtin_type (gdbarch);

      /* The type we're building is this: */
#if 0
      union __gdb_builtin_type_vec256i
      {
        int128_t uint128[2];
        int64_t v2_int64[4];
        int32_t v4_int32[8];
        int16_t v8_int16[16];
        int8_t v16_int8[32];
        double v2_double[4];
        float v4_float[8];
      };
#endif

      struct type *t;

      t = arch_composite_type (gdbarch,
			       "__gdb_builtin_type_vec256i", TYPE_CODE_UNION);
      append_composite_type_field (t, "v8_float",
				   init_vector_type (bt->builtin_float, 8));
      append_composite_type_field (t, "v4_double",
				   init_vector_type (bt->builtin_double, 4));
      append_composite_type_field (t, "v32_int8",
				   init_vector_type (bt->builtin_int8, 32));
      append_composite_type_field (t, "v16_int16",
				   init_vector_type (bt->builtin_int16, 16));
      append_composite_type_field (t, "v8_int32",
				   init_vector_type (bt->builtin_int32, 8));
      append_composite_type_field (t, "v4_int64",
				   init_vector_type (bt->builtin_int64, 4));
      append_composite_type_field (t, "v2_int128",
				   init_vector_type (bt->builtin_int128, 2));

      TYPE_VECTOR (t) = 1;
      TYPE_NAME (t) = "builtin_type_vec256i";
      tdep->i386_ymm_type = t;
    }

  return tdep->i386_ymm_type;
}

/* Construct vector type for MMX registers.  */
static struct type *
i386_mmx_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->i386_mmx_type)
    {
      const struct builtin_type *bt = builtin_type (gdbarch);

      /* The type we're building is this: */
#if 0
      union __gdb_builtin_type_vec64i
      {
        int64_t uint64;
        int32_t v2_int32[2];
        int16_t v4_int16[4];
        int8_t v8_int8[8];
      };
#endif

      struct type *t;

      t = arch_composite_type (gdbarch,
			       "__gdb_builtin_type_vec64i", TYPE_CODE_UNION);

      append_composite_type_field (t, "uint64", bt->builtin_int64);
      append_composite_type_field (t, "v2_int32",
				   init_vector_type (bt->builtin_int32, 2));
      append_composite_type_field (t, "v4_int16",
				   init_vector_type (bt->builtin_int16, 4));
      append_composite_type_field (t, "v8_int8",
				   init_vector_type (bt->builtin_int8, 8));

      TYPE_VECTOR (t) = 1;
      TYPE_NAME (t) = "builtin_type_vec64i";
      tdep->i386_mmx_type = t;
    }

  return tdep->i386_mmx_type;
}

/* Return the GDB type object for the "standard" data type of data in
   register REGNUM.  */

struct type *
i386_pseudo_register_type (struct gdbarch *gdbarch, int regnum)
{
  if (i386_mmx_regnum_p (gdbarch, regnum))
    return i386_mmx_type (gdbarch);
  else if (i386_ymm_regnum_p (gdbarch, regnum))
    return i386_ymm_type (gdbarch);
  else
    {
      const struct builtin_type *bt = builtin_type (gdbarch);
      if (i386_byte_regnum_p (gdbarch, regnum))
	return bt->builtin_int8;
      else if (i386_word_regnum_p (gdbarch, regnum))
	return bt->builtin_int16;
      else if (i386_dword_regnum_p (gdbarch, regnum))
	return bt->builtin_int32;
    }

  internal_error (__FILE__, __LINE__, _("invalid regnum"));
}

/* Map a cooked register onto a raw register or memory.  For the i386,
   the MMX registers need to be mapped onto floating point registers.  */

static int
i386_mmx_regnum_to_fp_regnum (struct regcache *regcache, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  int mmxreg, fpreg;
  ULONGEST fstat;
  int tos;

  mmxreg = regnum - tdep->mm0_regnum;
  regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM (tdep), &fstat);
  tos = (fstat >> 11) & 0x7;
  fpreg = (mmxreg + tos) % 8;

  return (I387_ST0_REGNUM (tdep) + fpreg);
}

/* A helper function for us by i386_pseudo_register_read_value and
   amd64_pseudo_register_read_value.  It does all the work but reads
   the data into an already-allocated value.  */

void
i386_pseudo_register_read_into_value (struct gdbarch *gdbarch,
				      struct regcache *regcache,
				      int regnum,
				      struct value *result_value)
{
  gdb_byte raw_buf[MAX_REGISTER_SIZE];
  enum register_status status;
  gdb_byte *buf = value_contents_raw (result_value);

  if (i386_mmx_regnum_p (gdbarch, regnum))
    {
      int fpnum = i386_mmx_regnum_to_fp_regnum (regcache, regnum);

      /* Extract (always little endian).  */
      status = regcache_raw_read (regcache, fpnum, raw_buf);
      if (status != REG_VALID)
	mark_value_bytes_unavailable (result_value, 0,
				      TYPE_LENGTH (value_type (result_value)));
      else
	memcpy (buf, raw_buf, register_size (gdbarch, regnum));
    }
  else
    {
      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

      if (i386_ymm_regnum_p (gdbarch, regnum))
	{
	  regnum -= tdep->ymm0_regnum;

	  /* Extract (always little endian).  Read lower 128bits.  */
	  status = regcache_raw_read (regcache,
				      I387_XMM0_REGNUM (tdep) + regnum,
				      raw_buf);
	  if (status != REG_VALID)
	    mark_value_bytes_unavailable (result_value, 0, 16);
	  else
	    memcpy (buf, raw_buf, 16);
	  /* Read upper 128bits.  */
	  status = regcache_raw_read (regcache,
				      tdep->ymm0h_regnum + regnum,
				      raw_buf);
	  if (status != REG_VALID)
	    mark_value_bytes_unavailable (result_value, 16, 32);
	  else
	    memcpy (buf + 16, raw_buf, 16);
	}
      else if (i386_word_regnum_p (gdbarch, regnum))
	{
	  int gpnum = regnum - tdep->ax_regnum;

	  /* Extract (always little endian).  */
	  status = regcache_raw_read (regcache, gpnum, raw_buf);
	  if (status != REG_VALID)
	    mark_value_bytes_unavailable (result_value, 0,
					  TYPE_LENGTH (value_type (result_value)));
	  else
	    memcpy (buf, raw_buf, 2);
	}
      else if (i386_byte_regnum_p (gdbarch, regnum))
	{
	  /* Check byte pseudo registers last since this function will
	     be called from amd64_pseudo_register_read, which handles
	     byte pseudo registers differently.  */
	  int gpnum = regnum - tdep->al_regnum;

	  /* Extract (always little endian).  We read both lower and
	     upper registers.  */
	  status = regcache_raw_read (regcache, gpnum % 4, raw_buf);
	  if (status != REG_VALID)
	    mark_value_bytes_unavailable (result_value, 0,
					  TYPE_LENGTH (value_type (result_value)));
	  else if (gpnum >= 4)
	    memcpy (buf, raw_buf + 1, 1);
	  else
	    memcpy (buf, raw_buf, 1);
	}
      else
	internal_error (__FILE__, __LINE__, _("invalid regnum"));
    }
}

static struct value *
i386_pseudo_register_read_value (struct gdbarch *gdbarch,
				 struct regcache *regcache,
				 int regnum)
{
  struct value *result;

  result = allocate_value (register_type (gdbarch, regnum));
  VALUE_LVAL (result) = lval_register;
  VALUE_REGNUM (result) = regnum;

  i386_pseudo_register_read_into_value (gdbarch, regcache, regnum, result);

  return result;
}

void
i386_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int regnum, const gdb_byte *buf)
{
  gdb_byte raw_buf[MAX_REGISTER_SIZE];

  if (i386_mmx_regnum_p (gdbarch, regnum))
    {
      int fpnum = i386_mmx_regnum_to_fp_regnum (regcache, regnum);

      /* Read ...  */
      regcache_raw_read (regcache, fpnum, raw_buf);
      /* ... Modify ... (always little endian).  */
      memcpy (raw_buf, buf, register_size (gdbarch, regnum));
      /* ... Write.  */
      regcache_raw_write (regcache, fpnum, raw_buf);
    }
  else
    {
      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

      if (i386_ymm_regnum_p (gdbarch, regnum))
	{
	  regnum -= tdep->ymm0_regnum;

	  /* ... Write lower 128bits.  */
	  regcache_raw_write (regcache,
			     I387_XMM0_REGNUM (tdep) + regnum,
			     buf);
	  /* ... Write upper 128bits.  */
	  regcache_raw_write (regcache,
			     tdep->ymm0h_regnum + regnum,
			     buf + 16);
	}
      else if (i386_word_regnum_p (gdbarch, regnum))
	{
	  int gpnum = regnum - tdep->ax_regnum;

	  /* Read ...  */
	  regcache_raw_read (regcache, gpnum, raw_buf);
	  /* ... Modify ... (always little endian).  */
	  memcpy (raw_buf, buf, 2);
	  /* ... Write.  */
	  regcache_raw_write (regcache, gpnum, raw_buf);
	}
      else if (i386_byte_regnum_p (gdbarch, regnum))
	{
	  /* Check byte pseudo registers last since this function will
	     be called from amd64_pseudo_register_read, which handles
	     byte pseudo registers differently.  */
	  int gpnum = regnum - tdep->al_regnum;

	  /* Read ...  We read both lower and upper registers.  */
	  regcache_raw_read (regcache, gpnum % 4, raw_buf);
	  /* ... Modify ... (always little endian).  */
	  if (gpnum >= 4)
	    memcpy (raw_buf + 1, buf, 1);
	  else
	    memcpy (raw_buf, buf, 1);
	  /* ... Write.  */
	  regcache_raw_write (regcache, gpnum % 4, raw_buf);
	}
      else
	internal_error (__FILE__, __LINE__, _("invalid regnum"));
    }
}


/* Return the register number of the register allocated by GCC after
   REGNUM, or -1 if there is no such register.  */

static int
i386_next_regnum (int regnum)
{
  /* GCC allocates the registers in the order:

     %eax, %edx, %ecx, %ebx, %esi, %edi, %ebp, %esp, ...

     Since storing a variable in %esp doesn't make any sense we return
     -1 for %ebp and for %esp itself.  */
  static int next_regnum[] =
  {
    I386_EDX_REGNUM,		/* Slot for %eax.  */
    I386_EBX_REGNUM,		/* Slot for %ecx.  */
    I386_ECX_REGNUM,		/* Slot for %edx.  */
    I386_ESI_REGNUM,		/* Slot for %ebx.  */
    -1, -1,			/* Slots for %esp and %ebp.  */
    I386_EDI_REGNUM,		/* Slot for %esi.  */
    I386_EBP_REGNUM		/* Slot for %edi.  */
  };

  if (regnum >= 0 && regnum < sizeof (next_regnum) / sizeof (next_regnum[0]))
    return next_regnum[regnum];

  return -1;
}

/* Return nonzero if a value of type TYPE stored in register REGNUM
   needs any special handling.  */

static int
i386_convert_register_p (struct gdbarch *gdbarch,
			 int regnum, struct type *type)
{
  int len = TYPE_LENGTH (type);

  /* Values may be spread across multiple registers.  Most debugging
     formats aren't expressive enough to specify the locations, so
     some heuristics is involved.  Right now we only handle types that
     have a length that is a multiple of the word size, since GCC
     doesn't seem to put any other types into registers.  */
  if (len > 4 && len % 4 == 0)
    {
      int last_regnum = regnum;

      while (len > 4)
	{
	  last_regnum = i386_next_regnum (last_regnum);
	  len -= 4;
	}

      if (last_regnum != -1)
	return 1;
    }

  return i387_convert_register_p (gdbarch, regnum, type);
}

/* Read a value of type TYPE from register REGNUM in frame FRAME, and
   return its contents in TO.  */

static int
i386_register_to_value (struct frame_info *frame, int regnum,
			struct type *type, gdb_byte *to,
			int *optimizedp, int *unavailablep)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int len = TYPE_LENGTH (type);

  if (i386_fp_regnum_p (gdbarch, regnum))
    return i387_register_to_value (frame, regnum, type, to,
				   optimizedp, unavailablep);

  /* Read a value spread across multiple registers.  */

  gdb_assert (len > 4 && len % 4 == 0);

  while (len > 0)
    {
      gdb_assert (regnum != -1);
      gdb_assert (register_size (gdbarch, regnum) == 4);

      if (!get_frame_register_bytes (frame, regnum, 0,
				     register_size (gdbarch, regnum),
				     to, optimizedp, unavailablep))
	return 0;

      regnum = i386_next_regnum (regnum);
      len -= 4;
      to += 4;
    }

  *optimizedp = *unavailablep = 0;
  return 1;
}

/* Write the contents FROM of a value of type TYPE into register
   REGNUM in frame FRAME.  */

static void
i386_value_to_register (struct frame_info *frame, int regnum,
			struct type *type, const gdb_byte *from)
{
  int len = TYPE_LENGTH (type);

  if (i386_fp_regnum_p (get_frame_arch (frame), regnum))
    {
      i387_value_to_register (frame, regnum, type, from);
      return;
    }

  /* Write a value spread across multiple registers.  */

  gdb_assert (len > 4 && len % 4 == 0);

  while (len > 0)
    {
      gdb_assert (regnum != -1);
      gdb_assert (register_size (get_frame_arch (frame), regnum) == 4);

      put_frame_register (frame, regnum, from);
      regnum = i386_next_regnum (regnum);
      len -= 4;
      from += 4;
    }
}

/* Supply register REGNUM from the buffer specified by GREGS and LEN
   in the general-purpose register set REGSET to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */

void
i386_supply_gregset (const struct regset *regset, struct regcache *regcache,
		     int regnum, const void *gregs, size_t len)
{
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
  const gdb_byte *regs = gregs;
  int i;

  gdb_assert (len == tdep->sizeof_gregset);

  for (i = 0; i < tdep->gregset_num_regs; i++)
    {
      if ((regnum == i || regnum == -1)
	  && tdep->gregset_reg_offset[i] != -1)
	regcache_raw_supply (regcache, i, regs + tdep->gregset_reg_offset[i]);
    }
}

/* Collect register REGNUM from the register cache REGCACHE and store
   it in the buffer specified by GREGS and LEN as described by the
   general-purpose register set REGSET.  If REGNUM is -1, do this for
   all registers in REGSET.  */

void
i386_collect_gregset (const struct regset *regset,
		      const struct regcache *regcache,
		      int regnum, void *gregs, size_t len)
{
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
  gdb_byte *regs = gregs;
  int i;

  gdb_assert (len == tdep->sizeof_gregset);

  for (i = 0; i < tdep->gregset_num_regs; i++)
    {
      if ((regnum == i || regnum == -1)
	  && tdep->gregset_reg_offset[i] != -1)
	regcache_raw_collect (regcache, i, regs + tdep->gregset_reg_offset[i]);
    }
}

/* Supply register REGNUM from the buffer specified by FPREGS and LEN
   in the floating-point register set REGSET to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */

static void
i386_supply_fpregset (const struct regset *regset, struct regcache *regcache,
		      int regnum, const void *fpregs, size_t len)
{
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);

  if (len == I387_SIZEOF_FXSAVE)
    {
      i387_supply_fxsave (regcache, regnum, fpregs);
      return;
    }

  gdb_assert (len == tdep->sizeof_fpregset);
  i387_supply_fsave (regcache, regnum, fpregs);
}

/* Collect register REGNUM from the register cache REGCACHE and store
   it in the buffer specified by FPREGS and LEN as described by the
   floating-point register set REGSET.  If REGNUM is -1, do this for
   all registers in REGSET.  */

static void
i386_collect_fpregset (const struct regset *regset,
		       const struct regcache *regcache,
		       int regnum, void *fpregs, size_t len)
{
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);

  if (len == I387_SIZEOF_FXSAVE)
    {
      i387_collect_fxsave (regcache, regnum, fpregs);
      return;
    }

  gdb_assert (len == tdep->sizeof_fpregset);
  i387_collect_fsave (regcache, regnum, fpregs);
}

/* Similar to i386_supply_fpregset, but use XSAVE extended state.  */

static void
i386_supply_xstateregset (const struct regset *regset,
			  struct regcache *regcache, int regnum,
			  const void *xstateregs, size_t len)
{
  i387_supply_xsave (regcache, regnum, xstateregs);
}

/* Similar to i386_collect_fpregset , but use XSAVE extended state.  */

static void
i386_collect_xstateregset (const struct regset *regset,
			   const struct regcache *regcache,
			   int regnum, void *xstateregs, size_t len)
{
  i387_collect_xsave (regcache, regnum, xstateregs, 1);
}

/* Return the appropriate register set for the core section identified
   by SECT_NAME and SECT_SIZE.  */

const struct regset *
i386_regset_from_core_section (struct gdbarch *gdbarch,
			       const char *sect_name, size_t sect_size)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (strcmp (sect_name, ".reg") == 0 && sect_size == tdep->sizeof_gregset)
    {
      if (tdep->gregset == NULL)
	tdep->gregset = regset_alloc (gdbarch, i386_supply_gregset,
				      i386_collect_gregset);
      return tdep->gregset;
    }

  if ((strcmp (sect_name, ".reg2") == 0 && sect_size == tdep->sizeof_fpregset)
      || (strcmp (sect_name, ".reg-xfp") == 0
	  && sect_size == I387_SIZEOF_FXSAVE))
    {
      if (tdep->fpregset == NULL)
	tdep->fpregset = regset_alloc (gdbarch, i386_supply_fpregset,
				       i386_collect_fpregset);
      return tdep->fpregset;
    }

  if (strcmp (sect_name, ".reg-xstate") == 0)
    {
      if (tdep->xstateregset == NULL)
	tdep->xstateregset = regset_alloc (gdbarch,
					   i386_supply_xstateregset,
					   i386_collect_xstateregset);

      return tdep->xstateregset;
    }

  return NULL;
}


/* Stuff for WIN32 PE style DLL's but is pretty generic really.  */

CORE_ADDR
i386_pe_skip_trampoline_code (struct frame_info *frame,
			      CORE_ADDR pc, char *name)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  /* jmp *(dest) */
  if (pc && read_memory_unsigned_integer (pc, 2, byte_order) == 0x25ff)
    {
      unsigned long indirect =
	read_memory_unsigned_integer (pc + 2, 4, byte_order);
      struct minimal_symbol *indsym =
	indirect ? lookup_minimal_symbol_by_pc (indirect).minsym : 0;
      const char *symname = indsym ? SYMBOL_LINKAGE_NAME (indsym) : 0;

      if (symname)
	{
	  if (strncmp (symname, "__imp_", 6) == 0
	      || strncmp (symname, "_imp_", 5) == 0)
	    return name ? 1 :
		   read_memory_unsigned_integer (indirect, 4, byte_order);
	}
    }
  return 0;			/* Not a trampoline.  */
}


/* Return whether the THIS_FRAME corresponds to a sigtramp
   routine.  */

int
i386_sigtramp_p (struct frame_info *this_frame)
{
  CORE_ADDR pc = get_frame_pc (this_frame);
  const char *name;

  find_pc_partial_function (pc, &name, NULL, NULL);
  return (name && strcmp ("_sigtramp", name) == 0);
}


/* We have two flavours of disassembly.  The machinery on this page
   deals with switching between those.  */

static int
i386_print_insn (bfd_vma pc, struct disassemble_info *info)
{
  gdb_assert (disassembly_flavor == att_flavor
	      || disassembly_flavor == intel_flavor);

  /* FIXME: kettenis/20020915: Until disassembler_options is properly
     constified, cast to prevent a compiler warning.  */
  info->disassembler_options = (char *) disassembly_flavor;

  return print_insn_i386 (pc, info);
}


/* There are a few i386 architecture variants that differ only
   slightly from the generic i386 target.  For now, we don't give them
   their own source file, but include them here.  As a consequence,
   they'll always be included.  */

/* System V Release 4 (SVR4).  */

/* Return whether THIS_FRAME corresponds to a SVR4 sigtramp
   routine.  */

static int
i386_svr4_sigtramp_p (struct frame_info *this_frame)
{
  CORE_ADDR pc = get_frame_pc (this_frame);
  const char *name;

  /* The origin of these symbols is currently unknown.  */
  find_pc_partial_function (pc, &name, NULL, NULL);
  return (name && (strcmp ("_sigreturn", name) == 0
		   || strcmp ("sigvechandler", name) == 0));
}

/* Assuming THIS_FRAME is for a SVR4 sigtramp routine, return the
   address of the associated sigcontext (ucontext) structure.  */

static CORE_ADDR
i386_svr4_sigcontext_addr (struct frame_info *this_frame)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[4];
  CORE_ADDR sp;

  get_frame_register (this_frame, I386_ESP_REGNUM, buf);
  sp = extract_unsigned_integer (buf, 4, byte_order);

  return read_memory_unsigned_integer (sp + 8, 4, byte_order);
}



/* Implementation of `gdbarch_stap_is_single_operand', as defined in
   gdbarch.h.  */

int
i386_stap_is_single_operand (struct gdbarch *gdbarch, const char *s)
{
  return (*s == '$' /* Literal number.  */
	  || (isdigit (*s) && s[1] == '(' && s[2] == '%') /* Displacement.  */
	  || (*s == '(' && s[1] == '%') /* Register indirection.  */
	  || (*s == '%' && isalpha (s[1]))); /* Register access.  */
}

/* Implementation of `gdbarch_stap_parse_special_token', as defined in
   gdbarch.h.  */

int
i386_stap_parse_special_token (struct gdbarch *gdbarch,
			       struct stap_parse_info *p)
{
  /* In order to parse special tokens, we use a state-machine that go
     through every known token and try to get a match.  */
  enum
    {
      TRIPLET,
      THREE_ARG_DISPLACEMENT,
      DONE
    } current_state;

  current_state = TRIPLET;

  /* The special tokens to be parsed here are:

     - `register base + (register index * size) + offset', as represented
     in `(%rcx,%rax,8)', or `[OFFSET](BASE_REG,INDEX_REG[,SIZE])'.

     - Operands of the form `-8+3+1(%rbp)', which must be interpreted as
     `*(-8 + 3 - 1 + (void *) $eax)'.  */

  while (current_state != DONE)
    {
      const char *s = p->arg;

      switch (current_state)
	{
	case TRIPLET:
	    {
	      if (isdigit (*s) || *s == '-' || *s == '+')
		{
		  int got_minus[3];
		  int i;
		  long displacements[3];
		  const char *start;
		  char *regname;
		  int len;
		  struct stoken str;
		  char *endp;

		  got_minus[0] = 0;
		  if (*s == '+')
		    ++s;
		  else if (*s == '-')
		    {
		      ++s;
		      got_minus[0] = 1;
		    }

		  displacements[0] = strtol (s, &endp, 10);
		  s = endp;

		  if (*s != '+' && *s != '-')
		    {
		      /* We are not dealing with a triplet.  */
		      break;
		    }

		  got_minus[1] = 0;
		  if (*s == '+')
		    ++s;
		  else
		    {
		      ++s;
		      got_minus[1] = 1;
		    }

		  displacements[1] = strtol (s, &endp, 10);
		  s = endp;

		  if (*s != '+' && *s != '-')
		    {
		      /* We are not dealing with a triplet.  */
		      break;
		    }

		  got_minus[2] = 0;
		  if (*s == '+')
		    ++s;
		  else
		    {
		      ++s;
		      got_minus[2] = 1;
		    }

		  displacements[2] = strtol (s, &endp, 10);
		  s = endp;

		  if (*s != '(' || s[1] != '%')
		    break;

		  s += 2;
		  start = s;

		  while (isalnum (*s))
		    ++s;

		  if (*s++ != ')')
		    break;

		  len = s - start;
		  regname = alloca (len + 1);

		  strncpy (regname, start, len);
		  regname[len] = '\0';

		  if (user_reg_map_name_to_regnum (gdbarch,
						   regname, len) == -1)
		    error (_("Invalid register name `%s' "
			     "on expression `%s'."),
			   regname, p->saved_arg);

		  for (i = 0; i < 3; i++)
		    {
		      write_exp_elt_opcode (OP_LONG);
		      write_exp_elt_type
			(builtin_type (gdbarch)->builtin_long);
		      write_exp_elt_longcst (displacements[i]);
		      write_exp_elt_opcode (OP_LONG);
		      if (got_minus[i])
			write_exp_elt_opcode (UNOP_NEG);
		    }

		  write_exp_elt_opcode (OP_REGISTER);
		  str.ptr = regname;
		  str.length = len;
		  write_exp_string (str);
		  write_exp_elt_opcode (OP_REGISTER);

		  write_exp_elt_opcode (UNOP_CAST);
		  write_exp_elt_type (builtin_type (gdbarch)->builtin_data_ptr);
		  write_exp_elt_opcode (UNOP_CAST);

		  write_exp_elt_opcode (BINOP_ADD);
		  write_exp_elt_opcode (BINOP_ADD);
		  write_exp_elt_opcode (BINOP_ADD);

		  write_exp_elt_opcode (UNOP_CAST);
		  write_exp_elt_type (lookup_pointer_type (p->arg_type));
		  write_exp_elt_opcode (UNOP_CAST);

		  write_exp_elt_opcode (UNOP_IND);

		  p->arg = s;

		  return 1;
		}
	      break;
	    }
	case THREE_ARG_DISPLACEMENT:
	    {
	      if (isdigit (*s) || *s == '(' || *s == '-' || *s == '+')
		{
		  int offset_minus = 0;
		  long offset = 0;
		  int size_minus = 0;
		  long size = 0;
		  const char *start;
		  char *base;
		  int len_base;
		  char *index;
		  int len_index;
		  struct stoken base_token, index_token;

		  if (*s == '+')
		    ++s;
		  else if (*s == '-')
		    {
		      ++s;
		      offset_minus = 1;
		    }

		  if (offset_minus && !isdigit (*s))
		    break;

		  if (isdigit (*s))
		    {
		      char *endp;

		      offset = strtol (s, &endp, 10);
		      s = endp;
		    }

		  if (*s != '(' || s[1] != '%')
		    break;

		  s += 2;
		  start = s;

		  while (isalnum (*s))
		    ++s;

		  if (*s != ',' || s[1] != '%')
		    break;

		  len_base = s - start;
		  base = alloca (len_base + 1);
		  strncpy (base, start, len_base);
		  base[len_base] = '\0';

		  if (user_reg_map_name_to_regnum (gdbarch,
						   base, len_base) == -1)
		    error (_("Invalid register name `%s' "
			     "on expression `%s'."),
			   base, p->saved_arg);

		  s += 2;
		  start = s;

		  while (isalnum (*s))
		    ++s;

		  len_index = s - start;
		  index = alloca (len_index + 1);
		  strncpy (index, start, len_index);
		  index[len_index] = '\0';

		  if (user_reg_map_name_to_regnum (gdbarch,
						   index, len_index) == -1)
		    error (_("Invalid register name `%s' "
			     "on expression `%s'."),
			   index, p->saved_arg);

		  if (*s != ',' && *s != ')')
		    break;

		  if (*s == ',')
		    {
		      char *endp;

		      ++s;
		      if (*s == '+')
			++s;
		      else if (*s == '-')
			{
			  ++s;
			  size_minus = 1;
			}

		      size = strtol (s, &endp, 10);
		      s = endp;

		      if (*s != ')')
			break;
		    }

		  ++s;

		  if (offset)
		    {
		      write_exp_elt_opcode (OP_LONG);
		      write_exp_elt_type
			(builtin_type (gdbarch)->builtin_long);
		      write_exp_elt_longcst (offset);
		      write_exp_elt_opcode (OP_LONG);
		      if (offset_minus)
			write_exp_elt_opcode (UNOP_NEG);
		    }

		  write_exp_elt_opcode (OP_REGISTER);
		  base_token.ptr = base;
		  base_token.length = len_base;
		  write_exp_string (base_token);
		  write_exp_elt_opcode (OP_REGISTER);

		  if (offset)
		    write_exp_elt_opcode (BINOP_ADD);

		  write_exp_elt_opcode (OP_REGISTER);
		  index_token.ptr = index;
		  index_token.length = len_index;
		  write_exp_string (index_token);
		  write_exp_elt_opcode (OP_REGISTER);

		  if (size)
		    {
		      write_exp_elt_opcode (OP_LONG);
		      write_exp_elt_type
			(builtin_type (gdbarch)->builtin_long);
		      write_exp_elt_longcst (size);
		      write_exp_elt_opcode (OP_LONG);
		      if (size_minus)
			write_exp_elt_opcode (UNOP_NEG);
		      write_exp_elt_opcode (BINOP_MUL);
		    }

		  write_exp_elt_opcode (BINOP_ADD);

		  write_exp_elt_opcode (UNOP_CAST);
		  write_exp_elt_type (lookup_pointer_type (p->arg_type));
		  write_exp_elt_opcode (UNOP_CAST);

		  write_exp_elt_opcode (UNOP_IND);

		  p->arg = s;

		  return 1;
		}
	      break;
	    }
	}

      /* Advancing to the next state.  */
      ++current_state;
    }

  return 0;
}



/* Generic ELF.  */

void
i386_elf_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  /* We typically use stabs-in-ELF with the SVR4 register numbering.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_svr4_reg_to_regnum);

  /* Registering SystemTap handlers.  */
  set_gdbarch_stap_integer_prefix (gdbarch, "$");
  set_gdbarch_stap_register_prefix (gdbarch, "%");
  set_gdbarch_stap_register_indirection_prefix (gdbarch, "(");
  set_gdbarch_stap_register_indirection_suffix (gdbarch, ")");
  set_gdbarch_stap_is_single_operand (gdbarch,
				      i386_stap_is_single_operand);
  set_gdbarch_stap_parse_special_token (gdbarch,
					i386_stap_parse_special_token);
}

/* System V Release 4 (SVR4).  */

void
i386_svr4_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* System V Release 4 uses ELF.  */
  i386_elf_init_abi (info, gdbarch);

  /* System V Release 4 has shared libraries.  */
  set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);

  tdep->sigtramp_p = i386_svr4_sigtramp_p;
  tdep->sigcontext_addr = i386_svr4_sigcontext_addr;
  tdep->sc_pc_offset = 36 + 14 * 4;
  tdep->sc_sp_offset = 36 + 17 * 4;

  tdep->jb_pc_offset = 20;
}

/* DJGPP.  */

static void
i386_go32_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* DJGPP doesn't have any special frames for signal handlers.  */
  tdep->sigtramp_p = NULL;

  tdep->jb_pc_offset = 36;

  /* DJGPP does not support the SSE registers.  */
  if (! tdesc_has_registers (info.target_desc))
    tdep->tdesc = tdesc_i386_mmx;

  /* Native compiler is GCC, which uses the SVR4 register numbering
     even in COFF and STABS.  See the comment in i386_gdbarch_init,
     before the calls to set_gdbarch_stab_reg_to_regnum and
     set_gdbarch_sdb_reg_to_regnum.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_svr4_reg_to_regnum);
  set_gdbarch_sdb_reg_to_regnum (gdbarch, i386_svr4_reg_to_regnum);

  set_gdbarch_has_dos_based_file_system (gdbarch, 1);
}


/* i386 register groups.  In addition to the normal groups, add "mmx"
   and "sse".  */

static struct reggroup *i386_sse_reggroup;
static struct reggroup *i386_mmx_reggroup;

static void
i386_init_reggroups (void)
{
  i386_sse_reggroup = reggroup_new ("sse", USER_REGGROUP);
  i386_mmx_reggroup = reggroup_new ("mmx", USER_REGGROUP);
}

static void
i386_add_reggroups (struct gdbarch *gdbarch)
{
  reggroup_add (gdbarch, i386_sse_reggroup);
  reggroup_add (gdbarch, i386_mmx_reggroup);
  reggroup_add (gdbarch, general_reggroup);
  reggroup_add (gdbarch, float_reggroup);
  reggroup_add (gdbarch, all_reggroup);
  reggroup_add (gdbarch, save_reggroup);
  reggroup_add (gdbarch, restore_reggroup);
  reggroup_add (gdbarch, vector_reggroup);
  reggroup_add (gdbarch, system_reggroup);
}

int
i386_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			  struct reggroup *group)
{
  const struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int fp_regnum_p, mmx_regnum_p, xmm_regnum_p, mxcsr_regnum_p,
      ymm_regnum_p, ymmh_regnum_p;

  /* Don't include pseudo registers, except for MMX, in any register
     groups.  */
  if (i386_byte_regnum_p (gdbarch, regnum))
    return 0;

  if (i386_word_regnum_p (gdbarch, regnum))
    return 0;

  if (i386_dword_regnum_p (gdbarch, regnum))
    return 0;

  mmx_regnum_p = i386_mmx_regnum_p (gdbarch, regnum);
  if (group == i386_mmx_reggroup)
    return mmx_regnum_p;

  xmm_regnum_p = i386_xmm_regnum_p (gdbarch, regnum);
  mxcsr_regnum_p = i386_mxcsr_regnum_p (gdbarch, regnum);
  if (group == i386_sse_reggroup)
    return xmm_regnum_p || mxcsr_regnum_p;

  ymm_regnum_p = i386_ymm_regnum_p (gdbarch, regnum);
  if (group == vector_reggroup)
    return (mmx_regnum_p
	    || ymm_regnum_p
	    || mxcsr_regnum_p
	    || (xmm_regnum_p
		&& ((tdep->xcr0 & I386_XSTATE_AVX_MASK)
		    == I386_XSTATE_SSE_MASK)));

  fp_regnum_p = (i386_fp_regnum_p (gdbarch, regnum)
		 || i386_fpc_regnum_p (gdbarch, regnum));
  if (group == float_reggroup)
    return fp_regnum_p;

  /* For "info reg all", don't include upper YMM registers nor XMM
     registers when AVX is supported.  */
  ymmh_regnum_p = i386_ymmh_regnum_p (gdbarch, regnum);
  if (group == all_reggroup
      && ((xmm_regnum_p
	   && (tdep->xcr0 & I386_XSTATE_AVX))
	  || ymmh_regnum_p))
    return 0;

  if (group == general_reggroup)
    return (!fp_regnum_p
	    && !mmx_regnum_p
	    && !mxcsr_regnum_p
	    && !xmm_regnum_p
	    && !ymm_regnum_p
	    && !ymmh_regnum_p);

  return default_register_reggroup_p (gdbarch, regnum, group);
}


/* Get the ARGIth function argument for the current function.  */

static CORE_ADDR
i386_fetch_pointer_argument (struct frame_info *frame, int argi, 
			     struct type *type)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR sp = get_frame_register_unsigned (frame, I386_ESP_REGNUM);
  return read_memory_unsigned_integer (sp + (4 * (argi + 1)), 4, byte_order);
}

static void
i386_skip_permanent_breakpoint (struct regcache *regcache)
{
  CORE_ADDR current_pc = regcache_read_pc (regcache);

 /* On i386, breakpoint is exactly 1 byte long, so we just
    adjust the PC in the regcache.  */
  current_pc += 1;
  regcache_write_pc (regcache, current_pc);
}


#define PREFIX_REPZ	0x01
#define PREFIX_REPNZ	0x02
#define PREFIX_LOCK	0x04
#define PREFIX_DATA	0x08
#define PREFIX_ADDR	0x10

/* operand size */
enum
{
  OT_BYTE = 0,
  OT_WORD,
  OT_LONG,
  OT_QUAD,
  OT_DQUAD,
};

/* i386 arith/logic operations */
enum
{
  OP_ADDL,
  OP_ORL,
  OP_ADCL,
  OP_SBBL,
  OP_ANDL,
  OP_SUBL,
  OP_XORL,
  OP_CMPL,
};

struct i386_record_s
{
  struct gdbarch *gdbarch;
  struct regcache *regcache;
  CORE_ADDR orig_addr;
  CORE_ADDR addr;
  int aflag;
  int dflag;
  int override;
  uint8_t modrm;
  uint8_t mod, reg, rm;
  int ot;
  uint8_t rex_x;
  uint8_t rex_b;
  int rip_offset;
  int popl_esp_hack;
  const int *regmap;
};

/* Parse the "modrm" part of the memory address irp->addr points at.
   Returns -1 if something goes wrong, 0 otherwise.  */

static int
i386_record_modrm (struct i386_record_s *irp)
{
  struct gdbarch *gdbarch = irp->gdbarch;

  if (record_read_memory (gdbarch, irp->addr, &irp->modrm, 1))
    return -1;

  irp->addr++;
  irp->mod = (irp->modrm >> 6) & 3;
  irp->reg = (irp->modrm >> 3) & 7;
  irp->rm = irp->modrm & 7;

  return 0;
}

/* Extract the memory address that the current instruction writes to,
   and return it in *ADDR.  Return -1 if something goes wrong.  */

static int
i386_record_lea_modrm_addr (struct i386_record_s *irp, uint64_t *addr)
{
  struct gdbarch *gdbarch = irp->gdbarch;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[4];
  ULONGEST offset64;

  *addr = 0;
  if (irp->aflag)
    {
      /* 32 bits */
      int havesib = 0;
      uint8_t scale = 0;
      uint8_t byte;
      uint8_t index = 0;
      uint8_t base = irp->rm;

      if (base == 4)
	{
	  havesib = 1;
	  if (record_read_memory (gdbarch, irp->addr, &byte, 1))
	    return -1;
	  irp->addr++;
	  scale = (byte >> 6) & 3;
	  index = ((byte >> 3) & 7) | irp->rex_x;
	  base = (byte & 7);
	}
      base |= irp->rex_b;

      switch (irp->mod)
	{
	case 0:
	  if ((base & 7) == 5)
	    {
	      base = 0xff;
	      if (record_read_memory (gdbarch, irp->addr, buf, 4))
		return -1;
	      irp->addr += 4;
	      *addr = extract_signed_integer (buf, 4, byte_order);
	      if (irp->regmap[X86_RECORD_R8_REGNUM] && !havesib)
		*addr += irp->addr + irp->rip_offset;
	    }
	  break;
	case 1:
	  if (record_read_memory (gdbarch, irp->addr, buf, 1))
	    return -1;
	  irp->addr++;
	  *addr = (int8_t) buf[0];
	  break;
	case 2:
	  if (record_read_memory (gdbarch, irp->addr, buf, 4))
	    return -1;
	  *addr = extract_signed_integer (buf, 4, byte_order);
	  irp->addr += 4;
	  break;
	}

      offset64 = 0;
      if (base != 0xff)
        {
	  if (base == 4 && irp->popl_esp_hack)
	    *addr += irp->popl_esp_hack;
	  regcache_raw_read_unsigned (irp->regcache, irp->regmap[base],
                                      &offset64);
	}
      if (irp->aflag == 2)
        {
	  *addr += offset64;
        }
      else
        *addr = (uint32_t) (offset64 + *addr);

      if (havesib && (index != 4 || scale != 0))
	{
	  regcache_raw_read_unsigned (irp->regcache, irp->regmap[index],
                                      &offset64);
	  if (irp->aflag == 2)
	    *addr += offset64 << scale;
	  else
	    *addr = (uint32_t) (*addr + (offset64 << scale));
	}
    }
  else
    {
      /* 16 bits */
      switch (irp->mod)
	{
	case 0:
	  if (irp->rm == 6)
	    {
	      if (record_read_memory (gdbarch, irp->addr, buf, 2))
		return -1;
	      irp->addr += 2;
	      *addr = extract_signed_integer (buf, 2, byte_order);
	      irp->rm = 0;
	      goto no_rm;
	    }
	  break;
	case 1:
	  if (record_read_memory (gdbarch, irp->addr, buf, 1))
	    return -1;
	  irp->addr++;
	  *addr = (int8_t) buf[0];
	  break;
	case 2:
	  if (record_read_memory (gdbarch, irp->addr, buf, 2))
	    return -1;
	  irp->addr += 2;
	  *addr = extract_signed_integer (buf, 2, byte_order);
	  break;
	}

      switch (irp->rm)
	{
	case 0:
	  regcache_raw_read_unsigned (irp->regcache,
				      irp->regmap[X86_RECORD_REBX_REGNUM],
                                      &offset64);
	  *addr = (uint32_t) (*addr + offset64);
	  regcache_raw_read_unsigned (irp->regcache,
				      irp->regmap[X86_RECORD_RESI_REGNUM],
                                      &offset64);
	  *addr = (uint32_t) (*addr + offset64);
	  break;
	case 1:
	  regcache_raw_read_unsigned (irp->regcache,
				      irp->regmap[X86_RECORD_REBX_REGNUM],
                                      &offset64);
	  *addr = (uint32_t) (*addr + offset64);
	  regcache_raw_read_unsigned (irp->regcache,
				      irp->regmap[X86_RECORD_REDI_REGNUM],
                                      &offset64);
	  *addr = (uint32_t) (*addr + offset64);
	  break;
	case 2:
	  regcache_raw_read_unsigned (irp->regcache,
				      irp->regmap[X86_RECORD_REBP_REGNUM],
                                      &offset64);
	  *addr = (uint32_t) (*addr + offset64);
	  regcache_raw_read_unsigned (irp->regcache,
				      irp->regmap[X86_RECORD_RESI_REGNUM],
                                      &offset64);
	  *addr = (uint32_t) (*addr + offset64);
	  break;
	case 3:
	  regcache_raw_read_unsigned (irp->regcache,
				      irp->regmap[X86_RECORD_REBP_REGNUM],
                                      &offset64);
	  *addr = (uint32_t) (*addr + offset64);
	  regcache_raw_read_unsigned (irp->regcache,
				      irp->regmap[X86_RECORD_REDI_REGNUM],
                                      &offset64);
	  *addr = (uint32_t) (*addr + offset64);
	  break;
	case 4:
	  regcache_raw_read_unsigned (irp->regcache,
				      irp->regmap[X86_RECORD_RESI_REGNUM],
                                      &offset64);
	  *addr = (uint32_t) (*addr + offset64);
	  break;
	case 5:
	  regcache_raw_read_unsigned (irp->regcache,
				      irp->regmap[X86_RECORD_REDI_REGNUM],
                                      &offset64);
	  *addr = (uint32_t) (*addr + offset64);
	  break;
	case 6:
	  regcache_raw_read_unsigned (irp->regcache,
				      irp->regmap[X86_RECORD_REBP_REGNUM],
                                      &offset64);
	  *addr = (uint32_t) (*addr + offset64);
	  break;
	case 7:
	  regcache_raw_read_unsigned (irp->regcache,
				      irp->regmap[X86_RECORD_REBX_REGNUM],
                                      &offset64);
	  *addr = (uint32_t) (*addr + offset64);
	  break;
	}
      *addr &= 0xffff;
    }

 no_rm:
  return 0;
}

/* Record the address and contents of the memory that will be changed
   by the current instruction.  Return -1 if something goes wrong, 0
   otherwise.  */

static int
i386_record_lea_modrm (struct i386_record_s *irp)
{
  struct gdbarch *gdbarch = irp->gdbarch;
  uint64_t addr;

  if (irp->override >= 0)
    {
      if (record_full_memory_query)
        {
	  int q;

          target_terminal_ours ();
          q = yquery (_("\
Process record ignores the memory change of instruction at address %s\n\
because it can't get the value of the segment register.\n\
Do you want to stop the program?"),
                      paddress (gdbarch, irp->orig_addr));
            target_terminal_inferior ();
            if (q)
              return -1;
        }

      return 0;
    }

  if (i386_record_lea_modrm_addr (irp, &addr))
    return -1;

  if (record_full_arch_list_add_mem (addr, 1 << irp->ot))
    return -1;

  return 0;
}

/* Record the effects of a push operation.  Return -1 if something
   goes wrong, 0 otherwise.  */

static int
i386_record_push (struct i386_record_s *irp, int size)
{
  ULONGEST addr;

  if (record_full_arch_list_add_reg (irp->regcache,
				     irp->regmap[X86_RECORD_RESP_REGNUM]))
    return -1;
  regcache_raw_read_unsigned (irp->regcache,
			      irp->regmap[X86_RECORD_RESP_REGNUM],
			      &addr);
  if (record_full_arch_list_add_mem ((CORE_ADDR) addr - size, size))
    return -1;

  return 0;
}


/* Defines contents to record.  */
#define I386_SAVE_FPU_REGS              0xfffd
#define I386_SAVE_FPU_ENV               0xfffe
#define I386_SAVE_FPU_ENV_REG_STACK     0xffff

/* Record the values of the floating point registers which will be
   changed by the current instruction.  Returns -1 if something is
   wrong, 0 otherwise.  */

static int i386_record_floats (struct gdbarch *gdbarch,
                               struct i386_record_s *ir,
                               uint32_t iregnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int i;

  /* Oza: Because of floating point insn push/pop of fpu stack is going to
     happen.  Currently we store st0-st7 registers, but we need not store all
     registers all the time, in future we use ftag register and record only
     those who are not marked as an empty.  */

  if (I386_SAVE_FPU_REGS == iregnum)
    {
      for (i = I387_ST0_REGNUM (tdep); i <= I387_ST0_REGNUM (tdep) + 7; i++)
        {
          if (record_full_arch_list_add_reg (ir->regcache, i))
            return -1;
        }
    }
  else if (I386_SAVE_FPU_ENV == iregnum)
    {
      for (i = I387_FCTRL_REGNUM (tdep); i <= I387_FOP_REGNUM (tdep); i++)
	      {
	      if (record_full_arch_list_add_reg (ir->regcache, i))
	        return -1;
	      }
    }
  else if (I386_SAVE_FPU_ENV_REG_STACK == iregnum)
    {
      for (i = I387_ST0_REGNUM (tdep); i <= I387_FOP_REGNUM (tdep); i++)
      {
        if (record_full_arch_list_add_reg (ir->regcache, i))
          return -1;
      }
    }
  else if ((iregnum >= I387_ST0_REGNUM (tdep)) &&
           (iregnum <= I387_FOP_REGNUM (tdep)))
    {
      if (record_full_arch_list_add_reg (ir->regcache,iregnum))
        return -1;
    }
  else
    {
      /* Parameter error.  */
      return -1;
    }
  if(I386_SAVE_FPU_ENV != iregnum)
    {
    for (i = I387_FCTRL_REGNUM (tdep); i <= I387_FOP_REGNUM (tdep); i++)
      {
      if (record_full_arch_list_add_reg (ir->regcache, i))
        return -1;
      }
    }
  return 0;
}

/* Parse the current instruction, and record the values of the
   registers and memory that will be changed by the current
   instruction.  Returns -1 if something goes wrong, 0 otherwise.  */

#define I386_RECORD_FULL_ARCH_LIST_ADD_REG(regnum) \
    record_full_arch_list_add_reg (ir.regcache, ir.regmap[(regnum)])

int
i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,
		     CORE_ADDR input_addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int prefixes = 0;
  int regnum = 0;
  uint32_t opcode;
  uint8_t opcode8;
  ULONGEST addr;
  gdb_byte buf[MAX_REGISTER_SIZE];
  struct i386_record_s ir;
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  uint8_t rex_w = -1;
  uint8_t rex_r = 0;

  memset (&ir, 0, sizeof (struct i386_record_s));
  ir.regcache = regcache;
  ir.addr = input_addr;
  ir.orig_addr = input_addr;
  ir.aflag = 1;
  ir.dflag = 1;
  ir.override = -1;
  ir.popl_esp_hack = 0;
  ir.regmap = tdep->record_regmap;
  ir.gdbarch = gdbarch;

  if (record_debug > 1)
    fprintf_unfiltered (gdb_stdlog, "Process record: i386_process_record "
			            "addr = %s\n",
			paddress (gdbarch, ir.addr));

  /* prefixes */
  while (1)
    {
      if (record_read_memory (gdbarch, ir.addr, &opcode8, 1))
	return -1;
      ir.addr++;
      switch (opcode8)	/* Instruction prefixes */
	{
	case REPE_PREFIX_OPCODE:
	  prefixes |= PREFIX_REPZ;
	  break;
	case REPNE_PREFIX_OPCODE:
	  prefixes |= PREFIX_REPNZ;
	  break;
	case LOCK_PREFIX_OPCODE:
	  prefixes |= PREFIX_LOCK;
	  break;
	case CS_PREFIX_OPCODE:
	  ir.override = X86_RECORD_CS_REGNUM;
	  break;
	case SS_PREFIX_OPCODE:
	  ir.override = X86_RECORD_SS_REGNUM;
	  break;
	case DS_PREFIX_OPCODE:
	  ir.override = X86_RECORD_DS_REGNUM;
	  break;
	case ES_PREFIX_OPCODE:
	  ir.override = X86_RECORD_ES_REGNUM;
	  break;
	case FS_PREFIX_OPCODE:
	  ir.override = X86_RECORD_FS_REGNUM;
	  break;
	case GS_PREFIX_OPCODE:
	  ir.override = X86_RECORD_GS_REGNUM;
	  break;
	case DATA_PREFIX_OPCODE:
	  prefixes |= PREFIX_DATA;
	  break;
	case ADDR_PREFIX_OPCODE:
	  prefixes |= PREFIX_ADDR;
	  break;
        case 0x40:	/* i386 inc %eax */
        case 0x41:	/* i386 inc %ecx */
        case 0x42:	/* i386 inc %edx */
        case 0x43:	/* i386 inc %ebx */
        case 0x44:	/* i386 inc %esp */
        case 0x45:	/* i386 inc %ebp */
        case 0x46:	/* i386 inc %esi */
        case 0x47:	/* i386 inc %edi */
        case 0x48:	/* i386 dec %eax */
        case 0x49:	/* i386 dec %ecx */
        case 0x4a:	/* i386 dec %edx */
        case 0x4b:	/* i386 dec %ebx */
        case 0x4c:	/* i386 dec %esp */
        case 0x4d:	/* i386 dec %ebp */
        case 0x4e:	/* i386 dec %esi */
        case 0x4f:	/* i386 dec %edi */
          if (ir.regmap[X86_RECORD_R8_REGNUM])	/* 64 bit target */
            {
               /* REX */
               rex_w = (opcode8 >> 3) & 1;
               rex_r = (opcode8 & 0x4) << 1;
               ir.rex_x = (opcode8 & 0x2) << 2;
               ir.rex_b = (opcode8 & 0x1) << 3;
            }
	  else					/* 32 bit target */
	    goto out_prefixes;
          break;
	default:
	  goto out_prefixes;
	  break;
	}
    }
 out_prefixes:
  if (ir.regmap[X86_RECORD_R8_REGNUM] && rex_w == 1)
    {
      ir.dflag = 2;
    }
  else
    {
      if (prefixes & PREFIX_DATA)
        ir.dflag ^= 1;
    }
  if (prefixes & PREFIX_ADDR)
    ir.aflag ^= 1;
  else if (ir.regmap[X86_RECORD_R8_REGNUM])
    ir.aflag = 2;

  /* Now check op code.  */
  opcode = (uint32_t) opcode8;
 reswitch:
  switch (opcode)
    {
    case 0x0f:
      if (record_read_memory (gdbarch, ir.addr, &opcode8, 1))
	return -1;
      ir.addr++;
      opcode = (uint32_t) opcode8 | 0x0f00;
      goto reswitch;
      break;

    case 0x00:    /* arith & logic */
    case 0x01:
    case 0x02:
    case 0x03:
    case 0x04:
    case 0x05:
    case 0x08:
    case 0x09:
    case 0x0a:
    case 0x0b:
    case 0x0c:
    case 0x0d:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x18:
    case 0x19:
    case 0x1a:
    case 0x1b:
    case 0x1c:
    case 0x1d:
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x28:
    case 0x29:
    case 0x2a:
    case 0x2b:
    case 0x2c:
    case 0x2d:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x38:
    case 0x39:
    case 0x3a:
    case 0x3b:
    case 0x3c:
    case 0x3d:
      if (((opcode >> 3) & 7) != OP_CMPL)
	{
	  if ((opcode & 1) == 0)
	    ir.ot = OT_BYTE;
	  else
	    ir.ot = ir.dflag + OT_WORD;

	  switch ((opcode >> 1) & 3)
	    {
	    case 0:    /* OP Ev, Gv */
	      if (i386_record_modrm (&ir))
		return -1;
	      if (ir.mod != 3)
		{
		  if (i386_record_lea_modrm (&ir))
		    return -1;
		}
	      else
		{
                  ir.rm |= ir.rex_b;
		  if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
		    ir.rm &= 0x3;
		  I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm);
		}
	      break;
	    case 1:    /* OP Gv, Ev */
	      if (i386_record_modrm (&ir))
		return -1;
              ir.reg |= rex_r;
	      if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
		ir.reg &= 0x3;
	      I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg);
	      break;
	    case 2:    /* OP A, Iv */
	      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
	      break;
	    }
	}
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x80:    /* GRP1 */
    case 0x81:
    case 0x82:
    case 0x83:
      if (i386_record_modrm (&ir))
	return -1;

      if (ir.reg != OP_CMPL)
	{
	  if ((opcode & 1) == 0)
	    ir.ot = OT_BYTE;
	  else
	    ir.ot = ir.dflag + OT_WORD;

	  if (ir.mod != 3)
	    {
              if (opcode == 0x83)
                ir.rip_offset = 1;
              else
                ir.rip_offset = (ir.ot > OT_LONG) ? 4 : (1 << ir.ot);
	      if (i386_record_lea_modrm (&ir))
		return -1;
	    }
	  else
	    I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
	}
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x40:      /* inc */
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:

    case 0x48:      /* dec */
    case 0x49:
    case 0x4a:
    case 0x4b:
    case 0x4c:
    case 0x4d:
    case 0x4e:
    case 0x4f:

      I386_RECORD_FULL_ARCH_LIST_ADD_REG (opcode & 7);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0xf6:    /* GRP3 */
    case 0xf7:
      if ((opcode & 1) == 0)
	ir.ot = OT_BYTE;
      else
	ir.ot = ir.dflag + OT_WORD;
      if (i386_record_modrm (&ir))
	return -1;

      if (ir.mod != 3 && ir.reg == 0)
        ir.rip_offset = (ir.ot > OT_LONG) ? 4 : (1 << ir.ot);

      switch (ir.reg)
	{
	case 0:    /* test */
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
	  break;
	case 2:    /* not */
	case 3:    /* neg */
	  if (ir.mod != 3)
	    {
	      if (i386_record_lea_modrm (&ir))
		return -1;
	    }
	  else
	    {
              ir.rm |= ir.rex_b;
	      if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
		ir.rm &= 0x3;
	      I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm);
	    }
	  if (ir.reg == 3)  /* neg */
	    I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
	  break;
	case 4:    /* mul  */
	case 5:    /* imul */
	case 6:    /* div  */
	case 7:    /* idiv */
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
	  if (ir.ot != OT_BYTE)
	    I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDX_REGNUM);
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
	  break;
	default:
	  ir.addr -= 2;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	  break;
	}
      break;

    case 0xfe:    /* GRP4 */
    case 0xff:    /* GRP5 */
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.reg >= 2 && opcode == 0xfe)
	{
	  ir.addr -= 2;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	}
      switch (ir.reg)
	{
	case 0:    /* inc */
	case 1:    /* dec */
          if ((opcode & 1) == 0)
	    ir.ot = OT_BYTE;
          else
	    ir.ot = ir.dflag + OT_WORD;
	  if (ir.mod != 3)
	    {
	      if (i386_record_lea_modrm (&ir))
		return -1;
	    }
	  else
	    {
	      ir.rm |= ir.rex_b;
	      if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
		ir.rm &= 0x3;
	      I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm);
	    }
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
	  break;
	case 2:    /* call */
          if (ir.regmap[X86_RECORD_R8_REGNUM] && ir.dflag)
            ir.dflag = 2;
	  if (i386_record_push (&ir, 1 << (ir.dflag + 1)))
	    return -1;
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
	  break;
	case 3:    /* lcall */
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_CS_REGNUM);
	  if (i386_record_push (&ir, 1 << (ir.dflag + 1)))
	    return -1;
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
	  break;
	case 4:    /* jmp  */
	case 5:    /* ljmp */
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
	  break;
	case 6:    /* push */
          if (ir.regmap[X86_RECORD_R8_REGNUM] && ir.dflag)
            ir.dflag = 2;
	  if (i386_record_push (&ir, 1 << (ir.dflag + 1)))
	    return -1;
	  break;
	default:
	  ir.addr -= 2;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	  break;
	}
      break;

    case 0x84:    /* test */
    case 0x85:
    case 0xa8:
    case 0xa9:
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x98:    /* CWDE/CBW */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      break;

    case 0x99:    /* CDQ/CWD */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDX_REGNUM);
      break;

    case 0x0faf:  /* imul */
    case 0x69:
    case 0x6b:
      ir.ot = ir.dflag + OT_WORD;
      if (i386_record_modrm (&ir))
	return -1;
      if (opcode == 0x69)
        ir.rip_offset = (ir.ot > OT_LONG) ? 4 : (1 << ir.ot);
      else if (opcode == 0x6b)
        ir.rip_offset = 1;
      ir.reg |= rex_r;
      if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
	ir.reg &= 0x3;
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x0fc0:  /* xadd */
    case 0x0fc1:
      if ((opcode & 1) == 0)
	ir.ot = OT_BYTE;
      else
	ir.ot = ir.dflag + OT_WORD;
      if (i386_record_modrm (&ir))
	return -1;
      ir.reg |= rex_r;
      if (ir.mod == 3)
	{
	  if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
	    ir.reg &= 0x3;
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg);
	  if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
	    ir.rm &= 0x3;
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm);
	}
      else
	{
	  if (i386_record_lea_modrm (&ir))
	    return -1;
	  if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
	    ir.reg &= 0x3;
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg);
	}
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x0fb0:  /* cmpxchg */
    case 0x0fb1:
      if ((opcode & 1) == 0)
	ir.ot = OT_BYTE;
      else
	ir.ot = ir.dflag + OT_WORD;
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.mod == 3)
	{
          ir.reg |= rex_r;
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
	  if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
	    ir.reg &= 0x3;
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg);
	}
      else
	{
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
	  if (i386_record_lea_modrm (&ir))
	    return -1;
	}
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x0fc7:    /* cmpxchg8b */
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.mod == 3)
	{
	  ir.addr -= 2;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	}
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDX_REGNUM);
      if (i386_record_lea_modrm (&ir))
	return -1;
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x50:    /* push */
    case 0x51:
    case 0x52:
    case 0x53:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
    case 0x68:
    case 0x6a:
      if (ir.regmap[X86_RECORD_R8_REGNUM] && ir.dflag)
        ir.dflag = 2;
      if (i386_record_push (&ir, 1 << (ir.dflag + 1)))
	return -1;
      break;

    case 0x06:    /* push es */
    case 0x0e:    /* push cs */
    case 0x16:    /* push ss */
    case 0x1e:    /* push ds */
      if (ir.regmap[X86_RECORD_R8_REGNUM])
        {
	  ir.addr -= 1;
	  goto no_support;
	}
      if (i386_record_push (&ir, 1 << (ir.dflag + 1)))
	return -1;
      break;

    case 0x0fa0:    /* push fs */
    case 0x0fa8:    /* push gs */
      if (ir.regmap[X86_RECORD_R8_REGNUM])
        {
	  ir.addr -= 2;
	  goto no_support;
	}
      if (i386_record_push (&ir, 1 << (ir.dflag + 1)))
	return -1;
      break;

    case 0x60:    /* pusha */
      if (ir.regmap[X86_RECORD_R8_REGNUM])
        {
	  ir.addr -= 1;
	  goto no_support;
	}
      if (i386_record_push (&ir, 1 << (ir.dflag + 4)))
	return -1;
      break;

    case 0x58:    /* pop */
    case 0x59:
    case 0x5a:
    case 0x5b:
    case 0x5c:
    case 0x5d:
    case 0x5e:
    case 0x5f:
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG ((opcode & 0x7) | ir.rex_b);
      break;

    case 0x61:    /* popa */
      if (ir.regmap[X86_RECORD_R8_REGNUM])
        {
	  ir.addr -= 1;
	  goto no_support;
	}
      for (regnum = X86_RECORD_REAX_REGNUM; 
	   regnum <= X86_RECORD_REDI_REGNUM;
	   regnum++)
	I386_RECORD_FULL_ARCH_LIST_ADD_REG (regnum);
      break;

    case 0x8f:    /* pop */
      if (ir.regmap[X86_RECORD_R8_REGNUM])
	ir.ot = ir.dflag ? OT_QUAD : OT_WORD;
      else
        ir.ot = ir.dflag + OT_WORD;
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.mod == 3)
	I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
      else
	{
          ir.popl_esp_hack = 1 << ir.ot;
	  if (i386_record_lea_modrm (&ir))
	    return -1;
	}
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      break;

    case 0xc8:    /* enter */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REBP_REGNUM);
      if (ir.regmap[X86_RECORD_R8_REGNUM] && ir.dflag)
        ir.dflag = 2;
      if (i386_record_push (&ir, 1 << (ir.dflag + 1)))
	return -1;
      break;

    case 0xc9:    /* leave */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REBP_REGNUM);
      break;

    case 0x07:    /* pop es */
      if (ir.regmap[X86_RECORD_R8_REGNUM])
        {
	  ir.addr -= 1;
	  goto no_support;
	}
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_ES_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x17:    /* pop ss */
      if (ir.regmap[X86_RECORD_R8_REGNUM])
        {
	  ir.addr -= 1;
	  goto no_support;
	}
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_SS_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x1f:    /* pop ds */
      if (ir.regmap[X86_RECORD_R8_REGNUM])
        {
	  ir.addr -= 1;
	  goto no_support;
	}
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_DS_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x0fa1:    /* pop fs */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_FS_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x0fa9:    /* pop gs */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_GS_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x88:    /* mov */
    case 0x89:
    case 0xc6:
    case 0xc7:
      if ((opcode & 1) == 0)
	ir.ot = OT_BYTE;
      else
	ir.ot = ir.dflag + OT_WORD;

      if (i386_record_modrm (&ir))
	return -1;

      if (ir.mod != 3)
	{
          if (opcode == 0xc6 || opcode == 0xc7)
	    ir.rip_offset = (ir.ot > OT_LONG) ? 4 : (1 << ir.ot);
	  if (i386_record_lea_modrm (&ir))
	    return -1;
	}
      else
	{
          if (opcode == 0xc6 || opcode == 0xc7)
	    ir.rm |= ir.rex_b;
	  if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
	    ir.rm &= 0x3;
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm);
	}
      break;

    case 0x8a:    /* mov */
    case 0x8b:
      if ((opcode & 1) == 0)
	ir.ot = OT_BYTE;
      else
	ir.ot = ir.dflag + OT_WORD;
      if (i386_record_modrm (&ir))
	return -1;
      ir.reg |= rex_r;
      if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
	ir.reg &= 0x3;
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg);
      break;

    case 0x8c:    /* mov seg */
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.reg > 5)
	{
	  ir.addr -= 2;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	}

      if (ir.mod == 3)
	I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm);
      else
	{
	  ir.ot = OT_WORD;
	  if (i386_record_lea_modrm (&ir))
	    return -1;
	}
      break;

    case 0x8e:    /* mov seg */
      if (i386_record_modrm (&ir))
	return -1;
      switch (ir.reg)
	{
	case 0:
	  regnum = X86_RECORD_ES_REGNUM;
	  break;
	case 2:
	  regnum = X86_RECORD_SS_REGNUM;
	  break;
	case 3:
	  regnum = X86_RECORD_DS_REGNUM;
	  break;
	case 4:
	  regnum = X86_RECORD_FS_REGNUM;
	  break;
	case 5:
	  regnum = X86_RECORD_GS_REGNUM;
	  break;
	default:
	  ir.addr -= 2;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	  break;
	}
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (regnum);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x0fb6:    /* movzbS */
    case 0x0fb7:    /* movzwS */
    case 0x0fbe:    /* movsbS */
    case 0x0fbf:    /* movswS */
      if (i386_record_modrm (&ir))
	return -1;
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg | rex_r);
      break;

    case 0x8d:      /* lea */
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.mod == 3)
	{
	  ir.addr -= 2;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	}
      ir.ot = ir.dflag;
      ir.reg |= rex_r;
      if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
	ir.reg &= 0x3;
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg);
      break;

    case 0xa0:    /* mov EAX */
    case 0xa1:

    case 0xd7:    /* xlat */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      break;

    case 0xa2:    /* mov EAX */
    case 0xa3:
      if (ir.override >= 0)
        {
          if (record_full_memory_query)
            {
	      int q;

              target_terminal_ours ();
              q = yquery (_("\
Process record ignores the memory change of instruction at address %s\n\
because it can't get the value of the segment register.\n\
Do you want to stop the program?"),
                          paddress (gdbarch, ir.orig_addr));
              target_terminal_inferior ();
              if (q)
                return -1;
            }
	}
      else
	{
          if ((opcode & 1) == 0)
	    ir.ot = OT_BYTE;
	  else
	    ir.ot = ir.dflag + OT_WORD;
	  if (ir.aflag == 2)
	    {
              if (record_read_memory (gdbarch, ir.addr, buf, 8))
		return -1;
	      ir.addr += 8;
	      addr = extract_unsigned_integer (buf, 8, byte_order);
	    }
          else if (ir.aflag)
	    {
              if (record_read_memory (gdbarch, ir.addr, buf, 4))
		return -1;
	      ir.addr += 4;
              addr = extract_unsigned_integer (buf, 4, byte_order);
	    }
          else
	    {
              if (record_read_memory (gdbarch, ir.addr, buf, 2))
		return -1;
	      ir.addr += 2;
              addr = extract_unsigned_integer (buf, 2, byte_order);
	    }
	  if (record_full_arch_list_add_mem (addr, 1 << ir.ot))
	    return -1;
        }
      break;

    case 0xb0:    /* mov R, Ib */
    case 0xb1:
    case 0xb2:
    case 0xb3:
    case 0xb4:
    case 0xb5:
    case 0xb6:
    case 0xb7:
      I386_RECORD_FULL_ARCH_LIST_ADD_REG ((ir.regmap[X86_RECORD_R8_REGNUM])
					  ? ((opcode & 0x7) | ir.rex_b)
					  : ((opcode & 0x7) & 0x3));
      break;

    case 0xb8:    /* mov R, Iv */
    case 0xb9:
    case 0xba:
    case 0xbb:
    case 0xbc:
    case 0xbd:
    case 0xbe:
    case 0xbf:
      I386_RECORD_FULL_ARCH_LIST_ADD_REG ((opcode & 0x7) | ir.rex_b);
      break;

    case 0x91:    /* xchg R, EAX */
    case 0x92:
    case 0x93:
    case 0x94:
    case 0x95:
    case 0x96:
    case 0x97:
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (opcode & 0x7);
      break;

    case 0x86:    /* xchg Ev, Gv */
    case 0x87:
      if ((opcode & 1) == 0)
	ir.ot = OT_BYTE;
      else
	ir.ot = ir.dflag + OT_WORD;
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.mod == 3)
	{
	  ir.rm |= ir.rex_b;
	  if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
	    ir.rm &= 0x3;
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm);
	}
      else
	{
	  if (i386_record_lea_modrm (&ir))
	    return -1;
	}
      ir.reg |= rex_r;
      if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
	ir.reg &= 0x3;
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg);
      break;

    case 0xc4:    /* les Gv */
    case 0xc5:    /* lds Gv */
      if (ir.regmap[X86_RECORD_R8_REGNUM])
        {
	  ir.addr -= 1;
	  goto no_support;
	}
      /* FALLTHROUGH */
    case 0x0fb2:    /* lss Gv */
    case 0x0fb4:    /* lfs Gv */
    case 0x0fb5:    /* lgs Gv */
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.mod == 3)
	{
	  if (opcode > 0xff)
	    ir.addr -= 3;
	  else
	    ir.addr -= 2;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	}
      switch (opcode)
	{
	case 0xc4:    /* les Gv */
	  regnum = X86_RECORD_ES_REGNUM;
	  break;
	case 0xc5:    /* lds Gv */
	  regnum = X86_RECORD_DS_REGNUM;
	  break;
	case 0x0fb2:  /* lss Gv */
	  regnum = X86_RECORD_SS_REGNUM;
	  break;
	case 0x0fb4:  /* lfs Gv */
	  regnum = X86_RECORD_FS_REGNUM;
	  break;
	case 0x0fb5:  /* lgs Gv */
	  regnum = X86_RECORD_GS_REGNUM;
	  break;
	}
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (regnum);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg | rex_r);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0xc0:    /* shifts */
    case 0xc1:
    case 0xd0:
    case 0xd1:
    case 0xd2:
    case 0xd3:
      if ((opcode & 1) == 0)
	ir.ot = OT_BYTE;
      else
	ir.ot = ir.dflag + OT_WORD;
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.mod != 3 && (opcode == 0xd2 || opcode == 0xd3))
	{
	  if (i386_record_lea_modrm (&ir))
	    return -1;
	}
      else
	{
	  ir.rm |= ir.rex_b;
	  if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])
	    ir.rm &= 0x3;
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm);
	}
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x0fa4:
    case 0x0fa5:
    case 0x0fac:
    case 0x0fad:
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.mod == 3)
	{
	  if (record_full_arch_list_add_reg (ir.regcache, ir.rm))
	    return -1;
	}
      else
	{
	  if (i386_record_lea_modrm (&ir))
	    return -1;
	}
      break;

    case 0xd8:    /* Floats.  */
    case 0xd9:
    case 0xda:
    case 0xdb:
    case 0xdc:
    case 0xdd:
    case 0xde:
    case 0xdf:
      if (i386_record_modrm (&ir))
	return -1;
      ir.reg |= ((opcode & 7) << 3);
      if (ir.mod != 3)
	{
	  /* Memory.  */
	  uint64_t addr64;

	  if (i386_record_lea_modrm_addr (&ir, &addr64))
	    return -1;
	  switch (ir.reg)
	    {
	    case 0x02:
            case 0x12:
            case 0x22:
            case 0x32:
	      /* For fcom, ficom nothing to do.  */
              break;
	    case 0x03:
            case 0x13:
            case 0x23:
            case 0x33:
	      /* For fcomp, ficomp pop FPU stack, store all.  */
              if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_REGS))
                return -1;
              break;
            case 0x00:
            case 0x01:
	    case 0x04:
	    case 0x05:
	    case 0x06:
	    case 0x07:
	    case 0x10:
	    case 0x11:
	    case 0x14:
	    case 0x15:
	    case 0x16:
	    case 0x17:
	    case 0x20:
	    case 0x21:
	    case 0x24:
	    case 0x25:
	    case 0x26:
	    case 0x27:
	    case 0x30:
	    case 0x31:
	    case 0x34:
	    case 0x35:
	    case 0x36:
	    case 0x37:
              /* For fadd, fmul, fsub, fsubr, fdiv, fdivr, fiadd, fimul,
                 fisub, fisubr, fidiv, fidivr, modR/M.reg is an extension
                 of code,  always affects st(0) register.  */
              if (i386_record_floats (gdbarch, &ir, I387_ST0_REGNUM (tdep)))
                return -1;
	      break;
	    case 0x08:
	    case 0x0a:
	    case 0x0b:
	    case 0x18:
	    case 0x19:
	    case 0x1a:
	    case 0x1b:
            case 0x1d:
	    case 0x28:
	    case 0x29:
	    case 0x2a:
	    case 0x2b:
	    case 0x38:
	    case 0x39:
	    case 0x3a:
	    case 0x3b:
            case 0x3c:
            case 0x3d:
	      switch (ir.reg & 7)
		{
		case 0:
		  /* Handling fld, fild.  */
		  if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_REGS))
		    return -1;
		  break;
		case 1:
		  switch (ir.reg >> 4)
		    {
		    case 0:
		      if (record_full_arch_list_add_mem (addr64, 4))
			return -1;
		      break;
		    case 2:
		      if (record_full_arch_list_add_mem (addr64, 8))
			return -1;
		      break;
		    case 3:
		      break;
		    default:
		      if (record_full_arch_list_add_mem (addr64, 2))
			return -1;
		      break;
		    }
		  break;
		default:
		  switch (ir.reg >> 4)
		    {
		    case 0:
		      if (record_full_arch_list_add_mem (addr64, 4))
			return -1;
		      if (3 == (ir.reg & 7))
			{
			  /* For fstp m32fp.  */
			  if (i386_record_floats (gdbarch, &ir,
						  I386_SAVE_FPU_REGS))
			    return -1;
			}
		      break;
		    case 1:
		      if (record_full_arch_list_add_mem (addr64, 4))
			return -1;
		      if ((3 == (ir.reg & 7))
			  || (5 == (ir.reg & 7))
			  || (7 == (ir.reg & 7)))
			{
			  /* For fstp insn.  */
			  if (i386_record_floats (gdbarch, &ir,
						  I386_SAVE_FPU_REGS))
			    return -1;
			}
		      break;
		    case 2:
		      if (record_full_arch_list_add_mem (addr64, 8))
			return -1;
		      if (3 == (ir.reg & 7))
			{
			  /* For fstp m64fp.  */
			  if (i386_record_floats (gdbarch, &ir,
						  I386_SAVE_FPU_REGS))
			    return -1;
			}
		      break;
		    case 3:
		      if ((3 <= (ir.reg & 7)) && (6 <= (ir.reg & 7)))
			{
			  /* For fistp, fbld, fild, fbstp.  */
			  if (i386_record_floats (gdbarch, &ir,
						  I386_SAVE_FPU_REGS))
			    return -1;
			}
		      /* Fall through */
		    default:
		      if (record_full_arch_list_add_mem (addr64, 2))
			return -1;
		      break;
		    }
		  break;
		}
	      break;
	    case 0x0c:
              /* Insn fldenv.  */
              if (i386_record_floats (gdbarch, &ir,
                                      I386_SAVE_FPU_ENV_REG_STACK))
                return -1;
              break;
	    case 0x0d:
              /* Insn fldcw.  */
              if (i386_record_floats (gdbarch, &ir, I387_FCTRL_REGNUM (tdep)))
                return -1;
              break;
	    case 0x2c:
              /* Insn frstor.  */
              if (i386_record_floats (gdbarch, &ir,
                                      I386_SAVE_FPU_ENV_REG_STACK))
                return -1;
	      break;
	    case 0x0e:
	      if (ir.dflag)
		{
		  if (record_full_arch_list_add_mem (addr64, 28))
		    return -1;
		}
	      else
		{
		  if (record_full_arch_list_add_mem (addr64, 14))
		    return -1;
		}
	      break;
	    case 0x0f:
	    case 0x2f:
	      if (record_full_arch_list_add_mem (addr64, 2))
		return -1;
              /* Insn fstp, fbstp.  */
              if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_REGS))
                return -1;
	      break;
	    case 0x1f:
	    case 0x3e:
	      if (record_full_arch_list_add_mem (addr64, 10))
		return -1;
	      break;
	    case 0x2e:
	      if (ir.dflag)
		{
		  if (record_full_arch_list_add_mem (addr64, 28))
		    return -1;
		  addr64 += 28;
		}
	      else
		{
		  if (record_full_arch_list_add_mem (addr64, 14))
		    return -1;
		  addr64 += 14;
		}
	      if (record_full_arch_list_add_mem (addr64, 80))
		return -1;
	      /* Insn fsave.  */
	      if (i386_record_floats (gdbarch, &ir,
				      I386_SAVE_FPU_ENV_REG_STACK))
		return -1;
	      break;
	    case 0x3f:
	      if (record_full_arch_list_add_mem (addr64, 8))
		return -1;
	      /* Insn fistp.  */
	      if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_REGS))
		return -1;
	      break;
	    default:
	      ir.addr -= 2;
	      opcode = opcode << 8 | ir.modrm;
	      goto no_support;
	      break;
	    }
	}
      /* Opcode is an extension of modR/M byte.  */
      else
        {
	  switch (opcode)
	    {
	    case 0xd8:
	      if (i386_record_floats (gdbarch, &ir, I387_ST0_REGNUM (tdep)))
		return -1;
	      break;
	    case 0xd9:
	      if (0x0c == (ir.modrm >> 4))
		{
		  if ((ir.modrm & 0x0f) <= 7)
		    {
		      if (i386_record_floats (gdbarch, &ir,
					      I386_SAVE_FPU_REGS))
			return -1;
		    }
                  else
		    {
		      if (i386_record_floats (gdbarch, &ir,
					      I387_ST0_REGNUM (tdep)))
			return -1;
		      /* If only st(0) is changing, then we have already
			 recorded.  */
		      if ((ir.modrm & 0x0f) - 0x08)
			{
			  if (i386_record_floats (gdbarch, &ir,
						  I387_ST0_REGNUM (tdep) +
						  ((ir.modrm & 0x0f) - 0x08)))
			    return -1;
			}
		    }
		}
              else
                {
		  switch (ir.modrm)
		    {
		    case 0xe0:
		    case 0xe1:
		    case 0xf0:
		    case 0xf5:
		    case 0xf8:
		    case 0xfa:
		    case 0xfc:
		    case 0xfe:
		    case 0xff:
		      if (i386_record_floats (gdbarch, &ir,
					      I387_ST0_REGNUM (tdep)))
			return -1;
		      break;
		    case 0xf1:
		    case 0xf2:
		    case 0xf3:
		    case 0xf4:
		    case 0xf6:
		    case 0xf7:
		    case 0xe8:
		    case 0xe9:
		    case 0xea:
		    case 0xeb:
		    case 0xec:
		    case 0xed:
		    case 0xee:
		    case 0xf9:
		    case 0xfb:
		      if (i386_record_floats (gdbarch, &ir,
					      I386_SAVE_FPU_REGS))
			return -1;
		      break;
		    case 0xfd:
		      if (i386_record_floats (gdbarch, &ir,
					      I387_ST0_REGNUM (tdep)))
			return -1;
		      if (i386_record_floats (gdbarch, &ir,
					      I387_ST0_REGNUM (tdep) + 1))
			return -1;
		      break;
		    }
		}
              break;
            case 0xda:
              if (0xe9 == ir.modrm)
                {
		  if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_REGS))
		    return -1;
                }
              else if ((0x0c == ir.modrm >> 4) || (0x0d == ir.modrm >> 4))
                {
		  if (i386_record_floats (gdbarch, &ir,
					  I387_ST0_REGNUM (tdep)))
		    return -1;
		  if (((ir.modrm & 0x0f) > 0) && ((ir.modrm & 0x0f) <= 7))
		    {
		      if (i386_record_floats (gdbarch, &ir,
					      I387_ST0_REGNUM (tdep) +
					      (ir.modrm & 0x0f)))
			return -1;
		    }
		  else if ((ir.modrm & 0x0f) - 0x08)
		    {
		      if (i386_record_floats (gdbarch, &ir,
					      I387_ST0_REGNUM (tdep) +
					      ((ir.modrm & 0x0f) - 0x08)))
			return -1;
		    }
                }
              break;
            case 0xdb:
              if (0xe3 == ir.modrm)
                {
		  if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_ENV))
		    return -1;
                }
              else if ((0x0c == ir.modrm >> 4) || (0x0d == ir.modrm >> 4))
                {
		  if (i386_record_floats (gdbarch, &ir,
					  I387_ST0_REGNUM (tdep)))
		    return -1;
		  if (((ir.modrm & 0x0f) > 0) && ((ir.modrm & 0x0f) <= 7))
		    {
		      if (i386_record_floats (gdbarch, &ir,
					      I387_ST0_REGNUM (tdep) +
					      (ir.modrm & 0x0f)))
			return -1;
		    }
		  else if ((ir.modrm & 0x0f) - 0x08)
		    {
		      if (i386_record_floats (gdbarch, &ir,
					      I387_ST0_REGNUM (tdep) +
					      ((ir.modrm & 0x0f) - 0x08)))
			return -1;
		    }
                }
              break;
            case 0xdc:
              if ((0x0c == ir.modrm >> 4)
		  || (0x0d == ir.modrm >> 4)
		  || (0x0f == ir.modrm >> 4))
                {
		  if ((ir.modrm & 0x0f) <= 7)
		    {
		      if (i386_record_floats (gdbarch, &ir,
					      I387_ST0_REGNUM (tdep) +
					      (ir.modrm & 0x0f)))
			return -1;
		    }
		  else
		    {
		      if (i386_record_floats (gdbarch, &ir,
					      I387_ST0_REGNUM (tdep) +
					      ((ir.modrm & 0x0f) - 0x08)))
			return -1;
		    }
                }
	      break;
            case 0xdd:
              if (0x0c == ir.modrm >> 4)
                {
                  if (i386_record_floats (gdbarch, &ir,
                                          I387_FTAG_REGNUM (tdep)))
                    return -1;
                }
              else if ((0x0d == ir.modrm >> 4) || (0x0e == ir.modrm >> 4))
                {
                  if ((ir.modrm & 0x0f) <= 7)
                    {
		      if (i386_record_floats (gdbarch, &ir,
					      I387_ST0_REGNUM (tdep) +
					      (ir.modrm & 0x0f)))
			return -1;
                    }
                  else
                    {
                      if (i386_record_floats (gdbarch, &ir,
					      I386_SAVE_FPU_REGS))
                        return -1;
                    }
                }
              break;
            case 0xde:
              if ((0x0c == ir.modrm >> 4)
		  || (0x0e == ir.modrm >> 4)
		  || (0x0f == ir.modrm >> 4)
		  || (0xd9 == ir.modrm))
                {
		  if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_REGS))
		    return -1;
                }
              break;
            case 0xdf:
              if (0xe0 == ir.modrm)
                {
		  if (record_full_arch_list_add_reg (ir.regcache,
						     I386_EAX_REGNUM))
		    return -1;
                }
              else if ((0x0f == ir.modrm >> 4) || (0x0e == ir.modrm >> 4))
                {
		  if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_REGS))
		    return -1;
                }
              break;
	    }
	}
      break;
      /* string ops */
    case 0xa4:    /* movsS */
    case 0xa5:
    case 0xaa:    /* stosS */
    case 0xab:
    case 0x6c:    /* insS */
    case 0x6d:
      regcache_raw_read_unsigned (ir.regcache,
                                  ir.regmap[X86_RECORD_RECX_REGNUM],
                                  &addr);
      if (addr)
        {
          ULONGEST es, ds;

          if ((opcode & 1) == 0)
	    ir.ot = OT_BYTE;
          else
	    ir.ot = ir.dflag + OT_WORD;
          regcache_raw_read_unsigned (ir.regcache,
                                      ir.regmap[X86_RECORD_REDI_REGNUM],
                                      &addr);

          regcache_raw_read_unsigned (ir.regcache,
                                      ir.regmap[X86_RECORD_ES_REGNUM],
                                      &es);
          regcache_raw_read_unsigned (ir.regcache,
                                      ir.regmap[X86_RECORD_DS_REGNUM],
                                      &ds);
          if (ir.aflag && (es != ds))
            {
              /* addr += ((uint32_t) read_register (I386_ES_REGNUM)) << 4; */
              if (record_full_memory_query)
                {
	          int q;

                  target_terminal_ours ();
                  q = yquery (_("\
Process record ignores the memory change of instruction at address %s\n\
because it can't get the value of the segment register.\n\
Do you want to stop the program?"),
                              paddress (gdbarch, ir.orig_addr));
                  target_terminal_inferior ();
                  if (q)
                    return -1;
                }
            }
          else
            {
              if (record_full_arch_list_add_mem (addr, 1 << ir.ot))
                return -1;
            }

          if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
            I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
          if (opcode == 0xa4 || opcode == 0xa5)
            I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);
          I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDI_REGNUM);
          I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
	}
      break;

    case 0xa6:    /* cmpsS */
    case 0xa7:
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDI_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
        I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0xac:    /* lodsS */
    case 0xad:
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
        I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0xae:    /* scasS */
    case 0xaf:
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDI_REGNUM);
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
        I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x6e:    /* outsS */
    case 0x6f:
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
        I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0xe4:    /* port I/O */
    case 0xe5:
    case 0xec:
    case 0xed:
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      break;

    case 0xe6:
    case 0xe7:
    case 0xee:
    case 0xef:
      break;

      /* control */
    case 0xc2:    /* ret im */
    case 0xc3:    /* ret */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0xca:    /* lret im */
    case 0xcb:    /* lret */
    case 0xcf:    /* iret */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_CS_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0xe8:    /* call im */
      if (ir.regmap[X86_RECORD_R8_REGNUM] && ir.dflag)
        ir.dflag = 2;
      if (i386_record_push (&ir, 1 << (ir.dflag + 1)))
        return -1;
      break;

    case 0x9a:    /* lcall im */
      if (ir.regmap[X86_RECORD_R8_REGNUM])
        {
          ir.addr -= 1;
          goto no_support;
        }
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_CS_REGNUM);
      if (i386_record_push (&ir, 1 << (ir.dflag + 1)))
        return -1;
      break;

    case 0xe9:    /* jmp im */
    case 0xea:    /* ljmp im */
    case 0xeb:    /* jmp Jb */
    case 0x70:    /* jcc Jb */
    case 0x71:
    case 0x72:
    case 0x73:
    case 0x74:
    case 0x75:
    case 0x76:
    case 0x77:
    case 0x78:
    case 0x79:
    case 0x7a:
    case 0x7b:
    case 0x7c:
    case 0x7d:
    case 0x7e:
    case 0x7f:
    case 0x0f80:  /* jcc Jv */
    case 0x0f81:
    case 0x0f82:
    case 0x0f83:
    case 0x0f84:
    case 0x0f85:
    case 0x0f86:
    case 0x0f87:
    case 0x0f88:
    case 0x0f89:
    case 0x0f8a:
    case 0x0f8b:
    case 0x0f8c:
    case 0x0f8d:
    case 0x0f8e:
    case 0x0f8f:
      break;

    case 0x0f90:  /* setcc Gv */
    case 0x0f91:
    case 0x0f92:
    case 0x0f93:
    case 0x0f94:
    case 0x0f95:
    case 0x0f96:
    case 0x0f97:
    case 0x0f98:
    case 0x0f99:
    case 0x0f9a:
    case 0x0f9b:
    case 0x0f9c:
    case 0x0f9d:
    case 0x0f9e:
    case 0x0f9f:
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      ir.ot = OT_BYTE;
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.mod == 3)
        I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rex_b ? (ir.rm | ir.rex_b)
					    : (ir.rm & 0x3));
      else
	{
	  if (i386_record_lea_modrm (&ir))
	    return -1;
	}
      break;

    case 0x0f40:    /* cmov Gv, Ev */
    case 0x0f41:
    case 0x0f42:
    case 0x0f43:
    case 0x0f44:
    case 0x0f45:
    case 0x0f46:
    case 0x0f47:
    case 0x0f48:
    case 0x0f49:
    case 0x0f4a:
    case 0x0f4b:
    case 0x0f4c:
    case 0x0f4d:
    case 0x0f4e:
    case 0x0f4f:
      if (i386_record_modrm (&ir))
	return -1;
      ir.reg |= rex_r;
      if (ir.dflag == OT_BYTE)
	ir.reg &= 0x3;
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg);
      break;

      /* flags */
    case 0x9c:    /* pushf */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      if (ir.regmap[X86_RECORD_R8_REGNUM] && ir.dflag)
        ir.dflag = 2;
      if (i386_record_push (&ir, 1 << (ir.dflag + 1)))
        return -1;
      break;

    case 0x9d:    /* popf */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x9e:    /* sahf */
      if (ir.regmap[X86_RECORD_R8_REGNUM])
        {
          ir.addr -= 1;
          goto no_support;
        }
      /* FALLTHROUGH */
    case 0xf5:    /* cmc */
    case 0xf8:    /* clc */
    case 0xf9:    /* stc */
    case 0xfc:    /* cld */
    case 0xfd:    /* std */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x9f:    /* lahf */
      if (ir.regmap[X86_RECORD_R8_REGNUM])
        {
          ir.addr -= 1;
          goto no_support;
        }
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      break;

      /* bit operations */
    case 0x0fba:    /* bt/bts/btr/btc Gv, im */
      ir.ot = ir.dflag + OT_WORD;
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.reg < 4)
	{
	  ir.addr -= 2;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	}
      if (ir.reg != 4)
	{
          if (ir.mod == 3)
            I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
	  else
	    {
	      if (i386_record_lea_modrm (&ir))
		return -1;
	    }
	}
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x0fa3:    /* bt Gv, Ev */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x0fab:    /* bts */
    case 0x0fb3:    /* btr */
    case 0x0fbb:    /* btc */
      ir.ot = ir.dflag + OT_WORD;
      if (i386_record_modrm (&ir))
        return -1;
      if (ir.mod == 3)
        I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
      else
        {
          uint64_t addr64;
          if (i386_record_lea_modrm_addr (&ir, &addr64))
            return -1;
          regcache_raw_read_unsigned (ir.regcache,
                                      ir.regmap[ir.reg | rex_r],
                                      &addr);
          switch (ir.dflag)
            {
            case 0:
              addr64 += ((int16_t) addr >> 4) << 4;
              break;
            case 1:
              addr64 += ((int32_t) addr >> 5) << 5;
              break;
            case 2:
              addr64 += ((int64_t) addr >> 6) << 6;
              break;
            }
          if (record_full_arch_list_add_mem (addr64, 1 << ir.ot))
            return -1;
          if (i386_record_lea_modrm (&ir))
            return -1;
        }
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x0fbc:    /* bsf */
    case 0x0fbd:    /* bsr */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg | rex_r);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

      /* bcd */
    case 0x27:    /* daa */
    case 0x2f:    /* das */
    case 0x37:    /* aaa */
    case 0x3f:    /* aas */
    case 0xd4:    /* aam */
    case 0xd5:    /* aad */
      if (ir.regmap[X86_RECORD_R8_REGNUM])
        {
          ir.addr -= 1;
          goto no_support;
        }
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

      /* misc */
    case 0x90:    /* nop */
      if (prefixes & PREFIX_LOCK)
	{
	  ir.addr -= 1;
	  goto no_support;
	}
      break;

    case 0x9b:    /* fwait */
      if (record_read_memory (gdbarch, ir.addr, &opcode8, 1))
	return -1;
      opcode = (uint32_t) opcode8;
      ir.addr++;
      goto reswitch;
      break;

      /* XXX */
    case 0xcc:    /* int3 */
      printf_unfiltered (_("Process record does not support instruction "
			   "int3.\n"));
      ir.addr -= 1;
      goto no_support;
      break;

      /* XXX */
    case 0xcd:    /* int */
      {
	int ret;
	uint8_t interrupt;
	if (record_read_memory (gdbarch, ir.addr, &interrupt, 1))
	  return -1;
	ir.addr++;
	if (interrupt != 0x80
	    || tdep->i386_intx80_record == NULL)
	  {
	    printf_unfiltered (_("Process record does not support "
				 "instruction int 0x%02x.\n"),
			       interrupt);
	    ir.addr -= 2;
	    goto no_support;
	  }
	ret = tdep->i386_intx80_record (ir.regcache);
	if (ret)
	  return ret;
      }
      break;

      /* XXX */
    case 0xce:    /* into */
      printf_unfiltered (_("Process record does not support "
			   "instruction into.\n"));
      ir.addr -= 1;
      goto no_support;
      break;

    case 0xfa:    /* cli */
    case 0xfb:    /* sti */
      break;

    case 0x62:    /* bound */
      printf_unfiltered (_("Process record does not support "
			   "instruction bound.\n"));
      ir.addr -= 1;
      goto no_support;
      break;

    case 0x0fc8:    /* bswap reg */
    case 0x0fc9:
    case 0x0fca:
    case 0x0fcb:
    case 0x0fcc:
    case 0x0fcd:
    case 0x0fce:
    case 0x0fcf:
      I386_RECORD_FULL_ARCH_LIST_ADD_REG ((opcode & 7) | ir.rex_b);
      break;

    case 0xd6:    /* salc */
      if (ir.regmap[X86_RECORD_R8_REGNUM])
        {
          ir.addr -= 1;
          goto no_support;
        }
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0xe0:    /* loopnz */
    case 0xe1:    /* loopz */
    case 0xe2:    /* loop */
    case 0xe3:    /* jecxz */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x0f30:    /* wrmsr */
      printf_unfiltered (_("Process record does not support "
			   "instruction wrmsr.\n"));
      ir.addr -= 2;
      goto no_support;
      break;

    case 0x0f32:    /* rdmsr */
      printf_unfiltered (_("Process record does not support "
			   "instruction rdmsr.\n"));
      ir.addr -= 2;
      goto no_support;
      break;

    case 0x0f31:    /* rdtsc */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDX_REGNUM);
      break;

    case 0x0f34:    /* sysenter */
      {
	int ret;
        if (ir.regmap[X86_RECORD_R8_REGNUM])
          {
            ir.addr -= 2;
            goto no_support;
          }
	if (tdep->i386_sysenter_record == NULL)
	  {
	    printf_unfiltered (_("Process record does not support "
				 "instruction sysenter.\n"));
	    ir.addr -= 2;
	    goto no_support;
	  }
	ret = tdep->i386_sysenter_record (ir.regcache);
	if (ret)
	  return ret;
      }
      break;

    case 0x0f35:    /* sysexit */
      printf_unfiltered (_("Process record does not support "
			   "instruction sysexit.\n"));
      ir.addr -= 2;
      goto no_support;
      break;

    case 0x0f05:    /* syscall */
      {
	int ret;
	if (tdep->i386_syscall_record == NULL)
	  {
	    printf_unfiltered (_("Process record does not support "
				 "instruction syscall.\n"));
	    ir.addr -= 2;
	    goto no_support;
	  }
	ret = tdep->i386_syscall_record (ir.regcache);
	if (ret)
	  return ret;
      }
      break;

    case 0x0f07:    /* sysret */
      printf_unfiltered (_("Process record does not support "
                           "instruction sysret.\n"));
      ir.addr -= 2;
      goto no_support;
      break;

    case 0x0fa2:    /* cpuid */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REBX_REGNUM);
      break;

    case 0xf4:    /* hlt */
      printf_unfiltered (_("Process record does not support "
			   "instruction hlt.\n"));
      ir.addr -= 1;
      goto no_support;
      break;

    case 0x0f00:
      if (i386_record_modrm (&ir))
	return -1;
      switch (ir.reg)
	{
	case 0:  /* sldt */
	case 1:  /* str  */
	  if (ir.mod == 3)
            I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
	  else
	    {
	      ir.ot = OT_WORD;
	      if (i386_record_lea_modrm (&ir))
		return -1;
	    }
	  break;
	case 2:  /* lldt */
	case 3:  /* ltr */
	  break;
	case 4:  /* verr */
	case 5:  /* verw */
          I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
	  break;
	default:
	  ir.addr -= 3;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	  break;
	}
      break;

    case 0x0f01:
      if (i386_record_modrm (&ir))
	return -1;
      switch (ir.reg)
	{
	case 0:  /* sgdt */
	  {
	    uint64_t addr64;

	    if (ir.mod == 3)
	      {
		ir.addr -= 3;
		opcode = opcode << 8 | ir.modrm;
		goto no_support;
	      }
	    if (ir.override >= 0)
	      {
                if (record_full_memory_query)
                  {
	            int q;

                    target_terminal_ours ();
                    q = yquery (_("\
Process record ignores the memory change of instruction at address %s\n\
because it can't get the value of the segment register.\n\
Do you want to stop the program?"),
                                paddress (gdbarch, ir.orig_addr));
                    target_terminal_inferior ();
                    if (q)
                      return -1;
                  }
	      }
	    else
	      {
		if (i386_record_lea_modrm_addr (&ir, &addr64))
		  return -1;
		if (record_full_arch_list_add_mem (addr64, 2))
		  return -1;
		addr64 += 2;
                if (ir.regmap[X86_RECORD_R8_REGNUM])
                  {
                    if (record_full_arch_list_add_mem (addr64, 8))
		      return -1;
                  }
                else
                  {
                    if (record_full_arch_list_add_mem (addr64, 4))
		      return -1;
                  }
	      }
	  }
	  break;
	case 1:
	  if (ir.mod == 3)
	    {
	      switch (ir.rm)
		{
		case 0:  /* monitor */
		  break;
		case 1:  /* mwait */
		  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
		  break;
		default:
		  ir.addr -= 3;
		  opcode = opcode << 8 | ir.modrm;
		  goto no_support;
		  break;
		}
	    }
	  else
	    {
	      /* sidt */
	      if (ir.override >= 0)
		{
                  if (record_full_memory_query)
                    {
	              int q;

                      target_terminal_ours ();
                      q = yquery (_("\
Process record ignores the memory change of instruction at address %s\n\
because it can't get the value of the segment register.\n\
Do you want to stop the program?"),
                                  paddress (gdbarch, ir.orig_addr));
                      target_terminal_inferior ();
                      if (q)
                        return -1;
                    }
		}
	      else
		{
		  uint64_t addr64;

		  if (i386_record_lea_modrm_addr (&ir, &addr64))
		    return -1;
		  if (record_full_arch_list_add_mem (addr64, 2))
		    return -1;
		  addr64 += 2;
                  if (ir.regmap[X86_RECORD_R8_REGNUM])
                    {
                      if (record_full_arch_list_add_mem (addr64, 8))
		        return -1;
                    }
                  else
                    {
                      if (record_full_arch_list_add_mem (addr64, 4))
		        return -1;
                    }
		}
	    }
	  break;
	case 2:  /* lgdt */
	  if (ir.mod == 3)
	    {
	      /* xgetbv */
	      if (ir.rm == 0)
		{
		  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
		  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDX_REGNUM);
		  break;
		}
	      /* xsetbv */
	      else if (ir.rm == 1)
		break;
	    }
	case 3:  /* lidt */
	  if (ir.mod == 3)
	    {
	      ir.addr -= 3;
	      opcode = opcode << 8 | ir.modrm;
	      goto no_support;
	    }
	  break;
	case 4:  /* smsw */
	  if (ir.mod == 3)
	    {
	      if (record_full_arch_list_add_reg (ir.regcache, ir.rm | ir.rex_b))
		return -1;
	    }
	  else
	    {
	      ir.ot = OT_WORD;
	      if (i386_record_lea_modrm (&ir))
		return -1;
	    }
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
	  break;
	case 6:  /* lmsw */
	  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
	  break;
	case 7:  /* invlpg */
	  if (ir.mod == 3)
	    {
	      if (ir.rm == 0 && ir.regmap[X86_RECORD_R8_REGNUM])
	        I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_GS_REGNUM);
	      else
	        {
	          ir.addr -= 3;
	          opcode = opcode << 8 | ir.modrm;
	          goto no_support;
	        }
	    }
	  else
	    I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
	  break;
	default:
	  ir.addr -= 3;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	  break;
	}
      break;

    case 0x0f08:    /* invd */
    case 0x0f09:    /* wbinvd */
      break;

    case 0x63:    /* arpl */
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.mod == 3 || ir.regmap[X86_RECORD_R8_REGNUM])
        {
          I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.regmap[X86_RECORD_R8_REGNUM]
					      ? (ir.reg | rex_r) : ir.rm);
        }
      else
        {
          ir.ot = ir.dflag ? OT_LONG : OT_WORD;
          if (i386_record_lea_modrm (&ir))
            return -1;
        }
      if (!ir.regmap[X86_RECORD_R8_REGNUM])
        I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x0f02:    /* lar */
    case 0x0f03:    /* lsl */
      if (i386_record_modrm (&ir))
	return -1;
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg | rex_r);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    case 0x0f18:
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.mod == 3 && ir.reg == 3)
        {
	  ir.addr -= 3;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	}
      break;

    case 0x0f19:
    case 0x0f1a:
    case 0x0f1b:
    case 0x0f1c:
    case 0x0f1d:
    case 0x0f1e:
    case 0x0f1f:
      /* nop (multi byte) */
      break;

    case 0x0f20:    /* mov reg, crN */
    case 0x0f22:    /* mov crN, reg */
      if (i386_record_modrm (&ir))
	return -1;
      if ((ir.modrm & 0xc0) != 0xc0)
	{
	  ir.addr -= 3;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	}
      switch (ir.reg)
	{
	case 0:
	case 2:
	case 3:
	case 4:
	case 8:
	  if (opcode & 2)
	    I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
	  else
            I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
	  break;
	default:
	  ir.addr -= 3;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	  break;
	}
      break;

    case 0x0f21:    /* mov reg, drN */
    case 0x0f23:    /* mov drN, reg */
      if (i386_record_modrm (&ir))
	return -1;
      if ((ir.modrm & 0xc0) != 0xc0 || ir.reg == 4
	  || ir.reg == 5 || ir.reg >= 8)
	{
	  ir.addr -= 3;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	}
      if (opcode & 2)
        I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      else
	I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
      break;

    case 0x0f06:    /* clts */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      break;

    /* MMX 3DNow! SSE SSE2 SSE3 SSSE3 SSE4 */

    case 0x0f0d:    /* 3DNow! prefetch */
      break;

    case 0x0f0e:    /* 3DNow! femms */
    case 0x0f77:    /* emms */
      if (i386_fpc_regnum_p (gdbarch, I387_FTAG_REGNUM(tdep)))
        goto no_support;
      record_full_arch_list_add_reg (ir.regcache, I387_FTAG_REGNUM(tdep));
      break;

    case 0x0f0f:    /* 3DNow! data */
      if (i386_record_modrm (&ir))
	return -1;
      if (record_read_memory (gdbarch, ir.addr, &opcode8, 1))
	return -1;
      ir.addr++;
      switch (opcode8)
        {
        case 0x0c:    /* 3DNow! pi2fw */
        case 0x0d:    /* 3DNow! pi2fd */
        case 0x1c:    /* 3DNow! pf2iw */
        case 0x1d:    /* 3DNow! pf2id */
        case 0x8a:    /* 3DNow! pfnacc */
        case 0x8e:    /* 3DNow! pfpnacc */
        case 0x90:    /* 3DNow! pfcmpge */
        case 0x94:    /* 3DNow! pfmin */
        case 0x96:    /* 3DNow! pfrcp */
        case 0x97:    /* 3DNow! pfrsqrt */
        case 0x9a:    /* 3DNow! pfsub */
        case 0x9e:    /* 3DNow! pfadd */
        case 0xa0:    /* 3DNow! pfcmpgt */
        case 0xa4:    /* 3DNow! pfmax */
        case 0xa6:    /* 3DNow! pfrcpit1 */
        case 0xa7:    /* 3DNow! pfrsqit1 */
        case 0xaa:    /* 3DNow! pfsubr */
        case 0xae:    /* 3DNow! pfacc */
        case 0xb0:    /* 3DNow! pfcmpeq */
        case 0xb4:    /* 3DNow! pfmul */
        case 0xb6:    /* 3DNow! pfrcpit2 */
        case 0xb7:    /* 3DNow! pmulhrw */
        case 0xbb:    /* 3DNow! pswapd */
        case 0xbf:    /* 3DNow! pavgusb */
          if (!i386_mmx_regnum_p (gdbarch, I387_MM0_REGNUM (tdep) + ir.reg))
            goto no_support_3dnow_data;
          record_full_arch_list_add_reg (ir.regcache, ir.reg);
          break;

        default:
no_support_3dnow_data:
          opcode = (opcode << 8) | opcode8;
          goto no_support;
          break;
        }
      break;

    case 0x0faa:    /* rsm */
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REBX_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REBP_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);
      I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDI_REGNUM);
      break;

    case 0x0fae:
      if (i386_record_modrm (&ir))
	return -1;
      switch(ir.reg)
        {
        case 0:    /* fxsave */
          {
            uint64_t tmpu64;

            I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
	    if (i386_record_lea_modrm_addr (&ir, &tmpu64))
	      return -1;
            if (record_full_arch_list_add_mem (tmpu64, 512))
              return -1;
          }
          break;

        case 1:    /* fxrstor */
          {
            int i;

            I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);

            for (i = I387_MM0_REGNUM (tdep);
                 i386_mmx_regnum_p (gdbarch, i); i++)
              record_full_arch_list_add_reg (ir.regcache, i);

            for (i = I387_XMM0_REGNUM (tdep);
                 i386_xmm_regnum_p (gdbarch, i); i++)
              record_full_arch_list_add_reg (ir.regcache, i);

            if (i386_mxcsr_regnum_p (gdbarch, I387_MXCSR_REGNUM(tdep)))
              record_full_arch_list_add_reg (ir.regcache,
					     I387_MXCSR_REGNUM(tdep));

            for (i = I387_ST0_REGNUM (tdep);
                 i386_fp_regnum_p (gdbarch, i); i++)
              record_full_arch_list_add_reg (ir.regcache, i);

            for (i = I387_FCTRL_REGNUM (tdep);
                 i386_fpc_regnum_p (gdbarch, i); i++)
              record_full_arch_list_add_reg (ir.regcache, i);
          }
          break;

        case 2:    /* ldmxcsr */
          if (!i386_mxcsr_regnum_p (gdbarch, I387_MXCSR_REGNUM(tdep)))
            goto no_support;
          record_full_arch_list_add_reg (ir.regcache, I387_MXCSR_REGNUM(tdep));
          break;

        case 3:    /* stmxcsr */
          ir.ot = OT_LONG;
          if (i386_record_lea_modrm (&ir))
            return -1;
          break;

        case 5:    /* lfence */
        case 6:    /* mfence */
        case 7:    /* sfence clflush */
          break;

        default:
          opcode = (opcode << 8) | ir.modrm;
          goto no_support;
          break;
        }
      break;

    case 0x0fc3:    /* movnti */
      ir.ot = (ir.dflag == 2) ? OT_QUAD : OT_LONG;
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.mod == 3)
        goto no_support;
      ir.reg |= rex_r;
      if (i386_record_lea_modrm (&ir))
        return -1;
      break;

    /* Add prefix to opcode.  */
    case 0x0f10:
    case 0x0f11:
    case 0x0f12:
    case 0x0f13:
    case 0x0f14:
    case 0x0f15:
    case 0x0f16:
    case 0x0f17:
    case 0x0f28:
    case 0x0f29:
    case 0x0f2a:
    case 0x0f2b:
    case 0x0f2c:
    case 0x0f2d:
    case 0x0f2e:
    case 0x0f2f:
    case 0x0f38:
    case 0x0f39:
    case 0x0f3a:
    case 0x0f50:
    case 0x0f51:
    case 0x0f52:
    case 0x0f53:
    case 0x0f54:
    case 0x0f55:
    case 0x0f56:
    case 0x0f57:
    case 0x0f58:
    case 0x0f59:
    case 0x0f5a:
    case 0x0f5b:
    case 0x0f5c:
    case 0x0f5d:
    case 0x0f5e:
    case 0x0f5f:
    case 0x0f60:
    case 0x0f61:
    case 0x0f62:
    case 0x0f63:
    case 0x0f64:
    case 0x0f65:
    case 0x0f66:
    case 0x0f67:
    case 0x0f68:
    case 0x0f69:
    case 0x0f6a:
    case 0x0f6b:
    case 0x0f6c:
    case 0x0f6d:
    case 0x0f6e:
    case 0x0f6f:
    case 0x0f70:
    case 0x0f71:
    case 0x0f72:
    case 0x0f73:
    case 0x0f74:
    case 0x0f75:
    case 0x0f76:
    case 0x0f7c:
    case 0x0f7d:
    case 0x0f7e:
    case 0x0f7f:
    case 0x0fb8:
    case 0x0fc2:
    case 0x0fc4:
    case 0x0fc5:
    case 0x0fc6:
    case 0x0fd0:
    case 0x0fd1:
    case 0x0fd2:
    case 0x0fd3:
    case 0x0fd4:
    case 0x0fd5:
    case 0x0fd6:
    case 0x0fd7:
    case 0x0fd8:
    case 0x0fd9:
    case 0x0fda:
    case 0x0fdb:
    case 0x0fdc:
    case 0x0fdd:
    case 0x0fde:
    case 0x0fdf:
    case 0x0fe0:
    case 0x0fe1:
    case 0x0fe2:
    case 0x0fe3:
    case 0x0fe4:
    case 0x0fe5:
    case 0x0fe6:
    case 0x0fe7:
    case 0x0fe8:
    case 0x0fe9:
    case 0x0fea:
    case 0x0feb:
    case 0x0fec:
    case 0x0fed:
    case 0x0fee:
    case 0x0fef:
    case 0x0ff0:
    case 0x0ff1:
    case 0x0ff2:
    case 0x0ff3:
    case 0x0ff4:
    case 0x0ff5:
    case 0x0ff6:
    case 0x0ff7:
    case 0x0ff8:
    case 0x0ff9:
    case 0x0ffa:
    case 0x0ffb:
    case 0x0ffc:
    case 0x0ffd:
    case 0x0ffe:
      switch (prefixes)
        {
        case PREFIX_REPNZ:
          opcode |= 0xf20000;
          break;
        case PREFIX_DATA:
          opcode |= 0x660000;
          break;
        case PREFIX_REPZ:
          opcode |= 0xf30000;
          break;
        }
reswitch_prefix_add:
      switch (opcode)
        {
        case 0x0f38:
        case 0x660f38:
        case 0xf20f38:
        case 0x0f3a:
        case 0x660f3a:
          if (record_read_memory (gdbarch, ir.addr, &opcode8, 1))
	    return -1;
          ir.addr++;
          opcode = (uint32_t) opcode8 | opcode << 8;
          goto reswitch_prefix_add;
          break;

        case 0x0f10:        /* movups */
        case 0x660f10:      /* movupd */
        case 0xf30f10:      /* movss */
        case 0xf20f10:      /* movsd */
        case 0x0f12:        /* movlps */
        case 0x660f12:      /* movlpd */
        case 0xf30f12:      /* movsldup */
        case 0xf20f12:      /* movddup */
        case 0x0f14:        /* unpcklps */
        case 0x660f14:      /* unpcklpd */
        case 0x0f15:        /* unpckhps */
        case 0x660f15:      /* unpckhpd */
        case 0x0f16:        /* movhps */
        case 0x660f16:      /* movhpd */
        case 0xf30f16:      /* movshdup */
        case 0x0f28:        /* movaps */
        case 0x660f28:      /* movapd */
        case 0x0f2a:        /* cvtpi2ps */
        case 0x660f2a:      /* cvtpi2pd */
        case 0xf30f2a:      /* cvtsi2ss */
        case 0xf20f2a:      /* cvtsi2sd */
        case 0x0f2c:        /* cvttps2pi */
        case 0x660f2c:      /* cvttpd2pi */
        case 0x0f2d:        /* cvtps2pi */
        case 0x660f2d:      /* cvtpd2pi */
        case 0x660f3800:    /* pshufb */
        case 0x660f3801:    /* phaddw */
        case 0x660f3802:    /* phaddd */
        case 0x660f3803:    /* phaddsw */
        case 0x660f3804:    /* pmaddubsw */
        case 0x660f3805:    /* phsubw */
        case 0x660f3806:    /* phsubd */
        case 0x660f3807:    /* phsubsw */
        case 0x660f3808:    /* psignb */
        case 0x660f3809:    /* psignw */
        case 0x660f380a:    /* psignd */
        case 0x660f380b:    /* pmulhrsw */
        case 0x660f3810:    /* pblendvb */
        case 0x660f3814:    /* blendvps */
        case 0x660f3815:    /* blendvpd */
        case 0x660f381c:    /* pabsb */
        case 0x660f381d:    /* pabsw */
        case 0x660f381e:    /* pabsd */
        case 0x660f3820:    /* pmovsxbw */
        case 0x660f3821:    /* pmovsxbd */
        case 0x660f3822:    /* pmovsxbq */
        case 0x660f3823:    /* pmovsxwd */
        case 0x660f3824:    /* pmovsxwq */
        case 0x660f3825:    /* pmovsxdq */
        case 0x660f3828:    /* pmuldq */
        case 0x660f3829:    /* pcmpeqq */
        case 0x660f382a:    /* movntdqa */
        case 0x660f3a08:    /* roundps */
        case 0x660f3a09:    /* roundpd */
        case 0x660f3a0a:    /* roundss */
        case 0x660f3a0b:    /* roundsd */
        case 0x660f3a0c:    /* blendps */
        case 0x660f3a0d:    /* blendpd */
        case 0x660f3a0e:    /* pblendw */
        case 0x660f3a0f:    /* palignr */
        case 0x660f3a20:    /* pinsrb */
        case 0x660f3a21:    /* insertps */
        case 0x660f3a22:    /* pinsrd pinsrq */
        case 0x660f3a40:    /* dpps */
        case 0x660f3a41:    /* dppd */
        case 0x660f3a42:    /* mpsadbw */
        case 0x660f3a60:    /* pcmpestrm */
        case 0x660f3a61:    /* pcmpestri */
        case 0x660f3a62:    /* pcmpistrm */
        case 0x660f3a63:    /* pcmpistri */
        case 0x0f51:        /* sqrtps */
        case 0x660f51:      /* sqrtpd */
        case 0xf20f51:      /* sqrtsd */
        case 0xf30f51:      /* sqrtss */
        case 0x0f52:        /* rsqrtps */
        case 0xf30f52:      /* rsqrtss */
        case 0x0f53:        /* rcpps */
        case 0xf30f53:      /* rcpss */
        case 0x0f54:        /* andps */
        case 0x660f54:      /* andpd */
        case 0x0f55:        /* andnps */
        case 0x660f55:      /* andnpd */
        case 0x0f56:        /* orps */
        case 0x660f56:      /* orpd */
        case 0x0f57:        /* xorps */
        case 0x660f57:      /* xorpd */
        case 0x0f58:        /* addps */
        case 0x660f58:      /* addpd */
        case 0xf20f58:      /* addsd */
        case 0xf30f58:      /* addss */
        case 0x0f59:        /* mulps */
        case 0x660f59:      /* mulpd */
        case 0xf20f59:      /* mulsd */
        case 0xf30f59:      /* mulss */
        case 0x0f5a:        /* cvtps2pd */
        case 0x660f5a:      /* cvtpd2ps */
        case 0xf20f5a:      /* cvtsd2ss */
        case 0xf30f5a:      /* cvtss2sd */
        case 0x0f5b:        /* cvtdq2ps */
        case 0x660f5b:      /* cvtps2dq */
        case 0xf30f5b:      /* cvttps2dq */
        case 0x0f5c:        /* subps */
        case 0x660f5c:      /* subpd */
        case 0xf20f5c:      /* subsd */
        case 0xf30f5c:      /* subss */
        case 0x0f5d:        /* minps */
        case 0x660f5d:      /* minpd */
        case 0xf20f5d:      /* minsd */
        case 0xf30f5d:      /* minss */
        case 0x0f5e:        /* divps */
        case 0x660f5e:      /* divpd */
        case 0xf20f5e:      /* divsd */
        case 0xf30f5e:      /* divss */
        case 0x0f5f:        /* maxps */
        case 0x660f5f:      /* maxpd */
        case 0xf20f5f:      /* maxsd */
        case 0xf30f5f:      /* maxss */
        case 0x660f60:      /* punpcklbw */
        case 0x660f61:      /* punpcklwd */
        case 0x660f62:      /* punpckldq */
        case 0x660f63:      /* packsswb */
        case 0x660f64:      /* pcmpgtb */
        case 0x660f65:      /* pcmpgtw */
        case 0x660f66:      /* pcmpgtd */
        case 0x660f67:      /* packuswb */
        case 0x660f68:      /* punpckhbw */
        case 0x660f69:      /* punpckhwd */
        case 0x660f6a:      /* punpckhdq */
        case 0x660f6b:      /* packssdw */
        case 0x660f6c:      /* punpcklqdq */
        case 0x660f6d:      /* punpckhqdq */
        case 0x660f6e:      /* movd */
        case 0x660f6f:      /* movdqa */
        case 0xf30f6f:      /* movdqu */
        case 0x660f70:      /* pshufd */
        case 0xf20f70:      /* pshuflw */
        case 0xf30f70:      /* pshufhw */
        case 0x660f74:      /* pcmpeqb */
        case 0x660f75:      /* pcmpeqw */
        case 0x660f76:      /* pcmpeqd */
        case 0x660f7c:      /* haddpd */
        case 0xf20f7c:      /* haddps */
        case 0x660f7d:      /* hsubpd */
        case 0xf20f7d:      /* hsubps */
        case 0xf30f7e:      /* movq */
        case 0x0fc2:        /* cmpps */
        case 0x660fc2:      /* cmppd */
        case 0xf20fc2:      /* cmpsd */
        case 0xf30fc2:      /* cmpss */
        case 0x660fc4:      /* pinsrw */
        case 0x0fc6:        /* shufps */
        case 0x660fc6:      /* shufpd */
        case 0x660fd0:      /* addsubpd */
        case 0xf20fd0:      /* addsubps */
        case 0x660fd1:      /* psrlw */
        case 0x660fd2:      /* psrld */
        case 0x660fd3:      /* psrlq */
        case 0x660fd4:      /* paddq */
        case 0x660fd5:      /* pmullw */
        case 0xf30fd6:      /* movq2dq */
        case 0x660fd8:      /* psubusb */
        case 0x660fd9:      /* psubusw */
        case 0x660fda:      /* pminub */
        case 0x660fdb:      /* pand */
        case 0x660fdc:      /* paddusb */
        case 0x660fdd:      /* paddusw */
        case 0x660fde:      /* pmaxub */
        case 0x660fdf:      /* pandn */
        case 0x660fe0:      /* pavgb */
        case 0x660fe1:      /* psraw */
        case 0x660fe2:      /* psrad */
        case 0x660fe3:      /* pavgw */
        case 0x660fe4:      /* pmulhuw */
        case 0x660fe5:      /* pmulhw */
        case 0x660fe6:      /* cvttpd2dq */
        case 0xf20fe6:      /* cvtpd2dq */
        case 0xf30fe6:      /* cvtdq2pd */
        case 0x660fe8:      /* psubsb */
        case 0x660fe9:      /* psubsw */
        case 0x660fea:      /* pminsw */
        case 0x660feb:      /* por */
        case 0x660fec:      /* paddsb */
        case 0x660fed:      /* paddsw */
        case 0x660fee:      /* pmaxsw */
        case 0x660fef:      /* pxor */
        case 0xf20ff0:      /* lddqu */
        case 0x660ff1:      /* psllw */
        case 0x660ff2:      /* pslld */
        case 0x660ff3:      /* psllq */
        case 0x660ff4:      /* pmuludq */
        case 0x660ff5:      /* pmaddwd */
        case 0x660ff6:      /* psadbw */
        case 0x660ff8:      /* psubb */
        case 0x660ff9:      /* psubw */
        case 0x660ffa:      /* psubd */
        case 0x660ffb:      /* psubq */
        case 0x660ffc:      /* paddb */
        case 0x660ffd:      /* paddw */
        case 0x660ffe:      /* paddd */
          if (i386_record_modrm (&ir))
	    return -1;
          ir.reg |= rex_r;
          if (!i386_xmm_regnum_p (gdbarch, I387_XMM0_REGNUM (tdep) + ir.reg))
            goto no_support;
          record_full_arch_list_add_reg (ir.regcache,
					 I387_XMM0_REGNUM (tdep) + ir.reg);
          if ((opcode & 0xfffffffc) == 0x660f3a60)
            I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
          break;

        case 0x0f11:        /* movups */
        case 0x660f11:      /* movupd */
        case 0xf30f11:      /* movss */
        case 0xf20f11:      /* movsd */
        case 0x0f13:        /* movlps */
        case 0x660f13:      /* movlpd */
        case 0x0f17:        /* movhps */
        case 0x660f17:      /* movhpd */
        case 0x0f29:        /* movaps */
        case 0x660f29:      /* movapd */
        case 0x660f3a14:    /* pextrb */
        case 0x660f3a15:    /* pextrw */
        case 0x660f3a16:    /* pextrd pextrq */
        case 0x660f3a17:    /* extractps */
        case 0x660f7f:      /* movdqa */
        case 0xf30f7f:      /* movdqu */
          if (i386_record_modrm (&ir))
	    return -1;
          if (ir.mod == 3)
            {
              if (opcode == 0x0f13 || opcode == 0x660f13
                  || opcode == 0x0f17 || opcode == 0x660f17)
                goto no_support;
              ir.rm |= ir.rex_b;
              if (!i386_xmm_regnum_p (gdbarch,
				      I387_XMM0_REGNUM (tdep) + ir.rm))
                goto no_support;
              record_full_arch_list_add_reg (ir.regcache,
					     I387_XMM0_REGNUM (tdep) + ir.rm);
            }
          else
            {
              switch (opcode)
                {
                  case 0x660f3a14:
                    ir.ot = OT_BYTE;
                    break;
                  case 0x660f3a15:
                    ir.ot = OT_WORD;
                    break;
                  case 0x660f3a16:
                    ir.ot = OT_LONG;
                    break;
                  case 0x660f3a17:
                    ir.ot = OT_QUAD;
                    break;
                  default:
                    ir.ot = OT_DQUAD;
                    break;
                }
              if (i386_record_lea_modrm (&ir))
                return -1;
            }
          break;

        case 0x0f2b:      /* movntps */
        case 0x660f2b:    /* movntpd */
        case 0x0fe7:      /* movntq */
        case 0x660fe7:    /* movntdq */
          if (ir.mod == 3)
            goto no_support;
          if (opcode == 0x0fe7)
            ir.ot = OT_QUAD;
          else
            ir.ot = OT_DQUAD;
          if (i386_record_lea_modrm (&ir))
            return -1;
          break;

        case 0xf30f2c:      /* cvttss2si */
        case 0xf20f2c:      /* cvttsd2si */
        case 0xf30f2d:      /* cvtss2si */
        case 0xf20f2d:      /* cvtsd2si */
        case 0xf20f38f0:    /* crc32 */
        case 0xf20f38f1:    /* crc32 */
        case 0x0f50:        /* movmskps */
        case 0x660f50:      /* movmskpd */
        case 0x0fc5:        /* pextrw */
        case 0x660fc5:      /* pextrw */
        case 0x0fd7:        /* pmovmskb */
        case 0x660fd7:      /* pmovmskb */
          I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg | rex_r);
          break;

        case 0x0f3800:    /* pshufb */
        case 0x0f3801:    /* phaddw */
        case 0x0f3802:    /* phaddd */
        case 0x0f3803:    /* phaddsw */
        case 0x0f3804:    /* pmaddubsw */
        case 0x0f3805:    /* phsubw */
        case 0x0f3806:    /* phsubd */
        case 0x0f3807:    /* phsubsw */
        case 0x0f3808:    /* psignb */
        case 0x0f3809:    /* psignw */
        case 0x0f380a:    /* psignd */
        case 0x0f380b:    /* pmulhrsw */
        case 0x0f381c:    /* pabsb */
        case 0x0f381d:    /* pabsw */
        case 0x0f381e:    /* pabsd */
        case 0x0f382b:    /* packusdw */
        case 0x0f3830:    /* pmovzxbw */
        case 0x0f3831:    /* pmovzxbd */
        case 0x0f3832:    /* pmovzxbq */
        case 0x0f3833:    /* pmovzxwd */
        case 0x0f3834:    /* pmovzxwq */
        case 0x0f3835:    /* pmovzxdq */
        case 0x0f3837:    /* pcmpgtq */
        case 0x0f3838:    /* pminsb */
        case 0x0f3839:    /* pminsd */
        case 0x0f383a:    /* pminuw */
        case 0x0f383b:    /* pminud */
        case 0x0f383c:    /* pmaxsb */
        case 0x0f383d:    /* pmaxsd */
        case 0x0f383e:    /* pmaxuw */
        case 0x0f383f:    /* pmaxud */
        case 0x0f3840:    /* pmulld */
        case 0x0f3841:    /* phminposuw */
        case 0x0f3a0f:    /* palignr */
        case 0x0f60:      /* punpcklbw */
        case 0x0f61:      /* punpcklwd */
        case 0x0f62:      /* punpckldq */
        case 0x0f63:      /* packsswb */
        case 0x0f64:      /* pcmpgtb */
        case 0x0f65:      /* pcmpgtw */
        case 0x0f66:      /* pcmpgtd */
        case 0x0f67:      /* packuswb */
        case 0x0f68:      /* punpckhbw */
        case 0x0f69:      /* punpckhwd */
        case 0x0f6a:      /* punpckhdq */
        case 0x0f6b:      /* packssdw */
        case 0x0f6e:      /* movd */
        case 0x0f6f:      /* movq */
        case 0x0f70:      /* pshufw */
        case 0x0f74:      /* pcmpeqb */
        case 0x0f75:      /* pcmpeqw */
        case 0x0f76:      /* pcmpeqd */
        case 0x0fc4:      /* pinsrw */
        case 0x0fd1:      /* psrlw */
        case 0x0fd2:      /* psrld */
        case 0x0fd3:      /* psrlq */
        case 0x0fd4:      /* paddq */
        case 0x0fd5:      /* pmullw */
        case 0xf20fd6:    /* movdq2q */
        case 0x0fd8:      /* psubusb */
        case 0x0fd9:      /* psubusw */
        case 0x0fda:      /* pminub */
        case 0x0fdb:      /* pand */
        case 0x0fdc:      /* paddusb */
        case 0x0fdd:      /* paddusw */
        case 0x0fde:      /* pmaxub */
        case 0x0fdf:      /* pandn */
        case 0x0fe0:      /* pavgb */
        case 0x0fe1:      /* psraw */
        case 0x0fe2:      /* psrad */
        case 0x0fe3:      /* pavgw */
        case 0x0fe4:      /* pmulhuw */
        case 0x0fe5:      /* pmulhw */
        case 0x0fe8:      /* psubsb */
        case 0x0fe9:      /* psubsw */
        case 0x0fea:      /* pminsw */
        case 0x0feb:      /* por */
        case 0x0fec:      /* paddsb */
        case 0x0fed:      /* paddsw */
        case 0x0fee:      /* pmaxsw */
        case 0x0fef:      /* pxor */
        case 0x0ff1:      /* psllw */
        case 0x0ff2:      /* pslld */
        case 0x0ff3:      /* psllq */
        case 0x0ff4:      /* pmuludq */
        case 0x0ff5:      /* pmaddwd */
        case 0x0ff6:      /* psadbw */
        case 0x0ff8:      /* psubb */
        case 0x0ff9:      /* psubw */
        case 0x0ffa:      /* psubd */
        case 0x0ffb:      /* psubq */
        case 0x0ffc:      /* paddb */
        case 0x0ffd:      /* paddw */
        case 0x0ffe:      /* paddd */
          if (i386_record_modrm (&ir))
	    return -1;
          if (!i386_mmx_regnum_p (gdbarch, I387_MM0_REGNUM (tdep) + ir.reg))
            goto no_support;
          record_full_arch_list_add_reg (ir.regcache,
					 I387_MM0_REGNUM (tdep) + ir.reg);
          break;

        case 0x0f71:    /* psllw */
        case 0x0f72:    /* pslld */
        case 0x0f73:    /* psllq */
          if (i386_record_modrm (&ir))
	    return -1;
          if (!i386_mmx_regnum_p (gdbarch, I387_MM0_REGNUM (tdep) + ir.rm))
            goto no_support;
          record_full_arch_list_add_reg (ir.regcache,
					 I387_MM0_REGNUM (tdep) + ir.rm);
          break;

        case 0x660f71:    /* psllw */
        case 0x660f72:    /* pslld */
        case 0x660f73:    /* psllq */
          if (i386_record_modrm (&ir))
	    return -1;
          ir.rm |= ir.rex_b;
          if (!i386_xmm_regnum_p (gdbarch, I387_XMM0_REGNUM (tdep) + ir.rm))
            goto no_support;
          record_full_arch_list_add_reg (ir.regcache,
					 I387_XMM0_REGNUM (tdep) + ir.rm);
          break;

        case 0x0f7e:      /* movd */
        case 0x660f7e:    /* movd */
          if (i386_record_modrm (&ir))
	    return -1;
          if (ir.mod == 3)
            I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
          else
            {
              if (ir.dflag == 2)
                ir.ot = OT_QUAD;
              else
                ir.ot = OT_LONG;
              if (i386_record_lea_modrm (&ir))
                return -1;
            }
          break;

        case 0x0f7f:    /* movq */
          if (i386_record_modrm (&ir))
	    return -1;
          if (ir.mod == 3)
            {
              if (!i386_mmx_regnum_p (gdbarch, I387_MM0_REGNUM (tdep) + ir.rm))
                goto no_support;
              record_full_arch_list_add_reg (ir.regcache,
					     I387_MM0_REGNUM (tdep) + ir.rm);
            }
          else
            {
              ir.ot = OT_QUAD;
              if (i386_record_lea_modrm (&ir))
                return -1;
            }
          break;

        case 0xf30fb8:    /* popcnt */
          if (i386_record_modrm (&ir))
	    return -1;
          I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg);
          I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
          break;

        case 0x660fd6:    /* movq */
          if (i386_record_modrm (&ir))
	    return -1;
          if (ir.mod == 3)
            {
              ir.rm |= ir.rex_b;
              if (!i386_xmm_regnum_p (gdbarch,
				      I387_XMM0_REGNUM (tdep) + ir.rm))
                goto no_support;
              record_full_arch_list_add_reg (ir.regcache,
					     I387_XMM0_REGNUM (tdep) + ir.rm);
            }
          else
            {
              ir.ot = OT_QUAD;
              if (i386_record_lea_modrm (&ir))
                return -1;
            }
          break;

        case 0x660f3817:    /* ptest */
        case 0x0f2e:        /* ucomiss */
        case 0x660f2e:      /* ucomisd */
        case 0x0f2f:        /* comiss */
        case 0x660f2f:      /* comisd */
          I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
          break;

        case 0x0ff7:    /* maskmovq */
          regcache_raw_read_unsigned (ir.regcache,
                                      ir.regmap[X86_RECORD_REDI_REGNUM],
                                      &addr);
          if (record_full_arch_list_add_mem (addr, 64))
            return -1;
          break;

        case 0x660ff7:    /* maskmovdqu */
          regcache_raw_read_unsigned (ir.regcache,
                                      ir.regmap[X86_RECORD_REDI_REGNUM],
                                      &addr);
          if (record_full_arch_list_add_mem (addr, 128))
            return -1;
          break;

        default:
          goto no_support;
          break;
        }
      break;

    default:
      goto no_support;
      break;
    }

  /* In the future, maybe still need to deal with need_dasm.  */
  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REIP_REGNUM);
  if (record_full_arch_list_add_end ())
    return -1;

  return 0;

 no_support:
  printf_unfiltered (_("Process record does not support instruction 0x%02x "
                       "at address %s.\n"),
                     (unsigned int) (opcode),
                     paddress (gdbarch, ir.orig_addr));
  return -1;
}

static const int i386_record_regmap[] =
{
  I386_EAX_REGNUM, I386_ECX_REGNUM, I386_EDX_REGNUM, I386_EBX_REGNUM,
  I386_ESP_REGNUM, I386_EBP_REGNUM, I386_ESI_REGNUM, I386_EDI_REGNUM,
  0, 0, 0, 0, 0, 0, 0, 0,
  I386_EIP_REGNUM, I386_EFLAGS_REGNUM, I386_CS_REGNUM, I386_SS_REGNUM,
  I386_DS_REGNUM, I386_ES_REGNUM, I386_FS_REGNUM, I386_GS_REGNUM
};

/* Check that the given address appears suitable for a fast
   tracepoint, which on x86-64 means that we need an instruction of at
   least 5 bytes, so that we can overwrite it with a 4-byte-offset
   jump and not have to worry about program jumps to an address in the
   middle of the tracepoint jump.  On x86, it may be possible to use
   4-byte jumps with a 2-byte offset to a trampoline located in the
   bottom 64 KiB of memory.  Returns 1 if OK, and writes a size
   of instruction to replace, and 0 if not, plus an explanatory
   string.  */

static int
i386_fast_tracepoint_valid_at (struct gdbarch *gdbarch,
			       CORE_ADDR addr, int *isize, char **msg)
{
  int len, jumplen;
  static struct ui_file *gdb_null = NULL;

  /*  Ask the target for the minimum instruction length supported.  */
  jumplen = target_get_min_fast_tracepoint_insn_len ();

  if (jumplen < 0)
    {
      /* If the target does not support the get_min_fast_tracepoint_insn_len
	 operation, assume that fast tracepoints will always be implemented
	 using 4-byte relative jumps on both x86 and x86-64.  */
      jumplen = 5;
    }
  else if (jumplen == 0)
    {
      /* If the target does support get_min_fast_tracepoint_insn_len but
	 returns zero, then the IPA has not loaded yet.  In this case,
	 we optimistically assume that truncated 2-byte relative jumps
	 will be available on x86, and compensate later if this assumption
	 turns out to be incorrect.  On x86-64 architectures, 4-byte relative
	 jumps will always be used.  */
      jumplen = (register_size (gdbarch, 0) == 8) ? 5 : 4;
    }

  /* Dummy file descriptor for the disassembler.  */
  if (!gdb_null)
    gdb_null = ui_file_new ();

  /* Check for fit.  */
  len = gdb_print_insn (gdbarch, addr, gdb_null, NULL);
  if (isize)
    *isize = len;

  if (len < jumplen)
    {
      /* Return a bit of target-specific detail to add to the caller's
	 generic failure message.  */
      if (msg)
	*msg = xstrprintf (_("; instruction is only %d bytes long, "
			     "need at least %d bytes for the jump"),
			   len, jumplen);
      return 0;
    }
  else
    {
      if (msg)
	*msg = NULL;
      return 1;
    }
}

static int
i386_validate_tdesc_p (struct gdbarch_tdep *tdep,
		       struct tdesc_arch_data *tdesc_data)
{
  const struct target_desc *tdesc = tdep->tdesc;
  const struct tdesc_feature *feature_core;
  const struct tdesc_feature *feature_sse, *feature_avx;
  int i, num_regs, valid_p;

  if (! tdesc_has_registers (tdesc))
    return 0;

  /* Get core registers.  */
  feature_core = tdesc_find_feature (tdesc, "org.gnu.gdb.i386.core");
  if (feature_core == NULL)
    return 0;

  /* Get SSE registers.  */
  feature_sse = tdesc_find_feature (tdesc, "org.gnu.gdb.i386.sse");

  /* Try AVX registers.  */
  feature_avx = tdesc_find_feature (tdesc, "org.gnu.gdb.i386.avx");

  valid_p = 1;

  /* The XCR0 bits.  */
  if (feature_avx)
    {
      /* AVX register description requires SSE register description.  */
      if (!feature_sse)
	return 0;

      tdep->xcr0 = I386_XSTATE_AVX_MASK;

      /* It may have been set by OSABI initialization function.  */
      if (tdep->num_ymm_regs == 0)
	{
	  tdep->ymmh_register_names = i386_ymmh_names;
	  tdep->num_ymm_regs = 8;
	  tdep->ymm0h_regnum = I386_YMM0H_REGNUM;
	}

      for (i = 0; i < tdep->num_ymm_regs; i++)
	valid_p &= tdesc_numbered_register (feature_avx, tdesc_data,
					    tdep->ymm0h_regnum + i,
					    tdep->ymmh_register_names[i]);
    }
  else if (feature_sse)
    tdep->xcr0 = I386_XSTATE_SSE_MASK;
  else
    {
      tdep->xcr0 = I386_XSTATE_X87_MASK;
      tdep->num_xmm_regs = 0;
    }

  num_regs = tdep->num_core_regs;
  for (i = 0; i < num_regs; i++)
    valid_p &= tdesc_numbered_register (feature_core, tdesc_data, i,
					tdep->register_names[i]);

  if (feature_sse)
    {
      /* Need to include %mxcsr, so add one.  */
      num_regs += tdep->num_xmm_regs + 1;
      for (; i < num_regs; i++)
	valid_p &= tdesc_numbered_register (feature_sse, tdesc_data, i,
					    tdep->register_names[i]);
    }

  return valid_p;
}


static struct gdbarch *
i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;
  struct tdesc_arch_data *tdesc_data;
  const struct target_desc *tdesc;
  int mm0_regnum;
  int ymm0_regnum;

  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* Allocate space for the new architecture.  */
  tdep = XCALLOC (1, struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  /* General-purpose registers.  */
  tdep->gregset = NULL;
  tdep->gregset_reg_offset = NULL;
  tdep->gregset_num_regs = I386_NUM_GREGS;
  tdep->sizeof_gregset = 0;

  /* Floating-point registers.  */
  tdep->fpregset = NULL;
  tdep->sizeof_fpregset = I387_SIZEOF_FSAVE;

  tdep->xstateregset = NULL;

  /* The default settings include the FPU registers, the MMX registers
     and the SSE registers.  This can be overridden for a specific ABI
     by adjusting the members `st0_regnum', `mm0_regnum' and
     `num_xmm_regs' of `struct gdbarch_tdep', otherwise the registers
     will show up in the output of "info all-registers".  */

  tdep->st0_regnum = I386_ST0_REGNUM;

  /* I386_NUM_XREGS includes %mxcsr, so substract one.  */
  tdep->num_xmm_regs = I386_NUM_XREGS - 1;

  tdep->jb_pc_offset = -1;
  tdep->struct_return = pcc_struct_return;
  tdep->sigtramp_start = 0;
  tdep->sigtramp_end = 0;
  tdep->sigtramp_p = i386_sigtramp_p;
  tdep->sigcontext_addr = NULL;
  tdep->sc_reg_offset = NULL;
  tdep->sc_pc_offset = -1;
  tdep->sc_sp_offset = -1;

  tdep->xsave_xcr0_offset = -1;

  tdep->record_regmap = i386_record_regmap;

  set_gdbarch_long_long_align_bit (gdbarch, 32);

  /* The format used for `long double' on almost all i386 targets is
     the i387 extended floating-point format.  In fact, of all targets
     in the GCC 2.95 tree, only OSF/1 does it different, and insists
     on having a `long double' that's not `long' at all.  */
  set_gdbarch_long_double_format (gdbarch, floatformats_i387_ext);

  /* Although the i387 extended floating-point has only 80 significant
     bits, a `long double' actually takes up 96, probably to enforce
     alignment.  */
  set_gdbarch_long_double_bit (gdbarch, 96);

  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, I386_ESP_REGNUM); /* %esp */
  set_gdbarch_pc_regnum (gdbarch, I386_EIP_REGNUM); /* %eip */
  set_gdbarch_ps_regnum (gdbarch, I386_EFLAGS_REGNUM); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, I386_ST0_REGNUM); /* %st(0) */

  /* NOTE: kettenis/20040418: GCC does have two possible register
     numbering schemes on the i386: dbx and SVR4.  These schemes
     differ in how they number %ebp, %esp, %eflags, and the
     floating-point registers, and are implemented by the arrays
     dbx_register_map[] and svr4_dbx_register_map in
     gcc/config/i386.c.  GCC also defines a third numbering scheme in
     gcc/config/i386.c, which it designates as the "default" register
     map used in 64bit mode.  This last register numbering scheme is
     implemented in dbx64_register_map, and is used for AMD64; see
     amd64-tdep.c.

     Currently, each GCC i386 target always uses the same register
     numbering scheme across all its supported debugging formats
     i.e. SDB (COFF), stabs and DWARF 2.  This is because
     gcc/sdbout.c, gcc/dbxout.c and gcc/dwarf2out.c all use the
     DBX_REGISTER_NUMBER macro which is defined by each target's
     respective config header in a manner independent of the requested
     output debugging format.

     This does not match the arrangement below, which presumes that
     the SDB and stabs numbering schemes differ from the DWARF and
     DWARF 2 ones.  The reason for this arrangement is that it is
     likely to get the numbering scheme for the target's
     default/native debug format right.  For targets where GCC is the
     native compiler (FreeBSD, NetBSD, OpenBSD, GNU/Linux) or for
     targets where the native toolchain uses a different numbering
     scheme for a particular debug format (stabs-in-ELF on Solaris)
     the defaults below will have to be overridden, like
     i386_elf_init_abi() does.  */

  /* Use the dbx register numbering scheme for stabs and COFF.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);
  set_gdbarch_sdb_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);

  /* Use the SVR4 register numbering scheme for DWARF 2.  */
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, i386_svr4_reg_to_regnum);

  /* We don't set gdbarch_stab_reg_to_regnum, since ECOFF doesn't seem to
     be in use on any of the supported i386 targets.  */

  set_gdbarch_print_float_info (gdbarch, i387_print_float_info);

  set_gdbarch_get_longjmp_target (gdbarch, i386_get_longjmp_target);

  /* Call dummy code.  */
  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
  set_gdbarch_push_dummy_code (gdbarch, i386_push_dummy_code);
  set_gdbarch_push_dummy_call (gdbarch, i386_push_dummy_call);
  set_gdbarch_frame_align (gdbarch, i386_frame_align);

  set_gdbarch_convert_register_p (gdbarch, i386_convert_register_p);
  set_gdbarch_register_to_value (gdbarch,  i386_register_to_value);
  set_gdbarch_value_to_register (gdbarch, i386_value_to_register);

  set_gdbarch_return_value (gdbarch, i386_return_value);

  set_gdbarch_skip_prologue (gdbarch, i386_skip_prologue);

  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);

  set_gdbarch_breakpoint_from_pc (gdbarch, i386_breakpoint_from_pc);
  set_gdbarch_decr_pc_after_break (gdbarch, 1);
  set_gdbarch_max_insn_length (gdbarch, I386_MAX_INSN_LEN);

  set_gdbarch_frame_args_skip (gdbarch, 8);

  set_gdbarch_print_insn (gdbarch, i386_print_insn);

  set_gdbarch_dummy_id (gdbarch, i386_dummy_id);

  set_gdbarch_unwind_pc (gdbarch, i386_unwind_pc);

  /* Add the i386 register groups.  */
  i386_add_reggroups (gdbarch);
  tdep->register_reggroup_p = i386_register_reggroup_p;

  /* Helper for function argument information.  */
  set_gdbarch_fetch_pointer_argument (gdbarch, i386_fetch_pointer_argument);

  /* Hook the function epilogue frame unwinder.  This unwinder is
     appended to the list first, so that it supercedes the DWARF
     unwinder in function epilogues (where the DWARF unwinder
     currently fails).  */
  frame_unwind_append_unwinder (gdbarch, &i386_epilogue_frame_unwind);

  /* Hook in the DWARF CFI frame unwinder.  This unwinder is appended
     to the list before the prologue-based unwinders, so that DWARF
     CFI info will be used if it is available.  */
  dwarf2_append_unwinders (gdbarch);

  frame_base_set_default (gdbarch, &i386_frame_base);

  /* Pseudo registers may be changed by amd64_init_abi.  */
  set_gdbarch_pseudo_register_read_value (gdbarch,
					  i386_pseudo_register_read_value);
  set_gdbarch_pseudo_register_write (gdbarch, i386_pseudo_register_write);

  set_tdesc_pseudo_register_type (gdbarch, i386_pseudo_register_type);
  set_tdesc_pseudo_register_name (gdbarch, i386_pseudo_register_name);

  /* Override the normal target description method to make the AVX
     upper halves anonymous.  */
  set_gdbarch_register_name (gdbarch, i386_register_name);

  /* Even though the default ABI only includes general-purpose registers,
     floating-point registers and the SSE registers, we have to leave a
     gap for the upper AVX registers.  */
  set_gdbarch_num_regs (gdbarch, I386_AVX_NUM_REGS);

  /* Get the x86 target description from INFO.  */
  tdesc = info.target_desc;
  if (! tdesc_has_registers (tdesc))
    tdesc = tdesc_i386;
  tdep->tdesc = tdesc;

  tdep->num_core_regs = I386_NUM_GREGS + I387_NUM_REGS;
  tdep->register_names = i386_register_names;

  /* No upper YMM registers.  */
  tdep->ymmh_register_names = NULL;
  tdep->ymm0h_regnum = -1;

  tdep->num_byte_regs = 8;
  tdep->num_word_regs = 8;
  tdep->num_dword_regs = 0;
  tdep->num_mmx_regs = 8;
  tdep->num_ymm_regs = 0;

  tdesc_data = tdesc_data_alloc ();

  set_gdbarch_relocate_instruction (gdbarch, i386_relocate_instruction);

  set_gdbarch_gen_return_address (gdbarch, i386_gen_return_address);

  /* Hook in ABI-specific overrides, if they have been registered.  */
  info.tdep_info = (void *) tdesc_data;
  gdbarch_init_osabi (info, gdbarch);

  if (!i386_validate_tdesc_p (tdep, tdesc_data))
    {
      tdesc_data_cleanup (tdesc_data);
      xfree (tdep);
      gdbarch_free (gdbarch);
      return NULL;
    }

  /* Wire in pseudo registers.  Number of pseudo registers may be
     changed.  */
  set_gdbarch_num_pseudo_regs (gdbarch, (tdep->num_byte_regs
					 + tdep->num_word_regs
					 + tdep->num_dword_regs
					 + tdep->num_mmx_regs
					 + tdep->num_ymm_regs));

  /* Target description may be changed.  */
  tdesc = tdep->tdesc;

  tdesc_use_registers (gdbarch, tdesc, tdesc_data);

  /* Override gdbarch_register_reggroup_p set in tdesc_use_registers.  */
  set_gdbarch_register_reggroup_p (gdbarch, tdep->register_reggroup_p);

  /* Make %al the first pseudo-register.  */
  tdep->al_regnum = gdbarch_num_regs (gdbarch);
  tdep->ax_regnum = tdep->al_regnum + tdep->num_byte_regs;

  ymm0_regnum = tdep->ax_regnum + tdep->num_word_regs;
  if (tdep->num_dword_regs)
    {
      /* Support dword pseudo-register if it hasn't been disabled.  */
      tdep->eax_regnum = ymm0_regnum;
      ymm0_regnum += tdep->num_dword_regs;
    }
  else
    tdep->eax_regnum = -1;

  mm0_regnum = ymm0_regnum;
  if (tdep->num_ymm_regs)
    {
      /* Support YMM pseudo-register if it is available.  */
      tdep->ymm0_regnum = ymm0_regnum;
      mm0_regnum += tdep->num_ymm_regs;
    }
  else
    tdep->ymm0_regnum = -1;

  if (tdep->num_mmx_regs != 0)
    {
      /* Support MMX pseudo-register if MMX hasn't been disabled.  */
      tdep->mm0_regnum = mm0_regnum;
    }
  else
    tdep->mm0_regnum = -1;

  /* Hook in the legacy prologue-based unwinders last (fallback).  */
  frame_unwind_append_unwinder (gdbarch, &i386_stack_tramp_frame_unwind);
  frame_unwind_append_unwinder (gdbarch, &i386_sigtramp_frame_unwind);
  frame_unwind_append_unwinder (gdbarch, &i386_frame_unwind);

  /* If we have a register mapping, enable the generic core file
     support, unless it has already been enabled.  */
  if (tdep->gregset_reg_offset
      && !gdbarch_regset_from_core_section_p (gdbarch))
    set_gdbarch_regset_from_core_section (gdbarch,
					  i386_regset_from_core_section);

  set_gdbarch_skip_permanent_breakpoint (gdbarch,
					 i386_skip_permanent_breakpoint);

  set_gdbarch_fast_tracepoint_valid_at (gdbarch,
					i386_fast_tracepoint_valid_at);

  return gdbarch;
}

static enum gdb_osabi
i386_coff_osabi_sniffer (bfd *abfd)
{
  if (strcmp (bfd_get_target (abfd), "coff-go32-exe") == 0
      || strcmp (bfd_get_target (abfd), "coff-go32") == 0)
    return GDB_OSABI_GO32;

  return GDB_OSABI_UNKNOWN;
}


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_i386_tdep (void);

void
_initialize_i386_tdep (void)
{
  register_gdbarch_init (bfd_arch_i386, i386_gdbarch_init);

  /* Add the variable that controls the disassembly flavor.  */
  add_setshow_enum_cmd ("disassembly-flavor", no_class, valid_flavors,
			&disassembly_flavor, _("\
Set the disassembly flavor."), _("\
Show the disassembly flavor."), _("\
The valid values are \"att\" and \"intel\", and the default value is \"att\"."),
			NULL,
			NULL, /* FIXME: i18n: */
			&setlist, &showlist);

  /* Add the variable that controls the convention for returning
     structs.  */
  add_setshow_enum_cmd ("struct-convention", no_class, valid_conventions,
			&struct_convention, _("\
Set the convention for returning small structs."), _("\
Show the convention for returning small structs."), _("\
Valid values are \"default\", \"pcc\" and \"reg\", and the default value\n\
is \"default\"."),
			NULL,
			NULL, /* FIXME: i18n: */
			&setlist, &showlist);

  gdbarch_register_osabi_sniffer (bfd_arch_i386, bfd_target_coff_flavour,
				  i386_coff_osabi_sniffer);

  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_SVR4,
			  i386_svr4_init_abi);
  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_GO32,
			  i386_go32_init_abi);

  /* Initialize the i386-specific register groups.  */
  i386_init_reggroups ();

  /* Initialize the standard target descriptions.  */
  initialize_tdesc_i386 ();
  initialize_tdesc_i386_mmx ();
  initialize_tdesc_i386_avx ();

  /* Tell remote stub that we support XML target description.  */
  register_remote_support_xml ("i386");
}
@


1.372
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d2097 1
a2097 1
i386_in_stack_tramp_p (struct gdbarch *gdbarch, CORE_ADDR pc)
d2126 1
a2126 2
    return i386_in_stack_tramp_p (get_frame_arch (this_frame),
				  get_frame_pc (this_frame));
@


1.371
log
@More invalid pointer to pointer conversions.

As a follow up to:

  http://sourceware.org/ml/gdb-patches/2013-03/msg00449.html

In a nutshell, casts between 'char **' <-> 'unsigned char **' and
'char **' <-> 'const char **' are invalid.

I grepped for "\*\*) &" and found these.  There's another one in
demangle.c, but I've split fixing that one to a separate patch.

I think the ada_decode_symbol change is perhaps the one that could be
surprising.  The function's description has this comment, which makes
things much clearer:

   The GSYMBOL parameter is "mutable" in the C++ sense: logically
   const, but nevertheless modified to a semantically equivalent form
   when a decoded name is cached in it.  */

 const char *
 ada_decode_symbol (const struct general_symbol_info *gsymbol)

With that out of the way, I think the patch ends up being pretty
obvious.

Tested on x86_64 Fedora 17.

gdb/
2013-03-13  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (ada_decode_symbol): Cast away constness of GSYMBOL
	rather than casting 'const char * const *' to 'const char **'.
	* ada-lex.l (processInt): Make "trailer" local const.  Remove
	'const char **' cast.
	* arm-linux-tdep.c (arm_stap_parse_special_token): Add 'char *'
	locals, and use those as strtol output pointer, instead than doing
	invalid casts to from 'const char **' to 'char **'.
	(_initialize_demangle): Remove cast.
	* i386-tdep.c (i386_stap_parse_special_token): : Add 'char *'
	locals, and use those as strtol output pointer, instead than doing
	invalid casts to from 'const char **' to 'char **'.
	* solib-dsbt.c (dsbt_get_initial_loadmaps): Remove 'gdb_byte**'
	casts.
	* stap-probe.c (stap_parse_register_operand)
	(stap_parse_single_operand): Likewise.
@
text
@d1690 1
a1690 1
 	  struct minimal_symbol *s;
d1696 3
a1698 3
 	  if (s != NULL
 	      && SYMBOL_LINKAGE_NAME (s) != NULL
 	      && strcmp (SYMBOL_LINKAGE_NAME (s), "__main") == 0)
d3355 1
a3355 1
	indirect ? lookup_minimal_symbol_by_pc (indirect) : 0;
@


1.370
log
@Rename record_ prefixes in record-full.h into record_full_.

gdb/
	* record-full.h, record-full.c (record_memory_query): Rename
	to ...
	(record_full_memory_query): ...this. Update all users.
	(record_arch_list_add_reg): Rename to ...
	(record_full_arch_list_add_reg): ...this. Update all users.
	(record_arch_list_add_mem): Rename to ...
	(record_full_arch_list_add_mem): ...this. Update all users.
	(record_arch_list_add_end): Rename to ...
	(record_full_arch_list_add_end): ...this. Update all users.
	(record_gdb_operation_disable_set): Rename to ...
	(record_full_gdb_operation_disable_set): ...this.
	Update all users.
@
text
@d3497 1
d3508 2
a3509 1
		  displacements[0] = strtol (s, (char **) &s, 10);
d3526 2
a3527 1
		  displacements[1] = strtol (s, (char **) &s, 10);
d3544 2
a3545 1
		  displacements[2] = strtol (s, (char **) &s, 10);
d3635 6
a3640 1
		    offset = strtol (s, (char **) &s, 10);
d3687 2
d3698 2
a3699 1
		      size = strtol (s, (char **) &s, 10);
@


1.369
log
@Split record.h into record.h and record-full.h.
Split record.c into record.c and record-full.c.

The split leaves the command part in record.c and moves the target part into
record-full.c.

gdb/
	* record.h: Split into this and ...
	* record-full.h: ... this.
	* record.c: Split into this and ...
	* record-full.c: ... this.
	* target.h (target_ops): Add new fields to_info_record,
	to_save_record, to_delete_record, to_record_is_replaying,
	to_goto_record_begin, to_goto_record_end, to_goto_record.
	(target_info_record): New.
	(target_save_record): New.
	(target_supports_delete_record): New.
	(target_delete_record): New.
	(target_record_is_replaying): New.
	(target_goto_record_begin): New.
	(target_goto_record_end): New.
	(target_goto_record): New.
	* target.c (target_info_record): New.
	(target_save_record): New.
	(target_supports_delete_record): New.
	(target_delete_record): New.
	(target_record_is_replaying): New.
	(target_goto_record_begin): New.
	(target_goto_record_end): New.
	(target_goto_record): New.
	* record.h: Declare struct cmd_list_element.
	(record_cmdlist): New declaration.
	(set_record_cmdlist): New declaration.
	(show_record_cmdlist): New declaration.
	(info_record_cmdlist): New declaration.
	(cmd_record_goto): New declaration.
	* record.c: Remove unnecessary includes.
	Include inferior.h.
	(cmd_record_goto): Remove declaration.
	(record_cmdlist): Now extern. Initialize.
	(set_record_cmdlist): Now extern. Initialize.
	(show_record_cmdlist): Now extern. Initialize.
	(info_record_cmdlist): Now extern. Initialize.
	(find_record_target): New.
	(require_record_target): New.
	(cmd_record_start): Update.
	(cmd_record_delete): Remove target-specific code.
	Call target_delete_record.
	(cmd_record_stop): Unpush any record target.
	(set_record_insn_max_num): Move to record-full.c
	(set_record_command): Add comment.
	(show_record_command): Add comment.
	(info_record_command): Update comment.
	Remove target-specific code.
	Call the record target's to_info_record.
	(cmd_record_start): New.
	(cmd_record_goto): Now extern.
	Remove target-specific code.
	Call target_goto_begin,  target_goto_end, or target_goto.
	(_initialize_record): Move record target ops initialization to
	record-full.c.
	Change "record" command help text.
	Move "record restore", "record set", and "record show" commands to
	record-full.c.
	* Makefile.in (SFILES): Add record-full.c.
	(HFILES_NO_SRCDIR): Add record-full.h.
	(COMMON_OBS): Add record-full.o.
	* amd64-linux-tdep.c: Include record-full.h instead of record.h.
	* arm-tdep.c: Include record-full.h.
	* i386-linux-tdep.c: Include record-full.h instead of record.h.
	* i386-tdep.c: Include record-full.h.
	* infrun.c: Include record-full.h.
	* linux-record.c: Include record-full.h.
	* moxie-tdep.c: Include record-full.h.
	* record-full.c: Include record-full.h.
	Change module comment.
	(set_record_full_cmdlist): New.
	(show_record_full_cmdlist): New.
	(record_full_cmdlist): New.
	(record_goto_insn): New declaration.
	(record_save): New declaration.
	(record_check_insn_num): Change query string.
	(record_info): New.
	(record_delete): New.
	(record_is_replaying): New.
	(record_goto_entry): New.
	(record_goto_begin): New.
	(record_goto_end): New.
	(record_goto): New.
	(init_record_ops): Update.
	(init_record_core_ops): Update.
	(cmd_record_save): Rename to record_save. Remove target and arg checks.
	(cmd_record_start): New.
	(set_record_insn_max_num): Moved from record.c
	(set_record_full_command): New.
	(show_record_full_command): New.
	(_initialize_record_full): New.
@
text
@d4208 1
a4208 1
      if (record_memory_query)
d4229 1
a4229 1
  if (record_arch_list_add_mem (addr, 1 << irp->ot))
d4243 2
a4244 2
  if (record_arch_list_add_reg (irp->regcache,
				irp->regmap[X86_RECORD_RESP_REGNUM]))
d4249 1
a4249 1
  if (record_arch_list_add_mem ((CORE_ADDR) addr - size, size))
d4281 1
a4281 1
          if (record_arch_list_add_reg (ir->regcache, i))
d4289 1
a4289 1
	      if (record_arch_list_add_reg (ir->regcache, i))
d4297 1
a4297 1
        if (record_arch_list_add_reg (ir->regcache, i))
d4304 1
a4304 1
      if (record_arch_list_add_reg (ir->regcache,iregnum))
d4316 1
a4316 1
      if (record_arch_list_add_reg (ir->regcache, i))
d4327 2
a4328 2
#define I386_RECORD_ARCH_LIST_ADD_REG(regnum) \
    record_arch_list_add_reg (ir.regcache, ir.regmap[(regnum)])
d4533 1
a4533 1
		  I386_RECORD_ARCH_LIST_ADD_REG (ir.rm);
d4542 1
a4542 1
	      I386_RECORD_ARCH_LIST_ADD_REG (ir.reg);
d4545 1
a4545 1
	      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
d4549 1
a4549 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4576 1
a4576 1
	    I386_RECORD_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
d4578 1
a4578 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4599 2
a4600 2
      I386_RECORD_ARCH_LIST_ADD_REG (opcode & 7);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4618 1
a4618 1
	  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4632 1
a4632 1
	      I386_RECORD_ARCH_LIST_ADD_REG (ir.rm);
d4635 1
a4635 1
	    I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4641 1
a4641 1
	  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
d4643 2
a4644 2
	    I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REDX_REGNUM);
	  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4682 1
a4682 1
	      I386_RECORD_ARCH_LIST_ADD_REG (ir.rm);
d4684 1
a4684 1
	  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4691 1
a4691 1
	  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4694 1
a4694 1
	  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_CS_REGNUM);
d4697 1
a4697 1
	  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4701 1
a4701 1
	  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4721 1
a4721 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4725 1
a4725 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
d4729 2
a4730 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REDX_REGNUM);
d4746 2
a4747 2
      I386_RECORD_ARCH_LIST_ADD_REG (ir.reg);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4763 1
a4763 1
	  I386_RECORD_ARCH_LIST_ADD_REG (ir.reg);
d4766 1
a4766 1
	  I386_RECORD_ARCH_LIST_ADD_REG (ir.rm);
d4774 1
a4774 1
	  I386_RECORD_ARCH_LIST_ADD_REG (ir.reg);
d4776 1
a4776 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4790 1
a4790 1
	  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
d4793 1
a4793 1
	  I386_RECORD_ARCH_LIST_ADD_REG (ir.reg);
d4797 1
a4797 1
	  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
d4801 1
a4801 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4813 2
a4814 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REDX_REGNUM);
d4817 1
a4817 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4878 2
a4879 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG ((opcode & 0x7) | ir.rex_b);
d4891 1
a4891 1
	I386_RECORD_ARCH_LIST_ADD_REG (regnum);
d4902 1
a4902 1
	I386_RECORD_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
d4909 1
a4909 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
d4913 1
a4913 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REBP_REGNUM);
d4921 2
a4922 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REBP_REGNUM);
d4931 3
a4933 3
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_ES_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4942 3
a4944 3
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_SS_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4953 3
a4955 3
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_DS_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4959 3
a4961 3
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_FS_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4965 3
a4967 3
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_GS_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d4995 1
a4995 1
	  I386_RECORD_ARCH_LIST_ADD_REG (ir.rm);
d5010 1
a5010 1
      I386_RECORD_ARCH_LIST_ADD_REG (ir.reg);
d5024 1
a5024 1
	I386_RECORD_ARCH_LIST_ADD_REG (ir.rm);
d5059 2
a5060 2
      I386_RECORD_ARCH_LIST_ADD_REG (regnum);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d5069 1
a5069 1
      I386_RECORD_ARCH_LIST_ADD_REG (ir.reg | rex_r);
d5085 1
a5085 1
      I386_RECORD_ARCH_LIST_ADD_REG (ir.reg);
d5092 1
a5092 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
d5099 1
a5099 1
          if (record_memory_query)
d5141 1
a5141 1
	  if (record_arch_list_add_mem (addr, 1 << ir.ot))
d5154 3
a5156 3
      I386_RECORD_ARCH_LIST_ADD_REG ((ir.regmap[X86_RECORD_R8_REGNUM])
                                        ? ((opcode & 0x7) | ir.rex_b)
					: ((opcode & 0x7) & 0x3));
d5167 1
a5167 1
      I386_RECORD_ARCH_LIST_ADD_REG ((opcode & 0x7) | ir.rex_b);
d5177 2
a5178 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (opcode & 0x7);
d5194 1
a5194 1
	  I386_RECORD_ARCH_LIST_ADD_REG (ir.rm);
d5204 1
a5204 1
      I386_RECORD_ARCH_LIST_ADD_REG (ir.reg);
d5247 3
a5249 3
      I386_RECORD_ARCH_LIST_ADD_REG (regnum);
      I386_RECORD_ARCH_LIST_ADD_REG (ir.reg | rex_r);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d5274 1
a5274 1
	  I386_RECORD_ARCH_LIST_ADD_REG (ir.rm);
d5276 1
a5276 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d5287 1
a5287 1
	  if (record_arch_list_add_reg (ir.regcache, ir.rm))
d5390 1
a5390 1
		      if (record_arch_list_add_mem (addr64, 4))
d5394 1
a5394 1
		      if (record_arch_list_add_mem (addr64, 8))
d5400 1
a5400 1
		      if (record_arch_list_add_mem (addr64, 2))
d5409 1
a5409 1
		      if (record_arch_list_add_mem (addr64, 4))
d5420 1
a5420 1
		      if (record_arch_list_add_mem (addr64, 4))
d5433 1
a5433 1
		      if (record_arch_list_add_mem (addr64, 8))
d5453 1
a5453 1
		      if (record_arch_list_add_mem (addr64, 2))
d5480 1
a5480 1
		  if (record_arch_list_add_mem (addr64, 28))
d5485 1
a5485 1
		  if (record_arch_list_add_mem (addr64, 14))
d5491 1
a5491 1
	      if (record_arch_list_add_mem (addr64, 2))
d5499 1
a5499 1
	      if (record_arch_list_add_mem (addr64, 10))
d5505 1
a5505 1
		  if (record_arch_list_add_mem (addr64, 28))
d5511 1
a5511 1
		  if (record_arch_list_add_mem (addr64, 14))
d5515 1
a5515 1
	      if (record_arch_list_add_mem (addr64, 80))
d5523 1
a5523 1
	      if (record_arch_list_add_mem (addr64, 8))
d5729 2
a5730 1
		  if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
d5773 1
a5773 1
              if (record_memory_query)
d5790 1
a5790 1
              if (record_arch_list_add_mem (addr, 1 << ir.ot))
d5795 1
a5795 1
            I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
d5797 3
a5799 3
            I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);
          I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REDI_REGNUM);
          I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d5805 2
a5806 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REDI_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);
d5808 2
a5809 2
        I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d5814 2
a5815 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);
d5817 2
a5818 2
        I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d5823 1
a5823 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REDI_REGNUM);
d5825 2
a5826 2
        I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d5831 1
a5831 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);
d5833 2
a5834 2
        I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d5841 2
a5842 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
d5854 2
a5855 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d5861 3
a5863 3
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_CS_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d5879 1
a5879 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_CS_REGNUM);
d5937 1
a5937 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d5942 2
a5943 2
        I386_RECORD_ARCH_LIST_ADD_REG (ir.rex_b ? (ir.rm | ir.rex_b)
	                                        : (ir.rm & 0x3));
d5972 1
a5972 1
      I386_RECORD_ARCH_LIST_ADD_REG (ir.reg);
d5977 1
a5977 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d5985 2
a5986 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6001 1
a6001 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6010 2
a6011 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
d6028 1
a6028 1
            I386_RECORD_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
d6035 1
a6035 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6039 1
a6039 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6049 1
a6049 1
        I386_RECORD_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
d6070 1
a6070 1
          if (record_arch_list_add_mem (addr64, 1 << ir.ot))
d6075 1
a6075 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6080 2
a6081 2
      I386_RECORD_ARCH_LIST_ADD_REG (ir.reg | rex_r);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6096 2
a6097 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6175 1
a6175 1
      I386_RECORD_ARCH_LIST_ADD_REG ((opcode & 7) | ir.rex_b);
d6184 2
a6185 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6192 2
a6193 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6211 2
a6212 2
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REDX_REGNUM);
d6267 4
a6270 4
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REDX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REBX_REGNUM);
d6288 1
a6288 1
            I386_RECORD_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
d6301 1
a6301 1
          I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6328 1
a6328 1
                if (record_memory_query)
d6347 1
a6347 1
		if (record_arch_list_add_mem (addr64, 2))
d6352 1
a6352 1
                    if (record_arch_list_add_mem (addr64, 8))
d6357 1
a6357 1
                    if (record_arch_list_add_mem (addr64, 4))
d6371 1
a6371 1
		  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6385 1
a6385 1
                  if (record_memory_query)
d6406 1
a6406 1
		  if (record_arch_list_add_mem (addr64, 2))
d6411 1
a6411 1
                      if (record_arch_list_add_mem (addr64, 8))
d6416 1
a6416 1
                      if (record_arch_list_add_mem (addr64, 4))
d6428 2
a6429 2
		  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
		  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REDX_REGNUM);
d6447 1
a6447 1
	      if (record_arch_list_add_reg (ir.regcache, ir.rm | ir.rex_b))
d6456 1
a6456 1
	  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6459 1
a6459 1
	  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6465 1
a6465 1
	        I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_GS_REGNUM);
d6474 1
a6474 1
	    I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6493 2
a6494 2
          I386_RECORD_ARCH_LIST_ADD_REG (ir.regmap[X86_RECORD_R8_REGNUM]
	                                   ? (ir.reg | rex_r) : ir.rm);
d6503 1
a6503 1
        I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6510 2
a6511 2
      I386_RECORD_ARCH_LIST_ADD_REG (ir.reg | rex_r);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6553 1
a6553 1
	    I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6555 1
a6555 1
            I386_RECORD_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
d6577 1
a6577 1
        I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6579 1
a6579 1
	I386_RECORD_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
d6583 1
a6583 1
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6595 1
a6595 1
      record_arch_list_add_reg (ir.regcache, I387_FTAG_REGNUM(tdep));
d6632 1
a6632 1
          record_arch_list_add_reg (ir.regcache, ir.reg);
d6644 9
a6652 9
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REDX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REBX_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESP_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REBP_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REDI_REGNUM);
d6664 1
a6664 1
            I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6667 1
a6667 1
            if (record_arch_list_add_mem (tmpu64, 512))
d6676 1
a6676 1
            I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d6680 1
a6680 1
              record_arch_list_add_reg (ir.regcache, i);
d6684 1
a6684 1
              record_arch_list_add_reg (ir.regcache, i);
d6687 2
a6688 1
              record_arch_list_add_reg (ir.regcache, I387_MXCSR_REGNUM(tdep));
d6692 1
a6692 1
              record_arch_list_add_reg (ir.regcache, i);
d6696 1
a6696 1
              record_arch_list_add_reg (ir.regcache, i);
d6703 1
a6703 1
          record_arch_list_add_reg (ir.regcache, I387_MXCSR_REGNUM(tdep));
d7081 2
a7082 2
          record_arch_list_add_reg (ir.regcache,
                                    I387_XMM0_REGNUM (tdep) + ir.reg);
d7084 1
a7084 1
            I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d7114 2
a7115 2
              record_arch_list_add_reg (ir.regcache,
                                        I387_XMM0_REGNUM (tdep) + ir.rm);
d7168 1
a7168 1
          I386_RECORD_ARCH_LIST_ADD_REG (ir.reg | rex_r);
d7269 2
a7270 2
          record_arch_list_add_reg (ir.regcache,
                                    I387_MM0_REGNUM (tdep) + ir.reg);
d7280 2
a7281 2
          record_arch_list_add_reg (ir.regcache,
                                    I387_MM0_REGNUM (tdep) + ir.rm);
d7292 2
a7293 2
          record_arch_list_add_reg (ir.regcache,
                                    I387_XMM0_REGNUM (tdep) + ir.rm);
d7301 1
a7301 1
            I386_RECORD_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);
d7320 2
a7321 2
              record_arch_list_add_reg (ir.regcache,
                                        I387_MM0_REGNUM (tdep) + ir.rm);
d7334 2
a7335 2
          I386_RECORD_ARCH_LIST_ADD_REG (ir.reg);
          I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d7347 2
a7348 2
              record_arch_list_add_reg (ir.regcache,
                                        I387_XMM0_REGNUM (tdep) + ir.rm);
d7363 1
a7363 1
          I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
d7370 1
a7370 1
          if (record_arch_list_add_mem (addr, 64))
d7378 1
a7378 1
          if (record_arch_list_add_mem (addr, 128))
d7394 2
a7395 2
  I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REIP_REGNUM);
  if (record_arch_list_add_end ())
@


1.368
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* charset.c (intermediate_encoding): Remove unused i.
	* completer.c (signal_completer): Remove unused i.
	* continuations.c (discard_my_continuations_1): Remove unused
	continuation_ptr.
	* corelow.c (core_close): Remove unuseD name.
	(get_core_siginfo): Remove unused pid.
	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Remove unused
	i, cps.
	* dwarf2loc.c (dwarf2_compile_expr_to_ax): Remove unused base_offset.
	(loclist_describe_location): Remove unused first.
	* event-top.c (command_line_handler): Remove unused got_eof.
	* exec.c (exec_close_1): Remove unused need_symtab_cleanup.
	(resize_section_table): Remove unused old_value.
	* gdb_bfd.c (gdb_bfd_map_section): Remove unused header.
	* gnu-v3-abi.c (compute_vtable_size): Remove unused addr.
	* i386-tdep.c (i386_process_record): Remove unused rex.
	* infcmd.c (get_return_value): Remove unused uiout.
	* jv-lang.c (type_from_class): Remove unused is_array.
	* jv-valprint.c (java_val_print): Remove unused i.
	* linux-nat.c (linux_nat_stop_lwp): Remove unused ptid.
	* linux-thread-db.c (thread_db_find_new_threads_2): Remove unuseD pid.
	* m2-typeprint.c (m2_print_type): Remove unused code.
	* macroexp.c (get_character_constant): Remove unused body_start.
	(macro_stringify): Remove unused result.
	* objc-lang.c (find_methods): Remove unused gdbarch.
	* objfiles.c (filter_overlapping_sections): Remove unused abfd1, abfd2.
	* regcache.c (regcache_cooked_read): Remove unused gdbarch.
	* stack.c (print_frame_args): Remove unused summary.
	* thread.c (thread_apply_command): Remove unused p.
	* valarith.c (value_x_unop): Remove unused mangle_ptr.
	* valops.c (search_struct_method): Remove unused skip.
	* valprint.c (generic_val_print): Remove unused byte_order.
	* varobj.c (varobj_update): Remove unused changed.
	* cli/cli-cmds.c (complete_command): Remove unused next_item.
	(alias_command): Remove unused c.
	* mi/mi-cmd-catch.c (mi_catch_load_unload): Remove unused c.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Remove unused
	format.
	(mi_cmd_data_write_memory): Remove unused word_format.
	(mi_cmd_data_write_memory_bytes): Remove unused r.
	* python/py-gdb-readline.c (gdbpy_readline_wrapper): Remove unused
	p_start, p_end.
	* python/python.c (_initialize_python): Remove unused cmd_name, cmd.
	* tui/tui-disasm.c (tui_set_disassem_content): Remove unused
	line_width.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00766.html
@
text
@d55 1
@


1.367
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a4341 1
  int rex = 0;
a4420 1
               rex = 1;
@


1.366
log
@gdb/
2012-12-11  Pedro Alves  <palves@@redhat.com>

	* configure.ac (detect type of /proc): Remove Unixware handling.
	* configure: Regenerate.
	* proc-api.c (ioctl_table) [PIOCLSTATUS]: Don't mention Unixware.
	(ioctl_table) [PCRESET]: Remove entry.
	* proc-events.c (SYS_lwp_create, SYS_lwp_exit, SYS_lwp_wait)
	(SYS_lwp_self, SYS_lwp_info, SYS_lwp_private, SYS_lwp_kill)
	(SYS_lwp_suspend, SYS_lwp_continue): Don't define.
	* proc-why.c (pr_why_table) [PR_SUSPENDED]: Don't mention Unixware.
	* procfs.c: Remove all UNIXWARE guarded code, and all traces of
	Unixware in comments throughout.
	* i386-tdep.c (i386_svr4_sigtramp_p): Don't match _sigacthandler,
	and remove mention of Unixware.

gdb/doc/
2012-12-11  Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo: Remove all mentions of Unixware throughout.
@
text
@d3 1
a3 1
   Copyright (C) 1988-2012 Free Software Foundation, Inc.
@


1.365
log
@Fix for incorrect breakpoint set in case of clang compiled binary
@
text
@d3416 1
a3416 2
  /* UnixWare uses _sigacthandler.  The origin of the other symbols is
     currently unknown.  */
a3418 1
		   || strcmp ("_sigacthandler", name) == 0
@


1.364
log
@Revert previous change to i386-tdep.c.
@
text
@d1585 1
d1587 15
@


1.363
log
@Fix for incorrect breakpoint set in case of clang compiled binary
@
text
@d1585 1
a1586 23
  CORE_ADDR func_addr;
  struct symtab *s = find_pc_symtab (func_addr);

  if (find_pc_partial_function (start_pc, NULL, &func_addr, NULL))
  {
    CORE_ADDR post_prologue_pc
      = skip_prologue_using_sal (gdbarch, func_addr);
    
    /* GCC always emits a line note before the prologue and another
	 one after, even if the two are at the same address or on the
	 same line.  Take advantage of this so that we do not need to
	 know every instruction that might appear in the prologue.  We
	 will have producer information for most binaries; if it is
	 missing (e.g. for -gstabs), assuming the GNU tools.  */
    if (post_prologue_pc
	  && (s == NULL
	      || s->producer == NULL
	      || strncmp (s->producer, "GNU ", sizeof ("GNU ") - 1) == 0
	      || strncmp (s->producer, "clang ", sizeof ("clang ") - 1) == 0))
	  return  max (start_pc, post_prologue_pc);
  }


@


1.362
log
@rename frame_register_read into deprecated_frame_register_read.

gdb/ChangeLog:

        * frame.h (deprecated_frame_register_read): Renames
        frame_register_read.
        * frame.c (deprecated_frame_register_read): Renames
        frame_register_read.  Update all callers.
        * i386-tdep.c: Update all callers of frame_register_read.
        * infcmd.c: Likewise.
        * jit.c: Likewise.
        * mips-tdep.c: Likewise.
        * mt-tdep.c: Likewise.
        * sh64-tdep.c: Likewise.
@
text
@d1585 23
a1608 1
  cache.locals = -1;
@


1.361
log
@gdb:
	* i386-tdep.c (i386_analyze_frame_setup): Handle opcode
	0x8d (lea).
@
text
@d1786 2
a1787 1
	  && frame_register_read (this_frame, cache->saved_sp_reg, buf))
@


1.360
log
@2012-10-26  Pedro Alves  <palves@@redhat.com>

	* amd64-tdep.c (amd64_relocate_instruction): Use
	store_unsigned_integer instead of memcpy.
	* i386-tdep.c (i386_relocate_instruction): Ditto.
@
text
@d1391 14
a1404 1
      /* Check for `movl %esp, %ebp' -- can be written in two ways.  */
d1407 1
d1412 1
d1418 7
a1434 1
      pc += (skip + 2);
d1443 2
d1473 9
d1484 1
a1484 1
	  /* Some instruction other than `subl'.  */
@


1.359
log
@PR gdb/12783
* i386-tdep.c (i386_return_value): Handle complex double and long
double.
@
text
@d753 1
a753 1
      memcpy (&push_buf[1], &ret_addr, 4);
@


1.358
log
@Remove sp_regnum_from_eax and pc_regnum_from_eax

	PR backtrace/14646
	PR gdb/14647
	* i386-tdep.h (gdbarch_tdep): Remove sp_regnum_from_eax and
	pc_regnum_from_eax.
	* i386-tdep.c (i386_gdbarch_init): Don't use sp_regnum_from_eax
	nor pc_regnum_from_eax.
	* amd64-tdep.c (amd64_x32_init_abi): Don't set sp_regnum_from_eax
	nor pc_regnum_from_eax.
@
text
@d2633 3
@


1.357
log
@2012-07-20  Pedro Alves  <palves@@redhat.com>

	* i386-tdep.c (i386_record_modrm, i386_record_lea_modrm_addr)
	(i386_record_lea_modrm, i386_record_push, i386_record_floats)
	(i386_process_record): Tweak description comments.
@
text
@a7707 3
  tdep->sp_regnum_from_eax = -1;
  tdep->pc_regnum_from_eax = -1;

a7751 8
      if (tdep->sp_regnum_from_eax != -1)
	set_gdbarch_sp_regnum (gdbarch,
			       (tdep->eax_regnum
				+ tdep->sp_regnum_from_eax));
      if (tdep->pc_regnum_from_eax != -1)
	set_gdbarch_pc_regnum (gdbarch,
			       (tdep->eax_regnum
				+ tdep->pc_regnum_from_eax));
@


1.356
log
@2012-07-20  Pedro Alves  <palves@@redhat.com>

	* i386-tdep.c (i386_record_modrm, i386_record_lea_modrm_addr)
	(i386_process_record): Use record_read_memory.
	* record.c (record_read_memory): New function.
	(record_arch_list_add_mem, record_exec_insn): Use
	record_read_memory.
	* record.h (record_read_memory): Declare.
@
text
@d3936 2
a3937 2
/* Parse "modrm" part in current memory address that irp->addr point to
   Return -1 if something wrong.  */
d3955 2
a3956 3
/* Get the memory address that current instruction  write to and set it to
   the argument "addr".
   Return -1 if something wrong.  */
d4145 3
a4147 3
/* Record the value of the memory that willbe changed in current instruction
   to "record_arch_list".
   Return -1 if something wrong.  */
d4184 2
a4185 2
/* Record the push operation to "record_arch_list".
   Return -1 if something wrong.  */
d4210 3
a4212 3
/* Record the value of floating point registers which will be changed
   by the current instruction to "record_arch_list".  Return -1 if
   something is wrong.  */
d4272 3
a4274 3
/* Parse the current instruction and record the values of the registers and
   memory that will be changed in current instruction to "record_arch_list".
   Return -1 if something wrong.  */
@


1.355
log
@Add sp_regnum_from_eax/pc_regnum_from_eax to i386 gdbarch_tdep

	* amd64-tdep.c (amd64_x32_init_abi): Set sp_regnum_from_eax to
	AMD64_RSP_REGNUM and pc_regnum_from_eax to AMD64_RIP_REGNUM.

	* i386-tdep.c (i386_gdbarch_init): Initialize sp_regnum_from_eax
	and pc_regnum_from_eax to -1.  Update SP regnum from
	sp_regnum_from_eax and PC regnum from pc_regnum_from_eax if
	needed.

	* i386-tdep.h (gdbarch_tdep): Add sp_regnum_from_eax and
	pc_regnum_from_eax.
@
text
@d3944 3
a3946 8
  if (target_read_memory (irp->addr, &irp->modrm, 1))
    {
      if (record_debug)
	printf_unfiltered (_("Process record: error reading memory at "
			     "addr %s len = 1.\n"),
			   paddress (gdbarch, irp->addr));
      return -1;
    }
d3980 2
a3981 8
	  if (target_read_memory (irp->addr, &byte, 1))
	    {
	      if (record_debug)
		printf_unfiltered (_("Process record: error reading memory "
				     "at addr %s len = 1.\n"),
				   paddress (gdbarch, irp->addr));
	      return -1;
	    }
d3995 2
a3996 8
	      if (target_read_memory (irp->addr, buf, 4))
		{
		  if (record_debug)
		    printf_unfiltered (_("Process record: error reading "
				         "memory at addr %s len = 4.\n"),
				       paddress (gdbarch, irp->addr));
		  return -1;
		}
d4004 2
a4005 8
	  if (target_read_memory (irp->addr, buf, 1))
	    {
	      if (record_debug)
		printf_unfiltered (_("Process record: error reading memory "
				     "at addr %s len = 1.\n"),
				   paddress (gdbarch, irp->addr));
	      return -1;
	    }
d4010 2
a4011 8
	  if (target_read_memory (irp->addr, buf, 4))
	    {
	      if (record_debug)
		printf_unfiltered (_("Process record: error reading memory "
				     "at addr %s len = 4.\n"),
				   paddress (gdbarch, irp->addr));
	      return -1;
	    }
d4050 2
a4051 8
	      if (target_read_memory (irp->addr, buf, 2))
		{
		  if (record_debug)
		    printf_unfiltered (_("Process record: error reading "
					 "memory at addr %s len = 2.\n"),
				       paddress (gdbarch, irp->addr));
		  return -1;
		}
d4059 2
a4060 8
	  if (target_read_memory (irp->addr, buf, 1))
	    {
	      if (record_debug)
		printf_unfiltered (_("Process record: error reading memory "
				     "at addr %s len = 1.\n"),
				   paddress (gdbarch, irp->addr));
	      return -1;
	    }
d4065 2
a4066 8
	  if (target_read_memory (irp->addr, buf, 2))
	    {
	      if (record_debug)
		printf_unfiltered (_("Process record: error reading memory "
				     "at addr %s len = 2.\n"),
				   paddress (gdbarch, irp->addr));
	      return -1;
	    }
d4316 2
a4317 8
      if (target_read_memory (ir.addr, &opcode8, 1))
	{
	  if (record_debug)
	    printf_unfiltered (_("Process record: error reading memory at "
				 "addr %s len = 1.\n"),
			       paddress (gdbarch, ir.addr));
	  return -1;
	}
d4408 2
a4409 8
      if (target_read_memory (ir.addr, &opcode8, 1))
	{
	  if (record_debug)
	    printf_unfiltered (_("Process record: error reading memory at "
				 "addr %s len = 1.\n"),
			       paddress (gdbarch, ir.addr));
	  return -1;
	}
d5074 2
a5075 8
              if (target_read_memory (ir.addr, buf, 8))
		{
	          if (record_debug)
		    printf_unfiltered (_("Process record: error reading "
	                    		 "memory at addr 0x%s len = 8.\n"),
				       paddress (gdbarch, ir.addr));
		  return -1;
		}
d5081 2
a5082 8
              if (target_read_memory (ir.addr, buf, 4))
		{
	          if (record_debug)
		    printf_unfiltered (_("Process record: error reading "
	                    		 "memory at addr 0x%s len = 4.\n"),
				       paddress (gdbarch, ir.addr));
		  return -1;
		}
d5088 2
a5089 8
              if (target_read_memory (ir.addr, buf, 2))
		{
	          if (record_debug)
		    printf_unfiltered (_("Process record: error reading "
	                    		 "memory at addr 0x%s len = 2.\n"),
				       paddress (gdbarch, ir.addr));
		  return -1;
		}
d6061 2
a6062 8
      if (target_read_memory (ir.addr, &opcode8, 1))
        {
          if (record_debug)
            printf_unfiltered (_("Process record: error reading memory at "
				 "addr 0x%s len = 1.\n"),
			       paddress (gdbarch, ir.addr));
          return -1;
        }
d6081 2
a6082 8
	if (target_read_memory (ir.addr, &interrupt, 1))
	  {
	    if (record_debug)
	      printf_unfiltered (_("Process record: error reading memory "
				   "at addr %s len = 1.\n"),
				 paddress (gdbarch, ir.addr));
	    return -1;
	  }
d6552 2
a6553 7
      if (target_read_memory (ir.addr, &opcode8, 1))
        {
	  printf_unfiltered (_("Process record: error reading memory at "
	                       "addr %s len = 1.\n"),
	                     paddress (gdbarch, ir.addr));
          return -1;
        }
d6820 2
a6821 7
          if (target_read_memory (ir.addr, &opcode8, 1))
            {
	      printf_unfiltered (_("Process record: error reading memory at "
	                           "addr %s len = 1.\n"),
	                         paddress (gdbarch, ir.addr));
              return -1;
            }
@


1.355.2.1
log
@Remove sp_regnum_from_eax and pc_regnum_from_eax

	PR backtrace/14646
	PR gdb/14647
	* i386-tdep.h (gdbarch_tdep): Remove sp_regnum_from_eax and
	pc_regnum_from_eax.
	* i386-tdep.c (i386_gdbarch_init): Don't use sp_regnum_from_eax
	nor pc_regnum_from_eax.
	* amd64-tdep.c (amd64_x32_init_abi): Don't set sp_regnum_from_eax
	nor pc_regnum_from_eax.
@
text
@d7808 3
d7855 8
@


1.354
log
@gdb/
	Switch i386 and derived targets to ON_STACK.
	* amd64-dicos-tdep.c (amd64_dicos_push_dummy_code): Remove.
	(amd64_dicos_init_abi): Remove its installment.
	* dicos-tdep.c (dicos_init_abi): Remove the
	set_gdbarch_call_dummy_location call.  Update the comment here.
	* i386-dicos-tdep.c (i386_dicos_push_dummy_code): Remove.
	(i386_dicos_init_abi): Remove its installment.
	* i386-tdep.c (i386_push_dummy_code): New function.
	(i386_gdbarch_init): Call set_gdbarch_call_dummy_location, install
	i386_push_dummy_code.
@
text
@d7808 3
d7855 8
@


1.353
log
@        PR tdep/14222
        * i386-tdep.c (i386_push_dummy_call): Unconditionally align the
        stack on a 16-byte boundary.
@
text
@d2335 16
d7724 2
@


1.352
log
@    H.J. Lu  <hongjiu.lu@@intel.com>

* i386-tdep.h (i386_pseudo_register_name): New prototype.
* i386-tdep.c (i386_pseudo_register_name): Make public.
* amd64-tdep.h (amd64_x32_init_abi): New prototype.
* amd64-tdep.c (amd64_dword_names): Add "eip".
(amd64_x32_pseudo_register_type): New function
(amd64_x32_init_abi): New function.
@
text
@a2353 1
      int have_16_byte_aligned_arg = 0;
d2391 1
a2391 4
		{
		  args_space = align_up (args_space, 16);
		  have_16_byte_aligned_arg = 1;
		}
a2397 2
	  if (have_16_byte_aligned_arg)
	    args_space = align_up (args_space, 16);
d2399 6
@


1.351
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d2783 1
a2783 1
static struct type *
@


1.350
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@a1199 1
  gdb_byte op;
@


1.349
log
@gdb:
	* i386-tdep.c (i386_fetch_pointer_argument): Remove extra
	space.
	(i386_process_record): Ditto.
@
text
@d2608 1
a2608 1
i386_return_value (struct gdbarch *gdbarch, struct type *func_type,
d2659 1
a2659 1
      return i386_return_value (gdbarch, func_type, type, regcache,
@


1.348
log
@2012-05-02  Sergio Durigan Junior  <sergiodj@@gmail.com>

	* i386-tdep.c (i386_stap_parse_special_token) <s>: Remove unused
	variable.
	* stap-probe.c (stap_parse_single_operand) <reg_suffix,
	reg_ind_suffix, reg_suffix_len, reg_ind_suffix_len>: Likewise.
	(stap_parse_argument) <e>: Likewise.
	(handle_stap_probe) <byte_order>: Likewise.
@
text
@d3857 1
a3857 1
  CORE_ADDR sp = get_frame_register_unsigned  (frame, I386_ESP_REGNUM);
d4320 1
a4320 1
  uint8_t  opcode8;
@


1.347
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@a3394 2
  const char *s = p->arg;

@


1.346
log
@gdb/
	Fix disp-step-syscall.exp: fork: single step over fork.
	* i386-linux-tdep.c (-i386_linux_get_syscall_number): Rename to ...
	(i386_linux_get_syscall_number_from_regcache): ... here, new function
	comment, change parameters gdbarch and ptid to regcache.  Remove
	parameter regcache, initialize gdbarch from regcache here.
	(i386_linux_get_syscall_number, i386_linux_displaced_step_copy_insn):
	New functions.
	(i386_linux_init_abi): Install i386_linux_displaced_step_copy_insn
	instead.
	* i386-tdep.c (i386_syscall_p): Check also for 'sysenter' and
	'syscall'.  Make the 'int' check more strict.

gdb/testsuite/
	Fix disp-step-syscall.exp: fork: single step over fork.
	* gdb.base/disp-step-syscall.exp (syscall_insn): Anchor it by
	whitespaces.
	(single step over $syscall): Remove its check.
	(single step over $syscall final pc): New check.
@
text
@d64 7
d3373 319
d3701 10
@


1.345
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d524 6
a529 1
  if (insn[0] == 0xcd)
@


1.344
log
@	* blockframe.c (find_pc_partial_function_gnu_ifunc): Change type of
	"name" parameter to const char ** from char **.  All callers updated.
	(find_pc_partial_function): Ditto.
	(cache_pc_function_name): Change type to const char * from char *.
	* symtab.h ((find_pc_partial_function_gnu_ifunc): Update.
	(find_pc_partial_function): Update.
	* alpha-tdep.h (struct gdbarch_tdep, member pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	All uses updated.
	* arch-utils.c (generic_in_solib_return_trampoline): Change
	type of "name" parameter to const char * from char *.
	* arch-utils.h (generic_in_solib_return_trampoline): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* gdbarch.sh (in_solib_return_trampoline): Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Update.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Update.
	* m32r-linux-tdep.c (m32r_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* skip.c (skip_function_pc): Ditto.
	* sparc-sol2-tdep.c (sparc_sol2_pc_in_sigtramp): Ditto.
	* sparc-tdep.h (sparc_sol2_pc_in_sigtramp): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_pc_in_sigtramp): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_pc_in_sigtramp): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_pc_in_sigtramp): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_pc_in_sigtramp): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_pc_in_sigtramp): Ditto.
	* nbsd-tdep.c (nbsd_pc_in_sigtramp): Similary for "func_name".
	* nbsd-tdep.h (nbsd_pc_in_sigtramp): Update.
@
text
@d3276 1
a3276 1
      char *symname = indsym ? SYMBOL_LINKAGE_NAME (indsym) : 0;
@


1.343
log
@gdb/
	Code cleanup: Make 1440 bytes of data segment read-only.
	* arch-utils.c (endian_enum): Make it const char *const [].
	* arm-tdep.c (fp_model_strings, arm_abi_strings, arm_mode_strings):
	Likewise.
	* breakpoint.c (always_inserted_enums): Likewise.
	* cli/cli-cmds.c (script_ext_enums): Likewise.
	* cli/cli-decode.c (add_setshow_enum_cmd, complete_on_enum): Make the
	enumlist parameter const char *const *.
	* cli/cli-decode.h (struct cmd_list_element): Make the enums field
	const char *const *.
	* command.h (complete_on_enum, add_setshow_enum_cmd): Make the enumlist
	parameter const char *const *.
	* cris-tdep.c (cris_modes): Make it const char *const [].
	* filesystem.c (target_file_system_kinds): Likewise.
	* i386-tdep.c (valid_flavors, valid_conventions): Likewise.
	* infrun.c (follow_fork_mode_kind_names, follow_exec_mode_names)
	(can_use_displaced_stepping_enum, scheduler_enums)
	(exec_direction_names): Likewise.
	* language.c (_initialize_language): Make the type_or_range_names and
	case_sensitive_names variables const char *const [].
	* mips-tdep.c (mips_abi_strings): Make it const char *const [].
	* python/python.c (python_excp_enums): Likewise.
	* remote.c (interrupt_sequence_modes): Likewise.
	* rs6000-tdep.c (powerpc_vector_strings): Likewise.
	* serial.c (logbase_enums): Likewise.
	* sh-tdep.c (sh_cc_enum): Likewise.
	* stack.c (print_frame_arguments_choices, print_entry_values_choices):
	Likewise.
	* symtab.c (multiple_symbols_modes): Likewise.
	* tui/tui-win.c (tui_border_kind_enums, tui_border_mode_enums):
	Likewise.
	* utils.c (internal_problem_modes): Likewise.
@
text
@d2039 1
a2039 1
  char *name;
d3297 1
a3297 1
  char *name;
d3335 1
a3335 1
  char *name;
@


1.342
log
@2012-01-12  Pedro Alves  <palves@@redhat.com>

	* i386-tdep.c (i386_frame_cache_1): Also mark the frame base as
	available when %ebp is found to be zero (outermost).
@
text
@d379 1
a379 1
static const char *valid_flavors[] =
d2548 1
a2548 1
static const char *valid_conventions[] =
@


1.341
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1683 4
a1686 1
    return;
@


1.340
log
@2011-11-14  Stan Shebs  <stan@@codesourcery.com>
	    Kwok Cheung Yeung  <kcy@@codesourcery.com>

	* NEWS: Document shorter fast tracepoints and qTMinFTPILen packet.
	* i386-tdep.c (i386_fast_tracepoint_valid_at): Query target for
	the minimum instruction size for fast tracepoints.
	* target.h (struct target_ops): Add new method
	to_get_min_fast_tracepoint_insn_len.
	(target_get_min_fast_tracepoint_insn_len): New.
	* target.c (update_current_target): Set up new target operation.
	* remote.c (remote_write_bytes_aux): Fix typo.
	(remote_get_min_fast_tracepoint_insn_len): New.
	(init_remote_ops): Initialize new field.

	* gdb.texinfo (Create and Delete Tracepoints): Describe what is
	needed to get shorter fast tracepoints.
	(Tracepoint Packets): Document new qTMinFTPILen packet.

	* linux-x86-low.c (small_jump_insn): New.
	(i386_install_fast_tracepoint_jump_pad): Add arguments for
	trampoline and error message, build a trampoline and issue a small
	jump instruction to it.
	(x86_install_fast_tracepoint_jump_pad): Add arguments for
	trampoline and error message.
	(x86_get_min_fast_tracepoint_insn_len): New.
	(the_low_target): Add call to x86_get_min_fast_tracepoint_insn_len.
	* linux-low.h (struct linux_target_ops): Add arguments to
	install_fast_tracepoint_jump_pad operation, add new operation.
	* linux-low.c (linux_install_fast_tracepoint_jump_pad): Add
	arguments.
	(linux_get_min_fast_tracepoint_insn_len): New function.
	(linux_target_op): Add new operation.
	* tracepoint.c (gdb_trampoline_buffer): New IPA variable.
	(gdb_trampoline_buffer_end): Ditto.
	(gdb_trampoline_buffer_error): Ditto.
	(struct ipa_sym_addresses): Add fields for new IPA variables.
	(symbol_list): Add entries for new IPA variables.
	(struct tracepoint): Add fields to hold the address range of the
	trampoline used by the tracepoint.
	(trampoline_buffer_head): New static variable.
	(trampoline_buffer_tail): Ditto.
	(claim_trampoline_space): New function.
	(have_fast_tracepoint_trampoline_buffer): New function.
	(clone_fast_tracepoint): Fill in trampoline fields of tracepoint
	structure.
	(install_fast_tracepoint): Ditto, also add error buffer argument.
	(cmd_qtminftpilen): New function.
	(handle_tracepoint_query): Add response to qTMinFTPILen packet.
	(fast_tracepoint_from_trampoline_address): New function.
	(fast_tracepoint_collecting): Handle trampoline as part of jump
	pad space.
	(set_trampoline_buffer_space): New function.
	(initialize_tracepoint): Initialize new IPA variables.
	* target.h (struct target_ops): Add arguments to
	install_fast_tracepoint_jump_pad operation, add new
	get_min_fast_tracepoint_insn_len operation.
	(target_get_min_fast_tracepoint_insn_len): New.
	(install_fast_tracepoint_jump_pad): Add arguments.
	* server.h (IPA_BUFSIZ): Define.
	* linux-i386-ipa.c: Include extra header files.
	(initialize_fast_tracepoint_trampoline_buffer): New function.
	(initialize_low_tracepoint): Call it.
	* server.h (set_trampoline_buffer_space): Declare.
	(claim_trampoline_space): Ditto.
	(have_fast_tracepoint_trampoline_buffer): Ditto.

	* gdb.trace/ftrace.c: New.
	* gdb.trace/ftrace.exp: New.
@
text
@d3 1
a3 3
   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011 Free Software Foundation, Inc.
@


1.340.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1988-2012 Free Software Foundation, Inc.
@


1.340.2.2
log
@	* i386-tdep.c (i386_frame_cache_1): Also mark the frame base as
	available when %ebp is found to be zero (outermost).
@
text
@d1683 1
a1683 4
    {
      cache->base_p = 1;
      return;
    }
@


1.339
log
@Fix jit.exp on most 32-bit targets.

	* gdbarch.sh: New field 'long_long_align_bit'.
	* gdbarch.c, gdbarch.h: Regenerate.
	* i386-tdep.c (i386_gdbarch_init): Set long_long_align_bit to 32.
	* jit.c (jit_read_code_entry): Use it to determine correct size offset.
@
text
@d7112 1
a7112 1
   tracepoint, which on x86 means that we need an instruction of at
d7115 3
a7117 1
   middle of the tracepoint jump.  Returns 1 if OK, and writes a size
d7128 20
a7147 4
  /* This is based on the target agent using a 4-byte relative jump.
     Alternate future possibilities include 8-byte offset for x86-84,
     or 3-byte jumps if the program has trampoline space close by.  */
  jumplen = 5;
d7155 3
d7168 6
a7173 6

  if (isize)
    *isize = len;
  if (msg)
    *msg = NULL;
  return 1;
@


1.338
log
@	Add return address collection for tracepoints.
	* tracepoint.c (encode_actions_1): Add case for $_ret.
	(validate_actionline): Check for $_ret.
	(trace_dump_actions): Ditto.
	* ax-gdb.h (gen_trace_for_return_address): Declare.
	* ax-gdb.c: Include arch-utils.h.
	(gen_trace_for_return_address): New function.
	(agent_command): Add return address special case.
	* amd64-tdep.c: Include ax.h and ax-gdb.h.
	(amd64_gen_return_address): New function.
	(amd64_init_abi): Call it.
	* i386-tdep.c: Include ax.h and ax-gdb.h.
	(i386_gen_return_address): New function.
	(i386_init_abi): Call it.
	* arch-utils.h (default_gen_return_address): Declare.
	* arch-utils.c (default_gen_return_address): New function.
	* gdbarch.sh (gen_return_address): New method.
	* gdbarch.h, gdbarch.c: Regenerate.

	* gdb.texinfo (Tracepoint Action Lists): Document $_ret.

	* gdb.trace/collection.exp: Test collection of $_ret.
@
text
@d7284 2
@


1.337
log
@	PR gdb/13079
	* i386-tdep.c (i386_frame_align): New.
	(i386_gdbarch_init): Use i386_frame_align.
@
text
@d63 3
d2080 16
d7432 2
@


1.336
log
@gdb
	* amd64-tdep.c (amd64_pseudo_register_read_value): Rename
	from amd64_pseudo_register_read.  Change arguments.  Call
	mark_value_bytes_unavailable when needed.
	(amd64_init_abi): Use set_gdbarch_pseudo_register_read_value, not
	set_gdbarch_pseudo_register_read.
	* sentinel-frame.c (sentinel_frame_prev_register): Use
	regcache_cooked_read_value.
	* regcache.h (regcache_cooked_read_value): Declare.
	* regcache.c (regcache_cooked_read_value): New function.
	(regcache_cooked_read): Call
	gdbarch_pseudo_register_read_value if available.
	* i386-tdep.h (i386_pseudo_register_read_value): Declare.
	(i386_pseudo_register_read): Remove.
	* i386-tdep.c (i386_pseudo_register_read_into_value): Rename from
	i386_pseudo_register_read.  Change arguments.  Call
	mark_value_bytes_unavailable when needed.
	(i386_pseudo_register_read_value): New function.
	(i386_gdbarch_init): Call set_gdbarch_pseudo_register_read_value,
	not set_gdbarch_pseudo_register_read.
	* gdbarch.sh (pseudo_register_read_value): New method.
	* gdbarch.c, gdbarch.h: Rebuild.
	* findvar.c (value_from_register): Call get_frame_register_value.
gdb/testsuite
	* gdb.dwarf2/typeddwarf.c: XFAIL 'z' on x86-64.
	* gdb.dwarf2/typeddwarf.exp (xfail-gdb-test): Add arch_pattern
	argument.
	* gdb.dwarf2/typeddwarf-amd64.S: New file.
@
text
@d2231 9
d7328 1
@


1.335
log
@gdb/
	Disable epilogue unwinders on recent GCCs.
	* amd64-tdep.c (amd64_in_function_epilogue_p): New variable symtab,
	initialize it, return 0 on EPILOGUE_UNWIND_VALID.
	* dwarf2read.c (process_full_comp_unit): Initialize
	EPILOGUE_UNWIND_VALID.
	* i386-tdep.c (i386_in_function_epilogue_p): New variable symtab,
	initialize it, return 0 on EPILOGUE_UNWIND_VALID.
	* symtab.h (struct symtab): New field epilogue_unwind_valid.
@
text
@d2783 9
a2791 3
enum register_status
i386_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int regnum, gdb_byte *buf)
d2795 1
d2804 4
a2807 2
	return status;
      memcpy (buf, raw_buf, register_size (gdbarch, regnum));
d2822 3
a2824 2
	    return status;
	  memcpy (buf, raw_buf, 16);
d2830 3
a2832 2
	    return status;
	  memcpy (buf + 16, raw_buf, 16);
d2841 4
a2844 2
	    return status;
	  memcpy (buf, raw_buf, 2);
d2857 3
a2859 2
	    return status;
	  if (gpnum >= 4)
d2867 14
d2882 1
a2882 1
  return REG_VALID;
d7364 2
a7365 1
  set_gdbarch_pseudo_register_read (gdbarch, i386_pseudo_register_read);
@


1.334
log
@* i386-tdep.c (i386_epilogue_frame_cache): Simplify code.  Call
get_frame_func instead of get_frame_pc to determine the code
address used to construct the frame ID.
(i386_epilogue_frame_unwind_stop_reason): Fix coding style.
(i386_epilogue_frame_this_id): Likewise.
(i386_epilogue_frame_prev_register): New function.
(i386_epilogue_frame_unwind): Use i386_epilogue_frame_prev_register.
(i386_stack_tramp_frame_sniffer): Fix coding style.
(i386_stack_tramp_frame_unwind): Use i386_epilogue_frame_prev_register.
(i386_gdbarch_init): Fix comments.
@
text
@d1888 5
@


1.333
log
@* i386-tdep.c (i386_match_insn_block): Use length of the proper
instruction when walking back through the instruction stream.
@
text
@a1912 2
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
d1915 1
a1915 1
  gdb_byte buf[4];
d1925 1
a1925 4
      /* Cache base will be %esp plus cache->sp_offset (-4).  */
      get_frame_register (this_frame, I386_ESP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 4,
					      byte_order) + cache->sp_offset;
d1927 5
a1931 4
      /* Cache pc will be the frame func.  */
      cache->pc = get_frame_pc (this_frame);

      /* The saved %esp will be at cache->base plus 8.  */
a1932 2

      /* The saved %eip will be at cache->base plus 4.  */
d1947 2
a1948 2
  struct i386_frame_cache *cache
    = i386_epilogue_frame_cache (this_frame, this_cache);
d1961 2
a1962 2
  struct i386_frame_cache *cache = i386_epilogue_frame_cache (this_frame,
							      this_cache);
d1970 10
d1985 1
a1985 1
  i386_frame_prev_register,
d2052 2
a2053 2
			     struct frame_info *this_frame,
			     void **this_prologue_cache)
d2067 1
a2067 1
  i386_frame_prev_register,
d7318 2
a7319 2
     appended to the list first, so that it supercedes the Dwarf
     unwinder in function epilogues (where the Dwarf unwinder
d7324 1
a7324 1
     to the list before the prologue-based unwinders, so that Dwarf
@


1.332
log
@2011-05-05  Jerome Guitton  <guitton@@adacore.com>

	* i386-tdep.c (i386_in_stack_tramp_p, i386_stack_tramp_frame_sniffer):
	New functions.
	(i386_stack_tramp_frame_unwind): New static global.
	(i386_match_pattern): New function, extracted from i386_match_insn.
	(i386_match_insn): Use i386_match_pattern.
	(i386_match_insn_block): New function.
	(i386_tramp_chain_in_reg_insns)
	(i386_tramp_chain_on_stack_insns): New static variables.
	(i386_gdbarch_init): Add i386_stack_tramp_frame_unwind to list
	of unwinders.
@
text
@d1194 1
a1194 1
  current_pc = pc - insn->len;
d1198 2
a1201 2

      current_pc -= insn_patterns[i].len;
@


1.331
log
@	* i386-tdep.c (i386_frame_prev_register): Unwind SP from memory
	if neither saved value nor register available (e.g. signal frame).
@
text
@d1129 33
a1161 1
/* Search for the instruction at PC in the list SKIP_INSNS.  Return
d1166 18
a1183 1
i386_match_insn (CORE_ADDR pc, struct i386_insn *skip_insns)
d1185 3
a1188 1
  gdb_byte op;
d1190 3
a1192 2
  if (target_read_memory (pc, &op, 1))
    return NULL;
d1194 3
a1196 1
  for (insn = skip_insns; insn->len > 0; insn++)
d1198 2
a1199 5
      if ((op & insn->mask[0]) == insn->insn[0])
	{
	  gdb_byte buf[I386_MAX_MATCHED_INSN_LEN - 1];
	  int insn_matched = 1;
	  size_t i;
d1201 2
a1202 2
	  gdb_assert (insn->len > 1);
	  gdb_assert (insn->len <= I386_MAX_MATCHED_INSN_LEN);
d1204 5
a1208 8
	  if (target_read_memory (pc + 1, buf, insn->len - 1))
	    return NULL;

	  for (i = 1; i < insn->len; i++)
	    {
	      if ((buf[i - 1] & insn->mask[i]) != insn->insn[i])
		insn_matched = 0;
	    }
d1210 1
a1210 3
	  if (insn_matched)
	    return insn;
	}
d1213 1
a1213 1
  return NULL;
d1987 82
d7426 1
@


1.330
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d1801 2
a1802 1
  if (regnum == I386_ESP_REGNUM)
d1807 1
a1807 1
      if (cache->saved_sp == 0 && cache->saved_sp_reg != -1)
@


1.329
log
@	gdb/
	* dwarf2loc.c (read_pieced_value): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	(write_pieced_value): Handle get_frame_register_bytes returning
	that the register piece is unavailable/optimized out when doing a
	read-modify write of a bitfield.
	* findvar.c (value_from_register): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	* frame.c (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.  Throw error on bad debug info.  Use
	frame_register instead of frame_register_read, to fill in the new
	arguments.
	* frame.h (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.
	* valops.c: (value_assign): Adjust, and handle
	get_frame_register_bytes failing.
	* spu-tdep.c: Include exceptions.h.
	(spu_software_single_step): Adjust, and handle
	get_frame_register_bytes failing.
	(spu_get_longjmp_target): Ditto.
	* gdbarch.sh (register_to_value): Change to return int.  New
	parameters `optimizedp' and `unavailablep'.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_register_to_value): Adjust to new
	gdbarch_register_to_value interface.
	* i387-tdep.c (i387_register_to_value): Ditto.
	* i387-tdep.h (i387_register_to_value): Ditto.
	* alpha-tdep.c (alpha_register_to_value): Ditto.
	* ia64-tdep.c (ia64_register_to_value): Ditto.
	* m68k-tdep.c (m68k_register_to_value): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* rs6000-tdep.c (rs6000_register_to_value): Ditto.
@
text
@d48 1
a48 1

d807 1
d832 1
d1613 3
a1615 2
static struct i386_frame_cache *
i386_frame_cache (struct frame_info *this_frame, void **this_cache)
a1618 1
  struct i386_frame_cache *cache;
d1622 1
a1622 5
  if (*this_cache)
    return *this_cache;

  cache = i386_alloc_frame_cache ();
  *this_cache = cache;
d1636 1
a1636 1
    return cache;
a1640 1
  cache->pc = get_frame_func (this_frame);
a1644 7
  if (cache->saved_sp_reg != -1)
    {
      /* Saved stack pointer has been saved.  */
      get_frame_register (this_frame, cache->saved_sp_reg, buf);
      cache->saved_sp = extract_unsigned_integer (buf, 4, byte_order);
    }

d1657 4
d1688 8
d1698 1
a1698 1
  if (cache->saved_sp == 0)
d1707 22
d1746 16
d1801 12
a1812 2
  if (regnum == I386_ESP_REGNUM && cache->saved_sp)
    return frame_unwind_got_constant (this_frame, regnum, cache->saved_sp);
d1824 1
d1868 1
d1878 6
a1883 4
  /* Cache base will be %esp plus cache->sp_offset (-4).  */
  get_frame_register (this_frame, I386_ESP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4, 
					  byte_order) + cache->sp_offset;
d1885 2
a1886 2
  /* Cache pc will be the frame func.  */
  cache->pc = get_frame_pc (this_frame);
d1888 2
a1889 2
  /* The saved %esp will be at cache->base plus 8.  */
  cache->saved_sp = cache->base + 8;
d1891 7
a1897 2
  /* The saved %eip will be at cache->base plus 4.  */
  cache->saved_regs[I386_EIP_REGNUM] = cache->base + 4;
d1902 13
d1923 3
d1932 1
d1948 1
d1958 9
a1966 2
  get_frame_register (this_frame, I386_ESP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4, byte_order) - 4;
d1968 1
a1968 4
  addr = tdep->sigcontext_addr (this_frame);
  if (tdep->sc_reg_offset)
    {
      int i;
d1970 9
a1978 1
      gdb_assert (tdep->sc_num_regs <= I386_NUM_SAVED_REGS);
d1980 1
a1980 8
      for (i = 0; i < tdep->sc_num_regs; i++)
	if (tdep->sc_reg_offset[i] != -1)
	  cache->saved_regs[i] = addr + tdep->sc_reg_offset[i];
    }
  else
    {
      cache->saved_regs[I386_EIP_REGNUM] = addr + tdep->sc_pc_offset;
      cache->saved_regs[I386_ESP_REGNUM] = addr + tdep->sc_sp_offset;
d1982 2
d1989 13
d2009 3
d2059 1
@


1.328
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d2749 1
a2749 1
static void
d2751 2
a2752 1
			struct type *type, gdb_byte *to)
a2756 3
  /* FIXME: kettenis/20030609: What should we do if REGNUM isn't
     available in FRAME (i.e. if it wasn't saved)?  */

d2758 2
a2759 4
    {
      i387_register_to_value (frame, regnum, type, to);
      return;
    }
d2770 5
a2774 1
      get_frame_register (frame, regnum, to);
d2779 3
@


1.327
log
@Fix relocation of jump and call instructions (used when inserting fast
tracepoints).

2011-03-18  Kwok Cheung Yeung  <kcy@@codesourcery.com>

        * amd64-tdep.c (amd64_relocate_instruction): Fix ordering of arguments
        to store_signed_integer.  Add debug message when relocating CALL
        instructions.  Fix formatting of debug message.
        * i386-tdep.c (i386_relocate_instruction): Ditto.
@
text
@d2544 1
a2544 1
void
d2549 1
d2556 3
a2558 1
      regcache_raw_read (regcache, fpnum, raw_buf);
d2570 5
a2574 3
	  regcache_raw_read (regcache,
			     I387_XMM0_REGNUM (tdep) + regnum,
			     raw_buf);
d2577 5
a2581 3
	  regcache_raw_read (regcache,
			     tdep->ymm0h_regnum + regnum,
			     raw_buf);
d2589 3
a2591 1
	  regcache_raw_read (regcache, gpnum, raw_buf);
d2603 3
a2605 1
	  regcache_raw_read (regcache, gpnum % 4, raw_buf);
d2614 2
@


1.326
log
@2011-03-08  Michael Snyder  <msnyder@@vmware.com>

	* i386-tdep.c (i386_follow_jump): Check return value of
	target_read_memory.
	(i386_analyze_struct_return): Ditto.
	(i386_skip_probe): Ditto.
	(i386_match_insn): Ditto.
	(i386_skip_noop): Ditto.
	(i386_analyze_frame_setup): Ditto.
	(i386_analyze_register_saves): Ditto.
	(i386_skip_prologue): Ditto.
	(i386_skip_main_prologue): Ditto.
@
text
@d750 8
a757 1
      store_signed_integer (insn + 1, 4, newrel, byte_order);
d776 1
a776 1
      store_signed_integer (insn + offset, 4, newrel, byte_order);
d779 2
a780 2
			    "Adjusted insn rel32=0x%s at 0x%s to"
			    " rel32=0x%s at 0x%s\n",
@


1.325
log
@2011-03-02  Michael Snyder  <msnyder@@vmware.com>

	* i386-tdep.c (i386_process_record): Document fall through.
@
text
@d853 3
a855 1
  target_read_memory (pc, &op, 1);
d921 2
a922 1
  target_read_memory (pc, &op, 1);
d927 3
a929 1
  target_read_memory (pc + 1, buf, 4);
d968 2
a969 1
  target_read_memory (pc, &op, 1);
d1130 2
a1131 1
  target_read_memory (pc, &op, 1);
d1144 3
a1146 1
	  target_read_memory (pc + 1, buf, insn->len - 1);
d1224 2
a1225 1
  target_read_memory (pc, &op, 1);
d1234 2
a1235 1
	  target_read_memory (pc, &op, 1);
d1251 3
a1253 1
	  target_read_memory (pc + 1, &op, 1);
d1257 3
a1259 1
	      target_read_memory (pc, &op, 1);
d1285 2
a1286 1
  target_read_memory (pc, &op, 1);
d1321 2
a1322 1
      target_read_memory (pc + skip, &op, 1);
d1358 2
a1359 1
      target_read_memory (pc, &op, 1);
d1415 2
a1416 1
      target_read_memory (pc, &op, 1);
d1509 3
a1511 1
      target_read_memory (pc + i, &op, 1);
d1519 2
a1520 1
      target_read_memory (pc + delta, &op, 1);
d1533 2
a1534 1
          target_read_memory (pc + delta, &op, 1);
d1564 2
a1565 1
  target_read_memory (pc, &op, 1);
@


1.324
log
@gdb/
	* i386-tdep.c (i386_process_record): Rename l suffixes to d suffixes
	in comments for pcmpgtd, pcmpeqd, psubd, paddd, pcmpgtd, pcmpeqd,
	psubd and paddd.
@
text
@d4546 1
d5326 1
@


1.323
log
@gdb/
	PR 12361.
	* i386-tdep.c (i386_process_record) <0x660f3807>: Fix the comment to
	phsubsw.
	(i386_process_record) <lddqu>: Fix the opcode to 0xf20ff0.
	(i386_process_record) <0x0f3807>: Fix the comment to phsubsw.
@
text
@d6350 1
a6350 1
        case 0x660f66:      /* pcmpgtl */
d6366 1
a6366 1
        case 0x660f76:      /* pcmpeql */
d6421 1
a6421 1
        case 0x660ffa:      /* psubl */
d6425 1
a6425 1
        case 0x660ffe:      /* paddl */
d6561 1
a6561 1
        case 0x0f66:      /* pcmpgtl */
d6572 1
a6572 1
        case 0x0f76:      /* pcmpeql */
d6610 1
a6610 1
        case 0x0ffa:      /* psubl */
d6614 1
a6614 1
        case 0x0ffe:      /* paddl */
@


1.322
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* h8300-tdep.c: Comment cleanup, mostly periods and spaces.
	* hppa-hpux-tdep.c: Ditto.
	* hppa-linux-nat.c: Ditto.
	* hppa-linux-tdep.c: Ditto.
	* hppanbsd-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* hppa-tdep.h: Ditto.
	* hpux-thread.c: Ditto.
	* i386-cygwin-tdep.c: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386gnu-nat.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* i386-linux-tdep.c: Ditto.
	* i386-nat.c: Ditto.
	* i386-nat.h: Ditto.
	* i386nbsd-tdep.c: Ditto.
	* i386-sol2-nat.c: Ditto.
	* i386-stub.c: Ditto.
	* i386-tdep.c: Ditto.
	* i386-tdep.h: Ditto.
	* i387-tdep.c: Ditto.
	* ia64-linux-nat.c: Ditto.
	* ia64-linux-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* infcall.c: Ditto.
	* infcall.h: Ditto.
	* infcmd.c: Ditto.
	* inferior.c: Ditto.
	* inferior.h: Ditto.
	* infloop.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* interps.c: Ditto.
	* interps.h: Ditto.
	* iq2000-tdep.c: Ditto.
	* irix5-nat.c: Ditto.
	* jit.c: Ditto.
	* jit.h: Ditto.
	* jv-exp.y: Ditto.
	* jv-lang.c: Ditto.
	* jv-lang.h: Ditto.
	* jv-typeprint.c: Ditto.
	* jv-valprint.c: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* linespec.c: Ditto.
	* linux-fork.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-thread-db.c: Ditto.
	* lm32-tdep.c: Ditto.
@
text
@d6259 1
a6259 1
        case 0x660f3807:    /* phaddsw */
d6412 1
a6412 1
        case 0x660ff0:      /* lddqu */
d6528 1
a6528 1
        case 0x0f3807:    /* phaddsw */
@


1.321
log
@run copyright.sh for 2011.
@
text
@d448 1
a448 1
  /* jmp far (absolute address in operand) */
d454 1
a454 1
      /* jump near, absolute indirect (/4) */
d458 1
a458 1
      /* jump far, absolute indirect (/5) */
d469 1
a469 1
  /* call far, absolute */
d475 1
a475 1
      /* Call near, absolute indirect (/2) */
d479 1
a479 1
      /* Call far, absolute indirect (/3) */
d492 1
a492 1
    case 0xc2: /* ret near, pop N bytes */
d494 1
a494 1
    case 0xca: /* ret far, pop N bytes */
d510 1
a510 1
  /* call near, relative */
d739 1
a739 1
      push_buf[0] = 0x68; /* pushq $... */
d1160 1
a1160 1
  /* Check for `movb imm8, r' and `movl imm32, r'. 
d2174 2
a2175 1
			_("Cannot extract return value of %d bytes long."), len);
d2471 1
a2471 1
   register REGNUM. */
d2535 1
a2535 1
	  /* Extract (always little endian).  Read lower 128bits. */
d2675 2
a2676 1
i386_convert_register_p (struct gdbarch *gdbarch, int regnum, struct type *type)
d3240 1
a3240 1
   Return -1 if something wrong. */
d3265 1
a3265 1
   Return -1 if something wrong. */
d3498 1
a3498 1
   Return -1 if something wrong. */
d3536 1
a3536 1
   Return -1 if something wrong. */
d3561 3
a3563 3
/* Record the value of floating point registers which will be changed by the
   current instruction to "record_arch_list".  Return -1 if something is wrong.
*/
d3625 1
a3625 1
   Return -1 if something wrong. */
d3758 1
a3758 1
  /* now check op code */
d4641 1
a4641 1
	  /* Memory. */
d6461 2
a6462 1
              if (!i386_xmm_regnum_p (gdbarch, I387_XMM0_REGNUM (tdep) + ir.rm))
d6694 2
a6695 1
              if (!i386_xmm_regnum_p (gdbarch, I387_XMM0_REGNUM (tdep) + ir.rm))
d6798 2
a6799 1
	*msg = xstrprintf (_("; instruction is only %d bytes long, need at least %d bytes for the jump"),
@


1.320
log
@Set 256bit vector type name to builtin_type_vec256i.

2010-09-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-tdep.c (i386_ymm_type): Set type name to
	builtin_type_vec256i.
@
text
@d5 1
a5 1
   2010 Free Software Foundation, Inc.
@


1.319
log
@2010-09-12  Michael Snyder  <msnyder@@vmware.com>

	* i386-tdep.c (i386_gdbarch_init): Fix typo in comments.
@
text
@d2420 1
a2420 1
      TYPE_NAME (t) = "builtin_type_vec128i";
@


1.318
log
@Fix typo in comments.

2010-09-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-tdep.c (i386_gdbarch_init): Fix typo in comments.
@
text
@d7116 1
a7116 1
      /* Support dword pseudo-registesr if it hasn't been disabled.  */
d7126 1
a7126 1
      /* Support YMM pseudo-registesr if it is available.  */
d7135 1
a7135 1
      /* Support MMX pseudo-registesr if MMX hasn't been disabled.  */
@


1.317
log
@Remove amd64_register_name.

2010-09-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* amd64-tdep.c (amd64_register_name): Removed.
	(amd64_init_abi): Don't call set_gdbarch_register_name.

	* i386-tdep.c (i386_ymmh_regnum_p): Make it static.

	* i386-tdep.h (i386_ymmh_regnum_p): Removed.
@
text
@d7116 1
a7116 1
      /* Support dword pseudo-registesr if it hasn't been disabled,  */
d7126 1
a7126 1
      /* Support YMM pseudo-registesr if it is available,  */
d7135 1
a7135 1
      /* Support MMX pseudo-registesr if MMX hasn't been disabled,  */
@


1.316
log
@2010-06-22  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c (i386_record_lea_modrm): Change warning to query.
	(i386_process_record): Ditto.
	* record.c (record_memory_query): New variable.
	(_initialize_record): New command "set record memory-query".
	* record.h (record_memory_query): New extern.

2010-06-22  Hui Zhu  <teawater@@gmail.com>

	* gdb.texinfo: (Process Record and Replay): Add documentation
	for command "set record memory-query".
@
text
@d168 1
a168 1
int
@


1.316.2.1
log
@Fix relocation of jump and call instructions (used when inserting fast
tracepoints).

2011-03-18  Kwok Cheung Yeung  <kcy@@codesourcery.com>

	* amd64-tdep.c (amd64_relocate_instruction): Fix ordering of arguments
        to store_signed_integer.  Add debug message when relocating CALL
        instructions.  Fix formatting of debug message.
        * i386-tdep.c (i386_relocate_instruction): Ditto.
@
text
@d750 1
a750 8
      store_signed_integer (insn + 1, 4, byte_order, newrel);

      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog,
			    "Adjusted insn rel32=%s at %s to"
			    " rel32=%s at %s\n",
			    hex_string (rel32), paddress (gdbarch, oldloc),
			    hex_string (newrel), paddress (gdbarch, *to));
d769 1
a769 1
      store_signed_integer (insn + offset, 4, byte_order, newrel);
d772 2
a773 2
			    "Adjusted insn rel32=%s at %s to"
			    " rel32=%s at %s\n",
@


1.315
log
@	* i386-tdep.h (i386_displaced_step_copy_insn): Declare.
	* i386-tdep.c (i386_displaced_step_copy_insn): New function.
	(i386_syscall_p): Change type of lengthp to int.
	(i386_displaced_step_fixup): Handle kernels that run one past a
	syscall insn.
	* i386-linux-tdep.c (i386_linux_init_abi): Use
	i386_displaced_step_copy_insn instead of
	simple_displaced_step_copy_insn.
@
text
@d3506 15
a3520 4
      warning (_("Process record ignores the memory change "
                 "of instruction at address %s because it "
                 "can't get the value of the segment register."),
               paddress (gdbarch, irp->orig_addr));
d4411 14
a4424 5
	  warning (_("Process record ignores the memory change "
                     "of instruction at address %s because "
                     "it can't get the value of the segment "
                     "register."),
                   paddress (gdbarch, ir.orig_addr));
d5101 14
a5114 5
              warning (_("Process record ignores the memory "
                         "change of instruction at address %s "
                         "because it can't get the value of the "
                         "ES segment register."),
                       paddress (gdbarch, ir.orig_addr));
d5667 14
a5680 6
		warning (_("Process record ignores the memory "
                           "change of instruction at "
                           "address %s because it can't get "
                           "the value of the segment "
                           "register."),
                         paddress (gdbarch, ir.orig_addr));
d5724 14
a5737 6
		  warning (_("Process record ignores the memory "
                             "change of instruction at "
                             "address %s because it can't get "
                             "the value of the segment "
                             "register."),
                           paddress (gdbarch, ir.orig_addr));
@


1.314
log
@gdb/
2010-05-26  Pedro Alves  <pedro@@codesourcery.com>

	* NEWS: Mention the `qRelocInsn' feature.
	* gdbarch.sh (relocate_instruction): New.
	* amd64-tdep.c (rip_relative_offset): New.
	(append_insns): New.
	(amd64_relocate_instruction): New.
	(amd64_init_abi): Install it.
	* i386-tdep.c (append_insns): New.
	(i386_relocate_instruction): New.
	(i386_gdbarch_init): Install it.
	* remote.c (remote_get_noisy_reply): Handle qRelocInsn requests.
	* gdbarch.h, gdbarch.c: Regenerate.

gdb/doc/
2010-05-26  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (General Query Packets) <qSupported>: Describe the
	`qRelocInsn' feature.
	(Relocate instruction reply packet): New subsection
	of `Tracepoint Packets'.
	(Tracepoint Packets): Mention that packets QTDP and QTStart
	support the qRelocInsn request, and add cross reference to new
	subsection.
@
text
@d521 1
a521 1
i386_syscall_p (const gdb_byte *insn, ULONGEST *lengthp)
d532 37
d627 1
a627 1
      ULONGEST insn_len;
d646 6
a651 1
          && orig_eip != to + (insn - insn_start) + insn_len)
@


1.313
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* i386-tdep.c (i386_supply_xstateregset) Delete unused variable.
	(i386_collect_xstateregset): Delete unused variable.
	* i387-tdep.c (i387_print_float_info): Delete unused variable.
@
text
@d661 80
d6992 2
@


1.312
log
@	* defs.h: Adjust comment.
	* filesystem.h, filesystem.c: New files.
	* Makefile.in (SFILES): Add filesystem.c.
	(COMMON_OBS): Add filesystem.o.
	* solib.c (solib_find): Handle DOS-based filesystems.  Handle
	different target and host path flavours.
	* arm-symbian-tdep.c (arm_symbian_init_abi): Set
	has_dos_based_file_system on the gdbarch.
	* arm-wince-tdep.c (arm_wince_init_abi): Ditto.
	* i386-cygwin-tdep.c (i386_cygwin_init_abi): Ditto.
	* i386-tdep.c (i386_go32_init_abi): Ditto.
	* gdbarch.sh (has_dos_based_file_system): New.
	* gdbarch.h, gdbarch.c: Regenerate.
	* NEWS: Mention improved support for remote targets with DOS-based
	filesystems.  Mention new `set/show target-file-system-kind'
	commands.

	gdb/doc/
	* gdb.texinfo (Commands to specify files): Describe what how GDB
	looks up DOS-based filesystem paths on the system root.  Document
	the new `set/show target-file-system-kind' commands.
@
text
@a2738 1
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
a2748 1
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
@


1.311
log
@Support i386 without SSE.

gdb/

2010-04-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-linux-nat.c (have_ptrace_getfpxregs): Initialize to -1
	if HAVE_PTRACE_GETFPXREGS is defined.
	(i386_linux_read_description): Set have_ptrace_getfpxregs and
	have_ptrace_getregset to 0 if ptrace PTRACE_GETFPXREGS failed.

	* i386-linux-tdep.c: Include "features/i386/i386-mmx-linux.c"
	(i386_linux_core_read_description): Return tdesc_i386_mmx_linux
	if .reg-xfp section doesn't exist.
	(_initialize_i386_linux_tdep): Call initialize_tdesc_i386_mmx_linux.

	* i386-linux-tdep.h (tdesc_i386_mmx_linux): New.

	* i386-tdep.c: Include "features/i386/i386-mmx.c".
	(i386_go32_init_abi): Set tdesc to tdesc_i386_mmx.
	(i386_validate_tdesc_p): Make org.gnu.gdb.i386.sse optional.  Set
	xcr0 to I386_XSTATE_X87_MASK if SSE isn't available.
	(i386_gdbarch_init): Update comments.
	(_initialize_i386_tdep): Call initialize_tdesc_i386_mmx.

	* common/i386-xstate.h (I386_XSTATE_X87_MASK): New.

	* config/djgpp/fnchange.lst: Add i386 MMX XML files.

	* features/Makefile (i386/i386-mmx-expedite): New.
	(i386/i386-mmx-linux-expedite): Likewise.
	($(outdir)/i386/i386-mmx.dat): Likewise.
	($(outdir)/i386/i386-mmx-linux.dat): Likewise.

	* features/i386/i386-mmx-linux.c: New.
	* features/i386/i386-mmx-linux.xml: Likewise.
	* features/i386/i386-mmx.c: Likewise.
	* features/i386/i386-mmx.xml: Likewise.
	* regformats/i386/i386-mmx-linux.dat: Likewise.
	* regformats/i386/i386-mmx.dat: Likewise.

	* features/Makefile (WHICH): Add i386/i386-mmx and
	i386/i386-mmx-linux.

gdb/doc/

2010-04-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* gdb.texinfo (i386 Features): Make org.gnu.gdb.i386.avx
	optional.  Make org.gnu.gdb.i386.avx requires
	org.gnu.gdb.i386.avx.

gdb/gdbserver/

2010-04-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.in (clean): Also remove i386-mmx.c i386-mmx-linux.c.
	(i386-mmx.o): New.
	(i386-mmx.c): Likewise.
	(i386-mmx-linux.o): Likewise.
	(i386-mmx-linux.c): Likewise.

	* configure.srv (srv_i386_regobj): Add i386-mmx.o.
	(srv_i386_linux_regobj): Add i386-mmx-linux.o.
	(srv_i386_xmlfiles): Add i386/i386-mmx.xml.
	(srv_i386_linux_xmlfiles): Add i386/i386-mmx-linux.xml.

	* linux-x86-low.c (init_registers_i386_mmx_linux): New.
	(x86_linux_update_xmltarget): Call init_registers_i386_mmx_linux
	and return if ptrace PTRACE_GETFPXREGS failed in 32bit.
@
text
@d2950 2
@


1.310
log
@2010-04-08  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c (i386_process_record): Add support for insn
	rdtsc.
@
text
@d61 1
d2941 2
a2942 2
  tdep->num_xmm_regs = 0;
  set_gdbarch_num_regs (gdbarch, I386_NUM_GREGS + I387_NUM_REGS);
d6653 2
a6658 3
  if (feature_core == NULL || feature_sse == NULL)
    return 0;

d6667 4
d6686 2
d6689 4
a6692 1
    tdep->xcr0 = I386_XSTATE_SSE_MASK;
d6699 8
a6706 5
  /* Need to include %mxcsr, so add one.  */
  num_regs += tdep->num_xmm_regs + 1;
  for (; i < num_regs; i++)
    valid_p &= tdesc_numbered_register (feature_sse, tdesc_data, i,
					tdep->register_names[i]);
d6747 1
a6747 9
     will show up in the output of "info all-registers".  Ideally we
     should try to autodetect whether they are available, such that we
     can prevent "info all-registers" from displaying registers that
     aren't available.

     NOTE: kevinb/2003-07-13: ... if it's a choice between printing
     [the SSE registers] always (even when they don't exist) or never
     showing them to the user (even when they do exist), I prefer the
     former over the latter.  */
d7046 1
@


1.309
log
@Support i386 AVX.

2010-04-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-linux-nat.c: Include "regset.h", "elf/common.h",
	<sys/uio.h> and "i386-xstate.h".
	(PTRACE_GETREGSET): New.
	(PTRACE_SETREGSET): Likewise.
	(fetch_xstateregs): Likewise.
	(store_xstateregs): Likewise.
	(GETXSTATEREGS_SUPPLIES): Likewise.
	(regmap): Include 8 upper YMM registers.
	(i386_linux_fetch_inferior_registers): Support XSAVE extended
	state.
	(i386_linux_store_inferior_registers): Likewise.
	(i386_linux_read_description): Check and enable AVX target
	descriptions.

	* i386-linux-tdep.c: Include "regset.h", "i387-tdep.h",
	"i386-xstate.h" and "features/i386/i386-avx-linux.c".
	(i386_linux_regset_sections): Add ".reg-xstate".
	(i386_linux_gregset_reg_offset): Include 8 upper YMM registers.
	(i386_linux_core_read_xcr0): New.
	(i386_linux_core_read_description): Check and enable AVX target
	description.
	(i386_linux_init_abi): Set xsave_xcr0_offset.
	(_initialize_i386_linux_tdep): Call
	initialize_tdesc_i386_avx_linux.

	* i386-linux-tdep.h (I386_LINUX_ORIG_EAX_REGNUM): Replace
	I386_SSE_NUM_REGS with I386_AVX_NUM_REGS.
	(i386_linux_core_read_xcr0): New.
	(tdesc_i386_avx_linux): Likewise.
	(I386_LINUX_XSAVE_XCR0_OFFSET): Likewise.

	* i386-tdep.c: Include "i386-xstate.h" and
	"features/i386/i386-avx.c".
	(i386_ymm_names): New.
	(i386_ymmh_names): Likewise.
	(i386_ymmh_regnum_p): Likewise.
	(i386_ymm_regnum_p): Likewise.
	(i386_xmm_regnum_p): Likewise.
	(i386_register_name): Likewise.
	(i386_ymm_type): Likewise.
	(i386_supply_xstateregset): Likewise.
	(i386_collect_xstateregset): Likewise.
	(i386_sse_regnum_p): Removed.
	(i386_pseudo_register_name): Support pseudo YMM registers.
	(i386_pseudo_register_type): Likewise.
	(i386_pseudo_register_read): Likewise.
	(i386_pseudo_register_write): Likewise.
	(i386_dbx_reg_to_regnum): Return %ymmN register number for
	%xmmN if AVX is available.
	(i386_regset_from_core_section): Support .reg-xstate section.
	(i386_register_reggroup_p): Supper upper YMM and YMM registers.
	(i386_process_record): Replace i386_sse_regnum_p with
	i386_xmm_regnum_p.
	(i386_validate_tdesc_p): Support org.gnu.gdb.i386.avx feature.
	Set ymmh_register_names, num_ymm_regs, ymm0h_regnum and xcr0.
	(i386_gdbarch_init): Set xstateregset.  Set xsave_xcr0_offset.
	Call set_gdbarch_register_name.  Replace I386_SSE_NUM_REGS with
	I386_AVX_NUM_REGS.  Set ymmh_register_names, ymm0h_regnum and
	num_ymm_regs.  Add num_ymm_regs to set_gdbarch_num_pseudo_regs.
	Set ymm0_regnum.
	(_initialize_i386_tdep): Call initialize_tdesc_i386_avx.

	* i386-tdep.h (gdbarch_tdep): Add xstateregset, ymm0_regnum,
	xcr0, xsave_xcr0_offset, ymm0h_regnum, ymmh_register_names and
	i386_ymm_type.
	(i386_regnum): Add I386_YMM0H_REGNUM, and I386_YMM7H_REGNUM.
	(I386_AVX_NUM_REGS): New.
	(i386_xmm_regnum_p): Likewise.
	(i386_ymm_regnum_p): Likewise.
	(i386_ymmh_regnum_p): Likewise.

	* common/i386-xstate.h: New.
@
text
@d5398 2
a5399 4
      printf_unfiltered (_("Process record does not support "
			   "instruction rdtsc.\n"));
      ir.addr -= 2;
      goto no_support;
@


1.308
log
@2010-04-02  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c (OT_DQUAD): New enum.
	(i386_process_record): Add code for MMX, 3DNow!, SSE, SSE2,
	SSE3, SSSE3 and SSE4.
@
text
@d54 1
d60 1
d79 12
d167 28
d197 2
a198 2
static int
i386_sse_regnum_p (struct gdbarch *gdbarch, int regnum)
d201 1
d203 1
a203 1
  if (I387_NUM_XMM_REGS (tdep) == 0)
d206 2
a207 2
  return (I387_XMM0_REGNUM (tdep) <= regnum
	  && regnum < I387_MXCSR_REGNUM (tdep));
d247 13
d268 2
d307 7
a313 1
      return reg - 21 + I387_XMM0_REGNUM (tdep);
d2251 53
d2354 2
d2407 16
a2422 1
      if (i386_word_regnum_p (gdbarch, regnum))
d2471 14
a2484 1
      if (i386_word_regnum_p (gdbarch, regnum))
d2731 22
d2780 10
d2983 3
a2985 2
  int sse_regnum_p, fp_regnum_p, mmx_regnum_p, byte_regnum_p,
      word_regnum_p, dword_regnum_p;
d2989 1
a2989 2
  byte_regnum_p = i386_byte_regnum_p (gdbarch, regnum);
  if (byte_regnum_p)
d2992 1
a2992 2
  word_regnum_p = i386_word_regnum_p (gdbarch, regnum);
  if (word_regnum_p)
d2995 1
a2995 2
  dword_regnum_p = i386_dword_regnum_p (gdbarch, regnum);
  if (dword_regnum_p)
d3002 2
a3003 2
  sse_regnum_p = (i386_sse_regnum_p (gdbarch, regnum)
		  || i386_mxcsr_regnum_p (gdbarch, regnum));
d3005 3
a3007 1
    return sse_regnum_p;
d3009 6
a3014 1
    return mmx_regnum_p || sse_regnum_p;
d3021 9
d3033 4
a3036 4
	    && !sse_regnum_p
	    && !byte_regnum_p
	    && !word_regnum_p
	    && !dword_regnum_p);
d5861 1
a5861 1
                 i386_sse_regnum_p (gdbarch, i); i++)
d6261 1
a6261 1
          if (!i386_sse_regnum_p (gdbarch, I387_XMM0_REGNUM (tdep) + ir.reg))
d6293 1
a6293 1
              if (!i386_sse_regnum_p (gdbarch, I387_XMM0_REGNUM (tdep) + ir.rm))
d6471 1
a6471 1
          if (!i386_sse_regnum_p (gdbarch, I387_XMM0_REGNUM (tdep) + ir.rm))
d6525 1
a6525 1
              if (!i386_sse_regnum_p (gdbarch, I387_XMM0_REGNUM (tdep) + ir.rm))
d6645 2
a6646 1
  const struct tdesc_feature *feature_core, *feature_vector;
d6656 1
a6656 1
  feature_vector = tdesc_find_feature (tdesc, "org.gnu.gdb.i386.sse");
d6658 1
a6658 1
  if (feature_core == NULL || feature_vector == NULL)
d6661 3
d6666 21
d6695 1
a6695 1
    valid_p &= tdesc_numbered_register (feature_vector, tdesc_data, i,
d6710 1
d6731 2
d6762 2
d6880 8
a6887 3
  /* The default ABI includes general-purpose registers, 
     floating-point registers, and the SSE registers.  */
  set_gdbarch_num_regs (gdbarch, I386_SSE_NUM_REGS);
d6898 4
d6906 1
d6914 8
d6927 2
a6928 1
					 + tdep->num_mmx_regs));
a6932 8
  if (!i386_validate_tdesc_p (tdep, tdesc_data))
    {
      tdesc_data_cleanup (tdesc_data);
      xfree (tdep);
      gdbarch_free (gdbarch);
      return NULL;
    }

d6942 1
a6942 1
  mm0_regnum = tdep->ax_regnum + tdep->num_word_regs;
d6946 2
a6947 2
      tdep->eax_regnum = mm0_regnum;
      mm0_regnum = tdep->eax_regnum + tdep->num_dword_regs;
d6952 10
d7044 1
@


1.307
log
@2010-04-02  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c (i386_record_lea_modrm_addr): Remove useless
	"*addr = 0".
@
text
@d2886 1
d3326 1
a3326 1
  ir.regmap = gdbarch_tdep (gdbarch)->record_regmap;
d3444 1
a3444 1
      opcode = (uint16_t) opcode8 | 0x0f00;
d5107 1
a5107 1
      printf_unfiltered (_("Process record doesn't support instruction "
d5128 1
a5128 1
	    || gdbarch_tdep (gdbarch)->i386_intx80_record == NULL)
d5130 1
a5130 1
	    printf_unfiltered (_("Process record doesn't support "
d5136 1
a5136 1
	ret = gdbarch_tdep (gdbarch)->i386_intx80_record (ir.regcache);
d5144 1
a5144 1
      printf_unfiltered (_("Process record doesn't support "
d5155 1
a5155 1
      printf_unfiltered (_("Process record doesn't support "
d5191 1
a5191 1
      printf_unfiltered (_("Process record doesn't support "
d5198 1
a5198 1
      printf_unfiltered (_("Process record doesn't support "
d5205 1
a5205 1
      printf_unfiltered (_("Process record doesn't support "
d5219 1
a5219 1
	if (gdbarch_tdep (gdbarch)->i386_sysenter_record == NULL)
d5221 1
a5221 1
	    printf_unfiltered (_("Process record doesn't support "
d5226 1
a5226 1
	ret = gdbarch_tdep (gdbarch)->i386_sysenter_record (ir.regcache);
d5233 1
a5233 1
      printf_unfiltered (_("Process record doesn't support "
d5242 1
a5242 1
	if (gdbarch_tdep (gdbarch)->i386_syscall_record == NULL)
d5244 1
a5244 1
	    printf_unfiltered (_("Process record doesn't support "
d5249 1
a5249 1
	ret = gdbarch_tdep (gdbarch)->i386_syscall_record (ir.regcache);
d5256 1
a5256 1
      printf_unfiltered (_("Process record doesn't support "
d5270 1
a5270 1
      printf_unfiltered (_("Process record doesn't support "
d5566 808
a6373 2
      /* MMX/SSE/SSE2/PNI support */
      /* XXX */
a6375 4
      if (opcode > 0xff)
	ir.addr -= 2;
      else
	ir.addr -= 1;
d6388 4
a6391 3
  printf_unfiltered (_("Process record doesn't support instruction 0x%02x "
		       "at address %s.\n"),
		     (unsigned int) (opcode), paddress (gdbarch, ir.addr));
@


1.306
log
@Add xmlRegisters= to qSupported packet.

gdb/

2010-03-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* NEWS: Mention xmlRegisters= in qSupported packet.

	* i386-tdep.c: Include "remote.h".
	(_initialize_i386_tdep): Call register_remote_support_xml.

	* remote.c (remote_support_xml): New.
	(register_remote_support_xml): Likewise.
	(remote_query_supported_append): Likewise.
	(remote_query_supported): Support remote_support_xml.

	* remote.h (register_remote_support_xml): New.

gdb/doc/

2010-03-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* gdb.texinfo (General Query Packets): Add xmlRegisters.
@
text
@a3002 4
	  else
	    {
	      *addr = 0;
	    }
a3075 4
	  else
	    {
	      *addr = 0;
	    }
@


1.305
log
@Restore sp for x86.

2010-03-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* amd64-tdep.c (amd64_word_names): Replace "sp" with "".
	* i386-tdep.c (i386_word_names): Likewise.
@
text
@d47 1
d6004 3
@


1.304
log
@2010-03-09  Michael Snyder  <msnyder@@vmware.com>

	* i386-tdep.c (i386_record_lea_modrm_addr): Use extract_signed_int
	after target_read_memory to get host byte order.
	(i386_process_record): Ditto.
@
text
@d97 1
a97 1
  "sp", "bp", "si", "di"
@


1.303
log
@2010-03-08  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c (i386_process_record): Initialize regnum.
@
text
@d2951 3
a2953 4
  int8_t  addr8;
  int16_t addr16;
  int32_t addr32;
  ULONGEST addr64;
d2989 1
a2989 1
	      if (target_read_memory (irp->addr, (gdb_byte *) &addr32, 4))
d2998 1
a2998 1
	      *addr = addr32;
d3008 1
a3008 1
	  if (target_read_memory (irp->addr, &addr8, 1))
d3017 1
a3017 1
	  *addr = addr8;
d3020 1
a3020 1
	  if (target_read_memory (irp->addr, (gdb_byte *) &addr32, 4))
d3028 1
a3028 1
	  *addr = addr32;
d3033 1
a3033 1
      addr64 = 0;
d3039 1
a3039 1
                                      &addr64);
d3043 1
a3043 1
	  *addr += addr64;
d3046 1
a3046 1
        *addr = (uint32_t) (addr64 + *addr);
d3051 1
a3051 1
                                      &addr64);
d3053 1
a3053 1
	    *addr += addr64 << scale;
d3055 1
a3055 1
	    *addr = (uint32_t) (*addr + (addr64 << scale));
d3066 1
a3066 1
	      if (target_read_memory (irp->addr, (gdb_byte *) &addr16, 2))
d3075 1
a3075 1
	      *addr = addr16;
d3085 1
a3085 1
	  if (target_read_memory (irp->addr, &addr8, 1))
d3094 1
a3094 1
	  *addr = addr8;
d3097 1
a3097 1
	  if (target_read_memory (irp->addr, (gdb_byte *) &addr16, 2))
d3106 1
a3106 1
	  *addr = addr16;
d3115 2
a3116 2
                                      &addr64);
	  *addr = (uint32_t) (*addr + addr64);
d3119 2
a3120 2
                                      &addr64);
	  *addr = (uint32_t) (*addr + addr64);
d3125 2
a3126 2
                                      &addr64);
	  *addr = (uint32_t) (*addr + addr64);
d3129 2
a3130 2
                                      &addr64);
	  *addr = (uint32_t) (*addr + addr64);
d3135 2
a3136 2
                                      &addr64);
	  *addr = (uint32_t) (*addr + addr64);
d3139 2
a3140 2
                                      &addr64);
	  *addr = (uint32_t) (*addr + addr64);
d3145 2
a3146 2
                                      &addr64);
	  *addr = (uint32_t) (*addr + addr64);
d3149 2
a3150 2
                                      &addr64);
	  *addr = (uint32_t) (*addr + addr64);
d3155 2
a3156 2
                                      &addr64);
	  *addr = (uint32_t) (*addr + addr64);
d3161 2
a3162 2
                                      &addr64);
	  *addr = (uint32_t) (*addr + addr64);
d3167 2
a3168 2
                                      &addr64);
	  *addr = (uint32_t) (*addr + addr64);
d3173 2
a3174 2
                                      &addr64);
	  *addr = (uint32_t) (*addr + addr64);
d3311 1
d3317 1
d4104 1
a4104 3
	      uint64_t addr64;

              if (target_read_memory (ir.addr, (gdb_byte *) &addr64, 8))
d4113 1
a4113 1
	      addr = addr64;
d4117 1
a4117 3
	      uint32_t addr32;

              if (target_read_memory (ir.addr, (gdb_byte *) &addr32, 4))
d4126 1
a4126 1
              addr = addr32;
d4130 1
a4130 3
	      uint16_t addr16;

              if (target_read_memory (ir.addr, (gdb_byte *) &addr16, 2))
d4139 1
a4139 1
              addr = addr16;
@


1.302
log
@2010-03-07  Michael Snyder  <msnyder@@vmware.com>

	* i386-tdep.c (i386_record_lea_modrm_addr): Rename local variables
	tmpu8, tmpi16, tmpi32, tmpulongest to addr8, addr16, addr32, addr64.

	(i386_record_push): Rename local tmpulongest to addr.

	(i386_process_record): Rename local tmpulongest to addr.
@
text
@d3313 1
a3313 1
  int regnum;
@


1.301
log
@2010-03-07  Michael Snyder  <msnyder@@vmware.com>

	* i386-tdep.c (i386_process_record): Rename local variables
	tmpu16, tmpu32, tmpu64 to addr16, addr32, addr64.
@
text
@d2951 4
a2954 4
  uint8_t tmpu8;
  int16_t tmpi16;
  int32_t tmpi32;
  ULONGEST tmpulongest;
d2962 1
d2969 1
a2969 1
	  if (target_read_memory (irp->addr, &tmpu8, 1))
d2978 3
a2980 3
	  scale = (tmpu8 >> 6) & 3;
	  index = ((tmpu8 >> 3) & 7) | irp->rex_x;
	  base = (tmpu8 & 7);
d2990 1
a2990 1
	      if (target_read_memory (irp->addr, (gdb_byte *) &tmpi32, 4))
d2999 1
a2999 1
	      *addr = tmpi32;
d3009 1
a3009 1
	  if (target_read_memory (irp->addr, &tmpu8, 1))
d3018 1
a3018 1
	  *addr = (int8_t) tmpu8;
d3021 1
a3021 1
	  if (target_read_memory (irp->addr, (gdb_byte *) &tmpi32, 4))
d3029 1
a3029 1
	  *addr = tmpi32;
d3034 1
a3034 1
      tmpulongest = 0;
d3040 1
a3040 1
                                      &tmpulongest);
d3044 1
a3044 1
	  *addr += tmpulongest;
d3047 1
a3047 1
        *addr = (uint32_t) (tmpulongest + *addr);
d3052 1
a3052 1
                                      &tmpulongest);
d3054 1
a3054 1
	    *addr += tmpulongest << scale;
d3056 1
a3056 1
	    *addr = (uint32_t) (*addr + (tmpulongest << scale));
d3067 1
a3067 2
	      if (target_read_memory
		  (irp->addr, (gdb_byte *) &tmpi16, 2))
d3076 1
a3076 1
	      *addr = tmpi16;
d3086 1
a3086 1
	  if (target_read_memory (irp->addr, &tmpu8, 1))
d3095 1
a3095 1
	  *addr = (int8_t) tmpu8;
d3098 1
a3098 1
	  if (target_read_memory (irp->addr, (gdb_byte *) &tmpi16, 2))
d3107 1
a3107 1
	  *addr = tmpi16;
d3116 2
a3117 2
                                      &tmpulongest);
	  *addr = (uint32_t) (*addr + tmpulongest);
d3120 2
a3121 2
                                      &tmpulongest);
	  *addr = (uint32_t) (*addr + tmpulongest);
d3126 2
a3127 2
                                      &tmpulongest);
	  *addr = (uint32_t) (*addr + tmpulongest);
d3130 2
a3131 2
                                      &tmpulongest);
	  *addr = (uint32_t) (*addr + tmpulongest);
d3136 2
a3137 2
                                      &tmpulongest);
	  *addr = (uint32_t) (*addr + tmpulongest);
d3140 2
a3141 2
                                      &tmpulongest);
	  *addr = (uint32_t) (*addr + tmpulongest);
d3146 2
a3147 2
                                      &tmpulongest);
	  *addr = (uint32_t) (*addr + tmpulongest);
d3150 2
a3151 2
                                      &tmpulongest);
	  *addr = (uint32_t) (*addr + tmpulongest);
d3156 2
a3157 2
                                      &tmpulongest);
	  *addr = (uint32_t) (*addr + tmpulongest);
d3162 2
a3163 2
                                      &tmpulongest);
	  *addr = (uint32_t) (*addr + tmpulongest);
d3168 2
a3169 2
                                      &tmpulongest);
	  *addr = (uint32_t) (*addr + tmpulongest);
d3174 2
a3175 2
                                      &tmpulongest);
	  *addr = (uint32_t) (*addr + tmpulongest);
d3219 1
a3219 1
  ULONGEST tmpulongest;
d3226 2
a3227 2
			      &tmpulongest);
  if (record_arch_list_add_mem ((CORE_ADDR) tmpulongest - size, size))
d3310 1
a3310 1
		     CORE_ADDR addr)
d3316 1
a3316 1
  ULONGEST tmpulongest;
d3325 2
a3326 2
  ir.addr = addr;
  ir.orig_addr = addr;
d4103 3
a4105 1
              if (target_read_memory (ir.addr, (gdb_byte *) &addr, 8))
d4114 1
d4129 1
a4129 1
              tmpulongest = addr32;
d4144 1
a4144 1
              tmpulongest = addr16;
d4146 1
a4146 1
	  if (record_arch_list_add_mem (tmpulongest, 1 << ir.ot))
d4754 2
a4755 2
                                  &tmpulongest);
      if (tmpulongest)
d4765 1
a4765 1
                                      &tmpulongest);
d4784 1
a4784 1
              if (record_arch_list_add_mem (tmpulongest, 1 << ir.ot))
d5050 1
a5050 1
                                      &tmpulongest);
d5054 1
a5054 1
              addr64 += ((int16_t) tmpulongest >> 4) << 4;
d5057 1
a5057 1
              addr64 += ((int32_t) tmpulongest >> 5) << 5;
d5060 1
a5060 1
              addr64 += ((int64_t) tmpulongest >> 6) << 6;
@


1.300
log
@2010-03-07  Michael Snyder  <msnyder@@vmware.com>

	* i386-tdep.c (i386_process_record): Rename tmpu8 to opcode8 and
	regnum.
@
text
@a3315 2
  uint16_t tmpu16;
  uint32_t tmpu32;
d4115 3
a4117 1
              if (target_read_memory (ir.addr, (gdb_byte *) &tmpu32, 4))
d4126 1
a4126 1
              addr = tmpu32;
d4130 3
a4132 1
              if (target_read_memory (ir.addr, (gdb_byte *) &tmpu16, 2))
d4141 1
a4141 1
              addr = tmpu16;
d4143 1
a4143 1
	  if (record_arch_list_add_mem (addr, 1 << ir.ot))
d4312 1
a4312 1
	  uint64_t tmpu64;
d4314 1
a4314 1
	  if (i386_record_lea_modrm_addr (&ir, &tmpu64))
d4391 1
a4391 1
		      if (record_arch_list_add_mem (tmpu64, 4))
d4395 1
a4395 1
		      if (record_arch_list_add_mem (tmpu64, 8))
d4401 1
a4401 1
		      if (record_arch_list_add_mem (tmpu64, 2))
d4410 1
a4410 1
		      if (record_arch_list_add_mem (tmpu64, 4))
d4421 1
a4421 1
		      if (record_arch_list_add_mem (tmpu64, 4))
d4434 1
a4434 1
		      if (record_arch_list_add_mem (tmpu64, 8))
d4454 1
a4454 1
		      if (record_arch_list_add_mem (tmpu64, 2))
d4481 1
a4481 1
		  if (record_arch_list_add_mem (tmpu64, 28))
d4486 1
a4486 1
		  if (record_arch_list_add_mem (tmpu64, 14))
d4492 1
a4492 1
	      if (record_arch_list_add_mem (tmpu64, 2))
d4500 1
a4500 1
	      if (record_arch_list_add_mem (tmpu64, 10))
d4506 1
a4506 1
		  if (record_arch_list_add_mem (tmpu64, 28))
d4508 1
a4508 1
		  tmpu64 += 28;
d4512 1
a4512 1
		  if (record_arch_list_add_mem (tmpu64, 14))
d4514 1
a4514 1
		  tmpu64 += 14;
d4516 1
a4516 1
	      if (record_arch_list_add_mem (tmpu64, 80))
d4524 1
a4524 1
	      if (record_arch_list_add_mem (tmpu64, 8))
d5042 2
a5043 2
          uint64_t tmpu64;
          if (i386_record_lea_modrm_addr (&ir, &tmpu64))
d5051 1
a5051 1
              tmpu64 += ((int16_t) tmpulongest >> 4) << 4;
d5054 1
a5054 1
              tmpu64 += ((int32_t) tmpulongest >> 5) << 5;
d5057 1
a5057 1
              tmpu64 += ((int64_t) tmpulongest >> 6) << 6;
d5060 1
a5060 1
          if (record_arch_list_add_mem (tmpu64, 1 << ir.ot))
d5322 1
a5322 1
	    uint64_t tmpu64;
d5341 1
a5341 1
		if (i386_record_lea_modrm_addr (&ir, &tmpu64))
d5343 1
a5343 1
		if (record_arch_list_add_mem (tmpu64, 2))
d5345 1
a5345 1
		tmpu64 += 2;
d5348 1
a5348 1
                    if (record_arch_list_add_mem (tmpu64, 8))
d5353 1
a5353 1
                    if (record_arch_list_add_mem (tmpu64, 4))
d5390 1
a5390 1
		  uint64_t tmpu64;
d5392 1
a5392 1
		  if (i386_record_lea_modrm_addr (&ir, &tmpu64))
d5394 1
a5394 1
		  if (record_arch_list_add_mem (tmpu64, 2))
d5396 1
a5396 1
		  tmpu64 += 2;
d5399 1
a5399 1
                      if (record_arch_list_add_mem (tmpu64, 8))
d5404 1
a5404 1
                      if (record_arch_list_add_mem (tmpu64, 4))
@


1.299
log
@2010-03-04  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c (i386_process_record): Change "addr" to "tmpu64".
@
text
@d3313 3
a3315 1
  uint8_t tmpu8;
a3318 1
  uint32_t opcode;
d3344 1
a3344 1
      if (target_read_memory (ir.addr, &tmpu8, 1))
d3353 1
a3353 1
      switch (tmpu8)	/* Instruction prefixes */
d3408 4
a3411 4
               rex_w = (tmpu8 >> 3) & 1;
               rex_r = (tmpu8 & 0x4) << 1;
               ir.rex_x = (tmpu8 & 0x2) << 2;
               ir.rex_b = (tmpu8 & 0x1) << 3;
d3437 1
a3437 1
  opcode = (uint32_t) tmpu8;
d3442 1
a3442 1
      if (target_read_memory (ir.addr, &tmpu8, 1))
d3451 1
a3451 1
      opcode = (uint16_t) tmpu8 | 0x0f00;
d3880 4
a3883 3
      for (tmpu8 = X86_RECORD_REAX_REGNUM; tmpu8 <= X86_RECORD_REDI_REGNUM;
	   tmpu8++)
	I386_RECORD_ARCH_LIST_ADD_REG (tmpu8);
d4031 1
a4031 1
	  tmpu8 = X86_RECORD_ES_REGNUM;
d4034 1
a4034 1
	  tmpu8 = X86_RECORD_SS_REGNUM;
d4037 1
a4037 1
	  tmpu8 = X86_RECORD_DS_REGNUM;
d4040 1
a4040 1
	  tmpu8 = X86_RECORD_FS_REGNUM;
d4043 1
a4043 1
	  tmpu8 = X86_RECORD_GS_REGNUM;
d4051 1
a4051 1
      I386_RECORD_ARCH_LIST_ADD_REG (tmpu8);
d4231 1
a4231 1
	  tmpu8 = X86_RECORD_ES_REGNUM;
d4234 1
a4234 1
	  tmpu8 = X86_RECORD_DS_REGNUM;
d4237 1
a4237 1
	  tmpu8 = X86_RECORD_SS_REGNUM;
d4240 1
a4240 1
	  tmpu8 = X86_RECORD_FS_REGNUM;
d4243 1
a4243 1
	  tmpu8 = X86_RECORD_GS_REGNUM;
d4246 1
a4246 1
      I386_RECORD_ARCH_LIST_ADD_REG (tmpu8);
d5098 1
a5098 1
      if (target_read_memory (ir.addr, &tmpu8, 1))
d5106 1
a5106 1
      opcode = (uint32_t) tmpu8;
d5123 2
a5124 1
	if (target_read_memory (ir.addr, &tmpu8, 1))
d5133 1
a5133 1
	if (tmpu8 != 0x80
d5138 1
a5138 1
			       tmpu8);
@


1.298
log
@Support x86 pseudo byte, word and dword registers.

gdb/

2010-03-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* amd64-tdep.c (amd64_byte_names): New.
	(amd64_word_names): Likewise.
	(amd64_dword_names): Likewise.
	(amd64_pseudo_register_name): Likewise.
	(amd64_pseudo_register_read): Likewise.
	(amd64_pseudo_register_write): Likewise.
	(amd64_init_abi): Set num_byte_regs, num_word_regs, num_dword_regs
	and num_mmx_regs.  Call set_gdbarch_pseudo_register_read,
	set_gdbarch_pseudo_register_write and
	set_tdesc_pseudo_register_name.  Don't call
	set_gdbarch_num_pseudo_regs.  Don't set mm0_regnum.

	* i386-tdep.c (i386_num_mmx_regs): Removed.
	(i386_num_pseudo_regs): Likewise.
	(i386_byte_names): New.
	(i386_word_names): Likewise.
	(i386_byte_regnum_p): Likewise.
	(i386_word_regnum_p): Likewise.
	(i386_mmx_regnum_p): Updated.
	(i386_pseudo_register_name): Make it global.  Handle byte and
	word pseudo-registers.
	(i386_pseudo_register_read): Likewise.
	(i386_pseudo_register_write): Likewise.
	(i386_pseudo_register_type): Handle byte, word and dword
	pseudo-registers
	(i386_register_reggroup_p): Don't include pseudo
	registers, except for MXX, in any register groups.  Don't
	include pseudo byte, word, dword registers in general_reggroup.
	(i386_gdbarch_init): Set num_byte_regs, num_word_regs,
	num_dword_regs, al_regnum, ax_regnum and eax_regnum.  Put MMX
	pseudo-registers after word pseudo-registers.  Call
	set_gdbarch_num_pseudo_regs after calling gdbarch_init_osabi.

	* i386-tdep.h (gdbarch_tdep): Add num_mmx_regs, num_byte_regs,
	al_regnum, num_word_regs, ax_regnum, num_dword_regs and
	eax_regnum.
	(i386_byte_regnum_p): New.
	(i386_word_regnum_p): Likewise.
	(i386_dword_regnum_p): Likewise.
	(i386_pseudo_register_name): Likewise.
	(i386_pseudo_register_read): Likewise.
	(i386_pseudo_register_write): Likewise.

gdb/testsuite/

2010-03-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* gdb.arch/amd64-byte.exp: New.
	* gdb.arch/amd64-dword.exp: Likewise.
	* gdb.arch/amd64-pseudo.c: Likewise.
	* gdb.arch/amd64-word.exp: Likewise.
	* gdb.arch/i386-byte.exp: Likewise.
	* gdb.arch/i386-pseudo.c: Likewise.
	* gdb.arch/i386-word.exp: Likewise.
@
text
@d5391 1
a5391 1
		  addr += 2;
@


1.297
log
@Enable XML target descriptions for x86.

gdb/

2010-03-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* amd64-linux-nat.c (AMD64_LINUX_USER64_CS): New.
	(amd64_linux_read_description): Likewise.
	(_initialize_amd64_linux_nat): Set to_read_description to
	amd64_linux_read_description.

	* amd64-linux-tdep.c: Include "features/i386/amd64-linux.c".
	(amd64_linux_register_name): Removed.
	(amd64_linux_register_type): Likewise.
	(amd64_linux_core_read_description): New.
	(amd64_linux_init_abi): Set target description to
	tdesc_amd64_linux if needed.  Support orig_rax in target
	description.  Don't call set_gdbarch_register_name nor
	set_gdbarch_register_type.  Call
	set_gdbarch_core_read_description.
	(_initialize_amd64_linux_tdep): Call
	initialize_tdesc_amd64_linux.

	* amd64-linux-tdep.h (tdesc_amd64_linux): New.

	* amd64-tdep.c:  Include "features/i386/amd64.c".
	(amd64_register_names): Removed.
	(amd64_register_name): Likewise.
	(amd64_register_type): Likewise.
	(amd64_init_abi):  Set num_core_regs and register_names.  Set
	target description to tdesc_amd64 if needed.  Don't call
	set_gdbarch_register_name nor set_gdbarch_register_type.
	(_initialize_amd64_tdep): New.

	* i386-linux-nat.c (i386_linux_read_description): New.
	(_initialize_i386_linux_nat): Set to_read_description to
	i386_linux_read_description.

	* i386-linux-tdep.c: Include "features/i386/i386-linux.c".
	(i386_linux_register_name): Removed.
	(i386_linux_core_read_description): New.
	(i386_linux_read_description): Likewise.
	(i386_linux_init_abi): Don't call set_gdbarch_register_name.
	Set target description to tdesc_i386_linux if needed.  Support
	orig_eax.  Set register_reggroup_p.  Call
	set_gdbarch_core_read_description.
	(_initialize_i386_linux_tdep): Call initialize_tdesc_i386_linux.

	* i386-linux-tdep.h (tdesc_i386_linux): New.

	* i386-nto-tdep.c (i386nto_regset_id): Replace I386_NUM_FREGS
	with I387_NUM_REGS.

	* i386-tdep.c: Include "features/i386/i386.c".
	(i386_register_names): Make it const.
	(i386_mmx_names): Likewise.
	(i386_num_register_names): Removed.
	(i386_register_name): Likewise.
	(i386_eflags_type): Likewise.
	(i386_mxcsr_type): Likewise.
	(i386_sse_type): Likewise.
	(i386_register_type): Likewise.
	(i387_ext_type): Call tdesc_find_type instead of arch_float_type.
	(i386_pseudo_register_name): New.
	(i386_pseudo_register_type): Likewise.
	(i386_mmx_type): Make it static.
	(i386_gdbarch_init): Check arch.  Replace I386_NUM_FREGS with
	I387_NUM_REGS.  Set num_core_regs and register_names.  Don't
	call set_gdbarch_register_name nor set_gdbarch_register_type.
	Set register_reggroup_p.  Set target description to tdesc_i386
	if needed.  Call set_tdesc_pseudo_register_type,
	set_tdesc_pseudo_register_name and tdesc_use_registers.
	(_initialize_i386_tdep): Call initialize_tdesc_i386.
	initialize_tdesc_x86_64.

	* i386-tdep.h (gdbarch_tdep): Remove i386_eflags_type,
	i386_mxcsr_type and i386_sse_type.  Add num_core_regs,
	register_names, tdesc and register_reggroup_p.
	(I386_NUM_FREGS): Removed.
	(i386_eflags_type): Likewise.
	(i386_mxcsr_type): Likewise.
	(i386_mmx_type): Likewise.
	(i386_sse_type): Likewise.
	(i386_register_name): Likewise.
	(i386_regnum): Add I386_MXCSR_REGNUM.
	(I386_SSE_NUM_REGS): Defined with I386_MXCSR_REGNUM.

	* i387-tdep.h (I387_NUM_REGS): New.

	* regformats/i386/i386-linux.dat: Generated.
	* regformats/i386/i386.dat: Likewise.
	* regformats/i386/amd64-linux.dat: Likewise.
	* regformats/i386/amd64.dat: Likewise.

	* regformats/reg-i386-linux.dat: Removed.
	* regformats/reg-i386.dat: Likewise.
	* regformats/reg-x86-64-linux.dat: Likewise.
	* regformats/reg-x86-64.dat: Likewise.

gdb/gdbserver/

2010-03-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.in (clean): Replace reg-i386.c, reg-x86-64.c,
	reg-i386-linux.c and reg-x86-64-linux.c with i386.c, amd64.c,
	i386-linux.c and amd64-linux.c.
	(reg-i386.o): Removed.
	(reg-i386.c): Likewise.
	(reg-i386-linux.o): Likewise.
	(reg-i386-linux.c): Likewise.
	(reg-x86-64.o): Likewise.
	(reg-x86-64.c): Likewise.
	(reg-x86-64-linux.o): Likewise.
	(reg-x86-64-linux.c): Likewise.
	(i386.o): New.
	(i386.c): Likewise.
	(i386-linux.o): Likewise.
	(i386-linux.c): Likewise.
	(amd64.o): Likewise.
	(amd64.c): Likewise.
	(amd64-linux.o): Likewise.
	(amd64-linux.c): Likewise.

	* configure.srv (srv_i386_regobj): New.
	(srv_i386_linux_regobj): Likewise.
	(srv_amd64_regobj): Likewise.
	(srv_amd64_linux_regobj): Likewise.
	(srv_i386_32bit_xmlfiles): Likewise.
	(srv_i386_64bit_xmlfiles): Likewise.
	(srv_i386_xmlfiles): Likewise.
	(srv_amd64_xmlfiles): Likewise.
	(srv_i386_linux_xmlfiles): Likewise.
	(srv_amd64_linux_xmlfiles): Likewise.
	(i[34567]86-*-cygwin*): Set srv_regobj to $srv_i386_regobj.  Set
	srv_xmlfiles to $srv_i386_xmlfiles.
	(i[34567]86-*-mingw32ce*): Likewise.
	(i[34567]86-*-mingw*): Likewise.
	(i[34567]86-*-nto*): Likewise.
	(i[34567]86-*-linux*): Set srv_regobj to $srv_i386_linux_regobj
	and $srv_amd64_linux_regobj.  Set srv_xmlfiles to
	$srv_i386_linux_xmlfiles and $srv_amd64_linux_xmlfiles.
	(x86_64-*-linux*): Likewise.

	* linux-x86-low.c (init_registers_x86_64_linux): Removed.
	(init_registers_amd64_linux): New.
	(x86_arch_setup): Replace init_registers_x86_64_linux with
	init_registers_amd64_linux.

gdb/testsuite/

2010-03-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* gdb.xml/tdesc-regs.exp (architecture): New.  Set it for x86.
	(load_description): Set architecture if defined.
@
text
@d84 17
a100 1
static const int i386_num_mmx_regs = ARRAY_SIZE (i386_mmx_names);
d105 2
a106 1
  int mm0_regnum = gdbarch_tdep (gdbarch)->mm0_regnum;
d111 39
a149 1
  return (regnum >= mm0_regnum && regnum < mm0_regnum + i386_num_mmx_regs);
d205 1
a205 1
static const char *
d208 9
a216 2
  gdb_assert (i386_mmx_regnum_p (gdbarch, regnum));
  return i386_mmx_names[regnum - I387_MM0_REGNUM (gdbarch_tdep (gdbarch))];
d2234 14
a2247 2
  gdb_assert (i386_mmx_regnum_p (gdbarch, regnum));
  return i386_mmx_type (gdbarch);
d2269 1
a2269 1
static void
d2273 2
a2276 1
      gdb_byte mmx_buf[MAX_REGISTER_SIZE];
d2280 2
a2281 2
      regcache_raw_read (regcache, fpnum, mmx_buf);
      memcpy (buf, mmx_buf, register_size (gdbarch, regnum));
d2284 29
a2312 1
    regcache_raw_read (regcache, regnum, buf);
d2315 1
a2315 1
static void
d2319 2
a2322 1
      gdb_byte mmx_buf[MAX_REGISTER_SIZE];
d2326 1
a2326 1
      regcache_raw_read (regcache, fpnum, mmx_buf);
d2328 1
a2328 1
      memcpy (mmx_buf, buf, register_size (gdbarch, regnum));
d2330 1
a2330 1
      regcache_raw_write (regcache, fpnum, mmx_buf);
d2333 34
a2366 1
    regcache_raw_write (regcache, regnum, buf);
d2803 8
a2810 5
  int sse_regnum_p = (i386_sse_regnum_p (gdbarch, regnum)
		      || i386_mxcsr_regnum_p (gdbarch, regnum));
  int fp_regnum_p = (i386_fp_regnum_p (gdbarch, regnum)
		     || i386_fpc_regnum_p (gdbarch, regnum));
  int mmx_regnum_p = (i386_mmx_regnum_p (gdbarch, regnum));
d2812 9
d2823 3
d2829 4
a2832 1
    return (mmx_regnum_p || sse_regnum_p);
d2835 1
d2837 6
a2842 1
    return (!fp_regnum_p && !mmx_regnum_p && !sse_regnum_p);
d5691 1
a5727 5
  /* The MMX registers are implemented as pseudo-registers.  Put off
     calculating the register number for %mm0 until we know the number
     of raw registers.  */
  tdep->mm0_regnum = 0;

d5850 1
a5850 2
  /* Wire in the MMX registers.  */
  set_gdbarch_num_pseudo_regs (gdbarch, i386_num_mmx_regs);
d5870 5
d5881 7
d5904 22
a5936 5
  /* Unless support for MMX has been disabled, make %mm0 the first
     pseudo-register.  */
  if (tdep->mm0_regnum == 0)
    tdep->mm0_regnum = gdbarch_num_regs (gdbarch);

@


1.296
log
@        * i386-tdep.c (i386_frame_cache): Assume valid anonymous
	functions use a frame pointer.
@
text
@d57 2
d61 1
a61 1
static char *i386_register_names[] =
a75 2
static const int i386_num_register_names = ARRAY_SIZE (i386_register_names);

d78 1
a78 1
static char *i386_mmx_names[] =
d150 2
a151 2
const char *
i386_register_name (struct gdbarch *gdbarch, int regnum)
d153 2
a154 7
  if (i386_mmx_regnum_p (gdbarch, regnum))
    return i386_mmx_names[regnum - I387_MM0_REGNUM (gdbarch_tdep (gdbarch))];

  if (regnum >= 0 && regnum < i386_num_register_names)
    return i386_register_names[regnum];

  return NULL;
a2109 1
/* Construct types for ISA-specific registers.  */
d2111 1
a2111 1
i386_eflags_type (struct gdbarch *gdbarch)
d2115 1
a2115 1
  if (!tdep->i386_eflags_type)
d2117 2
a2118 22
      struct type *type;

      type = arch_flags_type (gdbarch, "builtin_type_i386_eflags", 4);
      append_flags_type_flag (type, 0, "CF");
      append_flags_type_flag (type, 1, NULL);
      append_flags_type_flag (type, 2, "PF");
      append_flags_type_flag (type, 4, "AF");
      append_flags_type_flag (type, 6, "ZF");
      append_flags_type_flag (type, 7, "SF");
      append_flags_type_flag (type, 8, "TF");
      append_flags_type_flag (type, 9, "IF");
      append_flags_type_flag (type, 10, "DF");
      append_flags_type_flag (type, 11, "OF");
      append_flags_type_flag (type, 14, "NT");
      append_flags_type_flag (type, 16, "RF");
      append_flags_type_flag (type, 17, "VM");
      append_flags_type_flag (type, 18, "AC");
      append_flags_type_flag (type, 19, "VIF");
      append_flags_type_flag (type, 20, "VIP");
      append_flags_type_flag (type, 21, "ID");

      tdep->i386_eflags_type = type;
a2120 44
  return tdep->i386_eflags_type;
}

struct type *
i386_mxcsr_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->i386_mxcsr_type)
    {
      struct type *type;

      type = arch_flags_type (gdbarch, "builtin_type_i386_mxcsr", 4);
      append_flags_type_flag (type, 0, "IE");
      append_flags_type_flag (type, 1, "DE");
      append_flags_type_flag (type, 2, "ZE");
      append_flags_type_flag (type, 3, "OE");
      append_flags_type_flag (type, 4, "UE");
      append_flags_type_flag (type, 5, "PE");
      append_flags_type_flag (type, 6, "DAZ");
      append_flags_type_flag (type, 7, "IM");
      append_flags_type_flag (type, 8, "DM");
      append_flags_type_flag (type, 9, "ZM");
      append_flags_type_flag (type, 10, "OM");
      append_flags_type_flag (type, 11, "UM");
      append_flags_type_flag (type, 12, "PM");
      append_flags_type_flag (type, 15, "FZ");

      tdep->i386_mxcsr_type = type;
    }

  return tdep->i386_mxcsr_type;
}

struct type *
i387_ext_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->i387_ext_type)
    tdep->i387_ext_type
      = arch_float_type (gdbarch, -1, "builtin_type_i387_ext",
			 floatformats_i387_ext);

d2125 1
a2125 1
struct type *
a2165 49
struct type *
i386_sse_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->i386_sse_type)
    {
      const struct builtin_type *bt = builtin_type (gdbarch);

      /* The type we're building is this: */
#if 0
      union __gdb_builtin_type_vec128i
      {
        int128_t uint128;
        int64_t v2_int64[2];
        int32_t v4_int32[4];
        int16_t v8_int16[8];
        int8_t v16_int8[16];
        double v2_double[2];
        float v4_float[4];
      };
#endif

      struct type *t;

      t = arch_composite_type (gdbarch,
			       "__gdb_builtin_type_vec128i", TYPE_CODE_UNION);
      append_composite_type_field (t, "v4_float",
				   init_vector_type (bt->builtin_float, 4));
      append_composite_type_field (t, "v2_double",
				   init_vector_type (bt->builtin_double, 2));
      append_composite_type_field (t, "v16_int8",
				   init_vector_type (bt->builtin_int8, 16));
      append_composite_type_field (t, "v8_int16",
				   init_vector_type (bt->builtin_int16, 8));
      append_composite_type_field (t, "v4_int32",
				   init_vector_type (bt->builtin_int32, 4));
      append_composite_type_field (t, "v2_int64",
				   init_vector_type (bt->builtin_int64, 2));
      append_composite_type_field (t, "uint128", bt->builtin_int128);

      TYPE_VECTOR (t) = 1;
      TYPE_NAME (t) = "builtin_type_vec128i";
      tdep->i386_sse_type = t;
    }

  return tdep->i386_sse_type;
}

d2167 1
a2167 2
   register REGNUM.  Perhaps %esi and %edi should go here, but
   potentially they could be used for things other than address.  */
d2170 1
a2170 1
i386_register_type (struct gdbarch *gdbarch, int regnum)
d2172 2
a2173 22
  if (regnum == I386_EIP_REGNUM)
    return builtin_type (gdbarch)->builtin_func_ptr;

  if (regnum == I386_EFLAGS_REGNUM)
    return i386_eflags_type (gdbarch);

  if (regnum == I386_EBP_REGNUM || regnum == I386_ESP_REGNUM)
    return builtin_type (gdbarch)->builtin_data_ptr;

  if (i386_fp_regnum_p (gdbarch, regnum))
    return i387_ext_type (gdbarch);

  if (i386_mmx_regnum_p (gdbarch, regnum))
    return i386_mmx_type (gdbarch);

  if (i386_sse_regnum_p (gdbarch, regnum))
    return i386_sse_type (gdbarch);

  if (regnum == I387_MXCSR_REGNUM (gdbarch_tdep (gdbarch)))
    return i386_mxcsr_type (gdbarch);

  return builtin_type (gdbarch)->builtin_int;
d2624 1
a2624 1
  set_gdbarch_num_regs (gdbarch, I386_NUM_GREGS + I386_NUM_FREGS);
d5486 36
d5528 2
a5596 6
  /* The default ABI includes general-purpose registers, 
     floating-point registers, and the SSE registers.  */
  set_gdbarch_num_regs (gdbarch, I386_SSE_NUM_REGS);
  set_gdbarch_register_name (gdbarch, i386_register_name);
  set_gdbarch_register_type (gdbarch, i386_register_type);

a5666 5
  /* Wire in the MMX registers.  */
  set_gdbarch_num_pseudo_regs (gdbarch, i386_num_mmx_regs);
  set_gdbarch_pseudo_register_read (gdbarch, i386_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, i386_pseudo_register_write);

d5675 1
a5675 1
  set_gdbarch_register_reggroup_p (gdbarch, i386_register_reggroup_p);
d5693 23
d5717 1
d5720 16
d5812 3
@


1.295
log
@	Add fast tracepoints.
	* arch-utils.h (default_fast_tracepoint_valid_at): Declare.
	* arch-utils.c (default_fast_tracepoint_valid_at): New function.
	* breakpoint.h (enum bptype): Add bp_fast_tracepoint.
	* breakpoint.c (tracepoint_type): New function.
	(ALL_TRACEPOINTS): Use it.
	(should_be_inserted): Ditto.
	(bpstat_check_location): Ditto.
	(print_one_breakpoint_location): Ditto.
	(user_settable_breakpoint): Ditto.
	(set_breakpoint_location_function): Ditto.
	(disable_breakpoints_in_shlibs): Ditto.
	(delete_trace_command): Ditto.
	(print_it_typical): Add bp_fast_tracepoint case.
	(bpstat_what): Ditto.
	(print_one_breakpoint_location): Ditto.
	(allocate_bp_location): Ditto.
	(mention): Ditto.
	(breakpoint_re_set_one): Ditto.
	(disable_command): Ditto.
	(enable_command): Ditto.
	(check_fast_tracepoint_sals): New function.
	(break_command_really): Call it.
	(ftrace_command): New function.
	(_initialize_breakpoint): Add ftrace command.
	* gdbarch.sh (fast_tracepoint_valid_at): New.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_fast_tracepoint_valid_at): New function.
	(i386_gdbarch_init): Use it.
	* remote.c (struct remote_state): New field fast_tracepoints.
	(PACKET_FastTracepoints): New packet config type.
	(remote_fast_tracepoint_feature): New function.
	(remote_protocol_features): Add FastTracepoints.
	(remote_supports_fast_tracepoints): New function.
	(_initialize_remote): Add FastTracepoints.
	* tracepoint.c (download_tracepoint): Add fast tracepoint option.
	* NEWS: Mention fast tracepoints.

	* gdb.texinfo (Create and Delete Tracepoints): Describe fast
	tracepoints.
	(Tracepoint Packets): Describe remote protocol for fast
	tracepoints.

	* gdb.trace/tracecmd.exp: Test ftrace.
@
text
@d1398 2
a1399 1
      else
d1401 5
d1410 6
@


1.294
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d46 1
d5571 43
d5816 3
@


1.293
log
@2009-12-16  Michael Snyder  <msnyder@@vmware.com>

	* i386-tdep.c (i386_process_record): Reformat comments.
@
text
@d4 2
a5 2
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
@


1.292
log
@2009-12-10  Michael Snyder  <msnyder@@vmware.com>

	* i386-tdep.c (i386_record_lea_modrm_addr): Indent goto label.
	(i386_process_record): Indent goto label.  Use prefix opcode
	constants from include/opcode/i386.h in switch statement.
@
text
@d3420 1
a3420 2
      /* arith & logic */
    case 0x00:
d3477 1
a3477 2
	      /* OP Ev, Gv */
	    case 0:
d3493 1
a3493 2
	      /* OP Gv, Ev */
	    case 1:
d3501 1
a3501 2
	      /* OP A, Iv */
	    case 2:
d3509 1
a3509 2
      /* GRP1 */
    case 0x80:
d3538 1
a3538 2
      /* inv */
    case 0x40:
d3546 2
a3547 2
      /* dec */
    case 0x48:
d3555 1
d3560 1
a3560 2
      /* GRP3 */
    case 0xf6:
d3574 1
a3574 2
	  /* test */
	case 0:
d3577 2
a3578 4
	  /* not */
	case 2:
	  /* neg */
	case 3:
d3591 1
a3591 2
	  /* neg */
	  if (ir.reg == 3)
d3594 4
a3597 8
	  /* mul */
	case 4:
	  /* imul */
	case 5:
	  /* div */
	case 6:
	  /* idiv */
	case 7:
d3611 2
a3612 4
      /* GRP4 */
    case 0xfe:
      /* GRP5 */
    case 0xff:
d3623 2
a3624 4
	  /* inc */
	case 0:
	  /* dec */
	case 1:
d3643 1
a3643 2
	  /* call */
	case 2:
d3650 1
a3650 2
	  /* lcall */
	case 3:
d3656 2
a3657 4
	  /* jmp */
	case 4:
	  /* ljmp */
	case 5:
d3660 1
a3660 2
	  /* push */
	case 6:
d3674 1
a3674 2
      /* test */
    case 0x84:
d3681 1
a3681 2
      /* CWDE/CBW */
    case 0x98:
d3685 1
a3685 2
      /* CDQ/CWD */
    case 0x99:
d3690 1
a3690 2
      /* imul */
    case 0x0faf:
d3707 1
a3707 2
      /* xadd */
    case 0x0fc0:
d3736 1
a3736 2
      /* cmpxchg */
    case 0x0fb0:
d3761 1
a3761 2
      /* cmpxchg8b */
    case 0x0fc7:
d3777 1
a3777 2
      /* push */
    case 0x50:
d3793 4
a3796 8
      /* push es */
    case 0x06:
      /* push cs */
    case 0x0e:
      /* push ss */
    case 0x16:
      /* push ds */
    case 0x1e:
d3806 2
a3807 4
      /* push fs */
    case 0x0fa0:
      /* push gs */
    case 0x0fa8:
d3817 1
a3817 2
      /* pusha */
    case 0x60:
d3827 1
a3827 2
      /* pop */
    case 0x58:
d3839 1
a3839 2
      /* popa */
    case 0x61:
d3850 1
a3850 2
      /* pop */
    case 0x8f:
d3868 1
a3868 2
      /* enter */
    case 0xc8:
d3876 1
a3876 2
      /* leave */
    case 0xc9:
d3881 1
a3881 2
      /* pop es */
    case 0x07:
d3892 1
a3892 2
      /* pop ss */
    case 0x17:
d3903 1
a3903 2
      /* pop ds */
    case 0x1f:
d3914 1
a3914 2
      /* pop fs */
    case 0x0fa1:
d3920 1
a3920 2
      /* pop gs */
    case 0x0fa9:
d3926 1
a3926 2
      /* mov */
    case 0x88:
d3955 1
a3955 2
      /* mov */
    case 0x8a:
d3969 1
a3969 2
      /* mov seg */
    case 0x8c:
d3989 1
a3989 2
      /* mov seg */
    case 0x8e:
d4019 4
a4022 8
      /* movzbS */
    case 0x0fb6:
      /* movzwS */
    case 0x0fb7:
      /* movsbS */
    case 0x0fbe:
      /* movswS */
    case 0x0fbf:
d4028 1
a4028 2
      /* lea */
    case 0x8d:
d4044 1
a4044 2
      /* mov EAX */
    case 0xa0:
d4046 2
a4047 2
      /* xlat */
    case 0xd7:
d4051 1
a4051 2
      /* mov EAX */
    case 0xa2:
d4110 1
a4110 2
      /* mov R, Ib */
    case 0xb0:
d4123 1
a4123 2
      /* mov R, Iv */
    case 0xb8:
d4134 1
a4134 2
      /* xchg R, EAX */
    case 0x91:
d4145 1
a4145 2
      /* xchg Ev, Gv */
    case 0x86:
d4171 2
a4172 4
      /* les Gv */
    case 0xc4:
      /* lds Gv */
    case 0xc5:
d4178 3
a4180 6
      /* lss Gv */
    case 0x0fb2:
      /* lfs Gv */
    case 0x0fb4:
      /* lgs Gv */
    case 0x0fb5:
d4194 1
a4194 2
	  /* les Gv */
	case 0xc4:
d4197 1
a4197 2
	  /* lds Gv */
	case 0xc5:
d4200 1
a4200 2
	  /* lss Gv */
	case 0x0fb2:
d4203 1
a4203 2
	  /* lfs Gv */
	case 0x0fb4:
d4206 1
a4206 2
	  /* lgs Gv */
	case 0x0fb5:
d4215 1
a4215 2
      /* shifts */
    case 0xc0:
d4260 1
a4260 2
    /* Floats.  */
    case 0xd8:
d4705 1
a4705 2
      /* movsS */
    case 0xa4:
d4707 1
a4707 2
      /* stosS */
    case 0xaa:
d4709 1
a4709 2
      /* insS */
    case 0x6c:
d4756 1
a4756 2
      /* cmpsS */
    case 0xa6:
d4765 1
a4765 2
      /* lodsS */
    case 0xac:
d4774 1
a4774 2
      /* scasS */
    case 0xae:
d4782 1
a4782 2
      /* outsS */
    case 0x6e:
d4790 1
a4790 2
      /* port I/O */
    case 0xe4:
d4805 2
a4806 4
      /* ret im */
    case 0xc2:
      /* ret */
    case 0xc3:
d4811 3
a4813 6
      /* lret im */
    case 0xca:
      /* lret */
    case 0xcb:
      /* iret */
    case 0xcf:
d4819 1
a4819 2
      /* call im */
    case 0xe8:
d4826 1
a4826 2
      /* lcall im */
    case 0x9a:
d4837 4
a4840 8
      /* jmp im */
    case 0xe9:
      /* ljmp im */
    case 0xea:
      /* jmp Jb */
    case 0xeb:
      /* jcc Jb */
    case 0x70:
d4856 1
a4856 2
      /* jcc Jv */
    case 0x0f80:
d4874 1
a4874 2
      /* setcc Gv */
    case 0x0f90:
d4904 1
a4904 2
      /* cmov Gv, Ev */
    case 0x0f40:
d4929 1
a4929 2
      /* pushf */
    case 0x9c:
d4937 1
a4937 2
      /* popf */
    case 0x9d:
d4942 1
a4942 2
      /* sahf */
    case 0x9e:
d4948 5
a4952 10
      /* cmc */
    case 0xf5:
      /* clc */
    case 0xf8:
      /* stc */
    case 0xf9:
      /* cld */
    case 0xfc:
      /* std */
    case 0xfd:
d4956 1
a4956 2
      /* lahf */
    case 0x9f:
d4967 1
a4967 2
      /* bt/bts/btr/btc Gv, im */
    case 0x0fba:
d4990 1
a4990 2
      /* bt Gv, Ev */
    case 0x0fa3:
d4994 3
a4996 6
      /* bts */
    case 0x0fab:
      /* btr */
    case 0x0fb3:
      /* btc */
    case 0x0fbb:
d5030 2
a5031 4
      /* bsf */
    case 0x0fbc:
      /* bsr */
    case 0x0fbd:
d5037 6
a5042 12
      /* daa */
    case 0x27:
      /* das */
    case 0x2f:
      /* aaa */
    case 0x37:
      /* aas */
    case 0x3f:
      /* aam */
    case 0xd4:
      /* aad */
    case 0xd5:
d5053 1
a5053 2
      /* nop */
    case 0x90:
d5061 1
a5061 2
      /* fwait */
    case 0x9b:
a5074 1
      /* int3 */
d5076 1
a5076 1
    case 0xcc:
a5082 1
      /* int */
d5084 1
a5084 1
    case 0xcd:
a5110 1
      /* into */
d5112 1
a5112 1
    case 0xce:
d5119 2
a5120 4
      /* cli */
    case 0xfa:
      /* sti */
    case 0xfb:
d5123 1
a5123 2
      /* bound */
    case 0x62:
d5130 1
a5130 2
      /* bswap reg */
    case 0x0fc8:
d5141 1
a5141 2
      /* salc */
    case 0xd6:
d5151 4
a5154 8
      /* loopnz */
    case 0xe0:
      /* loopz */
    case 0xe1:
      /* loop */
    case 0xe2:
      /* jecxz */
    case 0xe3:
d5159 1
a5159 2
      /* wrmsr */
    case 0x0f30:
d5166 1
a5166 2
      /* rdmsr */
    case 0x0f32:
d5173 1
a5173 2
      /* rdtsc */
    case 0x0f31:
d5180 1
a5180 2
      /* sysenter */
    case 0x0f34:
d5201 1
a5201 2
      /* sysexit */
    case 0x0f35:
d5208 1
a5208 2
      /* syscall */
    case 0x0f05:
d5224 1
a5224 2
      /* sysret */
    case 0x0f07:
d5231 1
a5231 2
      /* cpuid */
    case 0x0fa2:
d5238 1
a5238 2
      /* hlt */
    case 0xf4:
d5250 2
a5251 4
	  /* sldt */
	case 0:
	  /* str */
	case 1:
d5261 2
a5262 4
	  /* lldt */
	case 2:
	  /* ltr */
	case 3:
d5264 2
a5265 4
	  /* verr */
	case 4:
	  /* verw */
	case 5:
d5281 1
a5281 2
	  /* sgdt */
	case 0:
d5325 1
a5325 2
		  /* monitor */
		case 0:
d5327 1
a5327 2
		  /* mwait */
		case 1:
d5371 1
a5371 2
	  /* lgdt */
	case 2:
d5385 1
a5385 2
	  /* lidt */
	case 3:
d5393 1
a5393 2
	  /* smsw */
	case 4:
d5407 1
a5407 2
	  /* lmsw */
	case 6:
d5410 1
a5410 2
	  /* invlpg */
	case 7:
d5433 2
a5434 4
      /* invd */
    case 0x0f08:
      /* wbinvd */
    case 0x0f09:
d5437 1
a5437 2
      /* arpl */
    case 0x63:
d5455 2
a5456 4
      /* lar */
    case 0x0f02:
      /* lsl */
    case 0x0f03:
a5473 1
      /* nop (multi byte) */
d5481 1
d5484 2
a5485 4
      /* mov reg, crN */
    case 0x0f20:
      /* mov crN, reg */
    case 0x0f22:
d5514 2
a5515 4
      /* mov reg, drN */
    case 0x0f21:
      /* mov drN, reg */
    case 0x0f23:
d5531 1
a5531 2
      /* clts */
    case 0x0f06:
@


1.291
log
@2009-12-10  Oza Pawandeep <paawan1982@@yahoo.com>

	* i386-tdep.c:  Support for floating point recording.
	Records and Replay the i386 floating point registers,
	of i387 FPU.
	(i386_record_floats): New function.
	(i386_process_record): Implement FP insns.
@
text
@d3147 1
a3147 1
no_rm:
d3318 1
a3318 1
      switch (tmpu8)
d3320 1
a3320 1
	case 0xf3:
d3323 1
a3323 1
	case 0xf2:
d3326 1
a3326 1
	case 0xf0:
d3329 1
a3329 1
	case 0x2e:
d3332 1
a3332 1
	case 0x36:
d3335 1
a3335 1
	case 0x3e:
d3338 1
a3338 1
	case 0x26:
d3341 1
a3341 1
	case 0x64:
d3344 1
a3344 1
	case 0x65:
d3347 1
a3347 1
	case 0x66:
d3350 1
a3350 1
	case 0x67:
d3386 1
a3386 1
out_prefixes:
d3403 1
a3403 1
reswitch:
d5720 1
a5720 1
no_support:
@


1.290
log
@2009-10-12  Jiang Jilin  <freephp@@gmail.com>

	* i386-tdep.c (i386_process_record): Add xgetbv/xsetbv
	instructions support.
@
text
@d3199 68
d3285 1
d4334 1
a4334 2
      /* floats */
      /* It just record the memory change of instrcution. */
d4348 1
a4348 1
	  /* memory */
a4354 2
	    case 0x00:
	    case 0x01:
d4356 5
d4362 9
a4376 2
	    case 0x12:
	    case 0x13:
a4382 2
	    case 0x22:
	    case 0x23:
a4388 2
	    case 0x32:
	    case 0x33:
d4393 5
d4406 1
d4415 2
d4420 3
d4436 1
d4447 10
d4460 9
d4473 7
d4482 8
d4499 5
d4505 4
a4508 1
	    case 0x1d:
d4510 4
a4513 2
	    case 0x3c:
	    case 0x3d:
d4531 3
d4555 4
d4563 3
d4574 204
a4778 1

a5181 1
      /* XXX */
d5183 11
a5193 4
      printf_unfiltered (_("Process record doesn't support instruction "
			   "fwait.\n"));
      ir.addr -= 1;
      goto no_support;
@


1.289
log
@*** empty log message ***
@
text
@d5175 13
@


1.288
log
@2009-09-28  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c (i386_process_record): Remove "0x" that
	don't need.
@
text
@d4149 1
a4149 1
	  ir.rm != ir.rex_b;
@


1.287
log
@2009-09-06  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c (i386_record_check_override): Deleted.
	(i386_record_lea_modrm): Ditto.
	(i386_process_record): Ditto.
@
text
@d4046 1
a4046 1
                     "of instruction at address 0x%s because "
d4471 1
a4471 1
                         "change of instruction at address 0x%s "
@


1.287.2.1
log
@2009-09-28  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c (i386_process_record): Remove "0x" that
	don't need.
@
text
@d4046 1
a4046 1
                     "of instruction at address %s because "
d4471 1
a4471 1
                         "change of instruction at address %s "
@


1.286
log
@2009-09-05  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c (i386_record_s): Add orig_addr.
	(i386_record_check_override): New function.
	(i386_record_lea_modrm): Call i386_record_check_override.
	(i386_process_record): Ditto.
@
text
@a3150 20
static int
i386_record_check_override (struct i386_record_s *irp)
{
  if (irp->override >= 0 && irp->override != X86_RECORD_DS_REGNUM)
    {
      ULONGEST orv, ds;

      regcache_raw_read_unsigned (irp->regcache,
                                  irp->regmap[irp->override],
                                  &orv);
      regcache_raw_read_unsigned (irp->regcache,
                                  irp->regmap[X86_RECORD_DS_REGNUM],
                                  &ds);
      if (orv != ds)
        return 1;
    }

  return 0;
}

d3161 1
a3161 1
  if (i386_record_check_override (irp))
d4043 1
a4043 1
      if (i386_record_check_override (&ir))
d4461 7
a4467 2
          ir.override = X86_RECORD_ES_REGNUM;
          if (ir.aflag && i386_record_check_override (&ir))
d5091 1
a5091 1
	    if (i386_record_check_override (&ir))
d5142 1
a5142 1
	      if (i386_record_check_override (&ir))
@


1.285
log
@2009-08-29  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c (i386_process_record): Fix the error of string
	ops instructions's handler.
@
text
@d2870 1
d3151 20
d3181 1
a3181 1
  if (irp->override >= 0)
d3183 4
a3186 5
      if (record_debug)
	printf_unfiltered (_("Process record ignores the memory change "
			     "of instruction at address %s because it "
			     "can't get the value of the segment register.\n"),
			   paddress (gdbarch, irp->addr));
d3244 1
d4063 1
a4063 1
      if (ir.override >= 0)
d4065 5
a4069 6
	  if (record_debug)
	    printf_unfiltered (_("Process record ignores the memory change "
				 "of instruction at address 0x%s because "
				 "it can't get the value of the segment "
				 "register.\n"),
			       paddress (gdbarch, ir.addr));
d4481 2
a4482 7
          regcache_raw_read_unsigned (ir.regcache,
                                      ir.regmap[X86_RECORD_ES_REGNUM],
                                      &es);
          regcache_raw_read_unsigned (ir.regcache,
                                      ir.regmap[X86_RECORD_DS_REGNUM],
                                      &ds);
          if (ir.aflag && (es != ds))
d4485 10
a4494 6
              if (record_debug)
                printf_unfiltered (_("Process record ignores the memory "
				     "change of instruction at address 0x%s "
				     "because it can't get the value of the "
				     "ES segment register.\n"),
                                   paddress (gdbarch, ir.addr));
a4498 2
          if (record_arch_list_add_mem (tmpulongest, 1 << ir.ot))
            return -1;
d5106 1
a5106 1
	    if (ir.override >= 0)
d5108 6
a5113 7
		if (record_debug)
		  printf_unfiltered (_("Process record ignores the memory "
				       "change of instruction at "
				       "address %s because it can't get "
				       "the value of the segment "
				       "register.\n"),
				     paddress (gdbarch, ir.addr));
d5157 1
a5157 1
	      if (ir.override >= 0)
d5159 6
a5164 7
		  if (record_debug)
		    printf_unfiltered (_("Process record ignores the memory "
					 "change of instruction at "
					 "address %s because it can't get "
					 "the value of the segment "
					 "register.\n"),
				       paddress (gdbarch, ir.addr));
@


1.284
log
@2009-08-22  Michael Snyder  <msnyder@@vmware.com>

	* i386-tdep.c (i386_process_record): Break out of prefix loop
	if not amd64.  Otherwise inc/dec instructions are lost.
@
text
@a4445 4
      if ((opcode & 1) == 0)
	ir.ot = OT_BYTE;
      else
	ir.ot = ir.dflag + OT_WORD;
d4447 1
a4447 1
                                  ir.regmap[X86_RECORD_REDI_REGNUM],
d4449 1
a4449 1
      if (!ir.aflag)
d4451 6
a4456 12
          tmpulongest &= 0xffff;
          /* addr += ((uint32_t) read_register (I386_ES_REGNUM)) << 4; */
          if (record_debug)
            printf_unfiltered (_("Process record ignores the memory change "
                                 "of instruction at address 0x%s because "
                                 "it can't get the value of the segment "
                                 "register.\n"),
                               paddress (gdbarch, ir.addr));
        }
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
        {
          ULONGEST count, eflags;
d4459 5
a4463 3
                                      &count);
          if (!ir.aflag)
            count &= 0xffff;
d4465 15
a4479 10
                                      ir.regmap[X86_RECORD_EFLAGS_REGNUM],
                                      &eflags);
          if ((eflags >> 10) & 0x1)
            tmpulongest -= (count - 1) * (1 << ir.ot);
          if (record_arch_list_add_mem (tmpulongest, count * (1 << ir.ot)))
            return -1;
          I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);
        }
      else
        {
d4482 5
a4486 5
        }
      if (opcode == 0xa4 || opcode == 0xa5)
        I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_REDI_REGNUM);
      I386_RECORD_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);
@


1.283
log
@2009-08-10  Hui Zhu  <teawater@@gmail.com>

	Add AMD64 process record instruction set support.

	* i386-tdep.h (gdbarch_tdep): Add record_regmap for registers
	because the AMD64's registers order in GDB is not same with
	I386 instructions.
	Add i386_syscall_record to be the syscall function handle
	interface.
	(record_i386_regnum): Number for record_regmap.
	* i386-tdep.c (OT_QUAD): For 64 bits.
	(i386_record_s): Add rex_x, rex_b, rip_offset and
	popl_esp_hack for AMD64 instruction set. And regmap for
	record_regmap.
	(i386_record_lea_modrm_addr): Support AMD64 instruction set
	64 bits lea.
	(i386_record_lea_modrm): Ditto.
	(i386_record_push): New function.  Record the execution log
	of push.
	(I386_RECORD_ARCH_LIST_ADD_REG): New macro to record the
	register.
	(i386_process_record): Support AMD64 instruction set.
	* amd64-tdep.c (amd64_record_regmap): For record_regmap.
	(amd64_init_abi): Set amd64_record_regmap to record_regmap.
@
text
@d3283 17
a3299 17
        case 0x40:
        case 0x41:
        case 0x42:
        case 0x43:
        case 0x44:
        case 0x45:
        case 0x46:
        case 0x47:
        case 0x48:
        case 0x49:
        case 0x4a:
        case 0x4b:
        case 0x4c:
        case 0x4d:
        case 0x4e:
        case 0x4f:
          if (ir.regmap[X86_RECORD_R8_REGNUM])
d3308 2
@


1.282
log
@2009-07-12  Michael Snyder  <msnyder@@vmware.com>

	* i386-tdep.c: Add a frame unwinder for function epilogues.
	(i386_in_function_epilogue_p): New function.
	(i386_epilogue_frame_sniffer): New function.
	(i386_epilogue_frame_cache): New function.
	(i386_epilogue_frame_this_id): New function.
	(i386_epilogue_frame_unwind): New struct frame_unwind.
	(i386_gdbarch_init): Hook the new unwinder.
@
text
@d2850 1
d2868 1
d2877 5
d2890 1
a2890 1
  struct gdbarch *gdbarch = get_regcache_arch (irp->regcache);
d2913 1
a2913 1
i386_record_lea_modrm_addr (struct i386_record_s *irp, uint32_t * addr)
d2915 1
a2915 1
  struct gdbarch *gdbarch = get_regcache_arch (irp->regcache);
d2917 3
a2919 2
  uint16_t tmpu16;
  uint32_t tmpu32;
d2943 1
a2943 1
	  index = ((tmpu8 >> 3) & 7);
d2946 1
d2954 1
a2954 1
	      if (target_read_memory (irp->addr, (gdb_byte *) addr, 4))
d2963 3
d2985 1
a2985 1
	  if (target_read_memory (irp->addr, (gdb_byte *) addr, 4))
d2993 1
d2998 1
d3000 12
a3011 4
	{
	  regcache_raw_read (irp->regcache, base, (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	}
a3012 1
      /* XXX: index == 4 is always invalid */
d3015 6
a3020 2
	  regcache_raw_read (irp->regcache, index, (gdb_byte *) & tmpu32);
	  *addr += tmpu32 << scale;
d3032 1
a3032 1
		  (irp->addr, (gdb_byte *) & tmpu16, 2))
d3041 1
a3041 1
	      *addr = (int16_t) tmpu16;
d3063 1
a3063 1
	  if (target_read_memory (irp->addr, (gdb_byte *) & tmpu16, 2))
d3072 1
a3072 1
	  *addr = (int16_t) tmpu16;
d3079 8
a3086 6
	  regcache_raw_read (irp->regcache, I386_EBX_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (irp->regcache, I386_ESI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
d3089 8
a3096 6
	  regcache_raw_read (irp->regcache, I386_EBX_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (irp->regcache, I386_EDI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
d3099 8
a3106 6
	  regcache_raw_read (irp->regcache, I386_EBP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (irp->regcache, I386_ESI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
d3109 8
a3116 6
	  regcache_raw_read (irp->regcache, I386_EBP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (irp->regcache, I386_EDI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
d3119 4
a3122 3
	  regcache_raw_read (irp->regcache, I386_ESI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
d3125 4
a3128 3
	  regcache_raw_read (irp->regcache, I386_EDI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
d3131 4
a3134 3
	  regcache_raw_read (irp->regcache, I386_EBP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
d3137 4
a3140 3
	  regcache_raw_read (irp->regcache, I386_EBX_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
d3157 2
a3158 2
  struct gdbarch *gdbarch = get_regcache_arch (irp->regcache);
  uint32_t addr;
d3160 1
a3160 1
  if (irp->override)
d3179 20
d3203 3
d3214 1
d3217 3
d3226 4
d3260 1
a3260 1
	  ir.override = I386_CS_REGNUM;
d3263 1
a3263 1
	  ir.override = I386_SS_REGNUM;
d3266 1
a3266 1
	  ir.override = I386_DS_REGNUM;
d3269 1
a3269 1
	  ir.override = I386_ES_REGNUM;
d3272 1
a3272 1
	  ir.override = I386_FS_REGNUM;
d3275 1
a3275 1
	  ir.override = I386_GS_REGNUM;
d3283 26
d3315 9
a3323 2
  if (prefixes & PREFIX_DATA)
    ir.dflag ^= 1;
d3326 2
d3417 2
a3418 1
		  if (ir.ot == OT_BYTE)
d3420 1
a3420 2
		  if (record_arch_list_add_reg (ir.regcache, ir.rm))
		    return -1;
d3427 2
a3428 1
	      if (ir.ot == OT_BYTE)
d3430 1
a3430 2
	      if (record_arch_list_add_reg (ir.regcache, ir.reg))
		return -1;
d3434 1
a3434 2
	      if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
		return -1;
d3438 1
a3438 2
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d3458 4
d3466 1
a3466 4
	    {
	      if (record_arch_list_add_reg (ir.regcache, ir.rm))
		return -1;
	    }
d3468 1
a3468 2
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d3489 2
a3490 4
      if (record_arch_list_add_reg (ir.regcache, opcode & 7))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d3503 3
d3510 1
a3510 2
	  if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	    return -1;
a3513 13
	  if (ir.mod != 3)
	    {
	      if (i386_record_lea_modrm (&ir))
		return -1;
	    }
	  else
	    {
	      if (ir.ot == OT_BYTE)
		ir.rm &= 0x3;
	      if (record_arch_list_add_reg (ir.regcache, ir.rm))
		return -1;
	    }
	  break;
d3523 2
a3524 1
	      if (ir.ot == OT_BYTE)
d3526 1
a3526 2
	      if (record_arch_list_add_reg (ir.regcache, ir.rm))
		return -1;
d3528 3
a3530 2
	  if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	    return -1;
d3540 1
a3540 2
	  if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
	    return -1;
d3542 2
a3543 6
	    {
	      if (record_arch_list_add_reg (ir.regcache, I386_EDX_REGNUM))
		return -1;
	    }
	  if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	    return -1;
a3556 4
      if ((opcode & 1) == 0)
	ir.ot = OT_BYTE;
      else
	ir.ot = ir.dflag + OT_WORD;
a3564 1

d3571 4
d3582 2
a3583 1
	      if (ir.ot == OT_BYTE)
d3585 1
a3585 2
	      if (record_arch_list_add_reg (ir.regcache, ir.rm))
		return -1;
d3587 1
a3587 2
	  if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	    return -1;
d3591 3
a3593 8
	  /* push */
	case 6:
	  if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	    return -1;
	  regcache_raw_read (ir.regcache, I386_ESP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem
	      ((CORE_ADDR) tmpu32 - (1 << (ir.dflag + 1)), (1 << (ir.dflag + 1))))
d3595 1
d3599 2
a3600 8
	  if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	    return -1;
	  if (record_arch_list_add_reg (ir.regcache, I386_CS_REGNUM))
	    return -1;
	  regcache_raw_read (ir.regcache, I386_ESP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem
	      ((CORE_ADDR) tmpu32 - (1 << (ir.dflag + 2)), (1 << (ir.dflag + 2))))
d3602 1
d3608 8
d3630 1
a3630 2
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d3635 1
a3635 2
      if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
	return -1;
d3640 2
a3641 4
      if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_EDX_REGNUM))
	return -1;
d3651 6
a3656 1
      if (ir.ot == OT_BYTE)
d3658 2
a3659 4
      if (record_arch_list_add_reg (ir.regcache, ir.reg))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d3671 1
d3674 1
a3674 1
	  if (ir.ot == OT_BYTE)
d3676 2
a3677 3
	  if (record_arch_list_add_reg (ir.regcache, ir.reg))
	    return -1;
	  if (ir.ot == OT_BYTE)
d3679 1
a3679 2
	  if (record_arch_list_add_reg (ir.regcache, ir.rm))
	    return -1;
d3685 1
a3685 1
	  if (ir.ot == OT_BYTE)
d3687 1
a3687 2
	  if (record_arch_list_add_reg (ir.regcache, ir.reg))
	    return -1;
d3689 1
a3689 2
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d3703 3
a3705 3
	  if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
	    return -1;
	  if (ir.ot == OT_BYTE)
d3707 1
a3707 2
	  if (record_arch_list_add_reg (ir.regcache, ir.reg))
	    return -1;
d3711 1
a3711 2
	  if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
	    return -1;
d3715 1
a3715 2
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d3728 2
a3729 4
      if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_EDX_REGNUM))
	return -1;
d3732 1
a3732 2
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d3746 6
d3760 9
d3773 6
a3778 1
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
d3780 10
a3789 4
      regcache_raw_read (ir.regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (ir.dflag + 1)), (1 << (ir.dflag + 1))))
d3802 2
a3803 18
      ir.ot = ir.dflag + OT_WORD;
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      if (ir.ot == OT_BYTE)
	opcode &= 0x3;
      if (record_arch_list_add_reg (ir.regcache, opcode & 0x7))
	return -1;
      break;

      /* pusha */
    case 0x60:
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      regcache_raw_read (ir.regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (ir.dflag + 4)), (1 << (ir.dflag + 4))))
	return -1;
d3808 4
a3811 4
      for (tmpu8 = I386_EAX_REGNUM; tmpu8 <= I386_EDI_REGNUM; tmpu8++)
	{
	  if (record_arch_list_add_reg (ir.regcache, tmpu8))
	    return -1;
d3813 3
d3820 4
a3823 1
      ir.ot = ir.dflag + OT_WORD;
d3827 1
a3827 4
	{
	  if (record_arch_list_add_reg (ir.regcache, ir.rm))
	    return -1;
	}
d3830 1
d3834 1
a3834 2
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
d3839 4
a3842 8
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_EBP_REGNUM))
	return -1;
      regcache_raw_read (ir.regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (ir.dflag + 1)), (1 << (ir.dflag + 1))))
d3848 2
a3849 4
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_EBP_REGNUM))
	return -1;
d3854 8
a3861 4
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_ES_REGNUM))
	return -1;
d3866 8
a3873 4
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_SS_REGNUM))
	return -1;
d3878 8
a3885 4
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_DS_REGNUM))
	return -1;
d3890 3
a3892 4
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_FS_REGNUM))
	return -1;
d3897 3
a3899 4
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_GS_REGNUM))
	return -1;
d3917 2
d3924 3
a3926 1
	  if (ir.ot == OT_BYTE)
d3928 1
a3928 2
	  if (record_arch_list_add_reg (ir.regcache, ir.rm))
	    return -1;
a3929 2
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d3931 1
a3938 1

d3941 5
d3947 3
a3949 3
      if (ir.ot == OT_BYTE)
	ir.reg &= 0x3;
      if (record_arch_list_add_reg (ir.regcache, ir.reg))
d3951 6
d3958 8
a3965 2
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
a3971 1

d3975 1
a3975 1
	  tmpu8 = I386_ES_REGNUM;
d3978 1
a3978 1
	  tmpu8 = I386_SS_REGNUM;
d3981 1
a3981 1
	  tmpu8 = I386_DS_REGNUM;
d3984 1
a3984 1
	  tmpu8 = I386_FS_REGNUM;
d3987 1
a3987 1
	  tmpu8 = I386_GS_REGNUM;
d3995 2
a3996 32
      if (record_arch_list_add_reg (ir.regcache, tmpu8))
	return -1;

      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
      break;

      /* mov seg */
    case 0x8c:
      if (i386_record_modrm (&ir))
	return -1;
      if (ir.reg > 5)
	{
	  ir.addr -= 2;
	  opcode = opcode << 8 | ir.modrm;
	  goto no_support;
	}

      if (ir.mod == 3)
	{
	  if (record_arch_list_add_reg (ir.regcache, ir.rm))
	    return -1;
	}
      else
	{
	  ir.ot = OT_WORD;
	  if (i386_record_lea_modrm (&ir))
	    return -1;
	}

      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d4009 1
a4009 2
      if (record_arch_list_add_reg (ir.regcache, ir.reg))
	return -1;
a4021 1

d4023 2
a4024 1
      if (ir.ot == OT_BYTE)
d4026 1
a4026 2
      if (record_arch_list_add_reg (ir.regcache, ir.reg))
	return -1;
d4034 1
a4034 2
      if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
	return -1;
d4040 56
a4095 49
      {
	uint32_t addr;

	if (ir.override)
	  {
	    if (record_debug)
	      printf_unfiltered (_("Process record ignores the memory change "
				   "of instruction at address %s because "
				   "it can't get the value of the segment "
				   "register.\n"),
				 paddress (gdbarch, ir.addr));
	  }
	else
	  {
	    if ((opcode & 1) == 0)
	      ir.ot = OT_BYTE;
	    else
	      ir.ot = ir.dflag + OT_WORD;
	    if (ir.aflag)
	      {
		if (target_read_memory
		    (ir.addr, (gdb_byte *) & addr, 4))
		  {
		    if (record_debug)
		      printf_unfiltered (_("Process record: error reading "
					   "memory at addr %s len = 4.\n"),
					 paddress (gdbarch, ir.addr));
		    return -1;
		  }
		ir.addr += 4;
	      }
	    else
	      {
		if (target_read_memory
		    (ir.addr, (gdb_byte *) & tmpu16, 4))
		  {
		    if (record_debug)
		      printf_unfiltered (_("Process record: error reading "
					   "memory at addr %s len = 4.\n"),
					 paddress (gdbarch, ir.addr));
		    return -1;
		  }
		ir.addr += 2;
		addr = tmpu16;
	      }
	    if (record_arch_list_add_mem (addr, 1 << ir.ot))
	      return -1;
	  }
      }
d4107 3
a4109 2
      if (record_arch_list_add_reg (ir.regcache, (opcode & 0x7) & 0x3))
	return -1;
d4121 1
a4121 2
      if (record_arch_list_add_reg (ir.regcache, opcode & 0x7))
	return -1;
d4132 2
a4133 4
      if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, opcode & 0x7))
	return -1;
a4142 1

a4144 1

d4147 2
a4148 1
	  if (ir.ot == OT_BYTE)
d4150 1
a4150 2
	  if (record_arch_list_add_reg (ir.regcache, ir.rm))
	    return -1;
d4157 2
a4158 2

      if (ir.ot == OT_BYTE)
d4160 1
a4160 2
      if (record_arch_list_add_reg (ir.regcache, ir.reg))
	return -1;
d4167 5
a4188 1

d4193 1
a4193 1
	  tmpu8 = I386_ES_REGNUM;
d4197 1
a4197 1
	  tmpu8 = I386_DS_REGNUM;
d4201 1
a4201 1
	  tmpu8 = I386_SS_REGNUM;
d4205 1
a4205 1
	  tmpu8 = I386_FS_REGNUM;
d4209 1
a4209 1
	  tmpu8 = I386_GS_REGNUM;
d4212 3
a4214 5
      if (record_arch_list_add_reg (ir.regcache, tmpu8))
	return -1;

      if (record_arch_list_add_reg (ir.regcache, ir.reg))
	return -1;
a4227 1

a4229 1

d4237 2
a4238 1
	  if (ir.ot == OT_BYTE)
d4240 1
a4240 2
	  if (record_arch_list_add_reg (ir.regcache, ir.rm))
	    return -1;
d4242 1
a4242 3

      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d4279 1
a4279 1
	  uint32_t addr;
d4281 1
a4281 1
	  if (i386_record_lea_modrm_addr (&ir, &addr))
d4341 1
a4341 1
		      if (record_arch_list_add_mem (addr, 4))
d4345 1
a4345 1
		      if (record_arch_list_add_mem (addr, 8))
d4350 1
a4350 1
		      if (record_arch_list_add_mem (addr, 2))
d4360 1
a4360 1
		      if (record_arch_list_add_mem (addr, 4))
d4364 1
a4364 1
		      if (record_arch_list_add_mem (addr, 8))
d4369 1
a4369 1
		      if (record_arch_list_add_mem (addr, 2))
d4386 1
a4386 1
		  if (record_arch_list_add_mem (addr, 28))
d4391 1
a4391 1
		  if (record_arch_list_add_mem (addr, 14))
d4397 1
a4397 1
	      if (record_arch_list_add_mem (addr, 2))
d4402 1
a4402 1
	      if (record_arch_list_add_mem (addr, 10))
d4408 1
a4408 1
		  if (record_arch_list_add_mem (addr, 28))
d4410 1
a4410 1
		  addr += 28;
d4414 1
a4414 1
		  if (record_arch_list_add_mem (addr, 14))
d4416 1
a4416 1
		  addr += 14;
d4418 1
a4418 1
	      if (record_arch_list_add_mem (addr, 80))
d4422 1
a4422 1
	      if (record_arch_list_add_mem (addr, 8))
d4444 45
a4488 2
      {
	uint32_t addr;
d4490 8
a4497 58
	if ((opcode & 1) == 0)
	  ir.ot = OT_BYTE;
	else
	  ir.ot = ir.dflag + OT_WORD;
	if (opcode == 0xa4 || opcode == 0xa5)
	  {
	    if (record_arch_list_add_reg (ir.regcache, I386_ESI_REGNUM))
	      return -1;
	  }
	if (record_arch_list_add_reg (ir.regcache, I386_EDI_REGNUM))
	  return -1;

	regcache_raw_read (ir.regcache, I386_EDI_REGNUM,
			   (gdb_byte *) & addr);
	if (!ir.aflag)
	  {
	    addr &= 0xffff;
	    /* addr += ((uint32_t)read_register (I386_ES_REGNUM)) << 4; */
	    if (record_debug)
	      printf_unfiltered (_("Process record ignores the memory change "
				   "of instruction at address %s because "
				   "it can't get the value of the segment "
				   "register.\n"),
				 paddress (gdbarch, ir.addr));
	  }

	if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	  {
	    uint32_t count;

	    regcache_raw_read (ir.regcache, I386_ECX_REGNUM,
			       (gdb_byte *) & count);
	    if (!ir.aflag)
	      count &= 0xffff;

	    regcache_raw_read (ir.regcache, I386_EFLAGS_REGNUM,
			       (gdb_byte *) & tmpu32);
	    if ((tmpu32 >> 10) & 0x1)
	      addr -= (count - 1) * (1 << ir.ot);

	    if (ir.aflag)
	      {
		if (record_arch_list_add_mem (addr, count * (1 << ir.ot)))
		  return -1;
	      }

	    if (record_arch_list_add_reg (ir.regcache, I386_ECX_REGNUM))
	      return -1;
	  }
	else
	  {
	    if (ir.aflag)
	      {
		if (record_arch_list_add_mem (addr, 1 << ir.ot))
		  return -1;
	      }
	  }
      }
d4503 2
a4504 4
      if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_ESI_REGNUM))
	return -1;
d4506 2
a4507 16
	{
	  if (record_arch_list_add_reg (ir.regcache, I386_ECX_REGNUM))
	    return -1;
	}
      break;

      /* outsS */
    case 0x6e:
    case 0x6f:
      if (record_arch_list_add_reg (ir.regcache, I386_ESI_REGNUM))
	return -1;
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	{
	  if (record_arch_list_add_reg (ir.regcache, I386_ECX_REGNUM))
	    return -1;
	}
d4513 1
a4513 2
      if (record_arch_list_add_reg (ir.regcache, I386_EDI_REGNUM))
	return -1;
d4515 2
a4516 6
	{
	  if (record_arch_list_add_reg (ir.regcache, I386_ECX_REGNUM))
	    return -1;
	}
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d4519 4
a4522 7
      /* cmpsS */
    case 0xa6:
    case 0xa7:
      if (record_arch_list_add_reg (ir.regcache, I386_EDI_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_ESI_REGNUM))
	return -1;
d4524 2
a4525 6
	{
	  if (record_arch_list_add_reg (ir.regcache, I386_ECX_REGNUM))
	    return -1;
	}
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d4533 2
a4534 2
      if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
	return -1;
d4548 4
a4555 6
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_CS_REGNUM))
	return -1;
      break;

d4558 3
a4560 6
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_CS_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d4565 4
a4568 7
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      regcache_raw_read (ir.regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (ir.dflag + 1)), (1 << (ir.dflag + 1))))
	return -1;
d4573 8
a4580 9
      if (record_arch_list_add_reg (ir.regcache, I386_CS_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      regcache_raw_read (ir.regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (ir.dflag + 2)), (1 << (ir.dflag + 2))))
	return -1;
d4642 1
d4647 2
a4648 4
	{
	  if (record_arch_list_add_reg (ir.regcache, ir.rm & 0x3))
	    return -1;
	}
d4675 1
d4678 1
a4678 2
      if (record_arch_list_add_reg (ir.regcache, ir.reg & 0x3))
	return -1;
d4684 5
a4688 7
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      regcache_raw_read (ir.regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (ir.dflag + 1)), (1 << (ir.dflag + 1))))
	return -1;
d4693 2
a4694 4
      if (record_arch_list_add_reg (ir.regcache, I386_ESP_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d4699 5
d4714 1
a4714 2
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d4719 7
a4725 2
      if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
	return -1;
a4730 6
      /* bts */
    case 0x0fab:
      /* btr */
    case 0x0fb3:
      /* btc */
    case 0x0fbb:
d4736 1
a4736 1
	  ir.addr -= 3;
d4740 1
a4740 2
      ir.reg -= 4;
      if (ir.reg != 0)
d4742 3
a4744 1
	  if (ir.mod != 3)
a4748 5
	  else
	    {
	      if (record_arch_list_add_reg (ir.regcache, ir.rm))
		return -1;
	    }
d4750 1
a4750 2
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d4755 40
a4794 2
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d4801 2
a4802 4
      if (record_arch_list_add_reg (ir.regcache, ir.reg))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d4818 7
a4824 4
      if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d4916 1
a4916 2
      if (record_arch_list_add_reg (ir.regcache, opcode & 7))
	return -1;
d4921 7
a4927 4
      if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d4938 2
a4939 2
      if (record_arch_list_add_reg (ir.regcache, I386_ECX_REGNUM))
	return -1;
d4970 5
d4996 25
d5023 4
a5026 8
      if (record_arch_list_add_reg (ir.regcache, I386_EAX_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_ECX_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_EDX_REGNUM))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_EBX_REGNUM))
	return -1;
d5047 1
a5047 4
	    {
	      if (record_arch_list_add_reg (ir.regcache, ir.rm))
		return -1;
	    }
d5064 1
a5064 2
	  if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	    return -1;
d5082 1
a5082 1
	    uint32_t addr;
d5090 1
a5090 2

	    if (ir.override)
d5102 1
a5102 3
		if (i386_record_lea_modrm_addr (&ir, &addr))
		  return -1;
		if (record_arch_list_add_mem (addr, 2))
d5104 1
a5104 2
		addr += 2;
		if (record_arch_list_add_mem (addr, 4))
d5106 11
d5130 1
a5130 2
		  if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
		    return -1;
d5142 1
a5142 1
	      if (ir.override)
d5154 1
a5154 1
		  uint32_t addr;
d5156 1
a5156 1
		  if (i386_record_lea_modrm_addr (&ir, &addr))
d5158 1
a5158 1
		  if (record_arch_list_add_mem (addr, 2))
d5161 10
a5170 2
		  if (record_arch_list_add_mem (addr, 4))
		    return -1;
a5177 3
	  /* invlpg */
	case 7:
	default:
d5189 1
a5189 1
	      if (record_arch_list_add_reg (ir.regcache, ir.rm))
d5198 1
d5202 22
a5235 1
      ir.ot = ir.dflag ? OT_LONG : OT_WORD;
d5238 5
a5242 5
      if (ir.mod != 3)
	{
	  if (i386_record_lea_modrm (&ir))
	    return -1;
	}
d5244 7
a5250 6
	{
	  if (record_arch_list_add_reg (ir.regcache, ir.rm))
	    return -1;
	}
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d5259 2
a5260 4
      if (record_arch_list_add_reg (ir.regcache, ir.reg))
	return -1;
      if (record_arch_list_add_reg (ir.regcache, I386_EFLAGS_REGNUM))
	return -1;
d5264 8
d5292 1
a5292 1
	  ir.addr -= 2;
d5304 1
a5304 2
	    {
	    }
d5306 1
a5306 4
	    {
	      if (record_arch_list_add_reg (ir.regcache, ir.rm))
		return -1;
	    }
d5309 1
a5309 1
	  ir.addr -= 2;
d5325 1
a5325 1
	  ir.addr -= 2;
d5330 1
a5330 2
	{
	}
d5332 1
a5332 4
	{
	  if (record_arch_list_add_reg (ir.regcache, ir.rm))
	    return -1;
	}
d5337 1
d5352 2
a5353 3
/* In the future, Maybe still need to deal with need_dasm */
  if (record_arch_list_add_reg (ir.regcache, I386_EIP_REGNUM))
    return -1;
d5366 9
d5435 2
@


1.281
log
@	* i386-tdep.c (i386_displaced_step_fixup): Fix order of arguments
	to read_memory_unsigned_integer.
@
text
@d1490 83
d5415 9
a5423 1
  /* Hook in the DWARF CFI frame unwinder.  */
d5431 1
@


1.280
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d526 1
a526 1
      retaddr = read_memory_unsigned_integer (esp, byte_order, retaddr_len);
@


1.279
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d417 2
d526 1
a526 1
      retaddr = read_memory_unsigned_integer (esp, retaddr_len);
d528 1
a528 1
      write_memory_unsigned_integer (esp, retaddr_len, retaddr);
d600 1
a600 1
i386_follow_jump (CORE_ADDR pc)
d602 1
d611 1
a611 1
      op = read_memory_unsigned_integer (pc + 1, 1);
d620 1
a620 1
	  delta = read_memory_integer (pc + 2, 2);
d628 1
a628 1
	  delta = read_memory_integer (pc + 1, 4);
d636 1
a636 1
      delta = read_memory_integer (pc + data16 + 1, 1);
d1012 2
a1013 1
i386_analyze_frame_setup (CORE_ADDR pc, CORE_ADDR limit,
d1016 1
d1065 2
a1066 1
	  if (read_memory_unsigned_integer (pc + skip + 1, 1) != 0xec)
d1070 2
a1071 1
	  if (read_memory_unsigned_integer (pc + skip + 1, 1) != 0xe5)
d1099 1
a1099 1
	  if (read_memory_unsigned_integer (pc + 1, 1) != 0xec)
d1105 1
a1105 1
	  cache->locals = read_memory_integer (pc + 2, 1);
d1111 1
a1111 1
	  if (read_memory_unsigned_integer (pc + 1, 1) != 0xec)
d1116 1
a1116 1
	  cache->locals = read_memory_integer (pc + 2, 4);
d1127 1
a1127 1
      cache->locals = read_memory_unsigned_integer (pc + 1, 2);
d1192 2
a1193 1
i386_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
d1197 1
a1197 1
  pc = i386_follow_jump (pc);
d1201 1
a1201 1
  pc = i386_analyze_frame_setup (pc, current_pc, cache);
d1210 2
d1223 1
a1223 1
  pc = i386_analyze_prologue (start_pc, 0xffffffff, &cache);
d1256 1
a1256 1
	  op = read_memory_unsigned_integer (pc + delta + 1, 1);
d1270 2
a1271 1
	  && read_memory_unsigned_integer (pc + delta + 1, 1) == 0xc3)
d1280 2
a1281 2
  if (i386_follow_jump (start_pc) != start_pc)
    pc = i386_follow_jump (pc);
d1292 1
d1305 1
a1305 1
 	  CORE_ADDR call_dest = pc + 5 + extract_signed_integer (buf, 4);
d1307 1
d1337 2
d1359 1
a1359 1
  cache->base = extract_unsigned_integer (buf, 4);
d1368 2
a1369 1
    i386_analyze_prologue (cache->pc, get_frame_pc (this_frame), cache);
d1375 1
a1375 1
      cache->saved_sp = extract_unsigned_integer(buf, 4);
d1400 2
a1401 1
	  cache->base = extract_unsigned_integer (buf, 4) + cache->sp_offset;
d1497 3
a1500 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));
d1510 1
a1510 1
  cache->base = extract_unsigned_integer (buf, 4) - 4;
d1634 1
d1643 1
a1643 1
  sp = extract_unsigned_integer (buf, 4);
d1647 1
a1647 1
  jb_addr = extract_unsigned_integer (buf, 4);
d1651 1
a1651 1
  *pc = extract_unsigned_integer (buf, 4);
d1690 1
d1710 1
a1710 1
	      store_unsigned_integer (buf, 4, struct_addr);
d1759 1
a1759 1
  store_unsigned_integer (buf, 4, bp_addr);
d1763 1
a1763 1
  store_unsigned_integer (buf, 4, sp);
d2524 2
a2525 1
i386_pe_skip_trampoline_code (CORE_ADDR pc, char *name)
d2527 5
a2531 1
  if (pc && read_memory_unsigned_integer (pc, 2) == 0x25ff) /* jmp *(dest) */
d2533 2
a2534 1
      unsigned long indirect = read_memory_unsigned_integer (pc + 2, 4);
d2543 2
a2544 1
	    return name ? 1 : read_memory_unsigned_integer (indirect, 4);
d2612 2
d2618 1
a2618 1
  sp = extract_unsigned_integer (buf, 4);
d2620 1
a2620 1
  return read_memory_unsigned_integer (sp + 8, 4);
d2737 2
d2740 1
a2740 1
  return read_memory_unsigned_integer (sp + (4 * (argi + 1)), 4);
@


1.278
log
@	* gdbtypes.h (TYPE_OBJFILE_OWNED, TYPE_OWNER): New macros.
	(TYPE_OBJFILE, TYPE_ALLOC, TYPE_ZALLOC): Reimplement.
	(alloc_type_arch): Add prototype.
	(alloc_type_copy): Likewise.
	(get_type_arch): Likewise.
	(arch_type): Likewise.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.

	* gdbtypes.c (alloc_type): No longer support NULL objfile.
	(init_type): Likewise.
	(alloc_type_arch): New function.
	(alloc_type_copy): New function.
	(get_type_arch): New function.

	(smash_type): Preserve type ownership information.
	(make_pointer_type, make_reference_type, make_function_type,
	smash_to_memberptr_type, smash_to_method_type): No longer
	preserve OBJFILE across smash_type calls.
	(make_pointer_type, make_reference_type, make_function_type,
	lookup_memberptr_type, lookup_methodptr_type, allocate_stub_method,
	create_range_type, create_array_type, create_set_type, copy_type):
	Use alloc_type_copy when allocating types.
	(check_typedef): Use alloc_type_arch.
	(copy_type_recursive): Likewise.  Preserve type ownership data
	after copying type.
	(recursive_dump_type): Dump type ownership data.
	(alloc_type_instance): Update type ownership check.
	(copy_type, copy_type_recursive): Likewise.

	(arch_type): New function.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(append_flags_type_flag): Move down.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.
	(append_composite_type_field_aligned,
	append_composite_type_field): Move down.

	* gdbarch.c (gdbtypes_post_init): Allocate all types
	using per-architecture routines.
	* ada-lang.c (ada_language_arch_info): Likewise.
	* f-lang.c (build_fortran_types): Likewise.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* scm-lang.c (build_scm_types): Likewise.

	* ada-lang.c (ada_type_of_array): Use alloc_type_copy.
	(packed_array_type): Likewise.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_variant_branch_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_fixed_range_type): Likewise.
	(empty_record): Use type instead of objfile argument.
	Use alloc_type_copy.
	(to_fixed_variant_branch_type): Update call to empty_record.
	* jv-lang.c (type_from_class): Use alloc_type_arch.

	* arm-tdep.c (arm_ext_type): Allocate per-architecture type.
	* i386-tdep.c (i386_eflags_type, i386_mxcsr_type, i387_ext_type,
	i386_mmx_type, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_ext_type): Likewise.
	* m32c-tdep.c (make_types): Likewise.
	* m68k-tdep.c (m68k_ps_type, m68881_ext_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* sparc-tdep.c (sparc_psr_type, sparc_fsr_type): Likewise.
	* sparc64-tdep.c (sparc64_pstate_type, sparc64_fsr_type,
	sparc64_fprs_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* target-descriptions.c (tdesc_gdb_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
@
text
@d431 1
a431 1
                        "displaced: fixup (0x%s, 0x%s), "
d433 2
a434 1
                        paddr_nz (from), paddr_nz (to), insn[0], insn[1]);
d503 3
a505 2
                                "relocated %%eip from 0x%s to 0x%s\n",
                                paddr_nz (orig_eip), paddr_nz (eip));
d530 3
a532 4
                            "displaced: relocated return addr at 0x%s "
                            "to 0x%s\n",
                            paddr_nz (esp),
                            paddr_nz (retaddr));
d2768 2
d2774 2
a2775 2
			     "addr 0x%s len = 1.\n"),
			   paddr_nz (irp->addr));
d2793 1
d2814 2
a2815 2
				     "at addr 0x%s len = 1.\n"),
				   paddr_nz (irp->addr));
d2834 2
a2835 2
				         "memory at addr 0x%s len = 4.\n"),
				       paddr_nz (irp->addr));
d2850 2
a2851 2
				     "at addr 0x%s len = 1.\n"),
				   paddr_nz (irp->addr));
d2862 2
a2863 2
				     "at addr 0x%s len = 4.\n"),
				   paddr_nz (irp->addr));
d2896 2
a2897 2
					 "memory at addr 0x%s len = 2.\n"),
				       paddr_nz (irp->addr));
d2915 2
a2916 2
				     "at addr 0x%s len = 1.\n"),
				   paddr_nz (irp->addr));
d2927 2
a2928 2
				     "at addr 0x%s len = 2.\n"),
				   paddr_nz (irp->addr));
d3005 1
d3012 1
a3012 1
			     "of instruction at address 0x%s because it "
d3014 1
a3014 1
			   paddr_nz (irp->addr));
d3050 2
a3051 2
			            "addr = 0x%s\n",
			paddr_nz (ir.addr));
d3060 2
a3061 2
				 "addr 0x%s len = 1.\n"),
			       paddr_nz (ir.addr));
d3121 2
a3122 2
				 "addr 0x%s len = 1.\n"),
			       paddr_nz (ir.addr));
d3860 1
a3860 1
				   "of instruction at address 0x%s because "
d3863 1
a3863 1
				 paddr_nz (ir.addr));
d3878 2
a3879 2
					   "memory at addr 0x%s len = 4.\n"),
					 paddr_nz (ir.addr));
d3891 2
a3892 2
					   "memory at addr 0x%s len = 4.\n"),
					 paddr_nz (ir.addr));
d4280 1
a4280 1
				   "of instruction at address 0x%s because "
d4283 1
a4283 1
				 paddr_nz (ir.addr));
d4689 2
a4690 2
				   "at addr 0x%s len = 1.\n"),
				 paddr_nz (ir.addr));
d4897 1
a4897 1
				       "address 0x%s because it can't get "
d4900 1
a4900 1
				     paddr_nz (ir.addr));
d4942 1
a4942 1
					 "address 0x%s because it can't get "
d4945 1
a4945 1
				       paddr_nz (ir.addr));
d5130 2
a5131 2
		       "at address 0x%s.\n"),
		     (unsigned int) (opcode), paddr_nz (ir.addr));
@


1.277
log
@	* i386-tdep.h (struct gdbarch_tdep): Add i386_eflags_type and
	i386_mxcsr_type members.
	(i386_eflags_type): Make into function.
	(i386_mxcsr_type): Likewise.
	* i386-tdep.c (i386_eflags_type): Make into function.
	(i386_mxcsr_type): Likewise.
	(i386_register_type): Update uses.
	(i386_init_types): Remove.
	(_initialize_i386_tdep): Do not call it.
	* amd64-tdep.c (amd64_register_type): Update uses.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68k_ps_type member.
	* m68k-tdep.c (m68k_ps_type): Make into function.
	(m68k_register_type): Update use.
	(m68k_init_types): Remove.
	(_initialize_m68k_tdep): Do not call it.

	* sparc-tdep.h (struct gdbarch_tdep): Add sparc_psr_type,
	sparc_fsr_type, sparc64_pstate_type, sparc64_fsr_type, and
	sparc64_fprs_type members.
	* sparc-tdep.c (sparc_psr_type): Make into function.
	(sparc_fsr_type): Likewise.
	(sparc32_register_type): Update uses.
	(sparc_init_types): Remove.
	(_initialize_sparc_tdep): Do not call it.
	* sparc64-tdep.c (sparc64_pstate_type): Make into function.
	(sparc64_fsr_type): Likewise.
	(sparc64_fprs_type): Likewise.
	(sparc64_register_type): Update uses.
	(sparc64_init_types): Remove.
	(_initialize_sparc64_tdep): Likewise.
@
text
@d2007 1
a2007 1
      type = init_flags_type ("builtin_type_i386_eflags", 4);
d2041 1
a2041 1
      type = init_flags_type ("builtin_type_i386_mxcsr", 4);
d2070 1
a2070 1
      = init_float_type (-1, "builtin_type_i387_ext",
d2099 2
a2100 1
      t = init_composite_type ("__gdb_builtin_type_vec64i", TYPE_CODE_UNION);
d2143 2
a2144 1
      t = init_composite_type ("__gdb_builtin_type_vec128i", TYPE_CODE_UNION);
@


1.276
log
@	* gdbtypes.h (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(init_float_type, init_complex_type): Add prototypes.
	* gdbtypes.c (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(build_flt): Rename to ...
	(init_float_type): ... this.  Make global.
	(build_complex): Rename to ...
	(init_complex_type): ... this.  Make global.  Remove BIT argument.
	(gdbtypes_post_init): Update calls.

	* ada-lang.c (ada_language_arch_info): Use init_float_type.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* f-lang.c (build_fortran_types): Use init_float_type and
	init_complex_type.

	* target-descriptions.c (tdesc_gdb_type): Call init_float_type instead
	of using builtin_type_ieee_single, builtin_type_ieee_double, or
	builtin_type_arm_ext.

	* ia64-tdep.h (struct gdbarch_tdep): Add ia64_ext_type member.
	* ia64-tdep.c (builtin_type_ia64_ext): Remove.
	(_initialize_ia64_tdep): Do not initialize it.
	(floatformat_valid, floatformat_ia64_ext, floatformats_ia64_ext):
	Move up.
	(ia64_ext_type): New function.
	(ia64_register_reggroup_p, ia64_convert_register_p,
	ia64_register_to_value, ia64_value_to_register,
	ia64_extract_return_value, ia64_store_return_value): Use ia64_ext_type
	instead of builtin_type_ia64_ext.

	* i386-tdep.h (struct gdbarch_tdep): Add i387_ext_type member.
	(i387_ext_type): Add prototype.
	* i386-tdep.c (i387_ext_type): New function.
	(i386_extract_return_value, i386_store_return_value,
	i386_register_type): Use it instead of builtin_type_i387_ext.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* i387-tdep.c (print_i387_value, i387_register_to_value,
	i387_value_to_register): Likewise.
	(print_i387_value, print_i387_ext): Add GDBARCH argument.
	(print_i387_ext, i387_print_float_info): Pass to subroutines.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68881_ext_type member.
	* m68k-tdep.c (m68881_ext_type): New function.
	(m68k_register_type, m68k_convert_register_p): Use it instead
	of builtin_type_m68881_ext.

	* arm-tdep.h (struct gdbarch_tdep): Add arm_ext_type member.
	* arm-tdep.c (arm_ext_type): New function.
	(arm_register_type): Use it instead of builtin_type_arm_ext.

	* alpha-tdep.c (alpha_register_type): Use builtin types
	instead of builtin_type_ieee_double.

	* mips-tdep.c (mips_float_register_type, mips_double_register_type):
	Remove.
	(mips_register_type): Use builtin types instead of
	builtin_type_ieee_single and builtin_type_ieee_double.
	(mips_print_fp_register): Use builtin types instead of
	mips_float_register_type and mips_double_register_type.

	* hppa-tdep.c (hppa32_register_type, hppa64_register_type):
	Use builtin types instead of builtin_type_ieee_single and
	builtin_type_ieee_double.
@
text
@d1997 28
a2024 2
/* Type for %eflags.  */
struct type *i386_eflags_type;
d2026 5
a2030 2
/* Type for %mxcsr.  */
struct type *i386_mxcsr_type;
d2032 2
a2033 3
/* Construct types for ISA-specific registers.  */
static void
i386_init_types (void)
d2035 24
a2058 1
  struct type *type;
d2060 1
a2060 36
  type = init_flags_type ("builtin_type_i386_eflags", 4);
  append_flags_type_flag (type, 0, "CF");
  append_flags_type_flag (type, 1, NULL);
  append_flags_type_flag (type, 2, "PF");
  append_flags_type_flag (type, 4, "AF");
  append_flags_type_flag (type, 6, "ZF");
  append_flags_type_flag (type, 7, "SF");
  append_flags_type_flag (type, 8, "TF");
  append_flags_type_flag (type, 9, "IF");
  append_flags_type_flag (type, 10, "DF");
  append_flags_type_flag (type, 11, "OF");
  append_flags_type_flag (type, 14, "NT");
  append_flags_type_flag (type, 16, "RF");
  append_flags_type_flag (type, 17, "VM");
  append_flags_type_flag (type, 18, "AC");
  append_flags_type_flag (type, 19, "VIF");
  append_flags_type_flag (type, 20, "VIP");
  append_flags_type_flag (type, 21, "ID");
  i386_eflags_type = type;

  type = init_flags_type ("builtin_type_i386_mxcsr", 4);
  append_flags_type_flag (type, 0, "IE");
  append_flags_type_flag (type, 1, "DE");
  append_flags_type_flag (type, 2, "ZE");
  append_flags_type_flag (type, 3, "OE");
  append_flags_type_flag (type, 4, "UE");
  append_flags_type_flag (type, 5, "PE");
  append_flags_type_flag (type, 6, "DAZ");
  append_flags_type_flag (type, 7, "IM");
  append_flags_type_flag (type, 8, "DM");
  append_flags_type_flag (type, 9, "ZM");
  append_flags_type_flag (type, 10, "OM");
  append_flags_type_flag (type, 11, "UM");
  append_flags_type_flag (type, 12, "PM");
  append_flags_type_flag (type, 15, "FZ");
  i386_mxcsr_type = type;
d2176 1
a2176 1
    return i386_eflags_type;
d2191 1
a2191 1
    return i386_mxcsr_type;
d5371 1
a5371 1
  /* Initialize the i386-specific register groups & types.  */
a5372 1
  i386_init_types();
@


1.275
log
@	* gdbtypes.h (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(struct builtin_type): New members builtin_int0, builtin_int8,
	builtin_uint8, builtin_int16, builtin_uint16, builtin_int32,
	builtin_uint32, builtin_int64, builtin_uint64, builtin_int128,
	and builtin_uint128.
	* gdbtypes.c (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize fixed-size integer types.

	* dwarf2expr.c (unsigned_address_type, signed_address_type): Add
	GDBARCH argument.  Return platform-specific type.
	(dwarf2_read_address, execute_stack_op): Update calls.

	* target-descriptions.c (tdesc_gdb_type): Use platform-specific types
	instead of global builtin_int_... variables.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	* printcmd.c (do_examine): Likewise.
	* jv-exp.y (parse_number): Likewise.

	* alpha-tdep.c (alpha_register_type, alpha_push_dummy_call,
	alpha_store_return_value): Likewise.
	* amd64-linux-tdep.c (amd64_linux_register_type): Likewise.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c h8300_register_type): Likewise.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_register_type,
	hppa64_register_type): Likewise.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Likewise.
	* iq2000-tdep.c (iq2000_register_type): Likewise.
	* lm32-tdep.c (lm32_register_type, lm32_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68hc11-tdep.c (m68hc11_register_type, m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m88k-tdep.c (m88k_register_type, m88k_store_arguments): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_register_type, mips_pseudo_register_type,
	mips_print_fp_register): Likewise.
	* moxie-tdep.c (moxie_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type, mt_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* score-tdep.c (score_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type, sparc32_store_arguments):
	Likewise.
	* sparc64-tdep.c (sparc64_register_type, sparc64_store_arguments):
	Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* xstormy16-tdep.c (xstormy16_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* mt-tdep.c (struct gdbarch_tdep): New data structure.
	(mt_gdbarch_init): Alloc TDEP structures.
	(mt_register_type): Cache coprocessor type in TDEP instead of
	static global variable.

	* xtensa-tdep.h (struct gdbarch_tdep): Add type_entries member.
	* xtensa-tdep.c (type_entries): Remove.
	(xtensa_register_type): Cache fixed-size types in TDEP instead
	of in global variable.
@
text
@d1790 1
a1790 1
      convert_typed_floating (buf, builtin_type_i387_ext, valbuf, type);
d1844 1
a1844 1
      convert_typed_floating (valbuf, type, buf, builtin_type_i387_ext);
d2047 13
d2166 1
a2166 1
    return builtin_type_i387_ext;
@


1.274
log
@
	* i386-tdep.c (i386_go32_init_abi): Use SVR4 register numbering
	for stabs and COFF debug info.
@
text
@d2055 2
d2071 2
a2072 1
      append_composite_type_field (t, "uint64", builtin_type_int64);
d2074 1
a2074 1
				   init_vector_type (builtin_type_int32, 2));
d2076 1
a2076 1
				   init_vector_type (builtin_type_int16, 4));
d2078 1
a2078 1
				   init_vector_type (builtin_type_int8, 8));
d2095 2
d2115 1
a2115 2
				   init_vector_type (builtin_type (gdbarch)
						     ->builtin_float, 4));
d2117 1
a2117 2
				   init_vector_type (builtin_type (gdbarch)
						     ->builtin_double, 2));
d2119 1
a2119 1
				   init_vector_type (builtin_type_int8, 16));
d2121 1
a2121 1
				   init_vector_type (builtin_type_int16, 8));
d2123 1
a2123 1
				   init_vector_type (builtin_type_int32, 4));
d2125 2
a2126 2
				   init_vector_type (builtin_type_int64, 2));
      append_composite_type_field (t, "uint128", builtin_type_int128);
@


1.273
log
@* i386-tdep.c (i386_process_record): Make it extern.
(i386_gdbarch_init): Don't call set_gdbarch_process_record
here.
* i386-tdep.c (i386_process_record): Declare.
* i386-linux-tdep.c (i386_linux_init_abi): Call
set_gdbarch_process_record.
@
text
@d2604 7
@


1.272
log
@* i386-tdep.c (i386_process_record): Change bzero to memset.
@
text
@d2985 1
a2985 1
static int
a5279 2
  set_gdbarch_process_record (gdbarch, i386_process_record);

@


1.271
log
@
	* i386-tdep.c (i386_go32_init_abi): Override the number of
	registers due to non-support of SSE.
@
text
@d2996 1
a2996 1
  bzero (&ir, sizeof (struct i386_record_s));
@


1.270
log
@I386 architecture process record and replay support.

* i386-tdep.c (PREFIX_REPZ, PREFIX_REPNZ, PREFIX_LOCK,
PREFIX_DATA, PREFIX_ADDR): New macros. Help decode the i386
instruction set.
(aflag, dflag, override, modrm, mod, reg, rm, ot,
i386_record_pc): New variables. Ditto.
(i386_record_modrm, i386_record_lea_modrm_addr,
i386_record_lea_modrm): New functions. Ditto.
(i386_process_record): New function. Parse the instruction in
address "addr" and record the values of registers and memory
that will be changed by this instruction.
(i386_gdbarch_init): Set "i386_process_record" to GDBARCH
"process_record" interface.
* i386-tdep.h (gdbarch_tdep): New function pointers
"i386_intx80_record" and "i386_sysenter_record" that point to
the function that can record "intx80" and "sysenter" execute
log.
@
text
@d2600 4
@


1.269
log
@	* amd64-tdep.c (amd64_skip_prefixes): Renamed from skip_prefixes.
	All callers updated.
	(amd64_get_insn_details): Handle more 3-byte opcode insns.
	(amd64_breakpoint_p): Delete.
	(amd64_displaced_step_fixup): When fixing up after stepping an int3,
	don't back up pc to the start of the int3.
	* i386-tdep.c: #include opcode/i386.h.
	(i386_skip_prefixes): New function.
	(i386_absolute_jmp_p): Constify argument.
	(i386_absolute_call_p,i386_ret_p,i386_call_p,i386_syscall_p): Ditto.
	(i386_breakpoint_p): Delete.
	(i386_displaced_step_fixup): Handle unnecessary or redundant prefixes.
	When fixing up after stepping an int3, don't back up pc to the start
	of the int3.

	* gdb.arch/amd64-disp-step.S (test_int3): New test.
	* gdb.arch/amd64-disp-step.exp (test_int3): New test.
	* gdb.arch/i386-disp-step.S (test_prefixed_abs_jump): New test.
	(test_prefixed_syscall,test_int3): New tests.
	* gdb.arch/i386-disp-step.exp (test_prefixed_abs_jump): New test.
	(test_prefixed_syscall,test_int3): New tests.
@
text
@d53 3
d2677 16
a2692 3

static struct gdbarch *
i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
d2694 9
a2702 2
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;
d2704 11
a2714 4
  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d2716 2
a2717 3
  /* Allocate space for the new architecture.  */
  tdep = XCALLOC (1, struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);
d2719 15
a2733 5
  /* General-purpose registers.  */
  tdep->gregset = NULL;
  tdep->gregset_reg_offset = NULL;
  tdep->gregset_num_regs = I386_NUM_GREGS;
  tdep->sizeof_gregset = 0;
d2735 2
a2736 3
  /* Floating-point registers.  */
  tdep->fpregset = NULL;
  tdep->sizeof_fpregset = I387_SIZEOF_FSAVE;
d2738 3
a2740 8
  /* The default settings include the FPU registers, the MMX registers
     and the SSE registers.  This can be overridden for a specific ABI
     by adjusting the members `st0_regnum', `mm0_regnum' and
     `num_xmm_regs' of `struct gdbarch_tdep', otherwise the registers
     will show up in the output of "info all-registers".  Ideally we
     should try to autodetect whether they are available, such that we
     can prevent "info all-registers" from displaying registers that
     aren't available.
d2742 15
a2756 4
     NOTE: kevinb/2003-07-13: ... if it's a choice between printing
     [the SSE registers] always (even when they don't exist) or never
     showing them to the user (even when they do exist), I prefer the
     former over the latter.  */
d2758 16
a2773 1
  tdep->st0_regnum = I386_ST0_REGNUM;
d2775 45
a2819 4
  /* The MMX registers are implemented as pseudo-registers.  Put off
     calculating the register number for %mm0 until we know the number
     of raw registers.  */
  tdep->mm0_regnum = 0;
d2821 5
a2825 2
  /* I386_NUM_XREGS includes %mxcsr, so substract one.  */
  tdep->num_xmm_regs = I386_NUM_XREGS - 1;
d2827 59
a2885 9
  tdep->jb_pc_offset = -1;
  tdep->struct_return = pcc_struct_return;
  tdep->sigtramp_start = 0;
  tdep->sigtramp_end = 0;
  tdep->sigtramp_p = i386_sigtramp_p;
  tdep->sigcontext_addr = NULL;
  tdep->sc_reg_offset = NULL;
  tdep->sc_pc_offset = -1;
  tdep->sc_sp_offset = -1;
d2887 57
a2943 5
  /* The format used for `long double' on almost all i386 targets is
     the i387 extended floating-point format.  In fact, of all targets
     in the GCC 2.95 tree, only OSF/1 does it different, and insists
     on having a `long double' that's not `long' at all.  */
  set_gdbarch_long_double_format (gdbarch, floatformats_i387_ext);
d2945 3
a2947 4
  /* Although the i387 extended floating-point has only 80 significant
     bits, a `long double' actually takes up 96, probably to enforce
     alignment.  */
  set_gdbarch_long_double_bit (gdbarch, 96);
d2949 3
a2951 5
  /* The default ABI includes general-purpose registers, 
     floating-point registers, and the SSE registers.  */
  set_gdbarch_num_regs (gdbarch, I386_SSE_NUM_REGS);
  set_gdbarch_register_name (gdbarch, i386_register_name);
  set_gdbarch_register_type (gdbarch, i386_register_type);
d2953 4
a2956 5
  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, I386_ESP_REGNUM); /* %esp */
  set_gdbarch_pc_regnum (gdbarch, I386_EIP_REGNUM); /* %eip */
  set_gdbarch_ps_regnum (gdbarch, I386_EFLAGS_REGNUM); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, I386_ST0_REGNUM); /* %st(0) */
d2958 9
a2966 10
  /* NOTE: kettenis/20040418: GCC does have two possible register
     numbering schemes on the i386: dbx and SVR4.  These schemes
     differ in how they number %ebp, %esp, %eflags, and the
     floating-point registers, and are implemented by the arrays
     dbx_register_map[] and svr4_dbx_register_map in
     gcc/config/i386.c.  GCC also defines a third numbering scheme in
     gcc/config/i386.c, which it designates as the "default" register
     map used in 64bit mode.  This last register numbering scheme is
     implemented in dbx64_register_map, and is used for AMD64; see
     amd64-tdep.c.
d2968 2
a2969 7
     Currently, each GCC i386 target always uses the same register
     numbering scheme across all its supported debugging formats
     i.e. SDB (COFF), stabs and DWARF 2.  This is because
     gcc/sdbout.c, gcc/dbxout.c and gcc/dwarf2out.c all use the
     DBX_REGISTER_NUMBER macro which is defined by each target's
     respective config header in a manner independent of the requested
     output debugging format.
d2971 2
a2972 10
     This does not match the arrangement below, which presumes that
     the SDB and stabs numbering schemes differ from the DWARF and
     DWARF 2 ones.  The reason for this arrangement is that it is
     likely to get the numbering scheme for the target's
     default/native debug format right.  For targets where GCC is the
     native compiler (FreeBSD, NetBSD, OpenBSD, GNU/Linux) or for
     targets where the native toolchain uses a different numbering
     scheme for a particular debug format (stabs-in-ELF on Solaris)
     the defaults below will have to be overridden, like
     i386_elf_init_abi() does.  */
d2974 2
a2975 3
  /* Use the dbx register numbering scheme for stabs and COFF.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);
  set_gdbarch_sdb_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);
d2977 3
a2979 2
  /* Use the SVR4 register numbering scheme for DWARF 2.  */
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, i386_svr4_reg_to_regnum);
d2981 21
a3001 2
  /* We don't set gdbarch_stab_reg_to_regnum, since ECOFF doesn't seem to
     be in use on any of the supported i386 targets.  */
d3003 76
a3078 1
  set_gdbarch_print_float_info (gdbarch, i387_print_float_info);
d3080 55
a3134 1
  set_gdbarch_get_longjmp_target (gdbarch, i386_get_longjmp_target);
d3136 38
a3173 2
  /* Call dummy code.  */
  set_gdbarch_push_dummy_call (gdbarch, i386_push_dummy_call);
d3175 7
a3181 3
  set_gdbarch_convert_register_p (gdbarch, i386_convert_register_p);
  set_gdbarch_register_to_value (gdbarch,  i386_register_to_value);
  set_gdbarch_value_to_register (gdbarch, i386_value_to_register);
d3183 6
a3188 1
  set_gdbarch_return_value (gdbarch, i386_return_value);
d3190 14
a3203 1
  set_gdbarch_skip_prologue (gdbarch, i386_skip_prologue);
d3205 23
a3227 2
  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
d3229 2000
a5228 3
  set_gdbarch_breakpoint_from_pc (gdbarch, i386_breakpoint_from_pc);
  set_gdbarch_decr_pc_after_break (gdbarch, 1);
  set_gdbarch_max_insn_length (gdbarch, I386_MAX_INSN_LEN);
d5276 2
@


1.268
log
@2009-02-04  Tristan Gingold  <gingold@@adacore.com>

	* i386-tdep.c (i386_sigtramp_p): Make it public.
	* i386-tdep.h (i386_sigtramp_p): Declare.
@
text
@d23 1
d282 35
d319 1
a319 1
i386_absolute_jmp_p (gdb_byte *insn)
d340 1
a340 1
i386_absolute_call_p (gdb_byte *insn)
d361 1
a361 1
i386_ret_p (gdb_byte *insn)
d378 1
a378 1
i386_call_p (gdb_byte *insn)
a389 6
static int
i386_breakpoint_p (gdb_byte *insn)
{
  return insn[0] == 0xcc;       /* int 3 */
}

d392 1
d394 1
a394 1
i386_syscall_p (gdb_byte *insn, ULONGEST *lengthp)
d407 1
d423 2
d438 12
d479 1
a479 1
          && orig_eip != to + insn_len)
d490 3
a492 14
          /* If we have stepped over a breakpoint, set the %eip to
             point at the breakpoint instruction itself.

             (gdbarch_decr_pc_after_break was never something the core
             of GDB should have been concerned with; arch-specific
             code should be making PC values consistent before
             presenting them to GDB.)  */
          if (i386_breakpoint_p (insn))
            {
              if (debug_displaced)
                fprintf_unfiltered (gdb_stdlog,
                                    "displaced: stepped breakpoint\n");
              eip--;
            }
a530 2


@


1.267
log
@        Updated copyright notices for most files.
@
text
@d2455 1
a2455 1
static int
@


1.266
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d4 1
a4 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.266.6.1
log
@2008-12-26  Michael Snyder  <msnyder@@vmware.com>

	* Marker: adding teawater patches to branch.
@
text
@a51 3
#include "record.h"
#include <stdint.h>

d2641 3
a2643 16
#define PREFIX_REPZ	0x01
#define PREFIX_REPNZ	0x02
#define PREFIX_LOCK	0x04
#define PREFIX_DATA	0x08
#define PREFIX_ADDR	0x10

/* operand size */
enum
{
  OT_BYTE = 0,
  OT_WORD,
  OT_LONG,
};

/* i386 arith/logic operations */
enum
d2645 2
a2646 9
  OP_ADDL,
  OP_ORL,
  OP_ADCL,
  OP_SBBL,
  OP_ANDL,
  OP_SUBL,
  OP_XORL,
  OP_CMPL,
};
d2648 4
a2651 7
static int aflag = 1;
static int dflag = 1;
static int override = 0;
static uint8_t modrm;
static uint8_t mod, reg, rm;
static int ot;
static CORE_ADDR i386_record_pc;
d2653 3
a2655 19
/* Parse "modrm" part in current memory address that i386_record_pc point to.
   Return -1 if something wrong. */
static int
i386_record_modrm (void)
{
  if (target_read_memory (i386_record_pc, &modrm, 1))
    {
      if (record_debug)
	{
	  printf_unfiltered (_
			     ("Process record: error reading memory at addr 0x%s len = 1.\n"),
			     paddr_nz (i386_record_pc));
	}
      return (-1);
    }
  i386_record_pc++;
  mod = (modrm >> 6) & 3;
  reg = (modrm >> 3) & 7;
  rm = modrm & 7;
d2657 5
a2661 2
  return (0);
}
d2663 3
a2665 18
/* Get the memory address that current instruction  write to and set it to
   the argument "addr".
   Return -1 if something wrong. */
static int
i386_record_lea_modrm_addr (uint32_t * addr)
{
  uint8_t tmpu8;
  uint16_t tmpu16;
  uint32_t tmpu32;

  *addr = 0;
  if (aflag)
    {
      /* 32 bits */
      int havesib = 0;
      uint8_t scale = 0;
      uint8_t index = 0;
      uint8_t base = rm;
d2667 8
a2674 18
      if (base == 4)
	{
	  havesib = 1;
	  if (target_read_memory (i386_record_pc, &tmpu8, 1))
	    {
	      if (record_debug)
		{
		  printf_unfiltered (_
				     ("Process record: error reading memory at addr 0x%s len = 1.\n"),
				     paddr_nz (i386_record_pc));
		}
	      return (-1);
	    }
	  i386_record_pc++;
	  scale = (tmpu8 >> 6) & 3;
	  index = ((tmpu8 >> 3) & 7);
	  base = (tmpu8 & 7);
	}
d2676 4
a2679 51
      switch (mod)
	{
	case 0:
	  if ((base & 7) == 5)
	    {
	      base = 0xff;
	      if (target_read_memory (i386_record_pc, (gdb_byte *) addr, 4))
		{
		  if (record_debug)
		    {
		      printf_unfiltered (_
					 ("Process record: error reading memory at addr 0x%s len = 4.\n"),
					 paddr_nz (i386_record_pc));
		    }
		  return (-1);
		}
	      i386_record_pc += 4;
	    }
	  else
	    {
	      *addr = 0;
	    }
	  break;
	case 1:
	  if (target_read_memory (i386_record_pc, &tmpu8, 1))
	    {
	      if (record_debug)
		{
		  printf_unfiltered (_
				     ("Process record: error reading memory at addr 0x%s len = 1.\n"),
				     paddr_nz (i386_record_pc));
		}
	      return (-1);
	    }
	  i386_record_pc++;
	  *addr = (int8_t) tmpu8;
	  break;
	case 2:
	  if (target_read_memory (i386_record_pc, (gdb_byte *) addr, 4))
	    {
	      if (record_debug)
		{
		  printf_unfiltered (_
				     ("Process record: error reading memory at addr 0x%s len = 4.\n"),
				     paddr_nz (i386_record_pc));
		}
	      return (-1);
	    }
	  i386_record_pc += 4;
	  break;
	}
d2681 1
a2681 5
      if (base != 0xff)
	{
	  regcache_raw_read (record_regcache, base, (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	}
d2683 4
a2686 65
      /* XXX: index == 4 is always invalid */
      if (havesib && (index != 4 || scale != 0))
	{
	  regcache_raw_read (record_regcache, index, (gdb_byte *) & tmpu32);
	  *addr += tmpu32 << scale;
	}
    }
  else
    {
      /* 16 bits */
      switch (mod)
	{
	case 0:
	  if (rm == 6)
	    {
	      if (target_read_memory
		  (i386_record_pc, (gdb_byte *) & tmpu16, 2))
		{
		  if (record_debug)
		    {
		      printf_unfiltered (_
					 ("Process record: error reading memory at addr 0x%s len = 2.\n"),
					 paddr_nz (i386_record_pc));
		    }
		  return (-1);
		}
	      i386_record_pc += 2;
	      *addr = (int16_t) tmpu16;
	      rm = 0;
	      goto no_rm;
	    }
	  else
	    {
	      *addr = 0;
	    }
	  break;
	case 1:
	  if (target_read_memory (i386_record_pc, &tmpu8, 1))
	    {
	      if (record_debug)
		{
		  printf_unfiltered (_
				     ("Process record: error reading memory at addr 0x%s len = 1.\n"),
				     paddr_nz (i386_record_pc));
		}
	      return (-1);
	    }
	  i386_record_pc++;
	  *addr = (int8_t) tmpu8;
	  break;
	case 2:
	  if (target_read_memory (i386_record_pc, (gdb_byte *) & tmpu16, 2))
	    {
	      if (record_debug)
		{
		  printf_unfiltered (_
				     ("Process record: error reading memory at addr 0x%s len = 2.\n"),
				     paddr_nz (i386_record_pc));
		}
	      return (-1);
	    }
	  i386_record_pc += 2;
	  *addr = (int16_t) tmpu16;
	  break;
	}
d2688 2
a2689 57
      switch (rm)
	{
	case 0:
	  regcache_raw_read (record_regcache, I386_EBX_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (record_regcache, I386_ESI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 1:
	  regcache_raw_read (record_regcache, I386_EBX_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (record_regcache, I386_EDI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 2:
	  regcache_raw_read (record_regcache, I386_EBP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (record_regcache, I386_ESI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 3:
	  regcache_raw_read (record_regcache, I386_EBP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (record_regcache, I386_EDI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 4:
	  regcache_raw_read (record_regcache, I386_ESI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 5:
	  regcache_raw_read (record_regcache, I386_EDI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 6:
	  regcache_raw_read (record_regcache, I386_EBP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 7:
	  regcache_raw_read (record_regcache, I386_EBX_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	}
      *addr &= 0xffff;
    }
d2691 9
a2699 3
no_rm:
  return (0);
}
d2701 5
a2705 7
/* Record the value of the memory that willbe changed in current instruction
   to "record_arch_list".
   Return -1 if something wrong. */
static int
i386_record_lea_modrm (void)
{
  uint32_t addr;
d2707 4
a2710 8
  if (override)
    {
      if (record_debug)
	printf_unfiltered (_
			   ("Process record ignores the memory change of instruction at address 0x%s because it can't get the value of the segment register.\n"),
			   paddr_nz (i386_record_pc));
      return (0);
    }
d2712 5
a2716 4
  if (i386_record_lea_modrm_addr (&addr))
    {
      return (-1);
    }
d2718 5
a2722 4
  if (record_arch_list_add_mem (addr, 1 << ot))
    {
      return (-1);
    }
d2724 10
a2733 2
  return (0);
}
d2735 7
a2741 11
/* Parse the current instruction and record the values of the registers and
   memory that will be changed in current instruction to "record_arch_list".
   Return -1 if something wrong. */
static int
i386_process_record (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  int prefixes = 0;
  uint8_t tmpu8;
  uint16_t tmpu16;
  uint32_t tmpu32;
  uint32_t opcode;
d2743 10
a2752 4
  i386_record_pc = addr;
  aflag = 1;
  dflag = 1;
  override = 0;
d2754 3
a2756 5
  if (record_debug > 1)
    {
      fprintf_unfiltered (gdb_stdlog, "Process record: i386_record pc = 0x%s\n",
			  paddr_nz (i386_record_pc));
    }
d2758 2
a2759 63
  /* prefixes */
  while (1)
    {
      if (target_read_memory (i386_record_pc, &tmpu8, 1))
	{
	  if (record_debug)
	    {
	      printf_unfiltered (_
				 ("Process record: error reading memory at addr 0x%s len = 1.\n"),
				 paddr_nz (i386_record_pc));
	    }
	  return (-1);
	}
      i386_record_pc++;
      switch (tmpu8)
	{
	case 0xf3:
	  prefixes |= PREFIX_REPZ;
	  break;
	case 0xf2:
	  prefixes |= PREFIX_REPNZ;
	  break;
	case 0xf0:
	  prefixes |= PREFIX_LOCK;
	  break;
	case 0x2e:
	  override = I386_CS_REGNUM;
	  break;
	case 0x36:
	  override = I386_SS_REGNUM;
	  break;
	case 0x3e:
	  override = I386_DS_REGNUM;
	  break;
	case 0x26:
	  override = I386_ES_REGNUM;
	  break;
	case 0x64:
	  override = I386_FS_REGNUM;
	  break;
	case 0x65:
	  override = I386_GS_REGNUM;
	  break;
	case 0x66:
	  prefixes |= PREFIX_DATA;
	  break;
	case 0x67:
	  prefixes |= PREFIX_ADDR;
	  break;
	default:
	  goto out_prefixes;
	  break;
	}
    }
out_prefixes:
  if (prefixes & PREFIX_DATA)
    {
      dflag ^= 1;
    }
  if (prefixes & PREFIX_ADDR)
    {
      aflag ^= 1;
    }
d2761 2
a2762 20
  /* now check op code */
  opcode = (uint32_t) tmpu8;
reswitch:
  switch (opcode)
    {
    case 0x0f:
      if (target_read_memory (i386_record_pc, &tmpu8, 1))
	{
	  if (record_debug)
	    {
	      printf_unfiltered (_
				 ("Process record: error reading memory at addr 0x%s len = 1.\n"),
				 paddr_nz (i386_record_pc));
	    }
	  return (-1);
	}
      i386_record_pc++;
      opcode = (uint16_t) tmpu8 | 0x0f00;
      goto reswitch;
      break;
d2764 1
a2764 59
      /* arith & logic */
    case 0x00:
    case 0x01:
    case 0x02:
    case 0x03:
    case 0x04:
    case 0x05:
    case 0x08:
    case 0x09:
    case 0x0a:
    case 0x0b:
    case 0x0c:
    case 0x0d:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x18:
    case 0x19:
    case 0x1a:
    case 0x1b:
    case 0x1c:
    case 0x1d:
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x28:
    case 0x29:
    case 0x2a:
    case 0x2b:
    case 0x2c:
    case 0x2d:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x38:
    case 0x39:
    case 0x3a:
    case 0x3b:
    case 0x3c:
    case 0x3d:
      if (((opcode >> 3) & 7) != OP_CMPL)
	{
	  if ((opcode & 1) == 0)
	    {
	      ot = OT_BYTE;
	    }
	  else
	    {
	      ot = dflag + OT_WORD;
	    }
d2766 1
a2766 56
	  switch ((opcode >> 1) & 3)
	    {
	      /* OP Ev, Gv */
	    case 0:
	      if (i386_record_modrm ())
		{
		  return (-1);
		}
	      if (mod != 3)
		{
		  if (i386_record_lea_modrm ())
		    {
		      return (-1);
		    }
		}
	      else
		{
		  if (ot == OT_BYTE)
		    {
		      rm &= 0x3;
		    }
		  if (record_arch_list_add_reg (rm))
		    {
		      return (-1);
		    }
		}
	      break;
	      /* OP Gv, Ev */
	    case 1:
	      if (i386_record_modrm ())
		{
		  return (-1);
		}
	      if (ot == OT_BYTE)
		{
		  reg &= 0x3;
		}
	      if (record_arch_list_add_reg (reg))
		{
		  return (-1);
		}
	      break;
	      /* OP A, Iv */
	    case 2:
	      if (record_arch_list_add_reg (I386_EAX_REGNUM))
		{
		  return (-1);
		}
	      break;
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;
d2768 2
a2769 9
      /* GRP1 */
    case 0x80:
    case 0x81:
    case 0x82:
    case 0x83:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
d2771 1
a2771 2543
      if (reg != OP_CMPL)
	{
	  if ((opcode & 1) == 0)
	    {
	      ot = OT_BYTE;
	    }
	  else
	    {
	      ot = dflag + OT_WORD;
	    }

	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* inv */
    case 0x40:
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
      /* dec */
    case 0x48:
    case 0x49:
    case 0x4a:
    case 0x4b:
    case 0x4c:
    case 0x4d:
    case 0x4e:
    case 0x4f:
      if (record_arch_list_add_reg (opcode & 7))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* GRP3 */
    case 0xf6:
    case 0xf7:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}
      if (i386_record_modrm ())
	{
	  return (-1);
	}

      switch (reg)
	{
	  /* test */
	case 0:
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	  /* not */
	case 2:
	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (ot == OT_BYTE)
		{
		  rm &= 0x3;
		}
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  break;
	  /* neg */
	case 3:
	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (ot == OT_BYTE)
		{
		  rm &= 0x3;
		}
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	  /* mul */
	case 4:
	  /* imul */
	case 5:
	  /* div */
	case 6:
	  /* idiv */
	case 7:
	  if (record_arch_list_add_reg (I386_EAX_REGNUM))
	    {
	      return (-1);
	    }
	  if (ot != OT_BYTE)
	    {
	      if (record_arch_list_add_reg (I386_EDX_REGNUM))
		{
		  return (-1);
		}
	    }
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	default:
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      break;

      /* GRP4 */
    case 0xfe:
      /* GRP5 */
    case 0xff:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (reg >= 2 && opcode == 0xfe)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}

      switch (reg)
	{
	  /* inc */
	case 0:
	  /* dec */
	case 1:
	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (ot == OT_BYTE)
		{
		  rm &= 0x3;
		}
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	  /* call */
	case 2:
	  /* push */
	case 6:
	  if (record_arch_list_add_reg (I386_ESP_REGNUM))
	    {
	      return (-1);
	    }
	  regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem
	      ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	    {
	      return (-1);
	    }
	  break;
	  /* lcall */
	case 3:
	  if (record_arch_list_add_reg (I386_ESP_REGNUM))
	    {
	      return (-1);
	    }
	  if (record_arch_list_add_reg (I386_CS_REGNUM))
	    {
	      return (-1);
	    }
	  regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem
	      ((CORE_ADDR) tmpu32 - (1 << (dflag + 2)), (1 << (dflag + 2))))
	    {
	      return (-1);
	    }
	  break;
	  /* jmp */
	case 4:
	  /* ljmp */
	case 5:
	  break;
	default:
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      break;

      /* test */
    case 0x84:
    case 0x85:
    case 0xa8:
    case 0xa9:
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* CWDE/CBW */
    case 0x98:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* CDQ/CWD */
    case 0x99:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EDX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* imul */
    case 0x0faf:
    case 0x69:
    case 0x6b:
      ot = dflag + OT_WORD;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (ot == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* xadd */
    case 0x0fc0:
    case 0x0fc1:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (ot == OT_BYTE)
	    {
	      reg &= 0x3;
	    }
	  if (record_arch_list_add_reg (reg))
	    {
	      return (-1);
	    }
	  if (ot == OT_BYTE)
	    {
	      rm &= 0x3;
	    }
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	  if (ot == OT_BYTE)
	    {
	      reg &= 0x3;
	    }
	  if (record_arch_list_add_reg (reg))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* cmpxchg */
    case 0x0fb0:
    case 0x0fb1:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (record_arch_list_add_reg (I386_EAX_REGNUM))
	    {
	      return (-1);
	    }
	  if (ot == OT_BYTE)
	    {
	      reg &= 0x3;
	    }
	  if (record_arch_list_add_reg (reg))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (record_arch_list_add_reg (I386_EAX_REGNUM))
	    {
	      return (-1);
	    }
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* cmpxchg8b */
    case 0x0fc7:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EDX_REGNUM))
	{
	  return (-1);
	}
      if (i386_record_lea_modrm ())
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* push */
    case 0x50:
    case 0x51:
    case 0x52:
    case 0x53:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
    case 0x68:
    case 0x6a:
      /* push es */
    case 0x06:
      /* push cs */
    case 0x0e:
      /* push ss */
    case 0x16:
      /* push ds */
    case 0x1e:
      /* push fs */
    case 0x0fa0:
      /* push gs */
    case 0x0fa8:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	{
	  return (-1);
	}
      break;

      /* pop */
    case 0x58:
    case 0x59:
    case 0x5a:
    case 0x5b:
    case 0x5c:
    case 0x5d:
    case 0x5e:
    case 0x5f:
      ot = dflag + OT_WORD;
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (ot == OT_BYTE)
	{
	  opcode &= 0x3;
	}
      if (record_arch_list_add_reg (opcode & 0x7))
	{
	  return (-1);
	}
      break;

      /* pusha */
    case 0x60:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 4)), (1 << (dflag + 4))))
	{
	  return (-1);
	}
      break;

      /* popa */
    case 0x61:
      for (tmpu8 = I386_EAX_REGNUM; tmpu8 <= I386_EDI_REGNUM; tmpu8++)
	{
	  if (record_arch_list_add_reg (tmpu8))
	    {
	      return (-1);
	    }
	}
      break;

      /* pop */
    case 0x8f:
      ot = dflag + OT_WORD;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      break;

      /* enter */
    case 0xc8:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EBP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	{
	  return (-1);
	}
      break;

      /* leave */
    case 0xc9:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EBP_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop es */
    case 0x07:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ES_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop ss */
    case 0x17:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_SS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop ds */
    case 0x1f:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_DS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop fs */
    case 0x0fa1:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_FS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop gs */
    case 0x0fa9:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_GS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* mov */
    case 0x88:
    case 0x89:
    case 0xc6:
    case 0xc7:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}

      if (i386_record_modrm ())
	{
	  return (-1);
	}

      if (mod != 3)
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (ot == OT_BYTE)
	    {
	      rm &= 0x3;
	    }
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;
      /* mov */
    case 0x8a:
    case 0x8b:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}

      if (i386_record_modrm ())
	{
	  return (-1);
	}

      if (ot == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}

      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* mov seg */
    case 0x8e:
      if (i386_record_modrm ())
	{
	  return (-1);
	}

      switch (reg)
	{
	case 0:
	  tmpu8 = I386_ES_REGNUM;
	  break;
	case 2:
	  tmpu8 = I386_SS_REGNUM;
	  break;
	case 3:
	  tmpu8 = I386_DS_REGNUM;
	  break;
	case 4:
	  tmpu8 = I386_FS_REGNUM;
	  break;
	case 5:
	  tmpu8 = I386_GS_REGNUM;
	  break;
	default:
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      if (record_arch_list_add_reg (tmpu8))
	{
	  return (-1);
	}

      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* mov seg */
    case 0x8c:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (reg > 5)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}

      if (mod == 3)
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  ot = OT_WORD;
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}

      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* movzbS */
    case 0x0fb6:
      /* movzwS */
    case 0x0fb7:
      /* movsbS */
    case 0x0fbe:
      /* movswS */
    case 0x0fbf:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      break;

      /* lea */
    case 0x8d:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}

      ot = dflag;
      if (ot == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      break;

      /* mov EAX */
    case 0xa0:
    case 0xa1:
      /* xlat */
    case 0xd7:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* mov EAX */
    case 0xa2:
    case 0xa3:
      {
	uint32_t addr;

	if (override)
	  {
	    if (record_debug)
	      printf_unfiltered (_
				 ("Process record ignores the memory change of instruction at address 0x%s because it can't get the value of the segment register.\n"),
				 paddr_nz (i386_record_pc));
	  }
	else
	  {
	    if ((opcode & 1) == 0)
	      {
		ot = OT_BYTE;
	      }
	    else
	      {
		ot = dflag + OT_WORD;
	      }
	    if (aflag)
	      {
		if (target_read_memory
		    (i386_record_pc, (gdb_byte *) & addr, 4))
		  {
		    if (record_debug)
		      {
			printf_unfiltered (_
					   ("Process record: error reading memory at addr 0x%s len = 4.\n"),
					   paddr_nz (i386_record_pc));
		      }
		    return (-1);
		  }
		i386_record_pc += 4;
	      }
	    else
	      {
		if (target_read_memory
		    (i386_record_pc, (gdb_byte *) & tmpu16, 4))
		  {
		    if (record_debug)
		      {
			printf_unfiltered (_
					   ("Process record: error reading memory at addr 0x%s len = 4.\n"),
					   paddr_nz (i386_record_pc));
		      }
		    return (-1);
		  }
		i386_record_pc += 2;
		addr = tmpu16;
	      }
	    if (record_arch_list_add_mem (addr, 1 << ot))
	      {
		return (-1);
	      }
	  }
      }
      break;

      /* mov R, Ib */
    case 0xb0:
    case 0xb1:
    case 0xb2:
    case 0xb3:
    case 0xb4:
    case 0xb5:
    case 0xb6:
    case 0xb7:
      if (record_arch_list_add_reg ((opcode & 0x7) & 0x3))
	{
	  return (-1);
	}
      break;

      /* mov R, Iv */
    case 0xb8:
    case 0xb9:
    case 0xba:
    case 0xbb:
    case 0xbc:
    case 0xbd:
    case 0xbe:
    case 0xbf:
      if (record_arch_list_add_reg (opcode & 0x7))
	{
	  return (-1);
	}
      break;

      /* xchg R, EAX */
    case 0x91:
    case 0x92:
    case 0x93:
    case 0x94:
    case 0x95:
    case 0x96:
    case 0x97:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (opcode & 0x7))
	{
	  return (-1);
	}
      break;

      /* xchg Ev, Gv */
    case 0x86:
    case 0x87:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}

      if (i386_record_modrm ())
	{
	  return (-1);
	}

      if (mod == 3)
	{
	  if (ot == OT_BYTE)
	    {
	      rm &= 0x3;
	    }
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}

      if (ot == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      break;

      /* les Gv */
    case 0xc4:
      /* lds Gv */
    case 0xc5:
      /* lss Gv */
    case 0x0fb2:
      /* lfs Gv */
    case 0x0fb4:
      /* lgs Gv */
    case 0x0fb5:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (opcode > 0xff)
	    {
	      i386_record_pc -= 3;
	    }
	  else
	    {
	      i386_record_pc -= 2;
	    }
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}

      switch (opcode)
	{
	  /* les Gv */
	case 0xc4:
	  tmpu8 = I386_ES_REGNUM;
	  break;
	  /* lds Gv */
	case 0xc5:
	  tmpu8 = I386_DS_REGNUM;
	  break;
	  /* lss Gv */
	case 0x0fb2:
	  tmpu8 = I386_SS_REGNUM;
	  break;
	  /* lfs Gv */
	case 0x0fb4:
	  tmpu8 = I386_FS_REGNUM;
	  break;
	  /* lgs Gv */
	case 0x0fb5:
	  tmpu8 = I386_GS_REGNUM;
	  break;
	}
      if (record_arch_list_add_reg (tmpu8))
	{
	  return (-1);
	}

      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      break;

      /* shifts */
    case 0xc0:
    case 0xc1:
    case 0xd0:
    case 0xd1:
    case 0xd2:
    case 0xd3:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}

      if (i386_record_modrm ())
	{
	  return (-1);
	}

      if (mod != 3 && (opcode == 0xd2 || opcode == 0xd3))
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (ot == OT_BYTE)
	    {
	      rm &= 0x3;
	    }
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}

      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

    case 0x0fa4:
    case 0x0fa5:
    case 0x0fac:
    case 0x0fad:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      break;

      /* floats */
      /* It just record the memory change of instrcution. */
    case 0xd8:
    case 0xd9:
    case 0xda:
    case 0xdb:
    case 0xdc:
    case 0xdd:
    case 0xde:
    case 0xdf:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      reg |= ((opcode & 7) << 3);
      if (mod != 3)
	{
	  /* memory */
	  uint32_t addr;

	  if (i386_record_lea_modrm_addr (&addr))
	    {
	      return (-1);
	    }
	  switch (reg)
	    {
	    case 0x00:
	    case 0x01:
	    case 0x02:
	    case 0x03:
	    case 0x04:
	    case 0x05:
	    case 0x06:
	    case 0x07:
	    case 0x10:
	    case 0x11:
	    case 0x12:
	    case 0x13:
	    case 0x14:
	    case 0x15:
	    case 0x16:
	    case 0x17:
	    case 0x20:
	    case 0x21:
	    case 0x22:
	    case 0x23:
	    case 0x24:
	    case 0x25:
	    case 0x26:
	    case 0x27:
	    case 0x30:
	    case 0x31:
	    case 0x32:
	    case 0x33:
	    case 0x34:
	    case 0x35:
	    case 0x36:
	    case 0x37:
	      break;
	    case 0x08:
	    case 0x0a:
	    case 0x0b:
	    case 0x18:
	    case 0x19:
	    case 0x1a:
	    case 0x1b:
	    case 0x28:
	    case 0x29:
	    case 0x2a:
	    case 0x2b:
	    case 0x38:
	    case 0x39:
	    case 0x3a:
	    case 0x3b:
	      switch (reg & 7)
		{
		case 0:
		  break;
		case 1:
		  switch (reg >> 4)
		    {
		    case 0:
		      if (record_arch_list_add_mem (addr, 4))
			{
			  return (-1);
			}
		      break;
		    case 2:
		      if (record_arch_list_add_mem (addr, 8))
			{
			  return (-1);
			}
		      break;
		    case 3:
		    default:
		      if (record_arch_list_add_mem (addr, 2))
			{
			  return (-1);
			}
		      break;
		    }
		  break;
		default:
		  switch (reg >> 4)
		    {
		    case 0:
		    case 1:
		      if (record_arch_list_add_mem (addr, 4))
			{
			  return (-1);
			}
		      break;
		    case 2:
		      if (record_arch_list_add_mem (addr, 8))
			{
			  return (-1);
			}
		      break;
		    case 3:
		    default:
		      if (record_arch_list_add_mem (addr, 2))
			{
			  return (-1);
			}
		      break;
		    }
		  break;
		}
	      break;
	    case 0x0c:
	    case 0x0d:
	    case 0x1d:
	    case 0x2c:
	    case 0x3c:
	    case 0x3d:
	      break;
	    case 0x0e:
	      if (dflag)
		{
		  if (record_arch_list_add_mem (addr, 28))
		    {
		      return (-1);
		    }
		}
	      else
		{
		  if (record_arch_list_add_mem (addr, 14))
		    {
		      return (-1);
		    }
		}
	      break;
	    case 0x0f:
	    case 0x2f:
	      if (record_arch_list_add_mem (addr, 2))
		{
		  return (-1);
		}
	      break;
	    case 0x1f:
	    case 0x3e:
	      if (record_arch_list_add_mem (addr, 10))
		{
		  return (-1);
		}
	      break;
	    case 0x2e:
	      if (dflag)
		{
		  if (record_arch_list_add_mem (addr, 28))
		    {
		      return (-1);
		    }
		  addr += 28;
		}
	      else
		{
		  if (record_arch_list_add_mem (addr, 14))
		    {
		      return (-1);
		    }
		  addr += 14;
		}
	      if (record_arch_list_add_mem (addr, 80))
		{
		  return (-1);
		}
	      break;
	    case 0x3f:
	      if (record_arch_list_add_mem (addr, 8))
		{
		  return (-1);
		}
	      break;
	    default:
	      i386_record_pc -= 2;
	      opcode = opcode << 8 | modrm;
	      goto no_support;
	      break;
	    }
	}
      break;

      /* string ops */
      /* movsS */
    case 0xa4:
    case 0xa5:
      /* stosS */
    case 0xaa:
    case 0xab:
      /* insS */
    case 0x6c:
    case 0x6d:
      {
	uint32_t addr;

	if ((opcode & 1) == 0)
	  {
	    ot = OT_BYTE;
	  }
	else
	  {
	    ot = dflag + OT_WORD;
	  }
	if (opcode == 0xa4 || opcode == 0xa5)
	  {
	    if (record_arch_list_add_reg (I386_ESI_REGNUM))
	      {
		return (-1);
	      }
	  }
	if (record_arch_list_add_reg (I386_EDI_REGNUM))
	  {
	    return (-1);
	  }

	regcache_raw_read (record_regcache, I386_EDI_REGNUM,
			   (gdb_byte *) & addr);
	if (!aflag)
	  {
	    addr &= 0xffff;
	    /* addr += ((uint32_t)read_register (I386_ES_REGNUM)) << 4; */
            if (record_debug)
	      printf_unfiltered (_
			         ("Process record ignores the memory change of instruction at address 0x%s because it can't get the value of the segment register.\n"),
			   paddr_nz (i386_record_pc));
	  }

	if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	  {
	    uint32_t count;

	    regcache_raw_read (record_regcache, I386_ECX_REGNUM,
			       (gdb_byte *) & count);
	    if (!aflag)
	      {
		count &= 0xffff;
	      }

	    regcache_raw_read (record_regcache, I386_EFLAGS_REGNUM,
			       (gdb_byte *) & tmpu32);
	    if ((tmpu32 >> 10) & 0x1)
	      {
		addr -= (count - 1) * (1 << ot);
	      }

	    if (aflag)
	      {
	        if (record_arch_list_add_mem (addr, count * (1 << ot)))
	          {
		    return (-1);
	          }
	      }

	    if (record_arch_list_add_reg (I386_ECX_REGNUM))
	      {
		return (-1);
	      }
	  }
	else
	  {
	    if (aflag)
	      {
	        if (record_arch_list_add_mem (addr, 1 << ot))
	          {
		    return (-1);
	          }
	      }
	  }
      }
      break;

      /* lodsS */
    case 0xac:
    case 0xad:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ESI_REGNUM))
	{
	  return (-1);
	}
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	{
	  if (record_arch_list_add_reg (I386_ECX_REGNUM))
	    {
	      return (-1);
	    }
	}
      break;

      /* outsS */
    case 0x6e:
    case 0x6f:
      if (record_arch_list_add_reg (I386_ESI_REGNUM))
	{
	  return (-1);
	}
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	{
	  if (record_arch_list_add_reg (I386_ECX_REGNUM))
	    {
	      return (-1);
	    }
	}
      break;

      /* scasS */
    case 0xae:
    case 0xaf:
      if (record_arch_list_add_reg (I386_EDI_REGNUM))
	{
	  return (-1);
	}
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	{
	  if (record_arch_list_add_reg (I386_ECX_REGNUM))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* cmpsS */
    case 0xa6:
    case 0xa7:
      if (record_arch_list_add_reg (I386_EDI_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ESI_REGNUM))
	{
	  return (-1);
	}
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	{
	  if (record_arch_list_add_reg (I386_ECX_REGNUM))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* port I/O */
    case 0xe4:
    case 0xe5:
    case 0xec:
    case 0xed:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      break;

    case 0xe6:
    case 0xe7:
    case 0xee:
    case 0xef:
      break;

      /* control */
      /* ret im */
    case 0xc2:
      /* ret */
    case 0xc3:
      /* lret im */
    case 0xca:
      /* lret */
    case 0xcb:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_CS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* iret */
    case 0xcf:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_CS_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* call im */
    case 0xe8:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	{
	  return (-1);
	}
      break;

      /* lcall im */
    case 0x9a:
      if (record_arch_list_add_reg (I386_CS_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 2)), (1 << (dflag + 2))))
	{
	  return (-1);
	}
      break;

      /* jmp im */
    case 0xe9:
      /* ljmp im */
    case 0xea:
      /* jmp Jb */
    case 0xeb:
      /* jcc Jb */
    case 0x70:
    case 0x71:
    case 0x72:
    case 0x73:
    case 0x74:
    case 0x75:
    case 0x76:
    case 0x77:
    case 0x78:
    case 0x79:
    case 0x7a:
    case 0x7b:
    case 0x7c:
    case 0x7d:
    case 0x7e:
    case 0x7f:
      /* jcc Jv */
    case 0x0f80:
    case 0x0f81:
    case 0x0f82:
    case 0x0f83:
    case 0x0f84:
    case 0x0f85:
    case 0x0f86:
    case 0x0f87:
    case 0x0f88:
    case 0x0f89:
    case 0x0f8a:
    case 0x0f8b:
    case 0x0f8c:
    case 0x0f8d:
    case 0x0f8e:
    case 0x0f8f:
      break;

      /* setcc Gv */
    case 0x0f90:
    case 0x0f91:
    case 0x0f92:
    case 0x0f93:
    case 0x0f94:
    case 0x0f95:
    case 0x0f96:
    case 0x0f97:
    case 0x0f98:
    case 0x0f99:
    case 0x0f9a:
    case 0x0f9b:
    case 0x0f9c:
    case 0x0f9d:
    case 0x0f9e:
    case 0x0f9f:
      ot = OT_BYTE;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (record_arch_list_add_reg (rm & 0x3))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      break;

      /* cmov Gv, Ev */
    case 0x0f40:
    case 0x0f41:
    case 0x0f42:
    case 0x0f43:
    case 0x0f44:
    case 0x0f45:
    case 0x0f46:
    case 0x0f47:
    case 0x0f48:
    case 0x0f49:
    case 0x0f4a:
    case 0x0f4b:
    case 0x0f4c:
    case 0x0f4d:
    case 0x0f4e:
    case 0x0f4f:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (dflag == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg & 0x3))
	{
	  return (-1);
	}
      break;

      /* flags */
      /* pushf */
    case 0x9c:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	{
	  return (-1);
	}
      break;

      /* popf */
    case 0x9d:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* sahf */
    case 0x9e:
      /* cmc */
    case 0xf5:
      /* clc */
    case 0xf8:
      /* stc */
    case 0xf9:
      /* cld */
    case 0xfc:
      /* std */
    case 0xfd:
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* lahf */
    case 0x9f:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* bit operations */
      /* bt/bts/btr/btc Gv, im */
    case 0x0fba:
      /* bts */
    case 0x0fab:
      /* btr */
    case 0x0fb3:
      /* btc */
    case 0x0fbb:
      ot = dflag + OT_WORD;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (reg < 4)
	{
	  i386_record_pc -= 3;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}
      reg -= 4;
      if (reg != 0)
	{
	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* bt Gv, Ev */
    case 0x0fa3:
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* bsf */
    case 0x0fbc:
      /* bsr */
    case 0x0fbd:
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* bcd */
      /* daa */
    case 0x27:
      /* das */
    case 0x2f:
      /* aaa */
    case 0x37:
      /* aas */
    case 0x3f:
      /* aam */
    case 0xd4:
      /* aad */
    case 0xd5:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* misc */
      /* nop */
    case 0x90:
      if (prefixes & PREFIX_LOCK)
	{
	  i386_record_pc -= 1;
	  goto no_support;
	}
      break;

      /* fwait */
      /* XXX */
    case 0x9b:
      printf_unfiltered (_
			 ("Process record doesn't support instruction fwait.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

      /* int3 */
      /* XXX */
    case 0xcc:
      printf_unfiltered (_
			 ("Process record doesn't support instruction int3.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

      /* int */
      /* XXX */
    case 0xcd:
      {
	int ret;
	if (target_read_memory (i386_record_pc, &tmpu8, 1))
	  {
	    if (record_debug)
	      {
		printf_unfiltered (_
				   ("Process record: error reading memory at addr 0x%s len = 1.\n"),
				   paddr_nz (i386_record_pc));
	      }
	    return (-1);
	  }
	i386_record_pc++;
	if (tmpu8 != 0x80
	    || gdbarch_tdep (gdbarch)->i386_intx80_record == NULL)
	  {
	    printf_unfiltered (_
			       ("Process record doesn't support instruction int 0x%02x.\n"),
			       tmpu8);
	    i386_record_pc -= 2;
	    goto no_support;
	  }
	ret = gdbarch_tdep (gdbarch)->i386_intx80_record ();
	if (ret)
	  {
	    return (ret);
	  }
      }
      break;

      /* into */
      /* XXX */
    case 0xce:
      printf_unfiltered (_
			 ("Process record doesn't support instruction into.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

      /* cli */
    case 0xfa:
      /* sti */
    case 0xfb:
      break;

      /* bound */
    case 0x62:
      printf_unfiltered (_
			 ("Process record doesn't support instruction bound.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

      /* bswap reg */
    case 0x0fc8:
    case 0x0fc9:
    case 0x0fca:
    case 0x0fcb:
    case 0x0fcc:
    case 0x0fcd:
    case 0x0fce:
    case 0x0fcf:
      if (record_arch_list_add_reg (opcode & 7))
	{
	  return (-1);
	}
      break;

      /* salc */
    case 0xd6:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* loopnz */
    case 0xe0:
      /* loopz */
    case 0xe1:
      /* loop */
    case 0xe2:
      /* jecxz */
    case 0xe3:
      if (record_arch_list_add_reg (I386_ECX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* wrmsr */
    case 0x0f30:
      printf_unfiltered (_
			 ("Process record doesn't support instruction wrmsr.\n"));
      i386_record_pc -= 2;
      goto no_support;
      break;

      /* rdmsr */
    case 0x0f32:
      printf_unfiltered (_
			 ("Process record doesn't support instruction rdmsr.\n"));
      i386_record_pc -= 2;
      goto no_support;
      break;

      /* rdtsc */
    case 0x0f31:
      printf_unfiltered (_
			 ("Process record doesn't support instruction rdtsc.\n"));
      i386_record_pc -= 2;
      goto no_support;
      break;

      /* sysenter */
    case 0x0f34:
      {
	int ret;
	if (gdbarch_tdep (gdbarch)->i386_sysenter_record == NULL)
	  {
	    printf_unfiltered (_
			       ("Process record doesn't support instruction sysenter.\n"));
	    i386_record_pc -= 2;
	    goto no_support;
	  }
	ret = gdbarch_tdep (gdbarch)->i386_sysenter_record ();
	if (ret)
	  {
	    return (ret);
	  }
      }
      break;

      /* sysexit */
    case 0x0f35:
      printf_unfiltered (_
			 ("Process record doesn't support instruction sysexit.\n"));
      i386_record_pc -= 2;
      goto no_support;
      break;

      /* cpuid */
    case 0x0fa2:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ECX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EDX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EBX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* hlt */
    case 0xf4:
      printf_unfiltered (_
			 ("Process record doesn't support instruction hlt.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

    case 0x0f00:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      switch (reg)
	{
	  /* sldt */
	case 0:
	  /* str */
	case 1:
	  if (mod == 3)
	    {
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  else
	    {
	      ot = OT_WORD;
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  break;
	  /* lldt */
	case 2:
	  /* ltr */
	case 3:
	  break;
	  /* verr */
	case 4:
	  /* verw */
	case 5:
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	default:
	  i386_record_pc -= 3;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      break;

    case 0x0f01:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      switch (reg)
	{
	  /* sgdt */
	case 0:
	  {
	    uint32_t addr;

	    if (mod == 3)
	      {
		i386_record_pc -= 3;
		opcode = opcode << 8 | modrm;
		goto no_support;
	      }

	    if (override)
	      {
		if (record_debug)
		  printf_unfiltered (_
				     ("Process record ignores the memory change of instruction at address 0x%s because it can't get the value of the segment register.\n"),
				     paddr_nz (i386_record_pc));
error("3");
	      }
	    else
	      {
		if (i386_record_lea_modrm_addr (&addr))
		  {
		    return (-1);
		  }
		if (record_arch_list_add_mem (addr, 2))
		  {
		    return (-1);
		  }
		addr += 2;
		if (record_arch_list_add_mem (addr, 4))
		  {
		    return (-1);
		  }
	      }
	  }
	  break;
	case 1:
	  if (mod == 3)
	    {
	      switch (rm)
		{
		  /* monitor */
		case 0:
		  break;
		  /* mwait */
		case 1:
		  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
		    {
		      return (-1);
		    }
		  break;
		default:
		  i386_record_pc -= 3;
		  opcode = opcode << 8 | modrm;
		  goto no_support;
		  break;
		}
	    }
	  else
	    {
	      /* sidt */
	      if (override)
		{
		  if (record_debug)
		    printf_unfiltered (_
				       ("Process record ignores the memory change of instruction at address 0x%s because it can't get the value of the segment register.\n"),
				       paddr_nz (i386_record_pc));
		}
	      else
		{
		  uint32_t addr;

		  if (i386_record_lea_modrm_addr (&addr))
		    {
		      return (-1);
		    }
		  if (record_arch_list_add_mem (addr, 2))
		    {
		      return (-1);
		    }
		  addr += 2;
		  if (record_arch_list_add_mem (addr, 4))
		    {
		      return (-1);
		    }
		}
	    }
	  break;
	  /* lgdt */
	case 2:
	  /* lidt */
	case 3:
	  /* invlpg */
	case 7:
	default:
	  if (mod == 3)
	    {
	      i386_record_pc -= 3;
	      opcode = opcode << 8 | modrm;
	      goto no_support;
	    }
	  break;
	  /* smsw */
	case 4:
	  if (mod == 3)
	    {
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  else
	    {
	      ot = OT_WORD;
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  break;
	  /* lmsw */
	case 6:
	  break;
	}
      break;

      /* invd */
    case 0x0f08:
      /* wbinvd */
    case 0x0f09:
      break;

      /* arpl */
    case 0x63:
      ot = dflag ? OT_LONG : OT_WORD;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod != 3)
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* lar */
    case 0x0f02:
      /* lsl */
    case 0x0f03:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

    case 0x0f18:
      break;

      /* nop (multi byte) */
    case 0x0f19:
    case 0x0f1a:
    case 0x0f1b:
    case 0x0f1c:
    case 0x0f1d:
    case 0x0f1e:
    case 0x0f1f:
      break;

      /* mov reg, crN */
    case 0x0f20:
      /* mov crN, reg */
    case 0x0f22:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if ((modrm & 0xc0) != 0xc0)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}
      switch (reg)
	{
	case 0:
	case 2:
	case 3:
	case 4:
	case 8:
	  if (opcode & 2)
	    {
	    }
	  else
	    {
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  break;
	default:
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      break;

      /* mov reg, drN */
    case 0x0f21:
      /* mov drN, reg */
    case 0x0f23:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if ((modrm & 0xc0) != 0xc0 || reg == 4 || reg == 5 || reg >= 8)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}
      if (opcode & 2)
	{
	}
      else
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      break;

      /* clts */
    case 0x0f06:
      break;

      /* MMX/SSE/SSE2/PNI support */
      /* XXX */

    default:
      if (opcode > 0xff)
	{
	  i386_record_pc -= 2;
	}
      else
	{
	  i386_record_pc -= 1;
	}
      goto no_support;
      break;
    }

/* In the future, Maybe still need to deal with need_dasm */
  if (record_arch_list_add_reg (I386_EIP_REGNUM))
    {
      return (-1);
    }
  if (record_arch_list_add_end (0))
    {
      return (-1);
    }

  return (0);

no_support:
  printf_unfiltered (_
		     ("Process record doesn't support instruction 0x%02x at address 0x%s.\n"),
		     (unsigned int) (opcode), paddr_nz (i386_record_pc));
  return (-1);
}


static struct gdbarch *
i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;

  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* Allocate space for the new architecture.  */
  tdep = XCALLOC (1, struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  /* General-purpose registers.  */
  tdep->gregset = NULL;
  tdep->gregset_reg_offset = NULL;
  tdep->gregset_num_regs = I386_NUM_GREGS;
  tdep->sizeof_gregset = 0;

  /* Floating-point registers.  */
  tdep->fpregset = NULL;
  tdep->sizeof_fpregset = I387_SIZEOF_FSAVE;

  /* The default settings include the FPU registers, the MMX registers
     and the SSE registers.  This can be overridden for a specific ABI
     by adjusting the members `st0_regnum', `mm0_regnum' and
     `num_xmm_regs' of `struct gdbarch_tdep', otherwise the registers
     will show up in the output of "info all-registers".  Ideally we
     should try to autodetect whether they are available, such that we
     can prevent "info all-registers" from displaying registers that
     aren't available.

     NOTE: kevinb/2003-07-13: ... if it's a choice between printing
     [the SSE registers] always (even when they don't exist) or never
     showing them to the user (even when they do exist), I prefer the
     former over the latter.  */

  tdep->st0_regnum = I386_ST0_REGNUM;

  /* The MMX registers are implemented as pseudo-registers.  Put off
     calculating the register number for %mm0 until we know the number
     of raw registers.  */
  tdep->mm0_regnum = 0;

  /* I386_NUM_XREGS includes %mxcsr, so substract one.  */
  tdep->num_xmm_regs = I386_NUM_XREGS - 1;

  tdep->jb_pc_offset = -1;
  tdep->struct_return = pcc_struct_return;
  tdep->sigtramp_start = 0;
  tdep->sigtramp_end = 0;
  tdep->sigtramp_p = i386_sigtramp_p;
  tdep->sigcontext_addr = NULL;
  tdep->sc_reg_offset = NULL;
  tdep->sc_pc_offset = -1;
  tdep->sc_sp_offset = -1;

  /* The format used for `long double' on almost all i386 targets is
     the i387 extended floating-point format.  In fact, of all targets
     in the GCC 2.95 tree, only OSF/1 does it different, and insists
     on having a `long double' that's not `long' at all.  */
  set_gdbarch_long_double_format (gdbarch, floatformats_i387_ext);

  /* Although the i387 extended floating-point has only 80 significant
     bits, a `long double' actually takes up 96, probably to enforce
     alignment.  */
  set_gdbarch_long_double_bit (gdbarch, 96);

  /* The default ABI includes general-purpose registers, 
     floating-point registers, and the SSE registers.  */
  set_gdbarch_num_regs (gdbarch, I386_SSE_NUM_REGS);
  set_gdbarch_register_name (gdbarch, i386_register_name);
  set_gdbarch_register_type (gdbarch, i386_register_type);

  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, I386_ESP_REGNUM); /* %esp */
  set_gdbarch_pc_regnum (gdbarch, I386_EIP_REGNUM); /* %eip */
  set_gdbarch_ps_regnum (gdbarch, I386_EFLAGS_REGNUM); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, I386_ST0_REGNUM); /* %st(0) */

  /* NOTE: kettenis/20040418: GCC does have two possible register
     numbering schemes on the i386: dbx and SVR4.  These schemes
     differ in how they number %ebp, %esp, %eflags, and the
     floating-point registers, and are implemented by the arrays
     dbx_register_map[] and svr4_dbx_register_map in
     gcc/config/i386.c.  GCC also defines a third numbering scheme in
     gcc/config/i386.c, which it designates as the "default" register
     map used in 64bit mode.  This last register numbering scheme is
     implemented in dbx64_register_map, and is used for AMD64; see
     amd64-tdep.c.

     Currently, each GCC i386 target always uses the same register
     numbering scheme across all its supported debugging formats
     i.e. SDB (COFF), stabs and DWARF 2.  This is because
     gcc/sdbout.c, gcc/dbxout.c and gcc/dwarf2out.c all use the
     DBX_REGISTER_NUMBER macro which is defined by each target's
     respective config header in a manner independent of the requested
     output debugging format.

     This does not match the arrangement below, which presumes that
     the SDB and stabs numbering schemes differ from the DWARF and
     DWARF 2 ones.  The reason for this arrangement is that it is
     likely to get the numbering scheme for the target's
     default/native debug format right.  For targets where GCC is the
     native compiler (FreeBSD, NetBSD, OpenBSD, GNU/Linux) or for
     targets where the native toolchain uses a different numbering
     scheme for a particular debug format (stabs-in-ELF on Solaris)
     the defaults below will have to be overridden, like
     i386_elf_init_abi() does.  */

  /* Use the dbx register numbering scheme for stabs and COFF.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);
  set_gdbarch_sdb_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);

  /* Use the SVR4 register numbering scheme for DWARF 2.  */
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, i386_svr4_reg_to_regnum);

  /* We don't set gdbarch_stab_reg_to_regnum, since ECOFF doesn't seem to
     be in use on any of the supported i386 targets.  */

  set_gdbarch_print_float_info (gdbarch, i387_print_float_info);

  set_gdbarch_get_longjmp_target (gdbarch, i386_get_longjmp_target);

  /* Call dummy code.  */
  set_gdbarch_push_dummy_call (gdbarch, i386_push_dummy_call);

  set_gdbarch_convert_register_p (gdbarch, i386_convert_register_p);
a2831 2
  set_gdbarch_process_record (gdbarch, i386_process_record);

@


1.266.2.1
log
@2008-09-30  Hui Zhu  <teawater@@gmail.com>

	Add process record and replay to i386 architecture.
	* i386-linux-tdep.c (linux_record_tdep): New static variable.
	I386 Linux record target-dependent stuff.
	(i386_linux_intx80_sysenter_record): New function. Record the
	running message of I386 Linux system call.
	(i386_linux_init_ab): Initialize the linux_record_tdep. Add
	i386_linux_intx80_sysenter_record to struct tdep.
	* i386-tdep.c (i386_record_modrm, i386_record_lea_modrm_addr,
	i386_record_lea_modrm, i386_record): New functions. Record the
	running message of I386 instruction.
	(i386_gdbarch_init): Add i386_record to struct gdbarch.
	* i386-tdep.h (gdbarch_tdep): Add elements "i386_intx80_record"
	and "i386_sysenter_record" to be the interfaces that record the
	running message of instruction "intx80" and "sysenter".
	* gdbarch.sh: Change process_record and process_record_dasm
	to multi-arch model.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@a51 3
#include "record.h"
#include <stdint.h>

d2641 15
a2655 13
#define PREFIX_REPZ	0x01
#define PREFIX_REPNZ	0x02
#define PREFIX_LOCK	0x04
#define PREFIX_DATA	0x08
#define PREFIX_ADDR	0x10

/* operand size */
enum
{
  OT_BYTE = 0,
  OT_WORD,
  OT_LONG,
};
d2657 5
a2661 12
/* i386 arith/logic operations */
enum
{
  OP_ADDL,
  OP_ORL,
  OP_ADCL,
  OP_SBBL,
  OP_ANDL,
  OP_SUBL,
  OP_XORL,
  OP_CMPL,
};
d2663 3
a2665 7
static int aflag = 1;
static int dflag = 1;
static int override = 0;
static uint8_t modrm;
static uint8_t mod, reg, rm;
static int ot;
static CORE_ADDR i386_record_pc;
d2667 8
a2674 15
/* Parse "modrm" part in current memory address that i386_record_pc point to.
   Return -1 if something wrong. */
static int
i386_record_modrm (void)
{
  if (target_read_memory (i386_record_pc, &modrm, 1))
    {
      printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
			 paddr_nz (i386_record_pc));
      return (-1);
    }
  i386_record_pc++;
  mod = (modrm >> 6) & 3;
  reg = (modrm >> 3) & 7;
  rm = modrm & 7;
d2676 4
a2679 2
  return (0);
}
d2681 1
a2681 18
/* Get the memory address that current instruction  write to and set it to
   the argument "addr".
   Return -1 if something wrong. */
static int
i386_record_lea_modrm_addr (uint32_t * addr)
{
  uint8_t tmpu8;
  uint16_t tmpu16;
  uint32_t tmpu32;

  *addr = 0;
  if (aflag)
    {
      /* 32 bits */
      int havesib = 0;
      uint8_t scale = 0;
      uint8_t index = 0;
      uint8_t base = rm;
d2683 4
a2686 14
      if (base == 4)
	{
	  havesib = 1;
	  if (target_read_memory (i386_record_pc, &tmpu8, 1))
	    {
	      printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				 paddr_nz (i386_record_pc));
	      return (-1);
	    }
	  i386_record_pc++;
	  scale = (tmpu8 >> 6) & 3;
	  index = ((tmpu8 >> 3) & 7);
	  base = (tmpu8 & 7);
	}
d2688 2
a2689 39
      switch (mod)
	{
	case 0:
	  if ((base & 7) == 5)
	    {
	      base = 0xff;
	      if (target_read_memory (i386_record_pc, (gdb_byte *) addr, 4))
		{
		  printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				     paddr_nz (i386_record_pc));
		  return (-1);
		}
	      i386_record_pc += 4;
	    }
	  else
	    {
	      *addr = 0;
	    }
	  break;
	case 1:
	  if (target_read_memory (i386_record_pc, &tmpu8, 1))
	    {
	      printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				 paddr_nz (i386_record_pc));
	      return (-1);
	    }
	  i386_record_pc++;
	  *addr = (int8_t) tmpu8;
	  break;
	case 2:
	  if (target_read_memory (i386_record_pc, (gdb_byte *) addr, 4))
	    {
	      printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				 paddr_nz (i386_record_pc));
	      return (-1);
	    }
	  i386_record_pc += 4;
	  break;
	}
d2691 9
a2699 5
      if (base != 0xff)
	{
	  regcache_raw_read (record_regcache, base, (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	}
d2701 5
a2705 53
      /* XXX: index == 4 is always invalid */
      if (havesib && (index != 4 || scale != 0))
	{
	  regcache_raw_read (record_regcache, index, (gdb_byte *) & tmpu32);
	  *addr += tmpu32 << scale;
	}
    }
  else
    {
      /* 16 bits */
      switch (mod)
	{
	case 0:
	  if (rm == 6)
	    {
	      if (target_read_memory
		  (i386_record_pc, (gdb_byte *) & tmpu16, 2))
		{
		  printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				     paddr_nz (i386_record_pc));
		  return (-1);
		}
	      i386_record_pc += 2;
	      *addr = (int16_t) tmpu16;
	      rm = 0;
	      goto no_rm;
	    }
	  else
	    {
	      *addr = 0;
	    }
	  break;
	case 1:
	  if (target_read_memory (i386_record_pc, &tmpu8, 1))
	    {
	      printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				 paddr_nz (i386_record_pc));
	      return (-1);
	    }
	  i386_record_pc++;
	  *addr = (int8_t) tmpu8;
	  break;
	case 2:
	  if (target_read_memory (i386_record_pc, (gdb_byte *) & tmpu16, 2))
	    {
	      printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				 paddr_nz (i386_record_pc));
	      return (-1);
	    }
	  i386_record_pc += 2;
	  *addr = (int16_t) tmpu16;
	  break;
	}
d2707 4
a2710 57
      switch (rm)
	{
	case 0:
	  regcache_raw_read (record_regcache, I386_EBX_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (record_regcache, I386_ESI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 1:
	  regcache_raw_read (record_regcache, I386_EBX_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (record_regcache, I386_EDI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 2:
	  regcache_raw_read (record_regcache, I386_EBP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (record_regcache, I386_ESI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 3:
	  regcache_raw_read (record_regcache, I386_EBP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (record_regcache, I386_EDI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 4:
	  regcache_raw_read (record_regcache, I386_ESI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 5:
	  regcache_raw_read (record_regcache, I386_EDI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 6:
	  regcache_raw_read (record_regcache, I386_EBP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 7:
	  regcache_raw_read (record_regcache, I386_EBX_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	}
      *addr &= 0xffff;
    }
d2712 5
a2716 3
no_rm:
  return (0);
}
d2718 5
a2722 7
/* Record the value of the memory that willbe changed in current instruction
   to "record_arch_list".
   Return -1 if something wrong. */
static int
i386_record_lea_modrm (void)
{
  uint32_t addr;
d2724 10
a2733 8
  if (override)
    {
      if (record_debug)
	printf_unfiltered (_
			   ("Record: Record ignore the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
			   paddr_nz (i386_record_pc));
      return (0);
    }
d2735 7
a2741 4
  if (i386_record_lea_modrm_addr (&addr))
    {
      return (-1);
    }
d2743 10
a2752 4
  if (record_arch_list_add_mem (addr, 1 << ot))
    {
      return (-1);
    }
d2754 3
a2756 2
  return (0);
}
d2758 2
a2759 11
/* Parse the current instruction and record the values of the registers and
   memory that will be changed in current instruction to "record_arch_list".
   Return -1 if something wrong. */
static int
i386_process_record (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  int prefixes = 0;
  uint8_t tmpu8;
  uint16_t tmpu16;
  uint32_t tmpu32;
  uint32_t opcode;
d2761 2
a2762 4
  i386_record_pc = addr;
  aflag = 1;
  dflag = 1;
  override = 0;
d2764 1
a2764 5
  if (record_debug > 1)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: i386_record pc = 0x%s\n",
			  paddr_nz (i386_record_pc));
    }
d2766 1
a2766 59
  /* prefixes */
  while (1)
    {
      if (target_read_memory (i386_record_pc, &tmpu8, 1))
	{
	  printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
			     paddr_nz (i386_record_pc));
	  return (-1);
	}
      i386_record_pc++;
      switch (tmpu8)
	{
	case 0xf3:
	  prefixes |= PREFIX_REPZ;
	  break;
	case 0xf2:
	  prefixes |= PREFIX_REPNZ;
	  break;
	case 0xf0:
	  prefixes |= PREFIX_LOCK;
	  break;
	case 0x2e:
	  override = I386_CS_REGNUM;
	  break;
	case 0x36:
	  override = I386_SS_REGNUM;
	  break;
	case 0x3e:
	  override = I386_DS_REGNUM;
	  break;
	case 0x26:
	  override = I386_ES_REGNUM;
	  break;
	case 0x64:
	  override = I386_FS_REGNUM;
	  break;
	case 0x65:
	  override = I386_GS_REGNUM;
	  break;
	case 0x66:
	  prefixes |= PREFIX_DATA;
	  break;
	case 0x67:
	  prefixes |= PREFIX_ADDR;
	  break;
	default:
	  goto out_prefixes;
	  break;
	}
    }
out_prefixes:
  if (prefixes & PREFIX_DATA)
    {
      dflag ^= 1;
    }
  if (prefixes & PREFIX_ADDR)
    {
      aflag ^= 1;
    }
d2768 2
a2769 16
  /* now check op code */
  opcode = (uint32_t) tmpu8;
reswitch:
  switch (opcode)
    {
    case 0x0f:
      if (target_read_memory (i386_record_pc, &tmpu8, 1))
	{
	  printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
			     paddr_nz (i386_record_pc));
	  return (-1);
	}
      i386_record_pc++;
      opcode = (uint16_t) tmpu8 | 0x0f00;
      goto reswitch;
      break;
d2771 3
a2773 19
      /* arith & logic */
    case 0x00 ... 0x05:
    case 0x08 ... 0x0d:
    case 0x10 ... 0x15:
    case 0x18 ... 0x1d:
    case 0x20 ... 0x25:
    case 0x28 ... 0x2d:
    case 0x30 ... 0x35:
    case 0x38 ... 0x3d:
      if (((opcode >> 3) & 7) != OP_CMPL)
	{
	  if ((opcode & 1) == 0)
	    {
	      ot = OT_BYTE;
	    }
	  else
	    {
	      ot = dflag + OT_WORD;
	    }
d2775 1
a2775 56
	  switch ((opcode >> 1) & 3)
	    {
	      /* OP Ev, Gv */
	    case 0:
	      if (i386_record_modrm ())
		{
		  return (-1);
		}
	      if (mod != 3)
		{
		  if (i386_record_lea_modrm ())
		    {
		      return (-1);
		    }
		}
	      else
		{
		  if (ot == OT_BYTE)
		    {
		      rm &= 0x3;
		    }
		  if (record_arch_list_add_reg (rm))
		    {
		      return (-1);
		    }
		}
	      break;
	      /* OP Gv, Ev */
	    case 1:
	      if (i386_record_modrm ())
		{
		  return (-1);
		}
	      if (ot == OT_BYTE)
		{
		  reg &= 0x3;
		}
	      if (record_arch_list_add_reg (reg))
		{
		  return (-1);
		}
	      break;
	      /* OP A, Iv */
	    case 2:
	      if (record_arch_list_add_reg (I386_EAX_REGNUM))
		{
		  return (-1);
		}
	      break;
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;
d2777 1
a2777 6
      /* GRP1 */
    case 0x80 ... 0x83:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
d2779 2
a2780 10
      if (reg != OP_CMPL)
	{
	  if ((opcode & 1) == 0)
	    {
	      ot = OT_BYTE;
	    }
	  else
	    {
	      ot = dflag + OT_WORD;
	    }
d2782 1
a2782 2368
	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* inv */
    case 0x40 ... 0x47:
      /* dec */
    case 0x48 ... 0x4f:
      if (record_arch_list_add_reg (opcode & 7))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* GRP3 */
    case 0xf6:
    case 0xf7:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}
      if (i386_record_modrm ())
	{
	  return (-1);
	}

      switch (reg)
	{
	  /* test */
	case 0:
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	  /* not */
	case 2:
	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (ot == OT_BYTE)
		{
		  rm &= 0x3;
		}
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  break;
	  /* neg */
	case 3:
	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (ot == OT_BYTE)
		{
		  rm &= 0x3;
		}
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	  /* mul */
	case 4:
	  /* imul */
	case 5:
	  /* div */
	case 6:
	  /* idiv */
	case 7:
	  if (record_arch_list_add_reg (I386_EAX_REGNUM))
	    {
	      return (-1);
	    }
	  if (ot != OT_BYTE)
	    {
	      if (record_arch_list_add_reg (I386_EDX_REGNUM))
		{
		  return (-1);
		}
	    }
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	default:
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      break;

      /* GRP4 */
    case 0xfe:
      /* GRP5 */
    case 0xff:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (reg >= 2 && opcode == 0xfe)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}

      switch (reg)
	{
	  /* inc */
	case 0:
	  /* dec */
	case 1:
	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (ot == OT_BYTE)
		{
		  rm &= 0x3;
		}
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	  /* call */
	case 2:
	  /* push */
	case 6:
	  if (record_arch_list_add_reg (I386_ESP_REGNUM))
	    {
	      return (-1);
	    }
	  regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem
	      ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	    {
	      return (-1);
	    }
	  break;
	  /* lcall */
	case 3:
	  if (record_arch_list_add_reg (I386_ESP_REGNUM))
	    {
	      return (-1);
	    }
	  if (record_arch_list_add_reg (I386_CS_REGNUM))
	    {
	      return (-1);
	    }
	  regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem
	      ((CORE_ADDR) tmpu32 - (1 << (dflag + 2)), (1 << (dflag + 2))))
	    {
	      return (-1);
	    }
	  break;
	  /* jmp */
	case 4:
	  /* ljmp */
	case 5:
	  break;
	default:
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      break;

      /* test */
    case 0x84:
    case 0x85:
    case 0xa8:
    case 0xa9:
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* CWDE/CBW */
    case 0x98:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* CDQ/CWD */
    case 0x99:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EDX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* imul */
    case 0x0faf:
    case 0x69:
    case 0x6b:
      ot = dflag + OT_WORD;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (ot == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* xadd */
    case 0x0fc0:
    case 0x0fc1:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (ot == OT_BYTE)
	    {
	      reg &= 0x3;
	    }
	  if (record_arch_list_add_reg (reg))
	    {
	      return (-1);
	    }
	  if (ot == OT_BYTE)
	    {
	      rm &= 0x3;
	    }
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	  if (ot == OT_BYTE)
	    {
	      reg &= 0x3;
	    }
	  if (record_arch_list_add_reg (reg))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* cmpxchg */
    case 0x0fb0:
    case 0x0fb1:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (record_arch_list_add_reg (I386_EAX_REGNUM))
	    {
	      return (-1);
	    }
	  if (ot == OT_BYTE)
	    {
	      reg &= 0x3;
	    }
	  if (record_arch_list_add_reg (reg))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (record_arch_list_add_reg (I386_EAX_REGNUM))
	    {
	      return (-1);
	    }
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* cmpxchg8b */
    case 0x0fc7:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EDX_REGNUM))
	{
	  return (-1);
	}
      if (i386_record_lea_modrm ())
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* push */
    case 0x50 ... 0x57:
    case 0x68:
    case 0x6a:
      /* push es */
    case 0x06:
      /* push cs */
    case 0x0e:
      /* push ss */
    case 0x16:
      /* push ds */
    case 0x1e:
      /* push fs */
    case 0x0fa0:
      /* push gs */
    case 0x0fa8:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	{
	  return (-1);
	}
      break;

      /* pop */
    case 0x58 ... 0x5f:
      ot = dflag + OT_WORD;
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (ot == OT_BYTE)
	{
	  opcode &= 0x3;
	}
      if (record_arch_list_add_reg (opcode & 0x7))
	{
	  return (-1);
	}
      break;

      /* pusha */
    case 0x60:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 4)), (1 << (dflag + 4))))
	{
	  return (-1);
	}
      break;

      /* popa */
    case 0x61:
      for (tmpu8 = I386_EAX_REGNUM; tmpu8 <= I386_EDI_REGNUM; tmpu8++)
	{
	  if (record_arch_list_add_reg (tmpu8))
	    {
	      return (-1);
	    }
	}
      break;

      /* pop */
    case 0x8f:
      ot = dflag + OT_WORD;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      break;

      /* enter */
    case 0xc8:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EBP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	{
	  return (-1);
	}
      break;

      /* leave */
    case 0xc9:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EBP_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop es */
    case 0x07:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ES_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop ss */
    case 0x17:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_SS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop ds */
    case 0x1f:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_DS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop fs */
    case 0x0fa1:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_FS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop gs */
    case 0x0fa9:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_GS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* mov */
    case 0x88:
    case 0x89:
    case 0xc6:
    case 0xc7:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}

      if (i386_record_modrm ())
	{
	  return (-1);
	}

      if (mod != 3)
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (ot == OT_BYTE)
	    {
	      rm &= 0x3;
	    }
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;
      /* mov */
    case 0x8a:
    case 0x8b:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}

      if (i386_record_modrm ())
	{
	  return (-1);
	}

      if (ot == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}

      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* mov seg */
    case 0x8e:
      if (i386_record_modrm ())
	{
	  return (-1);
	}

      switch (reg)
	{
	case 0:
	  tmpu8 = I386_ES_REGNUM;
	  break;
	case 2:
	  tmpu8 = I386_SS_REGNUM;
	  break;
	case 3:
	  tmpu8 = I386_DS_REGNUM;
	  break;
	case 4:
	  tmpu8 = I386_FS_REGNUM;
	  break;
	case 5:
	  tmpu8 = I386_GS_REGNUM;
	  break;
	default:
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      if (record_arch_list_add_reg (tmpu8))
	{
	  return (-1);
	}

      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* mov seg */
    case 0x8c:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (reg > 5)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}

      if (mod == 3)
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  ot = OT_WORD;
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}

      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* movzbS */
    case 0x0fb6:
      /* movzwS */
    case 0x0fb7:
      /* movsbS */
    case 0x0fbe:
      /* movswS */
    case 0x0fbf:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      break;

      /* lea */
    case 0x8d:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}

      ot = dflag;
      if (ot == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      break;

      /* mov EAX */
    case 0xa0:
    case 0xa1:
      /* xlat */
    case 0xd7:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* mov EAX */
    case 0xa2:
    case 0xa3:
      {
	uint32_t addr;

	if (override)
	  {
	    if (record_debug)
	      printf_unfiltered (_
				 ("Record: Record ignore the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
				 paddr_nz (i386_record_pc));
	  }
	else
	  {
	    if ((opcode & 1) == 0)
	      {
		ot = OT_BYTE;
	      }
	    else
	      {
		ot = dflag + OT_WORD;
	      }
	    if (aflag)
	      {
		if (target_read_memory
		    (i386_record_pc, (gdb_byte *) & addr, 4))
		  {
		    printf_unfiltered (_
				       ("Record: read memeory 0x%s error.\n"),
				       paddr_nz (i386_record_pc));
		    return (-1);
		  }
		i386_record_pc += 4;
	      }
	    else
	      {
		if (target_read_memory
		    (i386_record_pc, (gdb_byte *) & tmpu16, 4))
		  {
		    printf_unfiltered (_
				       ("Record: read memeory 0x%s error.\n"),
				       paddr_nz (i386_record_pc));
		    return (-1);
		  }
		i386_record_pc += 2;
		addr = tmpu16;
	      }
	    if (record_arch_list_add_mem (addr, 1 << ot))
	      {
		return (-1);
	      }
	  }
      }
      break;

      /* mov R, Ib */
    case 0xb0 ... 0xb7:
      if (record_arch_list_add_reg ((opcode & 0x7) & 0x3))
	{
	  return (-1);
	}
      break;

      /* mov R, Iv */
    case 0xb8 ... 0xbf:
      if (record_arch_list_add_reg (opcode & 0x7))
	{
	  return (-1);
	}
      break;

      /* xchg R, EAX */
    case 0x91 ... 0x97:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (opcode & 0x7))
	{
	  return (-1);
	}
      break;

      /* xchg Ev, Gv */
    case 0x86:
    case 0x87:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}

      if (i386_record_modrm ())
	{
	  return (-1);
	}

      if (mod == 3)
	{
	  if (ot == OT_BYTE)
	    {
	      rm &= 0x3;
	    }
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}

      if (ot == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      break;

      /* les Gv */
    case 0xc4:
      /* lds Gv */
    case 0xc5:
      /* lss Gv */
    case 0x0fb2:
      /* lfs Gv */
    case 0x0fb4:
      /* lgs Gv */
    case 0x0fb5:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (opcode > 0xff)
	    {
	      i386_record_pc -= 3;
	    }
	  else
	    {
	      i386_record_pc -= 2;
	    }
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}

      switch (opcode)
	{
	  /* les Gv */
	case 0xc4:
	  tmpu8 = I386_ES_REGNUM;
	  break;
	  /* lds Gv */
	case 0xc5:
	  tmpu8 = I386_DS_REGNUM;
	  break;
	  /* lss Gv */
	case 0x0fb2:
	  tmpu8 = I386_SS_REGNUM;
	  break;
	  /* lfs Gv */
	case 0x0fb4:
	  tmpu8 = I386_FS_REGNUM;
	  break;
	  /* lgs Gv */
	case 0x0fb5:
	  tmpu8 = I386_GS_REGNUM;
	  break;
	}
      if (record_arch_list_add_reg (tmpu8))
	{
	  return (-1);
	}

      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      break;

      /* shifts */
    case 0xc0:
    case 0xc1:
    case 0xd0:
    case 0xd1:
    case 0xd2:
    case 0xd3:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}

      if (i386_record_modrm ())
	{
	  return (-1);
	}

      if (mod != 3 && (opcode == 0xd2 || opcode == 0xd3))
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (ot == OT_BYTE)
	    {
	      rm &= 0x3;
	    }
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}

      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

    case 0x0fa4:
    case 0x0fa5:
    case 0x0fac:
    case 0x0fad:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      break;

      /* floats */
      /* It just record the memory change of instrcution. */
    case 0xd8 ... 0xdf:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      reg |= ((opcode & 7) << 3);
      if (mod != 3)
	{
	  /* memory */
	  uint32_t addr;

	  if (i386_record_lea_modrm_addr (&addr))
	    {
	      return (-1);
	    }
	  switch (reg)
	    {
	    case 0x00 ... 0x07:
	    case 0x10 ... 0x17:
	    case 0x20 ... 0x27:
	    case 0x30 ... 0x37:
	      break;
	    case 0x08:
	    case 0x0a:
	    case 0x0b:
	    case 0x18 ... 0x1b:
	    case 0x28 ... 0x2b:
	    case 0x38 ... 0x3b:
	      switch (reg & 7)
		{
		case 0:
		  break;
		case 1:
		  switch (reg >> 4)
		    {
		    case 0:
		      if (record_arch_list_add_mem (addr, 4))
			{
			  return (-1);
			}
		      break;
		    case 2:
		      if (record_arch_list_add_mem (addr, 8))
			{
			  return (-1);
			}
		      break;
		    case 3:
		    default:
		      if (record_arch_list_add_mem (addr, 2))
			{
			  return (-1);
			}
		      break;
		    }
		  break;
		default:
		  switch (reg >> 4)
		    {
		    case 0:
		    case 1:
		      if (record_arch_list_add_mem (addr, 4))
			{
			  return (-1);
			}
		      break;
		    case 2:
		      if (record_arch_list_add_mem (addr, 8))
			{
			  return (-1);
			}
		      break;
		    case 3:
		    default:
		      if (record_arch_list_add_mem (addr, 2))
			{
			  return (-1);
			}
		      break;
		    }
		  break;
		}
	      break;
	    case 0x0c:
	    case 0x0d:
	    case 0x1d:
	    case 0x2c:
	    case 0x3c:
	    case 0x3d:
	      break;
	    case 0x0e:
	      if (dflag)
		{
		  if (record_arch_list_add_mem (addr, 28))
		    {
		      return (-1);
		    }
		}
	      else
		{
		  if (record_arch_list_add_mem (addr, 14))
		    {
		      return (-1);
		    }
		}
	      break;
	    case 0x0f:
	    case 0x2f:
	      if (record_arch_list_add_mem (addr, 2))
		{
		  return (-1);
		}
	      break;
	    case 0x1f:
	    case 0x3e:
	      if (record_arch_list_add_mem (addr, 10))
		{
		  return (-1);
		}
	      break;
	    case 0x2e:
	      if (dflag)
		{
		  if (record_arch_list_add_mem (addr, 28))
		    {
		      return (-1);
		    }
		  addr += 28;
		}
	      else
		{
		  if (record_arch_list_add_mem (addr, 14))
		    {
		      return (-1);
		    }
		  addr += 14;
		}
	      if (record_arch_list_add_mem (addr, 80))
		{
		  return (-1);
		}
	      break;
	    case 0x3f:
	      if (record_arch_list_add_mem (addr, 8))
		{
		  return (-1);
		}
	      break;
	    default:
	      i386_record_pc -= 2;
	      opcode = opcode << 8 | modrm;
	      goto no_support;
	      break;
	    }
	}
      break;

      /* string ops */
      /* movsS */
    case 0xa4:
    case 0xa5:
      /* stosS */
    case 0xaa:
    case 0xab:
      /* insS */
    case 0x6c:
    case 0x6d:
      {
	uint32_t addr;

	if ((opcode & 1) == 0)
	  {
	    ot = OT_BYTE;
	  }
	else
	  {
	    ot = dflag + OT_WORD;
	  }
	if (opcode == 0xa4 || opcode == 0xa5)
	  {
	    if (record_arch_list_add_reg (I386_ESI_REGNUM))
	      {
		return (-1);
	      }
	  }
	if (record_arch_list_add_reg (I386_EDI_REGNUM))
	  {
	    return (-1);
	  }

	regcache_raw_read (record_regcache, I386_EDI_REGNUM,
			   (gdb_byte *) & addr);
	if (!aflag)
	  {
	    addr &= 0xffff;
	    /* addr += ((uint32_t)read_register (I386_ES_REGNUM)) << 4; */
            if (record_debug)
	      printf_unfiltered (_
			         ("Record: Record ignore the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
			   paddr_nz (i386_record_pc));
	  }

	if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	  {
	    uint32_t count;

	    regcache_raw_read (record_regcache, I386_ECX_REGNUM,
			       (gdb_byte *) & count);
	    if (!aflag)
	      {
		count &= 0xffff;
	      }

	    regcache_raw_read (record_regcache, I386_EFLAGS_REGNUM,
			       (gdb_byte *) & tmpu32);
	    if ((tmpu32 >> 10) & 0x1)
	      {
		addr -= (count - 1) * (1 << ot);
	      }

	    if (aflag)
	      {
	        if (record_arch_list_add_mem (addr, count * (1 << ot)))
	          {
		    return (-1);
	          }
	      }

	    if (record_arch_list_add_reg (I386_ECX_REGNUM))
	      {
		return (-1);
	      }
	  }
	else
	  {
	    if (aflag)
	      {
	        if (record_arch_list_add_mem (addr, 1 << ot))
	          {
		    return (-1);
	          }
	      }
	  }
      }
      break;

      /* lodsS */
    case 0xac:
    case 0xad:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ESI_REGNUM))
	{
	  return (-1);
	}
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	{
	  if (record_arch_list_add_reg (I386_ECX_REGNUM))
	    {
	      return (-1);
	    }
	}
      break;

      /* outsS */
    case 0x6e:
    case 0x6f:
      if (record_arch_list_add_reg (I386_ESI_REGNUM))
	{
	  return (-1);
	}
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	{
	  if (record_arch_list_add_reg (I386_ECX_REGNUM))
	    {
	      return (-1);
	    }
	}
      break;

      /* scasS */
    case 0xae:
    case 0xaf:
      if (record_arch_list_add_reg (I386_EDI_REGNUM))
	{
	  return (-1);
	}
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	{
	  if (record_arch_list_add_reg (I386_ECX_REGNUM))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* cmpsS */
    case 0xa6:
    case 0xa7:
      if (record_arch_list_add_reg (I386_EDI_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ESI_REGNUM))
	{
	  return (-1);
	}
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	{
	  if (record_arch_list_add_reg (I386_ECX_REGNUM))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* port I/O */
    case 0xe4:
    case 0xe5:
    case 0xec:
    case 0xed:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      break;

    case 0xe6:
    case 0xe7:
    case 0xee:
    case 0xef:
      break;

      /* control */
      /* ret im */
    case 0xc2:
      /* ret */
    case 0xc3:
      /* lret im */
    case 0xca:
      /* lret */
    case 0xcb:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_CS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* iret */
    case 0xcf:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_CS_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* call im */
    case 0xe8:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	{
	  return (-1);
	}
      break;

      /* lcall im */
    case 0x9a:
      if (record_arch_list_add_reg (I386_CS_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 2)), (1 << (dflag + 2))))
	{
	  return (-1);
	}
      break;

      /* jmp im */
    case 0xe9:
      /* ljmp im */
    case 0xea:
      /* jmp Jb */
    case 0xeb:
      /* jcc Jb */
    case 0x70 ... 0x7f:
      /* jcc Jv */
    case 0x0f80 ... 0x0f8f:
      break;

      /* setcc Gv */
    case 0x0f90 ... 0x0f9f:
      ot = OT_BYTE;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (record_arch_list_add_reg (rm & 0x3))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      break;

      /* cmov Gv, Ev */
    case 0x0f40 ... 0x0f4f:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (dflag == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg & 0x3))
	{
	  return (-1);
	}
      break;

      /* flags */
      /* pushf */
    case 0x9c:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	{
	  return (-1);
	}
      break;

      /* popf */
    case 0x9d:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* sahf */
    case 0x9e:
      /* cmc */
    case 0xf5:
      /* clc */
    case 0xf8:
      /* stc */
    case 0xf9:
      /* cld */
    case 0xfc:
      /* std */
    case 0xfd:
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* lahf */
    case 0x9f:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* bit operations */
      /* bt/bts/btr/btc Gv, im */
    case 0x0fba:
      /* bts */
    case 0x0fab:
      /* btr */
    case 0x0fb3:
      /* btc */
    case 0x0fbb:
      ot = dflag + OT_WORD;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (reg < 4)
	{
	  i386_record_pc -= 3;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}
      reg -= 4;
      if (reg != 0)
	{
	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* bt Gv, Ev */
    case 0x0fa3:
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* bsf */
    case 0x0fbc:
      /* bsr */
    case 0x0fbd:
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* bcd */
      /* daa */
    case 0x27:
      /* das */
    case 0x2f:
      /* aaa */
    case 0x37:
      /* aas */
    case 0x3f:
      /* aam */
    case 0xd4:
      /* aad */
    case 0xd5:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* misc */
      /* nop */
    case 0x90:
      if (prefixes & PREFIX_LOCK)
	{
	  i386_record_pc -= 1;
	  goto no_support;
	}
      break;

      /* fwait */
      /* XXX */
    case 0x9b:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction fwait.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

      /* int3 */
      /* XXX */
    case 0xcc:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction int3.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

      /* int */
      /* XXX */
    case 0xcd:
      {
	int ret;
	if (target_read_memory (i386_record_pc, &tmpu8, 1))
	  {
	    printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
			       paddr_nz (i386_record_pc));
	    return (-1);
	  }
	i386_record_pc++;
	if (tmpu8 != 0x80
	    || gdbarch_tdep (gdbarch)->i386_intx80_record == NULL)
	  {
	    printf_unfiltered (_
			       ("Record: record and reverse function don't support instruction int 0x%02x.\n"),
			       tmpu8);
	    i386_record_pc -= 2;
	    goto no_support;
	  }
	ret = gdbarch_tdep (gdbarch)->i386_intx80_record ();
	if (ret)
	  {
	    return (ret);
	  }
      }
      break;

      /* into */
      /* XXX */
    case 0xce:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction into.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

      /* cli */
    case 0xfa:
      /* sti */
    case 0xfb:
      break;

      /* bound */
    case 0x62:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction bound.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

      /* bswap reg */
    case 0x0fc8 ... 0x0fcf:
      if (record_arch_list_add_reg (opcode & 7))
	{
	  return (-1);
	}
      break;

      /* salc */
    case 0xd6:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* loopnz */
    case 0xe0:
      /* loopz */
    case 0xe1:
      /* loop */
    case 0xe2:
      /* jecxz */
    case 0xe3:
      if (record_arch_list_add_reg (I386_ECX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* wrmsr */
    case 0x0f30:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction wrmsr.\n"));
      i386_record_pc -= 2;
      goto no_support;
      break;

      /* rdmsr */
    case 0x0f32:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction rdmsr.\n"));
      i386_record_pc -= 2;
      goto no_support;
      break;

      /* rdtsc */
    case 0x0f31:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction rdtsc.\n"));
      i386_record_pc -= 2;
      goto no_support;
      break;

      /* sysenter */
    case 0x0f34:
      {
	int ret;
	if (gdbarch_tdep (gdbarch)->i386_sysenter_record == NULL)
	  {
	    printf_unfiltered (_
			       ("Record: record and reverse function don't support instruction sysenter.\n"));
	    i386_record_pc -= 2;
	    goto no_support;
	  }
	ret = gdbarch_tdep (gdbarch)->i386_sysenter_record ();
	if (ret)
	  {
	    return (ret);
	  }
      }
      break;

      /* sysexit */
    case 0x0f35:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction sysexit.\n"));
      i386_record_pc -= 2;
      goto no_support;
      break;

      /* cpuid */
    case 0x0fa2:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ECX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EDX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EBX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* hlt */
    case 0xf4:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction hlt.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

    case 0x0f00:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      switch (reg)
	{
	  /* sldt */
	case 0:
	  /* str */
	case 1:
	  if (mod == 3)
	    {
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  else
	    {
	      ot = OT_WORD;
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  break;
	  /* lldt */
	case 2:
	  /* ltr */
	case 3:
	  break;
	  /* verr */
	case 4:
	  /* verw */
	case 5:
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	default:
	  i386_record_pc -= 3;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      break;

    case 0x0f01:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      switch (reg)
	{
	  /* sgdt */
	case 0:
	  {
	    uint32_t addr;

	    if (mod == 3)
	      {
		i386_record_pc -= 3;
		opcode = opcode << 8 | modrm;
		goto no_support;
	      }

	    if (override)
	      {
		if (record_debug)
		  printf_unfiltered (_
				     ("Record: Record ignore the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
				     paddr_nz (i386_record_pc));
error("3");
	      }
	    else
	      {
		if (i386_record_lea_modrm_addr (&addr))
		  {
		    return (-1);
		  }
		if (record_arch_list_add_mem (addr, 2))
		  {
		    return (-1);
		  }
		addr += 2;
		if (record_arch_list_add_mem (addr, 4))
		  {
		    return (-1);
		  }
	      }
	  }
	  break;
	case 1:
	  if (mod == 3)
	    {
	      switch (rm)
		{
		  /* monitor */
		case 0:
		  break;
		  /* mwait */
		case 1:
		  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
		    {
		      return (-1);
		    }
		  break;
		default:
		  i386_record_pc -= 3;
		  opcode = opcode << 8 | modrm;
		  goto no_support;
		  break;
		}
	    }
	  else
	    {
	      /* sidt */
	      if (override)
		{
		  if (record_debug)
		    printf_unfiltered (_
				       ("Record: Record ignore the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
				       paddr_nz (i386_record_pc));
		}
	      else
		{
		  uint32_t addr;

		  if (i386_record_lea_modrm_addr (&addr))
		    {
		      return (-1);
		    }
		  if (record_arch_list_add_mem (addr, 2))
		    {
		      return (-1);
		    }
		  addr += 2;
		  if (record_arch_list_add_mem (addr, 4))
		    {
		      return (-1);
		    }
		}
	    }
	  break;
	  /* lgdt */
	case 2:
	  /* lidt */
	case 3:
	  /* invlpg */
	case 7:
	default:
	  if (mod == 3)
	    {
	      i386_record_pc -= 3;
	      opcode = opcode << 8 | modrm;
	      goto no_support;
	    }
	  break;
	  /* smsw */
	case 4:
	  if (mod == 3)
	    {
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  else
	    {
	      ot = OT_WORD;
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  break;
	  /* lmsw */
	case 6:
	  break;
	}
      break;

      /* invd */
    case 0x0f08:
      /* wbinvd */
    case 0x0f09:
      break;

      /* arpl */
    case 0x63:
      ot = dflag ? OT_LONG : OT_WORD;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod != 3)
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* lar */
    case 0x0f02:
      /* lsl */
    case 0x0f03:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

    case 0x0f18:
      break;

      /* nop (multi byte) */
    case 0x0f19 ... 0x0f1f:
      break;

      /* mov reg, crN */
    case 0x0f20:
      /* mov crN, reg */
    case 0x0f22:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if ((modrm & 0xc0) != 0xc0)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}
      switch (reg)
	{
	case 0:
	case 2:
	case 3:
	case 4:
	case 8:
	  if (opcode & 2)
	    {
	    }
	  else
	    {
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  break;
	default:
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      break;

      /* mov reg, drN */
    case 0x0f21:
      /* mov drN, reg */
    case 0x0f23:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if ((modrm & 0xc0) != 0xc0 || reg == 4 || reg == 5 || reg >= 8)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}
      if (opcode & 2)
	{
	}
      else
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      break;

      /* clts */
    case 0x0f06:
      break;

      /* MMX/SSE/SSE2/PNI support */
      /* XXX */

    default:
      if (opcode > 0xff)
	{
	  i386_record_pc -= 2;
	}
      else
	{
	  i386_record_pc -= 1;
	}
      goto no_support;
      break;
    }

/* In the future, Maybe still need to deal with need_dasm */
  if (record_arch_list_add_reg (I386_EIP_REGNUM))
    {
      return (-1);
    }
  if (record_arch_list_add_end (0))
    {
      return (-1);
    }

  return (0);

no_support:
  printf_unfiltered (_
		     ("Record: record and reverse function don't support instruction 0x%02x at address 0x%s.\n"),
		     (unsigned int) (opcode), paddr_nz (i386_record_pc));
  return (-1);
}


static struct gdbarch *
i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;

  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* Allocate space for the new architecture.  */
  tdep = XCALLOC (1, struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  /* General-purpose registers.  */
  tdep->gregset = NULL;
  tdep->gregset_reg_offset = NULL;
  tdep->gregset_num_regs = I386_NUM_GREGS;
  tdep->sizeof_gregset = 0;

  /* Floating-point registers.  */
  tdep->fpregset = NULL;
  tdep->sizeof_fpregset = I387_SIZEOF_FSAVE;

  /* The default settings include the FPU registers, the MMX registers
     and the SSE registers.  This can be overridden for a specific ABI
     by adjusting the members `st0_regnum', `mm0_regnum' and
     `num_xmm_regs' of `struct gdbarch_tdep', otherwise the registers
     will show up in the output of "info all-registers".  Ideally we
     should try to autodetect whether they are available, such that we
     can prevent "info all-registers" from displaying registers that
     aren't available.

     NOTE: kevinb/2003-07-13: ... if it's a choice between printing
     [the SSE registers] always (even when they don't exist) or never
     showing them to the user (even when they do exist), I prefer the
     former over the latter.  */

  tdep->st0_regnum = I386_ST0_REGNUM;

  /* The MMX registers are implemented as pseudo-registers.  Put off
     calculating the register number for %mm0 until we know the number
     of raw registers.  */
  tdep->mm0_regnum = 0;

  /* I386_NUM_XREGS includes %mxcsr, so substract one.  */
  tdep->num_xmm_regs = I386_NUM_XREGS - 1;

  tdep->jb_pc_offset = -1;
  tdep->struct_return = pcc_struct_return;
  tdep->sigtramp_start = 0;
  tdep->sigtramp_end = 0;
  tdep->sigtramp_p = i386_sigtramp_p;
  tdep->sigcontext_addr = NULL;
  tdep->sc_reg_offset = NULL;
  tdep->sc_pc_offset = -1;
  tdep->sc_sp_offset = -1;

  /* The format used for `long double' on almost all i386 targets is
     the i387 extended floating-point format.  In fact, of all targets
     in the GCC 2.95 tree, only OSF/1 does it different, and insists
     on having a `long double' that's not `long' at all.  */
  set_gdbarch_long_double_format (gdbarch, floatformats_i387_ext);

  /* Although the i387 extended floating-point has only 80 significant
     bits, a `long double' actually takes up 96, probably to enforce
     alignment.  */
  set_gdbarch_long_double_bit (gdbarch, 96);

  /* The default ABI includes general-purpose registers, 
     floating-point registers, and the SSE registers.  */
  set_gdbarch_num_regs (gdbarch, I386_SSE_NUM_REGS);
  set_gdbarch_register_name (gdbarch, i386_register_name);
  set_gdbarch_register_type (gdbarch, i386_register_type);

  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, I386_ESP_REGNUM); /* %esp */
  set_gdbarch_pc_regnum (gdbarch, I386_EIP_REGNUM); /* %eip */
  set_gdbarch_ps_regnum (gdbarch, I386_EFLAGS_REGNUM); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, I386_ST0_REGNUM); /* %st(0) */

  /* NOTE: kettenis/20040418: GCC does have two possible register
     numbering schemes on the i386: dbx and SVR4.  These schemes
     differ in how they number %ebp, %esp, %eflags, and the
     floating-point registers, and are implemented by the arrays
     dbx_register_map[] and svr4_dbx_register_map in
     gcc/config/i386.c.  GCC also defines a third numbering scheme in
     gcc/config/i386.c, which it designates as the "default" register
     map used in 64bit mode.  This last register numbering scheme is
     implemented in dbx64_register_map, and is used for AMD64; see
     amd64-tdep.c.

     Currently, each GCC i386 target always uses the same register
     numbering scheme across all its supported debugging formats
     i.e. SDB (COFF), stabs and DWARF 2.  This is because
     gcc/sdbout.c, gcc/dbxout.c and gcc/dwarf2out.c all use the
     DBX_REGISTER_NUMBER macro which is defined by each target's
     respective config header in a manner independent of the requested
     output debugging format.

     This does not match the arrangement below, which presumes that
     the SDB and stabs numbering schemes differ from the DWARF and
     DWARF 2 ones.  The reason for this arrangement is that it is
     likely to get the numbering scheme for the target's
     default/native debug format right.  For targets where GCC is the
     native compiler (FreeBSD, NetBSD, OpenBSD, GNU/Linux) or for
     targets where the native toolchain uses a different numbering
     scheme for a particular debug format (stabs-in-ELF on Solaris)
     the defaults below will have to be overridden, like
     i386_elf_init_abi() does.  */

  /* Use the dbx register numbering scheme for stabs and COFF.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);
  set_gdbarch_sdb_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);

  /* Use the SVR4 register numbering scheme for DWARF 2.  */
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, i386_svr4_reg_to_regnum);

  /* We don't set gdbarch_stab_reg_to_regnum, since ECOFF doesn't seem to
     be in use on any of the supported i386 targets.  */

  set_gdbarch_print_float_info (gdbarch, i387_print_float_info);

  set_gdbarch_get_longjmp_target (gdbarch, i386_get_longjmp_target);

  /* Call dummy code.  */
  set_gdbarch_push_dummy_call (gdbarch, i386_push_dummy_call);

  set_gdbarch_convert_register_p (gdbarch, i386_convert_register_p);
  set_gdbarch_register_to_value (gdbarch,  i386_register_to_value);
  set_gdbarch_value_to_register (gdbarch, i386_value_to_register);

  set_gdbarch_return_value (gdbarch, i386_return_value);

  set_gdbarch_skip_prologue (gdbarch, i386_skip_prologue);

  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);

  set_gdbarch_breakpoint_from_pc (gdbarch, i386_breakpoint_from_pc);
a2831 2
  set_gdbarch_process_record (gdbarch, i386_process_record);

@


1.266.2.2
log
@2008-10-07  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c, infrun.c, linux-record.c, linux-record.h,
	record.c, record.h: Change name from
	"record and reverse target" to
	"process record and replay target".
@
text
@d2686 1
a2686 1
      printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2722 1
a2722 1
	      printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2740 1
a2740 1
		  printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2754 1
a2754 1
	      printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2764 1
a2764 1
	      printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2796 1
a2796 1
		  printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2813 1
a2813 1
	      printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2823 1
a2823 1
	      printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2906 1
a2906 1
			   ("Process record ignores the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
d2943 1
a2943 1
      fprintf_unfiltered (gdb_stdlog, "Process record: i386_record pc = 0x%s\n",
d2952 1
a2952 1
	  printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d3015 1
a3015 1
	  printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d3945 1
a3945 1
				 ("Process record ignores the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
d3964 1
a3964 1
				       ("Process record: read memeory 0x%s error.\n"),
d3976 1
a3976 1
				       ("Process record: read memeory 0x%s error.\n"),
d4397 1
a4397 1
			         ("Process record ignores the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
d4819 1
a4819 1
			 ("Process record don't support instruction fwait.\n"));
d4828 1
a4828 1
			 ("Process record doesn't support instruction int3.\n"));
d4840 1
a4840 1
	    printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d4849 1
a4849 1
			       ("Process record doesn't support instruction int 0x%02x.\n"),
d4866 1
a4866 1
			 ("Process record doesn't support instruction into.\n"));
d4880 1
a4880 1
			 ("Process record doesn't support instruction bound.\n"));
d4922 1
a4922 1
			 ("Process record doesn't support instruction wrmsr.\n"));
d4930 1
a4930 1
			 ("Process record doesn't support instruction rdmsr.\n"));
d4938 1
a4938 1
			 ("Process record doesn't support instruction rdtsc.\n"));
d4950 1
a4950 1
			       ("Process record doesn't support instruction sysenter.\n"));
d4965 1
a4965 1
			 ("Process record doesn't support instruction sysexit.\n"));
d4993 1
a4993 1
			 ("Process record doesn't support instruction hlt.\n"));
d5070 1
a5070 1
				     ("Process record ignores the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
d5121 1
a5121 1
				       ("Process record ignores the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
d5340 1
a5340 1
		     ("Process record doesn't support instruction 0x%02x at address 0x%s.\n"),
@


1.265
log
@
	* breakpoint.c (breakpoint_init_inferior): Mark as not inserted only
	non-permanent breakpoints.
	(bpstat_stop_status): Change enable_state to bp_disabled only for
	non-permanent breakpoints.
	(bp_loc_is_permanent): New function.
	(create_breakpoint): Check if the location points to a permanent
	breakpoint and if it does, make breakpoint permanent.
	(update_breakpoint_locations): Make sure new locations of permanent
	breakpoints are properly initialized.
	* i386-tdep.c (i386_skip_permanent_breakpoint): New function.
	(i386_gdbarch_init): Set gdbarch_skip_permanent_breakpoint.

	* gdb.arch/i386-bp_permanent.exp: New test.
@
text
@d1278 1
a1278 1
  return extract_typed_address (buf, builtin_type_void_func_ptr);
d2074 2
a2075 1
				   init_vector_type (builtin_type_float, 4));
d2077 2
a2078 1
				   init_vector_type (builtin_type_double, 2));
d2105 1
a2105 1
    return builtin_type_void_func_ptr;
d2111 1
a2111 1
    return builtin_type_void_data_ptr;
d2125 1
a2125 1
  return builtin_type_int;
@


1.264
log
@	* dummy-frame.h (dummy_frame_pop): Add prototype.
	* dummy-frame.c: Include "observer.h".
	(dummy_frame_push): Do not check for stale frames.
	(dummy_frame_pop): New function.
	(cleanup_dummy_frames): New function.
	(_initialize_dummy_frame): Install it as inferior_created observer.

	* frame.h (struct frame_id): Update comments.
	(frame_id_inner): Remove prototype.
	* frame.c (frame_id_inner): Make static.  Add comments.
	(frame_find_by_id): Update frame_id_inner safety net check to avoid
	false positives for targets using non-contiguous stack ranges.
	(get_prev_frame_1): Update frame_id_inner safety net check.
	(frame_pop): Call dummy_frame_pop when popping a dummy frame.

	* stack.c (return_command): Directly pop the selected frame.
	* infrun.c (handle_inferior_event): Remove dead code.
	* i386-tdep.c (i386_push_dummy_call): Update comment.
@
text
@d2627 12
d2827 3
@


1.263
log
@gdb:
	* xml-tdesc.c (tdesc_end_union): Update.
	* stabsread.c (define_symbol): Update.
	(read_type): Update.
	(read_struct_type): Update.
	(read_enum_type): Update.
	* spu-tdep.c (spu_builtin_type_vec128): Update.
	* sh-tdep.c (sh_push_dummy_call_fpu): Update.
	(sh_push_dummy_call_nofpu): Update.
	* mdebugread.c (parse_symbol): Update.
	(parse_symbol): Update.
	(parse_symbol): Update.
	(upgrade_type): Update.
	* jv-lang.c (java_lookup_class): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address): Update.
	* i386-tdep.c (i386_mmx_type): Update.
	(i386_sse_type): Update.
	* gdbtypes.h (enum type_flag_value): New enum.
	(enum type_instance_flag_value): New enum.
	(TYPE_FLAG_UNSIGNED, TYPE_FLAG_NOSIGN, TYPE_FLAG_STUB,
	TYPE_FLAG_TARGET_STUB, TYPE_FLAG_STATIC, TYPE_FLAG_PROTOTYPED,
	TYPE_FLAG_INCOMPLETE, TYPE_FLAG_VARARGS, TYPE_FLAG_VECTOR,
	TYPE_FLAG_FIXED_INSTANCE, TYPE_FLAG_STUB_SUPPORTED,
	TYPE_FLAG_NOTTEXT): Now enum constants.
	(TYPE_FLAG_CONST, TYPE_FLAG_VOLATILE, TYPE_FLAG_CODE_SPACE,
	TYPE_FLAG_DATA_SPACE, TYPE_FLAG_ADDRESS_CLASS_1,
	TYPE_FLAG_ADDRESS_CLASS_2): Remove.
	(TYPE_INSTANCE_FLAG_CONST, TYPE_INSTANCE_FLAG_VOLATILE,
	TYPE_INSTANCE_FLAG_CODE_SPACE, TYPE_INSTANCE_FLAG_DATA_SPACE,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2): New constants.
	(TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB, TYPE_TARGET_STUB,
	TYPE_STATIC, TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_VARARGS,
	TYPE_VECTOR, TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED,
	TYPE_NOTTEXT): Update.
	(TYPE_FLAG_ADDRESS_CLASS_ALL): Remove.
	(TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL): New define.
	(TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE,
	TYPE_ADDRESS_CLASS_1, TYPE_ADDRESS_CLASS_2,
	TYPE_ADDRESS_CLASS_ALL): Update.
	(struct main_type) <flags>: Remove.
	<flag_unsigned, flag_nosign, flag_stub, flag_target_stub,
	flag_static, flag_prototyped, flag_incomplete, flag_varargs,
	flag_vector, flag_stub_supported, flag_nottext,
	flag_fixed_instance>: New fields.
	<nfields, vptr_fieldno>: Move earlier.
	(TYPE_FLAGS): Remove.
	* gdbtypes.c (make_pointer_type): Update.
	(address_space_name_to_int): Update.
	(address_space_int_to_name): Update.
	(make_type_with_address_space): Update.
	(make_cv_type): Update.
	(create_range_type): Update.
	(get_discrete_bounds): Update.
	(create_set_type): Update.
	(make_vector_type): Update.
	(smash_to_method_type): Update.
	(check_typedef): Update.
	(check_stub_method): Update.
	(init_type): Individually assign flag fields.
	(recursive_dump_type): Don't print entire TYPE_FLAGS field.  Do
	print TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED, and TYPE_NOTTEXT.
	(copy_type_recursive): Copy the entire main type.  Don't use
	TYPE_FLAGS.
	* features/rs6000/powerpc-altivec64l.c
	(initialize_tdesc_powerpc_altivec64l): Update.
	* features/rs6000/powerpc-altivec64.c
	(initialize_tdesc_powerpc_altivec64): Update.
	* features/rs6000/powerpc-altivec32l.c
	(initialize_tdesc_powerpc_altivec32l): Update.
	* features/rs6000/powerpc-altivec32.c
	(initialize_tdesc_powerpc_altivec32): Update.
	* features/rs6000/powerpc-7400.c (initialize_tdesc_powerpc_7400):
	Update.
	* features/arm-with-iwmmxt.c (initialize_tdesc_arm_with_iwmmxt):
	Update.
	* dwarf2read.c (read_structure_type): Update.
	(read_enumeration_type): Likewise.
	(process_enumeration_scope): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_base_type): Likewise.
	* coffread.c (coff_read_enum_type): Update.
	* ada-valprint.c (adjust_type_signedness): Update.
	* ada-typeprint.c (print_record_field_types): Update.
	* ada-lang.c (packed_array_type): Update.
	(empty_record): Don't reset TYPE_FLAGS.
	(ada_template_to_fixed_record_type_1): Update.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_record_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_static_fixed_type): Likewise.
gdb/testsuite:
	* gdb.base/maint.exp: Update "maint print type".
@
text
@d1715 2
a1716 2
     definition of the stack address of a frame.  Otherwise
     frame_id_inner() won't work correctly.  Since DWARF2/GCC uses the
@


1.262
log
@2008-08-09  Xuepeng Guo  <xuepeng.guo@@intel.com>
	    H.J. Lu  <hongjiu.lu@@intel.com>
	    Mark Kettenis <kettenis@@gnu.org>

	* amd64-tdep.c (amd64_frame_cache): Add saved_sp_reg.
	(amd64_init_frame_cache): Initialize saved_sp_reg.
	(amd64_analyze_stack_align): New.
	(amd64_analyze_prologue): Call it.
	(amd64_frame_cache): Use saved_sp_reg if it is invalid.  Don't set
	%rip to 8 when halfway aligning the stack.

	* amd64-tdep.h (amd64_regnum): Add AMD64_R9_REGNUM to
	AMD64_R14_REGNUM.

	* i386-tdep.c (i386_frame_cache): Remove stack_align.  Add
	saved_sp_reg.
	(i386_alloc_frame_cache): Remove stack_align.  Initialize
	saved_sp_reg to -1.
	(i386_analyze_stack_align): Rewrite.
	(i386_frame_cache): Use saved_sp_reg if it is valid.
@
text
@d2041 1
a2041 1
      TYPE_FLAGS (t) |= TYPE_FLAG_VECTOR;
d2087 1
a2087 1
      TYPE_FLAGS (t) |= TYPE_FLAG_VECTOR;
@


1.261
log
@	* i386-tdep.c (i386_displaced_step_fixup): Condition log printing
	on debug_displaced being set.
@
text
@d521 1
a521 1
  int stack_align;
d548 1
a548 1
  cache->stack_align = 0;
d710 34
a743 8
  /* The register used by the compiler to perform the stack re-alignment 
     is, in order of preference, either %ecx, %edx, or %eax.  GCC should
     never use %ebx as it always treats it as callee-saved, whereas
     the compiler can only use caller-saved registers.  */
  static const gdb_byte insns_ecx[10] = { 
    0x8d, 0x4c, 0x24, 0x04,	/* leal  4(%esp), %ecx */
    0x83, 0xe4, 0xf0,		/* andl  $-16, %esp */
    0xff, 0x71, 0xfc		/* pushl -4(%ecx) */
a744 11
  static const gdb_byte insns_edx[10] = { 
    0x8d, 0x54, 0x24, 0x04,	/* leal  4(%esp), %edx */
    0x83, 0xe4, 0xf0,		/* andl  $-16, %esp */
    0xff, 0x72, 0xfc		/* pushl -4(%edx) */
  };
  static const gdb_byte insns_eax[10] = { 
    0x8d, 0x44, 0x24, 0x04,	/* leal  4(%esp), %eax */
    0x83, 0xe4, 0xf0,		/* andl  $-16, %esp */
    0xff, 0x70, 0xfc		/* pushl -4(%eax) */
  };
  gdb_byte buf[10];
d746 63
a808 4
  if (target_read_memory (pc, buf, sizeof buf)
      || (memcmp (buf, insns_ecx, sizeof buf) != 0
          && memcmp (buf, insns_edx, sizeof buf) != 0
          && memcmp (buf, insns_eax, sizeof buf) != 0))
d811 2
a812 2
  if (current_pc > pc + 4)
    cache->stack_align = 1;
d814 1
a814 1
  return min (pc + 10, current_pc);
d1318 1
a1318 1
  if (cache->stack_align)
d1320 2
a1321 2
      /* Saved stack pointer has been saved in %ecx.  */
      get_frame_register (this_frame, I386_ECX_REGNUM, buf);
d1335 1
a1335 1
      if (cache->stack_align)
@


1.261.2.1
log
@Add record target to GDB.
@
text
@a51 3
#include "record.h"
#include <stdint.h>

d2553 15
a2567 13
#define PREFIX_REPZ	0x01
#define PREFIX_REPNZ	0x02
#define PREFIX_LOCK	0x04
#define PREFIX_DATA	0x08
#define PREFIX_ADDR	0x10

/* operand size */
enum
{
  OT_BYTE = 0,
  OT_WORD,
  OT_LONG,
};
d2569 5
a2573 12
/* i386 arith/logic operations */
enum
{
  OP_ADDL,
  OP_ORL,
  OP_ADCL,
  OP_SBBL,
  OP_ANDL,
  OP_SUBL,
  OP_XORL,
  OP_CMPL,
};
d2575 3
a2577 7
static int aflag = 1;
static int dflag = 1;
static int override = 0;
static uint8_t modrm;
static uint8_t mod, reg, rm;
static int ot;
static CORE_ADDR i386_record_pc;
d2579 8
a2586 15
/* Parse "modrm" part in current memory address that i386_record_pc point to.
   Return -1 if something wrong. */
static int
i386_record_modrm (void)
{
  if (target_read_memory (i386_record_pc, &modrm, 1))
    {
      printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
			 paddr_nz (i386_record_pc));
      return (-1);
    }
  i386_record_pc++;
  mod = (modrm >> 6) & 3;
  reg = (modrm >> 3) & 7;
  rm = modrm & 7;
d2588 4
a2591 2
  return (0);
}
d2593 1
a2593 18
/* Get the memory address that current instruction  write to and set it to
   the argument "addr".
   Return -1 if something wrong. */
static int
i386_record_lea_modrm_addr (uint32_t * addr)
{
  uint8_t tmpu8;
  uint16_t tmpu16;
  uint32_t tmpu32;

  *addr = 0;
  if (aflag)
    {
      /* 32 bits */
      int havesib = 0;
      uint8_t scale = 0;
      uint8_t index = 0;
      uint8_t base = rm;
d2595 4
a2598 14
      if (base == 4)
	{
	  havesib = 1;
	  if (target_read_memory (i386_record_pc, &tmpu8, 1))
	    {
	      printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				 paddr_nz (i386_record_pc));
	      return (-1);
	    }
	  i386_record_pc++;
	  scale = (tmpu8 >> 6) & 3;
	  index = ((tmpu8 >> 3) & 7);
	  base = (tmpu8 & 7);
	}
d2600 2
a2601 39
      switch (mod)
	{
	case 0:
	  if ((base & 7) == 5)
	    {
	      base = 0xff;
	      if (target_read_memory (i386_record_pc, (gdb_byte *) addr, 4))
		{
		  printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				     paddr_nz (i386_record_pc));
		  return (-1);
		}
	      i386_record_pc += 4;
	    }
	  else
	    {
	      *addr = 0;
	    }
	  break;
	case 1:
	  if (target_read_memory (i386_record_pc, &tmpu8, 1))
	    {
	      printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				 paddr_nz (i386_record_pc));
	      return (-1);
	    }
	  i386_record_pc++;
	  *addr = (int8_t) tmpu8;
	  break;
	case 2:
	  if (target_read_memory (i386_record_pc, (gdb_byte *) addr, 4))
	    {
	      printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				 paddr_nz (i386_record_pc));
	      return (-1);
	    }
	  i386_record_pc += 4;
	  break;
	}
d2603 9
a2611 5
      if (base != 0xff)
	{
	  regcache_raw_read (record_regcache, base, (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	}
d2613 5
a2617 53
      /* XXX: index == 4 is always invalid */
      if (havesib && (index != 4 || scale != 0))
	{
	  regcache_raw_read (record_regcache, index, (gdb_byte *) & tmpu32);
	  *addr += tmpu32 << scale;
	}
    }
  else
    {
      /* 16 bits */
      switch (mod)
	{
	case 0:
	  if (rm == 6)
	    {
	      if (target_read_memory
		  (i386_record_pc, (gdb_byte *) & tmpu16, 2))
		{
		  printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				     paddr_nz (i386_record_pc));
		  return (-1);
		}
	      i386_record_pc += 2;
	      *addr = (int16_t) tmpu16;
	      rm = 0;
	      goto no_rm;
	    }
	  else
	    {
	      *addr = 0;
	    }
	  break;
	case 1:
	  if (target_read_memory (i386_record_pc, &tmpu8, 1))
	    {
	      printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				 paddr_nz (i386_record_pc));
	      return (-1);
	    }
	  i386_record_pc++;
	  *addr = (int8_t) tmpu8;
	  break;
	case 2:
	  if (target_read_memory (i386_record_pc, (gdb_byte *) & tmpu16, 2))
	    {
	      printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				 paddr_nz (i386_record_pc));
	      return (-1);
	    }
	  i386_record_pc += 2;
	  *addr = (int16_t) tmpu16;
	  break;
	}
d2619 4
a2622 57
      switch (rm)
	{
	case 0:
	  regcache_raw_read (record_regcache, I386_EBX_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (record_regcache, I386_ESI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 1:
	  regcache_raw_read (record_regcache, I386_EBX_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (record_regcache, I386_EDI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 2:
	  regcache_raw_read (record_regcache, I386_EBP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (record_regcache, I386_ESI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 3:
	  regcache_raw_read (record_regcache, I386_EBP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  regcache_raw_read (record_regcache, I386_EDI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 4:
	  regcache_raw_read (record_regcache, I386_ESI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 5:
	  regcache_raw_read (record_regcache, I386_EDI_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 6:
	  regcache_raw_read (record_regcache, I386_EBP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	case 7:
	  regcache_raw_read (record_regcache, I386_EBX_REGNUM,
			     (gdb_byte *) & tmpu32);
	  *addr += tmpu32;
	  break;
	}
      *addr &= 0xffff;
    }
d2624 5
a2628 3
no_rm:
  return (0);
}
d2630 5
a2634 7
/* Record the value of the memory that willbe changed in current instruction
   to "record_arch_list".
   Return -1 if something wrong. */
static int
i386_record_lea_modrm (void)
{
  uint32_t addr;
d2636 10
a2645 7
  if (override)
    {
      printf_unfiltered (_
			 ("Record: cann't get the value of the segment register in address 0x%s. Record ignore this change.\n"),
			 paddr_nz (read_pc ()));
      return (0);
    }
d2647 7
a2653 4
  if (i386_record_lea_modrm_addr (&addr))
    {
      return (-1);
    }
d2655 10
a2664 4
  if (record_arch_list_add_mem (addr, 1 << ot))
    {
      return (-1);
    }
d2666 3
a2668 2
  return (0);
}
d2670 2
a2671 11
/* Parse the current instruction and record the values of the registers and
   memory that will be changed in current instruction to "record_arch_list".
   Return -1 if something wrong. */
static int
i386_record (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  int prefixes = 0;
  uint8_t tmpu8;
  uint16_t tmpu16;
  uint32_t tmpu32;
  uint32_t opcode;
d2673 2
a2674 4
  i386_record_pc = addr;
  aflag = 1;
  dflag = 1;
  override = 0;
d2676 1
a2676 5
  if (record_debug > 1)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: i386_record pc = 0x%s\n",
			  paddr_nz (i386_record_pc));
    }
d2678 1
a2678 59
  /* prefixes */
  while (1)
    {
      if (target_read_memory (i386_record_pc, &tmpu8, 1))
	{
	  printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
			     paddr_nz (i386_record_pc));
	  return (-1);
	}
      i386_record_pc++;
      switch (tmpu8)
	{
	case 0xf3:
	  prefixes |= PREFIX_REPZ;
	  break;
	case 0xf2:
	  prefixes |= PREFIX_REPNZ;
	  break;
	case 0xf0:
	  prefixes |= PREFIX_LOCK;
	  break;
	case 0x2e:
	  override = I386_CS_REGNUM;
	  break;
	case 0x36:
	  override = I386_SS_REGNUM;
	  break;
	case 0x3e:
	  override = I386_DS_REGNUM;
	  break;
	case 0x26:
	  override = I386_ES_REGNUM;
	  break;
	case 0x64:
	  override = I386_FS_REGNUM;
	  break;
	case 0x65:
	  override = I386_GS_REGNUM;
	  break;
	case 0x66:
	  prefixes |= PREFIX_DATA;
	  break;
	case 0x67:
	  prefixes |= PREFIX_ADDR;
	  break;
	default:
	  goto out_prefixes;
	  break;
	}
    }
out_prefixes:
  if (prefixes & PREFIX_DATA)
    {
      dflag ^= 1;
    }
  if (prefixes & PREFIX_ADDR)
    {
      aflag ^= 1;
    }
d2680 2
a2681 16
  /* now check op code */
  opcode = (uint32_t) tmpu8;
reswitch:
  switch (opcode)
    {
    case 0x0f:
      if (target_read_memory (i386_record_pc, &tmpu8, 1))
	{
	  printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
			     paddr_nz (i386_record_pc));
	  return (-1);
	}
      i386_record_pc++;
      opcode = (uint16_t) tmpu8 | 0x0f00;
      goto reswitch;
      break;
d2683 3
a2685 19
      /* arith & logic */
    case 0x00 ... 0x05:
    case 0x08 ... 0x0d:
    case 0x10 ... 0x15:
    case 0x18 ... 0x1d:
    case 0x20 ... 0x25:
    case 0x28 ... 0x2d:
    case 0x30 ... 0x35:
    case 0x38 ... 0x3d:
      if (((opcode >> 3) & 7) != OP_CMPL)
	{
	  if ((opcode & 1) == 0)
	    {
	      ot = OT_BYTE;
	    }
	  else
	    {
	      ot = dflag + OT_WORD;
	    }
d2687 1
a2687 56
	  switch ((opcode >> 1) & 3)
	    {
	      /* OP Ev, Gv */
	    case 0:
	      if (i386_record_modrm ())
		{
		  return (-1);
		}
	      if (mod != 3)
		{
		  if (i386_record_lea_modrm ())
		    {
		      return (-1);
		    }
		}
	      else
		{
		  if (ot == OT_BYTE)
		    {
		      rm &= 0x3;
		    }
		  if (record_arch_list_add_reg (rm))
		    {
		      return (-1);
		    }
		}
	      break;
	      /* OP Gv, Ev */
	    case 1:
	      if (i386_record_modrm ())
		{
		  return (-1);
		}
	      if (ot == OT_BYTE)
		{
		  reg &= 0x3;
		}
	      if (record_arch_list_add_reg (reg))
		{
		  return (-1);
		}
	      break;
	      /* OP A, Iv */
	    case 2:
	      if (record_arch_list_add_reg (I386_EAX_REGNUM))
		{
		  return (-1);
		}
	      break;
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;
d2689 1
a2689 6
      /* GRP1 */
    case 0x80 ... 0x83:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
d2691 2
a2692 10
      if (reg != OP_CMPL)
	{
	  if ((opcode & 1) == 0)
	    {
	      ot = OT_BYTE;
	    }
	  else
	    {
	      ot = dflag + OT_WORD;
	    }
d2694 1
a2694 2192
	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (ot == OT_BYTE)
		{
		  reg &= 0x3;
		}
	      if (record_arch_list_add_reg (reg))
		{
		  return (-1);
		}
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* inv */
    case 0x40 ... 0x47:
      /* dec */
    case 0x48 ... 0x4f:
      if (record_arch_list_add_reg (opcode & 7))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* GRP3 */
    case 0xf6:
    case 0xf7:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}
      if (i386_record_modrm ())
	{
	  return (-1);
	}

      switch (reg)
	{
	  /* test */
	case 0:
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	  /* not */
	case 2:
	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (ot == OT_BYTE)
		{
		  rm &= 0x3;
		}
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  break;
	  /* neg */
	case 3:
	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (ot == OT_BYTE)
		{
		  rm &= 0x3;
		}
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	  /* mul */
	case 4:
	  /* imul */
	case 5:
	  /* div */
	case 6:
	  /* idiv */
	case 7:
	  if (record_arch_list_add_reg (I386_EAX_REGNUM))
	    {
	      return (-1);
	    }
	  if (ot != OT_BYTE)
	    {
	      if (record_arch_list_add_reg (I386_EDX_REGNUM))
		{
		  return (-1);
		}
	    }
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	default:
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      break;

      /* GRP4 */
    case 0xfe:
      /* GRP5 */
    case 0xff:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (reg >= 2 && opcode == 0xfe)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}

      switch (reg)
	{
	  /* inc */
	case 0:
	  /* dec */
	case 1:
	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (ot == OT_BYTE)
		{
		  rm &= 0x3;
		}
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	  /* call */
	case 2:
	  /* push */
	case 6:
	  if (record_arch_list_add_reg (I386_ESP_REGNUM))
	    {
	      return (-1);
	    }
	  regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem
	      ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	    {
	      return (-1);
	    }
	  break;
	  /* lcall */
	case 3:
	  if (record_arch_list_add_reg (I386_ESP_REGNUM))
	    {
	      return (-1);
	    }
	  if (record_arch_list_add_reg (I386_CS_REGNUM))
	    {
	      return (-1);
	    }
	  regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			     (gdb_byte *) & tmpu32);
	  if (record_arch_list_add_mem
	      ((CORE_ADDR) tmpu32 - (1 << (dflag + 2)), (1 << (dflag + 2))))
	    {
	      return (-1);
	    }
	  break;
	  /* jmp */
	case 4:
	  /* ljmp */
	case 5:
	  break;
	default:
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      break;

      /* test */
    case 0x84:
    case 0x85:
    case 0xa8:
    case 0xa9:
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* CWDE/CBW */
    case 0x98:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* CDQ/CWD */
    case 0x99:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EDX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* imul */
    case 0x0faf:
    case 0x69:
    case 0x6b:
      ot = dflag + OT_WORD;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (ot == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* xadd */
    case 0x0fc0:
    case 0x0fc1:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (ot == OT_BYTE)
	    {
	      reg &= 0x3;
	    }
	  if (record_arch_list_add_reg (reg))
	    {
	      return (-1);
	    }
	  if (ot == OT_BYTE)
	    {
	      rm &= 0x3;
	    }
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	  if (ot == OT_BYTE)
	    {
	      reg &= 0x3;
	    }
	  if (record_arch_list_add_reg (reg))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* cmpxchg */
    case 0x0fb0:
    case 0x0fb1:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (record_arch_list_add_reg (I386_EAX_REGNUM))
	    {
	      return (-1);
	    }
	  if (ot == OT_BYTE)
	    {
	      reg &= 0x3;
	    }
	  if (record_arch_list_add_reg (reg))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (record_arch_list_add_reg (I386_EAX_REGNUM))
	    {
	      return (-1);
	    }
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* cmpxchg8b */
    case 0x0fc7:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EDX_REGNUM))
	{
	  return (-1);
	}
      if (i386_record_lea_modrm ())
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* push */
    case 0x50 ... 0x57:
    case 0x68:
    case 0x6a:
      /* push es */
    case 0x06:
      /* push cs */
    case 0x0e:
      /* push ss */
    case 0x16:
      /* push ds */
    case 0x1e:
      /* push fs */
    case 0x0fa0:
      /* push gs */
    case 0x0fa8:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	{
	  return (-1);
	}
      break;

      /* pop */
    case 0x58 ... 0x5f:
      ot = dflag + OT_WORD;
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (ot == OT_BYTE)
	{
	  opcode &= 0x3;
	}
      if (record_arch_list_add_reg (opcode & 0x7))
	{
	  return (-1);
	}
      break;

      /* pusha */
    case 0x60:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 4)), (1 << (dflag + 4))))
	{
	  return (-1);
	}
      break;

      /* popa */
    case 0x61:
      for (tmpu8 = I386_EAX_REGNUM; tmpu8 <= I386_EDI_REGNUM; tmpu8++)
	{
	  if (record_arch_list_add_reg (tmpu8))
	    {
	      return (-1);
	    }
	}
      break;

      /* pop */
    case 0x8f:
      ot = dflag + OT_WORD;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      break;

      /* enter */
    case 0xc8:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EBP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	{
	  return (-1);
	}
      break;

      /* leave */
    case 0xc9:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EBP_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop es */
    case 0x07:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ES_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop ss */
    case 0x17:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_SS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop ds */
    case 0x1f:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_DS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop fs */
    case 0x0fa1:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_FS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* pop gs */
    case 0x0fa9:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_GS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* mov */
    case 0x88:
    case 0x89:
    case 0xc6:
    case 0xc7:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}

      if (i386_record_modrm ())
	{
	  return (-1);
	}

      if (mod != 3)
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (ot == OT_BYTE)
	    {
	      rm &= 0x3;
	    }
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;
      /* mov */
    case 0x8a:
    case 0x8b:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}

      if (i386_record_modrm ())
	{
	  return (-1);
	}

      if (ot == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}

      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* mov seg */
    case 0x8e:
      if (i386_record_modrm ())
	{
	  return (-1);
	}

      switch (reg)
	{
	case 0:
	  tmpu8 = I386_ES_REGNUM;
	  break;
	case 2:
	  tmpu8 = I386_SS_REGNUM;
	  break;
	case 3:
	  tmpu8 = I386_DS_REGNUM;
	  break;
	case 4:
	  tmpu8 = I386_FS_REGNUM;
	  break;
	case 5:
	  tmpu8 = I386_GS_REGNUM;
	  break;
	default:
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      if (record_arch_list_add_reg (tmpu8))
	{
	  return (-1);
	}

      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* mov seg */
    case 0x8c:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (reg > 5)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}

      if (mod == 3)
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  ot = OT_WORD;
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}

      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* movzbS */
    case 0x0fb6:
      /* movzwS */
    case 0x0fb7:
      /* movsbS */
    case 0x0fbe:
      /* movswS */
    case 0x0fbf:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      break;

      /* lea */
    case 0x8d:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}

      ot = dflag;
      if (ot == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      break;

      /* mov EAX */
    case 0xa0:
    case 0xa1:
      /* xlat */
    case 0xd7:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* mov EAX */
    case 0xa2:
    case 0xa3:
      {
	uint32_t addr;

	if ((opcode & 1) == 0)
	  {
	    ot = OT_BYTE;
	  }
	else
	  {
	    ot = dflag + OT_WORD;
	  }
	if (aflag)
	  {
	    if (target_read_memory (i386_record_pc, (gdb_byte *) & addr, 4))
	      {
		printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				   paddr_nz (i386_record_pc));
		return (-1);
	      }
	    i386_record_pc += 4;
	  }
	else
	  {
	    if (target_read_memory (i386_record_pc, (gdb_byte *) & tmpu16, 4))
	      {
		printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
				   paddr_nz (i386_record_pc));
		return (-1);
	      }
	    i386_record_pc += 2;
	    addr = tmpu16;
	  }
	if (record_arch_list_add_mem (addr, 1 << ot))
	  {
	    return (-1);
	  }
      }
      break;

      /* mov R, Ib */
    case 0xb0 ... 0xb7:
      if (record_arch_list_add_reg ((opcode & 0x7) & 0x3))
	{
	  return (-1);
	}
      break;

      /* mov R, Iv */
    case 0xb8 ... 0xbf:
      if (record_arch_list_add_reg (opcode & 0x7))
	{
	  return (-1);
	}
      break;

      /* xchg R, EAX */
    case 0x91 ... 0x97:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (opcode & 0x7))
	{
	  return (-1);
	}
      break;

      /* xchg Ev, Gv */
    case 0x86:
    case 0x87:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}

      if (i386_record_modrm ())
	{
	  return (-1);
	}

      if (mod == 3)
	{
	  if (ot == OT_BYTE)
	    {
	      rm &= 0x3;
	    }
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}

      if (ot == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      break;

      /* les Gv */
    case 0xc4:
      /* lds Gv */
    case 0xc5:
      /* lss Gv */
    case 0x0fb2:
      /* lfs Gv */
    case 0x0fb4:
      /* lgs Gv */
    case 0x0fb5:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (opcode > 0xff)
	    {
	      i386_record_pc -= 3;
	    }
	  else
	    {
	      i386_record_pc -= 2;
	    }
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}

      switch (opcode)
	{
	  /* les Gv */
	case 0xc4:
	  tmpu8 = I386_ES_REGNUM;
	  break;
	  /* lds Gv */
	case 0xc5:
	  tmpu8 = I386_DS_REGNUM;
	  break;
	  /* lss Gv */
	case 0x0fb2:
	  tmpu8 = I386_SS_REGNUM;
	  break;
	  /* lfs Gv */
	case 0x0fb4:
	  tmpu8 = I386_FS_REGNUM;
	  break;
	  /* lgs Gv */
	case 0x0fb5:
	  tmpu8 = I386_GS_REGNUM;
	  break;
	}
      if (record_arch_list_add_reg (tmpu8))
	{
	  return (-1);
	}

      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      break;

      /* shifts */
    case 0xc0:
    case 0xc1:
    case 0xd0:
    case 0xd1:
    case 0xd2:
    case 0xd3:
      if ((opcode & 1) == 0)
	{
	  ot = OT_BYTE;
	}
      else
	{
	  ot = dflag + OT_WORD;
	}

      if (i386_record_modrm ())
	{
	  return (-1);
	}

      if (mod != 3 && (opcode == 0xd2 || opcode == 0xd3))
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (ot == OT_BYTE)
	    {
	      rm &= 0x3;
	    }
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}

      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

    case 0x0fa4:
    case 0x0fa5:
    case 0x0fac:
    case 0x0fad:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      break;

      /* floats */
      /* XXX */

      /* string ops */
      /* movsS */
    case 0xa4:
    case 0xa5:
      /* stosS */
    case 0xaa:
    case 0xab:
      /* insS */
    case 0x6c:
    case 0x6d:
      {
	uint32_t addr;

	if ((opcode & 1) == 0)
	  {
	    ot = OT_BYTE;
	  }
	else
	  {
	    ot = dflag + OT_WORD;
	  }
	if (opcode == 0xa4 || opcode == 0xa5)
	  {
	    if (record_arch_list_add_reg (I386_ESI_REGNUM))
	      {
		return (-1);
	      }
	  }
	if (record_arch_list_add_reg (I386_EDI_REGNUM))
	  {
	    return (-1);
	  }

	regcache_raw_read (record_regcache, I386_EDI_REGNUM,
			   (gdb_byte *) & addr);
	if (!aflag)
	  {
	    addr &= 0xffff;
	    /* addr += ((uint32_t)read_register (I386_ES_REGNUM)) << 4; */
	    printf_unfiltered (_
			       ("Record: cann't get the value of the segment register.\n"));
	    return (-1);
	  }

	if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	  {
	    uint32_t count;

	    regcache_raw_read (record_regcache, I386_ECX_REGNUM,
			       (gdb_byte *) & count);
	    if (!aflag)
	      {
		count &= 0xffff;
	      }

	    regcache_raw_read (record_regcache, I386_EFLAGS_REGNUM,
			       (gdb_byte *) & tmpu32);
	    if ((tmpu32 >> 10) & 0x1)
	      {
		addr -= (count - 1) * (1 << ot);
	      }

	    if (record_arch_list_add_mem (addr, count * (1 << ot)))
	      {
		return (-1);
	      }

	    if (record_arch_list_add_reg (I386_ECX_REGNUM))
	      {
		return (-1);
	      }
	  }
	else
	  {
	    if (record_arch_list_add_mem (addr, 1 << ot))
	      {
		return (-1);
	      }
	  }
      }
      break;

      /* lodsS */
    case 0xac:
    case 0xad:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ESI_REGNUM))
	{
	  return (-1);
	}
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	{
	  if (record_arch_list_add_reg (I386_ECX_REGNUM))
	    {
	      return (-1);
	    }
	}
      break;

      /* outsS */
    case 0x6e:
    case 0x6f:
      if (record_arch_list_add_reg (I386_ESI_REGNUM))
	{
	  return (-1);
	}
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	{
	  if (record_arch_list_add_reg (I386_ECX_REGNUM))
	    {
	      return (-1);
	    }
	}
      break;

      /* scasS */
    case 0xae:
    case 0xaf:
      if (record_arch_list_add_reg (I386_EDI_REGNUM))
	{
	  return (-1);
	}
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	{
	  if (record_arch_list_add_reg (I386_ECX_REGNUM))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* cmpsS */
    case 0xa6:
    case 0xa7:
      if (record_arch_list_add_reg (I386_EDI_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ESI_REGNUM))
	{
	  return (-1);
	}
      if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))
	{
	  if (record_arch_list_add_reg (I386_ECX_REGNUM))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* port I/O */
    case 0xe4:
    case 0xe5:
    case 0xec:
    case 0xed:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      break;

    case 0xe6:
    case 0xe7:
    case 0xee:
    case 0xef:
      break;

      /* control */
      /* ret im */
    case 0xc2:
      /* ret */
    case 0xc3:
      /* lret im */
    case 0xca:
      /* lret */
    case 0xcb:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_CS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* iret */
    case 0xcf:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_CS_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* call im */
    case 0xe8:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	{
	  return (-1);
	}
      break;

      /* lcall im */
    case 0x9a:
      if (record_arch_list_add_reg (I386_CS_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 2)), (1 << (dflag + 2))))
	{
	  return (-1);
	}
      break;

      /* jmp im */
    case 0xe9:
      /* ljmp im */
    case 0xea:
      /* jmp Jb */
    case 0xeb:
      /* jcc Jb */
    case 0x70 ... 0x7f:
      /* jcc Jv */
    case 0x0f80 ... 0x0f8f:
      break;

      /* setcc Gv */
    case 0x0f90 ... 0x0f9f:
      ot = OT_BYTE;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod == 3)
	{
	  if (record_arch_list_add_reg (rm & 0x3))
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      break;

      /* cmov Gv, Ev */
    case 0x0f40 ... 0x0f4f:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (dflag == OT_BYTE)
	{
	  reg &= 0x3;
	}
      if (record_arch_list_add_reg (reg & 0x3))
	{
	  return (-1);
	}
      break;

      /* flags */
      /* pushf */
    case 0x9c:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      regcache_raw_read (record_regcache, I386_ESP_REGNUM,
			 (gdb_byte *) & tmpu32);
      if (record_arch_list_add_mem
	  ((CORE_ADDR) tmpu32 - (1 << (dflag + 1)), (1 << (dflag + 1))))
	{
	  return (-1);
	}
      break;

      /* popf */
    case 0x9d:
      if (record_arch_list_add_reg (I386_ESP_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* sahf */
    case 0x9e:
      /* cmc */
    case 0xf5:
      /* clc */
    case 0xf8:
      /* stc */
    case 0xf9:
      /* cld */
    case 0xfc:
      /* std */
    case 0xfd:
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* lahf */
    case 0x9f:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* bit operations */
      /* bt/bts/btr/btc Gv, im */
    case 0x0fba:
      /* bts */
    case 0x0fab:
      /* btr */
    case 0x0fb3:
      /* btc */
    case 0x0fbb:
      ot = dflag + OT_WORD;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (reg < 4)
	{
	  i386_record_pc -= 3;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}
      reg -= 4;
      if (reg != 0)
	{
	  if (mod != 3)
	    {
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  else
	    {
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* bt Gv, Ev */
    case 0x0fa3:
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* bsf */
    case 0x0fbc:
      /* bsr */
    case 0x0fbd:
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* bcd */
      /* daa */
    case 0x27:
      /* das */
    case 0x2f:
      /* aaa */
    case 0x37:
      /* aas */
    case 0x3f:
      /* aam */
    case 0xd4:
      /* aad */
    case 0xd5:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* misc */
      /* nop */
    case 0x90:
      if (prefixes & PREFIX_LOCK)
	{
	  i386_record_pc -= 1;
	  goto no_support;
	}
      break;

      /* fwait */
      /* XXX */
    case 0x9b:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction fwait.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

      /* int3 */
      /* XXX */
    case 0xcc:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction int3.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

      /* int */
      /* XXX */
    case 0xcd:
      {
	int ret;
	if (target_read_memory (i386_record_pc, &tmpu8, 1))
	  {
	    printf_unfiltered (_("Record: read memeory 0x%s error.\n"),
			       paddr_nz (i386_record_pc));
	    return (-1);
	  }
	i386_record_pc++;
	if (tmpu8 != 0x80
	    || gdbarch_tdep (gdbarch)->i386_intx80_record == NULL)
	  {
	    printf_unfiltered (_
			       ("Record: record and reverse function don't support instruction int 0x%02x.\n"),
			       tmpu8);
	    i386_record_pc -= 2;
	    goto no_support;
	  }
	ret = gdbarch_tdep (gdbarch)->i386_intx80_record ();
	if (ret)
	  {
	    return (ret);
	  }
      }
      break;

      /* into */
      /* XXX */
    case 0xce:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction into.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

      /* cli */
    case 0xfa:
      /* sti */
    case 0xfb:
      break;

      /* bound */
    case 0x62:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction bound.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

      /* bswap reg */
    case 0x0fc8 ... 0x0fcf:
      if (record_arch_list_add_reg (opcode & 7))
	{
	  return (-1);
	}
      break;

      /* salc */
    case 0xd6:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* loopnz */
    case 0xe0:
      /* loopz */
    case 0xe1:
      /* loop */
    case 0xe2:
      /* jecxz */
    case 0xe3:
      if (record_arch_list_add_reg (I386_ECX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* wrmsr */
    case 0x0f30:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction wrmsr.\n"));
      i386_record_pc -= 2;
      goto no_support;
      break;

      /* rdmsr */
    case 0x0f32:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction rdmsr.\n"));
      i386_record_pc -= 2;
      goto no_support;
      break;

      /* rdtsc */
    case 0x0f31:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction rdtsc.\n"));
      i386_record_pc -= 2;
      goto no_support;
      break;

      /* sysenter */
    case 0x0f34:
      {
	int ret;
	if (gdbarch_tdep (gdbarch)->i386_sysenter_record == NULL)
	  {
	    printf_unfiltered (_
			       ("Record: record and reverse function don't support instruction sysenter.\n"));
	    i386_record_pc -= 2;
	    goto no_support;
	  }
	ret = gdbarch_tdep (gdbarch)->i386_sysenter_record ();
	if (ret)
	  {
	    return (ret);
	  }
      }
      break;

      /* sysexit */
    case 0x0f35:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction sysexit.\n"));
      i386_record_pc -= 2;
      goto no_support;
      break;

      /* cpuid */
    case 0x0fa2:
      if (record_arch_list_add_reg (I386_EAX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_ECX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EDX_REGNUM))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EBX_REGNUM))
	{
	  return (-1);
	}
      break;

      /* hlt */
    case 0xf4:
      printf_unfiltered (_
			 ("Record: record and reverse function don't support instruction hlt.\n"));
      i386_record_pc -= 1;
      goto no_support;
      break;

    case 0x0f00:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      switch (reg)
	{
	  /* sldt */
	case 0:
	  /* str */
	case 1:
	  if (mod == 3)
	    {
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  else
	    {
	      ot = OT_WORD;
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  break;
	  /* lldt */
	case 2:
	  /* ltr */
	case 3:
	  break;
	  /* verr */
	case 4:
	  /* verw */
	case 5:
	  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	    {
	      return (-1);
	    }
	  break;
	default:
	  i386_record_pc -= 3;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      break;

    case 0x0f01:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      switch (reg)
	{
	  /* sgdt */
	case 0:
	  {
	    uint32_t addr;

	    if (mod == 3)
	      {
		i386_record_pc -= 3;
		opcode = opcode << 8 | modrm;
		goto no_support;
	      }

	    if (override)
	      {
		printf_unfiltered (_
				   ("Record: cann't get the value of the segment register in address 0x%s. Record ignore this change.\n"),
				   paddr_nz (read_pc ()));
	      }
	    else
	      {
		if (i386_record_lea_modrm_addr (&addr))
		  {
		    return (-1);
		  }
		if (record_arch_list_add_mem (addr, 2))
		  {
		    return (-1);
		  }
		addr += 2;
		if (record_arch_list_add_mem (addr, 4))
		  {
		    return (-1);
		  }
	      }
	  }
	  break;
	case 1:
	  if (mod == 3)
	    {
	      switch (rm)
		{
		  /* monitor */
		case 0:
		  break;
		  /* mwait */
		case 1:
		  if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
		    {
		      return (-1);
		    }
		  break;
		default:
		  i386_record_pc -= 3;
		  opcode = opcode << 8 | modrm;
		  goto no_support;
		  break;
		}
	    }
	  else
	    {
	      /* sidt */
	      if (override)
		{
		  printf_unfiltered (_
				     ("Record: cann't get the value of the segment register in address 0x%s. Record ignore this change.\n"),
				     paddr_nz (read_pc ()));
		}
	      else
		{
		  uint32_t addr;

		  if (i386_record_lea_modrm_addr (&addr))
		    {
		      return (-1);
		    }
		  if (record_arch_list_add_mem (addr, 2))
		    {
		      return (-1);
		    }
		  addr += 2;
		  if (record_arch_list_add_mem (addr, 4))
		    {
		      return (-1);
		    }
		}
	    }
	  break;
	  /* lgdt */
	case 2:
	  /* lidt */
	case 3:
	  /* invlpg */
	case 7:
	default:
	  if (mod == 3)
	    {
	      i386_record_pc -= 3;
	      opcode = opcode << 8 | modrm;
	      goto no_support;
	    }
	  break;
	  /* smsw */
	case 4:
	  if (mod == 3)
	    {
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  else
	    {
	      ot = OT_WORD;
	      if (i386_record_lea_modrm ())
		{
		  return (-1);
		}
	    }
	  break;
	  /* lmsw */
	case 6:
	  break;
	}
      break;

      /* invd */
    case 0x0f08:
      /* wbinvd */
    case 0x0f09:
      break;

      /* arpl */
    case 0x63:
      ot = dflag ? OT_LONG : OT_WORD;
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (mod != 3)
	{
	  if (i386_record_lea_modrm ())
	    {
	      return (-1);
	    }
	}
      else
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

      /* lar */
    case 0x0f02:
      /* lsl */
    case 0x0f03:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (reg))
	{
	  return (-1);
	}
      if (record_arch_list_add_reg (I386_EFLAGS_REGNUM))
	{
	  return (-1);
	}
      break;

    case 0x0f18:
      break;

      /* nop (multi byte) */
    case 0x0f19 ... 0x0f1f:
      break;

      /* mov reg, crN */
    case 0x0f20:
      /* mov crN, reg */
    case 0x0f22:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if ((modrm & 0xc0) != 0xc0)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}
      switch (reg)
	{
	case 0:
	case 2:
	case 3:
	case 4:
	case 8:
	  if (opcode & 2)
	    {
	    }
	  else
	    {
	      if (record_arch_list_add_reg (rm))
		{
		  return (-1);
		}
	    }
	  break;
	default:
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	  break;
	}
      break;

      /* mov reg, drN */
    case 0x0f21:
      /* mov drN, reg */
    case 0x0f23:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      if ((modrm & 0xc0) != 0xc0 || reg == 4 || reg == 5 || reg >= 8)
	{
	  i386_record_pc -= 2;
	  opcode = opcode << 8 | modrm;
	  goto no_support;
	}
      if (opcode & 2)
	{
	}
      else
	{
	  if (record_arch_list_add_reg (rm))
	    {
	      return (-1);
	    }
	}
      break;

      /* clts */
    case 0x0f06:
      break;

      /* MMX/SSE/SSE2/PNI support */
      /* XXX */

    default:
      if (opcode > 0xff)
	{
	  i386_record_pc -= 2;
	}
      else
	{
	  i386_record_pc -= 1;
	}
      goto no_support;
      break;
    }

/* In the future, Maybe still need to deal with need_dasm */
  if (record_arch_list_add_reg (I386_EIP_REGNUM))
    {
      return (-1);
    }
  if (record_arch_list_add_end (0))
    {
      return (-1);
    }

  return (0);

no_support:
  printf_unfiltered (_
		     ("Record: record and reverse function don't support instruction 0x%02x at address 0x%s.\n"),
		     (unsigned int) (opcode), paddr_nz (i386_record_pc));
  return (-1);
}


static struct gdbarch *
i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;

  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* Allocate space for the new architecture.  */
  tdep = XCALLOC (1, struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  /* General-purpose registers.  */
  tdep->gregset = NULL;
  tdep->gregset_reg_offset = NULL;
  tdep->gregset_num_regs = I386_NUM_GREGS;
  tdep->sizeof_gregset = 0;

  /* Floating-point registers.  */
  tdep->fpregset = NULL;
  tdep->sizeof_fpregset = I387_SIZEOF_FSAVE;

  /* The default settings include the FPU registers, the MMX registers
     and the SSE registers.  This can be overridden for a specific ABI
     by adjusting the members `st0_regnum', `mm0_regnum' and
     `num_xmm_regs' of `struct gdbarch_tdep', otherwise the registers
     will show up in the output of "info all-registers".  Ideally we
     should try to autodetect whether they are available, such that we
     can prevent "info all-registers" from displaying registers that
     aren't available.

     NOTE: kevinb/2003-07-13: ... if it's a choice between printing
     [the SSE registers] always (even when they don't exist) or never
     showing them to the user (even when they do exist), I prefer the
     former over the latter.  */

  tdep->st0_regnum = I386_ST0_REGNUM;

  /* The MMX registers are implemented as pseudo-registers.  Put off
     calculating the register number for %mm0 until we know the number
     of raw registers.  */
  tdep->mm0_regnum = 0;

  /* I386_NUM_XREGS includes %mxcsr, so substract one.  */
  tdep->num_xmm_regs = I386_NUM_XREGS - 1;

  tdep->jb_pc_offset = -1;
  tdep->struct_return = pcc_struct_return;
  tdep->sigtramp_start = 0;
  tdep->sigtramp_end = 0;
  tdep->sigtramp_p = i386_sigtramp_p;
  tdep->sigcontext_addr = NULL;
  tdep->sc_reg_offset = NULL;
  tdep->sc_pc_offset = -1;
  tdep->sc_sp_offset = -1;

  /* The format used for `long double' on almost all i386 targets is
     the i387 extended floating-point format.  In fact, of all targets
     in the GCC 2.95 tree, only OSF/1 does it different, and insists
     on having a `long double' that's not `long' at all.  */
  set_gdbarch_long_double_format (gdbarch, floatformats_i387_ext);

  /* Although the i387 extended floating-point has only 80 significant
     bits, a `long double' actually takes up 96, probably to enforce
     alignment.  */
  set_gdbarch_long_double_bit (gdbarch, 96);

  /* The default ABI includes general-purpose registers, 
     floating-point registers, and the SSE registers.  */
  set_gdbarch_num_regs (gdbarch, I386_SSE_NUM_REGS);
  set_gdbarch_register_name (gdbarch, i386_register_name);
  set_gdbarch_register_type (gdbarch, i386_register_type);

  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, I386_ESP_REGNUM); /* %esp */
  set_gdbarch_pc_regnum (gdbarch, I386_EIP_REGNUM); /* %eip */
  set_gdbarch_ps_regnum (gdbarch, I386_EFLAGS_REGNUM); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, I386_ST0_REGNUM); /* %st(0) */

  /* NOTE: kettenis/20040418: GCC does have two possible register
     numbering schemes on the i386: dbx and SVR4.  These schemes
     differ in how they number %ebp, %esp, %eflags, and the
     floating-point registers, and are implemented by the arrays
     dbx_register_map[] and svr4_dbx_register_map in
     gcc/config/i386.c.  GCC also defines a third numbering scheme in
     gcc/config/i386.c, which it designates as the "default" register
     map used in 64bit mode.  This last register numbering scheme is
     implemented in dbx64_register_map, and is used for AMD64; see
     amd64-tdep.c.

     Currently, each GCC i386 target always uses the same register
     numbering scheme across all its supported debugging formats
     i.e. SDB (COFF), stabs and DWARF 2.  This is because
     gcc/sdbout.c, gcc/dbxout.c and gcc/dwarf2out.c all use the
     DBX_REGISTER_NUMBER macro which is defined by each target's
     respective config header in a manner independent of the requested
     output debugging format.

     This does not match the arrangement below, which presumes that
     the SDB and stabs numbering schemes differ from the DWARF and
     DWARF 2 ones.  The reason for this arrangement is that it is
     likely to get the numbering scheme for the target's
     default/native debug format right.  For targets where GCC is the
     native compiler (FreeBSD, NetBSD, OpenBSD, GNU/Linux) or for
     targets where the native toolchain uses a different numbering
     scheme for a particular debug format (stabs-in-ELF on Solaris)
     the defaults below will have to be overridden, like
     i386_elf_init_abi() does.  */

  /* Use the dbx register numbering scheme for stabs and COFF.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);
  set_gdbarch_sdb_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);

  /* Use the SVR4 register numbering scheme for DWARF 2.  */
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, i386_svr4_reg_to_regnum);

  /* We don't set gdbarch_stab_reg_to_regnum, since ECOFF doesn't seem to
     be in use on any of the supported i386 targets.  */

  set_gdbarch_print_float_info (gdbarch, i387_print_float_info);

  set_gdbarch_get_longjmp_target (gdbarch, i386_get_longjmp_target);

  /* Call dummy code.  */
  set_gdbarch_push_dummy_call (gdbarch, i386_push_dummy_call);

  set_gdbarch_convert_register_p (gdbarch, i386_convert_register_p);
  set_gdbarch_register_to_value (gdbarch,  i386_register_to_value);
  set_gdbarch_value_to_register (gdbarch, i386_value_to_register);

  set_gdbarch_return_value (gdbarch, i386_return_value);

  set_gdbarch_skip_prologue (gdbarch, i386_skip_prologue);

  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);

  set_gdbarch_breakpoint_from_pc (gdbarch, i386_breakpoint_from_pc);
a2740 2
  set_gdbarch_record (gdbarch, i386_record);

@


1.261.2.2
log
@

chael Snyder  <msnyder@@specifix.com>

        * record.c (_initialize_record): Clarify language in help strings.
        Fix up comment format (period must be followed by two spaces).

2008-08-01  Michael Snyder  <msnyder@@specifix.com>

        * i386-tdep.c (i386_record_lea_modrm): Spelling fix.
:wq
@
text
@d2817 1
a2817 1
			 ("Record: can't get the value of the segment register in address 0x%s. Record ignore this change.\n"),
d4141 1
a4141 1
			       ("Record: can't get the value of the segment register.\n"));
d4807 1
a4807 1
				   ("Record: can't get the value of the segment register in address 0x%s. Record ignore this change.\n"),
d4856 1
a4856 1
				     ("Record: can't get the value of the segment register in address 0x%s. Record ignore this change.\n"),
@


1.261.2.3
log
@	Support more ioctl requests in record target.

	* i386-linux-tdep.c (I386_RECORD_SIZE_termios,
	I386_RECORD_SIZE_termios2, I386_RECORD_SIZE_pid_t,
	I386_RECORD_SIZE_winsize, I386_RECORD_SIZE_char,
	I386_RECORD_SIZE_serial_struct,
	I386_RECORD_SIZE_serial_icounter_struct,
	I386_RECORD_SIZE_hayes_esp_config): New macros. Sizes of some types in
	I386.
	(I386_RECORD_IOCTL_TCGETS,
	I386_RECORD_IOCTL_TCSETS,
	I386_RECORD_IOCTL_TCSETSW,
	I386_RECORD_IOCTL_TCSETSF,
	I386_RECORD_IOCTL_TCGETA,
	I386_RECORD_IOCTL_TCSETA,
	I386_RECORD_IOCTL_TCSETAW,
	I386_RECORD_IOCTL_TCSETAF,
	I386_RECORD_IOCTL_TCSBRK,
	I386_RECORD_IOCTL_TCXONC,
	I386_RECORD_IOCTL_TCFLSH,
	I386_RECORD_IOCTL_TIOCEXCL,
	I386_RECORD_IOCTL_TIOCNXCL,
	I386_RECORD_IOCTL_TIOCSCTTY,
	I386_RECORD_IOCTL_TIOCGPGRP,
	I386_RECORD_IOCTL_TIOCSPGRP,
	I386_RECORD_IOCTL_TIOCOUTQ,
	I386_RECORD_IOCTL_TIOCSTI,
	I386_RECORD_IOCTL_TIOCGWINSZ,
	I386_RECORD_IOCTL_TIOCSWINSZ,
	I386_RECORD_IOCTL_TIOCMGET,
	I386_RECORD_IOCTL_TIOCMBIS,
	I386_RECORD_IOCTL_TIOCMBIC,
	I386_RECORD_IOCTL_TIOCMSET,
	I386_RECORD_IOCTL_TIOCGSOFTCAR,
	I386_RECORD_IOCTL_TIOCSSOFTCAR,
	I386_RECORD_IOCTL_FIONREAD,
	I386_RECORD_IOCTL_TIOCINQ,
	I386_RECORD_IOCTL_TIOCLINUX,
	I386_RECORD_IOCTL_TIOCCONS,
	I386_RECORD_IOCTL_TIOCGSERIAL,
	I386_RECORD_IOCTL_TIOCSSERIAL,
	I386_RECORD_IOCTL_TIOCPKT,
	I386_RECORD_IOCTL_FIONBIO,
	I386_RECORD_IOCTL_TIOCNOTTY,
	I386_RECORD_IOCTL_TIOCSETD,
	I386_RECORD_IOCTL_TIOCGETD,
	I386_RECORD_IOCTL_TCSBRKP,
	I386_RECORD_IOCTL_TIOCTTYGSTRUCT,
	I386_RECORD_IOCTL_TIOCSBRK,
	I386_RECORD_IOCTL_TIOCCBRK,
	I386_RECORD_IOCTL_TIOCGSID,
	I386_RECORD_IOCTL_TCGETS2,
	I386_RECORD_IOCTL_TCSETS2,
	I386_RECORD_IOCTL_TCSETSW2,
	I386_RECORD_IOCTL_TCSETSF2,
	I386_RECORD_IOCTL_TIOCGPTN,
	I386_RECORD_IOCTL_TIOCSPTLCK,
	I386_RECORD_IOCTL_FIONCLEX,
	I386_RECORD_IOCTL_FIOCLEX,
	I386_RECORD_IOCTL_FIOASYNC,
	I386_RECORD_IOCTL_TIOCSERCONFIG,
	I386_RECORD_IOCTL_TIOCSERGWILD,
	I386_RECORD_IOCTL_TIOCSERSWILD,
	I386_RECORD_IOCTL_TIOCGLCKTRMIOS,
	I386_RECORD_IOCTL_TIOCSLCKTRMIOS,
	I386_RECORD_IOCTL_TIOCSERGSTRUCT,
	I386_RECORD_IOCTL_TIOCSERGETLSR,
	I386_RECORD_IOCTL_TIOCSERGETMULTI,
	I386_RECORD_IOCTL_TIOCSERSETMULTI,
	I386_RECORD_IOCTL_TIOCMIWAIT,
	I386_RECORD_IOCTL_TIOCGICOUNT,
	I386_RECORD_IOCTL_TIOCGHAYESESP,
	I386_RECORD_IOCTL_TIOCSHAYESESP,
	I386_RECORD_IOCTL_FIOQSIZE): New macros. Ioctl request numbers in I386.
	(i386_linux_init_abi): Initialize the size of some types and ioctl
	request numbers in linux_record_tdep.
	linux-record.c (record_linux_system_call): Record more ioctl requests.
	linux-record.h (linux_record_tdep_s): Add size of some types and ioctl
	request numbers.

	Add a cleanup in function "record_wait".

	* record.c (record_wait_cleanups): New function. Clean for function
	"record_wait".
	(record_wait): Add a cleanup to call function "record_wait_cleanups".

	i386-tdep.c (i386_record_lea_modrm): If this is not a error, output
	warning message of "can't get the value of the segment register" just
	when record_debug is set.

	record.c (record_message): Change output message from "pause" to
	"stop".

	linux-record.c (record_linux_system_call): Change output message from
	"pause" to "stop".

	linux-record.c (record_linux_system_call): Make query message for
	syscall munmap more clear.

	record.c (_initialize_record): Fix a little bug.
@
text
@d2816 3
a2818 4
      if (record_debug)
	printf_unfiltered (_
			   ("Record: can't get the value of the segment register in address 0x%s. Record ignore this change.\n"),
			   paddr_nz (read_pc ()));
d4806 3
a4808 4
		if (record_debug)
		  printf_unfiltered (_
				     ("Record: can't get the value of the segment register in address 0x%s. Record ignore this change.\n"),
				     paddr_nz (read_pc ()));
d4855 3
a4857 4
		  if (record_debug)
		    printf_unfiltered (_
				       ("Record: can't get the value of the segment register in address 0x%s. Record ignore this change.\n"),
				       paddr_nz (read_pc ()));
@


1.261.2.4
log
@
	the insn number.
	(record_registers_change): Call function
	"record_check_insn_num" check the insn number. Increase
	"record_insn_num" if need.
	(record_xfer_partial): Call function "record_check_insn_num"
	check the insn number. Increase "record_insn_num" if need.

2008-08-10  Hui Zhu  <teawater@@gmail.com>

	Add the real beneath function pointers for record target.

	* Makefile.in: Add record.h to depend of target.c.
	* record.c (record_beneath_to_resume, record_beneath_to_wait,
	record_beneath_to_prepare_to_store,
	record_beneath_to_xfer_partial,
	record_beneath_to_insert_breakpoint,
	record_beneath_to_remove_breakpoint): New function pointers.
	The real beneath function pointers.
	(record_resume): Change "record_ops.beneath->to_resume" to
	"record_beneath_to_resume".
	(record_wait): Change "record_ops.beneath->to_wait" to
	"record_beneath_to_wait".
	(record_prepare_to_store): Change
	"record_ops.beneath->to_prepare_to_store" to
	"record_beneath_to_prepare_to_store".
	(record_xfer_partial): Change
	"record_ops.beneath->to_xfer_partial" to
	"record_beneath_to_xfer_partial".
	(record_insert_breakpoint): Change
	"record_ops.beneath->to_insert_breakpoint" to
	"record_beneath_to_insert_breakpoint".
	(record_remove_breakpoint): Change
	"record_ops.beneath->to_remove_breakpoint" to
	"record_beneath_to_remove_breakpoint".
	* record.h (record_beneath_to_resume,
	record_beneath_to_wait,
	record_beneath_to_prepare_to_store,
	record_beneath_to_xfer_partial,
	record_beneath_to_insert_breakpoint,
	record_beneath_to_remove_breakpoint): Extern.
	* target.c: Add include of "record.h".
	(update_current_target): Set the real beneath function
	pointers.
@
text
@d2818 2
a2819 2
			   ("Record: Record ignore the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
			   paddr_nz (i386_record_pc));
d3857 1
a3857 1
	if (override)
d3859 1
a3859 4
	    if (record_debug)
	      printf_unfiltered (_
				 ("Record: Record ignore the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
				 paddr_nz (i386_record_pc));
d3863 5
a3867 1
	    if ((opcode & 1) == 0)
d3869 3
a3871 1
		ot = OT_BYTE;
d3873 5
a3877 30
	    else
	      {
		ot = dflag + OT_WORD;
	      }
	    if (aflag)
	      {
		if (target_read_memory
		    (i386_record_pc, (gdb_byte *) & addr, 4))
		  {
		    printf_unfiltered (_
				       ("Record: read memeory 0x%s error.\n"),
				       paddr_nz (i386_record_pc));
		    return (-1);
		  }
		i386_record_pc += 4;
	      }
	    else
	      {
		if (target_read_memory
		    (i386_record_pc, (gdb_byte *) & tmpu16, 4))
		  {
		    printf_unfiltered (_
				       ("Record: read memeory 0x%s error.\n"),
				       paddr_nz (i386_record_pc));
		    return (-1);
		  }
		i386_record_pc += 2;
		addr = tmpu16;
	      }
	    if (record_arch_list_add_mem (addr, 1 << ot))
d3879 2
d3883 6
d4141 3
a4143 4
            if (record_debug)
	      printf_unfiltered (_
			         ("Record: Record ignore the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
			   paddr_nz (i386_record_pc));
d4164 1
a4164 1
	    if (aflag)
d4166 1
a4166 4
	        if (record_arch_list_add_mem (addr, count * (1 << ot)))
	          {
		    return (-1);
	          }
d4176 1
a4176 1
	    if (aflag)
d4178 1
a4178 4
	        if (record_arch_list_add_mem (addr, 1 << ot))
	          {
		    return (-1);
	          }
d4809 2
a4810 3
				     ("Record: Record ignore the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
				     paddr_nz (i386_record_pc));
error("3");
d4859 2
a4860 2
				       ("Record: Record ignore the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
				       paddr_nz (i386_record_pc));
@


1.261.2.5
log
@2008-09-09  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c (i386_record): Record the memory change of FP instructions.
@
text
@d4114 1
a4114 157
      /* It just record the memory change of instrcution. */
    case 0xd8 ... 0xdf:
      if (i386_record_modrm ())
	{
	  return (-1);
	}
      reg |= ((opcode & 7) << 3);
      if (mod != 3)
	{
	  /* memory */
	  uint32_t addr;

	  if (i386_record_lea_modrm_addr (&addr))
	    {
	      return (-1);
	    }
	  switch (reg)
	    {
	    case 0x00 ... 0x07:
	    case 0x10 ... 0x17:
	    case 0x20 ... 0x27:
	    case 0x30 ... 0x37:
	      break;
	    case 0x08:
	    case 0x0a:
	    case 0x0b:
	    case 0x18 ... 0x1b:
	    case 0x28 ... 0x2b:
	    case 0x38 ... 0x3b:
	      switch (reg & 7)
		{
		case 0:
		  break;
		case 1:
		  switch (reg >> 4)
		    {
		    case 0:
		      if (record_arch_list_add_mem (addr, 4))
			{
			  return (-1);
			}
		      break;
		    case 2:
		      if (record_arch_list_add_mem (addr, 8))
			{
			  return (-1);
			}
		      break;
		    case 3:
		    default:
		      if (record_arch_list_add_mem (addr, 2))
			{
			  return (-1);
			}
		      break;
		    }
		  break;
		default:
		  switch (reg >> 4)
		    {
		    case 0:
		    case 1:
		      if (record_arch_list_add_mem (addr, 4))
			{
			  return (-1);
			}
		      break;
		    case 2:
		      if (record_arch_list_add_mem (addr, 8))
			{
			  return (-1);
			}
		      break;
		    case 3:
		    default:
		      if (record_arch_list_add_mem (addr, 2))
			{
			  return (-1);
			}
		      break;
		    }
		  break;
		}
	      break;
	    case 0x0c:
	    case 0x0d:
	    case 0x1d:
	    case 0x2c:
	    case 0x3c:
	    case 0x3d:
	      break;
	    case 0x0e:
	      if (dflag)
		{
		  if (record_arch_list_add_mem (addr, 28))
		    {
		      return (-1);
		    }
		}
	      else
		{
		  if (record_arch_list_add_mem (addr, 14))
		    {
		      return (-1);
		    }
		}
	      break;
	    case 0x0f:
	    case 0x2f:
	      if (record_arch_list_add_mem (addr, 2))
		{
		  return (-1);
		}
	      break;
	    case 0x1f:
	    case 0x3e:
	      if (record_arch_list_add_mem (addr, 10))
		{
		  return (-1);
		}
	      break;
	    case 0x2e:
	      if (dflag)
		{
		  if (record_arch_list_add_mem (addr, 28))
		    {
		      return (-1);
		    }
		  addr += 28;
		}
	      else
		{
		  if (record_arch_list_add_mem (addr, 14))
		    {
		      return (-1);
		    }
		  addr += 14;
		}
	      if (record_arch_list_add_mem (addr, 80))
		{
		  return (-1);
		}
	      break;
	    case 0x3f:
	      if (record_arch_list_add_mem (addr, 8))
		{
		  return (-1);
		}
	      break;
	    default:
	      i386_record_pc -= 2;
	      opcode = opcode << 8 | modrm;
	      goto no_support;
	      break;
	    }
	}
      break;
@


1.261.2.6
log
@2008-09-19  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_wait): Fix the bug of forware step after
	reverse step.
	Make debug message more clean.
	Remove variable record_list_status.

	* i386-tdep.c (i386_record): Fix the bug of "0x80 ... 0x83".
@
text
@d3040 5
a3044 1
	      if (record_arch_list_add_reg (rm))
@


1.261.2.7
log
@2008-10-07  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c, inflow.c, infrun.c, linux-record.c,
	linux-record.h, record.c, record.h: Change name from
	"record and reverse target" to
	"process record and replay target".
@
text
@d2598 1
a2598 1
      printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2634 1
a2634 1
	      printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2652 1
a2652 1
		  printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2666 1
a2666 1
	      printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2676 1
a2676 1
	      printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2708 1
a2708 1
		  printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2725 1
a2725 1
	      printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2735 1
a2735 1
	      printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2818 1
a2818 1
			   ("Process record ignores the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
d2855 1
a2855 1
      fprintf_unfiltered (gdb_stdlog, "Process record: i386_record pc = 0x%s\n",
d2864 1
a2864 1
	  printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d2927 1
a2927 1
	  printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d3857 1
a3857 1
				 ("Process record ignores the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
d3876 1
a3876 1
				       ("Process record: read memeory 0x%s error.\n"),
d3888 1
a3888 1
				       ("Process record: read memeory 0x%s error.\n"),
d4309 1
a4309 1
			         ("Process record ignores the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
d4731 1
a4731 1
			 ("Process record don't support instruction fwait.\n"));
d4740 1
a4740 1
			 ("Process record doesn't support instruction int3.\n"));
d4752 1
a4752 1
	    printf_unfiltered (_("Process record: read memeory 0x%s error.\n"),
d4761 1
a4761 1
			       ("Process record doesn't support instruction int 0x%02x.\n"),
d4778 1
a4778 1
			 ("Process record doesn't support instruction into.\n"));
d4792 1
a4792 1
			 ("Process record doesn't support instruction bound.\n"));
d4834 1
a4834 1
			 ("Process record doesn't support instruction wrmsr.\n"));
d4842 1
a4842 1
			 ("Process record doesn't support instruction rdmsr.\n"));
d4850 1
a4850 1
			 ("Process record doesn't support instruction rdtsc.\n"));
d4862 1
a4862 1
			       ("Process record doesn't support instruction sysenter.\n"));
d4877 1
a4877 1
			 ("Process record doesn't support instruction sysexit.\n"));
d4905 1
a4905 1
			 ("Process record doesn't support instruction hlt.\n"));
d4982 1
a4982 1
				     ("Process record ignores the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
d5033 1
a5033 1
				       ("Process record ignores the memory change of instruction in address 0x%s because it can't get the value of the segment register.\n"),
d5252 1
a5252 1
		     ("Process record doesn't support instruction 0x%02x at address 0x%s.\n"),
@


1.260
log
@	* i386-tdep.c (i386_16_byte_align_p): New.
	(i386_push_dummy_call): Determine stack space required for
	arguments going forwards allowing for 16-byte alignment, then push
	arguments going forwards.
@
text
@d453 3
a455 2
              fprintf_unfiltered (gdb_stdlog,
                                  "displaced: stepped breakpoint\n");
@


1.259
log
@	* gdbarch.sh (gdbarch_skip_main_prologue): New.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.h (i386_skip_main_prologue): Declare.
	* i386-tdep.c (i386_skip_main_prologue): New.
	* i386-cygwin-tdep.c (i386_cygwin_init_abi): Register
	i386_skip_main_prologue as gdbarch_skip_main_prologue gdbarch callback.
	* symtab.c (find_function_start_sal): When pc points at the "main"
	function, call gdbarch_skip_main_prologue.
@
text
@d1524 28
d1560 6
d1567 1
a1567 2
  /* Push arguments in reverse order.  */
  for (i = nargs - 1; i >= 0; i--)
d1569 2
a1570 1
      int len = TYPE_LENGTH (value_enclosing_type (args[i]));
d1572 12
a1583 1
      /* The System V ABI says that:
d1585 3
a1587 3
	 "An argument's size is increased, if necessary, to make it a
	 multiple of [32-bit] words.  This may require tail padding,
	 depending on the size of the argument."
d1589 26
a1614 4
	 This makes sure the stack stays word-aligned.  */
      sp -= (len + 3) & ~3;
      write_memory (sp, value_contents_all (args[i]), len);
    }
d1616 6
a1621 6
  /* Push value address.  */
  if (struct_return)
    {
      sp -= 4;
      store_unsigned_integer (buf, 4, struct_addr);
      write_memory (sp, buf, 4);
@


1.258
log
@	* gdbarch.sh: Delete dwarf_reg_to_regnum.
	* gdbarch.c, gdbarch.h: Regenerated.
	* amd64-tdep.c, arm-tdep.c, h8300-tdep.c, hppa-linux-tdep.c,
	hppa-tdep.c, i386-tdep.c, m32c-tdep.c, m68k-tdep.c, mips-tdep.c,
	s390-tdep.c, xtensa-tdep.c: Do not set dwarf_reg_to_regnum.

	* gdbint.texinfo (Target Conditionals): Delete entry for
	gdbarch_dwarf_reg_to_regnum.
@
text
@d1163 32
@


1.257
log
@	Implement displaced stepping.

	gdb/
	* gdbarch.sh (max_insn_length): New 'variable'.
	(displaced_step_copy, displaced_step_fixup)
	(displaced_step_free_closure, displaced_step_location): New
	functions.
	(struct displaced_step_closure): Add forward declaration.
	* gdbarch.c, gdbarch.h: Regenerated.

	* arch-utils.c: #include "objfiles.h".
	(simple_displaced_step_copy_insn)
	(simple_displaced_step_free_closure)
	(displaced_step_at_entry_point): New functions.
	* arch-utils.h (simple_displaced_step_copy_insn)
	(simple_displaced_step_free_closure)
	(displaced_step_at_entry_point): New prototypes.

	* i386-tdep.c (I386_MAX_INSN_LEN): Rename to...
	(I386_MAX_MATCHED_INSN_LEN): ... this.
	(i386_absolute_jmp_p, i386_absolute_call_p)
	(i386_ret_p, i386_call_p, i386_breakpoint_p, i386_syscall_p)
	(i386_displaced_step_fixup): New functions.
	(struct i386_insn, i386_match_insn): Update.
	(i386_gdbarch_init): Set gdbarch_max_insn_length.
	* i386-tdep.h (I386_MAX_INSN_LEN): New.
	(i386_displaced_step_fixup): New prototype.
	* i386-linux-tdep.c (i386_linux_init_abi): Include "arch-utils.h".
	Register gdbarch_displaced_step_copy,
	gdbarch_displaced_step_fixup, gdbarch_displaced_step_free_closure,
	and gdbarch_displaced_step_location functions.

	* infrun.c (debug_displaced): New variable.
	(show_debug_displaced): New function.
	(struct displaced_step_request): New struct.
	(displaced_step_request_queue, displaced_step_ptid)
	(displaced_step_gdbarch, displaced_step_closure)
	(displaced_step_original, displaced_step_copy)
	(displaced_step_saved_copy, can_use_displaced_stepping): New
	variables.
	(show_can_use_displaced_stepping, use_displaced_stepping)
	(displaced_step_clear, cleanup_displaced_step_closure)
	(displaced_step_dump_bytes, displaced_step_prepare)
	(displaced_step_clear_cleanup, write_memory_ptid)
	(displaced_step_fixup): New functions.
	(resume): Call displaced_step_prepare.
	(proceed): Call read_pc once, and remember the value.  If using
	displaced stepping, don't remove breakpoints.
	(handle_inferior_event): Call displaced_step_fixup.  Add some
	debugging output.  When we try to step over a breakpoint, but get
	a signal to deliver to the thread instead, ensure the step-resume
	breakpoint is actually inserted.  If a thread hop is needed, and
	displaced stepping is enabled, don't remove breakpoints.
	(init_wait_for_inferior): Call displaced_step_clear.
	(_initialize_infrun): Add "set debug displaced" command.  Add
	"maint set can-use-displaced-stepping" command.  Clear
	displaced_step_ptid.
	* inferior.h (debug_displaced): Declare variable.
	(displaced_step_dump_bytes): Declare function.

	* Makefile.in (arch-utils.o, i386-linux-tdep.o): Update
	dependencies.

	gdb/testsuite/
	* gdb.asm/asmsrc1.s: Add scratch space.

	gdb/doc/
	* gdb.texinfo (Debugging Output): Document "set/show debug
	displaced".
	(Maintenance Commands): Document "maint set/show
	can-use-displaced-stepping".
@
text
@d2570 1
a2570 2
  /* Use the SVR4 register numbering scheme for DWARF and DWARF 2.  */
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, i386_svr4_reg_to_regnum);
@


1.256
log
@	Update i386 and amd64 ports for unwinder changes.

	* amd64-tdep.c (amd64_frame_cache): Expect this_frame.
	(amd64_frame_this_id, amd64_frame_prev_register): Update signature.
	(amd64_frame_unwind): Use default_frame_sniffer.
	(amd64_frame_sniffer): Delete.
	(amd64_sigtramp_frame_cache): Expect this_frame.
	(amd64_sigtramp_frame_this_id, amd64_sigtramp_frame_prev_register)
	(amd64_sigtramp_frame_sniffer): Update signature.
	(amd64_sigtramp_frame_unwind): Add amd64_sigtramp_frame_sniffer.
	(amd64_frame_base_address): Expect this_frame.
	(amd64_dummy_id): Renamed from amd64_unwind_dummy_id.  Expect
	this_frame.
	(amd64_init_abi): Use set_gdbarch_dummy_id and
	frame_unwind_append_unwinder.
	* i386-tdep.c (i386_frame_cache): Expect this_frame.
	(i386_frame_this_id, i386_frame_prev_register): Update signature.
	(i386_frame_unwind): Use default_frame_sniffer.
	(i386_frame_sniffer): Delete.
	(i386_sigtramp_frame_cache): Expect this_frame.
	(i386_sigtramp_frame_this_id, i386_sigtramp_frame_prev_register)
	(i386_sigtramp_frame_sniffer): Update signature.
	(i386_sigtramp_frame_unwind): Use i386_sigtramp_frame_sniffer.
	(i386_frame_base_address): Update signature.
	(i386_dummy_id): Rename from i386_unwind_dummy_id.  Expect this_frame.
	(i386_push_dummy_call): Update comment.
	(i386_sigtramp_p, i386_svr4_sigtramp_p, i386_svr4_sigcontext_addr):
	Expect this_frame.
	(i386_gdbarch_init): Use set_gdbarch_dummy_id, dwarf2_append_unwinders,
	and frame_unwind_append_unwinder.
	* amd64-linux-tdep.c, amd64-sol2-tdep.c, amd64fbsd-tdep.c,
	amd64nbsd-tdep.c, amd64obsd-tdep.c, i386-linux-tdep.c,
	i386-nto-tdep.c, i386bsd-tdep.c, i386-sol2-tdep.c, i386obsd-tdep.c,
	i386nbsd-tdep.c: Update for unwinder changes.
@
text
@d279 219
d743 1
a743 1
#define I386_MAX_INSN_LEN	6
d749 2
a750 2
  gdb_byte insn[I386_MAX_INSN_LEN];
  gdb_byte mask[I386_MAX_INSN_LEN];
d769 1
a769 1
	  gdb_byte buf[I386_MAX_INSN_LEN - 1];
d774 1
a774 1
	  gdb_assert (insn->len <= I386_MAX_INSN_LEN);
d2597 1
@


1.255
log
@	* amd64-tdep.c (amd64_get_longjmp_target): New.
	(amd64_init_abi): Register amd64_get_longjmp_target as
	gdbarch_get_longjmp_target callback.
	* i386-tdep.c (i386_get_longjmp_target): Remove 64-bit handling.
@
text
@d959 1
a959 1
i386_frame_cache (struct frame_info *next_frame, void **this_cache)
d980 1
a980 1
  frame_unwind_register (next_frame, I386_EBP_REGNUM, buf);
d988 1
a988 1
  cache->pc = frame_func_unwind (next_frame, NORMAL_FRAME);
d990 1
a990 1
    i386_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);
d995 1
a995 1
      frame_unwind_register (next_frame, I386_ECX_REGNUM, buf);
d1020 1
a1020 1
	  frame_unwind_register (next_frame, I386_ESP_REGNUM, buf);
d1040 1
a1040 1
i386_frame_this_id (struct frame_info *next_frame, void **this_cache,
d1043 1
a1043 1
  struct i386_frame_cache *cache = i386_frame_cache (next_frame, this_cache);
d1053 3
a1055 5
static void
i386_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, gdb_byte *valuep)
d1057 1
a1057 1
  struct i386_frame_cache *cache = i386_frame_cache (next_frame, this_cache);
d1082 1
a1082 7
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  ULONGEST val;
d1084 3
a1086 8
	  /* Clear the direction flag.  */
	  val = frame_unwind_register_unsigned (next_frame,
						I386_EFLAGS_REGNUM);
	  val &= ~(1 << 10);
	  store_unsigned_integer (valuep, 4, val);
	}

      return;
d1090 1
a1090 9
    {
      *optimizedp = 0;
      *lvalp = lval_register;
      *addrp = 0;
      *realnump = I386_EAX_REGNUM;
      if (valuep)
	frame_unwind_register (next_frame, (*realnump), valuep);
      return;
    }
d1093 1
a1093 12
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_unsigned_integer (valuep, 4, cache->saved_sp);
	}
      return;
    }
d1096 2
a1097 13
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (get_frame_arch (next_frame), regnum));
	}
      return;
    }
d1099 1
a1099 6
  *optimizedp = 0;
  *lvalp = lval_register;
  *addrp = 0;
  *realnump = regnum;
  if (valuep)
    frame_unwind_register (next_frame, (*realnump), valuep);
d1106 3
a1108 1
  i386_frame_prev_register
a1109 6

static const struct frame_unwind *
i386_frame_sniffer (struct frame_info *next_frame)
{
  return &i386_frame_unwind;
}
d1115 1
a1115 1
i386_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
d1118 1
a1118 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (next_frame));
d1127 1
a1127 1
  frame_unwind_register (next_frame, I386_ESP_REGNUM, buf);
d1130 1
a1130 1
  addr = tdep->sigcontext_addr (next_frame);
d1152 1
a1152 1
i386_sigtramp_frame_this_id (struct frame_info *next_frame, void **this_cache,
d1156 1
a1156 1
    i386_sigtramp_frame_cache (next_frame, this_cache);
d1159 1
a1159 1
  (*this_id) = frame_id_build (cache->base + 8, frame_pc_unwind (next_frame));
d1162 3
a1164 6
static void
i386_sigtramp_frame_prev_register (struct frame_info *next_frame,
				   void **this_cache,
				   int regnum, int *optimizedp,
				   enum lval_type *lvalp, CORE_ADDR *addrp,
				   int *realnump, gdb_byte *valuep)
d1167 1
a1167 1
  i386_sigtramp_frame_cache (next_frame, this_cache);
d1169 1
a1169 2
  i386_frame_prev_register (next_frame, this_cache, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
d1172 4
a1175 9
static const struct frame_unwind i386_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  i386_sigtramp_frame_this_id,
  i386_sigtramp_frame_prev_register
};

static const struct frame_unwind *
i386_sigtramp_frame_sniffer (struct frame_info *next_frame)
d1177 1
a1177 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (next_frame));
d1182 1
a1182 1
    return NULL;
d1186 2
a1187 2
      if (tdep->sigtramp_p (next_frame))
	return &i386_sigtramp_frame_unwind;
d1192 1
a1192 1
      CORE_ADDR pc = frame_pc_unwind (next_frame);
d1196 1
a1196 1
	return &i386_sigtramp_frame_unwind;
d1199 1
a1199 1
  return NULL;
d1201 9
d1213 1
a1213 1
i386_frame_base_address (struct frame_info *next_frame, void **this_cache)
d1215 1
a1215 1
  struct i386_frame_cache *cache = i386_frame_cache (next_frame, this_cache);
d1229 1
a1229 1
i386_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
a1230 1
  gdb_byte buf[4];
d1233 1
a1233 2
  frame_unwind_register (next_frame, I386_EBP_REGNUM, buf);
  fp = extract_unsigned_integer (buf, 4);
d1236 1
a1236 1
  return frame_id_build (fp + 8, frame_pc_unwind (next_frame));
d1320 1
a1320 1
     i386_unwind_dummy_id).  It's there, since all frame unwinders for
d2057 2
a2058 2
/* Return whether the frame preceding NEXT_FRAME corresponds to a
   sigtramp routine.  */
d2061 1
a2061 1
i386_sigtramp_p (struct frame_info *next_frame)
d2063 1
a2063 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d2095 2
a2096 2
/* Return whether the frame preceding NEXT_FRAME corresponds to a SVR4
   sigtramp routine.  */
d2099 1
a2099 1
i386_svr4_sigtramp_p (struct frame_info *next_frame)
d2101 1
a2101 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d2112 2
a2113 3
/* Assuming NEXT_FRAME is for a frame following a SVR4 sigtramp
   routine, return the address of the associated sigcontext (ucontext)
   structure.  */
d2116 1
a2116 1
i386_svr4_sigcontext_addr (struct frame_info *next_frame)
d2121 1
a2121 1
  frame_unwind_register (next_frame, I386_ESP_REGNUM, buf);
d2388 1
a2388 1
  set_gdbarch_unwind_dummy_id (gdbarch, i386_unwind_dummy_id);
d2400 1
a2400 1
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
d2407 2
a2408 2
  frame_unwind_append_sniffer (gdbarch, i386_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, i386_frame_sniffer);
@


1.254
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d1298 1
a1298 3
   success.

   This function is 64-bit safe.  */
d1303 1
a1303 1
  gdb_byte buf[8];
a1306 1
  int len = TYPE_LENGTH (builtin_type_void_func_ptr);
d1313 3
a1315 5
  /* Don't use I386_ESP_REGNUM here, since this function is also used
     for AMD64.  */
  get_frame_register (frame, gdbarch_sp_regnum (gdbarch), buf);
  sp = extract_typed_address (buf, builtin_type_void_data_ptr);
  if (target_read_memory (sp + len, buf, len))
d1318 2
a1319 2
  jb_addr = extract_typed_address (buf, builtin_type_void_data_ptr);
  if (target_read_memory (jb_addr + jb_pc_offset, buf, len))
d1322 1
a1322 1
  *pc = extract_typed_address (buf, builtin_type_void_func_ptr);
@


1.253
log
@
	* i386-tdep.c (i386_print_insn): Remove unnecessary call to
	gdbarch_bfd_arch_info.
@
text
@d1563 3
a1565 3
i386_return_value (struct gdbarch *gdbarch, struct type *type,
		   struct regcache *regcache, gdb_byte *readbuf,
		   const gdb_byte *writebuf)
d1614 2
a1615 1
      return i386_return_value (gdbarch, type, regcache, readbuf, writebuf);
@


1.252
log
@	* breakpoint.h (breakpoint_restore_shadows): New
	declaration.
	* breakpoint.c (breakpoint_restore_shadows): New.
	(read_memory_nobpt): Delete.
	* gdbcore.h (read_memory_nobpt): Delete declaration.
	* target.c (memory_xfer_partial): Call
	breakpoint_restore_shadows.
	(restore_show_memory_breakpoints)
	(make_show_memory_beakpoints_cleanup): New.
	(show_memory_breakpoints): New.
	* target.h (make_show_memory_beakpoints_cleanup): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint):
	Make sure we see memory breakpoints when checking if
	breakpoint is still there.
	* alpha-tdep.c, alphanbsd-tdep.c, frame.c, frv-tdep.c,
	hppa-linux-tdep.c, hppa-tdep.c, i386-linux-nat.c, i386-tdep.c,
	m68klinux-tdep.c, mips-tdep.c, mn10300-tdep.c, s390-tdep.c,
	sparc-tdep.c: Use target_read_memory instead of read_memory_nobpt.
@
text
@a2140 1
  info->mach = gdbarch_bfd_arch_info (current_gdbarch)->mach;
@


1.251
log
@
	* win32-nat.c (do_win32_fetch_inferior_registers): Use get_regcache_arch
	to get at the current architecture and at the target specific vector.
	Add target specific vector to I387_FISEG_REGNUM and I387_FOP_REGNUM and
	remove define of I387_ST0_REGNUM.

	* amd64-tdep.c (I387_ST0_REGNUM): Remove define.

	(amd64_supply_fxsave, amd64_collect_fxsave): Use get_regcache_arch to
	get at the current architecture
	(I387_FISEG_REGNUM, I387_FOSEG_REGNUM): Add target specific vector as
	parameter.

	* i386-tdep.c: Remove various define's and undef's of I387_ST0_REGNUM,
	I387_NUM_XMM_REGS and I387_MM0_REGNUM.

	(I387_NUM_XMM_REGS, I387_XMM0_REGNUM, I387_MXCSR_REGNUM,
	I387_ST0_REGNUM, I387_FCTRL_REGNUM, I387_MM0_REGNUM,
	(I387_FSTAT_REGNUM): Add target specific vector as parameter.

	(i386_register_name, i386_dbx_reg_to_regnum): Use gdbarch_tdep to get
	at the target specific vector.

	(i386_get_longjmp_target): Use get_frame_arch to get at the current
	architecture. Use gdbarch_tdep to get at the target specific vector.

	(i386_fp_regnum_p, i386_fpc_regnum_p): Add gdbarch as parameter and
	update caller. Use gdbarch_tdep to get at the target specific vector.

	(i386_register_to_value: Use get_frame_arch to get at the current
	architecture.

	* i386-tdep.h (i386_fp_regnum_p, i386_fpc_regnum_p): Add gdbarch as
	parameter.

	* i387-tdep.c (I387_FCTRL_REGNUM, I387_FSTAT_REGNUM, I387_FTAG_REGNUM,
	I387_FISEG_REGNUM, I387_FIOFF_REGNUM, I387_FOSEG_REGNUM
	I387_FOOFF_REGNUM, I387_FOP_REGNUM, I387_ST0_REGNUM, FSAVE_ADDR,
	FXSAVE_ADDR, I387_XMM0_REGNUM): Add target specific vector as parameter.

	(I387_ST0_REGNUM, I387_NUM_XMM_REGS): Remove various define's and
	undef's.

	(i387_convert_register_p, i387_register_to_value,
	i387_value_to_register): Update call for i386_fp_regnum_p.

	* i387-tdep.h: Remove comment.
	(I387_ST0_REGNUM, I387_NUM_XMM_REGS, I387_MM0_REGNUM): Add define.
	(I387_FCTRL_REGNUM, I387_FSTAT_REGNUM, I387_FTAG_REGNUM,
	I387_FISEG_REGNUM, I387_FIOFF_REGNUM, I387_FOSEG_REGNUM,
	I387_FOOFF_REGNUM, I387_FOP_REGNUM, I387_XMM0_REGNUM,
	I387_MXCSR_REGNUM): Add target specific vector as parameter.
@
text
@d347 1
a347 1
  read_memory_nobpt (pc, &op, 1);
d413 1
a413 1
  read_memory_nobpt (pc, &op, 1);
d418 1
a418 1
  read_memory_nobpt (pc + 1, buf, 4);
d457 1
a457 1
  read_memory_nobpt (pc, &op, 1);
d544 1
a544 1
  read_memory_nobpt (pc, &op, 1);
d557 1
a557 1
	  read_memory_nobpt (pc + 1, buf, insn->len - 1);
d635 1
a635 1
  read_memory_nobpt (pc, &op, 1);
d644 1
a644 1
	  read_memory_nobpt (pc, &op, 1);
d660 1
a660 1
	  read_memory_nobpt (pc + 1, &op, 1);
d664 1
a664 1
	      read_memory_nobpt (pc, &op, 1);
d688 1
a688 1
  read_memory_nobpt (pc, &op, 1);
d723 1
a723 1
      read_memory_nobpt (pc + skip, &op, 1);
d757 1
a757 1
      read_memory_nobpt (pc, &op, 1);
d813 1
a813 1
      read_memory_nobpt (pc, &op, 1);
d903 1
a903 1
      read_memory_nobpt (pc + i, &op, 1);
d911 1
a911 1
      read_memory_nobpt (pc + delta, &op, 1);
d924 1
a924 1
          read_memory_nobpt (pc + delta, &op, 1);
@


1.250
log
@	* amd64-tdep.c (amd64_classify): Add support for decimal float
	types.
	* i386-tdep.c (i386_return_value): Make 128-bit decimal float
	use the struct return convention.
@
text
@d99 1
a99 4
#define I387_ST0_REGNUM tdep->st0_regnum
#define I387_NUM_XMM_REGS tdep->num_xmm_regs

  if (I387_NUM_XMM_REGS == 0)
d102 2
a103 4
  return (I387_XMM0_REGNUM <= regnum && regnum < I387_MXCSR_REGNUM);

#undef I387_ST0_REGNUM
#undef I387_NUM_XMM_REGS
d111 1
a111 4
#define I387_ST0_REGNUM tdep->st0_regnum
#define I387_NUM_XMM_REGS tdep->num_xmm_regs

  if (I387_NUM_XMM_REGS == 0)
d114 1
a114 4
  return (regnum == I387_MXCSR_REGNUM);

#undef I387_ST0_REGNUM
#undef I387_NUM_XMM_REGS
a116 4
#define I387_ST0_REGNUM (gdbarch_tdep (current_gdbarch)->st0_regnum)
#define I387_MM0_REGNUM (gdbarch_tdep (current_gdbarch)->mm0_regnum)
#define I387_NUM_XMM_REGS (gdbarch_tdep (current_gdbarch)->num_xmm_regs)

d120 1
a120 1
i386_fp_regnum_p (int regnum)
d122 3
a124 1
  if (I387_ST0_REGNUM < 0)
d127 2
a128 1
  return (I387_ST0_REGNUM <= regnum && regnum < I387_FCTRL_REGNUM);
d132 1
a132 1
i386_fpc_regnum_p (int regnum)
d134 3
a136 1
  if (I387_ST0_REGNUM < 0)
d139 2
a140 1
  return (I387_FCTRL_REGNUM <= regnum && regnum < I387_XMM0_REGNUM);
d149 1
a149 1
    return i386_mmx_names[regnum - I387_MM0_REGNUM];
d163 2
d181 1
a181 1
      return reg - 12 + I387_ST0_REGNUM;
d186 1
a186 1
      return reg - 21 + I387_XMM0_REGNUM;
d191 1
a191 1
      return reg - 29 + I387_MM0_REGNUM;
d204 2
d219 1
a219 1
      return reg - 11 + I387_ST0_REGNUM;
d229 3
a231 3
    case 37: return I387_FCTRL_REGNUM;
    case 38: return I387_FSTAT_REGNUM;
    case 39: return I387_MXCSR_REGNUM;
a243 3
#undef I387_ST0_REGNUM
#undef I387_MM0_REGNUM
#undef I387_NUM_XMM_REGS
d1307 2
a1308 1
  int jb_pc_offset = gdbarch_tdep (get_frame_arch (frame))->jb_pc_offset;
d1318 1
a1318 1
  get_frame_register (frame, gdbarch_sp_regnum (get_frame_arch (frame)), buf);
a1454 4
  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for the architecture.  */
#define I387_ST0_REGNUM I386_ST0_REGNUM

d1481 1
a1481 1
      regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM, &fstat);
d1483 1
a1483 1
      regcache_raw_write_unsigned (regcache, I387_FSTAT_REGNUM, fstat);
d1488 1
a1488 1
      regcache_raw_write_unsigned (regcache, I387_FTAG_REGNUM, 0x3fff);
a1506 2

#undef I387_ST0_REGNUM
d1776 1
a1776 1
  if (i386_fp_regnum_p (regnum))
d1785 1
a1785 4
#define I387_ST0_REGNUM I386_ST0_REGNUM
#define I387_NUM_XMM_REGS (gdbarch_tdep (gdbarch)->num_xmm_regs)

  if (regnum == I387_MXCSR_REGNUM)
a1787 3
#undef I387_ST0_REGNUM
#undef I387_NUM_XMM_REGS

a1801 4
  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for REGCACHE's architecture.  */
#define I387_ST0_REGNUM tdep->st0_regnum

d1803 1
a1803 1
  regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM, &fstat);
d1807 1
a1807 3
  return (I387_ST0_REGNUM + fpreg);

#undef I387_ST0_REGNUM
d1914 1
d1920 1
a1920 1
  if (i386_fp_regnum_p (regnum))
d1933 1
a1933 1
      gdb_assert (register_size (get_frame_arch (frame), regnum) == 4);
d1951 1
a1951 1
  if (i386_fp_regnum_p (regnum))
d2265 2
a2266 2
  int fp_regnum_p = (i386_fp_regnum_p (regnum)
		     || i386_fpc_regnum_p (regnum));
@


1.249
log
@	* i386-tdep.c (i386_skip_noop): New function.
	(i386_analyze_prologue): Call i386_skip_noop function.
@
text
@d1582 6
a1587 4
  if ((code == TYPE_CODE_STRUCT
       || code == TYPE_CODE_UNION
       || code == TYPE_CODE_ARRAY)
      && !i386_reg_struct_return_p (gdbarch, type))
@


1.249.2.1
log
@        * amd64-tdep.c (amd64_classify): Add support for decimal float
        types.
        * i386-tdep.c (i386_return_value): Make 128-bit decimal float
        use the struct return convention.
@
text
@d1582 4
a1585 6
  if (((code == TYPE_CODE_STRUCT
	|| code == TYPE_CODE_UNION
	|| code == TYPE_CODE_ARRAY)
       && !i386_reg_struct_return_p (gdbarch, type))
      /* 128-bit decimal float uses the struct return convention.  */
      || (code == TYPE_CODE_DECFLOAT && TYPE_LENGTH (type) == 16))
@


1.248
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d635 45
d865 1
@


1.247
log
@	Updated copyright notices for most files.
@
text
@d831 1
a831 1
i386_skip_prologue (CORE_ADDR start_pc)
@


1.246
log
@	* gdbarch.sh (stab_reg_to_regnum, dwarf_reg_to_regnum)
	( dwarf2_reg_to_regnum, sdb_reg_to_regnum, ecoff_reg_to_regnum): Add
	gdbarch as parameter.
	* gdbarch.{c,h}: Regenerate.

	* xtensa-tdep.c (xtensa_reg_to_regnum): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* s390-tdep.c (s390_dwarf_reg_to_regnum): Likewise.
	* rs6000-tdep.c (rs6000_stab_reg_to_regnum)
	(rs6000_dwarf2_reg_to_regnum): Likewise.
	* mips-tdep.c (mips_stab_reg_to_regnum)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum): Likewise.
	* mep-tdep.c (mep_debug_reg_to_regnum): Likewise.
	* m32c-tdep.c (m32c_debug_info_reg_to_regnum): Likewise.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise
	* h8300-tdep.c (h8300s_dbg_reg_to_regnum)
	(h8300_dbg_reg_to_regnum): Likewise.
	* amd64-tdep.c (amd64_dwarf_reg_to_regnum): Likewise.
	* arch-utils.c (no_op_reg_to_regnum): Likewise.
	* arch-utils.h (no_op_reg_to_regnum): Likewise.
	* arm-tdep.c (arm_dwarf_reg_to_regnum): Likewise.
	* cris-tdep.c (cris_dwarf2_reg_to_regnum): Likewise.
	* hppa-tdep.c (hppa64_dwarf_reg_to_regnum): Likewise.
	* ia64-tdep.c (ia64_dwarf_reg_to_regnum): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
@
text
@d4 1
a4 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.245
log
@	* gdbarch.sh (convert_register_p): Add gdbarch as parameter.
	* ia64-tdep.c (ia64_convert_register_p): Likewise.
	* i387-tdep.c (i387_convert_register_p): Likewise.
	* i387-tdep.h (i387_convert_register_p): Likewise.
	* alpha-tdep.c (alpha_convert_register_p): Likewise.
	* gdbarch.{c,h}: Regenerate.

	* rs6000-tdep.c (rs6000_convert_register_p): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* mips-tdep.c (mips_convert_register_p): Likewise.
	* m68k-tdep.c (m68k_convert_register_p): Likewise.
	* i386-tdep.c (i386_convert_register_p): Likewise.
@
text
@d170 1
a170 1
i386_dbx_reg_to_regnum (int reg)
d202 1
a202 2
  return gdbarch_num_regs (current_gdbarch)
	 + gdbarch_num_pseudo_regs (current_gdbarch);
d209 1
a209 1
i386_svr4_reg_to_regnum (int reg)
d229 1
a229 1
      return i386_dbx_reg_to_regnum (reg);
d246 1
a246 2
  return gdbarch_num_regs (current_gdbarch)
	 + gdbarch_num_pseudo_regs (current_gdbarch);
@


1.244
log
@*** empty log message ***
@
text
@d1860 1
a1860 1
i386_convert_register_p (int regnum, struct type *type)
d1883 1
a1883 1
  return i387_convert_register_p (regnum, type);
@


1.243
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d281 1
a281 1
i386_breakpoint_from_pc (CORE_ADDR *pc, int *len)
@


1.242
log
@	* amd64-tdep.c (amd64_convert_register_p): Delete.
	(amd64_init_abi): Use i387_convert_register_p.
	* alpha-tdep.c (alpha_convert_register_p): Return zero for
	eight byte types.
	(alpha_register_to_value, alpha_value_to_register): Do not handle
	eight byte types.
	* i386-tdep.c (i386_convert_register_p): Use i387_convert_register_p.
	* i387-tdep.c (i387_convert_register_p): New.
	(i387_register_to_value, i387_value_to_register): Update comments.
	* i387-tdep.h (i387_convert_register_p): Declare.
	* ia64-tdep.c (ia64_convert_register_p): Return zero for
	builtin_type_ia64_ext.
	(ia64_gdbarch_init): Do not initialize builtin_type_ia64_ext here.
	(_initialize_ia64_tdep): Initialize builtin_type_ia64_ext here.
	* m68k-tdep.c (m68k_convert_register_p): Return zero for
	builtin_type_m68881_ext.
	(m68k_register_to_value, m68k_value_to_register): Update comments.

	* gdbint.texinfo (Register and Memory Data, Target Conditionals):
	Document that gdbarch_convert_register_p should return zero for no-op
	conversions.
@
text
@d155 1
a155 1
i386_register_name (int regnum)
d157 1
a157 1
  if (i386_mmx_regnum_p (current_gdbarch, regnum))
d1753 1
a1753 1
#define I387_NUM_XMM_REGS (gdbarch_tdep (current_gdbarch)->num_xmm_regs)
@


1.241
log
@	* gdbarch.sh (static_transform_name): New gdbarch callback.
	* gdbarch.c, gdbarch.h: Regenerate.
	* dbxread.c (read_dbx_symtab): Use gdbarch_static_transform_name
	instead of STATIC_TRANSFORM_NAME.
	* mdebugread.c (parse_partial_symbols): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* xcoffread.c (scan_xcoff_symtab): Likewise.

	* config/i368/tm-i386sol2.h (STATIC_TRANSFORM_NAME): Remove.
	(IS_STATIC_TRANSFORM_NAME): Remove.
	* i386-tdep.c (sunpro_static_transform_name): Remove, move to ...
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): ... here.
	(i386_sol2_init_abi): Install it.

	* config/sparc/tm-sol2.h (STATIC_TRANSFORM_NAME): Remove.
	(IS_STATIC_TRANSFORM_NAME): Remove.
	* sparc-tdep.c (sparc_stabs_unglobalize_name): Remove, move to ...
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): ... here.
	(sparc32_sol2_init_abi): Install it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Likewise.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Add prototype.
@
text
@d1883 1
a1883 1
  return i386_fp_regnum_p (regnum);
@


1.240
log
@2007-10-09  Markus Deuling  <deuling@@de.ibm.com>

	* i386-linux-nat.c (fetch_register): Use get_regcache_arch to get at
	the current architecture by regcache.
	(store_register, supply_gregset, fill_gregset, i386_linux_resume)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* i386-nto-tdep.c (i386nto_supply_gregset): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Replace current_gdbarch by gdbarch.
	(i386_extract_return_value, i386_store_return_value): Likewise.
	* i386-tdep.c (i386_frame_prev_register): Use get_frame_arch to get at
	the current architecture by frame_info.
	(i386_sigtramp_frame_cache, i386_get_longjmp_target)
	(i386_register_to_value, i386_value_to_register): Likewise.
@
text
@a2069 26
#ifdef STATIC_TRANSFORM_NAME
/* SunPRO encodes the static variables.  This is not related to C++
   mangling, it is done for C too.  */

char *
sunpro_static_transform_name (char *name)
{
  char *p;
  if (IS_STATIC_TRANSFORM_NAME (name))
    {
      /* For file-local statics there will be a period, a bunch of
         junk (the contents of which match a string given in the
         N_OPT), a period and the name.  For function-local statics
         there will be a bunch of junk (which seems to change the
         second character from 'A' to 'B'), a period, the name of the
         function, and the name.  So just skip everything before the
         last period.  */
      p = strrchr (name, '.');
      if (p != NULL)
	name = p + 1;
    }
  return name;
}
#endif /* STATIC_TRANSFORM_NAME */


@


1.239
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d915 1
a915 1
  frame_unwind_register (next_frame, gdbarch_pc_regnum (current_gdbarch), buf);
d1101 1
a1101 1
		       register_size (current_gdbarch, regnum));
d1134 1
a1134 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1281 1
a1281 1
  get_frame_register (frame, gdbarch_sp_regnum (current_gdbarch), buf);
d1387 2
a1388 2
      int low_size = register_size (current_gdbarch, LOW_RETURN_REGNUM);
      int high_size = register_size (current_gdbarch, HIGH_RETURN_REGNUM);
d1459 2
a1460 2
      int low_size = register_size (current_gdbarch, LOW_RETURN_REGNUM);
      int high_size = register_size (current_gdbarch, HIGH_RETURN_REGNUM);
d1911 1
a1911 1
      gdb_assert (register_size (current_gdbarch, regnum) == 4);
d1942 1
a1942 1
      gdb_assert (register_size (current_gdbarch, regnum) == 4);
@


1.238
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.237
log
@	* gdbtypes.c (builtin_type_v2_double, builtin_type_v4_float,
	builtin_type_v2_int64, builtin_type_v4_int32, builtin_type_v8_int16,
	builtin_type_v16_int8, builtin_type_v2_float, builtin_type_v2_int32,
	builtin_type_v4_int16, builtin_type_v8_int8, builtin_type_v4sf,
	builtin_type_v4si, builtin_type_v16qi, builtin_type_v8qi,
	builtin_type_v8hi, builtin_type_v4hi, builtin_type_v2si,
	builtin_type_vec64, builtin_type_vec128): Remove.
	(init_simd_type): Remove.
	(init_vector_type): Make global.
	(build_builtin_type_vec64, build_builtin_type_vec128): Remove.
	(build_gdbtypes): Do not build vector types.
	(_initialize_gdbtypes): Do not swap vector types.
	* gdbtypes.h (builtin_type_v2_double, builtin_type_v4_float,
	builtin_type_v2_int64, builtin_type_v4_int32, builtin_type_v8_int16,
	builtin_type_v16_int8, builtin_type_v2_float, builtin_type_v2_int32,
	builtin_type_v4_int16, builtin_type_v8_int8, builtin_type_v4sf,
	builtin_type_v4si, builtin_type_v16qi, builtin_type_v8qi,
	builtin_type_v8hi, builtin_type_v4hi, builtin_type_v2si,
	builtin_type_vec64, builtin_type_vec128): Remove declarations.
	(init_vector_type): Add prototype.

	* i386-tdep.h (struct gdbarch_tdep): Add i386_mmx_type and
	i386_sse_type members.
	(i386_mmx_type, i386_sse_type): Change from variables to functions.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Remove variables.
	(i386_init_types): Do not build vector types.
	(i386_mmx_type, i386_sse_type): New functions.
	(i386_register_type): Call them instead of using global variables.
	(i386_gdbarch_init): Use XCALLOC to allocate tdep structure.
	* amd64-tdep.c (amd64_register_type): Call i386_sse_type instead
	of using global variable.

	* rs6000-tdep.h (struct gdbarch_tdep): Add ppc_builtin_type_vec64
	and ppc_builtin_type_vec128 members.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): New function.
	(rs6000_builtin_type_vec128): Likewise.
	(rs6000_register_type): Call them instead of using builtin_type_vec64
	and builtin_type_vec128.
	(rs6000_gdbarch_init): Use XCALLOC to allocate tdep structure.

	* spu-tdep.c (struct gdbarch_tdep): New data type.
	(spu_builtin_type_vec128): Remove variable.
	(spu_builtin_type_vec128): New function.
	(spu_register_type): Call it instead of using global variable.
	(spu_gdbarch_init): Allocate tdep structure.
	(spu_init_vector_type): Remove function.
	(_initialize_spu_tdep): Do not call it.
@
text
@d917 1
a917 1
  frame_unwind_register (next_frame, PC_REGNUM, buf);
d1283 1
a1283 1
  get_frame_register (frame, SP_REGNUM, buf);
@


1.236
log
@	* gdbarch.sh (get_longjmp_target): Add FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* infrun.c (handle_inferior_event): Pass current frame to
	gdbarch_get_longjmp_target.

	* alpha-tdep.c (alpha_get_longjmp_target): Add FRAME argument.
	Read registers from FRAME instead of using read_register.
	Use get_frame_arch instead of current_gdbarch.
	* arm-tdep.c (arm_get_longjmp_target): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target): Likewise.
	(mips64_linux_get_longjmp_target): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Likewise.
@
text
@d1598 1
a1598 3
/* Types for the MMX and SSE registers.  */
struct type *i386_mmx_type;
struct type *i386_sse_type;
a1626 46
  /* The type we're building is this: */
#if 0
  union __gdb_builtin_type_vec64i
  {
    int64_t uint64;
    int32_t v2_int32[2];
    int16_t v4_int16[4];
    int8_t v8_int8[8];
  };
#endif

  type = init_composite_type ("__gdb_builtin_type_vec64i", TYPE_CODE_UNION);
  append_composite_type_field (type, "uint64", builtin_type_int64);
  append_composite_type_field (type, "v2_int32", builtin_type_v2_int32);
  append_composite_type_field (type, "v4_int16", builtin_type_v4_int16);
  append_composite_type_field (type, "v8_int8", builtin_type_v8_int8);
  TYPE_FLAGS (type) |= TYPE_FLAG_VECTOR;
  TYPE_NAME (type) = "builtin_type_vec64i";
  i386_mmx_type = type;

  /* The type we're building is this: */
#if 0
  union __gdb_builtin_type_vec128i
  {
    int128_t uint128;
    int64_t v2_int64[2];
    int32_t v4_int32[4];
    int16_t v8_int16[8];
    int8_t v16_int8[16];
    double v2_double[2];
    float v4_float[4];
  };
#endif

  type = init_composite_type ("__gdb_builtin_type_vec128i", TYPE_CODE_UNION);
  append_composite_type_field (type, "v4_float", builtin_type_v4_float);
  append_composite_type_field (type, "v2_double", builtin_type_v2_double);
  append_composite_type_field (type, "v16_int8", builtin_type_v16_int8);
  append_composite_type_field (type, "v8_int16", builtin_type_v8_int16);
  append_composite_type_field (type, "v4_int32", builtin_type_v4_int32);
  append_composite_type_field (type, "v2_int64", builtin_type_v2_int64);
  append_composite_type_field (type, "uint128", builtin_type_int128);
  TYPE_FLAGS (type) |= TYPE_FLAG_VECTOR;
  TYPE_NAME (type) = "builtin_type_vec128i";
  i386_sse_type = type;

d1645 84
d1749 1
a1749 1
    return i386_mmx_type;
d1752 1
a1752 1
    return i386_sse_type;
d2313 1
a2313 1
  tdep = XMALLOC (struct gdbarch_tdep);
@


1.235
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (STAB_REG_TO_REGNUM): Replace by
	gdbarch_stab_reg_to_regnum.
	* stabsread.c (define_symbol): Likewise.
	* gdbarch.sh (ECOFF_REG_TO_REGNUM): Replace by
	gdbarch_ecoff_reg_to_regnum.
	* mdebugread.c (parse_symbol): Likewise.
	* i386-tdep.c (i386_gdbarch_init): Likewise (comment).
	* gdbarch.sh (DWARF_REG_TO_REGNUM): Replace by
	gdbarch_dwarf_reg_to_regnum.
	* gdbarch.sh (SDB_REG_TO_REGNUM): Replace by gdbarch_sdb_reg_to_regnum.
	* coffread.c (process_coff_symbol): Likewise.
	* gdbarch.sh (DWARF2_REG_TO_REGNUM): Replace by
	gdbarch_dwarf2_reg_to_regnum.
	* dwarf2loc.c (dwarf_expr_read_reg,dwarf2_evaluate_loc_desc)
	(locexpr_describe_location): Likewise.
	* dwarf2-frame.c (read_reg,execute_cfa_program,dwarf2_frame_cache)
	(dwarf2_frame_prev_register,dwarf2_signal_frame_this_id): Likewise.
	* dwarf2loc.c (DWARF2_REG_TO_REGNUM): Remove macro.
	* dwarf2read.c (DWARF2_REG_TO_REGNUM): Remove macro.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1269 1
a1269 1
i386_get_longjmp_target (CORE_ADDR *pc)
d1273 1
a1273 1
  int jb_pc_offset = gdbarch_tdep (current_gdbarch)->jb_pc_offset;
d1283 1
a1283 1
  regcache_cooked_read (current_regcache, SP_REGNUM, buf);
@


1.234
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d2385 1
a2385 1
  /* We don't define ECOFF_REG_TO_REGNUM, since ECOFF doesn't seem to
@


1.233
log
@	* Makefile.in (SFILES): Remove nlmread.c.
	(COMMON_OBS): Remove nlmread.o.
	(nlmread.o): Delete rule.
	* README: Delete reference to remote-st.c.
	* acinclude.m4 (CY_AC_TCL_LYNX_POSIX): Delete.
	* defs.h (enum gdb_osabi): Delete GDB_OSABI_NETWARE and
	GDB_OSABI_LYNXOS.
	* i386-tdep.c (i386_nw_init_abi, i386_nlm_osabi_sniffer): Delete.
	(_initialize_i386_tdep): Do not reference them.
	* nlmread.c: Delete file.
	* osabi.c (gdb_osabi_names): Remove NetWare and LynxOS.
	* target.c: Doc update.
	* thread.c: Delete commented include.
	* config/alpha/tm-alpha.h: Doc update.

	* gdb.texinfo (Startup): Delete references to some alternate
	names for .gdbinit.
	(Thread): Remove LynxOS reference.
	(Tandem ST2000): Delete target-specific documentation.
	* gdbint.texinfo (Symbol Handling): Remove mention of NLM.
	(Target Architecture Definition): Remove mention of GDB_OSABI_NETWARE
	and GDB_OSABI_LYNXOS.

	* config/netware.exp: Delete file.
@
text
@d204 2
a205 1
  return NUM_REGS + NUM_PSEUDO_REGS;
d249 2
a250 1
  return NUM_REGS + NUM_PSEUDO_REGS;
@


1.232
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@a2197 10

/* NetWare.  */

static void
i386_nw_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  tdep->jb_pc_offset = 24;
}
a2461 6

static enum gdb_osabi
i386_nlm_osabi_sniffer (bfd *abfd)
{
  return GDB_OSABI_NETWARE;
}
a2495 2
  gdbarch_register_osabi_sniffer (bfd_arch_i386, bfd_target_nlm_flavour,
				  i386_nlm_osabi_sniffer);
a2500 2
  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_NETWARE,
			  i386_nw_init_abi);
@


1.231
log
@	* avr-tdep.c, hppa-tdep.c, hppabsd-tdep.c, i386-tdep.c,
	ia64-tdep.c, m68k-tdep.c, mips-linux-tdep.c, ppcobsd-tdep.c,
	sparc-linux-tdep.c: Include "gdbtypes.h" instead of "floatformat.h".
	* Makefile.in (avr-tdep.o, hppabsd-tdep.o, hppa-tdep.o, i386-tdep.o)
	(ia64-tdep.o, m68k-tdep.o, mips-linux-tdep.o, ppcobsd-tdep.o)
	(sparc-linux-tdep.o): Update.
@
text
@d952 1
a952 1
  cache->pc = frame_func_unwind (next_frame);
@


1.230
log
@	* doublest.c (floatformat_from_length): Use the right element from
	gdbarch floatformats.
	(floatformat_from_type, extract_typed_floating)
	(store_typed_floating): Likewise.
	* doublest.h: Remove declarations for undefined floatformat arrays.
	* gdbarch.sh (float_format, double_format, long_double_format): Change
	to pairs.
	(pformat): Update for pairs.
	* gdbarch.c, gdbarch.h: Regenerated.
	* gdbtypes.c (floatformats_ieee_single, floatformats_ieee_double)
	(floatformats_ieee_double_littlebyte_bigword)
	(floatformats_i387_ext, floatformats_m68881_ext, floatformats_arm_ext)
	(floatformats_ia64_spill, floatformats_ia64_quad, floatformats_vax_f)
	(floatformats_vax_d): New variables.
	(builtin_type_ieee_single, builtin_type_ieee_double)
	(builtin_type_arm_ext, builtin_type_ia64_spill)
	(builtin_type_ia64_quad): Replace arrays with individual types.
	(builtin_type_ieee_single_big, builtin_type_ieee_single_little)
	(builtin_type_ieee_double_big, builtin_type_ieee_double_little)
	(builtin_type_ieee_double_littlebyte_bigword, builtin_type_i960_ext)
	(builtin_type_m88110_ext, builtin_type_m88110_harris_ext)
	(builtin_type_arm_ext_big, builtin_type_arm_ext_littlebyte_bigword)
	(builtin_type_ia64_spill_big, builtin_type_ia64_spill_little)
	(builtin_type_ia64_quad_big, builtin_type_ia64_quad_little): Delete
	unused and endian-specific types.
	(recursive_dump_type): Update for floatformat pairs.
	(build_flt): Move higher.  Handle bit == -1.  Take a floatformat pair.
	(build_gdbtypes): Use build_flt.
	(_initialize_gdbtypes): Update set of initialized types.
	* gdbtypes.h: Update declarations to match gdbtypes.c.
	(struct main_type): Store a pointer to two floatformats.
	* arch-utils.c (default_float_format, default_double_format): Delete.
	* arch-utils.h (default_float_format, default_double_format): Delete.

	* arm-tdep.c, avr-tdep.c, hppa-tdep.c, hppabsd-tdep.c, i386-tdep.c,
	ia64-tdep.c,  iq2000-tdep.c, m68k-tdep.c, m88k-tdep.c,
	mips-linux-tdep.c, mips-tdep.c, mt-tdep.c, ppcobsd-tdep.c,
	sparc-linux-tdep.c, sparc-tdep.c, sparcnbsd-tdep.c, spu-tdep.c,
	vax-tdep.c, alpha-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@a29 1
#include "floatformat.h"
d36 1
@


1.229
log
@Copyright updates for 2007.
@
text
@d2336 1
a2336 1
  set_gdbarch_long_double_format (gdbarch, &floatformat_i387_ext);
@


1.228
log
@        * i386-tdep.c (i386_analyze_stack_align): Add comment.
@
text
@d3 2
a4 2
   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
@


1.227
log
@	Warning fixes.
	* ada-lang.c (find_struct_field): Initialize *byte_offset_p.
	* breakpoint.c (do_enable_breakpoint): Ignore both mem_cnt and i.
	* c-typeprint.c (c_type_print_varspec_suffix): Don't test length
	greater than or equal to zero.
	* m2-typeprint.c (m2_array): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	* gdbtypes.c (copy_type_recursive): Correct == typo.
	* i386-tdep.c (i386_skip_prologue): Remove stray semicolon.
	* linux-nat.c (linux_nat_info_proc_cmd): Don't compare a pointer
	greater than zero.
	* macroscope.c (sal_macro_scope): Don't name a local variable "main".
	(default_macro_scope): Remove unused variable.
	* prologue-value.h (pv_area_find_reg): Don't name an argument
	"register".
	* remote-fileio.c (remote_fio_func_map): Add missing braces.
	* remote.c (sigint_remote_twice_token, sigint_remote_token): Change
	type.
	(cleanup_sigint_signal_handler): Remove casts.
	* valprint.c (val_print): Use a volatile local for the modified
	argument.
	* varobj.c (languages): Remove extra array dimension.
	(varobj_create): Correct access to languages array.
	* mi/mi-cmd-break.c (mi_cmd_break_insert, mi_cmd_break_watch): Add
	missing braces.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Likewise.
	* mi/mi-cmd-env.c (mi_cmd_env_path, mi_cmd_env_dir): Likewise.
	* mi/mi-getopt.c (mi_valid_noargs): Likewise.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	(mi_cmd_data_write_memory): Likewise.
	* signals/signals.c (target_signal_to_string): Cast to int before
	comparing.
	* tui/tui-layout.c (init_and_make_win): Take and return a void *.
	Update all callers.
@
text
@d500 4
@


1.226
log
@        * i386-tdep.c (i386_analyze_stack_align): Add handling of two
        other possible code sequences that perform a stack realignment.
@
text
@d889 1
a889 1
	  && read_memory_unsigned_integer (pc + delta + 1, 1) == 0xc3);
@


1.225
log
@        * i386-tdep.c (i386_follow_jump): Use read_memory_nobpt to read
        instructions.
        (i386_analyze_struct_return): Likewise.
        (i386_skip_probe): Likewise.
        (i386_match_insn): Likewise.
        (i386_analyze_frame_setup): Likewise.
        (i386_analyze_register_saves): Likewise.
        (i386_skip_prologue): Likewise.
@
text
@d500 1
a500 1
  static const gdb_byte insns[10] = { 
d505 10
d518 3
a520 1
      || memcmp (buf, insns, sizeof buf) != 0)
@


1.224
log
@2006-03-16  Michael Snyder  <msnyder@@redhat.com>

	* i386-tdep.c (i386_push_dummy_call): Fix typo in comment.
@
text
@d357 1
a357 1
  op = read_memory_unsigned_integer (pc, 1);
d423 1
a423 1
  op = read_memory_unsigned_integer (pc, 1);
d428 1
a428 1
  read_memory (pc + 1, buf, 4);
d467 1
a467 1
  op = read_memory_unsigned_integer (pc, 1);
d538 1
a538 1
  op = read_memory_unsigned_integer (pc, 1);
d551 1
a551 1
	  read_memory (pc + 1, buf, insn->len - 1);
d637 1
a637 1
  op = read_memory_unsigned_integer (pc, 1);
d672 1
a672 1
      op = read_memory_unsigned_integer (pc + skip, 1);
d706 1
a706 1
      op = read_memory_unsigned_integer (pc, 1);
d762 1
a762 1
      op = read_memory_unsigned_integer (pc, 1);
d851 1
a851 1
      op = read_memory_unsigned_integer (pc + i, 1);
d859 1
a859 1
      op = read_memory_unsigned_integer (pc + delta, 1);
d872 1
a872 1
	  op = read_memory_unsigned_integer (pc + delta, 1);
@


1.224.8.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d357 1
a357 1
  read_memory_nobpt (pc, &op, 1);
d423 1
a423 1
  read_memory_nobpt (pc, &op, 1);
d428 1
a428 1
  read_memory_nobpt (pc + 1, buf, 4);
d467 1
a467 1
  read_memory_nobpt (pc, &op, 1);
d538 1
a538 1
  read_memory_nobpt (pc, &op, 1);
d551 1
a551 1
	  read_memory_nobpt (pc + 1, buf, insn->len - 1);
d637 1
a637 1
  read_memory_nobpt (pc, &op, 1);
d672 1
a672 1
      read_memory_nobpt (pc + skip, &op, 1);
d706 1
a706 1
      read_memory_nobpt (pc, &op, 1);
d762 1
a762 1
      read_memory_nobpt (pc, &op, 1);
d851 1
a851 1
      read_memory_nobpt (pc + i, &op, 1);
d859 1
a859 1
      read_memory_nobpt (pc + delta, &op, 1);
d872 1
a872 1
          read_memory_nobpt (pc + delta, &op, 1);
@


1.223
log
@Fix PR breakpoints/2080.
* i386-tdep.c (struct i386_frame_cache): Add stack_align member.
(i386_analyze_stack_align): New function.
(i386_analyze_prologue): Use i386_analyze_stack_align.
(i386_frame_cache): Deal with stack realignment.
@
text
@d1299 1
a1299 1
	 This makes sure the stack says word-aligned.  */
@


1.222
log
@* i386-tdep.c (i386_mxcsr_type): New variable.
(i386_init_types): Initialize i386_mxcsr_type.
(i386_register_type): Return i386_mxcsr_type for %mxcsr.
* i386-tdep.c (i386_mxcsr_type): New extern.
* amd64-tdep.c (amd64_register_info): Return i386_mxcsr_type for
%mxcsr.
@
text
@d311 1
d338 1
d490 27
d809 1
d940 7
d957 14
a970 2
      frame_unwind_register (next_frame, I386_ESP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 4) + cache->sp_offset;
d975 2
a976 1
  cache->saved_sp = cache->base + 8;
@


1.221
log
@* amd64-tdep.c (amd64_sse_type): Remove.
(amd64_register_info): Use i386_eflags_type and i386_sse_type
where appropriate.
(AMD64_NUM_REGS): Use ARRAY_SIZE.
(amd64_register_type): Remove code to build amd_sse_type.
* i386-tdep.c (i386_eflag_type): New variable.
(i386_mmx_type, i386_sse_type): Make global.
(i386_init_types): New function.
(i386_build_mmx_type, i386_build_sse_type): Remove functions.
(i386_register_type): Return i386_eflag_type, i386_sse_type and
i386_mmx_type when appropriate.
(_initialize_i386_tdep): Call i386_init_types.
* i386-tdep.h (i386_eflags_type, i386_mmx_type, i386_sse_type):
Declare extern.
Based on a previous patch form Michal Ludvig:
@
text
@d1533 1
d1606 17
d1644 3
d1650 8
a1657 2
  if (i386_mmx_regnum_p (gdbarch, regnum))
    return i386_mmx_type;
@


1.220
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d4 2
a5 2
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software
   Foundation, Inc.
d1527 3
d1531 2
a1532 2
static struct type *i386_mmx_type;
static struct type *i386_sse_type;
d1534 3
a1536 3
/* Construct the type for MMX registers.  */
static struct type *
i386_build_mmx_type (void)
d1538 22
d1562 1
a1562 1
  union __gdb_builtin_type_vec64i 
d1571 8
a1578 3
  if (! i386_mmx_type)
    {
      struct type *t;
d1580 13
a1592 8
      t = init_composite_type ("__gdb_builtin_type_vec64i", TYPE_CODE_UNION);
      append_composite_type_field (t, "uint64", builtin_type_int64);
      append_composite_type_field (t, "v2_int32", builtin_type_v2_int32);
      append_composite_type_field (t, "v4_int16", builtin_type_v4_int16);
      append_composite_type_field (t, "v8_int8", builtin_type_v8_int8);

      TYPE_FLAGS (t) |= TYPE_FLAG_VECTOR;
      TYPE_NAME (t) = "builtin_type_vec64i";
d1594 11
a1604 30
      i386_mmx_type = t;
    }

  return i386_mmx_type;
}

/* Construct the type for SSE registers.  */
static struct type *
i386_build_sse_type (void)
{
  if (! i386_sse_type)
    {
      struct type *t;

      t = init_composite_type ("__gdb_builtin_type_vec128i", TYPE_CODE_UNION);
      append_composite_type_field (t, "v4_float", builtin_type_v4_float);
      append_composite_type_field (t, "v2_double", builtin_type_v2_double);
      append_composite_type_field (t, "v16_int8", builtin_type_v16_int8);
      append_composite_type_field (t, "v8_int16", builtin_type_v8_int16);
      append_composite_type_field (t, "v4_int32", builtin_type_v4_int32);
      append_composite_type_field (t, "v2_int64", builtin_type_v2_int64);
      append_composite_type_field (t, "uint128", builtin_type_int128);

      TYPE_FLAGS (t) |= TYPE_FLAG_VECTOR;
      TYPE_NAME (t) = "builtin_type_vec128i";
      
      i386_sse_type = t;
    }

  return i386_sse_type;
d1617 3
d1627 1
a1627 1
    return i386_build_sse_type ();
d1630 1
a1630 1
    return i386_build_mmx_type ();
d2429 1
a2429 1
  /* Initialize the i386 specific register groups.  */
d2431 1
@


1.219
log
@        * i386-tdep.c (i386_reg_struct_return_p): Allow array types as well.
        (i386_return_value): Add handling for functions that return array
        types.
@
text
@d3 1
a3 1
   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.218
log
@gdb/
2005-09-26  Jan Beulich  <jbeulich@@novell.com>

	* amd64-tdep.h (AMD64_FCTRL_REGNUM, AMD64_FSTAT_REGNUM,
	AMD64_MXCSR_REGNUM): New.
	* amd64-tdep.c (amd64_dwarf_regmap): Add eflags, selector regs,
	mxcsr, fp control and status words.
	* i386-tdep.c (): Add selector regs, mxcsr, fp control and status
	words.
@
text
@d1427 3
a1429 3
/* Return non-zero if TYPE, which is assumed to be a structure or
   union type, should be returned in registers for architecture
   GDBARCH.  */
d1438 3
a1440 1
  gdb_assert (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION);
d1472 3
a1474 1
  if ((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION)
d1488 6
@


1.217
log
@    Jason Molenda  <jmolenda@@apple.com>
* i386-tdep.c (i386_match_insn): Match complete instruction
pattern.
@
text
@d228 1
a228 1
  else if (reg >= 21)
d234 13
@


1.216
log
@* i386-tdep.c (i386_reg_struct_return_p): Handle structures with a
single 'long double' member correctly.
(i386_return_value): Tweak comment.
@
text
@d502 2
a503 1
	  unsigned char buf[I386_MAX_INSN_LEN - 1];
d513 2
a514 1
		break;
d516 2
a517 2
	      return insn;
	    }
@


1.215
log
@	* i386-tdep.c (struct i386_frame_cache): Define sp_offset as LONGEST.
@
text
@d1430 9
d1481 6
a1486 5
     `float' or `double' member.  These structures are returned in
     %st(0).  For these structures, we call ourselves recursively,
     changing TYPE into the type of the first member of the structure.
     Since that should work for all structures that have only one
     member, we don't bother to check the member's type here.  */
@


1.214
log
@* i386-tdep.c (i386_register_type): Return
builtin_type_void_func_ptr for %eip and builtin_type_void_data_ptr
for %ebp and %esp.
@
text
@d292 1
a292 1
  CORE_ADDR sp_offset;
@


1.213
log
@	* dwarf2-frame.c (dwarf2_frame_prev_register): Use gdb_byte.
	* i386-linux-nat.c (fetch_register, store_register, supply_gregset)
	(fill_gregset): Likewise.
	* i386-tdep.c (i386_frame_prev_register)
	(i386_sigtramp_frame_prev_register): Likewise.
	* linux-nat.c (linux_nat_xfer_memory, linux_nat_make_corefile_notes):
	Likewise.
	* linux-thread-db.c (thread_db_xfer_memory): Likewise.
	* remote.c (remote_insert_hw_breakpoint, remote_remove_hw_breakpoint):
	Likewise.
	* target.c (debug_to_insert_hw_breakpoint)
	(debug_to_remove_hw_breakpoint, update_current_target): Likewise.
@
text
@d1563 5
a1567 3
  if (regnum == I386_EIP_REGNUM
      || regnum == I386_EBP_REGNUM || regnum == I386_ESP_REGNUM)
    return lookup_pointer_type (builtin_type_void);
@


1.212
log
@* i386-tdep.c (i386_supply_gregset, i386_collect_gregset): Use
gdb_byte instead of bfd_byte.
@
text
@d940 1
a940 1
			  int *realnump, void *valuep)
d1102 1
a1102 1
				   int *realnump, void *valuep)
@


1.211
log
@* amd64-tdep.c (amd64_return_value): Change type of readbuf and
writebuf arguments to `gdb_byte *'.  Remove now redundant casts.
* i386-tdep.c (i386_return_value): Change type of readbuf and
writebuf arguments to `gdb_byte *'.
(i386_pseudo_register_read, i386_pseudo_register_write): Change
type of last argument to `gdb_byte *'.
(i386_register_to_value, i386_value_to_register): Change type of
last argument to `gdb_byte *'.  Simplify function a bit.
* i387-tdep.h (i387_value_to_register, i387_register_to_value):
Change type of last argument to `gdb_byte *'.
* i387-tdep.c: Likewise.
@
text
@d1775 1
a1775 1
  const bfd_byte *regs = gregs;
d1799 1
a1799 1
  bfd_byte *regs = gregs;
@


1.210
log
@* i386-tdep.c (i386_breakpoint_from_pc): Change return type to
`const gdb_byte *'.  Use gdb_byte for break_insn.
(i386_follow_jump): Use gdb_byte for op.
(i386_analyze_struct_return): Use gdb_byte for proto1, proto2, buf
and op.
(i386_skip_probe): Use gdb_byte for buf and op.
(struct i386_insn): Use gdb_byte for insn and mask.
(i386_match_insn, i386_analyze_frame_setup)
(i386_analyze_register_saves): Use gdb_byte for op.
(i386_skip_prologue): Use gdb_byte for pic_pat and op;
(i386_unwind_pc, i386_frame_cache, i386_sigtramp_frame_cache)
(i386_unwind_dummy_id, i386_get_longjmp_target): Use gdb_byte for
buf.
(i386_extract_return_value, i386_store_return_value): Use
`bfd_byte *' instead of `void *' for valbuf argument.  Remove now
redundant cast.
(i386_pseudo_register_read, i386_pseudo_register_write): Use
gdb_byte for mmx_buf.
(i386_register_to_value, i386_value_to_register): Use `gdb_byte *'
instead of `char *' for buf.
(i386_supply_gregset, i386_collect_gregset): Use `gdb_byte *'
instead of `char *' for regs.
(i386_svr4_sigcontext_addr): Use gdb_byte for buf.
* i386obsd-tdep.c (i386obsd_sigtramp_p): Use gdb_byte for
sigreturn and `gdb_byte *' for buf.
(i386obsd_aout_supply_regset): Use `const gdb_byte *' in cast.
(i386obsd_supply_uthread, i386obsd_collect_uthread): Use gdb_byte
for buf.
* i386bsd-tdep.c (i386bsd_sigcontext_addr): Use gdb_byte for buf.
@
text
@d1441 2
a1442 2
		   struct regcache *regcache, void *readbuf,
		   const void *writebuf)
d1606 1
a1606 1
			   int regnum, void *buf)
d1623 1
a1623 1
			    int regnum, const void *buf)
d1706 1
a1706 1
			struct type *type, void *to)
a1708 1
  gdb_byte *buf = to;
d1728 1
a1728 1
      get_frame_register (frame, regnum, buf);
d1731 1
a1731 1
      buf += 4;
d1740 1
a1740 1
			struct type *type, const void *from)
a1742 1
  const gdb_byte *buf = from;
d1759 1
a1759 1
      put_frame_register (frame, regnum, buf);
d1762 1
a1762 1
      buf += 4;
@


1.209
log
@Move construction of IA-32 vector types to i386-tdep.c.
* gdbtypes.c (build_builtin_type_vec64i,
build_builtin_type_vec128i): Delete functions.
(builtin_type_vec64i, builtin_type_vec128i): Delete variables.
(build_gdbtypes): Don't initialize them.
(_initialize_gdbtypes): Don't register GDBARCH swap entries for
them.
* gdbtypes.h (builtin_type_vec64i, builtin_type_vec128i): Delete
declarations.
(builtin_type_v2_float, builtin_type_v2_int32,
builtin_type_v4_int16, builtin_type_v8_int8,
builtin_type_v2_double, builtin_type_v4_float,
builtin_type_v2_int64, builtin_type_v4_int32,
builtin_type_v8_int16, builtin_type_v16_int8): Add extern
declarations.
* i386-tdep.c (i386_mmx_type, i386_sse_type): New variables.
(i386_build_mmx_type, i386_build_sse_type): New functions.
(i386_register_type): Call them, rather than referring to
builtin_type_vec64i and builtin_type_vec128i.
@
text
@d266 2
a267 2
   
static const unsigned char *
d270 2
a271 2
  static unsigned char break_insn[] = { 0xcc };	/* int 3 */
  
d338 1
a338 1
  unsigned char op;
d400 4
a403 4
  static unsigned char proto1[3] = { 0x87, 0x04, 0x24 };
  static unsigned char proto2[4] = { 0x87, 0x44, 0x24, 0x00 };
  unsigned char buf[4];
  unsigned char op;
d449 2
a450 2
  unsigned char buf[8];
  unsigned char op;
d482 2
a483 2
  unsigned char insn[I386_MAX_INSN_LEN];
  unsigned char mask[I386_MAX_INSN_LEN];
d494 1
a494 1
  unsigned char op;
d587 1
a587 1
  unsigned char op;
d711 1
a711 1
  unsigned char op;
d774 1
a774 1
  static unsigned char pic_pat[6] =
d781 1
a781 1
  unsigned char op;
d852 1
a852 1
  char buf[8];
d865 1
a865 1
  char buf[4];
d1055 1
a1055 1
  char buf[4];
d1166 1
a1166 1
  char buf[4];
d1188 1
a1188 1
  char buf[8];
d1220 1
a1220 1
  char buf[4];
d1282 1
a1282 1
			   struct regcache *regcache, void *valbuf)
d1286 1
a1286 1
  char buf[I386_MAX_REGISTER_SIZE];
d1319 1
a1319 1
	  memcpy ((char *) valbuf + low_size, buf, len - low_size);
d1332 1
a1332 1
			 struct regcache *regcache, const void *valbuf)
d1344 1
a1344 1
      char buf[I386_MAX_REGISTER_SIZE];
d1387 1
a1387 1
				   len - low_size, (char *) valbuf + low_size);
d1610 1
a1610 1
      char mmx_buf[MAX_REGISTER_SIZE];
d1627 1
a1627 1
      char mmx_buf[MAX_REGISTER_SIZE];
d1709 1
a1709 1
  char *buf = to;
d1744 1
a1744 1
  const char *buf = from;
d1777 1
a1777 1
  const char *regs = gregs;
d1801 1
a1801 1
  char *regs = gregs;
d1999 1
a1999 1
  char buf[4];
@


1.208
log
@2005-02-20  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_enum_cmd through out.
	* arch-utils.c, charset.c, demangle.c, i386-tdep.c: Update.
	* infrun.c, mips-tdep.c, osabi.c, serial.c, tui/tui-win.c: Update.
@
text
@d1492 64
d1571 1
a1571 1
    return builtin_type_vec128i;
d1574 1
a1574 1
    return builtin_type_vec64i;
@


1.207
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d2278 8
a2285 12
  {
    struct cmd_list_element *new_cmd;

    new_cmd = add_set_enum_cmd ("disassembly-flavor", no_class,
				valid_flavors,
				&disassembly_flavor,
				"\
Set the disassembly flavor, the valid values are \"att\" and \"intel\", \
and the default value is \"att\".",
				&setlist);
    deprecated_add_show_from_set (new_cmd, &showlist);
  }
d2289 9
a2297 11
  {
    struct cmd_list_element *new_cmd;

    new_cmd = add_set_enum_cmd ("struct-convention", no_class,
				valid_conventions,
				&struct_convention, "\
Set the convention for returning small structs, valid values \
are \"default\", \"pcc\" and \"reg\", and the default value is \"default\".",
                                &setlist);
    deprecated_add_show_from_set (new_cmd, &showlist);
  }
@


1.206
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d1323 1
a1323 1
			"Cannot extract return value of %d bytes long.", len);
d1391 1
a1391 1
			"Cannot store return value of %d bytes long.", len);
@


1.205
log
@2005-02-02  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_CONTENTS_ALL): Delete.
	(value_contents_all): Declare.
	* value.c (value_contents_all): New function.
	* hpacc-abi.c, cp-valprint.c, valops.c, c-valprint.c: Update.
	* m68k-tdep.c, i386-tdep.c, infcall.c, valops.c: Update.
@
text
@d1292 1
a1292 1
	  warning ("Cannot find floating-point return value.");
d1348 1
a1348 1
	  warning ("Cannot set floating-point return value.");
@


1.204
log
@2005-02-02  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_enclosing_type): New function.
	* value.h (VALUE_ENCLOSING_TYPE): Delete.
	(value_enclosing_type): Declare.
	* xstormy16-tdep.c, vax-tdep.c, m68k-tdep.c, i386-tdep.c: Update.
	* gnu-v3-abi.c, hpacc-abi.c, infcall.c, valops.c: Update.
@
text
@d1236 1
a1236 1
      write_memory (sp, VALUE_CONTENTS_ALL (args[i]), len);
@


1.203
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Do not set
	in_solib_call_trampoline to in_plt_entry, IN_SOLIB_CALL_TRAMPOLINE
	isn't used by this architecture.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* m68klinux-tdep.c (m68k_linux_init_abi): Ditto.
	* i386-tdep.c (i386_svr4_init_abi): Ditto.
	* i386-nto-tdep.c (i386nto_init_abi): Ditto.
	* arm-linux-tdep.c (arm_linux_init_abi): Ditto.
	* amd64-tdep.c (amd64_init_abi): Ditto.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
d1226 1
a1226 1
      int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (args[i]));
@


1.202
log
@2004-10-27  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Use
	frame_unwind_register instead of frame_register_unwind, do not
	recurse the register's location.
	* xstormy16-tdep.c (xstormy16_frame_prev_register):
	* sparc-tdep.c (sparc32_frame_prev_register): Ditto.
	* sparc64-tdep.c (sparc64_frame_prev_register): Ditto.
	* sh-tdep.c (sh_frame_prev_register): Ditto.
	* m68k-tdep.c (m68k_frame_prev_register): Ditto.
	* i386-tdep.c (i386_frame_prev_register): Ditto.
	* dwarf2-frame.c (dwarf2_frame_prev_register): Ditto.
	* amd64-tdep.c (amd64_frame_prev_register): Ditto.
@
text
@a1964 1
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
@


1.201
log
@* i386-tdep.c (i386_register_name): Rename regno to regnum.
@
text
@d987 6
a992 2
      frame_register_unwind (next_frame, I386_EAX_REGNUM,
			     optimizedp, lvalp, addrp, realnump, valuep);
d1025 6
a1030 2
  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
@


1.200
log
@* i386-tdep.c (I386_MAX_INSN_LEN): New define.
(struct i386_insn): New structure.
(i386_match_insn): New function.
(i386_frame_setup_skip_insns): New variable.
(i386_analyze_frame_setup): Change to use i386_match_insn and the
array i386_frame_setup_insns of instructions that should be
skipped inside the frame setup sequence.
@
text
@d154 1
a154 1
/* Return the name of register REG.  */
d157 1
a157 1
i386_register_name (int reg)
d159 2
a160 2
  if (i386_mmx_regnum_p (current_gdbarch, reg))
    return i386_mmx_names[reg - I387_MM0_REGNUM];
d162 2
a163 2
  if (reg >= 0 && reg < i386_num_register_names)
    return i386_register_names[reg];
@


1.199
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d475 102
d579 2
a580 3
   instruction after the sequence that sets removes the "hidden"
   argument from the stack or CURRENT_PC, whichever is smaller.
   Otherwise, return PC.  */
d583 1
a583 1
i386_analyze_frame_setup (CORE_ADDR pc, CORE_ADDR current_pc,
d586 1
d590 2
a591 2
  if (current_pc <= pc)
    return current_pc;
d601 1
d604 2
a605 4
      if (current_pc <= pc + 1)
	return current_pc;

      op = read_memory_unsigned_integer (pc + 1, 1);
d608 4
a611 25
	 GCC into the prologue.  At this point in the prologue, code
	 should only touch the scratch registers %eax, %ecx and %edx,
	 so we check for

	    movl $XXX, %eax
	    movl $XXX, %ecx
	    movl $XXX, %edx

	 These instructions have opcodes 0xb8, 0xb9 and 0xba.

	 We also check for

	    xorl %eax, %eax
	    xorl %ecx, %ecx
	    xorl %edx, %edx

	 and the equivalent

	    subl %eax, %eax
	    subl %ecx, %ecx
	    subl %edx, %edx

	 Because of the symmetry, there are actually two ways to
	 encode these instructions; with opcode bytes 0x29 and 0x2b
	 for `subl' and opcode bytes 0x31 and 0x33 for `xorl'.
d615 1
a615 3
      while ((op >= 0xb8 && op <= 0xba)
	     || op == 0x29 || op == 0x2b
	     || op == 0x31 || op == 0x33)
d617 6
a622 20
	  if (op >= 0xb8 && op <= 0xba)
	    {
	      /* Skip the `movl' instructions cited above.  */
	      skip += 5;
	    }
	  else
	    {
	      /* Skip the `subl' and `xorl' instructions cited above.  */
	      op = read_memory_unsigned_integer (pc + skip + 2, 1);
	      switch (op)
		{
		case 0xc0:	/* %eax */
		case 0xc9:	/* %ecx */
		case 0xd2:	/* %edx */
		  skip += 2;
		  break;
		default:
		  return pc + 1;
		}
	    }
d624 3
a626 3
	  /* If that's all, return now.  */
	  if (current_pc <= pc + skip + 1)
	    return current_pc;
d628 1
a628 2
	  op = read_memory_unsigned_integer (pc + skip + 1, 1);
	}
d634 2
a635 2
	  if (read_memory_unsigned_integer (pc + skip + 2, 1) != 0xec)
	    return pc + 1;
d638 2
a639 2
	  if (read_memory_unsigned_integer (pc + skip + 2, 1) != 0xe5)
	    return pc + 1;
d642 1
a642 1
	  return pc + 1;
d650 1
a650 1
      pc += skip;
d653 2
a654 2
      if (current_pc <= pc + 3)
	return current_pc;
d662 1
a662 1
      op = read_memory_unsigned_integer (pc + 3, 1);
d666 1
a666 1
	  if (read_memory_unsigned_integer (pc + 4, 1) != 0xec)
d668 1
a668 1
	    return pc + 3;
d670 4
a673 4
	  /* `subl' with signed byte immediate (though it wouldn't make
	     sense to be negative).  */
	  cache->locals = read_memory_integer (pc + 5, 1);
	  return pc + 6;
d678 1
a678 1
	  if (read_memory_unsigned_integer (pc + 4, 1) != 0xec)
d680 1
a680 1
	    return pc + 3;
d683 2
a684 2
	  cache->locals = read_memory_integer (pc + 5, 4);
	  return pc + 9;
d689 1
a689 1
	  return pc + 3;
d692 1
a692 1
  else if (op == 0xc8)		/* enter $XXX */
@


1.198
log
@Partial fix for PR backtrace/1718.
* i386-tdep.c (i386_analyze_frame_setup): Handle more instructions
that GCC migrates into the prolugue.  Don't handle any
instructions that clobber %ebx.
@
text
@d2218 1
a2218 1
    add_show_from_set (new_cmd, &showlist);
d2232 1
a2232 1
    add_show_from_set (new_cmd, &showlist);
@


1.197
log
@* i386-tdep.c (i386_collect_fpregset): Fix comment.
@
text
@d506 8
a513 2
      /* Check for some special instructions that might be migrated
	 by GCC into the prologue.  We check for
d515 5
a519 1
	    xorl %ebx, %ebx
a521 1
	    xorl %eax, %eax
d525 1
a525 1
	    subl %ebx, %ebx
a527 1
	    subl %eax, %eax
d535 3
a537 1
      while (op == 0x29 || op == 0x2b || op == 0x31 || op == 0x33)
d539 6
a544 2
	  op = read_memory_unsigned_integer (pc + skip + 2, 1);
	  switch (op)
d546 12
a557 8
	    case 0xdb:	/* %ebx */
	    case 0xc9:	/* %ecx */
	    case 0xd2:	/* %edx */
	    case 0xc0:	/* %eax */
	      skip += 2;
	      break;
	    default:
	      return pc + 1;
d560 4
@


1.197.2.1
log
@* i386-tdep.c (I386_MAX_INSN_LEN): New define.
(struct i386_insn): New structure.
(i386_match_insn): New function.
(i386_frame_setup_skip_insns): New variable.
(i386_analyze_frame_setup): Change to use i386_match_insn and the
array i386_frame_setup_insns of instructions that should be
skipped inside the frame setup sequence.
* NEWS: Mention improved i386 prologue analyzer in GDB 6.2.1.
@
text
@a474 102
/* Maximum instruction length we need to handle.  */
#define I386_MAX_INSN_LEN	6

/* Instruction description.  */
struct i386_insn
{
  size_t len;
  unsigned char insn[I386_MAX_INSN_LEN];
  unsigned char mask[I386_MAX_INSN_LEN];
};

/* Search for the instruction at PC in the list SKIP_INSNS.  Return
   the first instruction description that matches.  Otherwise, return
   NULL.  */

static struct i386_insn *
i386_match_insn (CORE_ADDR pc, struct i386_insn *skip_insns)
{
  struct i386_insn *insn;
  unsigned char op;

  op = read_memory_unsigned_integer (pc, 1);

  for (insn = skip_insns; insn->len > 0; insn++)
    {
      if ((op & insn->mask[0]) == insn->insn[0])
	{
	  unsigned char buf[I386_MAX_INSN_LEN - 1];
	  size_t i;

	  gdb_assert (insn->len > 1);
	  gdb_assert (insn->len <= I386_MAX_INSN_LEN);

	  read_memory (pc + 1, buf, insn->len - 1);
	  for (i = 1; i < insn->len; i++)
	    {
	      if ((buf[i - 1] & insn->mask[i]) != insn->insn[i])
		break;

	      return insn;
	    }
	}
    }

  return NULL;
}

/* Some special instructions that might be migrated by GCC into the
   part of the prologue that sets up the new stack frame.  Because the
   stack frame hasn't been setup yet, no registers have been saved
   yet, and only the scratch registers %eax, %ecx and %edx can be
   touched.  */

struct i386_insn i386_frame_setup_skip_insns[] =
{
  /* Check for `movb imm8, r' and `movl imm32, r'. 
    
     ??? Should we handle 16-bit operand-sizes here?  */

  /* `movb imm8, %al' and `movb imm8, %ah' */
  /* `movb imm8, %cl' and `movb imm8, %ch' */
  { 2, { 0xb0, 0x00 }, { 0xfa, 0x00 } },
  /* `movb imm8, %dl' and `movb imm8, %dh' */
  { 2, { 0xb2, 0x00 }, { 0xfb, 0x00 } },
  /* `movl imm32, %eax' and `movl imm32, %ecx' */
  { 5, { 0xb8 }, { 0xfe } },
  /* `movl imm32, %edx' */
  { 5, { 0xba }, { 0xff } },

  /* Check for `mov imm32, r32'.  Note that there is an alternative
     encoding for `mov m32, %eax'.

     ??? Should we handle SIB adressing here?
     ??? Should we handle 16-bit operand-sizes here?  */

  /* `movl m32, %eax' */
  { 5, { 0xa1 }, { 0xff } },
  /* `movl m32, %eax' and `mov; m32, %ecx' */
  { 6, { 0x89, 0x05 }, {0xff, 0xf7 } },
  /* `movl m32, %edx' */
  { 6, { 0x89, 0x15 }, {0xff, 0xff } },

  /* Check for `xorl r32, r32' and the equivalent `subl r32, r32'.
     Because of the symmetry, there are actually two ways to encode
     these instructions; opcode bytes 0x29 and 0x2b for `subl' and
     opcode bytes 0x31 and 0x33 for `xorl'.  */

  /* `subl %eax, %eax' */
  { 2, { 0x29, 0xc0 }, { 0xfd, 0xff } },
  /* `subl %ecx, %ecx' */
  { 2, { 0x29, 0xc9 }, { 0xfd, 0xff } },
  /* `subl %edx, %edx' */
  { 2, { 0x29, 0xd2 }, { 0xfd, 0xff } },
  /* `xorl %eax, %eax' */
  { 2, { 0x31, 0xc0 }, { 0xfd, 0xff } },
  /* `xorl %ecx, %ecx' */
  { 2, { 0x31, 0xc9 }, { 0xfd, 0xff } },
  /* `xorl %edx, %edx' */
  { 2, { 0x31, 0xd2 }, { 0xfd, 0xff } },
  { 0 }
};

d477 3
a479 2
   instruction after the sequence that sets up the frame or LIMIT,
   whichever is smaller.  If we don't recognize the code, return PC.  */
d482 1
a482 1
i386_analyze_frame_setup (CORE_ADDR pc, CORE_ADDR limit,
a484 1
  struct i386_insn *insn;
d488 2
a489 2
  if (limit <= pc)
    return limit;
a498 1
      pc++;
d501 19
a519 2
      if (limit <= pc)
	return limit;
d521 3
a523 5
      /* Check for some special instructions that might be migrated by
	 GCC into the prologue and skip them.  At this point in the
	 prologue, code should only touch the scratch registers %eax,
	 %ecx and %edx, so while the number of posibilities is sheer,
	 it is limited.
d527 1
a527 1
      while (pc + skip < limit)
d529 12
a540 3
	  insn = i386_match_insn (pc + skip, i386_frame_setup_skip_insns);
	  if (insn == NULL)
	    break;
d542 1
a542 1
	  skip += insn->len;
a544 6
      /* If that's all, return now.  */
      if (limit <= pc + skip)
	return limit;

      op = read_memory_unsigned_integer (pc + skip, 1);

d549 2
a550 2
	  if (read_memory_unsigned_integer (pc + skip + 1, 1) != 0xec)
	    return pc;
d553 2
a554 2
	  if (read_memory_unsigned_integer (pc + skip + 1, 1) != 0xe5)
	    return pc;
d557 1
a557 1
	  return pc;
d565 1
a565 1
      pc += (skip + 2);
d568 2
a569 2
      if (limit <= pc)
	return limit;
d577 1
a577 1
      op = read_memory_unsigned_integer (pc, 1);
d581 1
a581 1
	  if (read_memory_unsigned_integer (pc + 1, 1) != 0xec)
d583 1
a583 1
	    return pc;
d585 4
a588 4
	  /* `subl' with signed 8-bit immediate (though it wouldn't
	     make sense to be negative).  */
	  cache->locals = read_memory_integer (pc + 2, 1);
	  return pc + 3;
d593 1
a593 1
	  if (read_memory_unsigned_integer (pc + 1, 1) != 0xec)
d595 1
a595 1
	    return pc;
d598 2
a599 2
	  cache->locals = read_memory_integer (pc + 2, 4);
	  return pc + 6;
d604 1
a604 1
	  return pc;
d607 1
a607 1
  else if (op == 0xc8)		/* enter */
@


1.196
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d1677 4
a1680 3
/* Supply register REGNUM from the buffer specified by FPREGS and LEN
   in the floating-point register set REGSET to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
@


1.195
log
@* i386-tdep.c (i386_supply_gregset): Adjust comment.
(i386_collect_gregset): New function.
(i386_supply_fpregset): Adjust comment.
(i386_collect_fpregset): New function.
(i386_regset_from_core_section): Use i386_collect_gregset and
i386_collect_fpregset.
@
text
@d1122 1
a1122 1
i386_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
@


1.194
log
@* regset.c: Tweak comment.
(regset_alloc): Remove descr argument.  Use GDBARCH_OBSTACK_ZALLOC
macro.
* regset.h: Update copyright year.
(struct regset): Remove `descr' member, add `gdbarch' member.
(regset_alloc): Adjust prototype and comment.
* i386-tdep.c (i386_supply_gregset): Get TDEP from REGSET->arch.
(i386_supply_fpregset): Likewise.
(i386_regset_from_core_section): Update call to regset_alloc.
* i386obsd-tdep.c (i386obsd_aout_supply_regset): Get TDEP from
REGSET->arch.
(i386obsd_aout_regset_from_core_section): Update call to
regset_alloc.
* i386nbsd-tdep.c (i386nbsd_aout_supply_regset): Get TDEP from
REGSET->arch.
(i386nbsd_aout_regset_from_core_section): Update call to
regset_alloc.
* amd64-tdep.c (amd64_supply_fpregset): Get TDEP from
REGSET->arch.
(amd64_regset_from_core_section): Update call to regset_alloc.
* amd64obsd-tdep.c (amd64obsd_supply_regset): Get TDEP from
REGSET->arch.
(amd64obsd_regset_from_core_section): Update call to regset_alloc.
* sparcnbsd-tdep.c (sparc32nbsd_supply_gregset): Directly pass
&sparc32nbsd_gregset in sparc32_supply_gregset call.
(sparc32nbsd_init_abi): Update call to regset_alloc.
* sparc64obsd-tdep.c (sparc64obsd_supply_gregset): Directly pass
&sparc64obsd_core_gregset in sparc64_supply_gregset call.
(sparc64obsd_init_abi): Update call to regset_alloc.
* sparc64nbsd-tdep.c (sparc64nbsd_supply_gregset): Directly pass
&sparc64nbsd_gregset in sparc64_supply_gregset call.
(sparc64nbsd_init_abi): Update call to regset_alloc.
* sparc64fbsd-tdep.c (sparc64fbsd_supply_gregset): Directly pass
&sparc64fbsd_gregset in sparc64_supply_gregset call.
(sparc64fbsd_init_abi): Update call to regset_alloc.
@
text
@d1611 3
a1613 3
/* Supply register REGNUM from the general-purpose register set REGSET
   to register cache REGCACHE.  If REGNUM is -1, do this for all
   registers in REGSET.  */
d1633 27
a1659 3
/* Supply register REGNUM from the floating-point register set REGSET
   to register cache REGCACHE.  If REGNUM is -1, do this for all
   registers in REGSET.  */
d1677 21
d1710 2
a1711 1
        tdep->gregset = regset_alloc (gdbarch, i386_supply_gregset, NULL);
d1720 2
a1721 1
        tdep->fpregset = regset_alloc (gdbarch, i386_supply_fpregset, NULL);
@


1.193
log
@Allocate regset structures in the gdbarch's obstack, not using
xmalloc.
* regset.c (regset_alloc): Renamed from regset_xmalloc.
Add 'arch' argument.  Allocate the regset on arch's obstack, not
using xmalloc.
* regset.h (regset_alloc): Update declaration.
* am64-tdep.c (amd64_regset_from_core_section): Update call; pass
gdbarch argument.
* amd64obsd-tdep.c (amd64obsd_regset_from_core_section): Same.
* i386-tdep.c (i386_regset_from_core_section): Same.
* i386nbsd-tdep.c (i386nbsd_aout_regset_from_core_section): Same.
* i386obsd-tdep.c (i386obsd_aout_regset_from_core_section): Same.
* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Same.
* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Same.
* sparc64obsd-tdep.c (sparc64obsd_init_abi): Same.
* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Same.
@
text
@d1619 1
a1619 1
  const struct gdbarch_tdep *tdep = regset->descr;
d1641 1
a1641 1
  const struct gdbarch_tdep *tdep = regset->descr;
d1665 1
a1665 2
        tdep->gregset = regset_alloc (gdbarch, tdep,
                                      i386_supply_gregset, NULL);
d1674 1
a1674 2
        tdep->fpregset = regset_alloc (gdbarch, tdep,
                                       i386_supply_fpregset, NULL);
@


1.192
log
@Use a constructor function to create regset structures.
* regset.h (supply_regset_ftype, collect_regset_ftype): New typedefs.
(struct regset): Use supply_regset_ftype.  Add new
'collect_regset' member.
(regset_xmalloc): New declaration.
* regset.c: New file.
* am64-tdep.c (amd64_regset_from_core_section): Use
regset_xmalloc to construct regset structures.
* amd64obsd-tdep.c (amd64obsd_regset_from_core_section): Same.
* i386-tdep.c (i386_regset_from_core_section): Same.
* i386nbsd-tdep.c (i386nbsd_aout_regset_from_core_section): Same.
* i386obsd-tdep.c (i386obsd_aout_regset_from_core_section): Same.
* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Same.
* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Same.
* sparc64obsd-tdep.c (sparc64obsd_init_abi): Same.
* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Same.
* Makefile.in (COMMON_OBS): Add regset.o.
(regset.o): New rule.
@
text
@d1665 2
a1666 1
        tdep->gregset = regset_xmalloc (tdep, i386_supply_gregset, NULL);
d1675 2
a1676 1
        tdep->fpregset = regset_xmalloc (tdep, i386_supply_fpregset, NULL);
@


1.191
log
@* defs.h (enum return_value_convention): Add
RETURN_VALUE_ABI_RETURNS_ADDRESS and
RETURN_VALUE_ABI_PRESERVES_ADDRESS.
* infcmd.c (legacy_return_value): New function.
(print_return_value): Rwerite to implement
RETURN_VALUE_ABI_RETURNS_ADDRESS.
* values.c (using_struct_return): Check for inequality to
RETURN_VALUE_REGISTER_CONVENTION instead of equality to
RETURN_VALUE_STRUCT_CONVENTION.
* i386-tdep.c (i386_return_value): Implement
RETURN_VALUE_ABI_RETURNS_ADDRESS.
@
text
@d1665 1
a1665 5
	{
	  tdep->gregset = XMALLOC (struct regset);
	  tdep->gregset->descr = tdep;
	  tdep->gregset->supply_regset = i386_supply_gregset;
	}
d1674 1
a1674 5
	{
	  tdep->fpregset = XMALLOC (struct regset);
	  tdep->fpregset->descr = tdep;
	  tdep->fpregset->supply_regset = i386_supply_fpregset;
	}
@


1.190
log
@	Revert 2004-04-16 change.
	* i386-tdep.c (i386_gdbarch_init): Fix comment typos.
	(i386_coff_init_abi): Remove.
	* i386-tdep.h (i386_coff_init_abi): Remove.
	* i386-cygwin-tdep.c (i386_cygwin_init_abi): Remove call to above.
@
text
@d1355 22
a1376 1
    return RETURN_VALUE_STRUCT_CONVENTION;
@


1.189
log
@    Mark Kettenis  <kettenis@@gnu.org>

* i386-tdep.c (i386_skip_prologue): follow the last jump only if
the function begins with a branch instruction.
@
text
@a1790 10
/* Generic COFF.  */

void
i386_coff_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  /* We typically use DWARF-in-COFF with the dbx register numbering.  */
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);
}

d1999 1
a1999 1
     implemented in dbx64_register_map, and us used for AMD64; see
d2018 2
a2019 2
     the defaults below will have to be overridden, like the functions
     i386_coff_init_abi() and i386_elf_init_abi() do.  */
@


1.188
log
@* i386-tdep.c: Fix spelling mistakes.
@
text
@d753 7
a759 1
  return i386_follow_jump (pc);
@


1.187
log
@Based on a patch from Brian Ford <ford@@vss.fsi.com>:
* i386-tdep.c: Correct register numbering scheme comments
throughout.
(i386_stab_reg_to_regnum): Rename to i386_dbx_reg_to_regnum.
(i386_dwarf_reg_to_regnum): Rename to i386_svr4_reg_to_regnum.
(i386_coff_init_abi, i386_elf_init_abi): Accomodate renames above.
(i386_gdb_arch_init): Likewise.
@
text
@d575 1
a575 1
	 NOTE: You can't subtract a 16 bit immediate from a 32 bit
d580 1
a580 1
	  /* `subl' with 8 bit immediate.  */
d592 1
a592 1
	  /* Maybe it is `subl' with a 32 bit immedediate.  */
d597 1
a597 1
	  /* It is `subl' with a 32 bit immediate.  */
d660 3
a662 3
   'enter' instruction, or by "subl $<size>, %esp".  'enter' has a 16
   bit unsigned argument for space to allocate, and the 'addl'
   instruction could have either a signed byte, or 32 bit immediate.
d1164 1
a1164 1
     defenition of the stack address of a frame.  Otherwise
d1536 1
a1536 1
  /* Read a value spread accross multiple registers.  */
d1568 1
a1568 1
  /* Write a value spread accross multiple registers.  */
d1939 1
a1939 1
     and the SSE registers.  This can be overidden for a specific ABI
d1955 1
a1955 1
     caclulating the register number for %mm0 until we know the number
d1998 1
a1998 1
     floating-point registers, and are implemented by the attays
@


1.186
log
@From Brian Ford <ford@@vss.fsi.com>:
* i386-tdep.c (i386_coff_init_abi): New function.
* i386-tdep.h (i386_coff_init_abi): New prototype.
* i386-cygwin-tdep.c (i386_cygwin_init_abi): Call it.  Use correct
register number translation functions for DWARF and DWARF 2.
@
text
@d54 1
a54 2
/* Names of the registers.  The first 10 registers match the register
   numbering scheme used by GCC for stabs and DWARF.  */
d73 1
a73 1
/* MMX registers.  */
d168 1
a168 37

/* FIXME: jimb/2004-04-01: I don't think these functions are right.
   For a given platform, GCC always uses the same register numbering
   in both STABS and Dwarf2: gcc/dbxout.c and gcc/dwarf2out.c both use
   the DBX_REGISTER_NUMBER macro, as defined by the config headers.
   If you compile a program so that its variables are allocated to
   floating-point registers, first with STABS and again with Dwarf 2,
   you'll see that the variable's register numbers are the same in
   each case.

   GCC does use (at least) two different register numberings on the
   i386; they differ in how they number %ebp, %esp, %eflags, and the
   floating-point registers.  And it has a third numbering for "64bit
   mode", which I assume is x86_64.  But it always uses a given
   numbering in both STABS and Dwarf.

   This does not match the arrangement we have below, which presumes
   that STABS and Dwarf numberings are different, and does some
   strange mixing and matching (e.g., registering the Dwarf 2 function
   as the STABS function for "Generic i386 ELF") to get close enough
   to the right effect on the platforms we care about.

   If we wanted to match GCC, we should have two separate register
   number translation functions (we handle x86_64 in a separate tdep
   file altogether), one corresponding to each of GCC's i386 register
   maps.  And for a given platform, we would register one of them as
   both the STABS and Dwarf 2 functions.

   However, we don't aspire to match GCC; we aspire to match the
   native system's tools.  I don't have access to lots of different
   native compilers and debuggers to verify that GCC is matching their
   behavior in this regard.  Is it sufficient to argue that we at
   least want to match GNU's compiler, and say we'll fix bugs relative
   to native tools as they're reported?  */


/* Convert stabs register number REG to the appropriate register
d172 1
a172 1
i386_stab_reg_to_regnum (int reg)
d174 3
a176 1
  /* This implements what GCC calls the "default" register map.  */
d207 2
a208 2
/* Convert DWARF register number REG to the appropriate register
   number used by GDB.  */
d211 1
a211 1
i386_dwarf_reg_to_regnum (int reg)
d213 4
a216 1
  /* The DWARF register numbering includes %eip and %eflags, and
d230 2
a231 2
      /* The SSE and MMX registers have identical numbers as in stabs.  */
      return i386_stab_reg_to_regnum (reg);
d1790 3
a1792 3
  /* We typically use DWARF-in-COFF with the stabs register numbering.  */
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, i386_stab_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, i386_stab_reg_to_regnum);
d1800 2
a1801 2
  /* We typically use stabs-in-ELF with the DWARF register numbering.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_dwarf_reg_to_regnum);
d1995 37
a2031 7
  /* Use the "default" register numbering scheme for stabs and COFF.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_stab_reg_to_regnum);
  set_gdbarch_sdb_reg_to_regnum (gdbarch, i386_stab_reg_to_regnum);

  /* Use the DWARF register numbering scheme for DWARF and DWARF 2.  */
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, i386_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, i386_dwarf_reg_to_regnum);
@


1.185
log
@* amd64-linux-tdep.c, amd64nbsd-tdep.c, amd64obsd-tdep.c,
i386-linux-tdep.c, i386-tdep.c, i386nbsd-tdep.c, i386obsd-tdep.c:
Fix typo.
@
text
@d1817 10
@


1.184
log
@* amd64-tdep.c (amd64_sigtramp_frame_sniffer): Rewrite to use new
sigtramp_p member of `struct gdbarch_tdep'.  Also check whether
the program counter is in the range specified by `struct
gdbarch_tdep'.
* amd64-linux-tdep.c: Include "symtab.h".
(amd64_linux_pc_in_sigtramp): Remove function.
(amd64_linux_sigtramp_p): New function.
(amd64_linux_init_abi): Initialize TDEP->sigtramp_p.  Don't set
deprecated_pc_in_sigtramp.
* amd64nbsd-tdep.c: Include "symtab.h".
(amd64nbsd_sigtramp_p): New function.
(amd64nbsd_init_abi): Initialize TDEP->sigtramp_p.  Don't set
deprecated_pc_in_sigtramp.
* amd64obsd-tdep.c: Include "symtab.h" and "objfiles.h".  Add a
few comments.
(amd64obsd_pc_in_sigtramp): Remove function.
(amd64obsd_sigtramp_p): New function.
(amd64obsd_init_abi): Initialize TDEP->sigtramp_p.  Don't set
deprecated_pc_in_sigtramp.
* i386-tdep.h (struct gdbarch_tdep): Add sigtramp_p member.
(i386bsd_pc_ins_sigtramp): Remove prototype.
(i386bsd_sigtramp_start, i386bsd_sigtramp_end): Remove prototypes.
* i386-tdep.c (i386_sigtramp_frame_sniffer): Rewrite to use new
sigtramp_p member of `struct gdbarch_tdep'.  Also check whether
the program counter is in the range specified by `struct
gdbarch_tdep'.
(i386_pc_in_sigtramp, i386_svr4_pc_in_sigtramp): Remove functions.
(i386_sigtramp_p, i386_svr4_sigtramp_p): New functions.
(i386_go32_pc_in_sigtramp): Remove function.
(i386_svr4_init_abi): Don't set deprecated_pc_in_sigtramp.
Initialize TDEP->sigtramp_p.
(i386_go32_init_abi): Initialize TDEP->sigtramp_p to NULL.
(i386_gdbarch_init): Initialize TDEP->sigtramp_p.  Don't set
deprecated_pc_in_sigtramp.
* i386-linux-tdep.c: Adjust comments.
(i386_linux_pc_in_sigtramp): Remove function.
(i386_linux_sigtramp_p): New function.
(i386_linux_init_abi): Initialize TDEP->sigtramp_p.  Don't set
deprecated_pc_in_sigtramp.
* i386-nto-tdep.c: Update copyright year.
(i386nto_pc_in_sigtramp): Remove function.
(i386nto_sigtramp_p): New function.
(i386nto_sigcontext_addr): Use I386_ESP_REGNUM instead of
SP_REGNUM.
(i386nto_init_abi): Initialize TDEP->sigtramp_p.  Don't set
deprecated_pc_in_sigtramp.
* i386-sol2-tdep.c: Update copyright year.
(i386_sol2_pc_in_sigtramp): Remove function.
(i386_sol2_sigtramp_p): New function.
(i386_sol2_init_abi): Initialize TDEP->sigtramp_p.  Don't set
deprecated_pc_in_sigtramp.
* i386bsd-tdep.c (i386bsd_pc_in_sigtramp): Remove function.
(i386bsd_sigtramp_start, i386bsd_sigtramp_end): Remove functions.
(i386bsd_init_abi): Don't set deprecated_pc_in_sigtramp,
deprecated_sigtramp_start and deprecated_sigtramp_end.
* i386nbsd-tdep.c: Include "frame.h" and "symtab.h".
(i386nbsd_pc_in_sigtramp): Remove function.
(i386nbsd_sigtramp_p): New function.
(i386nbsd_init_abi): Don't set deprecated_pc_in_sigtramp,
deprecated_sigtramp_start, deprecated_sigtramp_end.  Initialize
TDEP->sigtramp_start, TDEP->sigtramp_end and TDEP->sigtramp_p.
* i386obsd-tdep.c: Include "frame.h", "symtab.h" and "objfiles.h".
(i386obsd_pc_in_sigtramp): Remove function.
(i386obsd_sigtramp_p): New function.
(i386obsd_sigtramp_start, i386obsd_sigtramp_end): Remove
functions.
(i386bsd_init_abi): Don't set deprecated_pc_in_sigtramp,
deprecated_sigtramp_start, deprecated_sigtramp_end.  Initialize
TDEP->sigtramp_p.
* Makefile.in (amd64-linux-tdep.o, amd64nbsd-tdep.o,
amd64obsd-tdep.o, i386nbsd-tdep.o, i386obsd-tdep.o): Update
dependencies.
@
text
@d1744 1
a1744 1
/* Return whether the frame preciding NEXT_FRAME corresponds to a
d1783 1
a1783 1
/* Return whether the frame preciding NEXT_FRAME corresponds to a SVR4
@


1.183
log
@* i386-tdep.c (i386_stab_reg_to_regnum): Correct numbering for
%esp and %ebp
@
text
@d1054 1
a1054 2
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  char *name;
d1056 3
a1058 3
  /* We shouldn't even bother to try if the OSABI didn't register
     a sigcontext_addr handler.  */
  if (!gdbarch_tdep (current_gdbarch)->sigcontext_addr)
d1061 14
a1074 3
  find_pc_partial_function (pc, &name, NULL, NULL);
  if (DEPRECATED_PC_IN_SIGTRAMP (pc, name))
    return &i386_sigtramp_frame_unwind;
d1744 2
a1745 2
/* Return non-zero if PC and NAME show that we are in a signal
   trampoline.  */
d1748 1
a1748 1
i386_pc_in_sigtramp (CORE_ADDR pc, char *name)
d1750 4
d1783 3
d1787 1
a1787 1
i386_svr4_pc_in_sigtramp (CORE_ADDR pc, char *name)
d1789 3
d1794 1
a1816 10
/* DJGPP.  */

static int
i386_go32_pc_in_sigtramp (CORE_ADDR pc, char *name)
{
  /* DJGPP doesn't have any special frames for signal handlers.  */
  return 0;
}


d1840 1
a1840 1
  set_gdbarch_deprecated_pc_in_sigtramp (gdbarch, i386_svr4_pc_in_sigtramp);
d1855 2
a1856 1
  set_gdbarch_deprecated_pc_in_sigtramp (gdbarch, i386_go32_pc_in_sigtramp);
d1988 1
a2049 1
  set_gdbarch_deprecated_pc_in_sigtramp (gdbarch, i386_pc_in_sigtramp);
@


1.182
log
@* i386-tdep.c: Add FIXME regarding STABS vs. Dwarf 2 register
numbering.
@
text
@d214 7
a220 2
      /* General-purpose registers.  */
      return reg;
@


1.181
log
@2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PC_IN_SIGTRAMP): Change to a function with
	predicate, deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-linux-tdep.c (alpha_linux_init_abi): Update.
	* alpha-osf1-tdep.c (alpha_osf1_init_abi): Update.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Update.
	* alphafbsd-tdep.c (alphafbsd_init_abi): Update.
	* alphanbsd-tdep.c (alphanbsd_init_abi): Update.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Update.
	* amd64-tdep.c (amd64_sigtramp_frame_sniffer): Update.
	* amd64nbsd-tdep.c (amd64nbsd_init_abi): Update.
	* amd64obsd-tdep.c (amd64obsd_init_abi): Update.
	* arm-tdep.c (arm_sigtramp_unwind_sniffer): Update.
	* blockframe.c (find_pc_partial_function): Update.
	* breakpoint.c (bpstat_what): Update.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update.
	* frv-linux-tdep.c (frv_linux_init_abi): Update.
	* frv-tdep.c (frv_sigtramp_frame_sniffer): Update.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* i386-nto-tdep.c (i386nto_init_abi): Update.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Update.
	* i386-tdep.c (i386_sigtramp_frame_sniffer)
	(i386_svr4_init_abi, i386_go32_init_abi, i386_gdbarch_init): Update.
	* i386bsd-tdep.c (i386bsd_init_abi): Update.
	* i386nbsd-tdep.c (i386nbsd_init_abi): Update.
	* i386obsd-tdep.c (i386obsd_init_abi): Update.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Update.
	* infrun.c (pc_in_sigtramp): Update.
	* m68k-tdep.c (m68k_sigtramp_frame_sniffer): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mipsnbsd-tdep.c (mipsnbsd_init_abi): Update.
	* ppc-linux-tdep.c: Update comment.
	* ppcnbsd-tdep.c (ppcnbsd_init_abi): Update.
	* shnbsd-tdep.c (shnbsd_init_abi): Update.
	* sparc-linux-tdep.c (sparc32_linux_init_abi): Update.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Update.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Update.
	* sparcobsd-tdep.c (sparc32obsd_init_abi): Update.

Index: doc/ChangeLog
2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	references to PC_IN_SIGTRAMP.
@
text
@d169 36
@


1.180
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* x86-64-tdep.c (x86_64_init_abi): No need to clear
	extract_struct_value_address, i386 does not set it.
	* sparc64-tdep.c (sparc64_init_abi): Do not set
	extract_struct_value_address, never called.
	(sparc64_extract_struct_value_address): Delete function.
	* m68hc11-tdep.c: Update copyright.
	(m68hc11_gdbarch_init): Delete redundant assignment of
	extract_struct_value_address.
	* i386-tdep.c: Update copyright.
	(i386_gdbarch_init): Do not set extract_struct_value_address,
	never called.
	(i386_extract_struct_value_address): Delete function.
	* sparc-tdep.c (sparc32_gdbarch_init): Do not set
	extract_struct_value_address, never called.
	(sparc32_extract_struct_value_address): #if 0 function.
@
text
@d1022 1
a1022 1
  if (PC_IN_SIGTRAMP (pc, name))
d1788 1
a1788 1
  set_gdbarch_pc_in_sigtramp (gdbarch, i386_svr4_pc_in_sigtramp);
d1803 1
a1803 1
  set_gdbarch_pc_in_sigtramp (gdbarch, i386_go32_pc_in_sigtramp);
d1996 1
a1996 1
  set_gdbarch_pc_in_sigtramp (gdbarch, i386_pc_in_sigtramp);
@


1.180.6.1
log
@Merge mainline to intercu branch.
@
text
@d1022 1
a1022 1
  if (DEPRECATED_PC_IN_SIGTRAMP (pc, name))
d1788 1
a1788 1
  set_gdbarch_deprecated_pc_in_sigtramp (gdbarch, i386_svr4_pc_in_sigtramp);
d1803 1
a1803 1
  set_gdbarch_deprecated_pc_in_sigtramp (gdbarch, i386_go32_pc_in_sigtramp);
d1996 1
a1996 1
  set_gdbarch_deprecated_pc_in_sigtramp (gdbarch, i386_pc_in_sigtramp);
@


1.180.6.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@a168 36

/* FIXME: jimb/2004-04-01: I don't think these functions are right.
   For a given platform, GCC always uses the same register numbering
   in both STABS and Dwarf2: gcc/dbxout.c and gcc/dwarf2out.c both use
   the DBX_REGISTER_NUMBER macro, as defined by the config headers.
   If you compile a program so that its variables are allocated to
   floating-point registers, first with STABS and again with Dwarf 2,
   you'll see that the variable's register numbers are the same in
   each case.

   GCC does use (at least) two different register numberings on the
   i386; they differ in how they number %ebp, %esp, %eflags, and the
   floating-point registers.  And it has a third numbering for "64bit
   mode", which I assume is x86_64.  But it always uses a given
   numbering in both STABS and Dwarf.

   This does not match the arrangement we have below, which presumes
   that STABS and Dwarf numberings are different, and does some
   strange mixing and matching (e.g., registering the Dwarf 2 function
   as the STABS function for "Generic i386 ELF") to get close enough
   to the right effect on the platforms we care about.

   If we wanted to match GCC, we should have two separate register
   number translation functions (we handle x86_64 in a separate tdep
   file altogether), one corresponding to each of GCC's i386 register
   maps.  And for a given platform, we would register one of them as
   both the STABS and Dwarf 2 functions.

   However, we don't aspire to match GCC; we aspire to match the
   native system's tools.  I don't have access to lots of different
   native compilers and debuggers to verify that GCC is matching their
   behavior in this regard.  Is it sufficient to argue that we at
   least want to match GNU's compiler, and say we'll fix bugs relative
   to native tools as they're reported?  */


@


1.180.6.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d54 2
a55 1
/* Register names.  */
d74 1
a74 1
/* Register names for MMX pseudo-registers.  */
d169 37
a205 1
/* Convert a dbx register number REG to the appropriate register
d209 1
a209 1
i386_dbx_reg_to_regnum (int reg)
d211 1
a211 3
  /* This implements what GCC calls the "default" register map
     (dbx_register_map[]).  */

d214 2
a215 7
      /* General-purpose registers.  The debug info calls %ebp
         register 4, and %esp register 5.  */
      if (reg == 4)
        return 5;
      else if (reg == 5)
        return 4;
      else return reg;
d237 2
a238 2
/* Convert SVR4 register number REG to the appropriate register number
   used by GDB.  */
d241 1
a241 1
i386_svr4_reg_to_regnum (int reg)
d243 1
a243 4
  /* This implements the GCC register map that tries to be compatible
     with the SVR4 C compiler for DWARF (svr4_dbx_register_map[]).  */

  /* The SVR4 register numbering includes %eip and %eflags, and
d257 2
a258 2
      /* The SSE and MMX registers have the same numbers as with dbx.  */
      return i386_dbx_reg_to_regnum (reg);
a501 102
/* Maximum instruction length we need to handle.  */
#define I386_MAX_INSN_LEN	6

/* Instruction description.  */
struct i386_insn
{
  size_t len;
  unsigned char insn[I386_MAX_INSN_LEN];
  unsigned char mask[I386_MAX_INSN_LEN];
};

/* Search for the instruction at PC in the list SKIP_INSNS.  Return
   the first instruction description that matches.  Otherwise, return
   NULL.  */

static struct i386_insn *
i386_match_insn (CORE_ADDR pc, struct i386_insn *skip_insns)
{
  struct i386_insn *insn;
  unsigned char op;

  op = read_memory_unsigned_integer (pc, 1);

  for (insn = skip_insns; insn->len > 0; insn++)
    {
      if ((op & insn->mask[0]) == insn->insn[0])
	{
	  unsigned char buf[I386_MAX_INSN_LEN - 1];
	  size_t i;

	  gdb_assert (insn->len > 1);
	  gdb_assert (insn->len <= I386_MAX_INSN_LEN);

	  read_memory (pc + 1, buf, insn->len - 1);
	  for (i = 1; i < insn->len; i++)
	    {
	      if ((buf[i - 1] & insn->mask[i]) != insn->insn[i])
		break;

	      return insn;
	    }
	}
    }

  return NULL;
}

/* Some special instructions that might be migrated by GCC into the
   part of the prologue that sets up the new stack frame.  Because the
   stack frame hasn't been setup yet, no registers have been saved
   yet, and only the scratch registers %eax, %ecx and %edx can be
   touched.  */

struct i386_insn i386_frame_setup_skip_insns[] =
{
  /* Check for `movb imm8, r' and `movl imm32, r'. 
    
     ??? Should we handle 16-bit operand-sizes here?  */

  /* `movb imm8, %al' and `movb imm8, %ah' */
  /* `movb imm8, %cl' and `movb imm8, %ch' */
  { 2, { 0xb0, 0x00 }, { 0xfa, 0x00 } },
  /* `movb imm8, %dl' and `movb imm8, %dh' */
  { 2, { 0xb2, 0x00 }, { 0xfb, 0x00 } },
  /* `movl imm32, %eax' and `movl imm32, %ecx' */
  { 5, { 0xb8 }, { 0xfe } },
  /* `movl imm32, %edx' */
  { 5, { 0xba }, { 0xff } },

  /* Check for `mov imm32, r32'.  Note that there is an alternative
     encoding for `mov m32, %eax'.

     ??? Should we handle SIB adressing here?
     ??? Should we handle 16-bit operand-sizes here?  */

  /* `movl m32, %eax' */
  { 5, { 0xa1 }, { 0xff } },
  /* `movl m32, %eax' and `mov; m32, %ecx' */
  { 6, { 0x89, 0x05 }, {0xff, 0xf7 } },
  /* `movl m32, %edx' */
  { 6, { 0x89, 0x15 }, {0xff, 0xff } },

  /* Check for `xorl r32, r32' and the equivalent `subl r32, r32'.
     Because of the symmetry, there are actually two ways to encode
     these instructions; opcode bytes 0x29 and 0x2b for `subl' and
     opcode bytes 0x31 and 0x33 for `xorl'.  */

  /* `subl %eax, %eax' */
  { 2, { 0x29, 0xc0 }, { 0xfd, 0xff } },
  /* `subl %ecx, %ecx' */
  { 2, { 0x29, 0xc9 }, { 0xfd, 0xff } },
  /* `subl %edx, %edx' */
  { 2, { 0x29, 0xd2 }, { 0xfd, 0xff } },
  /* `xorl %eax, %eax' */
  { 2, { 0x31, 0xc0 }, { 0xfd, 0xff } },
  /* `xorl %ecx, %ecx' */
  { 2, { 0x31, 0xc9 }, { 0xfd, 0xff } },
  /* `xorl %edx, %edx' */
  { 2, { 0x31, 0xd2 }, { 0xfd, 0xff } },
  { 0 }
};

d504 3
a506 2
   instruction after the sequence that sets up the frame or LIMIT,
   whichever is smaller.  If we don't recognize the code, return PC.  */
d509 1
a509 1
i386_analyze_frame_setup (CORE_ADDR pc, CORE_ADDR limit,
a511 1
  struct i386_insn *insn;
d515 2
a516 2
  if (limit <= pc)
    return limit;
a525 1
      pc++;
d528 7
a534 2
      if (limit <= pc)
	return limit;
d536 15
a550 5
      /* Check for some special instructions that might be migrated by
	 GCC into the prologue and skip them.  At this point in the
	 prologue, code should only touch the scratch registers %eax,
	 %ecx and %edx, so while the number of posibilities is sheer,
	 it is limited.
d554 1
a554 1
      while (pc + skip < limit)
d556 12
a567 3
	  insn = i386_match_insn (pc + skip, i386_frame_setup_skip_insns);
	  if (insn == NULL)
	    break;
d569 1
a569 1
	  skip += insn->len;
a571 6
      /* If that's all, return now.  */
      if (limit <= pc + skip)
	return limit;

      op = read_memory_unsigned_integer (pc + skip, 1);

d576 2
a577 2
	  if (read_memory_unsigned_integer (pc + skip + 1, 1) != 0xec)
	    return pc;
d580 2
a581 2
	  if (read_memory_unsigned_integer (pc + skip + 1, 1) != 0xe5)
	    return pc;
d584 1
a584 1
	  return pc;
d592 1
a592 1
      pc += (skip + 2);
d595 2
a596 2
      if (limit <= pc)
	return limit;
d602 1
a602 1
	 NOTE: You can't subtract a 16-bit immediate from a 32-bit
d604 1
a604 1
      op = read_memory_unsigned_integer (pc, 1);
d607 2
a608 2
	  /* `subl' with 8-bit immediate.  */
	  if (read_memory_unsigned_integer (pc + 1, 1) != 0xec)
d610 1
a610 1
	    return pc;
d612 4
a615 4
	  /* `subl' with signed 8-bit immediate (though it wouldn't
	     make sense to be negative).  */
	  cache->locals = read_memory_integer (pc + 2, 1);
	  return pc + 3;
d619 2
a620 2
	  /* Maybe it is `subl' with a 32-bit immediate.  */
	  if (read_memory_unsigned_integer (pc + 1, 1) != 0xec)
d622 1
a622 1
	    return pc;
d624 3
a626 3
	  /* It is `subl' with a 32-bit immediate.  */
	  cache->locals = read_memory_integer (pc + 2, 4);
	  return pc + 6;
d631 1
a631 1
	  return pc;
d634 1
a634 1
  else if (op == 0xc8)		/* enter */
d687 3
a689 3
   'enter' instruction, or by "subl $<size>, %esp".  'enter' has a
   16-bit unsigned argument for space to allocate, and the 'addl'
   instruction could have either a signed byte, or 32-bit immediate.
d780 1
a780 7
  /* If the function starts with a branch (to startup code at the end)
     the last instruction should bring us back to the first
     instruction of the real code.  */
  if (i386_follow_jump (start_pc) != start_pc)
    pc = i386_follow_jump (pc);

  return pc;
d1049 2
a1050 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (next_frame));
d1052 3
a1054 3
  /* We shouldn't even bother if we don't have a sigcontext_addr
     handler.  */
  if (tdep->sigcontext_addr == NULL)
d1057 3
a1059 14
  if (tdep->sigtramp_p != NULL)
    {
      if (tdep->sigtramp_p (next_frame))
	return &i386_sigtramp_frame_unwind;
    }

  if (tdep->sigtramp_start != 0)
    {
      CORE_ADDR pc = frame_pc_unwind (next_frame);

      gdb_assert (tdep->sigtramp_end != 0);
      if (pc >= tdep->sigtramp_start && pc < tdep->sigtramp_end)
	return &i386_sigtramp_frame_unwind;
    }
d1133 1
a1133 1
i386_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
d1181 1
a1181 1
     definition of the stack address of a frame.  Otherwise
d1366 1
a1366 22
    {
      /* The System V ABI says that:

	 "A function that returns a structure or union also sets %eax
	 to the value of the original address of the caller's area
	 before it returns.  Thus when the caller receives control
	 again, the address of the returned object resides in register
	 %eax and can be used to access the object."

	 So the ABI guarantees that we can always find the return
	 value just after the function has returned.  */

      if (readbuf)
	{
	  ULONGEST addr;

	  regcache_raw_read_unsigned (regcache, I386_EAX_REGNUM, &addr);
	  read_memory (addr, readbuf, TYPE_LENGTH (type));
	}

      return RETURN_VALUE_ABI_RETURNS_ADDRESS;
    }
d1553 1
a1553 1
  /* Read a value spread across multiple registers.  */
d1585 1
a1585 1
  /* Write a value spread across multiple registers.  */
d1601 3
a1603 3
/* Supply register REGNUM from the buffer specified by GREGS and LEN
   in the general-purpose register set REGSET to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
d1609 1
a1609 1
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
d1623 3
a1625 27
/* Collect register REGNUM from the register cache REGCACHE and store
   it in the buffer specified by GREGS and LEN as described by the
   general-purpose register set REGSET.  If REGNUM is -1, do this for
   all registers in REGSET.  */

void
i386_collect_gregset (const struct regset *regset,
		      const struct regcache *regcache,
		      int regnum, void *gregs, size_t len)
{
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
  char *regs = gregs;
  int i;

  gdb_assert (len == tdep->sizeof_gregset);

  for (i = 0; i < tdep->gregset_num_regs; i++)
    {
      if ((regnum == i || regnum == -1)
	  && tdep->gregset_reg_offset[i] != -1)
	regcache_raw_collect (regcache, i, regs + tdep->gregset_reg_offset[i]);
    }
}

/* Supply register REGNUM from the buffer specified by FPREGS and LEN
   in the floating-point register set REGSET to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
d1631 1
a1631 1
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
a1642 22
/* Collect register REGNUM from the register cache REGCACHE and store
   it in the buffer specified by FPREGS and LEN as described by the
   floating-point register set REGSET.  If REGNUM is -1, do this for
   all registers in REGSET.  */

static void
i386_collect_fpregset (const struct regset *regset,
		       const struct regcache *regcache,
		       int regnum, void *fpregs, size_t len)
{
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);

  if (len == I387_SIZEOF_FXSAVE)
    {
      i387_collect_fxsave (regcache, regnum, fpregs);
      return;
    }

  gdb_assert (len == tdep->sizeof_fpregset);
  i387_collect_fsave (regcache, regnum, fpregs);
}

d1655 5
a1659 2
	tdep->gregset = regset_alloc (gdbarch, i386_supply_gregset,
				      i386_collect_gregset);
d1668 5
a1672 2
	tdep->fpregset = regset_alloc (gdbarch, i386_supply_fpregset,
				       i386_collect_fpregset);
d1729 2
a1730 2
/* Return whether the frame preceding NEXT_FRAME corresponds to a
   sigtramp routine.  */
d1733 1
a1733 1
i386_sigtramp_p (struct frame_info *next_frame)
a1734 4
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  char *name;

  find_pc_partial_function (pc, &name, NULL, NULL);
a1763 3
/* Return whether the frame preceding NEXT_FRAME corresponds to a SVR4
   sigtramp routine.  */

d1765 1
a1765 1
i386_svr4_sigtramp_p (struct frame_info *next_frame)
a1766 3
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  char *name;

a1768 1
  find_pc_partial_function (pc, &name, NULL, NULL);
d1791 10
d1806 2
a1807 2
  /* We typically use stabs-in-ELF with the SVR4 register numbering.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_svr4_reg_to_regnum);
d1824 1
a1824 1
  tdep->sigtramp_p = i386_svr4_sigtramp_p;
d1839 1
a1839 2
  /* DJGPP doesn't have any special frames for signal handlers.  */
  tdep->sigtramp_p = NULL;
d1944 1
a1944 1
     and the SSE registers.  This can be overridden for a specific ABI
d1960 1
a1960 1
     calculating the register number for %mm0 until we know the number
a1970 1
  tdep->sigtramp_p = i386_sigtramp_p;
d1999 7
a2005 37
  /* NOTE: kettenis/20040418: GCC does have two possible register
     numbering schemes on the i386: dbx and SVR4.  These schemes
     differ in how they number %ebp, %esp, %eflags, and the
     floating-point registers, and are implemented by the arrays
     dbx_register_map[] and svr4_dbx_register_map in
     gcc/config/i386.c.  GCC also defines a third numbering scheme in
     gcc/config/i386.c, which it designates as the "default" register
     map used in 64bit mode.  This last register numbering scheme is
     implemented in dbx64_register_map, and is used for AMD64; see
     amd64-tdep.c.

     Currently, each GCC i386 target always uses the same register
     numbering scheme across all its supported debugging formats
     i.e. SDB (COFF), stabs and DWARF 2.  This is because
     gcc/sdbout.c, gcc/dbxout.c and gcc/dwarf2out.c all use the
     DBX_REGISTER_NUMBER macro which is defined by each target's
     respective config header in a manner independent of the requested
     output debugging format.

     This does not match the arrangement below, which presumes that
     the SDB and stabs numbering schemes differ from the DWARF and
     DWARF 2 ones.  The reason for this arrangement is that it is
     likely to get the numbering scheme for the target's
     default/native debug format right.  For targets where GCC is the
     native compiler (FreeBSD, NetBSD, OpenBSD, GNU/Linux) or for
     targets where the native toolchain uses a different numbering
     scheme for a particular debug format (stabs-in-ELF on Solaris)
     the defaults below will have to be overridden, like
     i386_elf_init_abi() does.  */

  /* Use the dbx register numbering scheme for stabs and COFF.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);
  set_gdbarch_sdb_reg_to_regnum (gdbarch, i386_dbx_reg_to_regnum);

  /* Use the SVR4 register numbering scheme for DWARF and DWARF 2.  */
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, i386_svr4_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, i386_svr4_reg_to_regnum);
d2032 1
d2114 1
a2114 1
    deprecated_add_show_from_set (new_cmd, &showlist);
d2128 1
a2128 1
    deprecated_add_show_from_set (new_cmd, &showlist);
@


1.180.6.4
log
@Merge from mainline.
@
text
@d154 1
a154 1
/* Return the name of register REGNUM.  */
d157 1
a157 1
i386_register_name (int regnum)
d159 2
a160 2
  if (i386_mmx_regnum_p (current_gdbarch, regnum))
    return i386_mmx_names[regnum - I387_MM0_REGNUM];
d162 2
a163 2
  if (regnum >= 0 && regnum < i386_num_register_names)
    return i386_register_names[regnum];
@


1.179
log
@2004-01-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FUNCTION_START_OFFSET): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	FUNCTION_START_OFFSET.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d4 2
a5 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a1277 13

/* Extract from REGCACHE, which contains the (raw) register state, the
   address in which a function should return its structure value, as a
   CORE_ADDR.  */

static CORE_ADDR
i386_extract_struct_value_address (struct regcache *regcache)
{
  char buf[4];

  regcache_cooked_read (regcache, I386_EAX_REGNUM, buf);
  return extract_unsigned_integer (buf, 4);
}
a1985 2
  set_gdbarch_extract_struct_value_address (gdbarch,
					    i386_extract_struct_value_address);
@


1.178
log
@* i386-tdep.c (i386_analyze_frame_setup): Add missing encodings
for `subl' and `xorl' instructions.
@
text
@a2007 1
  set_gdbarch_function_start_offset (gdbarch, 0);
@


1.177
log
@* i386-tdep.c (i386_extract_return_value,
i386_store_return_value): Add gdbarch argument.  Use it instead of
determining it from REGCACHE.  Remove recursive call for
structures with a single member.
(i386_use_struct_convention): Remove.
(i386_reg_struct_return_p): New function.
(i386_return_value): New function.
(i386_gdbarch_init): Set return_value, don't set
extract_return_value, store_return_value and
use_struct_convention.
* x86-64-tdep.c (x86_64_init_abi): Set return_value to NULL.
@
text
@d511 4
d517 1
a517 1
      while (op == 0x29 || op == 0x31)
@


1.176
log
@* i386-tdep.h (i386_supply_gregset): Provide prototype.
* i386-tdep.c (i386_supply_gregset): Make public.
@
text
@d1154 2
a1155 3
/* Extract from an array REGBUF containing the (raw) register state, a
   function return value of TYPE, and copy that, in virtual format,
   into VALBUF.  */
d1158 2
a1159 2
i386_extract_return_value (struct type *type, struct regcache *regcache,
			   void *valbuf)
d1161 1
a1161 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
a1164 7
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      && TYPE_NFIELDS (type) == 1)
    {
      i386_extract_return_value (TYPE_FIELD_TYPE (type, 0), regcache, valbuf);
      return;
    }

d1204 2
a1205 2
/* Write into the appropriate registers a function return value stored
   in VALBUF of type TYPE, given in virtual format.  */
d1208 2
a1209 2
i386_store_return_value (struct type *type, struct regcache *regcache,
			 const void *valbuf)
d1211 1
a1211 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
a1217 7
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      && TYPE_NFIELDS (type) == 1)
    {
      i386_store_return_value (TYPE_FIELD_TYPE (type, 0), regcache, valbuf);
      return;
    }

d1302 4
d1307 1
a1307 1
i386_use_struct_convention (int gcc_p, struct type *type)
d1309 5
a1313 1
  enum struct_return struct_return;
d1315 41
a1355 6
  if (struct_convention == default_struct_convention)
    struct_return = gdbarch_tdep (current_gdbarch)->struct_return;
  else if (struct_convention == pcc_struct_convention)
    struct_return = pcc_struct_return;
  else
    struct_return = reg_struct_return;
d1357 1
a1357 2
  return generic_use_struct_convention (struct_return == reg_struct_return,
					type);
d1993 1
a1993 2
  set_gdbarch_extract_return_value (gdbarch, i386_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, i386_store_return_value);
a1995 1
  set_gdbarch_use_struct_convention (gdbarch, i386_use_struct_convention);
@


1.175
log
@* i386-tdep.c (i386_extract_return_value): Don't use bfd_byte.
@
text
@d1550 1
a1550 1
static void
@


1.174
log
@* i386-tdep.c (i386_supply_fpregset): Support floating-point
registers in `fxsave' format.
(i386_regset_from_core_section): Deal with ".reg-xfp" sections.
@
text
@d1160 1
a1160 1
			   void *dst)
a1162 1
  bfd_byte *valbuf = dst;
d1204 1
a1204 1
	  memcpy (valbuf + low_size, buf, len - low_size);
@


1.173
log
@Change register numbers to enumartion values.
* i386-tdep.h (enum i386_regnum): New.
(I386_EAX_REGNUM, I386_EDX_REGNUM, I386_ESP_REGNUM,
I386_EBP_REGNUM, I386_IP_REGNUM, I386_EFLAGS_REGNUM,
I386_ST0_REGNUM): Remove defines.
* i386-tdep.c (I386_EBX_REGNUM, I386_ECX_REGNUM, I386_ESI_REGNUM,
I386_EDI_REGNUM): Remove defines.
@
text
@d1579 6
d1609 3
a1611 1
  if (strcmp (sect_name, ".reg2") == 0 && sect_size == tdep->sizeof_fpregset)
@


1.172
log
@* i386-tdep.c (i386_regset_from_core_section): New function.
(i386_gdbarch_init): Initialize regset_from_core_section if
appropriate.
* i386-tdep.h (i386_regset_from_core_section): New declaration.
@
text
@a1420 8
/* These registers don't have pervasive standard uses.  Move them to
   i386-tdep.h if necessary.  */

#define I386_EBX_REGNUM		3 /* %ebx */
#define I386_ECX_REGNUM		1 /* %ecx */
#define I386_ESI_REGNUM		6 /* %esi */
#define I386_EDI_REGNUM		7 /* %edi */

@


1.171
log
@	* i386-tdep.c (i386_analyze_frame_setup): Also handle xorl/subl
	with %eax.
@
text
@d1590 34
d2013 7
@


1.170
log
@* i386-tdep.h (struct gdbarch_tdep): Add members gregset,
gregset_reg_offset, gregset_num_regs, sizeof_gregset, fpregset,
sizeof_fpregset.
* i386-tdep.c: Include "regset.h".
(i386_supply_gregset): New function.
(i386_supply_fpregset): New function.
(i386_gdbarch_init): Initialze register set-related members of
TDEP.
* x86-64-tdep.c (x86_64_supply_fpregset): New function.
(x86_64_init_abi): Initialize TDEP->sizeof_fpregset.
@
text
@d502 1
d509 1
d521 1
@


1.169
log
@* i386-tdep.h: Put opaque declarations in alphabetical
order.  Remove spurious whitespace.
(struct gdbarch_tdep): add st0_regnum and mm0_regnum members.
(i386_sse_regnum_p, i386_mxcsr_regnum_p): Remove prototypes.
* i386-tdep.c (MM0_REGNUM): Remove define.
(i386_mmx_regnum_p): Add gdbarch argument.
(i386_sse_regnum_p, i386_mxcsr_regnum_p): Add gdbarch argument.
Rewrite using new macro definitions for FPU/SSE registers.
(i386_fp_regnum_p, i386_fpc_regnum_p): Rewrite using new macro
definitions from i387-tdep.h.
(i386_register_name): Update.
(i386_stab_reg_to_regnum, i386_dwarf_reg_to_regnum): Update to use
new macro definitions for FPU/SSE registers.
(i386_extract_return_value): Determine whether floating-point
registers are present by examining REGCACHE's architecture.
(i386_store_return_value): Likewise.  Use I386_MAX_REGISTER_SIZE
instead of FPU_REG_RAW_SIZE.  Use new macro definitions for
FPU/SSE registers.
(i386_register_type): Update.
(i386_mmx_regnum_to_fp_regnum): Rewrite using new macro
definitions for FPU registers.  Use REGCACHE's architecture to
determine the appropriate register numbers.
(i386_pseudo_register_read, i386_pseudo_register_write,
i386_register_reggroup_p): Update.
(i386_gdbarch_init): Initialize TDEP->st0_regnum and
TDEP->mm0_regnum.
* i387-tdep.h (I387_FCTRL_REGNUM, I387_FSTAT_REGNUM,
I387_FTAG_REGNUM, I387_FISEG_REGNUM, I387_FIOFF_REGNUM,
I387_FOSEG_REGNUM, I387_FOOFF_REGNUM, I387_FOP_REGNUM,
I387_XMM0_REGNUM, I387_MXCSR_REGNUM): New defines.
(i387_supply_fsave, i387_fill_fsave, i387_supply_fxsave,
i387_fill_fxsave): Change type of fsave/fxsave argument from `char
*' to `void *'.
* i387-tdep.c (i387_print_float_info, fsave_offset, FSAVE_ADDR,
i387_supply_fsave, i387_fill_fsave, fxsave_offset, FXSAVE_ADDR,
i387_supply_fxsave, i387_fill_fxsave): Update to use new macro
definitions for FPU/SSE registers.
(FXSAVE_MXCSR_ADDR): New define.
* x86-64-tdep.c (x86_64_init_abi): Override TDEP->st0_regnum and
TDEP->mm0_regnum.
(I387_FISEG_REGNUM, I387_FOSEG_REGNUM): Remove defines.
(I387_ST0_REGNUM): Define.
@
text
@d40 1
d1552 3
d1556 32
d1841 10
@


1.168
log
@* i386-tdep.c (i386_num_register_names, i386_num_mmx_regs):
Initialize using ARRAY_SIZE.
@
text
@a81 2
#define MM0_REGNUM NUM_REGS

d83 1
a83 1
i386_mmx_regnum_p (int regnum)
d85 6
a90 2
  return (regnum >= MM0_REGNUM
	  && regnum < MM0_REGNUM + i386_num_mmx_regs);
d93 1
a93 1
/* FP register?  */
d95 2
a96 2
int
i386_fp_regnum_p (int regnum)
d98 12
a109 2
  return (regnum < NUM_REGS
	  && (FP0_REGNUM && FP0_REGNUM <= regnum && regnum < FPC_REGNUM));
d112 2
a113 2
int
i386_fpc_regnum_p (int regnum)
d115 12
a126 2
  return (regnum < NUM_REGS
	  && (FPC_REGNUM <= regnum && regnum < XMM0_REGNUM));
d129 5
a133 1
/* SSE register?  */
d136 1
a136 1
i386_sse_regnum_p (int regnum)
d138 4
a141 2
  return (regnum < NUM_REGS
	  && (XMM0_REGNUM <= regnum && regnum < MXCSR_REGNUM));
d145 1
a145 1
i386_mxcsr_regnum_p (int regnum)
d147 4
a150 2
  return (regnum < NUM_REGS
	  && regnum == MXCSR_REGNUM);
d158 2
a159 2
  if (i386_mmx_regnum_p (reg))
    return i386_mmx_names[reg - MM0_REGNUM];
d182 1
a182 1
      return reg - 12 + FP0_REGNUM;
d187 1
a187 1
      return reg - 21 + XMM0_REGNUM;
d192 1
a192 1
      return reg - 29 + MM0_REGNUM;
d215 1
a215 1
      return reg - 11 + FP0_REGNUM;
d226 4
d1158 1
d1172 1
a1172 1
      if (FP0_REGNUM < 0)
d1216 1
d1219 4
d1233 1
a1233 1
      char buf[FPU_REG_RAW_SIZE];
d1235 1
a1235 1
      if (FP0_REGNUM < 0)
d1256 1
a1256 1
      regcache_raw_read_unsigned (regcache, FSTAT_REGNUM, &fstat);
d1258 1
a1258 1
      regcache_raw_write_unsigned (regcache, FSTAT_REGNUM, fstat);
d1263 1
a1263 1
      regcache_raw_write_unsigned (regcache, FTAG_REGNUM, 0x3fff);
d1282 2
d1345 1
a1345 1
  if (i386_sse_regnum_p (regnum))
d1348 1
a1348 1
  if (i386_mmx_regnum_p (regnum))
d1360 2
a1361 1
  int mmxi;
a1363 1
  int fpi;
d1365 6
a1370 2
  mmxi = regnum - MM0_REGNUM;
  regcache_raw_read_unsigned (regcache, FSTAT_REGNUM, &fstat);
d1372 1
a1372 1
  fpi = (mmxi + tos) % 8;
d1374 3
a1376 1
  return (FP0_REGNUM + fpi);
d1383 1
a1383 1
  if (i386_mmx_regnum_p (regnum))
d1400 1
a1400 1
  if (i386_mmx_regnum_p (regnum))
d1759 2
a1760 2
  int sse_regnum_p = (i386_sse_regnum_p (regnum)
		      || i386_mxcsr_regnum_p (regnum));
d1763 1
a1763 1
  int mmx_regnum_p = (i386_mmx_regnum_p (regnum));
d1806 20
a1825 13
  /* The i386 default settings now include the SSE registers.
     I386_NUM_XREGS includes mxcsr, and we don't want to count
     this as one of the xmm regs -- which is why we subtract one.

     Note: kevinb/2003-07-14: Whatever Mark's concerns are about the
     FPU registers in the FIXME below apply to the SSE registers as well.
     The only problem that I see is that these registers will show up
     in "info all-registers" even on CPUs where they don't exist.  IMO,
     however, if it's a choice between printing them always (even when
     they don't exist) or never showing them to the user (even when they
     do exist), I prefer the former over the latter.  Ideally, of course,
     we'd somehow autodetect that we have them (or not) and display them
     when we have them and suppress them when we don't.
d1827 1
a1827 2
     FIXME: kettenis/20020614: They do include the FPU registers for
     now, which probably is not quite right.  */
d1930 5
@


1.167
log
@2003-09-04  Andrew Cagney  <cagney@@redhat.com>

	* avr-tdep.c: Include "dis-asm.h".
	* cris-tdep.c: Include "dis-asm.h".
	(cris_delayed_get_disassembler): Use "struct disassemble_info"
	instead of corresponding typedef.
	* h8300-tdep.c: Include "dis-asm.h".
	* ia64-tdep.c: Include "dis-asm.h".
	* i386-tdep.c: Include "dis-asm.h".
	(i386_print_insn): Use "struct disassemble_info" instead of
	corresponding typedef.
	* m68k-tdep.c: Include "dis-asm.h".
	* mcore-tdep.c: Include "dis-asm.h".
	* mips-tdep.c: Include "dis-asm.h".
	(gdb_print_insn_mips): Make static, use "struct disassemble_info"
	instead of corresponding typedef.
	* ns32k-tdep.c: Include "dis-asm.h".
	* s390-tdep.c: Include "dis-asm.h".
	* sparc-tdep.c: Include "dis-asm.h".
	* vax-tdep.c: Include "dis-asm.h".
	* v850-tdep.c: Include "dis-asm.h".
	* mn10300-tdep.c: Include "dis-asm.h".
	* rs6000-tdep.c: Include "dis-asm.h".
	* xstormy16-tdep.c: Include "dis-asm.h".
	(_initialize_xstormy16_tdep): Delete "extern" declaration of
	print_insn_xstormy16.
	* Makefile.in (v850-tdep.o): Update dependencies.
	(vax-tdep.o, sparc-tdep.o, s390-tdep.o): Ditto.
	(ns32k-tdep.o, mips-tdep.o, mcore-tdep.o): Ditto.
	(m68k-tdep.o, ia64-tdep.o, i386-tdep.o): Ditto.
	(h8300-tdep.o, cris-tdep.o, avr-tdep.o): Ditto.
	(mn10300-tdep.o, xstormy16-tdep.o, disasm.o): Ditto.
	(gdbarch_h): Remove $(dis_asm_h).
	* disasm.c: Include "dis-asm.h".
	(dis_asm_read_memory): Use "struct disassemble_info" instead of
	corresponding typedef.
	(dis_asm_memory_error, dump_insns, do_assembly_only): Ditto.
	(gdb_disassemble_info, gdb_disassembly, gdb_print_insn): Ditto.
	* gdbarch.sh: Do not include "dis-asm.h".
	(struct disassemble_info): Declare opaque.
	(TARGET_PRINT_INSN): Update declaration.
	* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d70 1
a70 2
static const int i386_num_register_names =
  (sizeof (i386_register_names) / sizeof (*i386_register_names));
d80 1
a80 2
static const int i386_num_mmx_regs =
  (sizeof (i386_mmx_names) / sizeof (i386_mmx_names[0]));
@


1.166
log
@* i386-tdep.c (i386_analyze_register_saves): Handle register saves
at the start of a frameless function.  This probably fixes PR
backtrace/1338.
@
text
@d44 1
d1570 1
a1570 1
i386_print_insn (bfd_vma pc, disassemble_info *info)
@


1.165
log
@	* i386-tdep.c (i386_gdbarch_init): Enable default support for
	SSE registers.
@
text
@d574 7
a580 1
  if (cache->locals >= 0)
d582 3
a584 10
      CORE_ADDR offset;
      unsigned char op;
      int i;

      offset = - 4 - cache->locals;
      for (i = 0; i < 8 && pc < current_pc; i++)
	{
	  op = read_memory_unsigned_integer (pc, 1);
	  if (op < 0x50 || op > 0x57)
	    break;
d586 4
a589 4
	  cache->saved_regs[op - 0x50] = offset;
	  offset -= 4;
	  pc++;
	}
@


1.164
log
@* i386-tdep.c (i386_register_to_value): Use get_frame_register
instead of frame_read_register.
(i386_fetch_pointer_argument): Use get_frame_register_unsigned
instead of frame_read_register.  Use I386_ESP_REGNUM instead of
SP_REGNUM.
(i386_frame_prev_register): Use frame_unwind_register_unsigned
instead of frame_unwind_unsigned_register.  Use
I386_EFLAGS_REGISTER instead of PS_REGNUM.
(i386_get_longjmp_target): Use regcache_read_unsigned_register
instead of read_register.  Use builtin_type_void_data_ptr instead
of builtin_type_void_func_ptr when extracting the address of the
jmp_buf.
(i386_extract_return_value, i386_store_return_value,
i386_pseudo_register_read, i386_pseudo_register_write): Use
register_size instead REGISTER_RAW_SIZE.

(i387_print_float_info): Use get_frame_register and
get_frame_register_unsigned instead of frame_register_read.
@
text
@d1760 14
a1773 1
  /* The i386 default settings don't include the SSE registers.
d1776 1
a1776 1
  tdep->num_xmm_regs = 0;
d1798 3
a1800 3
  /* The default ABI includes general-purpose registers and
     floating-point registers.  */
  set_gdbarch_num_regs (gdbarch, I386_NUM_GREGS + I386_NUM_FREGS);
@


1.163
log
@Based on a patch from Michael Elizabeth Chastain (mec@@shout.net):
* i386-tdep.c (i386_analyze_frame_setup): Recognize more
instructions that GCC likes to mingle into the prologue.  Fixes
gdb/1253 and gdb/1255.
@
text
@d835 2
a836 1
	  frame_unwind_unsigned_register (next_frame, PS_REGNUM, &val);
d1039 4
a1042 1
  sp = read_register (SP_REGNUM);
d1046 1
a1046 1
  jb_addr = extract_typed_address (buf, builtin_type_void_func_ptr);
d1155 2
a1156 2
      int low_size = REGISTER_RAW_SIZE (LOW_RETURN_REGNUM);
      int high_size = REGISTER_RAW_SIZE (HIGH_RETURN_REGNUM);
d1229 2
a1230 2
      int low_size = REGISTER_RAW_SIZE (LOW_RETURN_REGNUM);
      int high_size = REGISTER_RAW_SIZE (HIGH_RETURN_REGNUM);
d1344 1
a1344 1
      memcpy (buf, mmx_buf, REGISTER_RAW_SIZE (regnum));
d1362 1
a1362 1
      memcpy (mmx_buf, buf, REGISTER_RAW_SIZE (regnum));
d1466 1
a1466 1
      frame_read_register (frame, regnum, buf);
d1734 2
a1735 1
/* Get the ith function argument for the current function.  */
d1740 2
a1741 3
  CORE_ADDR stack;
  frame_read_register (frame, SP_REGNUM, &stack);
  return read_memory_unsigned_integer (stack + (4 * (argi + 1)), 4);
@


1.162
log
@2003-07-18  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DWARF2_BUILD_FRAME_INFO): Delete method.
	* gdbarch.h, gdbarch.c: Re-generate.
	* i386-tdep.c (i386_gdbarch_init): Do not set
	DWARF2_BUILD_FRAME_INFO.
	* elfread.c (elf_symfile_read): Call dwarf2_build_frame_info
	unconditionally.
	* alpha-tdep.c (alpha_dwarf2_init_abi): Do not set
	DWARF2_BUILD_FRAME_INFO.
@
text
@d442 1
d460 34
a494 1
      op = read_memory_unsigned_integer (pc + 1, 1);
d498 1
a498 1
	  if (read_memory_unsigned_integer (pc + 2, 1) != 0xec)
d502 1
a502 1
	  if (read_memory_unsigned_integer (pc + 2, 1) != 0xe5)
d509 4
a512 2
      /* OK, we actually have a frame.  We just don't know how large it is
	 yet.  Set its size to zero.  We'll adjust it if necessary.  */
d514 1
@


1.161
log
@2003-07-16  Andrew Cagney  <cagney@@redhat.com>

	* frame-base.h (frame_base_p_ftype): Delete definition.
	(frame_base_append_predicate): Delete declaration.
	* frame-unwind.h (frame_unwind_p_ftype): Delete definition.
	(frame_unwind_append_predicate): Delete declaration.
	* frame-unwind.c (struct frame_unwind_table): Delete field "p".
	(append_predicate): Delete parameter "p".
	(frame_unwind_append_predicate): Delete function.
	(frame_unwind_append_sniffer): Update call to append_predicate.
	(frame_unwind_free): Delete function.
	(_initialize_frame_unwind): Pass NULL as "free" to
	register_gdbarch_data.
	(frame_unwind_init): Append the dummy_frame_sniffer.
	(frame_unwind_find_by_frame): Simplify.
	* frame-base.c (struct frame_base_table): Delete field "p".
	(append_predicate): Delete parameter "p".
	(frame_base_append_predicate): Delete function.
	(frame_base_append_sniffer): Update call to append_predicate.
	(frame_base_free): Delete function.
	(frame_base_find_by_frame): Simplify.
	(_initialize_frame_base): Pass NULL as "free" to
	register_gdbarch_data.
	* x86-64-tdep.c (x86_64_frame_sniffer): Replace "x86_64_frame_p".
	(x86_64_sigtramp_frame_sniffer): Replace
	"x86_64_sigtramp_frame_p".
	(x86_64_init_abi): Set the frame unwind sniffers.
	* m68k-tdep.c (m68k_frame_sniffer): Replace "m68k_frame_p".
	(m68k_sigtramp_frame_sniffer): Replace "m68k_sigtramp_frame_p"
	(m68k_gdbarch_init): Set the frame unwind sniffers.
	* i386-tdep.c (i386_sigtramp_frame_sniffer): Replace
	"i386_sigtramp_frame_p".
	(i386_frame_sniffer): Replace "i386_frame_p".
	(i386_gdbarch_init): Set the frame unwind sniffers.
	* avr-tdep.c (avr_frame_sniffer): Replace "avr_frame_sniffer".
	(avr_gdbarch_init): Set the frame unwind sniffers.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Replace
	"alpha_sigtramp_frame_p"
	(alpha_heuristic_frame_sniffer): Replace
	"alpha_heuristic_frame_p".
	(alpha_gdbarch_init): Set the frame unwind sniffers.
	(alpha_dwarf2_init_abi): Ditto.
	* alpha-mdebug-tdep.c (alpha_mdebug_frame_sniffer): Replace
	"alpha_debug_frame_p".
	(alpha_mdebug_frame_base_sniffer): Replace
	"alpha_mdebug_frame_base_p".
	(alpha_mdebug_init_abi): Set the frame unwind sniffers.
	* d10v-tdep.c (d10v_frame_sniffer): Replace "d10v_frame_p".
	(d10v_gdbarch_init): Set the frame unwind sniffer.
	* dwarf2-frame.c (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	(dwarf2_frame_base_sniffer): Replace "dwarf2_frame_base_p".
	* dwarf2-frame.h (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	(dwarf2_frame_base_sniffer): Replace "dwarf2_frame_base_p".
	* dummy-frame.c (dummy_frame_sniffer): Replace "dummy_frame_p".
	* dummy-frame.h (dummy_frame_sniffer): Replace "dummy_frame_p".
@
text
@a1815 1
  set_gdbarch_dwarf2_build_frame_info (gdbarch, dwarf2_build_frame_info);
@


1.160
log
@2003-07-02  Andrew Cagney  <cagney@@redhat.com>

	* i386-tdep.c: Revert change committed as part of trad-frame code
	below.
@
text
@d854 1
a854 1
i386_frame_p (CORE_ADDR pc)
d932 1
a932 1
i386_sigtramp_frame_p (CORE_ADDR pc)
d934 1
d1815 1
a1815 1
  frame_unwind_append_predicate (gdbarch, dwarf2_frame_p);
d1823 2
a1824 2
  frame_unwind_append_predicate (gdbarch, i386_sigtramp_frame_p);
  frame_unwind_append_predicate (gdbarch, i386_frame_p);
@


1.159
log
@2003-07-01  Andrew Cagney  <cagney@@redhat.com>

	* trad-frame.h: Update comments, a -1 .addr is reserved.
	(trad_frame_value_p, trad_frame_addr_p): Declare.
	(trad_frame_reg_p): Declare.
	(trad_frame_set_value): Rename trad_frame_register_value.
	(trad_frame_set_unknown): Declare.
	* trad-frame.c (trad_frame_realreg_p): New function.
	(trad_frame_addr_p, trad_frame_value_p): New function.
	(trad_frame_set_unknown): New function.
	(trad_frame_alloc_saved_regs): Initialize .addr to -1, not zero.
	(trad_frame_prev_register): Use trad_frame_realreg_p,
	trad_frame_addr_p and trad_frame_value_p.
	(trad_frame_set_value): Rename trad_frame_register_value.
	* d10v-tdep.c (d10v_frame_unwind_cache): Use trad_frame_addr_p
	and trad_frame_set_value.
@
text
@a43 1
#include "trad-frame.h"
d251 2
a252 4
  /* Saved registers.  While trad-frame allocates space for the full
     NUM_REGS + NUM_PSEUDOREGS, some of the code below cheats and
     allocates space for only I386_NUM_SAVED_REGS.  */
  struct trad_frame_saved_reg *saved_regs;
d263 1
a263 1
i386_alloc_frame_cache (struct frame_info *next_frame)
d275 4
a278 1
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d452 1
a452 1
      cache->saved_regs[I386_EBP_REGNUM].addr = 0;
d550 1
a550 1
	  cache->saved_regs[op - 0x50].addr = offset;
a611 5
  /* Allocate space for the maximum number of saved registers.  This
     should include all registers mentioned above, and %eip.  */
  cache.saved_regs = alloca (I386_NUM_SAVED_REGS
			     * sizeof (cache.saved_regs[0]));

d693 1
a693 1
  cache = i386_alloc_frame_cache (next_frame);
d711 1
a711 1
  cache->saved_regs[I386_EIP_REGNUM].addr = 4;
d738 2
a739 3
    if (cache->saved_regs[i].realnum >= 0
	&& cache->saved_regs[i].addr != -1)
      cache->saved_regs[i].addr += cache->base;
d827 17
a843 2
  trad_frame_prev_register (next_frame, cache->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
d873 1
a873 1
  cache = i386_alloc_frame_cache (next_frame);
d887 1
a887 1
	  cache->saved_regs[i].addr = addr + tdep->sc_reg_offset[i];
d891 2
a892 2
      cache->saved_regs[I386_EIP_REGNUM].addr = addr + tdep->sc_pc_offset;
      cache->saved_regs[I386_ESP_REGNUM].addr = addr + tdep->sc_sp_offset;
@


1.158
log
@* i386-tdep.c (i386_next_regnum): Fix bounds checking.
(i386_convert_register_p, i386_register_to_value,
i386_register_from_value): Handle types longer than 8 bytes.
@
text
@d44 1
d252 4
a255 2
  /* Saved registers.  */
  CORE_ADDR saved_regs[I386_NUM_SAVED_REGS];
d266 1
a266 1
i386_alloc_frame_cache (void)
d278 1
a278 4
  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %ebp is supposed to be stored).  */
  for (i = 0; i < I386_NUM_SAVED_REGS; i++)
    cache->saved_regs[i] = -1;
d452 1
a452 1
      cache->saved_regs[I386_EBP_REGNUM] = 0;
d550 1
a550 1
	  cache->saved_regs[op - 0x50] = offset;
d612 5
d698 1
a698 1
  cache = i386_alloc_frame_cache ();
d716 1
a716 1
  cache->saved_regs[I386_EIP_REGNUM] = 4;
d743 3
a745 2
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;
d833 2
a834 17
  if (regnum < I386_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
	}
      return;
    }

  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
d864 1
a864 1
  cache = i386_alloc_frame_cache ();
d878 1
a878 1
	  cache->saved_regs[i] = addr + tdep->sc_reg_offset[i];
d882 2
a883 2
      cache->saved_regs[I386_EIP_REGNUM] = addr + tdep->sc_pc_offset;
      cache->saved_regs[I386_ESP_REGNUM] = addr + tdep->sc_sp_offset;
@


1.158.2.1
log
@2003-07-01  Andrew Cagney  <cagney@@redhat.com>

	* trad-frame.h: Update comments, a -1 .addr is reserved.
	(trad_frame_value_p, trad_frame_addr_p): Declare.
	(trad_frame_reg_p): Declare.
	(trad_frame_set_value): Rename trad_frame_register_value.
	(trad_frame_set_unknown): Declare.
	* trad-frame.c (trad_frame_realreg_p): New function.
	(trad_frame_addr_p, trad_frame_value_p): New function.
	(trad_frame_set_unknown): New function.
	(trad_frame_alloc_saved_regs): Initialize .addr to -1, not zero.
	(trad_frame_prev_register): Use trad_frame_realreg_p,
	trad_frame_addr_p and trad_frame_value_p.
	(trad_frame_set_value): Rename trad_frame_register_value.
	* d10v-tdep.c (d10v_frame_unwind_cache): Use trad_frame_addr_p
	and trad_frame_set_value.
@
text
@a43 1
#include "trad-frame.h"
d251 2
a252 4
  /* Saved registers.  While trad-frame allocates space for the full
     NUM_REGS + NUM_PSEUDOREGS, some of the code below cheats and
     allocates space for only I386_NUM_SAVED_REGS.  */
  struct trad_frame_saved_reg *saved_regs;
d263 1
a263 1
i386_alloc_frame_cache (struct frame_info *next_frame)
d275 4
a278 1
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d452 1
a452 1
      cache->saved_regs[I386_EBP_REGNUM].addr = 0;
d550 1
a550 1
	  cache->saved_regs[op - 0x50].addr = offset;
a611 5
  /* Allocate space for the maximum number of saved registers.  This
     should include all registers mentioned above, and %eip.  */
  cache.saved_regs = alloca (I386_NUM_SAVED_REGS
			     * sizeof (cache.saved_regs[0]));

d693 1
a693 1
  cache = i386_alloc_frame_cache (next_frame);
d711 1
a711 1
  cache->saved_regs[I386_EIP_REGNUM].addr = 4;
d738 2
a739 3
    if (cache->saved_regs[i].realnum >= 0
	&& cache->saved_regs[i].addr != -1)
      cache->saved_regs[i].addr += cache->base;
d827 17
a843 2
  trad_frame_prev_register (next_frame, cache->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
d873 1
a873 1
  cache = i386_alloc_frame_cache (next_frame);
d887 1
a887 1
	  cache->saved_regs[i].addr = addr + tdep->sc_reg_offset[i];
d891 2
a892 2
      cache->saved_regs[I386_EIP_REGNUM].addr = addr + tdep->sc_pc_offset;
      cache->saved_regs[I386_ESP_REGNUM].addr = addr + tdep->sc_sp_offset;
@


1.158.2.2
log
@Ulgh! Revert stray patch involving trad-frames.
@
text
@d44 1
d252 4
a255 2
  /* Saved registers.  */
  CORE_ADDR saved_regs[I386_NUM_SAVED_REGS];
d266 1
a266 1
i386_alloc_frame_cache (void)
d278 1
a278 4
  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %ebp is supposed to be stored).  */
  for (i = 0; i < I386_NUM_SAVED_REGS; i++)
    cache->saved_regs[i] = -1;
d452 1
a452 1
      cache->saved_regs[I386_EBP_REGNUM] = 0;
d550 1
a550 1
	  cache->saved_regs[op - 0x50] = offset;
d612 5
d698 1
a698 1
  cache = i386_alloc_frame_cache ();
d716 1
a716 1
  cache->saved_regs[I386_EIP_REGNUM] = 4;
d743 3
a745 2
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;
d833 2
a834 17
  if (regnum < I386_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
	}
      return;
    }

  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
d864 1
a864 1
  cache = i386_alloc_frame_cache ();
d878 1
a878 1
	  cache->saved_regs[i] = addr + tdep->sc_reg_offset[i];
d882 2
a883 2
      cache->saved_regs[I386_EIP_REGNUM] = addr + tdep->sc_pc_offset;
      cache->saved_regs[I386_ESP_REGNUM] = addr + tdep->sc_sp_offset;
@


1.158.2.3
log
@2003-07-21  Andrew Cagney  <cagney@@redhat.com>

	* dwarf2-frame.h (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	* dwarf2-frame.c (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	(dwarf2_frame_cache): Use frame_unwind_address_in_block, instead
	of frame_pc_unwind.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* alpha-tdep.c (alpha_dwarf2_init_abi): Update.
@
text
@d1814 1
a1814 1
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
@


1.158.2.4
log
@Based on a patch from Michael Elizabeth Chastain (mec@@shout.net):
* i386-tdep.c (i386_analyze_frame_setup): Recognize more
instructions that GCC likes to mingle into the prologue.  Fixes
gdb/1253 and gdb/1255.
@
text
@a441 1
  int skip = 0;
d459 1
a460 34

      /* Check for some special instructions that might be migrated
	 by GCC into the prologue.  We check for

	    xorl %ebx, %ebx
	    xorl %ecx, %ecx
	    xorl %edx, %edx

	 and the equivalent

	    subl %ebx, %ebx
	    subl %ecx, %ecx
	    subl %edx, %edx

	 Make sure we only skip these instructions if we later see the
	 `movl %esp, %ebp' that actually sets up the frame.  */
      while (op == 0x29 || op == 0x31)
	{
	  op = read_memory_unsigned_integer (pc + skip + 2, 1);
	  switch (op)
	    {
	    case 0xdb:	/* %ebx */
	    case 0xc9:	/* %ecx */
	    case 0xd2:	/* %edx */
	      skip += 2;
	      break;
	    default:
	      return pc + 1;
	    }

	  op = read_memory_unsigned_integer (pc + skip + 1, 1);
	}

      /* Check for `movl %esp, %ebp' -- can be written in two ways.  */
d464 1
a464 1
	  if (read_memory_unsigned_integer (pc + skip + 2, 1) != 0xec)
d468 1
a468 1
	  if (read_memory_unsigned_integer (pc + skip + 2, 1) != 0xe5)
d475 2
a476 4
      /* OK, we actually have a frame.  We just don't know how large
	 it is yet.  Set its size to zero.  We'll adjust it if
	 necessary.  We also now commit to skipping the special
	 instructions mentioned before.  */
a477 1
      pc += skip;
@


1.158.2.5
log
@* i386-tdep.c (i386_analyze_register_saves): Handle register saves
at the start of a frameless function.  This probably fixes PR
backtrace/1338.
@
text
@d574 5
a578 3
  CORE_ADDR offset = 0;
  unsigned char op;
  int i;
d580 6
a585 7
  if (cache->locals > 0)
    offset -= cache->locals;
  for (i = 0; i < 8 && pc < current_pc; i++)
    {
      op = read_memory_unsigned_integer (pc, 1);
      if (op < 0x50 || op > 0x57)
	break;
d587 4
a590 4
      offset -= 4;
      cache->saved_regs[op - 0x50] = offset;
      cache->sp_offset += 4;
      pc++;
@


1.157
log
@* i386-tdep.c (i386_register_to_value, i386_value_to_register):
Move floating-point code to new function in i387-tdep.c.
* i387-tdep.c (i387_register_to_value, i387_value_to_register):
New functions containing code moved here from i386-tdep.c.
* i387-tdep.h: Add opaque declaration for `struct type'.
(i387_register_to_value, i387_value_to_register): New prototypes.
* x86-64-tdep.c (x86_64_convert_register_p): New function.
(x86_64_init_abi): Set convert_register_p, register_to_value and
value_to_register here.
@
text
@d1360 1
a1360 1
  if (regnum < sizeof (next_regnum) / sizeof (next_regnum[0]))
d1372 2
d1377 15
a1391 4
     are exactly 8 bytes long as GCC doesn't seem to put any other
     types into registers.  */
  if (TYPE_LENGTH (type) == 8 && i386_next_regnum (regnum) != -1)
    return 1;
d1403 3
d1415 1
a1415 1
  gdb_assert (TYPE_LENGTH (type) == 8);
d1417 12
a1428 9
  /* Read the first part.  */
  gdb_assert (register_size (current_gdbarch, regnum) == 4);
  frame_read_register (frame, regnum, (char *) to + 0);

  /* Read the second part.  */
  regnum = i386_next_regnum (regnum);
  gdb_assert (regnum != -1);
  gdb_assert (register_size (current_gdbarch, regnum));
  frame_read_register (frame, regnum, (char *) to + 4);
d1438 3
d1447 3
a1449 1
  gdb_assert (TYPE_LENGTH (type) == 8);
d1451 10
a1460 9
  /* Write the first part.  */
  gdb_assert (register_size (current_gdbarch, regnum) == 4);
  put_frame_register (frame, regnum, (const char *) from + 0);

  /* Write the second part.  */
  regnum = i386_next_regnum (regnum);
  gdb_assert (regnum != -1);
  gdb_assert (register_size (current_gdbarch, regnum) == 4);
  put_frame_register (frame, regnum, (const char *) from + 4);
@


1.156
log
@2003-06-14  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_register_to_value): Make static.
	(mips_value_to_register): Make static.
	* i386-tdep.c (i386_fetch_pointer_argument): Make static.
	* ia64-tdep.c (ia64_register_raw_size): Make static.
	(ia64_register_virtual_size): Make static.
	(ia64_register_byte): Make static.
	* i387-tdep.c: Include "i387-tdep.h".
	(print_387_control_word): Delete function.
	(print_387_status_word): Delete function.
	(print_387_status_bits): Delete function.
	(print_387_control_bits): Delete function.
	* Makefile.in (i387-tdep.o): Update dependencies.
	* rdi-share/host.h (Fail): Declare.
	* remote-rdi.c (Fail): Update to match declaration.
@
text
@d1395 3
a1397 1
      char from[I386_MAX_REGISTER_SIZE];
d1399 1
a1399 17
      /* We only support floating-point values.  */
      if (TYPE_CODE (type) != TYPE_CODE_FLT)
	{
	  warning ("Cannot convert floating-point register value "
		   "to non-floating-point type.");
	  return;
	}

      /* Convert to TYPE.  This should be a no-op if TYPE is
	 equivalent to the extended floating-point format used by the
	 FPU.  */
      frame_read_register (frame, regnum, from);
      convert_typed_floating (from, builtin_type_i387_ext, to, type);
    }
  else
    {
      gdb_assert (TYPE_LENGTH (type) == 8);
d1401 9
a1409 10
      /* Read the first part.  */
      gdb_assert (register_size (current_gdbarch, regnum) == 4);
      frame_read_register (frame, regnum, (char *) to + 0);

      /* Read the second part.  */
      regnum = i386_next_regnum (regnum);
      gdb_assert (regnum != -1);
      gdb_assert (register_size (current_gdbarch, regnum));
      frame_read_register (frame, regnum, (char *) to + 4);
    }
d1421 3
a1423 1
      char to[I386_MAX_REGISTER_SIZE];
d1425 1
a1425 17
      /* We only support floating-point values.  */
      if (TYPE_CODE (type) != TYPE_CODE_FLT)
	{
	  warning ("Cannot convert non-floating-point type "
		   "to floating-point register value.");
	  return;
	}

      /* Convert from TYPE.  This should be a no-op if TYPE is
	 equivalent to the extended floating-point format used by the
	 FPU.  */
      convert_typed_floating (from, type, to, builtin_type_i387_ext);
      put_frame_register (frame, regnum, to);
    }
  else
    {
      gdb_assert (TYPE_LENGTH (type) == 8);
d1427 9
a1435 10
      /* Write the first part.  */
      gdb_assert (register_size (current_gdbarch, regnum) == 4);
      put_frame_register (frame, regnum, (const char *) from + 0);

      /* Write the second part.  */
      regnum = i386_next_regnum (regnum);
      gdb_assert (regnum != -1);
      gdb_assert (register_size (current_gdbarch, regnum) == 4);
      put_frame_register (frame, regnum, (const char *) from + 4);
   }
@


1.155
log
@2003-06-14  Andrew Cagney  <cagney@@redhat.com>
            Mark Kettenis  <kettenis@@gnu.org>

	* gdbarch.sh (CONVERT_REGISTER_P): Add "type" parameter.
	(REGISTER_TO_VALUE, VALUE_TO_REGISTER): Replace raw buffer
	parameter with "frame".
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h (put_frame_register): Declare.
	* frame.c (put_frame_register): New function.
	* arch-utils.c (legacy_convert_register_p): Add "type" parameter.
	(legacy_register_to_value): Rewrite, use "frame" to get the
	register value.
	(legacy_value_to_register): Rewrite, use "frame" to find the
	register's location before storing.
	* arch-utils.h (legacy_convert_register_p): Update.
	(legacy_register_to_value, legacy_value_to_register): Update.
	* findvar.c (value_from_register): Rewrite, eliminate use of
	REGISTER_CONVERT_TO_TYPE, pass "type" to CONVERT_REGISTER_P, pass
	"frame" to REGISTER_TO_VALUE.
	* valops.c (value_assign): Move the CONVERT_REGISTER code to the
	lval_reg_frame_relative + lval_register branch of the switch.  Do
	not use REGISTER_CONVERT_FROM_TYPE.  Use put_frame_register.
	* i386-tdep.c (I386_EBX_REGNUM, I386_ECX_REGNUM, I386_ESI_REGNUM,
	I386_EDI_REGNUM): New defines.
	(i386_next_regnum, i386_convert_register_p,
	i386_register_to_value, i386_value_to_register): New functions.
	(i386_register_convertible, i386_register_convert_to_virtual,
	i386_convert_to_raw): Remove functions.
	(i386_gdbarch_init): Set convert_register_p, register_to_value and
	value_to_register instead of register_convertible,
	register_convert_to_virtual and register_convert_to_raw.
	* mips-tdep.c (mips_convert_register_p): New function.
	(mips_value_to_register): Replace mips_register_convert_from_type.
	(mips_register_to_value): Replace mips_register_convert_to_type.
	(mips_gdbarch_init): Set conver_register_p, value_to_register and
	register_to_value.
	* alpha-tdep.c (alpha_convert_register_p): Update.
	(alpha_value_to_register): Update, store the register.
	(alpha_register_to_value): Update, fetch the register.
@
text
@d1698 1
a1698 1
CORE_ADDR
@


1.154
log
@2003-06-13  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c (call_function_by_hand): When UNWIND_DUMMY_ID is
	available, do not use the FP register, and always save the TOS.
	* dummy-frame.c (dummy_frame_this_id): Do not assert
	SAVE_DUMMY_FRAME_TOS.
	* i386-tdep.c (i386_save_dummy_frame_tos): Delete function.
	(i386_gdbarch_init): Do not set save_dummy_frame_tos.
	(i386_push_dummy_call): Add 8 to the returned SP.
	* frame.c (legacy_frame_p): Do not require SAVE_DUMMY_FRAME_TOS.
	* d10v-tdep.c (d10v_unwind_dummy_id): Use d10v_unwind_sp.
	(d10v_gdbarch_init): Do not set save_dummy_frame_tos.
	* x86-64-tdep.c (x86_64_save_dummy_frame_tos): Delete function.
	(x86_64_push_dummy_call): Return "sp + 16".
	(x86_64_init_abi): Do not set save_dummy_frame_tos.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	save_dummy_frame_tos.
@
text
@d1327 17
d1345 23
a1367 5
/* Return true iff register REGNUM's virtual format is different from
   its raw format.  Note that this definition assumes that the host
   supports IEEE 32-bit floats, since it doesn't say that SSE
   registers need conversion.  Even if we can't find a counterexample,
   this is still sloppy.  */
d1370 1
a1370 1
i386_register_convertible (int regnum)
d1372 8
d1383 2
a1384 2
/* Convert data from raw format for register REGNUM in buffer FROM to
   virtual format with type TYPE in buffer TO.  */
d1387 2
a1388 2
i386_register_convert_to_virtual (int regnum, struct type *type,
				  char *from, char *to)
d1390 2
a1391 1
  gdb_assert (i386_fp_regnum_p (regnum));
d1393 1
a1393 2
  /* We only support floating-point values.  */
  if (TYPE_CODE (type) != TYPE_CODE_FLT)
d1395 15
a1409 4
      warning ("Cannot convert floating-point register value "
	       "to non-floating-point type.");
      memset (to, 0, TYPE_LENGTH (type));
      return;
d1411 3
d1415 10
a1424 3
  /* Convert to TYPE.  This should be a no-op if TYPE is equivalent to
     the extended floating-point format used by the FPU.  */
  convert_typed_floating (from, builtin_type_i387_ext, to, type);
d1427 2
a1428 2
/* Convert data from virtual format with type TYPE in buffer FROM to
   raw format for register REGNUM in buffer TO.  */
d1431 2
a1432 2
i386_register_convert_to_raw (struct type *type, int regnum,
			      const char *from, char *to)
d1434 3
a1436 1
  gdb_assert (i386_fp_regnum_p (regnum));
d1438 15
a1452 2
  /* We only support floating-point values.  */
  if (TYPE_CODE (type) != TYPE_CODE_FLT)
d1454 1
a1454 5
      warning ("Cannot convert non-floating-point type "
	       "to floating-point register value.");
      memset (to, 0, TYPE_LENGTH (type));
      return;
    }
d1456 10
a1465 3
  /* Convert from TYPE.  This should be a no-op if TYPE is equivalent
     to the extended floating-point format used by the FPU.  */
  convert_typed_floating (from, type, to, builtin_type_i387_ext);
d1467 2
a1468 1
     
d1778 3
a1780 3
  set_gdbarch_deprecated_register_convertible (gdbarch, i386_register_convertible);
  set_gdbarch_deprecated_register_convert_to_virtual (gdbarch, i386_register_convert_to_virtual);
  set_gdbarch_deprecated_register_convert_to_raw (gdbarch, i386_register_convert_to_raw);
@


1.153
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_CONVERTIBLE): Deprecate
	REGISTER_CONVERTIBLE.
	(DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL): Same.
	(DEPRECATED_REGISTER_CONVERT_TO_RAW): Same, make "from" constant.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (deprecated_register_convertible_not): Rename
	generic_register_convertible_not.
	* arch-utils.c (deprecated_register_convertible_not): Rename
	generic_register_convertible.
	(legacy_convert_register_p, legacy_register_to_value): Update.
	* sh-tdep.c (sh64_push_arguments): Update.
	* m68klinux-tdep.c (m68k_linux_extract_return_value): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_EXTRACT_RETURN_VALUE): Update.
	* m68klinux-tdep.c (m68k_linux_store_return_value): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Update.
	* arch-utils.c (legacy_value_to_register): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	(rs6000_register_convert_to_raw): Make parameter "from" const.
	* mips-tdep.c (mips_gdbarch_init): Update.
	(mips_register_convert_to_raw): Make  parameter"virt_buf" const.
	* infcmd.c (default_print_registers_info): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_register_convert_to_raw): Make parameter "from" const.
	* i386-tdep.c (i386_gdbarch_init): Update.
	(i386_register_convert_to_raw): Update.
@
text
@d754 1
d906 1
a964 6
static void
i386_save_dummy_frame_tos (CORE_ADDR sp)
{
  generic_save_dummy_frame_tos (sp + 8);
}

d974 1
d1058 10
a1067 1
  return sp;
a1724 1
  set_gdbarch_save_dummy_frame_tos (gdbarch, i386_save_dummy_frame_tos);
@


1.152
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_NUM_ARGS): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (frame_num_args_unknown): Delete both declarations.
	* arch-utils.c (frame_num_args_unknown): Delete function.
	* stack.c (print_args_stub): Use FRAME_NUM_ARGS_P.
	(frame_info): Use FRAME_NUM_ARGS_P.
	* arm-tdep.c (arm_frame_num_args): Delete function.
	(arm_gdbarch_init): Do not set frame_num_args.
	* config/pa/tm-hppa64.h (FRAME_NUM_ARGS): Delete.
	* hppa-tdep.c (hppa_frame_num_args): Delete function.
	(hppa_gdbarch_init): Do not set frame_num_args.
	* config/sparc/tm-sparc.h (FRAME_NUM_ARGS): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	frame_num_args to default frame_num_args_unknown.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d1362 1
a1362 1
			      char *from, char *to)
d1689 3
a1691 4
  set_gdbarch_register_convertible (gdbarch, i386_register_convertible);
  set_gdbarch_register_convert_to_virtual (gdbarch,
					   i386_register_convert_to_virtual);
  set_gdbarch_register_convert_to_raw (gdbarch, i386_register_convert_to_raw);
@


1.151
log
@* gdbarch.sh (function_list): Add FETCH_POINTER_ARGUMENT.
* gdbarch.[ch]: Regenerate.
* hppa-tdep.c (hppa_fetch_pointer_argument): New function.
(hppa_gdbarch_init): Set it in the gdbarch vector.
* i386-tdep.c (i386_fetch_pointer_argument): New
(i386_gdbarch_init): Set it into gdbarch.
* rs6000-tdep.c (rs6000_fetch_pointer_argument): New.
(rs6000_gdbarch_init): Set it in gdbarch.
* sparc-tdep.c (sparc_fetch_pointer_argument): New
(sparc_gdbarch_init): Set it in gdbarch.
@
text
@a1709 1
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
@


1.151.2.1
log
@* i386-tdep.c (I386_EBX_REGNUM, I386_ECX_REGNUM, I386_ESI_REGNUM,
I386_EDI_REGNUM): New defines.
(i386_next_regnum, i386_convert_register_p,
i386_register_to_value, i386_value_to_register): New functions.
(i386_register_convertible, i386_register_convert_to_virtual,
i386_convert_to_raw): Remove functions.
(i386_gdbarch_init): Set convert_register_p, register_to_value and
value_to_register instead of register_convertible,
register_convert_to_virtual and register_convert_to_raw.
@
text
@a1320 17


/* These registers don't have pervasive standard uses.  Move them to
   i386-tdep.h if necessary.  */

#define I386_EBX_REGNUM		3 /* %ebx */
#define I386_ECX_REGNUM		1 /* %ecx */
#define I386_ESI_REGNUM		6 /* %esi */
#define I386_EDI_REGNUM		7 /* %edi */

/* Return the register number of the register allocated by GCC after
   REGNUM, or -1 if there is no such register.  */

static int
i386_next_regnum (int regnum)
{
  /* GCC allocates the registers in the order:
d1322 5
a1326 23
     %eax, %edx, %ecx, %ebx, %esi, %edi, %ebp, %esp, ...

     Since storing a variable in %esp doesn't make any sense we return
     -1 for %ebp and for %esp itself.  */
  static int next_regnum[] =
  {
    I386_EDX_REGNUM,		/* Slot for %eax.  */
    I386_EBX_REGNUM,		/* Slot for %ecx.  */
    I386_ECX_REGNUM,		/* Slot for %edx.  */
    I386_ESI_REGNUM,		/* Slot for %ebx.  */
    -1, -1,			/* Slots for %esp and %ebp.  */
    I386_EDI_REGNUM,		/* Slot for %esi.  */
    I386_EBP_REGNUM		/* Slot for %edi.  */
  };

  if (regnum < sizeof (next_regnum) / sizeof (next_regnum[0]))
    return next_regnum[regnum];

  return -1;
}

/* Return nonzero if a value of type TYPE stored in register REGNUM
   needs any special handling.  */
d1329 1
a1329 1
i386_convert_register_p (int regnum, struct type *type)
a1330 8
  /* Values may be spread across multiple registers.  Most debugging
     formats aren't expressive enough to specify the locations, so
     some heuristics is involved.  Right now we only handle types that
     are exactly 8 bytes long as GCC doesn't seem to put any other
     types into registers.  */
  if (TYPE_LENGTH (type) == 8 && i386_next_regnum (regnum) != -1)
    return 1;

d1334 2
a1335 2
/* Read a value of type TYPE from register REGNUM in frame FRAME, and
   return its contents in TO.  */
d1338 2
a1339 2
i386_register_to_value (struct frame_info *frame, int regnum,
			struct type *type, void *to)
d1341 1
a1341 2
  /* FIXME: kettenis/20030609: What should we do if REGNUM isn't
     available in FRAME (i.e. if it wasn't saved)?  */
d1343 2
a1344 1
  if (i386_fp_regnum_p (regnum))
d1346 4
a1349 15
      char from[I386_MAX_REGISTER_SIZE];

      /* We only support floating-point values.  */
      if (TYPE_CODE (type) != TYPE_CODE_FLT)
	{
	  warning ("Cannot convert floating-point register value "
		   "to non-floating-point type.");
	  return;
	}

      /* Convert to TYPE.  This should be a no-op if TYPE is
	 equivalent to the extended floating-point format used by the
	 FPU.  */
      frame_read_register (frame, regnum, from);
      convert_typed_floating (from, builtin_type_i387_ext, to, type);
a1350 3
  else
    {
      gdb_assert (TYPE_LENGTH (type) == 8);
d1352 3
a1354 10
      /* Read the first part.  */
      gdb_assert (register_size (current_gdbarch, regnum) == 4);
      frame_read_register (frame, regnum, (char *) to + 0);

      /* Read the second part.  */
      regnum = i386_next_regnum (regnum);
      gdb_assert (regnum != -1);
      gdb_assert (register_size (current_gdbarch, regnum));
      frame_read_register (frame, regnum, (char *) to + 4);
    }
d1357 2
a1358 2
/* Write the contents FROM of a value of type TYPE into register
   REGNUM in frame FRAME.  */
d1361 2
a1362 2
i386_value_to_register (struct frame_info *frame, int regnum,
			struct type *type, const void *from)
d1364 4
a1367 1
  if (i386_fp_regnum_p (regnum))
d1369 4
a1372 15
      char to[I386_MAX_REGISTER_SIZE];

      /* We only support floating-point values.  */
      if (TYPE_CODE (type) != TYPE_CODE_FLT)
	{
	  warning ("Cannot convert non-floating-point type "
		   "to floating-point register value.");
	  return;
	}

      /* Convert from TYPE.  This should be a no-op if TYPE is
	 equivalent to the extended floating-point format used by the
	 FPU.  */
      convert_typed_floating (from, type, to, builtin_type_i387_ext);
      put_frame_register (frame, regnum, to);
a1373 3
  else
    {
      gdb_assert (TYPE_LENGTH (type) == 8);
d1375 3
a1377 10
      /* Write the first part.  */
      gdb_assert (register_size (current_gdbarch, regnum) == 4);
      put_frame_register (frame, regnum, (const char *) from + 0);

      /* Write the second part.  */
      regnum = i386_next_regnum (regnum);
      gdb_assert (regnum != -1);
      gdb_assert (register_size (current_gdbarch, regnum) == 4);
      put_frame_register (frame, regnum, (const char *) from + 4);
    }
d1379 1
a1379 1

d1689 4
a1692 3
  set_gdbarch_convert_register_p (gdbarch, i386_convert_register_p);
  set_gdbarch_register_to_value (gdbarch,  i386_register_to_value);
  set_gdbarch_value_to_register (gdbarch, i386_value_to_register);
@


1.150
log
@* i386-tdep.c: Include "dwarf2-frame.h".
(i386_gdbarch_init): Hook in the DWARF CFI frame unwinder.
* Makefile.in (i386-tdep.o): Update dependencies.
@
text
@d1608 11
d1728 3
@


1.149
log
@* i386-tdep.c (i386_sigtramp_frame_p): Only handle frames if we
have a sigcontext_addr handler.
* x86-64-tdep.c (x86_64_sigtramp_frame_p): Assert that we have a
sigcontext_addr handler.
@
text
@d27 1
d1717 4
@


1.148
log
@* i386-tdep.c (i386_register_name): Check for MMX registers first.
Fixes a bug where GDB would print the wrong register names for
targets without SSE.
@
text
@d933 5
@


1.147
log
@From Michal Ludvig  <mludvig@@suse.cz>:
* i386-tdep.h (struct gdbarch_tdep): Add members `sc_reg_offset'
and `sc_num_regs'.
(I386_EAX_REGNUM, I386_EDX_REGNUM, I386_ESP_REGNUM,
I386_EBP_REGNUM, I386_EIP_REGNUM, I386_EFLAGS_REGNUM,
I386_ST0_REGNUM): Move here from...
* i386-tdep.c: ... here.
(I386_NUM_SAVED_REGS): Define to I386_NUM_REGS.
(i386_sigtramp_frame_cache): Use `sc_reg_offset' to find saved
registers if possible.
(i386_gdbarch_init): Initialize TDEP->sc_reg_offset.
* i386bsd-tdep.c (i386bsd_sc_pc_offset, i386bsd_sc_sp_offset):
Remove variables.
(i386bsd_sc_reg_offset): New variable.
(i386bsd_init_abi): Initialize TDEP->sc_reg_offset and
TDEP->sc_num_regs instead of TDEP->sc_pc_offset and
TDEP->sc_sp_offset.
(i386fbsd_sc_reg_offset): New variable.
(i386fbsdaout_init_abi): Initialize TDEP->sc_reg_offset and
TDEP->sc_num_regs.
(i386fbsd4_sc_pc_offset, i386fbsd4_sc_sp_offset): Remove
variables.
(i386fbsd4_sc_reg_offset): New variable.
(i3864bsd4_init_abi): Initialize TDEP->sc_reg_offset and
TDEP->sc_num_regs instead of TDEP->sc_pc_offset and
TDEP->sc_sp_offset.
* i386-linux-tdep.c (i386_linux_sc_reg_offset): New variable.
(i386_linux_init_abi): Set TDEP->sc_reg_offset and TDEP->sc_num_regs.
* i386nbsd-tdep.c (i386nbsd_sc_pc_offset, i386nbsd_sc_sp_offset):
Remove variables.
(i386nbsd_sc_reg_offset): New variable.
(i386nbsd_init_abi): Initialize TDEP->sc_reg_offset and
TDEP->sc_num_regs instead of TDEP->sc_pc_offset and
TDEP->sc_sp_offset.
* i386obsd-tdep.c (i386obsd_sc_pc_offset, i386obsd_sc_sp_offset):
Remove variables.
(i386obsd_sc_reg_offset): New variable.
(i386obsd_init_abi): Initialize TDEP->sc_reg_offset and
TDEP->sc_num_regs instead of TDEP->sc_pc_offset and
TDEP->sc_sp_offset.
* i386bsd-nat.c (_initialize_i386bsd_nat): Adjust for changes in
i386bsd-tdep.c, i386nbsd-tdep.c and i386obsd-tdep.c.  Add check
for frame pointer offset in `struct sigcontext'.
@
text
@d128 3
a132 3

  if (i386_mmx_regnum_p (reg))
    return i386_mmx_names[reg - MM0_REGNUM];
@


1.146
log
@2003-05-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PUSH_DUMMY_CALL): Add "func_addr" parameter.  Rename
	"dummy_addr" to "bp_addr".
	* infcall.c (call_function_by_hand): Pass "funaddr" to
	gdbarch_push_dummy_call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* i386-tdep.c (i386_push_dummy_call): Update.
	* arm-tdep.c (arm_push_dummy_call): Update.
	* d10v-tdep.c (d10v_push_dummy_call): Update.
@
text
@a49 10
/* Register numbers of various important registers.  */

#define I386_EAX_REGNUM		0 /* %eax */
#define I386_EDX_REGNUM		2 /* %edx */
#define I386_ESP_REGNUM		4 /* %esp */
#define I386_EBP_REGNUM		5 /* %ebp */
#define I386_EIP_REGNUM		8 /* %eip */
#define I386_EFLAGS_REGNUM	9 /* %eflags */
#define I386_ST0_REGNUM		16 /* %st(0) */

d241 1
a241 1
#define I386_NUM_SAVED_REGS	9
d877 15
a891 2
  cache->saved_regs[I386_EIP_REGNUM] = addr + tdep->sc_pc_offset;
  cache->saved_regs[I386_ESP_REGNUM] = addr + tdep->sc_sp_offset;
d1627 1
@


1.145
log
@* i386-tdep.h (i386bsd_sigcontext_addr): Remove prototype.
(I386_SIZEOF_GREGS, I386_SIZEOF_FREGS, I386_SIZEOF_XREGS): Remove
defenitions.
(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
* i386-tdep.c: Mark functions that are 64-bit safe as such.
(I386_EAX_REGNUM, I386_EDX_REGNUM, I386_ESP_REGNUM,
I386_EBP_REGNUM, I386_EIP_REGNUM, I386_EFLAGS_REGNUM,
I386_ST0_REGNUM): New defines.
(CODESTREAM_BUFSIZ, codestream_tell, codestream_peek,
codestream_get): Remove define.
(codestream_next_addr, condestream_addr, condestream_buf,
codestream_off, codestream_cnt): Remove variables.
(codestream_fill, codestream_seek, codestream_read): Remove
functions.
(i386_follow_jump): Rewrite to avoid usage of removed codestream
functionality.
(i386_get_frame_setup, i386_frameless_signal_p, i386_frame_chain,
i386_sigtramp_saved_pc, i386_sigtramp_saved_sp,
i386_frame_saved_pc, i386_saved_pc_after_call,
i386_frame_num_args, i386_frame_init_saved_regs,
i386_push_return_address, i386_do_pop_frame, i386_pop_frame,
i386_push_arguments): Remove functions.
(i386_skip_prologue): Rewrite to avoid usage of removed codestream
functionality.  Use i386_analyze_prologue instead of
i386_get_frame_setup.
(I386_NUM_SAVED_REGS): New define.
(struct i386_frame_cache): New structure.
(i386_alloc_frame_cache, i386_analyze_struct_return,
i386_skip_probe, i386_analyze_frame_setup,
i386_analyze_register_saves, i386_analyze_prologue,
i386_unwind_pc, i386_frame_cache, i386_frame_this_id,
i386_frame_prev_register, i386_sigtramp_frame_cache,
i386_sigtramp_frame_this_id, i386_sigtramp_frame_prev_register,
i386_frame_p, i386_sigtramp_frame_p, i386_frame_base_address,
i386_unwind_dummy_id, i386_save_dummy_tos, i386_push_dummy_call):
New functions.
(i386_frame_unwind, i386_sigtramp_frame_unwind, i386_frame_base):
New variables.
(LOW_RETURN_REGNUM, HIGH_RETURN_REGNUM): Define in terms of
I386_EAX_REGNUM and I386_EDX_REGNUM.
(i386_extract_return_value, i386_store_return_value): Use
I386_ST0_REGNUM where appropriate.
(i386_extract_struct_value_address): Rewrite to use extract_address.
(i386_svr4_pc_in_sigtramp): Add comment.
(i386_svr4_sigcontext_addr): Rewrite.
(i386_svr4_init_abi): Adjust TDEP->sc_pc_offset and
TDEP->sc_sp_offset.
(i386_gdbarch_init): Don't set deprecated_init_frame_pc.  Set
sp_regnum, fp_regnum, pc_regnum, ps_regnum and fp0_regnum in terms
of new defines.  Set push_dummy_call, don't set
deprecated_push_arguments, deprecated_push_return_address,
deprecated_pop_frame.  Don't set parm_boundary.  Don't set
deprecated_frame_chain, deprecated_frame_saved_pc,
deprecated_saved_pc_after_call.  Set unwind_dummy_id,
save_dummy_frame_tos, unwind_pc.  Call
frame_unwind_append_predicate and frame_base_set_default.  Don't
set deprecated_dummy_write_pc.  Don't set deprecated_fp_regnum.
Don't set frameless_function_invocation.  Don't set
deprecated_register_bytes, deprecated_register_size,
deprecated_call_dummy_words and deprecated_sizeof_call_dummy.
* i386-linux-tdep.c: Fix formatting in some comments.
(LINUX_SIGTRAMP_INSN0, LINUX_SIGTRAMP_OFFSET0,
LINUX_SIGTRAMP_INSN1, LINUX_SIGTRAMP_OFFSET1,
LINUX_SIGTRAMP_INSN2, LINUX_SIGTRAMP_OFFSET2,
LINUX_RT_SIGTRAMP_INSN0, LINUX_RT_SIGTRAMP_OFFSET0,
LINUX_RT_SIGTRAMP_INSN1, LINUX_RT_SIGTRAMP_OFFSET1): Drop
redundant parentheses.
(I386_LINUX_UCONTEXT_SIGCONTEXT_OFFSET): New define.
(i386_linux_sigcontext_addr): Use it.  Rewrite.
(find_minsym_and_objfile): Change name of second argument.
(skip_gnu_resolver): Renamed from skip_hurd_resolver.  All callers
changed.  Use frame_pc_unwind instead of
DEPRECATED_SAVED_PC_AFTER_CALL.
(i386_linux_init_abi): Don't set deprecated_register_bytes.
* i386bsd-tdep.c (i386bsd_sigcontext_addr): Rewrite.
* i386-nto-tdep.c (i386nto_sigcontext_addr): Adapt for new frame
unwinder.
* i386-cygwin-tdep.c: Don't include "gdbcore.h", "frame.h" and
"dummy-frame.h".
(i386_cygwin_frame_chain_valid, i386_cygwin_frame_chain): Removed.
(_initialize_i386_cygwin_tdep): New prototype.
(i386_cygwin_init_abi): Don't set deprecated_frame_chain and
deprecated_frame_chain_valid.
* i386-sol2-tdep.c (i386_sol2_init_abi): Don't set
TDEP->sigcontext_addr, TDEP->sc_pc_offset and TDEP->sc_sp_offset.
Rely on the SVR4 defaults.
* config/i386/i386sol2.mt (TDEPFILES): Remove i386bsd-tdep.o.
* Makefile.in (i386-tdep.o, i386-cygwin-tdep.o): Update dependencies.
@
text
@d1008 4
a1011 3
i386_push_dummy_call (struct gdbarch *gdbarch, struct regcache *regcache,
		      CORE_ADDR dummy_addr, int nargs, struct value **args,
		      CORE_ADDR sp, int struct_return, CORE_ADDR struct_addr)
d1042 1
a1042 1
  store_unsigned_integer (buf, 4, dummy_addr);
@


1.144
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@d24 5
a28 1
#include "gdb_string.h"
d30 2
d33 1
d36 3
a38 2
#include "target.h"
#include "floatformat.h"
d41 1
a41 5
#include "gdbcmd.h"
#include "command.h"
#include "arch-utils.h"
#include "regcache.h"
#include "doublest.h"
d43 1
d45 1
a45 3
#include "reggroups.h"
#include "dummy-frame.h"
#include "osabi.h"
d50 10
d156 1
a156 1
      /* General registers.  */
d189 1
a189 1
      /* General registers.  */
d219 1
d221 5
a225 41
/* Stdio style buffering was used to minimize calls to ptrace, but
   this buffering did not take into account that the code section
   being accessed may not be an even number of buffers long (even if
   the buffer is only sizeof(int) long).  In cases where the code
   section size happened to be a non-integral number of buffers long,
   attempting to read the last buffer would fail.  Simply using
   target_read_memory and ignoring errors, rather than read_memory, is
   not the correct solution, since legitimate access errors would then
   be totally ignored.  To properly handle this situation and continue
   to use buffering would require that this code be able to determine
   the minimum code section size granularity (not the alignment of the
   section itself, since the actual failing case that pointed out this
   problem had a section alignment of 4 but was not a multiple of 4
   bytes long), on a target by target basis, and then adjust it's
   buffer size accordingly.  This is messy, but potentially feasible.
   It probably needs the bfd library's help and support.  For now, the
   buffer size is set to 1.  (FIXME -fnf) */

#define CODESTREAM_BUFSIZ 1	/* Was sizeof(int), see note above.  */
static CORE_ADDR codestream_next_addr;
static CORE_ADDR codestream_addr;
static unsigned char codestream_buf[CODESTREAM_BUFSIZ];
static int codestream_off;
static int codestream_cnt;

#define codestream_tell() (codestream_addr + codestream_off)
#define codestream_peek() \
  (codestream_cnt == 0 ? \
   codestream_fill(1) : codestream_buf[codestream_off])
#define codestream_get() \
  (codestream_cnt-- == 0 ? \
   codestream_fill(0) : codestream_buf[codestream_off++])

static unsigned char
codestream_fill (int peek_flag)
{
  codestream_addr = codestream_next_addr;
  codestream_next_addr += CODESTREAM_BUFSIZ;
  codestream_off = 0;
  codestream_cnt = CODESTREAM_BUFSIZ;
  read_memory (codestream_addr, (char *) codestream_buf, CODESTREAM_BUFSIZ);
d227 2
a228 5
  if (peek_flag)
    return (codestream_peek ());
  else
    return (codestream_get ());
}
d230 4
a233 2
static void
codestream_seek (CORE_ADDR place)
d235 4
a238 6
  codestream_next_addr = place / CODESTREAM_BUFSIZ;
  codestream_next_addr *= CODESTREAM_BUFSIZ;
  codestream_cnt = 0;
  codestream_fill (1);
  while (codestream_tell () != place)
    codestream_get ();
d240 30
d271 2
a272 2
static void
codestream_read (unsigned char *buf, int count)
d274 1
a274 1
  unsigned char *p;
d276 19
a294 3
  p = buf;
  for (i = 0; i < count; i++)
    *p++ = codestream_get ();
a295 1

d297 2
a298 1
/* If the next instruction is a jump, move to its target.  */
d300 2
a301 2
static void
i386_follow_jump (void)
d303 3
a305 7
  unsigned char buf[4];
  long delta;

  int data16;
  CORE_ADDR pos;

  pos = codestream_tell ();
d307 2
a308 2
  data16 = 0;
  if (codestream_peek () == 0x66)
a309 1
      codestream_get ();
d311 1
d314 1
a314 1
  switch (codestream_get ())
d320 1
a320 2
	  codestream_read (buf, 2);
	  delta = extract_signed_integer (buf, 2);
d324 1
a324 1
	  pos += delta + 4;
d328 1
a328 2
	  codestream_read (buf, 4);
	  delta = extract_signed_integer (buf, 4);
d330 2
a331 1
	  pos += delta + 5;
d336 1
a336 3
      codestream_read (buf, 1);
      /* Sign-extend it.  */
      delta = extract_signed_integer (buf, 1);
d338 1
a338 1
      pos += delta + 2;
d341 2
a342 1
  codestream_seek (pos);
d345 5
a349 2
/* Find & return the amount a local space allocated, and advance the
   codestream to the first register push (if any).
d351 5
a355 2
   If the entry sequence doesn't make sense, return -1, and leave
   codestream pointer at a random spot.  */
d357 11
a367 3
static long
i386_get_frame_setup (CORE_ADDR pc)
{
d370 2
a371 1
  codestream_seek (pc);
d373 1
a373 1
  i386_follow_jump ();
d375 2
a376 1
  op = codestream_get ();
d378 5
a382 1
  if (op == 0x58)		/* popl %eax */
d384 3
a386 22
      /* This function must start with

	    popl %eax             0x58
            xchgl %eax, (%esp)    0x87 0x04 0x24
         or xchgl %eax, 0(%esp)   0x87 0x44 0x24 0x00

	 (the System V compiler puts out the second `xchg'
	 instruction, and the assembler doesn't try to optimize it, so
	 the 'sib' form gets generated).  This sequence is used to get
	 the address of the return buffer for a function that returns
	 a structure.  */
      int pos;
      unsigned char buf[4];
      static unsigned char proto1[3] = { 0x87, 0x04, 0x24 };
      static unsigned char proto2[4] = { 0x87, 0x44, 0x24, 0x00 };

      pos = codestream_tell ();
      codestream_read (buf, 4);
      if (memcmp (buf, proto1, 3) == 0)
	pos += 3;
      else if (memcmp (buf, proto2, 4) == 0)
	pos += 4;
d388 4
a391 2
      codestream_seek (pos);
      op = codestream_get ();	/* Update next opcode.  */
d393 6
d400 4
a403 3
  if (op == 0x68 || op == 0x6a)
    {
      /* This function may start with
d405 3
a407 3
            pushl constant
            call _probe
	    addl $4, %esp
d409 7
a415 1
	 followed by
d417 1
a417 1
            pushl %ebp
d419 3
a421 3
	 etc.  */
      int pos;
      unsigned char buf[8];
d423 2
a424 3
      /* Skip past the `pushl' instruction; it has either a one-byte 
         or a four-byte operand, depending on the opcode.  */
      pos = codestream_tell ();
d426 1
a426 1
	pos += 4;
d428 1
a428 2
	pos += 1;
      codestream_seek (pos);
d430 3
a432 3
      /* Read the following 8 bytes, which should be "call _probe" (6
         bytes) followed by "addl $4,%esp" (2 bytes).  */
      codestream_read (buf, sizeof (buf));
d434 1
a434 3
	pos += sizeof (buf);
      codestream_seek (pos);
      op = codestream_get ();	/* Update next opcode.  */
d437 20
d459 12
a470 2
      /* Check for "movl %esp, %ebp" -- can be written in two ways.  */
      switch (codestream_get ())
d473 2
a474 2
	  if (codestream_get () != 0xec)
	    return -1;
d477 2
a478 2
	  if (codestream_get () != 0xe5)
	    return -1;
d481 1
a481 1
	  return -1;
d483 9
d494 1
a494 1
           subl $XXX, %esp
d498 1
a498 1
      op = codestream_peek ();
d502 1
a502 2
	  codestream_get ();
	  if (codestream_get () != 0xec)
d504 6
a509 7
	    {
	      codestream_seek (codestream_tell () - 2);
	      return 0;
	    }
	  /* `subl' with signed byte immediate (though it wouldn't
	     make sense to be negative).  */
	  return (codestream_get ());
a512 1
	  char buf[4];
d514 1
a514 2
	  codestream_get ();
	  if (codestream_get () != 0xec)
d516 2
a517 4
	    {
	      codestream_seek (codestream_tell () - 2);
	      return 0;
	    }
d519 2
a520 2
	  codestream_read ((unsigned char *) buf, 4);
	  return extract_signed_integer (buf, 4);
d524 2
a525 1
	  return 0;
d528 1
a528 1
  else if (op == 0xc8)
d530 3
a532 35
      char buf[2];
      /* `enter' with 16 bit unsigned immediate.  */
      codestream_read ((unsigned char *) buf, 2);
      codestream_get ();	/* Flush final byte of enter instruction.  */
      return extract_unsigned_integer (buf, 2);
    }
  return (-1);
}

/* Signal trampolines don't have a meaningful frame.  The frame
   pointer value we use is actually the frame pointer of the calling
   frame -- that is, the frame which was in progress when the signal
   trampoline was entered.  GDB mostly treats this frame pointer value
   as a magic cookie.  We detect the case of a signal trampoline by
   testing for get_frame_type() == SIGTRAMP_FRAME, which is set based
   on PC_IN_SIGTRAMP.

   When a signal trampoline is invoked from a frameless function, we
   essentially have two frameless functions in a row.  In this case,
   we use the same magic cookie for three frames in a row.  We detect
   this case by seeing whether the next frame is a SIGTRAMP_FRAME,
   and, if it does, checking whether the current frame is actually
   frameless.  In this case, we need to get the PC by looking at the
   SP register value stored in the signal context.

   This should work in most cases except in horrible situations where
   a signal occurs just as we enter a function but before the frame
   has been set up.  Incidentally, that's just what happens when we
   call a function from GDB with a signal pending (there's a test in
   the testsuite that makes this happen).  Therefore we pretend that
   we have a frameless function if we're stopped at the start of a
   function.  */

/* Return non-zero if we're dealing with a frameless signal, that is,
   a signal trampoline invoked from a frameless function.  */
d534 1
a534 7
int
i386_frameless_signal_p (struct frame_info *frame)
{
  return (get_next_frame (frame)
	  && get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME
	  && (frameless_look_for_prologue (frame)
	      || get_frame_pc (frame) == get_frame_func (frame)));
d537 4
a540 3
/* Return the chain-pointer for FRAME.  In the case of the i386, the
   frame's nominal address is the address of a 4-byte word containing
   the calling frame's address.  */
d543 2
a544 1
i386_frame_chain (struct frame_info *frame)
d546 1
a546 58
  if (pc_in_dummy_frame (get_frame_pc (frame)))
    return get_frame_base (frame);

  if (get_frame_type (frame) == SIGTRAMP_FRAME
      || i386_frameless_signal_p (frame))
    return get_frame_base (frame);

  if (! inside_entry_file (get_frame_pc (frame)))
    return read_memory_unsigned_integer (get_frame_base (frame), 4);

  return 0;
}

/* Determine whether the function invocation represented by FRAME does
   not have a from on the stack associated with it.  If it does not,
   return non-zero, otherwise return zero.  */

static int
i386_frameless_function_invocation (struct frame_info *frame)
{
  if (get_frame_type (frame) == SIGTRAMP_FRAME)
    return 0;

  return frameless_look_for_prologue (frame);
}

/* Assuming FRAME is for a sigtramp routine, return the saved program
   counter.  */

static CORE_ADDR
i386_sigtramp_saved_pc (struct frame_info *frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  CORE_ADDR addr;

  addr = tdep->sigcontext_addr (frame);
  return read_memory_unsigned_integer (addr + tdep->sc_pc_offset, 4);
}

/* Assuming FRAME is for a sigtramp routine, return the saved stack
   pointer.  */

static CORE_ADDR
i386_sigtramp_saved_sp (struct frame_info *frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  CORE_ADDR addr;

  addr = tdep->sigcontext_addr (frame);
  return read_memory_unsigned_integer (addr + tdep->sc_sp_offset, 4);
}

/* Return the saved program counter for FRAME.  */

static CORE_ADDR
i386_frame_saved_pc (struct frame_info *frame)
{
  if (pc_in_dummy_frame (get_frame_pc (frame)))
d548 3
a550 1
      ULONGEST pc;
d552 6
a557 3
      frame_unwind_unsigned_register (frame, PC_REGNUM, &pc);
      return pc;
    }
d559 4
a562 7
  if (get_frame_type (frame) == SIGTRAMP_FRAME)
    return i386_sigtramp_saved_pc (frame);

  if (i386_frameless_signal_p (frame))
    {
      CORE_ADDR sp = i386_sigtramp_saved_sp (get_next_frame (frame));
      return read_memory_unsigned_integer (sp, 4);
d565 1
a565 1
  return read_memory_unsigned_integer (get_frame_base (frame) + 4, 4);
d568 3
a570 10
/* Immediately after a function call, return the saved pc.  */

static CORE_ADDR
i386_saved_pc_after_call (struct frame_info *frame)
{
  if (get_frame_type (frame) == SIGTRAMP_FRAME)
    return i386_sigtramp_saved_pc (frame);

  return read_memory_unsigned_integer (read_register (SP_REGNUM), 4);
}
a571 3
/* Parse the first few instructions the function to see what registers
   were stored.
   
d595 3
a597 2
static void
i386_frame_init_saved_regs (struct frame_info *fip)
d599 5
a603 35
  long locals = -1;
  unsigned char op;
  CORE_ADDR addr;
  CORE_ADDR pc;
  int i;

  if (get_frame_saved_regs (fip))
    return;

  frame_saved_regs_zalloc (fip);

  pc = get_frame_func (fip);
  if (pc != 0)
    locals = i386_get_frame_setup (pc);

  if (locals >= 0)
    {
      addr = get_frame_base (fip) - 4 - locals;
      for (i = 0; i < 8; i++)
	{
	  op = codestream_get ();
	  if (op < 0x50 || op > 0x57)
	    break;
#ifdef I386_REGNO_TO_SYMMETRY
	  /* Dynix uses different internal numbering.  Ick.  */
	  get_frame_saved_regs (fip)[I386_REGNO_TO_SYMMETRY (op - 0x50)] = addr;
#else
	  get_frame_saved_regs (fip)[op - 0x50] = addr;
#endif
	  addr -= 4;
	}
    }

  get_frame_saved_regs (fip)[PC_REGNUM] = get_frame_base (fip) + 4;
  get_frame_saved_regs (fip)[DEPRECATED_FP_REGNUM] = get_frame_base (fip);
d609 1
a609 1
i386_skip_prologue (CORE_ADDR pc)
d611 7
a619 5
  static unsigned char pic_pat[6] =
  { 0xe8, 0, 0, 0, 0,		/* call   0x0 */
    0x5b,			/* popl   %ebx */
  };
  CORE_ADDR pos;
d621 4
a624 2
  if (i386_get_frame_setup (pc) < 0)
    return (pc);
d626 1
a626 12
  /* Found valid frame setup -- codestream now points to start of push
     instructions for saving registers.  */

  /* Skip over register saves.  */
  for (i = 0; i < 8; i++)
    {
      op = codestream_peek ();
      /* Break if not `pushl' instrunction.  */
      if (op < 0x50 || op > 0x57)
	break;
      codestream_get ();
    }
d630 2
a631 2
     %ebx
     
a640 1
  pos = codestream_tell ();
d643 1
a643 1
      op = codestream_get ();
d649 3
a651 2
      unsigned char buf[4];
      long delta = 6;
a652 1
      op = codestream_get ();
d655 2
a656 1
	  op = codestream_get ();
d658 1
a658 4
	    {
	      delta += 3;
	      codestream_read (buf, 1);
	    }
d660 1
a660 4
	    {
	      delta += 6;
	      codestream_read (buf, 4);
	    }
d662 3
a664 2
	    delta = -1;
	  op = codestream_get ();
d666 1
d668 2
a669 1
      if (delta > 0 && op == 0x81 && codestream_get () == 0xc3)
d671 1
a671 1
	  pos += delta + 6;
a673 3
  codestream_seek (pos);

  i386_follow_jump ();
d675 1
a675 1
  return (codestream_tell ());
d678 1
a678 5
/* Use the program counter to determine the contents and size of a
   breakpoint instruction.  Return a pointer to a string of bytes that
   encode a breakpoint instruction, store the length of the string in
   *LEN and optionally adjust *PC to point to the correct memory
   location for inserting the breakpoint.
d680 2
a681 5
   On the i386 we have a single breakpoint that fits in a single byte
   and can be inserted anywhere.  */
   
static const unsigned char *
i386_breakpoint_from_pc (CORE_ADDR *pc, int *len)
d683 4
a686 4
  static unsigned char break_insn[] = { 0xcc };	/* int 3 */
  
  *len = sizeof (break_insn);
  return break_insn;
d688 1
d690 1
a690 2
/* Push the return address (pointing to the call dummy) onto the stack
   and return the new value for the stack pointer.  */
d692 2
a693 2
static CORE_ADDR
i386_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
d695 1
d697 52
d750 1
a750 3
  store_unsigned_integer (buf, 4, CALL_DUMMY_ADDRESS ());
  write_memory (sp - 4, buf, 4);
  return sp - 4;
d754 2
a755 1
i386_do_pop_frame (struct frame_info *frame)
d757 63
a819 3
  CORE_ADDR fp;
  int regnum;
  char regbuf[I386_MAX_REGISTER_SIZE];
d821 13
a833 2
  fp = get_frame_base (frame);
  i386_frame_init_saved_regs (frame);
d835 1
a835 1
  for (regnum = 0; regnum < NUM_REGS; regnum++)
d837 5
a841 3
      CORE_ADDR addr;
      addr = get_frame_saved_regs (frame)[regnum];
      if (addr)
d843 3
a845 2
	  read_memory (addr, regbuf, REGISTER_RAW_SIZE (regnum));
	  deprecated_write_register_gen (regnum, regbuf);
d847 1
d849 53
a901 4
  write_register (DEPRECATED_FP_REGNUM, read_memory_integer (fp, 4));
  write_register (PC_REGNUM, read_memory_integer (fp + 4, 4));
  write_register (SP_REGNUM, fp + 8);
  flush_cached_frames ();
d905 5
a909 1
i386_pop_frame (void)
d911 59
a969 1
  generic_pop_current_frame (i386_do_pop_frame);
d977 3
a979 1
   success.  */
d1008 3
a1010 2
i386_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		     int struct_return, CORE_ADDR struct_addr)
d1012 20
a1031 2
  sp = legacy_push_arguments (nargs, args, sp, struct_return, struct_addr);
  
a1033 2
      char buf[4];

d1039 12
d1057 2
a1058 2
#define LOW_RETURN_REGNUM 0	/* %eax */
#define HIGH_RETURN_REGNUM 2	/* %edx */
d1092 1
a1092 1
      regcache_raw_read (regcache, FP0_REGNUM, buf);
d1154 1
a1154 1
      regcache_raw_write (regcache, FP0_REGNUM, buf);
d1195 1
a1195 1
  ULONGEST addr;
d1197 2
a1198 2
  regcache_raw_read_unsigned (regcache, LOW_RETURN_REGNUM, &addr);
  return addr;
d1240 2
a1241 1
  if (regnum == PC_REGNUM || regnum == DEPRECATED_FP_REGNUM || regnum == SP_REGNUM)
d1257 1
a1257 1
   the MMX registers need to be mapped onto floating-point registers.  */
d1458 2
d1465 3
a1467 2
/* Get address of the pushed ucontext (sigcontext) on the stack for
   all three variants of SVR4 sigtramps.  */
d1470 1
a1470 1
i386_svr4_sigcontext_addr (struct frame_info *frame)
d1472 2
a1473 13
  int sigcontext_offset = -1;
  char *name = NULL;

  find_pc_partial_function (get_frame_pc (frame), &name, NULL, NULL);
  if (name)
    {
      if (strcmp (name, "_sigreturn") == 0)
	sigcontext_offset = 132;
      else if (strcmp (name, "_sigacthandler") == 0)
	sigcontext_offset = 80;
      else if (strcmp (name, "sigvechandler") == 0)
	sigcontext_offset = 120;
    }
d1475 2
a1476 1
  gdb_assert (sigcontext_offset != -1);
d1478 1
a1478 3
  if (get_next_frame (frame))
    return get_frame_base (get_next_frame (frame)) + sigcontext_offset;
  return read_register (SP_REGNUM) + sigcontext_offset;
d1517 2
a1518 2
  tdep->sc_pc_offset = 14 * 4;
  tdep->sc_sp_offset = 7 * 4;
d1582 1
d1593 1
d1596 1
a1597 1

a1612 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);

d1637 2
a1638 2
  /* NOTE: tm-i386aix.h, tm-i386bsd.h, tm-i386os9k.h, tm-ptx.h,
     tm-symmetry.h currently override this.  Sigh.  */
d1640 2
d1643 5
a1647 5
  set_gdbarch_sp_regnum (gdbarch, 4); /* %esp */
  set_gdbarch_deprecated_fp_regnum (gdbarch, 5); /* %ebp */
  set_gdbarch_pc_regnum (gdbarch, 8); /* %eip */
  set_gdbarch_ps_regnum (gdbarch, 9); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, 16);	/* %st(0) */
a1659 5
  set_gdbarch_register_name (gdbarch, i386_register_name);
  set_gdbarch_deprecated_register_size (gdbarch, 4);
  set_gdbarch_deprecated_register_bytes (gdbarch, I386_SIZEOF_GREGS + I386_SIZEOF_FREGS);
  set_gdbarch_register_type (gdbarch, i386_register_type);

d1665 1
a1665 2
  set_gdbarch_deprecated_call_dummy_words (gdbarch, NULL);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, 0);
a1671 5
  /* "An argument's size is increased, if necessary, to make it a
     multiple of [32-bit] words.  This may require tail padding,
     depending on the size of the argument" -- from the x86 ABI.  */
  set_gdbarch_parm_boundary (gdbarch, 32);

a1672 3
  set_gdbarch_deprecated_push_arguments (gdbarch, i386_push_arguments);
  set_gdbarch_deprecated_push_return_address (gdbarch, i386_push_return_address);
  set_gdbarch_deprecated_pop_frame (gdbarch, i386_pop_frame);
a1677 1
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, i386_frame_init_saved_regs);
a1686 5
  /* The following redefines make backtracing through sigtramp work.
     They manufacture a fake sigtramp frame and obtain the saved pc in
     sigtramp from the sigcontext structure which is pushed by the
     kernel on the user stack, along with a pointer to it.  */

a1687 5
  set_gdbarch_frameless_function_invocation (gdbarch,
                                           i386_frameless_function_invocation);
  set_gdbarch_deprecated_frame_chain (gdbarch, i386_frame_chain);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, i386_frame_saved_pc);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, i386_saved_pc_after_call);
d1698 5
d1707 1
a1707 2
  /* Should be using push_dummy_call.  */
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
d1711 3
@


1.143
log
@2003-05-13  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (store_address): Delete declaration.
	findvar.c (store_address): Delete function.
	* arm-tdep.c (arm_push_dummy_call): Replace store_address with
	store_unsigned_integer.
	* xstormy16-tdep.c (xstormy16_address_to_pointer): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	* sparc-tdep.c (sparc_get_saved_register): Ditto.
	* sh-tdep.c (sh64_get_saved_register): Ditto.
	* rs6000-tdep.c (rs6000_push_arguments): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_arguments): Ditto.
	* mips-tdep.c (mips_eabi_push_arguments): Ditto.
	(mips_get_saved_register): Ditto.
	* ia64-tdep.c (ia64_get_saved_register): Ditto.
	(find_func_descr, ia64_push_arguments): Ditto.
	* i386-tdep.c (i386_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	* frv-tdep.c (frv_push_arguments): Ditto.
	* frame.c (legacy_saved_regs_prev_register): Ditto.
	(deprecated_generic_get_saved_register): Ditto.
	* findvar.c (unsigned_address_to_pointer): Ditto.
	* dwarf2read.c (dwarf2_const_value): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_push_arguments): Ditto.
@
text
@d1490 1
a1490 1
  set_gdbarch_register_bytes (gdbarch, I386_SIZEOF_GREGS + I386_SIZEOF_FREGS);
@


1.142
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@d867 1
a867 1
      store_address (buf, 4, struct_addr);
@


1.142.4.1
log
@Snap const char * mess.
@
text
@d867 1
a867 1
      store_unsigned_integer (buf, 4, struct_addr);
@


1.141
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d1100 1
a1100 1
      char *mmx_buf = alloca (MAX_REGISTER_RAW_SIZE);
d1117 1
a1117 1
      char *mmx_buf = alloca (MAX_REGISTER_RAW_SIZE);
@


1.140
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d1489 1
a1489 1
  set_gdbarch_register_size (gdbarch, 4);
d1498 2
a1499 2
  set_gdbarch_call_dummy_words (gdbarch, NULL);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, 0);
@


1.139
log
@2003-04-21  Andrew Cagney  <cagney@@redhat.com>

	* i386-tdep.c (i386_gdbarch_init): Replace "mmx_num_regs" with
	"i386_num_mmx_regs".
@
text
@d672 1
a672 1
  get_frame_saved_regs (fip)[FP_REGNUM] = get_frame_base (fip);
d811 1
a811 1
  write_register (FP_REGNUM, read_memory_integer (fp, 4));
d1060 1
a1060 1
  if (regnum == PC_REGNUM || regnum == FP_REGNUM || regnum == SP_REGNUM)
d1472 1
a1472 1
  set_gdbarch_fp_regnum (gdbarch, 5); /* %ebp */
@


1.138
log
@* i386-tdep.c (i386_num_register_names): New variable.
(i386_num_mmx_regs): Renamed from mmx_num_regs.
(MM0_REGNUM): Remove redundant parentheses in define.
(i386_mmx_regnum_p): Use i386_mmx_regnum instead of mmx_num_regs.
(i386_fp_regnum_p, i386_fpc_regnum_p, i386_sse_regnum_p,
i386_mxcsr_regnum_p): Remove redundant parentheses.
(i386_register_name): Use i386_num_register_names.
@
text
@d1545 1
a1545 1
  set_gdbarch_num_pseudo_regs (gdbarch, mmx_num_regs);
@


1.138.2.1
log
@* i386-tdep.h (i386bsd_sigcontext_addr): Remove prototype.

* i386-tdep.c: Mark functions that are 64-bit safe as such.
(I386_EAX_REGNUM, I386_EDX_REGNUM, I386_ESP_REGNUM,
I386_EBP_REGNUM, I386_EIP_REGNUM, I386_EFLAGS_REGNUM,
I386_ST0_REGNUM): New defines.
(CODESTREAM_BUFSIZ, codestream_tell, codestream_peek,
codestream_get): Remove define.
(codestream_next_addr, condestream_addr, condestream_buf,
codestream_off, codestream_cnt): Remove variables.
(codestream_fill, codestream_seek, codestream_read): Remove
functions.
(i386_follow_jump): Rewrite to avoid usage of removed codestream
functionality.
(i386_get_frame_setup, i386_frameless_signal_p, i386_frame_chain,
i386_sigtramp_saved_pc, i386_sigtramp_saved_sp,
i386_frame_saved_pc, i386_saved_pc_after_call,
i386_frame_num_args, i386_frame_init_saved_regs,
i386_push_return_address, i386_do_pop_frame, i386_pop_frame,
i386_push_arguments): Remove functions.
(i386_skip_prologue): Rewrite to avoid usage of removed codestream
functionality.  Use i386_analyze_prologue instead of
i386_get_frame_setup.
(I386_NUM_SAVED_REGS): New define.
(struct i386_frame_cache): New structure.
(i386_alloc_frame_cache, i386_analyze_struct_return,
i386_skip_probe, i386_analyze_frame_setup,
i386_analyze_register_saves, i386_analyze_prologue,
i386_unwind_pc, i386_frame_cache, i386_frame_this_id,
i386_frame_prev_register, i386_sigtramp_frame_cache,
i386_sigtramp_frame_this_id, i386_sigtramp_frame_prev_register,
i386_frame_p, i386_frame_base_address, i386_unwind_dummy_id,
i386_save_dummy_tos, i386_push_dummy_call): New functions.
(i386_frame_unwind, i386_sigtramp_frame_unwind, i386_frame_base):
New variables.
(LOW_RETURN_REGNUM, HIGH_RETURN_REGNUM): Define in terms of
I386_EAX_REGNUM and I386_EDX_REGNUM.
(i386_extract_return_value, i386_store_return_value): Use
I386_ST0_REGNUM where appropriate.
(i386_extract_struct_value_address): Rewrite to use extract_address.
(i386_svr4_pc_in_sigtramp): Add comment.
(i386_svr4_sigcontext_addr): Rewrite.
(i386_svr4_init_abi): Adjust TDEP->sc_pc_offset and
TDEP->sc_sp_offset.
(i386_gdbarch_init): Don't set deprecated_init_frame_pc.  Set
sp_regnum, fp_regnum, pc_regnum, ps_regnum and fp0_regnum in terms
of new defines.  Set push_dummy_call, don't set
deprecated_push_arguments, deprecated_push_return_address,
deprecated_pop_frame.  Don't set parm_boundary.  Don't set
deprecated_frame_chain, deprecated_frame_saved_pc,
deprecated_saved_pc_after_call.  Set unwind_dummy_id,
save_dummy_frame_tos, unwind_pc.  Call
frame_unwind_append_predicate and frame_base_set_default.
Don't set deprecated_dummy_write_pc.

* i386-linux-tdep.c (i386_linux_sigcontext_addr): Rewrite.
(skip_gnu_resolver): Renamed from skip_hurd_resolver.  All callers
changed.  Use frame_pc_unwind instead of
DEPRECATED_SAVED_PC_AFTER_CALL.

* i386bsd-tdep.c (i386bsd_sigcontext_addr): Rewrite.

* i386-sol2-tdep.c (i386_sol2_init_abi): Don't set
TDEP->sigcontext_addr, TDEP->sc_pc_offset and TDEP->sc_sp_offset.
Rely on the SVR4 defaults.

* config/i386/i386sol2.mt (TDEPFILES): Remove i386bsd-tdep.o.
@
text
@a25 2
#include "frame-base.h"
#include "frame-unwind.h"
a46 10
/* Register numbers of various important registers.  */

#define I386_EAX_REGNUM		0 /* %eax */
#define I386_EDX_REGNUM		2 /* %edx */
#define I386_ESP_REGNUM		4 /* %esp */
#define I386_EBP_REGNUM		5 /* %ebp */
#define I386_EIP_REGNUM		8 /* %eip */
#define I386_EFLAGS_REGNUM	9 /* %eflags */
#define I386_ST0_REGNUM		16 /* %st(0) */

d143 1
a143 1
      /* General-purpose registers.  */
d176 1
a176 1
      /* General-purpose registers.  */
a205 1

d207 47
a253 3
/* Determine whether the function invocation represented by FRAME does
   not have a frame on the stack associated with it.  If it does not,
   return non-zero, otherwise return zero.  */
d255 2
a256 2
static int
i386_frameless_function_invocation (struct frame_info *frame)
d258 6
a263 4
  if (get_frame_type (frame) == SIGTRAMP_FRAME)
    return 0;

  return frameless_look_for_prologue (frame);
d266 2
a267 13
/* Use the program counter to determine the contents and size of a
   breakpoint instruction.  Return a pointer to a string of bytes that
   encode a breakpoint instruction, store the length of the string in
   *LEN and optionally adjust *PC to point to the correct memory
   location for inserting the breakpoint.

   On the i386 we have a single breakpoint that fits in a single byte
   and can be inserted anywhere.

   This function is 64-bit safe.  */
   
static const unsigned char *
i386_breakpoint_from_pc (CORE_ADDR *pc, int *len)
d269 5
a273 4
  static unsigned char break_insn[] = { 0xcc };	/* int 3 */
  
  *len = sizeof (break_insn);
  return break_insn;
a275 3
#ifdef I386_REGNO_TO_SYMMETRY
#error "The Sequent Symmetry is no longer supported."
#endif
d277 1
a277 14
/* According to the System V ABI, the registers %ebp, %ebx, %edi, %esi
   and %esp "belong" to the calling function.  Therefore these
   registers should be saved if they're going to be modified.  */

/* The maximum number of saved registers.  This should include all
   registers mentioned above, and %eip.  */
#define I386_NUM_SAVED_REGS	9

struct i386_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  CORE_ADDR sp_offset;
  CORE_ADDR pc;
d279 2
a280 13
  /* Saved registers.  */
  CORE_ADDR saved_regs[I386_NUM_SAVED_REGS];
  CORE_ADDR saved_sp;
  int pc_in_eax;

  /* Stack space reserved for local variables.  */
  long locals;
};

/* Allocate and initialize a frame cache.  */

static struct i386_frame_cache *
i386_alloc_frame_cache (void)
d282 2
a283 9
  struct i386_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct i386_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->sp_offset = -4;
  cache->pc = 0;
d285 2
a286 12
  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %ebp is supposed to be stored).  */
  for (i = 0; i < I386_NUM_SAVED_REGS; i++)
    cache->saved_regs[i] = -1;
  cache->saved_sp = 0;
  cache->pc_in_eax = 0;

  /* Frameless until proven otherwise.  */
  cache->locals = -1;

  return cache;
}
d288 1
a288 2
/* If the instruction at PC is a jump, return the address of its
   target.  Otherwise, return PC.  */
d290 2
a291 9
static CORE_ADDR
i386_follow_jump (CORE_ADDR pc)
{
  unsigned char op;
  long delta = 0;
  int data16 = 0;

  op = read_memory_unsigned_integer (pc, 1);
  if (op == 0x66)
d293 1
a294 1
      op = read_memory_unsigned_integer (pc + 1, 1);
d297 1
a297 1
  switch (op)
d303 2
a304 1
	  delta = read_memory_integer (pc + 2, 2);
d308 1
a308 1
	  delta += 4;
d312 2
a313 1
	  delta = read_memory_integer (pc + 1, 4);
d315 1
a315 2
	  /* Include the size of the jmp instruction.  */
	  delta += 5;
d320 3
a322 1
      delta = read_memory_integer (pc + data16 + 1, 1);
d324 1
a324 1
      delta += data16 + 2;
d327 2
d330 2
a331 2
  return pc + delta;
}
d333 2
a334 5
/* Check whether PC points at a prologue for a function returning a
   structure or union.  If so, it updates CACHE and returns the
   address of the first instruction after the code sequence that
   removes the "hidden" argument from the stack or CURRENT_PC,
   whichever is smaller.  Otherwise, return PC.  */
d336 2
a337 3
static CORE_ADDR
i386_analyze_struct_return (CORE_ADDR pc, CORE_ADDR current_pc,
			    struct i386_frame_cache *cache)
a338 14
  /* Functions that return a structure or union start with:

         popl %eax             0x58
         xchgl %eax, (%esp)    0x87 0x04 0x24
      or xchgl %eax, 0(%esp)   0x87 0x44 0x24 0x00

      (the System V compiler puts out the second `xchg'
      instruction, and the assembler doesn't try to optimize it, so
      the 'sib' form gets generated).  This sequence is used to get
      the address of the return buffer for a function that returns
      a structure.  */
  static unsigned char proto1[3] = { 0x87, 0x04, 0x24 };
  static unsigned char proto2[4] = { 0x87, 0x44, 0x24, 0x00 };
  unsigned char buf[4];
d341 1
a341 2
  if (current_pc <= pc)
    return pc;
d343 1
a343 1
  op = read_memory_unsigned_integer (pc, 1);
d345 1
a345 2
  if (op != 0x58)		/* popl %eax */
    return pc;
d347 24
a370 3
  read_memory (pc + 1, buf, 4);
  if (memcmp (buf, proto1, 3) != 0 && memcmp (buf, proto2, 4) != 0)
    return pc;
d372 2
a373 4
  if (current_pc == pc)
    {
      cache->sp_offset += 4;
      return current_pc;
d376 1
a376 1
  if (current_pc == pc + 1)
d378 1
a378 9
      cache->pc_in_eax = 1;
      return current_pc;
    }
  
  if (buf[1] == proto1[1])
    return pc + 4;
  else
    return pc + 5;
}
d380 3
a382 8
static CORE_ADDR
i386_skip_probe (CORE_ADDR pc)
{
  /* A function may start with

        pushl constant
        call _probe
	addl $4, %esp
d384 1
a384 3
     followed by

        pushl %ebp
d386 1
a386 3
     etc.  */
  unsigned char buf[8];
  unsigned char op;
d388 3
a390 1
  op = read_memory_unsigned_integer (pc, 1);
d392 3
a394 6
  if (op == 0x68 || op == 0x6a)
    {
      int delta;

      /* Skip past the `pushl' instruction; it has either a one-byte or a
	 four-byte operand, depending on the opcode.  */
d396 1
a396 1
	delta = 5;
d398 2
a399 1
	delta = 2;
d401 3
a403 3
      /* Read the following 8 bytes, which should be `call _probe' (6
	 bytes) followed by `addl $4,%esp' (2 bytes).  */
      read_memory (pc + delta, buf, sizeof (buf));
d405 3
a407 1
	pc += delta + sizeof (buf);
a409 20
  return pc;
}

/* Check whether PC points at a code that sets up a new stack frame.
   If so, it updates CACHE and returns the address of the first
   instruction after the sequence that sets removes the "hidden"
   argument from the stack or CURRENT_PC, whichever is smaller.
   Otherwise, return PC.  */

static CORE_ADDR
i386_analyze_frame_setup (CORE_ADDR pc, CORE_ADDR current_pc,
			  struct i386_frame_cache *cache)
{
  unsigned char op;

  if (current_pc <= pc)
    return current_pc;

  op = read_memory_unsigned_integer (pc, 1);

d412 2
a413 12
      /* Take into account that we've executed the `pushl %ebp' that
	 starts this instruction sequence.  */
      cache->saved_regs[FP_REGNUM] = 0;
      cache->sp_offset += 4;

      /* If that's all, return now.  */
      if (current_pc <= pc + 1)
	return current_pc;

      /* Check for `movl %esp, %ebp' -- can be written in two ways.  */
      op = read_memory_unsigned_integer (pc + 1, 1);
      switch (op)
d416 2
a417 2
	  if (read_memory_unsigned_integer (pc + 2, 1) != 0xec)
	    return pc;
d420 2
a421 2
	  if (read_memory_unsigned_integer (pc + 2, 1) != 0xe5)
	    return pc;
d424 1
a424 1
	  return pc;
a425 9

      /* OK, we actually have a frame.  We just don't know how large it is
	 yet.  Set its size to zero.  We'll adjust it if necessary.  */
      cache->locals = 0;

      /* If that's all, return now.  */
      if (current_pc <= pc + 3)
	return current_pc;

d428 1
a428 1
	    subl $XXX, %esp
d432 1
a432 1
      op = read_memory_unsigned_integer (pc + 3, 1);
d436 2
a437 1
	  if (read_memory_unsigned_integer (pc + 4, 1) != 0xec)
d439 7
a445 6
	    return pc + 3;

	  /* `subl' with signed byte immediate (though it wouldn't make
	     sense to be negative).  */
	  cache->locals = read_memory_integer (pc + 5, 1);
	  return pc + 6;
d449 1
d451 2
a452 1
	  if (read_memory_unsigned_integer (pc + 4, 1) != 0xec)
d454 4
a457 2
	    return pc + 3;

d459 2
a460 2
	  cache->locals = read_memory_integer (pc + 5, 4);
	  return pc + 9;
d464 1
a464 2
	  /* Some instruction other than `subl'.  */
	  return pc + 3;
d467 1
a467 1
  else if (op == 0xc8)		/* enter $XXX */
d469 99
a567 3
      cache->locals = read_memory_unsigned_integer (pc + 1, 2);
      return pc + 4;
    }
d569 2
a570 1
  return pc;
d573 1
a573 4
/* Check whether PC points at code that saves registers on the stack.
   If so, it updates CACHE and returns the address of the first
   instruction after the register saves or CURRENT_PC, whichever is
   smaller.  Otherwise, return PC.  */
d576 1
a576 2
i386_analyze_register_saves (CORE_ADDR pc, CORE_ADDR current_pc,
			     struct i386_frame_cache *cache)
d578 1
a578 1
  if (cache->locals >= 0)
d580 5
a584 3
      CORE_ADDR offset;
      unsigned char op;
      int i;
d586 2
a587 6
      offset = - 4 - cache->locals;
      for (i = 0; i < 8 && pc < current_pc; i++)
	{
	  op = read_memory_unsigned_integer (pc, 1);
	  if (op < 0x50 || op > 0x57)
	    break;
d589 4
a592 4
	  cache->saved_regs[op - 0x50] = offset;
	  offset -= 4;
	  pc++;
	}
d595 1
a595 1
  return pc;
d598 1
a598 3
/* Do a full analysis of the prologue at PC and update CACHE
   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
   address where the analysis stopped.
d600 12
d635 2
a636 3
static CORE_ADDR
i386_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
		       struct i386_frame_cache *cache)
d638 35
a672 5
  pc = i386_follow_jump (pc);
  pc = i386_analyze_struct_return (pc, current_pc, cache);
  pc = i386_skip_probe (pc);
  pc = i386_analyze_frame_setup (pc, current_pc, cache);
  return i386_analyze_register_saves (pc, current_pc, cache);
d678 1
a678 1
i386_skip_prologue (CORE_ADDR start_pc)
d680 2
d683 2
a684 3
  {
    0xe8, 0, 0, 0, 0,		/* call 0x0 */
    0x5b,			/* popl %ebx */
d686 4
a689 4
  struct i386_frame_cache cache;
  CORE_ADDR pc;
  unsigned char op;
  int i;
d691 2
a692 4
  cache.locals = -1;
  pc = i386_analyze_prologue (start_pc, 0xffffffff, &cache);
  if (cache.locals < 0)
    return start_pc;
d694 9
a702 1
  /* Found valid frame setup.  */
d707 1
a707 1

d717 1
d720 1
a720 1
      op = read_memory_unsigned_integer (pc + i, 1);
d726 2
a727 3
      int delta = 6;

      op = read_memory_unsigned_integer (pc + delta, 1);
d729 1
d732 1
a732 2
	  op = read_memory_unsigned_integer (pc + delta + 1, 1);

d734 4
a737 1
	    delta += 3;
d739 4
a742 1
	    delta += 6;
d744 2
a745 3
	    delta = 0;

	  op = read_memory_unsigned_integer (pc + delta, 1);
a746 1

d748 1
a748 2
      if (delta > 0 && op == 0x81
	  && read_memory_unsigned_integer (pc + delta + 1, 1) == 0xc3);
d750 1
a750 1
	  pc += delta + 6;
d753 3
d757 1
a757 1
  return i386_follow_jump (pc);
d760 5
a764 1
/* This function is 64-bit safe.  */
d766 5
a770 2
static CORE_ADDR
i386_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
d772 4
a775 4
  char buf[8];

  frame_unwind_register (next_frame, PC_REGNUM, buf);
  return extract_typed_address (buf, builtin_type_void_func_ptr);
a776 1

d778 2
a779 1
/* Normal frames.  */
d781 2
a782 2
static struct i386_frame_cache *
i386_frame_cache (struct frame_info *next_frame, void **this_cache)
a783 1
  struct i386_frame_cache *cache;
a784 4
  int i;

  if (*this_cache)
    return *this_cache;
d786 3
a788 49
  cache = i386_alloc_frame_cache ();
  *this_cache = cache;

/* In principle, for normal frames, %ebp holds the frame pointer,
   which holds the base address for the current stack frame.  However,
   for functions that don't need it, the frame pointer is optional.
   For these "frameless" functions the frame pointer is actually the
   frame pointer of the calling frame.  Signal trampolines are just a
   special case of a "frameless" function.  They (usually) share their
   frame pointer with the frame that was in progress when the signal
   occurred.  */

  frame_unwind_register (next_frame, I386_EBP_REGNUM, buf);
  cache->base = extract_address (buf, 4);
  if (cache->base == 0)
    return cache;

  /* For normal frames, %eip is stored at 4(%ebp).  */
  cache->saved_regs[I386_EIP_REGNUM] = 4;

  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
    i386_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);

  if (cache->locals < 0)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  If
	 we're at the start of a function, or somewhere half-way its
	 prologue, the function's frame probably hasn't been fully
	 setup yet.  Try to reconstruct the base address for the stack
	 frame by looking at the stack pointer.  For truly "frameless"
	 functions this might work too.  */

      frame_unwind_register (next_frame, I386_ESP_REGNUM, buf);
      cache->base = extract_address (buf, 4) + cache->sp_offset;
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of %esp in the calling frame.  */
  cache->saved_sp = cache->base + 8;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < I386_NUM_SAVED_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;

  return cache;
d792 1
a792 2
i386_frame_this_id (struct frame_info *next_frame, void **this_cache,
		    struct frame_id *this_id)
d794 3
a796 33
  struct i386_frame_cache *cache = i386_frame_cache (next_frame, this_cache);

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;

  /* This is meant to halt the backtrace at "_start".  */
  if (inside_entry_file (cache->pc))
    return;

  (*this_id) = frame_id_build (cache->base, cache->pc);
}

static void
i386_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *valuep)
{
  struct i386_frame_cache *cache = i386_frame_cache (next_frame, this_cache);

  gdb_assert (regnum >= 0);

  /* The System V ABI says that:

     "The flags register contains the system flags, such as the
     direction flag and the carry flag.  The direction flag must be
     set to the forward (that is, zero) direction before entry and
     upon exit from a function.  Other user flags have no specified
     role in the standard calling sequence and are not preserved."

     To guarantee the "upon exit" part of that statement we fake a
     saved flags register that has its direction flag cleared.
d798 2
a799 3
     Note that GCC doesn't seem to rely on the fact that the direction
     flag is cleared after a function return; it always explicitly
     clears the flag before operations where it matters.
d801 1
a801 5
     FIXME: kettenis/20030316: I'm not quite sure whether this is the
     right thing to do.  The way we fake the flags register here makes
     it impossible to change it.  */

  if (regnum == I386_EFLAGS_REGNUM)
d803 3
a805 5
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
d807 2
a808 6
	  ULONGEST val;

	  /* Clear the direction flag.  */
	  frame_unwind_unsigned_register (next_frame, PS_REGNUM, &val);
	  val &= ~(1 << 10);
	  store_unsigned_integer (valuep, 4, val);
a809 2

      return;
d811 4
a814 80

  if (regnum == I386_EIP_REGNUM && cache->pc_in_eax)
    {
      *optimizedp = 0;
      *lvalp = lval_register;
      *addrp = 0;
      *realnump = I386_EAX_REGNUM; /* %eax */
      if (valuep)
	{
	  /* Read the value from the register.  */
	  frame_unwind_register (next_frame, 0, valuep);
	}
      return;
    }

  if (regnum == I386_ESP_REGNUM && cache->saved_sp)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_address (valuep, 4, cache->saved_sp);
	}
      return;
    }

  if (regnum < I386_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
	}
      return;
    }

  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind i386_frame_unwind =
{
  NORMAL_FRAME,
  i386_frame_this_id,
  i386_frame_prev_register
};


/* Signal trampolines.  */

static struct i386_frame_cache *
i386_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct i386_frame_cache *cache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  CORE_ADDR addr;
  char buf[4];

  if (*this_cache)
    return *this_cache;

  cache = i386_alloc_frame_cache ();

  frame_unwind_register (next_frame, I386_ESP_REGNUM, buf);
  cache->base = extract_address (buf, 4) - 4;

  addr = tdep->sigcontext_addr (next_frame);
  cache->saved_regs[I386_EIP_REGNUM] = addr + tdep->sc_pc_offset;
  cache->saved_regs[I386_ESP_REGNUM] = addr + tdep->sc_sp_offset;

  *this_cache = cache;
  return cache;
d818 1
a818 2
i386_sigtramp_frame_this_id (struct frame_info *next_frame, void **this_cache,
			     struct frame_id *this_id)
d820 1
a820 86
  struct i386_frame_cache *cache =
    i386_sigtramp_frame_cache (next_frame, this_cache);

  (*this_id) = frame_id_build (cache->base, frame_pc_unwind (next_frame));
}

static void
i386_sigtramp_frame_prev_register (struct frame_info *next_frame,
				   void **this_cache,
				   int regnum, int *optimizedp,
				   enum lval_type *lvalp, CORE_ADDR *addrp,
				   int *realnump, void *valuep)
{
  /* Make sure we've initialized the cache.  */
  i386_sigtramp_frame_cache (next_frame, this_cache);

  i386_frame_prev_register (next_frame, this_cache, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind i386_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  i386_sigtramp_frame_this_id,
  i386_sigtramp_frame_prev_register
};


const struct frame_unwind *
i386_frame_p (CORE_ADDR pc)
{
  char *name;

  find_pc_partial_function (pc, &name, NULL, NULL);
  if (PC_IN_SIGTRAMP (pc, name))
    return &i386_sigtramp_frame_unwind;

  return &i386_frame_unwind;
}

static CORE_ADDR
i386_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct i386_frame_cache *cache = i386_frame_cache (next_frame, this_cache);

  return cache->base;
}

static const struct frame_base i386_frame_base =
{
  &i386_frame_unwind,
  i386_frame_base_address,
  i386_frame_base_address,
  i386_frame_base_address
};

/* This function is 64-bit safe.  */

static struct frame_id
i386_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  char buf[8];
  CORE_ADDR fp;

  frame_unwind_register (next_frame, FP_REGNUM, buf);
  fp = extract_typed_address (buf, builtin_type_void_data_ptr);

  return frame_id_build (fp, frame_pc_unwind (next_frame));
}

/* This function is 64-bit safe.  */

static void
i386_save_dummy_frame_tos (CORE_ADDR sp)
{
  char buf[8];

  /* We can't use the saved top-of-stack to find the right dummy frame
     when unwinding, since we can't reconstruct it properly if the
     dummy frame is the innermost frame.  To circumvent this, we fake
     a frame pointer here.  */

  store_typed_address (buf, builtin_type_void_data_ptr, sp);
  regcache_cooked_write (current_regcache, FP_REGNUM, buf);

  generic_save_dummy_frame_tos (sp);
d828 1
a828 3
   success.

   This function is 64-bit safe.  */
d857 2
a858 3
i386_push_dummy_call (struct gdbarch *gdbarch, struct regcache *regcache,
		      CORE_ADDR dummy_addr, int nargs, struct value **args,
		      CORE_ADDR sp, int struct_return, CORE_ADDR struct_addr)
d860 3
a862 5
  char buf[4];
  int i;

  /* Push arguments in reverse order.  */
  for (i = nargs - 1; i >= 0; i--)
d864 1
a864 7
      int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (args[i]));

      /* The System V ABI says that:

	 "An argument's size is increased, if necessary, to make it a
	 multiple of [32-bit] words.  This may require tail padding,
	 depending on the size of the argument."
a865 8
	 This makes sure the stack says word-aligned.  */
      sp -= (len + 3) & ~3;
      write_memory (sp, VALUE_CONTENTS_ALL (args[i]), len);
    }

  /* Push value address.  */
  if (struct_return)
    {
a870 9
  /* Store return address.  */
  sp -= 4;
  store_address (buf, 4, dummy_addr);
  write_memory (sp, buf, 4);

  /* Finally, update the stack pointer.  */
  store_address (buf, 4, sp);
  regcache_cooked_write (regcache, I386_ESP_REGNUM, buf);

d877 2
a878 2
#define LOW_RETURN_REGNUM	I386_EAX_REGNUM /* %eax */
#define HIGH_RETURN_REGNUM	I386_EDX_REGNUM /* %edx */
d912 1
a912 1
      regcache_raw_read (regcache, I386_ST0_REGNUM, buf);
d974 1
a974 1
      regcache_raw_write (regcache, I386_ST0_REGNUM, buf);
d1015 1
a1015 1
  char buf[4];
d1017 2
a1018 2
  regcache_cooked_read (regcache, I386_EAX_REGNUM, buf);
  return extract_address (buf, 4);
d1060 1
a1060 2
  if (regnum == I386_EIP_REGNUM
      || regnum == I386_EBP_REGNUM || regnum == I386_ESP_REGNUM)
d1076 1
a1076 1
   the MMX registers need to be mapped onto floating point registers.  */
a1276 2
  /* UnixWare uses _sigacthandler.  The origin of the other symbols is
     currently unknown.  */
d1282 2
a1283 3
/* Assuming NEXT_FRAME is for a frame following a SVR4 sigtramp
   routine, return the address of the associated sigcontext (ucontext)
   structure.  */
d1286 1
a1286 1
i386_svr4_sigcontext_addr (struct frame_info *next_frame)
d1288 13
a1300 2
  char buf[4];
  CORE_ADDR sp;
d1302 1
a1302 2
  frame_unwind_register (next_frame, I386_ESP_REGNUM, buf);
  sp = extract_address (buf, 4);
d1304 3
a1306 1
  return read_memory_unsigned_integer (sp + 8, 4);
d1345 2
a1346 2
  tdep->sc_pc_offset = 36 + 14 * 4;
  tdep->sc_sp_offset = 36 + 17 * 4;
a1409 1

a1419 1

d1422 1
a1423 1

d1439 4
d1467 2
a1468 2
  /* The default ABI includes general-purpose registers and
     floating-point registers.  */
a1469 4
  set_gdbarch_register_bytes (gdbarch, I386_SIZEOF_GREGS + I386_SIZEOF_FREGS);
  set_gdbarch_register_name (gdbarch, i386_register_name);
  set_gdbarch_register_size (gdbarch, 4);
  set_gdbarch_register_type (gdbarch, i386_register_type);
d1471 5
a1475 6
  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, I386_ESP_REGNUM); /* %esp */
  set_gdbarch_fp_regnum (gdbarch, I386_EBP_REGNUM); /* %ebp */
  set_gdbarch_pc_regnum (gdbarch, I386_EIP_REGNUM); /* %eip */
  set_gdbarch_ps_regnum (gdbarch, I386_EFLAGS_REGNUM); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, I386_ST0_REGNUM); /* %st(0) */
d1488 5
a1499 1
  set_gdbarch_push_dummy_call (gdbarch, i386_push_dummy_call);
d1506 5
d1512 3
d1520 1
d1530 5
d1538 3
d1545 1
a1545 1
  set_gdbarch_num_pseudo_regs (gdbarch, i386_num_mmx_regs);
a1550 5
  set_gdbarch_unwind_dummy_id (gdbarch, i386_unwind_dummy_id);
  set_gdbarch_save_dummy_frame_tos (gdbarch, i386_save_dummy_frame_tos);

  set_gdbarch_unwind_pc (gdbarch, i386_unwind_pc);

d1555 3
a1559 3

  frame_unwind_append_predicate (gdbarch, i386_frame_p);
  frame_base_set_default (gdbarch, &i386_frame_base);
@


1.138.2.2
log
@* i386-tdep.c (i386_analyze_frame_setup): Use I386_EBP_REGNUM
instead of FP_REGNUM.
(i386_unwind_dummy_id): Use I386_ESP_REGNUM instead of FP_REGNUM.
Don't mark this function as 64-bit safe.
(i386_save_dummy_frame_tos): Remove function.
(i386_push_dummy_call): Fake the frame pointer here.
(i386_gdbarch_init): Set save_dummy_frame_tos to
generic_save_dummy_frame_tos.
@
text
@d474 1
a474 1
      cache->saved_regs[I386_EBP_REGNUM] = 0;
d972 2
d977 1
a977 1
  char buf[4];
d980 1
a980 1
  frame_unwind_register (next_frame, I386_EBP_REGNUM, buf);
d985 18
d1076 1
a1076 1
  /* Finally, update the stack pointer...  */
a1079 3
  /* ...and fake a frame pointer.  */
  regcache_cooked_write (regcache, I386_EBP_REGNUM, buf);

d1735 1
a1735 1
  set_gdbarch_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
@


1.138.2.3
log
@Merge from mainline.
@
text
@d1659 1
a1659 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, I386_EBP_REGNUM); /* %ebp */
@


1.138.2.4
log
@* i386-tdep.c (i386_gdbarch_init): Don't set deprecated_fp_regnum.
@
text
@d1659 1
@


1.138.2.5
log
@* i386-tdep.c: Put header files in alphabetical orde.
(i386_frameless_function_invocation): Removed.
(i386_frame_this_id, i386_sigtramp_frame_this_id): Adjust stack
address when building the frame ID.
(i386_save_dummy_frame_tos): New function.
(i386_unwind_dummy_id): Adjust stack address when building the
frame ID.
(i386_gdbarch_init): Don't set frameless_function_invocation.  Set
save_dummy_frame_tos to i386_save_dummy_frame_tos.
@
text
@d24 1
a24 5
#include "arch-utils.h"
#include "command.h"
#include "dummy-frame.h"
#include "doublest.h"
#include "floatformat.h"
a28 1
#include "gdbcmd.h"
d31 2
a32 3
#include "osabi.h"
#include "regcache.h"
#include "reggroups.h"
d35 5
a39 1
#include "target.h"
a40 1

d42 3
a44 1
#include "gdb_string.h"
d220 13
d780 1
a780 1
  (*this_id) = frame_id_build (cache->base + 8, cache->pc);
d919 1
a919 1
  (*this_id) = frame_id_build (cache->base + 8, frame_pc_unwind (next_frame));
a971 6
static void
i386_save_dummy_frame_tos (CORE_ADDR sp)
{
  generic_save_dummy_frame_tos (sp + 8);
}

d981 1
a981 1
  return frame_id_build (fp + 8, frame_pc_unwind (next_frame));
d1704 2
d1717 1
a1717 1
  set_gdbarch_save_dummy_frame_tos (gdbarch, i386_save_dummy_frame_tos);
@


1.138.2.6
log
@* dwarf-frame.c, dwarf-frame.h: New files.
* i386-tdep.c: Include "dwarf-frame.h".
(i386_gdbarch_init): Hook in the DWARF CFI frame unwinder.
* Makefile.in (SFILES): Add dwarf-frame.c
(dwarf_frame_h): Define.
(COMMON_OBS): Add dwarf-frame.o
(dwarf-frame.o): Add dependencies.
@
text
@a26 1
#include "dwarf-frame.h"
a1719 5
  /* Hook in the DWARF CFI frame unwinder.  */
  frame_unwind_append_predicate (gdbarch, dwarf_frame_p);
  frame_base_append_predicate (gdbarch, dwarf_frame_base_p);
  set_gdbarch_dwarf2_build_frame_info (gdbarch, dwarf2_build_frame_info);
  
@


1.138.2.7
log
@* i386-tdep.c (i386_frame_prev_register): Use
frame_register_unwind to unwind I386_EAX_REGNUM when that's where
the PC lives.
@
text
@d822 9
a830 2
      frame_register_unwind (next_frame, I386_EAX_REGNUM,
			     optimizedp, lvalp, addrp, realnump, valuep);
@


1.138.2.8
log
@* i386-tdep.c (i386_gdbarch_init): Don't hook in the DWARF CFI
frame base methods.
@
text
@d1716 1
@


1.138.2.9
log
@* i386-tdep.c (i386_analyze_struct_return): Correctly indent
comment.
(i386_analyze_frame_setup): Report correct bug after matching
initial `pushl %ebp'.
@
text
@d358 9
a366 8
        popl %eax             0x58
        xchgl %eax, (%esp)    0x87 0x04 0x24
     or xchgl %eax, 0(%esp)   0x87 0x44 0x24 0x00

     (the System V compiler puts out the second `xchg' instruction,
     and the assembler doesn't try to optimize it, so the 'sib' form
     gets generated).  This sequence is used to get the address of the
     return buffer for a function that returns a structure.  */
d476 1
a476 1
	    return pc + 1;
d480 1
a480 1
	    return pc + 1;
d483 1
a483 1
	  return pc + 1;
@


1.138.2.10
log
@* i386-tdep.c (i386_frame_p): Move signal trampoline unwinder...
(i386_sigtramp_frame_p): ...here.  Make both functions static.
(i386_gdbarch_init): Register signal trampoline unwinder.  Change
order in which frame unwinders and frame baase methods are
registered to make overriding them easier.
@
text
@a864 6

static const struct frame_unwind *
i386_frame_p (CORE_ADDR pc)
{
  return &i386_frame_unwind;
}
d923 1
d925 2
a926 2
static const struct frame_unwind *
i386_sigtramp_frame_p (CORE_ADDR pc)
d934 1
a934 1
  return NULL;
a935 1

d1710 3
d1716 2
a1717 1

a1718 6

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  frame_unwind_append_predicate (gdbarch, i386_sigtramp_frame_p);
  frame_unwind_append_predicate (gdbarch, i386_frame_p);
@


1.138.2.11
log
@* i386-tdep.c (i386_frame_cache, i386_sigtramp_frame_cache,
i386_extract_struct_value_address, i386_svr4_sigcontext_addr): Use
extract_unsigned_integer instead of extract_address.
* i386bsd-tdep.c (i386bsd_sigcontext_addr): Likewise.
* i386-linux-tdep.c (i386_linux_sigcontext_addr): Likewise.
@
text
@d716 1
a716 1
  cache->base = extract_unsigned_integer (buf, 4);
d738 1
a738 1
      cache->base = extract_unsigned_integer (buf, 4) + cache->sp_offset;
d889 1
a889 1
  cache->base = extract_unsigned_integer (buf, 4) - 4;
d1203 1
a1203 1
  return extract_unsigned_integer (buf, 4);
d1481 1
a1481 1
  sp = extract_unsigned_integer (buf, 4);
@


1.138.2.12
log
@* i386-tdep.c (i386_unwind_dummy_id): Use extract_unsigned_integer
instead of extract_typed_address for consistency with the rest of
the code in this file.
* i386-linux-tdep.c: Fix formatting in some comments.
(LINUX_SIGTRAMP_INSN0, LINUX_SIGTRAMP_OFFSET0,
LINUX_SIGTRAMP_INSN1, LINUX_SIGTRAMP_OFFSET1,
LINUX_SIGTRAMP_INSN2, LINUX_SIGTRAMP_OFFSET2,
LINUX_RT_SIGTRAMP_INSN0, LINUX_RT_SIGTRAMP_OFFSET0,
LINUX_RT_SIGTRAMP_INSN1, LINUX_RT_SIGTRAMP_OFFSET1): Drop
redundant parentheses.
(I386_LINUX_UCONTEXT_SIGCONTEXT_OFFSET): New define.
(i386_linux_sigcontext_addr): Use it.
(find_minsym_and_objfile): Change name of second argument.
@
text
@d972 1
a972 1
  fp = extract_unsigned_integer (buf, 4);
@


1.138.2.13
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d835 1
a835 1
	  store_unsigned_integer (valuep, 4, cache->saved_sp);
d1040 1
a1040 1
      store_unsigned_integer (buf, 4, struct_addr);
d1046 1
a1046 1
  store_unsigned_integer (buf, 4, dummy_addr);
d1050 1
a1050 1
  store_unsigned_integer (buf, 4, sp);
d1286 1
a1286 1
      char mmx_buf[MAX_REGISTER_SIZE];
d1303 1
a1303 1
      char mmx_buf[MAX_REGISTER_SIZE];
d1645 1
d1647 1
d1672 2
@


1.138.2.14
log
@* i386-tdep.c (i386_frame_cache): Fix indentation of comment.
@
text
@d706 8
a713 8
  /* In principle, for normal frames, %ebp holds the frame pointer,
     which holds the base address for the current stack frame.
     However, for functions that don't need it, the frame pointer is
     optional.  For these "frameless" functions the frame pointer is
     actually the frame pointer of the calling frame.  Signal
     trampolines are just a special case of a "frameless" function.
     They (usually) share their frame pointer with the frame that was
     in progress when the signal occurred.  */
@


1.138.2.15
log
@* i386-tdep.c, dwarf-frame.c, dwarf-frame.h: Use dwarf2_ instead
of dwarf_ as the prefix where appropriate.
@
text
@d1713 1
a1713 1
  frame_unwind_append_predicate (gdbarch, dwarf2_frame_p);
@


1.138.2.16
log
@* i386-tdep.c (i386_skip_prologue): Fix comment.
@
text
@d631 1
a631 1
     %ebx:
@


1.138.2.17
log
@* i386-tdep.c (i386_frame_this_id): Remove inside_entry_file
check.  The majority of i386 targets shouldn't need this, and it
hurts Cygwin.
* x86-64-tdep.c (x86_64_frame_this_id): Likewise.
@
text
@d764 4
@


1.137
log
@* i386-tdep.c (i386_extract_return_value,
i386_store_return_value): Correct check for availability of
floating-point registers.
@
text
@d49 1
d65 3
d75 5
a79 3
static const int mmx_num_regs = (sizeof (i386_mmx_names)
				 / sizeof (i386_mmx_names[0]));
#define MM0_REGNUM (NUM_REGS)
d82 1
a82 1
i386_mmx_regnum_p (int reg)
d84 2
a85 1
  return (reg >= MM0_REGNUM && reg < MM0_REGNUM + mmx_num_regs);
d94 1
a94 1
	  && (FP0_REGNUM && FP0_REGNUM <= (regnum) && (regnum) < FPC_REGNUM));
d101 1
a101 1
	  && (FPC_REGNUM <= (regnum) && (regnum) < XMM0_REGNUM));
d110 1
a110 1
	  && (XMM0_REGNUM <= (regnum) && (regnum) < MXCSR_REGNUM));
d117 1
a117 1
	  && (regnum == MXCSR_REGNUM));
d125 3
a127 2
  if (reg < 0)
    return NULL;
a129 2
  if (reg >= sizeof (i386_register_names) / sizeof (*i386_register_names))
    return NULL;
d131 1
a131 1
  return i386_register_names[reg];
@


1.136
log
@* i386-tdep.c (i386_frame_num_args): Remove function.
(i386_gdbarch_init): Set frame_num_args to frame_num_args_unknown.
@
text
@d895 1
a895 1
      if (FP0_REGNUM == 0)
d953 1
a953 1
      if (FP0_REGNUM == 0)
@


1.135
log
@* i386-tdep.c (i386_mmx_regnum_to_fp_regnum): Renamed from
mmx_regnum_to_fp_regnum.  Adjust all callers.
@
text
@a602 74
/* Return number of args passed to a frame.
   Can return -1, meaning no way to tell.  */

static int
i386_frame_num_args (struct frame_info *fi)
{
#if 1
  return -1;
#else
  /* This loses because not only might the compiler not be popping the
     args right after the function call, it might be popping args from
     both this call and a previous one, and we would say there are
     more args than there really are.  */

  int retpc;
  unsigned char op;
  struct frame_info *pfi;

  /* On the i386, the instruction following the call could be:
     popl %ecx        -  one arg
     addl $imm, %esp  -  imm/4 args; imm may be 8 or 32 bits
     anything else    -  zero args.  */

  int frameless;

  frameless = FRAMELESS_FUNCTION_INVOCATION (fi);
  if (frameless)
    /* In the absence of a frame pointer, GDB doesn't get correct
       values for nameless arguments.  Return -1, so it doesn't print
       any nameless arguments.  */
    return -1;

  pfi = get_prev_frame (fi);
  if (pfi == 0)
    {
      /* NOTE: This can happen if we are looking at the frame for
         main, because DEPRECATED_FRAME_CHAIN_VALID won't let us go
         into start.  If we have debugging symbols, that's not really
         a big deal; it just means it will only show as many arguments
         to main as are declared.  */
      return -1;
    }
  else
    {
      retpc = pfi->pc;
      op = read_memory_integer (retpc, 1);
      if (op == 0x59)		/* pop %ecx */
	return 1;
      else if (op == 0x83)
	{
	  op = read_memory_integer (retpc + 1, 1);
	  if (op == 0xc4)
	    /* addl $<signed imm 8 bits>, %esp */
	    return (read_memory_integer (retpc + 2, 1) & 0xff) / 4;
	  else
	    return 0;
	}
      else if (op == 0x81)	/* `add' with 32 bit immediate.  */
	{
	  op = read_memory_integer (retpc + 1, 1);
	  if (op == 0xc4)
	    /* addl $<imm 32>, %esp */
	    return read_memory_integer (retpc + 2, 4) / 4;
	  else
	    return 0;
	}
      else
	{
	  return 0;
	}
    }
#endif
}

d1535 1
a1535 1
  set_gdbarch_frame_num_args (gdbarch, i386_frame_num_args);
@


1.134
log
@* i386-tdep.c (i386_get_longjmp_target): Use
TYPE_LENGTH(builtin_type_void_func_ptr) instead of TARGET_PTR_BIT
and TARGET_CHAR_BIT.  Use extract_typed_address instead of
extract_address.
@
text
@d1144 1
a1144 1
   the MMX registers need to be mapped onto floating point registers.  */
d1147 1
a1147 1
mmx_regnum_to_fp_regnum (struct regcache *regcache, int regnum)
d1153 1
d1158 1
d1169 3
a1171 1
      int fpnum = mmx_regnum_to_fp_regnum (regcache, regnum);
a1172 1
      /* Extract (always little endian).  */
d1186 2
a1187 1
      int fpnum = mmx_regnum_to_fp_regnum (regcache, regnum);
@


1.133
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_SAVED_PC_AFTER_CALL): Deprecate
	SAVED_PC_AFTER_CALL.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_saved_pc_after_call): Update declaration.
	* i386ly-tdep.c (i386lynx_init_abi): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	* infrun.c (step_over_function): Update.
	* i386-linux-tdep.c (skip_hurd_resolver): Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	* arm-linux-tdep.c (skip_hurd_resolver): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	* x86-64-tdep.h (x86_64_linux_saved_pc_after_call): Update
	declaration.
@
text
@d904 1
a904 1
  int len = TARGET_PTR_BIT / TARGET_CHAR_BIT;
d915 1
a915 1
  jb_addr = extract_address (buf, len);
d919 1
a919 1
  *pc = extract_address (buf, len);
@


1.132
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_func_unwind, get_frame_func): New functions.
	* frame.h (get_frame_func, frame_func_unwind): Declare.
	(struct frame_info): Add field "prev_func" for caching the
	previous frame's function address.
	* arm-tdep.c (arm_frameless_function_invocation): Combine
	get_pc_function_start and get_frame_pc into get_frame_func.
	* sh-tdep.c (sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	* s390-tdep.c (s390_function_start): Ditto.
	* rs6000-tdep.c (rs6000_pop_frame): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc): Ditto.
	* m68k-tdep.c (m68k_frame_init_saved_regs): Ditto.
	* ia64-tdep.c (ia64_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frameless_signal_p): Ditto.
	(i386_frame_init_saved_regs): Ditto.
	* hppa-tdep.c (hppa_frame_find_saved_regs): Ditto.
	* d10v-tdep.c (d10v_frame_unwind_cache): Combine
	get_pc_function_start and frame_pc_unwind into frame_func_unwind.
	* cris-tdep.c (cris_frame_init_saved_regs): Ditto.
	* blockframe.c (frameless_look_for_prologue): Ditto.
@
text
@d1604 1
a1604 1
  set_gdbarch_saved_pc_after_call (gdbarch, i386_saved_pc_after_call);
@


1.131
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_START_OFFSET): Default to zero.
	CALL_DUMMY_LENGTH): Ditto.
	* gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_START_OFFSET): Delete macro.
	(CALL_DUMMY_LENGTH): Delete macro.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set above when zero.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@d505 1
a505 1
	      || get_frame_pc (frame) == get_pc_function_start (get_frame_pc (frame))));
d717 1
a717 1
  pc = get_pc_function_start (get_frame_pc (fip));
@


1.131.2.1
log
@Merge with mainline.
@
text
@d505 1
a505 1
	      || get_frame_pc (frame) == get_frame_func (frame)));
d717 1
a717 1
  pc = get_frame_func (fip);
@


1.130
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_BREAKPOINT_OFFSET): Default to zero.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sp64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* config/pa/tm-hppa64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* inferior.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET): Delete.
	* infcmd.c (run_stack_dummy): Simplify assuming
	CALL_DUMMY_BREAKPOINT_OFFSET_P.
	* infrun.c (handle_inferior_event): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	call_dummy_breakpoint_offset or call_dummy_breakpoint_offset_p.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@a1561 2
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
  set_gdbarch_call_dummy_length (gdbarch, 0);
@


1.129
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FIX_CALL_DUMMY): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Regenerate.
	* inferior.h (FIX_CALL_DUMMY): Delete macro.
	* valops.c (hand_function_call): Only call FIX_CALL_DUMMY when
	available.
	* frame.h (generic_fix_call_dummy): Delete declaration.
	* dummy-frame.h: Update comment.
	* dummy-frame.c (generic_fix_call_dummy): Delete function.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	fix_call_dummy.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a1562 2
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
@


1.128
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Include "symfile.h".
	(CALL_DUMMY_ADDRESS): Default to entry_point_address.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_ADDRESS): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_address, the default is at entry_point_address.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a1567 1
  set_gdbarch_fix_call_dummy (gdbarch, generic_fix_call_dummy);
@


1.127
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_P): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* dummy-frame.c (dummy_frame_this_id): Update comments.
	* rs6000-tdep.c (rs6000_extract_struct_value_address): Ditto.
	* frame.c (legacy_get_prev_frame): Ditto.
	* valops.c (call_function_by_hand): Delete function.
	(hand_function_call): Rename to call_function_by_hand

2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to CALL_DUMMY_P.
@
text
@a1561 1
  set_gdbarch_call_dummy_address (gdbarch, entry_point_address);
@


1.126
log
@* i386-tdep.c (i386_store_struct_return): Removed.
(i386_gdbarch_init): Don't set deprecated_store_struct_return.
@
text
@a1566 1
  set_gdbarch_call_dummy_p (gdbarch, 1);
@


1.125
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_DUMMY_WRITE_SP): Replace TARGET_WRITE_SP.
	* gdbarch.h, gdbarch.c: Regenerate.
	* v850-tdep.c (v850_gdbarch_init): Set deprecated_dummy_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_push_dummy_frame, sparc_pop_frame): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_DUMMY_WRITE_SP): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* valops.c (hand_function_call): Replace TARGET_WRITE_SP with
	DEPRECATED_DUMMY_WRITE_SP.  Call when the method is available,
	instead of when push_dummy_call is not available.

2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Remove
	reference to TARGET_WRITE_SP.
@
text
@a941 6
static void
i386_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  /* Do nothing.  Everything was already done by i386_push_arguments.  */
}

a1585 1
  set_gdbarch_deprecated_store_struct_return (gdbarch, i386_store_struct_return);
@


1.124
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_RETURN_ADDRESS): Replace
	PUSH_RETURN_ADDRESS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* valops.c (hand_function_call): Update.
@
text
@d1633 3
@


1.123
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_ARGUMENTS): Rename PUSH_ARGUMENTS.
	(push_dummy_call): New pure multi-arch replacement with gdbarch,
	regcache and dummy_addr parameters.
	* gdbarch.h, gdbarch.c: Re-generate.
	* valops.c (hand_function_call): Use gdbarch_push_dummy_call when
	available; assume it will handle stack alignment and return
	address issues.  Fall back to DEPRECATED_PUSH_ARGUMENTS and
	legacy_push_arguments.
	(legacy_push_arguments): Rename default_push_arguments.
	* value.h (legacy_push_arguments): Rename default_push_arguments.
	* i386-tdep.c (i386_push_arguments): Call legacy_push_arguments.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/i386/tm-symmetry.h: Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* arm-linux-tdep.c (arm_linux_init_abi): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	PUSH_ARGUMENTS with push_dummy_call, add gdbarch, regcache and
	dummy_addr parameters.
@
text
@d1590 1
a1590 1
  set_gdbarch_push_return_address (gdbarch, i386_push_return_address);
@


1.122
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STORE_STRUCT_RETURN): Replace
	STORE_STRUCT_RETURN.
	* gdbarch.h, gdbarch.c: Regenerate.
	* d10v-tdep.c (d10v_store_struct_return): Delete function.
	(d10v_push_arguments): Set the struct return register.
	(d10v_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d928 1
a928 1
  sp = default_push_arguments (nargs, args, sp, struct_return, struct_addr);
d1589 1
a1589 1
  set_gdbarch_push_arguments (gdbarch, i386_push_arguments);
@


1.122.2.1
log
@Merge with mainline.
@
text
@d928 1
a928 1
  sp = legacy_push_arguments (nargs, args, sp, struct_return, struct_addr);
d942 6
d1589 2
a1590 2
  set_gdbarch_deprecated_push_arguments (gdbarch, i386_push_arguments);
  set_gdbarch_deprecated_push_return_address (gdbarch, i386_push_return_address);
d1592 1
a1631 3

  /* Should be using push_dummy_call.  */
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
@


1.121
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_STACK_ADJUST_P): Delete.
	(DEPRECATED_CALL_DUMMY_STACK_ADJUST): Replace
	CALL_DUMMY_STACK_ADJUST with a predicate variable.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_stack_adjust_p.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sparc.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.  Do not set
	call_dummy_stack_adjust_p.
	* inferior.h (CALL_DUMMY_STACK_ADJUST_P): Delete macro.
	(CALL_DUMMY_STACK_ADJUST): Delete macro.
	* sparc-tdep.c (sparc32_push_arguments): Update.
	* valops.c (hand_function_call): Update.

2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	reference to CALL_DUMMY_STACK_ADJUST_P.  Rename
	CALL_DUMMY_STACK_ADJUST to DEPRECATED_CALL_DUMMY_STACK_ADJUST.
	Add reference to PUSH_ARGUMENTS.
@
text
@d1592 1
a1592 1
  set_gdbarch_store_struct_return (gdbarch, i386_store_struct_return);
@


1.120
log
@Index: ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_CHAIN): Replace FRAME_CHAIN.
	(DEPRECATED_FRAME_CHAIN_VALID): Replace FRAME_CHAIN_VALID.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update.
	* objfiles.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame, get_prev_frame, legacy_frame_p): Update.
	* dummy-frame.h: Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* config/m68k/tm-vx68.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-os68k.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-sun3.h: Update.
	* blockframe.c (inside_main_func, frame_chain_valid): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_frame_chain, sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	(rs6000_gdbarch_init, rs6000_frame_saved_pc): Update.
	(frame_get_saved_regs): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_frame_num_args, i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	(i386_interix_back_one_frame): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	(hppa_init_extra_frame_info): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Algorithms, Target Architecture Definition):
	Deprecate FRAME_CHAIN and FRAME_CHAIN_VALID.
@
text
@a1575 1
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
@


1.119
log
@* i386-tdep.c (i386_register_type): Renamed from
i386_register_virtual_type.  Adjust function signature.
(i386_gdbarch_init): Set register_type instead of
deprecated_max_register_raw_size,
deprecated_max_register_virtual_size and register_virtual_type.
@
text
@d639 4
a642 4
         main, because FRAME_CHAIN_VALID won't let us go into start.
         If we have debugging symbols, that's not really a big deal;
         it just means it will only show as many arguments to main as
         are declared.  */
d1617 1
a1617 1
  set_gdbarch_frame_chain (gdbarch, i386_frame_chain);
@


1.118
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_POP_FRAME): Replace POP_FRAME.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update comment.
	* stack.c (return_command): Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_POP_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_POP_FRAME): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	POP_FRAME with DEPRECATED_POP_FRAME.  Update description.
@
text
@d1132 1
a1132 1
i386_register_virtual_type (int regnum)
d1561 1
a1561 3
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, I386_MAX_REGISTER_SIZE);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, I386_MAX_REGISTER_SIZE);
  set_gdbarch_register_virtual_type (gdbarch, i386_register_virtual_type);
@


1.117
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_SAVED_PC): Replace FRAME_SAVED_PC.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.h: Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* sh-tdep.c (sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Update.
	* xstormy16-tdep.c (xstormy16_pop_frame): Update.
	(xstormy16_frame_chain_valid): Update.
	* vax-tdep.c (vax_saved_pc_after_call): Update.
	* v850-tdep.c (v850_frame_chain): Update.
	(v850_pop_frame): Update.
	(v850_init_extra_frame_info): Update.
	* sparc-tdep.c (setup_arbitrary_frame): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* s390-tdep.c (s390_pop_frame_regular): Update.
	* mn10300-tdep.c (mn10300_frame_chain): Update.
	(mn10300_pop_frame_regular): Update.
	(mn10300_init_extra_frame_info): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	(mips_frame_chain): Update.
	(mips_pop_frame): Update.
	* mcore-tdep.c (mcore_frame_chain): Update.
	(mcore_pop_frame): Update.
	(mcore_init_extra_frame_info): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* m68k-tdep.c (isi_frame_num_args): Update.
	(delta68_frame_num_args): Update.
	(news_frame_num_args): Update.
	* ia64-tdep.c (ia64_pop_frame_regular): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	(alpha_frame_chain): Update.
	(alpha_pop_frame): Update.
	* hppa-tdep.c (hppa_saved_pc_after_call): Update.
	(hppa_init_extra_frame_info): Update.
	(hppa_frame_chain): Update.
	(hppa_frame_chain_valid): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_init_extra_frame_info): Update.
	* arm-tdep.c (arm_frame_chain_valid): Update.
	(arm_init_extra_frame_info): Update.
	(arm_pop_frame): Update.
	* frame.c (frame_pc_unwind): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_SAVED_PC): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-linux.h (DEPRECATED_FRAME_SAVED_PC): Update.

2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_SAVED_PC to DEPRECATED_FRAME_SAVED_PC.
@
text
@d1594 1
a1594 1
  set_gdbarch_pop_frame (gdbarch, i386_pop_frame);
@


1.116
log
@2003-03-03  Andrew Cagney  <cagney@@redhat.com>

	Make MAX_REGISTER_RAW_SIZE and MAX_REGISTER_VIRTUAL_SIZE optional.
	* gdbarch.sh (DEPRECATED_MAX_REGISTER_RAW_SIZE): Variable with
	predicate.  Replace MAX_REGISTER_RAW_SIZE.
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto for
	MAX_REGISTER_VIRTUAL_SIZE.
	* regcache.c (legacy_max_register_raw_size): New function.
	(legacy_max_register_virtual_size): New function.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Define.
	(MAX_REGISTER_RAW_SIZE): Define.
	(legacy_max_register_raw_size): Declare.
	(legacy_max_register_virtual_size): Declare.
	* config/sparc/tm-sparc.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/i386/tm-ptx.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Do not set
	max_register_raw_size or max_register_virtual_size.
@
text
@d1620 1
a1620 1
  set_gdbarch_frame_saved_pc (gdbarch, i386_frame_saved_pc);
@


1.116.4.1
log
@* i386-tdep.c (i386_frameless_signal_p): Removed.
(i386_frame_chain): Removed.
(i386_sigtramp_saved_pc, i386_sigtramp_saved_sp): Removed.
(i386_frame_saved_pc): Removed.
(i386_saved_pc_after_call): Use frame_unwind_register to find the
saved PC.
(i386_frame_init_saved_regs): Removed.
(i386_do_pop_frame, i386_pop_frame): Removed.
(i386_frame_cache): New function.
(i386_frame_pop, i386_frame_pc_unwind, i386_frame_id_unwind,
i386_frame_register_unwind): New functions.
(i386_frame_unwind): New variable.
(i386_frame_p): New function.
(i386_unwind_dummy_id, i386_save_dummy_frame_tos): New functions.
(i386_gdbarch_init): Don't set deprecated_init_frame_pc,
pop_frame, deprecated_frame_init_saved_regs, frame_chain and
frame_saved_pc.  Set unwind_dummy_id and save_dummy_frame_tos.
Call frame_unwind_append_predicate.
@
text
@d472 56
d529 1
a529 1
   not have a frame on the stack associated with it.  If it does not,
d541 51
d597 2
a598 1
  char buf[4];
d600 1
a600 3
  /* Our frame unwinder handles this just fine.  */
  frame_unwind_register (frame, PC_REGNUM, buf);
  return extract_address (buf, 4);
d677 66
a857 2

#include "frame-unwind.h"
d859 2
a860 49
#define regcache_cooked_write_unsigned regcache_raw_write_unsigned

#ifdef I386_REGNO_TO_SYMMETRY
#error "The Sequent Symmetry is no longer supported."
#endif

/* According to the System V ABI, the registers %ebp, %ebx, %edi, %esi
   and %esp "belong" to the calling function.  */

/* The maximum number of saved registers.  This should include all
   registers mentioned above, and %eip.  */
#define I386_NUM_SAVED_REGISTERS	9

struct i386_frame_cache
{
  CORE_ADDR saved_regs[I386_NUM_SAVED_REGISTERS];
  CORE_ADDR saved_sp;
  CORE_ADDR return_pc;
  int frameless;
};

/* Parse the first few instructions the function to see what registers
   were stored.
   
   We handle these cases:

   The startup sequence can be at the start of the function, or the
   function can start with a branch to startup code at the end.

   %ebp can be set up with either the 'enter' instruction, or "pushl
   %ebp, movl %esp, %ebp" (`enter' is too slow to be useful, but was
   once used in the System V compiler).

   Local space is allocated just below the saved %ebp by either the
   'enter' instruction, or by "subl $<size>, %esp".  'enter' has a 16
   bit unsigned argument for space to allocate, and the 'addl'
   instruction could have either a signed byte, or 32 bit immediate.

   Next, the registers used by this function are pushed.  With the
   System V compiler they will always be in the order: %edi, %esi,
   %ebx (and sometimes a harmless bug causes it to also save but not
   restore %eax); however, the code below is willing to see the pushes
   in any order, and will handle up to 8 of them.
 
   If the setup sequence is at the end of the function, then the next
   instruction will be a branch back to the start.  */

static struct i386_frame_cache *
i386_frame_cache (struct frame_info *frame, void **cachep)
d862 3
a864 4
  struct i386_frame_cache *cache;

  if (*cachep)
    return *cachep;
d866 2
a867 5
  cache = FRAME_OBSTACK_ZALLOC (struct i386_frame_cache);
  memset (cache->saved_regs, 0, sizeof (cache->saved_regs));
  cache->saved_sp = 0;
  cache->return_pc = 0;
  cache->frameless = 0;
d869 1
a869 3
  /* If this is a signal trampoline, get %esp and %eip from the
     signal context.  */
  if (get_frame_type (frame) == SIGTRAMP_FRAME)
a870 1
      struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d872 2
a873 15

      addr = tdep->sigcontext_addr (frame);
      cache->saved_regs[PC_REGNUM] = addr + tdep->sc_pc_offset;
      cache->saved_regs[SP_REGNUM] = addr + tdep->sc_sp_offset;
    }
  else
    {
      long locals = -1;
      CORE_ADDR pc;

      pc = get_pc_function_start (get_frame_pc (frame));
      if (pc != 0)
	locals = i386_get_frame_setup (pc);

      if (locals >= 0 && get_frame_pc (frame) > pc)
d875 2
a876 34
	  CORE_ADDR fp = get_frame_base (frame);
	  CORE_ADDR addr;
	  unsigned char op;
	  int i;

	  addr = fp - 4 - locals;
	  for (i = 0; i < I386_NUM_SAVED_REGISTERS; i++)
	    {
	      op = codestream_get ();
	      if (op < 0x50 || op > 0x57)
		break;

	      cache->saved_regs[op - 0x50] = addr;
	      addr -= 4;
	    }

	  cache->saved_regs[PC_REGNUM] = fp + 4;
	  cache->saved_regs[FP_REGNUM] = fp;
	  cache->saved_sp = fp + 8;
	}
      else
	{
	  char buf[4];

	  /* This function is either frameless or we're at the start
	     of the function and this function's frame hasn't been
	     setup yet.  In the latter case only %eip and %esp have
	     changed, and we can determine their previous values.  We
	     pretend we can do the same in the former case.  */
	  cache->frameless = 1;

	  frame_read_register (frame, SP_REGNUM, buf);
	  cache->saved_regs[PC_REGNUM] = extract_address (buf, 4);
	  cache->saved_sp = cache->saved_regs[PC_REGNUM] + 4;
d879 3
a881 34

  *cachep = cache;
  return cache;
}

static void
i386_frame_pop (struct frame_info *frame, void **cachep,
		struct regcache *regcache)
{
  CORE_ADDR fp = get_frame_base (frame);
  int regnum;
  char buf[4];
  ULONGEST val;

  gdb_assert (get_frame_type (frame) != DUMMY_FRAME);

  for (regnum = 0; regnum < I386_NUM_SAVED_REGISTERS; regnum++)
    {
      frame_unwind_register (frame, regnum, buf);
      regcache_cooked_write (regcache, regnum, buf);
    }

  /* Reset the direction flag.  */
  regcache_cooked_read_unsigned (regcache, PS_REGNUM, &val);
  val &= ~(1 << 10);
  regcache_cooked_write_unsigned (regcache, PS_REGNUM, val);

  /* The following sequence restores %ebp, %eip and %esp.  */
  read_memory (fp, buf, 4);
  regcache_cooked_write (regcache, FP_REGNUM, buf);
  read_memory (fp + 4, buf, 4);
  regcache_cooked_write (regcache, PC_REGNUM, buf);
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, fp + 8);

a884 120
static CORE_ADDR
i386_frame_pc_unwind (struct frame_info *frame, void **cachep)
{
  struct i386_frame_cache *cache = i386_frame_cache (frame, cachep);

  gdb_assert (get_frame_type (frame) != DUMMY_FRAME);

  if (cache->return_pc == 0)
    {
      char buf[4];

      frame_unwind_register (frame, PC_REGNUM, buf);
      cache->return_pc = extract_address (buf, 4);
    }

  return cache->return_pc;
}

static void
i386_frame_id_unwind (struct frame_info *frame, void **cachep,
		      struct frame_id *id)
{
  struct i386_frame_cache *cache = *cachep;

  gdb_assert (cache);
  gdb_assert (get_frame_type (frame) != DUMMY_FRAME);

  /* Start with a NULL frame ID.  */
  *id = null_frame_id;

  /* The frame's base is the address of a 4-byte word containing the
     calling frame's address.

     Signal trampolines don't have a meaningful frame.  The frame
     pointer value we use is actually the frame pointer of the calling
     frame -- that is, the frame which was in progress when the signal
     trampoline was entered.  GDB mostly treats this frame pointer
     value as a magic cookie.  We detect the case of a signal
     trampoline by testing for get_frame_type() == SIGTRAMP_FRAME,
     which is set based on PC_IN_SIGTRAMP.  */

  if (get_frame_type (frame) == SIGTRAMP_FRAME || cache->frameless)
    id->base = get_frame_base (frame);
  else if (!inside_entry_file (get_frame_pc (frame)))
    id->base = read_memory_unsigned_integer (get_frame_base (frame), 4);

  id->pc = cache->return_pc;
}

static void
i386_frame_register_unwind (struct frame_info *frame, void **cachep,
			    int regnum, int *optimizedp,
			    enum lval_type *lvalp, CORE_ADDR *addrp,
			    int *realnump, void *valuep)
{
  /* FIXME: kettenis/20030302: I don't understand why the cache isn't
     already initialized.  */
  struct i386_frame_cache *cache = i386_frame_cache (frame, cachep);

  gdb_assert (cache);
  gdb_assert (get_frame_type (frame) != DUMMY_FRAME);
  gdb_assert (regnum >= 0);

  if (regnum == SP_REGNUM && cache->saved_sp)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_address (valuep, 4, cache->saved_regs[SP_REGNUM]);
	}
      return;
    }

  if (regnum < I386_NUM_SAVED_REGISTERS && cache->saved_regs[regnum] != 0)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
	}
      return;
    }

  frame_register (frame, regnum, optimizedp, lvalp, addrp, realnump, valuep);
}

static struct frame_unwind i386_frame_unwind = {
  i386_frame_pop,
  i386_frame_pc_unwind,
  i386_frame_id_unwind,
  i386_frame_register_unwind
};

const struct frame_unwind *
i386_frame_p (CORE_ADDR pc)
{
  return &i386_frame_unwind;
}

static struct frame_id
i386_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  struct frame_id id;
  ULONGEST base;

  id.pc = frame_pc_unwind (next_frame);
  frame_unwind_unsigned_register (next_frame, FP_REGNUM, &base);
  id.base = base;
  return id;
}

d886 1
a886 1
i386_save_dummy_frame_tos (CORE_ADDR sp)
d888 1
a888 7
  /* We can't use the saved top-of-stack to find the right dummy frame
     when unwinding, since we can't reconstruct it properly if the
     dummy frame is the innermost frame.  To circumvent this, we fake
     a frame pointer here.  */

  regcache_cooked_write_unsigned (current_regcache, FP_REGNUM, sp);
  generic_save_dummy_frame_tos (sp);
d1509 4
d1594 1
d1601 1
d1611 5
d1619 2
a1631 3
  set_gdbarch_unwind_dummy_id (gdbarch, i386_unwind_dummy_id);
  set_gdbarch_save_dummy_frame_tos (gdbarch, i386_save_dummy_frame_tos);

a1637 2

  frame_unwind_append_predicate (gdbarch, i386_frame_p);
@


1.116.4.2
log
@* i386-tdep.c (regcache_cooked_write_unsigned): Remove define.
(i386_frame_cache): Cache PC.
(i386_frame_pop, i386_frame_pc_unwind): Remove.
(i386_unwind_pc): New function.
(i386_frame_id_unwind): Initialize cache if necessary.  Remove
related assertion.
(i386_frame_register_unwind): Remove FIXME and related assertion.
Add code that fakes a saved processor state with the direction
flag cleared.  Fix unwinding the stack register.
(struct i386_frame_unwind): Remove i386_frame_pop and
i386_frame_pc_unwind.
(i386_gdbarch_init): Set unwind_pc.
@
text
@d689 2
d809 16
a824 1
  if (cache->saved_regs[PC_REGNUM])
d826 8
a833 1
      char buf[4];
d835 6
a840 3
      read_memory (cache->saved_regs[PC_REGNUM], buf, 4);
      cache->return_pc = extract_address (buf, 4);
    }
d842 1
a842 2
  *cachep = cache;
  return cache;
d846 1
a846 1
i386_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
d848 11
a858 1
  char buf[4];
d860 1
a860 2
  frame_unwind_register (next_frame, PC_REGNUM, buf);
  return extract_address (buf, 4);
d867 1
a867 1
  struct i386_frame_cache *cache = i386_frame_cache (frame, cachep);
d869 1
d900 2
d904 1
a907 38
  /* The System V ABI says that:

     "The flags register contains the system flags, such as the
     direction flag and the carry flag.  The direction flag must be
     set to the forward (that is, zero) direction before entry and
     upon exit from a function.  Other user flags have no specified
     role in the standard calling sequence and are not preserved.

     To guarantee the "upon exit" part of that statement we fake a
     saved flags register that has its direction flag cleared.

     Note that GCC doesn't seem to rely on the fact that the direction
     flag is cleared after a function return; it always explicitly
     clears the flag before operations where it matters.

     FIXME: kettenis/20030316: I'm not quite sure whether this is the
     right thing to do.  The way we fake the flags register here makes
     it impossible to change it.  */

  if (regnum == PS_REGNUM)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  ULONGEST val;

	  /* Clear the direction flag.  */
	  frame_read_unsigned_register (frame, PS_REGNUM, &val);
	  val &= ~(1 << 10);
	  store_unsigned_integer (valuep, 4, val);
	}

      return;
    }

d917 1
a917 1
	  store_address (valuep, 4, cache->saved_sp);
d941 2
a1706 2

  set_gdbarch_unwind_pc (gdbarch, i386_unwind_pc);
@


1.116.4.3
log
@* i386-tdep.c (struct i386_frame_cache): Remove frameless.
(i386_frame_cache): Don't set CACHE->frameless.
(i386_frame_id_unwind): Simplify: Just unwind the frame pointer in
all cases.
@
text
@d705 1
d746 1
d799 1
d839 2
a840 14
  /* In principle, %ebp holds the frame pointer, which holds the base
     address for the current stack frame.  However, for functions that
     don't need it, the frame pointer is optional.  For these
     "frameless" functions the frame pointer is actaully the frame
     pointer of the calling frame.  Signal trampolines are just a
     special case of a "frameless" function.  They (usually) share
     their frame pointer with the frame that was in progress when the
     signal occurred.

     FIXME: kettenis/20030316: If we're at the start of a function,
     and this function's frame hasn't been setup yet, we essentially
     treat the function as frameless.  As a result, once the prologue
     of the function has been executed and the frame has been set up,
     the frame's base changes, which isn't good.  */
d842 12
a853 7
    if (!inside_entry_file (get_frame_pc (frame)))
    {
      char buf[4];

      frame_unwind_register (frame, FP_REGNUM, buf);
      id->base = extract_address (buf, 4);
    }
@


1.115
log
@* i386-tdep.c (i386_pe_skip_trampoline_code): Replace usage of
DEPRECATED_SYMBOL_NAME with SYMBOL_LINKAGE_NAME.
@
text
@d1561 2
a1562 2
  set_gdbarch_max_register_raw_size (gdbarch, I386_MAX_REGISTER_SIZE);
  set_gdbarch_max_register_virtual_size (gdbarch, I386_MAX_REGISTER_SIZE);
@


1.114
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_INIT_SAVED_REGS): Rename
	FRAME_INIT_SAVED_REGS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* stack.c (frame_info): Update.
	* sh-tdep.c (sh_find_callers_reg, sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info, sh64_init_extra_frame_info): Update.
	(sh64_get_saved_register, sh_pop_frame, sh64_pop_frame): Update.
	* ns32k-tdep.c (ns32k_pop_frame): Update.
	* mips-tdep.c (mips_pop_frame): Update.
	* m68hc11-tdep.c (m68hc11_pop_frame): Update.
	* ia64-tdep.c (ia64_frame_chain): Update.
	(ia64_frame_saved_pc, ia64_get_saved_register): Update.
	(ia64_frameless_function_invocation): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_pop_frame_regular): Update.
	* frame.h (struct frame_info): Update comment.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Rename macro.
	* frame.c (frame_saved_regs_register_unwind): Update.
	(frame_saved_regs_register_unwind): Update.
	(deprecated_generic_get_saved_register): Update.
	* cris-tdep.c: Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_INIT_SAVED_REGS):
	Rename macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_INIT_SAVED_REGS to DEPRECATED_FRAME_INIT_SAVED_REGS.
@
text
@d1296 1
a1296 1
      char *symname = indsym ? DEPRECATED_SYMBOL_NAME (indsym) : 0;
@


1.113
log
@2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_DUMMY_FRAME): Procedure with
	predicate.  Replaces PUSH_DUMMY_FRAME.
	* gdbarch.h, gdbarch.c: Regnerate.
	* valops.c (hand_function_call): Update.  Call
	generic_push_dummy_frame directly.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* inferior.h (PUSH_DUMMY_FRAME): Delete definition.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Don't set
	push_dummy_frame to generic_push_dummy_frame.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@d1601 1
a1601 1
  set_gdbarch_frame_init_saved_regs (gdbarch, i386_frame_init_saved_regs);
@


1.112
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@a1592 1
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
@


1.111
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_next_frame.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10200-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, sparc-tdep.c: Ditto.
	* v850-tdep.c, vax-tdep.c, x86-64-linux-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
@
text
@d1296 1
a1296 1
      char *symname = indsym ? SYMBOL_NAME (indsym) : 0;
@


1.110
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_base.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* mn10300-tdep.c, ns32k-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c: Ditto.
	* x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* config/h8500/tm-h8500.h, config/mn10200/tm-mn10200.h: Ditto.
	* config/sparc/tm-sparc.h: Ditto.
@
text
@d502 2
a503 1
  return (frame->next && get_frame_type (frame->next) == SIGTRAMP_FRAME
d585 1
a585 1
      CORE_ADDR sp = i386_sigtramp_saved_sp (frame->next);
d1374 2
a1375 2
  if (frame->next)
    return get_frame_base (frame->next) + sigcontext_offset;
@


1.109
log
@* i386-tdep.c (i386_get_longjmp_target): Make usable on x86-64.
* x86-64-tdep.c (x86_64_init_abi): Remove FIXME about
i386_get_longjmp_target.
@
text
@d515 1
a515 1
    return frame->frame;
d519 1
a519 1
    return frame->frame;
d522 1
a522 1
    return read_memory_unsigned_integer (frame->frame, 4);
d588 1
a588 1
  return read_memory_unsigned_integer (frame->frame + 4, 4);
d722 1
a722 1
      addr = fip->frame - 4 - locals;
d738 2
a739 2
  get_frame_saved_regs (fip)[PC_REGNUM] = fip->frame + 4;
  get_frame_saved_regs (fip)[FP_REGNUM] = fip->frame;
d1374 1
a1374 1
    return frame->next->frame + sigcontext_offset;
@


1.108
log
@	* arm-tdep.c (arm_frame_chain_valid):  Remove unnecessary test.
	* d10v-tdep.c (d10v_frame_chain_valid): Remove unnecessary tests.
	* hppa-tdep.c (hppa_frame_chain_valid): Remove unnecessary test.

	* blockframe.c: Include "gdbcmd.h" and "command.h".
	(backtrace_below_main): New variable.
	(file_frame_chain_valid, func_frame_chain_valid)
	(nonnull_frame_chain_valid, generic_file_frame_chain_valid)
	(generic_func_frame_chain_valid): Remove functions.
	(frame_chain_valid, do_flush_frames_sfunc): New functions.
	(_initialize_blockframe): New function.
	* Makefile.in (blockframe.o): Update dependencies.
	* frame.c (frame_saved_regs_id_unwind, get_prev_frame): Remove FIXME
	comment.  Call frame_chain_valid ().
	* frame.h: Remove old prototypes.  Add prototype for
	frame_chain_valid and update comments to match.
	* gdbarch.sh: Change FRAME_CHAIN_VALID into a predicated function.
	Remove old comment.
	* gdbarch.h: Regenerated.
	* gdbarch.c: Regenerated.

Plus updates to all other targets not to provide a FRAME_CHAIN_VALID.
@
text
@d894 1
a894 1
   This address is copied into PC.  This routine returns true on
d900 1
a900 1
  char buf[4];
d903 1
d911 1
a911 1
  if (target_read_memory (sp + 4, buf, 4))
d914 2
a915 2
  jb_addr = extract_address (buf, 4);
  if (target_read_memory (jb_addr + jb_pc_offset, buf, 4))
d918 1
a918 1
  *pc = extract_address (buf, 4);
@


1.107
log
@	* arch-utils.c (gdbarch_info_init): Set osabi to
	GDB_OSABI_UNINITIALIZED.
	* gdbarch.sh: Add osabi to struct gdbarch and to struct
	gdbarch_info.  Include "osabi.h" in gdbarch.c.  Check osabi
	in gdbarch_list_lookup_by_info and in gdbarch_update_p.
	* gdbarch.c: Regenerated.
	* gdbarch.h: Regenerated.
	* osabi.c (gdbarch_lookup_osabi): Return GDB_OSABI_UNINITIALIZED if
	there's no BFD.
	(gdbarch_init_osabi): Remove osabi argument; use info.osabi.
	* osabi.h (enum gdb_osabi): Move to defs.h.
	(gdbarch_init_osabi): Update prototype.
	* defs.h (enum gdb_osabi): Moved here.
	* Makefile.in: Update dependencies.

Plus updates to alpha, arm, hppa, i386, mips, ns32k, ppc, sh, sparc, and vax
ports to match.
@
text
@a1410 3
  /* FIXME: kettenis/20020511: Why do we override this function here?  */
  set_gdbarch_frame_chain_valid (gdbarch, generic_func_frame_chain_valid);

a1437 3
  /* FIXME: kettenis/20020511: Why do we override this function here?  */
  set_gdbarch_frame_chain_valid (gdbarch, generic_func_frame_chain_valid);

a1618 1
  set_gdbarch_frame_chain_valid (gdbarch, generic_file_frame_chain_valid);
@


1.106
log
@2003-01-03  Andrew Cagney  <ac131313@@redhat.com>

	* alpha-tdep.c: Use get_frame_saved_regs.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d42 1
a1502 1
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
d1504 4
a1507 14
  /* Try to determine the OS ABI of the object we're loading.  */
  if (info.abfd != NULL)
    osabi = gdbarch_lookup_osabi (info.abfd);

  /* Find a candidate among extant architectures.  */
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      /* Make sure the OS ABI selection matches.  */
      tdep = gdbarch_tdep (arches->gdbarch);
      if (tdep && tdep->osabi == osabi)
        return arches->gdbarch;
    }
a1516 2
  tdep->osabi = osabi;

d1643 1
a1643 1
  gdbarch_init_osabi (info, gdbarch, osabi);
@


1.105
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c: Use get_frame_pc and deprecated_update_frame_pc_hack
	frame accessor methods.
	* alpha-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Ditto.
	* s390-tdep.c, sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* z8k-tdep.c: Ditto.
@
text
@d710 1
a710 1
  if (fip->saved_regs)
d729 1
a729 1
	  fip->saved_regs[I386_REGNO_TO_SYMMETRY (op - 0x50)] = addr;
d731 1
a731 1
	  fip->saved_regs[op - 0x50] = addr;
d737 2
a738 2
  fip->saved_regs[PC_REGNUM] = fip->frame + 4;
  fip->saved_regs[FP_REGNUM] = fip->frame;
d870 1
a870 1
      addr = frame->saved_regs[regnum];
@


1.104
log
@* osabi.c: Include "gdb_assert.h" and "gdb_string.h".
(struct gdb_osabi_handler): Remove member `arch'.  Add member
`arch_info'.
(gdbarch_register_osabi): Add new argument `machine'.  Use ot to
construct a `struct bfd_arch_info' and store it in the `struct
gdb_osabi_handler' that is created.
(gdbarch_init_osabi): Check for compatibility based on machine
type and architecture.
* osabi.h (gdbarch_register_osabi): Adjust prototype and update
comment.
* alpha-linux-tdep.c (_initialize_alpha_linux_tdep): Add 0 as
second argument in call to gdbarch_register_osabi.
* alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Likewise.
* alphafbsd-tdep.c (_initialize_alphafbsd_tdep): Likewise.
* alphanbsd-tdep.c (_initialize_alphanbsd_tdep): Likewise.
* arm-linux-tdep.c (_initialize_arm_linux_tdep): Likewise.
* arm-tdep.c (_initialize_arm_tdep): Likewise.
* armnbsd-tdep.c (_initialize_armnbsd_tdep): Likewise.
* hppa-hpux-tdep.c (_initialize_hppa_hpux_tdep): Likewise.
* i386-interix-tdep.c (_initialize_i386_interix_tdep): Likewise.
* i386-linux-tdep.c (_initialize_i386_linux_tdep): Likewise.
* i386-sol2-tdep.c (_initialize_i386_sol2_tdep): Likewise.
* i386-tdep.c (_initialize_i386_tdep): Likewise.
* i386bsd-tdep.c (_initialize_i386bsd_tdep): Likewise.
* i386gnu-tdep.c (_initialize_i386gnu_tdep): Likewise.
* i386ly-tdep.c (_initialize_i386lynx_tdep): Renamed from
_initialize_i386bsd_tdep and updated likewise.
* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Likewise.
* i386obsd-tdep.c (_initialize_i386obsd_tdep): Likewise.
* mips-irix-tdep.c (_initialize_mips_irix_tdep): Likewise.
* mips-linux-tdep.c (_initialize_mips_linux_tdep): Likewise.
* mipsnbsd-tdep.c (_initialize_mipsnbsd__tdep): Likewise.
* ns32knbsd-tdep.c (_initialize_ns32kmnsd_tdep): Likewise.
* ppc-linux-tdep.c (_initialize_ppc_linux_tdep): Likewise.
* ppcnbsd-tdep.c (_initialize_ppcnbsd_tdep): Likewise.
* shnbsd-tdep.c (_initialize_shnbsd_tdep): Likewise.
* sparcnbsd-tdep.c (_initialize_sparcnbsd_tdep): Likewise.
@
text
@d503 1
a503 1
	      || frame->pc == get_pc_function_start (frame->pc)));
d513 1
a513 1
  if (pc_in_dummy_frame (frame->pc))
d520 1
a520 1
  if (! inside_entry_file (frame->pc))
d570 1
a570 1
  if (pc_in_dummy_frame (frame->pc))
d715 1
a715 1
  pc = get_pc_function_start (fip->pc);
d1358 1
a1358 1
  find_pc_partial_function (frame->pc, &name, NULL, NULL);
@


1.103
log
@* i386-tdep.c: Include "dummy-frame.h".
(i386_frame_chain, i386_frame_saved_pc): Replace
DEPRECATED_PC_IN_CALL_DUMMY with call to pc_in_dummy_frame.
(i386_gdbarch_init): Don't set deprecated_pc_in_call_dummy.
@
text
@d1718 1
a1718 1
  gdbarch_register_osabi (bfd_arch_i386, GDB_OSABI_SVR4,
d1720 1
a1720 1
  gdbarch_register_osabi (bfd_arch_i386, GDB_OSABI_GO32,
d1722 1
a1722 1
  gdbarch_register_osabi (bfd_arch_i386, GDB_OSABI_NETWARE,
@


1.102
log
@2002-12-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
	Change to a function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Update.  Test
	DEPRECATED_INIT_FRAME_PC_P.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/mn10200/tm-mn10200.h (DEPRECATED_INIT_FRAME_PC): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* arm-tdep.c: Update comments.
	* h8300-tdep.c (h8300_gdbarch_init): Explicitly set init_frame_pc.
	* config/m32r/tm-m32r.h (DEPRECATED_INIT_FRAME_PC): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC_FIRST): Delete macro.
	(DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
@
text
@d41 1
d513 1
a513 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, 0, 0))
d570 1
a570 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, 0, 0))
a1600 2

  set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
@


1.101
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d1522 4
@


1.100
log
@2002-11-27  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_LOCATION): Default to AT_ENTRY_POINT.
	(USE_GENERIC_DUMMY_FRAMES): Default to true.
	(PC_IN_CALL_DUMMY): Default to generic_pc_in_call_dummy.
	* gdbarch.c, gdbarch.h: Re-generate.
	* inferior.h (USE_GENERIC_DUMMY_FRAMES): Delete macro definition.
	(CALL_DUMMY_LOCATION): Delete macro definition.
	(PC_IN_CALL_DUMMY): Delete macro definitions.

	* arm-tdep.c (arm_gdbarch_init): Do not set pc_in_call_dummy,
	default is already generic_pc_in_call_dummy.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* arm-tdep.c (arm_gdbarch_init): Do not set
	use_generic_dummy_frames, default is already 1.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_location, default is already AT_ENTRY_POINT.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d512 1
a512 1
  if (PC_IN_CALL_DUMMY (frame->pc, 0, 0))
d569 1
a569 1
  if (PC_IN_CALL_DUMMY (frame->pc, 0, 0))
d1597 1
a1597 1
  set_gdbarch_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
@


1.99
log
@2002-11-26  Andrew Cagney  <ac131313@@redhat.com>

	* inferior.h (deprecated_pc_in_call_dummy_before_text_end): Rename
	pc_in_call_dummy_before_text_end
	(deprecated_pc_in_call_dummy_after_text_end): Rename
	pc_in_call_dummy_after_text_end.
	(deprecated_pc_in_call_dummy_on_stack): Rename
	pc_in_call_dummy_on_stack.
	(deprecated_pc_in_call_dummy_at_entry_point): Rename
	pc_in_call_dummy_at_entry_point.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (PC_IN_CALL_DUMMY): Update.
	* blockframe.c (deprecated_pc_in_call_dummy_before_text_end)
	(deprecated_pc_in_call_dummy_after_text_end)
	(deprecated_pc_in_call_dummy_on_stack)
	(deprecated_pc_in_call_dummy_at_entry_point): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@a1579 2
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);

a1580 1
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
@


1.98
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@d1600 1
a1600 1
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_at_entry_point);
@


1.97
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_ADDRESS, FRAME_LOCALS_ADDRESS): Default
	to default_frame_address.
	* gdbarch.h, gdbarch.c: Re-generate.

	* d10v-tdep.c (d10v_gdbarch_init): Do not set frame_args_address
	or frame_locals_address to default_frame_address.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.

	* cris-tdep.c (cris_frame_args_address): Delete function.
	(cris_frame_locals_address): Delete function.
	(cris_gdbarch_init): Do not set frame_args_address or
	frame_locals_address.
@
text
@d863 1
a863 1
  fp = FRAME_FP (frame);
@


1.96
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (enum frame_type): Define.
	(get_frame_type): Declare.
	(struct frame_info): Add field `type'.  Delete field
	signal_handler_caller.
	(deprecated_set_frame_signal_handler_caller): Declare.
	* frame.c (get_frame_type): New function.
	(deprecated_set_frame_type): New function.
	(create_new_frame): Set the frame's type.
	(get_prev_frame): Similar.
	* sparc-tdep.c: Use get_frame_type instead of signal_handler_caller.
	* s390-tdep.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* x86-64-linux-tdep.c: Ditto.
	* vax-tdep.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* i386-interix-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* m68k-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* cris-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* i386-tdep.c: Ditto.
	* stack.c: Ditto.
	* ada-lang.c: Ditto.
	* blockframe.c: Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Use
	deprecated_set_frame_type instead of signal_handler_caller.
	* ppc-linux-tdep.c (ppc_linux_init_extra_frame_info): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	* breakpoint.h: Delete FIXME suggesting get_frame_type.

Index: tui/ChangeLog
2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	signal_handler_caller.
@
text
@a1638 2
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);
@


1.95
log
@2002-11-15  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (generic_unwind_get_saved_register): Make static.
	* frame.h (generic_unwind_get_saved_register): Delete declaration.
	* avr-tdep.c (avr_gdbarch_init): Do not set get_saved_register,
	defaults to generic_unwind_get_saved_register.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* config/mn10200/tm-mn10200.h (GET_SAVED_REGISTER): Delete macro.
@
text
@d475 2
a476 2
   looking at the SIGNAL_HANDLER_CALLER field, which is set based on
   PC_IN_SIGTRAMP.
d481 4
a484 5
   this case by seeing whether the next frame has
   SIGNAL_HANDLER_CALLER set, and, if it does, checking whether the
   current frame is actually frameless.  In this case, we need to get
   the PC by looking at the SP register value stored in the signal
   context.
d500 1
a500 1
  return (frame->next && frame->next->signal_handler_caller
d515 1
a515 1
  if (frame->signal_handler_caller
d532 1
a532 1
  if (frame->signal_handler_caller)
d577 1
a577 1
  if (frame->signal_handler_caller)
d594 1
a594 1
  if (frame->signal_handler_caller)
@


1.94
log
@2002-11-08  Andrew Cagney  <ac131313@@redhat.com>

	* i386-linux-tdep.c: Include "reggroups.h".
	(i386_linux_register_reggroup_p): New function.
	(i386_linux_init_abi): Set register_reggroup_p to
	i386_linux_register_reggroup_p.
	* i386-tdep.h (i386_register_reggroup_p): Declare.
	* i386-tdep.c: Include "reggroups.h".
	(i386_init_reggroups): New function.
	(i386_add_reggroups): New function.
	(i386_register_reggroup_p): New function.
	(i386_sse_reggroup, i386_mmx_reggroup): New variables.
	(_initialize_i386_tdep): Call i386_init_reggroups.
	(i386_gdbarch_init): Set register_reggroup_p and add in the i386
	specific reggroups.
@
text
@a1600 2
  set_gdbarch_get_saved_register (gdbarch, generic_unwind_get_saved_register);

@


1.93
log
@       * i386-tdep.c (i386_frameless_signal_p): Make non static for
       the benefit of the interix target.
       * i386-tdep.h (i386_frameless_signal_p): Declare.
@
text
@d40 1
d1447 50
d1655 4
d1729 3
@


1.92
log
@2002-11-06  Andrew Cagney  <cagney@@redhat.com>

	* i386-tdep.c (i386_mmx_regnum_p): Rename mmx_regnum_p.  Update
	all callers.
	(i386_fp_regnum_p): New function.  Use instead of FP_REGNUM_P.
	(i386_fpc_regnum_p): New function.  Use instead of FPC_REGNUM_P.
	(i386_sse_regnum_p): New function.  Use instead of SSE_REGNUM_P.
	(i386_mxcsr_regnum_p): new function.  Use instead of
	MXCSR_REGNUM_P.
	* i386-tdep.h (SSE_REGNUM_P): Delete macro.
	(i386_sse_regnum_p): Declare.
	(i386_mxcsr_regnum_p): Declare.
	(FP_REGNUM_P, FPC_REGNUM_P): Delete macros.
	(i386_fp_regnum_p, i386_fpc_regnum_p): Declare.
	(IS_FP_REGNUM): Update definition.
	(IS_FPU_CTRL_REGNUM): Update definition..
	(IS_SSE_REGNUM): Update definition..
	* i386v-nat.c (register_u_addr): Update.
	* go32-nat.c (fetch_register): Update.
	(store_register): Update.
@
text
@d497 1
a497 1
static int
@


1.91
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d73 1
a73 1
mmx_regnum_p (int reg)
d78 32
d117 1
a117 1
  if (mmx_regnum_p (reg))
d1133 1
a1133 1
  if (FP_REGNUM_P (regnum))
d1136 1
a1136 1
  if (SSE_REGNUM_P (regnum))
d1139 1
a1139 1
  if (mmx_regnum_p (regnum))
d1166 1
a1166 1
  if (mmx_regnum_p (regnum))
d1182 1
a1182 1
  if (mmx_regnum_p (regnum))
d1206 1
a1206 1
  return FP_REGNUM_P (regnum);
d1216 1
a1216 1
  gdb_assert (FP_REGNUM_P (regnum));
d1239 1
a1239 1
  gdb_assert (FP_REGNUM_P (regnum));
@


1.90
log
@* i386-tdep.c (i386_frame_saved_pc): Replace call to
deprecated_read_register_dummy with
frame_unwind_unsigned_register.
@
text
@d841 1
a841 1
	  write_register_gen (regnum, regbuf);
@


1.89
log
@* i386-tdep.c (i386_extract_struct_value_address): Use
regcache_raw_read_unsigned instead of
regcache_cooked_read_unsigned since we know that the register
we're reading isn't a pseudo register.  Rename variable 'val' into
the more descriptive 'addr'.
@
text
@d538 6
a543 2
    return deprecated_read_register_dummy (frame->pc, frame->frame,
					   PC_REGNUM);
@


1.88
log
@2002-09-17  Andrew Cagney  <cagney@@redhat.com>

	* h8300-tdep.c (h8300_frame_chain):
	(h8300_frame_saved_pc):

	* blockframe.c (deprecated_read_register_dummy): Rename
	generic_read_register_dummy.
	* frame.c (frame_unwind_signed_register): New function.
	(frame_unwind_unsigned_register): New function.
	* frame.h (frame_unwind_signed_register): Declare.
	(frame_unwind_unsigned_register): Declare.
	(deprecated_read_register_dummy): Rename
	generic_read_register_dummy.

	* xstormy16-tdep.c (xstormy16_frame_saved_pc): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	* s390-tdep.c (s390_frame_saved_pc_nofix): Update.
	(s390_frame_chain): Update.
	* v850-tdep.c (v850_find_callers_reg): Update.
	(v850_frame_saved_pc): Update.
	* m32r-tdep.c (m32r_init_extra_frame_info): Update.
	(m32r_find_callers_reg): Update.
	(m32r_frame_saved_pc): Update.
	* sh-tdep.c (sh_find_callers_reg): Update.
	(sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info): Update.
	(sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* mcore-tdep.c (mcore_find_callers_reg): Update.
	(mcore_frame_saved_pc): Update.
	(mcore_init_extra_frame_info): Update.
	* i386-tdep.c (i386_frame_saved_pc): Update.
	* ia64-tdep.c (ia64_frame_saved_pc): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_init_extra_frame_info): Update.
	* d10v-tdep.c (d10v_frame_saved_pc): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_frame_chain): Update.
	(avr_init_extra_frame_info): Update.
	(avr_frame_saved_pc): Update.
	* arm-tdep.c (arm_find_callers_reg): Update.
	(arm_init_extra_frame_info): Update.
	(arm_frame_saved_pc): Update.
@
text
@d1042 3
a1044 3
/* Extract from an array REGBUF containing the (raw) register state
   the address in which a function should return its structure value,
   as a CORE_ADDR.  */
d1049 4
a1052 12
  /* NOTE: cagney/2002-08-12: Replaced a call to
     regcache_raw_read_as_address() with a call to
     regcache_cooked_read_unsigned().  The old, ...as_address function
     was eventually calling extract_unsigned_integer (via
     extract_address) to unpack the registers value.  The below is
     doing an unsigned extract so that it is functionally equivalent.
     The read needs to be cooked as, otherwise, it will never
     correctly return the value of a register in the [NUM_REGS
     .. NUM_REGS+NUM_PSEUDO_REGS) range.  */
  ULONGEST val;
  regcache_cooked_read_unsigned (regcache, LOW_RETURN_REGNUM, &val);
  return val;
@


1.88.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d24 1
a24 6
#include "arch-utils.h"
#include "command.h"
#include "dummy-frame.h"
#include "dwarf2-frame.h"
#include "doublest.h"
#include "floatformat.h"
a25 2
#include "frame-base.h"
#include "frame-unwind.h"
a26 1
#include "gdbcmd.h"
d29 2
a30 4
#include "osabi.h"
#include "regcache.h"
#include "reggroups.h"
#include "regset.h"
d33 5
a37 1
#include "target.h"
a38 2
#include "dis-asm.h"

a39 1
#include "gdb_string.h"
a45 1

a60 2
static const int i386_num_register_names = ARRAY_SIZE (i386_register_names);

d68 3
a70 2

static const int i386_num_mmx_regs = ARRAY_SIZE (i386_mmx_names);
d73 1
a73 1
i386_mmx_regnum_p (struct gdbarch *gdbarch, int regnum)
d75 1
a75 66
  int mm0_regnum = gdbarch_tdep (gdbarch)->mm0_regnum;

  if (mm0_regnum < 0)
    return 0;

  return (regnum >= mm0_regnum && regnum < mm0_regnum + i386_num_mmx_regs);
}

/* SSE register?  */

static int
i386_sse_regnum_p (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

#define I387_ST0_REGNUM tdep->st0_regnum
#define I387_NUM_XMM_REGS tdep->num_xmm_regs

  if (I387_NUM_XMM_REGS == 0)
    return 0;

  return (I387_XMM0_REGNUM <= regnum && regnum < I387_MXCSR_REGNUM);

#undef I387_ST0_REGNUM
#undef I387_NUM_XMM_REGS
}

static int
i386_mxcsr_regnum_p (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

#define I387_ST0_REGNUM tdep->st0_regnum
#define I387_NUM_XMM_REGS tdep->num_xmm_regs

  if (I387_NUM_XMM_REGS == 0)
    return 0;

  return (regnum == I387_MXCSR_REGNUM);

#undef I387_ST0_REGNUM
#undef I387_NUM_XMM_REGS
}

#define I387_ST0_REGNUM (gdbarch_tdep (current_gdbarch)->st0_regnum)
#define I387_MM0_REGNUM (gdbarch_tdep (current_gdbarch)->mm0_regnum)
#define I387_NUM_XMM_REGS (gdbarch_tdep (current_gdbarch)->num_xmm_regs)

/* FP register?  */

int
i386_fp_regnum_p (int regnum)
{
  if (I387_ST0_REGNUM < 0)
    return 0;

  return (I387_ST0_REGNUM <= regnum && regnum < I387_FCTRL_REGNUM);
}

int
i386_fpc_regnum_p (int regnum)
{
  if (I387_ST0_REGNUM < 0)
    return 0;

  return (I387_FCTRL_REGNUM <= regnum && regnum < I387_XMM0_REGNUM);
d83 6
a88 5
  if (i386_mmx_regnum_p (current_gdbarch, reg))
    return i386_mmx_names[reg - I387_MM0_REGNUM];

  if (reg >= 0 && reg < i386_num_register_names)
    return i386_register_names[reg];
d90 1
a90 1
  return NULL;
d102 1
a102 1
      /* General-purpose registers.  */
d108 1
a108 1
      return reg - 12 + I387_ST0_REGNUM;
d113 1
a113 1
      return reg - 21 + I387_XMM0_REGNUM;
d118 1
a118 1
      return reg - 29 + I387_MM0_REGNUM;
d135 1
a135 1
      /* General-purpose registers.  */
d141 1
a141 1
      return reg - 11 + I387_ST0_REGNUM;
a151 4

#undef I387_ST0_REGNUM
#undef I387_MM0_REGNUM
#undef I387_NUM_XMM_REGS
a164 1

d166 41
a206 5
/* Use the program counter to determine the contents and size of a
   breakpoint instruction.  Return a pointer to a string of bytes that
   encode a breakpoint instruction, store the length of the string in
   *LEN and optionally adjust *PC to point to the correct memory
   location for inserting the breakpoint.
d208 5
a212 2
   On the i386 we have a single breakpoint that fits in a single byte
   and can be inserted anywhere.
d214 2
a215 4
   This function is 64-bit safe.  */
   
static const unsigned char *
i386_breakpoint_from_pc (CORE_ADDR *pc, int *len)
d217 6
a222 4
  static unsigned char break_insn[] = { 0xcc };	/* int 3 */
  
  *len = sizeof (break_insn);
  return break_insn;
a223 4

#ifdef I386_REGNO_TO_SYMMETRY
#error "The Sequent Symmetry is no longer supported."
#endif
d225 2
a226 28
/* According to the System V ABI, the registers %ebp, %ebx, %edi, %esi
   and %esp "belong" to the calling function.  Therefore these
   registers should be saved if they're going to be modified.  */

/* The maximum number of saved registers.  This should include all
   registers mentioned above, and %eip.  */
#define I386_NUM_SAVED_REGS	I386_NUM_GREGS

struct i386_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  CORE_ADDR sp_offset;
  CORE_ADDR pc;

  /* Saved registers.  */
  CORE_ADDR saved_regs[I386_NUM_SAVED_REGS];
  CORE_ADDR saved_sp;
  int pc_in_eax;

  /* Stack space reserved for local variables.  */
  long locals;
};

/* Allocate and initialize a frame cache.  */

static struct i386_frame_cache *
i386_alloc_frame_cache (void)
d228 1
a228 1
  struct i386_frame_cache *cache;
d230 5
d236 1
a236 1
  cache = FRAME_OBSTACK_ZALLOC (struct i386_frame_cache);
d238 5
a242 14
  /* Base address.  */
  cache->base = 0;
  cache->sp_offset = -4;
  cache->pc = 0;

  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %ebp is supposed to be stored).  */
  for (i = 0; i < I386_NUM_SAVED_REGS; i++)
    cache->saved_regs[i] = -1;
  cache->saved_sp = 0;
  cache->pc_in_eax = 0;

  /* Frameless until proven otherwise.  */
  cache->locals = -1;
d244 2
a245 5
  return cache;
}

/* If the instruction at PC is a jump, return the address of its
   target.  Otherwise, return PC.  */
d247 1
a247 6
static CORE_ADDR
i386_follow_jump (CORE_ADDR pc)
{
  unsigned char op;
  long delta = 0;
  int data16 = 0;
d249 2
a250 2
  op = read_memory_unsigned_integer (pc, 1);
  if (op == 0x66)
d252 1
a253 1
      op = read_memory_unsigned_integer (pc + 1, 1);
d256 1
a256 1
  switch (op)
d262 2
a263 1
	  delta = read_memory_integer (pc + 2, 2);
d267 1
a267 1
	  delta += 4;
d271 2
a272 1
	  delta = read_memory_integer (pc + 1, 4);
d274 1
a274 2
	  /* Include the size of the jmp instruction.  */
	  delta += 5;
d279 3
a281 1
      delta = read_memory_integer (pc + data16 + 1, 1);
d283 1
a283 1
      delta += data16 + 2;
d286 2
d289 2
a290 2
  return pc + delta;
}
d292 2
a293 5
/* Check whether PC points at a prologue for a function returning a
   structure or union.  If so, it updates CACHE and returns the
   address of the first instruction after the code sequence that
   removes the "hidden" argument from the stack or CURRENT_PC,
   whichever is smaller.  Otherwise, return PC.  */
d295 2
a296 3
static CORE_ADDR
i386_analyze_struct_return (CORE_ADDR pc, CORE_ADDR current_pc,
			    struct i386_frame_cache *cache)
a297 13
  /* Functions that return a structure or union start with:

        popl %eax             0x58
        xchgl %eax, (%esp)    0x87 0x04 0x24
     or xchgl %eax, 0(%esp)   0x87 0x44 0x24 0x00

     (the System V compiler puts out the second `xchg' instruction,
     and the assembler doesn't try to optimize it, so the 'sib' form
     gets generated).  This sequence is used to get the address of the
     return buffer for a function that returns a structure.  */
  static unsigned char proto1[3] = { 0x87, 0x04, 0x24 };
  static unsigned char proto2[4] = { 0x87, 0x44, 0x24, 0x00 };
  unsigned char buf[4];
d300 1
a300 2
  if (current_pc <= pc)
    return pc;
d302 1
a302 1
  op = read_memory_unsigned_integer (pc, 1);
d304 1
a304 2
  if (op != 0x58)		/* popl %eax */
    return pc;
d306 24
a329 3
  read_memory (pc + 1, buf, 4);
  if (memcmp (buf, proto1, 3) != 0 && memcmp (buf, proto2, 4) != 0)
    return pc;
d331 2
a332 4
  if (current_pc == pc)
    {
      cache->sp_offset += 4;
      return current_pc;
d335 1
a335 1
  if (current_pc == pc + 1)
d337 1
a337 9
      cache->pc_in_eax = 1;
      return current_pc;
    }
  
  if (buf[1] == proto1[1])
    return pc + 4;
  else
    return pc + 5;
}
d339 3
a341 8
static CORE_ADDR
i386_skip_probe (CORE_ADDR pc)
{
  /* A function may start with

        pushl constant
        call _probe
	addl $4, %esp
d343 1
a343 3
     followed by

        pushl %ebp
d345 1
a345 3
     etc.  */
  unsigned char buf[8];
  unsigned char op;
d347 3
a349 5
  op = read_memory_unsigned_integer (pc, 1);

  if (op == 0x68 || op == 0x6a)
    {
      int delta;
d351 3
a353 2
      /* Skip past the `pushl' instruction; it has either a one-byte or a
	 four-byte operand, depending on the opcode.  */
d355 1
a355 1
	delta = 5;
d357 2
a358 1
	delta = 2;
d360 3
a362 3
      /* Read the following 8 bytes, which should be `call _probe' (6
	 bytes) followed by `addl $4,%esp' (2 bytes).  */
      read_memory (pc + delta, buf, sizeof (buf));
d364 3
a366 1
	pc += delta + sizeof (buf);
a368 21
  return pc;
}

/* Check whether PC points at a code that sets up a new stack frame.
   If so, it updates CACHE and returns the address of the first
   instruction after the sequence that sets removes the "hidden"
   argument from the stack or CURRENT_PC, whichever is smaller.
   Otherwise, return PC.  */

static CORE_ADDR
i386_analyze_frame_setup (CORE_ADDR pc, CORE_ADDR current_pc,
			  struct i386_frame_cache *cache)
{
  unsigned char op;
  int skip = 0;

  if (current_pc <= pc)
    return current_pc;

  op = read_memory_unsigned_integer (pc, 1);

d371 2
a372 48
      /* Take into account that we've executed the `pushl %ebp' that
	 starts this instruction sequence.  */
      cache->saved_regs[I386_EBP_REGNUM] = 0;
      cache->sp_offset += 4;

      /* If that's all, return now.  */
      if (current_pc <= pc + 1)
	return current_pc;

      op = read_memory_unsigned_integer (pc + 1, 1);

      /* Check for some special instructions that might be migrated
	 by GCC into the prologue.  We check for

	    xorl %ebx, %ebx
	    xorl %ecx, %ecx
	    xorl %edx, %edx
	    xorl %eax, %eax

	 and the equivalent

	    subl %ebx, %ebx
	    subl %ecx, %ecx
	    subl %edx, %edx
	    subl %eax, %eax

	 Make sure we only skip these instructions if we later see the
	 `movl %esp, %ebp' that actually sets up the frame.  */
      while (op == 0x29 || op == 0x31)
	{
	  op = read_memory_unsigned_integer (pc + skip + 2, 1);
	  switch (op)
	    {
	    case 0xdb:	/* %ebx */
	    case 0xc9:	/* %ecx */
	    case 0xd2:	/* %edx */
	    case 0xc0:	/* %eax */
	      skip += 2;
	      break;
	    default:
	      return pc + 1;
	    }

	  op = read_memory_unsigned_integer (pc + skip + 1, 1);
	}

      /* Check for `movl %esp, %ebp' -- can be written in two ways.  */
      switch (op)
d375 2
a376 2
	  if (read_memory_unsigned_integer (pc + skip + 2, 1) != 0xec)
	    return pc + 1;
d379 2
a380 2
	  if (read_memory_unsigned_integer (pc + skip + 2, 1) != 0xe5)
	    return pc + 1;
d383 1
a383 1
	  return pc + 1;
a384 12

      /* OK, we actually have a frame.  We just don't know how large
	 it is yet.  Set its size to zero.  We'll adjust it if
	 necessary.  We also now commit to skipping the special
	 instructions mentioned before.  */
      cache->locals = 0;
      pc += skip;

      /* If that's all, return now.  */
      if (current_pc <= pc + 3)
	return current_pc;

d387 1
a387 1
	    subl $XXX, %esp
d391 1
a391 1
      op = read_memory_unsigned_integer (pc + 3, 1);
d395 2
a396 1
	  if (read_memory_unsigned_integer (pc + 4, 1) != 0xec)
d398 7
a404 6
	    return pc + 3;

	  /* `subl' with signed byte immediate (though it wouldn't make
	     sense to be negative).  */
	  cache->locals = read_memory_integer (pc + 5, 1);
	  return pc + 6;
d408 1
d410 2
a411 1
	  if (read_memory_unsigned_integer (pc + 4, 1) != 0xec)
d413 4
a416 2
	    return pc + 3;

d418 2
a419 2
	  cache->locals = read_memory_integer (pc + 5, 4);
	  return pc + 9;
d423 1
a423 2
	  /* Some instruction other than `subl'.  */
	  return pc + 3;
d426 1
a426 1
  else if (op == 0xc8)		/* enter $XXX */
d428 36
a463 3
      cache->locals = read_memory_unsigned_integer (pc + 1, 2);
      return pc + 4;
    }
d465 6
a470 1
  return pc;
d473 3
a475 4
/* Check whether PC points at code that saves registers on the stack.
   If so, it updates CACHE and returns the address of the first
   instruction after the register saves or CURRENT_PC, whichever is
   smaller.  Otherwise, return PC.  */
d478 1
a478 2
i386_analyze_register_saves (CORE_ADDR pc, CORE_ADDR current_pc,
			     struct i386_frame_cache *cache)
d480 2
a481 3
  CORE_ADDR offset = 0;
  unsigned char op;
  int i;
d483 3
a485 7
  if (cache->locals > 0)
    offset -= cache->locals;
  for (i = 0; i < 8 && pc < current_pc; i++)
    {
      op = read_memory_unsigned_integer (pc, 1);
      if (op < 0x50 || op > 0x57)
	break;
d487 2
a488 5
      offset -= 4;
      cache->saved_regs[op - 0x50] = offset;
      cache->sp_offset += 4;
      pc++;
    }
d490 1
a490 1
  return pc;
d493 3
a495 3
/* Do a full analysis of the prologue at PC and update CACHE
   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
   address where the analysis stopped.
d497 5
a501 1
   We handle these cases:
d503 2
a504 11
   The startup sequence can be at the start of the function, or the
   function can start with a branch to startup code at the end.

   %ebp can be set up with either the 'enter' instruction, or "pushl
   %ebp, movl %esp, %ebp" (`enter' is too slow to be useful, but was
   once used in the System V compiler).

   Local space is allocated just below the saved %ebp by either the
   'enter' instruction, or by "subl $<size>, %esp".  'enter' has a 16
   bit unsigned argument for space to allocate, and the 'addl'
   instruction could have either a signed byte, or 32 bit immediate.
d506 2
a507 8
   Next, the registers used by this function are pushed.  With the
   System V compiler they will always be in the order: %edi, %esi,
   %ebx (and sometimes a harmless bug causes it to also save but not
   restore %eax); however, the code below is willing to see the pushes
   in any order, and will handle up to 8 of them.
 
   If the setup sequence is at the end of the function, then the next
   instruction will be a branch back to the start.  */
d510 1
a510 2
i386_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
		       struct i386_frame_cache *cache)
d512 5
a516 5
  pc = i386_follow_jump (pc);
  pc = i386_analyze_struct_return (pc, current_pc, cache);
  pc = i386_skip_probe (pc);
  pc = i386_analyze_frame_setup (pc, current_pc, cache);
  return i386_analyze_register_saves (pc, current_pc, cache);
d519 2
a520 1
/* Return PC of first real instruction.  */
d523 1
a523 1
i386_skip_prologue (CORE_ADDR start_pc)
d525 2
a526 9
  static unsigned char pic_pat[6] =
  {
    0xe8, 0, 0, 0, 0,		/* call 0x0 */
    0x5b,			/* popl %ebx */
  };
  struct i386_frame_cache cache;
  CORE_ADDR pc;
  unsigned char op;
  int i;
d528 3
a530 4
  cache.locals = -1;
  pc = i386_analyze_prologue (start_pc, 0xffffffff, &cache);
  if (cache.locals < 0)
    return start_pc;
d532 1
a532 1
  /* Found valid frame setup.  */
d534 6
a539 3
  /* The native cc on SVR4 in -K PIC mode inserts the following code
     to get the address of the global offset table (GOT) into register
     %ebx:
d541 2
a542 4
        call	0x0
	popl    %ebx
        movl    %ebx,x(%ebp)    (optional)
        addl    y,%ebx
d544 1
a544 5
     This code is with the rest of the prologue (at the end of the
     function), so we have to skip it to get to the first real
     instruction at the start of the function.  */

  for (i = 0; i < 6; i++)
d546 2
a547 3
      op = read_memory_unsigned_integer (pc + i, 1);
      if (pic_pat[i] != op)
	break;
a548 3
  if (i == 6)
    {
      int delta = 6;
d550 1
a550 25
      op = read_memory_unsigned_integer (pc + delta, 1);

      if (op == 0x89)		/* movl %ebx, x(%ebp) */
	{
	  op = read_memory_unsigned_integer (pc + delta + 1, 1);

	  if (op == 0x5d)	/* One byte offset from %ebp.  */
	    delta += 3;
	  else if (op == 0x9d)	/* Four byte offset from %ebp.  */
	    delta += 6;
	  else			/* Unexpected instruction.  */
	    delta = 0;

	  op = read_memory_unsigned_integer (pc + delta, 1);
	}

      /* addl y,%ebx */
      if (delta > 0 && op == 0x81
	  && read_memory_unsigned_integer (pc + delta + 1, 1) == 0xc3);
	{
	  pc += delta + 6;
	}
    }

  return i386_follow_jump (pc);
d553 1
a553 1
/* This function is 64-bit safe.  */
d556 1
a556 1
i386_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
d558 2
a559 1
  char buf[8];
d561 1
a561 2
  frame_unwind_register (next_frame, PC_REGNUM, buf);
  return extract_typed_address (buf, builtin_type_void_func_ptr);
a562 1

d564 2
a565 1
/* Normal frames.  */
d567 2
a568 2
static struct i386_frame_cache *
i386_frame_cache (struct frame_info *next_frame, void **this_cache)
d570 7
a576 3
  struct i386_frame_cache *cache;
  char buf[4];
  int i;
d578 3
a580 2
  if (*this_cache)
    return *this_cache;
d582 55
a636 2
  cache = i386_alloc_frame_cache ();
  *this_cache = cache;
d638 4
a641 44
  /* In principle, for normal frames, %ebp holds the frame pointer,
     which holds the base address for the current stack frame.
     However, for functions that don't need it, the frame pointer is
     optional.  For these "frameless" functions the frame pointer is
     actually the frame pointer of the calling frame.  Signal
     trampolines are just a special case of a "frameless" function.
     They (usually) share their frame pointer with the frame that was
     in progress when the signal occurred.  */

  frame_unwind_register (next_frame, I386_EBP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4);
  if (cache->base == 0)
    return cache;

  /* For normal frames, %eip is stored at 4(%ebp).  */
  cache->saved_regs[I386_EIP_REGNUM] = 4;

  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
    i386_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);

  if (cache->locals < 0)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  If
	 we're at the start of a function, or somewhere half-way its
	 prologue, the function's frame probably hasn't been fully
	 setup yet.  Try to reconstruct the base address for the stack
	 frame by looking at the stack pointer.  For truly "frameless"
	 functions this might work too.  */

      frame_unwind_register (next_frame, I386_ESP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 4) + cache->sp_offset;
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of %esp in the calling frame.  */
  cache->saved_sp = cache->base + 8;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < I386_NUM_SAVED_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;
d643 2
a644 2
  return cache;
}
d646 3
a648 5
static void
i386_frame_this_id (struct frame_info *next_frame, void **this_cache,
		    struct frame_id *this_id)
{
  struct i386_frame_cache *cache = i386_frame_cache (next_frame, this_cache);
d650 4
a653 3
  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;
d655 8
a662 3
  /* See the end of i386_push_dummy_call.  */
  (*this_id) = frame_id_build (cache->base + 8, cache->pc);
}
d665 1
a665 4
i386_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *valuep)
d667 5
a671 1
  struct i386_frame_cache *cache = i386_frame_cache (next_frame, this_cache);
d673 2
a674 12
  gdb_assert (regnum >= 0);

  /* The System V ABI says that:

     "The flags register contains the system flags, such as the
     direction flag and the carry flag.  The direction flag must be
     set to the forward (that is, zero) direction before entry and
     upon exit from a function.  Other user flags have no specified
     role in the standard calling sequence and are not preserved."

     To guarantee the "upon exit" part of that statement we fake a
     saved flags register that has its direction flag cleared.
d676 1
a676 3
     Note that GCC doesn't seem to rely on the fact that the direction
     flag is cleared after a function return; it always explicitly
     clears the flag before operations where it matters.
d678 3
a680 3
     FIXME: kettenis/20030316: I'm not quite sure whether this is the
     right thing to do.  The way we fake the flags register here makes
     it impossible to change it.  */
d682 1
a682 1
  if (regnum == I386_EFLAGS_REGNUM)
d684 2
a685 5
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
d687 10
a696 7
	  ULONGEST val;

	  /* Clear the direction flag.  */
	  val = frame_unwind_register_unsigned (next_frame,
						I386_EFLAGS_REGNUM);
	  val &= ~(1 << 10);
	  store_unsigned_integer (valuep, 4, val);
a697 9

      return;
    }

  if (regnum == I386_EIP_REGNUM && cache->pc_in_eax)
    {
      frame_register_unwind (next_frame, I386_EAX_REGNUM,
			     optimizedp, lvalp, addrp, realnump, valuep);
      return;
d700 2
a701 44
  if (regnum == I386_ESP_REGNUM && cache->saved_sp)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_unsigned_integer (valuep, 4, cache->saved_sp);
	}
      return;
    }

  if (regnum < I386_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
	}
      return;
    }

  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind i386_frame_unwind =
{
  NORMAL_FRAME,
  i386_frame_this_id,
  i386_frame_prev_register
};

static const struct frame_unwind *
i386_frame_sniffer (struct frame_info *next_frame)
{
  return &i386_frame_unwind;
a702 1

d704 1
a704 1
/* Signal trampolines.  */
d706 2
a707 2
static struct i386_frame_cache *
i386_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
d709 7
a715 4
  struct i386_frame_cache *cache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  CORE_ADDR addr;
  char buf[4];
d717 2
a718 2
  if (*this_cache)
    return *this_cache;
d720 2
a721 1
  cache = i386_alloc_frame_cache ();
d723 9
a731 2
  frame_unwind_register (next_frame, I386_ESP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4) - 4;
d733 8
a740 4
  addr = tdep->sigcontext_addr (next_frame);
  if (tdep->sc_reg_offset)
    {
      int i;
d742 3
a744 1
      gdb_assert (tdep->sc_num_regs <= I386_NUM_SAVED_REGS);
d746 6
a751 3
      for (i = 0; i < tdep->sc_num_regs; i++)
	if (tdep->sc_reg_offset[i] != -1)
	  cache->saved_regs[i] = addr + tdep->sc_reg_offset[i];
d753 1
a753 1
  else
d755 26
a780 2
      cache->saved_regs[I386_EIP_REGNUM] = addr + tdep->sc_pc_offset;
      cache->saved_regs[I386_ESP_REGNUM] = addr + tdep->sc_sp_offset;
d782 1
d784 3
a786 2
  *this_cache = cache;
  return cache;
d789 5
a793 6
static void
i386_sigtramp_frame_this_id (struct frame_info *next_frame, void **this_cache,
			     struct frame_id *this_id)
{
  struct i386_frame_cache *cache =
    i386_sigtramp_frame_cache (next_frame, this_cache);
d795 5
a799 10
  /* See the end of i386_push_dummy_call.  */
  (*this_id) = frame_id_build (cache->base + 8, frame_pc_unwind (next_frame));
}

static void
i386_sigtramp_frame_prev_register (struct frame_info *next_frame,
				   void **this_cache,
				   int regnum, int *optimizedp,
				   enum lval_type *lvalp, CORE_ADDR *addrp,
				   int *realnump, void *valuep)
d801 4
a804 5
  /* Make sure we've initialized the cache.  */
  i386_sigtramp_frame_cache (next_frame, this_cache);

  i386_frame_prev_register (next_frame, this_cache, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
d807 2
a808 6
static const struct frame_unwind i386_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  i386_sigtramp_frame_this_id,
  i386_sigtramp_frame_prev_register
};
d810 2
a811 2
static const struct frame_unwind *
i386_sigtramp_frame_sniffer (struct frame_info *next_frame)
d813 1
a813 2
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  char *name;
d815 3
a817 10
  /* We shouldn't even bother to try if the OSABI didn't register
     a sigcontext_addr handler.  */
  if (!gdbarch_tdep (current_gdbarch)->sigcontext_addr)
    return NULL;

  find_pc_partial_function (pc, &name, NULL, NULL);
  if (PC_IN_SIGTRAMP (pc, name))
    return &i386_sigtramp_frame_unwind;

  return NULL;
a818 1

d820 2
a821 2
static CORE_ADDR
i386_frame_base_address (struct frame_info *next_frame, void **this_cache)
d823 6
a828 1
  struct i386_frame_cache *cache = i386_frame_cache (next_frame, this_cache);
d830 14
a843 1
  return cache->base;
d846 2
a847 10
static const struct frame_base i386_frame_base =
{
  &i386_frame_unwind,
  i386_frame_base_address,
  i386_frame_base_address,
  i386_frame_base_address
};

static struct frame_id
i386_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d849 1
a849 8
  char buf[4];
  CORE_ADDR fp;

  frame_unwind_register (next_frame, I386_EBP_REGNUM, buf);
  fp = extract_unsigned_integer (buf, 4);

  /* See the end of i386_push_dummy_call.  */
  return frame_id_build (fp + 8, frame_pc_unwind (next_frame));
d856 2
a857 4
   This address is copied into PC.  This routine returns non-zero on
   success.

   This function is 64-bit safe.  */
d862 1
a862 1
  char buf[8];
a864 1
  int len = TYPE_LENGTH (builtin_type_void_func_ptr);
d871 2
a872 5
  /* Don't use I386_ESP_REGNUM here, since this function is also used
     for AMD64.  */
  regcache_cooked_read (current_regcache, SP_REGNUM, buf);
  sp = extract_typed_address (buf, builtin_type_void_data_ptr);
  if (target_read_memory (sp + len, buf, len))
d875 2
a876 2
  jb_addr = extract_typed_address (buf, builtin_type_void_data_ptr);
  if (target_read_memory (jb_addr + jb_pc_offset, buf, len))
d879 1
a879 1
  *pc = extract_typed_address (buf, builtin_type_void_func_ptr);
d885 2
a886 4
i386_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
d888 3
a890 5
  char buf[4];
  int i;

  /* Push arguments in reverse order.  */
  for (i = nargs - 1; i >= 0; i--)
d892 1
a892 3
      int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (args[i]));

      /* The System V ABI says that:
a893 12
	 "An argument's size is increased, if necessary, to make it a
	 multiple of [32-bit] words.  This may require tail padding,
	 depending on the size of the argument."

	 This makes sure the stack says word-aligned.  */
      sp -= (len + 3) & ~3;
      write_memory (sp, VALUE_CONTENTS_ALL (args[i]), len);
    }

  /* Push value address.  */
  if (struct_return)
    {
d895 1
a895 1
      store_unsigned_integer (buf, 4, struct_addr);
d899 7
a905 22
  /* Store return address.  */
  sp -= 4;
  store_unsigned_integer (buf, 4, bp_addr);
  write_memory (sp, buf, 4);

  /* Finally, update the stack pointer...  */
  store_unsigned_integer (buf, 4, sp);
  regcache_cooked_write (regcache, I386_ESP_REGNUM, buf);

  /* ...and fake a frame pointer.  */
  regcache_cooked_write (regcache, I386_EBP_REGNUM, buf);

  /* MarkK wrote: This "+ 8" is all over the place:
     (i386_frame_this_id, i386_sigtramp_frame_this_id,
     i386_unwind_dummy_id).  It's there, since all frame unwinders for
     a given target have to agree (within a certain margin) on the
     defenition of the stack address of a frame.  Otherwise
     frame_id_inner() won't work correctly.  Since DWARF2/GCC uses the
     stack address *before* the function call as a frame's CFA.  On
     the i386, when %ebp is used as a frame pointer, the offset
     between the contents %ebp and the CFA as defined by GCC.  */
  return sp + 8;
d911 2
a912 2
#define LOW_RETURN_REGNUM	I386_EAX_REGNUM /* %eax */
#define HIGH_RETURN_REGNUM	I386_EDX_REGNUM /* %edx */
d914 3
a916 2
/* Read, for architecture GDBARCH, a function return value of TYPE
   from REGCACHE, and copy that into VALBUF.  */
d919 2
a920 2
i386_extract_return_value (struct gdbarch *gdbarch, struct type *type,
			   struct regcache *regcache, void *valbuf)
d922 1
a922 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d926 7
d935 1
a935 1
      if (tdep->st0_regnum < 0)
d946 1
a946 1
      regcache_raw_read (regcache, I386_ST0_REGNUM, buf);
d951 2
a952 2
      int low_size = register_size (current_gdbarch, LOW_RETURN_REGNUM);
      int high_size = register_size (current_gdbarch, HIGH_RETURN_REGNUM);
d964 1
a964 1
	  memcpy ((char *) valbuf + low_size, buf, len - low_size);
d972 2
a973 2
/* Write, for architecture GDBARCH, a function return value of TYPE
   from VALBUF into REGCACHE.  */
d976 2
a977 2
i386_store_return_value (struct gdbarch *gdbarch, struct type *type,
			 struct regcache *regcache, const void *valbuf)
a978 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d981 6
a986 3
  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for the architecture.  */
#define I387_ST0_REGNUM I386_ST0_REGNUM
d991 1
a991 1
      char buf[I386_MAX_REGISTER_SIZE];
d993 1
a993 1
      if (tdep->st0_regnum < 0)
d1008 1
a1008 1
      regcache_raw_write (regcache, I386_ST0_REGNUM, buf);
d1014 1
a1014 1
      regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM, &fstat);
d1016 1
a1016 1
      regcache_raw_write_unsigned (regcache, I387_FSTAT_REGNUM, fstat);
d1021 1
a1021 1
      regcache_raw_write_unsigned (regcache, I387_FTAG_REGNUM, 0x3fff);
d1025 2
a1026 2
      int low_size = register_size (current_gdbarch, LOW_RETURN_REGNUM);
      int high_size = register_size (current_gdbarch, HIGH_RETURN_REGNUM);
a1039 2

#undef I387_ST0_REGNUM
d1042 3
a1044 3
/* Extract from REGCACHE, which contains the (raw) register state, the
   address in which a function should return its structure value, as a
   CORE_ADDR.  */
d1049 12
a1060 4
  char buf[4];

  regcache_cooked_read (regcache, I386_EAX_REGNUM, buf);
  return extract_unsigned_integer (buf, 4);
a1077 4
/* Return non-zero if TYPE, which is assumed to be a structure or
   union type, should be returned in registers for architecture
   GDBARCH.  */

d1079 1
a1079 1
i386_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)
d1081 1
a1081 3
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum type_code code = TYPE_CODE (type);
  int len = TYPE_LENGTH (type);
d1083 6
a1088 22
  gdb_assert (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION);

  if (struct_convention == pcc_struct_convention
      || (struct_convention == default_struct_convention
	  && tdep->struct_return == pcc_struct_return))
    return 0;

  return (len == 1 || len == 2 || len == 4 || len == 8);
}

/* Determine, for architecture GDBARCH, how a return value of TYPE
   should be returned.  If it is supposed to be returned in registers,
   and READBUF is non-zero, read the appropriate value from REGCACHE,
   and copy it into READBUF.  If WRITEBUF is non-zero, write the value
   from WRITEBUF into REGCACHE.  */

static enum return_value_convention
i386_return_value (struct gdbarch *gdbarch, struct type *type,
		   struct regcache *regcache, void *readbuf,
		   const void *writebuf)
{
  enum type_code code = TYPE_CODE (type);
d1090 2
a1091 22
  if ((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION)
      && !i386_reg_struct_return_p (gdbarch, type))
    return RETURN_VALUE_STRUCT_CONVENTION;

  /* This special case is for structures consisting of a single
     `float' or `double' member.  These structures are returned in
     %st(0).  For these structures, we call ourselves recursively,
     changing TYPE into the type of the first member of the structure.
     Since that should work for all structures that have only one
     member, we don't bother to check the member's type here.  */
  if (code == TYPE_CODE_STRUCT && TYPE_NFIELDS (type) == 1)
    {
      type = check_typedef (TYPE_FIELD_TYPE (type, 0));
      return i386_return_value (gdbarch, type, regcache, readbuf, writebuf);
    }

  if (readbuf)
    i386_extract_return_value (gdbarch, type, regcache, readbuf);
  if (writebuf)
    i386_store_return_value (gdbarch, type, regcache, writebuf);

  return RETURN_VALUE_REGISTER_CONVENTION;
d1100 1
a1100 1
i386_register_type (struct gdbarch *gdbarch, int regnum)
d1102 1
a1102 2
  if (regnum == I386_EIP_REGNUM
      || regnum == I386_EBP_REGNUM || regnum == I386_ESP_REGNUM)
d1105 1
a1105 1
  if (i386_fp_regnum_p (regnum))
d1108 1
a1108 1
  if (i386_sse_regnum_p (gdbarch, regnum))
d1111 1
a1111 1
  if (i386_mmx_regnum_p (gdbarch, regnum))
d1121 1
a1121 1
i386_mmx_regnum_to_fp_regnum (struct regcache *regcache, int regnum)
d1123 1
a1123 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  int mmxreg, fpreg;
d1126 3
a1128 7

  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for REGCACHE's architecture.  */
#define I387_ST0_REGNUM tdep->st0_regnum

  mmxreg = regnum - tdep->mm0_regnum;
  regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM, &fstat);
d1130 2
a1131 5
  fpreg = (mmxreg + tos) % 8;

  return (I387_ST0_REGNUM + fpreg);

#undef I387_ST0_REGNUM
d1138 1
a1138 1
  if (i386_mmx_regnum_p (gdbarch, regnum))
d1140 3
a1142 3
      char mmx_buf[MAX_REGISTER_SIZE];
      int fpnum = i386_mmx_regnum_to_fp_regnum (regcache, regnum);

d1144 1
a1144 2
      regcache_raw_read (regcache, fpnum, mmx_buf);
      memcpy (buf, mmx_buf, register_size (gdbarch, regnum));
d1154 1
a1154 1
  if (i386_mmx_regnum_p (gdbarch, regnum))
d1156 2
a1157 3
      char mmx_buf[MAX_REGISTER_SIZE];
      int fpnum = i386_mmx_regnum_to_fp_regnum (regcache, regnum);

d1161 1
a1161 1
      memcpy (mmx_buf, buf, register_size (gdbarch, regnum));
a1167 30


/* Return the register number of the register allocated by GCC after
   REGNUM, or -1 if there is no such register.  */

static int
i386_next_regnum (int regnum)
{
  /* GCC allocates the registers in the order:

     %eax, %edx, %ecx, %ebx, %esi, %edi, %ebp, %esp, ...

     Since storing a variable in %esp doesn't make any sense we return
     -1 for %ebp and for %esp itself.  */
  static int next_regnum[] =
  {
    I386_EDX_REGNUM,		/* Slot for %eax.  */
    I386_EBX_REGNUM,		/* Slot for %ecx.  */
    I386_ECX_REGNUM,		/* Slot for %edx.  */
    I386_ESI_REGNUM,		/* Slot for %ebx.  */
    -1, -1,			/* Slots for %esp and %ebp.  */
    I386_EDI_REGNUM,		/* Slot for %esi.  */
    I386_EBP_REGNUM		/* Slot for %edi.  */
  };

  if (regnum >= 0 && regnum < sizeof (next_regnum) / sizeof (next_regnum[0]))
    return next_regnum[regnum];

  return -1;
}
d1169 5
a1173 2
/* Return nonzero if a value of type TYPE stored in register REGNUM
   needs any special handling.  */
d1176 1
a1176 32
i386_convert_register_p (int regnum, struct type *type)
{
  int len = TYPE_LENGTH (type);

  /* Values may be spread across multiple registers.  Most debugging
     formats aren't expressive enough to specify the locations, so
     some heuristics is involved.  Right now we only handle types that
     have a length that is a multiple of the word size, since GCC
     doesn't seem to put any other types into registers.  */
  if (len > 4 && len % 4 == 0)
    {
      int last_regnum = regnum;

      while (len > 4)
	{
	  last_regnum = i386_next_regnum (last_regnum);
	  len -= 4;
	}

      if (last_regnum != -1)
	return 1;
    }

  return i386_fp_regnum_p (regnum);
}

/* Read a value of type TYPE from register REGNUM in frame FRAME, and
   return its contents in TO.  */

static void
i386_register_to_value (struct frame_info *frame, int regnum,
			struct type *type, void *to)
d1178 1
a1178 26
  int len = TYPE_LENGTH (type);
  char *buf = to;

  /* FIXME: kettenis/20030609: What should we do if REGNUM isn't
     available in FRAME (i.e. if it wasn't saved)?  */

  if (i386_fp_regnum_p (regnum))
    {
      i387_register_to_value (frame, regnum, type, to);
      return;
    }

  /* Read a value spread accross multiple registers.  */

  gdb_assert (len > 4 && len % 4 == 0);

  while (len > 0)
    {
      gdb_assert (regnum != -1);
      gdb_assert (register_size (current_gdbarch, regnum) == 4);

      get_frame_register (frame, regnum, buf);
      regnum = i386_next_regnum (regnum);
      len -= 4;
      buf += 4;
    }
d1181 2
a1182 2
/* Write the contents FROM of a value of type TYPE into register
   REGNUM in frame FRAME.  */
d1185 2
a1186 2
i386_value_to_register (struct frame_info *frame, int regnum,
			struct type *type, const void *from)
d1188 1
a1188 2
  int len = TYPE_LENGTH (type);
  const char *buf = from;
d1190 2
a1191 1
  if (i386_fp_regnum_p (regnum))
d1193 3
a1195 1
      i387_value_to_register (frame, regnum, type, from);
d1199 3
a1201 36
  /* Write a value spread accross multiple registers.  */

  gdb_assert (len > 4 && len % 4 == 0);

  while (len > 0)
    {
      gdb_assert (regnum != -1);
      gdb_assert (register_size (current_gdbarch, regnum) == 4);

      put_frame_register (frame, regnum, buf);
      regnum = i386_next_regnum (regnum);
      len -= 4;
      buf += 4;
    }
}

/* Supply register REGNUM from the general-purpose register set REGSET
   to register cache REGCACHE.  If REGNUM is -1, do this for all
   registers in REGSET.  */

void
i386_supply_gregset (const struct regset *regset, struct regcache *regcache,
		     int regnum, const void *gregs, size_t len)
{
  const struct gdbarch_tdep *tdep = regset->descr;
  const char *regs = gregs;
  int i;

  gdb_assert (len == tdep->sizeof_gregset);

  for (i = 0; i < tdep->gregset_num_regs; i++)
    {
      if ((regnum == i || regnum == -1)
	  && tdep->gregset_reg_offset[i] != -1)
	regcache_raw_supply (regcache, i, regs + tdep->gregset_reg_offset[i]);
    }
d1204 2
a1205 3
/* Supply register REGNUM from the floating-point register set REGSET
   to register cache REGCACHE.  If REGNUM is -1, do this for all
   registers in REGSET.  */
d1208 2
a1209 2
i386_supply_fpregset (const struct regset *regset, struct regcache *regcache,
		      int regnum, const void *fpregs, size_t len)
d1211 1
a1211 1
  const struct gdbarch_tdep *tdep = regset->descr;
d1213 2
a1214 1
  if (len == I387_SIZEOF_FXSAVE)
d1216 3
a1218 1
      i387_supply_fxsave (regcache, regnum, fpregs);
d1222 3
a1224 38
  gdb_assert (len == tdep->sizeof_fpregset);
  i387_supply_fsave (regcache, regnum, fpregs);
}

/* Return the appropriate register set for the core section identified
   by SECT_NAME and SECT_SIZE.  */

const struct regset *
i386_regset_from_core_section (struct gdbarch *gdbarch,
			       const char *sect_name, size_t sect_size)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (strcmp (sect_name, ".reg") == 0 && sect_size == tdep->sizeof_gregset)
    {
      if (tdep->gregset == NULL)
	{
	  tdep->gregset = XMALLOC (struct regset);
	  tdep->gregset->descr = tdep;
	  tdep->gregset->supply_regset = i386_supply_gregset;
	}
      return tdep->gregset;
    }

  if ((strcmp (sect_name, ".reg2") == 0 && sect_size == tdep->sizeof_fpregset)
      || (strcmp (sect_name, ".reg-xfp") == 0
	  && sect_size == I387_SIZEOF_FXSAVE))
    {
      if (tdep->fpregset == NULL)
	{
	  tdep->fpregset = XMALLOC (struct regset);
	  tdep->fpregset->descr = tdep;
	  tdep->fpregset->supply_regset = i386_supply_fpregset;
	}
      return tdep->fpregset;
    }

  return NULL;
d1226 1
a1226 1

d1264 1
a1264 1
      char *symname = indsym ? SYMBOL_LINKAGE_NAME (indsym) : 0;
d1291 1
a1291 1
i386_print_insn (bfd_vma pc, struct disassemble_info *info)
a1314 2
  /* UnixWare uses _sigacthandler.  The origin of the other symbols is
     currently unknown.  */
d1320 2
a1321 3
/* Assuming NEXT_FRAME is for a frame following a SVR4 sigtramp
   routine, return the address of the associated sigcontext (ucontext)
   structure.  */
d1324 1
a1324 1
i386_svr4_sigcontext_addr (struct frame_info *next_frame)
d1326 13
a1338 2
  char buf[4];
  CORE_ADDR sp;
d1340 1
a1340 2
  frame_unwind_register (next_frame, I386_ESP_REGNUM, buf);
  sp = extract_unsigned_integer (buf, 4);
d1342 3
a1344 1
  return read_memory_unsigned_integer (sp + 8, 4);
d1381 3
d1386 2
a1387 2
  tdep->sc_pc_offset = 36 + 14 * 4;
  tdep->sc_sp_offset = 36 + 17 * 4;
d1411 3
a1417 63
/* i386 register groups.  In addition to the normal groups, add "mmx"
   and "sse".  */

static struct reggroup *i386_sse_reggroup;
static struct reggroup *i386_mmx_reggroup;

static void
i386_init_reggroups (void)
{
  i386_sse_reggroup = reggroup_new ("sse", USER_REGGROUP);
  i386_mmx_reggroup = reggroup_new ("mmx", USER_REGGROUP);
}

static void
i386_add_reggroups (struct gdbarch *gdbarch)
{
  reggroup_add (gdbarch, i386_sse_reggroup);
  reggroup_add (gdbarch, i386_mmx_reggroup);
  reggroup_add (gdbarch, general_reggroup);
  reggroup_add (gdbarch, float_reggroup);
  reggroup_add (gdbarch, all_reggroup);
  reggroup_add (gdbarch, save_reggroup);
  reggroup_add (gdbarch, restore_reggroup);
  reggroup_add (gdbarch, vector_reggroup);
  reggroup_add (gdbarch, system_reggroup);
}

int
i386_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			  struct reggroup *group)
{
  int sse_regnum_p = (i386_sse_regnum_p (gdbarch, regnum)
		      || i386_mxcsr_regnum_p (gdbarch, regnum));
  int fp_regnum_p = (i386_fp_regnum_p (regnum)
		     || i386_fpc_regnum_p (regnum));
  int mmx_regnum_p = (i386_mmx_regnum_p (gdbarch, regnum));

  if (group == i386_mmx_reggroup)
    return mmx_regnum_p;
  if (group == i386_sse_reggroup)
    return sse_regnum_p;
  if (group == vector_reggroup)
    return (mmx_regnum_p || sse_regnum_p);
  if (group == float_reggroup)
    return fp_regnum_p;
  if (group == general_reggroup)
    return (!fp_regnum_p && !mmx_regnum_p && !sse_regnum_p);

  return default_register_reggroup_p (gdbarch, regnum, group);
}


/* Get the ARGIth function argument for the current function.  */

static CORE_ADDR
i386_fetch_pointer_argument (struct frame_info *frame, int argi, 
			     struct type *type)
{
  CORE_ADDR sp = get_frame_register_unsigned  (frame, I386_ESP_REGNUM);
  return read_memory_unsigned_integer (sp + (4 * (argi + 1)), 4);
}


d1423 1
d1425 14
a1438 4
  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d1444 1
a1444 30
  /* General-purpose registers.  */
  tdep->gregset = NULL;
  tdep->gregset_reg_offset = NULL;
  tdep->gregset_num_regs = I386_NUM_GREGS;
  tdep->sizeof_gregset = 0;

  /* Floating-point registers.  */
  tdep->fpregset = NULL;
  tdep->sizeof_fpregset = I387_SIZEOF_FSAVE;

  /* The default settings include the FPU registers, the MMX registers
     and the SSE registers.  This can be overidden for a specific ABI
     by adjusting the members `st0_regnum', `mm0_regnum' and
     `num_xmm_regs' of `struct gdbarch_tdep', otherwise the registers
     will show up in the output of "info all-registers".  Ideally we
     should try to autodetect whether they are available, such that we
     can prevent "info all-registers" from displaying registers that
     aren't available.

     NOTE: kevinb/2003-07-13: ... if it's a choice between printing
     [the SSE registers] always (even when they don't exist) or never
     showing them to the user (even when they do exist), I prefer the
     former over the latter.  */

  tdep->st0_regnum = I386_ST0_REGNUM;

  /* The MMX registers are implemented as pseudo-registers.  Put off
     caclulating the register number for %mm0 until we know the number
     of raw registers.  */
  tdep->mm0_regnum = 0;
d1446 4
a1449 2
  /* I386_NUM_XREGS includes %mxcsr, so substract one.  */
  tdep->num_xmm_regs = I386_NUM_XREGS - 1;
a1455 1
  tdep->sc_reg_offset = NULL;
d1470 9
a1478 11
  /* The default ABI includes general-purpose registers, 
     floating-point registers, and the SSE registers.  */
  set_gdbarch_num_regs (gdbarch, I386_SSE_NUM_REGS);
  set_gdbarch_register_name (gdbarch, i386_register_name);
  set_gdbarch_register_type (gdbarch, i386_register_type);

  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, I386_ESP_REGNUM); /* %esp */
  set_gdbarch_pc_regnum (gdbarch, I386_EIP_REGNUM); /* %eip */
  set_gdbarch_ps_regnum (gdbarch, I386_EFLAGS_REGNUM); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, I386_ST0_REGNUM); /* %st(0) */
d1491 7
d1502 2
d1505 33
a1537 7
  set_gdbarch_push_dummy_call (gdbarch, i386_push_dummy_call);

  set_gdbarch_convert_register_p (gdbarch, i386_convert_register_p);
  set_gdbarch_register_to_value (gdbarch,  i386_register_to_value);
  set_gdbarch_value_to_register (gdbarch, i386_value_to_register);

  set_gdbarch_return_value (gdbarch, i386_return_value);
d1540 1
d1542 1
d1552 5
d1558 9
d1570 1
a1570 1
  set_gdbarch_num_pseudo_regs (gdbarch, i386_num_mmx_regs);
a1575 16
  set_gdbarch_unwind_dummy_id (gdbarch, i386_unwind_dummy_id);

  set_gdbarch_unwind_pc (gdbarch, i386_unwind_pc);

  /* Add the i386 register groups.  */
  i386_add_reggroups (gdbarch);
  set_gdbarch_register_reggroup_p (gdbarch, i386_register_reggroup_p);

  /* Helper for function argument information.  */
  set_gdbarch_fetch_pointer_argument (gdbarch, i386_fetch_pointer_argument);

  /* Hook in the DWARF CFI frame unwinder.  */
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);

  frame_base_set_default (gdbarch, &i386_frame_base);

d1577 1
a1577 16
  gdbarch_init_osabi (info, gdbarch);

  frame_unwind_append_sniffer (gdbarch, i386_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, i386_frame_sniffer);

  /* If we have a register mapping, enable the generic core file
     support, unless it has already been enabled.  */
  if (tdep->gregset_reg_offset
      && !gdbarch_regset_from_core_section_p (gdbarch))
    set_gdbarch_regset_from_core_section (gdbarch,
					  i386_regset_from_core_section);

  /* Unless support for MMX has been disabled, make %mm0 the first
     pseudo-register.  */
  if (tdep->mm0_regnum == 0)
    tdep->mm0_regnum = gdbarch_num_regs (gdbarch);
d1640 1
a1640 1
  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_SVR4,
d1642 1
a1642 1
  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_GO32,
d1644 1
a1644 1
  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_NETWARE,
a1645 3

  /* Initialize the i386 specific register groups.  */
  i386_init_reggroups ();
@


1.88.4.2
log
@Merge from mainline.
@
text
@a510 4
	 Because of the symmetry, there are actually two ways to
	 encode these instructions; with opcode bytes 0x29 and 0x2b
	 for `subl' and opcode bytes 0x31 and 0x33 for `xorl'.

d513 1
a513 1
      while (op == 0x29 || op == 0x2b || op == 0x31 || op == 0x33)
@


1.88.4.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d4 1
a4 2
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d1277 13
d1998 2
d2008 1
@


1.88.2.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a39 1
#include "reggroups.h"
d73 1
a73 1
i386_mmx_regnum_p (int reg)
a77 32
/* FP register?  */

int
i386_fp_regnum_p (int regnum)
{
  return (regnum < NUM_REGS
	  && (FP0_REGNUM && FP0_REGNUM <= (regnum) && (regnum) < FPC_REGNUM));
}

int
i386_fpc_regnum_p (int regnum)
{
  return (regnum < NUM_REGS
	  && (FPC_REGNUM <= (regnum) && (regnum) < XMM0_REGNUM));
}

/* SSE register?  */

int
i386_sse_regnum_p (int regnum)
{
  return (regnum < NUM_REGS
	  && (XMM0_REGNUM <= (regnum) && (regnum) < MXCSR_REGNUM));
}

int
i386_mxcsr_regnum_p (int regnum)
{
  return (regnum < NUM_REGS
	  && (regnum == MXCSR_REGNUM));
}

d85 1
a85 1
  if (i386_mmx_regnum_p (reg))
d465 1
a465 1
int
d538 2
a539 6
    {
      ULONGEST pc;

      frame_unwind_unsigned_register (frame, PC_REGNUM, &pc);
      return pc;
    }
d837 1
a837 1
	  deprecated_write_register_gen (regnum, regbuf);
d1042 3
a1044 3
/* Extract from REGCACHE, which contains the (raw) register state, the
   address in which a function should return its structure value, as a
   CORE_ADDR.  */
d1049 12
a1060 4
  ULONGEST addr;

  regcache_raw_read_unsigned (regcache, LOW_RETURN_REGNUM, &addr);
  return addr;
d1105 1
a1105 1
  if (i386_fp_regnum_p (regnum))
d1108 1
a1108 1
  if (i386_sse_regnum_p (regnum))
d1111 1
a1111 1
  if (i386_mmx_regnum_p (regnum))
d1138 1
a1138 1
  if (i386_mmx_regnum_p (regnum))
d1154 1
a1154 1
  if (i386_mmx_regnum_p (regnum))
d1178 1
a1178 1
  return i386_fp_regnum_p (regnum);
d1188 1
a1188 1
  gdb_assert (i386_fp_regnum_p (regnum));
d1211 1
a1211 1
  gdb_assert (i386_fp_regnum_p (regnum));
a1417 50
/* i386 register groups.  In addition to the normal groups, add "mmx"
   and "sse".  */

static struct reggroup *i386_sse_reggroup;
static struct reggroup *i386_mmx_reggroup;

static void
i386_init_reggroups (void)
{
  i386_sse_reggroup = reggroup_new ("sse", USER_REGGROUP);
  i386_mmx_reggroup = reggroup_new ("mmx", USER_REGGROUP);
}

static void
i386_add_reggroups (struct gdbarch *gdbarch)
{
  reggroup_add (gdbarch, i386_sse_reggroup);
  reggroup_add (gdbarch, i386_mmx_reggroup);
  reggroup_add (gdbarch, general_reggroup);
  reggroup_add (gdbarch, float_reggroup);
  reggroup_add (gdbarch, all_reggroup);
  reggroup_add (gdbarch, save_reggroup);
  reggroup_add (gdbarch, restore_reggroup);
  reggroup_add (gdbarch, vector_reggroup);
  reggroup_add (gdbarch, system_reggroup);
}

int
i386_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			  struct reggroup *group)
{
  int sse_regnum_p = (i386_sse_regnum_p (regnum)
		      || i386_mxcsr_regnum_p (regnum));
  int fp_regnum_p = (i386_fp_regnum_p (regnum)
		     || i386_fpc_regnum_p (regnum));
  int mmx_regnum_p = (i386_mmx_regnum_p (regnum));
  if (group == i386_mmx_reggroup)
    return mmx_regnum_p;
  if (group == i386_sse_reggroup)
    return sse_regnum_p;
  if (group == vector_reggroup)
    return (mmx_regnum_p || sse_regnum_p);
  if (group == float_reggroup)
    return fp_regnum_p;
  if (group == general_reggroup)
    return (!fp_regnum_p && !mmx_regnum_p && !sse_regnum_p);
  return default_register_reggroup_p (gdbarch, regnum, group);
}


a1575 4
  /* Add the i386 register groups.  */
  i386_add_reggroups (gdbarch);
  set_gdbarch_register_reggroup_p (gdbarch, i386_register_reggroup_p);

a1645 3

  /* Initialize the i386 specific register groups.  */
  i386_init_reggroups ();
@


1.88.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a40 1
#include "dummy-frame.h"
d475 2
a476 2
   testing for get_frame_type() == SIGTRAMP_FRAME, which is set based
   on PC_IN_SIGTRAMP.
d481 5
a485 4
   this case by seeing whether the next frame is a SIGTRAMP_FRAME,
   and, if it does, checking whether the current frame is actually
   frameless.  In this case, we need to get the PC by looking at the
   SP register value stored in the signal context.
d501 1
a501 1
  return (frame->next && get_frame_type (frame->next) == SIGTRAMP_FRAME
d513 1
a513 1
  if (pc_in_dummy_frame (frame->pc))
d516 1
a516 1
  if (get_frame_type (frame) == SIGTRAMP_FRAME
d533 1
a533 1
  if (get_frame_type (frame) == SIGTRAMP_FRAME)
d570 1
a570 1
  if (pc_in_dummy_frame (frame->pc))
d578 1
a578 1
  if (get_frame_type (frame) == SIGTRAMP_FRAME)
d595 1
a595 1
  if (get_frame_type (frame) == SIGTRAMP_FRAME)
d864 1
a864 1
  fp = get_frame_base (frame);
a1522 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);

d1581 2
d1584 1
d1601 4
d1642 2
d1723 1
a1723 1
  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_SVR4,
d1725 1
a1725 1
  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_GO32,
d1727 1
a1727 1
  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_NETWARE,
@


1.88.2.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a41 1
#include "osabi.h"
d501 1
a501 2
  return (get_next_frame (frame)
	  && get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME
d503 1
a503 1
	      || get_frame_pc (frame) == get_pc_function_start (get_frame_pc (frame))));
d513 2
a514 2
  if (pc_in_dummy_frame (get_frame_pc (frame)))
    return get_frame_base (frame);
d518 1
a518 1
    return get_frame_base (frame);
d520 2
a521 2
  if (! inside_entry_file (get_frame_pc (frame)))
    return read_memory_unsigned_integer (get_frame_base (frame), 4);
d570 1
a570 1
  if (pc_in_dummy_frame (get_frame_pc (frame)))
d583 1
a583 1
      CORE_ADDR sp = i386_sigtramp_saved_sp (get_next_frame (frame));
d587 1
a587 1
  return read_memory_unsigned_integer (get_frame_base (frame) + 4, 4);
d710 1
a710 1
  if (get_frame_saved_regs (fip))
d715 1
a715 1
  pc = get_pc_function_start (get_frame_pc (fip));
d721 1
a721 1
      addr = get_frame_base (fip) - 4 - locals;
d729 1
a729 1
	  get_frame_saved_regs (fip)[I386_REGNO_TO_SYMMETRY (op - 0x50)] = addr;
d731 1
a731 1
	  get_frame_saved_regs (fip)[op - 0x50] = addr;
d737 2
a738 2
  get_frame_saved_regs (fip)[PC_REGNUM] = get_frame_base (fip) + 4;
  get_frame_saved_regs (fip)[FP_REGNUM] = get_frame_base (fip);
d870 1
a870 1
      addr = get_frame_saved_regs (frame)[regnum];
d893 1
a893 1
   This address is copied into PC.  This routine returns non-zero on
d899 1
a899 1
  char buf[8];
a901 1
  int len = TARGET_PTR_BIT / TARGET_CHAR_BIT;
d909 1
a909 1
  if (target_read_memory (sp + len, buf, len))
d912 2
a913 2
  jb_addr = extract_address (buf, len);
  if (target_read_memory (jb_addr + jb_pc_offset, buf, len))
d916 1
a916 1
  *pc = extract_address (buf, len);
d1358 1
a1358 1
  find_pc_partial_function (get_frame_pc (frame), &name, NULL, NULL);
d1371 2
a1372 2
  if (get_next_frame (frame))
    return get_frame_base (get_next_frame (frame)) + sigcontext_offset;
d1410 3
d1440 3
d1502 1
d1504 14
a1517 4
  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d1527 2
d1637 1
d1655 1
a1655 1
  gdbarch_init_osabi (info, gdbarch);
@


1.88.2.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d1296 1
a1296 1
      char *symname = indsym ? SYMBOL_LINKAGE_NAME (indsym) : 0;
d1561 2
a1562 2
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, I386_MAX_REGISTER_SIZE);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, I386_MAX_REGISTER_SIZE);
d1593 1
d1602 1
a1602 1
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, i386_frame_init_saved_regs);
@


1.88.2.5
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d505 1
a505 1
	      || get_frame_pc (frame) == get_frame_func (frame)));
d639 4
a642 4
         main, because DEPRECATED_FRAME_CHAIN_VALID won't let us go
         into start.  If we have debugging symbols, that's not really
         a big deal; it just means it will only show as many arguments
         to main as are declared.  */
d717 1
a717 1
  pc = get_frame_func (fip);
d928 1
a928 1
  sp = legacy_push_arguments (nargs, args, sp, struct_return, struct_addr);
d942 6
d1132 1
a1132 1
i386_register_type (struct gdbarch *gdbarch, int regnum)
d1561 3
a1563 1
  set_gdbarch_register_type (gdbarch, i386_register_type);
d1570 6
d1578 2
d1592 4
a1595 3
  set_gdbarch_deprecated_push_arguments (gdbarch, i386_push_arguments);
  set_gdbarch_deprecated_push_return_address (gdbarch, i386_push_return_address);
  set_gdbarch_deprecated_pop_frame (gdbarch, i386_pop_frame);
d1619 3
a1621 3
  set_gdbarch_deprecated_frame_chain (gdbarch, i386_frame_chain);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, i386_frame_saved_pc);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, i386_saved_pc_after_call);
a1634 3

  /* Should be using push_dummy_call.  */
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
@


1.88.2.6
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@a48 1

a63 3
static const int i386_num_register_names =
  (sizeof (i386_register_names) / sizeof (*i386_register_names));

d71 3
a73 5

static const int i386_num_mmx_regs =
  (sizeof (i386_mmx_names) / sizeof (i386_mmx_names[0]));

#define MM0_REGNUM NUM_REGS
d76 1
a76 1
i386_mmx_regnum_p (int regnum)
d78 1
a78 2
  return (regnum >= MM0_REGNUM
	  && regnum < MM0_REGNUM + i386_num_mmx_regs);
d87 1
a87 1
	  && (FP0_REGNUM && FP0_REGNUM <= regnum && regnum < FPC_REGNUM));
d94 1
a94 1
	  && (FPC_REGNUM <= regnum && regnum < XMM0_REGNUM));
d103 1
a103 1
	  && (XMM0_REGNUM <= regnum && regnum < MXCSR_REGNUM));
d110 1
a110 1
	  && regnum == MXCSR_REGNUM);
d118 2
a119 3
  if (reg >= 0 && reg < i386_num_register_names)
    return i386_register_names[reg];

d122 2
d125 1
a125 1
  return NULL;
d603 74
d740 1
a740 1
  get_frame_saved_regs (fip)[DEPRECATED_FP_REGNUM] = get_frame_base (fip);
d879 1
a879 1
  write_register (DEPRECATED_FP_REGNUM, read_memory_integer (fp, 4));
d904 1
a904 1
  int len = TYPE_LENGTH (builtin_type_void_func_ptr);
d915 1
a915 1
  jb_addr = extract_typed_address (buf, builtin_type_void_func_ptr);
d919 1
a919 1
  *pc = extract_typed_address (buf, builtin_type_void_func_ptr);
d969 1
a969 1
      if (FP0_REGNUM < 0)
d1027 1
a1027 1
      if (FP0_REGNUM < 0)
d1128 1
a1128 1
  if (regnum == PC_REGNUM || regnum == DEPRECATED_FP_REGNUM || regnum == SP_REGNUM)
d1144 1
a1144 1
   the MMX registers need to be mapped onto floating-point registers.  */
d1147 1
a1147 1
i386_mmx_regnum_to_fp_regnum (struct regcache *regcache, int regnum)
a1152 1

a1156 1

d1167 2
a1168 2
      int fpnum = i386_mmx_regnum_to_fp_regnum (regcache, regnum);

a1169 1
      regcache_raw_read (regcache, fpnum, mmx_buf);
d1183 1
a1183 2
      int fpnum = i386_mmx_regnum_to_fp_regnum (regcache, regnum);

d1536 1
a1536 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, 5); /* %ebp */
d1605 1
a1605 1
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
d1609 1
a1609 1
  set_gdbarch_num_pseudo_regs (gdbarch, i386_num_mmx_regs);
@


1.88.2.7
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d867 1
a867 1
      store_unsigned_integer (buf, 4, struct_addr);
d1100 1
a1100 1
      char mmx_buf[MAX_REGISTER_SIZE];
d1117 1
a1117 1
      char mmx_buf[MAX_REGISTER_SIZE];
d1489 2
a1490 2
  set_gdbarch_deprecated_register_size (gdbarch, 4);
  set_gdbarch_deprecated_register_bytes (gdbarch, I386_SIZEOF_GREGS + I386_SIZEOF_FREGS);
d1498 2
a1499 2
  set_gdbarch_deprecated_call_dummy_words (gdbarch, NULL);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, 0);
@


1.88.2.8
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d24 1
a24 6
#include "arch-utils.h"
#include "command.h"
#include "dummy-frame.h"
#include "dwarf2-frame.h"
#include "doublest.h"
#include "floatformat.h"
a25 2
#include "frame-base.h"
#include "frame-unwind.h"
a26 1
#include "gdbcmd.h"
d29 2
a30 3
#include "osabi.h"
#include "regcache.h"
#include "reggroups.h"
d33 5
a37 1
#include "target.h"
a38 1

d40 3
a42 1
#include "gdb_string.h"
d125 3
a130 3
  if (reg >= 0 && reg < i386_num_register_names)
    return i386_register_names[reg];

d143 1
a143 1
      /* General-purpose registers.  */
d176 1
a176 1
      /* General-purpose registers.  */
a205 1

d207 41
a247 5
/* Use the program counter to determine the contents and size of a
   breakpoint instruction.  Return a pointer to a string of bytes that
   encode a breakpoint instruction, store the length of the string in
   *LEN and optionally adjust *PC to point to the correct memory
   location for inserting the breakpoint.
d249 5
a253 2
   On the i386 we have a single breakpoint that fits in a single byte
   and can be inserted anywhere.
d255 2
a256 4
   This function is 64-bit safe.  */
   
static const unsigned char *
i386_breakpoint_from_pc (CORE_ADDR *pc, int *len)
d258 6
a263 4
  static unsigned char break_insn[] = { 0xcc };	/* int 3 */
  
  *len = sizeof (break_insn);
  return break_insn;
a264 4

#ifdef I386_REGNO_TO_SYMMETRY
#error "The Sequent Symmetry is no longer supported."
#endif
d266 2
a267 28
/* According to the System V ABI, the registers %ebp, %ebx, %edi, %esi
   and %esp "belong" to the calling function.  Therefore these
   registers should be saved if they're going to be modified.  */

/* The maximum number of saved registers.  This should include all
   registers mentioned above, and %eip.  */
#define I386_NUM_SAVED_REGS	I386_NUM_GREGS

struct i386_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  CORE_ADDR sp_offset;
  CORE_ADDR pc;

  /* Saved registers.  */
  CORE_ADDR saved_regs[I386_NUM_SAVED_REGS];
  CORE_ADDR saved_sp;
  int pc_in_eax;

  /* Stack space reserved for local variables.  */
  long locals;
};

/* Allocate and initialize a frame cache.  */

static struct i386_frame_cache *
i386_alloc_frame_cache (void)
d269 1
a269 1
  struct i386_frame_cache *cache;
d271 5
d277 1
a277 1
  cache = FRAME_OBSTACK_ZALLOC (struct i386_frame_cache);
d279 5
a283 11
  /* Base address.  */
  cache->base = 0;
  cache->sp_offset = -4;
  cache->pc = 0;

  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %ebp is supposed to be stored).  */
  for (i = 0; i < I386_NUM_SAVED_REGS; i++)
    cache->saved_regs[i] = -1;
  cache->saved_sp = 0;
  cache->pc_in_eax = 0;
d285 2
a286 2
  /* Frameless until proven otherwise.  */
  cache->locals = -1;
d288 1
a288 5
  return cache;
}

/* If the instruction at PC is a jump, return the address of its
   target.  Otherwise, return PC.  */
d290 2
a291 9
static CORE_ADDR
i386_follow_jump (CORE_ADDR pc)
{
  unsigned char op;
  long delta = 0;
  int data16 = 0;

  op = read_memory_unsigned_integer (pc, 1);
  if (op == 0x66)
d293 1
a294 1
      op = read_memory_unsigned_integer (pc + 1, 1);
d297 1
a297 1
  switch (op)
d303 2
a304 1
	  delta = read_memory_integer (pc + 2, 2);
d308 1
a308 1
	  delta += 4;
d312 2
a313 1
	  delta = read_memory_integer (pc + 1, 4);
d315 1
a315 2
	  /* Include the size of the jmp instruction.  */
	  delta += 5;
d320 3
a322 1
      delta = read_memory_integer (pc + data16 + 1, 1);
d324 1
a324 1
      delta += data16 + 2;
d327 2
d330 2
a331 2
  return pc + delta;
}
d333 2
a334 5
/* Check whether PC points at a prologue for a function returning a
   structure or union.  If so, it updates CACHE and returns the
   address of the first instruction after the code sequence that
   removes the "hidden" argument from the stack or CURRENT_PC,
   whichever is smaller.  Otherwise, return PC.  */
d336 2
a337 3
static CORE_ADDR
i386_analyze_struct_return (CORE_ADDR pc, CORE_ADDR current_pc,
			    struct i386_frame_cache *cache)
a338 13
  /* Functions that return a structure or union start with:

        popl %eax             0x58
        xchgl %eax, (%esp)    0x87 0x04 0x24
     or xchgl %eax, 0(%esp)   0x87 0x44 0x24 0x00

     (the System V compiler puts out the second `xchg' instruction,
     and the assembler doesn't try to optimize it, so the 'sib' form
     gets generated).  This sequence is used to get the address of the
     return buffer for a function that returns a structure.  */
  static unsigned char proto1[3] = { 0x87, 0x04, 0x24 };
  static unsigned char proto2[4] = { 0x87, 0x44, 0x24, 0x00 };
  unsigned char buf[4];
d341 1
a341 2
  if (current_pc <= pc)
    return pc;
d343 1
a343 1
  op = read_memory_unsigned_integer (pc, 1);
d345 1
a345 2
  if (op != 0x58)		/* popl %eax */
    return pc;
d347 24
a370 3
  read_memory (pc + 1, buf, 4);
  if (memcmp (buf, proto1, 3) != 0 && memcmp (buf, proto2, 4) != 0)
    return pc;
d372 2
a373 4
  if (current_pc == pc)
    {
      cache->sp_offset += 4;
      return current_pc;
d376 1
a376 1
  if (current_pc == pc + 1)
d378 1
a378 9
      cache->pc_in_eax = 1;
      return current_pc;
    }
  
  if (buf[1] == proto1[1])
    return pc + 4;
  else
    return pc + 5;
}
d380 3
a382 8
static CORE_ADDR
i386_skip_probe (CORE_ADDR pc)
{
  /* A function may start with

        pushl constant
        call _probe
	addl $4, %esp
d384 1
a384 7
     followed by

        pushl %ebp

     etc.  */
  unsigned char buf[8];
  unsigned char op;
d386 1
a386 1
  op = read_memory_unsigned_integer (pc, 1);
d388 3
a390 3
  if (op == 0x68 || op == 0x6a)
    {
      int delta;
d392 3
a394 2
      /* Skip past the `pushl' instruction; it has either a one-byte or a
	 four-byte operand, depending on the opcode.  */
d396 1
a396 1
	delta = 5;
d398 2
a399 1
	delta = 2;
d401 3
a403 3
      /* Read the following 8 bytes, which should be `call _probe' (6
	 bytes) followed by `addl $4,%esp' (2 bytes).  */
      read_memory (pc + delta, buf, sizeof (buf));
d405 3
a407 1
	pc += delta + sizeof (buf);
a409 20
  return pc;
}

/* Check whether PC points at a code that sets up a new stack frame.
   If so, it updates CACHE and returns the address of the first
   instruction after the sequence that sets removes the "hidden"
   argument from the stack or CURRENT_PC, whichever is smaller.
   Otherwise, return PC.  */

static CORE_ADDR
i386_analyze_frame_setup (CORE_ADDR pc, CORE_ADDR current_pc,
			  struct i386_frame_cache *cache)
{
  unsigned char op;

  if (current_pc <= pc)
    return current_pc;

  op = read_memory_unsigned_integer (pc, 1);

d412 2
a413 12
      /* Take into account that we've executed the `pushl %ebp' that
	 starts this instruction sequence.  */
      cache->saved_regs[I386_EBP_REGNUM] = 0;
      cache->sp_offset += 4;

      /* If that's all, return now.  */
      if (current_pc <= pc + 1)
	return current_pc;

      /* Check for `movl %esp, %ebp' -- can be written in two ways.  */
      op = read_memory_unsigned_integer (pc + 1, 1);
      switch (op)
d416 2
a417 2
	  if (read_memory_unsigned_integer (pc + 2, 1) != 0xec)
	    return pc + 1;
d420 2
a421 2
	  if (read_memory_unsigned_integer (pc + 2, 1) != 0xe5)
	    return pc + 1;
d424 1
a424 1
	  return pc + 1;
a425 9

      /* OK, we actually have a frame.  We just don't know how large it is
	 yet.  Set its size to zero.  We'll adjust it if necessary.  */
      cache->locals = 0;

      /* If that's all, return now.  */
      if (current_pc <= pc + 3)
	return current_pc;

d428 1
a428 1
	    subl $XXX, %esp
d432 1
a432 1
      op = read_memory_unsigned_integer (pc + 3, 1);
d436 2
a437 1
	  if (read_memory_unsigned_integer (pc + 4, 1) != 0xec)
d439 7
a445 6
	    return pc + 3;

	  /* `subl' with signed byte immediate (though it wouldn't make
	     sense to be negative).  */
	  cache->locals = read_memory_integer (pc + 5, 1);
	  return pc + 6;
d449 1
d451 2
a452 1
	  if (read_memory_unsigned_integer (pc + 4, 1) != 0xec)
d454 4
a457 2
	    return pc + 3;

d459 2
a460 2
	  cache->locals = read_memory_integer (pc + 5, 4);
	  return pc + 9;
d464 1
a464 2
	  /* Some instruction other than `subl'.  */
	  return pc + 3;
d467 1
a467 1
  else if (op == 0xc8)		/* enter $XXX */
d469 99
a567 3
      cache->locals = read_memory_unsigned_integer (pc + 1, 2);
      return pc + 4;
    }
d569 2
a570 1
  return pc;
d573 1
a573 4
/* Check whether PC points at code that saves registers on the stack.
   If so, it updates CACHE and returns the address of the first
   instruction after the register saves or CURRENT_PC, whichever is
   smaller.  Otherwise, return PC.  */
d576 1
a576 2
i386_analyze_register_saves (CORE_ADDR pc, CORE_ADDR current_pc,
			     struct i386_frame_cache *cache)
d578 1
a578 1
  if (cache->locals >= 0)
d580 1
a580 3
      CORE_ADDR offset;
      unsigned char op;
      int i;
d582 6
a587 6
      offset = - 4 - cache->locals;
      for (i = 0; i < 8 && pc < current_pc; i++)
	{
	  op = read_memory_unsigned_integer (pc, 1);
	  if (op < 0x50 || op > 0x57)
	    break;
d589 4
a592 4
	  cache->saved_regs[op - 0x50] = offset;
	  offset -= 4;
	  pc++;
	}
d595 1
a595 1
  return pc;
d598 10
a607 3
/* Do a full analysis of the prologue at PC and update CACHE
   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
   address where the analysis stopped.
d609 3
d635 2
a636 3
static CORE_ADDR
i386_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
		       struct i386_frame_cache *cache)
d638 35
a672 5
  pc = i386_follow_jump (pc);
  pc = i386_analyze_struct_return (pc, current_pc, cache);
  pc = i386_skip_probe (pc);
  pc = i386_analyze_frame_setup (pc, current_pc, cache);
  return i386_analyze_register_saves (pc, current_pc, cache);
d678 1
a678 1
i386_skip_prologue (CORE_ADDR start_pc)
d680 2
d683 2
a684 3
  {
    0xe8, 0, 0, 0, 0,		/* call 0x0 */
    0x5b,			/* popl %ebx */
d686 4
a689 4
  struct i386_frame_cache cache;
  CORE_ADDR pc;
  unsigned char op;
  int i;
d691 2
a692 4
  cache.locals = -1;
  pc = i386_analyze_prologue (start_pc, 0xffffffff, &cache);
  if (cache.locals < 0)
    return start_pc;
d694 9
a702 1
  /* Found valid frame setup.  */
d706 2
a707 2
     %ebx:

d717 1
d720 1
a720 1
      op = read_memory_unsigned_integer (pc + i, 1);
d726 2
a727 3
      int delta = 6;

      op = read_memory_unsigned_integer (pc + delta, 1);
d729 1
d732 1
a732 2
	  op = read_memory_unsigned_integer (pc + delta + 1, 1);

d734 4
a737 1
	    delta += 3;
d739 4
a742 1
	    delta += 6;
d744 2
a745 3
	    delta = 0;

	  op = read_memory_unsigned_integer (pc + delta, 1);
a746 1

d748 1
a748 2
      if (delta > 0 && op == 0x81
	  && read_memory_unsigned_integer (pc + delta + 1, 1) == 0xc3);
d750 1
a750 1
	  pc += delta + 6;
d753 1
d755 3
a757 1
  return i386_follow_jump (pc);
d760 5
a764 1
/* This function is 64-bit safe.  */
d766 5
a770 2
static CORE_ADDR
i386_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
d772 4
a775 4
  char buf[8];

  frame_unwind_register (next_frame, PC_REGNUM, buf);
  return extract_typed_address (buf, builtin_type_void_func_ptr);
a776 1

d778 2
a779 1
/* Normal frames.  */
d781 2
a782 2
static struct i386_frame_cache *
i386_frame_cache (struct frame_info *next_frame, void **this_cache)
a783 1
  struct i386_frame_cache *cache;
a784 1
  int i;
d786 3
a788 52
  if (*this_cache)
    return *this_cache;

  cache = i386_alloc_frame_cache ();
  *this_cache = cache;

  /* In principle, for normal frames, %ebp holds the frame pointer,
     which holds the base address for the current stack frame.
     However, for functions that don't need it, the frame pointer is
     optional.  For these "frameless" functions the frame pointer is
     actually the frame pointer of the calling frame.  Signal
     trampolines are just a special case of a "frameless" function.
     They (usually) share their frame pointer with the frame that was
     in progress when the signal occurred.  */

  frame_unwind_register (next_frame, I386_EBP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4);
  if (cache->base == 0)
    return cache;

  /* For normal frames, %eip is stored at 4(%ebp).  */
  cache->saved_regs[I386_EIP_REGNUM] = 4;

  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
    i386_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);

  if (cache->locals < 0)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  If
	 we're at the start of a function, or somewhere half-way its
	 prologue, the function's frame probably hasn't been fully
	 setup yet.  Try to reconstruct the base address for the stack
	 frame by looking at the stack pointer.  For truly "frameless"
	 functions this might work too.  */

      frame_unwind_register (next_frame, I386_ESP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 4) + cache->sp_offset;
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of %esp in the calling frame.  */
  cache->saved_sp = cache->base + 8;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < I386_NUM_SAVED_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;

  return cache;
d792 1
a792 2
i386_frame_this_id (struct frame_info *next_frame, void **this_cache,
		    struct frame_id *this_id)
d794 3
a796 1
  struct i386_frame_cache *cache = i386_frame_cache (next_frame, this_cache);
d798 2
a799 3
  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;
d801 1
a801 34
  /* See the end of i386_push_dummy_call.  */
  (*this_id) = frame_id_build (cache->base + 8, cache->pc);
}

static void
i386_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *valuep)
{
  struct i386_frame_cache *cache = i386_frame_cache (next_frame, this_cache);

  gdb_assert (regnum >= 0);

  /* The System V ABI says that:

     "The flags register contains the system flags, such as the
     direction flag and the carry flag.  The direction flag must be
     set to the forward (that is, zero) direction before entry and
     upon exit from a function.  Other user flags have no specified
     role in the standard calling sequence and are not preserved."

     To guarantee the "upon exit" part of that statement we fake a
     saved flags register that has its direction flag cleared.

     Note that GCC doesn't seem to rely on the fact that the direction
     flag is cleared after a function return; it always explicitly
     clears the flag before operations where it matters.

     FIXME: kettenis/20030316: I'm not quite sure whether this is the
     right thing to do.  The way we fake the flags register here makes
     it impossible to change it.  */

  if (regnum == I386_EFLAGS_REGNUM)
d803 3
a805 5
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
d807 2
a808 6
	  ULONGEST val;

	  /* Clear the direction flag.  */
	  frame_unwind_unsigned_register (next_frame, PS_REGNUM, &val);
	  val &= ~(1 << 10);
	  store_unsigned_integer (valuep, 4, val);
a809 23

      return;
    }

  if (regnum == I386_EIP_REGNUM && cache->pc_in_eax)
    {
      frame_register_unwind (next_frame, I386_EAX_REGNUM,
			     optimizedp, lvalp, addrp, realnump, valuep);
      return;
    }

  if (regnum == I386_ESP_REGNUM && cache->saved_sp)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_unsigned_integer (valuep, 4, cache->saved_sp);
	}
      return;
d811 4
a814 71

  if (regnum < I386_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
	}
      return;
    }

  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind i386_frame_unwind =
{
  NORMAL_FRAME,
  i386_frame_this_id,
  i386_frame_prev_register
};

static const struct frame_unwind *
i386_frame_p (CORE_ADDR pc)
{
  return &i386_frame_unwind;
}


/* Signal trampolines.  */

static struct i386_frame_cache *
i386_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct i386_frame_cache *cache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  CORE_ADDR addr;
  char buf[4];

  if (*this_cache)
    return *this_cache;

  cache = i386_alloc_frame_cache ();

  frame_unwind_register (next_frame, I386_ESP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4) - 4;

  addr = tdep->sigcontext_addr (next_frame);
  if (tdep->sc_reg_offset)
    {
      int i;

      gdb_assert (tdep->sc_num_regs <= I386_NUM_SAVED_REGS);

      for (i = 0; i < tdep->sc_num_regs; i++)
	if (tdep->sc_reg_offset[i] != -1)
	  cache->saved_regs[i] = addr + tdep->sc_reg_offset[i];
    }
  else
    {
      cache->saved_regs[I386_EIP_REGNUM] = addr + tdep->sc_pc_offset;
      cache->saved_regs[I386_ESP_REGNUM] = addr + tdep->sc_sp_offset;
    }

  *this_cache = cache;
  return cache;
d818 1
a818 67
i386_sigtramp_frame_this_id (struct frame_info *next_frame, void **this_cache,
			     struct frame_id *this_id)
{
  struct i386_frame_cache *cache =
    i386_sigtramp_frame_cache (next_frame, this_cache);

  /* See the end of i386_push_dummy_call.  */
  (*this_id) = frame_id_build (cache->base + 8, frame_pc_unwind (next_frame));
}

static void
i386_sigtramp_frame_prev_register (struct frame_info *next_frame,
				   void **this_cache,
				   int regnum, int *optimizedp,
				   enum lval_type *lvalp, CORE_ADDR *addrp,
				   int *realnump, void *valuep)
{
  /* Make sure we've initialized the cache.  */
  i386_sigtramp_frame_cache (next_frame, this_cache);

  i386_frame_prev_register (next_frame, this_cache, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind i386_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  i386_sigtramp_frame_this_id,
  i386_sigtramp_frame_prev_register
};

static const struct frame_unwind *
i386_sigtramp_frame_p (CORE_ADDR pc)
{
  char *name;

  /* We shouldn't even bother to try if the OSABI didn't register
     a sigcontext_addr handler.  */
  if (!gdbarch_tdep (current_gdbarch)->sigcontext_addr)
    return NULL;

  find_pc_partial_function (pc, &name, NULL, NULL);
  if (PC_IN_SIGTRAMP (pc, name))
    return &i386_sigtramp_frame_unwind;

  return NULL;
}


static CORE_ADDR
i386_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct i386_frame_cache *cache = i386_frame_cache (next_frame, this_cache);

  return cache->base;
}

static const struct frame_base i386_frame_base =
{
  &i386_frame_unwind,
  i386_frame_base_address,
  i386_frame_base_address,
  i386_frame_base_address
};

static struct frame_id
i386_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d820 1
a820 8
  char buf[4];
  CORE_ADDR fp;

  frame_unwind_register (next_frame, I386_EBP_REGNUM, buf);
  fp = extract_unsigned_integer (buf, 4);

  /* See the end of i386_push_dummy_call.  */
  return frame_id_build (fp + 8, frame_pc_unwind (next_frame));
d828 1
a828 3
   success.

   This function is 64-bit safe.  */
d857 2
a858 4
i386_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
d860 3
a862 5
  char buf[4];
  int i;

  /* Push arguments in reverse order.  */
  for (i = nargs - 1; i >= 0; i--)
d864 1
a864 1
      int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (args[i]));
a865 14
      /* The System V ABI says that:

	 "An argument's size is increased, if necessary, to make it a
	 multiple of [32-bit] words.  This may require tail padding,
	 depending on the size of the argument."

	 This makes sure the stack says word-aligned.  */
      sp -= (len + 3) & ~3;
      write_memory (sp, VALUE_CONTENTS_ALL (args[i]), len);
    }

  /* Push value address.  */
  if (struct_return)
    {
d871 1
a871 22
  /* Store return address.  */
  sp -= 4;
  store_unsigned_integer (buf, 4, bp_addr);
  write_memory (sp, buf, 4);

  /* Finally, update the stack pointer...  */
  store_unsigned_integer (buf, 4, sp);
  regcache_cooked_write (regcache, I386_ESP_REGNUM, buf);

  /* ...and fake a frame pointer.  */
  regcache_cooked_write (regcache, I386_EBP_REGNUM, buf);

  /* MarkK wrote: This "+ 8" is all over the place:
     (i386_frame_this_id, i386_sigtramp_frame_this_id,
     i386_unwind_dummy_id).  It's there, since all frame unwinders for
     a given target have to agree (within a certain margin) on the
     defenition of the stack address of a frame.  Otherwise
     frame_id_inner() won't work correctly.  Since DWARF2/GCC uses the
     stack address *before* the function call as a frame's CFA.  On
     the i386, when %ebp is used as a frame pointer, the offset
     between the contents %ebp and the CFA as defined by GCC.  */
  return sp + 8;
d877 2
a878 2
#define LOW_RETURN_REGNUM	I386_EAX_REGNUM /* %eax */
#define HIGH_RETURN_REGNUM	I386_EDX_REGNUM /* %edx */
d912 1
a912 1
      regcache_raw_read (regcache, I386_ST0_REGNUM, buf);
d974 1
a974 1
      regcache_raw_write (regcache, I386_ST0_REGNUM, buf);
d1015 1
a1015 1
  char buf[4];
d1017 2
a1018 2
  regcache_cooked_read (regcache, I386_EAX_REGNUM, buf);
  return extract_unsigned_integer (buf, 4);
d1060 1
a1060 2
  if (regnum == I386_EIP_REGNUM
      || regnum == I386_EBP_REGNUM || regnum == I386_ESP_REGNUM)
d1076 1
a1076 1
   the MMX registers need to be mapped onto floating point registers.  */
a1129 4


/* These registers don't have pervasive standard uses.  Move them to
   i386-tdep.h if necessary.  */
d1131 5
a1135 7
#define I386_EBX_REGNUM		3 /* %ebx */
#define I386_ECX_REGNUM		1 /* %ecx */
#define I386_ESI_REGNUM		6 /* %esi */
#define I386_EDI_REGNUM		7 /* %edi */

/* Return the register number of the register allocated by GCC after
   REGNUM, or -1 if there is no such register.  */
d1138 1
a1138 1
i386_next_regnum (int regnum)
a1139 50
  /* GCC allocates the registers in the order:

     %eax, %edx, %ecx, %ebx, %esi, %edi, %ebp, %esp, ...

     Since storing a variable in %esp doesn't make any sense we return
     -1 for %ebp and for %esp itself.  */
  static int next_regnum[] =
  {
    I386_EDX_REGNUM,		/* Slot for %eax.  */
    I386_EBX_REGNUM,		/* Slot for %ecx.  */
    I386_ECX_REGNUM,		/* Slot for %edx.  */
    I386_ESI_REGNUM,		/* Slot for %ebx.  */
    -1, -1,			/* Slots for %esp and %ebp.  */
    I386_EDI_REGNUM,		/* Slot for %esi.  */
    I386_EBP_REGNUM		/* Slot for %edi.  */
  };

  if (regnum >= 0 && regnum < sizeof (next_regnum) / sizeof (next_regnum[0]))
    return next_regnum[regnum];

  return -1;
}

/* Return nonzero if a value of type TYPE stored in register REGNUM
   needs any special handling.  */

static int
i386_convert_register_p (int regnum, struct type *type)
{
  int len = TYPE_LENGTH (type);

  /* Values may be spread across multiple registers.  Most debugging
     formats aren't expressive enough to specify the locations, so
     some heuristics is involved.  Right now we only handle types that
     have a length that is a multiple of the word size, since GCC
     doesn't seem to put any other types into registers.  */
  if (len > 4 && len % 4 == 0)
    {
      int last_regnum = regnum;

      while (len > 4)
	{
	  last_regnum = i386_next_regnum (last_regnum);
	  len -= 4;
	}

      if (last_regnum != -1)
	return 1;
    }

d1143 2
a1144 2
/* Read a value of type TYPE from register REGNUM in frame FRAME, and
   return its contents in TO.  */
d1147 2
a1148 2
i386_register_to_value (struct frame_info *frame, int regnum,
			struct type *type, void *to)
d1150 1
a1150 5
  int len = TYPE_LENGTH (type);
  char *buf = to;

  /* FIXME: kettenis/20030609: What should we do if REGNUM isn't
     available in FRAME (i.e. if it wasn't saved)?  */
d1152 2
a1153 1
  if (i386_fp_regnum_p (regnum))
d1155 3
a1157 1
      i387_register_to_value (frame, regnum, type, to);
d1161 3
a1163 14
  /* Read a value spread accross multiple registers.  */

  gdb_assert (len > 4 && len % 4 == 0);

  while (len > 0)
    {
      gdb_assert (regnum != -1);
      gdb_assert (register_size (current_gdbarch, regnum) == 4);

      frame_read_register (frame, regnum, buf);
      regnum = i386_next_regnum (regnum);
      len -= 4;
      buf += 4;
    }
d1166 2
a1167 2
/* Write the contents FROM of a value of type TYPE into register
   REGNUM in frame FRAME.  */
d1170 2
a1171 2
i386_value_to_register (struct frame_info *frame, int regnum,
			struct type *type, const void *from)
d1173 1
a1173 2
  int len = TYPE_LENGTH (type);
  const char *buf = from;
d1175 2
a1176 1
  if (i386_fp_regnum_p (regnum))
d1178 3
a1180 1
      i387_value_to_register (frame, regnum, type, from);
d1184 3
a1186 14
  /* Write a value spread accross multiple registers.  */

  gdb_assert (len > 4 && len % 4 == 0);

  while (len > 0)
    {
      gdb_assert (regnum != -1);
      gdb_assert (register_size (current_gdbarch, regnum) == 4);

      put_frame_register (frame, regnum, buf);
      regnum = i386_next_regnum (regnum);
      len -= 4;
      buf += 4;
    }
d1188 1
a1188 2


a1276 2
  /* UnixWare uses _sigacthandler.  The origin of the other symbols is
     currently unknown.  */
d1282 2
a1283 3
/* Assuming NEXT_FRAME is for a frame following a SVR4 sigtramp
   routine, return the address of the associated sigcontext (ucontext)
   structure.  */
d1286 1
a1286 1
i386_svr4_sigcontext_addr (struct frame_info *next_frame)
d1288 13
a1300 2
  char buf[4];
  CORE_ADDR sp;
d1302 1
a1302 2
  frame_unwind_register (next_frame, I386_ESP_REGNUM, buf);
  sp = extract_unsigned_integer (buf, 4);
d1304 3
a1306 1
  return read_memory_unsigned_integer (sp + 8, 4);
d1345 2
a1346 2
  tdep->sc_pc_offset = 36 + 14 * 4;
  tdep->sc_sp_offset = 36 + 17 * 4;
a1409 1

a1419 1

a1421 11


/* Get the ith function argument for the current function.  */
static CORE_ADDR
i386_fetch_pointer_argument (struct frame_info *frame, int argi, 
			     struct type *type)
{
  CORE_ADDR stack;
  frame_read_register (frame, SP_REGNUM, &stack);
  return read_memory_unsigned_integer (stack + (4 * (argi + 1)), 4);
}
d1439 4
a1452 1
  tdep->sc_reg_offset = NULL;
d1467 2
a1468 2
  /* The default ABI includes general-purpose registers and
     floating-point registers.  */
a1469 2
  set_gdbarch_register_name (gdbarch, i386_register_name);
  set_gdbarch_register_type (gdbarch, i386_register_type);
d1471 5
a1475 5
  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, I386_ESP_REGNUM); /* %esp */
  set_gdbarch_pc_regnum (gdbarch, I386_EIP_REGNUM); /* %eip */
  set_gdbarch_ps_regnum (gdbarch, I386_EFLAGS_REGNUM); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, I386_ST0_REGNUM); /* %st(0) */
d1488 5
d1498 2
a1499 1
  set_gdbarch_push_dummy_call (gdbarch, i386_push_dummy_call);
d1501 9
a1509 3
  set_gdbarch_convert_register_p (gdbarch, i386_convert_register_p);
  set_gdbarch_register_to_value (gdbarch,  i386_register_to_value);
  set_gdbarch_value_to_register (gdbarch, i386_value_to_register);
d1512 3
d1520 1
d1530 5
d1536 6
a1550 4
  set_gdbarch_unwind_dummy_id (gdbarch, i386_unwind_dummy_id);

  set_gdbarch_unwind_pc (gdbarch, i386_unwind_pc);

d1555 2
a1556 8
  /* Helper for function argument information.  */
  set_gdbarch_fetch_pointer_argument (gdbarch, i386_fetch_pointer_argument);

  /* Hook in the DWARF CFI frame unwinder.  */
  frame_unwind_append_predicate (gdbarch, dwarf2_frame_p);
  set_gdbarch_dwarf2_build_frame_info (gdbarch, dwarf2_build_frame_info);

  frame_base_set_default (gdbarch, &i386_frame_base);
a1559 3

  frame_unwind_append_predicate (gdbarch, i386_sigtramp_frame_p);
  frame_unwind_append_predicate (gdbarch, i386_frame_p);
@


1.88.2.9
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d854 1
a854 1
i386_frame_sniffer (struct frame_info *next_frame)
d932 1
a932 1
i386_sigtramp_frame_sniffer (struct frame_info *next_frame)
a933 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d1814 2
a1815 1
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
d1822 2
a1823 2
  frame_unwind_append_sniffer (gdbarch, i386_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, i386_frame_sniffer);
@


1.88.2.10
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a43 1
#include "dis-asm.h"
a441 1
  int skip = 0;
d459 1
a460 34

      /* Check for some special instructions that might be migrated
	 by GCC into the prologue.  We check for

	    xorl %ebx, %ebx
	    xorl %ecx, %ecx
	    xorl %edx, %edx

	 and the equivalent

	    subl %ebx, %ebx
	    subl %ecx, %ecx
	    subl %edx, %edx

	 Make sure we only skip these instructions if we later see the
	 `movl %esp, %ebp' that actually sets up the frame.  */
      while (op == 0x29 || op == 0x31)
	{
	  op = read_memory_unsigned_integer (pc + skip + 2, 1);
	  switch (op)
	    {
	    case 0xdb:	/* %ebx */
	    case 0xc9:	/* %ecx */
	    case 0xd2:	/* %edx */
	      skip += 2;
	      break;
	    default:
	      return pc + 1;
	    }

	  op = read_memory_unsigned_integer (pc + skip + 1, 1);
	}

      /* Check for `movl %esp, %ebp' -- can be written in two ways.  */
d464 1
a464 1
	  if (read_memory_unsigned_integer (pc + skip + 2, 1) != 0xec)
d468 1
a468 1
	  if (read_memory_unsigned_integer (pc + skip + 2, 1) != 0xe5)
d475 2
a476 4
      /* OK, we actually have a frame.  We just don't know how large
	 it is yet.  Set its size to zero.  We'll adjust it if
	 necessary.  We also now commit to skipping the special
	 instructions mentioned before.  */
a477 1
      pc += skip;
d537 1
a537 7
  CORE_ADDR offset = 0;
  unsigned char op;
  int i;

  if (cache->locals > 0)
    offset -= cache->locals;
  for (i = 0; i < 8 && pc < current_pc; i++)
d539 3
a541 3
      op = read_memory_unsigned_integer (pc, 1);
      if (op < 0x50 || op > 0x57)
	break;
d543 11
a553 4
      offset -= 4;
      cache->saved_regs[op - 0x50] = offset;
      cache->sp_offset += 4;
      pc++;
d798 1
a798 2
	  val = frame_unwind_register_unsigned (next_frame,
						I386_EFLAGS_REGNUM);
d1001 1
a1001 4
  /* Don't use I386_ESP_REGNUM here, since this function is also used
     for AMD64.  */
  regcache_cooked_read (current_regcache, SP_REGNUM, buf);
  sp = extract_typed_address (buf, builtin_type_void_data_ptr);
d1005 1
a1005 1
  jb_addr = extract_typed_address (buf, builtin_type_void_data_ptr);
d1114 2
a1115 2
      int low_size = register_size (current_gdbarch, LOW_RETURN_REGNUM);
      int high_size = register_size (current_gdbarch, HIGH_RETURN_REGNUM);
d1188 2
a1189 2
      int low_size = register_size (current_gdbarch, LOW_RETURN_REGNUM);
      int high_size = register_size (current_gdbarch, HIGH_RETURN_REGNUM);
d1303 1
a1303 1
      memcpy (buf, mmx_buf, register_size (gdbarch, regnum));
d1321 1
a1321 1
      memcpy (mmx_buf, buf, register_size (gdbarch, regnum));
d1425 1
a1425 1
      get_frame_register (frame, regnum, buf);
d1529 1
a1529 1
i386_print_insn (bfd_vma pc, struct disassemble_info *info)
d1693 1
a1693 2
/* Get the ARGIth function argument for the current function.  */

d1698 3
a1700 2
  CORE_ADDR sp = get_frame_register_unsigned  (frame, I386_ESP_REGNUM);
  return read_memory_unsigned_integer (sp + (4 * (argi + 1)), 4);
d1719 1
a1719 14
  /* The i386 default settings now include the SSE registers.
     I386_NUM_XREGS includes mxcsr, and we don't want to count
     this as one of the xmm regs -- which is why we subtract one.

     Note: kevinb/2003-07-14: Whatever Mark's concerns are about the
     FPU registers in the FIXME below apply to the SSE registers as well.
     The only problem that I see is that these registers will show up
     in "info all-registers" even on CPUs where they don't exist.  IMO,
     however, if it's a choice between printing them always (even when
     they don't exist) or never showing them to the user (even when they
     do exist), I prefer the former over the latter.  Ideally, of course,
     we'd somehow autodetect that we have them (or not) and display them
     when we have them and suppress them when we don't.

d1722 1
a1722 1
  tdep->num_xmm_regs = I386_NUM_XREGS - 1;
d1744 3
a1746 3
  /* The default ABI includes general-purpose registers, 
     floating-point registers, and the SSE registers.  */
  set_gdbarch_num_regs (gdbarch, I386_SSE_NUM_REGS);
@


1.88.2.11
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a39 1
#include "regset.h"
d70 2
a71 1
static const int i386_num_register_names = ARRAY_SIZE (i386_register_names);
d81 4
a84 1
static const int i386_num_mmx_regs = ARRAY_SIZE (i386_mmx_names);
d87 1
a87 1
i386_mmx_regnum_p (struct gdbarch *gdbarch, int regnum)
d89 2
a90 6
  int mm0_regnum = gdbarch_tdep (gdbarch)->mm0_regnum;

  if (mm0_regnum < 0)
    return 0;

  return (regnum >= mm0_regnum && regnum < mm0_regnum + i386_num_mmx_regs);
d93 1
a93 1
/* SSE register?  */
d95 2
a96 2
static int
i386_sse_regnum_p (struct gdbarch *gdbarch, int regnum)
d98 2
a99 12
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

#define I387_ST0_REGNUM tdep->st0_regnum
#define I387_NUM_XMM_REGS tdep->num_xmm_regs

  if (I387_NUM_XMM_REGS == 0)
    return 0;

  return (I387_XMM0_REGNUM <= regnum && regnum < I387_MXCSR_REGNUM);

#undef I387_ST0_REGNUM
#undef I387_NUM_XMM_REGS
d102 2
a103 2
static int
i386_mxcsr_regnum_p (struct gdbarch *gdbarch, int regnum)
d105 2
a106 12
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

#define I387_ST0_REGNUM tdep->st0_regnum
#define I387_NUM_XMM_REGS tdep->num_xmm_regs

  if (I387_NUM_XMM_REGS == 0)
    return 0;

  return (regnum == I387_MXCSR_REGNUM);

#undef I387_ST0_REGNUM
#undef I387_NUM_XMM_REGS
d109 1
a109 5
#define I387_ST0_REGNUM (gdbarch_tdep (current_gdbarch)->st0_regnum)
#define I387_MM0_REGNUM (gdbarch_tdep (current_gdbarch)->mm0_regnum)
#define I387_NUM_XMM_REGS (gdbarch_tdep (current_gdbarch)->num_xmm_regs)

/* FP register?  */
d112 1
a112 1
i386_fp_regnum_p (int regnum)
d114 2
a115 4
  if (I387_ST0_REGNUM < 0)
    return 0;

  return (I387_ST0_REGNUM <= regnum && regnum < I387_FCTRL_REGNUM);
d119 1
a119 1
i386_fpc_regnum_p (int regnum)
d121 2
a122 4
  if (I387_ST0_REGNUM < 0)
    return 0;

  return (I387_FCTRL_REGNUM <= regnum && regnum < I387_XMM0_REGNUM);
d130 2
a131 2
  if (i386_mmx_regnum_p (current_gdbarch, reg))
    return i386_mmx_names[reg - I387_MM0_REGNUM];
d154 1
a154 1
      return reg - 12 + I387_ST0_REGNUM;
d159 1
a159 1
      return reg - 21 + I387_XMM0_REGNUM;
d164 1
a164 1
      return reg - 29 + I387_MM0_REGNUM;
d187 1
a187 1
      return reg - 11 + I387_ST0_REGNUM;
a197 4

#undef I387_ST0_REGNUM
#undef I387_MM0_REGNUM
#undef I387_NUM_XMM_REGS
a468 1
	    xorl %eax, %eax
a474 1
	    subl %eax, %eax
a485 1
	    case 0xc0:	/* %eax */
a1125 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
d1139 1
a1139 1
      if (tdep->st0_regnum < 0)
a1182 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
a1184 4
  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for the architecture.  */
#define I387_ST0_REGNUM I386_ST0_REGNUM

d1195 1
a1195 1
      char buf[I386_MAX_REGISTER_SIZE];
d1197 1
a1197 1
      if (tdep->st0_regnum < 0)
d1218 1
a1218 1
      regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM, &fstat);
d1220 1
a1220 1
      regcache_raw_write_unsigned (regcache, I387_FSTAT_REGNUM, fstat);
d1225 1
a1225 1
      regcache_raw_write_unsigned (regcache, I387_FTAG_REGNUM, 0x3fff);
a1243 2

#undef I387_ST0_REGNUM
d1305 1
a1305 1
  if (i386_sse_regnum_p (gdbarch, regnum))
d1308 1
a1308 1
  if (i386_mmx_regnum_p (gdbarch, regnum))
d1320 1
a1320 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  int mmxreg, fpreg;
d1323 1
d1325 2
a1326 6
  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for REGCACHE's architecture.  */
#define I387_ST0_REGNUM tdep->st0_regnum

  mmxreg = regnum - tdep->mm0_regnum;
  regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM, &fstat);
d1328 1
a1328 1
  fpreg = (mmxreg + tos) % 8;
d1330 1
a1330 3
  return (I387_ST0_REGNUM + fpreg);

#undef I387_ST0_REGNUM
d1337 1
a1337 1
  if (i386_mmx_regnum_p (gdbarch, regnum))
d1354 1
a1354 1
  if (i386_mmx_regnum_p (gdbarch, regnum))
d1371 8
a1504 50
/* Supply register REGNUM from the general-purpose register set REGSET
   to register cache REGCACHE.  If REGNUM is -1, do this for all
   registers in REGSET.  */

static void
i386_supply_gregset (const struct regset *regset, struct regcache *regcache,
		     int regnum, const void *gregs, size_t len)
{
  const struct gdbarch_tdep *tdep = regset->descr;
  const char *regs = gregs;
  int i;

  gdb_assert (len == tdep->sizeof_gregset);

  for (i = 0; i < tdep->gregset_num_regs; i++)
    {
      if ((regnum == i || regnum == -1)
	  && tdep->gregset_reg_offset[i] != -1)
	regcache_raw_supply (regcache, i, regs + tdep->gregset_reg_offset[i]);
    }
}

/* Supply register REGNUM from the floating-point register set REGSET
   to register cache REGCACHE.  If REGNUM is -1, do this for all
   registers in REGSET.  */

static void
i386_supply_fpregset (const struct regset *regset, struct regcache *regcache,
		      int regnum, const void *fpregs, size_t len)
{
  const struct gdbarch_tdep *tdep = regset->descr;

  if (len == I387_SIZEOF_FXSAVE)
    {
      i387_supply_fxsave (regcache, regnum, fpregs);
      return;
    }

  gdb_assert (len == tdep->sizeof_fpregset);
  i387_supply_fsave (regcache, regnum, fpregs);
}

/* Return the appropriate register set for the core section identified
   by SECT_NAME and SECT_SIZE.  */

const struct regset *
i386_regset_from_core_section (struct gdbarch *gdbarch,
			       const char *sect_name, size_t sect_size)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
a1505 27
  if (strcmp (sect_name, ".reg") == 0 && sect_size == tdep->sizeof_gregset)
    {
      if (tdep->gregset == NULL)
	{
	  tdep->gregset = XMALLOC (struct regset);
	  tdep->gregset->descr = tdep;
	  tdep->gregset->supply_regset = i386_supply_gregset;
	}
      return tdep->gregset;
    }

  if ((strcmp (sect_name, ".reg2") == 0 && sect_size == tdep->sizeof_fpregset)
      || (strcmp (sect_name, ".reg-xfp") == 0
	  && sect_size == I387_SIZEOF_FXSAVE))
    {
      if (tdep->fpregset == NULL)
	{
	  tdep->fpregset = XMALLOC (struct regset);
	  tdep->fpregset->descr = tdep;
	  tdep->fpregset->supply_regset = i386_supply_fpregset;
	}
      return tdep->fpregset;
    }

  return NULL;
}

d1713 2
a1714 2
  int sse_regnum_p = (i386_sse_regnum_p (gdbarch, regnum)
		      || i386_mxcsr_regnum_p (gdbarch, regnum));
d1717 1
a1717 1
  int mmx_regnum_p = (i386_mmx_regnum_p (gdbarch, regnum));
d1760 13
a1772 30
  /* General-purpose registers.  */
  tdep->gregset = NULL;
  tdep->gregset_reg_offset = NULL;
  tdep->gregset_num_regs = I386_NUM_GREGS;
  tdep->sizeof_gregset = 0;

  /* Floating-point registers.  */
  tdep->fpregset = NULL;
  tdep->sizeof_fpregset = I387_SIZEOF_FSAVE;

  /* The default settings include the FPU registers, the MMX registers
     and the SSE registers.  This can be overidden for a specific ABI
     by adjusting the members `st0_regnum', `mm0_regnum' and
     `num_xmm_regs' of `struct gdbarch_tdep', otherwise the registers
     will show up in the output of "info all-registers".  Ideally we
     should try to autodetect whether they are available, such that we
     can prevent "info all-registers" from displaying registers that
     aren't available.

     NOTE: kevinb/2003-07-13: ... if it's a choice between printing
     [the SSE registers] always (even when they don't exist) or never
     showing them to the user (even when they do exist), I prefer the
     former over the latter.  */

  tdep->st0_regnum = I386_ST0_REGNUM;

  /* The MMX registers are implemented as pseudo-registers.  Put off
     caclulating the register number for %mm0 until we know the number
     of raw registers.  */
  tdep->mm0_regnum = 0;
d1774 2
a1775 1
  /* I386_NUM_XREGS includes %mxcsr, so substract one.  */
a1877 12

  /* If we have a register mapping, enable the generic core file
     support, unless it has already been enabled.  */
  if (tdep->gregset_reg_offset
      && !gdbarch_regset_from_core_section_p (gdbarch))
    set_gdbarch_regset_from_core_section (gdbarch,
					  i386_regset_from_core_section);

  /* Unless support for MMX has been disabled, make %mm0 the first
     pseudo-register.  */
  if (tdep->mm0_regnum == 0)
    tdep->mm0_regnum = gdbarch_num_regs (gdbarch);
@


1.88.2.12
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a510 4
	 Because of the symmetry, there are actually two ways to
	 encode these instructions; with opcode bytes 0x29 and 0x2b
	 for `subl' and opcode bytes 0x31 and 0x33 for `xorl'.

d513 1
a513 1
      while (op == 0x29 || op == 0x2b || op == 0x31 || op == 0x33)
d1154 3
a1156 2
/* Read, for architecture GDBARCH, a function return value of TYPE
   from REGCACHE, and copy that into VALBUF.  */
d1159 2
a1160 2
i386_extract_return_value (struct gdbarch *gdbarch, struct type *type,
			   struct regcache *regcache, void *valbuf)
d1162 2
a1163 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1167 7
d1205 1
a1205 1
	  memcpy ((char *) valbuf + low_size, buf, len - low_size);
d1213 2
a1214 2
/* Write, for architecture GDBARCH, a function return value of TYPE
   from VALBUF into REGCACHE.  */
d1217 2
a1218 2
i386_store_return_value (struct gdbarch *gdbarch, struct type *type,
			 struct regcache *regcache, const void *valbuf)
d1220 1
a1220 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1227 7
a1317 4
/* Return non-zero if TYPE, which is assumed to be a structure or
   union type, should be returned in registers for architecture
   GDBARCH.  */

d1319 1
a1319 1
i386_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)
d1321 1
a1321 3
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum type_code code = TYPE_CODE (type);
  int len = TYPE_LENGTH (type);
d1323 6
a1328 6
  gdb_assert (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION);

  if (struct_convention == pcc_struct_convention
      || (struct_convention == default_struct_convention
	  && tdep->struct_return == pcc_struct_return))
    return 0;
d1330 2
a1331 38
  return (len == 1 || len == 2 || len == 4 || len == 8);
}

/* Determine, for architecture GDBARCH, how a return value of TYPE
   should be returned.  If it is supposed to be returned in registers,
   and READBUF is non-zero, read the appropriate value from REGCACHE,
   and copy it into READBUF.  If WRITEBUF is non-zero, write the value
   from WRITEBUF into REGCACHE.  */

static enum return_value_convention
i386_return_value (struct gdbarch *gdbarch, struct type *type,
		   struct regcache *regcache, void *readbuf,
		   const void *writebuf)
{
  enum type_code code = TYPE_CODE (type);

  if ((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION)
      && !i386_reg_struct_return_p (gdbarch, type))
    return RETURN_VALUE_STRUCT_CONVENTION;

  /* This special case is for structures consisting of a single
     `float' or `double' member.  These structures are returned in
     %st(0).  For these structures, we call ourselves recursively,
     changing TYPE into the type of the first member of the structure.
     Since that should work for all structures that have only one
     member, we don't bother to check the member's type here.  */
  if (code == TYPE_CODE_STRUCT && TYPE_NFIELDS (type) == 1)
    {
      type = check_typedef (TYPE_FIELD_TYPE (type, 0));
      return i386_return_value (gdbarch, type, regcache, readbuf, writebuf);
    }

  if (readbuf)
    i386_extract_return_value (gdbarch, type, regcache, readbuf);
  if (writebuf)
    i386_store_return_value (gdbarch, type, regcache, writebuf);

  return RETURN_VALUE_REGISTER_CONVENTION;
d1551 1
a1551 1
void
d1967 2
a1968 1
  set_gdbarch_return_value (gdbarch, i386_return_value);
d1971 1
@


1.88.2.13
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d4 1
a4 2
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d1277 13
d1998 2
d2008 1
@


1.87
log
@* i386-tdep.c (gdb_print_insn_i386): Removed.
(i386_print_insn): New function.
(i386_gdbarch_init): Set print_insn to i386_print_insns.
(_initialize_i386_tdep): Don't initialize tm_print_insn and
tm_print_insn_info.
@
text
@d538 2
a539 2
    return generic_read_register_dummy (frame->pc, frame->frame,
					PC_REGNUM);
@


1.86
log
@* i386-tdep.c (i386_register_virtual_type,
i386_register_convertible, i386_register_convert_to_virtual,
i386_register_comvert_to_raw): Use FP_REGNUM_P and SSE_REGNUM_P
instead of IS_FP_REGNUM and IS_SSE_REGNUM.
(i386_gdbarch_init): Fix comment.  Add comments on calls that set
sp_regnum, fp_regnum, pc_regnum, ps_regnum and fp0_regnum.
Don't set push_arguments twice.
@
text
@d1291 1
a1291 1
gdb_print_insn_i386 (bfd_vma memaddr, disassemble_info *info)
d1293 9
a1301 7
  if (disassembly_flavor == att_flavor)
    return print_insn_i386_att (memaddr, info);
  else if (disassembly_flavor == intel_flavor)
    return print_insn_i386_intel (memaddr, info);
  /* Never reached -- disassembly_flavour is always either att_flavor
     or intel_flavor.  */
  internal_error (__FILE__, __LINE__, "failed internal consistency check");
d1574 2
a1606 3
  tm_print_insn = gdb_print_insn_i386;
  tm_print_insn_info.mach = bfd_lookup_arch (bfd_arch_i386, 0)->mach;

d1627 1
a1627 1
				 valid_conventions,
@


1.85
log
@* i386-tdep.c (i386_store_return_value): Undeprecate.  Convert to
use regcache_* functions.
(i386_gdbarch_init): Set store_return_value instead of
deprecated_store_return_value.
@
text
@d1105 1
a1105 1
  if (IS_FP_REGNUM (regnum))
d1108 1
a1108 1
  if (IS_SSE_REGNUM (regnum))
d1178 1
a1178 1
  return IS_FP_REGNUM (regnum);
d1188 1
a1188 1
  gdb_assert (IS_FP_REGNUM (regnum));
d1211 1
a1211 1
  gdb_assert (IS_FP_REGNUM (regnum));
d1463 1
a1463 1
  /* Although the i386 extended floating-point has only 80 significant
d1472 5
a1476 5
  set_gdbarch_sp_regnum (gdbarch, 4);
  set_gdbarch_fp_regnum (gdbarch, 5);
  set_gdbarch_pc_regnum (gdbarch, 8);
  set_gdbarch_ps_regnum (gdbarch, 9);
  set_gdbarch_fp0_regnum (gdbarch, 16);
a1520 1
  set_gdbarch_push_arguments (gdbarch, i386_push_arguments);
@


1.84
log
@Index: ChangeLog
===================================================================
RCS file: /cvs/src/src/gdb/ChangeLog,v
retrieving revision 1.3144
diff -u -r1.3144 ChangeLog
--- ChangeLog	23 Aug 2002 23:05:38 -0000	1.3144
+++ ChangeLog	23 Aug 2002 23:14:45 -0000
@@@@ -1,3 +1,53 @@@@
2002-08-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (STORE_RETURN_VALUE): Add regcache parameter.
	(DEPRECATED_STORE_RETURN_VALUE): New method.
	(EXTRACT_RETURN_VALUE): Make buffer parameter a void pointer.
	* gdbarch.h, gdbarch.c: Re-generate.

	* values.c (set_return_value): Pass current_regcache to
	STORE_RETURN_VALUE.
	* arch-utils.h (legacy_store_return_value): Declare.
	* arch-utils.c (legacy_store_return_value): New function.
	(legacy_extract_return_value): Update parameters.

	* config/pa/tm-hppa.h (DEPRECATED_STORE_RETURN_VALUE): Rename
	STORE_RETURN_VALUE.
	* config/pa/tm-hppa64.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/z8k/tm-z8k.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparclet.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/mn10200/tm-mn10200.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-linux.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m32r/tm-m32r.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8500/tm-h8500.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8300/tm-h8300.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.

	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* i386-tdep.c (i386_extract_return_value): Update.
	* arch-utils.c (legacy_extract_return_value): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.

Index: doc/ChangeLog
2002-08-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Update
	STORE_RETURN_VALUE, mention regcache.
@
text
@d976 2
a977 1
i386_store_return_value (struct type *type, char *valbuf)
d984 1
a984 1
      i386_store_return_value (TYPE_FIELD_TYPE (type, 0), valbuf);
d990 1
a990 1
      unsigned int fstat;
d1008 1
a1008 1
      write_register_gen (FP0_REGNUM, buf);
d1014 1
a1014 1
      fstat = read_register (FSTAT_REGNUM);
d1016 1
a1016 1
      write_register (FSTAT_REGNUM, fstat);
d1021 1
a1021 1
      write_register (FTAG_REGNUM, 0x3fff);
d1029 1
a1029 1
	write_register_bytes (REGISTER_BYTE (LOW_RETURN_REGNUM), valbuf, len);
d1032 3
a1034 4
	  write_register_bytes (REGISTER_BYTE (LOW_RETURN_REGNUM),
				valbuf, low_size);
	  write_register_bytes (REGISTER_BYTE (HIGH_RETURN_REGNUM),
				valbuf + low_size, len - low_size);
d1536 1
a1536 1
  set_gdbarch_deprecated_store_return_value (gdbarch, i386_store_return_value);
@


1.84.4.1
log
@2002-08-26  Andrew Cagney  <ac131313@@redhat.com>

	* i386-tdep.c: Include "reggroups.h".
	(i386_register_reggroup_p): New function.
	(i386_add_reggroups, i386_init_reggroups): New function.
	(i386_gdbarch_init): Call i386_add_reggroups.  Set
	register_reggroup_p.
	(_initialize_i386_tdep): Call i386_init_reggroups.

	* infcmd.c: Include <ctype.h>.
	(registers_info): Rewrite.  Handle reggroups.
	(default_print_registers_info): Use gdbarch_register_reggroup_p.
	(print_float_info): Use gdbarch_register_reggroup_p.

	* regcache.c: Include "reggroups.h".
	(regcache_dump): Include the register groups in the ``maint print
	registers'' command.

	* infcmd.c: Include "regroup.h".
	(default_print_registers_info): Use gdbarch_register_reggroup_p.
	(print_float_info): Ditto.

	* gdbarch.sh: Include "reggroups.h".
	(register_reggroup_p): New method.
	(struct reggroup): Add opaque declaration.
	* gdbarch.h, gdbarch.c: Regenerate.

	* Makefile.in (SFILES): Add reggroups.c.
	(reggroups_h): Define.
	(COMMON_OBS): Add reggroups.o.
	(reggroups.o): Specify dependencies.
	(gdbarch.o, infcmd.o, i386-tdep.o): Update dependencies.

	* reggroups.c: New file.
	* reggroups.h: New file.
@
text
@a39 1
#include "reggroups.h"
a1415 43
/* i386 register groups.  In addition to the normal groups, add "mmx"
   and "sse".  */

struct reggroup *i368_sse_reggroup;
struct reggroup *i368_mmx_reggroup;

static void
i386_init_reggroups (void)
{
  i368_sse_reggroup = reggroup_new ("sse");
  i368_mmx_reggroup = reggroup_new ("mmx");
}

static void
i386_add_reggroups (struct gdbarch *gdbarch)
{
  reggroup_add (gdbarch, i368_sse_reggroup);
  reggroup_add (gdbarch, i368_mmx_reggroup);
  reggroup_add (gdbarch, general_reggroup);
  reggroup_add (gdbarch, float_reggroup);
  reggroup_add (gdbarch, all_reggroup);
  reggroup_add (gdbarch, vector_reggroup);
  reggroup_add (gdbarch, system_reggroup);
}

static int
i386_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			  struct reggroup *group)
{
  if (group == all_reggroup)
    return 1;
  if (mmx_regnum_p (regnum) || regnum == MXCSR_REGNUM)
    return (group == i368_mmx_reggroup || group == vector_reggroup);
  if (FP_REGNUM_P (regnum) || FPC_REGNUM_P (regnum))
    return (group == float_reggroup || group == all_reggroup);
  if (SSE_REGNUM_P (regnum))
    return (group == i368_sse_reggroup || group == vector_reggroup);
  if (group == general_reggroup)
    return 1;
  return 0;
}


a1572 4
  /* Add the i386 register groups.  */
  i386_add_reggroups (gdbarch);
  set_gdbarch_register_reggroup_p (gdbarch, i386_register_reggroup_p);

a1645 3

  /* Define the i386 specific register groups.  */
  i386_init_reggroups ();
@


1.84.4.2
log
@2002-08-28  Andrew Cagney  <ac131313@@redhat.com>

	* infcmd.c (registers_info): Pass start, instead of addr_exp, to
	target_map_name_to_register.
	(default_print_registers_info): Use all_reggroup and
	general_reggroup to decide if all, general registers should be
	displayed.
	* i386-tdep.c (i386_register_reggroup_p): Move mxcsr to SSE group.
@
text
@d1448 1
a1448 1
  if (mmx_regnum_p (regnum))
d1452 1
a1452 1
  if (SSE_REGNUM_P (regnum) || regnum == MXCSR_REGNUM)
@


1.84.4.3
log
@2002-08-28  Andrew Cagney  <cagney@@redhat.com>

	* osabi.c (gdbarch_init_osabi): Allow a NULL abfd.
	(gdb_osabi_names): Add "RedBoot".
	* osabi.h (gdb_osabi): Add GDB_OSABI_REDBOOT.
	* i386-tdep.c (i386_gdbarch_init): Force RedBoot OSABI.

	* i386-tdep.h (i386_pseudo_register_read): Declare.
	(i386_pseudo_register_write): Declare.
	(i386_register_virtual_type): Declare.
	(i386_register_reggroup_p): Declare.
	* i386-tdep.c (i386_pseudo_register_read): Make global.
	(i386_pseudo_register_write): Make global.
	(i386_register_reggroup_p): Make global.
	(i386_register_virtual_type): Make global.

	* config/i386/embed.mt (TDEPFILES): Add i386-rb-tdep.c.
	(TM_FILE): Set to tm-embed.h.
	* config/i386/tm-embed.h: New file.
	* i386-rb-tdep.c: New file.  Based on code by Fernando Nasser.

	* remote.c (remote_fetch_registers): Call fetch_register_using_p.
	(fetch_register_using_p): New function.
	(init_remote_state): If defined, use GPACKET_UPPER_BOUND_HACK to
	identify a register that isn't in the G packet.
@
text
@d1100 1
a1100 1
struct type *
d1135 1
a1135 1
void
d1151 1
a1151 1
void
d1442 1
a1442 1
int
a1469 3
  /* Hack, force redboot.  */
  if (osabi == GDB_OSABI_UNKNOWN)
    osabi = GDB_OSABI_REDBOOT;
@


1.84.4.4
log
@2002-09-13  Andrew Cagney  <cagney@@redhat.com>

	* i386-tdep.c (i386_add_reggroups): Add save_reggroup and
	restore_reggroup.
	(i386_register_reggroup_p): Rewrite.  Use
	default_register_reggroup_p.

	* reggroups.h (save_reggroup, restore_reggroup): Declare.
	* reggroups.c (save_reggroup, restore_reggroup): Define.
	(_initialize_reggroup): Add save_reggroup and restore_reggroup to
	default_groups.
	* regcache.c (regcache_restore): Restore the registers in
	restore_reggroup.
	(regcache_save): Save registers in save_reggroup.
@
text
@a1437 2
  reggroup_add (gdbarch, save_reggroup);
  reggroup_add (gdbarch, restore_reggroup);
d1446 8
a1453 10
  int sse_regnum_p = SSE_REGNUM_P (regnum) || regnum == MXCSR_REGNUM;
  int fp_regnum_p = FP_REGNUM_P (regnum) || FPC_REGNUM_P (regnum);
  if (group == i368_mmx_reggroup)
    return mmx_regnum_p (regnum);
  if (group == i368_sse_reggroup)
    return sse_regnum_p;
  if (group == vector_reggroup)
    return (mmx_regnum_p (regnum) || sse_regnum_p);
  if (group == float_reggroup)
    return (FP_REGNUM_P (regnum) || FPC_REGNUM_P (regnum));
d1456 1
a1456 3
  if (group == save_reggroup || group == restore_reggroup)
    return (regnum < NUM_REGS);
  return default_register_reggroup_p (gdbarch, regnum, group);
@


1.84.4.5
log
@2002-09-19  Andrew Cagney  <cagney@@redhat.com>

	* i386-tdep.c (i386_sse_reggroup, i386_mmx_reggroup): Replace
	i368_sse_reggroup and i368_mmx_reggroup.
	(i386_register_reggroup_p, i386_init_reggroups): Update.
	(i386_add_reggroups): Update.
@
text
@d1420 2
a1421 2
struct reggroup *i386_sse_reggroup;
struct reggroup *i386_mmx_reggroup;
d1426 2
a1427 2
  i386_sse_reggroup = reggroup_new ("sse");
  i386_mmx_reggroup = reggroup_new ("mmx");
d1433 2
a1434 2
  reggroup_add (gdbarch, i386_sse_reggroup);
  reggroup_add (gdbarch, i386_mmx_reggroup);
d1450 1
a1450 1
  if (group == i386_mmx_reggroup)
d1452 1
a1452 1
  if (group == i386_sse_reggroup)
@


1.83
log
@* i386-tdep.c: Include "objfiles.h".
(i386_svr4_init_abi): Set in_solib_call_trampoline and
skip_trampoline_code.
* config/i386/tm-i386v4.h: Don't include "config/tm-sysv4.h".
(CPLUS_MARKER): Define to '.'.
@
text
@d920 1
a920 1
			   char *valbuf)
d922 1
d1536 1
a1536 1
  set_gdbarch_store_return_value (gdbarch, i386_store_return_value);
@


1.82
log
@* i386-tdep.c (i386_do_pop_frame, i386_store_return_value): Call
write_register_gen instead of write_register_bytes.
@
text
@d28 1
d1373 4
@


1.81
log
@* i386-tdep.c (i386_svr4_init_abi, i386_nw_init_abi): Use
generic_func_frame_valid instead of func_frame_valid.
@
text
@d836 1
a836 2
	  write_register_bytes (REGISTER_BYTE (regnum), regbuf,
				REGISTER_RAW_SIZE (regnum));
d1005 1
a1005 2
      write_register_bytes (REGISTER_BYTE (FP0_REGNUM), buf,
			    FPU_REG_RAW_SIZE);
@


1.80
log
@        * i386-tdep.c (i386_pe_skip_trampoline_code): renamed from
        skip_trampoline_code, for better namespace-proofing.

        * i386-tdep.h (i386_pe_skip_trampoline_code): Add declaration.
@
text
@d1376 1
a1376 1
  set_gdbarch_frame_chain_valid (gdbarch, func_frame_chain_valid);
d1406 1
a1406 1
  set_gdbarch_frame_chain_valid (gdbarch, func_frame_chain_valid);
@


1.79
log
@* i387-tdep.h (i387_print_float_info): New prototype.
* i387-tdep.c (print_i387_value, print_i387_ext,
print_i387_status_word, print_i387_control_word): Add `struct
ui_file *' argument and use it for output.
(i387_print_float_info): Renamed from i387_float_info.  Add
`struct gdbarch *' and `struct ui_file *' arguments and use the
latter for output.
* i386-tdep.c: Include "i387-tdep.h".
(i386_gdbarch_init): Set print_float_info.
* config/i386/tm-i386.h (i387_float_info): Remove prototype.
(FLOAT_INFO): Remove define.
@
text
@d1257 1
a1257 1
skip_trampoline_code (CORE_ADDR pc, char *name)
@


1.78
log
@* i386-tdep.c (i386_stab_reg_to_regnum): Return correct register
numbers for MMX registers.
@
text
@d41 1
d1491 2
@


1.77
log
@* i386-tdep.c (i386_gdbarch_init): Use
generic_unwind_get_saved_register.
@
text
@d116 1
a116 3
      /* FIXME: kettenis/2001-07-28: Should we have the MMX registers
         as pseudo-registers?  */
      return reg - 29 + FP0_REGNUM;
@


1.76
log
@2002-08-13  Andrew Cagney  <cagney@@redhat.com>

* i386-tdep.c (i386_register_name): Handle mmx registers.
(mmx_regnum_p): New function.
(i386_mmx_names): New array.
(mmx_num_regs): New variable.
(i386_pseudo_register_read): New function.
(i386_pseudo_register_write): New function.
(mmx_regnum_to_fp_regnum): New function. Code from Fernando Nasser.

* regcache.c (regcache_raw_read_unsigned): New function.
(regcache_raw_read_signed): New function.
* regcache.h (regcache_raw_read_unsigned): Declare.
(regcache_raw_read_signed): Declare.
@
text
@d1515 1
a1515 1
  set_gdbarch_get_saved_register (gdbarch, generic_get_saved_register);
@


1.75
log
@2002-08-12  Andrew Cagney  <cagney@@redhat.com>
* regcache.c (regcache_raw_read_as_address): Delete function.
(regcache_cooked_read_signed): New function.
(regcache_cooked_read_unsigned): New function.
* regcache.h (regcache_cooked_read_signed): Declare.
(regcache_cooked_read_unsigned): Declare.
(regcache_raw_read_as_address): Delete declaration.
* blockframe.c (generic_read_register_dummy): Use
regcache_cooked_read_unsigned.
* i386-tdep.c (i386_extract_struct_value_address): Use
regcache_cooked_read_unsigned.
@
text
@d59 17
d83 2
d1112 3
d1118 52
d1562 5
@


1.74
log
@2002-08-12  Andrew Cagney  <cagney@@redhat.com>

* i386-tdep.h (i386_register_byte, i386_register_raw_size): Delete
declarations.
* i386-linux-tdep.c (i386_linux_register_byte): Delete function.
(i386_linux_register_raw_size): Delete function.
i386_linux_init_abi): Update.
* i386-tdep.c (i386_register_raw_size): Delete function.
(i386_register_byte): Delete function.
(i386_gdbarch_init): Update.
(i386_register_size): Delete array.
(i386_register_offset): Delete array.

* config/i386/tm-symmetry.h (REGISTER_BYTE): Delete macro.
(REGISTER_RAW_SIZE): Delete macro.
* config/i386/tm-ptx.h (REGISTER_RAW_SIZE): Delete macro.
(REGISTER_BYTE): Delete macro.
@
text
@d1031 12
a1042 1
  return regcache_raw_read_as_address (regcache, LOW_RETURN_REGNUM);
@


1.73
log
@2002-07-24  Andrew Cagney  <cagney@@redhat.com>
* regcache.h (regcache_raw_read, regcache_raw_write): Replace
regcache_read and regcache_write.
(regcache_raw_read_as_address): Replace regcache_read_as_address.
* regcache.c: Update.
* sh-tdep.c (sh64_push_arguments): Update comment.
(sh_pseudo_register_read): Update.
(sh_pseudo_register_write): Update.
(sh4_register_read): Update.
(sh4_register_write): Update.
(sh64_pseudo_register_read): Update.
(sh64_pseudo_register_write): Update.
(sh64_register_read): Update.
(sh64_register_write): Update.
* i386-tdep.c (i386_extract_return_value): Update.
(i386_extract_struct_value_address): Update.
(i386_extract_return_value): Update.
* blockframe.c (generic_read_register_dummy): Update.
(generic_call_dummy_register_unwind): Update
* infrun.c (write_inferior_status_register): Update.
@
text
@a58 21
/* i386_register_offset[i] is the offset into the register file of the
   start of register number i.  We initialize this from
   i386_register_size.  */
static int i386_register_offset[I386_SSE_NUM_REGS];

/* i386_register_size[i] is the number of bytes of storage in GDB's
   register array occupied by register i.  */
static int i386_register_size[I386_SSE_NUM_REGS] = {
   4,  4,  4,  4,
   4,  4,  4,  4,
   4,  4,  4,  4,
   4,  4,  4,  4,
  10, 10, 10, 10,
  10, 10, 10, 10,
   4,  4,  4,  4,
   4,  4,  4,  4,
  16, 16, 16, 16,
  16, 16, 16, 16,
   4
};

a71 17
/* Return the offset into the register array of the start of register
   number REG.  */
int
i386_register_byte (int reg)
{
  return i386_register_offset[reg];
}

/* Return the number of bytes of storage in GDB's register array
   occupied by register REG.  */

int
i386_register_raw_size (int reg)
{
  return i386_register_size[reg];
}

a1403 2
  set_gdbarch_register_byte (gdbarch, i386_register_byte);
  set_gdbarch_register_raw_size (gdbarch, i386_register_raw_size);
a1507 13

  /* Initialize the table saying where each register starts in the
     register file.  */
  {
    int i, offset;

    offset = 0;
    for (i = 0; i < I386_SSE_NUM_REGS; i++)
      {
	i386_register_offset[i] = offset;
	offset += i386_register_size[i];
      }
  }
@


1.72
log
@* i386-tdep.h (I386_MAX_REGISTER_SIZE): New define.
* i386-tdep.c (i386_do_pop_frame): Use I386_MAX_REGISTER_SIZE
instead of MAX_REGISTER_RAW_SIZE.
(i386_extract_return_value, i386_extract_struct_value_address):
Convert to use regcache.
(i386_gdbarch_init): Set max_register_raw_size and
max_register_virtual_size to I386_MAX_REGISTER_SIZE.
Set extract_return_value and extract_struct_value_address instead
of their deprecated variants.
@
text
@d965 1
a965 1
      regcache_read (regcache, FP0_REGNUM, buf);
d975 1
a975 1
	  regcache_read (regcache, LOW_RETURN_REGNUM, buf);
d980 1
a980 1
	  regcache_read (regcache, LOW_RETURN_REGNUM, buf);
d982 1
a982 1
	  regcache_read (regcache, HIGH_RETURN_REGNUM, buf);
d1069 1
a1069 1
  return regcache_read_as_address (regcache, LOW_RETURN_REGNUM);
@


1.71
log
@Convert i386 target to generic dummy frames.
* i386-tdep.c: Include "symfile.h".
(i386_frameless_signal_p): Consider a function to be frameless if
the pc points at the first instruction of the function.
(i386_frame_chain): Handle (generic) call dummies.
(i386_frame_saved_pc): Likewise.
(i386_frame_init_saved_regs): Remove code dealing with call
dummies on the stack.
(i386_push_dummy_frame): Removed.
(i386_call_dummy_words): Removed.
(i386_fix_call_dummy): Removed.
(i386_push_return_address): New function.
(i386_do_pop_frame): Renamed from i386_pop_frame.  Add FRAME
parameter, and don't call get_current_frame.
(i386_pop_frame): New function.
(i386_gdbarch_init): Set use_generic_dummy_frames to 1, set
call_dummy_location to AT_ENTRY_POINT, set call_dummy_address to
entry_point_address, set call_dummy_breakpoint_offset to 0, set
call_dummy_length to 0, set call_dummy_words to NULL, set
sizeof_call_dummy_words to 0, set fix_call_dummy to
generic_fix_call_dummy, set pc_in_call_dummy to
pc_in_call_dummy_at_entry_point, set push_dummy_frame to
generic_push_dummy_frame, set push_return_address to
i386_push_return_address and set frame_chain_valid to
generic_file_frame_chain_valid.
@
text
@d844 1
a844 1
  char regbuf[MAX_REGISTER_RAW_SIZE];
d939 2
a940 1
i386_extract_return_value (struct type *type, char *regbuf, char *valbuf)
d943 1
d948 1
a948 1
      i386_extract_return_value (TYPE_FIELD_TYPE (type, 0), regbuf, valbuf);
d965 2
a966 2
      convert_typed_floating (&regbuf[REGISTER_BYTE (FP0_REGNUM)],
			      builtin_type_i387_ext, valbuf, type);
d974 4
a977 1
	memcpy (valbuf, &regbuf[REGISTER_BYTE (LOW_RETURN_REGNUM)], len);
d980 4
a983 4
	  memcpy (valbuf,
		  &regbuf[REGISTER_BYTE (LOW_RETURN_REGNUM)], low_size);
	  memcpy (valbuf + low_size,
		  &regbuf[REGISTER_BYTE (HIGH_RETURN_REGNUM)], len - low_size);
d1067 1
a1067 1
i386_extract_struct_value_address (char *regbuf)
d1069 1
a1069 2
  return extract_address (&regbuf[REGISTER_BYTE (LOW_RETURN_REGNUM)],
			  REGISTER_RAW_SIZE (LOW_RETURN_REGNUM));
d1444 2
a1445 2
  set_gdbarch_max_register_raw_size (gdbarch, 16);
  set_gdbarch_max_register_virtual_size (gdbarch, 16);
d1480 1
a1480 2
  set_gdbarch_deprecated_extract_return_value (gdbarch,
					       i386_extract_return_value);
d1487 1
a1487 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch,
@


1.70
log
@* i386-tdep.c (i386_frameless_signal_p): Provide an argument in to
frameless_look_for_prologue, such that we actually call this
function.
@
text
@d30 1
d475 5
a479 1
   has been set up.  */
d487 3
a489 3
  return (frame->next
	  && frame->next->signal_handler_caller
	  && frameless_look_for_prologue (frame));
d499 3
d556 4
a687 1
  CORE_ADDR dummy_bottom;
a696 17
  /* If the frame is the end of a dummy, compute where the beginning
     would be.  */
  dummy_bottom = fip->frame - 4 - REGISTER_BYTES - CALL_DUMMY_LENGTH;

  /* Check if the PC points in the stack, in a dummy frame.  */
  if (dummy_bottom <= fip->pc && fip->pc <= fip->frame)
    {
      /* All registers were saved by push_call_dummy.  */
      addr = fip->frame;
      for (i = 0; i < NUM_REGS; i++)
	{
	  addr -= REGISTER_RAW_SIZE (i);
	  fip->saved_regs[i] = addr;
	}
      return;
    }

d826 2
a827 7
static void
i386_push_dummy_frame (void)
{
  CORE_ADDR sp = read_register (SP_REGNUM);
  CORE_ADDR fp;
  int regnum;
  char regbuf[MAX_REGISTER_RAW_SIZE];
d829 2
a830 20
  sp = push_word (sp, read_register (PC_REGNUM));
  sp = push_word (sp, read_register (FP_REGNUM));
  fp = sp;
  for (regnum = 0; regnum < NUM_REGS; regnum++)
    {
      read_register_gen (regnum, regbuf);
      sp = push_bytes (sp, regbuf, REGISTER_RAW_SIZE (regnum));
    }
  write_register (SP_REGNUM, sp);
  write_register (FP_REGNUM, fp);
}

/* The i386 call dummy sequence:

     call 11223344 (32-bit relative)
     int 3

   It is 8 bytes long.  */

static LONGEST i386_call_dummy_words[] =
d832 1
a832 3
  0x223344e8,
  0xcc11
};
d834 3
a836 18
/* Insert the (relative) function address into the call sequence
   stored at DYMMY.  */

static void
i386_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs,
		     struct value **args, struct type *type, int gcc_p)
{
  int from, to, delta, loc;

  loc = (int)(read_register (SP_REGNUM) - CALL_DUMMY_LENGTH);
  from = loc + 5;
  to = (int)(fun);
  delta = to - from;

  *((char *)(dummy) + 1) = (delta & 0xff);
  *((char *)(dummy) + 2) = ((delta >> 8) & 0xff);
  *((char *)(dummy) + 3) = ((delta >> 16) & 0xff);
  *((char *)(dummy) + 4) = ((delta >> 24) & 0xff);
d840 1
a840 1
i386_pop_frame (void)
a841 1
  struct frame_info *frame = get_current_frame ();
d865 6
d1446 1
a1446 1
  set_gdbarch_use_generic_dummy_frames (gdbarch, 0);
d1449 2
a1450 1
  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
d1452 1
a1452 1
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 5);
d1454 1
a1454 1
  set_gdbarch_call_dummy_length (gdbarch, 8);
d1456 2
a1457 3
  set_gdbarch_call_dummy_words (gdbarch, i386_call_dummy_words);
  set_gdbarch_sizeof_call_dummy_words (gdbarch,
				       sizeof (i386_call_dummy_words));
d1459 1
a1459 1
  set_gdbarch_fix_call_dummy (gdbarch, i386_fix_call_dummy);
d1469 1
a1469 1
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_on_stack);
d1479 2
a1480 1
  set_gdbarch_push_dummy_frame (gdbarch, i386_push_dummy_frame);
d1507 1
a1507 1
  set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
@


1.69
log
@* i386-tdep.c (i386_frameless_signal_p): New function.
(i386_frame_chain): Deal with frameless signals.
(i386_sigtramp_saved_sp): New function.
(i386_frame_saved_pc): Deal with frameless signals.
(i386_saved_pc_after_call): Make sure the correct value is
returned just after entry into a sigtramp.
* i386bsd-tdep.c (i386bsd_sc_sp_offset, i386nbsd_sc_sp_offset,
i386fbsd4_sc_sp_offset): New variables.
(i386bsd_init_abi, i386nbsd_init_abi, i386fbsd4_init_abi): Use
these variables to initialize tdep->sc_sp_offset.  * i386bsd-nat.c
(_initialize_i386bsd_nat): Add sanity check for sc_sp_offset
similiar to what we already did for sc_pc_offset.
* i386-sol2-tdep.c (i386_sol2_init_abi): Initialize
tdep->sc_sp_offset.
@
text
@d484 1
a484 1
	  && frameless_look_for_prologue);
@


1.68
log
@* i386-tdep.h (struct gdbarch_tdep): Replace sigtramp_saved_pc
with sigcontext_addr.  Add sc_sp_offset.
(i386bsd_sigtramp_saved_pc): Remove prototype.
(i386bsd_sicontext_addr): Add prototype.
* i386-tdep.c (i386_sigtramp_saved_pc): New function.
(i386_frame_saved_pc): Rewrite to call i386_sigtramp_saved_pc.
(i386_svr4_sigtramp_saved_pc): Removed.
(i386_svr4_sigcontext_addr): New function.
(i386_svr4_init_abi): Don't initialize tdep->sigtramp_saved_pc.
Initialize tdep->sigcontext_addr instead.  Initialize
tdep->sc_pc_offset and tdep->sc_sp_offset.
(i386_gdbarch_init): Likewise.
* i386bsd-tdep.c (i386bsd_sigcontext_addr): Don't make it static
any more.
(i386bsd_sigtramp_saved_pc): Remove function.
(i386bsd_init_abi): Don't initialize tdep->sigtramp_saved_pc.
Initialize tdep->sigcontext_addr instead.  Initialize
tdep->sc_pc_offset.
* i386-linux-tdep.c (i386_linux_init_abi): Remove initialization
of tdep->sigtramp_saved_pc.
* i386-sol2-tdep.c (i386_sol2_init_abi): Don't initialize
tdep->sigtramp_saved_pc.  Initialize tdep->sigcontext_addr
instead.
@
text
@d455 32
d494 2
a495 1
  if (frame->signal_handler_caller)
d530 13
d551 6
d565 3
@


1.67
log
@* i386-tdep.c (i386_frameless_function_invocation,
i386_frame_num_args, i386_frame_init_saved_regs,
i386_skip_prologue, i386_push_dummy_frame, i386_fix_call_dummy,
i386_pop_frame, i386_push_arguments, i386_store_struct_return,
i386_extract_return_value, i386_store_return_value,
i386_extract_struct_value_address, i386_register_virtual_type,
i386_register_convertible, i386_register_convert_to_virtual,
i386_register_convert_to_raw, i386_svr4_sigtramp_saved_pc,
i386_go32_init_abi, i386_nw_init_abi, i386_gdbarch_init): Make
static.
@
text
@d484 13
d503 1
a503 7
    {
      CORE_ADDR (*sigtramp_saved_pc) (struct frame_info *);
      sigtramp_saved_pc = gdbarch_tdep (current_gdbarch)->sigtramp_saved_pc;

      gdb_assert (sigtramp_saved_pc != NULL);
      return sigtramp_saved_pc (frame);
    }
d1254 2
a1255 2
/* Get saved user PC for sigtramp from the pushed ucontext on the
   stack for all three variants of SVR4 sigtramps.  */
d1258 1
a1258 1
i386_svr4_sigtramp_saved_pc (struct frame_info *frame)
d1260 1
a1260 1
  CORE_ADDR saved_pc_offset = 4;
d1267 1
a1267 1
	saved_pc_offset = 132 + 14 * 4;
d1269 1
a1269 1
	saved_pc_offset = 80 + 14 * 4;
d1271 1
a1271 1
	saved_pc_offset = 120 + 14 * 4;
d1274 2
d1277 2
a1278 2
    return read_memory_integer (frame->next->frame + saved_pc_offset, 4);
  return read_memory_integer (read_register (SP_REGNUM) + saved_pc_offset, 4);
d1315 3
a1317 1
  tdep->sigtramp_saved_pc = i386_svr4_sigtramp_saved_pc;
a1382 1
  tdep->sigtramp_saved_pc = NULL;
d1385 1
d1387 1
d1394 1
a1394 1
  
d1403 1
a1403 1
  
@


1.66
log
@* gdbarch.sh (REGISTER_NAME): Change return type a constant string
pointer.
* gdbarch.h, gdbarch.c: Regenerate.
* config/mips/tm-mips.h (mips_register_name): Update.
* i386-tdep.h (i386_register_name): Update.
* mips-tdep.c (mips_register_name): Update
* alpha-tdep.c (alpha_register_name): Update.
* arch-utils.c (legacy_register_name): Update.
* arch-utils.h (legacy_register_name): Update.
* avr-tdep.c (avr_register_name): Update.
* ia64-tdep.c (ia64_register_name): Update.
* i386-tdep.c (i386_register_name): Update.
* sparc-tdep.c (sparc32_register_name): Update.
(sparc64_register_name): Update.
(sparclite_register_name): Update.
(sparclet_register_name):
* sh-tdep.c (sh_generic_register_name): Update.
(sh_sh_register_name): Update.
(sh_sh3_register_name): Update.
(sh_sh3e_register_name): Update.
(sh_sh_dsp_register_name): Update.
(sh_sh3_dsp_register_name): Update.
(sh_sh4_register_name): Update.
(sh_sh64_register_name): Update.
* s390-tdep.c (s390_register_name): Update.
* rs6000-tdep.c (rs6000_register_name): Update.
* ns32k-tdep.c (ns32k_register_name_32082): Update.
(ns32k_register_name_32382): Update.
* d10v-tdep.c (d10v_ts2_register_name): Update.
(d10v_ts3_register_name): Update.
* xstormy16-tdep.c (xstormy16_register_name): Update.
* vax-tdep.c (vax_register_name): Update.
* v850-tdep.c (v850_register_name): Update.
* m68hc11-tdep.c (m68hc11_register_name): Update.
* mn10300-tdep.c (mn10300_generic_register_name): Update.
(am33_register_name): Update.
@
text
@d475 1
a475 1
int
d512 1
a512 1
int
d609 1
a609 1
void
d669 1
a669 1
CORE_ADDR
d770 1
a770 1
void
d806 1
a806 1
void
d823 1
a823 1
void
d883 1
a883 1
CORE_ADDR
d901 1
a901 1
void
d917 1
a917 1
void
d968 1
a968 1
void
d1040 1
a1040 1
CORE_ADDR
d1083 1
a1083 1
struct type *
d1104 1
a1104 1
int
d1113 1
a1113 1
void
d1136 1
a1136 1
void
d1250 1
a1250 1
CORE_ADDR
d1313 1
a1313 1
void
d1325 1
a1325 1
void
d1337 1
a1337 1
struct gdbarch *
@


1.65
log
@* config/i386/tm-i386.h (REGISTER_VIRTUAL_TYPE,
REGISTER_CONVERTIBLE, REGISTER_CONVERT_TO_VIRTUAL,
REGISTER_CONVERT_TO_RAW): Remove defines.
(i386_register_virtual_type, i386_register_convertible,
i386_register_convert_to_virtual, i386_register_convert_to_raw):
Remove prototypes.
* i386-tdep.c (i386_gdbarch_init): Adjust for removal of the
macros mentioned above.
@
text
@d81 1
a81 1
char *
@


1.64
log
@* config/i386/tm-i386.h (PARM_BOUNDARY, CALL_DUMMY,
CALL_DUMMY_LENGTH, CALL_DUMMY_START_OFFSET,
CALL_DUMMY_BREAKPOINT_OFFSET, FIX_CALL_DUMMY): Remove defines.
(i386_fix_call_dummy): Remove prototype.
* i386-tdep.c (i386_call_dummy_words): New variable.
(i386_gdbarch_init): Adjust for removal of the
macros mentioned above.
@
text
@d1416 1
d1434 5
@


1.63
log
@* config/i386/tm-i386.h (PUSH_ARGUMENTS, STORE_STRUCT_RETURN,
DEPRECATED_EXTRACT_RETURN_VALUE, STORE_RETURN_VALUE,
DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS, PUSH_DUMMY_FRAME,
POP_FRAME): Remove defines.
(i386_push_arguments, i386_store_struct_return,
i386_extract_return_value, i386_store_return_value,
i386_extract_struct_value_address, i386_push_dummy_frame,
i386_pop_frame): Renove prototypes.
* i386-tdep.c (i386_gdbarch_init): Adjust for removal of the
macros mentioned above.
@
text
@d790 13
d1423 1
d1426 1
d1428 3
d1432 1
d1438 5
@


1.62
log
@* config/i386/tm-i386.h (FUNCTION_START_OFFSET, INNER_THAN,
BREAKPOINT, DECR_PC_AFTER_BREAK): Removed.
* i386-tdep.c (i386_skip_prologue): Adjust function signature to
fit into multi-arch framework.
(i386_breakpoint_from_pc): New function.
(i386_gdbarch_init): Adjust for removal of the macros mentioned
above.
@
text
@d1420 9
@


1.61
log
@* config/i386/tm-i386.h (FRAMELESS_FUNCTION_INVOCATION,
FRAME_ARGS_ADDRESS, FRAME_LOCALS_ADDRESS, FRAME_NUM_ARGS,
FRAME_ARGS_SKIP, FRAME_INIT_SAVED_REGS): Remove defines.
(i386_frameless_function_invocation, i386_frame_num_args,
i386_frame_init_saved_regs): Remove prototypes.
* i386-tdep.c (i386_gdbarch_init): Adjust for removal of the
macros mentioned above.
@
text
@d669 2
a670 2
int
i386_skip_prologue (int pc)
d752 18
d1423 8
@


1.60
log
@* i386-tdep.c (i386_coff_osabi_sniffer): Add "coff-go32" to the
list of DJGPP COFF targets.
@
text
@d1404 2
d1411 3
d1417 2
d1420 1
@


1.59
log
@Clean up the mess I made from my last checkin.
@
text
@d1424 2
a1425 1
  if (strcmp (bfd_get_target (abfd), "coff-go32-exe") == 0)
@


1.58
log
@* config/i386/tm-i386.h (MAX_NUM_REGS): Removed.
* i386-tdep.c (i386_register_offset, i386_register_size): Use
I386_SSE_NUM_REGS instead of MAX_NUM_REGS for the number of
elements in these arrays.
(_initialize_i386_tdep): Use I386_SSE_NUM_REGS instead of
MAX_NUM_REGS.
@
text
@a108 8
/* Return the size in bytes of the virtual type of register REG.  */

int
i386_register_virtual_size (int reg)
{
  return TYPE_LENGTH (REGISTER_VIRTUAL_TYPE (reg));
}

d900 1
a900 1
      if (NUM_FREGS == 0)
d954 1
a954 1
      if (NUM_FREGS == 0)
d1335 2
a1336 2
     FIXME: kettenis/20020509: They do include the FPU registers for
     now, which is not quite right.  */
d1357 29
a1413 20

  /* NOTE: tm-i386aix.h, tm-i386bsd.h, tm-i386os9k.h, tm-ptx.h,
     tm-symmetry.h currently override this.  Sigh.  */
  set_gdbarch_num_regs (gdbarch, I386_NUM_GREGS + I386_NUM_FREGS);

  /* Use the "default" register numbering scheme for stabs and COFF.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_stab_reg_to_regnum);
  set_gdbarch_sdb_reg_to_regnum (gdbarch, i386_stab_reg_to_regnum);

  /* Use the DWARF register numbering scheme for DWARF and DWARF 2.  */
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, i386_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, i386_dwarf_reg_to_regnum);

  /* We don't define ECOFF_REG_TO_REGNUM, since ECOFF doesn't seem to
     be in use on any of the supported i386 targets.  */

  set_gdbarch_register_bytes (gdbarch, I386_SIZEOF_GREGS + I386_SIZEOF_FREGS);
  set_gdbarch_register_name (gdbarch, i386_register_name);
  set_gdbarch_register_byte (gdbarch, i386_register_byte);
  set_gdbarch_register_raw_size (gdbarch, i386_register_raw_size);
@


1.57
log
@* config/i386/tm-i386.h (TARGET_LONG_DOUBLE_FORMAT,
TARGET_LONG_DOUBLE_BIT): Remove.  * i386-tdep.c
(i386_gdbarch_init): Initialize long_double_format and long_double
bit.
@
text
@d61 1
a61 1
static int i386_register_offset[MAX_NUM_REGS];
d65 1
a65 1
static int i386_register_size[MAX_NUM_REGS] = {
d1450 1
a1450 1
    for (i = 0; i < MAX_NUM_REGS; i++)
@


1.56
log
@* config/i386/i386sol2.mt (TDEPFILES): Add i386-sol2-tdep.o and
i386bsd-tdep.o.  Remove solib.o, solib-svr4.o and solib-legacy.o.
Move these to ...
* config/i386/i386sol2.mh: ... here.
* config/i386/tm-i386sol2.h (STAB_REG_TO_REGNUM): Remove define.
(sigtramp_saved_pc, I386V4_SIGTRAMP_SAVED_PC): Don't #undef.
(SIGCONTEXT_PC_OFFSET): Remove define.
(IN_SIGTRAMP): Remove define.
* i386-sol2-tdep.c: New file.

* config/i386/i386nw.mt (TM_FILE): Change to tm-i386.h.
* config/i386/tm-i386nw.h: Removed.

* config/i386/tm-fbsd.h (STAB_REG_TO_REGNUM,
USE_STRUCT_CONVENTION): Remove defines.
(JB_ELEMENT_SIZE, JB_PC, GET_LONGJMP_TARGET): Remove defines.
(get_longjmp_target): Remove prototype.
(IN_SIGTRAMP): Remove define.
(i386bsd_in_sigtramp): Remove prototype.
(i386bsd_sigtramp_start, i386bsd_sigtramp_end): Turn into a
function.  Update comment accordingly
(SIGTRAMP_START, SIGTRAMP): Adjust definition accordingly.
(FRAME_SAVED_PC): Remove define.
(i386bsd_frame_saved_pc): Remove prototype.
* config/i386/tm-nbsd.h (JB_ELEMENT_SIZE, JB_PC,
GET_LONGJMP_TARGET): Remove defines.
(get_longjmp_target): Remove prototype.
(IN_SIGTRAMP): Remove define.
(i386bsd_in_sigtramp): Remove prototype.
(i386bsd_sigtramp_start, i386bsd_sigtramp_end): Turn into a
function.  Update comment accordingly
(SIGTRAMP_START, SIGTRAMP): Adjust definition accordingly.
(FRAME_SAVED_PC): Remove define.
(i386bsd_frame_saved_pc): Remove prototype.
* config/i386/tm-nbsdaout.h (i386nbsd_aout_use_struct_convention):
Remove prototype.
(USE_STRUCT_CONVENTION): Remove prototype.
* i386bsd-nat.c (i386bsd_sigcontext_pc_offset): Remove
declaration.
(_initialize_i386bsd_nat): Revise logic to determine some
constants at compile time when compiling a native GDB.  Warn if
things don't match up with what we expect.
* i386bsd-tdep.c (i386bsd_sigtramp_start, i386bsd_sigtramp_end):
Remove variables.
(i386bsd_in_sigtramp): Rename tp i386bsd_pc_in_sigtramp.  Rewrite
to use date stored in `struct gdbarch_tdep'.
(i386bsd_sigcontext_offset): Remove varaible.
(i386bsd_sigtramp_saved_pc): Make public.  Rewrite to use data
stored in `struct gdbarch_tdep'.
(i386bsd_frame_saved_pc): Make static.
(i386bsd_sigtramp_start, i386bsd_sigtramp_end): New functions.
(i386bsd_sc_pc_offset, i386nbsd_sc_pc_offset,
i386fbsd_sigtramp_start, i386fbsd_sigtramp_end,
i386fbsd4_sc_pc_offset): New variables.
(i386bsd_init_abi, i386nbsd_init_abi, i386nbsdelf_init_abi,
i386fbsdaout_init_abi, i386fbsd_init_abi, i386fbsd4_init_abi): New
functions.
(i386bsd_aout_osabi_sniffer, _initialize_i386bsd_tdep): New
functions.
* i386fbsd-nat.c (_initialize_i386fbsd_nat): Fix type in comment.
Modify the value of i386fbsd_sigtramp_start and
i386fbsd_sigtramp_end instead of i386bsd_sigtramp_start and
i386fbsd_sigtramp_end.
* i386nbsd-tdep.c: (i386nbsd_aout_use_struct_convention): Remove
function.

* config/i386/tm-linux.h (I386_LINUX_ORIG_EAX_REGNUM): Move
define to i386-linux-tdep.h.
(NUM_REGS, MAX_NUM_REGS, REGISTER_BYTES, REGISTER_NAME,
REGISTER_BYTE, REGISTER_RAW_SIZE, STAB_REG_TO_REGNUM): Remove
defines.
(i386_linux_register_name, i386_linux_register_byte,
i386_linux_register_raw_size): Remove prototypes.
(i386_linux_svr4_fetch_link_map_offsets): Remove prototype.
(SVR4_FETCH_LINK_MAP_OFFSETS): Remove define.
(IN_SIGTRAMP, FRAME_CHAIN, FRAME_SAVED_PC, SAVED_PC_AFTER_CALL,
TARGET_WRITE_PC): Remove defines.
(i386_linux_in_sigtramp, i386_linux_frame_chain,
i386_linux_frame_saved_pc, i386_linux_saved_pc_after_call,
i386_linux_write_pc): Remove prototypes.
(JB_ELEMENT_SIZE, JB_PC, GET_LONGJMP_TARGET): Remove defines.
(get_longjmp_target): Remove prototype.
* i386-linux-tdep.h: New file.
* i386-linux-nat.c: Include "i386-linux-tdep.h".
* i386-linux-tdep.c: Include "i386-tdep.h" and
"i386-linux-tdep.h".
(i386_linux_register_name, i386_linux_register_byte,
i386_linux_register_raw_size, i386_linux_in_sigtramp,
i386_linux_write_pc, i386_linux_svr4_fetch_link_map_offsets):
Make static.
(i386_linux_init_abi): New function.
(_initialize_i386_linux_tdep): New function.

* config/i386/tm-i386.h (SAVED_PC_AFTER_CALL): Remove define.
(i386_saved_pc_after_call): Remove prototype.
(MAX_NUM_REGS): Increase to deal with Linux's orig_eax "register".
(REGISTER_NAME, STAB_REG_TO_REGNUM, SDB_REG_TO_REGNUM,
DWARF_REG_TO_REGNUM, DWARF2_REG_TO_REGNUM): Remove defines.
(i386_register_name, i386_stab_reg_to_regnum,
i386_dwarf_reg_to_regnum): Remove prototypes.
(SIZEOF_GREGS, SIZEOF_FPU_REGS, SIZEOF_FPU_CTL_REGS,
SIZEOF_SSE_REGS): Remove defines.
(REGISTER_BYTES): Remove define.
(REGISTER_BYTE, REGISTER_RAW_SIZE): Remove defines.
(i386_register_byte, i386_register_raw_size): Remove prototypes.
(FRAME_CHAIN, FRAME_SAVED_PC): Remove defines.
(i386_frame_chain, i386_frame_saved_pc): Remove prototypes.
* config/i386/tm-i386v4.h (FRAME_CHAIN_VALID): Remove define.
(JB_ELEMENT_SIZE, JB_PC, JB_EBX, JB_ESI, JB_EDI, JB_EBP, JB_ESP,
JB_EDX, GET_LONGJMP_TARGET): Remove defines.
(get_longjmp_target): Remove prototype.
(I386V4_SIGTRAMP_SAVED_PC, IN_SIGTRAMP): Remove defines.
(sigtramp_saved_pc): Remove define.
(i386v4_sigtramp_saved_pc): Remove prototype.
* config/i386/tm-go32.h (FRAME_CHAIN,
FRAMELESS_FUNCTION_INVOCATION, FRAME_SAVED_PC): Remove defines.
(i386go32_frame_saved_pc): Remove prototype.
(JB_ELEMENT_SIZE, JB_PC, GET_LONGJMP_TARGET): Remove defines.
(get_longjmp_target): Remove prototype.
* i386-tdep.h: Include "osabi.h".
(enum i386_abi): Removed.
(enum struct_return): New enum.
(struct gdbarch_tdep): Remove abi member, add osabi, jb_pc_offset,
struct_return, sigtramp_saved_pc, sigtramp_start, sigtramp_end and
sc_pc_offset members.
(i386_gdbarch_register_os_abi): Remove prototype.
(I386_NUM_GREGS, I386_NUM_FREGS, I386_NUM_XREGS,
I386_SSE_NUM_REGS): New defines.
(I386_SIZEOF_GREGS, I386_SIZEOF_FREGS, I386_SIZEOF_XREGS,
I386_SSE_SIZEOF_REGS): New defines.
(i386_register_name, i386_register_byte, i386_register_raw_size):
New prototypes.
(i386_elf_init_abi, i386_svr4_init_abi): New prototypes.
(i386bsd_sigtramp_saved_pc): New prototype.
* i386-tdep.c: Don't include "elf-bfd.h".
(i386_stab_reg_to_regnum, i386_dwarf_reg_to_regnum,
i386_frame_chain, i386_saved_pc_after_call): Make static.
(i386_frame_saved_pc): Rewrite to call architecture dependent
function to deal with signal handlers.  Make static.
(i386go32_frame_saved_pc): Removed.
[GET_LONGJMP_TARGET] (JB_PC, JB_ELEMENT_SIZE, get_longjmp_target):
Removed.
(i386_get_longjmp_target): New function.
(default_struct_convention, pcc_struct_convention,
reg_struct_convention, valid_conventions, struct_convention): New
variables.
(i386_use_struct_convention): New function.
(i386v4_sigtramp_saved_pc): Renamed to
i386_svr4_sigtramp_saved_pc.  Made static.  Moved.
(i386_pc_in_sigtramp): New function.
(i386_abi_names): Removed.
(ABI_TAG_OS_GNU_LINUX, ABI_TAG_OS_GNU_HURD,
ABI_TAG_OS_GNU_SOLARIS, ABI_TAG_OS_FREEBSD, ABI_TAG_OS_NETBSD):
Removed.
(process_note_sections, i386_elf_abi_from_note, i386_elf_abi,
i386_gdbarch_register_os_abi): Removed.
(struct i386_abi_handler): Removed.
(i386_abi_handler_list): Removed.
(i386_svr4_pc_in_sigtramp, i386_go32_pc_in_sigtramp): New
functions.
(i386_elf_init_abi, i386_svr4_init_abi, i386_go32_init_abi,
i386_nw_init_abi): New functions.
(i386_gdbarch_init): Rewritten to use generic OS ABI framework.
Use set_gdbarch_xxx() calls instead of relying on macros for a
number of calls.
(i386_coff_osabi_sniffer, i386_nlm_osabi_sniffer): New functions.
(_initialize_i386_tdep): Add new 'struct-convcention' command.
Register the various architecture variants defined in this file.
@
text
@d1354 11
@


1.55
log
@2002-05-27  Martin M. Hunt  <hunt@@redhat.com>

	* i386-tdep.c (i386_register_virtual_type): Return
	builtin_type_vec128i for SSE registers.

	* gdbtypes.h (builtin_type_vec128i): Declare.

	* gdbtypes.c (build_builtin_type_vec128i): New function.
	(builtin_type_v2_double, builtin_type_v4_int64): New types.
	(builtin_type_vec128i): New type for SSE2 128-bit registers.
	(build_gdbtypes): Initialize new builtin vector types.
	(_initialize_gdbtypes): Register new vector types with gdbarch.
@
text
@a38 2
#include "elf-bfd.h"

d120 1
a120 1
int
d151 1
a151 1
/* Convert Dwarf register number REG to the appropriate register
d154 1
a154 1
int
d467 1
a467 1
CORE_ADDR
d494 1
a494 1
CORE_ADDR
a496 5
  /* FIXME: kettenis/2001-05-09: Conditionalizing the next bit of code
     on SIGCONTEXT_PC_OFFSET and I386V4_SIGTRAMP_SAVED_PC should be
     considered a temporary hack.  I plan to come up with something
     better when we go multi-arch.  */
#if defined (SIGCONTEXT_PC_OFFSET) || defined (I386V4_SIGTRAMP_SAVED_PC)
d498 7
a504 2
    return sigtramp_saved_pc (frame);
#endif
a508 6
CORE_ADDR
i386go32_frame_saved_pc (struct frame_info *frame)
{
  return read_memory_integer (frame->frame + 4, 4);
}

d511 1
a511 1
CORE_ADDR
a828 12
#ifdef GET_LONGJMP_TARGET

/* FIXME: Multi-arching does not set JB_PC and JB_ELEMENT_SIZE yet.  
   Fill in with dummy value to enable compilation.  */
#ifndef JB_PC
#define JB_PC 0
#endif /* JB_PC */

#ifndef JB_ELEMENT_SIZE
#define JB_ELEMENT_SIZE 4
#endif /* JB_ELEMENT_SIZE */

d831 2
a832 2
   structure from which we extract the pc (JB_PC) that we will land
   at.  The pc is copied into PC.  This routine returns true on
d835 2
a836 2
int
get_longjmp_target (CORE_ADDR *pc)
d838 1
a838 1
  char buf[TARGET_PTR_BIT / TARGET_CHAR_BIT];
d840 6
d848 1
a848 4

  if (target_read_memory (sp + SP_ARG0,	/* Offset of first arg on stack.  */
			  buf,
			  TARGET_PTR_BIT / TARGET_CHAR_BIT))
d851 2
a852 4
  jb_addr = extract_address (buf, TARGET_PTR_BIT / TARGET_CHAR_BIT);

  if (target_read_memory (jb_addr + JB_PC * JB_ELEMENT_SIZE, buf,
			  TARGET_PTR_BIT / TARGET_CHAR_BIT))
d855 1
a855 2
  *pc = extract_address (buf, TARGET_PTR_BIT / TARGET_CHAR_BIT);

a857 2

#endif /* GET_LONGJMP_TARGET */
d1025 31
a1133 28
#ifdef I386V4_SIGTRAMP_SAVED_PC
/* Get saved user PC for sigtramp from the pushed ucontext on the
   stack for all three variants of SVR4 sigtramps.  */

CORE_ADDR
i386v4_sigtramp_saved_pc (struct frame_info *frame)
{
  CORE_ADDR saved_pc_offset = 4;
  char *name = NULL;

  find_pc_partial_function (frame->pc, &name, NULL, NULL);
  if (name)
    {
      if (STREQ (name, "_sigreturn"))
	saved_pc_offset = 132 + 14 * 4;
      else if (STREQ (name, "_sigacthandler"))
	saved_pc_offset = 80 + 14 * 4;
      else if (STREQ (name, "sigvechandler"))
	saved_pc_offset = 120 + 14 * 4;
    }

  if (frame->next)
    return read_memory_integer (frame->next->frame + saved_pc_offset, 4);
  return read_memory_integer (read_register (SP_REGNUM) + saved_pc_offset, 4);
}
#endif /* I386V4_SIGTRAMP_SAVED_PC */


d1183 10
a1206 1

a1207 13
/* This table matches the indices assigned to enum i386_abi.  Keep
   them in sync.  */
static const char * const i386_abi_names[] =
{
  "<unknown>",
  "SVR4",
  "NetBSD",
  "GNU/Linux",
  "GNU/Hurd",
  "Solaris",
  "FreeBSD",
  NULL
};
d1209 4
d1214 1
a1214 5
#define ABI_TAG_OS_GNU_LINUX	I386_ABI_LINUX
#define ABI_TAG_OS_GNU_HURD	I386_ABI_HURD
#define ABI_TAG_OS_GNU_SOLARIS	I386_ABI_INVALID
#define ABI_TAG_OS_FREEBSD	I386_ABI_FREEBSD
#define ABI_TAG_OS_NETBSD	I386_ABI_NETBSD
d1216 2
a1217 2
static void
process_note_sections (bfd *abfd, asection *sect, void *obj)
d1219 4
a1222 3
  int *abi = obj;
  const char *name;
  unsigned int sectsize;
d1224 8
a1231 2
  name = bfd_get_section_name (abfd, sect);
  sectsize = bfd_section_size (abfd, sect);
d1233 2
a1234 1
  if (strcmp (name, ".note.ABI-tag") == 0 && sectsize > 0)
d1236 7
a1242 2
      unsigned int name_length, data_length, note_type;
      char *note;
d1244 5
a1248 4
      /* If the section is larger than this, it's probably not what we
	 are looking for.  */
      if (sectsize > 128)
	sectsize = 128;
d1250 1
a1250 1
      note = alloca (sectsize);
d1252 7
a1258 2
      bfd_get_section_contents (abfd, sect, note,
				(file_ptr) 0, (bfd_size_type) sectsize);
d1260 1
a1260 3
      name_length = bfd_h_get_32 (abfd, note);
      data_length = bfd_h_get_32 (abfd, note + 4);
      note_type = bfd_h_get_32 (abfd, note + 8);
d1262 6
a1267 5
      if (name_length == 4 && data_length == 16
	  && note_type == NT_GNU_ABI_TAG
	  && strcmp (note + 12, "GNU") == 0)
	{
	  int abi_tag_os = bfd_h_get_32 (abfd, note + 16);
d1269 1
a1269 54
	  /* The case numbers are from abi-tags in glibc.  */
	  switch (abi_tag_os)
	    {
	    case GNU_ABI_TAG_LINUX:
	      *abi = ABI_TAG_OS_GNU_LINUX;
	      break;

	    case GNU_ABI_TAG_HURD:
	      *abi = ABI_TAG_OS_GNU_HURD;
	      break;

	    case GNU_ABI_TAG_SOLARIS:
	      *abi = ABI_TAG_OS_GNU_SOLARIS;
	      break;

	    default:
	      internal_error
		(__FILE__, __LINE__,
		 "process_note_abi_sections: unknown ABI OS tag %d",
		 abi_tag_os);
	      break;
	    }
	}
      else if (name_length == 8 && data_length == 4
	       && note_type == NT_FREEBSD_ABI_TAG
	       && strcmp (note + 12, "FreeBSD") == 0)
	*abi = ABI_TAG_OS_FREEBSD;
    }
  /* NetBSD uses a similar trick.  */
  else if (strcmp (name, ".note.netbsd.ident") == 0 && sectsize > 0)
    {
      unsigned int name_length, desc_length, note_type;
      char *note;

      /* If the section is larger than this, it's probably not what we are
         looking for.  */
      if (sectsize > 128)
	sectsize = 128;

      note = alloca (sectsize);

      bfd_get_section_contents (abfd, sect, note,
				(file_ptr) 0, (bfd_size_type) sectsize);

      name_length = bfd_h_get_32 (abfd, note);
      desc_length = bfd_h_get_32 (abfd, note + 4);
      note_type = bfd_h_get_32 (abfd, note + 8);

      if (name_length == 7 && desc_length == 4
	  && note_type == NT_NETBSD_IDENT
	  && strcmp (note + 12, "NetBSD") == 0)
	*abi = ABI_TAG_OS_NETBSD;
    }
}
d1271 2
a1272 2
static int
i386_elf_abi_from_note (bfd *abfd)
d1274 4
a1277 3
  enum i386_abi abi = I386_ABI_UNKNOWN;
  
  bfd_map_over_sections (abfd, process_note_sections, &abi);
d1279 2
a1280 2
  return abi;
}
d1282 2
a1283 4
static enum i386_abi
i386_elf_abi (bfd *abfd)
{
  int elfosabi = elf_elfheader (abfd)->e_ident[EI_OSABI];
d1285 2
a1286 7
  /* The fact that the EI_OSABI byte is set to ELFOSABI_NONE doesn't
     necessarily mean that this is a System V ELF binary.  To further
     distinguish between binaries for differens operating systems,
     check for vendor-specific note elements.  */
  if (elfosabi == ELFOSABI_NONE)
    {
      enum i386_abi abi = i386_elf_abi_from_note (abfd);
d1288 1
a1288 2
      if (abi != I386_ABI_UNKNOWN)
	return abi;
d1290 4
a1293 5
      /* FreeBSD folks are naughty; they stored the string "FreeBSD"
	 in the padding of the e_ident field of the ELF header.  */
      if (strcmp (&elf_elfheader (abfd)->e_ident[8], "FreeBSD") == 0)
	return I386_ABI_FREEBSD;
    }
d1295 1
a1295 7
  switch (elfosabi)
    {
    case ELFOSABI_NONE:
      return I386_ABI_SVR4;
    case ELFOSABI_FREEBSD:
      return I386_ABI_FREEBSD;
    }
d1297 1
a1297 1
  return I386_ABI_UNKNOWN;
d1300 1
a1300 8
struct i386_abi_handler
{
  struct i386_abi_handler *next;
  enum i386_abi abi;
  void (*init_abi)(struct gdbarch_info, struct gdbarch *);
};

struct i386_abi_handler *i386_abi_handler_list = NULL;
d1303 1
a1303 3
i386_gdbarch_register_os_abi (enum i386_abi abi,
			      void (*init_abi)(struct gdbarch_info,
					       struct gdbarch *))
d1305 4
a1308 1
  struct i386_abi_handler **handler_p;
d1310 1
a1310 19
  for (handler_p = &i386_abi_handler_list; *handler_p != NULL;
       handler_p = &(*handler_p)->next)
    {
      if ((*handler_p)->abi == abi)
	{
	  internal_error
	    (__FILE__, __LINE__,
	     "i386_gdbarch_register_abi: A handler for this ABI variant "
	     "(%d) has already been registered", (int) abi);
	  /* If user wants to continue, override previous definition.  */
	  (*handler_p)->init_abi = init_abi;
	  return;
	}
    }
  (*handler_p)
    = (struct i386_abi_handler *) xmalloc (sizeof (struct i386_abi_handler));
  (*handler_p)->next = NULL;
  (*handler_p)->abi = abi;
  (*handler_p)->init_abi = init_abi;
d1312 1
d1319 1
a1319 2
  enum i386_abi abi = I386_ABI_UNKNOWN;
  struct i386_abi_handler *abi_handler;
d1321 1
d1323 1
a1323 12
    {
      switch (bfd_get_flavour (info.abfd))
	{
	case bfd_target_elf_flavour:
	  abi= i386_elf_abi (info.abfd);
	  break;

	default:
	  /* Not sure what to do here, leave the ABI as unknown.  */
	  break;
	}
    }
d1330 1
a1330 1
      /* Make sure the ABI selection matches.  */
d1332 1
a1332 1
      if (tdep && tdep->abi == abi)
d1340 13
a1352 1
  tdep->abi = abi;
d1354 1
a1354 3
  /* FIXME: kettenis/2001-11-24: Although not all IA-32 processors
     have the SSE registers, it's easier to set the default to 8.  */
  tdep->num_xmm_regs = 8;
d1370 8
a1377 1
  /* NOTE: tm-i386nw.h and tm-i386v4.h override this.  */
d1379 23
a1401 4

  /* NOTE: tm-i386aix.h, tm-i386bsd.h, tm-i386os9k.h, tm-linux.h,
     tm-ptx.h, tm-symmetry.h currently override this.  Sigh.  */
  set_gdbarch_num_regs (gdbarch, NUM_GREGS + NUM_FREGS + NUM_SSE_REGS);
d1404 1
a1404 15
  if (abi == I386_ABI_UNKNOWN)
    {
      /* Don't complain about not knowing the ABI variant if we don't
	 have an inferior.  */
      if (info.abfd)
	fprintf_filtered
	  (gdb_stderr, "GDB doesn't recognize the ABI of the inferior.  "
	   "Attempting to continue with the default i386 settings");
    }
  else
    {
      for (abi_handler = i386_abi_handler_list; abi_handler != NULL;
	   abi_handler = abi_handler->next)
	if (abi_handler->abi == abi)
	  break;
a1405 17
      if (abi_handler)
	abi_handler->init_abi (info, gdbarch);
      else
	{
	  /* We assume that if GDB_MULTI_ARCH is less than
	     GDB_MULTI_ARCH_TM that an ABI variant can be supported by
	     overriding definitions in this file.  */
	  if (GDB_MULTI_ARCH > GDB_MULTI_ARCH_PARTIAL)
	    fprintf_filtered
	      (gdb_stderr,
	       "A handler for the ABI variant \"%s\" is not built into this "
	       "configuration of GDB.  "
	       "Attempting to continue with the default i386 settings",
	       i386_abi_names[abi]);
	}
    }
  
d1409 16
d1462 26
@


1.55.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d39 2
d63 1
a63 1
static int i386_register_offset[I386_SSE_NUM_REGS];
d67 1
a67 1
static int i386_register_size[I386_SSE_NUM_REGS] = {
d83 1
a83 1
const char *
d111 8
d122 1
a122 1
static int
d153 1
a153 1
/* Convert DWARF register number REG to the appropriate register
d156 1
a156 1
static int
d469 1
a469 1
static CORE_ADDR
d496 1
a496 1
static CORE_ADDR
d499 5
d505 2
a506 3
    {
      CORE_ADDR (*sigtramp_saved_pc) (struct frame_info *);
      sigtramp_saved_pc = gdbarch_tdep (current_gdbarch)->sigtramp_saved_pc;
d508 2
a509 3
      gdb_assert (sigtramp_saved_pc != NULL);
      return sigtramp_saved_pc (frame);
    }
d511 4
a514 1
  return read_memory_unsigned_integer (frame->frame + 4, 4);
d519 1
a519 1
static CORE_ADDR
d685 2
a686 2
CORE_ADDR
i386_skip_prologue (CORE_ADDR pc)
a767 18
/* Use the program counter to determine the contents and size of a
   breakpoint instruction.  Return a pointer to a string of bytes that
   encode a breakpoint instruction, store the length of the string in
   *LEN and optionally adjust *PC to point to the correct memory
   location for inserting the breakpoint.

   On the i386 we have a single breakpoint that fits in a single byte
   and can be inserted anywhere.  */
   
static const unsigned char *
i386_breakpoint_from_pc (CORE_ADDR *pc, int *len)
{
  static unsigned char break_insn[] = { 0xcc };	/* int 3 */
  
  *len = sizeof (break_insn);
  return break_insn;
}

a787 13
/* The i386 call dummy sequence:

     call 11223344 (32-bit relative)
     int 3

   It is 8 bytes long.  */

static LONGEST i386_call_dummy_words[] =
{
  0x223344e8,
  0xcc11
};

d837 12
d851 2
a852 2
   structure from which we extract the address that we will land at.
   This address is copied into PC.  This routine returns true on
d855 2
a856 2
static int
i386_get_longjmp_target (CORE_ADDR *pc)
d858 1
a858 1
  char buf[4];
a859 1
  int jb_pc_offset = gdbarch_tdep (current_gdbarch)->jb_pc_offset;
d861 5
a865 3
  /* If JB_PC_OFFSET is -1, we have no way to find out where the
     longjmp will land.  */
  if (jb_pc_offset == -1)
d868 4
a871 2
  sp = read_register (SP_REGNUM);
  if (target_read_memory (sp + 4, buf, 4))
d874 1
a874 3
  jb_addr = extract_address (buf, 4);
  if (target_read_memory (jb_addr + jb_pc_offset, buf, 4))
    return 0;
a875 1
  *pc = extract_address (buf, 4);
d878 2
d930 1
a930 1
      if (FP0_REGNUM == 0)
d984 1
a984 1
      if (FP0_REGNUM == 0)
a1046 31
/* This is the variable that is set with "set struct-convention", and
   its legitimate values.  */
static const char default_struct_convention[] = "default";
static const char pcc_struct_convention[] = "pcc";
static const char reg_struct_convention[] = "reg";
static const char *valid_conventions[] =
{
  default_struct_convention,
  pcc_struct_convention,
  reg_struct_convention,
  NULL
};
static const char *struct_convention = default_struct_convention;

static int
i386_use_struct_convention (int gcc_p, struct type *type)
{
  enum struct_return struct_return;

  if (struct_convention == default_struct_convention)
    struct_return = gdbarch_tdep (current_gdbarch)->struct_return;
  else if (struct_convention == pcc_struct_convention)
    struct_return = pcc_struct_return;
  else
    struct_return = reg_struct_return;

  return generic_use_struct_convention (struct_return == reg_struct_return,
					type);
}


d1125 28
a1201 10
/* Return non-zero if PC and NAME show that we are in a signal
   trampoline.  */

static int
i386_pc_in_sigtramp (CORE_ADDR pc, char *name)
{
  return (name && strcmp ("_sigtramp", name) == 0);
}


d1216 1
d1218 13
a1231 4
/* There are a few i386 architecture variants that differ only
   slightly from the generic i386 target.  For now, we don't give them
   their own source file, but include them here.  As a consequence,
   they'll always be included.  */
d1233 5
a1237 1
/* System V Release 4 (SVR4).  */
d1239 2
a1240 2
static int
i386_svr4_pc_in_sigtramp (CORE_ADDR pc, char *name)
d1242 21
a1262 4
  return (name && (strcmp ("_sigreturn", name) == 0
		   || strcmp ("_sigacthandler", name) == 0
		   || strcmp ("sigvechandler", name) == 0));
}
d1264 3
a1266 2
/* Get saved user PC for sigtramp from the pushed ucontext on the
   stack for all three variants of SVR4 sigtramps.  */
d1268 5
a1272 5
CORE_ADDR
i386_svr4_sigtramp_saved_pc (struct frame_info *frame)
{
  CORE_ADDR saved_pc_offset = 4;
  char *name = NULL;
d1274 52
a1325 9
  find_pc_partial_function (frame->pc, &name, NULL, NULL);
  if (name)
    {
      if (strcmp (name, "_sigreturn") == 0)
	saved_pc_offset = 132 + 14 * 4;
      else if (strcmp (name, "_sigacthandler") == 0)
	saved_pc_offset = 80 + 14 * 4;
      else if (strcmp (name, "sigvechandler") == 0)
	saved_pc_offset = 120 + 14 * 4;
a1326 4

  if (frame->next)
    return read_memory_integer (frame->next->frame + saved_pc_offset, 4);
  return read_memory_integer (read_register (SP_REGNUM) + saved_pc_offset, 4);
a1327 3


/* DJGPP.  */
d1330 1
a1330 1
i386_go32_pc_in_sigtramp (CORE_ADDR pc, char *name)
d1332 5
a1336 2
  /* DJGPP doesn't have any special frames for signal handlers.  */
  return 0;
a1337 1

d1339 2
a1340 4
/* Generic ELF.  */

void
i386_elf_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
d1342 1
a1342 3
  /* We typically use stabs-in-ELF with the DWARF register numbering.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_dwarf_reg_to_regnum);
}
d1344 7
a1350 1
/* System V Release 4 (SVR4).  */
d1352 2
a1353 4
void
i386_svr4_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1355 5
a1359 2
  /* System V Release 4 uses ELF.  */
  i386_elf_init_abi (info, gdbarch);
d1361 7
a1367 2
  /* FIXME: kettenis/20020511: Why do we override this function here?  */
  set_gdbarch_frame_chain_valid (gdbarch, func_frame_chain_valid);
d1369 1
a1369 4
  set_gdbarch_pc_in_sigtramp (gdbarch, i386_svr4_pc_in_sigtramp);
  tdep->sigtramp_saved_pc = i386_svr4_sigtramp_saved_pc;

  tdep->jb_pc_offset = 20;
d1372 1
a1372 4
/* DJGPP.  */

void
i386_go32_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
d1374 4
a1377 3
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  set_gdbarch_pc_in_sigtramp (gdbarch, i386_go32_pc_in_sigtramp);
d1379 1
a1379 4
  tdep->jb_pc_offset = 36;
}

/* NetWare.  */
d1382 3
a1384 1
i386_nw_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
d1386 1
a1386 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1388 19
a1406 4
  /* FIXME: kettenis/20020511: Why do we override this function here?  */
  set_gdbarch_frame_chain_valid (gdbarch, func_frame_chain_valid);

  tdep->jb_pc_offset = 24;
a1407 1

d1414 2
a1415 1
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
a1416 1
  /* Try to determine the OS ABI of the object we're loading.  */
d1418 12
a1429 1
    osabi = gdbarch_lookup_osabi (info.abfd);
d1436 1
a1436 1
      /* Make sure the OS ABI selection matches.  */
d1438 1
a1438 1
      if (tdep && tdep->osabi == osabi)
d1446 1
a1446 54
  tdep->osabi = osabi;

  /* The i386 default settings don't include the SSE registers.
     FIXME: kettenis/20020614: They do include the FPU registers for
     now, which probably is not quite right.  */
  tdep->num_xmm_regs = 0;

  tdep->jb_pc_offset = -1;
  tdep->struct_return = pcc_struct_return;
  tdep->sigtramp_saved_pc = NULL;
  tdep->sigtramp_start = 0;
  tdep->sigtramp_end = 0;
  tdep->sc_pc_offset = -1;

  /* The format used for `long double' on almost all i386 targets is
     the i387 extended floating-point format.  In fact, of all targets
     in the GCC 2.95 tree, only OSF/1 does it different, and insists
     on having a `long double' that's not `long' at all.  */
  set_gdbarch_long_double_format (gdbarch, &floatformat_i387_ext);
  
  /* Although the i386 extended floating-point has only 80 significant
     bits, a `long double' actually takes up 96, probably to enforce
     alignment.  */
  set_gdbarch_long_double_bit (gdbarch, 96);

  /* NOTE: tm-i386aix.h, tm-i386bsd.h, tm-i386os9k.h, tm-ptx.h,
     tm-symmetry.h currently override this.  Sigh.  */
  set_gdbarch_num_regs (gdbarch, I386_NUM_GREGS + I386_NUM_FREGS);
  
  set_gdbarch_sp_regnum (gdbarch, 4);
  set_gdbarch_fp_regnum (gdbarch, 5);
  set_gdbarch_pc_regnum (gdbarch, 8);
  set_gdbarch_ps_regnum (gdbarch, 9);
  set_gdbarch_fp0_regnum (gdbarch, 16);

  /* Use the "default" register numbering scheme for stabs and COFF.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_stab_reg_to_regnum);
  set_gdbarch_sdb_reg_to_regnum (gdbarch, i386_stab_reg_to_regnum);

  /* Use the DWARF register numbering scheme for DWARF and DWARF 2.  */
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, i386_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, i386_dwarf_reg_to_regnum);

  /* We don't define ECOFF_REG_TO_REGNUM, since ECOFF doesn't seem to
     be in use on any of the supported i386 targets.  */

  set_gdbarch_register_name (gdbarch, i386_register_name);
  set_gdbarch_register_size (gdbarch, 4);
  set_gdbarch_register_bytes (gdbarch, I386_SIZEOF_GREGS + I386_SIZEOF_FREGS);
  set_gdbarch_register_byte (gdbarch, i386_register_byte);
  set_gdbarch_register_raw_size (gdbarch, i386_register_raw_size);
  set_gdbarch_max_register_raw_size (gdbarch, 16);
  set_gdbarch_max_register_virtual_size (gdbarch, 16);
  set_gdbarch_register_virtual_type (gdbarch, i386_register_virtual_type);
d1448 3
a1450 1
  set_gdbarch_get_longjmp_target (gdbarch, i386_get_longjmp_target);
a1455 1
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
a1457 1
  set_gdbarch_call_dummy_length (gdbarch, 8);
a1458 3
  set_gdbarch_call_dummy_words (gdbarch, i386_call_dummy_words);
  set_gdbarch_sizeof_call_dummy_words (gdbarch,
				       sizeof (i386_call_dummy_words));
a1459 6
  set_gdbarch_fix_call_dummy (gdbarch, i386_fix_call_dummy);

  set_gdbarch_register_convertible (gdbarch, i386_register_convertible);
  set_gdbarch_register_convert_to_virtual (gdbarch,
					   i386_register_convert_to_virtual);
  set_gdbarch_register_convert_to_raw (gdbarch, i386_register_convert_to_raw);
d1466 2
a1467 4
  /* "An argument's size is increased, if necessary, to make it a
     multiple of [32-bit] words.  This may require tail padding,
     depending on the size of the argument" -- from the x86 ABI.  */
  set_gdbarch_parm_boundary (gdbarch, 32);
d1469 3
a1471 37
  set_gdbarch_deprecated_extract_return_value (gdbarch,
					       i386_extract_return_value);
  set_gdbarch_push_arguments (gdbarch, i386_push_arguments);
  set_gdbarch_push_dummy_frame (gdbarch, i386_push_dummy_frame);
  set_gdbarch_pop_frame (gdbarch, i386_pop_frame);
  set_gdbarch_store_struct_return (gdbarch, i386_store_struct_return);
  set_gdbarch_store_return_value (gdbarch, i386_store_return_value);
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch,
					    i386_extract_struct_value_address);
  set_gdbarch_use_struct_convention (gdbarch, i386_use_struct_convention);

  set_gdbarch_frame_init_saved_regs (gdbarch, i386_frame_init_saved_regs);
  set_gdbarch_skip_prologue (gdbarch, i386_skip_prologue);

  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);

  set_gdbarch_breakpoint_from_pc (gdbarch, i386_breakpoint_from_pc);
  set_gdbarch_decr_pc_after_break (gdbarch, 1);
  set_gdbarch_function_start_offset (gdbarch, 0);

  /* The following redefines make backtracing through sigtramp work.
     They manufacture a fake sigtramp frame and obtain the saved pc in
     sigtramp from the sigcontext structure which is pushed by the
     kernel on the user stack, along with a pointer to it.  */

  set_gdbarch_frame_args_skip (gdbarch, 8);
  set_gdbarch_frameless_function_invocation (gdbarch,
                                           i386_frameless_function_invocation);
  set_gdbarch_frame_chain (gdbarch, i386_frame_chain);
  set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
  set_gdbarch_frame_saved_pc (gdbarch, i386_frame_saved_pc);
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);
  set_gdbarch_saved_pc_after_call (gdbarch, i386_saved_pc_after_call);
  set_gdbarch_frame_num_args (gdbarch, i386_frame_num_args);
  set_gdbarch_pc_in_sigtramp (gdbarch, i386_pc_in_sigtramp);
d1474 15
a1488 1
  gdbarch_init_osabi (info, gdbarch, osabi);
d1490 17
a1509 17
static enum gdb_osabi
i386_coff_osabi_sniffer (bfd *abfd)
{
  if (strcmp (bfd_get_target (abfd), "coff-go32-exe") == 0
      || strcmp (bfd_get_target (abfd), "coff-go32") == 0)
    return GDB_OSABI_GO32;

  return GDB_OSABI_UNKNOWN;
}

static enum gdb_osabi
i386_nlm_osabi_sniffer (bfd *abfd)
{
  return GDB_OSABI_NETWARE;
}


d1524 1
a1524 1
    for (i = 0; i < I386_SSE_NUM_REGS; i++)
a1546 26

  /* Add the variable that controls the convention for returning
     structs.  */
  {
    struct cmd_list_element *new_cmd;

    new_cmd = add_set_enum_cmd ("struct-convention", no_class,
				 valid_conventions,
				&struct_convention, "\
Set the convention for returning small structs, valid values \
are \"default\", \"pcc\" and \"reg\", and the default value is \"default\".",
                                &setlist);
    add_show_from_set (new_cmd, &showlist);
  }

  gdbarch_register_osabi_sniffer (bfd_arch_i386, bfd_target_coff_flavour,
				  i386_coff_osabi_sniffer);
  gdbarch_register_osabi_sniffer (bfd_arch_i386, bfd_target_nlm_flavour,
				  i386_nlm_osabi_sniffer);

  gdbarch_register_osabi (bfd_arch_i386, GDB_OSABI_SVR4,
			  i386_svr4_init_abi);
  gdbarch_register_osabi (bfd_arch_i386, GDB_OSABI_GO32,
			  i386_go32_init_abi);
  gdbarch_register_osabi (bfd_arch_i386, GDB_OSABI_NETWARE,
			  i386_nw_init_abi);
@


1.55.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a29 1
#include "symfile.h"
a454 36
/* Signal trampolines don't have a meaningful frame.  The frame
   pointer value we use is actually the frame pointer of the calling
   frame -- that is, the frame which was in progress when the signal
   trampoline was entered.  GDB mostly treats this frame pointer value
   as a magic cookie.  We detect the case of a signal trampoline by
   looking at the SIGNAL_HANDLER_CALLER field, which is set based on
   PC_IN_SIGTRAMP.

   When a signal trampoline is invoked from a frameless function, we
   essentially have two frameless functions in a row.  In this case,
   we use the same magic cookie for three frames in a row.  We detect
   this case by seeing whether the next frame has
   SIGNAL_HANDLER_CALLER set, and, if it does, checking whether the
   current frame is actually frameless.  In this case, we need to get
   the PC by looking at the SP register value stored in the signal
   context.

   This should work in most cases except in horrible situations where
   a signal occurs just as we enter a function but before the frame
   has been set up.  Incidentally, that's just what happens when we
   call a function from GDB with a signal pending (there's a test in
   the testsuite that makes this happen).  Therefore we pretend that
   we have a frameless function if we're stopped at the start of a
   function.  */

/* Return non-zero if we're dealing with a frameless signal, that is,
   a signal trampoline invoked from a frameless function.  */

static int
i386_frameless_signal_p (struct frame_info *frame)
{
  return (frame->next && frame->next->signal_handler_caller
	  && (frameless_look_for_prologue (frame)
	      || frame->pc == get_pc_function_start (frame->pc)));
}

d462 1
a462 5
  if (PC_IN_CALL_DUMMY (frame->pc, 0, 0))
    return frame->frame;

  if (frame->signal_handler_caller
      || i386_frameless_signal_p (frame))
d475 1
a475 1
static int
a483 26
/* Assuming FRAME is for a sigtramp routine, return the saved program
   counter.  */

static CORE_ADDR
i386_sigtramp_saved_pc (struct frame_info *frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  CORE_ADDR addr;

  addr = tdep->sigcontext_addr (frame);
  return read_memory_unsigned_integer (addr + tdep->sc_pc_offset, 4);
}

/* Assuming FRAME is for a sigtramp routine, return the saved stack
   pointer.  */

static CORE_ADDR
i386_sigtramp_saved_sp (struct frame_info *frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  CORE_ADDR addr;

  addr = tdep->sigcontext_addr (frame);
  return read_memory_unsigned_integer (addr + tdep->sc_sp_offset, 4);
}

a488 4
  if (PC_IN_CALL_DUMMY (frame->pc, 0, 0))
    return generic_read_register_dummy (frame->pc, frame->frame,
					PC_REGNUM);

d490 3
a492 1
    return i386_sigtramp_saved_pc (frame);
d494 2
a495 4
  if (i386_frameless_signal_p (frame))
    {
      CORE_ADDR sp = i386_sigtramp_saved_sp (frame->next);
      return read_memory_unsigned_integer (sp, 4);
a505 3
  if (frame->signal_handler_caller)
    return i386_sigtramp_saved_pc (frame);

d512 1
a512 1
static int
d609 1
a609 1
static void
d614 1
d624 17
d669 1
a669 1
static CORE_ADDR
d770 7
a776 2
/* Push the return address (pointing to the call dummy) onto the stack
   and return the new value for the stack pointer.  */
d778 31
a808 2
static CORE_ADDR
i386_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
d810 1
a810 1
  char buf[4];
d812 9
a820 3
  store_unsigned_integer (buf, 4, CALL_DUMMY_ADDRESS ());
  write_memory (sp - 4, buf, 4);
  return sp - 4;
d823 2
a824 2
static void
i386_do_pop_frame (struct frame_info *frame)
d826 1
d829 1
a829 1
  char regbuf[I386_MAX_REGISTER_SIZE];
a849 6

static void
i386_pop_frame (void)
{
  generic_pop_current_frame (i386_do_pop_frame);
}
d883 1
a883 1
static CORE_ADDR
d901 1
a901 1
static void
d917 2
a918 3
static void
i386_extract_return_value (struct type *type, struct regcache *regcache,
			   char *valbuf)
a920 1
  char buf[I386_MAX_REGISTER_SIZE];
d925 1
a925 1
      i386_extract_return_value (TYPE_FIELD_TYPE (type, 0), regcache, valbuf);
d942 2
a943 2
      regcache_read (regcache, FP0_REGNUM, buf);
      convert_typed_floating (buf, builtin_type_i387_ext, valbuf, type);
d951 1
a951 4
	{
	  regcache_read (regcache, LOW_RETURN_REGNUM, buf);
	  memcpy (valbuf, buf, len);
	}
d954 4
a957 4
	  regcache_read (regcache, LOW_RETURN_REGNUM, buf);
	  memcpy (valbuf, buf, low_size);
	  regcache_read (regcache, HIGH_RETURN_REGNUM, buf);
	  memcpy (valbuf + low_size, buf, len - low_size);
d968 1
a968 1
static void
d1040 2
a1041 2
static CORE_ADDR
i386_extract_struct_value_address (struct regcache *regcache)
d1043 2
a1044 1
  return regcache_read_as_address (regcache, LOW_RETURN_REGNUM);
d1083 1
a1083 1
static struct type *
d1104 1
a1104 1
static int
d1113 1
a1113 1
static void
d1136 1
a1136 1
static void
d1247 2
a1248 2
/* Get address of the pushed ucontext (sigcontext) on the stack for
   all three variants of SVR4 sigtramps.  */
d1250 2
a1251 2
static CORE_ADDR
i386_svr4_sigcontext_addr (struct frame_info *frame)
d1253 1
a1253 1
  int sigcontext_offset = -1;
d1260 1
a1260 1
	sigcontext_offset = 132;
d1262 1
a1262 1
	sigcontext_offset = 80;
d1264 1
a1264 1
	sigcontext_offset = 120;
a1266 2
  gdb_assert (sigcontext_offset != -1);

d1268 2
a1269 2
    return frame->next->frame + sigcontext_offset;
  return read_register (SP_REGNUM) + sigcontext_offset;
d1306 1
a1306 3
  tdep->sigcontext_addr = i386_svr4_sigcontext_addr;
  tdep->sc_pc_offset = 14 * 4;
  tdep->sc_sp_offset = 7 * 4;
d1313 1
a1313 1
static void
d1325 1
a1325 1
static void
d1337 1
a1337 1
static struct gdbarch *
d1372 1
a1374 1
  tdep->sigcontext_addr = NULL;
a1375 1
  tdep->sc_sp_offset = -1;
d1382 1
a1382 1

d1391 1
a1391 1

d1414 2
a1415 2
  set_gdbarch_max_register_raw_size (gdbarch, I386_MAX_REGISTER_SIZE);
  set_gdbarch_max_register_virtual_size (gdbarch, I386_MAX_REGISTER_SIZE);
d1420 1
a1420 1
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);
d1423 1
a1423 2
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
  set_gdbarch_call_dummy_address (gdbarch, entry_point_address);
d1425 1
a1425 1
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
d1427 1
a1427 1
  set_gdbarch_call_dummy_length (gdbarch, 0);
d1429 3
a1431 2
  set_gdbarch_call_dummy_words (gdbarch, NULL);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, 0);
d1433 1
a1433 1
  set_gdbarch_fix_call_dummy (gdbarch, generic_fix_call_dummy);
d1443 1
a1443 1
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_at_entry_point);
d1450 2
a1451 1
  set_gdbarch_extract_return_value (gdbarch, i386_extract_return_value);
d1453 1
a1453 2
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
  set_gdbarch_push_return_address (gdbarch, i386_push_return_address);
d1457 1
a1457 1
  set_gdbarch_extract_struct_value_address (gdbarch,
d1480 1
a1480 1
  set_gdbarch_frame_chain_valid (gdbarch, generic_file_frame_chain_valid);
@


1.55.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d965 1
a965 1
      regcache_raw_read (regcache, FP0_REGNUM, buf);
d975 1
a975 1
	  regcache_raw_read (regcache, LOW_RETURN_REGNUM, buf);
d980 1
a980 1
	  regcache_raw_read (regcache, LOW_RETURN_REGNUM, buf);
d982 1
a982 1
	  regcache_raw_read (regcache, HIGH_RETURN_REGNUM, buf);
d1069 1
a1069 1
  return regcache_raw_read_as_address (regcache, LOW_RETURN_REGNUM);
@


1.55.2.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a27 1
#include "objfiles.h"
a40 1
#include "i387-tdep.h"
d59 19
a77 6
/* MMX registers.  */

static char *i386_mmx_names[] =
{
  "mm0", "mm1", "mm2", "mm3",
  "mm4", "mm5", "mm6", "mm7"
a78 9
static const int mmx_num_regs = (sizeof (i386_mmx_names)
				 / sizeof (i386_mmx_names[0]));
#define MM0_REGNUM (NUM_REGS)

static int
mmx_regnum_p (int reg)
{
  return (reg >= MM0_REGNUM && reg < MM0_REGNUM + mmx_num_regs);
}
a86 2
  if (mmx_regnum_p (reg))
    return i386_mmx_names[reg - MM0_REGNUM];
d93 17
d135 3
a137 1
      return reg - 29 + MM0_REGNUM;
d856 2
a857 1
	  write_register_gen (regnum, regbuf);
d940 1
a940 1
			   void *dst)
a941 1
  bfd_byte *valbuf = dst;
d995 1
a995 2
i386_store_return_value (struct type *type, struct regcache *regcache,
			 const void *valbuf)
d1002 1
a1002 1
      i386_store_return_value (TYPE_FIELD_TYPE (type, 0), regcache, valbuf);
d1008 1
a1008 1
      ULONGEST fstat;
d1026 2
a1027 1
      regcache_raw_write (regcache, FP0_REGNUM, buf);
d1033 1
a1033 1
      regcache_raw_read_unsigned (regcache, FSTAT_REGNUM, &fstat);
d1035 1
a1035 1
      regcache_raw_write_unsigned (regcache, FSTAT_REGNUM, fstat);
d1040 1
a1040 1
      regcache_raw_write_unsigned (regcache, FTAG_REGNUM, 0x3fff);
d1048 1
a1048 1
	regcache_raw_write_part (regcache, LOW_RETURN_REGNUM, 0, len, valbuf);
d1051 4
a1054 3
	  regcache_raw_write (regcache, LOW_RETURN_REGNUM, valbuf);
	  regcache_raw_write_part (regcache, HIGH_RETURN_REGNUM, 0,
				   len - low_size, (char *) valbuf + low_size);
d1069 1
a1069 12
  /* NOTE: cagney/2002-08-12: Replaced a call to
     regcache_raw_read_as_address() with a call to
     regcache_cooked_read_unsigned().  The old, ...as_address function
     was eventually calling extract_unsigned_integer (via
     extract_address) to unpack the registers value.  The below is
     doing an unsigned extract so that it is functionally equivalent.
     The read needs to be cooked as, otherwise, it will never
     correctly return the value of a register in the [NUM_REGS
     .. NUM_REGS+NUM_PSEUDO_REGS) range.  */
  ULONGEST val;
  regcache_cooked_read_unsigned (regcache, LOW_RETURN_REGNUM, &val);
  return val;
a1119 3
  if (mmx_regnum_p (regnum))
    return builtin_type_vec64i;

a1122 52
/* Map a cooked register onto a raw register or memory.  For the i386,
   the MMX registers need to be mapped onto floating point registers.  */

static int
mmx_regnum_to_fp_regnum (struct regcache *regcache, int regnum)
{
  int mmxi;
  ULONGEST fstat;
  int tos;
  int fpi;
  mmxi = regnum - MM0_REGNUM;
  regcache_raw_read_unsigned (regcache, FSTAT_REGNUM, &fstat);
  tos = (fstat >> 11) & 0x7;
  fpi = (mmxi + tos) % 8;
  return (FP0_REGNUM + fpi);
}

static void
i386_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int regnum, void *buf)
{
  if (mmx_regnum_p (regnum))
    {
      char *mmx_buf = alloca (MAX_REGISTER_RAW_SIZE);
      int fpnum = mmx_regnum_to_fp_regnum (regcache, regnum);
      regcache_raw_read (regcache, fpnum, mmx_buf);
      /* Extract (always little endian).  */
      memcpy (buf, mmx_buf, REGISTER_RAW_SIZE (regnum));
    }
  else
    regcache_raw_read (regcache, regnum, buf);
}

static void
i386_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int regnum, const void *buf)
{
  if (mmx_regnum_p (regnum))
    {
      char *mmx_buf = alloca (MAX_REGISTER_RAW_SIZE);
      int fpnum = mmx_regnum_to_fp_regnum (regcache, regnum);
      /* Read ...  */
      regcache_raw_read (regcache, fpnum, mmx_buf);
      /* ... Modify ... (always little endian).  */
      memcpy (mmx_buf, buf, REGISTER_RAW_SIZE (regnum));
      /* ... Write.  */
      regcache_raw_write (regcache, fpnum, mmx_buf);
    }
  else
    regcache_raw_write (regcache, regnum, buf);
}

d1211 1
a1211 1
i386_pe_skip_trampoline_code (CORE_ADDR pc, char *name)
a1328 4
  /* System V Release 4 has shared libraries.  */
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
  set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);

d1330 1
a1330 1
  set_gdbarch_frame_chain_valid (gdbarch, generic_func_frame_chain_valid);
d1360 1
a1360 1
  set_gdbarch_frame_chain_valid (gdbarch, generic_func_frame_chain_valid);
d1442 2
a1447 2
  set_gdbarch_print_float_info (gdbarch, i387_print_float_info);

d1470 1
a1470 1
  set_gdbarch_get_saved_register (gdbarch, generic_unwind_get_saved_register);
a1517 5
  /* Wire in the MMX registers.  */
  set_gdbarch_num_pseudo_regs (gdbarch, mmx_num_regs);
  set_gdbarch_pseudo_register_read (gdbarch, i386_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, i386_pseudo_register_write);

d1548 13
@


1.55.2.5
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d538 2
a539 2
    return deprecated_read_register_dummy (frame->pc, frame->frame,
					   PC_REGNUM);
d1105 1
a1105 1
  if (FP_REGNUM_P (regnum))
d1108 1
a1108 1
  if (SSE_REGNUM_P (regnum))
d1178 1
a1178 1
  return FP_REGNUM_P (regnum);
d1188 1
a1188 1
  gdb_assert (FP_REGNUM_P (regnum));
d1211 1
a1211 1
  gdb_assert (FP_REGNUM_P (regnum));
d1291 1
a1291 1
i386_print_insn (bfd_vma pc, disassemble_info *info)
d1293 7
a1299 9
  gdb_assert (disassembly_flavor == att_flavor
	      || disassembly_flavor == intel_flavor);

  /* FIXME: kettenis/20020915: Until disassembler_options is properly
     constified, cast to prevent a compiler warning.  */
  info->disassembler_options = (char *) disassembly_flavor;
  info->mach = gdbarch_bfd_arch_info (current_gdbarch)->mach;

  return print_insn_i386 (pc, info);
d1463 1
a1463 1
  /* Although the i387 extended floating-point has only 80 significant
d1472 5
a1476 5
  set_gdbarch_sp_regnum (gdbarch, 4); /* %esp */
  set_gdbarch_fp_regnum (gdbarch, 5); /* %ebp */
  set_gdbarch_pc_regnum (gdbarch, 8); /* %eip */
  set_gdbarch_ps_regnum (gdbarch, 9); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, 16);	/* %st(0) */
d1521 1
a1572 2
  set_gdbarch_print_insn (gdbarch, i386_print_insn);

d1604 3
d1627 1
a1627 1
				valid_conventions,
@


1.55.2.6
log
@merge from mainline
@
text
@d538 2
a539 6
    {
      ULONGEST pc;

      frame_unwind_unsigned_register (frame, PC_REGNUM, &pc);
      return pc;
    }
d837 1
a837 1
	  deprecated_write_register_gen (regnum, regbuf);
d1042 3
a1044 3
/* Extract from REGCACHE, which contains the (raw) register state, the
   address in which a function should return its structure value, as a
   CORE_ADDR.  */
d1049 12
a1060 4
  ULONGEST addr;

  regcache_raw_read_unsigned (regcache, LOW_RETURN_REGNUM, &addr);
  return addr;
@


1.54
log
@* i386-tdep.h (i386_abi): New enum.
(struct gdbarch_tdep): Replace os_ident member with abi.
(i386_gdbarch_register_os_abi): New prototype.
* i386-tdep.c (i386_abi_names): New array.
(process_note_abi_tag_sections): Removed.
(process_note_sections): New function.
(i386_elf_abi_from_note, i386_elf_abi): New functions.
(struct i386_abi_handler): New struct.
(i386_abi_handler_list): New variable.
(i386_gdbarch_register_os_abi): New function.
(i386_gdbarch_init): Adapt for the changes given above.
@
text
@d1061 1
a1061 1
    return builtin_type_v4sf;
@


1.54.2.1
log
@merge from trunk
@
text
@d39 2
d122 1
a122 1
static int
d153 1
a153 1
/* Convert DWARF register number REG to the appropriate register
d156 1
a156 1
static int
d469 1
a469 1
static CORE_ADDR
d496 1
a496 1
static CORE_ADDR
d499 5
d505 2
a506 3
    {
      CORE_ADDR (*sigtramp_saved_pc) (struct frame_info *);
      sigtramp_saved_pc = gdbarch_tdep (current_gdbarch)->sigtramp_saved_pc;
d508 2
a509 3
      gdb_assert (sigtramp_saved_pc != NULL);
      return sigtramp_saved_pc (frame);
    }
d511 4
a514 1
  return read_memory_unsigned_integer (frame->frame + 4, 4);
d519 1
a519 1
static CORE_ADDR
d837 12
d851 2
a852 2
   structure from which we extract the address that we will land at.
   This address is copied into PC.  This routine returns true on
d855 2
a856 2
static int
i386_get_longjmp_target (CORE_ADDR *pc)
d858 1
a858 1
  char buf[4];
a859 1
  int jb_pc_offset = gdbarch_tdep (current_gdbarch)->jb_pc_offset;
d861 5
a865 3
  /* If JB_PC_OFFSET is -1, we have no way to find out where the
     longjmp will land.  */
  if (jb_pc_offset == -1)
d868 4
a871 2
  sp = read_register (SP_REGNUM);
  if (target_read_memory (sp + 4, buf, 4))
d874 1
a874 3
  jb_addr = extract_address (buf, 4);
  if (target_read_memory (jb_addr + jb_pc_offset, buf, 4))
    return 0;
a875 1
  *pc = extract_address (buf, 4);
d878 2
a1046 31
/* This is the variable that is set with "set struct-convention", and
   its legitimate values.  */
static const char default_struct_convention[] = "default";
static const char pcc_struct_convention[] = "pcc";
static const char reg_struct_convention[] = "reg";
static const char *valid_conventions[] =
{
  default_struct_convention,
  pcc_struct_convention,
  reg_struct_convention,
  NULL
};
static const char *struct_convention = default_struct_convention;

static int
i386_use_struct_convention (int gcc_p, struct type *type)
{
  enum struct_return struct_return;

  if (struct_convention == default_struct_convention)
    struct_return = gdbarch_tdep (current_gdbarch)->struct_return;
  else if (struct_convention == pcc_struct_convention)
    struct_return = pcc_struct_return;
  else
    struct_return = reg_struct_return;

  return generic_use_struct_convention (struct_return == reg_struct_return,
					type);
}


d1061 1
a1061 1
    return builtin_type_vec128i;
d1125 28
a1201 10
/* Return non-zero if PC and NAME show that we are in a signal
   trampoline.  */

static int
i386_pc_in_sigtramp (CORE_ADDR pc, char *name)
{
  return (name && strcmp ("_sigtramp", name) == 0);
}


d1216 1
d1218 13
a1231 4
/* There are a few i386 architecture variants that differ only
   slightly from the generic i386 target.  For now, we don't give them
   their own source file, but include them here.  As a consequence,
   they'll always be included.  */
d1233 5
a1237 1
/* System V Release 4 (SVR4).  */
d1239 2
a1240 2
static int
i386_svr4_pc_in_sigtramp (CORE_ADDR pc, char *name)
d1242 21
a1262 4
  return (name && (strcmp ("_sigreturn", name) == 0
		   || strcmp ("_sigacthandler", name) == 0
		   || strcmp ("sigvechandler", name) == 0));
}
d1264 3
a1266 2
/* Get saved user PC for sigtramp from the pushed ucontext on the
   stack for all three variants of SVR4 sigtramps.  */
d1268 5
a1272 5
CORE_ADDR
i386_svr4_sigtramp_saved_pc (struct frame_info *frame)
{
  CORE_ADDR saved_pc_offset = 4;
  char *name = NULL;
d1274 52
a1325 9
  find_pc_partial_function (frame->pc, &name, NULL, NULL);
  if (name)
    {
      if (strcmp (name, "_sigreturn") == 0)
	saved_pc_offset = 132 + 14 * 4;
      else if (strcmp (name, "_sigacthandler") == 0)
	saved_pc_offset = 80 + 14 * 4;
      else if (strcmp (name, "sigvechandler") == 0)
	saved_pc_offset = 120 + 14 * 4;
a1326 4

  if (frame->next)
    return read_memory_integer (frame->next->frame + saved_pc_offset, 4);
  return read_memory_integer (read_register (SP_REGNUM) + saved_pc_offset, 4);
a1327 3


/* DJGPP.  */
d1330 1
a1330 1
i386_go32_pc_in_sigtramp (CORE_ADDR pc, char *name)
d1332 5
a1336 2
  /* DJGPP doesn't have any special frames for signal handlers.  */
  return 0;
a1337 1

d1339 2
a1340 4
/* Generic ELF.  */

void
i386_elf_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
d1342 1
a1342 3
  /* We typically use stabs-in-ELF with the DWARF register numbering.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_dwarf_reg_to_regnum);
}
d1344 7
a1350 6
/* System V Release 4 (SVR4).  */

void
i386_svr4_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1352 2
a1353 2
  /* System V Release 4 uses ELF.  */
  i386_elf_init_abi (info, gdbarch);
d1355 5
a1359 2
  /* FIXME: kettenis/20020511: Why do we override this function here?  */
  set_gdbarch_frame_chain_valid (gdbarch, func_frame_chain_valid);
d1361 7
a1367 2
  set_gdbarch_pc_in_sigtramp (gdbarch, i386_svr4_pc_in_sigtramp);
  tdep->sigtramp_saved_pc = i386_svr4_sigtramp_saved_pc;
d1369 1
a1369 1
  tdep->jb_pc_offset = 20;
d1372 1
a1372 4
/* DJGPP.  */

void
i386_go32_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
d1374 4
a1377 6
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  set_gdbarch_pc_in_sigtramp (gdbarch, i386_go32_pc_in_sigtramp);

  tdep->jb_pc_offset = 36;
}
d1379 1
a1379 1
/* NetWare.  */
d1382 3
a1384 1
i386_nw_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
d1386 1
a1386 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1388 19
a1406 4
  /* FIXME: kettenis/20020511: Why do we override this function here?  */
  set_gdbarch_frame_chain_valid (gdbarch, func_frame_chain_valid);

  tdep->jb_pc_offset = 24;
a1407 1

d1414 2
a1415 1
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
a1416 1
  /* Try to determine the OS ABI of the object we're loading.  */
d1418 12
a1429 1
    osabi = gdbarch_lookup_osabi (info.abfd);
d1436 1
a1436 1
      /* Make sure the OS ABI selection matches.  */
d1438 1
a1438 1
      if (tdep && tdep->osabi == osabi)
d1446 1
a1446 1
  tdep->osabi = osabi;
d1448 3
a1450 24
  /* The i386 default settings don't include the SSE registers.
     FIXME: kettenis/20020509: They do include the FPU registers for
     now, which is not quite right.  */
  tdep->num_xmm_regs = 0;

  tdep->jb_pc_offset = -1;
  tdep->struct_return = pcc_struct_return;
  tdep->sigtramp_saved_pc = NULL;
  tdep->sigtramp_start = 0;
  tdep->sigtramp_end = 0;
  tdep->sc_pc_offset = -1;

  /* The format used for `long double' on almost all i386 targets is
     the i387 extended floating-point format.  In fact, of all targets
     in the GCC 2.95 tree, only OSF/1 does it different, and insists
     on having a `long double' that's not `long' at all.  */
  set_gdbarch_long_double_format (gdbarch, &floatformat_i387_ext);
  
  /* Although the i386 extended floating-point has only 80 significant
     bits, a `long double' actually takes up 96, probably to enforce
     alignment.  */
  set_gdbarch_long_double_bit (gdbarch, 96);

  set_gdbarch_get_longjmp_target (gdbarch, i386_get_longjmp_target);
d1466 2
a1467 1
  set_gdbarch_use_struct_convention (gdbarch, i386_use_struct_convention);
d1469 3
a1471 30
  /* The following redefines make backtracing through sigtramp work.
     They manufacture a fake sigtramp frame and obtain the saved pc in
     sigtramp from the sigcontext structure which is pushed by the
     kernel on the user stack, along with a pointer to it.  */

  set_gdbarch_frame_chain (gdbarch, i386_frame_chain);
  set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
  set_gdbarch_frame_saved_pc (gdbarch, i386_frame_saved_pc);
  set_gdbarch_saved_pc_after_call (gdbarch, i386_saved_pc_after_call);
  set_gdbarch_pc_in_sigtramp (gdbarch, i386_pc_in_sigtramp);

  /* NOTE: tm-i386aix.h, tm-i386bsd.h, tm-i386os9k.h, tm-ptx.h,
     tm-symmetry.h currently override this.  Sigh.  */
  set_gdbarch_num_regs (gdbarch, I386_NUM_GREGS + I386_NUM_FREGS);

  /* Use the "default" register numbering scheme for stabs and COFF.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_stab_reg_to_regnum);
  set_gdbarch_sdb_reg_to_regnum (gdbarch, i386_stab_reg_to_regnum);

  /* Use the DWARF register numbering scheme for DWARF and DWARF 2.  */
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, i386_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, i386_dwarf_reg_to_regnum);

  /* We don't define ECOFF_REG_TO_REGNUM, since ECOFF doesn't seem to
     be in use on any of the supported i386 targets.  */

  set_gdbarch_register_bytes (gdbarch, I386_SIZEOF_GREGS + I386_SIZEOF_FREGS);
  set_gdbarch_register_name (gdbarch, i386_register_name);
  set_gdbarch_register_byte (gdbarch, i386_register_byte);
  set_gdbarch_register_raw_size (gdbarch, i386_register_raw_size);
d1474 15
a1488 1
  gdbarch_init_osabi (info, gdbarch, osabi);
d1490 17
a1509 16
static enum gdb_osabi
i386_coff_osabi_sniffer (bfd *abfd)
{
  if (strcmp (bfd_get_target (abfd), "coff-go32-exe") == 0)
    return GDB_OSABI_GO32;

  return GDB_OSABI_UNKNOWN;
}

static enum gdb_osabi
i386_nlm_osabi_sniffer (bfd *abfd)
{
  return GDB_OSABI_NETWARE;
}


a1546 26

  /* Add the variable that controls the convention for returning
     structs.  */
  {
    struct cmd_list_element *new_cmd;

    new_cmd = add_set_enum_cmd ("struct-convention", no_class,
				 valid_conventions,
				&struct_convention, "\
Set the convention for returning small structs, valid values \
are \"default\", \"pcc\" and \"reg\", and the default value is \"default\".",
                                &setlist);
    add_show_from_set (new_cmd, &showlist);
  }

  gdbarch_register_osabi_sniffer (bfd_arch_i386, bfd_target_coff_flavour,
				  i386_coff_osabi_sniffer);
  gdbarch_register_osabi_sniffer (bfd_arch_i386, bfd_target_nlm_flavour,
				  i386_nlm_osabi_sniffer);

  gdbarch_register_osabi (bfd_arch_i386, GDB_OSABI_SVR4,
			  i386_svr4_init_abi);
  gdbarch_register_osabi (bfd_arch_i386, GDB_OSABI_GO32,
			  i386_go32_init_abi);
  gdbarch_register_osabi (bfd_arch_i386, GDB_OSABI_NETWARE,
			  i386_nw_init_abi);
@


1.54.2.2
log
@Merge with trunk.
@
text
@d61 1
a61 1
static int i386_register_offset[I386_SSE_NUM_REGS];
d65 1
a65 1
static int i386_register_size[I386_SSE_NUM_REGS] = {
d81 1
a81 1
const char *
d109 8
d677 2
a678 2
CORE_ADDR
i386_skip_prologue (CORE_ADDR pc)
a759 18
/* Use the program counter to determine the contents and size of a
   breakpoint instruction.  Return a pointer to a string of bytes that
   encode a breakpoint instruction, store the length of the string in
   *LEN and optionally adjust *PC to point to the correct memory
   location for inserting the breakpoint.

   On the i386 we have a single breakpoint that fits in a single byte
   and can be inserted anywhere.  */
   
static const unsigned char *
i386_breakpoint_from_pc (CORE_ADDR *pc, int *len)
{
  static unsigned char break_insn[] = { 0xcc };	/* int 3 */
  
  *len = sizeof (break_insn);
  return break_insn;
}

a779 13
/* The i386 call dummy sequence:

     call 11223344 (32-bit relative)
     int 3

   It is 8 bytes long.  */

static LONGEST i386_call_dummy_words[] =
{
  0x223344e8,
  0xcc11
};

d908 1
a908 1
      if (FP0_REGNUM == 0)
d962 1
a962 1
      if (FP0_REGNUM == 0)
d1343 2
a1344 2
     FIXME: kettenis/20020614: They do include the FPU registers for
     now, which probably is not quite right.  */
a1364 30
  /* NOTE: tm-i386aix.h, tm-i386bsd.h, tm-i386os9k.h, tm-ptx.h,
     tm-symmetry.h currently override this.  Sigh.  */
  set_gdbarch_num_regs (gdbarch, I386_NUM_GREGS + I386_NUM_FREGS);
  
  set_gdbarch_sp_regnum (gdbarch, 4);
  set_gdbarch_fp_regnum (gdbarch, 5);
  set_gdbarch_pc_regnum (gdbarch, 8);
  set_gdbarch_ps_regnum (gdbarch, 9);
  set_gdbarch_fp0_regnum (gdbarch, 16);

  /* Use the "default" register numbering scheme for stabs and COFF.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, i386_stab_reg_to_regnum);
  set_gdbarch_sdb_reg_to_regnum (gdbarch, i386_stab_reg_to_regnum);

  /* Use the DWARF register numbering scheme for DWARF and DWARF 2.  */
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, i386_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, i386_dwarf_reg_to_regnum);

  /* We don't define ECOFF_REG_TO_REGNUM, since ECOFF doesn't seem to
     be in use on any of the supported i386 targets.  */

  set_gdbarch_register_name (gdbarch, i386_register_name);
  set_gdbarch_register_size (gdbarch, 4);
  set_gdbarch_register_bytes (gdbarch, I386_SIZEOF_GREGS + I386_SIZEOF_FREGS);
  set_gdbarch_register_byte (gdbarch, i386_register_byte);
  set_gdbarch_register_raw_size (gdbarch, i386_register_raw_size);
  set_gdbarch_max_register_raw_size (gdbarch, 16);
  set_gdbarch_max_register_virtual_size (gdbarch, 16);
  set_gdbarch_register_virtual_type (gdbarch, i386_register_virtual_type);

a1370 1
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
a1372 1
  set_gdbarch_call_dummy_length (gdbarch, 8);
a1373 3
  set_gdbarch_call_dummy_words (gdbarch, i386_call_dummy_words);
  set_gdbarch_sizeof_call_dummy_words (gdbarch,
				       sizeof (i386_call_dummy_words));
a1374 6
  set_gdbarch_fix_call_dummy (gdbarch, i386_fix_call_dummy);

  set_gdbarch_register_convertible (gdbarch, i386_register_convertible);
  set_gdbarch_register_convert_to_virtual (gdbarch,
					   i386_register_convert_to_virtual);
  set_gdbarch_register_convert_to_raw (gdbarch, i386_register_convert_to_raw);
a1380 14
  /* "An argument's size is increased, if necessary, to make it a
     multiple of [32-bit] words.  This may require tail padding,
     depending on the size of the argument" -- from the x86 ABI.  */
  set_gdbarch_parm_boundary (gdbarch, 32);

  set_gdbarch_deprecated_extract_return_value (gdbarch,
					       i386_extract_return_value);
  set_gdbarch_push_arguments (gdbarch, i386_push_arguments);
  set_gdbarch_push_dummy_frame (gdbarch, i386_push_dummy_frame);
  set_gdbarch_pop_frame (gdbarch, i386_pop_frame);
  set_gdbarch_store_struct_return (gdbarch, i386_store_struct_return);
  set_gdbarch_store_return_value (gdbarch, i386_store_return_value);
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch,
					    i386_extract_struct_value_address);
a1382 10
  set_gdbarch_frame_init_saved_regs (gdbarch, i386_frame_init_saved_regs);
  set_gdbarch_skip_prologue (gdbarch, i386_skip_prologue);

  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);

  set_gdbarch_breakpoint_from_pc (gdbarch, i386_breakpoint_from_pc);
  set_gdbarch_decr_pc_after_break (gdbarch, 1);
  set_gdbarch_function_start_offset (gdbarch, 0);

a1387 3
  set_gdbarch_frame_args_skip (gdbarch, 8);
  set_gdbarch_frameless_function_invocation (gdbarch,
                                           i386_frameless_function_invocation);
a1390 2
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);
a1391 1
  set_gdbarch_frame_num_args (gdbarch, i386_frame_num_args);
d1394 20
d1423 1
a1423 2
  if (strcmp (bfd_get_target (abfd), "coff-go32-exe") == 0
      || strcmp (bfd_get_target (abfd), "coff-go32") == 0)
d1450 1
a1450 1
    for (i = 0; i < I386_SSE_NUM_REGS; i++)
@


1.54.2.3
log
@merge with trunk.
@
text
@a454 32
/* Signal trampolines don't have a meaningful frame.  The frame
   pointer value we use is actually the frame pointer of the calling
   frame -- that is, the frame which was in progress when the signal
   trampoline was entered.  GDB mostly treats this frame pointer value
   as a magic cookie.  We detect the case of a signal trampoline by
   looking at the SIGNAL_HANDLER_CALLER field, which is set based on
   PC_IN_SIGTRAMP.

   When a signal trampoline is invoked from a frameless function, we
   essentially have two frameless functions in a row.  In this case,
   we use the same magic cookie for three frames in a row.  We detect
   this case by seeing whether the next frame has
   SIGNAL_HANDLER_CALLER set, and, if it does, checking whether the
   current frame is actually frameless.  In this case, we need to get
   the PC by looking at the SP register value stored in the signal
   context.

   This should work in most cases except in horrible situations where
   a signal occurs just as we enter a function but before the frame
   has been set up.  */

/* Return non-zero if we're dealing with a frameless signal, that is,
   a signal trampoline invoked from a frameless function.  */

static int
i386_frameless_signal_p (struct frame_info *frame)
{
  return (frame->next
	  && frame->next->signal_handler_caller
	  && frameless_look_for_prologue (frame));
}

d462 1
a462 2
  if (frame->signal_handler_caller
      || i386_frameless_signal_p (frame))
d475 1
a475 1
static int
a483 26
/* Assuming FRAME is for a sigtramp routine, return the saved program
   counter.  */

static CORE_ADDR
i386_sigtramp_saved_pc (struct frame_info *frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  CORE_ADDR addr;

  addr = tdep->sigcontext_addr (frame);
  return read_memory_unsigned_integer (addr + tdep->sc_pc_offset, 4);
}

/* Assuming FRAME is for a sigtramp routine, return the saved stack
   pointer.  */

static CORE_ADDR
i386_sigtramp_saved_sp (struct frame_info *frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  CORE_ADDR addr;

  addr = tdep->sigcontext_addr (frame);
  return read_memory_unsigned_integer (addr + tdep->sc_sp_offset, 4);
}

d490 3
a492 1
    return i386_sigtramp_saved_pc (frame);
d494 2
a495 4
  if (i386_frameless_signal_p (frame))
    {
      CORE_ADDR sp = i386_sigtramp_saved_sp (frame->next);
      return read_memory_unsigned_integer (sp, 4);
a505 3
  if (frame->signal_handler_caller)
    return i386_sigtramp_saved_pc (frame);

d512 1
a512 1
static int
d609 1
a609 1
static void
d669 1
a669 1
static CORE_ADDR
d770 1
a770 1
static void
d806 1
a806 1
static void
d823 1
a823 1
static void
d883 1
a883 1
static CORE_ADDR
d901 1
a901 1
static void
d917 1
a917 1
static void
d968 1
a968 1
static void
d1040 1
a1040 1
static CORE_ADDR
d1083 1
a1083 1
static struct type *
d1104 1
a1104 1
static int
d1113 1
a1113 1
static void
d1136 1
a1136 1
static void
d1247 2
a1248 2
/* Get address of the pushed ucontext (sigcontext) on the stack for
   all three variants of SVR4 sigtramps.  */
d1250 2
a1251 2
static CORE_ADDR
i386_svr4_sigcontext_addr (struct frame_info *frame)
d1253 1
a1253 1
  int sigcontext_offset = -1;
d1260 1
a1260 1
	sigcontext_offset = 132;
d1262 1
a1262 1
	sigcontext_offset = 80;
d1264 1
a1264 1
	sigcontext_offset = 120;
a1266 2
  gdb_assert (sigcontext_offset != -1);

d1268 2
a1269 2
    return frame->next->frame + sigcontext_offset;
  return read_register (SP_REGNUM) + sigcontext_offset;
d1306 1
a1306 3
  tdep->sigcontext_addr = i386_svr4_sigcontext_addr;
  tdep->sc_pc_offset = 14 * 4;
  tdep->sc_sp_offset = 7 * 4;
d1313 1
a1313 1
static void
d1325 1
a1325 1
static void
d1337 1
a1337 1
static struct gdbarch *
d1372 1
a1374 1
  tdep->sigcontext_addr = NULL;
a1375 1
  tdep->sc_sp_offset = -1;
d1382 1
a1382 1

d1391 1
a1391 1

@


1.53
log
@* defs.h (XMALLOC): Define.
* gdb-events.sh (XMALLOC): Delete macro.
* gdb-events.c, gdb-events.h: Regenerate.
* gdbarch.sh (XMALLOC): Delete macro.
* gdbarch.c: Regenerate.
* serial.c (XMALLOC): Delete macro.
* ui-file.c (XMALLOC): Ditto.
* ser-unix.h (XMALLOC): Ditto.
* sh-tdep.c (XMALLOC): Ditto.
* ui-out.c (XMALLOC): Ditto.
* utils.c (XMALLOC): Ditto.
* i386-tdep.c (XMALLOC): Ditto.
* gdb-events.c (XMALLOC): Ditto.
* d10v-tdep.c (XMALLOC): Ditto.
* cli-out.c (XMALLOC): Ditto.

* cli-out.c, d10v-tdep.c, gdb-events.c: Update copyright.
* gdb-events.sh, i386-tdep.c, ser-unix.h, serial.c: Ditto.
* ui-file.c, ui-out.c: Ditto.
@
text
@d1218 21
d1240 1
a1240 1
process_note_abi_tag_sections (bfd *abfd, asection *sect, void *obj)
d1242 1
a1242 1
  int *os_ident_ptr = obj;
d1244 1
a1244 1
  unsigned int sect_size;
d1247 3
a1249 2
  sect_size = bfd_section_size (abfd, sect);
  if (strcmp (name, ".note.ABI-tag") == 0 && sect_size > 0)
d1252 8
a1259 1
      char *note = alloca (sect_size);
d1262 1
a1262 1
                                (file_ptr) 0, (bfd_size_type) sect_size);
d1268 33
a1300 24
      if (name_length == 4 && data_length == 16 && note_type == 1
          && strcmp (note + 12, "GNU") == 0)
        {
          int os_number = bfd_h_get_32 (abfd, note + 16);

          /* The case numbers are from abi-tags in glibc.  */
          switch (os_number)
            {
            case 0:
              *os_ident_ptr = ELFOSABI_LINUX;
              break;
            case 1:
              *os_ident_ptr = ELFOSABI_HURD;
              break;
            case 2:
              *os_ident_ptr = ELFOSABI_SOLARIS;
              break;
            default:
              internal_error (__FILE__, __LINE__,
                              "process_note_abi_sections: "
                              "unknown OS number %d", os_number);
              break;
            }
        }
d1302 105
d1414 2
a1415 1
  int os_ident;
d1417 1
a1417 2
  if (info.abfd != NULL
      && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
d1419 1
a1419 14
      os_ident = elf_elfheader (info.abfd)->e_ident[EI_OSABI];

      /* If os_ident is 0, it is not necessarily the case that we're
         on a SYSV system.  (ELFOSABI_NONE is defined to be 0.)
         GNU/Linux uses a note section to record OS/ABI info, but
         leaves e_ident[EI_OSABI] zero.  So we have to check for note
         sections too.  */
      if (os_ident == ELFOSABI_NONE)
	bfd_map_over_sections (info.abfd,
			       process_note_abi_tag_sections,
			       &os_ident);
	  
      /* If that didn't help us, revert to some non-standard checks.  */
      if (os_ident == ELFOSABI_NONE)
d1421 8
a1428 6
	  /* FreeBSD folks are naughty; they stored the string
	     "FreeBSD" in the padding of the e_ident field of the ELF
	     header.  */
	  if (strcmp (&elf_elfheader (info.abfd)->e_ident[8], "FreeBSD") == 0)
	    os_ident = ELFOSABI_FREEBSD;
        }
a1429 2
  else
    os_ident = -1;
d1431 1
d1436 1
d1438 1
a1438 1
      if (tdep && tdep->os_ident == os_ident)
d1446 1
a1446 1
  tdep->os_ident = os_ident;
d1473 34
@


1.52
log
@	* i386-tdep.c (i386_gdbarch_init): Eliminate incorrect use
        of ``current_gdbarch''.
@
text
@d2 3
a4 3
   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
a41 3

#undef XMALLOC
#define XMALLOC(TYPE) ((TYPE*) xmalloc (sizeof (TYPE)))
@


1.52.2.1
log
@	* i386-tdep.c (get_longjmp_target): Dynamically allocate ``buf''.
@
text
@d861 1
a861 1
  char *buf = alloca (TARGET_PTR_BIT / TARGET_CHAR_BIT);
@


1.51
log
@ 	* i386-tdep.c (get_longjmp_target): Fix compilation failure
 	by setting dummy values to JB_PC and JB_ELEMENT_SIZE
 	if not defined.
@
text
@d1308 3
a1310 3
      if (gdbarch_tdep (current_gdbarch)->os_ident != os_ident)
        continue;
      return arches->gdbarch;
@


1.50
log
@* i386-tdep.h (struct gdbarch_tdep): Add `os_ident' member.
* i386-tdep.c: Include "elf-bfd.h".
(process_note_abi_tag_sections): New function.
(i386_gdbarch_init): Add code to recognize various OS/ABI
combinations.
@
text
@d842 10
@


1.49
log
@* i386-tdep.c (i386_push_dummy_frame): Don't write back the
modified frame pointer until the old frame pointer has been saved.
@
text
@d37 4
a41 1
#include "gdb_assert.h"
d1211 47
d1264 1
d1266 36
a1301 3
  /* For the moment there is only one i386 architecture.  */
  if (arches != NULL)
    return arches->gdbarch;
d1306 2
@


1.48
log
@* config/i386/tm-i386.h (FP7_REGNUM, FIRST_FPU_CTRL_REGNUM,
FCTRL_REGNUM, FPC_REGNUM, FSTAT_REGNUM, FTAG_REGNUM, FCS_REGNUM,
FCOFF_REGNUM, FDS_REGNUM, FDOFF_REGNUM, FOP_REGNUM,
LAST_FPU_CTRL_REGNUM, XMM0_REGNUM, XMM7_REGNUM, MXCSR_REGNUM,
IS_FP_REGNUM, IS_SSE_REGNUM): Removed.
(FP0_REGNUM): Define conditionally depending on HAVE_I387_REGS.
(SIZEOF_FPU_CTRL_REGS): Hardcode value.
* i386-tdep.h (struct gdbarch_tdep): Change such that it contains
a single member `num_xmm_regs'.
(FPC_REGNUM): New macro.
(FIRST_FPU_REGNUM, LAST_FPU_REGNUM, FISRT_XMM_REGNUM,
LAST_XMM_REGNUM, MXCSR_REGNUM, FIRST_FPU_CTRL_REGNUM,
LAST_FPU_CTRL_REGNUM): Removed.
(FCTRL_REGNUM, FSTAT_REGNUM, FTAG_REGNUM, FOP_REGNUM, XMM0_REGNUM,
MXCSR_REGNUM): Define unconditionally.  Change macros to match the
comment describing the register layout.
(FISEG_REGNUM, FIOFF_REGNUM, FOSEG_REGNUM, FOOFF_REGNUM): New macros.
(FP_REGNUM_P, FPC_REGNUM_P, SSE_REGNUM_P): New macros.
(IS_FP_REGNUM, IS_FPU_CTRL_REGNUM, IS_SSE_REGNUM): Make obsolete,
unconditionally define in terms of FP_REGNUM_P, FPC_REGNUM_P and
SSE_REGNUM_P).
(FCS_REGNUM, FCOFF_REGNUM, FDS_REGNUM, FDOFF_REGNUM): Make
obsolete, unconditionally define in terms of FISEG_REGNUM,
FIOFF_REGNUM, FOSEG_REGNUM, FOOFF_REGNUM.
* i386-tdep.c (i386_gdbarch_init): Initialize `num_xmm_regs'
member of `struct gdbarch_tdep'.
* x86-64-tdep.c (i386_gdbarch_init): Change initialization of
`struct gdbarch_tdep'.
* i387-nat.c (FCS_REGNUM, FCOFF_REGNUM, FDS_REGNUM, FDOFF_REGNUM):
Replace with FISEG_REGNUM, FIOFF_REGNUM, FOSEG_REGNUM and
FOOFF_REGNUM.  Use FPC_REGNUM instead of FIRST_FPU_CTRL_REGNUM.
Use XMM0_REGNUM instead of LAST_FPU_CTRL_REGNUM.
@
text
@d772 1
d778 1
a778 1
  write_register (FP_REGNUM, sp);
d785 1
@


1.47
log
@* i386-tdep.c (i386go32_frame_saved_pc): New function.
* config/i386/tm-go32.h (i386go32_frame_saved_pc): Declare.
(FRAME_SAVED_PC): Redefine to i386go32_frame_saved_pc.
@
text
@d1221 4
@


1.46
log
@* i386-tdep.c (i386_gdbarch_init): Initialize num_regs.
* config/i386/tm-i386.h (NUM_REGS): Delete.
@
text
@d511 6
@


1.45
log
@* i386-tdep.c (i386_gdbarch_init): Fix typo.
@
text
@d1232 4
@


1.44
log
@Enable multi-arch for i386.
@
text
@d1204 1
a1204 1
  struct gdbarch_tdep *tdep
@


1.43
log
@Don't update ``set architecture'' when ``set disassembly-flavor[sic]''
@
text
@d37 2
d40 2
a41 1
#include "gdb_assert.h"
d1201 34
d1241 2
@


1.42
log
@* i386-tdep.c (i386_register_offset): Renamed from
i386_register_byte.  Made static.
(i386_register_size): Renamed from i386_register_raw_size.  Made
static.
(i386_register_virtual_size): Removed.
(i386_register_byte, i386_register_raw_size,
i386_register_virtual_size): New functions.
(_initialize_i386_tdep): Initialize i386_register_offset instead
of i386_register_byte.  Remove code to initialize
i386_register_virtual_size.
* config/i386/tm-i386.h (REGISTER_BYTE): Redefine to use
i386_register_byte function.
(REGISTER_RAW_SIZE): Redefine to use i386_register_raw_size
function.
(REGISTER_VIRTUAL_SIZE): Redefine to use
i386_register_virtual_size function.
(i386_register_byte, i386_register_raw_size,
i386_register_virtual_size): New functions.
@
text
@a190 7
/* This is used to keep the bfd arch_info in sync with the disassembly
   flavor.  */
static void set_disassembly_flavor_sfunc (char *, int,
					  struct cmd_list_element *);
static void set_disassembly_flavor (void);


a1195 20
/* If the disassembly mode is intel, we have to also switch the bfd
   mach_type.  This function is run in the set disassembly_flavor
   command, and does that.  */

static void
set_disassembly_flavor_sfunc (char *args, int from_tty,
			      struct cmd_list_element *c)
{
  set_disassembly_flavor ();
}

static void
set_disassembly_flavor (void)
{
  if (disassembly_flavor == att_flavor)
    set_architecture_from_arch_mach (bfd_arch_i386, bfd_mach_i386_i386);
  else if (disassembly_flavor == intel_flavor)
    set_architecture_from_arch_mach (bfd_arch_i386,
				     bfd_mach_i386_i386_intel_syntax);
}
a1230 1
    new_cmd->function.sfunc = set_disassembly_flavor_sfunc;
a1232 4

  /* Finally, initialize the disassembly flavor to the default given
     in the disassembly_flavor variable.  */
  set_disassembly_flavor ();
@


1.41
log
@* config/i386/tm-i386.h (REGISTER_NAMES): Remove.
(REGISTER_NAME): New define.
(i386_register_name): New prototype.
* i386-tdep.c (i386_register_names): New variable.
(i386_register_name): New function.
* config/i386/tm-i386os9k.h, config/i386/tm-ptx.h,
config/i386/tm-symmetry.h: Undefine REGISTER_NAME instead of
REGISTER_NAMES.
@
text
@d57 1
a57 1
/* i386_register_byte[i] is the offset into the register file of the
d59 2
a60 2
   i386_register_raw_size.  */
int i386_register_byte[MAX_NUM_REGS];
d62 3
a64 3
/* i386_register_raw_size[i] is the number of bytes of storage in
   GDB's register array occupied by register i.  */
int i386_register_raw_size[MAX_NUM_REGS] = {
a77 4
/* i386_register_virtual_size[i] is the size in bytes of the virtual
   type of register i.  */
int i386_register_virtual_size[MAX_NUM_REGS];

d91 25
d1239 2
a1240 2
	i386_register_byte[i] = offset;
	offset += i386_register_raw_size[i];
a1241 8
  }

  /* Initialize the table of virtual register sizes.  */
  {
    int i;

    for (i = 0; i < MAX_NUM_REGS; i++)
      i386_register_virtual_size[i] = TYPE_LENGTH (REGISTER_VIRTUAL_TYPE (i));
@


1.40
log
@* i386-tdep.c (i386_extract_return_value): Use
convert_typed_floating to extract floating-point value from
register buffer.
(i386_store_return_value): Use convert_typed_floating to store
floating-point return balue in register buffer
(i386_register_virtual_type): Change type of floating-point
registers to builtin_type_i387_ext.
(i386_register_convert_to_virtual): Use convert_typed_floating to
do the conversion.
(i386_register_convert_to_raw): Likewise.
@
text
@d40 17
d81 13
@


1.39
log
@Add explicit #include of "value.h".
@
text
@d872 6
a877 20
      /* Floating-point return values can be found in %st(0).  */
      if (len == TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT
	  && TARGET_LONG_DOUBLE_FORMAT == &floatformat_i387_ext)
	{
	  /* Copy straight over, but take care of the padding.  */
	  memcpy (valbuf, &regbuf[REGISTER_BYTE (FP0_REGNUM)],
		  FPU_REG_RAW_SIZE);
	  memset (valbuf + FPU_REG_RAW_SIZE, 0, len - FPU_REG_RAW_SIZE);
	}
      else
	{
	  /* Convert the extended floating-point number found in
             %st(0) to the desired type.  This is probably not exactly
             how it would happen on the target itself, but it is the
             best we can do.  */
	  DOUBLEST val;
	  floatformat_to_doublest (&floatformat_i387_ext,
				   &regbuf[REGISTER_BYTE (FP0_REGNUM)], &val);
	  store_floating (valbuf, TYPE_LENGTH (type), val);
	}
d917 1
d929 7
a935 21
      if (len == TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT
	  && TARGET_LONG_DOUBLE_FORMAT == &floatformat_i387_ext)
	{
	  /* Copy straight over.  */
	  write_register_bytes (REGISTER_BYTE (FP0_REGNUM), valbuf,
				FPU_REG_RAW_SIZE);
	}
      else
	{
	  char buf[FPU_REG_RAW_SIZE];
	  DOUBLEST val;

	  /* Convert the value found in VALBUF to the extended
             floating-point format used by the FPU.  This is probably
             not exactly how it would happen on the target itself, but
             it is the best we can do.  */
	  val = extract_floating (valbuf, TYPE_LENGTH (type));
	  floatformat_from_doublest (&floatformat_i387_ext, &val, buf);
	  write_register_bytes (REGISTER_BYTE (FP0_REGNUM), buf,
				FPU_REG_RAW_SIZE);
	}
d993 1
a993 1
    return builtin_type_long_double;
d1020 1
a1020 2
  char buf[12];
  DOUBLEST d;
d1031 3
a1033 8
  /* First add the necessary padding.  */
  memcpy (buf, from, FPU_REG_RAW_SIZE);
  memset (buf + FPU_REG_RAW_SIZE, 0, sizeof buf - FPU_REG_RAW_SIZE);

  /* Convert to TYPE.  This should be a no-op, if TYPE is equivalent
     to the extended floating-point format used by the FPU.  */
  d = extract_floating (buf, sizeof buf);
  store_floating (to, TYPE_LENGTH (type), d);
d1043 10
a1052 2
  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FLT
	      && TYPE_LENGTH (type) == 12);
d1054 3
a1056 2
  /* Simply omit the two unused bytes.  */
  memcpy (to, from, FPU_REG_RAW_SIZE);
@


1.38
log
@* defs.h (HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_LONG_DOUBLE_FORMAT, DOUBLEST)
(floatformat_to_doublest, floatformat_from_doublest)
(floatformat_is_negative, floatformat_is_nan)
(floatformat_mantissa, store_floating)
(extract_floating): Move declaration from here.
* doublest.h: To here.  New file.
* utils.c (get_field, floatformat_to_doublest, put_field)
(ldfrexp, floatformat_from_doublest, floatformat_is_negative)
(floatformat_is_nan, floatformat_mantissa)
(FLOATFORMAT_CHAR_BIT): Move from here.
* doublest.c: To here.  New file.
* findvar.c (store_floating, extract_floating): Move from here.
* doublest.c: To here.
* Makefile.in (SFILES): Add doublest.c.
(COMMON_OBS): Add doublest.o.
(doublest.o): Specify dependencies.
(doublest_h): Define.

* config/m88k/tm-m88k.h: Include "doublest.h".
* config/i960/tm-i960.h: Ditto.
* config/i386/tm-symmetry.h: Ditto.
* rs6000-tdep.c, valarith.c: Ditto.
* valprint.c, stabsread.c, sh-tdep.c: Ditto.
* ia64-tdep.c, i387-tdep.c, i386-tdep.c: Ditto.
* values.c, arm-tdep.c, arm-linux-tdep.c: Ditto.
* alpha-tdep.c, ax.h, expression.h: Ditto.
* sh-tdep.c, parse.c, top.c, value.h: Ditto.

* Makefile.in (arm-tdep.o): Add $(doublest_h).
(i386-tdep.o, i387-tdep.o, ia64-tdep.o): Ditto.
(rs6000-tdep.o, stabsread.o, valarith.o): Ditto.
(values.o, valprint.o, arm-linux-tdep.o): Ditto.
(alpha-tdep.o, ax_h, parse.o, top.o, value_h): Ditto.
(parser_defs_h): Ditto.
(expression_h): Add $(doublest_h) and $(symtab_h).
@
text
@d36 1
@


1.37
log
@* i386-tdep.c (i386_register_convert_to_virtual): Replace
assertion with a warning if we're asked to convert towards a
non-floating-point type.  Zero out the the buffer where the data
is supposed to be stored in that case.
@
text
@d35 1
@


1.36
log
@* config/i386/tm-i386.h (STAB_REG_TO_REGNUM, SDB_REG_TO_REGNUM,
DWARF_REG_TO_REGNUM, DWARF2_REG_TO_REGNUM): New defines.
(i386_stab_reg_to_regnum, i386_dwarf_reg_to_regnum): New
prototypes.
* config/i386/tm-fbsd.h, config/i386/tm-i386gnu.h,
config/i386/tm-linux.h (STAB_REG_TO_REGNUM): Redefine to call
i386_dwarf_reg_to_regnum.
* i386-tdep.c (i386_stab_reg_to_regnum, i386_dwarf_reg_to_regnum):
New functions.
@
text
@d1049 7
a1055 1
  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FLT);
@


1.36.2.1
log
@* i386-tdep.c (i386_register_convert_to_virtual): Replace
assertion with a warning if we're asked to convert towards a
non-floating-point type.  Zero out the the buffer where the data
is supposed to be stored in that case.
@
text
@d1049 1
a1049 7
  if (TYPE_CODE (type) != TYPE_CODE_FLT)
    {
      warning ("Cannot convert floating-point register value "
	       "to non-floating-point type.");
      memset (to, 0, TYPE_LENGTH (type));
      return;
    }
@


1.35
log
@* i386-tdep.c: Include "gdb_assert.h"
(i386_register_convert_to_virtual): Fix such that it can handle
conversion to any floating-point type.  Assert that we are dealing
with a floating-point first.
(i386_register_convert_to_raw): Assert that TYPE is a
floating-point type with length 12.
@
text
@d62 62
@


1.34
log
@s/value_ptr/struct value */
@
text
@d36 2
d977 1
a977 3
   virtual format with type TYPE in buffer TO.  In principle both
   formats are identical except that the virtual format has two extra
   bytes appended that aren't used.  We set these to zero.  */
d983 14
a996 3
  /* Copy straight over, but take care of the padding.  */
  memcpy (to, from, FPU_REG_RAW_SIZE);
  memset (to + FPU_REG_RAW_SIZE, 0, TYPE_LENGTH (type) - FPU_REG_RAW_SIZE);
d1000 1
a1000 2
   raw format for register REGNUM in buffer TO.  Simply omit the two
   unused bytes.  */
d1006 4
@


1.33
log
@* i386-tdep.c (i386_extract_return_value): Undo 2001-07-11 changes
to comment.
(i386_store_return_value): Improve comments about storing
floating-point return values.
@
text
@d672 1
a672 1
		     value_ptr *args, struct type *type, int gcc_p)
d752 1
a752 1
i386_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
@


1.32
log
@* i386-tdep.c (i386_extract_return_value): "Fix" comment.
(i386_store_return_value): Frob FPU status and tag word to make
sure the return value is the only value on the FPU stack.
@
text
@d806 1
a806 2
      /* Floating-point return values can be found in %st(0).
         FIXME: Does %st(0) always correspond to FP0?  */
d872 4
a875 1
      /* Floating-point return values can be found in %st(0).  */
d889 1
a889 1
             floating point format used by the FPU.  This is probably
d898 4
a901 3
      /* Set the top of the floating point register stack to 7.  That
         makes sure that FP0 (which we set above) is indeed %st(0).
         FIXME: Perhaps we should completely reset the status word?  */
d906 3
a908 1
      /* Mark %st(1) through %st(7) as empty.  */
@


1.31
log
@* i386-tdep.c (i386_frame_saved_pc): New function.
* config/i386/tm-i386.h (FRAME_SAVED_PC): Redefine in terms of
i386_frame_saved_pc.
(i386_frame_saved_pc): New prototype.
@
text
@d806 2
a807 1
      /* Floating-point return values can be found in %st(0).  */
d865 2
d895 10
@


1.30
log
@* i386-tdep.c (i386_register_virtual_type): New function.
(i386_register_convertible): New function.
* config/i386/tm-i386.h (REGISTER_VIRTUAL_TYPE): Redefine in terms
of i386_register_virtual_type.
(REGISTER_CONVERTIBLE): Redefine in terms of
i386_register_convertible.
(i386_register_virtual_type, i386_register_convertible): New
prototypes.
@
text
@d381 17
@


1.29
log
@* i386-tdep.c (i386_frameless_function_invocation): New function.
* config/i386/tm-i386.h (FRAMELESS_FUNCTION_INVOCATION): Redefine
in terms of i386_frameless_function_invocation.  Adjust comment.
(i386_frameless_function_invocation): New prototype.
@
text
@d908 31
@


1.28
log
@* i386-tdep.c (i386_saved_pc_after_call): New function.
* config/i386/tm-i386.h (SAVED_PC_AFTER_CALL): Redefine in terms
of i386_saved_pc_after_call.
(i386_saved_pc_after_call): New prototype.
@
text
@d368 13
@


1.27
log
@* i386-tdep.c (i386_frame_chain): New function.
* config/i386/tm-i386.h (FRAME_CHAIN): Redefine in terms of
i386_frame_chain.
(i386_frame_chain): New prototype.
@
text
@d368 8
@


1.26
log
@* i386-tdep.c (i386_extract_return_value): Don't return the return
value of a void function.
(i386_store_return_value): Likewise.
@
text
@d352 16
@


1.25
log
@* i386-tdep.c (i386_extract_struct_value_address): New function.
* config/i386/tm-i386.h (EXTRACT_STRUCT_VALUE_ADDRESS): Redefine
in terms of i386_extract_struct_value_address.
(i386_extract_struct_value_address): New prototype.
@
text
@d738 4
a741 2
    return i386_extract_return_value (TYPE_FIELD_TYPE (type, 0),
				      regbuf, valbuf);
d803 4
a806 1
    return i386_store_return_value (TYPE_FIELD_TYPE (type, 0), valbuf);
@


1.24
log
@* i386-tdep.c (i386_extract_return_value): If the type of the
return value is TYPE_STRUCT and the number of fields is one, call
ourselves with TYPE set tp the type of the first field.
(i386_store_return_value): Likewise.
This fixes a problem with returning structs consisting of a single
`float' or `double' on *BSD.
@
text
@d853 11
@


1.23
log
@* i386-tdep.c (i386_push_arguments, i386_store_struct_return): New
functions.
* config/i386/tm-i386.h (PUSH_ARGUMENTS): New macro.
(STORE_STRUCT_RETURN): Redefine in terms of
i386_store_struct_return.
(i386_push_arguments, i386_store_struct_return): New prototypes.
* config/i386/tm-i386v.h (STORE_STRUCT_RETURN): Remove.  It's
definition was identical to the definition in "i386/tm-i386.h" so
the new definition should suffice too.
@
text
@d736 6
a741 1
  if (TYPE_CODE_FLT == TYPE_CODE (type))
d799 5
a803 1
  if (TYPE_CODE_FLT == TYPE_CODE (type))
@


1.22
log
@* i386-tdep.c: Add back _initialize_i386_tdep prototype with
appropriate comment.
@
text
@d697 24
@


1.21
log
@* i386-tdep.c: Fix formatting.
(i386_get_frame_setup, i386_follow_jump, codestream_read,
codestream_seek, codestream_fill, skip_trampoline_code,
gdb_print_insn_i386, _initialize_i386_tdep): Remove redundant
prototypoes.
@
text
@d962 3
@


1.20
log
@Update/correct copyright notices.
@
text
@a35 16
static long i386_get_frame_setup (CORE_ADDR);

static void i386_follow_jump (void);

static void codestream_read (unsigned char *, int);

static void codestream_seek (CORE_ADDR);

static unsigned char codestream_fill (int);

CORE_ADDR skip_trampoline_code (CORE_ADDR, char *);

static int gdb_print_insn_i386 (bfd_vma, disassemble_info *);

void _initialize_i386_tdep (void);

d60 1
d62 2
a63 3

/* This is the variable the is set with "set disassembly-flavor",
   and its legitimate values. */
d74 2
a75 3
static void i386_print_register (char *, int, int);

/* This is used to keep the bfd arch_info in sync with the disassembly flavor.  */
d79 1
d81 17
a97 16
/* Stdio style buffering was used to minimize calls to ptrace, but this
   buffering did not take into account that the code section being accessed
   may not be an even number of buffers long (even if the buffer is only
   sizeof(int) long).  In cases where the code section size happened to
   be a non-integral number of buffers long, attempting to read the last
   buffer would fail.  Simply using target_read_memory and ignoring errors,
   rather than read_memory, is not the correct solution, since legitimate
   access errors would then be totally ignored.  To properly handle this
   situation and continue to use buffering would require that this code
   be able to determine the minimum code section size granularity (not the
   alignment of the section itself, since the actual failing case that
   pointed out this problem had a section alignment of 4 but was not a
   multiple of 4 bytes long), on a target by target basis, and then
   adjust it's buffer size accordingly.  This is messy, but potentially
   feasible.  It probably needs the bfd library's help and support.  For
   now, the buffer size is set to 1.  (FIXME -fnf) */
d99 1
a99 1
#define CODESTREAM_BUFSIZ 1	/* Was sizeof(int), see note above. */
d107 6
a112 4
#define codestream_peek() (codestream_cnt == 0 ? \
			   codestream_fill(1): codestream_buf[codestream_off])
#define codestream_get() (codestream_cnt-- == 0 ? \
			 codestream_fill(0) : codestream_buf[codestream_off++])
d149 1
d151 1
a151 1
/* next instruction is a jump, move to target */
d174 1
a174 1
      /* relative jump: if data16 == 0, disp32, else disp16 */
d180 2
a181 1
	  /* include size of jmp inst (including the 0x66 prefix).  */
d193 1
a193 1
      /* relative jump, disp8 (ignore data16) */
d204 5
a208 7
/*
 * find & return amound a local space allocated, and advance codestream to
 * first register push (if any)
 *
 * if entry sequence doesn't make sense, return -1, and leave 
 * codestream pointer random
 */
d223 11
a233 14
      /*
       * this function must start with
       * 
       *    popl %eax             0x58
       *    xchgl %eax, (%esp)  0x87 0x04 0x24
       * or xchgl %eax, 0(%esp) 0x87 0x44 0x24 0x00
       *
       * (the system 5 compiler puts out the second xchg
       * inst, and the assembler doesn't try to optimize it,
       * so the 'sib' form gets generated)
       * 
       * this sequence is used to get the address of the return
       * buffer for a function that returns a structure
       */
d236 3
a238 4
      static unsigned char proto1[3] =
      {0x87, 0x04, 0x24};
      static unsigned char proto2[4] =
      {0x87, 0x44, 0x24, 0x00};
d247 1
a247 1
      op = codestream_get ();	/* update next opcode */
d252 11
a262 10
      /*
       * this function may start with
       *
       *   pushl constant
       *   call _probe
       *   addl $4, %esp
       *      followed by 
       *     pushl %ebp
       *     etc.
       */
d266 1
a266 1
      /* Skip past the pushl instruction; it has either a one-byte 
d275 2
a276 2
      /* Read the following 8 bytes, which should be "call _probe" (6 bytes)
         followed by "addl $4,%esp" (2 bytes).  */
d281 1
a281 1
      op = codestream_get ();	/* update next opcode */
d286 1
a286 1
      /* check for movl %esp, %ebp - can be written two ways */
d291 1
a291 1
	    return (-1);
d295 1
a295 1
	    return (-1);
d298 1
a298 1
	  return (-1);
d300 3
a302 1
      /* check for stack adjustment 
d304 2
a305 6
       *  subl $XXX, %esp
       *
       * note: you can't subtract a 16 bit immediate
       * from a 32 bit reg, so we don't have to worry
       * about a data16 prefix 
       */
d309 1
a309 1
	  /* subl with 8 bit immed */
d312 1
a312 1
	    /* Some instruction starting with 0x83 other than subl.  */
d317 2
a318 3
	  /* subl with signed byte immediate 
	   * (though it wouldn't make sense to be negative)
	   */
d324 1
a324 1
	  /* Maybe it is subl with 32 bit immedediate.  */
d327 1
a327 1
	    /* Some instruction starting with 0x81 other than subl.  */
d332 1
a332 1
	  /* It is subl with 32 bit immediate.  */
d338 1
a338 1
	  return (0);
d344 1
a344 1
      /* enter instruction: arg is 16 bit unsigned immed */
d346 1
a346 1
      codestream_get ();	/* flush final byte of enter instruction */
d362 3
a364 3
     args right after the function call, it might be popping args from both
     this call and a previous one, and we would say there are more args
     than there really are.  */
d370 1
a370 1
  /* on the 386, the instruction following the call could be:
d373 1
a373 1
     anything else    -  zero args  */
d379 3
a381 3
    /* In the absence of a frame pointer, GDB doesn't get correct values
       for nameless arguments.  Return -1, so it doesn't print any
       nameless arguments.  */
d387 5
a391 5
      /* Note:  this can happen if we are looking at the frame for
         main, because FRAME_CHAIN_VALID won't let us go into
         start.  If we have debugging symbols, that's not really
         a big deal; it just means it will only show as many arguments
         to main as are declared.  */
d398 1
a398 2
      if (op == 0x59)
	/* pop %ecx */
d409 2
a410 2
      else if (op == 0x81)
	{			/* add with 32 bit immediate */
d426 25
a450 28
/*
 * parse the first few instructions of the function to see
 * what registers were stored.
 *
 * We handle these cases:
 *
 * The startup sequence can be at the start of the function,
 * or the function can start with a branch to startup code at the end.
 *
 * %ebp can be set up with either the 'enter' instruction, or 
 * 'pushl %ebp, movl %esp, %ebp' (enter is too slow to be useful,
 * but was once used in the sys5 compiler)
 *
 * Local space is allocated just below the saved %ebp by either the
 * 'enter' instruction, or by 'subl $<size>, %esp'.  'enter' has
 * a 16 bit unsigned argument for space to allocate, and the
 * 'addl' instruction could have either a signed byte, or
 * 32 bit immediate.
 *
 * Next, the registers used by this function are pushed.  In
 * the sys5 compiler they will always be in the order: %edi, %esi, %ebx
 * (and sometimes a harmless bug causes it to also save but not restore %eax);
 * however, the code below is willing to see the pushes in any order,
 * and will handle up to 8 of them.
 *
 * If the setup sequence is at the end of the function, then the
 * next instruction will be a branch back to the start.
 */
d458 1
a458 1
  CORE_ADDR adr;
d467 2
a468 3
  /* if frame is the end of a dummy, compute where the
   * beginning would be
   */
d471 1
a471 1
  /* check if the PC is in the stack, in a dummy frame */
d474 2
a475 2
      /* all regs were saved by push_call_dummy () */
      adr = fip->frame;
d478 2
a479 2
	  adr -= REGISTER_RAW_SIZE (i);
	  fip->saved_regs[i] = adr;
d490 1
a490 1
      adr = fip->frame - 4 - locals;
d498 1
a498 1
	  fip->saved_regs[I386_REGNO_TO_SYMMETRY (op - 0x50)] = adr;
d500 1
a500 1
	  fip->saved_regs[op - 0x50] = adr;
d502 1
a502 1
	  adr -= 4;
d510 1
a510 1
/* return pc of first real instruction */
d518 2
a519 2
  {0xe8, 0, 0, 0, 0,		/* call   0x0 */
   0x5b,			/* popl   %ebx */
d526 2
a527 3
  /* found valid frame setup - codestream now points to 
   * start of push instructions for saving registers
   */
d529 1
a529 1
  /* skip over register saves */
d533 1
a533 1
      /* break if not pushl inst */
d539 9
a547 6
  /* The native cc on SVR4 in -K PIC mode inserts the following code to get
     the address of the global offset table (GOT) into register %ebx.
     call       0x0
     popl       %ebx
     movl       %ebx,x(%ebp)    (optional)
     addl       y,%ebx
d568 1
a568 1
	  if (op == 0x5d)	/* one byte offset from %ebp */
d573 1
a573 1
	  else if (op == 0x9d)	/* four byte offset from %ebp */
d578 1
a578 1
	  else			/* unexpected instruction */
d646 3
a648 3
      CORE_ADDR adr;
      adr = frame->saved_regs[regnum];
      if (adr)
d650 1
a650 1
	  read_memory (adr, regbuf, REGISTER_RAW_SIZE (regnum));
d660 1
d664 5
a668 4
/* Figure out where the longjmp will land.  Slurp the args out of the stack.
   We expect the first arg to be a pointer to the jmp_buf structure from which
   we extract the pc (JB_PC) that we will land at.  The pc is copied into PC.
   This routine returns true on success. */
d678 1
a678 1
  if (target_read_memory (sp + SP_ARG0,		/* Offset of first arg on stack */
d695 1
d820 1
d846 1
a847 1
     
d849 2
a850 2
/* Get saved user PC for sigtramp from the pushed ucontext on the stack
   for all three variants of SVR4 sigtramps.  */
d874 1
a874 1

d877 2
a878 2
/* SunPRO encodes the static variables.  This is not related to C++ mangling,
   it is done for C too.  */
d886 2
a887 2
      /* For file-local statics there will be a period, a bunch
         of junk (the contents of which match a string given in the
d900 1
d902 1
a902 3


/* Stuff for WIN32 PE style DLL's but is pretty generic really. */
d907 1
a907 1
  if (pc && read_memory_unsigned_integer (pc, 2) == 0x25ff)	/* jmp *(dest) */
d911 1
a911 1
      indirect ? lookup_minimal_symbol_by_pc (indirect) : 0;
d921 1
a921 1
  return 0;			/* not a trampoline */
d923 4
d935 2
a936 2
  /* Never reached - disassembly_flavour is always either att_flavor
     or intel_flavor */
d940 2
a941 2
/* If the disassembly mode is intel, we have to also switch the
   bfd mach_type.  This function is run in the set disassembly_flavor
d957 2
a958 1
    set_architecture_from_arch_mach (bfd_arch_i386, bfd_mach_i386_i386_intel_syntax);
d960 1
a960 1

d989 1
a989 1
  /* Add the variable that controls the disassembly flavor */
d996 2
a997 1
				"Set the disassembly flavor, the valid values are \"att\" and \"intel\", \
d1005 1
a1005 2
     in the disassembly_flavor variable */

@


1.19
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright (C) 1988, 1989, 1991, 1994, 1995, 1996, 1998, 2001
@


1.18
log
@Replace calls to abort() with calls to internal_error().
@
text
@d33 1
@


1.17
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d950 1
a950 1
  abort ();
@


1.16
log
@* i386-tdep.c: Add missing ')' in comment.
(i386_extract_return_value): Return directly after issuing the
warning and filling *VALBUF with zeroes if we cannot get at the
floating-point registers.
(i386_store_return_value): New function.
* config/i386/tm-i386.h (STORE_RETURN_VALUE): Simply call
i386_store_return_value.
Add prototype for i386_store_return_value.
@
text
@d2 1
a2 1
   Copyright (C) 1988, 1989, 1991, 1994, 1995, 1996, 1998
d774 2
a775 1
	internal_error ("Cannot extract return value of %d bytes long.", len);
d833 2
a834 1
	internal_error ("Cannot store return value of %d bytes long.", len);
@


1.15
log
@Protoization.
@
text
@d716 1
a716 1
   size and alignment match an integer type.  */
d735 1
d775 58
@


1.14
log
@* config/i386/tm-i386.h: Add forward declaration of `struct value'.
(FIX_CALL_DUMMY): Redefined to call i386_fix_call_dummy.
(i386_fix_call_dummy): Add prototype.
* i386-tdep.c (i386_fix_call_dummy): New function based on the
code from the old FIX_CALL_DUMMY macro.
@
text
@d126 1
a126 2
codestream_fill (peek_flag)
     int peek_flag;
d141 1
a141 2
codestream_seek (place)
     CORE_ADDR place;
d152 1
a152 3
codestream_read (buf, count)
     unsigned char *buf;
     int count;
d164 1
a164 1
i386_follow_jump ()
d222 1
a222 2
i386_get_frame_setup (pc)
     CORE_ADDR pc;
d373 1
a373 2
i386_frame_num_args (fi)
     struct frame_info *fi;
d474 1
a474 2
i386_frame_init_saved_regs (fip)
     struct frame_info *fip;
d535 1
a535 2
i386_skip_prologue (pc)
     int pc;
d616 1
a616 1
i386_push_dummy_frame ()
d654 1
a654 1
i386_pop_frame ()
d689 1
a689 2
get_longjmp_target (pc)
     CORE_ADDR *pc;
d808 1
a808 2
i386v4_sigtramp_saved_pc (frame)
     struct frame_info *frame;
d836 1
a836 2
sunpro_static_transform_name (name)
     char *name;
d861 1
a861 3
skip_trampoline_code (pc, name)
     CORE_ADDR pc;
     char *name;
d881 1
a881 3
gdb_print_insn_i386 (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
d897 2
a898 4
set_disassembly_flavor_sfunc (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
d904 1
a904 1
set_disassembly_flavor ()
d914 1
a914 1
_initialize_i386_tdep ()
@


1.13
log
@Change signature of function add_set_enum_cmd() so that it uses
constant character pointers.  Update everything.
As a consequence fix infrun's follow-fork plugging a small memory leak.
@
text
@d641 20
@


1.12
log
@The attatched moves the remaining guff from gdbarch.{h,c,sh} to
arch-utils.{h,c}.  The ``set architecutre'' and ``set endian''
commands (part of the move) were implemented to use add_set_enum_cmd()
so that ``set architecture <tab>'' works.
@
text
@d78 3
a80 3
static char att_flavor[] = "att";
static char intel_flavor[] = "intel";
static char *valid_flavors[] =
d86 1
a86 1
static char *disassembly_flavor = att_flavor;
@


1.11
log
@PARAMS removal.
@
text
@d32 1
@


1.10
log
@Fix signature of add_set_enum_cmd.  Change VAR parameter to char**.
Cleanup signature of add_set_cmd.  Change VAR parameter to void*.
@
text
@d33 1
a33 1
static long i386_get_frame_setup PARAMS ((CORE_ADDR));
d35 1
a35 1
static void i386_follow_jump PARAMS ((void));
d37 1
a37 1
static void codestream_read PARAMS ((unsigned char *, int));
d39 1
a39 1
static void codestream_seek PARAMS ((CORE_ADDR));
d41 1
a41 1
static unsigned char codestream_fill PARAMS ((int));
d43 1
a43 1
CORE_ADDR skip_trampoline_code PARAMS ((CORE_ADDR, char *));
d47 1
a47 1
void _initialize_i386_tdep PARAMS ((void));
d87 1
a87 1
static void i386_print_register PARAMS ((char *, int, int));
d90 3
a92 2
static void set_disassembly_flavor_sfunc PARAMS ((char *, int, struct cmd_list_element *));
static void set_disassembly_flavor PARAMS ((void));
@


1.9
log
@2000-03-26  Mark Kettenis  <kettenis@@gnu.org>

	Provide `long double' support for most i386 targets.
	* config/i386/tm-i386.h (TARGET_LONG_DOUBLE_FORMAT): Define as
	&floatformat_i387_ext.
	(TARGET_LONG_DOUBLE_BITS): Define as 96.
	(REGISTER_VIRTUAL_TYPE): Change type for FPU registers to
	`builtin_type_long_double'.
	(REGISTER_CONVERT_TO_VIRTUAL): Call
	i386_register_convert_to_virtual.
	(REGISTER_CONVERT_TO_RAW): Call i386_register_convert_to_raw.
	(i387_to_double, double_to_i387): Remove prototypes.
	(i386_extract_return_value): Change prototype to match definition
	in i386-tdep.c.
	* config/i386/tm-i386mk.h (TARGET_LONG_DOUBLE_FORMAT): #undef.
	(TARGET_LONG_DOUBLE_BITS): #undef.
	* config/i386/tm-linux.h (TARGET_LONG_DOUBLE_BIT): Remove.
	[HAVE_LONG_DOUBLE && HOST_I386] (LD_I387): Remove.
	(i387_extract_floating, i387_store_floating): Remove prototypes.
	(TARGET_EXTRACT_FLOATING, TARGET_STORE_FLOATING): Remove.
	(REGISTER_CONVERT_TO_VIRTUAL, REGOISTER_CONVERT_TO_RAW): Remove.
	(REGISTER_VIRTUAL_TYPE): Remove.
	* i386-tdep.c (i386_register_convert_to_virtual): New function.
	(i386_register_convert_to_raw): New function.
	* i387-tdep.c [LD_I387] (i387_extract_floating): Remove.
	(i387_store_floating): Remove.
@
text
@d941 1
a941 1
				(char *) &disassembly_flavor,
@


1.8
log
@2000-03-22  Mark Kettenis  <kettenis@@gnu.org>

	* config/i386/tm-i386aix.h (I386_AIX_TARGET): Remove.
	* config/i386/tm-linux.h (LOW_RETURN_REGNUM, HIGH_RETURN_REGNUM):
	Remove
	* i386-tdep.c (LOW_RETURN_REGNUM, HIGH_RETURN_REGNUM): New defines.
	(i386_extract_return_value): Rewritten.  Correctly support all
	floating-point types and large integer types on targets that use
	the standard i386 GDB register layout and return floating-point
	values in the FPU.
@
text
@d764 26
@


1.7
log
@* i386-tdep.c (LINUX_SIGTRAMP_INSN0, LINUX_SIGTRAMP_OFFSET0,
LINUX_SIGTRAMP_INSN1, LINUX_SIGTRAMP_OFFSET1,
LINUX_SIGTRAMP_INSN2, LINUX_SIGTRAMP_OFFSET2, linux_sigtramp_code,
LINUX_SIGTRAMP_LEN, i386_linux_sigtramp_start,
LINUX_RT_SIGTRAMP_INSN0, LINUX_RT_SIGTRAMP_OFFSET0,
LINUX_RT_SIGTRAMP_INSN1, LINUX_RT_SIGTRAMP_OFFSET1,
linux_rt_sigtramp_code, LINUX_RT_SIGTRAMP_LEN,
i386_linux_rt_sigtramp_start, i386_linux_in_sigtramp,
i386_linux_sigcontext_addr, LINUX_SIGCONTEXT_PC_OFFSET,
i386_linux_sigtramp_saved_pc, LINUX_SIGCONTEXT_SP_OFFSET,
i386_linux_sigtramp_saved_sp): Deleted.  These all implement
Linux-specific signal trampoline detection, and should be moved to...
* i386-linux-nat.c: ... here.
* config/i386/tm-linux.h (I386_LINUX_SIGTRAMP): No need to define
this any more, since we're not enabling OS-specific code in a
OS-independent file.
@
text
@d701 10
d712 1
a712 4
i386_extract_return_value (type, regbuf, valbuf)
     struct type *type;
     char regbuf[REGISTER_BYTES];
     char *valbuf;
d714 2
a715 6
  /* On AIX, i386 GNU/Linux and DJGPP, floating point values are
     returned in floating point registers.  */
  /* FIXME: cagney/2000-02-29: This function needs to be rewritten
     using multi-arch. Please don't keep adding to this #ifdef
     spaghetti. */
#if defined(I386_AIX_TARGET) || defined(I386_GNULINUX_TARGET) || defined(I386_DJGPP_TARGET)
d718 5
a722 8
      double d;
      /* 387 %st(0), gcc uses this */
      floatformat_to_double (&floatformat_i387_ext,
#if defined(FPDATA_REGNUM)
			     &regbuf[REGISTER_BYTE (FPDATA_REGNUM)],
#else /* !FPDATA_REGNUM */
			     &regbuf[REGISTER_BYTE (FP0_REGNUM)],
#endif /* FPDATA_REGNUM */
d724 20
a743 2
			     &d);
      store_floating (valbuf, TYPE_LENGTH (type), d);
a745 1
#endif /* I386_AIX_TARGET || I386_GNULINUX_TARGET || I386_DJGPP_TARGET */
a746 2
#if defined(LOW_RETURN_REGNUM)
      int len = TYPE_LENGTH (type);
d751 1
a751 1
	memcpy (valbuf, regbuf + REGISTER_BYTE (LOW_RETURN_REGNUM), len);
d755 1
a755 2
		  regbuf + REGISTER_BYTE (LOW_RETURN_REGNUM),
		  low_size);
d757 1
a757 2
		  regbuf + REGISTER_BYTE (HIGH_RETURN_REGNUM),
		  len - low_size);
d760 1
a760 4
	error ("GDB bug: i386-tdep.c (i386_extract_return_value): Don't know how to find a return value %d bytes long", len);
#else /* !LOW_RETURN_REGNUM */
      memcpy (valbuf, regbuf, TYPE_LENGTH (type));
#endif /* LOW_RETURN_REGNUM */
@


1.6
log
@2000-03-08  Mark Kettenis  <kettenis@@gnu.org>

	* i386-tdep.c (i386_linux_saved_pc_after_call): New function.
	* config/i386/tm-linux.h (SAVED_PC_AFTER_CALL): Define to call
	i386_linux_saved_pc_after_call.
@
text
@a781 257
#ifdef I386_LINUX_SIGTRAMP

/* Linux has two flavors of signals.  Normal signal handlers, and
   "realtime" (RT) signals.  The RT signals can provide additional
   information to the signal handler if the SA_SIGINFO flag is set
   when establishing a signal handler using `sigaction'.  It is not
   unlikely that future versions of Linux will support SA_SIGINFO for
   normal signals too.  */

/* When the i386 Linux kernel calls a signal handler and the
   SA_RESTORER flag isn't set, the return address points to a bit of
   code on the stack.  This function returns whether the PC appears to
   be within this bit of code.

   The instruction sequence for normal signals is
       pop    %eax
       mov    $0x77,%eax
       int    $0x80
   or 0x58 0xb8 0x77 0x00 0x00 0x00 0xcd 0x80.

   Checking for the code sequence should be somewhat reliable, because
   the effect is to call the system call sigreturn.  This is unlikely
   to occur anywhere other than a signal trampoline.

   It kind of sucks that we have to read memory from the process in
   order to identify a signal trampoline, but there doesn't seem to be
   any other way.  The IN_SIGTRAMP macro in tm-linux.h arranges to
   only call us if no function name could be identified, which should
   be the case since the code is on the stack.

   Detection of signal trampolines for handlers that set the
   SA_RESTORER flag is in general not possible.  Unfortunately this is
   what the GNU C Library has been doing for quite some time now.
   However, as of version 2.1.2, the GNU C Library uses signal
   trampolines (named __restore and __restore_rt) that are identical
   to the ones used by the kernel.  Therefore, these trampolines are
   supported too.  */

#define LINUX_SIGTRAMP_INSN0 (0x58)	/* pop %eax */
#define LINUX_SIGTRAMP_OFFSET0 (0)
#define LINUX_SIGTRAMP_INSN1 (0xb8)	/* mov $NNNN,%eax */
#define LINUX_SIGTRAMP_OFFSET1 (1)
#define LINUX_SIGTRAMP_INSN2 (0xcd)	/* int */
#define LINUX_SIGTRAMP_OFFSET2 (6)

static const unsigned char linux_sigtramp_code[] =
{
  LINUX_SIGTRAMP_INSN0,					/* pop %eax */
  LINUX_SIGTRAMP_INSN1, 0x77, 0x00, 0x00, 0x00,		/* mov $0x77,%eax */
  LINUX_SIGTRAMP_INSN2, 0x80				/* int $0x80 */
};

#define LINUX_SIGTRAMP_LEN (sizeof linux_sigtramp_code)

/* If PC is in a sigtramp routine, return the address of the start of
   the routine.  Otherwise, return 0.  */

static CORE_ADDR
i386_linux_sigtramp_start (CORE_ADDR pc)
{
  unsigned char buf[LINUX_SIGTRAMP_LEN];

  /* We only recognize a signal trampoline if PC is at the start of
     one of the three instructions.  We optimize for finding the PC at
     the start, as will be the case when the trampoline is not the
     first frame on the stack.  We assume that in the case where the
     PC is not at the start of the instruction sequence, there will be
     a few trailing readable bytes on the stack.  */

  if (read_memory_nobpt (pc, (char *) buf, LINUX_SIGTRAMP_LEN) != 0)
    return 0;

  if (buf[0] != LINUX_SIGTRAMP_INSN0)
    {
      int adjust;

      switch (buf[0])
	{
	case LINUX_SIGTRAMP_INSN1:
	  adjust = LINUX_SIGTRAMP_OFFSET1;
	  break;
	case LINUX_SIGTRAMP_INSN2:
	  adjust = LINUX_SIGTRAMP_OFFSET2;
	  break;
	default:
	  return 0;
	}

      pc -= adjust;

      if (read_memory_nobpt (pc, (char *) buf, LINUX_SIGTRAMP_LEN) != 0)
	return 0;
    }

  if (memcmp (buf, linux_sigtramp_code, LINUX_SIGTRAMP_LEN) != 0)
    return 0;

  return pc;
}

/* This function does the same for RT signals.  Here the instruction
   sequence is
       mov    $0xad,%eax
       int    $0x80
   or 0xb8 0xad 0x00 0x00 0x00 0xcd 0x80.

   The effect is to call the system call rt_sigreturn.  */

#define LINUX_RT_SIGTRAMP_INSN0 (0xb8)	/* mov $NNNN,%eax */
#define LINUX_RT_SIGTRAMP_OFFSET0 (0)
#define LINUX_RT_SIGTRAMP_INSN1 (0xcd)	/* int */
#define LINUX_RT_SIGTRAMP_OFFSET1 (5)

static const unsigned char linux_rt_sigtramp_code[] =
{
  LINUX_RT_SIGTRAMP_INSN0, 0xad, 0x00, 0x00, 0x00,	/* mov $0xad,%eax */
  LINUX_RT_SIGTRAMP_INSN1, 0x80				/* int $0x80 */
};

#define LINUX_RT_SIGTRAMP_LEN (sizeof linux_rt_sigtramp_code)

/* If PC is in a RT sigtramp routine, return the address of the start
   of the routine.  Otherwise, return 0.  */

static CORE_ADDR
i386_linux_rt_sigtramp_start (CORE_ADDR pc)
{
  unsigned char buf[LINUX_RT_SIGTRAMP_LEN];

  /* We only recognize a signal trampoline if PC is at the start of
     one of the two instructions.  We optimize for finding the PC at
     the start, as will be the case when the trampoline is not the
     first frame on the stack.  We assume that in the case where the
     PC is not at the start of the instruction sequence, there will be
     a few trailing readable bytes on the stack.  */

  if (read_memory_nobpt (pc, (char *) buf, LINUX_RT_SIGTRAMP_LEN) != 0)
    return 0;

  if (buf[0] != LINUX_RT_SIGTRAMP_INSN0)
    {
      if (buf[0] != LINUX_RT_SIGTRAMP_INSN1)
	return 0;

      pc -= LINUX_RT_SIGTRAMP_OFFSET1;

      if (read_memory_nobpt (pc, (char *) buf, LINUX_RT_SIGTRAMP_LEN) != 0)
	return 0;
    }

  if (memcmp (buf, linux_rt_sigtramp_code, LINUX_RT_SIGTRAMP_LEN) != 0)
    return 0;

  return pc;
}

/* Return whether PC is in a Linux sigtramp routine.  */

int
i386_linux_in_sigtramp (CORE_ADDR pc, char *name)
{
  if (name)
    return STREQ ("__restore", name) || STREQ ("__restore_rt", name);
  
  return (i386_linux_sigtramp_start (pc) != 0
	  || i386_linux_rt_sigtramp_start (pc) != 0);
}

/* Assuming FRAME is for a Linux sigtramp routine, return the address
   of the associated sigcontext structure.  */

CORE_ADDR
i386_linux_sigcontext_addr (struct frame_info *frame)
{
  CORE_ADDR pc;

  pc = i386_linux_sigtramp_start (frame->pc);
  if (pc)
    {
      CORE_ADDR sp;

      if (frame->next)
	/* If this isn't the top frame, the next frame must be for the
	   signal handler itself.  The sigcontext structure lives on
	   the stack, right after the signum argument.  */
	return frame->next->frame + 12;

      /* This is the top frame.  We'll have to find the address of the
	 sigcontext structure by looking at the stack pointer.  Keep
	 in mind that the first instruction of the sigtramp code is
	 "pop %eax".  If the PC is at this instruction, adjust the
	 returned value accordingly.  */
      sp = read_register (SP_REGNUM);
      if (pc == frame->pc)
	return sp + 4;
      return sp;
    }

  pc = i386_linux_rt_sigtramp_start (frame->pc);
  if (pc)
    {
      if (frame->next)
	/* If this isn't the top frame, the next frame must be for the
	   signal handler itself.  The sigcontext structure is part of
	   the user context.  A pointer to the user context is passed
	   as the third argument to the signal handler.  */
	return read_memory_integer (frame->next->frame + 16, 4) + 20;

      /* This is the top frame.  Again, use the stack pointer to find
	 the address of the sigcontext structure.  */
      return read_memory_integer (read_register (SP_REGNUM) + 8, 4) + 20;
    }

  error ("Couldn't recognize signal trampoline.");
  return 0;
}

/* Offset to saved PC in sigcontext, from <asm/sigcontext.h>.  */
#define LINUX_SIGCONTEXT_PC_OFFSET (56)

/* Assuming FRAME is for a Linux sigtramp routine, return the saved
   program counter.  */

CORE_ADDR
i386_linux_sigtramp_saved_pc (struct frame_info *frame)
{
  CORE_ADDR addr;
  addr = i386_linux_sigcontext_addr (frame);
  return read_memory_integer (addr + LINUX_SIGCONTEXT_PC_OFFSET, 4);
}

/* Offset to saved SP in sigcontext, from <asm/sigcontext.h>.  */
#define LINUX_SIGCONTEXT_SP_OFFSET (28)

/* Assuming FRAME is for a Linux sigtramp routine, return the saved
   stack pointer.  */

CORE_ADDR
i386_linux_sigtramp_saved_sp (struct frame_info *frame)
{
  CORE_ADDR addr;
  addr = i386_linux_sigcontext_addr (frame);
  return read_memory_integer (addr + LINUX_SIGCONTEXT_SP_OFFSET, 4);
}

/* Immediately after a function call, return the saved pc.  */

CORE_ADDR
i386_linux_saved_pc_after_call (struct frame_info *frame)
{
  if (frame->signal_handler_caller)
    return i386_linux_sigtramp_saved_pc (frame);

  return read_memory_integer (read_register (SP_REGNUM), 4);
}

#endif /* I386_LINUX_SIGTRAMP */
@


1.5
log
@2000-03-04  Mark Kettenis  <kettenis@@gnu.org>

	Fix support for Linux/i386 signal trampolines.  The old approach
	didn't work for Linux 2.2 and beyond, and didn't work with recent
	versions of the GNU C library.
	* i386-tdep.c (LINUX_RT_SIGTRAMP_INSN0, LINUX_RT_SIGTRAMP_OFFSET0,
	LINUX_RT_SIGTRAMP_INSN1, LINUX_RT_SIGTRAMP_OFFSET1): New defines.
	(linux_rt_sigtramp_code): New variable.
	(LINUX_RT_SIGTRAMP_LEN): New define.
	(i386_linux_rt_sigtramp_start): New function.  Detect start of
	signal trampolines for RT signals.
	(i386_linux_sigtramp): Removed.
	(i386_linux_in_sigtramp): New function.
	(i386_linux_sigcontext_addr): New function.  Recognize the names
	of the signal tranmpolines used by recent versions of the GNU C
	library, and add support for RT signals.
        (LINUX_SIGCONTEXT_PC_OFFSET, LINUX_SIGCONTEXT_SP_OFFSET):  New
	defines.  Moved here from config/i386/tm-linux.h.
	(i386_linux_sigtramp_saved_pc, i386_linux_sigtramp_saved_sp):
	Reimplement in terms of i386_linux_sigcontext_addr.
	* config/i386/tm-linux.h (LINUX_SIGCONTEXT_SIZE): Removed.
        (LINUX_SIGCONTEXT_PC_OFFSET, LINUX_SIGCONTEXT_SP_OFFSET):
        Moved to i386-tdep.c.
	(IN_SIGTRAMP): Redefine to call i386_linux_in_sigtramp.
@
text
@d1027 11
@


1.4
log
@From J.T.: Convert i386 to updated frame_saved_regs.
@
text
@d784 11
a794 3
/* When the i386 Linux kernel calls a signal handler, the return
   address points to a bit of code on the stack.  This function
   returns whether the PC appears to be within this bit of code.
d796 1
a796 1
   The instruction sequence is
d810 9
a818 1
   be the case since the code is on the stack.  */
d840 1
a840 2
i386_linux_sigtramp_start (pc)
     CORE_ADDR pc;
d882 56
d941 1
a941 2
i386_linux_sigtramp (pc)
     CORE_ADDR pc;
d943 5
a947 1
  return i386_linux_sigtramp_start (pc) != 0;
d950 2
a951 3
/* Assuming FRAME is for a Linux sigtramp routine, return the saved
   program counter.  The Linux kernel will set up a sigcontext
   structure immediately before the sigtramp routine on the stack.  */
d954 1
a954 2
i386_linux_sigtramp_saved_pc (frame)
     struct frame_info *frame;
d959 38
a996 6
  if (pc == 0)
    error ("i386_linux_sigtramp_saved_pc called when no sigtramp");
  return read_memory_integer ((pc
			       - LINUX_SIGCONTEXT_SIZE
			       + LINUX_SIGCONTEXT_PC_OFFSET),
			      4);
d999 3
d1003 1
a1003 2
   stack pointer.  The Linux kernel will set up a sigcontext structure
   immediately before the sigtramp routine on the stack.  */
d1006 1
a1006 2
i386_linux_sigtramp_saved_sp (frame)
     struct frame_info *frame;
d1008 10
a1017 1
  CORE_ADDR pc;
d1019 6
a1024 7
  pc = i386_linux_sigtramp_start (frame->pc);
  if (pc == 0)
    error ("i386_linux_sigtramp_saved_sp called when no sigtramp");
  return read_memory_integer ((pc
			       - LINUX_SIGCONTEXT_SIZE
			       + LINUX_SIGCONTEXT_SP_OFFSET),
			      4);
@


1.3
log
@From Eli.  Bring go32 target up-to-date with recent GDB i386 changes.
@
text
@d478 1
a478 1
i386_frame_find_saved_regs (fip, fsrp)
a479 1
     struct frame_saved_regs *fsrp;
d488 4
a491 1
  memset (fsrp, 0, sizeof *fsrp);
d506 1
a506 1
	  fsrp->regs[i] = adr;
d525 1
a525 1
	  fsrp->regs[I386_REGNO_TO_SYMMETRY (op - 0x50)] = adr;
d527 1
a527 1
	  fsrp->regs[op - 0x50] = adr;
d533 2
a534 2
  fsrp->regs[PC_REGNUM] = fip->frame + 4;
  fsrp->regs[FP_REGNUM] = fip->frame;
a644 1
  struct frame_saved_regs fsr;
d648 2
a649 1
  get_frame_saved_regs (frame, &fsr);
d653 1
a653 1
      adr = fsr.regs[regnum];
@


1.2
log
@Doc fix.
@
text
@d705 6
a710 3
  /* On AIX and i386 GNU/Linux, floating point values are returned in
     floating point registers.  */
#if defined(I386_AIX_TARGET) || defined(I386_GNULINUX_TARGET)
d726 1
a726 1
#endif /* I386_AIX_TARGET || I386_GNULINUX_TARGET*/
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d49 26
d76 1
a76 1
 and its legitimate values. */
d79 2
a80 1
static char *valid_flavors[] = {
d87 6
d123 1
a123 1
static unsigned char 
d125 1
a125 1
    int peek_flag;
d132 1
a132 1
  
d134 1
a134 1
    return (codestream_peek());
d136 1
a136 1
    return (codestream_get());
d141 1
a141 1
    CORE_ADDR place;
d147 1
a147 1
  while (codestream_tell() != place)
d193 1
a193 1
	  pos += delta + 4; 
d240 1
a240 1
       *    popl %eax		  0x58
d253 4
a256 2
      static unsigned char proto1[3] = { 0x87,0x04,0x24 };
      static unsigned char proto2[4] = { 0x87,0x44,0x24,0x00 };
d265 1
a265 1
      op = codestream_get (); /* update next opcode */
d298 1
a298 1
      op = codestream_get (); /* update next opcode */
d302 1
a302 1
    {			
d318 1
a318 1
       *
d339 1
a339 1
	  return (codestream_get());
d345 1
a345 1
	  codestream_get();
d353 1
a353 1
	  codestream_read ((unsigned char *)buf, 4);
d365 2
a366 2
      codestream_read ((unsigned char *)buf, 2);
      codestream_get (); /* flush final byte of enter instruction */
d387 2
a388 2
  int retpc;						
  unsigned char op;					
d398 1
a398 1
  FRAMELESS_FUNCTION_INVOCATION (fi, frameless);
d405 1
a405 1
  pfi = get_prev_frame_info (fi);			
d409 4
a412 4
	 main, because FRAME_CHAIN_VALID won't let us go into
	 start.  If we have debugging symbols, that's not really
	 a big deal; it just means it will only show as many arguments
	 to main as are declared.  */
d417 5
a421 5
      retpc = pfi->pc;					
      op = read_memory_integer (retpc, 1);			
      if (op == 0x59)					
	/* pop %ecx */			       
	return 1;				
d424 4
a427 4
	  op = read_memory_integer (retpc+1, 1);	
	  if (op == 0xc4)				
	    /* addl $<signed imm 8 bits>, %esp */	
	    return (read_memory_integer (retpc+2,1)&0xff)/4;
d432 5
a436 5
	{ /* add with 32 bit immediate */
	  op = read_memory_integer (retpc+1, 1);	
	  if (op == 0xc4)				
	    /* addl $<imm 32>, %esp */		
	    return read_memory_integer (retpc+2, 4) / 4;
d488 1
a488 1
  
d490 1
a490 1
  
d495 1
a495 1
  
d497 1
a497 1
  if (dummy_bottom <= fip->pc && fip->pc <= fip->frame) 
d501 1
a501 1
      for (i = 0; i < NUM_REGS; i++) 
d508 1
a508 1
  
d512 2
a513 2
  
  if (locals >= 0) 
d516 1
a516 1
      for (i = 0; i < 8; i++) 
d523 1
a523 1
	  fsrp->regs[I386_REGNO_TO_SYMMETRY(op - 0x50)] = adr;
d530 1
a530 1
  
d543 4
a546 3
  static unsigned char pic_pat[6] = { 0xe8, 0, 0, 0, 0, /* call   0x0 */
				      0x5b,             /* popl   %ebx */
				    };
d548 1
a548 1
  
d551 1
a551 1
  
d555 1
a555 1
  
d561 1
a561 1
      if (op < 0x50 || op > 0x57) 
d568 4
a571 4
      call	0x0
      popl	%ebx
      movl	%ebx,x(%ebp)	(optional)
      addl	y,%ebx
d575 1
a575 1
     
d580 1
a580 1
      if (pic_pat [i] != op)
d589 1
a589 1
      if (op == 0x89)			/* movl %ebx, x(%ebp) */
d592 1
a592 1
	  if (op == 0x5d)		/* one byte offset from %ebp */
d597 1
a597 1
	  else if (op == 0x9d)		/* four byte offset from %ebp */
d602 3
a604 3
	  else				/* unexpected instruction */
	      delta = -1;
          op = codestream_get ();
d606 2
a607 2
					/* addl y,%ebx */
      if (delta > 0 && op == 0x81 && codestream_get () == 0xc3) 
d609 1
a609 1
	    pos += delta + 6;
d613 1
a613 1
  
d615 1
a615 1
  
d625 1
a625 1
  
d645 1
a645 1
  
d648 1
a648 1
  for (regnum = 0; regnum < NUM_REGS; regnum++) 
d673 1
a673 1
get_longjmp_target(pc)
d681 1
a681 1
  if (target_read_memory (sp + SP_ARG0, /* Offset of first arg on stack */
d700 1
a700 1
i386_extract_return_value(type, regbuf, valbuf)
d705 4
a708 3
/* On AIX, floating point values are returned in floating point registers.  */
#ifdef I386_AIX_TARGET
  if (TYPE_CODE_FLT == TYPE_CODE(type))
d713 6
a718 1
			     &regbuf[REGISTER_BYTE(FP0_REGNUM)],
d723 23
a745 3
#endif /* I386_AIX_TARGET */
    { 
      memcpy (valbuf, regbuf, TYPE_LENGTH (type)); 
d777 134
d923 6
a928 6
	 of junk (the contents of which match a string given in the
	 N_OPT), a period and the name.  For function-local statics
	 there will be a bunch of junk (which seems to change the
	 second character from 'A' to 'B'), a period, the name of the
	 function, and the name.  So just skip everything before the
	 last period.  */
d946 1
a946 1
  if (pc && read_memory_unsigned_integer (pc, 2) == 0x25ff) /* jmp *(dest) */
d948 1
a948 1
      unsigned long indirect = read_memory_unsigned_integer (pc+2, 4);
d950 2
a951 2
	indirect ? lookup_minimal_symbol_by_pc (indirect) : 0;
      char *symname = indsym ? SYMBOL_NAME(indsym) : 0;
d953 1
a953 1
      if (symname) 
d955 2
a956 2
	  if (strncmp (symname,"__imp_", 6) == 0
	      || strncmp (symname,"_imp_", 5) == 0)
d966 1
a966 1
     disassemble_info * info;
d972 3
d977 23
d1003 21
d1028 7
a1034 5
  add_show_from_set(
	    add_set_enum_cmd ("disassembly-flavor", no_class,
				  valid_flavors,
				  (char *) &disassembly_flavor,
				  "Set the disassembly flavor, the valid values are \"att\" and \"intel\", \
d1036 7
a1042 2
				  &setlist),
	    &showlist);
d1044 1
a1044 1
  
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a58 6
/* This is used to keep the bfd arch_info in sync with the disassembly flavor.  */
static void set_disassembly_flavor_sfunc PARAMS ((char *, int, struct cmd_list_element *));
static void set_disassembly_flavor ();

void (*disassembly_flavor_hook) PARAMS((char *args, int from_tty));

d369 1
a369 1
  pfi = get_prev_frame (fi);			
a774 28
  /* Never reached - disassembly_flavour is always either att_flavor
     or intel_flavor */
  abort ();
}

/* If the disassembly mode is intel, we have to also switch the
   bfd mach_type.  This function is run in the set disassembly_flavor
   command, and does that.  */

static void
set_disassembly_flavor_sfunc (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
{
  set_disassembly_flavor ();
  
  if (disassembly_flavor_hook != NULL)
    disassembly_flavor_hook(args, from_tty);
}

static void
set_disassembly_flavor ()
{
  if (disassembly_flavor == att_flavor)
    set_architecture_from_arch_mach (bfd_arch_i386, bfd_mach_i386_i386);
  else if (disassembly_flavor == intel_flavor)
    set_architecture_from_arch_mach (bfd_arch_i386, bfd_mach_i386_i386_intel_syntax);
a779 2
  struct cmd_list_element *new_cmd;
  
d784 2
a785 2

  new_cmd = add_set_enum_cmd ("disassembly-flavor", no_class,
d790 2
a791 6
				  &setlist);
  new_cmd->function.sfunc = set_disassembly_flavor_sfunc;
  add_show_from_set(new_cmd, &showlist);
  
  /* Finally, initialize the disassembly flavor to the default given
     in the disassembly_flavor variable */
a792 1
  set_disassembly_flavor ();
@


1.1.1.3
log
@import gdb-1999-05-25 snapshot
@
text
@d368 1
a368 1
  frameless = FRAMELESS_FUNCTION_INVOCATION (fi);
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d49 1
a49 1
   and its legitimate values. */
d52 1
a52 2
static char *valid_flavors[] =
{
d63 1
a63 1
void (*disassembly_flavor_hook) PARAMS ((char *args, int from_tty));
d95 1
a95 1
static unsigned char
d97 1
a97 1
     int peek_flag;
d104 1
a104 1

d106 1
a106 1
    return (codestream_peek ());
d108 1
a108 1
    return (codestream_get ());
d113 1
a113 1
     CORE_ADDR place;
d119 1
a119 1
  while (codestream_tell () != place)
d165 1
a165 1
	  pos += delta + 4;
d212 1
a212 1
       *    popl %eax             0x58
d225 2
a226 4
      static unsigned char proto1[3] =
      {0x87, 0x04, 0x24};
      static unsigned char proto2[4] =
      {0x87, 0x44, 0x24, 0x00};
d235 1
a235 1
      op = codestream_get ();	/* update next opcode */
d268 1
a268 1
      op = codestream_get ();	/* update next opcode */
d272 1
a272 1
    {
d288 1
a288 1

d309 1
a309 1
	  return (codestream_get ());
d315 1
a315 1
	  codestream_get ();
d323 1
a323 1
	  codestream_read ((unsigned char *) buf, 4);
d335 2
a336 2
      codestream_read ((unsigned char *) buf, 2);
      codestream_get ();	/* flush final byte of enter instruction */
d357 2
a358 2
  int retpc;
  unsigned char op;
d375 1
a375 1
  pfi = get_prev_frame (fi);
d379 4
a382 4
         main, because FRAME_CHAIN_VALID won't let us go into
         start.  If we have debugging symbols, that's not really
         a big deal; it just means it will only show as many arguments
         to main as are declared.  */
d387 5
a391 5
      retpc = pfi->pc;
      op = read_memory_integer (retpc, 1);
      if (op == 0x59)
	/* pop %ecx */
	return 1;
d394 4
a397 4
	  op = read_memory_integer (retpc + 1, 1);
	  if (op == 0xc4)
	    /* addl $<signed imm 8 bits>, %esp */
	    return (read_memory_integer (retpc + 2, 1) & 0xff) / 4;
d402 5
a406 5
	{			/* add with 32 bit immediate */
	  op = read_memory_integer (retpc + 1, 1);
	  if (op == 0xc4)
	    /* addl $<imm 32>, %esp */
	    return read_memory_integer (retpc + 2, 4) / 4;
d458 1
a458 1

d460 1
a460 1

d465 1
a465 1

d467 1
a467 1
  if (dummy_bottom <= fip->pc && fip->pc <= fip->frame)
d471 1
a471 1
      for (i = 0; i < NUM_REGS; i++)
d478 1
a478 1

d482 2
a483 2

  if (locals >= 0)
d486 1
a486 1
      for (i = 0; i < 8; i++)
d493 1
a493 1
	  fsrp->regs[I386_REGNO_TO_SYMMETRY (op - 0x50)] = adr;
d500 1
a500 1

d513 3
a515 4
  static unsigned char pic_pat[6] =
  {0xe8, 0, 0, 0, 0,		/* call   0x0 */
   0x5b,			/* popl   %ebx */
  };
d517 1
a517 1

d520 1
a520 1

d524 1
a524 1

d530 1
a530 1
      if (op < 0x50 || op > 0x57)
d537 4
a540 4
     call       0x0
     popl       %ebx
     movl       %ebx,x(%ebp)    (optional)
     addl       y,%ebx
d544 1
a544 1

d549 1
a549 1
      if (pic_pat[i] != op)
d558 1
a558 1
      if (op == 0x89)		/* movl %ebx, x(%ebp) */
d561 1
a561 1
	  if (op == 0x5d)	/* one byte offset from %ebp */
d566 1
a566 1
	  else if (op == 0x9d)	/* four byte offset from %ebp */
d571 3
a573 3
	  else			/* unexpected instruction */
	    delta = -1;
	  op = codestream_get ();
d575 2
a576 2
      /* addl y,%ebx */
      if (delta > 0 && op == 0x81 && codestream_get () == 0xc3)
d578 1
a578 1
	  pos += delta + 6;
d582 1
a582 1

d584 1
a584 1

d594 1
a594 1

d614 1
a614 1

d617 1
a617 1
  for (regnum = 0; regnum < NUM_REGS; regnum++)
d642 1
a642 1
get_longjmp_target (pc)
d650 1
a650 1
  if (target_read_memory (sp + SP_ARG0,		/* Offset of first arg on stack */
d669 1
a669 1
i386_extract_return_value (type, regbuf, valbuf)
d676 1
a676 1
  if (TYPE_CODE_FLT == TYPE_CODE (type))
d681 1
a681 1
			     &regbuf[REGISTER_BYTE (FP0_REGNUM)],
d687 2
a688 2
    {
      memcpy (valbuf, regbuf, TYPE_LENGTH (type));
d732 6
a737 6
         of junk (the contents of which match a string given in the
         N_OPT), a period and the name.  For function-local statics
         there will be a bunch of junk (which seems to change the
         second character from 'A' to 'B'), a period, the name of the
         function, and the name.  So just skip everything before the
         last period.  */
d755 1
a755 1
  if (pc && read_memory_unsigned_integer (pc, 2) == 0x25ff)	/* jmp *(dest) */
d757 1
a757 1
      unsigned long indirect = read_memory_unsigned_integer (pc + 2, 4);
d759 2
a760 2
      indirect ? lookup_minimal_symbol_by_pc (indirect) : 0;
      char *symname = indsym ? SYMBOL_NAME (indsym) : 0;
d762 1
a762 1
      if (symname)
d764 2
a765 2
	  if (strncmp (symname, "__imp_", 6) == 0
	      || strncmp (symname, "_imp_", 5) == 0)
d775 1
a775 1
     disassemble_info *info;
d797 1
a797 1

d799 1
a799 1
    disassembly_flavor_hook (args, from_tty);
d815 1
a815 1

d822 3
a824 3
			      valid_flavors,
			      (char *) &disassembly_flavor,
			      "Set the disassembly flavor, the valid values are \"att\" and \"intel\", \
d826 1
a826 1
			      &setlist);
d828 2
a829 2
  add_show_from_set (new_cmd, &showlist);

d834 1
a834 1

@


1.1.1.5
log
@import gdb-1999-08-02 snapshot
@
text
@a724 134
#ifdef I386_LINUX_SIGTRAMP

/* When the i386 Linux kernel calls a signal handler, the return
   address points to a bit of code on the stack.  This function
   returns whether the PC appears to be within this bit of code.

   The instruction sequence is
       pop    %eax
       mov    $0x77,%eax
       int    $0x80
   or 0x58 0xb8 0x77 0x00 0x00 0x00 0xcd 0x80.

   Checking for the code sequence should be somewhat reliable, because
   the effect is to call the system call sigreturn.  This is unlikely
   to occur anywhere other than a signal trampoline.

   It kind of sucks that we have to read memory from the process in
   order to identify a signal trampoline, but there doesn't seem to be
   any other way.  The IN_SIGTRAMP macro in tm-linux.h arranges to
   only call us if no function name could be identified, which should
   be the case since the code is on the stack.  */

#define LINUX_SIGTRAMP_INSN0 (0x58)	/* pop %eax */
#define LINUX_SIGTRAMP_OFFSET0 (0)
#define LINUX_SIGTRAMP_INSN1 (0xb8)	/* mov $NNNN,%eax */
#define LINUX_SIGTRAMP_OFFSET1 (1)
#define LINUX_SIGTRAMP_INSN2 (0xcd)	/* int */
#define LINUX_SIGTRAMP_OFFSET2 (6)

static const unsigned char linux_sigtramp_code[] =
{
  LINUX_SIGTRAMP_INSN0,					/* pop %eax */
  LINUX_SIGTRAMP_INSN1, 0x77, 0x00, 0x00, 0x00,		/* mov $0x77,%eax */
  LINUX_SIGTRAMP_INSN2, 0x80				/* int $0x80 */
};

#define LINUX_SIGTRAMP_LEN (sizeof linux_sigtramp_code)

/* If PC is in a sigtramp routine, return the address of the start of
   the routine.  Otherwise, return 0.  */

static CORE_ADDR
i386_linux_sigtramp_start (pc)
     CORE_ADDR pc;
{
  unsigned char buf[LINUX_SIGTRAMP_LEN];

  /* We only recognize a signal trampoline if PC is at the start of
     one of the three instructions.  We optimize for finding the PC at
     the start, as will be the case when the trampoline is not the
     first frame on the stack.  We assume that in the case where the
     PC is not at the start of the instruction sequence, there will be
     a few trailing readable bytes on the stack.  */

  if (read_memory_nobpt (pc, (char *) buf, LINUX_SIGTRAMP_LEN) != 0)
    return 0;

  if (buf[0] != LINUX_SIGTRAMP_INSN0)
    {
      int adjust;

      switch (buf[0])
	{
	case LINUX_SIGTRAMP_INSN1:
	  adjust = LINUX_SIGTRAMP_OFFSET1;
	  break;
	case LINUX_SIGTRAMP_INSN2:
	  adjust = LINUX_SIGTRAMP_OFFSET2;
	  break;
	default:
	  return 0;
	}

      pc -= adjust;

      if (read_memory_nobpt (pc, (char *) buf, LINUX_SIGTRAMP_LEN) != 0)
	return 0;
    }

  if (memcmp (buf, linux_sigtramp_code, LINUX_SIGTRAMP_LEN) != 0)
    return 0;

  return pc;
}

/* Return whether PC is in a Linux sigtramp routine.  */

int
i386_linux_sigtramp (pc)
     CORE_ADDR pc;
{
  return i386_linux_sigtramp_start (pc) != 0;
}

/* Assuming FRAME is for a Linux sigtramp routine, return the saved
   program counter.  The Linux kernel will set up a sigcontext
   structure immediately before the sigtramp routine on the stack.  */

CORE_ADDR
i386_linux_sigtramp_saved_pc (frame)
     struct frame_info *frame;
{
  CORE_ADDR pc;

  pc = i386_linux_sigtramp_start (frame->pc);
  if (pc == 0)
    error ("i386_linux_sigtramp_saved_pc called when no sigtramp");
  return read_memory_integer ((pc
			       - LINUX_SIGCONTEXT_SIZE
			       + LINUX_SIGCONTEXT_PC_OFFSET),
			      4);
}

/* Assuming FRAME is for a Linux sigtramp routine, return the saved
   stack pointer.  The Linux kernel will set up a sigcontext structure
   immediately before the sigtramp routine on the stack.  */

CORE_ADDR
i386_linux_sigtramp_saved_sp (frame)
     struct frame_info *frame;
{
  CORE_ADDR pc;

  pc = i386_linux_sigtramp_start (frame->pc);
  if (pc == 0)
    error ("i386_linux_sigtramp_saved_sp called when no sigtramp");
  return read_memory_integer ((pc
			       - LINUX_SIGCONTEXT_SIZE
			       + LINUX_SIGCONTEXT_SP_OFFSET),
			      4);
}

#endif /* I386_LINUX_SIGTRAMP */

@


1.1.1.6
log
@import gdb-1999-08-09 snapshot
@
text
@d65 2
@


1.1.1.7
log
@import gdb-1999-08-16 snapshot
@
text
@d934 3
@


1.1.1.8
log
@import gdb-1999-09-08 snapshot
@
text
@a60 2
static void i386_print_register PARAMS ((char *, int, int));

d63 1
a63 1
static void set_disassembly_flavor PARAMS ((void));
d677 2
a678 3
  /* On AIX and i386 GNU/Linux, floating point values are returned in
     floating point registers.  */
#if defined(I386_AIX_TARGET) || defined(I386_GNULINUX_TARGET)
d684 1
a684 1
			     &regbuf[REGISTER_BYTE(FPDATA_REGNUM)],
d689 1
a689 1
#endif /* I386_AIX_TARGET || I386_GNULINUX_TARGET*/
d691 1
a691 17
      int len = TYPE_LENGTH (type);
      int low_size = REGISTER_RAW_SIZE (LOW_RETURN_REGNUM);
      int high_size = REGISTER_RAW_SIZE (HIGH_RETURN_REGNUM);

      if (len <= low_size)
	memcpy (valbuf, regbuf + REGISTER_BYTE (LOW_RETURN_REGNUM), len);
      else if (len <= (low_size + high_size))
	{
	  memcpy (valbuf,
		  regbuf + REGISTER_BYTE (LOW_RETURN_REGNUM),
		  low_size);
	  memcpy (valbuf + low_size,
		  regbuf + REGISTER_BYTE (HIGH_RETURN_REGNUM),
		  len - low_size);
	}
      else
	error ("GDB bug: i386-tdep.c (i386_extract_return_value): Don't know how to find a return value %d bytes long", len);
a942 45
}

/* Print the register regnum, or all registers if regnum is -1 */

void
i386_do_registers_info (regnum, fpregs)
     int regnum;
     int fpregs;
{
  char raw_regs [REGISTER_BYTES];
  int i;

  for (i = 0; i < NUM_REGS; i++)
    read_relative_register_raw_bytes (i, raw_regs + REGISTER_BYTE (i));

  if (regnum < FPSTART_REGNUM)
    i386_print_register (raw_regs, regnum, fpregs);
  else
    i387_print_register (raw_regs, regnum);
}

static void
i386_print_register (raw_regs, regnum, fpregs)
     char *raw_regs;
     int regnum;
     int fpregs;
{
  int i;
  long val;
  char string[12];

  for (i = 0; i < FPSTART_REGNUM; i++)
    {
      if ((regnum != -1) && (i != regnum))
	continue;

      val = extract_signed_integer (raw_regs + REGISTER_BYTE (i), 4);

      sprintf(string, "0x%x", val);
      printf_filtered ("%8.8s: %10.10s %11d\n", REGISTER_NAME(i), string, val);
    }

  if ((regnum == -1) && fpregs)
    for (i = FPSTART_REGNUM; i < FPEND_REGNUM; i++)
      i387_print_register (raw_regs, i);
@


1.1.1.9
log
@import gdb-1999-09-21
@
text
@d687 1
a687 6
#if defined(FPDATA_REGNUM)
			     &regbuf[REGISTER_BYTE (FPDATA_REGNUM)],
#else /* !FPDATA_REGNUM */
			     &regbuf[REGISTER_BYTE (FP0_REGNUM)],
#endif /* FPDATA_REGNUM */

a693 1
#if defined(LOW_RETURN_REGNUM)
a710 3
#else /* !LOW_RETURN_REGNUM */
      memcpy (valbuf, regbuf, TYPE_LENGTH (type));
#endif /* LOW_RETURN_REGNUM */
d962 45
@


1.1.1.10
log
@import gdb-1999-10-04 snapshot
@
text
@a972 1

@


1.1.1.11
log
@import gdb-1999-10-18 snapshot
@
text
@a48 26
/* i386_register_byte[i] is the offset into the register file of the
   start of register number i.  We initialize this from
   i386_register_raw_size.  */
int i386_register_byte[MAX_NUM_REGS];

/* i386_register_raw_size[i] is the number of bytes of storage in the
   actual machine representation for register i.  */
int i386_register_raw_size[MAX_NUM_REGS] = {
   4,  4,  4,  4,
   4,  4,  4,  4,
   4,  4,  4,  4,
   4,  4,  4,  4,
  10, 10, 10, 10,
  10, 10, 10, 10,
   4,  4,  4,  4,
   4,  4,  4,  4,
  16, 16, 16, 16,
  16, 16, 16, 16,
   4
};

/* i386_register_virtual_size[i] is the size in bytes of the virtual
   type of register i.  */
int i386_register_virtual_size[MAX_NUM_REGS];


d977 1
a977 20
  /* Initialize the table saying where each register starts in the
     register file.  */
  {
    int i, offset;

    offset = 0;
    for (i = 0; i < MAX_NUM_REGS; i++)
      {
	i386_register_byte[i] = offset;
	offset += i386_register_raw_size[i];
      }
  }

  /* Initialize the table of virtual register sizes.  */
  {
    int i;

    for (i = 0; i < MAX_NUM_REGS; i++)
      i386_register_virtual_size[i] = TYPE_LENGTH (REGISTER_VIRTUAL_TYPE (i));
  }
a982 2
  {
    struct cmd_list_element *new_cmd;
d984 4
a987 4
    new_cmd = add_set_enum_cmd ("disassembly-flavor", no_class,
				valid_flavors,
				(char *) &disassembly_flavor,
				"Set the disassembly flavor, the valid values are \"att\" and \"intel\", \
d989 3
a991 4
				&setlist);
    new_cmd->function.sfunc = set_disassembly_flavor_sfunc;
    add_show_from_set (new_cmd, &showlist);
  }
d997 1
@


