head	1.181;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.169
	gdb_7_6-2013-04-26-release:1.169
	gdb_7_6-branch:1.169.0.2
	gdb_7_6-2013-03-12-branchpoint:1.169
	gdb_7_5_1-2012-11-29-release:1.158
	gdb_7_5-2012-08-17-release:1.158
	gdb_7_5-branch:1.158.0.2
	gdb_7_5-2012-07-18-branchpoint:1.158
	gdb_7_4_1-2012-04-26-release:1.154.2.1
	gdb_7_4-2012-01-24-release:1.154.2.1
	gdb_7_4-branch:1.154.0.2
	gdb_7_4-2011-12-13-branchpoint:1.154
	gdb_7_3_1-2011-09-04-release:1.147
	gdb_7_3-2011-07-26-release:1.147
	gdb_7_3-branch:1.147.0.2
	gdb_7_3-2011-04-01-branchpoint:1.147
	gdb_7_2-2010-09-02-release:1.140
	gdb_7_2-branch:1.140.0.2
	gdb_7_2-2010-07-07-branchpoint:1.140
	gdb_7_1-2010-03-18-release:1.133
	gdb_7_1-branch:1.133.0.2
	gdb_7_1-2010-02-18-branchpoint:1.133
	gdb_7_0_1-2009-12-22-release:1.126.2.1
	gdb_7_0-2009-10-06-release:1.126.2.1
	gdb_7_0-branch:1.126.0.2
	gdb_7_0-2009-09-16-branchpoint:1.126
	arc-sim-20090309:1.101
	msnyder-checkpoint-072509-branch:1.122.0.2
	msnyder-checkpoint-072509-branchpoint:1.122
	arc-insight_6_8-branch:1.101.0.6
	arc-insight_6_8-branchpoint:1.101
	insight_6_8-branch:1.101.0.4
	insight_6_8-branchpoint:1.101
	reverse-20081226-branch:1.107.0.4
	reverse-20081226-branchpoint:1.107
	multiprocess-20081120-branch:1.107.0.2
	multiprocess-20081120-branchpoint:1.107
	reverse-20080930-branch:1.106.0.2
	reverse-20080930-branchpoint:1.106
	reverse-20080717-branch:1.103.0.2
	reverse-20080717-branchpoint:1.103
	msnyder-reverse-20080609-branch:1.102.0.2
	msnyder-reverse-20080609-branchpoint:1.102
	drow-reverse-20070409-branch:1.90.0.2
	drow-reverse-20070409-branchpoint:1.90
	gdb_6_8-2008-03-27-release:1.101
	gdb_6_8-branch:1.101.0.2
	gdb_6_8-2008-02-26-branchpoint:1.101
	gdb_6_7_1-2007-10-29-release:1.97
	gdb_6_7-2007-10-10-release:1.97
	gdb_6_7-branch:1.97.0.2
	gdb_6_7-2007-09-07-branchpoint:1.97
	insight_6_6-20070208-release:1.87
	gdb_6_6-2006-12-18-release:1.87
	gdb_6_6-branch:1.87.0.2
	gdb_6_6-2006-11-15-branchpoint:1.87
	insight_6_5-20061003-release:1.84
	gdb-csl-symbian-6_4_50_20060226-12:1.84.8.3
	gdb-csl-sourcerygxx-3_4_4-25:1.81
	nickrob-async-20060828-mergepoint:1.84
	gdb-csl-symbian-6_4_50_20060226-11:1.84.8.3
	gdb-csl-sourcerygxx-4_1-17:1.84
	gdb-csl-20060226-branch-local-2:1.84
	gdb-csl-sourcerygxx-4_1-14:1.84
	gdb-csl-sourcerygxx-4_1-13:1.84
	gdb-csl-sourcerygxx-4_1-12:1.84
	gdb-csl-sourcerygxx-3_4_4-21:1.84
	gdb_6_5-20060621-release:1.84
	gdb-csl-sourcerygxx-4_1-9:1.84
	gdb-csl-sourcerygxx-4_1-8:1.84
	gdb-csl-sourcerygxx-4_1-7:1.84
	gdb-csl-arm-2006q1-6:1.84
	gdb-csl-sourcerygxx-4_1-6:1.84
	gdb-csl-symbian-6_4_50_20060226-10:1.84.8.2
	gdb-csl-symbian-6_4_50_20060226-9:1.84.8.2
	gdb-csl-symbian-6_4_50_20060226-8:1.84.8.2
	gdb-csl-coldfire-4_1-11:1.84
	gdb-csl-sourcerygxx-3_4_4-19:1.84
	gdb-csl-coldfire-4_1-10:1.84
	gdb_6_5-branch:1.84.0.16
	gdb_6_5-2006-05-14-branchpoint:1.84
	gdb-csl-sourcerygxx-4_1-5:1.84
	nickrob-async-20060513-branch:1.84.0.14
	nickrob-async-20060513-branchpoint:1.84
	gdb-csl-sourcerygxx-4_1-4:1.84
	msnyder-reverse-20060502-branch:1.84.0.12
	msnyder-reverse-20060502-branchpoint:1.84
	gdb-csl-morpho-4_1-4:1.84
	gdb-csl-sourcerygxx-3_4_4-17:1.84
	readline_5_1-import-branch:1.84.0.10
	readline_5_1-import-branchpoint:1.84
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.84
	gdb-csl-symbian-20060226-branch:1.84.0.8
	gdb-csl-symbian-20060226-branchpoint:1.84
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.84
	msnyder-reverse-20060331-branch:1.84.0.6
	msnyder-reverse-20060331-branchpoint:1.84
	gdb-csl-available-20060303-branch:1.84.0.4
	gdb-csl-available-20060303-branchpoint:1.84
	gdb-csl-20060226-branch:1.84.0.2
	gdb-csl-20060226-branchpoint:1.84
	gdb_6_4-20051202-release:1.81
	msnyder-fork-checkpoint-branch:1.81.0.8
	msnyder-fork-checkpoint-branchpoint:1.81
	gdb-csl-gxxpro-6_3-branch:1.81.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.81
	gdb_6_4-branch:1.81.0.4
	gdb_6_4-2005-11-01-branchpoint:1.81
	gdb-csl-arm-20051020-branch:1.81.0.2
	gdb-csl-arm-20051020-branchpoint:1.81
	msnyder-tracepoint-checkpoint-branch:1.80.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.80
	gdb-csl-arm-20050325-2005-q1b:1.79
	gdb-csl-arm-20050325-2005-q1a:1.79
	csl-arm-20050325-branch:1.79.0.2
	csl-arm-20050325-branchpoint:1.79
	gdb-post-i18n-errorwarning-20050211:1.72
	gdb-pre-i18n-errorwarning-20050211:1.71
	gdb_6_3-20041109-release:1.68
	gdb_6_3-branch:1.68.0.2
	gdb_6_3-20041019-branchpoint:1.68
	drow_intercu-merge-20040921:1.68
	drow_intercu-merge-20040915:1.68
	jimb-gdb_6_2-e500-branch:1.64.0.8
	jimb-gdb_6_2-e500-branchpoint:1.64
	gdb_6_2-20040730-release:1.64
	gdb_6_2-branch:1.64.0.4
	gdb_6_2-2004-07-10-gmt-branchpoint:1.64
	gdb_6_1_1-20040616-release:1.63
	gdb_6_1-2004-04-05-release:1.63
	drow_intercu-merge-20040402:1.64
	drow_intercu-merge-20040327:1.64
	ezannoni_pie-20040323-branch:1.64.0.2
	ezannoni_pie-20040323-branchpoint:1.64
	cagney_tramp-20040321-mergepoint:1.64
	cagney_tramp-20040309-branch:1.63.0.4
	cagney_tramp-20040309-branchpoint:1.63
	gdb_6_1-branch:1.63.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.63
	drow_intercu-20040221-branch:1.62.0.2
	drow_intercu-20040221-branchpoint:1.62
	cagney_bfdfile-20040213-branch:1.61.0.4
	cagney_bfdfile-20040213-branchpoint:1.61
	drow-cplus-merge-20040208:1.61
	carlton_dictionary-20040126-merge:1.61
	cagney_bigcore-20040122-branch:1.61.0.2
	cagney_bigcore-20040122-branchpoint:1.61
	drow-cplus-merge-20040113:1.61
	drow-cplus-merge-20031224:1.61
	drow-cplus-merge-20031220:1.61
	carlton_dictionary-20031215-merge:1.61
	drow-cplus-merge-20031214:1.61
	carlton-dictionary-20031111-merge:1.61
	gdb_6_0-2003-10-04-release:1.58
	kettenis_sparc-20030918-branch:1.59.0.4
	kettenis_sparc-20030918-branchpoint:1.59
	carlton_dictionary-20030917-merge:1.59
	ezannoni_pie-20030916-branchpoint:1.59
	ezannoni_pie-20030916-branch:1.59.0.2
	cagney_x86i386-20030821-branch:1.58.0.4
	cagney_x86i386-20030821-branchpoint:1.58
	carlton_dictionary-20030805-merge:1.58
	carlton_dictionary-20030627-merge:1.58
	gdb_6_0-branch:1.58.0.2
	gdb_6_0-2003-06-23-branchpoint:1.58
	jimb-ppc64-linux-20030613-branch:1.57.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.57
	cagney_convert-20030606-branch:1.56.0.2
	cagney_convert-20030606-branchpoint:1.56
	cagney_writestrings-20030508-branch:1.55.0.24
	cagney_writestrings-20030508-branchpoint:1.55
	jimb-ppc64-linux-20030528-branch:1.55.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.55
	carlton_dictionary-20030523-merge:1.55
	cagney_fileio-20030521-branch:1.55.0.20
	cagney_fileio-20030521-branchpoint:1.55
	kettenis_i386newframe-20030517-mergepoint:1.55
	jimb-ppc64-linux-20030509-branch:1.55.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.55
	kettenis_i386newframe-20030504-mergepoint:1.55
	carlton_dictionary-20030430-merge:1.55
	kettenis_i386newframe-20030419-branch:1.55.0.16
	kettenis_i386newframe-20030419-branchpoint:1.55
	carlton_dictionary-20030416-merge:1.55
	cagney_frameaddr-20030409-mergepoint:1.55
	kettenis_i386newframe-20030406-branch:1.55.0.14
	kettenis_i386newframe-20030406-branchpoint:1.55
	cagney_frameaddr-20030403-branchpoint:1.55
	cagney_frameaddr-20030403-branch:1.55.0.12
	cagney_framebase-20030330-mergepoint:1.55
	cagney_framebase-20030326-branch:1.55.0.10
	cagney_framebase-20030326-branchpoint:1.55
	cagney_lazyid-20030317-branch:1.55.0.8
	cagney_lazyid-20030317-branchpoint:1.55
	kettenis-i386newframe-20030316-mergepoint:1.55
	offbyone-20030313-branch:1.55.0.6
	offbyone-20030313-branchpoint:1.55
	kettenis-i386newframe-20030308-branch:1.55.0.4
	kettenis-i386newframe-20030308-branchpoint:1.55
	carlton_dictionary-20030305-merge:1.55
	cagney_offbyone-20030303-branch:1.55.0.2
	cagney_offbyone-20030303-branchpoint:1.55
	carlton_dictionary-20030207-merge:1.53
	interps-20030203-mergepoint:1.53
	interps-20030202-branch:1.53.0.2
	interps-20030202-branchpoint:1.53
	cagney-unwind-20030108-branch:1.51.0.2
	cagney-unwind-20030108-branchpoint:1.51
	carlton_dictionary-20021223-merge:1.51
	gdb_5_3-2002-12-12-release:1.50
	carlton_dictionary-20021115-merge:1.50
	kseitz_interps-20021105-merge:1.50
	kseitz_interps-20021103-merge:1.50
	drow-cplus-merge-20021020:1.50
	drow-cplus-merge-20021025:1.50
	carlton_dictionary-20021025-merge:1.50
	carlton_dictionary-20021011-merge:1.50
	drow-cplus-branch:1.50.0.14
	drow-cplus-branchpoint:1.50
	kseitz_interps-20020930-merge:1.50
	carlton_dictionary-20020927-merge:1.50
	carlton_dictionary-branch:1.50.0.12
	carlton_dictionary-20020920-branchpoint:1.50
	gdb_5_3-branch:1.50.0.10
	gdb_5_3-2002-09-04-branchpoint:1.50
	kseitz_interps-20020829-merge:1.50
	cagney_sysregs-20020825-branch:1.50.0.8
	cagney_sysregs-20020825-branchpoint:1.50
	readline_4_3-import-branch:1.50.0.6
	readline_4_3-import-branchpoint:1.50
	gdb_5_2_1-2002-07-23-release:1.48
	kseitz_interps-20020528-branch:1.50.0.4
	kseitz_interps-20020528-branchpoint:1.50
	cagney_regbuf-20020515-branch:1.50.0.2
	cagney_regbuf-20020515-branchpoint:1.50
	jimb-macro-020506-branch:1.49.0.2
	jimb-macro-020506-branchpoint:1.49
	gdb_5_2-2002-04-29-release:1.48
	gdb_5_2-branch:1.48.0.2
	gdb_5_2-2002-03-03-branchpoint:1.48
	gdb_5_1_1-2002-01-24-release:1.42.4.1
	gdb_5_1_0_1-2002-01-03-release:1.42.4.1
	cygnus_cvs_20020108_pre:1.46
	gdb_5_1_0_1-2002-01-03-branchpoint:1.42.4.1
	gdb_5_1_0_1-2002-01-03-branch:1.42.4.1.0.2
	gdb_5_1-2001-11-21-release:1.42.4.1
	gdb_s390-2001-09-26-branch:1.42.0.6
	gdb_s390-2001-09-26-branchpoint:1.42
	gdb_5_1-2001-07-29-branch:1.42.0.4
	gdb_5_1-2001-07-29-branchpoint:1.42
	dberlin-typesystem-branch:1.42.0.2
	dberlin-typesystem-branchpoint:1.42
	gdb-post-ptid_t-2001-05-03:1.39
	gdb-pre-ptid_t-2001-05-03:1.39
	insight-precleanup-2001-01-01:1.31
	gdb-post-protoization-2000-07-29:1.18
	gdb-pre-protoization-2000-07-29:1.17
	gdb-premipsmulti-2000-06-06-branch:1.16.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.16
	gdb-post-params-removal-2000-06-04:1.16
	gdb-pre-params-removal-2000-06-04:1.16
	gdb-post-params-removal-2000-05-28:1.16
	gdb-pre-params-removal-2000-05-28:1.15
	gdb_5_0-2000-05-19-release:1.10
	gdb_4_18_2-2000-05-18-release:1.10
	gdb_4_95_1-2000-05-11-snapshot:1.10
	gdb_4_95_0-2000-04-27-snapshot:1.10
	gdb_5_0-2000-04-10-branch:1.10.0.2
	gdb_5_0-2000-04-10-branchpoint:1.10
	repo-unification-2000-02-06:1.1.1.10
	insight-2000-02-04:1.1.1.10
	gdb-2000-02-04:1.1.1.10
	gdb-2000-02-02:1.1.1.10
	gdb-2000-02-01:1.1.1.10
	gdb-2000-01-31:1.1.1.10
	gdb-2000-01-26:1.1.1.10
	gdb-2000-01-24:1.1.1.10
	gdb-2000-01-17:1.1.1.10
	gdb-2000-01-10:1.1.1.10
	gdb-2000-01-05:1.1.1.10
	gdb-1999-12-21:1.1.1.10
	gdb-1999-12-13:1.1.1.10
	gdb-1999-12-07:1.1.1.10
	gdb-1999-12-06:1.1.1.10
	gdb-1999-11-16:1.1.1.10
	gdb-1999-11-08:1.1.1.9
	gdb-1999-11-01:1.1.1.9
	gdb-1999-10-25:1.1.1.9
	gdb-1999-10-18:1.1.1.9
	gdb-1999-10-11:1.1.1.9
	gdb-1999-10-04:1.1.1.8
	gdb-1999-09-28:1.1.1.7
	gdb-1999-09-21:1.1.1.6
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.6
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.5
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.181
date	2013.09.27.15.29.06;	author palves;	state Exp;
branches;
next	1.180;

1.180
date	2013.09.24.14.00.06;	author jkratoch;	state Exp;
branches;
next	1.179;

1.179
date	2013.09.24.13.57.37;	author jkratoch;	state Exp;
branches;
next	1.178;

1.178
date	2013.09.04.20.09.39;	author jkratoch;	state Exp;
branches;
next	1.177;

1.177
date	2013.07.22.20.51.10;	author jkratoch;	state Exp;
branches;
next	1.176;

1.176
date	2013.06.04.13.17.06;	author gary;	state Exp;
branches;
next	1.175;

1.175
date	2013.06.04.01.33.31;	author qiyao;	state Exp;
branches;
next	1.174;

1.174
date	2013.05.21.08.16.10;	author jkratoch;	state Exp;
branches;
next	1.173;

1.173
date	2013.05.06.22.18.39;	author devans;	state Exp;
branches;
next	1.172;

1.172
date	2013.05.06.14.15.50;	author brobecke;	state Exp;
branches;
next	1.171;

1.171
date	2013.04.22.16.46.15;	author tromey;	state Exp;
branches;
next	1.170;

1.170
date	2013.04.11.01.18.49;	author brobecke;	state Exp;
branches;
next	1.169;

1.169
date	2013.01.01.06.32.51;	author brobecke;	state Exp;
branches;
next	1.168;

1.168
date	2012.11.09.19.58.01;	author tromey;	state Exp;
branches;
next	1.167;

1.167
date	2012.09.28.20.20.08;	author emachado;	state Exp;
branches;
next	1.166;

1.166
date	2012.08.22.16.24.38;	author tromey;	state Exp;
branches;
next	1.165;

1.165
date	2012.08.22.15.01.50;	author tromey;	state Exp;
branches;
next	1.164;

1.164
date	2012.07.23.14.58.44;	author tromey;	state Exp;
branches;
next	1.163;

1.163
date	2012.07.23.14.57.57;	author tromey;	state Exp;
branches;
next	1.162;

1.162
date	2012.07.23.14.56.10;	author tromey;	state Exp;
branches;
next	1.161;

1.161
date	2012.07.18.19.42.26;	author tromey;	state Exp;
branches;
next	1.160;

1.160
date	2012.07.18.19.34.57;	author tromey;	state Exp;
branches;
next	1.159;

1.159
date	2012.07.18.19.33.34;	author tromey;	state Exp;
branches;
next	1.158;

1.158
date	2012.05.29.14.23.40;	author tromey;	state Exp;
branches;
next	1.157;

1.157
date	2012.02.16.21.07.20;	author tromey;	state Exp;
branches;
next	1.156;

1.156
date	2012.01.24.21.39.15;	author tromey;	state Exp;
branches;
next	1.155;

1.155
date	2012.01.04.08.17.11;	author brobecke;	state Exp;
branches;
next	1.154;

1.154
date	2011.09.12.19.00.22;	author aristovski;	state Exp;
branches
	1.154.2.1;
next	1.153;

1.153
date	2011.08.30.02.48.05;	author qiyao;	state Exp;
branches;
next	1.152;

1.152
date	2011.08.09.12.51.47;	author palves;	state Exp;
branches;
next	1.151;

1.151
date	2011.08.04.19.10.12;	author palves;	state Exp;
branches;
next	1.150;

1.150
date	2011.07.26.15.17.47;	author ppluzhnikov;	state Exp;
branches;
next	1.149;

1.149
date	2011.06.30.19.29.54;	author tromey;	state Exp;
branches;
next	1.148;

1.148
date	2011.04.17.18.38.45;	author jkratoch;	state Exp;
branches;
next	1.147;

1.147
date	2011.03.23.18.23.55;	author ktietz;	state Exp;
branches;
next	1.146;

1.146
date	2011.03.04.18.02.54;	author msnyder;	state Exp;
branches;
next	1.145;

1.145
date	2011.01.26.01.55.19;	author bauermann;	state Exp;
branches;
next	1.144;

1.144
date	2011.01.11.21.53.24;	author msnyder;	state Exp;
branches;
next	1.143;

1.143
date	2011.01.05.22.22.50;	author msnyder;	state Exp;
branches;
next	1.142;

1.142
date	2011.01.01.15.33.15;	author brobecke;	state Exp;
branches;
next	1.141;

1.141
date	2010.11.05.01.40.28;	author jkratoch;	state Exp;
branches;
next	1.140;

1.140
date	2010.05.16.23.49.58;	author msnyder;	state Exp;
branches;
next	1.139;

1.139
date	2010.05.05.19.37.45;	author msnyder;	state Exp;
branches;
next	1.138;

1.138
date	2010.04.24.13.12.55;	author palves;	state Exp;
branches;
next	1.137;

1.137
date	2010.04.14.23.20.27;	author palves;	state Exp;
branches;
next	1.136;

1.136
date	2010.04.14.13.49.53;	author palves;	state Exp;
branches;
next	1.135;

1.135
date	2010.03.09.18.09.07;	author kseitz;	state Exp;
branches;
next	1.134;

1.134
date	2010.03.08.19.28.27;	author palves;	state Exp;
branches;
next	1.133;

1.133
date	2010.01.20.14.23.07;	author vprus;	state Exp;
branches;
next	1.132;

1.132
date	2010.01.11.16.30.10;	author jkratoch;	state Exp;
branches;
next	1.131;

1.131
date	2010.01.08.22.52.03;	author jkratoch;	state Exp;
branches;
next	1.130;

1.130
date	2010.01.01.07.31.41;	author brobecke;	state Exp;
branches;
next	1.129;

1.129
date	2009.12.01.22.46.11;	author jsm28;	state Exp;
branches;
next	1.128;

1.128
date	2009.10.19.09.51.42;	author palves;	state Exp;
branches;
next	1.127;

1.127
date	2009.09.22.23.03.30;	author brobecke;	state Exp;
branches;
next	1.126;

1.126
date	2009.08.27.21.56.38;	author devans;	state Exp;
branches
	1.126.2.1;
next	1.125;

1.125
date	2009.08.21.17.57.17;	author ppluzhnikov;	state Exp;
branches;
next	1.124;

1.124
date	2009.08.10.22.09.22;	author jkratoch;	state Exp;
branches;
next	1.123;

1.123
date	2009.08.04.18.46.05;	author ppluzhnikov;	state Exp;
branches;
next	1.122;

1.122
date	2009.07.17.17.08.23;	author uweigand;	state Exp;
branches;
next	1.121;

1.121
date	2009.07.09.13.39.17;	author teawater;	state Exp;
branches;
next	1.120;

1.120
date	2009.06.16.18.49.25;	author ppluzhnikov;	state Exp;
branches;
next	1.119;

1.119
date	2009.06.03.18.50.36;	author palves;	state Exp;
branches;
next	1.118;

1.118
date	2009.05.22.23.49.13;	author palves;	state Exp;
branches;
next	1.117;

1.117
date	2009.05.19.13.51.37;	author jkratoch;	state Exp;
branches;
next	1.116;

1.116
date	2009.05.15.16.53.44;	author ppluzhnikov;	state Exp;
branches;
next	1.115;

1.115
date	2009.03.09.22.38.37;	author ppluzhnikov;	state Exp;
branches;
next	1.114;

1.114
date	2009.03.09.13.19.19;	author vprus;	state Exp;
branches;
next	1.113;

1.113
date	2009.03.06.18.51.05;	author ppluzhnikov;	state Exp;
branches;
next	1.112;

1.112
date	2009.03.05.23.45.14;	author ppluzhnikov;	state Exp;
branches;
next	1.111;

1.111
date	2009.02.21.16.14.49;	author palves;	state Exp;
branches;
next	1.110;

1.110
date	2009.02.18.07.28.32;	author vprus;	state Exp;
branches;
next	1.109;

1.109
date	2009.01.15.16.35.22;	author uweigand;	state Exp;
branches;
next	1.108;

1.108
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.107;

1.107
date	2008.11.03.14.01.27;	author palves;	state Exp;
branches
	1.107.2.1;
next	1.106;

1.106
date	2008.09.22.15.21.30;	author palves;	state Exp;
branches;
next	1.105;

1.105
date	2008.08.26.17.30.35;	author uweigand;	state Exp;
branches;
next	1.104;

1.104
date	2008.08.26.17.21.29;	author uweigand;	state Exp;
branches;
next	1.103;

1.103
date	2008.07.10.23.08.21;	author devans;	state Exp;
branches;
next	1.102;

1.102
date	2008.05.19.15.49.14;	author uweigand;	state Exp;
branches;
next	1.101;

1.101
date	2008.01.07.15.19.58;	author vprus;	state Exp;
branches;
next	1.100;

1.100
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.99;

1.99
date	2007.11.15.06.24.17;	author vprus;	state Exp;
branches;
next	1.98;

1.98
date	2007.10.24.21.07.30;	author uweigand;	state Exp;
branches;
next	1.97;

1.97
date	2007.08.23.18.08.38;	author brobecke;	state Exp;
branches;
next	1.96;

1.96
date	2007.08.14.11.09.45;	author vprus;	state Exp;
branches;
next	1.95;

1.95
date	2007.08.09.18.37.08;	author msnyder;	state Exp;
branches;
next	1.94;

1.94
date	2007.07.03.12.14.43;	author uweigand;	state Exp;
branches;
next	1.93;

1.93
date	2007.07.02.22.01.09;	author drow;	state Exp;
branches;
next	1.92;

1.92
date	2007.06.13.17.30.01;	author uweigand;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.16.14.07.56;	author drow;	state Exp;
branches;
next	1.90;

1.90
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.89;

1.89
date	2007.01.08.18.56.30;	author drow;	state Exp;
branches;
next	1.88;

1.88
date	2006.11.29.12.27.01;	author ams;	state Exp;
branches;
next	1.87;

1.87
date	2006.10.19.19.58.23;	author brobecke;	state Exp;
branches;
next	1.86;

1.86
date	2006.10.09.20.16.10;	author drow;	state Exp;
branches;
next	1.85;

1.85
date	2006.10.09.19.58.07;	author drow;	state Exp;
branches;
next	1.84;

1.84
date	2006.02.25.04.36.39;	author cwilson;	state Exp;
branches
	1.84.8.1;
next	1.83;

1.83
date	2006.01.21.22.23.27;	author drow;	state Exp;
branches;
next	1.82;

1.82
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.81;

1.81
date	2005.06.13.18.39.11;	author mmitchel;	state Exp;
branches;
next	1.80;

1.80
date	2005.04.30.12.59.57;	author kettenis;	state Exp;
branches;
next	1.79;

1.79
date	2005.02.24.13.51.34;	author cagney;	state Exp;
branches
	1.79.2.1;
next	1.78;

1.78
date	2005.02.21.07.08.40;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2005.02.18.15.25.28;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2005.02.17.17.11.03;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2005.02.15.15.49.19;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2005.02.12.00.39.21;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2005.02.11.18.13.53;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2005.02.11.04.06.05;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2005.01.14.02.04.02;	author msnyder;	state Exp;
branches;
next	1.70;

1.70
date	2005.01.12.20.52.18;	author kettenis;	state Exp;
branches;
next	1.69;

1.69
date	2005.01.12.18.31.33;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2004.09.11.10.24.50;	author hilfingr;	state Exp;
branches;
next	1.67;

1.67
date	2004.09.01.18.00.29;	author jjohnstn;	state Exp;
branches;
next	1.66;

1.66
date	2004.07.30.19.17.19;	author eliz;	state Exp;
branches;
next	1.65;

1.65
date	2004.07.26.14.53.04;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2004.03.11.17.04.40;	author kevinb;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2004.02.28.18.04.37;	author cagney;	state Exp;
branches
	1.63.4.1;
next	1.62;

1.62
date	2004.02.15.15.16.29;	author cagney;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2003.11.08.00.13.02;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2003.10.23.03.01.55;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.20.12.23.18;	author kewarken;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.11.13.16.29;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2003.06.03.19.16.34;	author kewarken;	state Exp;
branches;
next	1.55;

1.55
date	2003.02.24.19.11.04;	author kewarken;	state Exp;
branches
	1.55.24.1;
next	1.54;

1.54
date	2003.02.20.18.25.27;	author kevinb;	state Exp;
branches;
next	1.53;

1.53
date	2003.01.18.15.55.52;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2003.01.13.18.00.16;	author drow;	state Exp;
branches;
next	1.51;

1.51
date	2002.12.09.00.59.26;	author ezannoni;	state Exp;
branches;
next	1.50;

1.50
date	2002.05.12.04.20.06;	author cagney;	state Exp;
branches
	1.50.12.1
	1.50.14.1;
next	1.49;

1.49
date	2002.03.06.06.28.33;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.27.01.40.35;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2002.01.08.18.55.26;	author msnyder;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.04.09.34.56;	author orjanf;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.01.16.17.08;	author fnf;	state Exp;
branches;
next	1.44;

1.44
date	2001.10.30.04.05.34;	author fnf;	state Exp;
branches;
next	1.43;

1.43
date	2001.09.14.00.40.29;	author kevinb;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.04.07.45.08;	author eliz;	state Exp;
branches
	1.42.4.1;
next	1.41;

1.41
date	2001.05.26.00.55.11;	author nsd;	state Exp;
branches;
next	1.40;

1.40
date	2001.05.14.18.45.45;	author msnyder;	state Exp;
branches;
next	1.39;

1.39
date	2001.04.17.23.22.52;	author msnyder;	state Exp;
branches;
next	1.38;

1.38
date	2001.04.17.23.21.48;	author msnyder;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.06.08.21.16;	author kevinb;	state Exp;
branches;
next	1.36;

1.36
date	2001.02.22.03.01.27;	author kevinb;	state Exp;
branches;
next	1.35;

1.35
date	2001.02.20.18.07.17;	author hunt;	state Exp;
branches;
next	1.34;

1.34
date	2001.02.19.11.47.16;	author eliz;	state Exp;
branches;
next	1.33;

1.33
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2001.01.31.01.24.02;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.23.00.27.20;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2000.12.15.01.01.49;	author kevinb;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.27.02.18.44;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.21.09.23.32;	author kevinb;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.21.01.09.54;	author msnyder;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.30.23.31.17;	author kevinb;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.24.20.05.35;	author kevinb;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.24.14.42.21;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.20.00.44.49;	author kevinb;	state Exp;
branches;
next	1.22;

1.22
date	2000.08.31.00.39.10;	author kevinb;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.30.00.58.58;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.09.20.09.01;	author msnyder;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.07.10.56.22;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.19.02.55.55;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.22.09.02.23;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.16.04.07.39;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.11.00.36.17;	author ezannoni;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.05.18.14.27;	author msnyder;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.17.16.09.04;	author ezannoni;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.05.20.40.22;	author jimb;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.04.02.08.52;	author hjl;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.03.17.45.17;	author jimb;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.24.23.49.10;	author msnyder;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.21.22.37.42;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.17.20.12.23;	author jimb;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.16.23.12.42;	author jimb;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.15.16.55.07;	author jimb;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.06.18.04.56;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.154.2.1
date	2012.01.06.04.43.30;	author brobecke;	state Exp;
branches;
next	;

1.126.2.1
date	2009.09.22.23.04.30;	author brobecke;	state Exp;
branches;
next	;

1.107.2.1
date	2008.11.21.02.31.57;	author shebs;	state Exp;
branches;
next	;

1.84.8.1
date	2006.04.12.18.11.40;	author drow;	state Exp;
branches;
next	1.84.8.2;

1.84.8.2
date	2006.05.09.17.46.17;	author drow;	state Exp;
branches;
next	1.84.8.3;

1.84.8.3
date	2006.07.11.20.37.02;	author drow;	state Exp;
branches;
next	;

1.79.2.1
date	2005.06.13.18.43.57;	author mmitchel;	state Exp;
branches;
next	;

1.64.2.1
date	2004.03.24.04.10.01;	author ezannoni;	state Exp;
branches;
next	;

1.63.4.1
date	2004.03.21.23.57.38;	author cagney;	state Exp;
branches;
next	;

1.62.2.1
date	2004.03.27.17.37.51;	author drow;	state Exp;
branches;
next	1.62.2.2;

1.62.2.2
date	2004.09.16.17.01.19;	author drow;	state Exp;
branches;
next	;

1.55.24.1
date	2003.06.03.20.54.39;	author cagney;	state Exp;
branches;
next	;

1.50.12.1
date	2002.12.23.19.38.43;	author carlton;	state Exp;
branches;
next	1.50.12.2;

1.50.12.2
date	2003.02.07.19.17.52;	author carlton;	state Exp;
branches;
next	1.50.12.3;

1.50.12.3
date	2003.03.06.00.56.32;	author carlton;	state Exp;
branches;
next	1.50.12.4;

1.50.12.4
date	2003.06.27.21.50.09;	author carlton;	state Exp;
branches;
next	1.50.12.5;

1.50.12.5
date	2003.09.17.21.28.31;	author carlton;	state Exp;
branches;
next	1.50.12.6;

1.50.12.6
date	2003.11.11.23.50.54;	author carlton;	state Exp;
branches;
next	;

1.50.14.1
date	2003.12.14.20.27.30;	author drow;	state Exp;
branches;
next	;

1.42.4.1
date	2001.09.27.05.03.08;	author kevinb;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.19;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.06.28.16.00.56;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.09.59;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.09.21.33.54;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.31.01.06.01;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.09.28.21.52.31;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.10.05.23.08.48;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.10.12.04.37.24;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.11.17.02.30.28;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.181
log
@Fix regular /path/to/directory sysroots and target reported dll paths with drive specs.

I tried debugging a remote Windows program on Linux host, and pointed the
sysroot to "/some/path/" rather than "remote:", and I found GDB couldn't
find the dlls in the sysroot.  If the dll name is
"C:/Windows/system32/ntdll.dll", I end up with the sysroot+in_pathname
concatenated this way:

 (top-gdb) p temp_pathname
 $1 = 0x228b690 "/some/pathC:/Windows/system32/ntdll.dll"
                          ^^

That is, a directory separator is missing.  This is a regression.

The problem is that solib_find decides that since the target path has
a drive spec, a separator is not necessary, which is clearly wrong in
this case.  That check was added in
<https://sourceware.org/ml/gdb-patches/2013-06/msg00028.html>, to
handle the case of sysroot being "remote:".  This patch fixes that
original issue in a different way.  Instead of checking whether the
path has a drive spec, check whether the sysroot is "remote:".  The
patch adds a table that helps visualize the cases that need a
separator.  I also confirmed the original issue is still handled as
expected.  That is, that "set sysroot remote:" still does the right
thing.

remote_filename_p returns true if the filename is prefixed with
"remote:".  In this case, we need to check whether the filename is
exactly "remote:".  I thought of different ways or either changing
remote_filename_p or adding another convenience function to remote.c
to avoid exposing the "remote:" prefix out of remote.c.  But all
attempts turned out adding lot of over needless complication.  So the
patch just exposes the prefix behind a new macro, which allows using a
straighforward strcmp.

gdb/
2013-09-27  Pedro Alves  <palves@@redhat.com>

	* remote.h (REMOTE_SYSROOT_PREFIX): New define.
	(remote_filename_p): Add comment.
	* remote.c (remote_filename_p): Adjust to use
	REMOTE_SYSROOT_PREFIX.
	* solib.c (solib_find): When deciding whether we need to add a
	directory separator, check whether the sysroot is "remote:"
	instead of checking whether the patch has a drive spec.  Add
	comments.
@
text
@/* Handle shared libraries for GDB, the GNU Debugger.

   Copyright (C) 1990-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"

#include <sys/types.h>
#include <fcntl.h>
#include "gdb_string.h"
#include "symtab.h"
#include "bfd.h"
#include "symfile.h"
#include "objfiles.h"
#include "exceptions.h"
#include "gdbcore.h"
#include "command.h"
#include "target.h"
#include "frame.h"
#include "gdb_regex.h"
#include "inferior.h"
#include "environ.h"
#include "language.h"
#include "gdbcmd.h"
#include "completer.h"
#include "filenames.h"		/* for DOSish file names */
#include "exec.h"
#include "solist.h"
#include "observer.h"
#include "readline/readline.h"
#include "remote.h"
#include "solib.h"
#include "interps.h"
#include "filesystem.h"
#include "gdb_bfd.h"
#include "filestuff.h"

/* Architecture-specific operations.  */

/* Per-architecture data key.  */
static struct gdbarch_data *solib_data;

static void *
solib_init (struct obstack *obstack)
{
  struct target_so_ops **ops;

  ops = OBSTACK_ZALLOC (obstack, struct target_so_ops *);
  *ops = current_target_so_ops;
  return ops;
}

static const struct target_so_ops *
solib_ops (struct gdbarch *gdbarch)
{
  const struct target_so_ops **ops = gdbarch_data (gdbarch, solib_data);

  return *ops;
}

/* Set the solib operations for GDBARCH to NEW_OPS.  */

void
set_solib_ops (struct gdbarch *gdbarch, const struct target_so_ops *new_ops)
{
  const struct target_so_ops **ops = gdbarch_data (gdbarch, solib_data);

  *ops = new_ops;
}


/* external data declarations */

/* FIXME: gdbarch needs to control this variable, or else every
   configuration needs to call set_solib_ops.  */
struct target_so_ops *current_target_so_ops;

/* List of known shared objects */
#define so_list_head current_program_space->so_list

/* Local function prototypes */

/* If non-empty, this is a search path for loading non-absolute shared library
   symbol files.  This takes precedence over the environment variables PATH
   and LD_LIBRARY_PATH.  */
static char *solib_search_path = NULL;
static void
show_solib_search_path (struct ui_file *file, int from_tty,
			struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("The search path for loading non-absolute "
			    "shared library symbol files is %s.\n"),
		    value);
}

/* Same as HAVE_DOS_BASED_FILE_SYSTEM, but useable as an rvalue.  */
#if (HAVE_DOS_BASED_FILE_SYSTEM)
#  define DOS_BASED_FILE_SYSTEM 1
#else
#  define DOS_BASED_FILE_SYSTEM 0
#endif

/* Returns the full pathname of the shared library file, or NULL if
   not found.  (The pathname is malloc'ed; it needs to be freed by the
   caller.)  *FD is set to either -1 or an open file handle for the
   library.

   Global variable GDB_SYSROOT is used as a prefix directory
   to search for shared libraries if they have an absolute path.

   Global variable SOLIB_SEARCH_PATH is used as a prefix directory
   (or set of directories, as in LD_LIBRARY_PATH) to search for all
   shared libraries if not found in GDB_SYSROOT.

   Search algorithm:
   * If there is a gdb_sysroot and path is absolute:
   *   Search for gdb_sysroot/path.
   * else
   *   Look for it literally (unmodified).
   * Look in SOLIB_SEARCH_PATH.
   * If available, use target defined search function.
   * If gdb_sysroot is NOT set, perform the following two searches:
   *   Look in inferior's $PATH.
   *   Look in inferior's $LD_LIBRARY_PATH.
   *
   * The last check avoids doing this search when targetting remote
   * machines since gdb_sysroot will almost always be set.
*/

char *
solib_find (char *in_pathname, int *fd)
{
  const struct target_so_ops *ops = solib_ops (target_gdbarch ());
  int found_file = -1;
  char *temp_pathname = NULL;
  int gdb_sysroot_is_empty;
  const char *solib_symbols_extension
    = gdbarch_solib_symbols_extension (target_gdbarch ());
  const char *fskind = effective_target_file_system_kind ();
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
  char *sysroot = NULL;

  /* If solib_symbols_extension is set, replace the file's
     extension.  */
  if (solib_symbols_extension)
    {
      char *p = in_pathname + strlen (in_pathname);

      while (p > in_pathname && *p != '.')
	p--;

      if (*p == '.')
	{
	  char *new_pathname;

	  new_pathname = alloca (p - in_pathname + 1
				 + strlen (solib_symbols_extension) + 1);
	  memcpy (new_pathname, in_pathname, p - in_pathname + 1);
	  strcpy (new_pathname + (p - in_pathname) + 1,
		  solib_symbols_extension);

	  in_pathname = new_pathname;
	}
    }

  gdb_sysroot_is_empty = (gdb_sysroot == NULL || *gdb_sysroot == 0);

  if (!gdb_sysroot_is_empty)
    {
      int prefix_len = strlen (gdb_sysroot);

      /* Remove trailing slashes from absolute prefix.  */
      while (prefix_len > 0
	     && IS_DIR_SEPARATOR (gdb_sysroot[prefix_len - 1]))
	prefix_len--;

      sysroot = savestring (gdb_sysroot, prefix_len);
      make_cleanup (xfree, sysroot);
    }

  /* If we're on a non-DOS-based system, backslashes won't be
     understood as directory separator, so, convert them to forward
     slashes, iff we're supposed to handle DOS-based file system
     semantics for target paths.  */
  if (!DOS_BASED_FILE_SYSTEM && fskind == file_system_kind_dos_based)
    {
      char *p;

      /* Avoid clobbering our input.  */
      p = alloca (strlen (in_pathname) + 1);
      strcpy (p, in_pathname);
      in_pathname = p;

      for (; *p; p++)
	{
	  if (*p == '\\')
	    *p = '/';
	}
    }

  /* Note, we're interested in IS_TARGET_ABSOLUTE_PATH, not
     IS_ABSOLUTE_PATH.  The latter is for host paths only, while
     IN_PATHNAME is a target path.  For example, if we're supposed to
     be handling DOS-like semantics we want to consider a
     'c:/foo/bar.dll' path as an absolute path, even on a Unix box.
     With such a path, before giving up on the sysroot, we'll try:

       1st attempt, c:/foo/bar.dll ==> /sysroot/c:/foo/bar.dll
       2nd attempt, c:/foo/bar.dll ==> /sysroot/c/foo/bar.dll
       3rd attempt, c:/foo/bar.dll ==> /sysroot/foo/bar.dll
  */

  if (!IS_TARGET_ABSOLUTE_PATH (fskind, in_pathname) || gdb_sysroot_is_empty)
    temp_pathname = xstrdup (in_pathname);
  else
    {
      int need_dir_separator;

      /* Concatenate the sysroot and the target reported filename.  We
	 may need to glue them with a directory separator.  Cases to
	 consider:

        | sysroot         | separator | in_pathname    |
        |-----------------+-----------+----------------|
        | /some/dir       | /         | c:/foo/bar.dll |
        | /some/dir       |           | /foo/bar.dll   |
        | remote:         |           | c:/foo/bar.dll |
        | remote:         |           | /foo/bar.dll   |
        | remote:some/dir | /         | c:/foo/bar.dll |
        | remote:some/dir |           | /foo/bar.dll   |

	IOW, we don't need to add a separator if IN_PATHNAME already
	has one, or when the the sysroot is exactly "remote:".
	There's no need to check for drive spec explicitly, as we only
	get here if IN_PATHNAME is considered an absolute path.  */
      need_dir_separator = !(IS_DIR_SEPARATOR (in_pathname[0])
			     || strcmp (REMOTE_SYSROOT_PREFIX, sysroot) == 0);

      /* Cat the prefixed pathname together.  */
      temp_pathname = concat (sysroot,
			      need_dir_separator ? SLASH_STRING : "",
			      in_pathname, (char *) NULL);
    }

  /* Handle remote files.  */
  if (remote_filename_p (temp_pathname))
    {
      *fd = -1;
      do_cleanups (old_chain);
      return temp_pathname;
    }

  /* Now see if we can open it.  */
  found_file = gdb_open_cloexec (temp_pathname, O_RDONLY | O_BINARY, 0);
  if (found_file < 0)
    xfree (temp_pathname);

  /* If the search in gdb_sysroot failed, and the path name has a
     drive spec (e.g, c:/foo), try stripping ':' from the drive spec,
     and retrying in the sysroot:
       c:/foo/bar.dll ==> /sysroot/c/foo/bar.dll.  */

  if (found_file < 0
      && !gdb_sysroot_is_empty
      && HAS_TARGET_DRIVE_SPEC (fskind, in_pathname))
    {
      int need_dir_separator = !IS_DIR_SEPARATOR (in_pathname[2]);
      char *drive = savestring (in_pathname, 1);

      temp_pathname = concat (sysroot,
			      SLASH_STRING,
			      drive,
			      need_dir_separator ? SLASH_STRING : "",
			      in_pathname + 2, (char *) NULL);
      xfree (drive);

      found_file = gdb_open_cloexec (temp_pathname, O_RDONLY | O_BINARY, 0);
      if (found_file < 0)
	{
	  xfree (temp_pathname);

	  /* If the search in gdb_sysroot still failed, try fully
	     stripping the drive spec, and trying once more in the
	     sysroot before giving up.

	     c:/foo/bar.dll ==> /sysroot/foo/bar.dll.  */

	  temp_pathname = concat (sysroot,
				  need_dir_separator ? SLASH_STRING : "",
				  in_pathname + 2, (char *) NULL);

	  found_file = gdb_open_cloexec (temp_pathname, O_RDONLY | O_BINARY, 0);
	  if (found_file < 0)
	    xfree (temp_pathname);
	}
    }

  do_cleanups (old_chain);

  /* We try to find the library in various ways.  After each attempt,
     either found_file >= 0 and temp_pathname is a malloc'd string, or
     found_file < 0 and temp_pathname does not point to storage that
     needs to be freed.  */

  if (found_file < 0)
    temp_pathname = NULL;

  /* If the search in gdb_sysroot failed, and the path name is
     absolute at this point, make it relative.  (openp will try and open the
     file according to its absolute path otherwise, which is not what we want.)
     Affects subsequent searches for this solib.  */
  if (found_file < 0 && IS_TARGET_ABSOLUTE_PATH (fskind, in_pathname))
    {
      /* First, get rid of any drive letters etc.  */
      while (!IS_TARGET_DIR_SEPARATOR (fskind, *in_pathname))
	in_pathname++;

      /* Next, get rid of all leading dir separators.  */
      while (IS_TARGET_DIR_SEPARATOR (fskind, *in_pathname))
	in_pathname++;
    }

  /* If not found, search the solib_search_path (if any).  */
  if (found_file < 0 && solib_search_path != NULL)
    found_file = openp (solib_search_path,
			OPF_TRY_CWD_FIRST | OPF_RETURN_REALPATH,
			in_pathname, O_RDONLY | O_BINARY, &temp_pathname);

  /* If not found, next search the solib_search_path (if any) for the basename
     only (ignoring the path).  This is to allow reading solibs from a path
     that differs from the opened path.  */
  if (found_file < 0 && solib_search_path != NULL)
    found_file = openp (solib_search_path,
			OPF_TRY_CWD_FIRST | OPF_RETURN_REALPATH,
			target_lbasename (fskind, in_pathname),
			O_RDONLY | O_BINARY, &temp_pathname);

  /* If not found, try to use target supplied solib search method.  */
  if (found_file < 0 && ops->find_and_open_solib)
    found_file = ops->find_and_open_solib (in_pathname, O_RDONLY | O_BINARY,
					   &temp_pathname);

  /* If not found, next search the inferior's $PATH environment variable.  */
  if (found_file < 0 && gdb_sysroot_is_empty)
    found_file = openp (get_in_environ (current_inferior ()->environment,
					"PATH"),
			OPF_TRY_CWD_FIRST | OPF_RETURN_REALPATH, in_pathname,
			O_RDONLY | O_BINARY, &temp_pathname);

  /* If not found, next search the inferior's $LD_LIBRARY_PATH
     environment variable.  */
  if (found_file < 0 && gdb_sysroot_is_empty)
    found_file = openp (get_in_environ (current_inferior ()->environment,
					"LD_LIBRARY_PATH"),
			OPF_TRY_CWD_FIRST | OPF_RETURN_REALPATH, in_pathname,
			O_RDONLY | O_BINARY, &temp_pathname);

  *fd = found_file;
  return temp_pathname;
}

/* Open and return a BFD for the shared library PATHNAME.  If FD is not -1,
   it is used as file handle to open the file.  Throws an error if the file
   could not be opened.  Handles both local and remote file access.

   PATHNAME must be malloc'ed by the caller.  It will be freed by this
   function.  If unsuccessful, the FD will be closed (unless FD was
   -1).  */

bfd *
solib_bfd_fopen (char *pathname, int fd)
{
  bfd *abfd;

  if (remote_filename_p (pathname))
    {
      gdb_assert (fd == -1);
      abfd = remote_bfd_open (pathname, gnutarget);
    }
  else
    {
      abfd = gdb_bfd_open (pathname, gnutarget, fd);

      if (abfd)
	bfd_set_cacheable (abfd, 1);
    }

  if (!abfd)
    {
      make_cleanup (xfree, pathname);
      error (_("Could not open `%s' as an executable file: %s"),
	     pathname, bfd_errmsg (bfd_get_error ()));
    }

  xfree (pathname);

  return abfd;
}

/* Find shared library PATHNAME and open a BFD for it.  */

bfd *
solib_bfd_open (char *pathname)
{
  char *found_pathname;
  int found_file;
  bfd *abfd;
  const struct bfd_arch_info *b;

  /* Search for shared library file.  */
  found_pathname = solib_find (pathname, &found_file);
  if (found_pathname == NULL)
    {
      /* Return failure if the file could not be found, so that we can
	 accumulate messages about missing libraries.  */
      if (errno == ENOENT)
	return NULL;

      perror_with_name (pathname);
    }

  /* Open bfd for shared library.  */
  abfd = solib_bfd_fopen (found_pathname, found_file);

  /* Check bfd format.  */
  if (!bfd_check_format (abfd, bfd_object))
    {
      make_cleanup_bfd_unref (abfd);
      error (_("`%s': not in executable format: %s"),
	     bfd_get_filename (abfd), bfd_errmsg (bfd_get_error ()));
    }

  /* Check bfd arch.  */
  b = gdbarch_bfd_arch_info (target_gdbarch ());
  if (!b->compatible (b, bfd_get_arch_info (abfd)))
    warning (_("`%s': Shared library architecture %s is not compatible "
               "with target architecture %s."), bfd_get_filename (abfd),
             bfd_get_arch_info (abfd)->printable_name, b->printable_name);

  return abfd;
}

/* Given a pointer to one of the shared objects in our list of mapped
   objects, use the recorded name to open a bfd descriptor for the
   object, build a section table, relocate all the section addresses
   by the base address at which the shared object was mapped, and then
   add the sections to the target's section table.

   FIXME: In most (all?) cases the shared object file name recorded in
   the dynamic linkage tables will be a fully qualified pathname.  For
   cases where it isn't, do we really mimic the systems search
   mechanism correctly in the below code (particularly the tilde
   expansion stuff?).  */

static int
solib_map_sections (struct so_list *so)
{
  const struct target_so_ops *ops = solib_ops (target_gdbarch ());
  char *filename;
  struct target_section *p;
  struct cleanup *old_chain;
  bfd *abfd;

  filename = tilde_expand (so->so_name);
  old_chain = make_cleanup (xfree, filename);
  abfd = ops->bfd_open (filename);
  do_cleanups (old_chain);

  if (abfd == NULL)
    return 0;

  /* Leave bfd open, core_xfer_memory and "info files" need it.  */
  so->abfd = abfd;

  if (build_section_table (abfd, &so->sections, &so->sections_end))
    {
      error (_("Can't find the file sections in `%s': %s"),
	     bfd_get_filename (abfd), bfd_errmsg (bfd_get_error ()));
    }

  for (p = so->sections; p < so->sections_end; p++)
    {
      /* Relocate the section binding addresses as recorded in the shared
         object's file by the base address to which the object was actually
         mapped.  */
      ops->relocate_section_addresses (so, p);

      /* If the target didn't provide information about the address
	 range of the shared object, assume we want the location of
	 the .text section.  */
      if (so->addr_low == 0 && so->addr_high == 0
	  && strcmp (p->the_bfd_section->name, ".text") == 0)
	{
	  so->addr_low = p->addr;
	  so->addr_high = p->endaddr;
	}
    }

  /* Add the shared object's sections to the current set of file
     section tables.  Do this immediately after mapping the object so
     that later nodes in the list can query this object, as is needed
     in solib-osf.c.  */
  add_target_sections (so, so->sections, so->sections_end);

  return 1;
}

/* Free symbol-file related contents of SO and reset for possible reloading
   of SO.  If we have opened a BFD for SO, close it.  If we have placed SO's
   sections in some target's section table, the caller is responsible for
   removing them.

   This function doesn't mess with objfiles at all.  If there is an
   objfile associated with SO that needs to be removed, the caller is
   responsible for taking care of that.  */

static void
clear_so (struct so_list *so)
{
  const struct target_so_ops *ops = solib_ops (target_gdbarch ());

  if (so->sections)
    {
      xfree (so->sections);
      so->sections = so->sections_end = NULL;
    }

  gdb_bfd_unref (so->abfd);
  so->abfd = NULL;

  /* Our caller closed the objfile, possibly via objfile_purge_solibs.  */
  so->symbols_loaded = 0;
  so->objfile = NULL;

  so->addr_low = so->addr_high = 0;

  /* Restore the target-supplied file name.  SO_NAME may be the path
     of the symbol file.  */
  strcpy (so->so_name, so->so_original_name);

  /* Do the same for target-specific data.  */
  if (ops->clear_so != NULL)
    ops->clear_so (so);
}

/* Free the storage associated with the `struct so_list' object SO.
   If we have opened a BFD for SO, close it.

   The caller is responsible for removing SO from whatever list it is
   a member of.  If we have placed SO's sections in some target's
   section table, the caller is responsible for removing them.

   This function doesn't mess with objfiles at all.  If there is an
   objfile associated with SO that needs to be removed, the caller is
   responsible for taking care of that.  */

void
free_so (struct so_list *so)
{
  const struct target_so_ops *ops = solib_ops (target_gdbarch ());

  clear_so (so);
  ops->free_so (so);

  xfree (so);
}


/* Return address of first so_list entry in master shared object list.  */
struct so_list *
master_so_list (void)
{
  return so_list_head;
}

/* Read in symbols for shared object SO.  If SYMFILE_VERBOSE is set in FLAGS,
   be chatty about it.  Return non-zero if any symbols were actually
   loaded.  */

int
solib_read_symbols (struct so_list *so, int flags)
{
  const int from_tty = flags & SYMFILE_VERBOSE;

  if (so->symbols_loaded)
    {
      /* If needed, we've already warned in our caller.  */
    }
  else if (so->abfd == NULL)
    {
      /* We've already warned about this library, when trying to open
	 it.  */
    }
  else
    {
      volatile struct gdb_exception e;

      flags |= current_inferior ()->symfile_flags;

      TRY_CATCH (e, RETURN_MASK_ERROR)
	{
	  struct section_addr_info *sap;

	  /* Have we already loaded this shared object?  */
	  ALL_OBJFILES (so->objfile)
	    {
	      if (filename_cmp (objfile_name (so->objfile), so->so_name) == 0
		  && so->objfile->addr_low == so->addr_low)
		break;
	    }
	  if (so->objfile != NULL)
	    break;

	  sap = build_section_addr_info_from_section_table (so->sections,
							    so->sections_end);
	  so->objfile = symbol_file_add_from_bfd (so->abfd, so->so_name,
						  flags, sap, OBJF_SHARED,
						  NULL);
	  so->objfile->addr_low = so->addr_low;
	  free_section_addr_info (sap);
	}

      if (e.reason < 0)
	exception_fprintf (gdb_stderr, e, _("Error while reading shared"
					    " library symbols for %s:\n"),
			   so->so_name);
      else
	{
	  if (from_tty || info_verbose)
	    printf_unfiltered (_("Loaded symbols for %s\n"), so->so_name);
	  so->symbols_loaded = 1;
	}
      return 1;
    }

  return 0;
}

/* Return 1 if KNOWN->objfile is used by any other so_list object in the
   SO_LIST_HEAD list.  Return 0 otherwise.  */

static int
solib_used (const struct so_list *const known)
{
  const struct so_list *pivot;

  for (pivot = so_list_head; pivot != NULL; pivot = pivot->next)
    if (pivot != known && pivot->objfile == known->objfile)
      return 1;
  return 0;
}

/* Synchronize GDB's shared object list with inferior's.

   Extract the list of currently loaded shared objects from the
   inferior, and compare it with the list of shared objects currently
   in GDB's so_list_head list.  Edit so_list_head to bring it in sync
   with the inferior's new list.

   If we notice that the inferior has unloaded some shared objects,
   free any symbolic info GDB had read about those shared objects.

   Don't load symbolic info for any new shared objects; just add them
   to the list, and leave their symbols_loaded flag clear.

   If FROM_TTY is non-null, feel free to print messages about what
   we're doing.

   If TARGET is non-null, add the sections of all new shared objects
   to TARGET's section table.  Note that this doesn't remove any
   sections for shared objects that have been unloaded, and it
   doesn't check to see if the new shared objects are already present in
   the section table.  But we only use this for core files and
   processes we've just attached to, so that's okay.  */

static void
update_solib_list (int from_tty, struct target_ops *target)
{
  const struct target_so_ops *ops = solib_ops (target_gdbarch ());
  struct so_list *inferior = ops->current_sos();
  struct so_list *gdb, **gdb_link;

  /* We can reach here due to changing solib-search-path or the
     sysroot, before having any inferior.  */
  if (target_has_execution && !ptid_equal (inferior_ptid, null_ptid))
    {
      struct inferior *inf = current_inferior ();

      /* If we are attaching to a running process for which we
	 have not opened a symbol file, we may be able to get its
	 symbols now!  */
      if (inf->attach_flag && symfile_objfile == NULL)
	catch_errors (ops->open_symbol_file_object, &from_tty,
		      "Error reading attached process's symbol file.\n",
		      RETURN_MASK_ALL);
    }

  /* GDB and the inferior's dynamic linker each maintain their own
     list of currently loaded shared objects; we want to bring the
     former in sync with the latter.  Scan both lists, seeing which
     shared objects appear where.  There are three cases:

     - A shared object appears on both lists.  This means that GDB
     knows about it already, and it's still loaded in the inferior.
     Nothing needs to happen.

     - A shared object appears only on GDB's list.  This means that
     the inferior has unloaded it.  We should remove the shared
     object from GDB's tables.

     - A shared object appears only on the inferior's list.  This
     means that it's just been loaded.  We should add it to GDB's
     tables.

     So we walk GDB's list, checking each entry to see if it appears
     in the inferior's list too.  If it does, no action is needed, and
     we remove it from the inferior's list.  If it doesn't, the
     inferior has unloaded it, and we remove it from GDB's list.  By
     the time we're done walking GDB's list, the inferior's list
     contains only the new shared objects, which we then add.  */

  gdb = so_list_head;
  gdb_link = &so_list_head;
  while (gdb)
    {
      struct so_list *i = inferior;
      struct so_list **i_link = &inferior;

      /* Check to see whether the shared object *gdb also appears in
	 the inferior's current list.  */
      while (i)
	{
	  if (ops->same)
	    {
	      if (ops->same (gdb, i))
		break;
	    }
	  else
	    {
	      if (! filename_cmp (gdb->so_original_name, i->so_original_name))
		break;	      
	    }

	  i_link = &i->next;
	  i = *i_link;
	}

      /* If the shared object appears on the inferior's list too, then
         it's still loaded, so we don't need to do anything.  Delete
         it from the inferior's list, and leave it on GDB's list.  */
      if (i)
	{
	  *i_link = i->next;
	  free_so (i);
	  gdb_link = &gdb->next;
	  gdb = *gdb_link;
	}

      /* If it's not on the inferior's list, remove it from GDB's tables.  */
      else
	{
	  /* Notify any observer that the shared object has been
	     unloaded before we remove it from GDB's tables.  */
	  observer_notify_solib_unloaded (gdb);

	  VEC_safe_push (char_ptr, current_program_space->deleted_solibs,
			 xstrdup (gdb->so_name));

	  *gdb_link = gdb->next;

	  /* Unless the user loaded it explicitly, free SO's objfile.  */
	  if (gdb->objfile && ! (gdb->objfile->flags & OBJF_USERLOADED)
	      && !solib_used (gdb))
	    free_objfile (gdb->objfile);

	  /* Some targets' section tables might be referring to
	     sections from so->abfd; remove them.  */
	  remove_target_sections (gdb);

	  free_so (gdb);
	  gdb = *gdb_link;
	}
    }

  /* Now the inferior's list contains only shared objects that don't
     appear in GDB's list --- those that are newly loaded.  Add them
     to GDB's shared object list.  */
  if (inferior)
    {
      int not_found = 0;
      const char *not_found_filename = NULL;

      struct so_list *i;

      /* Add the new shared objects to GDB's list.  */
      *gdb_link = inferior;

      /* Fill in the rest of each of the `struct so_list' nodes.  */
      for (i = inferior; i; i = i->next)
	{
	  volatile struct gdb_exception e;

	  i->pspace = current_program_space;
	  VEC_safe_push (so_list_ptr, current_program_space->added_solibs, i);

	  TRY_CATCH (e, RETURN_MASK_ERROR)
	    {
	      /* Fill in the rest of the `struct so_list' node.  */
	      if (!solib_map_sections (i))
		{
		  not_found++;
		  if (not_found_filename == NULL)
		    not_found_filename = i->so_original_name;
		}
	    }

	  if (e.reason < 0)
	    exception_fprintf (gdb_stderr, e,
			       _("Error while mapping shared "
				 "library sections:\n"));

	  /* Notify any observer that the shared object has been
	     loaded now that we've added it to GDB's tables.  */
	  observer_notify_solib_loaded (i);
	}

      /* If a library was not found, issue an appropriate warning
	 message.  We have to use a single call to warning in case the
	 front end does something special with warnings, e.g., pop up
	 a dialog box.  It Would Be Nice if we could get a "warning: "
	 prefix on each line in the CLI front end, though - it doesn't
	 stand out well.  */

      if (not_found == 1)
	warning (_("Could not load shared library symbols for %s.\n"
		   "Do you need \"set solib-search-path\" "
		   "or \"set sysroot\"?"),
		 not_found_filename);
      else if (not_found > 1)
	warning (_("\
Could not load shared library symbols for %d libraries, e.g. %s.\n\
Use the \"info sharedlibrary\" command to see the complete listing.\n\
Do you need \"set solib-search-path\" or \"set sysroot\"?"),
		 not_found, not_found_filename);
    }
}


/* Return non-zero if NAME is the libpthread shared library.

   Uses a fairly simplistic heuristic approach where we check
   the file name against "/libpthread".  This can lead to false
   positives, but this should be good enough in practice.  */

int
libpthread_name_p (const char *name)
{
  return (strstr (name, "/libpthread") != NULL);
}

/* Return non-zero if SO is the libpthread shared library.  */

static int
libpthread_solib_p (struct so_list *so)
{
  return libpthread_name_p (so->so_name);
}

/* Read in symbolic information for any shared objects whose names
   match PATTERN.  (If we've already read a shared object's symbol
   info, leave it alone.)  If PATTERN is zero, read them all.

   If READSYMS is 0, defer reading symbolic information until later
   but still do any needed low level processing.

   FROM_TTY and TARGET are as described for update_solib_list, above.  */

void
solib_add (char *pattern, int from_tty,
	   struct target_ops *target, int readsyms)
{
  struct so_list *gdb;

  current_program_space->solib_add_generation++;

  if (pattern)
    {
      char *re_err = re_comp (pattern);

      if (re_err)
	error (_("Invalid regexp: %s"), re_err);
    }

  update_solib_list (from_tty, target);

  /* Walk the list of currently loaded shared libraries, and read
     symbols for any that match the pattern --- or any whose symbols
     aren't already loaded, if no pattern was given.  */
  {
    int any_matches = 0;
    int loaded_any_symbols = 0;
    const int flags =
        SYMFILE_DEFER_BP_RESET | (from_tty ? SYMFILE_VERBOSE : 0);

    for (gdb = so_list_head; gdb; gdb = gdb->next)
      if (! pattern || re_exec (gdb->so_name))
	{
          /* Normally, we would read the symbols from that library
             only if READSYMS is set.  However, we're making a small
             exception for the pthread library, because we sometimes
             need the library symbols to be loaded in order to provide
             thread support (x86-linux for instance).  */
          const int add_this_solib =
            (readsyms || libpthread_solib_p (gdb));

	  any_matches = 1;
	  if (add_this_solib)
	    {
	      if (gdb->symbols_loaded)
		{
		  /* If no pattern was given, be quiet for shared
		     libraries we have already loaded.  */
		  if (pattern && (from_tty || info_verbose))
		    printf_unfiltered (_("Symbols already loaded for %s\n"),
				       gdb->so_name);
		}
	      else if (solib_read_symbols (gdb, flags))
		loaded_any_symbols = 1;
	    }
	}

    if (loaded_any_symbols)
      breakpoint_re_set ();

    if (from_tty && pattern && ! any_matches)
      printf_unfiltered
	("No loaded shared libraries match the pattern `%s'.\n", pattern);

    if (loaded_any_symbols)
      {
	const struct target_so_ops *ops = solib_ops (target_gdbarch ());

	/* Getting new symbols may change our opinion about what is
	   frameless.  */
	reinit_frame_cache ();

	ops->special_symbol_handling ();
      }
  }
}

/* Implement the "info sharedlibrary" command.  Walk through the
   shared library list and print information about each attached
   library matching PATTERN.  If PATTERN is elided, print them
   all.  */

static void
info_sharedlibrary_command (char *pattern, int from_tty)
{
  struct so_list *so = NULL;	/* link map state variable */
  int so_missing_debug_info = 0;
  int addr_width;
  int nr_libs;
  struct cleanup *table_cleanup;
  struct gdbarch *gdbarch = target_gdbarch ();
  struct ui_out *uiout = current_uiout;

  if (pattern)
    {
      char *re_err = re_comp (pattern);

      if (re_err)
	error (_("Invalid regexp: %s"), re_err);
    }

  /* "0x", a little whitespace, and two hex digits per byte of pointers.  */
  addr_width = 4 + (gdbarch_ptr_bit (gdbarch) / 4);

  update_solib_list (from_tty, 0);

  /* make_cleanup_ui_out_table_begin_end needs to know the number of
     rows, so we need to make two passes over the libs.  */

  for (nr_libs = 0, so = so_list_head; so; so = so->next)
    {
      if (so->so_name[0])
	{
	  if (pattern && ! re_exec (so->so_name))
	    continue;
	  ++nr_libs;
	}
    }

  table_cleanup =
    make_cleanup_ui_out_table_begin_end (uiout, 4, nr_libs,
					 "SharedLibraryTable");

  /* The "- 1" is because ui_out adds one space between columns.  */
  ui_out_table_header (uiout, addr_width - 1, ui_left, "from", "From");
  ui_out_table_header (uiout, addr_width - 1, ui_left, "to", "To");
  ui_out_table_header (uiout, 12 - 1, ui_left, "syms-read", "Syms Read");
  ui_out_table_header (uiout, 0, ui_noalign,
		       "name", "Shared Object Library");

  ui_out_table_body (uiout);

  for (so = so_list_head; so; so = so->next)
    {
      struct cleanup *lib_cleanup;

      if (! so->so_name[0])
	continue;
      if (pattern && ! re_exec (so->so_name))
	continue;

      lib_cleanup = make_cleanup_ui_out_tuple_begin_end (uiout, "lib");

      if (so->addr_high != 0)
	{
	  ui_out_field_core_addr (uiout, "from", gdbarch, so->addr_low);
	  ui_out_field_core_addr (uiout, "to", gdbarch, so->addr_high);
	}
      else
	{
	  ui_out_field_skip (uiout, "from");
	  ui_out_field_skip (uiout, "to");
	}

      if (! ui_out_is_mi_like_p (interp_ui_out (top_level_interpreter ()))
	  && so->symbols_loaded
	  && !objfile_has_symbols (so->objfile))
	{
	  so_missing_debug_info = 1;
	  ui_out_field_string (uiout, "syms-read", "Yes (*)");
	}
      else
	ui_out_field_string (uiout, "syms-read", 
			     so->symbols_loaded ? "Yes" : "No");

      ui_out_field_string (uiout, "name", so->so_name);

      ui_out_text (uiout, "\n");

      do_cleanups (lib_cleanup);
    }

  do_cleanups (table_cleanup);

  if (nr_libs == 0)
    {
      if (pattern)
	ui_out_message (uiout, 0,
			_("No shared libraries matched.\n"));
      else
	ui_out_message (uiout, 0,
			_("No shared libraries loaded at this time.\n"));
    }
  else
    {
      if (so_missing_debug_info)
	ui_out_message (uiout, 0,
			_("(*): Shared library is missing "
			  "debugging information.\n"));
    }
}

/* Return 1 if ADDRESS lies within SOLIB.  */

int
solib_contains_address_p (const struct so_list *const solib,
			  CORE_ADDR address)
{
  struct target_section *p;

  for (p = solib->sections; p < solib->sections_end; p++)
    if (p->addr <= address && address < p->endaddr)
      return 1;

  return 0;
}

/* If ADDRESS is in a shared lib in program space PSPACE, return its
   name.

   Provides a hook for other gdb routines to discover whether or not a
   particular address is within the mapped address space of a shared
   library.

   For example, this routine is called at one point to disable
   breakpoints which are in shared libraries that are not currently
   mapped in.  */

char *
solib_name_from_address (struct program_space *pspace, CORE_ADDR address)
{
  struct so_list *so = NULL;

  for (so = pspace->so_list; so; so = so->next)
    if (solib_contains_address_p (so, address))
      return (so->so_name);

  return (0);
}

/* Return whether the data starting at VADDR, size SIZE, must be kept
   in a core file for shared libraries loaded before "gcore" is used
   to be handled correctly when the core file is loaded.  This only
   applies when the section would otherwise not be kept in the core
   file (in particular, for readonly sections).  */

int
solib_keep_data_in_core (CORE_ADDR vaddr, unsigned long size)
{
  const struct target_so_ops *ops = solib_ops (target_gdbarch ());

  if (ops->keep_data_in_core)
    return ops->keep_data_in_core (vaddr, size);
  else
    return 0;
}

/* Called by free_all_symtabs */

void
clear_solib (void)
{
  const struct target_so_ops *ops = solib_ops (target_gdbarch ());

  /* This function is expected to handle ELF shared libraries.  It is
     also used on Solaris, which can run either ELF or a.out binaries
     (for compatibility with SunOS 4), both of which can use shared
     libraries.  So we don't know whether we have an ELF executable or
     an a.out executable until the user chooses an executable file.

     ELF shared libraries don't get mapped into the address space
     until after the program starts, so we'd better not try to insert
     breakpoints in them immediately.  We have to wait until the
     dynamic linker has loaded them; we'll hit a bp_shlib_event
     breakpoint (look for calls to create_solib_event_breakpoint) when
     it's ready.

     SunOS shared libraries seem to be different --- they're present
     as soon as the process begins execution, so there's no need to
     put off inserting breakpoints.  There's also nowhere to put a
     bp_shlib_event breakpoint, so if we put it off, we'll never get
     around to it.

     So: disable breakpoints only if we're using ELF shared libs.  */
  if (exec_bfd != NULL
      && bfd_get_flavour (exec_bfd) != bfd_target_aout_flavour)
    disable_breakpoints_in_shlibs ();

  while (so_list_head)
    {
      struct so_list *so = so_list_head;

      so_list_head = so->next;
      observer_notify_solib_unloaded (so);
      remove_target_sections (so);
      free_so (so);
    }

  ops->clear_solib ();
}

/* Shared library startup support.  When GDB starts up the inferior,
   it nurses it along (through the shell) until it is ready to execute
   its first instruction.  At this point, this function gets
   called.  */

void
solib_create_inferior_hook (int from_tty)
{
  const struct target_so_ops *ops = solib_ops (target_gdbarch ());

  ops->solib_create_inferior_hook (from_tty);
}

/* Check to see if an address is in the dynamic loader's dynamic
   symbol resolution code.  Return 1 if so, 0 otherwise.  */

int
in_solib_dynsym_resolve_code (CORE_ADDR pc)
{
  const struct target_so_ops *ops = solib_ops (target_gdbarch ());

  return ops->in_dynsym_resolve_code (pc);
}

/* Implements the "sharedlibrary" command.  */

static void
sharedlibrary_command (char *args, int from_tty)
{
  dont_repeat ();
  solib_add (args, from_tty, (struct target_ops *) 0, 1);
}

/* Implements the command "nosharedlibrary", which discards symbols
   that have been auto-loaded from shared libraries.  Symbols from
   shared libraries that were added by explicit request of the user
   are not discarded.  Also called from remote.c.  */

void
no_shared_libraries (char *ignored, int from_tty)
{
  /* The order of the two routines below is important: clear_solib notifies
     the solib_unloaded observers, and some of these observers might need
     access to their associated objfiles.  Therefore, we can not purge the
     solibs' objfiles before clear_solib has been called.  */

  clear_solib ();
  objfile_purge_solibs ();
}

/* See solib.h.  */

void
update_solib_breakpoints (void)
{
  const struct target_so_ops *ops = solib_ops (target_gdbarch ());

  if (ops->update_breakpoints != NULL)
    ops->update_breakpoints ();
}

/* See solib.h.  */

void
handle_solib_event (void)
{
  const struct target_so_ops *ops = solib_ops (target_gdbarch ());

  if (ops->handle_event != NULL)
    ops->handle_event ();

  clear_program_space_solib_cache (current_inferior ()->pspace);

  /* Check for any newly added shared libraries if we're supposed to
     be adding them automatically.  Switch terminal for any messages
     produced by breakpoint_re_set.  */
  target_terminal_ours_for_output ();
  solib_add (NULL, 0, &current_target, auto_solib_add);
  target_terminal_inferior ();
}

/* Reload shared libraries, but avoid reloading the same symbol file
   we already have loaded.  */

static void
reload_shared_libraries_1 (int from_tty)
{
  struct so_list *so;
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);

  for (so = so_list_head; so != NULL; so = so->next)
    {
      char *filename, *found_pathname = NULL;
      bfd *abfd;
      int was_loaded = so->symbols_loaded;
      const int flags =
	SYMFILE_DEFER_BP_RESET | (from_tty ? SYMFILE_VERBOSE : 0);

      filename = tilde_expand (so->so_original_name);
      make_cleanup (xfree, filename);
      abfd = solib_bfd_open (filename);
      if (abfd != NULL)
	{
	  found_pathname = xstrdup (bfd_get_filename (abfd));
	  make_cleanup (xfree, found_pathname);
	  gdb_bfd_unref (abfd);
	}

      /* If this shared library is no longer associated with its previous
	 symbol file, close that.  */
      if ((found_pathname == NULL && was_loaded)
	  || (found_pathname != NULL
	      && filename_cmp (found_pathname, so->so_name) != 0))
	{
	  if (so->objfile && ! (so->objfile->flags & OBJF_USERLOADED)
	      && !solib_used (so))
	    free_objfile (so->objfile);
	  remove_target_sections (so);
	  clear_so (so);
	}

      /* If this shared library is now associated with a new symbol
	 file, open it.  */
      if (found_pathname != NULL
	  && (!was_loaded
	      || filename_cmp (found_pathname, so->so_name) != 0))
	{
	  volatile struct gdb_exception e;

	  TRY_CATCH (e, RETURN_MASK_ERROR)
	    solib_map_sections (so);

	  if (e.reason < 0)
	    exception_fprintf (gdb_stderr, e,
			       _("Error while mapping "
				 "shared library sections:\n"));
	  else if (auto_solib_add || was_loaded || libpthread_solib_p (so))
	    solib_read_symbols (so, flags);
	}
    }

  do_cleanups (old_chain);
}

static void
reload_shared_libraries (char *ignored, int from_tty,
			 struct cmd_list_element *e)
{
  const struct target_so_ops *ops;

  reload_shared_libraries_1 (from_tty);

  ops = solib_ops (target_gdbarch ());

  /* Creating inferior hooks here has two purposes.  First, if we reload 
     shared libraries then the address of solib breakpoint we've computed
     previously might be no longer valid.  For example, if we forgot to set
     solib-absolute-prefix and are setting it right now, then the previous
     breakpoint address is plain wrong.  Second, installing solib hooks
     also implicitly figures were ld.so is and loads symbols for it.
     Absent this call, if we've just connected to a target and set 
     solib-absolute-prefix or solib-search-path, we'll lose all information
     about ld.so.  */
  if (target_has_execution)
    {
      /* Reset or free private data structures not associated with
	 so_list entries.  */
      ops->clear_solib ();

      /* Remove any previous solib event breakpoint.  This is usually
	 done in common code, at breakpoint_init_inferior time, but
	 we're not really starting up the inferior here.  */
      remove_solib_event_breakpoints ();

      solib_create_inferior_hook (from_tty);
    }

  /* Sometimes the platform-specific hook loads initial shared
     libraries, and sometimes it doesn't.  If it doesn't FROM_TTY will be
     incorrectly 0 but such solib targets should be fixed anyway.  If we
     made all the inferior hook methods consistent, this call could be
     removed.  Call it only after the solib target has been initialized by
     solib_create_inferior_hook.  */

  solib_add (NULL, 0, NULL, auto_solib_add);

  breakpoint_re_set ();

  /* We may have loaded or unloaded debug info for some (or all)
     shared libraries.  However, frames may still reference them.  For
     example, a frame's unwinder might still point at DWARF FDE
     structures that are now freed.  Also, getting new symbols may
     change our opinion about what is frameless.  */
  reinit_frame_cache ();

  ops->special_symbol_handling ();
}

static void
show_auto_solib_add (struct ui_file *file, int from_tty,
		     struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Autoloading of shared library symbols is %s.\n"),
		    value);
}


/* Handler for library-specific lookup of global symbol NAME in OBJFILE.  Call
   the library-specific handler if it is installed for the current target.  */

struct symbol *
solib_global_lookup (const struct objfile *objfile,
		     const char *name,
		     const domain_enum domain)
{
  const struct target_so_ops *ops = solib_ops (target_gdbarch ());

  if (ops->lookup_lib_global_symbol != NULL)
    return ops->lookup_lib_global_symbol (objfile, name, domain);
  return NULL;
}

/* Lookup the value for a specific symbol from dynamic symbol table.  Look
   up symbol from ABFD.  MATCH_SYM is a callback function to determine
   whether to pick up a symbol.  DATA is the input of this callback
   function.  Return NULL if symbol is not found.  */

CORE_ADDR
gdb_bfd_lookup_symbol_from_symtab (bfd *abfd,
				   int (*match_sym) (asymbol *, void *),
				   void *data)
{
  long storage_needed = bfd_get_symtab_upper_bound (abfd);
  CORE_ADDR symaddr = 0;

  if (storage_needed > 0)
    {
      unsigned int i;

      asymbol **symbol_table = (asymbol **) xmalloc (storage_needed);
      struct cleanup *back_to = make_cleanup (xfree, symbol_table);
      unsigned int number_of_symbols =
	bfd_canonicalize_symtab (abfd, symbol_table);

      for (i = 0; i < number_of_symbols; i++)
	{
	  asymbol *sym  = *symbol_table++;

	  if (match_sym (sym, data))
	    {
	      /* BFD symbols are section relative.  */
	      symaddr = sym->value + sym->section->vma;
	      break;
	    }
	}
      do_cleanups (back_to);
    }

  return symaddr;
}

/* Lookup the value for a specific symbol from symbol table.  Look up symbol
   from ABFD.  MATCH_SYM is a callback function to determine whether to pick
   up a symbol.  DATA is the input of this callback function.  Return NULL
   if symbol is not found.  */

static CORE_ADDR
bfd_lookup_symbol_from_dyn_symtab (bfd *abfd,
				   int (*match_sym) (asymbol *, void *),
				   void *data)
{
  long storage_needed = bfd_get_dynamic_symtab_upper_bound (abfd);
  CORE_ADDR symaddr = 0;

  if (storage_needed > 0)
    {
      unsigned int i;
      asymbol **symbol_table = (asymbol **) xmalloc (storage_needed);
      struct cleanup *back_to = make_cleanup (xfree, symbol_table);
      unsigned int number_of_symbols =
	bfd_canonicalize_dynamic_symtab (abfd, symbol_table);

      for (i = 0; i < number_of_symbols; i++)
	{
	  asymbol *sym = *symbol_table++;

	  if (match_sym (sym, data))
	    {
	      /* BFD symbols are section relative.  */
	      symaddr = sym->value + sym->section->vma;
	      break;
	    }
	}
      do_cleanups (back_to);
    }
  return symaddr;
}

/* Lookup the value for a specific symbol from symbol table and dynamic
   symbol table.  Look up symbol from ABFD.  MATCH_SYM is a callback
   function to determine whether to pick up a symbol.  DATA is the
   input of this callback function.  Return NULL if symbol is not
   found.  */

CORE_ADDR
gdb_bfd_lookup_symbol (bfd *abfd,
		       int (*match_sym) (asymbol *, void *),
		       void *data)
{
  CORE_ADDR symaddr = gdb_bfd_lookup_symbol_from_symtab (abfd, match_sym, data);

  /* On FreeBSD, the dynamic linker is stripped by default.  So we'll
     have to check the dynamic string table too.  */
  if (symaddr == 0)
    symaddr = bfd_lookup_symbol_from_dyn_symtab (abfd, match_sym, data);

  return symaddr;
}

extern initialize_file_ftype _initialize_solib; /* -Wmissing-prototypes */

void
_initialize_solib (void)
{
  solib_data = gdbarch_data_register_pre_init (solib_init);

  add_com ("sharedlibrary", class_files, sharedlibrary_command,
	   _("Load shared object library symbols for files matching REGEXP."));
  add_info ("sharedlibrary", info_sharedlibrary_command,
	    _("Status of loaded shared object libraries."));
  add_com ("nosharedlibrary", class_files, no_shared_libraries,
	   _("Unload all shared object library symbols."));

  add_setshow_boolean_cmd ("auto-solib-add", class_support,
			   &auto_solib_add, _("\
Set autoloading of shared library symbols."), _("\
Show autoloading of shared library symbols."), _("\
If \"on\", symbols from all shared object libraries will be loaded\n\
automatically when the inferior begins execution, when the dynamic linker\n\
informs gdb that a new library has been loaded, or when attaching to the\n\
inferior.  Otherwise, symbols must be loaded manually, using \
`sharedlibrary'."),
			   NULL,
			   show_auto_solib_add,
			   &setlist, &showlist);

  add_setshow_filename_cmd ("sysroot", class_support,
			    &gdb_sysroot, _("\
Set an alternate system root."), _("\
Show the current system root."), _("\
The system root is used to load absolute shared library symbol files.\n\
For other (relative) files, you can add directories using\n\
`set solib-search-path'."),
			    reload_shared_libraries,
			    NULL,
			    &setlist, &showlist);

  add_alias_cmd ("solib-absolute-prefix", "sysroot", class_support, 0,
		 &setlist);
  add_alias_cmd ("solib-absolute-prefix", "sysroot", class_support, 0,
		 &showlist);

  add_setshow_optional_filename_cmd ("solib-search-path", class_support,
				     &solib_search_path, _("\
Set the search path for loading non-absolute shared library symbol files."),
				     _("\
Show the search path for loading non-absolute shared library symbol files."),
				     _("\
This takes precedence over the environment variables \
PATH and LD_LIBRARY_PATH."),
				     reload_shared_libraries,
				     show_solib_search_path,
				     &setlist, &showlist);
}
@


1.180
log
@Keep objfile original filename

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Pass down original filename for objfile.
	* coffread.c (coff_symfile_read): Update symbol_file_add_separate call.
	* elfread.c (elf_symfile_read): Likewise.
	* jit.c (jit_object_close_impl): Update allocate_objfile call, no
	longer set ORIGINAL_NAME.
	(jit_bfd_try_read_symtab): Update symbol_file_add_from_bfd call.
	* jv-lang.c (get_dynamics_objfile): Update allocate_objfile call.
	* machoread.c (macho_add_oso_symfile): Add parameter name.  Update
	symbol_file_add_from_bfd call.
	(macho_symfile_read_all_oso): Update two macho_add_oso_symfile calls.
	(macho_check_dsym): Add parameter filenamep.  Change function comment.
	Set *filenamep.
	(macho_symfile_read): New variable dsym_filename.  Update
	macho_check_dsym call.  Use it for symbol_file_add_separate.
	* objfiles.c (allocate_objfile): Add parameter name.  New comment for
	it.  Use it for objfile->original_name.
	(objfile_name): Return OBFD's filename, if available.
	* objfiles.h (allocate_objfile): Add new parameter name.
	* solib.c (solib_read_symbols): Update symbol_file_add_from_bfd call.
	* symfile-mem.c (symbol_file_add_from_memory): Update
	symbol_file_add_from_bfd call.
	* symfile.c (read_symbols): Update symbol_file_add_separate call, new
	comment for it.
	(symbol_file_add_with_addrs): New parameter name, add function comment
	for it.  Remove variable name.  Update allocate_objfile call.
	(symbol_file_add_separate): New parameter name, add function comment
	for it.  Update symbol_file_add_with_addrs call.
	(symbol_file_add_from_bfd): New parameter name.  Update
	symbol_file_add_with_addrs call.
	(symbol_file_add): Update symbol_file_add_from_bfd call.
	(reread_symbols): New variable original_name.  Save
	objfile->original_name by it.
	* symfile.h (symbol_file_add_from_bfd, symbol_file_add_separate): Add
	second parameter.
@
text
@d233 19
a251 2
      need_dir_separator = (!IS_DIR_SEPARATOR (in_pathname[0])
			    && !HAS_TARGET_DRIVE_SPEC (fskind, in_pathname));
@


1.179
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@d613 1
a613 1
	  so->objfile = symbol_file_add_from_bfd (so->abfd,
@


1.178
log
@Code cleanup: Change OPF_DISABLE_REALPATH to OPF_RETURN_REALPATH.

gdb/
2013-09-04  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Change OPF_DISABLE_REALPATH to OPF_RETURN_REALPATH.
	* cli/cli-cmds.c (find_and_open_script): Add OPF_RETURN_REALPATH to
	variable search_flags.
	* defs.h (OPF_DISABLE_REALPATH): Rename to ...
	(OPF_RETURN_REALPATH): ... here.
	* dwarf2read.c (try_open_dwop_file): Set OPF_RETURN_REALPATH for flags.
	* exec.c (exec_file_attach): Remove OPF_DISABLE_REALPATH from openp
	call.  Twice.
	* nto-tdep.c (nto_find_and_open_solib): Add OPF_RETURN_REALPATH for
	openp call.
	* solib.c (solib_find): Likewise.  Four times.
	* source.c (openp): Change OPF_DISABLE_REALPATH to OPF_RETURN_REALPATH
	in the function comment and for the realpath_fptr variable.
	(source_full_path_of): Add OPF_RETURN_REALPATH for openp call.
	(find_and_open_source): Likewise.  Twice.
	* symfile.c (symfile_bfd_open): Likewise, also twice.
@
text
@d604 1
a604 1
	      if (filename_cmp (so->objfile->name, so->so_name) == 0
@


1.177
log
@2013-07-22  Doug Evans  <dje@@google.com>

gdb/
	* exec.h (remove_target_sections): Delete arg abfd.
	* exec.c (remove_target_sections): Delete arg abfd.
	(exec_close): Update call to remove_target_sections.
	* solib.c (update_solib_list): Ditto.
	(reload_shared_libraries_1): Ditto.
	(clear_solib): Ditto, and unconditionally call remove_target_sections.
@
text
@d322 2
a323 1
    found_file = openp (solib_search_path, OPF_TRY_CWD_FIRST,
d330 2
a331 1
    found_file = openp (solib_search_path, OPF_TRY_CWD_FIRST,
d344 2
a345 2
			OPF_TRY_CWD_FIRST, in_pathname, O_RDONLY | O_BINARY,
			&temp_pathname);
d352 2
a353 2
			OPF_TRY_CWD_FIRST, in_pathname, O_RDONLY | O_BINARY,
			&temp_pathname);
@


1.176
log
@2013-06-04  Gary Benson  <gbenson@@redhat.com>

	* breakpoint.h (handle_solib_event): Moved function declaration
	to solib.h.
	* breakpoint.c (handle_solib_event): Moved function to solib.c.
	(bpstat_stop_status): Pass new argument to handle_solib_event.
	* solib.h (update_solib_breakpoints): New function declaration.
	(handle_solib_event): Moved function declaration from
	breakpoint.h.
	* solib.c (update_solib_breakpoints): New function.
	(handle_solib_event): Moved function from breakpoint.c.
	Updated to call solib_ops->handle_event if not NULL.
	* solist.h (target_so_ops): New fields "update_breakpoints" and
	"handle_event".
	* infrun.c (set_stop_on_solib_events): New function.
	(_initialize_infrun): Use the above for "set
	stop-on-solib-events".
	(handle_inferior_event): Pass new argument to handle_solib_event.
	* solib-svr4.c (probe.h): New include.
	(svr4_free_library_list): New forward declaration.
	(probe_action): New enum.
	(probe_info): New struct.
	(probe_info): New static variable.
	(NUM_PROBES): New definition.
	(svr4_info): New fields "using_xfer", "probes_table" and
	"solib_list".
	(free_probes_table): New function.
	(free_solib_list): New function.
	(svr4_pspace_data_cleanup): Free probes table and solib list.
	(svr4_copy_library_list): New function.
	(svr4_current_sos_via_xfer_libraries): New parameter "annex".
	(svr4_read_so_list): New parameter "prev_lm".
	(svr4_current_sos_direct): Renamed from "svr4_current_sos".
	(svr4_current_sos): New function.
	(probe_and_action): New struct.
	(hash_probe_and_action): New function.
	(equal_probe_and_action): Likewise.
	(register_solib_event_probe): Likewise.
	(solib_event_probe_at): Likewise.
	(solib_event_probe_action): Likewise.
	(solist_update_full): Likewise.
	(solist_update_incremental): Likewise.
	(disable_probes_interface_cleanup): Likewise.
	(svr4_handle_solib_event): Likewise.
	(svr4_update_solib_event_breakpoint): Likewise.
	(svr4_update_solib_event_breakpoints): Likewise.
	(svr4_create_solib_event_breakpoints): Likewise.
	(enable_break): Free probes table before creating breakpoints.
	Use svr4_create_solib_event_breakpoints to create breakpoints.
	(svr4_solib_create_inferior_hook): Free the solib list.
	(_initialize_svr4_solib): Initialise
	svr4_so_ops.handle_solib_event and svr4_so_ops.update_breakpoints.
@
text
@d773 1
a773 1
	  remove_target_sections (gdb, gdb->abfd);
d1154 1
a1154 2
      if (so->abfd)
	remove_target_sections (so, so->abfd);
d1278 1
a1278 1
	  remove_target_sections (so, so->abfd);
@


1.175
log
@gdb/
	* solib.c (solib_find): Don't need dir separator if path has
	drive spec.
@
text
@d1212 31
@


1.174
log
@gdb/
	Code cleanup: constification.
	* solib.c (solib_ops): Make return type and ops variable type const.
	(set_solib_ops): Make the new_ops parameter and ops variable const.
	(solib_find, solib_map_sections, clear_so, free_so, update_solib_list)
	(solib_add, solib_keep_data_in_core, clear_solib)
	(solib_create_inferior_hook, in_solib_dynsym_resolve_code)
	(reload_shared_libraries, solib_global_lookup): Make the ops variable
	const.
	* solib.h (set_solib_ops): Make the new_ops parameter const.
@
text
@d233 2
a234 1
      need_dir_separator = !IS_DIR_SEPARATOR (in_pathname[0]);
@


1.173
log
@	* solist.h (struct target_so_ops): New member clear_so.
	* solib-svr4.c (svr4_clear_so): New function.
	(_initialize_svr4_solib): Set svr4_so_ops.clear_so.
	* solib.c (clear_so): Renamed from free_so_symbols.
	All callers updated.  Call target clear_so if it exists.
@
text
@d67 1
a67 1
static struct target_so_ops *
d70 1
a70 1
  struct target_so_ops **ops = gdbarch_data (gdbarch, solib_data);
d78 1
a78 1
set_solib_ops (struct gdbarch *gdbarch, struct target_so_ops *new_ops)
d80 1
a80 1
  struct target_so_ops **ops = gdbarch_data (gdbarch, solib_data);
d147 1
a147 1
  struct target_so_ops *ops = solib_ops (target_gdbarch ());
d452 1
a452 1
  struct target_so_ops *ops = solib_ops (target_gdbarch ());
d514 1
a514 1
  struct target_so_ops *ops = solib_ops (target_gdbarch ());
d554 1
a554 1
  struct target_so_ops *ops = solib_ops (target_gdbarch ());
d673 1
a673 1
  struct target_so_ops *ops = solib_ops (target_gdbarch ());
d935 1
a935 1
	struct target_so_ops *ops = solib_ops (target_gdbarch ());
d1108 1
a1108 1
  struct target_so_ops *ops = solib_ops (target_gdbarch ());
d1121 1
a1121 1
  struct target_so_ops *ops = solib_ops (target_gdbarch ());
d1169 1
a1169 1
  struct target_so_ops *ops = solib_ops (target_gdbarch ());
d1180 1
a1180 1
  struct target_so_ops *ops = solib_ops (target_gdbarch ());
d1278 1
a1278 1
  struct target_so_ops *ops;
d1345 1
a1345 1
  struct target_so_ops *ops = solib_ops (target_gdbarch ());
@


1.172
log
@Reimplement shared library support on ppc-aix...

... using the target_so_ops framework.

gdb/ChangeLog:

        * target.h (TARGET_OBJECT_AIX_LIBRARIES): New target_object enum.
        * features/library-list-aix.dtd: New file.
        * solib-aix.h, solib-aix.c: New file.
        * rs6000-aix-tdep.c: #include "solib.h" and "solib-aix.h".
        (rs6000_find_toc_address_hook): Delete.
        (rs6000_push_dummy_call): Rewrite code setting the TOC value.
        (rs6000_aix_init_osabi): Register solib_aix_so_ops.
        * rs6000-nat.c: Remove "xcoffsolib.h" include.  Include
        "xml-utils.h".
        (map_vmap, vmap_exec, vmap_ldinfo, add_vmap, objfile_symbol_add)
        (vmap_symtab, fixup_breakpoints): Delete.
        (rs6000_xfer_shared_libraries): New function.
        (rs6000_xfer_partial): Add TARGET_OBJECT_AIX_LIBRARIES handling.
        (vmap_secs, bss_data_overlap, vmap_add_symbols): Delete.
        (xcoff_relocate_symtab, xcoff_relocate_core): Delete.
        (rs6000_ptrace_ldinfo, rs6000_core_ldinfo)
        (rs6000_xfer_shared_library): New function.
        (find_toc_address): Delete.
        (_initialize_rs6000_nat): Do not set rs6000_find_toc_address_hook.
        * rs6000-tdep.h (rs6000_find_toc_address_hook): Remove.
        * xcoffread.c (record_minimal_symbol): Reloate symbol address
        before creating minimal symbol.  Adjust function description
        accordingly.
        (scan_xcoff_symtab): Replace call to
        prim_record_minimal_symbol_and_info by call to
        record_minimal_symbol.
        (xcoff_symfile_offsets): Reimplement mostly as a wrapper
        around default_symfile_offsets.
        * configure.tgt: Add solib-aix.o to gdb_target_obs for
        powerpc-aix targets.
        * config/rs6000/nm-rs6000.h: Delete.
        * config/powerpc/aix.mh (NAT_FILE): Delete.
        (NATDEPFILES): Remove xcoffsolib.o.
        * Makefile.in (XMLFILES): Add library-list-aix.dtd.
        (ALL_TARGET_OBS): Add solib-aix.o.
        (HFILES_NO_SRCDIR): Remove xcoffsolib.h and
        config/rs6000/nm-rs6000.h.  Add solib-aix.h.
        (ALLDEPFILES): Add solib-aix.c.  Remove xcoffsolib.c.
        * xcoffsolib.h, xcoffsolib.c: Delete.

        * solib.c (reload_shared_libraries): Remove reference to
        SOLIB_CREATE_INFERIOR_HOOK.
        * breakpoint.c (handle_solib_event): Remove reference to SOLIB_ADD.
        (disable_breakpoints_in_shlibs): Remove reference to PC_SOLIB.
        (momentary_bkpt_re_set): Replace SOLIB_ADD by solib_add in
        comment.
        * corelow.c (deprecated_core_resize_section_table): Delete.
        * exec.c: Remove include of xcoffsolib.h".
        (map_vmap, vmap): Delete.
        (exec_close_1): Remove references to vmap.
        (exec_file_attach): Remove vmap handling code, and reference
        to DEPRECATED_IBM6000_TARGET.
        (bfdsec_to_vmap): Delete.
        (exec_files_info): Remove block of code handling VMAP.
        * infcmd.c (post_create_inferior): Remove reference to
        SOLIB_CREATE_INFERIOR_HOOK and SOLIB_ADD.
        * infrun.c (follow_exec): Remove reference to
        SOLIB_CREATE_INFERIOR_HOOK.
        * stack.c (print_frame): Remove reference to PC_SOLIB.
        * solib-dsbt.c (dsbt_current_sos): Adjust comment.
        (dsbt_relocate_main_executable): Likewise.
        * solib-frv.c (frv_current_sos): Likewise.

gdb/doc/ChangeLog:

        * gdbint.texinfo (Algorithms): Remove entries documenting
        DEPRECATED_IBM6000_TARGET, SOLIB_ADD, and
        SOLIB_CREATE_INFERIOR_HOOK.
@
text
@d502 4
a505 3
/* Free symbol-file related contents of SO.  If we have opened a BFD
   for SO, close it.  If we have placed SO's sections in some target's
   section table, the caller is responsible for removing them.
d512 1
a512 1
free_so_symbols (struct so_list *so)
d514 2
d534 4
d556 1
a556 1
  free_so_symbols (so);
d1248 1
a1248 1
	  free_so_symbols (so);
@


1.171
log
@	PR gdb/7912:
	* Makefile.in (SFILES): Add filestuff.c
	(COMMON_OBS): Add filestuff.o.
	(filestuff.o): New target.
	* auto-load.c (auto_load_objfile_script_1): Use
	gdb_fopen_cloexec.
	* auxv.c (procfs_xfer_auxv): Use gdb_open_cloexec.
	* cli/cli-cmds.c (shell_escape): Call close_most_fds.
	* cli/cli-dump.c (fopen_with_cleanup): Use gdb_fopen_cloexec.
	* common/agent.c (gdb_connect_sync_socket): Use
	gdb_socket_cloexec.
	* common/filestuff.c: New file.
	* common/filestuff.h: New file.
	* common/linux-osdata.c (linux_common_core_of_thread)
	(command_from_pid, commandline_from_pid, print_source_lines)
	(linux_xfer_osdata_shm, linux_xfer_osdata_sem)
	(linux_xfer_osdata_msg, linux_xfer_osdata_modules): Use
	gdb_fopen_cloexec.
	* common/linux-procfs.c (linux_proc_get_int)
	(linux_proc_pid_has_state): Use gdb_fopen_cloexec.
	* config.in, configure: Rebuild.
	* configure.ac: Don't check for sys/socket.h.  Check for
	fdwalk, pipe2.
	* corelow.c (core_open): Use gdb_open_cloexec.
	* dwarf2read.c (write_psymtabs_to_index): Use gdb_fopen_cloexec.
	* fork-child.c (fork_inferior): Call close_most_fds.
	* gdb_bfd.c (gdb_bfd_open): Use gdb_open_cloexec.
	* inf-child.c (inf_child_fileio_readlink): Use gdb_open_cloexec.
	* linux-nat.c (linux_nat_thread_name, linux_proc_pending_signals):
	Use gdb_fopen_cloexec.
	(linux_proc_xfer_partial, linux_proc_xfer_spu): Use
	gdb_open_cloexec.
	(linux_async_pipe): Use gdb_pipe_cloexec.
	* remote-fileio.c (remote_fileio_func_open): Use
	gdb_open_cloexec.
	* remote.c (remote_file_put, remote_file_get): Use
	gdb_fopen_cloexec.
	* ser-pipe.c (pipe_open): Use gdb_socketpair_cloexec,
	close_most_fds.
	* ser-tcp.c (net_open): Use gdb_socket_cloexec.
	* ser-unix.c (hardwire_open): Use gdb_open_cloexec.
	* solib.c (solib_find): Use gdb_open_cloexec.
	* source.c (openp, find_and_open_source): Use gdb_open_cloexec.
	* tracepoint.c (tfile_start): Use gdb_fopen_cloexec.
	(tfile_open): Use gdb_open_cloexec.
	* tui/tui-io.c (tui_initialize_io): Use gdb_pipe_cloexec.
	* ui-file.c (gdb_fopen): Use gdb_fopen_cloexec.
	* xml-support.c (xml_fetch_content_from_file): Use
	gdb_fopen_cloexec.
	* main.c (captured_main): Call notice_open_fds.
gdbserver
	* Makefile.in (SFILES): Add filestuff.c.
	(OBS): Add filestuff.o.
	(filestuff.o): New target.
	* config.in, configure: Rebuild.
	* configure.ac: Check for fdwalk, pipe2.
@
text
@a1296 3
#ifdef SOLIB_CREATE_INFERIOR_HOOK
      SOLIB_CREATE_INFERIOR_HOOK (PIDGET (inferior_ptid));
#else
a1297 1
#endif
@


1.170
log
@Do not overwrite so_list's so_name in solib_map_sections

gdb/ChangeLog:

        * solib.c (solib_map_sections): Remove code overwriting
        SO->SO_NAME with the bfd's filename.
@
text
@d50 1
d250 1
a250 1
  found_file = open (temp_pathname, O_RDONLY | O_BINARY, 0);
d273 1
a273 1
      found_file = open (temp_pathname, O_RDONLY | O_BINARY, 0);
d288 1
a288 1
	  found_file = open (temp_pathname, O_RDONLY | O_BINARY, 0);
@


1.169
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a467 6
  /* copy full path name into so_name, so that later symbol_file_add
     can find it.  */
  if (strlen (bfd_get_filename (abfd)) >= SO_NAME_MAX_PATH_SIZE)
    error (_("Shared library file name is too long."));
  strcpy (so->so_name, bfd_get_filename (abfd));

@


1.168
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d3 1
a3 1
   Copyright (C) 1990-2003, 2005-2012 Free Software Foundation, Inc.
@


1.167
log
@2012-09-28  Nathan Miller  <nathanm2@@us.ibm.com>
	    Edjunior Machado  <emachado@@linux.vnet.ibm.com>

	PR gdb/13989
	* solib.c (solib_find): Prevent GDB from loading native libraries when
	debugging a cross-target corefile.
@
text
@d146 1
a146 1
  struct target_so_ops *ops = solib_ops (target_gdbarch);
d151 1
a151 1
    = gdbarch_solib_symbols_extension (target_gdbarch);
d427 1
a427 1
  b = gdbarch_bfd_arch_info (target_gdbarch);
d451 1
a451 1
  struct target_so_ops *ops = solib_ops (target_gdbarch);
d552 1
a552 1
  struct target_so_ops *ops = solib_ops (target_gdbarch);
d671 1
a671 1
  struct target_so_ops *ops = solib_ops (target_gdbarch);
d933 1
a933 1
	struct target_so_ops *ops = solib_ops (target_gdbarch);
d957 1
a957 1
  struct gdbarch *gdbarch = target_gdbarch;
d1106 1
a1106 1
  struct target_so_ops *ops = solib_ops (target_gdbarch);
d1119 1
a1119 1
  struct target_so_ops *ops = solib_ops (target_gdbarch);
d1167 1
a1167 1
  struct target_so_ops *ops = solib_ops (target_gdbarch);
d1178 1
a1178 1
  struct target_so_ops *ops = solib_ops (target_gdbarch);
d1280 1
a1280 1
  ops = solib_ops (target_gdbarch);
d1347 1
a1347 1
  struct target_so_ops *ops = solib_ops (target_gdbarch);
@


1.166
log
@	* windows-nat.c (windows_make_so): Use gdb_bfd_open.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_open.
	(symfile_bfd_open): Likewise.
	(generic_load): Likewise.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_open.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_open.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_open.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_open.
	* remote-mips.c (mips_load_srec): Use gdb_bfd_open.
	(pmon_load_fast): Likewise.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_open.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_open.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_open.
	(macho_check_dsym): Likewise.
	* m32r-rom.c (m32r_load): Use gdb_bfd_open.
	(m32r_upload_command): Likewise.
	* gdb_bfd.h (gdb_bfd_cache): Declare.
	* gdb_bfd.c (struct gdb_bfd_data): New.
	(gdb_bfd_cache): New global.
	(struct gdb_bfd_cache_search): New.
	(hash_bfd): New function.
	(eq_bfd): Likewise.
	(gdb_bfd_open): Likewise.
	(gdb_bfd_ref): Allocate a gdb_bfd_data and attach to the BFD.
	(gdb_bfd_unref): Remove closed BFD from cache.  Update for
	gdb_bfd_data.
	* exec.c (exec_file_attach): Use gdb_bfd_open.
	* dsrec.c (load_srec): Use gdb_bfd_open.
@
text
@a302 5
  /* If not found, search the solib_search_path (if any).  */
  if (found_file < 0 && solib_search_path != NULL)
    found_file = openp (solib_search_path, OPF_TRY_CWD_FIRST,
			in_pathname, O_RDONLY | O_BINARY, &temp_pathname);

@


1.165
log
@	* exec.c (exec_close, exec_file_attach): Update.
	(add_to_section_table): Initialize 'key' field.
	(add_target_sections, remove_target_sections): Add 'key' argument.
	* exec.h (add_target_sections, remove_target_sections): Add
	'key' argument.
	* solib.c (solib_map_sections, update_solib_list, clear_solib)
	(reload_shared_libraries_1): Update.
	* target.h (struct target_section) <key>: New field.
@
text
@d380 1
a380 1
      abfd = gdb_bfd_fopen (pathname, gnutarget, FOPEN_RB, fd);
@


1.164
log
@	* coffread.c (coff_symfile_read): Make a cleanup for 'debugfile'
	and 'abfd'.
	* elfread.c (elf_symfile_read): Make a cleanup for 'debugfile'
	and 'abfd'.
	* jit.c (jit_bfd_try_read_symtab): Make a cleanup for 'nbfd'.
	* machoread.c (macho_add_oso_symfile): Make a cleanup for
	'abfd'.
	(macho_symfile_read): Make a cleanup for 'dsym_bfd'.
	* objfiles.c (allocate_objfile): Acquire a new reference.
	* rs6000-nat.c (add_vmap): Don't acquire a BFD reference.
	* solib.c (solib_read_symbols): Don't acquire a BFD reference.
	* spu-linux-nat.c (spu_symbol_file_add_from_memory): Make
	a cleanup for 'nbfd'.
	* symfile-mem.c (symbol_file_add_from_memory): Make a cleanup
	for 'nbfd'.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Don't
	make a cleanup for 'abfd'.
	(symbol_file_add): Make a BFD cleanup.
@
text
@d507 1
a507 1
  add_target_sections (so->sections, so->sections_end);
d775 1
a775 1
	  remove_target_sections (gdb->abfd);
d1157 1
a1157 1
	remove_target_sections (so->abfd);
d1250 1
a1250 1
	  remove_target_sections (so->abfd);
@


1.163
log
@	* cli/cli-dump.c (bfd_openr_with_cleanup): Use gdb_bfd_openr.
	(bfd_openw_with_cleanup): Use gdb_bfd_openw.
	* corelow.c (core_open): Use gdb_bfd_fopen.
	* dsrec.c (load_srec): Use gdb_bfd_openr.
	* exec.c (exec_file_attach): Use gdb_bfd_fopen.
	* gcore.c (gcore_memory_sections): Use gdb_bfd_openw.
	* gdb_bfd.c (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): New functions.
	* gdb_bfd.h (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): Declare.
	* jit.c (bfd_open_from_target_memory): Use gdb_bfd_openr_iovec.
	* m32-rom.c (m32r_load, m32r_upload_command): Use gdb_bfd_openr.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_openr,
	gdb_bfd_openr_next_archived_file.
	(macho_check_dsym): Use gdb_bfd_openr.
	(macho_add_oso_symfile): Don't call gdb_bfd_stash_filename.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_fdopenr.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_openr.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Use
	gdb_bfd_openr.
	* remote.c (remote_bfd_open): Use gdb_bfd_openr_iovec.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_openr, gdb_bfd_fdopenr,
	gdb_bfd_openr_next_archived_file.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_openr.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_openr.
	* solib-spu.c (spu_bfd_fopen): Use gdb_bfd_openr_iovec.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_fopen.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_openr_iovec.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_openr.
	(symfile_bfd_open): Use gdb_bfd_fopen.
	(generic_load): Use gdb_bfd_openr.
	* windows-nat.c (windows_make_so): Use gdb_bfd_openr.
@
text
@a612 1
	  gdb_bfd_ref (so->abfd);
@


1.162
log
@	* bfd-target.c (target_bfd_reopen): Update.
	* cli/cli-dump.c (bfd_openr_with_cleanup)
	(bfd_openw_with_cleanup): Update.
	* corelow.c (core_open): Update.
	* dsrec.c (load_srec): Update.
	* exec.c (exec_file_attach): Update.
	* gcore.c (create_gcore_bfd): Update.
	* gdb_bfd.c (gdb_bfd_ref): Return void.
	(gdb_bfd_open): Update.
	* gdb_bfd.h (gdb_bfd_ref): Return void.
	Update comments.
	* jit.c (jit_bfd_try_read_symtab): Update.
	* m32r-rom.c (m32r_load, m32r_upload_command): Update.
	* machoread.c (macho_symfile_read_all_oso): Update.
	(macho_check_dsym): Update.
	* procfs.c (insert_dbx_link_bpt_in_file): Update.
	* remote-m32r-sdi.c (m32r_load): Update.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Update.
	* rs6000-nat.c (add_vmap): Update.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-spu.c (spu_bfd_open): Update.
	* solib.c (solib_bfd_fopen, solib_read_symbols): Update.
	* spu-linux-nat.c (spu_bfd_open): Update.
	* symfile.c (bfd_open_maybe_remote, symfile_bfd_open)
	(generic_load): Update.
	* windows-nat.c (windows_make_so): Update.
@
text
@d380 1
a380 1
      abfd = bfd_fopen (pathname, gnutarget, FOPEN_RB, fd);
a392 1
  gdb_bfd_stash_filename (abfd);
a394 1
  gdb_bfd_ref (abfd);
@


1.161
log
@	* utils.c (make_cleanup_bfd_unref): Rename from
	make_cleanup_bfd_close.
	* defs.h (make_cleanup_bfd_unref): Rename from
	make_cleanup_bfd_close.
	* cli/cli-dump.c (bfd_openr_with_cleanup): Update.
	(bfd_openw_with_cleanup): Update.
	* corelow.c (core_open): Update.
	* dsrec.c (load_srec): Update.
	* m32r-rom.c (m32r_load, m32r_upload_command): Update.
	* remote-m32r-sdi.c (m32r_load): Update.
	* remote-mips.c (mips_load_srec): Update.
	(pmon_load_fast): Update.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Update.
	(darwin_bfd_open): Update.
	* solib.c (solib_bfd_fopen): Update.
	* symfile-mem.c (symbol_file_add_from_memory): Update.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Update.
	(symfile_bfd_open): Update.
	(generic_load): Update.
@
text
@d396 2
a397 1
  return gdb_bfd_ref (abfd);
d615 2
a616 1
	  so->objfile = symbol_file_add_from_bfd (gdb_bfd_ref (so->abfd),
@


1.160
log
@	* symfile.c (symfile_bfd_open): Don't copy name.  Call
	gdb_bfd_stash_filename.
	(load_command): Open the new BFD before freeing the old.
	(bfd_open_maybe_remote): Call gdb_bfd_stash_filename.
	* symfile-mem.c (symbol_file_add_from_memory): Don't copy name.
	Call gdb_bfd_stash_filename.
	* spu-linux-nat.c (spu_bfd_open): Don't copy name.
	* solib-spu.c (spu_bfd_fopen): Don't copy name.  Call
	gdb_bfd_stash_filename.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Free found_pathname.
	* rs6000-nat.c (add_vmap): Don't copy filename.  Call
	gdb_bfd_stash_filename.
	* remote.c (remote_bfd_open): Call gdb_bfd_stash_filename.
	* machoread.c (macho_add_oso_symfile): Call
	gdb_bfd_stash_filename.
	(macho_symfile_read_all_oso): Arrange to free archive_name.  Call
	gdb_bfd_stash_filename.
	(macho_check_dsym): Don't copy filename.  Call
	gdb_bfd_stash_filename.
	* jit.c (bfd_open_from_target_memory): Don't copy the filename.
	* gdb_bfd.c (gdb_bfd_stash_filename): New function.
	* gdb_bfd.h (gdb_bfd_stash_filename): Declare.
	* gcore.c (create_gcore_bfd): Call gdb_bfd_stash_filename.
	* exec.c (exec_close): Don't free the BFD's filename.
	(exec_file_attach): Don't copy the filename.  Call
	gdb_bfd_stash_filename.
	* corelow.c (core_close): Don't free the BFD's filename.
	(core_open): Call gdb_bfd_stash_filename.
	* corefile.c (reopen_exec_file): Remove #if 0 code.
	* solib.c (solib_bfd_fopen): Call gdb_bfd_stash_filename.  Free
	pathname.
	* dwarf2read.c (try_open_dwo_file): Call gdb_bfd_stash_filename.
@
text
@d427 1
a427 1
      make_cleanup_bfd_close (abfd);
@


1.159
log
@	* dwarf2read.c (try_open_dwo_file): Use gdb_bfd_ref and
	gdb_bfd_unref.
	(free_dwo_file): Use gdb_bfd_unref.
	* cli/cli-dump.c: Include gdb_bfd.h.
	(bfd_openw_with_cleanup): Use gdb_bfd_ref.
	(bfd_openr_with_cleanup): Likewise.
	* windows-nat.c (windows_make_so): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* utils.c: Include gdb_bfd.h.
	(do_bfd_close_cleanup): Use gdb_bfd_unref.
	* symfile.c: Include gdb_bfd.h.
	(separate_debug_file_exists): Use gdb_bfd_unref.
	(bfd_open_maybe_remote): Use gdb_bfd_ref.
	(symfile_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	(generic_load): Use gdb_bfd_ref.
	(reread_symbols): Use gdb_bfd_unref.
	* symfile-mem.c: Include gdb_bfd.h.
	(symbol_file_add_from_memory): Use make_cleanup_bfd_close.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib.c: Include gdb_bfd.h.
	(solib_bfd_fopen): Use gdb_bfd_ref.
	(solib_bfd_open): Use gdb_bfd_unref.
	(free_so_symbols): Use gdb_bfd_unref.
	(reload_shared_libraries_1): Use gdb_bfd_unref.
	* solib-spu.c: Include gdb_bfd.h.
	(spu_bfd_fopen): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* solib-frv.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-dsbt.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-darwin.c: Include gdb_bfd.h.
	(darwin_solib_get_all_image_info_addr_at_init): Use gdb_bfd_ref,
	gdb_bfd_unref.
	(darwin_bfd_open): Use gdb_bfd_unref.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_ref, gdb_bfd_unref.
	* remote-mips.c: Include gdb_bfd.h.
	(mips_load_srec): Use gdb_bfd_ref.
	(pmon_load_fast): Use gdb_bfd_ref.
	* remote-m32r-sdi.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	* record.c: Include gdb_bfd.h.
	(record_save_cleanups): Use gdb_bfd_unref.
	(cmd_record_save): Use gdb_bfd_unref.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* objfiles.h (gdb_bfd_close_or_warn): Remove.
	(gdb_bfd_ref, gdb_bfd_unref): Move to gdb_bfd.h.
	* objfiles.c: Include gdb_bfd.h.
	(free_objfile): Use gdb_bfd_unref.
	(gdb_bfd_close_or_warn, gdb_bfd_ref, gdb_bfd_unref): Move to
	gdb_bfd.c.
	* machoread.c (macho_add_oso_symfile): Use gdb_bfd_unref.
	(macho_symfile_read_all_oso): Use gdb_bfd_ref, gdb_bfd_unref.
	(macho_check_dsym): Likewise.
	* m32r-rom.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	(m32r_upload_command): Use gdb_bfd_ref.
	* jit.c: Include gdb_bfd.h.
	(jit_bfd_try_read_symtab): Use gdb_bfd_ref, gdb_bfd_unref.
	* gdb_bfd.h: New file.
	* gdb_bfd.c: New file.
	* gcore.c: Include gdb_bfd.h.
	(create_gcore_bfd): Use gdb_bfd_ref.
	(do_bfd_delete_cleanup): Use gdb_bfd_unref.
	(gcore_command): Use gdb_bfd_unref.
	* exec.c: Include gdb_bfd.h.
	(exec_close): Use gdb_bfd_unref.
	(exec_close_1): Use gdb_bfd_unref.
	(exec_file_attach): Use gdb_bfd_ref.
	* elfread.c: Include gdb_bfd.h.
	(build_id_verify): Use gdb_bfd_unref.
	* dsrec.c: Include gdb_bfd.h.
	(load_srec): Use gdb_bfd_ref.
	* corelow.c: Include gdb_bfd.h.
	(core_close): Use gdb_bfd_unref.
	(core_open): Use gdb_bfd_ref.
	* bfd-target.c: Include gdb_bfd.h.
	(target_bfd_xclose): Use gdb_bfd_unref.
	(target_bfd_reopen): Use gdb_bfd_ref.
	* Makefile.in (SFILES): Add gdb_bfd.c.
	(HFILES_NO_SRCDIR): Add gdb_bfd.h.
	(COMMON_OBS): Add gdb_bfd.o.
@
text
@d364 3
a366 3
   PATHNAME must be malloc'ed by the caller.  If successful, the new BFD's
   name will point to it.  If unsuccessful, PATHNAME will be freed and the
   FD will be closed (unless FD was -1).  */
d393 3
d427 1
a427 2
      gdb_bfd_unref (abfd);
      make_cleanup (xfree, found_pathname);
d429 1
a429 1
	     found_pathname, bfd_errmsg (bfd_get_error ()));
d436 1
a436 1
               "with target architecture %s."), found_pathname,
@


1.158
log
@bfd/
	* opncls.c (bfd_fopen): Always close fd on failure.
	(bfd_fdopenr): Likewise.
gdb/
	* symfile.c (symfile_bfd_open): Don't close desc if bfd_fopen
	fails.
	* solib.c (solib_bfd_fopen): Don't close fd if bfd_fopen fails.
	* exec.c (exec_file_attach): Don't close scratch_chan if bfd_fopen
	fails.
	* dwarf2read.c (try_open_dwo_file): Don't close fd if bfd_fopen
	fails.
@
text
@d49 1
d393 1
a393 1
  return abfd;
d424 1
a424 1
      bfd_close (abfd);
d470 1
a470 1
  so->abfd = gdb_bfd_ref (abfd);
d612 1
a612 1
	  so->objfile = symbol_file_add_from_bfd (so->abfd,
d1237 1
a1237 1
	  gdb_bfd_close_or_warn (abfd);
@


1.157
log
@	* symfile.c (symbol_file_add_main_1): Use inferior's
	symfile_flags.
	* solib.c (solib_read_symbols): Use inferior's symfile_flags.
	* linux-nat.c (linux_child_follow_fork): Set symfile_flags on
	inferior.
	* infrun.c (handle_vfork_child_exec_or_exit): Set symfile_flags on
	inferior.
	(follow_exec): Use inferior's symfile_flags.
	* inferior.h (struct inferior) <symfile_flags>: New field.
@
text
@a382 2
      else if (fd != -1)
	close (fd);
@


1.156
log
@	PR symtab/12406:
	* solib.c (update_solib_list): Update the program space's
	added_solibs and deleted_solibs fields.
	* progspace.h (struct program_space) <added_solibs,
	deleted_solibs>: New fields.
	(clear_program_space_solib_cache): Declare.
	* progspace.c (release_program_space): Call
	clear_program_space_solib_cache.
	(clear_program_space_solib_cache): New function.
	* infrun.c (handle_inferior_event) <TARGET_WAITKIND_LOADED>: Call
	bpstat_stop_status.  Use handle_solib_event.
	* breakpoint.c: Include gdb_regex.h.
	(print_solib_event): New function.
	(bpstat_print): Use print_solib_event.
	(bpstat_stop_status): Add special case for bp_shlib_event.
	(handle_solib_event): New function.
	(bpstat_what): Use handle_solib_event.
	(struct solib_catchpoint): New.
	(dtor_catch_solib, insert_catch_solib, remove_catch_solib)
	(breakpoint_hit_catch_solib, check_status_catch_solib)
	(print_it_catch_solib, print_one_catch_solib)
	(print_mention_catch_solib, print_recreate_catch_solib): New
	functions.
	(catch_solib_breakpoint_ops): New global.
	(catch_load_or_unload, catch_load_command_1)
	(catch_unload_command_1): New functions.
	(internal_bkpt_check_status): Add special case for
	bp_shlib_event.
	(internal_bkpt_print_it): Use print_solib_event.
	(initialize_breakpoint_ops): Initialize
	catch_solib_breakpoint_ops.
	(_initialize_breakpoint): Register "catch load" and "catch
	unload".
	* breakpoint.h (handle_solib_event): Declare.
	* NEWS: Add entry for "catch load" and "catch unload".
gdb/doc
	* gdb.texinfo (Set Catchpoints): Document "catch load" and "catch
	unload".
	(Files): Mention new catch commands.
	(GDB/MI Async Records): Likewise.
gdb/testsuite
	* lib/mi-support.exp (mi_expect_stop): Add special case for
	solib-event.
	* gdb.base/catch-load-so.c: New file.
	* gdb.base/catch-load.exp: New file.
	* gdb.base/catch-load.c: New file.
	* gdb.base/break-interp.exp (reach_1): Update regexp.
@
text
@d595 2
@


1.155
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d761 3
d799 1
@


1.154
log
@    * solib.c (solib_used): New function.
    (update_solib_list, reload_shared_libraries_1): Check if objfile is used
    by another so_list object before freeing it.
@
text
@d3 1
a3 3
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.154.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1990-2003, 2005-2012 Free Software Foundation, Inc.
@


1.153
log
@	gdb/
	* solib-dsbt.c (bfd_lookup_symbol): Removed.
	(cmp_name): New.
	(enable_break2): Update caller.
	* solib-frv.c (bfd_lookup_symbol): Removed.
	(cmp_name): New.
	(enable_break2): Update caller.
	* solib-pa64.c (bfd_lookup_symbol): Removed.
	(cmp_name): New.
	* solib-svr4.c (bfd_lookup_symbol): Removed.
	(cmp_name_and_sec_flags): New.
	(enable_break): Update caller.
	* solib.c (gdb_bfd_lookup_symbol_from_symtab): New.
	(gdb_bfd_lookup_symbol_from_dyn_symtab): New.
	(gdb_bfd_lookup_symbol): New.
	* solib.h: Functions declarations.
@
text
@d636 14
d766 2
a767 1
	  if (gdb->objfile && ! (gdb->objfile->flags & OBJF_USERLOADED))
d1243 2
a1244 1
	  if (so->objfile && ! (so->objfile->flags & OBJF_USERLOADED))
@


1.152
log
@2011-08-09  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* elfread.c (elf_symtab_read): Ditto.
	* maint.c (maintenance_command): Ditto.
	* somread.c (som_symtab_read): Ditto.
	* solib.c (solib_find, solib_map_sections, update_solib_list)
	(solib_add, info_sharedlibrary_command, solib_name_from_address)
	(solib_create_inferior_hook, in_solib_dynsym_resolve_code)
	(sharedlibrary_command, no_shared_libraries): Rework comments.
	* solib-irix.c (locate_base, disable_break, enable_break)
	(irix_solib_create_inferior_hook, irix_solib_create_inferior_hook)
	(irix_current_sos, irix_open_symbol_file_object)
	(irix_special_symbol_handling): Ditto.
	* solib-sunos.c (locate_base, first_link_map_member)
	(sunos_current_sos, disable_break, enable_break)
	(sunos_special_symbol_handling, sunos_solib_create_inferior_hook):
	Ditto.
	* solib-svr4.c (bfd_lookup_symbol, elf_locate_base, locate_base)
	(open_symbol_file_object, svr4_current_sos, enable_break)
	(svr4_special_symbol_handling, svr4_solib_create_inferior_hook):
	Ditto.
	* solib-frv.c (bfd_lookup_symbol, open_symbol_file_object)
	(frv_current_sos, enable_break, frv_special_symbol_handling)
	(frv_solib_create_inferior_hook): Ditto.
	* solist.h (struct target_so_ops): Extend the comments of the
	special_symbol_handling, current_sos and open_symbol_file_object
	methods.
@
text
@d1339 96
@


1.151
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* ui-out.h (uiout): Rename to ...
	(current_uiout): ... this.
	* ui-out.c (uiout): Rename to ...
	(current_uiout): ... this.
	* ada-lang.c (print_it_exception, print_one_exception)
	(print_mention_exception): Adjust.
	* breakpoint.c (watchpoint_check): Adjust.
	(print_breakpoint_location, print_one_breakpoint, breakpoint_1)
	(default_collect_info, watchpoints_info, print_one_catch_fork)
	(print_one_catch_vfork, print_one_catch_syscall)
	(print_one_catch_exec, mention, print_it_ranged_breakpoint)
	(print_one_ranged_breakpoint, print_mention_ranged_breakpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_it_masked_watchpoint, print_mention_masked_watchpoint)
	(print_it_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint, say_where, bkpt_print_it)
	(bkpt_print_mention, momentary_bkpt_print_it)
	(tracepoint_print_mention, update_static_tracepoint)
	(tracepoints_info, save_breakpoints): Adjust.
	* cli-out.c (field_separator): Adjust.
	* cp-abi.c (list_cp_abis, show_cp_abi_cmd): Adjust.
	* exceptions.c (catch_exceptions_with_msg, catch_errors): Adjust.
	* frame.c (get_current_frame): Adjust.
	* infcmd.c (run_command_1, print_return_value): Adjust.
	* inferior.c (inferior_command, info_inferiors_command): Adjust.
	* infrun.c (print_end_stepping_range_reason): Adjust.
	(print_signal_exited_reason, print_exited_reason): Adjust.
	(print_signal_received_reason, print_no_history_reason): Adjust.
	* interps.c (interp_set): Adjust.
	* osdata.c (info_osdata_command): Adjust.
	* progspace.c (maintenance_info_program_spaces_command): Adjust.
	* remote-fileio.c (remote_fileio_request): Adjust.
	* remote.c (show_remote_cmd): Adjust.
	* solib.c (info_sharedlibrary_command): Adjust.
	* source.c (print_source_lines_base): Adjust.
	* stack.c (print_stack_frame): Adjust.
	(do_gdb_disassembly, print_frame_info, print_frame): Adjust.
	* symfile-mem.c (add_vsyscall_page): Adjust.
	* symfile.c (load_progress, generic_load)
	(print_transfer_performance): Adjust.
	* thread.c (info_threads_command, restore_selected_frame)
	(thread_command): Adjust.
	* top.c (make_cleanup_restore_ui_file): Adjust.
	* tracepoint.c (tvariables_info_1, trace_status_mi, tfind_1)
	(print_one_static_tracepoint_marker): Adjust.
	* cli/cli-cmds.c (print_disassembly): Adjust.
	* cli/cli-decode.c (print_doc_line): Adjust.
	* cli/cli-interp.c (safe_execute_command): Adjust.
	* cli/cli-logging.c (set_logging_redirect, pop_output_files)
	(handle_redirections): Adjust.
	* cli/cli-script.c (show_user_1): Adjust.
	* cli/cli-setshow.c (do_setshow_command, cmd_show_list): Adjust.
	* mi/mi-cmd-break.c (breakpoint_notify): Adjust.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Adjust.
	* mi/mi-cmd-env.c (mi_cmd_env_pwd, mi_cmd_env_path)
	(mi_cmd_env_dir): Adjust.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(print_partial_file_name, mi_cmd_file_list_exec_source_files): Adjust.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_depth, mi_cmd_stack_list_args)
	(list_args_or_locals): Adjust.
	* mi/mi-cmd-var.c (print_varobj, mi_cmd_var_create)
	(mi_cmd_var_delete, mi_cmd_var_set_format, mi_cmd_var_set_frozen)
	(mi_cmd_var_show_format, mi_cmd_var_info_num_children)
	(mi_cmd_var_list_children, mi_cmd_var_info_type)
	(mi_cmd_var_info_path_expression, mi_cmd_var_info_expression)
	(mi_cmd_var_show_attributes, mi_cmd_var_evaluate_expression)
	(mi_cmd_var_assign, mi_cmd_var_update, varobj_update_one): Adjust.
	* mi/mi-interp.c (mi_on_normal_stop): Adjust.
	* mi/mi-main.c (mi_cmd_gdb_exit, mi_cmd_thread_select)
	(mi_cmd_thread_list_ids, mi_cmd_thread_info, print_one_inferior)
	(list_available_thread_groups, mi_cmd_list_thread_groups)
	(mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers)
	(mi_cmd_data_list_register_values, get_register)
	(mi_cmd_data_evaluate_expression, mi_cmd_data_read_memory)
	(mi_cmd_data_read_memory_bytes, mi_cmd_list_features)
	(mi_cmd_list_target_features, mi_cmd_add_inferior)
	(mi_execute_command, mi_load_progress): Adjust.
	* mi/mi-symbol-cmds.c (mi_cmd_symbol_list_lines): Adjust.
	* python/py-auto-load.c (print_script, info_auto_load_scripts):
	Adjust.
	* python/py-breakpoint.c (bppy_get_commands): Adjust.
	* tui/tui-interp.c (tui_command_loop): Adjust.
	* tui/tui-io.c (tui_setup_io, tui_initialize_io): Adjust.
@
text
@d117 4
a120 11
/*

   GLOBAL FUNCTION

   solib_find -- Find a shared library file.

   SYNOPSIS

   char *solib_find (char *in_pathname, int *fd);

   DESCRIPTION
d142 1
a142 6

   RETURNS

   Full pathname of the shared library file, or NULL if not found.
   (The pathname is malloc'ed; it needs to be freed by the caller.)
   *FD is set to either -1 or an open file handle for the library.  */
d443 5
d449 2
a450 22
/*

   LOCAL FUNCTION

   solib_map_sections -- open bfd and build sections for shared lib

   SYNOPSIS

   static int solib_map_sections (struct so_list *so)

   DESCRIPTION

   Given a pointer to one of the shared objects in our list
   of mapped objects, use the recorded name to open a bfd
   descriptor for the object, build a section table, and then
   relocate all the section addresses by the base address at
   which the shared object was mapped.

   FIXMES

   In most (all?) cases the shared object file name recorded in the
   dynamic linkage tables will be a fully qualified pathname.  For
d453 1
a453 2
   expansion stuff?).
 */
d545 1
a545 11
/* LOCAL FUNCTION

   free_so --- free a `struct so_list' object

   SYNOPSIS

   void free_so (struct so_list *so)

   DESCRIPTION

   Free the storage associated with the `struct so_list' object SO.
d636 1
a636 7
/* LOCAL FUNCTION

   update_solib_list --- synchronize GDB's shared object list with inferior's

   SYNOPSIS

   void update_solib_list (int from_tty, struct target_ops *TARGET)
d847 1
a847 12
/* GLOBAL FUNCTION

   solib_add -- read in symbol info for newly added shared libraries

   SYNOPSIS

   void solib_add (char *pattern, int from_tty, struct target_ops
   *TARGET, int readsyms)

   DESCRIPTION

   Read in symbolic information for any shared objects whose names
d930 4
a933 17

/*

   LOCAL FUNCTION

   info_sharedlibrary_command -- code for "info sharedlibrary"

   SYNOPSIS

   static void info_sharedlibrary_command ()

   DESCRIPTION

   Walk through the shared library list and print information
   about each attached library matching PATTERN.  If PATTERN is elided,
   print them all.
 */
d1060 2
a1061 8
/*

   GLOBAL FUNCTION

   solib_name_from_address -- if an address is in a shared lib, return
   its name.

   SYNOPSIS
d1063 3
a1065 7
   char * solib_name_from_address (CORE_ADDR address)

   DESCRIPTION

   Provides a hook for other gdb routines to discover whether or
   not a particular address is within the mapped address space of
   a shared library.
d1069 1
a1069 2
   mapped in.
 */
d1145 4
a1148 14
/* GLOBAL FUNCTION

   solib_create_inferior_hook -- shared library startup support

   SYNOPSIS

   void solib_create_inferior_hook (int from_tty)

   DESCRIPTION

   When gdb starts up the inferior, it nurses it along (through the
   shell) until it is ready to execute it's first instruction.  At this
   point, this function gets called via expansion of the macro
   SOLIB_CREATE_INFERIOR_HOOK.  */
d1158 2
a1159 15
/* GLOBAL FUNCTION

   in_solib_dynsym_resolve_code -- check to see if an address is in
                                   dynamic loader's dynamic symbol
				   resolution code

   SYNOPSIS

   int in_solib_dynsym_resolve_code (CORE_ADDR pc)

   DESCRIPTION

   Determine if PC is in the dynamic linker's symbol resolution
   code.  Return 1 if so, 0 otherwise.
*/
d1169 1
a1169 13
/*

   LOCAL FUNCTION

   sharedlibrary_command -- handle command to explicitly add library

   SYNOPSIS

   static void sharedlibrary_command (char *args, int from_tty)

   DESCRIPTION

 */
d1178 1
a1178 8
/* LOCAL FUNCTION

   no_shared_libraries -- handle command to explicitly discard symbols
   from shared libraries.

   DESCRIPTION

   Implements the command "nosharedlibrary", which discards symbols
@


1.150
log
@2011-07-26  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* progspace.h (struct program_space): Add solib_add_generation.
	* infcmd.c (post_create_inferior): Only call solib_add if not
	already done.
	* solib.c (solib_add): Increment solib_add_generation.
@
text
@d1012 1
@


1.149
log
@	* varobj.c (varobj_create): Call do_cleanups on early exit path.
	* valops.c (find_overload_match): Call do_cleanups on early exit
	path.
	* solib.c (solib_find): Call do_cleanups on early exit path.
@
text
@d917 2
@


1.148
log
@bfd/
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Do not check for
	SEC_LOAD.

gdb/
	Fix convert_code_addr_to_desc_addr for ppc64 files after eu-strip.
	* elfread.c (elf_symfile_read): New variable synth_abfd, pass it to
	bfd_get_synthetic_symtab.
	* jit.c (jit_register_code): Pass NULL to the new parameter parent.
	* machoread.c (macho_add_oso_symfile): Pass main_objfile to the new
	parameter parent, remove the call to add_separate_debug_objfile.
	* solib.c (solib_read_symbols): Pass NULL to the new parameter parent.
	* symfile-mem.c (symbol_file_add_from_memory): Likewise.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): New parameter
	parent, new comment for it, call add_separate_debug_objfile for it.
	(symbol_file_add_separate): Pass objfile as the parameter parent,
	remove the call to add_separate_debug_objfile.
	(symbol_file_add_from_bfd): New parameter parent, pass it.
	(symbol_file_add): Pass NULL to the new parameter parent.
	* symfile.h (symbol_file_add_from_bfd): New parameter parent.

gdb/testsuite/
	* gdb.base/eu-strip-infcall.c: New file.
	* gdb.base/eu-strip-infcall.exp: New file.
@
text
@d257 1
@


1.147
log
@2011-03-23  Kai Tietz  <ktietz@@redhat.com>

	* breakpoint.c (clear_command): Use filename_cmp
	instead of strcmp for comparison.
	* buildsym.c (watch_main_source_file_lossage): Likewise.
	(patch_subfile_names): Use IS_DIR_SEPARATOR instead of
	checking just for slash.
	* dbxread.c (read_dbx_symtab): Use lbasename instead of
	strrchr and filename_cmp instead of strcmp for filenames.
	(add_old_header_file): Use filename_cmp
	instead of strcmp for comparison.
	* exec.c (exec_set_section_address): Likewise.
	* macrotab.c (macro_lookup_inclusion): Likewise.
	(macro_lookup_inclusion): Likewise.
	* elfread.c (_initialize_elfread): Likewise.
	(elfstab_offset_sections): Likewise.
	(elfstab_offset_sections): Use lbasename instead of
	strrchr.
	* mdebugread.c (parse_partial_symbols): Likewise.
	(arse_partial_symbols): Use filename_(n)cmp instead of
	str(n)cmp for comparison.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* psymtab.c (read_psymtabs_with_filename): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	(reload_shared_libraries_1): Likewise.
	* symmisc.c (maintenance_print_symbols): Likewise.
	* symfile.c (separate_debug_file_exists): Likewise.
	(reread_symbols): Likewise.
	(find_separate_debug_file_by_debuglink): Likewise.
	* remote-fileio.c (remote_fileio_func_rename): Likewise.
	* source.c (add_path): Likewise.
	* symtab.c (filename_seen): Likewise.
	(file_matches): Likewise.
	(print_symbol_info): Likewise.
	(maybe_add_partial_symtab_filename): Likewise.
	(make_source_files_completion_list): Likewise.
	* xml-syscall.c (init_sysinfo): Likewise.
	* windows-nat.c (_initialize_check_for_gdb_ini): Use
	IS_DIR_SEPARATOR for checking for trailing path separator.
@
text
@d651 2
a652 1
						  flags, sap, OBJF_SHARED);
@


1.146
log
@2011-03-04  Michael Snyder  <msnyder@@vmware.com>

	* solib.c (reload_shared_libraries_1): Close memory leak.
@
text
@d641 1
a641 1
	      if (strcmp (so->objfile->name, so->so_name) == 0
d765 1
a765 1
	      if (! strcmp (gdb->so_original_name, i->so_original_name))
d1342 1
a1342 1
	      && strcmp (found_pathname, so->so_name) != 0))
d1354 1
a1354 1
	      || strcmp (found_pathname, so->so_name) != 0))
@


1.145
log
@2011-01-25  Mathieu Lacage  <mathieu.lacage@@inria.fr>

	PR/symtab 11766:
	* gdb/objfiles.h (struct objfile) <addr_low>: New field.
	* gdb/solib.c (solib_read_symbols): Check for addr_low in
	equality test for objfile, initialize addr_low if needed.
@
text
@d1329 1
@


1.144
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d641 2
a642 1
	      if (strcmp (so->objfile->name, so->so_name) == 0)
d652 1
@


1.143
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d348 1
a348 1
  /* If not found, try to use target supplied solib search method */
d353 1
a353 1
  /* If not found, next search the inferior's $PATH environment variable. */
d361 1
a361 1
     environment variable. */
d503 1
a503 1
     can find it */
d518 1
a518 1
         mapped. */
d583 1
a583 1
   If we have opened a BFD for SO, close it.  
d1380 1
a1380 1
  /* Creating inferior hooks here has two purposes. First, if we reload 
@


1.142
log
@run copyright.sh for 2011.
@
text
@d105 2
a106 2
  fprintf_filtered (file, _("\
The search path for loading non-absolute shared library symbol files is %s.\n"),
d836 3
a838 2
	    exception_fprintf (gdb_stderr, e, _("\
Error while mapping shared library sections:\n"));
d853 3
a855 3
	warning (_("\
Could not load shared library symbols for %s.\n\
Do you need \"set solib-search-path\" or \"set sysroot\"?"),
d908 2
a909 1
solib_add (char *pattern, int from_tty, struct target_ops *target, int readsyms)
d1101 2
a1102 1
			_("(*): Shared library is missing debugging information.\n"));
d1359 3
a1361 2
	    exception_fprintf (gdb_stderr, e, _("\
Error while mapping shared library sections:\n"));
d1474 2
a1475 1
inferior.  Otherwise, symbols must be loaded manually, using `sharedlibrary'."),
d1498 6
a1503 3
Set the search path for loading non-absolute shared library symbol files."), _("\
Show the search path for loading non-absolute shared library symbol files."), _("\
This takes precedence over the environment variables PATH and LD_LIBRARY_PATH."),
@


1.141
log
@gdb/
	* solib.c (solib_read_symbols): Call exception_fprintf even without
	FROM_TTY.  Print also so->so_name.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010
@


1.140
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* scm-exp.c: White space.
	* scm-lang.c: White space.
	* scm-valprint.c: White space.
	* sentinel-frame.c: White space.
	* ser-base.c: White space.
	* ser-go32.c: White space.
	* serial.c: White space.
	* ser-mingw.c: White space.
	* ser-pipe.c: White space.
	* ser-tcp.c: White space.
	* ser-unix.c: White space.
	* solib.c: White space.
	* solib-darwin.c: White space.
	* solib-frv.c: White space.
	* solib-irix.c: White space.
	* solib-osf.c: White space.
	* solib-pa64.c: White space.
	* solib-som.c: White space.
	* solib-spu.c: White space.
	* solib-svr4.c: White space.
	* solib-target.c: White space.
	* source.c: White space.
	* stabsread.c: White space.
	* stack.c: White space.
	* std-regs.c: White space.
	* symfile.c: White space.
	* symmisc.c: White space.
	* symtab.c: White space.
@
text
@d655 3
a657 6
	{
	  if (from_tty)
	    exception_fprintf
	      (gdb_stderr, e,
	       _("Error while reading shared library symbols:\n"));
	}
@


1.139
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* solib.c (solib_find): Delete unused variable.
	(free_so_symbols): Delete unused variable.
	(info_sharedlibrary_command): Delete unused variable.
	(reload_shared_libraries_1): Delete unused variable.
	(_initialize_solib): Delete unused variable.
@
text
@d71 1
d81 1
d174 1
d1206 1
d1236 1
d1260 1
@


1.138
log
@	* defs.h: Adjust comment.
	* filesystem.h, filesystem.c: New files.
	* Makefile.in (SFILES): Add filesystem.c.
	(COMMON_OBS): Add filesystem.o.
	* solib.c (solib_find): Handle DOS-based filesystems.  Handle
	different target and host path flavours.
	* arm-symbian-tdep.c (arm_symbian_init_abi): Set
	has_dos_based_file_system on the gdbarch.
	* arm-wince-tdep.c (arm_wince_init_abi): Ditto.
	* i386-cygwin-tdep.c (i386_cygwin_init_abi): Ditto.
	* i386-tdep.c (i386_go32_init_abi): Ditto.
	* gdbarch.sh (has_dos_based_file_system): New.
	* gdbarch.h, gdbarch.c: Regenerate.
	* NEWS: Mention improved support for remote targets with DOS-based
	filesystems.  Mention new `set/show target-file-system-kind'
	commands.

	gdb/doc/
	* gdb.texinfo (Commands to specify files): Describe what how GDB
	looks up DOS-based filesystem paths on the system root.  Document
	the new `set/show target-file-system-kind' commands.
@
text
@a283 2
	  char *p;

a548 2
  char *bfd_filename = 0;

a998 1
  int header_done = 0;
a1315 1
      int scratch_chan;
a1450 2
  struct cmd_list_element *c;

@


1.137
log
@	Avoid rereading shared libraries that haven't changed.

	* solib.c (free_so_symbols): New function, from ...
	(free_so): ... here.  Call it.
	(solib_read_symbols): Don't warn here if symbols have already been
	loaded.
	(solib_add): Warn here instead, if a pattern was specified.
	(reload_shared_libraries_1): New.
	(reload_shared_libraries): Rewrite to not fetch the library list.
@
text
@d50 1
d108 7
d144 1
a144 1
   *   
d163 3
d191 1
a191 3
  if (! IS_ABSOLUTE_PATH (in_pathname) || gdb_sysroot_is_empty)
    temp_pathname = in_pathname;
  else
d200 44
d245 3
a247 4
      temp_pathname = alloca (prefix_len + strlen (in_pathname) + 1);
      strncpy (temp_pathname, gdb_sysroot, prefix_len);
      temp_pathname[prefix_len] = '\0';
      strcat (temp_pathname, in_pathname);
d254 1
a254 1
      return xstrdup (temp_pathname);
d259 2
d262 56
a317 10
  /* We try to find the library in various ways.  After each attempt
     (except for the one above), either found_file >= 0 and
     temp_pathname is a malloc'd string, or found_file < 0 and
     temp_pathname does not point to storage that needs to be
     freed.  */

    if (found_file < 0)
      temp_pathname = NULL;
    else
      temp_pathname = xstrdup (temp_pathname);
d323 1
a323 1
  if (found_file < 0 && IS_ABSOLUTE_PATH (in_pathname))
d326 2
a327 2
      while (!IS_DIR_SEPARATOR (*in_pathname))
        in_pathname++;
d330 2
a331 2
      while (IS_DIR_SEPARATOR (*in_pathname))
        in_pathname++;
d333 1
a333 1
  
d338 1
a338 1
  
d344 2
a345 2
                        lbasename (in_pathname), O_RDONLY | O_BINARY,
                        &temp_pathname);
d359 1
a359 1
  /* If not found, next search the inferior's $LD_LIBRARY_PATH 
@


1.136
log
@	Group errors for many missing shared libraries.

	* solist.h (struct so_list): Remove from_tty.
	* solib.c (solib_bfd_open): Return NULL if we failed to open a BFD.
	(solib_map_sections): Take so_list argument.  Return 0 if we
	failed to open a BFD.  Add target sections here.
	(symbol_add_stub): Delete.
	(solib_read_symbols): Inline symbol_add_stub.  Use current flags,
	not from_tty copied from the so_list.  Don't warn a second time
	for a missing library.
	(update_solib_list): Don't save from_tty.  Use TRY_CATCH.  Do not
	add to the section table here.  Print out a single warning for all
	missing libraries.
	* bsd-uthread.c (bsd_uthread_solib_loaded): Always pass 0 for
	flags.
@
text
@d440 33
d499 1
a499 5
  if (so->sections)
    xfree (so->sections);

  gdb_bfd_unref (so->abfd);

d524 1
a524 2
      if (from_tty || info_verbose)
	printf_unfiltered (_("Symbols already loaded for %s\n"), so->so_name);
d846 13
a858 2
	  if (add_this_solib && solib_read_symbols (gdb, flags))
	    loaded_any_symbols = 1;
d1208 61
d1273 6
a1278 1
  no_shared_libraries (NULL, from_tty);
d1290 9
d1315 7
a1321 4
  /* We have unloaded and then reloaded debug info for all shared libraries.
     However, frames may still reference them, for example a frame's 
     unwinder might still point of DWARF FDE structures that are now freed.
     Reinit frame cache to avoid crashing.  */
d1323 2
@


1.135
log
@dwarf2_physname patchset:

	Based on work from Daniel Jacobowitz  <dan@@codesourcery.com>
	* c-typeprint.c (cp_type_print_method_args): For non-static methods,
	print out const or volatile qualifiers, too.
	(c_type_print_args): Add parameters show_artificial and language.
	Skip artificial parameters when requested.
	Use the appropriate language printer.
	(c_type_print_varspec): Tell c_type_print_args to skip artificial
	parameters and pass language_c.
	* dwarf2read.c (die_list): New file global.
	(struct partial_die_info): Update comments for name field.
	(pdi_needs_namespace): Renamed to ...
	(die_needs_namespace): ... this. Rewrite.
	(dwarf2_linkage_name): Remove.
	(add_partial_symbol): Do not predicate the call to
	partial_die_full_name based on pdi_needs_namespace.
	Remove call to cp_check_possible_namespace_symbols and associated
	outdated comments.
	(guess_structure_name): Do not inspect child subprogram DIEs.
	(dwarf2_fullname): Update comments.
	Use die_needs_namespace to assist in computing the name.
	(read_func_scope): Use dwarf2_name to get the DIE's name.
	Use dwarf2_physname to get the "linkage name" of the DIE.
	(dwarf2_add_member_field): Use dwarf2_physname instead of
	dwarf2_linkage_name.
	(read_structure_type): For structs and classes, set TYPE_NAME, too.
	(determine_class): Remove.
	(read_partial_die): Ignore DW_AT_MIPS_linkage_name for all languages
	except Ada.
	(new_symbol): Unconditionally call dwarf2_name.
	Compute the "linkage name" using dwarf2_physname.
	Use dwarf2_name instead of dwarf2_full_name for enumerator DIEs.
	When determining to scan for anonymous C++ namespaces, ignore
	the linkage name.
	(dwarf2_physname): New function.
	(dwarf2_full_name): Move content to new function and call
	that.
	(dwarf2_compute_name): "New" function.
	(_initialize_dwarf2_read): Initialize die_list.
	* gnu-v3-eabi.c (gnu_v3_find_method_in): Remove unused variable
	physname.
	(gnu_v3_print_method_ptr): Use the physname for virtual methods
	without a demangled name.
	Print out type information for non-virtual methods.
        * linespec.c (decode_line_1): Force ANY string using "::" (or
	"." for java) to use decode_compound, and clean up any stray quoting.
        If we found a file symtab, re-evaluate whether the remainder is_quoted.
        (decode_compound): Stop consuming at an open parenthesis.
        Keep template parameters.
        Keep any overload information.
        Keep keywords like "const".
        Remove paren_pointer.
        Move is_quoted check from set_flags to here.
        Remove #if 0 code from 2000. Ten years is long enough.
        (find_method): Before comparing symbol names, canonicalize the string
        from the user.
        If a specific overload is requested, find it. Otherwise throw an error.
	(find_method_overload_end): New function.
	(set_flags): Remove.
        (decode_compound): Assume that parentheses are matched.
        It's a lot easier.
	* symtab.c (symbol_find_demangled_name): Add DMGL_VERBOSE flag
	to cplus_demangle.
	* linespec.c (decode_line_1): Keep important keywords like
	"const" and "volatile".
	* symtab.h (SYMBOL_CPLUS_DEMANGLED_NAME): Remove.
	* typeprint.h (c_type_print_args): Add declaration.
	* ui-file.c (do_ui_file_obsavestring): New function.
	(ui_file_obsavestring): New function.
	* ui-file.h (ui_file_obsavestring): Add declaration.
	* valops.c (find_overload_match): Resolve the object to
	a non-pointer type.
	If the object is a data member, search the object for the member
	and return with staticp set.
	Use SYMBOL_NATURAL_NAME instead of SYMBOL_CPLUS_DEMANGLED_NAME.
	Do not attempt to extract a function name from non-function types.
	If the extracted function name and the original name are the same,
	we don't have a C++ method.

	From Jan Kratochvil  <jan.kratochvil@@redhat.com>:
    	* dwarf2read.c (new_symbol <DW_TAG_enumerator>): Call dwarf2_full_name.

	* ada-lang.c (ada_lookup_symbol): Remove linkage_name parameters
	and arguments from symbol lookups.
	* ax-gdb.c (gen_expr): Likewise.
	* cp-namespace.c (cp_lookup_symbol_nonlocal, lookup_namespace_scope,
	cp_lookup_symbol_namespace, lookup_symbol_file, lookup_nested_type,
	lookup_possible_namespace_symbol): Likewise.
	* cp-support.c (read_in_psymtabs): Likewise.
	* cp-support.h (cp_lookup_symbol_nonlocal): Likewise.
	* language.h (la_lookup_symbol_nonlocal): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* solib-darwin.c (darwin_relocate_section_addresses): Likewise.
	* solib-svr.c (elf_lookup_lib): Likewise.
	* solib.c (show_auto_solib_add): Likewise.
	* solist.h (lookup_lib_global, solib_global_lookup): Likewise.
	* symmisc.c (maintenance_check_symtabs): Likewise.
	* symtab.c (lookup_symbol_in_language, lookup_symbol_aux,
	lookup_symbol_aux_local, lookup_symbol_aux_block,
	lookup_symbol_from_objfile, lookup_symbol_aux_symtabs,
	lookup_symbol_aux_psymtabs,basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global, symbol_matches_domain,
	basic_lookup_transparent_type, find_main_psymtab,
	lookup_block_symbol): Likewise.
	* symtab.h (basic_lookp_symbol_nonlocal, lookup_symbol_static,
	lookup_symbol_global, lookup_symbol_aux_block,
	lookup_symbol_partial_symbol, lookup_block_symbol,
	lookup_global_symbol, value_maybe_namespace_elt): Likewise.
@
text
@d322 8
a329 1
    perror_with_name (pathname);
d382 1
a382 1
solib_map_sections (void *arg)
a383 1
  struct so_list *so = (struct so_list *) arg;	/* catch_errors bogon */
d395 3
d431 7
a437 1
  return (1);
a483 21
static void
symbol_add_stub (struct so_list *so, int flags)
{
  struct section_addr_info *sap;

  /* Have we already loaded this shared object?  */
  ALL_OBJFILES (so->objfile)
    {
      if (strcmp (so->objfile->name, so->so_name) == 0)
	return;
    }

  sap = build_section_addr_info_from_section_table (so->sections,
                                                    so->sections_end);

  so->objfile = symbol_file_add_from_bfd (so->abfd, flags, sap, OBJF_SHARED);
  free_section_addr_info (sap);

  return;
}

d500 2
a501 2
      if (from_tty || info_verbose)
	printf_unfiltered (_("Symbol file not found for %s\n"), so->so_name);
d505 35
a539 14
      volatile struct gdb_exception exception;
      TRY_CATCH (exception, RETURN_MASK_ALL)
        {
          symbol_add_stub (so, flags);
        }
      if (exception.reason != 0)
        {
          exception_fprintf (gdb_stderr, exception,
                             "Error while reading shared library symbols:\n");
          return 0;
        }
      if (from_tty || info_verbose)
        printf_unfiltered (_("Loaded symbols for %s\n"), so->so_name);
      so->symbols_loaded = 1;
d685 3
d696 2
a697 1
	  i->from_tty = from_tty;
d700 14
a713 10
	  /* Fill in the rest of the `struct so_list' node.  */
	  catch_errors (solib_map_sections, i,
			"Error while mapping shared library sections:\n",
			RETURN_MASK_ALL);

	  /* Add the shared object's sections to the current set of
	     file section tables.  Do this immediately after mapping
	     the object so that later nodes in the list can query this
	     object, as is needed in solib-osf.c.  */
	  add_target_sections (i->sections, i->sections_end);
d716 1
a716 1
             loaded now that we've added it to GDB's tables.  */
d719 19
@


1.134
log
@	* solib.c (solib_find): Replace extension if
	solib_symbols_extension is set in the target gdbarch.
	* arm-symbian-tdep.c (arm_symbian_init_abi): Set
	solib_symbols_extension to "sym".
	* gdbarch.sh (solib_symbols_extension): New variable.
	(pstring): New function.
	* gdbarch.h, gdbarch.c: Regenerate.
@
text
@a1180 1
		     const char *linkage_name,
d1186 1
a1186 1
    return ops->lookup_lib_global_symbol (objfile, name, linkage_name, domain);
@


1.133
log
@	Per-inferior args and tty and environment.

	* infcmd.c (inferior_args): Rename to ...
	(inferior_args_scratch): ... this.
	(inferior_io_terminal): Rename to ...
	(inferior_io_terminal_scratch): ... this.
	(inferior_argc, inferior_argv): Remove.
	(set_inferior_io_terminal, get_inferior_io_terminal): Store
	inside current_inferior().
	(set_inferior_tty_command, show_inferior_tty_command): New.
	(get_inferior_args, set_inferior_args): Store inside
	current_inferior().
	(notice_args_set): Likewise and rename to...
	(set_args_command): ... this.
	(set_inferior_args_vector): Likewise.
	(notice_args_read): Rename to...
	(show_args_command): ...new.
	(tty_command): Remove.
	(run_command_1): Don't free old args, as they are freed by
	set_inferior_arg now.
	(run_no_args_command): Likewise.
	(inferior_environ): Remove.
	(run_command_1): Use environment of the current inferior.
	(environment_info, set_environment_command)
	(unset_environment_command, path_info, path_command): Likewise.
	(_initialize_infcmd): Adjust for function and variable renames.
	Do not init inferior_environ.
	* inferior.h (set_inferior_arg): Adjust prototype.
	(struct inferior): New fields args, argc, argv, terminal, environment.
	(inferior_environ): Remove declaration.
	* inferior.c (free_inferior): Free new fields.
	(add_inferior_silent): Initialize 'environment' field.
	* main.c (captured_main): Set arguments only after the initial
	inferior has been created.  Set set_inferior_io_terminal,
	not tty_command.
	* mi/mi-main.c (mi_cmd_env_path): Use environment of the current
	inferior.
	(_initialize_mi_cmd_env): Adjust for disappearance of global
	inferior_environ.
	* solib.c (solib_find): Use environment of the current inferior.
@
text
@d153 24
@


1.132
log
@gdb/
	* solib.c (info_sharedlibrary_command): Replace
	objfile_has_partial_symbols and objfile_has_full_symbols calls by
	objfile_has_symbols.
@
text
@d230 2
a231 1
    found_file = openp (get_in_environ (inferior_environ, "PATH"),
d238 2
a239 1
    found_file = openp (get_in_environ (inferior_environ, "LD_LIBRARY_PATH"),
@


1.131
log
@gdb/
	Add from_tty to solib_create_inferior_hook.
	* infcmd.c (post_create_inferior): Move solib_add after
	solib_create_inferior_hook.  Pass from_tty to
	solib_create_inferior_hook.  Call solib_add and SOLIB_ADD with
	0 from_tty and comment why.
	* infrun.c (follow_exec): Pass from_tty solib_create_inferior_hook as 0.
	* linux-nat.c (linux_child_follow_fork): Likewise.
	* nto-procfs.c (procfs_post_attach, procfs_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): New parameter
	from_tty.
	* solib-frv.c (frv_solib_create_inferior_hook): Likewise.
	* solib-irix.c (irix_solib_create_inferior_hook): Likewise.
	* solib-null.c (null_solib_create_inferior_hook): Likewise.
	* solib-osf.c (osf_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-som.c (som_solib_create_inferior_hook): Likewise.
	* solib-spu.c (spu_solib_create_inferior_hook): New parameter from_tty.
	Pass it to svr4_so_ops.solib_create_inferior_hook.
	* solib-sunos.c (sunos_solib_create_inferior_hook): New parameter
	from_tty.
	* solib-svr4.c (enable_break): New parameter from_tty.  Pass it to
	solib_add.
	(svr4_solib_create_inferior_hook): New parameter from_tty.  Pass it to
	enable_break.
	* solib-target.c (solib_target_solib_create_inferior_hook): New
	parameter from_tty.
	* solib.c (solib_create_inferior_hook): New parameter from_tty.  Pass
	it to ops->solib_create_inferior_hook.
	(reload_shared_libraries): Pass from_tty to solib_create_inferior_hook.
	Move solib_add after solib_create_inferior_hook, call it now with
	from_tty as 0.  New comment there.
	* solib.h (solib_create_inferior_hook): New parameter from_tty.
	* solist.h (struct target_so_ops <solib_create_inferior_hook>):
	Likewise.
@
text
@d866 1
a866 2
	  && !objfile_has_partial_symbols (so->objfile)
	  && !objfile_has_full_symbols (so->objfile))
@


1.130
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1018 1
a1018 1
   void solib_create_inferior_hook ()
d1028 1
a1028 1
solib_create_inferior_hook (void)
d1031 1
a1031 1
  ops->solib_create_inferior_hook();
a1106 1
  solib_add (NULL, from_tty, NULL, auto_solib_add);
d1121 1
a1121 1
      solib_create_inferior_hook ();
d1124 10
@


1.129
log
@	* gcore.c: Include solib.h.
	(gcore_create_callback): Call solib_keep_data_in_core when
	considering not saving memory in core file.
	* solib-svr4.c (svr4_keep_data_in_core): New.
	(_initialize_svr4_solib): Initialize
	svr4_so_ops.keep_data_in_core.
	* solib.c (solib_keep_data_in_core): New.
	* solib.h (solib_keep_data_in_core): Declare.
	* solist.h (struct target_so_ops): Add keep_data_in_core.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009
@


1.128
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d951 17
@


1.127
log
@        * solib.c (solib_bfd_open): Relax a bit the compatibility check.
@
text
@d89 2
a90 3
/* local data declarations */

static struct so_list *so_list_head;	/* List of known shared objects */
d653 1
d940 1
a940 1
solib_name_from_address (CORE_ADDR address)
d942 1
a942 1
  struct so_list *so = 0;	/* link map state variable */
d944 1
a944 1
  for (so = so_list_head; so; so = so->next)
@


1.126
log
@	* NEWS: Add note on "info sharedlibrary".
	Remove note on "set print symbol-loading".
	* main.c (captured_main): Pass !batch for from_tty when calling
	symbol_file_add_main.
	* objfiles.h (objfile_has_partial_symbols): Declare.
	(objfile_has_full_symbols): Declare.
	* objfiles.c (objfile_has_partial_symbols): New function.
	(have_partial_symbols): Use it.
	(objfile_has_full_symbols): New function.
	(have_full_symbols): Use it.
	* solib.c: Include interps.h.
	(solib_read_symbols): Back out patch of 2008-07-10.
	Add test for info_verbose for symbol loading messages for
	consistency with symfile.c.
	(info_sharedlibrary_command): Handle optional parameter of regex of
	libraries to list.  Inform user of libraries without debugging info.
	Rewrite to use ui_out routines to format output.
	* symfile.c (print_symbol_loading): Delete.
	(symbol_file_add_with_addrs_or_offsets): Back out patch of 2008-07-10.
	Print "no debugging symbols found" only if from_tty || info_verbose;
	and only check file being loaded, not all files.
	(reread_symbols): Test file being loaded for whether it has symbols,
	not all files.
	(__initialize_symfile): Delete `set print symbol-loading'.
	* symfile.h (print_symbol_loading): Delete.

	* doc/gdb.texinfo (Symbols): Delete `set print symbol-loading'.
	(Files): Add note on new optional regex arg to `info sharedlibrary'.
@
text
@d313 1
a313 1
  if (b->compatible (b, bfd_get_arch_info (abfd)) != b)
@


1.126.2.1
log
@        * solib.c (solib_bfd_open): Relax a bit the compatibility check.
@
text
@d313 1
a313 1
  if (!b->compatible (b, bfd_get_arch_info (abfd)))
@


1.125
log
@2009-08-21  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* objfiles.h (gdb_bfd_ref): New prototype.
	* objfiles.c (gdb_bfd_ref): New function.
	(allocate_objfile): Call it.
	(gdb_bfd_unref): Adjust assertion.
	* solib.c (solib_map_sections): Add reference.
	(symbol_add_stub): Don't add reference here.
	* symfile.c (reread_symbols): Add reference.
@
text
@d49 1
d476 1
a476 1
      if (from_tty)
d481 1
a481 1
      if (from_tty)
d497 1
a497 1
      if (from_tty && print_symbol_loading)
d788 2
a789 1
   about each attached library.
d793 1
a793 1
info_sharedlibrary_command (char *ignore, int from_tty)
d797 1
d799 11
d812 1
a812 1
  addr_width = 4 + (gdbarch_ptr_bit (target_gdbarch) / 4);
d816 26
d844 15
a858 1
      if (so->so_name[0])
d860 3
a862 7
	  if (!header_done)
	    {
	      printf_unfiltered ("%-*s%-*s%-12s%s\n", addr_width, "From",
				 addr_width, "To", "Syms Read",
				 "Shared Object Library");
	      header_done++;
	    }
d864 7
a870 14
	  printf_unfiltered ("%-*s", addr_width,
			     so->addr_high != 0
			       ? hex_string_custom (
			           (LONGEST) so->addr_low,
	                           addr_width - 4)
			       : "");
	  printf_unfiltered ("%-*s", addr_width,
			     so->addr_high != 0
			       ? hex_string_custom (
			           (LONGEST) so->addr_high,
	                           addr_width - 4)
			       : "");
	  printf_unfiltered ("%-12s", so->symbols_loaded ? "Yes" : "No");
	  printf_unfiltered ("%s\n", so->so_name);
d872 9
d882 13
a894 1
  if (so_list_head == NULL)
d896 3
a898 1
      printf_unfiltered (_("No shared libraries loaded at this time.\n"));
@


1.124
log
@gdb/
	* objfiles.c (gdb_bfd_unref): Use the bfd_usrdata accessor.
	* solib.c (symbol_add_stub): Likewise.
	* symfile.c (symfile_bfd_open): Assert BFD_USRDATA is NULL.
@
text
@d364 1
a364 1
  so->abfd = abfd;
a446 1
  int *p_refcount;
a458 4
  p_refcount = xmalloc (sizeof (*p_refcount));
  *p_refcount = 2;  /* Both solib and objfile refer to this abfd.  */
  bfd_usrdata (so->abfd) = p_refcount;

@


1.123
log
@2009-08-04  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* objfiles.h (OBJF_KEEPBFD): Delete.
	(gdb_bfd_unref): New prototype.
	* objfiles.c (gdb_bfd_unref): New function.
	(free_objfile): Call gdb_bfd_unref.
	* solib.c (free_so): Likewise.
	(symbol_add_stub): Set refcount.
@
text
@d462 1
a462 1
  so->abfd->usrdata = p_refcount;
@


1.122
log
@	* solib.c (solib_bfd_open): Do not call ops->bfd_open.
	(solib_map_sections): Call ops->bfd_open instead of solib_bfd_open.
	* solib-frv.c (_initialize_frv_solib): Initialize bfd_open member.
	* solib-irix.c (_initialize_irix_solib): Likewise.
	* solib-null.c (_initialize_null_solib): Likewise.
	* solib-osf.c (_initialize_osf_solib): Likewise.
	* solib-pa64.c (_initialize_pa64_solib): Likewise.
	* solib-som.c (_initialize_som_solib): Likewise.
	* solib-sunos.c (_initialize_sunos_solib): Likewise.
	* solib-svr4.c (_initialize_svr4_solib): Likewise.
	* solib-target.c (_initialize_solib_target): Likewise.
@
text
@a423 1
  char *bfd_filename = 0;
a426 8
      
  if (so->abfd)
    {
      bfd_filename = bfd_get_filename (so->abfd);
      if (! bfd_close (so->abfd))
	warning (_("cannot close \"%s\": %s"),
		 bfd_filename, bfd_errmsg (bfd_get_error ()));
    }
d428 1
a428 2
  if (bfd_filename)
    xfree (bfd_filename);
d447 1
d459 5
a463 2
  so->objfile = symbol_file_add_from_bfd (so->abfd, flags,
					  sap, OBJF_SHARED | OBJF_KEEPBFD);
@


1.121
log
@2009-07-09  Hui Zhu  <teawater@@gmail.com>

	* solib.c (solib_bfd_open): Output a warning if solib's
	architecture is not compatible with inferior's architecture.
@
text
@a287 1
  struct target_so_ops *ops = solib_ops (target_gdbarch);
a292 4
  /* Use target-specific override if present.  */
  if (ops->bfd_open)
    return ops->bfd_open (pathname);

d352 1
d360 1
a360 1
  abfd = solib_bfd_open (filename);
a379 2
      struct target_so_ops *ops = solib_ops (target_gdbarch);

@


1.120
log
@2009-06-16  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* solib.c (symbol_add_stub): New FLAGS parameter.
	(solib_read_symbols): FROM_TTY -> FLAGS, call symbol_add_stub
	directly.
	(solib_add): Defer breakpoint_re_set until after all solibs.
	* bsd-uthread.c (bsd_uthread_solib_loaded): Adjust.
	* rs6000-nat.c (objfile_symbol_add): Adjust.
	* symfile.c (syms_from_objfile): Merge parameters into ADD_FLAGS.
	(new_symfile_objfile): Likewise.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	(symbol_file_add_from_bfd): Likewise.
	(symbol_file_add): Likewise.
	* symfile.h (enum symfile_add_flags): New. Adjust prototypes.
	* symfile-mem.c (symbol_file_add_from_memory): Adjust.
	* windows-nat.c (safe_symbol_file_add_stub): Adjust.
	* machoread.c (macho_oso_symfile, macho_symfile_read): Adjust.
@
text
@d292 1
d315 7
@


1.119
log
@	* target.c: Include "exec.h".
	(update_current_target): Don't inherit to_sections or
	to_sections_end.
	(target_get_section_table): New.
	(target_section_by_addr): Fetch the section table from the passed
	in target.
	(memory_xfer_partial): Handle unmapped overlay sections before
	anything else.  Get the overlay mapped address here.  Adjust to
	use section_table_xfer_memory_partial.
	(get_target_memory): Request a TARGET_OBJECT_RAW_MEMORY object
	instead of TARGET_OBJECT_MEMORY.
	(target_resize_to_sections): Delete.
	(remove_target_sections): Adjust to remove target sections from
	`current_target_sections', and use resize_section_table.
	* target.h (struct target_ops) <to_sections, to_sections_end>:
	Remove fields.
	<to_get_section_table>: New method.
	(xfer_memory, print_section_info): Delete declarations.
	(struct target_section_table): New type.
	(target_get_section_table): Declare.
	(target_resize_to_sections): Delete declaration.
	(remove_target_sections): Delete declaration.
	* bfd-target.c (target_bfd_xfer_partial): Get the section table
	from to_data.
	(target_bfd_get_section_table): New.
	(target_bfd_xclose): Adjust.
	(target_bfd_reopen): Store the section table in the to_data field.
	* corelow.c (core_data): New.
	(core_close): Adjust to release core_data and its sections.
	(core_open): Allocate core_data, and build its target sections
	table.
	(deprecated_core_resize_section_table): New.
	(core_files_info): Pass core_data to print_section_info.
	(core_xfer_partial): Adjust to use
	section_table_xfer_memory_partial for TARGET_OBJECT_MEMORY xfers.
	(init_core_ops): Do not install a deprecated_xfer_memory callback
	anymore.
	* solib.c (update_solib_list): Add the shared library sections
	to the current target sections table.
	* exec.c (current_target_sections_1): New global.
	(current_target_sections): New global.
	(exec_close_1): New function, refactored from exec_close.  Remove
	the exec_bfd's sections from the current target sections table.
	Adjust to not use to_sections.
	(exec_close): Remove all target sections.  Call exec_close_1.
	(exec_file_clear): Use exec_close_1 instead of unpushing the
	target.
	(exec_file_attach): Likewise.  Adjust to not use to_sections.  Add
	exec_bfd's sections to the current target sections table.  Don't
	push the exec_ops target here.
	(resize_section_table): New.
	(add_target_sections): New.
	(remove_target_sections): Moved here.
	(section_table_xfer_memory): Adjust to implement the xfer_partial
	interface, and rename to...
	(section_table_xfer_memory_partial): ... this, replacing the
	current function of that same name.
	(exec_get_section_table): New.
	(exec_xfer_partial): New.
	(xfer_memory): Delete.
	(print_section_info): Replace the target_ops parameter by a
	target_section_table parameter.
	(exec_files_info, set_section_command, exec_set_section_address):
	Adjust to use the current sections table.
	(init_exec_ops): Do not register a deprecated_xfer_memory
	callback.  Register to_xfer_partial and to_get_section_table
	callbacks.
	* infrun.c (handle_inferior_event): Update comments around
	solib_add.
	* rs6000-nat.c (xcoff_relocate_core): Adjust to use
	deprecated_core_resize_section_table.
	* exec.h (resize_section_table): Declare.
	(section_table_xfer_memory_partial): Add const char * argument.
	(remove_target_sections): Declare here.
	(add_target_sections): Declare.
	(print_section_info): Declare here.
	* gdbcore.h (deprecated_core_resize_section_table): Declare.
@
text
@d451 2
a452 5

/* A small stub to get us past the arg-passing pinhole of catch_errors.  */

static int
symbol_add_stub (void *arg)
a453 1
  struct so_list *so = (struct so_list *) arg;  /* catch_errs bogon */
d460 1
a460 1
	return 1;
d466 2
a467 2
  so->objfile = symbol_file_add_from_bfd (so->abfd, so->from_tty,
					  sap, 0, OBJF_SHARED | OBJF_KEEPBFD);
d470 1
a470 1
  return (1);
d473 2
a474 2
/* Read in symbols for shared object SO.  If FROM_TTY is non-zero, be
   chatty about it.  Return non-zero if any symbols were actually
d478 1
a478 1
solib_read_symbols (struct so_list *so, int from_tty)
d480 2
d494 15
a508 9
      if (catch_errors (symbol_add_stub, so,
			"Error while reading shared library symbols:\n",
			RETURN_MASK_ALL))
	{
	  if (from_tty && print_symbol_loading)
	    printf_unfiltered (_("Loaded symbols for %s\n"), so->so_name);
	  so->symbols_loaded = 1;
	  return 1;
	}
d743 2
d758 1
a758 1
	  if (add_this_solib && solib_read_symbols (gdb, from_tty))
d762 3
@


1.118
log
@	* target.h (struct section_table): Rename to ...
	(struct target_section): ... this.
	* exec.c: Adjust all references.
	* exec.h: Adjust all references.
	* nto-tdep.c: Adjust all references.
	* nto-tdep.h: Adjust all references.
	* ppc-linux-tdep.c: Adjust all references.
	* rs6000-nat.c: Adjust all references.
	* s390-tdep.c: Adjust all references.
	* solib-darwin.c: Adjust all references.
	* solib-frv.c: Adjust all references.
	* solib-irix.c: Adjust all references.
	* solib-null.c: Adjust all references.
	* solib-osf.c: Adjust all references.
	* solib-pa64.c: Adjust all references.
	* solib-som.c: Adjust all references.
	* solib-sunos.c: Adjust all references.
	* solib-svr4.c: Adjust all references.
	* solib-target.c: Adjust all references.
	* solib.c: Adjust all references.
	* solist.h: Adjust all references.
	* symfile.c: Adjust all references.
	* symfile.h: Adjust all references.
	* target.c: Adjust all references.
@
text
@d664 5
a668 15
	  /* If requested, add the shared object's sections to the TARGET's
	     section table.  Do this immediately after mapping the object so
	     that later nodes in the list can query this object, as is needed
	     in solib-osf.c.  */
	  if (target)
	    {
	      int count = (i->sections_end - i->sections);
	      if (count > 0)
		{
		  int space = target_resize_to_sections (target, count);
		  memcpy (target->to_sections + space,
			  i->sections,
			  count * sizeof (i->sections[0]));
		}
	    }
@


1.117
log
@gdb/
	Remove the PROT parameter from openp.
	* source.c (openp): Remove the parameter PROT.  Assertion check MODE.
	defs.h (openp): Update the prototype.
	Update all the openp callers.
@
text
@d350 1
a350 1
  struct section_table *p;
d852 1
a852 1
  struct section_table *p;
@


1.116
log
@2009-05-15  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* NEWS: Mention set/show libthread-db-search-path.
	* gdb_thread_db.h (LIBTHREAD_DB_SEARCH_PATH): New define.
	(LIBTHREAD_DB_SO): Moved from linux-thread-db.c
	* linux-thread-db.c (libthread_db_search_path): New setting.
	(thread_db_handle): New variable (replaces using_thread_db).
	(try_thread_db_load_1): New function.
	(try_thread_db_load, thread_db_load_search): Likewise.
	(dladdr_to_soname): Likewise.
	(thread_db_load): Iterate over possibly multiple libthread_db's.
	(check_for_thread_db): Attempt to load new libthread_db.
	(thread_db_detach, thread_db_wait): Unload libthread_db.
	(thread_db_mourn_inferior): Likewise.
	(_initialize_thread_db): Add new libthread-db-search-path option.
	Defer loading of libthread_db to check_for_thread_db.
	* solib.c (libpthread_name_p): New function.
	(libpthread_solib_p): Call it.
	* solib.h (libpthread_name_p): New prototype.
@
text
@d213 1
a213 1
			in_pathname, O_RDONLY | O_BINARY, 0, &temp_pathname);
d220 1
a220 1
                        lbasename (in_pathname), O_RDONLY | O_BINARY, 0,
d231 1
a231 1
			OPF_TRY_CWD_FIRST, in_pathname, O_RDONLY | O_BINARY, 0,
d238 1
a238 1
			OPF_TRY_CWD_FIRST, in_pathname, O_RDONLY | O_BINARY, 0,
@


1.115
log
@2009-03-09  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* solib.c (solib_contains_address_p): New function.
	(solib_name_from_address): Use it.
	* printcmd.c (display_uses_solib_p): Use it.
	* solib.h (solib_contains_address_p): Declare it.
@
text
@d687 2
a688 1
/* Return non-zero if SO is the libpthread shared library.
d694 8
d705 1
a705 1
  return (strstr (so->so_name, "/libpthread") != NULL);
@


1.114
log
@       * solib.c (reload_shared_libraries): Give
       inferior a chance to reset solib breakpoint.
       Reinit frame cache.
@
text
@d837 15
d880 2
a881 9
    {
      struct section_table *p;

      for (p = so->sections; p < so->sections_end; p++)
	{
	  if (p->addr <= address && address < p->endaddr)
	    return (so->so_name);
	}
    }
@


1.113
log
@2009-03-06  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	Rename solib_address to solib_name_from_address.
	* breakpoint.c (insert_bp_location, disable_breakpoints_in_shlibs)
	(disable_breakpoints_in_unloaded_shlib): Update.
	* printcmd.c (display_uses_solib_p): Likewise.
	* stack.c (print_frame): Likewise.
	* solib.c: Rename.
	* solib.h: Rename.
@
text
@d1018 22
@


1.112
log
@2009-03-05  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* printcmd.c (do_one_display): Reparse exp_string.
	(display_uses_solib_p): New function.
	(clear_dangling_display_expressions): New function.
	(_initialize_printcmd): Add observer.
	* solib.c (no_shared_libraries): Swap order of calls to
	clear_solib and objfile_purge_solibs.
@
text
@d841 2
a842 1
   solib_address -- check to see if an address is in a shared lib
d846 1
a846 1
   char * solib_address (CORE_ADDR address)
d860 1
a860 1
solib_address (CORE_ADDR address)
@


1.111
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d1002 6
a1008 1
  clear_solib ();
@


1.110
log
@	* mi/mi-interp.c (mi_solib_loaded, mi_solib_unloaded): New.
	(mi_interpreter_init): Register the above.
	* solib.c (clear_solib): Notify solib unload.
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib): Do not
	disable breakpoints on a.out targets.
@
text
@d48 1
@


1.109
log
@	* solist.h (struct target_so_ops): New member bfd_open.
	(solib_find): Add prototype.
	(solib_bfd_fopen): Add prototype.
	* solib.c (solib_find, solib_bfd_fopen): New functions, extracted
	from solib_bfd_open.
	(solib_bfd_open): Use ops->bfd_open override if present.  Call
	solib_find and solib_bfd_open otherwise.

	* objfiles.h (OBJF_KEEPBFD): New define.
	* objfiles.c (free_objfile): Do not close BFD if OBJF_KEEPBFD
	objfile flag is set.
	* solib.c (symbol_add_stub): Do not allocate second BFD for
	shared library; use OBJF_KEEPBFD flag on solib objfile.
@
text
@d911 1
@


1.108
log
@        Updated copyright notices for most files.
@
text
@d110 1
a110 1
   solib_bfd_open -- Find a shared library file and open BFD for it.
d114 1
a114 1
   struct bfd *solib_open (char *in_pathname);
d141 3
a143 1
   BFD file handle for opened solib; throws error on failure.  */
d145 2
a146 2
bfd *
solib_bfd_open (char *in_pathname)
a150 1
  char *p = in_pathname;
a151 1
  bfd *abfd;
d176 2
a177 18
      temp_pathname = xstrdup (temp_pathname);
      abfd = remote_bfd_open (temp_pathname, gnutarget);
      if (!abfd)
	{
	  make_cleanup (xfree, temp_pathname);
	  error (_("Could not open `%s' as an executable file: %s"),
		 temp_pathname, bfd_errmsg (bfd_get_error ()));
	}

      if (!bfd_check_format (abfd, bfd_object))
	{
	  bfd_close (abfd);
	  make_cleanup (xfree, temp_pathname);
	  error (_("`%s': not in executable format: %s"),
		 temp_pathname, bfd_errmsg (bfd_get_error ()));
	}

      return abfd;
d240 31
a270 3
  /* Done.  If still not found, error.  */
  if (found_file < 0)
    perror_with_name (in_pathname);
a271 2
  /* Leave temp_pathname allocated.  abfd->name will point to it.  */
  abfd = bfd_fopen (temp_pathname, gnutarget, FOPEN_RB, found_file);
d274 1
a274 2
      close (found_file);
      make_cleanup (xfree, temp_pathname);
d276 1
a276 1
	     temp_pathname, bfd_errmsg (bfd_get_error ()));
d279 26
d308 1
a308 1
      make_cleanup (xfree, temp_pathname);
d310 1
a310 1
	     temp_pathname, bfd_errmsg (bfd_get_error ()));
a312 1
  bfd_set_cacheable (abfd, 1);
d469 2
a470 2
  so->objfile = symbol_file_add (so->so_name, so->from_tty,
				 sap, 0, OBJF_SHARED);
@


1.107
log
@	* remote.c (remote_start_remote): If the solib list is global,
	fetch libraries and insert breakpoints after connecting.
	* infcmd.c (post_create_inferior): If the solist is shared between
	inferiors, no need to refetch it on every new inferior.
	(detach_command): If the shared library list is shared between
	inferiors, then don't clear it on every inferior detach.
	* gdbarch.sh (has_global_solist): New.
	* i386-dicos-tdep.c (i386_dicos_init_abi): Set
	gdbarch_has_global_solist.
	* target.c (target_pre_inferior): If the shared library list is
	shared between inferiors, then don't clear it here, neither
	invalidate the memory regions or clear the target description.
	(target_detach): If the shared library list is shared between
	inferiors, then don't remove breakpoints from the target here.
	(target_disconnect): Comment.
	* solib.c (update_solib_list): Check for null_ptid.
	* breakpoint.c (insert_breakpoints, update_global_location_list):
	If the shared library list is shared between inferiors, insert
	breakpoints even if there's no execution.
	(breakpoint_init_inferior): If the shared library list is shared
	between inferiors, don't delete breakpoints or mark them
	uninserted here.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008
@


1.107.2.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@d869 2
a870 2
  if (first_exec != NULL
      && bfd_get_flavour (first_exec->ebfd) != bfd_target_aout_flavour)
@


1.106
log
@	Remove the attach_flag global, and make it per-inferior.

	* inferior.h (attach_flag): Delete.
	(inferior_process): Declare.
	* solib.c (update_solib_list): Adjust.
	* gnu-nat.c (gnu_create_inferior, gnu_attach): Adjust.
	* inf-ptrace.c (inf_ptrace_detach): Adjust.
	(inf_ptrace_files_info): Get it from the current inferior.
	* inf-ttrace.c (inf_ttrace_attach): Adjust.
	(inf_ttrace_files_info): Get it from the current
	inferior.
	* inflow.c (terminal_inferior, terminal_ours_1, set_sigint_trap)
	(clear_sigint_trap): Get it from the current process.
	* remote.c (extended_remote_attach_1)
	(extended_remote_create_inferior_1): Adjust.
	* top.c (quit_confirm, quit_target): Get it from the current inferior.
	* procfs.c (do_detach): Adjust.
	(procfs_wait): Get it from the event inferior.
	(procfs_files_info): Get it from the current inferior.
	* nto-procfs.c (procfs_files_info): Likewise.
	(procfs_attach): Adjust.  Set the attach_flag here.
	(do_attach): Don't set it here.
	(procfs_detach): Don't clear it.
	(procfs_mourn_inferior): Don't clear it.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* target.c (attach_flag): Delete.
	(generic_mourn_inferior): Don't clear it.
	* win32-nat.c (get_win32_debug_event): Get it from the event
	process.
	(do_initial_win32_stuff): Add attaching argument.  Set attach_flag
	in the inferior accordingly.
	(win32_attach): Don't set the attach_flag here.  Pass 1 to
	do_intial_win32_stuff.
	(win32_files_info): Get it from the current inferior.
	(win32_create_inferior): Dont clear attach_flag here.  Pass 0 to
	do_intial_win32_stuff.
@
text
@d513 1
a513 1
  if (target_has_execution)
@


1.105
log
@ChangeLog:

	* remote.h (remote_filename_p, remote_bfd_open): Add prototypes.
	* remote.c (remote_bfd_iovec_open, remote_bfd_iovec_close,
	remote_bfd_iovec_pread, remote_bfd_iovec_stat, remote_filename_p,
	remote_bfd_open): New functions.
	(remote_hostio_send_command): Fail safely if remote connection
	is not set up.

	* solist.h (solib_open): Remove prototype.
	(solib_bfd_open): Add prototype.
	* solib.c: Include "remote.h".
	(solib_open): Remove, replace by ...
	(solib_bfd_open): ... this new function.  Handle remote BFDs.
	(solib_map_sections): Replace solib_open by solib_bfd_open.
	* solib-frv.c: Include "exceptions.h".
	(enable_break2): Replace solib_open by solib_bfd_open.
	* solib-svr4.c: Include "exceptions.h".
	(enable_break): Replace solib_open by solib_bfd_open.

	* symfile.c: Include "remote.h".
	(build_id_verify): Handle remote BFDs.
	(separate_debug_file_exists): Use BFD to access file.  Handle
	remote BFDs.
	(symfile_bfd_open): Handle remote BFDs.
	(reread_symbols): Handle remote BFDs.

	* NEWS: Mention "remote:" argument prefix to "set sysroot".

doc/ChangeLog:

	* gdb.texinfo (Commands to Specify Files): Document "remote:"
	argument prefix to "set sysroot".
@
text
@d511 14
a524 8
  /* If we are attaching to a running process for which we 
     have not opened a symbol file, we may be able to get its 
     symbols now!  */
  if (attach_flag &&
      symfile_objfile == NULL)
    catch_errors (ops->open_symbol_file_object, &from_tty, 
		  "Error reading attached process's symbol file.\n",
		  RETURN_MASK_ALL);
@


1.104
log
@	* gdbarch.sh (target_gdbarch): New global variable.
	(deprecated_current_gdbarch_select_hack): Set it.
	* gdbarch.c, gdbarch.h: Regenerate.

	* arch-utils.c (gdbarch_update_p): Use target_gdbarch instead
	of current_gdbarch.
	* target-descriptions.c (target_find_description): Likewise.
	* arm-tdep.c (arm_update_current_architecture): Likewise.
	(show_fp_model, arm_show_abi, arm_show_fallback_mode,
	arm_show_force_mode): Likewise.
	* mips-tdep.c (show_mask_address, show_mipsfpu_command,
	show_mips_abi): Likewise.
	* mep-tdep.c (me_module_register_set, current_me_module): Likewise.

	* target.c (target_translate_tls_address): Use target_gdbarch
	instead of current_gdbarch.
	* remote.c (struct packet_reg): Likewise.
	(get_remote_arch_state, packet_reg_from_regnum,
	packet_reg_from_pnum, remote_check_symbols, remote_wait,
	remote_address_masked, remote_insert_breakpoint,
	remote_insert_hw_breakpoint, remote_read_description): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* remote-mips.c (mips_open, mips_common_breakpoint): Likewise.
	* cris-tdep.c (cris_can_use_hardware_watchpoint): Likewise.

	* solib.c (solib_open, solib_map_sections, solib_read_symbols,
	solib_add, info_sharedlibrary_command, solib_address,
	solib_create_inferior_hook, in_solib_dynsym_resolve_code,
	solib_global_lookup): Likewise.
	* solib-frv.c (enable_break2, frv_relocate_main_executable): Likewise.
	* solib-irix.c (irix_current_sos, irix_open_symbol_file_object):
	Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (exec_entry_point, enable_break, svr4_free_so,
	set_solib_svr4_fetch_link_map_offsets, svr4_fetch_link_map_offsets):
	Likewise.
	* nto-tdep.c (nto_find_and_open_solib, nto_init_solib_absolute_prefix,
	nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_in_dynsym_stub): Likewise.
@
text
@d47 1
d110 1
a110 1
   solib_open -- Find a shared library file and open it.
d114 1
a114 1
   int solib_open (char *in_patname, char **found_pathname);
d141 1
a141 1
   file handle for opened solib, or -1 for failure.  */
d143 2
a144 2
int
solib_open (char *in_pathname, char **found_pathname)
d151 1
d173 23
d256 15
a270 3
  /* Done.  If not found, tough luck.  Return found_file and 
     (optionally) found_pathname.  */
  if (temp_pathname)
d272 4
a275 4
      if (found_pathname != NULL)
	*found_pathname = temp_pathname;
      else
	xfree (temp_pathname);
d277 3
a279 1
  return found_file;
a314 2
  char *scratch_pathname;
  int scratch_chan;
a319 1

d321 2
a322 15
  scratch_chan = solib_open (filename, &scratch_pathname);

  if (scratch_chan < 0)
    {
      perror_with_name (filename);
    }

  /* Leave scratch_pathname allocated.  abfd->name will point to it.  */
  abfd = bfd_fopen (scratch_pathname, gnutarget, FOPEN_RB, scratch_chan);
  if (!abfd)
    {
      close (scratch_chan);
      error (_("Could not open `%s' as an executable file: %s"),
	     scratch_pathname, bfd_errmsg (bfd_get_error ()));
    }
a325 1
  bfd_set_cacheable (abfd, 1);
d329 3
a331 3
  if (strlen (scratch_pathname) >= SO_NAME_MAX_PATH_SIZE)
    error (_("Full path name length of shared library exceeds SO_NAME_MAX_PATH_SIZE in so_list structure."));
  strcpy (so->so_name, scratch_pathname);
a332 5
  if (!bfd_check_format (abfd, bfd_object))
    {
      error (_("\"%s\": not in executable format: %s."),
	     scratch_pathname, bfd_errmsg (bfd_get_error ()));
    }
a358 3
  /* Free the file names, close the file now.  */
  do_cleanups (old_chain);

@


1.103
log
@	Add "set print symbol-loading on|off".
	* NEWS: Document new option.
	* symfile.h (print_symbol_loading): Declare.
	* symfile.c (print_symbol_loading): New global.
	(symbol_file_add_with_addrs_or_offsets): Only print "Reading symbols
	from ..." if print_symbol_loading.
	(_initialize_symfile): Add set/show print symbol-loading.
	* solib.c (solib_read_symbols): Only print "Loaded symbols for ..."
	if print_symbol_loading.

	* doc/gdb.texinfo: Document "set print symbol-loading on|off".
@
text
@d145 1
a145 1
  struct target_so_ops *ops = solib_ops (current_gdbarch);
d324 1
a324 1
      struct target_so_ops *ops = solib_ops (current_gdbarch);
d372 1
a372 1
  struct target_so_ops *ops = solib_ops (current_gdbarch);
d493 1
a493 1
  struct target_so_ops *ops = solib_ops (current_gdbarch);
d708 1
a708 1
	struct target_so_ops *ops = solib_ops (current_gdbarch);
d744 1
a744 1
  addr_width = 4 + (gdbarch_ptr_bit (current_gdbarch) / 4);
d827 1
a827 1
  struct target_so_ops *ops = solib_ops (current_gdbarch);
d883 1
a883 1
  struct target_so_ops *ops = solib_ops (current_gdbarch);
d906 1
a906 1
  struct target_so_ops *ops = solib_ops (current_gdbarch);
d976 1
a976 1
  struct target_so_ops *ops = solib_ops (current_gdbarch);
@


1.102
log
@	* language.h (struct language_defn): Remove SYMTAB parameter from
	la_lookup_symbol_nonlocal callback function pointer.

	* ada-lang.h (ada_lookup_encoded_symbol): Remove SYMTAB parameter.
	(ada_lookup_encoded_symbol): Likewise.
	* ada-lang.c (ada_lookup_encoded_symbol): Remove SYMTAB parameter.
	Always call fixup_symbol_section.
	(ada_lookup_symbol): Remove SYMTAB parameter.
	(ada_lookup_symbol_nonlocal): Likewise.
	* ada-exp.y (write_object_renaming): Update.
	(find_primitive_type): Likewise.

	* cp-support.h (cp_lookup_symbol_nonlocal): Remove SYMTAB parameter.
	(cp_lookup_symbol_namespace): Likewise.
	* cp-namespace.c (lookup_namespace_scope): Remove SYMTAB parameter.
	(lookup_symbol_file): Likewise.
	(lookup_possible_namespace_symbol): Likewise.
	(cp_lookup_symbol_nonlocal): Likewise.
	(cp_lookup_symbol_namespace): Likewise.
	(cp_lookup_nested_type): Update.

	* scm-valprint.c (scm_inferior_print): Update.
	* valops.c (value_maybe_namespace_elt): Update.

	* solist.h (struct target_so_ops): Remove SYMTAB parameter from
	lookup_lib_global_symbol callback function pointer.
	(solib_global_lookup): Remove SYMTAB parameter.
	* solib.c (solib_global_lookup): Remove SYMTAB parameter.
	* solib-svr4.c (elf_lookup_lib_symbol): Likewise.

	* symtab.h (basic_lookup_symbol_nonlocal): Remove SYMTAB parameter.
	(lookup_symbol_static): Likewise.
	(lookup_symbol_global): Likewise.
	(lookup_symbol_aux_block): Likewise.
	(lookup_global_symbol_from_objfile): Likewise.
	* symtab.c (lookup_symbol_aux): Remove SYMTAB parameter.
	(lookup_symbol_aux_local): Likewise.
	(lookup_symbol_aux_block): Likewise.
	(lookup_symbol_aux_symtabs): Likewise.
	(lookup_symbol_aux_psymtabs): Likewise.
	(lookup_global_symbol_from_objfile): Likewise.
	(basic_lookup_symbol_nonlocal): Likewise.
	(lookup_symbol_static): Likewise.
	(lookup_symbol_global): Likewise.

	(lookup_symbol_in_language): Do not pass SYMTAB to lookup_symbol_aux.
@
text
@d451 1
a451 1
	  if (from_tty)
@


1.101
log
@	Ignore change in name of dynamic linker during
	execution, on Solaris.  This also unbreaks pending breakpoints.

	* solist.h (struct target_so_ops): New field same.
        * solib-svr4.c (svr4_same): New.
        (_initialize_svr4_solib): Register svr4_same.
        * solib.c (update_solib_list): Use ops->same, if available.
@
text
@d974 1
a974 2
		     const domain_enum domain,
		     struct symtab **symtab)
d979 1
a979 2
    return ops->lookup_lib_global_symbol (objfile, name, linkage_name,
					  domain, symtab);
@


1.100
log
@	Updated copyright notices for most files.
@
text
@d541 10
a550 2
	  if (! strcmp (gdb->so_original_name, i->so_original_name))
	    break;
@


1.99
log
@	Remove 'run_cleanup'.
	* defs.h (do_run_cleanups, make_run_cleanup): Remove
	declarations.
	* infcmd.c (run_command_1): Call clear_solib instead
	of do_run_cleanups.
	* jv-lang.c (java_rerun_cleanup): Remove, for lack of
	any use.
	* solib.c (solib_cleanup_queued, do_clear_solib): Remove.
	(update_solib_lib): Don't setup run cleanup.
	(no_shared_libraries): Call clear_solib, not do_clear_solib.
	* utils.c (run_cleanup_chain, make_run_cleanup)
	(do_run_cleanups): Remove.
@
text
@d4 2
a5 1
   2000, 2001, 2002, 2003, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.98
log
@	* solib.c (solib_global_lookup): Use solib_ops instead of global
	current_target_so_ops.
@
text
@a88 2
static int solib_cleanup_queued = 0;	/* make_run_cleanup called */

a90 2
static void do_clear_solib (void *);

a504 9
  /* Since this function might actually add some elements to the
     so_list_head list, arrange for it to be cleaned up when
     appropriate.  */
  if (!solib_cleanup_queued)
    {
      make_run_cleanup (do_clear_solib, NULL);
      solib_cleanup_queued = 1;
    }

a855 7
static void
do_clear_solib (void *dummy)
{
  solib_cleanup_queued = 0;
  clear_solib ();
}

d938 1
a938 1
  do_clear_solib (NULL);
@


1.97
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d988 1
a988 3
  if (current_target_so_ops->lookup_lib_global_symbol != NULL)
    return current_target_so_ops->lookup_lib_global_symbol (objfile,
				name, linkage_name, domain, symtab);
d990 3
@


1.96
log
@	gdb/
	* breakpoint.c (disable_breakpoints_in_shlibs): Remove
	the 'silent' parameter and code to implement that.
	* breakpoint.h (disable_breakpoints_in_shlibs): Adjust
	prototype.
	* win32-nat.c: Adjust.
	* solib.c: Adjust.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.95
log
@2007-08-09  Michael Snyder  <msnyder@@access-company.com>

	* solib.c (solib_open): Memory leak -- openp returns xmalloc buffer.
@
text
@d857 1
a857 1
    disable_breakpoints_in_shlibs (1);
@


1.94
log
@2007-07-03  Markus Deuling  <deuling@@de.ibm.com>

	* cp-namespace.c (lookup_symbol_file): Add block to
	lookup_symbol_global call.
	* Makefile.in (solist_h): Add dependency on symtab header.
	(symtab.o): Add dependency on solist header.
	* solib.c (solib_global_lookup): New function.
	* solib-svr4.c (scan_dyntag): Likewise.
	(elf_locate_base): Call helper routine scan_dyntag.
	(elf_lookup_lib_symbol): New function.
	(_initialize_svr4_solib): Add elf_lookup_lib_symbol to svr4_so_ops.
	* solist.h (symtab.h): New include.
	(struct target_so_ops): New member lookup_lib_global_symbol.
	(solib_global_lookup): New prototype.
	* symtab.c: New include solist.h.
	(lookup_objfile_from_block): New function.
	(lookup_global_symbol_from_objfile): New function.
	(basic_lookup_symbol_nonlocal): Add block to lookup_symbol_global call.
	(lookup_symbol_global): Call library-specific lookup procedure.
	* symtab.h (lookup_global_symbol_from_objfile): New prototype.

	* NEWS: Document framework.

testsuite/

	* gdb.base/solib-symbol.exp: New file (testcase multiple symbol lookup).
	* gdb.base/solib-symbol-lib.c: Likewise.
	* gdb.base/solib-symbol-main.c: Likewise.
@
text
@d179 11
d238 7
a244 2
  if (found_pathname != NULL && temp_pathname != NULL)
    *found_pathname = xstrdup (temp_pathname);
@


1.93
log
@	* Makefile.in (XMLFILES): Add library-list.dtd.
	(ALLDEPFILES): Add solib-target.o.
	(solib-target.o): New rule.
	* remote.c (PACKET_qXfer_libraries): New constant.
	(remote_protocol_features): Add qXfer:libraries:read.
	(remote_wait): Recognize library stop replies.
	(remote_async_wait): Likewise.  Fix typo.
	(remote_xfer_partial): Handle TARGET_OBJECT_LIBRARIES.
	(init_remote_async_ops): Fix typo.
	(_initialize_remote): Register "set remote library-info-packet".
	* solib-som.c (som_current_sos): Set addr_low and addr_high.
	* solib-target.c: New file.
	* solib.c (solib_map_sections): Use addr_low and addr_high instead
	of textsection.
	(info_sharedlibrary_command): Likewise.
	(solib_add_library, solib_remove_library): New.
	* solist.h (struct so_list): Replace textsection with addr_low and
	addr_high.
	* target.h (enum target_object): Add TARGET_OBJECT_LIBRARIES.
	* NEWS: Describe new qXfer:libraries:read and shared library
	event support.
	* features/library-list.dtd: New.

	* gdb.texinfo (Remote Configuration): Document library-info-packet.
	Add other missing entries.  Adjust the table size to fit.
	(Stop Reply Packets): Use @@itemize instead of @@enumerate.  Document
	stop reasons including the new "library" event.
	(General Query Packets): Adjust table widths for qSupported.  Mention
	qXfer:libraries:read reply to qSupported and document the new packet.
	(Library List Format): New section.
@
text
@d964 18
@


1.92
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_PTR_BIT): Replace with gdbarch_ptr_bit.
	* solib-svr4.c (svr4_truncate_ptr): Likewise.
	* solib-pa64.c (read_dynamic_info): Likewise.
	* solib-legacy.c (legacy_svr4_fetch_link_map_offsets): Likewise.
	* solib.c (info_sharedlibrary_command): Likewise.
	* s390-nat.c (SUBOFF): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	* procfs.c (info_proc_mappings): Likewise.
	* printcmd.c (decode_format): Likewise.
	* nto-tdep.c (nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips64_linux_get_longjmp_target): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* jv-valprint.c (java_value_print): Likewise.
	* jv-lang.c (get_java_object_header_size): Likewise.
	* hppa-tdep.c (skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code)
	(hppa_hpux_unwind_adjust_stub): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
	* gdbtypes.c (make_pointer_type, make_reference_type)
	(smash_to_memberptr_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d319 6
a324 1
      if (strcmp (p->the_bfd_section->name, ".text") == 0)
d326 2
a327 1
	  so->textsection = p;
d751 1
a751 1
			     so->textsection != NULL 
d753 1
a753 1
			           (LONGEST) so->textsection->addr,
d757 1
a757 1
			     so->textsection != NULL 
d759 1
a759 1
			           (LONGEST) so->textsection->endaddr,
@


1.91
log
@	* config/mips/linux.mt (DEPRECATED_TM_FILE): Delete.
	* config/mips/tm-linux.h: Delete.
	* mips-linux-tdep.c (mips_svr4_so_ops): New.
	(mips_linux_in_dynsym_resolve_code): Make static.  Use
	svr4_in_dynsym_resolve_code.
	(mips_linux_init_abi): Initialize mips_svr4_so_ops.  Call
	set_solib_ops.
	* solib-svr4.c (svr4_in_dynsym_resolve_code, svr4_so_ops): Make
	global.
	* solib-svr4.h (svr4_so_ops, svr4_in_dynsym_resolve_code): Declare.
	* Makefile.in (mips-linux-tdep.o): Update.
	* solib.c (set_solib_ops): New.
	(current_target_so_ops): Update comment.
	* solib.h (set_solib_ops): New prototype.
@
text
@d728 1
a728 1
  addr_width = 4 + (TARGET_PTR_BIT / 4);
@


1.90
log
@Copyright updates for 2007.
@
text
@d70 9
d83 2
a84 1
/* FIXME: gdbarch needs to control this variable */
@


1.89
log
@	* NEWS: Add "set sysroot" and "show sysroot".
	* solib.c (solib_absolute_prefix): Delete.  Replace
	all uses with gdb_sysroot.
	(_initialize_solib): Add "set sysroot" and "show sysroot".
	Make "solib-absolute-prefix" an alias to it.

	* gdb.texinfo (Commands to specify files): Describe
	"set sysroot" and "show sysroot".
	(Using the `gdbserver' program): Lowercase argument
	to @@var.  Expand description of setting up GDB on the
	host.
@
text
@d3 2
a4 3
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2005, 2006
   Free Software Foundation, Inc.
@


1.88
log
@2006-11-29  Andrew Stubbs  <andrew.stubbs@@st.com>

	* solib.c (solib_open): Treat bare file names as relative paths.
@
text
@a87 4
/* If non-zero, this is a prefix that will be added to the front of the name
   shared libraries with an absolute filename for loading.  */
static char *solib_absolute_prefix = NULL;

d113 1
a113 1
   Global variable SOLIB_ABSOLUTE_PREFIX is used as a prefix directory
d118 1
a118 1
   shared libraries if not found in SOLIB_ABSOLUTE_PREFIX.
d121 2
a122 2
   * If there is a solib_absolute_prefix and path is absolute:
   *   Search for solib_absolute_prefix/path.
d127 1
a127 1
   * If solib_absolute_prefix is NOT set, perform the following two searches:
d132 1
a132 1
   * machines since solib_absolute_prefix will almost always be set.
d145 1
a145 1
  int solib_absolute_prefix_is_empty;
d147 1
a147 2
  solib_absolute_prefix_is_empty = (solib_absolute_prefix == NULL
                                    || *solib_absolute_prefix == 0);
d149 1
a149 1
  if (! IS_ABSOLUTE_PATH (in_pathname) || solib_absolute_prefix_is_empty)
d153 1
a153 1
      int prefix_len = strlen (solib_absolute_prefix);
d157 1
a157 1
	     && IS_DIR_SEPARATOR (solib_absolute_prefix[prefix_len - 1]))
d162 1
a162 1
      strncpy (temp_pathname, solib_absolute_prefix, prefix_len);
d170 1
a170 1
  /* If the search in solib_absolute_prefix failed, and the path name is
d204 1
a204 1
  if (found_file < 0 && solib_absolute_prefix_is_empty)
d211 1
a211 1
  if (found_file < 0 && solib_absolute_prefix_is_empty)
d977 7
a983 5
  add_setshow_filename_cmd ("solib-absolute-prefix", class_support,
			    &solib_absolute_prefix, _("\
Set prefix for loading absolute shared library symbol files."), _("\
Show prefix for loading absolute shared library symbol files."), _("\
For other (relative) files, you can add values using `set solib-search-path'."),
d988 4
a991 3
  /* Set the default value of "solib-absolute-prefix" from the sysroot, if
     one is set.  */
  solib_absolute_prefix = xstrdup (gdb_sysroot);
@


1.87
log
@        * solib.c (libpthread_solib_p): New function.
        (solib_add): Always read the symbols from the libpthread library.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003, 2005
d154 3
a156 4
  while (*p && !IS_DIR_SEPARATOR (*p))
    p++;

  if (*p)
d158 1
a158 5
      if (! IS_ABSOLUTE_PATH (in_pathname) || solib_absolute_prefix_is_empty)
        temp_pathname = in_pathname;
      else
	{
	  int prefix_len = strlen (solib_absolute_prefix);
d160 11
a170 11
	  /* Remove trailing slashes from absolute prefix.  */
	  while (prefix_len > 0
		 && IS_DIR_SEPARATOR (solib_absolute_prefix[prefix_len - 1]))
	    prefix_len--;

	  /* Cat the prefixed pathname together.  */
	  temp_pathname = alloca (prefix_len + strlen (in_pathname) + 1);
	  strncpy (temp_pathname, solib_absolute_prefix, prefix_len);
	  temp_pathname[prefix_len] = '\0';
	  strcat (temp_pathname, in_pathname);
	}
d172 2
a173 3
      /* Now see if we can open it.  */
      found_file = open (temp_pathname, O_RDONLY | O_BINARY, 0);
    }
@


1.86
log
@	* solib.c (solib_open): Handle an empty solib_absolute_prefix like a
	missing one.
@
text
@d618 11
d675 8
d684 1
a684 1
	  if (readsyms && solib_read_symbols (gdb, from_tty))
@


1.85
log
@	* solib.c (solib_read_symbols): Stop if the file was not found.
@
text
@d149 4
d159 1
a159 1
      if (! IS_ABSOLUTE_PATH (in_pathname) || solib_absolute_prefix == NULL)
d215 1
a215 1
  if (found_file < 0 && solib_absolute_prefix == NULL)
d222 1
a222 1
  if (found_file < 0 && solib_absolute_prefix == NULL)
@


1.84
log
@	* gdb/defs.h: unconditionally include <fcntl.h>, and
	ensure that O_BINARY is defined.
	* gdb/solib.c(solib_open): ensure solib files are opened in
	binary mode.
	* gdb/corelow.c: Remove O_BINARY macro definition.
	* gdb/exec.c: Remove O_BINARY macro definition
	* gdb/remote-rdp.c: Remove O_BINARY macro definition
	* gdb/source.c: Remove O_BINARY macro definition
	* gdb/symfile.c: Remove O_BINARY macro definition
@
text
@d421 5
@


1.84.8.1
log
@Add experimental support for SymbianOS-related protocol features.
@
text
@a87 5
/* If non-empty, this is a file extension that will be opened in place
   of the file extension reported by the shared library list.  */

char *solib_symbols_extension;

d148 1
a148 24
  char *p;

  /* If solib-symbols-extension is set, replace the file's extension.  */
  if (solib_symbols_extension && *solib_symbols_extension)
    {
      p = in_pathname + strlen (in_pathname);
      while (p > in_pathname && *p != '.')
	p--;

      if (*p == '.')
	{
	  char *new_pathname;

	  new_pathname = alloca (p - in_pathname + 1
				 + strlen (solib_symbols_extension) + 1);
	  memcpy (new_pathname, in_pathname, p - in_pathname + 1);
	  strcpy (new_pathname + (p - in_pathname) + 1,
		  solib_symbols_extension);

	  in_pathname = new_pathname;
	}
    }

  p = in_pathname;
d317 1
a317 5

      /* If the target didn't provide information about the address range
	 of the DLL, assume we want the location of the .text section.  */
      if (so->addr_low == 0 && so->addr_high == 0
	  && strcmp (p->the_bfd_section->name, ".text") == 0)
d319 1
a319 2
	  so->addr_low = p->addr;
	  so->addr_high = p->endaddr;
d719 1
a719 1
			     so->addr_high != 0
d721 1
a721 1
			           (LONGEST) so->addr_low,
d725 1
a725 1
			     so->addr_high != 0
d727 1
a727 1
			           (LONGEST) so->addr_high,
@


1.84.8.2
log
@	* gdb/bsd-uthread.c (bsd_uthread_solib_loaded): Always pass 0 for
	from_tty.
	* gdb/remote.c (remote_get_shared_libraries): Don't call solib_add.
	* gdb/solib.c: Include "exceptions.h".
	(solib_map_sections): Throw NOT_FOUND_ERROR if appropriate.
	(symbol_add_stub): Delete.
	(solib_read_symbols): Use TRY_CATCH.  Inline symbol_add_stub.
	Use current from_tty, not a copy from the so_list.  Don't warn
	a second time for a missing library.
	(update_solib_list): Don't save from_tty.  Use TRY_CATCH.  Print
	out a single warning for all missing libraries.
	* gdb/solist.h (struct so_list): Remove from_tty.
	* gdb/Makefile.in (solib.o): Update.
@
text
@a47 1
#include "exceptions.h"
a303 5
      /* Throw a more specific error if the file could not be found, so
	 that we can accumulate messages about missing libraries.  */
      if (errno == ENOENT)
	throw_error (NOT_FOUND_ERROR, "%s", safe_strerror (errno));

d417 25
d456 3
a458 38
      volatile struct gdb_exception e;

      TRY_CATCH (e, RETURN_MASK_ERROR)
	{
	  struct section_addr_info *sap;

	  /* Could we find a file for this shared library?  If we
	     couldn't, don't try to open it again.  */
	  if (so->abfd == NULL)
	    throw_error (NOT_FOUND_ERROR, "%s", safe_strerror (errno));

	  /* Have we already loaded this shared object?  */
	  ALL_OBJFILES (so->objfile)
	    {
	      if (strcmp (so->objfile->name, so->so_name) == 0)
		break;
	    }
	  if (so->objfile != NULL)
	    break;

	  sap = build_section_addr_info_from_section_table (so->sections,
							    so->sections_end);
	  so->objfile = symbol_file_add (so->so_name, from_tty,
					 sap, 0, OBJF_SHARED);
	  free_section_addr_info (sap);
	}

      if (e.reason == RETURN_ERROR && e.error == NOT_FOUND_ERROR)
	/* We've already warned about this library, when trying to
	   open it.  */
	return 0;
      else if (e.reason < 0)
	{
	  if (from_tty)
	    exception_fprintf
	      (gdb_stderr, e, _("Error while reading shared library symbols:\n"));
	}
      else
a603 3
      int not_found = 0;
      const char *not_found_filename = NULL;

d612 1
a612 1
	  volatile struct gdb_exception e;
d614 4
a617 17
	  TRY_CATCH (e, RETURN_MASK_ERROR)
	    {
	      /* Fill in the rest of the `struct so_list' node.  */
	      solib_map_sections (i);
	    }

	  if (e.reason == RETURN_ERROR && e.error == NOT_FOUND_ERROR)
	    {
	      not_found++;
	      if (not_found_filename == NULL)
		not_found_filename = i->so_original_name;
	    }
	  else if (e.reason < 0)
	    {
	      exception_fprintf (gdb_stderr, e,
				 _("Error while mapping shared library sections:\n"));
	    }
a638 18

      /* If a library was not found, issue an appropriate warning
	 message.  We have to use a single call to warning () in case
	 the front end does something special with warnings, e.g.  pop
	 up a dialog box.  It Would Be Nice if we could get a
	 "warning: " prefix on each line in the CLI front end,
	 though - it doesn't stand out well.  */

      if (not_found == 1)
	warning (_("\
Could not load shared library symbols for %s.\n\
Do you need \"set solib-search-path\" or \"set solib-absolute-prefix\"?"),
		 not_found_filename);
      else if (not_found > 1)
	warning (_("\
Could not load shared library symbols for %d libraries, e.g. %s.\n\
Do you need \"set solib-search-path\" or \"set solib-absolute-prefix\"?"),
		 not_found, not_found_filename);
@


1.84.8.3
log
@        gdb/
        * symfile.c (symfile_section_offset_from_segment): Correct
        last change.

        * solib.c (solib_open): Always set errno.
@
text
@a155 6
  /* By default, return ENOENT.  We must set this explicitly because
     we don't know whether any of the various calls to open or openp
     below will actually be made; if none of them are, return this
     instead of whatever errno was on entry.  */
  errno = ENOENT;

@


1.83
log
@	* solib.c (info_sharedlibrary_command): Avoid internal_error.
@
text
@d174 1
a174 1
      found_file = open (temp_pathname, O_RDONLY, 0);
d195 1
a195 1
			in_pathname, O_RDONLY, 0, &temp_pathname);
d202 1
a202 1
                        lbasename (in_pathname), O_RDONLY, 0,
d207 1
a207 1
    found_file = ops->find_and_open_solib (in_pathname, O_RDONLY,
d213 1
a213 1
			OPF_TRY_CWD_FIRST, in_pathname, O_RDONLY, 0,
d220 1
a220 1
			OPF_TRY_CWD_FIRST, in_pathname, O_RDONLY, 0,
@


1.82
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d701 2
a702 10
  if (TARGET_PTR_BIT == 32)
    addr_width = 8 + 4;
  else if (TARGET_PTR_BIT == 64)
    addr_width = 16 + 4;
  else
    {
      internal_error (__FILE__, __LINE__,
		      _("TARGET_PTR_BIT returned unknown size %d"),
		      TARGET_PTR_BIT);
    }
@


1.81
log
@	* corelow.c (core_open): Use bfd_fopen, not bfd_fdopenr.
	* exec.c (exec_file_attach): Likewise.
	* solib-frv.c (enable_break2): Likewise.
	* solib-svr4.c (enable_break): Likewise.
	* solib.c (solib_map_sections): Likewise.
	* symfile.c (symfile_bfd_open): Likewise.
@
text
@d3 1
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.80
log
@* solist.h (TARGET_SO_FREE_SO, TARGET_SO_CLEAR_SOLIB)
(TARGET_SO_SOLIB_CREATE_INFERIOR_HOOK)
(TARGET_SO_SPECIAL_SYMBOL_HANDLING, TARGET_SO_CURRENT_SOS)
(TARGET_SO_OPEN_SYMBOL_FILE_OBJECT): Remove defines.
* solib.c (solib_data): New variable.
(solib_init, solib_ops): New functions.
(solib_open, solib_map_sections, free_so, update_solib_list)
(solib_add, clear_solib, solib_create_inferior_hook)
(in_solib_dynsym_resolve_code): Call architecture-dependent code
using solib_ops.
(_initialize_solib): Register SOLIB_DATA.
@
text
@d280 1
a280 1
  abfd = bfd_fdopenr (scratch_pathname, gnutarget, scratch_chan);
@


1.79
log
@2005-02-24  Andrew Cagney  <cagney@@gnu.org>

	Add show_VARIABLE functions, update add_setshow call.
	* varobj.c (_initialize_varobj, show_varobjdebug): Add and update.
	* valprint.c (_initialize_valprint, show_print_max)
	(show_stop_print_at_null, show_repeat_count_threshold)
	(show_prettyprint_structs, show_unionprint)
	(show_prettyprint_arrays, show_addressprint, show_input_radix)
	(show_output_radix): Ditto.
	* valops.c (_initialize_valops, show_overload_resolution): Ditto.
	* utils.c (initialize_utils, show_chars_per_line)
	(show_lines_per_page, show_demangle, show_pagination_enabled)
	(show_sevenbit_strings, show_asm_demangle): Ditto
	* tui/tui-win.c (_initialize_tui_win, show_tui_border_kind)
	(show_tui_border_mode, show_tui_active_border_mode): Ditto.
	* top.c (init_main, show_new_async_prompt)
	(show_async_command_editing_p, show_write_history_p)
	(show_history_size, show_history_filename, show_caution)
	(show_annotation_level, init_main): Ditto.
	* target.c (initialize_targets, show_targetdebug)
	(show_trust_readonly): Ditto.
	* symfile.c (_initialize_symfile, show_symbol_reloading)
	(show_ext_args, show_download_write_size)
	(show_debug_file_directory): Ditto.
	* source.c (_initialize_source, show_lines_to_list): Ditto.
	* solib.c (_initialize_solib, show_auto_solib_add)
	(show_solib_search_path): Ditto.
	* p-valprint.c (_initialize_pascal_valprint)
	(show_pascal_static_field_print): Ditto.
	* printcmd.c (_initialize_printcmd, show_max_symbolic_offset)
	(show_print_symbol_filename): Add and update.
	* parse.c (_initialize_parse, show_expressiondebug): Dito.
	* observer.c (_initialize_observer, show_observer_debug): Dito.
	* maint.c (_initialize_maint_cmds, show_watchdog)
	(show_maintenance_profile_p): Dito.
	* linux-nat.c (_initialize_linux_nat, show_debug_linux_nat): Dito.
	* infrun.c (_initialize_infrun, show_debug_infrun)
	(show_stop_on_solib_events, show_follow_fork_mode_string)
	(show_scheduler_mode, show_step_stop_if_no_debug): Ditto.
	* infcall.c (_initialize_infcall, show_coerce_float_to_double_p)
	(show_unwind_on_signal_p): Ditto.
	* gdbtypes.c (build_gdbtypes, show_opaque_type_resolution)
	(_initialize_gdbtypes, show_overload_debug): Ditto.
	* gdb-events.c, gdb-events.sh (_initialize_gdb_events)
	(show_gdb_events_debug): Ditto.
	* gdbarch.c, gdbarch.sh (show_gdbarch_debug)
	(_initialize_gdbarch): Ditto.
	* frame.c (_initialize_frame, show_backtrace_past_main)
	(show_backtrace_past_entry, show_backtrace_limit)
	(show_frame_debug): Ditto.
	* exec.c (_initialize_exec, show_write_files): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read)
	(show_dwarf2_max_cache_age): Ditto.
	* demangle.c (_initialize_demangler)
	(show_demangling_style_names): Ditto.
	* dcache.c (_initialize_dcache, show_dcache_enabled_p): Ditto.
	* cp-valprint.c (show_static_field_print)
	(_initialize_cp_valprint, show_vtblprint, show_objectprint): Ditto.
	* corefile.c (_initialize_core, show_gnutarget_string): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging)
	(show_logging_overwrite, show_logging_redirect)
	(show_logging_filename): Ditto.
	* cli/cli-cmds.c (show_info_verbose, show_history_expansion_p)
	(init_cli_cmds, show_baud_rate, show_remote_debug)
	(show_remote_timeout, show_max_user_call_depth): Ditto.
	* charset.c (show_host_charset_name, show_target_charset_name)
	(initialize_charset): Ditto.
	* breakpoint.c (show_can_use_hw_watchpoints)
	(show_pending_break_support, _initialize_breakpoint): Ditto.
@
text
@d50 23
d145 1
d206 3
a208 3
  if (found_file < 0 && TARGET_SO_FIND_AND_OPEN_SOLIB != NULL)
    found_file = TARGET_SO_FIND_AND_OPEN_SOLIB
                 (in_pathname, O_RDONLY, &temp_pathname);
d311 2
d316 1
a316 1
      TARGET_SO_RELOCATE_SECTION_ADDRESSES (so, p);
d353 1
d370 1
a370 1
  TARGET_SO_FREE_SO (so);
d469 2
a470 1
  struct so_list *inferior = TARGET_SO_CURRENT_SOS ();
d478 1
a478 1
    catch_errors (TARGET_SO_OPEN_SYMBOL_FILE_OBJECT, &from_tty, 
d666 2
d672 1
a672 1
	TARGET_SO_SPECIAL_SYMBOL_HANDLING ();
d793 2
d828 1
a828 1
  TARGET_SO_CLEAR_SOLIB ();
d856 2
a857 1
  TARGET_SO_SOLIB_CREATE_INFERIOR_HOOK ();
d879 2
a880 1
  return TARGET_SO_IN_DYNSYM_RESOLVE_CODE (pc);
d947 2
@


1.79.2.1
log
@	* corelow.c (core_open): Use bfd_fopen, not bfd_fdopenr.
	* exec.c (exec_file_attach): Likewise.
	* solib-frv.c (enable_break2): Likewise.
	* solib-svr4.c (enable_break): Likewise.
	* solib.c (solib_map_sections): Likewise.
	* symfile.c (symfile_bfd_open): Likewise.
@
text
@d256 1
a256 1
  abfd = bfd_fopen (scratch_pathname, gnutarget, FOPEN_RB, scratch_chan);
@


1.78
log
@2005-02-21  Andrew Cagney  <cagney@@gnu.org>

	Replace string variables with a filename completer with
	add_setshow_optional_filename_cmd.
	* solib.c, symfile.c: Update.
	* cli/cli-setshow.c: Do not tidle expand the file.
@
text
@d73 8
d897 9
d929 1
a929 1
			   NULL, /* FIXME: i18n: */
d951 1
a951 1
				     NULL, /* FIXME: i18n: */
@


1.77
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_boolean_command through out.  Delete #ifdef 0'ed
	code adding set/show boolean commands.
	* cp-valprint.c, dcache.c, exec.c, gdbtypes.c, infrun.c: Update.
	* monitor.c, p-valprint.c, pa64solib.c, printcmd.c: Update.
	* proc-api.c, remote-mips.c, remote.c, solib.c: Update.
	* somsolib.c, symfile.c, top.c, utils.c, valops.c: Update.
	* valprint.c, win32-nat.c, wince.c, xcoffsolib.c: Update.
	* cli/cli-cmds.c: Update.
@
text
@d928 8
a935 8
  c = add_set_cmd ("solib-search-path", class_support, var_string,
		   (char *) &solib_search_path,
		   "Set the search path for loading non-absolute shared library symbol files.\n\
This takes precedence over the environment variables PATH and LD_LIBRARY_PATH.",
		   &setlist);
  deprecated_add_show_from_set (c, &showlist);
  set_cmd_sfunc (c, reload_shared_libraries);
  set_cmd_completer (c, filename_completer);
@


1.76
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_filename_cmd): Set the completer
	to filename_completer.
	* solib.c (_initialize_solib, reload_shared_libraries): Use
	add_setshow_filename_cmd.
	* serial.c (_initialize_serial): Ditto.
	* remote-utils.c (_initialize_sr_support): Ditto.
@
text
@d903 4
a906 4
  deprecated_add_show_from_set
    (add_set_cmd ("auto-solib-add", class_support, var_boolean,
		  (char *) &auto_solib_add,
		  "Set autoloading of shared library symbols.\n\
d910 4
a913 3
inferior.  Otherwise, symbols must be loaded manually, using `sharedlibrary'.",
		  &setlist),
     &showlist);
@


1.75
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d882 2
a883 1
reload_shared_libraries (char *ignored, int from_tty)
d914 8
a921 8
  c = add_set_cmd ("solib-absolute-prefix", class_support, var_filename,
		   (char *) &solib_absolute_prefix,
		   "Set prefix for loading absolute shared library symbol files.\n\
For other (relative) files, you can add values using `set solib-search-path'.",
		   &setlist);
  deprecated_add_show_from_set (c, &showlist);
  set_cmd_cfunc (c, reload_shared_libraries);
  set_cmd_completer (c, filename_completer);
d933 1
a933 1
  set_cmd_cfunc (c, reload_shared_libraries);
@


1.74
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d896 1
a896 1
	   "Load shared object library symbols for files matching REGEXP.");
d898 1
a898 1
	    "Status of loaded shared object libraries.");
d900 1
a900 1
	   "Unload all shared object library symbols.");
@


1.73
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d384 1
a384 1
	printf_unfiltered ("Symbols already loaded for %s\n", so->so_name);
d393 1
a393 1
	    printf_unfiltered ("Loaded symbols for %s\n", so->so_name);
d706 1
a706 1
      printf_unfiltered ("No shared libraries loaded at this time.\n");
@


1.72
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d670 1
a670 1
		      "TARGET_PTR_BIT returned unknown size %d",
@


1.71
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* solib-aix.c: Whitespace tweaks.
	* solib.c: Whitespace tweaks.
	* solib-frv.c: Whitespace tweaks.
	* solib.h: Whitespace tweaks.
	* solib-irix.c: Whitespace tweaks.
	* solib-som.c: Whitespace tweaks.
	* solib-sunos.c: Whitespace tweaks.
	* solib-svr4.[ch]: Whitespace tweaks.
@
text
@d252 1
a252 1
      error ("Could not open `%s' as an executable file: %s",
d263 1
a263 1
    error ("Full path name length of shared library exceeds SO_NAME_MAX_PATH_SIZE in so_list structure.");
d268 1
a268 1
      error ("\"%s\": not in executable format: %s.",
d273 1
a273 1
      error ("Can't find the file sections in `%s': %s",
d328 1
a328 1
	warning ("cannot close \"%s\": %s",
d604 1
a604 1
	error ("Invalid regexp: %s", re_err);
@


1.70
log
@* solib.h Update copyright year.
(struct so_list): Forward declaration.
(solib_read_symbols): New prototype.
* solib.c (solib_read_symbols): New function.
(solib_add): Call solib_read_symbols to read in symbols.
(update_solib_list): Call observer_notify_solib_loaded.
@
text
@d804 1
a804 1
   void solib_create_inferior_hook()
@


1.69
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d4 2
a5 1
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d374 27
d511 2
a512 2
	  /* Notify any observer that the SO has been unloaded
	     before we remove it from the gdb tables.  */
d565 4
d620 2
a621 21

	  if (gdb->symbols_loaded)
	    {
	      if (from_tty)
		printf_unfiltered ("Symbols already loaded for %s\n",
				   gdb->so_name);
	    }
	  else if (readsyms)
	    {
	      if (catch_errors
		  (symbol_add_stub, gdb,
		   "Error while reading shared library symbols:\n",
		   RETURN_MASK_ALL))
		{
		  if (from_tty)
		    printf_unfiltered ("Loaded symbols for %s\n",
				       gdb->so_name);
		  gdb->symbols_loaded = 1;
		  loaded_any_symbols = 1;
		}
	    }
@


1.68
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@d32 1
@


1.67
log
@
2004-09-01  Jeff Johnston  <jjohnstn@@redhat.com>

        * observer.sh: Add struct so_list declaration.
        * Makefile.in: Add dependencies on observer.h for solib.c and
        breakpoint.c.
        * breakpoint.c (disable_breakpoints_in_unloaded_shlib): New
        function.
        (_initialize_breakpoint): Register
        disable_breakpoints_in_unloaded_shlib as an observer of the
        "solib unloaded" observation event.
        (re_enable_breakpoints_in_shlibs): For bp_shlib_disabled breakpoints,
        call decode_line_1 so unfound breakpoint errors are silent.
        * solib.c (update_solib_list): When a solib is discovered to have
        been unloaded by the program, notify all observers of the
        "solib unloaded" observation event.
@
text
@a647 1
  char *addr_fmt;
d650 1
a650 4
    {
      addr_width = 8 + 4;
      addr_fmt = "08l";
    }
d652 1
a652 4
    {
      addr_width = 16 + 4;
      addr_fmt = "016l";
    }
d676 1
a676 1
			       ? local_hex_string_custom (
d678 1
a678 1
	                           addr_fmt)
d682 1
a682 1
			       ? local_hex_string_custom (
d684 1
a684 1
	                           addr_fmt)
@


1.66
log
@	* defs.h (OPF_TRY_CWD_FIRST, OPF_SEARCH_IN_PATH): New macros.

	* exec.c (exec_file_attach):
	* nto-tdep.c (nto_find_and_open_solib):
	* pa64solib.c (pa64_solib_sizeof_symbol_table):
	* solib.c (solib_open):
	* somsolib.c (som_solib_sizeof_symbol_table):
	* source.c (is_regular_file, openp, open_source_file):
	* symfile.c (symfile_bfd_open):
	* wince.c (upload_to_device): Differentiate between the search for
	binary and source files.
@
text
@d45 1
d482 4
@


1.65
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d159 2
a160 2
    found_file = openp (solib_search_path,
			1, in_pathname, O_RDONLY, 0, &temp_pathname);
d166 2
a167 2
    found_file = openp (solib_search_path, 
                        1, lbasename (in_pathname), O_RDONLY, 0,
d178 2
a179 1
			1, in_pathname, O_RDONLY, 0, &temp_pathname);
d185 2
a186 1
			1, in_pathname, O_RDONLY, 0, &temp_pathname);
@


1.64
log
@	* solist.h (master_so_list): New function.
	* solib.c (master_so_list): Likewise.
	* solib-svr4.c (enable_break): Iterate over so_list entries
	obtained from master list instead of entries obtained directly
	via svr4_current_sos().
@
text
@d888 1
a888 1
  add_show_from_set
d904 1
a904 1
  add_show_from_set (c, &showlist);
d917 1
a917 1
  add_show_from_set (c, &showlist);
@


1.64.2.1
log
@2004-03-23  Elena Zannoni  <ezannoni@@redhat.com>

       * solib-svr4.c (svr4_solib_create_inferior_hook): Disable
       breakpoints at startup.
       (elf_locate_base): Find out where the entry point for the program
       is, using the auxv vector, if possible. Compute the address of
       .dynamic using it.
       (svr4_current_sos): Don't ignore the first entry if we have PIE,
       it's our main program. Delete code that was skipping over the
       solib entry for main executable.
       * solist.h (struct so_list): Add fields main and main_relocated.
        (add_to_target_sections): Export.
       * solib.c (symbol_add_stub): Handle main executable in shared
       library list. Ignore it if it has been relocated already. Add it
       as the main symbol file, otherwise.
       * infrun.c (handle_inferior_event): Re-enable startup breakpoints.

       * solib-svr4.c (elf_locate_base, first_link_map_member)
       svr4_current_sos, enable_break): Add debugging output.
       * solist.h (debug_solib): Export.
       * solib.c (debug_solib): New variable to enable debugging output.
       (symbol_add_stub, update_solib_list, update_solib_list)
       (add_to_target_sections): Add debugging output.
       (_initialize_solib): Add new comand to enable printing of
       debugging output.
       (add_to_target_sections): New function. Factored out from
       update_solib_list.
       (update_solib_list): Call add_to_target_sections.

       * varobj.h (varobj_refresh): New prototype.
       * varobj.c (varobj_refresh): New function.
       * symfile.c (reread_symbols): Make sure that we recompute the
       entry point for the program.
       (symbol_file_clear): Clear the solibs as well, if we change symbol
       files.
       (clear_symtab_users): Refresh the varobjs that depend on the symtabs
       we are clearing.
       * objfiles.c (entry_point_address): Rewrite, to fetch entry point
       from auxv vector, if possible.
       Add include of elf/common.h.
       * breakpoint.h (enum bptype): Add bp type bp_startup_disabled.
       (re_enable_breakpoints_at_startup)
       (disable_breakpoints_at_startup): Add prototypes
       * breakpoint.c (re_enable_breakpoints_at_startup)
       (disable_breakpoints_at_startup): New functions.
       (describe_other_breakpoints, delete_breakpoint)
       (breakpoint_re_set_one): Handle new bp type.
       * auxv.h (target_auxv_parse, target_auxv_search): Update.
       * auxv.c (target_auxv_parse, target_auxv_search)
       (fprint_target_auxv): Use ULONGEST instead of CORE_ADDR for
       variable. Change variable name to at_type.
@
text
@a48 2
int debug_solib;

a70 2
void add_to_target_sections (int, struct target_ops *, struct so_list *);

d343 1
d355 1
a355 3
      /* Found an already loaded shared library.  */
      if (strcmp (so->objfile->name, so->so_name) == 0
          && !so->main)
a356 12
      /* Found an already loaded main executable.  This could happen in
         two circumstances. 
         First case: the main file has already been read in
         as the first thing that gdb does at startup, and the file
         hasn't been relocated properly yet. Therefor we need to read
         it in with the proper section info.
         Second case: it has been read in with the correct relocation,
         and therefore we need to skip it.  */
      if (strcmp (so->objfile->name, so->so_name) == 0 
          && so->main
          && so->main_relocated)
        return 1;
d362 2
a363 13
  if (so->main)
    {
      if (debug_solib)
        fprintf_unfiltered (gdb_stdlog,
			    "symbol_add_stub: adding symbols for main\n");
      so->objfile = symbol_file_add (so->so_name, /*so->from_tty*/ 0,
   				     sap, 1, 0);
      so->main_relocated = 1;
    }
  else
    so->objfile = symbol_file_add (so->so_name, so->from_tty,
				   sap, 0, OBJF_SHARED);

a457 4
          if (debug_solib)
            fprintf_unfiltered (gdb_stdlog,
                                "update_solib_list: compare gdb:%s and inferior:%s\n",
                                gdb->so_original_name, i->so_original_name);
d507 22
a528 1
   	  add_to_target_sections (from_tty, target, i);
a532 35
void
add_to_target_sections (int from_tty, struct target_ops *target, struct so_list *solib)
{
  /* If this is set, then the sections have been already added to the
     target list.  */
  if (solib->main)
    return;

  solib->from_tty = from_tty;

  /* Fill in the rest of the `struct so_list' node.  */
  catch_errors (solib_map_sections, solib,
		"Error while mapping shared library sections:\n",
		RETURN_MASK_ALL);

  /* If requested, add the shared object's sections to the TARGET's
     section table.  Do this immediately after mapping the object so
     that later nodes in the list can query this object, as is needed
     in solib-osf.c.  */
  if (target)
    {
      int count = (solib->sections_end - solib->sections);
      if (count > 0)
	{
	  int space = target_resize_to_sections (target, count);
          if (debug_solib)
             fprintf_unfiltered (gdb_stdlog,
                                 "add_to_target_sections: add %s to to_sections\n",
                                 solib->so_original_name);
	  memcpy (target->to_sections + space,
		  solib->sections,
		  count * sizeof (solib->sections[0]));
	}
    }
}
a919 6

  add_show_from_set (add_set_cmd ("solib", no_class, var_zinteger,
                                 (char *) &debug_solib,
                                 "Set debugging of GNU/Linux shlib module.\n\
Enables printf debugging output.\n", &setdebuglist), &showdebuglist);

@


1.63
log
@2004-02-28  Andrew Cagney  <cagney@@redhat.com>

	* utils.c: Use "", instead of <>, to include readline.
	tui/tui-win.c, tui/tui.c, tui/tui-hooks.c: Ditto.
	* tracepoint.c, top.c, symmisc.c, symfile.c: Ditto.
	* source.c, solib.c, exec.c, event-top.c: Ditto.
	* corelow.c, completer.c, cli/cli-setshow.c: Ditto.
	* cli/cli-dump.c, cli/cli-cmds.c: Ditto.
	* Makefile.in: Update all dependencies.
	(readline_tilde_h, readline_history_h): Define.
	(readline_headers): Delete.
@
text
@d336 8
@


1.63.4.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@a335 8
/* Return address of first so_list entry in master shared object list.  */
struct so_list *
master_so_list (void)
{
  return so_list_head;
}


@


1.62
log
@2004-02-15  Andrew Cagney  <cagney@@redhat.com>

	* solib.c (solib_map_sections): Use bfd_set_cacheable instead of
	poking .cacheable directly.
	* symfile.c (symfile_bfd_open): Ditto.
@
text
@d45 1
a45 1
#include <readline/readline.h>
@


1.62.2.1
log
@Merge mainline to intercu branch.
@
text
@d45 1
a45 1
#include "readline/readline.h"
a332 8
}


/* Return address of first so_list entry in master shared object list.  */
struct so_list *
master_so_list (void)
{
  return so_list_head;
@


1.62.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a44 1
#include "observer.h"
d159 2
a160 2
    found_file = openp (solib_search_path, OPF_TRY_CWD_FIRST,
			in_pathname, O_RDONLY, 0, &temp_pathname);
d166 2
a167 2
    found_file = openp (solib_search_path, OPF_TRY_CWD_FIRST,
                        lbasename (in_pathname), O_RDONLY, 0,
d178 1
a178 2
			OPF_TRY_CWD_FIRST, in_pathname, O_RDONLY, 0,
			&temp_pathname);
d184 1
a184 2
			OPF_TRY_CWD_FIRST, in_pathname, O_RDONLY, 0,
			&temp_pathname);
a478 4
	  /* Notify any observer that the SO has been unloaded
	     before we remove it from the gdb tables.  */
	  observer_notify_solib_unloaded (gdb);

d641 1
d644 4
a647 1
    addr_width = 8 + 4;
d649 4
a652 1
    addr_width = 16 + 4;
d676 1
a676 1
			       ? hex_string_custom (
d678 1
a678 1
	                           addr_width - 4)
d682 1
a682 1
			       ? hex_string_custom (
d684 1
a684 1
	                           addr_width - 4)
d888 1
a888 1
  deprecated_add_show_from_set
d904 1
a904 1
  deprecated_add_show_from_set (c, &showlist);
d917 1
a917 1
  deprecated_add_show_from_set (c, &showlist);
@


1.61
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@d253 1
a253 1
  abfd->cacheable = 1;
@


1.60
log
@2003-10-22  Andrew Cagney  <cagney@@redhat.com>

	* exec.h: New file.
	* win32-nat.c: Include "exec.h".
	* solib.c: Include "exec.h".
	* target.h (build_section_table): Delete declaration.
	* somsolib.c: Include "exec.h".
	(exec_ops): Delete extern declaration.
	* rs6000-nat.c: Update copyright.  Include "exec.h".
	(exec_ops): Delete extern declaration.
	* pa64solib.c: Update copyright.  Include "exec.h".
	(exec_ops): Delete extern declaration.
	* exec.c: Update copyright.  Include "exec.h".
	* corelow.c: Update dependencies.  Include "exec.h".
	* Makefile.in (exec_h): Define.
	(exec.o, somsolib.o): Update dependencies.
	(pa64solib.o, corelow.o): Update dependencies.
@
text
@d278 1
a278 1
      if (STREQ (p->the_bfd_section->name, ".text"))
@


1.59
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d43 1
a43 1

@


1.58
log
@2003-06-19  Kris Warkentin  <kewarken@@qnx.com>

* solib.c (solib_open): Change tests for whether to search
LD_LIBRARY_PATH and PATH to better deal with remotes.  Update
comments.
@
text
@d341 1
a341 1
  register struct so_list *so = (struct so_list *) arg;  /* catch_errs bogon */
d630 1
a630 1
  register struct so_list *so = NULL;	/* link map state variable */
d712 1
a712 1
  register struct so_list *so = 0;	/* link map state variable */
@


1.57
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_push_return_address): Make static.
	(xstormy16_save_dummy_frame_tos): Make static.
	(_initialize_xstormy16_tdep): Add declaration.
	* vax-tdep.c (_initialize_vax_tdep): Add declaration.
	* v850-tdep.c: Make local functions static.
	(_initialize_v850_tdep): Add declaration.
	* sparc-tdep.c: Make local functions static.
	(_initialize_sparc_tdep): Add declaration.
	* sh-tdep.c: Make local functions static.
	(_initialize_sh_tdep): Add declaration.
	* sh3-rom.c (_initialize_sh3_rom): Add declaration.
	* s390-tdep.c: Make local functions static.
	(_initialize_s390_tdep): Add declaration.
	* dbxread.c (find_stab_function_addr): Make static.
	* ppc-bdm.c (_initialize_bdm_ppc): Add declaration.
	* ocd.c (_initialize_remote_ocd): Add declaration.
	* dink32-rom.c (_initialize_dink32_rom): Add declaration.
	* ppcbug-rom.c (_initialize_ppcbug_rom): Add declaration.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Add declaration.
	* ns32knbsd-tdep.c (_initialize_ns32knbsd_tdep): Add declaration.
	* mips-tdep.c (_initialize_mips_tdep): Add declaration.
	* remote-array.c (_initialize_array): Add declaration.
	(_initialize_remote_monitors): Add declaration.
	* remote-mips.c: Make local functions static.
	(_initialize_remote_mips): Add declaration.
	* mcore-tdep.c: Make all local functions static.
	(_initialize_mcore_tdep): Add declaration.
	* dbug-rom.c (_initialize_dbug_rom): Add declaration.
	* abug-rom.c (_initialize_abug_rom): Add declaration.
	* rom68k-rom.c (_initialize_rom68k): Add declaration.
	* cpu32bug-rom.c (_initialize_cpu32bug_rom): Add declaration.
	* m68k-tdep.c (_initialize_m68k_tdep): Add declaration.
	* remote-est.c (_initialize_est): Add declaration.
	* m68hc11-tdep.c (_initialize_m68hc11_tdep): Add declaration.
	(m68hc11_call_dummy_address): Make static.
	* ia64-tdep.c: Make local functions static.
	(_initialize_ia64_tdep): Add declaration.
	* solib-legacy.c (_initialize_svr4_lm): Add declaration.
	* monitor.c (monitor_wait_filter): Make static.
	(_initialize_remote_monitors): Add declaration.
	* remote-hms.c (_initialize_remote_hms): Add declaration.
	* remote-e7000.c (fetch_regs_from_dump): Make static.
	(expect_n): Make static.
	(_initialize_remote_e7000): Add declaration.
	* ser-e7kpc.c: Always include "defs.h".
	(_initialize_ser_e7000pc): Add declaration.
	* h8300-tdep.c (_initialize_h8300_tdep): Add declaration.
	* cris-tdep.c: Make all but one function static.
	(_initialize_cris_tdep): Add declaration.
	* solib-svr4.c (_initialize_svr4_solib): Add declaration.
	* solib.c (update_solib_list): Make static.
	(_initialize_solib): Add declaration.
	* avr-tdep.c (avr_breakpoint_from_pc): Make static.
	(_initialize_avr_tdep): Add declaration.
	* remote-rdi.c (voiddummy): Make static.
	(_initialize_remote_rdi): Add declaration.
	* arm-tdep.c (_initialize_arm_tdep): Add declaration.
	* remote-rdp.c (send_rdp): Make static.
	(_initialize_remote_rdp): Add declaration.
	* alpha-tdep.c (_initialize_alpha_tdep): Add declaration.
@
text
@d90 5
a94 3
   Search order:
   * If path is absolute, look in SOLIB_ABSOLUTE_PREFIX.
   * If path is absolute or relative, look for it literally (unmodified).
d97 6
a102 2
   * Look in inferior's $PATH.
   * Look in inferior's $LD_LIBRARY_PATH.
d157 1
a157 1
  /* If not found, next search the solib_search_path (if any).  */
d176 1
a176 1
  if (found_file < 0 && solib_search_path != NULL)
d182 1
a182 1
  if (found_file < 0 && solib_search_path != NULL)
@


1.56
log
@2003-06-03  Kris Warkentin  <kewarken@@qnx.com>

 * solib.c (solib_open): Update comment to reflect actual search order.
@
text
@d385 1
a385 1
void
d859 2
@


1.55
log
@added target specific solib find hook
@
text
@d94 1
@


1.55.24.1
log
@Snap const char * mess.
@
text
@d540 1
a540 2
solib_add (const char *pattern, int from_tty, struct target_ops *target,
	   int readsyms)
d621 1
a621 1
info_sharedlibrary_command (const char *ignore, int from_tty)
d827 1
a827 1
sharedlibrary_command (const char *args, int from_tty)
d846 1
a846 1
no_shared_libraries (const char *ignored, int from_tty)
d853 1
a853 1
reload_shared_libraries (const char *ignored, int from_tty)
@


1.54
log
@	* solib.c (reload_shared_libraries): New function.
	(_initialize_solib): Add callbacks for ``set solib-search-path''
	and ``set solib-absolute-prefix''.
@
text
@d163 5
@


1.53
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d847 7
d883 1
d896 1
@


1.52
log
@	* Makefile.in (TARGET_SYSTEM_ROOT, TARGET_SYSTEM_ROOT_DEFINE): New
	variables.
	(main.o): Custom rule which uses $(TARGET_SYSTEM_ROOT_DEFINE).
	* configure.in: Add --with-sysroot.
	* configure: Regenerated.
	* main.c (gdb_sysroot): New variable.
	(captured_main): Initialize gdb_sysroot.
	* defs.h (gdb_sysroot): New extern declaration.
	* solib.c (_initialize_solib): Initialize solib_absolute_prefix.
@
text
@d60 1
a60 1
static void do_clear_solib (PTR);
d210 1
a210 1
solib_map_sections (PTR arg)
d327 1
a327 1
symbol_add_stub (PTR arg)
d390 1
a390 1
    catch_errors (TARGET_SO_OPEN_SYMBOL_FILE_OBJECT, (PTR) &from_tty, 
d758 1
a758 1
do_clear_solib (PTR dummy)
@


1.51
log
@2002-12-08  Elena Zannoni  <ezannoni@@redhat.com>

	More cleanup from import of readline 4.3.
	* completer.h (complete_line, readline_line_completion_function):
	Update prototypes.
	(line_completion_function): Removed, not used outside of completer.c.
	* completer.c (readline_line_completion_function,
	complete_function, line_completion_function): Use const for first
	parameter.
	(line_completion_function): Make static.
	(filename_completer): filename_completion_function is now called
	rl_filename_completion_function
	* corelow.c: Include <readline/readline.h>.
	* exec.c: Ditto.
	* solib.c: Ditto.
	* source.c: Ditto.
	* symfile.c: Ditto.
	* symmisc.c: Ditto.
	* top.c (init_main): No need to coerce
	readline_line_completion_function anymore.
	* cli/cli-dump.c: Include <readline/readline.h>.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d877 4
@


1.50
log
@* language.c (local_hex_string_custom): Simplify.  Do not depend
on PRINTF_HAS_LONG_LONG or CC_HAS_LONG_LONG.

* memattr.c (mem_info_command): Replace calls to
longest_local_hex_string and longest_local_hex_string_custom.
* buildsym.c (make_blockvector): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* symtab.c (print_msymbol_info): Ditto.

* language.c (local_hex_string): Delete.
(local_hex_string_custom): Delete.
(longest_local_hex_string): Rename to local_hex_string.
(longest_local_hex_string_custom): Rename to
local_hex_string_custom.
* language.h (local_hex_string): Change parameter type to LONGEST.
(local_hex_string_custom): Ditto.
(longest_local_hex_string): Delete declaration.
(longest_local_hex_string_custom): Ditto.

* solib.c: Update copyright.
* memattr.c: Update copyright.
@
text
@d45 1
@


1.50.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d43 1
a43 1
#include "exec.h"
a44 1
#include <readline/readline.h>
d59 1
a59 1
static void do_clear_solib (void *);
d89 3
a91 5
   Search algorithm:
   * If there is a solib_absolute_prefix and path is absolute:
   *   Search for solib_absolute_prefix/path.
   * else
   *   Look for it literally (unmodified).
d93 2
a94 7
   * If available, use target defined search function.
   * If solib_absolute_prefix is NOT set, perform the following two searches:
   *   Look in inferior's $PATH.
   *   Look in inferior's $LD_LIBRARY_PATH.
   *   
   * The last check avoids doing this search when targetting remote
   * machines since solib_absolute_prefix will almost always be set.
d149 1
a149 1
  /* If not found, search the solib_search_path (if any).  */
a161 5
  /* If not found, try to use target supplied solib search method */
  if (found_file < 0 && TARGET_SO_FIND_AND_OPEN_SOLIB != NULL)
    found_file = TARGET_SO_FIND_AND_OPEN_SOLIB
                 (in_pathname, O_RDONLY, &temp_pathname);

d163 1
a163 1
  if (found_file < 0 && solib_absolute_prefix == NULL)
d169 1
a169 1
  if (found_file < 0 && solib_absolute_prefix == NULL)
d209 1
a209 1
solib_map_sections (void *arg)
d265 1
a265 1
      if (strcmp (p->the_bfd_section->name, ".text") == 0)
d326 1
a326 1
symbol_add_stub (void *arg)
d328 1
a328 1
  struct so_list *so = (struct so_list *) arg;  /* catch_errs bogon */
d378 1
a378 1
static void
d389 1
a389 1
    catch_errors (TARGET_SO_OPEN_SYMBOL_FILE_OBJECT, &from_tty, 
d617 1
a617 1
  struct so_list *so = NULL;	/* link map state variable */
d699 1
a699 1
  struct so_list *so = 0;	/* link map state variable */
d757 1
a757 1
do_clear_solib (void *dummy)
a845 9
static void
reload_shared_libraries (char *ignored, int from_tty)
{
  no_shared_libraries (NULL, from_tty);
  solib_add (NULL, from_tty, NULL, auto_solib_add);
}

extern initialize_file_ftype _initialize_solib; /* -Wmissing-prototypes */

a874 1
  set_cmd_cfunc (c, reload_shared_libraries);
a876 4
  /* Set the default value of "solib-absolute-prefix" from the sysroot, if
     one is set.  */
  solib_absolute_prefix = xstrdup (gdb_sysroot);

a882 1
  set_cmd_cfunc (c, reload_shared_libraries);
@


1.50.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a44 1
#include <readline/readline.h>
@


1.50.12.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d60 1
a60 1
static void do_clear_solib (void *);
d210 1
a210 1
solib_map_sections (void *arg)
d327 1
a327 1
symbol_add_stub (void *arg)
d390 1
a390 1
    catch_errors (TARGET_SO_OPEN_SYMBOL_FILE_OBJECT, &from_tty, 
d758 1
a758 1
do_clear_solib (void *dummy)
a876 4

  /* Set the default value of "solib-absolute-prefix" from the sysroot, if
     one is set.  */
  solib_absolute_prefix = xstrdup (gdb_sysroot);
@


1.50.12.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@a162 5
  /* If not found, try to use target supplied solib search method */
  if (found_file < 0 && TARGET_SO_FIND_AND_OPEN_SOLIB != NULL)
    found_file = TARGET_SO_FIND_AND_OPEN_SOLIB
                 (in_pathname, O_RDONLY, &temp_pathname);

a846 7
static void
reload_shared_libraries (char *ignored, int from_tty)
{
  no_shared_libraries (NULL, from_tty);
  solib_add (NULL, from_tty, NULL, auto_solib_add);
}

a875 1
  set_cmd_cfunc (c, reload_shared_libraries);
a887 1
  set_cmd_cfunc (c, reload_shared_libraries);
@


1.50.12.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d90 3
a92 5
   Search algorithm:
   * If there is a solib_absolute_prefix and path is absolute:
   *   Search for solib_absolute_prefix/path.
   * else
   *   Look for it literally (unmodified).
d94 2
a95 7
   * If available, use target defined search function.
   * If solib_absolute_prefix is NOT set, perform the following two searches:
   *   Look in inferior's $PATH.
   *   Look in inferior's $LD_LIBRARY_PATH.
   *   
   * The last check avoids doing this search when targetting remote
   * machines since solib_absolute_prefix will almost always be set.
d150 1
a150 1
  /* If not found, search the solib_search_path (if any).  */
d169 1
a169 1
  if (found_file < 0 && solib_absolute_prefix == NULL)
d175 1
a175 1
  if (found_file < 0 && solib_absolute_prefix == NULL)
d384 1
a384 1
static void
a857 2

extern initialize_file_ftype _initialize_solib; /* -Wmissing-prototypes */
@


1.50.12.5
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d341 1
a341 1
  struct so_list *so = (struct so_list *) arg;  /* catch_errs bogon */
d630 1
a630 1
  struct so_list *so = NULL;	/* link map state variable */
d712 1
a712 1
  struct so_list *so = 0;	/* link map state variable */
@


1.50.12.6
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d43 1
a43 1
#include "exec.h"
d278 1
a278 1
      if (strcmp (p->the_bfd_section->name, ".text") == 0)
@


1.49
log
@* cli/cli-decode.c (set_cmd_completer): New function.
* command.h (set_cmd_completer): Declare.
* cli/cli-decode.h (set_cmd_completer): Ditto.

* breakpoint.c (_initialize_breakpoint): Use set_cmd_completer.
* cli/cli-cmds.c (init_cli_cmds): Ditto.
* win32-nat.c (_initialize_inftarg): Ditto.
* remote-rdi.c (_initialize_remote_rdi): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* hppa-tdep.c (_initialize_hppa_tdep): Ditto.
* source.c (_initialize_source): Ditto.
* exec.c (_initialize_exec): Ditto.
* solib.c (_initialize_solib): Ditto.
* top.c (init_main): Ditto.
* tracepoint.c (_initialize_tracepoint): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* printcmd.c (_initialize_printcmd): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
@
text
@d2 3
a4 3
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
   Free Software Foundation, Inc.
d655 1
a655 1
			       ? longest_local_hex_string_custom (
d661 1
a661 1
			       ? longest_local_hex_string_custom (
@


1.48
log
@* memattr.c (mem_command): Eliminate ``true'' and ``false''.
* osfsolib.c (solib_map_sections): Ditto.
* irix5-nat.c (solib_map_sections): Ditto.
* corelow.c (gdb_check_format): Ditto.
* symfile.c (symfile_bfd_open): Ditto.
* solib.c (solib_map_sections): Ditto.
Partially fix PR gdb/354.
@
text
@d875 1
a875 1
  c->completer = filename_completer;
d883 1
a883 1
  c->completer = filename_completer;
@


1.47
log
@2002-01-07  Michael Snyder  <msnyder@@redhat.com>

	* solib.c (info_sharedlibrary_command): Use TARGET_PTR_BIT
	instead of bfd_get_arch_size.  Don't bail out just because
	there's no exec_bfd.
@
text
@d240 1
a240 1
  abfd->cacheable = true;
@


1.46
log
@2001-12-04  Orjan Friberg  <orjanf@@axis.com>

	* solib.c (solib_open): Make path relative if search for absolute path
	failed.  If search for relative path in solib_search_path failed, fall
	back to search for basename only.
@
text
@a620 1
  int arch_size;
d622 1
a622 12
  if (exec_bfd == NULL)
    {
      printf_unfiltered ("No executable file.\n");
      return;
    }

  arch_size = bfd_get_arch_size (exec_bfd);
  if (arch_size == -1)
    arch_size = bfd_arch_bits_per_address(exec_bfd);

  /* Default to 32-bit in case of failure.  */
  if (arch_size == 32 || arch_size == -1)
d627 1
a627 1
  else if (arch_size == 64)
d635 2
a636 2
		      "bfd_get_arch_size() returned unknown size %d",
		      arch_size);
@


1.45
log
@Approved by kev@@cygnus.com
ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* coff-solib.c (coff_solib_add): Add new readsyms arg.
	* irix5-nat.c (solib_add): Ditto.
	* osfsolib.c (solib_add): Ditto.
	* pa64solib.c (pa64_solib_add): Ditto.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* solib.c (solib_add): Ditto.
	* somsolib.c (som_solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* coff-solib.h (coff_solib_add): Add new readsyms arg to prototype.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* pa64solib.h (pa64_solib_add): Ditto.
	* solib.h (solib_add): Ditto.
	* somsolib.h (som_solib_add): Ditto.
	* config/i386/tm-cygwin.h (child_solib_add): Ditto.

	* coff-solib.c (coff_solib_add):  If readsyms is zero don't read
	symbols but do any other needed work for shared libs.
	* irix5-nat.c: Ditto.
	* osfsolib.c (solib_add): Ditto.
	* solib.c (solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* irix5-nat.c (sharedlibrary_command): Pass 1 as readsyms to
	solib_add to force reading of shared library symbols.
	* osfsolib.c (sharedlibrary_command;): Ditto.
	* pa64solib.c (pa64_solib_sharedlibrary_command): Ditto.
	* solib.c (sharedlibrary_command): Ditto.
	* somsolib.c (som_solib_sharedlibrary_command): Ditto.
	* xcoffsolib.c (sharedlibrary_command): Ditto.

	* coff-solib.c (coff_solib_create_inferior_hook): Call solib_add
	unconditionally with auto_solib_add.
	* irix5-nat.c (solib_create_inferior_hook): Ditto.
	* osfsolib.c (solib_create_inferior_hook): Ditto.
	* solib.c (solib_create_inferior_hook): Ditto.
	* solib-osf.c (osf_solib_create_inferior_hook): Ditto.
	* solib-svr4.c (enable_break): Ditto.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Ditto.

	* corelow.c (solib_add_stub): Add auto_solib_add to args passed
	via SOLIB_ADD.
	* sol-thread.c (sol_thread_attach): Ditto.
	* config/rs6000/nm-rs6000.h (SOLIB_ADD): Ditto.

	* infcmd.c (attach_command): Remove auto_solib_add decl.
	Call SOLIB_ADD directly with auto_solib_add.
	* infrun.c (handle_inferior_event): Ditto.

	* coff-solib.h (SOLIB_ADD): Add readsyms arg.
	* pa64solib.h (SOLIB_ADD): Ditto.
	* solib.h (SOLIB_ADD): Ditto.
	* somsolib.h (SOLIB_ADD): Ditto.
	* config/i386/tm-cygwin.h (SOLIB_ADD): Ditto.

	* fork-child.c (clone_and_follow_inferior): Remove unused
	auto_solib_add decl.

	* pa64solib.c (pa64_solib_add): Call add_to_solist with readsyms.
	(read_dld_descriptor): Ditto.
	(pa64_solib_add): Call read_dld_descriptor with	readsyms.
	(pa64_solib_in_dynamic_linker): Ditto.

	* corelow.c (symfile.h): Need this for auto_solib_add declaration.
	* sol-thread.c (symfile.h): Ditto.

Approved by eliz@@is.elta.co.il
doc/ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* gdbint.texinfo (SOLIB_ADD): Document additional new
	"readsyms" arg.
@
text
@d134 15
d153 8
@


1.44
log
@Changes approved by kev@@cygnus.com, ezannoni@@cygnus.com, eliz@@is.elta.co.il.

  Changelog:

	2001-10-27  Fred Fish  <fnf@@redhat.com>

	* symfile.c (auto_solib_add): Update comment to note that
	this variable is now just used as a boolean to control shlib
	autoloading, and clarify when it is used.
	* symfile.h (auto_solib_add): Ditto.

	* symfile.c (auto_solib_limit): New variable that holds the
	autoloading threshold instead of overloading auto_solib_add.
	* symfile.h (auto_solib_limit): Ditto.

	* irix5-nat.c (_initialize_solib): Change auto-solib-add
	variable from var_zinteger to var_boolean and update help.
	* osfsolib.c (_initialize_solib): Ditto.
	* pa64solib.c (_initialize_pa64_solib): Ditto.
	* solib.c (_initialize_solib): Ditto.
	* somsolib.c (_initialize_som_solib): Ditto.
	* xcoffsolib.c (_initialize_solib): Ditto.

	* pa64solib.c (pa64_solib_total_st_size): Update comment to
	note that the new auto_solib_limit variable is used instead
	of overloading auto_solib_add variable.
	(_initialize_pa64_solib): Ditto.
	* somsolib.c (som_solib_total_st_size): Ditto.
	(_initialize_som_solib): Ditto.

	* pa64solib.c (_initialize_pa64_solib): Add new set/show
	commands for auto-solib-limit variable.
	* somsolib.c (_initialize_som_solib): Ditto

	* pa64solib.c (add_to_solist): Check that auto_solib_add is
	set and use auto_solib_limit as the threshold size instead
	of auto_solib_add.
	* somsolib.c (som_solib_add): Ditto, and also change warning
	text about size threshold exceeded.

  doc/ChangeLog:

	2001-10-28  Fred Fish  <fnf@@redhat.com>

	* gdb.texinfo (auto-solib-add): Change docs to match
	implementation change.
	(auto-solib-limit): Add docs for new variable.
@
text
@d496 2
a497 1
   void solib_add (char *pattern, int from_tty, struct target_ops *TARGET)
d505 3
d511 1
a511 1
solib_add (char *pattern, int from_tty, struct target_ops *target)
d543 1
a543 1
	  else
d813 1
a813 1
  solib_add (args, from_tty, (struct target_ops *) 0);
@


1.43
log
@Commit Ilya Golubev's clear_solib() fixes.
@
text
@d844 1
a844 1
    (add_set_cmd ("auto-solib-add", class_support, var_zinteger,
d847 4
a850 4
If nonzero, symbols from all shared object libraries will be loaded\n\
automatically when the inferior begins execution or when the dynamic linker\n\
informs gdb that a new library has been loaded.  Otherwise, symbols\n\
must be loaded manually, using `sharedlibrary'.",
@


1.42
log
@	* source.c (mod_path, openp): Use HAVE_DOS_BASED_FILE_SYSTEM
	instead of system-specific define's like _WIN32 and __MSDOS__.
	Use IS_DIR_SEPARATOR and IS_ABSOLUTE_PATH instead of SLASH_P and
	ROOTED_P.
	(top-level): #include "filenames.h".

	* solib.c (solib_open): Use IS_DIR_SEPARATOR and IS_ABSOLUTE_PATH
	instead of SLASH_CHAR, ROOTED_P and SLASH_P.
	(top-level): #include "filenames.h".

	* defs.h (SLASH_P, SLASH_CHAR, ROOTED_P): Remove definitions.
	(SLASH_STRING): Define only for _WIN32.

	* completer.c: Use HAVE_DOS_BASED_FILE_SYSTEM instead of
	__MSDOS_.

	* cli/cli-cmds.c (cd_command): Use IS_DIR_SEPARATOR and
	IS_ABSOLUTE_PATH instead of SLASH_P and ROOTED_P.  Replace
	system-specific ifdefs with HAVE_DOS_BASED_FILE_SYSTEM.
	(top-level): #include "filenames.h".
@
text
@d733 2
@


1.42.4.1
log
@	From Ilya Golubev <gin@@mo.msk.ru>:
	* solib.c (clear_solib): Call `remove_target_sections' to fix
	stale pointers in `struct target_ops'.
	* irix5-nat.c (clear_solib): Likewise.
	* osfsolib.c (clear_solib): Likewise.
@
text
@a732 2
      if (so->abfd)
	remove_target_sections (so->abfd);
@


1.41
log
@	* solib.c (update_solib_list): Move target_resize_to_sections()
	into solib_map_sections() loop.
	(info_sharedlibrary_command): Try bfd_arch_bits_per_address() if
	bfd_get_arch_size() fails.
@
text
@d42 1
d105 1
d107 4
a110 1
  if (strchr (in_pathname, SLASH_CHAR))
d112 1
a112 1
      if (! ROOTED_P (in_pathname) || solib_absolute_prefix == NULL)
d120 1
a120 1
		 && SLASH_P (solib_absolute_prefix[prefix_len - 1]))
@


1.40
log
@2001-05-14  Michael Snyder  <msnyder@@redhat.com>

        * solib.c, solib.h: Add comment for function no_shared_libraries.
@
text
@a463 7
	}

      /* If requested, add the shared objects' sections to the the
	 TARGET's section table.  */
      if (target)
	{
	  int new_sections;
d465 5
a469 6
	  /* Figure out how many sections we'll need to add in total.  */
	  new_sections = 0;
	  for (i = inferior; i; i = i->next)
	    new_sections += (i->sections_end - i->sections);

	  if (new_sections > 0)
d471 2
a472 3
	      int space = target_resize_to_sections (target, new_sections);

	      for (i = inferior; i; i = i->next)
d474 1
a474 1
		  int count = (i->sections_end - i->sections);
a477 1
		  space += count;
d598 4
a601 1
  /* Default to 32-bit in case of failure (non-elf). */
@


1.39
log
@Fix thinko.
@
text
@d812 12
@


1.38
log
@2001-04-17  Michael Snyder  <msnyder@@redhat.com>

	* solib.c (no_shared_libraries): New function.  Discard all symbols
	from shared libraries.
	(_initialize_solib): Add command "nosharedlibrary" as complement
	to the command "sharedlibrary".  Unloads symbols for all solibs.
@
text
@d829 1
a829 1
	   "Unload all shared object library symbols except .");
@


1.37
log
@Update/correct copyright notices.
@
text
@d812 6
d828 2
@


1.36
log
@Made changes to shared library support and added more of the support needed
for AIX/IA-64.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 98, 1999, 2000, 2001
@


1.35
log
@2001-02-20  Martin M. Hunt  <hunt@@redhat.com>

	* solib.c (info_sharedlibrary_command): Don't assume pointers
	are the same size of long, call	longest_local_hex_string_custom().
@
text
@d768 21
@


1.34
log
@	* demangle.c (demangling_style_names): New variable.
	(_initialize_demangler): Fill demangling_style_names with the
	names of known demangling styles from libiberty_demanglers[].  Use
	add_set_enum_cmd instead of add_set_cmd, to get completion on
	demangling style names.

	* proc-api.c (_initialize_proc_api): Make `procfs-file' use
	file-name completion.

	* remote-rdi.c (_initialize_remote_rdi): Ditto for `rdilogfile'.

	* solib.c (_initialize_solib): Ditto for `solib-search-path' and
	`solib-absolute-prefix'.

	* tracepoint.c (_initialize_tracepoint): Ditto for
	`save-tracepoints'.

	* win32-nat.c (_initialize_inftarg): Ditto for `dll-symbols'.

	* cli/cli-cmds.c (init_cli_cmds): Make `shell' and `make' use
	file-name completion.

	* infcmd.c (_initialize_infcmd): Make the following commands use
	the file-name completer: `tty', `args', `path', `paths', and
	`run'.
@
text
@d641 2
a642 2
			       ? local_hex_string_custom (
			           (unsigned long) so->textsection->addr,
d647 2
a648 2
			       ? local_hex_string_custom (
			           (unsigned long) so->textsection->endaddr,
@


1.33
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d40 1
d794 2
d812 3
a814 4
  add_show_from_set
    (add_set_cmd ("solib-absolute-prefix", class_support, var_filename,
		  (char *) &solib_absolute_prefix,
		  "Set prefix for loading absolute shared library symbol files.\n\
d816 7
a822 6
		  &setlist),
     &showlist);
  add_show_from_set
    (add_set_cmd ("solib-search-path", class_support, var_string,
		  (char *) &solib_search_path,
		  "Set the search path for loading non-absolute shared library symbol files.\n\
d824 3
a826 3
		  &setlist),
     &showlist);

@


1.32
log
@Replace strsave() with xstrdup().
@
text
@d619 3
a621 2
      internal_error ("%s:%d: bfd_get_arch_size() returned unknown size %d",
		      __FILE__, __LINE__, arch_size);
@


1.31
log
@* solib.c (solib_open): If path is relative, look for it
literally.  This matches the behaviour of the GNU dynamic linker
more closely.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 98, 1999, 2000
d146 1
a146 1
    *found_pathname = strsave (temp_pathname);
@


1.30
log
@Replace free() with xfree().
@
text
@d88 1
a88 1
   * If path is absolute, look for it literally (unmodified).
d94 1
a94 1
   
d103 1
a103 1
  if (ROOTED_P (in_pathname))
d105 1
a105 1
      if (solib_absolute_prefix == NULL)
d109 1
a109 1
	  int  prefix_len = strlen (solib_absolute_prefix);
d112 2
a113 1
	  while (prefix_len > 0 && SLASH_P (solib_absolute_prefix[prefix_len - 1]))
d121 1
a122 1
	}
@


1.29
log
@* remote.c (remote_write_bytes): Add default case to switch
initializing ``todo''. Ditto for ``nr_bytes''.
* top.c (catch_errors): Always initialize ``val''.
* solib.c (info_sharedlibrary_command): Handle bfd_get_arch_size
returning an unknown size.
* gdbtypes.c (count_virtual_fns): Always initialize ``vfuncs''.
* breakpoint.c (break_at_finish_at_depth_command_1): Initialise
extra_args to NULL.
(break_at_finish_command_1): Ditto.
@
text
@d190 1
a190 1
  old_chain = make_cleanup (free, filename);
d273 1
a273 1
    free (so->sections);
d284 1
a284 1
    free (bfd_filename);
d288 1
a288 1
  free (so);
@


1.28
log
@	* solib.c (solib_open): Handle the case where
	solib_absolute_prefix is NULL.
@
text
@d616 5
@


1.27
log
@2000-11-20  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * solist.h: Declare new function solib_open.
        * solib.c (solib_open): New function.  Abstracts some of the
        code from solib_map_sections, for finding the binary solib file.
        (solib_map_sections): Call solib_open.
        * solib-svr4.c (enable_break): Call solib_open.
@
text
@d103 1
a103 2
  if (solib_absolute_prefix != NULL &&
      ROOTED_P (in_pathname))
d105 15
a119 11
      int  prefix_len = strlen (solib_absolute_prefix);

      /* Remove trailing slashes from absolute prefix.  */
      while (prefix_len > 0 && SLASH_P (solib_absolute_prefix[prefix_len - 1]))
	prefix_len--;

      /* Cat the prefixed pathname together.  */
      temp_pathname = alloca (prefix_len + strlen (in_pathname) + 1);
      strncpy (temp_pathname, solib_absolute_prefix, prefix_len);
      temp_pathname[prefix_len] = '\0';
      strcat (temp_pathname, in_pathname);
d121 1
d144 1
a144 1
  if (found_pathname != NULL)
@


1.26
log
@solib.c relocation improvements
@
text
@d69 79
a185 21
  if (solib_absolute_prefix && ROOTED_P (filename))
    /* Prefix shared libraries with absolute filenames with
       SOLIB_ABSOLUTE_PREFIX.  */
    {
      char *pfxed_fn;
      int pfx_len;

      pfx_len = strlen (solib_absolute_prefix);

      /* Remove trailing slashes.  */
      while (pfx_len > 0 && SLASH_P (solib_absolute_prefix[pfx_len - 1]))
	pfx_len--;

      pfxed_fn = xmalloc (pfx_len + strlen (filename) + 1);
      strcpy (pfxed_fn, solib_absolute_prefix);
      strcat (pfxed_fn, filename);
      free (filename);

      filename = pfxed_fn;
    }

d187 1
a188 14
  scratch_chan = -1;

  if (solib_search_path)
    scratch_chan = openp (solib_search_path,
			  1, filename, O_RDONLY, 0, &scratch_pathname);
  if (scratch_chan < 0)
    scratch_chan = openp (get_in_environ (inferior_environ, "PATH"),
			  1, filename, O_RDONLY, 0, &scratch_pathname);
  if (scratch_chan < 0)
    {
      scratch_chan = openp (get_in_environ
			    (inferior_environ, "LD_LIBRARY_PATH"),
			    1, filename, O_RDONLY, 0, &scratch_pathname);
    }
d193 1
a194 1

d202 1
d207 2
a208 2
  /* copy full path name into so_name, so that later symbol_file_add can find
     it */
@


1.25
log
@Reorganize solib.c.
@
text
@d183 1
a183 3
      p->addr += TARGET_SO_LM_ADDR (so);
      p->endaddr += TARGET_SO_LM_ADDR (so);
      so->lmend = max (p->endaddr, so->lmend);
a248 3
  CORE_ADDR lowest_addr = 0;
  int lowest_index;
  asection *lowest_sect = NULL;
a256 24
  /* Find the shared object's text segment.  */
  if (so->textsection)
    {
      lowest_addr = so->textsection->addr;
      lowest_sect = bfd_get_section_by_name (so->abfd, ".text");
      lowest_index = lowest_sect->index;
    }
  else if (so->abfd != NULL)
    {
      /* If we didn't find a mapped non zero sized .text section, set
         up lowest_addr so that the relocation in symbol_file_add does
         no harm.  */
      lowest_sect = bfd_get_section_by_name (so->abfd, ".text");
      if (lowest_sect == NULL)
	bfd_map_over_sections (so->abfd, find_lowest_section,
			       (PTR) &lowest_sect);
      if (lowest_sect)
	{
	  lowest_addr = bfd_section_vma (so->abfd, lowest_sect)
	    + TARGET_SO_LM_ADDR (so);
	  lowest_index = lowest_sect->index;
	}
    }

a259 2
  sap->other[lowest_index].addr = lowest_addr;

d582 5
a586 3
                             local_hex_string_custom (
			       (unsigned long) TARGET_SO_LM_ADDR (so),
	                       addr_fmt));
d588 5
a592 2
			 local_hex_string_custom ((unsigned long) so->lmend,
						  addr_fmt));
d617 1
a617 4
   a shared library.  Any address between the base mapping address
   and the first address beyond the end of the last mapping, is
   considered to be within the shared library address space, for
   our purposes.
d631 7
a637 2
      if (TARGET_SO_LM_ADDR (so) <= address && address < so->lmend)
	return (so->so_name);
@


1.24
log
@* solib.c (open_symbol_file_object): Update function signature to
match catch_errors function argument.
@
text
@d1 1
a1 1
/* Handle SunOS and SVR4 shared libraries for GDB, the GNU Debugger.
a21 1
#define _SYSCALL32	/* for Sparc64 cross Sparc32 */
a23 4
/* This file is only compilable if link.h is available. */

#ifdef HAVE_LINK_H

d25 1
a25 1
#include <signal.h>
a26 12
#include <sys/param.h>
#include <fcntl.h>

#ifndef SVR4_SHARED_LIBS
 /* SunOS shared libs need the nlist structure.  */
#include <a.out.h>
#else
#include "elf/external.h"
#endif

#include <link.h>

d41 1
a41 57
#define MAX_PATH_SIZE 512	/* FIXME: Should be dynamic */

/* On SVR4 systems, a list of symbols in the dynamic linker where
   GDB can try to place a breakpoint to monitor shared library
   events.

   If none of these symbols are found, or other errors occur, then
   SVR4 systems will fall back to using a symbol as the "startup
   mapping complete" breakpoint address.  */

#ifdef SVR4_SHARED_LIBS
static char *solib_break_names[] =
{
  "r_debug_state",
  "_r_debug_state",
  "_dl_debug_state",
  "rtld_db_dlactivity",
  NULL
};
#endif

#define BKPT_AT_SYMBOL 1

#if defined (BKPT_AT_SYMBOL) && defined (SVR4_SHARED_LIBS)
static char *bkpt_names[] =
{
#ifdef SOLIB_BKPT_NAME
  SOLIB_BKPT_NAME,		/* Prefer configured name if it exists. */
#endif
  "_start",
  "main",
  NULL
};
#endif

/* Symbols which are used to locate the base of the link map structures. */

#ifndef SVR4_SHARED_LIBS
static char *debug_base_symbols[] =
{
  "_DYNAMIC",
  "_DYNAMIC__MGC",
  NULL
};
#endif

static char *main_name_list[] =
{
  "main_$main",
  NULL
};

/* Function to extract an address from a solib structure.
   When GDB is configured for some 32-bit targets (e.g. Solaris 2.7
   sparc), BFD is configured to handle 64-bit targets, so CORE_ADDR is
   64 bits.  We have to extract only the significant bits of addresses
   to get the right address when accessing the core file BFD.  
d43 1
a43 9
   We'll use the BFD itself to determine the number of significant bits.  
   MVS, June 2000  */

static CORE_ADDR
solib_extract_address (void *memberp)
{
  return extract_address (memberp, 
			  bfd_get_arch_size (exec_bfd) / 8);
}
d45 2
a46 2
#define SOLIB_EXTRACT_ADDRESS(MEMBER) \
        solib_extract_address (&MEMBER)
a49 60
#ifndef SVR4_SHARED_LIBS

/* NOTE: converted the macros LM_ADDR, LM_NEXT, LM_NAME and
   IGNORE_FIRST_LINK_MAP_ENTRY into functions (see below).
   MVS, June 2000  */

static struct link_dynamic dynamic_copy;
static struct link_dynamic_2 ld_2_copy;
static struct ld_debug debug_copy;
static CORE_ADDR debug_addr;
static CORE_ADDR flag_addr;

#else /* SVR4_SHARED_LIBS */

static struct r_debug debug_copy;
#if defined (HAVE_STRUCT_LINK_MAP32)
static struct r_debug32 debug32_copy;	/* Sparc64 cross Sparc32 */
#endif

char shadow_contents[BREAKPOINT_MAX];	/* Stash old bkpt addr contents */

#endif /* !SVR4_SHARED_LIBS */

struct so_list
  {
    /* The following fields of the structure come directly from the
       dynamic linker's tables in the inferior, and are initialized by
       current_sos.  */

    struct so_list *next;	/* next structure in linked list */
    struct link_map lm;		/* copy of link map from inferior */
#if defined (HAVE_STRUCT_LINK_MAP32)
    struct link_map32 lm32;	/* copy of link map from 32-bit inferior */
#endif
    CORE_ADDR lmaddr;		/* addr in inferior lm was read from */

    /* Shared object file name, exactly as it appears in the
       inferior's link map.  This may be a relative path, or something
       which needs to be looked up in LD_LIBRARY_PATH, etc.  We use it
       to tell which entries in the inferior's dynamic linker's link
       map we've already loaded.  */
    char so_original_name[MAX_PATH_SIZE];

    /* shared object file name, expanded to something GDB can open */
    char so_name[MAX_PATH_SIZE];

    /* The following fields of the structure are built from
       information gathered from the shared object file itself, and
       are initialized when we actually add it to our symbol tables.  */

    bfd *abfd;
    CORE_ADDR lmend;		/* upper addr bound of mapped object */
    char symbols_loaded;	/* flag: symbols read in yet? */
    char from_tty;		/* flag: print msgs? */
    struct objfile *objfile;	/* objfile for loaded lib */
    struct section_table *sections;
    struct section_table *sections_end;
    struct section_table *textsection;
  };

a51 95
/* link map access functions */

#ifndef SVR4_SHARED_LIBS

static CORE_ADDR
LM_ADDR (struct so_list *so)
{
#if defined (HAVE_STRUCT_LINK_MAP32)
  if (bfd_get_arch_size (exec_bfd) == 32)
    return extract_address (&so->lm32.lm_addr, sizeof (so->lm32.lm_addr));
  else
#endif
    return extract_address (&so->lm.lm_addr, sizeof (so->lm.lm_addr));
}

static CORE_ADDR
LM_NEXT (struct so_list *so)
{
#if defined (HAVE_STRUCT_LINK_MAP32)
  if (bfd_get_arch_size (exec_bfd) == 32)
    return extract_address (&so->lm32.lm_next, sizeof (so->lm32.lm_next));
  else
#endif
    return extract_address (&so->lm.lm_next, sizeof (so->lm.lm_next));
}

static CORE_ADDR
LM_NAME (struct so_list *so)
{
#if defined (HAVE_STRUCT_LINK_MAP32)
  if (bfd_get_arch_size (exec_bfd) == 32)
    return extract_address (&so->lm32.lm_name, sizeof (so->lm32.lm_name));
  else
#endif
    return extract_address (&so->lm.lm_name, sizeof (so->lm.lm_name));
}

static int 
IGNORE_FIRST_LINK_MAP_ENTRY (struct so_list *so)
{
  return 0;
}

#else /* SVR4_SHARED_LIBS */

static CORE_ADDR
LM_ADDR (struct so_list *so)
{
#if defined (HAVE_STRUCT_LINK_MAP32)
  if (bfd_get_arch_size (exec_bfd) == 32)
    return extract_address (&so->lm32.l_addr, sizeof (so->lm32.l_addr));
  else
#endif
    return extract_address (&so->lm.l_addr, sizeof (so->lm.l_addr));
}

static CORE_ADDR
LM_NEXT (struct so_list *so)
{
#if defined (HAVE_STRUCT_LINK_MAP32)
  if (bfd_get_arch_size (exec_bfd) == 32)
    return extract_address (&so->lm32.l_next, sizeof (so->lm32.l_next));
  else
#endif
    return extract_address (&so->lm.l_next, sizeof (so->lm.l_next));
}

static CORE_ADDR
LM_NAME (struct so_list *so)
{
#if defined (HAVE_STRUCT_LINK_MAP32)
  if (bfd_get_arch_size (exec_bfd) == 32)
    return extract_address (&so->lm32.l_name, sizeof (so->lm32.l_name));
  else
#endif
    return extract_address (&so->lm.l_name, sizeof (so->lm.l_name));
}

static int
IGNORE_FIRST_LINK_MAP_ENTRY (struct so_list *so)
{
#if defined (HAVE_STRUCT_LINK_MAP32)
  if (bfd_get_arch_size (exec_bfd) == 32)
    return (solib_extract_address (&(so) -> lm32.l_prev) == 0);
  else
#endif
    return (solib_extract_address (&(so) -> lm.l_prev) == 0);
}

#endif /* !SVR4_SHARED_LIBS */


static CORE_ADDR debug_base;	/* Base of dynamic linker structures */
static CORE_ADDR breakpoint_addr;	/* Address where end bkpt is set */

a53 2
extern int fdmatch (int, int);	/* In libiberty */

a57 38
static int match_main (char *);

static void special_symbol_handling (void);

static void sharedlibrary_command (char *, int);

static int enable_break (void);

static void info_sharedlibrary_command (char *, int);

static int symbol_add_stub (PTR);

static CORE_ADDR first_link_map_member (void);

static CORE_ADDR locate_base (void);

static int solib_map_sections (PTR);

#ifdef SVR4_SHARED_LIBS

static CORE_ADDR elf_locate_base (void);

#else

static struct so_list *current_sos (void);
static void free_so (struct so_list *node);

static int disable_break (void);

static void allocate_rt_common_objfile (void);

static void
solib_add_common_symbols (CORE_ADDR);

#endif

void _initialize_solib (void);

d161 5
a165 647
  /* copy full path name into so_name, so that later symbol_file_add can find
     it */
  if (strlen (scratch_pathname) >= MAX_PATH_SIZE)
    error ("Full path name length of shared library exceeds MAX_PATH_SIZE in so_list structure.");
  strcpy (so->so_name, scratch_pathname);

  if (!bfd_check_format (abfd, bfd_object))
    {
      error ("\"%s\": not in executable format: %s.",
	     scratch_pathname, bfd_errmsg (bfd_get_error ()));
    }
  if (build_section_table (abfd, &so->sections, &so->sections_end))
    {
      error ("Can't find the file sections in `%s': %s",
	     bfd_get_filename (abfd), bfd_errmsg (bfd_get_error ()));
    }

  for (p = so->sections; p < so->sections_end; p++)
    {
      /* Relocate the section binding addresses as recorded in the shared
         object's file by the base address to which the object was actually
         mapped. */
      p->addr += LM_ADDR (so);
      p->endaddr += LM_ADDR (so);
      so->lmend = max (p->endaddr, so->lmend);
      if (STREQ (p->the_bfd_section->name, ".text"))
	{
	  so->textsection = p;
	}
    }

  /* Free the file names, close the file now.  */
  do_cleanups (old_chain);

  return (1);
}

#ifndef SVR4_SHARED_LIBS

/* Allocate the runtime common object file.  */

static void
allocate_rt_common_objfile (void)
{
  struct objfile *objfile;
  struct objfile *last_one;

  objfile = (struct objfile *) xmalloc (sizeof (struct objfile));
  memset (objfile, 0, sizeof (struct objfile));
  objfile->md = NULL;
  obstack_specify_allocation (&objfile->psymbol_cache.cache, 0, 0,
			      xmalloc, free);
  obstack_specify_allocation (&objfile->psymbol_obstack, 0, 0, xmalloc,
			      free);
  obstack_specify_allocation (&objfile->symbol_obstack, 0, 0, xmalloc,
			      free);
  obstack_specify_allocation (&objfile->type_obstack, 0, 0, xmalloc,
			      free);
  objfile->name = mstrsave (objfile->md, "rt_common");

  /* Add this file onto the tail of the linked list of other such files. */

  objfile->next = NULL;
  if (object_files == NULL)
    object_files = objfile;
  else
    {
      for (last_one = object_files;
	   last_one->next;
	   last_one = last_one->next);
      last_one->next = objfile;
    }

  rt_common_objfile = objfile;
}

/* Read all dynamically loaded common symbol definitions from the inferior
   and put them into the minimal symbol table for the runtime common
   objfile.  */

static void
solib_add_common_symbols (CORE_ADDR rtc_symp)
{
  struct rtc_symb inferior_rtc_symb;
  struct nlist inferior_rtc_nlist;
  int len;
  char *name;

  /* Remove any runtime common symbols from previous runs.  */

  if (rt_common_objfile != NULL && rt_common_objfile->minimal_symbol_count)
    {
      obstack_free (&rt_common_objfile->symbol_obstack, 0);
      obstack_specify_allocation (&rt_common_objfile->symbol_obstack, 0, 0,
				  xmalloc, free);
      rt_common_objfile->minimal_symbol_count = 0;
      rt_common_objfile->msymbols = NULL;
    }

  init_minimal_symbol_collection ();
  make_cleanup_discard_minimal_symbols ();

  while (rtc_symp)
    {
      read_memory (rtc_symp,
		   (char *) &inferior_rtc_symb,
		   sizeof (inferior_rtc_symb));
      read_memory (SOLIB_EXTRACT_ADDRESS (inferior_rtc_symb.rtc_sp),
		   (char *) &inferior_rtc_nlist,
		   sizeof (inferior_rtc_nlist));
      if (inferior_rtc_nlist.n_type == N_COMM)
	{
	  /* FIXME: The length of the symbol name is not available, but in the
	     current implementation the common symbol is allocated immediately
	     behind the name of the symbol. */
	  len = inferior_rtc_nlist.n_value - inferior_rtc_nlist.n_un.n_strx;

	  name = xmalloc (len);
	  read_memory (SOLIB_EXTRACT_ADDRESS (inferior_rtc_nlist.n_un.n_name),
		       name, len);

	  /* Allocate the runtime common objfile if necessary. */
	  if (rt_common_objfile == NULL)
	    allocate_rt_common_objfile ();

	  prim_record_minimal_symbol (name, inferior_rtc_nlist.n_value,
				      mst_bss, rt_common_objfile);
	  free (name);
	}
      rtc_symp = SOLIB_EXTRACT_ADDRESS (inferior_rtc_symb.rtc_next);
    }

  /* Install any minimal symbols that have been collected as the current
     minimal symbols for the runtime common objfile.  */

  install_minimal_symbols (rt_common_objfile);
}

#endif /* SVR4_SHARED_LIBS */


#ifdef SVR4_SHARED_LIBS

static CORE_ADDR bfd_lookup_symbol (bfd *, char *);

/*

   LOCAL FUNCTION

   bfd_lookup_symbol -- lookup the value for a specific symbol

   SYNOPSIS

   CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname)

   DESCRIPTION

   An expensive way to lookup the value of a single symbol for
   bfd's that are only temporary anyway.  This is used by the
   shared library support to find the address of the debugger
   interface structures in the shared library.

   Note that 0 is specifically allowed as an error return (no
   such symbol).
 */

static CORE_ADDR
bfd_lookup_symbol (bfd *abfd, char *symname)
{
  unsigned int storage_needed;
  asymbol *sym;
  asymbol **symbol_table;
  unsigned int number_of_symbols;
  unsigned int i;
  struct cleanup *back_to;
  CORE_ADDR symaddr = 0;

  storage_needed = bfd_get_symtab_upper_bound (abfd);

  if (storage_needed > 0)
    {
      symbol_table = (asymbol **) xmalloc (storage_needed);
      back_to = make_cleanup (free, (PTR) symbol_table);
      number_of_symbols = bfd_canonicalize_symtab (abfd, symbol_table);

      for (i = 0; i < number_of_symbols; i++)
	{
	  sym = *symbol_table++;
	  if (STREQ (sym->name, symname))
	    {
	      /* Bfd symbols are section relative. */
	      symaddr = sym->value + sym->section->vma;
	      break;
	    }
	}
      do_cleanups (back_to);
    }

  if (symaddr)
    return symaddr;

  /* On FreeBSD, the dynamic linker is stripped by default.  So we'll
     have to check the dynamic string table too.  */

  storage_needed = bfd_get_dynamic_symtab_upper_bound (abfd);

  if (storage_needed > 0)
    {
      symbol_table = (asymbol **) xmalloc (storage_needed);
      back_to = make_cleanup (free, (PTR) symbol_table);
      number_of_symbols = bfd_canonicalize_dynamic_symtab (abfd, symbol_table);

      for (i = 0; i < number_of_symbols; i++)
	{
	  sym = *symbol_table++;
	  if (STREQ (sym->name, symname))
	    {
	      /* Bfd symbols are section relative. */
	      symaddr = sym->value + sym->section->vma;
	      break;
	    }
	}
      do_cleanups (back_to);
    }

  return symaddr;
}

#ifdef HANDLE_SVR4_EXEC_EMULATORS

/*
   Solaris BCP (the part of Solaris which allows it to run SunOS4
   a.out files) throws in another wrinkle. Solaris does not fill
   in the usual a.out link map structures when running BCP programs,
   the only way to get at them is via groping around in the dynamic
   linker.
   The dynamic linker and it's structures are located in the shared
   C library, which gets run as the executable's "interpreter" by
   the kernel.

   Note that we can assume nothing about the process state at the time
   we need to find these structures.  We may be stopped on the first
   instruction of the interpreter (C shared library), the first
   instruction of the executable itself, or somewhere else entirely
   (if we attached to the process for example).
 */

static char *debug_base_symbols[] =
{
  "r_debug",			/* Solaris 2.3 */
  "_r_debug",			/* Solaris 2.1, 2.2 */
  NULL
};

static int look_for_base (int, CORE_ADDR);

/*

   LOCAL FUNCTION

   look_for_base -- examine file for each mapped address segment

   SYNOPSYS

   static int look_for_base (int fd, CORE_ADDR baseaddr)

   DESCRIPTION

   This function is passed to proc_iterate_over_mappings, which
   causes it to get called once for each mapped address space, with
   an open file descriptor for the file mapped to that space, and the
   base address of that mapped space.

   Our job is to find the debug base symbol in the file that this
   fd is open on, if it exists, and if so, initialize the dynamic
   linker structure base address debug_base.

   Note that this is a computationally expensive proposition, since
   we basically have to open a bfd on every call, so we specifically
   avoid opening the exec file.
 */

static int
look_for_base (int fd, CORE_ADDR baseaddr)
{
  bfd *interp_bfd;
  CORE_ADDR address = 0;
  char **symbolp;

  /* If the fd is -1, then there is no file that corresponds to this
     mapped memory segment, so skip it.  Also, if the fd corresponds
     to the exec file, skip it as well. */

  if (fd == -1
      || (exec_bfd != NULL
	  && fdmatch (fileno ((FILE *) (exec_bfd->iostream)), fd)))
    {
      return (0);
    }

  /* Try to open whatever random file this fd corresponds to.  Note that
     we have no way currently to find the filename.  Don't gripe about
     any problems we might have, just fail. */

  if ((interp_bfd = bfd_fdopenr ("unnamed", gnutarget, fd)) == NULL)
    {
      return (0);
    }
  if (!bfd_check_format (interp_bfd, bfd_object))
    {
      /* FIXME-leak: on failure, might not free all memory associated with
         interp_bfd.  */
      bfd_close (interp_bfd);
      return (0);
    }

  /* Now try to find our debug base symbol in this file, which we at
     least know to be a valid ELF executable or shared library. */

  for (symbolp = debug_base_symbols; *symbolp != NULL; symbolp++)
    {
      address = bfd_lookup_symbol (interp_bfd, *symbolp);
      if (address != 0)
	{
	  break;
	}
    }
  if (address == 0)
    {
      /* FIXME-leak: on failure, might not free all memory associated with
         interp_bfd.  */
      bfd_close (interp_bfd);
      return (0);
    }

  /* Eureka!  We found the symbol.  But now we may need to relocate it
     by the base address.  If the symbol's value is less than the base
     address of the shared library, then it hasn't yet been relocated
     by the dynamic linker, and we have to do it ourself.  FIXME: Note
     that we make the assumption that the first segment that corresponds
     to the shared library has the base address to which the library
     was relocated. */

  if (address < baseaddr)
    {
      address += baseaddr;
    }
  debug_base = address;
  /* FIXME-leak: on failure, might not free all memory associated with
     interp_bfd.  */
  bfd_close (interp_bfd);
  return (1);
}
#endif /* HANDLE_SVR4_EXEC_EMULATORS */

/*

   LOCAL FUNCTION

   elf_locate_base -- locate the base address of dynamic linker structs
   for SVR4 elf targets.

   SYNOPSIS

   CORE_ADDR elf_locate_base (void)

   DESCRIPTION

   For SVR4 elf targets the address of the dynamic linker's runtime
   structure is contained within the dynamic info section in the
   executable file.  The dynamic section is also mapped into the
   inferior address space.  Because the runtime loader fills in the
   real address before starting the inferior, we have to read in the
   dynamic info section from the inferior address space.
   If there are any errors while trying to find the address, we
   silently return 0, otherwise the found address is returned.

 */

static CORE_ADDR
elf_locate_base (void)
{
  sec_ptr dyninfo_sect;
  int dyninfo_sect_size;
  CORE_ADDR dyninfo_addr;
  char *buf;
  char *bufend;
  int arch_size;

  /* Find the start address of the .dynamic section.  */
  dyninfo_sect = bfd_get_section_by_name (exec_bfd, ".dynamic");
  if (dyninfo_sect == NULL)
    return 0;
  dyninfo_addr = bfd_section_vma (exec_bfd, dyninfo_sect);

  /* Read in .dynamic section, silently ignore errors.  */
  dyninfo_sect_size = bfd_section_size (exec_bfd, dyninfo_sect);
  buf = alloca (dyninfo_sect_size);
  if (target_read_memory (dyninfo_addr, buf, dyninfo_sect_size))
    return 0;

  /* Find the DT_DEBUG entry in the the .dynamic section.
     For mips elf we look for DT_MIPS_RLD_MAP, mips elf apparently has
     no DT_DEBUG entries.  */

  arch_size = bfd_get_arch_size (exec_bfd);
  if (arch_size == -1)	/* failure */
    return 0;

  if (arch_size == 32)
    { /* 32-bit elf */
      for (bufend = buf + dyninfo_sect_size;
	   buf < bufend;
	   buf += sizeof (Elf32_External_Dyn))
	{
	  Elf32_External_Dyn *x_dynp = (Elf32_External_Dyn *) buf;
	  long dyn_tag;
	  CORE_ADDR dyn_ptr;

	  dyn_tag = bfd_h_get_32 (exec_bfd, (bfd_byte *) x_dynp->d_tag);
	  if (dyn_tag == DT_NULL)
	    break;
	  else if (dyn_tag == DT_DEBUG)
	    {
	      dyn_ptr = bfd_h_get_32 (exec_bfd, 
				      (bfd_byte *) x_dynp->d_un.d_ptr);
	      return dyn_ptr;
	    }
#ifdef DT_MIPS_RLD_MAP
	  else if (dyn_tag == DT_MIPS_RLD_MAP)
	    {
	      char *pbuf;

	      pbuf = alloca (TARGET_PTR_BIT / HOST_CHAR_BIT);
	      /* DT_MIPS_RLD_MAP contains a pointer to the address
		 of the dynamic link structure.  */
	      dyn_ptr = bfd_h_get_32 (exec_bfd, 
				      (bfd_byte *) x_dynp->d_un.d_ptr);
	      if (target_read_memory (dyn_ptr, pbuf, sizeof (pbuf)))
		return 0;
	      return extract_unsigned_integer (pbuf, sizeof (pbuf));
	    }
#endif
	}
    }
  else /* 64-bit elf */
    {
      for (bufend = buf + dyninfo_sect_size;
	   buf < bufend;
	   buf += sizeof (Elf64_External_Dyn))
	{
	  Elf64_External_Dyn *x_dynp = (Elf64_External_Dyn *) buf;
	  long dyn_tag;
	  CORE_ADDR dyn_ptr;

	  dyn_tag = bfd_h_get_64 (exec_bfd, (bfd_byte *) x_dynp->d_tag);
	  if (dyn_tag == DT_NULL)
	    break;
	  else if (dyn_tag == DT_DEBUG)
	    {
	      dyn_ptr = bfd_h_get_64 (exec_bfd, 
				      (bfd_byte *) x_dynp->d_un.d_ptr);
	      return dyn_ptr;
	    }
	}
    }

  /* DT_DEBUG entry not found.  */
  return 0;
}

#endif /* SVR4_SHARED_LIBS */

/*

   LOCAL FUNCTION

   locate_base -- locate the base address of dynamic linker structs

   SYNOPSIS

   CORE_ADDR locate_base (void)

   DESCRIPTION

   For both the SunOS and SVR4 shared library implementations, if the
   inferior executable has been linked dynamically, there is a single
   address somewhere in the inferior's data space which is the key to
   locating all of the dynamic linker's runtime structures.  This
   address is the value of the debug base symbol.  The job of this
   function is to find and return that address, or to return 0 if there
   is no such address (the executable is statically linked for example).

   For SunOS, the job is almost trivial, since the dynamic linker and
   all of it's structures are statically linked to the executable at
   link time.  Thus the symbol for the address we are looking for has
   already been added to the minimal symbol table for the executable's
   objfile at the time the symbol file's symbols were read, and all we
   have to do is look it up there.  Note that we explicitly do NOT want
   to find the copies in the shared library.

   The SVR4 version is a bit more complicated because the address
   is contained somewhere in the dynamic info section.  We have to go
   to a lot more work to discover the address of the debug base symbol.
   Because of this complexity, we cache the value we find and return that
   value on subsequent invocations.  Note there is no copy in the
   executable symbol tables.

 */

static CORE_ADDR
locate_base (void)
{

#ifndef SVR4_SHARED_LIBS

  struct minimal_symbol *msymbol;
  CORE_ADDR address = 0;
  char **symbolp;

  /* For SunOS, we want to limit the search for the debug base symbol to the
     executable being debugged, since there is a duplicate named symbol in the
     shared library.  We don't want the shared library versions. */

  for (symbolp = debug_base_symbols; *symbolp != NULL; symbolp++)
    {
      msymbol = lookup_minimal_symbol (*symbolp, NULL, symfile_objfile);
      if ((msymbol != NULL) && (SYMBOL_VALUE_ADDRESS (msymbol) != 0))
	{
	  address = SYMBOL_VALUE_ADDRESS (msymbol);
	  return (address);
	}
    }
  return (0);

#else /* SVR4_SHARED_LIBS */

  /* Check to see if we have a currently valid address, and if so, avoid
     doing all this work again and just return the cached address.  If
     we have no cached address, try to locate it in the dynamic info
     section for ELF executables.  */

  if (debug_base == 0)
    {
      if (exec_bfd != NULL
	  && bfd_get_flavour (exec_bfd) == bfd_target_elf_flavour)
	debug_base = elf_locate_base ();
#ifdef HANDLE_SVR4_EXEC_EMULATORS
      /* Try it the hard way for emulated executables.  */
      else if (inferior_pid != 0 && target_has_execution)
	proc_iterate_over_mappings (look_for_base);
#endif
    }
  return (debug_base);

#endif /* !SVR4_SHARED_LIBS */

}

/*

   LOCAL FUNCTION

   first_link_map_member -- locate first member in dynamic linker's map

   SYNOPSIS

   static CORE_ADDR first_link_map_member (void)

   DESCRIPTION

   Find the first element in the inferior's dynamic link map, and
   return its address in the inferior.  This function doesn't copy the
   link map entry itself into our address space; current_sos actually
   does the reading.  */

static CORE_ADDR
first_link_map_member (void)
{
  CORE_ADDR lm = 0;

#ifndef SVR4_SHARED_LIBS

  read_memory (debug_base, (char *) &dynamic_copy, sizeof (dynamic_copy));
  if (dynamic_copy.ld_version >= 2)
    {
      /* It is a version that we can deal with, so read in the secondary
         structure and find the address of the link map list from it. */
      read_memory (SOLIB_EXTRACT_ADDRESS (dynamic_copy.ld_un.ld_2),
		   (char *) &ld_2_copy, sizeof (struct link_dynamic_2));
      lm = SOLIB_EXTRACT_ADDRESS (ld_2_copy.ld_loaded);
    }

#else /* SVR4_SHARED_LIBS */
#if defined (HAVE_STRUCT_LINK_MAP32)
  if (bfd_get_arch_size (exec_bfd) == 32)
    {
      read_memory (debug_base, (char *) &debug32_copy, 
		   sizeof (struct r_debug32));
      lm = SOLIB_EXTRACT_ADDRESS (debug32_copy.r_map);
    }
  else
#endif
    {
      read_memory (debug_base, (char *) &debug_copy, 
		   sizeof (struct r_debug));
      lm = SOLIB_EXTRACT_ADDRESS (debug_copy.r_map);
    }
  /* FIXME:  Perhaps we should validate the info somehow, perhaps by
     checking r_version for a known version number, or r_state for
     RT_CONSISTENT. */

#endif /* !SVR4_SHARED_LIBS */

  return (lm);
}

#ifdef SVR4_SHARED_LIBS
/*

  LOCAL FUNCTION

  open_symbol_file_object

  SYNOPSIS

  int open_symbol_file_object (void *from_ttyp)

  DESCRIPTION

  If no open symbol file, attempt to locate and open the main symbol
  file.  On SVR4 systems, this is the first link map entry.  If its
  name is here, we can open it.  Useful when attaching to a process
  without first loading its symbol file.

  If FROM_TTYP dereferences to a non-zero integer, allow messages to
  be printed.  This parameter is a pointer rather than an int because
  open_symbol_file_object() is called via catch_errors() and
  catch_errors() requires a pointer argument. */

static int
open_symbol_file_object (void *from_ttyp)
{
  CORE_ADDR lm;
  char *filename;
  int errcode;
  int from_tty = *(int *)from_ttyp;
d167 1
a167 13
  if (symfile_objfile)
    if (!query ("Attempt to reload symbols from process? "))
      return 0;

  if ((debug_base = locate_base ()) == 0)
    return 0;	/* failed somehow... */

  /* First link map member should be the executable.  */
  if ((lm = first_link_map_member ()) == 0)
    return 0;	/* failed somehow... */

#if defined (HAVE_STRUCT_LINK_MAP32)
  if (bfd_get_arch_size (exec_bfd) == 32)
d169 2
a170 10
      struct link_map32 lmcopy;
      /* Read from target memory to GDB.  */
      read_memory (lm, (void *) &lmcopy, sizeof (lmcopy));

      if (lmcopy.l_name == 0)
	return 0;	/* no filename.  */

      /* Now fetch the filename from target memory.  */
      target_read_string (SOLIB_EXTRACT_ADDRESS (lmcopy.l_name), 
			  &filename, MAX_PATH_SIZE - 1, &errcode);
d172 1
a172 2
  else
#endif /* HAVE_STRUCT_LINK_MAP32 */
d174 2
a175 10
      struct link_map lmcopy;
      /* Read from target memory to GDB.  */
      read_memory (lm, (void *) &lmcopy, sizeof (lmcopy));

      if (lmcopy.l_name == 0)
	return 0;	/* no filename.  */

      /* Now fetch the filename from target memory.  */
      target_read_string (SOLIB_EXTRACT_ADDRESS (lmcopy.l_name), &filename, 
			  MAX_PATH_SIZE - 1, &errcode);
d178 1
a178 1
  if (errcode)
d180 10
a189 3
      warning ("failed to read exec filename from attached file: %s",
	       safe_strerror (errcode));
      return 0;
d192 2
a193 3
  make_cleanup (free, filename);
  /* Have a pathname: read the symbol file.  */
  symbol_file_command (filename, from_tty);
d195 1
a195 1
  return 1;
a196 2
#endif /* SVR4_SHARED_LIBS */

d219 1
a219 1
static void
d238 2
a243 126
/* On some systems, the only way to recognize the link map entry for
   the main executable file is by looking at its name.  Return
   non-zero iff SONAME matches one of the known main executable names.  */

static int
match_main (char *soname)
{
  char **mainp;

  for (mainp = main_name_list; *mainp != NULL; mainp++)
    {
      if (strcmp (soname, *mainp) == 0)
	return (1);
    }

  return (0);
}


/* LOCAL FUNCTION

   current_sos -- build a list of currently loaded shared objects

   SYNOPSIS

   struct so_list *current_sos ()

   DESCRIPTION

   Build a list of `struct so_list' objects describing the shared
   objects currently loaded in the inferior.  This list does not
   include an entry for the main executable file.

   Note that we only gather information directly available from the
   inferior --- we don't examine any of the shared library files
   themselves.  The declaration of `struct so_list' says which fields
   we provide values for.  */

static struct so_list *
current_sos (void)
{
  CORE_ADDR lm;
  struct so_list *head = 0;
  struct so_list **link_ptr = &head;

  /* Make sure we've looked up the inferior's dynamic linker's base
     structure.  */
  if (! debug_base)
    {
      debug_base = locate_base ();

      /* If we can't find the dynamic linker's base structure, this
	 must not be a dynamically linked executable.  Hmm.  */
      if (! debug_base)
	return 0;
    }

  /* Walk the inferior's link map list, and build our list of
     `struct so_list' nodes.  */
  lm = first_link_map_member ();  
  while (lm)
    {
      struct so_list *new
	= (struct so_list *) xmalloc (sizeof (struct so_list));
      struct cleanup *old_chain = make_cleanup (free, new);
      memset (new, 0, sizeof (*new));

      new->lmaddr = lm;

#if defined (HAVE_STRUCT_LINK_MAP32)
      if (bfd_get_arch_size (exec_bfd) == 32)
	read_memory (lm, (char *) &(new->lm32), sizeof (struct link_map32));
      else
#endif
	read_memory (lm, (char *) &(new->lm), sizeof (struct link_map));

      lm = LM_NEXT (new);

      /* For SVR4 versions, the first entry in the link map is for the
         inferior executable, so we must ignore it.  For some versions of
         SVR4, it has no name.  For others (Solaris 2.3 for example), it
         does have a name, so we can no longer use a missing name to
         decide when to ignore it. */
      if (IGNORE_FIRST_LINK_MAP_ENTRY (new))
	free_so (new);
      else
	{
	  int errcode;
	  char *buffer;

	  /* Extract this shared object's name.  */
	  target_read_string (LM_NAME (new), &buffer,
			      MAX_PATH_SIZE - 1, &errcode);
	  if (errcode != 0)
	    {
	      warning ("current_sos: Can't read pathname for load map: %s\n",
		       safe_strerror (errcode));
	    }
	  else
	    {
	      strncpy (new->so_name, buffer, MAX_PATH_SIZE - 1);
	      new->so_name[MAX_PATH_SIZE - 1] = '\0';
	      free (buffer);
	      strcpy (new->so_original_name, new->so_name);
	    }

	  /* If this entry has no name, or its name matches the name
	     for the main executable, don't include it in the list.  */
	  if (! new->so_name[0]
	      || match_main (new->so_name))
	    free_so (new);
	  else
	    {
	      new->next = 0;
	      *link_ptr = new;
	      link_ptr = &new->next;
	    }
	}

      discard_cleanups (old_chain);
    }

  return head;
}


d281 1
a281 1
	    + LM_ADDR (so);
d331 1
a331 1
  struct so_list *inferior = current_sos ();
a333 1
#ifdef SVR4_SHARED_LIBS
d339 1
a339 1
    catch_errors (open_symbol_file_object, (PTR) &from_tty, 
a342 2
#endif SVR4_SHARED_LIBS

d548 1
a548 1
	special_symbol_handling ();
d613 3
a615 2
		      local_hex_string_custom ((unsigned long) LM_ADDR (so),
					       addr_fmt));
d660 1
a660 1
      if (LM_ADDR (so) <= address && address < so->lmend)
d703 1
a703 1
  debug_base = 0;
d713 1
a713 295
#ifdef SVR4_SHARED_LIBS

/* Return 1 if PC lies in the dynamic symbol resolution code of the
   SVR4 run time loader.  */

static CORE_ADDR interp_text_sect_low;
static CORE_ADDR interp_text_sect_high;
static CORE_ADDR interp_plt_sect_low;
static CORE_ADDR interp_plt_sect_high;

int
in_svr4_dynsym_resolve_code (CORE_ADDR pc)
{
  return ((pc >= interp_text_sect_low && pc < interp_text_sect_high)
	  || (pc >= interp_plt_sect_low && pc < interp_plt_sect_high)
	  || in_plt_section (pc, NULL));
}
#endif

/*

   LOCAL FUNCTION

   disable_break -- remove the "mapping changed" breakpoint

   SYNOPSIS

   static int disable_break ()

   DESCRIPTION

   Removes the breakpoint that gets hit when the dynamic linker
   completes a mapping change.

 */

#ifndef SVR4_SHARED_LIBS

static int
disable_break (void)
{
  int status = 1;

#ifndef SVR4_SHARED_LIBS

  int in_debugger = 0;

  /* Read the debugger structure from the inferior to retrieve the
     address of the breakpoint and the original contents of the
     breakpoint address.  Remove the breakpoint by writing the original
     contents back. */

  read_memory (debug_addr, (char *) &debug_copy, sizeof (debug_copy));

  /* Set `in_debugger' to zero now. */

  write_memory (flag_addr, (char *) &in_debugger, sizeof (in_debugger));

  breakpoint_addr = SOLIB_EXTRACT_ADDRESS (debug_copy.ldd_bp_addr);
  write_memory (breakpoint_addr, (char *) &debug_copy.ldd_bp_inst,
		sizeof (debug_copy.ldd_bp_inst));

#else /* SVR4_SHARED_LIBS */

  /* Note that breakpoint address and original contents are in our address
     space, so we just need to write the original contents back. */

  if (memory_remove_breakpoint (breakpoint_addr, shadow_contents) != 0)
    {
      status = 0;
    }

#endif /* !SVR4_SHARED_LIBS */

  /* For the SVR4 version, we always know the breakpoint address.  For the
     SunOS version we don't know it until the above code is executed.
     Grumble if we are stopped anywhere besides the breakpoint address. */

  if (stop_pc != breakpoint_addr)
    {
      warning ("stopped at unknown breakpoint while handling shared libraries");
    }

  return (status);
}

#endif /* #ifdef SVR4_SHARED_LIBS */

/*

   LOCAL FUNCTION

   enable_break -- arrange for dynamic linker to hit breakpoint

   SYNOPSIS

   int enable_break (void)

   DESCRIPTION

   Both the SunOS and the SVR4 dynamic linkers have, as part of their
   debugger interface, support for arranging for the inferior to hit
   a breakpoint after mapping in the shared libraries.  This function
   enables that breakpoint.

   For SunOS, there is a special flag location (in_debugger) which we
   set to 1.  When the dynamic linker sees this flag set, it will set
   a breakpoint at a location known only to itself, after saving the
   original contents of that place and the breakpoint address itself,
   in it's own internal structures.  When we resume the inferior, it
   will eventually take a SIGTRAP when it runs into the breakpoint.
   We handle this (in a different place) by restoring the contents of
   the breakpointed location (which is only known after it stops),
   chasing around to locate the shared libraries that have been
   loaded, then resuming.

   For SVR4, the debugger interface structure contains a member (r_brk)
   which is statically initialized at the time the shared library is
   built, to the offset of a function (_r_debug_state) which is guaran-
   teed to be called once before mapping in a library, and again when
   the mapping is complete.  At the time we are examining this member,
   it contains only the unrelocated offset of the function, so we have
   to do our own relocation.  Later, when the dynamic linker actually
   runs, it relocates r_brk to be the actual address of _r_debug_state().

   The debugger interface structure also contains an enumeration which
   is set to either RT_ADD or RT_DELETE prior to changing the mapping,
   depending upon whether or not the library is being mapped or unmapped,
   and then set to RT_CONSISTENT after the library is mapped/unmapped.
 */

static int
enable_break (void)
{
  int success = 0;

#ifndef SVR4_SHARED_LIBS

  int j;
  int in_debugger;

  /* Get link_dynamic structure */

  j = target_read_memory (debug_base, (char *) &dynamic_copy,
			  sizeof (dynamic_copy));
  if (j)
    {
      /* unreadable */
      return (0);
    }

  /* Calc address of debugger interface structure */

  debug_addr = SOLIB_EXTRACT_ADDRESS (dynamic_copy.ldd);

  /* Calc address of `in_debugger' member of debugger interface structure */

  flag_addr = debug_addr + (CORE_ADDR) ((char *) &debug_copy.ldd_in_debugger -
					(char *) &debug_copy);

  /* Write a value of 1 to this member.  */

  in_debugger = 1;
  write_memory (flag_addr, (char *) &in_debugger, sizeof (in_debugger));
  success = 1;

#else /* SVR4_SHARED_LIBS */

#ifdef BKPT_AT_SYMBOL

  struct minimal_symbol *msymbol;
  char **bkpt_namep;
  asection *interp_sect;

  /* First, remove all the solib event breakpoints.  Their addresses
     may have changed since the last time we ran the program.  */
  remove_solib_event_breakpoints ();

#ifdef SVR4_SHARED_LIBS
  interp_text_sect_low = interp_text_sect_high = 0;
  interp_plt_sect_low = interp_plt_sect_high = 0;

  /* Find the .interp section; if not found, warn the user and drop
     into the old breakpoint at symbol code.  */
  interp_sect = bfd_get_section_by_name (exec_bfd, ".interp");
  if (interp_sect)
    {
      unsigned int interp_sect_size;
      char *buf;
      CORE_ADDR load_addr;
      bfd *tmp_bfd;
      CORE_ADDR sym_addr = 0;

      /* Read the contents of the .interp section into a local buffer;
         the contents specify the dynamic linker this program uses.  */
      interp_sect_size = bfd_section_size (exec_bfd, interp_sect);
      buf = alloca (interp_sect_size);
      bfd_get_section_contents (exec_bfd, interp_sect,
				buf, 0, interp_sect_size);

      /* Now we need to figure out where the dynamic linker was
         loaded so that we can load its symbols and place a breakpoint
         in the dynamic linker itself.

         This address is stored on the stack.  However, I've been unable
         to find any magic formula to find it for Solaris (appears to
         be trivial on GNU/Linux).  Therefore, we have to try an alternate
         mechanism to find the dynamic linker's base address.  */
      tmp_bfd = bfd_openr (buf, gnutarget);
      if (tmp_bfd == NULL)
	goto bkpt_at_symbol;

      /* Make sure the dynamic linker's really a useful object.  */
      if (!bfd_check_format (tmp_bfd, bfd_object))
	{
	  warning ("Unable to grok dynamic linker %s as an object file", buf);
	  bfd_close (tmp_bfd);
	  goto bkpt_at_symbol;
	}

      /* We find the dynamic linker's base address by examining the
         current pc (which point at the entry point for the dynamic
         linker) and subtracting the offset of the entry point.  */
      load_addr = read_pc () - tmp_bfd->start_address;

      /* Record the relocated start and end address of the dynamic linker
         text and plt section for in_svr4_dynsym_resolve_code.  */
      interp_sect = bfd_get_section_by_name (tmp_bfd, ".text");
      if (interp_sect)
	{
	  interp_text_sect_low =
	    bfd_section_vma (tmp_bfd, interp_sect) + load_addr;
	  interp_text_sect_high =
	    interp_text_sect_low + bfd_section_size (tmp_bfd, interp_sect);
	}
      interp_sect = bfd_get_section_by_name (tmp_bfd, ".plt");
      if (interp_sect)
	{
	  interp_plt_sect_low =
	    bfd_section_vma (tmp_bfd, interp_sect) + load_addr;
	  interp_plt_sect_high =
	    interp_plt_sect_low + bfd_section_size (tmp_bfd, interp_sect);
	}

      /* Now try to set a breakpoint in the dynamic linker.  */
      for (bkpt_namep = solib_break_names; *bkpt_namep != NULL; bkpt_namep++)
	{
	  sym_addr = bfd_lookup_symbol (tmp_bfd, *bkpt_namep);
	  if (sym_addr != 0)
	    break;
	}

      /* We're done with the temporary bfd.  */
      bfd_close (tmp_bfd);

      if (sym_addr != 0)
	{
	  create_solib_event_breakpoint (load_addr + sym_addr);
	  return 1;
	}

      /* For whatever reason we couldn't set a breakpoint in the dynamic
         linker.  Warn and drop into the old code.  */
    bkpt_at_symbol:
      warning ("Unable to find dynamic linker breakpoint function.\nGDB will be unable to debug shared library initializers\nand track explicitly loaded dynamic code.");
    }
#endif

  /* Scan through the list of symbols, trying to look up the symbol and
     set a breakpoint there.  Terminate loop when we/if we succeed. */

  breakpoint_addr = 0;
  for (bkpt_namep = bkpt_names; *bkpt_namep != NULL; bkpt_namep++)
    {
      msymbol = lookup_minimal_symbol (*bkpt_namep, NULL, symfile_objfile);
      if ((msymbol != NULL) && (SYMBOL_VALUE_ADDRESS (msymbol) != 0))
	{
	  create_solib_event_breakpoint (SYMBOL_VALUE_ADDRESS (msymbol));
	  return 1;
	}
    }

  /* Nothing good happened.  */
  success = 0;

#endif /* BKPT_AT_SYMBOL */

#endif /* !SVR4_SHARED_LIBS */

  return (success);
}

/*

   GLOBAL FUNCTION
d726 1
a726 36
   SOLIB_CREATE_INFERIOR_HOOK.

   For SunOS executables, this first instruction is typically the
   one at "_start", or a similar text label, regardless of whether
   the executable is statically or dynamically linked.  The runtime
   startup code takes care of dynamically linking in any shared
   libraries, once gdb allows the inferior to continue.

   For SVR4 executables, this first instruction is either the first
   instruction in the dynamic linker (for dynamically linked
   executables) or the instruction at "start" for statically linked
   executables.  For dynamically linked executables, the system
   first exec's /lib/libc.so.N, which contains the dynamic linker,
   and starts it running.  The dynamic linker maps in any needed
   shared libraries, maps in the actual user executable, and then
   jumps to "start" in the user executable.

   For both SunOS shared libraries, and SVR4 shared libraries, we
   can arrange to cooperate with the dynamic linker to discover the
   names of shared libraries that are dynamically linked, and the
   base addresses to which they are linked.

   This function is responsible for discovering those names and
   addresses, and saving sufficient information about them to allow
   their symbols to be read at a later time.

   FIXME

   Between enable_break() and disable_break(), this code does not
   properly handle hitting breakpoints which the user might have
   set in the startup code or in the dynamic linker itself.  Proper
   handling will probably have to wait until the implementation is
   changed to use the "breakpoint handler function" method.

   Also, what if child has exit()ed?  Must exit loop somehow.
 */
d731 1
a731 126
  /* If we are using the BKPT_AT_SYMBOL code, then we don't need the base
     yet.  In fact, in the case of a SunOS4 executable being run on
     Solaris, we can't get it yet.  current_sos will get it when it needs
     it.  */
#if !(defined (SVR4_SHARED_LIBS) && defined (BKPT_AT_SYMBOL))
  if ((debug_base = locate_base ()) == 0)
    {
      /* Can't find the symbol or the executable is statically linked. */
      return;
    }
#endif

  if (!enable_break ())
    {
      warning ("shared library handler failed to enable breakpoint");
      return;
    }

#if !defined(SVR4_SHARED_LIBS) || defined(_SCO_DS)
  /* SCO and SunOS need the loop below, other systems should be using the
     special shared library breakpoints and the shared library breakpoint
     service routine.

     Now run the target.  It will eventually hit the breakpoint, at
     which point all of the libraries will have been mapped in and we
     can go groveling around in the dynamic linker structures to find
     out what we need to know about them. */

  clear_proceed_status ();
  stop_soon_quietly = 1;
  stop_signal = TARGET_SIGNAL_0;
  do
    {
      target_resume (-1, 0, stop_signal);
      wait_for_inferior ();
    }
  while (stop_signal != TARGET_SIGNAL_TRAP);
  stop_soon_quietly = 0;

#if !defined(_SCO_DS)
  /* We are now either at the "mapping complete" breakpoint (or somewhere
     else, a condition we aren't prepared to deal with anyway), so adjust
     the PC as necessary after a breakpoint, disable the breakpoint, and
     add any shared libraries that were mapped in. */

  if (DECR_PC_AFTER_BREAK)
    {
      stop_pc -= DECR_PC_AFTER_BREAK;
      write_register (PC_REGNUM, stop_pc);
    }

  if (!disable_break ())
    {
      warning ("shared library handler failed to disable breakpoint");
    }

  if (auto_solib_add)
    solib_add ((char *) 0, 0, (struct target_ops *) 0);
#endif /* ! _SCO_DS */
#endif
}

/*

   LOCAL FUNCTION

   special_symbol_handling -- additional shared library symbol handling

   SYNOPSIS

   void special_symbol_handling ()

   DESCRIPTION

   Once the symbols from a shared object have been loaded in the usual
   way, we are called to do any system specific symbol handling that 
   is needed.

   For SunOS4, this consists of grunging around in the dynamic
   linkers structures to find symbol definitions for "common" symbols
   and adding them to the minimal symbol table for the runtime common
   objfile.

 */

static void
special_symbol_handling (void)
{
#ifndef SVR4_SHARED_LIBS
  int j;

  if (debug_addr == 0)
    {
      /* Get link_dynamic structure */

      j = target_read_memory (debug_base, (char *) &dynamic_copy,
			      sizeof (dynamic_copy));
      if (j)
	{
	  /* unreadable */
	  return;
	}

      /* Calc address of debugger interface structure */
      /* FIXME, this needs work for cross-debugging of core files
         (byteorder, size, alignment, etc).  */

      debug_addr = SOLIB_EXTRACT_ADDRESS (dynamic_copy.ldd);
    }

  /* Read the debugger structure from the inferior, just to make sure
     we have a current copy. */

  j = target_read_memory (debug_addr, (char *) &debug_copy,
			  sizeof (debug_copy));
  if (j)
    return;			/* unreadable */

  /* Get common symbol definitions for the loaded object. */

  if (debug_copy.ldd_cp)
    {
      solib_add_common_symbols (SOLIB_EXTRACT_ADDRESS (debug_copy.ldd_cp));
    }

#endif /* !SVR4_SHARED_LIBS */
a755 1
#endif /* HAVE_LINK_H */
a759 2
#ifdef HAVE_LINK_H

a790 1
#endif /* HAVE_LINK_H */
@


1.23
log
@Protoization.
@
text
@d1063 1
a1063 1
  void open_symbol_file_object (int *from_tty)
d1078 1
a1078 1
open_symbol_file_object (int *from_ttyp)
d1083 1
d1134 1
a1134 1
  symbol_file_command (filename, *from_ttyp);
@


1.22
log
@Rename bfd_elf_get_arch_size to bfd_get_arch_size().
@
text
@d198 1
a198 2
LM_ADDR (so)
     struct so_list *so;
d209 1
a209 2
LM_NEXT (so)
     struct so_list *so;
d220 1
a220 2
LM_NAME (so)
     struct so_list *so;
d231 1
a231 2
IGNORE_FIRST_LINK_MAP_ENTRY (so)
     struct so_list *so;
d239 1
a239 2
LM_ADDR (so)
     struct so_list *so;
d250 1
a250 2
LM_NEXT (so)
     struct so_list *so;
d261 1
a261 2
LM_NAME (so)
     struct so_list *so;
d272 1
a272 2
IGNORE_FIRST_LINK_MAP_ENTRY (so)
     struct so_list *so;
d1063 1
a1063 1
  void open_symbol_file_object (int from_tty)
d1072 4
a1075 1
 */
d1078 1
a1078 2
open_symbol_file_object (from_ttyp)
     int *from_ttyp;	/* sneak past catch_errors */
@


1.21
log
@2000-08-29  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * valops.c (value_cast): Indentation fix-up.
        * acconfig.h (HAVE_PRGREGSET32_T, HAVE_PRFPREGSET32_T,
        HAVE_STRUCT_LINK_MAP32): New configure macros.
        * config.in: Ditto.
        * configure.in: Test for the above new macros.
        * breakpoint.c: Update copyright date.
        * core-sol2.c: Include v9/sys/privregs.h directly to
        work around a bug in Sun's Solaris 8 header files.
        (fetch_core_registers): Use the above new configure macros to
        handle cross-debugging of 32-bit core files on a 64-bit host.
        * sol-thread.c (ps_pdmodel) New function.
        (rw_common): For debugging of 32-bit apps on a 64-bit host,
        truncate addresses to 32 bits.
        * solib.c (solib_extract_address): Functionize.  Make 32/64 aware.
        (LM_ADDR, LM_NEXT, LM_NAME): Ditto.
        (IGNORE_FIRST_LINK_MAP): Ditto.
        (first_link_map_member): Make 32/64 aware.
        (open_symbol_file_object): Ditto.
        (current_sos): Ditto.
@
text
@d123 1
a123 1
			  bfd_elf_get_arch_size (exec_bfd) / 8);
d202 1
a202 1
  if (bfd_elf_get_arch_size (exec_bfd) == 32)
d214 1
a214 1
  if (bfd_elf_get_arch_size (exec_bfd) == 32)
d226 1
a226 1
  if (bfd_elf_get_arch_size (exec_bfd) == 32)
d247 1
a247 1
  if (bfd_elf_get_arch_size (exec_bfd) == 32)
d259 1
a259 1
  if (bfd_elf_get_arch_size (exec_bfd) == 32)
d271 1
a271 1
  if (bfd_elf_get_arch_size (exec_bfd) == 32)
d283 1
a283 1
  if (bfd_elf_get_arch_size (exec_bfd) == 32)
d1040 1
a1040 1
  if (bfd_elf_get_arch_size (exec_bfd) == 32)
d1102 1
a1102 1
  if (bfd_elf_get_arch_size (exec_bfd) == 32)
d1260 1
a1260 1
      if (bfd_elf_get_arch_size (exec_bfd) == 32)
@


1.20
log
@2000-08-09  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * blockframe.c (sigtramp_saved_pc): Use dynamic allocation,
        since TARGET_PTR_BIT is no longer a constant (MULTI_ARCH).
        * irix4-nat.c (get_longjmp_target): Ditto.
        * irix5-nat.c (get_longjmp_target): Ditto.
        * jv-valprint.c (java_value_print): Ditto.
        * m3-nat.c (get_cprocs):            Ditto.
        * m68k-tdep.c (get_longjmp_target): Ditto.
        * mips-nat.c  (get_longjmp_target): Ditto.
        * mipsv4-nat.c(get_longjmp_target): Ditto.
        * pa64solib.c (read_dynamic_info):  Ditto.
        * solib.c (elf_locate_base):        Ditto.
@
text
@d22 1
a22 1

d110 1
a110 3
/* local data declarations */

/* Macro to extract an address from a solib structure.
d114 1
a114 1
   to get the right address when accessing the core file BFD.  */
d116 14
a129 2
#define SOLIB_EXTRACT_ADDRESS(member) \
  extract_address (&member, sizeof (member))
d133 4
a136 5
#define LM_ADDR(so) (SOLIB_EXTRACT_ADDRESS ((so) -> lm.lm_addr))
#define LM_NEXT(so) (SOLIB_EXTRACT_ADDRESS ((so) -> lm.lm_next))
#define LM_NAME(so) (SOLIB_EXTRACT_ADDRESS ((so) -> lm.lm_name))
/* Test for first link map entry; first entry is a shared library. */
#define IGNORE_FIRST_LINK_MAP_ENTRY(so) (0)
a144 6
#define LM_ADDR(so) (SOLIB_EXTRACT_ADDRESS ((so) -> lm.l_addr))
#define LM_NEXT(so) (SOLIB_EXTRACT_ADDRESS ((so) -> lm.l_next))
#define LM_NAME(so) (SOLIB_EXTRACT_ADDRESS ((so) -> lm.l_name))
/* Test for first link map entry; first entry is the exec-file. */
#define IGNORE_FIRST_LINK_MAP_ENTRY(so) \
  (SOLIB_EXTRACT_ADDRESS ((so) -> lm.l_prev) == 0)
d146 4
d162 3
d192 101
d1039 14
a1052 2

  read_memory (debug_base, (char *) &debug_copy, sizeof (struct r_debug));
a1055 1
  lm = SOLIB_EXTRACT_ADDRESS (debug_copy.r_map);
a1086 1
  struct link_map lmcopy;
d1101 28
a1128 5
  /* Read from target memory to GDB.  */
  read_memory (lm, (void *) &lmcopy, sizeof (lmcopy));

  if (lmcopy.l_name == 0)
    return 0;	/* no filename.  */
a1129 3
  /* Now fetch the filename from target memory.  */
  target_read_string (SOLIB_EXTRACT_ADDRESS (lmcopy.l_name), &filename, 
		      MAX_PATH_SIZE - 1, &errcode);
d1258 7
a1264 1
      read_memory (lm, (char *) &(new->lm), sizeof (struct link_map));
@


1.19
log
@* solib.c (bfd_lookup_symbol): Fall back on the dynamic symbol
table if the symbol couldn't be found in the normal symbol table
(i.e. if the shared object in question was stripped).
@
text
@d765 1
a765 1
	      char pbuf[TARGET_PTR_BIT / HOST_CHAR_BIT];
d767 1
@


1.18
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 98, 1999
d531 29
a559 1
  return (symaddr);
@


1.17
log
@* solib.c (elf_locate_base, info_sharedlibrary_command): Rename
bfd_elf_get_arch_size to bfd_get_arch_size.
@
text
@d268 1
a268 2
solib_map_sections (arg)
     PTR arg;
d376 1
a376 1
allocate_rt_common_objfile ()
d415 1
a415 2
solib_add_common_symbols (rtc_symp)
     CORE_ADDR rtc_symp;
d501 1
a501 3
bfd_lookup_symbol (abfd, symname)
     bfd *abfd;
     char *symname;
d589 1
a589 3
look_for_base (fd, baseaddr)
     int fd;
     CORE_ADDR baseaddr;
d686 1
a686 1
elf_locate_base ()
d816 1
a816 1
locate_base ()
d882 1
a882 1
first_link_map_member ()
d1025 1
a1025 2
match_main (soname)
     char *soname;
d1059 1
a1059 1
current_sos ()
d1143 1
a1143 2
symbol_add_stub (arg)
     PTR arg;
d1470 1
a1470 3
info_sharedlibrary_command (ignore, from_tty)
     char *ignore;
     int from_tty;
d1552 1
a1552 2
solib_address (address)
     CORE_ADDR address;
d1568 1
a1568 1
clear_solib ()
d1605 1
a1605 2
do_clear_solib (dummy)
     PTR dummy;
d1622 1
a1622 2
in_svr4_dynsym_resolve_code (pc)
     CORE_ADDR pc;
d1650 1
a1650 1
disable_break ()
d1743 1
a1743 1
enable_break ()
d1956 1
a1956 1
solib_create_inferior_hook ()
d2044 1
a2044 1
special_symbol_handling ()
d2102 1
a2102 3
sharedlibrary_command (args, from_tty)
     char *args;
     int from_tty;
d2111 1
a2111 1
_initialize_solib ()
@


1.16
log
@PARAMS removal.
@
text
@d717 1
a717 1
  arch_size = bfd_elf_get_arch_size (exec_bfd);
d1494 1
a1494 1
  arch_size = bfd_elf_get_arch_size (exec_bfd);
@


1.15
log
@Purge (almost) make_cleanup_func.
@
text
@d187 1
a187 2
extern int
fdmatch PARAMS ((int, int));	/* In libiberty */
d191 1
a191 2
static void
do_clear_solib PARAMS ((PTR));
d193 1
a193 2
static int
match_main PARAMS ((char *));
d195 1
a195 2
static void
special_symbol_handling PARAMS ((void));
d197 1
a197 2
static void
sharedlibrary_command PARAMS ((char *, int));
d199 1
a199 2
static int
enable_break PARAMS ((void));
d201 1
a201 2
static void
info_sharedlibrary_command PARAMS ((char *, int));
d203 1
a203 1
static int symbol_add_stub PARAMS ((PTR));
d205 1
a205 2
static CORE_ADDR
  first_link_map_member PARAMS ((void));
d207 1
a207 2
static CORE_ADDR
  locate_base PARAMS ((void));
d209 1
a209 1
static int solib_map_sections PARAMS ((PTR));
d213 1
a213 2
static CORE_ADDR
  elf_locate_base PARAMS ((void));
d220 1
a220 2
static int
disable_break PARAMS ((void));
d222 1
a222 2
static void
allocate_rt_common_objfile PARAMS ((void));
d229 1
a229 1
void _initialize_solib PARAMS ((void));
d479 1
a479 2
static CORE_ADDR
  bfd_lookup_symbol PARAMS ((bfd *, char *));
d564 1
a564 2
static int
look_for_base PARAMS ((int, CORE_ADDR));
@


1.14
log
@Cleanup discard_minimal_symbols cleanup.
@
text
@d987 1
a987 1
  make_cleanup ((make_cleanup_func) free, (void *) filename);
@


1.13
log
@2000-05-10  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * solib.c (symbol_add_stub): Remember the index and the name of
        the section with the lowest address. Use this data (instead of
        data from .text) to pass info into symbol_file_add.

        * elfread.c (record_minimal_symbol_and_info): Use the section
        where the symbol lives to get the index, instead of guessing.
@
text
@d448 1
a448 1
  make_cleanup ((make_cleanup_func) discard_minimal_symbols, 0);
@


1.12
log
@2000-05-03  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * solib.c (elf_locate_base, info_sharedlibrary_command):
        Look at the bfd to determine if it is elf32 or elf64, rather
        than using an ifdef.  This makes it runtime teststable and
        multi-arch.
@
text
@a1167 1
  CORE_ADDR text_addr = 0;
d1169 3
a1171 2
  int i;
  asection *text_section;
d1182 5
a1186 1
    text_addr = so->textsection->addr;
d1189 3
a1191 4
      asection *lowest_sect;

      /* If we didn't find a mapped non zero sized .text section, set up
         text_addr so that the relocation in symbol_file_add does no harm.  */
d1197 5
a1201 2
	text_addr = bfd_section_vma (so->abfd, lowest_sect)
	  + LM_ADDR (so);
d1207 2
a1208 7
  /* Look for the index for the .text section in the sap structure. */
  text_section = bfd_get_section_by_name (so->abfd, ".text");
  for (i = 0; i < MAX_SECTIONS && sap->other[i].name; i++)
    if (sap->other[i].sectindex == text_section->index)
      break;
  
  sap->other[i].addr = text_addr;
@


1.11
log
@2000-04-17  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* symfile.h (struct section_addr_info ): Remove fields for special
 	treatment of .text, .data and .bss sections.

	* solib.c (symbol_add_stub): The special field text_addr is not
 	available anymore. Search for the .text field the hard way.

	* symfile.c (build_section_addr_info_from_section_table): Don't
 	fill in {text, data, bss}_addr any more.
	(default_symfile_offsets): Don't use {text, data, bss}_addr fields
 	to fill in section_offsets for objfile.
	(syms_from_objfile): Don't deal with {text, data, bss}_addr as a
 	special case anymore.
        (add_symbol_file_command): Ditto.
@
text
@d713 1
d730 24
a753 17
#ifndef TARGET_ELF64
  for (bufend = buf + dyninfo_sect_size;
       buf < bufend;
       buf += sizeof (Elf32_External_Dyn))
    {
      Elf32_External_Dyn *x_dynp = (Elf32_External_Dyn *) buf;
      long dyn_tag;
      CORE_ADDR dyn_ptr;

      dyn_tag = bfd_h_get_32 (exec_bfd, (bfd_byte *) x_dynp->d_tag);
      if (dyn_tag == DT_NULL)
	break;
      else if (dyn_tag == DT_DEBUG)
	{
	  dyn_ptr = bfd_h_get_32 (exec_bfd, (bfd_byte *) x_dynp->d_un.d_ptr);
	  return dyn_ptr;
	}
d755 3
a757 3
      else if (dyn_tag == DT_MIPS_RLD_MAP)
	{
	  char pbuf[TARGET_PTR_BIT / HOST_CHAR_BIT];
d759 9
a767 6
	  /* DT_MIPS_RLD_MAP contains a pointer to the address
	     of the dynamic link structure.  */
	  dyn_ptr = bfd_h_get_32 (exec_bfd, (bfd_byte *) x_dynp->d_un.d_ptr);
	  if (target_read_memory (dyn_ptr, pbuf, sizeof (pbuf)))
	    return 0;
	  return extract_unsigned_integer (pbuf, sizeof (pbuf));
a768 1
#endif
d770 19
a788 16
#else /* ELF64 */
  for (bufend = buf + dyninfo_sect_size;
       buf < bufend;
       buf += sizeof (Elf64_External_Dyn))
    {
      Elf64_External_Dyn *x_dynp = (Elf64_External_Dyn *) buf;
      long dyn_tag;
      CORE_ADDR dyn_ptr;

      dyn_tag = bfd_h_get_64 (exec_bfd, (bfd_byte *) x_dynp->d_tag);
      if (dyn_tag == DT_NULL)
	break;
      else if (dyn_tag == DT_DEBUG)
	{
	  dyn_ptr = bfd_h_get_64 (exec_bfd, (bfd_byte *) x_dynp->d_un.d_ptr);
	  return dyn_ptr;
a790 1
#endif
d1499 1
d1507 12
a1518 7
#ifndef TARGET_ELF64
  addr_width = 8 + 4;
  addr_fmt = "08l";
#else
  addr_width = 16 + 4;
  addr_fmt = "016l";
#endif
@


1.10
log
@* solib.c (update_solib_list): New function.
(solib_add): Call update_solib_list, and then read symbols.
(info_sharedlibrary_command): Call update_solib_list, not
solib_add.
@
text
@d1158 2
d1188 8
a1195 1
  sap->text_addr = text_addr;
@


1.9
log
@2000-04-03  H.J. Lu  <hjl@@gnu.org>

	* gdb_regex.h: New. Include "regex.h" if USE_INCLUDED_REGEX
	is defined and <regex.h> otherwise.

        * irix5-nat.c: Include "gdb_regex.h" instead of "gnu-regex.h".
	* monitor.c: Likewise.
	* osfsolib.c: Likewise.
	* solib.c: Likewise.
	* source.c: Likewise.
	* symtab.c: Likewise.

	* Makefile.in (REGEX): Changed to @@REGEX@@.
	(REGEX_CFLAGS): New.
	(REGEX1): Removed.
	(ADD_DEPS): Use $(REGEX) instead of $(REGEX1).
	(INTERNAL_WARN_CFLAGS): Add $(REGEX_CFLAGS).

	* configure.in (--with-included-regex): New switch.
	(REGEX): New. Subsstitue @@REGEX@@ in Makefile.in.
	(REGEX_CFLAGS): New. Subsstitue @@REGEX_CFLAGS@@ in Makefile.in.
	* configure: Regenerated.
@
text
@d1197 1
a1197 1
   solib_add -- synchronize GDB's shared object list with the inferior's
d1201 1
a1201 1
   void solib_add (char *pattern, int from_tty, struct target_ops *TARGET)
d1203 4
a1206 1
   DESCRIPTION
d1208 2
a1209 5
   Extract the list of currently loaded shared objects from the
   inferior, and compare it with the list of shared objects for which
   GDB has currently loaded symbolic information.  If new shared
   objects have been loaded, or old shared objects have disappeared,
   make the appropriate changes to GDB's tables.
d1211 2
a1212 2
   If PATTERN is non-null, read symbols only for shared objects
   whose names match PATTERN.
d1225 1
a1225 1
solib_add (char *pattern, int from_tty, struct target_ops *target)
a1241 8
  if (pattern)
    {
      char *re_err = re_comp (pattern);

      if (re_err)
	error ("Invalid regexp: %s", re_err);
    }

d1257 2
a1258 2
       knows about it already, and it's still loaded in the inferior.
       Nothing needs to happen.
d1261 2
a1262 2
       the inferior has unloaded it.  We should remove the shared
       object from GDB's tables.
d1265 2
a1266 2
       means that it's just been loaded.  We should add it to GDB's
       tables.
d1369 33
d1403 3
a1405 4
  /* Finally, read the symbols as requested.  Walk the list of
     currently loaded shared libraries, and read symbols for any that
     match the pattern --- or any whose symbols aren't already loaded,
     if no pattern was given.  */
d1493 1
a1493 1
  solib_add (0, 0, 0);
@


1.8
log
@* solib.c (solib_add): Move all the code for loading symbol tables
below the code to sort out additions and removals.  That way, we
always catch all loaded shared libraries whose symbols we haven't
grabbed yet.

* solib.c (solib_add): Don't try to free a shared object's objfile
if it doesn't have one.  Duh.

* solib.c (solib_add): If a pattern was given, but it doesn't
match any currently loaded shared libraries, print a message;
don't just be silent.
@
text
@d52 1
a52 1
#include "gnu-regex.h"
@


1.7
log
@2000-03-23  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * solib.c (open_symbol_file_object): to sneak an int argument
        past catch_errors, instead of casting it to a pointer, simply
        pass it by address.
@
text
@d1318 1
a1318 1
	  if (! (gdb->objfile->flags & OBJF_USERLOADED))
d1332 1
a1332 2
     to GDB's shared object list, and read in their symbols, if
     appropriate.  */
d1340 1
a1340 2
      /* Fill in the rest of each of the `struct so_list' nodes, and
	 read symbols for those files whose names match PATTERN.  */
a1348 23

	  if (! pattern || re_exec (i->so_name))
	    {
	      if (i->symbols_loaded)
		{
		  if (from_tty)
		    printf_unfiltered ("Symbols already loaded for %s\n",
				       i->so_name);
		}
	      else
		{
		  if (catch_errors
		      (symbol_add_stub, i,
		       "Error while reading shared library symbols:\n",
		       RETURN_MASK_ALL))
		    {
		      if (from_tty)
			printf_unfiltered ("Loaded symbols for %s\n",
					   i->so_name);
		      i->symbols_loaded = 1;
		    }
		}
	    }
d1376 1
d1378 12
a1389 3
      /* Getting new symbols may change our opinion about what is
         frameless.  */
      reinit_frame_cache ();
d1391 35
a1425 2
      special_symbol_handling ();
    }
@


1.6
log
@Make sure section addresses from a shared object are correctly set in
a new struct objfile.
@
text
@d924 1
a924 1
  open_exec_file_object
d939 3
a941 3
int
open_symbol_file_object (arg)
     PTR arg;
a942 1
  int from_tty = (int) arg;	/* sneak past catch_errors */
d977 1
a977 1
  symbol_file_command (filename, from_tty);
d1236 1
a1236 1
    catch_errors (open_symbol_file_object, (PTR) from_tty, 
@


1.5
log
@* solib.c (solib_add): Delete debugging code.
@
text
@d1158 1
d1185 6
a1190 9
  {
    struct section_addr_info section_addrs;

    memset (&section_addrs, 0, sizeof (section_addrs));
    section_addrs.text_addr = text_addr;

    so->objfile = symbol_file_add (so->so_name, so->from_tty,
				   &section_addrs, 0, OBJF_SHARED);
  }
@


1.4
log
@* solib.c (current_sos): Be more careful about freeing the new
so_list node if an error occurs.
@
text
@a1232 10
  /* #define JIMB_DEBUG */
#ifdef JIMB_DEBUG
  printf ("GDB's shared library list:\n");
  for (gdb = so_list_head; gdb; gdb = gdb->next)
    printf ("  %s\n", gdb->so_original_name);
  printf ("inferior's shared library list:\n");
  for (gdb = inferior; gdb; gdb = gdb->next)
    printf ("  %s\n", gdb->so_original_name);
#endif

a1309 3
#ifdef JIMB_DEBUG
	  printf ("unchanged: %s\n", i->so_name);
#endif
a1318 3
#ifdef JIMB_DEBUG
	  printf ("removed:   %s\n", gdb->so_name);
#endif
a1364 3
#ifdef JIMB_DEBUG
		  printf ("added:     %s\n", i->so_name);
#endif
a1410 4

#ifdef JIMB_DEBUG
  putchar ('\n');
#endif
@


1.3
log
@Deal with the inferior unloading shared objects.
* solib.c (current_sos): New function, replacing find_solib.
(find_solib): Deleted.
(free_so): New function.
(clear_solib): Call free_so, instead of writing it out.
(solib_add): Rewritten: compare the inferior's current list of
shared objects with GDB's list, and do the required loads and
unloads.
(info_sharedlibrary_command, solib_address): Don't use find_solib
to walk the list of shared libraries: call solib_add, and then
walk the list at so_list_head normally.
* objfiles.c (free_objfile): Don't call CLEAR_SOLIB, and don't
detach the core target.  These tasks are taken care of elsewhere.
* target.c (remove_target_sections): New function.
* target.h (remove_target_sections): New declaration.

* solib.c (symbol_add_stub): Check whether we've already created
an objfile for this shared object first, before doing all that
work to compute section addresses, etc.

* objfiles.c (unlink_objfile): Report an internal error if objfile
doesn't occur in the object_files list.

* solib.c (special_symbol_handling): Delete argument; it's not
used.

* solib.c (SOLIB_EXTRACT_ADDRESS):  New macro to extract addresses
from solib structures. Use it throughout solib.c, get rid of all
CORE_ADDR casts.
(struct so_list):  Change type of lmaddr to CORE_ADDR.
(first_link_map_member):  Change return value type to CORE_ADDR,
update callers.
(solib_add_common_symbols):  Change parameter type to CORE_ADDR,
update callers.
(open_symbol_file_object, find_solib):  Change type of lm variable
to CORE_ADDR.
@
text
@d1094 1
d1108 1
a1108 3
	{
	  free_so (new);
	}
d1142 2
@


1.2
log
@Doc fix.
@
text
@d112 9
d123 3
a125 3
#define LM_ADDR(so) ((so) -> lm.lm_addr)
#define LM_NEXT(so) ((so) -> lm.lm_next)
#define LM_NAME(so) ((so) -> lm.lm_name)
d127 1
a127 1
#define IGNORE_FIRST_LINK_MAP_ENTRY(x) (0)
d136 3
a138 3
#define LM_ADDR(so) ((so) -> lm.l_addr)
#define LM_NEXT(so) ((so) -> lm.l_next)
#define LM_NAME(so) ((so) -> lm.l_name)
d140 2
a141 1
#define IGNORE_FIRST_LINK_MAP_ENTRY(x) ((x).l_prev == NULL)
d149 4
d155 17
a171 1
    struct link_map *lmaddr;	/* addr in inferior lm was read from */
a172 1
    char so_name[MAX_PATH_SIZE];	/* shared object lib name (FIXME) */
a178 1
    bfd *abfd;
d199 1
a199 1
special_symbol_handling PARAMS ((struct so_list *));
d212 1
a212 4
static struct so_list *
  find_solib PARAMS ((struct so_list *));

static struct link_map *
d227 3
d237 1
a237 1
solib_add_common_symbols PARAMS ((struct rtc_symb *));
d369 3
a371 3
      p->addr += (CORE_ADDR) LM_ADDR (so);
      p->endaddr += (CORE_ADDR) LM_ADDR (so);
      so->lmend = (CORE_ADDR) max (p->endaddr, so->lmend);
d429 1
a429 1
     struct rtc_symb *rtc_symp;
d452 1
a452 1
      read_memory ((CORE_ADDR) rtc_symp,
d455 1
a455 1
      read_memory ((CORE_ADDR) inferior_rtc_symb.rtc_sp,
d466 2
a467 1
	  read_memory ((CORE_ADDR) inferior_rtc_nlist.n_un.n_name, name, len);
d477 1
a477 1
      rtc_symp = inferior_rtc_symb.rtc_next;
d880 1
a880 1
   static struct link_map *first_link_map_member (void)
d886 1
a886 1
   link map entry itself into our address space; find_solib actually
d889 1
a889 1
static struct link_map *
d892 1
a892 1
  struct link_map *lm = NULL;
d901 3
a903 3
      read_memory ((CORE_ADDR) dynamic_copy.ld_un.ld_2, (char *) &ld_2_copy,
		   sizeof (struct link_dynamic_2));
      lm = ld_2_copy.ld_loaded;
d912 1
a912 1
  lm = debug_copy.r_map;
d944 2
a945 1
  struct link_map *lm, lmcopy;
d957 1
a957 1
  if ((lm = first_link_map_member ()) == NULL)
d961 1
a961 1
  read_memory ((CORE_ADDR) lm, (void *) &lmcopy, sizeof (lmcopy));
d967 1
a967 1
  target_read_string ((CORE_ADDR) lmcopy.l_name, &filename, 
a983 1
/*
d985 1
a985 1
   LOCAL FUNCTION
d987 1
a987 1
   find_solib -- step through list of shared objects
d991 1
a991 1
   struct so_list *find_solib (struct so_list *so_list_ptr)
d995 57
a1051 6
   This module contains the routine which finds the names of any
   loaded "images" in the current process. The argument in must be
   NULL on the first call, and then the returned value must be passed
   in on subsequent calls. This provides the capability to "step" down
   the list of loaded objects. On the last object, a NULL value is
   returned.
d1053 14
a1066 3
   The arg and return value are "struct link_map" pointers, as defined
   in <link.h>.
 */
d1069 1
a1069 2
find_solib (so_list_ptr)
     struct so_list *so_list_ptr;	/* Last lm or NULL for first one */
d1071 7
a1077 21
  struct so_list *so_list_next = NULL;
  struct link_map *lm = NULL;
  struct so_list *new;

  if (so_list_ptr == NULL)
    {
      /* We are setting up for a new scan through the loaded images. */
      if ((so_list_next = so_list_head) == NULL)
	{
	  /* We have not already read in the dynamic linking structures
	     from the inferior, lookup the address of the base structure. */
	  debug_base = locate_base ();
	  if (debug_base != 0)
	    {
	      /* Read the base structure in and find the address of the first
	         link map list member. */
	      lm = first_link_map_member ();
	    }
	}
    }
  else
d1079 6
a1084 19
      /* We have been called before, and are in the process of walking
         the shared library list.  Advance to the next shared object. */
      if ((lm = LM_NEXT (so_list_ptr)) == NULL)
	{
	  /* We have hit the end of the list, so check to see if any were
	     added, but be quiet if we can't read from the target any more. */
	  int status = target_read_memory ((CORE_ADDR) so_list_ptr->lmaddr,
					   (char *) &(so_list_ptr->lm),
					   sizeof (struct link_map));
	  if (status == 0)
	    {
	      lm = LM_NEXT (so_list_ptr);
	    }
	  else
	    {
	      lm = NULL;
	    }
	}
      so_list_next = so_list_ptr->next;
d1086 5
a1090 1
  if ((so_list_next == NULL) && (lm != NULL))
d1092 4
a1095 4
      /* Get next link map structure from inferior image and build a local
         abbreviated load_map structure */
      new = (struct so_list *) xmalloc (sizeof (struct so_list));
      memset ((char *) new, 0, sizeof (struct so_list));
d1097 1
a1097 9
      /* Add the new node as the next node in the list, or as the root
         node if this is the first one. */
      if (so_list_ptr != NULL)
	{
	  so_list_ptr->next = new;
	}
      else
	{
	  so_list_head = new;
d1099 1
a1099 5
	  if (!solib_cleanup_queued)
	    {
	      make_run_cleanup (do_clear_solib, NULL);
	      solib_cleanup_queued = 1;
	    }
a1100 4
	}
      so_list_next = new;
      read_memory ((CORE_ADDR) lm, (char *) &(new->lm),
		   sizeof (struct link_map));
d1106 5
a1110 1
      if (!IGNORE_FIRST_LINK_MAP_ENTRY (new->lm))
d1114 3
a1116 1
	  target_read_string ((CORE_ADDR) LM_NAME (new), &buffer,
d1120 1
a1120 1
	      warning ("find_solib: Can't read pathname for load map: %s\n",
a1121 1
	      return (so_list_next);
d1123 19
a1141 6
	  strncpy (new->so_name, buffer, MAX_PATH_SIZE - 1);
	  new->so_name[MAX_PATH_SIZE - 1] = '\0';
	  free (buffer);
	  catch_errors (solib_map_sections, new,
			"Error while mapping shared library sections:\n",
			RETURN_MASK_ALL);
d1144 2
a1145 1
  return (so_list_next);
d1148 1
d1155 1
a1155 1
  register struct so_list *so = (struct so_list *) arg;		/* catch_errs bogon */
a1156 1
  struct section_addr_info section_addrs;
d1158 8
a1165 1
  memset (&section_addrs, 0, sizeof (section_addrs));
a1173 1

d1180 1
a1180 1
	  + (CORE_ADDR) LM_ADDR (so);
a1182 1
  ALL_OBJFILES (so->objfile)
d1184 1
a1184 9
    if (strcmp (so->objfile->name, so->so_name) == 0)
      return 1;
  }
  section_addrs.text_addr = text_addr;
  so->objfile =
    symbol_file_add (so->so_name, so->from_tty,
		     &section_addrs, 0, OBJF_SHARED);
  return (1);
}
d1186 2
a1187 2
/* This function will check the so name to see if matches the main list.
   In some system the main object is in the list, which we want to exclude */
d1189 3
a1191 5
static int
match_main (soname)
     char *soname;
{
  char **mainp;
d1193 1
a1193 7
  for (mainp = main_name_list; *mainp != NULL; mainp++)
    {
      if (strcmp (soname, *mainp) == 0)
	return (1);
    }

  return (0);
a1195 1
/*
d1197 1
a1197 1
   GLOBAL FUNCTION
d1199 1
a1199 1
   solib_add -- add a shared library file to the symtab and section list
d1203 1
a1203 2
   void solib_add (char *arg_string, int from_tty,
   struct target_ops *target)
d1207 18
a1224 1
 */
d1227 1
a1227 4
solib_add (arg_string, from_tty, target)
     char *arg_string;
     int from_tty;
     struct target_ops *target;
d1229 2
a1230 1
  register struct so_list *so = NULL;	/* link map state variable */
d1232 9
a1240 6
  /* Last shared library that we read.  */
  struct so_list *so_last = NULL;

  char *re_err;
  int count;
  int old;
d1254 12
a1265 1
  if ((re_err = re_comp (arg_string? arg_string : ".")) != NULL)
d1267 2
a1268 1
      error ("Invalid regexp: %s", re_err);
d1271 27
a1297 3
  /* Add the shared library sections to the section table of the
     specified target, if any.  */
  if (target)
d1299 6
a1304 4
      /* Count how many new section_table entries there are.  */
      so = NULL;
      count = 0;
      while ((so = find_solib (so)) != NULL)
d1306 19
a1324 4
	  if (so->so_name[0] && !match_main (so->so_name))
	    {
	      count += so->sections_end - so->sections;
	    }
d1327 2
a1328 1
      if (count)
d1330 15
a1344 14
	  
	  /* Add these section table entries to the target's table.  */
	  old = target_resize_to_sections (target, count);
	  while ((so = find_solib (so)) != NULL)
	    {
	      if (so->so_name[0])
		{
		  count = so->sections_end - so->sections;
		  memcpy ((char *) (target->to_sections + old),
			  so->sections,
			  (sizeof (struct section_table)) * count);
		  old += count;
		}
	    }
d1348 5
a1352 2
  /* Now add the symbol files.  */
  while ((so = find_solib (so)) != NULL)
d1354 8
a1361 2
      if (so->so_name[0] && re_exec (so->so_name) &&
	  !match_main (so->so_name))
d1363 8
a1370 2
	  so->from_tty = from_tty;
	  if (so->symbols_loaded)
d1372 1
a1372 1
	      if (from_tty)
d1374 19
a1392 1
		  printf_unfiltered ("Symbols already loaded for %s\n", so->so_name);
d1395 14
a1408 4
	  else if (catch_errors
		   (symbol_add_stub, so,
		    "Error while reading shared library symbols:\n",
		    RETURN_MASK_ALL))
d1410 10
a1419 2
	      so_last = so;
	      so->symbols_loaded = 1;
d1422 6
d1430 4
a1433 4
  /* Getting new symbols may change our opinion about what is
     frameless.  */
  if (so_last)
    reinit_frame_cache ();
a1434 3
  if (so_last)
    special_symbol_handling (so_last);
}
d1476 3
a1478 1
  while ((so = find_solib (so)) != NULL)
d1536 1
a1536 1
  while ((so = find_solib (so)) != NULL)
d1538 2
a1539 6
      if (so->so_name[0])
	{
	  if ((address >= (CORE_ADDR) LM_ADDR (so)) &&
	      (address < (CORE_ADDR) so->lmend))
	    return (so->so_name);
	}
d1541 1
a1549 3
  struct so_list *next;
  char *bfd_filename;

d1576 4
a1579 14
      if (so_list_head->sections)
	{
	  free ((PTR) so_list_head->sections);
	}
      if (so_list_head->abfd)
	{
	  bfd_filename = bfd_get_filename (so_list_head->abfd);
	  if (!bfd_close (so_list_head->abfd))
	    warning ("cannot close \"%s\": %s",
		     bfd_filename, bfd_errmsg (bfd_get_error ()));
	}
      else
	/* This happens for the executable on SVR4.  */
	bfd_filename = NULL;
a1580 6
      next = so_list_head->next;
      if (bfd_filename)
	free ((PTR) bfd_filename);
      free ((PTR) so_list_head);
      so_list_head = next;
    }
d1651 1
a1651 1
  breakpoint_addr = (CORE_ADDR) debug_copy.ldd_bp_addr;
d1746 1
a1746 1
  debug_addr = (CORE_ADDR) dynamic_copy.ldd;
d1942 1
a1942 1
     Solaris, we can't get it yet.  find_solib will get it when it needs
d2010 1
a2010 1
   void special_symbol_handling (struct so_list *so)
d2026 1
a2026 2
special_symbol_handling (so)
     struct so_list *so;
d2047 1
a2047 1
      debug_addr = (CORE_ADDR) dynamic_copy.ldd;
d2062 1
a2062 1
      solib_add_common_symbols (debug_copy.ldd_cp);
@


1.1
log
@Initial revision
@
text
@a3 2
   
This file is part of GDB.
d5 16
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a33 1
#include <unistd.h>
d37 1
a37 1
#include <a.out.h> 
d58 1
a58 1
#define MAX_PATH_SIZE 512		/* FIXME: Should be dynamic */
d69 2
a70 1
static char *solib_break_names[] = {
d82 2
a83 1
static char *bkpt_names[] = {
d96 2
a97 1
static char *debug_base_symbols[] = {
d104 2
a105 1
static char *main_name_list[] = {
d125 1
a125 1
#else	/* SVR4_SHARED_LIBS */
d135 1
a135 1
#endif	/* !SVR4_SHARED_LIBS */
d137 15
a151 14
struct so_list {
  struct so_list *next;			/* next structure in linked list */
  struct link_map lm;			/* copy of link map from inferior */
  struct link_map *lmaddr;		/* addr in inferior lm was read from */
  CORE_ADDR lmend;			/* upper addr bound of mapped object */
  char so_name[MAX_PATH_SIZE];		/* shared object lib name (FIXME) */
  char symbols_loaded;			/* flag: symbols read in yet? */
  char from_tty;			/* flag: print msgs? */
  struct objfile *objfile;		/* objfile for loaded lib */
  struct section_table *sections;
  struct section_table *sections_end;
  struct section_table *textsection;
  bfd *abfd;
};
d154 1
a154 1
static CORE_ADDR debug_base;		/* Base of dynamic linker structures */
d157 1
a157 1
static int solib_cleanup_queued = 0;    /* make_run_cleanup called */
d160 1
a160 1
fdmatch PARAMS ((int, int));		/* In libiberty */
d185 1
a185 1
find_solib PARAMS ((struct so_list *));
d188 1
a188 1
first_link_map_member PARAMS ((void));
d191 1
a191 1
locate_base PARAMS ((void));
d198 1
a198 1
elf_locate_base PARAMS ((void));
d226 1
a226 1
LOCAL FUNCTION
d228 1
a228 1
	solib_map_sections -- open bfd and build sections for shared lib
d230 1
a230 1
SYNOPSIS
d232 1
a232 1
	static int solib_map_sections (struct so_list *so)
d234 1
a234 1
DESCRIPTION
d236 5
a240 5
	Given a pointer to one of the shared objects in our list
	of mapped objects, use the recorded name to open a bfd
	descriptor for the object, build a section table, and then
	relocate all the section addresses by the base address at
	which the shared object was mapped.
d242 1
a242 1
FIXMES
d244 5
a248 5
	In most (all?) cases the shared object file name recorded in the
	dynamic linkage tables will be a fully qualified pathname.  For
	cases where it isn't, do we really mimic the systems search
	mechanism correctly in the below code (particularly the tilde
	expansion stuff?).
d262 3
a264 3
  
  filename = tilde_expand (so -> so_name);
  
d294 1
a294 1
    scratch_chan = openp (get_in_environ (inferior_environ, "PATH"), 
d298 2
a299 2
      scratch_chan = openp (get_in_environ 
			    (inferior_environ, "LD_LIBRARY_PATH"), 
d316 2
a317 2
  so -> abfd = abfd;
  abfd -> cacheable = true;
d330 1
a330 1
  if (build_section_table (abfd, &so -> sections, &so -> sections_end))
d332 1
a332 1
      error ("Can't find the file sections in `%s': %s", 
d336 1
a336 1
  for (p = so -> sections; p < so -> sections_end; p++)
d339 6
a344 6
	 object's file by the base address to which the object was actually
	 mapped. */
      p -> addr += (CORE_ADDR) LM_ADDR (so);
      p -> endaddr += (CORE_ADDR) LM_ADDR (so);
      so -> lmend = (CORE_ADDR) max (p -> endaddr, so -> lmend);
      if (STREQ (p -> the_bfd_section -> name, ".text"))
d346 1
a346 1
	  so -> textsection = p;
d368 2
a369 2
  objfile -> md = NULL;
  obstack_specify_allocation (&objfile -> psymbol_cache.cache, 0, 0,
d371 1
a371 1
  obstack_specify_allocation (&objfile -> psymbol_obstack, 0, 0, xmalloc,
d373 1
a373 1
  obstack_specify_allocation (&objfile -> symbol_obstack, 0, 0, xmalloc,
d375 1
a375 1
  obstack_specify_allocation (&objfile -> type_obstack, 0, 0, xmalloc,
d377 1
a377 1
  objfile -> name = mstrsave (objfile -> md, "rt_common");
d381 1
a381 1
  objfile -> next = NULL;
d387 3
a389 3
	   last_one -> next;
	   last_one = last_one -> next);
      last_one -> next = objfile;
d401 1
a401 1
    struct rtc_symb *rtc_symp;
d410 1
a410 1
  if (rt_common_objfile != NULL && rt_common_objfile -> minimal_symbol_count)
d412 2
a413 2
      obstack_free (&rt_common_objfile -> symbol_obstack, 0);
      obstack_specify_allocation (&rt_common_objfile -> symbol_obstack, 0, 0,
d415 2
a416 2
      rt_common_objfile -> minimal_symbol_count = 0;
      rt_common_objfile -> msymbols = NULL;
d429 1
a429 1
		   sizeof(inferior_rtc_nlist));
d457 1
a457 1
#endif	/* SVR4_SHARED_LIBS */
d463 1
a463 1
bfd_lookup_symbol PARAMS ((bfd *, char *));
d467 1
a467 1
LOCAL FUNCTION
d469 1
a469 1
	bfd_lookup_symbol -- lookup the value for a specific symbol
d471 1
a471 1
SYNOPSIS
d473 1
a473 1
	CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname)
d475 1
a475 1
DESCRIPTION
d477 4
a480 4
	An expensive way to lookup the value of a single symbol for
	bfd's that are only temporary anyway.  This is used by the
	shared library support to find the address of the debugger
	interface structures in the shared library.
d482 3
a484 3
	Note that 0 is specifically allowed as an error return (no
	such symbol).
*/
d498 1
a498 1
  
d504 3
a506 3
      back_to = make_cleanup (free, (PTR)symbol_table);
      number_of_symbols = bfd_canonicalize_symtab (abfd, symbol_table); 
  
d510 1
a510 1
	  if (STREQ (sym -> name, symname))
d513 1
a513 1
	      symaddr = sym -> value + sym -> section -> vma;
d525 20
a544 19
	Solaris BCP (the part of Solaris which allows it to run SunOS4
	a.out files) throws in another wrinkle. Solaris does not fill
	in the usual a.out link map structures when running BCP programs,
	the only way to get at them is via groping around in the dynamic
	linker.
	The dynamic linker and it's structures are located in the shared
	C library, which gets run as the executable's "interpreter" by
	the kernel.

	Note that we can assume nothing about the process state at the time
	we need to find these structures.  We may be stopped on the first
	instruction of the interpreter (C shared library), the first
	instruction of the executable itself, or somewhere else entirely
	(if we attached to the process for example).
*/

static char *debug_base_symbols[] = {
  "r_debug",	/* Solaris 2.3 */
  "_r_debug",	/* Solaris 2.1, 2.2 */
d553 1
a553 1
LOCAL FUNCTION
d555 1
a555 1
	look_for_base -- examine file for each mapped address segment
d557 1
a557 1
SYNOPSYS
d559 1
a559 1
	static int look_for_base (int fd, CORE_ADDR baseaddr)
d561 1
a561 1
DESCRIPTION
d563 4
a566 4
	This function is passed to proc_iterate_over_mappings, which
	causes it to get called once for each mapped address space, with
	an open file descriptor for the file mapped to that space, and the
	base address of that mapped space.
d568 3
a570 3
	Our job is to find the debug base symbol in the file that this
	fd is open on, if it exists, and if so, initialize the dynamic
	linker structure base address debug_base.
d572 3
a574 3
	Note that this is a computationally expensive proposition, since
	we basically have to open a bfd on every call, so we specifically
	avoid opening the exec file.
d592 1
a592 1
	  && fdmatch (fileno ((FILE *)(exec_bfd -> iostream)), fd)))
d608 1
a608 1
	 interp_bfd.  */
d627 1
a627 1
	 interp_bfd.  */
d654 1
a654 1
LOCAL FUNCTION
d656 2
a657 2
	elf_locate_base -- locate the base address of dynamic linker structs
	for SVR4 elf targets.
d659 1
a659 1
SYNOPSIS
d661 1
a661 1
	CORE_ADDR elf_locate_base (void)
d663 1
a663 1
DESCRIPTION
d665 8
a672 8
	For SVR4 elf targets the address of the dynamic linker's runtime
	structure is contained within the dynamic info section in the
	executable file.  The dynamic section is also mapped into the
	inferior address space.  Because the runtime loader fills in the
	real address before starting the inferior, we have to read in the
	dynamic info section from the inferior address space.
	If there are any errors while trying to find the address, we
	silently return 0, otherwise the found address is returned.
d705 1
a705 1
      Elf32_External_Dyn *x_dynp = (Elf32_External_Dyn *)buf;
d736 1
a736 1
      Elf64_External_Dyn *x_dynp = (Elf64_External_Dyn *)buf;
d755 1
a755 1
#endif	/* SVR4_SHARED_LIBS */
d759 1
a759 1
LOCAL FUNCTION
d761 1
a761 1
	locate_base -- locate the base address of dynamic linker structs
d763 1
a763 1
SYNOPSIS
d765 1
a765 1
	CORE_ADDR locate_base (void)
d767 24
a790 24
DESCRIPTION

	For both the SunOS and SVR4 shared library implementations, if the
	inferior executable has been linked dynamically, there is a single
	address somewhere in the inferior's data space which is the key to
	locating all of the dynamic linker's runtime structures.  This
	address is the value of the debug base symbol.  The job of this
	function is to find and return that address, or to return 0 if there
	is no such address (the executable is statically linked for example).

	For SunOS, the job is almost trivial, since the dynamic linker and
	all of it's structures are statically linked to the executable at
	link time.  Thus the symbol for the address we are looking for has
	already been added to the minimal symbol table for the executable's
	objfile at the time the symbol file's symbols were read, and all we
	have to do is look it up there.  Note that we explicitly do NOT want
	to find the copies in the shared library.

	The SVR4 version is a bit more complicated because the address
	is contained somewhere in the dynamic info section.  We have to go
	to a lot more work to discover the address of the debug base symbol.
	Because of this complexity, we cache the value we find and return that
	value on subsequent invocations.  Note there is no copy in the
	executable symbol tables.
d819 1
a819 1
#else	/* SVR4_SHARED_LIBS */
d839 1
a839 1
#endif	/* !SVR4_SHARED_LIBS */
d845 1
a845 1
LOCAL FUNCTION
d847 1
a847 1
	first_link_map_member -- locate first member in dynamic linker's map
d849 1
a849 1
SYNOPSIS
d851 1
a851 1
	static struct link_map *first_link_map_member (void)
d853 1
a853 1
DESCRIPTION
d855 4
a858 4
	Read in a copy of the first member in the inferior's dynamic
	link map from the inferior's dynamic linker structures, and return
	a pointer to the copy in our address space.
*/
d871 1
a871 1
	 structure and find the address of the link map list from it. */
d877 1
a877 1
#else	/* SVR4_SHARED_LIBS */
d885 1
a885 1
#endif	/* !SVR4_SHARED_LIBS */
d890 1
d893 1
a893 1
LOCAL FUNCTION
d895 1
a895 1
	find_solib -- step through list of shared objects
d897 1
a897 1
SYNOPSIS
d899 1
a899 1
	struct so_list *find_solib (struct so_list *so_list_ptr)
d901 1
a901 1
DESCRIPTION
d903 4
a906 6
	This module contains the routine which finds the names of any
	loaded "images" in the current process. The argument in must be
	NULL on the first call, and then the returned value must be passed
	in on subsequent calls. This provides the capability to "step" down
	the list of loaded objects. On the last object, a NULL value is
	returned.
d908 67
a974 2
	The arg and return value are "struct link_map" pointers, as defined
	in <link.h>.
d984 1
a984 1
  
d996 1
a996 1
		 link map list member. */
d1004 1
a1004 1
	 the shared library list.  Advance to the next shared object. */
d1009 2
a1010 2
	  int status = target_read_memory ((CORE_ADDR) so_list_ptr -> lmaddr,
					   (char *) &(so_list_ptr -> lm),
d1021 1
a1021 1
      so_list_next = so_list_ptr -> next;
d1026 1
a1026 1
	 abbreviated load_map structure */
d1029 1
a1029 1
      new -> lmaddr = lm;
d1031 1
a1031 1
	 node if this is the first one. */
d1034 1
a1034 1
	  so_list_ptr -> next = new;
d1040 1
a1040 1
	  if (! solib_cleanup_queued)
d1045 2
a1046 2
	  
	}      
d1048 1
a1048 1
      read_memory ((CORE_ADDR) lm, (char *) &(new -> lm),
d1051 5
a1055 5
	 inferior executable, so we must ignore it.  For some versions of
	 SVR4, it has no name.  For others (Solaris 2.3 for example), it
	 does have a name, so we can no longer use a missing name to
	 decide when to ignore it. */
      if (!IGNORE_FIRST_LINK_MAP_ENTRY (new -> lm))
d1067 2
a1068 2
	  strncpy (new -> so_name, buffer, MAX_PATH_SIZE - 1);
	  new -> so_name[MAX_PATH_SIZE - 1] = '\0';
d1073 1
a1073 1
	}      
d1084 1
a1084 1
  register struct so_list *so = (struct so_list *) arg;	/* catch_errs bogon */
d1086 1
d1088 4
a1091 3
  if (so -> textsection)
    text_addr = so -> textsection -> addr;
  else if (so -> abfd != NULL)
d1096 1
a1096 1
	 text_addr so that the relocation in symbol_file_add does no harm.  */
d1098 1
a1098 1
      lowest_sect = bfd_get_section_by_name (so -> abfd, ".text");
d1100 1
a1100 1
	bfd_map_over_sections (so -> abfd, find_lowest_section,
d1103 2
a1104 2
	text_addr = bfd_section_vma (so -> abfd, lowest_sect)
		    + (CORE_ADDR) LM_ADDR (so);
d1106 10
a1115 10
  
  ALL_OBJFILES (so -> objfile)
    {
      if (strcmp (so -> objfile -> name, so -> so_name) == 0)
	return 1;
    }
  so -> objfile =
    symbol_file_add (so -> so_name, so -> from_tty,
		     text_addr,
		     0, 0, 0, 0, 1);
d1122 3
a1124 2
static int match_main (soname)
    char *soname;
d1139 1
a1139 1
GLOBAL FUNCTION
d1141 1
a1141 1
	solib_add -- add a shared library file to the symtab and section list
d1143 1
a1143 1
SYNOPSIS
d1145 2
a1146 2
	void solib_add (char *arg_string, int from_tty,
			struct target_ops *target)
d1148 1
a1148 1
DESCRIPTION
d1150 1
a1150 1
*/
d1157 2
a1158 2
{	
  register struct so_list *so = NULL;   	/* link map state variable */
d1166 14
a1179 2
  
  if ((re_err = re_comp (arg_string ? arg_string : ".")) != NULL)
d1183 1
a1183 1
  
d1193 1
a1193 1
	  if (so -> so_name[0] && !match_main (so -> so_name))
d1195 1
a1195 1
	      count += so -> sections_end - so -> sections;
d1198 1
a1198 1
      
a1200 22
	  int update_coreops;

	  /* We must update the to_sections field in the core_ops structure
	     here, otherwise we dereference a potential dangling pointer
	     for each call to target_read/write_memory within this routine.  */
	  update_coreops = core_ops.to_sections == target->to_sections;
          	     
	  /* Reallocate the target's section table including the new size.  */
	  if (target -> to_sections)
	    {
	      old = target -> to_sections_end - target -> to_sections;
	      target -> to_sections = (struct section_table *)
		xrealloc ((char *)target -> to_sections,
			 (sizeof (struct section_table)) * (count + old));
	    }
	  else
	    {
	      old = 0;
	      target -> to_sections = (struct section_table *)
		xmalloc ((sizeof (struct section_table)) * count);
	    }
	  target -> to_sections_end = target -> to_sections + (count + old);
a1201 8
	  /* Update the to_sections field in the core_ops structure
	     if needed.  */
	  if (update_coreops)
	    {
	      core_ops.to_sections = target->to_sections;
	      core_ops.to_sections_end = target->to_sections_end;
	    }

d1203 1
d1206 1
a1206 1
	      if (so -> so_name[0])
d1208 3
a1210 3
		  count = so -> sections_end - so -> sections;
		  memcpy ((char *) (target -> to_sections + old),
			  so -> sections, 
d1217 1
a1217 1
  
d1221 2
a1222 2
      if (so -> so_name[0] && re_exec (so -> so_name) && 
      !match_main (so -> so_name))
d1224 2
a1225 2
	  so -> from_tty = from_tty;
	  if (so -> symbols_loaded)
d1229 1
a1229 1
		  printf_unfiltered ("Symbols already loaded for %s\n", so -> so_name);
d1238 1
a1238 1
	      so -> symbols_loaded = 1;
d1254 1
a1254 1
LOCAL FUNCTION
d1256 1
a1256 1
	info_sharedlibrary_command -- code for "info sharedlibrary"
d1258 1
a1258 1
SYNOPSIS
d1260 1
a1260 1
	static void info_sharedlibrary_command ()
d1262 1
a1262 1
DESCRIPTION
d1264 3
a1266 3
	Walk through the shared library list and print information
	about each attached library.
*/
d1273 1
a1273 1
  register struct so_list *so = NULL;  	/* link map state variable */
d1280 1
a1280 1
      printf_unfiltered ("No exec file.\n");
d1285 1
a1285 1
  addr_width = 8+4;
d1288 1
a1288 1
  addr_width = 16+4;
d1294 1
a1294 1
      if (so -> so_name[0])
d1298 3
a1300 3
	      printf_unfiltered("%-*s%-*s%-12s%s\n", addr_width, "From",
				addr_width, "To", "Syms Read",
				"Shared Object Library");
d1305 2
a1306 2
		  local_hex_string_custom ((unsigned long) LM_ADDR (so),
					   addr_fmt));
d1308 4
a1311 4
		  local_hex_string_custom ((unsigned long) so -> lmend,
					   addr_fmt));
	  printf_unfiltered ("%-12s", so -> symbols_loaded ? "Yes" : "No");
	  printf_unfiltered ("%s\n",  so -> so_name);
d1316 1
a1316 1
      printf_unfiltered ("No shared libraries loaded at this time.\n");	
d1322 1
a1322 1
GLOBAL FUNCTION
d1324 1
a1324 1
	solib_address -- check to see if an address is in a shared lib
d1326 1
a1326 1
SYNOPSIS
d1328 1
a1328 1
	char * solib_address (CORE_ADDR address)
d1330 1
a1330 1
DESCRIPTION
d1332 6
a1337 6
	Provides a hook for other gdb routines to discover whether or
	not a particular address is within the mapped address space of
	a shared library.  Any address between the base mapping address
	and the first address beyond the end of the last mapping, is
	considered to be within the shared library address space, for
	our purposes.
d1339 3
a1341 3
	For example, this routine is called at one point to disable
	breakpoints which are in shared libraries that are not currently
	mapped in.
d1348 2
a1349 2
  register struct so_list *so = 0;   	/* link map state variable */
  
d1352 1
a1352 1
      if (so -> so_name[0])
d1355 1
a1355 1
	      (address < (CORE_ADDR) so -> lmend))
d1364 2
a1365 2
void 
clear_solib()
d1369 25
a1393 1
  
d1396 1
a1396 1
      if (so_list_head -> sections)
d1398 1
a1398 1
	  free ((PTR)so_list_head -> sections);
d1400 1
a1400 1
      if (so_list_head -> abfd)
d1402 2
a1403 2
	  bfd_filename = bfd_get_filename (so_list_head -> abfd);
	  if (!bfd_close (so_list_head -> abfd))
d1411 1
a1411 1
      next = so_list_head -> next;
d1413 2
a1414 2
	free ((PTR)bfd_filename);
      free ((PTR)so_list_head);
d1450 1
a1450 1
LOCAL FUNCTION
d1452 1
a1452 1
	disable_break -- remove the "mapping changed" breakpoint
d1454 1
a1454 1
SYNOPSIS
d1456 1
a1456 1
	static int disable_break ()
d1458 1
a1458 1
DESCRIPTION
d1460 2
a1461 2
	Removes the breakpoint that gets hit when the dynamic linker
	completes a mapping change.
d1463 1
a1463 1
*/
d1475 1
a1475 1
  
d1491 1
a1491 1
#else	/* SVR4_SHARED_LIBS */
d1501 1
a1501 1
#endif	/* !SVR4_SHARED_LIBS */
d1515 1
a1515 1
#endif	/* #ifdef SVR4_SHARED_LIBS */
d1519 1
a1519 1
LOCAL FUNCTION
d1521 1
a1521 1
	enable_break -- arrange for dynamic linker to hit breakpoint
d1523 1
a1523 1
SYNOPSIS
d1525 1
a1525 1
	int enable_break (void)
d1527 32
a1558 32
DESCRIPTION

	Both the SunOS and the SVR4 dynamic linkers have, as part of their
	debugger interface, support for arranging for the inferior to hit
	a breakpoint after mapping in the shared libraries.  This function
	enables that breakpoint.

	For SunOS, there is a special flag location (in_debugger) which we
	set to 1.  When the dynamic linker sees this flag set, it will set
	a breakpoint at a location known only to itself, after saving the
	original contents of that place and the breakpoint address itself,
	in it's own internal structures.  When we resume the inferior, it
	will eventually take a SIGTRAP when it runs into the breakpoint.
	We handle this (in a different place) by restoring the contents of
	the breakpointed location (which is only known after it stops),
	chasing around to locate the shared libraries that have been
	loaded, then resuming.

	For SVR4, the debugger interface structure contains a member (r_brk)
	which is statically initialized at the time the shared library is
	built, to the offset of a function (_r_debug_state) which is guaran-
	teed to be called once before mapping in a library, and again when
	the mapping is complete.  At the time we are examining this member,
	it contains only the unrelocated offset of the function, so we have
	to do our own relocation.  Later, when the dynamic linker actually
	runs, it relocates r_brk to be the actual address of _r_debug_state().

	The debugger interface structure also contains an enumeration which
	is set to either RT_ADD or RT_DELETE prior to changing the mapping,
	depending upon whether or not the library is being mapped or unmapped,
	and then set to RT_CONSISTENT after the library is mapped/unmapped.
*/
d1595 1
a1595 1
#else	/* SVR4_SHARED_LIBS */
d1623 1
a1623 1
	 the contents specify the dynamic linker this program uses.  */
d1630 2
a1631 2
	 loaded so that we can load its symbols and place a breakpoint
	 in the dynamic linker itself.
d1633 4
a1636 4
	 This address is stored on the stack.  However, I've been unable
	 to find any magic formula to find it for Solaris (appears to
	 be trivial on GNU/Linux).  Therefore, we have to try an alternate
	 mechanism to find the dynamic linker's base address.  */
d1650 2
a1651 2
	 current pc (which point at the entry point for the dynamic
	 linker) and subtracting the offset of the entry point.  */
d1655 1
a1655 1
	 text and plt section for in_svr4_dynsym_resolve_code.  */
d1691 2
a1692 2
	 linker.  Warn and drop into the old code.  */
bkpt_at_symbol:
d1714 1
a1714 1
#endif	/* BKPT_AT_SYMBOL */
d1716 1
a1716 1
#endif	/* !SVR4_SHARED_LIBS */
d1720 1
a1720 1
  
a1721 47
  
GLOBAL FUNCTION
  
	solib_create_inferior_hook -- shared library startup support
  
SYNOPSIS
  
	void solib_create_inferior_hook()
  
DESCRIPTION
  
	When gdb starts up the inferior, it nurses it along (through the
	shell) until it is ready to execute it's first instruction.  At this
	point, this function gets called via expansion of the macro
	SOLIB_CREATE_INFERIOR_HOOK.

	For SunOS executables, this first instruction is typically the
	one at "_start", or a similar text label, regardless of whether
	the executable is statically or dynamically linked.  The runtime
	startup code takes care of dynamically linking in any shared
	libraries, once gdb allows the inferior to continue.

	For SVR4 executables, this first instruction is either the first
	instruction in the dynamic linker (for dynamically linked
	executables) or the instruction at "start" for statically linked
	executables.  For dynamically linked executables, the system
	first exec's /lib/libc.so.N, which contains the dynamic linker,
	and starts it running.  The dynamic linker maps in any needed
	shared libraries, maps in the actual user executable, and then
	jumps to "start" in the user executable.

	For both SunOS shared libraries, and SVR4 shared libraries, we
	can arrange to cooperate with the dynamic linker to discover the
	names of shared libraries that are dynamically linked, and the
	base addresses to which they are linked.

	This function is responsible for discovering those names and
	addresses, and saving sufficient information about them to allow
	their symbols to be read at a later time.

FIXME

	Between enable_break() and disable_break(), this code does not
	properly handle hitting breakpoints which the user might have
	set in the startup code or in the dynamic linker itself.  Proper
	handling will probably have to wait until the implementation is
	changed to use the "breakpoint handler function" method.
d1723 5
a1727 2
	Also, what if child has exit()ed?  Must exit loop somehow.
  */
d1729 46
a1774 2
void 
solib_create_inferior_hook()
d1840 1
a1840 1
LOCAL FUNCTION
d1842 1
a1842 1
	special_symbol_handling -- additional shared library symbol handling
d1844 1
a1844 1
SYNOPSIS
d1846 1
a1846 1
	void special_symbol_handling (struct so_list *so)
d1848 1
a1848 1
DESCRIPTION
d1850 3
a1852 3
	Once the symbols from a shared object have been loaded in the usual
	way, we are called to do any system specific symbol handling that 
	is needed.
d1854 4
a1857 4
	For SunOS4, this consists of grunging around in the dynamic
	linkers structures to find symbol definitions for "common" symbols
	and adding them to the minimal symbol table for the runtime common
	objfile.
d1859 1
a1859 1
*/
d1863 1
a1863 1
struct so_list *so;
d1882 1
a1882 1
	 (byteorder, size, alignment, etc).  */
d1893 1
a1893 1
    return;		/* unreadable */
d1902 1
a1902 1
#endif	/* !SVR4_SHARED_LIBS */
d1908 1
a1908 1
LOCAL FUNCTION
d1910 1
a1910 1
	sharedlibrary_command -- handle command to explicitly add library
d1912 1
a1912 1
SYNOPSIS
d1914 1
a1914 1
	static void sharedlibrary_command (char *args, int from_tty)
d1916 1
a1916 1
DESCRIPTION
d1918 1
a1918 1
*/
d1922 2
a1923 2
char *args;
int from_tty;
d1932 1
a1932 1
_initialize_solib()
d1938 1
a1938 1
  add_info ("sharedlibrary", info_sharedlibrary_command, 
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d1313 1
a1313 1

@


1.1.1.3
log
@import gdb-1999-06-28 snapshot
@
text
@d1309 1
a1309 1
clear_solib ()
a1312 24

  /* This function is expected to handle ELF shared libraries.  It is
     also used on Solaris, which can run either ELF or a.out binaries
     (for compatibility with SunOS 4), both of which can use shared
     libraries.  So we don't know whether we have an ELF executable or
     an a.out executable until the user chooses an executable file.

     ELF shared libraries don't get mapped into the address space
     until after the program starts, so we'd better not try to insert
     breakpoints in them immediately.  We have to wait until the
     dynamic linker has loaded them; we'll hit a bp_shlib_event
     breakpoint (look for calls to create_solib_event_breakpoint) when
     it's ready.

     SunOS shared libraries seem to be different --- they're present
     as soon as the process begins execution, so there's no need to
     put off inserting breakpoints.  There's also nowhere to put a
     bp_shlib_event breakpoint, so if we put it off, we'll never get
     around to it.

     So: disable breakpoints only if we're using ELF shared libs.  */
  if (exec_bfd != NULL
      && bfd_get_flavour (exec_bfd) != bfd_target_aout_flavour)
    disable_breakpoints_in_shlibs (1);
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d4 2
d7 13
a19 16
   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d37 1
a37 1
#include <a.out.h>
d58 1
a58 1
#define MAX_PATH_SIZE 512	/* FIXME: Should be dynamic */
d69 1
a69 2
static char *solib_break_names[] =
{
d81 1
a81 2
static char *bkpt_names[] =
{
d94 1
a94 2
static char *debug_base_symbols[] =
{
d101 1
a101 2
static char *main_name_list[] =
{
d121 1
a121 1
#else /* SVR4_SHARED_LIBS */
d131 1
a131 1
#endif /* !SVR4_SHARED_LIBS */
d133 14
a146 15
struct so_list
  {
    struct so_list *next;	/* next structure in linked list */
    struct link_map lm;		/* copy of link map from inferior */
    struct link_map *lmaddr;	/* addr in inferior lm was read from */
    CORE_ADDR lmend;		/* upper addr bound of mapped object */
    char so_name[MAX_PATH_SIZE];	/* shared object lib name (FIXME) */
    char symbols_loaded;	/* flag: symbols read in yet? */
    char from_tty;		/* flag: print msgs? */
    struct objfile *objfile;	/* objfile for loaded lib */
    struct section_table *sections;
    struct section_table *sections_end;
    struct section_table *textsection;
    bfd *abfd;
  };
d149 1
a149 1
static CORE_ADDR debug_base;	/* Base of dynamic linker structures */
d152 1
a152 1
static int solib_cleanup_queued = 0;	/* make_run_cleanup called */
d155 1
a155 1
fdmatch PARAMS ((int, int));	/* In libiberty */
d180 1
a180 1
  find_solib PARAMS ((struct so_list *));
d183 1
a183 1
  first_link_map_member PARAMS ((void));
d186 1
a186 1
  locate_base PARAMS ((void));
d193 1
a193 1
  elf_locate_base PARAMS ((void));
d221 1
a221 1
   LOCAL FUNCTION
d223 1
a223 1
   solib_map_sections -- open bfd and build sections for shared lib
d225 1
a225 1
   SYNOPSIS
d227 1
a227 1
   static int solib_map_sections (struct so_list *so)
d229 1
a229 1
   DESCRIPTION
d231 5
a235 5
   Given a pointer to one of the shared objects in our list
   of mapped objects, use the recorded name to open a bfd
   descriptor for the object, build a section table, and then
   relocate all the section addresses by the base address at
   which the shared object was mapped.
d237 1
a237 1
   FIXMES
d239 5
a243 5
   In most (all?) cases the shared object file name recorded in the
   dynamic linkage tables will be a fully qualified pathname.  For
   cases where it isn't, do we really mimic the systems search
   mechanism correctly in the below code (particularly the tilde
   expansion stuff?).
d257 3
a259 3

  filename = tilde_expand (so->so_name);

d289 1
a289 1
    scratch_chan = openp (get_in_environ (inferior_environ, "PATH"),
d293 2
a294 2
      scratch_chan = openp (get_in_environ
			    (inferior_environ, "LD_LIBRARY_PATH"),
d311 2
a312 2
  so->abfd = abfd;
  abfd->cacheable = true;
d325 1
a325 1
  if (build_section_table (abfd, &so->sections, &so->sections_end))
d327 1
a327 1
      error ("Can't find the file sections in `%s': %s",
d331 1
a331 1
  for (p = so->sections; p < so->sections_end; p++)
d334 6
a339 6
         object's file by the base address to which the object was actually
         mapped. */
      p->addr += (CORE_ADDR) LM_ADDR (so);
      p->endaddr += (CORE_ADDR) LM_ADDR (so);
      so->lmend = (CORE_ADDR) max (p->endaddr, so->lmend);
      if (STREQ (p->the_bfd_section->name, ".text"))
d341 1
a341 1
	  so->textsection = p;
d363 2
a364 2
  objfile->md = NULL;
  obstack_specify_allocation (&objfile->psymbol_cache.cache, 0, 0,
d366 1
a366 1
  obstack_specify_allocation (&objfile->psymbol_obstack, 0, 0, xmalloc,
d368 1
a368 1
  obstack_specify_allocation (&objfile->symbol_obstack, 0, 0, xmalloc,
d370 1
a370 1
  obstack_specify_allocation (&objfile->type_obstack, 0, 0, xmalloc,
d372 1
a372 1
  objfile->name = mstrsave (objfile->md, "rt_common");
d376 1
a376 1
  objfile->next = NULL;
d382 3
a384 3
	   last_one->next;
	   last_one = last_one->next);
      last_one->next = objfile;
d396 1
a396 1
     struct rtc_symb *rtc_symp;
d405 1
a405 1
  if (rt_common_objfile != NULL && rt_common_objfile->minimal_symbol_count)
d407 2
a408 2
      obstack_free (&rt_common_objfile->symbol_obstack, 0);
      obstack_specify_allocation (&rt_common_objfile->symbol_obstack, 0, 0,
d410 2
a411 2
      rt_common_objfile->minimal_symbol_count = 0;
      rt_common_objfile->msymbols = NULL;
d424 1
a424 1
		   sizeof (inferior_rtc_nlist));
d452 1
a452 1
#endif /* SVR4_SHARED_LIBS */
d458 1
a458 1
  bfd_lookup_symbol PARAMS ((bfd *, char *));
d462 1
a462 1
   LOCAL FUNCTION
d464 1
a464 1
   bfd_lookup_symbol -- lookup the value for a specific symbol
d466 1
a466 1
   SYNOPSIS
d468 1
a468 1
   CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname)
d470 1
a470 1
   DESCRIPTION
d472 4
a475 4
   An expensive way to lookup the value of a single symbol for
   bfd's that are only temporary anyway.  This is used by the
   shared library support to find the address of the debugger
   interface structures in the shared library.
d477 3
a479 3
   Note that 0 is specifically allowed as an error return (no
   such symbol).
 */
d493 1
a493 1

d499 3
a501 3
      back_to = make_cleanup (free, (PTR) symbol_table);
      number_of_symbols = bfd_canonicalize_symtab (abfd, symbol_table);

d505 1
a505 1
	  if (STREQ (sym->name, symname))
d508 1
a508 1
	      symaddr = sym->value + sym->section->vma;
d520 19
a538 20
   Solaris BCP (the part of Solaris which allows it to run SunOS4
   a.out files) throws in another wrinkle. Solaris does not fill
   in the usual a.out link map structures when running BCP programs,
   the only way to get at them is via groping around in the dynamic
   linker.
   The dynamic linker and it's structures are located in the shared
   C library, which gets run as the executable's "interpreter" by
   the kernel.

   Note that we can assume nothing about the process state at the time
   we need to find these structures.  We may be stopped on the first
   instruction of the interpreter (C shared library), the first
   instruction of the executable itself, or somewhere else entirely
   (if we attached to the process for example).
 */

static char *debug_base_symbols[] =
{
  "r_debug",			/* Solaris 2.3 */
  "_r_debug",			/* Solaris 2.1, 2.2 */
d547 1
a547 1
   LOCAL FUNCTION
d549 1
a549 1
   look_for_base -- examine file for each mapped address segment
d551 1
a551 1
   SYNOPSYS
d553 1
a553 1
   static int look_for_base (int fd, CORE_ADDR baseaddr)
d555 1
a555 1
   DESCRIPTION
d557 4
a560 4
   This function is passed to proc_iterate_over_mappings, which
   causes it to get called once for each mapped address space, with
   an open file descriptor for the file mapped to that space, and the
   base address of that mapped space.
d562 3
a564 3
   Our job is to find the debug base symbol in the file that this
   fd is open on, if it exists, and if so, initialize the dynamic
   linker structure base address debug_base.
d566 3
a568 3
   Note that this is a computationally expensive proposition, since
   we basically have to open a bfd on every call, so we specifically
   avoid opening the exec file.
d586 1
a586 1
	  && fdmatch (fileno ((FILE *) (exec_bfd->iostream)), fd)))
d602 1
a602 1
         interp_bfd.  */
d621 1
a621 1
         interp_bfd.  */
d648 1
a648 1
   LOCAL FUNCTION
d650 2
a651 2
   elf_locate_base -- locate the base address of dynamic linker structs
   for SVR4 elf targets.
d653 1
a653 1
   SYNOPSIS
d655 1
a655 1
   CORE_ADDR elf_locate_base (void)
d657 1
a657 1
   DESCRIPTION
d659 8
a666 8
   For SVR4 elf targets the address of the dynamic linker's runtime
   structure is contained within the dynamic info section in the
   executable file.  The dynamic section is also mapped into the
   inferior address space.  Because the runtime loader fills in the
   real address before starting the inferior, we have to read in the
   dynamic info section from the inferior address space.
   If there are any errors while trying to find the address, we
   silently return 0, otherwise the found address is returned.
d699 1
a699 1
      Elf32_External_Dyn *x_dynp = (Elf32_External_Dyn *) buf;
d730 1
a730 1
      Elf64_External_Dyn *x_dynp = (Elf64_External_Dyn *) buf;
d749 1
a749 1
#endif /* SVR4_SHARED_LIBS */
d753 1
a753 1
   LOCAL FUNCTION
d755 1
a755 1
   locate_base -- locate the base address of dynamic linker structs
d757 1
a757 1
   SYNOPSIS
d759 1
a759 1
   CORE_ADDR locate_base (void)
d761 24
a784 24
   DESCRIPTION

   For both the SunOS and SVR4 shared library implementations, if the
   inferior executable has been linked dynamically, there is a single
   address somewhere in the inferior's data space which is the key to
   locating all of the dynamic linker's runtime structures.  This
   address is the value of the debug base symbol.  The job of this
   function is to find and return that address, or to return 0 if there
   is no such address (the executable is statically linked for example).

   For SunOS, the job is almost trivial, since the dynamic linker and
   all of it's structures are statically linked to the executable at
   link time.  Thus the symbol for the address we are looking for has
   already been added to the minimal symbol table for the executable's
   objfile at the time the symbol file's symbols were read, and all we
   have to do is look it up there.  Note that we explicitly do NOT want
   to find the copies in the shared library.

   The SVR4 version is a bit more complicated because the address
   is contained somewhere in the dynamic info section.  We have to go
   to a lot more work to discover the address of the debug base symbol.
   Because of this complexity, we cache the value we find and return that
   value on subsequent invocations.  Note there is no copy in the
   executable symbol tables.
d813 1
a813 1
#else /* SVR4_SHARED_LIBS */
d833 1
a833 1
#endif /* !SVR4_SHARED_LIBS */
d839 1
a839 1
   LOCAL FUNCTION
d841 1
a841 1
   first_link_map_member -- locate first member in dynamic linker's map
d843 1
a843 1
   SYNOPSIS
d845 1
a845 1
   static struct link_map *first_link_map_member (void)
d847 1
a847 1
   DESCRIPTION
d849 4
a852 4
   Read in a copy of the first member in the inferior's dynamic
   link map from the inferior's dynamic linker structures, and return
   a pointer to the copy in our address space.
 */
d865 1
a865 1
         structure and find the address of the link map list from it. */
d871 1
a871 1
#else /* SVR4_SHARED_LIBS */
d879 1
a879 1
#endif /* !SVR4_SHARED_LIBS */
d886 1
a886 1
   LOCAL FUNCTION
d888 1
a888 1
   find_solib -- step through list of shared objects
d890 1
a890 1
   SYNOPSIS
d892 1
a892 1
   struct so_list *find_solib (struct so_list *so_list_ptr)
d894 1
a894 1
   DESCRIPTION
d896 6
a901 6
   This module contains the routine which finds the names of any
   loaded "images" in the current process. The argument in must be
   NULL on the first call, and then the returned value must be passed
   in on subsequent calls. This provides the capability to "step" down
   the list of loaded objects. On the last object, a NULL value is
   returned.
d903 2
a904 2
   The arg and return value are "struct link_map" pointers, as defined
   in <link.h>.
d914 1
a914 1

d926 1
a926 1
	         link map list member. */
d934 1
a934 1
         the shared library list.  Advance to the next shared object. */
d939 2
a940 2
	  int status = target_read_memory ((CORE_ADDR) so_list_ptr->lmaddr,
					   (char *) &(so_list_ptr->lm),
d951 1
a951 1
      so_list_next = so_list_ptr->next;
d956 1
a956 1
         abbreviated load_map structure */
d959 1
a959 1
      new->lmaddr = lm;
d961 1
a961 1
         node if this is the first one. */
d964 1
a964 1
	  so_list_ptr->next = new;
d970 1
a970 1
	  if (!solib_cleanup_queued)
d975 2
a976 2

	}
d978 1
a978 1
      read_memory ((CORE_ADDR) lm, (char *) &(new->lm),
d981 5
a985 5
         inferior executable, so we must ignore it.  For some versions of
         SVR4, it has no name.  For others (Solaris 2.3 for example), it
         does have a name, so we can no longer use a missing name to
         decide when to ignore it. */
      if (!IGNORE_FIRST_LINK_MAP_ENTRY (new->lm))
d997 2
a998 2
	  strncpy (new->so_name, buffer, MAX_PATH_SIZE - 1);
	  new->so_name[MAX_PATH_SIZE - 1] = '\0';
d1003 1
a1003 1
	}
d1014 1
a1014 1
  register struct so_list *so = (struct so_list *) arg;		/* catch_errs bogon */
d1017 3
a1019 3
  if (so->textsection)
    text_addr = so->textsection->addr;
  else if (so->abfd != NULL)
d1024 1
a1024 1
         text_addr so that the relocation in symbol_file_add does no harm.  */
d1026 1
a1026 1
      lowest_sect = bfd_get_section_by_name (so->abfd, ".text");
d1028 2
a1029 2
	bfd_map_over_sections (so->abfd, find_lowest_section,
			       (PTR) & lowest_sect);
d1031 8
a1038 2
	text_addr = bfd_section_vma (so->abfd, lowest_sect)
	  + (CORE_ADDR) LM_ADDR (so);
d1040 2
a1041 8

  ALL_OBJFILES (so->objfile)
  {
    if (strcmp (so->objfile->name, so->so_name) == 0)
      return 1;
  }
  so->objfile =
    symbol_file_add (so->so_name, so->from_tty,
d1050 2
a1051 3
static int
match_main (soname)
     char *soname;
d1066 1
a1066 1
   GLOBAL FUNCTION
d1068 1
a1068 1
   solib_add -- add a shared library file to the symtab and section list
d1070 1
a1070 1
   SYNOPSIS
d1072 2
a1073 2
   void solib_add (char *arg_string, int from_tty,
   struct target_ops *target)
d1075 1
a1075 1
   DESCRIPTION
d1077 1
a1077 1
 */
d1084 2
a1085 2
{
  register struct so_list *so = NULL;	/* link map state variable */
d1093 1
a1093 1

d1098 1
a1098 1

d1108 1
a1108 1
	  if (so->so_name[0] && !match_main (so->so_name))
d1110 1
a1110 1
	      count += so->sections_end - so->sections;
d1113 1
a1113 1

d1122 1
a1122 1

d1124 1
a1124 1
	  if (target->to_sections)
d1126 4
a1129 4
	      old = target->to_sections_end - target->to_sections;
	      target->to_sections = (struct section_table *)
		xrealloc ((char *) target->to_sections,
			  (sizeof (struct section_table)) * (count + old));
d1134 1
a1134 1
	      target->to_sections = (struct section_table *)
d1137 2
a1138 2
	  target->to_sections_end = target->to_sections + (count + old);

d1150 1
a1150 1
	      if (so->so_name[0])
d1152 3
a1154 3
		  count = so->sections_end - so->sections;
		  memcpy ((char *) (target->to_sections + old),
			  so->sections,
d1161 1
a1161 1

d1165 2
a1166 2
      if (so->so_name[0] && re_exec (so->so_name) &&
	  !match_main (so->so_name))
d1168 2
a1169 2
	  so->from_tty = from_tty;
	  if (so->symbols_loaded)
d1173 1
a1173 1
		  printf_unfiltered ("Symbols already loaded for %s\n", so->so_name);
d1182 1
a1182 1
	      so->symbols_loaded = 1;
d1198 1
a1198 1
   LOCAL FUNCTION
d1200 1
a1200 1
   info_sharedlibrary_command -- code for "info sharedlibrary"
d1202 1
a1202 1
   SYNOPSIS
d1204 1
a1204 1
   static void info_sharedlibrary_command ()
d1206 1
a1206 1
   DESCRIPTION
d1208 3
a1210 3
   Walk through the shared library list and print information
   about each attached library.
 */
d1217 1
a1217 1
  register struct so_list *so = NULL;	/* link map state variable */
d1229 1
a1229 1
  addr_width = 8 + 4;
d1232 1
a1232 1
  addr_width = 16 + 4;
d1238 1
a1238 1
      if (so->so_name[0])
d1242 3
a1244 3
	      printf_unfiltered ("%-*s%-*s%-12s%s\n", addr_width, "From",
				 addr_width, "To", "Syms Read",
				 "Shared Object Library");
d1249 2
a1250 2
		      local_hex_string_custom ((unsigned long) LM_ADDR (so),
					       addr_fmt));
d1252 4
a1255 4
			 local_hex_string_custom ((unsigned long) so->lmend,
						  addr_fmt));
	  printf_unfiltered ("%-12s", so->symbols_loaded ? "Yes" : "No");
	  printf_unfiltered ("%s\n", so->so_name);
d1260 1
a1260 1
      printf_unfiltered ("No shared libraries loaded at this time.\n");
d1266 1
a1266 1
   GLOBAL FUNCTION
d1268 1
a1268 1
   solib_address -- check to see if an address is in a shared lib
d1270 1
a1270 1
   SYNOPSIS
d1272 1
a1272 1
   char * solib_address (CORE_ADDR address)
d1274 1
a1274 1
   DESCRIPTION
d1276 6
a1281 6
   Provides a hook for other gdb routines to discover whether or
   not a particular address is within the mapped address space of
   a shared library.  Any address between the base mapping address
   and the first address beyond the end of the last mapping, is
   considered to be within the shared library address space, for
   our purposes.
d1283 3
a1285 3
   For example, this routine is called at one point to disable
   breakpoints which are in shared libraries that are not currently
   mapped in.
d1292 2
a1293 2
  register struct so_list *so = 0;	/* link map state variable */

d1296 1
a1296 1
      if (so->so_name[0])
d1299 1
a1299 1
	      (address < (CORE_ADDR) so->lmend))
d1308 1
a1308 1
void
d1340 1
a1340 1
      if (so_list_head->sections)
d1342 1
a1342 1
	  free ((PTR) so_list_head->sections);
d1344 1
a1344 1
      if (so_list_head->abfd)
d1346 2
a1347 2
	  bfd_filename = bfd_get_filename (so_list_head->abfd);
	  if (!bfd_close (so_list_head->abfd))
d1355 1
a1355 1
      next = so_list_head->next;
d1357 2
a1358 2
	free ((PTR) bfd_filename);
      free ((PTR) so_list_head);
d1394 1
a1394 1
   LOCAL FUNCTION
d1396 1
a1396 1
   disable_break -- remove the "mapping changed" breakpoint
d1398 1
a1398 1
   SYNOPSIS
d1400 1
a1400 1
   static int disable_break ()
d1402 1
a1402 1
   DESCRIPTION
d1404 2
a1405 2
   Removes the breakpoint that gets hit when the dynamic linker
   completes a mapping change.
d1407 1
a1407 1
 */
d1419 1
a1419 1

d1435 1
a1435 1
#else /* SVR4_SHARED_LIBS */
d1445 1
a1445 1
#endif /* !SVR4_SHARED_LIBS */
d1459 1
a1459 1
#endif /* #ifdef SVR4_SHARED_LIBS */
d1463 1
a1463 1
   LOCAL FUNCTION
d1465 1
a1465 1
   enable_break -- arrange for dynamic linker to hit breakpoint
d1467 1
a1467 1
   SYNOPSIS
d1469 1
a1469 1
   int enable_break (void)
d1471 32
a1502 32
   DESCRIPTION

   Both the SunOS and the SVR4 dynamic linkers have, as part of their
   debugger interface, support for arranging for the inferior to hit
   a breakpoint after mapping in the shared libraries.  This function
   enables that breakpoint.

   For SunOS, there is a special flag location (in_debugger) which we
   set to 1.  When the dynamic linker sees this flag set, it will set
   a breakpoint at a location known only to itself, after saving the
   original contents of that place and the breakpoint address itself,
   in it's own internal structures.  When we resume the inferior, it
   will eventually take a SIGTRAP when it runs into the breakpoint.
   We handle this (in a different place) by restoring the contents of
   the breakpointed location (which is only known after it stops),
   chasing around to locate the shared libraries that have been
   loaded, then resuming.

   For SVR4, the debugger interface structure contains a member (r_brk)
   which is statically initialized at the time the shared library is
   built, to the offset of a function (_r_debug_state) which is guaran-
   teed to be called once before mapping in a library, and again when
   the mapping is complete.  At the time we are examining this member,
   it contains only the unrelocated offset of the function, so we have
   to do our own relocation.  Later, when the dynamic linker actually
   runs, it relocates r_brk to be the actual address of _r_debug_state().

   The debugger interface structure also contains an enumeration which
   is set to either RT_ADD or RT_DELETE prior to changing the mapping,
   depending upon whether or not the library is being mapped or unmapped,
   and then set to RT_CONSISTENT after the library is mapped/unmapped.
 */
d1539 1
a1539 1
#else /* SVR4_SHARED_LIBS */
d1567 1
a1567 1
         the contents specify the dynamic linker this program uses.  */
d1574 2
a1575 2
         loaded so that we can load its symbols and place a breakpoint
         in the dynamic linker itself.
d1577 4
a1580 4
         This address is stored on the stack.  However, I've been unable
         to find any magic formula to find it for Solaris (appears to
         be trivial on GNU/Linux).  Therefore, we have to try an alternate
         mechanism to find the dynamic linker's base address.  */
d1594 2
a1595 2
         current pc (which point at the entry point for the dynamic
         linker) and subtracting the offset of the entry point.  */
d1599 1
a1599 1
         text and plt section for in_svr4_dynsym_resolve_code.  */
d1635 2
a1636 2
         linker.  Warn and drop into the old code.  */
    bkpt_at_symbol:
d1658 1
a1658 1
#endif /* BKPT_AT_SYMBOL */
d1660 1
a1660 1
#endif /* !SVR4_SHARED_LIBS */
d1664 1
a1664 1

d1666 47
d1714 2
a1715 46
   GLOBAL FUNCTION

   solib_create_inferior_hook -- shared library startup support

   SYNOPSIS

   void solib_create_inferior_hook()

   DESCRIPTION

   When gdb starts up the inferior, it nurses it along (through the
   shell) until it is ready to execute it's first instruction.  At this
   point, this function gets called via expansion of the macro
   SOLIB_CREATE_INFERIOR_HOOK.

   For SunOS executables, this first instruction is typically the
   one at "_start", or a similar text label, regardless of whether
   the executable is statically or dynamically linked.  The runtime
   startup code takes care of dynamically linking in any shared
   libraries, once gdb allows the inferior to continue.

   For SVR4 executables, this first instruction is either the first
   instruction in the dynamic linker (for dynamically linked
   executables) or the instruction at "start" for statically linked
   executables.  For dynamically linked executables, the system
   first exec's /lib/libc.so.N, which contains the dynamic linker,
   and starts it running.  The dynamic linker maps in any needed
   shared libraries, maps in the actual user executable, and then
   jumps to "start" in the user executable.

   For both SunOS shared libraries, and SVR4 shared libraries, we
   can arrange to cooperate with the dynamic linker to discover the
   names of shared libraries that are dynamically linked, and the
   base addresses to which they are linked.

   This function is responsible for discovering those names and
   addresses, and saving sufficient information about them to allow
   their symbols to be read at a later time.

   FIXME

   Between enable_break() and disable_break(), this code does not
   properly handle hitting breakpoints which the user might have
   set in the startup code or in the dynamic linker itself.  Proper
   handling will probably have to wait until the implementation is
   changed to use the "breakpoint handler function" method.
d1717 2
a1718 5
   Also, what if child has exit()ed?  Must exit loop somehow.
 */

void
solib_create_inferior_hook ()
d1784 1
a1784 1
   LOCAL FUNCTION
d1786 1
a1786 1
   special_symbol_handling -- additional shared library symbol handling
d1788 1
a1788 1
   SYNOPSIS
d1790 1
a1790 1
   void special_symbol_handling (struct so_list *so)
d1792 1
a1792 1
   DESCRIPTION
d1794 3
a1796 3
   Once the symbols from a shared object have been loaded in the usual
   way, we are called to do any system specific symbol handling that 
   is needed.
d1798 4
a1801 4
   For SunOS4, this consists of grunging around in the dynamic
   linkers structures to find symbol definitions for "common" symbols
   and adding them to the minimal symbol table for the runtime common
   objfile.
d1803 1
a1803 1
 */
d1807 1
a1807 1
     struct so_list *so;
d1826 1
a1826 1
         (byteorder, size, alignment, etc).  */
d1837 1
a1837 1
    return;			/* unreadable */
d1846 1
a1846 1
#endif /* !SVR4_SHARED_LIBS */
d1852 1
a1852 1
   LOCAL FUNCTION
d1854 1
a1854 1
   sharedlibrary_command -- handle command to explicitly add library
d1856 1
a1856 1
   SYNOPSIS
d1858 1
a1858 1
   static void sharedlibrary_command (char *args, int from_tty)
d1860 1
a1860 1
   DESCRIPTION
d1862 1
a1862 1
 */
d1866 2
a1867 2
     char *args;
     int from_tty;
d1876 1
a1876 1
_initialize_solib ()
d1882 1
a1882 1
  add_info ("sharedlibrary", info_sharedlibrary_command,
@


1.1.1.5
log
@import gdb-1999-08-09 snapshot
@
text
@d1036 1
a1036 1
			       (PTR) &lowest_sect);
@


1.1.1.6
log
@import gdb-1999-08-30 snapshot
@
text
@d34 1
a890 64
#ifdef SVR4_SHARED_LIBS
/*

  LOCAL FUNCTION

  open_exec_file_object

  SYNOPSIS

  void open_symbol_file_object (int from_tty)

  DESCRIPTION

  If no open symbol file, attempt to locate and open the main symbol
  file.  On SVR4 systems, this is the first link map entry.  If its
  name is here, we can open it.  Useful when attaching to a process
  without first loading its symbol file.

 */

int
open_symbol_file_object (arg)
     PTR arg;
{
  int from_tty = (int) arg;	/* sneak past catch_errors */
  struct link_map *lm, lmcopy;
  char *filename;
  int errcode;

  if (symfile_objfile)
    if (!query ("Attempt to reload symbols from process? "))
      return 0;

  if ((debug_base = locate_base ()) == 0)
    return 0;	/* failed somehow... */

  /* First link map member should be the executable.  */
  if ((lm = first_link_map_member ()) == NULL)
    return 0;	/* failed somehow... */

  /* Read from target memory to GDB.  */
  read_memory ((CORE_ADDR) lm, (void *) &lmcopy, sizeof (lmcopy));

  if (lmcopy.l_name == 0)
    return 0;	/* no filename.  */

  /* Now fetch the filename from target memory.  */
  target_read_string ((CORE_ADDR) lmcopy.l_name, &filename, 
		      MAX_PATH_SIZE - 1, &errcode);
  if (errcode)
    {
      warning ("failed to read exec filename from attached file: %s",
	       safe_strerror (errcode));
      return 0;
    }

  make_cleanup ((make_cleanup_func) free, (void *) filename);
  /* Have a pathname: read the symbol file.  */
  symbol_file_command (filename, from_tty);

  return 1;
}
#endif /* SVR4_SHARED_LIBS */

a1100 12

#ifdef SVR4_SHARED_LIBS
  /* If we are attaching to a running process for which we 
     have not opened a symbol file, we may be able to get its 
     symbols now!  */
  if (attach_flag &&
      symfile_objfile == NULL)
    catch_errors (open_symbol_file_object, (PTR) from_tty, 
		  "Error reading attached process's symbol file.\n",
		  RETURN_MASK_ALL);

#endif SVR4_SHARED_LIBS
@


1.1.1.7
log
@import gdb-1999-09-28 snapshot
@
text
@d1177 1
a1177 1
  if ((re_err = re_comp (arg_string? arg_string : ".")) != NULL)
d1199 31
a1229 1
	  
a1230 1
	  old = target_resize_to_sections (target, count);
@


1.1.1.8
log
@import gdb-1999-10-04 snapshot
@
text
@a1085 1
  struct section_addr_info section_addrs;
a1086 1
  memset (&section_addrs, 0, sizeof (section_addrs));
a1109 1
  section_addrs.text_addr = text_addr;
d1112 2
a1113 2
		     &section_addrs,
		     0, 0, 0, 1);
@


1.1.1.9
log
@import gdb-1999-10-11 snapshot
@
text
@d1115 2
a1116 1
		     &section_addrs, 0, OBJF_SHARED);
@


1.1.1.10
log
@import gdb-1999-11-16 snapshot
@
text
@d1280 1
a1280 1
      printf_unfiltered ("No executable file.\n");
@


