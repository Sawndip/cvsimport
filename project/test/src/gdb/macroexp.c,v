head	1.33;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.32
	gdb_7_6-2013-04-26-release:1.32
	gdb_7_6-branch:1.32.0.2
	gdb_7_6-2013-03-12-branchpoint:1.32
	gdb_7_5_1-2012-11-29-release:1.30
	gdb_7_5-2012-08-17-release:1.30
	gdb_7_5-branch:1.30.0.2
	gdb_7_5-2012-07-18-branchpoint:1.30
	gdb_7_4_1-2012-04-26-release:1.27.4.1
	gdb_7_4-2012-01-24-release:1.27.4.1
	gdb_7_4-branch:1.27.0.4
	gdb_7_4-2011-12-13-branchpoint:1.27
	gdb_7_3_1-2011-09-04-release:1.27
	gdb_7_3-2011-07-26-release:1.27
	gdb_7_3-branch:1.27.0.2
	gdb_7_3-2011-04-01-branchpoint:1.27
	gdb_7_2-2010-09-02-release:1.22
	gdb_7_2-branch:1.22.0.2
	gdb_7_2-2010-07-07-branchpoint:1.22
	gdb_7_1-2010-03-18-release:1.20
	gdb_7_1-branch:1.20.0.2
	gdb_7_1-2010-02-18-branchpoint:1.20
	gdb_7_0_1-2009-12-22-release:1.19
	gdb_7_0-2009-10-06-release:1.19
	gdb_7_0-branch:1.19.0.4
	gdb_7_0-2009-09-16-branchpoint:1.19
	arc-sim-20090309:1.13
	msnyder-checkpoint-072509-branch:1.19.0.2
	msnyder-checkpoint-072509-branchpoint:1.19
	arc-insight_6_8-branch:1.13.0.10
	arc-insight_6_8-branchpoint:1.13
	insight_6_8-branch:1.13.0.8
	insight_6_8-branchpoint:1.13
	reverse-20081226-branch:1.17.0.2
	reverse-20081226-branchpoint:1.17
	multiprocess-20081120-branch:1.16.0.4
	multiprocess-20081120-branchpoint:1.16
	reverse-20080930-branch:1.16.0.2
	reverse-20080930-branchpoint:1.16
	reverse-20080717-branch:1.13.0.6
	reverse-20080717-branchpoint:1.13
	msnyder-reverse-20080609-branch:1.13.0.4
	msnyder-reverse-20080609-branchpoint:1.13
	drow-reverse-20070409-branch:1.10.0.2
	drow-reverse-20070409-branchpoint:1.10
	gdb_6_8-2008-03-27-release:1.13
	gdb_6_8-branch:1.13.0.2
	gdb_6_8-2008-02-26-branchpoint:1.13
	gdb_6_7_1-2007-10-29-release:1.12
	gdb_6_7-2007-10-10-release:1.12
	gdb_6_7-branch:1.12.0.2
	gdb_6_7-2007-09-07-branchpoint:1.12
	insight_6_6-20070208-release:1.9
	gdb_6_6-2006-12-18-release:1.9
	gdb_6_6-branch:1.9.0.18
	gdb_6_6-2006-11-15-branchpoint:1.9
	insight_6_5-20061003-release:1.9
	gdb-csl-symbian-6_4_50_20060226-12:1.9
	gdb-csl-sourcerygxx-3_4_4-25:1.7
	nickrob-async-20060828-mergepoint:1.9
	gdb-csl-symbian-6_4_50_20060226-11:1.9
	gdb-csl-sourcerygxx-4_1-17:1.9
	gdb-csl-20060226-branch-local-2:1.9
	gdb-csl-sourcerygxx-4_1-14:1.9
	gdb-csl-sourcerygxx-4_1-13:1.9
	gdb-csl-sourcerygxx-4_1-12:1.9
	gdb-csl-sourcerygxx-3_4_4-21:1.9
	gdb_6_5-20060621-release:1.9
	gdb-csl-sourcerygxx-4_1-9:1.9
	gdb-csl-sourcerygxx-4_1-8:1.9
	gdb-csl-sourcerygxx-4_1-7:1.9
	gdb-csl-arm-2006q1-6:1.9
	gdb-csl-sourcerygxx-4_1-6:1.9
	gdb-csl-symbian-6_4_50_20060226-10:1.9
	gdb-csl-symbian-6_4_50_20060226-9:1.9
	gdb-csl-symbian-6_4_50_20060226-8:1.9
	gdb-csl-coldfire-4_1-11:1.9
	gdb-csl-sourcerygxx-3_4_4-19:1.9
	gdb-csl-coldfire-4_1-10:1.9
	gdb_6_5-branch:1.9.0.16
	gdb_6_5-2006-05-14-branchpoint:1.9
	gdb-csl-sourcerygxx-4_1-5:1.9
	nickrob-async-20060513-branch:1.9.0.14
	nickrob-async-20060513-branchpoint:1.9
	gdb-csl-sourcerygxx-4_1-4:1.9
	msnyder-reverse-20060502-branch:1.9.0.12
	msnyder-reverse-20060502-branchpoint:1.9
	gdb-csl-morpho-4_1-4:1.9
	gdb-csl-sourcerygxx-3_4_4-17:1.9
	readline_5_1-import-branch:1.9.0.10
	readline_5_1-import-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.9
	gdb-csl-symbian-20060226-branch:1.9.0.8
	gdb-csl-symbian-20060226-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.9
	msnyder-reverse-20060331-branch:1.9.0.6
	msnyder-reverse-20060331-branchpoint:1.9
	gdb-csl-available-20060303-branch:1.9.0.4
	gdb-csl-available-20060303-branchpoint:1.9
	gdb-csl-20060226-branch:1.9.0.2
	gdb-csl-20060226-branchpoint:1.9
	gdb_6_4-20051202-release:1.7
	msnyder-fork-checkpoint-branch:1.7.0.12
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.7.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.7
	gdb_6_4-branch:1.7.0.8
	gdb_6_4-2005-11-01-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.6
	gdb-csl-arm-20051020-branchpoint:1.7
	msnyder-tracepoint-checkpoint-branch:1.7.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb-csl-arm-20050325-2005-q1b:1.7
	gdb-csl-arm-20050325-2005-q1a:1.7
	csl-arm-20050325-branch:1.7.0.2
	csl-arm-20050325-branchpoint:1.7
	gdb-post-i18n-errorwarning-20050211:1.6
	gdb-pre-i18n-errorwarning-20050211:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.20
	gdb_6_3-20041019-branchpoint:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.22
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.18
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.16
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.14
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.12
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.10
	drow_intercu-20040221-branchpoint:1.5
	cagney_bfdfile-20040213-branch:1.5.0.8
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.6
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.5.0.4
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.2
	cagney_x86i386-20030821-branch:1.4.0.46
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.44
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.40
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.38
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.34
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.30
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.28
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.26
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.24
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.22
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.20
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.18
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.16
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030203-mergepoint:1.4
	interps-20030202-branch:1.4.0.14
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.12
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.4
	carlton_dictionary-20021115-merge:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.10
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.8
	carlton_dictionary-20020920-branchpoint:1.4
	gdb_5_3-branch:1.4.0.6
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.4
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.2
	readline_4_3-import-branchpoint:1.4
	kseitz_interps-20020528-branch:1.3.0.4
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.2
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.33
date	2013.10.02.00.46.06;	author kseitz;	state Exp;
branches;
next	1.32;

1.32
date	2013.01.31.18.37.37;	author aristovski;	state Exp;
branches;
next	1.31;

1.31
date	2013.01.01.06.32.47;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2012.05.21.15.27.24;	author tromey;	state Exp;
branches;
next	1.29;

1.29
date	2012.05.16.20.31.09;	author tromey;	state Exp;
branches;
next	1.28;

1.28
date	2012.01.04.08.17.06;	author brobecke;	state Exp;
branches;
next	1.27;

1.27
date	2011.03.31.15.40.44;	author bauermann;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2011.01.09.03.20.33;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2011.01.05.22.22.49;	author msnyder;	state Exp;
branches;
next	1.24;

1.24
date	2011.01.01.15.33.10;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2010.08.18.19.13.33;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.16.00.18.02;	author msnyder;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.06.19.41.11;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2010.01.01.07.31.37;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.20.23.04.33;	author tromey;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.12.17.03.37;	author tromey;	state Exp;
branches;
next	1.16;

1.16
date	2008.09.27.21.40.48;	author tromey;	state Exp;
branches;
next	1.15;

1.15
date	2008.07.27.01.58.01;	author tromey;	state Exp;
branches;
next	1.14;

1.14
date	2008.07.18.20.55.32;	author tromey;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.05.21.41.09;	author jimb;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.09.17.58.52;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.15.20.26.02;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.11.18.13.51;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.11.04.05.56;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.09.03.14.02;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.29.22.55.26;	author cagney;	state Exp;
branches
	1.4.8.1
	1.4.10.1;
next	1.3;

1.3
date	2002.05.14.21.31.05;	author jimb;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2002.05.13.18.13.07;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.08.18.26.26;	author jimb;	state dead;
branches
	1.1.2.1;
next	;

1.27.4.1
date	2012.01.06.04.43.20;	author brobecke;	state Exp;
branches;
next	;

1.4.8.1
date	2003.09.17.21.28.25;	author carlton;	state Exp;
branches;
next	;

1.4.10.1
date	2003.12.14.20.27.21;	author drow;	state Exp;
branches;
next	;

1.3.4.1
date	2002.08.09.18.34.25;	author kseitz;	state Exp;
branches;
next	;

1.1.2.1
date	2002.05.08.18.26.26;	author jimb;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.05.09.15.04.42;	author jimb;	state dead;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.05.09.15.18.32;	author jimb;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.05.10.16.26.59;	author jimb;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Constification of parse_linespec and fallout:
https://sourceware.org/ml/gdb-patches/2013-09/msg01017.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01018.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01019.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01020.html
@
text
@/* C preprocessor macro expansion for GDB.
   Copyright (C) 2002-2013 Free Software Foundation, Inc.
   Contributed by Red Hat, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdb_obstack.h"
#include "bcache.h"
#include "macrotab.h"
#include "macroexp.h"
#include "gdb_assert.h"
#include "c-lang.h"



/* A resizeable, substringable string type.  */


/* A string type that we can resize, quickly append to, and use to
   refer to substrings of other strings.  */
struct macro_buffer
{
  /* An array of characters.  The first LEN bytes are the real text,
     but there are SIZE bytes allocated to the array.  If SIZE is
     zero, then this doesn't point to a malloc'ed block.  If SHARED is
     non-zero, then this buffer is actually a pointer into some larger
     string, and we shouldn't append characters to it, etc.  Because
     of sharing, we can't assume in general that the text is
     null-terminated.  */
  char *text;

  /* The number of characters in the string.  */
  int len;

  /* The number of characters allocated to the string.  If SHARED is
     non-zero, this is meaningless; in this case, we set it to zero so
     that any "do we have room to append something?" tests will fail,
     so we don't always have to check SHARED before using this field.  */
  int size;

  /* Zero if TEXT can be safely realloc'ed (i.e., it's its own malloc
     block).  Non-zero if TEXT is actually pointing into the middle of
     some other block, and we shouldn't reallocate it.  */
  int shared;

  /* For detecting token splicing. 

     This is the index in TEXT of the first character of the token
     that abuts the end of TEXT.  If TEXT contains no tokens, then we
     set this equal to LEN.  If TEXT ends in whitespace, then there is
     no token abutting the end of TEXT (it's just whitespace), and
     again, we set this equal to LEN.  We set this to -1 if we don't
     know the nature of TEXT.  */
  int last_token;

  /* If this buffer is holding the result from get_token, then this 
     is non-zero if it is an identifier token, zero otherwise.  */
  int is_identifier;
};


/* Set the macro buffer *B to the empty string, guessing that its
   final contents will fit in N bytes.  (It'll get resized if it
   doesn't, so the guess doesn't have to be right.)  Allocate the
   initial storage with xmalloc.  */
static void
init_buffer (struct macro_buffer *b, int n)
{
  b->size = n;
  if (n > 0)
    b->text = (char *) xmalloc (n);
  else
    b->text = NULL;
  b->len = 0;
  b->shared = 0;
  b->last_token = -1;
}


/* Set the macro buffer *BUF to refer to the LEN bytes at ADDR, as a
   shared substring.  */
static void
init_shared_buffer (struct macro_buffer *buf, char *addr, int len)
{
  buf->text = addr;
  buf->len = len;
  buf->shared = 1;
  buf->size = 0;
  buf->last_token = -1;
}


/* Free the text of the buffer B.  Raise an error if B is shared.  */
static void
free_buffer (struct macro_buffer *b)
{
  gdb_assert (! b->shared);
  if (b->size)
    xfree (b->text);
}

/* Like free_buffer, but return the text as an xstrdup()d string.
   This only exists to try to make the API relatively clean.  */

static char *
free_buffer_return_text (struct macro_buffer *b)
{
  gdb_assert (! b->shared);
  gdb_assert (b->size);
  /* Nothing to do.  */
  return b->text;
}

/* A cleanup function for macro buffers.  */
static void
cleanup_macro_buffer (void *untyped_buf)
{
  free_buffer ((struct macro_buffer *) untyped_buf);
}


/* Resize the buffer B to be at least N bytes long.  Raise an error if
   B shouldn't be resized.  */
static void
resize_buffer (struct macro_buffer *b, int n)
{
  /* We shouldn't be trying to resize shared strings.  */
  gdb_assert (! b->shared);
  
  if (b->size == 0)
    b->size = n;
  else
    while (b->size <= n)
      b->size *= 2;

  b->text = xrealloc (b->text, b->size);
}


/* Append the character C to the buffer B.  */
static void
appendc (struct macro_buffer *b, int c)
{
  int new_len = b->len + 1;

  if (new_len > b->size)
    resize_buffer (b, new_len);

  b->text[b->len] = c;
  b->len = new_len;
}


/* Append the LEN bytes at ADDR to the buffer B.  */
static void
appendmem (struct macro_buffer *b, char *addr, int len)
{
  int new_len = b->len + len;

  if (new_len > b->size)
    resize_buffer (b, new_len);

  memcpy (b->text + b->len, addr, len);
  b->len = new_len;
}



/* Recognizing preprocessor tokens.  */


int
macro_is_whitespace (int c)
{
  return (c == ' '
          || c == '\t'
          || c == '\n'
          || c == '\v'
          || c == '\f');
}


int
macro_is_digit (int c)
{
  return ('0' <= c && c <= '9');
}


int
macro_is_identifier_nondigit (int c)
{
  return (c == '_'
          || ('a' <= c && c <= 'z')
          || ('A' <= c && c <= 'Z'));
}


static void
set_token (struct macro_buffer *tok, char *start, char *end)
{
  init_shared_buffer (tok, start, end - start);
  tok->last_token = 0;

  /* Presumed; get_identifier may overwrite this.  */
  tok->is_identifier = 0;
}


static int
get_comment (struct macro_buffer *tok, char *p, char *end)
{
  if (p + 2 > end)
    return 0;
  else if (p[0] == '/'
           && p[1] == '*')
    {
      char *tok_start = p;

      p += 2;

      for (; p < end; p++)
        if (p + 2 <= end
            && p[0] == '*'
            && p[1] == '/')
          {
            p += 2;
            set_token (tok, tok_start, p);
            return 1;
          }

      error (_("Unterminated comment in macro expansion."));
    }
  else if (p[0] == '/'
           && p[1] == '/')
    {
      char *tok_start = p;

      p += 2;
      for (; p < end; p++)
        if (*p == '\n')
          break;

      set_token (tok, tok_start, p);
      return 1;
    }
  else
    return 0;
}


static int
get_identifier (struct macro_buffer *tok, char *p, char *end)
{
  if (p < end
      && macro_is_identifier_nondigit (*p))
    {
      char *tok_start = p;

      while (p < end
             && (macro_is_identifier_nondigit (*p)
                 || macro_is_digit (*p)))
        p++;

      set_token (tok, tok_start, p);
      tok->is_identifier = 1;
      return 1;
    }
  else
    return 0;
}


static int
get_pp_number (struct macro_buffer *tok, char *p, char *end)
{
  if (p < end
      && (macro_is_digit (*p)
          || (*p == '.'
	      && p + 2 <= end
	      && macro_is_digit (p[1]))))
    {
      char *tok_start = p;

      while (p < end)
        {
	  if (p + 2 <= end
	      && strchr ("eEpP", *p)
	      && (p[1] == '+' || p[1] == '-'))
            p += 2;
          else if (macro_is_digit (*p)
		   || macro_is_identifier_nondigit (*p)
		   || *p == '.')
            p++;
          else
            break;
        }

      set_token (tok, tok_start, p);
      return 1;
    }
  else
    return 0;
}



/* If the text starting at P going up to (but not including) END
   starts with a character constant, set *TOK to point to that
   character constant, and return 1.  Otherwise, return zero.
   Signal an error if it contains a malformed or incomplete character
   constant.  */
static int
get_character_constant (struct macro_buffer *tok, char *p, char *end)
{
  /* ISO/IEC 9899:1999 (E)  Section 6.4.4.4  paragraph 1 
     But of course, what really matters is that we handle it the same
     way GDB's C/C++ lexer does.  So we call parse_escape in utils.c
     to handle escape sequences.  */
  if ((p + 1 <= end && *p == '\'')
      || (p + 2 <= end
	  && (p[0] == 'L' || p[0] == 'u' || p[0] == 'U')
	  && p[1] == '\''))
    {
      char *tok_start = p;
      int char_count = 0;

      if (*p == '\'')
        p++;
      else if (*p == 'L' || *p == 'u' || *p == 'U')
        p += 2;
      else
        gdb_assert_not_reached ("unexpected character constant");

      for (;;)
        {
          if (p >= end)
            error (_("Unmatched single quote."));
          else if (*p == '\'')
            {
              if (!char_count)
                error (_("A character constant must contain at least one "
                       "character."));
              p++;
              break;
            }
          else if (*p == '\\')
            {
	      const char *s, *o;

	      s = o = ++p;
	      char_count += c_parse_escape (&s, NULL);
	      p += s - o;
            }
          else
	    {
	      p++;
	      char_count++;
	    }
        }

      set_token (tok, tok_start, p);
      return 1;
    }
  else
    return 0;
}


/* If the text starting at P going up to (but not including) END
   starts with a string literal, set *TOK to point to that string
   literal, and return 1.  Otherwise, return zero.  Signal an error if
   it contains a malformed or incomplete string literal.  */
static int
get_string_literal (struct macro_buffer *tok, char *p, char *end)
{
  if ((p + 1 <= end
       && *p == '"')
      || (p + 2 <= end
          && (p[0] == 'L' || p[0] == 'u' || p[0] == 'U')
          && p[1] == '"'))
    {
      char *tok_start = p;

      if (*p == '"')
        p++;
      else if (*p == 'L' || *p == 'u' || *p == 'U')
        p += 2;
      else
        gdb_assert_not_reached ("unexpected string literal");

      for (;;)
        {
          if (p >= end)
            error (_("Unterminated string in expression."));
          else if (*p == '"')
            {
              p++;
              break;
            }
          else if (*p == '\n')
            error (_("Newline characters may not appear in string "
                   "constants."));
          else if (*p == '\\')
            {
	      const char *s, *o;

	      s = o = ++p;
	      c_parse_escape (&s, NULL);
	      p += s - o;
            }
          else
            p++;
        }

      set_token (tok, tok_start, p);
      return 1;
    }
  else
    return 0;
}


static int
get_punctuator (struct macro_buffer *tok, char *p, char *end)
{
  /* Here, speed is much less important than correctness and clarity.  */

  /* ISO/IEC 9899:1999 (E)  Section 6.4.6  Paragraph 1.
     Note that this table is ordered in a special way.  A punctuator
     which is a prefix of another punctuator must appear after its
     "extension".  Otherwise, the wrong token will be returned.  */
  static const char * const punctuators[] = {
    "[", "]", "(", ")", "{", "}", "?", ";", ",", "~",
    "...", ".",
    "->", "--", "-=", "-",
    "++", "+=", "+",
    "*=", "*",
    "!=", "!",
    "&&", "&=", "&",
    "/=", "/",
    "%>", "%:%:", "%:", "%=", "%",
    "^=", "^",
    "##", "#",
    ":>", ":",
    "||", "|=", "|",
    "<<=", "<<", "<=", "<:", "<%", "<",
    ">>=", ">>", ">=", ">",
    "==", "=",
    0
  };

  int i;

  if (p + 1 <= end)
    {
      for (i = 0; punctuators[i]; i++)
        {
          const char *punctuator = punctuators[i];

          if (p[0] == punctuator[0])
            {
              int len = strlen (punctuator);

              if (p + len <= end
                  && ! memcmp (p, punctuator, len))
                {
                  set_token (tok, p, p + len);
                  return 1;
                }
            }
        }
    }

  return 0;
}


/* Peel the next preprocessor token off of SRC, and put it in TOK.
   Mutate TOK to refer to the first token in SRC, and mutate SRC to
   refer to the text after that token.  SRC must be a shared buffer;
   the resulting TOK will be shared, pointing into the same string SRC
   does.  Initialize TOK's last_token field.  Return non-zero if we
   succeed, or 0 if we didn't find any more tokens in SRC.  */
static int
get_token (struct macro_buffer *tok,
           struct macro_buffer *src)
{
  char *p = src->text;
  char *end = p + src->len;

  gdb_assert (src->shared);

  /* From the ISO C standard, ISO/IEC 9899:1999 (E), section 6.4:

     preprocessing-token: 
         header-name
         identifier
         pp-number
         character-constant
         string-literal
         punctuator
         each non-white-space character that cannot be one of the above

     We don't have to deal with header-name tokens, since those can
     only occur after a #include, which we will never see.  */

  while (p < end)
    if (macro_is_whitespace (*p))
      p++;
    else if (get_comment (tok, p, end))
      p += tok->len;
    else if (get_pp_number (tok, p, end)
             || get_character_constant (tok, p, end)
             || get_string_literal (tok, p, end)
             /* Note: the grammar in the standard seems to be
                ambiguous: L'x' can be either a wide character
                constant, or an identifier followed by a normal
                character constant.  By trying `get_identifier' after
                we try get_character_constant and get_string_literal,
                we give the wide character syntax precedence.  Now,
                since GDB doesn't handle wide character constants
                anyway, is this the right thing to do?  */
             || get_identifier (tok, p, end)
             || get_punctuator (tok, p, end))
      {
        /* How many characters did we consume, including whitespace?  */
        int consumed = p - src->text + tok->len;

        src->text += consumed;
        src->len -= consumed;
        return 1;
      }
    else 
      {
        /* We have found a "non-whitespace character that cannot be
           one of the above."  Make a token out of it.  */
        int consumed;

        set_token (tok, p, p + 1);
        consumed = p - src->text + tok->len;
        src->text += consumed;
        src->len -= consumed;
        return 1;
      }

  return 0;
}



/* Appending token strings, with and without splicing  */


/* Append the macro buffer SRC to the end of DEST, and ensure that
   doing so doesn't splice the token at the end of SRC with the token
   at the beginning of DEST.  SRC and DEST must have their last_token
   fields set.  Upon return, DEST's last_token field is set correctly.

   For example:

   If DEST is "(" and SRC is "y", then we can return with
   DEST set to "(y" --- we've simply appended the two buffers.

   However, if DEST is "x" and SRC is "y", then we must not return
   with DEST set to "xy" --- that would splice the two tokens "x" and
   "y" together to make a single token "xy".  However, it would be
   fine to return with DEST set to "x y".  Similarly, "<" and "<" must
   yield "< <", not "<<", etc.  */
static void
append_tokens_without_splicing (struct macro_buffer *dest,
                                struct macro_buffer *src)
{
  int original_dest_len = dest->len;
  struct macro_buffer dest_tail, new_token;

  gdb_assert (src->last_token != -1);
  gdb_assert (dest->last_token != -1);
  
  /* First, just try appending the two, and call get_token to see if
     we got a splice.  */
  appendmem (dest, src->text, src->len);

  /* If DEST originally had no token abutting its end, then we can't
     have spliced anything, so we're done.  */
  if (dest->last_token == original_dest_len)
    {
      dest->last_token = original_dest_len + src->last_token;
      return;
    }

  /* Set DEST_TAIL to point to the last token in DEST, followed by
     all the stuff we just appended.  */
  init_shared_buffer (&dest_tail,
                      dest->text + dest->last_token,
                      dest->len - dest->last_token);

  /* Re-parse DEST's last token.  We know that DEST used to contain
     at least one token, so if it doesn't contain any after the
     append, then we must have spliced "/" and "*" or "/" and "/" to
     make a comment start.  (Just for the record, I got this right
     the first time.  This is not a bug fix.)  */
  if (get_token (&new_token, &dest_tail)
      && (new_token.text + new_token.len
          == dest->text + original_dest_len))
    {
      /* No splice, so we're done.  */
      dest->last_token = original_dest_len + src->last_token;
      return;
    }

  /* Okay, a simple append caused a splice.  Let's chop dest back to
     its original length and try again, but separate the texts with a
     space.  */
  dest->len = original_dest_len;
  appendc (dest, ' ');
  appendmem (dest, src->text, src->len);

  init_shared_buffer (&dest_tail,
                      dest->text + dest->last_token,
                      dest->len - dest->last_token);

  /* Try to re-parse DEST's last token, as above.  */
  if (get_token (&new_token, &dest_tail)
      && (new_token.text + new_token.len
          == dest->text + original_dest_len))
    {
      /* No splice, so we're done.  */
      dest->last_token = original_dest_len + 1 + src->last_token;
      return;
    }

  /* As far as I know, there's no case where inserting a space isn't
     enough to prevent a splice.  */
  internal_error (__FILE__, __LINE__,
                  _("unable to avoid splicing tokens during macro expansion"));
}

/* Stringify an argument, and insert it into DEST.  ARG is the text to
   stringify; it is LEN bytes long.  */

static void
stringify (struct macro_buffer *dest, const char *arg, int len)
{
  /* Trim initial whitespace from ARG.  */
  while (len > 0 && macro_is_whitespace (*arg))
    {
      ++arg;
      --len;
    }

  /* Trim trailing whitespace from ARG.  */
  while (len > 0 && macro_is_whitespace (arg[len - 1]))
    --len;

  /* Insert the string.  */
  appendc (dest, '"');
  while (len > 0)
    {
      /* We could try to handle strange cases here, like control
	 characters, but there doesn't seem to be much point.  */
      if (macro_is_whitespace (*arg))
	{
	  /* Replace a sequence of whitespace with a single space.  */
	  appendc (dest, ' ');
	  while (len > 1 && macro_is_whitespace (arg[1]))
	    {
	      ++arg;
	      --len;
	    }
	}
      else if (*arg == '\\' || *arg == '"')
	{
	  appendc (dest, '\\');
	  appendc (dest, *arg);
	}
      else
	appendc (dest, *arg);
      ++arg;
      --len;
    }
  appendc (dest, '"');
  dest->last_token = dest->len;
}

/* See macroexp.h.  */

char *
macro_stringify (const char *str)
{
  struct macro_buffer buffer;
  int len = strlen (str);

  init_buffer (&buffer, len);
  stringify (&buffer, str, len);
  appendc (&buffer, '\0');

  return free_buffer_return_text (&buffer);
}


/* Expanding macros!  */


/* A singly-linked list of the names of the macros we are currently 
   expanding --- for detecting expansion loops.  */
struct macro_name_list {
  const char *name;
  struct macro_name_list *next;
};


/* Return non-zero if we are currently expanding the macro named NAME,
   according to LIST; otherwise, return zero.

   You know, it would be possible to get rid of all the NO_LOOP
   arguments to these functions by simply generating a new lookup
   function and baton which refuses to find the definition for a
   particular macro, and otherwise delegates the decision to another
   function/baton pair.  But that makes the linked list of excluded
   macros chained through untyped baton pointers, which will make it
   harder to debug.  :(  */
static int
currently_rescanning (struct macro_name_list *list, const char *name)
{
  for (; list; list = list->next)
    if (strcmp (name, list->name) == 0)
      return 1;

  return 0;
}


/* Gather the arguments to a macro expansion.

   NAME is the name of the macro being invoked.  (It's only used for
   printing error messages.)

   Assume that SRC is the text of the macro invocation immediately
   following the macro name.  For example, if we're processing the
   text foo(bar, baz), then NAME would be foo and SRC will be (bar,
   baz).

   If SRC doesn't start with an open paren ( token at all, return
   zero, leave SRC unchanged, and don't set *ARGC_P to anything.

   If SRC doesn't contain a properly terminated argument list, then
   raise an error.
   
   For a variadic macro, NARGS holds the number of formal arguments to
   the macro.  For a GNU-style variadic macro, this should be the
   number of named arguments.  For a non-variadic macro, NARGS should
   be -1.

   Otherwise, return a pointer to the first element of an array of
   macro buffers referring to the argument texts, and set *ARGC_P to
   the number of arguments we found --- the number of elements in the
   array.  The macro buffers share their text with SRC, and their
   last_token fields are initialized.  The array is allocated with
   xmalloc, and the caller is responsible for freeing it.

   NOTE WELL: if SRC starts with a open paren ( token followed
   immediately by a close paren ) token (e.g., the invocation looks
   like "foo()"), we treat that as one argument, which happens to be
   the empty list of tokens.  The caller should keep in mind that such
   a sequence of tokens is a valid way to invoke one-parameter
   function-like macros, but also a valid way to invoke zero-parameter
   function-like macros.  Eeew.

   Consume the tokens from SRC; after this call, SRC contains the text
   following the invocation.  */

static struct macro_buffer *
gather_arguments (const char *name, struct macro_buffer *src,
		  int nargs, int *argc_p)
{
  struct macro_buffer tok;
  int args_len, args_size;
  struct macro_buffer *args = NULL;
  struct cleanup *back_to = make_cleanup (free_current_contents, &args);

  /* Does SRC start with an opening paren token?  Read from a copy of
     SRC, so SRC itself is unaffected if we don't find an opening
     paren.  */
  {
    struct macro_buffer temp;

    init_shared_buffer (&temp, src->text, src->len);

    if (! get_token (&tok, &temp)
        || tok.len != 1
        || tok.text[0] != '(')
      {
        discard_cleanups (back_to);
        return 0;
      }
  }

  /* Consume SRC's opening paren.  */
  get_token (&tok, src);

  args_len = 0;
  args_size = 6;
  args = (struct macro_buffer *) xmalloc (sizeof (*args) * args_size);

  for (;;)
    {
      struct macro_buffer *arg;
      int depth;

      /* Make sure we have room for the next argument.  */
      if (args_len >= args_size)
        {
          args_size *= 2;
          args = xrealloc (args, sizeof (*args) * args_size);
        }

      /* Initialize the next argument.  */
      arg = &args[args_len++];
      set_token (arg, src->text, src->text);

      /* Gather the argument's tokens.  */
      depth = 0;
      for (;;)
        {
          if (! get_token (&tok, src))
            error (_("Malformed argument list for macro `%s'."), name);
      
          /* Is tok an opening paren?  */
          if (tok.len == 1 && tok.text[0] == '(')
            depth++;

          /* Is tok is a closing paren?  */
          else if (tok.len == 1 && tok.text[0] == ')')
            {
              /* If it's a closing paren at the top level, then that's
                 the end of the argument list.  */
              if (depth == 0)
                {
		  /* In the varargs case, the last argument may be
		     missing.  Add an empty argument in this case.  */
		  if (nargs != -1 && args_len == nargs - 1)
		    {
		      /* Make sure we have room for the argument.  */
		      if (args_len >= args_size)
			{
			  args_size++;
			  args = xrealloc (args, sizeof (*args) * args_size);
			}
		      arg = &args[args_len++];
		      set_token (arg, src->text, src->text);
		    }

                  discard_cleanups (back_to);
                  *argc_p = args_len;
                  return args;
                }

              depth--;
            }

          /* If tok is a comma at top level, then that's the end of
             the current argument.  However, if we are handling a
             variadic macro and we are computing the last argument, we
             want to include the comma and remaining tokens.  */
          else if (tok.len == 1 && tok.text[0] == ',' && depth == 0
		   && (nargs == -1 || args_len < nargs))
            break;

          /* Extend the current argument to enclose this token.  If
             this is the current argument's first token, leave out any
             leading whitespace, just for aesthetics.  */
          if (arg->len == 0)
            {
              arg->text = tok.text;
              arg->len = tok.len;
              arg->last_token = 0;
            }
          else
            {
              arg->len = (tok.text + tok.len) - arg->text;
              arg->last_token = tok.text - arg->text;
            }
        }
    }
}


/* The `expand' and `substitute_args' functions both invoke `scan'
   recursively, so we need a forward declaration somewhere.  */
static void scan (struct macro_buffer *dest,
                  struct macro_buffer *src,
                  struct macro_name_list *no_loop,
                  macro_lookup_ftype *lookup_func,
                  void *lookup_baton);


/* A helper function for substitute_args.
   
   ARGV is a vector of all the arguments; ARGC is the number of
   arguments.  IS_VARARGS is true if the macro being substituted is a
   varargs macro; in this case VA_ARG_NAME is the name of the
   "variable" argument.  VA_ARG_NAME is ignored if IS_VARARGS is
   false.

   If the token TOK is the name of a parameter, return the parameter's
   index.  If TOK is not an argument, return -1.  */

static int
find_parameter (const struct macro_buffer *tok,
		int is_varargs, const struct macro_buffer *va_arg_name,
		int argc, const char * const *argv)
{
  int i;

  if (! tok->is_identifier)
    return -1;

  for (i = 0; i < argc; ++i)
    if (tok->len == strlen (argv[i]) 
	&& !memcmp (tok->text, argv[i], tok->len))
      return i;

  if (is_varargs && tok->len == va_arg_name->len
      && ! memcmp (tok->text, va_arg_name->text, tok->len))
    return argc - 1;

  return -1;
}
 
/* Given the macro definition DEF, being invoked with the actual
   arguments given by ARGC and ARGV, substitute the arguments into the
   replacement list, and store the result in DEST.

   IS_VARARGS should be true if DEF is a varargs macro.  In this case,
   VA_ARG_NAME should be the name of the "variable" argument -- either
   __VA_ARGS__ for c99-style varargs, or the final argument name, for
   GNU-style varargs.  If IS_VARARGS is false, this parameter is
   ignored.

   If it is necessary to expand macro invocations in one of the
   arguments, use LOOKUP_FUNC and LOOKUP_BATON to find the macro
   definitions, and don't expand invocations of the macros listed in
   NO_LOOP.  */

static void
substitute_args (struct macro_buffer *dest, 
                 struct macro_definition *def,
		 int is_varargs, const struct macro_buffer *va_arg_name,
                 int argc, struct macro_buffer *argv,
                 struct macro_name_list *no_loop,
                 macro_lookup_ftype *lookup_func,
                 void *lookup_baton)
{
  /* A macro buffer for the macro's replacement list.  */
  struct macro_buffer replacement_list;
  /* The token we are currently considering.  */
  struct macro_buffer tok;
  /* The replacement list's pointer from just before TOK was lexed.  */
  char *original_rl_start;
  /* We have a single lookahead token to handle token splicing.  */
  struct macro_buffer lookahead;
  /* The lookahead token might not be valid.  */
  int lookahead_valid;
  /* The replacement list's pointer from just before LOOKAHEAD was
     lexed.  */
  char *lookahead_rl_start;

  init_shared_buffer (&replacement_list, (char *) def->replacement,
                      strlen (def->replacement));

  gdb_assert (dest->len == 0);
  dest->last_token = 0;

  original_rl_start = replacement_list.text;
  if (! get_token (&tok, &replacement_list))
    return;
  lookahead_rl_start = replacement_list.text;
  lookahead_valid = get_token (&lookahead, &replacement_list);

  for (;;)
    {
      /* Just for aesthetics.  If we skipped some whitespace, copy
         that to DEST.  */
      if (tok.text > original_rl_start)
        {
          appendmem (dest, original_rl_start, tok.text - original_rl_start);
          dest->last_token = dest->len;
        }

      /* Is this token the stringification operator?  */
      if (tok.len == 1
          && tok.text[0] == '#')
	{
	  int arg;

	  if (!lookahead_valid)
	    error (_("Stringification operator requires an argument."));

	  arg = find_parameter (&lookahead, is_varargs, va_arg_name,
				def->argc, def->argv);
	  if (arg == -1)
	    error (_("Argument to stringification operator must name "
		     "a macro parameter."));

	  stringify (dest, argv[arg].text, argv[arg].len);

	  /* Read one token and let the loop iteration code handle the
	     rest.  */
	  lookahead_rl_start = replacement_list.text;
	  lookahead_valid = get_token (&lookahead, &replacement_list);
	}
      /* Is this token the splicing operator?  */
      else if (tok.len == 2
	       && tok.text[0] == '#'
	       && tok.text[1] == '#')
	error (_("Stray splicing operator"));
      /* Is the next token the splicing operator?  */
      else if (lookahead_valid
	       && lookahead.len == 2
	       && lookahead.text[0] == '#'
	       && lookahead.text[1] == '#')
	{
	  int finished = 0;
	  int prev_was_comma = 0;

	  /* Note that GCC warns if the result of splicing is not a
	     token.  In the debugger there doesn't seem to be much
	     benefit from doing this.  */

	  /* Insert the first token.  */
	  if (tok.len == 1 && tok.text[0] == ',')
	    prev_was_comma = 1;
	  else
	    {
	      int arg = find_parameter (&tok, is_varargs, va_arg_name,
					def->argc, def->argv);

	      if (arg != -1)
		appendmem (dest, argv[arg].text, argv[arg].len);
	      else
		appendmem (dest, tok.text, tok.len);
	    }

	  /* Apply a possible sequence of ## operators.  */
	  for (;;)
	    {
	      if (! get_token (&tok, &replacement_list))
		error (_("Splicing operator at end of macro"));

	      /* Handle a comma before a ##.  If we are handling
		 varargs, and the token on the right hand side is the
		 varargs marker, and the final argument is empty or
		 missing, then drop the comma.  This is a GNU
		 extension.  There is one ambiguous case here,
		 involving pedantic behavior with an empty argument,
		 but we settle that in favor of GNU-style (GCC uses an
		 option).  If we aren't dealing with varargs, we
		 simply insert the comma.  */
	      if (prev_was_comma)
		{
		  if (! (is_varargs
			 && tok.len == va_arg_name->len
			 && !memcmp (tok.text, va_arg_name->text, tok.len)
			 && argv[argc - 1].len == 0))
		    appendmem (dest, ",", 1);
		  prev_was_comma = 0;
		}

	      /* Insert the token.  If it is a parameter, insert the
		 argument.  If it is a comma, treat it specially.  */
	      if (tok.len == 1 && tok.text[0] == ',')
		prev_was_comma = 1;
	      else
		{
		  int arg = find_parameter (&tok, is_varargs, va_arg_name,
					    def->argc, def->argv);

		  if (arg != -1)
		    appendmem (dest, argv[arg].text, argv[arg].len);
		  else
		    appendmem (dest, tok.text, tok.len);
		}

	      /* Now read another token.  If it is another splice, we
		 loop.  */
	      original_rl_start = replacement_list.text;
	      if (! get_token (&tok, &replacement_list))
		{
		  finished = 1;
		  break;
		}

	      if (! (tok.len == 2
		     && tok.text[0] == '#'
		     && tok.text[1] == '#'))
		break;
	    }

	  if (prev_was_comma)
	    {
	      /* We saw a comma.  Insert it now.  */
	      appendmem (dest, ",", 1);
	    }

          dest->last_token = dest->len;
	  if (finished)
	    lookahead_valid = 0;
	  else
	    {
	      /* Set up for the loop iterator.  */
	      lookahead = tok;
	      lookahead_rl_start = original_rl_start;
	      lookahead_valid = 1;
	    }
	}
      else
	{
	  /* Is this token an identifier?  */
	  int substituted = 0;
	  int arg = find_parameter (&tok, is_varargs, va_arg_name,
				    def->argc, def->argv);

	  if (arg != -1)
	    {
	      struct macro_buffer arg_src;

	      /* Expand any macro invocations in the argument text,
		 and append the result to dest.  Remember that scan
		 mutates its source, so we need to scan a new buffer
		 referring to the argument's text, not the argument
		 itself.  */
	      init_shared_buffer (&arg_src, argv[arg].text, argv[arg].len);
	      scan (dest, &arg_src, no_loop, lookup_func, lookup_baton);
	      substituted = 1;
	    }

	  /* If it wasn't a parameter, then just copy it across.  */
	  if (! substituted)
	    append_tokens_without_splicing (dest, &tok);
	}

      if (! lookahead_valid)
	break;

      tok = lookahead;
      original_rl_start = lookahead_rl_start;

      lookahead_rl_start = replacement_list.text;
      lookahead_valid = get_token (&lookahead, &replacement_list);
    }
}


/* Expand a call to a macro named ID, whose definition is DEF.  Append
   its expansion to DEST.  SRC is the input text following the ID
   token.  We are currently rescanning the expansions of the macros
   named in NO_LOOP; don't re-expand them.  Use LOOKUP_FUNC and
   LOOKUP_BATON to find definitions for any nested macro references.

   Return 1 if we decided to expand it, zero otherwise.  (If it's a
   function-like macro name that isn't followed by an argument list,
   we don't expand it.)  If we return zero, leave SRC unchanged.  */
static int
expand (const char *id,
        struct macro_definition *def, 
        struct macro_buffer *dest,
        struct macro_buffer *src,
        struct macro_name_list *no_loop,
        macro_lookup_ftype *lookup_func,
        void *lookup_baton)
{
  struct macro_name_list new_no_loop;

  /* Create a new node to be added to the front of the no-expand list.
     This list is appropriate for re-scanning replacement lists, but
     it is *not* appropriate for scanning macro arguments; invocations
     of the macro whose arguments we are gathering *do* get expanded
     there.  */
  new_no_loop.name = id;
  new_no_loop.next = no_loop;

  /* What kind of macro are we expanding?  */
  if (def->kind == macro_object_like)
    {
      struct macro_buffer replacement_list;

      init_shared_buffer (&replacement_list, (char *) def->replacement,
                          strlen (def->replacement));

      scan (dest, &replacement_list, &new_no_loop, lookup_func, lookup_baton);
      return 1;
    }
  else if (def->kind == macro_function_like)
    {
      struct cleanup *back_to = make_cleanup (null_cleanup, 0);
      int argc = 0;
      struct macro_buffer *argv = NULL;
      struct macro_buffer substituted;
      struct macro_buffer substituted_src;
      struct macro_buffer va_arg_name = {0};
      int is_varargs = 0;

      if (def->argc >= 1)
	{
	  if (strcmp (def->argv[def->argc - 1], "...") == 0)
	    {
	      /* In C99-style varargs, substitution is done using
		 __VA_ARGS__.  */
	      init_shared_buffer (&va_arg_name, "__VA_ARGS__",
				  strlen ("__VA_ARGS__"));
	      is_varargs = 1;
	    }
	  else
	    {
	      int len = strlen (def->argv[def->argc - 1]);

	      if (len > 3
		  && strcmp (def->argv[def->argc - 1] + len - 3, "...") == 0)
		{
		  /* In GNU-style varargs, the name of the
		     substitution parameter is the name of the formal
		     argument without the "...".  */
		  init_shared_buffer (&va_arg_name,
				      (char *) def->argv[def->argc - 1],
				      len - 3);
		  is_varargs = 1;
		}
	    }
	}

      make_cleanup (free_current_contents, &argv);
      argv = gather_arguments (id, src, is_varargs ? def->argc : -1,
			       &argc);

      /* If we couldn't find any argument list, then we don't expand
         this macro.  */
      if (! argv)
        {
          do_cleanups (back_to);
          return 0;
        }

      /* Check that we're passing an acceptable number of arguments for
         this macro.  */
      if (argc != def->argc)
        {
	  if (is_varargs && argc >= def->argc - 1)
	    {
	      /* Ok.  */
	    }
          /* Remember that a sequence of tokens like "foo()" is a
             valid invocation of a macro expecting either zero or one
             arguments.  */
          else if (! (argc == 1
		      && argv[0].len == 0
		      && def->argc == 0))
            error (_("Wrong number of arguments to macro `%s' "
                   "(expected %d, got %d)."),
                   id, def->argc, argc);
        }

      /* Note that we don't expand macro invocations in the arguments
         yet --- we let subst_args take care of that.  Parameters that
         appear as operands of the stringifying operator "#" or the
         splicing operator "##" don't get macro references expanded,
         so we can't really tell whether it's appropriate to macro-
         expand an argument until we see how it's being used.  */
      init_buffer (&substituted, 0);
      make_cleanup (cleanup_macro_buffer, &substituted);
      substitute_args (&substituted, def, is_varargs, &va_arg_name,
		       argc, argv, no_loop, lookup_func, lookup_baton);

      /* Now `substituted' is the macro's replacement list, with all
         argument values substituted into it properly.  Re-scan it for
         macro references, but don't expand invocations of this macro.

         We create a new buffer, `substituted_src', which points into
         `substituted', and scan that.  We can't scan `substituted'
         itself, since the tokenization process moves the buffer's
         text pointer around, and we still need to be able to find
         `substituted's original text buffer after scanning it so we
         can free it.  */
      init_shared_buffer (&substituted_src, substituted.text, substituted.len);
      scan (dest, &substituted_src, &new_no_loop, lookup_func, lookup_baton);

      do_cleanups (back_to);

      return 1;
    }
  else
    internal_error (__FILE__, __LINE__, _("bad macro definition kind"));
}


/* If the single token in SRC_FIRST followed by the tokens in SRC_REST
   constitute a macro invokation not forbidden in NO_LOOP, append its
   expansion to DEST and return non-zero.  Otherwise, return zero, and
   leave DEST unchanged.

   SRC_FIRST and SRC_REST must be shared buffers; DEST must not be one.
   SRC_FIRST must be a string built by get_token.  */
static int
maybe_expand (struct macro_buffer *dest,
              struct macro_buffer *src_first,
              struct macro_buffer *src_rest,
              struct macro_name_list *no_loop,
              macro_lookup_ftype *lookup_func,
              void *lookup_baton)
{
  gdb_assert (src_first->shared);
  gdb_assert (src_rest->shared);
  gdb_assert (! dest->shared);

  /* Is this token an identifier?  */
  if (src_first->is_identifier)
    {
      /* Make a null-terminated copy of it, since that's what our
         lookup function expects.  */
      char *id = xmalloc (src_first->len + 1);
      struct cleanup *back_to = make_cleanup (xfree, id);

      memcpy (id, src_first->text, src_first->len);
      id[src_first->len] = 0;
          
      /* If we're currently re-scanning the result of expanding
         this macro, don't expand it again.  */
      if (! currently_rescanning (no_loop, id))
        {
          /* Does this identifier have a macro definition in scope?  */
          struct macro_definition *def = lookup_func (id, lookup_baton);

          if (def && expand (id, def, dest, src_rest, no_loop,
                             lookup_func, lookup_baton))
            {
              do_cleanups (back_to);
              return 1;
            }
        }

      do_cleanups (back_to);
    }

  return 0;
}


/* Expand macro references in SRC, appending the results to DEST.
   Assume we are re-scanning the result of expanding the macros named
   in NO_LOOP, and don't try to re-expand references to them.

   SRC must be a shared buffer; DEST must not be one.  */
static void
scan (struct macro_buffer *dest,
      struct macro_buffer *src,
      struct macro_name_list *no_loop,
      macro_lookup_ftype *lookup_func,
      void *lookup_baton)
{
  gdb_assert (src->shared);
  gdb_assert (! dest->shared);

  for (;;)
    {
      struct macro_buffer tok;
      char *original_src_start = src->text;

      /* Find the next token in SRC.  */
      if (! get_token (&tok, src))
        break;

      /* Just for aesthetics.  If we skipped some whitespace, copy
         that to DEST.  */
      if (tok.text > original_src_start)
        {
          appendmem (dest, original_src_start, tok.text - original_src_start);
          dest->last_token = dest->len;
        }

      if (! maybe_expand (dest, &tok, src, no_loop, lookup_func, lookup_baton))
        /* We didn't end up expanding tok as a macro reference, so
           simply append it to dest.  */
        append_tokens_without_splicing (dest, &tok);
    }

  /* Just for aesthetics.  If there was any trailing whitespace in
     src, copy it to dest.  */
  if (src->len)
    {
      appendmem (dest, src->text, src->len);
      dest->last_token = dest->len;
    }
}


char *
macro_expand (const char *source,
              macro_lookup_ftype *lookup_func,
              void *lookup_func_baton)
{
  struct macro_buffer src, dest;
  struct cleanup *back_to;

  init_shared_buffer (&src, (char *) source, strlen (source));

  init_buffer (&dest, 0);
  dest.last_token = 0;
  back_to = make_cleanup (cleanup_macro_buffer, &dest);

  scan (&dest, &src, 0, lookup_func, lookup_func_baton);

  appendc (&dest, '\0');

  discard_cleanups (back_to);
  return dest.text;
}


char *
macro_expand_once (const char *source,
                   macro_lookup_ftype *lookup_func,
                   void *lookup_func_baton)
{
  error (_("Expand-once not implemented yet."));
}


char *
macro_expand_next (const char **lexptr,
                   macro_lookup_ftype *lookup_func,
                   void *lookup_baton)
{
  struct macro_buffer src, dest, tok;
  struct cleanup *back_to;

  /* Set up SRC to refer to the input text, pointed to by *lexptr.  */
  init_shared_buffer (&src, (char *) *lexptr, strlen (*lexptr));

  /* Set up DEST to receive the expansion, if there is one.  */
  init_buffer (&dest, 0);
  dest.last_token = 0;
  back_to = make_cleanup (cleanup_macro_buffer, &dest);

  /* Get the text's first preprocessing token.  */
  if (! get_token (&tok, &src))
    {
      do_cleanups (back_to);
      return 0;
    }

  /* If it's a macro invocation, expand it.  */
  if (maybe_expand (&dest, &tok, &src, 0, lookup_func, lookup_baton))
    {
      /* It was a macro invocation!  Package up the expansion as a
         null-terminated string and return it.  Set *lexptr to the
         start of the next token in the input.  */
      appendc (&dest, '\0');
      discard_cleanups (back_to);
      *lexptr = src.text;
      return dest.text;
    }
  else
    {
      /* It wasn't a macro invocation.  */
      do_cleanups (back_to);
      return 0;
    }
}
@


1.32
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* charset.c (intermediate_encoding): Remove unused i.
	* completer.c (signal_completer): Remove unused i.
	* continuations.c (discard_my_continuations_1): Remove unused
	continuation_ptr.
	* corelow.c (core_close): Remove unuseD name.
	(get_core_siginfo): Remove unused pid.
	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Remove unused
	i, cps.
	* dwarf2loc.c (dwarf2_compile_expr_to_ax): Remove unused base_offset.
	(loclist_describe_location): Remove unused first.
	* event-top.c (command_line_handler): Remove unused got_eof.
	* exec.c (exec_close_1): Remove unused need_symtab_cleanup.
	(resize_section_table): Remove unused old_value.
	* gdb_bfd.c (gdb_bfd_map_section): Remove unused header.
	* gnu-v3-abi.c (compute_vtable_size): Remove unused addr.
	* i386-tdep.c (i386_process_record): Remove unused rex.
	* infcmd.c (get_return_value): Remove unused uiout.
	* jv-lang.c (type_from_class): Remove unused is_array.
	* jv-valprint.c (java_val_print): Remove unused i.
	* linux-nat.c (linux_nat_stop_lwp): Remove unused ptid.
	* linux-thread-db.c (thread_db_find_new_threads_2): Remove unuseD pid.
	* m2-typeprint.c (m2_print_type): Remove unused code.
	* macroexp.c (get_character_constant): Remove unused body_start.
	(macro_stringify): Remove unused result.
	* objc-lang.c (find_methods): Remove unused gdbarch.
	* objfiles.c (filter_overlapping_sections): Remove unused abfd1, abfd2.
	* regcache.c (regcache_cooked_read): Remove unused gdbarch.
	* stack.c (print_frame_args): Remove unused summary.
	* thread.c (thread_apply_command): Remove unused p.
	* valarith.c (value_x_unop): Remove unused mangle_ptr.
	* valops.c (search_struct_method): Remove unused skip.
	* valprint.c (generic_val_print): Remove unused byte_order.
	* varobj.c (varobj_update): Remove unused changed.
	* cli/cli-cmds.c (complete_command): Remove unused next_item.
	(alias_command): Remove unused c.
	* mi/mi-cmd-catch.c (mi_catch_load_unload): Remove unused c.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Remove unused
	format.
	(mi_cmd_data_write_memory): Remove unused word_format.
	(mi_cmd_data_write_memory_bytes): Remove unused r.
	* python/py-gdb-readline.c (gdbpy_readline_wrapper): Remove unused
	p_start, p_end.
	* python/python.c (_initialize_python): Remove unused cmd_name, cmd.
	* tui/tui-disasm.c (tui_set_disassem_content): Remove unused
	line_width.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00766.html
@
text
@d363 5
a367 2
              p++;
	      char_count += c_parse_escape (&p, NULL);
d420 5
a424 2
              p++;
              c_parse_escape (&p, NULL);
d1443 1
a1443 1
macro_expand_next (char **lexptr,
d1451 1
a1451 1
  init_shared_buffer (&src, *lexptr, strlen (*lexptr));
@


1.31
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a339 1
      char *body_start;
a348 1
      body_start = p;
a700 1
  char *result;
@


1.30
log
@	* macroexp.c (macro_stringify): Terminate the string.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2007-2012 Free Software Foundation, Inc.
@


1.29
log
@	PR macros/13205:
	* macrotab.h: (macro_define_special): Declare.
	(enum macro_special_kind): New.
	(struct macro_definition) <argc, replacement>: Update comments.
	* macrotab.c (new_macro_definition): Unconditionally set 'argc'.
	(macro_define_object_internal): New function.
	(macro_define_object): Use it.
	(macro_define_special): New function.
	(fixup_definition): New function.
	(macro_lookup_definition, foreach_macro_in_scope)
	(foreach_macro): Use fixup_definition.
	* macroexp.h (macro_stringify): Declare.
	* macroexp.c (free_buffer_return_text): New function.
	(stringify): Constify "arg".
	(macro_stringify): New function.
	* dwarf2read.c (macro_start_file): Call macro_define_special.
testsuite
	* gdb.base/macscp1.c (macscp_expr): Add comment.
	* gdb.base/macscp.exp: Test __FILE__ and __LINE__.
@
text
@d707 1
@


1.28
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d116 11
d653 1
a653 1
stringify (struct macro_buffer *dest, char *arg, int len)
d696 15
@


1.27
log
@	* macroexp.c (expand): Avoid uninitialized variable
	compiler warning.
@
text
@d2 1
a2 2
   Copyright (C) 2002, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.27.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 2002, 2007-2012 Free Software Foundation, Inc.
@


1.26
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* m2-exp.y: Comment cleanup, mostly periods and spaces.
	* m2-lang.c: Ditto.
	* m2-typeprint.c: Ditto.
	* m2-valprint.c: Ditto.
	* m32c-tdep.c: Ditto.
	* m32r-linux-nat.c: Ditto.
	* m32r-rom.c: Ditto.
	* m32r-tdep.c: Ditto.
	* m32r-tdep.h: Ditto.
	* m68hc11-tdep.c: Ditto.
	* m58klinux-nat.c: Ditto.
	* m68k-tdep.c: Ditto.
	* m88k-tdep.c: Ditto.
	* m88k-tdep.h: Ditto.
	* machoread.c: Ditto.
	* macrocmd.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* mdebugread.h: Ditto.
	* memattr.c: Ditto.
	* memattr.h: Ditto.
	* memory-map.h: Ditto.
	* mep-tdep.c: Ditto.
	* microblaze-rom.c: Ditto.
	* microblaze-tdep.c: Ditto.
	* minsyms.c: Ditto.
	* mips-irix-tdep.c: Ditto.
	* mips-linux-nat.c: Ditto.
	* mips-linux-tdep.c: Ditto.
	* mips-linux-tdep.h: Ditto.
	* mipsnbsd-nat.c: Ditto.
	* mipsnbsd-tdep.c: Ditto.
	* mipsread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mips-tdep.h: Ditto.
	* mn10300-linux-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* mn10300-tdep.h: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* moxie-tdep.c: Ditto.
	* moxie-tdep.h: Ditto.
	* mt-tdep.c: Ditto.
@
text
@d1186 1
a1186 1
      struct macro_buffer va_arg_name;
@


1.25
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d209 1
a209 1
  /* Presumed; get_identifier may overwrite this. */
d707 1
a707 1
   harder to debug.  :( */
d1144 1
a1144 1
   LOOKUP_BATON to find definitions for any nested macro references.  
@


1.24
log
@run copyright.sh for 2011.
@
text
@d905 2
a906 1
    if (tok->len == strlen (argv[i]) && ! memcmp (tok->text, argv[i], tok->len))
@


1.23
log
@	* gdb_assert.h (gdb_assert_not_reached): New macro.
	(gdb_assert_fail): Fix typo in comment.
	* avr-tdep.c (avr_return_value): Use gdb_assert_not_reached instead of
	gdb_assert (0).
	* darwin-nat.c (darwin_check_new_threads): Ditto.
	* dwarf2read.c (dwarf2_get_section_info): Ditto.
	(munmap_section_buffer): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	(m32c_decode_srcdest4, m32c_decode_sd23, m32c_frame_base): Ditto.
	* macroexp.c (get_character_constant): Ditto.
	(get_string_literal): Ditto.
	* mep-tdep.c (mep_pseudo_cr_size): Ditto.
	(mep_pseudo_cr_index, mep_register_type): Ditto.
	(mep_pseudo_register_read, mep_pseudo_register_write): Ditto.
	(mep_get_insn, mep_analyze_prologue): Ditto.
	* objfiles.c (qsort_cmp): Ditto.
	* prologue-value.c (pv_is_identical): Ditto.
	* record.c (record_get_loc): Ditto.
	* value.c (value_static_field): Ditto.
	* xtensa-tdep.c (call0_track_op): Ditto.
@
text
@d2 2
a3 1
   Copyright (C) 2002, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.22
log
@2010-05-15  Michael Snyder  <msnyder@@vmware.com>

	* m2-lang.c: White space.
	* m2-valprint.c: White space.
	* macrocmd.c: White space.
	* macroexp.c: White space.
	* macroscope.c: White space.
	* macrotab.c: White space.
	* main.c: White space.
	* maint.c: White space.
	* mdebugread.c: White space.
	* memattr.c: White space.
	* minsyms.c: White space.
	* monitor.c: White space.
@
text
@d337 1
a337 1
        gdb_assert (0);
d392 1
a392 1
        gdb_assert (0);
@


1.21
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* macrocmd.c (_initialize_macrocmd): Delete unused variable.
	* macroexp.c (gather_arguments): Delete unused variable.
	(substitute_args): Delete unused variable.
	* completer.c (gdb_completer_loc_break_characters): Unused, delete.
	* gdbarch.sh (gdbarch_printable_names): Delete unused variable.
	(_initialize_gdbarch): Delete unused variable.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (initialize_current_architecture):
	Delete unused variable.
	(_initialize_gdbarch_utils): Delete unused variable.
	* gdbtypes.c (make_cv_type): Delete unused variable.
	(make_type_with_address_space): Delete unused variable.
@
text
@d528 1
d771 1
d1021 1
d1061 1
d1200 1
d1305 1
@


1.20
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a807 2
          char *start = src->text;

d1005 1
a1005 1
	  int arg, finished = 0;
@


1.19
log
@gdb:
2009-03-19  Tom Tromey  <tromey@@redhat.com>
	    Julian Brown  <julian@@codesourcery.com>

	PR i18n/7220, PR i18n/7821, PR exp/8815, PR exp/9103,
	PR i18n/9401, PR exp/9613:
	* NEWS: Update
	* value.h (value_typed_string): Declare.
	(val_print_string): Update.
	* valprint.h (print_char_chars): Update.
	* valprint.c (print_char_chars): Add type argument.  Update.
	(val_print_string): Likewise.
	* valops.c (value_typed_string): New function.
	* utils.c (host_char_to_target): New function.
	(parse_escape): Use host_char_to_target, host_hex_value.  Update.
	Remove '^' case.
	(no_control_char_error): Remove.
	* typeprint.c (print_type_scalar): Update.
	* scm-valprint.c (scm_scmval_print): Update.
	* scm-lang.h (scm_printchar, scm_printstr): Update.
	* scm-lang.c (scm_printchar): Add type argument.
	(scm_printstr): Likewise.
	* printcmd.c (print_formatted): Update.
	(print_scalar_formatted): Update.
	(printf_command) <wide_string_arg, wide_char_arg>: New constants.
	Handle '%lc' and '%ls'.
	* parser-defs.h (struct typed_stoken): New type.
	(struct stoken_vector): Likewise.
	(write_exp_string_vector): Declare.
	* parse.c (write_exp_string_vector): New function.
	* p-valprint.c (pascal_val_print): Update.
	* p-lang.h (is_pascal_string_type, pascal_printchar,
	pascal_printstr): Update.
	* p-lang.c (is_pascal_string_type): Remove 'char_size' argument.
	Add 'char_type' argument.
	(pascal_emit_char): Add type argument.
	(pascal_printchar): Likewise.
	(pascal_printstr): Likewise.
	* objc-lang.c (objc_emit_char): Add type argument.
	(objc_printchar): Likewise.
	(objc_printstr): Likewise.
	* macroexp.c (get_character_constant): Handle unicode characters.
	Use c_parse_escape.
	(get_string_literal): Handle unicode strings.  Use
	c_parse_escape.
	* m2-valprint.c (print_unpacked_pointer): Update.
	(m2_print_array_contents): Update.
	(m2_val_print): Update.
	* m2-lang.c (m2_emit_char): Add type argument.
	(m2_printchar): Likewise.
	(m2_printstr): Likewise.
	* language.h (struct language_defn) <la_printchar>: Add type
	argument.
	<la_printstr, la_emitchar>: Likewise.
	(LA_PRINT_CHAR): Likewise.
	(LA_PRINT_STRING): Likewise.
	(LA_EMIT_CHAR): Likewise.
	* language.c (unk_lang_emit_char): Add type argument.
	(unk_lang_printchar): Likewise.
	(unk_lang_printstr): Likewise.
	* jv-valprint.c (java_val_print): Update.
	* jv-lang.c (java_emit_char): Add type argument.
	* f-valprint.c (f_val_print): Update.
	* f-lang.c (f_emit_char): Add type argument.
	(f_printchar): Likewise.
	(f_printstr): Likewise.
	* expprint.c (print_subexp_standard): Update.
	* charset.h (target_wide_charset): Declare.
	(c_target_char_has_backslash_escape, c_parse_backslash,
	host_char_print_literally, host_char_to_target,
	target_char_to_host, target_char_to_control_char): Remove.
	(enum transliterations): New type.
	(convert_between_encodings): Declare.
	(HOST_ESCAPE_CHAR): New define.
	(host_letter_to_control_character, host_hex_value): Declare.
	(enum wchar_iterate_result): New enum.
	(struct wchar_iterator): Declare.
	(make_wchar_iterator, make_cleanup_wchar_iterator, wchar_iterator,
	wchar_push_back): Declare.
	* charset-list.h: New file.
	* c-valprint.c (textual_name): New function.
	(textual_element_type): Handle wide character types.
	(c_val_print): Pass original type to textual_element_type.  Handle
	wide character types.
	(c_value_print): Use textual_element_type.  Pass original type of
	value to val_print.
	* c-lang.h (enum c_string_type): New type.
	(c_printchar, c_printstr): Update.
	* c-lang.c (classify_type): New function.
	(print_wchar): Likewise.
	(c_emit_char): Add type argument.  Handle wide characters.
	(c_printchar): Likewise.
	(c_printstr): Add type argument.  Handle wide and multibyte
	character sets.
	(convert_ucn): New function.
	(emit_numeric_character): Likewise.
	(convert_octal): Likewise.
	(convert_hex): Likewise.
	(ADVANCE): New macro.
	(convert_escape): New function.
	(parse_one_string): Likewise.
	(evaluate_subexp_c): Likewise.
	(exp_descriptor_c): New global.
	(c_language_defn): Use exp_descriptor_c.
	(cplus_language_defn): Likewise.
	(asm_language_defn): Likewise.
	(minimal_language_defn): Likewise.
	(charset_for_string_type): New function.
	* c-exp.y (%union): Add 'svec' and 'tsval'.
	(CHAR): New token.
	(exp): Add CHAR production.
	(string_exp): Rewrite.
	(exp) <string_exp>: Rewrite.
	(tempbuf): Now global.
	(tempbuf_init): New global.
	(parse_string_or_char): New function.
	(yylex) <tempbuf>: Now global.
	<tokptr, tempbufindex, tempbufsize, token_string, class_prefix>:
	Remove.
	Handle 'u', 'U', and 'L' prefixes.  Call parse_string_or_char.
	(c_parse_escape): New function.
	* auxv.c (fprint_target_auxv): Update.
	* ada-valprint.c (ada_emit_char): Add type argument.
	(ada_printchar): Likewise.
	(ada_print_scalar): Update.
	(printstr): Add type argument.  Update calls to ada_emit_char.
	(ada_printstr): Add type argument.
	(ada_val_print_array): Update.
	(ada_val_print_1): Likewise.
	* ada-lang.c (emit_char): Add type argument.
	* ada-lang.h (ada_emit_char, ada_printchar, ada_printstr): Add
	type arguments.
	* gdb_locale.h: Include langinfo.h.
	* charset.c (_initialize_charset): Set default host charset from
	the locale.  Don't register charsets.  Add target-wide-charset
	commands.  Call find_charset_names.
	(struct charset, struct translation): Remove.
	(GDB_DEFAULT_HOST_CHARSET): Remove.
	(GDB_DEFAULT_TARGET_WIDE_CHARSET): New define.
	(target_wide_charset_name): New global.
	(show_host_charset_name): Handle "auto".
	(show_target_wide_charset_name): New function.
	(host_charset_enum, target_charset_enum): Remove.
	(charset_enum): New global.
	(all_charsets, register_charset, lookup_charset, all_translations,
	register_translation, lookup_translation): Remove.
	(simple_charset, ascii_print_literally, ascii_to_control): Remove.
	(iso_8859_print_literally, iso_8859_to_control,
	iso_8859_family_charset): Remove.
	(ebcdic_print_literally, ebcdic_to_control,
	ebcdic_family_charset): Remove.
	(struct cached_iconv, check_iconv_cache, cached_iconv_convert,
	register_iconv_charsets): Remove.
	(target_wide_charset_be_name, target_wide_charset_le_name): New
	globals.
	(identity_either_char_to_other): Remove.
	(set_be_le_names, validate): New functions.
	(backslashable, backslashed, represented): Remove.
	(default_c_target_char_has_backslash_escape): Remove.
	(default_c_parse_backslash, iconv_convert): Remove.
	(ascii_to_iso_8859_1_table, ascii_to_ebcdic_us_table,
	ascii_to_ibm1047_table, iso_8859_1_to_ascii_table,
	iso_8859_1_to_ebcdic_us_table, iso_8859_1_to_ibm1047_table,
	ebcdic_us_to_ascii_table, ebcdic_us_to_iso_8859_1_table,
	ebcdic_us_to_ibm1047_table, ibm1047_to_ascii_table,
	ibm1047_to_iso_8859_1_table, ibm1047_to_ebcdic_us_table): Remove.
	(table_convert_char, table_translation, simple_table_translation):
	Remove.
	(current_host_charset, current_target_charset,
	c_target_char_has_backslash_escape_func,
	c_target_char_has_backslash_escape_baton): Remove.
	(c_parse_backslash_func, c_parse_backslash_baton): Remove.
	(host_char_to_target_func, host_char_to_target_baton): Remove.
	(target_char_to_host_func, target_char_to_host_baton): Remove.
	(cached_iconv_host_to_target, cached_iconv_target_to_host):
	Remove.
	(lookup_charset_or_error, check_valid_host_charset): Remove.
	(set_host_and_target_charsets): Remove.
	(set_host_charset, set_target_charset): Remove.
	(set_host_charset_sfunc, set_target_charset_sfunc): Rewrite.
	(set_target_wide_charset_sfunc): New function.
	(show_charset): Print target wide character set.
	(host_charset, target_charset): Rewrite.
	(target_wide_charset): New function.
	(c_target_char_has_backslash_escape): Remove.
	(c_parse_backslash): Remove.
	(host_letter_to_control_character): New function.
	(host_char_print_literally): Remove.
	(host_hex_value): New function.
	(target_char_to_control_char): Remove.
	(cleanup_iconv): New function.
	(convert_between_encodings): New function.
	(target_char_to_host): Remove.
	(struct wchar_iterator): Define.
	(make_wchar_iterator, make_cleanup_wchar_iterator, wchar_iterator,
	wchar_push_back): New functions.
	(do_cleanup_iterator): New function.
	(char_ptr): New typedef.
	(charsets): New global.
	(add_one, find_charset_names): New functions.
	(default_charset_names): New global.
	(auto_host_charset_name): Likewise.
	* aclocal.m4, config.in, configure: Rebuild.
	* configure.ac: Call AM_LANGINFO_CODESET.
	(GDB_DEFAULT_HOST_CHARSET): Default to UTF-8.
	(AM_ICONV): Invoke earlier.
	* acinclude.m4: Include codeset.m4.  Subst LIBICONV_INCLUDE and
	LIBICONV_LIBDIR.  Check for libiconv in build tree.
	* Makefile.in (LIBICONV_LIBDIR, LIBICONV_INCLUDE): New macros.
	(INTERNAL_CFLAGS_BASE): Add LIBICONV_INCLUDE.
	(INTERNAL_LDFLAGS): Add LIBICONV_LIBDIR.
	* gdb_obstack.h (obstack_grow_wstr): New define.
        * gdb_wchar.h: New file.
        * defs.h: Include it.
gdb/testsuite:
	* gdb.base/store.exp: Update for change to escape output.
	* gdb.base/callfuncs.exp (fetch_all_registers): Update for change
	to escape output.
	* gdb.base/pointers.exp: Update for change to escape output.
	* gdb.base/long_long.exp (gdb_test_long_long): Update for change
	to escape output.
	* gdb.base/constvars.exp (do_constvar_tests): Update for change to
	escape output.
	* gdb.base/call-rt-st.exp (print_struct_call): Update for change
	to escape output.
	* gdb.cp/ref-types.exp (gdb_start_again): Update for change to
	escape output.
	* gdb.base/setvar.exp: Update for change to escape output.
	* lib/gdb.exp (default_gdb_start): Set LC_CTYPE to C.
	* gdb.base/printcmds.exp (test_print_all_chars): Update for change
	to escape output.
	(test_print_string_constants): Likewise.
	* gdb.base/charset.exp (valid_host_charset): Check size of
	wchar_t.  Handle UCS-2 and UCS-4.  Add tests for wide and unicode
	cases.  Handle "auto"-related output.
	* gdb.base/charset.c (char16_t, char32_t): New typedefs.
	(uvar, Uvar): New globals.
gdb/doc:
	* gdb.texinfo (Character Sets): Remove obsolete text.  Document
	set target-wide-charset.
	(Requirements): Mention iconv.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.18
log
@        Updated copyright notices for most files.
@
text
@d26 1
d324 3
a326 1
      || (p + 2 <= end && p[0] == 'L' && p[1] == '\''))
d330 1
d334 1
a334 1
      else if (*p == 'L')
d346 1
a346 1
              if (p == body_start)
d355 1
a355 1
              parse_escape (&p);
d358 4
a361 1
            p++;
d380 1
a380 1
       && *p == '\"')
d382 2
a383 2
          && p[0] == 'L'
          && p[1] == '\"'))
d387 1
a387 1
      if (*p == '\"')
d389 1
a389 1
      else if (*p == 'L')
d398 1
a398 1
          else if (*p == '\"')
d409 1
a409 1
              parse_escape (&p);
@


1.17
log
@gdb
	* macroexp.c (get_pp_number): Require digit after leading ".".
	Correctly handle suffixes.
gdb/testsuite
	* gdb.base/macscp.exp: New regression test.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2007, 2008 Free Software Foundation, Inc.
@


1.16
log
@gdb
	* NEWS: Update.
	* macrocmd.c (extract_identifier): Add is_parameter argument.
	(macro_define_command): Update.
	(macro_undef_command): Likewise.
	* macroexp.c (stringify): New function.
	(find_parameter): Likewise.
	(gather_arguments): Add nargs argument.  Handle varargs.
	(substitute_args): Add is_varargs and va_arg_name arguments.
	Handle varargs, splicing, stringification.  Use find_parameter.
	(expand): Handle varargs.
gdb/doc
	* gdb.texinfo (Macros): Remove text about stringification,
	varargs, and splicing.
gdb/testsuite
	* gdb.base/macscp.exp: Add tests for stringification, splicing,
	and varargs.
@
text
@d281 3
a283 1
          || *p == '.'))
d289 7
a295 3
          if (macro_is_digit (*p)
              || macro_is_identifier_nondigit (*p)
              || *p == '.')
a296 4
          else if (p + 2 <= end
                   && strchr ("eEpP.", *p)
                   && (p[1] == '+' || p[1] == '-'))
            p += 2;
@


1.15
log
@gdb:
	PR gdb/1136:
	* macroexp.c (get_punctuator) <punctuators>: Rearrange to put
	longer tokens first.
gdb/testsuite:
	* gdb.base/macscp.exp: Add test for macro lexing bug.
@
text
@d628 46
d723 5
d748 2
a749 1
gather_arguments (const char *name, struct macro_buffer *src, int *argc_p)
d815 14
d838 5
a842 2
             the current argument.  */
          else if (tok.len == 1 && tok.text[0] == ',' && depth == 0)
d873 32
d909 6
d919 1
d923 1
d931 11
d949 6
a956 8
      struct macro_buffer tok;
      char *original_rl_start = replacement_list.text;
      int substituted = 0;
      
      /* Find the next token in the replacement list.  */
      if (! get_token (&tok, &replacement_list))
        break;

d968 2
a969 1
        error (_("Stringification is not implemented yet."));
d971 16
d988 126
a1113 4
      if (tok.len == 2
          && tok.text[0] == '#'
          && tok.text[1] == '#')
        error (_("Token splicing is not implemented yet."));
d1115 2
a1116 4
      /* Is this token an identifier?  */
      if (tok.is_identifier)
        {
          int i;
d1118 2
a1119 23
          /* Is it the magic varargs parameter?  */
          if (tok.len == 11
              && ! memcmp (tok.text, "__VA_ARGS__", 11))
            error (_("Variable-arity macros not implemented yet."));

          /* Is it one of the parameters?  */
          for (i = 0; i < def->argc; i++)
            if (tok.len == strlen (def->argv[i])
                && ! memcmp (tok.text, def->argv[i], tok.len))
              {
                struct macro_buffer arg_src;

                /* Expand any macro invocations in the argument text,
                   and append the result to dest.  Remember that scan
                   mutates its source, so we need to scan a new buffer
                   referring to the argument's text, not the argument
                   itself.  */
                init_shared_buffer (&arg_src, argv[i].text, argv[i].len);
                scan (dest, &arg_src, no_loop, lookup_func, lookup_baton);
                substituted = 1;
                break;
              }
        }
d1121 2
a1122 3
      /* If it wasn't a parameter, then just copy it across.  */
      if (! substituted)
        append_tokens_without_splicing (dest, &tok);
d1173 2
d1176 26
a1201 3
      if (def->argc >= 1
          && strcmp (def->argv[def->argc - 1], "...") == 0)
        error (_("Varargs macros not implemented yet."));
d1204 2
a1205 1
      argv = gather_arguments (id, src, &argc);
d1219 4
d1226 3
a1228 3
          if (! (argc == 1
                 && argv[0].len == 0
                 && def->argc == 0))
d1242 2
a1243 2
      substitute_args (&substituted, def, argc, argv, no_loop,
                       lookup_func, lookup_baton);
@


1.14
log
@gdb
	PR gdb/855:
	* NEWS: Add entry for macro commands.
	* Makefile.in (macrocmd.o): Add gdb_string.h.
	* macroscope.h (user_macro_scope): Declare.
	(default_macro_scope): Update documentation.
	(macro_user_macros): Declare.
	* c-lang.c (c_preprocess_and_parse): Always attempt macro lookup.
	Use user_macro_scope.
	(null_macro_lookup): Remove.
	* macrotab.h (macro_callback_fn): Declare.
	(macro_for_each): Likewise.
	(macro_allow_redefinitions): Likewise.
	* macrotab.c (foreach_macro): New function
	(macro_for_each): Likewise.
	(struct macro_table) <redef_ok>: New field.
	(macro_allow_redefinitions): New function.
	(new_macro_table): Update.
	(macro_define_function): Likewise.
	(macro_define_object): Likewise.
	* macroscope.c (user_macro_scope): New function.
	(default_macro_scope): Use it.
	(macro_user_macros): New global.
	(standard_macro_lookup): Look in macro_user_macros.
	(_initialize_macroscope): New function.
	* macroexp.h (macro_is_whitespace, macro_is_digit,
	macro_is_identifier_nondigit): Declare.
	* macroexp.c (macro_is_whitespace): Rename.  No longer static.
	(macro_is_digit): Likewise.
	(macro_is_identifier_nondigit): Likewise.
	(get_identifier): Update.
	(get_pp_number): Likewise.
	(get_token): Likewise.
	* macrocmd.c (skip_ws): New function.
	(extract_identifier): Likewise.
	(free_macro_definition_ptr): Likewise.
	(user_macros): Remove.
	(macro_define_command): Implement.
	(_initialize_macrocmd): Update.
	(macro_undef_command): Implement.
	(print_one_macro): New function.
	(macro_list_command): Implement.
gdb/doc
	* gdb.texinfo (Macros): Update.  Use @@code rather than @@command.
gdb/testsuite
	* gdb.base/macscp.exp: Add macro tests.
@
text
@d419 4
a422 1
  /* ISO/IEC 9899:1999 (E)  Section 6.4.6  Paragraph 1  */
d424 16
a439 8
    "[", "]", "(", ")", "{", "}", ".", "->", 
    "++", "--", "&", "*", "+", "-", "~", "!",
    "/", "%", "<<", ">>", "<", ">", "<=", ">=", "==", "!=", 
    "^", "|", "&&", "||",
    "?", ":", ";", "...",
    "=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=", "&=", "^=", "|=",
    ",", "#", "##",
    "<:", ":>", "<%", "%>", "%:", "%:%:",
@


1.13
log
@	Updated copyright notices for most files.
@
text
@d174 2
a175 2
static int
is_whitespace (int c)
d185 2
a186 2
static int
is_digit (int c)
d192 2
a193 2
static int
is_identifier_nondigit (int c)
d258 1
a258 1
      && is_identifier_nondigit (*p))
d263 2
a264 2
             && (is_identifier_nondigit (*p)
                 || is_digit (*p)))
d280 1
a280 1
      && (is_digit (*p)
d287 2
a288 2
          if (is_digit (*p)
              || is_identifier_nondigit (*p)
d488 1
a488 1
    if (is_whitespace (*p))
@


1.12
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2007 Free Software Foundation, Inc.
@


1.11
log
@* macroexp.c (init_buffer): Remove testing code that overrides the
caller's length guess.
(gather_arguments): Use a larger initial size, now that the vector
growth code has been exercised.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.10
log
@Copyright updates for 2007.
@
text
@a83 3
  /* Small value for initial testing.  */
  n = 1;

d715 1
a715 1
  args_size = 1;                /* small for initial testing */
@


1.9
log
@	* macroexp.c (expand): Initialize argc.
	* stabsread.c (read_type): Handle errors from read_args.
	(read_args): Return NULL for errors.
@
text
@d2 1
a2 1
   Copyright (C) 2002 Free Software Foundation, Inc.
@


1.8
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d930 1
a930 1
      int argc;
@


1.7
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d2 1
a2 1
   Copyright 2002 Free Software Foundation, Inc.
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.6
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d619 1
a619 1
                  "unable to avoid splicing tokens during macro expansion");
d994 1
a994 1
    internal_error (__FILE__, __LINE__, "bad macro definition kind");
@


1.5
log
@2003-09-08  Andrew Cagney  <cagney@@redhat.com>

	* gnu-nat.c: Remove "inline" function attribute.
	* alpha-tdep.c, ppc-linux-tdep.c, macroexp.c: Ditto.
@
text
@d239 1
a239 1
      error ("Unterminated comment in macro expansion.");
d342 1
a342 1
            error ("Unmatched single quote.");
d346 2
a347 2
                error ("A character constant must contain at least one "
                       "character.");
d393 1
a393 1
            error ("Unterminated string in expression.");
d400 2
a401 2
            error ("Newline characters may not appear in string "
                   "constants.");
d744 1
a744 1
            error ("Malformed argument list for macro `%s'.", name);
d844 1
a844 1
        error ("Stringification is not implemented yet.");
d850 1
a850 1
        error ("Token splicing is not implemented yet.");
d860 1
a860 1
            error ("Variable-arity macros not implemented yet.");
d937 1
a937 1
        error ("Varargs macros not implemented yet.");
d960 2
a961 2
            error ("Wrong number of arguments to macro `%s' "
                   "(expected %d, got %d).",
d1125 1
a1125 1
  error ("Expand-once not implemented yet.");
@


1.4
log
@2002-07-29  Andrew Cagney  <ac131313@@redhat.com>

* gdb_obstack.h: New file.
* symtab.h: Include "gdb_obstack.h" instead of "obstack.h".
(obstack_chunk_alloc, obstack_chunk_free): Delete macros.
* objfiles.h: Include "gdb_obstack.h".
* Makefile.in (gdb_obstack_h): Define.
(symtab_h): Add $(gdb_obstack_h).
(objfiles_h): Add $(gdb_obstack_h).

* objfiles.c: Include "gdb_obstack.h" instead of "obstack.h".
* macrotab.c, cp-valprint.c, dbxread.c: Ditto.
* ch-typeprint.c, ch-valprint.c, dstread.c: Ditto.
* macroexp.c, p-typeprint.c, stabsread.c: Ditto.
* symtab.c, f-typeprint.c, mdebugread.c: Ditto.
* p-valprint.c, symmisc.c, typeprint.c: Ditto.
* symfile.c, coffread.c, c-typeprint.c: Ditto.
* buildsym.c, bcache.c, ada-typeprint.c: Ditto.

* Makefile.in (bcache.o): Update dependencies.
(buildsym.o, c-typeprint.o, ch-typeprint.o): Ditto.
(ch-valprint.o, coffread.o, cp-valprint.o): Ditto.
(dbxread.o, dstread.o, f-typeprint.o): Ditto.
(objfiles.o, p-typeprint.o, p-valprint.o): Ditto.
(stabsread.o, symfile.o, symmisc.o): Ditto.
(symtab.o, typeprint.o, macroexp.o): Ditto.
(macrotab.o, mdebugread.o): Ditto.
(f_lang_h, coff_sym_h, coff_symconst_h): Define.
(coff_ecoff_h, aout_aout64_h): Define.
(aout_stabs_gnu_h, libaout_h): Define.
@
text
@d148 1
a148 1
static inline void
d162 1
a162 1
static inline void
@


1.4.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d148 1
a148 1
static void
d162 1
a162 1
static void
@


1.4.8.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d148 1
a148 1
static void
d162 1
a162 1
static void
@


1.3
log
@* macroexp.c (init_buffer, gather_arguments, expand): Use NULL, not 0.
* macrotab.c (macro_lookup_inclusion, find_definition,
new_macro_table): Same.

* macroexp.c (currently_rescanning, expand): Use `strcmp () == 0',
not `! strcmp ()'.  This is a dubious improvement.
* macrotab.c (macro_lookup_inclusion, find_definition): Same.

* macrotab.c (macro_lookup_inclusion): Initialize `best_depth',
although it's not necessary, to avoid a warning.
@
text
@d23 1
a23 1
#include "obstack.h"
@


1.3.4.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d23 1
a23 1
#include "gdb_obstack.h"
@


1.2
log
@Add first preprocessor macro-expansion files.
* macroexp.c, macroexp.h, macrotab.c, macrotab.h: New files.
* Makefile.in (SFILES): Add macrotab.c, macroexp.c.
(splay_tree_h, macroexp_h, macrotab_h): New variable.
(HFILES_NO_SRCDIR): Add macrotab.h, macroexp.h.
(COMMON_OBS): Add macrotab.o, macroexp.o.
(macroexp.o, macrotab.o): New rules.
@
text
@d91 1
a91 1
    b->text = 0;
d649 1
a649 1
    if (! strcmp (name, list->name))
d695 1
a695 1
  struct macro_buffer *args = 0;
d931 1
a931 1
      struct macro_buffer *argv = 0;
d936 1
a936 1
          && ! strcmp (def->argv[def->argc - 1], "..."))
@


1.1
log
@file macroexp.c was initially added on branch jimb-macro-020506-branch.
@
text
@d1 1169
@


1.1.2.1
log
@Add first preprocessor macro-expansion files.
* macroexp.c, macroexp.h, macrotab.c, macrotab.h: New files.
* Makefile.in (SFILES): Add macrotab.c, macroexp.c.
(splay_tree_h, macroexp_h, macrotab_h): New variable.
(HFILES_NO_SRCDIR): Add macrotab.h, macroexp.h.
(COMMON_OBS): Add macrotab.o, macroexp.o.
(macroexp.o, macrotab.o): New rules.
@
text
@a0 1169
/* C preprocessor macro expansion for GDB.
   Copyright 2002 Free Software Foundation, Inc.
   Contributed by Red Hat, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "obstack.h"
#include "bcache.h"
#include "macrotab.h"
#include "macroexp.h"
#include "gdb_assert.h"



/* A resizeable, substringable string type.  */


/* A string type that we can resize, quickly append to, and use to
   refer to substrings of other strings.  */
struct macro_buffer
{
  /* An array of characters.  The first LEN bytes are the real text,
     but there are SIZE bytes allocated to the array.  If SIZE is
     zero, then this doesn't point to a malloc'ed block.  If SHARED is
     non-zero, then this buffer is actually a pointer into some larger
     string, and we shouldn't append characters to it, etc.  Because
     of sharing, we can't assume in general that the text is
     null-terminated.  */
  char *text;

  /* The number of characters in the string.  */
  int len;

  /* The number of characters allocated to the string.  If SHARED is
     non-zero, this is meaningless; in this case, we set it to zero so
     that any "do we have room to append something?" tests will fail,
     so we don't always have to check SHARED before using this field.  */
  int size;

  /* Zero if TEXT can be safely realloc'ed (i.e., it's its own malloc
     block).  Non-zero if TEXT is actually pointing into the middle of
     some other block, and we shouldn't reallocate it.  */
  int shared;

  /* For detecting token splicing. 

     This is the index in TEXT of the first character of the token
     that abuts the end of TEXT.  If TEXT contains no tokens, then we
     set this equal to LEN.  If TEXT ends in whitespace, then there is
     no token abutting the end of TEXT (it's just whitespace), and
     again, we set this equal to LEN.  We set this to -1 if we don't
     know the nature of TEXT.  */
  int last_token;

  /* If this buffer is holding the result from get_token, then this 
     is non-zero if it is an identifier token, zero otherwise.  */
  int is_identifier;
};


/* Set the macro buffer *B to the empty string, guessing that its
   final contents will fit in N bytes.  (It'll get resized if it
   doesn't, so the guess doesn't have to be right.)  Allocate the
   initial storage with xmalloc.  */
static void
init_buffer (struct macro_buffer *b, int n)
{
  /* Small value for initial testing.  */
  n = 1;

  b->size = n;
  if (n > 0)
    b->text = (char *) xmalloc (n);
  else
    b->text = 0;
  b->len = 0;
  b->shared = 0;
  b->last_token = -1;
}


/* Set the macro buffer *BUF to refer to the LEN bytes at ADDR, as a
   shared substring.  */
static void
init_shared_buffer (struct macro_buffer *buf, char *addr, int len)
{
  buf->text = addr;
  buf->len = len;
  buf->shared = 1;
  buf->size = 0;
  buf->last_token = -1;
}


/* Free the text of the buffer B.  Raise an error if B is shared.  */
static void
free_buffer (struct macro_buffer *b)
{
  gdb_assert (! b->shared);
  if (b->size)
    xfree (b->text);
}


/* A cleanup function for macro buffers.  */
static void
cleanup_macro_buffer (void *untyped_buf)
{
  free_buffer ((struct macro_buffer *) untyped_buf);
}


/* Resize the buffer B to be at least N bytes long.  Raise an error if
   B shouldn't be resized.  */
static void
resize_buffer (struct macro_buffer *b, int n)
{
  /* We shouldn't be trying to resize shared strings.  */
  gdb_assert (! b->shared);
  
  if (b->size == 0)
    b->size = n;
  else
    while (b->size <= n)
      b->size *= 2;

  b->text = xrealloc (b->text, b->size);
}


/* Append the character C to the buffer B.  */
static inline void
appendc (struct macro_buffer *b, int c)
{
  int new_len = b->len + 1;

  if (new_len > b->size)
    resize_buffer (b, new_len);

  b->text[b->len] = c;
  b->len = new_len;
}


/* Append the LEN bytes at ADDR to the buffer B.  */
static inline void
appendmem (struct macro_buffer *b, char *addr, int len)
{
  int new_len = b->len + len;

  if (new_len > b->size)
    resize_buffer (b, new_len);

  memcpy (b->text + b->len, addr, len);
  b->len = new_len;
}



/* Recognizing preprocessor tokens.  */


static int
is_whitespace (int c)
{
  return (c == ' '
          || c == '\t'
          || c == '\n'
          || c == '\v'
          || c == '\f');
}


static int
is_digit (int c)
{
  return ('0' <= c && c <= '9');
}


static int
is_identifier_nondigit (int c)
{
  return (c == '_'
          || ('a' <= c && c <= 'z')
          || ('A' <= c && c <= 'Z'));
}


static void
set_token (struct macro_buffer *tok, char *start, char *end)
{
  init_shared_buffer (tok, start, end - start);
  tok->last_token = 0;

  /* Presumed; get_identifier may overwrite this. */
  tok->is_identifier = 0;
}


static int
get_comment (struct macro_buffer *tok, char *p, char *end)
{
  if (p + 2 > end)
    return 0;
  else if (p[0] == '/'
           && p[1] == '*')
    {
      char *tok_start = p;

      p += 2;

      for (; p < end; p++)
        if (p + 2 <= end
            && p[0] == '*'
            && p[1] == '/')
          {
            p += 2;
            set_token (tok, tok_start, p);
            return 1;
          }

      error ("Unterminated comment in macro expansion.");
    }
  else if (p[0] == '/'
           && p[1] == '/')
    {
      char *tok_start = p;

      p += 2;
      for (; p < end; p++)
        if (*p == '\n')
          break;

      set_token (tok, tok_start, p);
      return 1;
    }
  else
    return 0;
}


static int
get_identifier (struct macro_buffer *tok, char *p, char *end)
{
  if (p < end
      && is_identifier_nondigit (*p))
    {
      char *tok_start = p;

      while (p < end
             && (is_identifier_nondigit (*p)
                 || is_digit (*p)))
        p++;

      set_token (tok, tok_start, p);
      tok->is_identifier = 1;
      return 1;
    }
  else
    return 0;
}


static int
get_pp_number (struct macro_buffer *tok, char *p, char *end)
{
  if (p < end
      && (is_digit (*p)
          || *p == '.'))
    {
      char *tok_start = p;

      while (p < end)
        {
          if (is_digit (*p)
              || is_identifier_nondigit (*p)
              || *p == '.')
            p++;
          else if (p + 2 <= end
                   && strchr ("eEpP.", *p)
                   && (p[1] == '+' || p[1] == '-'))
            p += 2;
          else
            break;
        }

      set_token (tok, tok_start, p);
      return 1;
    }
  else
    return 0;
}



/* If the text starting at P going up to (but not including) END
   starts with a character constant, set *TOK to point to that
   character constant, and return 1.  Otherwise, return zero.
   Signal an error if it contains a malformed or incomplete character
   constant.  */
static int
get_character_constant (struct macro_buffer *tok, char *p, char *end)
{
  /* ISO/IEC 9899:1999 (E)  Section 6.4.4.4  paragraph 1 
     But of course, what really matters is that we handle it the same
     way GDB's C/C++ lexer does.  So we call parse_escape in utils.c
     to handle escape sequences.  */
  if ((p + 1 <= end && *p == '\'')
      || (p + 2 <= end && p[0] == 'L' && p[1] == '\''))
    {
      char *tok_start = p;
      char *body_start;

      if (*p == '\'')
        p++;
      else if (*p == 'L')
        p += 2;
      else
        gdb_assert (0);

      body_start = p;
      for (;;)
        {
          if (p >= end)
            error ("Unmatched single quote.");
          else if (*p == '\'')
            {
              if (p == body_start)
                error ("A character constant must contain at least one "
                       "character.");
              p++;
              break;
            }
          else if (*p == '\\')
            {
              p++;
              parse_escape (&p);
            }
          else
            p++;
        }

      set_token (tok, tok_start, p);
      return 1;
    }
  else
    return 0;
}


/* If the text starting at P going up to (but not including) END
   starts with a string literal, set *TOK to point to that string
   literal, and return 1.  Otherwise, return zero.  Signal an error if
   it contains a malformed or incomplete string literal.  */
static int
get_string_literal (struct macro_buffer *tok, char *p, char *end)
{
  if ((p + 1 <= end
       && *p == '\"')
      || (p + 2 <= end
          && p[0] == 'L'
          && p[1] == '\"'))
    {
      char *tok_start = p;

      if (*p == '\"')
        p++;
      else if (*p == 'L')
        p += 2;
      else
        gdb_assert (0);

      for (;;)
        {
          if (p >= end)
            error ("Unterminated string in expression.");
          else if (*p == '\"')
            {
              p++;
              break;
            }
          else if (*p == '\n')
            error ("Newline characters may not appear in string "
                   "constants.");
          else if (*p == '\\')
            {
              p++;
              parse_escape (&p);
            }
          else
            p++;
        }

      set_token (tok, tok_start, p);
      return 1;
    }
  else
    return 0;
}


static int
get_punctuator (struct macro_buffer *tok, char *p, char *end)
{
  /* Here, speed is much less important than correctness and clarity.  */

  /* ISO/IEC 9899:1999 (E)  Section 6.4.6  Paragraph 1  */
  static const char * const punctuators[] = {
    "[", "]", "(", ")", "{", "}", ".", "->", 
    "++", "--", "&", "*", "+", "-", "~", "!",
    "/", "%", "<<", ">>", "<", ">", "<=", ">=", "==", "!=", 
    "^", "|", "&&", "||",
    "?", ":", ";", "...",
    "=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=", "&=", "^=", "|=",
    ",", "#", "##",
    "<:", ":>", "<%", "%>", "%:", "%:%:",
    0
  };

  int i;

  if (p + 1 <= end)
    {
      for (i = 0; punctuators[i]; i++)
        {
          const char *punctuator = punctuators[i];

          if (p[0] == punctuator[0])
            {
              int len = strlen (punctuator);

              if (p + len <= end
                  && ! memcmp (p, punctuator, len))
                {
                  set_token (tok, p, p + len);
                  return 1;
                }
            }
        }
    }

  return 0;
}


/* Peel the next preprocessor token off of SRC, and put it in TOK.
   Mutate TOK to refer to the first token in SRC, and mutate SRC to
   refer to the text after that token.  SRC must be a shared buffer;
   the resulting TOK will be shared, pointing into the same string SRC
   does.  Initialize TOK's last_token field.  Return non-zero if we
   succeed, or 0 if we didn't find any more tokens in SRC.  */
static int
get_token (struct macro_buffer *tok,
           struct macro_buffer *src)
{
  char *p = src->text;
  char *end = p + src->len;

  gdb_assert (src->shared);

  /* From the ISO C standard, ISO/IEC 9899:1999 (E), section 6.4:

     preprocessing-token: 
         header-name
         identifier
         pp-number
         character-constant
         string-literal
         punctuator
         each non-white-space character that cannot be one of the above

     We don't have to deal with header-name tokens, since those can
     only occur after a #include, which we will never see.  */

  while (p < end)
    if (is_whitespace (*p))
      p++;
    else if (get_comment (tok, p, end))
      p += tok->len;
    else if (get_pp_number (tok, p, end)
             || get_character_constant (tok, p, end)
             || get_string_literal (tok, p, end)
             /* Note: the grammar in the standard seems to be
                ambiguous: L'x' can be either a wide character
                constant, or an identifier followed by a normal
                character constant.  By trying `get_identifier' after
                we try get_character_constant and get_string_literal,
                we give the wide character syntax precedence.  Now,
                since GDB doesn't handle wide character constants
                anyway, is this the right thing to do?  */
             || get_identifier (tok, p, end)
             || get_punctuator (tok, p, end))
      {
        /* How many characters did we consume, including whitespace?  */
        int consumed = p - src->text + tok->len;
        src->text += consumed;
        src->len -= consumed;
        return 1;
      }
    else 
      {
        /* We have found a "non-whitespace character that cannot be
           one of the above."  Make a token out of it.  */
        int consumed;

        set_token (tok, p, p + 1);
        consumed = p - src->text + tok->len;
        src->text += consumed;
        src->len -= consumed;
        return 1;
      }

  return 0;
}



/* Appending token strings, with and without splicing  */


/* Append the macro buffer SRC to the end of DEST, and ensure that
   doing so doesn't splice the token at the end of SRC with the token
   at the beginning of DEST.  SRC and DEST must have their last_token
   fields set.  Upon return, DEST's last_token field is set correctly.

   For example:

   If DEST is "(" and SRC is "y", then we can return with
   DEST set to "(y" --- we've simply appended the two buffers.

   However, if DEST is "x" and SRC is "y", then we must not return
   with DEST set to "xy" --- that would splice the two tokens "x" and
   "y" together to make a single token "xy".  However, it would be
   fine to return with DEST set to "x y".  Similarly, "<" and "<" must
   yield "< <", not "<<", etc.  */
static void
append_tokens_without_splicing (struct macro_buffer *dest,
                                struct macro_buffer *src)
{
  int original_dest_len = dest->len;
  struct macro_buffer dest_tail, new_token;

  gdb_assert (src->last_token != -1);
  gdb_assert (dest->last_token != -1);
  
  /* First, just try appending the two, and call get_token to see if
     we got a splice.  */
  appendmem (dest, src->text, src->len);

  /* If DEST originally had no token abutting its end, then we can't
     have spliced anything, so we're done.  */
  if (dest->last_token == original_dest_len)
    {
      dest->last_token = original_dest_len + src->last_token;
      return;
    }

  /* Set DEST_TAIL to point to the last token in DEST, followed by
     all the stuff we just appended.  */
  init_shared_buffer (&dest_tail,
                      dest->text + dest->last_token,
                      dest->len - dest->last_token);

  /* Re-parse DEST's last token.  We know that DEST used to contain
     at least one token, so if it doesn't contain any after the
     append, then we must have spliced "/" and "*" or "/" and "/" to
     make a comment start.  (Just for the record, I got this right
     the first time.  This is not a bug fix.)  */
  if (get_token (&new_token, &dest_tail)
      && (new_token.text + new_token.len
          == dest->text + original_dest_len))
    {
      /* No splice, so we're done.  */
      dest->last_token = original_dest_len + src->last_token;
      return;
    }

  /* Okay, a simple append caused a splice.  Let's chop dest back to
     its original length and try again, but separate the texts with a
     space.  */
  dest->len = original_dest_len;
  appendc (dest, ' ');
  appendmem (dest, src->text, src->len);

  init_shared_buffer (&dest_tail,
                      dest->text + dest->last_token,
                      dest->len - dest->last_token);

  /* Try to re-parse DEST's last token, as above.  */
  if (get_token (&new_token, &dest_tail)
      && (new_token.text + new_token.len
          == dest->text + original_dest_len))
    {
      /* No splice, so we're done.  */
      dest->last_token = original_dest_len + 1 + src->last_token;
      return;
    }

  /* As far as I know, there's no case where inserting a space isn't
     enough to prevent a splice.  */
  internal_error (__FILE__, __LINE__,
                  "unable to avoid splicing tokens during macro expansion");
}



/* Expanding macros!  */


/* A singly-linked list of the names of the macros we are currently 
   expanding --- for detecting expansion loops.  */
struct macro_name_list {
  const char *name;
  struct macro_name_list *next;
};


/* Return non-zero if we are currently expanding the macro named NAME,
   according to LIST; otherwise, return zero.

   You know, it would be possible to get rid of all the NO_LOOP
   arguments to these functions by simply generating a new lookup
   function and baton which refuses to find the definition for a
   particular macro, and otherwise delegates the decision to another
   function/baton pair.  But that makes the linked list of excluded
   macros chained through untyped baton pointers, which will make it
   harder to debug.  :( */
static int
currently_rescanning (struct macro_name_list *list, const char *name)
{
  for (; list; list = list->next)
    if (! strcmp (name, list->name))
      return 1;

  return 0;
}


/* Gather the arguments to a macro expansion.

   NAME is the name of the macro being invoked.  (It's only used for
   printing error messages.)

   Assume that SRC is the text of the macro invocation immediately
   following the macro name.  For example, if we're processing the
   text foo(bar, baz), then NAME would be foo and SRC will be (bar,
   baz).

   If SRC doesn't start with an open paren ( token at all, return
   zero, leave SRC unchanged, and don't set *ARGC_P to anything.

   If SRC doesn't contain a properly terminated argument list, then
   raise an error.

   Otherwise, return a pointer to the first element of an array of
   macro buffers referring to the argument texts, and set *ARGC_P to
   the number of arguments we found --- the number of elements in the
   array.  The macro buffers share their text with SRC, and their
   last_token fields are initialized.  The array is allocated with
   xmalloc, and the caller is responsible for freeing it.

   NOTE WELL: if SRC starts with a open paren ( token followed
   immediately by a close paren ) token (e.g., the invocation looks
   like "foo()"), we treat that as one argument, which happens to be
   the empty list of tokens.  The caller should keep in mind that such
   a sequence of tokens is a valid way to invoke one-parameter
   function-like macros, but also a valid way to invoke zero-parameter
   function-like macros.  Eeew.

   Consume the tokens from SRC; after this call, SRC contains the text
   following the invocation.  */

static struct macro_buffer *
gather_arguments (const char *name, struct macro_buffer *src, int *argc_p)
{
  struct macro_buffer tok;
  int args_len, args_size;
  struct macro_buffer *args = 0;
  struct cleanup *back_to = make_cleanup (free_current_contents, &args);

  /* Does SRC start with an opening paren token?  Read from a copy of
     SRC, so SRC itself is unaffected if we don't find an opening
     paren.  */
  {
    struct macro_buffer temp;
    init_shared_buffer (&temp, src->text, src->len);

    if (! get_token (&tok, &temp)
        || tok.len != 1
        || tok.text[0] != '(')
      {
        discard_cleanups (back_to);
        return 0;
      }
  }

  /* Consume SRC's opening paren.  */
  get_token (&tok, src);

  args_len = 0;
  args_size = 1;                /* small for initial testing */
  args = (struct macro_buffer *) xmalloc (sizeof (*args) * args_size);

  for (;;)
    {
      struct macro_buffer *arg;
      int depth;

      /* Make sure we have room for the next argument.  */
      if (args_len >= args_size)
        {
          args_size *= 2;
          args = xrealloc (args, sizeof (*args) * args_size);
        }

      /* Initialize the next argument.  */
      arg = &args[args_len++];
      set_token (arg, src->text, src->text);

      /* Gather the argument's tokens.  */
      depth = 0;
      for (;;)
        {
          char *start = src->text;

          if (! get_token (&tok, src))
            error ("Malformed argument list for macro `%s'.", name);
      
          /* Is tok an opening paren?  */
          if (tok.len == 1 && tok.text[0] == '(')
            depth++;

          /* Is tok is a closing paren?  */
          else if (tok.len == 1 && tok.text[0] == ')')
            {
              /* If it's a closing paren at the top level, then that's
                 the end of the argument list.  */
              if (depth == 0)
                {
                  discard_cleanups (back_to);
                  *argc_p = args_len;
                  return args;
                }

              depth--;
            }

          /* If tok is a comma at top level, then that's the end of
             the current argument.  */
          else if (tok.len == 1 && tok.text[0] == ',' && depth == 0)
            break;

          /* Extend the current argument to enclose this token.  If
             this is the current argument's first token, leave out any
             leading whitespace, just for aesthetics.  */
          if (arg->len == 0)
            {
              arg->text = tok.text;
              arg->len = tok.len;
              arg->last_token = 0;
            }
          else
            {
              arg->len = (tok.text + tok.len) - arg->text;
              arg->last_token = tok.text - arg->text;
            }
        }
    }
}


/* The `expand' and `substitute_args' functions both invoke `scan'
   recursively, so we need a forward declaration somewhere.  */
static void scan (struct macro_buffer *dest,
                  struct macro_buffer *src,
                  struct macro_name_list *no_loop,
                  macro_lookup_ftype *lookup_func,
                  void *lookup_baton);


/* Given the macro definition DEF, being invoked with the actual
   arguments given by ARGC and ARGV, substitute the arguments into the
   replacement list, and store the result in DEST.

   If it is necessary to expand macro invocations in one of the
   arguments, use LOOKUP_FUNC and LOOKUP_BATON to find the macro
   definitions, and don't expand invocations of the macros listed in
   NO_LOOP.  */
static void
substitute_args (struct macro_buffer *dest, 
                 struct macro_definition *def,
                 int argc, struct macro_buffer *argv,
                 struct macro_name_list *no_loop,
                 macro_lookup_ftype *lookup_func,
                 void *lookup_baton)
{
  /* A macro buffer for the macro's replacement list.  */
  struct macro_buffer replacement_list;

  init_shared_buffer (&replacement_list, (char *) def->replacement,
                      strlen (def->replacement));

  gdb_assert (dest->len == 0);
  dest->last_token = 0;

  for (;;)
    {
      struct macro_buffer tok;
      char *original_rl_start = replacement_list.text;
      int substituted = 0;
      
      /* Find the next token in the replacement list.  */
      if (! get_token (&tok, &replacement_list))
        break;

      /* Just for aesthetics.  If we skipped some whitespace, copy
         that to DEST.  */
      if (tok.text > original_rl_start)
        {
          appendmem (dest, original_rl_start, tok.text - original_rl_start);
          dest->last_token = dest->len;
        }

      /* Is this token the stringification operator?  */
      if (tok.len == 1
          && tok.text[0] == '#')
        error ("Stringification is not implemented yet.");

      /* Is this token the splicing operator?  */
      if (tok.len == 2
          && tok.text[0] == '#'
          && tok.text[1] == '#')
        error ("Token splicing is not implemented yet.");

      /* Is this token an identifier?  */
      if (tok.is_identifier)
        {
          int i;

          /* Is it the magic varargs parameter?  */
          if (tok.len == 11
              && ! memcmp (tok.text, "__VA_ARGS__", 11))
            error ("Variable-arity macros not implemented yet.");

          /* Is it one of the parameters?  */
          for (i = 0; i < def->argc; i++)
            if (tok.len == strlen (def->argv[i])
                && ! memcmp (tok.text, def->argv[i], tok.len))
              {
                struct macro_buffer arg_src;

                /* Expand any macro invocations in the argument text,
                   and append the result to dest.  Remember that scan
                   mutates its source, so we need to scan a new buffer
                   referring to the argument's text, not the argument
                   itself.  */
                init_shared_buffer (&arg_src, argv[i].text, argv[i].len);
                scan (dest, &arg_src, no_loop, lookup_func, lookup_baton);
                substituted = 1;
                break;
              }
        }

      /* If it wasn't a parameter, then just copy it across.  */
      if (! substituted)
        append_tokens_without_splicing (dest, &tok);
    }
}


/* Expand a call to a macro named ID, whose definition is DEF.  Append
   its expansion to DEST.  SRC is the input text following the ID
   token.  We are currently rescanning the expansions of the macros
   named in NO_LOOP; don't re-expand them.  Use LOOKUP_FUNC and
   LOOKUP_BATON to find definitions for any nested macro references.  

   Return 1 if we decided to expand it, zero otherwise.  (If it's a
   function-like macro name that isn't followed by an argument list,
   we don't expand it.)  If we return zero, leave SRC unchanged.  */
static int
expand (const char *id,
        struct macro_definition *def, 
        struct macro_buffer *dest,
        struct macro_buffer *src,
        struct macro_name_list *no_loop,
        macro_lookup_ftype *lookup_func,
        void *lookup_baton)
{
  struct macro_name_list new_no_loop;

  /* Create a new node to be added to the front of the no-expand list.
     This list is appropriate for re-scanning replacement lists, but
     it is *not* appropriate for scanning macro arguments; invocations
     of the macro whose arguments we are gathering *do* get expanded
     there.  */
  new_no_loop.name = id;
  new_no_loop.next = no_loop;

  /* What kind of macro are we expanding?  */
  if (def->kind == macro_object_like)
    {
      struct macro_buffer replacement_list;

      init_shared_buffer (&replacement_list, (char *) def->replacement,
                          strlen (def->replacement));

      scan (dest, &replacement_list, &new_no_loop, lookup_func, lookup_baton);
      return 1;
    }
  else if (def->kind == macro_function_like)
    {
      struct cleanup *back_to = make_cleanup (null_cleanup, 0);
      int argc;
      struct macro_buffer *argv = 0;
      struct macro_buffer substituted;
      struct macro_buffer substituted_src;

      if (def->argc >= 1
          && ! strcmp (def->argv[def->argc - 1], "..."))
        error ("Varargs macros not implemented yet.");

      make_cleanup (free_current_contents, &argv);
      argv = gather_arguments (id, src, &argc);

      /* If we couldn't find any argument list, then we don't expand
         this macro.  */
      if (! argv)
        {
          do_cleanups (back_to);
          return 0;
        }

      /* Check that we're passing an acceptable number of arguments for
         this macro.  */
      if (argc != def->argc)
        {
          /* Remember that a sequence of tokens like "foo()" is a
             valid invocation of a macro expecting either zero or one
             arguments.  */
          if (! (argc == 1
                 && argv[0].len == 0
                 && def->argc == 0))
            error ("Wrong number of arguments to macro `%s' "
                   "(expected %d, got %d).",
                   id, def->argc, argc);
        }

      /* Note that we don't expand macro invocations in the arguments
         yet --- we let subst_args take care of that.  Parameters that
         appear as operands of the stringifying operator "#" or the
         splicing operator "##" don't get macro references expanded,
         so we can't really tell whether it's appropriate to macro-
         expand an argument until we see how it's being used.  */
      init_buffer (&substituted, 0);
      make_cleanup (cleanup_macro_buffer, &substituted);
      substitute_args (&substituted, def, argc, argv, no_loop,
                       lookup_func, lookup_baton);

      /* Now `substituted' is the macro's replacement list, with all
         argument values substituted into it properly.  Re-scan it for
         macro references, but don't expand invocations of this macro.

         We create a new buffer, `substituted_src', which points into
         `substituted', and scan that.  We can't scan `substituted'
         itself, since the tokenization process moves the buffer's
         text pointer around, and we still need to be able to find
         `substituted's original text buffer after scanning it so we
         can free it.  */
      init_shared_buffer (&substituted_src, substituted.text, substituted.len);
      scan (dest, &substituted_src, &new_no_loop, lookup_func, lookup_baton);

      do_cleanups (back_to);

      return 1;
    }
  else
    internal_error (__FILE__, __LINE__, "bad macro definition kind");
}


/* If the single token in SRC_FIRST followed by the tokens in SRC_REST
   constitute a macro invokation not forbidden in NO_LOOP, append its
   expansion to DEST and return non-zero.  Otherwise, return zero, and
   leave DEST unchanged.

   SRC_FIRST and SRC_REST must be shared buffers; DEST must not be one.
   SRC_FIRST must be a string built by get_token.  */
static int
maybe_expand (struct macro_buffer *dest,
              struct macro_buffer *src_first,
              struct macro_buffer *src_rest,
              struct macro_name_list *no_loop,
              macro_lookup_ftype *lookup_func,
              void *lookup_baton)
{
  gdb_assert (src_first->shared);
  gdb_assert (src_rest->shared);
  gdb_assert (! dest->shared);

  /* Is this token an identifier?  */
  if (src_first->is_identifier)
    {
      /* Make a null-terminated copy of it, since that's what our
         lookup function expects.  */
      char *id = xmalloc (src_first->len + 1);
      struct cleanup *back_to = make_cleanup (xfree, id);
      memcpy (id, src_first->text, src_first->len);
      id[src_first->len] = 0;
          
      /* If we're currently re-scanning the result of expanding
         this macro, don't expand it again.  */
      if (! currently_rescanning (no_loop, id))
        {
          /* Does this identifier have a macro definition in scope?  */
          struct macro_definition *def = lookup_func (id, lookup_baton);

          if (def && expand (id, def, dest, src_rest, no_loop,
                             lookup_func, lookup_baton))
            {
              do_cleanups (back_to);
              return 1;
            }
        }

      do_cleanups (back_to);
    }

  return 0;
}


/* Expand macro references in SRC, appending the results to DEST.
   Assume we are re-scanning the result of expanding the macros named
   in NO_LOOP, and don't try to re-expand references to them.

   SRC must be a shared buffer; DEST must not be one.  */
static void
scan (struct macro_buffer *dest,
      struct macro_buffer *src,
      struct macro_name_list *no_loop,
      macro_lookup_ftype *lookup_func,
      void *lookup_baton)
{
  gdb_assert (src->shared);
  gdb_assert (! dest->shared);

  for (;;)
    {
      struct macro_buffer tok;
      char *original_src_start = src->text;

      /* Find the next token in SRC.  */
      if (! get_token (&tok, src))
        break;

      /* Just for aesthetics.  If we skipped some whitespace, copy
         that to DEST.  */
      if (tok.text > original_src_start)
        {
          appendmem (dest, original_src_start, tok.text - original_src_start);
          dest->last_token = dest->len;
        }

      if (! maybe_expand (dest, &tok, src, no_loop, lookup_func, lookup_baton))
        /* We didn't end up expanding tok as a macro reference, so
           simply append it to dest.  */
        append_tokens_without_splicing (dest, &tok);
    }

  /* Just for aesthetics.  If there was any trailing whitespace in
     src, copy it to dest.  */
  if (src->len)
    {
      appendmem (dest, src->text, src->len);
      dest->last_token = dest->len;
    }
}


char *
macro_expand (const char *source,
              macro_lookup_ftype *lookup_func,
              void *lookup_func_baton)
{
  struct macro_buffer src, dest;
  struct cleanup *back_to;

  init_shared_buffer (&src, (char *) source, strlen (source));

  init_buffer (&dest, 0);
  dest.last_token = 0;
  back_to = make_cleanup (cleanup_macro_buffer, &dest);

  scan (&dest, &src, 0, lookup_func, lookup_func_baton);

  appendc (&dest, '\0');

  discard_cleanups (back_to);
  return dest.text;
}


char *
macro_expand_once (const char *source,
                   macro_lookup_ftype *lookup_func,
                   void *lookup_func_baton)
{
  error ("Expand-once not implemented yet.");
}


char *
macro_expand_next (char **lexptr,
                   macro_lookup_ftype *lookup_func,
                   void *lookup_baton)
{
  struct macro_buffer src, dest, tok;
  struct cleanup *back_to;

  /* Set up SRC to refer to the input text, pointed to by *lexptr.  */
  init_shared_buffer (&src, *lexptr, strlen (*lexptr));

  /* Set up DEST to receive the expansion, if there is one.  */
  init_buffer (&dest, 0);
  dest.last_token = 0;
  back_to = make_cleanup (cleanup_macro_buffer, &dest);

  /* Get the text's first preprocessing token.  */
  if (! get_token (&tok, &src))
    {
      do_cleanups (back_to);
      return 0;
    }

  /* If it's a macro invocation, expand it.  */
  if (maybe_expand (&dest, &tok, &src, 0, lookup_func, lookup_baton))
    {
      /* It was a macro invocation!  Package up the expansion as a
         null-terminated string and return it.  Set *lexptr to the
         start of the next token in the input.  */
      appendc (&dest, '\0');
      discard_cleanups (back_to);
      *lexptr = src.text;
      return dest.text;
    }
  else
    {
      /* It wasn't a macro invocation.  */
      do_cleanups (back_to);
      return 0;
    }
}
@


1.1.2.2
log
@Revert 8 May change; it's going to be revised.
@
text
@@


1.1.2.3
log
@Add first preprocessor macro-expansion files.
* macroexp.c, macroexp.h, macrotab.c, macrotab.h: New files.
* Makefile.in (SFILES): Add macrotab.c, macroexp.c.
(splay_tree_h, macroexp_h, macrotab_h): New variable.
(HFILES_NO_SRCDIR): Add macrotab.h, macroexp.h.
(COMMON_OBS): Add macrotab.o, macroexp.o.
(macroexp.o, macrotab.o): New rules.
@
text
@d342 1
a342 1
            error ("Invalid character constant.");
@


1.1.2.4
log
@Revert last reversion.  The original was better.
@
text
@d342 1
a342 1
            error ("Unmatched single quote.");
@


