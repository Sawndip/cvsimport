head	1.15;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.15
	gdb_7_6-2013-04-26-release:1.15
	gdb_7_6-branch:1.15.0.2
	gdb_7_6-2013-03-12-branchpoint:1.15
	gdb_7_5_1-2012-11-29-release:1.14
	gdb_7_5-2012-08-17-release:1.14
	gdb_7_5-branch:1.14.0.2
	gdb_7_5-2012-07-18-branchpoint:1.14
	gdb_7_4_1-2012-04-26-release:1.13.4.1
	gdb_7_4-2012-01-24-release:1.13.4.1
	gdb_7_4-branch:1.13.0.4
	gdb_7_4-2011-12-13-branchpoint:1.13
	gdb_7_3_1-2011-09-04-release:1.13
	gdb_7_3-2011-07-26-release:1.13
	gdb_7_3-branch:1.13.0.2
	gdb_7_3-2011-04-01-branchpoint:1.13
	gdb_7_2-2010-09-02-release:1.10
	gdb_7_2-branch:1.10.0.2
	gdb_7_2-2010-07-07-branchpoint:1.10
	gdb_7_1-2010-03-18-release:1.9
	gdb_7_1-branch:1.9.0.2
	gdb_7_1-2010-02-18-branchpoint:1.9
	gdb_7_0_1-2009-12-22-release:1.8
	gdb_7_0-2009-10-06-release:1.8
	gdb_7_0-branch:1.8.0.4
	gdb_7_0-2009-09-16-branchpoint:1.8
	arc-sim-20090309:1.6
	msnyder-checkpoint-072509-branch:1.8.0.2
	msnyder-checkpoint-072509-branchpoint:1.8
	arc-insight_6_8-branch:1.6.0.16
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.14
	insight_6_8-branchpoint:1.6
	reverse-20081226-branch:1.6.0.12
	reverse-20081226-branchpoint:1.6
	multiprocess-20081120-branch:1.6.0.10
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.8
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.6
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.4
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.2.0.2
	drow-reverse-20070409-branchpoint:1.2
	gdb_6_8-2008-03-27-release:1.6
	gdb_6_8-branch:1.6.0.2
	gdb_6_8-2008-02-26-branchpoint:1.6
	gdb_6_7_1-2007-10-29-release:1.4
	gdb_6_7-2007-10-10-release:1.4
	gdb_6_7-branch:1.4.0.2
	gdb_6_7-2007-09-07-branchpoint:1.4
	insight_6_6-20070208-release:1.1
	gdb_6_6-2006-12-18-release:1.1
	gdb_6_6-branch:1.1.0.2
	gdb_6_6-2006-11-15-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.15
date	2013.01.01.06.32.52;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2012.01.04.08.17.13;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.11.21.53.25;	author msnyder;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2011.01.05.22.22.53;	author msnyder;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.01.15.33.17;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.17.01.15.20;	author msnyder;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.01.07.31.42;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.07.16.46.48;	author palves;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.24.20.14.58;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2007.08.23.18.08.45;	author brobecke;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.07.14.24.15;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.21.14.00.53;	author drow;	state Exp;
branches;
next	;

1.13.4.1
date	2012.01.06.04.43.31;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Parts of target interface that deal with accessing memory and memory-like
   objects.

   Copyright (C) 2006-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "vec.h"
#include "target.h"
#include "memory-map.h"

#include "gdb_assert.h"

#include <stdio.h>
#include <sys/time.h>

static int
compare_block_starting_address (const void *a, const void *b)
{
  const struct memory_write_request *a_req = a;
  const struct memory_write_request *b_req = b;

  if (a_req->begin < b_req->begin)
    return -1;
  else if (a_req->begin == b_req->begin)
    return 0;
  else
    return 1;
}

/* Adds to RESULT all memory write requests from BLOCK that are
   in [BEGIN, END) range.

   If any memory request is only partially in the specified range,
   that part of the memory request will be added.  */

static void
claim_memory (VEC(memory_write_request_s) *blocks,
	      VEC(memory_write_request_s) **result,
	      ULONGEST begin,
	      ULONGEST end)
{
  int i;
  ULONGEST claimed_begin;
  ULONGEST claimed_end;
  struct memory_write_request *r;

  for (i = 0; VEC_iterate (memory_write_request_s, blocks, i, r); ++i)
    {
      /* If the request doesn't overlap [BEGIN, END), skip it.  We
	 must handle END == 0 meaning the top of memory; we don't yet
	 check for R->end == 0, which would also mean the top of
	 memory, but there's an assertion in
	 target_write_memory_blocks which checks for that.  */

      if (begin >= r->end)
	continue;
      if (end != 0 && end <= r->begin)
	continue;

      claimed_begin = max (begin, r->begin);
      if (end == 0)
	claimed_end = r->end;
      else
	claimed_end = min (end, r->end);

      if (claimed_begin == r->begin && claimed_end == r->end)
	VEC_safe_push (memory_write_request_s, *result, r);
      else
	{
	  struct memory_write_request *n =
	    VEC_safe_push (memory_write_request_s, *result, NULL);

	  *n = *r;
	  n->begin = claimed_begin;
	  n->end = claimed_end;
	  n->data += claimed_begin - r->begin;
	}
    }
}

/* Given a vector of struct memory_write_request objects in BLOCKS,
   add memory requests for flash memory into FLASH_BLOCKS, and for
   regular memory to REGULAR_BLOCKS.  */

static void
split_regular_and_flash_blocks (VEC(memory_write_request_s) *blocks,
				VEC(memory_write_request_s) **regular_blocks,
				VEC(memory_write_request_s) **flash_blocks)
{
  struct mem_region *region;
  CORE_ADDR cur_address;

  /* This implementation runs in O(length(regions)*length(blocks)) time.
     However, in most cases the number of blocks will be small, so this does
     not matter.

     Note also that it's extremely unlikely that a memory write request
     will span more than one memory region, however for safety we handle
     such situations.  */

  cur_address = 0;
  while (1)
    {
      VEC(memory_write_request_s) **r;

      region = lookup_mem_region (cur_address);
      r = region->attrib.mode == MEM_FLASH ? flash_blocks : regular_blocks;
      cur_address = region->hi;
      claim_memory (blocks, r, region->lo, region->hi);

      if (cur_address == 0)
	break;
    }
}

/* Given an ADDRESS, if BEGIN is non-NULL this function sets *BEGIN
   to the start of the flash block containing the address.  Similarly,
   if END is non-NULL *END will be set to the address one past the end
   of the block containing the address.  */

static void
block_boundaries (CORE_ADDR address, CORE_ADDR *begin, CORE_ADDR *end)
{
  struct mem_region *region;
  unsigned blocksize;

  region = lookup_mem_region (address);
  gdb_assert (region->attrib.mode == MEM_FLASH);
  blocksize = region->attrib.blocksize;
  if (begin)
    *begin = address / blocksize * blocksize;
  if (end)
    *end = (address + blocksize - 1) / blocksize * blocksize;
}

/* Given the list of memory requests to be WRITTEN, this function
   returns write requests covering each group of flash blocks which must
   be erased.  */

static VEC(memory_write_request_s) *
blocks_to_erase (VEC(memory_write_request_s) *written)
{
  unsigned i;
  struct memory_write_request *ptr;

  VEC(memory_write_request_s) *result = NULL;

  for (i = 0; VEC_iterate (memory_write_request_s, written, i, ptr); ++i)
    {
      CORE_ADDR begin, end;

      block_boundaries (ptr->begin, &begin, 0);
      block_boundaries (ptr->end - 1, 0, &end);

      if (!VEC_empty (memory_write_request_s, result)
	  && VEC_last (memory_write_request_s, result)->end >= begin)
	{
	  VEC_last (memory_write_request_s, result)->end = end;
	}
      else
	{
	  struct memory_write_request *n =
	    VEC_safe_push (memory_write_request_s, result, NULL);

	  memset (n, 0, sizeof (struct memory_write_request));
	  n->begin = begin;
	  n->end = end;
	}
    }

  return result;
}

/* Given ERASED_BLOCKS, a list of blocks that will be erased with
   flash erase commands, and WRITTEN_BLOCKS, the list of memory
   addresses that will be written, compute the set of memory addresses
   that will be erased but not rewritten (e.g. padding within a block
   which is only partially filled by "load").  */

static VEC(memory_write_request_s) *
compute_garbled_blocks (VEC(memory_write_request_s) *erased_blocks,
			VEC(memory_write_request_s) *written_blocks)
{
  VEC(memory_write_request_s) *result = NULL;

  unsigned i, j;
  unsigned je = VEC_length (memory_write_request_s, written_blocks);
  struct memory_write_request *erased_p;

  /* Look at each erased memory_write_request in turn, and
     see what part of it is subsequently written to.

     This implementation is O(length(erased) * length(written)).  If
     the lists are sorted at this point it could be rewritten more
     efficiently, but the complexity is not generally worthwhile.  */

  for (i = 0;
       VEC_iterate (memory_write_request_s, erased_blocks, i, erased_p);
       ++i)
    {
      /* Make a deep copy -- it will be modified inside the loop, but
	 we don't want to modify original vector.  */
      struct memory_write_request erased = *erased_p;

      for (j = 0; j != je;)
	{
	  struct memory_write_request *written
	    = VEC_index (memory_write_request_s,
			 written_blocks, j);

	  /* Now try various cases.  */

	  /* If WRITTEN is fully to the left of ERASED, check the next
	     written memory_write_request.  */
	  if (written->end <= erased.begin)
	    {
	      ++j;
	      continue;
	    }

	  /* If WRITTEN is fully to the right of ERASED, then ERASED
	     is not written at all.  WRITTEN might affect other
	     blocks.  */
	  if (written->begin >= erased.end)
	    {
	      VEC_safe_push (memory_write_request_s, result, &erased);
	      goto next_erased;
	    }

	  /* If all of ERASED is completely written, we can move on to
	     the next erased region.  */
	  if (written->begin <= erased.begin
	      && written->end >= erased.end)
	    {
	      goto next_erased;
	    }

	  /* If there is an unwritten part at the beginning of ERASED,
	     then we should record that part and try this inner loop
	     again for the remainder.  */
	  if (written->begin > erased.begin)
	    {
	      struct memory_write_request *n =
		VEC_safe_push (memory_write_request_s, result, NULL);

	      memset (n, 0, sizeof (struct memory_write_request));
	      n->begin = erased.begin;
	      n->end = written->begin;
	      erased.begin = written->begin;
	      continue;
	    }

	  /* If there is an unwritten part at the end of ERASED, we
	     forget about the part that was written to and wait to see
	     if the next write request writes more of ERASED.  We can't
	     push it yet.  */
	  if (written->end < erased.end)
	    {
	      erased.begin = written->end;
	      ++j;
	      continue;
	    }
	}

      /* If we ran out of write requests without doing anything about
	 ERASED, then that means it's really erased.  */
      VEC_safe_push (memory_write_request_s, result, &erased);

    next_erased:
      ;
    }

  return result;
}

static void
cleanup_request_data (void *p)
{
  VEC(memory_write_request_s) **v = p;
  struct memory_write_request *r;
  int i;

  for (i = 0; VEC_iterate (memory_write_request_s, *v, i, r); ++i)
    xfree (r->data);
}

static void
cleanup_write_requests_vector (void *p)
{
  VEC(memory_write_request_s) **v = p;

  VEC_free (memory_write_request_s, *v);
}

int
target_write_memory_blocks (VEC(memory_write_request_s) *requests,
			    enum flash_preserve_mode preserve_flash_p,
			    void (*progress_cb) (ULONGEST, void *))
{
  struct cleanup *back_to = make_cleanup (null_cleanup, NULL);
  VEC(memory_write_request_s) *blocks = VEC_copy (memory_write_request_s,
						  requests);
  unsigned i;
  int err = 0;
  struct memory_write_request *r;
  VEC(memory_write_request_s) *regular = NULL;
  VEC(memory_write_request_s) *flash = NULL;
  VEC(memory_write_request_s) *erased, *garbled;

  /* END == 0 would represent wraparound: a write to the very last
     byte of the address space.  This file was not written with that
     possibility in mind.  This is fixable, but a lot of work for a
     rare problem; so for now, fail noisily here instead of obscurely
     later.  */
  for (i = 0; VEC_iterate (memory_write_request_s, requests, i, r); ++i)
    gdb_assert (r->end != 0);

  make_cleanup (cleanup_write_requests_vector, &blocks);

  /* Sort the blocks by their start address.  */
  qsort (VEC_address (memory_write_request_s, blocks),
	 VEC_length (memory_write_request_s, blocks),
	 sizeof (struct memory_write_request), compare_block_starting_address);

  /* Split blocks into list of regular memory blocks,
     and list of flash memory blocks.  */
  make_cleanup (cleanup_write_requests_vector, &regular);
  make_cleanup (cleanup_write_requests_vector, &flash);
  split_regular_and_flash_blocks (blocks, &regular, &flash);

  /* If a variable is added to forbid flash write, even during "load",
     it should be checked here.  Similarly, if this function is used
     for other situations besides "load" in which writing to flash
     is undesirable, that should be checked here.  */

  /* Find flash blocks to erase.  */
  erased = blocks_to_erase (flash);
  make_cleanup (cleanup_write_requests_vector, &erased);

  /* Find what flash regions will be erased, and not overwritten; then
     either preserve or discard the old contents.  */
  garbled = compute_garbled_blocks (erased, flash);
  make_cleanup (cleanup_request_data, &garbled);
  make_cleanup (cleanup_write_requests_vector, &garbled);

  if (!VEC_empty (memory_write_request_s, garbled))
    {
      if (preserve_flash_p == flash_preserve)
	{
	  struct memory_write_request *r;

	  /* Read in regions that must be preserved and add them to
	     the list of blocks we read.  */
	  for (i = 0; VEC_iterate (memory_write_request_s, garbled, i, r); ++i)
	    {
	      gdb_assert (r->data == NULL);
	      r->data = xmalloc (r->end - r->begin);
	      err = target_read_memory (r->begin, r->data, r->end - r->begin);
	      if (err != 0)
		goto out;

	      VEC_safe_push (memory_write_request_s, flash, r);
	    }

	  qsort (VEC_address (memory_write_request_s, flash),
		 VEC_length (memory_write_request_s, flash),
		 sizeof (struct memory_write_request),
		 compare_block_starting_address);
	}
    }

  /* We could coalesce adjacent memory blocks here, to reduce the
     number of write requests for small sections.  However, we would
     have to reallocate and copy the data pointers, which could be
     large; large sections are more common in loadable objects than
     large numbers of small sections (although the reverse can be true
     in object files).  So, we issue at least one write request per
     passed struct memory_write_request.  The remote stub will still
     have the opportunity to batch flash requests.  */

  /* Write regular blocks.  */
  for (i = 0; VEC_iterate (memory_write_request_s, regular, i, r); ++i)
    {
      LONGEST len;

      len = target_write_with_progress (current_target.beneath,
					TARGET_OBJECT_MEMORY, NULL,
					r->data, r->begin, r->end - r->begin,
					progress_cb, r->baton);
      if (len < (LONGEST) (r->end - r->begin))
	{
	  /* Call error?  */
	  err = -1;
	  goto out;
	}
    }

  if (!VEC_empty (memory_write_request_s, erased))
    {
      /* Erase all pages.  */
      for (i = 0; VEC_iterate (memory_write_request_s, erased, i, r); ++i)
	target_flash_erase (r->begin, r->end - r->begin);

      /* Write flash data.  */
      for (i = 0; VEC_iterate (memory_write_request_s, flash, i, r); ++i)
	{
	  LONGEST len;

	  len = target_write_with_progress (&current_target,
					    TARGET_OBJECT_FLASH, NULL,
					    r->data, r->begin,
					    r->end - r->begin,
					    progress_cb, r->baton);
	  if (len < (LONGEST) (r->end - r->begin))
	    error (_("Error writing data to flash"));
	}

      target_flash_done ();
    }

 out:
  do_cleanups (back_to);

  return err;
}
@


1.14
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d4 1
a4 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.13
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d4 1
a4 2
   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.13.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d4 2
a5 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.12
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d342 1
a342 1
     and list of flash memory blocks. */
@


1.11
log
@run copyright.sh for 2011.
@
text
@d383 2
a384 1
		 sizeof (struct memory_write_request), compare_block_starting_address);
d427 2
a428 1
					    r->data, r->begin, r->end - r->begin,
@


1.10
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* target.c: White space.
	* target-descriptions.c: White space.
	* target-memory.c: White space.
	* thread.c: White space.
	* top.c: White space.
	* tracepoint.c: White space.
	* trad-frame.c: White space.
	* tramp-frame.c: White space.
	* ui-file.c: White space.
	* ui-out.c: White space.
	* user-regs.c: White space.
	* utils.c: White space.
@
text
@d4 2
a5 1
   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.9
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d87 1
d120 1
a121 1

d179 1
d260 1
d306 1
@


1.8
log
@	* target.h (struct target_ops): Make to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	methods instead of variables.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1)
	(target_has_registers_1, target_has_execution_1): Declare
	functions.
	(target_has_all_memory): Rewrite to call target_has_all_memory_1.
	(target_has_memory): Rewrite to call target_has_memory_1.
	(target_has_stack): Rewrite to call target_has_all_stack_1.
	(target_has_registers): Rewrite to call target_has_registers_1.
	(target_has_execution): Rewrite to call target_has_execution_1.
	(default_child_has_all_memory, default_child_has_memory)
	(default_child_has_stack, default_child_has_registers)
	(default_child_has_execution): Declare.
	(target_mark_running, target_mark_exited): Delete declarations.
	* target.c (default_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution): New.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1,
	target_has_registers_1, target_has_execution_1): New.
	(add_target): Default the to_has_all_memory, to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	callbacks to return 0.
	(update_current_target): Do not inherit to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers or to_has_execution.
	(target_mark_running, target_mark_exited): Delete.
	(memory_xfer_partial): Adjust.
	(target_read_memory, target_write_memory, target_search_memory):
	Dispatch to the the top-most target, not the flattened
	current_target.
	(target_info): Adjust.
	(init_dummy_target): Install return_zero as callback for
	to_has_all_memory, to_has_memory, to_has_stack, to_has_registers,
	to_has_execution.
	(set_maintenance_target_async_permitted): Use have_live_inferiors
	instead of target_has_execution.
	* target-memory.c (target_write_memory_blocks): Dispatch memory
	writes to the the top-most target, not the flattened
	current_target.

	* breakpoint.c (insert_breakpoints): Don't check for
	target_has_execution here.
	(update_global_location_list): Check if there are live inferiors
	to debug instead of target_has_execution.
	* infcmd.c (kill_command, detach_command): Check if there are
	inferiors instead of target_has_execution.
	* inferior.h (have_live_inferiors): Declare.
	* inferior.c (have_live_inferiors): New.
	* infrun.c (normal_stop): Don't check for target_has_execution to
	finish the thread states.
	* thread.c (is_thread_state, is_stopped, is_exited, is_running)
	(any_running, is_executing): Remove checks for
	target_has_execution.
	* top.c (kill_or_detach): Don't try to kill core inferiors.
	(quit_target): Don't check for target_has_execution.

	* corelow.c (core_has_memory, core_has_stack, core_has_registers):
	New.
	(init_core_ops): Install core_has_memory, core_has_stack and
	core_has_registers.
	* exec.c (exec_has_memory): New.
	(init_exec_ops): Install exec_has_memory.
	* remote.c (remote_add_inferior): Don't call target_mark_running.
	(remote_start_remote): Don't call target_mark_exited or call
	target_mark_running.
	(remote_open_1): Use have_inferiors instead of
	target_has_execution.  Don't use target_mark_exited.
	(init_remote_ops): Install deafult_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution.
	* bsd-kvm.c (bsd_kvm_return_one): New.
	(bsd_kvm_add_target): Register bsd_kvm_return_one as
	to_has_memory, to_has_stack and to_has_registers callbacks.
	* remote-m32r-sdi.c (m32r_return_one): New.
	(init_m32r_ops): Register it.
	* inf-child.c (inf_child_target): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.
	* gnu-nat.c (init_gnu_ops): Likewise.
	* go32-nat.c (init_go32_ops): Likewise.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* monitor.c (init_base_monitor_ops): Likewise.
	* nto-procfs.c (init_procfs_ops): Likewise.
	* remote-mips.c (_initialize_remote_mips): Likewise.
	* windows-nat.c (init_windows_ops): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Don't use
	target_mark_running or target_mark_exited.
	(gdbsim_mourn_inferior): Don't call target_mark_exited.
	(init_gdbsim_ops): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.

	* linux-nat.c (linux_nat_xfer_partial): If reading memory, and
	there's no inferior selected, defer to a lower stratum.
@
text
@d4 1
a4 1
   Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.7
log
@        Updated copyright notices for most files.
@
text
@d396 1
a396 1
      len = target_write_with_progress (&current_target,
@


1.6
log
@	Updated copyright notices for most files.
@
text
@d4 1
a4 1
   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.5
log
@2007-10-24  Nathan Sidwell  <nathan@@codesourcery.com>

	* target-memory.c (claim_memory): Propagate baton for split memory
	requests.
@
text
@d4 1
a4 1
   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
@


1.4
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d87 1
a87 1
	  memset (n, 0, sizeof (struct memory_write_request));
d90 1
a90 1
	  n->data = r->data + (claimed_begin - r->begin);
@


1.3
log
@	* target-memory.c (blocks_to_erase): Correct off-by-one error.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.2
log
@Copyright updates for 2007.
@
text
@d169 1
a169 1
      block_boundaries (ptr->end, 0, &end);
@


1.1
log
@	* Makefile.in (SFILES): Add target-memory.c.
	(COMMON_OBS): Add target-memory.o.
	* memattr.c (lookup_mem_region): Adjust handling for
	the top of memory.  Improve comments.
	* remote.c (packet_check_result): New function, split out
	from packet_ok.  Recognize "E." as an error prefix.
	(packet_ok): Use it.
	(remote_write_bytes_aux): New function, renamed from
	remote_write_bytes.  Take packet header, packet format,
	and length flag as arguments.
	(remote_write_bytes): Rewrite to use remote_write_bytes_aux.
	(remote_send_printf, restore_remote_timeout)
	(remote_flash_timeout, remote_flash_erase, remote_flash_write)
	(remote_flash_done): New.
	(remote_xfer_partial): Handle flash writes.
	(init_remote_ops, init_remote_async_ops): Set to_flash_erase
	and to_flash_done.
	* symfile.c (struct load_section_data): Include a pointer to
	the cumulative stats and a request queue.  Move most members
	to other types.
	(struct load_progress_data, struct load_progress_section_data): New
	types.
	(load_progress): Handle a NULL baton and zero bytes.  Update for
	type changes.
	(load_section_callback): Create memory write requests instead of
	writing to memory.  Don't print the progress message here.
	(clear_memory_write_data): New function.
	(generic_load): Use target_write_memory_blocks.
	* target-memory.c: New file.
	* target.c (update_current_target): Mention new uninherited methods.
	(memory_xfer_partial): Issue an error for flash writes.
	(target_flash_erase, target_flash_done): New functions.
	(target_write_with_progress): Call the progress callback at the
	start also.
	* target.h (enum target_object): Add TARGET_OBJECT_FLASH.
	(target_write_with_progress): Update comment.
	(struct target_ops): Add to_flash_erase and to_flash_done.
	(target_flash_erase, target_flash_done, struct memory_write_request)
	(memory_write_request_s, enum flash_preserve_mode)
	(target_write_memory_blocks): New, including a vector type
	for memory_write_request_s.
@
text
@d4 1
a4 2
   Copyright (C) 2006
   Free Software Foundation, Inc.
@

