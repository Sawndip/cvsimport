head	1.396;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.365
	gdb_7_6-2013-04-26-release:1.365
	gdb_7_6-branch:1.365.0.2
	gdb_7_6-2013-03-12-branchpoint:1.365
	gdb_7_5_1-2012-11-29-release:1.335.2.1
	gdb_7_5-2012-08-17-release:1.335
	gdb_7_5-branch:1.335.0.2
	gdb_7_5-2012-07-18-branchpoint:1.335
	gdb_7_4_1-2012-04-26-release:1.320.2.3
	gdb_7_4-2012-01-24-release:1.320.2.3
	gdb_7_4-branch:1.320.0.2
	gdb_7_4-2011-12-13-branchpoint:1.320
	gdb_7_3_1-2011-09-04-release:1.310
	gdb_7_3-2011-07-26-release:1.310
	gdb_7_3-branch:1.310.0.2
	gdb_7_3-2011-04-01-branchpoint:1.310
	gdb_7_2-2010-09-02-release:1.288.2.1
	gdb_7_2-branch:1.288.0.2
	gdb_7_2-2010-07-07-branchpoint:1.288
	gdb_7_1-2010-03-18-release:1.272.2.3
	gdb_7_1-branch:1.272.0.2
	gdb_7_1-2010-02-18-branchpoint:1.272
	gdb_7_0_1-2009-12-22-release:1.245.2.1
	gdb_7_0-2009-10-06-release:1.245.2.1
	gdb_7_0-branch:1.245.0.2
	gdb_7_0-2009-09-16-branchpoint:1.245
	arc-sim-20090309:1.198
	msnyder-checkpoint-072509-branch:1.239.0.2
	msnyder-checkpoint-072509-branchpoint:1.239
	arc-insight_6_8-branch:1.198.0.6
	arc-insight_6_8-branchpoint:1.198
	insight_6_8-branch:1.198.0.4
	insight_6_8-branchpoint:1.198
	reverse-20081226-branch:1.218.0.4
	reverse-20081226-branchpoint:1.218
	multiprocess-20081120-branch:1.218.0.2
	multiprocess-20081120-branchpoint:1.218
	reverse-20080930-branch:1.216.0.2
	reverse-20080930-branchpoint:1.216
	reverse-20080717-branch:1.207.0.2
	reverse-20080717-branchpoint:1.207
	msnyder-reverse-20080609-branch:1.205.0.2
	msnyder-reverse-20080609-branchpoint:1.205
	drow-reverse-20070409-branch:1.182.0.2
	drow-reverse-20070409-branchpoint:1.182
	gdb_6_8-2008-03-27-release:1.198
	gdb_6_8-branch:1.198.0.2
	gdb_6_8-2008-02-26-branchpoint:1.198
	gdb_6_7_1-2007-10-29-release:1.191.2.1
	gdb_6_7-2007-10-10-release:1.191.2.1
	gdb_6_7-branch:1.191.0.2
	gdb_6_7-2007-09-07-branchpoint:1.191
	insight_6_6-20070208-release:1.177
	gdb_6_6-2006-12-18-release:1.177
	gdb_6_6-branch:1.177.0.2
	gdb_6_6-2006-11-15-branchpoint:1.177
	insight_6_5-20061003-release:1.171
	gdb-csl-symbian-6_4_50_20060226-12:1.171.2.1.2.5
	gdb-csl-sourcerygxx-3_4_4-25:1.162
	nickrob-async-20060828-mergepoint:1.176
	gdb-csl-symbian-6_4_50_20060226-11:1.171.2.1.2.5
	gdb-csl-sourcerygxx-4_1-17:1.171.2.1
	gdb-csl-20060226-branch-local-2:1.171.2.1
	gdb-csl-sourcerygxx-4_1-14:1.171.2.1
	gdb-csl-sourcerygxx-4_1-13:1.171.2.1
	gdb-csl-sourcerygxx-4_1-12:1.171.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.171.2.1
	gdb_6_5-20060621-release:1.171
	gdb-csl-sourcerygxx-4_1-9:1.171.2.1
	gdb-csl-sourcerygxx-4_1-8:1.171.2.1
	gdb-csl-sourcerygxx-4_1-7:1.171.2.1
	gdb-csl-arm-2006q1-6:1.171.2.1
	gdb-csl-sourcerygxx-4_1-6:1.171.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.171.2.1.2.3
	gdb-csl-symbian-6_4_50_20060226-9:1.171.2.1.2.3
	gdb-csl-symbian-6_4_50_20060226-8:1.171.2.1.2.3
	gdb-csl-coldfire-4_1-11:1.171.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.171.2.1
	gdb-csl-coldfire-4_1-10:1.171.2.1
	gdb_6_5-branch:1.171.0.14
	gdb_6_5-2006-05-14-branchpoint:1.171
	gdb-csl-sourcerygxx-4_1-5:1.171.2.1
	nickrob-async-20060513-branch:1.171.0.12
	nickrob-async-20060513-branchpoint:1.171
	gdb-csl-sourcerygxx-4_1-4:1.171.2.1
	msnyder-reverse-20060502-branch:1.171.0.10
	msnyder-reverse-20060502-branchpoint:1.171
	gdb-csl-morpho-4_1-4:1.171.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.171.2.1
	readline_5_1-import-branch:1.171.0.8
	readline_5_1-import-branchpoint:1.171
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.171.2.1
	gdb-csl-symbian-20060226-branch:1.171.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.171.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.171.2.1
	msnyder-reverse-20060331-branch:1.171.0.6
	msnyder-reverse-20060331-branchpoint:1.171
	gdb-csl-available-20060303-branch:1.171.0.4
	gdb-csl-available-20060303-branchpoint:1.171
	gdb-csl-20060226-branch:1.171.0.2
	gdb-csl-20060226-branchpoint:1.171
	gdb_6_4-20051202-release:1.162
	msnyder-fork-checkpoint-branch:1.162.0.8
	msnyder-fork-checkpoint-branchpoint:1.162
	gdb-csl-gxxpro-6_3-branch:1.162.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.162
	gdb_6_4-branch:1.162.0.4
	gdb_6_4-2005-11-01-branchpoint:1.162
	gdb-csl-arm-20051020-branch:1.162.0.2
	gdb-csl-arm-20051020-branchpoint:1.162
	msnyder-tracepoint-checkpoint-branch:1.158.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.158
	gdb-csl-arm-20050325-2005-q1b:1.157.2.1
	gdb-csl-arm-20050325-2005-q1a:1.157.2.1
	csl-arm-20050325-branch:1.157.0.2
	csl-arm-20050325-branchpoint:1.157
	gdb-post-i18n-errorwarning-20050211:1.145
	gdb-pre-i18n-errorwarning-20050211:1.144
	gdb_6_3-20041109-release:1.143
	gdb_6_3-branch:1.143.0.2
	gdb_6_3-20041019-branchpoint:1.143
	drow_intercu-merge-20040921:1.142
	drow_intercu-merge-20040915:1.142
	jimb-gdb_6_2-e500-branch:1.133.0.6
	jimb-gdb_6_2-e500-branchpoint:1.133
	gdb_6_2-20040730-release:1.133
	gdb_6_2-branch:1.133.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.133
	gdb_6_1_1-20040616-release:1.124
	gdb_6_1-2004-04-05-release:1.124
	drow_intercu-merge-20040402:1.124
	drow_intercu-merge-20040327:1.124
	ezannoni_pie-20040323-branch:1.124.0.6
	ezannoni_pie-20040323-branchpoint:1.124
	cagney_tramp-20040321-mergepoint:1.124
	cagney_tramp-20040309-branch:1.124.0.4
	cagney_tramp-20040309-branchpoint:1.124
	gdb_6_1-branch:1.124.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.124
	drow_intercu-20040221-branch:1.123.0.2
	drow_intercu-20040221-branchpoint:1.123
	cagney_bfdfile-20040213-branch:1.121.0.2
	cagney_bfdfile-20040213-branchpoint:1.121
	drow-cplus-merge-20040208:1.120
	carlton_dictionary-20040126-merge:1.117
	cagney_bigcore-20040122-branch:1.116.0.2
	cagney_bigcore-20040122-branchpoint:1.116
	drow-cplus-merge-20040113:1.114
	drow-cplus-merge-20031224:1.114
	drow-cplus-merge-20031220:1.114
	carlton_dictionary-20031215-merge:1.114
	drow-cplus-merge-20031214:1.114
	carlton-dictionary-20031111-merge:1.112
	gdb_6_0-2003-10-04-release:1.100.2.2
	kettenis_sparc-20030918-branch:1.108.0.4
	kettenis_sparc-20030918-branchpoint:1.108
	carlton_dictionary-20030917-merge:1.108
	ezannoni_pie-20030916-branchpoint:1.108
	ezannoni_pie-20030916-branch:1.108.0.2
	cagney_x86i386-20030821-branch:1.102.0.2
	cagney_x86i386-20030821-branchpoint:1.102
	carlton_dictionary-20030805-merge:1.101
	carlton_dictionary-20030627-merge:1.101
	gdb_6_0-branch:1.100.0.2
	gdb_6_0-2003-06-23-branchpoint:1.100
	jimb-ppc64-linux-20030613-branch:1.98.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.98
	cagney_convert-20030606-branch:1.95.0.2
	cagney_convert-20030606-branchpoint:1.95
	cagney_writestrings-20030508-branch:1.93.0.10
	cagney_writestrings-20030508-branchpoint:1.93
	jimb-ppc64-linux-20030528-branch:1.94.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.94
	carlton_dictionary-20030523-merge:1.94
	cagney_fileio-20030521-branch:1.94.0.2
	cagney_fileio-20030521-branchpoint:1.94
	kettenis_i386newframe-20030517-mergepoint:1.94
	jimb-ppc64-linux-20030509-branch:1.93.0.8
	jimb-ppc64-linux-20030509-branchpoint:1.93
	kettenis_i386newframe-20030504-mergepoint:1.93
	carlton_dictionary-20030430-merge:1.93
	kettenis_i386newframe-20030419-branch:1.93.0.6
	kettenis_i386newframe-20030419-branchpoint:1.93
	carlton_dictionary-20030416-merge:1.93
	cagney_frameaddr-20030409-mergepoint:1.93
	kettenis_i386newframe-20030406-branch:1.93.0.4
	kettenis_i386newframe-20030406-branchpoint:1.93
	cagney_frameaddr-20030403-branchpoint:1.93
	cagney_frameaddr-20030403-branch:1.93.0.2
	cagney_framebase-20030330-mergepoint:1.92
	cagney_framebase-20030326-branch:1.92.0.10
	cagney_framebase-20030326-branchpoint:1.92
	cagney_lazyid-20030317-branch:1.92.0.8
	cagney_lazyid-20030317-branchpoint:1.92
	kettenis-i386newframe-20030316-mergepoint:1.92
	offbyone-20030313-branch:1.92.0.6
	offbyone-20030313-branchpoint:1.92
	kettenis-i386newframe-20030308-branch:1.92.0.4
	kettenis-i386newframe-20030308-branchpoint:1.92
	carlton_dictionary-20030305-merge:1.92
	cagney_offbyone-20030303-branch:1.92.0.2
	cagney_offbyone-20030303-branchpoint:1.92
	carlton_dictionary-20030207-merge:1.87
	interps-20030203-mergepoint:1.86
	interps-20030202-branch:1.85.0.2
	interps-20030202-branchpoint:1.85
	cagney-unwind-20030108-branch:1.76.0.2
	cagney-unwind-20030108-branchpoint:1.76
	carlton_dictionary-20021223-merge:1.75
	jimb-separate-debug-021223-branch:1.75.0.2
	gdb_5_3-2002-12-12-release:1.65
	jimb-separate-debug-021125-branch:1.74.0.2
	carlton_dictionary-20021115-merge:1.71
	kseitz_interps-20021105-merge:1.71
	kseitz_interps-20021103-merge:1.71
	drow-cplus-merge-20021020:1.71
	drow-cplus-merge-20021025:1.71
	carlton_dictionary-20021025-merge:1.71
	carlton_dictionary-20021011-merge:1.69
	drow-cplus-branch:1.69.0.4
	drow-cplus-branchpoint:1.69
	kseitz_interps-20020930-merge:1.69
	carlton_dictionary-20020927-merge:1.69
	carlton_dictionary-branch:1.69.0.2
	carlton_dictionary-20020920-branchpoint:1.69
	gdb_5_3-branch:1.65.0.6
	gdb_5_3-2002-09-04-branchpoint:1.65
	kseitz_interps-20020829-merge:1.65
	cagney_sysregs-20020825-branch:1.65.0.4
	cagney_sysregs-20020825-branchpoint:1.65
	readline_4_3-import-branch:1.65.0.2
	readline_4_3-import-branchpoint:1.65
	gdb_5_2_1-2002-07-23-release:1.54.2.3
	kseitz_interps-20020528-branch:1.62.0.4
	kseitz_interps-20020528-branchpoint:1.62
	cagney_regbuf-20020515-branch:1.62.0.2
	cagney_regbuf-20020515-branchpoint:1.62
	jimb-macro-020506-branch:1.60.0.2
	jimb-macro-020506-branchpoint:1.60
	gdb_5_2-2002-04-29-release:1.54
	gdb_5_2-branch:1.54.0.2
	gdb_5_2-2002-03-03-branchpoint:1.54
	gdb_5_1_1-2002-01-24-release:1.36
	gdb_5_1_0_1-2002-01-03-release:1.36
	cygnus_cvs_20020108_pre:1.45
	gdb_5_1_0_1-2002-01-03-branchpoint:1.36
	gdb_5_1_0_1-2002-01-03-branch:1.36.0.6
	gdb_5_1-2001-11-21-release:1.36
	gdb_s390-2001-09-26-branch:1.36.0.4
	gdb_s390-2001-09-26-branchpoint:1.36
	gdb_5_1-2001-07-29-branch:1.36.0.2
	gdb_5_1-2001-07-29-branchpoint:1.36
	dberlin-typesystem-branch:1.34.0.2
	dberlin-typesystem-branchpoint:1.34
	gdb-post-ptid_t-2001-05-03:1.31
	gdb-pre-ptid_t-2001-05-03:1.31
	insight-precleanup-2001-01-01:1.22
	gdb-post-protoization-2000-07-29:1.16
	gdb-pre-protoization-2000-07-29:1.15
	gdb-premipsmulti-2000-06-06-branch:1.12.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.12
	gdb-post-params-removal-2000-06-04:1.12
	gdb-pre-params-removal-2000-06-04:1.11
	gdb-post-params-removal-2000-05-28:1.11
	gdb-pre-params-removal-2000-05-28:1.10
	gdb_5_0-2000-05-19-release:1.4
	gdb_4_18_2-2000-05-18-release:1.4
	gdb_4_95_1-2000-05-11-snapshot:1.4
	gdb_4_95_0-2000-04-27-snapshot:1.4
	gdb_5_0-2000-04-10-branch:1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.4
	repo-unification-2000-02-06:1.1.1.17
	insight-2000-02-04:1.1.1.17
	gdb-2000-02-04:1.1.1.17
	gdb-2000-02-02:1.1.1.17
	gdb-2000-02-01:1.1.1.16
	gdb-2000-01-31:1.1.1.15
	gdb-2000-01-26:1.1.1.15
	gdb-2000-01-24:1.1.1.15
	gdb-2000-01-17:1.1.1.15
	gdb-2000-01-10:1.1.1.15
	gdb-2000-01-05:1.1.1.15
	gdb-1999-12-21:1.1.1.15
	gdb-1999-12-13:1.1.1.15
	gdb-1999-12-07:1.1.1.15
	gdb-1999-12-06:1.1.1.15
	gdb-1999-11-16:1.1.1.14
	gdb-1999-11-08:1.1.1.14
	gdb-1999-11-01:1.1.1.13
	gdb-1999-10-25:1.1.1.13
	gdb-1999-10-18:1.1.1.13
	gdb-1999-10-11:1.1.1.12
	gdb-1999-10-04:1.1.1.11
	gdb-1999-09-28:1.1.1.10
	gdb-1999-09-21:1.1.1.10
	gdb-1999-09-13:1.1.1.10
	gdb-1999-09-08:1.1.1.10
	gdb-1999-08-30:1.1.1.9
	gdb-1999-08-23:1.1.1.8
	gdb-1999-08-16:1.1.1.7
	gdb-1999-08-09:1.1.1.7
	gdb-1999-08-02:1.1.1.6
	gdb-1999-07-26:1.1.1.5
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.396
date	2013.10.07.19.40.38;	author tromey;	state Exp;
branches;
next	1.395;

1.395
date	2013.09.25.23.17.12;	author devans;	state Exp;
branches;
next	1.394;

1.394
date	2013.09.25.22.48.18;	author devans;	state Exp;
branches;
next	1.393;

1.393
date	2013.09.24.14.00.06;	author jkratoch;	state Exp;
branches;
next	1.392;

1.392
date	2013.09.24.13.57.37;	author jkratoch;	state Exp;
branches;
next	1.391;

1.391
date	2013.09.24.13.51.55;	author jkratoch;	state Exp;
branches;
next	1.390;

1.390
date	2013.09.19.12.44.46;	author jkratoch;	state Exp;
branches;
next	1.389;

1.389
date	2013.09.13.14.21.03;	author jkratoch;	state Exp;
branches;
next	1.388;

1.388
date	2013.09.05.13.13.25;	author mbilal;	state Exp;
branches;
next	1.387;

1.387
date	2013.09.04.20.09.39;	author jkratoch;	state Exp;
branches;
next	1.386;

1.386
date	2013.09.04.06.17.07;	author mbilal;	state Exp;
branches;
next	1.385;

1.385
date	2013.08.26.18.43.39;	author devans;	state Exp;
branches;
next	1.384;

1.384
date	2013.08.20.15.04.51;	author tromey;	state Exp;
branches;
next	1.383;

1.383
date	2013.08.07.20.03.52;	author tromey;	state Exp;
branches;
next	1.382;

1.382
date	2013.08.05.15.51.02;	author tromey;	state Exp;
branches;
next	1.381;

1.381
date	2013.07.16.20.41.55;	author devans;	state Exp;
branches;
next	1.380;

1.380
date	2013.06.19.22.20.58;	author devans;	state Exp;
branches;
next	1.379;

1.379
date	2013.05.30.17.21.15;	author tromey;	state Exp;
branches;
next	1.378;

1.378
date	2013.05.30.16.24.36;	author tromey;	state Exp;
branches;
next	1.377;

1.377
date	2013.05.09.18.03.28;	author devans;	state Exp;
branches;
next	1.376;

1.376
date	2013.05.09.17.24.55;	author devans;	state Exp;
branches;
next	1.375;

1.375
date	2013.05.07.00.02.12;	author devans;	state Exp;
branches;
next	1.374;

1.374
date	2013.05.06.19.15.17;	author devans;	state Exp;
branches;
next	1.373;

1.373
date	2013.05.06.18.50.08;	author devans;	state Exp;
branches;
next	1.372;

1.372
date	2013.05.05.16.54.26;	author jkratoch;	state Exp;
branches;
next	1.371;

1.371
date	2013.05.04.06.19.31;	author devans;	state Exp;
branches;
next	1.370;

1.370
date	2013.04.08.20.04.42;	author tromey;	state Exp;
branches;
next	1.369;

1.369
date	2013.03.28.18.17.38;	author devans;	state Exp;
branches;
next	1.368;

1.368
date	2013.03.21.16.18.48;	author tromey;	state Exp;
branches;
next	1.367;

1.367
date	2013.03.14.20.26.19;	author tromey;	state Exp;
branches;
next	1.366;

1.366
date	2013.03.14.20.11.12;	author tromey;	state Exp;
branches;
next	1.365;

1.365
date	2013.03.07.21.57.30;	author kseitz;	state Exp;
branches;
next	1.364;

1.364
date	2013.02.19.18.31.49;	author ktietz;	state Exp;
branches;
next	1.363;

1.363
date	2013.02.01.19.39.03;	author jkratoch;	state Exp;
branches;
next	1.362;

1.362
date	2013.01.30.20.38.03;	author tromey;	state Exp;
branches;
next	1.361;

1.361
date	2013.01.21.18.15.32;	author tromey;	state Exp;
branches;
next	1.360;

1.360
date	2013.01.21.18.13.14;	author tromey;	state Exp;
branches;
next	1.359;

1.359
date	2013.01.01.06.32.51;	author brobecke;	state Exp;
branches;
next	1.358;

1.358
date	2012.12.18.19.25.24;	author tromey;	state Exp;
branches;
next	1.357;

1.357
date	2012.12.15.13.11.18;	author brobecke;	state Exp;
branches;
next	1.356;

1.356
date	2012.12.15.13.10.50;	author brobecke;	state Exp;
branches;
next	1.355;

1.355
date	2012.12.12.16.22.33;	author tromey;	state Exp;
branches;
next	1.354;

1.354
date	2012.12.11.18.45.24;	author tromey;	state Exp;
branches;
next	1.353;

1.353
date	2012.11.27.08.11.59;	author qiyao;	state Exp;
branches;
next	1.352;

1.352
date	2012.11.26.19.23.52;	author tromey;	state Exp;
branches;
next	1.351;

1.351
date	2012.11.09.19.58.01;	author tromey;	state Exp;
branches;
next	1.350;

1.350
date	2012.08.22.17.48.54;	author tromey;	state Exp;
branches;
next	1.349;

1.349
date	2012.08.22.16.44.45;	author tromey;	state Exp;
branches;
next	1.348;

1.348
date	2012.08.22.16.24.39;	author tromey;	state Exp;
branches;
next	1.347;

1.347
date	2012.08.22.16.12.50;	author tromey;	state Exp;
branches;
next	1.346;

1.346
date	2012.08.22.16.01.07;	author tromey;	state Exp;
branches;
next	1.345;

1.345
date	2012.08.21.15.43.46;	author muller;	state Exp;
branches;
next	1.344;

1.344
date	2012.08.09.06.26.24;	author qiyao;	state Exp;
branches;
next	1.343;

1.343
date	2012.07.24.20.15.56;	author tromey;	state Exp;
branches;
next	1.342;

1.342
date	2012.07.23.15.03.59;	author tromey;	state Exp;
branches;
next	1.341;

1.341
date	2012.07.23.14.58.44;	author tromey;	state Exp;
branches;
next	1.340;

1.340
date	2012.07.23.14.57.57;	author tromey;	state Exp;
branches;
next	1.339;

1.339
date	2012.07.23.14.56.10;	author tromey;	state Exp;
branches;
next	1.338;

1.338
date	2012.07.18.19.42.26;	author tromey;	state Exp;
branches;
next	1.337;

1.337
date	2012.07.18.19.34.57;	author tromey;	state Exp;
branches;
next	1.336;

1.336
date	2012.07.18.19.33.34;	author tromey;	state Exp;
branches;
next	1.335;

1.335
date	2012.06.26.20.14.02;	author devans;	state Exp;
branches
	1.335.2.1;
next	1.334;

1.334
date	2012.05.31.18.44.49;	author kseitz;	state Exp;
branches;
next	1.333;

1.333
date	2012.05.29.14.23.40;	author tromey;	state Exp;
branches;
next	1.332;

1.332
date	2012.05.18.21.02.50;	author sergiodj;	state Exp;
branches;
next	1.331;

1.331
date	2012.04.28.23.22.13;	author devans;	state Exp;
branches;
next	1.330;

1.330
date	2012.04.17.15.47.09;	author jkratoch;	state Exp;
branches;
next	1.329;

1.329
date	2012.03.13.21.02.36;	author devans;	state Exp;
branches;
next	1.328;

1.328
date	2012.02.21.06.55.36;	author devans;	state Exp;
branches;
next	1.327;

1.327
date	2012.02.16.21.07.20;	author tromey;	state Exp;
branches;
next	1.326;

1.326
date	2012.01.18.18.58.42;	author ppluzhnikov;	state Exp;
branches;
next	1.325;

1.325
date	2012.01.12.00.00.01;	author ppluzhnikov;	state Exp;
branches;
next	1.324;

1.324
date	2012.01.04.08.17.13;	author brobecke;	state Exp;
branches;
next	1.323;

1.323
date	2011.12.21.14.25.53;	author jkratoch;	state Exp;
branches;
next	1.322;

1.322
date	2011.12.19.22.20.05;	author jkratoch;	state Exp;
branches;
next	1.321;

1.321
date	2011.12.15.15.36.55;	author tromey;	state Exp;
branches;
next	1.320;

1.320
date	2011.11.01.14.51.21;	author jlebar;	state Exp;
branches
	1.320.2.1;
next	1.319;

1.319
date	2011.10.11.19.00.22;	author uweigand;	state Exp;
branches;
next	1.318;

1.318
date	2011.10.11.12.58.08;	author jkratoch;	state Exp;
branches;
next	1.317;

1.317
date	2011.10.11.03.31.59;	author devans;	state Exp;
branches;
next	1.316;

1.316
date	2011.09.29.02.04.25;	author qiyao;	state Exp;
branches;
next	1.315;

1.315
date	2011.08.27.10.28.31;	author ratmice;	state Exp;
branches;
next	1.314;

1.314
date	2011.08.04.19.10.13;	author palves;	state Exp;
branches;
next	1.313;

1.313
date	2011.05.11.04.56.07;	author jkratoch;	state Exp;
branches;
next	1.312;

1.312
date	2011.04.17.18.38.45;	author jkratoch;	state Exp;
branches;
next	1.311;

1.311
date	2011.04.04.14.37.16;	author tromey;	state Exp;
branches;
next	1.310;

1.310
date	2011.03.23.18.23.55;	author ktietz;	state Exp;
branches;
next	1.309;

1.309
date	2011.03.07.16.17.29;	author tromey;	state Exp;
branches;
next	1.308;

1.308
date	2011.03.05.00.52.41;	author msnyder;	state Exp;
branches;
next	1.307;

1.307
date	2011.02.26.02.07.09;	author msnyder;	state Exp;
branches;
next	1.306;

1.306
date	2011.02.22.15.58.37;	author tromey;	state Exp;
branches;
next	1.305;

1.305
date	2011.01.11.21.53.24;	author msnyder;	state Exp;
branches;
next	1.304;

1.304
date	2011.01.05.22.22.50;	author msnyder;	state Exp;
branches;
next	1.303;

1.303
date	2011.01.03.07.53.06;	author brobecke;	state Exp;
branches;
next	1.302;

1.302
date	2011.01.01.15.33.16;	author brobecke;	state Exp;
branches;
next	1.301;

1.301
date	2010.11.23.00.59.58;	author brobecke;	state Exp;
branches;
next	1.300;

1.300
date	2010.11.23.00.58.55;	author brobecke;	state Exp;
branches;
next	1.299;

1.299
date	2010.10.17.18.49.46;	author jkratoch;	state Exp;
branches;
next	1.298;

1.298
date	2010.10.17.17.45.16;	author jkratoch;	state Exp;
branches;
next	1.297;

1.297
date	2010.10.01.20.26.11;	author tromey;	state Exp;
branches;
next	1.296;

1.296
date	2010.09.30.19.14.30;	author tromey;	state Exp;
branches;
next	1.295;

1.295
date	2010.08.31.20.10.42;	author swagiaal;	state Exp;
branches;
next	1.294;

1.294
date	2010.08.31.17.26.08;	author swagiaal;	state Exp;
branches;
next	1.293;

1.293
date	2010.07.30.16.04.29;	author jkratoch;	state Exp;
branches;
next	1.292;

1.292
date	2010.07.28.16.23.59;	author tromey;	state Exp;
branches;
next	1.291;

1.291
date	2010.07.20.22.19.07;	author jkratoch;	state Exp;
branches;
next	1.290;

1.290
date	2010.07.13.20.52.52;	author tromey;	state Exp;
branches;
next	1.289;

1.289
date	2010.07.13.20.51.33;	author tromey;	state Exp;
branches;
next	1.288;

1.288
date	2010.06.02.23.01.00;	author jkratoch;	state Exp;
branches
	1.288.2.1;
next	1.287;

1.287
date	2010.05.16.23.49.58;	author msnyder;	state Exp;
branches;
next	1.286;

1.286
date	2010.05.08.04.58.45;	author jkratoch;	state Exp;
branches;
next	1.285;

1.285
date	2010.05.06.01.16.15;	author msnyder;	state Exp;
branches;
next	1.284;

1.284
date	2010.04.29.14.45.38;	author brobecke;	state Exp;
branches;
next	1.283;

1.283
date	2010.04.27.21.01.57;	author brobecke;	state Exp;
branches;
next	1.282;

1.282
date	2010.04.27.21.01.30;	author brobecke;	state Exp;
branches;
next	1.281;

1.281
date	2010.04.27.20.07.01;	author jkratoch;	state Exp;
branches;
next	1.280;

1.280
date	2010.03.25.20.29.28;	author jkratoch;	state Exp;
branches;
next	1.279;

1.279
date	2010.03.17.18.08.11;	author drow;	state Exp;
branches;
next	1.278;

1.278
date	2010.03.15.09.31.34;	author jkratoch;	state Exp;
branches;
next	1.277;

1.277
date	2010.03.10.18.20.07;	author tromey;	state Exp;
branches;
next	1.276;

1.276
date	2010.03.08.08.32.49;	author jkratoch;	state Exp;
branches;
next	1.275;

1.275
date	2010.03.05.19.32.44;	author uweigand;	state Exp;
branches;
next	1.274;

1.274
date	2010.02.25.15.40.01;	author drow;	state Exp;
branches;
next	1.273;

1.273
date	2010.02.19.06.19.45;	author jkratoch;	state Exp;
branches;
next	1.272;

1.272
date	2010.02.18.19.17.00;	author palves;	state Exp;
branches
	1.272.2.1;
next	1.271;

1.271
date	2010.02.17.20.54.52;	author jkratoch;	state Exp;
branches;
next	1.270;

1.270
date	2010.02.16.20.28.06;	author drow;	state Exp;
branches;
next	1.269;

1.269
date	2010.02.03.14.13.16;	author gingold;	state Exp;
branches;
next	1.268;

1.268
date	2010.01.19.09.47.47;	author brobecke;	state Exp;
branches;
next	1.267;

1.267
date	2010.01.09.09.11.00;	author jkratoch;	state Exp;
branches;
next	1.266;

1.266
date	2010.01.08.22.55.15;	author jkratoch;	state Exp;
branches;
next	1.265;

1.265
date	2010.01.07.09.30.46;	author gingold;	state Exp;
branches;
next	1.264;

1.264
date	2010.01.06.10.11.04;	author gingold;	state Exp;
branches;
next	1.263;

1.263
date	2010.01.05.15.51.02;	author jkratoch;	state Exp;
branches;
next	1.262;

1.262
date	2010.01.01.07.31.42;	author brobecke;	state Exp;
branches;
next	1.261;

1.261
date	2009.12.14.12.50.39;	author gingold;	state Exp;
branches;
next	1.260;

1.260
date	2009.12.09.13.44.53;	author gingold;	state Exp;
branches;
next	1.259;

1.259
date	2009.12.07.09.47.40;	author gingold;	state Exp;
branches;
next	1.258;

1.258
date	2009.11.16.18.40.22;	author tromey;	state Exp;
branches;
next	1.257;

1.257
date	2009.11.11.05.04.34;	author jkratoch;	state Exp;
branches;
next	1.256;

1.256
date	2009.11.05.23.18.00;	author drow;	state Exp;
branches;
next	1.255;

1.255
date	2009.11.05.22.26.10;	author tromey;	state Exp;
branches;
next	1.254;

1.254
date	2009.11.05.22.19.09;	author tromey;	state Exp;
branches;
next	1.253;

1.253
date	2009.11.05.19.53.04;	author tromey;	state Exp;
branches;
next	1.252;

1.252
date	2009.11.04.23.06.50;	author tromey;	state Exp;
branches;
next	1.251;

1.251
date	2009.11.02.14.59.51;	author jkratoch;	state Exp;
branches;
next	1.250;

1.250
date	2009.11.02.14.57.02;	author jkratoch;	state Exp;
branches;
next	1.249;

1.249
date	2009.11.02.14.55.05;	author jkratoch;	state Exp;
branches;
next	1.248;

1.248
date	2009.10.19.09.51.42;	author palves;	state Exp;
branches;
next	1.247;

1.247
date	2009.10.13.07.56.29;	author gingold;	state Exp;
branches;
next	1.246;

1.246
date	2009.09.18.17.33.51;	author jkratoch;	state Exp;
branches;
next	1.245;

1.245
date	2009.08.27.21.56.38;	author devans;	state Exp;
branches
	1.245.2.1;
next	1.244;

1.244
date	2009.08.21.17.57.17;	author ppluzhnikov;	state Exp;
branches;
next	1.243;

1.243
date	2009.08.17.20.09.38;	author uweigand;	state Exp;
branches;
next	1.242;

1.242
date	2009.08.14.23.35.33;	author devans;	state Exp;
branches;
next	1.241;

1.241
date	2009.08.10.22.09.22;	author jkratoch;	state Exp;
branches;
next	1.240;

1.240
date	2009.08.03.17.00.34;	author jkratoch;	state Exp;
branches;
next	1.239;

1.239
date	2009.07.22.20.00.34;	author ppluzhnikov;	state Exp;
branches;
next	1.238;

1.238
date	2009.07.22.19.21.31;	author ppluzhnikov;	state Exp;
branches;
next	1.237;

1.237
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches;
next	1.236;

1.236
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.235;

1.235
date	2009.07.02.17.02.34;	author uweigand;	state Exp;
branches;
next	1.234;

1.234
date	2009.06.23.18.19.54;	author jkratoch;	state Exp;
branches;
next	1.233;

1.233
date	2009.06.23.16.28.45;	author ppluzhnikov;	state Exp;
branches;
next	1.232;

1.232
date	2009.06.17.18.34.34;	author uweigand;	state Exp;
branches;
next	1.231;

1.231
date	2009.06.16.18.49.25;	author ppluzhnikov;	state Exp;
branches;
next	1.230;

1.230
date	2009.06.04.00.50.16;	author devans;	state Exp;
branches;
next	1.229;

1.229
date	2009.05.24.12.27.35;	author muller;	state Exp;
branches;
next	1.228;

1.228
date	2009.05.22.23.49.13;	author palves;	state Exp;
branches;
next	1.227;

1.227
date	2009.05.19.13.51.37;	author jkratoch;	state Exp;
branches;
next	1.226;

1.226
date	2009.05.14.23.33.08;	author ppluzhnikov;	state Exp;
branches;
next	1.225;

1.225
date	2009.05.05.13.24.49;	author uweigand;	state Exp;
branches;
next	1.224;

1.224
date	2009.04.07.20.43.51;	author devans;	state Exp;
branches;
next	1.223;

1.223
date	2009.03.22.17.32.16;	author palves;	state Exp;
branches;
next	1.222;

1.222
date	2009.02.25.02.14.22;	author teawater;	state Exp;
branches;
next	1.221;

1.221
date	2009.02.21.16.14.49;	author palves;	state Exp;
branches;
next	1.220;

1.220
date	2009.01.08.16.32.30;	author tromey;	state Exp;
branches;
next	1.219;

1.219
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.218;

1.218
date	2008.10.03.16.36.10;	author ppluzhnikov;	state Exp;
branches
	1.218.2.1;
next	1.217;

1.217
date	2008.10.01.17.21.06;	author tromey;	state Exp;
branches;
next	1.216;

1.216
date	2008.09.22.18.18.07;	author tromey;	state Exp;
branches;
next	1.215;

1.215
date	2008.09.13.17.28.56;	author tromey;	state Exp;
branches;
next	1.214;

1.214
date	2008.09.11.14.20.50;	author uweigand;	state Exp;
branches;
next	1.213;

1.213
date	2008.09.05.11.37.17;	author uweigand;	state Exp;
branches;
next	1.212;

1.212
date	2008.08.26.17.30.35;	author uweigand;	state Exp;
branches;
next	1.211;

1.211
date	2008.08.20.11.21.44;	author palves;	state Exp;
branches;
next	1.210;

1.210
date	2008.08.18.19.44.49;	author tromey;	state Exp;
branches;
next	1.209;

1.209
date	2008.08.05.20.41.16;	author tromey;	state Exp;
branches;
next	1.208;

1.208
date	2008.07.21.16.47.10;	author tromey;	state Exp;
branches;
next	1.207;

1.207
date	2008.07.10.23.08.21;	author devans;	state Exp;
branches;
next	1.206;

1.206
date	2008.07.09.11.16.49;	author palves;	state Exp;
branches;
next	1.205;

1.205
date	2008.06.05.19.21.55;	author aristovski;	state Exp;
branches;
next	1.204;

1.204
date	2008.06.05.16.17.54;	author drow;	state Exp;
branches;
next	1.203;

1.203
date	2008.05.05.16.13.49;	author luisgpm;	state Exp;
branches;
next	1.202;

1.202
date	2008.05.04.14.34.06;	author jkratoch;	state Exp;
branches;
next	1.201;

1.201
date	2008.05.04.03.45.42;	author nemet;	state Exp;
branches;
next	1.200;

1.200
date	2008.05.03.18.04.02;	author drow;	state Exp;
branches;
next	1.199;

1.199
date	2008.04.21.14.25.16;	author palves;	state Exp;
branches;
next	1.198;

1.198
date	2008.01.29.22.47.20;	author drow;	state Exp;
branches;
next	1.197;

1.197
date	2008.01.11.13.34.15;	author deuling;	state Exp;
branches;
next	1.196;

1.196
date	2008.01.03.04.23.46;	author brobecke;	state Exp;
branches;
next	1.195;

1.195
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.194;

1.194
date	2007.12.17.17.20.15;	author macro;	state Exp;
branches;
next	1.193;

1.193
date	2007.12.04.23.33.00;	author uweigand;	state Exp;
branches;
next	1.192;

1.192
date	2007.09.24.21.48.29;	author jimb;	state Exp;
branches;
next	1.191;

1.191
date	2007.09.01.08.18.15;	author jkratoch;	state Exp;
branches
	1.191.2.1;
next	1.190;

1.190
date	2007.08.23.18.08.39;	author brobecke;	state Exp;
branches;
next	1.189;

1.189
date	2007.07.31.21.42.19;	author msnyder;	state Exp;
branches;
next	1.188;

1.188
date	2007.07.03.15.32.20;	author drow;	state Exp;
branches;
next	1.187;

1.187
date	2007.06.18.15.46.38;	author drow;	state Exp;
branches;
next	1.186;

1.186
date	2007.06.12.15.33.04;	author uweigand;	state Exp;
branches;
next	1.185;

1.185
date	2007.05.11.19.57.17;	author uweigand;	state Exp;
branches;
next	1.184;

1.184
date	2007.05.11.19.55.20;	author uweigand;	state Exp;
branches;
next	1.183;

1.183
date	2007.04.13.14.03.56;	author drow;	state Exp;
branches;
next	1.182;

1.182
date	2007.02.26.20.04.38;	author drow;	state Exp;
branches;
next	1.181;

1.181
date	2007.02.13.08.15.49;	author denis;	state Exp;
branches;
next	1.180;

1.180
date	2007.01.21.01.02.03;	author drow;	state Exp;
branches;
next	1.179;

1.179
date	2007.01.09.21.34.29;	author drow;	state Exp;
branches;
next	1.178;

1.178
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.177;

1.177
date	2006.09.21.14.00.53;	author drow;	state Exp;
branches;
next	1.176;

1.176
date	2006.08.24.12.43.10;	author schwab;	state Exp;
branches;
next	1.175;

1.175
date	2006.08.15.18.46.25;	author drow;	state Exp;
branches;
next	1.174;

1.174
date	2006.08.08.17.39.10;	author drow;	state Exp;
branches;
next	1.173;

1.173
date	2006.08.08.15.48.07;	author drow;	state Exp;
branches;
next	1.172;

1.172
date	2006.06.13.20.54.42;	author drow;	state Exp;
branches;
next	1.171;

1.171
date	2006.02.25.04.36.39;	author cwilson;	state Exp;
branches
	1.171.2.1
	1.171.4.1
	1.171.12.1;
next	1.170;

1.170
date	2006.02.21.19.13.20;	author ams;	state Exp;
branches;
next	1.169;

1.169
date	2006.02.21.18.22.26;	author ams;	state Exp;
branches;
next	1.168;

1.168
date	2006.02.20.15.02.10;	author drow;	state Exp;
branches;
next	1.167;

1.167
date	2006.02.07.19.40.30;	author brobecke;	state Exp;
branches;
next	1.166;

1.166
date	2006.02.01.23.14.10;	author drow;	state Exp;
branches;
next	1.165;

1.165
date	2006.01.15.19.50.03;	author drow;	state Exp;
branches;
next	1.164;

1.164
date	2005.12.17.22.34.03;	author eliz;	state Exp;
branches;
next	1.163;

1.163
date	2005.12.02.11.11.23;	author ams;	state Exp;
branches;
next	1.162;

1.162
date	2005.08.31.21.07.33;	author kettenis;	state Exp;
branches;
next	1.161;

1.161
date	2005.08.02.03.02.05;	author drow;	state Exp;
branches;
next	1.160;

1.160
date	2005.06.13.18.39.11;	author mmitchel;	state Exp;
branches;
next	1.159;

1.159
date	2005.06.13.16.15.35;	author drow;	state Exp;
branches;
next	1.158;

1.158
date	2005.05.08.14.46.52;	author kettenis;	state Exp;
branches;
next	1.157;

1.157
date	2005.03.08.21.40.46;	author drow;	state Exp;
branches
	1.157.2.1;
next	1.156;

1.156
date	2005.03.08.04.34.44;	author brobecke;	state Exp;
branches;
next	1.155;

1.155
date	2005.02.24.13.51.34;	author cagney;	state Exp;
branches;
next	1.154;

1.154
date	2005.02.21.07.08.40;	author cagney;	state Exp;
branches;
next	1.153;

1.153
date	2005.02.21.06.21.08;	author cagney;	state Exp;
branches;
next	1.152;

1.152
date	2005.02.18.15.25.28;	author cagney;	state Exp;
branches;
next	1.151;

1.151
date	2005.02.17.15.00.31;	author cagney;	state Exp;
branches;
next	1.150;

1.150
date	2005.02.15.15.49.20;	author cagney;	state Exp;
branches;
next	1.149;

1.149
date	2005.02.14.18.10.10;	author cagney;	state Exp;
branches;
next	1.148;

1.148
date	2005.02.14.14.37.38;	author cagney;	state Exp;
branches;
next	1.147;

1.147
date	2005.02.12.00.39.21;	author cagney;	state Exp;
branches;
next	1.146;

1.146
date	2005.02.11.18.13.53;	author cagney;	state Exp;
branches;
next	1.145;

1.145
date	2005.02.11.04.06.05;	author cagney;	state Exp;
branches;
next	1.144;

1.144
date	2004.10.23.16.18.09;	author cagney;	state Exp;
branches;
next	1.143;

1.143
date	2004.10.01.10.23.09;	author hilfingr;	state Exp;
branches;
next	1.142;

1.142
date	2004.09.11.10.24.51;	author hilfingr;	state Exp;
branches;
next	1.141;

1.141
date	2004.09.08.21.58.19;	author jimb;	state Exp;
branches;
next	1.140;

1.140
date	2004.08.10.21.52.05;	author cagney;	state Exp;
branches;
next	1.139;

1.139
date	2004.08.10.19.37.47;	author cagney;	state Exp;
branches;
next	1.138;

1.138
date	2004.08.10.16.09.54;	author guitton;	state Exp;
branches;
next	1.137;

1.137
date	2004.07.30.19.17.20;	author eliz;	state Exp;
branches;
next	1.136;

1.136
date	2004.07.30.12.05.44;	author guitton;	state Exp;
branches;
next	1.135;

1.135
date	2004.07.26.14.53.05;	author cagney;	state Exp;
branches;
next	1.134;

1.134
date	2004.07.10.01.17.52;	author msnyder;	state Exp;
branches;
next	1.133;

1.133
date	2004.06.24.22.09.34;	author cagney;	state Exp;
branches;
next	1.132;

1.132
date	2004.06.15.01.04.20;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2004.06.14.20.40.40;	author tausq;	state Exp;
branches;
next	1.130;

1.130
date	2004.05.20.09.51.33;	author hilfingr;	state Exp;
branches;
next	1.129;

1.129
date	2004.05.02.10.14.01;	author jimb;	state Exp;
branches;
next	1.128;

1.128
date	2004.04.21.23.52.21;	author cagney;	state Exp;
branches;
next	1.127;

1.127
date	2004.04.21.22.02.38;	author cagney;	state Exp;
branches;
next	1.126;

1.126
date	2004.04.15.21.39.27;	author roland;	state Exp;
branches;
next	1.125;

1.125
date	2004.04.08.21.18.13;	author cagney;	state Exp;
branches;
next	1.124;

1.124
date	2004.02.28.18.04.37;	author cagney;	state Exp;
branches
	1.124.6.1;
next	1.123;

1.123
date	2004.02.15.15.16.29;	author cagney;	state Exp;
branches
	1.123.2.1;
next	1.122;

1.122
date	2004.02.14.15.46.33;	author ezannoni;	state Exp;
branches;
next	1.121;

1.121
date	2004.02.09.23.50.55;	author ezannoni;	state Exp;
branches;
next	1.120;

1.120
date	2004.02.07.23.13.47;	author ezannoni;	state Exp;
branches;
next	1.119;

1.119
date	2004.02.07.18.29.54;	author ezannoni;	state Exp;
branches;
next	1.118;

1.118
date	2004.02.07.16.57.55;	author ezannoni;	state Exp;
branches;
next	1.117;

1.117
date	2004.01.23.17.56.46;	author carlton;	state Exp;
branches;
next	1.116;

1.116
date	2004.01.19.19.56.02;	author cagney;	state Exp;
branches;
next	1.115;

1.115
date	2004.01.17.01.05.06;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2003.11.23.19.24.05;	author cagney;	state Exp;
branches;
next	1.113;

1.113
date	2003.11.15.19.39.04;	author cagney;	state Exp;
branches;
next	1.112;

1.112
date	2003.11.08.00.13.03;	author cagney;	state Exp;
branches;
next	1.111;

1.111
date	2003.10.29.18.29.07;	author kettenis;	state Exp;
branches;
next	1.110;

1.110
date	2003.10.28.17.09.12;	author jjohnstn;	state Exp;
branches;
next	1.109;

1.109
date	2003.09.21.01.26.45;	author cagney;	state Exp;
branches;
next	1.108;

1.108
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.107;

1.107
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2003.09.12.18.40.18;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2003.09.11.19.49.18;	author carlton;	state Exp;
branches;
next	1.104;

1.104
date	2003.09.11.19.20.07;	author ezannoni;	state Exp;
branches;
next	1.103;

1.103
date	2003.09.03.21.01.44;	author cagney;	state Exp;
branches;
next	1.102;

1.102
date	2003.08.17.22.33.08;	author chastain;	state Exp;
branches;
next	1.101;

1.101
date	2003.06.27.13.11.17;	author ezannoni;	state Exp;
branches;
next	1.100;

1.100
date	2003.06.22.18.32.49;	author drow;	state Exp;
branches
	1.100.2.1;
next	1.99;

1.99
date	2003.06.17.19.15.24;	author drow;	state Exp;
branches;
next	1.98;

1.98
date	2003.06.11.22.27.13;	author carlton;	state Exp;
branches;
next	1.97;

1.97
date	2003.06.08.18.27.14;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2003.06.06.23.32.59;	author mmitchel;	state Exp;
branches;
next	1.95;

1.95
date	2003.06.02.23.20.46;	author ezannoni;	state Exp;
branches;
next	1.94;

1.94
date	2003.05.14.17.43.19;	author ezannoni;	state Exp;
branches;
next	1.93;

1.93
date	2003.04.01.14.17.20;	author drow;	state Exp;
branches
	1.93.6.1
	1.93.10.1;
next	1.92;

1.92
date	2003.02.27.20.48.03;	author carlton;	state Exp;
branches;
next	1.91;

1.91
date	2003.02.25.21.36.20;	author carlton;	state Exp;
branches;
next	1.90;

1.90
date	2003.02.24.23.37.01;	author carlton;	state Exp;
branches;
next	1.89;

1.89
date	2003.02.20.17.17.25;	author carlton;	state Exp;
branches;
next	1.88;

1.88
date	2003.02.20.00.01.06;	author carlton;	state Exp;
branches;
next	1.87;

1.87
date	2003.02.04.18.07.01;	author drow;	state Exp;
branches;
next	1.86;

1.86
date	2003.02.03.20.39.41;	author jimb;	state Exp;
branches;
next	1.85;

1.85
date	2003.02.01.20.51.05;	author cagney;	state Exp;
branches
	1.85.2.1;
next	1.84;

1.84
date	2003.01.31.19.22.18;	author drow;	state Exp;
branches;
next	1.83;

1.83
date	2003.01.30.21.45.07;	author jimb;	state Exp;
branches;
next	1.82;

1.82
date	2003.01.23.23.17.28;	author jimb;	state Exp;
branches;
next	1.81;

1.81
date	2003.01.23.23.03.32;	author jimb;	state Exp;
branches;
next	1.80;

1.80
date	2003.01.23.08.06.36;	author jimb;	state Exp;
branches;
next	1.79;

1.79
date	2003.01.23.07.30.18;	author jimb;	state Exp;
branches;
next	1.78;

1.78
date	2003.01.18.15.55.52;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2003.01.14.00.49.04;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2003.01.02.14.27.26;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2002.12.09.00.59.26;	author ezannoni;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2002.11.25.21.00.51;	author jimb;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2002.11.25.20.11.35;	author jimb;	state Exp;
branches;
next	1.72;

1.72
date	2002.11.25.20.01.06;	author jimb;	state Exp;
branches;
next	1.71;

1.71
date	2002.10.17.21.16.12;	author carlton;	state Exp;
branches;
next	1.70;

1.70
date	2002.10.15.02.42.32;	author fedor;	state Exp;
branches;
next	1.69;

1.69
date	2002.09.20.14.58.58;	author fnasser;	state Exp;
branches
	1.69.2.1
	1.69.4.1;
next	1.68;

1.68
date	2002.09.19.03.58.41;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2002.09.19.01.34.51;	author msnyder;	state Exp;
branches;
next	1.66;

1.66
date	2002.09.19.00.42.41;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2002.08.01.17.18.32;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2002.07.29.22.55.26;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2002.07.12.15.23.10;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2002.05.15.21.19.20;	author jimb;	state Exp;
branches
	1.62.4.1;
next	1.61;

1.61
date	2002.05.12.18.13.33;	author fnf;	state Exp;
branches;
next	1.60;

1.60
date	2002.04.25.16.29.27;	author muller;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2002.04.22.10.19.35;	author brobecke;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.29.01.09.27;	author msnyder;	state Exp;
branches;
next	1.57;

1.57
date	2002.03.28.01.35.55;	author msnyder;	state Exp;
branches;
next	1.56;

1.56
date	2002.03.19.03.51.06;	author msnyder;	state Exp;
branches;
next	1.55;

1.55
date	2002.03.06.06.28.34;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2002.02.27.01.40.36;	author cagney;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2002.02.06.18.31.07;	author msnyder;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.05.04.37.22;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.01.01.14.20;	author msnyder;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.17.22.15.17;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2002.01.15.20.00.56;	author msnyder;	state Exp;
branches;
next	1.48;

1.48
date	2002.01.13.05.59.30;	author msnyder;	state Exp;
branches;
next	1.47;

1.47
date	2002.01.12.23.44.26;	author msnyder;	state Exp;
branches;
next	1.46;

1.46
date	2002.01.08.02.09.31;	author msnyder;	state Exp;
branches;
next	1.45;

1.45
date	2001.12.10.22.04.10;	author fnf;	state Exp;
branches;
next	1.44;

1.44
date	2001.12.02.22.38.23;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.14.21.55.21;	author jimb;	state Exp;
branches;
next	1.42;

1.42
date	2001.11.06.23.38.14;	author fnf;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.30.04.05.34;	author fnf;	state Exp;
branches;
next	1.40;

1.40
date	2001.10.24.17.13.12;	author jimb;	state Exp;
branches;
next	1.39;

1.39
date	2001.10.24.17.10.18;	author jimb;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.31.00.40.45;	author jimb;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.31.00.36.23;	author jimb;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.15.18.57.06;	author ezannoni;	state Exp;
branches;
next	1.35;

1.35
date	2001.07.14.18.59.07;	author ciceron;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.06.17.12.30;	author cagney;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2001.05.29.10.20.27;	author aoliva;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.10.15.33.21;	author fnasser;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.05.02.02.13;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.27.20.36.24;	author jtc;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.20.00.54.42;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.07.02.57.08;	author jtc;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.19.18.56.11;	author ezannoni;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.31.01.24.02;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.27.00.43.25;	author fnasser;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.19.08.01.46;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2000.12.15.01.01.50;	author kevinb;	state Exp;
branches;
next	1.21;

1.21
date	2000.12.01.00.41.27;	author fnasser;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.27.15.02.42;	author davea;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.12.16.53.06;	author ezannoni;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.02.00.09.06;	author davea;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.07.15.02.48;	author ezannoni;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.21.09.59.51;	author muller;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.16.21.02.21;	author nsd;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.12.14.05.44;	author ezannoni;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.22.09.02.23;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.16.02.43.39;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.04.16.52.34;	author ezannoni;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.17.16.09.04;	author ezannoni;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.17.15.59.56;	author ezannoni;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.17.15.47.17;	author ezannoni;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.03.15.16.13;	author eliz;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.21.22.37.42;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.15.19.43.57;	author msnyder;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.335.2.1
date	2012.08.21.16.05.46;	author muller;	state Exp;
branches;
next	;

1.320.2.1
date	2011.12.15.15.33.14;	author tromey;	state Exp;
branches;
next	1.320.2.2;

1.320.2.2
date	2011.12.19.22.28.21;	author jkratoch;	state Exp;
branches;
next	1.320.2.3;

1.320.2.3
date	2012.01.06.04.43.31;	author brobecke;	state Exp;
branches;
next	;

1.288.2.1
date	2010.07.20.22.22.57;	author jkratoch;	state Exp;
branches;
next	1.288.2.2;

1.288.2.2
date	2010.10.05.20.53.39;	author jkratoch;	state Exp;
branches;
next	;

1.272.2.1
date	2010.02.19.14.05.39;	author jkratoch;	state Exp;
branches;
next	1.272.2.2;

1.272.2.2
date	2010.03.05.19.33.10;	author uweigand;	state Exp;
branches;
next	1.272.2.3;

1.272.2.3
date	2010.03.17.00.05.23;	author drow;	state Exp;
branches;
next	1.272.2.4;

1.272.2.4
date	2010.04.22.23.20.14;	author jkratoch;	state Exp;
branches;
next	;

1.245.2.1
date	2009.09.18.17.39.37;	author jkratoch;	state Exp;
branches;
next	;

1.218.2.1
date	2008.11.21.02.31.57;	author shebs;	state Exp;
branches;
next	;

1.191.2.1
date	2007.09.24.21.48.05;	author jimb;	state Exp;
branches;
next	;

1.171.2.1
date	2006.04.03.00.47.40;	author drow;	state Exp;
branches
	1.171.2.1.2.1;
next	;

1.171.2.1.2.1
date	2006.04.12.14.48.21;	author drow;	state Exp;
branches;
next	1.171.2.1.2.2;

1.171.2.1.2.2
date	2006.04.12.14.52.04;	author drow;	state Exp;
branches;
next	1.171.2.1.2.3;

1.171.2.1.2.3
date	2006.04.12.18.11.40;	author drow;	state Exp;
branches;
next	1.171.2.1.2.4;

1.171.2.1.2.4
date	2006.07.11.19.35.43;	author drow;	state Exp;
branches;
next	1.171.2.1.2.5;

1.171.2.1.2.5
date	2006.07.11.20.37.02;	author drow;	state Exp;
branches;
next	;

1.171.4.1
date	2006.03.31.18.17.29;	author drow;	state Exp;
branches;
next	;

1.171.12.1
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;

1.157.2.1
date	2005.03.29.02.52.06;	author pbrook;	state Exp;
branches;
next	1.157.2.2;

1.157.2.2
date	2005.06.13.18.43.57;	author mmitchel;	state Exp;
branches;
next	;

1.124.6.1
date	2004.03.24.04.10.01;	author ezannoni;	state Exp;
branches;
next	;

1.123.2.1
date	2004.03.27.17.37.54;	author drow;	state Exp;
branches;
next	1.123.2.2;

1.123.2.2
date	2004.09.16.17.01.23;	author drow;	state Exp;
branches;
next	;

1.100.2.1
date	2003.06.27.13.34.40;	author ezannoni;	state Exp;
branches;
next	1.100.2.2;

1.100.2.2
date	2003.08.14.20.12.31;	author ezannoni;	state Exp;
branches;
next	1.100.2.3;

1.100.2.3
date	2003.10.29.18.40.39;	author kettenis;	state Exp;
branches;
next	;

1.93.6.1
date	2003.05.18.09.44.22;	author kettenis;	state Exp;
branches;
next	;

1.93.10.1
date	2003.06.03.20.54.39;	author cagney;	state Exp;
branches;
next	;

1.85.2.1
date	2003.02.03.22.00.56;	author cagney;	state Exp;
branches;
next	;

1.75.2.1
date	2002.12.23.08.48.07;	author jimb;	state Exp;
branches;
next	1.75.2.2;

1.75.2.2
date	2002.12.23.08.50.07;	author jimb;	state Exp;
branches;
next	1.75.2.3;

1.75.2.3
date	2002.12.23.09.22.59;	author jimb;	state Exp;
branches;
next	;

1.74.2.1
date	2002.11.26.02.32.13;	author jimb;	state Exp;
branches;
next	1.74.2.2;

1.74.2.2
date	2002.11.26.03.14.15;	author jimb;	state Exp;
branches;
next	1.74.2.3;

1.74.2.3
date	2002.11.26.04.52.01;	author jimb;	state Exp;
branches;
next	1.74.2.4;

1.74.2.4
date	2002.12.17.04.18.13;	author jimb;	state Exp;
branches;
next	;

1.69.2.1
date	2002.09.20.18.52.16;	author carlton;	state Exp;
branches;
next	1.69.2.2;

1.69.2.2
date	2002.09.20.23.55.03;	author carlton;	state Exp;
branches;
next	1.69.2.3;

1.69.2.3
date	2002.09.24.00.04.51;	author carlton;	state Exp;
branches;
next	1.69.2.4;

1.69.2.4
date	2002.09.25.00.19.27;	author carlton;	state Exp;
branches;
next	1.69.2.5;

1.69.2.5
date	2002.10.09.23.08.10;	author carlton;	state Exp;
branches;
next	1.69.2.6;

1.69.2.6
date	2002.10.18.23.42.58;	author carlton;	state Exp;
branches;
next	1.69.2.7;

1.69.2.7
date	2002.10.25.23.49.55;	author carlton;	state Exp;
branches;
next	1.69.2.8;

1.69.2.8
date	2002.11.28.00.53.24;	author carlton;	state Exp;
branches;
next	1.69.2.9;

1.69.2.9
date	2002.12.19.01.03.06;	author carlton;	state Exp;
branches;
next	1.69.2.10;

1.69.2.10
date	2002.12.21.00.17.44;	author carlton;	state Exp;
branches;
next	1.69.2.11;

1.69.2.11
date	2002.12.23.19.38.45;	author carlton;	state Exp;
branches;
next	1.69.2.12;

1.69.2.12
date	2002.12.24.01.23.49;	author carlton;	state Exp;
branches;
next	1.69.2.13;

1.69.2.13
date	2003.02.01.01.17.22;	author carlton;	state Exp;
branches;
next	1.69.2.14;

1.69.2.14
date	2003.02.07.19.17.53;	author carlton;	state Exp;
branches;
next	1.69.2.15;

1.69.2.15
date	2003.02.12.00.38.06;	author carlton;	state Exp;
branches;
next	1.69.2.16;

1.69.2.16
date	2003.03.06.00.56.32;	author carlton;	state Exp;
branches;
next	1.69.2.17;

1.69.2.17
date	2003.04.16.19.56.54;	author carlton;	state Exp;
branches;
next	1.69.2.18;

1.69.2.18
date	2003.05.23.18.40.45;	author carlton;	state Exp;
branches;
next	1.69.2.19;

1.69.2.19
date	2003.06.27.21.50.11;	author carlton;	state Exp;
branches;
next	1.69.2.20;

1.69.2.20
date	2003.09.17.21.28.32;	author carlton;	state Exp;
branches;
next	1.69.2.21;

1.69.2.21
date	2003.11.11.23.50.57;	author carlton;	state Exp;
branches;
next	1.69.2.22;

1.69.2.22
date	2003.12.16.00.00.50;	author carlton;	state Exp;
branches;
next	1.69.2.23;

1.69.2.23
date	2004.01.26.19.11.32;	author carlton;	state Exp;
branches;
next	;

1.69.4.1
date	2002.10.22.19.59.36;	author carlton;	state Exp;
branches;
next	1.69.4.2;

1.69.4.2
date	2002.10.26.17.12.09;	author drow;	state Exp;
branches;
next	1.69.4.3;

1.69.4.3
date	2003.12.14.20.27.31;	author drow;	state Exp;
branches;
next	1.69.4.4;

1.69.4.4
date	2004.02.09.19.43.48;	author drow;	state Exp;
branches;
next	;

1.62.4.1
date	2002.07.22.21.47.03;	author kseitz;	state Exp;
branches;
next	1.62.4.2;

1.62.4.2
date	2002.08.09.18.34.27;	author kseitz;	state Exp;
branches;
next	1.62.4.3;

1.62.4.3
date	2002.10.01.00.46.14;	author kseitz;	state Exp;
branches;
next	1.62.4.4;

1.62.4.4
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.60.2.1
date	2002.05.09.18.35.54;	author jimb;	state Exp;
branches;
next	;

1.54.2.1
date	2002.05.01.01.25.27;	author chastain;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2002.06.16.14.13.59;	author cagney;	state Exp;
branches;
next	1.54.2.3;

1.54.2.3
date	2002.06.22.16.49.33;	author cagney;	state Exp;
branches;
next	;

1.34.2.1
date	2001.07.06.19.17.03;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.28;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.25.18.03.28;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.10.26;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.27.00.51.04;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.02.23.46.09;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.08.09.21.33.56;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.08.23.22.36.15;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.08.31.01.06.08;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.09.08.23.59.34;	author shebs;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.10.05.23.08.54;	author jsm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.10.12.04.37.25;	author jsm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.10.19.02.46.39;	author jsm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.11.09.01.23.07;	author jsm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.12.07.03.56.06;	author jsm;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2000.02.02.00.21.07;	author jsm;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2000.02.03.04.14.35;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.396
log
@move the demangled_names_hash into the per-BFD

This moves the demangled_names_hash from the objfile into the per-BFD
object.  This is part of the objfile splitting project.

The demangled names hash is independent of the program space.  And, it
is needed by the symbol tables.  Both of these things indicate that it
must be pushed into the per-BFD object, which this patch does.

Built and regtested on x86-64 Fedora 18.

	* objfiles.c (free_objfile_per_bfd_storage): Delete the
	demangled_names_hash.
	(free_objfile): Don't delete the demangled_names_hash.
	* objfiles.h (struct objfile_per_bfd_storage)
	<demangled_names_hash>: New field.
	(struct objfile) <demangled_names_hash>: Move to
	objfile_per_bfd_storage.
	* symfile.c (reread_symbols): Don't delete the
	demangled_names_hash.
	* symtab.c (create_demangled_names_hash): Update.
	(symbol_set_names): Update.
@
text
@/* Generic symbol file reading for the GNU debugger, GDB.

   Copyright (C) 1990-2013 Free Software Foundation, Inc.

   Contributed by Cygnus Support, using pieces from other GDB modules.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "bfdlink.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcore.h"
#include "frame.h"
#include "target.h"
#include "value.h"
#include "symfile.h"
#include "objfiles.h"
#include "source.h"
#include "gdbcmd.h"
#include "breakpoint.h"
#include "language.h"
#include "complaints.h"
#include "demangle.h"
#include "inferior.h"
#include "regcache.h"
#include "filenames.h"		/* for DOSish file names */
#include "gdb-stabs.h"
#include "gdb_obstack.h"
#include "completer.h"
#include "bcache.h"
#include "hashtab.h"
#include "readline/readline.h"
#include "gdb_assert.h"
#include "block.h"
#include "observer.h"
#include "exec.h"
#include "parser-defs.h"
#include "varobj.h"
#include "elf-bfd.h"
#include "solib.h"
#include "remote.h"
#include "stack.h"
#include "gdb_bfd.h"
#include "cli/cli-utils.h"

#include <sys/types.h>
#include <fcntl.h>
#include "gdb_string.h"
#include "gdb_stat.h"
#include <ctype.h>
#include <time.h>
#include <sys/time.h>

#include "psymtab.h"

int (*deprecated_ui_load_progress_hook) (const char *section,
					 unsigned long num);
void (*deprecated_show_load_progress) (const char *section,
			    unsigned long section_sent,
			    unsigned long section_size,
			    unsigned long total_sent,
			    unsigned long total_size);
void (*deprecated_pre_add_symbol_hook) (const char *);
void (*deprecated_post_add_symbol_hook) (void);

static void clear_symtab_users_cleanup (void *ignore);

/* Global variables owned by this file.  */
int readnow_symbol_files;	/* Read full symbols immediately.  */

/* Functions this file defines.  */

static void load_command (char *, int);

static void symbol_file_add_main_1 (const char *args, int from_tty, int flags);

static void add_symbol_file_command (char *, int);

static const struct sym_fns *find_sym_fns (bfd *);

static void decrement_reading_symtab (void *);

static void overlay_invalidate_all (void);

static void overlay_auto_command (char *, int);

static void overlay_manual_command (char *, int);

static void overlay_off_command (char *, int);

static void overlay_load_command (char *, int);

static void overlay_command (char *, int);

static void simple_free_overlay_table (void);

static void read_target_long_array (CORE_ADDR, unsigned int *, int, int,
				    enum bfd_endian);

static int simple_read_overlay_table (void);

static int simple_overlay_update_1 (struct obj_section *);

static void add_filename_language (char *ext, enum language lang);

static void info_ext_lang_command (char *args, int from_tty);

static void init_filename_language_table (void);

static void symfile_find_segment_sections (struct objfile *objfile);

void _initialize_symfile (void);

/* List of all available sym_fns.  On gdb startup, each object file reader
   calls add_symtab_fns() to register information on each format it is
   prepared to read.  */

typedef struct
{
  /* BFD flavour that we handle.  */
  enum bfd_flavour sym_flavour;

  /* The "vtable" of symbol functions.  */
  const struct sym_fns *sym_fns;
} registered_sym_fns;

DEF_VEC_O (registered_sym_fns);

static VEC (registered_sym_fns) *symtab_fns = NULL;

/* If non-zero, shared library symbols will be added automatically
   when the inferior is created, new libraries are loaded, or when
   attaching to the inferior.  This is almost always what users will
   want to have happen; but for very large programs, the startup time
   will be excessive, and so if this is a problem, the user can clear
   this flag and then add the shared library symbols as needed.  Note
   that there is a potential for confusion, since if the shared
   library symbols are not loaded, commands like "info fun" will *not*
   report all the functions that are actually present.  */

int auto_solib_add = 1;


/* True if we are reading a symbol table.  */

int currently_reading_symtab = 0;

static void
decrement_reading_symtab (void *dummy)
{
  currently_reading_symtab--;
  gdb_assert (currently_reading_symtab >= 0);
}

/* Increment currently_reading_symtab and return a cleanup that can be
   used to decrement it.  */

struct cleanup *
increment_reading_symtab (void)
{
  ++currently_reading_symtab;
  gdb_assert (currently_reading_symtab > 0);
  return make_cleanup (decrement_reading_symtab, NULL);
}

/* Remember the lowest-addressed loadable section we've seen.
   This function is called via bfd_map_over_sections.

   In case of equal vmas, the section with the largest size becomes the
   lowest-addressed loadable section.

   If the vmas and sizes are equal, the last section is considered the
   lowest-addressed loadable section.  */

void
find_lowest_section (bfd *abfd, asection *sect, void *obj)
{
  asection **lowest = (asection **) obj;

  if (0 == (bfd_get_section_flags (abfd, sect) & (SEC_ALLOC | SEC_LOAD)))
    return;
  if (!*lowest)
    *lowest = sect;		/* First loadable section */
  else if (bfd_section_vma (abfd, *lowest) > bfd_section_vma (abfd, sect))
    *lowest = sect;		/* A lower loadable section */
  else if (bfd_section_vma (abfd, *lowest) == bfd_section_vma (abfd, sect)
	   && (bfd_section_size (abfd, (*lowest))
	       <= bfd_section_size (abfd, sect)))
    *lowest = sect;
}

/* Create a new section_addr_info, with room for NUM_SECTIONS.  The
   new object's 'num_sections' field is set to 0; it must be updated
   by the caller.  */

struct section_addr_info *
alloc_section_addr_info (size_t num_sections)
{
  struct section_addr_info *sap;
  size_t size;

  size = (sizeof (struct section_addr_info)
	  +  sizeof (struct other_sections) * (num_sections - 1));
  sap = (struct section_addr_info *) xmalloc (size);
  memset (sap, 0, size);

  return sap;
}

/* Build (allocate and populate) a section_addr_info struct from
   an existing section table.  */

extern struct section_addr_info *
build_section_addr_info_from_section_table (const struct target_section *start,
                                            const struct target_section *end)
{
  struct section_addr_info *sap;
  const struct target_section *stp;
  int oidx;

  sap = alloc_section_addr_info (end - start);

  for (stp = start, oidx = 0; stp != end; stp++)
    {
      struct bfd_section *asect = stp->the_bfd_section;
      bfd *abfd = asect->owner;

      if (bfd_get_section_flags (abfd, asect) & (SEC_ALLOC | SEC_LOAD)
	  && oidx < end - start)
	{
	  sap->other[oidx].addr = stp->addr;
	  sap->other[oidx].name = xstrdup (bfd_section_name (abfd, asect));
	  sap->other[oidx].sectindex = gdb_bfd_section_index (abfd, asect);
	  oidx++;
	}
    }

  sap->num_sections = oidx;

  return sap;
}

/* Create a section_addr_info from section offsets in ABFD.  */

static struct section_addr_info *
build_section_addr_info_from_bfd (bfd *abfd)
{
  struct section_addr_info *sap;
  int i;
  struct bfd_section *sec;

  sap = alloc_section_addr_info (bfd_count_sections (abfd));
  for (i = 0, sec = abfd->sections; sec != NULL; sec = sec->next)
    if (bfd_get_section_flags (abfd, sec) & (SEC_ALLOC | SEC_LOAD))
      {
	sap->other[i].addr = bfd_get_section_vma (abfd, sec);
	sap->other[i].name = xstrdup (bfd_get_section_name (abfd, sec));
	sap->other[i].sectindex = gdb_bfd_section_index (abfd, sec);
	i++;
      }

  sap->num_sections = i;

  return sap;
}

/* Create a section_addr_info from section offsets in OBJFILE.  */

struct section_addr_info *
build_section_addr_info_from_objfile (const struct objfile *objfile)
{
  struct section_addr_info *sap;
  int i;

  /* Before reread_symbols gets rewritten it is not safe to call:
     gdb_assert (objfile->num_sections == bfd_count_sections (objfile->obfd));
     */
  sap = build_section_addr_info_from_bfd (objfile->obfd);
  for (i = 0; i < sap->num_sections; i++)
    {
      int sectindex = sap->other[i].sectindex;

      sap->other[i].addr += objfile->section_offsets->offsets[sectindex];
    }
  return sap;
}

/* Free all memory allocated by build_section_addr_info_from_section_table.  */

extern void
free_section_addr_info (struct section_addr_info *sap)
{
  int idx;

  for (idx = 0; idx < sap->num_sections; idx++)
    xfree (sap->other[idx].name);
  xfree (sap);
}

/* Initialize OBJFILE's sect_index_* members.  */

static void
init_objfile_sect_indices (struct objfile *objfile)
{
  asection *sect;
  int i;

  sect = bfd_get_section_by_name (objfile->obfd, ".text");
  if (sect)
    objfile->sect_index_text = sect->index;

  sect = bfd_get_section_by_name (objfile->obfd, ".data");
  if (sect)
    objfile->sect_index_data = sect->index;

  sect = bfd_get_section_by_name (objfile->obfd, ".bss");
  if (sect)
    objfile->sect_index_bss = sect->index;

  sect = bfd_get_section_by_name (objfile->obfd, ".rodata");
  if (sect)
    objfile->sect_index_rodata = sect->index;

  /* This is where things get really weird...  We MUST have valid
     indices for the various sect_index_* members or gdb will abort.
     So if for example, there is no ".text" section, we have to
     accomodate that.  First, check for a file with the standard
     one or two segments.  */

  symfile_find_segment_sections (objfile);

  /* Except when explicitly adding symbol files at some address,
     section_offsets contains nothing but zeros, so it doesn't matter
     which slot in section_offsets the individual sect_index_* members
     index into.  So if they are all zero, it is safe to just point
     all the currently uninitialized indices to the first slot.  But
     beware: if this is the main executable, it may be relocated
     later, e.g. by the remote qOffsets packet, and then this will
     be wrong!  That's why we try segments first.  */

  for (i = 0; i < objfile->num_sections; i++)
    {
      if (ANOFFSET (objfile->section_offsets, i) != 0)
	{
	  break;
	}
    }
  if (i == objfile->num_sections)
    {
      if (objfile->sect_index_text == -1)
	objfile->sect_index_text = 0;
      if (objfile->sect_index_data == -1)
	objfile->sect_index_data = 0;
      if (objfile->sect_index_bss == -1)
	objfile->sect_index_bss = 0;
      if (objfile->sect_index_rodata == -1)
	objfile->sect_index_rodata = 0;
    }
}

/* The arguments to place_section.  */

struct place_section_arg
{
  struct section_offsets *offsets;
  CORE_ADDR lowest;
};

/* Find a unique offset to use for loadable section SECT if
   the user did not provide an offset.  */

static void
place_section (bfd *abfd, asection *sect, void *obj)
{
  struct place_section_arg *arg = obj;
  CORE_ADDR *offsets = arg->offsets->offsets, start_addr;
  int done;
  ULONGEST align = ((ULONGEST) 1) << bfd_get_section_alignment (abfd, sect);

  /* We are only interested in allocated sections.  */
  if ((bfd_get_section_flags (abfd, sect) & SEC_ALLOC) == 0)
    return;

  /* If the user specified an offset, honor it.  */
  if (offsets[gdb_bfd_section_index (abfd, sect)] != 0)
    return;

  /* Otherwise, let's try to find a place for the section.  */
  start_addr = (arg->lowest + align - 1) & -align;

  do {
    asection *cur_sec;

    done = 1;

    for (cur_sec = abfd->sections; cur_sec != NULL; cur_sec = cur_sec->next)
      {
	int indx = cur_sec->index;

	/* We don't need to compare against ourself.  */
	if (cur_sec == sect)
	  continue;

	/* We can only conflict with allocated sections.  */
	if ((bfd_get_section_flags (abfd, cur_sec) & SEC_ALLOC) == 0)
	  continue;

	/* If the section offset is 0, either the section has not been placed
	   yet, or it was the lowest section placed (in which case LOWEST
	   will be past its end).  */
	if (offsets[indx] == 0)
	  continue;

	/* If this section would overlap us, then we must move up.  */
	if (start_addr + bfd_get_section_size (sect) > offsets[indx]
	    && start_addr < offsets[indx] + bfd_get_section_size (cur_sec))
	  {
	    start_addr = offsets[indx] + bfd_get_section_size (cur_sec);
	    start_addr = (start_addr + align - 1) & -align;
	    done = 0;
	    break;
	  }

	/* Otherwise, we appear to be OK.  So far.  */
      }
    }
  while (!done);

  offsets[gdb_bfd_section_index (abfd, sect)] = start_addr;
  arg->lowest = start_addr + bfd_get_section_size (sect);
}

/* Store struct section_addr_info as prepared (made relative and with SECTINDEX
   filled-in) by addr_info_make_relative into SECTION_OFFSETS of NUM_SECTIONS
   entries.  */

void
relative_addr_info_to_section_offsets (struct section_offsets *section_offsets,
				       int num_sections,
				       const struct section_addr_info *addrs)
{
  int i;

  memset (section_offsets, 0, SIZEOF_N_SECTION_OFFSETS (num_sections));

  /* Now calculate offsets for section that were specified by the caller.  */
  for (i = 0; i < addrs->num_sections; i++)
    {
      const struct other_sections *osp;

      osp = &addrs->other[i];
      if (osp->sectindex == -1)
  	continue;

      /* Record all sections in offsets.  */
      /* The section_offsets in the objfile are here filled in using
         the BFD index.  */
      section_offsets->offsets[osp->sectindex] = osp->addr;
    }
}

/* Transform section name S for a name comparison.  prelink can split section
   `.bss' into two sections `.dynbss' and `.bss' (in this order).  Similarly
   prelink can split `.sbss' into `.sdynbss' and `.sbss'.  Use virtual address
   of the new `.dynbss' (`.sdynbss') section as the adjacent new `.bss'
   (`.sbss') section has invalid (increased) virtual address.  */

static const char *
addr_section_name (const char *s)
{
  if (strcmp (s, ".dynbss") == 0)
    return ".bss";
  if (strcmp (s, ".sdynbss") == 0)
    return ".sbss";

  return s;
}

/* qsort comparator for addrs_section_sort.  Sort entries in ascending order by
   their (name, sectindex) pair.  sectindex makes the sort by name stable.  */

static int
addrs_section_compar (const void *ap, const void *bp)
{
  const struct other_sections *a = *((struct other_sections **) ap);
  const struct other_sections *b = *((struct other_sections **) bp);
  int retval;

  retval = strcmp (addr_section_name (a->name), addr_section_name (b->name));
  if (retval)
    return retval;

  return a->sectindex - b->sectindex;
}

/* Provide sorted array of pointers to sections of ADDRS.  The array is
   terminated by NULL.  Caller is responsible to call xfree for it.  */

static struct other_sections **
addrs_section_sort (struct section_addr_info *addrs)
{
  struct other_sections **array;
  int i;

  /* `+ 1' for the NULL terminator.  */
  array = xmalloc (sizeof (*array) * (addrs->num_sections + 1));
  for (i = 0; i < addrs->num_sections; i++)
    array[i] = &addrs->other[i];
  array[i] = NULL;

  qsort (array, i, sizeof (*array), addrs_section_compar);

  return array;
}

/* Relativize absolute addresses in ADDRS into offsets based on ABFD.  Fill-in
   also SECTINDEXes specific to ABFD there.  This function can be used to
   rebase ADDRS to start referencing different BFD than before.  */

void
addr_info_make_relative (struct section_addr_info *addrs, bfd *abfd)
{
  asection *lower_sect;
  CORE_ADDR lower_offset;
  int i;
  struct cleanup *my_cleanup;
  struct section_addr_info *abfd_addrs;
  struct other_sections **addrs_sorted, **abfd_addrs_sorted;
  struct other_sections **addrs_to_abfd_addrs;

  /* Find lowest loadable section to be used as starting point for
     continguous sections.  */
  lower_sect = NULL;
  bfd_map_over_sections (abfd, find_lowest_section, &lower_sect);
  if (lower_sect == NULL)
    {
      warning (_("no loadable sections found in added symbol-file %s"),
	       bfd_get_filename (abfd));
      lower_offset = 0;
    }
  else
    lower_offset = bfd_section_vma (bfd_get_filename (abfd), lower_sect);

  /* Create ADDRS_TO_ABFD_ADDRS array to map the sections in ADDRS to sections
     in ABFD.  Section names are not unique - there can be multiple sections of
     the same name.  Also the sections of the same name do not have to be
     adjacent to each other.  Some sections may be present only in one of the
     files.  Even sections present in both files do not have to be in the same
     order.

     Use stable sort by name for the sections in both files.  Then linearly
     scan both lists matching as most of the entries as possible.  */

  addrs_sorted = addrs_section_sort (addrs);
  my_cleanup = make_cleanup (xfree, addrs_sorted);

  abfd_addrs = build_section_addr_info_from_bfd (abfd);
  make_cleanup_free_section_addr_info (abfd_addrs);
  abfd_addrs_sorted = addrs_section_sort (abfd_addrs);
  make_cleanup (xfree, abfd_addrs_sorted);

  /* Now create ADDRS_TO_ABFD_ADDRS from ADDRS_SORTED and
     ABFD_ADDRS_SORTED.  */

  addrs_to_abfd_addrs = xzalloc (sizeof (*addrs_to_abfd_addrs)
				 * addrs->num_sections);
  make_cleanup (xfree, addrs_to_abfd_addrs);

  while (*addrs_sorted)
    {
      const char *sect_name = addr_section_name ((*addrs_sorted)->name);

      while (*abfd_addrs_sorted
	     && strcmp (addr_section_name ((*abfd_addrs_sorted)->name),
			sect_name) < 0)
	abfd_addrs_sorted++;

      if (*abfd_addrs_sorted
	  && strcmp (addr_section_name ((*abfd_addrs_sorted)->name),
		     sect_name) == 0)
	{
	  int index_in_addrs;

	  /* Make the found item directly addressable from ADDRS.  */
	  index_in_addrs = *addrs_sorted - addrs->other;
	  gdb_assert (addrs_to_abfd_addrs[index_in_addrs] == NULL);
	  addrs_to_abfd_addrs[index_in_addrs] = *abfd_addrs_sorted;

	  /* Never use the same ABFD entry twice.  */
	  abfd_addrs_sorted++;
	}

      addrs_sorted++;
    }

  /* Calculate offsets for the loadable sections.
     FIXME! Sections must be in order of increasing loadable section
     so that contiguous sections can use the lower-offset!!!

     Adjust offsets if the segments are not contiguous.
     If the section is contiguous, its offset should be set to
     the offset of the highest loadable section lower than it
     (the loadable section directly below it in memory).
     this_offset = lower_offset = lower_addr - lower_orig_addr */

  for (i = 0; i < addrs->num_sections; i++)
    {
      struct other_sections *sect = addrs_to_abfd_addrs[i];

      if (sect)
	{
	  /* This is the index used by BFD.  */
	  addrs->other[i].sectindex = sect->sectindex;

	  if (addrs->other[i].addr != 0)
	    {
	      addrs->other[i].addr -= sect->addr;
	      lower_offset = addrs->other[i].addr;
	    }
	  else
	    addrs->other[i].addr = lower_offset;
	}
      else
	{
	  /* addr_section_name transformation is not used for SECT_NAME.  */
	  const char *sect_name = addrs->other[i].name;

	  /* This section does not exist in ABFD, which is normally
	     unexpected and we want to issue a warning.

	     However, the ELF prelinker does create a few sections which are
	     marked in the main executable as loadable (they are loaded in
	     memory from the DYNAMIC segment) and yet are not present in
	     separate debug info files.  This is fine, and should not cause
	     a warning.  Shared libraries contain just the section
	     ".gnu.liblist" but it is not marked as loadable there.  There is
	     no other way to identify them than by their name as the sections
	     created by prelink have no special flags.

	     For the sections `.bss' and `.sbss' see addr_section_name.  */

	  if (!(strcmp (sect_name, ".gnu.liblist") == 0
		|| strcmp (sect_name, ".gnu.conflict") == 0
		|| (strcmp (sect_name, ".bss") == 0
		    && i > 0
		    && strcmp (addrs->other[i - 1].name, ".dynbss") == 0
		    && addrs_to_abfd_addrs[i - 1] != NULL)
		|| (strcmp (sect_name, ".sbss") == 0
		    && i > 0
		    && strcmp (addrs->other[i - 1].name, ".sdynbss") == 0
		    && addrs_to_abfd_addrs[i - 1] != NULL)))
	    warning (_("section %s not found in %s"), sect_name,
		     bfd_get_filename (abfd));

	  addrs->other[i].addr = 0;
	  addrs->other[i].sectindex = -1;
	}
    }

  do_cleanups (my_cleanup);
}

/* Parse the user's idea of an offset for dynamic linking, into our idea
   of how to represent it for fast symbol reading.  This is the default
   version of the sym_fns.sym_offsets function for symbol readers that
   don't need to do anything special.  It allocates a section_offsets table
   for the objectfile OBJFILE and stuffs ADDR into all of the offsets.  */

void
default_symfile_offsets (struct objfile *objfile,
			 const struct section_addr_info *addrs)
{
  objfile->num_sections = gdb_bfd_count_sections (objfile->obfd);
  objfile->section_offsets = (struct section_offsets *)
    obstack_alloc (&objfile->objfile_obstack,
		   SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
  relative_addr_info_to_section_offsets (objfile->section_offsets,
					 objfile->num_sections, addrs);

  /* For relocatable files, all loadable sections will start at zero.
     The zero is meaningless, so try to pick arbitrary addresses such
     that no loadable sections overlap.  This algorithm is quadratic,
     but the number of sections in a single object file is generally
     small.  */
  if ((bfd_get_file_flags (objfile->obfd) & (EXEC_P | DYNAMIC)) == 0)
    {
      struct place_section_arg arg;
      bfd *abfd = objfile->obfd;
      asection *cur_sec;

      for (cur_sec = abfd->sections; cur_sec != NULL; cur_sec = cur_sec->next)
	/* We do not expect this to happen; just skip this step if the
	   relocatable file has a section with an assigned VMA.  */
	if (bfd_section_vma (abfd, cur_sec) != 0)
	  break;

      if (cur_sec == NULL)
	{
	  CORE_ADDR *offsets = objfile->section_offsets->offsets;

	  /* Pick non-overlapping offsets for sections the user did not
	     place explicitly.  */
	  arg.offsets = objfile->section_offsets;
	  arg.lowest = 0;
	  bfd_map_over_sections (objfile->obfd, place_section, &arg);

	  /* Correctly filling in the section offsets is not quite
	     enough.  Relocatable files have two properties that
	     (most) shared objects do not:

	     - Their debug information will contain relocations.  Some
	     shared libraries do also, but many do not, so this can not
	     be assumed.

	     - If there are multiple code sections they will be loaded
	     at different relative addresses in memory than they are
	     in the objfile, since all sections in the file will start
	     at address zero.

	     Because GDB has very limited ability to map from an
	     address in debug info to the correct code section,
	     it relies on adding SECT_OFF_TEXT to things which might be
	     code.  If we clear all the section offsets, and set the
	     section VMAs instead, then symfile_relocate_debug_section
	     will return meaningful debug information pointing at the
	     correct sections.

	     GDB has too many different data structures for section
	     addresses - a bfd, objfile, and so_list all have section
	     tables, as does exec_ops.  Some of these could probably
	     be eliminated.  */

	  for (cur_sec = abfd->sections; cur_sec != NULL;
	       cur_sec = cur_sec->next)
	    {
	      if ((bfd_get_section_flags (abfd, cur_sec) & SEC_ALLOC) == 0)
		continue;

	      bfd_set_section_vma (abfd, cur_sec, offsets[cur_sec->index]);
	      exec_set_section_address (bfd_get_filename (abfd),
					cur_sec->index,
					offsets[cur_sec->index]);
	      offsets[cur_sec->index] = 0;
	    }
	}
    }

  /* Remember the bfd indexes for the .text, .data, .bss and
     .rodata sections.  */
  init_objfile_sect_indices (objfile);
}

/* Divide the file into segments, which are individual relocatable units.
   This is the default version of the sym_fns.sym_segments function for
   symbol readers that do not have an explicit representation of segments.
   It assumes that object files do not have segments, and fully linked
   files have a single segment.  */

struct symfile_segment_data *
default_symfile_segments (bfd *abfd)
{
  int num_sections, i;
  asection *sect;
  struct symfile_segment_data *data;
  CORE_ADDR low, high;

  /* Relocatable files contain enough information to position each
     loadable section independently; they should not be relocated
     in segments.  */
  if ((bfd_get_file_flags (abfd) & (EXEC_P | DYNAMIC)) == 0)
    return NULL;

  /* Make sure there is at least one loadable section in the file.  */
  for (sect = abfd->sections; sect != NULL; sect = sect->next)
    {
      if ((bfd_get_section_flags (abfd, sect) & SEC_ALLOC) == 0)
	continue;

      break;
    }
  if (sect == NULL)
    return NULL;

  low = bfd_get_section_vma (abfd, sect);
  high = low + bfd_get_section_size (sect);

  data = XZALLOC (struct symfile_segment_data);
  data->num_segments = 1;
  data->segment_bases = XCALLOC (1, CORE_ADDR);
  data->segment_sizes = XCALLOC (1, CORE_ADDR);

  num_sections = bfd_count_sections (abfd);
  data->segment_info = XCALLOC (num_sections, int);

  for (i = 0, sect = abfd->sections; sect != NULL; i++, sect = sect->next)
    {
      CORE_ADDR vma;

      if ((bfd_get_section_flags (abfd, sect) & SEC_ALLOC) == 0)
	continue;

      vma = bfd_get_section_vma (abfd, sect);
      if (vma < low)
	low = vma;
      if (vma + bfd_get_section_size (sect) > high)
	high = vma + bfd_get_section_size (sect);

      data->segment_info[i] = 1;
    }

  data->segment_bases[0] = low;
  data->segment_sizes[0] = high - low;

  return data;
}

/* This is a convenience function to call sym_read for OBJFILE and
   possibly force the partial symbols to be read.  */

static void
read_symbols (struct objfile *objfile, int add_flags)
{
  (*objfile->sf->sym_read) (objfile, add_flags);

  /* find_separate_debug_file_in_section should be called only if there is
     single binary with no existing separate debug info file.  */
  if (!objfile_has_partial_symbols (objfile)
      && objfile->separate_debug_objfile == NULL
      && objfile->separate_debug_objfile_backlink == NULL)
    {
      bfd *abfd = find_separate_debug_file_in_section (objfile);
      struct cleanup *cleanup = make_cleanup_bfd_unref (abfd);

      if (abfd != NULL)
	{
	  /* find_separate_debug_file_in_section uses the same filename for the
	     virtual section-as-bfd like the bfd filename containing the
	     section.  Therefore use also non-canonical name form for the same
	     file containing the section.  */
	  symbol_file_add_separate (abfd, objfile->original_name, add_flags,
				    objfile);
	}

      do_cleanups (cleanup);
    }
  if ((add_flags & SYMFILE_NO_READ) == 0)
    require_partial_symbols (objfile, 0);
}

/* Initialize entry point information for this objfile.  */

static void
init_entry_point_info (struct objfile *objfile)
{
  /* Save startup file's range of PC addresses to help blockframe.c
     decide where the bottom of the stack is.  */

  if (bfd_get_file_flags (objfile->obfd) & EXEC_P)
    {
      /* Executable file -- record its entry point so we'll recognize
         the startup file because it contains the entry point.  */
      objfile->ei.entry_point = bfd_get_start_address (objfile->obfd);
      objfile->ei.entry_point_p = 1;
    }
  else if (bfd_get_file_flags (objfile->obfd) & DYNAMIC
	   && bfd_get_start_address (objfile->obfd) != 0)
    {
      /* Some shared libraries may have entry points set and be
	 runnable.  There's no clear way to indicate this, so just check
	 for values other than zero.  */
      objfile->ei.entry_point = bfd_get_start_address (objfile->obfd);
      objfile->ei.entry_point_p = 1;
    }
  else
    {
      /* Examination of non-executable.o files.  Short-circuit this stuff.  */
      objfile->ei.entry_point_p = 0;
    }

  if (objfile->ei.entry_point_p)
    {
      CORE_ADDR entry_point =  objfile->ei.entry_point;

      /* Make certain that the address points at real code, and not a
	 function descriptor.  */
      entry_point
	= gdbarch_convert_from_func_ptr_addr (get_objfile_arch (objfile),
					      entry_point,
					      &current_target);

      /* Remove any ISA markers, so that this matches entries in the
	 symbol table.  */
      objfile->ei.entry_point
	= gdbarch_addr_bits_remove (get_objfile_arch (objfile), entry_point);
    }
}

/* Process a symbol file, as either the main file or as a dynamically
   loaded file.

   This function does not set the OBJFILE's entry-point info.

   OBJFILE is where the symbols are to be read from.

   ADDRS is the list of section load addresses.  If the user has given
   an 'add-symbol-file' command, then this is the list of offsets and
   addresses he or she provided as arguments to the command; or, if
   we're handling a shared library, these are the actual addresses the
   sections are loaded at, according to the inferior's dynamic linker
   (as gleaned by GDB's shared library code).  We convert each address
   into an offset from the section VMA's as it appears in the object
   file, and then call the file's sym_offsets function to convert this
   into a format-specific offset table --- a `struct section_offsets'.

   ADD_FLAGS encodes verbosity level, whether this is main symbol or
   an extra symbol file such as dynamically loaded code, and wether
   breakpoint reset should be deferred.  */

static void
syms_from_objfile_1 (struct objfile *objfile,
		     struct section_addr_info *addrs,
		     int add_flags)
{
  struct section_addr_info *local_addr = NULL;
  struct cleanup *old_chain;
  const int mainline = add_flags & SYMFILE_MAINLINE;

  objfile_set_sym_fns (objfile, find_sym_fns (objfile->obfd));

  if (objfile->sf == NULL)
    {
      /* No symbols to load, but we still need to make sure
	 that the section_offsets table is allocated.  */
      int num_sections = gdb_bfd_count_sections (objfile->obfd);
      size_t size = SIZEOF_N_SECTION_OFFSETS (num_sections);

      objfile->num_sections = num_sections;
      objfile->section_offsets
        = obstack_alloc (&objfile->objfile_obstack, size);
      memset (objfile->section_offsets, 0, size);
      return;
    }

  /* Make sure that partially constructed symbol tables will be cleaned up
     if an error occurs during symbol reading.  */
  old_chain = make_cleanup_free_objfile (objfile);

  /* If ADDRS is NULL, put together a dummy address list.
     We now establish the convention that an addr of zero means
     no load address was specified.  */
  if (! addrs)
    {
      local_addr = alloc_section_addr_info (1);
      make_cleanup (xfree, local_addr);
      addrs = local_addr;
    }

  if (mainline)
    {
      /* We will modify the main symbol table, make sure that all its users
         will be cleaned up if an error occurs during symbol reading.  */
      make_cleanup (clear_symtab_users_cleanup, 0 /*ignore*/);

      /* Since no error yet, throw away the old symbol table.  */

      if (symfile_objfile != NULL)
	{
	  free_objfile (symfile_objfile);
	  gdb_assert (symfile_objfile == NULL);
	}

      /* Currently we keep symbols from the add-symbol-file command.
         If the user wants to get rid of them, they should do "symbol-file"
         without arguments first.  Not sure this is the best behavior
         (PR 2207).  */

      (*objfile->sf->sym_new_init) (objfile);
    }

  /* Convert addr into an offset rather than an absolute address.
     We find the lowest address of a loaded segment in the objfile,
     and assume that <addr> is where that got loaded.

     We no longer warn if the lowest section is not a text segment (as
     happens for the PA64 port.  */
  if (addrs->num_sections > 0)
    addr_info_make_relative (addrs, objfile->obfd);

  /* Initialize symbol reading routines for this objfile, allow complaints to
     appear for this new file, and record how verbose to be, then do the
     initial symbol reading for this file.  */

  (*objfile->sf->sym_init) (objfile);
  clear_complaints (&symfile_complaints, 1, add_flags & SYMFILE_VERBOSE);

  (*objfile->sf->sym_offsets) (objfile, addrs);

  read_symbols (objfile, add_flags);

  /* Discard cleanups as symbol reading was successful.  */

  discard_cleanups (old_chain);
  xfree (local_addr);
}

/* Same as syms_from_objfile_1, but also initializes the objfile
   entry-point info.  */

static void
syms_from_objfile (struct objfile *objfile,
		   struct section_addr_info *addrs,
		   int add_flags)
{
  syms_from_objfile_1 (objfile, addrs, add_flags);
  init_entry_point_info (objfile);
}

/* Perform required actions after either reading in the initial
   symbols for a new objfile, or mapping in the symbols from a reusable
   objfile.  ADD_FLAGS is a bitmask of enum symfile_add_flags.  */

void
new_symfile_objfile (struct objfile *objfile, int add_flags)
{
  /* If this is the main symbol file we have to clean up all users of the
     old main symbol file.  Otherwise it is sufficient to fixup all the
     breakpoints that may have been redefined by this symbol file.  */
  if (add_flags & SYMFILE_MAINLINE)
    {
      /* OK, make it the "real" symbol file.  */
      symfile_objfile = objfile;

      clear_symtab_users (add_flags);
    }
  else if ((add_flags & SYMFILE_DEFER_BP_RESET) == 0)
    {
      breakpoint_re_set ();
    }

  /* We're done reading the symbol file; finish off complaints.  */
  clear_complaints (&symfile_complaints, 0, add_flags & SYMFILE_VERBOSE);
}

/* Process a symbol file, as either the main file or as a dynamically
   loaded file.

   ABFD is a BFD already open on the file, as from symfile_bfd_open.
   A new reference is acquired by this function.

   For NAME description see allocate_objfile's definition.

   ADD_FLAGS encodes verbosity, whether this is main symbol file or
   extra, such as dynamically loaded code, and what to do with breakpoins.

   ADDRS is as described for syms_from_objfile_1, above.
   ADDRS is ignored when SYMFILE_MAINLINE bit is set in ADD_FLAGS.

   PARENT is the original objfile if ABFD is a separate debug info file.
   Otherwise PARENT is NULL.

   Upon success, returns a pointer to the objfile that was added.
   Upon failure, jumps back to command level (never returns).  */

static struct objfile *
symbol_file_add_with_addrs (bfd *abfd, const char *name, int add_flags,
			    struct section_addr_info *addrs,
			    int flags, struct objfile *parent)
{
  struct objfile *objfile;
  const int from_tty = add_flags & SYMFILE_VERBOSE;
  const int mainline = add_flags & SYMFILE_MAINLINE;
  const int should_print = ((from_tty || info_verbose)
			    && (readnow_symbol_files
				|| (add_flags & SYMFILE_NO_READ) == 0));

  if (readnow_symbol_files)
    {
      flags |= OBJF_READNOW;
      add_flags &= ~SYMFILE_NO_READ;
    }

  /* Give user a chance to burp if we'd be
     interactively wiping out any existing symbols.  */

  if ((have_full_symbols () || have_partial_symbols ())
      && mainline
      && from_tty
      && !query (_("Load new symbol table from \"%s\"? "), name))
    error (_("Not confirmed."));

  objfile = allocate_objfile (abfd, name,
			      flags | (mainline ? OBJF_MAINLINE : 0));

  if (parent)
    add_separate_debug_objfile (objfile, parent);

  /* We either created a new mapped symbol table, mapped an existing
     symbol table file which has not had initial symbol reading
     performed, or need to read an unmapped symbol table.  */
  if (should_print)
    {
      if (deprecated_pre_add_symbol_hook)
	deprecated_pre_add_symbol_hook (name);
      else
	{
	  printf_unfiltered (_("Reading symbols from %s..."), name);
	  wrap_here ("");
	  gdb_flush (gdb_stdout);
	}
    }
  syms_from_objfile (objfile, addrs, add_flags);

  /* We now have at least a partial symbol table.  Check to see if the
     user requested that all symbols be read on initial access via either
     the gdb startup command line or on a per symbol file basis.  Expand
     all partial symbol tables for this objfile if so.  */

  if ((flags & OBJF_READNOW))
    {
      if (should_print)
	{
	  printf_unfiltered (_("expanding to full symbols..."));
	  wrap_here ("");
	  gdb_flush (gdb_stdout);
	}

      if (objfile->sf)
	objfile->sf->qf->expand_all_symtabs (objfile);
    }

  if (should_print && !objfile_has_symbols (objfile))
    {
      wrap_here ("");
      printf_unfiltered (_("(no debugging symbols found)..."));
      wrap_here ("");
    }

  if (should_print)
    {
      if (deprecated_post_add_symbol_hook)
	deprecated_post_add_symbol_hook ();
      else
	printf_unfiltered (_("done.\n"));
    }

  /* We print some messages regardless of whether 'from_tty ||
     info_verbose' is true, so make sure they go out at the right
     time.  */
  gdb_flush (gdb_stdout);

  if (objfile->sf == NULL)
    {
      observer_notify_new_objfile (objfile);
      return objfile;	/* No symbols.  */
    }

  new_symfile_objfile (objfile, add_flags);

  observer_notify_new_objfile (objfile);

  bfd_cache_close_all ();
  return (objfile);
}

/* Add BFD as a separate debug file for OBJFILE.  For NAME description
   see allocate_objfile's definition.  */

void
symbol_file_add_separate (bfd *bfd, const char *name, int symfile_flags,
			  struct objfile *objfile)
{
  struct objfile *new_objfile;
  struct section_addr_info *sap;
  struct cleanup *my_cleanup;

  /* Create section_addr_info.  We can't directly use offsets from OBJFILE
     because sections of BFD may not match sections of OBJFILE and because
     vma may have been modified by tools such as prelink.  */
  sap = build_section_addr_info_from_objfile (objfile);
  my_cleanup = make_cleanup_free_section_addr_info (sap);

  new_objfile = symbol_file_add_with_addrs
    (bfd, name, symfile_flags, sap,
     objfile->flags & (OBJF_REORDERED | OBJF_SHARED | OBJF_READNOW
		       | OBJF_USERLOADED),
     objfile);

  do_cleanups (my_cleanup);
}

/* Process the symbol file ABFD, as either the main file or as a
   dynamically loaded file.
   See symbol_file_add_with_addrs's comments for details.  */

struct objfile *
symbol_file_add_from_bfd (bfd *abfd, const char *name, int add_flags,
                          struct section_addr_info *addrs,
                          int flags, struct objfile *parent)
{
  return symbol_file_add_with_addrs (abfd, name, add_flags, addrs, flags,
				     parent);
}

/* Process a symbol file, as either the main file or as a dynamically
   loaded file.  See symbol_file_add_with_addrs's comments for details.  */

struct objfile *
symbol_file_add (const char *name, int add_flags,
		 struct section_addr_info *addrs, int flags)
{
  bfd *bfd = symfile_bfd_open (name);
  struct cleanup *cleanup = make_cleanup_bfd_unref (bfd);
  struct objfile *objf;

  objf = symbol_file_add_from_bfd (bfd, name, add_flags, addrs, flags, NULL);
  do_cleanups (cleanup);
  return objf;
}

/* Call symbol_file_add() with default values and update whatever is
   affected by the loading of a new main().
   Used when the file is supplied in the gdb command line
   and by some targets with special loading requirements.
   The auxiliary function, symbol_file_add_main_1(), has the flags
   argument for the switches that can only be specified in the symbol_file
   command itself.  */

void
symbol_file_add_main (const char *args, int from_tty)
{
  symbol_file_add_main_1 (args, from_tty, 0);
}

static void
symbol_file_add_main_1 (const char *args, int from_tty, int flags)
{
  const int add_flags = (current_inferior ()->symfile_flags
			 | SYMFILE_MAINLINE | (from_tty ? SYMFILE_VERBOSE : 0));

  symbol_file_add (args, add_flags, NULL, flags);

  /* Getting new symbols may change our opinion about
     what is frameless.  */
  reinit_frame_cache ();

  if ((flags & SYMFILE_NO_READ) == 0)
    set_initial_language ();
}

void
symbol_file_clear (int from_tty)
{
  if ((have_full_symbols () || have_partial_symbols ())
      && from_tty
      && (symfile_objfile
	  ? !query (_("Discard symbol table from `%s'? "),
		    objfile_name (symfile_objfile))
	  : !query (_("Discard symbol table? "))))
    error (_("Not confirmed."));

  /* solib descriptors may have handles to objfiles.  Wipe them before their
     objfiles get stale by free_all_objfiles.  */
  no_shared_libraries (NULL, from_tty);

  free_all_objfiles ();

  gdb_assert (symfile_objfile == NULL);
  if (from_tty)
    printf_unfiltered (_("No symbol file now.\n"));
}

static int
separate_debug_file_exists (const char *name, unsigned long crc,
			    struct objfile *parent_objfile)
{
  unsigned long file_crc;
  int file_crc_p;
  bfd *abfd;
  struct stat parent_stat, abfd_stat;
  int verified_as_different;

  /* Find a separate debug info file as if symbols would be present in
     PARENT_OBJFILE itself this function would not be called.  .gnu_debuglink
     section can contain just the basename of PARENT_OBJFILE without any
     ".debug" suffix as "/usr/lib/debug/path/to/file" is a separate tree where
     the separate debug infos with the same basename can exist.  */

  if (filename_cmp (name, objfile_name (parent_objfile)) == 0)
    return 0;

  abfd = gdb_bfd_open_maybe_remote (name);

  if (!abfd)
    return 0;

  /* Verify symlinks were not the cause of filename_cmp name difference above.

     Some operating systems, e.g. Windows, do not provide a meaningful
     st_ino; they always set it to zero.  (Windows does provide a
     meaningful st_dev.)  Do not indicate a duplicate library in that
     case.  While there is no guarantee that a system that provides
     meaningful inode numbers will never set st_ino to zero, this is
     merely an optimization, so we do not need to worry about false
     negatives.  */

  if (bfd_stat (abfd, &abfd_stat) == 0
      && abfd_stat.st_ino != 0
      && bfd_stat (parent_objfile->obfd, &parent_stat) == 0)
    {
      if (abfd_stat.st_dev == parent_stat.st_dev
	  && abfd_stat.st_ino == parent_stat.st_ino)
	{
	  gdb_bfd_unref (abfd);
	  return 0;
	}
      verified_as_different = 1;
    }
  else
    verified_as_different = 0;

  file_crc_p = gdb_bfd_crc (abfd, &file_crc);

  gdb_bfd_unref (abfd);

  if (!file_crc_p)
    return 0;

  if (crc != file_crc)
    {
      unsigned long parent_crc;

      /* If one (or both) the files are accessed for example the via "remote:"
	 gdbserver way it does not support the bfd_stat operation.  Verify
	 whether those two files are not the same manually.  */

      if (!verified_as_different)
	{
	  if (!gdb_bfd_crc (parent_objfile->obfd, &parent_crc))
	    return 0;
	}

      if (verified_as_different || parent_crc != file_crc)
	warning (_("the debug information found in \"%s\""
		   " does not match \"%s\" (CRC mismatch).\n"),
		 name, objfile_name (parent_objfile));

      return 0;
    }

  return 1;
}

char *debug_file_directory = NULL;
static void
show_debug_file_directory (struct ui_file *file, int from_tty,
			   struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("The directory where separate debug "
		      "symbols are searched for is \"%s\".\n"),
		    value);
}

#if ! defined (DEBUG_SUBDIRECTORY)
#define DEBUG_SUBDIRECTORY ".debug"
#endif

/* Find a separate debuginfo file for OBJFILE, using DIR as the directory
   where the original file resides (may not be the same as
   dirname(objfile->name) due to symlinks), and DEBUGLINK as the file we are
   looking for.  CANON_DIR is the "realpath" form of DIR.
   DIR must contain a trailing '/'.
   Returns the path of the file with separate debug info, of NULL.  */

static char *
find_separate_debug_file (const char *dir,
			  const char *canon_dir,
			  const char *debuglink,
			  unsigned long crc32, struct objfile *objfile)
{
  char *debugdir;
  char *debugfile;
  int i;
  VEC (char_ptr) *debugdir_vec;
  struct cleanup *back_to;
  int ix;

  /* Set I to max (strlen (canon_dir), strlen (dir)).  */
  i = strlen (dir);
  if (canon_dir != NULL && strlen (canon_dir) > i)
    i = strlen (canon_dir);

  debugfile = xmalloc (strlen (debug_file_directory) + 1
		       + i
		       + strlen (DEBUG_SUBDIRECTORY)
		       + strlen ("/")
		       + strlen (debuglink)
		       + 1);

  /* First try in the same directory as the original file.  */
  strcpy (debugfile, dir);
  strcat (debugfile, debuglink);

  if (separate_debug_file_exists (debugfile, crc32, objfile))
    return debugfile;

  /* Then try in the subdirectory named DEBUG_SUBDIRECTORY.  */
  strcpy (debugfile, dir);
  strcat (debugfile, DEBUG_SUBDIRECTORY);
  strcat (debugfile, "/");
  strcat (debugfile, debuglink);

  if (separate_debug_file_exists (debugfile, crc32, objfile))
    return debugfile;

  /* Then try in the global debugfile directories.

     Keep backward compatibility so that DEBUG_FILE_DIRECTORY being "" will
     cause "/..." lookups.  */

  debugdir_vec = dirnames_to_char_ptr_vec (debug_file_directory);
  back_to = make_cleanup_free_char_ptr_vec (debugdir_vec);

  for (ix = 0; VEC_iterate (char_ptr, debugdir_vec, ix, debugdir); ++ix)
    {
      strcpy (debugfile, debugdir);
      strcat (debugfile, "/");
      strcat (debugfile, dir);
      strcat (debugfile, debuglink);

      if (separate_debug_file_exists (debugfile, crc32, objfile))
	{
	  do_cleanups (back_to);
	  return debugfile;
	}

      /* If the file is in the sysroot, try using its base path in the
	 global debugfile directory.  */
      if (canon_dir != NULL
	  && filename_ncmp (canon_dir, gdb_sysroot,
			    strlen (gdb_sysroot)) == 0
	  && IS_DIR_SEPARATOR (canon_dir[strlen (gdb_sysroot)]))
	{
	  strcpy (debugfile, debugdir);
	  strcat (debugfile, canon_dir + strlen (gdb_sysroot));
	  strcat (debugfile, "/");
	  strcat (debugfile, debuglink);

	  if (separate_debug_file_exists (debugfile, crc32, objfile))
	    {
	      do_cleanups (back_to);
	      return debugfile;
	    }
	}
    }

  do_cleanups (back_to);
  xfree (debugfile);
  return NULL;
}

/* Modify PATH to contain only "[/]directory/" part of PATH.
   If there were no directory separators in PATH, PATH will be empty
   string on return.  */

static void
terminate_after_last_dir_separator (char *path)
{
  int i;

  /* Strip off the final filename part, leaving the directory name,
     followed by a slash.  The directory can be relative or absolute.  */
  for (i = strlen(path) - 1; i >= 0; i--)
    if (IS_DIR_SEPARATOR (path[i]))
      break;

  /* If I is -1 then no directory is present there and DIR will be "".  */
  path[i + 1] = '\0';
}

/* Find separate debuginfo for OBJFILE (using .gnu_debuglink section).
   Returns pathname, or NULL.  */

char *
find_separate_debug_file_by_debuglink (struct objfile *objfile)
{
  char *debuglink;
  char *dir, *canon_dir;
  char *debugfile;
  unsigned long crc32;
  struct cleanup *cleanups;

  debuglink = bfd_get_debug_link_info (objfile->obfd, &crc32);

  if (debuglink == NULL)
    {
      /* There's no separate debug info, hence there's no way we could
	 load it => no warning.  */
      return NULL;
    }

  cleanups = make_cleanup (xfree, debuglink);
  dir = xstrdup (objfile_name (objfile));
  make_cleanup (xfree, dir);
  terminate_after_last_dir_separator (dir);
  canon_dir = lrealpath (dir);

  debugfile = find_separate_debug_file (dir, canon_dir, debuglink,
					crc32, objfile);
  xfree (canon_dir);

  if (debugfile == NULL)
    {
#ifdef HAVE_LSTAT
      /* For PR gdb/9538, try again with realpath (if different from the
	 original).  */

      struct stat st_buf;

      if (lstat (objfile_name (objfile), &st_buf) == 0
	  && S_ISLNK (st_buf.st_mode))
	{
	  char *symlink_dir;

	  symlink_dir = lrealpath (objfile_name (objfile));
	  if (symlink_dir != NULL)
	    {
	      make_cleanup (xfree, symlink_dir);
	      terminate_after_last_dir_separator (symlink_dir);
	      if (strcmp (dir, symlink_dir) != 0)
		{
		  /* Different directory, so try using it.  */
		  debugfile = find_separate_debug_file (symlink_dir,
							symlink_dir,
							debuglink,
							crc32,
							objfile);
		}
	    }
	}
#endif  /* HAVE_LSTAT  */
    }

  do_cleanups (cleanups);
  return debugfile;
}

/* This is the symbol-file command.  Read the file, analyze its
   symbols, and add a struct symtab to a symtab list.  The syntax of
   the command is rather bizarre:

   1. The function buildargv implements various quoting conventions
   which are undocumented and have little or nothing in common with
   the way things are quoted (or not quoted) elsewhere in GDB.

   2. Options are used, which are not generally used in GDB (perhaps
   "set mapped on", "set readnow on" would be better)

   3. The order of options matters, which is contrary to GNU
   conventions (because it is confusing and inconvenient).  */

void
symbol_file_command (char *args, int from_tty)
{
  dont_repeat ();

  if (args == NULL)
    {
      symbol_file_clear (from_tty);
    }
  else
    {
      char **argv = gdb_buildargv (args);
      int flags = OBJF_USERLOADED;
      struct cleanup *cleanups;
      char *name = NULL;

      cleanups = make_cleanup_freeargv (argv);
      while (*argv != NULL)
	{
	  if (strcmp (*argv, "-readnow") == 0)
	    flags |= OBJF_READNOW;
	  else if (**argv == '-')
	    error (_("unknown option `%s'"), *argv);
	  else
	    {
	      symbol_file_add_main_1 (*argv, from_tty, flags);
	      name = *argv;
	    }

	  argv++;
	}

      if (name == NULL)
	error (_("no symbol file name was specified"));

      do_cleanups (cleanups);
    }
}

/* Set the initial language.

   FIXME: A better solution would be to record the language in the
   psymtab when reading partial symbols, and then use it (if known) to
   set the language.  This would be a win for formats that encode the
   language in an easily discoverable place, such as DWARF.  For
   stabs, we can jump through hoops looking for specially named
   symbols or try to intuit the language from the specific type of
   stabs we find, but we can't do that until later when we read in
   full symbols.  */

void
set_initial_language (void)
{
  enum language lang = language_unknown;

  if (language_of_main != language_unknown)
    lang = language_of_main;
  else
    {
      char *name = main_name ();
      struct symbol *sym = lookup_symbol (name, NULL, VAR_DOMAIN, NULL);

      if (sym != NULL)
	lang = SYMBOL_LANGUAGE (sym);
    }

  if (lang == language_unknown)
    {
      /* Make C the default language */
      lang = language_c;
    }

  set_language (lang);
  expected_language = current_language; /* Don't warn the user.  */
}

/* If NAME is a remote name open the file using remote protocol, otherwise
   open it normally.  Returns a new reference to the BFD.  On error,
   returns NULL with the BFD error set.  */

bfd *
gdb_bfd_open_maybe_remote (const char *name)
{
  bfd *result;

  if (remote_filename_p (name))
    result = remote_bfd_open (name, gnutarget);
  else
    result = gdb_bfd_open (name, gnutarget, -1);

  return result;
}

/* Open the file specified by NAME and hand it off to BFD for
   preliminary analysis.  Return a newly initialized bfd *, which
   includes a newly malloc'd` copy of NAME (tilde-expanded and made
   absolute).  In case of trouble, error() is called.  */

bfd *
symfile_bfd_open (const char *cname)
{
  bfd *sym_bfd;
  int desc;
  char *name, *absolute_name;
  struct cleanup *back_to;

  if (remote_filename_p (cname))
    {
      sym_bfd = remote_bfd_open (cname, gnutarget);
      if (!sym_bfd)
	error (_("`%s': can't open to read symbols: %s."), cname,
	       bfd_errmsg (bfd_get_error ()));

      if (!bfd_check_format (sym_bfd, bfd_object))
	{
	  make_cleanup_bfd_unref (sym_bfd);
	  error (_("`%s': can't read symbols: %s."), cname,
		 bfd_errmsg (bfd_get_error ()));
	}

      return sym_bfd;
    }

  name = tilde_expand (cname);	/* Returns 1st new malloc'd copy.  */

  /* Look down path for it, allocate 2nd new malloc'd copy.  */
  desc = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST | OPF_RETURN_REALPATH, name,
		O_RDONLY | O_BINARY, &absolute_name);
#if defined(__GO32__) || defined(_WIN32) || defined (__CYGWIN__)
  if (desc < 0)
    {
      char *exename = alloca (strlen (name) + 5);

      strcat (strcpy (exename, name), ".exe");
      desc = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST | OPF_RETURN_REALPATH,
		    exename, O_RDONLY | O_BINARY, &absolute_name);
    }
#endif
  if (desc < 0)
    {
      make_cleanup (xfree, name);
      perror_with_name (name);
    }

  xfree (name);
  name = absolute_name;
  back_to = make_cleanup (xfree, name);

  sym_bfd = gdb_bfd_open (name, gnutarget, desc);
  if (!sym_bfd)
    error (_("`%s': can't open to read symbols: %s."), name,
	   bfd_errmsg (bfd_get_error ()));
  bfd_set_cacheable (sym_bfd, 1);

  if (!bfd_check_format (sym_bfd, bfd_object))
    {
      make_cleanup_bfd_unref (sym_bfd);
      error (_("`%s': can't read symbols: %s."), name,
	     bfd_errmsg (bfd_get_error ()));
    }

  do_cleanups (back_to);

  return sym_bfd;
}

/* Return the section index for SECTION_NAME on OBJFILE.  Return -1 if
   the section was not found.  */

int
get_section_index (struct objfile *objfile, char *section_name)
{
  asection *sect = bfd_get_section_by_name (objfile->obfd, section_name);

  if (sect)
    return sect->index;
  else
    return -1;
}

/* Link SF into the global symtab_fns list.
   FLAVOUR is the file format that SF handles.
   Called on startup by the _initialize routine in each object file format
   reader, to register information about each format the reader is prepared
   to handle.  */

void
add_symtab_fns (enum bfd_flavour flavour, const struct sym_fns *sf)
{
  registered_sym_fns fns = { flavour, sf };

  VEC_safe_push (registered_sym_fns, symtab_fns, &fns);
}

/* Initialize OBJFILE to read symbols from its associated BFD.  It
   either returns or calls error().  The result is an initialized
   struct sym_fns in the objfile structure, that contains cached
   information about the symbol file.  */

static const struct sym_fns *
find_sym_fns (bfd *abfd)
{
  registered_sym_fns *rsf;
  enum bfd_flavour our_flavour = bfd_get_flavour (abfd);
  int i;

  if (our_flavour == bfd_target_srec_flavour
      || our_flavour == bfd_target_ihex_flavour
      || our_flavour == bfd_target_tekhex_flavour)
    return NULL;	/* No symbols.  */

  for (i = 0; VEC_iterate (registered_sym_fns, symtab_fns, i, rsf); ++i)
    if (our_flavour == rsf->sym_flavour)
      return rsf->sym_fns;

  error (_("I'm sorry, Dave, I can't do that.  Symbol format `%s' unknown."),
	 bfd_get_target (abfd));
}


/* This function runs the load command of our current target.  */

static void
load_command (char *arg, int from_tty)
{
  struct cleanup *cleanup = make_cleanup (null_cleanup, NULL);

  dont_repeat ();

  /* The user might be reloading because the binary has changed.  Take
     this opportunity to check.  */
  reopen_exec_file ();
  reread_symbols ();

  if (arg == NULL)
    {
      char *parg;
      int count = 0;

      parg = arg = get_exec_file (1);

      /* Count how many \ " ' tab space there are in the name.  */
      while ((parg = strpbrk (parg, "\\\"'\t ")))
	{
	  parg++;
	  count++;
	}

      if (count)
	{
	  /* We need to quote this string so buildargv can pull it apart.  */
	  char *temp = xmalloc (strlen (arg) + count + 1 );
	  char *ptemp = temp;
	  char *prev;

	  make_cleanup (xfree, temp);

	  prev = parg = arg;
	  while ((parg = strpbrk (parg, "\\\"'\t ")))
	    {
	      strncpy (ptemp, prev, parg - prev);
	      ptemp += parg - prev;
	      prev = parg++;
	      *ptemp++ = '\\';
	    }
	  strcpy (ptemp, prev);

	  arg = temp;
	}
    }

  target_load (arg, from_tty);

  /* After re-loading the executable, we don't really know which
     overlays are mapped any more.  */
  overlay_cache_invalid = 1;

  do_cleanups (cleanup);
}

/* This version of "load" should be usable for any target.  Currently
   it is just used for remote targets, not inftarg.c or core files,
   on the theory that only in that case is it useful.

   Avoiding xmodem and the like seems like a win (a) because we don't have
   to worry about finding it, and (b) On VMS, fork() is very slow and so
   we don't want to run a subprocess.  On the other hand, I'm not sure how
   performance compares.  */

static int validate_download = 0;

/* Callback service function for generic_load (bfd_map_over_sections).  */

static void
add_section_size_callback (bfd *abfd, asection *asec, void *data)
{
  bfd_size_type *sum = data;

  *sum += bfd_get_section_size (asec);
}

/* Opaque data for load_section_callback.  */
struct load_section_data {
  CORE_ADDR load_offset;
  struct load_progress_data *progress_data;
  VEC(memory_write_request_s) *requests;
};

/* Opaque data for load_progress.  */
struct load_progress_data {
  /* Cumulative data.  */
  unsigned long write_count;
  unsigned long data_count;
  bfd_size_type total_size;
};

/* Opaque data for load_progress for a single section.  */
struct load_progress_section_data {
  struct load_progress_data *cumulative;

  /* Per-section data.  */
  const char *section_name;
  ULONGEST section_sent;
  ULONGEST section_size;
  CORE_ADDR lma;
  gdb_byte *buffer;
};

/* Target write callback routine for progress reporting.  */

static void
load_progress (ULONGEST bytes, void *untyped_arg)
{
  struct load_progress_section_data *args = untyped_arg;
  struct load_progress_data *totals;

  if (args == NULL)
    /* Writing padding data.  No easy way to get at the cumulative
       stats, so just ignore this.  */
    return;

  totals = args->cumulative;

  if (bytes == 0 && args->section_sent == 0)
    {
      /* The write is just starting.  Let the user know we've started
	 this section.  */
      ui_out_message (current_uiout, 0, "Loading section %s, size %s lma %s\n",
		      args->section_name, hex_string (args->section_size),
		      paddress (target_gdbarch (), args->lma));
      return;
    }

  if (validate_download)
    {
      /* Broken memories and broken monitors manifest themselves here
	 when bring new computers to life.  This doubles already slow
	 downloads.  */
      /* NOTE: cagney/1999-10-18: A more efficient implementation
	 might add a verify_memory() method to the target vector and
	 then use that.  remote.c could implement that method using
	 the ``qCRC'' packet.  */
      gdb_byte *check = xmalloc (bytes);
      struct cleanup *verify_cleanups = make_cleanup (xfree, check);

      if (target_read_memory (args->lma, check, bytes) != 0)
	error (_("Download verify read failed at %s"),
	       paddress (target_gdbarch (), args->lma));
      if (memcmp (args->buffer, check, bytes) != 0)
	error (_("Download verify compare failed at %s"),
	       paddress (target_gdbarch (), args->lma));
      do_cleanups (verify_cleanups);
    }
  totals->data_count += bytes;
  args->lma += bytes;
  args->buffer += bytes;
  totals->write_count += 1;
  args->section_sent += bytes;
  if (check_quit_flag ()
      || (deprecated_ui_load_progress_hook != NULL
	  && deprecated_ui_load_progress_hook (args->section_name,
					       args->section_sent)))
    error (_("Canceled the download"));

  if (deprecated_show_load_progress != NULL)
    deprecated_show_load_progress (args->section_name,
				   args->section_sent,
				   args->section_size,
				   totals->data_count,
				   totals->total_size);
}

/* Callback service function for generic_load (bfd_map_over_sections).  */

static void
load_section_callback (bfd *abfd, asection *asec, void *data)
{
  struct memory_write_request *new_request;
  struct load_section_data *args = data;
  struct load_progress_section_data *section_data;
  bfd_size_type size = bfd_get_section_size (asec);
  gdb_byte *buffer;
  const char *sect_name = bfd_get_section_name (abfd, asec);

  if ((bfd_get_section_flags (abfd, asec) & SEC_LOAD) == 0)
    return;

  if (size == 0)
    return;

  new_request = VEC_safe_push (memory_write_request_s,
			       args->requests, NULL);
  memset (new_request, 0, sizeof (struct memory_write_request));
  section_data = xcalloc (1, sizeof (struct load_progress_section_data));
  new_request->begin = bfd_section_lma (abfd, asec) + args->load_offset;
  new_request->end = new_request->begin + size; /* FIXME Should size
						   be in instead?  */
  new_request->data = xmalloc (size);
  new_request->baton = section_data;

  buffer = new_request->data;

  section_data->cumulative = args->progress_data;
  section_data->section_name = sect_name;
  section_data->section_size = size;
  section_data->lma = new_request->begin;
  section_data->buffer = buffer;

  bfd_get_section_contents (abfd, asec, buffer, 0, size);
}

/* Clean up an entire memory request vector, including load
   data and progress records.  */

static void
clear_memory_write_data (void *arg)
{
  VEC(memory_write_request_s) **vec_p = arg;
  VEC(memory_write_request_s) *vec = *vec_p;
  int i;
  struct memory_write_request *mr;

  for (i = 0; VEC_iterate (memory_write_request_s, vec, i, mr); ++i)
    {
      xfree (mr->data);
      xfree (mr->baton);
    }
  VEC_free (memory_write_request_s, vec);
}

void
generic_load (char *args, int from_tty)
{
  bfd *loadfile_bfd;
  struct timeval start_time, end_time;
  char *filename;
  struct cleanup *old_cleanups = make_cleanup (null_cleanup, 0);
  struct load_section_data cbdata;
  struct load_progress_data total_progress;
  struct ui_out *uiout = current_uiout;

  CORE_ADDR entry;
  char **argv;

  memset (&cbdata, 0, sizeof (cbdata));
  memset (&total_progress, 0, sizeof (total_progress));
  cbdata.progress_data = &total_progress;

  make_cleanup (clear_memory_write_data, &cbdata.requests);

  if (args == NULL)
    error_no_arg (_("file to load"));

  argv = gdb_buildargv (args);
  make_cleanup_freeargv (argv);

  filename = tilde_expand (argv[0]);
  make_cleanup (xfree, filename);

  if (argv[1] != NULL)
    {
      const char *endptr;

      cbdata.load_offset = strtoulst (argv[1], &endptr, 0);

      /* If the last word was not a valid number then
         treat it as a file name with spaces in.  */
      if (argv[1] == endptr)
        error (_("Invalid download offset:%s."), argv[1]);

      if (argv[2] != NULL)
	error (_("Too many parameters."));
    }

  /* Open the file for loading.  */
  loadfile_bfd = gdb_bfd_open (filename, gnutarget, -1);
  if (loadfile_bfd == NULL)
    {
      perror_with_name (filename);
      return;
    }

  make_cleanup_bfd_unref (loadfile_bfd);

  if (!bfd_check_format (loadfile_bfd, bfd_object))
    {
      error (_("\"%s\" is not an object file: %s"), filename,
	     bfd_errmsg (bfd_get_error ()));
    }

  bfd_map_over_sections (loadfile_bfd, add_section_size_callback,
			 (void *) &total_progress.total_size);

  bfd_map_over_sections (loadfile_bfd, load_section_callback, &cbdata);

  gettimeofday (&start_time, NULL);

  if (target_write_memory_blocks (cbdata.requests, flash_discard,
				  load_progress) != 0)
    error (_("Load failed"));

  gettimeofday (&end_time, NULL);

  entry = bfd_get_start_address (loadfile_bfd);
  entry = gdbarch_addr_bits_remove (target_gdbarch (), entry);
  ui_out_text (uiout, "Start address ");
  ui_out_field_fmt (uiout, "address", "%s", paddress (target_gdbarch (), entry));
  ui_out_text (uiout, ", load size ");
  ui_out_field_fmt (uiout, "load-size", "%lu", total_progress.data_count);
  ui_out_text (uiout, "\n");
  /* We were doing this in remote-mips.c, I suspect it is right
     for other targets too.  */
  regcache_write_pc (get_current_regcache (), entry);

  /* Reset breakpoints, now that we have changed the load image.  For
     instance, breakpoints may have been set (or reset, by
     post_create_inferior) while connected to the target but before we
     loaded the program.  In that case, the prologue analyzer could
     have read instructions from the target to find the right
     breakpoint locations.  Loading has changed the contents of that
     memory.  */

  breakpoint_re_set ();

  /* FIXME: are we supposed to call symbol_file_add or not?  According
     to a comment from remote-mips.c (where a call to symbol_file_add
     was commented out), making the call confuses GDB if more than one
     file is loaded in.  Some targets do (e.g., remote-vx.c) but
     others don't (or didn't - perhaps they have all been deleted).  */

  print_transfer_performance (gdb_stdout, total_progress.data_count,
			      total_progress.write_count,
			      &start_time, &end_time);

  do_cleanups (old_cleanups);
}

/* Report how fast the transfer went.  */

void
print_transfer_performance (struct ui_file *stream,
			    unsigned long data_count,
			    unsigned long write_count,
			    const struct timeval *start_time,
			    const struct timeval *end_time)
{
  ULONGEST time_count;
  struct ui_out *uiout = current_uiout;

  /* Compute the elapsed time in milliseconds, as a tradeoff between
     accuracy and overflow.  */
  time_count = (end_time->tv_sec - start_time->tv_sec) * 1000;
  time_count += (end_time->tv_usec - start_time->tv_usec) / 1000;

  ui_out_text (uiout, "Transfer rate: ");
  if (time_count > 0)
    {
      unsigned long rate = ((ULONGEST) data_count * 1000) / time_count;

      if (ui_out_is_mi_like_p (uiout))
	{
	  ui_out_field_fmt (uiout, "transfer-rate", "%lu", rate * 8);
	  ui_out_text (uiout, " bits/sec");
	}
      else if (rate < 1024)
	{
	  ui_out_field_fmt (uiout, "transfer-rate", "%lu", rate);
	  ui_out_text (uiout, " bytes/sec");
	}
      else
	{
	  ui_out_field_fmt (uiout, "transfer-rate", "%lu", rate / 1024);
	  ui_out_text (uiout, " KB/sec");
	}
    }
  else
    {
      ui_out_field_fmt (uiout, "transferred-bits", "%lu", (data_count * 8));
      ui_out_text (uiout, " bits in <1 sec");
    }
  if (write_count > 0)
    {
      ui_out_text (uiout, ", ");
      ui_out_field_fmt (uiout, "write-rate", "%lu", data_count / write_count);
      ui_out_text (uiout, " bytes/write");
    }
  ui_out_text (uiout, ".\n");
}

/* This function allows the addition of incrementally linked object files.
   It does not modify any state in the target, only in the debugger.  */
/* Note: ezannoni 2000-04-13 This function/command used to have a
   special case syntax for the rombug target (Rombug is the boot
   monitor for Microware's OS-9 / OS-9000, see remote-os9k.c). In the
   rombug case, the user doesn't need to supply a text address,
   instead a call to target_link() (in target.c) would supply the
   value to use.  We are now discontinuing this type of ad hoc syntax.  */

static void
add_symbol_file_command (char *args, int from_tty)
{
  struct gdbarch *gdbarch = get_current_arch ();
  char *filename = NULL;
  int flags = OBJF_USERLOADED;
  char *arg;
  int section_index = 0;
  int argcnt = 0;
  int sec_num = 0;
  int i;
  int expecting_sec_name = 0;
  int expecting_sec_addr = 0;
  char **argv;

  struct sect_opt
  {
    char *name;
    char *value;
  };

  struct section_addr_info *section_addrs;
  struct sect_opt *sect_opts = NULL;
  size_t num_sect_opts = 0;
  struct cleanup *my_cleanups = make_cleanup (null_cleanup, NULL);

  num_sect_opts = 16;
  sect_opts = (struct sect_opt *) xmalloc (num_sect_opts
					   * sizeof (struct sect_opt));

  dont_repeat ();

  if (args == NULL)
    error (_("add-symbol-file takes a file name and an address"));

  argv = gdb_buildargv (args);
  make_cleanup_freeargv (argv);

  for (arg = argv[0], argcnt = 0; arg != NULL; arg = argv[++argcnt])
    {
      /* Process the argument.  */
      if (argcnt == 0)
	{
	  /* The first argument is the file name.  */
	  filename = tilde_expand (arg);
	  make_cleanup (xfree, filename);
	}
      else if (argcnt == 1)
	{
	  /* The second argument is always the text address at which
	     to load the program.  */
	  sect_opts[section_index].name = ".text";
	  sect_opts[section_index].value = arg;
	  if (++section_index >= num_sect_opts)
	    {
	      num_sect_opts *= 2;
	      sect_opts = ((struct sect_opt *)
			   xrealloc (sect_opts,
				     num_sect_opts
				     * sizeof (struct sect_opt)));
	    }
	}
      else
	{
	  /* It's an option (starting with '-') or it's an argument
	     to an option.  */
	  if (expecting_sec_name)
	    {
	      sect_opts[section_index].name = arg;
	      expecting_sec_name = 0;
	    }
	  else if (expecting_sec_addr)
	    {
	      sect_opts[section_index].value = arg;
	      expecting_sec_addr = 0;
	      if (++section_index >= num_sect_opts)
		{
		  num_sect_opts *= 2;
		  sect_opts = ((struct sect_opt *)
			       xrealloc (sect_opts,
					 num_sect_opts
					 * sizeof (struct sect_opt)));
		}
	    }
	  else if (strcmp (arg, "-readnow") == 0)
	    flags |= OBJF_READNOW;
	  else if (strcmp (arg, "-s") == 0)
	    {
	      expecting_sec_name = 1;
	      expecting_sec_addr = 1;
	    }
	  else
	    error (_("USAGE: add-symbol-file <filename> <textaddress>"
		     " [-readnow] [-s <secname> <addr>]*"));
	}
    }

  /* This command takes at least two arguments.  The first one is a
     filename, and the second is the address where this file has been
     loaded.  Abort now if this address hasn't been provided by the
     user.  */
  if (section_index < 1)
    error (_("The address where %s has been loaded is missing"), filename);

  /* Print the prompt for the query below.  And save the arguments into
     a sect_addr_info structure to be passed around to other
     functions.  We have to split this up into separate print
     statements because hex_string returns a local static
     string.  */

  printf_unfiltered (_("add symbol table from file \"%s\" at\n"), filename);
  section_addrs = alloc_section_addr_info (section_index);
  make_cleanup (xfree, section_addrs);
  for (i = 0; i < section_index; i++)
    {
      CORE_ADDR addr;
      char *val = sect_opts[i].value;
      char *sec = sect_opts[i].name;

      addr = parse_and_eval_address (val);

      /* Here we store the section offsets in the order they were
         entered on the command line.  */
      section_addrs->other[sec_num].name = sec;
      section_addrs->other[sec_num].addr = addr;
      printf_unfiltered ("\t%s_addr = %s\n", sec,
			 paddress (gdbarch, addr));
      sec_num++;

      /* The object's sections are initialized when a
	 call is made to build_objfile_section_table (objfile).
	 This happens in reread_symbols.
	 At this point, we don't know what file type this is,
	 so we can't determine what section names are valid.  */
    }
  section_addrs->num_sections = sec_num;

  if (from_tty && (!query ("%s", "")))
    error (_("Not confirmed."));

  symbol_file_add (filename, from_tty ? SYMFILE_VERBOSE : 0,
                   section_addrs, flags);

  /* Getting new symbols may change our opinion about what is
     frameless.  */
  reinit_frame_cache ();
  do_cleanups (my_cleanups);
}


typedef struct objfile *objfilep;

DEF_VEC_P (objfilep);

/* Re-read symbols if a symbol-file has changed.  */

void
reread_symbols (void)
{
  struct objfile *objfile;
  long new_modtime;
  struct stat new_statbuf;
  int res;
  VEC (objfilep) *new_objfiles = NULL;
  struct cleanup *all_cleanups;

  all_cleanups = make_cleanup (VEC_cleanup (objfilep), &new_objfiles);

  /* With the addition of shared libraries, this should be modified,
     the load time should be saved in the partial symbol tables, since
     different tables may come from different source files.  FIXME.
     This routine should then walk down each partial symbol table
     and see if the symbol table that it originates from has been changed.  */

  for (objfile = object_files; objfile; objfile = objfile->next)
    {
      if (objfile->obfd == NULL)
	continue;

      /* Separate debug objfiles are handled in the main objfile.  */
      if (objfile->separate_debug_objfile_backlink)
	continue;

      /* If this object is from an archive (what you usually create with
	 `ar', often called a `static library' on most systems, though
	 a `shared library' on AIX is also an archive), then you should
	 stat on the archive name, not member name.  */
      if (objfile->obfd->my_archive)
	res = stat (objfile->obfd->my_archive->filename, &new_statbuf);
      else
	res = stat (objfile_name (objfile), &new_statbuf);
      if (res != 0)
	{
	  /* FIXME, should use print_sys_errmsg but it's not filtered.  */
	  printf_unfiltered (_("`%s' has disappeared; keeping its symbols.\n"),
			     objfile_name (objfile));
	  continue;
	}
      new_modtime = new_statbuf.st_mtime;
      if (new_modtime != objfile->mtime)
	{
	  struct cleanup *old_cleanups;
	  struct section_offsets *offsets;
	  int num_offsets;
	  char *original_name;

	  printf_unfiltered (_("`%s' has changed; re-reading symbols.\n"),
			     objfile_name (objfile));

	  /* There are various functions like symbol_file_add,
	     symfile_bfd_open, syms_from_objfile, etc., which might
	     appear to do what we want.  But they have various other
	     effects which we *don't* want.  So we just do stuff
	     ourselves.  We don't worry about mapped files (for one thing,
	     any mapped file will be out of date).  */

	  /* If we get an error, blow away this objfile (not sure if
	     that is the correct response for things like shared
	     libraries).  */
	  old_cleanups = make_cleanup_free_objfile (objfile);
	  /* We need to do this whenever any symbols go away.  */
	  make_cleanup (clear_symtab_users_cleanup, 0 /*ignore*/);

	  if (exec_bfd != NULL
	      && filename_cmp (bfd_get_filename (objfile->obfd),
			       bfd_get_filename (exec_bfd)) == 0)
	    {
	      /* Reload EXEC_BFD without asking anything.  */

	      exec_file_attach (bfd_get_filename (objfile->obfd), 0);
	    }

	  /* Keep the calls order approx. the same as in free_objfile.  */

	  /* Free the separate debug objfiles.  It will be
	     automatically recreated by sym_read.  */
	  free_objfile_separate_debug (objfile);

	  /* Remove any references to this objfile in the global
	     value lists.  */
	  preserve_values (objfile);

	  /* Nuke all the state that we will re-read.  Much of the following
	     code which sets things to NULL really is necessary to tell
	     other parts of GDB that there is nothing currently there.

	     Try to keep the freeing order compatible with free_objfile.  */

	  if (objfile->sf != NULL)
	    {
	      (*objfile->sf->sym_finish) (objfile);
	    }

	  clear_objfile_data (objfile);

	  /* Clean up any state BFD has sitting around.  */
	  {
	    struct bfd *obfd = objfile->obfd;
	    char *obfd_filename;

	    obfd_filename = bfd_get_filename (objfile->obfd);
	    /* Open the new BFD before freeing the old one, so that
	       the filename remains live.  */
	    objfile->obfd = gdb_bfd_open_maybe_remote (obfd_filename);
	    if (objfile->obfd == NULL)
	      {
		/* We have to make a cleanup and error here, rather
		   than erroring later, because once we unref OBFD,
		   OBFD_FILENAME will be freed.  */
		make_cleanup_bfd_unref (obfd);
		error (_("Can't open %s to read symbols."), obfd_filename);
	      }
	    gdb_bfd_unref (obfd);
	  }

	  original_name = xstrdup (objfile->original_name);
	  make_cleanup (xfree, original_name);

	  /* bfd_openr sets cacheable to true, which is what we want.  */
	  if (!bfd_check_format (objfile->obfd, bfd_object))
	    error (_("Can't read symbols from %s: %s."), objfile_name (objfile),
		   bfd_errmsg (bfd_get_error ()));

	  /* Save the offsets, we will nuke them with the rest of the
	     objfile_obstack.  */
	  num_offsets = objfile->num_sections;
	  offsets = ((struct section_offsets *)
		     alloca (SIZEOF_N_SECTION_OFFSETS (num_offsets)));
	  memcpy (offsets, objfile->section_offsets,
		  SIZEOF_N_SECTION_OFFSETS (num_offsets));

	  /* FIXME: Do we have to free a whole linked list, or is this
	     enough?  */
	  if (objfile->global_psymbols.list)
	    xfree (objfile->global_psymbols.list);
	  memset (&objfile->global_psymbols, 0,
		  sizeof (objfile->global_psymbols));
	  if (objfile->static_psymbols.list)
	    xfree (objfile->static_psymbols.list);
	  memset (&objfile->static_psymbols, 0,
		  sizeof (objfile->static_psymbols));

	  /* Free the obstacks for non-reusable objfiles.  */
	  psymbol_bcache_free (objfile->psymbol_cache);
	  objfile->psymbol_cache = psymbol_bcache_init ();
	  obstack_free (&objfile->objfile_obstack, 0);
	  objfile->sections = NULL;
	  objfile->symtabs = NULL;
	  objfile->psymtabs = NULL;
	  objfile->psymtabs_addrmap = NULL;
	  objfile->free_psymtabs = NULL;
	  objfile->template_symbols = NULL;
	  objfile->msymbols = NULL;
	  objfile->minimal_symbol_count = 0;
	  memset (&objfile->msymbol_hash, 0,
		  sizeof (objfile->msymbol_hash));
	  memset (&objfile->msymbol_demangled_hash, 0,
		  sizeof (objfile->msymbol_demangled_hash));

	  set_objfile_per_bfd (objfile);

	  /* obstack_init also initializes the obstack so it is
	     empty.  We could use obstack_specify_allocation but
	     gdb_obstack.h specifies the alloc/dealloc functions.  */
	  obstack_init (&objfile->objfile_obstack);

	  objfile->original_name = obstack_copy0 (&objfile->objfile_obstack,
						  original_name,
						  strlen (original_name));

	  /* Reset the sym_fns pointer.  The ELF reader can change it
	     based on whether .gdb_index is present, and we need it to
	     start over.  PR symtab/15885  */
	  objfile_set_sym_fns (objfile, find_sym_fns (objfile->obfd));

	  build_objfile_section_table (objfile);
	  terminate_minimal_symbol_table (objfile);

	  /* We use the same section offsets as from last time.  I'm not
	     sure whether that is always correct for shared libraries.  */
	  objfile->section_offsets = (struct section_offsets *)
	    obstack_alloc (&objfile->objfile_obstack,
			   SIZEOF_N_SECTION_OFFSETS (num_offsets));
	  memcpy (objfile->section_offsets, offsets,
		  SIZEOF_N_SECTION_OFFSETS (num_offsets));
	  objfile->num_sections = num_offsets;

	  /* What the hell is sym_new_init for, anyway?  The concept of
	     distinguishing between the main file and additional files
	     in this way seems rather dubious.  */
	  if (objfile == symfile_objfile)
	    {
	      (*objfile->sf->sym_new_init) (objfile);
	    }

	  (*objfile->sf->sym_init) (objfile);
	  clear_complaints (&symfile_complaints, 1, 1);

	  objfile->flags &= ~OBJF_PSYMTABS_READ;
	  read_symbols (objfile, 0);

	  if (!objfile_has_symbols (objfile))
	    {
	      wrap_here ("");
	      printf_unfiltered (_("(no debugging symbols found)\n"));
	      wrap_here ("");
	    }

	  /* We're done reading the symbol file; finish off complaints.  */
	  clear_complaints (&symfile_complaints, 0, 1);

	  /* Getting new symbols may change our opinion about what is
	     frameless.  */

	  reinit_frame_cache ();

	  /* Discard cleanups as symbol reading was successful.  */
	  discard_cleanups (old_cleanups);

	  /* If the mtime has changed between the time we set new_modtime
	     and now, we *want* this to be out of date, so don't call stat
	     again now.  */
	  objfile->mtime = new_modtime;
	  init_entry_point_info (objfile);

	  VEC_safe_push (objfilep, new_objfiles, objfile);
	}
    }

  if (new_objfiles)
    {
      int ix;

      /* Notify objfiles that we've modified objfile sections.  */
      objfiles_changed ();

      clear_symtab_users (0);

      /* clear_objfile_data for each objfile was called before freeing it and
	 observer_notify_new_objfile (NULL) has been called by
	 clear_symtab_users above.  Notify the new files now.  */
      for (ix = 0; VEC_iterate (objfilep, new_objfiles, ix, objfile); ix++)
	observer_notify_new_objfile (objfile);

      /* At least one objfile has changed, so we can consider that
         the executable we're debugging has changed too.  */
      observer_notify_executable_changed ();
    }

  do_cleanups (all_cleanups);
}


typedef struct
{
  char *ext;
  enum language lang;
}
filename_language;

static filename_language *filename_language_table;
static int fl_table_size, fl_table_next;

static void
add_filename_language (char *ext, enum language lang)
{
  if (fl_table_next >= fl_table_size)
    {
      fl_table_size += 10;
      filename_language_table =
	xrealloc (filename_language_table,
		  fl_table_size * sizeof (*filename_language_table));
    }

  filename_language_table[fl_table_next].ext = xstrdup (ext);
  filename_language_table[fl_table_next].lang = lang;
  fl_table_next++;
}

static char *ext_args;
static void
show_ext_args (struct ui_file *file, int from_tty,
	       struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("Mapping between filename extension "
		      "and source language is \"%s\".\n"),
		    value);
}

static void
set_ext_lang_command (char *args, int from_tty, struct cmd_list_element *e)
{
  int i;
  char *cp = ext_args;
  enum language lang;

  /* First arg is filename extension, starting with '.'  */
  if (*cp != '.')
    error (_("'%s': Filename extension must begin with '.'"), ext_args);

  /* Find end of first arg.  */
  while (*cp && !isspace (*cp))
    cp++;

  if (*cp == '\0')
    error (_("'%s': two arguments required -- "
	     "filename extension and language"),
	   ext_args);

  /* Null-terminate first arg.  */
  *cp++ = '\0';

  /* Find beginning of second arg, which should be a source language.  */
  cp = skip_spaces (cp);

  if (*cp == '\0')
    error (_("'%s': two arguments required -- "
	     "filename extension and language"),
	   ext_args);

  /* Lookup the language from among those we know.  */
  lang = language_enum (cp);

  /* Now lookup the filename extension: do we already know it?  */
  for (i = 0; i < fl_table_next; i++)
    if (0 == strcmp (ext_args, filename_language_table[i].ext))
      break;

  if (i >= fl_table_next)
    {
      /* New file extension.  */
      add_filename_language (ext_args, lang);
    }
  else
    {
      /* Redefining a previously known filename extension.  */

      /* if (from_tty) */
      /*   query ("Really make files of type %s '%s'?", */
      /*          ext_args, language_str (lang));           */

      xfree (filename_language_table[i].ext);
      filename_language_table[i].ext = xstrdup (ext_args);
      filename_language_table[i].lang = lang;
    }
}

static void
info_ext_lang_command (char *args, int from_tty)
{
  int i;

  printf_filtered (_("Filename extensions and the languages they represent:"));
  printf_filtered ("\n\n");
  for (i = 0; i < fl_table_next; i++)
    printf_filtered ("\t%s\t- %s\n",
		     filename_language_table[i].ext,
		     language_str (filename_language_table[i].lang));
}

static void
init_filename_language_table (void)
{
  if (fl_table_size == 0)	/* Protect against repetition.  */
    {
      fl_table_size = 20;
      fl_table_next = 0;
      filename_language_table =
	xmalloc (fl_table_size * sizeof (*filename_language_table));
      add_filename_language (".c", language_c);
      add_filename_language (".d", language_d);
      add_filename_language (".C", language_cplus);
      add_filename_language (".cc", language_cplus);
      add_filename_language (".cp", language_cplus);
      add_filename_language (".cpp", language_cplus);
      add_filename_language (".cxx", language_cplus);
      add_filename_language (".c++", language_cplus);
      add_filename_language (".java", language_java);
      add_filename_language (".class", language_java);
      add_filename_language (".m", language_objc);
      add_filename_language (".f", language_fortran);
      add_filename_language (".F", language_fortran);
      add_filename_language (".for", language_fortran);
      add_filename_language (".FOR", language_fortran);
      add_filename_language (".ftn", language_fortran);
      add_filename_language (".FTN", language_fortran);
      add_filename_language (".fpp", language_fortran);
      add_filename_language (".FPP", language_fortran);
      add_filename_language (".f90", language_fortran);
      add_filename_language (".F90", language_fortran);
      add_filename_language (".f95", language_fortran);
      add_filename_language (".F95", language_fortran);
      add_filename_language (".f03", language_fortran);
      add_filename_language (".F03", language_fortran);
      add_filename_language (".f08", language_fortran);
      add_filename_language (".F08", language_fortran);
      add_filename_language (".s", language_asm);
      add_filename_language (".sx", language_asm);
      add_filename_language (".S", language_asm);
      add_filename_language (".pas", language_pascal);
      add_filename_language (".p", language_pascal);
      add_filename_language (".pp", language_pascal);
      add_filename_language (".adb", language_ada);
      add_filename_language (".ads", language_ada);
      add_filename_language (".a", language_ada);
      add_filename_language (".ada", language_ada);
      add_filename_language (".dg", language_ada);
    }
}

enum language
deduce_language_from_filename (const char *filename)
{
  int i;
  char *cp;

  if (filename != NULL)
    if ((cp = strrchr (filename, '.')) != NULL)
      for (i = 0; i < fl_table_next; i++)
	if (strcmp (cp, filename_language_table[i].ext) == 0)
	  return filename_language_table[i].lang;

  return language_unknown;
}

/* allocate_symtab:

   Allocate and partly initialize a new symbol table.  Return a pointer
   to it.  error() if no space.

   Caller must set these fields:
   LINETABLE(symtab)
   symtab->blockvector
   symtab->dirname
   symtab->free_code
   symtab->free_ptr
 */

struct symtab *
allocate_symtab (const char *filename, struct objfile *objfile)
{
  struct symtab *symtab;

  symtab = (struct symtab *)
    obstack_alloc (&objfile->objfile_obstack, sizeof (struct symtab));
  memset (symtab, 0, sizeof (*symtab));
  symtab->filename = (char *) bcache (filename, strlen (filename) + 1,
				      objfile->per_bfd->filename_cache);
  symtab->fullname = NULL;
  symtab->language = deduce_language_from_filename (filename);
  symtab->debugformat = "unknown";

  /* Hook it to the objfile it comes from.  */

  symtab->objfile = objfile;
  symtab->next = objfile->symtabs;
  objfile->symtabs = symtab;

  if (symtab_create_debug)
    {
      /* Be a bit clever with debugging messages, and don't print objfile
	 every time, only when it changes.  */
      static char *last_objfile_name = NULL;

      if (last_objfile_name == NULL
	  || strcmp (last_objfile_name, objfile_name (objfile)) != 0)
	{
	  xfree (last_objfile_name);
	  last_objfile_name = xstrdup (objfile_name (objfile));
	  fprintf_unfiltered (gdb_stdlog,
			      "Creating one or more symtabs for objfile %s ...\n",
			      last_objfile_name);
	}
      fprintf_unfiltered (gdb_stdlog,
			  "Created symtab %s for module %s.\n",
			  host_address_to_string (symtab), filename);
    }

  return (symtab);
}


/* Reset all data structures in gdb which may contain references to symbol
   table data.  ADD_FLAGS is a bitmask of enum symfile_add_flags.  */

void
clear_symtab_users (int add_flags)
{
  /* Someday, we should do better than this, by only blowing away
     the things that really need to be blown.  */

  /* Clear the "current" symtab first, because it is no longer valid.
     breakpoint_re_set may try to access the current symtab.  */
  clear_current_source_symtab_and_line ();

  clear_displays ();
  if ((add_flags & SYMFILE_DEFER_BP_RESET) == 0)
    breakpoint_re_set ();
  clear_last_displayed_sal ();
  clear_pc_function_cache ();
  observer_notify_new_objfile (NULL);

  /* Clear globals which might have pointed into a removed objfile.
     FIXME: It's not clear which of these are supposed to persist
     between expressions and which ought to be reset each time.  */
  expression_context_block = NULL;
  innermost_block = NULL;

  /* Varobj may refer to old symbols, perform a cleanup.  */
  varobj_invalidate ();

}

static void
clear_symtab_users_cleanup (void *ignore)
{
  clear_symtab_users (0);
}

/* OVERLAYS:
   The following code implements an abstraction for debugging overlay sections.

   The target model is as follows:
   1) The gnu linker will permit multiple sections to be mapped into the
   same VMA, each with its own unique LMA (or load address).
   2) It is assumed that some runtime mechanism exists for mapping the
   sections, one by one, from the load address into the VMA address.
   3) This code provides a mechanism for gdb to keep track of which
   sections should be considered to be mapped from the VMA to the LMA.
   This information is used for symbol lookup, and memory read/write.
   For instance, if a section has been mapped then its contents
   should be read from the VMA, otherwise from the LMA.

   Two levels of debugger support for overlays are available.  One is
   "manual", in which the debugger relies on the user to tell it which
   overlays are currently mapped.  This level of support is
   implemented entirely in the core debugger, and the information about
   whether a section is mapped is kept in the objfile->obj_section table.

   The second level of support is "automatic", and is only available if
   the target-specific code provides functionality to read the target's
   overlay mapping table, and translate its contents for the debugger
   (by updating the mapped state information in the obj_section tables).

   The interface is as follows:
   User commands:
   overlay map <name>   -- tell gdb to consider this section mapped
   overlay unmap <name> -- tell gdb to consider this section unmapped
   overlay list         -- list the sections that GDB thinks are mapped
   overlay read-target  -- get the target's state of what's mapped
   overlay off/manual/auto -- set overlay debugging state
   Functional interface:
   find_pc_mapped_section(pc):    if the pc is in the range of a mapped
   section, return that section.
   find_pc_overlay(pc):       find any overlay section that contains
   the pc, either in its VMA or its LMA
   section_is_mapped(sect):       true if overlay is marked as mapped
   section_is_overlay(sect):      true if section's VMA != LMA
   pc_in_mapped_range(pc,sec):    true if pc belongs to section's VMA
   pc_in_unmapped_range(...):     true if pc belongs to section's LMA
   sections_overlap(sec1, sec2):  true if mapped sec1 and sec2 ranges overlap
   overlay_mapped_address(...):   map an address from section's LMA to VMA
   overlay_unmapped_address(...): map an address from section's VMA to LMA
   symbol_overlayed_address(...): Return a "current" address for symbol:
   either in VMA or LMA depending on whether
   the symbol's section is currently mapped.  */

/* Overlay debugging state: */

enum overlay_debugging_state overlay_debugging = ovly_off;
int overlay_cache_invalid = 0;	/* True if need to refresh mapped state.  */

/* Function: section_is_overlay (SECTION)
   Returns true if SECTION has VMA not equal to LMA, ie.
   SECTION is loaded at an address different from where it will "run".  */

int
section_is_overlay (struct obj_section *section)
{
  if (overlay_debugging && section)
    {
      bfd *abfd = section->objfile->obfd;
      asection *bfd_section = section->the_bfd_section;

      if (bfd_section_lma (abfd, bfd_section) != 0
	  && bfd_section_lma (abfd, bfd_section)
	     != bfd_section_vma (abfd, bfd_section))
	return 1;
    }

  return 0;
}

/* Function: overlay_invalidate_all (void)
   Invalidate the mapped state of all overlay sections (mark it as stale).  */

static void
overlay_invalidate_all (void)
{
  struct objfile *objfile;
  struct obj_section *sect;

  ALL_OBJSECTIONS (objfile, sect)
    if (section_is_overlay (sect))
      sect->ovly_mapped = -1;
}

/* Function: section_is_mapped (SECTION)
   Returns true if section is an overlay, and is currently mapped.

   Access to the ovly_mapped flag is restricted to this function, so
   that we can do automatic update.  If the global flag
   OVERLAY_CACHE_INVALID is set (by wait_for_inferior), then call
   overlay_invalidate_all.  If the mapped state of the particular
   section is stale, then call TARGET_OVERLAY_UPDATE to refresh it.  */

int
section_is_mapped (struct obj_section *osect)
{
  struct gdbarch *gdbarch;

  if (osect == 0 || !section_is_overlay (osect))
    return 0;

  switch (overlay_debugging)
    {
    default:
    case ovly_off:
      return 0;			/* overlay debugging off */
    case ovly_auto:		/* overlay debugging automatic */
      /* Unles there is a gdbarch_overlay_update function,
         there's really nothing useful to do here (can't really go auto).  */
      gdbarch = get_objfile_arch (osect->objfile);
      if (gdbarch_overlay_update_p (gdbarch))
	{
	  if (overlay_cache_invalid)
	    {
	      overlay_invalidate_all ();
	      overlay_cache_invalid = 0;
	    }
	  if (osect->ovly_mapped == -1)
	    gdbarch_overlay_update (gdbarch, osect);
	}
      /* fall thru to manual case */
    case ovly_on:		/* overlay debugging manual */
      return osect->ovly_mapped == 1;
    }
}

/* Function: pc_in_unmapped_range
   If PC falls into the lma range of SECTION, return true, else false.  */

CORE_ADDR
pc_in_unmapped_range (CORE_ADDR pc, struct obj_section *section)
{
  if (section_is_overlay (section))
    {
      bfd *abfd = section->objfile->obfd;
      asection *bfd_section = section->the_bfd_section;

      /* We assume the LMA is relocated by the same offset as the VMA.  */
      bfd_vma size = bfd_get_section_size (bfd_section);
      CORE_ADDR offset = obj_section_offset (section);

      if (bfd_get_section_lma (abfd, bfd_section) + offset <= pc
	  && pc < bfd_get_section_lma (abfd, bfd_section) + offset + size)
	return 1;
    }

  return 0;
}

/* Function: pc_in_mapped_range
   If PC falls into the vma range of SECTION, return true, else false.  */

CORE_ADDR
pc_in_mapped_range (CORE_ADDR pc, struct obj_section *section)
{
  if (section_is_overlay (section))
    {
      if (obj_section_addr (section) <= pc
	  && pc < obj_section_endaddr (section))
	return 1;
    }

  return 0;
}

/* Return true if the mapped ranges of sections A and B overlap, false
   otherwise.  */

static int
sections_overlap (struct obj_section *a, struct obj_section *b)
{
  CORE_ADDR a_start = obj_section_addr (a);
  CORE_ADDR a_end = obj_section_endaddr (a);
  CORE_ADDR b_start = obj_section_addr (b);
  CORE_ADDR b_end = obj_section_endaddr (b);

  return (a_start < b_end && b_start < a_end);
}

/* Function: overlay_unmapped_address (PC, SECTION)
   Returns the address corresponding to PC in the unmapped (load) range.
   May be the same as PC.  */

CORE_ADDR
overlay_unmapped_address (CORE_ADDR pc, struct obj_section *section)
{
  if (section_is_overlay (section) && pc_in_mapped_range (pc, section))
    {
      bfd *abfd = section->objfile->obfd;
      asection *bfd_section = section->the_bfd_section;

      return pc + bfd_section_lma (abfd, bfd_section)
		- bfd_section_vma (abfd, bfd_section);
    }

  return pc;
}

/* Function: overlay_mapped_address (PC, SECTION)
   Returns the address corresponding to PC in the mapped (runtime) range.
   May be the same as PC.  */

CORE_ADDR
overlay_mapped_address (CORE_ADDR pc, struct obj_section *section)
{
  if (section_is_overlay (section) && pc_in_unmapped_range (pc, section))
    {
      bfd *abfd = section->objfile->obfd;
      asection *bfd_section = section->the_bfd_section;

      return pc + bfd_section_vma (abfd, bfd_section)
		- bfd_section_lma (abfd, bfd_section);
    }

  return pc;
}

/* Function: symbol_overlayed_address
   Return one of two addresses (relative to the VMA or to the LMA),
   depending on whether the section is mapped or not.  */

CORE_ADDR
symbol_overlayed_address (CORE_ADDR address, struct obj_section *section)
{
  if (overlay_debugging)
    {
      /* If the symbol has no section, just return its regular address.  */
      if (section == 0)
	return address;
      /* If the symbol's section is not an overlay, just return its
	 address.  */
      if (!section_is_overlay (section))
	return address;
      /* If the symbol's section is mapped, just return its address.  */
      if (section_is_mapped (section))
	return address;
      /*
       * HOWEVER: if the symbol is in an overlay section which is NOT mapped,
       * then return its LOADED address rather than its vma address!!
       */
      return overlay_unmapped_address (address, section);
    }
  return address;
}

/* Function: find_pc_overlay (PC)
   Return the best-match overlay section for PC:
   If PC matches a mapped overlay section's VMA, return that section.
   Else if PC matches an unmapped section's VMA, return that section.
   Else if PC matches an unmapped section's LMA, return that section.  */

struct obj_section *
find_pc_overlay (CORE_ADDR pc)
{
  struct objfile *objfile;
  struct obj_section *osect, *best_match = NULL;

  if (overlay_debugging)
    ALL_OBJSECTIONS (objfile, osect)
      if (section_is_overlay (osect))
      {
	if (pc_in_mapped_range (pc, osect))
	  {
	    if (section_is_mapped (osect))
	      return osect;
	    else
	      best_match = osect;
	  }
	else if (pc_in_unmapped_range (pc, osect))
	  best_match = osect;
      }
  return best_match;
}

/* Function: find_pc_mapped_section (PC)
   If PC falls into the VMA address range of an overlay section that is
   currently marked as MAPPED, return that section.  Else return NULL.  */

struct obj_section *
find_pc_mapped_section (CORE_ADDR pc)
{
  struct objfile *objfile;
  struct obj_section *osect;

  if (overlay_debugging)
    ALL_OBJSECTIONS (objfile, osect)
      if (pc_in_mapped_range (pc, osect) && section_is_mapped (osect))
	return osect;

  return NULL;
}

/* Function: list_overlays_command
   Print a list of mapped sections and their PC ranges.  */

static void
list_overlays_command (char *args, int from_tty)
{
  int nmapped = 0;
  struct objfile *objfile;
  struct obj_section *osect;

  if (overlay_debugging)
    ALL_OBJSECTIONS (objfile, osect)
      if (section_is_mapped (osect))
      {
	struct gdbarch *gdbarch = get_objfile_arch (objfile);
	const char *name;
	bfd_vma lma, vma;
	int size;

	vma = bfd_section_vma (objfile->obfd, osect->the_bfd_section);
	lma = bfd_section_lma (objfile->obfd, osect->the_bfd_section);
	size = bfd_get_section_size (osect->the_bfd_section);
	name = bfd_section_name (objfile->obfd, osect->the_bfd_section);

	printf_filtered ("Section %s, loaded at ", name);
	fputs_filtered (paddress (gdbarch, lma), gdb_stdout);
	puts_filtered (" - ");
	fputs_filtered (paddress (gdbarch, lma + size), gdb_stdout);
	printf_filtered (", mapped at ");
	fputs_filtered (paddress (gdbarch, vma), gdb_stdout);
	puts_filtered (" - ");
	fputs_filtered (paddress (gdbarch, vma + size), gdb_stdout);
	puts_filtered ("\n");

	nmapped++;
      }
  if (nmapped == 0)
    printf_filtered (_("No sections are mapped.\n"));
}

/* Function: map_overlay_command
   Mark the named section as mapped (ie. residing at its VMA address).  */

static void
map_overlay_command (char *args, int from_tty)
{
  struct objfile *objfile, *objfile2;
  struct obj_section *sec, *sec2;

  if (!overlay_debugging)
    error (_("Overlay debugging not enabled.  Use "
	     "either the 'overlay auto' or\n"
	     "the 'overlay manual' command."));

  if (args == 0 || *args == 0)
    error (_("Argument required: name of an overlay section"));

  /* First, find a section matching the user supplied argument.  */
  ALL_OBJSECTIONS (objfile, sec)
    if (!strcmp (bfd_section_name (objfile->obfd, sec->the_bfd_section), args))
    {
      /* Now, check to see if the section is an overlay.  */
      if (!section_is_overlay (sec))
	continue;		/* not an overlay section */

      /* Mark the overlay as "mapped".  */
      sec->ovly_mapped = 1;

      /* Next, make a pass and unmap any sections that are
         overlapped by this new section: */
      ALL_OBJSECTIONS (objfile2, sec2)
	if (sec2->ovly_mapped && sec != sec2 && sections_overlap (sec, sec2))
	{
	  if (info_verbose)
	    printf_unfiltered (_("Note: section %s unmapped by overlap\n"),
			     bfd_section_name (objfile->obfd,
					       sec2->the_bfd_section));
	  sec2->ovly_mapped = 0;	/* sec2 overlaps sec: unmap sec2.  */
	}
      return;
    }
  error (_("No overlay section called %s"), args);
}

/* Function: unmap_overlay_command
   Mark the overlay section as unmapped
   (ie. resident in its LMA address range, rather than the VMA range).  */

static void
unmap_overlay_command (char *args, int from_tty)
{
  struct objfile *objfile;
  struct obj_section *sec;

  if (!overlay_debugging)
    error (_("Overlay debugging not enabled.  "
	     "Use either the 'overlay auto' or\n"
	     "the 'overlay manual' command."));

  if (args == 0 || *args == 0)
    error (_("Argument required: name of an overlay section"));

  /* First, find a section matching the user supplied argument.  */
  ALL_OBJSECTIONS (objfile, sec)
    if (!strcmp (bfd_section_name (objfile->obfd, sec->the_bfd_section), args))
    {
      if (!sec->ovly_mapped)
	error (_("Section %s is not mapped"), args);
      sec->ovly_mapped = 0;
      return;
    }
  error (_("No overlay section called %s"), args);
}

/* Function: overlay_auto_command
   A utility command to turn on overlay debugging.
   Possibly this should be done via a set/show command.  */

static void
overlay_auto_command (char *args, int from_tty)
{
  overlay_debugging = ovly_auto;
  enable_overlay_breakpoints ();
  if (info_verbose)
    printf_unfiltered (_("Automatic overlay debugging enabled."));
}

/* Function: overlay_manual_command
   A utility command to turn on overlay debugging.
   Possibly this should be done via a set/show command.  */

static void
overlay_manual_command (char *args, int from_tty)
{
  overlay_debugging = ovly_on;
  disable_overlay_breakpoints ();
  if (info_verbose)
    printf_unfiltered (_("Overlay debugging enabled."));
}

/* Function: overlay_off_command
   A utility command to turn on overlay debugging.
   Possibly this should be done via a set/show command.  */

static void
overlay_off_command (char *args, int from_tty)
{
  overlay_debugging = ovly_off;
  disable_overlay_breakpoints ();
  if (info_verbose)
    printf_unfiltered (_("Overlay debugging disabled."));
}

static void
overlay_load_command (char *args, int from_tty)
{
  struct gdbarch *gdbarch = get_current_arch ();

  if (gdbarch_overlay_update_p (gdbarch))
    gdbarch_overlay_update (gdbarch, NULL);
  else
    error (_("This target does not know how to read its overlay state."));
}

/* Function: overlay_command
   A place-holder for a mis-typed command.  */

/* Command list chain containing all defined "overlay" subcommands.  */
static struct cmd_list_element *overlaylist;

static void
overlay_command (char *args, int from_tty)
{
  printf_unfiltered
    ("\"overlay\" must be followed by the name of an overlay command.\n");
  help_list (overlaylist, "overlay ", -1, gdb_stdout);
}

/* Target Overlays for the "Simplest" overlay manager:

   This is GDB's default target overlay layer.  It works with the
   minimal overlay manager supplied as an example by Cygnus.  The
   entry point is via a function pointer "gdbarch_overlay_update",
   so targets that use a different runtime overlay manager can
   substitute their own overlay_update function and take over the
   function pointer.

   The overlay_update function pokes around in the target's data structures
   to see what overlays are mapped, and updates GDB's overlay mapping with
   this information.

   In this simple implementation, the target data structures are as follows:
   unsigned _novlys;            /# number of overlay sections #/
   unsigned _ovly_table[_novlys][4] = {
   {VMA, SIZE, LMA, MAPPED},    /# one entry per overlay section #/
   {..., ...,  ..., ...},
   }
   unsigned _novly_regions;     /# number of overlay regions #/
   unsigned _ovly_region_table[_novly_regions][3] = {
   {VMA, SIZE, MAPPED_TO_LMA},  /# one entry per overlay region #/
   {..., ...,  ...},
   }
   These functions will attempt to update GDB's mappedness state in the
   symbol section table, based on the target's mappedness state.

   To do this, we keep a cached copy of the target's _ovly_table, and
   attempt to detect when the cached copy is invalidated.  The main
   entry point is "simple_overlay_update(SECT), which looks up SECT in
   the cached table and re-reads only the entry for that section from
   the target (whenever possible).  */

/* Cached, dynamically allocated copies of the target data structures: */
static unsigned (*cache_ovly_table)[4] = 0;
static unsigned cache_novlys = 0;
static CORE_ADDR cache_ovly_table_base = 0;
enum ovly_index
  {
    VMA, SIZE, LMA, MAPPED
  };

/* Throw away the cached copy of _ovly_table.  */

static void
simple_free_overlay_table (void)
{
  if (cache_ovly_table)
    xfree (cache_ovly_table);
  cache_novlys = 0;
  cache_ovly_table = NULL;
  cache_ovly_table_base = 0;
}

/* Read an array of ints of size SIZE from the target into a local buffer.
   Convert to host order.  int LEN is number of ints.  */

static void
read_target_long_array (CORE_ADDR memaddr, unsigned int *myaddr,
			int len, int size, enum bfd_endian byte_order)
{
  /* FIXME (alloca): Not safe if array is very large.  */
  gdb_byte *buf = alloca (len * size);
  int i;

  read_memory (memaddr, buf, len * size);
  for (i = 0; i < len; i++)
    myaddr[i] = extract_unsigned_integer (size * i + buf, size, byte_order);
}

/* Find and grab a copy of the target _ovly_table
   (and _novlys, which is needed for the table's size).  */

static int
simple_read_overlay_table (void)
{
  struct minimal_symbol *novlys_msym;
  struct bound_minimal_symbol ovly_table_msym;
  struct gdbarch *gdbarch;
  int word_size;
  enum bfd_endian byte_order;

  simple_free_overlay_table ();
  novlys_msym = lookup_minimal_symbol ("_novlys", NULL, NULL);
  if (! novlys_msym)
    {
      error (_("Error reading inferior's overlay table: "
             "couldn't find `_novlys' variable\n"
             "in inferior.  Use `overlay manual' mode."));
      return 0;
    }

  ovly_table_msym = lookup_bound_minimal_symbol ("_ovly_table");
  if (! ovly_table_msym.minsym)
    {
      error (_("Error reading inferior's overlay table: couldn't find "
             "`_ovly_table' array\n"
             "in inferior.  Use `overlay manual' mode."));
      return 0;
    }

  gdbarch = get_objfile_arch (ovly_table_msym.objfile);
  word_size = gdbarch_long_bit (gdbarch) / TARGET_CHAR_BIT;
  byte_order = gdbarch_byte_order (gdbarch);

  cache_novlys = read_memory_integer (SYMBOL_VALUE_ADDRESS (novlys_msym),
				      4, byte_order);
  cache_ovly_table
    = (void *) xmalloc (cache_novlys * sizeof (*cache_ovly_table));
  cache_ovly_table_base = SYMBOL_VALUE_ADDRESS (ovly_table_msym.minsym);
  read_target_long_array (cache_ovly_table_base,
                          (unsigned int *) cache_ovly_table,
                          cache_novlys * 4, word_size, byte_order);

  return 1;			/* SUCCESS */
}

/* Function: simple_overlay_update_1
   A helper function for simple_overlay_update.  Assuming a cached copy
   of _ovly_table exists, look through it to find an entry whose vma,
   lma and size match those of OSECT.  Re-read the entry and make sure
   it still matches OSECT (else the table may no longer be valid).
   Set OSECT's mapped state to match the entry.  Return: 1 for
   success, 0 for failure.  */

static int
simple_overlay_update_1 (struct obj_section *osect)
{
  int i, size;
  bfd *obfd = osect->objfile->obfd;
  asection *bsect = osect->the_bfd_section;
  struct gdbarch *gdbarch = get_objfile_arch (osect->objfile);
  int word_size = gdbarch_long_bit (gdbarch) / TARGET_CHAR_BIT;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  size = bfd_get_section_size (osect->the_bfd_section);
  for (i = 0; i < cache_novlys; i++)
    if (cache_ovly_table[i][VMA] == bfd_section_vma (obfd, bsect)
	&& cache_ovly_table[i][LMA] == bfd_section_lma (obfd, bsect)
	/* && cache_ovly_table[i][SIZE] == size */ )
      {
	read_target_long_array (cache_ovly_table_base + i * word_size,
				(unsigned int *) cache_ovly_table[i],
				4, word_size, byte_order);
	if (cache_ovly_table[i][VMA] == bfd_section_vma (obfd, bsect)
	    && cache_ovly_table[i][LMA] == bfd_section_lma (obfd, bsect)
	    /* && cache_ovly_table[i][SIZE] == size */ )
	  {
	    osect->ovly_mapped = cache_ovly_table[i][MAPPED];
	    return 1;
	  }
	else	/* Warning!  Warning!  Target's ovly table has changed!  */
	  return 0;
      }
  return 0;
}

/* Function: simple_overlay_update
   If OSECT is NULL, then update all sections' mapped state
   (after re-reading the entire target _ovly_table).
   If OSECT is non-NULL, then try to find a matching entry in the
   cached ovly_table and update only OSECT's mapped state.
   If a cached entry can't be found or the cache isn't valid, then
   re-read the entire cache, and go ahead and update all sections.  */

void
simple_overlay_update (struct obj_section *osect)
{
  struct objfile *objfile;

  /* Were we given an osect to look up?  NULL means do all of them.  */
  if (osect)
    /* Have we got a cached copy of the target's overlay table?  */
    if (cache_ovly_table != NULL)
      {
	/* Does its cached location match what's currently in the
	   symtab?  */
	struct minimal_symbol *minsym
	  = lookup_minimal_symbol ("_ovly_table", NULL, NULL);

	if (minsym == NULL)
	  error (_("Error reading inferior's overlay table: couldn't "
		   "find `_ovly_table' array\n"
		   "in inferior.  Use `overlay manual' mode."));
	
	if (cache_ovly_table_base == SYMBOL_VALUE_ADDRESS (minsym))
	  /* Then go ahead and try to look up this single section in
	     the cache.  */
	  if (simple_overlay_update_1 (osect))
	    /* Found it!  We're done.  */
	    return;
      }

  /* Cached table no good: need to read the entire table anew.
     Or else we want all the sections, in which case it's actually
     more efficient to read the whole table in one block anyway.  */

  if (! simple_read_overlay_table ())
    return;

  /* Now may as well update all sections, even if only one was requested.  */
  ALL_OBJSECTIONS (objfile, osect)
    if (section_is_overlay (osect))
    {
      int i, size;
      bfd *obfd = osect->objfile->obfd;
      asection *bsect = osect->the_bfd_section;

      size = bfd_get_section_size (bsect);
      for (i = 0; i < cache_novlys; i++)
	if (cache_ovly_table[i][VMA] == bfd_section_vma (obfd, bsect)
	    && cache_ovly_table[i][LMA] == bfd_section_lma (obfd, bsect)
	    /* && cache_ovly_table[i][SIZE] == size */ )
	  { /* obj_section matches i'th entry in ovly_table.  */
	    osect->ovly_mapped = cache_ovly_table[i][MAPPED];
	    break;		/* finished with inner for loop: break out.  */
	  }
    }
}

/* Set the output sections and output offsets for section SECTP in
   ABFD.  The relocation code in BFD will read these offsets, so we
   need to be sure they're initialized.  We map each section to itself,
   with no offset; this means that SECTP->vma will be honored.  */

static void
symfile_dummy_outputs (bfd *abfd, asection *sectp, void *dummy)
{
  sectp->output_section = sectp;
  sectp->output_offset = 0;
}

/* Default implementation for sym_relocate.  */

bfd_byte *
default_symfile_relocate (struct objfile *objfile, asection *sectp,
                          bfd_byte *buf)
{
  /* Use sectp->owner instead of objfile->obfd.  sectp may point to a
     DWO file.  */
  bfd *abfd = sectp->owner;

  /* We're only interested in sections with relocation
     information.  */
  if ((sectp->flags & SEC_RELOC) == 0)
    return NULL;

  /* We will handle section offsets properly elsewhere, so relocate as if
     all sections begin at 0.  */
  bfd_map_over_sections (abfd, symfile_dummy_outputs, NULL);

  return bfd_simple_get_relocated_section_contents (abfd, sectp, buf, NULL);
}

/* Relocate the contents of a debug section SECTP in ABFD.  The
   contents are stored in BUF if it is non-NULL, or returned in a
   malloc'd buffer otherwise.

   For some platforms and debug info formats, shared libraries contain
   relocations against the debug sections (particularly for DWARF-2;
   one affected platform is PowerPC GNU/Linux, although it depends on
   the version of the linker in use).  Also, ELF object files naturally
   have unresolved relocations for their debug sections.  We need to apply
   the relocations in order to get the locations of symbols correct.
   Another example that may require relocation processing, is the
   DWARF-2 .eh_frame section in .o files, although it isn't strictly a
   debug section.  */

bfd_byte *
symfile_relocate_debug_section (struct objfile *objfile,
                                asection *sectp, bfd_byte *buf)
{
  gdb_assert (objfile->sf->sym_relocate);

  return (*objfile->sf->sym_relocate) (objfile, sectp, buf);
}

struct symfile_segment_data *
get_symfile_segment_data (bfd *abfd)
{
  const struct sym_fns *sf = find_sym_fns (abfd);

  if (sf == NULL)
    return NULL;

  return sf->sym_segments (abfd);
}

void
free_symfile_segment_data (struct symfile_segment_data *data)
{
  xfree (data->segment_bases);
  xfree (data->segment_sizes);
  xfree (data->segment_info);
  xfree (data);
}

/* Given:
   - DATA, containing segment addresses from the object file ABFD, and
     the mapping from ABFD's sections onto the segments that own them,
     and
   - SEGMENT_BASES[0 .. NUM_SEGMENT_BASES - 1], holding the actual
     segment addresses reported by the target,
   store the appropriate offsets for each section in OFFSETS.

   If there are fewer entries in SEGMENT_BASES than there are segments
   in DATA, then apply SEGMENT_BASES' last entry to all the segments.

   If there are more entries, then ignore the extra.  The target may
   not be able to distinguish between an empty data segment and a
   missing data segment; a missing text segment is less plausible.  */

int
symfile_map_offsets_to_segments (bfd *abfd,
				 const struct symfile_segment_data *data,
				 struct section_offsets *offsets,
				 int num_segment_bases,
				 const CORE_ADDR *segment_bases)
{
  int i;
  asection *sect;

  /* It doesn't make sense to call this function unless you have some
     segment base addresses.  */
  gdb_assert (num_segment_bases > 0);

  /* If we do not have segment mappings for the object file, we
     can not relocate it by segments.  */
  gdb_assert (data != NULL);
  gdb_assert (data->num_segments > 0);

  for (i = 0, sect = abfd->sections; sect != NULL; i++, sect = sect->next)
    {
      int which = data->segment_info[i];

      gdb_assert (0 <= which && which <= data->num_segments);

      /* Don't bother computing offsets for sections that aren't
         loaded as part of any segment.  */
      if (! which)
        continue;

      /* Use the last SEGMENT_BASES entry as the address of any extra
         segments mentioned in DATA->segment_info.  */
      if (which > num_segment_bases)
        which = num_segment_bases;

      offsets->offsets[i] = (segment_bases[which - 1]
                             - data->segment_bases[which - 1]);
    }

  return 1;
}

static void
symfile_find_segment_sections (struct objfile *objfile)
{
  bfd *abfd = objfile->obfd;
  int i;
  asection *sect;
  struct symfile_segment_data *data;

  data = get_symfile_segment_data (objfile->obfd);
  if (data == NULL)
    return;

  if (data->num_segments != 1 && data->num_segments != 2)
    {
      free_symfile_segment_data (data);
      return;
    }

  for (i = 0, sect = abfd->sections; sect != NULL; i++, sect = sect->next)
    {
      int which = data->segment_info[i];

      if (which == 1)
	{
	  if (objfile->sect_index_text == -1)
	    objfile->sect_index_text = sect->index;

	  if (objfile->sect_index_rodata == -1)
	    objfile->sect_index_rodata = sect->index;
	}
      else if (which == 2)
	{
	  if (objfile->sect_index_data == -1)
	    objfile->sect_index_data = sect->index;

	  if (objfile->sect_index_bss == -1)
	    objfile->sect_index_bss = sect->index;
	}
    }

  free_symfile_segment_data (data);
}

void
_initialize_symfile (void)
{
  struct cmd_list_element *c;

  c = add_cmd ("symbol-file", class_files, symbol_file_command, _("\
Load symbol table from executable file FILE.\n\
The `file' command can also load symbol tables, as well as setting the file\n\
to execute."), &cmdlist);
  set_cmd_completer (c, filename_completer);

  c = add_cmd ("add-symbol-file", class_files, add_symbol_file_command, _("\
Load symbols from FILE, assuming FILE has been dynamically loaded.\n\
Usage: add-symbol-file FILE ADDR [-s <SECT> <SECT_ADDR> -s <SECT> <SECT_ADDR>\
 ...]\nADDR is the starting address of the file's text.\n\
The optional arguments are section-name section-address pairs and\n\
should be specified if the data and bss segments are not contiguous\n\
with the text.  SECT is a section name to be loaded at SECT_ADDR."),
	       &cmdlist);
  set_cmd_completer (c, filename_completer);

  c = add_cmd ("load", class_files, load_command, _("\
Dynamically load FILE into the running program, and record its symbols\n\
for access from GDB.\n\
A load OFFSET may also be given."), &cmdlist);
  set_cmd_completer (c, filename_completer);

  add_prefix_cmd ("overlay", class_support, overlay_command,
		  _("Commands for debugging overlays."), &overlaylist,
		  "overlay ", 0, &cmdlist);

  add_com_alias ("ovly", "overlay", class_alias, 1);
  add_com_alias ("ov", "overlay", class_alias, 1);

  add_cmd ("map-overlay", class_support, map_overlay_command,
	   _("Assert that an overlay section is mapped."), &overlaylist);

  add_cmd ("unmap-overlay", class_support, unmap_overlay_command,
	   _("Assert that an overlay section is unmapped."), &overlaylist);

  add_cmd ("list-overlays", class_support, list_overlays_command,
	   _("List mappings of overlay sections."), &overlaylist);

  add_cmd ("manual", class_support, overlay_manual_command,
	   _("Enable overlay debugging."), &overlaylist);
  add_cmd ("off", class_support, overlay_off_command,
	   _("Disable overlay debugging."), &overlaylist);
  add_cmd ("auto", class_support, overlay_auto_command,
	   _("Enable automatic overlay debugging."), &overlaylist);
  add_cmd ("load-target", class_support, overlay_load_command,
	   _("Read the overlay mapping state from the target."), &overlaylist);

  /* Filename extension to source language lookup table: */
  init_filename_language_table ();
  add_setshow_string_noescape_cmd ("extension-language", class_files,
				   &ext_args, _("\
Set mapping between filename extension and source language."), _("\
Show mapping between filename extension and source language."), _("\
Usage: set extension-language .foo bar"),
				   set_ext_lang_command,
				   show_ext_args,
				   &setlist, &showlist);

  add_info ("extensions", info_ext_lang_command,
	    _("All filename extensions associated with a source language."));

  add_setshow_optional_filename_cmd ("debug-file-directory", class_support,
				     &debug_file_directory, _("\
Set the directories where separate debug symbols are searched for."), _("\
Show the directories where separate debug symbols are searched for."), _("\
Separate debug symbols are first searched for in the same\n\
directory as the binary, then in the `" DEBUG_SUBDIRECTORY "' subdirectory,\n\
and lastly at the path of the directory of the binary with\n\
each global debug-file-directory component prepended."),
				     NULL,
				     show_debug_file_directory,
				     &setlist, &showlist);
}
@


1.395
log
@	New option "set debug symfile on".
	* NEWS: Mention "set debug symfile".
	* Makefile.in (SFILES): Add symfile-debug.c.
	(COMMON_OBS): Add symfile-debug.o.
	* elfread.c (elf_symfile_read): Use objfile_set_sym_fns to set the
	objfile's symbol functions.
	* objfiles.h (objfile_set_sym_fns): Declare.
	* symfile-debug.c: New file.
	* symfile.c (syms_from_objfile_1): Use objfile_set_sym_fns to set the
	objfile's symbol functions.
	(reread_symbols): Ditto.
@
text
@a2499 5
	  if (objfile->demangled_names_hash != NULL)
	    {
	      htab_delete (objfile->demangled_names_hash);
	      objfile->demangled_names_hash = NULL;
	    }
@


1.394
log
@	* symfile.h (struct sym_fns): Delete member "sym_flavour".
	All uses updated.
	(add_symtab_fns): Update prototype.
	* symfile.c (sym_fns_ptr): Delete.  Replace with ...
	(registered_sym_fns): ... this.
	(symtab_fns): Update.
	(add_symtab_fns): New arg "flavour".  All callers updated.
	(find_sym_fns): Rewrite to use new sym_fns registry.
@
text
@d943 1
a943 1
  objfile->sf = find_sym_fns (objfile->obfd);
d2533 1
a2533 1
	  objfile->sf = find_sym_fns (objfile->obfd);
@


1.393
log
@Keep objfile original filename

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Pass down original filename for objfile.
	* coffread.c (coff_symfile_read): Update symbol_file_add_separate call.
	* elfread.c (elf_symfile_read): Likewise.
	* jit.c (jit_object_close_impl): Update allocate_objfile call, no
	longer set ORIGINAL_NAME.
	(jit_bfd_try_read_symtab): Update symbol_file_add_from_bfd call.
	* jv-lang.c (get_dynamics_objfile): Update allocate_objfile call.
	* machoread.c (macho_add_oso_symfile): Add parameter name.  Update
	symbol_file_add_from_bfd call.
	(macho_symfile_read_all_oso): Update two macho_add_oso_symfile calls.
	(macho_check_dsym): Add parameter filenamep.  Change function comment.
	Set *filenamep.
	(macho_symfile_read): New variable dsym_filename.  Update
	macho_check_dsym call.  Use it for symbol_file_add_separate.
	* objfiles.c (allocate_objfile): Add parameter name.  New comment for
	it.  Use it for objfile->original_name.
	(objfile_name): Return OBFD's filename, if available.
	* objfiles.h (allocate_objfile): Add new parameter name.
	* solib.c (solib_read_symbols): Update symbol_file_add_from_bfd call.
	* symfile-mem.c (symbol_file_add_from_memory): Update
	symbol_file_add_from_bfd call.
	* symfile.c (read_symbols): Update symbol_file_add_separate call, new
	comment for it.
	(symbol_file_add_with_addrs): New parameter name, add function comment
	for it.  Remove variable name.  Update allocate_objfile call.
	(symbol_file_add_separate): New parameter name, add function comment
	for it.  Update symbol_file_add_with_addrs call.
	(symbol_file_add_from_bfd): New parameter name.  Update
	symbol_file_add_with_addrs call.
	(symbol_file_add): Update symbol_file_add_from_bfd call.
	(reread_symbols): New variable original_name.  Save
	objfile->original_name by it.
	* symfile.h (symbol_file_add_from_bfd, symbol_file_add_separate): Add
	second parameter.
@
text
@d133 8
a140 2
typedef const struct sym_fns *sym_fns_ptr;
DEF_VEC_P (sym_fns_ptr);
d142 3
a144 1
static VEC (sym_fns_ptr) *symtab_fns = NULL;
d1757 5
a1761 3
/* Link SF into the global symtab_fns list.  Called on startup by the
   _initialize routine in each object file format reader, to register
   information about each format the reader is prepared to handle.  */
d1764 1
a1764 1
add_symtab_fns (const struct sym_fns *sf)
d1766 3
a1768 1
  VEC_safe_push (sym_fns_ptr, symtab_fns, sf);
d1779 1
a1779 1
  const struct sym_fns *sf;
d1788 3
a1790 3
  for (i = 0; VEC_iterate (sym_fns_ptr, symtab_fns, i, sf); ++i)
    if (our_flavour == sf->sym_flavour)
      return sf;
@


1.392
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@d842 8
a849 1
	symbol_file_add_separate (abfd, add_flags, objfile);
d1057 2
d1072 1
a1072 1
symbol_file_add_with_addrs (bfd *abfd, int add_flags,
a1076 1
  const char *name = bfd_get_filename (abfd);
d1098 2
a1099 1
  objfile = allocate_objfile (abfd, flags | (mainline ? OBJF_MAINLINE : 0));
d1172 2
a1173 1
/* Add BFD as a separate debug file for OBJFILE.  */
d1176 2
a1177 1
symbol_file_add_separate (bfd *bfd, int symfile_flags, struct objfile *objfile)
d1190 1
a1190 1
    (bfd, symfile_flags, sap,
d1203 1
a1203 1
symbol_file_add_from_bfd (bfd *abfd, int add_flags,
d1207 2
a1208 1
  return symbol_file_add_with_addrs (abfd, add_flags, addrs, flags, parent);
d1222 1
a1222 1
  objf = symbol_file_add_from_bfd (bfd, add_flags, addrs, flags, NULL);
d2387 1
d2458 3
a2460 1
	  objfile->original_name = bfd_get_filename (objfile->obfd);
d2514 4
@


1.391
log
@Remove solib-sunos.c

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Remove solib-sunos.c.
	* Makefile.in (ALLDEPFILES): Remove solib-sunos.c.
	* config/m68k/obsd.mh (NATDEPFILES): Remove solib-sunos.o.
	* objfiles.c (rt_common_objfile): Remove.
	(free_objfile): Remove rt_common_objfile comparison.
	* objfiles.h (rt_common_objfile): Remove.
	* solib-sunos.c: Remove.
	* symfile.c (reread_symbols): Remove solib-sunos.c comment.
@
text
@d1252 1
a1252 1
		    symfile_objfile->name)
d1283 1
a1283 1
  if (filename_cmp (name, parent_objfile->name) == 0)
d1340 1
a1340 1
		 name, parent_objfile->name);
d1498 1
a1498 1
  dir = xstrdup (objfile->name);
d1515 2
a1516 1
      if (lstat (objfile->name, &st_buf) == 0 && S_ISLNK(st_buf.st_mode))
d1520 1
a1520 1
	  symlink_dir = lrealpath (objfile->name);
d2361 1
a2361 1
	res = stat (objfile->name, &new_statbuf);
d2366 1
a2366 1
			     objfile->name);
d2377 1
a2377 1
			     objfile->name);
d2445 1
a2445 1
	  objfile->name = bfd_get_filename (objfile->obfd);
d2448 1
a2448 1
	    error (_("Can't read symbols from %s: %s."), objfile->name,
d2795 1
a2795 1
	  || strcmp (last_objfile_name, objfile->name) != 0)
d2798 1
a2798 1
	  last_objfile_name = xstrdup (objfile->name);
@


1.390
log
@Mostly code cleanup: Constification.

gdb/
2013-09-19  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Constification.
	* main.c (captured_main): Replace catch_command_errors by
	catch_command_errors_const.  Twice.
	* symfile.c (symbol_file_add_main_1): Make args parameter const.
	(symbol_file_add): Make name parameter const.
	(symbol_file_add_main, symbol_file_add_main_1): Make args parameter const.
	(symfile_bfd_open): Make name parameter const, rename it to cname.  Add
	variable name.  Change their usage accordingly.
	* symfile.h (symbol_file_add, symfile_bfd_open): Make first parameter
	const.
	(symbol_file_add_main): Make args parameter const.
@
text
@a2345 1
      /* solib-sunos.c creates one objfile with obfd.  */
@


1.389
log
@Code cleanup: Move variable.

gdb/
2013-09-13  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup.
	* symfile.c (reread_symbols): Move variable obfd_filename to a more
	inner block.
@
text
@d90 1
a90 1
static void symbol_file_add_main_1 (char *args, int from_tty, int flags);
d1203 2
a1204 2
symbol_file_add (char *name, int add_flags, struct section_addr_info *addrs,
		 int flags)
d1224 1
a1224 1
symbol_file_add_main (char *args, int from_tty)
d1230 1
a1230 1
symbol_file_add_main_1 (char *args, int from_tty, int flags)
d1655 1
a1655 1
symfile_bfd_open (char *name)
d1659 1
a1659 1
  char *absolute_name;
d1662 1
a1662 1
  if (remote_filename_p (name))
d1664 1
a1664 1
      sym_bfd = remote_bfd_open (name, gnutarget);
d1666 1
a1666 1
	error (_("`%s': can't open to read symbols: %s."), name,
d1672 1
a1672 1
	  error (_("`%s': can't read symbols: %s."), name,
d1679 1
a1679 1
  name = tilde_expand (name);	/* Returns 1st new malloc'd copy.  */
@


1.388
log
@2013-09-05  Muhammad Bilal  <mbilal@@codesourcery.com>

	* symfile.c (add_symbol_file_command): Remove trailing
	 whitespaces and blank line after comment.
@
text
@a2374 1
	  char *obfd_filename;
d2428 1
@


1.387
log
@Code cleanup: Change OPF_DISABLE_REALPATH to OPF_RETURN_REALPATH.

gdb/
2013-09-04  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Change OPF_DISABLE_REALPATH to OPF_RETURN_REALPATH.
	* cli/cli-cmds.c (find_and_open_script): Add OPF_RETURN_REALPATH to
	variable search_flags.
	* defs.h (OPF_DISABLE_REALPATH): Rename to ...
	(OPF_RETURN_REALPATH): ... here.
	* dwarf2read.c (try_open_dwop_file): Set OPF_RETURN_REALPATH for flags.
	* exec.c (exec_file_attach): Remove OPF_DISABLE_REALPATH from openp
	call.  Twice.
	* nto-tdep.c (nto_find_and_open_solib): Add OPF_RETURN_REALPATH for
	openp call.
	* solib.c (solib_find): Likewise.  Four times.
	* source.c (openp): Change OPF_DISABLE_REALPATH to OPF_RETURN_REALPATH
	in the function comment and for the realpath_fptr variable.
	(source_full_path_of): Add OPF_RETURN_REALPATH for openp call.
	(find_and_open_source): Likewise.  Twice.
	* symfile.c (symfile_bfd_open): Likewise, also twice.
@
text
@a2235 1
	    
@


1.386
log
@2013-09-04  Muhammad Bilal  <mbilal@@codesourcery.com>
            Pedro Alves  <palves@@redhat.com>

	* symfile.c (add_symbol_file_command): Error out on unknown
        option.  Handle EXPECTING_SEC_ADDR/EXPECTING_SEC_NAME before '-'
        options and collapse into single conditional branch.
2013-09-13  Muhammad Bilal  <mbilal@@codesourcery.com>
            Pedro Alves  <palves@@redhat.com>

	* gdb.base/relocate.exp: Check that invalid options are
	rejected.
@
text
@d1682 1
a1682 1
  desc = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, name,
d1690 2
a1691 2
      desc = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, exename,
		    O_RDONLY | O_BINARY, &absolute_name);
@


1.385
log
@	PR symtab/15885
	* dwarf2read.c (dw2_dump): Print some minimal information indicating
	.gdb_index is in use.
	* symfile.c (reread_symbols): Reset objfile->sf.

	testsuite/
	* gdb.dwarf2/Makefile.in (EXECUTABLES): Add gdb-index.
	(clean): rm -f *.gdb-index *.with-index.
	* gdb.dwarf2/gdb-index.exp: New testcase.
@
text
@d2217 15
d2233 33
a2265 56
	if (argcnt == 1)
	  {
	    /* The second argument is always the text address at which
               to load the program.  */
	    sect_opts[section_index].name = ".text";
	    sect_opts[section_index].value = arg;
	    if (++section_index >= num_sect_opts)
	      {
		num_sect_opts *= 2;
		sect_opts = ((struct sect_opt *)
			     xrealloc (sect_opts,
				       num_sect_opts
				       * sizeof (struct sect_opt)));
	      }
	  }
	else
	  {
	    /* It's an option (starting with '-') or it's an argument
	       to an option.  */

	    if (*arg == '-')
	      {
		if (strcmp (arg, "-readnow") == 0)
		  flags |= OBJF_READNOW;
		else if (strcmp (arg, "-s") == 0)
		  {
		    expecting_sec_name = 1;
		    expecting_sec_addr = 1;
		  }
	      }
	    else
	      {
		if (expecting_sec_name)
		  {
		    sect_opts[section_index].name = arg;
		    expecting_sec_name = 0;
		  }
		else
		  if (expecting_sec_addr)
		    {
		      sect_opts[section_index].value = arg;
		      expecting_sec_addr = 0;
		      if (++section_index >= num_sect_opts)
			{
			  num_sect_opts *= 2;
			  sect_opts = ((struct sect_opt *)
				       xrealloc (sect_opts,
						 num_sect_opts
						 * sizeof (struct sect_opt)));
			}
		    }
		  else
		    error (_("USAGE: add-symbol-file <filename> <textaddress>"
			     " [-readnow] [-s <secname> <addr>]*"));
	      }
	  }
@


1.384
log
@move gdbarch object from objfile to per-BFD

This moves the "gdbarch" field from the objfile into the BFD.

This field's value is derived from the BFD and is immutable over the
lifetime of the BFD.  This makes it a reasonable candidate for pushing
into the per-BFD object.

This is part of the long-term objfile splitting project.  In the long
run I think this patch will make it simpler to moves types from the
objfile to the per-BFD object; but the patch makes sense as a minor
cleanup by itself.

Built and regtested on x86-64 Fedora 18.

	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Use
	get_objfile_arch.
	* elfread.c (elf_rel_plt_read, elf_gnu_ifunc_record_cache)
	(elf_gnu_ifunc_resolve_by_got): Use get_objfile_arch.
	* jit.c (jit_object_close_impl): Update.
	* jv-lang.c (get_dynamics_objfile): Update.
	* linespec.c (add_minsym): Use get_dynamics_objfile.
	* objfiles.c (get_objfile_bfd_data): Initialize 'gdbarch' field.
	(allocate_objfile): Don't initialize 'gdbarch' field.
	(get_objfile_arch): Update.
	* objfiles.h (struct objfile_per_bfd_storage) <gdbarch>: New field,
	moved from...
	(struct objfile) <gdbarch>: ... here.  Remove.
	* stap-probe.c (stap_can_evaluate_probe_arguments): Use
	get_objfile_arch.
	* symfile.c (init_entry_point_info): Use get_objfile_arch.
@
text
@d2507 6
@


1.383
log
@use language of the main symbol

With "dwz -m", "main" appears in both the PU and the importing CU when
running anon-struct.exp.  However, the PU does not have a file name.
So, find_main_filename returns the empty string, making
deduce_language_from_filename return language_unknown.

This patch fixes this problem by changing gdb to use the ordinary
symbol-lookup functions to find "main"'s symbol.  Then, it examines the
symbol's language.

I think this is cleaner than the current approach.  For one thing it
avoids trying to guess the language based on the source file name,
instead deferring to the presumably more reliable debuginfo.

Another possible fix would have been to change how the file name is
found via the "qf" methods.  However, I think the approach given is
preferable for the reason outlined above.

This required a minor test suite change, as now a symtab is expanded
during the search for "main".

Built and regtested (both ways) on x86-64 Fedora 18.

	* symfile.c (set_initial_language): Look up "main" symbol
	and use its language.
	* symtab.c (find_main_filename): Remove.
	* symtab.h (find_main_filename): Remove.

	* gdb.base/maint.exp: Allow zero symtabs to be expanded.
@
text
@d887 1
a887 1
	= gdbarch_convert_from_func_ptr_addr (objfile->gdbarch,
d894 1
a894 1
	= gdbarch_addr_bits_remove (objfile->gdbarch, entry_point);
@


1.382
log
@remove msymbol_objfile

This is another patch in my ongoing series to "split" objfile to share
more read-only data across inferiors.  See

    http://sourceware.org/gdb/wiki/ObjfileSplitting

When symbols are finally shared, there will be no back-link from the
symbol to its containing objfile, because there may be more than one
such objfile.  So, all such back-links must be removed.

One hidden back-link is the msymbol_objfile function.  Since
(eventually) a symbol may appear in more than one objfile, trying to
look up the objfile given just a symbol cannot work.

This patch removes msymbol_objfile in favor of using a bound minimal
symbol.  It introduces a new function to make this conversion simpler
in some spots.

The bonus of this patch is that using msymbol_objfile is slower than
simply looking up the owning objfile in the first place.

Built and regtested on x86-64 Fedora 18.

	* ada-exp.y (write_var_or_type): Use bound_minimal_symbol.
	* ada-lang.c (ada_lookup_simple_minsym): Return
	bound_minimal_symbol.
	* ada-lang.h (ada_lookup_simple_minsym): Update.
	* c-exp.y (variable): Use lookup_bound_minimal_symbol.
	* f-exp.y (variable): Use lookup_bound_minimal_symbol.
	* go-exp.y (variable): Use lookup_bound_minimal_symbol.
	* jv-exp.y (push_expression_name): Use lookup_bound_minimal_symbol.
	* m2-exp.y (variable): Use lookup_bound_minimal_symbol.
	* minsyms.c (msymbol_objfile): Remove.
	(lookup_minimal_symbol_internal): New function, from
	lookup_minimal_symbol.
	(lookup_minimal_symbol): Rewrite using
	lookup_minimal_symbol_internal.
	(lookup_bound_minimal_symbol): New function.
	* minsyms.h (msymbol_objfile): Remove.
	(lookup_bound_minimal_symbol): Declare.
	* p-exp.y (variable): Use lookup_bound_minimal_symbol.
	* parse.c (write_exp_msymbol): Change parameter to a
	bound_minimal_symbol.
	(write_dollar_variable): Use lookup_bound_minimal_symbol.
	* parser-defs.h (write_exp_msymbol): Update.
	* printcmd.c (address_info): Use lookup_bound_minimal_symbol.
	* symfile.c (simple_read_overlay_table): Use
	lookup_bound_minimal_symbol.
	* symtab.c (skip_prologue_sal): Don't use msymbol_objfile.
	(search_symbols): Likewise.
	(print_msymbol_info): Take a bound_minimal_symbol argument.
	(symtab_symbol_info, rbreak_command): Update.
	* symtab.h (struct symbol_search) <msymbol>: Change type
	to bound_minimal_symbol.
	* valops.c (find_function_in_inferior): Use
	lookup_bound_minimal_symbol.
	* value.c (value_fn_field): Use lookup_bound_minimal_symbol.
@
text
@d1615 2
a1616 1
      const char *filename;
d1618 2
a1619 3
      filename = find_main_filename ();
      if (filename != NULL)
	lang = deduce_language_from_filename (filename);
@


1.381
log
@	* target.h (struct target_section): Delete member bfd.
	All users updated to use the_bfd_section->owner instead.
	* exec.c (add_to_section_table): Assert bfd is expected value.
	Remove initialization of target_section.bfd.
	(remove_target_sections): Update.
	(section_table_available_memory): Update.
	(section_table_xfer_memory_partial): Update.
	(print_section_info): Update.
	(exec_set_section_address): Update.
	* record-full.c (record_full_core_xfer_partial): Update.
	* solib-svr4.c (svr4_relocate_section_addresses): Update.
	* solib-target.c (solib_target_relocate_section_addresses): Update.
	* symfile.c (build_section_addr_info_from_section_table): Update.
	* target.c (memory_xfer_live_readonly_partial): Update.
	(memory_xfer_partial_1): Update.
@
text
@d3402 2
a3403 1
  struct minimal_symbol *novlys_msym, *ovly_table_msym;
d3418 2
a3419 2
  ovly_table_msym = lookup_minimal_symbol ("_ovly_table", NULL, NULL);
  if (! ovly_table_msym)
d3427 1
a3427 1
  gdbarch = get_objfile_arch (msymbol_objfile (ovly_table_msym));
d3435 1
a3435 1
  cache_ovly_table_base = SYMBOL_VALUE_ADDRESS (ovly_table_msym);
@


1.380
log
@	* symfile.c (symfile_bfd_open): Delete unnecessary declaration.
	(get_section_index): Ditto.
@
text
@d232 4
a235 2
      if (bfd_get_section_flags (stp->bfd,
				 stp->the_bfd_section) & (SEC_ALLOC | SEC_LOAD)
d239 2
a240 4
	  sap->other[oidx].name
	    = xstrdup (bfd_section_name (stp->bfd, stp->the_bfd_section));
	  sap->other[oidx].sectindex
	    = gdb_bfd_section_index (stp->bfd, stp->the_bfd_section);
@


1.379
log
@fix one bug in symfile.c

find_separate_debug_file could leak a cleanup along some return paths.

	* symfile.c (find_separate_debug_file): Call do_cleanups
	along all return paths.
@
text
@a93 4
bfd *symfile_bfd_open (char *);

int get_section_index (struct objfile *, char *);

@


1.378
log
@some cleanup checker fixes

Fix some bugs pointed out by the cleanup checker.  This one just fixes
some simple CLI reports, where CLI commands know that their caller
will do cleanups.  This an older style with few instances, so it is
simpler to fix them up than to teach the checker about it.

	* cli/cli-cmds.c (cd_command, alias_command): Call do_cleanups.
	* cli/cli-dump.c (restore_binary_file): Call do_cleanups.
	* interps.c (interpreter_exec_cmd): Call do_cleanups.
	* source.c (show_substitute_path_command): Call do_cleanups.
	(unset_substitute_path_command, set_substitute_path_command):
	Likewise.
	* symfile.c (load_command): Call do_cleanups.
@
text
@d1431 4
a1434 1
	return debugfile;
d1449 4
a1452 1
	    return debugfile;
@


1.377
log
@	* symfile.c (syms_from_objfile_1): Delete args offsets, num_offsets.
	All callers updated.
	(syms_from_objfile): Ditto.  Make static.
	(symbol_file_add_with_addrs): Renamed from
	symbol_file_add_with_addrs_or_offsets.  Delete args offsets,
	num_offsets.  All callers updated.
	* symfile.h (syms_from_objfile): Delete.
@
text
@d1775 2
d1826 2
@


1.376
log
@	* symfile.c (decrement_reading_symtab): Add assert.
	(increment_reading_symtab): Ditto.
@
text
@a917 11
   If ADDRS is non-zero, OFFSETS must be zero.

   OFFSETS is a table of section offsets already in the right
   format-specific representation.  NUM_OFFSETS is the number of
   elements present in OFFSETS->offsets.  If OFFSETS is non-zero, we
   assume this is the proper table the call to sym_offsets described
   above would produce.  Instead of calling sym_offsets, we just dump
   it right into objfile->section_offsets.  (When we're re-reading
   symbols from an objfile, we don't have the original load address
   list any more; all we have is the section offset table.)  If
   OFFSETS is non-zero, ADDRS must be zero.
a925 2
		     const struct section_offsets *offsets,
		     int num_offsets,
a931 2
  gdb_assert (! (addrs && offsets));

d952 2
a953 2
  /* If ADDRS and OFFSETS are both NULL, put together a dummy address
     list.  We now establish the convention that an addr of zero means
d955 1
a955 1
  if (! addrs && ! offsets)
a961 2
  /* Now either addrs or offsets is non-zero.  */

d990 1
a990 1
  if (addrs && addrs->num_sections > 0)
d1000 1
a1000 15
  if (addrs)
    (*objfile->sf->sym_offsets) (objfile, addrs);
  else
    {
      size_t size = SIZEOF_N_SECTION_OFFSETS (num_offsets);

      /* Just copy in the offset table directly as given to us.  */
      objfile->num_sections = num_offsets;
      objfile->section_offsets
        = ((struct section_offsets *)
           obstack_alloc (&objfile->objfile_obstack, size));
      memcpy (objfile->section_offsets, offsets, size);

      init_objfile_sect_indices (objfile);
    }
d1013 1
a1013 1
void
a1015 2
		   const struct section_offsets *offsets,
		   int num_offsets,
d1018 1
a1018 1
  syms_from_objfile_1 (objfile, addrs, offsets, num_offsets, add_flags);
d1057 1
a1057 2
   ADDRS, OFFSETS, and NUM_OFFSETS are as described for
   syms_from_objfile, above.
d1067 3
a1069 6
symbol_file_add_with_addrs_or_offsets (bfd *abfd,
                                       int add_flags,
                                       struct section_addr_info *addrs,
                                       const struct section_offsets *offsets,
                                       int num_offsets,
                                       int flags, struct objfile *parent)
d1113 1
a1113 2
  syms_from_objfile (objfile, addrs, offsets, num_offsets,
		     add_flags);
d1182 2
a1183 3
  new_objfile = symbol_file_add_with_addrs_or_offsets
    (bfd, symfile_flags,
     sap, NULL, 0,
d1193 1
a1193 3

   See symbol_file_add_with_addrs_or_offsets's comments for
   details.  */
d1200 1
a1200 2
  return symbol_file_add_with_addrs_or_offsets (abfd, add_flags, addrs, 0, 0,
                                                flags, parent);
d1204 1
a1204 2
   loaded file.  See symbol_file_add_with_addrs_or_offsets's comments
   for details.  */
@


1.375
log
@	* symfile.c: Whitespace cleanup.
@
text
@d163 1
d173 1
@


1.374
log
@	* dbxread.c (process_one_symbol): Constify section_offsets parameter.
	* stabsread.h (process_one_symbol): Update declaration.
	* dwarf2read.c (dw2_relocate): Constify new_offsets, delta parameters.
	* elfread.c (elf_symfile_relocate_probe): Ditto.
	* psymtab.c (relocate_psymtabs): Ditto.
	* objfiles.c (objfile_relocate1): Constify new_offsets parameter.
	(objfile_relocate): Ditto.
	* objfiles.h (objfile_relocate): Update declaration.
	* symfile.c (relative_addr_info_to_section_offsets): Constify
	addrs parameter.
	(default_symfile_offsets): Ditto.
	(syms_from_objfile_1): Constify offsets parameter.
	(syms_from_objfile): Ditto.
	(symbol_file_add_with_addrs_or_offsets): Ditto.
	(symfile_map_offsets_to_segments): Constify data parameter.
	* symfile.h (struct quick_symbol_functions): Constify new_offsets,
	delta parameters of member relocate.
	(struct sym_probe_fns): Constify new_offsets,
	delta parameters of member sym_relocate_probe.
	(struct sym_fns): Constify section_addr_info parameter of member
	sym_offsets.
	(relative_addr_info_to_section_offsets): Update declaration.
	(default_symfile_offsets): Ditto.
	(syms_from_objfile): Ditto.
	(symfile_map_offsets_to_segments): Ditto.
@
text
@d167 1
d309 1
a310 1
/* Initialize OBJFILE's sect_index_* members.  */
a761 1

d1233 1
a1242 1

d1246 1
a1259 1

a1580 1

a1687 1

d2369 1
a2619 1

a3055 1

d3058 1
a3107 1

a3360 1

d3404 1
d3417 1
d3433 1
a3593 1

a3656 1

d3671 1
@


1.373
log
@	* symfile.c (syms_from_objfile_1): Use correct section count when
	objfile->sf == NULL.
@
text
@d448 1
a448 1
				       struct section_addr_info *addrs)
d457 1
a457 1
      struct other_sections *osp;
d679 1
a679 1
			 struct section_addr_info *addrs)
d935 1
a935 1
		     struct section_offsets *offsets,
d1045 1
a1045 1
		   struct section_offsets *offsets,
d1102 1
a1102 1
                                       struct section_offsets *offsets,
d3675 2
a3676 1
symfile_map_offsets_to_segments (bfd *abfd, struct symfile_segment_data *data,
@


1.372
log
@gdb/
	* event-top.c (display_gdb_prompt): Call missing do_cleanups.
	* infcmd.c (get_return_value) <!stop_regs>: Do not overwrite CLEANUP.
	* symfile.c (symfile_bfd_open): New variable back_to.  Do not leave
	a stale cleanup.  Fix double free of NAME.
@
text
@d952 1
a952 1
      size_t size = SIZEOF_N_SECTION_OFFSETS (num_offsets);
@


1.371
log
@	* objfiles.c (objfile_relocate): Use gdb_bfd_count_sections instead
	of bfd_count_sections.
	* solib-target.c (solib_target_relocate_section_addresses): Ditto.
	* symfile.c (default_symfile_offsets): Ditto.
	(syms_from_objfile_1): Ditto.  Make dummy addrs list an array of
	one entry, not bfd_count_sections entries.
@
text
@d1701 1
d1743 1
a1743 1
  make_cleanup (xfree, name);
d1747 2
a1748 5
    {
      make_cleanup (xfree, name);
      error (_("`%s': can't open to read symbols: %s."), name,
	     bfd_errmsg (bfd_get_error ()));
    }
d1758 2
@


1.370
log
@	* coffread.c (cs_to_section): Use gdb_bfd_section_index.
	* elfread.c (record_minimal_symbol, elf_symtab_read): Use
	gdb_bfd_section_index.
	* gdb_bfd.c (gdb_bfd_section_index, gdb_bfd_count_sections):
	New functions.
	* gdb_bfd.h (gdb_bfd_section_index, gdb_bfd_count_sections):
	Declare.
	* machoread.c (macho_symtab_add_minsym, macho_symfile_offsets):
	Update.
	* objfiles.c (add_to_objfile_sections_full): New function.
	(add_to_objfile_sections): Use it.
	(build_section_table): Rewrite.
	(objfile_relocate1): Use gdb_bfd_section_index.  Update.
	* objfiles.h (obj_section_offset): Use gdb_bfd_section_index.
	(struct objfile) <sections>: Update comment.
	(ALL_OBJFILE_OSECTIONS): Skip sections where the_bfd_section
	is NULL.
	(ALL_OBJSECTIONS): Use it.
	* solib-dsbt.c (dsbt_relocate_main_executable): Update.
	* solib-frv.c (frv_relocate_main_executable): Update.
	* solib-target.c (solib_target_relocate_section_addresses):
	Use gdb_bfd_section_index.
	* symfile.c (build_section_addr_info_from_section_table):
	Use gdb_bfd_section_index.
	(build_section_addr_info_from_bfd, place_section): Likewise.
	* symtab.c (fixup_section): Update.
	* xcoffread.c (find_targ_sec): Use gdb_bfd_section_index.
@
text
@d681 1
a681 1
  objfile->num_sections = bfd_count_sections (objfile->obfd);
d951 1
a951 1
      int num_sections = bfd_count_sections (objfile->obfd);
d970 1
a970 2
      local_addr
	= alloc_section_addr_info (bfd_count_sections (objfile->obfd));
@


1.369
log
@	* symfile.c (find_separate_debug_file): Add comment.
	(terminate_after_last_dir_separator): Tweak comment.
@
text
@d240 2
a241 1
	  sap->other[oidx].sectindex = stp->the_bfd_section->index;
d266 1
a266 1
	sap->other[i].sectindex = sec->index;
d393 1
a393 1
  if (offsets[sect->index] != 0)
d437 1
a437 1
  offsets[sect->index] = start_addr;
@


1.368
log
@	* symfile.c (alloc_section_addr_info): Update header.  Don't set
	'num_sections' field.
	(build_section_addr_info_from_section_table): Set 'num_sections'.
	(build_section_addr_info_from_bfd): Likewise.
	(build_section_addr_info_from_objfile): Remove dead loop
	condition.
	(free_section_addr_info): Unconditionally call xfree.
	(relative_addr_info_to_section_offsets, addrs_section_sort)
	(addr_info_make_relative, syms_from_objfile_1): Remove dead loop
	condition.
	(syms_from_objfile_1): Remove dead 'if' condition.  Check
	'num_sections'.
	(add_symbol_file_command): Set 'num_sections'.
	* symfile-mem.c (symbol_file_add_from_memory): Set
	'num_sections'.
	* somread.c (som_symfile_offsets): Remove dead loop condition.
	* machoread.c (macho_symfile_offsets): Remove dead 'if'.
	* jit.c (jit_bfd_try_read_symtab): Set 'num_sections'.
@
text
@d1411 3
a1413 1
   looking for.  Returns the name of the debuginfo, of NULL.  */
d1496 1
a1496 1
/* Modify PATH to contain only "directory/" part of PATH.
@


1.367
log
@	* gdb_bfd.c (struct gdb_bfd_data) <crc_computed, crc>:
	New fields.
	(get_file_crc): Move from symfile.c.
	(gdb_bfd_crc): New function.
	* gdb_bfd.h (gdb_bfd_crc): Declare.
	* objfiles.h (struct objfile) <crc32, crc32_p>: Remove.
	* symfile.c (get_file_crc): Move to gdb_bfd.c.
	(separate_debug_file_exists): Use gdb_bfd_crc.
@
text
@d200 3
a202 1
/* Create a new section_addr_info, with room for NUM_SECTIONS.  */
a213 1
  sap->num_sections = num_sections;
d245 2
d268 3
d286 1
a286 1
  for (i = 0; i < sap->num_sections && sap->other[i].name; i++)
d303 1
a303 2
    if (sap->other[idx].name)
      xfree (sap->other[idx].name);
d454 1
a454 1
  for (i = 0; i < addrs->num_sections && addrs->other[i].name; i++)
d514 1
a514 1
  for (i = 0; i < addrs->num_sections && addrs->other[i].name; i++)
d613 1
a613 1
  for (i = 0; i < addrs->num_sections && addrs->other[i].name; i++)
d1005 1
a1005 1
  if (addrs && addrs->other[0].name)
d2349 1
@


1.366
log
@gdb
	* symfile.c (get_debug_link_info): Remove.
	(find_separate_debug_file_by_debuglink): Use
	bfd_get_debug_link_info.
bfd
	* opncls.c (bfd_get_debug_link_info): Rename from
	get_debug_link_info.  Export.  Update comment.
	(find_separate_debug_file): Update.
	* bfd-in2.h: Rebuild.
@
text
@a1306 37
/* Return 32-bit CRC for ABFD.  If successful store it to *FILE_CRC_RETURN and
   return 1.  Otherwise print a warning and return 0.  ABFD seek position is
   not preserved.  */

static int
get_file_crc (bfd *abfd, unsigned long *file_crc_return)
{
  unsigned long file_crc = 0;

  if (bfd_seek (abfd, 0, SEEK_SET) != 0)
    {
      warning (_("Problem reading \"%s\" for CRC: %s"),
	       bfd_get_filename (abfd), bfd_errmsg (bfd_get_error ()));
      return 0;
    }

  for (;;)
    {
      gdb_byte buffer[8 * 1024];
      bfd_size_type count;

      count = bfd_bread (buffer, sizeof (buffer), abfd);
      if (count == (bfd_size_type) -1)
	{
	  warning (_("Problem reading \"%s\" for CRC: %s"),
		   bfd_get_filename (abfd), bfd_errmsg (bfd_get_error ()));
	  return 0;
	}
      if (count == 0)
	break;
      file_crc = bfd_calc_gnu_debuglink_crc32 (file_crc, buffer, count);
    }

  *file_crc_return = file_crc;
  return 1;
}

d1356 1
a1356 1
  file_crc_p = get_file_crc (abfd, &file_crc);
d1365 2
d1371 1
a1371 1
      if (!verified_as_different && !parent_objfile->crc32_p)
d1373 1
a1373 3
	  parent_objfile->crc32_p = get_file_crc (parent_objfile->obfd,
						  &parent_objfile->crc32);
	  if (!parent_objfile->crc32_p)
d1377 1
a1377 1
      if (verified_as_different || parent_objfile->crc32 != file_crc)
@


1.365
log
@	* breakpoint.c (catch_syscall_split_args): Use skip_spaces.
	(trace_pass_command): Likewise.
	* cli/cli-cmds.c: Include cli/cli-utils.h.
	(source_command): Use skip-spaces.
	(disassemble_command): Likewise.
	* findcmd.c: Include cli/cli-utils.h.
	(parse_find_args): Use skip_spaces.
	* go32-nat.c: Include cli/cli-utils.h.
	(go32_sldt): Use skip_spaces.
	(go32_sgdt): Likewise.
	(go32_sidt): Likewise.
	(go32_pde): Likewise.
	(go32_pte): Likewise.
	(go32_pte_for_address): Likewise.
	* infcmd.c: Include cli/cli-utils.h.
	(registers_info): Use skip_spaces.
	* linux-tdep.c (read_mapping): Use skip_spaces_const.
	(linux_info_proc): Likewise.
	* linux-thread-db.c: Include cli/cli-utils.h.
	(info_auto_load_libthread_db): Use skip_spaces_const.
	* m32r-rom.c: Include cli/cli-utils.h.
	(m32r_upload_command): Use skip_spaces.
	* maint.c: Include cli/cli-utils.h.
	(maintenance_translate_address): Use skip_spaces.
	* mi/mi-parse.c: Include cli/cli-utils.h.
	(mi_parse_argv): Use skip_spaces.
	(mi_parse): Likewise.
	* minsyms.c: Include cli/cli-utils.h.
	(msymbol_hash_iw): Use skip_spaces_const.
	* objc-lang.c: Include cli/cli-utils.h.
	(parse_selector): Use skip_spaces.
	(parse_method): Likewise.
	* python/python.c: Include cli/cli-utils.h.
	(python_interactive_command)[HAVE_PYTHON]: Use skip_spaces.
	(python_command)[HAVE_PYTHON]: Likewise.
	(python_interactive_command)[!HAVE_PYTHON]: Likewise.
	* remote-m32r-sdi.c: Include cli/cli-utils.h.
	(m32r_load): Use skip_spaces.
	* serial.c: Include cli/cli-utils.h.
	(serial_open): Use skip_spaces_const.
	* stack.c: Include cli/cli-utils.h.
	(parse_frame_specification_1): Use skip_spaces_const.
	* symfile.c: Include cli/cli-utils.h.
	(set_ext_lang_command): Use skip_spaces.
	* symtab.c: Include cli/cli-utils.h.
	(rbreak_command): Use skip_spaces.
	* thread.c (thread_name_command): Use skip_spaces.
	* tracepoint.c (validate_actionline): Use skip_spaces.
	(encode_actions_1): Likewise.
	(trace_find_range_command): Likewise.
	(trace_find_outside_command): Likewise.
	(trace_dump_actions): Likewise.
@
text
@a1306 30
static char *
get_debug_link_info (struct objfile *objfile, unsigned long *crc32_out)
{
  asection *sect;
  bfd_size_type debuglink_size;
  unsigned long crc32;
  char *contents;
  int crc_offset;

  sect = bfd_get_section_by_name (objfile->obfd, ".gnu_debuglink");

  if (sect == NULL)
    return NULL;

  debuglink_size = bfd_section_size (objfile->obfd, sect);

  contents = xmalloc (debuglink_size);
  bfd_get_section_contents (objfile->obfd, sect, contents,
			    (file_ptr)0, (bfd_size_type)debuglink_size);

  /* Crc value is stored after the filename, aligned up to 4 bytes.  */
  crc_offset = strlen (contents) + 1;
  crc_offset = (crc_offset + 3) & ~3;

  crc32 = bfd_get_32 (objfile->obfd, (bfd_byte *) (contents + crc_offset));

  *crc32_out = crc32;
  return contents;
}

d1557 1
a1557 1
  debuglink = get_debug_link_info (objfile, &crc32);
@


1.364
log
@       PR gdb/15161
       * symfile.c (load_section_data): Change type of load_offset
       to CORE_ADDR.
       (generic_load): User strtoulst instead of strtoul for conversion
       of load_offset.
@
text
@d59 1
d2742 1
a2742 2
  while (*cp && isspace (*cp))
    cp++;
@


1.363
log
@gdb/
	* elfread.c (elf_symfile_read): Limit separate debug info additions to
	files with no separate debug info.
	* objfiles.c (add_separate_debug_objfile): Add gdb_assert calls.
	* symfile.c (read_symbols): Call find_separate_debug_file_in_section
	only for files with no separate debug info.

gdb/testsuite/
	* gdb.base/gnu-debugdata.exp): Create ${binfile}.debug,
	${binfile}.mini_debuginfo-debuglink, add -k to xz, use now
	${binfile}.mini_debuginfo-debuglink and
	${binfile}.mini_debuginfo-debuglink.xz.
@
text
@d1951 1
a1951 1
  unsigned long load_offset;
d2129 1
a2129 1
      char *endptr;
d2131 1
a2131 1
      cbdata.load_offset = strtoul (argv[1], &endptr, 0);
@


1.362
log
@	* symfile.c (get_file_crc): Use bfd_calc_gnu_debuglink_crc32.
	* utils.c (gnu_debuglink_crc32): Remove.
	* utils.h (gnu_debuglink_crc32): Don't declare.
@
text
@d826 6
a831 1
  if (!objfile_has_partial_symbols (objfile))
@


1.361
log
@	* gdb_obstack.h (obconcat): Move declaration here, from...
	* symfile.h (obconcat): ... here.
	* gdb_obstack.c: New file.
	(obconcat): Move from...
	* symfile.c (obconcat): ... here.
	* Makefile.in (SFILES): Add gdb_obstack.c.
	(COMMON_OBS): Add gdb_obstack.o.
@
text
@d1361 1
a1361 1
      file_crc = gnu_debuglink_crc32 (file_crc, buffer, count);
@


1.360
log
@	* symfile.h (obsavestring): Don't declare.
	* symfile.c (obsavestring): Remove.
	* ada-exp.y: Use obstack_copy0, not obsavestring.
	* ada-lang.c: Use obstack_copy0, not obsavestring.
	* coffread.c: Use obstack_copy0, not obsavestring.
	* cp-namespace.c: Use obstack_copy0, not obsavestring.
	* dbxread.c: Use obstack_copy0, not obsavestring.
	* dwarf2read.c: Use obstack_copy0, not obsavestring.
	* jit.c: Use obstack_copy0, not obsavestring.
	* mdebugread.c: Use obstack_copy0, not obsavestring.
	* psymtab.c: Use obstack_copy0, not obsavestring.
	* stabsread.c: Use obstack_copy0, not obsavestring.
	* xcoffread.c: Use obstack_copy0, not obsavestring.
@
text
@a153 26
/* Concatenate NULL terminated variable argument list of `const char *'
   strings; return the new string.  Space is found in the OBSTACKP.
   Argument list must be terminated by a sentinel expression `(char *)
   NULL'.  */

char *
obconcat (struct obstack *obstackp, ...)
{
  va_list ap;

  va_start (ap, obstackp);
  for (;;)
    {
      const char *s = va_arg (ap, const char *);

      if (s == NULL)
	break;

      obstack_grow_str (obstackp, s);
    }
  va_end (ap);
  obstack_1grow (obstackp, 0);

  return obstack_finish (obstackp);
}

@


1.359
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a153 24
/* Make a null terminated copy of the string at PTR with SIZE characters in
   the obstack pointed to by OBSTACKP .  Returns the address of the copy.
   Note that the string at PTR does not have to be null terminated, I.e. it
   may be part of a larger string and we are only saving a substring.  */

char *
obsavestring (const char *ptr, int size, struct obstack *obstackp)
{
  char *p = (char *) obstack_alloc (obstackp, size + 1);
  /* Open-coded memcpy--saves function call time.  These strings are usually
     short.  FIXME: Is this really still true with a compiler that can
     inline memcpy?  */
  {
    const char *p1 = ptr;
    char *p2 = p;
    const char *end = ptr + size;

    while (p1 != end)
      *p2++ = *p1++;
  }
  p[size] = 0;
  return p;
}

@


1.358
log
@	* symfile.c (list_overlays_command, map_overlay_command)
	(unmap_overlay_command): Now static.
@
text
@d3 1
a3 1
   Copyright (C) 1990-2012 Free Software Foundation, Inc.
@


1.357
log
@Move init_entry_point_info to symfile.c and make it static.

gdb/ChangeLog:

        * objfiles.c (init_entry_point_info): Move function from here...
        * symfile.c (init_entry_point_info): ... to there.  Make static.
        * objfiles.h (objfiles.h): Delete declaration.
@
text
@a102 6
void list_overlays_command (char *, int);

void map_overlay_command (char *, int);

void unmap_overlay_command (char *, int);

d3293 1
a3293 1
void
d3333 1
a3333 1
void
d3378 1
a3378 1
void
@


1.356
log
@Fix NULL objfile's section_offsets dereference during symbol load.

gdb/ChangeLog:

        * symfile.c (syms_from_objfile_1): Renames syms_from_objfile.
        Remove call to init_entry_point_info.  Add OBJFILE's
        section_offsets and num_sections initialization.  Add note
        about entry info in the function documentation.
        (syms_from_objfile): New function.
        * coffread.c (coff_symfile_init): Remove call to
        init_entry_point_info.
        * machoread.c (macho_symfile_init): Likewise.
        * xcoffread.c(xcoff_symfile_init): Likewise.
@
text
@d896 48
@


1.355
log
@	* coffread.c (coff_objfile_data_key): New global.
	(coff_symfile_init): Use set_objfile_data.
	(coff_symfile_read): Use objfile_data.
	(coff_symfile_finish): Don't free deprecated_sym_private.
	(coff_free_info): New function.
	(_initialize_coffread): Initialize coff_objfile_data_key.
	* mdebugread.c (pending_list): Update comment.
	* objfiles.h (struct objfile) <deprecated_sym_private>: Remove.
	* symfile.c (reread_symbols): Don't mention
	deprecated_sym_private.
	* xcoffread.c (xcoff_objfile_data_key): New global.
	(XCOFF_DATA): New macro.
	(process_linenos, enter_line_range, xcoff_next_symbol_text)
	(read_xcoff_symtab, coff_getfilename, read_symbol_lineno): Use
	XCOFF_DATA.
	(xcoff_new_init) Use set_objfile_data.
	(xcoff_symfile_finish): Don't free deprecated_sym_private.
	(init_stringtab, swap_sym, scan_xcoff_symtab)
	(xcoff_get_toc_offset, xcoff_initial_scan): Use XCOFF_DATA.
	(xcoff_free_info): New function.
	(_initialize_xcoffread): Initialize xcoff_objfile_data_key.
@
text
@d899 2
d928 6
a933 6
void
syms_from_objfile (struct objfile *objfile,
                   struct section_addr_info *addrs,
                   struct section_offsets *offsets,
                   int num_offsets,
		   int add_flags)
a940 1
  init_entry_point_info (objfile);
d944 12
a955 1
    return;	/* No symbols.  */
d1036 14
@


1.354
log
@	* dsrec.c (report_transfer_performance): Don't declare.
	(load_srec): Use gettimeofday, print_transfer_performance.
	* symfile.c (report_transfer_performance): Remove.
@
text
@a2565 1
	  objfile->deprecated_sym_private = NULL;
@


1.353
log
@gdb/
2012-11-27  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Kazu Hirata  <kazu@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* objfiles.c (init_entry_point_info): Call
	gdbarch_convert_from_func_ptr_addr and
	gdbarch_addr_bits_remove here ...
	(entry_point_address_query): ... instead of here.
	* solib-svr4.c (exec_entry_point): Call
	gdbarch_addr_bits_remove.
	* symfile.c (generic_load): Call gdbarch_addr_bits_remove on
	the entry address.
@
text
@a84 4
/* External variables and functions referenced.  */

extern void report_transfer_performance (unsigned long, time_t, time_t);

a2183 18
/* DEPRECATED: cagney/1999-10-18: report_transfer_performance is being
   replaced by print_transfer_performance (with a very different
   function signature).  */

void
report_transfer_performance (unsigned long data_count, time_t start_time,
			     time_t end_time)
{
  struct timeval start, end;

  start.tv_sec = start_time;
  start.tv_usec = 0;
  end.tv_sec = end_time;
  end.tv_usec = 0;

  print_transfer_performance (gdb_stdout, data_count, 0, &start, &end);
}

@


1.352
log
@2012-11-26  Alexander Larsson  <alexl@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	* NEWS: Mention mini debuginfo feature.
	* minidebug.c: New file.
	* configure.ac: Check for lzma.
	* configure, config.in: Rebuild.
	* Makefile.in (LIBLZMA): New variable.
	(CLIBS): Include LIBLZMA.
	(SFILES): Mention minidebug.c.
	(COMMON_OBS): Mention minidebug.o.
	* symfile.c (read_symbols): New function.
	(syms_from_objfile, reread_symbols): Call it.
	* symfile.h (find_separate_debug_file_in_section): Declare.
doc
	* gdb.texinfo (MiniDebugInfo): New node.
	(GDB Files): Update.
testsuite
	* gdb.base/gnu-debugdata.exp: New file.
	* gdb.base/gnu-debugdata.c: New file.
	* lib/gdb.exp (gdb_file_cmd): Handle LZMA warning.
	(gdb_unload): Return 0 on success.
@
text
@d2153 1
@


1.351
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d879 21
d1020 1
a1020 4
  (*objfile->sf->sym_read) (objfile, add_flags);

  if ((add_flags & SYMFILE_NO_READ) == 0)
    require_partial_symbols (objfile, 0);
d2622 3
a2624 8
	  /* Do not set flags as this is safe and we don't want to be
             verbose.  */
	  (*objfile->sf->sym_read) (objfile, 0);
	  if ((objfile->flags & OBJF_PSYMTABS_READ) != 0)
	    {
	      objfile->flags &= ~OBJF_PSYMTABS_READ;
	      require_partial_symbols (objfile, 0);
	    }
@


1.350
log
@	* defs.h (quit_flag): Don't declare.
	(clear_quit_flag, check_quit_flag, set_quit_flag): Declare.
	(QUIT): Use new functions.
	* event-top.c (command_handler): Use clear_quit_flag.
	(handle_sigint): Use set_quit_flag.
	(async_request_quit): Use check_quit_flag.  Don't check
	immediate_quit.
	* exceptions.c (throw_exception): Use clear_quit_flag.
	* main.c (captured_main): Use clear_quit_flag.
	* python/python.c (clear_quit_flag, set_quit_flag)
	(check_quit_flag): New functions.
	* remote-sim.c (gdb_os_poll_quit): Use check_quit_flag,
	clear_quit_flag.
	* remote.c (remote_wait_as): Use check_quit_flag,
	clear_quit_flag.
	(remote_start_remote): Call QUIT.
	* symfile.c (load_progress): Use check_quit_flag.
	* top.c (command_loop): Use clear_quit_flag.
	(command_line_input): Call QUIT.
	* utils.c (quit_flag): Conditionally define.
	(clear_quit_flag, check_quit_flag, set_quit_flag): New
	functions.
	(prompt_for_continue): Call QUIT.  Use quit, not
	async_request_quit.
	* remote-mips.c (mips_expect_timeout): Call QUIT.
	* monitor.c (monitor_expect): Call QUIT.
@
text
@d1960 1
a1960 1
		      paddress (target_gdbarch, args->lma));
d1978 1
a1978 1
	       paddress (target_gdbarch, args->lma));
d1981 1
a1981 1
	       paddress (target_gdbarch, args->lma));
d2136 1
a2136 1
  ui_out_field_fmt (uiout, "address", "%s", paddress (target_gdbarch, entry));
@


1.349
log
@	* jit.c (jit_object_close_impl): Don't malloc the objfile
	name.
	* objfiles.c (allocate_objfile): Don't malloc the objfile
	name.
	(free_objfile): Don't free the objfile name.
	* objfiles.h (struct objfile) <name>: Update comment.
	* symfile.c (reread_symbols): Fix reference counting.  Don't
	malloc objfile name.
@
text
@d1989 1
a1989 1
  if (quit_flag
@


1.348
log
@	* windows-nat.c (windows_make_so): Use gdb_bfd_open.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_open.
	(symfile_bfd_open): Likewise.
	(generic_load): Likewise.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_open.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_open.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_open.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_open.
	* remote-mips.c (mips_load_srec): Use gdb_bfd_open.
	(pmon_load_fast): Likewise.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_open.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_open.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_open.
	(macho_check_dsym): Likewise.
	* m32r-rom.c (m32r_load): Use gdb_bfd_open.
	(m32r_upload_command): Likewise.
	* gdb_bfd.h (gdb_bfd_cache): Declare.
	* gdb_bfd.c (struct gdb_bfd_data): New.
	(gdb_bfd_cache): New global.
	(struct gdb_bfd_cache_search): New.
	(hash_bfd): New function.
	(eq_bfd): Likewise.
	(gdb_bfd_open): Likewise.
	(gdb_bfd_ref): Allocate a gdb_bfd_data and attach to the BFD.
	(gdb_bfd_unref): Remove closed BFD from cache.  Update for
	gdb_bfd_data.
	* exec.c (exec_file_attach): Use gdb_bfd_open.
	* dsrec.c (load_srec): Use gdb_bfd_open.
@
text
@d2509 1
a2509 3
	  /* Clean up any state BFD has sitting around.  We don't need
	     to close the descriptor but BFD lacks a way of closing the
	     BFD without closing the descriptor.  */
d2517 8
d2528 1
a2528 2
	  if (objfile->obfd == NULL)
	    error (_("Can't open %s to read symbols."), objfile->name);
@


1.347
log
@	* dwarf2read.c (macro_start_file): Update.
	* objfiles.c (get_objfile_bfd_data): Initialize macro_cache.
	(free_objfile_per_bfd_storage): Destroy macro_cache.
	(allocate_objfile, free_objfile): Update.
	* objfiles.h (struct objfile_per_bfd_storage) <macro_cache>:
	New field.
	(struct objfile) <macro_cache>: Remove.
	* symfile.c (reread_symbols): Update.
	* symmisc.c (print_symbol_bcache_statistics): Update.
	(print_objfile_statistics): Update.
@
text
@d1706 1
a1706 1
    result = gdb_bfd_openr (name, gnutarget);
d1766 1
a1766 1
  sym_bfd = gdb_bfd_fopen (name, gnutarget, FOPEN_RB, desc);
d2106 1
a2106 1
  loadfile_bfd = gdb_bfd_openr (filename, gnutarget);
@


1.346
log
@	* elfread.c (elf_symtab_read): Update.
	* objfiles.c (objfiles_bfd_data): New global.
	(get_objfile_bfd_data, free_objfile_per_bfd_storage)
	(objfile_bfd_data_free, set_objfile_per_bfd): New functions.
	(allocate_objfile, free_objfile): Update.
	(_initialize_objfiles): Initialize objfiles_bfd_data.
	* objfiles.h (struct objfile_per_bfd_storage): New.
	(struct objfile) <per_bfd>: New field.
	<filename_cache>: Remove.
	(set_objfile_per_bfd): Declare.
	* symfile.c (reread_symbols): Update.  Call
	set_objfile_per_bfd.
	(allocate_symtab): Update.
	* symmisc.c (print_symbol_bcache_statistics): Update.
	(print_objfile_statistics): Print the size of the BFD obstack.
gdb/testsuite
	* gdb.base/maint.exp: Update.
@
text
@a2550 2
	  bcache_xfree (objfile->macro_cache);
	  objfile->macro_cache = bcache_xmalloc (NULL, NULL);
@


1.345
log
@	* symfile.c (allocate_symtab): Use host_address_to_string
	function instead of cast of pointer to long which is not
	compatible with x86_64-w64-mingw32 build.
@
text
@a2552 2
	  bcache_xfree (objfile->filename_cache);
	  objfile->filename_cache = bcache_xmalloc (NULL,NULL);
d2573 2
d2859 1
a2859 1
				      objfile->filename_cache);
@


1.344
log
@gdb/
	* cli/cli-dump.c: Add 'static' to some cmd_list_element variables.
	* gnu-nat.c, symfile.c: Likewise.
@
text
@d2886 2
a2887 2
			  "Created symtab 0x%lx for module %s.\n",
			  (long) symtab, filename);
@


1.343
log
@	* symfile.c (symbol_file_add): Don't open BFD twice.
@
text
@d3396 1
a3396 1
struct cmd_list_element *overlaylist;
@


1.342
log
@	* symfile.c (separate_debug_file_exists): Update.
	(gdb_bfd_open_maybe_remote): Rename from bfd_open_maybe_remote.
	(reread_symbols): Update.
	* elfread.c (build_id_verify): Update.
	* symfile.h (gdb_bfd_open_maybe_remote): Rename from
	bfd_open_maybe_remote.
@
text
@d1211 1
a1211 2
  objf = symbol_file_add_from_bfd (symfile_bfd_open (name), add_flags, addrs,
                                   flags, NULL);
@


1.341
log
@	* coffread.c (coff_symfile_read): Make a cleanup for 'debugfile'
	and 'abfd'.
	* elfread.c (elf_symfile_read): Make a cleanup for 'debugfile'
	and 'abfd'.
	* jit.c (jit_bfd_try_read_symtab): Make a cleanup for 'nbfd'.
	* machoread.c (macho_add_oso_symfile): Make a cleanup for
	'abfd'.
	(macho_symfile_read): Make a cleanup for 'dsym_bfd'.
	* objfiles.c (allocate_objfile): Acquire a new reference.
	* rs6000-nat.c (add_vmap): Don't acquire a BFD reference.
	* solib.c (solib_read_symbols): Don't acquire a BFD reference.
	* spu-linux-nat.c (spu_symbol_file_add_from_memory): Make
	a cleanup for 'nbfd'.
	* symfile-mem.c (symbol_file_add_from_memory): Make a cleanup
	for 'nbfd'.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Don't
	make a cleanup for 'abfd'.
	(symbol_file_add): Make a BFD cleanup.
@
text
@d1356 1
a1356 1
  abfd = bfd_open_maybe_remote (name);
d1700 1
a1700 1
bfd_open_maybe_remote (const char *name)
d2519 1
a2519 1
	    objfile->obfd = bfd_open_maybe_remote (obfd_filename);
@


1.340
log
@	* cli/cli-dump.c (bfd_openr_with_cleanup): Use gdb_bfd_openr.
	(bfd_openw_with_cleanup): Use gdb_bfd_openw.
	* corelow.c (core_open): Use gdb_bfd_fopen.
	* dsrec.c (load_srec): Use gdb_bfd_openr.
	* exec.c (exec_file_attach): Use gdb_bfd_fopen.
	* gcore.c (gcore_memory_sections): Use gdb_bfd_openw.
	* gdb_bfd.c (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): New functions.
	* gdb_bfd.h (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): Declare.
	* jit.c (bfd_open_from_target_memory): Use gdb_bfd_openr_iovec.
	* m32-rom.c (m32r_load, m32r_upload_command): Use gdb_bfd_openr.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_openr,
	gdb_bfd_openr_next_archived_file.
	(macho_check_dsym): Use gdb_bfd_openr.
	(macho_add_oso_symfile): Don't call gdb_bfd_stash_filename.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_fdopenr.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_openr.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Use
	gdb_bfd_openr.
	* remote.c (remote_bfd_open): Use gdb_bfd_openr_iovec.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_openr, gdb_bfd_fdopenr,
	gdb_bfd_openr_next_archived_file.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_openr.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_openr.
	* solib-spu.c (spu_bfd_fopen): Use gdb_bfd_openr_iovec.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_fopen.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_openr_iovec.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_openr.
	(symfile_bfd_open): Use gdb_bfd_fopen.
	(generic_load): Use gdb_bfd_openr.
	* windows-nat.c (windows_make_so): Use gdb_bfd_openr.
@
text
@d1040 1
a1040 1
   This BFD will be closed on error, and is always consumed by this function.
a1063 1
  struct cleanup *my_cleanups;
a1076 2
  my_cleanups = make_cleanup_bfd_unref (abfd);

a1086 1
  discard_cleanups (my_cleanups);
d1207 5
a1211 1
  return symbol_file_add_from_bfd (symfile_bfd_open (name), add_flags, addrs,
d1213 2
@


1.339
log
@	* bfd-target.c (target_bfd_reopen): Update.
	* cli/cli-dump.c (bfd_openr_with_cleanup)
	(bfd_openw_with_cleanup): Update.
	* corelow.c (core_open): Update.
	* dsrec.c (load_srec): Update.
	* exec.c (exec_file_attach): Update.
	* gcore.c (create_gcore_bfd): Update.
	* gdb_bfd.c (gdb_bfd_ref): Return void.
	(gdb_bfd_open): Update.
	* gdb_bfd.h (gdb_bfd_ref): Return void.
	Update comments.
	* jit.c (jit_bfd_try_read_symtab): Update.
	* m32r-rom.c (m32r_load, m32r_upload_command): Update.
	* machoread.c (macho_symfile_read_all_oso): Update.
	(macho_check_dsym): Update.
	* procfs.c (insert_dbx_link_bpt_in_file): Update.
	* remote-m32r-sdi.c (m32r_load): Update.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Update.
	* rs6000-nat.c (add_vmap): Update.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-spu.c (spu_bfd_open): Update.
	* solib.c (solib_bfd_fopen, solib_read_symbols): Update.
	* spu-linux-nat.c (spu_bfd_open): Update.
	* symfile.c (bfd_open_maybe_remote, symfile_bfd_open)
	(generic_load): Update.
	* windows-nat.c (windows_make_so): Update.
@
text
@d1705 1
a1705 5
    {
      result = bfd_openr (name, gnutarget);
      if (result != NULL)
	gdb_bfd_stash_filename (result);
    }
a1706 1
  gdb_bfd_ref (result);
a1725 1
      gdb_bfd_ref (sym_bfd);
d1765 1
a1765 2
  sym_bfd = bfd_fopen (name, gnutarget, FOPEN_RB, desc);
  gdb_bfd_ref (sym_bfd);
a1780 2
  gdb_bfd_stash_filename (sym_bfd);

d2105 1
a2105 2
  loadfile_bfd = bfd_openr (filename, gnutarget);
  gdb_bfd_ref (loadfile_bfd);
@


1.338
log
@	* utils.c (make_cleanup_bfd_unref): Rename from
	make_cleanup_bfd_close.
	* defs.h (make_cleanup_bfd_unref): Rename from
	make_cleanup_bfd_close.
	* cli/cli-dump.c (bfd_openr_with_cleanup): Update.
	(bfd_openw_with_cleanup): Update.
	* corelow.c (core_open): Update.
	* dsrec.c (load_srec): Update.
	* m32r-rom.c (m32r_load, m32r_upload_command): Update.
	* remote-m32r-sdi.c (m32r_load): Update.
	* remote-mips.c (mips_load_srec): Update.
	(pmon_load_fast): Update.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Update.
	(darwin_bfd_open): Update.
	* solib.c (solib_bfd_fopen): Update.
	* symfile-mem.c (symbol_file_add_from_memory): Update.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Update.
	(symfile_bfd_open): Update.
	(generic_load): Update.
@
text
@d1700 2
d1703 1
a1703 1
    return gdb_bfd_ref (remote_bfd_open (name, gnutarget));
d1706 1
a1706 2
      bfd *result = gdb_bfd_ref (bfd_openr (name, gnutarget));

a1708 1
      return result;
d1710 3
d1730 2
a1731 1
      sym_bfd = gdb_bfd_ref (remote_bfd_open (name, gnutarget));
d1771 2
a1772 1
  sym_bfd = gdb_bfd_ref (bfd_fopen (name, gnutarget, FOPEN_RB, desc));
d2114 2
a2115 1
  loadfile_bfd = gdb_bfd_ref (bfd_openr (filename, gnutarget));
@


1.337
log
@	* symfile.c (symfile_bfd_open): Don't copy name.  Call
	gdb_bfd_stash_filename.
	(load_command): Open the new BFD before freeing the old.
	(bfd_open_maybe_remote): Call gdb_bfd_stash_filename.
	* symfile-mem.c (symbol_file_add_from_memory): Don't copy name.
	Call gdb_bfd_stash_filename.
	* spu-linux-nat.c (spu_bfd_open): Don't copy name.
	* solib-spu.c (spu_bfd_fopen): Don't copy name.  Call
	gdb_bfd_stash_filename.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Free found_pathname.
	* rs6000-nat.c (add_vmap): Don't copy filename.  Call
	gdb_bfd_stash_filename.
	* remote.c (remote_bfd_open): Call gdb_bfd_stash_filename.
	* machoread.c (macho_add_oso_symfile): Call
	gdb_bfd_stash_filename.
	(macho_symfile_read_all_oso): Arrange to free archive_name.  Call
	gdb_bfd_stash_filename.
	(macho_check_dsym): Don't copy filename.  Call
	gdb_bfd_stash_filename.
	* jit.c (bfd_open_from_target_memory): Don't copy the filename.
	* gdb_bfd.c (gdb_bfd_stash_filename): New function.
	* gdb_bfd.h (gdb_bfd_stash_filename): Declare.
	* gcore.c (create_gcore_bfd): Call gdb_bfd_stash_filename.
	* exec.c (exec_close): Don't free the BFD's filename.
	(exec_file_attach): Don't copy the filename.  Call
	gdb_bfd_stash_filename.
	* corelow.c (core_close): Don't free the BFD's filename.
	(core_open): Call gdb_bfd_stash_filename.
	* corefile.c (reopen_exec_file): Remove #if 0 code.
	* solib.c (solib_bfd_fopen): Call gdb_bfd_stash_filename.  Free
	pathname.
	* dwarf2read.c (try_open_dwo_file): Call gdb_bfd_stash_filename.
@
text
@d1078 1
a1078 1
  my_cleanups = make_cleanup_bfd_close (abfd);
d1734 1
a1734 1
	  make_cleanup_bfd_close (sym_bfd);
d1778 1
a1778 1
      make_cleanup_bfd_close (sym_bfd);
d2116 1
a2116 1
  make_cleanup_bfd_close (loadfile_bfd);
@


1.336
log
@	* dwarf2read.c (try_open_dwo_file): Use gdb_bfd_ref and
	gdb_bfd_unref.
	(free_dwo_file): Use gdb_bfd_unref.
	* cli/cli-dump.c: Include gdb_bfd.h.
	(bfd_openw_with_cleanup): Use gdb_bfd_ref.
	(bfd_openr_with_cleanup): Likewise.
	* windows-nat.c (windows_make_so): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* utils.c: Include gdb_bfd.h.
	(do_bfd_close_cleanup): Use gdb_bfd_unref.
	* symfile.c: Include gdb_bfd.h.
	(separate_debug_file_exists): Use gdb_bfd_unref.
	(bfd_open_maybe_remote): Use gdb_bfd_ref.
	(symfile_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	(generic_load): Use gdb_bfd_ref.
	(reread_symbols): Use gdb_bfd_unref.
	* symfile-mem.c: Include gdb_bfd.h.
	(symbol_file_add_from_memory): Use make_cleanup_bfd_close.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib.c: Include gdb_bfd.h.
	(solib_bfd_fopen): Use gdb_bfd_ref.
	(solib_bfd_open): Use gdb_bfd_unref.
	(free_so_symbols): Use gdb_bfd_unref.
	(reload_shared_libraries_1): Use gdb_bfd_unref.
	* solib-spu.c: Include gdb_bfd.h.
	(spu_bfd_fopen): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* solib-frv.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-dsbt.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-darwin.c: Include gdb_bfd.h.
	(darwin_solib_get_all_image_info_addr_at_init): Use gdb_bfd_ref,
	gdb_bfd_unref.
	(darwin_bfd_open): Use gdb_bfd_unref.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_ref, gdb_bfd_unref.
	* remote-mips.c: Include gdb_bfd.h.
	(mips_load_srec): Use gdb_bfd_ref.
	(pmon_load_fast): Use gdb_bfd_ref.
	* remote-m32r-sdi.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	* record.c: Include gdb_bfd.h.
	(record_save_cleanups): Use gdb_bfd_unref.
	(cmd_record_save): Use gdb_bfd_unref.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* objfiles.h (gdb_bfd_close_or_warn): Remove.
	(gdb_bfd_ref, gdb_bfd_unref): Move to gdb_bfd.h.
	* objfiles.c: Include gdb_bfd.h.
	(free_objfile): Use gdb_bfd_unref.
	(gdb_bfd_close_or_warn, gdb_bfd_ref, gdb_bfd_unref): Move to
	gdb_bfd.c.
	* machoread.c (macho_add_oso_symfile): Use gdb_bfd_unref.
	(macho_symfile_read_all_oso): Use gdb_bfd_ref, gdb_bfd_unref.
	(macho_check_dsym): Likewise.
	* m32r-rom.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	(m32r_upload_command): Use gdb_bfd_ref.
	* jit.c: Include gdb_bfd.h.
	(jit_bfd_try_read_symtab): Use gdb_bfd_ref, gdb_bfd_unref.
	* gdb_bfd.h: New file.
	* gdb_bfd.c: New file.
	* gcore.c: Include gdb_bfd.h.
	(create_gcore_bfd): Use gdb_bfd_ref.
	(do_bfd_delete_cleanup): Use gdb_bfd_unref.
	(gcore_command): Use gdb_bfd_unref.
	* exec.c: Include gdb_bfd.h.
	(exec_close): Use gdb_bfd_unref.
	(exec_close_1): Use gdb_bfd_unref.
	(exec_file_attach): Use gdb_bfd_ref.
	* elfread.c: Include gdb_bfd.h.
	(build_id_verify): Use gdb_bfd_unref.
	* dsrec.c: Include gdb_bfd.h.
	(load_srec): Use gdb_bfd_ref.
	* corelow.c: Include gdb_bfd.h.
	(core_close): Use gdb_bfd_unref.
	(core_open): Use gdb_bfd_ref.
	* bfd-target.c: Include gdb_bfd.h.
	(target_bfd_xclose): Use gdb_bfd_unref.
	(target_bfd_reopen): Use gdb_bfd_ref.
	* Makefile.in (SFILES): Add gdb_bfd.c.
	(HFILES_NO_SRCDIR): Add gdb_bfd.h.
	(COMMON_OBS): Add gdb_bfd.o.
@
text
@d1703 7
a1709 1
    return gdb_bfd_ref (bfd_openr (name, gnutarget));
a1726 1
      name = xstrdup (name);
d1729 2
a1730 5
	{
	  make_cleanup (xfree, name);
	  error (_("`%s': can't open to read symbols: %s."), name,
		 bfd_errmsg (bfd_get_error ()));
	}
d1734 1
a1734 2
	  gdb_bfd_unref (sym_bfd);
	  make_cleanup (xfree, name);
a1762 2
  /* Free 1st new malloc'd copy, but keep the 2nd malloc'd copy in
     bfd.  It'll be freed in free_objfile().  */
d1765 1
a1778 1
      make_cleanup (xfree, name);
d1783 2
d2515 10
a2524 3
	  obfd_filename = bfd_get_filename (objfile->obfd);
	  gdb_bfd_unref (objfile->obfd);
	  objfile->obfd = bfd_open_maybe_remote (obfd_filename);
@


1.335
log
@	* NEWS: Mention new options "set debug dwarf2-read" and
	"set debug symtab-create".
	* dwarf2read.c (dwarf2_read_debug): New static global.
	(dwarf2_build_psymtabs_hard): Add debugging printfs.
	(process_queue): Ditto.
	(process_full_comp_unit): Ditto.
	(_initialize_dwarf2_read): Add new option "set debug dwarf2-read".
	* elfread.c (elf_symfile_read): Add debugging printf.
	* minsyms.c (install_minimal_symbols): Ditto.
	* psymtab.c (allocate_psymtab): Ditto.
	* symfile.c (allocate_symtab): Ditto.
	* symtab.c (symtab_create_debug): New global.
	(_initialize_symtab): Add new option "set debug symtab-create".
	* symtab.h (symtab_create_debug): Declare.

	doc/
	* gdb.texinfo (Debugging Output): Document debug options dwarf2-read
	and symtab-create.
@
text
@d58 1
d1376 1
a1376 1
	  bfd_close (abfd);
d1386 1
a1386 1
  bfd_close (abfd);
d1694 2
a1695 1
   open it normally.  */
d1701 1
a1701 1
    return remote_bfd_open (name, gnutarget);
d1703 1
a1703 1
    return bfd_openr (name, gnutarget);
d1722 1
a1722 1
      sym_bfd = remote_bfd_open (name, gnutarget);
d1732 1
a1732 1
	  bfd_close (sym_bfd);
d1767 1
a1767 1
  sym_bfd = bfd_fopen (name, gnutarget, FOPEN_RB, desc);
d1778 1
a1778 4
      /* FIXME: should be checking for errors from bfd_close (for one
         thing, on error it does not free all the storage associated
         with the bfd).  */
      bfd_close (sym_bfd);	/* This also closes desc.  */
a1783 3
  /* bfd_usrdata exists for applications and libbfd must not touch it.  */
  gdb_assert (bfd_usrdata (sym_bfd) == NULL);

d2108 1
a2108 1
  loadfile_bfd = bfd_openr (filename, gnutarget);
a2114 3
  /* FIXME: should be checking for errors from bfd_close (for one thing,
     on error it does not free all the storage associated with the
     bfd).  */
d2515 1
a2515 3
	  if (!bfd_close (objfile->obfd))
	    error (_("Can't close BFD for %s: %s"), objfile->name,
		   bfd_errmsg (bfd_get_error ()));
a2518 2
	  else
	    objfile->obfd = gdb_bfd_ref (objfile->obfd);
@


1.335.2.1
log
@	* symfile.c (allocate_symtab): Use host_address_to_string
	function instead of cast of pointer to long which is not
	compatible with x86_64-w64-mingw32 build.
@
text
@d2892 2
a2893 2
			  "Created symtab %s for module %s.\n",
			  host_address_to_string (symtab), filename);
@


1.334
log
@	* linespec.c (decode_objc): Add cleanup to free
	INFO.FILE_SYMTABS.
	(find_linespec_symbols): Add cleanup to free CLASSES.
	* symfile.c (find_separate_debug_file_by_debuglink): Add
	cleanup to free DEBUGLINK.
	* ui-out.c (clear_header_list): No need to check if
	HEADER_NEXT.COLHDR is NULL.
	Free HEADER_NEXT.COL_NAME.
@
text
@d2876 20
@


1.333
log
@bfd/
	* opncls.c (bfd_fopen): Always close fd on failure.
	(bfd_fdopenr): Likewise.
gdb/
	* symfile.c (symfile_bfd_open): Don't close desc if bfd_fopen
	fails.
	* solib.c (solib_bfd_fopen): Don't close fd if bfd_fopen fails.
	* exec.c (exec_file_attach): Don't close scratch_chan if bfd_fopen
	fails.
	* dwarf2read.c (try_open_dwo_file): Don't close fd if bfd_fopen
	fails.
@
text
@d1556 1
d1558 1
a1558 1
  cleanups = make_cleanup (xfree, dir);
@


1.332
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@a1766 1
      close (desc);
@


1.331
log
@	Initial support for Fission.  http://gcc.gnu.org/wiki/DebugFission
	* symfile.c (default_symfile_relocate): Use sectp->owner instead of
	objfile->obfd.
	* symfile.h (dwarf2_debug_sections): New member addr.
	* dwarf2expr.c (execute_stack_op): New case DW_OP_GNU_addr_index.
	(ctx_no_get_addr_index): New function.
	* dwarf2expr.h (dwarf_expr_context_funcs): New member get_addr_index.
	(ctx_no_get_addr_index): Declare.
	* dwarf2-frame.c (dwarf2_frame_ctx_funcs): Update.
	* dwarf2loc.c (dwarf_expr_get_addr_index): New function.
	(dwarf_expr_ctx_funcs): Update.
	(needs_get_addr_index): New function.
	(needs_frame_ctx_funcs): Update.
	* dwarf2loc.h (dwarf2_read_addr_index): Declare.
	* dwarf2read.c: #include "gdbcore.h".
	(dwarf2_per_objfile): New members addr, dwo_files.
	(dwarf2_elf_names): Add entry for addr.
	(struct dwo_section_names): New type.
	(dwo_section_names): New static global.
	(dwarf2_cu): New members dwo_unit, addr_base, have_addr_base.
	(dwarf2_per_cu_data): New member is_debug_types, all boolean uses of
	old debug_types_section member updated to use this.
	Rename member debug_types_section to info_or_types_section,
	all uses updated.
	(signatured_type): Rename member type_offset to type_offset_in_tu,
	all uses updated.  New member type_offset_in_section.
	(struct dwo_sections): New type.
	(struct dwo_unit): New type.
	(struct dwo_file): New type.
	(die_reader_specs): New member dwo_file.
	(dwarf2_locate_sections): Watch for .debug_addr.
	(zlib_decompress_section): Use sectp->owner instead of objfile->obfd.
	(dwarf2_read_section): Get bfd of section from bfd's asection,
	instead of objfile.
	(create_cus_from_index): Initialize the_cu->info_or_types_section.
	(create_signatured_type_table_from_index): Initialize
	sig_type->info_or_types_section.
	(dw2_get_file_names): Statement lists for type units with DWO files
	live in the DWO file.
	(create_debug_types_hash_table): New function.
	(create_all_type_units): Rewrite.
	(init_cu_die_reader): New arg dwo_file, all callers updated.
	(init_and_read_dies_worker): Get section from
	this_cu->info_or_types_section.  Set sig_type->type_offset_in_section.
	Watch for DW_AT_GNU_dwo_name and if present lookup the file and
	continue reading the CU/TU from there.
	(init_cutu_and_read_dies_no_follow): New arg dwo_file, all callers
	updated.  Get section from this_cu->info_or_types_section.
	(create_all_comp_units): Initialize this_cu->info_or_types_section.
	(skip_one_die): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(hash_dwo_file, eq_dwo_file): New functions.
	(allocate_dwo_file_hash_table): New function.
	(hash_dwo_unit, eq_dwo_unit): New functions.
	(allocate_dwo_unit_table): New function.
	(dwarf2_locate_dwo_sections): New function.
	(struct create_dwo_info_table_data): New type.
	(create_debug_info_hash_table_reader): New function.
	(create_debug_info_hash_table): New function.
	(try_open_dwo_file, open_dwo_file, init_dwo_file): New function.
	(lookup_dwo_file): New function.
	(lookup_dwo_comp_unit, lookup_dwo_type_unit): New functions.
	(free_dwo_file, free_dwo_file_cleanup): New functions.
	(free_dwo_file_from_slot, free_dwo_files): New functions.
	(dwarf2_get_pc_bounds): Handle DW_FORM_GNU_addr_index.
	(dwarf2_record_block_ranges): Ditto.
	(read_partial_die): Ditto.
	(process_enumeration_scope): Update to use type_offset_in_section.
	(read_full_die_1): New function.
	(read_full_die): Rewrite.
	(read_attribute_value): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(read_addr_index_1, read_addr_index): New functions.
	(read_addr_index_from_leb128): New function.
	(struct dwarf2_read_addr_index_data): New type.
	(dwarf2_read_addr_index_reader): New function.
	(dwarf2_read_addr_index): New function.
	(read_str_index): New function.
	(leb128_size): New function.
	(dwarf_decode_line_header): Delete arg abfd, all callers updated.
	If processing a type unit from a DWO file, get the line section
	from the DWO file.
	(var_decode_location): Watch for DW_OP_GNU_addr_index.
	(dwarf2_const_value_attr): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(lookup_die_type): Check whether section offset of type's die is
	known before looking it up.  Remove assert.  Condition can
	legimately happen for inter-cu type references.
	(dwarf_attr_name): Handle Fission attributes.
	(dwarf_form_name): Handle Fission forms.
	(dump_die_shallow): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(follow_die_sig): Update to use type_offset_in_section.
	(decode_locdesc): New case DW_OP_GNU_addr_index.
	(skip_form_bytes): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(cu_debug_loc_section): New function.
	(fill_in_loclist_baton, dwarf2_symbol_mark_computed): Call it.
	(dwarf2_per_objfile_free): Unmap .debug_addr section.
	Free DWO files if present.
	* xcoffread.c (dwarf2_xcoff_names): Add .debug_addr.

	testsuite/
	* gdb.dwarf2/dw2-intercu.S (.Ltype_int2_in_cu2): Renamed from
	.Ltype_int_in_cu2.  Use name "int2" instead of "int".
	All uses updated.
	* gdb.dwarf2/dw2-intercu.exp: Add "ptype int2" ahead of
	"ptype func_cu1" to expand cu2 before cu1.
@
text
@d547 1
a547 1
  int retval, a_idx, b_idx;
@


1.330
log
@gdb/
	Code cleanup.
	* charset.c (find_charset_names): Remove variables ix and elt.
	Use free_char_ptr_vec.
	* elfread.c (build_id_to_debug_filename): New variables debugdir_vec,
	back_to and ix.  Use dirnames_to_char_ptr_vec.  Remove variable
	debugdir_end.  New variable debugdir_len.
	* gdb_vecs.h (free_char_ptr_vec, make_cleanup_free_char_ptr_vec)
	(dirnames_to_char_ptr_vec_append, dirnames_to_char_ptr_vec): New
	declarations.
	* progspace.c (clear_program_space_solib_cache): Remove variables ix
	and elt.  Use free_char_ptr_vec.
	* source.c (add_path): Remove variables argv, arg and argv_index.
	New variables dir_vec, back_to, ix and name.
	Use dirnames_to_char_ptr_vec_append.  Use freeargv instead of
	make_cleanup_freeargv.  Remove variable separator.  Simplify the code
	no longer expecting DIRNAME_SEPARATOR.
	(openp): Remove variable p, p1 and len.  New variables dir_vec,
	back_to, ix and dir.  Use dirnames_to_char_ptr_vec.  Simplify the code
	no longer expecting DIRNAME_SEPARATOR.
	* symfile.c (find_separate_debug_file): New variables debugdir_vec,
	back_to and ix.  Use dirnames_to_char_ptr_vec.  Remove variable
	debugdir_end.
	* utils.c (free_char_ptr_vec, do_free_char_ptr_vec)
	(make_cleanup_free_char_ptr_vec, dirnames_to_char_ptr_vec_append)
	(dirnames_to_char_ptr_vec): New functions.
@
text
@d3628 3
a3630 1
  bfd *abfd = objfile->obfd;
@


1.329
log
@	* NEWS: Mention symbol-reloading has been deleted.
	* symfile.c (symbol_reloading): Delete.
	(show_symbol_reloading): Delete.
	(_initialize_symfile): Delete set/show symbol-reloading.

	doc/
	* gdb.texinfo (Help): Change apropos example to use "alias" instead
	of "reload".
	(Symbols): Delete docs for set/show symbol-reloading.
	* gdbint.texinfo (Defining Other Architecture Features): Delete
	SYMBOL_RELOADING_DEFAULT.
	* refcard.tex: Delete reference to symbol-reloading.

	testsuite/
	* gdb.base/default.exp: Delete tests for symbol-reloading.
	* gdb.base/help.exp: Ditto.
	* gdb.base/setshow.exp: Ditto.
	* gdb.base/gdb_history: Delete references to symbol-reloading.
@
text
@d1444 3
d1481 4
a1484 2
  debugdir = debug_file_directory;
  do
d1486 1
a1486 11
      char *debugdir_end;

      while (*debugdir == DIRNAME_SEPARATOR)
	debugdir++;

      debugdir_end = strchr (debugdir, DIRNAME_SEPARATOR);
      if (debugdir_end == NULL)
	debugdir_end = &debugdir[strlen (debugdir)];

      memcpy (debugfile, debugdir, debugdir_end - debugdir);
      debugfile[debugdir_end - debugdir] = 0;
d1501 1
a1501 2
	  memcpy (debugfile, debugdir, debugdir_end - debugdir);
	  debugfile[debugdir_end - debugdir] = 0;
a1508 2

      debugdir = debugdir_end;
a1509 1
  while (*debugdir != 0);
d1511 1
@


1.328
log
@	* objfiles.c (add_to_objfile_sections): Remove outdated comments.
	Rename objfile_p_char parameter to objfilep.
	(build_objfile_section_table): Result is now void.  All callers
	updated.
	* objfiles.h (struct objfile): Tweak comments, whitespace.
	(build_objfile_section_table): Update.
@
text
@a149 17
/* Flag for whether user will be reloading symbols multiple times.
   Defaults to ON for VxWorks, otherwise OFF.  */

#ifdef SYMBOL_RELOADING_DEFAULT
int symbol_reloading = SYMBOL_RELOADING_DEFAULT;
#else
int symbol_reloading = 0;
#endif
static void
show_symbol_reloading (struct ui_file *file, int from_tty,
		       struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Dynamic symbol table reloading "
			    "multiple times in one run is %s.\n"),
		    value);
}

a3818 8
  add_setshow_boolean_cmd ("symbol-reloading", class_support,
			   &symbol_reloading, _("\
Set dynamic symbol table reloading multiple times in one run."), _("\
Show dynamic symbol table reloading multiple times in one run."), NULL,
			   NULL,
			   show_symbol_reloading,
			   &setlist, &showlist);

@


1.327
log
@	* symfile.c (symbol_file_add_main_1): Use inferior's
	symfile_flags.
	* solib.c (solib_read_symbols): Use inferior's symfile_flags.
	* linux-nat.c (linux_child_follow_fork): Set symfile_flags on
	inferior.
	* infrun.c (handle_vfork_child_exec_or_exit): Set symfile_flags on
	inferior.
	(follow_exec): Use inferior's symfile_flags.
	* inferior.h (struct inferior) <symfile_flags>: New field.
@
text
@d2608 1
a2608 2
	     gdb_obstack.h specifies the alloc/dealloc
	     functions.  */
d2610 1
a2610 5
	  if (build_objfile_section_table (objfile))
	    {
	      error (_("Can't find the file sections in `%s': %s"),
		     objfile->name, bfd_errmsg (bfd_get_error ()));
	    }
@


1.326
log
@2012-01-18  Paul Pluzhnikov  <ppluzhnikov@@google.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR gdb/9538
	* symfile.c (find_separate_debug_file): New function.
	(terminate_after_last_dir_separator): Likewise.
	(find_separate_debug_file_by_debuglink): Also try realpath.
	* configure.ac (AC_CHECK_FUNCS): Add lstat.
	* configure: Regenerate.
	* config.in: Regenerate.

testsuite/ChangeLog:

2012-01-18  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	PR gdb/9538
	* gdb.base/sepdebug.exp: New test.
@
text
@d1249 3
a1251 1
  const int add_flags = SYMFILE_MAINLINE | (from_tty ? SYMFILE_VERBOSE : 0);
d1258 2
a1259 1
  set_initial_language ();
@


1.325
log
@Trivial cleanup: kill trailing whitespace
@
text
@d1444 10
a1453 2
char *
find_separate_debug_file_by_debuglink (struct objfile *objfile)
d1455 2
a1456 5
  char *basename, *debugdir;
  char *dir = NULL;
  char *debugfile = NULL;
  char *canon_name = NULL;
  unsigned long crc32;
d1459 1
a1459 21
  basename = get_debug_link_info (objfile, &crc32);

  if (basename == NULL)
    /* There's no separate debug info, hence there's no way we could
       load it => no warning.  */
    goto cleanup_return_debugfile;

  dir = xstrdup (objfile->name);

  /* Strip off the final filename part, leaving the directory name,
     followed by a slash.  The directory can be relative or absolute.  */
  for (i = strlen(dir) - 1; i >= 0; i--)
    {
      if (IS_DIR_SEPARATOR (dir[i]))
	break;
    }
  /* If I is -1 then no directory is present there and DIR will be "".  */
  dir[i+1] = '\0';

  /* Set I to max (strlen (canon_name), strlen (dir)).  */
  canon_name = lrealpath (dir);
d1461 2
a1462 2
  if (canon_name && strlen (canon_name) > i)
    i = strlen (canon_name);
d1468 1
a1468 1
		       + strlen (basename)
d1473 1
a1473 1
  strcat (debugfile, basename);
d1476 1
a1476 1
    goto cleanup_return_debugfile;
d1482 1
a1482 1
  strcat (debugfile, basename);
d1485 1
a1485 1
    goto cleanup_return_debugfile;
d1508 1
a1508 1
      strcat (debugfile, basename);
d1511 1
a1511 1
	goto cleanup_return_debugfile;
d1515 2
a1516 2
      if (canon_name
	  && filename_ncmp (canon_name, gdb_sysroot,
d1518 1
a1518 1
	  && IS_DIR_SEPARATOR (canon_name[strlen (gdb_sysroot)]))
d1522 1
a1522 1
	  strcat (debugfile, canon_name + strlen (gdb_sysroot));
d1524 1
a1524 1
	  strcat (debugfile, basename);
d1527 1
a1527 1
	    goto cleanup_return_debugfile;
d1535 82
a1616 1
  debugfile = NULL;
d1618 1
a1618 4
cleanup_return_debugfile:
  xfree (canon_name);
  xfree (basename);
  xfree (dir);
@


1.324
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1503 1
a1503 1
 
d1548 1
a1548 1
  
d1634 1
a1634 1
      
d2945 1
a2945 1
  
@


1.323
log
@gdb/
	* symfile.c (objfilep): New typedef and new DEF_VEC_P.
	(reread_symbols): Remove variable reread_one, new variables
	new_objfiles, all_cleanups and ix.  Use new_objfiles instead of
	reread_one.  Push changed objfiles to new_objfiles, call
	observer_notify_new_objfile for them later.
@
text
@d3 1
a3 3
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.322
log
@gdb/
	* symfile.c (reread_symbols): Move free_objfile_separate_debug,
	preserve_values, sym_finish and clear_objfile_data calls before BFD
	close.  Move free_objfile_separate_debug as the very first call.  New
	comment on the ordering.

gdb/testsuite/
	* gdb.base/reread.exp: If srcfile2 fails to build retry it with
	-DNO_SECTIONS.
	* gdb.base/reread2.c <!NO_SECTIONS>: New sections block.
@
text
@d2374 4
a2383 1
  int reread_one = 0;
d2386 4
a2603 1
	  reread_one = 1;
d2605 2
d2610 1
a2610 1
  if (reread_one)
d2612 2
d2618 7
d2629 2
@


1.321
log
@	* symfile.c (symbol_file_add_with_addrs_or_offsets): Remove bad
	do_cleanups call.
@
text
@d2449 23
a2496 21
	  /* Remove any references to this objfile in the global
	     value lists.  */
	  preserve_values (objfile);

	  /* Nuke all the state that we will re-read.  Much of the following
	     code which sets things to NULL really is necessary to tell
	     other parts of GDB that there is nothing currently there.

	     Try to keep the freeing order compatible with free_objfile.  */

	  if (objfile->sf != NULL)
	    {
	      (*objfile->sf->sym_finish) (objfile);
	    }

	  clear_objfile_data (objfile);

	  /* Free the separate debug objfiles.  It will be
	     automatically recreated by sym_read.  */
          free_objfile_separate_debug (objfile);

@


1.320
log
@2011-10-06  Justin Lebar  <justin.lebar@@gmail.com>

	* Makefile.in: (SFILES): Add skip.c.
	(HFILES_NO_SRCDIR): Add skip.h.
	(COMMON_OBS): Add skip.o.
	* skip.h, skip.c: New.
	* breakpoint.h (set_default_breakpoint): Remove.
	(get_sal_arch): Declare.
	* breakpoint.c: Remove default_breakpoint_valid,
	default_breakpoint_address, default_breakpoint_symtab,
	default_breakpoint_line, default_breakpoint_pspace variables.
	(get_sal_arch): Make public.
	(set_default_breakpoint): Remove.
	(parse_breakpoint_sals, create_breakpoint, clear_command,
	decode_line_spec_1): Remove uses of default_breakpoint variables;
	replaced with function calls into stack.c.
	* cli/cli-cmds.h: Add cmd_list_element *skiplist.
	* cli/cli-cmds.c: Add skiplist.
	(init_cmd_lists): Initialize skiplist.
	(init_cli_cmds): Fix comment (classes of commands appear in
	alphabetical order).
	* infrun.c (handle_inferior_event): Add check that we don't step into
	a function whose pc is marked for skip.
	* stack.c: Declare last_displayed_sal_valid, last_displayed_pspace,
	last_displayed_addr, last_displayed_symtab, last_displayed_line
	variables.
	(set_last_displayed_sal): New static function.
	(print_frame_info): Switch call to set_default_breakpoint to call to
	set_last_displayed_sal.
	(clear_last_displayed_sal, last_displayed_sal_is_valid,
	get_last_displayed_pspace, get_last_displayed_addr,
	get_last_displayed_symtab, get_last_displayed_line,
	get_last_displayed_sal): New public functions.
	* stack.h (clear_last_displayed_sal, last_displayed_sal_is_valid,
	get_last_displayed_pspace, get_last_displayed_addr,
	get_last_displayed_symtab, get_last_displayed_line,
	get_last_displayed_sal): Declare.

2011-10-06  Justin Lebar <justin.lebar@@gmail.com>

	Add tests for skip command.
	* testsuite/gdb.base/skip-solib-lib.c: New
	* testsuite/gdb.base/skip-solib-main.c: New
	* testsuite/gdb.base/skip-solib.exp: New
	* testsuite/gdb.base/skip.c: New
	* testsuite/gdb.base/skip.exp: New
	* testsuite/gdb.base/skip1.c: New
	* testsuite/gdb.base/Makefile.in: Adding new files.
@
text
@a1167 2
  do_cleanups (my_cleanups);

@


1.320.2.1
log
@	* symfile.c (symbol_file_add_with_addrs_or_offsets): Remove bad
	do_cleanups call.
@
text
@d1168 2
@


1.320.2.2
log
@gdb/
	* symfile.c (reread_symbols): Move free_objfile_separate_debug,
	preserve_values, sym_finish and clear_objfile_data calls before BFD
	close.  Move free_objfile_separate_debug as the very first call.  New
	comment on the ordering.

gdb/testsuite/
	* gdb.base/reread.exp: If srcfile2 fails to build retry it with
	-DNO_SECTIONS.
	* gdb.base/reread2.c <!NO_SECTIONS>: New sections block.
@
text
@a2448 23
	  /* Keep the calls order approx. the same as in free_objfile.  */

	  /* Free the separate debug objfiles.  It will be
	     automatically recreated by sym_read.  */
	  free_objfile_separate_debug (objfile);

	  /* Remove any references to this objfile in the global
	     value lists.  */
	  preserve_values (objfile);

	  /* Nuke all the state that we will re-read.  Much of the following
	     code which sets things to NULL really is necessary to tell
	     other parts of GDB that there is nothing currently there.

	     Try to keep the freeing order compatible with free_objfile.  */

	  if (objfile->sf != NULL)
	    {
	      (*objfile->sf->sym_finish) (objfile);
	    }

	  clear_objfile_data (objfile);

d2474 21
@


1.320.2.3
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1990-2012 Free Software Foundation, Inc.
@


1.319
log
@	* symfile.c (separate_debug_file_exists): Fix condition.
@
text
@d59 1
d2843 1
a2843 1
  set_default_breakpoint (0, NULL, 0, 0, 0);
@


1.318
log
@gdb/
	Fix separate debuginfo warning with "remote:" access.
	* objfiles.h (struct objfile): New fields crc32 and crc32_p.
	* symfile.c (get_file_crc): New function with the code moved from ...
	(separate_debug_file_exists): ... this function, specifically variables
	buffer and count.  New variable verified_as_different, set it.  Remove
	file_crc initialization.  Verify also if both files are not the same
	manually, if needed.
@
text
@d1421 1
a1421 1
      if (verified_as_different || parent_objfile->crc32 != crc)
@


1.317
log
@	* linux-thread-db.c (thread_db_new_objfile): Only try to load
	libthread_db when we load libpthread or the main symbol file.
	(thread_db_inferior_created): New function.
	(_initialize_thread_db): Attach inferior_created observer.
	* linux-nat.c (linux_child_post_attach): Remove call to
	check_for_thread_db.
	(linux_child_post_startup_inferior): Ditto.
	* objfiles.h (OBJF_MAINLINE): Define.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Pass it to
	allocate_objfile when appropriate.
@
text
@d1314 37
d1355 2
a1356 1
  unsigned long file_crc = 0;
a1357 2
  gdb_byte buffer[8*1024];
  int count;
d1359 1
d1386 2
a1387 4
      && bfd_stat (parent_objfile->obfd, &parent_stat) == 0
      && abfd_stat.st_dev == parent_stat.st_dev
      && abfd_stat.st_ino == parent_stat.st_ino
      && abfd_stat.st_ino != 0)
d1389 7
a1395 2
      bfd_close (abfd);
      return 0;
d1397 2
d1400 1
a1400 2
  while ((count = bfd_bread (buffer, sizeof (buffer), abfd)) > 0)
    file_crc = gnu_debuglink_crc32 (file_crc, buffer, count);
d1404 3
d1409 17
a1425 3
      warning (_("the debug information found in \"%s\""
		 " does not match \"%s\" (CRC mismatch).\n"),
	       name, parent_objfile->name);
@


1.316
log
@gdb/
	* symfile.c (add_symbol_file_command): Update message on usage.
@
text
@d1084 1
d1101 1
a1101 1
      && (add_flags & SYMFILE_MAINLINE)
d1106 1
a1106 1
  objfile = allocate_objfile (abfd, flags);
@


1.315
log
@* solib-sunos.c (allocate_rt_common_objfile): Add missing arguments to
bcache_xmalloc,  replace bcache_xmalloc with call to
psymbol_bcache_init for psymbol_cache.
* symfile.c (reread_symbols): Remove extra calls to bcache_xmalloc.
@
text
@d2259 1
a2259 1
			     " [-mapped] [-readnow] [-s <secname> <addr>]*"));
@


1.314
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* ui-out.h (uiout): Rename to ...
	(current_uiout): ... this.
	* ui-out.c (uiout): Rename to ...
	(current_uiout): ... this.
	* ada-lang.c (print_it_exception, print_one_exception)
	(print_mention_exception): Adjust.
	* breakpoint.c (watchpoint_check): Adjust.
	(print_breakpoint_location, print_one_breakpoint, breakpoint_1)
	(default_collect_info, watchpoints_info, print_one_catch_fork)
	(print_one_catch_vfork, print_one_catch_syscall)
	(print_one_catch_exec, mention, print_it_ranged_breakpoint)
	(print_one_ranged_breakpoint, print_mention_ranged_breakpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_it_masked_watchpoint, print_mention_masked_watchpoint)
	(print_it_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint, say_where, bkpt_print_it)
	(bkpt_print_mention, momentary_bkpt_print_it)
	(tracepoint_print_mention, update_static_tracepoint)
	(tracepoints_info, save_breakpoints): Adjust.
	* cli-out.c (field_separator): Adjust.
	* cp-abi.c (list_cp_abis, show_cp_abi_cmd): Adjust.
	* exceptions.c (catch_exceptions_with_msg, catch_errors): Adjust.
	* frame.c (get_current_frame): Adjust.
	* infcmd.c (run_command_1, print_return_value): Adjust.
	* inferior.c (inferior_command, info_inferiors_command): Adjust.
	* infrun.c (print_end_stepping_range_reason): Adjust.
	(print_signal_exited_reason, print_exited_reason): Adjust.
	(print_signal_received_reason, print_no_history_reason): Adjust.
	* interps.c (interp_set): Adjust.
	* osdata.c (info_osdata_command): Adjust.
	* progspace.c (maintenance_info_program_spaces_command): Adjust.
	* remote-fileio.c (remote_fileio_request): Adjust.
	* remote.c (show_remote_cmd): Adjust.
	* solib.c (info_sharedlibrary_command): Adjust.
	* source.c (print_source_lines_base): Adjust.
	* stack.c (print_stack_frame): Adjust.
	(do_gdb_disassembly, print_frame_info, print_frame): Adjust.
	* symfile-mem.c (add_vsyscall_page): Adjust.
	* symfile.c (load_progress, generic_load)
	(print_transfer_performance): Adjust.
	* thread.c (info_threads_command, restore_selected_frame)
	(thread_command): Adjust.
	* top.c (make_cleanup_restore_ui_file): Adjust.
	* tracepoint.c (tvariables_info_1, trace_status_mi, tfind_1)
	(print_one_static_tracepoint_marker): Adjust.
	* cli/cli-cmds.c (print_disassembly): Adjust.
	* cli/cli-decode.c (print_doc_line): Adjust.
	* cli/cli-interp.c (safe_execute_command): Adjust.
	* cli/cli-logging.c (set_logging_redirect, pop_output_files)
	(handle_redirections): Adjust.
	* cli/cli-script.c (show_user_1): Adjust.
	* cli/cli-setshow.c (do_setshow_command, cmd_show_list): Adjust.
	* mi/mi-cmd-break.c (breakpoint_notify): Adjust.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Adjust.
	* mi/mi-cmd-env.c (mi_cmd_env_pwd, mi_cmd_env_path)
	(mi_cmd_env_dir): Adjust.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(print_partial_file_name, mi_cmd_file_list_exec_source_files): Adjust.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_depth, mi_cmd_stack_list_args)
	(list_args_or_locals): Adjust.
	* mi/mi-cmd-var.c (print_varobj, mi_cmd_var_create)
	(mi_cmd_var_delete, mi_cmd_var_set_format, mi_cmd_var_set_frozen)
	(mi_cmd_var_show_format, mi_cmd_var_info_num_children)
	(mi_cmd_var_list_children, mi_cmd_var_info_type)
	(mi_cmd_var_info_path_expression, mi_cmd_var_info_expression)
	(mi_cmd_var_show_attributes, mi_cmd_var_evaluate_expression)
	(mi_cmd_var_assign, mi_cmd_var_update, varobj_update_one): Adjust.
	* mi/mi-interp.c (mi_on_normal_stop): Adjust.
	* mi/mi-main.c (mi_cmd_gdb_exit, mi_cmd_thread_select)
	(mi_cmd_thread_list_ids, mi_cmd_thread_info, print_one_inferior)
	(list_available_thread_groups, mi_cmd_list_thread_groups)
	(mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers)
	(mi_cmd_data_list_register_values, get_register)
	(mi_cmd_data_evaluate_expression, mi_cmd_data_read_memory)
	(mi_cmd_data_read_memory_bytes, mi_cmd_list_features)
	(mi_cmd_list_target_features, mi_cmd_add_inferior)
	(mi_execute_command, mi_load_progress): Adjust.
	* mi/mi-symbol-cmds.c (mi_cmd_symbol_list_lines): Adjust.
	* python/py-auto-load.c (print_script, info_auto_load_scripts):
	Adjust.
	* python/py-breakpoint.c (bppy_get_commands): Adjust.
	* tui/tui-interp.c (tui_command_loop): Adjust.
	* tui/tui-io.c (tui_setup_io, tui_initialize_io): Adjust.
@
text
@a2474 3
	  objfile->psymbol_cache = psymbol_bcache_init ();
	  objfile->macro_cache = bcache_xmalloc (NULL, NULL);
	  objfile->filename_cache = bcache_xmalloc (NULL, NULL);
@


1.313
log
@gdb/
	Make addrs->SECTINDEX always defined.
	* symfile.c (relative_addr_info_to_section_offsets): Check for
	SECTINDEX -1, not for zero ADDR.
	(addrs_section_compar): Remove checking for invalid SECTINDEX.
	(addr_info_make_relative): Set SECTINDEX to -1 for unmatched entries.
	* symfile.h (struct section_addr_info) <sectindex>: Update the comment
	on its validity.
@
text
@d1867 1
a1867 1
      ui_out_message (uiout, 0, "Loading section %s, size %s lma %s\n",
d1979 1
d2107 1
@


1.312
log
@bfd/
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Do not check for
	SEC_LOAD.

gdb/
	Fix convert_code_addr_to_desc_addr for ppc64 files after eu-strip.
	* elfread.c (elf_symfile_read): New variable synth_abfd, pass it to
	bfd_get_synthetic_symtab.
	* jit.c (jit_register_code): Pass NULL to the new parameter parent.
	* machoread.c (macho_add_oso_symfile): Pass main_objfile to the new
	parameter parent, remove the call to add_separate_debug_objfile.
	* solib.c (solib_read_symbols): Pass NULL to the new parameter parent.
	* symfile-mem.c (symbol_file_add_from_memory): Likewise.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): New parameter
	parent, new comment for it, call add_separate_debug_objfile for it.
	(symbol_file_add_separate): Pass objfile as the parameter parent,
	remove the call to add_separate_debug_objfile.
	(symbol_file_add_from_bfd): New parameter parent, pass it.
	(symbol_file_add): Pass NULL to the new parameter parent.
	* symfile.h (symbol_file_add_from_bfd): New parameter parent.

gdb/testsuite/
	* gdb.base/eu-strip-infcall.c: New file.
	* gdb.base/eu-strip-infcall.exp: New file.
@
text
@d530 1
a530 1
      if (osp->addr == 0)
d571 1
a571 4
  /* SECTINDEX is undefined iff ADDR is zero.  */
  a_idx = a->addr == 0 ? 0 : a->sectindex;
  b_idx = b->addr == 0 ? 0 : b->sectindex;
  return a_idx - b_idx;
d734 1
a734 2

	  /* SECTINDEX is invalid if ADDR is zero.  */
@


1.311
log
@gdb
	* symfile.c (reread_symbols): Update.
	* objfiles.h (struct objfile) <cp_namespace_symtab>: Remove
	field.
	* objfiles.c (allocate_objfile): Update.
	* cp-support.h (cp_check_possible_namespace_symbols): Don't
	declare.
	* cp-namespace.c (lookup_symbol_file): Don't call
	lookup_possible_namespace_symbol.
	(initialize_namespace_symtab, get_possible_namespace_block)
	(free_namespace_block, cp_check_possible_namespace_symbols)
	(check_possible_namespace_symbols_loop)
	(check_one_possible_namespace_symbol)
	(lookup_possible_namespace_symbol): Remove.
	(maintenance_cplus_namespace): Replace with notice.
	(_initialize_cp_namespace): Deprecate `maint cplus namespace'.
gdb/testsuite
	* gdb.cp/maint.exp (test_help): Update.
	(test_namespace): Likewise.
@
text
@d1070 3
d1082 1
a1082 1
                                       int flags)
d1112 3
d1205 2
a1206 1
		       | OBJF_USERLOADED));
a1208 2

  add_separate_debug_objfile (new_objfile, objfile);
d1219 1
a1219 1
                          int flags)
d1222 1
a1222 1
                                                flags);
d1234 1
a1234 1
                                   flags);
@


1.310
log
@2011-03-23  Kai Tietz  <ktietz@@redhat.com>

	* breakpoint.c (clear_command): Use filename_cmp
	instead of strcmp for comparison.
	* buildsym.c (watch_main_source_file_lossage): Likewise.
	(patch_subfile_names): Use IS_DIR_SEPARATOR instead of
	checking just for slash.
	* dbxread.c (read_dbx_symtab): Use lbasename instead of
	strrchr and filename_cmp instead of strcmp for filenames.
	(add_old_header_file): Use filename_cmp
	instead of strcmp for comparison.
	* exec.c (exec_set_section_address): Likewise.
	* macrotab.c (macro_lookup_inclusion): Likewise.
	(macro_lookup_inclusion): Likewise.
	* elfread.c (_initialize_elfread): Likewise.
	(elfstab_offset_sections): Likewise.
	(elfstab_offset_sections): Use lbasename instead of
	strrchr.
	* mdebugread.c (parse_partial_symbols): Likewise.
	(arse_partial_symbols): Use filename_(n)cmp instead of
	str(n)cmp for comparison.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* psymtab.c (read_psymtabs_with_filename): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	(reload_shared_libraries_1): Likewise.
	* symmisc.c (maintenance_print_symbols): Likewise.
	* symfile.c (separate_debug_file_exists): Likewise.
	(reread_symbols): Likewise.
	(find_separate_debug_file_by_debuglink): Likewise.
	* remote-fileio.c (remote_fileio_func_rename): Likewise.
	* source.c (add_path): Likewise.
	* symtab.c (filename_seen): Likewise.
	(file_matches): Likewise.
	(print_symbol_info): Likewise.
	(maybe_add_partial_symtab_filename): Likewise.
	(make_source_files_completion_list): Likewise.
	* xml-syscall.c (init_sysinfo): Likewise.
	* windows-nat.c (_initialize_check_for_gdb_ini): Use
	IS_DIR_SEPARATOR for checking for trailing path separator.
@
text
@a2462 1
	  objfile->cp_namespace_symtab = NULL;
@


1.309
log
@	* xcoffread.c (xcoff_sym_fns): Update.
	* symfile.h (struct sym_fns) <sym_read_psymbols>: New field.
	(enum symfile_add_flags) <SYMFILE_NO_READ>: New constant.
	* symfile.c (syms_from_objfile): Handle SYMFILE_NO_READ.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	(reread_symbols): Handle OBJF_PSYMTABS_READ.
	* somread.c (som_sym_fns): Update.
	* psymtab.h (require_partial_symbols): Declare.
	* psymtab.c (require_partial_symbols): New function.
	(ALL_OBJFILE_PSYMTABS_REQUIRED): New macro.
	(ALL_OBJFILE_PSYMTABS): Undef.
	(ALL_PSYMTABS): Move from psympriv.h.
	(lookup_partial_symtab, find_pc_sect_psymtab)
	(lookup_symbol_aux_psymtabs, relocate_psymtabs)
	(find_last_source_symtab_from_partial)
	(forget_cached_source_info_partial)
	(print_psymtab_stats_for_objfile, read_symtabs_for_function)
	(expand_partial_symbol_tables, read_psymtabs_with_filename)
	(map_symbol_names_psymtab, map_symbol_filenames_psymtab)
	(find_symbol_file_from_partial, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial, maintenance_info_psymtabs):
	Use ALL_OBJFILE_PSYMTABS_REQUIRED.
	* psympriv.h (ALL_PSYMTABS): Move to psymtab.c.
	* objfiles.h (OBJF_PSYMTABS_READ): New macro.
	* objfiles.c (objfile_has_partial_symbols): Handle lazily-read
	psymtabs.
	* mipsread.c (ecoff_sym_fns): Update.
	* machoread.c (macho_sym_fns): Update.
	* elfread.c (elf_symfile_read): Set up for lazy psymtab reading.
	(read_psyms): New function.
	(elf_sym_fns, elf_sym_fns_gdb_index): Update.
	(elf_sym_fns_lazy_psyms): New global.
	* dwarf2read.c (dwarf2_initialize_objfile): Don't call
	dwarf2_build_psymtabs.
	* dbxread.c (aout_sym_fns): Update.
	* coffread.c (coff_sym_fns): Update.
@
text
@d1328 1
a1328 1
  if (strcmp (name, parent_objfile->name) == 0)
d1336 1
a1336 1
  /* Verify symlinks were not the cause of strcmp name difference above.
d1474 2
a1475 1
	  && strncmp (canon_name, gdb_sysroot, strlen (gdb_sysroot)) == 0
d2379 3
a2381 2
	  if (exec_bfd != NULL && strcmp (bfd_get_filename (objfile->obfd),
					  bfd_get_filename (exec_bfd)) == 0)
@


1.308
log
@2011-03-04  Michael Snyder  <msnyder@@vmware.com>

	* symfile.c (simple_overlay_update): Check for null return value
	from lookup_minimal_symbol.
@
text
@d1022 3
d1085 3
d1090 4
a1093 1
    flags |= OBJF_READNOW;
d1112 1
a1112 1
  if (from_tty || info_verbose)
d1133 1
a1133 1
      if (from_tty || info_verbose)
d1144 1
a1144 2
  if ((from_tty || info_verbose)
      && !objfile_has_symbols (objfile))
d1151 1
a1151 1
  if (from_tty || info_verbose)
d2508 6
@


1.307
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d3435 18
a3452 9
      /* Does its cached location match what's currently in the symtab?  */
      if (cache_ovly_table_base ==
	  SYMBOL_VALUE_ADDRESS (lookup_minimal_symbol ("_ovly_table",
						       NULL, NULL)))
	/* Then go ahead and try to look up this single section in the
	   cache.  */
	if (simple_overlay_update_1 (osect))
	  /* Found it!  We're done.  */
	  return;
@


1.306
log
@	* symfile.c (auto_solib_limit): Remove.
	* symfile.h (auto_solib_limit): Remove.
@
text
@d1700 1
a1700 2
   information about each format the the reader is prepared to
   handle.  */
@


1.305
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@a178 10

/* For systems that support it, a threshold size in megabytes.  If
   automatically adding a new library's symbol table to those already
   known to the debugger would cause the total shared library symbol
   size to exceed this threshhold, then the shlib's symbols are not
   added.  The threshold is ignored if the user explicitly asks for a
   shlib to be added, such as when using the "sharedlibrary"
   command.  */

int auto_solib_limit;
@


1.304
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d82 2
a83 2
/* Global variables owned by this file */
int readnow_symbol_files;	/* Read full symbols immediately */
d85 1
a85 1
/* External variables and functions referenced. */
d89 1
a89 1
/* Functions this file defines */
d144 1
a144 1
   prepared to read. */
d193 1
a193 1
   Note that the string at PTR does not have to be null terminated, I.E. it
d202 1
a202 1
     inline memcpy? */
d304 1
a304 1
   an existing section table. */
d375 1
a375 1
/* Free all memory allocated by build_section_addr_info_from_section_table. */
d534 1
a534 1
  /* Now calculate offsets for section that were specified by the caller. */
d543 1
a543 1
      /* Record all sections in offsets */
d545 1
a545 1
         the BFD index. */
d653 2
a654 1
  /* Now create ADDRS_TO_ABFD_ADDRS from ADDRS_SORTED and ABFD_ADDRS_SORTED.  */
d703 1
a703 1
	  /* This is the index used by BFD. */
d841 1
a841 1
     .rodata sections. */
d957 1
a957 1
    return;	/* No symbols. */
d965 1
a965 1
     no load address was specified. */
d1009 1
a1009 1
     initial symbol reading for this file. */
d1046 1
a1046 1
     old main symbol file. Otherwise it is sufficient to fixup all the
d1078 1
a1078 1
   Upon failure, jumps back to command level (never returns). */
d1112 1
a1112 1
     performed, or need to read an unmapped symbol table. */
d1130 1
a1130 1
     all partial symbol tables for this objfile if so. */
d1171 1
a1171 1
      return objfile;	/* No symbols. */
d1304 1
a1304 1
  /* Crc value is stored after the filename, aligned up to 4 bytes. */
d1328 1
a1328 1
     the separate debug infos with the same basename can exist. */
d1418 1
a1418 1
  /* Set I to max (strlen (canon_name), strlen (dir)). */
d1663 1
a1663 1
     bfd.  It'll be freed in free_objfile(). */
d1711 1
a1711 1
   handle. */
d2014 1
a2014 1
  /* Open the file for loading. */
d2079 1
a2079 1
/* Report how fast the transfer went. */
d2083 1
a2083 1
   function signature). */
d2155 1
a2155 1
   value to use. We are now discontinuing this type of ad hoc syntax. */
d2197 1
a2197 1
      /* Process the argument. */
d2200 1
a2200 1
	  /* The first argument is the file name. */
d2208 1
a2208 1
               to load the program. */
d2223 1
a2223 1
	       to an option */
d2270 1
a2270 1
  /* Print the prompt for the query below. And save the arguments into
d2274 1
a2274 1
     string. */
d2288 1
a2288 1
         entered on the command line. */
d2329 1
a2329 1
     and see if the symbol table that it originates from has been changed */
d2351 1
a2351 1
	  /* FIXME, should use print_sys_errmsg but it's not filtered. */
d2446 1
a2446 1
	  /* Free the obstacks for non-reusable objfiles */
d2596 1
a2596 1
  /* First arg is filename extension, starting with '.' */
d2609 1
a2609 1
  /* Null-terminate first arg */
d2631 1
a2631 1
      /* new file extension */
d2636 1
a2636 1
      /* redefining a previously known filename extension */
d2664 1
a2664 1
  if (fl_table_size == 0)	/* protect against repetition */
d2753 1
a2753 1
  /* Hook it to the objfile it comes from */
d2846 1
a2846 2
   the symbol's section is currently mapped
 */
d2851 1
a2851 1
int overlay_cache_invalid = 0;	/* True if need to refresh mapped state */
d2912 1
a2912 1
         there's really nothing useful to do here (can't really go auto)  */
d3031 1
a3031 1
      /* If the symbol has no section, just return its regular address. */
d3034 2
a3035 1
      /* If the symbol's section is not an overlay, just return its address */
d3038 1
a3038 1
      /* If the symbol's section is mapped, just return its address */
d3098 1
a3098 1
   Print a list of mapped sections and their PC ranges */
d3154 1
a3154 1
  /* First, find a section matching the user supplied argument */
d3158 1
a3158 1
      /* Now, check to see if the section is an overlay. */
d3162 1
a3162 1
      /* Mark the overlay as "mapped" */
d3174 1
a3174 1
	  sec2->ovly_mapped = 0;	/* sec2 overlaps sec: unmap sec2 */
d3199 1
a3199 1
  /* First, find a section matching the user supplied argument */
d3213 1
a3213 1
   Possibly this should be done via a set/show command. */
d3226 1
a3226 1
   Possibly this should be done via a set/show command. */
d3239 1
a3239 1
   Possibly this should be done via a set/show command. */
d3262 1
a3262 1
   A place-holder for a mis-typed command */
d3264 1
a3264 1
/* Command list chain containing all defined "overlay" subcommands. */
d3307 1
a3307 2
   the target (whenever possible).
 */
d3318 1
a3318 1
/* Throw away the cached copy of _ovly_table */
d3330 1
a3330 1
   Convert to host order.  int LEN is number of ints  */
d3335 1
a3335 1
  /* FIXME (alloca): Not safe if array is very large. */
d3345 1
a3345 1
   (and _novlys, which is needed for the table's size) */
d3423 1
a3423 1
	else	/* Warning!  Warning!  Target's ovly table has changed! */
d3442 1
a3442 1
  /* Were we given an osect to look up?  NULL means do all of them. */
d3444 1
a3444 1
    /* Have we got a cached copy of the target's overlay table? */
d3446 1
a3446 1
      /* Does its cached location match what's currently in the symtab? */
d3450 2
a3451 1
	/* Then go ahead and try to look up this single section in the cache */
d3453 1
a3453 1
	  /* Found it!  We're done. */
d3463 1
a3463 1
  /* Now may as well update all sections, even if only one was requested. */
d3476 1
a3476 1
	  { /* obj_section matches i'th entry in ovly_table */
d3478 1
a3478 1
	    break;		/* finished with inner for loop: break out */
@


1.303
log
@prevent the "load" command from repeating

This makes sure that the `load' command does not repeat when the user
presses Return again, as documented in the GDB User's Manual.

gdb/ChangeLog:

        * symfile.c (find_sym_fns): Add call to dont_repeat.
@
text
@d70 2
a71 1
int (*deprecated_ui_load_progress_hook) (const char *section, unsigned long num);
d163 2
a164 2
  fprintf_filtered (file, _("\
Dynamic symbol table reloading multiple times in one run is %s.\n"),
d215 4
a218 3
/* Concatenate NULL terminated variable argument list of `const char *' strings;
   return the new string.  Space is found in the OBSTACKP.  Argument list must
   be terminated by a sentinel expression `(char *) NULL'.  */
d831 2
a832 1
	      exec_set_section_address (bfd_get_filename (abfd), cur_sec->index,
d1378 3
a1380 2
  fprintf_filtered (file, _("\
The directory where separate debug symbols are searched for is \"%s\".\n"),
d1935 2
a1936 1
  new_request->end = new_request->begin + size; /* FIXME Should size be in instead?  */
d2256 2
a2257 1
		    error (_("USAGE: add-symbol-file <filename> <textaddress> [-mapped] [-readnow] [-s <secname> <addr>]*"));
d2582 3
a2584 2
  fprintf_filtered (file, _("\
Mapping between filename extension and source language is \"%s\".\n"),
d2604 2
a2605 1
    error (_("'%s': two arguments required -- filename extension and language"),
d2616 2
a2617 1
    error (_("'%s': two arguments required -- filename extension and language"),
d3146 3
a3148 3
    error (_("\
Overlay debugging not enabled.  Use either the 'overlay auto' or\n\
the 'overlay manual' command."));
d3191 3
a3193 3
    error (_("\
Overlay debugging not enabled.  Use either the 'overlay auto' or\n\
the 'overlay manual' command."));
d3448 2
a3449 1
	  SYMBOL_VALUE_ADDRESS (lookup_minimal_symbol ("_ovly_table", NULL, NULL)))
d3670 2
a3671 2
Usage: add-symbol-file FILE ADDR [-s <SECT> <SECT_ADDR> -s <SECT> <SECT_ADDR> ...]\n\
ADDR is the starting address of the file's text.\n\
@


1.302
log
@run copyright.sh for 2011.
@
text
@d1745 2
@


1.301
log
@Remove commented-out code in symfile.c

This patch removes some code that has been `#if 0'-ed since at least
1999 or 2000...

gdb/ChangeLog:

        * symfile.c: Remove all "#if 0"/"#endif" blocks.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.300
log
@symfile.c: Add missing second space after period.

gdb/ChangeLog:

        * symfile.c: Add missing second space after period in various comments.
@
text
@a89 5
#if 0
static int simple_read_overlay_region_table (void);
static void simple_free_overlay_region_table (void);
#endif

a3299 3
#if 0
static unsigned (*cache_ovly_region_table)[3] = 0;
#endif
a3300 3
#if 0
static unsigned cache_novly_regions = 0;
#endif
a3301 3
#if 0
static CORE_ADDR cache_ovly_region_table_base = 0;
#endif
a3317 13
#if 0
/* Throw away the cached copy of _ovly_region_table */
static void
simple_free_overlay_region_table (void)
{
  if (cache_ovly_region_table)
    xfree (cache_ovly_region_table);
  cache_novly_regions = 0;
  cache_ovly_region_table = NULL;
  cache_ovly_region_table_base = 0;
}
#endif

a3377 44
#if 0
/* Find and grab a copy of the target _ovly_region_table
   (and _novly_regions, which is needed for the table's size) */
static int
simple_read_overlay_region_table (void)
{
  struct minimal_symbol *msym;
  struct gdbarch *gdbarch;
  int word_size;
  enum bfd_endian byte_order;

  simple_free_overlay_region_table ();
  msym = lookup_minimal_symbol ("_novly_regions", NULL, NULL);
  if (msym == NULL)
    return 0;			/* failure */

  gdbarch = get_objfile_arch (msymbol_objfile (msym));
  word_size = gdbarch_long_bit (gdbarch) / TARGET_CHAR_BIT;
  byte_order = gdbarch_byte_order (gdbarch);

  cache_novly_regions = read_memory_integer (SYMBOL_VALUE_ADDRESS (msym),
					     4, byte_order);

  cache_ovly_region_table = (void *) xmalloc (cache_novly_regions * 12);
  if (cache_ovly_region_table != NULL)
    {
      msym = lookup_minimal_symbol ("_ovly_region_table", NULL, NULL);
      if (msym != NULL)
	{
	  cache_ovly_region_table_base = SYMBOL_VALUE_ADDRESS (msym);
	  read_target_long_array (cache_ovly_region_table_base,
				  (unsigned int *) cache_ovly_region_table,
				  cache_novly_regions * 3,
				  word_size, byte_order);
	}
      else
	return 0;		/* failure */
    }
  else
    return 0;			/* failure */
  return 1;			/* SUCCESS */
}
#endif

@


1.299
log
@gdb/
	Fix the `stopped language detection' testcase for gcc-4.5.
	* dwarf2read.c (read_partial_die): Set also LANGUAGE_OF_MAIN.
	* symfile.c (set_initial_language): Move variable filename to a more
	inner block.  Prefer LANGUAGE_OF_MAIN.
	* symtab.c (language_of_main): New variable.
	(set_main_name): Always reset LANGUAGE_OF_MAIN.
	* symtab.h (language_of_main): New declaration.
@
text
@d180 1
a180 1
   report all the functions that are actually present. */
d190 1
a190 1
   command. */
d198 1
a198 1
   may be part of a larger string and we are only saving a substring. */
d244 1
a244 1
/* True if we are reading a symbol table. */
@


1.298
log
@gdb/
	* infrun.c (follow_exec): Replace symbol_file_add_main by
	symbol_file_add with SYMFILE_DEFER_BP_RESET, set_initial_language and
	breakpoint_re_set.
	* m32r-rom.c (m32r_load, m32r_upload_command): Use parameter 0 for
	clear_symtab_users.
	* objfiles.c (free_all_objfiles): Likewise.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* solib-som.c (som_solib_create_inferior_hook): Likewise.
	* symfile.c (new_symfile_objfile): New comment for add_flags.  Call
	clear_symtab_users with ADD_FLAGS.
	(reread_symbols): Use parameter 0 for clear_symtab_users.
	(clear_symtab_users): New parameter add_flags.  Do not call
	breakpoint_re_set if SYMFILE_DEFER_BP_RESET.
	(clear_symtab_users_cleanup): Use parameter 0 for clear_symtab_users.
	* symtab.h (clear_symtab_users): New parameter add_flags.

gdb/testsuite/
	* gdb.base/pie-execl.exp: New file.
	* gdb.base/pie-execl.c: New file.
@
text
@a1570 1
  const char *filename;
d1573 10
a1582 3
  filename = find_main_filename ();
  if (filename != NULL)
    lang = deduce_language_from_filename (filename);
@


1.297
log
@	* symfile.h (allocate_symtab): Update.
	* symfile.c (allocate_symtab): Make 'filename' const.
	* psymtab.c (add_psymbol_to_bcache): Make 'name' const.
	(add_psymbol_to_list): Likewise.
	* psympriv.h (struct partial_symtab) <filename, dirname>: Now
	const.
	(add_psymbol_to_list): Update.
	* mdebugread.c (new_symtab): Make 'name' const.
	(psymtab_to_symtab_1): Make 'filename' const.
	* elfread.c (elfstab_offset_sections): Update.
	* dwarf2read.c (dwarf_decode_lines): Make 'comp_dir' const.
	(dwarf2_start_subfile): Make 'dirname' and 'comp_dir' const.
	(psymtab_include_file_name): Update.
	* dbxread.c (find_stab_function_addr): Make 'filename' const.
	* buildsym.h (start_subfile): Update.
	* buildsym.c (start_subfile): Make arguments const.
@
text
@d1041 1
a1041 1
   objfile. */
d1054 1
a1054 1
      clear_symtab_users ();
d2533 1
a2533 1
      clear_symtab_users ();
d2751 1
a2751 1
   table data.  */
d2754 1
a2754 1
clear_symtab_users (void)
d2764 2
a2765 1
  breakpoint_re_set ();
d2784 1
a2784 1
  clear_symtab_users ();
@


1.296
log
@	* symfile.h (struct sym_fns) <next>: Remove.
	(add_symtab_fns): Update.
	* symfile.c (sym_fns_ptr): New typedef.
	(symtab_fns): Now a VEC.
	(add_symtab_fns): Update.  Change argument type.
	(find_sym_fns): Update.  Change return type.
	(get_symfile_segment_data): Update.
	* objfiles.h (struct objfile) <sf>: Now const.
	* somread.c (som_sym_fns): Now const.  Update.
	* xcoffread.c (xcoff_sym_fns): Now const.  Update.
	* mipsread.c (ecoff_sym_fns): Now const.  Update.
	* machoread.c (macho_sym_fns): Now const.  Update.
	* elfread.c (elf_sym_fns): Now const.  Update.
	(elf_sym_fns_gdb_index): Likewise.
	* dbxread.c (aout_sym_fns): Now const.  Update.
	* coffread.c (coff_sym_fns): Now const.  Update.
@
text
@d2727 1
a2727 1
allocate_symtab (char *filename, struct objfile *objfile)
@


1.295
log
@Create and use a specialized bcache type for psymbols

2010-08-31  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symfile.c (reread_symbols): Use psymbol_bcache_free, and
	psymbol_bcache_init.
	* psymtab.h (psymbol_bcache_init): New function prototype.
	(psymbol_bcache_free): New function prototype.
	(psymbol_bcache_get_bcache): New function prototype.
	* psymtab.c (psymbol_bcache_init): New function.
	(psymbol_bcache_free): New function.
	(psymbol_bcache_full): New function.
	(psymbol_bcache_get_bcache): New function.
	(add_psymbol_to_bcache): use psymbol_bcache_full.
	* objfiles.h (psymbol_cache): Change type of psymbol_cache to
	psymbol_bcache.
	* symmisc.c (print_symbol_bcache_statistics): Updated.
	(print_objfile_statistics): Updated.
	* objfiles.c (allocate_objfile): Use psymbol_bcache_init to initialize
	psymbol_cache.
	(free_objfile): Use psymbol_bcache_free.
@
text
@d105 1
a105 1
static struct sym_fns *find_sym_fns (bfd *);
d150 4
a153 1
static struct sym_fns *symtab_fns = NULL;
d1708 1
a1708 1
add_symtab_fns (struct sym_fns *sf)
d1710 1
a1710 2
  sf->next = symtab_fns;
  symtab_fns = sf;
d1718 1
a1718 1
static struct sym_fns *
d1721 1
a1721 1
  struct sym_fns *sf;
d1723 1
d1730 1
a1730 1
  for (sf = symtab_fns; sf != NULL; sf = sf->next)
d3593 1
a3593 1
  struct sym_fns *sf = find_sym_fns (abfd);
@


1.294
log
@Enable custom bcache hash function.

2010-08-25  Sami Wagiaalla  <swagiaal@@redhat.com>

	* psymtab.c (add_psymbol_to_bcache): Remove 'static' from
	'static partial_symbol psymbol'.
	(psymbol_hash): New function.
	(psymbol_compare): New function.
	* bcache.c (hash_continue): New.
	(hash): Use hash_continue.
	* bcache.c: Add hash_function and compare_function
	pointers to bcache struct.
	(bcache_full): Use bcache->hash_function, and
	bcache->compare_function.
	(bcache_compare): New function.
	(bcache_xmalloc): Take hash_function and
	compare_function arguments and initialize the
	bcach's pointers.
	Updated comment.
	* objfiles.c (allocate_objfile): Updated.
	* symfile.c (reread_symbols): Updated.
	* python/py-type.c (typy_richcompare): Updated.
@
text
@d2434 2
a2435 3
	  bcache_xfree (objfile->psymbol_cache);
	  objfile->psymbol_cache = bcache_xmalloc (psymbol_hash,
	                                           psymbol_compare);
d2461 1
a2461 2
	  objfile->psymbol_cache = bcache_xmalloc (psymbol_hash,
	                                           psymbol_compare);
@


1.293
log
@gdb/
	* symfile.c (addr_section_name): New function.
	(addrs_section_compar): Use it.
	(addr_info_make_relative): Use it.  Move variable sect_name into a more
	inner block.  Make ".dynbss" and ".sdynbss" checks more strict.

gdb/testsuite/
	* gdb.base/prelink-lib.c (copyreloc): New initialized variable.
	* gdb.base/prelink.c (copyreloc, bssvar, bssvarp): New variables.
	(main): Use copyreloc.
	* gdb.base/prelink.exp (split debug of executable)
	(.dynbss vs. .bss address shift): New tests.
@
text
@d2435 2
a2436 1
	  objfile->psymbol_cache = bcache_xmalloc ();
d2438 1
a2438 1
	  objfile->macro_cache = bcache_xmalloc ();
d2440 1
a2440 1
	  objfile->filename_cache = bcache_xmalloc ();
d2462 4
a2465 3
	  objfile->psymbol_cache = bcache_xmalloc ();
	  objfile->macro_cache = bcache_xmalloc ();
	  objfile->filename_cache = bcache_xmalloc ();
@


1.292
log
@gdb
	PR c++/9946:
	* symfile.c (reread_symbols): Clear template_symbols.
	* symtab.h (struct symbol) <is_cplus_template_function>: New
	field.
	(SYMBOL_IS_CPLUS_TEMPLATE_FUNCTION): New macro.
	(struct template_symbol): New.
	* symtab.c (lookup_symbol_aux_local): Use
	cp_lookup_symbol_imports_or_template.
	* objfiles.h (struct objfile) <template_symbols>: New field.
	* objfiles.c (relocate_one_symbol): New function.
	(objfile_relocate1): Use it.  Relocate isolated symbols.
	* gdbtypes.h (struct cplus_struct_type) <n_template_arguments,
	template_arguments>: New fields.
	(TYPE_N_TEMPLATE_ARGUMENTS): New macro.
	(TYPE_TEMPLATE_ARGUMENTS): Likewise.
	(TYPE_TEMPLATE_ARGUMENT): Likewise.
	(lookup_typename): Update.
	* gdbtypes.c (lookup_typename): Constify "block" argument.
	* dwarf2read.c: Include vec.h.
	(symbolp): New typedef.
	(read_func_scope): Read template arguments.  Allocate a
	template_symbol when needed.
	(read_structure_type): Read template arguments.
	(new_symbol_full): New function, from new_symbol.  Handle
	DW_TAG_template_type_param and DW_TAG_template_value_param.
	(new_symbol): Rewrite as wrapper.
	* cp-support.h (cp_lookup_symbol_imports_or_template): Declare.
	* cp-namespace.c: Include language.h.
	(search_symbol_list): New function.
	(cp_lookup_symbol_imports_or_template): Likewise.
gdb/testsuite
	PR c++/9946:
	* gdb.cp/temargs.exp: New file.
	* gdb.cp/temargs.cc: New file.
@
text
@d550 17
d577 1
a577 1
  retval = strcmp (a->name, b->name);
d661 1
a661 1
      const char *sect_name = (*addrs_sorted)->name;
d664 2
a665 1
	     && strcmp ((*abfd_addrs_sorted)->name, sect_name) < 0)
d669 2
a670 1
	  && strcmp ((*abfd_addrs_sorted)->name, sect_name) == 0)
a697 1
      const char *sect_name = addrs->other[i].name;
d715 3
d728 3
a730 1
	     created by prelink have no special flags.  */
d734 8
a741 2
		|| strcmp (sect_name, ".dynbss") == 0
		|| strcmp (sect_name, ".sdynbss") == 0))
@


1.291
log
@gdb/
	* symfile.c (find_separate_debug_file_by_debuglink): Remove
	a gdb_assert call, new comment.

gdb/testsuite/
	* gdb.base/solib-nodir.exp: New file.
	* lib/gdb.exp (runto): New case for a GDB internal error.
@
text
@d2423 1
@


1.290
log
@	* symfile.c (set_initial_language): Update.
	(deduce_language_from_filename): Argument type now const.
	* symtab.h (find_main_filename): Update.
	(deduce_language_from_filename): Update.
	* symtab.c (find_main_filename): Make result const.
	* dwarf2read.c (dw2_find_symbol_file): Change return type.
	* psymtab.c (find_symbol_file_from_partial): Change return type.
	* symfile.h (struct quick_symbol_functions) <find_symbol_file>:
	Make result const.
@
text
@d1377 1
a1377 3
     followed by a slash.  Objfile names should always be absolute and
     tilde-expanded, so there should always be a slash in there
     somewhere.  */
d1383 1
a1383 1
  gdb_assert (i >= 0 && IS_DIR_SEPARATOR (dir[i]));
@


1.289
log
@gdb
	* breakpoint.c (save_cmdlist): No longer static.
	* gdbcmd.h (save_cmdlist): Declare.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Set
	OBJF_READNOW on objfile if readnow_symbol_files.
	* elfread.c (elf_symfile_read): Use dwarf2_initialize_objfile.
	(elf_sym_fns_gdb_index): New global.
	* dwarf2read.c: Include exceptions.h.
	(offset_type): New.
	(struct mapped_index): New.
	(dwarf2_per_cu_data_ptr): New typedef.
	(struct dwarf2_per_objfile) <using_index, index_table, gdb_index>:
	New fields.
	(GDB_INDEX_SECTION): New define.
	(struct dwarf2_per_cu_quick_data): New.
	(struct dwarf2_per_cu_data) <objfile>: New field.
	<psymtab>: Removed.
	<v>: New field.
	(byte_swap): New function.
	(MAYBE_SWAP): New macro.
	(INDEX_SUFFIX): New macro.
	(dw2_do_instantiate_symtab): New function.
	(dw2_instantiate_symtab): Likewise.
	(create_cus_from_index): Likewise.
	(create_addrmap_from_index): Likewise.
	(mapped_index_string_hash): Likewise.
	(find_slot_in_mapped_hash): Likewise.
	(dwarf2_read_index): Likewise.
	(dw2_setup): Likewise.
	(dw2_require_line_header): Likewise.
	(dw2_require_full_path): Likewise.
	(dw2_find_last_source_symtab): Likewise.
	(dw2_forget_cached_source_info): Likewise.
	(dw2_lookup_symtab): Likewise.
	(dw2_lookup_symbol): Likewise.
	(dw2_do_expand_symtabs_matching): Likewise.
	(dw2_pre_expand_symtabs_matching): Likewise.
	(dw2_print_stats): Likewise.
	(dw2_dump): Likewise.
	(dw2_relocate): Likewise.
	(dw2_expand_symtabs_for_function): Likewise.
	(dw2_expand_all_symtabs): Likewise.
	(dw2_expand_symtabs_with_filename): Likewise.
	(dw2_find_symbol_file): Likewise.
	(dw2_map_ada_symtabs): Likewise.
	(dw2_expand_symtabs_matching): Likewise.
	(dw2_find_pc_sect_symtab): Likewise.
	(dw2_map_symbol_names): Likewise.
	(dw2_map_symbol_filenames): Likewise.
	(dw2_has_symbols): Likewise.
	(dwarf2_gdb_index_functions): New global.
	(dwarf2_initialize_objfile): New function.
	(process_psymtab_comp_unit): Update.
	(add_partial_subprogram): Likewise.
	(dwarf2_psymtab_to_symtab): Likewise.
	(psymtab_to_symtab_1): Use dw2_do_instantiate_symtab.
	(process_full_comp_unit): Update.
	(find_file_and_directory): New function.
	(read_file_scope): Use find_file_and_directory.
	(dwarf2_per_cu_objfile): Update.
	(dwarf2_per_cu_addr_size): Update.
	(dwarf2_per_cu_offset_size): Update.
	(dwarf2_free_objfile): Free the index, if needed.
	(dwarf2_per_objfile_free): Unmap the index, if needed.
	(struct strtab_entry): New.
	(hash_strtab_entry): New function.
	(eq_strtab_entry): Likewise.
	(create_strtab): Likewise.
	(add_string): Likewise.
	(struct symtab_index_entry): New.
	(struct mapped_symtab): New.
	(hash_symtab_entry): New function.
	(eq_symtab_entry): Likewise.
	(delete_symtab_entry): Likewise.
	(create_index_table): Likewise.
	(create_mapped_symtab): Likewise.
	(cleanup_mapped_symtab): Likewise.
	(find_slot): Likewise.
	(hash_expand): Likewise.
	(add_index_entry): Likewise.
	(add_indices_to_cpool): Likewise.
	(write_hash_table): Likewise.
	(add_address_entry): Likewise.
	(write_psymbols): Likewise.
	(write_obstack): Likewise.
	(unlink_if_set): Likewise.
	(write_psymtabs_to_index): Likewise.
	(save_gdb_index_command): Likewise.
	(_initialize_dwarf2_read): Install "save gdb-index"
	command.
	(create_all_comp_units): Initialize 'objfile' field of CU.
	(dwarf2_locate_sections): Check for .gdb_index.
	* psymtab.h (dwarf2_gdb_index_functions): Declare.
	* symfile.h (dwarf2_initialize_objfile): Declare.
gdb/doc
	* gdb.texinfo (Index Files): New node.
@
text
@d1541 1
a1541 1
  char *filename;
d2668 1
a2668 1
deduce_language_from_filename (char *filename)
@


1.288
log
@gdb/
	* symfile.c (init_filename_language_table): New extensions .for, .FOR,
	.ftn, .FTN, .fpp, .FPP, .f90, .F90, .f95, .F95, .f03, .F03, .f08 and
	.F08.

gdb/testsuite/
	* gdb.fortran/module.exp (stopped language detection): New test.
@
text
@d1062 3
d1101 1
a1101 1
  if ((flags & OBJF_READNOW) || readnow_symbol_files)
@


1.288.2.1
log
@gdb/
	* symfile.c (find_separate_debug_file_by_debuglink): Remove
	a gdb_assert call, new comment.

gdb/testsuite/
	* gdb.base/solib-nodir.exp: New file.
	* lib/gdb.exp (runto): New case for a GDB internal error.
@
text
@d1374 3
a1376 1
     followed by a slash.  The directory can be relative or absolute.  */
d1382 1
a1382 1
  /* If I is -1 then no directory is present there and DIR will be "".  */
@


1.288.2.2
log
@gdb/
	* symfile.c (addr_section_name): New function.
	(addrs_section_compar): Use it.
	(addr_info_make_relative): Use it.  Move variable sect_name into a more
	inner block.  Make ".dynbss" and ".sdynbss" checks more strict.

gdb/testsuite/
	* gdb.base/prelink-lib.c (copyreloc): New initialized variable.
	* gdb.base/prelink.c (copyreloc, bssvar, bssvarp): New variables.
	(main): Use copyreloc.
	* gdb.base/prelink.exp (split debug of executable)
	(.dynbss vs. .bss address shift): New tests.
@
text
@a549 17
/* Transform section name S for a name comparison.  prelink can split section
   `.bss' into two sections `.dynbss' and `.bss' (in this order).  Similarly
   prelink can split `.sbss' into `.sdynbss' and `.sbss'.  Use virtual address
   of the new `.dynbss' (`.sdynbss') section as the adjacent new `.bss'
   (`.sbss') section has invalid (increased) virtual address.  */

static const char *
addr_section_name (const char *s)
{
  if (strcmp (s, ".dynbss") == 0)
    return ".bss";
  if (strcmp (s, ".sdynbss") == 0)
    return ".sbss";

  return s;
}

d560 1
a560 1
  retval = strcmp (addr_section_name (a->name), addr_section_name (b->name));
d644 1
a644 1
      const char *sect_name = addr_section_name ((*addrs_sorted)->name);
d647 1
a647 2
	     && strcmp (addr_section_name ((*abfd_addrs_sorted)->name),
			sect_name) < 0)
d651 1
a651 2
	  && strcmp (addr_section_name ((*abfd_addrs_sorted)->name),
		     sect_name) == 0)
d679 1
a696 3
	  /* addr_section_name transformation is not used for SECT_NAME.  */
	  const char *sect_name = addrs->other[i].name;

d707 1
a707 3
	     created by prelink have no special flags.

	     For the sections `.bss' and `.sbss' see addr_section_name.  */
d711 2
a712 8
		|| (strcmp (sect_name, ".bss") == 0
		    && i > 0
		    && strcmp (addrs->other[i - 1].name, ".dynbss") == 0
		    && addrs_to_abfd_addrs[i - 1] != NULL)
		|| (strcmp (sect_name, ".sbss") == 0
		    && i > 0
		    && strcmp (addrs->other[i - 1].name, ".sdynbss") == 0
		    && addrs_to_abfd_addrs[i - 1] != NULL)))
@


1.287
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* scm-exp.c: White space.
	* scm-lang.c: White space.
	* scm-valprint.c: White space.
	* sentinel-frame.c: White space.
	* ser-base.c: White space.
	* ser-go32.c: White space.
	* serial.c: White space.
	* ser-mingw.c: White space.
	* ser-pipe.c: White space.
	* ser-tcp.c: White space.
	* ser-unix.c: White space.
	* solib.c: White space.
	* solib-darwin.c: White space.
	* solib-frv.c: White space.
	* solib-irix.c: White space.
	* solib-osf.c: White space.
	* solib-pa64.c: White space.
	* solib-som.c: White space.
	* solib-spu.c: White space.
	* solib-svr4.c: White space.
	* solib-target.c: White space.
	* source.c: White space.
	* stabsread.c: White space.
	* stack.c: White space.
	* std-regs.c: White space.
	* symfile.c: White space.
	* symmisc.c: White space.
	* symtab.c: White space.
@
text
@d2636 14
@


1.286
log
@gdb/
	* dwarf2read.c (typename_concat): Use (char *) NULL terminated stdarg
	list for the obconcat call.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol, read_member_functions, read_cpp_abbrev):
	Likewise.
	* symfile.c (obconcat): Replace the s1, s2 and s3 parameters by `...'.
	New variable ap.  Remove variables len and val.
	* symfile.h (obconcat): Likewise for the prototype.
@
text
@d208 1
a1013 1

d1611 1
@


1.285
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* psymtab.c (lookup_partial_symbol): Delete unused variable.
	(find_last_source_symtab_from_partial): Delete unused variable.
	* symfile.c (place_section): Delete unused variable.
	(default_symfile_offsets): Delete unused variable.
	(get_debug_link_info): Delete unused variable.
	(find_separate_debug_file_by_debuglink): Delete unused variable.
	(add_symbol_file_command): Delete unused variable.
	(symfile_find_segment_sections): Delete unused variable.
	* symmisc.c (free_symtab): Delete unused variable.
	(dump_symtab_1): Delete unused variable.
	* symtab.c (lookup_symbil_aux_quick): Delete unused variable.
	(find_pc_sect_symtab): Delete unused variable.
	(skip_prologue_using_lineinfo): Delete unused variable.
	(sources_info): Delete unused variable.
	(completion_list_add_name): Delete unused variable.
	(expand_line_sal): Delete unused variable.
@
text
@d215 3
a217 2
/* Concatenate strings S1, S2 and S3; return the new string.  Space is found
   in the obstack pointed to by OBSTACKP.  */
d220 1
a220 2
obconcat (struct obstack *obstackp, const char *s1, const char *s2,
	  const char *s3)
d222 16
a237 6
  int len = strlen (s1) + strlen (s2) + strlen (s3) + 1;
  char *val = (char *) obstack_alloc (obstackp, len);
  strcpy (val, s1);
  strcat (val, s2);
  strcat (val, s3);
  return val;
@


1.284
log
@D language support.

gdb/ChangeLog:

        D language support.
        * Makefile.in (SFILES): Add d-lang.c d-valprint.c.
        (COMMON_OBS): Add d-lang.o d-valprint.o.
        (HFILES_NO_SRCDIR): Add d-lang.h.
        * NEWS: Mention D language support.
        * c-lang.c (c_emit_char, exp_descriptor_c): Make public.
        * c-lang.h (c_emit_char, exp_descriptor_c): Add declaration.
        * d-lang.c: New file.
        * d-lang.h: New file.
        * d-valprint.c: New file.
        * defs.h (enum language): Add language_d.
        * dwarf2read.c (set_cu_language): Add DW_LANG_D.
        * language.c (binop_result_type, integral_type, character_type)
        (string_type, boolean_type, structured_type): Add language_d.
        * symfile.c (init_filename_language_table): Add language_d.
        * symtab.c: Include d-lang.h.
        (symbol_init_language_specific, symbol_find_demangled_name)
        (symbol_natural_name, lookup_symbol_in_language)
        (symbol_demangled_name, symbol_matches_domain): Add language_d.

gdb/doc/ChangeLog:

        * gdb.texinfo: (Summary) Add mention about D language support.
        (Filenames): Add D suffixes.
        (D): New node.

gdb/testsuite/ChangeLog:

        * gdb.base/default.exp: Fix "set language" test.
@
text
@a475 1
	CORE_ADDR cur_offset;
a740 1
      CORE_ADDR lowest = 0;
a1247 1
  unsigned char *p;
d1347 1
a1347 2
  asection *sect;
  char *basename, *name_copy, *debugdir;
a1350 1
  bfd_size_type debuglink_size;
a2110 1
  int expecting_option = 0;
a3626 1
      CORE_ADDR vma;
@


1.283
log
@Associate .dg files to Ada

The .dg files are files containing the user's code, after the GNAT
expander was applied.  The expansion replaces some of the complex
features by simpler pseudo-Ada code and the user can ask to see and
debug that code using the -gnatDG option...

For instance, given the following code where Circle is a tagged type
(aka as a class type in C++):

    procedure Foo is
       My_Shape : Circle := (X => 1, Y => 2, R => 3);
       X : Integer;
    begin
       X := Position_X (My_Shape);
    end Foo;

The expansion results in:

    procedure foo is
       my_shape : pck__circle := (
          _parent => (
             _tag => pck__circleP,
             x => 1,
             y => 2),
          r => 3);
       x : integer;
    begin
       x := pck__position_x (my_shape);
       return;
    end foo;

2010-04-27  Joel Brobecker  <brobecker@@adacore.com>

        * symfile.c (init_filename_language_table): Register .dg files
        with language_ada.
@
text
@d2619 1
@


1.282
log
@Check library name rather than member name when rereading symbols.

On Darwin, we have lots of complaints being emitted when restarting
a program:

    (gdb) start
    `a-except.o' has disappeared; keeping its symbols.
    `unwind-dw2.o' has disappeared; keeping its symbols.
    `s-except.o' has disappeared; keeping its symbols.
    `s-traceb.o' has disappeared; keeping its symbols.

These object files are part of the GNAT runtime, and were never available.
The warning comes from the fact that we're checking whether the .o files
in the GNAT shared runtime have changed whereas we should be checking
whether the GNAT shared library itself has changed.

This patch implements this.  Although it is really only useful on a platform
such as Darwin (debug info stored in .o files), we believe that this is
the right thing to do in general.  This change should be a noop for all
the other platforms in any case.

gdb/ChangeLog (from Tristan Gingold & Pedro Alves):

        * symfile.c (reread_symbols): Also search for file in libraries.
        Update comment.

Tested on x86_64-darwin and x86_64-linux.
@
text
@d2640 1
@


1.281
log
@gdb/
	* objfiles.c: Include solist.h.
	(free_all_objfiles): New variable so.  Check stale solist objfiles.
	* symfile.c (symbol_file_clear): Swap the order of free_all_objfiles
	and no_shared_libraries.
@
text
@d2293 4
a2296 4
#ifdef DEPRECATED_IBM6000_TARGET
      /* If this object is from a shared library, then you should
	 stat on the library name, not member name. */

a2299 1
#endif
@


1.280
log
@gdb/
	* symfile.c (build_section_addr_info_from_bfd): New.
	(build_section_addr_info_from_objfile): Base it on
	build_section_addr_info_from_bfd.
	(addrs_section_compar, addrs_section_sort): New.
	(addr_info_make_relative): New variables my_cleanup, abfd_addrs,
	addrs_sorted, abfd_addrs_sorted and addrs_to_abfd_addrs.  Build
	addrs_to_abfd_addrs.  Use it for recalculating ADDRS.

gdb/testsuite/
	* gdb.base/dup-sect.exp, gdb.base/dup-sect.S: New.
@
text
@d1231 4
a1236 5
  /* solib descriptors may have handles to objfiles.  Since their
     storage has just been released, we'd better wipe the solib
     descriptors as well.  */
  no_shared_libraries (NULL, from_tty);

@


1.279
log
@	* symfile.c (generic_load): Reset breakpoints after loading.
@
text
@d322 1
a322 1
/* Create a section_addr_info from section offsets in OBJFILE.  */
d324 2
a325 2
struct section_addr_info *
build_section_addr_info_from_objfile (const struct objfile *objfile)
d331 3
a333 3
  sap = alloc_section_addr_info (objfile->num_sections);
  for (i = 0, sec = objfile->obfd->sections; sec != NULL; sec = sec->next)
    if (bfd_get_section_flags (objfile->obfd, sec) & (SEC_ALLOC | SEC_LOAD))
d335 2
a336 4
	sap->other[i].addr = (bfd_get_section_vma (objfile->obfd, sec)
			      + objfile->section_offsets->offsets[i]);
	sap->other[i].name = xstrdup (bfd_get_section_name (objfile->obfd,
							    sec));
d343 20
d540 40
d590 4
d608 49
d670 1
a670 1
      asection *sect = bfd_get_section_by_name (abfd, sect_name);
d675 1
a675 1
	  addrs->other[i].sectindex = sect->index;
d679 1
a679 1
	      addrs->other[i].addr -= bfd_section_vma (abfd, sect);
d711 2
@


1.278
log
@gdb/
	* symfile.c (addr_info_make_relative): Ignore also missing ".dynbss"
	and ".sdynbss".  Update the comment.
@
text
@d1896 10
@


1.277
log
@gdb
	* xcoffread.c: Include psymtab.h.
	(xcoff_sym_fns): Update.
	* symtab.h (struct partial_symbol): Remove.
	(PSYMBOL_DOMAIN, PSYMBOL_CLASS): Remove.
	(struct partial_symtab): Remove.
	(PSYMTAB_TO_SYMTAB): Remove.
	(lookup_partial_symbol, lookup_partial_symtab, find_pc_psymtab)
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): Declare.
	(find_pc_psymtab, find_pc_sect_psymbol, psymtab_to_symtab)
	(find_main_psymtab): Remove.
	(find_main_filename): Declare.
	(fixup_psymbol_section): Remove.
	(fixup_section): Declare.
	* symtab.c: Include psymtab.h.
	(lookup_symtab): Use lookup_symtab method.
	(lookup_partial_symtab): Remove.
	(find_pc_sect_psymtab_closer): Remove.
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): New function.
	(find_pc_psymtab, find_pc_sect_psymbol, find_pc_psymbol): Remove.
	(fixup_section): No longer static.
	(fixup_psymbol_section): Remove.
	(lookup_symbol_aux): Use lookup_symbol_aux_quick.
	(lookup_global_symbol_from_objfile): Likewise.
	(lookup_symbol_aux_psymtabs): Remove.
	(lookup_symbol_aux_quick): New function.
	(lookup_symbol_global): Use lookup_symbol_aux_quick.
	(lookup_partial_symbol): Remove.
	(basic_lookup_transparent_type_quick): New function.
	(basic_lookup_transparent_type): Use it.
	(find_main_psymtab): Remove.
	(find_main_filename): New function.
	(find_pc_sect_symtab): Use find_pc_sect_symtab method.
	(find_line_symtab): Use expand_symtabs_with_filename method.
	(output_partial_symbol_filename): New function.
	(sources_info): Use map_partial_symbol_filenames.
	(struct search_symbols_data): New type.
	(search_symbols_file_matches): New function.
	(search_symbols_name_matches): Likewise.
	(search_symbols): Use expand_symtabs_matching method.
	(struct add_name_data): Rename from add_macro_name_data.
	(add_macro_name): Update.
	(add_partial_symbol_name): New function.
	(default_make_symbol_completion_list): Use
	map_partial_symbol_names.
	(struct add_partial_symbol_name): New type.
	(maybe_add_partial_symtab_filename): New function.
	(make_source_files_completion_list): Use
	map_partial_symbol_filenames.
	(expand_line_sal): Use expand_symtabs_with_filename method.
	* symmisc.c: Include psymtab.h.
	(print_objfile_statistics): Use print_stats method.
	(dump_objfile): Use dump method.
	(dump_psymtab, maintenance_print_psymbols)
	(maintenance_info_psymtabs, maintenance_check_symtabs)
	(extend_psymbol_list): Remove.
	* symfile.h (struct quick_symbol_functions): New struct.
	(struct sym_fns) <qf>: New field.
	(sort_pst_symbols): Remove.
	(increment_reading_symtab): Declare.
	* symfile.c: Include psymtab.h.
	(compare_psymbols, sort_pst_symbols): Remove.
	(psymtab_to_symtab): Remove.
	(increment_reading_symtab): New function.
	(symbol_file_add_with_addrs_or_offsets): Use expand_all_symtabs
	method.
	(set_initial_language): Use find_main_filename.
	(allocate_psymtab, discard_psymtab, cashier_psymtab): Remove.
	(free_named_symtabs): Remove unused code.
	(start_psymtab_common, add_psymbol_to_bcache)
	(append_psymbol_to_list, add_psymbol_to_list, init_psymbol_list):
	Remove.
	* stack.c: Include psymtab.h, symfile.h.
	(backtrace_command_1): Use find_pc_sect_symtab_via_partial.
	* source.h (psymtab_to_fullname): Don't declare.
	* source.c: Include psymtab.h.
	(select_source_symtab): Use find_last_source_symtab method.
	(forget_cached_source_info): Use forget_cached_source_info
	method.
	(find_and_open_source): No longer static.
	(psymtab_to_fullname): Remove.
	* somread.c: Include psymtab.h.
	(som_sym_fns): Update.
	* psympriv.h: New file.
	* psymtab.h: New file.
	* psymtab.c: New file.
	* objfiles.h: (ALL_OBJFILE_PSYMTABS): Remove.
	(ALL_PSYMTABS, ALL_PSPACE_PSYMTABS): Likewise.
	* objfiles.c: Include psymtab.h.
	(objfile_relocate1): Use relocate method.
	(objfile_has_partial_symbols): Use has_symbols method.
	* mipsread.c: Include psymtab.h.
	(ecoff_sym_fns): Update.
	* mi/mi-cmd-file.c: Include psymtab.h.
	(print_partial_file_name): New function.
	(mi_cmd_file_list_exec_source_files): Use
	map_partial_symbol_filenames.
	* mdebugread.c: Include psympriv.h.
	* machoread.c: Include psympriv.h.
	(macho_sym_fns): Update.
	* m2-exp.y (yylex): Use lookup_symtab.
	* elfread.c: Include psympriv.h.
	(elf_sym_fns): Update.
	* dwarf2read.c: Include psympriv.h.
	* dbxread.c: Include psympriv.h.
	(aout_sym_fns): Update.
	* cp-support.c: Include psymtab.h.
	(read_in_psymtabs): Remove.
	(make_symbol_overload_list_qualified): Use
	expand_symtabs_for_function method.
	* coffread.c: Include psympriv.h.
	(coff_sym_fns): Update.
	* blockframe.c: Include psymtab.h.
	(find_pc_partial_function): Use find_pc_sect_symtab method.
	* ada-lang.h (ada_update_initial_language): Update.
	* ada-lang.c: Include psymtab.h.
	(ada_update_initial_language): Remove 'main_pst' argument.
	(ada_lookup_partial_symbol): Remove.
	(struct ada_psym_data): New type.
	(ada_add_psyms): New function.
	(ada_add_non_local_symbols): Use map_ada_symtabs method.
	(struct add_partial_datum): New type.
	(ada_add_partial_symbol_completions): New function.
	(ada_make_symbol_completion_list): Use map_partial_symbol_names.
	(ada_exception_support_info_sniffer): Update.
	* Makefile.in (SFILES): Add psymtab.c.
	(COMMON_OBS): Add psymtab.o.
	(HFILES_NO_SRCDIR): Add psymtab.h, psympriv.h.
gdb/doc
	* gdbint.texinfo (Symbol Handling): Update.
@
text
@d579 8
a586 7
	     However, the ELF prelinker does create a couple of sections
	     (".gnu.liblist" and ".gnu.conflict") which are marked in the main
	     executable as loadable (they are loaded in memory from the
	     DYNAMIC segment) and yet are not present in separate debug info
	     files.  This is fine, and should not cause a warning.  Shared
	     libraries contain just the section ".gnu.liblist" but it is not
	     marked as loadable there.  */
d589 3
a591 1
		|| strcmp (sect_name, ".gnu.conflict") == 0))
@


1.276
log
@gdb/
	* symfile.c (addr_info_make_relative): New variable sect_name, use it.
	Do not warn on ".gnu.liblist" and ".gnu.conflict".
@
text
@d68 1
a191 23
/* This compares two partial symbols by names, using strcmp_iw_ordered
   for the comparison.  */

static int
compare_psymbols (const void *s1p, const void *s2p)
{
  struct partial_symbol *const *s1 = s1p;
  struct partial_symbol *const *s2 = s2p;

  return strcmp_iw_ordered (SYMBOL_SEARCH_NAME (*s1),
			    SYMBOL_SEARCH_NAME (*s2));
}

void
sort_pst_symbols (struct partial_symtab *pst)
{
  /* Sort the global list; don't sort the static list */

  qsort (pst->objfile->global_psymbols.list + pst->globals_offset,
	 pst->n_global_syms, sizeof (struct partial_symbol *),
	 compare_psymbols);
}

d230 1
a230 1
/* True if we are nested inside psymtab_to_symtab. */
d240 4
a243 7
/* Get the symbol table that corresponds to a partial_symtab.
   This is fast after the first time you do it.  In fact, there
   is an even faster macro PSYMTAB_TO_SYMTAB that does the fast
   case inline.  */

struct symtab *
psymtab_to_symtab (struct partial_symtab *pst)
d245 2
a246 14
  /* If it's been looked up before, return it. */
  if (pst->symtab)
    return pst->symtab;

  /* If it has not yet been read in, read it.  */
  if (!pst->readin)
    {
      struct cleanup *back_to = make_cleanup (decrement_reading_symtab, NULL);
      currently_reading_symtab++;
      (*pst->read_symtab) (pst);
      do_cleanups (back_to);
    }

  return pst->symtab;
a933 1
  struct partial_symtab *psymtab;
d983 2
a984 6
      for (psymtab = objfile->psymtabs;
	   psymtab != NULL;
	   psymtab = psymtab->next)
	{
	  psymtab_to_symtab (psymtab);
	}
d1418 1
a1418 1
  struct partial_symtab *pst;
d1421 5
a1425 2
  pst = find_main_psymtab ();
  if (pst != NULL)
d1427 3
a1429 2
      if (pst->filename != NULL)
	lang = deduce_language_from_filename (pst->filename);
d1431 2
a1432 9
      if (lang == language_unknown)
	{
	  /* Make C the default language */
	  lang = language_c;
	}

      set_language (lang);
      expected_language = current_language; /* Don't warn the user.  */
    }
a2568 67

struct partial_symtab *
allocate_psymtab (const char *filename, struct objfile *objfile)
{
  struct partial_symtab *psymtab;

  if (objfile->free_psymtabs)
    {
      psymtab = objfile->free_psymtabs;
      objfile->free_psymtabs = psymtab->next;
    }
  else
    psymtab = (struct partial_symtab *)
      obstack_alloc (&objfile->objfile_obstack,
		     sizeof (struct partial_symtab));

  memset (psymtab, 0, sizeof (struct partial_symtab));
  psymtab->filename = (char *) bcache (filename, strlen (filename) + 1,
				       objfile->filename_cache);
  psymtab->symtab = NULL;

  /* Prepend it to the psymtab list for the objfile it belongs to.
     Psymtabs are searched in most recent inserted -> least recent
     inserted order. */

  psymtab->objfile = objfile;
  psymtab->next = objfile->psymtabs;
  objfile->psymtabs = psymtab;
#if 0
  {
    struct partial_symtab **prev_pst;
    psymtab->objfile = objfile;
    psymtab->next = NULL;
    prev_pst = &(objfile->psymtabs);
    while ((*prev_pst) != NULL)
      prev_pst = &((*prev_pst)->next);
    (*prev_pst) = psymtab;
  }
#endif

  return (psymtab);
}

void
discard_psymtab (struct partial_symtab *pst)
{
  struct partial_symtab **prev_pst;

  /* From dbxread.c:
     Empty psymtabs happen as a result of header files which don't
     have any symbols in them.  There can be a lot of them.  But this
     check is wrong, in that a psymtab with N_SLINE entries but
     nothing else is not empty, but we don't realize that.  Fixing
     that without slowing things down might be tricky.  */

  /* First, snip it out of the psymtab chain */

  prev_pst = &(pst->objfile->psymtabs);
  while ((*prev_pst) != pst)
    prev_pst = &((*prev_pst)->next);
  (*prev_pst) = pst->next;

  /* Next, put it on a free list for recycling */

  pst->next = pst->objfile->free_psymtabs;
  pst->objfile->free_psymtabs = pst;
}
a2606 163
/* Allocate and partially fill a partial symtab.  It will be
   completely filled at the end of the symbol list.

   FILENAME is the name of the symbol-file we are reading from. */

struct partial_symtab *
start_psymtab_common (struct objfile *objfile,
		      struct section_offsets *section_offsets,
		      const char *filename,
		      CORE_ADDR textlow, struct partial_symbol **global_syms,
		      struct partial_symbol **static_syms)
{
  struct partial_symtab *psymtab;

  psymtab = allocate_psymtab (filename, objfile);
  psymtab->section_offsets = section_offsets;
  psymtab->textlow = textlow;
  psymtab->texthigh = psymtab->textlow;		/* default */
  psymtab->globals_offset = global_syms - objfile->global_psymbols.list;
  psymtab->statics_offset = static_syms - objfile->static_psymbols.list;
  return (psymtab);
}

/* Helper function, initialises partial symbol structure and stashes 
   it into objfile's bcache.  Note that our caching mechanism will
   use all fields of struct partial_symbol to determine hash value of the
   structure.  In other words, having two symbols with the same name but
   different domain (or address) is possible and correct.  */

static const struct partial_symbol *
add_psymbol_to_bcache (char *name, int namelength, int copy_name,
		       domain_enum domain,
		       enum address_class class,
		       long val,	/* Value as a long */
		       CORE_ADDR coreaddr,	/* Value as a CORE_ADDR */
		       enum language language, struct objfile *objfile,
		       int *added)
{
  /* psymbol is static so that there will be no uninitialized gaps in the
     structure which might contain random data, causing cache misses in
     bcache. */
  static struct partial_symbol psymbol;

  /* However, we must ensure that the entire 'value' field has been
     zeroed before assigning to it, because an assignment may not
     write the entire field.  */
  memset (&psymbol.ginfo.value, 0, sizeof (psymbol.ginfo.value));
  /* val and coreaddr are mutually exclusive, one of them *will* be zero */
  if (val != 0)
    {
      SYMBOL_VALUE (&psymbol) = val;
    }
  else
    {
      SYMBOL_VALUE_ADDRESS (&psymbol) = coreaddr;
    }
  SYMBOL_SECTION (&psymbol) = 0;
  SYMBOL_LANGUAGE (&psymbol) = language;
  PSYMBOL_DOMAIN (&psymbol) = domain;
  PSYMBOL_CLASS (&psymbol) = class;

  SYMBOL_SET_NAMES (&psymbol, name, namelength, copy_name, objfile);

  /* Stash the partial symbol away in the cache */
  return bcache_full (&psymbol, sizeof (struct partial_symbol),
		      objfile->psymbol_cache, added);
}

/* Helper function, adds partial symbol to the given partial symbol
   list.  */

static void
append_psymbol_to_list (struct psymbol_allocation_list *list,
			const struct partial_symbol *psym,
			struct objfile *objfile)
{
  if (list->next >= list->list + list->size)
    extend_psymbol_list (list, objfile);
  *list->next++ = (struct partial_symbol *) psym;
  OBJSTAT (objfile, n_psyms++);
}

/* Add a symbol with a long value to a psymtab.
   Since one arg is a struct, we pass in a ptr and deref it (sigh).
   Return the partial symbol that has been added.  */

/* NOTE: carlton/2003-09-11: The reason why we return the partial
   symbol is so that callers can get access to the symbol's demangled
   name, which they don't have any cheap way to determine otherwise.
   (Currenly, dwarf2read.c is the only file who uses that information,
   though it's possible that other readers might in the future.)
   Elena wasn't thrilled about that, and I don't blame her, but we
   couldn't come up with a better way to get that information.  If
   it's needed in other situations, we could consider breaking up
   SYMBOL_SET_NAMES to provide access to the demangled name lookup
   cache.  */

const struct partial_symbol *
add_psymbol_to_list (char *name, int namelength, int copy_name,
		     domain_enum domain,
		     enum address_class class,
		     struct psymbol_allocation_list *list, 
		     long val,	/* Value as a long */
		     CORE_ADDR coreaddr,	/* Value as a CORE_ADDR */
		     enum language language, struct objfile *objfile)
{
  const struct partial_symbol *psym;

  int added;

  /* Stash the partial symbol away in the cache */
  psym = add_psymbol_to_bcache (name, namelength, copy_name, domain, class,
				val, coreaddr, language, objfile, &added);

  /* Do not duplicate global partial symbols.  */
  if (list == &objfile->global_psymbols
      && !added)
    return psym;

  /* Save pointer to partial symbol in psymtab, growing symtab if needed. */
  append_psymbol_to_list (list, psym, objfile);
  return psym;
}

/* Initialize storage for partial symbols.  */

void
init_psymbol_list (struct objfile *objfile, int total_symbols)
{
  /* Free any previously allocated psymbol lists.  */

  if (objfile->global_psymbols.list)
    {
      xfree (objfile->global_psymbols.list);
    }
  if (objfile->static_psymbols.list)
    {
      xfree (objfile->static_psymbols.list);
    }

  /* Current best guess is that approximately a twentieth
     of the total symbols (in a debugging file) are global or static
     oriented symbols */

  objfile->global_psymbols.size = total_symbols / 10;
  objfile->static_psymbols.size = total_symbols / 10;

  if (objfile->global_psymbols.size > 0)
    {
      objfile->global_psymbols.next =
	objfile->global_psymbols.list = (struct partial_symbol **)
	xmalloc ((objfile->global_psymbols.size
		  * sizeof (struct partial_symbol *)));
    }
  if (objfile->static_psymbols.size > 0)
    {
      objfile->static_psymbols.next =
	objfile->static_psymbols.list = (struct partial_symbol **)
	xmalloc ((objfile->static_psymbols.size
		  * sizeof (struct partial_symbol *)));
    }
}

@


1.275
log
@	* symfile.c (build_section_addr_info_from_objfile): Do not mask
	off high address bits.
@
text
@d595 2
a596 1
      asection *sect = bfd_get_section_by_name (abfd, addrs->other[i].name);
d613 16
a628 2
	  warning (_("section %s not found in %s"), addrs->other[i].name,
		   bfd_get_filename (abfd));
@


1.274
log
@	* symfile.c (find_lowest_section): Include SEC_ALLOC sections.
@
text
@a366 5
  int addr_bit = gdbarch_addr_bit (objfile->gdbarch);
  CORE_ADDR mask = CORE_ADDR_MAX;

  if (addr_bit < (sizeof (CORE_ADDR) * HOST_CHAR_BIT))
    mask = ((CORE_ADDR) 1 << addr_bit) - 1;
d373 1
a373 1
			      + objfile->section_offsets->offsets[i]) & mask;
@


1.273
log
@gdb/
	* symfile.c (addr_info_make_relative): Extend comment.  Move SECT to
	a more inner block.  Initialize ADDR by LOWER_OFFSET only if it was
	found by bfd_get_section_by_name.
	* symfile.h (struct section_addr_info) <sectindex>: New comment.
@
text
@d300 1
a300 1
  if (0 == (bfd_get_section_flags (abfd, sect) & SEC_LOAD))
@


1.272
log
@2010-02-18  Harald Koenig  <H.Koenig@@science-computing.de>

	* mi/mi-main.c (mi_cmd_exec_jump): Drop unneeded `return'.
	* symfile.c (symfile_map_offsets_to_segments): Fix assertion.
@
text
@d565 2
a566 1
   also SECTINDEXes there.  */
a571 1
  asection *sect;
d600 3
a602 1
      if (addrs->other[i].addr != 0)
d604 4
a607 2
	  sect = bfd_get_section_by_name (abfd, addrs->other[i].name);
	  if (sect)
a610 2
	      /* This is the index used by BFD. */
	      addrs->other[i].sectindex = sect->index;
d613 1
a613 5
	    {
	      warning (_("section %s not found in %s"), addrs->other[i].name,
		       bfd_get_filename (abfd));
	      addrs->other[i].addr = 0;
	    }
d616 7
a622 1
	addrs->other[i].addr = lower_offset;
@


1.272.2.1
log
@gdb/
	* symfile.c (addr_info_make_relative): Extend comment.  Move SECT to
	a more inner block.  Initialize ADDR by LOWER_OFFSET only if it was
	found by bfd_get_section_by_name.
	* symfile.h (struct section_addr_info) <sectindex>: New comment.
@
text
@d565 1
a565 2
   also SECTINDEXes specific to ABFD there.  This function can be used to
   rebase ADDRS to start referencing different BFD than before.  */
d571 1
d600 1
a600 3
      asection *sect = bfd_get_section_by_name (abfd, addrs->other[i].name);

      if (sect)
d602 2
a603 4
	  /* This is the index used by BFD. */
	  addrs->other[i].sectindex = sect->index;

	  if (addrs->other[i].addr != 0)
d607 2
d611 5
a615 1
	    addrs->other[i].addr = lower_offset;
d618 1
a618 7
	{
	  warning (_("section %s not found in %s"), addrs->other[i].name,
		   bfd_get_filename (abfd));
	  addrs->other[i].addr = 0;

	  /* SECTINDEX is invalid if ADDR is zero.  */
	}
@


1.272.2.2
log
@	* symfile.c (build_section_addr_info_from_objfile): Do not mask
	off high address bits.
@
text
@d367 5
d378 1
a378 1
			      + objfile->section_offsets->offsets[i]);
@


1.272.2.3
log
@	* symfile.c (generic_load): Reset breakpoints after loading.
@
text
@a1922 10
  /* Reset breakpoints, now that we have changed the load image.  For
     instance, breakpoints may have been set (or reset, by
     post_create_inferior) while connected to the target but before we
     loaded the program.  In that case, the prologue analyzer could
     have read instructions from the target to find the right
     breakpoint locations.  Loading has changed the contents of that
     memory.  */

  breakpoint_re_set ();

@


1.272.2.4
log
@gdb/
	* symfile.c (addr_info_make_relative): Move sect declaration to the
	outer block.  Initialize it to NULL.  Prefer SECT->next more than
	bfd_get_section_by_name.

gdb/testsuite/
	* gdb.base/dup-sect.exp, gdb.base/dup-sect.S: New.
@
text
@a568 1
  asection *sect;
a592 1
  sect = NULL;
d595 1
a595 11
      const char *sect_name = addrs->other[i].name;

      /* Prefer the next section of that we have found last.  The separate
	 debug info files have either the same section layout or just a few
	 sections are missing there.  On the other hand the section name is not
	 unique and we could find an inappropraite section by its name.  */

      if (sect)
	sect = sect->next;
      if (sect && strcmp (sect_name, bfd_get_section_name (abfd, sect)) != 0)
	sect = NULL;
a596 2
      if (sect == NULL)
	sect = bfd_get_section_by_name (abfd, sect_name);
@


1.271
log
@gdb/
	* symfile.c (build_section_addr_info_from_objfile): Include sections
	only if they are SEC_ALLOC or SEC_LOAD.
@
text
@d3718 1
a3718 1
  gdb_assert (segment_bases > 0);
@


1.270
log
@	gdb/
	* symfile.c (addr_info_make_relative): Always use
	find_lowest_section.
@
text
@d374 10
a383 10
  for (i = 0, sec = objfile->obfd->sections;
       i < objfile->num_sections;
       i++, sec = sec->next)
    {
      gdb_assert (sec != NULL);
      sap->other[i].addr = (bfd_get_section_vma (objfile->obfd, sec)
                            + objfile->section_offsets->offsets[i]) & mask;
      sap->other[i].name = xstrdup (bfd_get_section_name (objfile->obfd, sec));
      sap->other[i].sectindex = sec->index;
    }
@


1.269
log
@2010-02-03  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct sym_fns): Add sym_relocate field.
	(default_symfile_relocate): New prototype.
	(symfile_relocate_debug_section): First argument is now an objfile.
	* symfile.c (default_symfile_relocate): Rename from
	symfile_relocate_debug_section, first argument is now an objfile.
	(symfile_relocate_debug_section): New function.
	* coffread.c (coff_sym_fns): Set sym_relocate field.
	* somread.c (som_sym_fns): Ditto.
	* mipsread.c (ecoff_sym_fns): Ditto.
	* machoread.c (macho_sym_fns): Ditto.
	* elfread.c (elf_sym_fns): Ditto.
	* dwarf2read.c (dwarf2_read_section): Ditto.
	* xcoffread.c (xcoff_sym_fns): Ditto.
	* dbxread.c (aout_sym_fns): Ditto.
	(dbx_psymtab_to_symtab): Adjust call to symfile_relocate_debug_section.
	(elfstab_build_psymtabs): Ditto.
@
text
@d576 3
a578 5
     continguous sections. FIXME!! won't work without call to find
     .text first, but this assumes text is lowest section. */
  lower_sect = bfd_get_section_by_name (abfd, ".text");
  if (lower_sect == NULL)
    bfd_map_over_sections (abfd, find_lowest_section, &lower_sect);
@


1.268
log
@Delete free_named_symtabs and associated cleanup.

        * symfile.h (free_named_symtabs): Delete declaration.
        * symfile.c: Remove some commented out code (clear_symtab_users_once).
        (cashier_psymtab): Comment function out.
        Delete declaration.
        (free_named_symtabs): Delete.
        * coffread.c (coff_end_symtab): Remove call to free_named_symtabs.
        * dbxread.c (end_psymtab): Likewise.
        * dwarf2read.c (process_psymtab_comp_unit): Ditto.
        * exec.c (exec_close_1): Ditto.
        * xcoffread.c (xcoff_end_psymtab): Likewise.
@
text
@d3630 21
d3666 2
a3667 1
symfile_relocate_debug_section (bfd *abfd, asection *sectp, bfd_byte *buf)
d3669 1
a3669 8
  /* We're only interested in sections with relocation
     information.  */
  if ((sectp->flags & SEC_RELOC) == 0)
    return NULL;

  /* We will handle section offsets properly elsewhere, so relocate as if
     all sections begin at 0.  */
  bfd_map_over_sections (abfd, symfile_dummy_outputs, NULL);
d3671 1
a3671 1
  return bfd_simple_get_relocated_section_contents (abfd, sectp, buf, NULL);
@


1.267
log
@gdb/
	Fix displacement of separate debug info files.
	* objfiles.c (objfile_relocate): Rename to ...
	(objfile_relocate1): ... here and make it static.  Extend the comment.
	(objfile_relocate): New function.
	* solib-spu.c (spu_relocate_main_executable): Explicitly check if
	SYMFILE_OBJFILE is NULL.  Remove variables objfile and old_chain.
	Remove following of SEPARATE_DEBUG_OBJFILE.  new_offsets is now
	allocated using alloca.
	* symfile.c (copy_section_addr_info): Remove.
	(build_section_addr_info_from_objfile): Make it global.  New variables
	addr_bit and mask, use them.
	* symfile.h (build_section_addr_info_from_objfile): New prototype.
	(copy_section_addr_info): Remove.
@
text
@a99 2
static void cashier_psymtab (struct partial_symtab *);

a2577 1
   possibly free_named_symtabs (symtab->filename);
a2705 204

/* clear_symtab_users_once:

   This function is run after symbol reading, or from a cleanup.
   If an old symbol table was obsoleted, the old symbol table
   has been blown away, but the other GDB data structures that may
   reference it have not yet been cleared or re-directed.  (The old
   symtab was zapped, and the cleanup queued, in free_named_symtab()
   below.)

   This function can be queued N times as a cleanup, or called
   directly; it will do all the work the first time, and then will be a
   no-op until the next time it is queued.  This works by bumping a
   counter at queueing time.  Much later when the cleanup is run, or at
   the end of symbol processing (in case the cleanup is discarded), if
   the queued count is greater than the "done-count", we do the work
   and set the done-count to the queued count.  If the queued count is
   less than or equal to the done-count, we just ignore the call.  This
   is needed because reading a single .o file will often replace many
   symtabs (one per .h file, for example), and we don't want to reset
   the breakpoints N times in the user's face.

   The reason we both queue a cleanup, and call it directly after symbol
   reading, is because the cleanup protects us in case of errors, but is
   discarded if symbol reading is successful.  */

#if 0
/* FIXME:  As free_named_symtabs is currently a big noop this function
   is no longer needed.  */
static void clear_symtab_users_once (void);

static int clear_symtab_users_queued;
static int clear_symtab_users_done;

static void
clear_symtab_users_once (void)
{
  /* Enforce once-per-`do_cleanups'-semantics */
  if (clear_symtab_users_queued <= clear_symtab_users_done)
    return;
  clear_symtab_users_done = clear_symtab_users_queued;

  clear_symtab_users ();
}
#endif

/* Delete the specified psymtab, and any others that reference it.  */

static void
cashier_psymtab (struct partial_symtab *pst)
{
  struct partial_symtab *ps, *pprev = NULL;
  int i;

  /* Find its previous psymtab in the chain */
  for (ps = pst->objfile->psymtabs; ps; ps = ps->next)
    {
      if (ps == pst)
	break;
      pprev = ps;
    }

  if (ps)
    {
      /* Unhook it from the chain.  */
      if (ps == pst->objfile->psymtabs)
	pst->objfile->psymtabs = ps->next;
      else
	pprev->next = ps->next;

      /* FIXME, we can't conveniently deallocate the entries in the
         partial_symbol lists (global_psymbols/static_psymbols) that
         this psymtab points to.  These just take up space until all
         the psymtabs are reclaimed.  Ditto the dependencies list and
         filename, which are all in the objfile_obstack.  */

      /* We need to cashier any psymtab that has this one as a dependency... */
    again:
      for (ps = pst->objfile->psymtabs; ps; ps = ps->next)
	{
	  for (i = 0; i < ps->number_of_dependencies; i++)
	    {
	      if (ps->dependencies[i] == pst)
		{
		  cashier_psymtab (ps);
		  goto again;	/* Must restart, chain has been munged. */
		}
	    }
	}
    }
}

/* If a symtab or psymtab for filename NAME is found, free it along
   with any dependent breakpoints, displays, etc.
   Used when loading new versions of object modules with the "add-file"
   command.  This is only called on the top-level symtab or psymtab's name;
   it is not called for subsidiary files such as .h files.

   Return value is 1 if we blew away the environment, 0 if not.
   FIXME.  The return value appears to never be used.

   FIXME.  I think this is not the best way to do this.  We should
   work on being gentler to the environment while still cleaning up
   all stray pointers into the freed symtab.  */

int
free_named_symtabs (char *name)
{
#if 0
  /* FIXME:  With the new method of each objfile having it's own
     psymtab list, this function needs serious rethinking.  In particular,
     why was it ever necessary to toss psymtabs with specific compilation
     unit filenames, as opposed to all psymtabs from a particular symbol
     file?  -- fnf
     Well, the answer is that some systems permit reloading of particular
     compilation units.  We want to blow away any old info about these
     compilation units, regardless of which objfiles they arrived in. --gnu.  */

  struct symtab *s;
  struct symtab *prev;
  struct partial_symtab *ps;
  struct blockvector *bv;
  int blewit = 0;

  /* We only wack things if the symbol-reload switch is set.  */
  if (!symbol_reloading)
    return 0;

  /* Some symbol formats have trouble providing file names... */
  if (name == 0 || *name == '\0')
    return 0;

  /* Look for a psymtab with the specified name.  */

again2:
  for (ps = partial_symtab_list; ps; ps = ps->next)
    {
      if (strcmp (name, ps->filename) == 0)
	{
	  cashier_psymtab (ps);	/* Blow it away...and its little dog, too.  */
	  goto again2;		/* Must restart, chain has been munged */
	}
    }

  /* Look for a symtab with the specified name.  */

  for (s = symtab_list; s; s = s->next)
    {
      if (strcmp (name, s->filename) == 0)
	break;
      prev = s;
    }

  if (s)
    {
      if (s == symtab_list)
	symtab_list = s->next;
      else
	prev->next = s->next;

      /* For now, queue a delete for all breakpoints, displays, etc., whether
         or not they depend on the symtab being freed.  This should be
         changed so that only those data structures affected are deleted.  */

      /* But don't delete anything if the symtab is empty.
         This test is necessary due to a bug in "dbxread.c" that
         causes empty symtabs to be created for N_SO symbols that
         contain the pathname of the object file.  (This problem
         has been fixed in GDB 3.9x).  */

      bv = BLOCKVECTOR (s);
      if (BLOCKVECTOR_NBLOCKS (bv) > 2
	  || BLOCK_NSYMS (BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK))
	  || BLOCK_NSYMS (BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK)))
	{
	  complaint (&symfile_complaints, _("Replacing old symbols for `%s'"),
		     name);
	  clear_symtab_users_queued++;
	  make_cleanup (clear_symtab_users_once, 0);
	  blewit = 1;
	}
      else
	complaint (&symfile_complaints, _("Empty symbol table found for `%s'"),
		   name);

      free_symtab (s);
    }
  else
    {
      /* It is still possible that some breakpoints will be affected
         even though no symtab was found, since the file might have
         been compiled without debugging, and hence not be associated
         with a symtab.  In order to handle this correctly, we would need
         to keep a list of text address ranges for undebuggable files.
         For now, we do nothing, since this is a fairly obscure case.  */
      ;
    }

  /* FIXME, what about the minimal symbol table? */
  return blewit;
#else
  return (0);
#endif
}
@


1.266
log
@gdb/
	Move some symfile code into subroutines.
	* symfile.h (relative_addr_info_to_section_offsets)
	(addr_info_make_relative): New prototypes.
	* symfile.c (default_symfile_offsets): Move a part to ...
	(relative_addr_info_to_section_offsets): ... this new function.
	(default_symfile_offsets): Call it.
	(syms_from_objfile <!mainline && addrs && addrs->other[0].name>): Move
	this part to ...
	(addr_info_make_relative): ... this new function.
@
text
@a330 26

/* Return a freshly allocated copy of ADDRS.  The section names, if
   any, are also freshly allocated copies of those in ADDRS.  */
struct section_addr_info *
copy_section_addr_info (struct section_addr_info *addrs)
{
  struct section_addr_info *copy
    = alloc_section_addr_info (addrs->num_sections);
  int i;

  copy->num_sections = addrs->num_sections;
  for (i = 0; i < addrs->num_sections; i++)
    {
      copy->other[i].addr = addrs->other[i].addr;
      if (addrs->other[i].name)
        copy->other[i].name = xstrdup (addrs->other[i].name);
      else
        copy->other[i].name = NULL;
      copy->other[i].sectindex = addrs->other[i].sectindex;
    }

  return copy;
}



d363 1
a363 1
static struct section_addr_info *
d369 5
d382 1
a382 1
                            + objfile->section_offsets->offsets[i]);
@


1.265
log
@2010-01-07  Tristan Gingold  <gingold@@adacore.com>

	* symfile.c (build_section_addr_info_from_objfile): New function.
	(symbol_file_add_separate): Don't use offsets from objfile but
	built an addr info.
@
text
@d558 3
a560 5
/* Parse the user's idea of an offset for dynamic linking, into our idea
   of how to represent it for fast symbol reading.  This is the default
   version of the sym_fns.sym_offsets function for symbol readers that
   don't need to do anything special.  It allocates a section_offsets table
   for the objectfile OBJFILE and stuffs ADDR into all of the offsets.  */
d563 3
a565 2
default_symfile_offsets (struct objfile *objfile,
			 struct section_addr_info *addrs)
d569 1
a569 6
  objfile->num_sections = bfd_count_sections (objfile->obfd);
  objfile->section_offsets = (struct section_offsets *)
    obstack_alloc (&objfile->objfile_obstack,
		   SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
  memset (objfile->section_offsets, 0,
	  SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
d571 1
a571 2
  /* Now calculate offsets for section that were specified by the
     caller. */
d574 1
a574 1
      struct other_sections *osp ;
d576 1
a576 1
      osp = &addrs->other[i] ;
d583 26
a608 1
      (objfile->section_offsets)->offsets[osp->sectindex] = osp->addr;
d610 53
d897 1
a897 58
    {
      asection *lower_sect;
      asection *sect;
      CORE_ADDR lower_offset;
      int i;

      /* Find lowest loadable section to be used as starting point for
         continguous sections. FIXME!! won't work without call to find
	 .text first, but this assumes text is lowest section. */
      lower_sect = bfd_get_section_by_name (objfile->obfd, ".text");
      if (lower_sect == NULL)
	bfd_map_over_sections (objfile->obfd, find_lowest_section,
			       &lower_sect);
      if (lower_sect == NULL)
	{
	  warning (_("no loadable sections found in added symbol-file %s"),
		   objfile->name);
	  lower_offset = 0;
	}
      else
	lower_offset = bfd_section_vma (objfile->obfd, lower_sect);

      /* Calculate offsets for the loadable sections.
 	 FIXME! Sections must be in order of increasing loadable section
 	 so that contiguous sections can use the lower-offset!!!

         Adjust offsets if the segments are not contiguous.
         If the section is contiguous, its offset should be set to
 	 the offset of the highest loadable section lower than it
 	 (the loadable section directly below it in memory).
 	 this_offset = lower_offset = lower_addr - lower_orig_addr */

        for (i = 0; i < addrs->num_sections && addrs->other[i].name; i++)
          {
            if (addrs->other[i].addr != 0)
              {
                sect = bfd_get_section_by_name (objfile->obfd,
                                                addrs->other[i].name);
                if (sect)
                  {
                    addrs->other[i].addr
                      -= bfd_section_vma (objfile->obfd, sect);
                    lower_offset = addrs->other[i].addr;
                    /* This is the index used by BFD. */
                    addrs->other[i].sectindex = sect->index ;
                  }
                else
                  {
                    warning (_("section %s not found in %s"),
                             addrs->other[i].name,
                             objfile->name);
                    addrs->other[i].addr = 0;
                  }
              }
            else
              addrs->other[i].addr = lower_offset;
          }
    }
@


1.264
log
@2010-01-06  Tristan Gingold  <gingold@@adacore.com>

	* symtab.c (lookup_global_symbol_from_objfile): Rename objfile
	parameter to main_objfile.  Iterate on all separate debug objfiles.
	* symfile.h (symbol_file_add_separate)
	(find_separate_debug_file_by_debuglink): Remove parameter names.
	* symfile.c (symbol_file_add_separate): Use add_separate_objfile.
	(reread_symbols): Use free_objfile_separate_debug.
	* objfiles.h (struct objfile): Add separate_debug_objfile_link.
	Adjust comment.
	(objfile_separate_debug_iterate, add_separate_debug_objfile)
	(free_objfile_separate_debug): New prototypes.
	* objfiles.c (objfile_separate_debug_iterate): New function.
	(add_separate_debug_objfile, free_objfile_separate_debug): New
	functions.
	(free_objfile): Use free_objfile_separate_debug.  Adjust for
	multiple separate debug objfile.
	(objfile_has_symbols): Adjust comment.  Iterate on all separate
	debug objfiles.
	* minsyms.c (lookup_minimal_symbol): Adjust for multiple separate
	debug objfile.
	(lookup_minimal_symbol_text): Ditto.
	(lookup_minimal_symbol_by_pc_name): Ditto.
	(lookup_minimal_symbol_solib_trampoline): Ditto.
	(lookup_minimal_symbol_by_pc_section_1): Iterate on all separate
	debug objfiles.
@
text
@d387 23
d1069 8
d1080 1
a1080 2
     0, /* No addr table.  */
     objfile->section_offsets, objfile->num_sections,
d1084 2
@


1.263
log
@gdb/
	* symfile.c (syms_from_objfile): Remove the !MAINLINE conditional.
@
text
@d1045 1
a1045 2
  /* Currently only one separate debug objfile is supported.  */
  gdb_assert (objfile && objfile->separate_debug_objfile == NULL);
d1047 1
a1047 2
  objfile->separate_debug_objfile =
    symbol_file_add_with_addrs_or_offsets
a1052 2
  objfile->separate_debug_objfile->separate_debug_objfile_backlink
    = objfile;
d1054 1
a1054 3
  /* Put the separate debug object before the normal one, this is so that
     usage of the ALL_OBJFILES_SAFE macro will stay safe. */
  put_objfile_before (objfile->separate_debug_objfile, objfile);
d2269 1
a2269 1
	  /* Free the separate debug objfile if there is one.  It will be
d2271 1
a2271 6
	  if (objfile->separate_debug_objfile)
	    {
	      /* Note: no need to clear separate_debug_objfile field as it is
		 done by free_objfile.  */
	      free_objfile (objfile->separate_debug_objfile);
	    }
@


1.262
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d802 1
a802 1
  if (!mainline && addrs && addrs->other[0].name)
@


1.261
log
@2009-12-11  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (find_separate_debug_file_by_buildid): Remove prototype.
	(bfd_open_maybe_remote): New prototype.
	* symfile.c (bfd_open_maybe_remote): New function.
	(separate_debug_file_exists, reread_symbols): Use it.
	(struct build_id, build_id_bfd_get, build_id_verify)
	(build_id_to_debug_filename)
	(find_separate_debug_file_by_buildid): Move these ...
	* elfread.c (struct build_id)
	(build_id_bfd_get, build_id_verify, build_id_to_debug_filename)
	(find_separate_debug_file_by_buildid): ... here.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.260
log
@2009-12-02  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (symbol_file_add_separate): New prototype.
	(find_separate_debug_file_by_buildid): Ditto.
	(find_separate_debug_file_by_debuglink): Ditto.
	* symfile.c (reread_separate_symbols): Remove.
	(find_separate_debug_file): Split into ...
	(find_separate_debug_file_by_buildid): ... this and ...
	(find_separate_debug_file_by_debuglink): ... this.
	(symbol_file_add_with_addrs_or_offsets): Do not save orig_addrs.
	Remove separate debug file handling.
	(symbol_file_add_separate): New function.
	(reread_symbols): Do not considere separate debug files, but free
	them while handling their parent.  Reindent.
	* coffread.c (coff_symfile_read): Handle separate object file.
	* elfread.c (elf_symfile_read): Ditto.
@
text
@a1139 121
struct build_id
  {
    size_t size;
    gdb_byte data[1];
  };

/* Locate NT_GNU_BUILD_ID from ABFD and return its content.  */

static struct build_id *
build_id_bfd_get (bfd *abfd)
{
  struct build_id *retval;

  if (!bfd_check_format (abfd, bfd_object)
      || bfd_get_flavour (abfd) != bfd_target_elf_flavour
      || elf_tdata (abfd)->build_id == NULL)
    return NULL;

  retval = xmalloc (sizeof *retval - 1 + elf_tdata (abfd)->build_id_size);
  retval->size = elf_tdata (abfd)->build_id_size;
  memcpy (retval->data, elf_tdata (abfd)->build_id, retval->size);

  return retval;
}

/* Return if FILENAME has NT_GNU_BUILD_ID matching the CHECK value.  */

static int
build_id_verify (const char *filename, struct build_id *check)
{
  bfd *abfd;
  struct build_id *found = NULL;
  int retval = 0;

  /* We expect to be silent on the non-existing files.  */
  if (remote_filename_p (filename))
    abfd = remote_bfd_open (filename, gnutarget);
  else
    abfd = bfd_openr (filename, gnutarget);
  if (abfd == NULL)
    return 0;

  found = build_id_bfd_get (abfd);

  if (found == NULL)
    warning (_("File \"%s\" has no build-id, file skipped"), filename);
  else if (found->size != check->size
           || memcmp (found->data, check->data, found->size) != 0)
    warning (_("File \"%s\" has a different build-id, file skipped"), filename);
  else
    retval = 1;

  if (!bfd_close (abfd))
    warning (_("cannot close \"%s\": %s"), filename,
	     bfd_errmsg (bfd_get_error ()));

  xfree (found);

  return retval;
}

static char *
build_id_to_debug_filename (struct build_id *build_id)
{
  char *link, *debugdir, *retval = NULL;

  /* DEBUG_FILE_DIRECTORY/.build-id/ab/cdef */
  link = alloca (strlen (debug_file_directory) + (sizeof "/.build-id/" - 1) + 1
		 + 2 * build_id->size + (sizeof ".debug" - 1) + 1);

  /* Keep backward compatibility so that DEBUG_FILE_DIRECTORY being "" will
     cause "/.build-id/..." lookups.  */

  debugdir = debug_file_directory;
  do
    {
      char *s, *debugdir_end;
      gdb_byte *data = build_id->data;
      size_t size = build_id->size;

      while (*debugdir == DIRNAME_SEPARATOR)
	debugdir++;

      debugdir_end = strchr (debugdir, DIRNAME_SEPARATOR);
      if (debugdir_end == NULL)
	debugdir_end = &debugdir[strlen (debugdir)];

      memcpy (link, debugdir, debugdir_end - debugdir);
      s = &link[debugdir_end - debugdir];
      s += sprintf (s, "/.build-id/");
      if (size > 0)
	{
	  size--;
	  s += sprintf (s, "%02x", (unsigned) *data++);
	}
      if (size > 0)
	*s++ = '/';
      while (size-- > 0)
	s += sprintf (s, "%02x", (unsigned) *data++);
      strcpy (s, ".debug");

      /* lrealpath() is expensive even for the usually non-existent files.  */
      if (access (link, F_OK) == 0)
	retval = lrealpath (link);

      if (retval != NULL && !build_id_verify (retval, build_id))
	{
	  xfree (retval);
	  retval = NULL;
	}

      if (retval != NULL)
	break;

      debugdir = debugdir_end;
    }
  while (*debugdir != 0);

  return retval;
}

d1190 1
a1190 4
  if (remote_filename_p (name))
    abfd = remote_bfd_open (name, gnutarget);
  else
    abfd = bfd_openr (name, gnutarget);
a1245 33
find_separate_debug_file_by_buildid (struct objfile *objfile)
{
  asection *sect;
  char *basename, *name_copy, *debugdir;
  char *dir = NULL;
  char *debugfile = NULL;
  char *canon_name = NULL;
  bfd_size_type debuglink_size;
  unsigned long crc32;
  int i;
  struct build_id *build_id;

  build_id = build_id_bfd_get (objfile->obfd);
  if (build_id != NULL)
    {
      char *build_id_name;

      build_id_name = build_id_to_debug_filename (build_id);
      xfree (build_id);
      /* Prevent looping on a stripped .debug file.  */
      if (build_id_name != NULL && strcmp (build_id_name, objfile->name) == 0)
        {
	  warning (_("\"%s\": separate debug info file has no debug info"),
		   build_id_name);
	  xfree (build_id_name);
	}
      else if (build_id_name != NULL)
        return build_id_name;
    }
  return NULL;
}

char *
d1451 13
d2240 1
a2240 4
	  if (remote_filename_p (obfd_filename))
	    objfile->obfd = remote_bfd_open (obfd_filename, gnutarget);
	  else
	    objfile->obfd = bfd_openr (obfd_filename, gnutarget);
@


1.259
log
@2009-12-07  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct sym_fns): Adjust comment on sym_read.
	* symfile.c (syms_from_objfile): Pass all symfile flags to sym_read.
	* dbxread.c (dbx_symfile_read): Rename mainline to symfile_flags,
	adjust header comment.
	* elfread.c (elf_symfile_read): Ditto.
	* somread.c (som_symfile_read): Ditto.
	* xcoffread.c (xcoff_initial_scan): Ditto.
	* coffread.c (coff_symfile_read): Rename mainline to symfile_flags.
	* machoread.c (macho_symfile_read): Ditto.
	* mipsread.c (mipscoff_symfile_read): Ditto.
@
text
@a99 2
static void reread_separate_symbols (struct objfile *objfile);

a140 2
static char *find_separate_debug_file (struct objfile *objfile);

a945 2
  char *debugfile = NULL;
  struct section_addr_info *orig_addrs = NULL;
a963 6
  if (addrs)
    {
      orig_addrs = copy_section_addr_info (addrs);
      make_cleanup_free_section_addr_info (orig_addrs);
    }

a1002 27
  /* If the file has its own symbol tables it has no separate debug info.
     `.dynsym'/`.symtab' go to MSYMBOLS, `.debug_info' goes to SYMTABS/PSYMTABS.
     `.gnu_debuglink' may no longer be present with `.note.gnu.build-id'.  */
  if (objfile->psymtabs == NULL)
    debugfile = find_separate_debug_file (objfile);
  if (debugfile)
    {
      if (addrs != NULL)
	{
	  objfile->separate_debug_objfile
            = symbol_file_add (debugfile, add_flags, orig_addrs, flags);
	}
      else
	{
	  objfile->separate_debug_objfile
            = symbol_file_add (debugfile, add_flags, NULL, flags);
	}
      objfile->separate_debug_objfile->separate_debug_objfile_backlink
        = objfile;

      /* Put the separate debug object before the normal one, this is so that
         usage of the ALL_OBJFILES_SAFE macro will stay safe. */
      put_objfile_before (objfile->separate_debug_objfile, objfile);

      xfree (debugfile);
    }

d1040 22
d1369 2
a1370 2
static char *
find_separate_debug_file (struct objfile *objfile)
d1399 14
d2320 8
a2327 2
      if (objfile->obfd)
	{
d2329 2
a2330 2
	  /* If this object is from a shared library, then you should
	     stat on the library name, not member name. */
d2332 3
a2334 3
	  if (objfile->obfd->my_archive)
	    res = stat (objfile->obfd->my_archive->filename, &new_statbuf);
	  else
d2336 35
a2370 2
	    res = stat (objfile->name, &new_statbuf);
	  if (res != 0)
d2372 3
a2374 4
	      /* FIXME, should use print_sys_errmsg but it's not filtered. */
	      printf_unfiltered (_("`%s' has disappeared; keeping its symbols.\n"),
			       objfile->name);
	      continue;
a2375 24
	  new_modtime = new_statbuf.st_mtime;
	  if (new_modtime != objfile->mtime)
	    {
	      struct cleanup *old_cleanups;
	      struct section_offsets *offsets;
	      int num_offsets;
	      char *obfd_filename;

	      printf_unfiltered (_("`%s' has changed; re-reading symbols.\n"),
			       objfile->name);

	      /* There are various functions like symbol_file_add,
	         symfile_bfd_open, syms_from_objfile, etc., which might
	         appear to do what we want.  But they have various other
	         effects which we *don't* want.  So we just do stuff
	         ourselves.  We don't worry about mapped files (for one thing,
	         any mapped file will be out of date).  */

	      /* If we get an error, blow away this objfile (not sure if
	         that is the correct response for things like shared
	         libraries).  */
	      old_cleanups = make_cleanup_free_objfile (objfile);
	      /* We need to do this whenever any symbols go away.  */
	      make_cleanup (clear_symtab_users_cleanup, 0 /*ignore*/);
d2377 35
a2411 4
	      if (exec_bfd != NULL && strcmp (bfd_get_filename (objfile->obfd),
					      bfd_get_filename (exec_bfd)) == 0)
		{
		  /* Reload EXEC_BFD without asking anything.  */
d2413 1
a2413 2
		  exec_file_attach (bfd_get_filename (objfile->obfd), 0);
		}
d2415 4
a2418 37
	      /* Clean up any state BFD has sitting around.  We don't need
	         to close the descriptor but BFD lacks a way of closing the
	         BFD without closing the descriptor.  */
	      obfd_filename = bfd_get_filename (objfile->obfd);
	      if (!bfd_close (objfile->obfd))
		error (_("Can't close BFD for %s: %s"), objfile->name,
		       bfd_errmsg (bfd_get_error ()));
	      if (remote_filename_p (obfd_filename))
		objfile->obfd = remote_bfd_open (obfd_filename, gnutarget);
	      else
		objfile->obfd = bfd_openr (obfd_filename, gnutarget);
	      if (objfile->obfd == NULL)
		error (_("Can't open %s to read symbols."), objfile->name);
	      else
		objfile->obfd = gdb_bfd_ref (objfile->obfd);
	      /* bfd_openr sets cacheable to true, which is what we want.  */
	      if (!bfd_check_format (objfile->obfd, bfd_object))
		error (_("Can't read symbols from %s: %s."), objfile->name,
		       bfd_errmsg (bfd_get_error ()));

	      /* Save the offsets, we will nuke them with the rest of the
	         objfile_obstack.  */
	      num_offsets = objfile->num_sections;
	      offsets = ((struct section_offsets *)
			 alloca (SIZEOF_N_SECTION_OFFSETS (num_offsets)));
	      memcpy (offsets, objfile->section_offsets,
		      SIZEOF_N_SECTION_OFFSETS (num_offsets));

	      /* Remove any references to this objfile in the global
		 value lists.  */
	      preserve_values (objfile);

	      /* Nuke all the state that we will re-read.  Much of the following
	         code which sets things to NULL really is necessary to tell
	         other parts of GDB that there is nothing currently there.
		 
		 Try to keep the freeing order compatible with free_objfile.  */
d2420 1
a2420 4
	      if (objfile->sf != NULL)
		{
		  (*objfile->sf->sym_finish) (objfile);
		}
d2422 8
a2429 1
	      clear_objfile_data (objfile);
d2431 52
a2482 52
	      /* FIXME: Do we have to free a whole linked list, or is this
	         enough?  */
	      if (objfile->global_psymbols.list)
		xfree (objfile->global_psymbols.list);
	      memset (&objfile->global_psymbols, 0,
		      sizeof (objfile->global_psymbols));
	      if (objfile->static_psymbols.list)
		xfree (objfile->static_psymbols.list);
	      memset (&objfile->static_psymbols, 0,
		      sizeof (objfile->static_psymbols));

	      /* Free the obstacks for non-reusable objfiles */
	      bcache_xfree (objfile->psymbol_cache);
	      objfile->psymbol_cache = bcache_xmalloc ();
	      bcache_xfree (objfile->macro_cache);
	      objfile->macro_cache = bcache_xmalloc ();
	      bcache_xfree (objfile->filename_cache);
	      objfile->filename_cache = bcache_xmalloc ();
	      if (objfile->demangled_names_hash != NULL)
		{
		  htab_delete (objfile->demangled_names_hash);
		  objfile->demangled_names_hash = NULL;
		}
	      obstack_free (&objfile->objfile_obstack, 0);
	      objfile->sections = NULL;
	      objfile->symtabs = NULL;
	      objfile->psymtabs = NULL;
	      objfile->psymtabs_addrmap = NULL;
	      objfile->free_psymtabs = NULL;
	      objfile->cp_namespace_symtab = NULL;
	      objfile->msymbols = NULL;
	      objfile->deprecated_sym_private = NULL;
	      objfile->minimal_symbol_count = 0;
	      memset (&objfile->msymbol_hash, 0,
		      sizeof (objfile->msymbol_hash));
	      memset (&objfile->msymbol_demangled_hash, 0,
		      sizeof (objfile->msymbol_demangled_hash));

	      objfile->psymbol_cache = bcache_xmalloc ();
	      objfile->macro_cache = bcache_xmalloc ();
	      objfile->filename_cache = bcache_xmalloc ();
	      /* obstack_init also initializes the obstack so it is
	         empty.  We could use obstack_specify_allocation but
	         gdb_obstack.h specifies the alloc/dealloc
	         functions.  */
	      obstack_init (&objfile->objfile_obstack);
	      if (build_objfile_section_table (objfile))
		{
		  error (_("Can't find the file sections in `%s': %s"),
			 objfile->name, bfd_errmsg (bfd_get_error ()));
		}
              terminate_minimal_symbol_table (objfile);
d2484 16
a2499 16
	      /* We use the same section offsets as from last time.  I'm not
	         sure whether that is always correct for shared libraries.  */
	      objfile->section_offsets = (struct section_offsets *)
		obstack_alloc (&objfile->objfile_obstack,
			       SIZEOF_N_SECTION_OFFSETS (num_offsets));
	      memcpy (objfile->section_offsets, offsets,
		      SIZEOF_N_SECTION_OFFSETS (num_offsets));
	      objfile->num_sections = num_offsets;

	      /* What the hell is sym_new_init for, anyway?  The concept of
	         distinguishing between the main file and additional files
	         in this way seems rather dubious.  */
	      if (objfile == symfile_objfile)
		{
		  (*objfile->sf->sym_new_init) (objfile);
		}
d2501 11
a2511 12
	      (*objfile->sf->sym_init) (objfile);
	      clear_complaints (&symfile_complaints, 1, 1);
	      /* The "mainline" parameter is a hideous hack; I think leaving it
	         zero is OK since dbxread.c also does what it needs to do if
	         objfile->global_psymbols.size is 0.  */
	      (*objfile->sf->sym_read) (objfile, 0);
	      if (!objfile_has_symbols (objfile))
		{
		  wrap_here ("");
		  printf_unfiltered (_("(no debugging symbols found)\n"));
		  wrap_here ("");
		}
d2513 2
a2514 2
	      /* We're done reading the symbol file; finish off complaints.  */
	      clear_complaints (&symfile_complaints, 0, 1);
d2516 2
a2517 2
	      /* Getting new symbols may change our opinion about what is
	         frameless.  */
d2519 1
a2519 1
	      reinit_frame_cache ();
d2521 9
a2529 11
	      /* Discard cleanups as symbol reading was successful.  */
	      discard_cleanups (old_cleanups);

	      /* If the mtime has changed between the time we set new_modtime
	         and now, we *want* this to be out of date, so don't call stat
	         again now.  */
	      objfile->mtime = new_modtime;
	      reread_one = 1;
              reread_separate_symbols (objfile);
	      init_entry_point_info (objfile);
	    }
a2543 67


/* Handle separate debug info for OBJFILE, which has just been
   re-read:
   - If we had separate debug info before, but now we don't, get rid
     of the separated objfile.
   - If we didn't have separated debug info before, but now we do,
     read in the new separated debug info file.
   - If the debug link points to a different file, toss the old one
     and read the new one.
   This function does *not* handle the case where objfile is still
   using the same separate debug info file, but that file's timestamp
   has changed.  That case should be handled by the loop in
   reread_symbols already.  */
static void
reread_separate_symbols (struct objfile *objfile)
{
  char *debug_file;
  unsigned long crc32;

  /* Does the updated objfile's debug info live in a
     separate file?  */
  debug_file = find_separate_debug_file (objfile);

  if (objfile->separate_debug_objfile)
    {
      /* There are two cases where we need to get rid of
         the old separated debug info objfile:
         - if the new primary objfile doesn't have
         separated debug info, or
         - if the new primary objfile has separate debug
         info, but it's under a different filename.

         If the old and new objfiles both have separate
         debug info, under the same filename, then we're
         okay --- if the separated file's contents have
         changed, we will have caught that when we
         visited it in this function's outermost
         loop.  */
      if (! debug_file
          || strcmp (debug_file, objfile->separate_debug_objfile->name) != 0)
        free_objfile (objfile->separate_debug_objfile);
    }

  /* If the new objfile has separate debug info, and we
     haven't loaded it already, do so now.  */
  if (debug_file
      && ! objfile->separate_debug_objfile)
    {
      /* Use the same section offset table as objfile itself.
         Preserve the flags from objfile that make sense.  */
      objfile->separate_debug_objfile
        = (symbol_file_add_with_addrs_or_offsets
           (symfile_bfd_open (debug_file),
            info_verbose ? SYMFILE_VERBOSE : 0,
            0, /* No addr table.  */
            objfile->section_offsets, objfile->num_sections,
            objfile->flags & (OBJF_REORDERED | OBJF_SHARED | OBJF_READNOW
                              | OBJF_USERLOADED)));
      objfile->separate_debug_objfile->separate_debug_objfile_backlink
        = objfile;
    }
  if (debug_file)
    xfree (debug_file);
}


@


1.258
log
@	* xcoffread.c (scan_xcoff_symtab): Update.
	* symfile.h (add_psymbol_to_list): Update prototype.
	* symfile.c (add_psymbol_to_bcache): Add copy_name argument.
	(add_psymbol_to_list): Likewise.
	* stabsread.c (define_symbol): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	(handle_psymbol_enumerators): Update.
	(new_symbol): Update.
	* dbxread.c (read_dbx_symtab): Update.
	* coffread.c (process_coff_symbol): Update.
	* symtab.h (prim_record_minimal_symbol_full): Declare.
	(SYMBOL_SET_NAMES): Add copy_name argument.
	* symtab.c (struct demangled_name_entry): New struct.
	(hash_demangled_name_entry): New function.
	(eq_demangled_name_entry): Likewise.
	(create_demangled_names_hash): Use new functions.
	(symbol_set_names): Use struct demangled_name_entry.  Add
	copy_name argument.
	* minsyms.c (prim_record_minimal_symbol_full): New function.
	(prim_record_minimal_symbol_and_info): Use it.
	* elfread.c (record_minimal_symbol): Add name_len and copy_name
	arguments.  Call prim_record_minimal_symbol_full.
	(elf_symtab_read): Add copy_names argument.
	(elf_symfile_read): Update calls to elf_symtab_read.
	* dwarf2read.c (add_partial_symbol): Don't copy symbol names.
	(load_partial_dies): Likewise.
	(new_symbol): Likewise.
	* cp-namespace.c (check_one_possible_namespace_symbol): Don't save
	name on the obstack.  Update call to SYMBOL_SET_NAMES.
@
text
@d889 1
a889 1
  (*objfile->sf->sym_read) (objfile, mainline);
@


1.257
log
@gdb/
	* symfile.c (separate_debug_file_exists): Change parameter parent_name
	to parent_objfile.  New variables parent_stat and abfd_stat.  Call
	strcmp and then bfd_stat functions to verify if NAME matches.
	(find_separate_debug_file): Update the passed parameter at caller.
@
text
@d3135 2
a3136 1
add_psymbol_to_bcache (char *name, int namelength, domain_enum domain,
d3166 1
a3166 1
  SYMBOL_SET_NAMES (&psymbol, name, namelength, objfile);
d3203 2
a3204 1
add_psymbol_to_list (char *name, int namelength, domain_enum domain,
d3216 1
a3216 1
  psym = add_psymbol_to_bcache (name, namelength, domain, class,
@


1.256
log
@	* dwarf2read.c (struct dwarf2_cu): Remove ranges_offset and
	has_ranges_offset.
	(struct partial_die_info): Remove language, has_stmt_list, dirname,
	and line_offset.
	(dwarf2_build_include_psymtabs): Take a die_info.  Handle a missing
	line table.
	(dwarf2_get_pc_bounds): Take PST argument.  Pass it
	to dwarf2_ranges_read.  Update all callers.
	(init_cu_die_reader): Move earlier.
	(dwarf2_find_base_address): New function.
	(process_psymtab_comp_unit): Rewrite to use a full DIE for the
	compilation unit.  Use dwarf2_get_pc_bounds and
	dwarf2_find_base_address.
	(load_comp_unit): Rewrite to use a full DIE for the compilation unit.
	(process_full_comp_unit): Use dwarf2_find_base_address.
	(read_partial_die): Remove support for attributes only used
	in the compilation unit DIE.
	* symfile.c (allocate_psymtab): Make FILENAME const.
	(start_psymtab_common): Likewise.
	* symfile.h (allocate_psymtab, start_psymtab_common): Update
	prototypes.
@
text
@d1311 1
a1311 1
			    const char *parent_name)
d1317 10
d1336 20
d1365 1
a1365 1
	       name, parent_name);
d1455 1
a1455 1
  if (separate_debug_file_exists (debugfile, crc32, objfile->name))
d1464 1
a1464 1
  if (separate_debug_file_exists (debugfile, crc32, objfile->name))
d1490 1
a1490 1
      if (separate_debug_file_exists (debugfile, crc32, objfile->name))
d1505 1
a1505 1
	  if (separate_debug_file_exists (debugfile, crc32, objfile->name))
@


1.255
log
@	* symmisc.c (print_symbol_bcache_statistics): Print filename cache
	statistics.
	(print_objfile_statistics): Likewise.
	* symfile.c (reread_symbols): Initialize filename_cache.
	(allocate_symtab): Cache the file name.
	(allocate_psymtab): Likewise.
	* solib-sunos.c (allocate_rt_common_objfile): Initialize
	filename_cache.
	* objfiles.h (struct objfile) <filename_cache>: New field.
	* objfiles.c (allocate_objfile): Initialize filename_cache.
	(free_objfile): Free filename_cache.
@
text
@d2768 1
a2768 1
allocate_psymtab (char *filename, struct objfile *objfile)
d3082 2
a3083 1
		      struct section_offsets *section_offsets, char *filename,
@


1.254
log
@	* symfile.c (add_psymbol_to_bcache): Make 'psymbol' static again.
	Zero the 'value' field.
@
text
@d2405 2
d2429 1
d2752 2
a2753 2
  symtab->filename = obsavestring (filename, strlen (filename),
				   &objfile->objfile_obstack);
d2783 2
a2784 2
  psymtab->filename = obsavestring (filename, strlen (filename),
				    &objfile->objfile_obstack);
@


1.253
log
@	* symtab.h (SYMBOL_SET_LINKAGE_NAME): Update comment.
	* symfile.c (allocate_symtab): Don't use obsavestring on a
	constant string.
	* stabsread.c (define_symbol): Don't use obsavestring on a
	constant string.
	* mdebugread.c (parse_type): Don't use obsavestring on a constant
	string.
	(new_symtab): Likewise.
	* elfread.c (elf_symtab_read): Don't use obsavestring on a
	constant string.
@
text
@d3108 9
a3116 3
  struct partial_symbol psymbol;

  memset (&psymbol, 0, sizeof (struct partial_symbol));
@


1.252
log
@	* symfile.c (add_psymbol_to_bcache): Don't copy name.  Make
	'psymbol' non-static.
@
text
@d2753 1
a2753 2
  symtab->debugformat = obsavestring ("unknown", 7,
				      &objfile->objfile_obstack);
@


1.251
log
@gdb/
	* symfile.c (build_id_to_debug_filename): New variable debugdir.  Move
	variables size, s and data into a new inner block.  Change xmalloc for
	alloca, use direct BUILDID->SIZE there now.  Loop for the
	DEBUG_FILE_DIRECTORY components.
	(find_separate_debug_file): New variable debugdir and debugdir_end.
	Loop for the DEBUG_FILE_DIRECTORY components.
	(_initialize_symfile): For "debug-file-directory" use plural and note
	one can use multiple components now.

gdb/doc/
	* gdb.texinfo (set debug-file-directory, show debug-file-directory)
	(Auto-loading): Use plural and note one can use multiple components now.

gdb/testsuite/
	* gdb.base/sepdebug.exp: New test_different_dir call for multiple-dirs.
@
text
@d3109 3
a3111 13
  char *buf = name;  
  /* psymbol is static so that there will be no uninitialized gaps in the
     structure which might contain random data, causing cache misses in
     bcache. */
  static struct partial_symbol psymbol;
  
  if (name[namelength] != '\0')
    {
      buf = alloca (namelength + 1);
      /* Create local copy of the partial symbol */
      memcpy (buf, name, namelength);
      buf[namelength] = '\0';
    }
d3126 1
a3126 1
  SYMBOL_SET_NAMES (&psymbol, buf, namelength, objfile);
@


1.250
log
@gdb/
	* symfile.c (find_separate_debug_file): Initialize dir, debugfile and
	canon_name to NULL.  Change alloca to xmalloc, newly call xfree for it.
	New label cleanup_return_debugfile, jump to it from the failure paths.
@
text
@d1221 1
a1221 3
  char *link, *s, *retval = NULL;
  gdb_byte *data = build_id->data;
  size_t size = build_id->size;
d1224 2
a1225 18
  link = xmalloc (strlen (debug_file_directory) + (sizeof "/.build-id/" - 1) + 1
		  + 2 * size + (sizeof ".debug" - 1) + 1);
  s = link + sprintf (link, "%s/.build-id/", debug_file_directory);
  if (size > 0)
    {
      size--;
      s += sprintf (s, "%02x", (unsigned) *data++);
    }
  if (size > 0)
    *s++ = '/';
  while (size-- > 0)
    s += sprintf (s, "%02x", (unsigned) *data++);
  strcpy (s, ".debug");

  /* lrealpath() is expensive even for the usually non-existent files.  */
  if (access (link, F_OK) == 0)
    retval = lrealpath (link);
  xfree (link);
d1227 5
a1231 1
  if (retval != NULL && !build_id_verify (retval, build_id))
d1233 39
a1271 2
      xfree (retval);
      retval = NULL;
d1273 1
d1360 1
a1360 1
  char *basename, *name_copy;
d1437 12
a1448 5
  /* Then try in the global debugfile directory.  */
  strcpy (debugfile, debug_file_directory);
  strcat (debugfile, "/");
  strcat (debugfile, dir);
  strcat (debugfile, basename);
d1450 3
a1452 2
  if (separate_debug_file_exists (debugfile, crc32, objfile->name))
    goto cleanup_return_debugfile;
d1454 2
a1455 8
  /* If the file is in the sysroot, try using its base path in the
     global debugfile directory.  */
  if (canon_name
      && strncmp (canon_name, gdb_sysroot, strlen (gdb_sysroot)) == 0
      && IS_DIR_SEPARATOR (canon_name[strlen (gdb_sysroot)]))
    {
      strcpy (debugfile, debug_file_directory);
      strcat (debugfile, canon_name + strlen (gdb_sysroot));
d1457 1
d1462 18
d1481 1
d4222 2
a4223 2
Set the directory where separate debug symbols are searched for."), _("\
Show the directory where separate debug symbols are searched for."), _("\
d4227 1
a4227 1
the global debug-file directory prepended."),
@


1.249
log
@gdb/
	* symfile.c (separate_debug_file_exists): When the CRCs mismatch
	print a warning.
	(find_separate_debug_file): Pass in the objfile's name.

gdb/testsuite/
	* gdb.base/sepdebug.exp (CRC mismatch is reported): New test.
	* gdb.base/sepdebug2.c: New file.
@
text
@d1336 4
a1339 5
  char *basename;
  char *dir;
  char *debugfile;
  char *name_copy;
  char *canon_name;
d1368 1
a1368 1
    return NULL;
d1390 6
a1395 6
  debugfile = alloca (strlen (debug_file_directory) + 1
                      + i
                      + strlen (DEBUG_SUBDIRECTORY)
                      + strlen ("/")
                      + strlen (basename)
                      + 1);
d1402 1
a1402 6
    {
      xfree (basename);
      xfree (dir);
      xfree (canon_name);
      return xstrdup (debugfile);
    }
d1411 1
a1411 6
    {
      xfree (basename);
      xfree (dir);
      xfree (canon_name);
      return xstrdup (debugfile);
    }
d1420 1
a1420 6
    {
      xfree (basename);
      xfree (dir);
      xfree (canon_name);
      return xstrdup (debugfile);
    }
d1434 1
a1434 6
	{
	  xfree (canon_name);
	  xfree (basename);
	  xfree (dir);
	  return xstrdup (debugfile);
	}
d1437 2
a1438 2
  if (canon_name)
    xfree (canon_name);
d1440 2
d1444 1
a1444 1
  return NULL;
@


1.248
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d1286 2
a1287 1
separate_debug_file_exists (const char *name, unsigned long crc)
d1307 9
a1315 1
  return crc == file_crc;
d1367 2
d1402 1
a1402 1
  if (separate_debug_file_exists (debugfile, crc32))
d1416 1
a1416 1
  if (separate_debug_file_exists (debugfile, crc32))
d1430 1
a1430 1
  if (separate_debug_file_exists (debugfile, crc32))
d1449 1
a1449 1
      if (separate_debug_file_exists (debugfile, crc32))
@


1.247
log
@2009-10-12  Tristan Gingold  <gingold@@adacore.com>

	* objfiles.c (objfile_has_symbols): New function.
	* objfiles.h (objfile_has_symbols): Add prototype.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Call
	objfile_has_symbols.
	(reread_symbols): Ditto.
@
text
@d2810 1
a2810 1
  set_default_breakpoint (0, 0, 0, 0);
@


1.246
log
@gdb/
	* objfiles.c (free_objfile): Clear SYMFILE_OBJFILE if it is OBJFILE.
	* rs6000-nat.c (vmap_ldinfo): Only assertion check SYMFILE_OBJFILE now.
	* symfile.c (syms_from_objfile, symbol_file_clear): Likewise.
@
text
@d1043 1
a1043 2
      && !objfile_has_partial_symbols (objfile)
      && !objfile_has_full_symbols (objfile))
d2424 1
a2424 2
	      if (!objfile_has_partial_symbols (objfile)
		  && !objfile_has_full_symbols (objfile))
@


1.245
log
@	* NEWS: Add note on "info sharedlibrary".
	Remove note on "set print symbol-loading".
	* main.c (captured_main): Pass !batch for from_tty when calling
	symbol_file_add_main.
	* objfiles.h (objfile_has_partial_symbols): Declare.
	(objfile_has_full_symbols): Declare.
	* objfiles.c (objfile_has_partial_symbols): New function.
	(have_partial_symbols): Use it.
	(objfile_has_full_symbols): New function.
	(have_full_symbols): Use it.
	* solib.c: Include interps.h.
	(solib_read_symbols): Back out patch of 2008-07-10.
	Add test for info_verbose for symbol loading messages for
	consistency with symfile.c.
	(info_sharedlibrary_command): Handle optional parameter of regex of
	libraries to list.  Inform user of libraries without debugging info.
	Rewrite to use ui_out routines to format output.
	* symfile.c (print_symbol_loading): Delete.
	(symbol_file_add_with_addrs_or_offsets): Back out patch of 2008-07-10.
	Print "no debugging symbols found" only if from_tty || info_verbose;
	and only check file being loaded, not all files.
	(reread_symbols): Test file being loaded for whether it has symbols,
	not all files.
	(__initialize_symfile): Delete `set print symbol-loading'.
	* symfile.h (print_symbol_loading): Delete.

	* doc/gdb.texinfo (Symbols): Delete `set print symbol-loading'.
	(Files): Add note on new optional regex arg to `info sharedlibrary'.
@
text
@d789 1
a789 1
	  symfile_objfile = NULL;
d1153 1
a1153 1
  symfile_objfile = NULL;
@


1.245.2.1
log
@gdb/
	* objfiles.c (free_objfile): Clear SYMFILE_OBJFILE if it is OBJFILE.
	* rs6000-nat.c (vmap_ldinfo): Only assertion check SYMFILE_OBJFILE now.
	* symfile.c (syms_from_objfile, symbol_file_clear): Likewise.
@
text
@d789 1
a789 1
	  gdb_assert (symfile_objfile == NULL);
d1153 1
a1153 1
  gdb_assert (symfile_objfile == NULL);
@


1.244
log
@2009-08-21  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* objfiles.h (gdb_bfd_ref): New prototype.
	* objfiles.c (gdb_bfd_ref): New function.
	(allocate_objfile): Call it.
	(gdb_bfd_unref): Adjust assertion.
	* solib.c (solib_map_sections): Add reference.
	(symbol_add_stub): Don't add reference here.
	* symfile.c (reread_symbols): Add reference.
@
text
@a173 7
/* If non-zero, gdb will notify the user when it is loading symbols
   from a file.  This is almost always what users will want to have happen;
   but for programs with lots of dynamically linked libraries, the output
   can be more noise than signal.  */

int print_symbol_loading = 1;

d985 3
a987 6
          if (print_symbol_loading)
	    {
	      printf_unfiltered (_("Reading symbols from %s..."), name);
	      wrap_here ("");
	      gdb_flush (gdb_stdout);
	    }
d1000 1
a1000 1
      if ((from_tty || info_verbose) && print_symbol_loading)
d1042 3
a1044 2
  if (!have_partial_symbols () && !have_full_symbols ()
      && print_symbol_loading)
d1047 1
a1047 5
      printf_unfiltered (_("(no debugging symbols found)"));
      if (from_tty || info_verbose)
        printf_unfiltered ("...");
      else
        printf_unfiltered ("\n");
d1056 1
a1056 4
	{
	  if (print_symbol_loading)
	    printf_unfiltered (_("done.\n"));
	}
d2425 2
a2426 1
	      if (!have_partial_symbols () && !have_full_symbols ())
a4194 8

  add_setshow_boolean_cmd ("symbol-loading", no_class,
                           &print_symbol_loading, _("\
Set printing of symbol loading messages."), _("\
Show printing of symbol loading messages."), NULL,
                           NULL,
                           NULL,
                           &setprintlist, &showprintlist);
@


1.243
log
@	* symfile.c (reread_symbols): Call objfiles_changed *before*
	calling clear_symtab_users.
@
text
@d2336 2
@


1.242
log
@	* symfile.c (find_separate_debug_file): Remove double free of
	canon_name.
@
text
@d2470 3
a2476 3

      /* Notify objfiles that we've modified objfile sections.  */
      objfiles_changed ();
@


1.241
log
@gdb/
	* objfiles.c (gdb_bfd_unref): Use the bfd_usrdata accessor.
	* solib.c (symbol_add_stub): Likewise.
	* symfile.c (symfile_bfd_open): Assert BFD_USRDATA is NULL.
@
text
@a1459 1
	  xfree (canon_name);
@


1.240
log
@gdb/
	Fix memory corruption on reread of file through a symbolic link.
	* symfile.c (find_separate_debug_file): Initialize CANON_NAME earlier.
	Allocate DEBUGFILE with length based on CANON_NAME.  Free CANON_NAME on
	all the return paths.
@
text
@d1641 3
@


1.239
log
@2009-07-22  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* symfile.c (symbol_file_add_with_addrs_or_offsets): Call observer.
@
text
@d1391 6
d1398 1
a1398 1
                      + strlen (dir)
d1412 1
d1426 1
d1440 1
a1445 1
  canon_name = lrealpath (dir);
d1460 1
@


1.238
log
@2009-07-22  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* objfiles.h (objfiles_changed): New prototype.
	* objfiles.c (objfiles_updated_p): Rename to objfiles_changed_p.
	(allocate_objfile, free_objfile): Must rebuild section map.
	(objfile_relocate): Likewise.
	(update_section_map, find_pc_section): Adjust.
	(set_objfiles_updated_on_exe_change): Remove.
	(set_objfiles_updated_on_solib_activity): Remove.
	(_initialize_objfiles): Remove.
	(objfiles_changed): New function.
	* symfile.c (reread_symbols): Call objfiles_changed.
@
text
@d1083 4
a1086 1
    return objfile;	/* No symbols. */
@


1.237
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d2460 3
a2463 1
      
@


1.236
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d132 2
a133 1
static void read_target_long_array (CORE_ADDR, unsigned int *, int, int);
d3754 1
a3754 1
			int len, int size)
d3762 1
a3762 1
    myaddr[i] = extract_unsigned_integer (size * i + buf, size);
d3773 1
d3796 1
d3798 2
a3799 1
  cache_novlys = read_memory_integer (SYMBOL_VALUE_ADDRESS (novlys_msym), 4);
d3805 1
a3805 1
                          cache_novlys * 4, word_size);
d3817 3
d3823 1
a3823 3
  if (msym != NULL)
    cache_novly_regions = read_memory_integer (SYMBOL_VALUE_ADDRESS (msym), 4);
  else
d3825 8
a3838 2
	  struct gdbarch *gdbarch = get_objfile_arch (msymbol_objfile (msym));
	  int word_size = gdbarch_long_bit (gdbarch) / TARGET_CHAR_BIT;
d3842 2
a3843 1
				  cache_novly_regions * 3, word_size);
d3870 1
d3880 1
a3880 1
				4, word_size);
@


1.235
log
@	* arch-utils.c (selected_byte_order): Return target_byte_order_user.
	(show_endian): Use target_byte_order_user if specified; otherwise
	use get_current_arch () instead of current_gdbarch.
	(show_architecture): Use set_architecture_string if specified;
	otherwise use get_current_arch () instead of current_gdbarch.
	(get_current_arch): New function.
	* arch-utils.h (get_current_arch): Add prototype.

	* osabi.c (show_osabi): Use get_current_arch () instead of
	current_gdbarch.

	* findcmd.c: Include "arch-utils.h".
	(parse_find_args): Add BIG_P argument.  Use it instead of byte order
	of current_gdbarch.
	(find_command): Use get_current_arch () instead of current_gdbarch.
	Pass byte order to parse_find_args.

	* maint.c: Include "arch-utils.h".
	(maintenance_print_architecture): Use get_current_arch () instead
	of current_gdbarch.

	* reggroups.c: Include "arch-utils.h".
	(maintenance_print_reggroups): Use get_current_arch () instead
	of current_gdbarch.

	* symfile.c: Include "arch-utils.h".
	(overlay_load_command): Use get_current_arch () instead of
	current_gdbarch.

	* value.c: Include "arch-utils.h".
	(show_convenience): Use get_current_arch () instead of
	current_gdbarch.

	* tui/tui-regs.c: Include "arch-utils.h".
	(tui_reg_next_command): Use get_current_arch () instead of
	current_gdbarch.

	* mi/mi-main.c: Include "arch-utils.h".
	(mi_cmd_data_read_memory): Use get_current_arch () instead of
	current_gdbarch.

	* parse.c: Include "arch-utils.h".
	(parse_exp_in_context): Use get_current_arch () instead of
	current_gdbarch.
@
text
@d1803 3
a1805 3
      ui_out_message (uiout, 0, "Loading section %s, size 0x%s lma 0x%s\n",
		      args->section_name, paddr_nz (args->section_size),
		      paddr_nz (args->lma));
d1822 2
a1823 2
	error (_("Download verify read failed at 0x%s"),
	       paddr (args->lma));
d1825 2
a1826 2
	error (_("Download verify compare failed at 0x%s"),
	       paddr (args->lma));
d1982 1
a1982 1
  ui_out_field_fmt (uiout, "address", "0x%s", paddr_nz (entry));
d2084 1
d2215 2
a2216 1
      printf_unfiltered ("\t%s_addr = %s\n", sec, paddress (addr));
d3508 1
d3519 1
a3519 1
	fputs_filtered (paddress (lma), gdb_stdout);
d3521 1
a3521 1
	fputs_filtered (paddress (lma + size), gdb_stdout);
d3523 1
a3523 1
	fputs_filtered (paddress (vma), gdb_stdout);
d3525 1
a3525 1
	fputs_filtered (paddress (vma + size), gdb_stdout);
@


1.234
log
@gdb/
	Fix a regression by the mmap patch from 2009-06-16.
	* symfile.c (reread_symbols): Move sym_finish and clear_objfile_data
	calls before deleting the OBJFILE obstack.  Extend the comment.
@
text
@d25 1
d3647 4
a3650 2
  if (gdbarch_overlay_update_p (current_gdbarch))
    gdbarch_overlay_update (current_gdbarch, NULL);
@


1.233
log
@2009-06-23  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	Revert 2009-05-14 breakpoint commit (no longer needed).
	* breakpoint.h (breakpoint_re_set_objfile): Remove
	* breakpoint.c (breakpoint_re_set_objfile): Likewise
	(create_overlay_event_breakpoint): Remove objfile parameter,
	iterate over all objfiles.
	* objfiles.c (objfile_relocate): Update.
	* symfile.c (new_symfile_objfile): Likewise.
@
text
@d2337 10
a2346 1
	         other parts of GDB that there is nothing currently there.  */
a2382 5
	      clear_objfile_data (objfile);
	      if (objfile->sf != NULL)
		{
		  (*objfile->sf->sym_finish) (objfile);
		}
@


1.232
log
@	* symfile.c (section_is_mapped): Use objfile architecture instead
	of current_gdbarch.
	(TARGET_LONG_BYTES): Remove.
	(read_target_long_array): Add SIZE argument.  Use it instead of
	TARGET_LONG_BYTES.
	(simple_read_overlay_table): Retrieve long size from objfile
	architecture; pass it to read_target_long_array.
	(simple_read_overlay_region_table): Likewise.
	(simple_overlay_update_1): Likewise.
@
text
@d922 1
a922 1
      breakpoint_re_set_objfile (objfile);
@


1.231
log
@2009-06-16  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* solib.c (symbol_add_stub): New FLAGS parameter.
	(solib_read_symbols): FROM_TTY -> FLAGS, call symbol_add_stub
	directly.
	(solib_add): Defer breakpoint_re_set until after all solibs.
	* bsd-uthread.c (bsd_uthread_solib_loaded): Adjust.
	* rs6000-nat.c (objfile_symbol_add): Adjust.
	* symfile.c (syms_from_objfile): Merge parameters into ADD_FLAGS.
	(new_symfile_objfile): Likewise.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	(symbol_file_add_from_bfd): Likewise.
	(symbol_file_add): Likewise.
	* symfile.h (enum symfile_add_flags): New. Adjust prototypes.
	* symfile-mem.c (symbol_file_add_from_memory): Adjust.
	* windows-nat.c (safe_symbol_file_add_stub): Adjust.
	* machoread.c (macho_oso_symfile, macho_symfile_read): Adjust.
@
text
@d131 1
a131 1
static void read_target_long_array (CORE_ADDR, unsigned int *, int);
d3291 2
d3304 2
a3305 1
      if (gdbarch_overlay_update_p (current_gdbarch))
d3313 1
a3313 1
	    gdbarch_overlay_update (current_gdbarch, osect);
a3713 2
#define TARGET_LONG_BYTES (gdbarch_long_bit (current_gdbarch) \
			    / TARGET_CHAR_BIT)
d3739 1
a3739 1
/* Read an array of ints from the target into a local buffer.
d3742 2
a3743 1
read_target_long_array (CORE_ADDR memaddr, unsigned int *myaddr, int len)
d3746 1
a3746 1
  gdb_byte *buf = alloca (len * TARGET_LONG_BYTES);
d3749 1
a3749 1
  read_memory (memaddr, buf, len * TARGET_LONG_BYTES);
d3751 1
a3751 2
    myaddr[i] = extract_unsigned_integer (TARGET_LONG_BYTES * i + buf,
					  TARGET_LONG_BYTES);
d3760 2
d3782 3
d3791 1
a3791 1
                          cache_novlys * 4);
d3816 2
d3821 1
a3821 1
				  cache_novly_regions * 3);
d3846 2
d3855 3
a3857 2
	read_target_long_array (cache_ovly_table_base + i * TARGET_LONG_BYTES,
				(unsigned int *) cache_ovly_table[i], 4);
@


1.230
log
@	* symfile.c (reread_symbols): Reset psymtabs_addrmap to NULL
	after discarding its contents.
@
text
@d743 3
a745 5
   MAINLINE is nonzero if this is the main symbol file, or zero if
   it's an extra symbol file such as dynamically loaded code.

   VERBO is nonzero if the caller has printed a verbose message about
   the symbol reading (and complaints can be more terse about it).  */
d752 1
a752 2
		   int mainline,
                   int verbo)
d756 1
d876 1
a876 1
  clear_complaints (&symfile_complaints, 1, verbo);
d907 1
a907 1
new_symfile_objfile (struct objfile *objfile, int mainline, int verbo)
d913 1
a913 1
  if (mainline)
d920 1
a920 1
  else
d926 1
a926 1
  clear_complaints (&symfile_complaints, 0, verbo);
d935 2
a936 4
   FROM_TTY says how verbose to be.

   MAINLINE specifies whether this is the main symbol file, or whether
   it's an extra symbol file such as dynamically loaded code.
d939 2
a940 2
   syms_from_objfile, above.  ADDRS is ignored when MAINLINE is
   non-zero.
d944 1
d946 2
a947 1
symbol_file_add_with_addrs_or_offsets (bfd *abfd, int from_tty,
d951 1
a951 1
                                       int mainline, int flags)
d959 1
d967 1
a967 1
      && mainline
d999 1
a999 1
		     mainline, from_tty);
d1033 1
a1033 1
            = symbol_file_add (debugfile, from_tty, orig_addrs, 0, flags);
d1038 1
a1038 1
            = symbol_file_add (debugfile, from_tty, NULL, 0, flags);
d1083 1
a1083 1
  new_symfile_objfile (objfile, mainline, from_tty);
d1098 1
a1098 1
symbol_file_add_from_bfd (bfd *abfd, int from_tty,
d1100 1
a1100 1
                          int mainline, int flags)
d1102 2
a1103 3
  return symbol_file_add_with_addrs_or_offsets (abfd,
						from_tty, addrs, 0, 0,
                                                mainline, flags);
d1111 2
a1112 2
symbol_file_add (char *name, int from_tty, struct section_addr_info *addrs,
		 int mainline, int flags)
d1114 2
a1115 2
  return symbol_file_add_from_bfd (symfile_bfd_open (name), from_tty,
                                   addrs, mainline, flags);
d1136 2
a1137 1
  symbol_file_add (args, from_tty, NULL, 1, flags);
d2226 2
a2227 1
  symbol_file_add (filename, from_tty, section_addrs, 0, flags);
d2509 1
a2509 1
            info_verbose, /* from_tty: Don't override the default. */
a2511 1
            0, /* Not mainline.  See comments about this above.  */
@


1.229
log
@	* symfile.c (add_shared_symbol_files_command): Remove
	prototype and function.
	(_initialize _symfile): Move "add-shared-symbol-files"
	command and "assf" alias.
	* windows-nat.c (_initialize_windows_nat): to here.
	Change "add-shared-symbol-files" to alias.

	* config/i386/cygwin.mh: Remove NAT_FILE.
	* config/i386/mingw.mh: Remove NAT_FILE.
	* config/i386/mingw64.mh: Remove NAT_FILE.
	* config/i386/nm-cygwin.h: Remove file.
	* config/i386/nm-cygwin64.h: Remove file.
@
text
@d2364 1
@


1.228
log
@	* target.h (struct section_table): Rename to ...
	(struct target_section): ... this.
	* exec.c: Adjust all references.
	* exec.h: Adjust all references.
	* nto-tdep.c: Adjust all references.
	* nto-tdep.h: Adjust all references.
	* ppc-linux-tdep.c: Adjust all references.
	* rs6000-nat.c: Adjust all references.
	* s390-tdep.c: Adjust all references.
	* solib-darwin.c: Adjust all references.
	* solib-frv.c: Adjust all references.
	* solib-irix.c: Adjust all references.
	* solib-null.c: Adjust all references.
	* solib-osf.c: Adjust all references.
	* solib-pa64.c: Adjust all references.
	* solib-som.c: Adjust all references.
	* solib-sunos.c: Adjust all references.
	* solib-svr4.c: Adjust all references.
	* solib-target.c: Adjust all references.
	* solib.c: Adjust all references.
	* solist.h: Adjust all references.
	* symfile.c: Adjust all references.
	* symfile.h: Adjust all references.
	* target.c: Adjust all references.
@
text
@a98 2
static void add_shared_symbol_files_command (char *, int);

d2235 1
a2235 10
static void
add_shared_symbol_files_command (char *args, int from_tty)
{
#ifdef ADD_SHARED_SYMBOL_FILES
  ADD_SHARED_SYMBOL_FILES (args, from_tty);
#else
  error (_("This command is not available in this configuration of GDB."));
#endif
}

a4093 7
  c = add_cmd ("add-shared-symbol-files", class_files,
	       add_shared_symbol_files_command, _("\
Load the symbols from shared objects in the dynamic linker's link map."),
	       &cmdlist);
  c = add_alias_cmd ("assf", "add-shared-symbol-files", class_files, 1,
		     &cmdlist);

@


1.227
log
@gdb/
	Remove the PROT parameter from openp.
	* source.c (openp): Remove the parameter PROT.  Assertion check MODE.
	defs.h (openp): Update the prototype.
	Update all the openp callers.
@
text
@d372 2
a373 2
build_section_addr_info_from_section_table (const struct section_table *start,
                                            const struct section_table *end)
d376 1
a376 1
  const struct section_table *stp;
@


1.226
log
@2009-05-14  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* breakpoint.h: Add breakpoint_re_set_objfile prototype.
	* breakpoint.c (create_overlay_event_breakpoint): Renamed
	from create_overlay_event_breakpoint_1, old
	create_overlay_event_breakpoint deleted.
	(breakpoint_re_set_objfile): Don't rescan all objfiles
	unnecessarily.
	(breakpoint_re_set): New function.
	* symfile.c (new_symfile_objfile): Call breakpoint_re_set_objfile
	instead of breakpoint_re_set.
	* objfiles.c (objfile_relocate): Likewise.
@
text
@d1588 1
a1588 1
		O_RDONLY | O_BINARY, 0, &absolute_name);
d1595 1
a1595 1
		    O_RDONLY | O_BINARY, 0, &absolute_name);
@


1.225
log
@	* inferior.h (read_pc, write_pc): Remove.
	* regcache.c (read_pc, write_pc): Remove.

	* infrun.c (displaced_step_fixup): Use regcache_read_pc instead
	of read_pc.
	(handle_inferior_event): Use regcache_read_pc instead of read_pc
	when determining value of stop_pc.  Replace subsequent uses of
	read_pc by inspecting already-retrieved stop_pc value.
	(keep_going): Use regcache_read_pc instead of read_pc.

	* breakpoint.c (watchpoint_check): Use current frame architecture
	and PC instead of current_gdbarch and read_pc ().
	* tracepoint.c (set_traceframe_context): Replace PC argument
	with FRAME argument.
	(trace_start_command, finish_tfind_command): Update calls.
	(finish_tfind_command): Compare frame IDs to identify transitions
	between frames.
	(trace_find_pc_command): Use regcache_read_pc instead of read_pc.
	* rs6000-nat.c (exec_one_dummy_insn): Pass in regcache instead
	of gdbarch.  Use regcache_read_pc and regcache_write_pc instead
	of read_pc and write_pc.
	(store_register): Make regcache argument non-const.  Update call
	to exec_one_dummy_insn.

	* thread.c (switch_to_thread): Use regcache_read_pc instead of read_pc.
	* infcmd.c (post_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (enable_break, svr4_relocate_main_executable): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* record.c (record_wait): Likewise.
	* procfs.c (procfs_wait): Likewise.
	* remote-mips.c (common_open, mips_wait): Likewise.
	* remote-m32r-sdi.c (m32r_resume): Likewise.

	* symfile.c (generic_load): Use regcache_write_pc instead of write_pc.
	* monitor.c (monitor_create_inferior, monitor_load): Likewise.
	* m32r-rom.c (m32r_load, m32r_upload_command): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior, m32r_load): Likewise.
	* remote-mips.c (mips_create_inferior, mips_load): Likewise.

	* solib-darwin.c: Include "regcache.h".
	* solib-pa64.c: Include "regcache.h".
	* solib-svr4.c: Include "regcache.h.".

	* symfile.c: Do not mention read_pc or write_pc in comments.
	* dink32-rom.c: Likewise.
	* m32r-rom.c: Likewise.
	* mips-tdep.c: Likewise.
@
text
@d926 1
a926 1
      breakpoint_re_set ();
@


1.224
log
@	* symfile.c (symbol_file_clear): Fix indentation.
@
text
@d40 2
a41 1
#include "inferior.h"		/* for write_pc */
d1990 1
a1990 1
  write_pc (entry);
@


1.223
log
@	* symfile.c (symfile_relocate_debug_section): Remove check for
	SEC_DEBUGGING.
@
text
@a1157 1
    free_all_objfiles ();
d1159 10
a1168 9
    /* solib descriptors may have handles to objfiles.  Since their
       storage has just been released, we'd better wipe the solib
       descriptors as well.
     */
    no_shared_libraries (NULL, from_tty);

    symfile_objfile = NULL;
    if (from_tty)
      printf_unfiltered (_("No symbol file now.\n"));
@


1.222
log
@2009-02-25  Hui Zhu  <teawater@@gmail.com>

	* cli/cli-script.c (define_command): Add _() to query.
	* gnu-nat.c (inf_validate_task_sc): Ditto.
	* infcmd.c (kill_if_already_running): Ditto.
	(jump_command): Ditto.
	(attach_command): Ditto.
	* inflow.c (kill_command): Ditto.
	* infrun.c (handle_command): Ditto.
	* maint.c (maintenance_dump_me): Ditto.
	* memattr.c (mem_delete_command): Ditto.
	* monitor.c (monitor_interrupt_query): Ditto.
	* nto-procfs.c (interrupt_query): Ditto.
	* printcmd.c (undisplay_command): Ditto.
	* remote-mips.c (mips_kill): Ditto.
	* remote.c (interrupt_query): Ditto.
	* solib-irix.c (irix_open_symbol_file_object): Ditto.
	* solib-osf.c (osf_open_symbol_file_object): Ditto.
	* solib-pa64.c (pa64_open_symbol_file_object): Ditto.
	* solib-som.c (som_open_symbol_file_object): Ditto.
	* solib-svr4.c (open_symbol_file_object): Ditto.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Ditto.
	* target.c (kill_or_be_killed): Ditto.
	* tracepoint.c (delete_trace_command): Ditto.
	* top.c (quit_confirm): Add _() to s that will be used
	in query.
@
text
@d3943 4
a3946 1
   the relocations in order to get the locations of symbols correct.  */
d3951 1
a3951 1
  /* We're only interested in debugging sections with relocation
a3954 2
  if ((sectp->flags & SEC_DEBUGGING) == 0)
    return NULL;
@


1.221
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d971 1
a971 1
      && !query ("Load new symbol table from \"%s\"? ", name))
@


1.220
log
@	PR breakpoints/9350:
	* varobj.c (varobj_invalidate): Unconditionally free
	all_rootvarobj.
	* symfile.c (syms_from_objfile): Free local_addr when returning
	normally.
	* exec.c (exec_file_attach): Do cleanups before returning.
	(exec_file_command): Likewise.
	* corefile.c (reopen_exec_file): Do cleanups before returning.
	* breakpoint.c (insert_breakpoint_locations): Do cleanups before
	returning.
	(do_vec_free): New function.
	(update_global_location_list): Make a cleanup for old_locations.
	Do cleanups before returning.  Remove unused variable 'e'.
	(find_condition_and_thread): Free result of parsing the
	expression.
	(print_it_typical): Do cleanups before returning.
	(breakpoint_re_set_one): Always free sals.sals.
@
text
@d483 1
a483 1
void
@


1.219
log
@        Updated copyright notices for most files.
@
text
@d902 1
@


1.218
log
@2008-10-03  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* utils.c, defs.h (gdb_buildargv): New fn. Wrap buildargv
	and check for out-of-memory condition.
	* exec.c (exec_file_command): Call it.
	* infrun.c (handle_command, xdb_handle_command): Likewise.
	* interps.c (interpreter_exec_cmd): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* procfs.c (info_proc_cmd): Likewise.
	* remote-mips.c (common_open): Likewise.
	* remote-sim.c (gdbsim_kill, gdbsim_create_inferior)
	(gdbsim_open): Likewise.
	* remote.c (extended_remote_run, remote_put_command)
	(remote_get_command, remote_delete_command): Likewise.
	* ser-mingw.c (pipe_windows_open): Likesise.
	* source.c (add_path, show_substitute_path_command)
	(unset_substitute_path_command, set_substitute_path_command):
	Likewise.
	* stack.c (backtrace_command): Likewise.
	* symfile.c (symbol_file_command, generic_load)
	(add_symbol_file_command): Likesise.
	* symmisc.c (maintenance_print_symbols, maintenance_print_psymbols)
	(maintenance_print_msymbols): Likewise.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.218.2.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@a51 1
extern struct exec *last_exec_created;
d793 2
a794 2
      /* (But not in the multiprocess case.)  */
      if (symfile_objfile != NULL && number_of_execs () <= 1)
a919 10
      /* Use the exec object smuggled through this global (a
	 workaround due to the inability of command processing in
	 main.c to pass additional arguments).  */
      if (last_exec_created)
	{
	  last_exec_created->objfile = objfile;
	  objfile->exec = last_exec_created;
	  last_exec_created = NULL;
	}

d1152 4
a1155 1
      && !query (_("Discard all symbol tables? ")))
d1167 1
a1167 1
      printf_unfiltered (_("No symbol files now.\n"));
d2306 7
a2312 5
	      /* If this objfile is also one of our executables,
		 update that.  */
	      if (objfile->exec
		  && objfile->exec->objfile == objfile)
		exec_file_update (objfile->exec);
a3198 26
/* Given a pc and inferior, return a section.  */

struct obj_section *
find_pc_inf_sect (CORE_ADDR pc, struct inferior *inf)
{
  struct objfile *objfile;
  struct obj_section *osect;
  asection *section;
  int size;

  ALL_OBJSECTIONS (objfile, osect)
    {
      if (!inf || objfile->exec == inf->exec)
	{
	  section = osect->the_bfd_section;
	  if (section)
	    {
	      size = bfd_get_section_size (section);
	      if (section->vma <= pc && pc < section->vma + size)
		return osect;
	    }
	}
    }
  return NULL;
}

@


1.217
log
@	* symfile.c (syms_from_objfile): Update.
	(reread_symbols): Update.
	* objfiles.h (OBJF_SYMS): Remove.
	(OBJF_REORDERED): Renumber.
	(OBJF_SHARED): Likewise.
	(OBJF_READNOW): Likewise.
	(OBJF_USERLOADED): Likewise.
@
text
@d1486 1
a1486 1
      char **argv = buildargv (args);
a1490 3
      if (argv == NULL)
	nomem (0);

d1924 2
a1925 4
  argv = buildargv (args);

  if (argv == NULL)
    nomem(0);
d1927 1
d2116 1
a2116 1
  argv = buildargv (args);
a2118 3
  if (argv == NULL)
    nomem (0);

@


1.216
log
@	* symfile.c (symbol_file_add_with_addrs_or_offsets): Don't use
	printf_filtered.
@
text
@a898 5
  /* Mark the objfile has having had initial symbol read attempted.  Note
     that this does not mean we found any symbols... */

  objfile->flags |= OBJF_SYMS;

a2437 1
	      objfile->flags |= OBJF_SYMS;
@


1.215
log
@	* symfile.c (build_id_verify): Free 'found'.
	(find_separate_debug_file): Use xfree, not free.
@
text
@d1060 1
a1060 1
      printf_filtered (_("(no debugging symbols found)"));
d1062 1
a1062 1
        printf_filtered ("...");
d1064 1
a1064 1
        printf_filtered ("\n");
@


1.214
log
@	* gdbtypes.h (builtin_type_void): Remove macro, add declaration.
	(builtin_type_f_void): Remove macro.
	* gdbtypes.c (builtin_type_void): New global variable.
	(_initialize_gdbtypes): Initialize it.

	* gnu-v3-abi.c (build_gdb_vtable_type): Do not call
	lookup_pointer_type or lookup_function_type on builtin_type_void.
	* printcmd.c (set_next_address): Likewise.
	* objc-lang.c (value_nsstring): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* symfile.c (syms_from_objfile): Remove special handling
	of builtin_type_void and builtin_type_char.
@
text
@d1230 3
d1361 1
a1361 1
      free (build_id);
@


1.213
log
@	* breakpoint.h (struct bp_location): Change type of section
	member to "struct obj_section *".
	* tracepoint.h (struct tracepoint): Likewise.
	* symtab.h (struct general_symbol_info): Replace bfd_section
	member with obj_section.
	(struct symtab_and_line): Change type of section member to
	"struct obj_section *".
	(SYMBOL_BFD_SECTION): Remove macro, replace by ...
	(SYMBOL_OBJ_SECTION): ... this.

	* minsym.c (prim_record_minimal_symbol_and_info): Record symbol
	section as obj_section instead of bfd_section.

	* ada-lang.c (ada_decode_symbol): Use gsymbol->obj_section
	directly instead of looking of obj_section from bfd_section.

	* objfiles.h (find_pc_sect_section): Remove.
	* objfiles.c (find_pc_sect_section): Remove.
	(find_pc_section): Inline find_pc_sect_section code.

	* symfile.h (find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(section_is_overlay, section_is_mapped): Change type of section
	argument to struct obj_section *.
	(pc_in_mapped_range, pc_in_unmapped_range): Likewise.
	(overlay_mapped_address, overlay_unmapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	* symtab.h (symbol_overlayed_address): Likewise.
	* symfile.c (overlay_is_mapped): Remove.
	(section_is_mapped): Inline overlay_is_mapped code.  Update.
	(overlay_invalidate_all): Update.
	(section_is_overlay): Change section argument to type
	"struct obj_section *".  Use bfd_ methods.
	(pc_in_unmapped_range): Likewise.  Handle relocated sections.
	(pc_in_mapped_range): Likewise.  Handle relocated sections.
	(sections_overlap): Likewise.
	(overlay_unmapped_address): Likewise.
	(overlay_mapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	(find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(list_overlays_command): Update.
	(map_overlay_command, unmap_overlay_command): Update.
	(simple_overlay_update): Update.

	* block.h (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* block.c (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* symtab.h (find_pc_sect_function, find_pc_sect_psymtab,
	find_pc_sect_symtab, find_pc_sect_psymbol, find_pc_sect_line,
	lookup_minimal_symbol_by_pc_section, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.
	* blockframe.c (find_pc_sect_function): Likewise.
	* breakpoint.c (describe_other_breakpoints): Likewise.
	(breakpoint_has_pc, check_duplicates_for): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_minimal_symbol_by_pc_section): Likewise.
	* symtab.c (find_pc_sect_psymtab_closer): Likewise.
	(find_pc_sect_psymtab, find_pc_sect_psymbol, find_pc_sect_symtab,
	find_pc_sect_line, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.

	* blockframe.c (find_pc_partial_function): Update to section
	type changes.  No longer call find_pc_sect_section.
	(cache_pc_function_section): Change to type "struct obj_section *".
	* breakpoint.c (resolve_sal_pc): Update to section type changes.
	* exec.c (xfer_memory): Likewise.
	* findvar.c (read_var_value): Likewise.
	* infcmd.c (jump_command): Likewise.
	* linespec.c (minsym_found): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_solib_trampoline_symbol_by_pc): Likewise.
	* parse.c (write_exp_msymbol): Likewise.
	* printcmd.c (build_address_symbolic): Likewise.
	(address_info, sym_info): Likewise.
	* symmisc.c (dump_msymbols, print_symbol): Likewise.
	* symtab.c (fixup_section): Likewise.
	(fixup_symbol_section, fixup_psymbol_section): Likewise.
	(find_pc_line, find_function_start_sal): Likewise.
	* target.c (memory_xfer_partial): Likewise.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline): Likewise.
	* spu-tdep.c (spu_overlay_update): Likewise.
@
text
@a898 8
  /* Don't allow char * to have a typename (else would get caddr_t).
     Ditto void *.  FIXME: Check whether this is now done by all the
     symbol readers themselves (many of them now do), and if so remove
     it from here.  */

  TYPE_NAME (lookup_pointer_type (builtin_type_char)) = 0;
  TYPE_NAME (lookup_pointer_type (builtin_type_void)) = 0;

@


1.212
log
@ChangeLog:

	* remote.h (remote_filename_p, remote_bfd_open): Add prototypes.
	* remote.c (remote_bfd_iovec_open, remote_bfd_iovec_close,
	remote_bfd_iovec_pread, remote_bfd_iovec_stat, remote_filename_p,
	remote_bfd_open): New functions.
	(remote_hostio_send_command): Fail safely if remote connection
	is not set up.

	* solist.h (solib_open): Remove prototype.
	(solib_bfd_open): Add prototype.
	* solib.c: Include "remote.h".
	(solib_open): Remove, replace by ...
	(solib_bfd_open): ... this new function.  Handle remote BFDs.
	(solib_map_sections): Replace solib_open by solib_bfd_open.
	* solib-frv.c: Include "exceptions.h".
	(enable_break2): Replace solib_open by solib_bfd_open.
	* solib-svr4.c: Include "exceptions.h".
	(enable_break): Replace solib_open by solib_bfd_open.

	* symfile.c: Include "remote.h".
	(build_id_verify): Handle remote BFDs.
	(separate_debug_file_exists): Use BFD to access file.  Handle
	remote BFDs.
	(symfile_bfd_open): Handle remote BFDs.
	(reread_symbols): Handle remote BFDs.

	* NEWS: Mention "remote:" argument prefix to "set sysroot".

doc/ChangeLog:

	* gdb.texinfo (Commands to Specify Files): Document "remote:"
	argument prefix to "set sysroot".
@
text
@a113 2
static int overlay_is_mapped (struct obj_section *);

d3254 1
a3254 1
   overlay_is_mapped(sect):       true if overlay is marked as mapped
d3276 1
a3276 1
section_is_overlay (asection *section)
d3278 10
a3287 6
  /* FIXME: need bfd *, so we can use bfd_section_lma methods. */

  if (overlay_debugging)
    if (section && section->lma != 0 &&
	section->vma != section->lma)
      return 1;
d3302 2
a3303 2
    if (section_is_overlay (sect->the_bfd_section))
    sect->ovly_mapped = -1;
d3306 1
a3306 1
/* Function: overlay_is_mapped (SECTION)
a3307 1
   Private: public access is thru function section_is_mapped.
d3315 2
a3316 2
static int
overlay_is_mapped (struct obj_section *osect)
d3318 1
a3318 1
  if (osect == 0 || !section_is_overlay (osect->the_bfd_section))
a3344 18
/* Function: section_is_mapped
   Returns true if section is an overlay, and is currently mapped.  */

int
section_is_mapped (asection *section)
{
  struct objfile *objfile;
  struct obj_section *osect;

  if (overlay_debugging)
    if (section && section_is_overlay (section))
      ALL_OBJSECTIONS (objfile, osect)
	if (osect->the_bfd_section == section)
	return overlay_is_mapped (osect);

  return 0;
}

d3349 1
a3349 1
pc_in_unmapped_range (CORE_ADDR pc, asection *section)
d3351 8
a3358 1
  /* FIXME: need bfd *, so we can use bfd_section_lma methods. */
d3360 4
a3363 1
  int size;
a3364 7
  if (overlay_debugging)
    if (section && section_is_overlay (section))
      {
	size = bfd_get_section_size (section);
	if (section->lma <= pc && pc < section->lma + size)
	  return 1;
      }
d3372 1
a3372 1
pc_in_mapped_range (CORE_ADDR pc, asection *section)
d3374 6
a3379 1
  /* FIXME: need bfd *, so we can use bfd_section_vma methods. */
a3380 9
  int size;

  if (overlay_debugging)
    if (section && section_is_overlay (section))
      {
	size = bfd_get_section_size (section);
	if (section->vma <= pc && pc < section->vma + size)
	  return 1;
      }
d3388 1
a3388 1
sections_overlap (asection *a, asection *b)
d3390 4
a3393 6
  /* FIXME: need bfd *, so we can use bfd_section_vma methods. */

  CORE_ADDR a_start = a->vma;
  CORE_ADDR a_end = a->vma + bfd_get_section_size (a);
  CORE_ADDR b_start = b->vma;
  CORE_ADDR b_end = b->vma + bfd_get_section_size (b);
d3403 1
a3403 1
overlay_unmapped_address (CORE_ADDR pc, asection *section)
d3405 4
a3408 1
  /* FIXME: need bfd *, so we can use bfd_section_lma methods. */
d3410 3
a3412 4
  if (overlay_debugging)
    if (section && section_is_overlay (section) &&
	pc_in_mapped_range (pc, section))
      return pc + section->lma - section->vma;
d3422 1
a3422 1
overlay_mapped_address (CORE_ADDR pc, asection *section)
d3424 4
a3427 1
  /* FIXME: need bfd *, so we can use bfd_section_vma methods. */
d3429 3
a3431 4
  if (overlay_debugging)
    if (section && section_is_overlay (section) &&
	pc_in_unmapped_range (pc, section))
      return pc + section->vma - section->lma;
d3442 1
a3442 1
symbol_overlayed_address (CORE_ADDR address, asection *section)
d3470 1
a3470 1
asection *
d3478 1
a3478 1
      if (section_is_overlay (osect->the_bfd_section))
d3480 1
a3480 1
	if (pc_in_mapped_range (pc, osect->the_bfd_section))
d3482 2
a3483 2
	    if (overlay_is_mapped (osect))
	      return osect->the_bfd_section;
d3487 1
a3487 1
	else if (pc_in_unmapped_range (pc, osect->the_bfd_section))
d3490 1
a3490 1
  return best_match ? best_match->the_bfd_section : NULL;
d3497 1
a3497 1
asection *
d3505 2
a3506 3
      if (pc_in_mapped_range (pc, osect->the_bfd_section) &&
	  overlay_is_mapped (osect))
      return osect->the_bfd_section;
d3523 1
a3523 1
      if (overlay_is_mapped (osect))
a3557 1
  asection *bfdsec;
d3572 1
a3572 2
      bfdsec = sec->the_bfd_section;
      if (!section_is_overlay (bfdsec))
d3581 1
a3581 5
	if (sec2->ovly_mapped
            && sec != sec2
            && sec->the_bfd_section != sec2->the_bfd_section
            && sections_overlap (sec->the_bfd_section,
                                 sec2->the_bfd_section))
d3921 1
a3921 1
    if (section_is_overlay (osect->the_bfd_section))
@


1.211
log
@	* objfiles.h (struct obj_section): Remove addr and endaddr fields.
	(obj_section_offset, obj_section_addr, obj_section_endaddr): New
	macros.
	* objfiles.c (add_to_objfile_sections): Don't set addr, endaddr
	and offset.  Use size_t instead of unsigned long.
	(build_objfile_section_table): Use size_t instead of unsigned
	long.
	(objfile_relocate): Don't relocate s->addr and s->endaddr, they're
	gone.
	(find_pc_sect_section): Use obj_section_addr and
	obj_section_endaddr.
	* symfile.c (symfile.c): Remove code that maps sections
	offsets in "addr" to the object's sections.
	* blockframe.c (find_pc_partial_function): Use obj_section_endaddr.
	* gcore.c (gcore_create_callback): Use obj_section_addr and
	obj_section_endaddr.
	* maint.c (print_objfile_section_info): Likewise.
	* printcmd.c (sym_info): Use obj_section_addr and
	obj_section_endaddr.
	* symtab.c (fixup_section): Likewise.
@
text
@d56 1
d1220 4
a1223 1
  abfd = bfd_openr (filename, gnutarget);
d1314 1
a1314 1
  int fd;
d1318 6
a1323 2
  fd = open (name, O_RDONLY | O_BINARY);
  if (fd < 0)
d1326 1
a1326 1
  while ((count = read (fd, buffer, sizeof (buffer))) > 0)
d1329 1
a1329 1
  close (fd);
d1575 22
d1627 1
a1627 1
      error (_("\"%s\": can't open to read symbols: %s."), name,
d1639 1
a1639 1
      error (_("\"%s\": can't read symbols: %s."), name,
d2340 4
a2343 1
	      objfile->obfd = bfd_openr (obfd_filename, gnutarget);
@


1.210
log
@	* symfile.c (reread_symbols): Update.
	* solib-sunos.c (allocate_rt_common_objfile): Update.
	* objfiles.c (allocate_objfile): Update.
	* objfiles.h (struct objfile) <md, mmfd, deprecated_obj_private>:
	Remove.
@
text
@a897 50
#ifndef DEPRECATED_IBM6000_TARGET
  /* This is a SVR4/SunOS specific hack, I think.  In any event, it
     screws RS/6000.  sym_offsets should be doing this sort of thing,
     because it knows the mapping between bfd sections and
     section_offsets.  */
  /* This is a hack.  As far as I can tell, section offsets are not
     target dependent.  They are all set to addr with a couple of
     exceptions.  The exceptions are sysvr4 shared libraries, whose
     offsets are kept in solib structures anyway and rs6000 xcoff
     which handles shared libraries in a completely unique way.

     Section offsets are built similarly, except that they are built
     by adding addr in all cases because there is no clear mapping
     from section_offsets into actual sections.  Note that solib.c
     has a different algorithm for finding section offsets.

     These should probably all be collapsed into some target
     independent form of shared library support.  FIXME.  */

  if (addrs)
    {
      struct obj_section *s;

 	/* Map section offsets in "addr" back to the object's
 	   sections by comparing the section names with bfd's
 	   section names.  Then adjust the section address by
 	   the offset. */ /* for gdb/13815 */

      ALL_OBJFILE_OSECTIONS (objfile, s)
	{
	  CORE_ADDR s_addr = 0;
	  int i;

 	    for (i = 0;
	         !s_addr && i < addrs->num_sections && addrs->other[i].name;
		 i++)
 	      if (strcmp (bfd_section_name (s->objfile->obfd,
					    s->the_bfd_section),
			  addrs->other[i].name) == 0)
 	        s_addr = addrs->other[i].addr; /* end added for gdb/13815 */

	  s->addr -= s->offset;
	  s->addr += s_addr;
	  s->endaddr -= s->offset;
	  s->endaddr += s_addr;
	  s->offset += s_addr;
	}
    }
#endif /* not DEPRECATED_IBM6000_TARGET */

@


1.209
log
@	* symfile.c (add_psymbol_to_bcache): Return a const pointer.  Use
	bcache_full.
	(append_psymbol_to_list): Accept a const pointer.
	(add_psymbol_to_list): Fix const correctness.
	* bcache.h: (deprecated_bcache_added, deprecated_bcache): Remove.
	(bcache_full): Declare.
	* bcache.c (bcache_data, deprecated_bcache): Remove.
	(bcache): Use bcache_full.
	(bcache_full): Rename from deprecated_bcache_added.  Change return
	type.
@
text
@a2423 2
	      /* We never make this a mapped file.  */
	      objfile->md = NULL;
@


1.208
log
@gdb
	* symfile.c (reread_symbols): Don't pass argument to observer.
	* exec.c (exec_file_attach): Don't pass argument to observer.
	* ada-lang.c (ada_executable_changed_observer): Remove argument.
	* symtab.c (symtab_observer_executable_changed): Remove argument.
	* observer.sh: Handle functions with no arguments.
gdb/doc
	* observer.texi (GDB Observers): Remove obsolete comment.
	<executable_changed>: Remove argument.
@
text
@d3102 1
a3102 1
static struct partial_symbol *
d3140 2
a3141 2
  return deprecated_bcache_added (&psymbol, sizeof (struct partial_symbol),
				  objfile->psymbol_cache, added);
d3149 1
a3149 1
			struct partial_symbol *psym,
d3154 1
a3154 1
  *list->next++ = psym;
d3181 1
a3181 1
  struct partial_symbol *psym;
@


1.207
log
@	Add "set print symbol-loading on|off".
	* NEWS: Document new option.
	* symfile.h (print_symbol_loading): Declare.
	* symfile.c (print_symbol_loading): New global.
	(symbol_file_add_with_addrs_or_offsets): Only print "Reading symbols
	from ..." if print_symbol_loading.
	(_initialize_symfile): Add set/show print symbol-loading.
	* solib.c (solib_read_symbols): Only print "Loaded symbols for ..."
	if print_symbol_loading.

	* doc/gdb.texinfo: Document "set print symbol-loading on|off".
@
text
@d2498 1
a2498 1
      observer_notify_executable_changed (NULL);
@


1.206
log
@gdb/
2008-07-09  Pedro Alves  <pedro@@codesourcery.com>

	* symfile.c (load_command): Reopen the exec file and reread
	symbols before anything else.

gdb/testsuite/
2008-07-09  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.base/chng-syms.exp: Don't expect "No symbol ...".
@
text
@d174 6
d1055 6
a1060 3
	  printf_unfiltered (_("Reading symbols from %s..."), name);
	  wrap_here ("");
	  gdb_flush (gdb_stdout);
d1073 1
a1073 1
      if (from_tty || info_verbose)
d1115 2
a1116 1
  if (!have_partial_symbols () && !have_full_symbols ())
d1133 2
a1134 1
	  printf_unfiltered (_("done.\n"));
d4233 8
@


1.205
log
@	* bcache.c (bcache_data): Call deprecated_bcache_added function.
	(deprecated_bcache_added): New function name. Body of function
	bcache_data is used here with the addition of 'added' argument.
	* bcache.h (deprecated_bcache_added): New function.
	* symfile.c (add_psymbol_to_bcache): New helper function, takes part of
	work from add_psymbol_to_list - initialises partial symbol and stashes
	it in objfile's cache.
	(append_psymbol_to_list): New helper function, takes other part of
	work from add_psymbol_to_list - adds partial symbol to the given list.
	(add_psymbol_to_list): Call helper functions instead of doing work
	here. If adding to global list, do not duplicate partial symbols in the
	partial symtab.
@
text
@d1711 5
a1752 5
  /* The user might be reloading because the binary has changed.  Take
     this opportunity to check.  */
  reopen_exec_file ();
  reread_symbols ();

@


1.204
log
@	* remote.c (get_offsets): Handle a single segment.
	* symfile.c (symfile_map_offsets_to_segments): Allow more bases
	than segments.
@
text
@d3085 62
d3165 2
a3166 1
		     struct psymbol_allocation_list *list, long val,	/* Value as a long */
a3170 22
  char *buf = alloca (namelength + 1);
  /* psymbol is static so that there will be no uninitialized gaps in the
     structure which might contain random data, causing cache misses in
     bcache. */
  static struct partial_symbol psymbol;

  /* Create local copy of the partial symbol */
  memcpy (buf, name, namelength);
  buf[namelength] = '\0';
  /* val and coreaddr are mutually exclusive, one of them *will* be zero */
  if (val != 0)
    {
      SYMBOL_VALUE (&psymbol) = val;
    }
  else
    {
      SYMBOL_VALUE_ADDRESS (&psymbol) = coreaddr;
    }
  SYMBOL_SECTION (&psymbol) = 0;
  SYMBOL_LANGUAGE (&psymbol) = language;
  PSYMBOL_DOMAIN (&psymbol) = domain;
  PSYMBOL_CLASS (&psymbol) = class;
d3172 1
a3172 1
  SYMBOL_SET_NAMES (&psymbol, buf, namelength, objfile);
d3175 7
a3181 2
  psym = deprecated_bcache (&psymbol, sizeof (struct partial_symbol),
			    objfile->psymbol_cache);
d3184 1
a3184 7
  if (list->next >= list->list + list->size)
    {
      extend_psymbol_list (list, objfile);
    }
  *list->next++ = psym;
  OBJSTAT (objfile, n_psyms++);

@


1.203
log
@	* symfile.c (reread_symbols): Update objfile's entry point.
@
text
@d4002 3
a4004 4
   If there are more, then verify that all the excess addresses are
   the same as the last legitimate one, and then ignore them.  This
   allows "TextSeg=X;DataSeg=X" qOffset replies for files which have
   only a single segment.  */
a4022 6
  /* Check any extra SEGMENT_BASES entries.  */
  if (num_segment_bases > data->num_segments)
    for (i = data->num_segments; i < num_segment_bases; i++)
      if (segment_bases[i] != segment_bases[data->num_segments - 1])
	return 0;

@


1.202
log
@	* symfile.c (reread_symbols): Reload EXEC_BFD on its change.
@
text
@d2477 1
@


1.201
log
@	* symfile.c (add_symbol_file_command):  Use paddress rather than
	hex_string to print the address.
@
text
@d2334 8
@


1.200
log
@	* Makefile.in (objfiles.o): Update.
	* exec.c (exec_set_section_address): Support p->addr != 0.
	* objfiles.c (objfile_relocate): Update exec_ops section
	addresses.
	* symfile.c (place_section): Move exec_set_section_address call...
	(default_symfile_offsets): ...to here.
@
text
@d2242 1
a2242 2
      printf_unfiltered ("\t%s_addr = %s\n",
		       sec, hex_string ((unsigned long)addr));
@


1.199
log
@	* symfile.c (syms_from_objfile): Don't warn if lowest loadable
	section is not a code section.
@
text
@a537 2

  exec_set_section_address (bfd_get_filename (abfd), sect->index, start_addr);
d636 2
@


1.198
log
@	* Makefile.in (symfile.o): Update.
	* NEWS: Mention exec tracing support.
	* inf-ttrace.c (inf_ttrace_wait): Return TARGET_WAITKIND_EXECD for
	exec events.
	* infcmd.c (kill_if_already_running, detach_command)
	(disconnect_command): Replace SOLIB_RESTART with no_shared_libraries.
	* infrun.c (MAY_FOLLOW_EXEC, may_follow_exec): Delete.
	(follow_exec): Do not check may_follow_exec.  Do not mourn and push
	targets.  Apply the sysroot path to the loaded executable.  Use
	no_shared_libraries.
	* linux-nat.c (linux_child_follow_fork): Print fork following
	messages if verbose.
	(kill_wait_callback): Kill again before waiting a second time.
	* symfile.c (symbol_file_clear): Replace SOLIB_RESTART with
	no_shared_libraries.

	* gdb.base/foll-exec.exp: Update header.  Skip on remote targets.
	Run on GNU/Linux.
	(do_exec_tests): Check for systems which do not support catchpoints.
	Do not match START.
	* gdb.base/foll-fork.exp: Update header.  Skip on remote targets.
	Run on GNU/Linux.  Enable verbose output.
	(check_fork_catchpoints): New.
	(explicit_fork_child_follow, catch_fork_child_follow)
	(tcatch_fork_parent_follow): Update expected messages.
	(do_fork_tests): Use check_fork_catchpoints.
	* gdb.base/foll-vfork.exp: Update header.  Skip on remote targets.
	Run on GNU/Linux.  Enable verbose output.
	(check_vfork_catchpoints): New.
	(vfork_parent_follow_to_bp, tcatch_vfork_then_child_follow): Update
	expected messages.
	(do_vfork_and_exec_tests): Use check_fork_catchpoints.
@
text
@d824 5
a828 10
	warning (_("no loadable sections found in added symbol-file %s"),
		 objfile->name);
      else
	if ((bfd_get_section_flags (objfile->obfd, lower_sect) & SEC_CODE) == 0)
	  warning (_("Lowest section in %s is %s at %s"),
		   objfile->name,
		   bfd_section_name (objfile->obfd, lower_sect),
		   paddr (bfd_section_vma (objfile->obfd, lower_sect)));
      if (lower_sect != NULL)
 	lower_offset = bfd_section_vma (objfile->obfd, lower_sect);
d830 1
a830 1
 	lower_offset = 0;
@


1.197
log
@	* exec.c: #include "arch-utils.h"
	 (print_section_info): Use gdbarch_from_bfd to get at the
	current architecture. Replace current_gdbarch. Fix indention.
	Replace deprecated_print_address_numeric by paddress.
	* Makefile.in (exec.o) Add dependency to arch-utils.h.

	* valprint.c (val_print_string): Replace
	deprecated_print_address_numeric.
	* tracepoint.c (trace_mention, scope_info): Likewise.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1, print_symbol)
	(print_symbol, print_partial_symbols, maintenance_info_psymtabs)
	(maintenance_check_symtabs): Likewise.
	* symfile.c (list_overlays_command): Likewise.
	* stack.c (frame_info, print_block_frame_labels): Likewise.
	* printcmd.c (print_address, print_address_demangle)
	(address_info): Likewise.
	* corefile.c (memory_error): Likewise.
	* infcmd.c (jump_command): Likewise.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints)
	(mention, delete_breakpoint): Likewise.
	* c-valprint.c (print_function_pointer_address, c_val_print): Likewise.
	* dwarf2read.c (dump_die): Likewise.
	* ada-valprint.c (ada_val_print_1): Likewise.
	* f-valprint.c (f_val_print): Likewise.
	* linux-fork.c (info_forks_command): Likewise.
	* m32r-com.c (m32r_load_section, m32r_load)
	(m32r_upload_command): Likewise.

	* ui-out.c (ui_out_field_core_addr): Remove unnecessary comment.
@
text
@d55 1
d1221 1
a1221 3
#if defined(SOLIB_RESTART)
    SOLIB_RESTART ();
#endif
@


1.196
log
@        * symfile.c (set_initial_language): Make non-static.
        * symfile.h (set_initial_language): Add declaration.
        * language.c: #include "symfile.h".
        (set_language): Call set_initial_language if the frame language
        could not be determined.
@
text
@d3518 1
a3518 1
	deprecated_print_address_numeric (lma, 1, gdb_stdout);
d3520 1
a3520 1
	deprecated_print_address_numeric (lma + size, 1, gdb_stdout);
d3522 1
a3522 1
	deprecated_print_address_numeric (vma, 1, gdb_stdout);
d3524 1
a3524 1
	deprecated_print_address_numeric (vma + size, 1, gdb_stdout);
@


1.195
log
@	Updated copyright notices for most files.
@
text
@a89 2
static void set_initial_language (void);

d1577 1
a1577 1
static void
@


1.194
log
@* symfile.c (init_filename_language_table): Recognise .sx as
an assembler file.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.193
log
@	* coffread.c (decode_type): Use builtin_type_int32 instead
	of FT_INTEGER fundamental type for array range index type.
	(decode_base_type): Use builtin types of current_gdbarch
	instead of fundamental types.

	* dwarf2read.c (struct dwarf2_cu): Remove ftypes member.
	(read_file_scope): Do not initialize ftypes member.
	(dwarf_base_type, dwarf2_fundamental_types): Remove functions.
	(read_array_type): Use builtin_type_int32 instead of FT_INTEGER
	fundamental type for array range index type.
	(read_tag_string_type): Likewise for string range index type.
	Also, do not overwrite FT_CHAR type with new string type.
	(read_base_type): If DW_AT_name is missing, create unnamed type
	with given properties instead of looking for a fundamental type.
	Create new types as TYPE_TARGET_TYPE for DW_ATE_address and
	DW_ATE_complex_float types.
	(read_subrange_type): Create new type to represent missing
	DW_AT_type instead of looking for a fundamental type.
	(die_type): Use builtin type to represent "void" instead of
	looking for a fundamental type.

	* stabsread.c (define_symbol): Use builtin types to represent
	'r' and 'i' floating-point and integer constants.

	* gdbtypes.c (lookup_fundamental_type): Remove.
	* gdbtypes.h (lookup_fundamental_type): Remove prototype.
	(FT_VOID, FT_BOOLEAN, FT_CHAR, FT_SIGNED_CHAR, FT_UNSIGNED_CHAR,
	FT_SHORT, FT_SIGNED_SHORT, FT_UNSIGNED_SHORT, FT_INTEGER,
	FT_SIGNED_INTEGER, FT_UNSIGNED_INTEGER, FT_LONG, FT_SIGNED_LONG,
	FT_UNSIGNED_LONG, FT_LONG_LONG, FT_SIGNED_LONG_LONG,
	FT_UNSIGNED_LONG_LONG, FT_FLOAT, FT_DBL_PREC_FLOAT, FT_EXT_PREC_FLOAT,
	FT_COMPLEX, FT_DBL_PREC_COMPLEX, FT_EXT_PREC_COMPLEX, FT_STRING,
	FT_FIXED_DECIMAL, FT_FLOAT_DECIMAL, FT_BYTE, FT_UNSIGNED_BYTE,
	FT_TEMPLATE_ARG, FT_DECFLOAT, FT_DBL_PREC_DECFLOAT,
	FT_EXT_PREC_DECFLOAT, FT_NUM_MEMBERS): Remove macros.
	* objfiles.c (struct objfile): Remove fundamental_types member.
	* symfile.c (reread_symbols): Do not clear fundamental_types.

	* language.h (struct language_defn): Remove la_fund_type member.
	(create_fundamental_type): Remove.
	* language.c (unk_lang_create_fundamental_type): Remove.
	(unknown_language_defn, auto_language_defn,
	local_language_defn): Adapt initializer.
	* ada-lang.c (ada_create_fundamental_type): Remove.
	(ada_language_defn): Adapt initializer.
	* c-lang.h (c_create_fundamental_type): Remove prototype.
	* c-lang.c (c_create_fundamental_type): Remove.
	(c_language_defn, cplus_language_defn, asm_language_defn,
	minimal_language_defn): Adapt initializer.
	* f-lang.c (f_create_fundamental_type): Remove.
	(f_language_defn): Adapt initializer.
	* jv-lang.c (java_create_fundamental_type): Remove.
	(java_language_defn): Adapt initializer.
	* m2-lang.c (m2_create_fundamental_type): Remove.
	(m2_language_defn): Adapt initializer.
	* objc-lang.c (objc_create_fundamental_type): Remove.
	(objc_language_defn): Adapt initializer.
	* p-lang.h (pascal_create_fundamental_type): Remove prototype.
	* p-lang.c (pascal_create_fundamental_type): Remove.
	(pascal_language_defn): Adapt initializer.
	* scm-lang.c (scm_language_defn): Adapt initializer.
@
text
@d2690 1
@


1.192
log
@* symfile.h (struct symfile_segment_data): Doc fixes.
* symfile.c (symfile_map_offsets_to_segments): Doc fixes.
Assert that we were passed some loaded segment addresses,
and that sections' segment numbers are valid.
Simplify offset calculation.
* remote.c (get_offsets): Clarify selection of relocate-by-segment
strategy, and set num_segments correctly.  Delete redundant
assignments to do_sections.
@
text
@a2407 1
	      objfile->fundamental_types = NULL;
@


1.191
log
@	* Makefile.in (symfile.o): Update dependencies.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Initialize the
	DEBUGFILE variable.  FIND_SEPARATE_DEBUG_FILE called only if !PSYMTABS.
	(struct build_id): New structure.
	(build_id_bfd_get, build_id_verify, build_id_to_debug_filename): New.
	(find_separate_debug_file): New variable BUILD_ID.
	Call BUILD_ID_BFD_GET with BUILD_ID_TO_DEBUG_FILENAME as the first try.
@
text
@d3990 16
d4015 4
d4024 1
a4024 4
  /* If more offsets are provided than we have segments, make sure the
     excess offsets are all the same as the last segment's offset.
     This allows "Text=X;Data=X" for files which have only a single
     segment.  */
a4031 1
      CORE_ADDR vma;
d4034 9
d4044 1
a4044 5
	offsets->offsets[i] = segment_bases[num_segment_bases - 1];
      else if (which > 0)
	offsets->offsets[i] = segment_bases[which - 1];
      else
	continue;
d4046 2
a4047 1
      offsets->offsets[i] -= data->segment_bases[which - 1];
@


1.191.2.1
log
@* symfile.h (struct symfile_segment_data): Doc fixes.
* symfile.c (symfile_map_offsets_to_segments): Doc fixes.
Assert that we were passed some loaded segment addresses,
and that sections' segment numbers are valid.
Simplify offset calculation.
* remote.c (get_offsets): Clarify selection of relocate-by-segment
strategy, and set num_segments correctly.  Delete redundant
assignments to do_sections.
@
text
@a3989 16

/* Given:
   - DATA, containing segment addresses from the object file ABFD, and
     the mapping from ABFD's sections onto the segments that own them,
     and
   - SEGMENT_BASES[0 .. NUM_SEGMENT_BASES - 1], holding the actual
     segment addresses reported by the target,
   store the appropriate offsets for each section in OFFSETS.

   If there are fewer entries in SEGMENT_BASES than there are segments
   in DATA, then apply SEGMENT_BASES' last entry to all the segments.

   If there are more, then verify that all the excess addresses are
   the same as the last legitimate one, and then ignore them.  This
   allows "TextSeg=X;DataSeg=X" qOffset replies for files which have
   only a single segment.  */
a3998 4
  /* It doesn't make sense to call this function unless you have some
     segment base addresses.  */
  gdb_assert (segment_bases > 0);

d4004 4
a4007 1
  /* Check any extra SEGMENT_BASES entries.  */
d4015 1
a4017 9
      gdb_assert (0 <= which && which <= data->num_segments);

      /* Don't bother computing offsets for sections that aren't
         loaded as part of any segment.  */
      if (! which)
        continue;

      /* Use the last SEGMENT_BASES entry as the address of any extra
         segments mentioned in DATA->segment_info.  */
d4019 5
a4023 1
        which = num_segment_bases;
d4025 1
a4025 2
      offsets->offsets[i] = (segment_bases[which - 1]
                             - data->segment_bases[which - 1]);
@


1.190
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d54 1
d1021 1
a1021 1
  char *debugfile;
d1085 5
a1089 1
  debugfile = find_separate_debug_file (objfile);
d1231 91
d1399 19
@


1.189
log
@2007-07-31  Michael Snyder  <msnyder@@access-company.com>

	* symfile.c (reread_separate_symbols): Free xmalloced memory.
@
text
@d13 1
a13 1
   the Free Software Foundation; either version 2 of the License, or
d22 1
a22 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.188
log
@2007-07-03  Ilko Iliev  <iliev@@ronetix.at>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* symfile.c (print_transfer_performance): Avoid integer overflow.
	Use larger units.
@
text
@d2442 2
@


1.187
log
@	* coffread.c (coff_sym_fns): Add default_symfile_segments.
	* dbxread.c (start_psymtab): Check HAVE_ELF.
	(aout_sym_fns): Likewise.
	* elfread.c (elf_symfile_segments): New.
	(elf_sym_fns): Add elf_symfile_segments.
	* mipsread.c (ecoff_sym_fns): Add default_symfile_segments.
	* remote.c (get_offsets): Use symfile_map_offsets_to_segments.
	Skip if there is no symfile_objfile.  Handle TextSeg and DataSeg.
	* somread.c (som_sym_fns): Use default_symfile_segments.
	* symfile.c (find_sym_fns): Take a BFD and return the sym_fns.
	(init_objfile_sect_indices): Call symfile_find_segment_sections.
	(default_symfile_segments): New function.
	(syms_from_objfile): Update call to find_sym_fns.
	(symfile_get_segment_data, free_symfile_segment_data): New.
	(symfile_map_offsets_to_segments): New.
	(symfile_find_segment_sections): New.
	* symfile.h (struct symfile_segment_data): New.
	(struct sym_fns): Add sym_segments.
	(default_symfile_segments, symfile_get_segment_data)
	(free_symfile_segment_data): New prototypes.
	(symfile_map_offsets_to_segments): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add default_symfile_segments.
	* Makefile.in (COMMON_OBS): Remove elfread.o.
	(elf_internal_h): New.
	(elfread.o): Update.
	* configure.ac: Add elfread.o to COMMON_OBS if bfd/elf.o was
	compiled.
	* config.in, configure: Regenerated.
	* NEWS: Mention qOffsets changes.

	* gdb.texinfo (General Query Packets): Document qOffsets changes.

	* Makefile.def: Add dependency from configure-gdb to all-bfd.
	* Makefile.in: Regenerated.
@
text
@d1950 1
a1950 1
  unsigned long time_count;
d1960 17
a1976 3
      ui_out_field_fmt (uiout, "transfer-rate", "%lu",
			1000 * (data_count * 8) / time_count);
      ui_out_text (uiout, " bits/sec");
@


1.186
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_SHORT_BIT): Replace by gdbarch_int_bit.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* gdbarch.sh (TARGET_INT_BIT): Replace by gdbarch_int_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type, ada_language_arch_info)
	(gdbtypes_post_init, build_gdbtypes): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* parse.c (build_parse): Likewise.
	* xcoffread.c (_initialize_xcoffread): Likewise.
	* stabsread.c (define_symbol, read_one_struct_field, read_enum_type)
	(read_range_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* f-lang.c (build_fortran_types, f_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type, _initialize_m2_language)
	(m2_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (coff_read_enum_type): Likewise.
	* mdebugread.c (parse_symbol, _initialize_mdebugread): Likewise.
	* dwarf2read.c (new_symbol): Likewise.
	* gdbarch.sh (TARGET_LONG_BIT): Replace by gdbarch_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* valarith.c (value_binop): Likewise.
	* symfile.c (read_target_long_array, simple_overlay_update_1): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* symfile.c (TARGET_LONG_BYTES): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (decode_base_type): Likewise.
	* gdbarch.sh (TARGET_LONG_LONG_BIT): Replace by gdbarch_long_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (gdbtypes_post_init, build_gdbtypes): Likewise.
	* stabsread.c (read_range_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d109 1
a109 1
static void find_sym_fns (struct objfile *);
d149 2
d435 13
a447 6
     accomodate that.  Except when explicitly adding symbol files at
     some address, section_offsets contains nothing but zeros, so it
     doesn't matter which slot in section_offsets the individual
     sect_index_* members index into.  So if they are all zero, it is
     safe to just point all the currently uninitialized indices to the
     first slot. */
d651 64
d761 1
a761 1
  find_sym_fns (objfile);
d1581 2
a1582 2
static void
find_sym_fns (struct objfile *objfile)
d1585 1
a1585 2
  enum bfd_flavour our_flavour = bfd_get_flavour (objfile->obfd);
  char *our_target = bfd_get_target (objfile->obfd);
d1590 1
a1590 1
    return;	/* No symbols.  */
d1593 2
a1594 7
    {
      if (our_flavour == sf->sym_flavour)
	{
	  objfile->sf = sf;
	  return;
	}
    }
d1597 1
a1597 1
	 bfd_get_target (objfile->obfd));
d3841 105
@


1.185
log
@	* gdbarch.sh (overlay_update): New gdbarch function.
	(struct obj_section): Add forward declaration.
	* gdbarch.c, gdbarch.h: Regenerate.

	* symfile.c (simple_overlay_update): Make global.
	(target_overlay_update): Remove variable.
	(overlay_is_mapped): Call gdbarch_overlay_update instead of
	target_overlay_update.
	(overlay_load_command): Likewise.
	* symfile.h (struct obj_section): Add forward declaration.
	(simple_overlay_update): Add prototype.

	* m32r-tdep.c (m32r_gdbarch_init): Install simple_overlay_update.
@
text
@d3533 2
a3534 1
#define TARGET_LONG_BYTES (TARGET_LONG_BIT / TARGET_CHAR_BIT)
@


1.184
log
@doc/ChangeLog:

	* observer.texi (GDB Observers): New observer "new_objfile".

ChangeLog:

	* observer.sh: Add "struct objfile" forward declaration.
	* target.h (deprecated_target_new_objfile_hook): Remove.
	* symfile.c (deprecated_target_new_objfile_hook): Remove.
	(clear_symtab_users): Call observer_notify_new_objfile.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	* rs6000-nat.c: Include "observer.h".
	(vmap_ldinfo): Call observer_notify_new_objfile.
	(xcoff_relocate_core): Likewise.
	* remote.c (remote_new_objfile_chain): Remove.
	(remote_new_objfile): Do not call remote_new_objfile_chain.
	(_initialize_remote): Use observer_attach_new_objfile.
	* tui/tui-hooks.c (tui_target_new_objfile_chain): Remove.
	(tui_new_objfile_hook): Do not call tui_target_new_objfile_chain.
	(_initialize_tui_hooks): Use observer_attach_new_objfile.
	* aix-thread.c: Include "observer.h".
	(target_new_objfile_chain): Remove.
	(new_objfile): Do not call target_new_objfile_chain.
	(_initialize_aix_thread): Use observer_attach_new_objfile.
	* hpux-thread.c: Include "observer.h"
	(target_new_objfile_chain): Remove.
	(hpux_thread_new_objfile): Make static.  Do not call
	target_new_objfile_chain.
	(_initialize_hpux_thread): Use observer_attach_new_objfile.
	* linux-thread-db.c: Include "observer.h".
	(target_new_objfile_chain): Remove.
	(thread_db_new_objfile): Do not call target_new_objfile_chain.
	(_initialize_thread_db): Use observer_attach_new_objfile.
	* sol-thread.c: Include "observer.h".
	(target_new_objfile_chain): Remove.
	(sol_thread_new_objfile): Make static.  Do not call
	target_new_objfile_chain.
	(_initialize_sol_thread): Use observer_attach_new_objfile.
	* Makefile.in (aix-thread.o, hpux-thread.o, linux-thread-db.o,
	rs6000-nat.o, sol-thread.o, tui-hooks.o): Add dependency on
	$(observer_h).
@
text
@a3044 4
/* Target vector for refreshing overlay mapped state */
static void simple_overlay_update (struct obj_section *);
void (*target_overlay_update) (struct obj_section *) = simple_overlay_update;

d3098 1
a3098 1
      /* Unles there is a target_overlay_update function,
d3100 1
a3100 1
      if (target_overlay_update)
d3108 1
a3108 1
	    (*target_overlay_update) (osect);
d3461 2
a3462 2
  if (target_overlay_update)
    (*target_overlay_update) (NULL);
d3486 1
a3486 1
   entry point is via a function pointer "target_overlay_update",
d3689 1
a3689 1
static void
@


1.183
log
@	* symfile.c (add_psymbol_with_dem_name_to_list): Remove.
	* symfile.h (add_psymbol_with_dem_name_to_list): Remove prototype.
@
text
@a73 1
void (*deprecated_target_new_objfile_hook) (struct objfile *);
d1069 1
a1069 2
  if (deprecated_target_new_objfile_hook)
    deprecated_target_new_objfile_hook (objfile);
d2644 1
a2644 2
  if (deprecated_target_new_objfile_hook)
    deprecated_target_new_objfile_hook (NULL);
@


1.182
log
@	* symfile.c (place_section): Check SEC_ALLOC.  Do not check VMA.
	(default_symfile_offsets): Check VMA here.  Update section VMAs.

	* gdb.cp/cp-relocate.cc, gdb.cp/cp-relocate.exp: New.
@
text
@a2954 69
/* Add a symbol with a long value to a psymtab. This differs from
 * add_psymbol_to_list above in taking both a mangled and a demangled
 * name. */

void
add_psymbol_with_dem_name_to_list (char *name, int namelength, char *dem_name,
				   int dem_namelength, domain_enum domain,
				   enum address_class class,
				   struct psymbol_allocation_list *list, long val,	/* Value as a long */
				   CORE_ADDR coreaddr,	/* Value as a CORE_ADDR */
				   enum language language,
				   struct objfile *objfile)
{
  struct partial_symbol *psym;
  char *buf = alloca (namelength + 1);
  /* psymbol is static so that there will be no uninitialized gaps in the
     structure which might contain random data, causing cache misses in
     bcache. */
  static struct partial_symbol psymbol;

  /* Create local copy of the partial symbol */

  memcpy (buf, name, namelength);
  buf[namelength] = '\0';
  DEPRECATED_SYMBOL_NAME (&psymbol) = deprecated_bcache (buf, namelength + 1,
							 objfile->psymbol_cache);

  buf = alloca (dem_namelength + 1);
  memcpy (buf, dem_name, dem_namelength);
  buf[dem_namelength] = '\0';

  switch (language)
    {
    case language_c:
    case language_cplus:
      SYMBOL_CPLUS_DEMANGLED_NAME (&psymbol) =
	deprecated_bcache (buf, dem_namelength + 1, objfile->psymbol_cache);
      break;
      /* FIXME What should be done for the default case? Ignoring for now. */
    }

  /* val and coreaddr are mutually exclusive, one of them *will* be zero */
  if (val != 0)
    {
      SYMBOL_VALUE (&psymbol) = val;
    }
  else
    {
      SYMBOL_VALUE_ADDRESS (&psymbol) = coreaddr;
    }
  SYMBOL_SECTION (&psymbol) = 0;
  SYMBOL_LANGUAGE (&psymbol) = language;
  PSYMBOL_DOMAIN (&psymbol) = domain;
  PSYMBOL_CLASS (&psymbol) = class;
  SYMBOL_INIT_LANGUAGE_SPECIFIC (&psymbol, language);

  /* Stash the partial symbol away in the cache */
  psym = deprecated_bcache (&psymbol, sizeof (struct partial_symbol),
			    objfile->psymbol_cache);

  /* Save pointer to partial symbol in psymtab, growing symtab if needed. */
  if (list->next >= list->list + list->size)
    {
      extend_psymbol_list (list, objfile);
    }
  *list->next++ = psym;
  OBJSTAT (objfile, n_psyms++);
}

@


1.181
log
@2007-02-13  Denis Pilat  <denis.pilat@@st.com>

	* varobj.h (enum varobj_update_error): New enum.
	* varobj.c (struct varobj_root): Add is_valid member.
	(varobj_get_type): Check for invalid varobj.
	(varobj_get_attributes): Likewise.
	(variable_editable):Likewise.
	(varobj_update): Likewise.  Use varobj_update_error.
	(new_root_variable): Set root varobj as valid by default.
	(varobj_invalidate): New function.
	* symfile.c (clear_symtab_users): Use varobj_invalidate.
	* mi/mi-cmd-var.c (varobj_update_one): Change return type to void.
	Use varobj_update_error.
@
text
@d480 2
a481 2
  /* We are only interested in loadable sections.  */
  if ((bfd_get_section_flags (abfd, sect) & SEC_LOAD) == 0)
d505 2
a506 7
	/* We can only conflict with loadable sections.  */
	if ((bfd_get_section_flags (abfd, cur_sec) & SEC_LOAD) == 0)
	  continue;

	/* We do not expect this to happen; just ignore sections in a
	   relocatable file with an assigned VMA.  */
	if (bfd_section_vma (abfd, cur_sec) != 0)
d579 56
a634 3
      arg.offsets = objfile->section_offsets;
      arg.lowest = 0;
      bfd_map_over_sections (objfile->obfd, place_section, &arg);
@


1.180
log
@	* symfile.c (allocate_symtab): Remove INIT_EXTRA_SYMTAB_INFO.
@
text
@d55 1
d2606 4
@


1.179
log
@	* configure.ac (DEBUGDIR_RELOCATABLE): Define for debugdir inside
	exec_prefix.
	(TARGET_SYSTEM_ROOT_RELOCATABLE): Allow for exec_prefix being
	'${prefix}'.
	* configure, config.in: Regenerate.
	* defs.h (debug_file_directory): Declare.
	* main.c (captured_main): Canonicalize gdb_sysroot.  Assume
	TARGET_SYSTEM_ROOT is defined.  Initialize debug_file_directory and
	relocate it if DEBUGDIR_RELOCATABLE.
	* symfile.c (debug_file_directory): Make non-static.
	(find_separate_debug_file): Look for debug info for SYSROOT/PATH
	in DEBUGDIR/PATH if DEBUGDIR is inside SYSROOT.
	(_initialize_symfile): Don't initialize debug_file_directory here.
@
text
@a2508 8
  /* FIXME: This should go away.  It is only defined for the Z8000,
     and the Z8000 definition of this macro doesn't have anything to
     do with the now-nonexistent EXTRA_SYMTAB_INFO macro, it's just
     here for convenience.  */
#ifdef INIT_EXTRA_SYMTAB_INFO
  INIT_EXTRA_SYMTAB_INFO (symtab);
#endif

@


1.178
log
@Copyright updates for 2007.
@
text
@d1159 1
a1159 1
static char *debug_file_directory = NULL;
d1181 1
d1249 24
a3884 1
  debug_file_directory = xstrdup (DEBUGDIR);
@


1.177
log
@	* Makefile.in (SFILES): Add target-memory.c.
	(COMMON_OBS): Add target-memory.o.
	* memattr.c (lookup_mem_region): Adjust handling for
	the top of memory.  Improve comments.
	* remote.c (packet_check_result): New function, split out
	from packet_ok.  Recognize "E." as an error prefix.
	(packet_ok): Use it.
	(remote_write_bytes_aux): New function, renamed from
	remote_write_bytes.  Take packet header, packet format,
	and length flag as arguments.
	(remote_write_bytes): Rewrite to use remote_write_bytes_aux.
	(remote_send_printf, restore_remote_timeout)
	(remote_flash_timeout, remote_flash_erase, remote_flash_write)
	(remote_flash_done): New.
	(remote_xfer_partial): Handle flash writes.
	(init_remote_ops, init_remote_async_ops): Set to_flash_erase
	and to_flash_done.
	* symfile.c (struct load_section_data): Include a pointer to
	the cumulative stats and a request queue.  Move most members
	to other types.
	(struct load_progress_data, struct load_progress_section_data): New
	types.
	(load_progress): Handle a NULL baton and zero bytes.  Update for
	type changes.
	(load_section_callback): Create memory write requests instead of
	writing to memory.  Don't print the progress message here.
	(clear_memory_write_data): New function.
	(generic_load): Use target_write_memory_blocks.
	* target-memory.c: New file.
	* target.c (update_current_target): Mention new uninherited methods.
	(memory_xfer_partial): Issue an error for flash writes.
	(target_flash_erase, target_flash_done): New functions.
	(target_write_with_progress): Call the progress callback at the
	start also.
	* target.h (enum target_object): Add TARGET_OBJECT_FLASH.
	(target_write_with_progress): Update comment.
	(struct target_ops): Add to_flash_erase and to_flash_done.
	(target_flash_erase, target_flash_done, struct memory_write_request)
	(memory_write_request_s, enum flash_preserve_mode)
	(target_write_memory_blocks): New, including a vector type
	for memory_write_request_s.
@
text
@d3 2
a4 2
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
@


1.176
log
@	* symfile.c (add_symbol_file_command): Fix off-by-one when
	extending sect_opts.
@
text
@d1540 7
d1550 5
d1556 1
a1556 1
  /* Per-section data for load_progress.  */
d1564 1
a1564 1
/* Target write callback routine for load_section_callback.  */
d1569 19
a1587 1
  struct load_section_data *args = untyped_arg;
d1609 1
a1609 1
  args->data_count += bytes;
d1612 1
a1612 1
  args->write_count += 1;
d1624 2
a1625 2
				   args->data_count,
				   args->total_size);
d1633 1
d1635 1
a1637 1
  struct cleanup *old_chain;
a1638 1
  LONGEST transferred;
d1646 16
a1661 2
  buffer = xmalloc (size);
  old_chain = make_cleanup (xfree, buffer);
d1663 2
a1664 10
  args->section_name = sect_name;
  args->section_sent = 0;
  args->section_size = size;
  args->lma = bfd_section_lma (abfd, asec) + args->load_offset;
  args->buffer = buffer;

  /* Is this really necessary?  I guess it gives the user something
     to look at during a long download.  */
  ui_out_message (uiout, 0, "Loading section %s, size 0x%s lma 0x%s\n",
		  sect_name, paddr_nz (size), paddr_nz (args->lma));
d1666 2
a1667 1
  bfd_get_section_contents (abfd, asec, buffer, 0, size);
d1669 7
a1675 7
  transferred = target_write_with_progress (&current_target,
					    TARGET_OBJECT_MEMORY,
					    NULL, buffer, args->lma,
					    size, load_progress, args);
  if (transferred < size)
    error (_("Memory access error while loading section %s."),
	   sect_name);
d1677 6
a1682 1
  do_cleanups (old_chain);
a1687 1
  asection *s;
d1693 2
d1698 5
a1702 4
  cbdata.load_offset = 0;	/* Offset to add to vma for each section. */
  cbdata.write_count = 0;	/* Number of writes needed. */
  cbdata.data_count = 0;	/* Number of bytes written to target memory. */
  cbdata.total_size = 0;	/* Total size of all bfd sectors. */
d1749 3
a1751 1
			 (void *) &cbdata.total_size);
d1755 3
a1757 1
  bfd_map_over_sections (loadfile_bfd, load_section_callback, &cbdata);
d1765 1
a1765 1
  ui_out_field_fmt (uiout, "load-size", "%lu", cbdata.data_count);
d1777 3
a1779 2
  print_transfer_performance (gdb_stdout, cbdata.data_count,
			      cbdata.write_count, &start_time, &end_time);
@


1.175
log
@	PR remote/1966
	* dcache.c (dcache_write_line): Use target_write.
	(dcache_read_line): Use target_read.
	* mi/mi-main.c (mi_cmd_data_read_memory): Use target_read.
	* symfile.c (struct load_section_data): Add new per-section
	members.
	(load_progress): New function.
	(load_section_callback): Pass load_progress to the new
	target_write_with_progress.
	* target.c (current_xfer_partial, memory_xfer_partial): New.
	(target_xfer_partial): New prototype.
	(target_xfer_memory, target_xfer_partial_p, xfer_using_stratum)
	(do_xfer_memory, target_xfer_memory_partial)
	(target_read_memory_partial, target_write_memory_partial): Delete.
	(trust_readonly): Move higher in the file.
	(update_current_target): Use current_xer_partial.
	(target_xfer_partial): Use memory_xfer_partial.  Handle
	TARGET_OBJECT_RAW_MEMORY specially.
	(target_read_memory): Use target_read.
	(target_write_memory): Use target_write.
	(default_xfer_partial): Call to_xfer_partial directly.
	(target_write_with_progress): New function, based on target_write.
	(target_write): Call it.
	* target.h (enum target_object): Add TARGET_OBJECT_RAW_MEMORY.
	(target_write_with_progress): New prototype.
	(do_xfer_memory, target_read_memory_partial)
	(target_write_memory_partial): Delete prototypes.
@
text
@d1856 1
a1856 1
	    if (++section_index > num_sect_opts)
d1892 1
a1892 1
		      if (++section_index > num_sect_opts)
@


1.174
log
@	* Makefile.in (objfiles.o, symfile.o): Update.
	* objfiles.c: Include "expression.h" and "parser-defs.h".
	(free_objfile): Clear global blocks.
	* symfile.c: Include "parser-defs.h".
	(clear_symtab_users): Clear global blocks.
@
text
@d1543 7
d1552 46
d1604 5
d1610 2
a1611 20
  if (bfd_get_section_flags (abfd, asec) & SEC_LOAD)
    {
      bfd_size_type size = bfd_get_section_size (asec);
      if (size > 0)
	{
	  gdb_byte *buffer;
	  struct cleanup *old_chain;
	  CORE_ADDR lma = bfd_section_lma (abfd, asec) + args->load_offset;
	  bfd_size_type block_size;
	  int err;
	  const char *sect_name = bfd_get_section_name (abfd, asec);
	  bfd_size_type sent;

	  buffer = xmalloc (size);
	  old_chain = make_cleanup (xfree, buffer);

	  /* Is this really necessary?  I guess it gives the user something
	     to look at during a long download.  */
	  ui_out_message (uiout, 0, "Loading section %s, size 0x%s lma 0x%s\n",
			  sect_name, paddr_nz (size), paddr_nz (lma));
d1613 2
a1614 1
	  bfd_get_section_contents (abfd, asec, buffer, 0, size);
d1616 2
a1617 5
	  sent = 0;
	  do
	    {
	      int len;
	      bfd_size_type this_transfer = size - sent;
d1619 20
a1638 45
	      len = target_write_memory_partial (lma, buffer,
						 this_transfer, &err);
	      if (err)
		break;
	      if (validate_download)
		{
		  /* Broken memories and broken monitors manifest
		     themselves here when bring new computers to
		     life.  This doubles already slow downloads.  */
		  /* NOTE: cagney/1999-10-18: A more efficient
		     implementation might add a verify_memory()
		     method to the target vector and then use
		     that.  remote.c could implement that method
		     using the ``qCRC'' packet.  */
		  gdb_byte *check = xmalloc (len);
		  struct cleanup *verify_cleanups =
		    make_cleanup (xfree, check);

		  if (target_read_memory (lma, check, len) != 0)
		    error (_("Download verify read failed at 0x%s"),
			   paddr (lma));
		  if (memcmp (buffer, check, len) != 0)
		    error (_("Download verify compare failed at 0x%s"),
			   paddr (lma));
		  do_cleanups (verify_cleanups);
		}
	      args->data_count += len;
	      lma += len;
	      buffer += len;
	      args->write_count += 1;
	      sent += len;
	      if (quit_flag
		  || (deprecated_ui_load_progress_hook != NULL
		      && deprecated_ui_load_progress_hook (sect_name, sent)))
		error (_("Canceled the download"));

	      if (deprecated_show_load_progress != NULL)
		deprecated_show_load_progress (sect_name, sent, size,
					       args->data_count,
					       args->total_size);
	    }
	  while (sent < size);

	  if (err != 0)
	    error (_("Memory access error while loading section %s."), sect_name);
d1640 1
a1640 3
	  do_cleanups (old_chain);
	}
    }
@


1.173
log
@gdb/
	* symfile.c (download_write_size): Remove.
	(show_download_write_size): Remove.
	(load_section_callback): Don't use download_write_size.
	(_initialize_symfile): Don't register download_write_size.
	* NEWS: Mention 'download-write-size' removal.
gdb/doc/
	* gdb.texinfo (Target Commands): Remove
	'set download-write-size' and 'show download-write-size'.
gdb/testsuite/
	* config/monitor.exp (gdb_load): Remove support for obsolete
	download-write-size.
	* gdb.base/remote.exp: Likewise.  Update all callers of
	gdb_timed_load.
@
text
@d54 1
d2522 6
@


1.172
log
@	* symfile.c (load_command): Check for a changed executable before
	"load".
@
text
@a1523 9
static int download_write_size = 512;
static void
show_download_write_size (struct ui_file *file, int from_tty,
			  struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("\
The write size used when downloading a program is %s.\n"),
		    value);
}
a1563 5
	  if (download_write_size > 0 && size > download_write_size)
	    block_size = download_write_size;
	  else
	    block_size = size;

a1579 2
	      if (this_transfer >= block_size)
		this_transfer = block_size;
a3792 13
  add_setshow_integer_cmd ("download-write-size", class_obscure,
			   &download_write_size, _("\
Set the write size used when downloading a program."), _("\
Show the write size used when downloading a program."), _("\
Only used when downloading a program onto a remote\n\
target. Specify zero, or a negative value, to disable\n\
blocked writes. The actual size of each transfer is also\n\
limited by the size of the target packet and the memory\n\
cache."),
			   NULL,
			   show_download_write_size,
			   &setlist, &showlist);

@


1.171
log
@	* gdb/defs.h: unconditionally include <fcntl.h>, and
	ensure that O_BINARY is defined.
	* gdb/solib.c(solib_open): ensure solib files are opened in
	binary mode.
	* gdb/corelow.c: Remove O_BINARY macro definition.
	* gdb/exec.c: Remove O_BINARY macro definition
	* gdb/remote-rdp.c: Remove O_BINARY macro definition
	* gdb/source.c: Remove O_BINARY macro definition
	* gdb/symfile.c: Remove O_BINARY macro definition
@
text
@d1503 5
@


1.171.12.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a53 1
#include "parser-defs.h"
a1502 5
  /* The user might be reloading because the binary has changed.  Take
     this opportunity to check.  */
  reopen_exec_file ();
  reread_symbols ();

d1519 9
a1545 7

  /* Per-section data for load_progress.  */
  const char *section_name;
  ULONGEST section_sent;
  ULONGEST section_size;
  CORE_ADDR lma;
  gdb_byte *buffer;
d1548 1
a1548 1
/* Target write callback routine for load_section_callback.  */
d1551 1
a1551 1
load_progress (ULONGEST bytes, void *untyped_arg)
d1553 1
a1553 1
  struct load_section_data *args = untyped_arg;
d1555 1
a1555 1
  if (validate_download)
d1557 15
a1571 36
      /* Broken memories and broken monitors manifest themselves here
	 when bring new computers to life.  This doubles already slow
	 downloads.  */
      /* NOTE: cagney/1999-10-18: A more efficient implementation
	 might add a verify_memory() method to the target vector and
	 then use that.  remote.c could implement that method using
	 the ``qCRC'' packet.  */
      gdb_byte *check = xmalloc (bytes);
      struct cleanup *verify_cleanups = make_cleanup (xfree, check);

      if (target_read_memory (args->lma, check, bytes) != 0)
	error (_("Download verify read failed at 0x%s"),
	       paddr (args->lma));
      if (memcmp (args->buffer, check, bytes) != 0)
	error (_("Download verify compare failed at 0x%s"),
	       paddr (args->lma));
      do_cleanups (verify_cleanups);
    }
  args->data_count += bytes;
  args->lma += bytes;
  args->buffer += bytes;
  args->write_count += 1;
  args->section_sent += bytes;
  if (quit_flag
      || (deprecated_ui_load_progress_hook != NULL
	  && deprecated_ui_load_progress_hook (args->section_name,
					       args->section_sent)))
    error (_("Canceled the download"));

  if (deprecated_show_load_progress != NULL)
    deprecated_show_load_progress (args->section_name,
				   args->section_sent,
				   args->section_size,
				   args->data_count,
				   args->total_size);
}
d1573 2
a1574 1
/* Callback service function for generic_load (bfd_map_over_sections).  */
d1576 4
a1579 9
static void
load_section_callback (bfd *abfd, asection *asec, void *data)
{
  struct load_section_data *args = data;
  bfd_size_type size = bfd_get_section_size (asec);
  gdb_byte *buffer;
  struct cleanup *old_chain;
  const char *sect_name = bfd_get_section_name (abfd, asec);
  LONGEST transferred;
d1581 1
a1581 2
  if ((bfd_get_section_flags (abfd, asec) & SEC_LOAD) == 0)
    return;
d1583 5
a1587 2
  if (size == 0)
    return;
d1589 44
a1632 2
  buffer = xmalloc (size);
  old_chain = make_cleanup (xfree, buffer);
d1634 2
a1635 20
  args->section_name = sect_name;
  args->section_sent = 0;
  args->section_size = size;
  args->lma = bfd_section_lma (abfd, asec) + args->load_offset;
  args->buffer = buffer;

  /* Is this really necessary?  I guess it gives the user something
     to look at during a long download.  */
  ui_out_message (uiout, 0, "Loading section %s, size 0x%s lma 0x%s\n",
		  sect_name, paddr_nz (size), paddr_nz (args->lma));

  bfd_get_section_contents (abfd, asec, buffer, 0, size);

  transferred = target_write_with_progress (&current_target,
					    TARGET_OBJECT_MEMORY,
					    NULL, buffer, args->lma,
					    size, load_progress, args);
  if (transferred < size)
    error (_("Memory access error while loading section %s."),
	   sect_name);
d1637 3
a1639 1
  do_cleanups (old_chain);
d1855 1
a1855 1
	    if (++section_index >= num_sect_opts)
d1891 1
a1891 1
		      if (++section_index >= num_sect_opts)
a2531 6

  /* Clear globals which might have pointed into a removed objfile.
     FIXME: It's not clear which of these are supposed to persist
     between expressions and which ought to be reset each time.  */
  expression_context_block = NULL;
  innermost_block = NULL;
d3804 13
@


1.171.2.1
log
@Merge XML and VFP support to this branch.
@
text
@d1519 1
a1519 4
/* FIXME drow/2006-03-30: This used to be 512.  The remote target will
   throttle it if it's too large; is there any use in having a small
   value here?  */
static int download_write_size = 16384;
@


1.171.2.1.2.1
log
@Actually include patch, not just changelog.
@
text
@a3725 100
/* FIXME: This should probably go through the symfile ops vector.  */

#include "elf/internal.h"
#include "elf/common.h"

int
symfile_map_offsets_to_segments (struct objfile *objfile,
				 struct section_offsets *offsets,
				 CORE_ADDR text_addr, CORE_ADDR data_addr)
{
  Elf_Internal_Phdr *phdrs, *segments[2];
  int num_phdrs, i, num_segments;
  long phdrs_size;
  bfd *abfd = objfile->obfd;
  asection *sect;
  CORE_ADDR text_offset, data_offset;

  phdrs_size = bfd_get_elf_phdr_upper_bound (objfile->obfd);
  if (phdrs_size == -1)
    return 0;

  phdrs = alloca (phdrs_size);
  num_phdrs = bfd_get_elf_phdrs (objfile->obfd, phdrs);
  if (num_phdrs == -1)
    return 0;

  num_segments = 0;
  for (i = 0; i < num_phdrs; i++)
    if (phdrs[i].p_type == PT_LOAD)
      {
	if (num_segments == 2)
	  return 0;
	segments[num_segments++] = &phdrs[i];
      }

  if (num_segments == 0)
    return 0;

  if (num_segments == 1)
    {
      if ((segments[0]->p_flags & PF_W) && !(segments[0]->p_flags & PF_X))
	{
	  segments[1] = segments[0];
	  segments[0] = NULL;
	}
      else
	segments[1] = NULL;
    }
  else
    {
      if ((segments[0]->p_flags & PF_X) && !(segments[1]->p_flags & PF_X))
	/* OK */;
      else if ((segments[1]->p_flags & PF_X) && !(segments[0]->p_flags & PF_X))
	{
	  Elf_Internal_Phdr *tmp = segments[0];
	  segments[0] = segments[1];
	  segments[1] = tmp;
	}
      else if ((segments[1]->p_flags & PF_W) && !(segments[0]->p_flags & PF_W))
	/* OK */;
      else if ((segments[0]->p_flags & PF_W) && !(segments[1]->p_flags & PF_W))
	{
	  Elf_Internal_Phdr *tmp = segments[0];
	  segments[0] = segments[1];
	  segments[1] = tmp;
	}
      else
	return 0;
    }

  text_offset = text_addr - segments[0]->p_vaddr;
  data_offset = data_addr - segments[1]->p_vaddr;

  for (i = 0, sect = abfd->sections; sect != NULL; i++, sect = sect->next)
    {
      CORE_ADDR vma;

      if ((bfd_get_section_flags (abfd, sect) & SEC_LOAD) == 0)
	continue;

      vma = bfd_get_section_vma (abfd, sect);

      if (segments[0]
	  && vma >= segments[0]->p_vaddr
	  && vma < segments[0]->p_vaddr + segments[0]->p_memsz)
	offsets->offsets[i] = text_offset;

      else if (segments[1]
	       && vma >= segments[1]->p_vaddr
	       && vma < segments[1]->p_vaddr + segments[1]->p_memsz)
	offsets->offsets[i] = data_offset;

      else
	warning (_("Loadable segment \"%s\" outside of ELF segments"),
		 bfd_section_name (abfd, sect));
    }

  return 1;
}

@


1.171.2.1.2.2
log
@No, really, check in the RIGHT patch!
[Revert half of changes from previous commit.]
@
text
@d3726 100
@


1.171.2.1.2.3
log
@Add experimental support for SymbianOS-related protocol features.
@
text
@a147 2
static void symfile_find_segment_sections (struct objfile *objfile);

d432 6
a437 13
     accomodate that.  First, check for a file with the standard
     one or two segments.  */

  symfile_find_segment_sections (objfile);

  /* Except when explicitly adding symbol files at some address,
     section_offsets contains nothing but zeros, so it doesn't matter
     which slot in section_offsets the individual sect_index_* members
     index into.  So if they are all zero, it is safe to just point
     all the currently uninitialized indices to the first slot.  But
     beware: if this is the main executable, it may be relocated
     later, e.g. by the remote qOffsets packet, and then this will
     be wrong!  That's why we try segments first.  */
a3725 220
/* FIXME: This should probably go through the symfile ops vector.  */

#include "elf/internal.h"
#include "elf/common.h"

static int
symfile_find_segments (bfd *abfd, Elf_Internal_Phdr *text_segment,
		       Elf_Internal_Phdr *data_segment)
{
  Elf_Internal_Phdr *phdrs, *segments[2];
  int num_phdrs, i, num_segments;
  long phdrs_size;
  asection *sect;
  CORE_ADDR text_offset, data_offset;

  phdrs_size = bfd_get_elf_phdr_upper_bound (abfd);
  if (phdrs_size == -1)
    return 0;

  phdrs = alloca (phdrs_size);
  num_phdrs = bfd_get_elf_phdrs (abfd, phdrs);
  if (num_phdrs == -1)
    return 0;

  num_segments = 0;
  for (i = 0; i < num_phdrs; i++)
    if (phdrs[i].p_type == PT_LOAD)
      {
	if (num_segments == 2)
	  return 0;
	segments[num_segments++] = &phdrs[i];
      }

  if (num_segments == 0)
    return 0;

  if (num_segments == 1)
    {
      if ((segments[0]->p_flags & PF_W) && !(segments[0]->p_flags & PF_X))
	{
	  memset (text_segment, 0, sizeof (*text_segment));
	  *data_segment = *segments[0];
	}
      else
	{
	  *text_segment = *segments[0];
	  memset (data_segment, 0, sizeof (*data_segment));
	}
    }
  else
    {
      if ((segments[0]->p_flags & PF_X) && !(segments[1]->p_flags & PF_X))
	{
	  *text_segment = *segments[0];
	  *data_segment = *segments[1];
	}
      else if ((segments[1]->p_flags & PF_X) && !(segments[0]->p_flags & PF_X))
	{
	  *text_segment = *segments[1];
	  *data_segment = *segments[0];
	}
      else if ((segments[1]->p_flags & PF_W) && !(segments[0]->p_flags & PF_W))
	{
	  *text_segment = *segments[0];
	  *data_segment = *segments[1];
	}
      else if ((segments[0]->p_flags & PF_W) && !(segments[1]->p_flags & PF_W))
	{
	  *text_segment = *segments[1];
	  *data_segment = *segments[0];
	}
      else
	return 0;
    }

  return 1;
}

int
symfile_map_offsets_to_segments (struct objfile *objfile,
				 struct section_offsets *offsets,
				 CORE_ADDR text_addr, CORE_ADDR data_addr)
{
  Elf_Internal_Phdr text_segment, data_segment;
  bfd *abfd = objfile->obfd;
  int i;
  asection *sect;
  CORE_ADDR text_offset, data_offset;

  if (symfile_find_segments (abfd, &text_segment, &data_segment) == 0)
    return 0;

  text_offset = text_addr - text_segment.p_vaddr;
  data_offset = data_addr - data_segment.p_vaddr;

  for (i = 0, sect = abfd->sections; sect != NULL; i++, sect = sect->next)
    {
      CORE_ADDR vma;

      if ((bfd_get_section_flags (abfd, sect) & SEC_LOAD) == 0)
	continue;

      vma = bfd_get_section_vma (abfd, sect);

      if (text_segment.p_memsz
	  && vma >= text_segment.p_vaddr
	  && vma < text_segment.p_vaddr + text_segment.p_memsz)
	offsets->offsets[i] = text_offset;

      else if (data_segment.p_memsz
	       && vma >= data_segment.p_vaddr
	       && vma < data_segment.p_vaddr + data_segment.p_memsz)
	offsets->offsets[i] = data_offset;

      else
	warning (_("Loadable segment \"%s\" outside of ELF segments"),
		 bfd_section_name (abfd, sect));
    }

  return 1;
}

CORE_ADDR
symfile_section_offset_from_segment (bfd *abfd, asection *sect,
				     CORE_ADDR text_addr, CORE_ADDR data_addr)
{
  Elf_Internal_Phdr text_segment, data_segment;
  CORE_ADDR text_offset, data_offset, vma;

  if (symfile_find_segments (abfd, &text_segment, &data_segment) == 0)
    return 0;

  text_offset = text_addr - text_segment.p_vaddr;
  data_offset = data_addr - data_segment.p_vaddr;

  if ((bfd_get_section_flags (abfd, sect) & SEC_LOAD) == 0)
    return 0;

  vma = bfd_get_section_vma (abfd, sect);

  if (text_segment.p_memsz
      && vma >= text_segment.p_vaddr
      && vma < text_segment.p_vaddr + text_segment.p_memsz)
    return text_offset;

  else if (data_segment.p_memsz
	   && vma >= data_segment.p_vaddr
	   && vma < data_segment.p_vaddr + data_segment.p_memsz)
    return data_offset;

  else
    {
      warning (_("Loadable segment \"%s\" outside of ELF segments"),
	       bfd_section_name (abfd, sect));
      return 0;
    }
}

static void
symfile_find_segment_sections (struct objfile *objfile)
{
  Elf_Internal_Phdr text_segment, data_segment;
  bfd *abfd = objfile->obfd;
  int i;
  asection *sect;

  if (symfile_find_segments (abfd, &text_segment, &data_segment) == 0)
    return;

  for (i = 0, sect = abfd->sections; sect != NULL; i++, sect = sect->next)
    {
      CORE_ADDR vma;

      if ((bfd_get_section_flags (abfd, sect) & SEC_LOAD) == 0)
	continue;

      vma = bfd_get_section_vma (abfd, sect);

      if (text_segment.p_memsz
	  && vma >= text_segment.p_vaddr
	  && vma < text_segment.p_vaddr + text_segment.p_memsz)
	{
	  if (objfile->sect_index_text == -1)
	    objfile->sect_index_text = sect->index;

	  if (objfile->sect_index_rodata == -1)
	    objfile->sect_index_rodata = sect->index;
	}

      else if (data_segment.p_memsz
	       && vma >= data_segment.p_vaddr
	       && vma < data_segment.p_vaddr + data_segment.p_memsz)
	{
	  if (objfile->sect_index_data == -1)
	    objfile->sect_index_data = sect->index;

	  if (objfile->sect_index_bss == -1)
	    objfile->sect_index_bss = sect->index;
	}
    }
}

void
symfile_find_segment_lengths (bfd *abfd, CORE_ADDR *text_len,
			      CORE_ADDR *data_len)
{
  Elf_Internal_Phdr text_segment, data_segment;

  if (symfile_find_segments (abfd, &text_segment, &data_segment) == 0)
    {
      *text_len = 0;
      *data_len = 0;
    }
  else
    {
      *text_len = text_segment.p_memsz;
      *data_len = data_segment.p_memsz;
    }
}

@


1.171.2.1.2.4
log
@        * symfile.c (symfile_map_offsets_to_segments): Don't warn
        for empty sections.
        (symfile_section_offset_from_segment): Likewise.
@
text
@d3849 1
a3849 1
      else if (bfd_get_section_size (sect) > 0)
d3885 1
a3885 1
  else if (bfd_get_section_size (sect) > 0)
@


1.171.2.1.2.5
log
@        gdb/
        * symfile.c (symfile_section_offset_from_segment): Correct
        last change.

        * solib.c (solib_open): Always set errno.
@
text
@d3885 1
a3885 1
  else
d3887 2
a3888 3
      if (bfd_get_section_size (sect) > 0)
	warning (_("Loadable segment \"%s\" outside of ELF segments"),
		 bfd_section_name (abfd, sect));
@


1.171.4.1
log
@Local changes to take full advantage of qPacketInfo
@
text
@d1519 1
a1519 4
/* FIXME drow/2006-03-30: This used to be 512.  The remote target will
   throttle it if it's too large; is there any use in having a small
   value here?  */
static int download_write_size = 16384;
@


1.170
log
@2006-02-21  Andrew Stubbs  <andrew.stubbs@@st.com>

	* symfile.c (add_symbol_file_command): Use buildargv(), instead of
	hand decoding the command line, to allow use of quotes and spaces.
	(_initialize_symfile): Reorganize the help message for add-symbol-file
	such that 'help files' shows a better message.

testsuite/
	* gdb.base/help.exp (help add-symbol-file): Update.
@
text
@a62 3
#ifndef O_BINARY
#define O_BINARY 0
#endif
@


1.169
log
@2006-02-21  Andrew Stubbs  <andrew.stubbs@@st.com>

	* symfile.c (generic_load): Use buildargv() and tilde_expand()
	to parse file names with quoting, spaces and tildes properly.
	(load_command): Quote all special characters before calling
	target_load() such that buildargv() doesn't break file names.
	(_initialize_symfile): Mention the load offset in the help for
	the load command.
	* remote-sim.c: Include readline.h.
	(gdbsim_load): Use buildargv and tilde_expand() to parse file
	names with quoting, spaces and tildes properly.
	* target.h (target_load): Comment the parameters better.
	* Makefile.in (remote_sim.o): Add readline.h dependency.

testsuite/
	* gdb.base/help.exp (help load): Update expected results.
@
text
@d1814 1
d1836 2
a1837 2
  /* Make a copy of the string that we can safely write into. */
  args = xstrdup (args);
d1839 4
a1842 1
  while (*args != '\000')
d1844 1
a1844 17
      /* Any leading spaces? */
      while (isspace (*args))
	args++;

      /* Point arg to the beginning of the argument. */
      arg = args;

      /* Move args pointer over the argument. */
      while ((*args != '\000') && !isspace (*args))
	args++;

      /* If there are more arguments, terminate arg and
         proceed past it. */
      if (*args != '\000')
	*args++ = '\000';

      /* Now process the argument. */
a1906 1
      argcnt++;
d3738 1
a3739 1
Load the symbols from FILE, assuming FILE has been dynamically loaded.\n\
@


1.168
log
@	* symfile.c (place_section): Correct retry logic.
@
text
@d1470 36
a1505 1
    arg = get_exec_file (1);
d1652 1
a1652 2
  struct cleanup *old_cleanups;
  char *offptr;
d1655 1
d1662 11
a1672 7
  /* Parse the input argument - the user can specify a load offset as
     a second argument. */
  filename = xmalloc (strlen (args) + 1);
  old_cleanups = make_cleanup (xfree, filename);
  strcpy (filename, args);
  offptr = strchr (filename, ' ');
  if (offptr != NULL)
d1676 9
a1684 4
      cbdata.load_offset = strtoul (offptr, &endptr, 0);
      if (offptr == endptr)
	error (_("Invalid download offset:%s."), offptr);
      *offptr = '\0';
a1685 2
  else
    cbdata.load_offset = 0;
d3769 2
a3770 1
for access from GDB."), &cmdlist);
@


1.167
log
@        * symfile.c (add_symbol_file_command): Abort if the user forgot
        to provide the address when the file has been loaded.
@
text
@d479 1
d490 2
a493 1
    ULONGEST align = 1 << bfd_get_section_alignment (abfd, sect);
a494 1
    start_addr = (arg->lowest + align - 1) & -align;
d528 1
a528 1
	    continue;
@


1.166
log
@gdb/
	* Makefile.in (gdbtypes_h, gdbtypes.o, utils.o): Update.
	* defs.h (hashtab_obstack_allocate, dummy_obstack_deallocate): Add
	prototypes.
	* dwarf2read.c (read_subroutine_type): Use TYPE_ZALLOC.
	(hashtab_obstack_allocate, dummy_obstack_deallocate): Moved to...
	* utils.c (hashtab_obstack_allocate, dummy_obstack_deallocate):
	...here.
	* gdbtypes.c: Include "hashtab.h".
	(build_gdbtypes): Remove extra prototype.
	(struct type_pair, type_pair_hash, type_pair_eq)
	(create_copied_types_hash, copy_type_recursive): New.
	* gdbtypes.h: Include "hashtab.h".
	(TYPE_ZALLOC): New.
	(create_copied_types_hash, copy_type_recursive): New prototypes.
	* objfiles.c (free_objfile): Call preserve_values.
	* symfile.c (reread_symbols): Likewise.
	(clear_symtab_users): Remove calls to clear_value_history and
	clear_internalvars.
	* value.c (clear_value_history, clear_internalvars): Removed.
	(preserve_one_value, preserve_values): New functions.
	* value.h (clear_value_history, clear_internalvars): Removed.
	(preserve_values): New prototype.

	* tracepoint.c (_initialize_tracepoint): Do not initialize convenience
	variables here.
gdb/doc/
	* gdb.texinfo (Files): Remove obsolete bits from the description
	of "symbol-file".
@
text
@d1879 7
@


1.165
log
@	* printcmd.c (output_command): Always initialize fmt.size.
	(printf_command): Use gdb_byte.
	* symfile.c (separate_debug_file_exists): Use gdb_byte.
	(load_section_callback, read_target_long_array): Likewise.
	(simple_read_overlay_table, simple_read_overlay_region_table)
	(simple_overlay_update_1): Correct calls to read_target_long_array.
	* valprint.c (partial_memory_read): Change MYADDR to a gdb_byte *.
	Also change local pointers.
	(val_print_string): Use gdb_byte.
@
text
@d2016 4
a2491 1
  clear_value_history ();
a2492 1
  clear_internalvars ();
@


1.164
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d4 2
a5 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d1145 1
a1145 1
  char buffer[8*1024];
d1527 1
a1527 1
	  char *buffer;
d1572 1
a1572 1
		  char *check = xmalloc (len);
d3479 1
a3479 1
  char *buf = alloca (len * TARGET_LONG_BYTES);
d3519 1
a3519 1
                          (int *) cache_ovly_table,
d3547 1
a3547 1
				  (int *) cache_ovly_region_table,
d3581 1
a3581 1
				(int *) cache_ovly_table[i], 4);
@


1.163
log
@2005-12-02  Andrew Stubbs  <andrew.stubbs@@st.com>

	* symfile.c (symbol_file_clear): Test symfile_objfile is not NULL
	before dereferencing it.
	Gettextize the query.
@
text
@d3 1
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.162
log
@* symfile.c (symbol_file_command, set_initial_language)
(symfile_bfd_open, get_section_index, add_symtab_fns)
(find_sym_fns): Reformat code and comments.  Tweak comments.
@
text
@d1088 4
a1091 2
      && !query ("Discard symbol table from `%s'? ",
		 symfile_objfile->name))
@


1.161
log
@	Suggested by Shaun Jackman <sjackman@@gmail.com>:
	* defs.h (print_transfer_performance): Update prototype.
	* m32r-rom.c (m32r_load, m32r_upload_command): Use gettimeofday
	for print_transfer_performance.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* symfile.c (generic_load): Likewise.
	(report_transfer_performance): Create a dummy struct timeval.
	(print_transfer_performance): Use a more accurate measure
	of performance.
@
text
@d1254 10
a1263 6
   the command is rather bizarre--(1) buildargv implements various
   quoting conventions which are undocumented and have little or
   nothing in common with the way things are quoted (or not quoted)
   elsewhere in GDB, (2) options are used, which are not generally
   used in GDB (perhaps "set mapped on", "set readnow on" would be
   better), (3) the order of options matters, which is contrary to GNU
a1268 5
  char **argv;
  char *name = NULL;
  struct cleanup *cleanups;
  int flags = OBJF_USERLOADED;

d1277 8
a1284 4
      if ((argv = buildargv (args)) == NULL)
	{
	  nomem (0);
	}
d1294 1
d1296 1
a1297 2
	      symbol_file_add_main_1 (name, from_tty, flags);
	    }
d1302 2
a1303 3
	{
	  error (_("no symbol file name was specified"));
	}
d1310 8
a1317 7
   A better solution would be to record the language in the psymtab when reading
   partial symbols, and then use it (if known) to set the language.  This would
   be a win for formats that encode the language in an easily discoverable place,
   such as DWARF.  For stabs, we can jump through hoops looking for specially
   named symbols or try to intuit the language from the specific type of stabs
   we find, but we can't do that until later when we read in full symbols.
   FIXME.  */
d1329 2
a1330 3
	{
	  lang = deduce_language_from_filename (pst->filename);
	}
d1336 1
d1338 1
a1338 1
      expected_language = current_language;	/* Don't warn the user */
d1342 4
a1345 4
/* Open file specified by NAME and hand it off to BFD for preliminary
   analysis.  Result is a newly initialized bfd *, which includes a newly
   malloc'd` copy of NAME (tilde-expanded and made absolute).
   In case of trouble, error() is called.  */
d1354 1
a1354 3


  name = tilde_expand (name);	/* Returns 1st new malloc'd copy */
d1357 2
a1358 2
  desc = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, name, O_RDONLY | O_BINARY,
		0, &absolute_name);
d1373 5
a1377 3
  xfree (name);			/* Free 1st new malloc'd copy */
  name = absolute_name;		/* Keep 2nd malloc'd copy in bfd */
  /* It'll be freed in free_objfile(). */
d1391 4
a1394 4
      /* FIXME: should be checking for errors from bfd_close (for one thing,
         on error it does not free all the storage associated with the
         bfd).  */
      bfd_close (sym_bfd);	/* This also closes desc */
d1399 2
a1400 1
  return (sym_bfd);
d1403 3
a1405 2
/* Return the section index for the given section name. Return -1 if
   the section was not found. */
d1410 1
d1417 4
a1420 4
/* Link a new symtab_fns into the global symtab_fns list.  Called on gdb
   startup by the _initialize routine in each object file format reader,
   to register information about each format the the reader is prepared
   to handle. */
d1429 4
a1432 5

/* Initialize to read symbols from the symbol file sym_bfd.  It either
   returns or calls error().  The result is an initialized struct sym_fns
   in the objfile structure, that contains cached information about the
   symbol file.  */
d1444 1
a1444 1
    return;	/* No symbols. */
d1454 1
d1459 1
@


1.160
log
@	* corelow.c (core_open): Use bfd_fopen, not bfd_fdopenr.
	* exec.c (exec_file_attach): Likewise.
	* solib-frv.c (enable_break2): Likewise.
	* solib-svr4.c (enable_break): Likewise.
	* solib.c (solib_map_sections): Likewise.
	* symfile.c (symfile_bfd_open): Likewise.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d60 1
d1604 1
a1604 1
  time_t start_time, end_time;	/* Start and end times of download */
d1656 1
a1656 1
  start_time = time (NULL);
d1660 1
a1660 1
  end_time = time (NULL);
d1679 1
a1679 1
			      cbdata.write_count, end_time - start_time);
d1694 8
a1701 2
  print_transfer_performance (gdb_stdout, data_count,
			      end_time - start_time, 0);
d1708 2
a1709 1
			    unsigned long time_count)
d1711 7
d1722 1
a1722 1
			(data_count * 8) / time_count);
@


1.159
log
@gdb/
	* Makefile.in (symfile.o): Add $(exec_h).
	* exec.h (exec_set_section_address): Add prototype.
	* exec.c (exec_set_section_address): New function.
	* symfile.c: Include "exec.h".
	(struct place_section_arg, place_section): New.
	(default_symfile_offsets): Call place_section for each
	section of a relocatable file.
gdb/testsuite/
	* gdb.base/relocate.c: Add a copyright notice.
	(dummy): Remove.
	* gdb.base/relocate.exp: Test printing the values of variables
	from a relocatable file.
@
text
@d1375 1
a1375 1
  sym_bfd = bfd_fdopenr (name, gnutarget, desc);
@


1.158
log
@* target.h (target_link): Remove prototype.
* target.c (target_link): Remove function.
* symfile.c: Remove comment about rombug.
@
text
@d52 1
d460 78
d574 13
@


1.157
log
@	* symfile.c (clear_symtab_users): Call
	clear_current_source_symtab_and_line first.
@
text
@a1167 4
/* Note: ezannoni 2000-04-17. This function used to have support for
   rombug (see remote-os9k.c). It consisted of a call to target_link()
   (target.c) to get the address of the text segment from the target,
   and pass that to symbol_file_add(). This is no longer supported. */
@


1.157.2.1
log
@2005-03-28  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in: arm-tdep.o depends on $(observer_h).
	* gdb/arm-linux-nat.c (fetch_fpregister, fetch_fpregs,
	store_fpregister, store_fpregs): Rename...
	(fetch_fpa_register, fetch_fpa_regs, store_fpa_register,
	store_fpa_regs): ... to this.
	* gdb/arm-linux-tdep.c (arm_linux_init_abi): Provide ABI specific
	overrides.
	* gdb/arm-tdep.c: Include opserver.h.
	(struct gdbarch_tdep_info): Add.
	(arm_push_dummy_call): Handle doubleword alignment.
	(arm_register_type): Handle iWMMXt and VFP regs.
	(arm_register_byte): Ditto.
	(arm_pseudo_register_read): New function.
	(arm_pseudo_register_write): New function.
	(arm_dwarf_reg_to_regnum): New function.
	(arm_register_sim_regno): Handle iWMMXT regs.
	(arm_register_remote_regno): New function.
	(arm_extract_return_value): Use new macro names.
	(arm_register_name): Handle iWMMXt and VFP registers.
	(arm_sim_available_registers): New function.
	(arm_update_architecture): New function.
	(arm_gdbarch_init): Handle optional register sets.  Register new
	hooks.  Fix misleading error message.
	(_initialize_arm_tdep): Call observer_attach_inferior_created.
	* gdb/arm-tdep.h (ARM_NUM_FP_ARG_REGS, ARM_LAST_FP_ARG_REGNUM,
	FP_REGISTER_SIZE, NUM_FREGS): Rename ...
	(ARM_NUM_FPA_ARG_REGS, ARM_LAST_FPA_ARG_REGNUM, FPA_REGISTER_SIZE,
	NUM_FPA_REGS): ... to this.
	(NUM_IWMMXT_COP0REGS, NUM_IWMMXT_COP1REGS, NUM_IWMMXT_REGS,
	IWMMXT_COP0_REGSIZE, IWMMXT_COP1_REGSIZE, NUM_VFP_XREGS,
	VFP_XREG_SIZE, NUM_VFP_SREGS, VFP_SREG_SIZE, NUM_VFP_PSEUDOS): Define.
	(struct gdbarch_tdep): Add target_has_iwmmxt_regs,
	target_has_vfp_regs, first_iwmmxt_regnum, target_iwmmxt_regnum,
	first_vfp_regnum, first_vfp_pseudo and target_vfp_regnum.
	* gdb/gdbarch.c (struct gdbarch): Add remote_num_g_packet_regs,
	sim_available_registers and register_remote_regno.
	(startup_gdbarch, verify_gdbarch): Ditto.
	(gdbarch_dump): Dump new fields.
	(gdbarch_remote_num_g_packet_regs_p, gdbarch_remote_num_g_packet_regs,
	set_gdbarch_remote_num_g_packet_regs,
	gdbarch_sim_available_registers_p, gdbarch_sim_available_registers,
	set_gdbarch_sim_available_registers, gdbarch_register_remote_regno_p,
	gdbarch_register_remote_regno, set_gdbarch_register_remote_regno):
	New functions.
	* gdb/gdbarch.h: Add prototypes.
	* gdb/gdbarch.sh: Add new fields.
	(deprecated_current_gdbarch_select_hack): Call flush_cached_frames.
	* gdb/remote-sim.h (gdbsim_create_inferior): Call
	observer_notify_inferior_created.
	(gdbsim_xfer_partial): New function.
	(init_gdbsim_ops): Use it.
	* gdb/remote.c (struct remote_state): Add num_g_regs.
	(init_remote_state): Only consider hard regs.  Allow target to provide
	register mapping.
	(packet_reg_from_regnum): Don't check pseudo regs.
	(packet_reg_from_pnum): Ditto.
	(remote_protocol_qPart_availableRegisters): Add.
	(set_remote_protocol_qPart_availableRegisters_packet_cmd,
	show_remote_protocol_qPart_availableRegisters_packet_cmd): New
	functions.
	(fetch_register_using_p, store_register_using_P): Handle arbitrary
	register mappings.
	(fetch_registers_using_g): New function.
	(remote_fetch_registers): Use it.
	(store_registers_using_G): New function.
	(remote_store_registers): Use it.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_REGISTERS.
	(show_remote_cmd): Display availableRegisters.
	(_initialize_remote): Register qPart_availableRegisters.
	* gdb/target.h (enum target_object): Add
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/gdbserver/configure.srv (arm*-*-linux*): set
	srv_linux_regsets=yes.
	* gdb/gdbserver/linux-arm-low.c (PTRACE_GETWMMXREGS,
	PTRACE_SETWMMXREGS): Define.
	(arm_fill_gregset, arm_store_gregset, arm_fill_wmmxregset,
	arm_store_wmmxregset, arm_available_registers): New functions.
	(target_regsets): Add.
	(the_low_target): Use arm_available_registers.
	* gdb/gdbserver/linux-low.c (linux_available_registers): New function.
	(linux_target_op): Use it.
	* gdb/gdbserver/linux-low.h (gdbserver/linux-low.h): Add
	available_registers.
	(use_regsets_p): Declare.
	* gdb/gdbserver/regcache.c (g_register_bytes): Add.
	(regcache_invalidate, registers_to_string, registers_from_string):
	Use it.
	(set_register_cache): Set g_register_bytes.
	(supply_register_as_string): New function.
	* gdb/gdbserver/regcache.h (supply_register_as_string): Add prototype.
	* gdb/gdbserver/server.c (handle_query): Handle
	qPart:availableRegisters.
	(handle_p_packet, handle_P_packet): New functions.
	(main): Handle 'p' and 'P' packets.
	* gdb/gdbserver/target.h (struct target_ops): Add available_registers.
	* gdb/regformats/reg-arm.dat: Add last_g_reg and iWMMXT regs.
	* gdb/regformats/regdat.sh: Handle last_g_reg.
	* gdb/regformats/regdef.h (set_register_cache): Update prototype.
@
text
@d1503 1
a1503 1
	    error (_("Memory access error %d while loading section %s."), err, sect_name);
@


1.157.2.2
log
@	* corelow.c (core_open): Use bfd_fopen, not bfd_fdopenr.
	* exec.c (exec_file_attach): Likewise.
	* solib-frv.c (enable_break2): Likewise.
	* solib-svr4.c (enable_break): Likewise.
	* solib.c (solib_map_sections): Likewise.
	* symfile.c (symfile_bfd_open): Likewise.
@
text
@d1287 1
a1287 1
  sym_bfd = bfd_fopen (name, gnutarget, FOPEN_RB, desc);
@


1.156
log
@        * doc/observer.texi (executable_changed): New observer.
        * symtab.c: Include "observer.h".
        (find_main_name): New function.
        (main_name): If name_of_main is unset, then compute it
        using find_main_name.
        (symtab_observer_executable_changed): New function.
        (_initialize_symtab): Attach executable_changed observer.
        * exec.c: Include "observer.h".
        (exec_file_attach): Emit executable_changed notification.
        * symfile.c: Include "observer.h".
        (reread_symbols): Send an executable_changed if appropriate.
        * Makefile.in (exec.o): Add dependency on observer.h.
        (symfile.o): Likewise.
        (symtab.o): Likewise.
@
text
@d2370 5
a2379 1
  clear_current_source_symtab_and_line ();
@


1.155
log
@2005-02-24  Andrew Cagney  <cagney@@gnu.org>

	Add show_VARIABLE functions, update add_setshow call.
	* varobj.c (_initialize_varobj, show_varobjdebug): Add and update.
	* valprint.c (_initialize_valprint, show_print_max)
	(show_stop_print_at_null, show_repeat_count_threshold)
	(show_prettyprint_structs, show_unionprint)
	(show_prettyprint_arrays, show_addressprint, show_input_radix)
	(show_output_radix): Ditto.
	* valops.c (_initialize_valops, show_overload_resolution): Ditto.
	* utils.c (initialize_utils, show_chars_per_line)
	(show_lines_per_page, show_demangle, show_pagination_enabled)
	(show_sevenbit_strings, show_asm_demangle): Ditto
	* tui/tui-win.c (_initialize_tui_win, show_tui_border_kind)
	(show_tui_border_mode, show_tui_active_border_mode): Ditto.
	* top.c (init_main, show_new_async_prompt)
	(show_async_command_editing_p, show_write_history_p)
	(show_history_size, show_history_filename, show_caution)
	(show_annotation_level, init_main): Ditto.
	* target.c (initialize_targets, show_targetdebug)
	(show_trust_readonly): Ditto.
	* symfile.c (_initialize_symfile, show_symbol_reloading)
	(show_ext_args, show_download_write_size)
	(show_debug_file_directory): Ditto.
	* source.c (_initialize_source, show_lines_to_list): Ditto.
	* solib.c (_initialize_solib, show_auto_solib_add)
	(show_solib_search_path): Ditto.
	* p-valprint.c (_initialize_pascal_valprint)
	(show_pascal_static_field_print): Ditto.
	* printcmd.c (_initialize_printcmd, show_max_symbolic_offset)
	(show_print_symbol_filename): Add and update.
	* parse.c (_initialize_parse, show_expressiondebug): Dito.
	* observer.c (_initialize_observer, show_observer_debug): Dito.
	* maint.c (_initialize_maint_cmds, show_watchdog)
	(show_maintenance_profile_p): Dito.
	* linux-nat.c (_initialize_linux_nat, show_debug_linux_nat): Dito.
	* infrun.c (_initialize_infrun, show_debug_infrun)
	(show_stop_on_solib_events, show_follow_fork_mode_string)
	(show_scheduler_mode, show_step_stop_if_no_debug): Ditto.
	* infcall.c (_initialize_infcall, show_coerce_float_to_double_p)
	(show_unwind_on_signal_p): Ditto.
	* gdbtypes.c (build_gdbtypes, show_opaque_type_resolution)
	(_initialize_gdbtypes, show_overload_debug): Ditto.
	* gdb-events.c, gdb-events.sh (_initialize_gdb_events)
	(show_gdb_events_debug): Ditto.
	* gdbarch.c, gdbarch.sh (show_gdbarch_debug)
	(_initialize_gdbarch): Ditto.
	* frame.c (_initialize_frame, show_backtrace_past_main)
	(show_backtrace_past_entry, show_backtrace_limit)
	(show_frame_debug): Ditto.
	* exec.c (_initialize_exec, show_write_files): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read)
	(show_dwarf2_max_cache_age): Ditto.
	* demangle.c (_initialize_demangler)
	(show_demangling_style_names): Ditto.
	* dcache.c (_initialize_dcache, show_dcache_enabled_p): Ditto.
	* cp-valprint.c (show_static_field_print)
	(_initialize_cp_valprint, show_vtblprint, show_objectprint): Ditto.
	* corefile.c (_initialize_core, show_gnutarget_string): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging)
	(show_logging_overwrite, show_logging_redirect)
	(show_logging_filename): Ditto.
	* cli/cli-cmds.c (show_info_verbose, show_history_expansion_p)
	(init_cli_cmds, show_baud_rate, show_remote_debug)
	(show_remote_timeout, show_max_user_call_depth): Ditto.
	* charset.c (show_host_charset_name, show_target_charset_name)
	(initialize_charset): Ditto.
	* breakpoint.c (show_can_use_hw_watchpoints)
	(show_pending_break_support, _initialize_breakpoint): Ditto.
@
text
@d51 1
d2017 7
a2023 1
    clear_symtab_users ();
@


1.154
log
@2005-02-21  Andrew Cagney  <cagney@@gnu.org>

	Replace string variables with a filename completer with
	add_setshow_optional_filename_cmd.
	* solib.c, symfile.c: Update.
	* cli/cli-setshow.c: Do not tidle expand the file.
@
text
@d163 9
d1064 8
d1387 8
d2114 8
d3601 1
a3601 1
			   NULL, /* FIXME: i18n: */
d3637 1
a3637 1
				   NULL, /* FIXME: i18n: */
d3653 1
a3653 1
			   NULL, /* FIXME: i18n: */
d3666 1
a3666 1
				     NULL, /* FIXME: i18n: */
@


1.153
log
@2005-02-21  Andrew Cagney  <cagney@@gnu.org>

	Add more uses of add_setshow_string_cmd, add_setshow_integer_cmd,
	and add_setshow_string_noescape_cmd.
	* cli/cli-setshow.c (deprecated_show_value_hack): Do not print a
	NULL command's value.
	* kod.c, language.c, ocd.c, remote-e7000.c, remote-mips.c: Update.
	* remote-sds.c, remote.c, symfile.c, top.c: Update.
@
text
@d3624 11
a3634 12
  c = (add_set_cmd
       ("debug-file-directory", class_support, var_string,
        (char *) &debug_file_directory,
        "Set the directory where separate debug symbols are searched for.\n"
        "Separate debug symbols are first searched for in the same\n"
        "directory as the binary, then in the `" DEBUG_SUBDIRECTORY
        "' subdirectory,\n"
        "and lastly at the path of the directory of the binary with\n"
        "the global debug-file directory prepended\n",
        &setlist));
  deprecated_add_show_from_set (c, &showlist);
  set_cmd_completer (c, filename_completer);
@


1.152
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_boolean_command through out.  Delete #ifdef 0'ed
	code adding set/show boolean commands.
	* cp-valprint.c, dcache.c, exec.c, gdbtypes.c, infrun.c: Update.
	* monitor.c, p-valprint.c, pa64solib.c, printcmd.c: Update.
	* proc-api.c, remote-mips.c, remote.c, solib.c: Update.
	* somsolib.c, symfile.c, top.c, utils.c, valops.c: Update.
	* valprint.c, win32-nat.c, wince.c, xcoffsolib.c: Update.
	* cli/cli-cmds.c: Update.
@
text
@d3610 12
a3621 11
  deprecated_add_show_from_set
    (add_set_cmd ("download-write-size", class_obscure,
		  var_integer, (char *) &download_write_size,
		  "Set the write size used when downloading a program.\n"
		  "Only used when downloading a program onto a remote\n"
		  "target. Specify zero, or a negative value, to disable\n"
		  "blocked writes. The actual size of each transfer is also\n"
		  "limited by the size of the target packet and the memory\n"
		  "cache.\n",
		  &setlist),
     &showlist);
@


1.151
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* command.h (fprint_setshow_ftype): Delete.
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* complaints.c, cris-tdep.c, dwarf2read.c, frame.c: Update.
	* hppa-tdep.c, infcall.c, m32r-rom.c, maint.c: Update.
	* mips-tdep.c, nto-tdep.c, observer.c, remote-rdi.c: Update
	* remote.c, target.c, cli/cli-logging.c: Update.
@
text
@d3563 7
a3569 6
  deprecated_add_show_from_set
    (add_set_cmd ("symbol-reloading", class_support, var_boolean,
		  (char *) &symbol_reloading,
	    "Set dynamic symbol table reloading multiple times in one run.",
		  &setlist),
     &showlist);
@


1.150
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@a140 2
static void set_ext_lang_command (char *args, int from_tty);

d2091 1
a2091 1
set_ext_lang_command (char *args, int from_tty)
d3597 8
a3604 6
  c = add_set_cmd ("extension-language", class_files, var_string_noescape,
		   (char *) &ext_args,
		   "Set mapping between filename extension and source language.\n\
Usage: set extension-language .foo bar",
		   &setlist);
  set_cmd_cfunc (c, set_ext_lang_command);
@


1.149
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d3573 1
a3573 1
		  "Commands for debugging overlays.", &overlaylist,
d3607 1
a3607 1
	    "All filename extensions associated with a source language.");
@


1.148
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	* utils.c (paddress): New function.
	* defs.h (paddress): Declare.
	* printcmd.c (deprecated_print_address_numeric): Rename
	print_address_numeric, call paddress.
	* valprint.c, ui-out.c, tui/tui-stack.c, tracepoint.c: Update.
	* symmisc.c, symfile.c stack.c, p-valprint.c, printcmd.c: Update.
	* maint.c, m32r-rom.c, infcmd.c, f-valprint.c, exec.c: Update.
	* dwarf2read.c, dve3900-rom.c, defs.h, c-valprint.c: Update.
	* corefile.c, cli/cli-cmds.c, breakpoint.c, annotate.c: Update.
	* ada-valprint.c: Update.
@
text
@d3537 2
a3538 2
  c = add_cmd ("symbol-file", class_files, symbol_file_command,
	       "Load symbol table from executable file FILE.\n\
d3540 1
a3540 1
to execute.", &cmdlist);
d3543 2
a3544 2
  c = add_cmd ("add-symbol-file", class_files, add_symbol_file_command,
	       "Usage: add-symbol-file FILE ADDR [-s <SECT> <SECT_ADDR> -s <SECT> <SECT_ADDR> ...]\n\
d3549 1
a3549 1
with the text.  SECT is a section name to be loaded at SECT_ADDR.",
d3554 2
a3555 2
	       add_shared_symbol_files_command,
   "Load the symbols from shared objects in the dynamic linker's link map.",
d3560 3
a3562 3
  c = add_cmd ("load", class_files, load_command,
	       "Dynamically load FILE into the running program, and record its symbols\n\
for access from GDB.", &cmdlist);
d3580 1
a3580 1
	   "Assert that an overlay section is mapped.", &overlaylist);
d3583 1
a3583 1
	   "Assert that an overlay section is unmapped.", &overlaylist);
d3586 1
a3586 1
	   "List mappings of overlay sections.", &overlaylist);
d3589 1
a3589 1
	   "Enable overlay debugging.", &overlaylist);
d3591 1
a3591 1
	   "Disable overlay debugging.", &overlaylist);
d3593 1
a3593 1
	   "Enable automatic overlay debugging.", &overlaylist);
d3595 1
a3595 1
	   "Read the overlay mapping state from the target.", &overlaylist);
@


1.147
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d3083 1
a3083 1
	print_address_numeric (lma, 1, gdb_stdout);
d3085 1
a3085 1
	print_address_numeric (lma + size, 1, gdb_stdout);
d3087 1
a3087 1
	print_address_numeric (vma, 1, gdb_stdout);
d3089 1
a3089 1
	print_address_numeric (vma + size, 1, gdb_stdout);
@


1.146
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d834 1
a834 1
	  printf_unfiltered ("Reading symbols from %s...", name);
d851 1
a851 1
	  printf_unfiltered ("expanding to full symbols...");
d890 1
a890 1
      printf_filtered ("(no debugging symbols found)");
d904 1
a904 1
	  printf_unfiltered ("done.\n");
d1002 1
a1002 1
      printf_unfiltered ("No symbol file now.\n");
d1748 1
a1748 1
  printf_unfiltered ("add symbol table from file \"%s\" at\n", filename);
d1827 1
a1827 1
	      printf_unfiltered ("`%s' has disappeared; keeping its symbols.\n",
d1839 1
a1839 1
	      printf_unfiltered ("`%s' has changed; re-reading symbols.\n",
d1966 1
a1966 1
		  printf_unfiltered ("(no debugging symbols found)\n");
d2154 1
a2154 1
  printf_filtered ("Filename extensions and the languages they represent:");
d3095 1
a3095 1
    printf_filtered ("No sections are mapped.\n");
d3138 1
a3138 1
	    printf_unfiltered ("Note: section %s unmapped by overlap\n",
d3188 1
a3188 1
    printf_unfiltered ("Automatic overlay debugging enabled.");
d3201 1
a3201 1
    printf_unfiltered ("Overlay debugging enabled.");
d3214 1
a3214 1
    printf_unfiltered ("Overlay debugging disabled.");
@


1.145
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d2523 1
a2523 1
	  complaint (&symfile_complaints, "Replacing old symbols for `%s'",
d2530 2
a2531 4
	{
	  complaint (&symfile_complaints, "Empty symbol table found for `%s'",
		     name);
	}
@


1.144
log
@2004-10-23  Andrew Cagney  <cagney@@gnu.org>

	* objfiles.h (struct objfile): Rename obj_private to
	deprecated_obj_private, sym_private to deprecated_sym_private, and
	sym_stab_info to deprecated_sym_stab_info.
	* gdb-stabs.h: Update.
	* elfread.c: Update.
	* dbxread.c: Update.
	* coffread.c: Update.
	* xcoffread.c: Update.
	* symfile.c: Update.
	* somread.c: Update.
	* nlmread.c: Update.
	* mdebugread.c: Update.
	* hpread.c: Update.
	* coffread.c: Update.
@
text
@d604 1
a604 1
	warning ("no loadable sections found in added symbol-file %s",
d608 1
a608 1
	  warning ("Lowest section in %s is %s at %s",
d643 1
a643 1
                    warning ("section %s not found in %s",
d814 1
a814 1
    error ("Not confirmed.");
d989 1
a989 1
    error ("Not confirmed.");
d1183 1
a1183 1
	    error ("unknown option `%s'", *argv);
d1195 1
a1195 1
	  error ("no symbol file name was specified");
d1276 1
a1276 1
      error ("\"%s\": can't open to read symbols: %s.", name,
d1288 1
a1288 1
      error ("\"%s\": can't read symbols: %s.", name,
d1344 1
a1344 1
  error ("I'm sorry, Dave, I can't do that.  Symbol format `%s' unknown.",
d1454 1
a1454 1
		    error ("Download verify read failed at 0x%s",
d1457 1
a1457 1
		    error ("Download verify compare failed at 0x%s",
d1469 1
a1469 1
		error ("Canceled the download");
d1479 1
a1479 1
	    error ("Memory access error while loading section %s.", sect_name);
d1515 1
a1515 1
	error ("Invalid download offset:%s\n", offptr);
d1536 1
a1536 1
      error ("\"%s\" is not an object file: %s", filename,
d1653 1
a1653 1
    error ("add-symbol-file takes a file name and an address");
d1736 1
a1736 1
		    error ("USAGE: add-symbol-file <filename> <textaddress> [-mapped] [-readnow] [-s <secname> <addr>]*");
d1775 1
a1775 1
    error ("Not confirmed.");
d1791 1
a1791 1
  error ("This command is not available in this configuration of GDB.");
d1861 1
a1861 1
		error ("Can't close BFD for %s: %s", objfile->name,
d1865 1
a1865 1
		error ("Can't open %s to read symbols.", objfile->name);
d1868 1
a1868 1
		error ("Can't read symbols from %s: %s.", objfile->name,
d1935 1
a1935 1
		  error ("Can't find the file sections in `%s': %s",
d2101 1
a2101 1
    error ("'%s': Filename extension must begin with '.'", ext_args);
d2108 1
a2108 1
    error ("'%s': two arguments required -- filename extension and language",
d2119 1
a2119 1
    error ("'%s': two arguments required -- filename extension and language",
d3111 1
a3111 1
    error ("\
d3113 1
a3113 1
the 'overlay manual' command.");
d3116 1
a3116 1
    error ("Argument required: name of an overlay section");
d3147 1
a3147 1
  error ("No overlay section called %s", args);
d3161 1
a3161 1
    error ("\
d3163 1
a3163 1
the 'overlay manual' command.");
d3166 1
a3166 1
    error ("Argument required: name of an overlay section");
d3173 1
a3173 1
	error ("Section %s is not mapped", args);
d3177 1
a3177 1
  error ("No overlay section called %s", args);
d3225 1
a3225 1
    error ("This target does not know how to read its overlay state.");
d3346 1
a3346 1
      error ("Error reading inferior's overlay table: "
d3348 1
a3348 1
             "in inferior.  Use `overlay manual' mode.");
d3355 1
a3355 1
      error ("Error reading inferior's overlay table: couldn't find "
d3357 1
a3357 1
             "in inferior.  Use `overlay manual' mode.");
@


1.143
log
@First part of turning on initial Ada support.

* symfile.c (init_filename_language_table): Add extensions for
Ada.
* defs.h (enum language): Add language_ada.
* gdbtypes.h (TYPE_FLAG_FIXED_INSTANCE): Define.
* ada-lang.c: Strip code that is conditionalized out by GNAT_GDB.
(add_symbols_from_enclosing_procs): Make a no-op for now.
(ada_unqualified_name,add_angle_brackets,function_name_from_pc)
(extended_canonical_line_spec, find_sal_from_funcs_and_line)
(find_line_in_linetable, find_next_line_in_linetable)
(read_all_symtabs, is_plausible_func_for_line)
(adjust_pc_past_prologue, error_breakpoint_runtime_sym_not_found)
(is_runtime_sym_defined, check_size): Remove declaration.
(function_name_from_pc, ada_translate_error_message)
(ada_lookup_minimal_symbol): Remove definition.
(ada_add_block_symbols): Remove useless label.
* ada-lang.h (ada_maybe_exception_partial_symbol): Remove
useless declaration.
(ada_is_exception_sym): Likewise.
@
text
@d1911 1
a1911 1
	      objfile->sym_private = NULL;
@


1.142
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@d2188 4
@


1.141
log
@Fix bug reported and analyzed by Olivier Crete:
* symfile.c (copy_section_addr_info): New function.
(symbol_file_add_with_addrs_or_offsets): Use it to save the
original set of address arguments, instead of handwritten code
that uses one length to allocate and a different length to
initialize.  Use make_cleanup_free_section_addr_info.
* symfile.h (copy_section_addr_info): New declaration.
* utils.c: #include "symfile.h".
(do_free_section_addr_info, make_cleanup_free_section_addr_info):
New functions.
* defs.h (make_cleanup_free_section_addr_info): New declaration.
* Makefile.in (utils.o): Update dependencies.
@
text
@d1745 1
a1745 1
     statements because local_hex_string returns a local static
d1764 1
a1764 2
		       sec,
		       local_hex_string ((unsigned long)addr));
@


1.140
log
@2004-08-10  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (xmfree): Delete.
	* utils.c (xmfree): Delete function.
	(xfree): Inline calls to xmfree and mfree.
	* symmisc.c (free_symtab_block, free_symtab): Use xfree.
	* symfile.c (reread_symbols, init_psymbol_list): Ditto.
	* source.c (forget_cached_source_info, find_and_open_source): Ditto.
	* somread.c (som_symfile_finish): Ditto.
	* objfiles.c (allocate_objfile, free_objfile):
	* nlmread.c (nlm_symfile_finish): Ditto.
	* hpread.c (hpread_symfile_finish): Ditto.
	* elfread.c (free_elfinfo, elf_symfile_finish): Ditto.
	* dbxread.c (dbx_symfile_finish, free_bincl_list): Ditto.
	* coffread.c (coff_symfile_finish): Ditto.
@
text
@d327 26
d801 1
a801 1
  struct section_addr_info *orig_addrs;
a818 2
  orig_addrs = alloc_section_addr_info (bfd_count_sections (abfd));
  my_cleanups = make_cleanup (xfree, orig_addrs);
d821 2
a822 4
      int i;
      orig_addrs->num_sections = addrs->num_sections;
      for (i = 0; i < addrs->num_sections; i++)
	orig_addrs->other[i] = addrs->other[i];
@


1.139
log
@2004-08-10  Andrew Cagney  <cagney@@gnu.org>

	* utils.c (xmmalloc): Delete.
	(xmalloc): Inline xmmalloc and mmalloc calls.
	(msavestring): Use xmalloc.
	* defs.h (xmmalloc): Delete declaration.
	* xcoffread.c (xcoff_symfile_init): Use xmalloc instead of
	xmmalloc.
	* symmisc.c (extend_psymbol_list): Ditto.
	* symfile.c (init_psymbol_list): Ditto.
	* source.c (find_source_lines): Ditto.
	* hpread.c (hpread_symfile_init, hpread_lookup_type): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* dbxread.c (dbx_symfile_init, init_bincl_list): Ditto.
	* coffread.c (coff_symfile_init): Ditto.
@
text
@d1865 1
a1865 1
		xmfree (objfile->md, objfile->global_psymbols.list);
d1869 1
a1869 1
		xmfree (objfile->md, objfile->static_psymbols.list);
d2693 1
a2693 1
      xmfree (objfile->md, objfile->global_psymbols.list);
d2697 1
a2697 1
      xmfree (objfile->md, objfile->static_psymbols.list);
@


1.138
log
@	* symfile.c (symbol_file_add_with_addrs_or_offsets): Make sure to
	print a line feed before the prompt.
@
text
@d2711 2
a2712 2
	xmmalloc (objfile->md, (objfile->global_psymbols.size
				* sizeof (struct partial_symbol *)));
d2718 2
a2719 2
	xmmalloc (objfile->md, (objfile->static_psymbols.size
				* sizeof (struct partial_symbol *)));
@


1.137
log
@	* defs.h (OPF_TRY_CWD_FIRST, OPF_SEARCH_IN_PATH): New macros.

	* exec.c (exec_file_attach):
	* nto-tdep.c (nto_find_and_open_solib):
	* pa64solib.c (pa64_solib_sizeof_symbol_table):
	* solib.c (solib_open):
	* somsolib.c (som_solib_sizeof_symbol_table):
	* source.c (is_regular_file, openp, open_source_file):
	* symfile.c (symfile_bfd_open):
	* wince.c (upload_to_device): Differentiate between the search for
	binary and source files.
@
text
@d868 5
a872 1
      printf_unfiltered ("(no debugging symbols found)...");
@


1.136
log
@	* inflow.c (kill_command): release file handles in BFD.
	* exec.c (exec_file_attach): Ditto.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Ditto.
@
text
@d1225 2
a1226 1
  desc = openp (getenv ("PATH"), 1, name, O_RDONLY | O_BINARY, 0, &absolute_name);
d1232 2
a1233 2
      desc = openp (getenv ("PATH"), 1, exename, O_RDONLY | O_BINARY,
		    0, &absolute_name);
@


1.135
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d897 1
@


1.134
log
@2004-07-10  Michael Snyder  <msnyder@@redhat.com>

        * symfile.c (generic_load): Comment typo.
        * stack.c (get_selected_block): Ditto.
        * regcache.c (regcache_cooked_read): Ditto.
        * monitor.c (monitor_debug): Ditto.
        * mips-tdep.c (mips_read_pc): Ditto.
        * i386-linux-nat.c (ps_get_thread_area): Ditto.
        * gdb_mbuild.sh: Ditto.
        * gdbarch.sh: Ditto.
        * gdbarch.h: Ditto.
@
text
@d3536 1
a3536 1
  add_show_from_set
d3580 1
a3580 1
  add_show_from_set
d3603 1
a3603 1
  add_show_from_set (c, &showlist);
@


1.133
log
@2004-06-24  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (deprecated_pre_add_symbol_hook)
	(deprecated_post_add_symbol_hook): Deprecated.
	* symfile.c (symbol_file_add_with_addrs_or_offsets)
	(symbol_file_add_with_addrs_or_offsets): Update references.
@
text
@d1535 1
a1535 1
     others don't (or didn't - perhaphs they have all been deleted).  */
@


1.132
log
@	* dsrec.c (load_srec, make_srec): Use bfd_get_section_size instead of
	bfd_get_section_size_before_reloc or _raw_size.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2read.c (dwarf2_locate_sections): Likewise.
	(dwarf2_read_section): Likewise.
	* elfread.c (elf_locate_sections): Likewise.
	* gcore.c (derive_heap_segment): Likewise.
	* mipsread.c (read_alphacoff_dynamic_symtab): Likewise.
	* remote-e7000.c (e7000_load): Likewise.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* remote-mips.c (mips_load_srec): Likewise.
	(pmon_load_fast): Likewise.
	* remote.c (compare_sections_command): Likewise.
	* symfile.c (add_section_size_callback): Likewise.
	(load_section_callback): Likewise.
	(pc_in_unmapped_range): Likewise.
	(pc_in_mapped_range): Likewise.
	(sections_overlap): Likewise.
	(list_overlays_command): Likewise.
	(simple_overlay_update_1): Likewise.
	(simple_overlay_update): Likewise.
	* tracepoint.c (remote_set_transparent_ranges): Likewise.
	* win32-nat.c (core_section_load_dll_symbols): Likewise.
@
text
@d69 2
a70 2
void (*pre_add_symbol_hook) (const char *);
void (*post_add_symbol_hook) (void);
d808 2
a809 2
      if (pre_add_symbol_hook)
	pre_add_symbol_hook (name);
d874 2
a875 2
      if (post_add_symbol_hook)
	post_add_symbol_hook ();
@


1.131
log
@2004-06-14  Randolph Chung  <tausq@@debian.org>

	* Makefile.in (hppa-hpux-tdep.o): Update dependency.
	* hppa-hpux-tdep.c (hp_cxx_exception_support_initialized): Make
	static.
	(hppa_hpux_inferior_created): New function.
	(hppa_hpux_init_abi): Register observer.
	* symfile.c (hp_cxx_exception_support_initialized)
	(RESET_HP_UX_GLOBALS): Remove HPUXHPPA specific hacks.
	(symbol_file_add_main_1, symbol_file_clear): Likewise.
@
text
@d1353 1
a1353 1
  *sum += bfd_get_section_size_before_reloc (asec);
d1373 1
a1373 1
      bfd_size_type size = bfd_get_section_size_before_reloc (asec);
d2877 1
a2877 1
	size = bfd_get_section_size_before_reloc (section);
d2897 1
a2897 1
	size = bfd_get_section_size_before_reloc (section);
d2913 1
a2913 1
  CORE_ADDR a_end = a->vma + bfd_get_section_size_before_reloc (a);
d2915 1
a2915 1
  CORE_ADDR b_end = b->vma + bfd_get_section_size_before_reloc (b);
d3050 1
a3050 1
	size = bfd_get_section_size_before_reloc (osect->the_bfd_section);
d3390 1
a3390 1
  size = bfd_get_section_size_before_reloc (osect->the_bfd_section);
d3451 1
a3451 1
      size = bfd_get_section_size_before_reloc (osect->the_bfd_section);
@


1.130
log
@* symtab.h (SYMBOL_SEARCH_NAME): New definition.
(SYMBOL_MATCHES_SEARCH_NAME): New definition.
(symbol_search_name): Declare.

* dictionary.c (iter_name_first_hashed): Match on SYMBOL_SEARCH_NAME.
(iter_name_next_hashed): Ditto.
(iter_name_next_linear): Ditto.
(insert_symbol_hashed): Hash on SYMBOL_SEARCH_NAME.

* symtab.c (lookup_partial_symbol): Assume symbols ordered by
search name, using SYMBOL_SEARCH_NAME and SYMBOL_MATCHES_SEARCH_NAME.
(symbol_search_name): New function.

* symfile.c (compare_psymbols): Order by SYMBOL_SEARCH_NAME.

* minsyms.c (build_minimal_symbol_hash_tables): Change
test for adding to demangled hash table to check for difference
between SYMBOL_SEARCH_NAME and SYMBOL_LINKAGE_NAME.
@
text
@a62 12
#ifdef HPUXHPPA

/* Some HP-UX related globals to clear when a new "main"
   symbol file is loaded. HP-specific.  */

extern int hp_cxx_exception_support_initialized;
#define RESET_HP_UX_GLOBALS() do {\
                                    deprecated_hp_som_som_object_present = 0;             /* indicates HP-compiled code */        \
                                    hp_cxx_exception_support_initialized = 0;  /* must reinitialize exception stuff */ \
                              } while (0)
#endif

a947 4
#ifdef HPUXHPPA
  RESET_HP_UX_GLOBALS ();
#endif

a975 3
#ifdef HPUXHPPA
    RESET_HP_UX_GLOBALS ();
#endif
a1927 3
#ifdef HPUXHPPA
		  RESET_HP_UX_GLOBALS ();
#endif
@


1.129
log
@Move the symbol-file-from-memory functions into their own file.
* symfile-mem.c, symfile-mem.h: New files.
* symfile.c (symbol_file_add_from_bfd): New function.
(symbol_file_add): Call symbol_file_add_from_bfd.
(symbol_file_add_from_memory, add_symbol_file_from_memory_command):
Moved to symfile-mem.c.
(_initialize_symfile): Move definition of
add-symbol-file-from-memory command to symfile-mem.c.
* symfile.h (symbol_file_add_from_bfd): New declaration.
* config/i386/linux.mt (TDEPFILES): Add symfile-mem.o.
* config/powerpc/linux.mt (TDEPFILES): Same.
* Makefile.in (SFILES): Add symfile-mem.c.
(symfile_mem_h): New variable.
(HFILES_NO_SRCDIR): Add symfile-mem.h.
(symfile-mem.o): New rule.
@
text
@d210 2
a211 2
  return strcmp_iw_ordered (SYMBOL_NATURAL_NAME (*s1),
			    SYMBOL_NATURAL_NAME (*s2));
@


1.128
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d913 16
d936 2
a937 3
  return symbol_file_add_with_addrs_or_offsets (symfile_bfd_open (name),
						from_tty, addrs, 0, 0,
                                                mainline, flags);
a1786 87
#if 0
/* Read inferior memory at ADDR to find the header of a loaded object file
   and read its in-core symbols out of inferior memory.  TEMPL is a bfd
   representing the target's format.  */
struct objfile *
symbol_file_add_from_memory (bfd *templ, CORE_ADDR addr, int from_tty)
{
  struct objfile *objf;
  bfd *nbfd;
  asection *sec;
  bfd_vma loadbase;
  struct section_addr_info *sai;
  unsigned int i;

  if (bfd_get_flavour (templ) != bfd_target_elf_flavour)
    error ("add-symbol-file-from-memory not supported for this target");

  nbfd = bfd_elf_bfd_from_remote_memory (templ, addr, &loadbase,
					 target_read_memory);
  if (nbfd == NULL)
    {
      error ("Failed to read a valid object file image from memory.");
      return NULL;
    }

  nbfd->filename = xstrdup ("shared object read from target memory");

  if (!bfd_check_format (nbfd, bfd_object))
    {
      /* FIXME: should be checking for errors from bfd_close (for one thing,
         on error it does not free all the storage associated with the
         bfd).  */
      bfd_close (nbfd);
      error ("Got object file from memory but can't read symbols: %s.",
	     bfd_errmsg (bfd_get_error ()));
      return NULL;
    }

  sai = alloc_section_addr_info (bfd_count_sections (nbfd));
  make_cleanup (xfree, sai);
  i = 0;
  for (sec = nbfd->sections; sec != NULL; sec = sec->next)
    if ((bfd_get_section_flags (nbfd, sec) & (SEC_ALLOC|SEC_LOAD)) != 0)
      {
	sai->other[i].addr = bfd_get_section_vma (nbfd, sec) + loadbase;
	sai->other[i].name = (char *) bfd_get_section_name (nbfd, sec);
	sai->other[i].sectindex = sec->index;
	++i;
      }

  objf = symbol_file_add_with_addrs_or_offsets (nbfd, from_tty,
						sai, NULL, 0, 0, OBJF_SHARED);

  /* This might change our ideas about frames already looked at.  */
  reinit_frame_cache ();

  return objf;
}
#endif

static void
add_symbol_file_from_memory_command (char *args, int from_tty)
{
#if 0
  CORE_ADDR addr;
  bfd *templ;

  if (args == NULL)
    error ("add-symbol-file-from-memory requires an expression argument");

  addr = parse_and_eval_address (args);

  /* We need some representative bfd to know the target we are looking at.  */
  if (symfile_objfile != NULL)
    templ = symfile_objfile->obfd;
  else
    templ = exec_bfd;
  if (templ == NULL)
    error ("\
Must use symbol-file or exec-file before add-symbol-file-from-memory.");

  symbol_file_add_from_memory (templ, addr, from_tty);
#else
  error ("add-symbol-file-from-memory not implemented");
#endif
}

a3544 7

  c = add_cmd ("add-symbol-file-from-memory", class_files,
	       add_symbol_file_from_memory_command,
	       "\
Load the symbols out of memory from a dynamically loaded object file.\n\
Give an expression for the address of the file's shared object file header.",
	       &cmdlist);
@


1.127
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_add_from_memory): #if 0 function.
	(add_symbol_file_from_memory_command): #if 0 function body, call
	error instead.
@
text
@d75 2
a76 2
int (*ui_load_progress_hook) (const char *section, unsigned long num);
void (*show_load_progress) (const char *section,
d83 1
a83 1
void (*target_new_objfile_hook) (struct objfile *);
d906 2
a907 2
  if (target_new_objfile_hook)
    target_new_objfile_hook (objfile);
d1443 2
a1444 2
		  || (ui_load_progress_hook != NULL
		      && ui_load_progress_hook (sect_name, sent)))
d1447 4
a1450 3
	      if (show_load_progress != NULL)
		show_load_progress (sect_name, sent, size,
				    args->data_count, args->total_size);
d2402 2
a2403 2
  if (target_new_objfile_hook)
    target_new_objfile_hook (NULL);
@


1.126
log
@2004-04-08  Roland McGrath  <roland@@redhat.com>

	* symfile.c (symbol_file_add_with_addrs_or_offsets): Take ABFD as
	argument instead of NAME.
	(symbol_file_add, reread_separate_symbols): Call symfile_bfd_open
	in call to symbol_file_add_with_addrs_or_offsets.
	(build_addr_info): New function, helper for ...
	(symbol_file_add_from_memory): New function.
	(add_symbol_file_from_memory_command): New function using that.
	(_initialize_symfile): Register it for add-symbol-file-from-memory.
	(pre_add_symbol_hook): Add const to argument type.
	* symfile.h (symbol_file_add_from_memory): Declare it.
@
text
@d1771 1
d1829 1
d1834 1
d1852 4
a1855 1
  (void) symbol_file_add_from_memory (templ, addr, from_tty);
@


1.125
log
@2004-04-08  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Declare.
	* hppa-hpux-tdep.c (initialize_hp_cxx_exception_support)
	(initialize_hp_cxx_exception_support)
	(child_enable_exception_callback): Update.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Rename
	deprecated_exception_catchpoints_are_fragile and
	deprecated_exception_support_initialized.
	(breakpoint_init_inferior, breakpoint_init_inferior): Update.

	* symtab.c (deprecated_hp_som_som_object_present): Rename
	hp_som_som_object_present.
	* symtab.h (deprecated_hp_som_som_object_present): Declare.
	* symfile.c (hp_som_som_object_present, RESET_HP_UX_GLOBALS):
	Update.  Delete extern declaration.
	* valops.c (hp_som_som_object_present): Ditto.
	* parse.c (deprecated_hp_som_som_object_present)
	(parse_nested_classes_for_hpacc): Ditto.
	* hpread.c (hp_som_som_object_present, hpread_expand_symtab): Ditto.
	* hppa-hpux-tdep.c (hp_som_som_object_present)
	(initialize_hp_cxx_exception_support): Ditto.
	* eval.c (hp_som_som_object_present, evaluate_subexp_standard): Ditto.
	* cp-valprint.c (hp_som_som_object_present)
	(cp_print_class_method): Ditto.
	* c-typeprint.c (hp_som_som_object_present):
	(c_type_print_base): Ditto.
	* c-exp.y (hp_som_som_object_present): Ditto.
@
text
@d77 3
a79 3
			    unsigned long section_sent, 
			    unsigned long section_size, 
			    unsigned long total_sent, 
d81 1
a81 1
void (*pre_add_symbol_hook) (char *);
d296 2
a297 2
/* Remember the lowest-addressed loadable section we've seen.  
   This function is called via bfd_map_over_sections. 
d354 1
a354 1
      if (bfd_get_section_flags (stp->bfd, 
d359 1
a359 1
	  sap->other[oidx].name 
d390 1
a390 1
  
d392 1
a392 1
  if (sect) 
d396 1
a396 1
  if (sect) 
d400 1
a400 1
  if (sect) 
d404 1
a404 1
  if (sect) 
d439 1
a439 1
   of how to represent it for fast symbol reading.  This is the default 
d452 1
a452 1
    obstack_alloc (&objfile->objfile_obstack, 
d454 1
a454 1
  memset (objfile->section_offsets, 0, 
d539 1
a539 1
      local_addr 
d582 1
a582 1
      /* Find lowest loadable section to be used as starting point for 
d592 1
a592 1
      else 
d602 1
a602 1
 
d606 1
a606 1
 
d630 1
a630 1
                             addrs->other[i].name, 
d686 2
a687 2
 	/* Map section offsets in "addr" back to the object's 
 	   sections by comparing the section names with bfd's 
d690 1
a690 1
 
d696 1
a696 1
 	    for (i = 0; 
d699 2
a700 2
 	      if (strcmp (bfd_section_name (s->objfile->obfd, 
					    s->the_bfd_section), 
d703 1
a703 1
 
d763 2
a764 2
   NAME is the file name (which will be tilde-expanded and made
   absolute herein) (but we don't free or modify NAME itself).
d778 1
a778 1
symbol_file_add_with_addrs_or_offsets (char *name, int from_tty,
a786 1
  bfd *abfd;
d789 3
d793 1
a793 1
  /* Open a bfd for the file, and give user a chance to burp if we'd be
a795 2
  abfd = symfile_bfd_open (name);

d803 1
d869 1
a869 1
      
d873 1
a873 1
      
d876 1
a876 1
  
d920 2
a921 1
  return symbol_file_add_with_addrs_or_offsets (name, from_tty, addrs, 0, 0, 
d933 1
a933 1
   
d991 1
a991 1
  
d998 1
a998 1
  
d1008 1
a1008 1
  
d1055 1
a1055 1
  
d1069 1
a1069 1
  
d1074 1
a1074 1
                      + strlen (basename) 
d1087 1
a1087 1
  
d1100 1
a1100 1
  
d1113 1
a1113 1
  
d1164 1
a1164 1
	      
d1426 1
a1426 1
		  struct cleanup *verify_cleanups = 
d1448 1
a1448 1
		show_load_progress (sect_name, sent, size, 
d1515 1
a1515 1
  bfd_map_over_sections (loadfile_bfd, add_section_size_callback, 
d1540 1
a1540 1
  print_transfer_performance (gdb_stdout, cbdata.data_count, 
d1556 1
a1556 1
  print_transfer_performance (gdb_stdout, data_count, 
d1569 1
a1569 1
      ui_out_field_fmt (uiout, "transfer-rate", "%lu", 
d1576 1
a1576 1
      ui_out_text (uiout, " bits in <1 sec");    
d1622 1
a1622 1
  sect_opts = (struct sect_opt *) xmalloc (num_sect_opts 
d1665 1
a1665 1
	    if (++section_index > num_sect_opts) 
d1668 1
a1668 1
		sect_opts = ((struct sect_opt *) 
d1670 1
a1670 1
				       num_sect_opts 
d1701 1
a1701 1
		      if (++section_index > num_sect_opts) 
d1704 1
a1704 1
			  sect_opts = ((struct sect_opt *) 
d1706 1
a1706 1
						 num_sect_opts 
d1722 1
a1722 1
 
d1731 1
a1731 1
 
d1739 1
a1739 1
		       sec, 
d1743 1
a1743 1
      /* The object's sections are initialized when a 
d1745 1
a1745 1
	 This happens in reread_symbols. 
d1771 81
d1931 1
a1931 1
	      offsets = ((struct section_offsets *) 
d1933 1
a1933 1
	      memcpy (offsets, objfile->section_offsets, 
d2000 1
a2000 1
		obstack_alloc (&objfile->objfile_obstack, 
d2002 1
a2002 1
	      memcpy (objfile->section_offsets, offsets, 
d2087 1
a2087 1
 
d2108 1
a2108 1
           (debug_file,
d2140 1
a2140 1
      filename_language_table = 
d2409 1
a2409 1
   has been blown away, but the other GDB data structures that may 
d2634 1
a2634 1
   Since one arg is a struct, we pass in a ptr and deref it (sigh).  
d2812 1
a2812 1
   3) This code provides a mechanism for gdb to keep track of which 
d2815 1
a2815 1
   For instance, if a section has been mapped then its contents 
d2839 1
a2839 1
   find_pc_overlay(pc):       find any overlay section that contains 
d2863 1
a2863 1
   Returns true if SECTION has VMA not equal to LMA, ie. 
d2894 1
a2894 1
   Returns true if section is an overlay, and is currently mapped. 
d2915 1
a2915 1
      /* Unles there is a target_overlay_update function, 
d3042 1
a3042 1
/* Function: symbol_overlayed_address 
d3069 1
a3069 1
/* Function: find_pc_overlay (PC) 
d3099 1
a3099 1
   If PC falls into the VMA address range of an overlay section that is 
d3207 1
a3207 1
   Mark the overlay section as unmapped 
d3301 4
a3304 4
   This is GDB's default target overlay layer.  It works with the 
   minimal overlay manager supplied as an example by Cygnus.  The 
   entry point is via a function pointer "target_overlay_update", 
   so targets that use a different runtime overlay manager can 
d3462 1
a3462 1
/* Function: simple_overlay_update_1 
d3499 3
a3501 3
   If OSECT is NULL, then update all sections' mapped state 
   (after re-reading the entire target _ovly_table). 
   If OSECT is non-NULL, then try to find a matching entry in the 
d3503 1
a3503 1
   If a cached entry can't be found or the cache isn't valid, then 
d3611 7
d3692 1
a3692 1
        "directory as the binary, then in the `" DEBUG_SUBDIRECTORY 
@


1.124
log
@2004-02-28  Andrew Cagney  <cagney@@redhat.com>

	* utils.c: Use "", instead of <>, to include readline.
	tui/tui-win.c, tui/tui.c, tui/tui-hooks.c: Ditto.
	* tracepoint.c, top.c, symmisc.c, symfile.c: Ditto.
	* source.c, solib.c, exec.c, event-top.c: Ditto.
	* corelow.c, completer.c, cli/cli-setshow.c: Ditto.
	* cli/cli-dump.c, cli/cli-cmds.c: Ditto.
	* Makefile.in: Update all dependencies.
	(readline_tilde_h, readline_history_h): Define.
	(readline_headers): Delete.
@
text
@a67 1
extern int hp_som_som_object_present;
d70 1
a70 1
                                    hp_som_som_object_present = 0;             /* indicates HP-compiled code */        \
@


1.124.6.1
log
@2004-03-23  Elena Zannoni  <ezannoni@@redhat.com>

       * solib-svr4.c (svr4_solib_create_inferior_hook): Disable
       breakpoints at startup.
       (elf_locate_base): Find out where the entry point for the program
       is, using the auxv vector, if possible. Compute the address of
       .dynamic using it.
       (svr4_current_sos): Don't ignore the first entry if we have PIE,
       it's our main program. Delete code that was skipping over the
       solib entry for main executable.
       * solist.h (struct so_list): Add fields main and main_relocated.
        (add_to_target_sections): Export.
       * solib.c (symbol_add_stub): Handle main executable in shared
       library list. Ignore it if it has been relocated already. Add it
       as the main symbol file, otherwise.
       * infrun.c (handle_inferior_event): Re-enable startup breakpoints.

       * solib-svr4.c (elf_locate_base, first_link_map_member)
       svr4_current_sos, enable_break): Add debugging output.
       * solist.h (debug_solib): Export.
       * solib.c (debug_solib): New variable to enable debugging output.
       (symbol_add_stub, update_solib_list, update_solib_list)
       (add_to_target_sections): Add debugging output.
       (_initialize_solib): Add new comand to enable printing of
       debugging output.
       (add_to_target_sections): New function. Factored out from
       update_solib_list.
       (update_solib_list): Call add_to_target_sections.

       * varobj.h (varobj_refresh): New prototype.
       * varobj.c (varobj_refresh): New function.
       * symfile.c (reread_symbols): Make sure that we recompute the
       entry point for the program.
       (symbol_file_clear): Clear the solibs as well, if we change symbol
       files.
       (clear_symtab_users): Refresh the varobjs that depend on the symtabs
       we are clearing.
       * objfiles.c (entry_point_address): Rewrite, to fetch entry point
       from auxv vector, if possible.
       Add include of elf/common.h.
       * breakpoint.h (enum bptype): Add bp type bp_startup_disabled.
       (re_enable_breakpoints_at_startup)
       (disable_breakpoints_at_startup): Add prototypes
       * breakpoint.c (re_enable_breakpoints_at_startup)
       (disable_breakpoints_at_startup): New functions.
       (describe_other_breakpoints, delete_breakpoint)
       (breakpoint_re_set_one): Handle new bp type.
       * auxv.h (target_auxv_parse, target_auxv_search): Update.
       * auxv.c (target_auxv_parse, target_auxv_search)
       (fprint_target_auxv): Use ULONGEST instead of CORE_ADDR for
       variable. Change variable name to at_type.
@
text
@a50 1
#include "varobj.h"
d576 1
a576 1
  if (/*!mainline &&*/ addrs && addrs->other[0].name)
a962 4
#ifdef CLEAR_SOLIB
      CLEAR_SOLIB ();
#endif

a1959 2
	      init_entry_point_info (objfile);

a2314 1
  varobj_refresh();
@


1.123
log
@2004-02-15  Andrew Cagney  <cagney@@redhat.com>

	* solib.c (solib_map_sections): Use bfd_set_cacheable instead of
	poking .cacheable directly.
	* symfile.c (symfile_bfd_open): Ditto.
@
text
@d48 1
a48 1
#include <readline/readline.h>
@


1.123.2.1
log
@Merge mainline to intercu branch.
@
text
@d48 1
a48 1
#include "readline/readline.h"
@


1.123.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d63 18
a80 5
int (*deprecated_ui_load_progress_hook) (const char *section, unsigned long num);
void (*deprecated_show_load_progress) (const char *section,
			    unsigned long section_sent,
			    unsigned long section_size,
			    unsigned long total_sent,
d82 3
a84 3
void (*deprecated_pre_add_symbol_hook) (const char *);
void (*deprecated_post_add_symbol_hook) (void);
void (*deprecated_target_new_objfile_hook) (struct objfile *);
d211 2
a212 2
  return strcmp_iw_ordered (SYMBOL_SEARCH_NAME (*s1),
			    SYMBOL_SEARCH_NAME (*s2));
d297 2
a298 2
/* Remember the lowest-addressed loadable section we've seen.
   This function is called via bfd_map_over_sections.
a339 26

/* Return a freshly allocated copy of ADDRS.  The section names, if
   any, are also freshly allocated copies of those in ADDRS.  */
struct section_addr_info *
copy_section_addr_info (struct section_addr_info *addrs)
{
  struct section_addr_info *copy
    = alloc_section_addr_info (addrs->num_sections);
  int i;

  copy->num_sections = addrs->num_sections;
  for (i = 0; i < addrs->num_sections; i++)
    {
      copy->other[i].addr = addrs->other[i].addr;
      if (addrs->other[i].name)
        copy->other[i].name = xstrdup (addrs->other[i].name);
      else
        copy->other[i].name = NULL;
      copy->other[i].sectindex = addrs->other[i].sectindex;
    }

  return copy;
}



d355 1
a355 1
      if (bfd_get_section_flags (stp->bfd,
d360 1
a360 1
	  sap->other[oidx].name
d391 1
a391 1

d393 1
a393 1
  if (sect)
d397 1
a397 1
  if (sect)
d401 1
a401 1
  if (sect)
d405 1
a405 1
  if (sect)
d440 1
a440 1
   of how to represent it for fast symbol reading.  This is the default
d453 1
a453 1
    obstack_alloc (&objfile->objfile_obstack,
d455 1
a455 1
  memset (objfile->section_offsets, 0,
d540 1
a540 1
      local_addr
d583 1
a583 1
      /* Find lowest loadable section to be used as starting point for
d593 1
a593 1
      else
d603 1
a603 1

d607 1
a607 1

d631 1
a631 1
                             addrs->other[i].name,
d687 2
a688 2
 	/* Map section offsets in "addr" back to the object's
 	   sections by comparing the section names with bfd's
d691 1
a691 1

d697 1
a697 1
 	    for (i = 0;
d700 2
a701 2
 	      if (strcmp (bfd_section_name (s->objfile->obfd,
					    s->the_bfd_section),
d704 1
a704 1

d764 2
a765 2
   ABFD is a BFD already open on the file, as from symfile_bfd_open.
   This BFD will be closed on error, and is always consumed by this function.
d779 1
a779 1
symbol_file_add_with_addrs_or_offsets (bfd *abfd, int from_tty,
d788 2
a789 1
  struct section_addr_info *orig_addrs = NULL;
a790 1
  const char *name = bfd_get_filename (abfd);
d792 2
a793 1
  my_cleanups = make_cleanup_bfd_close (abfd);
d795 1
a795 2
  /* Give user a chance to burp if we'd be
     interactively wiping out any existing symbols.  */
a803 1
  discard_cleanups (my_cleanups);
d805 2
d809 4
a812 2
      orig_addrs = copy_section_addr_info (addrs);
      make_cleanup_free_section_addr_info (orig_addrs);
d820 2
a821 2
      if (deprecated_pre_add_symbol_hook)
	deprecated_pre_add_symbol_hook (name);
d869 1
a869 1

d873 1
a873 1

d876 1
a876 1

d880 1
a880 5
      printf_filtered ("(no debugging symbols found)");
      if (from_tty || info_verbose)
        printf_filtered ("...");
      else
        printf_filtered ("\n");
d886 2
a887 2
      if (deprecated_post_add_symbol_hook)
	deprecated_post_add_symbol_hook ();
d906 2
a907 2
  if (deprecated_target_new_objfile_hook)
    deprecated_target_new_objfile_hook (objfile);
a908 1
  bfd_cache_close_all ();
a912 16
/* Process the symbol file ABFD, as either the main file or as a
   dynamically loaded file.

   See symbol_file_add_with_addrs_or_offsets's comments for
   details.  */
struct objfile *
symbol_file_add_from_bfd (bfd *abfd, int from_tty,
                          struct section_addr_info *addrs,
                          int mainline, int flags)
{
  return symbol_file_add_with_addrs_or_offsets (abfd,
						from_tty, addrs, 0, 0,
                                                mainline, flags);
}


d920 2
a921 2
  return symbol_file_add_from_bfd (symfile_bfd_open (name), from_tty,
                                   addrs, mainline, flags);
d932 1
a932 1

d944 4
d976 3
d990 1
a990 1

d997 1
a997 1

d1007 1
a1007 1

d1054 1
a1054 1

d1068 1
a1068 1

d1073 1
a1073 1
                      + strlen (basename)
d1086 1
a1086 1

d1099 1
a1099 1

d1112 1
a1112 1

d1163 1
a1163 1

d1227 1
a1227 2
  desc = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, name, O_RDONLY | O_BINARY,
		0, &absolute_name);
d1233 2
a1234 2
      desc = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, exename,
		    O_RDONLY | O_BINARY, 0, &absolute_name);
d1356 1
a1356 1
  *sum += bfd_get_section_size (asec);
d1376 1
a1376 1
      bfd_size_type size = bfd_get_section_size (asec);
d1425 1
a1425 1
		  struct cleanup *verify_cleanups =
d1442 2
a1443 2
		  || (deprecated_ui_load_progress_hook != NULL
		      && deprecated_ui_load_progress_hook (sect_name, sent)))
d1446 3
a1448 4
	      if (deprecated_show_load_progress != NULL)
		deprecated_show_load_progress (sect_name, sent, size,
					       args->data_count,
					       args->total_size);
d1514 1
a1514 1
  bfd_map_over_sections (loadfile_bfd, add_section_size_callback,
d1537 1
a1537 1
     others don't (or didn't - perhaps they have all been deleted).  */
d1539 1
a1539 1
  print_transfer_performance (gdb_stdout, cbdata.data_count,
d1555 1
a1555 1
  print_transfer_performance (gdb_stdout, data_count,
d1568 1
a1568 1
      ui_out_field_fmt (uiout, "transfer-rate", "%lu",
d1575 1
a1575 1
      ui_out_text (uiout, " bits in <1 sec");
d1621 1
a1621 1
  sect_opts = (struct sect_opt *) xmalloc (num_sect_opts
d1664 1
a1664 1
	    if (++section_index > num_sect_opts)
d1667 1
a1667 1
		sect_opts = ((struct sect_opt *)
d1669 1
a1669 1
				       num_sect_opts
d1700 1
a1700 1
		      if (++section_index > num_sect_opts)
d1703 1
a1703 1
			  sect_opts = ((struct sect_opt *)
d1705 1
a1705 1
						 num_sect_opts
d1719 1
a1719 1
     statements because hex_string returns a local static
d1721 1
a1721 1

d1730 1
a1730 1

d1738 2
a1739 1
		       sec, hex_string ((unsigned long)addr));
d1742 1
a1742 1
      /* The object's sections are initialized when a
d1744 1
a1744 1
	 This happens in reread_symbols.
d1849 1
a1849 1
	      offsets = ((struct section_offsets *)
d1851 1
a1851 1
	      memcpy (offsets, objfile->section_offsets,
d1861 1
a1861 1
		xfree (objfile->global_psymbols.list);
d1865 1
a1865 1
		xfree (objfile->static_psymbols.list);
d1918 1
a1918 1
		obstack_alloc (&objfile->objfile_obstack,
d1920 1
a1920 1
	      memcpy (objfile->section_offsets, offsets,
d1930 3
d2005 1
a2005 1

d2026 1
a2026 1
           (symfile_bfd_open (debug_file),
d2058 1
a2058 1
      filename_language_table =
d2313 2
a2314 2
  if (deprecated_target_new_objfile_hook)
    deprecated_target_new_objfile_hook (NULL);
d2327 1
a2327 1
   has been blown away, but the other GDB data structures that may
d2552 1
a2552 1
   Since one arg is a struct, we pass in a ptr and deref it (sigh).
d2692 1
a2692 1
      xfree (objfile->global_psymbols.list);
d2696 1
a2696 1
      xfree (objfile->static_psymbols.list);
d2710 2
a2711 2
	xmalloc ((objfile->global_psymbols.size
		  * sizeof (struct partial_symbol *)));
d2717 2
a2718 2
	xmalloc ((objfile->static_psymbols.size
		  * sizeof (struct partial_symbol *)));
d2730 1
a2730 1
   3) This code provides a mechanism for gdb to keep track of which
d2733 1
a2733 1
   For instance, if a section has been mapped then its contents
d2757 1
a2757 1
   find_pc_overlay(pc):       find any overlay section that contains
d2781 1
a2781 1
   Returns true if SECTION has VMA not equal to LMA, ie.
d2812 1
a2812 1
   Returns true if section is an overlay, and is currently mapped.
d2833 1
a2833 1
      /* Unles there is a target_overlay_update function,
d2882 1
a2882 1
	size = bfd_get_section_size (section);
d2902 1
a2902 1
	size = bfd_get_section_size (section);
d2918 1
a2918 1
  CORE_ADDR a_end = a->vma + bfd_get_section_size (a);
d2920 1
a2920 1
  CORE_ADDR b_end = b->vma + bfd_get_section_size (b);
d2960 1
a2960 1
/* Function: symbol_overlayed_address
d2987 1
a2987 1
/* Function: find_pc_overlay (PC)
d3017 1
a3017 1
   If PC falls into the VMA address range of an overlay section that is
d3055 1
a3055 1
	size = bfd_get_section_size (osect->the_bfd_section);
d3125 1
a3125 1
   Mark the overlay section as unmapped
d3219 4
a3222 4
   This is GDB's default target overlay layer.  It works with the
   minimal overlay manager supplied as an example by Cygnus.  The
   entry point is via a function pointer "target_overlay_update",
   so targets that use a different runtime overlay manager can
d3380 1
a3380 1
/* Function: simple_overlay_update_1
d3395 1
a3395 1
  size = bfd_get_section_size (osect->the_bfd_section);
d3417 3
a3419 3
   If OSECT is NULL, then update all sections' mapped state
   (after re-reading the entire target _ovly_table).
   If OSECT is non-NULL, then try to find a matching entry in the
d3421 1
a3421 1
   If a cached entry can't be found or the cache isn't valid, then
d3456 1
a3456 1
      size = bfd_get_section_size (bsect);
d3541 1
a3541 1
  deprecated_add_show_from_set
d3585 1
a3585 1
  deprecated_add_show_from_set
d3603 1
a3603 1
        "directory as the binary, then in the `" DEBUG_SUBDIRECTORY
d3608 1
a3608 1
  deprecated_add_show_from_set (c, &showlist);
@


1.122
log
@2004-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (init_entry_point_info, entry_point_address): Move
	from here...
	* objfiles.c (init_entry_point_info, entry_point_address):..to
	here.
	* symfile.h (init_entry_point_info, entry_point_address): Remove
	prototypes.
	* objfiles.h (init_entry_point_info, entry_point_address):Add
	prototypes.
	* cris-tdep.c: Remove include of symfile.h. Add include of
	objfiles.h.
	* infcall.c: Ditto.
	* mcore-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
 	* v850-tdep.c: Ditto.
	* arm-tdep.c: Remove include of symfile.h.
	* blockframe.c: Ditto.
	* coffread.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* frv-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* mipsread.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* s390-tdep.c: Ditto.
	* sh-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* gdbarch.sh: Remove include of symfile.h.
	* gdbarch.c: Regenerate.
	* solib-irix.c (enable_break): Use entry_point_address().
	Add comment about include file.
	* xcoffread.c: Add comment about include file.
	* Makefile.in (arm-tdep.o, blockframe.o, coffread.o, cris-tdep.o)
	(dbxread.o, dwarf2read.o, dwarfread.o, frv-tdep.o, gdbarch.o)
	(ia64-tdep.o, infcall.o, mcore-tdep.o, mdebugread.o, mipsread.o)
	(mn10300-tdep.o, rs6000-nat.o, s390-tdep.o, sh64-tdep.o)
	(sh-tdep.o, v850-tdep.o, xstormy16-tdep.o): Update dependencies.
@
text
@d1254 1
a1254 1
  sym_bfd->cacheable = 1;
@


1.121
log
@2004-02-09  Elena Zannoni  <ezannoni@@redhat.com>

	* bcache.c (bcache_xmalloc): Use obstack_init instead of
	obstack_specify_allocation.
	* objfiles.c (allocate_objfile): Ditto.
	* solib-sunos.c (solib_add_common_symbols)
	(allocate_rt_common_objfile): Ditto.
	* symfile.c (reread_symbols): Ditto.
	* gdb_obstack.h: Add comment.
@
text
@a296 35
/* Initialize entry point information for this objfile. */

void
init_entry_point_info (struct objfile *objfile)
{
  /* Save startup file's range of PC addresses to help blockframe.c
     decide where the bottom of the stack is.  */

  if (bfd_get_file_flags (objfile->obfd) & EXEC_P)
    {
      /* Executable file -- record its entry point so we'll recognize
         the startup file because it contains the entry point.  */
      objfile->ei.entry_point = bfd_get_start_address (objfile->obfd);
    }
  else
    {
      /* Examination of non-executable.o files.  Short-circuit this stuff.  */
      objfile->ei.entry_point = INVALID_ENTRY_POINT;
    }
  objfile->ei.deprecated_entry_file_lowpc = INVALID_ENTRY_LOWPC;
  objfile->ei.deprecated_entry_file_highpc = INVALID_ENTRY_HIGHPC;
  objfile->ei.entry_func_lowpc = INVALID_ENTRY_LOWPC;
  objfile->ei.entry_func_highpc = INVALID_ENTRY_HIGHPC;
  objfile->ei.main_func_lowpc = INVALID_ENTRY_LOWPC;
  objfile->ei.main_func_highpc = INVALID_ENTRY_HIGHPC;
}

/* Get current entry point address.  */

CORE_ADDR
entry_point_address (void)
{
  return symfile_objfile ? symfile_objfile->ei.entry_point : 0;
}

@


1.120
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* buildsym.c (free_pending_blocks, finish_block)
	(record_pending_block, make_blockvector, end_symtab): Replace
	symbol_obstack with objfile_obstack.
	* coffread.c (process_coff_symbol, coff_read_struct_type)
	(coff_read_enum_type): Ditto.
	* cp-namespace.c (initialize_namespace_symtab)
	(check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol, dwarf2_const_value, macro_start_file)
	(dwarf2_symbol_mark_computed): Ditto.
	* dwarfread.c (enum_type, new_symbol, synthesize_typedef): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* hpread.c (hpread_symfile_init, hpread_symfile_init)
	(hpread_read_enum_type, hpread_read_function_type)
	(hpread_read_doc_function_type, hpread_process_one_debug_symbol):
	Ditto.
	* jv-lang.c (get_java_class_symtab, add_class_symbol)
	(java_link_class_type): Ditto.
	* mdebugread.c (parse_symbol, psymtab_to_symtab_1, new_symtab)
	(new_symbol): Ditto.
	* minsyms.c (install_minimal_symbols): Ditto.
	* objfiles.c (allocate_objfile): Remove init of symbol_obstack.
	(terminate_minimal_symbol_table): Replace symbol_obstack with
	objfile_obstack.
	(free_objfile): Remove freeing of symbol_obstack.
	* objfiles.h: Remove symbol_obstack field.
	* pa64solib.c (add_to_solist): Replace symbol_obstack with
	objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
	symbol_obstack.
	(solib_add_common_symbols): Replace symbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add): Ditto.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_start, common_block_end): Ditto.
	* symfile.c (reread_symbols): Remove freeing and init of
	symbol_obstack.
	(allocate_symtab): Rename symbol_obstack to objfile_obstack.
	* symfile.h: Update comment.
	* symmisc.c (print_objfile_statistics): Remove symbol_obstack
	stats printing.
	* symtab.c (symbol_set_names): Replace symbol_obstack with
	objfile_obstack.
	* symtab.h (struct general_symbol_info, struct minimal_symbol):
	Update comments.
	* xcoffread.c (read_xcoff_symtab, SYMBOL_DUP, SYMNAME_ALLOC)
	(init_stringtab, xcoff_initial_scan): Replace symbol_obstack with
	objfile_obstack.
@
text
@a1935 2
	      /* obstack_specify_allocation also initializes the obstack so
	         it is empty.  */
d1938 5
a1942 2
	      obstack_specify_allocation (&objfile->objfile_obstack, 0, 0,
					  xmalloc, xfree);
@


1.119
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (dbx_symfile_init, start_psymtab, end_psymtab,
	coffstab_build_psymtabs, elfstab_build_psymtabs)
	(stabsect_build_psymtabs): Replace psymbol_obstack with
	objfile_obstack.
	* dwarf2-frame.c (decode_frame_entry_1): Ditto.
	* dwarf2read.c (dwarf2_build_psymtabs_hard, dwarf2_read_section):
	Ditto.
	* dwarfread.c (scan_compilation_units): Ditto.
	* elfread.c (elfstab_offset_sections): Ditto.
	* hppa-tdep.c (read_unwind_info): Ditto.
	* hpread.c (hpread_build_psymtabs, hpread_start_psymtab)
	(hpread_end_psymtab): Ditto.
	* mdebugread.c (mdebug_build_psymtabs, add_pending)
	(parse_partial_symbols, new_psymtab, elfmdebug_build_psymtabs):
	Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* objfiles.c (add_to_objfile_sections)
	(build_objfile_section_table): Ditto.
	(allocate_objfile): Remove init of psymbol_obstack.
	(free_objfile): Remove freeing of psymbol_obstack.
	* objfiles.h (struct objfile): Remove field
	psymbol_obstack. Update comments.
	* pa64solib.c (pa64_solib_add_solib_objfile): Replace
	psymbol_obstack with objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
        psymbol_obstack.
	* somread.c (som_symfile_offsets, init_import_symbols)
	(init_export_symbols): Replace psymbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
	* symfile.c (default_symfile_offsets, syms_from_objfile)
	(reread_symbols): Remove freeing and init of psymbol_obstack.
	(cashier_psymtab): Update comment.
	* symmisc.c (print_objfile_statistics): Don't report stats for
	psymbol obstack.
	* symtab.h (struct general_symbol_info, struct partial_symtab):
	Update comments.
	* xcoffread.c (xcoff_start_psymtab, xcoff_end_psymtab, swap_sym)
	(xcoff_symfile_offsets): Replace psymbol_obstack with
	objfile_obstack.
@
text
@a1914 1
	      obstack_free (&objfile->symbol_obstack, 0);
a1941 2
	      obstack_specify_allocation (&objfile->symbol_obstack, 0, 0,
					  xmalloc, xfree);
d2238 1
a2238 1
    obstack_alloc (&objfile->symbol_obstack, sizeof (struct symtab));
d2241 1
a2241 1
				   &objfile->symbol_obstack);
d2245 1
a2245 1
				      &objfile->symbol_obstack);
@


1.118
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

        * objfiles.h (struct objfile): Add objfile_obstack field.
        Remove type_obstack field.

        * dwarf2read.c (dwarf2_add_field,dwarf2_add_member_fn,
        read_structure_scope read_enumeration, new_symbol): Replace
        type_obstack with objfile_obstack.
        * dwarfread.c (struct_type, enum_type): Ditto.
        * gdbtypes.c (alloc_type, alloc_type_instance, init_type)
        (lookup_fundamental_type): Ditto.
        * gdbtypes.h (TYPE_ALLOC): Ditto.
        * hpread.c (hpread_read_enum_type, hpread_read_function_type)
        (hpread_read_doc_function_type, hpread_read_struct_type)
        (fix_static_member_physnames, hpread_read_array_type)
        (hpread_read_subrange_type, hpread_type_lookup): Ditto.
        * jv-lang.c (java_lookup_class, type_from_class, type_from_class)
        (java_link_class_type): Ditto.
        * mdebugread.c (parse_type): Ditto.
        * objfiles.c (allocate_objfile, free_objfile): Ditto.
        * solib-sunos.c (solib_add_common_symbols): Ditto.
        * stabsread.c (define_symbol, read_type, read_member_functions,
        read_cpp_abbrev, read_one_struct_field): Ditto.
        * symfile.c (reread_symbols): Ditto.
        * symmisc.c (print_objfile_statistics): Ditto.
@
text
@d488 1
a488 1
    obstack_alloc (&objfile->psymbol_obstack, 
d693 1
a693 1
           obstack_alloc (&objfile->psymbol_obstack, size));
d1882 1
a1882 1
	         psymbol_obstack.  */
d1914 1
a1914 1
	      obstack_free (&objfile->psymbol_obstack, 0);
a1915 1
	      obstack_free (&objfile->objfile_obstack, 0);
d1941 1
a1941 1
	      obstack_specify_allocation (&objfile->psymbol_obstack, 0, 0,
a1944 2
	      obstack_specify_allocation (&objfile->objfile_obstack, 0, 0,
					  xmalloc, xfree);
d1955 1
a1955 1
		obstack_alloc (&objfile->psymbol_obstack, 
d2279 1
a2279 1
      obstack_alloc (&objfile->psymbol_obstack,
d2284 1
a2284 1
				    &objfile->psymbol_obstack);
d2433 1
a2433 1
         filename, which are all in the psymbol_obstack.  */
@


1.117
log
@2004-01-23  David Carlton  <carlton@@kealia.com>

	* symfile.c (reread_symbols): Clear objfile->cp_namespace_symtab.
	Fix for PR symtab/1534.
@
text
@d1916 1
a1916 1
	      obstack_free (&objfile->type_obstack, 0);
d1946 1
a1946 1
	      obstack_specify_allocation (&objfile->type_obstack, 0, 0,
@


1.116
log
@2004-01-19  Andrew Cagney  <cagney@@redhat.com>

	* top.h (mapped_symbol_files): Delete declaration.
	* main.c (captured_main): Delete option "m" and "mapped".
	* objfiles.c (mapped_symbol_files): Delete variable.
	* symfile.c (symbol_file_command): Delete mmap code.
	(symbol_file_add_with_addrs_or_offsets): Ditto.
	(add_symbol_file_command, reread_separate_symbols): Ditto.
	* objfiles.h (OBJF_MAPPED): Delete.
	* objfiles.c (allocate_objfile) [USE_MMALLOC]: Delete.
	(free_objfile) [USE_MMALLOC]: Ditto.
	(open_existing_mapped_file): Delete function.
	(open_mapped_file): Delete function.
	(map_to_file): Delete function.
@
text
@d1921 1
@


1.115
log
@2004-01-16  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c: Update copyright year.
	(compare_symbols): Delete unused function.
	* stabsread.c: Update copyright year.
	(lrs_general_complaint): Delete unused function.
	(ref_search_value): Ditto.
	(get_substring): Delete declaration.
	* sh64-tdep.c: Update copyright year.
	(sh64_get_gdb_regnum): Delete unused function.
	* dwarf2read.c (dwarf2_unsupported_at_frame_base_complaint):
	Delete unused function.
@
text
@d850 4
a853 4
  /* If the objfile uses a mapped symbol file, and we have a psymtab for
     it, then skip reading any symbols at this time. */

  if ((objfile->flags & OBJF_MAPPED) && (objfile->flags & OBJF_SYMS))
d855 3
a857 5
      /* We mapped in an existing symbol table file that already has had
         initial symbol reading performed, so we can skip that part.  Notify
         the user that instead of reading the symbols, they have been mapped.
       */
      if (from_tty || info_verbose)
d859 1
a859 1
	  printf_unfiltered ("Mapped symbols for %s...", name);
a862 21
      init_entry_point_info (objfile);
      find_sym_fns (objfile);
    }
  else
    {
      /* We either created a new mapped symbol table, mapped an existing
         symbol table file which has not had initial symbol reading
         performed, or need to read an unmapped symbol table. */
      if (from_tty || info_verbose)
	{
	  if (pre_add_symbol_hook)
	    pre_add_symbol_hook (name);
	  else
	    {
	      printf_unfiltered ("Reading symbols from %s...", name);
	      wrap_here ("");
	      gdb_flush (gdb_stdout);
	    }
	}
      syms_from_objfile (objfile, addrs, offsets, num_offsets,
                         mainline, from_tty);
d864 2
d1191 10
a1200 14
	  if (strcmp (*argv, "-mapped") == 0)
	    flags |= OBJF_MAPPED;
	  else 
	    if (strcmp (*argv, "-readnow") == 0)
	      flags |= OBJF_READNOW;
	    else 
	      if (**argv == '-')
		error ("unknown option `%s'", *argv);
	      else
		{
                  name = *argv;

		  symbol_file_add_main_1 (name, from_tty, flags);
		}
d1715 7
a1721 11
		if (strcmp (arg, "-mapped") == 0)
		  flags |= OBJF_MAPPED;
		else 
		  if (strcmp (arg, "-readnow") == 0)
		    flags |= OBJF_READNOW;
		  else 
		    if (strcmp (arg, "-s") == 0)
		      {
			expecting_sec_name = 1;
			expecting_sec_addr = 1;
		      }
d2070 1
a2070 2
            objfile->flags & (OBJF_MAPPED | OBJF_REORDERED
                              | OBJF_SHARED | OBJF_READNOW
@


1.114
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* elfread.c (elf_symtab_read): Delete STREQ from comment.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a200 14

/* Since this function is called from within qsort, in an ANSI environment
   it must conform to the prototype for qsort, which specifies that the
   comparison function takes two "void *" pointers. */

static int
compare_symbols (const void *s1p, const void *s2p)
{
  struct symbol **s1, **s2;

  s1 = (struct symbol **) s1p;
  s2 = (struct symbol **) s2p;
  return (strcmp (SYMBOL_NATURAL_NAME (*s1), SYMBOL_NATURAL_NAME (*s2)));
}
@


1.113
log
@2003-11-15  Andrew Cagney  <cagney@@redhat.com>

	* bcache.h (deprecated_bcache): Declare.
	(bcache): Make returned buffer constant.
	* bcache.c (deprecated_bcache): New function.
	(bcache_data): New function.
	(bcache): Call bcache data.
	* symfile.c (add_psymbol_to_list): Use deprecated_bcache.
	(add_psymbol_with_dem_name_to_list): Ditto.
@
text
@d1229 1
a1229 1
	    if (STREQ (*argv, "-readnow"))
@


1.112
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@d2683 2
a2684 1
  psym = bcache (&psymbol, sizeof (struct partial_symbol), objfile->psymbol_cache);
d2721 2
a2722 1
  DEPRECATED_SYMBOL_NAME (&psymbol) = bcache (buf, namelength + 1, objfile->psymbol_cache);
d2733 1
a2733 1
	bcache (buf, dem_namelength + 1, objfile->psymbol_cache);
d2754 2
a2755 1
  psym = bcache (&psymbol, sizeof (struct partial_symbol), objfile->psymbol_cache);
@


1.111
log
@* objfiles.h (clear_objfile_data): New prototype.
* objfiles.c (clear_objfile_data): New function.
* symfile.c (reread_symbols): Clear per-objfile data.
@
text
@d1226 1
a1226 1
	  if (STREQ (*argv, "-mapped"))
d2542 1
a2542 1
      if (STREQ (name, ps->filename))
d2553 1
a2553 1
      if (STREQ (name, s->filename))
@


1.110
log
@
2003-10-28  Jeff Johnston  <jjohnstn@@redhat.com>

        * symfile.c (symbol_file_add_with_addrs_or_offsets): Switch to use
        printf_unfiltered instead of printf_filtered for output messages.
        (add_symbol_file_command): Ditto.
        (reread_symbols): Ditto.
        (overlay_auto_command): Ditto.
        (overlay_manual_command): Ditto.
        (overlay_off_command): Ditto.
@
text
@d1972 1
@


1.109
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d875 1
a875 1
	  printf_filtered ("Mapped symbols for %s...", name);
d893 1
a893 1
	      printf_filtered ("Reading symbols from %s...", name);
d911 1
a911 1
	  printf_filtered ("expanding to full symbols...");
d950 1
a950 1
      printf_filtered ("(no debugging symbols found)...");
d960 1
a960 1
	  printf_filtered ("done.\n");
d1800 1
a1800 1
  printf_filtered ("add symbol table from file \"%s\" at\n", filename);
d1815 1
a1815 1
      printf_filtered ("\t%s_addr = %s\n",
d1880 1
a1880 1
	      printf_filtered ("`%s' has disappeared; keeping its symbols.\n",
d1892 1
a1892 1
	      printf_filtered ("`%s' has changed; re-reading symbols.\n",
d2025 1
a2025 1
		  printf_filtered ("(no debugging symbols found)\n");
d3193 1
a3193 1
	    printf_filtered ("Note: section %s unmapped by overlap\n",
d3243 1
a3243 1
    printf_filtered ("Automatic overlay debugging enabled.");
d3256 1
a3256 1
    printf_filtered ("Overlay debugging enabled.");
d3269 1
a3269 1
    printf_filtered ("Overlay debugging disabled.");
@


1.108
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@a1668 1
/* ARGSUSED */
@


1.107
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d252 2
a253 2
    register const char *p1 = ptr;
    register char *p2 = p;
d293 1
a293 1
psymtab_to_symtab (register struct partial_symtab *pst)
@


1.106
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d209 1
a209 1
  register struct symbol **s1, **s2;
d247 1
a247 1
  register char *p = (char *) obstack_alloc (obstackp, size + 1);
d269 2
a270 2
  register int len = strlen (s1) + strlen (s2) + strlen (s3) + 1;
  register char *val = (char *) obstack_alloc (obstackp, len);
d2284 1
a2284 1
  register struct symtab *symtab;
d2523 3
a2525 3
  register struct symtab *s;
  register struct symtab *prev;
  register struct partial_symtab *ps;
d2656 1
a2656 1
  register struct partial_symbol *psym;
d2709 1
a2709 1
  register struct partial_symbol *psym;
@


1.105
log
@2003-09-11  David Carlton  <carlton@@kealia.com>

	* gdbtypes.h: Add TYPE_CODE_NAMESPACE.
	* gdbtypes.c (init_type): Handle TYPE_CODE_NAMESPACE.
	(recursive_dump_type): Ditto.
	* printcmd.c (print_formatted): Ditto.
	* typeprint.c (print_type_scalar): Ditto.
	* c-typeprint.c (c_type_print_varspec_prefix): Ditto.
	(c_type_print_varspec_suffix, c_type_print_base): Ditto.
	* cp-support.h: Declare cp_check_possible_namespace_symbols,
	maint_cplus_cmd_list.
	* cp-support.c: Make maint_cplus_cmd_list extern.
	* cp-namespace.c: Include objfiles.h, gdbtypes.h, dictionary.h,
	command.h.
	(lookup_symbol_file): Look in possible namespace blocks when
	appropriate.
	(initialize_namespace_symtab): New.
	(get_possible_namespace_block, free_namespace_block)
	(check_possible_namespace_symbols)
	(check_possible_namespace_symbols_loop)
	(check_one_possible_namespace_symbol)
	(lookup_possible_namespace_symbol, maintenance_cplus_namespace)
	(_initialize_cp_namespace): Ditto.
	* block.h: Declare allocate_block.
	* block.c (allocate_block): New.
	* jv-lang.c (get_java_class_symtab): Allocate blocks via
	allocate_block.
	* symfile.h: Update declaration of add_psymbol_to_list.
	* symfile.c (add_psymbol_to_list): Return the partial symbol in
	question.
	* dwarf2read.c (dwarf2_build_psymtabs_hard): Add argument to
	scan_partial_symbols_call.
	(scan_partial_symbols): Add NAMESPACE argument; update calls to
	helper functions.
	(add_partial_symbol): If necessary, scan mangled names for names
	of namespaces.
	(add_partial_namespace): Add NAMESPACE argument; generate partial
	symbols associated  to namespaces.
	(add_partial_enumeration): Add NAMESPACE argument.
	(new_symbol): Allow namespace syms.
	(read_namespace): Generate namespace syms.
	* objfiles.h: Add opaque declaration of struct symtab.
	(struct objfile): Add cp_namespace_symtab member.
	* objfiles.c (allocate_objfile): Set
	objfile->cp_namespace_symtab.
	* Makefile.in (cp-namespace.o): Depend on objfiles_h, gdbtypes_h,
	dictionary_h, command_h.

2003-09-11  David Carlton  <carlton@@kealia.com>

	* gdb.c++/namespace.exp: Add tests for namespace types.
	* gdb.c++/maint.exp (test_help): Test 'help maint cp namespace'.
	(test_namespace): New.
@
text
@d330 2
a331 2
  objfile->ei.entry_file_lowpc = INVALID_ENTRY_LOWPC;
  objfile->ei.entry_file_highpc = INVALID_ENTRY_HIGHPC;
@


1.104
log
@2003-09-11  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (symbol_file_add_with_addrs_or_offsets): Make sure
	orig_addrs is set up properly.
@
text
@d2635 2
a2636 1
   Since one arg is a struct, we pass in a ptr and deref it (sigh).  */
d2638 12
a2649 1
void
d2692 2
@


1.103
log
@2003-09-03  Andrew Cagney  <cagney@@redhat.com>

	* config/rs6000/tm-rs6000.h (IBM6000_TARGET): Delete definition.
	* config/rs6000/nm-rs6000.h (DEPRECATED_IBM6000_TARGET): Define.
	* symfile.c (syms_from_objfile): Update.
	(reread_symbols): `Update
	* exec.c (exec_file_attach): Update.
	(exec_file_attach): Update.
	* config/powerpc/tm-nbsd.h: Delete #undef IBM6000_TARGET, revert
	2003-08-29 change.
	* config/powerpc/tm-linux.h: Delete #undef IBM6000_TARGET.
@
text
@d857 6
a862 1
    *orig_addrs = *addrs;
@


1.102
log
@2003-08-17  Michael Chastain  <mec@@shout.net>

	* symfile.c (find_sym_fns): Remove special case for apollo target.
@
text
@d713 1
a713 1
#ifndef IBM6000_TARGET
d761 1
a761 1
#endif /* not IBM6000_TARGET */
d1864 1
a1864 1
#ifdef IBM6000_TARGET
@


1.101
log
@2003-06-27  Elena Zannoni  <ezannoni@@redhat.com>

        * symfile.c (syms_from_objfile): Move variables to inner block.
        Move the checks for the non-mainline case a bit earlier to avoid
        doing some useless computations.
@
text
@a1379 4
  /* Special kludge for apollo.  See dstread.c.  */
  if (STREQN (our_target, "apollo", 6))
    our_flavour = (enum bfd_flavour) -2;

@


1.100
log
@	* symfile.c (add_symbol_file_command): Use parse_and_eval_address.
	Suggested by Nick Hibma <n_hibma@@webweaving.org>.
@
text
@a568 3
  asection *lower_sect;
  asection *sect;
  CORE_ADDR lower_offset;
a570 1
  int i;
d625 1
a625 1
  if (!mainline)
d627 5
d663 1
a663 3
      /* Calculate offsets for sections. */
      if (addrs)
        for (i=0 ; i < addrs->num_sections && addrs->other[i].name; i++)
@


1.100.2.1
log
@2003-06-27  Elena Zannoni  <ezannoni@@redhat.com>

        * symfile.c (syms_from_objfile): Move variables to inner block.
        Move the checks for the non-mainline case a bit earlier to avoid
        doing some useless computations.
@
text
@d569 3
d574 1
d629 1
a629 1
  if (!mainline && addrs && addrs->other[0].name)
a630 5
      asection *lower_sect;
      asection *sect;
      CORE_ADDR lower_offset;
      int i;

d662 3
a664 1
        for (i = 0; i < addrs->num_sections && addrs->other[i].name; i++)
@


1.100.2.2
log
@2003-08-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (symbol_file_add_with_addrs_or_offsets): Make sure
	orig_addrs is set up properly.
@
text
@d857 1
a857 6
    {
      int i;
      orig_addrs->num_sections = addrs->num_sections;
      for (i = 0; i < addrs->num_sections; i++)
	orig_addrs->other[i] = addrs->other[i];
    }
@


1.100.2.3
log
@Merged from mainline:

2003-10-29  Mark Kettenis  <kettenis@@gnu.org>

* objfiles.h (clear_objfile_data): New prototype.
* objfiles.c (clear_objfile_data): New function.
* symfile.c (reread_symbols): Clear per-objfile data.
@
text
@a1976 1
	      clear_objfile_data (objfile);
@


1.99
log
@	* symfile.c (reread_symbols): Clear sym_private.
@
text
@d1810 1
a1810 5
      val = sect_opts[i].value;
      if (val[0] == '0' && val[1] == 'x')
	addr = strtoul (val+2, NULL, 16);
      else
	addr = strtoul (val, NULL, 10);
@


1.98
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* block.h (BLOCK_SHOULD_SORT): Delete.
	* symtab.c (lookup_block_symbol): Don't worry about sorted linear
	blocks.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Ditto.
	* symfile.h: Delete sort_symtabs_syms and sort_block_syms
	declarations.
	* coffread.c (coff_symfile_read): Don't call sort_symtab_syms.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
@
text
@d1970 1
@


1.97
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@a238 32
/* Call sort_block_syms to sort alphabetically the symbols of one block.  */

void
sort_block_syms (register struct block *b)
{
  qsort (&BLOCK_SYM (b, 0), BLOCK_NSYMS (b),
	 sizeof (struct symbol *), compare_symbols);
}

/* Call sort_symtab_syms to sort alphabetically
   the symbols of each block of one symtab.  */

void
sort_symtab_syms (register struct symtab *s)
{
  register struct blockvector *bv;
  int nbl;
  int i;
  register struct block *b;

  if (s == 0)
    return;
  bv = BLOCKVECTOR (s);
  nbl = BLOCKVECTOR_NBLOCKS (bv);
  for (i = 0; i < nbl; i++)
    {
      b = BLOCKVECTOR_BLOCK (bv, i);
      if (BLOCK_SHOULD_SORT (b))
	sort_block_syms (b);
    }
}

@


1.96
log
@	* elfread.c (elf_symtab_read): Avoid use of SECT_OFF_MAX.
	(elfstab_offset_sections): Likewise.
	* gdb-stabs.h (stab_section_info): Likewise.
	* i386-interix-tdep.c (pei_adjust_objfile_offsets): Likewise.
	* objfiles.c (objfile_relocate): Likewise.
	* pa64solib.c (pa64_solib_add_solib_objfile): Likewise.
	* remote.c (get_offsets): Likewise.
	(remote_cisco_objfile_relocate): Likewise.
	* somread.c (som_symfile_offsets): Likewise.
	* symfile.c (alloc_section_addr_info): New function.
	(build_section_addr_info_from_section_tab): Use it.
	(free_section_addr_info): Adjust.
	(default_symfile_offsets): Avoid use of SECT_OFF_MAX.
	(syms_from_objfile): Allocate local_addr dynamically.
	(symbol_file_add_with_addrs_or_offsets): Allocate orig_addrs
	dynamically.
	(add_symbol_file_command): Allocate sect_opts dynamically.
	(reread_symbols): Avoid use of SECT_OFF_MAX.
	* symfile.h (section_addr_info): Do not use MAX_SECTIONS.
	(alloc_section_addr_info): Declare it.
	* symtab.h (SIZEOF_SECTION_OFFSETS): Remove.
	* win32-nat.c (solib_symbols_add): Allocate section_addrs
	dynamically.
	* xcoffread.c (xcoff_symfile_offsets): Avoid use of SECT_OFF_MAX.
@
text
@d3013 1
a3013 1
int
@


1.95
log
@2003-06-02  Elena Zannoni  <ezannoni@@redhat.com>

	* target.h (TARGET_SYMFILE_POSTREAD): Delete unused macro.
	* symfile.c (reread_symbols): Delete call to TARGET_SYMFILE_POSTREAD.
	(syms_from_objfile): Ditto.
@
text
@d404 16
d432 1
a432 2
  sap = xmalloc (sizeof (struct section_addr_info));
  memset (sap, 0, sizeof (struct section_addr_info));
d438 1
a438 1
	  && oidx < MAX_SECTIONS)
d459 1
a459 1
  for (idx = 0; idx < MAX_SECTIONS; idx++)
d532 1
a532 1
  objfile->num_sections = SECT_OFF_MAX;
d534 4
a537 2
    obstack_alloc (&objfile->psymbol_obstack, SIZEOF_SECTION_OFFSETS);
  memset (objfile->section_offsets, 0, SIZEOF_SECTION_OFFSETS);
d541 1
a541 1
  for (i = 0; i < MAX_SECTIONS && addrs->other[i].name; i++)
d604 1
a604 1
  struct section_addr_info local_addr;
a609 11
  /* If ADDRS and OFFSETS are both NULL, put together a dummy address
     list.  We now establish the convention that an addr of zero means
     no load address was specified. */
  if (! addrs && ! offsets)
    {
      memset (&local_addr, 0, sizeof (local_addr));
      addrs = &local_addr;
    }

  /* Now either addrs or offsets is non-zero.  */

d620 13
d696 1
a696 1
        for (i=0 ; i < MAX_SECTIONS && addrs->other[i].name; i++)
d780 1
a780 1
	         !s_addr && i < MAX_SECTIONS && addrs->other[i].name;
d871 2
a872 4
  struct section_addr_info orig_addrs;
  
  if (addrs)
    orig_addrs = *addrs;
d887 5
d958 1
a958 1
            = symbol_file_add (debugfile, from_tty, &orig_addrs, 0, flags);
d997 2
d1716 1
a1716 1
  struct
d1720 1
a1720 1
  } sect_opts[SECT_OFF_MAX];
d1722 3
a1724 1
  struct section_addr_info section_addrs;
d1727 4
a1738 3
  /* Ensure section_addrs is initialized */
  memset (&section_addrs, 0, sizeof (section_addrs));

d1771 8
a1778 1
	    section_index++;		  
a1794 2
			if (section_index >= SECT_OFF_MAX)
			  error ("Too many sections specified.");
d1811 8
a1818 1
		      section_index++;		  
d1834 2
d1850 2
a1851 2
      section_addrs.other[sec_num].name = sec;
      section_addrs.other[sec_num].addr = addr;
d1867 1
a1867 1
  symbol_file_add (filename, from_tty, &section_addrs, 0, flags);
d1964 4
a1967 2
	      offsets = (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
	      memcpy (offsets, objfile->section_offsets, SIZEOF_SECTION_OFFSETS);
d2035 4
a2038 2
		obstack_alloc (&objfile->psymbol_obstack, SIZEOF_SECTION_OFFSETS);
	      memcpy (objfile->section_offsets, offsets, SIZEOF_SECTION_OFFSETS);
@


1.94
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@a794 7

  /* Call this after reading in a new symbol table to give target
     dependent code a crack at the new symbols.  For instance, this
     could be used to update the values of target-specific symbols GDB
     needs to keep track of (such as _sigtramp, or whatever).  */

  TARGET_SYMFILE_POSTREAD (objfile);
a2036 8

	      /* Call this after reading in a new symbol table to give target
	         dependent code a crack at the new symbols.  For instance, this
	         could be used to update the values of target-specific symbols GDB
	         needs to keep track of (such as _sigtramp, or whatever).  */

	      TARGET_SYMFILE_POSTREAD (objfile);

@


1.93
log
@	* symfile.c (symfile_relocate_debug_section): Update call to
	bfd_simple_get_relocated_section_contents.
@
text
@d2643 1
a2643 1
add_psymbol_to_list (char *name, int namelength, namespace_enum namespace,
d2670 1
a2670 1
  PSYMBOL_NAMESPACE (&psymbol) = namespace;
d2693 1
a2693 1
				   int dem_namelength, namespace_enum namespace,
d2738 1
a2738 1
  PSYMBOL_NAMESPACE (&psymbol) = namespace;
@


1.93.10.1
log
@Snap const char * mess.
@
text
@d82 1
a82 1
void (*pre_add_symbol_hook) (const char *);
d104 1
a104 1
static void load_command (const char *, int);
d106 1
a106 1
static void symbol_file_add_main_1 (const char *args, int from_tty, int flags);
d108 1
a108 1
static void add_symbol_file_command (const char *, int);
d110 1
a110 1
static void add_shared_symbol_files_command (const char *, int);
d116 1
a116 1
bfd *symfile_bfd_open (const char *);
d128 1
a128 1
void list_overlays_command (const char *, int);
d130 1
a130 1
void map_overlay_command (const char *, int);
d132 1
a132 1
void unmap_overlay_command (const char *, int);
d134 1
a134 1
static void overlay_auto_command (const char *, int);
d136 1
a136 1
static void overlay_manual_command (const char *, int);
d138 1
a138 1
static void overlay_off_command (const char *, int);
d140 1
a140 1
static void overlay_load_command (const char *, int);
d142 1
a142 1
static void overlay_command (const char *, int);
d154 1
a154 1
static void set_ext_lang_command (const char *args, int from_tty);
d156 1
a156 1
static void info_ext_lang_command (const char *args, int from_tty);
d849 1
a849 1
symbol_file_add_with_addrs_or_offsets (const char *name, int from_tty,
d998 1
a998 2
symbol_file_add (const char *name, int from_tty,
		 struct section_addr_info *addrs,
d1015 1
a1015 1
symbol_file_add_main (const char *args, int from_tty)
d1021 1
a1021 1
symbol_file_add_main_1 (const char *args, int from_tty, int flags)
d1215 1
a1215 1
symbol_file_command (const char *args, int from_tty)
d1301 1
a1301 1
symfile_bfd_open (const char *n)
d1306 4
a1309 1
  char *name = tilde_expand (n);	/* Returns 1st new malloc'd copy */
d1415 1
a1415 1
load_command (const char *arg, int from_tty)
d1550 1
a1550 1
generic_load (const char *args, int from_tty)
d1686 1
a1686 1
add_symbol_file_command (const char *args, int from_tty)
d1690 1
a1690 1
  const char *arg;
d1701 2
a1702 2
    const char *name;
    const char *value;
d1805 2
a1806 2
      const char *val = sect_opts[i].value;
      const char *sec = sect_opts[i].name;
d1842 1
a1842 1
add_shared_symbol_files_command (const char *args, int from_tty)
d2159 1
a2159 1
set_ext_lang_command (const char *args, int from_tty)
d2216 1
a2216 1
info_ext_lang_command (const char *args, int from_tty)
d3110 1
a3110 1
list_overlays_command (const char *args, int from_tty)
d3149 1
a3149 1
map_overlay_command (const char *args, int from_tty)
d3200 1
a3200 1
unmap_overlay_command (const char *args, int from_tty)
d3230 1
a3230 1
overlay_auto_command (const char *args, int from_tty)
d3243 1
a3243 1
overlay_manual_command (const char *args, int from_tty)
d3256 1
a3256 1
overlay_off_command (const char *args, int from_tty)
d3265 1
a3265 1
overlay_load_command (const char *args, int from_tty)
d3280 1
a3280 1
overlay_command (const char *args, int from_tty)
@


1.93.6.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d2643 1
a2643 1
add_psymbol_to_list (char *name, int namelength, domain_enum domain,
d2670 1
a2670 1
  PSYMBOL_DOMAIN (&psymbol) = domain;
d2693 1
a2693 1
				   int dem_namelength, domain_enum domain,
d2738 1
a2738 1
  PSYMBOL_DOMAIN (&psymbol) = domain;
@


1.92
log
@2003-02-27  David Carlton  <carlton@@math.stanford.edu>

	* symfile.c (compare_symbols): Use SYMBOL_NATURAL_NAME, not
	SYMBOL_PRINT_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_partial_symbol, lookup_block_symbol): Ditto.
@
text
@d3576 1
a3576 1
  return bfd_simple_get_relocated_section_contents (abfd, sectp, buf);
@


1.91
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d213 1
a213 1
  return (strcmp (SYMBOL_PRINT_NAME (*s1), SYMBOL_PRINT_NAME (*s2)));
d225 2
a226 2
  return strcmp_iw_ordered (SYMBOL_PRINT_NAME (*s1),
			    SYMBOL_PRINT_NAME (*s2));
@


1.90
log
@2003-02-24  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Use strcmp_iw_ordered to
	do the comparison, not strcmp.
	* symfile.c (compare_psymbols): Ditto.
	* defs.h: Declare strcmp_iw_ordered.
	* utils.c (strcmp_iw_ordered): New function.
@
text
@d2711 1
a2711 1
  SYMBOL_NAME (&psymbol) = bcache (buf, namelength + 1, objfile->psymbol_cache);
@


1.89
log
@2003-02-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME;
	expand comment.
	* ada-lang.c (user_select_syms, ada_finish_decode_line_1): Replace
	SYMBOL_PRINT_NAME with SYMBOL_SOURCE_NAME.
	* ada-typeprint.c (ada_typedef_print): Ditto.
	* ax-gdb.c (gen_var_ref): Ditto.
	* breakpoint.c (print_one_breakpoint): Ditto.
	* buildsym.c (finish_block): Ditto.
	* c-valprint.c (c_val_print): Ditto.
	* expprint.c (print_subexp): Ditto.
	* findvar.c (locate_var_value): Ditto.
	* infcmd.c (jump_command): Ditto.
	* linespec.c (decode_line_2, decode_compound): Ditto.
	* maint.c (maintenance_translate_address): Ditto.
	* objc-lang.c (compare_selectors, compare_classes): Ditto.
	* printcmd.c (build_address_symbolic, sym_info, print_frame_args):
	Ditto.
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* stack.c (print_frame, frame_info, print_block_frame_locals)
	(print_frame_arg_vars, return_command): Ditto.
	* symfile.c (compare_symbols, compare_psymbols): Ditto.
	* symmisc.c (print_symbol): Ditto.
	* symtab.c (lookup_partial_symbol, lookup_block_symbol)
	(compare_search_syms, print_symbol_info, print_msymbol_info)
	(rbreak_command): Ditto.
	* tracepoint.c (tracepoints_info): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* valops.c (value_of_variable, hand_function_call): Ditto.
	* cli/cli-cmds.c (edit_command, list_command): Ditto.
	* ada-typeprint.c: Update Copyright.
	* infcmd.c, objc-lang.c, p-valprint.c, symmisc.c: Ditto.
	* tracepoint.c, cli/cli-cmds.c: Ditto.
@
text
@d216 2
a217 21
/*

   LOCAL FUNCTION

   compare_psymbols -- compare two partial symbols by name

   DESCRIPTION

   Given pointers to pointers to two partial symbol table entries,
   compare them by name and return -N, 0, or +N (ala strcmp).
   Typically used by sorting routines like qsort().

   NOTES

   Does direct compare of first two characters before punting
   and passing to strcmp for longer compares.  Note that the
   original version had a bug whereby two null strings or two
   identically named one character strings would return the
   comparison of memory following the null byte.

 */
d222 2
a223 8
  register struct partial_symbol **s1, **s2;
  register char *st1, *st2;

  s1 = (struct partial_symbol **) s1p;
  s2 = (struct partial_symbol **) s2p;
  st1 = SYMBOL_PRINT_NAME (*s1);
  st2 = SYMBOL_PRINT_NAME (*s2);

d225 2
a226 12
  if ((st1[0] - st2[0]) || !st1[0])
    {
      return (st1[0] - st2[0]);
    }
  else if ((st1[1] - st2[1]) || !st1[1])
    {
      return (st1[1] - st2[1]);
    }
  else
    {
      return (strcmp (st1, st2));
    }
@


1.88
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d213 1
a213 1
  return (strcmp (SYMBOL_SOURCE_NAME (*s1), SYMBOL_SOURCE_NAME (*s2)));
d246 2
a247 2
  st1 = SYMBOL_SOURCE_NAME (*s1);
  st2 = SYMBOL_SOURCE_NAME (*s2);
@


1.87
log
@	* defs.h (streq): Add prototype.
	* utils.c (streq): New function.

	* dwarf2read.c (new_symbol): Use SYMBOL_SET_NAMES instead of
	SYMBOL_NAME and SYMBOL_INIT_DEMANGLED_NAME.
	* mdebugread.c (new_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* dwarfread.c (new_symbol): Likewise.

	* minsyms.c (prim_record_minimal_symbol_and_info): Use
	SYMBOL_SET_NAMES instead of setting SYMBOL_NAME.  Set the language
	here.
	(install_minimal_symbols): Don't set SYMBOL_LANGUAGE or call
	SYMBOL_INIT_DEMANGLED_NAME.
	* objfiles.c: Include "hashtab.h".
	(allocate_objfile): Call htab_set_functions_ex for the
	demangled_names_hash.
	(free_objfile): Call htab_delete for the demangled_names_hash.
	* objfiles.h (struct htab): Add declaration.
	(struct objfile): Add demangled_names_hash.
	* symfile.c: Include "hashtab.h".
	(reread_symbols): Call htab_delete for the demangled_names_hash.
	(add_psymbol_to_list): Use SYMBOL_SET_NAMES instead of putting
	SYMBOL_NAME in the bcache.
	* symtab.c: Include "hashtab.h".  Update comments.
	(create_demangled_names_hash, symbol_set_names): New functions.
	(symbol_find_demangled_name): New function, broken out from
	symbol_init_demangled_names.
	(symbol_init_demangled_names): Use it.
	* symtab.h (SYMBOL_INIT_DEMANGLED_NAME): Add missing parentheses.
	(SYMBOL_SET_NAMES): New macro.
	(symbol_set_names): Add prototype.
@
text
@d50 1
@


1.86
log
@Use a single, consistent representation for an empty minimal
symbol table in an objfile.
* objfiles.c (terminate_minimal_symbol_table): New function.
(allocate_objfile): Call it.
* objfiles.h (terminate_minimal_symbol_table): New declaration.
(ALL_MSYMBOLS): No need to test whether (objfile)->msymbols is
non-NULL.
* minsyms.c (lookup_minimal_symbol_by_pc_section): To see whether
objfile has minimal symbols, compare minimal_symbol_count to zero,
instead of comparing msymbols with NULL.
* objfiles.c (have_minimal_symbols): Same.
* solib-sunos.c (solib_add_common_symbols): Call
terminate_minimal_symbol_table.
* symfile.c (reread_symbols): Same.
@
text
@d47 1
d1987 5
a2692 1
  SYMBOL_NAME (&psymbol) = bcache (buf, namelength + 1, objfile->psymbol_cache);
d2706 2
a2707 1
  SYMBOL_INIT_LANGUAGE_SPECIFIC (&psymbol, language);
a3714 1

@


1.85
log
@2003-02-01  Andrew Cagney  <ac131313@@redhat.com>

	* main.c (captured_main): Delete #ifdef ADDITIONAL_OPTIONS,
	ADDITIONAL_OPTION_CASES, and ADDITIONAL_OPTION_HANDLER code.
	(print_gdb_help): Delete #ifdef ADDITIONAL_OPTION_HELP code.
	* stabsread.c (DBX_PARM_SYMBOL_CLASS): Delete macro.
	(define_symbol): Update.
	* symfile.c (generic_load): Remove references to nindy.
	* symtab.c: Remove references to nindy.

Index: doc/ChangeLog
2003-02-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	description of ADDITIONAL_OPTIONS, ADDITIONAL_OPTION_CASES,
	ADDITIONAL_OPTION_HANDLER, and ADDITIONAL_OPTION_HELP, and
	BEFORE_MAIN_LOOP_HOOK, and DBX_PARM_SYMBOL_CLASS along with
	references to nindy and i960.
	* gdb.texinfo (i960): Delete all references to i960 and nindy.
@
text
@d2022 1
@


1.85.2.1
log
@Merge with interps-20030203-mergepoint.
@
text
@a2021 1
              terminate_minimal_symbol_table (objfile);
@


1.84
log
@	* dbxread.c (stabs_data): New static variable.
	(fill_symbuf): Support an in-memory buffer for stabs data.
	(stabs_seek): New function.
	(dbx_psymtab_to_symtab): Relocate the stabs data if necessary.
	(read_ofile_symtab): Use stabs_seek.
	(elfstab_build_psymtabs): Take an asection* instead of
	an offset and size.  Relocate the stabs data if necessary.
	Save the section* for dbx_psymtab_to_symtab.
	* dwarf2read.c: Add section variables for each debug section.
	(dwarf2_locate_sections): Fill them in.
	(dwarf2_read_section): Take an asection* argument.
	Relocate the section contents if necessary.
	(dwarf2_build_psymtabs, dwarf2_build_psymtabs_easy): Update callers.
	* dwarf2cfi.c (parse_frame_info): Take a section argument and pass
	it to dwarf2_read_section.
	(dwarf2_build_frame_info): Update callers.
	* elfread.c (elf_symfile_read): Update call to
	elfstab_build_psymtabs.
	* gdb-stabs.h (struct dbx_symfile_info): Add stab_section.
	(DBX_STAB_SECTION): New macro.
	* stabsread.h (elfstab_build_psymtabs): Update prototype.
	* symfile.c (symfile_dummy_outputs): New function.
	(symfile_relocate_debug_section): New function.
	* symfile.h (symfile_relocate_debug_section): Add prototype.
@
text
@d1655 5
a1659 5
  /* FIXME: are we supposed to call symbol_file_add or not?  According to
     a comment from remote-mips.c (where a call to symbol_file_add was
     commented out), making the call confuses GDB if more than one file is
     loaded in.  remote-nindy.c had no call to symbol_file_add, but remote-vx.c
     does.  */
@


1.83
log
@* symfile.c (find_separate_debug_file): Assert that the objfile's
directory name we compute ends with a slash, and then assume that
that's so everywhere we use it.
@
text
@d26 1
d3566 39
@


1.82
log
@* symfile.c (syms_from_objfile): Don't print the "(no debugging
symbols found)" message here; we haven't checked for a separate
debug info file yet, so we don't know yet.
(symbol_file_add_with_addrs_or_offsets): Print it here, after
we've looked everywhere.  Also, there's no need to print a special
message when we're loading the separate debug info file: the one
symbol_file_add prints is fine.
@
text
@d1170 4
a1173 1
  /* Strip off filename part */
d1179 1
a1216 1
  strcat (debugfile, "/");
@


1.81
log
@gdb/ChangeLog:
2003-01-23  Alexander Larsson <alexl@@redhat.com>
	    Jim Blandy  <jimb@@redhat.com>

	Add support for executables whose debug info has been separated
	out into a separate file, leaving only a link behind.
	* objfiles.h (struct objfile): New fields: separate_debug_objfile
	and separate_debug_objfile_backlink.
	(put_objfile_before): New declaration.
	* symfile.c: #include "filenames.h".
	(symbol_file_add_with_addrs_or_offsets): If this objfile has its
	debug info in a separate file, read that, too. Save the addrs
	argument, so we can use it again to read the separated debug info;
	syms_from_objfile modifies the table we pass it.
	(reread_symbols): After re-reading an objfile, call
	reread_separate_symbols to refresh its separate debug info
	objfile, if it has one.
	(reread_separate_symbols, find_separate_debug_file,
	get_debug_link_info, separate_debug_file_exists): New functions.
	(debug_file_directory): New global var.
	(_initialize_symfile): Initialize debug_file_directory, and
	provide the new `set debug-file-directory' command to let the user
	change it.
	* objfiles.c (free_objfile): If this objfile has its debug info in
	a separate objfile, free that one too.  If this is itself a
	separate debug info objfile, clear our parent's backlink.
	(put_objfile_before): New function.
	* utils.c (gnu_debuglink_crc32): New function.
	* defs.h (gnu_debuglink_crc32): New declaration.
	* Makefile.in (symfile.o): Note dependency on "filenames.h".
	* configure.in: Handle --with-separate-debug-dir config option.
	* acinclude.m4 (AC_DEFINE_DIR): New macro.
	* acconfig.h (DEBUGDIR): New macro.
	* configure, aclocal.m4, config.in: Regenerated.

gdb/doc/ChangeLog:
2003-01-23  Jim Blandy  <jimb@@redhat.com>

	* gdb.texinfo (Separate Debug Files): New section.
@
text
@a810 7
  if (!have_partial_symbols () && !have_full_symbols ())
    {
      wrap_here ("");
      printf_filtered ("(no debugging symbols found)...");
      wrap_here ("");
    }

a971 8
      if (from_tty || info_verbose)
        {
          printf_filtered ("loading separate debug info from '%s'",
                           debugfile);
          wrap_here ("");
          gdb_flush (gdb_stdout);
        }

d992 7
@


1.80
log
@* symfile.c (symbol_file_add_with_addrs_or_offsets): New function,
like the old symbol_file_add, but taking new arguments: you can
now pass in either a `struct section_addr_info' list to say where
each section is loaded, or a `struct section_offsets' table.  Pass
these new arguments through to syms_from_objfile as appropriate.
(symbol_file_add): Just call symbol_file_add_with_addrs_or_offsets,
with the appropriate quiescent values for the new arguments.
@
text
@d41 1
d109 2
d155 2
d896 1
d898 4
d976 31
d1102 135
d2082 2
d2091 67
d3659 15
@


1.79
log
@* symfile.c: #include "gdb_assert.h".
(syms_from_objfile): Add the ability to pass in a section offset
table directly, as an alternative to the section_addr_info table.
Document arguments better.
(symbol_file_add): Pass extra arguments to syms_from_objfile.
* symfile.h (syms_from_objfile): Update declaration.
* rs6000-nat.c (objfile_symbol_add): Pass new arguments to
syms_from_objfile.
* Makefile.in (symfile.o): List dependency on $(gdb_assert_h).
@
text
@d870 9
a878 4
   FROM_TTY says how verbose to be.  MAINLINE specifies whether this
   is the main symbol file, or whether it's an extra symbol file such
   as dynamically loaded code.  If !mainline, ADDR is the address
   where the text segment was loaded.
d882 6
a887 4

struct objfile *
symbol_file_add (char *name, int from_tty, struct section_addr_info *addrs,
		 int mainline, int flags)
d940 2
a941 1
      syms_from_objfile (objfile, addrs, 0, 0, mainline, from_tty);
d991 13
@


1.78
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d46 1
d576 20
a595 2
   ADDR is the address where the text segment was loaded, unless the
   objfile is the main symbol file, in which case it is zero.
d604 6
a609 2
syms_from_objfile (struct objfile *objfile, struct section_addr_info *addrs,
		   int mainline, int verbo)
d618 1
a618 3
  /* If ADDRS is NULL, initialize the local section_addr_info struct and
     point ADDRS to it.  We now establish the convention that an addr of
     zero means no load address was specified. */
d620 4
a623 1
  if (addrs == NULL)
d629 2
d703 26
a728 24
      for (i=0 ; i < MAX_SECTIONS && addrs->other[i].name; i++)
	{
	  if (addrs->other[i].addr != 0)
 	    {
 	      sect = bfd_get_section_by_name (objfile->obfd,
                                              addrs->other[i].name);
 	      if (sect)
 		{
 		  addrs->other[i].addr
                    -= bfd_section_vma (objfile->obfd, sect);
 		  lower_offset = addrs->other[i].addr;
		  /* This is the index used by BFD. */
		  addrs->other[i].sectindex = sect->index ;
 		}
 	      else
		{
		  warning ("section %s not found in %s", addrs->other[i].name, 
			   objfile->name);
		  addrs->other[i].addr = 0;
		}
 	    }
 	  else
 	    addrs->other[i].addr = lower_offset;
	}
d738 15
a752 1
  (*objfile->sf->sym_offsets) (objfile, addrs);
d933 1
a933 1
      syms_from_objfile (objfile, addrs, mainline, from_tty);
@


1.77
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d414 1
a414 1
find_lowest_section (bfd *abfd, asection *sect, PTR obj)
d651 1
a651 1
			       (PTR) &lower_sect);
d2486 1
a2486 1
      xmfree (objfile->md, (PTR) objfile->global_psymbols.list);
d2490 1
a2490 1
      xmfree (objfile->md, (PTR) objfile->static_psymbols.list);
@


1.76
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* valarith.c (value_binop): Delete obsolete code and comments.
	* configure.host: Ditto.
	* buildsym.h (make_blockvector): Ditto.
	* buildsym.c (make_blockvector): Ditto.
	* defs.h (enum language): Ditto.
	(chill_demangle): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* dwarfread.c (CHILL_PRODUCER): Ditto.
	(set_cu_language): Ditto.
	(handle_producer): Ditto.
	* expprint.c (print_subexp): Ditto.
	* gdbtypes.c (chill_varying_type): Ditto.
	* gdbtypes.h (builtin_type_chill_bool): Ditto.
	(builtin_type_chill_char, builtin_type_chill_long): Ditto.
	(builtin_type_chill_ulong, builtin_type_chill_real): Ditto.
	(chill_varying_type): Ditto.
	* language.h (_LANG_chill): Ditto.
	* language.c (binop_result_type, integral_type): Ditto.
	(character_type, string_type, structured_type): Ditto.
	(lang_bool_type, binop_type_check): Ditto.
	* stabsread.h (os9k_stabs): Ditto.
	* stabsread.c (os9k_type_vector, dbx_lookup_type): Ditto.
	(define_symbol, read_type, read_struct_fields): Ditto.
	(read_array_type, read_enum_type, read_huge_number): Ditto.
	(read_range_type, start_stabs): Ditto.
	* symfile.c (init_filename_language_table): Ditto.
	(add_psymbol_with_dem_name_to_list): Ditto.
	* symtab.c (symbol_init_language_specific): Ditto.
	(symbol_init_demangled_name, symbol_demangled_name): Ditto.
	* symtab.h (struct general_symbol_info): Ditto.
	(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* valops.c (value_cast, search_struct_field, value_slice): Delete
	obsolete code.
	(varying_to_slice): Delete function.
	* value.h (COERCE_VARYING_ARRAY): Delete obsolete macro contents.
	(varying_to_slice): Delete declaration.
	* MAINTAINERS: Update.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002 Free Software Foundation, Inc.
@


1.75
log
@2002-12-08  Elena Zannoni  <ezannoni@@redhat.com>

	More cleanup from import of readline 4.3.
	* completer.h (complete_line, readline_line_completion_function):
	Update prototypes.
	(line_completion_function): Removed, not used outside of completer.c.
	* completer.c (readline_line_completion_function,
	complete_function, line_completion_function): Use const for first
	parameter.
	(line_completion_function): Make static.
	(filename_completer): filename_completion_function is now called
	rl_filename_completion_function
	* corelow.c: Include <readline/readline.h>.
	* exec.c: Ditto.
	* solib.c: Ditto.
	* source.c: Ditto.
	* symfile.c: Ditto.
	* symmisc.c: Ditto.
	* top.c (init_main): No need to coerce
	readline_line_completion_function anymore.
	* cli/cli-dump.c: Include <readline/readline.h>.
@
text
@a1968 3
      /* OBSOLETE add_filename_language (".ch", language_chill); */
      /* OBSOLETE add_filename_language (".c186", language_chill); */
      /* OBSOLETE add_filename_language (".c286", language_chill); */
a2446 4
      /* OBSOLETE case language_chill: */
      /* OBSOLETE   SYMBOL_CHILL_DEMANGLED_NAME (&psymbol) = */
      /* OBSOLETE     bcache (buf, dem_namelength + 1, objfile->psymbol_cache); */

@


1.75.2.1
log
@* symfile.c: #include "gdb_assert.h".
(syms_from_objfile): Add the ability to pass in a section offset
table directly, as an alternative to the section_addr_info table.
Document arguments better.
(symbol_file_add): Pass extra arguments to syms_from_objfile.
* symfile.h (syms_from_objfile): Update declaration.
* rs6000-nat.c (objfile_symbol_add): Pass new arguments to
syms_from_objfile.
* Makefile.in (symfile.o): List dependency on $(gdb_assert_h).
@
text
@a45 1
#include "gdb_assert.h"
d575 2
a576 20
   ADDRS is the list of section load addresses.  If the user has given
   an 'add-symbol-file' command, then this is the list of offsets and
   addresses he or she provided as arguments to the command; or, if
   we're handling a shared library, these are the actual addresses the
   sections are loaded at, according to the inferior's dynamic linker
   (as gleaned by GDB's shared library code).  We convert each address
   into an offset from the section VMA's as it appears in the object
   file, and then call the file's sym_offsets function to convert this
   into a format-specific offset table --- a `struct section_offsets'.
   If ADDRS is non-zero, OFFSETS must be zero.

   OFFSETS is a table of section offsets already in the right
   format-specific representation.  NUM_OFFSETS is the number of
   elements present in OFFSETS->offsets.  If OFFSETS is non-zero, we
   assume this is the proper table the call to sym_offsets described
   above would produce.  Instead of calling sym_offsets, we just dump
   it right into objfile->section_offsets.  (When we're re-reading
   symbols from an objfile, we don't have the original load address
   list any more; all we have is the section offset table.)  If
   OFFSETS is non-zero, ADDRS must be zero.
d585 2
a586 6
syms_from_objfile (struct objfile *objfile,
                   struct section_addr_info *addrs,
                   struct section_offsets *offsets,
                   int num_offsets,
		   int mainline,
                   int verbo)
d595 3
a597 1
  gdb_assert (! (addrs && offsets));
d599 1
a599 4
  /* If ADDRS and OFFSETS are both NULL, put together a dummy address
     list.  We now establish the convention that an addr of zero means
     no load address was specified. */
  if (! addrs && ! offsets)
a604 2
  /* Now either addrs or offsets is non-zero.  */

d677 24
a700 26
      if (addrs)
        for (i=0 ; i < MAX_SECTIONS && addrs->other[i].name; i++)
          {
            if (addrs->other[i].addr != 0)
              {
                sect = bfd_get_section_by_name (objfile->obfd,
                                                addrs->other[i].name);
                if (sect)
                  {
                    addrs->other[i].addr
                      -= bfd_section_vma (objfile->obfd, sect);
                    lower_offset = addrs->other[i].addr;
                    /* This is the index used by BFD. */
                    addrs->other[i].sectindex = sect->index ;
                  }
                else
                  {
                    warning ("section %s not found in %s",
                             addrs->other[i].name, 
                             objfile->name);
                    addrs->other[i].addr = 0;
                  }
              }
            else
              addrs->other[i].addr = lower_offset;
          }
d710 1
a710 15
  if (addrs)
    (*objfile->sf->sym_offsets) (objfile, addrs);
  else
    {
      size_t size = SIZEOF_N_SECTION_OFFSETS (num_offsets);

      /* Just copy in the offset table directly as given to us.  */
      objfile->num_sections = num_offsets;
      objfile->section_offsets
        = ((struct section_offsets *)
           obstack_alloc (&objfile->psymbol_obstack, size));
      memcpy (objfile->section_offsets, offsets, size);

      init_objfile_sect_indices (objfile);
    }
d891 1
a891 1
      syms_from_objfile (objfile, addrs, 0, 0, mainline, from_tty);
@


1.75.2.2
log
@* symfile.c (symbol_file_add_with_addrs_or_offsets): New function,
like the old symbol_file_add, but taking new arguments: you can
now pass in either a `struct section_addr_info' list to say where
each section is loaded, or a `struct section_offsets' table.  Pass
these new arguments through to syms_from_objfile as appropriate.
(symbol_file_add): Just call symbol_file_add_with_addrs_or_offsets,
with the appropriate quiescent values for the new arguments.
@
text
@d870 4
a873 9

   FROM_TTY says how verbose to be.

   MAINLINE specifies whether this is the main symbol file, or whether
   it's an extra symbol file such as dynamically loaded code.

   ADDRS, OFFSETS, and NUM_OFFSETS are as described for
   syms_from_objfile, above.  ADDRS is ignored when MAINLINE is
   non-zero.
d877 4
a880 6
static struct objfile *
symbol_file_add_with_addrs_or_offsets (char *name, int from_tty,
                                       struct section_addr_info *addrs,
                                       struct section_offsets *offsets,
                                       int num_offsets,
                                       int mainline, int flags)
d933 1
a933 2
      syms_from_objfile (objfile, addrs, offsets, num_offsets,
                         mainline, from_tty);
a982 13


/* Process a symbol file, as either the main file or as a dynamically
   loaded file.  See symbol_file_add_with_addrs_or_offsets's comments
   for details.  */
struct objfile *
symbol_file_add (char *name, int from_tty, struct section_addr_info *addrs,
		 int mainline, int flags)
{
  return symbol_file_add_with_addrs_or_offsets (name, from_tty, addrs, 0, 0, 
                                                mainline, flags);
}

@


1.75.2.3
log
@Add support for executables whose debug info has been separated
out into a separate file, leaving only a link behind.
* objfiles.h (struct objfile): New fields: separate_debug_objfile
and separate_debug_objfile_backlink.
(put_objfile_before): New declaration.
* symfile.c: #include "filenames.h".
(symbol_file_add_with_addrs_or_offsets): If this objfile has its
debug info in a separate file, read that, too. Save the addrs
argument, so we can use it again to read the separated debug info;
syms_from_objfile modifies the table we pass it.
(reread_symbols): After re-reading an objfile, call
reread_separate_symbols to refresh its separate debug info
objfile, if it has one.
(reread_separate_symbols, find_separate_debug_file,
get_debug_link_info, separate_debug_file_exists): New functions.
(debug_file_directory): New global var.
(_initialize_symfile): Initialize debug_file_directory, and
provide the new `set debug-file-directory' command to let the user
change it.
* objfiles.c (free_objfile): If this objfile has its debug info in
a separate objfile, free that one too.  If this is itself a
separate debug info objfile, clear our parent's backlink.
(put_objfile_before): New function.
* utils.c (gnu_debuglink_crc32): New function.
* defs.h (gnu_debuglink_crc32): New declaration.
* Makefile.in (symfile.o): Note dependency on "filenames.h".
* configure.in: Handle --with-separate-debug-dir config option.
* acinclude.m4 (AC_DEFINE_DIR): New macro.
* acconfig.h (DEBUGDIR): New macro.
* configure, aclocal.m4, config.in: Regenerated.
@
text
@a40 1
#include "filenames.h"		/* for DOSish file names */
a107 2
static void reread_separate_symbols (struct objfile *objfile);

a151 2
static char *find_separate_debug_file (struct objfile *objfile);

a890 1
  char *debugfile;
a891 4
  struct section_addr_info orig_addrs;
  
  if (addrs)
    orig_addrs = *addrs;
a965 31
  debugfile = find_separate_debug_file (objfile);
  if (debugfile)
    {
      if (from_tty || info_verbose)
        {
          printf_filtered ("loading separate debug info from '%s'",
                           debugfile);
          wrap_here ("");
          gdb_flush (gdb_stdout);
        }

      if (addrs != NULL)
	{
	  objfile->separate_debug_objfile
            = symbol_file_add (debugfile, from_tty, &orig_addrs, 0, flags);
	}
      else
	{
	  objfile->separate_debug_objfile
            = symbol_file_add (debugfile, from_tty, NULL, 0, flags);
	}
      objfile->separate_debug_objfile->separate_debug_objfile_backlink
        = objfile;
      
      /* Put the separate debug object before the normal one, this is so that
         usage of the ALL_OBJFILES_SAFE macro will stay safe. */
      put_objfile_before (objfile->separate_debug_objfile, objfile);
      
      xfree (debugfile);
    }
  
a1060 135
static char *
get_debug_link_info (struct objfile *objfile, unsigned long *crc32_out)
{
  asection *sect;
  bfd_size_type debuglink_size;
  unsigned long crc32;
  char *contents;
  int crc_offset;
  unsigned char *p;
  
  sect = bfd_get_section_by_name (objfile->obfd, ".gnu_debuglink");

  if (sect == NULL)
    return NULL;

  debuglink_size = bfd_section_size (objfile->obfd, sect);
  
  contents = xmalloc (debuglink_size);
  bfd_get_section_contents (objfile->obfd, sect, contents,
			    (file_ptr)0, (bfd_size_type)debuglink_size);

  /* Crc value is stored after the filename, aligned up to 4 bytes. */
  crc_offset = strlen (contents) + 1;
  crc_offset = (crc_offset + 3) & ~3;

  crc32 = bfd_get_32 (objfile->obfd, (bfd_byte *) (contents + crc_offset));
  
  *crc32_out = crc32;
  return contents;
}

static int
separate_debug_file_exists (const char *name, unsigned long crc)
{
  unsigned long file_crc = 0;
  int fd;
  char buffer[8*1024];
  int count;

  fd = open (name, O_RDONLY | O_BINARY);
  if (fd < 0)
    return 0;

  while ((count = read (fd, buffer, sizeof (buffer))) > 0)
    file_crc = gnu_debuglink_crc32 (file_crc, buffer, count);

  close (fd);

  return crc == file_crc;
}

static char *debug_file_directory = NULL;

#if ! defined (DEBUG_SUBDIRECTORY)
#define DEBUG_SUBDIRECTORY ".debug"
#endif

static char *
find_separate_debug_file (struct objfile *objfile)
{
  asection *sect;
  char *basename;
  char *dir;
  char *debugfile;
  char *name_copy;
  bfd_size_type debuglink_size;
  unsigned long crc32;
  int i;

  basename = get_debug_link_info (objfile, &crc32);

  if (basename == NULL)
    return NULL;
  
  dir = xstrdup (objfile->name);

  /* Strip off filename part */
  for (i = strlen(dir) - 1; i >= 0; i--)
    {
      if (IS_DIR_SEPARATOR (dir[i]))
	break;
    }
  dir[i+1] = '\0';
  
  debugfile = alloca (strlen (debug_file_directory) + 1
                      + strlen (dir)
                      + strlen (DEBUG_SUBDIRECTORY)
                      + strlen ("/")
                      + strlen (basename) 
                      + 1);

  /* First try in the same directory as the original file.  */
  strcpy (debugfile, dir);
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      xfree (basename);
      xfree (dir);
      return xstrdup (debugfile);
    }
  
  /* Then try in the subdirectory named DEBUG_SUBDIRECTORY.  */
  strcpy (debugfile, dir);
  strcat (debugfile, DEBUG_SUBDIRECTORY);
  strcat (debugfile, "/");
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      xfree (basename);
      xfree (dir);
      return xstrdup (debugfile);
    }
  
  /* Then try in the global debugfile directory.  */
  strcpy (debugfile, debug_file_directory);
  strcat (debugfile, "/");
  strcat (debugfile, dir);
  strcat (debugfile, "/");
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      xfree (basename);
      xfree (dir);
      return xstrdup (debugfile);
    }
  
  xfree (basename);
  xfree (dir);
  return NULL;
}


a1905 2

              reread_separate_symbols (objfile);
a1912 67


/* Handle separate debug info for OBJFILE, which has just been
   re-read:
   - If we had separate debug info before, but now we don't, get rid
     of the separated objfile.
   - If we didn't have separated debug info before, but now we do,
     read in the new separated debug info file.
   - If the debug link points to a different file, toss the old one
     and read the new one.
   This function does *not* handle the case where objfile is still
   using the same separate debug info file, but that file's timestamp
   has changed.  That case should be handled by the loop in
   reread_symbols already.  */
static void
reread_separate_symbols (struct objfile *objfile)
{
  char *debug_file;
  unsigned long crc32;

  /* Does the updated objfile's debug info live in a
     separate file?  */
  debug_file = find_separate_debug_file (objfile);

  if (objfile->separate_debug_objfile)
    {
      /* There are two cases where we need to get rid of
         the old separated debug info objfile:
         - if the new primary objfile doesn't have
         separated debug info, or
         - if the new primary objfile has separate debug
         info, but it's under a different filename.
 
         If the old and new objfiles both have separate
         debug info, under the same filename, then we're
         okay --- if the separated file's contents have
         changed, we will have caught that when we
         visited it in this function's outermost
         loop.  */
      if (! debug_file
          || strcmp (debug_file, objfile->separate_debug_objfile->name) != 0)
        free_objfile (objfile->separate_debug_objfile);
    }

  /* If the new objfile has separate debug info, and we
     haven't loaded it already, do so now.  */
  if (debug_file
      && ! objfile->separate_debug_objfile)
    {
      /* Use the same section offset table as objfile itself.
         Preserve the flags from objfile that make sense.  */
      objfile->separate_debug_objfile
        = (symbol_file_add_with_addrs_or_offsets
           (debug_file,
            info_verbose, /* from_tty: Don't override the default. */
            0, /* No addr table.  */
            objfile->section_offsets, objfile->num_sections,
            0, /* Not mainline.  See comments about this above.  */
            objfile->flags & (OBJF_MAPPED | OBJF_REORDERED
                              | OBJF_SHARED | OBJF_READNOW
                              | OBJF_USERLOADED)));
      objfile->separate_debug_objfile->separate_debug_objfile_backlink
        = objfile;
    }
}


a3420 15

  debug_file_directory = xstrdup (DEBUGDIR);
  c = (add_set_cmd
       ("debug-file-directory", class_support, var_string,
        (char *) &debug_file_directory,
        "Set the directory where separate debug symbols are searched for.\n"
        "Separate debug symbols are first searched for in the same\n"
        "directory as the binary, then in the `" DEBUG_SUBDIRECTORY 
        "' subdirectory,\n"
        "and lastly at the path of the directory of the binary with\n"
        "the global debug-file directory prepended\n",
        &setlist));
  add_show_from_set (c, &showlist);
  set_cmd_completer (c, filename_completer);

@


1.74
log
@* symfile.c (init_objfile_sect_indices): New function.
(default_symfile_offsets): Move the section-index-initializing
stuff into init_objfile_sect_indices, and call that.
@
text
@d45 1
@


1.74.2.1
log
@* symfile.c: #include "gdb_assert.h".
(syms_from_objfile): Add the ability to pass in a section offset
table directly, as an alternative to the section_addr_info table.
Document arguments better.
(symbol_file_add): Pass extra arguments to syms_from_objfile.
* symfile.h (syms_from_objfile): Update declaration.
* rs6000-nat.c (objfile_symbol_add): Pass new arguments to
syms_from_objfile.
* Makefile.in (symfile.o): List dependency on $(gdb_assert_h).
@
text
@a44 1
#include "gdb_assert.h"
d574 2
a575 20
   ADDRS is the list of section load addresses.  If the user has given
   an 'add-symbol-file' command, then this is the list of offsets and
   addresses he or she provided as arguments to the command; or, if
   we're handling a shared library, these are the actual addresses the
   sections are loaded at, according to the inferior's dynamic linker
   (as gleaned by GDB's shared library code).  We convert each address
   into an offset from the section VMA's as it appears in the object
   file, and then call the file's sym_offsets function to convert this
   into a format-specific offset table --- a `struct section_offsets'.
   If ADDRS is non-zero, OFFSETS must be zero.

   OFFSETS is a table of section offsets already in the right
   format-specific representation.  NUM_OFFSETS is the number of
   elements present in OFFSETS->offsets.  If OFFSETS is non-zero, we
   assume this is the proper table the call to sym_offsets described
   above would produce.  Instead of calling sym_offsets, we just dump
   it right into objfile->section_offsets.  (When we're re-reading
   symbols from an objfile, we don't have the original load address
   list any more; all we have is the section offset table.)  If
   OFFSETS is non-zero, ADDRS must be zero.
d584 2
a585 6
syms_from_objfile (struct objfile *objfile,
                   struct section_addr_info *addrs,
                   struct section_offsets *offsets,
                   int num_offsets,
		   int mainline,
                   int verbo)
d594 3
a596 1
  gdb_assert (! (addrs && offsets));
d598 1
a598 4
  /* If ADDRS and OFFSETS are both NULL, put together a dummy address
     list.  We now establish the convention that an addr of zero means
     no load address was specified. */
  if (! addrs && ! offsets)
a603 2
  /* Now either addrs or offsets is non-zero.  */

d676 24
a699 26
      if (addrs)
        for (i=0 ; i < MAX_SECTIONS && addrs->other[i].name; i++)
          {
            if (addrs->other[i].addr != 0)
              {
                sect = bfd_get_section_by_name (objfile->obfd,
                                                addrs->other[i].name);
                if (sect)
                  {
                    addrs->other[i].addr
                      -= bfd_section_vma (objfile->obfd, sect);
                    lower_offset = addrs->other[i].addr;
                    /* This is the index used by BFD. */
                    addrs->other[i].sectindex = sect->index ;
                  }
                else
                  {
                    warning ("section %s not found in %s",
                             addrs->other[i].name, 
                             objfile->name);
                    addrs->other[i].addr = 0;
                  }
              }
            else
              addrs->other[i].addr = lower_offset;
          }
d709 1
a709 15
  if (addrs)
    (*objfile->sf->sym_offsets) (objfile, addrs);
  else
    {
      size_t size = SIZEOF_N_SECTION_OFFSETS (num_offsets);

      /* Just copy in the offset table directly as given to us.  */
      objfile->num_sections = num_offsets;
      objfile->section_offsets
        = ((struct section_offsets *)
           obstack_alloc (&objfile->psymbol_obstack, size));
      memcpy (objfile->section_offsets, offsets, size);

      init_objfile_sect_indices (objfile);
    }
d890 1
a890 1
      syms_from_objfile (objfile, addrs, 0, 0, mainline, from_tty);
@


1.74.2.2
log
@* symfile.c (symbol_file_add_with_addrs_or_offsets): New function,
like the old symbol_file_add, but taking new arguments: you can
now pass in either a `struct section_addr_info' list to say where
each section is loaded, or a `struct section_offsets' table.  Pass
these new arguments through to syms_from_objfile as appropriate.
(symbol_file_add): Just call symbol_file_add_with_addrs_or_offsets,
with the appropriate quiescent values for the new arguments.
@
text
@d869 4
a872 9

   FROM_TTY says how verbose to be.

   MAINLINE specifies whether this is the main symbol file, or whether
   it's an extra symbol file such as dynamically loaded code.

   ADDRS, OFFSETS, and NUM_OFFSETS are as described for
   syms_from_objfile, above.  ADDRS is ignored when MAINLINE is
   non-zero.
d876 4
a879 6
static struct objfile *
symbol_file_add_with_addrs_or_offsets (char *name, int from_tty,
                                       struct section_addr_info *addrs,
                                       struct section_offsets *offsets,
                                       int num_offsets,
                                       int mainline, int flags)
d932 1
a932 2
      syms_from_objfile (objfile, addrs, offsets, num_offsets,
                         mainline, from_tty);
a981 13


/* Process a symbol file, as either the main file or as a dynamically
   loaded file.  See symbol_file_add_with_addrs_or_offsets's comments
   for details.  */
struct objfile *
symbol_file_add (char *name, int from_tty, struct section_addr_info *addrs,
		 int mainline, int flags)
{
  return symbol_file_add_with_addrs_or_offsets (name, from_tty, addrs, 0, 0, 
                                                mainline, flags);
}

@


1.74.2.3
log
@Add support for executables whose debug info has been separated
out into a separate file, leaving only a link behind.
* objfiles.h (struct objfile): New fields: separate_debug_objfile
and separate_debug_objfile_backlink.
(put_objfile_before): New declaration.
* symfile.c (symbol_file_add_with_addrs_or_offsets): If this
objfile has its debug info in a separate file, read that,
too. Save the addrs argument, so we can use it again to read the
separated debug info; syms_from_objfile modifies the table we pass
it.
(reread_symbols): After re-reading an objfile, call
reread_separate_symbols to refresh its separate debug info
objfile, if it has one.
(reread_separate_symbols, find_separate_debug_file,
get_debug_link_info, separate_debug_file_exists): New functions.
(debug_file_directory): New global var.
(_initialize_symfile): Initialize debug_file_directory, and
provide the new `set debug-file-directory' command to let the user
change it.
* objfiles.c (free_objfile): If this objfile has its debug info in
a separate objfile, free that one too.  If this is itself a
separate debug info objfile, clear our parent's backlink.
(put_objfile_before): New function.
* utils.c (calc_crc32): New function.
* defs.h (calc_crc32): New declaration.
* configure.in: Handle --with-separate-debug-dir config option.
* acinclude.m4 (AC_DEFINE_DIR): New macro.
* acconfig.h (DEBUGDIR): New macro.
* configure, aclocal.m4, config.in: Regenerated.
@
text
@a40 1
#include "filenames.h"		/* for DOSish file names */
a106 2
static void reread_separate_symbols (struct objfile *objfile);

a150 2
static char *find_separate_debug_file (struct objfile *objfile);

a889 1
  char *debugfile;
a890 4
  struct section_addr_info orig_addrs;
  
  if (addrs)
    orig_addrs = *addrs;
a964 31
  debugfile = find_separate_debug_file (objfile);
  if (debugfile)
    {
      if (from_tty || info_verbose)
        {
          printf_filtered ("loading separate debug info from '%s'",
                           debugfile);
          wrap_here ("");
          gdb_flush (gdb_stdout);
        }

      if (addrs != NULL)
	{
	  objfile->separate_debug_objfile
            = symbol_file_add (debugfile, from_tty, &orig_addrs, 0, flags);
	}
      else
	{
	  objfile->separate_debug_objfile
            = symbol_file_add (debugfile, from_tty, NULL, 0, flags);
	}
      objfile->separate_debug_objfile->separate_debug_objfile_backlink
        = objfile;
      
      /* Put the separate debug object before the normal one, this is so that
         usage of the ALL_OBJFILES_SAFE macro will stay safe. */
      put_objfile_before (objfile->separate_debug_objfile, objfile);
      
      xfree (debugfile);
    }
  
a1059 129
static char *
get_debug_link_info (struct objfile *objfile, unsigned long *crc32_out)
{
  asection *sect;
  bfd_size_type debuglink_size;
  unsigned long crc32;
  char *contents;
  int crc_offset;
  unsigned char *p;
  
  sect = bfd_get_section_by_name (objfile->obfd, ".gnu_debuglink");

  if (sect == NULL)
    return NULL;

  debuglink_size = bfd_section_size (objfile->obfd, sect);
  
  contents = xmalloc (debuglink_size);
  bfd_get_section_contents (objfile->obfd, sect, contents,
			    (file_ptr)0, (bfd_size_type)debuglink_size);

  /* Crc value is stored after the filename, aligned up to 4 bytes. */
  crc_offset = strlen (contents) + 1;
  crc_offset = (crc_offset + 3) & ~3;

  crc32 = bfd_get_32 (objfile->obfd, (bfd_byte *) (contents + crc_offset));
  
  *crc32_out = crc32;
  return contents;
}

static int
separate_debug_file_exists (const char *name, unsigned long crc)
{
  unsigned long file_crc = 0;
  int fd;
  char buffer[8*1024];
  int count;

  fd = open (name, O_RDONLY | O_BINARY);
  if (fd < 0)
    return 0;

  while ((count = read (fd, buffer, sizeof (buffer))) > 0)
    file_crc = calc_crc32 (file_crc, buffer, count);

  close (fd);

  return crc == file_crc;
}

static char *debug_file_directory = NULL;

static char *
find_separate_debug_file (struct objfile *objfile)
{
  asection *sect;
  char *basename;
  char *dir;
  char *debugfile;
  char *name_copy;
  bfd_size_type debuglink_size;
  unsigned long crc32;
  int i;

  basename = get_debug_link_info (objfile, &crc32);

  if (basename == NULL)
    return NULL;
  
  dir = xstrdup (objfile->name);

  /* Strip off filename part */
  for (i = strlen(dir) - 1; i >= 0; i--)
    {
      if (IS_DIR_SEPARATOR (dir[i]))
	break;
    }
  dir[i+1] = '\0';
  
  debugfile = alloca (strlen (debug_file_directory) + 1
                      + strlen (dir)
                      + strlen (".debug/")
                      + strlen (basename) 
                      + 1);

  /* First try in the same directory as the original file: */
  strcpy (debugfile, dir);
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      xfree (basename);
      xfree (dir);
      return xstrdup (debugfile);
    }
  
  /* Then try in a subdirectory called .debug */
  strcpy (debugfile, dir);
  strcat (debugfile, ".debug/");
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      xfree (basename);
      xfree (dir);
      return xstrdup (debugfile);
    }
  
  /* Then try in the global debugfile directory */
  strcpy (debugfile, debug_file_directory);
  strcat (debugfile, "/");
  strcat (debugfile, dir);
  strcat (debugfile, "/");
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      xfree (basename);
      xfree (dir);
      return xstrdup (debugfile);
    }
  
  xfree (basename);
  xfree (dir);
  return NULL;
}


a1904 2

              reread_separate_symbols (objfile);
a1911 67


/* Handle separate debug info for OBJFILE, which has just been
   re-read:
   - If we had separate debug info before, but now we don't, get rid
     of the separated objfile.
   - If we didn't have separated debug info before, but now we do,
     read in the new separated debug info file.
   - If the debug link points to a different file, toss the old one
     and read the new one.
   This function does *not* handle the case where objfile is still
   using the same separate debug info file, but that file's timestamp
   has changed.  That case should be handled by the loop in
   reread_symbols already.  */
static void
reread_separate_symbols (struct objfile *objfile)
{
  char *debug_file;
  unsigned long crc32;

  /* Does the updated objfile's debug info live in a
     separate file?  */
  debug_file = find_separate_debug_file (objfile);

  if (objfile->separate_debug_objfile)
    {
      /* There are two cases where we need to get rid of
         the old separated debug info objfile:
         - if the new primary objfile doesn't have
         separated debug info, or
         - if the new primary objfile has separate debug
         info, but it's under a different filename.
 
         If the old and new objfiles both have separate
         debug info, under the same filename, then we're
         okay --- if the separated file's contents have
         changed, we will have caught that when we
         visited it in this function's outermost
         loop.  */
      if (! debug_file
          || strcmp (debug_file, objfile->separate_debug_objfile->name) != 0)
        free_objfile (objfile->separate_debug_objfile);
    }

  /* If the new objfile has separate debug info, and we
     haven't loaded it already, do so now.  */
  if (debug_file
      && ! objfile->separate_debug_objfile)
    {
      /* Use the same section offset table as objfile itself.
         Preserve the flags from objfile that make sense.  */
      objfile->separate_debug_objfile
        = (symbol_file_add_with_addrs_or_offsets
           (debug_file,
            info_verbose, /* from_tty: Don't override the default. */
            0, /* No addr table.  */
            objfile->section_offsets, objfile->num_sections,
            0, /* Not mainline.  See comments about this above.  */
            objfile->flags & (OBJF_MAPPED | OBJF_REORDERED
                              | OBJF_SHARED | OBJF_READNOW
                              | OBJF_USERLOADED)));
      objfile->separate_debug_objfile->separate_debug_objfile_backlink
        = objfile;
    }
}


a3419 14

  debug_file_directory = xstrdup (DEBUGDIR);
  c = (add_set_cmd
       ("debug-file-directory", class_support, var_string,
        (char *) &debug_file_directory,
        "Set the directory where separate debug symbols are searched for.\n"
        "Separate debug symbols are first searched for in the same\n"
        "directory as the binary, then in the .debug subdirectory,\n"
        "and lastly at the path of the directory of the binary with\n"
        "the global debug-file directory prepended\n",
        &setlist));
  add_show_from_set (c, &showlist);
  set_cmd_completer (c, filename_completer);

@


1.74.2.4
log
@Back initial version of Alex Larsson's change off the branch, so we
can revise it.
@
text
@d41 1
d108 2
d154 2
d895 1
d897 4
d975 31
d1101 129
d2075 2
d2084 67
d3659 14
@


1.73
log
@* symfile.c (syms_from_objfile): Adjust indentation.
@
text
@d476 3
a478 9
/* Parse the user's idea of an offset for dynamic linking, into our idea
   of how to represent it for fast symbol reading.  This is the default 
   version of the sym_fns.sym_offsets function for symbol readers that
   don't need to do anything special.  It allocates a section_offsets table
   for the objectfile OBJFILE and stuffs ADDR into all of the offsets.  */

void
default_symfile_offsets (struct objfile *objfile,
			 struct section_addr_info *addrs)
d480 1
d482 1
a482 26
  asection *sect = NULL;

  objfile->num_sections = SECT_OFF_MAX;
  objfile->section_offsets = (struct section_offsets *)
    obstack_alloc (&objfile->psymbol_obstack, SIZEOF_SECTION_OFFSETS);
  memset (objfile->section_offsets, 0, SIZEOF_SECTION_OFFSETS);

  /* Now calculate offsets for section that were specified by the
     caller. */
  for (i = 0; i < MAX_SECTIONS && addrs->other[i].name; i++)
    {
      struct other_sections *osp ;

      osp = &addrs->other[i] ;
      if (osp->addr == 0)
  	continue;

      /* Record all sections in offsets */
      /* The section_offsets in the objfile are here filled in using
         the BFD index. */
      (objfile->section_offsets)->offsets[osp->sectindex] = osp->addr;
    }

  /* Remember the bfd indexes for the .text, .data, .bss and
     .rodata sections. */

d528 40
@


1.72
log
@* symfile.c (symbol_file_add): Flush gdb_stdout even if from_tty
|| info_verbose isn't true.
@
text
@d655 1
a655 1
       /* Calculate offsets for the loadable sections.
d659 2
a660 2
          Adjust offsets if the segments are not contiguous.
          If the section is contiguous, its offset should be set to
d665 1
a665 1
       /* Calculate offsets for sections. */
d670 2
a671 1
 	      sect = bfd_get_section_by_name (objfile->obfd, addrs->other[i].name);
d674 2
a675 1
 		  addrs->other[i].addr -= bfd_section_vma (objfile->obfd, sect);
@


1.71
log
@2002-10-09  David Carlton  <carlton@@math.stanford.edu>

	* symfile.h: Add opaque declaration for struct obstack.
	Declare obsavestring to take a const char *.
	* symfile.c (obsavestring): Make first argument a const char *.
@
text
@a909 1
	  gdb_flush (gdb_stdout);
d912 5
@


1.70
log
@(init_filename_language_table): Add ObjC file extension.
@
text
@d302 1
a302 1
obsavestring (char *ptr, int size, struct obstack *obstackp)
d309 1
a309 1
    register char *p1 = ptr;
d311 1
a311 1
    char *end = ptr + size;
@


1.69
log
@        * source.c: Make global variables current_source_symtab and
        current_source_line static.
        (list_command): Moved to cli/cli-cmds.c.
        (ambiguous_line_spec): Moved to cli/cli-cmds.c.
        (get_first_line_listed): New accessor function.
        (get_lines_to_list): New accessor function.
        (get_current_source_symtab_and_line): New function. Retrieves the
        position in the source code that we consider current.
        (get_current_or_default_source_symtab_and_line): New function.
        Like the above but attempts to determine a default position if one
        is not currently defined.
        (set_current_source_symtab_and_line): New function. Sets the source
        code position considered current and returns the previously set one.
        (clear_current_source_symtab_and_line): Reset stored information about
        a current source line.
        (_initialize_source): Remove registration for the "list" command and
        its alias.
        * source.h: Add declarations for the new functions above.
        * symtab.h: Remove declarations for the global variables mentioned
        above.
        * breakpoint.c (parse_breakpoint_sals): Use accessor functions to
        obtain current source line.
        * linespec.c (decode_line_1): Ditto.
        * macroscope.c (default_macro_scope): Ditto.
        * scm-lang.c (scm_unpac): Ditto.
        * stack.c (print_frame_info_base): Ditto.
        * symfile.c (clear_symtab_users): Ditto.
        * symtab.c (decode_line_spec): Ditto.
        * cli/cli-cmds.c (list_command): Moved here from source.c.
        (ambiguous_line_spec): Moved here from source.c.
        (_init_cli_cmds): Add definition for "list" and its alias.
        * Makefile.in: Update dependencies.
@
text
@d1955 1
@


1.69.4.1
log
@2002-10-22  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (buildsym.o): Depend on $(gdb_assert_h) and
	$(cp_support_h).
	(cp-support.o): Fix dependencies and add $(gdb_obstack_h) and
	$(gdb_assert_h).
	(symtab.o): Depend on $(cp_support_h).
	* symtab.h: Add opaque declaration for struct using_direct_node.
	(struct block): Add member 'language_specific'.
	(BLOCK_USING): New macro.
	* symtab.c: #include "cp-support.h"
	(lookup_symbol_aux): Call lookup_symbol_aux_nonlocal and
	lookup_symbol_aux_using when appropriate.
	(lookup_symbol_aux_nonlocal): New function.
	(lookup_symbol_aux_using): New function.
	(lookup_symbol_aux_using_loop): New function.
	* symfile.h: Add opaque declaration for struct obstack.
	Declare obsavestring to take a const char *.
	* symfile.c (obsavestring): Make first argument a const char *.
	* jv-lang.c (get_java_class_symtab): Initialize BLOCK_USING.
	* dwarf2read.c: New variable current_namespace.
	(scan_partial_symbols): Handle DW_TAG_namespace.
	(psymtab_to_symtab_1): Initialize current_namespace.
	(process_die): Handle DW_TAG_namespace,
	DW_TAG_imported_declaration, DW_TAG_imported_module.
	(read_namespace): New function.
	(dwarf2_name): New function.
	(dwarf2_extension): New function.
	(dwarf_tag_name): Add DWARF 3 names.
	(dwarf_attr_name): Ditto.
	(dwarf_type_encoding_name): Ditto.
	* cp-support.h: Opaque declaration for struct obstack.
	(struct using_direct): New struct.
	(struct using_direct_node): New struct.
	Add declarations for cp_add_using_obstack, cp_add_using_xmalloc,
	cp_copy_usings, cp_free_usings,	cp_find_first_component.
	* cp-support.c: #include "gdb_obstack.h", "gdb_assert.h".
	Comment on demangled name pitfalls.
	(cp_add_using_obstack): New function.
	(cp_add_using_xmalloc): New function.
	(cp_copy_usings): New function.
	(cp_free_usings): New function.
	(cp_find_first_component): New function.
	* buildsym.h: Declare processing_has_namespace_info.
	Declare add_using_directive.
	* buildsym.c: #include "gdb_assert.h", "cp-support.h".
	Change comment after #include "symfile.h".
	New variable using_list.
	(add_symbol_to_list): Scan for anonymous namespaces when
	appropriate.
	(scan_for_anonymous_namespaces): New function.
	(add_using_directive): New function.
	(start_symtab): Initialize processing_has_namespace_info,
	using_list.
	(end_symtab): Copy using_list into block.
	(copy_usings_to_obstack): New function.
	(finish_block): Set BLOCK_USING in general case and in C++
	function case.

2002-10-22  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Add tests involving namespaces
	  starting from C.
	* gdb.c++/namespace.cc: Add namespaces with names starting
	  from C and their contents.
@
text
@d302 1
a302 1
obsavestring (const char *ptr, int size, struct obstack *obstackp)
d309 1
a309 1
    register const char *p1 = ptr;
d311 1
a311 1
    const char *end = ptr + size;
@


1.69.4.2
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a1954 1
      add_filename_language (".m", language_objc);
@


1.69.4.3
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a25 1
#include "bfdlink.h"
a40 1
#include "filenames.h"		/* for DOSish file names */
a44 4
#include "hashtab.h"
#include <readline/readline.h>
#include "gdb_assert.h"
#include "block.h"
a105 2
static void reread_separate_symbols (struct objfile *objfile);

a149 2
static char *find_separate_debug_file (struct objfile *objfile);

d199 1
a199 1
  struct symbol **s1, **s2;
d203 1
a203 1
  return (strcmp (SYMBOL_NATURAL_NAME (*s1), SYMBOL_NATURAL_NAME (*s2)));
d206 21
a226 2
/* This compares two partial symbols by names, using strcmp_iw_ordered
   for the comparison.  */
d231 8
a238 2
  struct partial_symbol *const *s1 = s1p;
  struct partial_symbol *const *s2 = s2p;
d240 12
a251 2
  return strcmp_iw_ordered (SYMBOL_NATURAL_NAME (*s1),
			    SYMBOL_NATURAL_NAME (*s2));
d264 32
d304 1
a304 1
  char *p = (char *) obstack_alloc (obstackp, size + 1);
d309 2
a310 2
    const char *p1 = ptr;
    char *p2 = p;
d326 2
a327 2
  int len = strlen (s1) + strlen (s2) + strlen (s3) + 1;
  char *val = (char *) obstack_alloc (obstackp, len);
d350 1
a350 1
psymtab_to_symtab (struct partial_symtab *pst)
d387 2
a388 2
  objfile->ei.deprecated_entry_file_lowpc = INVALID_ENTRY_LOWPC;
  objfile->ei.deprecated_entry_file_highpc = INVALID_ENTRY_HIGHPC;
d413 1
a413 1
find_lowest_section (bfd *abfd, asection *sect, void *obj)
a428 16
/* Create a new section_addr_info, with room for NUM_SECTIONS.  */

struct section_addr_info *
alloc_section_addr_info (size_t num_sections)
{
  struct section_addr_info *sap;
  size_t size;

  size = (sizeof (struct section_addr_info)
	  +  sizeof (struct other_sections) * (num_sections - 1));
  sap = (struct section_addr_info *) xmalloc (size);
  memset (sap, 0, size);
  sap->num_sections = num_sections;

  return sap;
}
d441 2
a442 1
  sap = alloc_section_addr_info (end - start);
d448 1
a448 1
	  && oidx < end - start)
d469 1
a469 1
  for (idx = 0; idx < sap->num_sections; idx++)
d476 9
a484 3
/* Initialize OBJFILE's sect_index_* members.  */
static void
init_objfile_sect_indices (struct objfile *objfile)
a485 1
  asection *sect;
d487 26
a512 1
  
a558 42

/* Parse the user's idea of an offset for dynamic linking, into our idea
   of how to represent it for fast symbol reading.  This is the default 
   version of the sym_fns.sym_offsets function for symbol readers that
   don't need to do anything special.  It allocates a section_offsets table
   for the objectfile OBJFILE and stuffs ADDR into all of the offsets.  */

void
default_symfile_offsets (struct objfile *objfile,
			 struct section_addr_info *addrs)
{
  int i;

  objfile->num_sections = bfd_count_sections (objfile->obfd);
  objfile->section_offsets = (struct section_offsets *)
    obstack_alloc (&objfile->psymbol_obstack, 
		   SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
  memset (objfile->section_offsets, 0, 
	  SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));

  /* Now calculate offsets for section that were specified by the
     caller. */
  for (i = 0; i < addrs->num_sections && addrs->other[i].name; i++)
    {
      struct other_sections *osp ;

      osp = &addrs->other[i] ;
      if (osp->addr == 0)
  	continue;

      /* Record all sections in offsets */
      /* The section_offsets in the objfile are here filled in using
         the BFD index. */
      (objfile->section_offsets)->offsets[osp->sectindex] = osp->addr;
    }

  /* Remember the bfd indexes for the .text, .data, .bss and
     .rodata sections. */
  init_objfile_sect_indices (objfile);
}


d564 2
a565 20
   ADDRS is the list of section load addresses.  If the user has given
   an 'add-symbol-file' command, then this is the list of offsets and
   addresses he or she provided as arguments to the command; or, if
   we're handling a shared library, these are the actual addresses the
   sections are loaded at, according to the inferior's dynamic linker
   (as gleaned by GDB's shared library code).  We convert each address
   into an offset from the section VMA's as it appears in the object
   file, and then call the file's sym_offsets function to convert this
   into a format-specific offset table --- a `struct section_offsets'.
   If ADDRS is non-zero, OFFSETS must be zero.

   OFFSETS is a table of section offsets already in the right
   format-specific representation.  NUM_OFFSETS is the number of
   elements present in OFFSETS->offsets.  If OFFSETS is non-zero, we
   assume this is the proper table the call to sym_offsets described
   above would produce.  Instead of calling sym_offsets, we just dump
   it right into objfile->section_offsets.  (When we're re-reading
   symbols from an objfile, we don't have the original load address
   list any more; all we have is the section offset table.)  If
   OFFSETS is non-zero, ADDRS must be zero.
d574 2
a575 6
syms_from_objfile (struct objfile *objfile,
                   struct section_addr_info *addrs,
                   struct section_offsets *offsets,
                   int num_offsets,
		   int mainline,
                   int verbo)
d577 4
a580 1
  struct section_addr_info *local_addr = NULL;
d582 1
d584 9
a592 1
  gdb_assert (! (addrs && offsets));
a603 13
  /* If ADDRS and OFFSETS are both NULL, put together a dummy address
     list.  We now establish the convention that an addr of zero means
     no load address was specified. */
  if (! addrs && ! offsets)
    {
      local_addr 
	= alloc_section_addr_info (bfd_count_sections (objfile->obfd));
      make_cleanup (xfree, local_addr);
      addrs = local_addr;
    }

  /* Now either addrs or offsets is non-zero.  */

d632 1
a632 1
  if (!mainline && addrs && addrs->other[0].name)
a633 5
      asection *lower_sect;
      asection *sect;
      CORE_ADDR lower_offset;
      int i;

d640 1
a640 1
			       &lower_sect);
d655 1
a655 1
      /* Calculate offsets for the loadable sections.
d659 2
a660 2
         Adjust offsets if the segments are not contiguous.
         If the section is contiguous, its offset should be set to
d665 23
a687 25
        for (i = 0; i < addrs->num_sections && addrs->other[i].name; i++)
          {
            if (addrs->other[i].addr != 0)
              {
                sect = bfd_get_section_by_name (objfile->obfd,
                                                addrs->other[i].name);
                if (sect)
                  {
                    addrs->other[i].addr
                      -= bfd_section_vma (objfile->obfd, sect);
                    lower_offset = addrs->other[i].addr;
                    /* This is the index used by BFD. */
                    addrs->other[i].sectindex = sect->index ;
                  }
                else
                  {
                    warning ("section %s not found in %s",
                             addrs->other[i].name, 
                             objfile->name);
                    addrs->other[i].addr = 0;
                  }
              }
            else
              addrs->other[i].addr = lower_offset;
          }
d697 1
a697 12
  if (addrs)
    (*objfile->sf->sym_offsets) (objfile, addrs);
  else
    {
      size_t size = SIZEOF_N_SECTION_OFFSETS (num_offsets);

      /* Just copy in the offset table directly as given to us.  */
      objfile->num_sections = num_offsets;
      objfile->section_offsets
        = ((struct section_offsets *)
           obstack_alloc (&objfile->psymbol_obstack, size));
      memcpy (objfile->section_offsets, offsets, size);
d699 1
a699 4
      init_objfile_sect_indices (objfile);
    }

#ifndef DEPRECATED_IBM6000_TARGET
d733 1
a733 1
	         !s_addr && i < addrs->num_sections && addrs->other[i].name;
d747 1
a747 1
#endif /* not DEPRECATED_IBM6000_TARGET */
d751 7
d774 7
d815 4
a818 9

   FROM_TTY says how verbose to be.

   MAINLINE specifies whether this is the main symbol file, or whether
   it's an extra symbol file such as dynamically loaded code.

   ADDRS, OFFSETS, and NUM_OFFSETS are as described for
   syms_from_objfile, above.  ADDRS is ignored when MAINLINE is
   non-zero.
d822 4
a825 6
static struct objfile *
symbol_file_add_with_addrs_or_offsets (char *name, int from_tty,
                                       struct section_addr_info *addrs,
                                       struct section_offsets *offsets,
                                       int num_offsets,
                                       int mainline, int flags)
a828 1
  char *debugfile;
a829 2
  struct section_addr_info *orig_addrs;
  struct cleanup *my_cleanups;
a843 10
  orig_addrs = alloc_section_addr_info (bfd_count_sections (abfd));
  my_cleanups = make_cleanup (xfree, orig_addrs);
  if (addrs)
    {
      int i;
      orig_addrs->num_sections = addrs->num_sections;
      for (i = 0; i < addrs->num_sections; i++)
	orig_addrs->other[i] = addrs->other[i];
    }

d855 1
a855 1
	  printf_unfiltered ("Mapped symbols for %s...", name);
d873 1
a873 1
	      printf_unfiltered ("Reading symbols from %s...", name);
d878 1
a878 2
      syms_from_objfile (objfile, addrs, offsets, num_offsets,
                         mainline, from_tty);
d890 1
a890 1
	  printf_unfiltered ("expanding to full symbols...");
a902 30
  debugfile = find_separate_debug_file (objfile);
  if (debugfile)
    {
      if (addrs != NULL)
	{
	  objfile->separate_debug_objfile
            = symbol_file_add (debugfile, from_tty, orig_addrs, 0, flags);
	}
      else
	{
	  objfile->separate_debug_objfile
            = symbol_file_add (debugfile, from_tty, NULL, 0, flags);
	}
      objfile->separate_debug_objfile->separate_debug_objfile_backlink
        = objfile;
      
      /* Put the separate debug object before the normal one, this is so that
         usage of the ALL_OBJFILES_SAFE macro will stay safe. */
      put_objfile_before (objfile->separate_debug_objfile, objfile);
      
      xfree (debugfile);
    }
  
  if (!have_partial_symbols () && !have_full_symbols ())
    {
      wrap_here ("");
      printf_unfiltered ("(no debugging symbols found)...");
      wrap_here ("");
    }

d909 2
a910 1
	  printf_unfiltered ("done.\n");
a913 7
  /* We print some messages regardless of whether 'from_tty ||
     info_verbose' is true, so make sure they go out at the right
     time.  */
  gdb_flush (gdb_stdout);

  do_cleanups (my_cleanups);

a924 13

/* Process a symbol file, as either the main file or as a dynamically
   loaded file.  See symbol_file_add_with_addrs_or_offsets's comments
   for details.  */
struct objfile *
symbol_file_add (char *name, int from_tty, struct section_addr_info *addrs,
		 int mainline, int flags)
{
  return symbol_file_add_with_addrs_or_offsets (name, from_tty, addrs, 0, 0, 
                                                mainline, flags);
}


a980 138
static char *
get_debug_link_info (struct objfile *objfile, unsigned long *crc32_out)
{
  asection *sect;
  bfd_size_type debuglink_size;
  unsigned long crc32;
  char *contents;
  int crc_offset;
  unsigned char *p;
  
  sect = bfd_get_section_by_name (objfile->obfd, ".gnu_debuglink");

  if (sect == NULL)
    return NULL;

  debuglink_size = bfd_section_size (objfile->obfd, sect);
  
  contents = xmalloc (debuglink_size);
  bfd_get_section_contents (objfile->obfd, sect, contents,
			    (file_ptr)0, (bfd_size_type)debuglink_size);

  /* Crc value is stored after the filename, aligned up to 4 bytes. */
  crc_offset = strlen (contents) + 1;
  crc_offset = (crc_offset + 3) & ~3;

  crc32 = bfd_get_32 (objfile->obfd, (bfd_byte *) (contents + crc_offset));
  
  *crc32_out = crc32;
  return contents;
}

static int
separate_debug_file_exists (const char *name, unsigned long crc)
{
  unsigned long file_crc = 0;
  int fd;
  char buffer[8*1024];
  int count;

  fd = open (name, O_RDONLY | O_BINARY);
  if (fd < 0)
    return 0;

  while ((count = read (fd, buffer, sizeof (buffer))) > 0)
    file_crc = gnu_debuglink_crc32 (file_crc, buffer, count);

  close (fd);

  return crc == file_crc;
}

static char *debug_file_directory = NULL;

#if ! defined (DEBUG_SUBDIRECTORY)
#define DEBUG_SUBDIRECTORY ".debug"
#endif

static char *
find_separate_debug_file (struct objfile *objfile)
{
  asection *sect;
  char *basename;
  char *dir;
  char *debugfile;
  char *name_copy;
  bfd_size_type debuglink_size;
  unsigned long crc32;
  int i;

  basename = get_debug_link_info (objfile, &crc32);

  if (basename == NULL)
    return NULL;
  
  dir = xstrdup (objfile->name);

  /* Strip off the final filename part, leaving the directory name,
     followed by a slash.  Objfile names should always be absolute and
     tilde-expanded, so there should always be a slash in there
     somewhere.  */
  for (i = strlen(dir) - 1; i >= 0; i--)
    {
      if (IS_DIR_SEPARATOR (dir[i]))
	break;
    }
  gdb_assert (i >= 0 && IS_DIR_SEPARATOR (dir[i]));
  dir[i+1] = '\0';
  
  debugfile = alloca (strlen (debug_file_directory) + 1
                      + strlen (dir)
                      + strlen (DEBUG_SUBDIRECTORY)
                      + strlen ("/")
                      + strlen (basename) 
                      + 1);

  /* First try in the same directory as the original file.  */
  strcpy (debugfile, dir);
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      xfree (basename);
      xfree (dir);
      return xstrdup (debugfile);
    }
  
  /* Then try in the subdirectory named DEBUG_SUBDIRECTORY.  */
  strcpy (debugfile, dir);
  strcat (debugfile, DEBUG_SUBDIRECTORY);
  strcat (debugfile, "/");
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      xfree (basename);
      xfree (dir);
      return xstrdup (debugfile);
    }
  
  /* Then try in the global debugfile directory.  */
  strcpy (debugfile, debug_file_directory);
  strcat (debugfile, "/");
  strcat (debugfile, dir);
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      xfree (basename);
      xfree (dir);
      return xstrdup (debugfile);
    }
  
  xfree (basename);
  xfree (dir);
  return NULL;
}


d1018 1
a1018 1
	  if (strcmp (*argv, "-mapped") == 0)
d1021 1
a1021 1
	    if (strcmp (*argv, "-readnow") == 0)
d1177 4
d1403 5
a1407 5
  /* FIXME: are we supposed to call symbol_file_add or not?  According
     to a comment from remote-mips.c (where a call to symbol_file_add
     was commented out), making the call confuses GDB if more than one
     file is loaded in.  Some targets do (e.g., remote-vx.c) but
     others don't (or didn't - perhaphs they have all been deleted).  */
d1465 1
d1480 1
a1480 1
  struct sect_opt
d1484 1
a1484 1
  };
d1486 1
a1486 3
  struct section_addr_info *section_addrs;
  struct sect_opt *sect_opts = NULL;
  size_t num_sect_opts = 0;
a1488 4
  num_sect_opts = 16;
  sect_opts = (struct sect_opt *) xmalloc (num_sect_opts 
					   * sizeof (struct sect_opt));

d1497 3
d1532 1
a1532 8
	    if (++section_index > num_sect_opts) 
	      {
		num_sect_opts *= 2;
		sect_opts = ((struct sect_opt *) 
			     xrealloc (sect_opts,
				       num_sect_opts 
				       * sizeof (struct sect_opt)));
	      }
d1549 2
d1567 1
a1567 8
		      if (++section_index > num_sect_opts) 
			{
			  num_sect_opts *= 2;
			  sect_opts = ((struct sect_opt *) 
				       xrealloc (sect_opts,
						 num_sect_opts 
						 * sizeof (struct sect_opt)));
			}
d1582 1
a1582 3
  printf_unfiltered ("add symbol table from file \"%s\" at\n", filename);
  section_addrs = alloc_section_addr_info (section_index);
  make_cleanup (xfree, section_addrs);
d1589 5
a1593 1
      addr = parse_and_eval_address (val);
d1597 3
a1599 3
      section_addrs->other[sec_num].name = sec;
      section_addrs->other[sec_num].addr = addr;
      printf_unfiltered ("\t%s_addr = %s\n",
d1614 1
a1614 1
  symbol_file_add (filename, from_tty, section_addrs, 0, flags);
d1652 1
a1652 1
#ifdef DEPRECATED_IBM6000_TARGET
d1664 1
a1664 1
	      printf_unfiltered ("`%s' has disappeared; keeping its symbols.\n",
d1676 1
a1676 1
	      printf_unfiltered ("`%s' has changed; re-reading symbols.\n",
d1711 2
a1712 4
	      offsets = ((struct section_offsets *) 
			 alloca (SIZEOF_N_SECTION_OFFSETS (num_offsets)));
	      memcpy (offsets, objfile->section_offsets, 
		      SIZEOF_N_SECTION_OFFSETS (num_offsets));
a1733 5
	      if (objfile->demangled_names_hash != NULL)
		{
		  htab_delete (objfile->demangled_names_hash);
		  objfile->demangled_names_hash = NULL;
		}
a1741 1
	      objfile->sym_private = NULL;
a1747 1
	      clear_objfile_data (objfile);
a1769 1
              terminate_minimal_symbol_table (objfile);
d1774 2
a1775 4
		obstack_alloc (&objfile->psymbol_obstack, 
			       SIZEOF_N_SECTION_OFFSETS (num_offsets));
	      memcpy (objfile->section_offsets, offsets, 
		      SIZEOF_N_SECTION_OFFSETS (num_offsets));
d1798 1
a1798 1
		  printf_unfiltered ("(no debugging symbols found)\n");
d1819 7
a1825 1
              reread_separate_symbols (objfile);
a1832 67


/* Handle separate debug info for OBJFILE, which has just been
   re-read:
   - If we had separate debug info before, but now we don't, get rid
     of the separated objfile.
   - If we didn't have separated debug info before, but now we do,
     read in the new separated debug info file.
   - If the debug link points to a different file, toss the old one
     and read the new one.
   This function does *not* handle the case where objfile is still
   using the same separate debug info file, but that file's timestamp
   has changed.  That case should be handled by the loop in
   reread_symbols already.  */
static void
reread_separate_symbols (struct objfile *objfile)
{
  char *debug_file;
  unsigned long crc32;

  /* Does the updated objfile's debug info live in a
     separate file?  */
  debug_file = find_separate_debug_file (objfile);

  if (objfile->separate_debug_objfile)
    {
      /* There are two cases where we need to get rid of
         the old separated debug info objfile:
         - if the new primary objfile doesn't have
         separated debug info, or
         - if the new primary objfile has separate debug
         info, but it's under a different filename.
 
         If the old and new objfiles both have separate
         debug info, under the same filename, then we're
         okay --- if the separated file's contents have
         changed, we will have caught that when we
         visited it in this function's outermost
         loop.  */
      if (! debug_file
          || strcmp (debug_file, objfile->separate_debug_objfile->name) != 0)
        free_objfile (objfile->separate_debug_objfile);
    }

  /* If the new objfile has separate debug info, and we
     haven't loaded it already, do so now.  */
  if (debug_file
      && ! objfile->separate_debug_objfile)
    {
      /* Use the same section offset table as objfile itself.
         Preserve the flags from objfile that make sense.  */
      objfile->separate_debug_objfile
        = (symbol_file_add_with_addrs_or_offsets
           (debug_file,
            info_verbose, /* from_tty: Don't override the default. */
            0, /* No addr table.  */
            objfile->section_offsets, objfile->num_sections,
            0, /* Not mainline.  See comments about this above.  */
            objfile->flags & (OBJF_MAPPED | OBJF_REORDERED
                              | OBJF_SHARED | OBJF_READNOW
                              | OBJF_USERLOADED)));
      objfile->separate_debug_objfile->separate_debug_objfile_backlink
        = objfile;
    }
}


d1952 3
d1998 1
a1998 1
  struct symtab *symtab;
d2237 3
a2239 3
  struct symtab *s;
  struct symtab *prev;
  struct partial_symtab *ps;
d2256 1
a2256 1
      if (strcmp (name, ps->filename) == 0)
d2267 1
a2267 1
      if (strcmp (name, s->filename) == 0)
d2349 1
a2349 2
   Since one arg is a struct, we pass in a ptr and deref it (sigh).  
   Return the partial symbol that has been added.  */
d2351 2
a2352 13
/* NOTE: carlton/2003-09-11: The reason why we return the partial
   symbol is so that callers can get access to the symbol's demangled
   name, which they don't have any cheap way to determine otherwise.
   (Currenly, dwarf2read.c is the only file who uses that information,
   though it's possible that other readers might in the future.)
   Elena wasn't thrilled about that, and I don't blame her, but we
   couldn't come up with a better way to get that information.  If
   it's needed in other situations, we could consider breaking up
   SYMBOL_SET_NAMES to provide access to the demangled name lookup
   cache.  */

const struct partial_symbol *
add_psymbol_to_list (char *name, int namelength, domain_enum domain,
d2358 1
a2358 1
  struct partial_symbol *psym;
d2368 1
d2380 1
a2380 1
  PSYMBOL_DOMAIN (&psymbol) = domain;
d2382 1
a2382 2

  SYMBOL_SET_NAMES (&psymbol, buf, namelength, objfile);
d2385 1
a2385 2
  psym = deprecated_bcache (&psymbol, sizeof (struct partial_symbol),
			    objfile->psymbol_cache);
a2393 2

  return psym;
d2402 1
a2402 1
				   int dem_namelength, domain_enum domain,
d2409 1
a2409 1
  struct partial_symbol *psym;
d2420 1
a2420 2
  DEPRECATED_SYMBOL_NAME (&psymbol) = deprecated_bcache (buf, namelength + 1,
							 objfile->psymbol_cache);
d2431 1
a2431 1
	deprecated_bcache (buf, dem_namelength + 1, objfile->psymbol_cache);
d2433 4
d2451 1
a2451 1
  PSYMBOL_DOMAIN (&psymbol) = domain;
d2456 1
a2456 2
  psym = deprecated_bcache (&psymbol, sizeof (struct partial_symbol),
			    objfile->psymbol_cache);
d2476 1
a2476 1
      xmfree (objfile->md, objfile->global_psymbols.list);
d2480 1
a2480 1
      xmfree (objfile->md, objfile->static_psymbols.list);
d2696 1
a2696 1
static int
d2898 1
a2898 1
	    printf_unfiltered ("Note: section %s unmapped by overlap\n",
d2948 1
a2948 1
    printf_unfiltered ("Automatic overlay debugging enabled.");
d2961 1
a2961 1
    printf_unfiltered ("Overlay debugging enabled.");
d2974 1
a2974 1
    printf_unfiltered ("Overlay debugging disabled.");
a3251 39
/* Set the output sections and output offsets for section SECTP in
   ABFD.  The relocation code in BFD will read these offsets, so we
   need to be sure they're initialized.  We map each section to itself,
   with no offset; this means that SECTP->vma will be honored.  */

static void
symfile_dummy_outputs (bfd *abfd, asection *sectp, void *dummy)
{
  sectp->output_section = sectp;
  sectp->output_offset = 0;
}

/* Relocate the contents of a debug section SECTP in ABFD.  The
   contents are stored in BUF if it is non-NULL, or returned in a
   malloc'd buffer otherwise.

   For some platforms and debug info formats, shared libraries contain
   relocations against the debug sections (particularly for DWARF-2;
   one affected platform is PowerPC GNU/Linux, although it depends on
   the version of the linker in use).  Also, ELF object files naturally
   have unresolved relocations for their debug sections.  We need to apply
   the relocations in order to get the locations of symbols correct.  */

bfd_byte *
symfile_relocate_debug_section (bfd *abfd, asection *sectp, bfd_byte *buf)
{
  /* We're only interested in debugging sections with relocation
     information.  */
  if ((sectp->flags & SEC_RELOC) == 0)
    return NULL;
  if ((sectp->flags & SEC_DEBUGGING) == 0)
    return NULL;

  /* We will handle section offsets properly elsewhere, so relocate as if
     all sections begin at 0.  */
  bfd_map_over_sections (abfd, symfile_dummy_outputs, NULL);

  return bfd_simple_get_relocated_section_contents (abfd, sectp, buf, NULL);
}
a3340 14

  debug_file_directory = xstrdup (DEBUGDIR);
  c = (add_set_cmd
       ("debug-file-directory", class_support, var_string,
        (char *) &debug_file_directory,
        "Set the directory where separate debug symbols are searched for.\n"
        "Separate debug symbols are first searched for in the same\n"
        "directory as the binary, then in the `" DEBUG_SUBDIRECTORY 
        "' subdirectory,\n"
        "and lastly at the path of the directory of the binary with\n"
        "the global debug-file directory prepended\n",
        &setlist));
  add_show_from_set (c, &showlist);
  set_cmd_completer (c, filename_completer);
@


1.69.4.4
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d202 14
d502 1
a502 1
    obstack_alloc (&objfile->objfile_obstack, 
d707 1
a707 1
           obstack_alloc (&objfile->objfile_obstack, size));
d864 4
a867 4
  /* We either created a new mapped symbol table, mapped an existing
     symbol table file which has not had initial symbol reading
     performed, or need to read an unmapped symbol table. */
  if (from_tty || info_verbose)
d869 5
a873 3
      if (pre_add_symbol_hook)
	pre_add_symbol_hook (name);
      else
d875 1
a875 1
	  printf_unfiltered ("Reading symbols from %s...", name);
d879 21
a900 2
  syms_from_objfile (objfile, addrs, offsets, num_offsets,
		     mainline, from_tty);
d1226 14
a1239 10
	  if (strcmp (*argv, "-readnow") == 0)
	    flags |= OBJF_READNOW;
	  else if (**argv == '-')
	    error ("unknown option `%s'", *argv);
	  else
	    {
	      name = *argv;
	      
	      symbol_file_add_main_1 (name, from_tty, flags);
	    }
d1754 11
a1764 7
		if (strcmp (arg, "-readnow") == 0)
		  flags |= OBJF_READNOW;
		else if (strcmp (arg, "-s") == 0)
		  {
		    expecting_sec_name = 1;
		    expecting_sec_addr = 1;
		  }
d1925 1
a1925 1
	         objfile_obstack.  */
d1957 3
a1959 1
	      obstack_free (&objfile->objfile_obstack, 0);
a1963 1
	      objfile->cp_namespace_symtab = NULL;
d1984 5
a1988 1
	      obstack_specify_allocation (&objfile->objfile_obstack, 0, 0,
d2000 1
a2000 1
		obstack_alloc (&objfile->objfile_obstack, 
d2113 2
a2114 1
            objfile->flags & (OBJF_REORDERED | OBJF_SHARED | OBJF_READNOW
d2287 1
a2287 1
    obstack_alloc (&objfile->objfile_obstack, sizeof (struct symtab));
d2290 1
a2290 1
				   &objfile->objfile_obstack);
d2294 1
a2294 1
				      &objfile->objfile_obstack);
d2325 1
a2325 1
      obstack_alloc (&objfile->objfile_obstack,
d2330 1
a2330 1
				    &objfile->objfile_obstack);
d2479 1
a2479 1
         filename, which are all in the objfile_obstack.  */
@


1.69.2.1
log
@2002-09-18  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h: Delete BLOCK_SHOULD_SORT.
	* symtab.c (lookup_block_symbol): Assume non-hashed blocks aren't
	sorted.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.h: Delete prototypes for sort_block_syms and
	sort_symtab_syms.
	* symfile.c: Delete functions sort_block_syms and
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Remove call to
	sort_symtab_syms.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.

2002-09-20  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (c-lang.o): Correct dependencies.
	(utils.o): Gather dependencies.
	(charset.o): Move.
@
text
@d264 32
@


1.69.2.2
log
@2002-09-20  David Carlton  <carlton@@math.stanford.edu>

	* jv-lang.c (get_java_class_symtab): Use xmalloc to allocate
	GLOBAL_BLOCK rather than xmmalloc.
	(free_class_block): Use xfree rather than xmfree.
	* mdebugread.c: #include "dictionary.h"
	(new_block): Remove argument.  Initialize BLOCK_DICT.
	(parse_symbol): Update call to new_block.
	(new_symtab): Ditto.
	(fixup_sigtramp): Ditto.
	Delete MAXSYMS member of struct parse_stack.
	(psymtab_to_symtab_1): Don't set maxsyms.
	(new_symtab): Remove maxsyms argument.
	(psymtab_to_symtab_1): Update call to new_symtab.
	(shrink_block): Delete function.
	(add_symbol): Add symbols via dict_add_symbol_block.
	* jv-lang.c (add_class_symtab_symbol): Add symbols via
	dict_add_symbol_block.
	Delete variable class_symtab_space.
	* Makefile.in (jv-lang.o): Add dictionary_h.
	* jv-lang.c: #include "dictionary.h"
	* symmisc.c (free_symtab): Call free_func rather than freeing free_ptr.
	* jv-lang.c (get_java_class_symtab): Initialize free_func rather
	than free_ptr.
	(free_class_block): New function.
	(add_class_symtab_symbol): Delete reference to free_ptr.
	* buildsym.c (end_symtab): Initialize free_func rather than free_ptr.
	* symtab.h (struct symtab): Replace free_ptr by free_func.
	* jv-lang.c (get_java_class_symtab): Add DICT_BLOCK assignments.
	* Makefile.in (buildsym.o): Add dictionary_h.
	* buildsym.c (finish_block): Initialize BLOCK_DICT (block).
	#include "dictionary.h"
	* symtab.h (struct block): Add 'dict' member.
	(BLOCK_DICT): New macro.
	* dictionary.c: New file.
	* dictionary.h: New file.
	* Makefile.in (SFILES): Add dictionary.c
	(dictionary_h): New variable.
	(COMMON_OBS): Add dictionary.o.
	(dictionary.o): New rule.
	(carlton): New rule.
@
text
@d1958 1
a1958 1
   symtab->free_func
@


1.69.2.3
log
@2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c (struct dict_vtbl): 'add_symbol' field.
	(add_symbol_generic): New function.
	(free_obstack): New function.
	(dict_create_hashed): New function.
	(lookup_hashed): New function.
	(iterator_first_hashed): New function.
	(iterator_hashed_advance): New function.
	(iterator_next_hashed): New function.
	* dictionary.h: A few more declarations.
	* mdebugread.c (parse_symbol): Use dict_iterator when finding
	parameters.
	* Makefile.in (valops.o): Depend on dictionary_h.
	* valops.c (value_of_this): Check empty block via dict_empty.
	#include "dictionary.h"
	* symfile.c (free_named_symtabs): Check empty block via dict_empty.
	* dictionary.h: Declare dict_empty.
	* symmisc.c (dump_symtab): Don't print out number of
	symbols/buckets.
	* printcmd.c (print_frame_args): Delete assertion that block isn't
	a hashtable.
	* symmisc.c (free_symtab_block): Update to use dictionary
	methods.
	* symtab.h (struct symtab): Comment on free_contents.
	* jv-lang.c (get_java_class_symtab): Set class_symtab->free_code.
	* mdebugread.c (add_symbol): Delete 'nsyms' variable.
	(fixup_sigtramp): Add symbol via dict_add_symbol_block.
	* Makefile.in (mi-cmd-stack.o): Depend on dictionary_h.
	* ada-lang.c (symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(ada_add_block_symbols): Ditto.
	(debug_print_block): Ditto.
	(fill_in_ada_prototype): Ditto.
	* breakpoint.c (get_catch_sals): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	(scope_info): Ditto.
	* symtab.c (find_pc_sect_symtab): Ditto.
	(search_symbols): Ditto.
	(make_symbol_completion_list): Ditto.
	(find_addr_symbol): Ditto.
	(make_file_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* symmisc.c (dump_symtab): Ditto.
	* stack.c (print_block_frame_locals): Ditto.
	(print_block_frame_labels): Ditto.
	(print_frame_arg_vars): Ditto.
	* printcmd.c (print_frame_args): Ditto.
	* objfiles.c (objfile_relocate): Ditto.
	* mdebugread.c (mylookup_symbol): Ditto.
	* Makefile.in (ada-lang.o): Depend on dictionary_h.
	* Makefile.in (tracepoint.o): Ditto.
	* Makefile.in (symmisc.o): Ditto.
	* Makefile.in (stack.o): Ditto.
	* Makefile.in (printcmd.o): Ditto.
	* Makefile.in (objfiles.o): Ditto.
	* Makefile.in (coffread.o): Ditto.
	* Makefile.in (breakpoint.o): Ditto.
	* ada-lang.c: #include "dictionary.h"
	* tracepoint.c: Ditto.
	* symmisc.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* coffread.c: Ditto.
	* breakpoint.c: Ditto.
	* symtab.h: Comment out ALL_BLOCK_SYMBOLS.  (Moved to
	dictionary.h.)
	* dictionary.c: Dict_iterator accessor macros.
	(struct dict_vtbl): Add iterator_first, iterator_next.
	(dict_iterator_first): New function.
	(dict_iterator_next): New function.
	(iterator_first_block): New function.
	(iterator_next_block): New function.
	(iterator_block_hashed_advance): New function.
	* dictionary.h: Add dict_iterator stuff.
	* Makefile.in (symtab.o): Depend on dictionary_h.
	* symtab.c: #include "dictionary.h"
	* dictionary.c: Move down #include "dictionary.h", for now...
	(free_block): Rename from dict_free_block.
	(struct dict_vtbl): Add LOOKUP member.
	(dict_lookup): New function.
	(lookup_block): New function.
	* dictionary.h: Declare dict_lookup.
	* symtab.c (lookup_block_symbol): Use dict_lookup.

2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c (list_args_or_locals): Update use of
	ALL_BLOCK_SYMBOLS.
	#include "dictionary.h"
@
text
@d2258 2
a2259 4
	  || ! dict_empty (BLOCK_DICT (BLOCK_NSYMS (BLOCKVECTOR_BLOCK
						    (bv, GLOBAL_BLOCK))))
	  || ! dict_empty (BLOCK_DICT (BLOCK_NSYMS (BLOCKVECTOR_BLOCK
						    (bv, STATIC_BLOCK)))))
@


1.69.2.4
log
@2002-09-24  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c: Comment out block-specific stuff.
	* jv-lang.c (get_java_class_symtab): Allocate GLOBAL_BLOCK on
	obstack.
	(free_class_block): Don't free GLOBAL_BLOCK.
	* dictionary.h: Comment out block-specific stuff.
	* symtab.h: Comment out the members of struct block that
	BLOCK_DICT obsoletes, and their accessors.
	* Makefile.in (buildsym.o): Depend on gdb_assert_h.
	* buildsym.c (finish_block): Don't count number of symbols.
	(finish_block): Replace BLOCK_SYM reference with use of iterator.
	#include "gdb_assert.h"
	* symfile.c (free_named_symtabs): Fix calls to dict_empty
	(which would seem to be #if'd out; oops...).
	* buildsym.c (finish_block): Don't set BLOCK_HASHTABLE.
	* jv-lang.c (get_java_class_symtab): Don't set BLOCK_HASHTABLE and
	BLOCK_NSYMS.
	* mdebugread.c (new_block): Allocate BLOCK_DICT via
	dict_create_linear_expandable.
	(add_symbol): Add symbol via dict_add_symbol; no need to chase
	pointers.
	(fixup_sigtramp): Add symbol via dict_add_symbol.
	(new_symtab): Add FIXME comment on freeing blocks.
	* jv-lang.c (get_java_class_symtab): Allocate GLOBAL_BLOCK's dict
	using dict_create_linear_expandable.
	(add_class_symtab_symbol): Add symbol using dict_add_symbol.
	* dictionary.c (struct dictionary_linear_expandable): New struct.
	(struct dictionary): Added member 'linear_expandable'.
	(DICT_LINEAR_EXPANDABLE_MAXSYMS): New macro.
	New variable dict_block_vtbl.  Made all the _vtbl variables static.
	Renamed all 'maxsyms' to 'capacity'.
	(dict_create_linear_expandable): New function.
	(add_symbol_linear_expandable): New function.
	(free_linear_expandable): New function.
	* jv-lang.c (get_java_class_symtab): Create static block's
	dictionary with dict_create_linear.
	* buildsym.c (finish_block): Create function blocks' dictionaries
	with dict_create_linear.
	* dictionary.c (lookup_linear): New function.
	(iterator_first_linear): New function.
	(iterator_next_linear): New function.
	* dictionary.h: Moved comment.
	* dictionary.c (struct dictionary_linear): New struct.
	(struct dictionary): Added 'linear' member.
	(DICT_LINEAR_NSYMS): New macro.
	(DICT_LINEAR_SYMS): New macro.
	(DICT_LINEAR_SYM): New macro.
	New variable dict_linear_vtbl.
	(dict_create_linear): New function.
@
text
@d2258 4
a2261 4
	  || ! dict_empty (BLOCK_DICT (BLOCKVECTOR_BLOCK
				       (bv, GLOBAL_BLOCK)))
	  || ! dict_empty (BLOCK_DICT (BLOCKVECTOR_BLOCK
				       (bv, STATIC_BLOCK))))
@


1.69.2.5
log
@2002-10-09  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Comment out cp_find_last_component and
	cp_locate_arguments.
	Add comments warning about pitfals involving demangled names.
	* buildsym.c (finish_block): Grab the namespace names from the
	front instead of from the back.
	* Makefile.in (cp-support.o): Depend on gdb_assert_h.
	* cp-support.c: #include "gdb_assert.h"
	* cp-support.h: Declare cp_find_first_component.
	* cp-support.c (cp_find_first_component): New function.
	* buildsym.c (finish_block): Don't add namespace using stuff
	unless there's a demangled name to work with.
	(finish_block): Delete unused variable 'j'.
	(finish_block): Move declaration of iter earlier to pacify GCC.

2002-10-08  David Carlton  <carlton@@math.stanford.edu>

	* symfile.c (obsavestring): Make first argument a const char *.
	* symfile.h: Add opaque declaration for 'struct obstack'.
	Make obsavestring take a const char * as its first argument.
	* Makefile.in (cp-support.o): Correct dependencies.
	* cp-support.h: Declare cp_add_using.
	* cp-support.c: #include "gdb_obstack.h"
	(cp_add_using): New function.
	* Makefile.in (buildsym.o): Depend on $(cp_support_h).
	* buildsym.c (finish_block): Add 'using' directives for
	functions.
	#include "cp-support.h"
	* cp-support.h: Add function declarations.
	* cp-support.c (cp_locate_arguments): New function.
	(cp_find_last_component): New function.
	* symtab.h (struct block): Add comment.
@
text
@d270 1
a270 1
obsavestring (const char *ptr, int size, struct obstack *obstackp)
d277 1
a277 1
    register const char *p1 = ptr;
d279 1
a279 1
    const char *end = ptr + size;
@


1.69.2.6
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a26 1
#include "block.h"
@


1.69.2.7
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@a1923 1
      add_filename_language (".m", language_objc);
@


1.69.2.8
log
@2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (add_partial_enumeration): New function.
	(scan_partial_symbols): Call add_partial_enumeration.
	(locate_pdi_sibling): New function.
	(scan_partial_symbols): Call locate_pdi_sibling.  Get rid of
	nesting_level.
	(pdi_needs_namespace): New function.
	(add_partial_symbol): Add 'namespace' arg; calculate full name
	when appropriate.
	(scan_partial_symbols): Update calls to add_partial_symbol.
	(add_partial_enumeration): Ditto.
	(read_enumeration): Add processing_current_prefix to name when
	appropriate.
	(new_symbol): Set names of enumerators and typedefs appropriately
	if processing_has_namespace_info.
	* symtab.c (lookup_symbol_namespace): Rename 'namespace' argument
	to 'namespace_name'.
	* symtab.h: Ditto.
	* symtab.c (lookup_symbol_namespace): Delete FIXME comments; add a
	new one.
	(lookup_symbol_aux_file): New function.
	(lookup_symbol_aux): Delete FIXME comment.
	(lookup_symbol_aux): Don't search static block explicitly; delete
	FIXME comments.
	* valops.c (value_namespace_elt): Update call to
	lookup_symbol_namespace.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* symtab.c (lookup_symbol_namespace): Delete 'using' argument and
	add 'block' argument; get using directives via iterators.
	(lookup_symbol_aux_using_loop): Delete 'using' argument and add
	'block' argument.
	(lookup_symbol_aux_using): Don't calculate using directives.
	* block.c (block_using_iterator_first): New function.
	(block_using_iterator_next): Ditto.
	* block.h: Add comment.
	(struct block_using_iterator): New struct.
	Declare block_using_iterator_first, block_using_iterator_next.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Set type name and
	processing_current_prefix appropriately.
	(new_symbol): Make sure that, in symbols associated to class
	types, the name includes appropriate namespaces.
	* buildsym.h: Rename processing_current_namespace to
	processing_current_prefix.
	* buildsym.c (finish_block): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	(read_namespace): Ditto.  Also rename previous_namespace to
	previous_prefix.

	Now come a thousand and one const correctness fixes:
	* p-typeprint.c (pascal_print_type): Const.
	(pascal_type_print_method_args): Const.
	* p-lang.h: Const.
	* m2-typeprint.c (m2_print_type): Const.
	* valops.c (hand_function_call): Const.
	* jv-lang.c (java_primitive_type_from_name): Const.
	* jv-lang.h: Const.
	* jv-typeprint.c (java_print_type): Const.
	* language.c: (unk_lang_print_type): Const.
	* stack.c (frame_info): Const.
	* linespec.c (find_methods): Const.
	(find_method_name): Const
	* f-lang.h: Const.
	* f-typeprint.c (f_print_type): Const.
	* c-typeprint.c (c_print_type): Const.
	* c-lang.h: Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (lookup_primitive_typename): Const.
	* stack.c (print_frame): Const.
	(func_command): Delete pointless cast.
	* linespec.c (find_method_name): Const.
	* language.h: Const.
	* symfile.c (compare_psymbols): Const.
	* symtab.c (completion_list_add_name): Const.
	* breakpoint.c (break_at_finish_at_depth_command_1): Remove
	useless cast.
	(break_at_finish_command_1): Ditto.
	* typeprint.c (type_print): Const.
	* symtab.h: Const.
	* symtab.c (gdb_mangle_name): Const.
	(symbol_init_demangled_name): Const.
	(symbol_demangled_name): Const.
	* defs.h: Const.
	* printcmd.c (build_address_symbolic): Const.
	* valops.c (search_struct_method): Const.
	* cp-valprint.c (cp_is_vtbl_ptr_type): Const.
	(cp_print_value): Const.
	(cp_print_class_member): Const.
	* c-typeprint.c (cp_type_print_derivation_info): Const.
	(c_type_print_varspec_prefix): Const.
	(c_type_print_base): Const.
	* p-valprint.c (pascal_object_is_vtbl_ptr_type): Const.
	(pascal_object_print_value): Const.
	(pascal_object_print_class_member): Const.
	* p-typeprint.c (pascal_type_print_derivation_info): Const.
	(pascal_type_print_varspec_prefix): Const.
	(pascal_type_print_base): Const.
	* jv-typeprint.c (java_type_print_base): Const.
	* jv-lang.h (java_demangle_type_signature): Const.
	* jv-lang.c (java_demangle_type_signature): Const.
	(java_demangled_signature_length): Const.
	(java_demangled_signature_copy): Const.
	* jv-typeprint.c (java_type_print_derivation_info): Const.
	* jv-valprint.c (java_value_print): Const.
	(java_print_value_fields): Const.
	* jv-lang.c (is_object_type): Const.
	(evaluate_subexp_java): Const.
	* stabsread.c (read_cpp_abbrev): Const.
	(complain_about_struct_wipeout): Const.
	(cleanup_undefined_types): Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (add_name): Second arg const.
	(lookup_typename): Const.
	(lookup_unsigned_typename): Const.
	(lookup_signed_typename): Const.
	* linespec.c (find_methods): const char *class_name.
	* symtab.c (gdb_mangle_name): const char *newname.
	* valops.c (destructor_name_p): const char *dname.
	(search_struct_field): First arg const.
	* gdbtypes.c (check_typedef): const char *name (multiple places).
	(cfront_mangle_name): const char *newname.
	* gdbtypes.c (add_mangled_type): const char *tname.
	* valops.c (find_overload_match): const char *obj_type_name.
	* utils.c (gdb_print_host_address): Make first arg const.
	* defs.h: Declare first arg of gdb_print_host_address to be
	const.
	* valarith.c (find_size_for_pointer_math): const char *name.

2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/m-data.cc (main): Add marker comment.
	* gdb.c++/m-data.exp: Use marker comment instead of line numbers.
	* gdb.c++/m-data.cc: Delete superfluous namespace.
	* gdb.c++/m-static.cc: Ditto.
	* gdb.c++/m-static1.cc: Ditto.
	* carlton_runtest: Compare based on gdb.sum, not based on output.
	* carlton_runnamespace: Ditto.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Put tests for CClass.
	* gdb.c++/namespace.cc (C): Add CClass.
@
text
@d233 1
a233 1
  register const char *st1, *st2;
@


1.69.2.9
log
@2002-12-18  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_file): Call
	cp_lookup_possible_namespace_symbol.
	* dwarf2read.c (add_partial_symbol): Sometimes check for possible
	namespace symbols.
	* cp-support.c (maintenance_print_namespace): Handle
	possible_namespace_block, too.
	(cp_lookup_possible_namespace_symbol): New function.
	* cp-support.h: Declare cp_check_possible_namespace_symbols,
	cp_lookup_possible_namespace_symbol.
	* cp-support.c (check_one_possible_namespace_symbol): New
	function.
	(cp_check_possible_namespace_symbols): New function.
	(check_possible_namespace_symbols_loop): New function.
	* symfile.h: Update declaration for add_psymbol_to_list.
	* symfile.c (psymbol_init_demangled_name): New function.
	(add_psymbol_to_list): Change SYMBOL_INIT_LANGUAGE_SPECIFIC to
	psymbol_init_demangled_name.
	(add_psymbol_to_list): Return a const struct psymbol *.
	* Makefile.in (dwarf2read.o): Don't depend on bcache_h.
	* dwarf2read.c: Don't #include "bcache.h"
	* cp-support.c (get_namespace_block): Allocate blocks via
	allocate_block.
	(initialize_namespace_blocks): New function.
	New variable possible_namespace_block.
	(get_namespace_block): Call initialize_namespace_blocks.
	(free_namespace_blocks): Rename from free_namespace_block; handle
	possible_namespace_block, too.
	(get_possible_namespace_block): New function.
	* jv-lang.c (get_java_class_symtab): Ditto.
	* block.c (allocate_block): New function.
	* block.h: Declare allocate_block.
@
text
@a116 3
static void psymbol_init_demangled_name (struct partial_symbol *psymbol,
					 struct bcache *bcache);

d2322 1
a2322 6
/* NOTE: carlton/2002-12-18: I've modified this function to return the
   partial symbol in question.  But pay heed to the 'const' qualifier
   in front: these partial symbols are stored in a bcache, and bad
   things will happen if you modify them.  */

const struct partial_symbol *
d2353 1
a2353 1
  psymbol_init_demangled_name (&psymbol, objfile->psymbol_cache);
a2364 47

  return psym;
}

/* Initialize the demangled name for PSYMBOL, using bcache CACHE to
   store the demangle name if necessary.  */

static void
psymbol_init_demangled_name (struct partial_symbol *psymbol,
			     struct bcache *cache)
{
  const char *mangled = SYMBOL_NAME (psymbol);
  char *demangled = NULL;

  SYMBOL_CPLUS_DEMANGLED_NAME (psymbol) = NULL;

  if (SYMBOL_LANGUAGE (psymbol) == language_unknown)
    SYMBOL_LANGUAGE (psymbol) = language_auto;

  switch (SYMBOL_LANGUAGE (psymbol))
    {
    case language_cplus:
    case language_auto:
      demangled = cplus_demangle (SYMBOL_NAME (psymbol),
				  DMGL_PARAMS | DMGL_ANSI);
      if (demangled != NULL)
	{
	  SYMBOL_LANGUAGE (psymbol) = language_cplus;
	  SYMBOL_CPLUS_DEMANGLED_NAME (psymbol)
	    = bcache (demangled, strlen (demangled) + 1, cache);
	  xfree (demangled);
	}
      break;
    case language_java:
      demangled =
	cplus_demangle (SYMBOL_NAME (psymbol),
			DMGL_PARAMS | DMGL_ANSI | DMGL_JAVA);
      if (demangled != NULL)
	{
	  SYMBOL_LANGUAGE (psymbol) = language_java;
	  SYMBOL_CPLUS_DEMANGLED_NAME (psymbol)
	    = bcache (demangled, strlen (demangled) + 1, cache);
	  xfree (demangled);
	}
    default:
      break;
    }
@


1.69.2.10
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@d207 1
a207 1
  return (strcmp (SYMBOL_BEST_NAME (*s1), SYMBOL_BEST_NAME (*s2)));
d240 2
a241 2
  st1 = SYMBOL_BEST_NAME (*s1);
  st2 = SYMBOL_BEST_NAME (*s2);
@


1.69.2.11
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a45 1
#include <readline/readline.h>
d448 9
a456 3
/* Initialize OBJFILE's sect_index_* members.  */
static void
init_objfile_sect_indices (struct objfile *objfile)
a457 1
  asection *sect;
d459 26
a484 1
  
a530 40

/* Parse the user's idea of an offset for dynamic linking, into our idea
   of how to represent it for fast symbol reading.  This is the default 
   version of the sym_fns.sym_offsets function for symbol readers that
   don't need to do anything special.  It allocates a section_offsets table
   for the objectfile OBJFILE and stuffs ADDR into all of the offsets.  */

void
default_symfile_offsets (struct objfile *objfile,
			 struct section_addr_info *addrs)
{
  int i;

  objfile->num_sections = SECT_OFF_MAX;
  objfile->section_offsets = (struct section_offsets *)
    obstack_alloc (&objfile->psymbol_obstack, SIZEOF_SECTION_OFFSETS);
  memset (objfile->section_offsets, 0, SIZEOF_SECTION_OFFSETS);

  /* Now calculate offsets for section that were specified by the
     caller. */
  for (i = 0; i < MAX_SECTIONS && addrs->other[i].name; i++)
    {
      struct other_sections *osp ;

      osp = &addrs->other[i] ;
      if (osp->addr == 0)
  	continue;

      /* Record all sections in offsets */
      /* The section_offsets in the objfile are here filled in using
         the BFD index. */
      (objfile->section_offsets)->offsets[osp->sectindex] = osp->addr;
    }

  /* Remember the bfd indexes for the .text, .data, .bss and
     .rodata sections. */
  init_objfile_sect_indices (objfile);
}


d627 1
a627 1
      /* Calculate offsets for the loadable sections.
d631 2
a632 2
         Adjust offsets if the segments are not contiguous.
         If the section is contiguous, its offset should be set to
d637 1
a637 1
      /* Calculate offsets for sections. */
d642 1
a642 2
 	      sect = bfd_get_section_by_name (objfile->obfd,
                                              addrs->other[i].name);
d645 1
a645 2
 		  addrs->other[i].addr
                    -= bfd_section_vma (objfile->obfd, sect);
d882 1
a884 5

  /* We print some messages regardless of whether 'from_tty ||
     info_verbose' is true, so make sure they go out at the right
     time.  */
  gdb_flush (gdb_stdout);
@


1.69.2.12
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (search_symbols): Update comment.
	(lookup_symbol): Don't demangle names.
	(lookup_symbol_minsym): Delete FIXME comment.
	(lookup_symbol_linkage): Add comment.
	(lookup_symbol_aux): Rename 'mangled_name' argument to
	'linkage_name'.
	(lookup_symbol_aux_local): Ditto.
	(lookup_symbol_aux_block): Ditto.
	(lookup_symbol_aux_nonlocal): Ditto.
	(lookup_symbol_aux_file): Ditto.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(lookup_symbol_aux_using): Ditto.
	(lookup_symbol_aux_using_loop): Ditto.
	(lookup_symbol_namespace): Ditto.
	(lookup_symbol_aux_minsyms): Ditto.
	* symfile.c (psymbol_init_demangled_name): Delete unnecessary
	variable, initialization.
@
text
@d2401 2
a2402 1
  char *demangled;
@


1.69.2.13
log
@2003-01-31  David Carlton  <carlton@@math.stanford.edu>

	From Jim Blandy  <jimb@@redhat.com>:

	Use a single, consistent representation for an empty minimal
	symbol table in an objfile.
	* objfiles.c (terminate_minimal_symbol_table): New function.
	(allocate_objfile): Call it.
	* objfiles.h (terminate_minimal_symbol_table): New declaration.
	(ALL_MSYMBOLS): No need to test whether (objfile)->msymbols is
	non-NULL.
	* minsyms.c (lookup_minimal_symbol_by_pc_section): To see whether
	objfile has minimal symbols, compare minimal_symbol_count to zero,
	instead of comparing msymbols with NULL.
	* objfiles.c (have_minimal_symbols): Same.
	* solib-sunos.c (solib_add_common_symbols): Call
	terminate_minimal_symbol_table.
	* symfile.c (reread_symbols): Same.

	* objfiles.h: Revert patch from 2003-01-27, to be replaced by
	similar patch from Jim Blandy.
	* objfiles.c (objfile_relocate): Ditto.
	* i386-linux-tdep.c (find_minsym_and_objfile): Ditto.
	* arm-linux-tdep.c (find_minsym_and_objfile): Ditto.
	* gdbtypes.h: Delete INTEGER_COERCION_BADNESS,
	FLOAT_COERCION_BADNESS.
	* gdbtypes.c (rank_one_type): Replace all uses of
	INTEGER_COERCION_BADNESS by INTEGER_CONVERSION_BADNESS.
	* valops.c (find_overload_match): Call cp_func_name.
	* cp-support.h: Declare cp_func_name.
	* cp-support.c (cp_func_name): New function.

2003-01-30  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (find_overload_match): Move code into
	find_oload_champ_namespace.
	(find_oload_champ_namespace): New function, which immediately gets
	eviscerated and turned into a call to
	find_oload_champ_namespace_loop.
	(find_oload_champ_namespace_loop): New function.
	* symtab.c (make_symbol_overload_list): Move entire body into
	make_symbol_overload_list_qualified.
	(make_symbol_overload_list_qualified): New.
	(read_in_psymtabs): New.
	(make_symbol_overload_list_qualified): Rewrite.
	(make_symbol_overload_list_using): New.
	(lookup_symbol_namespace): Use alloca, not xmalloc.
	(make_symbol_overload_list): Put some memory management stuff back
	in.
@
text
@a1758 1
              terminate_minimal_symbol_table (objfile);
@


1.69.2.14
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a25 1
#include "bfdlink.h"
a41 1
#include "filenames.h"		/* for DOSish file names */
a45 1
#include "hashtab.h"
a46 1
#include "gdb_assert.h"
a107 2
static void reread_separate_symbols (struct objfile *objfile);

d118 3
a154 2
static char *find_separate_debug_file (struct objfile *objfile);

d386 1
a386 1
find_lowest_section (bfd *abfd, asection *sect, void *obj)
d547 2
a548 20
   ADDRS is the list of section load addresses.  If the user has given
   an 'add-symbol-file' command, then this is the list of offsets and
   addresses he or she provided as arguments to the command; or, if
   we're handling a shared library, these are the actual addresses the
   sections are loaded at, according to the inferior's dynamic linker
   (as gleaned by GDB's shared library code).  We convert each address
   into an offset from the section VMA's as it appears in the object
   file, and then call the file's sym_offsets function to convert this
   into a format-specific offset table --- a `struct section_offsets'.
   If ADDRS is non-zero, OFFSETS must be zero.

   OFFSETS is a table of section offsets already in the right
   format-specific representation.  NUM_OFFSETS is the number of
   elements present in OFFSETS->offsets.  If OFFSETS is non-zero, we
   assume this is the proper table the call to sym_offsets described
   above would produce.  Instead of calling sym_offsets, we just dump
   it right into objfile->section_offsets.  (When we're re-reading
   symbols from an objfile, we don't have the original load address
   list any more; all we have is the section offset table.)  If
   OFFSETS is non-zero, ADDRS must be zero.
d557 2
a558 6
syms_from_objfile (struct objfile *objfile,
                   struct section_addr_info *addrs,
                   struct section_offsets *offsets,
                   int num_offsets,
		   int mainline,
                   int verbo)
d567 3
a569 1
  gdb_assert (! (addrs && offsets));
d571 1
a571 4
  /* If ADDRS and OFFSETS are both NULL, put together a dummy address
     list.  We now establish the convention that an addr of zero means
     no load address was specified. */
  if (! addrs && ! offsets)
a576 2
  /* Now either addrs or offsets is non-zero.  */

d623 1
a623 1
			       &lower_sect);
d649 24
a672 26
      if (addrs)
        for (i=0 ; i < MAX_SECTIONS && addrs->other[i].name; i++)
          {
            if (addrs->other[i].addr != 0)
              {
                sect = bfd_get_section_by_name (objfile->obfd,
                                                addrs->other[i].name);
                if (sect)
                  {
                    addrs->other[i].addr
                      -= bfd_section_vma (objfile->obfd, sect);
                    lower_offset = addrs->other[i].addr;
                    /* This is the index used by BFD. */
                    addrs->other[i].sectindex = sect->index ;
                  }
                else
                  {
                    warning ("section %s not found in %s",
                             addrs->other[i].name, 
                             objfile->name);
                    addrs->other[i].addr = 0;
                  }
              }
            else
              addrs->other[i].addr = lower_offset;
          }
d682 1
a682 15
  if (addrs)
    (*objfile->sf->sym_offsets) (objfile, addrs);
  else
    {
      size_t size = SIZEOF_N_SECTION_OFFSETS (num_offsets);

      /* Just copy in the offset table directly as given to us.  */
      objfile->num_sections = num_offsets;
      objfile->section_offsets
        = ((struct section_offsets *)
           obstack_alloc (&objfile->psymbol_obstack, size));
      memcpy (objfile->section_offsets, offsets, size);

      init_objfile_sect_indices (objfile);
    }
d736 7
d800 4
a803 9

   FROM_TTY says how verbose to be.

   MAINLINE specifies whether this is the main symbol file, or whether
   it's an extra symbol file such as dynamically loaded code.

   ADDRS, OFFSETS, and NUM_OFFSETS are as described for
   syms_from_objfile, above.  ADDRS is ignored when MAINLINE is
   non-zero.
d807 4
a810 6
static struct objfile *
symbol_file_add_with_addrs_or_offsets (char *name, int from_tty,
                                       struct section_addr_info *addrs,
                                       struct section_offsets *offsets,
                                       int num_offsets,
                                       int mainline, int flags)
a813 1
  char *debugfile;
a814 4
  struct section_addr_info orig_addrs;
  
  if (addrs)
    orig_addrs = *addrs;
d863 1
a863 2
      syms_from_objfile (objfile, addrs, offsets, num_offsets,
                         mainline, from_tty);
a887 30
  debugfile = find_separate_debug_file (objfile);
  if (debugfile)
    {
      if (addrs != NULL)
	{
	  objfile->separate_debug_objfile
            = symbol_file_add (debugfile, from_tty, &orig_addrs, 0, flags);
	}
      else
	{
	  objfile->separate_debug_objfile
            = symbol_file_add (debugfile, from_tty, NULL, 0, flags);
	}
      objfile->separate_debug_objfile->separate_debug_objfile_backlink
        = objfile;
      
      /* Put the separate debug object before the normal one, this is so that
         usage of the ALL_OBJFILES_SAFE macro will stay safe. */
      put_objfile_before (objfile->separate_debug_objfile, objfile);
      
      xfree (debugfile);
    }
  
  if (!have_partial_symbols () && !have_full_symbols ())
    {
      wrap_here ("");
      printf_filtered ("(no debugging symbols found)...");
      wrap_here ("");
    }

a913 13

/* Process a symbol file, as either the main file or as a dynamically
   loaded file.  See symbol_file_add_with_addrs_or_offsets's comments
   for details.  */
struct objfile *
symbol_file_add (char *name, int from_tty, struct section_addr_info *addrs,
		 int mainline, int flags)
{
  return symbol_file_add_with_addrs_or_offsets (name, from_tty, addrs, 0, 0, 
                                                mainline, flags);
}


a969 138
static char *
get_debug_link_info (struct objfile *objfile, unsigned long *crc32_out)
{
  asection *sect;
  bfd_size_type debuglink_size;
  unsigned long crc32;
  char *contents;
  int crc_offset;
  unsigned char *p;
  
  sect = bfd_get_section_by_name (objfile->obfd, ".gnu_debuglink");

  if (sect == NULL)
    return NULL;

  debuglink_size = bfd_section_size (objfile->obfd, sect);
  
  contents = xmalloc (debuglink_size);
  bfd_get_section_contents (objfile->obfd, sect, contents,
			    (file_ptr)0, (bfd_size_type)debuglink_size);

  /* Crc value is stored after the filename, aligned up to 4 bytes. */
  crc_offset = strlen (contents) + 1;
  crc_offset = (crc_offset + 3) & ~3;

  crc32 = bfd_get_32 (objfile->obfd, (bfd_byte *) (contents + crc_offset));
  
  *crc32_out = crc32;
  return contents;
}

static int
separate_debug_file_exists (const char *name, unsigned long crc)
{
  unsigned long file_crc = 0;
  int fd;
  char buffer[8*1024];
  int count;

  fd = open (name, O_RDONLY | O_BINARY);
  if (fd < 0)
    return 0;

  while ((count = read (fd, buffer, sizeof (buffer))) > 0)
    file_crc = gnu_debuglink_crc32 (file_crc, buffer, count);

  close (fd);

  return crc == file_crc;
}

static char *debug_file_directory = NULL;

#if ! defined (DEBUG_SUBDIRECTORY)
#define DEBUG_SUBDIRECTORY ".debug"
#endif

static char *
find_separate_debug_file (struct objfile *objfile)
{
  asection *sect;
  char *basename;
  char *dir;
  char *debugfile;
  char *name_copy;
  bfd_size_type debuglink_size;
  unsigned long crc32;
  int i;

  basename = get_debug_link_info (objfile, &crc32);

  if (basename == NULL)
    return NULL;
  
  dir = xstrdup (objfile->name);

  /* Strip off the final filename part, leaving the directory name,
     followed by a slash.  Objfile names should always be absolute and
     tilde-expanded, so there should always be a slash in there
     somewhere.  */
  for (i = strlen(dir) - 1; i >= 0; i--)
    {
      if (IS_DIR_SEPARATOR (dir[i]))
	break;
    }
  gdb_assert (i >= 0 && IS_DIR_SEPARATOR (dir[i]));
  dir[i+1] = '\0';
  
  debugfile = alloca (strlen (debug_file_directory) + 1
                      + strlen (dir)
                      + strlen (DEBUG_SUBDIRECTORY)
                      + strlen ("/")
                      + strlen (basename) 
                      + 1);

  /* First try in the same directory as the original file.  */
  strcpy (debugfile, dir);
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      xfree (basename);
      xfree (dir);
      return xstrdup (debugfile);
    }
  
  /* Then try in the subdirectory named DEBUG_SUBDIRECTORY.  */
  strcpy (debugfile, dir);
  strcat (debugfile, DEBUG_SUBDIRECTORY);
  strcat (debugfile, "/");
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      xfree (basename);
      xfree (dir);
      return xstrdup (debugfile);
    }
  
  /* Then try in the global debugfile directory.  */
  strcpy (debugfile, debug_file_directory);
  strcat (debugfile, "/");
  strcat (debugfile, dir);
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      xfree (basename);
      xfree (dir);
      return xstrdup (debugfile);
    }
  
  xfree (basename);
  xfree (dir);
  return NULL;
}


d1392 5
a1396 5
  /* FIXME: are we supposed to call symbol_file_add or not?  According
     to a comment from remote-mips.c (where a call to symbol_file_add
     was commented out), making the call confuses GDB if more than one
     file is loaded in.  Some targets do (e.g., remote-vx.c) but
     others don't (or didn't - perhaphs they have all been deleted).  */
a1722 5
	      if (objfile->demangled_names_hash != NULL)
		{
		  htab_delete (objfile->demangled_names_hash);
		  objfile->demangled_names_hash = NULL;
		}
a1815 2

              reread_separate_symbols (objfile);
a1822 67


/* Handle separate debug info for OBJFILE, which has just been
   re-read:
   - If we had separate debug info before, but now we don't, get rid
     of the separated objfile.
   - If we didn't have separated debug info before, but now we do,
     read in the new separated debug info file.
   - If the debug link points to a different file, toss the old one
     and read the new one.
   This function does *not* handle the case where objfile is still
   using the same separate debug info file, but that file's timestamp
   has changed.  That case should be handled by the loop in
   reread_symbols already.  */
static void
reread_separate_symbols (struct objfile *objfile)
{
  char *debug_file;
  unsigned long crc32;

  /* Does the updated objfile's debug info live in a
     separate file?  */
  debug_file = find_separate_debug_file (objfile);

  if (objfile->separate_debug_objfile)
    {
      /* There are two cases where we need to get rid of
         the old separated debug info objfile:
         - if the new primary objfile doesn't have
         separated debug info, or
         - if the new primary objfile has separate debug
         info, but it's under a different filename.
 
         If the old and new objfiles both have separate
         debug info, under the same filename, then we're
         okay --- if the separated file's contents have
         changed, we will have caught that when we
         visited it in this function's outermost
         loop.  */
      if (! debug_file
          || strcmp (debug_file, objfile->separate_debug_objfile->name) != 0)
        free_objfile (objfile->separate_debug_objfile);
    }

  /* If the new objfile has separate debug info, and we
     haven't loaded it already, do so now.  */
  if (debug_file
      && ! objfile->separate_debug_objfile)
    {
      /* Use the same section offset table as objfile itself.
         Preserve the flags from objfile that make sense.  */
      objfile->separate_debug_objfile
        = (symbol_file_add_with_addrs_or_offsets
           (debug_file,
            info_verbose, /* from_tty: Don't override the default. */
            0, /* No addr table.  */
            objfile->section_offsets, objfile->num_sections,
            0, /* Not mainline.  See comments about this above.  */
            objfile->flags & (OBJF_MAPPED | OBJF_REORDERED
                              | OBJF_SHARED | OBJF_READNOW
                              | OBJF_USERLOADED)));
      objfile->separate_debug_objfile->separate_debug_objfile_backlink
        = objfile;
    }
}


d1942 3
d2365 1
d2379 1
a2379 2

  SYMBOL_SET_NAMES (&psymbol, buf, namelength, objfile);
d2395 44
d2476 4
d2519 1
a2519 1
      xmfree (objfile->md, objfile->global_psymbols.list);
d2523 1
a2523 1
      xmfree (objfile->md, objfile->static_psymbols.list);
a3294 39
/* Set the output sections and output offsets for section SECTP in
   ABFD.  The relocation code in BFD will read these offsets, so we
   need to be sure they're initialized.  We map each section to itself,
   with no offset; this means that SECTP->vma will be honored.  */

static void
symfile_dummy_outputs (bfd *abfd, asection *sectp, void *dummy)
{
  sectp->output_section = sectp;
  sectp->output_offset = 0;
}

/* Relocate the contents of a debug section SECTP in ABFD.  The
   contents are stored in BUF if it is non-NULL, or returned in a
   malloc'd buffer otherwise.

   For some platforms and debug info formats, shared libraries contain
   relocations against the debug sections (particularly for DWARF-2;
   one affected platform is PowerPC GNU/Linux, although it depends on
   the version of the linker in use).  Also, ELF object files naturally
   have unresolved relocations for their debug sections.  We need to apply
   the relocations in order to get the locations of symbols correct.  */

bfd_byte *
symfile_relocate_debug_section (bfd *abfd, asection *sectp, bfd_byte *buf)
{
  /* We're only interested in debugging sections with relocation
     information.  */
  if ((sectp->flags & SEC_RELOC) == 0)
    return NULL;
  if ((sectp->flags & SEC_DEBUGGING) == 0)
    return NULL;

  /* We will handle section offsets properly elsewhere, so relocate as if
     all sections begin at 0.  */
  bfd_map_over_sections (abfd, symfile_dummy_outputs, NULL);

  return bfd_simple_get_relocated_section_contents (abfd, sectp, buf);
}
a3383 14

  debug_file_directory = xstrdup (DEBUGDIR);
  c = (add_set_cmd
       ("debug-file-directory", class_support, var_string,
        (char *) &debug_file_directory,
        "Set the directory where separate debug symbols are searched for.\n"
        "Separate debug symbols are first searched for in the same\n"
        "directory as the binary, then in the `" DEBUG_SUBDIRECTORY 
        "' subdirectory,\n"
        "and lastly at the path of the directory of the binary with\n"
        "the global debug-file directory prepended\n",
        &setlist));
  add_show_from_set (c, &showlist);
  set_cmd_completer (c, filename_completer);
@


1.69.2.15
log
@2003-02-11  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (find_oload_champ): Add comment.
	(find_oload_champ_namespace_loop): Fix memory management.
	(find_oload_champ_namespace): Add comment.
	(find_overload_match): Free oload_syms, oload_champ_bv.
	* gdbtypes.c (rank_function): Add comment.
	* valops.c (find_oload_champ_namespace_loop): Allow num_fns to be
	zero.
	* symtab.c (lookup_partial_symbol): Use strcmp_iw_ordered.
	(lookup_block_symbol): Delete comment.
	* symfile.c (compare_psymbols): Use strcmp_iw_ordered.
	* defs.h: Declare strcmp_iw_ordered.
	* utils.c (strcmp_iw_ordered): New function.
@
text
@d216 21
a236 2
/* This compares two partial symbols by names, using strcmp_iw_ordered
   for the comparison.  */
d241 8
a248 2
  struct partial_symbol *const *s1 = s1p;
  struct partial_symbol *const *s2 = s2p;
d250 12
a261 2
  return strcmp_iw_ordered (SYMBOL_BEST_NAME (*s1),
			    SYMBOL_BEST_NAME (*s2));
@


1.69.2.16
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d28 1
a50 1
#include "block.h"
d213 1
a213 1
  return (strcmp (SYMBOL_NATURAL_NAME (*s1), SYMBOL_NATURAL_NAME (*s2)));
d225 2
a226 2
  return strcmp_iw_ordered (SYMBOL_NATURAL_NAME (*s1),
			    SYMBOL_NATURAL_NAME (*s2));
d2688 1
a2688 1
  DEPRECATED_SYMBOL_NAME (&psymbol) = bcache (buf, namelength + 1, objfile->psymbol_cache);
@


1.69.2.17
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d3553 1
a3553 1
  return bfd_simple_get_relocated_section_contents (abfd, sectp, buf, NULL);
@


1.69.2.18
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d2618 1
a2618 1
add_psymbol_to_list (char *name, int namelength, domain_enum domain,
d2645 1
a2645 1
  PSYMBOL_DOMAIN (&psymbol) = domain;
d2670 1
a2670 1
				   int dem_namelength, domain_enum domain,
d2715 1
a2715 1
  PSYMBOL_DOMAIN (&psymbol) = domain;
@


1.69.2.19
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a371 16
/* Create a new section_addr_info, with room for NUM_SECTIONS.  */

struct section_addr_info *
alloc_section_addr_info (size_t num_sections)
{
  struct section_addr_info *sap;
  size_t size;

  size = (sizeof (struct section_addr_info)
	  +  sizeof (struct other_sections) * (num_sections - 1));
  sap = (struct section_addr_info *) xmalloc (size);
  memset (sap, 0, size);
  sap->num_sections = num_sections;

  return sap;
}
d384 2
a385 1
  sap = alloc_section_addr_info (end - start);
d391 1
a391 1
	  && oidx < end - start)
d412 1
a412 1
  for (idx = 0; idx < sap->num_sections; idx++)
d485 1
a485 1
  objfile->num_sections = bfd_count_sections (objfile->obfd);
d487 2
a488 4
    obstack_alloc (&objfile->psymbol_obstack, 
		   SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
  memset (objfile->section_offsets, 0, 
	  SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
d492 1
a492 1
  for (i = 0; i < addrs->num_sections && addrs->other[i].name; i++)
d552 4
a555 1
  struct section_addr_info *local_addr = NULL;
d557 1
d561 11
a581 13
  /* If ADDRS and OFFSETS are both NULL, put together a dummy address
     list.  We now establish the convention that an addr of zero means
     no load address was specified. */
  if (! addrs && ! offsets)
    {
      local_addr 
	= alloc_section_addr_info (bfd_count_sections (objfile->obfd));
      make_cleanup (xfree, local_addr);
      addrs = local_addr;
    }

  /* Now either addrs or offsets is non-zero.  */

d610 1
a610 1
  if (!mainline && addrs && addrs->other[0].name)
a611 5
      asection *lower_sect;
      asection *sect;
      CORE_ADDR lower_offset;
      int i;

d643 3
a645 1
        for (i = 0; i < addrs->num_sections && addrs->other[i].name; i++)
d729 1
a729 1
	         !s_addr && i < addrs->num_sections && addrs->other[i].name;
d763 7
d827 4
a830 2
  struct section_addr_info *orig_addrs;
  struct cleanup *my_cleanups;
a844 5
  orig_addrs = alloc_section_addr_info (bfd_count_sections (abfd));
  my_cleanups = make_cleanup (xfree, orig_addrs);
  if (addrs)
    *orig_addrs = *addrs;

d911 1
a911 1
            = symbol_file_add (debugfile, from_tty, orig_addrs, 0, flags);
a949 2
  do_cleanups (my_cleanups);

d1667 1
a1667 1
  struct sect_opt
d1671 1
a1671 1
  };
d1673 1
a1673 3
  struct section_addr_info *section_addrs;
  struct sect_opt *sect_opts = NULL;
  size_t num_sect_opts = 0;
a1675 4
  num_sect_opts = 16;
  sect_opts = (struct sect_opt *) xmalloc (num_sect_opts 
					   * sizeof (struct sect_opt));

d1684 3
d1719 1
a1719 8
	    if (++section_index > num_sect_opts) 
	      {
		num_sect_opts *= 2;
		sect_opts = ((struct sect_opt *) 
			     xrealloc (sect_opts,
				       num_sect_opts 
				       * sizeof (struct sect_opt)));
	      }
d1736 2
d1754 1
a1754 8
		      if (++section_index > num_sect_opts) 
			{
			  num_sect_opts *= 2;
			  sect_opts = ((struct sect_opt *) 
				       xrealloc (sect_opts,
						 num_sect_opts 
						 * sizeof (struct sect_opt)));
			}
a1769 2
  section_addrs = alloc_section_addr_info (section_index);
  make_cleanup (xfree, section_addrs);
d1776 5
a1780 1
      addr = parse_and_eval_address (val);
d1784 2
a1785 2
      section_addrs->other[sec_num].name = sec;
      section_addrs->other[sec_num].addr = addr;
d1801 1
a1801 1
  symbol_file_add (filename, from_tty, section_addrs, 0, flags);
d1898 2
a1899 4
	      offsets = ((struct section_offsets *) 
			 alloca (SIZEOF_N_SECTION_OFFSETS (num_offsets)));
	      memcpy (offsets, objfile->section_offsets, 
		      SIZEOF_N_SECTION_OFFSETS (num_offsets));
a1933 1
	      objfile->sym_private = NULL;
d1967 2
a1968 4
		obstack_alloc (&objfile->psymbol_obstack, 
			       SIZEOF_N_SECTION_OFFSETS (num_offsets));
	      memcpy (objfile->section_offsets, offsets, 
		      SIZEOF_N_SECTION_OFFSETS (num_offsets));
d2012 8
d2960 1
a2960 1
static int
@


1.69.2.20
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d209 1
a209 1
  struct symbol **s1, **s2;
d247 1
a247 1
  char *p = (char *) obstack_alloc (obstackp, size + 1);
d252 2
a253 2
    const char *p1 = ptr;
    char *p2 = p;
d269 2
a270 2
  int len = strlen (s1) + strlen (s2) + strlen (s3) + 1;
  char *val = (char *) obstack_alloc (obstackp, len);
d293 1
a293 1
psymtab_to_symtab (struct partial_symtab *pst)
d330 2
a331 2
  objfile->ei.deprecated_entry_file_lowpc = INVALID_ENTRY_LOWPC;
  objfile->ei.deprecated_entry_file_highpc = INVALID_ENTRY_HIGHPC;
d713 1
a713 1
#ifndef DEPRECATED_IBM6000_TARGET
d761 1
a761 1
#endif /* not DEPRECATED_IBM6000_TARGET */
d857 1
a857 6
    {
      int i;
      orig_addrs->num_sections = addrs->num_sections;
      for (i = 0; i < addrs->num_sections; i++)
	orig_addrs->other[i] = addrs->other[i];
    }
d1380 4
d1868 1
a1868 1
#ifdef DEPRECATED_IBM6000_TARGET
d2283 1
a2283 1
  struct symtab *symtab;
d2522 3
a2524 3
  struct symtab *s;
  struct symtab *prev;
  struct partial_symtab *ps;
d2636 1
a2636 2
   Since one arg is a struct, we pass in a ptr and deref it (sigh).  
   Return the partial symbol that has been added.  */
d2638 4
a2641 10
/* NOTE: carlton/2003-09-11: The reason why we return the partial
   symbol is so that callers can get access to the symbol's demangled
   name, which they don't have any cheap way to determine otherwise.
   (Currenly, dwarf2read.c is the only file who uses that information,
   though it's possible that other readers might in the future.)
   Elena wasn't thrilled about that, and I don't blame her, but we
   couldn't come up with a better way to get that information.  If
   it's needed in other situations, we could consider breaking up
   SYMBOL_SET_NAMES to provide access to the demangled name lookup
   cache.  */
d2650 1
a2650 1
  struct partial_symbol *psym;
d2703 1
a2703 1
  struct partial_symbol *psym;
@


1.69.2.21
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d875 1
a875 1
	  printf_unfiltered ("Mapped symbols for %s...", name);
d893 1
a893 1
	      printf_unfiltered ("Reading symbols from %s...", name);
d911 1
a911 1
	  printf_unfiltered ("expanding to full symbols...");
d950 1
a950 1
      printf_unfiltered ("(no debugging symbols found)...");
d960 1
a960 1
	  printf_unfiltered ("done.\n");
d1226 1
a1226 1
	  if (strcmp (*argv, "-mapped") == 0)
d1669 1
d1801 1
a1801 1
  printf_unfiltered ("add symbol table from file \"%s\" at\n", filename);
d1816 1
a1816 1
      printf_unfiltered ("\t%s_addr = %s\n",
d1881 1
a1881 1
	      printf_unfiltered ("`%s' has disappeared; keeping its symbols.\n",
d1893 1
a1893 1
	      printf_unfiltered ("`%s' has changed; re-reading symbols.\n",
a1972 1
	      clear_objfile_data (objfile);
d2026 1
a2026 1
		  printf_unfiltered ("(no debugging symbols found)\n");
d2542 1
a2542 1
      if (strcmp (name, ps->filename) == 0)
d2553 1
a2553 1
      if (strcmp (name, s->filename) == 0)
d3196 1
a3196 1
	    printf_unfiltered ("Note: section %s unmapped by overlap\n",
d3246 1
a3246 1
    printf_unfiltered ("Automatic overlay debugging enabled.");
d3259 1
a3259 1
    printf_unfiltered ("Overlay debugging enabled.");
d3272 1
a3272 1
    printf_unfiltered ("Overlay debugging disabled.");
@


1.69.2.22
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1229 1
a1229 1
	    if (strcmp (*argv, "-readnow") == 0)
d2685 1
a2685 2
  psym = deprecated_bcache (&psymbol, sizeof (struct partial_symbol),
			    objfile->psymbol_cache);
d2722 1
a2722 2
  DEPRECATED_SYMBOL_NAME (&psymbol) = deprecated_bcache (buf, namelength + 1,
							 objfile->psymbol_cache);
d2733 1
a2733 1
	deprecated_bcache (buf, dem_namelength + 1, objfile->psymbol_cache);
d2754 1
a2754 2
  psym = deprecated_bcache (&psymbol, sizeof (struct partial_symbol),
			    objfile->psymbol_cache);
@


1.69.2.23
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d202 14
d864 4
a867 4
  /* We either created a new mapped symbol table, mapped an existing
     symbol table file which has not had initial symbol reading
     performed, or need to read an unmapped symbol table. */
  if (from_tty || info_verbose)
d869 5
a873 3
      if (pre_add_symbol_hook)
	pre_add_symbol_hook (name);
      else
d875 1
a875 1
	  printf_unfiltered ("Reading symbols from %s...", name);
d879 21
a900 2
  syms_from_objfile (objfile, addrs, offsets, num_offsets,
		     mainline, from_tty);
d1226 14
a1239 10
	  if (strcmp (*argv, "-readnow") == 0)
	    flags |= OBJF_READNOW;
	  else if (**argv == '-')
	    error ("unknown option `%s'", *argv);
	  else
	    {
	      name = *argv;
	      
	      symbol_file_add_main_1 (name, from_tty, flags);
	    }
d1754 11
a1764 7
		if (strcmp (arg, "-readnow") == 0)
		  flags |= OBJF_READNOW;
		else if (strcmp (arg, "-s") == 0)
		  {
		    expecting_sec_name = 1;
		    expecting_sec_addr = 1;
		  }
a1963 1
	      objfile->cp_namespace_symtab = NULL;
d2113 2
a2114 1
            objfile->flags & (OBJF_REORDERED | OBJF_SHARED | OBJF_READNOW
@


1.68
log
@Revert previous change.  Not obvious.
@
text
@d34 1
d2107 1
a2107 2
  current_source_symtab = 0;
  current_source_line = 0;
@


1.67
log
@2002-09-18  Michael Snyder  <msnyder@@redhat.com>

	Preliminary support for Objective-C:
	* defs.h (language_objc): New enum value.
	(puts_filtered_tabular): Declaration only, exported from utils.c.
	(skip_quoted): Delete, declared in completer.h.
	* c-exp.y: Include completer.h.
	* p-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* expression.h (OP_MSGCALL, OP_SELECTOR, OP_SELF, OP_NSSTRING):
	New operator enum values.
	* language.h (CAST_IS_CONVERSION): Test for language_objc.
	* language.c (binop_result_type): Handle language_objc case.
	(integral_type, character_type, string_type, boolean_type,
	structured_type, binop_type_check): Ditto.
	* symtab.h (SYMBOL_OBJC_DEMANGLED_NAME): Define.
	(struct objc_specific): Add to general_symbol_info.
	(SYMBOL_INIT_LANGUAGE_SPECIFIC): Add objc initialization.
	(SYMBOL_DEMANGLED_NAME): Handle objc case.
	* parser-defs.h (struct objc_class_str): New struct type.
	(start_msglist, end_msglist, add_msglist): Declaration only,
	exported from objc-lang.c.
	* value.h (value_of_local, value_nsstring,
	call_function_by_hand_expecting_type): Exported from valops.c.
	* valops.c (find_function_addr): Export.
	(call_function_by_hand_expecting_type): New function.
	(value_of_local): New function.
	* symfile.c (init_filename_language_table): Add ".m" extension
	for Objective-C.
	* utils.c (puts_filtered_tabular): New function.
	(fprintf_symbol_filtered): Add objc demangling support (disabled).
	(set/show demangle): Extend help-string to refer to ObjC.
	* elfread.c (elf_symtab_read): Skip Objective-C special symbols.
	* stabsread.c (symbol_reference_defined): Objective-C symbols
	may contain colons: make allowances when scanning stabs strings
	for colons.
	(objc_find_colon): New function.
	* printcmd.c (address_info): If language == objc then print
	"self" instead of "this".
	* parse.c (length_of_subexp): Handle new operators OP_MSGCALL,
	OP_NSSTRING, and OP_SELF.
	(prefixify_subexp): Ditto.
	* source.c (print_source_lines): Mention objc in comment.
	* breakpoint.c (parse_breakpoint_sals): Recognize Objective-C
	method names.
@
text
@a1953 1
      add_filename_language (".m", language_objc);
@


1.66
log
@2002-09-18  Andrew Cagney  <ac131313@@redhat.com>

	* complaints.h: Update copyright.
	(struct complaints): Declare.
	(struct complaint): Make `message' constant.
	(internal_complaint): Declare.
	(complaint): Declare.
	(complaint_root): Delete declaration.
	(symfile_complaints): Delete declaration.
	(struct complaints): Add opaque declaration.
	(clear_complaints): Add a complaints parameter.
	* complaints.c: Update copyright.
	(enum complaint_series): Define.
	(complaint_root): Delete.
	(struct complaints): Define.
	(complaint_sentinel, symfile_complaint_book): New variables.
	(symfile_explanations, symfile_complaints): New variables.
	New variables.
	(get_complaints): New function.
	(vcomplaint): New function.
	(complaint): New function.
	(internal_complaint): New function.
	(complain): Call vcomplain with symfile_complaint.
	(clear_complaints): Rewrite.
	(_initialize_complaints): Use add_setshow_command.
	* Makefile.in (complaints.o): Update dependencies.
	* symfile.c (syms_from_objfile): Add symfile_complaints parameter
	to call to clear_complaints.
	(new_symfile_objfile, reread_symbols): Ditto.
	(oldsyms_complaint): Delete.
	(empty_symtab_complaint, unknown_option_complaint): Delete.
	(free_named_symtabs): Use complaint instead of complain.
@
text
@d1954 1
@


1.65
log
@2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* NEWS: Menion that CHILL has been made obsolete.

* gdbtypes.c (chill_varying_type): Make chill references obsolete.
* gdbserver/Makefile.in: Ditto.
* stabsread.c (read_range_type): Ditto.
* gdbtypes.h: Ditto.
* language.c (binop_type_check): Ditto.
(binop_result_type): Ditto.
(integral_type): Ditto.
(character_type): Ditto.
(string_type): Ditto.
(boolean_type): Ditto.
(structured_type): Ditto.
(lang_bool_type): Ditto.
(binop_type_check): Ditto.
* language.h (_LANG_chill): Ditto.
* dwarfread.c (set_cu_language): Ditto.
* dwarfread.c (CHILL_PRODUCER): Ditto.
* dwarfread.c (handle_producer): Ditto.
* expression.h (enum exp_opcode): Ditto.
* eval.c: Ditto for comments.
* typeprint.c (typedef_print) [_LANG_chill]: Ditto.
* expprint.c (print_subexp): Ditto.
(print_subexp): Ditto.
* valops.c (value_cast): Ditto.
(search_struct_field): Ditto.
* value.h (COERCE_VARYING_ARRAY): Ditto.
* symfile.c (init_filename_language_table): Ditto.
(add_psymbol_with_dem_name_to_list): Ditto.
* valarith.c (value_binop): Ditto.
(value_neg): Ditto.
* valops.c (value_slice): Ditto.
* symtab.h (union language_specific): Ditto.
(SYMBOL_INIT_LANGUAGE_SPECIFIC): Ditto.
(SYMBOL_DEMANGLED_NAME): Ditto.
(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
* defs.h (enum language): Ditto.
* symtab.c (got_symtab): Ditto.
* utils.c (fprintf_symbol_filtered): Ditto.

* ch-typeprint.c: Make file obsolete.
* ch-valprint.c: Make file obsolete.
* ch-lang.h: Make file obsolete.
* ch-exp.c: Make file obsolete.
* ch-lang.c: Make file obsolete.

* Makefile.in (FLAGS_TO_PASS): Do not pass CHILL or CHILLFLAGS or
CHILL_LIB.
(TARGET_FLAGS_TO_PASS): Ditto.
(CHILLFLAGS): Obsolete.
(CHILL): Obsolete.
(CHILL_FOR_TARGET): Obsolete.
(CHILL_LIB): Obsolete.
(SFILES): Remove ch-exp.c, ch-lang.c, ch-typeprint.c and
ch-valprint.c.
(HFILES_NO_SRCDIR): Remove ch-lang.h.
(COMMON_OBS): Remove ch-valprint.o, ch-typeprint.o, ch-exp.o and
ch-lang.o.
(ch-exp.o, ch-lang.o, ch-typeprint.o, ch-valprint.o): Delete
targets.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* stabs.texinfo, gdb.texinfo, gdbint.texinfo: Obsolete references
to CHILL.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* Makefile.in (TARGET_FLAGS_TO_PASS): Remove CHILLFLAGS, CHILL,
CHILL_FOR_TARGET and CHILL_LIB.
* configure.in (configdirs): Remove gdb.chill.
* configure: Regenerate.
* lib/gdb.exp: Obsolete references to chill.
* gdb.fortran/types.exp: Ditto.
* gdb.fortran/exprs.exp: Ditto.
@
text
@a83 15
struct complaint oldsyms_complaint =
{
  "Replacing old symbols for `%s'", 0, 0
};

struct complaint empty_symtab_complaint =
{
  "Empty symbol table found for `%s'", 0, 0
};

struct complaint unknown_option_complaint =
{
  "Unknown option `%s' ignored", 0, 0
};

d694 1
a694 1
  clear_complaints (1, verbo);
d806 1
a806 1
  clear_complaints (0, verbo);
d1789 1
a1789 1
	      clear_complaints (1, 1);
d1803 1
a1803 1
	      clear_complaints (0, 1);
d2293 2
a2294 2
	  complain (&oldsyms_complaint, name);

d2301 2
a2302 1
	  complain (&empty_symtab_complaint, name);
@


1.64
log
@2002-07-29  Andrew Cagney  <ac131313@@redhat.com>

* gdb_obstack.h: New file.
* symtab.h: Include "gdb_obstack.h" instead of "obstack.h".
(obstack_chunk_alloc, obstack_chunk_free): Delete macros.
* objfiles.h: Include "gdb_obstack.h".
* Makefile.in (gdb_obstack_h): Define.
(symtab_h): Add $(gdb_obstack_h).
(objfiles_h): Add $(gdb_obstack_h).

* objfiles.c: Include "gdb_obstack.h" instead of "obstack.h".
* macrotab.c, cp-valprint.c, dbxread.c: Ditto.
* ch-typeprint.c, ch-valprint.c, dstread.c: Ditto.
* macroexp.c, p-typeprint.c, stabsread.c: Ditto.
* symtab.c, f-typeprint.c, mdebugread.c: Ditto.
* p-valprint.c, symmisc.c, typeprint.c: Ditto.
* symfile.c, coffread.c, c-typeprint.c: Ditto.
* buildsym.c, bcache.c, ada-typeprint.c: Ditto.

* Makefile.in (bcache.o): Update dependencies.
(buildsym.o, c-typeprint.o, ch-typeprint.o): Ditto.
(ch-valprint.o, coffread.o, cp-valprint.o): Ditto.
(dbxread.o, dstread.o, f-typeprint.o): Ditto.
(objfiles.o, p-typeprint.o, p-valprint.o): Ditto.
(stabsread.o, symfile.o, symmisc.o): Ditto.
(symtab.o, typeprint.o, macroexp.o): Ditto.
(macrotab.o, mdebugread.o): Ditto.
(f_lang_h, coff_sym_h, coff_symconst_h): Define.
(coff_ecoff_h, aout_aout64_h): Define.
(aout_stabs_gnu_h, libaout_h): Define.
@
text
@d1966 3
a1968 3
      add_filename_language (".ch", language_chill);
      add_filename_language (".c186", language_chill);
      add_filename_language (".c286", language_chill);
d2446 3
a2448 3
    case language_chill:
      SYMBOL_CHILL_DEMANGLED_NAME (&psymbol) =
	bcache (buf, dem_namelength + 1, objfile->psymbol_cache);
@


1.63
log
@* bcache.h: Update copyright.
(struct bstring, struct bcache): Move definition to "bcache.c".
Replaced by opaque declaration.
(bcache_xfree): Replace free_bcache.
(bcache_xmalloc, bcache_memory_used): Declare.

* bcache.c: Update copyright.
(struct bstring, struct bcache): Moved to here from "bcache.h".
Update comments.
(bcache_xmalloc, bcache_memory_used): New functions.
(bcache_xfree): Replace function free_bcache.

* Makefile.in (objfiles.o): Add $(bcache_h).
(objfiles_h): Remove $(bcache_h).
(symfile.o): Add $(bcache_h).

* symmisc.c: Update copyright.
(print_symbol_bcache_statistics): Pass psymbol_cache by value.
(print_objfile_statistics): Use bcache_memory_used.

* symfile.c: Include "bcache.h".
(reread_symbols): Use bcache_xfree.
(reread_symbols): Use bcache_xmalloc and bcache_xfree.
(add_psymbol_to_list): Pass psymbol_cache by value.
(add_psymbol_with_dem_name_to_list): Ditto.

* objfiles.h: Update copyright.
(struct bcache): Declare opaque.  Do not include "bcache.h".
(struct objfile): Change psymbol_cache and macro_cache to ``struct
bcache'' pointers.
* dwarf2read.c (macro_start_file): Pass macro_cache by value.

* objfiles.c: Include "bcache.h".  Update copyright.
(allocate_objfile): Use bcache_xmalloc to create psymbol_cache and
macro_cache.
(free_objfile): Use bcache_xfree.
@
text
@d41 1
a41 1
#include "obstack.h"
@


1.62
log
@Add macro structures to GDB's symbol tables.  Nobody puts anything
in them yet.
* symtab.h (struct symtab): New member: `macro_table'.
* buildsym.h (pending_macros): New global variable.
* buildsym.c: #include "macrotab.h".
(buildsym_init): Initialize `pending_macros'.
(end_symtab): If we found macro information while reading a CU's
debugging info, do build a symtab structure for it.  Make the
symtab point to the macro information, and clear the
`pending_macros' pointer which held it while we were reading the
debug info.
(really_free_pendings): Free any pending macro table.
* objfiles.h (struct objfile): New member: `macro_cache'.
* objfiles.c (allocate_objfile): Set allocate and free functions
for the macro cache's objstack.
(free_objfile): Empty the macro cache's obstack.
* symfile.c (reread_symbols): Empty the macro cache's obstack, and
set new allocate and free functions for it.
* solib-sunos.c (allocate_rt_common_objfile): Set allocate and
free functions for the macro cache's objstack.  (Why is this
function building its own objfile?)
* symmisc.c (print_objfile_statistics): Print statistics on the
macro bcache.
* Makefile.in: Note that buildsym.o depends on macrotab.h.
@
text
@d43 1
d1744 4
a1747 2
	      free_bcache (&objfile->psymbol_cache);
	      free_bcache (&objfile->macro_cache);
d1771 2
a1772 4
	      obstack_specify_allocation (&objfile->psymbol_cache.cache, 0, 0,
					  xmalloc, xfree);
	      obstack_specify_allocation (&objfile->macro_cache.cache, 0, 0,
					  xmalloc, xfree);
d2381 1
a2381 1
  SYMBOL_NAME (&psymbol) = bcache (buf, namelength + 1, &objfile->psymbol_cache);
d2398 1
a2398 1
  psym = bcache (&psymbol, sizeof (struct partial_symbol), &objfile->psymbol_cache);
d2433 1
a2433 1
  SYMBOL_NAME (&psymbol) = bcache (buf, namelength + 1, &objfile->psymbol_cache);
d2444 1
a2444 1
	bcache (buf, dem_namelength + 1, &objfile->psymbol_cache);
d2448 1
a2448 1
	bcache (buf, dem_namelength + 1, &objfile->psymbol_cache);
d2469 1
a2469 1
  psym = bcache (&psymbol, sizeof (struct partial_symbol), &objfile->psymbol_cache);
@


1.62.4.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a42 1
#include "bcache.h"
d1743 2
a1744 4
	      bcache_xfree (objfile->psymbol_cache);
	      objfile->psymbol_cache = bcache_xmalloc ();
	      bcache_xfree (objfile->macro_cache);
	      objfile->macro_cache = bcache_xmalloc ();
d1768 4
a1771 2
	      objfile->psymbol_cache = bcache_xmalloc ();
	      objfile->macro_cache = bcache_xmalloc ();
d2380 1
a2380 1
  SYMBOL_NAME (&psymbol) = bcache (buf, namelength + 1, objfile->psymbol_cache);
d2397 1
a2397 1
  psym = bcache (&psymbol, sizeof (struct partial_symbol), objfile->psymbol_cache);
d2432 1
a2432 1
  SYMBOL_NAME (&psymbol) = bcache (buf, namelength + 1, objfile->psymbol_cache);
d2443 1
a2443 1
	bcache (buf, dem_namelength + 1, objfile->psymbol_cache);
d2447 1
a2447 1
	bcache (buf, dem_namelength + 1, objfile->psymbol_cache);
d2468 1
a2468 1
  psym = bcache (&psymbol, sizeof (struct partial_symbol), objfile->psymbol_cache);
@


1.62.4.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d41 1
a41 1
#include "gdb_obstack.h"
d1966 3
a1968 3
      /* OBSOLETE add_filename_language (".ch", language_chill); */
      /* OBSOLETE add_filename_language (".c186", language_chill); */
      /* OBSOLETE add_filename_language (".c286", language_chill); */
d2446 3
a2448 3
      /* OBSOLETE case language_chill: */
      /* OBSOLETE   SYMBOL_CHILL_DEMANGLED_NAME (&psymbol) = */
      /* OBSOLETE     bcache (buf, dem_namelength + 1, objfile->psymbol_cache); */
@


1.62.4.3
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a33 1
#include "source.h"
d84 15
d709 1
a709 1
  clear_complaints (&symfile_complaints, 1, verbo);
d821 1
a821 1
  clear_complaints (&symfile_complaints, 0, verbo);
d1804 1
a1804 1
	      clear_complaints (&symfile_complaints, 1, 1);
d1818 1
a1818 1
	      clear_complaints (&symfile_complaints, 0, 1);
d2121 2
a2122 1
  clear_current_source_symtab_and_line ();
d2308 2
a2309 2
	  complaint (&symfile_complaints, "Replacing old symbols for `%s'",
		     name);
d2316 1
a2316 2
	  complaint (&symfile_complaints, "Empty symbol table found for `%s'",
		     name);
@


1.62.4.4
log
@merge from mainline
@
text
@d302 1
a302 1
obsavestring (const char *ptr, int size, struct obstack *obstackp)
d309 1
a309 1
    register const char *p1 = ptr;
d311 1
a311 1
    const char *end = ptr + size;
a1954 1
      add_filename_language (".m", language_objc);
@


1.61
log
@Approved by ezannoni@@redhat.com:

	2002-05-12  Fred Fish  <fnf@@redhat.com>
	* symfile.c (default_symfile_offsets): Arrange for uninitialized
	sect_index_xxx members to index the first slot in section_offsets
	if all of the section_offsets are zero.
@
text
@d1744 1
d1769 2
@


1.60
log
@2002-04-25  Pierre Muller  <muller@@ics.u-strasbg.fr>

	Fix PR gdb/508.
	* symfile.c (add_filename_language): Fix wrong xrealloc size argument.
@
text
@d542 28
@


1.60.2.1
log
@Add macro structures to GDB's symbol tables.  Nobody puts anything
in them yet.
* symtab.h (struct symtab): New member: `macro_table'.
* buildsym.h (pending_macros): New global variable.
* buildsym.c: #include "macrotab.h".
(buildsym_init): Initialize `pending_macros'.
(end_symtab): If we found macro information while reading a CU's
debugging info, do build a symtab structure for it.  Make the
symtab point to the macro information, and clear the
`pending_macros' pointer which held it while we were reading the
debug info.
(really_free_pendings): Free any pending macro table.
* objfiles.h (struct objfile): New member: `macro_cache'.
* objfiles.c (allocate_objfile): Set allocate and free functions
for the macro cache's objstack.
(free_objfile): Empty the macro cache's obstack.
* symfile.c (reread_symbols): Empty the macro cache's obstack, and
set new allocate and free functions for it.
* solib-sunos.c (allocate_rt_common_objfile): Set allocate and
free functions for the macro cache's objstack.  (Why is this
function building its own objfile?)
* symmisc.c (print_objfile_statistics): Print statistics on the
macro bcache.
* Makefile.in: Note that buildsym.o depends on macrotab.h.
@
text
@a1715 1
	      free_bcache (&objfile->macro_cache);
a1739 2
					  xmalloc, xfree);
	      obstack_specify_allocation (&objfile->macro_cache.cache, 0, 0,
@


1.59
log
@        * symfile.h (get_section_index): Define.
        * symfile.c (get_section_index): New function.
        * mdebugread.c (SC_IS_SBSS): New macro.
        (SC_IS_BSS): Return true for the scBss storage class only, as
        the scSBss storage class refers to the .sbss section.
        (parse_partial_symbols): Discard the symbols which associated
        section does not exist.
        Make sure to use the .sbss section index for symbols which
        storage class is scBss, rather than using the .bss section index.
@
text
@d1834 3
a1836 2
      filename_language_table = xrealloc (filename_language_table,
					  fl_table_size);
@


1.58
log
@2002-03-28  Michael Snyder  <msnyder@@redhat.com>

	* symfile.c (symbol_file_add): Move test for null symbols to later.
@
text
@d123 2
d1118 12
@


1.57
log
@2002-03-27  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (_initialize_breakpoint): Clean up help string.
	* infcmd.c (_initialize_infcmd): Ditto.
	* language.c (_initialize_language): Ditto.
	* symfile.c (_initialize_symfile): Ditto.
	* top.c (_init_main): Ditto.
	* cli/cli-cmds.c (init_cli_cmds): Ditto.
@
text
@a863 3
  if (objfile->sf == NULL)
    return objfile;	/* No symbols. */

d896 3
@


1.56
log
@2002-03-14  Michael Snyder  <msnyder@@redhat.com>

	* symfile.c (syms_from_objfile): Return immediately if no syms.
	(symbol_file_add): Return immediately if no syms.
	(find_sym_fns): Return immediately if no syms.
@
text
@d3236 1
a3236 1
with the text. SECT is a section name to be loaded at SECT_ADDR.",
@


1.55
log
@* cli/cli-decode.c (set_cmd_completer): New function.
* command.h (set_cmd_completer): Declare.
* cli/cli-decode.h (set_cmd_completer): Ditto.

* breakpoint.c (_initialize_breakpoint): Use set_cmd_completer.
* cli/cli-cmds.c (init_cli_cmds): Ditto.
* win32-nat.c (_initialize_inftarg): Ditto.
* remote-rdi.c (_initialize_remote_rdi): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* hppa-tdep.c (_initialize_hppa_tdep): Ditto.
* source.c (_initialize_source): Ditto.
* exec.c (_initialize_exec): Ditto.
* solib.c (_initialize_solib): Ditto.
* top.c (init_main): Ditto.
* tracepoint.c (_initialize_tracepoint): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* printcmd.c (_initialize_printcmd): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
@
text
@d580 3
d864 3
d1142 5
@


1.54
log
@* memattr.c (mem_command): Eliminate ``true'' and ``false''.
* osfsolib.c (solib_map_sections): Ditto.
* irix5-nat.c (solib_map_sections): Ditto.
* corelow.c (gdb_check_format): Ditto.
* symfile.c (symfile_bfd_open): Ditto.
* solib.c (solib_map_sections): Ditto.
Partially fix PR gdb/354.
@
text
@d3217 1
a3217 1
  c->completer = filename_completer;
d3227 1
a3227 1
  c->completer = filename_completer;
d3239 1
a3239 1
  c->completer = filename_completer;
@


1.54.2.1
log
@2002-04-30  Michael Chastain  <mec@@shout.net>

	Merge from trunk.  This also fixes PR gdb/172.

	2002-04-25  Pierre Muller  <muller@@ics.u-strasbg.fr>

	Fix PR gdb/508.
	* symfile.c (add_filename_language): Fix wrong xrealloc size argument.
@
text
@d1809 2
a1810 3
      filename_language_table = 
	xrealloc (filename_language_table,
		  fl_table_size * sizeof (*filename_language_table));
@


1.54.2.2
log
@* NEWS: Mention below.

Merge from mainline:
2002-04-22 J. Brobecker <brobecker@@gnat.com>:
* symfile.h (get_section_index): Define.
* symfile.c (get_section_index): New function.
* mdebugread.c (SC_IS_SBSS): New macro.
(SC_IS_BSS): Return true for the scBss storage class only, as
the scSBss storage class refers to the .sbss section.
(parse_partial_symbols): Discard the symbols which associated
section does not exist.
Make sure to use the .sbss section index for symbols which
storage class is scBss, rather than using the .bss section index.
@
text
@a122 2
int get_section_index (struct objfile *, char *);

a1109 12
}

/* Return the section index for the given section name. Return -1 if
   the section was not found. */
int
get_section_index (struct objfile *objfile, char *section_name)
{
  asection *sect = bfd_get_section_by_name (objfile->obfd, section_name);
  if (sect)
    return sect->index;
  else
    return -1;
@


1.54.2.3
log
@* NEWS: Mention below.
Merge from mainline:
2002-05-12 Fred Fish <fnf@@redhat.com>:
* symfile.c (default_symfile_offsets): Arrange for uninitialized
sect_index_xxx members to index the first slot in section_offsets
if all of the section_offsets are zero.
@
text
@a541 28
  /* This is where things get really weird...  We MUST have valid
     indices for the various sect_index_* members or gdb will abort.
     So if for example, there is no ".text" section, we have to
     accomodate that.  Except when explicitly adding symbol files at
     some address, section_offsets contains nothing but zeros, so it
     doesn't matter which slot in section_offsets the individual
     sect_index_* members index into.  So if they are all zero, it is
     safe to just point all the currently uninitialized indices to the
     first slot. */

  for (i = 0; i < objfile->num_sections; i++)
    {
      if (ANOFFSET (objfile->section_offsets, i) != 0)
	{
	  break;
	}
    }
  if (i == objfile->num_sections)
    {
      if (objfile->sect_index_text == -1)
	objfile->sect_index_text = 0;
      if (objfile->sect_index_data == -1)
	objfile->sect_index_data = 0;
      if (objfile->sect_index_bss == -1)
	objfile->sect_index_bss = 0;
      if (objfile->sect_index_rodata == -1)
	objfile->sect_index_rodata = 0;
    }
@


1.53
log
@2002-02-04  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.h (enum bptype): Add new overlay event bp type.
	(enable_overlay_breakpoints, disable_overlay_breakpoints): Export.

	* breakpoint.c (create_internal_breakpoint): New function.
	(internal_breakpoint_number): Moved into create_internal_breakpoint.
	(create_longjmp_breakpoint): Use create_internal_breakpoint.
	(create_thread_event_breakpoint): Ditto.
	(create_solib_event_breakpoint): Ditto.
	(create_overlay_event_breakpoint): New function.
	(enable_overlay_breakpoints, disable_overlay_breakpoints): New funcs.
	(update_breakpoints_after_exec): Delete and re-initialize
	overlay event breakpoints after an exec.  Add FIXME comment
	about longjmp breakpoint.
	(print_it_typical): Ignore overlay event breakpoints.
	(print_one_breakpoint): Ditto.
	(mention): Ditto.
	(bpstat_what): Do not stop for overlay event breakpoints.
	(delete_breakpoint): Don't delete overlay event breakpoints.
	(breakpoint_re_set_one): Delete the overlay event breakpoint.
	(breakpoint_re_set): Re-create overlay event breakpoint.

	* symfile.c (overlay_auto_command): Enable overlay breakpoints.
	(overlay_manual_command): Disable overlay breakpoints.
	(overlay_off_command): Disable overlay breakpoints.
@
text
@d1097 1
a1097 1
  sym_bfd->cacheable = true;
@


1.52
log
@* cli/cli-decode.c (do_cfunc, set_cmd_cfunc): New functions.
(do_sfunc, set_cmd_sfunc): New functions.

* command.h (struct cmd_list_element): Add field func.
* cli/cli-decode.h (struct cmd_list_element): Ditto.
* command.h (set_cmd_sfunc, set_cmd_cfunc): Declare.
* cli/cli-decode.h: Ditto.

* cli/cli-decode.c (help_cmd): Test for func not cfunc/sfunc.
(help_all, help_cmd_list): Ditto.
(find_cmd, complete_on_cmdlist): Ditto.
* top.c (execute_command): Ditto.

* cli/cli-setshow.c (do_setshow_command): Call func instead of
function.sfunc.

* infcmd.c (notice_args_read): Fix function signature.

* cli/cli-cmds.c (init_cli_cmds): Use set_cmd_sfunc.
* cli/cli-decode.c (add_set_cmd): Ditto.
* utils.c (initialize_utils): Ditto.
* maint.c (_initialize_maint_cmds): Ditto.
* infrun.c (_initialize_infrun): Ditto.
* demangle.c (_initialize_demangler): Ditto.
* remote.c (add_packet_config_cmd): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* cris-tdep.c (_initialize_cris_tdep): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* kod.c (_initialize_kod): Ditto.
* valprint.c (_initialize_valprint): Ditto.
* top.c (init_main): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
* arm-tdep.c (_initialize_arm_tdep): Ditto.
* arch-utils.c (initialize_current_architecture): Ditto.
(_initialize_gdbarch_utils): Ditto.
* alpha-tdep.c (_initialize_alpha_tdep): Ditto.

* cli/cli-decode.c (add_cmd): Use set_cmd_cfunc.
* wince.c (_initialize_inftarg): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* language.c (_initialize_language): Ditto.
* arc-tdep.c (_initialize_arc_tdep): Ditto.
@
text
@d2901 1
d2914 1
d2927 1
@


1.51
log
@2002-01-31  Michael Snyder  <msnyder@@redhat.com>

	* symfile.h (enum overlay_debugging_state):
	Define enum constant values for overlay mode.
	* symfile.c (overlay_debugging): Use enums instead of literals.
	(overlay_is_mapped, overlay_auto_command,
	overlay_manual_command): Ditto.
@
text
@d3277 1
a3277 1
  c->function.cfunc = set_ext_lang_command;
@


1.50
log
@Remove else clause to #if UI_OUT.
@
text
@d2512 1
a2512 1
int overlay_debugging = 0;	/* 0 == off, 1 == manual, -1 == auto */
d2569 1
a2569 1
    case 0:
d2571 1
a2571 1
    case -1:			/* overlay debugging automatic */
d2585 1
a2585 1
    case 1:			/* overlay debugging manual */
d2900 1
a2900 1
  overlay_debugging = -1;
d2912 1
a2912 1
  overlay_debugging = 1;
d2924 1
a2924 1
  overlay_debugging = 0;
@


1.49
log
@2002-01-15  Michael Snyder  <msnyder@@redhat.com>

	* symfile.c (generic_load): Use bfd_map_over_sections method
	instead of manipulating bfd structure members directly.
	(add_section_size_callback): New function, bfd sections callback
        used by generic_load.
	(load_sections_callback): New function, bfd sections callback
        used by generic_load.
@
text
@d2 4
a5 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001 Free Software Foundation, Inc.
a1226 1
#ifdef UI_OUT
a1228 5
#else
	  fprintf_unfiltered (gdb_stdout,
			      "Loading section %s, size 0x%s lma 0x%s\n",
			      sect_name, paddr_nz (size), paddr_nz (lma));
#endif
a1353 1
#ifdef UI_OUT
a1358 5
#else
  fprintf_unfiltered (gdb_stdout,
		      "Start address 0x%s, load size %lu\n",
		      paddr_nz (entry), cbdata.data_count);
#endif
a1394 1
#ifdef UI_OUT
a1413 10
#else
  fprintf_unfiltered (stream, "Transfer rate: ");
  if (time_count > 0)
    fprintf_unfiltered (stream, "%lu bits/sec", (data_count * 8) / time_count);
  else
    fprintf_unfiltered (stream, "%lu bits in <1 sec", (data_count * 8));
  if (write_count > 0)
    fprintf_unfiltered (stream, ", %lu bytes/write", data_count / write_count);
  fprintf_unfiltered (stream, ".\n");
#endif
@


1.48
log
@2002-01-11  Michael Snyder  <msnyder@@redhat.com>

        * symfile.c (build_section_addr_info_from_section_tab):
        Use bfd access method instead of manipulating bfd directly.
        (syms_from_objfile): Ditto.
        (simple_overlay_update_1): Ditto.
        (simple_overlay_update): Ditto.
        (generic_load): Ditto.
        (overlay_unmapped_address): FIXME comment, bfd access methods.
        (sections_overlap): FIXME comment, bfd access methods.
        (pc_in_mapped_range): FIXME comment, bfd access methods.
        (pc_in_unmapped_range): FIXME comment, bfd access methods.
        (section_is_mapped): FIXME comment, bfd access methods.
        (section_is_overlay): FIXME comment, bfd access methods.
@
text
@d1177 117
a1299 3
  unsigned long data_count = 0;	/* Number of bytes transferred to memory */
  unsigned long write_count = 0;	/* Number of writes needed. */
  unsigned long load_offset;	/* offset to add to vma for each section */
d1303 7
a1309 1
  bfd_size_type total_size = 0;
d1321 1
a1321 1
      load_offset = strtoul (offptr, &endptr, 0);
d1327 1
a1327 1
    load_offset = 0;
d1348 2
a1349 3
  for (s = loadfile_bfd->sections; s; s = s->next)
    if (bfd_get_section_flags (loadfile_bfd, s) & SEC_LOAD)
      total_size += bfd_get_section_size_before_reloc (s);
d1353 1
a1353 96
  for (s = loadfile_bfd->sections; s; s = s->next)
    {
      if (s->flags & SEC_LOAD)
	{
	  bfd_size_type size = bfd_get_section_size_before_reloc (s);

	  if (size > 0)
	    {
	      char *buffer;
	      struct cleanup *old_chain;
	      CORE_ADDR lma = bfd_section_lma (loadfile_bfd, s) + load_offset;
	      bfd_size_type block_size;
	      int err;
	      const char *sect_name = bfd_get_section_name (loadfile_bfd, s);
	      bfd_size_type sent;

	      if (download_write_size > 0 && size > download_write_size)
		block_size = download_write_size;
	      else
		block_size = size;

	      buffer = xmalloc (size);
	      old_chain = make_cleanup (xfree, buffer);

	      /* Is this really necessary?  I guess it gives the user something
	         to look at during a long download.  */
#ifdef UI_OUT
	      ui_out_message (uiout, 0, 
			      "Loading section %s, size 0x%s lma 0x%s\n",
			      sect_name, paddr_nz (size), paddr_nz (lma));
#else
	      fprintf_unfiltered (gdb_stdout,
				  "Loading section %s, size 0x%s lma 0x%s\n",
				  sect_name, paddr_nz (size), paddr_nz (lma));
#endif

	      bfd_get_section_contents (loadfile_bfd, s, buffer, 0, size);

	      sent = 0;
	      do
		{
		  int len;
		  bfd_size_type this_transfer = size - sent;

		  if (this_transfer >= block_size)
		    this_transfer = block_size;
		  len = target_write_memory_partial (lma, buffer,
						     this_transfer, &err);
		  if (err)
		    break;
		  if (validate_download)
		    {
		      /* Broken memories and broken monitors manifest
			 themselves here when bring new computers to
			 life.  This doubles already slow downloads.  */
		      /* NOTE: cagney/1999-10-18: A more efficient
                         implementation might add a verify_memory()
                         method to the target vector and then use
                         that.  remote.c could implement that method
                         using the ``qCRC'' packet.  */
		      char *check = xmalloc (len);
		      struct cleanup *verify_cleanups = make_cleanup (xfree, 
								      check);

		      if (target_read_memory (lma, check, len) != 0)
			error ("Download verify read failed at 0x%s",
			       paddr (lma));
		      if (memcmp (buffer, check, len) != 0)
			error ("Download verify compare failed at 0x%s",
			       paddr (lma));
		      do_cleanups (verify_cleanups);
 		    }
		  data_count += len;
		  lma += len;
		  buffer += len;
		  write_count += 1;
		  sent += len;
		  if (quit_flag
		      || (ui_load_progress_hook != NULL
			  && ui_load_progress_hook (sect_name, sent)))
		    error ("Canceled the download");

		  if (show_load_progress != NULL)
		    show_load_progress (sect_name, sent, size, 
					data_count, total_size);
		}
	      while (sent < size);

	      if (err != 0)
		error ("Memory access error while loading section %s.", 
		       sect_name);

	      do_cleanups (old_chain);
	    }
	}
    }
a1355 2
  {
    CORE_ADDR entry = bfd_get_start_address (loadfile_bfd);
d1357 1
d1359 5
a1363 6
    ui_out_text (uiout, "Start address ");
    ui_out_field_fmt (uiout, "address", "0x%s", paddr_nz (entry));
    ui_out_text (uiout, ", load size ");
    ui_out_field_fmt (uiout, "load-size", "%lu", data_count);
    ui_out_text (uiout, "\n");

d1365 3
a1367 3
    fprintf_unfiltered (gdb_stdout,
			"Start address 0x%s, load size %lu\n",
			paddr_nz (entry), data_count);
d1369 3
a1371 4
    /* We were doing this in remote-mips.c, I suspect it is right
       for other targets too.  */
    write_pc (entry);
  }
d1379 2
a1380 2
  print_transfer_performance (gdb_stdout, data_count, write_count,
			      end_time - start_time);
@


1.47
log
@2002-01-11  Michael Snyder  <msnyder@@redhat.com>

        * symfile.c (generic_load): Whitespace and long line cleanups.
        Remove duplicate variable, change several local variables to
        more appropriate data types.
        (print_transfer_performance): Use %lu instead of %ld for ulongs.
@
text
@d455 2
a456 1
      if (stp->the_bfd_section->flags & (SEC_ALLOC | SEC_LOAD)
d460 2
a461 1
	  sap->other[oidx].name = xstrdup (stp->the_bfd_section->name);
d713 3
a715 1
 	      if (strcmp (s->the_bfd_section->name, addrs->other[i].name) == 0)
d1229 1
a1229 1
    if (s->flags & SEC_LOAD)
d2526 2
d2614 2
d2634 2
d2654 2
d2671 2
d2688 2
d3128 2
d3133 3
a3135 3
    if (cache_ovly_table[i][VMA] == osect->the_bfd_section->vma &&
	cache_ovly_table[i][LMA] == osect->the_bfd_section->lma		/* &&
									   cache_ovly_table[i][SIZE] == size */ )
d3139 3
a3141 3
	if (cache_ovly_table[i][VMA] == osect->the_bfd_section->vma &&
	    cache_ovly_table[i][LMA] == osect->the_bfd_section->lma	/* &&
									   cache_ovly_table[i][SIZE] == size */ )
d3146 1
a3146 1
	else			/* Warning!  Warning!  Target's ovly table has changed! */
d3189 2
d3194 4
a3197 4
	if (cache_ovly_table[i][VMA] == osect->the_bfd_section->vma &&
	    cache_ovly_table[i][LMA] == osect->the_bfd_section->lma	/* &&
									   cache_ovly_table[i][SIZE] == size */ )
	  {			/* obj_section matches i'th entry in ovly_table */
@


1.46
log
@2002-01-07  Michael Snyder  <msnyder@@redhat.com>

	* cp-valprint.c (cp_print_value): FIXME comment, alloca size.
	* p-valprint.c (pascal_object_print_value): Ditto.
	* somread.c (som_symtab_read): Ditto.
	* symfile.c (simple_free_overlay_region_table): Ditto.
	* valops.c (value_assign): Ditto.
@
text
@d1185 1
a1185 2
  CORE_ADDR total_size = 0;
  CORE_ADDR total_sent = 0;
d1196 1
d1234 2
a1235 1
	  CORE_ADDR size = bfd_get_section_size_before_reloc (s);
d1240 2
a1241 2
	      CORE_ADDR lma = s->lma + load_offset;
	      CORE_ADDR block_size;
d1244 1
a1244 1
	      CORE_ADDR sent;
d1257 3
a1259 2
	      ui_out_message (uiout, 0, "Loading section %s, size 0x%s lma 0x%s\n",
			   sect_name, paddr_nz (size), paddr_nz (lma));
d1271 3
a1273 2
		  CORE_ADDR len;
		  CORE_ADDR this_transfer = size - sent;
d1291 3
a1293 1
		      struct cleanup *verify_cleanups = make_cleanup (xfree, check);
a1306 1
		  total_sent += len;
d1313 2
a1314 1
		    show_load_progress (sect_name, sent, size, total_sent, total_size);
d1319 2
a1320 1
		error ("Memory access error while loading section %s.", sect_name);
d1329 2
a1330 2
    CORE_ADDR entry;
    entry = bfd_get_start_address (loadfile_bfd);
d1332 5
a1336 5
   ui_out_text (uiout, "Start address ");
   ui_out_field_fmt (uiout, "address", "0x%s" , paddr_nz (entry));
   ui_out_text (uiout, ", load size ");
   ui_out_field_fmt (uiout, "load-size", "%ld" , data_count);
   ui_out_text (uiout, "\n");
d1340 1
a1340 1
			"Start address 0x%s , load size %ld\n",
d1370 2
a1371 1
  print_transfer_performance (gdb_stdout, data_count, end_time - start_time, 0);
d1384 1
a1384 1
      ui_out_field_fmt (uiout, "transfer-rate", "%ld", 
d1390 1
a1390 1
      ui_out_field_fmt (uiout, "transferred-bits", "%ld", (data_count * 8));
d1396 1
a1396 1
      ui_out_field_fmt (uiout, "write-rate", "%ld", data_count / write_count);
d1403 1
a1403 1
    fprintf_unfiltered (stream, "%ld bits/sec", (data_count * 8) / time_count);
d1405 1
a1405 1
    fprintf_unfiltered (stream, "%ld bits in <1 sec", (data_count * 8));
d1407 1
a1407 1
    fprintf_unfiltered (stream, ", %ld bytes/write", data_count / write_count);
@


1.45
log
@Approved by Jim Blandy:

	2001-12-10  Fred Fish  <fnf@@redhat.com>
	* arm-linux-tdep.c (skip_hurd_resolver): Use NULL rather than
	zero in args to lookup_minimal_symbol.
	* linespec.c (decode_line_1): Ditto.
	* i386-linux-tdep.c (skip_hurd_resolver): Ditto.
	* minsyms.c (find_stab_function_addr): Ditto.
	* symfile.c (simple_read_overlay_table): Ditto.
	(simple_read_overlay_region_table): Ditto.
@
text
@d3012 1
@


1.44
log
@mfree() -> xmfree().
@
text
@d3029 1
a3029 1
  novlys_msym = lookup_minimal_symbol ("_novlys", 0, 0);
d3038 1
a3038 1
  ovly_table_msym = lookup_minimal_symbol ("_ovly_table", 0, 0);
d3067 1
a3067 1
  msym = lookup_minimal_symbol ("_novly_regions", 0, 0);
d3075 1
a3075 1
      msym = lookup_minimal_symbol ("_ovly_region_table", 0, 0);
d3145 1
a3145 1
	  SYMBOL_VALUE_ADDRESS (lookup_minimal_symbol ("_ovly_table", 0, 0)))
@


1.43
log
@* symfile.c (simple_read_overlay_table): Make sure we can find
both `_novlys' and `_ovly_table' before we try anything else;
print a helpful error message.
(simple_overlay_update): No need to print error message here.
@
text
@d1670 1
a1670 1
		mfree (objfile->md, objfile->global_psymbols.list);
d1674 1
a1674 1
		mfree (objfile->md, objfile->static_psymbols.list);
d2420 1
a2420 1
      mfree (objfile->md, (PTR) objfile->global_psymbols.list);
d2424 1
a2424 1
      mfree (objfile->md, (PTR) objfile->static_psymbols.list);
@


1.42
log
@	2001-11-06  Fred Fish  <fnf@@redhat.com>
	* complaints.c (info_verbose): Remove unneeded decl, is in defs.h.
	* dbxread.c: Ditto
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* exec.c: Ditto.
	* hpread.c: Ditto.
	* hpread.h: Ditto.
	* mdebugread.c: Ditto.
	* os9kread.c: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* tracepoint.c: Ditto.
@
text
@d3026 1
a3026 1
  struct minimal_symbol *msym;
d3029 11
a3039 7
  msym = lookup_minimal_symbol ("_novlys", 0, 0);
  if (msym != NULL)
    cache_novlys = read_memory_integer (SYMBOL_VALUE_ADDRESS (msym), 4);
  else
    return 0;			/* failure */
  cache_ovly_table = (void *) xmalloc (cache_novlys * sizeof (*cache_ovly_table));
  if (cache_ovly_table != NULL)
d3041 4
a3044 10
      msym = lookup_minimal_symbol ("_ovly_table", 0, 0);
      if (msym != NULL)
	{
	  cache_ovly_table_base = SYMBOL_VALUE_ADDRESS (msym);
	  read_target_long_array (cache_ovly_table_base,
				  (int *) cache_ovly_table,
				  cache_novlys * 4);
	}
      else
	return 0;		/* failure */
d3046 9
a3054 2
  else
    return 0;			/* failure */
d3155 3
a3157 5
  if (simple_read_overlay_table () == 0)	/* read failed?  No table? */
    {
      warning ("Failed to read the target overlay mapping table.");
      return;
    }
@


1.41
log
@Changes approved by kev@@cygnus.com, ezannoni@@cygnus.com, eliz@@is.elta.co.il.

  Changelog:

	2001-10-27  Fred Fish  <fnf@@redhat.com>

	* symfile.c (auto_solib_add): Update comment to note that
	this variable is now just used as a boolean to control shlib
	autoloading, and clarify when it is used.
	* symfile.h (auto_solib_add): Ditto.

	* symfile.c (auto_solib_limit): New variable that holds the
	autoloading threshold instead of overloading auto_solib_add.
	* symfile.h (auto_solib_limit): Ditto.

	* irix5-nat.c (_initialize_solib): Change auto-solib-add
	variable from var_zinteger to var_boolean and update help.
	* osfsolib.c (_initialize_solib): Ditto.
	* pa64solib.c (_initialize_pa64_solib): Ditto.
	* solib.c (_initialize_solib): Ditto.
	* somsolib.c (_initialize_som_solib): Ditto.
	* xcoffsolib.c (_initialize_solib): Ditto.

	* pa64solib.c (pa64_solib_total_st_size): Update comment to
	note that the new auto_solib_limit variable is used instead
	of overloading auto_solib_add variable.
	(_initialize_pa64_solib): Ditto.
	* somsolib.c (som_solib_total_st_size): Ditto.
	(_initialize_som_solib): Ditto.

	* pa64solib.c (_initialize_pa64_solib): Add new set/show
	commands for auto-solib-limit variable.
	* somsolib.c (_initialize_som_solib): Ditto

	* pa64solib.c (add_to_solist): Check that auto_solib_add is
	set and use auto_solib_limit as the threshold size instead
	of auto_solib_add.
	* somsolib.c (som_solib_add): Ditto, and also change warning
	text about size threshold exceeded.

  doc/ChangeLog:

	2001-10-28  Fred Fish  <fnf@@redhat.com>

	* gdb.texinfo (auto-solib-add): Change docs to match
	implementation change.
	(auto-solib-limit): Add docs for new variable.
@
text
@a97 2
extern int info_verbose;

@


1.40
log
@(start_psymtab_common): Revert change accidentally included in last
commit.
@
text
@d180 9
a188 4
/* If non-zero, then on HP-UX (i.e., platforms that use somsolib.c),
   this variable is interpreted as a threshhold.  If adding a new
   library's symbol table to those already known to the debugger would
   exceed this threshhold, then the shlib's symbols are not added.
d190 1
a190 9
   If non-zero on other platforms, shared library symbols will be added
   automatically when the inferior is created, new libraries are loaded,
   or when attaching to the inferior.  This is almost always what users
   will want to have happen; but for very large programs, the startup
   time will be excessive, and so if this is a problem, the user can
   clear this flag and then add the shared library symbols as needed.
   Note that there is a potential for confusion, since if the shared
   library symbols are not loaded, commands like "info fun" will *not*
   report all the functions that are actually present. 
d192 7
a198 4
   Note that HP-UX interprets this variable to mean, "threshhold size
   in megabytes, where zero means never add".  Other platforms interpret
   this variable to mean, "always add if non-zero, never add if zero."
 */
d200 1
a200 1
int auto_solib_add = 1;
@


1.39
log
@Isolate STABS readers' use of the `textlow' and `texthigh' fields
of `struct partial_symtab' to only a few locations.  This change
is not supposed to affect the way the values are computed, only
where they live.

* dbxread.c (struct symloc): Add `textlow' and `texthigh' fields
to the reader-specific structure.
* mdebugread.c (struct symloc): Same.
* dbxread.c (TEXTLOW, TEXTHIGH): New accessor macros.
* mdebugread.c (TEXTLOW, TEXTHIGH): Same.
* dbxread.c (dbx_symfile_read): After we've built all our partial
symbol tables, set each partial symtab's `textlow' and `texthigh'
fields from our reader-specific structure.
* mdebugread.c (mdebug_build_psymtabs): Same.
* dbxread.c (start_psymtab): Initialize the reader-specific
structure's `textlow' and `texthigh' from the new psymtab's.
* mdebugread.c (parse_partial_symbols, new_psymtab): Same.
* dbxread.c (read_dbx_symtab, end_psymtab, read_ofile_symtab): Use
the reader-specific `textlow' and `texthigh', not the generic
psymtab fields.
* mdebugread.c (parse_lines, parse_partial_symbols,
psymtab_to_symtab_1): Same.
* partial-stab.h: Same.
@
text
@a1991 1
  psymtab->text_addrs = addrset_new (&objfile->psymbol_obstack);
@


1.38
log
@* symfile.c (sections_overlap): New function.
(map_overlay_command): Call sections_overlap, instead of using
incorrect logic to recognize overlapping sections.
@
text
@d1992 1
@


1.37
log
@* symfile.c (load_command): Invalidate the overlay cache.
@
text
@d2493 1
d2633 14
d2825 5
a2829 5
	if (sec2->ovly_mapped &&
	    sec != sec2 &&
	    sec->the_bfd_section != sec2->the_bfd_section &&
	    (pc_in_mapped_range (sec2->addr, sec->the_bfd_section) ||
	     pc_in_mapped_range (sec2->endaddr, sec->the_bfd_section)))
@


1.36
log
@2001-07-15  Elena Zannoni  <ezannoni@@redhat.com>

	* top.c (readline_line_completion_function, noop_completer): Move
 	from here...
	* completer.c (readline_line_completion_function, noop_completer):
 	...to here.
	* gdbcmd.h (readline_line_completion_function, noop_completer):
 	Move declarations from here...
	* completer.h (readline_line_completion_function, noop_completer):
 	...to here.
	* corefile.c: Include completer.h.
	* source.c: Ditto.
	* symfile.c: Ditto.
	* Makefile.in: Update dependencies.
@
text
@d1157 4
@


1.35
log
@	* utils.c (query): Remove tui hacks; tui must use the query_hook.
	* top.c (command_loop): Remove tui insert_mode hacks; don't call
	tuiCleanUp because this must be made with atexit by tui.
	* symfile.c (symbol_file_command): Remove call to TUIDO
	* stack.c (show_and_print_stack_frame_stub): Remove tui check;
	not necessary when using the selected frame hooks.
	(print_stack_frame_stub): Likewise.
	(print_frame_info_base): Likewise.
	(print_frame_info): Likewise.
	(up_silently_command): Likewise.
	(down_silently_command): Likewise.
	(show_stack_frame): Likewise for TUIDO.
	(select_frame): Likewise.
	(select_and_print_frame): Likewise.
	(stack_publish_stopped_with_no_frame): Remove.
	(select_and_maybe_print_frame): Remove.
	* main.c (captured_main): Remove tui_fileopen and tuiInit; tui
	must use the initialize ui hook.
	* infrun.c (normal_stop): Remove call to TUIDO; tui must use the
	selected frame hooks.
	* event-top.c (command_handler): Remove tui insert_mode hack.
	* defs.h: Remove TUIDO; Only include tui.h.
	* breakpoint.c (mention): Remove calls to TUIDO.
	(delete_breakpoint): Remove tui hacks; tui must install
	the breakpoint hooks.
@
text
@d40 1
@


1.34
log
@Delete some unnecessary PTR uses.
@
text
@a1010 1
      TUIDO (((TuiOpaqueFuncPtr) tuiDisplayMainFunction));
@


1.34.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d374 1
d499 1
a499 1
    obstack_alloc (&objfile->misc_obstack, SIZEOF_SECTION_OFFSETS);
a1677 1
	      obstack_free (&objfile->misc_obstack, 0);
a1702 2
	      obstack_specify_allocation (&objfile->misc_obstack, 0, 0,
					  xmalloc, xfree);
d1718 1
a1718 1
		obstack_alloc (&objfile->misc_obstack, SIZEOF_SECTION_OFFSETS);
d1980 3
a1982 1
    psymtab = (struct partial_symtab *) obstack_alloc (&objfile->misc_obstack, sizeof (struct partial_symtab));
d1985 2
a1986 1
  psymtab->filename = obsavestring (filename, strlen(filename), &objfile->misc_obstack);
@


1.33
log
@* symfile.c (compare_psymbols, compare_symbols): Declare using
PTR, as in the definition.
@
text
@a119 4
static int compare_psymbols (const PTR, const PTR);

static int compare_symbols (const PTR, const PTR);

d207 1
a207 1
compare_symbols (const PTR s1p, const PTR s2p)
d239 1
a239 1
compare_psymbols (const PTR s1p, const PTR s2p)
@


1.32
log
@2001-05-10  Fernando Nasser  <fnasser@@redhat.com>

	* symfile.c (symbol_file_add_main_1): New static function.
	Passes the flags arguments to  symbol_file_add() and takes care
	of any necessary reinitializations.
        (symbol_file_command): Call symbol_file_add_main_1() instead of
        symbol_file_add().
        (symbol_file_add_main): Ditto.
@
text
@d120 1
a120 1
static int compare_psymbols (const void *, const void *);
d122 1
a122 1
static int compare_symbols (const void *, const void *);
@


1.31
log
@* main.c: Remove windows.h use.
(gdbtk_test): Use PATH_MAX for home var calculation.
* remote-e7000.c (e7000_parse_device): Accomodate Cygwin as well as Win32 in
test.
* ser-tcp.c: Use modern __CYGWIN__ conditional.
* source.c (mod_path): Add __CYGWIN__ conditional to WIN32 test.
(openp): Ditto.
* symfile.c (symfile_bfd_open): Ditto.
* gdbtk/generic/gdbtk.c: Ditto.
@
text
@d112 2
d901 7
a907 2
/* Just call the above with default values.
   Used when the file is supplied in the gdb command line. */
d912 17
a928 1
  symbol_file_add (args, from_tty, NULL, 1, 0);
a1004 7
		  symbol_file_add (name, from_tty, NULL, 1, flags);
#ifdef HPUXHPPA
		  RESET_HP_UX_GLOBALS ();
#endif
		  /* Getting new symbols may change our opinion about
		     what is frameless.  */
		  reinit_frame_cache ();
d1006 1
a1006 1
		  set_initial_language ();
@


1.30
log
@* arch-utils.c (#include "gdbthread.h"): Removed.
(#include "symfile.h"): Removed.
(XMALLOC): Removed unused macro.
* breakpoint.c (tbreak_command): Removed local declaration.
(awatch_command, do_enable_breakpoint, set_breakpoint_count):
Remove duplicate declarations.
(bpstat_should_step, bpstat_have_active_hw_watchpoints)
(remove_solib_event_breakpoints): Fix indentation botch.
* c-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* ch-exp.c (ch_terminal_match_float_literal, parse_expr)
(parse_primval, parse_untyped_expr, parse_opt_untyped_expr):
Removed duplicate declarations.
* ch-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* corefile.c (#include "frame.h"): Removed
(#include "symfile.h"): Removed.
(#include "language.h"): Removed.
* dbxread.c (#include "command.h"): Removed.
* environ.c (#include "gdbcore.h"): Removed.
* event-loop.c (#include "top.h"): Removed.
* f-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
(#include "typeprint.h"): Removed.
(#include "frame.h"): Removed.
* gdbtypes.h (print_type_scalar): Removed declaration.
* infcmd.c (#include "completer.h"): Removed.
* language.c (#include "frame.h"): Removed.
* m2-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
* m2-valprint.c (#include "valprint.h"): Removed.
* p-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* p-valprint.c (#include "typeprint.h"): Removed.
* parse.c (#include "linespec.h"): Removed.
* regcache.c (#include "frame.h"): Removed.
* remote.c (#include "frame.h"): Removed.
(getpkt_sane): Make static.
* source.c (#include "completer.h"): Removed.
* stack.c (#include "symfile.h"): Removed.
(#include "objfiles.h"): Removed.
* symfile.c (#include "completer.h"): Removed.
* tracepoint.c (#include "completer.h"): Removed.
* values.c (#include "frame.h"): Removed.
* varobj.c (#include "valprint.h"): Removed.
* wrapper.c (#include "frame.h"): Removed.

* memattr.c (create_mem_region): Removed unused variable.
* remote-nrom.c: Removed spurious semicolon after init_nrom_ops.
-------------------------------------------------------------------
@
text
@d1055 1
a1055 1
#if defined(__GO32__) || defined(_WIN32)
@


1.29
log
@Move realoc() decl to utils.c.  s/realloc()/xrealloc()/.
@
text
@a39 1
#include "completer.h"
@


1.28
log
@2001-03-06  J.T. Conklin  <jtc@@redback.com>

        * symtab.h (decode_line_1): Removed declaration.

        * symfile.c (#include <assert.h>): Removed.

        * arch-utils.c (#include <ctype.h>): Removed.
        * c-typeprint.c: Likewise.
        * dbxread.c: Likewise.
        * gdbtypes.c: Likewise.
        * target.c: Likewise.
        * os9kread.c: Likewise.

        * c-valprint.c (#include "demangle.h"): Removed.
        * ch-typeprint.c: Likewise.
        * eval.c: Likewise.
        * f-typeprint.c: Likewise.
        * f-valprint.c: Likewise.
        * m2-typeprint.c: Likewise.
        * typeprint.c: Likewise.
        * p-typeprint.c: Likewise.
        * valarith.c: Likewise.
        * valprint.c: Likewise.

        * m2-typeprint.c (#include "gdb_string.h"): Removed.
        * nlmread.c: Likewise.

        * mdebugread.c (#include "gdb-stabs.h"): Removed.
        * minsyms.c: Likewise.
        * mipsread.c: Likewise.
        * nlmread.c: Likewise.

        * m2-typeprint.c (#include "obstack.h"): Removed.
        * m2-valprint.c: Likewise.

        * event-loop.c (#include <setjmp.h>): Removed.
@
text
@d1785 2
a1786 2
      filename_language_table = realloc (filename_language_table,
					 fl_table_size);
@


1.27
log
@Update/correct copyright notices.
@
text
@a41 1
#include <assert.h>
@


1.26
log
@2001-02-19  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        From Andrew Cagney  <cagney@@b1.cygnus.com>:
	* symfile.c (add_symbol_file_command): Always initialize
 	my_cleanup using a NULL cleanup.
@
text
@d2 2
a3 1
   Copyright 1990-1996, 1998, 2000, 2001 Free Software Foundation, Inc.
@


1.25
log
@Replace strsave() with xstrdup().
@
text
@d1423 1
a1423 1
  struct cleanup *my_cleanups;
d1459 1
a1459 1
	  my_cleanups = make_cleanup (xfree, filename);
@


1.24
log
@2001-01-26  Fernando Nasser  <fnasser@@redhat.com>

        Fix double parsing of filenames passed as command line arguments
        to GDB (causes weird handling of escape characters).
        Also, remove dependencies on the CLI from libgdb.
        * call-cmds.h: Remove declaration of exec_file_command().
        * gdbcore.h: Remove declaration of exec_file_command().
        Add declarations for exec_open() and exec_file_clear().
        * symfile.h: Add declarations for symbol_file_add_main() and
        symbol_file_clear().
        * exec.c (exec_open): New function. Implements to_open for exec
        targets.
        (exec_file_clear): New function. Makes GDB forget about a previously
        specified executable file.
        (exec_file_attach): Move parsing of arguments from here ...
        (exec_file_command): ... to here.
        (init_exec_ops): Use exec_open(), not exec_file_command() to
        implement to_open for exec targets.
        * symfile.c (symbol_file_add_main): New function. Call symbol_file_add()        with default values.  Used when the file name has already been parsed.
        (symbol_file_clear): New function. Makes GDB forget about previously
        read symbols.
        (symbol_file_command): Call the above function instead of inline code.
        * main.c: Include "symfile.h" and "gdbcore.h" instead of the deprecated
        "call-cmds.h".
        (captured_main): Call exec_file_attach() and symbol_file_add_main()
        instead of exec_file_command() and symbol_file_command().
        (captured_main): Add comment.
        * corefile.c: Include "symfile.h".
        (core_file_command): Call symbol_file_add_main() instead of
        symbol_file_command().
        (reopen_exec_file): Call exec_open() instead of exec_file_command().
        * infcmd.c: Include "symfile.h".
        (attach_command): Call symbol_file_add_main() instead of
        symbol_file_command().
        * infrun.c: Remove comment about the inclusion of "symfile.h",
        not any longer appropriate.
        (follow_exec): Call symbol_file_add_main() instead of
        symbol_file_command().
        * remote-es.c: Include "symfile.h".
        (es1800_load): Call symbol_file_add_main() instead of
        symbol_file_command().
        * remote-vx.c: Remove comment about the inclusion of "symfile.h",
        not any longer appropriate.
        (vx-wait): Call symbol_file_add_main() instead of
        symbol_file_command().
        * solib-svr4.c (open_symbol_file_object): Call symbol_file_add_main()
        instead of symbol_file_command().
        * v850ice.c (ice_file): Call exec_open(), exec_file_attach() and
        symbol_file_add_main() instead of exec_file_command() and
        symbol_file_command().
        * Makefile.in: Update dependencies.
@
text
@d2 1
a2 1
   Copyright 1990-1996, 1998, 2000 Free Software Foundation, Inc.
d1789 1
a1789 1
  filename_language_table[fl_table_next].ext = strsave (ext);
d1848 1
a1848 1
      filename_language_table[i].ext = strsave (ext_args);
@


1.23
log
@Replace STRCMP with strcmp()
@
text
@d900 35
d961 1
a961 21
      if ((have_full_symbols () || have_partial_symbols ())
	  && from_tty
	  && !query ("Discard symbol table from `%s'? ",
		     symfile_objfile->name))
	error ("Not confirmed.");
      free_all_objfiles ();

      /* solib descriptors may have handles to objfiles.  Since their
         storage has just been released, we'd better wipe the solib
         descriptors as well.
       */
#if defined(SOLIB_RESTART)
      SOLIB_RESTART ();
#endif

      symfile_objfile = NULL;
      if (from_tty)
	  printf_unfiltered ("No symbol file now.\n");
#ifdef HPUXHPPA
      RESET_HP_UX_GLOBALS ();
#endif
@


1.22
log
@Replace free() with xfree().
@
text
@d216 1
a216 1
  return (STRCMP (SYMBOL_SOURCE_NAME (*s1), SYMBOL_SOURCE_NAME (*s2)));
a262 12
      /* Note: I replaced the STRCMP line (commented out below)
       * with a simpler "strcmp()" which compares the 2 strings
       * from the beginning. (STRCMP is a macro which first compares
       * the initial characters, then falls back on strcmp).
       * The reason is that the STRCMP line was tickling a C compiler
       * bug on HP-UX 10.30, which is avoided with the simpler
       * code. The performance gain from the more complicated code
       * is negligible, given that we have already checked the
       * initial 2 characters above. I reported the compiler bug,
       * and once it is fixed the original line can be put back. RT
       */
      /* return ( STRCMP (st1 + 2, st2 + 2)); */
@


1.21
log
@2000-11-30  Fernando Nasser  <fnasser@@redhat.com>

        * linespec.h: New file. Declarations for linespec.c.
        * linespec.c, alpha-tdep.c, breakpoint.c, parse.c, source.c,
        symtab.c, tracepoint.c: Include the above.
        * completer.c: New file. Line completion stuff for GDB.
        (get_gdb_completer_word_break_characters,
        get_gdb_completer_quote_characters): New functions. Accessors for
        useful completer internal data.
        (filename_completer, line_completion_function, skip_quoted): Moved
        here from top.c.
        * completer.h: New file. Declarations for the above.
        * linespec.c (decode_line_1): Use
        get_gdb_completer_word_break_characters and
        get_gdb_completer_quote_characters.
        * top.c: Include completer.h.
        (filename_completer, line_completion_function, skip_quoted):
        Moved to completer.c.
        * corefile.c, exec.c, source.c, symfile.c, linespec.c: Include
        completer.h.
        * Makefile.in (SFILES): Add completer.c.
        (COMMON_OBS): Add completer.o.
        (completer.o): New target.
        (linespec.o, alpha-tdep.o, breakpoint.o, parse.o, source.o,
        symtab.o, tracepoint.o): Add linespec.h to dependencies list.
        (corefile.o, exec.o, source.o, symfile.o, linespec.o): Add completer.h
        to dependencies list.
@
text
@d494 2
a495 2
      free (sap->other[idx].name);
  free (sap);
d1064 1
a1064 1
      make_cleanup (free, name);
d1067 1
a1067 1
  free (name);			/* Free 1st new malloc'd copy */
d1075 1
a1075 1
      make_cleanup (free, name);
d1087 1
a1087 1
      make_cleanup (free, name);
d1175 1
a1175 1
  old_cleanups = make_cleanup (free, filename);
d1235 1
a1235 1
	      old_chain = make_cleanup (free, buffer);
d1272 1
a1272 1
		      struct cleanup *verify_cleanups = make_cleanup (free, check);
d1456 1
a1456 1
	  my_cleanups = make_cleanup (free, filename);
d1688 1
a1688 1
					  xmalloc, free);
d1690 1
a1690 1
					  xmalloc, free);
d1692 1
a1692 1
					  xmalloc, free);
d1694 1
a1694 1
					  xmalloc, free);
d1844 1
a1844 1
      free (filename_language_table[i].ext);
d2957 1
a2957 1
    free (cache_ovly_table);
d2969 1
a2969 1
    free (cache_ovly_region_table);
@


1.20
log
@
Corrected spelling errors in comments.
gdbarch.{c,sh} removed a word from a comment.
@
text
@d39 1
@


1.19
log
@2000-10-12  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	From Daniel Berlin <dberlin@@redhat.com> :

	* symtab.c (lookup_symbol_aux): New function. Renamed from
 	lookup_symbol. Move code to do demangling/case sensitivity to
 	lookup_symbol().
  	(lookup_symbol): Now wrapper for lookup_symbol_aux, so we can
 	perform case sensitivity/demangling without leaking memory.  Move
 	code to do demangling/case sensitivity from old_lookup_symbol to
 	here.
	(lookup_partial_symbol): Use SYMBOL_SOURCE_NAME instead of
 	SYMBOL_NAME.
	(lookup_block_symbol): Use SYMBOL_SOURCE_NAME instead of
 	SYMBOL_NAME. Don't do linear search in case of C++.

  	* symfile.c (compare_symbols): Use SYMBOL_SOURCE_NAME instead of
 	SYMBOL_NAME.
  	(compare_psymbols): Same here.
@
text
@d2146 1
a2146 1
   FIXME.  The return valu appears to never be used.
@


1.18
log
@
Corrected spelling in comment: dependant -> dependent
@
text
@d215 1
a215 2

  return (STRCMP (SYMBOL_NAME (*s1), SYMBOL_NAME (*s2)));
d243 8
a250 2
  register char *st1 = SYMBOL_NAME (*(struct partial_symbol **) s1p);
  register char *st2 = SYMBOL_NAME (*(struct partial_symbol **) s2p);
@


1.17
log
@2000-08-07  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* objfiles.h (SECT_OFF_BSS): Don't detect invalid sect_index_bss
 	here, let the users of the macro do it.
	* symtab.h (ANOFFSET): Detect here if the section index is not
 	initialized.
	* xcoffread.c (find_targ_sec): Don't treat .bss as special,
 	because some objfiles may not have that section at all.
	* coffread.c (cs_to_section): Ditto.
	* elfread.c (elf_symtab_read): Detect an uninitialized index
 	value.
	(elfstab_offset_sections): The macro ANOFFSET cannot be used as an
 	lvalue anymore.
	* remote.c (get_offsets, remote_cisco_objfile_relocate): Don't use
 	ANOFFSET as an lvalue.
	* objfiles.c (objfile_relocate, objfile_relocate): Don't use
 	ANOFFSET as an lvalue.
	* symfile.c (default_symfile_offsets): Don't use ANOFFSET as an
 	lvalue.
@
text
@d760 1
a760 1
     dependant code a crack at the new symbols.  For instance, this
d1745 1
a1745 1
	         dependant code a crack at the new symbols.  For instance, this
@


1.16
log
@Protoization.
@
text
@d524 1
a524 1
      ANOFFSET (objfile->section_offsets, osp->sectindex) = osp->addr;
@


1.15
log
@2000-06-21  Pierre Muller  <muller@@ics.u-strasbg.fr>
   * symfile.c (init_filename_language_table) add ".pas", ".p" and ".pp"
   as pascal source file extensions.
@
text
@d209 1
a209 3
compare_symbols (s1p, s2p)
     const PTR s1p;
     const PTR s2p;
d242 1
a242 3
compare_psymbols (s1p, s2p)
     const PTR s1p;
     const PTR s2p;
d274 1
a274 2
sort_pst_symbols (pst)
     struct partial_symtab *pst;
d286 1
a286 2
sort_block_syms (b)
     register struct block *b;
d296 1
a296 2
sort_symtab_syms (s)
     register struct symtab *s;
d321 1
a321 4
obsavestring (ptr, size, obstackp)
     char *ptr;
     int size;
     struct obstack *obstackp;
d342 2
a343 3
obconcat (obstackp, s1, s2, s3)
     struct obstack *obstackp;
     const char *s1, *s2, *s3;
d358 1
a358 2
decrement_reading_symtab (dummy)
     void *dummy;
d369 1
a369 2
psymtab_to_symtab (pst)
     register struct partial_symtab *pst;
d390 1
a390 2
init_entry_point_info (objfile)
     struct objfile *objfile;
d417 1
a417 1
entry_point_address ()
d432 1
a432 4
find_lowest_section (abfd, sect, obj)
     bfd *abfd;
     asection *sect;
     PTR obj;
d500 2
a501 3
default_symfile_offsets (objfile, addrs)
     struct objfile *objfile;
     struct section_addr_info *addrs;
d563 2
a564 5
syms_from_objfile (objfile, addrs, mainline, verbo)
     struct objfile *objfile;
     struct section_addr_info *addrs;
     int mainline;
     int verbo;
d772 1
a772 4
new_symfile_objfile (objfile, mainline, verbo)
     struct objfile *objfile;
     int mainline;
     int verbo;
d808 2
a809 6
symbol_file_add (name, from_tty, addrs, mainline, flags)
     char *name;
     int from_tty;
     struct section_addr_info *addrs;
     int mainline;
     int flags;
d921 1
a921 3
symbol_file_command (args, from_tty)
     char *args;
     int from_tty;
d1007 1
a1007 1
set_initial_language ()
d1035 1
a1035 2
symfile_bfd_open (name)
     char *name;
d1094 1
a1094 2
add_symtab_fns (sf)
     struct sym_fns *sf;
d1107 1
a1107 2
find_sym_fns (objfile)
     struct objfile *objfile;
d1132 1
a1132 3
load_command (arg, from_tty)
     char *arg;
     int from_tty;
d1339 2
a1340 3
report_transfer_performance (data_count, start_time, end_time)
     unsigned long data_count;
     time_t start_time, end_time;
d1394 1
a1394 3
add_symbol_file_command (args, from_tty)
     char *args;
     int from_tty;
d1550 1
a1550 3
add_shared_symbol_files_command (args, from_tty)
     char *args;
     int from_tty;
d1561 1
a1561 1
reread_symbols ()
d1771 1
a1771 3
add_filename_language (ext, lang)
     char *ext;
     enum language lang;
d1788 1
a1788 3
set_ext_lang_command (args, from_tty)
     char *args;
     int from_tty;
d1845 1
a1845 3
info_ext_lang_command (args, from_tty)
     char *args;
     int from_tty;
d1858 1
a1858 1
init_filename_language_table ()
d1889 1
a1889 2
deduce_language_from_filename (filename)
     char *filename;
d1918 1
a1918 3
allocate_symtab (filename, objfile)
     char *filename;
     struct objfile *objfile;
d1950 1
a1950 3
allocate_psymtab (filename, objfile)
     char *filename;
     struct objfile *objfile;
d1992 1
a1992 2
discard_psymtab (pst)
     struct partial_symtab *pst;
d2021 1
a2021 1
clear_symtab_users ()
d2077 1
a2077 1
clear_symtab_users_once ()
d2091 1
a2091 2
cashier_psymtab (pst)
     struct partial_symtab *pst;
d2148 1
a2148 2
free_named_symtabs (name)
     char *name;
d2254 4
a2257 8
start_psymtab_common (objfile, section_offsets,
		      filename, textlow, global_syms, static_syms)
     struct objfile *objfile;
     struct section_offsets *section_offsets;
     char *filename;
     CORE_ADDR textlow;
     struct partial_symbol **global_syms;
     struct partial_symbol **static_syms;
d2274 5
a2278 11
add_psymbol_to_list (name, namelength, namespace, class, list, val, coreaddr,
		     language, objfile)
     char *name;
     int namelength;
     namespace_enum namespace;
     enum address_class class;
     struct psymbol_allocation_list *list;
     long val;			/* Value as a long */
     CORE_ADDR coreaddr;	/* Value as a CORE_ADDR */
     enum language language;
     struct objfile *objfile;
d2323 7
a2329 13
add_psymbol_with_dem_name_to_list (name, namelength, dem_name, dem_namelength,
		   namespace, class, list, val, coreaddr, language, objfile)
     char *name;
     int namelength;
     char *dem_name;
     int dem_namelength;
     namespace_enum namespace;
     enum address_class class;
     struct psymbol_allocation_list *list;
     long val;			/* Value as a long */
     CORE_ADDR coreaddr;	/* Value as a CORE_ADDR */
     enum language language;
     struct objfile *objfile;
d2392 1
a2392 3
init_psymbol_list (objfile, total_symbols)
     struct objfile *objfile;
     int total_symbols;
d2490 1
a2490 2
section_is_overlay (section)
     asection *section;
d2504 1
a2504 1
overlay_invalidate_all ()
d2525 1
a2525 2
overlay_is_mapped (osect)
     struct obj_section *osect;
d2558 1
a2558 2
section_is_mapped (section)
     asection *section;
d2576 1
a2576 3
pc_in_unmapped_range (pc, section)
     CORE_ADDR pc;
     asection *section;
d2594 1
a2594 3
pc_in_mapped_range (pc, section)
     CORE_ADDR pc;
     asection *section;
d2613 1
a2613 3
overlay_unmapped_address (pc, section)
     CORE_ADDR pc;
     asection *section;
d2628 1
a2628 3
overlay_mapped_address (pc, section)
     CORE_ADDR pc;
     asection *section;
d2644 1
a2644 3
symbol_overlayed_address (address, section)
     CORE_ADDR address;
     asection *section;
d2673 1
a2673 2
find_pc_overlay (pc)
     CORE_ADDR pc;
d2700 1
a2700 2
find_pc_mapped_section (pc)
     CORE_ADDR pc;
d2718 1
a2718 3
list_overlays_command (args, from_tty)
     char *args;
     int from_tty;
d2757 1
a2757 3
map_overlay_command (args, from_tty)
     char *args;
     int from_tty;
d2808 1
a2808 3
unmap_overlay_command (args, from_tty)
     char *args;
     int from_tty;
d2838 1
a2838 3
overlay_auto_command (args, from_tty)
     char *args;
     int from_tty;
d2850 1
a2850 3
overlay_manual_command (args, from_tty)
     char *args;
     int from_tty;
d2862 1
a2862 3
overlay_off_command (args, from_tty)
     char *args;
     int from_tty;
d2870 1
a2870 3
overlay_load_command (args, from_tty)
     char *args;
     int from_tty;
d2885 1
a2885 3
overlay_command (args, from_tty)
     char *args;
     int from_tty;
d2948 1
a2948 1
simple_free_overlay_table ()
d2960 1
a2960 1
simple_free_overlay_region_table ()
d2973 1
a2973 4
read_target_long_array (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned int *myaddr;
     int len;
d2987 1
a2987 1
simple_read_overlay_table ()
d3020 1
a3020 1
simple_read_overlay_region_table ()
d3059 1
a3059 2
simple_overlay_update_1 (osect)
     struct obj_section *osect;
d3093 1
a3093 2
simple_overlay_update (osect)
     struct obj_section *osect;
d3138 1
a3138 1
_initialize_symfile ()
@


1.14
log
@	* rs6000-tdep.c: Changes throughout for multi-arch 64-bit
	support.  Incorporate most of tm-rs6000.h.
	(find_toc_address_hook): Rename to rs6000_find_toc_address_hook.
	(rs6000_set_host_arch_hook): Declare.
	(read_memory_addr): Define.
	(pop_frame): Rename to rs6000_pop_frame.
	(rs6000_pop_frame, rs6000_fix_call_dummy, rs6000_push_arguments,
	rs6000_frame_saved_pc, rs6000_frame_chain): Remove non-generic
	dummy frame handling.
	(branch_dest, rs6000_pop_frame, rs6000_skip_trampoline_code,
	rs6000_frame_saved_pc, frame_get_saved_regs,
	frame_initial_stack_address, rs6000_frame_chain,
	rs6000_convert_from_func_ptr_addr): Call read_memory_addr instead
	of read_memory_integer.
	(branch_dest, rs6000_pop_frame, rs6000_push_arguments,
	rs6000_skip_trampoline_code, rs6000_frame_saved_pc,
	frame_get_saved_regs, frame_initial_stack_address,
	rs6000_frame_chain): Replace 4 with TDEP->wordsize.
	(skip_prologue): Recognize some 64-bit stack adjustments.
	(push_dummy_frame, pop_dummy_frame, set_processor,
	show_processor): Delete.
	(frame_get_saved_regs): Manipulate saved register addresses using
	CORE_ADDR instead of int.
	(rs6000_create_inferior): New function.
	(register_names_*[]): Change to struct reg registers_*[].
	(variants[]): Assimilate into multi-arch approach.
	(register_names_*[], variants[]): Refer to pre-PowerPC
	architectures as POWER instead of RS6000.
	* rs6000-nat.c: Ubiquitous changes for 64-bit support.
	(vmap_secs, xcoff_relocate_symtab): Cast addresses
	to unsigned long to avoid sign-extension errors.
	(set_host_arch): New function.
	(xcoff_relocate_symtab): Try disabling usleep(36000) workaround.
	(rs6000_core_fns): Use new bfd_target_xcoff_flavour.
	(_initialize_core_rs6000): Initialize rs6000_set_host_arch_hook.
	* symfile.c (find_sym_fns): Remove special xcoff kludge.
	* xcoffread.c (secnum_to_bfd_section): Initialize args.objfile.
	(process_linenos): Query line struct size from coff
	backend instead of using compile-time constant.
	(enter_line_range): Likewise.
	(read_xcoff_symtab): Pass "XCOFF64" instead of "XCOFF" to
	record_debugformat() if appropriate.
	(process_xcoff_symbol): Access symbol addresses using
	SYMBOL_VALUE_ADDRESS instead of SYMBOL_VALUE.
	(read_symbol_lineno): Retrieve XCOFF64 symbol names from strtbl.
	(scan_xcoff_symtab): Likewise.  Query syment struct size from
	coff backend instead of using compile-time constant.
	(xcoff_sym_fns): Set flavour to bfd_target_xcoff_flavour.
	* Makefile.in (INTERNAL_LDFLAGS): Add $(MH_LDFLAGS) to list of flags
	that this Makefile variable get set to.  (From Kevin Buettner.)
	* config/powerpc/aix.mh (MH_LDFLAGS): Add linker flags so that
	the TOC doesn't overflow.  (From Kevin Buettner.)
	* config/powerpc/tm-ppc-aix.h: Move config decisions to
	multi-arched rs6000-tdep.c.
	* config/rs6000/tm-rs6000.h: Likewise.
	(GDB_MULTI_ARCH): Define.
	(skip_trampoline_code): Rename to rs6000_skip_trampoline_code.
	(is_magic_function_pointer): Replace with
	rs6000_convert_from_func_ptr_addr.
	(TARGET_CREATE_INFERIOR_HOOK): Define.
	(find_toc_address_hook): Rename to rs6000_find_toc_address_hook.
	(rs6000_set_host_arch_hook): Declare.
	* config/rs6000/nm-rs6000.h (CHILD_XFER_MEMORY): Define.
@
text
@d1928 3
@


1.13
log
@	* symfile.c (add_symbol_file_command): Properly reformat "else if"
 	code.
	* coffread.c (coff_symtab_read): Ditto.
@
text
@a1145 5
  /* Special kludge for RS/6000 and PowerMac.  See xcoffread.c.  */
  if (STREQ (our_target, "aixcoff-rs6000") ||
      STREQ (our_target, "xcoff-powermac"))
    our_flavour = (enum bfd_flavour) -1;

a1489 8
      else if (argcnt == 1)
	{
	  /* The second argument is always the text address at which
	     to load the program. */
	  sect_opts[section_index].name = ".text";
	  sect_opts[section_index].value = arg;
	  section_index++;		  
	}
d1491 32
a1522 27
	{
	  /* It's an option (starting with '-') or it's an argument
	     to an option */

	  if (*arg == '-')
	    {
	      if (strcmp (arg, "-mapped") == 0)
		flags |= OBJF_MAPPED;
	      else if (strcmp (arg, "-readnow") == 0)
		flags |= OBJF_READNOW;
	      else if (strcmp (arg, "-s") == 0)
		{
		  if (section_index >= SECT_OFF_MAX)
		    error ("Too many sections specified.");
		  expecting_sec_name = 1;
		  expecting_sec_addr = 1;
		}
	    }
	  else
	    {
	      if (expecting_sec_name)
		{
		  sect_opts[section_index].name = arg;
		  expecting_sec_name = 0;
		}
	      else
		if (expecting_sec_addr)
d1524 2
a1525 3
		    sect_opts[section_index].value = arg;
		    expecting_sec_addr = 0;
		    section_index++;		  
d1528 10
a1537 3
		  error ("USAGE: add-symbol-file <filename> <textaddress> [-mapped] [-readnow] [-s <secname> <addr>]*");
	    }
	}
@


1.12
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d1495 8
d1504 3
a1506 12
	if (argcnt == 1)
	  {
	    /* The second argument is always the text address at which
               to load the program. */
	    sect_opts[section_index].name = ".text";
	    sect_opts[section_index].value = arg;
	    section_index++;		  
	  }
	else
	  {
	    /* It's an option (starting with '-') or it's an argument
	       to an option */
d1508 23
a1530 19
	    if (*arg == '-')
	      {
		if (strcmp (arg, "-mapped") == 0)
		  flags |= OBJF_MAPPED;
		else 
		  if (strcmp (arg, "-readnow") == 0)
		    flags |= OBJF_READNOW;
		  else 
		    if (strcmp (arg, "-s") == 0)
		      {
			if (section_index >= SECT_OFF_MAX)
			  error ("Too many sections specified.");
			expecting_sec_name = 1;
			expecting_sec_addr = 1;
		      }
	      }
	    else
	      {
		if (expecting_sec_name)
d1532 3
a1534 2
		    sect_opts[section_index].name = arg;
		    expecting_sec_name = 0;
d1537 3
a1539 10
		  if (expecting_sec_addr)
		    {
		      sect_opts[section_index].value = arg;
		      expecting_sec_addr = 0;
		      section_index++;		  
		    }
		  else
		    error ("USAGE: add-symbol-file <filename> <textaddress> [-mapped] [-readnow] [-s <secname> <addr>]*");
	      }
	  }
@


1.11
log
@PARAMS removal.
@
text
@d71 3
a73 3
void (*pre_add_symbol_hook) PARAMS ((char *));
void (*post_add_symbol_hook) PARAMS ((void));
void (*target_new_objfile_hook) PARAMS ((struct objfile *));
d2557 1
a2557 2
void (*target_overlay_update) PARAMS ((struct obj_section *))
= simple_overlay_update;
@


1.10
log
@Purge (almost) make_cleanup_func.
@
text
@d99 1
a99 2
extern void report_transfer_performance PARAMS ((unsigned long,
						 time_t, time_t));
d104 2
a105 2
static int simple_read_overlay_region_table PARAMS ((void));
static void simple_free_overlay_region_table PARAMS ((void));
d108 1
a108 1
static void set_initial_language PARAMS ((void));
d110 1
a110 1
static void load_command PARAMS ((char *, int));
d112 1
a112 1
static void add_symbol_file_command PARAMS ((char *, int));
d114 1
a114 1
static void add_shared_symbol_files_command PARAMS ((char *, int));
d116 1
a116 1
static void cashier_psymtab PARAMS ((struct partial_symtab *));
d118 1
a118 1
static int compare_psymbols PARAMS ((const void *, const void *));
d120 1
a120 1
static int compare_symbols PARAMS ((const void *, const void *));
d122 1
a122 1
bfd *symfile_bfd_open PARAMS ((char *));
d124 1
a124 1
static void find_sym_fns PARAMS ((struct objfile *));
d126 1
a126 1
static void decrement_reading_symtab PARAMS ((void *));
d128 1
a128 1
static void overlay_invalidate_all PARAMS ((void));
d130 1
a130 1
static int overlay_is_mapped PARAMS ((struct obj_section *));
d132 1
a132 1
void list_overlays_command PARAMS ((char *, int));
d134 1
a134 1
void map_overlay_command PARAMS ((char *, int));
d136 1
a136 1
void unmap_overlay_command PARAMS ((char *, int));
d138 1
a138 1
static void overlay_auto_command PARAMS ((char *, int));
d140 1
a140 1
static void overlay_manual_command PARAMS ((char *, int));
d142 1
a142 1
static void overlay_off_command PARAMS ((char *, int));
d144 1
a144 1
static void overlay_load_command PARAMS ((char *, int));
d146 1
a146 1
static void overlay_command PARAMS ((char *, int));
d148 1
a148 1
static void simple_free_overlay_table PARAMS ((void));
d150 1
a150 1
static void read_target_long_array PARAMS ((CORE_ADDR, unsigned int *, int));
d152 1
a152 1
static int simple_read_overlay_table PARAMS ((void));
d154 1
a154 1
static int simple_overlay_update_1 PARAMS ((struct obj_section *));
d156 1
a156 1
static void add_filename_language PARAMS ((char *ext, enum language lang));
d158 1
a158 1
static void set_ext_lang_command PARAMS ((char *args, int from_tty));
d160 1
a160 1
static void info_ext_lang_command PARAMS ((char *args, int from_tty));
d162 1
a162 1
static void init_filename_language_table PARAMS ((void));
d164 1
a164 1
void _initialize_symfile PARAMS ((void));
d2125 1
a2125 2
static void
clear_symtab_users_once PARAMS ((void));
d2556 1
a2556 1
static void simple_overlay_update PARAMS ((struct obj_section *));
@


1.9
log
@Cleanup bfd_close() cleanups.
@
text
@d75 2
d610 1
a610 1
  old_chain = make_cleanup ((make_cleanup_func) free_objfile, objfile);
d616 1
a616 1
      make_cleanup ((make_cleanup_func) clear_symtab_users, 0);
d1662 1
a1662 2
	      old_cleanups = make_cleanup ((make_cleanup_func) free_objfile,
					   objfile);
d1664 1
a1664 1
	      make_cleanup ((make_cleanup_func) clear_symtab_users, 0);
d2090 6
@


1.8
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d1233 1
a1233 1
  make_cleanup ((make_cleanup_func) bfd_close, loadfile_bfd);
@


1.7
log
@2000-04-17  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* symfile.h (struct section_addr_info ): Remove fields for special
 	treatment of .text, .data and .bss sections.

	* solib.c (symbol_add_stub): The special field text_addr is not
 	available anymore. Search for the .text field the hard way.

	* symfile.c (build_section_addr_info_from_section_table): Don't
 	fill in {text, data, bss}_addr any more.
	(default_symfile_offsets): Don't use {text, data, bss}_addr fields
 	to fill in section_offsets for objfile.
	(syms_from_objfile): Don't deal with {text, data, bss}_addr as a
 	special case anymore.
        (add_symbol_file_command): Ditto.
@
text
@d521 1
d528 2
a529 1
  /* Now calculate offsets for other sections. */
d535 1
a535 1
      if (addrs->other[i].addr == 0)
d537 1
a537 8
#if 0
      if (strcmp (".text", osp->name) == 0)
	SECT_OFF_TEXT = osp->sectindex ;
      else if (strcmp (".data", osp->name) == 0)
	SECT_OFF_DATA = osp->sectindex ;
      else if (strcmp (".bss", osp->name) == 0)
	SECT_OFF_BSS =  osp->sectindex ;
#endif
d539 2
d543 20
a564 1

d650 6
a655 6
      else if ((bfd_get_section_flags (objfile->obfd, lower_sect) & SEC_CODE)
	       == 0)
	warning ("Lowest section in %s is %s at %s",
		 objfile->name,
		 bfd_section_name (objfile->obfd, lower_sect),
		 paddr (bfd_section_vma (objfile->obfd, lower_sect)));
@


1.6
log
@2000-04-17  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	symfile.c: (symbol_file_command): Remove support for rombug, to
 	simplify code.
@
text
@a480 7
      if (strcmp (stp->the_bfd_section->name, ".text") == 0)
	sap->text_addr = stp->addr;
      else if (strcmp (stp->the_bfd_section->name, ".data") == 0)
	sap->data_addr = stp->addr;
      else if (strcmp (stp->the_bfd_section->name, ".bss") == 0)
	sap->bss_addr = stp->addr;

a526 9
  /* If user explicitly specified values for data and bss, set them here. */
  
  if (addrs->text_addr)
    ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT) = addrs->text_addr;
  if (addrs->data_addr)
    ANOFFSET (objfile->section_offsets, SECT_OFF_DATA) = addrs->data_addr;
  if (addrs->bss_addr)
    ANOFFSET (objfile->section_offsets, SECT_OFF_BSS)  = addrs->bss_addr;
    
d622 1
a622 8
  if (mainline)
    {
      /* No offset from objfile addresses.  */
      addrs -> text_addr = 0;
      addrs -> data_addr = 0;
      addrs -> bss_addr = 0;
    }
  else
d655 1
a655 41
      /* FIXME: These sections will not need special treatment because ALL
	 sections are in the other sections table */
 
      if (addrs->text_addr != 0)
 	{
 	  sect = bfd_get_section_by_name (objfile->obfd, ".text");
 	  if (sect)
 	    {
 	      addrs->text_addr -= bfd_section_vma (objfile->obfd, sect);
 	      lower_offset = addrs->text_addr;
 	    }
 	}
      else 
 	/* ??? who's below me? */
	addrs->text_addr = lower_offset;
 
      if (addrs->data_addr != 0)
	{
	  sect = bfd_get_section_by_name (objfile->obfd, ".data");
	  if (sect)
 	    {
	      addrs->data_addr -= bfd_section_vma (objfile->obfd, sect);
 	      lower_offset = addrs->data_addr;
 	    }
	}
      else
	addrs->data_addr = lower_offset;
 
      if (addrs->bss_addr != 0)
	{
	  sect = bfd_get_section_by_name (objfile->obfd, ".bss");
	  if (sect)
 	    {
	      addrs->bss_addr -= bfd_section_vma (objfile->obfd, sect);
 	      lower_offset = addrs->bss_addr;
 	    }
	}
      else
	addrs->bss_addr = lower_offset;
  
       /* Now calculate offsets for other sections. */
d658 1
a658 2
	 
 	  if (addrs->other[i].addr != 0)
d660 1
a660 1
 	      sect=bfd_get_section_by_name(objfile->obfd, addrs->other[i].name);
d665 1
a721 7
 	  if (strcmp (s->the_bfd_section->name, ".text") == 0)
 	    s_addr = addrs->text_addr;
 	  else if (strcmp (s->the_bfd_section->name, ".data") == 0)
 	    s_addr = addrs->data_addr;
 	  else if (strcmp (s->the_bfd_section->name, ".bss") == 0)
 	    s_addr = addrs->bss_addr;
 	  else 
a1546 7

      if (strcmp (sec, ".text") == 0)
	section_addrs.text_addr = addr;
      else if (strcmp (sec, ".data") == 0)
	section_addrs.data_addr = addr;
      else if (strcmp (sec, ".bss") == 0)
	section_addrs.bss_addr = addr;
@


1.5
log
@2000-04-17  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* symfile.c (add_symbol_file_command): Rewrite the arguments
 	processing part. Simplify syntax of command. Remove support for
 	rombug.
	(_initialize_symfile): Update help message for add-symbol-file
 	command.
@
text
@d996 4
a1007 1
  CORE_ADDR text_relocation = 0;	/* text_relocation */
a1031 1
	{
a1032 1
	}
d1047 3
a1049 5
	    {
	      flags |= OBJF_MAPPED;
	    }
	  else if (STREQ (*argv, "-readnow"))
	    {
d1051 3
a1053 16
	    }
	  else if (**argv == '-')
	    {
	      error ("unknown option `%s'", *argv);
	    }
	  else
	    {
	      char *p;

	      name = *argv;

	      /* this is for rombug remote only, to get the text relocation by
	         using link command */
	      p = strrchr (name, '/');
	      if (p != NULL)
		p++;
a1054 7
		p = name;

	      target_link (p, &text_relocation);

	      if (text_relocation == (CORE_ADDR) 0)
		return;
	      else if (text_relocation == (CORE_ADDR) -1)
d1056 1
d1061 5
a1066 14
	      else
		{
		  struct section_addr_info section_addrs;
		  memset (&section_addrs, 0, sizeof (section_addrs));
		  section_addrs.text_addr = (CORE_ADDR) text_relocation;
		  symbol_file_add (name, from_tty, &section_addrs, 0, flags);
		}

	      /* Getting new symbols may change our opinion about what is
	         frameless.  */
	      reinit_frame_cache ();

	      set_initial_language ();
	    }
@


1.4
log
@	* symfile.c (map_overlay_command, unmap_overlay_command): Fix
	error message: there's no "overlay on" command.
@
text
@d1508 6
d1521 1
a1521 1
  char *name = NULL;
d1525 1
a1525 1
  int option_index = 0;
d1529 3
a1533 1
    enum { OPT_SECTION } type;
d1536 2
a1537 1
  } opt[SECT_OFF_MAX];
d1539 1
d1544 1
a1544 3
    {
      error ("add-symbol-file takes a file name and an address");
    }
a1546 1

a1547 1
  make_cleanup (free, args);
a1551 2
  /* Pick off any -option args and the file name. */

d1554 1
d1556 3
a1558 3
	{
	  args++;
	}
d1560 2
d1563 4
a1566 3
	{
	  args++;
	}
d1568 4
d1573 3
a1575 1
	  *args++ = '\000';
d1577 31
a1607 81
      if (*arg != '-')
	{
	  if (expecting_option)
	    {
 	      opt[option_index++].value = arg;
 	      expecting_option = 0;
 	    }
 	  else
 	    {
	      switch (argcnt)
		{
 		case 0:
 		  name = arg;
 		  break;
 		case 1: 
 		  opt[option_index].type = OPT_SECTION;
 		  opt[option_index].name = ".text";
 		  opt[option_index++].value = arg;
 		  break;
 		case 2: 
 		  opt[option_index].type = OPT_SECTION;
 		  opt[option_index].name = ".data";
 		  opt[option_index++].value = arg;
 		  break;
 		case 3: 
 		  opt[option_index].type = OPT_SECTION;
 		  opt[option_index].name = ".bss";
 		  opt[option_index++].value = arg;
 		  break;
 		default:
 		  warning ("Too many arguments entered; see \"help add-symbol-file\" for command syntax.");
		}
	      argcnt++;
 	    }
	}
      else if (STREQ (arg, "-mapped"))
	{
	  flags |= OBJF_MAPPED;
	}
      else if (STREQ (arg, "-readnow"))
	{
	  flags |= OBJF_READNOW;
	}
      else if (STREQN (arg, "-T", 2))
 	{
 	  if (option_index >= SECT_OFF_MAX)
	    {
	      warning ("Number of options exceeds maximum allowed.");
	    }
 	  else
 	    {
 	      expecting_option = 1;
 	      opt[option_index].type = OPT_SECTION;
 	      opt[option_index].name = arg + 2;
 	    }
 	}
      else 
        {
	  error ("Unknown option `%s'", arg);
        }
    }

  if (name == NULL)
    {
      error ("add-symbol-file takes a file name");
    }
  name = tilde_expand (name);
  make_cleanup (free, name);

  if (option_index > 0)
    {
      /* Print the prompt for the query below.
	 We have to split this up into 3 print statements because
	 local_hex_string returns a local static string. */
 
      printf_filtered ("add symbol table from file \"%s\" at\n", name);
      for (i = 0; i < option_index; i++)
	{
	  switch (opt[i].type)
	    {
	    case OPT_SECTION:
d1609 24
a1632 3
                CORE_ADDR addr;
                char *val = opt[i].value;
                char *sec = opt[i].name;
d1634 6
a1639 5
                val = opt[i].value;
                if (val[0] == '0' && val[1] == 'x')
                  addr = strtoul (val+2, NULL, 16);
                else
                  addr = strtoul (val, NULL, 10);
d1641 27
a1667 43
                if (strcmp (sec, ".text") == 0)
                  section_addrs.text_addr = addr;
                else if (strcmp (sec, ".data") == 0)
                  section_addrs.data_addr = addr;
                else if (strcmp (sec, ".bss") == 0)
                  section_addrs.bss_addr = addr;
                /* Add the section to the others even if it is a
                   text data or bss section. This is redundent but
                   eventually, none will be given special treatment */
		{
		  section_addrs.other[sec_num].name = xstrdup (sec);
		  make_cleanup (free, section_addrs.other[sec_num].name);
		  section_addrs.other[sec_num++].addr = addr;
		  printf_filtered ("\t%s_addr = %s\n",
				   sec, 
				   local_hex_string ((unsigned long)addr));
		}
 
                /* The object's sections are initialized when a 
                   call is made to build_objfile_section_table (objfile).
                   This happens in reread_symbols. 
                   At this point, we don't know what file type this is,
                   so we can't determine what section names are valid.  */
              }
              break;
            default:
              complain (&unknown_option_complaint, opt[i].name);
	    }
	}
      /* Eventually, these hard coded names will be obsolete */
      /* All the addresses will be on the others section */
    }
  else
    {
      CORE_ADDR text_addr;
      target_link (name, &text_addr);  
      if (text_addr == (CORE_ADDR) -1)
	error("Don't know how to get text start location for this file");
      section_addrs.text_addr = text_addr;
      section_addrs.data_addr = 0;
      section_addrs.bss_addr = 0;
      printf_filtered("add symbol table from file \"%s\" at text_addr = %s?\n",
		      name, local_hex_string ((unsigned long)text_addr));
d1669 1
d1673 1
a1673 1
  symbol_file_add (name, from_tty, &section_addrs, 0, flags);
d1678 1
d3345 1
a3345 2
	       "Usage: add-symbol-file FILE ADDR [DATA_ADDR [BSS_ADDR]]\n\
or:    add-symbol-file FILE -T<SECT> <SECT_ADDR> -T<SECT> <SECT_ADDR> ...\n\
d3348 3
a3350 3
The optional arguments, DATA_ADDR and BSS_ADDR, should be specified\n\
if the data and bss segments are not contiguous with the text.\n\
For complicated cases, SECT is a section name to be loaded at SECT_ADDR.",
@


1.3
log
@Make sure section addresses from a shared object are correctly set in
a new struct objfile.
@
text
@d2971 3
a2973 1
    error ("Overlay debugging not enabled.  Use the 'OVERLAY ON' command.");
d3023 3
a3025 1
    error ("Overlay debugging not enabled.  Use the 'OVERLAY ON' command.");
@


1.2
log
@2000-03-15  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        From "Peter.Schauer" <Peter.Schauer@@regent.e-technik.tu-muenchen.de>
        * symfile.c (reread_symbols):  Clear msymbol hash table.
@
text
@d464 52
a585 1
  struct section_offsets *section_offsets;
d792 3
a794 1
 	    for (i = 0; !s_addr && addrs->other[i].name; i++)
a1515 1
  CORE_ADDR text_addr;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998
   Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d36 1
a36 1
#include "inferior.h" /* for write_pc */
a46 3
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
d65 6
a70 1
int (*ui_load_progress_hook) PARAMS ((char *, unsigned long));
d73 1
d76 1
a76 1
int readnow_symbol_files;		/* Read full symbols immediately */
d78 2
a79 1
struct complaint oldsyms_complaint = {
d83 2
a84 1
struct complaint empty_symtab_complaint = {
d88 5
d155 8
d198 1
a198 1
   */
d201 1
a202 1

d222 1
a222 1
LOCAL FUNCTION
d224 1
a224 1
	compare_psymbols -- compare two partial symbols by name
d226 1
a226 1
DESCRIPTION
d228 3
a230 3
	Given pointers to pointers to two partial symbol table entries,
	compare them by name and return -N, 0, or +N (ala strcmp).
	Typically used by sorting routines like qsort().
d232 1
a232 1
NOTES
d234 5
a238 5
	Does direct compare of first two characters before punting
	and passing to strcmp for longer compares.  Note that the
	original version had a bug whereby two null strings or two
	identically named one character strings would return the
	comparison of memory following the null byte.
d272 1
a272 1
      return ( strcmp (st1, st2));
d282 2
a283 2
  qsort (pst -> objfile -> global_psymbols.list + pst -> globals_offset,
	 pst -> n_global_syms, sizeof (struct partial_symbol *),
d389 1
a389 1
    { 
d408 1
a408 1
  if (bfd_get_file_flags (objfile -> obfd) & EXEC_P)
d411 2
a412 2
	 the startup file because it contains the entry point.  */
      objfile -> ei.entry_point = bfd_get_start_address (objfile -> obfd);
d417 1
a417 1
      objfile -> ei.entry_point = INVALID_ENTRY_POINT;
d419 6
a424 6
  objfile -> ei.entry_file_lowpc = INVALID_ENTRY_LOWPC;
  objfile -> ei.entry_file_highpc = INVALID_ENTRY_HIGHPC;
  objfile -> ei.entry_func_lowpc = INVALID_ENTRY_LOWPC;
  objfile -> ei.entry_func_highpc = INVALID_ENTRY_HIGHPC;
  objfile -> ei.main_func_lowpc = INVALID_ENTRY_LOWPC;
  objfile -> ei.main_func_highpc = INVALID_ENTRY_HIGHPC;
d430 1
a430 1
entry_point_address()
d450 1
a450 1
  asection **lowest = (asection **)obj;
d470 2
a471 2
struct section_offsets *
default_symfile_offsets (objfile, addr)
d473 1
a473 1
     CORE_ADDR addr;
a474 1
  struct section_offsets *section_offsets;
d478 3
a480 2
  section_offsets = (struct section_offsets *)
    obstack_alloc (&objfile -> psymbol_obstack, SIZEOF_SECTION_OFFSETS);
d482 1
a482 2
  for (i = 0; i < SECT_OFF_MAX; i++)
    ANOFFSET (section_offsets, i) = addr;
d484 26
a509 1
  return section_offsets;
d516 10
a525 8
   NAME is the file name (which will be tilde-expanded and made
   absolute herein) (but we don't free or modify NAME itself).
   FROM_TTY says how verbose to be.  MAINLINE specifies whether this
   is the main symbol file, or whether it's an extra symbol file such
   as dynamically loaded code.  If !mainline, ADDR is the address
   where the text segment was loaded.  If VERBO, the caller has printed
   a verbose message about the symbol reading (and complaints can be
   more terse about it).  */
d528 1
a528 1
syms_from_objfile (objfile, addr, mainline, verbo)
d530 1
a530 1
     CORE_ADDR addr;
d535 4
a538 1
  asection *lowest_sect;
d540 11
d559 1
a559 1
  if (mainline) 
d562 1
a562 1
	 will be cleaned up if an error occurs during symbol reading.  */
d574 3
a576 3
	 If the user wants to get rid of them, they should do "symbol-file"
	 without arguments first.  Not sure this is the best behavior
	 (PR 2207).  */
d578 1
a578 1
      (*objfile -> sf -> sym_new_init) (objfile);
d583 1
a583 2
     and assume that <addr> is where that got loaded.  Due to historical
     precedent, we warn if that doesn't happen to be a text segment.  */
d585 2
d589 4
a592 1
      addr = 0;		/* No offset from objfile addresses.  */
d596 5
a600 2
      lowest_sect = bfd_get_section_by_name (objfile->obfd, ".text");
      if (lowest_sect == NULL)
d602 2
a603 3
			       (PTR) &lowest_sect);

      if (lowest_sect == NULL)
d606 1
a606 1
      else if ((bfd_get_section_flags (objfile->obfd, lowest_sect) & SEC_CODE)
d608 1
a608 2
	/* FIXME-32x64--assumes bfd_vma fits in long.  */
	warning ("Lowest section in %s is %s at 0x%lx",
d610 80
a689 5
		 bfd_section_name (objfile->obfd, lowest_sect),
		 (unsigned long) bfd_section_vma (objfile->obfd, lowest_sect));

      if (lowest_sect)
	addr -= bfd_section_vma (objfile->obfd, lowest_sect);
d696 1
a696 1
  (*objfile -> sf -> sym_init) (objfile);
d699 1
a699 2
  section_offsets = (*objfile -> sf -> sym_offsets) (objfile, addr);
  objfile->section_offsets = section_offsets;
d715 1
a715 1
     has a different algorythm for finding section offsets.
d720 1
a720 1
  if (addr)
d724 21
a744 2
      for (s = objfile->sections; s < objfile->sections_end; ++s)
	{
d746 1
a746 1
	  s->addr += addr;
d748 2
a749 2
	  s->endaddr += addr;
	  s->offset += addr;
d754 1
a754 1
  (*objfile -> sf -> sym_read) (objfile, section_offsets, mainline);
d774 1
a774 1
  objfile -> flags |= OBJF_SYMS;
d780 4
a783 4
/* Call this after reading in a new symbol table to give target dependant code
   a crack at the new symbols.  For instance, this could be used to update the
   values of target-specific symbols GDB needs to keep track of (such as
   _sigtramp, or whatever).  */
d791 1
a791 1
   
a827 6
   USER_LOADED is TRUE if the add-symbol-file command was how this
   symbol file came to be processed.

   IS_SOLIB is TRUE if this symbol file represents a solib, as discovered
   by the target's implementation of the solib package.

d832 1
a832 1
symbol_file_add (name, from_tty, addr, mainline, mapped, readnow, user_loaded, is_solib)
d835 1
a835 1
     CORE_ADDR addr;
d837 1
a837 4
     int mapped;
     int readnow;
     int  user_loaded;
     int  is_solib;
d852 1
a852 1
      error ("Not confirmed.");
d854 1
a854 1
  objfile = allocate_objfile (abfd, mapped, user_loaded, is_solib);
d859 1
a859 1
  if ((objfile -> flags & OBJF_MAPPED) && (objfile -> flags & OBJF_SYMS))
d862 3
a864 3
	 initial symbol reading performed, so we can skip that part.  Notify
	 the user that instead of reading the symbols, they have been mapped.
	 */
d877 2
a878 2
	 symbol table file which has not had initial symbol reading
	 performed, or need to read an unmapped symbol table. */
d890 1
a890 1
      syms_from_objfile (objfile, addr, mainline, from_tty);
d898 1
a898 1
  if (readnow || readnow_symbol_files)
d907 1
a907 1
      for (psymtab = objfile -> psymtabs;
d909 1
a909 1
	   psymtab = psymtab -> next)
d918 1
a918 1
        post_add_symbol_hook ();
d920 4
a923 4
        {
          printf_filtered ("done.\n");
          gdb_flush (gdb_stdout);
        }
d928 2
a929 1
  target_new_objfile (objfile);
d951 1
a951 1
  CORE_ADDR text_relocation = 0;		/* text_relocation */
d953 1
a953 2
  int mapped = 0;
  int readnow = 0;
d962 1
a962 1
		     symfile_objfile -> name))
d969 1
a969 1
         */
d989 1
a989 1
      cleanups = make_cleanup ((make_cleanup_func) freeargv, (char *) argv);
d994 1
a994 1
	      mapped = 1;
d998 1
a998 1
	      readnow = 1;
d1006 1
a1006 1
            char *p;
d1008 1
a1008 1
              name = *argv;
d1010 15
a1024 14
              /* this is for rombug remote only, to get the text relocation by
              using link command */
              p = strrchr(name, '/');
              if (p != NULL) p++;
              else p = name;

              target_link(p, &text_relocation);

              if (text_relocation == (CORE_ADDR)0)
                return;
              else if (text_relocation == (CORE_ADDR)-1)
                {
                  symbol_file_add (name, from_tty, (CORE_ADDR)0, 
                                   1, mapped, readnow, 1, 0);
d1026 1
a1026 1
                  RESET_HP_UX_GLOBALS ();
d1028 8
a1035 4
                }
              else
                symbol_file_add (name, from_tty, (CORE_ADDR)text_relocation,
				 0, mapped, readnow, 1, 0);
d1038 1
a1038 1
		 frameless.  */
d1041 1
a1041 1
              set_initial_language ();
d1050 1
a1050 1
      TUIDO(((TuiOpaqueFuncPtr)tuiDisplayMainFunction));
d1069 1
a1069 1
  enum language lang = language_unknown;  	
d1074 1
a1074 1
      if (pst -> filename != NULL)
d1076 2
a1077 2
	  lang = deduce_language_from_filename (pst -> filename);
        }
d1080 2
a1081 2
	    /* Make C the default language */
	    lang = language_c;
d1113 1
a1113 1
                    0, &absolute_name);
d1123 1
a1123 1
				/* It'll be freed in free_objfile(). */
d1138 2
a1139 2
	 on error it does not free all the storage associated with the
	 bfd).  */
d1172 2
a1173 2
  enum bfd_flavour our_flavour = bfd_get_flavour (objfile -> obfd);
  char *our_target = bfd_get_target (objfile -> obfd);
d1178 1
a1178 1
    our_flavour = (enum bfd_flavour)-1;
d1182 1
a1182 1
    our_flavour = (enum bfd_flavour)-2;
d1184 1
a1184 1
  for (sf = symtab_fns; sf != NULL; sf = sf -> next)
d1186 1
a1186 1
      if (our_flavour == sf -> sym_flavour)
d1188 1
a1188 1
	  objfile -> sf = sf;
d1193 1
a1193 1
	 bfd_get_target (objfile -> obfd));
d1216 4
a1219 2
#define GENERIC_LOAD_CHUNK 256
#define VALIDATE_DOWNLOAD 0
d1221 1
a1221 3
generic_load (filename, from_tty)
    char *filename;
    int from_tty;
a1222 1
  struct cleanup *old_cleanups;
d1227 22
a1248 11
  int n; 
  unsigned long load_offset = 0; 	/* offset to add to vma for each section */
  char buf[GENERIC_LOAD_CHUNK+8];
#if VALIDATE_DOWNLOAD  
  char verify_buffer[GENERIC_LOAD_CHUNK+8] ;
#endif  

  /* enable user to specify address for downloading as 2nd arg to load */
  n = sscanf(filename, "%s 0x%lx", buf, &load_offset);
  if (n > 1 ) 
    filename = buf;
d1252 1
d1259 1
d1263 1
a1263 1
  old_cleanups = make_cleanup ((make_cleanup_func) bfd_close, loadfile_bfd);
d1265 1
a1265 1
  if (!bfd_check_format (loadfile_bfd, bfd_object)) 
d1270 5
a1274 1
  
d1277 1
a1277 1
  for (s = loadfile_bfd->sections; s; s = s->next) 
d1279 83
a1361 3
      if (s->flags & SEC_LOAD) 
        {
          bfd_size_type size;
d1363 3
a1365 67
          size = bfd_get_section_size_before_reloc (s);
          if (size > 0)
            {
              char *buffer;
              struct cleanup *old_chain;
              bfd_vma lma;
              unsigned long l = size ;
              int err;
              char *sect;
              unsigned long sent;
              unsigned long len;
	      
	      l = l > GENERIC_LOAD_CHUNK ? GENERIC_LOAD_CHUNK : l ;

              buffer = xmalloc (size);
              old_chain = make_cleanup (free, buffer);

              lma = s->lma;
              lma += load_offset;

              /* Is this really necessary?  I guess it gives the user something
                 to look at during a long download.  */
              printf_filtered ("Loading section %s, size 0x%lx lma ",
                               bfd_get_section_name (loadfile_bfd, s),
                               (unsigned long) size);
              print_address_numeric (lma, 1, gdb_stdout);
              printf_filtered ("\n");

              bfd_get_section_contents (loadfile_bfd, s, buffer, 0, size);

              sect = (char *) bfd_get_section_name (loadfile_bfd, s);
              sent = 0;
              do
                {            
                  len = (size - sent) < l ? (size - sent) : l;
                  sent += len;
                  err = target_write_memory (lma, buffer, len);
                  if (ui_load_progress_hook)
                    if (ui_load_progress_hook (sect, sent))
		      error ("Canceled the download");
#if VALIDATE_DOWNLOAD
		  /* Broken memories and broken monitors manifest themselves
		     here when bring new computers to life.
		     This doubles already slow downloads.
		  */
		  if (err) break ;
		  {
		    target_read_memory(lma,verify_buffer,len) ;
		    if (0 != bcmp(buffer,verify_buffer,len))
		      error("Download verify failed at %08x",
			    (unsigned long)lma) ;
		  }

#endif
		  data_count += len ;
                  lma  += len;
                  buffer += len;
                } /* od */
              while (err == 0 && sent < size);

              if (err != 0)
                error ("Memory access error while loading section %s.", 
                       bfd_get_section_name (loadfile_bfd, s));
                
              do_cleanups (old_chain);
            }
        }
d1370 14
a1383 3
    unsigned long entry ;
    entry = bfd_get_start_address(loadfile_bfd) ;
    printf_filtered ("Start address 0x%lx , load size %d\n", entry,data_count);
d1395 2
a1396 1
  report_transfer_performance (data_count, start_time, end_time);
d1403 4
d1409 11
a1419 2
unsigned long data_count;
time_t start_time, end_time;
d1421 8
a1428 4
  printf_filtered ("Transfer rate: ");
  if (end_time != start_time)
    printf_filtered ("%d bits/sec",
		     (data_count * 8) / (end_time - start_time));
d1430 21
a1450 2
    printf_filtered ("%d bits in <1 sec", (data_count * 8));
  printf_filtered (".\n");
d1464 1
d1466 13
a1478 3
  int readnow = 0;
  int mapped = 0;
  
d1488 1
a1488 1
  args = strdup (args);
d1491 3
d1496 1
a1496 1
  while ((*args != '\000') && (name == NULL))
d1498 4
a1501 1
      while (isspace (*args)) {args++;}
d1503 4
a1506 1
      while ((*args != '\000') && !isspace (*args)) {args++;}
d1513 32
a1544 1
	  name = arg;
d1548 1
a1548 1
	  mapped = 1;
d1552 1
a1552 5
	  readnow = 1;
	}
      else
	{
	  error ("unknown option `%s'", arg);
d1554 17
a1572 4
  /* After picking off any options and the file name, args should be
     left pointing at the remainder of the command line, which should
     be the address expression to evaluate. */

d1580 1
a1580 1
  if (*args != '\000')
d1582 52
a1633 1
      text_addr = parse_and_eval_address (args);
d1637 3
a1639 2
      target_link(name, &text_addr);
      if (text_addr == (CORE_ADDR)-1)
d1641 5
d1647 1
a1647 5

  /* FIXME-32x64: Assumes text_addr fits in a long.  */
  if ((from_tty)
      && (!query ("add symbol table from file \"%s\" at text_addr = %s?\n",
	          name, local_hex_string ((unsigned long)text_addr))))
d1650 1
a1650 3
  symbol_file_add (name, from_tty, text_addr, 0, mapped, readnow,
                   1,  /* user_loaded */
                   0); /* We'll guess it's ! is_solib */
d1658 1
a1658 1
add_shared_symbol_files_command  (args, from_tty)
d1666 1
a1666 1
#endif  
d1685 4
a1688 2
  for (objfile = object_files; objfile; objfile = objfile->next) {
    if (objfile->obfd) {
d1690 2
a1691 2
     /* If this object is from a shared library, then you should
        stat on the library name, not member name. */
d1693 6
a1698 92
     if (objfile->obfd->my_archive)
       res = stat (objfile->obfd->my_archive->filename, &new_statbuf);
     else
#endif
      res = stat (objfile->name, &new_statbuf);
      if (res != 0) {
	/* FIXME, should use print_sys_errmsg but it's not filtered. */
	printf_filtered ("`%s' has disappeared; keeping its symbols.\n",
			 objfile->name);
	continue;
      }
      new_modtime = new_statbuf.st_mtime;
      if (new_modtime != objfile->mtime)
	{
	  struct cleanup *old_cleanups;
	  struct section_offsets *offsets;
	  int num_offsets;
	  int section_offsets_size;
	  char *obfd_filename;

	  printf_filtered ("`%s' has changed; re-reading symbols.\n",
			   objfile->name);

	  /* There are various functions like symbol_file_add,
	     symfile_bfd_open, syms_from_objfile, etc., which might
	     appear to do what we want.  But they have various other
	     effects which we *don't* want.  So we just do stuff
	     ourselves.  We don't worry about mapped files (for one thing,
	     any mapped file will be out of date).  */

	  /* If we get an error, blow away this objfile (not sure if
	     that is the correct response for things like shared
	     libraries).  */
	  old_cleanups = make_cleanup ((make_cleanup_func) free_objfile, 
                                       objfile);
	  /* We need to do this whenever any symbols go away.  */
	  make_cleanup ((make_cleanup_func) clear_symtab_users, 0);

	  /* Clean up any state BFD has sitting around.  We don't need
	     to close the descriptor but BFD lacks a way of closing the
	     BFD without closing the descriptor.  */
	  obfd_filename = bfd_get_filename (objfile->obfd);
	  if (!bfd_close (objfile->obfd))
	    error ("Can't close BFD for %s: %s", objfile->name,
		   bfd_errmsg (bfd_get_error ()));
	  objfile->obfd = bfd_openr (obfd_filename, gnutarget);
	  if (objfile->obfd == NULL)
	    error ("Can't open %s to read symbols.", objfile->name);
	  /* bfd_openr sets cacheable to true, which is what we want.  */
	  if (!bfd_check_format (objfile->obfd, bfd_object))
	    error ("Can't read symbols from %s: %s.", objfile->name,
		   bfd_errmsg (bfd_get_error ()));

	  /* Save the offsets, we will nuke them with the rest of the
	     psymbol_obstack.  */
	  num_offsets = objfile->num_sections;
	  section_offsets_size =
	    sizeof (struct section_offsets)
	      + sizeof (objfile->section_offsets->offsets) * num_offsets;
	  offsets = (struct section_offsets *) alloca (section_offsets_size);
	  memcpy (offsets, objfile->section_offsets, section_offsets_size);

	  /* Nuke all the state that we will re-read.  Much of the following
	     code which sets things to NULL really is necessary to tell
	     other parts of GDB that there is nothing currently there.  */

	  /* FIXME: Do we have to free a whole linked list, or is this
	     enough?  */
	  if (objfile->global_psymbols.list)
	    mfree (objfile->md, objfile->global_psymbols.list);
	  memset (&objfile -> global_psymbols, 0,
		  sizeof (objfile -> global_psymbols));
	  if (objfile->static_psymbols.list)
	    mfree (objfile->md, objfile->static_psymbols.list);
	  memset (&objfile -> static_psymbols, 0,
		  sizeof (objfile -> static_psymbols));

	  /* Free the obstacks for non-reusable objfiles */
	  obstack_free (&objfile -> psymbol_cache.cache, 0);
	  memset (&objfile -> psymbol_cache, 0,
		  sizeof (objfile -> psymbol_cache));
	  obstack_free (&objfile -> psymbol_obstack, 0);
	  obstack_free (&objfile -> symbol_obstack, 0);
	  obstack_free (&objfile -> type_obstack, 0);
	  objfile->sections = NULL;
	  objfile->symtabs = NULL;
	  objfile->psymtabs = NULL;
	  objfile->free_psymtabs = NULL;
	  objfile->msymbols = NULL;
	  objfile->minimal_symbol_count= 0;
	  objfile->fundamental_types = NULL;
	  if (objfile -> sf != NULL)
d1700 4
a1703 1
	      (*objfile -> sf -> sym_finish) (objfile);
d1705 2
a1706 14

	  /* We never make this a mapped file.  */
	  objfile -> md = NULL;
	  /* obstack_specify_allocation also initializes the obstack so
	     it is empty.  */
	  obstack_specify_allocation (&objfile -> psymbol_cache.cache, 0, 0,
				      xmalloc, free);
	  obstack_specify_allocation (&objfile -> psymbol_obstack, 0, 0,
				      xmalloc, free);
	  obstack_specify_allocation (&objfile -> symbol_obstack, 0, 0,
				      xmalloc, free);
	  obstack_specify_allocation (&objfile -> type_obstack, 0, 0,
				      xmalloc, free);
	  if (build_objfile_section_table (objfile))
d1708 111
a1818 17
	      error ("Can't find the file sections in `%s': %s", 
		     objfile -> name, bfd_errmsg (bfd_get_error ()));
	    }

	  /* We use the same section offsets as from last time.  I'm not
	     sure whether that is always correct for shared libraries.  */
	  objfile->section_offsets = (struct section_offsets *)
	    obstack_alloc (&objfile -> psymbol_obstack, section_offsets_size);
	  memcpy (objfile->section_offsets, offsets, section_offsets_size);
	  objfile->num_sections = num_offsets;

	  /* What the hell is sym_new_init for, anyway?  The concept of
	     distinguishing between the main file and additional files
	     in this way seems rather dubious.  */
	  if (objfile == symfile_objfile)
            {
              (*objfile->sf->sym_new_init) (objfile);
d1820 1
a1820 1
              RESET_HP_UX_GLOBALS ();
d1822 1
a1822 1
            }
d1824 13
a1836 13
	  (*objfile->sf->sym_init) (objfile);
	  clear_complaints (1, 1);
	  /* The "mainline" parameter is a hideous hack; I think leaving it
	     zero is OK since dbxread.c also does what it needs to do if
	     objfile->global_psymbols.size is 0.  */
	  (*objfile->sf->sym_read) (objfile, objfile->section_offsets, 0);
	  if (!have_partial_symbols () && !have_full_symbols ())
	    {
	      wrap_here ("");
	      printf_filtered ("(no debugging symbols found)\n");
	      wrap_here ("");
	    }
	  objfile -> flags |= OBJF_SYMS;
d1838 2
a1839 2
	  /* We're done reading the symbol file; finish off complaints.  */
	  clear_complaints (0, 1);
d1841 2
a1842 2
	  /* Getting new symbols may change our opinion about what is
	     frameless.  */
d1844 1
a1844 1
	  reinit_frame_cache ();
d1846 2
a1847 2
	  /* Discard cleanups as symbol reading was successful.  */
	  discard_cleanups (old_cleanups);
d1849 10
a1858 5
	  /* If the mtime has changed between the time we set new_modtime
	     and now, we *want* this to be out of date, so don't call stat
	     again now.  */
	  objfile->mtime = new_modtime;
	  reread_one = 1;
d1860 2
a1861 6
	  /* Call this after reading in a new symbol table to give target
	     dependant code a crack at the new symbols.  For instance, this
	     could be used to update the values of target-specific symbols GDB
	     needs to keep track of (such as _sigtramp, or whatever).  */

	  TARGET_SYMFILE_POSTREAD (objfile);
a1863 1
  }
d1868 1
a1869 1

d1871 3
a1873 2
typedef struct {
  char         *ext;
d1875 2
a1876 1
} filename_language;
d1878 1
a1878 1
static filename_language * filename_language_table;
d1883 1
a1883 1
     char         *ext;
d1889 1
a1889 1
      filename_language_table = realloc (filename_language_table, 
d1893 1
a1893 1
  filename_language_table[fl_table_next].ext  = strsave (ext);
d1914 1
a1914 1
  while (*cp && !isspace (*cp))	
d1922 1
a1922 1
  *cp++ = '\0'; 
d1954 1
a1954 1
      filename_language_table[i].ext  = strsave (ext_args);
d1962 1
a1962 1
     int   from_tty;
d1969 2
a1970 2
    printf_filtered ("\t%s\t- %s\n", 
		     filename_language_table[i].ext, 
d1981 1
a1981 1
      filename_language_table = 
d1983 8
a1990 8
      add_filename_language (".c",     language_c);
      add_filename_language (".C",     language_cplus);
      add_filename_language (".cc",    language_cplus);
      add_filename_language (".cp",    language_cplus);
      add_filename_language (".cpp",   language_cplus);
      add_filename_language (".cxx",   language_cplus);
      add_filename_language (".c++",   language_cplus);
      add_filename_language (".java",  language_java);
d1992 7
a1998 7
      add_filename_language (".ch",    language_chill);
      add_filename_language (".c186",  language_chill);
      add_filename_language (".c286",  language_chill);
      add_filename_language (".f",     language_fortran);
      add_filename_language (".F",     language_fortran);
      add_filename_language (".s",     language_asm);
      add_filename_language (".S",     language_asm);
d2024 6
a2029 6
	LINETABLE(symtab)
	symtab->blockvector
	symtab->dirname
	symtab->free_code
	symtab->free_ptr
	possibly free_named_symtabs (symtab->filename);
d2040 1
a2040 1
    obstack_alloc (&objfile -> symbol_obstack, sizeof (struct symtab));
d2042 6
a2047 6
  symtab -> filename = obsavestring (filename, strlen (filename),
				     &objfile -> symbol_obstack);
  symtab -> fullname = NULL;
  symtab -> language = deduce_language_from_filename (filename);
  symtab -> debugformat = obsavestring ("unknown", 7,
					&objfile -> symbol_obstack);
d2051 3
a2053 3
  symtab -> objfile = objfile;
  symtab -> next = objfile -> symtabs;
  objfile -> symtabs = symtab;
d2073 1
a2073 1
  if (objfile -> free_psymtabs)
d2075 2
a2076 2
      psymtab = objfile -> free_psymtabs;
      objfile -> free_psymtabs = psymtab -> next;
d2080 1
a2080 1
      obstack_alloc (&objfile -> psymbol_obstack,
d2084 3
a2086 3
  psymtab -> filename = obsavestring (filename, strlen (filename),
				      &objfile -> psymbol_obstack);
  psymtab -> symtab = NULL;
d2092 3
a2094 3
  psymtab -> objfile = objfile;
  psymtab -> next = objfile -> psymtabs;
  objfile -> psymtabs = psymtab;
d2098 3
a2100 3
    psymtab -> objfile = objfile;
    psymtab -> next = NULL;
    prev_pst = &(objfile -> psymtabs);
d2102 1
a2102 1
      prev_pst = &((*prev_pst) -> next);
d2104 1
a2104 1
  }  
d2106 1
a2106 1
  
d2135 1
a2136 1

d2153 2
a2154 1
  target_new_objfile (NULL);
d2213 14
a2226 5
  for (ps = pst->objfile->psymtabs; ps; ps = ps->next) {
    if (ps == pst)
      break;
    pprev = ps;
  }
d2228 18
a2245 20
  if (ps) {
    /* Unhook it from the chain.  */
    if (ps == pst->objfile->psymtabs)
      pst->objfile->psymtabs = ps->next;
    else
      pprev->next = ps->next;

    /* FIXME, we can't conveniently deallocate the entries in the
       partial_symbol lists (global_psymbols/static_psymbols) that
       this psymtab points to.  These just take up space until all
       the psymtabs are reclaimed.  Ditto the dependencies list and
       filename, which are all in the psymbol_obstack.  */

    /* We need to cashier any psymtab that has this one as a dependency... */
again:
    for (ps = pst->objfile->psymtabs; ps; ps = ps->next) {
      for (i = 0; i < ps->number_of_dependencies; i++) {
	if (ps->dependencies[i] == pst) {
	  cashier_psymtab (ps);
	  goto again;		/* Must restart, chain has been munged. */
a2246 1
      }
a2247 1
  }
d2294 7
a2300 4
  for (ps = partial_symtab_list; ps; ps = ps->next) {
    if (STREQ (name, ps->filename)) {
      cashier_psymtab (ps);	/* Blow it away...and its little dog, too.  */
      goto again2;		/* Must restart, chain has been munged */
a2301 1
  }
d2320 2
a2321 2
	 or not they depend on the symtab being freed.  This should be
	 changed so that only those data structures affected are deleted.  */
d2324 4
a2327 4
	 This test is necessary due to a bug in "dbxread.c" that
	 causes empty symtabs to be created for N_SO symbols that
	 contain the pathname of the object file.  (This problem
	 has been fixed in GDB 3.9x).  */
d2339 3
a2341 1
	} else {
d2350 5
a2354 5
	 even though no symtab was found, since the file might have
	 been compiled without debugging, and hence not be associated
	 with a symtab.  In order to handle this correctly, we would need
	 to keep a list of text address ranges for undebuggable files.
	 For now, we do nothing, since this is a fairly obscure case.  */
d2368 1
a2368 4
   SYMFILE_NAME is the name of the symbol-file we are reading from, and ADDR
   is the address relative to which its symbols are (incremental) or 0
   (normal). */

d2383 5
a2387 5
  psymtab -> section_offsets = section_offsets;
  psymtab -> textlow = textlow;
  psymtab -> texthigh = psymtab -> textlow;  /* default */
  psymtab -> globals_offset = global_syms - objfile -> global_psymbols.list;
  psymtab -> statics_offset = static_syms - objfile -> static_psymbols.list;
d2402 2
a2403 2
     long val;					/* Value as a long */
     CORE_ADDR coreaddr;			/* Value as a CORE_ADDR */
d2451 1
a2451 1
                                   namespace, class, list, val, coreaddr, language, objfile)
d2459 2
a2460 2
     long val;					/* Value as a long */
     CORE_ADDR coreaddr;			/* Value as a CORE_ADDR */
d2480 1
a2480 1
  
d2483 9
a2491 9
      case language_c:
      case language_cplus:
        SYMBOL_CPLUS_DEMANGLED_NAME (&psymbol) =
          bcache (buf, dem_namelength + 1, &objfile->psymbol_cache);
        break;
      case language_chill:
        SYMBOL_CHILL_DEMANGLED_NAME (&psymbol) = 
          bcache (buf, dem_namelength + 1, &objfile->psymbol_cache);
        
d2530 2
a2531 2
  
  if (objfile -> global_psymbols.list)
d2533 1
a2533 1
      mfree (objfile -> md, (PTR)objfile -> global_psymbols.list);
d2535 1
a2535 1
  if (objfile -> static_psymbols.list)
d2537 1
a2537 1
      mfree (objfile -> md, (PTR)objfile -> static_psymbols.list);
d2539 1
a2539 1
  
a2542 3
  
  objfile -> global_psymbols.size = total_symbols / 10;
  objfile -> static_psymbols.size = total_symbols / 10;
d2544 4
a2547 1
  if (objfile -> global_psymbols.size > 0)
d2549 11
a2559 11
      objfile -> global_psymbols.next =
	objfile -> global_psymbols.list = (struct partial_symbol **)
	xmmalloc (objfile -> md, (objfile -> global_psymbols.size
				  * sizeof (struct partial_symbol *)));
    }
  if (objfile -> static_psymbols.size > 0)
    {
      objfile -> static_psymbols.next =
	objfile -> static_psymbols.list = (struct partial_symbol **)
	xmmalloc (objfile -> md, (objfile -> static_psymbols.size
				  * sizeof (struct partial_symbol *)));
d2568 1
a2568 1
      same VMA, each with its own unique LMA (or load address).
d2570 1
a2570 1
      sections, one by one, from the load address into the VMA address.
d2572 4
a2575 4
      sections should be considered to be mapped from the VMA to the LMA.
      This information is used for symbol lookup, and memory read/write.
      For instance, if a section has been mapped then its contents 
      should be read from the VMA, otherwise from the LMA.
d2589 20
a2608 20
     User commands:
       overlay map <name>	-- tell gdb to consider this section mapped
       overlay unmap <name>	-- tell gdb to consider this section unmapped
       overlay list		-- list the sections that GDB thinks are mapped
       overlay read-target	-- get the target's state of what's mapped
       overlay off/manual/auto -- set overlay debugging state
     Functional interface:
       find_pc_mapped_section(pc):    if the pc is in the range of a mapped
				      section, return that section.
       find_pc_overlay(pc):	      find any overlay section that contains 
				      the pc, either in its VMA or its LMA
       overlay_is_mapped(sect):       true if overlay is marked as mapped
       section_is_overlay(sect):      true if section's VMA != LMA
       pc_in_mapped_range(pc,sec):    true if pc belongs to section's VMA
       pc_in_unmapped_range(...):     true if pc belongs to section's LMA
       overlay_mapped_address(...):   map an address from section's LMA to VMA
       overlay_unmapped_address(...): map an address from section's VMA to LMA
       symbol_overlayed_address(...): Return a "current" address for symbol:
				      either in VMA or LMA depending on whether
				      the symbol's section is currently mapped
d2618 2
a2619 2
void (*target_overlay_update) PARAMS ((struct obj_section *)) 
     = simple_overlay_update;
d2643 1
a2643 1
  struct objfile     *objfile;
d2648 1
a2648 1
      sect->ovly_mapped = -1;
d2661 1
a2661 1
static int 
d2668 1
a2668 1
  switch (overlay_debugging) 
d2671 2
a2672 1
    case 0:	return 0;	/* overlay debugging off */
d2675 1
a2675 1
	 there's really nothing useful to do here (can't really go auto)  */
d2699 1
a2699 1
  struct objfile     *objfile;
d2706 1
a2706 1
	  return overlay_is_mapped (osect);
d2790 1
a2790 1
CORE_ADDR 
d2825 1
a2825 1
  struct objfile     *objfile;
d2831 11
a2841 11
	{
	  if (pc_in_mapped_range (pc, osect->the_bfd_section))
	    {
	      if (overlay_is_mapped (osect))
		return osect->the_bfd_section;
	      else
		best_match = osect;
	    }
	  else if (pc_in_unmapped_range (pc, osect->the_bfd_section))
	    best_match = osect;
	}
d2853 1
a2853 1
  struct objfile     *objfile;
d2860 1
a2860 1
	return osect->the_bfd_section;
d2873 2
a2874 2
  int                nmapped = 0;
  struct objfile     *objfile;
d2880 19
a2898 19
	{
	  const char *name;
	  bfd_vma     lma, vma;
	  int         size;

	  vma  = bfd_section_vma (objfile->obfd, osect->the_bfd_section);
	  lma  = bfd_section_lma (objfile->obfd, osect->the_bfd_section);
	  size = bfd_get_section_size_before_reloc (osect->the_bfd_section);
	  name = bfd_section_name (objfile->obfd, osect->the_bfd_section);

	  printf_filtered ("Section %s, loaded at ", name);
	  print_address_numeric (lma, 1, gdb_stdout);
	  puts_filtered (" - ");
	  print_address_numeric (lma + size, 1, gdb_stdout);
	  printf_filtered (", mapped at ");
	  print_address_numeric (vma, 1, gdb_stdout);
	  puts_filtered (" - ");
	  print_address_numeric (vma + size, 1, gdb_stdout);
	  puts_filtered ("\n");
d2900 2
a2901 2
	  nmapped ++;
	}
d2912 1
a2912 1
     int   from_tty;
d2914 3
a2916 3
  struct objfile     *objfile, *objfile2;
  struct obj_section *sec,     *sec2;
  asection           *bfdsec;
d2927 26
a2952 26
      { 
	/* Now, check to see if the section is an overlay. */
	bfdsec = sec->the_bfd_section;
	if (!section_is_overlay (bfdsec))
	  continue;		/* not an overlay section */

	/* Mark the overlay as "mapped" */
	sec->ovly_mapped = 1;

	/* Next, make a pass and unmap any sections that are
	   overlapped by this new section: */
	ALL_OBJSECTIONS (objfile2, sec2)
	  if (sec2->ovly_mapped &&
	      sec != sec2 &&
	      sec->the_bfd_section != sec2->the_bfd_section &&
	      (pc_in_mapped_range (sec2->addr,    sec->the_bfd_section) ||
	       pc_in_mapped_range (sec2->endaddr, sec->the_bfd_section)))
	    {
	      if (info_verbose)
		printf_filtered ("Note: section %s unmapped by overlap\n",
				 bfd_section_name (objfile->obfd, 
						   sec2->the_bfd_section));
	      sec2->ovly_mapped = 0;	/* sec2 overlaps sec: unmap sec2 */
	    }
	return;
      }
d2963 1
a2963 1
     int   from_tty;
d2965 1
a2965 1
  struct objfile     *objfile;
d2977 6
a2982 6
      {
	if (!sec->ovly_mapped)
	  error ("Section %s is not mapped", args);
	sec->ovly_mapped = 0;
	return;
      }
d2993 1
a2993 1
     int   from_tty;
d3007 1
a3007 1
     int   from_tty;
d3021 1
a3021 1
     int   from_tty;
d3023 1
a3023 1
  overlay_debugging = 0; 
d3031 1
a3031 1
     int   from_tty;
d3050 1
a3050 1
  printf_unfiltered 
d3070 10
a3079 10
   	unsigned _novlys;		/# number of overlay sections #/
	unsigned _ovly_table[_novlys][4] = {
	  {VMA, SIZE, LMA, MAPPED},	/# one entry per overlay section #/
	  {..., ...,  ..., ...},
	}
	unsigned _novly_regions;	/# number of overlay regions #/
	unsigned _ovly_region_table[_novly_regions][3] = {
	  {VMA, SIZE, MAPPED_TO_LMA},	/# one entry per overlay region #/
	  {..., ...,  ...},
	}
d3091 1
a3091 1
static unsigned  (*cache_ovly_table)[4] = 0;
d3093 1
a3093 1
static unsigned  (*cache_ovly_region_table)[3] = 0;
d3095 1
a3095 1
static unsigned  cache_novlys = 0;
d3097 1
a3097 1
static unsigned  cache_novly_regions = 0;
d3103 4
a3106 1
enum   ovly_index { VMA, SIZE, LMA, MAPPED};
d3114 2
a3115 2
    free(cache_ovly_table);
  cache_novlys     = 0;
d3126 2
a3127 2
    free(cache_ovly_region_table);
  cache_novly_regions     = 0;
d3137 1
a3137 1
     CORE_ADDR     memaddr;
d3139 1
a3139 1
     int           len;
d3142 1
a3142 1
  int           i;
d3146 1
a3146 1
    myaddr[i] = extract_unsigned_integer (TARGET_LONG_BYTES * i + buf, 
d3152 1
a3152 1
static int 
d3161 3
a3163 3
  else 
    return 0;	/* failure */
  cache_ovly_table = (void *) xmalloc (cache_novlys * sizeof(*cache_ovly_table));
d3170 2
a3171 2
	  read_target_long_array (cache_ovly_table_base, 
				  (int *) cache_ovly_table, 
d3174 2
a3175 2
      else 
	return 0;	/* failure */
d3177 3
a3179 3
  else 
    return 0;	/* failure */
  return 1;	/* SUCCESS */
d3185 1
a3185 1
static int 
d3194 2
a3195 2
  else 
    return 0;	/* failure */
d3203 2
a3204 2
	  read_target_long_array (cache_ovly_region_table_base, 
				  (int *) cache_ovly_region_table, 
d3207 2
a3208 2
      else 
	return 0;	/* failure */
d3210 3
a3212 3
  else 
    return 0;	/* failure */
  return 1;	/* SUCCESS */
d3232 3
a3234 3
    if (cache_ovly_table[i][VMA]  == osect->the_bfd_section->vma &&
	cache_ovly_table[i][LMA]  == osect->the_bfd_section->lma /* &&
	cache_ovly_table[i][SIZE] == size */)
d3238 3
a3240 3
	if (cache_ovly_table[i][VMA]  == osect->the_bfd_section->vma &&
	    cache_ovly_table[i][LMA]  == osect->the_bfd_section->lma /* &&
	    cache_ovly_table[i][SIZE] == size */)
d3245 1
a3245 1
	else	/* Warning!  Warning!  Target's ovly table has changed! */
d3263 1
a3263 1
  struct objfile        *objfile;
d3270 1
a3270 1
      if (cache_ovly_table_base == 
d3289 2
a3290 2
      {
	int i, size;
d3292 10
a3301 10
	size = bfd_get_section_size_before_reloc (osect->the_bfd_section);
	for (i = 0; i < cache_novlys; i++)
	  if (cache_ovly_table[i][VMA]  == osect->the_bfd_section->vma &&
	      cache_ovly_table[i][LMA]  == osect->the_bfd_section->lma /* &&
	      cache_ovly_table[i][SIZE] == size */)
	    { /* obj_section matches i'th entry in ovly_table */
	      osect->ovly_mapped = cache_ovly_table[i][MAPPED];
	      break;	/* finished with inner for loop: break out */
	    }
      }
d3309 1
a3309 1
  
d3311 1
a3311 1
   "Load symbol table from executable file FILE.\n\
d3317 2
a3318 1
   "Usage: add-symbol-file FILE ADDR\n\
d3320 4
a3323 1
ADDR is the starting address of the file's text.",
d3330 1
a3330 1
   	       &cmdlist);
d3335 1
a3335 1
   "Dynamically load FILE into the running program, and record its symbols\n\
d3341 2
a3342 2
		  (char *)&symbol_reloading,
	  "Set dynamic symbol table reloading multiple times in one run.",
d3346 2
a3347 2
  add_prefix_cmd ("overlay", class_support, overlay_command, 
		  "Commands for debugging overlays.", &overlaylist, 
d3353 1
a3353 1
  add_cmd ("map-overlay", class_support, map_overlay_command, 
d3356 1
a3356 1
  add_cmd ("unmap-overlay", class_support, unmap_overlay_command, 
d3359 1
a3359 1
  add_cmd ("list-overlays", class_support, list_overlays_command, 
d3362 1
a3362 1
  add_cmd ("manual", class_support, overlay_manual_command, 
d3364 1
a3364 1
  add_cmd ("off", class_support, overlay_off_command, 
d3366 1
a3366 1
  add_cmd ("auto", class_support, overlay_auto_command, 
d3368 1
a3368 1
  add_cmd ("load-target", class_support, overlay_load_command, 
d3374 1
a3374 1
		   (char *) &ext_args, 
d3377 1
a3377 1
		     &setlist);
d3380 1
a3380 1
  add_info ("extensions", info_ext_lang_command, 
d3382 12
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d842 1
a842 1
      cleanups = make_cleanup_freeargv (argv);
@


1.1.1.3
log
@import gdb-1999-05-25 snapshot
@
text
@a144 8
static void add_filename_language PARAMS ((char *ext, enum language lang));

static void set_ext_lang_command PARAMS ((char *args, int from_tty));

static void info_ext_lang_command PARAMS ((char *args, int from_tty));

static void init_filename_language_table PARAMS ((void));

@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d6 1
a6 1
   This file is part of GDB.
d8 13
a20 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d36 1
a36 1
#include "inferior.h"		/* for write_pc */
d73 1
a73 1
int readnow_symbol_files;	/* Read full symbols immediately */
d75 1
a75 2
struct complaint oldsyms_complaint =
{
d79 1
a79 2
struct complaint empty_symtab_complaint =
{
d188 1
a188 1
 */
d191 1
a192 1

d212 1
a212 1
   LOCAL FUNCTION
d214 1
a214 1
   compare_psymbols -- compare two partial symbols by name
d216 1
a216 1
   DESCRIPTION
d218 3
a220 3
   Given pointers to pointers to two partial symbol table entries,
   compare them by name and return -N, 0, or +N (ala strcmp).
   Typically used by sorting routines like qsort().
d222 1
a222 1
   NOTES
d224 5
a228 5
   Does direct compare of first two characters before punting
   and passing to strcmp for longer compares.  Note that the
   original version had a bug whereby two null strings or two
   identically named one character strings would return the
   comparison of memory following the null byte.
d262 1
a262 1
      return (strcmp (st1, st2));
d272 2
a273 2
  qsort (pst->objfile->global_psymbols.list + pst->globals_offset,
	 pst->n_global_syms, sizeof (struct partial_symbol *),
d379 1
a379 1
    {
d398 1
a398 1
  if (bfd_get_file_flags (objfile->obfd) & EXEC_P)
d401 2
a402 2
         the startup file because it contains the entry point.  */
      objfile->ei.entry_point = bfd_get_start_address (objfile->obfd);
d407 1
a407 1
      objfile->ei.entry_point = INVALID_ENTRY_POINT;
d409 6
a414 6
  objfile->ei.entry_file_lowpc = INVALID_ENTRY_LOWPC;
  objfile->ei.entry_file_highpc = INVALID_ENTRY_HIGHPC;
  objfile->ei.entry_func_lowpc = INVALID_ENTRY_LOWPC;
  objfile->ei.entry_func_highpc = INVALID_ENTRY_HIGHPC;
  objfile->ei.main_func_lowpc = INVALID_ENTRY_LOWPC;
  objfile->ei.main_func_highpc = INVALID_ENTRY_HIGHPC;
d420 1
a420 1
entry_point_address ()
d440 1
a440 1
  asection **lowest = (asection **) obj;
d470 1
a470 1
    obstack_alloc (&objfile->psymbol_obstack, SIZEOF_SECTION_OFFSETS);
d474 1
a474 1

d509 1
a509 1
  if (mainline)
d512 1
a512 1
         will be cleaned up if an error occurs during symbol reading.  */
d524 3
a526 3
         If the user wants to get rid of them, they should do "symbol-file"
         without arguments first.  Not sure this is the best behavior
         (PR 2207).  */
d528 1
a528 1
      (*objfile->sf->sym_new_init) (objfile);
d538 1
a538 1
      addr = 0;			/* No offset from objfile addresses.  */
d545 1
a545 1
			       (PTR) & lowest_sect);
d556 1
a556 1
	      (unsigned long) bfd_section_vma (objfile->obfd, lowest_sect));
d566 1
a566 1
  (*objfile->sf->sym_init) (objfile);
d569 1
a569 1
  section_offsets = (*objfile->sf->sym_offsets) (objfile, addr);
d606 1
a606 1
  (*objfile->sf->sym_read) (objfile, section_offsets, mainline);
d626 1
a626 1
  objfile->flags |= OBJF_SYMS;
d643 1
a643 1

d697 2
a698 2
     int user_loaded;
     int is_solib;
d713 1
a713 1
    error ("Not confirmed.");
d720 1
a720 1
  if ((objfile->flags & OBJF_MAPPED) && (objfile->flags & OBJF_SYMS))
d723 3
a725 3
         initial symbol reading performed, so we can skip that part.  Notify
         the user that instead of reading the symbols, they have been mapped.
       */
d738 2
a739 2
         symbol table file which has not had initial symbol reading
         performed, or need to read an unmapped symbol table. */
d768 1
a768 1
      for (psymtab = objfile->psymtabs;
d770 1
a770 1
	   psymtab = psymtab->next)
d779 1
a779 1
	post_add_symbol_hook ();
d781 4
a784 4
	{
	  printf_filtered ("done.\n");
	  gdb_flush (gdb_stdout);
	}
d811 1
a811 1
  CORE_ADDR text_relocation = 0;	/* text_relocation */
d823 1
a823 1
		     symfile_objfile->name))
d830 1
a830 1
       */
d867 1
a867 1
	      char *p;
d869 1
a869 1
	      name = *argv;
d871 14
a884 16
	      /* this is for rombug remote only, to get the text relocation by
	         using link command */
	      p = strrchr (name, '/');
	      if (p != NULL)
		p++;
	      else
		p = name;

	      target_link (p, &text_relocation);

	      if (text_relocation == (CORE_ADDR) 0)
		return;
	      else if (text_relocation == (CORE_ADDR) - 1)
		{
		  symbol_file_add (name, from_tty, (CORE_ADDR) 0,
				   1, mapped, readnow, 1, 0);
d886 1
a886 1
		  RESET_HP_UX_GLOBALS ();
d888 3
a890 3
		}
	      else
		symbol_file_add (name, from_tty, (CORE_ADDR) text_relocation,
d894 1
a894 1
	         frameless.  */
d897 1
a897 1
	      set_initial_language ();
d906 1
a906 1
      TUIDO (((TuiOpaqueFuncPtr) tuiDisplayMainFunction));
d925 1
a925 1
  enum language lang = language_unknown;
d930 1
a930 1
      if (pst->filename != NULL)
d932 2
a933 2
	  lang = deduce_language_from_filename (pst->filename);
	}
d936 2
a937 2
	  /* Make C the default language */
	  lang = language_c;
d969 1
a969 1
		    0, &absolute_name);
d979 1
a979 1
  /* It'll be freed in free_objfile(). */
d994 2
a995 2
         on error it does not free all the storage associated with the
         bfd).  */
d1028 2
a1029 2
  enum bfd_flavour our_flavour = bfd_get_flavour (objfile->obfd);
  char *our_target = bfd_get_target (objfile->obfd);
d1034 1
a1034 1
    our_flavour = (enum bfd_flavour) -1;
d1038 1
a1038 1
    our_flavour = (enum bfd_flavour) -2;
d1040 1
a1040 1
  for (sf = symtab_fns; sf != NULL; sf = sf->next)
d1042 1
a1042 1
      if (our_flavour == sf->sym_flavour)
d1044 1
a1044 1
	  objfile->sf = sf;
d1049 1
a1049 1
	 bfd_get_target (objfile->obfd));
d1076 2
a1077 2
     char *filename;
     int from_tty;
d1084 6
a1089 6
  int n;
  unsigned long load_offset = 0;	/* offset to add to vma for each section */
  char buf[GENERIC_LOAD_CHUNK + 8];
#if VALIDATE_DOWNLOAD
  char verify_buffer[GENERIC_LOAD_CHUNK + 8];
#endif
d1092 2
a1093 2
  n = sscanf (filename, "%s 0x%lx", buf, &load_offset);
  if (n > 1)
d1109 1
a1109 1
  if (!bfd_check_format (loadfile_bfd, bfd_object))
d1114 1
a1114 1

d1117 1
a1117 1
  for (s = loadfile_bfd->sections; s; s = s->next)
d1119 43
a1161 43
      if (s->flags & SEC_LOAD)
	{
	  bfd_size_type size;

	  size = bfd_get_section_size_before_reloc (s);
	  if (size > 0)
	    {
	      char *buffer;
	      struct cleanup *old_chain;
	      bfd_vma lma;
	      unsigned long l = size;
	      int err;
	      char *sect;
	      unsigned long sent;
	      unsigned long len;

	      l = l > GENERIC_LOAD_CHUNK ? GENERIC_LOAD_CHUNK : l;

	      buffer = xmalloc (size);
	      old_chain = make_cleanup (free, buffer);

	      lma = s->lma;
	      lma += load_offset;

	      /* Is this really necessary?  I guess it gives the user something
	         to look at during a long download.  */
	      printf_filtered ("Loading section %s, size 0x%lx lma ",
			       bfd_get_section_name (loadfile_bfd, s),
			       (unsigned long) size);
	      print_address_numeric (lma, 1, gdb_stdout);
	      printf_filtered ("\n");

	      bfd_get_section_contents (loadfile_bfd, s, buffer, 0, size);

	      sect = (char *) bfd_get_section_name (loadfile_bfd, s);
	      sent = 0;
	      do
		{
		  len = (size - sent) < l ? (size - sent) : l;
		  sent += len;
		  err = target_write_memory (lma, buffer, len);
		  if (ui_load_progress_hook)
		    if (ui_load_progress_hook (sect, sent))
d1167 2
a1168 3
		   */
		  if (err)
		    break;
d1170 4
a1173 4
		    target_read_memory (lma, verify_buffer, len);
		    if (0 != bcmp (buffer, verify_buffer, len))
		      error ("Download verify failed at %08x",
			     (unsigned long) lma);
d1177 13
a1189 13
		  data_count += len;
		  lma += len;
		  buffer += len;
		}		/* od */
	      while (err == 0 && sent < size);

	      if (err != 0)
		error ("Memory access error while loading section %s.",
		       bfd_get_section_name (loadfile_bfd, s));

	      do_cleanups (old_chain);
	    }
	}
d1194 3
a1196 3
    unsigned long entry;
    entry = bfd_get_start_address (loadfile_bfd);
    printf_filtered ("Start address 0x%lx , load size %d\n", entry, data_count);
d1217 2
a1218 2
     unsigned long data_count;
     time_t start_time, end_time;
d1243 1
a1243 1

d1260 1
a1260 4
      while (isspace (*args))
	{
	  args++;
	}
d1262 1
a1262 4
      while ((*args != '\000') && !isspace (*args))
	{
	  args++;
	}
d1302 3
a1304 3
      target_link (name, &text_addr);
      if (text_addr == (CORE_ADDR) - 1)
	error ("Don't know how to get text start location for this file");
d1310 1
a1310 1
		  name, local_hex_string ((unsigned long) text_addr))))
d1314 2
a1315 2
		   1,		/* user_loaded */
		   0);		/* We'll guess it's ! is_solib */
d1323 1
a1323 1
add_shared_symbol_files_command (args, from_tty)
d1331 1
a1331 1
#endif
d1350 19
a1368 3
  for (objfile = object_files; objfile; objfile = objfile->next)
    {
      if (objfile->obfd)
d1370 47
a1416 3
#ifdef IBM6000_TARGET
	  /* If this object is from a shared library, then you should
	     stat on the library name, not member name. */
d1418 30
a1447 6
	  if (objfile->obfd->my_archive)
	    res = stat (objfile->obfd->my_archive->filename, &new_statbuf);
	  else
#endif
	    res = stat (objfile->name, &new_statbuf);
	  if (res != 0)
d1449 1
a1449 4
	      /* FIXME, should use print_sys_errmsg but it's not filtered. */
	      printf_filtered ("`%s' has disappeared; keeping its symbols.\n",
			       objfile->name);
	      continue;
d1451 14
a1464 2
	  new_modtime = new_statbuf.st_mtime;
	  if (new_modtime != objfile->mtime)
d1466 3
a1468 47
	      struct cleanup *old_cleanups;
	      struct section_offsets *offsets;
	      int num_offsets;
	      int section_offsets_size;
	      char *obfd_filename;

	      printf_filtered ("`%s' has changed; re-reading symbols.\n",
			       objfile->name);

	      /* There are various functions like symbol_file_add,
	         symfile_bfd_open, syms_from_objfile, etc., which might
	         appear to do what we want.  But they have various other
	         effects which we *don't* want.  So we just do stuff
	         ourselves.  We don't worry about mapped files (for one thing,
	         any mapped file will be out of date).  */

	      /* If we get an error, blow away this objfile (not sure if
	         that is the correct response for things like shared
	         libraries).  */
	      old_cleanups = make_cleanup ((make_cleanup_func) free_objfile,
					   objfile);
	      /* We need to do this whenever any symbols go away.  */
	      make_cleanup ((make_cleanup_func) clear_symtab_users, 0);

	      /* Clean up any state BFD has sitting around.  We don't need
	         to close the descriptor but BFD lacks a way of closing the
	         BFD without closing the descriptor.  */
	      obfd_filename = bfd_get_filename (objfile->obfd);
	      if (!bfd_close (objfile->obfd))
		error ("Can't close BFD for %s: %s", objfile->name,
		       bfd_errmsg (bfd_get_error ()));
	      objfile->obfd = bfd_openr (obfd_filename, gnutarget);
	      if (objfile->obfd == NULL)
		error ("Can't open %s to read symbols.", objfile->name);
	      /* bfd_openr sets cacheable to true, which is what we want.  */
	      if (!bfd_check_format (objfile->obfd, bfd_object))
		error ("Can't read symbols from %s: %s.", objfile->name,
		       bfd_errmsg (bfd_get_error ()));

	      /* Save the offsets, we will nuke them with the rest of the
	         psymbol_obstack.  */
	      num_offsets = objfile->num_sections;
	      section_offsets_size =
		sizeof (struct section_offsets)
	      + sizeof (objfile->section_offsets->offsets) * num_offsets;
	      offsets = (struct section_offsets *) alloca (section_offsets_size);
	      memcpy (offsets, objfile->section_offsets, section_offsets_size);
d1470 13
a1482 65
	      /* Nuke all the state that we will re-read.  Much of the following
	         code which sets things to NULL really is necessary to tell
	         other parts of GDB that there is nothing currently there.  */

	      /* FIXME: Do we have to free a whole linked list, or is this
	         enough?  */
	      if (objfile->global_psymbols.list)
		mfree (objfile->md, objfile->global_psymbols.list);
	      memset (&objfile->global_psymbols, 0,
		      sizeof (objfile->global_psymbols));
	      if (objfile->static_psymbols.list)
		mfree (objfile->md, objfile->static_psymbols.list);
	      memset (&objfile->static_psymbols, 0,
		      sizeof (objfile->static_psymbols));

	      /* Free the obstacks for non-reusable objfiles */
	      obstack_free (&objfile->psymbol_cache.cache, 0);
	      memset (&objfile->psymbol_cache, 0,
		      sizeof (objfile->psymbol_cache));
	      obstack_free (&objfile->psymbol_obstack, 0);
	      obstack_free (&objfile->symbol_obstack, 0);
	      obstack_free (&objfile->type_obstack, 0);
	      objfile->sections = NULL;
	      objfile->symtabs = NULL;
	      objfile->psymtabs = NULL;
	      objfile->free_psymtabs = NULL;
	      objfile->msymbols = NULL;
	      objfile->minimal_symbol_count = 0;
	      objfile->fundamental_types = NULL;
	      if (objfile->sf != NULL)
		{
		  (*objfile->sf->sym_finish) (objfile);
		}

	      /* We never make this a mapped file.  */
	      objfile->md = NULL;
	      /* obstack_specify_allocation also initializes the obstack so
	         it is empty.  */
	      obstack_specify_allocation (&objfile->psymbol_cache.cache, 0, 0,
					  xmalloc, free);
	      obstack_specify_allocation (&objfile->psymbol_obstack, 0, 0,
					  xmalloc, free);
	      obstack_specify_allocation (&objfile->symbol_obstack, 0, 0,
					  xmalloc, free);
	      obstack_specify_allocation (&objfile->type_obstack, 0, 0,
					  xmalloc, free);
	      if (build_objfile_section_table (objfile))
		{
		  error ("Can't find the file sections in `%s': %s",
			 objfile->name, bfd_errmsg (bfd_get_error ()));
		}

	      /* We use the same section offsets as from last time.  I'm not
	         sure whether that is always correct for shared libraries.  */
	      objfile->section_offsets = (struct section_offsets *)
		obstack_alloc (&objfile->psymbol_obstack, section_offsets_size);
	      memcpy (objfile->section_offsets, offsets, section_offsets_size);
	      objfile->num_sections = num_offsets;

	      /* What the hell is sym_new_init for, anyway?  The concept of
	         distinguishing between the main file and additional files
	         in this way seems rather dubious.  */
	      if (objfile == symfile_objfile)
		{
		  (*objfile->sf->sym_new_init) (objfile);
d1484 1
a1484 1
		  RESET_HP_UX_GLOBALS ();
d1486 15
a1500 1
		}
d1502 2
a1503 13
	      (*objfile->sf->sym_init) (objfile);
	      clear_complaints (1, 1);
	      /* The "mainline" parameter is a hideous hack; I think leaving it
	         zero is OK since dbxread.c also does what it needs to do if
	         objfile->global_psymbols.size is 0.  */
	      (*objfile->sf->sym_read) (objfile, objfile->section_offsets, 0);
	      if (!have_partial_symbols () && !have_full_symbols ())
		{
		  wrap_here ("");
		  printf_filtered ("(no debugging symbols found)\n");
		  wrap_here ("");
		}
	      objfile->flags |= OBJF_SYMS;
d1505 2
a1506 2
	      /* We're done reading the symbol file; finish off complaints.  */
	      clear_complaints (0, 1);
d1508 1
a1508 2
	      /* Getting new symbols may change our opinion about what is
	         frameless.  */
d1510 2
a1511 1
	      reinit_frame_cache ();
d1513 5
a1517 2
	      /* Discard cleanups as symbol reading was successful.  */
	      discard_cleanups (old_cleanups);
d1519 4
a1522 10
	      /* If the mtime has changed between the time we set new_modtime
	         and now, we *want* this to be out of date, so don't call stat
	         again now.  */
	      objfile->mtime = new_modtime;
	      reread_one = 1;

	      /* Call this after reading in a new symbol table to give target
	         dependant code a crack at the new symbols.  For instance, this
	         could be used to update the values of target-specific symbols GDB
	         needs to keep track of (such as _sigtramp, or whatever).  */
d1524 1
a1524 2
	      TARGET_SYMFILE_POSTREAD (objfile);
	    }
d1527 1
d1532 1
d1535 2
a1536 4

typedef struct
{
  char *ext;
d1538 1
a1538 2
}
filename_language;
d1540 1
a1540 1
static filename_language *filename_language_table;
d1545 1
a1545 1
     char *ext;
d1551 1
a1551 1
      filename_language_table = realloc (filename_language_table,
d1555 1
a1555 1
  filename_language_table[fl_table_next].ext = strsave (ext);
d1576 1
a1576 1
  while (*cp && !isspace (*cp))
d1584 1
a1584 1
  *cp++ = '\0';
d1616 1
a1616 1
      filename_language_table[i].ext = strsave (ext_args);
d1624 1
a1624 1
     int from_tty;
d1631 2
a1632 2
    printf_filtered ("\t%s\t- %s\n",
		     filename_language_table[i].ext,
d1643 1
a1643 1
      filename_language_table =
d1645 8
a1652 8
      add_filename_language (".c", language_c);
      add_filename_language (".C", language_cplus);
      add_filename_language (".cc", language_cplus);
      add_filename_language (".cp", language_cplus);
      add_filename_language (".cpp", language_cplus);
      add_filename_language (".cxx", language_cplus);
      add_filename_language (".c++", language_cplus);
      add_filename_language (".java", language_java);
d1654 7
a1660 7
      add_filename_language (".ch", language_chill);
      add_filename_language (".c186", language_chill);
      add_filename_language (".c286", language_chill);
      add_filename_language (".f", language_fortran);
      add_filename_language (".F", language_fortran);
      add_filename_language (".s", language_asm);
      add_filename_language (".S", language_asm);
d1686 6
a1691 6
   LINETABLE(symtab)
   symtab->blockvector
   symtab->dirname
   symtab->free_code
   symtab->free_ptr
   possibly free_named_symtabs (symtab->filename);
d1702 1
a1702 1
    obstack_alloc (&objfile->symbol_obstack, sizeof (struct symtab));
d1704 6
a1709 6
  symtab->filename = obsavestring (filename, strlen (filename),
				   &objfile->symbol_obstack);
  symtab->fullname = NULL;
  symtab->language = deduce_language_from_filename (filename);
  symtab->debugformat = obsavestring ("unknown", 7,
				      &objfile->symbol_obstack);
d1713 3
a1715 3
  symtab->objfile = objfile;
  symtab->next = objfile->symtabs;
  objfile->symtabs = symtab;
d1735 1
a1735 1
  if (objfile->free_psymtabs)
d1737 2
a1738 2
      psymtab = objfile->free_psymtabs;
      objfile->free_psymtabs = psymtab->next;
d1742 1
a1742 1
      obstack_alloc (&objfile->psymbol_obstack,
d1746 3
a1748 3
  psymtab->filename = obsavestring (filename, strlen (filename),
				    &objfile->psymbol_obstack);
  psymtab->symtab = NULL;
d1754 3
a1756 3
  psymtab->objfile = objfile;
  psymtab->next = objfile->psymtabs;
  objfile->psymtabs = psymtab;
d1760 3
a1762 3
    psymtab->objfile = objfile;
    psymtab->next = NULL;
    prev_pst = &(objfile->psymtabs);
d1764 1
a1764 1
      prev_pst = &((*prev_pst)->next);
d1766 1
a1766 1
  }
d1768 1
a1768 1

d1797 1
a1798 1

d1874 5
a1878 6
  for (ps = pst->objfile->psymtabs; ps; ps = ps->next)
    {
      if (ps == pst)
	break;
      pprev = ps;
    }
d1880 20
a1899 26
  if (ps)
    {
      /* Unhook it from the chain.  */
      if (ps == pst->objfile->psymtabs)
	pst->objfile->psymtabs = ps->next;
      else
	pprev->next = ps->next;

      /* FIXME, we can't conveniently deallocate the entries in the
         partial_symbol lists (global_psymbols/static_psymbols) that
         this psymtab points to.  These just take up space until all
         the psymtabs are reclaimed.  Ditto the dependencies list and
         filename, which are all in the psymbol_obstack.  */

      /* We need to cashier any psymtab that has this one as a dependency... */
    again:
      for (ps = pst->objfile->psymtabs; ps; ps = ps->next)
	{
	  for (i = 0; i < ps->number_of_dependencies; i++)
	    {
	      if (ps->dependencies[i] == pst)
		{
		  cashier_psymtab (ps);
		  goto again;	/* Must restart, chain has been munged. */
		}
	    }
d1901 1
d1903 1
d1950 4
a1953 7
  for (ps = partial_symtab_list; ps; ps = ps->next)
    {
      if (STREQ (name, ps->filename))
	{
	  cashier_psymtab (ps);	/* Blow it away...and its little dog, too.  */
	  goto again2;		/* Must restart, chain has been munged */
	}
d1955 1
d1974 2
a1975 2
         or not they depend on the symtab being freed.  This should be
         changed so that only those data structures affected are deleted.  */
d1978 4
a1981 4
         This test is necessary due to a bug in "dbxread.c" that
         causes empty symtabs to be created for N_SO symbols that
         contain the pathname of the object file.  (This problem
         has been fixed in GDB 3.9x).  */
d1993 1
a1993 3
	}
      else
	{
d2002 5
a2006 5
         even though no symtab was found, since the file might have
         been compiled without debugging, and hence not be associated
         with a symtab.  In order to handle this correctly, we would need
         to keep a list of text address ranges for undebuggable files.
         For now, we do nothing, since this is a fairly obscure case.  */
d2038 5
a2042 5
  psymtab->section_offsets = section_offsets;
  psymtab->textlow = textlow;
  psymtab->texthigh = psymtab->textlow;		/* default */
  psymtab->globals_offset = global_syms - objfile->global_psymbols.list;
  psymtab->statics_offset = static_syms - objfile->static_psymbols.list;
d2057 2
a2058 2
     long val;			/* Value as a long */
     CORE_ADDR coreaddr;	/* Value as a CORE_ADDR */
d2106 1
a2106 1
		   namespace, class, list, val, coreaddr, language, objfile)
d2114 2
a2115 2
     long val;			/* Value as a long */
     CORE_ADDR coreaddr;	/* Value as a CORE_ADDR */
d2135 1
a2135 1

d2138 9
a2146 9
    case language_c:
    case language_cplus:
      SYMBOL_CPLUS_DEMANGLED_NAME (&psymbol) =
	bcache (buf, dem_namelength + 1, &objfile->psymbol_cache);
      break;
    case language_chill:
      SYMBOL_CHILL_DEMANGLED_NAME (&psymbol) =
	bcache (buf, dem_namelength + 1, &objfile->psymbol_cache);

d2185 2
a2186 2

  if (objfile->global_psymbols.list)
d2188 1
a2188 1
      mfree (objfile->md, (PTR) objfile->global_psymbols.list);
d2190 1
a2190 1
  if (objfile->static_psymbols.list)
d2192 1
a2192 1
      mfree (objfile->md, (PTR) objfile->static_psymbols.list);
d2194 1
a2194 1

d2198 17
a2214 17

  objfile->global_psymbols.size = total_symbols / 10;
  objfile->static_psymbols.size = total_symbols / 10;

  if (objfile->global_psymbols.size > 0)
    {
      objfile->global_psymbols.next =
	objfile->global_psymbols.list = (struct partial_symbol **)
	xmmalloc (objfile->md, (objfile->global_psymbols.size
				* sizeof (struct partial_symbol *)));
    }
  if (objfile->static_psymbols.size > 0)
    {
      objfile->static_psymbols.next =
	objfile->static_psymbols.list = (struct partial_symbol **)
	xmmalloc (objfile->md, (objfile->static_psymbols.size
				* sizeof (struct partial_symbol *)));
d2223 1
a2223 1
   same VMA, each with its own unique LMA (or load address).
d2225 1
a2225 1
   sections, one by one, from the load address into the VMA address.
d2227 4
a2230 4
   sections should be considered to be mapped from the VMA to the LMA.
   This information is used for symbol lookup, and memory read/write.
   For instance, if a section has been mapped then its contents 
   should be read from the VMA, otherwise from the LMA.
d2244 20
a2263 20
   User commands:
   overlay map <name>   -- tell gdb to consider this section mapped
   overlay unmap <name> -- tell gdb to consider this section unmapped
   overlay list         -- list the sections that GDB thinks are mapped
   overlay read-target  -- get the target's state of what's mapped
   overlay off/manual/auto -- set overlay debugging state
   Functional interface:
   find_pc_mapped_section(pc):    if the pc is in the range of a mapped
   section, return that section.
   find_pc_overlay(pc):       find any overlay section that contains 
   the pc, either in its VMA or its LMA
   overlay_is_mapped(sect):       true if overlay is marked as mapped
   section_is_overlay(sect):      true if section's VMA != LMA
   pc_in_mapped_range(pc,sec):    true if pc belongs to section's VMA
   pc_in_unmapped_range(...):     true if pc belongs to section's LMA
   overlay_mapped_address(...):   map an address from section's LMA to VMA
   overlay_unmapped_address(...): map an address from section's VMA to LMA
   symbol_overlayed_address(...): Return a "current" address for symbol:
   either in VMA or LMA depending on whether
   the symbol's section is currently mapped
d2273 2
a2274 2
void (*target_overlay_update) PARAMS ((struct obj_section *))
= simple_overlay_update;
d2298 1
a2298 1
  struct objfile *objfile;
d2303 1
a2303 1
    sect->ovly_mapped = -1;
d2316 1
a2316 1
static int
d2323 1
a2323 1
  switch (overlay_debugging)
d2326 1
a2326 2
    case 0:
      return 0;			/* overlay debugging off */
d2329 1
a2329 1
         there's really nothing useful to do here (can't really go auto)  */
d2353 1
a2353 1
  struct objfile *objfile;
d2360 1
a2360 1
	return overlay_is_mapped (osect);
d2444 1
a2444 1
CORE_ADDR
d2479 1
a2479 1
  struct objfile *objfile;
d2485 11
a2495 11
      {
	if (pc_in_mapped_range (pc, osect->the_bfd_section))
	  {
	    if (overlay_is_mapped (osect))
	      return osect->the_bfd_section;
	    else
	      best_match = osect;
	  }
	else if (pc_in_unmapped_range (pc, osect->the_bfd_section))
	  best_match = osect;
      }
d2507 1
a2507 1
  struct objfile *objfile;
d2514 1
a2514 1
      return osect->the_bfd_section;
d2527 2
a2528 2
  int nmapped = 0;
  struct objfile *objfile;
d2534 19
a2552 4
      {
	const char *name;
	bfd_vma lma, vma;
	int size;
d2554 2
a2555 17
	vma = bfd_section_vma (objfile->obfd, osect->the_bfd_section);
	lma = bfd_section_lma (objfile->obfd, osect->the_bfd_section);
	size = bfd_get_section_size_before_reloc (osect->the_bfd_section);
	name = bfd_section_name (objfile->obfd, osect->the_bfd_section);

	printf_filtered ("Section %s, loaded at ", name);
	print_address_numeric (lma, 1, gdb_stdout);
	puts_filtered (" - ");
	print_address_numeric (lma + size, 1, gdb_stdout);
	printf_filtered (", mapped at ");
	print_address_numeric (vma, 1, gdb_stdout);
	puts_filtered (" - ");
	print_address_numeric (vma + size, 1, gdb_stdout);
	puts_filtered ("\n");

	nmapped++;
      }
d2566 1
a2566 1
     int from_tty;
d2568 3
a2570 3
  struct objfile *objfile, *objfile2;
  struct obj_section *sec, *sec2;
  asection *bfdsec;
d2581 26
a2606 26
    {
      /* Now, check to see if the section is an overlay. */
      bfdsec = sec->the_bfd_section;
      if (!section_is_overlay (bfdsec))
	continue;		/* not an overlay section */

      /* Mark the overlay as "mapped" */
      sec->ovly_mapped = 1;

      /* Next, make a pass and unmap any sections that are
         overlapped by this new section: */
      ALL_OBJSECTIONS (objfile2, sec2)
	if (sec2->ovly_mapped &&
	    sec != sec2 &&
	    sec->the_bfd_section != sec2->the_bfd_section &&
	    (pc_in_mapped_range (sec2->addr, sec->the_bfd_section) ||
	     pc_in_mapped_range (sec2->endaddr, sec->the_bfd_section)))
	{
	  if (info_verbose)
	    printf_filtered ("Note: section %s unmapped by overlap\n",
			     bfd_section_name (objfile->obfd,
					       sec2->the_bfd_section));
	  sec2->ovly_mapped = 0;	/* sec2 overlaps sec: unmap sec2 */
	}
      return;
    }
d2617 1
a2617 1
     int from_tty;
d2619 1
a2619 1
  struct objfile *objfile;
d2631 6
a2636 6
    {
      if (!sec->ovly_mapped)
	error ("Section %s is not mapped", args);
      sec->ovly_mapped = 0;
      return;
    }
d2647 1
a2647 1
     int from_tty;
d2661 1
a2661 1
     int from_tty;
d2675 1
a2675 1
     int from_tty;
d2677 1
a2677 1
  overlay_debugging = 0;
d2685 1
a2685 1
     int from_tty;
d2704 1
a2704 1
  printf_unfiltered
d2724 10
a2733 10
   unsigned _novlys;            /# number of overlay sections #/
   unsigned _ovly_table[_novlys][4] = {
   {VMA, SIZE, LMA, MAPPED},    /# one entry per overlay section #/
   {..., ...,  ..., ...},
   }
   unsigned _novly_regions;     /# number of overlay regions #/
   unsigned _ovly_region_table[_novly_regions][3] = {
   {VMA, SIZE, MAPPED_TO_LMA},  /# one entry per overlay region #/
   {..., ...,  ...},
   }
d2745 1
a2745 1
static unsigned (*cache_ovly_table)[4] = 0;
d2747 1
a2747 1
static unsigned (*cache_ovly_region_table)[3] = 0;
d2749 1
a2749 1
static unsigned cache_novlys = 0;
d2751 1
a2751 1
static unsigned cache_novly_regions = 0;
d2757 1
a2757 4
enum ovly_index
  {
    VMA, SIZE, LMA, MAPPED
  };
d2765 2
a2766 2
    free (cache_ovly_table);
  cache_novlys = 0;
d2777 2
a2778 2
    free (cache_ovly_region_table);
  cache_novly_regions = 0;
d2788 1
a2788 1
     CORE_ADDR memaddr;
d2790 1
a2790 1
     int len;
d2793 1
a2793 1
  int i;
d2797 1
a2797 1
    myaddr[i] = extract_unsigned_integer (TARGET_LONG_BYTES * i + buf,
d2803 1
a2803 1
static int
d2812 3
a2814 3
  else
    return 0;			/* failure */
  cache_ovly_table = (void *) xmalloc (cache_novlys * sizeof (*cache_ovly_table));
d2821 2
a2822 2
	  read_target_long_array (cache_ovly_table_base,
				  (int *) cache_ovly_table,
d2825 2
a2826 2
      else
	return 0;		/* failure */
d2828 3
a2830 3
  else
    return 0;			/* failure */
  return 1;			/* SUCCESS */
d2836 1
a2836 1
static int
d2845 2
a2846 2
  else
    return 0;			/* failure */
d2854 2
a2855 2
	  read_target_long_array (cache_ovly_region_table_base,
				  (int *) cache_ovly_region_table,
d2858 2
a2859 2
      else
	return 0;		/* failure */
d2861 3
a2863 3
  else
    return 0;			/* failure */
  return 1;			/* SUCCESS */
d2883 3
a2885 3
    if (cache_ovly_table[i][VMA] == osect->the_bfd_section->vma &&
	cache_ovly_table[i][LMA] == osect->the_bfd_section->lma		/* &&
									   cache_ovly_table[i][SIZE] == size */ )
d2889 3
a2891 3
	if (cache_ovly_table[i][VMA] == osect->the_bfd_section->vma &&
	    cache_ovly_table[i][LMA] == osect->the_bfd_section->lma	/* &&
									   cache_ovly_table[i][SIZE] == size */ )
d2896 1
a2896 1
	else			/* Warning!  Warning!  Target's ovly table has changed! */
d2914 1
a2914 1
  struct objfile *objfile;
d2921 1
a2921 1
      if (cache_ovly_table_base ==
d2940 2
a2941 2
    {
      int i, size;
d2943 10
a2952 10
      size = bfd_get_section_size_before_reloc (osect->the_bfd_section);
      for (i = 0; i < cache_novlys; i++)
	if (cache_ovly_table[i][VMA] == osect->the_bfd_section->vma &&
	    cache_ovly_table[i][LMA] == osect->the_bfd_section->lma	/* &&
									   cache_ovly_table[i][SIZE] == size */ )
	  {			/* obj_section matches i'th entry in ovly_table */
	    osect->ovly_mapped = cache_ovly_table[i][MAPPED];
	    break;		/* finished with inner for loop: break out */
	  }
    }
d2960 1
a2960 1

d2962 1
a2962 1
	       "Load symbol table from executable file FILE.\n\
d2968 1
a2968 1
	       "Usage: add-symbol-file FILE ADDR\n\
d2977 1
a2977 1
	       &cmdlist);
d2982 1
a2982 1
	       "Dynamically load FILE into the running program, and record its symbols\n\
d2988 2
a2989 2
		  (char *) &symbol_reloading,
	    "Set dynamic symbol table reloading multiple times in one run.",
d2993 2
a2994 2
  add_prefix_cmd ("overlay", class_support, overlay_command,
		  "Commands for debugging overlays.", &overlaylist,
d3000 1
a3000 1
  add_cmd ("map-overlay", class_support, map_overlay_command,
d3003 1
a3003 1
  add_cmd ("unmap-overlay", class_support, unmap_overlay_command,
d3006 1
a3006 1
  add_cmd ("list-overlays", class_support, list_overlays_command,
d3009 1
a3009 1
  add_cmd ("manual", class_support, overlay_manual_command,
d3011 1
a3011 1
  add_cmd ("off", class_support, overlay_off_command,
d3013 1
a3013 1
  add_cmd ("auto", class_support, overlay_auto_command,
d3015 1
a3015 1
  add_cmd ("load-target", class_support, overlay_load_command,
d3021 1
a3021 1
		   (char *) &ext_args,
d3024 1
a3024 1
		   &setlist);
d3027 1
a3027 1
  add_info ("extensions", info_ext_lang_command,
@


1.1.1.5
log
@import gdb-1999-07-26 snapshot
@
text
@a473 1
  memset (section_offsets, 0, SIZEOF_SECTION_OFFSETS);
@


1.1.1.6
log
@import gdb-1999-08-02 snapshot
@
text
@d887 1
a887 1
	      else if (text_relocation == (CORE_ADDR) -1)
d1316 1
a1316 1
      if (text_addr == (CORE_ADDR) -1)
@


1.1.1.7
log
@import gdb-1999-08-09 snapshot
@
text
@d486 8
a493 10
   OBJFILE is where the symbols are to be read from.

   ADDR is the address where the text segment was loaded, unless the
   objfile is the main symbol file, in which case it is zero.

   MAINLINE is nonzero if this is the main symbol file, or zero if
   it's an extra symbol file such as dynamically loaded code.

   VERBO is nonzero if the caller has printed a verbose message about
   the symbol reading (and complaints can be more terse about it).  */
d549 1
a549 1
			       (PTR) &lowest_sect);
d560 1
a560 1
		 (unsigned long) bfd_section_vma (objfile->obfd, lowest_sect));
d590 1
a590 1
     has a different algorithm for finding section offsets.
d599 1
a599 1
      ALL_OBJFILE_OSECTIONS (objfile, s)
d610 1
a610 1
  (*objfile->sf->sym_read) (objfile, mainline);
d636 4
a639 4
  /* Call this after reading in a new symbol table to give target
     dependant code a crack at the new symbols.  For instance, this
     could be used to update the values of target-specific symbols GDB
     needs to keep track of (such as _sigtramp, or whatever).  */
d1509 1
a1509 1
	      (*objfile->sf->sym_read) (objfile, 0);
@


1.1.1.8
log
@import gdb-1999-08-23 snapshot
@
text
@d539 2
a540 1
     and assume that <addr> is where that got loaded.
a541 2
     We no longer warn if the lowest section is not a text segment (as
     happens for the PA64 port.  */
d556 7
@


1.1.1.9
log
@import gdb-1999-08-30 snapshot
@
text
@d48 3
@


1.1.1.10
log
@import gdb-1999-09-08 snapshot
@
text
@d460 1
a460 1
void
d465 1
d469 1
a469 1
  objfile->section_offsets = (struct section_offsets *)
d471 1
a471 1
  memset (objfile->section_offsets, 0, SIZEOF_SECTION_OFFSETS);
d474 3
a476 1
    ANOFFSET (objfile->section_offsets, i) = addr;
d566 2
a567 1
  (*objfile->sf->sym_offsets) (objfile, addr);
d1196 1
a1196 1
    printf_filtered ("Start address 0x%lx , load size %ld\n", entry, data_count);
d1222 1
a1222 1
    printf_filtered ("%ld bits/sec",
d1225 1
a1225 1
    printf_filtered ("%ld bits in <1 sec", (data_count * 8));
d1382 1
d1421 5
a1425 2
	      offsets = (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
	      memcpy (offsets, objfile->section_offsets, SIZEOF_SECTION_OFFSETS);
d1482 2
a1483 2
		obstack_alloc (&objfile->psymbol_obstack, SIZEOF_SECTION_OFFSETS);
	      memcpy (objfile->section_offsets, offsets, SIZEOF_SECTION_OFFSETS);
d2040 4
a2043 1
   FILENAME is the name of the symbol-file we are reading from. */
@


1.1.1.11
log
@import gdb-1999-10-04 snapshot
@
text
@a82 5
struct complaint unknown_option_complaint =
{
  "Unknown option `%s' ignored", 0, 0
};

d461 1
a461 1
default_symfile_offsets (objfile, addrs)
d463 1
a463 1
     struct section_addr_info *addrs;
d472 2
a473 28
  /* If user explicitly specified values for data and bss, set them here. */
  
  if (addrs->text_addr)
    ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT) = addrs->text_addr;
  if (addrs->data_addr)
    ANOFFSET (objfile->section_offsets, SECT_OFF_DATA) = addrs->data_addr;
  if (addrs->bss_addr)
    ANOFFSET (objfile->section_offsets, SECT_OFF_BSS)  = addrs->bss_addr;
    
  /* Now calculate offsets for other sections. */
  for (i = 0; i < MAX_SECTIONS && addrs->other[i].name; i++)
    {
      struct other_sections *osp ;

      osp = &addrs->other[i] ;
      if (addrs->other[i].addr == 0)
  	continue;
#if 0
      if (strcmp (".text", osp->name) == 0)
	SECT_OFF_TEXT = osp->sectindex ;
      else if (strcmp (".data", osp->name) == 0)
	SECT_OFF_DATA = osp->sectindex ;
      else if (strcmp (".bss", osp->name) == 0)
	SECT_OFF_BSS =  osp->sectindex ;
#endif
      /* Record all sections in offsets */
      ANOFFSET (objfile->section_offsets, osp->sectindex) = osp->addr;
    }
d492 1
a492 1
syms_from_objfile (objfile, addrs, mainline, verbo)
d494 1
a494 1
     struct section_addr_info *addrs;
d499 1
a499 4
  asection *lower_sect;
  asection *sect;
  CORE_ADDR lower_offset;
  struct section_addr_info local_addr;
a500 11
  int i;

  /* If ADDRS is NULL, initialize the local section_addr_info struct and
     point ADDRS to it.  We now establish the convention that an addr of
     zero means no load address was specified. */

  if (addrs == NULL)
    {
      memset (&local_addr, 0, sizeof (local_addr));
      addrs = &local_addr;
    }
d539 1
a539 4
      /* No offset from objfile addresses.  */
      addrs -> text_addr = 0;
      addrs -> data_addr = 0;
      addrs -> bss_addr = 0;
d543 2
a544 5
      /* Find lowest loadable section to be used as starting point for 
         continguous sections. FIXME!! won't work without call to find
	 .text first, but this assumes text is lowest section. */
      lower_sect = bfd_get_section_by_name (objfile->obfd, ".text");
      if (lower_sect == NULL)
d546 3
a548 2
			       (PTR) &lower_sect);
      if (lower_sect == NULL)
d551 3
a553 84
      else if ((bfd_get_section_flags (objfile->obfd, lower_sect) & SEC_CODE)
	       == 0)
	warning ("Lowest section in %s is %s at %s",
		 objfile->name,
		 bfd_section_name (objfile->obfd, lower_sect),
		 paddr (bfd_section_vma (objfile->obfd, lower_sect)));
      if (lower_sect != NULL)
 	lower_offset = bfd_section_vma (objfile->obfd, lower_sect);
      else
 	lower_offset = 0;
 
       /* Calculate offsets for the loadable sections.
 	 FIXME! Sections must be in order of increasing loadable section
 	 so that contiguous sections can use the lower-offset!!!
 
          Adjust offsets if the segments are not contiguous.
          If the section is contiguous, its offset should be set to
 	 the offset of the highest loadable section lower than it
 	 (the loadable section directly below it in memory).
 	 this_offset = lower_offset = lower_addr - lower_orig_addr */

      /* FIXME: These sections will not need special treatment because ALL
	 sections are in the other sections table */
 
      if (addrs->text_addr != 0)
 	{
 	  sect = bfd_get_section_by_name (objfile->obfd, ".text");
 	  if (sect)
 	    {
 	      addrs->text_addr -= bfd_section_vma (objfile->obfd, sect);
 	      lower_offset = addrs->text_addr;
 	    }
 	}
      else 
 	/* ??? who's below me? */
	addrs->text_addr = lower_offset;
 
      if (addrs->data_addr != 0)
	{
	  sect = bfd_get_section_by_name (objfile->obfd, ".data");
	  if (sect)
 	    {
	      addrs->data_addr -= bfd_section_vma (objfile->obfd, sect);
 	      lower_offset = addrs->data_addr;
 	    }
	}
      else
	addrs->data_addr = lower_offset;
 
      if (addrs->bss_addr != 0)
	{
	  sect = bfd_get_section_by_name (objfile->obfd, ".bss");
	  if (sect)
 	    {
	      addrs->bss_addr -= bfd_section_vma (objfile->obfd, sect);
 	      lower_offset = addrs->bss_addr;
 	    }
	}
      else
	addrs->bss_addr = lower_offset;
  
       /* Now calculate offsets for other sections. */
      for (i=0 ; i < MAX_SECTIONS && addrs->other[i].name; i++)
	{
	 
 	  if (addrs->other[i].addr != 0)
 	    {
 	      sect=bfd_get_section_by_name(objfile->obfd, addrs->other[i].name);
 	      if (sect)
 		{
 		  addrs->other[i].addr -= bfd_section_vma (objfile->obfd, sect);
 		  lower_offset = addrs->other[i].addr;
		  addrs->other[i].sectindex = sect->index ;
 		}
 	      else
		{
		  warning ("section %s not found in %s", addrs->other[i].name, 
			   objfile->name);
		  addrs->other[i].addr = 0;
		}
 	    }
 	  else
 	    addrs->other[i].addr = lower_offset;
	}
d563 1
a563 1
  (*objfile->sf->sym_offsets) (objfile, addrs);
d584 1
a584 1
  if (addrs)
a587 5
 	/* Map section offsets in "addr" back to the object's 
 	   sections by comparing the section names with bfd's 
 	   section names.  Then adjust the section address by
 	   the offset. */ /* for gdb/13815 */
 
a589 14
	  CORE_ADDR s_addr = 0;
	  int i;

 	  if (strcmp (s->the_bfd_section->name, ".text") == 0)
 	    s_addr = addrs->text_addr;
 	  else if (strcmp (s->the_bfd_section->name, ".data") == 0)
 	    s_addr = addrs->data_addr;
 	  else if (strcmp (s->the_bfd_section->name, ".bss") == 0)
 	    s_addr = addrs->bss_addr;
 	  else 
 	    for (i = 0; !s_addr && addrs->other[i].name; i++)
 	      if (strcmp (s->the_bfd_section->name, addrs->other[i].name) == 0)
 	        s_addr = addrs->other[i].addr; /* end added for gdb/13815 */
 
d591 1
a591 1
	  s->addr += s_addr;
d593 2
a594 2
	  s->endaddr += s_addr;
	  s->offset += s_addr;
d683 1
a683 1
symbol_file_add (name, from_tty, addrs, mainline, flags, user_loaded, is_solib)
d686 1
a686 1
     struct section_addr_info *addrs;
d688 2
a689 1
     int flags;
d708 1
a708 1
  objfile = allocate_objfile (abfd, flags & OBJF_MAPPED, user_loaded, is_solib);
d744 1
a744 1
      syms_from_objfile (objfile, addrs, mainline, from_tty);
d752 1
a752 1
  if ((flags & OBJF_READNOW) || readnow_symbol_files)
d806 2
a807 1
  int flags = 0;
d848 1
a848 1
	      flags |= OBJF_MAPPED;
d852 1
a852 1
	      flags |= OBJF_READNOW;
d878 2
a879 2
		  symbol_file_add (name, from_tty, NULL,
				   1, flags, 1, 0);
d885 2
a886 7
		{
		  struct section_addr_info section_addrs;
		  memset (&section_addrs, 0, sizeof (section_addrs));
		  section_addrs.text_addr = (CORE_ADDR) text_relocation;
		  symbol_file_add (name, from_tty, &section_addrs,
				   0, flags, 1, 0);
		}
a1235 1
  int flags = 0;
d1237 2
a1238 12
  int expecting_option = 0;
  int option_index = 0;
  int argcnt = 0;
  int sec_num = 0;
  int i;
  struct
  {
    enum { OPT_SECTION } type;
    char *name;
    char *value;
  } opt[SECT_OFF_MAX];
  struct section_addr_info section_addrs;
a1251 3
  /* Ensure section_addrs is initialized */
  memset (&section_addrs, 0, sizeof (section_addrs));

d1254 1
a1254 1
  while (*args != '\000')
d1271 1
a1271 32
	  if (expecting_option)
	    {
 	      opt[option_index++].value = arg;
 	      expecting_option = 0;
 	    }
 	  else
 	    {
	      switch (argcnt)
		{
 		case 0:
 		  name = arg;
 		  break;
 		case 1: 
 		  opt[option_index].type = OPT_SECTION;
 		  opt[option_index].name = ".text";
 		  opt[option_index++].value = arg;
 		  break;
 		case 2: 
 		  opt[option_index].type = OPT_SECTION;
 		  opt[option_index].name = ".data";
 		  opt[option_index++].value = arg;
 		  break;
 		case 3: 
 		  opt[option_index].type = OPT_SECTION;
 		  opt[option_index].name = ".bss";
 		  opt[option_index++].value = arg;
 		  break;
 		default:
 		  warning ("Too many arguments entered; see \"help add-symbol-file\" for command syntax.");
		}
	      argcnt++;
 	    }
d1275 1
a1275 1
	  flags |= OBJF_MAPPED;
d1279 5
a1283 1
	  flags |= OBJF_READNOW;
a1284 17
      else if (STREQN (arg, "-T", 2))
 	{
 	  if (option_index >= SECT_OFF_MAX)
	    {
	      warning ("Number of options exceeds maximum allowed.");
	    }
 	  else
 	    {
 	      expecting_option = 1;
 	      opt[option_index].type = OPT_SECTION;
 	      opt[option_index].name = arg + 2;
 	    }
 	}
      else 
        {
	  error ("Unknown option `%s'", arg);
        }
d1287 4
d1298 1
a1298 1
  if (option_index > 0)
d1300 1
a1300 52
      /* Print the prompt for the query below.
	 We have to split this up into 3 print statements because
	 local_hex_string returns a local static string. */
 
      printf_filtered ("add symbol table from file \"%s\" at\n", name);
      for (i = 0; i < option_index; i++)
	{
	  switch (opt[i].type)
	    {
	    case OPT_SECTION:
	      {
                CORE_ADDR addr;
                char *val = opt[i].value;
                char *sec = opt[i].name;
 
                val = opt[i].value;
                if (val[0] == '0' && val[1] == 'x')
                  addr = strtoul (val+2, NULL, 16);
                else
                  addr = strtoul (val, NULL, 10);
 
                if (strcmp (sec, ".text") == 0)
                  section_addrs.text_addr = addr;
                else if (strcmp (sec, ".data") == 0)
                  section_addrs.data_addr = addr;
                else if (strcmp (sec, ".bss") == 0)
                  section_addrs.bss_addr = addr;
                /* Add the section to the others even if it is a
                   text data or bss section. This is redundent but
                   eventually, none will be given special treatment */
		{
		  section_addrs.other[sec_num].name = strdup (sec);
		  make_cleanup (free, section_addrs.other[sec_num].name);
		  section_addrs.other[sec_num++].addr = addr;
		  printf_filtered ("\t%s_addr = %s\n",
				   sec, 
				   local_hex_string ((unsigned long)addr));
		}
 
                /* The object's sections are initialized when a 
                   call is made to build_objfile_section_table (objfile).
                   This happens in reread_symbols. 
                   At this point, we don't know what file type this is,
                   so we can't determine what section names are valid.  */
              }
              break;
            default:
              complain (&unknown_option_complaint, opt[i].name);
	    }
	}
      /* Eventually, these hard coded names will be obsolete */
      /* All the addresses will be on the others section */
d1304 1
a1304 2
      CORE_ADDR text_addr;
      target_link (name, &text_addr);  
d1306 1
a1306 6
	error("Don't know how to get text start location for this file");
      section_addrs.text_addr = text_addr;
      section_addrs.data_addr = 0;
      section_addrs.bss_addr = 0;
      printf_filtered("add symbol table from file \"%s\" at text_addr = %s?\n",
		      name, local_hex_string ((unsigned long)text_addr));
d1308 5
a1312 1
  if (from_tty && (!query ("%s", "")))
d1315 1
a1315 1
  symbol_file_add (name, from_tty, &section_addrs, 0, flags,
d2981 1
a2981 2
	       "Usage: add-symbol-file FILE ADDR [DATA_ADDR [BSS_ADDR]]\n\
or:    add-symbol-file FILE -T<SECT> <SECT_ADDR> -T<SECT> <SECT_ADDR> ...\n\
d2983 1
a2983 4
ADDR is the starting address of the file's text.\n\
The optional arguments, DATA_ADDR and BSS_ADDR, should be specified\n\
if the data and bss segments are not contiguous with the text.\n\
For complicated cases, SECT is a section name to be loaded at SECT_ADDR.",
@


1.1.1.12
log
@import gdb-1999-10-11 snapshot
@
text
@d823 6
d833 1
a833 1
symbol_file_add (name, from_tty, addrs, mainline, flags)
d839 2
d857 1
a857 1
  objfile = allocate_objfile (abfd, flags);
d955 1
a955 1
  int flags = OBJF_USERLOADED;
d1026 2
a1027 1
		  symbol_file_add (name, from_tty, NULL, 1, flags);
d1037 2
a1038 1
		  symbol_file_add (name, from_tty, &section_addrs, 0, flags);
d1389 1
a1389 1
  int flags = OBJF_USERLOADED;
d1575 3
a1577 1
  symbol_file_add (name, from_tty, &section_addrs, 0, flags);
@


1.1.1.13
log
@import gdb-1999-10-18 snapshot
@
text
@d66 1
a66 1
int (*ui_load_progress_hook) (const char *section, unsigned long num);
d1210 2
a1211 4

static int download_write_size = 512;
static int validate_download = 0;

d1213 3
a1215 1
generic_load (char *args, int from_tty)
d1217 1
d1222 6
a1227 5
  unsigned long write_count = 0;	/* Number of writes needed. */
  unsigned long load_offset;	/* offset to add to vma for each section */
  char *filename;
  struct cleanup *old_cleanups;
  char *offptr;
d1229 4
a1232 14
  /* Parse the input argument - the user can specify a load offset as
     a second argument. */
  filename = xmalloc (strlen (args) + 1);
  old_cleanups = make_cleanup (free, filename);
  strcpy (filename, args);
  offptr = strchr (filename, ' ');
  if (offptr != NULL)
    {
      char *endptr;
      load_offset = strtoul (offptr, &endptr, 0);
      if (offptr == endptr)
	error ("Invalid download offset:%s\n", offptr);
      *offptr = '\0';
    }
a1235 1
  /* Open the file for loading. */
a1241 1

d1245 1
a1245 1
  make_cleanup ((make_cleanup_func) bfd_close, loadfile_bfd);
d1259 3
a1261 1
	  CORE_ADDR size = bfd_get_section_size_before_reloc (s);
d1266 2
a1267 2
	      CORE_ADDR lma = s->lma + load_offset;
	      CORE_ADDR block_size;
d1269 3
a1271 2
	      const char *sect_name = bfd_get_section_name (loadfile_bfd, s);
	      CORE_ADDR sent;
d1273 1
a1273 4
	      if (download_write_size > 0 && size > download_write_size)
		block_size = download_write_size;
	      else
		block_size = size;
d1278 3
d1283 5
a1287 3
	      fprintf_unfiltered (gdb_stdout,
				  "Loading section %s, size 0x%s lma 0x%s\n",
				  sect_name, paddr_nz (size), paddr_nz (lma));
d1291 1
d1295 11
a1305 6
		  CORE_ADDR len;
		  CORE_ADDR this_transfer = size - sent;
		  if (this_transfer >= block_size)
		    this_transfer = block_size;
		  len = target_write_memory_partial (lma, buffer,
						     this_transfer, &err);
d1308 8
a1315 20
		  if (validate_download)
		    {
		      /* Broken memories and broken monitors manifest
			 themselves here when bring new computers to
			 life.  This doubles already slow downloads.  */
		      /* NOTE: cagney/1999-10-18: A more efficient
                         implementation might add a verify_memory()
                         method to the target vector and then use
                         that.  remote.c could implement that method
                         using the ``qCRC'' packet.  */
		      char *check = xmalloc (len);
		      struct cleanup *verify_cleanups = make_cleanup (free, check);
		      if (target_read_memory (lma, check, len) != 0)
			error ("Download verify read failed at 0x%s",
			       paddr (lma));
		      if (memcmp (buffer, check, len) != 0)
			error ("Download verify compare failed at 0x%s",
			       paddr (lma));
		      do_cleanups (verify_cleanups);
 		    }
d1319 2
a1320 8
		  write_count += 1;
		  sent += len;
		  if (quit_flag
		      || (ui_load_progress_hook != NULL
			  && ui_load_progress_hook (sect_name, sent)))
		    error ("Canceled the download");
		}
	      while (sent < size);
d1323 2
a1324 1
		error ("Memory access error while loading section %s.", sect_name);
d1333 1
a1333 1
    CORE_ADDR entry;
d1335 1
a1335 3
    fprintf_unfiltered (gdb_stdout,
			"Start address 0x%s , load size %ld\n",
			paddr_nz (entry), data_count);
d1347 1
a1347 2
  print_transfer_performance (gdb_stdout, data_count, write_count,
			      end_time - start_time);
a1353 4
/* DEPRECATED: cagney/1999-10-18: report_transfer_performance is being
   replaced by print_transfer_performance (with a very different
   function signature). */

d1359 4
a1362 12
  print_transfer_performance (gdb_stdout, data_count, end_time - start_time, 0);
}

void
print_transfer_performance (struct gdb_file *stream,
			    unsigned long data_count,
			    unsigned long write_count,
			    unsigned long time_count)
{
  fprintf_unfiltered (stream, "Transfer rate: ");
  if (time_count > 0)
    fprintf_unfiltered (stream, "%ld bits/sec", (data_count * 8) / time_count);
d1364 2
a1365 4
    fprintf_unfiltered (stream, "%ld bits in <1 sec", (data_count * 8));
  if (write_count > 0)
    fprintf_unfiltered (stream, ", %ld bytes/write", data_count / write_count);
  fprintf_unfiltered (stream, ".\n");
a3293 12

  add_show_from_set
    (add_set_cmd ("download-write-size", class_obscure,
		  var_integer, (char *) &download_write_size,
		  "Set the write size used when downloading a program.\n"
		  "Only used when downloading a program onto a remote\n"
		  "target. Specify zero, or a negative value, to disable\n"
		  "blocked writes. The actual size of each transfer is also\n"
		  "limited by the size of the target packet and the memory\n"
		  "cache.\n",
		  &setlist),
     &showlist);
@


1.1.1.14
log
@import gdb-1999-11-08 snapshot
@
text
@a68 1
void (*target_new_objfile_hook) PARAMS ((struct objfile *));
d923 1
a923 2
  if (target_new_objfile_hook)
    target_new_objfile_hook (objfile);
d2099 1
a2099 2
  if (target_new_objfile_hook)
    target_new_objfile_hook (NULL);
@


1.1.1.15
log
@import gdb-1999-12-06 snapshot
@
text
@a66 5
void (*show_load_progress) (const char *section,
			    unsigned long section_sent, 
			    unsigned long section_size, 
			    unsigned long total_sent, 
			    unsigned long total_size);
a1227 2
  CORE_ADDR total_size = 0;
  CORE_ADDR total_sent = 0;
a1264 4
  for (s = loadfile_bfd->sections; s; s = s->next)
    if (s->flags & SEC_LOAD)
      total_size += bfd_get_section_size_before_reloc (s);

a1333 1
		  total_sent += len;
a1337 3

		  if (show_load_progress != NULL)
		    show_load_progress (sect_name, sent, size, total_sent, total_size);
d1438 1
a1438 1
  args = xstrdup (args);
d1563 1
a1563 1
		  section_addrs.other[sec_num].name = xstrdup (sec);
d1718 3
a1720 1
	      free_bcache (&objfile->psymbol_cache);
@


1.1.1.16
log
@import gdb-2000-02-01 snapshot
@
text
@d2 2
a3 1
   Copyright 1990-1996, 1998, 2000 Free Software Foundation, Inc.
d1403 1
a1403 1
print_transfer_performance (struct ui_file *stream,
@


1.1.1.17
log
@import gdb-2000-02-02 snapshot
@
text
@a1301 4
#ifdef UI_OUT
	      ui_out_message (uiout, 0, "Loading section %s, size 0x%s lma 0x%s\n",
			   sect_name, paddr_nz (size), paddr_nz (lma));
#else
a1304 1
#endif
a1366 8
#ifdef UI_OUT
   ui_out_text (uiout, "Start address ");
   ui_out_field_fmt (uiout, "address", "0x%s" , paddr_nz (entry));
   ui_out_text (uiout, ", load size ");
   ui_out_field_fmt (uiout, "load-size", "%ld" , data_count);
   ui_out_text (uiout, "\n");

#else
a1369 1
#endif
a1406 21
#ifdef UI_OUT
  ui_out_text (uiout, "Transfer rate: ");
  if (time_count > 0)
    {
      ui_out_field_fmt (uiout, "transfer-rate", "%ld", 
			(data_count * 8) / time_count);
      ui_out_text (uiout, " bits/sec");
    }
  else
    {
      ui_out_field_fmt (uiout, "transferred-bits", "%ld", (data_count * 8));
      ui_out_text (uiout, " bits in <1 sec");    
    }
  if (write_count > 0)
    {
      ui_out_text (uiout, ", ");
      ui_out_field_fmt (uiout, "write-rate", "%ld", data_count / write_count);
      ui_out_text (uiout, " bytes/write");
    }
  ui_out_text (uiout, ".\n");
#else
a1414 1
#endif
@


