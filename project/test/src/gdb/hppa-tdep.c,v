head	1.289;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.287
	gdb_7_6-2013-04-26-release:1.287
	gdb_7_6-branch:1.287.0.2
	gdb_7_6-2013-03-12-branchpoint:1.287
	gdb_7_5_1-2012-11-29-release:1.281
	gdb_7_5-2012-08-17-release:1.281
	gdb_7_5-branch:1.281.0.2
	gdb_7_5-2012-07-18-branchpoint:1.281
	gdb_7_4_1-2012-04-26-release:1.278.4.1
	gdb_7_4-2012-01-24-release:1.278.4.1
	gdb_7_4-branch:1.278.0.4
	gdb_7_4-2011-12-13-branchpoint:1.278
	gdb_7_3_1-2011-09-04-release:1.278
	gdb_7_3-2011-07-26-release:1.278
	gdb_7_3-branch:1.278.0.2
	gdb_7_3-2011-04-01-branchpoint:1.278
	gdb_7_2-2010-09-02-release:1.273
	gdb_7_2-branch:1.273.0.4
	gdb_7_2-2010-07-07-branchpoint:1.273
	gdb_7_1-2010-03-18-release:1.273
	gdb_7_1-branch:1.273.0.2
	gdb_7_1-2010-02-18-branchpoint:1.273
	gdb_7_0_1-2009-12-22-release:1.271
	gdb_7_0-2009-10-06-release:1.271
	gdb_7_0-branch:1.271.0.2
	gdb_7_0-2009-09-16-branchpoint:1.271
	arc-sim-20090309:1.247
	msnyder-checkpoint-072509-branch:1.270.0.2
	msnyder-checkpoint-072509-branchpoint:1.270
	arc-insight_6_8-branch:1.247.0.6
	arc-insight_6_8-branchpoint:1.247
	insight_6_8-branch:1.247.0.4
	insight_6_8-branchpoint:1.247
	reverse-20081226-branch:1.261.0.6
	reverse-20081226-branchpoint:1.261
	multiprocess-20081120-branch:1.261.0.4
	multiprocess-20081120-branchpoint:1.261
	reverse-20080930-branch:1.261.0.2
	reverse-20080930-branchpoint:1.261
	reverse-20080717-branch:1.256.0.2
	reverse-20080717-branchpoint:1.256
	msnyder-reverse-20080609-branch:1.251.0.2
	msnyder-reverse-20080609-branchpoint:1.251
	drow-reverse-20070409-branch:1.227.0.2
	drow-reverse-20070409-branchpoint:1.227
	gdb_6_8-2008-03-27-release:1.247
	gdb_6_8-branch:1.247.0.2
	gdb_6_8-2008-02-26-branchpoint:1.247
	gdb_6_7_1-2007-10-29-release:1.236
	gdb_6_7-2007-10-10-release:1.236
	gdb_6_7-branch:1.236.0.2
	gdb_6_7-2007-09-07-branchpoint:1.236
	insight_6_6-20070208-release:1.223
	gdb_6_6-2006-12-18-release:1.223
	gdb_6_6-branch:1.223.0.2
	gdb_6_6-2006-11-15-branchpoint:1.223
	insight_6_5-20061003-release:1.222
	gdb-csl-symbian-6_4_50_20060226-12:1.219
	gdb-csl-sourcerygxx-3_4_4-25:1.212
	nickrob-async-20060828-mergepoint:1.223
	gdb-csl-symbian-6_4_50_20060226-11:1.219
	gdb-csl-sourcerygxx-4_1-17:1.219
	gdb-csl-20060226-branch-local-2:1.219
	gdb-csl-sourcerygxx-4_1-14:1.219
	gdb-csl-sourcerygxx-4_1-13:1.219
	gdb-csl-sourcerygxx-4_1-12:1.219
	gdb-csl-sourcerygxx-3_4_4-21:1.219
	gdb_6_5-20060621-release:1.222
	gdb-csl-sourcerygxx-4_1-9:1.219
	gdb-csl-sourcerygxx-4_1-8:1.219
	gdb-csl-sourcerygxx-4_1-7:1.219
	gdb-csl-arm-2006q1-6:1.219
	gdb-csl-sourcerygxx-4_1-6:1.219
	gdb-csl-symbian-6_4_50_20060226-10:1.219
	gdb-csl-symbian-6_4_50_20060226-9:1.219
	gdb-csl-symbian-6_4_50_20060226-8:1.219
	gdb-csl-coldfire-4_1-11:1.219
	gdb-csl-sourcerygxx-3_4_4-19:1.219
	gdb-csl-coldfire-4_1-10:1.219
	gdb_6_5-branch:1.222.0.8
	gdb_6_5-2006-05-14-branchpoint:1.222
	gdb-csl-sourcerygxx-4_1-5:1.219
	nickrob-async-20060513-branch:1.222.0.6
	nickrob-async-20060513-branchpoint:1.222
	gdb-csl-sourcerygxx-4_1-4:1.219
	msnyder-reverse-20060502-branch:1.222.0.4
	msnyder-reverse-20060502-branchpoint:1.222
	gdb-csl-morpho-4_1-4:1.219
	gdb-csl-sourcerygxx-3_4_4-17:1.219
	readline_5_1-import-branch:1.222.0.2
	readline_5_1-import-branchpoint:1.222
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.219
	gdb-csl-symbian-20060226-branch:1.219.0.4
	gdb-csl-symbian-20060226-branchpoint:1.219
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.219
	msnyder-reverse-20060331-branch:1.221.0.4
	msnyder-reverse-20060331-branchpoint:1.221
	gdb-csl-available-20060303-branch:1.221.0.2
	gdb-csl-available-20060303-branchpoint:1.221
	gdb-csl-20060226-branch:1.219.0.2
	gdb-csl-20060226-branchpoint:1.219
	gdb_6_4-20051202-release:1.212
	msnyder-fork-checkpoint-branch:1.214.0.2
	msnyder-fork-checkpoint-branchpoint:1.214
	gdb-csl-gxxpro-6_3-branch:1.212.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.212
	gdb_6_4-branch:1.212.0.4
	gdb_6_4-2005-11-01-branchpoint:1.212
	gdb-csl-arm-20051020-branch:1.212.0.2
	gdb-csl-arm-20051020-branchpoint:1.212
	msnyder-tracepoint-checkpoint-branch:1.206.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.206
	gdb-csl-arm-20050325-2005-q1b:1.206
	gdb-csl-arm-20050325-2005-q1a:1.206
	csl-arm-20050325-branch:1.206.0.2
	csl-arm-20050325-branchpoint:1.206
	gdb-post-i18n-errorwarning-20050211:1.202
	gdb-pre-i18n-errorwarning-20050211:1.201
	gdb_6_3-20041109-release:1.174.2.1
	gdb_6_3-branch:1.174.0.2
	gdb_6_3-20041019-branchpoint:1.174
	drow_intercu-merge-20040921:1.173
	drow_intercu-merge-20040915:1.173
	jimb-gdb_6_2-e500-branch:1.170.0.6
	jimb-gdb_6_2-e500-branchpoint:1.170
	gdb_6_2-20040730-release:1.170
	gdb_6_2-branch:1.170.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.170
	gdb_6_1_1-20040616-release:1.129.2.2
	gdb_6_1-2004-04-05-release:1.129.2.2
	drow_intercu-merge-20040402:1.137
	drow_intercu-merge-20040327:1.136
	ezannoni_pie-20040323-branch:1.136.0.4
	ezannoni_pie-20040323-branchpoint:1.136
	cagney_tramp-20040321-mergepoint:1.136
	cagney_tramp-20040309-branch:1.136.0.2
	cagney_tramp-20040309-branchpoint:1.136
	gdb_6_1-branch:1.129.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.129
	drow_intercu-20040221-branch:1.117.0.2
	drow_intercu-20040221-branchpoint:1.117
	cagney_bfdfile-20040213-branch:1.116.0.2
	cagney_bfdfile-20040213-branchpoint:1.116
	drow-cplus-merge-20040208:1.114
	carlton_dictionary-20040126-merge:1.113
	cagney_bigcore-20040122-branch:1.113.0.2
	cagney_bigcore-20040122-branchpoint:1.113
	drow-cplus-merge-20040113:1.109
	drow-cplus-merge-20031224:1.109
	drow-cplus-merge-20031220:1.109
	carlton_dictionary-20031215-merge:1.107
	drow-cplus-merge-20031214:1.107
	carlton-dictionary-20031111-merge:1.105
	gdb_6_0-2003-10-04-release:1.85.2.1
	kettenis_sparc-20030918-branch:1.98.0.2
	kettenis_sparc-20030918-branchpoint:1.98
	carlton_dictionary-20030917-merge:1.98
	ezannoni_pie-20030916-branchpoint:1.96
	ezannoni_pie-20030916-branch:1.96.0.2
	cagney_x86i386-20030821-branch:1.89.0.2
	cagney_x86i386-20030821-branchpoint:1.89
	carlton_dictionary-20030805-merge:1.86
	carlton_dictionary-20030627-merge:1.85
	gdb_6_0-branch:1.85.0.2
	gdb_6_0-2003-06-23-branchpoint:1.85
	jimb-ppc64-linux-20030613-branch:1.84.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.84
	cagney_convert-20030606-branch:1.81.0.2
	cagney_convert-20030606-branchpoint:1.81
	cagney_writestrings-20030508-branch:1.75.0.4
	cagney_writestrings-20030508-branchpoint:1.75
	jimb-ppc64-linux-20030528-branch:1.79.0.2
	jimb-ppc64-linux-20030528-branchpoint:1.79
	carlton_dictionary-20030523-merge:1.79
	cagney_fileio-20030521-branch:1.78.0.2
	cagney_fileio-20030521-branchpoint:1.78
	kettenis_i386newframe-20030517-mergepoint:1.78
	jimb-ppc64-linux-20030509-branch:1.75.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.75
	kettenis_i386newframe-20030504-mergepoint:1.73
	carlton_dictionary-20030430-merge:1.73
	kettenis_i386newframe-20030419-branch:1.69.0.2
	kettenis_i386newframe-20030419-branchpoint:1.69
	carlton_dictionary-20030416-merge:1.69
	cagney_frameaddr-20030409-mergepoint:1.67
	kettenis_i386newframe-20030406-branch:1.67.0.2
	kettenis_i386newframe-20030406-branchpoint:1.67
	cagney_frameaddr-20030403-branchpoint:1.65
	cagney_frameaddr-20030403-branch:1.65.0.2
	cagney_framebase-20030330-mergepoint:1.64
	cagney_framebase-20030326-branch:1.62.0.2
	cagney_framebase-20030326-branchpoint:1.62
	cagney_lazyid-20030317-branch:1.55.0.2
	cagney_lazyid-20030317-branchpoint:1.55
	kettenis-i386newframe-20030316-mergepoint:1.55
	offbyone-20030313-branch:1.54.0.2
	offbyone-20030313-branchpoint:1.54
	kettenis-i386newframe-20030308-branch:1.53.0.4
	kettenis-i386newframe-20030308-branchpoint:1.53
	carlton_dictionary-20030305-merge:1.53
	cagney_offbyone-20030303-branch:1.53.0.2
	cagney_offbyone-20030303-branchpoint:1.53
	carlton_dictionary-20030207-merge:1.49
	interps-20030203-mergepoint:1.49
	interps-20030202-branch:1.49.0.2
	interps-20030202-branchpoint:1.49
	cagney-unwind-20030108-branch:1.46.0.2
	cagney-unwind-20030108-branchpoint:1.46
	carlton_dictionary-20021223-merge:1.41
	gdb_5_3-2002-12-12-release:1.27.12.1
	carlton_dictionary-20021115-merge:1.33
	kseitz_interps-20021105-merge:1.29
	kseitz_interps-20021103-merge:1.29
	drow-cplus-merge-20021020:1.27
	drow-cplus-merge-20021025:1.28
	carlton_dictionary-20021025-merge:1.28
	carlton_dictionary-20021011-merge:1.27
	drow-cplus-branch:1.27.0.16
	drow-cplus-branchpoint:1.27
	kseitz_interps-20020930-merge:1.27
	carlton_dictionary-20020927-merge:1.27
	carlton_dictionary-branch:1.27.0.14
	carlton_dictionary-20020920-branchpoint:1.27
	gdb_5_3-branch:1.27.0.12
	gdb_5_3-2002-09-04-branchpoint:1.27
	kseitz_interps-20020829-merge:1.27
	cagney_sysregs-20020825-branch:1.27.0.10
	cagney_sysregs-20020825-branchpoint:1.27
	readline_4_3-import-branch:1.27.0.8
	readline_4_3-import-branchpoint:1.27
	gdb_5_2_1-2002-07-23-release:1.22
	kseitz_interps-20020528-branch:1.27.0.6
	kseitz_interps-20020528-branchpoint:1.27
	cagney_regbuf-20020515-branch:1.27.0.4
	cagney_regbuf-20020515-branchpoint:1.27
	jimb-macro-020506-branch:1.27.0.2
	jimb-macro-020506-branchpoint:1.27
	gdb_5_2-2002-04-29-release:1.22
	gdb_5_2-branch:1.22.0.2
	gdb_5_2-2002-03-03-branchpoint:1.22
	gdb_5_1_1-2002-01-24-release:1.16
	gdb_5_1_0_1-2002-01-03-release:1.16
	cygnus_cvs_20020108_pre:1.18
	gdb_5_1_0_1-2002-01-03-branchpoint:1.16
	gdb_5_1_0_1-2002-01-03-branch:1.16.0.6
	gdb_5_1-2001-11-21-release:1.16
	gdb_s390-2001-09-26-branch:1.16.0.4
	gdb_s390-2001-09-26-branchpoint:1.16
	gdb_5_1-2001-07-29-branch:1.16.0.2
	gdb_5_1-2001-07-29-branchpoint:1.16
	dberlin-typesystem-branch:1.15.0.2
	dberlin-typesystem-branchpoint:1.15
	gdb-post-ptid_t-2001-05-03:1.13
	gdb-pre-ptid_t-2001-05-03:1.12
	insight-precleanup-2001-01-01:1.8
	gdb-post-protoization-2000-07-29:1.6
	gdb-pre-protoization-2000-07-29:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb-post-params-removal-2000-06-04:1.5
	gdb-pre-params-removal-2000-06-04:1.5
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.4
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.16
	insight-2000-02-04:1.1.1.16
	gdb-2000-02-04:1.1.1.16
	gdb-2000-02-02:1.1.1.16
	gdb-2000-02-01:1.1.1.16
	gdb-2000-01-31:1.1.1.15
	gdb-2000-01-26:1.1.1.15
	gdb-2000-01-24:1.1.1.15
	gdb-2000-01-17:1.1.1.15
	gdb-2000-01-10:1.1.1.15
	gdb-2000-01-05:1.1.1.15
	gdb-1999-12-21:1.1.1.15
	gdb-1999-12-13:1.1.1.15
	gdb-1999-12-07:1.1.1.15
	gdb-1999-12-06:1.1.1.15
	gdb-1999-11-16:1.1.1.15
	gdb-1999-11-08:1.1.1.14
	gdb-1999-11-01:1.1.1.14
	gdb-1999-10-25:1.1.1.14
	gdb-1999-10-18:1.1.1.14
	gdb-1999-10-11:1.1.1.14
	gdb-1999-10-04:1.1.1.14
	gdb-1999-09-28:1.1.1.13
	gdb-1999-09-21:1.1.1.12
	gdb-1999-09-13:1.1.1.11
	gdb-1999-09-08:1.1.1.11
	gdb-1999-08-30:1.1.1.10
	gdb-1999-08-23:1.1.1.9
	gdb-1999-08-16:1.1.1.8
	gdb-1999-08-09:1.1.1.7
	gdb-1999-08-02:1.1.1.7
	gdb-1999-07-26:1.1.1.6
	gdb-1999-07-19:1.1.1.6
	gdb-1999-07-12:1.1.1.5
	gdb-post-reformat-19990707:1.1.1.5
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.5
	gdb-pre-reformat-19990707:1.1.1.4
	gdb-1999-07-07:1.1.1.4
	gdb-1999-07-05:1.1.1.4
	gdb-1999-06-28:1.1.1.4
	gdb-1999-06-21:1.1.1.4
	gdb-1999-06-14:1.1.1.4
	gdb-1999-06-07:1.1.1.4
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.289
date	2013.06.24.22.18.31;	author macro;	state Exp;
branches;
next	1.288;

1.288
date	2013.04.19.15.09.45;	author palves;	state Exp;
branches;
next	1.287;

1.287
date	2013.03.01.15.38.24;	author palves;	state Exp;
branches;
next	1.286;

1.286
date	2013.01.30.20.42.11;	author tromey;	state Exp;
branches;
next	1.285;

1.285
date	2013.01.01.06.32.44;	author brobecke;	state Exp;
branches;
next	1.284;

1.284
date	2012.11.21.00.29.55;	author qiyao;	state Exp;
branches;
next	1.283;

1.283
date	2012.09.27.10.40.00;	author siddhesh;	state Exp;
branches;
next	1.282;

1.282
date	2012.09.26.07.52.48;	author siddhesh;	state Exp;
branches;
next	1.281;

1.281
date	2012.05.18.21.02.48;	author sergiodj;	state Exp;
branches;
next	1.280;

1.280
date	2012.05.16.14.35.04;	author macro;	state Exp;
branches;
next	1.279;

1.279
date	2012.01.04.08.17.03;	author brobecke;	state Exp;
branches;
next	1.278;

1.278
date	2011.03.18.18.52.30;	author palves;	state Exp;
branches
	1.278.4.1;
next	1.277;

1.277
date	2011.03.18.18.38.42;	author palves;	state Exp;
branches;
next	1.276;

1.276
date	2011.01.09.03.08.54;	author msnyder;	state Exp;
branches;
next	1.275;

1.275
date	2011.01.01.15.33.05;	author brobecke;	state Exp;
branches;
next	1.274;

1.274
date	2010.09.10.16.17.14;	author muller;	state Exp;
branches;
next	1.273;

1.273
date	2010.01.19.09.39.12;	author brobecke;	state Exp;
branches;
next	1.272;

1.272
date	2010.01.01.07.31.33;	author brobecke;	state Exp;
branches;
next	1.271;

1.271
date	2009.09.13.16.28.28;	author brobecke;	state Exp;
branches;
next	1.270;

1.270
date	2009.07.02.17.25.54;	author uweigand;	state Exp;
branches;
next	1.269;

1.269
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.268;

1.268
date	2009.07.02.12.48.53;	author uweigand;	state Exp;
branches;
next	1.267;

1.267
date	2009.07.02.12.46.19;	author uweigand;	state Exp;
branches;
next	1.266;

1.266
date	2009.06.28.00.05.14;	author drow;	state Exp;
branches;
next	1.265;

1.265
date	2009.06.07.22.52.44;	author palves;	state Exp;
branches;
next	1.264;

1.264
date	2009.02.22.01.02.17;	author palves;	state Exp;
branches;
next	1.263;

1.263
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.262;

1.262
date	2008.12.28.14.14.19;	author jkratoch;	state Exp;
branches;
next	1.261;

1.261
date	2008.09.15.01.56.31;	author danglin;	state Exp;
branches;
next	1.260;

1.260
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.259;

1.259
date	2008.09.05.11.45.01;	author uweigand;	state Exp;
branches;
next	1.258;

1.258
date	2008.09.05.11.42.31;	author uweigand;	state Exp;
branches;
next	1.257;

1.257
date	2008.08.21.13.19.18;	author palves;	state Exp;
branches;
next	1.256;

1.256
date	2008.07.15.23.29.24;	author drow;	state Exp;
branches;
next	1.255;

1.255
date	2008.07.15.18.58.32;	author drow;	state Exp;
branches;
next	1.254;

1.254
date	2008.07.15.18.40.03;	author drow;	state Exp;
branches;
next	1.253;

1.253
date	2008.07.15.18.32.05;	author drow;	state Exp;
branches;
next	1.252;

1.252
date	2008.06.26.15.51.28;	author drow;	state Exp;
branches;
next	1.251;

1.251
date	2008.05.16.00.27.23;	author drow;	state Exp;
branches;
next	1.250;

1.250
date	2008.05.08.04.21.45;	author brobecke;	state Exp;
branches;
next	1.249;

1.249
date	2008.04.22.11.03.41;	author corinna;	state Exp;
branches;
next	1.248;

1.248
date	2008.03.13.12.22.12;	author drow;	state Exp;
branches;
next	1.247;

1.247
date	2008.02.18.16.11.21;	author deuling;	state Exp;
branches;
next	1.246;

1.246
date	2008.01.11.14.43.14;	author deuling;	state Exp;
branches;
next	1.245;

1.245
date	2008.01.11.13.20.00;	author deuling;	state Exp;
branches;
next	1.244;

1.244
date	2008.01.01.22.53.10;	author drow;	state Exp;
branches;
next	1.243;

1.243
date	2007.12.06.16.32.59;	author deuling;	state Exp;
branches;
next	1.242;

1.242
date	2007.11.16.04.56.45;	author deuling;	state Exp;
branches;
next	1.241;

1.241
date	2007.11.07.06.32.59;	author deuling;	state Exp;
branches;
next	1.240;

1.240
date	2007.11.02.14.27.14;	author uweigand;	state Exp;
branches;
next	1.239;

1.239
date	2007.10.30.21.56.12;	author uweigand;	state Exp;
branches;
next	1.238;

1.238
date	2007.10.12.16.11.12;	author uweigand;	state Exp;
branches;
next	1.237;

1.237
date	2007.10.08.12.50.56;	author uweigand;	state Exp;
branches;
next	1.236;

1.236
date	2007.08.29.04.11.06;	author carlos;	state Exp;
branches;
next	1.235;

1.235
date	2007.08.23.18.08.33;	author brobecke;	state Exp;
branches;
next	1.234;

1.234
date	2007.06.15.22.44.55;	author uweigand;	state Exp;
branches;
next	1.233;

1.233
date	2007.06.15.22.39.52;	author uweigand;	state Exp;
branches;
next	1.232;

1.232
date	2007.06.15.22.34.13;	author uweigand;	state Exp;
branches;
next	1.231;

1.231
date	2007.06.13.17.30.01;	author uweigand;	state Exp;
branches;
next	1.230;

1.230
date	2007.06.09.14.20.24;	author uweigand;	state Exp;
branches;
next	1.229;

1.229
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.228;

1.228
date	2007.05.13.13.02.54;	author uweigand;	state Exp;
branches;
next	1.227;

1.227
date	2007.02.27.20.17.18;	author drow;	state Exp;
branches;
next	1.226;

1.226
date	2007.02.16.21.49.59;	author drow;	state Exp;
branches;
next	1.225;

1.225
date	2007.01.29.17.31.06;	author drow;	state Exp;
branches;
next	1.224;

1.224
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.223;

1.223
date	2006.08.08.21.32.48;	author brobecke;	state Exp;
branches;
next	1.222;

1.222
date	2006.03.30.14.15.00;	author tausq;	state Exp;
branches
	1.222.6.1;
next	1.221;

1.221
date	2006.03.01.05.43.03;	author tausq;	state Exp;
branches;
next	1.220;

1.220
date	2006.03.01.05.22.38;	author tausq;	state Exp;
branches;
next	1.219;

1.219
date	2006.02.19.07.21.26;	author tausq;	state Exp;
branches;
next	1.218;

1.218
date	2006.01.20.23.37.07;	author kettenis;	state Exp;
branches;
next	1.217;

1.217
date	2005.12.17.22.34.00;	author eliz;	state Exp;
branches;
next	1.216;

1.216
date	2005.12.09.11.13.34;	author tausq;	state Exp;
branches;
next	1.215;

1.215
date	2005.12.09.11.10.25;	author tausq;	state Exp;
branches;
next	1.214;

1.214
date	2005.11.19.12.39.50;	author tausq;	state Exp;
branches;
next	1.213;

1.213
date	2005.11.19.12.38.56;	author tausq;	state Exp;
branches;
next	1.212;

1.212
date	2005.10.03.20.53.00;	author brobecke;	state Exp;
branches;
next	1.211;

1.211
date	2005.07.18.20.34.09;	author kettenis;	state Exp;
branches;
next	1.210;

1.210
date	2005.06.19.21.25.47;	author kettenis;	state Exp;
branches;
next	1.209;

1.209
date	2005.06.18.22.03.41;	author kettenis;	state Exp;
branches;
next	1.208;

1.208
date	2005.06.13.13.43.32;	author brobecke;	state Exp;
branches;
next	1.207;

1.207
date	2005.06.12.19.54.25;	author kettenis;	state Exp;
branches;
next	1.206;

1.206
date	2005.02.17.13.49.53;	author cagney;	state Exp;
branches;
next	1.205;

1.205
date	2005.02.14.18.10.08;	author cagney;	state Exp;
branches;
next	1.204;

1.204
date	2005.02.14.16.18.41;	author cagney;	state Exp;
branches;
next	1.203;

1.203
date	2005.02.11.18.13.50;	author cagney;	state Exp;
branches;
next	1.202;

1.202
date	2005.02.11.04.05.50;	author cagney;	state Exp;
branches;
next	1.201;

1.201
date	2005.02.10.17.32.48;	author cagney;	state Exp;
branches;
next	1.200;

1.200
date	2005.02.07.00.09.53;	author cagney;	state Exp;
branches;
next	1.199;

1.199
date	2005.01.01.12.28.17;	author brobecke;	state Exp;
branches;
next	1.198;

1.198
date	2004.12.21.22.50.54;	author kettenis;	state Exp;
branches;
next	1.197;

1.197
date	2004.12.21.22.06.40;	author kettenis;	state Exp;
branches;
next	1.196;

1.196
date	2004.12.21.21.36.28;	author kettenis;	state Exp;
branches;
next	1.195;

1.195
date	2004.12.19.21.09.40;	author kettenis;	state Exp;
branches;
next	1.194;

1.194
date	2004.12.17.19.09.53;	author tausq;	state Exp;
branches;
next	1.193;

1.193
date	2004.12.17.07.42.47;	author brobecke;	state Exp;
branches;
next	1.192;

1.192
date	2004.12.14.16.35.37;	author tausq;	state Exp;
branches;
next	1.191;

1.191
date	2004.12.13.04.06.15;	author tausq;	state Exp;
branches;
next	1.190;

1.190
date	2004.12.12.16.26.17;	author cagney;	state Exp;
branches;
next	1.189;

1.189
date	2004.12.08.06.12.40;	author tausq;	state Exp;
branches;
next	1.188;

1.188
date	2004.12.08.01.48.02;	author tausq;	state Exp;
branches;
next	1.187;

1.187
date	2004.12.08.01.44.02;	author tausq;	state Exp;
branches;
next	1.186;

1.186
date	2004.12.07.18.04.10;	author kettenis;	state Exp;
branches;
next	1.185;

1.185
date	2004.12.06.03.32.26;	author tausq;	state Exp;
branches;
next	1.184;

1.184
date	2004.12.03.23.59.52;	author tausq;	state Exp;
branches;
next	1.183;

1.183
date	2004.12.01.06.54.56;	author tausq;	state Exp;
branches;
next	1.182;

1.182
date	2004.11.23.21.05.20;	author tausq;	state Exp;
branches;
next	1.181;

1.181
date	2004.11.13.02.15.32;	author cagney;	state Exp;
branches;
next	1.180;

1.180
date	2004.11.12.18.38.32;	author tausq;	state Exp;
branches;
next	1.179;

1.179
date	2004.11.12.00.51.23;	author tausq;	state Exp;
branches;
next	1.178;

1.178
date	2004.11.12.00.48.12;	author tausq;	state Exp;
branches;
next	1.177;

1.177
date	2004.11.10.16.26.55;	author tausq;	state Exp;
branches;
next	1.176;

1.176
date	2004.11.03.23.20.43;	author tausq;	state Exp;
branches;
next	1.175;

1.175
date	2004.10.31.21.09.28;	author cagney;	state Exp;
branches;
next	1.174;

1.174
date	2004.10.14.21.08.06;	author kettenis;	state Exp;
branches
	1.174.2.1;
next	1.173;

1.173
date	2004.07.31.21.53.17;	author cagney;	state Exp;
branches;
next	1.172;

1.172
date	2004.07.26.14.53.01;	author cagney;	state Exp;
branches;
next	1.171;

1.171
date	2004.07.20.19.45.05;	author cagney;	state Exp;
branches;
next	1.170;

1.170
date	2004.06.07.15.28.47;	author tausq;	state Exp;
branches;
next	1.169;

1.169
date	2004.06.07.02.17.29;	author tausq;	state Exp;
branches;
next	1.168;

1.168
date	2004.06.07.02.08.07;	author tausq;	state Exp;
branches;
next	1.167;

1.167
date	2004.06.07.02.02.47;	author tausq;	state Exp;
branches;
next	1.166;

1.166
date	2004.05.30.14.11.00;	author kettenis;	state Exp;
branches;
next	1.165;

1.165
date	2004.05.26.04.02.24;	author tausq;	state Exp;
branches;
next	1.164;

1.164
date	2004.05.25.03.55.23;	author tausq;	state Exp;
branches;
next	1.163;

1.163
date	2004.05.24.15.36.31;	author tausq;	state Exp;
branches;
next	1.162;

1.162
date	2004.05.19.03.07.58;	author tausq;	state Exp;
branches;
next	1.161;

1.161
date	2004.05.19.02.38.28;	author tausq;	state Exp;
branches;
next	1.160;

1.160
date	2004.05.19.02.15.22;	author tausq;	state Exp;
branches;
next	1.159;

1.159
date	2004.05.17.16.46.06;	author tausq;	state Exp;
branches;
next	1.158;

1.158
date	2004.05.17.15.16.39;	author tausq;	state Exp;
branches;
next	1.157;

1.157
date	2004.05.17.14.59.16;	author tausq;	state Exp;
branches;
next	1.156;

1.156
date	2004.05.08.03.59.34;	author tausq;	state Exp;
branches;
next	1.155;

1.155
date	2004.05.08.03.17.57;	author tausq;	state Exp;
branches;
next	1.154;

1.154
date	2004.05.07.05.48.49;	author tausq;	state Exp;
branches;
next	1.153;

1.153
date	2004.04.29.03.36.49;	author tausq;	state Exp;
branches;
next	1.152;

1.152
date	2004.04.29.03.25.35;	author tausq;	state Exp;
branches;
next	1.151;

1.151
date	2004.04.24.06.13.32;	author tausq;	state Exp;
branches;
next	1.150;

1.150
date	2004.04.24.06.10.01;	author tausq;	state Exp;
branches;
next	1.149;

1.149
date	2004.04.23.02.54.21;	author tausq;	state Exp;
branches;
next	1.148;

1.148
date	2004.04.23.02.51.52;	author tausq;	state Exp;
branches;
next	1.147;

1.147
date	2004.04.17.17.41.10;	author tausq;	state Exp;
branches;
next	1.146;

1.146
date	2004.04.17.17.31.40;	author tausq;	state Exp;
branches;
next	1.145;

1.145
date	2004.04.17.17.19.28;	author tausq;	state Exp;
branches;
next	1.144;

1.144
date	2004.04.17.15.34.16;	author tausq;	state Exp;
branches;
next	1.143;

1.143
date	2004.04.11.04.20.51;	author tausq;	state Exp;
branches;
next	1.142;

1.142
date	2004.04.06.16.11.02;	author cagney;	state Exp;
branches;
next	1.141;

1.141
date	2004.04.06.15.41.50;	author cagney;	state Exp;
branches;
next	1.140;

1.140
date	2004.04.06.15.30.19;	author cagney;	state Exp;
branches;
next	1.139;

1.139
date	2004.04.06.02.53.41;	author cagney;	state Exp;
branches;
next	1.138;

1.138
date	2004.04.03.17.49.06;	author cagney;	state Exp;
branches;
next	1.137;

1.137
date	2004.03.31.17.44.08;	author brobecke;	state Exp;
branches;
next	1.136;

1.136
date	2004.03.07.19.58.27;	author cagney;	state Exp;
branches;
next	1.135;

1.135
date	2004.03.07.19.21.13;	author cagney;	state Exp;
branches;
next	1.134;

1.134
date	2004.03.07.19.00.42;	author cagney;	state Exp;
branches;
next	1.133;

1.133
date	2004.03.07.18.06.14;	author cagney;	state Exp;
branches;
next	1.132;

1.132
date	2004.03.07.17.19.26;	author cagney;	state Exp;
branches;
next	1.131;

1.131
date	2004.03.07.17.06.21;	author cagney;	state Exp;
branches;
next	1.130;

1.130
date	2004.03.05.04.49.52;	author brobecke;	state Exp;
branches;
next	1.129;

1.129
date	2004.02.27.21.47.53;	author cagney;	state Exp;
branches
	1.129.2.1;
next	1.128;

1.128
date	2004.02.27.19.06.16;	author cagney;	state Exp;
branches;
next	1.127;

1.127
date	2004.02.27.16.38.39;	author cagney;	state Exp;
branches;
next	1.126;

1.126
date	2004.02.25.20.00.40;	author cagney;	state Exp;
branches;
next	1.125;

1.125
date	2004.02.23.16.35.54;	author cagney;	state Exp;
branches;
next	1.124;

1.124
date	2004.02.23.00.06.39;	author cagney;	state Exp;
branches;
next	1.123;

1.123
date	2004.02.22.19.22.37;	author cagney;	state Exp;
branches;
next	1.122;

1.122
date	2004.02.22.17.58.10;	author cagney;	state Exp;
branches;
next	1.121;

1.121
date	2004.02.22.17.34.17;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2004.02.22.17.01.04;	author cagney;	state Exp;
branches;
next	1.119;

1.119
date	2004.02.22.16.55.03;	author cagney;	state Exp;
branches;
next	1.118;

1.118
date	2004.02.22.16.51.37;	author cagney;	state Exp;
branches;
next	1.117;

1.117
date	2004.02.16.21.49.22;	author cagney;	state Exp;
branches
	1.117.2.1;
next	1.116;

1.116
date	2004.02.11.16.46.20;	author cagney;	state Exp;
branches;
next	1.115;

1.115
date	2004.02.11.15.40.27;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2004.02.07.18.29.53;	author ezannoni;	state Exp;
branches;
next	1.113;

1.113
date	2004.01.17.18.45.25;	author cagney;	state Exp;
branches;
next	1.112;

1.112
date	2004.01.17.17.01.32;	author cagney;	state Exp;
branches;
next	1.111;

1.111
date	2004.01.17.15.34.11;	author cagney;	state Exp;
branches;
next	1.110;

1.110
date	2004.01.13.21.38.46;	author cagney;	state Exp;
branches;
next	1.109;

1.109
date	2003.12.19.06.45.03;	author chastain;	state Exp;
branches;
next	1.108;

1.108
date	2003.12.18.22.13.48;	author chastain;	state Exp;
branches;
next	1.107;

1.107
date	2003.11.23.20.41.16;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2003.11.22.22.15.23;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2003.10.16.16.35.26;	author ezannoni;	state Exp;
branches;
next	1.104;

1.104
date	2003.10.11.12.40.38;	author amodra;	state Exp;
branches;
next	1.103;

1.103
date	2003.10.02.20.28.29;	author cagney;	state Exp;
branches;
next	1.102;

1.102
date	2003.10.01.18.48.12;	author cagney;	state Exp;
branches;
next	1.101;

1.101
date	2003.09.30.13.29.43;	author cagney;	state Exp;
branches;
next	1.100;

1.100
date	2003.09.28.22.32.19;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2003.09.25.20.44.01;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2003.09.17.15.42.18;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2003.09.17.14.24.30;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2003.09.14.16.32.12;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2003.09.13.23.25.41;	author kettenis;	state Exp;
branches;
next	1.93;

1.93
date	2003.09.11.15.17.15;	author cagney;	state Exp;
branches;
next	1.92;

1.92
date	2003.09.11.02.00.50;	author brobecke;	state Exp;
branches;
next	1.91;

1.91
date	2003.09.04.18.04.24;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2003.08.28.03.03.44;	author cagney;	state Exp;
branches;
next	1.89;

1.89
date	2003.08.15.23.02.03;	author brobecke;	state Exp;
branches;
next	1.88;

1.88
date	2003.08.13.18.57.01;	author brobecke;	state Exp;
branches;
next	1.87;

1.87
date	2003.08.13.17.09.09;	author brobecke;	state Exp;
branches;
next	1.86;

1.86
date	2003.07.03.22.14.42;	author cagney;	state Exp;
branches;
next	1.85;

1.85
date	2003.06.19.15.04.56;	author drow;	state Exp;
branches
	1.85.2.1;
next	1.84;

1.84
date	2003.06.13.04.40.32;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2003.06.09.20.08.55;	author cagney;	state Exp;
branches;
next	1.82;

1.82
date	2003.06.09.17.35.57;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2003.06.04.20.55.02;	author brobecke;	state Exp;
branches;
next	1.80;

1.80
date	2003.06.02.02.54.35;	author fedor;	state Exp;
branches;
next	1.79;

1.79
date	2003.05.22.02.04.05;	author brobecke;	state Exp;
branches;
next	1.78;

1.78
date	2003.05.17.05.59.58;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2003.05.15.22.58.36;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2003.05.14.17.43.17;	author ezannoni;	state Exp;
branches;
next	1.75;

1.75
date	2003.05.08.22.33.14;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2003.05.05.17.56.55;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2003.04.29.01.49.47;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2003.04.28.16.17.28;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2003.04.22.23.04.39;	author brobecke;	state Exp;
branches;
next	1.70;

1.70
date	2003.04.21.16.48.37;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2003.04.13.15.54.58;	author cagney;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2003.04.11.18.15.38;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2003.04.06.01.13.59;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2003.04.05.18.54.38;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2003.04.01.17.17.27;	author cagney;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2003.03.29.23.29.47;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2003.03.26.22.39.52;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2003.03.25.22.56.40;	author cagney;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2003.03.25.20.38.45;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2003.03.24.03.54.48;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2003.03.19.20.14.00;	author brobecke;	state Exp;
branches;
next	1.58;

1.58
date	2003.03.18.18.57.47;	author brobecke;	state Exp;
branches;
next	1.57;

1.57
date	2003.03.18.18.26.40;	author brobecke;	state Exp;
branches;
next	1.56;

1.56
date	2003.03.17.23.25.08;	author brobecke;	state Exp;
branches;
next	1.55;

1.55
date	2003.03.13.21.45.40;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2003.03.12.16.50.44;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2003.03.03.20.50.18;	author cagney;	state Exp;
branches
	1.53.4.1;
next	1.52;

1.52
date	2003.03.02.00.11.42;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2003.02.27.17.48.47;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2003.02.25.21.36.17;	author carlton;	state Exp;
branches;
next	1.49;

1.49
date	2003.02.02.05.46.14;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2003.02.01.23.34.04;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2003.01.18.15.55.52;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2003.01.05.01.39.54;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2003.01.04.23.38.44;	author drow;	state Exp;
branches;
next	1.44;

1.44
date	2003.01.04.22.37.47;	author drow;	state Exp;
branches;
next	1.43;

1.43
date	2002.12.26.20.10.13;	author brobecke;	state Exp;
branches;
next	1.42;

1.42
date	2002.12.26.09.36.41;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2002.12.16.16.51.45;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2002.12.13.14.37.41;	author brobecke;	state Exp;
branches;
next	1.39;

1.39
date	2002.12.11.20.35.43;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2002.12.11.02.26.35;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.12.02.23.30.34;	author brobecke;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.29.19.15.14;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.24.19.48.12;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2002.11.18.22.19.27;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2002.11.14.00.25.02;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2002.11.08.03.35.13;	author brobecke;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.07.07.47.20;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.07.02.19.56;	author brobecke;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.30.20.42.54;	author brobecke;	state Exp;
branches;
next	1.28;

1.28
date	2002.10.24.21.02.53;	author ezannoni;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.05.01.15.13;	author cagney;	state Exp;
branches
	1.27.6.1
	1.27.12.1
	1.27.14.1
	1.27.16.1;
next	1.26;

1.26
date	2002.04.24.16.28.15;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.12.18.18.57;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.27.00.21.51;	author law;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.06.06.28.33;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.03.11.43.17;	author schauer;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.01.22.45.32;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.01.02.05.13;	author msnyder;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.13.15.48.56;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.19.20.21.43;	author law;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.24.02.53.48;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.15.20.10.02;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.06.16.31.32;	author jlarmour;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.12.03.18.33;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.04.04.15.24;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.06.17.53.39;	author dsmith;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.14.16.42.29;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.06.08.21.08;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.02.00.07.32;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.10.21.17.46;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.28.01.12.27;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.15.05.54.02;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.14.18.43.41;	author jimb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.45;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.01;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.278.4.1
date	2012.01.06.04.43.15;	author brobecke;	state Exp;
branches;
next	;

1.222.6.1
date	2006.08.28.07.48.48;	author nickrob;	state Exp;
branches;
next	;

1.174.2.1
date	2004.11.03.23.39.36;	author tausq;	state Exp;
branches;
next	;

1.129.2.1
date	2004.03.10.20.06.08;	author brobecke;	state Exp;
branches;
next	1.129.2.2;

1.129.2.2
date	2004.03.31.18.45.59;	author brobecke;	state Exp;
branches;
next	;

1.117.2.1
date	2004.03.27.17.37.49;	author drow;	state Exp;
branches;
next	1.117.2.2;

1.117.2.2
date	2004.04.02.16.47.46;	author drow;	state Exp;
branches;
next	1.117.2.3;

1.117.2.3
date	2004.09.16.17.01.07;	author drow;	state Exp;
branches;
next	;

1.85.2.1
date	2003.07.27.17.19.57;	author cagney;	state Exp;
branches;
next	;

1.69.2.1
date	2003.05.04.11.37.42;	author kettenis;	state Exp;
branches;
next	;

1.65.2.1
date	2003.04.10.21.33.48;	author cagney;	state Exp;
branches;
next	;

1.62.2.1
date	2003.03.30.16.35.20;	author cagney;	state Exp;
branches;
next	;

1.53.4.1
date	2003.03.16.14.01.49;	author kettenis;	state Exp;
branches;
next	;

1.27.6.1
date	2002.11.04.00.17.31;	author ezannoni;	state Exp;
branches;
next	;

1.27.12.1
date	2002.10.31.23.34.47;	author brobecke;	state Exp;
branches;
next	;

1.27.14.1
date	2002.10.25.23.49.54;	author carlton;	state Exp;
branches;
next	1.27.14.2;

1.27.14.2
date	2002.11.15.19.18.45;	author carlton;	state Exp;
branches;
next	1.27.14.3;

1.27.14.3
date	2002.12.21.00.17.43;	author carlton;	state Exp;
branches;
next	1.27.14.4;

1.27.14.4
date	2002.12.23.19.38.27;	author carlton;	state Exp;
branches;
next	1.27.14.5;

1.27.14.5
date	2003.02.07.19.17.49;	author carlton;	state Exp;
branches;
next	1.27.14.6;

1.27.14.6
date	2003.03.06.00.56.29;	author carlton;	state Exp;
branches;
next	1.27.14.7;

1.27.14.7
date	2003.03.07.22.52.53;	author carlton;	state Exp;
branches;
next	1.27.14.8;

1.27.14.8
date	2003.04.16.19.56.52;	author carlton;	state Exp;
branches;
next	1.27.14.9;

1.27.14.9
date	2003.05.01.00.46.49;	author carlton;	state Exp;
branches;
next	1.27.14.10;

1.27.14.10
date	2003.05.23.18.40.39;	author carlton;	state Exp;
branches;
next	1.27.14.11;

1.27.14.11
date	2003.06.27.21.49.57;	author carlton;	state Exp;
branches;
next	1.27.14.12;

1.27.14.12
date	2003.08.05.17.13.10;	author carlton;	state Exp;
branches;
next	1.27.14.13;

1.27.14.13
date	2003.09.17.21.28.21;	author carlton;	state Exp;
branches;
next	1.27.14.14;

1.27.14.14
date	2003.11.11.23.50.44;	author carlton;	state Exp;
branches;
next	1.27.14.15;

1.27.14.15
date	2003.12.16.00.00.35;	author carlton;	state Exp;
branches;
next	1.27.14.16;

1.27.14.16
date	2004.01.26.19.11.24;	author carlton;	state Exp;
branches;
next	;

1.27.16.1
date	2002.10.26.17.12.07;	author drow;	state Exp;
branches;
next	1.27.16.2;

1.27.16.2
date	2003.12.14.20.27.16;	author drow;	state Exp;
branches;
next	1.27.16.3;

1.27.16.3
date	2003.12.20.18.16.49;	author drow;	state Exp;
branches;
next	1.27.16.4;

1.27.16.4
date	2004.02.09.19.43.40;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.01;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.21;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.42.31;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.06.07.19.17.31;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.07.20.06.45;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.07.19.23.27.56;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.08.02.23.45.33;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.08.16.19.52.48;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.08.23.22.35.06;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.08.31.01.05.07;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.09.08.23.59.15;	author shebs;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.09.22.03.24.34;	author jsm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.09.28.21.52.11;	author jsm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.10.05.23.08.18;	author jsm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.11.17.02.30.25;	author jsm;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2000.02.02.00.21.08;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.289
log
@	* objfiles.h (pc_in_section): New prototype.
	(in_plt_section): Remove name argument, replace prototype with
	static inline function.
	* mips-tdep.h: Include "objfiles.h".
	(in_mips_stubs_section): New function.
	* hppa-tdep.h (gdbarch_tdep): Remove name argument of
	in_solib_call_trampoline member.
	(hppa_in_solib_call_trampoline): Remove name argument.
	* objfiles.c (pc_in_section): New function.
	(in_plt_section): Remove function.
	* mips-linux-tdep.c: Include "objfiles.h".
	(mips_linux_in_dynsym_stub): Call in_mips_stubs_section.  Remove
	name argument.  Return 1 rather than the low 16-bit halfword of
	any instruction examined.
	(mips_linux_in_dynsym_resolve_code): Update
	mips_linux_in_dynsym_stub call accordingly.
	* mips-tdep.c (mips_stub_frame_sniffer): Use in_mips_stubs_section
	rather than an equivalent hand-coded sequence.
	* hppa-hpux-tdep.c (in_opd_section): Remove function.
	(hppa32_hpux_in_solib_call_trampoline): Remove name argument.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.
	(hppa64_hpux_find_global_pointer): Use pc_in_section rather than
	in_opd_section.
	* hppa-tdep.c (hppa_stub_unwind_sniffer): Remove name argument
	on call to tdep->in_solib_call_trampoline.
	(hppa_in_solib_call_trampoline): Remove name argument, update
	according to in_plt_section change.
	(hppa_skip_trampoline_code): Update according to in_plt_section
	change.
	* aarch64-tdep.c (aarch64_stub_unwind_sniffer): Likewise.
	* arm-symbian-tdep.c (arm_symbian_skip_trampoline_code):
	Likewise.
	* arm-tdep.c (arm_stub_unwind_sniffer): Likewise.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Likewise.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Likewise.
	* nios2-tdep.c (nios2_stub_frame_sniffer): Likewise.
	* nto-tdep.c (nto_relocate_section_addresses): Likewise.
	* s390-tdep.c (s390_stub_frame_sniffer): Likewise.
	* sh-tdep.c (sh_stub_unwind_sniffer): Likewise.
	* solib-dsbt.c (dsbt_in_dynsym_resolve_code): Likewise.
	* solib-frv.c (frv_in_dynsym_resolve_code): Likewise.
	* solib-svr4.c (svr4_in_dynsym_resolve_code): Likewise.
	* solib-target.c (solib_target_in_dynsym_resolve_code): Likewise.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise.
	* tic6x-tdep.c (tic6x_stub_unwind_sniffer): Likewise.
@
text
@/* Target-dependent code for the HP PA-RISC architecture.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   Contributed by the Center for Software Science at the
   University of Utah (pa-gdb-bugs@@cs.utah.edu).

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "bfd.h"
#include "inferior.h"
#include "regcache.h"
#include "completer.h"
#include "osabi.h"
#include "gdb_assert.h"
#include "arch-utils.h"
/* For argument passing to the inferior.  */
#include "symtab.h"
#include "dis-asm.h"
#include "trad-frame.h"
#include "frame-unwind.h"
#include "frame-base.h"

#include "gdbcore.h"
#include "gdbcmd.h"
#include "gdbtypes.h"
#include "objfiles.h"
#include "hppa-tdep.h"

static int hppa_debug = 0;

/* Some local constants.  */
static const int hppa32_num_regs = 128;
static const int hppa64_num_regs = 96;

/* hppa-specific object data -- unwind and solib info.
   TODO/maybe: think about splitting this into two parts; the unwind data is 
   common to all hppa targets, but is only used in this file; we can register 
   that separately and make this static. The solib data is probably hpux-
   specific, so we can create a separate extern objfile_data that is registered
   by hppa-hpux-tdep.c and shared with pa64solib.c and somsolib.c.  */
const struct objfile_data *hppa_objfile_priv_data = NULL;

/* Get at various relevent fields of an instruction word.  */
#define MASK_5 0x1f
#define MASK_11 0x7ff
#define MASK_14 0x3fff
#define MASK_21 0x1fffff

/* Sizes (in bytes) of the native unwind entries.  */
#define UNWIND_ENTRY_SIZE 16
#define STUB_UNWIND_ENTRY_SIZE 8

/* Routines to extract various sized constants out of hppa 
   instructions.  */

/* This assumes that no garbage lies outside of the lower bits of 
   value.  */

static int
hppa_sign_extend (unsigned val, unsigned bits)
{
  return (int) (val >> (bits - 1) ? (-1 << bits) | val : val);
}

/* For many immediate values the sign bit is the low bit!  */

static int
hppa_low_hppa_sign_extend (unsigned val, unsigned bits)
{
  return (int) ((val & 0x1 ? (-1 << (bits - 1)) : 0) | val >> 1);
}

/* Extract the bits at positions between FROM and TO, using HP's numbering
   (MSB = 0).  */

int
hppa_get_field (unsigned word, int from, int to)
{
  return ((word) >> (31 - (to)) & ((1 << ((to) - (from) + 1)) - 1));
}

/* Extract the immediate field from a ld{bhw}s instruction.  */

int
hppa_extract_5_load (unsigned word)
{
  return hppa_low_hppa_sign_extend (word >> 16 & MASK_5, 5);
}

/* Extract the immediate field from a break instruction.  */

unsigned
hppa_extract_5r_store (unsigned word)
{
  return (word & MASK_5);
}

/* Extract the immediate field from a {sr}sm instruction.  */

unsigned
hppa_extract_5R_store (unsigned word)
{
  return (word >> 16 & MASK_5);
}

/* Extract a 14 bit immediate field.  */

int
hppa_extract_14 (unsigned word)
{
  return hppa_low_hppa_sign_extend (word & MASK_14, 14);
}

/* Extract a 21 bit constant.  */

int
hppa_extract_21 (unsigned word)
{
  int val;

  word &= MASK_21;
  word <<= 11;
  val = hppa_get_field (word, 20, 20);
  val <<= 11;
  val |= hppa_get_field (word, 9, 19);
  val <<= 2;
  val |= hppa_get_field (word, 5, 6);
  val <<= 5;
  val |= hppa_get_field (word, 0, 4);
  val <<= 2;
  val |= hppa_get_field (word, 7, 8);
  return hppa_sign_extend (val, 21) << 11;
}

/* extract a 17 bit constant from branch instructions, returning the
   19 bit signed value.  */

int
hppa_extract_17 (unsigned word)
{
  return hppa_sign_extend (hppa_get_field (word, 19, 28) |
		      hppa_get_field (word, 29, 29) << 10 |
		      hppa_get_field (word, 11, 15) << 11 |
		      (word & 0x1) << 16, 17) << 2;
}

CORE_ADDR 
hppa_symbol_address(const char *sym)
{
  struct minimal_symbol *minsym;

  minsym = lookup_minimal_symbol (sym, NULL, NULL);
  if (minsym)
    return SYMBOL_VALUE_ADDRESS (minsym);
  else
    return (CORE_ADDR)-1;
}

struct hppa_objfile_private *
hppa_init_objfile_priv_data (struct objfile *objfile)
{
  struct hppa_objfile_private *priv;

  priv = (struct hppa_objfile_private *)
  	 obstack_alloc (&objfile->objfile_obstack,
	 		sizeof (struct hppa_objfile_private));
  set_objfile_data (objfile, hppa_objfile_priv_data, priv);
  memset (priv, 0, sizeof (*priv));

  return priv;
}


/* Compare the start address for two unwind entries returning 1 if 
   the first address is larger than the second, -1 if the second is
   larger than the first, and zero if they are equal.  */

static int
compare_unwind_entries (const void *arg1, const void *arg2)
{
  const struct unwind_table_entry *a = arg1;
  const struct unwind_table_entry *b = arg2;

  if (a->region_start > b->region_start)
    return 1;
  else if (a->region_start < b->region_start)
    return -1;
  else
    return 0;
}

static void
record_text_segment_lowaddr (bfd *abfd, asection *section, void *data)
{
  if ((section->flags & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
       == (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
    {
      bfd_vma value = section->vma - section->filepos;
      CORE_ADDR *low_text_segment_address = (CORE_ADDR *)data;

      if (value < *low_text_segment_address)
          *low_text_segment_address = value;
    }
}

static void
internalize_unwinds (struct objfile *objfile, struct unwind_table_entry *table,
		     asection *section, unsigned int entries,
		     unsigned int size, CORE_ADDR text_offset)
{
  /* We will read the unwind entries into temporary memory, then
     fill in the actual unwind table.  */

  if (size > 0)
    {
      struct gdbarch *gdbarch = get_objfile_arch (objfile);
      unsigned long tmp;
      unsigned i;
      char *buf = alloca (size);
      CORE_ADDR low_text_segment_address;

      /* For ELF targets, then unwinds are supposed to
	 be segment relative offsets instead of absolute addresses.

	 Note that when loading a shared library (text_offset != 0) the
	 unwinds are already relative to the text_offset that will be
	 passed in.  */
      if (gdbarch_tdep (gdbarch)->is_elf && text_offset == 0)
	{
          low_text_segment_address = -1;

	  bfd_map_over_sections (objfile->obfd,
				 record_text_segment_lowaddr, 
				 &low_text_segment_address);

	  text_offset = low_text_segment_address;
	}
      else if (gdbarch_tdep (gdbarch)->solib_get_text_base)
        {
	  text_offset = gdbarch_tdep (gdbarch)->solib_get_text_base (objfile);
	}

      bfd_get_section_contents (objfile->obfd, section, buf, 0, size);

      /* Now internalize the information being careful to handle host/target
         endian issues.  */
      for (i = 0; i < entries; i++)
	{
	  table[i].region_start = bfd_get_32 (objfile->obfd,
					      (bfd_byte *) buf);
	  table[i].region_start += text_offset;
	  buf += 4;
	  table[i].region_end = bfd_get_32 (objfile->obfd, (bfd_byte *) buf);
	  table[i].region_end += text_offset;
	  buf += 4;
	  tmp = bfd_get_32 (objfile->obfd, (bfd_byte *) buf);
	  buf += 4;
	  table[i].Cannot_unwind = (tmp >> 31) & 0x1;
	  table[i].Millicode = (tmp >> 30) & 0x1;
	  table[i].Millicode_save_sr0 = (tmp >> 29) & 0x1;
	  table[i].Region_description = (tmp >> 27) & 0x3;
	  table[i].reserved = (tmp >> 26) & 0x1;
	  table[i].Entry_SR = (tmp >> 25) & 0x1;
	  table[i].Entry_FR = (tmp >> 21) & 0xf;
	  table[i].Entry_GR = (tmp >> 16) & 0x1f;
	  table[i].Args_stored = (tmp >> 15) & 0x1;
	  table[i].Variable_Frame = (tmp >> 14) & 0x1;
	  table[i].Separate_Package_Body = (tmp >> 13) & 0x1;
	  table[i].Frame_Extension_Millicode = (tmp >> 12) & 0x1;
	  table[i].Stack_Overflow_Check = (tmp >> 11) & 0x1;
	  table[i].Two_Instruction_SP_Increment = (tmp >> 10) & 0x1;
	  table[i].sr4export = (tmp >> 9) & 0x1;
	  table[i].cxx_info = (tmp >> 8) & 0x1;
	  table[i].cxx_try_catch = (tmp >> 7) & 0x1;
	  table[i].sched_entry_seq = (tmp >> 6) & 0x1;
	  table[i].reserved1 = (tmp >> 5) & 0x1;
	  table[i].Save_SP = (tmp >> 4) & 0x1;
	  table[i].Save_RP = (tmp >> 3) & 0x1;
	  table[i].Save_MRP_in_frame = (tmp >> 2) & 0x1;
	  table[i].save_r19 = (tmp >> 1) & 0x1;
	  table[i].Cleanup_defined = tmp & 0x1;
	  tmp = bfd_get_32 (objfile->obfd, (bfd_byte *) buf);
	  buf += 4;
	  table[i].MPE_XL_interrupt_marker = (tmp >> 31) & 0x1;
	  table[i].HP_UX_interrupt_marker = (tmp >> 30) & 0x1;
	  table[i].Large_frame = (tmp >> 29) & 0x1;
	  table[i].alloca_frame = (tmp >> 28) & 0x1;
	  table[i].reserved2 = (tmp >> 27) & 0x1;
	  table[i].Total_frame_size = tmp & 0x7ffffff;

	  /* Stub unwinds are handled elsewhere.  */
	  table[i].stub_unwind.stub_type = 0;
	  table[i].stub_unwind.padding = 0;
	}
    }
}

/* Read in the backtrace information stored in the `$UNWIND_START$' section of
   the object file.  This info is used mainly by find_unwind_entry() to find
   out the stack frame size and frame pointer used by procedures.  We put
   everything on the psymbol obstack in the objfile so that it automatically
   gets freed when the objfile is destroyed.  */

static void
read_unwind_info (struct objfile *objfile)
{
  asection *unwind_sec, *stub_unwind_sec;
  unsigned unwind_size, stub_unwind_size, total_size;
  unsigned index, unwind_entries;
  unsigned stub_entries, total_entries;
  CORE_ADDR text_offset;
  struct hppa_unwind_info *ui;
  struct hppa_objfile_private *obj_private;

  text_offset = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
  ui = (struct hppa_unwind_info *) obstack_alloc (&objfile->objfile_obstack,
					   sizeof (struct hppa_unwind_info));

  ui->table = NULL;
  ui->cache = NULL;
  ui->last = -1;

  /* For reasons unknown the HP PA64 tools generate multiple unwinder
     sections in a single executable.  So we just iterate over every
     section in the BFD looking for unwinder sections intead of trying
     to do a lookup with bfd_get_section_by_name.

     First determine the total size of the unwind tables so that we
     can allocate memory in a nice big hunk.  */
  total_entries = 0;
  for (unwind_sec = objfile->obfd->sections;
       unwind_sec;
       unwind_sec = unwind_sec->next)
    {
      if (strcmp (unwind_sec->name, "$UNWIND_START$") == 0
	  || strcmp (unwind_sec->name, ".PARISC.unwind") == 0)
	{
	  unwind_size = bfd_section_size (objfile->obfd, unwind_sec);
	  unwind_entries = unwind_size / UNWIND_ENTRY_SIZE;

	  total_entries += unwind_entries;
	}
    }

  /* Now compute the size of the stub unwinds.  Note the ELF tools do not
     use stub unwinds at the current time.  */
  stub_unwind_sec = bfd_get_section_by_name (objfile->obfd, "$UNWIND_END$");

  if (stub_unwind_sec)
    {
      stub_unwind_size = bfd_section_size (objfile->obfd, stub_unwind_sec);
      stub_entries = stub_unwind_size / STUB_UNWIND_ENTRY_SIZE;
    }
  else
    {
      stub_unwind_size = 0;
      stub_entries = 0;
    }

  /* Compute total number of unwind entries and their total size.  */
  total_entries += stub_entries;
  total_size = total_entries * sizeof (struct unwind_table_entry);

  /* Allocate memory for the unwind table.  */
  ui->table = (struct unwind_table_entry *)
    obstack_alloc (&objfile->objfile_obstack, total_size);
  ui->last = total_entries - 1;

  /* Now read in each unwind section and internalize the standard unwind
     entries.  */
  index = 0;
  for (unwind_sec = objfile->obfd->sections;
       unwind_sec;
       unwind_sec = unwind_sec->next)
    {
      if (strcmp (unwind_sec->name, "$UNWIND_START$") == 0
	  || strcmp (unwind_sec->name, ".PARISC.unwind") == 0)
	{
	  unwind_size = bfd_section_size (objfile->obfd, unwind_sec);
	  unwind_entries = unwind_size / UNWIND_ENTRY_SIZE;

	  internalize_unwinds (objfile, &ui->table[index], unwind_sec,
			       unwind_entries, unwind_size, text_offset);
	  index += unwind_entries;
	}
    }

  /* Now read in and internalize the stub unwind entries.  */
  if (stub_unwind_size > 0)
    {
      unsigned int i;
      char *buf = alloca (stub_unwind_size);

      /* Read in the stub unwind entries.  */
      bfd_get_section_contents (objfile->obfd, stub_unwind_sec, buf,
				0, stub_unwind_size);

      /* Now convert them into regular unwind entries.  */
      for (i = 0; i < stub_entries; i++, index++)
	{
	  /* Clear out the next unwind entry.  */
	  memset (&ui->table[index], 0, sizeof (struct unwind_table_entry));

	  /* Convert offset & size into region_start and region_end.
	     Stuff away the stub type into "reserved" fields.  */
	  ui->table[index].region_start = bfd_get_32 (objfile->obfd,
						      (bfd_byte *) buf);
	  ui->table[index].region_start += text_offset;
	  buf += 4;
	  ui->table[index].stub_unwind.stub_type = bfd_get_8 (objfile->obfd,
							  (bfd_byte *) buf);
	  buf += 2;
	  ui->table[index].region_end
	    = ui->table[index].region_start + 4 *
	    (bfd_get_16 (objfile->obfd, (bfd_byte *) buf) - 1);
	  buf += 2;
	}

    }

  /* Unwind table needs to be kept sorted.  */
  qsort (ui->table, total_entries, sizeof (struct unwind_table_entry),
	 compare_unwind_entries);

  /* Keep a pointer to the unwind information.  */
  obj_private = (struct hppa_objfile_private *) 
	        objfile_data (objfile, hppa_objfile_priv_data);
  if (obj_private == NULL)
    obj_private = hppa_init_objfile_priv_data (objfile);

  obj_private->unwind_info = ui;
}

/* Lookup the unwind (stack backtrace) info for the given PC.  We search all
   of the objfiles seeking the unwind table entry for this PC.  Each objfile
   contains a sorted list of struct unwind_table_entry.  Since we do a binary
   search of the unwind tables, we depend upon them to be sorted.  */

struct unwind_table_entry *
find_unwind_entry (CORE_ADDR pc)
{
  int first, middle, last;
  struct objfile *objfile;
  struct hppa_objfile_private *priv;

  if (hppa_debug)
    fprintf_unfiltered (gdb_stdlog, "{ find_unwind_entry %s -> ",
		        hex_string (pc));

  /* A function at address 0?  Not in HP-UX!  */
  if (pc == (CORE_ADDR) 0)
    {
      if (hppa_debug)
	fprintf_unfiltered (gdb_stdlog, "NULL }\n");
      return NULL;
    }

  ALL_OBJFILES (objfile)
  {
    struct hppa_unwind_info *ui;
    ui = NULL;
    priv = objfile_data (objfile, hppa_objfile_priv_data);
    if (priv)
      ui = ((struct hppa_objfile_private *) priv)->unwind_info;

    if (!ui)
      {
	read_unwind_info (objfile);
        priv = objfile_data (objfile, hppa_objfile_priv_data);
	if (priv == NULL)
	  error (_("Internal error reading unwind information."));
        ui = ((struct hppa_objfile_private *) priv)->unwind_info;
      }

    /* First, check the cache.  */

    if (ui->cache
	&& pc >= ui->cache->region_start
	&& pc <= ui->cache->region_end)
      {
	if (hppa_debug)
	  fprintf_unfiltered (gdb_stdlog, "%s (cached) }\n",
            hex_string ((uintptr_t) ui->cache));
        return ui->cache;
      }

    /* Not in the cache, do a binary search.  */

    first = 0;
    last = ui->last;

    while (first <= last)
      {
	middle = (first + last) / 2;
	if (pc >= ui->table[middle].region_start
	    && pc <= ui->table[middle].region_end)
	  {
	    ui->cache = &ui->table[middle];
	    if (hppa_debug)
	      fprintf_unfiltered (gdb_stdlog, "%s }\n",
                hex_string ((uintptr_t) ui->cache));
	    return &ui->table[middle];
	  }

	if (pc < ui->table[middle].region_start)
	  last = middle - 1;
	else
	  first = middle + 1;
      }
  }				/* ALL_OBJFILES() */

  if (hppa_debug)
    fprintf_unfiltered (gdb_stdlog, "NULL (not found) }\n");

  return NULL;
}

/* The epilogue is defined here as the area either on the `bv' instruction 
   itself or an instruction which destroys the function's stack frame.
   
   We do not assume that the epilogue is at the end of a function as we can
   also have return sequences in the middle of a function.  */
static int
hppa_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  unsigned long status;
  unsigned int inst;
  gdb_byte buf[4];

  status = target_read_memory (pc, buf, 4);
  if (status != 0)
    return 0;

  inst = extract_unsigned_integer (buf, 4, byte_order);

  /* The most common way to perform a stack adjustment ldo X(sp),sp 
     We are destroying a stack frame if the offset is negative.  */
  if ((inst & 0xffffc000) == 0x37de0000
      && hppa_extract_14 (inst) < 0)
    return 1;

  /* ldw,mb D(sp),X or ldd,mb D(sp),X */
  if (((inst & 0x0fc010e0) == 0x0fc010e0 
       || (inst & 0x0fc010e0) == 0x0fc010e0)
      && hppa_extract_14 (inst) < 0)
    return 1;

  /* bv %r0(%rp) or bv,n %r0(%rp) */
  if (inst == 0xe840c000 || inst == 0xe840c002)
    return 1;

  return 0;
}

static const unsigned char *
hppa_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pc, int *len)
{
  static const unsigned char breakpoint[] = {0x00, 0x01, 0x00, 0x04};
  (*len) = sizeof (breakpoint);
  return breakpoint;
}

/* Return the name of a register.  */

static const char *
hppa32_register_name (struct gdbarch *gdbarch, int i)
{
  static char *names[] = {
    "flags",  "r1",      "rp",     "r3",
    "r4",     "r5",      "r6",     "r7",
    "r8",     "r9",      "r10",    "r11",
    "r12",    "r13",     "r14",    "r15",
    "r16",    "r17",     "r18",    "r19",
    "r20",    "r21",     "r22",    "r23",
    "r24",    "r25",     "r26",    "dp",
    "ret0",   "ret1",    "sp",     "r31",
    "sar",    "pcoqh",   "pcsqh",  "pcoqt",
    "pcsqt",  "eiem",    "iir",    "isr",
    "ior",    "ipsw",    "goto",   "sr4",
    "sr0",    "sr1",     "sr2",    "sr3",
    "sr5",    "sr6",     "sr7",    "cr0",
    "cr8",    "cr9",     "ccr",    "cr12",
    "cr13",   "cr24",    "cr25",   "cr26",
    "mpsfu_high","mpsfu_low","mpsfu_ovflo","pad",
    "fpsr",    "fpe1",   "fpe2",   "fpe3",
    "fpe4",   "fpe5",    "fpe6",   "fpe7",
    "fr4",     "fr4R",   "fr5",    "fr5R",
    "fr6",    "fr6R",    "fr7",    "fr7R",
    "fr8",     "fr8R",   "fr9",    "fr9R",
    "fr10",   "fr10R",   "fr11",   "fr11R",
    "fr12",    "fr12R",  "fr13",   "fr13R",
    "fr14",   "fr14R",   "fr15",   "fr15R",
    "fr16",    "fr16R",  "fr17",   "fr17R",
    "fr18",   "fr18R",   "fr19",   "fr19R",
    "fr20",    "fr20R",  "fr21",   "fr21R",
    "fr22",   "fr22R",   "fr23",   "fr23R",
    "fr24",    "fr24R",  "fr25",   "fr25R",
    "fr26",   "fr26R",   "fr27",   "fr27R",
    "fr28",    "fr28R",  "fr29",   "fr29R",
    "fr30",   "fr30R",   "fr31",   "fr31R"
  };
  if (i < 0 || i >= (sizeof (names) / sizeof (*names)))
    return NULL;
  else
    return names[i];
}

static const char *
hppa64_register_name (struct gdbarch *gdbarch, int i)
{
  static char *names[] = {
    "flags",  "r1",      "rp",     "r3",
    "r4",     "r5",      "r6",     "r7",
    "r8",     "r9",      "r10",    "r11",
    "r12",    "r13",     "r14",    "r15",
    "r16",    "r17",     "r18",    "r19",
    "r20",    "r21",     "r22",    "r23",
    "r24",    "r25",     "r26",    "dp",
    "ret0",   "ret1",    "sp",     "r31",
    "sar",    "pcoqh",   "pcsqh",  "pcoqt",
    "pcsqt",  "eiem",    "iir",    "isr",
    "ior",    "ipsw",    "goto",   "sr4",
    "sr0",    "sr1",     "sr2",    "sr3",
    "sr5",    "sr6",     "sr7",    "cr0",
    "cr8",    "cr9",     "ccr",    "cr12",
    "cr13",   "cr24",    "cr25",   "cr26",
    "mpsfu_high","mpsfu_low","mpsfu_ovflo","pad",
    "fpsr",    "fpe1",   "fpe2",   "fpe3",
    "fr4",    "fr5",     "fr6",    "fr7",
    "fr8",     "fr9",    "fr10",   "fr11",
    "fr12",   "fr13",    "fr14",   "fr15",
    "fr16",    "fr17",   "fr18",   "fr19",
    "fr20",   "fr21",    "fr22",   "fr23",
    "fr24",    "fr25",   "fr26",   "fr27",
    "fr28",  "fr29",    "fr30",   "fr31"
  };
  if (i < 0 || i >= (sizeof (names) / sizeof (*names)))
    return NULL;
  else
    return names[i];
}

/* Map dwarf DBX register numbers to GDB register numbers.  */
static int
hppa64_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int reg)
{
  /* The general registers and the sar are the same in both sets.  */
  if (reg <= 32)
    return reg;

  /* fr4-fr31 are mapped from 72 in steps of 2.  */
  if (reg >= 72 && reg < 72 + 28 * 2 && !(reg & 1))
    return HPPA64_FP4_REGNUM + (reg - 72) / 2;

  warning (_("Unmapped DWARF DBX Register #%d encountered."), reg);
  return -1;
}

/* This function pushes a stack frame with arguments as part of the
   inferior function calling mechanism.

   This is the version of the function for the 32-bit PA machines, in
   which later arguments appear at lower addresses.  (The stack always
   grows towards higher addresses.)

   We simply allocate the appropriate amount of stack space and put
   arguments into their proper slots.  */
   
static CORE_ADDR
hppa32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
			struct regcache *regcache, CORE_ADDR bp_addr,
			int nargs, struct value **args, CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  /* Stack base address at which any pass-by-reference parameters are
     stored.  */
  CORE_ADDR struct_end = 0;
  /* Stack base address at which the first parameter is stored.  */
  CORE_ADDR param_end = 0;

  /* The inner most end of the stack after all the parameters have
     been pushed.  */
  CORE_ADDR new_sp = 0;

  /* Two passes.  First pass computes the location of everything,
     second pass writes the bytes out.  */
  int write_pass;

  /* Global pointer (r19) of the function we are trying to call.  */
  CORE_ADDR gp;

  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  for (write_pass = 0; write_pass < 2; write_pass++)
    {
      CORE_ADDR struct_ptr = 0;
      /* The first parameter goes into sp-36, each stack slot is 4-bytes.
         struct_ptr is adjusted for each argument below, so the first
	 argument will end up at sp-36.  */
      CORE_ADDR param_ptr = 32;
      int i;
      int small_struct = 0;

      for (i = 0; i < nargs; i++)
	{
	  struct value *arg = args[i];
	  struct type *type = check_typedef (value_type (arg));
	  /* The corresponding parameter that is pushed onto the
	     stack, and [possibly] passed in a register.  */
	  gdb_byte param_val[8];
	  int param_len;
	  memset (param_val, 0, sizeof param_val);
	  if (TYPE_LENGTH (type) > 8)
	    {
	      /* Large parameter, pass by reference.  Store the value
		 in "struct" area and then pass its address.  */
	      param_len = 4;
	      struct_ptr += align_up (TYPE_LENGTH (type), 8);
	      if (write_pass)
		write_memory (struct_end - struct_ptr, value_contents (arg),
			      TYPE_LENGTH (type));
	      store_unsigned_integer (param_val, 4, byte_order,
				      struct_end - struct_ptr);
	    }
	  else if (TYPE_CODE (type) == TYPE_CODE_INT
		   || TYPE_CODE (type) == TYPE_CODE_ENUM)
	    {
	      /* Integer value store, right aligned.  "unpack_long"
		 takes care of any sign-extension problems.  */
	      param_len = align_up (TYPE_LENGTH (type), 4);
	      store_unsigned_integer (param_val, param_len, byte_order,
				      unpack_long (type,
						   value_contents (arg)));
	    }
	  else if (TYPE_CODE (type) == TYPE_CODE_FLT)
            {
	      /* Floating point value store, right aligned.  */
	      param_len = align_up (TYPE_LENGTH (type), 4);
	      memcpy (param_val, value_contents (arg), param_len);
            }
	  else
	    {
	      param_len = align_up (TYPE_LENGTH (type), 4);

	      /* Small struct value are stored right-aligned.  */
	      memcpy (param_val + param_len - TYPE_LENGTH (type),
		      value_contents (arg), TYPE_LENGTH (type));

	      /* Structures of size 5, 6 and 7 bytes are special in that
	         the higher-ordered word is stored in the lower-ordered
		 argument, and even though it is a 8-byte quantity the
		 registers need not be 8-byte aligned.  */
	      if (param_len > 4 && param_len < 8)
		small_struct = 1;
	    }

	  param_ptr += param_len;
	  if (param_len == 8 && !small_struct)
            param_ptr = align_up (param_ptr, 8);

	  /* First 4 non-FP arguments are passed in gr26-gr23.
	     First 4 32-bit FP arguments are passed in fr4L-fr7L.
	     First 2 64-bit FP arguments are passed in fr5 and fr7.

	     The rest go on the stack, starting at sp-36, towards lower
	     addresses.  8-byte arguments must be aligned to a 8-byte
	     stack boundary.  */
	  if (write_pass)
	    {
	      write_memory (param_end - param_ptr, param_val, param_len);

	      /* There are some cases when we don't know the type
		 expected by the callee (e.g. for variadic functions), so 
		 pass the parameters in both general and fp regs.  */
	      if (param_ptr <= 48)
		{
		  int grreg = 26 - (param_ptr - 36) / 4;
		  int fpLreg = 72 + (param_ptr - 36) / 4 * 2;
		  int fpreg = 74 + (param_ptr - 32) / 8 * 4;

		  regcache_cooked_write (regcache, grreg, param_val);
		  regcache_cooked_write (regcache, fpLreg, param_val);

		  if (param_len > 4)
		    {
		      regcache_cooked_write (regcache, grreg + 1, 
					     param_val + 4);

		      regcache_cooked_write (regcache, fpreg, param_val);
		      regcache_cooked_write (regcache, fpreg + 1, 
					     param_val + 4);
		    }
		}
	    }
	}

      /* Update the various stack pointers.  */
      if (!write_pass)
	{
	  struct_end = sp + align_up (struct_ptr, 64);
	  /* PARAM_PTR already accounts for all the arguments passed
	     by the user.  However, the ABI mandates minimum stack
	     space allocations for outgoing arguments.  The ABI also
	     mandates minimum stack alignments which we must
	     preserve.  */
	  param_end = struct_end + align_up (param_ptr, 64);
	}
    }

  /* If a structure has to be returned, set up register 28 to hold its
     address.  */
  if (struct_return)
    regcache_cooked_write_unsigned (regcache, 28, struct_addr);

  gp = tdep->find_global_pointer (gdbarch, function);

  if (gp != 0)
    regcache_cooked_write_unsigned (regcache, 19, gp);

  /* Set the return address.  */
  if (!gdbarch_push_dummy_code_p (gdbarch))
    regcache_cooked_write_unsigned (regcache, HPPA_RP_REGNUM, bp_addr);

  /* Update the Stack Pointer.  */
  regcache_cooked_write_unsigned (regcache, HPPA_SP_REGNUM, param_end);

  return param_end;
}

/* The 64-bit PA-RISC calling conventions are documented in "64-Bit
   Runtime Architecture for PA-RISC 2.0", which is distributed as part
   as of the HP-UX Software Transition Kit (STK).  This implementation
   is based on version 3.3, dated October 6, 1997.  */

/* Check whether TYPE is an "Integral or Pointer Scalar Type".  */

static int
hppa64_integral_or_pointer_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_RANGE:
      {
	int len = TYPE_LENGTH (type);
	return (len == 1 || len == 2 || len == 4 || len == 8);
      }
    case TYPE_CODE_PTR:
    case TYPE_CODE_REF:
      return (TYPE_LENGTH (type) == 8);
    default:
      break;
    }

  return 0;
}

/* Check whether TYPE is a "Floating Scalar Type".  */

static int
hppa64_floating_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_FLT:
      {
	int len = TYPE_LENGTH (type);
	return (len == 4 || len == 8 || len == 16);
      }
    default:
      break;
    }

  return 0;
}

/* If CODE points to a function entry address, try to look up the corresponding
   function descriptor and return its address instead.  If CODE is not a
   function entry address, then just return it unchanged.  */
static CORE_ADDR
hppa64_convert_code_addr_to_fptr (struct gdbarch *gdbarch, CORE_ADDR code)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct obj_section *sec, *opd;

  sec = find_pc_section (code);

  if (!sec)
    return code;

  /* If CODE is in a data section, assume it's already a fptr.  */
  if (!(sec->the_bfd_section->flags & SEC_CODE))
    return code;

  ALL_OBJFILE_OSECTIONS (sec->objfile, opd)
    {
      if (strcmp (opd->the_bfd_section->name, ".opd") == 0)
	break;
    }

  if (opd < sec->objfile->sections_end)
    {
      CORE_ADDR addr;

      for (addr = obj_section_addr (opd);
	   addr < obj_section_endaddr (opd);
	   addr += 2 * 8)
	{
	  ULONGEST opdaddr;
	  gdb_byte tmp[8];

	  if (target_read_memory (addr, tmp, sizeof (tmp)))
	      break;
	  opdaddr = extract_unsigned_integer (tmp, sizeof (tmp), byte_order);

	  if (opdaddr == code)
	    return addr - 16;
	}
    }

  return code;
}

static CORE_ADDR
hppa64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
			struct regcache *regcache, CORE_ADDR bp_addr,
			int nargs, struct value **args, CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_addr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int i, offset = 0;
  CORE_ADDR gp;

  /* "The outgoing parameter area [...] must be aligned at a 16-byte
     boundary."  */
  sp = align_up (sp, 16);

  for (i = 0; i < nargs; i++)
    {
      struct value *arg = args[i];
      struct type *type = value_type (arg);
      int len = TYPE_LENGTH (type);
      const bfd_byte *valbuf;
      bfd_byte fptrbuf[8];
      int regnum;

      /* "Each parameter begins on a 64-bit (8-byte) boundary."  */
      offset = align_up (offset, 8);

      if (hppa64_integral_or_pointer_p (type))
	{
	  /* "Integral scalar parameters smaller than 64 bits are
             padded on the left (i.e., the value is in the
             least-significant bits of the 64-bit storage unit, and
             the high-order bits are undefined)."  Therefore we can
             safely sign-extend them.  */
	  if (len < 8)
	    {
	      arg = value_cast (builtin_type (gdbarch)->builtin_int64, arg);
	      len = 8;
	    }
	}
      else if (hppa64_floating_p (type))
	{
	  if (len > 8)
	    {
	      /* "Quad-precision (128-bit) floating-point scalar
		 parameters are aligned on a 16-byte boundary."  */
	      offset = align_up (offset, 16);

	      /* "Double-extended- and quad-precision floating-point
                 parameters within the first 64 bytes of the parameter
                 list are always passed in general registers."  */
	    }
	  else
	    {
	      if (len == 4)
		{
		  /* "Single-precision (32-bit) floating-point scalar
		     parameters are padded on the left with 32 bits of
		     garbage (i.e., the floating-point value is in the
		     least-significant 32 bits of a 64-bit storage
		     unit)."  */
		  offset += 4;
		}

	      /* "Single- and double-precision floating-point
                 parameters in this area are passed according to the
                 available formal parameter information in a function
                 prototype.  [...]  If no prototype is in scope,
                 floating-point parameters must be passed both in the
                 corresponding general registers and in the
                 corresponding floating-point registers."  */
	      regnum = HPPA64_FP4_REGNUM + offset / 8;

	      if (regnum < HPPA64_FP4_REGNUM + 8)
		{
		  /* "Single-precision floating-point parameters, when
		     passed in floating-point registers, are passed in
		     the right halves of the floating point registers;
		     the left halves are unused."  */
		  regcache_cooked_write_part (regcache, regnum, offset % 8,
					      len, value_contents (arg));
		}
	    }
	}
      else
	{
	  if (len > 8)
	    {
	      /* "Aggregates larger than 8 bytes are aligned on a
		 16-byte boundary, possibly leaving an unused argument
		 slot, which is filled with garbage.  If necessary,
		 they are padded on the right (with garbage), to a
		 multiple of 8 bytes."  */
	      offset = align_up (offset, 16);
	    }
	}

      /* If we are passing a function pointer, make sure we pass a function
         descriptor instead of the function entry address.  */
      if (TYPE_CODE (type) == TYPE_CODE_PTR
          && TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC)
        {
	  ULONGEST codeptr, fptr;

	  codeptr = unpack_long (type, value_contents (arg));
	  fptr = hppa64_convert_code_addr_to_fptr (gdbarch, codeptr);
	  store_unsigned_integer (fptrbuf, TYPE_LENGTH (type), byte_order,
				  fptr);
	  valbuf = fptrbuf;
	}
      else
        {
          valbuf = value_contents (arg);
	}

      /* Always store the argument in memory.  */
      write_memory (sp + offset, valbuf, len);

      regnum = HPPA_ARG0_REGNUM - offset / 8;
      while (regnum > HPPA_ARG0_REGNUM - 8 && len > 0)
	{
	  regcache_cooked_write_part (regcache, regnum,
				      offset % 8, min (len, 8), valbuf);
	  offset += min (len, 8);
	  valbuf += min (len, 8);
	  len -= min (len, 8);
	  regnum--;
	}

      offset += len;
    }

  /* Set up GR29 (%ret1) to hold the argument pointer (ap).  */
  regcache_cooked_write_unsigned (regcache, HPPA_RET1_REGNUM, sp + 64);

  /* Allocate the outgoing parameter area.  Make sure the outgoing
     parameter area is multiple of 16 bytes in length.  */
  sp += max (align_up (offset, 16), 64);

  /* Allocate 32-bytes of scratch space.  The documentation doesn't
     mention this, but it seems to be needed.  */
  sp += 32;

  /* Allocate the frame marker area.  */
  sp += 16;

  /* If a structure has to be returned, set up GR 28 (%ret0) to hold
     its address.  */
  if (struct_return)
    regcache_cooked_write_unsigned (regcache, HPPA_RET0_REGNUM, struct_addr);

  /* Set up GR27 (%dp) to hold the global pointer (gp).  */
  gp = tdep->find_global_pointer (gdbarch, function);
  if (gp != 0)
    regcache_cooked_write_unsigned (regcache, HPPA_DP_REGNUM, gp);

  /* Set up GR2 (%rp) to hold the return pointer (rp).  */
  if (!gdbarch_push_dummy_code_p (gdbarch))
    regcache_cooked_write_unsigned (regcache, HPPA_RP_REGNUM, bp_addr);

  /* Set up GR30 to hold the stack pointer (sp).  */
  regcache_cooked_write_unsigned (regcache, HPPA_SP_REGNUM, sp);

  return sp;
}


/* Handle 32/64-bit struct return conventions.  */

static enum return_value_convention
hppa32_return_value (struct gdbarch *gdbarch, struct value *function,
		     struct type *type, struct regcache *regcache,
		     gdb_byte *readbuf, const gdb_byte *writebuf)
{
  if (TYPE_LENGTH (type) <= 2 * 4)
    {
      /* The value always lives in the right hand end of the register
	 (or register pair)?  */
      int b;
      int reg = TYPE_CODE (type) == TYPE_CODE_FLT ? HPPA_FP4_REGNUM : 28;
      int part = TYPE_LENGTH (type) % 4;
      /* The left hand register contains only part of the value,
	 transfer that first so that the rest can be xfered as entire
	 4-byte registers.  */
      if (part > 0)
	{
	  if (readbuf != NULL)
	    regcache_cooked_read_part (regcache, reg, 4 - part,
				       part, readbuf);
	  if (writebuf != NULL)
	    regcache_cooked_write_part (regcache, reg, 4 - part,
					part, writebuf);
	  reg++;
	}
      /* Now transfer the remaining register values.  */
      for (b = part; b < TYPE_LENGTH (type); b += 4)
	{
	  if (readbuf != NULL)
	    regcache_cooked_read (regcache, reg, readbuf + b);
	  if (writebuf != NULL)
	    regcache_cooked_write (regcache, reg, writebuf + b);
	  reg++;
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else
    return RETURN_VALUE_STRUCT_CONVENTION;
}

static enum return_value_convention
hppa64_return_value (struct gdbarch *gdbarch, struct value *function,
		     struct type *type, struct regcache *regcache,
		     gdb_byte *readbuf, const gdb_byte *writebuf)
{
  int len = TYPE_LENGTH (type);
  int regnum, offset;

  if (len > 16)
    {
      /* All return values larget than 128 bits must be aggregate
         return values.  */
      gdb_assert (!hppa64_integral_or_pointer_p (type));
      gdb_assert (!hppa64_floating_p (type));

      /* "Aggregate return values larger than 128 bits are returned in
	 a buffer allocated by the caller.  The address of the buffer
	 must be passed in GR 28."  */
      return RETURN_VALUE_STRUCT_CONVENTION;
    }

  if (hppa64_integral_or_pointer_p (type))
    {
      /* "Integral return values are returned in GR 28.  Values
         smaller than 64 bits are padded on the left (with garbage)."  */
      regnum = HPPA_RET0_REGNUM;
      offset = 8 - len;
    }
  else if (hppa64_floating_p (type))
    {
      if (len > 8)
	{
	  /* "Double-extended- and quad-precision floating-point
	     values are returned in GRs 28 and 29.  The sign,
	     exponent, and most-significant bits of the mantissa are
	     returned in GR 28; the least-significant bits of the
	     mantissa are passed in GR 29.  For double-extended
	     precision values, GR 29 is padded on the right with 48
	     bits of garbage."  */
	  regnum = HPPA_RET0_REGNUM;
	  offset = 0;
	}
      else
	{
	  /* "Single-precision and double-precision floating-point
	     return values are returned in FR 4R (single precision) or
	     FR 4 (double-precision)."  */
	  regnum = HPPA64_FP4_REGNUM;
	  offset = 8 - len;
	}
    }
  else
    {
      /* "Aggregate return values up to 64 bits in size are returned
         in GR 28.  Aggregates smaller than 64 bits are left aligned
         in the register; the pad bits on the right are undefined."

	 "Aggregate return values between 65 and 128 bits are returned
	 in GRs 28 and 29.  The first 64 bits are placed in GR 28, and
	 the remaining bits are placed, left aligned, in GR 29.  The
	 pad bits on the right of GR 29 (if any) are undefined."  */
      regnum = HPPA_RET0_REGNUM;
      offset = 0;
    }

  if (readbuf)
    {
      while (len > 0)
	{
	  regcache_cooked_read_part (regcache, regnum, offset,
				     min (len, 8), readbuf);
	  readbuf += min (len, 8);
	  len -= min (len, 8);
	  regnum++;
	}
    }

  if (writebuf)
    {
      while (len > 0)
	{
	  regcache_cooked_write_part (regcache, regnum, offset,
				      min (len, 8), writebuf);
	  writebuf += min (len, 8);
	  len -= min (len, 8);
	  regnum++;
	}
    }

  return RETURN_VALUE_REGISTER_CONVENTION;
}


static CORE_ADDR
hppa32_convert_from_func_ptr_addr (struct gdbarch *gdbarch, CORE_ADDR addr,
				   struct target_ops *targ)
{
  if (addr & 2)
    {
      struct type *func_ptr_type = builtin_type (gdbarch)->builtin_func_ptr;
      CORE_ADDR plabel = addr & ~3;
      return read_memory_typed_address (plabel, func_ptr_type);
    }

  return addr;
}

static CORE_ADDR
hppa32_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  /* HP frames are 64-byte (or cache line) aligned (yes that's _byte_
     and not _bit_)!  */
  return align_up (addr, 64);
}

/* Force all frames to 16-byte alignment.  Better safe than sorry.  */

static CORE_ADDR
hppa64_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  /* Just always 16-byte align.  */
  return align_up (addr, 16);
}

CORE_ADDR
hppa_read_pc (struct regcache *regcache)
{
  ULONGEST ipsw;
  ULONGEST pc;

  regcache_cooked_read_unsigned (regcache, HPPA_IPSW_REGNUM, &ipsw);
  regcache_cooked_read_unsigned (regcache, HPPA_PCOQ_HEAD_REGNUM, &pc);

  /* If the current instruction is nullified, then we are effectively
     still executing the previous instruction.  Pretend we are still
     there.  This is needed when single stepping; if the nullified
     instruction is on a different line, we don't want GDB to think
     we've stepped onto that line.  */
  if (ipsw & 0x00200000)
    pc -= 4;

  return pc & ~0x3;
}

void
hppa_write_pc (struct regcache *regcache, CORE_ADDR pc)
{
  regcache_cooked_write_unsigned (regcache, HPPA_PCOQ_HEAD_REGNUM, pc);
  regcache_cooked_write_unsigned (regcache, HPPA_PCOQ_TAIL_REGNUM, pc + 4);
}

/* For the given instruction (INST), return any adjustment it makes
   to the stack pointer or zero for no adjustment.

   This only handles instructions commonly found in prologues.  */

static int
prologue_inst_adjust_sp (unsigned long inst)
{
  /* This must persist across calls.  */
  static int save_high21;

  /* The most common way to perform a stack adjustment ldo X(sp),sp */
  if ((inst & 0xffffc000) == 0x37de0000)
    return hppa_extract_14 (inst);

  /* stwm X,D(sp) */
  if ((inst & 0xffe00000) == 0x6fc00000)
    return hppa_extract_14 (inst);

  /* std,ma X,D(sp) */
  if ((inst & 0xffe00008) == 0x73c00008)
    return (inst & 0x1 ? -1 << 13 : 0) | (((inst >> 4) & 0x3ff) << 3);

  /* addil high21,%r30; ldo low11,(%r1),%r30)
     save high bits in save_high21 for later use.  */
  if ((inst & 0xffe00000) == 0x2bc00000)
    {
      save_high21 = hppa_extract_21 (inst);
      return 0;
    }

  if ((inst & 0xffff0000) == 0x343e0000)
    return save_high21 + hppa_extract_14 (inst);

  /* fstws as used by the HP compilers.  */
  if ((inst & 0xffffffe0) == 0x2fd01220)
    return hppa_extract_5_load (inst);

  /* No adjustment.  */
  return 0;
}

/* Return nonzero if INST is a branch of some kind, else return zero.  */

static int
is_branch (unsigned long inst)
{
  switch (inst >> 26)
    {
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x23:
    case 0x27:
    case 0x28:
    case 0x29:
    case 0x2a:
    case 0x2b:
    case 0x2f:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x38:
    case 0x39:
    case 0x3a:
    case 0x3b:
      return 1;

    default:
      return 0;
    }
}

/* Return the register number for a GR which is saved by INST or
   zero it INST does not save a GR.  */

static int
inst_saves_gr (unsigned long inst)
{
  /* Does it look like a stw?  */
  if ((inst >> 26) == 0x1a || (inst >> 26) == 0x1b
      || (inst >> 26) == 0x1f
      || ((inst >> 26) == 0x1f
	  && ((inst >> 6) == 0xa)))
    return hppa_extract_5R_store (inst);

  /* Does it look like a std?  */
  if ((inst >> 26) == 0x1c
      || ((inst >> 26) == 0x03
	  && ((inst >> 6) & 0xf) == 0xb))
    return hppa_extract_5R_store (inst);

  /* Does it look like a stwm?  GCC & HPC may use this in prologues.  */
  if ((inst >> 26) == 0x1b)
    return hppa_extract_5R_store (inst);

  /* Does it look like sth or stb?  HPC versions 9.0 and later use these
     too.  */
  if ((inst >> 26) == 0x19 || (inst >> 26) == 0x18
      || ((inst >> 26) == 0x3
	  && (((inst >> 6) & 0xf) == 0x8
	      || (inst >> 6) & 0xf) == 0x9))
    return hppa_extract_5R_store (inst);

  return 0;
}

/* Return the register number for a FR which is saved by INST or
   zero it INST does not save a FR.

   Note we only care about full 64bit register stores (that's the only
   kind of stores the prologue will use).

   FIXME: What about argument stores with the HP compiler in ANSI mode? */

static int
inst_saves_fr (unsigned long inst)
{
  /* Is this an FSTD?  */
  if ((inst & 0xfc00dfc0) == 0x2c001200)
    return hppa_extract_5r_store (inst);
  if ((inst & 0xfc000002) == 0x70000002)
    return hppa_extract_5R_store (inst);
  /* Is this an FSTW?  */
  if ((inst & 0xfc00df80) == 0x24001200)
    return hppa_extract_5r_store (inst);
  if ((inst & 0xfc000002) == 0x7c000000)
    return hppa_extract_5R_store (inst);
  return 0;
}

/* Advance PC across any function entry prologue instructions
   to reach some "real" code.

   Use information in the unwind table to determine what exactly should
   be in the prologue.  */


static CORE_ADDR
skip_prologue_hard_way (struct gdbarch *gdbarch, CORE_ADDR pc,
			int stop_before_branch)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[4];
  CORE_ADDR orig_pc = pc;
  unsigned long inst, stack_remaining, save_gr, save_fr, save_rp, save_sp;
  unsigned long args_stored, status, i, restart_gr, restart_fr;
  struct unwind_table_entry *u;
  int final_iteration;

  restart_gr = 0;
  restart_fr = 0;

restart:
  u = find_unwind_entry (pc);
  if (!u)
    return pc;

  /* If we are not at the beginning of a function, then return now.  */
  if ((pc & ~0x3) != u->region_start)
    return pc;

  /* This is how much of a frame adjustment we need to account for.  */
  stack_remaining = u->Total_frame_size << 3;

  /* Magic register saves we want to know about.  */
  save_rp = u->Save_RP;
  save_sp = u->Save_SP;

  /* An indication that args may be stored into the stack.  Unfortunately
     the HPUX compilers tend to set this in cases where no args were
     stored too!.  */
  args_stored = 1;

  /* Turn the Entry_GR field into a bitmask.  */
  save_gr = 0;
  for (i = 3; i < u->Entry_GR + 3; i++)
    {
      /* Frame pointer gets saved into a special location.  */
      if (u->Save_SP && i == HPPA_FP_REGNUM)
	continue;

      save_gr |= (1 << i);
    }
  save_gr &= ~restart_gr;

  /* Turn the Entry_FR field into a bitmask too.  */
  save_fr = 0;
  for (i = 12; i < u->Entry_FR + 12; i++)
    save_fr |= (1 << i);
  save_fr &= ~restart_fr;

  final_iteration = 0;

  /* Loop until we find everything of interest or hit a branch.

     For unoptimized GCC code and for any HP CC code this will never ever
     examine any user instructions.

     For optimzied GCC code we're faced with problems.  GCC will schedule
     its prologue and make prologue instructions available for delay slot
     filling.  The end result is user code gets mixed in with the prologue
     and a prologue instruction may be in the delay slot of the first branch
     or call.

     Some unexpected things are expected with debugging optimized code, so
     we allow this routine to walk past user instructions in optimized
     GCC code.  */
  while (save_gr || save_fr || save_rp || save_sp || stack_remaining > 0
	 || args_stored)
    {
      unsigned int reg_num;
      unsigned long old_stack_remaining, old_save_gr, old_save_fr;
      unsigned long old_save_rp, old_save_sp, next_inst;

      /* Save copies of all the triggers so we can compare them later
         (only for HPC).  */
      old_save_gr = save_gr;
      old_save_fr = save_fr;
      old_save_rp = save_rp;
      old_save_sp = save_sp;
      old_stack_remaining = stack_remaining;

      status = target_read_memory (pc, buf, 4);
      inst = extract_unsigned_integer (buf, 4, byte_order);

      /* Yow! */
      if (status != 0)
	return pc;

      /* Note the interesting effects of this instruction.  */
      stack_remaining -= prologue_inst_adjust_sp (inst);

      /* There are limited ways to store the return pointer into the
	 stack.  */
      if (inst == 0x6bc23fd9 || inst == 0x0fc212c1 || inst == 0x73c23fe1)
	save_rp = 0;

      /* These are the only ways we save SP into the stack.  At this time
         the HP compilers never bother to save SP into the stack.  */
      if ((inst & 0xffffc000) == 0x6fc10000
	  || (inst & 0xffffc00c) == 0x73c10008)
	save_sp = 0;

      /* Are we loading some register with an offset from the argument
         pointer?  */
      if ((inst & 0xffe00000) == 0x37a00000
	  || (inst & 0xffffffe0) == 0x081d0240)
	{
	  pc += 4;
	  continue;
	}

      /* Account for general and floating-point register saves.  */
      reg_num = inst_saves_gr (inst);
      save_gr &= ~(1 << reg_num);

      /* Ugh.  Also account for argument stores into the stack.
         Unfortunately args_stored only tells us that some arguments
         where stored into the stack.  Not how many or what kind!

         This is a kludge as on the HP compiler sets this bit and it
         never does prologue scheduling.  So once we see one, skip past
         all of them.   We have similar code for the fp arg stores below.

         FIXME.  Can still die if we have a mix of GR and FR argument
         stores!  */
      if (reg_num >= (gdbarch_ptr_bit (gdbarch) == 64 ? 19 : 23)
	  && reg_num <= 26)
	{
	  while (reg_num >= (gdbarch_ptr_bit (gdbarch) == 64 ? 19 : 23)
		 && reg_num <= 26)
	    {
	      pc += 4;
	      status = target_read_memory (pc, buf, 4);
	      inst = extract_unsigned_integer (buf, 4, byte_order);
	      if (status != 0)
		return pc;
	      reg_num = inst_saves_gr (inst);
	    }
	  args_stored = 0;
	  continue;
	}

      reg_num = inst_saves_fr (inst);
      save_fr &= ~(1 << reg_num);

      status = target_read_memory (pc + 4, buf, 4);
      next_inst = extract_unsigned_integer (buf, 4, byte_order);

      /* Yow! */
      if (status != 0)
	return pc;

      /* We've got to be read to handle the ldo before the fp register
         save.  */
      if ((inst & 0xfc000000) == 0x34000000
	  && inst_saves_fr (next_inst) >= 4
	  && inst_saves_fr (next_inst)
	       <= (gdbarch_ptr_bit (gdbarch) == 64 ? 11 : 7))
	{
	  /* So we drop into the code below in a reasonable state.  */
	  reg_num = inst_saves_fr (next_inst);
	  pc -= 4;
	}

      /* Ugh.  Also account for argument stores into the stack.
         This is a kludge as on the HP compiler sets this bit and it
         never does prologue scheduling.  So once we see one, skip past
         all of them.  */
      if (reg_num >= 4
	  && reg_num <= (gdbarch_ptr_bit (gdbarch) == 64 ? 11 : 7))
	{
	  while (reg_num >= 4
		 && reg_num
		      <= (gdbarch_ptr_bit (gdbarch) == 64 ? 11 : 7))
	    {
	      pc += 8;
	      status = target_read_memory (pc, buf, 4);
	      inst = extract_unsigned_integer (buf, 4, byte_order);
	      if (status != 0)
		return pc;
	      if ((inst & 0xfc000000) != 0x34000000)
		break;
	      status = target_read_memory (pc + 4, buf, 4);
	      next_inst = extract_unsigned_integer (buf, 4, byte_order);
	      if (status != 0)
		return pc;
	      reg_num = inst_saves_fr (next_inst);
	    }
	  args_stored = 0;
	  continue;
	}

      /* Quit if we hit any kind of branch.  This can happen if a prologue
         instruction is in the delay slot of the first call/branch.  */
      if (is_branch (inst) && stop_before_branch)
	break;

      /* What a crock.  The HP compilers set args_stored even if no
         arguments were stored into the stack (boo hiss).  This could
         cause this code to then skip a bunch of user insns (up to the
         first branch).

         To combat this we try to identify when args_stored was bogusly
         set and clear it.   We only do this when args_stored is nonzero,
         all other resources are accounted for, and nothing changed on
         this pass.  */
      if (args_stored
       && !(save_gr || save_fr || save_rp || save_sp || stack_remaining > 0)
	  && old_save_gr == save_gr && old_save_fr == save_fr
	  && old_save_rp == save_rp && old_save_sp == save_sp
	  && old_stack_remaining == stack_remaining)
	break;

      /* Bump the PC.  */
      pc += 4;

      /* !stop_before_branch, so also look at the insn in the delay slot 
         of the branch.  */
      if (final_iteration)
	break;
      if (is_branch (inst))
	final_iteration = 1;
    }

  /* We've got a tenative location for the end of the prologue.  However
     because of limitations in the unwind descriptor mechanism we may
     have went too far into user code looking for the save of a register
     that does not exist.  So, if there registers we expected to be saved
     but never were, mask them out and restart.

     This should only happen in optimized code, and should be very rare.  */
  if (save_gr || (save_fr && !(restart_fr || restart_gr)))
    {
      pc = orig_pc;
      restart_gr = save_gr;
      restart_fr = save_fr;
      goto restart;
    }

  return pc;
}


/* Return the address of the PC after the last prologue instruction if
   we can determine it from the debug symbols.  Else return zero.  */

static CORE_ADDR
after_prologue (CORE_ADDR pc)
{
  struct symtab_and_line sal;
  CORE_ADDR func_addr, func_end;

  /* If we can not find the symbol in the partial symbol table, then
     there is no hope we can determine the function's start address
     with this code.  */
  if (!find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    return 0;

  /* Get the line associated with FUNC_ADDR.  */
  sal = find_pc_line (func_addr, 0);

  /* There are only two cases to consider.  First, the end of the source line
     is within the function bounds.  In that case we return the end of the
     source line.  Second is the end of the source line extends beyond the
     bounds of the current function.  We need to use the slow code to
     examine instructions in that case.

     Anything else is simply a bug elsewhere.  Fixing it here is absolutely
     the wrong thing to do.  In fact, it should be entirely possible for this
     function to always return zero since the slow instruction scanning code
     is supposed to *always* work.  If it does not, then it is a bug.  */
  if (sal.end < func_end)
    return sal.end;
  else
    return 0;
}

/* To skip prologues, I use this predicate.  Returns either PC itself
   if the code at PC does not look like a function prologue; otherwise
   returns an address that (if we're lucky) follows the prologue.
   
   hppa_skip_prologue is called by gdb to place a breakpoint in a function.
   It doesn't necessarily skips all the insns in the prologue.  In fact
   we might not want to skip all the insns because a prologue insn may
   appear in the delay slot of the first branch, and we don't want to
   skip over the branch in that case.  */

static CORE_ADDR
hppa_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  CORE_ADDR post_prologue_pc;

  /* See if we can determine the end of the prologue via the symbol table.
     If so, then return either PC, or the PC after the prologue, whichever
     is greater.  */

  post_prologue_pc = after_prologue (pc);

  /* If after_prologue returned a useful address, then use it.  Else
     fall back on the instruction skipping code.

     Some folks have claimed this causes problems because the breakpoint
     may be the first instruction of the prologue.  If that happens, then
     the instruction skipping code has a bug that needs to be fixed.  */
  if (post_prologue_pc != 0)
    return max (pc, post_prologue_pc);
  else
    return (skip_prologue_hard_way (gdbarch, pc, 1));
}

/* Return an unwind entry that falls within the frame's code block.  */

static struct unwind_table_entry *
hppa_find_unwind_entry_in_block (struct frame_info *this_frame)
{
  CORE_ADDR pc = get_frame_address_in_block (this_frame);

  /* FIXME drow/20070101: Calling gdbarch_addr_bits_remove on the
     result of get_frame_address_in_block implies a problem.
     The bits should have been removed earlier, before the return
     value of gdbarch_unwind_pc.  That might be happening already;
     if it isn't, it should be fixed.  Then this call can be
     removed.  */
  pc = gdbarch_addr_bits_remove (get_frame_arch (this_frame), pc);
  return find_unwind_entry (pc);
}

struct hppa_frame_cache
{
  CORE_ADDR base;
  struct trad_frame_saved_reg *saved_regs;
};

static struct hppa_frame_cache *
hppa_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int word_size = gdbarch_ptr_bit (gdbarch) / 8;
  struct hppa_frame_cache *cache;
  long saved_gr_mask;
  long saved_fr_mask;
  long frame_size;
  struct unwind_table_entry *u;
  CORE_ADDR prologue_end;
  int fp_in_r1 = 0;
  int i;

  if (hppa_debug)
    fprintf_unfiltered (gdb_stdlog, "{ hppa_frame_cache (frame=%d) -> ",
      frame_relative_level(this_frame));

  if ((*this_cache) != NULL)
    {
      if (hppa_debug)
        fprintf_unfiltered (gdb_stdlog, "base=%s (cached) }",
          paddress (gdbarch, ((struct hppa_frame_cache *)*this_cache)->base));
      return (*this_cache);
    }
  cache = FRAME_OBSTACK_ZALLOC (struct hppa_frame_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  /* Yow! */
  u = hppa_find_unwind_entry_in_block (this_frame);
  if (!u)
    {
      if (hppa_debug)
        fprintf_unfiltered (gdb_stdlog, "base=NULL (no unwind entry) }");
      return (*this_cache);
    }

  /* Turn the Entry_GR field into a bitmask.  */
  saved_gr_mask = 0;
  for (i = 3; i < u->Entry_GR + 3; i++)
    {
      /* Frame pointer gets saved into a special location.  */
      if (u->Save_SP && i == HPPA_FP_REGNUM)
	continue;
	
      saved_gr_mask |= (1 << i);
    }

  /* Turn the Entry_FR field into a bitmask too.  */
  saved_fr_mask = 0;
  for (i = 12; i < u->Entry_FR + 12; i++)
    saved_fr_mask |= (1 << i);

  /* Loop until we find everything of interest or hit a branch.

     For unoptimized GCC code and for any HP CC code this will never ever
     examine any user instructions.

     For optimized GCC code we're faced with problems.  GCC will schedule
     its prologue and make prologue instructions available for delay slot
     filling.  The end result is user code gets mixed in with the prologue
     and a prologue instruction may be in the delay slot of the first branch
     or call.

     Some unexpected things are expected with debugging optimized code, so
     we allow this routine to walk past user instructions in optimized
     GCC code.  */
  {
    int final_iteration = 0;
    CORE_ADDR pc, start_pc, end_pc;
    int looking_for_sp = u->Save_SP;
    int looking_for_rp = u->Save_RP;
    int fp_loc = -1;

    /* We have to use skip_prologue_hard_way instead of just 
       skip_prologue_using_sal, in case we stepped into a function without
       symbol information.  hppa_skip_prologue also bounds the returned
       pc by the passed in pc, so it will not return a pc in the next
       function.
       
       We used to call hppa_skip_prologue to find the end of the prologue,
       but if some non-prologue instructions get scheduled into the prologue,
       and the program is compiled with debug information, the "easy" way
       in hppa_skip_prologue will return a prologue end that is too early
       for us to notice any potential frame adjustments.  */

    /* We used to use get_frame_func to locate the beginning of the
       function to pass to skip_prologue.  However, when objects are
       compiled without debug symbols, get_frame_func can return the wrong
       function (or 0).  We can do better than that by using unwind records.
       This only works if the Region_description of the unwind record
       indicates that it includes the entry point of the function.
       HP compilers sometimes generate unwind records for regions that
       do not include the entry or exit point of a function.  GNU tools
       do not do this.  */

    if ((u->Region_description & 0x2) == 0)
      start_pc = u->region_start;
    else
      start_pc = get_frame_func (this_frame);

    prologue_end = skip_prologue_hard_way (gdbarch, start_pc, 0);
    end_pc = get_frame_pc (this_frame);

    if (prologue_end != 0 && end_pc > prologue_end)
      end_pc = prologue_end;

    frame_size = 0;

    for (pc = start_pc;
	 ((saved_gr_mask || saved_fr_mask
	   || looking_for_sp || looking_for_rp
	   || frame_size < (u->Total_frame_size << 3))
	  && pc < end_pc);
	 pc += 4)
      {
	int reg;
	gdb_byte buf4[4];
	long inst;

	if (!safe_frame_unwind_memory (this_frame, pc, buf4, sizeof buf4)) 
	  {
	    error (_("Cannot read instruction at %s."),
		   paddress (gdbarch, pc));
	    return (*this_cache);
	  }

	inst = extract_unsigned_integer (buf4, sizeof buf4, byte_order);

	/* Note the interesting effects of this instruction.  */
	frame_size += prologue_inst_adjust_sp (inst);
	
	/* There are limited ways to store the return pointer into the
	   stack.  */
	if (inst == 0x6bc23fd9) /* stw rp,-0x14(sr0,sp) */
	  {
	    looking_for_rp = 0;
	    cache->saved_regs[HPPA_RP_REGNUM].addr = -20;
	  }
	else if (inst == 0x6bc23fd1) /* stw rp,-0x18(sr0,sp) */
	  {
	    looking_for_rp = 0;
	    cache->saved_regs[HPPA_RP_REGNUM].addr = -24;
	  }
	else if (inst == 0x0fc212c1 
	         || inst == 0x73c23fe1) /* std rp,-0x10(sr0,sp) */
	  {
	    looking_for_rp = 0;
	    cache->saved_regs[HPPA_RP_REGNUM].addr = -16;
	  }
	
	/* Check to see if we saved SP into the stack.  This also
	   happens to indicate the location of the saved frame
	   pointer.  */
	if ((inst & 0xffffc000) == 0x6fc10000  /* stw,ma r1,N(sr0,sp) */
	    || (inst & 0xffffc00c) == 0x73c10008) /* std,ma r1,N(sr0,sp) */
	  {
	    looking_for_sp = 0;
	    cache->saved_regs[HPPA_FP_REGNUM].addr = 0;
	  }
	else if (inst == 0x08030241) /* copy %r3, %r1 */
	  {
	    fp_in_r1 = 1;
	  }
	
	/* Account for general and floating-point register saves.  */
	reg = inst_saves_gr (inst);
	if (reg >= 3 && reg <= 18
	    && (!u->Save_SP || reg != HPPA_FP_REGNUM))
	  {
	    saved_gr_mask &= ~(1 << reg);
	    if ((inst >> 26) == 0x1b && hppa_extract_14 (inst) >= 0)
	      /* stwm with a positive displacement is a _post_
		 _modify_.  */
	      cache->saved_regs[reg].addr = 0;
	    else if ((inst & 0xfc00000c) == 0x70000008)
	      /* A std has explicit post_modify forms.  */
	      cache->saved_regs[reg].addr = 0;
	    else
	      {
		CORE_ADDR offset;
		
		if ((inst >> 26) == 0x1c)
		  offset = (inst & 0x1 ? -1 << 13 : 0)
		    | (((inst >> 4) & 0x3ff) << 3);
		else if ((inst >> 26) == 0x03)
		  offset = hppa_low_hppa_sign_extend (inst & 0x1f, 5);
		else
		  offset = hppa_extract_14 (inst);
		
		/* Handle code with and without frame pointers.  */
		if (u->Save_SP)
		  cache->saved_regs[reg].addr = offset;
		else
		  cache->saved_regs[reg].addr
		    = (u->Total_frame_size << 3) + offset;
	      }
	  }

	/* GCC handles callee saved FP regs a little differently.  
	   
	   It emits an instruction to put the value of the start of
	   the FP store area into %r1.  It then uses fstds,ma with a
	   basereg of %r1 for the stores.

	   HP CC emits them at the current stack pointer modifying the
	   stack pointer as it stores each register.  */
	
	/* ldo X(%r3),%r1 or ldo X(%r30),%r1.  */
	if ((inst & 0xffffc000) == 0x34610000
	    || (inst & 0xffffc000) == 0x37c10000)
	  fp_loc = hppa_extract_14 (inst);
	
	reg = inst_saves_fr (inst);
	if (reg >= 12 && reg <= 21)
	  {
	    /* Note +4 braindamage below is necessary because the FP
	       status registers are internally 8 registers rather than
	       the expected 4 registers.  */
	    saved_fr_mask &= ~(1 << reg);
	    if (fp_loc == -1)
	      {
		/* 1st HP CC FP register store.  After this
		   instruction we've set enough state that the GCC and
		   HPCC code are both handled in the same manner.  */
		cache->saved_regs[reg + HPPA_FP4_REGNUM + 4].addr = 0;
		fp_loc = 8;
	      }
	    else
	      {
		cache->saved_regs[reg + HPPA_FP0_REGNUM + 4].addr = fp_loc;
		fp_loc += 8;
	      }
	  }
	
	/* Quit if we hit any kind of branch the previous iteration.  */
	if (final_iteration)
	  break;
	/* We want to look precisely one instruction beyond the branch
	   if we have not found everything yet.  */
	if (is_branch (inst))
	  final_iteration = 1;
      }
  }

  {
    /* The frame base always represents the value of %sp at entry to
       the current function (and is thus equivalent to the "saved"
       stack pointer.  */
    CORE_ADDR this_sp = get_frame_register_unsigned (this_frame,
                                                     HPPA_SP_REGNUM);
    CORE_ADDR fp;

    if (hppa_debug)
      fprintf_unfiltered (gdb_stdlog, " (this_sp=%s, pc=%s, "
		          "prologue_end=%s) ",
		          paddress (gdbarch, this_sp),
			  paddress (gdbarch, get_frame_pc (this_frame)),
			  paddress (gdbarch, prologue_end));

     /* Check to see if a frame pointer is available, and use it for
        frame unwinding if it is.
 
        There are some situations where we need to rely on the frame
        pointer to do stack unwinding.  For example, if a function calls
        alloca (), the stack pointer can get adjusted inside the body of
        the function.  In this case, the ABI requires that the compiler
        maintain a frame pointer for the function.
 
        The unwind record has a flag (alloca_frame) that indicates that
        a function has a variable frame; unfortunately, gcc/binutils 
        does not set this flag.  Instead, whenever a frame pointer is used
        and saved on the stack, the Save_SP flag is set.  We use this to
        decide whether to use the frame pointer for unwinding.
	
        TODO: For the HP compiler, maybe we should use the alloca_frame flag 
	instead of Save_SP.  */
 
     fp = get_frame_register_unsigned (this_frame, HPPA_FP_REGNUM);

     if (u->alloca_frame)
       fp -= u->Total_frame_size << 3;
 
     if (get_frame_pc (this_frame) >= prologue_end
         && (u->Save_SP || u->alloca_frame) && fp != 0)
      {
 	cache->base = fp;
 
 	if (hppa_debug)
	  fprintf_unfiltered (gdb_stdlog, " (base=%s) [frame pointer]",
			      paddress (gdbarch, cache->base));
      }
     else if (u->Save_SP 
	      && trad_frame_addr_p (cache->saved_regs, HPPA_SP_REGNUM))
      {
            /* Both we're expecting the SP to be saved and the SP has been
	       saved.  The entry SP value is saved at this frame's SP
	       address.  */
            cache->base = read_memory_integer (this_sp, word_size, byte_order);

	    if (hppa_debug)
	      fprintf_unfiltered (gdb_stdlog, " (base=%s) [saved]",
			          paddress (gdbarch, cache->base));
      }
    else
      {
        /* The prologue has been slowly allocating stack space.  Adjust
	   the SP back.  */
        cache->base = this_sp - frame_size;
	if (hppa_debug)
	  fprintf_unfiltered (gdb_stdlog, " (base=%s) [unwind adjust]",
			      paddress (gdbarch, cache->base));

      }
    trad_frame_set_value (cache->saved_regs, HPPA_SP_REGNUM, cache->base);
  }

  /* The PC is found in the "return register", "Millicode" uses "r31"
     as the return register while normal code uses "rp".  */
  if (u->Millicode)
    {
      if (trad_frame_addr_p (cache->saved_regs, 31))
        {
          cache->saved_regs[HPPA_PCOQ_HEAD_REGNUM] = cache->saved_regs[31];
	  if (hppa_debug)
	    fprintf_unfiltered (gdb_stdlog, " (pc=r31) [stack] } ");
        }
      else
	{
	  ULONGEST r31 = get_frame_register_unsigned (this_frame, 31);
	  trad_frame_set_value (cache->saved_regs, HPPA_PCOQ_HEAD_REGNUM, r31);
	  if (hppa_debug)
	    fprintf_unfiltered (gdb_stdlog, " (pc=r31) [frame] } ");
        }
    }
  else
    {
      if (trad_frame_addr_p (cache->saved_regs, HPPA_RP_REGNUM))
        {
          cache->saved_regs[HPPA_PCOQ_HEAD_REGNUM] = 
	    cache->saved_regs[HPPA_RP_REGNUM];
	  if (hppa_debug)
	    fprintf_unfiltered (gdb_stdlog, " (pc=rp) [stack] } ");
        }
      else
	{
	  ULONGEST rp = get_frame_register_unsigned (this_frame,
                                                     HPPA_RP_REGNUM);
	  trad_frame_set_value (cache->saved_regs, HPPA_PCOQ_HEAD_REGNUM, rp);
	  if (hppa_debug)
	    fprintf_unfiltered (gdb_stdlog, " (pc=rp) [frame] } ");
	}
    }

  /* If Save_SP is set, then we expect the frame pointer to be saved in the
     frame.  However, there is a one-insn window where we haven't saved it
     yet, but we've already clobbered it.  Detect this case and fix it up.

     The prologue sequence for frame-pointer functions is:
	0: stw %rp, -20(%sp)
	4: copy %r3, %r1
	8: copy %sp, %r3
	c: stw,ma %r1, XX(%sp)

     So if we are at offset c, the r3 value that we want is not yet saved
     on the stack, but it's been overwritten.  The prologue analyzer will
     set fp_in_r1 when it sees the copy insn so we know to get the value 
     from r1 instead.  */
  if (u->Save_SP && !trad_frame_addr_p (cache->saved_regs, HPPA_FP_REGNUM)
      && fp_in_r1)
    {
      ULONGEST r1 = get_frame_register_unsigned (this_frame, 1);
      trad_frame_set_value (cache->saved_regs, HPPA_FP_REGNUM, r1);
    }

  {
    /* Convert all the offsets into addresses.  */
    int reg;
    for (reg = 0; reg < gdbarch_num_regs (gdbarch); reg++)
      {
	if (trad_frame_addr_p (cache->saved_regs, reg))
	  cache->saved_regs[reg].addr += cache->base;
      }
  }

  {
    struct gdbarch_tdep *tdep;

    tdep = gdbarch_tdep (gdbarch);

    if (tdep->unwind_adjust_stub)
      tdep->unwind_adjust_stub (this_frame, cache->base, cache->saved_regs);
  }

  if (hppa_debug)
    fprintf_unfiltered (gdb_stdlog, "base=%s }",
      paddress (gdbarch, ((struct hppa_frame_cache *)*this_cache)->base));
  return (*this_cache);
}

static void
hppa_frame_this_id (struct frame_info *this_frame, void **this_cache,
		    struct frame_id *this_id)
{
  struct hppa_frame_cache *info;
  CORE_ADDR pc = get_frame_pc (this_frame);
  struct unwind_table_entry *u;

  info = hppa_frame_cache (this_frame, this_cache);
  u = hppa_find_unwind_entry_in_block (this_frame);

  (*this_id) = frame_id_build (info->base, u->region_start);
}

static struct value *
hppa_frame_prev_register (struct frame_info *this_frame,
			  void **this_cache, int regnum)
{
  struct hppa_frame_cache *info = hppa_frame_cache (this_frame, this_cache);

  return hppa_frame_prev_register_helper (this_frame,
					  info->saved_regs, regnum);
}

static int
hppa_frame_unwind_sniffer (const struct frame_unwind *self,
                           struct frame_info *this_frame, void **this_cache)
{
  if (hppa_find_unwind_entry_in_block (this_frame))
    return 1;

  return 0;
}

static const struct frame_unwind hppa_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  hppa_frame_this_id,
  hppa_frame_prev_register,
  NULL,
  hppa_frame_unwind_sniffer
};

/* This is a generic fallback frame unwinder that kicks in if we fail all
   the other ones.  Normally we would expect the stub and regular unwinder
   to work, but in some cases we might hit a function that just doesn't
   have any unwind information available.  In this case we try to do
   unwinding solely based on code reading.  This is obviously going to be
   slow, so only use this as a last resort.  Currently this will only
   identify the stack and pc for the frame.  */

static struct hppa_frame_cache *
hppa_fallback_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct hppa_frame_cache *cache;
  unsigned int frame_size = 0;
  int found_rp = 0;
  CORE_ADDR start_pc;

  if (hppa_debug)
    fprintf_unfiltered (gdb_stdlog,
			"{ hppa_fallback_frame_cache (frame=%d) -> ",
			frame_relative_level (this_frame));

  cache = FRAME_OBSTACK_ZALLOC (struct hppa_frame_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  start_pc = get_frame_func (this_frame);
  if (start_pc)
    {
      CORE_ADDR cur_pc = get_frame_pc (this_frame);
      CORE_ADDR pc;

      for (pc = start_pc; pc < cur_pc; pc += 4)
	{
	  unsigned int insn;

	  insn = read_memory_unsigned_integer (pc, 4, byte_order);
	  frame_size += prologue_inst_adjust_sp (insn);

	  /* There are limited ways to store the return pointer into the
	     stack.  */
	  if (insn == 0x6bc23fd9) /* stw rp,-0x14(sr0,sp) */
	    {
	      cache->saved_regs[HPPA_RP_REGNUM].addr = -20;
	      found_rp = 1;
	    }
	  else if (insn == 0x0fc212c1
	           || insn == 0x73c23fe1) /* std rp,-0x10(sr0,sp) */
	    {
	      cache->saved_regs[HPPA_RP_REGNUM].addr = -16;
	      found_rp = 1;
	    }
	}
    }

  if (hppa_debug)
    fprintf_unfiltered (gdb_stdlog, " frame_size=%d, found_rp=%d }\n",
			frame_size, found_rp);

  cache->base = get_frame_register_unsigned (this_frame, HPPA_SP_REGNUM);
  cache->base -= frame_size;
  trad_frame_set_value (cache->saved_regs, HPPA_SP_REGNUM, cache->base);

  if (trad_frame_addr_p (cache->saved_regs, HPPA_RP_REGNUM))
    {
      cache->saved_regs[HPPA_RP_REGNUM].addr += cache->base;
      cache->saved_regs[HPPA_PCOQ_HEAD_REGNUM] = 
	cache->saved_regs[HPPA_RP_REGNUM];
    }
  else
    {
      ULONGEST rp;
      rp = get_frame_register_unsigned (this_frame, HPPA_RP_REGNUM);
      trad_frame_set_value (cache->saved_regs, HPPA_PCOQ_HEAD_REGNUM, rp);
    }

  return cache;
}

static void
hppa_fallback_frame_this_id (struct frame_info *this_frame, void **this_cache,
			     struct frame_id *this_id)
{
  struct hppa_frame_cache *info = 
    hppa_fallback_frame_cache (this_frame, this_cache);

  (*this_id) = frame_id_build (info->base, get_frame_func (this_frame));
}

static struct value *
hppa_fallback_frame_prev_register (struct frame_info *this_frame,
			           void **this_cache, int regnum)
{
  struct hppa_frame_cache *info
    = hppa_fallback_frame_cache (this_frame, this_cache);

  return hppa_frame_prev_register_helper (this_frame,
					  info->saved_regs, regnum);
}

static const struct frame_unwind hppa_fallback_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  hppa_fallback_frame_this_id,
  hppa_fallback_frame_prev_register,
  NULL,
  default_frame_sniffer
};

/* Stub frames, used for all kinds of call stubs.  */
struct hppa_stub_unwind_cache
{
  CORE_ADDR base;
  struct trad_frame_saved_reg *saved_regs;
};

static struct hppa_stub_unwind_cache *
hppa_stub_frame_unwind_cache (struct frame_info *this_frame,
			      void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct hppa_stub_unwind_cache *info;
  struct unwind_table_entry *u;

  if (*this_cache)
    return *this_cache;

  info = FRAME_OBSTACK_ZALLOC (struct hppa_stub_unwind_cache);
  *this_cache = info;
  info->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  info->base = get_frame_register_unsigned (this_frame, HPPA_SP_REGNUM);

  if (gdbarch_osabi (gdbarch) == GDB_OSABI_HPUX_SOM)
    {
      /* HPUX uses export stubs in function calls; the export stub clobbers
         the return value of the caller, and, later restores it from the
	 stack.  */
      u = find_unwind_entry (get_frame_pc (this_frame));

      if (u && u->stub_unwind.stub_type == EXPORT)
	{
          info->saved_regs[HPPA_PCOQ_HEAD_REGNUM].addr = info->base - 24;

	  return info;
	}
    }

  /* By default we assume that stubs do not change the rp.  */
  info->saved_regs[HPPA_PCOQ_HEAD_REGNUM].realreg = HPPA_RP_REGNUM;

  return info;
}

static void
hppa_stub_frame_this_id (struct frame_info *this_frame,
			 void **this_prologue_cache,
			 struct frame_id *this_id)
{
  struct hppa_stub_unwind_cache *info
    = hppa_stub_frame_unwind_cache (this_frame, this_prologue_cache);

  if (info)
    *this_id = frame_id_build (info->base, get_frame_func (this_frame));
}

static struct value *
hppa_stub_frame_prev_register (struct frame_info *this_frame,
			       void **this_prologue_cache, int regnum)
{
  struct hppa_stub_unwind_cache *info
    = hppa_stub_frame_unwind_cache (this_frame, this_prologue_cache);

  if (info == NULL)
    error (_("Requesting registers from null frame."));

  return hppa_frame_prev_register_helper (this_frame,
					  info->saved_regs, regnum);
}

static int
hppa_stub_unwind_sniffer (const struct frame_unwind *self,
                          struct frame_info *this_frame,
                          void **this_cache)
{
  CORE_ADDR pc = get_frame_address_in_block (this_frame);
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (pc == 0
      || (tdep->in_solib_call_trampoline != NULL
	  && tdep->in_solib_call_trampoline (gdbarch, pc))
      || gdbarch_in_solib_return_trampoline (gdbarch, pc, NULL))
    return 1;
  return 0;
}

static const struct frame_unwind hppa_stub_frame_unwind = {
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  hppa_stub_frame_this_id,
  hppa_stub_frame_prev_register,
  NULL,
  hppa_stub_unwind_sniffer
};

static struct frame_id
hppa_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  return frame_id_build (get_frame_register_unsigned (this_frame,
                                                      HPPA_SP_REGNUM),
			 get_frame_pc (this_frame));
}

CORE_ADDR
hppa_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  ULONGEST ipsw;
  CORE_ADDR pc;

  ipsw = frame_unwind_register_unsigned (next_frame, HPPA_IPSW_REGNUM);
  pc = frame_unwind_register_unsigned (next_frame, HPPA_PCOQ_HEAD_REGNUM);

  /* If the current instruction is nullified, then we are effectively
     still executing the previous instruction.  Pretend we are still
     there.  This is needed when single stepping; if the nullified
     instruction is on a different line, we don't want GDB to think
     we've stepped onto that line.  */
  if (ipsw & 0x00200000)
    pc -= 4;

  return pc & ~0x3;
}

/* Return the minimal symbol whose name is NAME and stub type is STUB_TYPE.
   Return NULL if no such symbol was found.  */

struct minimal_symbol *
hppa_lookup_stub_minimal_symbol (const char *name,
                                 enum unwind_stub_types stub_type)
{
  struct objfile *objfile;
  struct minimal_symbol *msym;

  ALL_MSYMBOLS (objfile, msym)
    {
      if (strcmp (SYMBOL_LINKAGE_NAME (msym), name) == 0)
        {
          struct unwind_table_entry *u;

          u = find_unwind_entry (SYMBOL_VALUE (msym));
          if (u != NULL && u->stub_unwind.stub_type == stub_type)
            return msym;
        }
    }

  return NULL;
}

static void
unwind_command (char *exp, int from_tty)
{
  CORE_ADDR address;
  struct unwind_table_entry *u;

  /* If we have an expression, evaluate it and use it as the address.  */

  if (exp != 0 && *exp != 0)
    address = parse_and_eval_address (exp);
  else
    return;

  u = find_unwind_entry (address);

  if (!u)
    {
      printf_unfiltered ("Can't find unwind table entry for %s\n", exp);
      return;
    }

  printf_unfiltered ("unwind_table_entry (%s):\n", host_address_to_string (u));

  printf_unfiltered ("\tregion_start = %s\n", hex_string (u->region_start));
  gdb_flush (gdb_stdout);

  printf_unfiltered ("\tregion_end = %s\n", hex_string (u->region_end));
  gdb_flush (gdb_stdout);

#define pif(FLD) if (u->FLD) printf_unfiltered (" "#FLD);

  printf_unfiltered ("\n\tflags =");
  pif (Cannot_unwind);
  pif (Millicode);
  pif (Millicode_save_sr0);
  pif (Entry_SR);
  pif (Args_stored);
  pif (Variable_Frame);
  pif (Separate_Package_Body);
  pif (Frame_Extension_Millicode);
  pif (Stack_Overflow_Check);
  pif (Two_Instruction_SP_Increment);
  pif (sr4export);
  pif (cxx_info);
  pif (cxx_try_catch);
  pif (sched_entry_seq);
  pif (Save_SP);
  pif (Save_RP);
  pif (Save_MRP_in_frame);
  pif (save_r19);
  pif (Cleanup_defined);
  pif (MPE_XL_interrupt_marker);
  pif (HP_UX_interrupt_marker);
  pif (Large_frame);
  pif (alloca_frame);

  putchar_unfiltered ('\n');

#define pin(FLD) printf_unfiltered ("\t"#FLD" = 0x%x\n", u->FLD);

  pin (Region_description);
  pin (Entry_FR);
  pin (Entry_GR);
  pin (Total_frame_size);

  if (u->stub_unwind.stub_type)
    {
      printf_unfiltered ("\tstub type = ");
      switch (u->stub_unwind.stub_type)
        {
	  case LONG_BRANCH:
	    printf_unfiltered ("long branch\n");
	    break;
	  case PARAMETER_RELOCATION:
	    printf_unfiltered ("parameter relocation\n");
	    break;
	  case EXPORT:
	    printf_unfiltered ("export\n");
	    break;
	  case IMPORT:
	    printf_unfiltered ("import\n");
	    break;
	  case IMPORT_SHLIB:
	    printf_unfiltered ("import shlib\n");
	    break;
	  default:
	    printf_unfiltered ("unknown (%d)\n", u->stub_unwind.stub_type);
	}
    }
}

/* Return the GDB type object for the "standard" data type of data in
   register REGNUM.  */

static struct type *
hppa32_register_type (struct gdbarch *gdbarch, int regnum)
{
   if (regnum < HPPA_FP4_REGNUM)
     return builtin_type (gdbarch)->builtin_uint32;
   else
     return builtin_type (gdbarch)->builtin_float;
}

static struct type *
hppa64_register_type (struct gdbarch *gdbarch, int regnum)
{
   if (regnum < HPPA64_FP4_REGNUM)
     return builtin_type (gdbarch)->builtin_uint64;
   else
     return builtin_type (gdbarch)->builtin_double;
}

/* Return non-zero if REGNUM is not a register available to the user
   through ptrace/ttrace.  */

static int
hppa32_cannot_store_register (struct gdbarch *gdbarch, int regnum)
{
  return (regnum == 0
          || regnum == HPPA_PCSQ_HEAD_REGNUM
          || (regnum >= HPPA_PCSQ_TAIL_REGNUM && regnum < HPPA_IPSW_REGNUM)
          || (regnum > HPPA_IPSW_REGNUM && regnum < HPPA_FP4_REGNUM));
}

static int
hppa32_cannot_fetch_register (struct gdbarch *gdbarch, int regnum)
{
  /* cr26 and cr27 are readable (but not writable) from userspace.  */
  if (regnum == HPPA_CR26_REGNUM || regnum == HPPA_CR27_REGNUM)
    return 0;
  else
    return hppa32_cannot_store_register (gdbarch, regnum);
}

static int
hppa64_cannot_store_register (struct gdbarch *gdbarch, int regnum)
{
  return (regnum == 0
          || regnum == HPPA_PCSQ_HEAD_REGNUM
          || (regnum >= HPPA_PCSQ_TAIL_REGNUM && regnum < HPPA_IPSW_REGNUM)
          || (regnum > HPPA_IPSW_REGNUM && regnum < HPPA64_FP4_REGNUM));
}

static int
hppa64_cannot_fetch_register (struct gdbarch *gdbarch, int regnum)
{
  /* cr26 and cr27 are readable (but not writable) from userspace.  */
  if (regnum == HPPA_CR26_REGNUM || regnum == HPPA_CR27_REGNUM)
    return 0;
  else
    return hppa64_cannot_store_register (gdbarch, regnum);
}

static CORE_ADDR
hppa_addr_bits_remove (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  /* The low two bits of the PC on the PA contain the privilege level.
     Some genius implementing a (non-GCC) compiler apparently decided
     this means that "addresses" in a text section therefore include a
     privilege level, and thus symbol tables should contain these bits.
     This seems like a bonehead thing to do--anyway, it seems to work
     for our purposes to just ignore those bits.  */

  return (addr &= ~0x3);
}

/* Get the ARGIth function argument for the current function.  */

static CORE_ADDR
hppa_fetch_pointer_argument (struct frame_info *frame, int argi, 
			     struct type *type)
{
  return get_frame_register_unsigned (frame, HPPA_R0_REGNUM + 26 - argi);
}

static enum register_status
hppa_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int regnum, gdb_byte *buf)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  ULONGEST tmp;
  enum register_status status;

  status = regcache_raw_read_unsigned (regcache, regnum, &tmp);
  if (status == REG_VALID)
    {
      if (regnum == HPPA_PCOQ_HEAD_REGNUM || regnum == HPPA_PCOQ_TAIL_REGNUM)
	tmp &= ~0x3;
      store_unsigned_integer (buf, sizeof tmp, byte_order, tmp);
    }
  return status;
}

static CORE_ADDR
hppa_find_global_pointer (struct gdbarch *gdbarch, struct value *function)
{
  return 0;
}

struct value *
hppa_frame_prev_register_helper (struct frame_info *this_frame,
			         struct trad_frame_saved_reg saved_regs[],
				 int regnum)
{
  struct gdbarch *arch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (arch);

  if (regnum == HPPA_PCOQ_TAIL_REGNUM)
    {
      int size = register_size (arch, HPPA_PCOQ_HEAD_REGNUM);
      CORE_ADDR pc;
      struct value *pcoq_val =
        trad_frame_get_prev_register (this_frame, saved_regs,
                                      HPPA_PCOQ_HEAD_REGNUM);

      pc = extract_unsigned_integer (value_contents_all (pcoq_val),
				     size, byte_order);
      return frame_unwind_got_constant (this_frame, regnum, pc + 4);
    }

  /* Make sure the "flags" register is zero in all unwound frames.
     The "flags" registers is a HP-UX specific wart, and only the code
     in hppa-hpux-tdep.c depends on it.  However, it is easier to deal
     with it here.  This shouldn't affect other systems since those
     should provide zero for the "flags" register anyway.  */
  if (regnum == HPPA_FLAGS_REGNUM)
    return frame_unwind_got_constant (this_frame, regnum, 0);

  return trad_frame_get_prev_register (this_frame, saved_regs, regnum);
}


/* An instruction to match.  */
struct insn_pattern
{
  unsigned int data;            /* See if it matches this....  */
  unsigned int mask;            /* ... with this mask.  */
};

/* See bfd/elf32-hppa.c */
static struct insn_pattern hppa_long_branch_stub[] = {
  /* ldil LR'xxx,%r1 */
  { 0x20200000, 0xffe00000 },
  /* be,n RR'xxx(%sr4,%r1) */
  { 0xe0202002, 0xffe02002 }, 
  { 0, 0 }
};

static struct insn_pattern hppa_long_branch_pic_stub[] = {
  /* b,l .+8, %r1 */
  { 0xe8200000, 0xffe00000 },
  /* addil LR'xxx - ($PIC_pcrel$0 - 4), %r1 */
  { 0x28200000, 0xffe00000 },
  /* be,n RR'xxxx - ($PIC_pcrel$0 - 8)(%sr4, %r1) */
  { 0xe0202002, 0xffe02002 }, 
  { 0, 0 }
};

static struct insn_pattern hppa_import_stub[] = {
  /* addil LR'xxx, %dp */
  { 0x2b600000, 0xffe00000 },
  /* ldw RR'xxx(%r1), %r21 */
  { 0x48350000, 0xffffb000 },
  /* bv %r0(%r21) */
  { 0xeaa0c000, 0xffffffff },
  /* ldw RR'xxx+4(%r1), %r19 */
  { 0x48330000, 0xffffb000 },
  { 0, 0 }
};

static struct insn_pattern hppa_import_pic_stub[] = {
  /* addil LR'xxx,%r19 */
  { 0x2a600000, 0xffe00000 },
  /* ldw RR'xxx(%r1),%r21 */
  { 0x48350000, 0xffffb000 },
  /* bv %r0(%r21) */
  { 0xeaa0c000, 0xffffffff },
  /* ldw RR'xxx+4(%r1),%r19 */
  { 0x48330000, 0xffffb000 },
  { 0, 0 },
};

static struct insn_pattern hppa_plt_stub[] = {
  /* b,l 1b, %r20 - 1b is 3 insns before here */
  { 0xea9f1fdd, 0xffffffff },
  /* depi 0,31,2,%r20 */
  { 0xd6801c1e, 0xffffffff },
  { 0, 0 }
};

static struct insn_pattern hppa_sigtramp[] = {
  /* ldi 0, %r25 or ldi 1, %r25 */
  { 0x34190000, 0xfffffffd },
  /* ldi __NR_rt_sigreturn, %r20 */
  { 0x3414015a, 0xffffffff },
  /* be,l 0x100(%sr2, %r0), %sr0, %r31 */
  { 0xe4008200, 0xffffffff },
  /* nop */
  { 0x08000240, 0xffffffff },
  { 0, 0 }
};

/* Maximum number of instructions on the patterns above.  */
#define HPPA_MAX_INSN_PATTERN_LEN	4

/* Return non-zero if the instructions at PC match the series
   described in PATTERN, or zero otherwise.  PATTERN is an array of
   'struct insn_pattern' objects, terminated by an entry whose mask is
   zero.

   When the match is successful, fill INSN[i] with what PATTERN[i]
   matched.  */

static int
hppa_match_insns (struct gdbarch *gdbarch, CORE_ADDR pc,
		  struct insn_pattern *pattern, unsigned int *insn)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR npc = pc;
  int i;

  for (i = 0; pattern[i].mask; i++)
    {
      gdb_byte buf[HPPA_INSN_SIZE];

      target_read_memory (npc, buf, HPPA_INSN_SIZE);
      insn[i] = extract_unsigned_integer (buf, HPPA_INSN_SIZE, byte_order);
      if ((insn[i] & pattern[i].mask) == pattern[i].data)
        npc += 4;
      else
        return 0;
    }

  return 1;
}

/* This relaxed version of the insstruction matcher allows us to match
   from somewhere inside the pattern, by looking backwards in the
   instruction scheme.  */

static int
hppa_match_insns_relaxed (struct gdbarch *gdbarch, CORE_ADDR pc,
			  struct insn_pattern *pattern, unsigned int *insn)
{
  int offset, len = 0;

  while (pattern[len].mask)
    len++;

  for (offset = 0; offset < len; offset++)
    if (hppa_match_insns (gdbarch, pc - offset * HPPA_INSN_SIZE,
			  pattern, insn))
      return 1;

  return 0;
}

static int
hppa_in_dyncall (CORE_ADDR pc)
{
  struct unwind_table_entry *u;

  u = find_unwind_entry (hppa_symbol_address ("$$dyncall"));
  if (!u)
    return 0;

  return (pc >= u->region_start && pc <= u->region_end);
}

int
hppa_in_solib_call_trampoline (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  unsigned int insn[HPPA_MAX_INSN_PATTERN_LEN];
  struct unwind_table_entry *u;

  if (in_plt_section (pc) || hppa_in_dyncall (pc))
    return 1;

  /* The GNU toolchain produces linker stubs without unwind
     information.  Since the pattern matching for linker stubs can be
     quite slow, so bail out if we do have an unwind entry.  */

  u = find_unwind_entry (pc);
  if (u != NULL)
    return 0;

  return
    (hppa_match_insns_relaxed (gdbarch, pc, hppa_import_stub, insn)
     || hppa_match_insns_relaxed (gdbarch, pc, hppa_import_pic_stub, insn)
     || hppa_match_insns_relaxed (gdbarch, pc, hppa_long_branch_stub, insn)
     || hppa_match_insns_relaxed (gdbarch, pc,
				  hppa_long_branch_pic_stub, insn));
}

/* This code skips several kind of "trampolines" used on PA-RISC
   systems: $$dyncall, import stubs and PLT stubs.  */

CORE_ADDR
hppa_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct type *func_ptr_type = builtin_type (gdbarch)->builtin_func_ptr;

  unsigned int insn[HPPA_MAX_INSN_PATTERN_LEN];
  int dp_rel;

  /* $$dyncall handles both PLABELs and direct addresses.  */
  if (hppa_in_dyncall (pc))
    {
      pc = get_frame_register_unsigned (frame, HPPA_R0_REGNUM + 22);

      /* PLABELs have bit 30 set; if it's a PLABEL, then dereference it.  */
      if (pc & 0x2)
	pc = read_memory_typed_address (pc & ~0x3, func_ptr_type);

      return pc;
    }

  dp_rel = hppa_match_insns (gdbarch, pc, hppa_import_stub, insn);
  if (dp_rel || hppa_match_insns (gdbarch, pc, hppa_import_pic_stub, insn))
    {
      /* Extract the target address from the addil/ldw sequence.  */
      pc = hppa_extract_21 (insn[0]) + hppa_extract_14 (insn[1]);

      if (dp_rel)
        pc += get_frame_register_unsigned (frame, HPPA_DP_REGNUM);
      else
        pc += get_frame_register_unsigned (frame, HPPA_R0_REGNUM + 19);

      /* fallthrough */
    }

  if (in_plt_section (pc))
    {
      pc = read_memory_typed_address (pc, func_ptr_type);

      /* If the PLT slot has not yet been resolved, the target will be
         the PLT stub.  */
      if (in_plt_section (pc))
	{
	  /* Sanity check: are we pointing to the PLT stub?  */
  	  if (!hppa_match_insns (gdbarch, pc, hppa_plt_stub, insn))
	    {
	      warning (_("Cannot resolve PLT stub at %s."),
		       paddress (gdbarch, pc));
	      return 0;
	    }

	  /* This should point to the fixup routine.  */
	  pc = read_memory_typed_address (pc + 8, func_ptr_type);
	}
    }

  return pc;
}


/* Here is a table of C type sizes on hppa with various compiles
   and options.  I measured this on PA 9000/800 with HP-UX 11.11
   and these compilers:

     /usr/ccs/bin/cc    HP92453-01 A.11.01.21
     /opt/ansic/bin/cc  HP92453-01 B.11.11.28706.GP
     /opt/aCC/bin/aCC   B3910B A.03.45
     gcc                gcc 3.3.2 native hppa2.0w-hp-hpux11.11

     cc            : 1 2 4 4 8 : 4 8 -- : 4 4
     ansic +DA1.1  : 1 2 4 4 8 : 4 8 16 : 4 4
     ansic +DA2.0  : 1 2 4 4 8 : 4 8 16 : 4 4
     ansic +DA2.0W : 1 2 4 8 8 : 4 8 16 : 8 8
     acc   +DA1.1  : 1 2 4 4 8 : 4 8 16 : 4 4
     acc   +DA2.0  : 1 2 4 4 8 : 4 8 16 : 4 4
     acc   +DA2.0W : 1 2 4 8 8 : 4 8 16 : 8 8
     gcc           : 1 2 4 4 8 : 4 8 16 : 4 4

   Each line is:

     compiler and options
     char, short, int, long, long long
     float, double, long double
     char *, void (*)()

   So all these compilers use either ILP32 or LP64 model.
   TODO: gcc has more options so it needs more investigation.

   For floating point types, see:

     http://docs.hp.com/hpux/pdf/B3906-90006.pdf
     HP-UX floating-point guide, hpux 11.00

   -- chastain 2003-12-18  */

static struct gdbarch *
hppa_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;
  
  /* Try to determine the ABI of the object we are loading.  */
  if (info.abfd != NULL && info.osabi == GDB_OSABI_UNKNOWN)
    {
      /* If it's a SOM file, assume it's HP/UX SOM.  */
      if (bfd_get_flavour (info.abfd) == bfd_target_som_flavour)
	info.osabi = GDB_OSABI_HPUX_SOM;
    }

  /* find a candidate among the list of pre-declared architectures.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return (arches->gdbarch);

  /* If none found, then allocate and initialize one.  */
  tdep = XZALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  /* Determine from the bfd_arch_info structure if we are dealing with
     a 32 or 64 bits architecture.  If the bfd_arch_info is not available,
     then default to a 32bit machine.  */
  if (info.bfd_arch_info != NULL)
    tdep->bytes_per_address =
      info.bfd_arch_info->bits_per_address / info.bfd_arch_info->bits_per_byte;
  else
    tdep->bytes_per_address = 4;

  tdep->find_global_pointer = hppa_find_global_pointer;

  /* Some parts of the gdbarch vector depend on whether we are running
     on a 32 bits or 64 bits target.  */
  switch (tdep->bytes_per_address)
    {
      case 4:
        set_gdbarch_num_regs (gdbarch, hppa32_num_regs);
        set_gdbarch_register_name (gdbarch, hppa32_register_name);
        set_gdbarch_register_type (gdbarch, hppa32_register_type);
	set_gdbarch_cannot_store_register (gdbarch,
					   hppa32_cannot_store_register);
	set_gdbarch_cannot_fetch_register (gdbarch,
					   hppa32_cannot_fetch_register);
        break;
      case 8:
        set_gdbarch_num_regs (gdbarch, hppa64_num_regs);
        set_gdbarch_register_name (gdbarch, hppa64_register_name);
        set_gdbarch_register_type (gdbarch, hppa64_register_type);
        set_gdbarch_dwarf2_reg_to_regnum (gdbarch, hppa64_dwarf_reg_to_regnum);
	set_gdbarch_cannot_store_register (gdbarch,
					   hppa64_cannot_store_register);
	set_gdbarch_cannot_fetch_register (gdbarch,
					   hppa64_cannot_fetch_register);
        break;
      default:
        internal_error (__FILE__, __LINE__, _("Unsupported address size: %d"),
                        tdep->bytes_per_address);
    }

  set_gdbarch_long_bit (gdbarch, tdep->bytes_per_address * TARGET_CHAR_BIT);
  set_gdbarch_ptr_bit (gdbarch, tdep->bytes_per_address * TARGET_CHAR_BIT);

  /* The following gdbarch vector elements are the same in both ILP32
     and LP64, but might show differences some day.  */
  set_gdbarch_long_long_bit (gdbarch, 64);
  set_gdbarch_long_double_bit (gdbarch, 128);
  set_gdbarch_long_double_format (gdbarch, floatformats_ia64_quad);

  /* The following gdbarch vector elements do not depend on the address
     size, or in any other gdbarch element previously set.  */
  set_gdbarch_skip_prologue (gdbarch, hppa_skip_prologue);
  set_gdbarch_in_function_epilogue_p (gdbarch,
				      hppa_in_function_epilogue_p);
  set_gdbarch_inner_than (gdbarch, core_addr_greaterthan);
  set_gdbarch_sp_regnum (gdbarch, HPPA_SP_REGNUM);
  set_gdbarch_fp0_regnum (gdbarch, HPPA_FP0_REGNUM);
  set_gdbarch_addr_bits_remove (gdbarch, hppa_addr_bits_remove);
  set_gdbarch_believe_pcc_promotion (gdbarch, 1);
  set_gdbarch_read_pc (gdbarch, hppa_read_pc);
  set_gdbarch_write_pc (gdbarch, hppa_write_pc);

  /* Helper for function argument information.  */
  set_gdbarch_fetch_pointer_argument (gdbarch, hppa_fetch_pointer_argument);

  set_gdbarch_print_insn (gdbarch, print_insn_hppa);

  /* When a hardware watchpoint triggers, we'll move the inferior past
     it by removing all eventpoints; stepping past the instruction
     that caused the trigger; reinserting eventpoints; and checking
     whether any watched location changed.  */
  set_gdbarch_have_nonsteppable_watchpoint (gdbarch, 1);

  /* Inferior function call methods.  */
  switch (tdep->bytes_per_address)
    {
    case 4:
      set_gdbarch_push_dummy_call (gdbarch, hppa32_push_dummy_call);
      set_gdbarch_frame_align (gdbarch, hppa32_frame_align);
      set_gdbarch_convert_from_func_ptr_addr
        (gdbarch, hppa32_convert_from_func_ptr_addr);
      break;
    case 8:
      set_gdbarch_push_dummy_call (gdbarch, hppa64_push_dummy_call);
      set_gdbarch_frame_align (gdbarch, hppa64_frame_align);
      break;
    default:
      internal_error (__FILE__, __LINE__, _("bad switch"));
    }
      
  /* Struct return methods.  */
  switch (tdep->bytes_per_address)
    {
    case 4:
      set_gdbarch_return_value (gdbarch, hppa32_return_value);
      break;
    case 8:
      set_gdbarch_return_value (gdbarch, hppa64_return_value);
      break;
    default:
      internal_error (__FILE__, __LINE__, _("bad switch"));
    }
      
  set_gdbarch_breakpoint_from_pc (gdbarch, hppa_breakpoint_from_pc);
  set_gdbarch_pseudo_register_read (gdbarch, hppa_pseudo_register_read);

  /* Frame unwind methods.  */
  set_gdbarch_dummy_id (gdbarch, hppa_dummy_id);
  set_gdbarch_unwind_pc (gdbarch, hppa_unwind_pc);

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  /* Hook in the default unwinders.  */
  frame_unwind_append_unwinder (gdbarch, &hppa_stub_frame_unwind);
  frame_unwind_append_unwinder (gdbarch, &hppa_frame_unwind);
  frame_unwind_append_unwinder (gdbarch, &hppa_fallback_frame_unwind);

  return gdbarch;
}

static void
hppa_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  fprintf_unfiltered (file, "bytes_per_address = %d\n", 
                      tdep->bytes_per_address);
  fprintf_unfiltered (file, "elf = %s\n", tdep->is_elf ? "yes" : "no");
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_hppa_tdep;

void
_initialize_hppa_tdep (void)
{
  struct cmd_list_element *c;

  gdbarch_register (bfd_arch_hppa, hppa_gdbarch_init, hppa_dump_tdep);

  hppa_objfile_priv_data = register_objfile_data ();

  add_cmd ("unwind", class_maintenance, unwind_command,
	   _("Print unwind table entry at given address."),
	   &maintenanceprintlist);

  /* Debug this files internals.  */
  add_setshow_boolean_cmd ("hppa", class_maintenance, &hppa_debug, _("\
Set whether hppa target specific debugging information should be displayed."),
			   _("\
Show whether hppa target specific debugging information is displayed."), _("\
This flag controls whether hppa target specific debugging information is\n\
displayed.  This information is particularly useful for debugging frame\n\
unwinding problems."),
			   NULL,
			   NULL, /* FIXME: i18n: hppa debug flag is %s.  */
			   &setdebuglist, &showdebuglist);
}
@


1.288
log
@-Wpointer-sign: char -> gdb_byte.

-Wpointer-sign catches all these cases across the codebase that should
be using gdb_byte for raw target bytes.  I think these are all
obvious, hence I've collapsed into a single patch.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* aarch64-tdep.c (aarch64_default_breakpoint): Change type to
	gdb_byte[].
	(aarch64_breakpoint_from_pc): Change return type to gdb_byte *.
	* ada-lang.c (ada_value_assign): Use gdb_byte.
	* alphanbsd-tdep.c (sigtramp_retcode): Change type to gdb_byte[].
	(alphanbsd_sigtramp_offset): Use gdb_byte.
	* arm-linux-tdep.c (arm_linux_arm_le_breakpoint)
	(arm_linux_arm_be_breakpoint, eabi_linux_arm_le_breakpoint)
	(eabi_linux_arm_be_breakpoint, arm_linux_thumb_be_breakpoint)
	(arm_linux_thumb_le_breakpoint, arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): Change type to gdb_byte[].
	* arm-tdep.c (arm_stub_unwind_sniffer)
	(arm_displaced_init_closure): Use gdb_byte.
	(arm_default_arm_le_breakpoint, arm_default_arm_be_breakpoint)
	(arm_default_thumb_le_breakpoint)
	(arm_default_thumb_be_breakpoint): Change type to gdb_byte[].
	* arm-tdep.h (struct gdbarch_tdep) <arm_breakpoint,
	thumb_breakpoint, thumb2_breakpoint>: Change type to gdb_byte *.
	* arm-wince-tdep.c (arm_wince_le_breakpoint)
	(arm_wince_thumb_le_breakpoint): Change type to gdb_byte[].
	* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint)
	(arm_nbsd_arm_be_breakpoint, arm_nbsd_thumb_le_breakpoint)
	(arm_nbsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint)
	(arm_obsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* cris-tdep.c (push_stack_item, cris_push_dummy_call)
	(cris_store_return_value, cris_extract_return_value): Use
	gdb_byte.
	(constraint): Change type of parameter to char * from signed
	char*.  Use gdb_byte.
	* dwarf2loc.c (read_pieced_value, write_pieced_value): Change type
	of local buffer to gdb_byte *.
	* dwarf2read.c (read_index_from_section): Use gdb_byte.
	(create_dwp_hash_table): Change type of locals to gdb_byte *.
	(add_address_entry): Change type of local buffer to gdb_byte[].
	* frv-tdep.c (frv_adjust_breakpoint_address, find_func_descr)
	(frv_push_dummy_call): Use gdb_byte.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code)
	(hppa_hpux_supply_ss_fpblock, hppa_hpux_supply_ss_wide)
	(hppa_hpux_supply_save_state): Use gdb_byte.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_convert_code_addr_to_fptr): Use gdb_byte.
	* ia64-tdep.c (extract_bit_field, replace_bit_field)
	(slotN_contents, replace_slotN_contents): Change type of parameter
	to gdb_byte *.
	(fetch_instruction, ia64_pseudo_register_write)
	(ia64_register_to_value, ia64_value_to_register)
	(ia64_extract_return_value, ia64_store_return_value)
	(ia64_push_dummy_call): Use gdb_byte.
	* m32c-tdep.c (m32c_return_value): Remove cast.
	* m68hc11-tdep.c (m68hc11_pseudo_register_write)
	(m68hc11_push_dummy_call, m68hc11_store_return_value): Use
	gdb_byte.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use gdb_byte.
	* mn10300-tdep.c (mn10300_store_return_value)
	(mn10300_breakpoint_from_pc, mn10300_push_dummy_call): Use
	gdb_byte.
	* moxie-tdep.c (moxie_process_readu): Use gdb_byte.
	(moxie_process_record): Remove casts.
	* ppc-ravenscar-thread.c (supply_register_at_address)
	(ppc_ravenscar_generic_store_registers): Use gdb_byte.
	* ravenscar-thread.c (get_running_thread_id): Use gdb_byte.
	* remote-m32r-sdi.c (m32r_fetch_register): Use gdb_byte.
	* remote-mips.c (mips_xfer_memory): Use gdb_byte.
	* remote.c (compare_sections_command): Use gdb_byte.
	* score-tdep.c (score7_free_memblock): Change type of parameter to
	gdb_byte *.
	* sh-tdep.c (sh_justify_value_in_reg): Change return type to
	gdb_byte *.  Use gdb_byte.
	(sh_push_dummy_call_fpu): Use gdb_byte.
	(sh_extract_return_value_nofpu, sh_extract_return_value_fpu)
	(sh_store_return_value_nofpu, sh_store_return_value_fpu)
	(sh_register_convert_to_virtual, sh_register_convert_to_raw):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh_pseudo_register_read, sh_pseudo_register_write): Use gdb_byte.
	* sh64-tdep.c (sh64_push_dummy_call): Use gdb_byte.
	(sh64_store_return_value, sh64_register_convert_to_virtual):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh64_pseudo_register_write): Use gdb_byte.
	* solib-darwin.c (darwin_current_sos): Add casts to 'gdb_byte *'.
	* solib-irix.c (fetch_lm_info): Likewise.  Use gdb_byte for byte
	buffer.
	(irix_current_sos): Use gdb_byte.
	* solib-som.c (som_current_sos): Use gdb_byte.
	* sparc-ravenscar-thread.c (supply_register_at_address)
	(sparc_ravenscar_generic_store_registers): Use gdb_byte.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_get_overlay_table): Use gdb_byte.
	* tic6x-tdep.c (tic6x_breakpoint_from_pc): Change return type to
	'gdb_byte *'.
	* tic6x-tdep.h (struct gdbarch_tdep) <breakpoint>: Change type to
	'gdb_byte *'.
	* tracepoint.c (tfile_fetch_registers): Use gdb_byte.
	* xstormy16-tdep.c (xstormy16_extract_return_value)
	(xstormy16_store_return_value): Change parameter type to
	'gdb_byte *'.  Adjust.
	(xstormy16_push_dummy_call): Use gdb_byte.
	* xtensa-tdep.c (xtensa_scan_prologue, call0_ret)
	(call0_analyze_prologue, execute_code): Use gdb_byte.
@
text
@d2420 1
a2420 1
	  && tdep->in_solib_call_trampoline (gdbarch, pc, NULL))
d2858 1
a2858 2
hppa_in_solib_call_trampoline (struct gdbarch *gdbarch,
			       CORE_ADDR pc, char *name)
d2863 1
a2863 1
  if (in_plt_section (pc, name) || hppa_in_dyncall (pc))
d2920 1
a2920 1
  if (in_plt_section (pc, NULL))
d2926 1
a2926 1
      if (in_plt_section (pc, NULL))
@


1.287
log
@Use gdb_byte for bytes from the program being debugged.

gdb_byte should be used for bytes from the program being debugged.  We
have many places using char or unsigned char instead all over the
existing ports, and more ends up added over time due to copy/paste as
new code is based on old code.

I've greped the tree for "char buf[", and fixed all I found.

Tested by building with --enable-targets=all.

2013-03-01  Pedro Alves  <palves@@redhat.com>

	Use gdb_byte for bytes from the program being debugged.

	* arm-tdep.c (arm_store_return_value, arm_get_longjmp_target):
	Change type of local 'buf' to gdb_byte.
	* avr-tdep.c (avr_frame_prev_register, avr_push_dummy_call): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* cris-tdep.c (cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache): Likewise.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp)
	(frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Likewise.
	* frv-tdep.c (frv_pseudo_register_write, frv_analyze_prologue): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_find_global_pointer)
	(hppa32_hpux_search_dummy_call_sequence)
	(hppa_hpux_supply_save_state): Likewise.
	* hppa-linux-tdep.c (insns_match_pattern)
	(hppa_linux_find_global_pointer): Likewise.
	* hppa-tdep.c (hppa_in_function_epilogue_p)
	(skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Likewise.
	* i386fbsd-tdep.c (i386fbsd_supply_uthread)
	(i386fbsd_collect_uthread): Likewise.
	* ia64-hpux-tdep.c (ia64_hpux_push_dummy_code): Likewise.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Likewise.
	* ia64-tdep.c (examine_prologue, ia64_frame_cache)
	(ia64_frame_prev_register, ia64_sigtramp_frame_cache)
	(ia64_sigtramp_frame_prev_register, ia64_access_reg)
	(ia64_access_rse_reg, ia64_libunwind_frame_this_id)
	(ia64_libunwind_frame_prev_register)
	(ia64_libunwind_sigtramp_frame_this_id)
	(ia64_find_global_pointer_from_dynamic_section)
	(find_extant_func_descr, find_func_descr, ia64_dummy_id)
	(ia64_unwind_pc): Likewise.
	* iq2000-tdep.c (iq2000_store_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call)
	(m68hc11_extract_return_value): Likewise.
	* m68klinux-nat.c (fetch_register, store_register): Likewise.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_cr32_write)
	(mep_get_insn, mep_push_dummy_call): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips_linux_in_dynsym_stub): Likewise.
	* mn10300-tdep.c (mep_pseudo_cr32_write): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* regcache.c (dump_endian_bytes): Change type of parameter 'buf'
	to gdb_byte.
	* remote-mips.c (mips_set_register): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* score-tdep.c (score7_fetch_inst): Change type of parameter
	'memblock' and local 'buf' to gdb_byte.
	(score7_malloc_and_get_memblock): Change return type to gdb_byte.
	Change type of local 'buf' to gdb_byte.  Adjust.
	(score7_adjust_memblock_ptr): Change type of parameter 'memblock'
	to gdb_byte**.
	(score7_analyze_prologue): Change type of 'memblock' and
	'memblock_ptr' locals to gdb_byte*.
	* sh64-tdep.c (sh64_extract_return_value)
	(sh64_store_return_value): Change type of local 'buf' to gdb_byte.
	* solib-darwin.c (darwin_current_sos, darwin_read_exec_load_addr):
	* solib-pa64.c (pa64_solib_create_inferior_hook)
	(pa64_open_symbol_file_object): Remove local 'buf'.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start)
	(som_open_symbol_file_object): Likewise.
	* solib-spu.c (spu_current_sos): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	* spu-multiarch.c (parse_spufs_run, spu_fetch_registers)
	(spu_store_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	* tic6x-tdep.c (tic6x_get_longjmp_target): Likewise.
	* xstormy16-tdep.c (xstormy16_store_return_value)
	(xstormy16_push_dummy_call, xstormy16_resolve_jmp_table_entry)
	(xstormy16_find_jmp_table_entry): Likewise.
@
text
@d728 1
a728 1
	  char param_val[8];
d931 1
a931 1
	  char tmp[8];
@


1.286
log
@	* hppa-tdep.c (read_unwind_info): Use SECT_OFF_TEXT, not "0".
@
text
@d544 1
a544 1
  char buf[4];
d1449 1
a1449 1
  char buf[4];
d1900 1
a1900 1
	char buf4[4];
@


1.285
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d330 1
a330 1
  text_offset = ANOFFSET (objfile->section_offsets, 0);
@


1.284
log
@gdb/
2012-11-21  Yao Qi  <yao@@codesourcery.com>

	PR tdep/7438
	* gdbarch.sh (smash_text_address): Remove.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arm-tdep.c (arm_smash_text_address): Remove.
	(arm_gdbarch_init): Don't call set_gdbarch_smash_text_address.
	* hppa-tdep.c (hppa_smash_text_address): Remove.
	(hppa_addr_bits_remove): Rename from hppa_smash_text_address.
	(hppa_gdbarch_init): Don't call set_gdbarch_smash_text_address.
	Caller update.
	* coffread.c (coff_symtab_read): Caller update.
	* dbxread.c (process_one_symbol): Likewise.
	* elfread.c (record_minimal_symbol): Likewise.
	* somread.c (som_symtab_read): Likewise.
@
text
@d3 1
a3 2
   Copyright (C) 1986-1987, 1989-1996, 1998-2005, 2007-2012 Free
   Software Foundation, Inc.
@


1.283
log
@        * amd64-tdep.c (amd64_return_value): Revert previous change
        that used TYPE_LENGTH directly.
        * bfin-tdep.c (bfin_extract_return_value): Likewise.
        (bfin_store_return_value): Likewise.
        * cris-tdep.c (cris_store_return_value): Likewise.
        (cris_extract_return_value): Likewise.
        * h8300-tdep.c (h8300_extract_return_value): Likewise.
        * hppa-tdep.c (hppa64_return_value): Likewise.
        * lm32-tdep.c (lm32_store_return_value): Likewise.
        * microblaze-tdep.c (microblaze_store_return_value): Likewise.
        * spu-tdep.c (spu_value_from_register): Likewise.
        * vax-tdep.c (vax_return_value): Likewise.
@
text
@d2643 1
a2643 1
hppa_smash_text_address (struct gdbarch *gdbarch, CORE_ADDR addr)
d3061 1
a3061 2
  set_gdbarch_addr_bits_remove (gdbarch, hppa_smash_text_address);
  set_gdbarch_smash_text_address (gdbarch, hppa_smash_text_address);
@


1.282
log
@        * amd64-tdep.c (amd64_return_value): Use TYPE_LENGTH directly.
        * bfin-tdep.c (bfin_extract_return_value): Likewise.
        (bfin_store_return_value): Likewise.
        * cris-tdep.c (cris_store_return_value): Likewise.
        (cris_extract_return_value): Likewise.
        * h8300-tdep.c (h8300_extract_return_value): Likewise.
        * hppa-tdep.c (hppa64_return_value): Likewise.
        * lm32-tdep.c (lm32_store_return_value): Likewise.
        * microblaze-tdep.c (microblaze_store_return_value): Likewise.
        * spu-tdep.c (spu_value_from_register): Likewise.
        * vax-tdep.c (vax_return_value): Likewise.
@
text
@d1163 1
a1163 1
  if (TYPE_LENGTH (type) > 16)
@


1.281
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d1163 1
a1163 1
  if (len > 16)
@


1.280
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@a545 1
  int off;
a1699 1
  struct symbol *f;
a1738 2
  unsigned long inst;
  int offset;
a1739 1
  char buf[4];
a1790 1
  CORE_ADDR this_sp;
@


1.279
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1117 1
a1117 1
hppa32_return_value (struct gdbarch *gdbarch, struct type *func_type,
d1157 1
a1157 1
hppa64_return_value (struct gdbarch *gdbarch, struct type *func_type,
@


1.278
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d3 2
a4 3
   Copyright (C) 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010,
   2011 Free Software Foundation, Inc.
@


1.278.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 2
   Copyright (C) 1986-1987, 1989-1996, 1998-2005, 2007-2012 Free
   Software Foundation, Inc.
@


1.277
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d2228 1
d2339 1
d2436 1
@


1.276
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* h8300-tdep.c: Comment cleanup, mostly periods and spaces.
	* hppa-hpux-tdep.c: Ditto.
	* hppa-linux-nat.c: Ditto.
	* hppa-linux-tdep.c: Ditto.
	* hppanbsd-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* hppa-tdep.h: Ditto.
	* hpux-thread.c: Ditto.
	* i386-cygwin-tdep.c: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386gnu-nat.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* i386-linux-tdep.c: Ditto.
	* i386-nat.c: Ditto.
	* i386-nat.h: Ditto.
	* i386nbsd-tdep.c: Ditto.
	* i386-sol2-nat.c: Ditto.
	* i386-stub.c: Ditto.
	* i386-tdep.c: Ditto.
	* i386-tdep.h: Ditto.
	* i387-tdep.c: Ditto.
	* ia64-linux-nat.c: Ditto.
	* ia64-linux-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* infcall.c: Ditto.
	* infcall.h: Ditto.
	* infcmd.c: Ditto.
	* inferior.c: Ditto.
	* inferior.h: Ditto.
	* infloop.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* interps.c: Ditto.
	* interps.h: Ditto.
	* iq2000-tdep.c: Ditto.
	* irix5-nat.c: Ditto.
	* jit.c: Ditto.
	* jit.h: Ditto.
	* jv-exp.y: Ditto.
	* jv-lang.c: Ditto.
	* jv-lang.h: Ditto.
	* jv-typeprint.c: Ditto.
	* jv-valprint.c: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* linespec.c: Ditto.
	* linux-fork.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-thread-db.c: Ditto.
	* lm32-tdep.c: Ditto.
@
text
@d2668 1
a2668 1
static void
d2672 3
a2674 2
    enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
    ULONGEST tmp;
d2676 8
a2683 4
    regcache_raw_read_unsigned (regcache, regnum, &tmp);
    if (regnum == HPPA_PCOQ_HEAD_REGNUM || regnum == HPPA_PCOQ_TAIL_REGNUM)
      tmp &= ~0x3;
    store_unsigned_integer (buf, sizeof tmp, byte_order, tmp);
@


1.275
log
@run copyright.sh for 2011.
@
text
@d33 1
a33 1
/* For argument passing to the inferior */
d60 1
a60 1
/* Get at various relevent fields of an instruction word. */
d71 1
a71 1
   instructions. */
d74 1
a74 1
   value. */
d82 1
a82 1
/* For many immediate values the sign bit is the low bit! */
d91 1
a91 1
   (MSB = 0). */
d99 1
a99 1
/* extract the immediate field from a ld{bhw}s instruction */
d107 1
a107 1
/* extract the immediate field from a break instruction */
d115 1
a115 1
/* extract the immediate field from a {sr}sm instruction */
d123 1
a123 1
/* extract a 14 bit immediate field */
d131 1
a131 1
/* extract a 21 bit constant */
d153 1
a153 1
   19 bit signed value. */
d225 2
a226 2
		     asection *section, unsigned int entries, unsigned int size,
		     CORE_ADDR text_offset)
d240 1
a240 1
	 be segment relative offsets instead of absolute addresses. 
d308 1
a308 1
	  /* Stub unwinds are handled elsewhere. */
d343 1
a343 1
     to do a lookup with bfd_get_section_by_name. 
d421 1
a421 1
	  /* Convert offset & size into region_start and region_end.  
d467 1
a467 1
  /* A function at address 0?  Not in HP-UX! */
d492 1
a492 1
    /* First, check the cache */
d504 1
a504 1
    /* Not in the cache, do a binary search */
d536 1
a536 1
   itself or an instruction which destroys the function's stack frame. 
d718 1
a718 1
      /* The first parameter goes into sp-36, each stack slot is 4-bytes.  
d832 1
a832 1
     address */
d1038 1
a1038 1
		 slot, which is filled with garbage. If necessary,
d1309 1
a1309 1
   to the stack pointer or zero for no adjustment. 
d1401 1
a1401 1
  /* Does it look like a stwm?  GCC & HPC may use this in prologues. */
d1427 1
a1427 1
  /* is this an FSTD ? */
d1432 1
a1432 1
  /* is this an FSTW ? */
d1441 1
a1441 1
   to reach some "real" code. 
d1467 1
a1467 1
  /* If we are not at the beginning of a function, then return now. */
d1717 1
a1717 1
     examine instructions in that case. 
d1731 1
a1731 1
   returns an address that (if we're lucky) follows the prologue.  
d1734 1
a1734 1
   It doesn't necessarily skips all the insns in the prologue. In fact
d1869 1
a1869 1
       function.  
d1880 1
a1880 1
       function (or 0).  We can do better than that by using unwind records.  
d1882 1
a1882 1
       indicates that it includes the entry point of the function.  
d1974 2
a1975 1
		  offset = (inst & 0x1 ? -1 << 13 : 0) | (((inst >> 4) & 0x3ff) << 3);
d1985 2
a1986 1
		  cache->saved_regs[reg].addr = (u->Total_frame_size << 3) + offset;
d2026 1
a2026 1
	/* Quit if we hit any kind of branch the previous iteration. */
d2211 2
a2212 1
  return hppa_frame_prev_register_helper (this_frame, info->saved_regs, regnum);
d2328 2
a2329 2
  struct hppa_frame_cache *info = 
    hppa_fallback_frame_cache (this_frame, this_cache);
d2331 2
a2332 1
  return hppa_frame_prev_register_helper (this_frame, info->saved_regs, regnum);
d2411 2
a2412 1
  return hppa_frame_prev_register_helper (this_frame, info->saved_regs, regnum);
d3151 1
a3151 1
  /* Debug this files internals. */
@


1.274
log
@	* hppa-tdep.c (unwind_command): Use host_address_to_string function
	to display a host address.
	* monitor.c (monitor_read_memory): Likewise.
	* xtensa-tdep.c (xtensa_push_dummy_call): Likewise.
@
text
@d4 2
a5 2
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
@


1.273
log
@Delete unused or undefined functions.

        * breakpoint.c (ep_parse_optional_filename): Delete.
        * dcache.c (dcache_write_line): Remove declaration.
        * infrun.c (build_infrun): Remove declaration.
        * tracepoint.c (tracepoint_save_command): Remove declaration.
        * linux-nat.c (init_lwp_list): Delete. No longer used.
        * event-loop.c (check_async_signal_handlers): Delete declaration.
        * infrun.c (init_execution_control_state): Delete.
        (proceed): Update comment to avoid mentioning
        init_execution_control_state.
        * target.c (kill_or_be_killed, nosupport_runtime): Delete.
        * ada-lang.c (ada_to_static_fixed_value): Delete.
        * scm-lang.c (evaluate_subexp_scm): Delete declaration.
        * cp-namespace.c (cp_copy_usings): Delete.
        * xml-syscall.c (xml_number_of_syscalls): Delete.
        * progspace.c (find_program_space_by_num): Delete.
        * inflow.c (handle_sigio): Delete declaration.
        * hppa-tdep.c (hppa_alignof): Delete.
        * mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset)
        (mipsnbsd_core_osabi_sniffer): Delete.
@
text
@d2509 1
a2509 1
  printf_unfiltered ("unwind_table_entry (0x%lx):\n", (unsigned long)u);
@


1.272
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a1307 35
/* return the alignment of a type in bytes. Structures have the maximum
   alignment required by their fields. */

static int
hppa_alignof (struct type *type)
{
  int max_align, align, i;
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_PTR:
    case TYPE_CODE_INT:
    case TYPE_CODE_FLT:
      return TYPE_LENGTH (type);
    case TYPE_CODE_ARRAY:
      return hppa_alignof (TYPE_INDEX_TYPE (type));
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      max_align = 1;
      for (i = 0; i < TYPE_NFIELDS (type); i++)
	{
	  /* Bit fields have no real alignment. */
	  /* if (!TYPE_FIELD_BITPOS (type, i)) */
	  if (!TYPE_FIELD_BITSIZE (type, i))	/* elz: this should be bitsize */
	    {
	      align = hppa_alignof (TYPE_FIELD_TYPE (type, i));
	      max_align = max (max_align, align);
	    }
	}
      return max_align;
    default:
      return 4;
    }
}

@


1.271
log
@        gdb/
        * frame.c (get_frame_id): Default to outer_frame_id if the this_id
        method does not supply an ID.  Assert that the result is not
        null_frame_id.
        (outer_frame_id): New.
        (frame_id_p): Accept outer_frame_id.
        (frame_id_eq): Allow outer_frame_id to be equal to itself.
        (frame_find_by_id): Revert previous local workarounds.
        (get_prev_frame_1): Adjust end-of-stack check to test outer_frame_id.
        * frame.h (null_frame_id, frame_id_p): Update comments.
        (outer_frame_id): Declare.
        * infrun.c (handle_inferior_event): Do not treat all steps from the
        outermost frame as subroutine calls.

        * libunwind-frame.c (libunwind_frame_this_id): Do not clear THIS_ID.
        * hppa-tdep.c (hppa_stub_frame_this_id): Likewise.
        * ia64-tdep.c (ia64_frame_this_id): Likewise.
        (ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id):
        Use outer_frame_id instead of null_frame_id.
        * amd64obsd-tdep.c (amd64obsd_trapframe_cache): Use outer_frame_id.
        * i386obsd-tdep.c (i386obsd_trapframe_cache): Likewise.
        * inline-frame.c (inline_frame_this_id): Refuse outer_frame_id.
        * thread.c (restore_selected_frame): Update comment and remove
        frame_id_p check.

        gdb/doc/
        * gdbint.texinfo (Unwinding the Frame ID): Reference outer_frame_id.
@
text
@d4 1
a4 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
@


1.270
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@a2429 2
  else
    *this_id = null_frame_id;
@


1.269
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d543 1
d553 1
a553 1
  inst = extract_unsigned_integer (buf, 4);
d694 2
d743 2
a744 1
	      store_unsigned_integer (param_val, 4, struct_end - struct_ptr);
d752 1
a752 1
	      store_unsigned_integer (param_val, param_len,
d905 1
a905 1
hppa64_convert_code_addr_to_fptr (CORE_ADDR code)
d907 1
d938 1
a938 1
	  opdaddr = extract_unsigned_integer (tmp, sizeof (tmp));
d955 1
d1053 3
a1055 2
	  fptr = hppa64_convert_code_addr_to_fptr (codeptr);
	  store_unsigned_integer (fptrbuf, TYPE_LENGTH (type), fptr);
d1486 1
d1568 1
a1568 1
      inst = extract_unsigned_integer (buf, 4);
d1619 1
a1619 1
	      inst = extract_unsigned_integer (buf, 4);
d1632 1
a1632 1
      next_inst = extract_unsigned_integer (buf, 4);
d1663 1
a1663 1
	      inst = extract_unsigned_integer (buf, 4);
d1669 1
a1669 1
	      next_inst = extract_unsigned_integer (buf, 4);
d1827 2
d1953 1
a1953 1
	inst = extract_unsigned_integer (buf4, sizeof buf4);
d2122 1
a2122 2
            cache->base = read_memory_integer
			    (this_sp, gdbarch_ptr_bit (gdbarch) / 8);
d2277 2
d2303 1
a2303 1
	  insn = read_memory_unsigned_integer (pc, 4);
d2458 1
a2458 1
	  && tdep->in_solib_call_trampoline (pc, NULL))
d2704 1
d2710 1
a2710 1
    store_unsigned_integer (buf, sizeof tmp, tmp);
d2725 1
d2735 2
a2736 1
      pc = extract_unsigned_integer (value_contents_all (pcoq_val), size);
d2834 2
a2835 2
hppa_match_insns (CORE_ADDR pc, struct insn_pattern *pattern,
		  unsigned int *insn)
d2837 1
d2846 1
a2846 1
      insn[i] = extract_unsigned_integer (buf, HPPA_INSN_SIZE);
d2861 2
a2862 2
hppa_match_insns_relaxed (CORE_ADDR pc, struct insn_pattern *pattern,
			  unsigned int *insn)
d2870 2
a2871 1
    if (hppa_match_insns (pc - offset * HPPA_INSN_SIZE, pattern, insn))
d2890 2
a2891 1
hppa_in_solib_call_trampoline (CORE_ADDR pc, char *name)
d2907 6
a2912 4
  return (hppa_match_insns_relaxed (pc, hppa_import_stub, insn)
	  || hppa_match_insns_relaxed (pc, hppa_import_pic_stub, insn)
	  || hppa_match_insns_relaxed (pc, hppa_long_branch_stub, insn)
	  || hppa_match_insns_relaxed (pc, hppa_long_branch_pic_stub, insn));
d2939 2
a2940 2
  dp_rel = hppa_match_insns (pc, hppa_import_stub, insn);
  if (dp_rel || hppa_match_insns (pc, hppa_import_pic_stub, insn))
d2962 1
a2962 1
  	  if (!hppa_match_insns (pc, hppa_plt_stub, insn))
@


1.268
log
@	* gdbtypes.h (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(init_float_type, init_complex_type): Add prototypes.
	* gdbtypes.c (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(build_flt): Rename to ...
	(init_float_type): ... this.  Make global.
	(build_complex): Rename to ...
	(init_complex_type): ... this.  Make global.  Remove BIT argument.
	(gdbtypes_post_init): Update calls.

	* ada-lang.c (ada_language_arch_info): Use init_float_type.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* f-lang.c (build_fortran_types): Use init_float_type and
	init_complex_type.

	* target-descriptions.c (tdesc_gdb_type): Call init_float_type instead
	of using builtin_type_ieee_single, builtin_type_ieee_double, or
	builtin_type_arm_ext.

	* ia64-tdep.h (struct gdbarch_tdep): Add ia64_ext_type member.
	* ia64-tdep.c (builtin_type_ia64_ext): Remove.
	(_initialize_ia64_tdep): Do not initialize it.
	(floatformat_valid, floatformat_ia64_ext, floatformats_ia64_ext):
	Move up.
	(ia64_ext_type): New function.
	(ia64_register_reggroup_p, ia64_convert_register_p,
	ia64_register_to_value, ia64_value_to_register,
	ia64_extract_return_value, ia64_store_return_value): Use ia64_ext_type
	instead of builtin_type_ia64_ext.

	* i386-tdep.h (struct gdbarch_tdep): Add i387_ext_type member.
	(i387_ext_type): Add prototype.
	* i386-tdep.c (i387_ext_type): New function.
	(i386_extract_return_value, i386_store_return_value,
	i386_register_type): Use it instead of builtin_type_i387_ext.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* i387-tdep.c (print_i387_value, i387_register_to_value,
	i387_value_to_register): Likewise.
	(print_i387_value, print_i387_ext): Add GDBARCH argument.
	(print_i387_ext, i387_print_float_info): Pass to subroutines.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68881_ext_type member.
	* m68k-tdep.c (m68881_ext_type): New function.
	(m68k_register_type, m68k_convert_register_p): Use it instead
	of builtin_type_m68881_ext.

	* arm-tdep.h (struct gdbarch_tdep): Add arm_ext_type member.
	* arm-tdep.c (arm_ext_type): New function.
	(arm_register_type): Use it instead of builtin_type_arm_ext.

	* alpha-tdep.c (alpha_register_type): Use builtin types
	instead of builtin_type_ieee_double.

	* mips-tdep.c (mips_float_register_type, mips_double_register_type):
	Remove.
	(mips_register_type): Use builtin types instead of
	builtin_type_ieee_single and builtin_type_ieee_double.
	(mips_print_fp_register): Use builtin types instead of
	mips_float_register_type and mips_double_register_type.

	* hppa-tdep.c (hppa32_register_type, hppa64_register_type):
	Use builtin types instead of builtin_type_ieee_single and
	builtin_type_ieee_double.
@
text
@d464 2
a465 2
    fprintf_unfiltered (gdb_stdlog, "{ find_unwind_entry 0x%s -> ",
		        paddr_nz (pc));
d499 2
a500 2
	  fprintf_unfiltered (gdb_stdlog, "0x%s (cached) }\n",
            paddr_nz ((uintptr_t) ui->cache));
d517 2
a518 2
	      fprintf_unfiltered (gdb_stdlog, "0x%s }\n",
                paddr_nz ((uintptr_t) ui->cache));
d1836 2
a1837 2
        fprintf_unfiltered (gdb_stdlog, "base=0x%s (cached) }", 
          paddr_nz (((struct hppa_frame_cache *)*this_cache)->base));
d1938 2
a1939 1
	    error (_("Cannot read instruction at 0x%s."), paddr_nz (pc));
d2068 5
a2072 5
      fprintf_unfiltered (gdb_stdlog, " (this_sp=0x%s, pc=0x%s, "
		          "prologue_end=0x%s) ",
		          paddr_nz (this_sp),
			  paddr_nz (get_frame_pc (this_frame)),
			  paddr_nz (prologue_end));
d2103 2
a2104 2
	  fprintf_unfiltered (gdb_stdlog, " (base=0x%s) [frame pointer]",
 	    paddr_nz (cache->base));
d2116 2
a2117 2
	      fprintf_unfiltered (gdb_stdlog, " (base=0x%s) [saved]",
			          paddr_nz (cache->base));
d2125 2
a2126 2
	  fprintf_unfiltered (gdb_stdlog, " (base=0x%s) [unwind adjust]",
			      paddr_nz (cache->base));
d2210 2
a2211 2
    fprintf_unfiltered (gdb_stdlog, "base=0x%s }", 
      paddr_nz (((struct hppa_frame_cache *)*this_cache)->base));
d2537 1
a2537 2
  printf_unfiltered ("\tregion_start = ");
  print_address (u->region_start, gdb_stdout);
d2540 1
a2540 2
  printf_unfiltered ("\n\tregion_end = ");
  print_address (u->region_end, gdb_stdout);
d2945 2
a2946 1
	      warning (_("Cannot resolve PLT stub at 0x%s."), paddr_nz (pc));
@


1.267
log
@	* gdbtypes.h (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(struct builtin_type): New members builtin_int0, builtin_int8,
	builtin_uint8, builtin_int16, builtin_uint16, builtin_int32,
	builtin_uint32, builtin_int64, builtin_uint64, builtin_int128,
	and builtin_uint128.
	* gdbtypes.c (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize fixed-size integer types.

	* dwarf2expr.c (unsigned_address_type, signed_address_type): Add
	GDBARCH argument.  Return platform-specific type.
	(dwarf2_read_address, execute_stack_op): Update calls.

	* target-descriptions.c (tdesc_gdb_type): Use platform-specific types
	instead of global builtin_int_... variables.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	* printcmd.c (do_examine): Likewise.
	* jv-exp.y (parse_number): Likewise.

	* alpha-tdep.c (alpha_register_type, alpha_push_dummy_call,
	alpha_store_return_value): Likewise.
	* amd64-linux-tdep.c (amd64_linux_register_type): Likewise.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c h8300_register_type): Likewise.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_register_type,
	hppa64_register_type): Likewise.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Likewise.
	* iq2000-tdep.c (iq2000_register_type): Likewise.
	* lm32-tdep.c (lm32_register_type, lm32_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68hc11-tdep.c (m68hc11_register_type, m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m88k-tdep.c (m88k_register_type, m88k_store_arguments): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_register_type, mips_pseudo_register_type,
	mips_print_fp_register): Likewise.
	* moxie-tdep.c (moxie_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type, mt_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* score-tdep.c (score_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type, sparc32_store_arguments):
	Likewise.
	* sparc64-tdep.c (sparc64_register_type, sparc64_store_arguments):
	Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* xstormy16-tdep.c (xstormy16_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* mt-tdep.c (struct gdbarch_tdep): New data structure.
	(mt_gdbarch_init): Alloc TDEP structures.
	(mt_register_type): Cache coprocessor type in TDEP instead of
	static global variable.

	* xtensa-tdep.h (struct gdbarch_tdep): Add type_entries member.
	* xtensa-tdep.c (type_entries): Remove.
	(xtensa_register_type): Cache fixed-size types in TDEP instead
	of in global variable.
@
text
@d2615 1
a2615 1
     return builtin_type_ieee_single;
d2624 1
a2624 1
     return builtin_type_ieee_double;
@


1.266
log
@	* frame.c (frame_unwind_id): Renamed to ...
	(frame_unwind_caller_id): ... this.  All callers updated.
	(frame_pc_unwind): Renamed to ...
	(frame_unwind_caller_pc): ... this.  All callers updated.
	* frame.h: Document frame_unwind_caller_WHAT functions.
	(frame_unwind_id): Renamed to ...
	(frame_unwind_caller_id): ... this.
	(frame_pc_unwind): Renamed to ...
	(frame_unwind_caller_pc): ... this.
	* hppa-tdep.c (hppa_find_unwind_entry_in_block): Correct comment.
	* stack.c (parse_frame_specification_1): Do not rely on
	frame_unwind_id.
@
text
@d978 1
a978 1
	      arg = value_cast (builtin_type_int64, arg);
d2613 1
a2613 1
     return builtin_type_uint32;
d2622 1
a2622 1
     return builtin_type_uint64;
@


1.265
log
@	* hppa-tdep.c (_initialize_hppa_tdep): Add declaration.
@
text
@d1802 1
a1802 1
     value of frame_pc_unwind.  That might be happening already;
@


1.264
log
@	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
        * alpha-linux-tdep.c (alpha_linux_regset_from_core_section): Make
	it static.
        * alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Declare.
        * amd64fbsd-tdep.c (amd64fbsd_init_abi): Make it static.
        * amd64nbsd-tdep.c (_initialize_amd64nbsd_ndep): Rename to ...
	(_initialize_amd64nbsd_tdep): ... this.
	* arm-linux-tdep.c (arm_linux_software_single_step): Make it static.
	(_initialize_arm_linux_tdep): Declare.
	* armbsd-tdep.c (armbsd_fpreg_offset): Make it static.
	* armnbsd-tdep.c (_initialize_arm_netbsd_tdep): Declare.
	* armobsd-tdep.c (_initialize_armobsd_tdep): Declare.
	* avr-tdep.c (avr_return_value): Make it static.
	(avr_frame_unwind_cache): Ditto.
	* bsd-uthread.c (bsd_uthread_inferior_created): Ditto.
	(bsd_uthread_solib_loaded): Ditto.
	(bsd_uthread_solib_unloaded): Ditto.
	(bsd_uthread_target): Ditto.
	(_initialize_bsd_uthread): Declare.
	* cris-tdep.c (crisv32_single_step_through_delay): Make it static.
	(cris_frame_unwind_cache): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_use_struct_convention): Ditto.
	(h8300h_use_struct_convention): Ditto.
	* hppa-tdep.c (hppa_sign_extend, hppa_low_hppa_sign_extend):
	Ditto.
	* hppa-tdep.h (hppa_low_sign_extend, hppa_sign_extend): Delete
	declarations.
	* hppabsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_find_global_pointer): Make it static.
	* hppabsd-tdep.h: New.
	* hppanbsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Remove declaration.
	(_initialize_hppabsd_tdep): Remove declaration.
	(_initialize_hppanbsd_tdep): Declare.
	* hppaobsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Delete declaration.
	(hppaobsd_init_abi): Make it static.
	* i386-nto-tdep.c (_initialize_i386nto_tdep): Declare.
	* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Declare.
	* ia64-linux-tdep.c (_initialize_ia64_linux_tdep): Declare.
	* ia64-tdep.c (ia64_register_reggroup_p): Make it static.
	* iq2000-tdep.c (_initialize_iq2000_tdep): Declare.
	* m32c-tdep.c (m32c_register_reggroup_p): Make it static.
	(m32c_analyze_prologue, m32c_virtual_frame_pointer): Ditto.
	(_initialize_m32c_tdep): Declare.
	* m32r-rom.c (_initialize_m32r_rom): Declare.
	* m32r-tdep.c (m32r_skip_prologue): Make it static.
	(m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Make it static.
	(m68hc11_return_value): Ditto.
	* m68klinux-tdep.c (_initialize_m68k_linux_tdep): Declare.
	* m88k-tdep.c (m88k_frame_cache): Make it static.
	* mep-tdep.c (mep_gdb_print_insn): Ditto.
	(mep_return_value): Ditto.
	(_initialize_mep_tdep): Declare.
	* mips-irix-tdep.c (_initialize_mips_irix_tdep): Declare.
	* mips-linux-tdep.c (supply_64bit_reg): Make it static.
	(mips_linux_syscall_next_pc): Ditto.
	(_initialize_mips_linux_tdep): Declare.
	* mips-tdep.c (mips_single_step_through_delay): Make it static.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Declare.
	* mn10300-linux-tdep.c (_initialize_mn10300_linux_tdep): Declare.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Declare.
	* mt-tdep.c (_initialize_mt_tdep): Declare.
	* nbsd-tdep.c: Include nbsd-tdep.h.
	* nto-tdep.c (find_load_phdr): Make it static.
	(_initialize_nto_tdep): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Make it
	static.
	(_initialize_ppc_linux_tdep): Declare.
	* remote-m32r-sdi.c (m32r_can_use_hw_watchpoint)
	(m32r_insert_watchpoint, m32r_remove_watchpoint)
	(m32r_stopped_data_address, m32r_stopped_by_watchpoint): Make
	static.
	* rs6000-aix-tdep.c (_initialize_rs6000_aix_tdep): Declare.
	* rs6000-nat.c: Include xcoffread.h.
	(find_toc_address): Don't extern declare get_toc_offset.  Adjust
	to call xcoff_get_to_offset.
	* rs6000-tdep.c (ppc_vsx_support_p, ppc_displaced_step_fixup)
	(rs6000_skip_main_prologue, rs6000_in_solib_return_trampoline)
	(rs6000_skip_trampoline_code): Make static.
	* s390-tdep.c (s390_regset_from_core_section): Ditto.
	* sh-tdep.c (sh_register_reggroup_p): Ditto.
	* shnbsd-tdep.c (shnbsd_regset_from_core_section): Ditto.
	(_initialize_shnbsd_tdep): Declare.
	* solib-frv.c (displacement_from_map): Make static.
	(_initialize_frv_solib): Declare.
	* solib-irix.c (fetch_lm_info): Make static.
	(_initialize_irix_solib): Declare.
	* solib-som.c: Include solib-som.h.
	(som_solib_select): Line break.
	* sparc-tdep.c (sparc_regset_from_core_section): Make static.
	* sparcnbsd-tdep.c (_initialize_sparnbsd_tdep): Rename to ...
	(_initialize_sparcnbsd_tdep): ... this.
	* spu-tdep.c (spu_software_single_step): Make it static.
	(_initialize_spu_tdep): Declare.
	* vax-tdep.c (vax_frame_cache): Make it static.
	* xcoffread.c: Include xcoffread.h.
	(get_toc_offset): Rename to ...
	(xcoff_get_toc_offset): ... this.
	(_initialize_xcoffread): Declare.
	* xcoffread.h: New.
	* xtensa-linux-tdep.c (_initialize_xtensa_linux_tdep): Declare.
	* xtensa-tdep.c (xtensa_skip_prologue, xtensa_derive_tdep): Make
	static.
	(_initialize_xtensa_tdep): Declare.
@
text
@d3148 3
@


1.263
log
@        Updated copyright notices for most files.
@
text
@d76 1
a76 1
int
d84 1
a84 1
int
@


1.262
log
@	Fix TYPE_HIGH_BOUND for TYPE_CODE_RANGE using arbitrary TYPE_NFIELDS in
	preparation for supporting DW_AT_byte_stride.
	* ada-lang.c (packed_array_type, ada_index_type): Use TYPE_INDEX_TYPE.
	(ada_array_bound_from_type): Move `index_type' declaration to the
	function start.  New variable `retval'.  Return the bounds for
	TYPE_CODE_RANGE using TYPE_LOW_BOUND and TYPE_HIGH_BOUND.  Abort on
	invalid index type codes.
	* ada-typeprint.c (print_range): Set `upper_bound' for TYPE_CODE_RANGE
	now using TYPE_HIGH_BOUND.
	* ada-valprint.c (val_print_packed_array_elements): Use `index_type'.
	* eval.c (evaluate_subexp_standard): Use TYPE_INDEX_TYPE.
	* gdbtypes.c (create_range_type): Use TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	refer to the number of fields only through TYPE_NFIELDS.
	(create_array_type): Use TYPE_INDEX_TYPE.
	(check_typedef): Use TYPE_INDEX_TYPE, TYPE_LOW_BOUND, TYPE_HIGH_BOUND.
	* gdbtypes.h (TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED)
	(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED): Use TYPE_INDEX_TYPE.
	(TYPE_ARRAY_UPPER_BOUND_VALUE, TYPE_ARRAY_LOWER_BOUND_VALUE): Use
	TYPE_INDEX_TYPE, TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	* hppa-tdep.c (hppa_alignof <TYPE_CODE_ARRAY>): Use TYPE_INDEX_TYPE.
	* mdebugread.c (parse_type): Use TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	* valarith.c (value_bit_index): Use TYPE_INDEX_TYPE.
@
text
@d4 1
a4 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
@


1.261
log
@	* hppa-linux-tdep.c (hppa_dwarf_reg_to_regnum): Remove surrounding
	"#if 0" "#endif".  Fix mapping of DWARF DBX registers to GDB registers.
	Correct arguments and improve comments.
	(hppa_linux_init_abi): Call set_gdbarch_dwarf2_reg_to_regnum.  Delete
	disabled code.
	* hppa-tdep.c (hppa64_dwarf_reg_to_regnum): Fix check for floating
	point DBX register, change error to warning, and improve comments.
@
text
@d1316 1
a1316 1
      return hppa_alignof (TYPE_FIELD_TYPE (type, 0));
@


1.260
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d661 1
d665 1
a665 1
  /* r0-r31 and sar map one-to-one.  */
d670 1
a670 1
  if (reg >= 72 || reg < 72 + 28 * 2)
d673 1
a673 1
  error ("Invalid DWARF register num %d.", reg);
@


1.259
log
@	* hppa-tdep.c (internalize_unwinds): Use objfile architecture
	instead of current_gdbarch.
@
text
@d1248 1
d1250 1
a1250 1
      return read_memory_typed_address (plabel, builtin_type_void_func_ptr);
d2902 3
d2915 1
a2915 1
	pc = read_memory_typed_address (pc & ~0x3, builtin_type_void_func_ptr);
d2936 1
a2936 1
      pc = read_memory_typed_address (pc, builtin_type_void_func_ptr);
d2950 1
a2950 1
	  pc = read_memory_typed_address (pc + 8, builtin_type_void_func_ptr);
@


1.258
log
@	* gdbarch.sh (addr_bits_remove): Change type to 'm'.
	(smash_text_address): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.

	* arch-utils.c (core_addr_identity): Add gdbarch parameter.
	* arch-utils.h (core_addr_identity): Likewise.
	* arm-tdep.c (arm_addr_bits_remove): Likewise.
	(arm_smash_text_address): Likewise.
	* hppa-tdep.c (hppa_smash_text_address): Likewise.
	* m88k-tdep.c (m88k_addr_bits_remove): Likewise.
	* s390-tdep.c (s390_addr_bits_remove): Likewise.

	* mips-tdep.c (mips_addr_bits_remove): Add gdbarch parameter.
	Use it instead of current_gdbarch.

	* arm-tdep.c (arm_prologue_prev_register, arm_unwind_pc,
	arm_dwarf2_prev_register): Update calls.
	* m88k-tdep.c (m88k_unwind_pc): Update call.
@
text
@d233 1
d245 1
a245 1
      if (gdbarch_tdep (current_gdbarch)->is_elf && text_offset == 0)
d255 1
a255 1
      else if (gdbarch_tdep (current_gdbarch)->solib_get_text_base)
d257 1
a257 1
	  text_offset = gdbarch_tdep (current_gdbarch)->solib_get_text_base (objfile);
@


1.257
log
@	* arm-tdep.c (arm_pc_is_thumb): Use obj_section_addr.
	* hppa-hpux-tdep.c (hppa_hpux_find_dummy_bpaddr): Likewise.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Use
	obj_section_addr and obj_section_endaddr.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Likewise.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Likewise.
	* ia64-tdep.c (ia64_find_global_pointer): Likewise.
	(find_extant_func_descr): Likewise.
	* solib-frv.c (frv_relocate_main_executable): Use
	obj_section_addr.
	* xstormy16-tdep.c (xstormy16_find_jmp_table_entry): Use
	obj_section_addr and obj_section_endaddr.
@
text
@d2666 1
a2666 1
hppa_smash_text_address (CORE_ADDR addr)
@


1.256
log
@Revert frame_unwind_caller_pc / frame_unwind_caller_id.
@
text
@d915 1
a915 1
        break;
d922 4
a925 2
      for (addr = opd->addr; addr < opd->endaddr; addr += 2 * 8)
        {
d933 1
a933 1
          if (opdaddr == code)
@


1.255
log
@	* frame.c (frame_unwind_id): Renamed to ...
	(frame_unwind_caller_id): ... this.  All callers updated.
	(frame_pc_unwind): Renamed to ...
	(frame_unwind_caller_pc): ... this.  All callers updated.
	* frame.h: Document frame_unwind_caller_WHAT functions.
	(frame_unwind_id): Renamed to ...
	(frame_unwind_caller_id): ... this.
	(frame_pc_unwind): Renamed to ...
	(frame_unwind_caller_pc): ... this.
	* hppa-tdep.c (hppa_find_unwind_entry_in_block): Correct comment.
	* stack.c (parse_frame_specification_1): Do not rely on
	frame_unwind_id.
@
text
@d1797 1
a1797 1
     value of gdbarch_unwind_pc.  That might be happening already;
@


1.254
log
@* dwarf2-frame.c (dwarf2_frame_cache): Update comment.

* frame.c (frame_unwind_address_in_block): Delete.
(get_frame_address_in_block): Do not use it.  Check the type
of the next frame first.
(frame_cleanup_after_sniffer): Update comment.
* frame.h (frame_unwind_address_in_block): Delete prototype.
* hppa-tdep.c (hppa_find_unwind_entry_in_block): Update comment.
@
text
@d1797 1
a1797 1
     value of frame_pc_unwind.  That might be happening already;
@


1.253
log
@* frame.c (frame_func_unwind): Delete.

(get_frame_func): Do not use it.
* frame.h (frame_func_unwind): Delete prototype.
* hppa-tdep.c (hppa_frame_cache): Update comment.
* rs6000-tdep.c (rs6000_frame_cache): Update comment.
@
text
@d1795 1
a1795 1
     result of frame_unwind_address_in_block implies a problem.
@


1.252
log
@	* Makefile.in (GNULIB_H): Use GNULIB_STDINT_H.
	(gdb_stdint_h, gdb_stdint.h, stamp-int): Delete.  Remove
	all dependencies on $(gdb_stdint_h).
	(distclean): Do not delete gdb_stdint.h.
	* acinclude.m4: Do not use stdint.m4.
	* configure.ac: Set GNULIB_STDINT_H.  Remove tests for stdint.h,
	uintptr_t, and gdb_stdint.h.
	* defs.h: Include <stdint.h>.
	* gdb_thread_db.h: Assume stdint.h is already included.
	* breakpoint.c, findcmd.c, hppa-tdep.c, inf-ptrace.c, proc-service.c,
	rs6000-nat.c, spu-linux-nat.c, target.c, win32-nat.c: Do not
	include gdb_stdint.h.
	* configure, config.in: Regenerate.
@
text
@d1897 3
a1899 3
    /* We used to use frame_func_unwind () to locate the beginning of the
       function to pass to skip_prologue ().  However, when objects are 
       compiled without debug symbols, frame_func_unwind can return the wrong 
@


1.251
log
@	* gdbarch.sh: Delete dwarf_reg_to_regnum.
	* gdbarch.c, gdbarch.h: Regenerated.
	* amd64-tdep.c, arm-tdep.c, h8300-tdep.c, hppa-linux-tdep.c,
	hppa-tdep.c, i386-tdep.c, m32c-tdep.c, m68k-tdep.c, mips-tdep.c,
	s390-tdep.c, xtensa-tdep.c: Do not set dwarf_reg_to_regnum.

	* gdbint.texinfo (Target Conditionals): Delete entry for
	gdbarch_dwarf_reg_to_regnum.
@
text
@a31 1
#include "gdb_stdint.h"
@


1.250
log
@        * hppa-tdep.h, hppa-tdep.c, hppa-hpux-tdep.c: Update for unwinder
        changes.
@
text
@a3037 1
        set_gdbarch_dwarf_reg_to_regnum (gdbarch, hppa64_dwarf_reg_to_regnum);
@


1.249
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d1789 1
d1791 1
a1791 1
hppa_find_unwind_entry_in_block (struct frame_info *f)
d1793 1
a1793 1
  CORE_ADDR pc = frame_unwind_address_in_block (f, NORMAL_FRAME);
d1801 1
a1801 1
  pc = gdbarch_addr_bits_remove (get_frame_arch (f), pc);
d1812 1
a1812 1
hppa_frame_cache (struct frame_info *next_frame, void **this_cache)
d1814 1
a1814 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d1827 1
a1827 1
      frame_relative_level(next_frame));
d1838 1
a1838 1
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d1841 1
a1841 1
  u = hppa_find_unwind_entry_in_block (next_frame);
d1911 1
a1911 1
      start_pc = frame_func_unwind (next_frame, NORMAL_FRAME);
d1914 1
a1914 1
    end_pc = frame_pc_unwind (next_frame);
d1932 1
a1932 2
	if (!safe_frame_unwind_memory (next_frame, pc, buf4, 
				       sizeof buf4)) 
d2058 2
a2059 1
    CORE_ADDR this_sp = frame_unwind_register_unsigned (next_frame, HPPA_SP_REGNUM);
d2066 1
a2066 1
			  paddr_nz (frame_pc_unwind (next_frame)),
d2087 1
a2087 1
     fp = frame_unwind_register_unsigned (next_frame, HPPA_FP_REGNUM);
d2092 1
a2092 1
     if (frame_pc_unwind (next_frame) >= prologue_end
d2139 1
a2139 1
	  ULONGEST r31 = frame_unwind_register_unsigned (next_frame, 31);
d2156 2
a2157 1
	  ULONGEST rp = frame_unwind_register_unsigned (next_frame, HPPA_RP_REGNUM);
d2181 1
a2181 1
      ULONGEST r1 = frame_unwind_register_unsigned (next_frame, 1);
d2201 1
a2201 3
      {
        tdep->unwind_adjust_stub (next_frame, cache->base, cache->saved_regs);
      }
d2211 2
a2212 2
hppa_frame_this_id (struct frame_info *next_frame, void **this_cache,
			   struct frame_id *this_id)
d2215 1
a2215 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d2218 2
a2219 2
  info = hppa_frame_cache (next_frame, this_cache);
  u = hppa_find_unwind_entry_in_block (next_frame);
d2224 17
a2240 10
static void
hppa_frame_prev_register (struct frame_info *next_frame,
			  void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, gdb_byte *valuep)
{
  struct hppa_frame_cache *info = hppa_frame_cache (next_frame, this_cache);
  hppa_frame_prev_register_helper (next_frame, info->saved_regs, regnum,
		                   optimizedp, lvalp, addrp, realnump, valuep);
d2247 3
a2249 1
  hppa_frame_prev_register
a2251 9
static const struct frame_unwind *
hppa_frame_unwind_sniffer (struct frame_info *next_frame)
{
  if (hppa_find_unwind_entry_in_block (next_frame))
    return &hppa_frame_unwind;

  return NULL;
}

d2261 1
a2261 1
hppa_fallback_frame_cache (struct frame_info *next_frame, void **this_cache)
d2271 1
a2271 1
			frame_relative_level (next_frame));
d2275 1
a2275 1
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d2277 1
a2277 1
  start_pc = frame_func_unwind (next_frame, NORMAL_FRAME);
d2280 1
a2280 1
      CORE_ADDR cur_pc = frame_pc_unwind (next_frame);
d2310 1
a2310 1
  cache->base = frame_unwind_register_unsigned (next_frame, HPPA_SP_REGNUM);
d2323 1
a2323 1
      rp = frame_unwind_register_unsigned (next_frame, HPPA_RP_REGNUM);
d2331 1
a2331 1
hppa_fallback_frame_this_id (struct frame_info *next_frame, void **this_cache,
d2335 3
a2337 3
    hppa_fallback_frame_cache (next_frame, this_cache);
  (*this_id) = frame_id_build (info->base,
			       frame_func_unwind (next_frame, NORMAL_FRAME));
d2340 3
a2342 6
static void
hppa_fallback_frame_prev_register (struct frame_info *next_frame,
			  void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, gdb_byte *valuep)
d2345 3
a2347 3
    hppa_fallback_frame_cache (next_frame, this_cache);
  hppa_frame_prev_register_helper (next_frame, info->saved_regs, regnum,
		                   optimizedp, lvalp, addrp, realnump, valuep);
d2354 3
a2356 1
  hppa_fallback_frame_prev_register
a2358 6
static const struct frame_unwind *
hppa_fallback_unwind_sniffer (struct frame_info *next_frame)
{
  return &hppa_fallback_frame_unwind;
}

d2367 1
a2367 1
hppa_stub_frame_unwind_cache (struct frame_info *next_frame,
d2370 1
a2370 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d2379 1
a2379 1
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d2381 1
a2381 1
  info->base = frame_unwind_register_unsigned (next_frame, HPPA_SP_REGNUM);
d2388 1
a2388 1
      u = find_unwind_entry (frame_pc_unwind (next_frame));
d2405 1
a2405 1
hppa_stub_frame_this_id (struct frame_info *next_frame,
d2410 1
a2410 1
    = hppa_stub_frame_unwind_cache (next_frame, this_prologue_cache);
d2413 1
a2413 2
    *this_id = frame_id_build (info->base,
			       frame_func_unwind (next_frame, NORMAL_FRAME));
d2418 3
a2420 6
static void
hppa_stub_frame_prev_register (struct frame_info *next_frame,
			       void **this_prologue_cache,
			       int regnum, int *optimizedp,
			       enum lval_type *lvalp, CORE_ADDR *addrp,
			       int *realnump, gdb_byte *valuep)
d2423 1
a2423 1
    = hppa_stub_frame_unwind_cache (next_frame, this_prologue_cache);
d2425 1
a2425 5
  if (info)
    hppa_frame_prev_register_helper (next_frame, info->saved_regs, regnum,
				     optimizedp, lvalp, addrp, realnump, 
				     valuep);
  else
d2427 2
d2431 4
a2434 8
static const struct frame_unwind hppa_stub_frame_unwind = {
  NORMAL_FRAME,
  hppa_stub_frame_this_id,
  hppa_stub_frame_prev_register
};

static const struct frame_unwind *
hppa_stub_unwind_sniffer (struct frame_info *next_frame)
d2436 2
a2437 2
  CORE_ADDR pc = frame_unwind_address_in_block (next_frame, NORMAL_FRAME);
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d2444 2
a2445 2
    return &hppa_stub_frame_unwind;
  return NULL;
d2448 8
d2457 1
a2457 1
hppa_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d2459 3
a2461 3
  return frame_id_build (frame_unwind_register_unsigned (next_frame,
							 HPPA_SP_REGNUM),
			 frame_pc_unwind (next_frame));
d2704 2
a2705 2
void
hppa_frame_prev_register_helper (struct frame_info *next_frame,
d2707 1
a2707 3
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, gdb_byte *valuep)
d2709 1
a2709 1
  struct gdbarch *arch = get_frame_arch (next_frame);
d2713 5
a2717 8
      if (valuep)
	{
	  int size = register_size (arch, HPPA_PCOQ_HEAD_REGNUM);
	  CORE_ADDR pc;

	  trad_frame_get_prev_register (next_frame, saved_regs,
					HPPA_PCOQ_HEAD_REGNUM, optimizedp,
					lvalp, addrp, realnump, valuep);
d2719 2
a2720 10
	  pc = extract_unsigned_integer (valuep, size);
	  store_unsigned_integer (valuep, size, pc + 4);
	}

      /* It's a computed value.  */
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      return;
d2729 1
a2729 11
    {
      if (valuep)
	store_unsigned_integer (valuep, register_size (arch, regnum), 0);

      /* It's a computed value.  */
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      return;
    }
d2731 1
a2731 2
  trad_frame_get_prev_register (next_frame, saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
d3118 1
a3118 1
  set_gdbarch_unwind_dummy_id (gdbarch, hppa_unwind_dummy_id);
d3125 3
a3127 3
  frame_unwind_append_sniffer (gdbarch, hppa_stub_unwind_sniffer);
  frame_unwind_append_sniffer (gdbarch, hppa_frame_unwind_sniffer);
  frame_unwind_append_sniffer (gdbarch, hppa_fallback_unwind_sniffer);
@


1.248
log
@	* breakpoint.h (breakpoint_restore_shadows): New
	declaration.
	* breakpoint.c (breakpoint_restore_shadows): New.
	(read_memory_nobpt): Delete.
	* gdbcore.h (read_memory_nobpt): Delete declaration.
	* target.c (memory_xfer_partial): Call
	breakpoint_restore_shadows.
	(restore_show_memory_breakpoints)
	(make_show_memory_beakpoints_cleanup): New.
	(show_memory_breakpoints): New.
	* target.h (make_show_memory_beakpoints_cleanup): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint):
	Make sure we see memory breakpoints when checking if
	breakpoint is still there.
	* alpha-tdep.c, alphanbsd-tdep.c, frame.c, frv-tdep.c,
	hppa-linux-tdep.c, hppa-tdep.c, i386-linux-nat.c, i386-tdep.c,
	m68klinux-tdep.c, mips-tdep.c, mn10300-tdep.c, s390-tdep.c,
	sparc-tdep.c: Use target_read_memory instead of read_memory_nobpt.
@
text
@d1108 1
a1108 1
hppa32_return_value (struct gdbarch *gdbarch,
d1148 1
a1148 1
hppa64_return_value (struct gdbarch *gdbarch,
@


1.247
log
@
	* hppa-tdep.h (find_global_pointer): Add gdbarch as parameter.

	* hppa-hpux-tdep.c (hppa32_hpux_find_global_pointer): Likewise. Replace
	current_gdbarch by gdbarch.
	(hppa64_hpux_find_global_pointer): Likewise.
	* hppa-tdep.c (hppa_find_global_pointer): Likewise.
	(hppa32_push_dummy_call, hppa64_push_dummy_call): Update call for
	find_global_pointer.

	* hppabsd-tdep.c (hppabsd_find_global_pointer): Add gdbarch as
	parameter.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Likewise.

	* hppa-linux-nat.c (hppa_linux_register_addr): Use ARRAY_SIZE instead
	of gdbarch_num_regs.

	* hppa-hpux-tdep.c (hppa_hpux_sr_for_addr): Add gdbarch as parameter and
	replace current_gdbarch by gdbarch.
	(hppa_hpux_push_dummy_code): Update call for hppa_hpux_sr_for_addr.
@
text
@d548 1
a548 1
  status = read_memory_nobpt (pc, buf, 4);
d1555 1
a1555 1
      status = read_memory_nobpt (pc, buf, 4);
d1606 1
a1606 1
	      status = read_memory_nobpt (pc, buf, 4);
d1619 1
a1619 1
      status = read_memory_nobpt (pc + 4, buf, 4);
d1650 1
a1650 1
	      status = read_memory_nobpt (pc, buf, 4);
d1656 1
a1656 1
	      status = read_memory_nobpt (pc + 4, buf, 4);
d2860 1
a2860 1
      read_memory_nobpt (npc, buf, HPPA_INSN_SIZE);
@


1.246
log
@	* alpha-tdep.c (alpha_heuristic_proc_start)
	(alpha_sigtramp_register_address): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.

	(alpha_heuristic_frame_unwind_cache): Use get_frame_arch to get at the
	current architecture by frame_info. Update alpha_heuristic_proc_start
	call.

	(alpha_sigtramp_frame_this_id, alpha_sigtramp_frame_prev_register): Use
	get_frame_arch to get at the current architecture by frame_info. Update
	alpha_sigtramp_register_address call.

	* arm-tdep.c (thumb_scan_prologue): Add gdbarch as parameter and replace
	current_gdbarch by gdbarch. Update caller.
	(convert_to_extended, convert_from_extended): Add endianess parameter
	for comparison. Update caller.
	(arm_extract_return_value, arm_store_return_value): Use
	get_regcache_arch to get at the current	architecture.

	* cris-tdep.c (cris_register_size): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.
	(cris_gdb_func, move_to_preg_op, none_reg_mode_move_from_preg_op): Add
	gdbarch as parameter. Update caller. Replace current_gdbarch by gdbarch.

	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM, E_PSEUDO_EXR_REGNUM, BINWORD): Add
	gdbarch	as parameter. Update caller.
	(h8300_init_frame_cache): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.

	* hppa-tdep.c (skip_prologue_hard_way): Add gdbarch as parameter and
	update caller. Replace current_gdbarch by gdbarch.

	* m32c-tdep.c (m32c_skip_trampoline_code): Use get_frame_arch to get at
	the current architecture. Replace current_gdbarch by gdbarch.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Likewise.
	(STACK_CORRECTION, USE_PAGE_REGISTER): Replace M6811_TDEP by its
	expression. Add gdbarch as parameter and replace current_gdbarch with
	it. Update caller.
	(M6811_TDEP): Remove.
	(m68hc11_frame_prev_register): Use get_frame_arch to get at the current
	architecture.
	(m68hc11_scan_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.

	* m68k-tdep.c (m68k_analyze_prologue): Add gdbarch as parameter and
	update caller.
	(m68k_analyze_register_saves): Likewise. Also replace current_gdbarch
	by gdbarch.

	* rs6000-tdep.c (skip_prologue): Add gdbarch as parameter and update
	caller. Relace current_gdbarch by gdbarch.
	(altivec_register_p, spe_register_p): Likewise.
	* ppc-tdep.h (altivec_register_p, spe_register_p): Add gdbarch as
	parameter.
	* ppc-linux-nat.c (fetch_register, store_register): Update caller of
	altivec_register_p and spe_register_p.

	* score-tdep.c (score_fetch_inst): Add gdbarch as parameter. Update
	caller. Replace current_gdbarch by gdbarch.
	(score_analyze_prologue): use get_frame_arch to get at the current
	architecture.

	* sparc-tdep.h (sparc_analyze_prologue): Add gdbarch as parameter.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise. Replace
	current_gdbarch by gdbarch. Update caller.
	(sparc_frame_cache): Use get_frame_arch to get at the current
	architecture.
	* sparce64-tdep.c (sparc64_skip_prologue): Update call of
	sparc_analyze_prologue.

	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Add gdbarch as
	parameter.
@
text
@d831 1
a831 1
  gp = tdep->find_global_pointer (function);
d1090 1
a1090 1
  gp = tdep->find_global_pointer (function);
d2708 1
a2708 1
hppa_find_global_pointer (struct value *function)
@


1.245
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d1472 2
a1473 1
skip_prologue_hard_way (CORE_ADDR pc, int stop_before_branch)
d1599 1
a1599 1
      if (reg_num >= (gdbarch_ptr_bit (current_gdbarch) == 64 ? 19 : 23)
d1602 1
a1602 1
	  while (reg_num >= (gdbarch_ptr_bit (current_gdbarch) == 64 ? 19 : 23)
d1631 1
a1631 1
	       <= (gdbarch_ptr_bit (current_gdbarch) == 64 ? 11 : 7))
d1643 1
a1643 1
	  && reg_num <= (gdbarch_ptr_bit (current_gdbarch) == 64 ? 11 : 7))
d1647 1
a1647 1
		      <= (gdbarch_ptr_bit (current_gdbarch) == 64 ? 11 : 7))
d1785 1
a1785 1
    return (skip_prologue_hard_way (pc, 1));
d1912 1
a1912 1
    prologue_end = skip_prologue_hard_way (start_pc, 0);
@


1.244
log
@	Updated copyright notices for most files.
@
text
@d1762 1
a1762 1
hppa_skip_prologue (CORE_ADDR pc)
@


1.243
log
@	* gdbarch.sh (stab_reg_to_regnum, dwarf_reg_to_regnum)
	( dwarf2_reg_to_regnum, sdb_reg_to_regnum, ecoff_reg_to_regnum): Add
	gdbarch as parameter.
	* gdbarch.{c,h}: Regenerate.

	* xtensa-tdep.c (xtensa_reg_to_regnum): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* s390-tdep.c (s390_dwarf_reg_to_regnum): Likewise.
	* rs6000-tdep.c (rs6000_stab_reg_to_regnum)
	(rs6000_dwarf2_reg_to_regnum): Likewise.
	* mips-tdep.c (mips_stab_reg_to_regnum)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum): Likewise.
	* mep-tdep.c (mep_debug_reg_to_regnum): Likewise.
	* m32c-tdep.c (m32c_debug_info_reg_to_regnum): Likewise.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise
	* h8300-tdep.c (h8300s_dbg_reg_to_regnum)
	(h8300_dbg_reg_to_regnum): Likewise.
	* amd64-tdep.c (amd64_dwarf_reg_to_regnum): Likewise.
	* arch-utils.c (no_op_reg_to_regnum): Likewise.
	* arch-utils.h (no_op_reg_to_regnum): Likewise.
	* arm-tdep.c (arm_dwarf_reg_to_regnum): Likewise.
	* cris-tdep.c (cris_dwarf2_reg_to_regnum): Likewise.
	* hppa-tdep.c (hppa64_dwarf_reg_to_regnum): Likewise.
	* ia64-tdep.c (ia64_dwarf_reg_to_regnum): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
@
text
@d4 1
a4 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007
@


1.242
log
@2007-11-16  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (cannot_fetch_register, cannot_store_register): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_cannot_fetch_register)
	(alpha_cannot_store_register): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* cris-tdep.c (cris_cannot_fetch_register, cris_cannot_store_register)
	(crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register): Likewise.
	* arch-utils.c (cannot_register_not): Likewise.
	* arch-utils.h (cannot_register_not): Likewise.
	* hppa-tdep.c (hppa32_cannot_store_register)
	(hppa32_cannot_store_register, hppa64_cannot_store_register)
	(hppa64_cannot_fetch_register): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_cannot_fetch_register)
	(mipsnbsd_cannot_store_register): Likewise.
@
text
@d662 1
a662 1
hppa64_dwarf_reg_to_regnum (int reg)
@


1.241
log
@*** empty log message ***
@
text
@d2635 1
a2635 1
hppa32_cannot_store_register (int regnum)
d2644 1
a2644 1
hppa32_cannot_fetch_register (int regnum)
d2650 1
a2650 1
    return hppa32_cannot_store_register (regnum);
d2654 1
a2654 1
hppa64_cannot_store_register (int regnum)
d2663 1
a2663 1
hppa64_cannot_fetch_register (int regnum)
d2669 1
a2669 1
    return hppa64_cannot_store_register (regnum);
@


1.240
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d574 1
a574 1
hppa_breakpoint_from_pc (CORE_ADDR *pc, int *len)
@


1.239
log
@2007-10-30  Markus Deuling  <deuling@@de.ibm.com>

	* hppa-tdep.c (hppa_frame_cache): Use get_frame_arch to get at the
	current architecture by frame_info.
@
text
@d584 1
a584 1
hppa32_register_name (int i)
d627 1
a627 1
hppa64_register_name (int i)
@


1.238
log
@	* breakpoint.c (breakpoint_sals_to_pc): Do not check for
	DEPRECATED_PC_REQUIRES_RUN_BEFORE_USE.

	* config/pa/tm-hppa.h: Delete file.
	* config/pa/hppa64.mt: Do not set DEPRECATED_TM_FILE.
	* config/pa/hppahpux.mt: Likewise.
	* config/pa/hppa.mt: Likewise.
	* config/pa/linux.mt: Likewise.
	* hppa-tdep.c (hppa_pc_requires_run_before_use): Delete.
@
text
@d1812 1
d2106 1
a2106 1
			    (this_sp, gdbarch_ptr_bit (current_gdbarch) / 8);
d2185 1
a2185 1
    for (reg = 0; reg < gdbarch_num_regs (current_gdbarch); reg++)
a2192 1
    struct gdbarch *gdbarch;
a2194 1
    gdbarch = get_frame_arch (next_frame);
@


1.237
log
@2007-10-08  Markus Deuling  <deuling@@de.ibm.com>

	* hppa-tdep.c (hppa_stub_unwind_sniffer, hppa_dump_tdep): Replace
	current_gdbarch by gdbarch.
	* hppa-linux-nat.c (fetch_register, store_register)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Use get_regcache_arch or
	get_frame_arch to get at the current architecture by regcache or by
	frame, respectively.
	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code
	(hppa_hpux_unwind_adjust_stub): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register)
	(hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
@
text
@a70 4
/* FIXME: brobecker 2002-11-07: We will likely be able to make the
   following functions static, once we hppa is partially multiarched.  */
int hppa_pc_requires_run_before_use (CORE_ADDR pc);

a2610 28
int
hppa_pc_requires_run_before_use (CORE_ADDR pc)
{
  /* Sometimes we may pluck out a minimal symbol that has a negative address.
  
     An example of this occurs when an a.out is linked against a foo.sl.
     The foo.sl defines a global bar(), and the a.out declares a signature
     for bar().  However, the a.out doesn't directly call bar(), but passes
     its address in another call.
  
     If you have this scenario and attempt to "break bar" before running,
     gdb will find a minimal symbol for bar() in the a.out.  But that
     symbol's address will be negative.  What this appears to denote is
     an index backwards from the base of the procedure linkage table (PLT)
     into the data linkage table (DLT), the end of which is contiguous
     with the start of the PLT.  This is clearly not a valid address for
     us to set a breakpoint on.
  
     Note that one must be careful in how one checks for a negative address.
     0xc0000000 is a legitimate address of something in a shared text
     segment, for example.  Since I don't know what the possible range
     is of these "really, truly negative" addresses that come from the
     minimal symbols, I'm resorting to the gross hack of checking the
     top byte of the address for all 1's.  Sigh.  */

  return (!target_has_stack && (pc & 0xFF000000) == 0xFF000000);
}

@


1.236
log
@
2007-08-29  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa32_cannot_fetch_register)
	(hppa64_cannot_fetch_register): New functions.
	(hppa_gdbarch_init): Set cannot_fetch_register appropriately.
	* hppa-tdep.h (hppa_regnum): Add HPPA_CR26_REGNUM.
@
text
@d2464 1
a2464 1
      || gdbarch_in_solib_return_trampoline (current_gdbarch, pc, NULL))
d3198 1
a3198 1
hppa_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
d3200 1
a3200 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.235
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d2677 10
d2695 10
d3097 1
a3097 1
					   hppa32_cannot_store_register);
d3108 1
a3108 1
					   hppa64_cannot_store_register);
@


1.234
log
@	* gdbarch.sh (read_pc): Add REGCACHE argument.  Remove PTID argument.
	(write_pc): Likewise.  Remove default implementation, add predicate.
	* gdbarch.c, gdbarch.h: Regenerate.
	* regcache.c (read_pc_pid): Use current regcache instead of calling
	read_register_pid.
	(write_pc_pid): Check gdbarch_write_pc predicate, implement default
	case inline.
	(generic_target_write_pc): Remove.
	* inferior.h (generic_target_write_pc): Remove.
	* frv-tdep.c (frv_gdbarch_init): Do not install it.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Likewise.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	* sh64-tdep.c (sh64_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.

	* avr-tdep.c (avr_read_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling read_register_pid.
	* hppa-hpux-tdep.c (hppa_hpux_read_pc): Likewise.
	* hppa-tdep.c (hppa_read_pc): Likewise.
	* hppa-tdep.h (hppa_read_pc): Likewise.
	* ia64-tdep.c (ia64_read_pc): Likewise.
	* m32r-tdep.c (m32r_read_pc): Likewise.
	* mep-tdep.c (mep_read_pc): Likewise.
	* mn10300-tdep.c (mn10300_read_pc): Likewise.
	* spu-tdep.c (spu_read_pc): Likewise.

	* arm-tdep.c (arm_write_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling write_register_pid.
	* avr-tdep.c (avr_write_pc): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_write_pc): Likewise.
	* hppa-tdep.c (hppa_write_pc): Likewise.
	* hppa-tdep.h (hppa_write_pc): Likewise.
	* i386-linux-tdep.c (i386_linux_write_pc): Likewise.
	* amd64-linux-tdep.c (amd64_linux_write_pc): Likewise.
	* ia64-linux-tdep.c (ia64_linux_write_pc): Likewise.
	* ia64-tdep.c (ia64_write_pc): Likewise.
	* ia64-tdep.h (ia64_write_pc): Likewise.
	* m32r-tdep.c (m32r_write_pc): Likewise.
	* m88k-tdep.c (m88k_write_pc): Likewise.
	* mep-tdep.c (mep_write_pc): Likewise.
	* mips-tdep.c (mips_write_pc): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.
	* mn10300-tdep.c (mn10300_write_pc): Likewise.
	* sparc-tdep.c (sparc_write_pc): Likewise.
	* spu-tdep.c (spu_write_pc): Likewise.

	* mips-tdep.c (read_signed_register): Remove.
	(read_signed_register_pid): Likewise.
	(mips_read_pc): Add REGCACHE argument.  Remove PTID argument.
	Use REGCACHE instead of calling read_signed_register_pid.
@
text
@d14 1
a14 1
   the Free Software Foundation; either version 2 of the License, or
d23 1
a23 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.233
log
@	* gdbarch.sh (skip_trampoline_code): Add FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (generic_skip_trampoline_code): Add FRAME argument.
	* arch-utils.h (generic_skip_trampoline_code): Likewise.
	* infrun.c (handle_inferior_event): Pass current frame to
	gdbarch_skip_trampoline_code and skip_language_trampoline.

	* language.c (unk_lang_trampoline): Add FRAME argument.
	(skip_language_trampoline): Add FRAME argument.  Pass it to
	skip_trampoline callback.
	* language.h: Add forward declaration of struct frame_info.
	(struct language_defn): Add FRAME argument to skip_trampoline.
	(skip_language_trampoline): Add FRAME argument.
	* cp-abi.c (cplus_skip_trampoline): Add FRAME argument.  Pass it
	to skip_trampoline callback.
	* cp-abi.h: Add forward declaration of struct frame_info.
	(cplus_skip_trampoline): Add FRAME argument.
	(struct cp_abi_ops): Add FRAME argument to skip_trampoline callback.
	* gnu-v3-abi.c (gnuv3_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.
	* objc-lang.c (objc_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.

	* minsyms.c (find_solib_trampoline_target): Add FRAME argument.
	* symtab.h (find_solib_trampoline_target): Likewise.
	* obsd-tdep.c (obsd_skip_solib_resolver): Pass current frame to
	find_solib_trampoline_target.

	* arm-tdep.c (arm_skip_stub): Add FRAME argument.  Read registers
	from FRAME instead of calling read_register.

	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code): Add FRAME
	argument.  Read registers from FRAME instead of using read_register.
	* hppa-tdep.c (hppa_skip_trampoline_code): Likewise.
	* hppa-tdep.h (hppa_skip_trampoline_code): Add FRAME argument.

	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Add FRAME
	argument.

	* m32c-tdep.c (m32c_skip_trampoline_code): Add FRAME argument.

	* mips-tdep.c (mips_skip_trampoline_code): Add FRAME argument.  Read
	registers from FRAME instead of using read_signed_register.

	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Add FRAME
	argument.
	(ppc64_standard_linkage_target): Likewise.  Read registers from FRAME
	instead of using read_register.
	(ppc64_skip_trampoline_code): Add FRAME argument.  Pass it to
	ppc64_standard_linkage_target.
	* rs6000-tdep.c (rs6000_skip_trampoline_code): Add FRAME argument.
	Pass it to find_solib_trampoline_target.  Read registers from FRAME
	instead of using read_register.

	* xstormy16-tdep.c (xstormy16_skip_trampoline_code): Add FRAME
	argument.
@
text
@d1277 1
a1277 1
hppa_read_pc (ptid_t ptid)
d1280 1
a1280 1
  CORE_ADDR pc;
d1282 2
a1283 2
  ipsw = read_register_pid (HPPA_IPSW_REGNUM, ptid);
  pc = read_register_pid (HPPA_PCOQ_HEAD_REGNUM, ptid);
d1297 1
a1297 1
hppa_write_pc (CORE_ADDR pc, ptid_t ptid)
d1299 2
a1300 2
  write_register_pid (HPPA_PCOQ_HEAD_REGNUM, pc, ptid);
  write_register_pid (HPPA_PCOQ_TAIL_REGNUM, pc + 4, ptid);
@


1.232
log
@	* arm-tdep.c (arm_print_float_info): Use register value from FRAME
	instead of calling read_register.

	* avr-tdep.c (avr_push_dummy_call): Write to REGCACHE instead of
	calling write_register.

	* hppa-tdep.c (hppa32_push_dummy_call): Write to REGCACHE instead of
	calling write_register.

	* ia64-tdep.c (find_func_descr): Add REGCACHE parameter.  Use it
	instead of calling read_register.
	(ia64_push_dummy_call): Update call to find_func_descr.  Use REGCACHE
	instead of calling read_register and write_register.

	* m32r-tdep.c (m32r_linux_supply_gregset): Use REGCACHE parameter
	instead of current_regcache.

	* mn10300-tdep.c (mn10300_push_dummy_call): Write to REGCACHE instead
	of calling write_register.
	* mn10300-linux-tdep.c (am33_supply_fpregset_method): Use REGCACHE
	parameter instead of current_regcache.

	* mips-tdep.c (mips2_fp_compat): Add FRAME parameter.  Use it
	instead of calling read_register.
	(mips_read_fp_register_double, mips_print_fp_register): Update calls.
	(mips_eabi_push_dummy_call): Use REGCACHE instead of write_register.
	(mips_n32n64_push_dummy_call): Likewise.
	(mips_o32_push_dummy_call): Likewise.
	(mips_o64_push_dummy_call): Likewise.

	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Use REGCACHE
	parameter instead of current_regcache.

	* xtensa-tdep.c (xtensa_register_write_masked): Add REGCACHE parameter.
	Use it instead of read_register and write_register.
	(xtensa_register_read_masked): Likewise.
	(xtensa_pseudo_register_read): Update call.
	(xtensa_pseudo_register_write): Likewise.
	(xtensa_frame_cache): Use register values unwound from NEXT_FRAME
	instead of calling read_register.
	(xtensa_push_dummy_call): Update comment.
@
text
@d2944 1
a2944 1
hppa_skip_trampoline_code (CORE_ADDR pc)
d2952 1
a2952 1
      pc = read_register (HPPA_R0_REGNUM + 22);
d2968 1
a2968 1
        pc += read_register (HPPA_DP_REGNUM);
d2970 1
a2970 1
        pc += read_register (HPPA_R0_REGNUM + 19);
@


1.231
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_PTR_BIT): Replace with gdbarch_ptr_bit.
	* solib-svr4.c (svr4_truncate_ptr): Likewise.
	* solib-pa64.c (read_dynamic_info): Likewise.
	* solib-legacy.c (legacy_svr4_fetch_link_map_offsets): Likewise.
	* solib.c (info_sharedlibrary_command): Likewise.
	* s390-nat.c (SUBOFF): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	* procfs.c (info_proc_mappings): Likewise.
	* printcmd.c (decode_format): Likewise.
	* nto-tdep.c (nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips64_linux_get_longjmp_target): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* jv-valprint.c (java_value_print): Likewise.
	* jv-lang.c (get_java_object_header_size): Likewise.
	* hppa-tdep.c (skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code)
	(hppa_hpux_unwind_adjust_stub): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
	* gdbtypes.c (make_pointer_type, make_reference_type)
	(smash_to_memberptr_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d835 1
a835 1
    write_register (28, struct_addr);
d840 1
a840 1
    write_register (19, gp);
@


1.230
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SKIP_TRAMPOLINE_CODE): Replace by
	gdbarch_skip_trampoline_code.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise (comment).
	* objc-lang.c (objc_skip_trampoline)
	(objc_submethod_helper_data): Likewise.
	* m32c-lang.c (m32c_skip_trampoline_code): Likewise (comment).
	* infrun.c (handle_inferior_event): Likewise.
	* gnu-v3-abi.c (gnuv3_skip_trampoline): Likewise.
	* gdbarch.sh (IN_SOLIB_RETURN_TRAMPOLINE): Replace by
	gdbarch_in_solib_return_trampoline.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise (comment).
	* infrun.c (handle_inferior_event): Likewise.
	* hppa-tdep.c (hppa_stub_unwind_sniffer): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1604 2
a1605 1
      if (reg_num >= (TARGET_PTR_BIT == 64 ? 19 : 23) && reg_num <= 26)
d1607 2
a1608 1
	  while (reg_num >= (TARGET_PTR_BIT == 64 ? 19 : 23) && reg_num <= 26)
d1635 2
a1636 1
	  && inst_saves_fr (next_inst) <= (TARGET_PTR_BIT == 64 ? 11 : 7))
d1647 2
a1648 1
      if (reg_num >= 4 && reg_num <= (TARGET_PTR_BIT == 64 ? 11 : 7))
d1650 3
a1652 1
	  while (reg_num >= 4 && reg_num <= (TARGET_PTR_BIT == 64 ? 11 : 7))
d2110 2
a2111 1
            cache->base = read_memory_integer (this_sp, TARGET_PTR_BIT / 8);
@


1.229
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d2459 1
a2459 1
      || IN_SOLIB_RETURN_TRAMPOLINE (pc, NULL))
@


1.228
log
@	* hppa-hpux-tdep.c: Include "regcache.h".
	* hppa-linux-tdep.c: Likewise.
	* hppa-tdep.c: Include "gdb_stdint.h".
	(find_unwind_entry): Cast host pointer to uintptr_t before passing
	it to paddr_nz.
	* Makefile.in: Update dependencies.
@
text
@d2183 1
a2183 1
    for (reg = 0; reg < NUM_REGS; reg++)
@


1.227
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d34 1
d506 1
a506 1
            paddr_nz ((CORE_ADDR) ui->cache));
d524 1
a524 1
                paddr_nz ((CORE_ADDR) ui->cache));
@


1.226
log
@	* avr-tdep.c, hppa-tdep.c, hppabsd-tdep.c, i386-tdep.c,
	ia64-tdep.c, m68k-tdep.c, mips-linux-tdep.c, ppcobsd-tdep.c,
	sparc-linux-tdep.c: Include "gdbtypes.h" instead of "floatformat.h".
	* Makefile.in (avr-tdep.o, hppabsd-tdep.o, hppa-tdep.o, i386-tdep.o)
	(ia64-tdep.o, m68k-tdep.o, mips-linux-tdep.o, ppcobsd-tdep.o)
	(sparc-linux-tdep.o): Update.
@
text
@d1790 1
a1790 1
  CORE_ADDR pc;
d1792 6
a1797 1
  pc = frame_unwind_address_in_block (f);
d1907 1
a1907 1
      start_pc = frame_func_unwind (next_frame);
d2275 1
a2275 1
  start_pc = frame_func_unwind (next_frame);
d2334 2
a2335 1
  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
d2418 2
a2419 1
    *this_id = frame_id_build (info->base, frame_func_unwind (next_frame));
d2451 1
a2451 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
@


1.225
log
@	* doublest.c (floatformat_from_length): Use the right element from
	gdbarch floatformats.
	(floatformat_from_type, extract_typed_floating)
	(store_typed_floating): Likewise.
	* doublest.h: Remove declarations for undefined floatformat arrays.
	* gdbarch.sh (float_format, double_format, long_double_format): Change
	to pairs.
	(pformat): Update for pairs.
	* gdbarch.c, gdbarch.h: Regenerated.
	* gdbtypes.c (floatformats_ieee_single, floatformats_ieee_double)
	(floatformats_ieee_double_littlebyte_bigword)
	(floatformats_i387_ext, floatformats_m68881_ext, floatformats_arm_ext)
	(floatformats_ia64_spill, floatformats_ia64_quad, floatformats_vax_f)
	(floatformats_vax_d): New variables.
	(builtin_type_ieee_single, builtin_type_ieee_double)
	(builtin_type_arm_ext, builtin_type_ia64_spill)
	(builtin_type_ia64_quad): Replace arrays with individual types.
	(builtin_type_ieee_single_big, builtin_type_ieee_single_little)
	(builtin_type_ieee_double_big, builtin_type_ieee_double_little)
	(builtin_type_ieee_double_littlebyte_bigword, builtin_type_i960_ext)
	(builtin_type_m88110_ext, builtin_type_m88110_harris_ext)
	(builtin_type_arm_ext_big, builtin_type_arm_ext_littlebyte_bigword)
	(builtin_type_ia64_spill_big, builtin_type_ia64_spill_little)
	(builtin_type_ia64_quad_big, builtin_type_ia64_quad_little): Delete
	unused and endian-specific types.
	(recursive_dump_type): Update for floatformat pairs.
	(build_flt): Move higher.  Handle bit == -1.  Take a floatformat pair.
	(build_gdbtypes): Use build_flt.
	(_initialize_gdbtypes): Update set of initialized types.
	* gdbtypes.h: Update declarations to match gdbtypes.c.
	(struct main_type): Store a pointer to two floatformats.
	* arch-utils.c (default_float_format, default_double_format): Delete.
	* arch-utils.h (default_float_format, default_double_format): Delete.

	* arm-tdep.c, avr-tdep.c, hppa-tdep.c, hppabsd-tdep.c, i386-tdep.c,
	ia64-tdep.c,  iq2000-tdep.c, m68k-tdep.c, m88k-tdep.c,
	mips-linux-tdep.c, mips-tdep.c, mt-tdep.c, ppcobsd-tdep.c,
	sparc-linux-tdep.c, sparc-tdep.c, sparcnbsd-tdep.c, spu-tdep.c,
	vax-tdep.c, alpha-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d44 1
@


1.224
log
@Copyright updates for 2007.
@
text
@d2638 1
a2638 1
     return builtin_type_ieee_single_big;
d2647 1
a2647 1
     return builtin_type_ieee_double_big;
d3088 1
a3088 1
  set_gdbarch_long_double_format (gdbarch, &floatformat_ia64_quad_big);
@


1.223
log
@        * gdbcore.h (read_memory_nobpt): New function name instead of
        deprecated_read_memory_nobpt.
        * breakpoint.c (read_memory_nobpt): New function name instead
        of deprecated_read_memory_nobpt.
        Adjust calls to old deprecated_read_memory_nobpt accordingly.
        * alpha-tdep.c: Adjust calls to deprecated_read_memory_nobpt
        accordingly.
        * alphanbsd-tdep.c: Likewise.
        * frame.c: Likewise.
        * frv-tdep.c: Likewise.
        * hppa-linux-tdep.c: Likewise.
        * hppa-tdep.c: Likewise.
        * i386-linux-nat.c: Likewise.
        * m68klinux-tdep.c: Likewise.
        * mips-tdep.c: Likewise.
        * s390-tdep.c: Likewise.
@
text
@d3 2
a4 2
   Copyright (C) 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
@


1.222
log
@2006-03-30  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_find_unwind_entry_in_block): New.
	(hppa_frame_cache): Use new function to find unwind entry.
	(hppa_frame_this_id): Likewise.
	(hppa_frame_unwind_sniffer): Likewise.
@
text
@d552 1
a552 1
  status = deprecated_read_memory_nobpt (pc, buf, 4);
d1558 1
a1558 1
      status = deprecated_read_memory_nobpt (pc, buf, 4);
d1607 1
a1607 1
	      status = deprecated_read_memory_nobpt (pc, buf, 4);
d1620 1
a1620 1
      status = deprecated_read_memory_nobpt (pc + 4, buf, 4);
d1647 1
a1647 1
	      status = deprecated_read_memory_nobpt (pc, buf, 4);
d1653 1
a1653 1
	      status = deprecated_read_memory_nobpt (pc + 4, buf, 4);
d2858 1
a2858 1
      deprecated_read_memory_nobpt (npc, buf, HPPA_INSN_SIZE);
@


1.222.6.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d552 1
a552 1
  status = read_memory_nobpt (pc, buf, 4);
d1558 1
a1558 1
      status = read_memory_nobpt (pc, buf, 4);
d1607 1
a1607 1
	      status = read_memory_nobpt (pc, buf, 4);
d1620 1
a1620 1
      status = read_memory_nobpt (pc + 4, buf, 4);
d1647 1
a1647 1
	      status = read_memory_nobpt (pc, buf, 4);
d1653 1
a1653 1
	      status = read_memory_nobpt (pc + 4, buf, 4);
d2858 1
a2858 1
      read_memory_nobpt (npc, buf, HPPA_INSN_SIZE);
@


1.221
log
@2006-03-01  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.h (unwind_table_entry): Update field names to match HP
	runtime specification.
	* hppa-tdep.c (internalize_unwinds, hppa_frame_cache): Likewise.
	(unwind_command): Likewise.
@
text
@d1785 11
d1831 1
a1831 1
  u = find_unwind_entry (frame_pc_unwind (next_frame));
d2211 1
a2211 1
  u = find_unwind_entry (pc);
d2238 1
a2238 3
  CORE_ADDR pc = frame_pc_unwind (next_frame);

  if (find_unwind_entry (pc))
@


1.220
log
@2006-03-01  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_frame_cache): Handle Region_Description and
	Pseudo_SP_Set in unwind record.
@
text
@d283 1
a283 1
	  table[i].reserved1 = (tmp >> 26) & 0x1;
d293 1
a293 1
	  table[i].Ada_Region = (tmp >> 9) & 0x1;
d297 1
a297 1
	  table[i].reserved2 = (tmp >> 5) & 0x1;
d301 1
a301 1
	  table[i].extn_ptr_defined = (tmp >> 1) & 0x1;
d308 2
a309 2
	  table[i].Pseudo_SP_Set = (tmp >> 28) & 0x1;
	  table[i].reserved4 = (tmp >> 27) & 0x1;
d2068 1
a2068 1
     if (u->Pseudo_SP_Set)
d2072 1
a2072 1
         && (u->Save_SP || u->Pseudo_SP_Set) && fp != 0)
d2543 4
a2546 1
  pif (Ada_Region);
d2550 1
a2550 1
  pif (extn_ptr_defined);
d2555 1
@


1.219
log
@2006-02-19  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_in_solib_call_trampoline): Only use if no
	unwind entry.
@
text
@d1860 1
a1860 1
    CORE_ADDR pc, end_pc;
d1880 6
a1885 1
       function (or 0).  We can do better than that by using unwind records.  */
d1887 6
a1892 1
    prologue_end = skip_prologue_hard_way (u->region_start, 0);
d1900 1
a1900 1
    for (pc = u->region_start;
d2067 3
d2072 1
a2072 1
         && u->Save_SP && fp != 0)
@


1.218
log
@* hppa-tdep.h (hppa_in_solib_call_trampoline)
(hppa_skip_trampoline_code): New prototypes.
* hppa-tdep.c (struct insn_pattern): New.
(hppa_long_branch_stub, hppa_long_branch_pic_stub)
(hppa_import_stub, hppa_import_pic_stub, hppa_plt_stub): Moved
here from hppa-linux-tdep.c
(HPPA_MAX_INSN_PATTERN_LEN): New define.
(hppa_match_insns, hppa_match_insns_relaxed, hppa_in_dyncall)
(hppa_in_solib_call_trampoline, hppa_skip_trampoline_code): New
functions based on functions removed from hppa-linux-tdep.c.
* hppa-linux-tdep.c (hppa_long_branch_stub)
(hppa_long_branch_pic_stub, hppa_import_stub)
(hppa_import_pic_stub, hppa_plt_stub): Moved to hppa-tdep.c.
(insns_match_pattern_relaxed, hppa_linux_in_dyncall)
(hppa_linux_in_solib_call_trampoline)
(hppa_linux_skip_trampoline_code): Removed.
(hppa_linux_init_abi): Set TDEP->in_solib_call_tranpoline to
hppa_in_solib_call_trampoline and skip_trampoline_code to
hppa_skip_trampoline_code.
* hppabsd-tdep.c (hppabsd_init_abi): Set
TDEP->in_solib_call_trampoline and skip_trampoline_code.
@
text
@d2889 1
a2889 1
  if (u == NULL)
@


1.217
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d2740 217
@


1.216
log
@2005-12-09  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): New function.
	(hppa64_push_dummy_call): If passing a function pointer, ensure
	it is a function descriptor address instead of the function entry
	point.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
d24 2
a25 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.215
log
@2005-12-09  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa64_dwarf_reg_to_regnum): New funtion.
	(hppa_gdbarch_init): Set dwarf_reg_to_regnum and
	dwarf2_reg_to_regnum methods.
@
text
@d900 44
d964 1
d1040 17
d1058 1
a1058 1
      write_memory (sp + offset, value_contents (arg), len);
a1059 1
      valbuf = value_contents (arg);
@


1.214
log
@2005-11-19  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (skip_prologue_hard_way): Add one more insn pattern
	for "std rp,-0x10(sp)".
	(hppa_frame_cache): Likewise.
	(hppa_fallback_frame_cache): Likewise.
@
text
@d665 15
d2765 2
@


1.213
log
@2005-11-19  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_frame_cache): Reformat code and enhance
	debugging.
@
text
@d1494 1
a1494 1
      if (inst == 0x6bc23fd9 || inst == 0x0fc212c1)
d1849 2
a1850 1
	else if (inst == 0x0fc212c1) /* std rp,-0x10(sr0,sp) */
d2191 2
a2192 1
	  else if (insn == 0x0fc212c1) /* std rp,-0x10(sr0,sp) */
@


1.212
log
@        * hppa-tdep.c (read_unwind_info): Fix typo in comment.
@
text
@d1987 1
a1987 1
	  fprintf_unfiltered (gdb_stdlog, " (base=0x%s) [frame pointer] }",
d1999 1
a1999 1
	      fprintf_unfiltered (gdb_stdlog, " (base=0x%s) [saved] }",
d2008 1
a2008 1
	  fprintf_unfiltered (gdb_stdlog, " (base=0x%s) [unwind adjust] } ",
d2020 5
a2024 1
        cache->saved_regs[HPPA_PCOQ_HEAD_REGNUM] = cache->saved_regs[31];
d2029 2
d2036 6
a2041 1
        cache->saved_regs[HPPA_PCOQ_HEAD_REGNUM] = cache->saved_regs[HPPA_RP_REGNUM];
d2046 2
@


1.211
log
@* hppa-tdep.h (hppa_frame_prev_register_helper): Change types of
last argument to `gdb_byte *'.
* hppa-tdep.c (hppa32_convert_from_func_ptr_addr): Rewrite.
(hppa_frame_prev_register_helper): Change types of last argument
to `gdb_byte *'.
* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_prev_register):
Change types of last argument to `gdb_byte *'.
@
text
@d367 1
a367 1
     use stub unwinds at the curren time.  */
@


1.210
log
@* hppa-tdep.c (hppa_pointer_to_address_hack): Remove function.
(unwind_command): Use %lx to print pointer.
@
text
@d1 1
a1 1
/* Target-dependent code for the HP PA architecture, for GDB.
d4 2
a5 2
   1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software
   Foundation, Inc.
d1169 1
a1169 2
hppa32_convert_from_func_ptr_addr (struct gdbarch *gdbarch,
				   CORE_ADDR addr,
d1174 2
a1175 4
      CORE_ADDR plabel;

      plabel = addr & ~3;
      target_read_memory(plabel, (char *)&addr, 4);
d2599 1
a2599 1
				 int *realnump, void *valuep)
@


1.209
log
@* hppa-tdep.c (hppa_fallback_frame_cache): Don't error out if we
can't find the bounds of the current function.  Wrap some long
lines in the process.
@
text
@a2397 10
/* Instead of this nasty cast, add a method pvoid() that prints out a
   host VOID data type (remember %p isn't portable).  */

static CORE_ADDR
hppa_pointer_to_address_hack (void *ptr)
{
  gdb_assert (sizeof (ptr) == TYPE_LENGTH (builtin_type_void_data_ptr));
  return POINTER_TO_ADDRESS (builtin_type_void_data_ptr, &ptr);
}

d2419 1
a2419 2
  printf_unfiltered ("unwind_table_entry (0x%s):\n",
		     paddr_nz (hppa_pointer_to_address_hack (u)));
@


1.208
log
@        * hppa-tdep.c (hppa_pc_requires_run_before_use): Really test all
        bits of top byte in address.
@
text
@d2147 3
a2149 3
  unsigned int frame_size;
  int found_rp;
  CORE_ADDR pc, start_pc, end_pc, cur_pc;
d2152 3
a2154 2
    fprintf_unfiltered (gdb_stdlog, "{ hppa_fallback_frame_cache (frame=%d)-> ",
      frame_relative_level(next_frame));
d2160 2
a2161 8
  pc = frame_func_unwind (next_frame);
  cur_pc = frame_pc_unwind (next_frame);
  frame_size = 0;
  found_rp = 0;

  find_pc_partial_function (pc, NULL, &start_pc, &end_pc);

  if (start_pc == 0 || end_pc == 0)
d2163 2
a2164 4
      error (_("Cannot find bounds of current function (@@0x%s), unwinding will "
	     "fail."), paddr_nz (pc));
      return cache;
    }
d2166 3
a2168 2
  if (end_pc > cur_pc)
    end_pc = cur_pc;
d2170 2
a2171 3
  for (pc = start_pc; pc < end_pc; pc += 4)
    {
      unsigned int insn;
d2173 13
a2185 16
      insn = read_memory_unsigned_integer (pc, 4);

      frame_size += prologue_inst_adjust_sp (insn);

      /* There are limited ways to store the return pointer into the
	 stack.  */
      if (insn == 0x6bc23fd9) /* stw rp,-0x14(sr0,sp) */
	 {
	   cache->saved_regs[HPPA_RP_REGNUM].addr = -20;
	   found_rp = 1;
	 }
      else if (insn == 0x0fc212c1) /* std rp,-0x10(sr0,sp) */
	 {
	   cache->saved_regs[HPPA_RP_REGNUM].addr = -16;
	   found_rp = 1;
	 }
d2189 2
a2190 2
    fprintf_unfiltered (gdb_stdlog, " frame_size = %d, found_rp = %d }\n",
      frame_size, found_rp);
d2192 2
a2193 1
  cache->base = frame_unwind_register_unsigned (next_frame, HPPA_SP_REGNUM) - frame_size;
d2199 2
a2200 1
      cache->saved_regs[HPPA_PCOQ_HEAD_REGNUM] = cache->saved_regs[HPPA_RP_REGNUM];
d2204 2
a2205 1
      ULONGEST rp = frame_unwind_register_unsigned (next_frame, HPPA_RP_REGNUM);
@


1.207
log
@* hppa-tdep.c (hppa_frame_prev_register)
(hppa_fallback_frame_prev_register)
(hppa_stub_frame_prev_register): Change type of last argument to
`gdb_byte *'.
(hppa_fetch_pointer_argument): Tweak comment.  Use
get_frame_register_unsigned instead of get_frame_register.
(hppa32_return_value, hppa64_return_value): Change type of readbuf
and writebuf arguments to `gdb_byte *'.  Remove unecessary casts
and local variables.
(hppa_pseudo_register_read): Change type of last argument to
`gdb_byte *'.
@
text
@d2530 1
a2530 1
  return (!target_has_stack && (pc & 0xFF000000));
@


1.206
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* command.h (fprint_setshow_ftype): Delete.
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* complaints.c, cris-tdep.c, dwarf2read.c, frame.c: Update.
	* hppa-tdep.c, infcall.c, m32r-rom.c, maint.c: Update.
	* mips-tdep.c, nto-tdep.c, observer.c, remote-rdi.c: Update
	* remote.c, target.c, cli/cli-logging.c: Update.
@
text
@d1038 1
a1038 1
		     void *readbuf, const void *writebuf)
d1064 1
a1064 1
	    regcache_cooked_read (regcache, reg, (char *) readbuf + b);
d1066 1
a1066 1
	    regcache_cooked_write (regcache, reg, (const char *) writebuf + b);
d1078 1
a1078 1
		     void *readbuf, const void *writebuf)
a1141 1
      char *buf = readbuf;
d1145 2
a1146 2
				     min (len, 8), buf);
	  buf += min (len, 8);
a1153 1
      const char *buf = writebuf;
d1157 2
a1158 2
				      min (len, 8), buf);
	  buf += min (len, 8);
d2110 1
a2110 1
			  int *realnump, void *valuep)
d2233 1
a2233 1
			  int *realnump, void *valuep)
d2318 1
a2318 1
			       int *realnump, void *valuep)
d2588 2
a2589 1
/* Get the ith function argument for the current function.  */
d2594 1
a2594 3
  CORE_ADDR addr;
  get_frame_register (frame, HPPA_R0_REGNUM + 26 - argi, &addr);
  return addr;
d2599 1
a2599 1
			   int regnum, void *buf)
d2606 1
a2606 1
    store_unsigned_integer (buf, sizeof(tmp), tmp);
@


1.205
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d2882 1
d2884 1
a2884 1
			   NULL, NULL, &setdebuglist, &showdebuglist);
@


1.204
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_setshow functions, replace "PRINT:" comment prefix
	with "FIXME: i18n:".
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* cris-tdep.c, dwarf2read.c, frame.c, hppa-tdep.c: Update.
	* infcall.c, m32r-rom.c, maint.c, mips-tdep.c: Update.
	* nto-tdep.c, observer.c, remote-rdi.c, remote.c: Update.
	* target.c, cli/cli-logging.c: Update.
@
text
@d2871 1
a2871 1
	   "Print unwind table entry at given address.",
@


1.203
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d2875 4
a2878 3
  add_setshow_boolean_cmd ("hppa", class_maintenance, &hppa_debug, "\
Set whether hppa target specific debugging information should be displayed.", "\
Show whether hppa target specific debugging information is displayed.", "\
d2881 2
a2882 2
unwinding problems.",
			   NULL, /* PRINT hppa debug flag is %s.  */
@


1.202
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d2765 1
a2765 1
        internal_error (__FILE__, __LINE__, "Unsupported address size: %d",
d2817 1
a2817 1
      internal_error (__FILE__, __LINE__, "bad switch");
d2830 1
a2830 1
      internal_error (__FILE__, __LINE__, "bad switch");
@


1.201
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd, add_setshow_cmd_full)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Replace
	print string parameter with fprint_setshow function.
	* command.h (fprint_setshow_ftype): Define.  Update declarations.
	* cli/cli-setshow.c (do_setshow_command): When fprint_setshow is
	available, use that.
	* cli/cli-decode.h (struct cmd_list_element): Add field
	fprint_setshow.
	* complaints.c (fprint_setshow_complaints): New function.
	(_initialize_complaints): Pass to add_setshow_zinteger_cmd.
	* hppa-tdep.c (_initialize_hppa_tdep): Replace "print" parameter
	with NULL.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* cris-tdep.c (_initialize_cris_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* target.c (initialize_targets): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* breakpoint.c (_initialize_breakpoint): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
@
text
@d492 1
a492 1
	  error ("Internal error reading unwind information.");
d1833 1
a1833 1
	    error ("Cannot read instruction at 0x%s\n", paddr_nz (pc));
d2170 2
a2171 2
      error ("Cannot find bounds of current function (@@0x%s), unwinding will "
	     "fail.", paddr_nz (pc));
d2330 1
a2330 1
    error ("Requesting registers from null frame.\n");
@


1.200
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d2880 2
a2881 1
unwinding problems.", "hppa debug flag is %s.",
@


1.199
log
@        * hppa-tdep.c (prologue_inst_adjust_sp): Fix small confusion
        in register number for addil instruction.
@
text
@d4 1
a4 1
   1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
d726 1
a726 1
		write_memory (struct_end - struct_ptr, VALUE_CONTENTS (arg),
d738 1
a738 1
						   VALUE_CONTENTS (arg)));
d744 1
a744 1
	      memcpy (param_val, VALUE_CONTENTS (arg), param_len);
d752 1
a752 1
		      VALUE_CONTENTS (arg), TYPE_LENGTH (type));
d904 1
a904 1
      char *valbuf;
d963 1
a963 1
					      len, VALUE_CONTENTS (arg));
d981 1
a981 1
      write_memory (sp + offset, VALUE_CONTENTS (arg), len);
d983 1
a983 1
      valbuf = VALUE_CONTENTS (arg);
@


1.198
log
@* hppa-tdep.c (hppa_frame_prev_register_helper): Make 64-bit safe.
@
text
@d1288 1
a1288 1
  /* addil high21,%r1; ldo low11,(%r1),%r30)
d1290 1
a1290 1
  if ((inst & 0xffe00000) == 0x28200000)
@


1.197
log
@* hppa-tdep.c (hppa64_return_value): Fix previous commit.
@
text
@d2625 2
d2631 1
d2638 2
a2639 2
	  pc = extract_unsigned_integer (valuep, 4);
	  store_unsigned_integer (valuep, 4, pc + 4);
d2658 1
a2658 4
	store_unsigned_integer (valuep, 
			        register_size (get_frame_arch (next_frame), 
					       regnum), 
				0);
@


1.196
log
@* hppa-tdep.c (hppa32_return_value): Move further down.
(hppa64_return_value): Re-implement.
@
text
@d1087 2
a1088 2
      gdb_assert (!hppa64_integral_or_pointer_p());
      gdb_assert (!hppa64_floating_p());
@


1.195
log
@* hppa-tdep.h (hppa_regnum): Add HPPA_DP_REGNUM, HPPA_RET0_REGNUM,
HPPA_RET1_REGNUM and HPPA64_FP4_REGNUM.
* hppa-tdep.c (hppa64_integral_or_pointer_p)
(hppa64_floating_p) New functions.
(hppa64_push_dummy_call): Re-implement.
(hppa32_register_type): Rename argument reg_nr to regnum.
(hppa64_register_type): Likewise.  Use HPPA64_FP4_REGNUM instead
of HPPA_FP4_REGNUM.
(hppa32_cannot_store_register): Renamed from
hppa_cannot_store_register.
(hppa64_cannot_store_register): New function.
(hppa_gdbarch_init): Set cannot_store_register and
cannot_fetch_register to hppa32_cannot_store_register or
hppa64_cannot_store_register when appropriate.
@
text
@a74 96
/* Handle 32/64-bit struct return conventions.  */

static enum return_value_convention
hppa32_return_value (struct gdbarch *gdbarch,
		     struct type *type, struct regcache *regcache,
		     void *readbuf, const void *writebuf)
{
  if (TYPE_LENGTH (type) <= 2 * 4)
    {
      /* The value always lives in the right hand end of the register
	 (or register pair)?  */
      int b;
      int reg = TYPE_CODE (type) == TYPE_CODE_FLT ? HPPA_FP4_REGNUM : 28;
      int part = TYPE_LENGTH (type) % 4;
      /* The left hand register contains only part of the value,
	 transfer that first so that the rest can be xfered as entire
	 4-byte registers.  */
      if (part > 0)
	{
	  if (readbuf != NULL)
	    regcache_cooked_read_part (regcache, reg, 4 - part,
				       part, readbuf);
	  if (writebuf != NULL)
	    regcache_cooked_write_part (regcache, reg, 4 - part,
					part, writebuf);
	  reg++;
	}
      /* Now transfer the remaining register values.  */
      for (b = part; b < TYPE_LENGTH (type); b += 4)
	{
	  if (readbuf != NULL)
	    regcache_cooked_read (regcache, reg, (char *) readbuf + b);
	  if (writebuf != NULL)
	    regcache_cooked_write (regcache, reg, (const char *) writebuf + b);
	  reg++;
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else
    return RETURN_VALUE_STRUCT_CONVENTION;
}

static enum return_value_convention
hppa64_return_value (struct gdbarch *gdbarch,
		     struct type *type, struct regcache *regcache,
		     void *readbuf, const void *writebuf)
{
  /* RM: Floats are returned in FR4R, doubles in FR4.  Integral values
     are in r28, padded on the left.  Aggregates less that 65 bits are
     in r28, right padded.  Aggregates upto 128 bits are in r28 and
     r29, right padded.  */ 
  if (TYPE_CODE (type) == TYPE_CODE_FLT
      && TYPE_LENGTH (type) <= 8)
    {
      /* Floats are right aligned?  */
      int offset = register_size (gdbarch, HPPA_FP4_REGNUM) - TYPE_LENGTH (type);
      if (readbuf != NULL)
	regcache_cooked_read_part (regcache, HPPA_FP4_REGNUM, offset,
				   TYPE_LENGTH (type), readbuf);
      if (writebuf != NULL)
	regcache_cooked_write_part (regcache, HPPA_FP4_REGNUM, offset,
				    TYPE_LENGTH (type), writebuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_LENGTH (type) <= 8 && is_integral_type (type))
    {
      /* Integrals are right aligned.  */
      int offset = register_size (gdbarch, HPPA_FP4_REGNUM) - TYPE_LENGTH (type);
      if (readbuf != NULL)
	regcache_cooked_read_part (regcache, 28, offset,
				   TYPE_LENGTH (type), readbuf);
      if (writebuf != NULL)
	regcache_cooked_write_part (regcache, 28, offset,
				    TYPE_LENGTH (type), writebuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_LENGTH (type) <= 2 * 8)
    {
      /* Composite values are left aligned.  */
      int b;
      for (b = 0; b < TYPE_LENGTH (type); b += 8)
	{
	  int part = min (8, TYPE_LENGTH (type) - b);
	  if (readbuf != NULL)
	    regcache_cooked_read_part (regcache, 28 + b / 8, 0, part,
				       (char *) readbuf + b);
	  if (writebuf != NULL)
	    regcache_cooked_write_part (regcache, 28 + b / 8, 0, part,
					(const char *) writebuf + b);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else
    return RETURN_VALUE_STRUCT_CONVENTION;
}

d1033 137
@


1.194
log
@2004-12-17  Randolph Chung  <tausq@@debian.org>

	* hppa-hpux-tdep.c (IS_32BIT_TARGET): New.
	(in_opd_section): New.
	(hppa32_hpux_find_global_pointer): Rename from
	hppa_hpux_som_find_global_pointer.
	(hppa64_hpux_find_global_pointer): New.
	(ldsid_pattern): New.
	(hppa_hpux_search_pattern): New.
	(hppa32_hpux_search_dummy_call_sequence): New.
	(hppa64_hpux_search_dummy_call_sequence): New.
	(hppa_hpux_find_import_stub_for_addr): New.
	(hppa_hpux_sr_for_addr): New.
	(hppa_hpux_find_dummy_bpaddr): New.
	(hppa_hpux_init_abi): Use IS_32BIT_TARGET predicate.
	(hppa_hpux_som_init_abi): Set find_global_pointer method to
	hppa32_hpux_find_global_pointer instead of
	hppa_hpux_som_find_global_pointer.
	(hppa_hpux_elf_init_abi): Set find_global_pointer method.
	* hppa-tdep.c (hppa_init_objfile_priv_data): New.
	(read_unwind_info): Use function to initialize objfile-private data.
	(hppa32_push_dummy_call): Don't automatically set the RP if there is
	a push_dummy_code method.
	(hppa64_push_dummy_call): Retrieve and set the global pointer.
	Don't automatically set the RP if there is a push_dummy_code method.
	* hppa-tdep.h (hppa_objfile_private): Add dummy_call_sequence_reg and
	dummy_call_sequence_addr members.
	(hppa_init_objfile_priv_data): New prototype.
@
text
@d931 4
a934 2
/* This function pushes a stack frame with arguments as part of the
   inferior function calling mechanism.
d936 1
a936 3
   This is the version for the PA64, in which later arguments appear
   at higher addresses.  (The stack always grows towards higher
   addresses.)
d938 42
a979 2
   We simply allocate the appropriate amount of stack space and put
   arguments into their proper slots.
a980 3
   This ABI also requires that the caller provide an argument pointer
   to the callee, so we do that too.  */
   
d987 3
a989 2
  /* NOTE: cagney/2004-02-27: This is a guess - its implemented by
     reverse engineering testsuite failures.  */
d991 11
a1001 9
  /* Stack base address at which any pass-by-reference parameters are
     stored.  */
  CORE_ADDR struct_end = 0;
  /* Stack base address at which the first parameter is stored.  */
  CORE_ADDR param_end = 0;

  /* The inner most end of the stack after all the parameters have
     been pushed.  */
  CORE_ADDR new_sp = 0;
d1003 2
a1004 3
  /* Global pointer (r27) of the function we are trying to call.  */
  CORE_ADDR gp;
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1006 14
a1019 9
  /* Two passes.  First pass computes the location of everything,
     second pass writes the bytes out.  */
  int write_pass;
  for (write_pass = 0; write_pass < 2; write_pass++)
    {
      CORE_ADDR struct_ptr = 0;
      CORE_ADDR param_ptr = 0;
      int i;
      for (i = 0; i < nargs; i++)
d1021 1
a1021 5
	  struct value *arg = args[i];
	  struct type *type = check_typedef (value_type (arg));
	  if ((TYPE_CODE (type) == TYPE_CODE_INT
	       || TYPE_CODE (type) == TYPE_CODE_ENUM)
	      && TYPE_LENGTH (type) <= 8)
d1023 7
a1029 12
	      /* Integer value store, right aligned.  "unpack_long"
		 takes care of any sign-extension problems.  */
	      param_ptr += 8;
	      if (write_pass)
		{
		  ULONGEST val = unpack_long (type, VALUE_CONTENTS (arg));
		  int reg = 27 - param_ptr / 8;
		  write_memory_unsigned_integer (param_end - param_ptr,
						 val, 8);
		  if (reg >= 19)
		    regcache_cooked_write_unsigned (regcache, reg, val);
		}
d1033 1
a1033 3
	      /* Small struct value, store left aligned?  */
	      int reg;
	      if (TYPE_LENGTH (type) > 8)
d1035 6
a1040 3
		  param_ptr = align_up (param_ptr, 16);
		  reg = 26 - param_ptr / 8;
		  param_ptr += align_up (TYPE_LENGTH (type), 16);
d1042 11
a1052 1
	      else
d1054 6
a1059 19
		  param_ptr = align_up (param_ptr, 8);
		  reg = 26 - param_ptr / 8;
		  param_ptr += align_up (TYPE_LENGTH (type), 8);
		}
	      if (write_pass)
		{
		  int byte;
		  write_memory (param_end - param_ptr, VALUE_CONTENTS (arg),
				TYPE_LENGTH (type));
		  for (byte = 0; byte < TYPE_LENGTH (type); byte += 8)
		    {
		      if (reg >= 19)
			{
			  int len = min (8, TYPE_LENGTH (type) - byte);
			  regcache_cooked_write_part (regcache, reg, 0, len,
						      VALUE_CONTENTS (arg) + byte);
			}
		      reg--;
		    }
d1063 19
a1081 2
      /* Update the various stack pointers.  */
      if (!write_pass)
d1083 6
a1088 7
	  struct_end = sp + struct_ptr;
	  /* PARAM_PTR already accounts for all the arguments passed
	     by the user.  However, the ABI mandates minimum stack
	     space allocations for outgoing arguments.  The ABI also
	     mandates minimum stack alignments which we must
	     preserve.  */
	  param_end = struct_end + max (align_up (param_ptr, 16), 64);
d1090 2
d1094 16
a1109 2
  /* If a structure has to be returned, set up register 28 to hold its
     address */
d1111 1
a1111 1
    write_register (28, struct_addr);
d1113 1
a1114 1

d1116 1
a1116 1
    write_register (27, gp);
d1118 1
a1118 1
  /* Set the return address.  */
d1122 2
a1123 2
  /* Update the Stack Pointer.  */
  regcache_cooked_write_unsigned (regcache, HPPA_SP_REGNUM, param_end + 64);
d1125 1
a1125 2
  /* The stack will have 32 bytes of additional space for a frame marker.  */
  return param_end + 64;
d1127 1
d2494 2
a2495 2
/* Return the GDB type object for the "standard" data type of data
   in register N.  */
d2498 1
a2498 1
hppa32_register_type (struct gdbarch *gdbarch, int reg_nr)
d2500 1
a2500 1
   if (reg_nr < HPPA_FP4_REGNUM)
a2505 3
/* Return the GDB type object for the "standard" data type of data
   in register N.  hppa64 version.  */

d2507 1
a2507 1
hppa64_register_type (struct gdbarch *gdbarch, int reg_nr)
d2509 1
a2509 1
   if (reg_nr < HPPA_FP4_REGNUM)
d2515 2
a2516 2
/* Return True if REGNUM is not a register available to the user
   through ptrace().  */
d2519 1
a2519 1
hppa_cannot_store_register (int regnum)
d2525 1
d2527 7
d2709 4
d2718 4
a2744 2
  set_gdbarch_cannot_store_register (gdbarch, hppa_cannot_store_register);
  set_gdbarch_cannot_fetch_register (gdbarch, hppa_cannot_store_register);
@


1.193
log
@        * hppa-tdep.c (hppa_lookup_stub_minimal_symbol): New function.
        * hppa-tdep.h (hppa_lookup_stub_minimal_symbol): Add declaration.
        * solib-som.c (som_solib_create_inferior_hook): Replace stub
        msymbol search by call to hppa_lookup_stub_minimal_symbol. This
        extends the search to all objfiles, not just shared libraries.
        Remove unused variable.
@
text
@d276 14
d546 2
a547 9
    {
      obj_private = (struct hppa_objfile_private *)
	obstack_alloc (&objfile->objfile_obstack, 
                       sizeof (struct hppa_objfile_private));
      set_objfile_data (objfile, hppa_objfile_priv_data, obj_private);
      obj_private->unwind_info = NULL;
      obj_private->so_info = NULL;
      obj_private->dp = 0;
    }
d922 2
a923 1
  regcache_cooked_write_unsigned (regcache, HPPA_RP_REGNUM, bp_addr);
d963 4
d1048 5
d1054 2
a1055 1
  regcache_cooked_write_unsigned (regcache, HPPA_RP_REGNUM, bp_addr);
@


1.192
log
@2004-12-14  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_in_function_epilogue_p): New function.
	(hppa_gdbarch_init): Set in_epilogue_p method.
@
text
@d2258 25
@


1.191
log
@2004-12-13  Randolph Chung  <tausq@@debian.org>

	* Makefile.in (pa64solib_h, somsolib_h): Delete.
	(solib_pa64_h, solib_som_h): New.
	(HFILES_NO_SRCDIR, ALLDEPFILES): Replace somsolib.h with solib-som.h.
	(hppa-hpux-tdep.o, hpread.o): Update dependencies.
	(pa64solib.o, somsolib.o): Delete.
	(solib-pa64.o, solib-som.o): New.
	* hppa-hpux-tdep.c: Include new solib interfaces.
	(hppa_hpux_som_init_abi): Attach to SOM solib interface.
	(hppa_hpux_elf_init_abi): Attach to PA64 ELF solib interface.
	* hppa-tdep.c (internalize_unwinds): If solib_get_text_base method
	is available, use it to determine the base of unwind records.
	* hppa-tdep.h (gdbarch_tdep): Add new solib methods.
	* hpread.c: Replace somsolib.h with solib-som.h.
	(hpread_process_one_debug_symbol): Use target vector to get thread
	start address.
	* config/pa/hppa64.mt (TDEPFILES): Use new solib interface.
	* config/pa/hppahpux.mt (TDEPFILES): Likewise.
	* config/pa/hpux.mh (NATDEPFILES): Delete references to target objects.
	* config/pa/tm-hppah.h: Use new solib interface.
@
text
@d628 38
d2619 2
@


1.190
log
@2004-12-12  Andrew Cagney  <cagney@@gnu.org>

	* frame.c (get_prev_frame): When unwinding normal frames, check
	that the PC isn't zero.
	* hppa-tdep.c (hppa_stub_frame_unwind_cache): Delete check for a
	zero PC.
@
text
@d341 4
@


1.189
log
@2004-12-07  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_frame_prev_register_helper): Zero out the entire
	register for both 32- and 64-bit targets.
@
text
@a2107 3
  if (frame_pc_unwind (next_frame) == 0)
    return NULL;

@


1.188
log
@2004-12-07  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.h (gdbarch_tdep): Add unwind_adjust_stub method.
	* hppa-hpux-tdep.c (hppa_hpux_unwind_adjust_stub): New function.
	(hppa_hpux_init_abi) Set unwind_adjust_stub method.
	* hppa-tdep.c (hppa_frame_cache): Call unwind_adjust_stub method
    	if defined.
@
text
@d2462 4
a2465 1
	store_unsigned_integer (valuep, 4, 0);
@


1.187
log
@2004-12-07  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_stub_Frame_unwind_cache): Stop unwinding if
	unwinding from a frame with pc == 0.
	(hppa_stub_frame_this_id): Likewise.
	(hppa_stub_frame_prev_register): Only provide real values if the frame
	cache is not NULL.
@
text
@d1908 13
@


1.186
log
@* hppa-tdep.h (hppa_read_pc, hppa_write_pc, hppa_unwind_pc): New
prototypes.
* hppa-tdep.c (hppa_read_pc): Rename from hppa_target_read_pc.
Make global.  Remove HP-UX specific code.  Use
frame_unwind_register_unsigned instead of
frame_unwind_register_signed.
(hppa_write_pc): Rename from hppa_target_write_pc.  Make global.
Remove HP-UX specific code.
(hppa_unwind_pc): Make global.  Remove HP-UX specific code.
(hppa_frame_prev_register_helper): Set "flags" register to zero
for all unwound frames.
(hppa_gdbarch_init): Adjust.
* hppa-hpux-tdep.c (HPPA_HPUX_SS_INSYSCALL): New define.
(hppa_hpux_read_pc, hppa_hpux_write_pc)
(hppa_hpux_unwind_pc): New functions.
(hppa_hpux_init_abi): Set read_pc, write_pc and unwind_pc.
@
text
@d2095 3
d2132 5
a2136 1
  *this_id = frame_id_build (info->base, frame_pc_unwind (next_frame));
d2148 7
a2154 2
  hppa_frame_prev_register_helper (next_frame, info->saved_regs, regnum,
		                   optimizedp, lvalp, addrp, realnump, valuep);
@


1.185
log
@2004-12-05  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (unwind_command): Print the stub type for stub unwind
	records.
@
text
@d1037 2
a1038 6

/* Get the PC from %r31 if currently in a syscall.  Also mask out privilege
   bits.  */

static CORE_ADDR
hppa_target_read_pc (ptid_t ptid)
d1040 1
a1040 2
  int flags = read_register_pid (HPPA_FLAGS_REGNUM, ptid);
  ULONGEST ipsw = read_register_pid (HPPA_IPSW_REGNUM, ptid);
d1043 2
a1044 7
  /* The following test does not belong here.  It is OS-specific, and belongs
     in native code.  */
  /* Test SS_INSYSCALL */
  if (flags & 2)
    return read_register_pid (31, ptid) & ~0x3;

  pc = read_register_pid (HPPA_PCOQ_HEAD_REGNUM, ptid) & ~0x3;
d1048 3
a1050 3
     there.  This is needed when single stepping; if the nullified instruction
     is on a different line, we don't want gdb to think we've stepped onto
     that line.  */
d1054 1
a1054 1
  return pc;
d1057 2
a1058 5
/* Write out the PC.  If currently in a syscall, then also write the new
   PC value into %r31.  */

static void
hppa_target_write_pc (CORE_ADDR v, ptid_t ptid)
d1060 2
a1061 12
  int flags = read_register_pid (HPPA_FLAGS_REGNUM, ptid);

  /* The following test does not belong here.  It is OS-specific, and belongs
     in native code.  */
  /* If in a syscall, then set %r31.  Also make sure to get the 
     privilege bits set correctly.  */
  /* Test SS_INSYSCALL */
  if (flags & 2)
    write_register_pid (31, v | 0x3, ptid);

  write_register_pid (HPPA_PCOQ_HEAD_REGNUM, v, ptid);
  write_register_pid (HPPA_PCOQ_TAIL_REGNUM, v + 4, ptid);
d2174 1
a2174 1
static CORE_ADDR
d2180 2
a2181 2
  ipsw = frame_unwind_register_signed (next_frame, HPPA_IPSW_REGNUM);
  pc = frame_unwind_register_signed (next_frame, HPPA_PCOQ_HEAD_REGNUM) & ~3;
d2185 3
a2187 3
     there.  This is needed when single stepping; if the nullified instruction
     is on a different line, we don't want gdb to think we've stepped onto
     that line.  */
d2191 1
a2191 1
  return pc;
d2429 18
d2560 2
a2561 2
  set_gdbarch_read_pc (gdbarch, hppa_target_read_pc);
  set_gdbarch_write_pc (gdbarch, hppa_target_write_pc);
@


1.184
log
@2004-12-03  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (instruction_nullified): Delete.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-tdep.c (hppa_target_read_pc): Adjust pc if instruction is
	nullified.
	(hppa_unwind_pc): Likewise.
	(hppa_instruction_nullified): Delete.
	(hppa_gdbarch_init): Don't set instruction_nullified method.
	* infrun.c (infwait_states): Remove infwait_nullified_state.
	(handle_inferior_event): Remove handling of infwait_nullified_state.
	Remove handling of nullified instructions.


testsuite/

	* gdb.arch/pa-nullify.exp: New file.
	* gdb.arch/pa-nullify.s: New file.
@
text
@d2290 25
@


1.183
log
@2004-11-30  Randolph Chung  <tausq@@debian.org>

	* breakpoint.c (break_at_finish_command): Delete.
	(break_at_finish_command_1): Delete.
	(break_at_finish_at_depth_command): Delete.
	(break_at_finish_at_depth_command_1): Delete.
	(tbreak_at_finish_command): Delete.
	* hppa-tdep.c (_initialize_hppa_tdep): Remove deprecated xbreak, tbreak
	and bx commands.
@
text
@d1045 2
d1054 11
a1064 1
  return read_register_pid (HPPA_PCOQ_HEAD_REGNUM, ptid) & ~0x3;
d2200 15
a2214 1
  return frame_unwind_register_signed (next_frame, HPPA_PCOQ_HEAD_REGNUM) & ~3;
a2319 16
static int
hppa_instruction_nullified (struct gdbarch *gdbarch, struct regcache *regcache)
{
  ULONGEST tmp, ipsw, flags;

  regcache_cooked_read (regcache, HPPA_IPSW_REGNUM, &tmp);
  ipsw = extract_unsigned_integer (&tmp, 
		  		   register_size (gdbarch, HPPA_IPSW_REGNUM));

  regcache_cooked_read (regcache, HPPA_FLAGS_REGNUM, &tmp);
  flags = extract_unsigned_integer (&tmp, 
		  		    register_size (gdbarch, HPPA_FLAGS_REGNUM));

  return ((ipsw & 0x00200000) && !(flags & 0x2));
}

a2585 1
  set_gdbarch_instruction_nullified (gdbarch, hppa_instruction_nullified);
@


1.182
log
@2004-11-23  Randolph Chung  <tausq@@debian.org>

	* arch-utils.c (generic_instruction_nullified): New.
	* arch-utils.h (generic_instruction_nullified): New.
	* gdbarch.sh (instruction_nullified): New method.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* infrun.c (INSTRUCTION_NULLIFIED): Delete.
	(handle_inferior_event): Replace INSTRUCTION_NULLIFIED with calls to
	new gdbarch method.
	* config/pa/tm-hppa.h (INSTRUCTION_NULLIFIED): Delete definition.
	* hppa-tdep.c (hppa_instruction_nullified): Remove prototype and make
	static.  Rewrite to work directly off the passed regcache.
	(hppa_gdbarch_init): Set instruction_nullified method.
@
text
@a2606 3
  void break_at_finish_command (char *arg, int from_tty);
  void tbreak_at_finish_command (char *arg, int from_tty);
  void break_at_finish_at_depth_command (char *arg, int from_tty);
a2615 30
  deprecate_cmd (add_com ("xbreak", class_breakpoint, 
			  break_at_finish_command,
			  concat ("Set breakpoint at procedure exit. \n\
Argument may be function name, or \"*\" and an address.\n\
If function is specified, break at end of code for that function.\n\
If an address is specified, break at the end of the function that contains \n\
that exact address.\n",
		   "With no arg, uses current execution address of selected stack frame.\n\
This is useful for breaking on return to a stack frame.\n\
\n\
Multiple breakpoints at one place are permitted, and useful if conditional.\n\
\n\
Do \"help breakpoints\" for info on other commands dealing with breakpoints.", NULL)), NULL);
  deprecate_cmd (add_com_alias ("xb", "xbreak", class_breakpoint, 1), NULL);
  deprecate_cmd (add_com_alias ("xbr", "xbreak", class_breakpoint, 1), NULL);
  deprecate_cmd (add_com_alias ("xbre", "xbreak", class_breakpoint, 1), NULL);
  deprecate_cmd (add_com_alias ("xbrea", "xbreak", class_breakpoint, 1), NULL);

  deprecate_cmd (c = add_com ("txbreak", class_breakpoint, 
			      tbreak_at_finish_command,
"Set temporary breakpoint at procedure exit.  Either there should\n\
be no argument or the argument must be a depth.\n"), NULL);
  set_cmd_completer (c, location_completer);
  
  if (xdb_commands)
    deprecate_cmd (add_com ("bx", class_breakpoint, 
			    break_at_finish_at_depth_command,
"Set breakpoint at procedure exit.  Either there should\n\
be no argument or the argument must be a depth.\n"), NULL);

@


1.181
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* sparc-tdep.c: Replace VALUE_TYPE with value_type.
	* v850-tdep.c, sparc64-tdep.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, s390-tdep.c, mcore-tdep.c: Ditto.
	* h8300-tdep.c, arm-linux-tdep.c, amd64-tdep.c: Ditto.
	* hppa-tdep.c, mips-tdep.c, m88k-tdep.c: Ditto.
	* m68hc11-tdep.c, m32r-tdep.c, ia64-tdep.c: Ditto.
	* frv-tdep.c, cris-tdep.c, avr-tdep.c, alpha-tdep.c: Ditto.
@
text
@a73 1
int hppa_instruction_nullified (void);
d2294 2
a2295 2
int
hppa_instruction_nullified (void)
d2297 9
a2305 5
  /* brobecker 2002/11/07: Couldn't we use a ULONGEST here? It would
     avoid the type cast.  I'm leaving it as is for now as I'm doing
     semi-mechanical multiarching-related changes.  */
  const int ipsw = (int) read_register (HPPA_IPSW_REGNUM);
  const int flags = (int) read_register (HPPA_FLAGS_REGNUM);
d2576 1
@


1.180
log
@2004-11-12  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_skip_permanent_breakpoint): Move definition ...
	* hppa-hpux-tdep.c (hppa_skip_permanent_breakpoint): ... to here.
	* config/pa/tm-hppa.h (SKIP_PERMANENT_BREAKPOINT): Move definition ...
	* config/pa/tm-hppah.h (SKIP_PERMANENT_BREAKPOINT): ... to here.
@
text
@d761 1
a761 1
	  struct type *type = check_typedef (VALUE_TYPE (arg));
d925 1
a925 1
	  struct type *type = check_typedef (VALUE_TYPE (arg));
@


1.179
log
@2004-11-11  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (skip_prologue_hard_way): Make static, add
	stop_after_branch parameter and use it to determine if we should look
	at the delay slot of the first branch insn to find prologue insns.
	(hppa_skip_prologue): Update comment and call to skip_prologue_hard_way.
	(hppa_frame_cache): Likewise.
@
text
@a2266 24
void
hppa_skip_permanent_breakpoint (void)
{
  /* To step over a breakpoint instruction on the PA takes some
     fiddling with the instruction address queue.

     When we stop at a breakpoint, the IA queue front (the instruction
     we're executing now) points at the breakpoint instruction, and
     the IA queue back (the next instruction to execute) points to
     whatever instruction we would execute after the breakpoint, if it
     were an ordinary instruction.  This is the case even if the
     breakpoint is in the delay slot of a branch instruction.

     Clearly, to step past the breakpoint, we need to set the queue
     front to the back.  But what do we put in the back?  What
     instruction comes after that one?  Because of the branch delay
     slot, the next insn is always at the back + 4.  */
  write_register (HPPA_PCOQ_HEAD_REGNUM, read_register (HPPA_PCOQ_TAIL_REGNUM));
  write_register (HPPA_PCSQ_HEAD_REGNUM, read_register (HPPA_PCSQ_TAIL_REGNUM));

  write_register (HPPA_PCOQ_TAIL_REGNUM, read_register (HPPA_PCOQ_TAIL_REGNUM) + 4);
  /* We can leave the tail's space the same, since there's no jump.  */
}

@


1.178
log
@2004-11-11  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_frame_cache): Properly handle the frame pointer
	register so that it can be unwound from anywhere in the prologue.
@
text
@d1250 2
a1251 2
CORE_ADDR
skip_prologue_hard_way (CORE_ADDR pc)
d1258 1
d1302 2
d1440 1
a1440 1
      if (is_branch (inst))
d1461 7
d1526 7
a1532 6
   returns an address that (if we're lucky) follows the prologue.  If
   LENIENT, then we must skip everything which is involved in setting
   up the frame (it's OK to skip more, just so long as we don't skip
   anything which might clobber the registers which are being saved.
   Currently we must not skip more on the alpha, but we might the lenient
   stuff some day.  */
d1557 1
a1557 1
    return (skip_prologue_hard_way (pc));
d1640 1
a1640 1
    /* We have to use hppa_skip_prologue instead of just 
d1644 7
a1650 1
       function.  */
d1657 1
a1657 1
    prologue_end = hppa_skip_prologue (u->region_start);
@


1.177
log
@2004-11-10  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Make static.
	(hppa32_push_dummy_call, hppa64_push_dummy_call): Likewise.
	(hppa_fetch_pointer_argument): Likewise.
	(hppa_frame_cache): Use safe_frame_unwind_memory instead of
	deprecated_read_memory_nobpt.
	(_initialize_hppa_tdep): Replace deprecated_add_show_from_set/
	add_set_cmd sequence with add_setshow_boolean_cmd.
@
text
@d1565 1
d1698 4
a1809 3
	fp may be zero if it is not available in an inner frame because
	it has been modified by not yet saved.
	
d1872 20
a1891 7
  /* If the frame pointer was not saved in this frame, but we should be saving
     it, set it to an invalid value so that another frame will not pick up the 
     wrong frame pointer.  This can happen if we start unwinding after the 
     frame pointer has been modified, but before we've saved it to the
     stack.  */
  if (u->Save_SP && !trad_frame_addr_p (cache->saved_regs, HPPA_FP_REGNUM))
    trad_frame_set_value (cache->saved_regs, HPPA_FP_REGNUM, 0);
@


1.176
log
@2004-11-03  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_frame_cache): Use frame_pc_unwind instead of
    frame_func_unwind to locate the unwind entry.
	(hppa_frame_this_id): Likewise.
@
text
@d635 1
a635 1
const char *
d678 1
a678 1
const char *
d723 1
a723 1
CORE_ADDR
d895 1
a895 1
CORE_ADDR
d1656 10
a1665 2
	long status = deprecated_read_memory_nobpt (pc, buf4, sizeof buf4);
	long inst = extract_unsigned_integer (buf4, sizeof buf4);
d2350 1
a2350 1
CORE_ADDR
d2638 7
a2644 5
  deprecated_add_show_from_set
    (add_set_cmd ("hppa", class_maintenance, var_zinteger,
		  &hppa_debug, "Set hppa debugging.\n\
When non-zero, hppa specific debugging is enabled.", &setdebuglist),
     &showdebuglist);
@


1.175
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* hppa-tdep.c (hppa_stub_unwind_sniffer): Replace
	IN_SOLIB_CALL_TRAMPOLINE with tdep.in_solib_call_trampoline.
	* hppa-tdep.h (struct gdbarch_tdep): Add in_solib_call_trampoline.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Set same.
	* hppa-linux-tdep.c (hppa_linux_init_abi): Ditto.
@
text
@d1583 1
a1583 1
  u = find_unwind_entry (frame_func_unwind (next_frame));
d1633 7
a1639 1
    prologue_end = hppa_skip_prologue (frame_func_unwind (next_frame));
d1647 1
a1647 1
    for (pc = frame_func_unwind (next_frame);
d1890 8
a1897 2
  struct hppa_frame_cache *info = hppa_frame_cache (next_frame, this_cache);
  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
d1943 1
d1946 4
d1957 1
d1982 4
a1985 1
	 cache->saved_regs[HPPA_RP_REGNUM].addr = -20;
d1987 4
a1990 1
	 cache->saved_regs[HPPA_RP_REGNUM].addr = -16;
d1993 4
d2188 1
d2192 1
@


1.174
log
@* hppa-tdep.c (hppa_frame_cache): Add support for OpenBSD and
NetBSD system call stubs that store %rp in the ERP slot of the
stack frame.
@
text
@d2099 2
d2103 2
a2104 1
      || IN_SOLIB_CALL_TRAMPOLINE (pc, NULL)
@


1.174.2.1
log
@2004-11-03  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_frame_cache): Use frame_pc_unwind instead of
    frame_func_unwind to locate the unwind entry.
	(hppa_frame_this_id): Likewise.
@
text
@d1583 1
a1583 1
  u = find_unwind_entry (frame_pc_unwind (next_frame));
d1633 1
a1633 7

    /* We used to use frame_func_unwind () to locate the beginning of the
       function to pass to skip_prologue ().  However, when objects are 
       compiled without debug symbols, frame_func_unwind can return the wrong 
       function (or 0).  We can do better than that by using unwind records.  */

    prologue_end = hppa_skip_prologue (u->region_start);
d1641 1
a1641 1
    for (pc = u->region_start;
d1884 2
a1885 8
  struct hppa_frame_cache *info;
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  struct unwind_table_entry *u;

  info = hppa_frame_cache (next_frame, this_cache);
  u = find_unwind_entry (pc);

  (*this_id) = frame_id_build (info->base, u->region_start);
a1930 1
  int found_rp;
a1932 4
  if (hppa_debug)
    fprintf_unfiltered (gdb_stdlog, "{ hppa_fallback_frame_cache (frame=%d)-> ",
      frame_relative_level(next_frame));

a1939 1
  found_rp = 0;
d1964 1
a1964 4
	 {
	   cache->saved_regs[HPPA_RP_REGNUM].addr = -20;
	   found_rp = 1;
	 }
d1966 1
a1966 4
	 {
	   cache->saved_regs[HPPA_RP_REGNUM].addr = -16;
	   found_rp = 1;
	 }
a1968 4
  if (hppa_debug)
    fprintf_unfiltered (gdb_stdlog, " frame_size = %d, found_rp = %d }\n",
      frame_size, found_rp);

a2156 1
  gdb_flush (gdb_stdout);
a2159 1
  gdb_flush (gdb_stdout);
@


1.173
log
@2004-07-31  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Rename
	trad_frame_get_prev_register.
	* vax-tdep.c (vax_frame_prev_register): Update.
	* trad-frame.h: Update.
	* trad-frame.c (trad_frame_get_register): Update.
	* sparcobsd-tdep.c (sparc32obsd_frame_prev_register): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64obsd-tdep.c (sparc64obsd_frame_prev_register): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_prev_register):
	Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-linux-tdep.c (sparc32_linux_sigtramp_frame_prev_register):
	Update.
	* s390-tdep.c (s390_frame_prev_register)
	(s390_stub_frame_prev_register)
	(s390_sigtramp_frame_prev_register): Update.
	* rs6000-tdep.c (rs6000_frame_prev_register): Update.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_prev_register): Update.
	* mips-tdep.c (mips_mdebug_frame_prev_register): Update.
	* m88k-tdep.c (m88k_frame_prev_register)
	* m68hc11-tdep.c (m68hc11_frame_prev_register)
	* m32r-tdep.c (m32r_frame_prev_register): Update.
	* hppa-tdep.c (hppa_frame_prev_register_helper)
	* frv-tdep.c (frv_frame_prev_register): Update.
	* d10v-tdep.c (d10v_frame_prev_register): Update.
	* cris-tdep.c (cris_frame_prev_register): Update.
	* avr-tdep.c (avr_frame_prev_register): Update.
	* arm-tdep.c (arm_prologue_prev_register)
	(arm_sigtramp_prev_register): Update.
@
text
@d1663 5
@


1.172
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d2344 3
a2346 3
	  trad_frame_prev_register (next_frame, saved_regs,
				    HPPA_PCOQ_HEAD_REGNUM, optimizedp,
				    lvalp, addrp, realnump, valuep);
d2360 2
a2361 2
  trad_frame_prev_register (next_frame, saved_regs, regnum,
                            optimizedp, lvalp, addrp, realnump, valuep);
@


1.171
log
@2004-07-20  Andrew Cagney  <cagney@@gnu.org>

	* breakpoint.c (deprecated_read_memory_nobpt): Rename
	read_memory_nobpt.
	* sparc-linux-tdep.c (sparc_linux_sigtramp_start): Update.
	* s390-tdep.c (s390_readinstruction, s390_in_function_epilogue_p)
	(s390_sigtramp_frame_sniffer): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue): Update.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Update.
	* mips-tdep.c (mips_fetch_instruction, mips16_fetch_instruction)
	(mips32_fetch_instruction): Update.
	* mcore-tdep.c (get_insn): Update.
	* m68klinux-tdep.c (m68k_linux_pc_in_sigtramp): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_offset): Update.
	* i386ly-tdep.c (i386lynx_saved_pc_after_call): Update.
	* i386-linux-tdep.c (i386_linux_sigtramp_start)
	(i386_linux_rt_sigtramp_start): Update.
	* i386-linux-nat.c (child_resume): Update.
	* hppa-tdep.c (skip_prologue_hard_way, hppa_frame_cache): Update.
	* hppa-linux-tdep.c (insns_match_pattern): Update.
	* gdbcore.h: Update.
	* frv-tdep.c (frv_gdbarch_adjust_breakpoint_address): Update.
	* frame.c (safe_frame_unwind_memory): Update.
	* amd64-linux-tdep.c (amd64_linux_sigtramp_start): Update.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Update.
	* alpha-tdep.c (alpha_read_insn): Update.
@
text
@d2592 5
a2596 3
  add_show_from_set (add_set_cmd ("hppa", class_maintenance, var_zinteger,
				  &hppa_debug, "Set hppa debugging.\n\
When non-zero, hppa specific debugging is enabled.", &setdebuglist), &showdebuglist);
@


1.170
log
@2004-06-07  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_frame_cache): Handle the cases when we start
	unwinding after sp has been saved to the stack but before the end
	of the prologue, and after the fp has been modified but before it has
	been saved to the stack.
	(hppa_frame_base_address, hppa_frame_base, hppa_frame_base_sniffer):
	Remove superfluous definitions.
	(hppa_gdbarch_init): Remove superfluous frame base sniffer.
@
text
@d1330 1
a1330 1
      status = read_memory_nobpt (pc, buf, 4);
d1379 1
a1379 1
	      status = read_memory_nobpt (pc, buf, 4);
d1392 1
a1392 1
      status = read_memory_nobpt (pc + 4, buf, 4);
d1419 1
a1419 1
	      status = read_memory_nobpt (pc, buf, 4);
d1425 1
a1425 1
	      status = read_memory_nobpt (pc + 4, buf, 4);
d1650 1
a1650 1
	long status = read_memory_nobpt (pc, buf4, sizeof buf4);
@


1.169
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Don't cache symbol values.
	* hppa-linux-tdep.c (hppa_linux_in_dyncall): Likewise.
	* hppa-tdep.c (hppa_symbol_address): New function definition.
	* hppa-tdep.h (hppa_symbol_address): New function declaration.
@
text
@d1786 2
a1787 1
	fp should never be zero here; checking just in case. 
d1803 2
a1804 1
     else if (frame_pc_unwind (next_frame) >= prologue_end)
a1805 2
        if (u->Save_SP && trad_frame_addr_p (cache->saved_regs, HPPA_SP_REGNUM))
          {
a1813 11
          }
        else
          {
            /* The prologue has been slowly allocating stack space.  Adjust
	     the SP back.  */
            cache->base = this_sp - frame_size;
	    if (hppa_debug)
	      fprintf_unfiltered (gdb_stdlog, " (base=0x%s) [unwind adjust] } ",
			          paddr_nz (cache->base));

          }
d1817 3
a1819 3
	/* This frame has not yet been created. */
        cache->base = this_sp;

d1821 1
a1821 1
	  fprintf_unfiltered (gdb_stdlog, " (base=0x%s) [before prologue] } ",
a1824 1

d1851 8
a2015 22
static CORE_ADDR
hppa_frame_base_address (struct frame_info *next_frame,
				void **this_cache)
{
  struct hppa_frame_cache *info = hppa_frame_cache (next_frame,
							   this_cache);
  return info->base;
}

static const struct frame_base hppa_frame_base = {
  &hppa_frame_unwind,
  hppa_frame_base_address,
  hppa_frame_base_address,
  hppa_frame_base_address
};

static const struct frame_base *
hppa_frame_base_sniffer (struct frame_info *next_frame)
{
  return &hppa_frame_base;
}

a2530 1
  frame_base_append_sniffer (gdbarch, hppa_frame_base_sniffer);
@


1.168
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.h (struct value): Forward declaration.
	(gdbarch_tdep): Define tdep find_global_pointer method.
	* hppa-tdep.c (hppa32_push_dummy_call): Find the global pointer
	associated with the function we are trying to call, and write it
	to the gp register.
	(hppa32_convert_from_funct_ptr_addr): New function.
	(hppa_find_global_pointer): New function.
	(hppa_gdbarch_init): Set default find_global_pointer method; set
	convert_from_func_ptr_addr method.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): New function.
	(hppa_linux_init_abi): Set find_global_pointer method.
	* Makefile.in (hppa-linux-tdep.o): Add value.h dependency.
@
text
@d265 12
@


1.167
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d730 6
d856 5
d994 16
d2339 6
d2446 2
d2507 2
@


1.166
log
@* hppa-tdep.c (hppa_frame_prev_register_helper): Reimplement to
handle VALUEP being null.
@
text
@d712 1
a712 1
hppa32_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
d873 1
a873 1
hppa64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
@


1.165
log
@2004-05-25  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_fallback_frame_cache): Handle stack adjustment,
	and multiple stack unwinds.
	(hppa_stub_unwind_sniffer): Handle unwind from pc == 0.
@
text
@d2319 21
a2339 6
  int pcoqt = (regnum == HPPA_PCOQ_TAIL_REGNUM);
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  int regsize = register_size (gdbarch, HPPA_PCOQ_HEAD_REGNUM);

  if (pcoqt)
    regnum = HPPA_PCOQ_HEAD_REGNUM;
a2342 4

  if (pcoqt)
    store_unsigned_integer (valuep, regsize, 
		      	    extract_unsigned_integer (valuep, regsize) + 4);
d2344 1
a2573 1

@


1.164
log
@2004-05-24  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (SR4EXPORT_LDIL_OFFSET, SR4EXPORT_LDO_OFFSET): Remove
	unused symbols.
	* hppa-tdep.h (HPPA_INSTRUCTION_SIZE): Remove, since there are no more
	references.
@
text
@d1890 1
d1899 1
d1919 2
d1924 1
a1924 4
	{
	  cache->saved_regs[HPPA_RP_REGNUM].addr = -20;
	  break;
	}
d1926 1
a1926 4
	{
	  cache->saved_regs[HPPA_RP_REGNUM].addr = -16;
	  break;
	}
d1929 2
a1930 1
  cache->base = frame_unwind_register_unsigned (next_frame, HPPA_SP_REGNUM);
d2082 2
a2083 1
  if (IN_SOLIB_CALL_TRAMPOLINE (pc, NULL)
@


1.163
log
@2004-05-24  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c: Fix handling of 8-byte structures; they should not
	be "small_struct".
@
text
@a66 5
/* Define offsets into the call dummy for the _sr4export address.
   See comments related to CALL_DUMMY for more info.  */
#define SR4EXPORT_LDIL_OFFSET (HPPA_INSTRUCTION_SIZE * 12)
#define SR4EXPORT_LDO_OFFSET (HPPA_INSTRUCTION_SIZE * 13)

@


1.162
log
@2004-05-18  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_frame_cache): Check for validity of r31 for
	millicode functions.
@
text
@d793 1
a793 1
	      if (param_len > 4)
@


1.161
log
@2004-05-18  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_frame_cache): If a frame pointer is available, use
	it for unwinding the stack.
@
text
@d1810 1
a1810 1
      if (trad_frame_addr_p (cache->saved_regs, HPPA_RP_REGNUM))
@


1.160
log
@2004-05-18  Randolph Chung <tausq@@debian.org>

	* hppa-tdep.c (hppa_stub_frame_unwind_cache): Don't do export stub
	handling for 64-bit HPUX (elf).
@
text
@d1728 1
d1737 32
a1768 1
    if (frame_pc_unwind (next_frame) >= prologue_end)
@


1.159
log
@2004-05-17  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_stub_frame_unwind_cache): For HPUX stub unwinding,
	check to see if we are unwinding an export stub.  Export stubs clobber
	the %rp in the call path and stores the original rp in a stack slot.
@
text
@d2001 1
a2001 2
  if (gdbarch_osabi (gdbarch) == GDB_OSABI_HPUX_ELF 
      || gdbarch_osabi (gdbarch) == GDB_OSABI_HPUX_SOM)
@


1.158
log
@2004-05-17  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c: Remove superfluous #include's.
	* Makefile.in (hppa-tdep.o): Update dependencies.
@
text
@d1990 1
d1999 19
a2018 1
  info->base = frame_unwind_register_unsigned (next_frame, HPPA_SP_REGNUM);
@


1.157
log
@2004-05-17  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (THREAD_INITIAL_FRAME_SYMBOL): Delete unused symbol.
	(THREAD_INITIAL_FRAME_SYM_LEN): Likewise.
	(unwind_command, hppa_alignof, prologue_inst_adjust_sp)
	(is_branch, inst_saves_gr, inst_saves_fr, compare_unwind_entries)
	(read_unwind_info, internalize_unwinds, record_text_segment_lowaddr):
	Remove static function declarations.
@
text
@a27 1
#include "frame.h"
a29 1
#include "value.h"
a31 1
#include "language.h"
a33 1
#include "infttrace.h"
a36 1
#include "infcall.h"
a41 3
#include "gdb_stat.h"
#include "gdb_wait.h"

a43 2
#include "target.h"
#include "symfile.h"
@


1.156
log
@2004-05-07  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (skip_prologue_hard_way, hppa_frame_cache): Use
	read_memory_nobpt for code reading when doing frame unwinding.
	* hppa-linux-tdep.c (insns_match_pattern): Likewise.
@
text
@a81 5
/* To support detection of the pseudo-initial frame
   that threads have. */
#define THREAD_INITIAL_FRAME_SYMBOL  "__pthread_exit"
#define THREAD_INITIAL_FRAME_SYM_LEN  sizeof(THREAD_INITIAL_FRAME_SYMBOL)

a85 21
static void unwind_command (char *, int);

static int hppa_alignof (struct type *);

static int prologue_inst_adjust_sp (unsigned long);

static int is_branch (unsigned long);

static int inst_saves_gr (unsigned long);

static int inst_saves_fr (unsigned long);

static int compare_unwind_entries (const void *, const void *);

static void read_unwind_info (struct objfile *);

static void internalize_unwinds (struct objfile *,
				 struct unwind_table_entry *,
				 asection *, unsigned int,
				 unsigned int, CORE_ADDR);
static void record_text_segment_lowaddr (bfd *, asection *, void *);
@


1.155
log
@2004-05-07  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_frame_prev_register_helper): New function to
	do common handling of the pcoqt register.
	(hppa_frame_prev_register, hppa_stub_frame_prev_register): Convert
	to use helper function.
	(hppa_frame_unwind_sniffer): Only use if unwind entry is present.
	(hppa_fallback_frame_cache, hppa_fallback_frame_this_id)
	(hppa_fallback_frame_prev_register, hppa_fallback_frame_unwind): New
	generic fallback unwinder when all else fails.
	(hppa_gdbarch_init): Add fallback sniffer.
	* hppa-tdep.h (hppa_frame_prev_register_helper): Prototype.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_prev_register): Convert
	to use helper function.
@
text
@d1332 1
a1332 1
      status = target_read_memory (pc, buf, 4);
d1381 1
a1381 1
	      status = target_read_memory (pc, buf, 4);
d1394 1
a1394 1
      status = target_read_memory (pc + 4, buf, 4);
d1421 1
a1421 1
	      status = target_read_memory (pc, buf, 4);
d1427 1
a1427 1
	      status = target_read_memory (pc + 4, buf, 4);
d1652 1
a1652 1
	long status = target_read_memory (pc, buf4, sizeof buf4);
@


1.154
log
@2004-05-06  Randolph Chung  <tausq@@debian.org>

	* config/pa/tm-hppa.h (RO_REGNUM, FLAGS_REGNUM, RP_REGNUM)
	(HPPA_FP_REGNUM, HPPA_SP_REGNUM, SAR_REGNUM, IPSW_REGNUM)
	(PCOQ_HEAD_REGNUM, PCSQ_HEAD_REGNUM, PCOQ_TAIL_REGNUM, PCSQ_TAIL_REGNUM)
	(EIEM_REGNUM, IIR_REGNUM, ISR_REGNUM, IOR_REGNUM, SR4_REGNUM)
	(RCR_REGNUM, PID0_REGNUM, PID1_REGNUM, PID2_REGNUM, PID3_REGNUM)
	(CCR_REGNUM, TR0_REGNUM, CR27_REGNUM, HPPA_FP0_REGNUM, FP4_REGNUM)
	(ARG0_REGNUM, ARG1_REGNUM, ARG2_REGNUM, ARG3_REGNUM): Move *_REGNUM
	definitions ...
	* hppa-tdep.h: ... to here, with HPPA_ prefix.
	* Makefile.in (hppah-nat.o): Add $(hppa_tdep_h)
	* hppa-hpux-tdep.c (hppa32_hpux_frame_find_saved_regs_in_sig)
	(hppa64_hpux_frame_find_saved_regs_in_sig)
	(child_get_current_exception_event): Add HPPA_ prefix to *_REGNUM usage.
	* hppa-linux-nat.c (GR_REGNUM, TR_REGNUM, greg_map): Likewise.
	* hppa-linux-tdep.c (hppa_dwarf_reg_to_regnum)
	(hppa_linux_target_write_pc, hppa_linux_sigtramp_frame_unwind_cache)
	(hppa_linux_sigtramp_frame_prev_register): Likewise.
	* hppa-tdep.c (hppa32_return_value, hppa64_return_value)
	(hppa32_push_dummy_call, hppa64_push_dummy_call, hppa64_frame_align)
	(hppa_target_read_pc, hppa_target_write_pc, hppa_frame_cache)
	(hppa_frame_prev_register, hppa_stub_frame_unwind_cache)
	(hppa_stub_frame_prev_register, hppa_unwind_dummy_id)
	(hppa_skip_permanent_breakpoint, hppa_instruction_nullified)
	(hppa32_register_type, hppa_cannot_store_register)
	(hppa_fetch_pointer_argument, hppa_pseudo_register_read): Likewise.
	* hppah-nat.c (store_inferior_registers, fetch_register): Likewise.
	* hpread.c (hpread_process_one_debug_symbol): Likewise.
	* pa64solib.c (pa64_solib_have_load_event)
	(pa64_solib_have_unload_event, pa64_solib_loaded_library_pathname)
	(pa64_solib_unloaded_library_pathname): Likewise.
	* somsolib.c (som_solib_have_load_event, som_solib_have_unload_event)
	(som_solib_library_pathname): Likewise.
@
text
@d1859 4
a1862 4
				 void **this_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *valuep)
d1865 56
a1920 2
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  if (regnum == HPPA_PCOQ_TAIL_REGNUM)
d1922 12
a1933 7
      /* The PCOQ TAIL, or NPC, needs to be computed from the unwound
	 PC register.  */
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = 0;
      if (valuep)
d1935 2
a1936 12
	  int regsize = register_size (gdbarch, HPPA_PCOQ_HEAD_REGNUM);
	  CORE_ADDR pc;
	  int optimized;
	  enum lval_type lval;
	  CORE_ADDR addr;
	  int realnum;
	  bfd_byte value[MAX_REGISTER_SIZE];
	  trad_frame_prev_register (next_frame, info->saved_regs,
				    HPPA_PCOQ_HEAD_REGNUM, &optimized, &lval, &addr,
				    &realnum, &value);
	  pc = extract_unsigned_integer (&value, regsize);
	  store_unsigned_integer (valuep, regsize, pc + 4);
d1939 8
d1949 2
a1950 2
      trad_frame_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
d1952 11
d1965 14
a1978 1
static const struct frame_unwind hppa_frame_unwind =
d1981 2
a1982 2
  hppa_frame_this_id,
  hppa_frame_prev_register
d1986 1
a1986 1
hppa_frame_unwind_sniffer (struct frame_info *next_frame)
d1988 1
a1988 1
  return &hppa_frame_unwind;
d2055 1
a2055 1
			       int *realnump, void *bufferp)
d2059 2
a2060 13
  int pcoqt = (regnum == HPPA_PCOQ_TAIL_REGNUM);
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  int regsize = register_size (gdbarch, HPPA_PCOQ_HEAD_REGNUM);

  if (pcoqt)
    regnum = HPPA_PCOQ_HEAD_REGNUM;

  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
                            optimizedp, lvalp, addrp, realnump, bufferp);

  if (pcoqt)
    store_unsigned_integer (bufferp, regsize, 
		      	    extract_unsigned_integer (bufferp, regsize) + 4);
d2303 22
d2486 1
@


1.153
log
@2004-04-24  Randolph Chung  <tausq@@debian.org>

	* configure.host (hppa*-*-linux*): New target.
	* configure.tgt (hppa*-*-linux*): Likewise.
	* hppa-tdep.c (hppa_gdbarch_init): Set cannot_fetch_register, move
	gdbarch_init_osabi() call earlier so that osabi-specific frame
	unwinders can be registered first.
	* config/djgpp/fnchange.lst: Add entries for hppa-linux-tdep.c and
	hppa-linux-nat.c.
	* config/pa/tm-hppa.h (ISR_REGNUM, PID0_REGNUM, PID1_REGNUM)
	(PID2_REGNUM, PID3_REGNUM): Add definitions of some register numbers.
	* config/pa/linux.mh: New file.
	* config/pa/linux.mt: New file.
	* config/pa/nm-linux.h: New file.
	* config/pa/xm-linux.h: New file.
	* hppa-linux-nat.c: New file.
	* hppa-linux-tdep.c: New file.
@
text
@d129 1
a129 1
      int reg = TYPE_CODE (type) == TYPE_CODE_FLT ? FP4_REGNUM : 28;
d172 1
a172 1
      int offset = register_size (gdbarch, FP4_REGNUM) - TYPE_LENGTH (type);
d174 1
a174 1
	regcache_cooked_read_part (regcache, FP4_REGNUM, offset,
d177 1
a177 1
	regcache_cooked_write_part (regcache, FP4_REGNUM, offset,
d184 1
a184 1
      int offset = register_size (gdbarch, FP4_REGNUM) - TYPE_LENGTH (type);
d892 1
a892 1
  regcache_cooked_write_unsigned (regcache, RP_REGNUM, bp_addr);
d895 1
a895 1
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, param_end);
d1014 1
a1014 1
  regcache_cooked_write_unsigned (regcache, RP_REGNUM, bp_addr);
d1017 1
a1017 1
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, param_end + 64);
d1047 1
a1047 1
  int flags = read_register_pid (FLAGS_REGNUM, ptid);
d1055 1
a1055 1
  return read_register_pid (PCOQ_HEAD_REGNUM, ptid) & ~0x3;
d1064 1
a1064 1
  int flags = read_register_pid (FLAGS_REGNUM, ptid);
d1074 2
a1075 2
  write_register_pid (PCOQ_HEAD_REGNUM, v, ptid);
  write_register_pid (PCOQ_TAIL_REGNUM, v + 4, ptid);
d1663 1
a1663 1
	    cache->saved_regs[RP_REGNUM].addr = -20;
d1668 1
a1668 1
	    cache->saved_regs[RP_REGNUM].addr = -16;
d1739 1
a1739 1
		cache->saved_regs[reg + FP4_REGNUM + 4].addr = 0;
d1814 2
a1815 2
      if (trad_frame_addr_p (cache->saved_regs, RP_REGNUM))
        cache->saved_regs[PCOQ_HEAD_REGNUM] = cache->saved_regs[31];
d1819 1
a1819 1
	  trad_frame_set_value (cache->saved_regs, PCOQ_HEAD_REGNUM, r31);
d1824 2
a1825 2
      if (trad_frame_addr_p (cache->saved_regs, RP_REGNUM))
        cache->saved_regs[PCOQ_HEAD_REGNUM] = cache->saved_regs[RP_REGNUM];
d1828 2
a1829 2
	  ULONGEST rp = frame_unwind_register_unsigned (next_frame, RP_REGNUM);
	  trad_frame_set_value (cache->saved_regs, PCOQ_HEAD_REGNUM, rp);
d1866 1
a1866 1
  if (regnum == PCOQ_TAIL_REGNUM)
d1876 1
a1876 1
	  int regsize = register_size (gdbarch, PCOQ_HEAD_REGNUM);
d1884 1
a1884 1
				    PCOQ_HEAD_REGNUM, &optimized, &lval, &addr,
d1953 1
a1953 1
  info->saved_regs[PCOQ_HEAD_REGNUM].realreg = RP_REGNUM;
d1978 1
a1978 1
  int pcoqt = (regnum == PCOQ_TAIL_REGNUM);
d1980 1
a1980 1
  int regsize = register_size (gdbarch, PCOQ_HEAD_REGNUM);
d1983 1
a1983 1
    regnum = PCOQ_HEAD_REGNUM;
d2021 1
a2021 1
  return frame_unwind_register_signed (next_frame, PCOQ_HEAD_REGNUM) & ~3;
d2114 2
a2115 2
  write_register (PCOQ_HEAD_REGNUM, read_register (PCOQ_TAIL_REGNUM));
  write_register (PCSQ_HEAD_REGNUM, read_register (PCSQ_TAIL_REGNUM));
d2117 1
a2117 1
  write_register (PCOQ_TAIL_REGNUM, read_register (PCOQ_TAIL_REGNUM) + 4);
d2155 2
a2156 2
  const int ipsw = (int) read_register (IPSW_REGNUM);
  const int flags = (int) read_register (FLAGS_REGNUM);
d2167 1
a2167 1
   if (reg_nr < FP4_REGNUM)
d2179 1
a2179 1
   if (reg_nr < FP4_REGNUM)
d2192 3
a2194 3
          || regnum == PCSQ_HEAD_REGNUM
          || (regnum >= PCSQ_TAIL_REGNUM && regnum < IPSW_REGNUM)
          || (regnum > IPSW_REGNUM && regnum < FP4_REGNUM));
d2217 1
a2217 1
  get_frame_register (frame, R0_REGNUM + 26 - argi, &addr);
d2228 1
a2228 1
    if (regnum == PCOQ_HEAD_REGNUM || regnum == PCOQ_TAIL_REGNUM)
@


1.152
log
@2004-04-28  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa32_return_value): Handle both 4- and 8-byte fp
	return values.
	(hppa32_push_dummy_call): Fix small struct and floating point argument
	passing, and make sure the stack frame is properly aligned.
@
text
@d2335 1
d2388 3
a2394 3

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);
@


1.151
log
@2004-04-23  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_stub_unwind_cache, hppa_stub_frame_unwind_cache)
	(hppa_stub_frame_this_id, hppa_stub_frame_prev_register)
	(hppa_stub_frame_unwind, hppa_stub_unwind_sniffer): New stub unwinder
	for handling stackless frames.
	(hppa_gdbarch_init): Link in hppa_stub_unwind_sniffer.
@
text
@a123 10
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    {
      if (readbuf != NULL)
	regcache_cooked_read_part (regcache, FP4_REGNUM, 0,
				   TYPE_LENGTH (type), readbuf);
      if (writebuf != NULL)
	regcache_cooked_write_part (regcache, FP4_REGNUM, 0,
				    TYPE_LENGTH (type), writebuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
d129 1
a129 1
      int reg = 28;
a757 3
  /* NOTE: cagney/2004-02-27: This is a guess - its implemented by
     reverse engineering testsuite failures.  */

d774 4
a777 2
      CORE_ADDR param_ptr = 0;
      int reg = 27;	      /* NOTE: Registers go down.  */
d779 2
d811 6
a818 1
	      /* Small struct value, store right aligned?  */
d820 2
d824 7
d832 1
d834 10
a843 1
	  reg -= param_len / 4;
d847 5
a851 1
	      if (reg >= 23)
d853 7
a859 1
		  regcache_cooked_write (regcache, reg, param_val);
d861 8
a868 1
		    regcache_cooked_write (regcache, reg + 1, param_val + 4);
d876 1
a876 1
	  struct_end = sp + struct_ptr;
d882 1
a882 1
	  param_end = struct_end + max (align_up (param_ptr, 8), 16);
d895 1
a895 1
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, param_end + 32);
d897 1
a897 2
  /* The stack will have 32 bytes of additional space for a frame marker.  */
  return param_end + 32;
@


1.150
log
@2004-04-23  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_frame_cache): Handle the case when frame unwind
	starts at a pc before the frame is created.
@
text
@d1901 78
d2348 1
a2348 1

d2350 1
d2355 3
a2359 2

  set_gdbarch_pseudo_register_read (gdbarch, hppa_pseudo_register_read);
@


1.149
log
@2004-04-22  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.h (find_unwind_entry, hppa_get_field, hppa_extract_5_load)
	(hppa_extract_5R_store, hppa_extract_5r_store, hppa_extract_17)
	(hppa_extract_21, hppa_extract_14, hppa_low_sign_extend)
	(hppa_sign_extend): Add prototype.
	* hppa-tdep.c (get_field, extract_5_load, extract_5R_store)
	(extract_5r_store, extract_17, extract_21, extract_14, low_sign_extend)
	(sign_extend): Rename with hppa_ prefix and make non-static.  Other
	hppa targets will also use these functions.
	(find_unwind_entry): Remove prototype (moved to hppa-tdep.h).
	(hppa_in_solib_call_trampoline, hppa_in_solib_return_trampoline)
	(hppa_skip_trampoline_code): Move to hppa-hpux-tdep.c
	(hppa_gdbarch_init): Remove gdbarch setting of
	skip_trampoline_code, in_solib_call_trampoline and
	in_solib_return_trampoline.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa64_hpux_in_solib_call_trampoline): New functions, split from
	hppa_in_solib_call_trampoline.
	(hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code):
	Moved from hppa-tdep.c.
 	(hppa_hpux_init_abi): Set gdbarch for skip_trampoline_code,
	in_solib_call_trampoline and in_solib_return_trampoline.
@
text
@d1535 1
d1594 1
a1594 2
    CORE_ADDR pc;
    CORE_ADDR end_pc;
d1598 12
a1609 3
    end_pc = skip_prologue_using_sal (frame_func_unwind (next_frame));
    if (end_pc == 0)
      end_pc = frame_pc_unwind (next_frame);
d1611 1
d1616 1
a1616 1
	  && pc <= end_pc);
d1623 1
a1623 1
	
d1733 32
a1764 7
    /* FIXME: cagney/2004-02-22: This assumes that the frame has been
       created.  If it hasn't everything will be out-of-wack.  */
    if (u->Save_SP && trad_frame_addr_p (cache->saved_regs, HPPA_SP_REGNUM))
      /* Both we're expecting the SP to be saved and the SP has been
	 saved.  The entry SP value is saved at this frame's SP
	 address.  */
      cache->base = read_memory_integer (this_sp, TARGET_PTR_BIT / 8);
d1766 10
a1775 3
      /* The prologue has been slowly allocating stack space.  Adjust
	 the SP back.  */
      cache->base = this_sp - frame_size;
d1782 9
a1790 1
    cache->saved_regs[PCOQ_HEAD_REGNUM] = cache->saved_regs[31];
d1792 9
a1800 1
    cache->saved_regs[PCOQ_HEAD_REGNUM] = cache->saved_regs[RP_REGNUM];
@


1.148
log
@2004-04-22  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_debug): New variable.
	(find_unwind_entry, hppa_frame_cache): Add debug output.
	(_initialize_hppa_tdep): Add command to set debug flag.
@
text
@a90 16
static int get_field (unsigned word, int from, int to);

static int extract_5_load (unsigned int);

static unsigned extract_5R_store (unsigned int);

static unsigned extract_5r_store (unsigned int);

struct unwind_table_entry *find_unwind_entry (CORE_ADDR);

static int extract_17 (unsigned int);

static int extract_21 (unsigned);

static int extract_14 (unsigned);

a92 4
static int low_sign_extend (unsigned int, unsigned int);

static int sign_extend (unsigned int, unsigned int);

d229 2
a230 2
static int
sign_extend (unsigned val, unsigned bits)
d237 2
a238 2
static int
low_sign_extend (unsigned val, unsigned bits)
d246 2
a247 2
static int
get_field (unsigned word, int from, int to)
d254 2
a255 2
static int
extract_5_load (unsigned word)
d257 1
a257 1
  return low_sign_extend (word >> 16 & MASK_5, 5);
d262 2
a263 2
static unsigned
extract_5r_store (unsigned word)
d270 2
a271 2
static unsigned
extract_5R_store (unsigned word)
d278 2
a279 2
static int
extract_14 (unsigned word)
d281 1
a281 1
  return low_sign_extend (word & MASK_14, 14);
d286 2
a287 2
static int
extract_21 (unsigned word)
d293 1
a293 1
  val = get_field (word, 20, 20);
d295 1
a295 1
  val |= get_field (word, 9, 19);
d297 1
a297 1
  val |= get_field (word, 5, 6);
d299 1
a299 1
  val |= get_field (word, 0, 4);
d301 2
a302 2
  val |= get_field (word, 7, 8);
  return sign_extend (val, 21) << 11;
d308 2
a309 2
static int
extract_17 (unsigned word)
d311 3
a313 3
  return sign_extend (get_field (word, 19, 28) |
		      get_field (word, 29, 29) << 10 |
		      get_field (word, 11, 15) << 11 |
a1081 509
/* Return one if PC is in the call path of a trampoline, else return zero.

   Note we return one for *any* call trampoline (long-call, arg-reloc), not
   just shared library trampolines (import, export).  */

static int
hppa_in_solib_call_trampoline (CORE_ADDR pc, char *name)
{
  struct minimal_symbol *minsym;
  struct unwind_table_entry *u;
  static CORE_ADDR dyncall = 0;
  static CORE_ADDR sr4export = 0;

#ifdef GDB_TARGET_IS_HPPA_20W
  /* PA64 has a completely different stub/trampoline scheme.  Is it
     better?  Maybe.  It's certainly harder to determine with any
     certainty that we are in a stub because we can not refer to the
     unwinders to help. 

     The heuristic is simple.  Try to lookup the current PC value in th
     minimal symbol table.  If that fails, then assume we are not in a
     stub and return.

     Then see if the PC value falls within the section bounds for the
     section containing the minimal symbol we found in the first
     step.  If it does, then assume we are not in a stub and return.

     Finally peek at the instructions to see if they look like a stub.  */
  {
    struct minimal_symbol *minsym;
    asection *sec;
    CORE_ADDR addr;
    int insn, i;

    minsym = lookup_minimal_symbol_by_pc (pc);
    if (! minsym)
      return 0;

    sec = SYMBOL_BFD_SECTION (minsym);

    if (bfd_get_section_vma (sec->owner, sec) <= pc
	&& pc < (bfd_get_section_vma (sec->owner, sec)
		 + bfd_section_size (sec->owner, sec)))
      return 0;

    /* We might be in a stub.  Peek at the instructions.  Stubs are 3
       instructions long. */
    insn = read_memory_integer (pc, 4);

    /* Find out where we think we are within the stub.  */
    if ((insn & 0xffffc00e) == 0x53610000)
      addr = pc;
    else if ((insn & 0xffffffff) == 0xe820d000)
      addr = pc - 4;
    else if ((insn & 0xffffc00e) == 0x537b0000)
      addr = pc - 8;
    else
      return 0;

    /* Now verify each insn in the range looks like a stub instruction.  */
    insn = read_memory_integer (addr, 4);
    if ((insn & 0xffffc00e) != 0x53610000)
      return 0;
	
    /* Now verify each insn in the range looks like a stub instruction.  */
    insn = read_memory_integer (addr + 4, 4);
    if ((insn & 0xffffffff) != 0xe820d000)
      return 0;
    
    /* Now verify each insn in the range looks like a stub instruction.  */
    insn = read_memory_integer (addr + 8, 4);
    if ((insn & 0xffffc00e) != 0x537b0000)
      return 0;

    /* Looks like a stub.  */
    return 1;
  }
#endif

  /* FIXME XXX - dyncall and sr4export must be initialized whenever we get a
     new exec file */

  /* First see if PC is in one of the two C-library trampolines.  */
  if (!dyncall)
    {
      minsym = lookup_minimal_symbol ("$$dyncall", NULL, NULL);
      if (minsym)
	dyncall = SYMBOL_VALUE_ADDRESS (minsym);
      else
	dyncall = -1;
    }

  if (!sr4export)
    {
      minsym = lookup_minimal_symbol ("_sr4export", NULL, NULL);
      if (minsym)
	sr4export = SYMBOL_VALUE_ADDRESS (minsym);
      else
	sr4export = -1;
    }

  if (pc == dyncall || pc == sr4export)
    return 1;

  minsym = lookup_minimal_symbol_by_pc (pc);
  if (minsym && strcmp (DEPRECATED_SYMBOL_NAME (minsym), ".stub") == 0)
    return 1;

  /* Get the unwind descriptor corresponding to PC, return zero
     if no unwind was found.  */
  u = find_unwind_entry (pc);
  if (!u)
    return 0;

  /* If this isn't a linker stub, then return now.  */
  if (u->stub_unwind.stub_type == 0)
    return 0;

  /* By definition a long-branch stub is a call stub.  */
  if (u->stub_unwind.stub_type == LONG_BRANCH)
    return 1;

  /* The call and return path execute the same instructions within
     an IMPORT stub!  So an IMPORT stub is both a call and return
     trampoline.  */
  if (u->stub_unwind.stub_type == IMPORT)
    return 1;

  /* Parameter relocation stubs always have a call path and may have a
     return path.  */
  if (u->stub_unwind.stub_type == PARAMETER_RELOCATION
      || u->stub_unwind.stub_type == EXPORT)
    {
      CORE_ADDR addr;

      /* Search forward from the current PC until we hit a branch
         or the end of the stub.  */
      for (addr = pc; addr <= u->region_end; addr += 4)
	{
	  unsigned long insn;

	  insn = read_memory_integer (addr, 4);

	  /* Does it look like a bl?  If so then it's the call path, if
	     we find a bv or be first, then we're on the return path.  */
	  if ((insn & 0xfc00e000) == 0xe8000000)
	    return 1;
	  else if ((insn & 0xfc00e001) == 0xe800c000
		   || (insn & 0xfc000000) == 0xe0000000)
	    return 0;
	}

      /* Should never happen.  */
      warning ("Unable to find branch in parameter relocation stub.\n");
      return 0;
    }

  /* Unknown stub type.  For now, just return zero.  */
  return 0;
}

/* Return one if PC is in the return path of a trampoline, else return zero.

   Note we return one for *any* call trampoline (long-call, arg-reloc), not
   just shared library trampolines (import, export).  */

static int
hppa_in_solib_return_trampoline (CORE_ADDR pc, char *name)
{
  struct unwind_table_entry *u;

  /* Get the unwind descriptor corresponding to PC, return zero
     if no unwind was found.  */
  u = find_unwind_entry (pc);
  if (!u)
    return 0;

  /* If this isn't a linker stub or it's just a long branch stub, then
     return zero.  */
  if (u->stub_unwind.stub_type == 0 || u->stub_unwind.stub_type == LONG_BRANCH)
    return 0;

  /* The call and return path execute the same instructions within
     an IMPORT stub!  So an IMPORT stub is both a call and return
     trampoline.  */
  if (u->stub_unwind.stub_type == IMPORT)
    return 1;

  /* Parameter relocation stubs always have a call path and may have a
     return path.  */
  if (u->stub_unwind.stub_type == PARAMETER_RELOCATION
      || u->stub_unwind.stub_type == EXPORT)
    {
      CORE_ADDR addr;

      /* Search forward from the current PC until we hit a branch
         or the end of the stub.  */
      for (addr = pc; addr <= u->region_end; addr += 4)
	{
	  unsigned long insn;

	  insn = read_memory_integer (addr, 4);

	  /* Does it look like a bl?  If so then it's the call path, if
	     we find a bv or be first, then we're on the return path.  */
	  if ((insn & 0xfc00e000) == 0xe8000000)
	    return 0;
	  else if ((insn & 0xfc00e001) == 0xe800c000
		   || (insn & 0xfc000000) == 0xe0000000)
	    return 1;
	}

      /* Should never happen.  */
      warning ("Unable to find branch in parameter relocation stub.\n");
      return 0;
    }

  /* Unknown stub type.  For now, just return zero.  */
  return 0;

}

/* Figure out if PC is in a trampoline, and if so find out where
   the trampoline will jump to.  If not in a trampoline, return zero.

   Simple code examination probably is not a good idea since the code
   sequences in trampolines can also appear in user code.

   We use unwinds and information from the minimal symbol table to
   determine when we're in a trampoline.  This won't work for ELF
   (yet) since it doesn't create stub unwind entries.  Whether or
   not ELF will create stub unwinds or normal unwinds for linker
   stubs is still being debated.

   This should handle simple calls through dyncall or sr4export,
   long calls, argument relocation stubs, and dyncall/sr4export
   calling an argument relocation stub.  It even handles some stubs
   used in dynamic executables.  */

static CORE_ADDR
hppa_skip_trampoline_code (CORE_ADDR pc)
{
  long orig_pc = pc;
  long prev_inst, curr_inst, loc;
  static CORE_ADDR dyncall = 0;
  static CORE_ADDR dyncall_external = 0;
  static CORE_ADDR sr4export = 0;
  struct minimal_symbol *msym;
  struct unwind_table_entry *u;

  /* FIXME XXX - dyncall and sr4export must be initialized whenever we get a
     new exec file */

  if (!dyncall)
    {
      msym = lookup_minimal_symbol ("$$dyncall", NULL, NULL);
      if (msym)
	dyncall = SYMBOL_VALUE_ADDRESS (msym);
      else
	dyncall = -1;
    }

  if (!dyncall_external)
    {
      msym = lookup_minimal_symbol ("$$dyncall_external", NULL, NULL);
      if (msym)
	dyncall_external = SYMBOL_VALUE_ADDRESS (msym);
      else
	dyncall_external = -1;
    }

  if (!sr4export)
    {
      msym = lookup_minimal_symbol ("_sr4export", NULL, NULL);
      if (msym)
	sr4export = SYMBOL_VALUE_ADDRESS (msym);
      else
	sr4export = -1;
    }

  /* Addresses passed to dyncall may *NOT* be the actual address
     of the function.  So we may have to do something special.  */
  if (pc == dyncall)
    {
      pc = (CORE_ADDR) read_register (22);

      /* If bit 30 (counting from the left) is on, then pc is the address of
         the PLT entry for this function, not the address of the function
         itself.  Bit 31 has meaning too, but only for MPE.  */
      if (pc & 0x2)
	pc = (CORE_ADDR) read_memory_integer (pc & ~0x3, TARGET_PTR_BIT / 8);
    }
  if (pc == dyncall_external)
    {
      pc = (CORE_ADDR) read_register (22);
      pc = (CORE_ADDR) read_memory_integer (pc & ~0x3, TARGET_PTR_BIT / 8);
    }
  else if (pc == sr4export)
    pc = (CORE_ADDR) (read_register (22));

  /* Get the unwind descriptor corresponding to PC, return zero
     if no unwind was found.  */
  u = find_unwind_entry (pc);
  if (!u)
    return 0;

  /* If this isn't a linker stub, then return now.  */
  /* elz: attention here! (FIXME) because of a compiler/linker 
     error, some stubs which should have a non zero stub_unwind.stub_type 
     have unfortunately a value of zero. So this function would return here
     as if we were not in a trampoline. To fix this, we go look at the partial
     symbol information, which reports this guy as a stub.
     (FIXME): Unfortunately, we are not that lucky: it turns out that the 
     partial symbol information is also wrong sometimes. This is because 
     when it is entered (somread.c::som_symtab_read()) it can happen that
     if the type of the symbol (from the som) is Entry, and the symbol is
     in a shared library, then it can also be a trampoline.  This would
     be OK, except that I believe the way they decide if we are ina shared library
     does not work. SOOOO..., even if we have a regular function w/o trampolines
     its minimal symbol can be assigned type mst_solib_trampoline.
     Also, if we find that the symbol is a real stub, then we fix the unwind
     descriptor, and define the stub type to be EXPORT.
     Hopefully this is correct most of the times. */
  if (u->stub_unwind.stub_type == 0)
    {

/* elz: NOTE (FIXME!) once the problem with the unwind information is fixed
   we can delete all the code which appears between the lines */
/*--------------------------------------------------------------------------*/
      msym = lookup_minimal_symbol_by_pc (pc);

      if (msym == NULL || MSYMBOL_TYPE (msym) != mst_solib_trampoline)
	return orig_pc == pc ? 0 : pc & ~0x3;

      else if (msym != NULL && MSYMBOL_TYPE (msym) == mst_solib_trampoline)
	{
	  struct objfile *objfile;
	  struct minimal_symbol *msymbol;
	  int function_found = 0;

	  /* go look if there is another minimal symbol with the same name as 
	     this one, but with type mst_text. This would happen if the msym
	     is an actual trampoline, in which case there would be another
	     symbol with the same name corresponding to the real function */

	  ALL_MSYMBOLS (objfile, msymbol)
	  {
	    if (MSYMBOL_TYPE (msymbol) == mst_text
		&& DEPRECATED_STREQ (DEPRECATED_SYMBOL_NAME (msymbol), DEPRECATED_SYMBOL_NAME (msym)))
	      {
		function_found = 1;
		break;
	      }
	  }

	  if (function_found)
	    /* the type of msym is correct (mst_solib_trampoline), but
	       the unwind info is wrong, so set it to the correct value */
	    u->stub_unwind.stub_type = EXPORT;
	  else
	    /* the stub type info in the unwind is correct (this is not a
	       trampoline), but the msym type information is wrong, it
	       should be mst_text. So we need to fix the msym, and also
	       get out of this function */
	    {
	      MSYMBOL_TYPE (msym) = mst_text;
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }
	}

/*--------------------------------------------------------------------------*/
    }

  /* It's a stub.  Search for a branch and figure out where it goes.
     Note we have to handle multi insn branch sequences like ldil;ble.
     Most (all?) other branches can be determined by examining the contents
     of certain registers and the stack.  */

  loc = pc;
  curr_inst = 0;
  prev_inst = 0;
  while (1)
    {
      /* Make sure we haven't walked outside the range of this stub.  */
      if (u != find_unwind_entry (loc))
	{
	  warning ("Unable to find branch in linker stub");
	  return orig_pc == pc ? 0 : pc & ~0x3;
	}

      prev_inst = curr_inst;
      curr_inst = read_memory_integer (loc, 4);

      /* Does it look like a branch external using %r1?  Then it's the
         branch from the stub to the actual function.  */
      if ((curr_inst & 0xffe0e000) == 0xe0202000)
	{
	  /* Yup.  See if the previous instruction loaded
	     a value into %r1.  If so compute and return the jump address.  */
	  if ((prev_inst & 0xffe00000) == 0x20200000)
	    return (extract_21 (prev_inst) + extract_17 (curr_inst)) & ~0x3;
	  else
	    {
	      warning ("Unable to find ldil X,%%r1 before ble Y(%%sr4,%%r1).");
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }
	}

      /* Does it look like a be 0(sr0,%r21)? OR 
         Does it look like a be, n 0(sr0,%r21)? OR 
         Does it look like a bve (r21)? (this is on PA2.0)
         Does it look like a bve, n(r21)? (this is also on PA2.0)
         That's the branch from an
         import stub to an export stub.

         It is impossible to determine the target of the branch via
         simple examination of instructions and/or data (consider
         that the address in the plabel may be the address of the
         bind-on-reference routine in the dynamic loader).

         So we have try an alternative approach.

         Get the name of the symbol at our current location; it should
         be a stub symbol with the same name as the symbol in the
         shared library.

         Then lookup a minimal symbol with the same name; we should
         get the minimal symbol for the target routine in the shared
         library as those take precedence of import/export stubs.  */
      if ((curr_inst == 0xe2a00000) ||
	  (curr_inst == 0xe2a00002) ||
	  (curr_inst == 0xeaa0d000) ||
	  (curr_inst == 0xeaa0d002))
	{
	  struct minimal_symbol *stubsym, *libsym;

	  stubsym = lookup_minimal_symbol_by_pc (loc);
	  if (stubsym == NULL)
	    {
	      warning ("Unable to find symbol for 0x%lx", loc);
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }

	  libsym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (stubsym), NULL, NULL);
	  if (libsym == NULL)
	    {
	      warning ("Unable to find library symbol for %s\n",
		       DEPRECATED_SYMBOL_NAME (stubsym));
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }

	  return SYMBOL_VALUE (libsym);
	}

      /* Does it look like bl X,%rp or bl X,%r0?  Another way to do a
         branch from the stub to the actual function.  */
      /*elz */
      else if ((curr_inst & 0xffe0e000) == 0xe8400000
	       || (curr_inst & 0xffe0e000) == 0xe8000000
	       || (curr_inst & 0xffe0e000) == 0xe800A000)
	return (loc + extract_17 (curr_inst) + 8) & ~0x3;

      /* Does it look like bv (rp)?   Note this depends on the
         current stack pointer being the same as the stack
         pointer in the stub itself!  This is a branch on from the
         stub back to the original caller.  */
      /*else if ((curr_inst & 0xffe0e000) == 0xe840c000) */
      else if ((curr_inst & 0xffe0f000) == 0xe840c000)
	{
	  /* Yup.  See if the previous instruction loaded
	     rp from sp - 8.  */
	  if (prev_inst == 0x4bc23ff1)
	    return (read_memory_integer
		    (read_register (HPPA_SP_REGNUM) - 8, 4)) & ~0x3;
	  else
	    {
	      warning ("Unable to find restore of %%rp before bv (%%rp).");
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }
	}

      /* elz: added this case to capture the new instruction
         at the end of the return part of an export stub used by
         the PA2.0: BVE, n (rp) */
      else if ((curr_inst & 0xffe0f000) == 0xe840d000)
	{
	  return (read_memory_integer
		  (read_register (HPPA_SP_REGNUM) - 24, TARGET_PTR_BIT / 8)) & ~0x3;
	}

      /* What about be,n 0(sr0,%rp)?  It's just another way we return to
         the original caller from the stub.  Used in dynamic executables.  */
      else if (curr_inst == 0xe0400002)
	{
	  /* The value we jump to is sitting in sp - 24.  But that's
	     loaded several instructions before the be instruction.
	     I guess we could check for the previous instruction being
	     mtsp %r1,%sr0 if we want to do sanity checking.  */
	  return (read_memory_integer
		  (read_register (HPPA_SP_REGNUM) - 24, TARGET_PTR_BIT / 8)) & ~0x3;
	}

      /* Haven't found the branch yet, but we're still in the stub.
         Keep looking.  */
      loc += 4;
    }
}


d1095 1
a1095 1
    return extract_14 (inst);
d1099 1
a1099 1
    return extract_14 (inst);
d1109 1
a1109 1
      save_high21 = extract_21 (inst);
d1114 1
a1114 1
    return save_high21 + extract_14 (inst);
d1118 1
a1118 1
    return extract_5_load (inst);
d1167 1
a1167 1
    return extract_5R_store (inst);
d1173 1
a1173 1
    return extract_5R_store (inst);
d1177 1
a1177 1
    return extract_5R_store (inst);
d1185 1
a1185 1
    return extract_5R_store (inst);
d1203 1
a1203 1
    return extract_5r_store (inst);
d1205 1
a1205 1
    return extract_5R_store (inst);
d1208 1
a1208 1
    return extract_5r_store (inst);
d1210 1
a1210 1
    return extract_5R_store (inst);
d1646 1
a1646 1
	    if ((inst >> 26) == 0x1b && extract_14 (inst) >= 0)
d1660 1
a1660 1
		  offset = low_sign_extend (inst & 0x1f, 5);
d1662 1
a1662 1
		  offset = extract_14 (inst);
d1684 1
a1684 1
	  fp_loc = extract_14 (inst);
a2163 4
  set_gdbarch_skip_trampoline_code (gdbarch, hppa_skip_trampoline_code);
  set_gdbarch_in_solib_call_trampoline (gdbarch, hppa_in_solib_call_trampoline);
  set_gdbarch_in_solib_return_trampoline (gdbarch,
                                          hppa_in_solib_return_trampoline);
@


1.147
log
@2004-04-17  Randolph Chung  <tausq@@debian.org>

	* Makefile.in (hppa-hpux-tdep.o): Add $(hppa_tdep_h).
	* hppa-hpux-tdep.c (hppa-tdep.h): Include.
 	(hppa_hpux_som_init_abi): Set is_elf to 0.
 	(hppa_hpux_elf_init_abi): Set is_elf to 1.
	* hppa-tdep.c (low_text_segment_address): Remove global.
	(record_text_segment_lowaddr): Pass in low address as parameter. Use
	section offset to calculate segment address.
	(internalize_unwinds): Define low_text_segment_address as local and
	pass to record_text_segment_lowaddr for ELF targets.
	(hppa_gdbarch_init): Zero fill tdep structure.
	(hppa_dump_tdep): Print tdep structure.
	* hppa-tdep.h (gdbarch_tdep): Add is_elf member to tdep structure.
@
text
@d57 2
d612 4
d618 5
a622 1
    return NULL;
d646 6
a651 1
      return ui->cache;
d665 3
d677 4
d2066 4
d2071 6
a2076 1
    return (*this_cache);
d2084 5
a2088 1
    return (*this_cache);
d2283 3
d2817 5
@


1.146
log
@2004-04-17  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_pseudo_register_read): Define.
	(hppa_gdbarch_init): Set pseudo_register_read.
	* config/pa/tm-hppa.h (DEPRECATED_CLEAN_UP_REGISTER_VALUE): Remove.
	* regcache.c (supply_register): Remove check for
	DEPRECATED_CLEAN_UP_REGISTER_VALUE since we've removed the last user.
@
text
@a353 2
static CORE_ADDR low_text_segment_address;

d355 1
a355 1
record_text_segment_lowaddr (bfd *abfd, asection *section, void *ignored)
d357 1
a357 1
  if (((section->flags & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
d359 7
a365 2
      && section->vma < low_text_segment_address)
    low_text_segment_address = section->vma;
d375 1
d381 1
d383 1
a383 3
      low_text_segment_address = -1;

      /* If addresses are 64 bits wide, then unwinds are supposed to
d389 1
a389 1
      if (TARGET_PTR_BIT == 64 && text_offset == 0)
d391 2
d394 2
a395 1
				 record_text_segment_lowaddr, NULL);
d397 1
a397 5
	  /* ?!? Mask off some low bits.  Should this instead subtract
	     out the lowest section's filepos or something like that?
	     This looks very hokey to me.  */
	  low_text_segment_address &= ~0xfff;
	  text_offset += low_text_segment_address;
d2612 1
a2612 1
  tdep = XMALLOC (struct gdbarch_tdep);
d2727 5
a2731 1
   /* Nothing to print for the moment.  */
@


1.145
log
@2004-04-17  Randolph Chung  <tausq@@debian.org>

	* Makefile.in (hpread.o, pa64solib.o, somsolib.o): Add $(hppa_tdep_h)
	* hppa-tdep.c (hppa_objfile_priv_data): New.
	(SR4EXPORT_LDIL_OFFSET, SR4EXPORT_LDO_OFFSET): Use
	HPPA_INSTRUCTION_SIZE.
	(read_unwind_info): Use objfile_data to reference unwind info.
	(find_unwind_entry): Likewise.
	(hpread_adjust_stack_address): Move to hpread.c.
	(_initialize_hppa_tdep): Register hppa objfile data.
	* hppa-tdep.h (HPPA_INSTRUCTION_SIZE): Define.
	(unwind_table_entry, unwind_stub_types): Move from tm-hppa.h.
	(obj_unwind_info, obj_private_struct): Move from tm-hppa.h, and rename
	with hppa_ prefix.
	* hpread.c (hppa-tdep.h): Include.
	(hpread_adjust_stack_address): Move from hppa-tdep.c.
	(hpread_read_function_type, hpread_read_doc_function_type)
	(hpread_process_one_debug_symbol): Call hpread_adjust_stack_address
	directly. Use objfile_data to access solib data.
	* pa64solib.c (hppa-tdep.h): Include.
	(pa64_solib_add_solib_objfile): Use objfile_data to access solib data.
	* somsolib.c (hppa-tdep.h): Include.
	(som_solib_add_solib_objfile): Use objfile_data to access solib data.
	* config/pa/tm-hppa.h (frame_info, frame_saved_regs, value, type)
	(inferior_status): Remove unused forward declarations.
	(INSTRUCTION_SIZE): Move to hppa-tdep.c.
	(unwind_table_entry, unwind_stub_types, obj_unwind_info)
	(obj_private_struct): Move to hppa-tdep.h.
	(HPREAD_ADJUST_STACK_ADDRESS): Remove.
@
text
@d2543 12
d2713 2
@


1.144
log
@2004-04-17  Randolph Chung  <tausq@@debian.org>

        * hppa-tdep.c (hppa_reg_struct_has_addr, hppa_skip_prologue)
        (hppa_skip_trampoline_code, hppa_in_solib_call_trampoline)
        (hppa_in_solib_return_trampoline, hppa_cannot_store_register)
        (hppa_smash_text_address, hppa_target_read_pc, hppa_target_write_pc):
        Remove forward declaration and make static.
        (hppa_reg_struct_has_addr): Remove.
@
text
@d61 8
d77 2
a78 2
#define SR4EXPORT_LDIL_OFFSET (INSTRUCTION_SIZE * 12)
#define SR4EXPORT_LDO_OFFSET (INSTRUCTION_SIZE * 13)
d467 2
a468 2
  struct obj_unwind_info *ui;
  obj_private_data_t *obj_private;
d471 2
a472 2
  ui = (struct obj_unwind_info *) obstack_alloc (&objfile->objfile_obstack,
					   sizeof (struct obj_unwind_info));
d581 8
a588 5
  if (objfile->obj_private == NULL)
    {
      obj_private = (obj_private_data_t *)
	obstack_alloc (&objfile->objfile_obstack,
		       sizeof (obj_private_data_t));
a591 2

      objfile->obj_private = obj_private;
a592 1
  obj_private = (obj_private_data_t *) objfile->obj_private;
d606 1
d614 1
a614 1
    struct obj_unwind_info *ui;
d616 3
a618 2
    if (objfile->obj_private)
      ui = ((obj_private_data_t *) (objfile->obj_private))->unwind_info;
d623 2
a624 1
	if (objfile->obj_private == NULL)
d626 1
a626 1
	ui = ((obj_private_data_t *) (objfile->obj_private))->unwind_info;
a747 20


/* Return the adjustment necessary to make for addresses on the stack
   as presented by hpread.c.

   This is necessary because of the stack direction on the PA and the
   bizarre way in which someone (?) decided they wanted to handle
   frame pointerless code in GDB.  */
int
hpread_adjust_stack_address (CORE_ADDR func_addr)
{
  struct unwind_table_entry *u;

  u = find_unwind_entry (func_addr);
  if (!u)
    return 0;
  else
    return u->Total_frame_size << 3;
}

d2723 2
@


1.143
log
@2004-04-07  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_inner_than): Remove.
	(is_pa_2): Remove unused static variable.
	(hppa_gdbarch_init): Use core_addr_greaterthan instead of own version.
@
text
@a123 5
int hppa_reg_struct_has_addr (int gcc_p, struct type *type);
CORE_ADDR hppa_skip_prologue (CORE_ADDR pc);
CORE_ADDR hppa_skip_trampoline_code (CORE_ADDR pc);
int hppa_in_solib_call_trampoline (CORE_ADDR pc, char *name);
int hppa_in_solib_return_trampoline (CORE_ADDR pc, char *name);
a125 4
int hppa_cannot_store_register (int regnum);
CORE_ADDR hppa_smash_text_address (CORE_ADDR addr);
CORE_ADDR hppa_target_read_pc (ptid_t ptid);
void hppa_target_write_pc (CORE_ADDR v, ptid_t ptid);
d1018 1
a1018 1
CORE_ADDR
d1035 1
a1035 1
void
d1092 1
a1092 1
int
d1253 1
a1253 1
int
d1326 1
a1326 1
CORE_ADDR
d2008 1
a2008 1
CORE_ADDR
a2452 8
hppa_reg_struct_has_addr (int gcc_p, struct type *type)
{
  /* On the PA, any pass-by-value structure > 8 bytes is actually passed
     via a pointer regardless of its type or the compiler used.  */
  return (TYPE_LENGTH (type) > 8);
}

int
d2519 1
a2519 1
int
d2529 1
a2529 1
CORE_ADDR
@


1.142
log
@2004-04-06  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa_breakpoint_from_pc): Make static.
	(hppa_gdbarch_init): Set gdbarch_breakpoint_from_pc
	* config/pa/tm-hppa.h (BREAKPOINT_FROM_PC, BREAKPOINT32):
	(hppa_breakpoint_from_pc): Delete.
@
text
@a128 1
int hppa_inner_than (CORE_ADDR lhs, CORE_ADDR rhs);
a135 2
static int is_pa_2 = 0;		/* False */

a2469 7
hppa_inner_than (CORE_ADDR lhs, CORE_ADDR rhs)
{
  /* Stack grows upward */
  return (lhs > rhs);
}

int
d2671 1
a2671 1
  set_gdbarch_inner_than (gdbarch, hppa_inner_than);
@


1.141
log
@2004-04-05  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c: Do not include <sys/types.h>, <sys/param.h>,
	<signal.h>, <sys/ptrace.h>, #include "a.out.encap.h",
	<sys/file.h>.
@
text
@d661 1
a661 1
const unsigned char *
d2729 3
a2731 1
      
@


1.140
log
@2004-04-06  Randolph Chung  <tausq@@debian.org>

	Committed by Andrew Cagney (mechanical change).
	* hppa-tdep.c: (args_for_find_stub, hp_som_som_object_present,
	exception_catchpoints_are_fragile, find_stub_with_shl_get,
	cover_find_stub_with_shl_get, initialize_hp_cxx_exception_support,
	child_enable_exception_callback, current_ex_event,
	null_symtab_and_line, child_get_current_exception_event,
	HP_ACC_EH_notify_hook, HP_ACC_EH_set_hook_value,
	HP_ACC_EH_notify_callback, HP_ACC_EH_break, HP_ACC_EH_catch_throw,
	HP_ACC_EH_catch_catch, __eh_notification, hp_cxx_exception_support,
	hp_cxx_exception_support_initialized, eh_notify_hook_addr,
	eh_notify_callback_addr, eh_break_addr, eh_catch_catch_addr,
	eh_catch_throw_addr, break_callback_sal, setup_d_pid_in_inferior):
	Move hpux-specific definitions ...
	* hppa-hpux-tdep.c: ... to here.
@
text
@a46 16
#ifdef USG
#include <sys/types.h>
#endif

#include <sys/param.h>
#include <signal.h>

#include <sys/ptrace.h>

#ifdef COFF_ENCAPSULATE
#include "a.out.encap.h"
#else
#endif

/*#include <sys/user.h>         After a.out.h  */
#include <sys/file.h>
@


1.139
log
@2004-04-05  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa_frame_cache): Pass the frame's func to
	skip_prologue_using_sal.
@
text
@a50 1
#include <dl.h>
a54 1
#include <machine/save_state.h>
a152 10
typedef struct
  {
    struct minimal_symbol *msym;
    CORE_ADDR solib_handle;
    CORE_ADDR return_val;
  }
args_for_find_stub;

static int cover_find_stub_with_shl_get (void *);

a154 6
/* This is declared in symtab.c; set to 1 in hp-symtab-read.c */
extern int hp_som_som_object_present;

/* In breakpoint.c */
extern int exception_catchpoints_are_fragile;

a1042 96
/* elz: Used to lookup a symbol in the shared libraries.
   This function calls shl_findsym, indirectly through a
   call to __d_shl_get. __d_shl_get is in end.c, which is always
   linked in by the hp compilers/linkers. 
   The call to shl_findsym cannot be made directly because it needs
   to be active in target address space. 
   inputs: - minimal symbol pointer for the function we want to look up
   - address in target space of the descriptor for the library
   where we want to look the symbol up.
   This address is retrieved using the 
   som_solib_get_solib_by_pc function (somsolib.c). 
   output: - real address in the library of the function.          
   note: the handle can be null, in which case shl_findsym will look for
   the symbol in all the loaded shared libraries.
   files to look at if you need reference on this stuff:
   dld.c, dld_shl_findsym.c
   end.c
   man entry for shl_findsym */

CORE_ADDR
find_stub_with_shl_get (struct minimal_symbol *function, CORE_ADDR handle)
{
  struct symbol *get_sym, *symbol2;
  struct minimal_symbol *buff_minsym, *msymbol;
  struct type *ftype;
  struct value **args;
  struct value *funcval;
  struct value *val;

  int x, namelen, err_value, tmp = -1;
  CORE_ADDR endo_buff_addr, value_return_addr, errno_return_addr;
  CORE_ADDR stub_addr;


  args = alloca (sizeof (struct value *) * 8);		/* 6 for the arguments and one null one??? */
  funcval = find_function_in_inferior ("__d_shl_get");
  get_sym = lookup_symbol ("__d_shl_get", NULL, VAR_DOMAIN, NULL, NULL);
  buff_minsym = lookup_minimal_symbol ("__buffer", NULL, NULL);
  msymbol = lookup_minimal_symbol ("__shldp", NULL, NULL);
  symbol2 = lookup_symbol ("__shldp", NULL, VAR_DOMAIN, NULL, NULL);
  endo_buff_addr = SYMBOL_VALUE_ADDRESS (buff_minsym);
  namelen = strlen (DEPRECATED_SYMBOL_NAME (function));
  value_return_addr = endo_buff_addr + namelen;
  ftype = check_typedef (SYMBOL_TYPE (get_sym));

  /* do alignment */
  if ((x = value_return_addr % 64) != 0)
    value_return_addr = value_return_addr + 64 - x;

  errno_return_addr = value_return_addr + 64;


  /* set up stuff needed by __d_shl_get in buffer in end.o */

  target_write_memory (endo_buff_addr, DEPRECATED_SYMBOL_NAME (function), namelen);

  target_write_memory (value_return_addr, (char *) &tmp, 4);

  target_write_memory (errno_return_addr, (char *) &tmp, 4);

  target_write_memory (SYMBOL_VALUE_ADDRESS (msymbol),
		       (char *) &handle, 4);

  /* now prepare the arguments for the call */

  args[0] = value_from_longest (TYPE_FIELD_TYPE (ftype, 0), 12);
  args[1] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 1), SYMBOL_VALUE_ADDRESS (msymbol));
  args[2] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 2), endo_buff_addr);
  args[3] = value_from_longest (TYPE_FIELD_TYPE (ftype, 3), TYPE_PROCEDURE);
  args[4] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 4), value_return_addr);
  args[5] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 5), errno_return_addr);

  /* now call the function */

  val = call_function_by_hand (funcval, 6, args);

  /* now get the results */

  target_read_memory (errno_return_addr, (char *) &err_value, sizeof (err_value));

  target_read_memory (value_return_addr, (char *) &stub_addr, sizeof (stub_addr));
  if (stub_addr <= 0)
    error ("call to __d_shl_get failed, error code is %d", err_value);

  return (stub_addr);
}

/* Cover routine for find_stub_with_shl_get to pass to catch_errors */
static int
cover_find_stub_with_shl_get (void *args_untyped)
{
  args_for_find_stub *args = args_untyped;
  args->return_val = find_stub_with_shl_get (args->msym, args->solib_handle);
  return 0;
}

a2380 454
}

/* Exception handling support for the HP-UX ANSI C++ compiler.
   The compiler (aCC) provides a callback for exception events;
   GDB can set a breakpoint on this callback and find out what
   exception event has occurred. */

/* The name of the hook to be set to point to the callback function */
static char HP_ACC_EH_notify_hook[] = "__eh_notify_hook";
/* The name of the function to be used to set the hook value */
static char HP_ACC_EH_set_hook_value[] = "__eh_set_hook_value";
/* The name of the callback function in end.o */
static char HP_ACC_EH_notify_callback[] = "__d_eh_notify_callback";
/* Name of function in end.o on which a break is set (called by above) */
static char HP_ACC_EH_break[] = "__d_eh_break";
/* Name of flag (in end.o) that enables catching throws */
static char HP_ACC_EH_catch_throw[] = "__d_eh_catch_throw";
/* Name of flag (in end.o) that enables catching catching */
static char HP_ACC_EH_catch_catch[] = "__d_eh_catch_catch";
/* The enum used by aCC */
typedef enum
  {
    __EH_NOTIFY_THROW,
    __EH_NOTIFY_CATCH
  }
__eh_notification;

/* Is exception-handling support available with this executable? */
static int hp_cxx_exception_support = 0;
/* Has the initialize function been run? */
int hp_cxx_exception_support_initialized = 0;
/* Similar to above, but imported from breakpoint.c -- non-target-specific */
extern int exception_support_initialized;
/* Address of __eh_notify_hook */
static CORE_ADDR eh_notify_hook_addr = 0;
/* Address of __d_eh_notify_callback */
static CORE_ADDR eh_notify_callback_addr = 0;
/* Address of __d_eh_break */
static CORE_ADDR eh_break_addr = 0;
/* Address of __d_eh_catch_catch */
static CORE_ADDR eh_catch_catch_addr = 0;
/* Address of __d_eh_catch_throw */
static CORE_ADDR eh_catch_throw_addr = 0;
/* Sal for __d_eh_break */
static struct symtab_and_line *break_callback_sal = 0;

/* Code in end.c expects __d_pid to be set in the inferior,
   otherwise __d_eh_notify_callback doesn't bother to call
   __d_eh_break!  So we poke the pid into this symbol
   ourselves.
   0 => success
   1 => failure  */
int
setup_d_pid_in_inferior (void)
{
  CORE_ADDR anaddr;
  struct minimal_symbol *msymbol;
  char buf[4];			/* FIXME 32x64? */

  /* Slam the pid of the process into __d_pid; failing is only a warning!  */
  msymbol = lookup_minimal_symbol ("__d_pid", NULL, symfile_objfile);
  if (msymbol == NULL)
    {
      warning ("Unable to find __d_pid symbol in object file.");
      warning ("Suggest linking executable with -g (links in /opt/langtools/lib/end.o).");
      return 1;
    }

  anaddr = SYMBOL_VALUE_ADDRESS (msymbol);
  store_unsigned_integer (buf, 4, PIDGET (inferior_ptid)); /* FIXME 32x64? */
  if (target_write_memory (anaddr, buf, 4))	/* FIXME 32x64? */
    {
      warning ("Unable to write __d_pid");
      warning ("Suggest linking executable with -g (links in /opt/langtools/lib/end.o).");
      return 1;
    }
  return 0;
}

/* Initialize exception catchpoint support by looking for the
   necessary hooks/callbacks in end.o, etc., and set the hook value to
   point to the required debug function

   Return 0 => failure
   1 => success          */

static int
initialize_hp_cxx_exception_support (void)
{
  struct symtabs_and_lines sals;
  struct cleanup *old_chain;
  struct cleanup *canonical_strings_chain = NULL;
  int i;
  char *addr_start;
  char *addr_end = NULL;
  char **canonical = (char **) NULL;
  int thread = -1;
  struct symbol *sym = NULL;
  struct minimal_symbol *msym = NULL;
  struct objfile *objfile;
  asection *shlib_info;

  /* Detect and disallow recursion.  On HP-UX with aCC, infinite
     recursion is a possibility because finding the hook for exception
     callbacks involves making a call in the inferior, which means
     re-inserting breakpoints which can re-invoke this code */

  static int recurse = 0;
  if (recurse > 0)
    {
      hp_cxx_exception_support_initialized = 0;
      exception_support_initialized = 0;
      return 0;
    }

  hp_cxx_exception_support = 0;

  /* First check if we have seen any HP compiled objects; if not,
     it is very unlikely that HP's idiosyncratic callback mechanism
     for exception handling debug support will be available!
     This will percolate back up to breakpoint.c, where our callers
     will decide to try the g++ exception-handling support instead. */
  if (!hp_som_som_object_present)
    return 0;

  /* We have a SOM executable with SOM debug info; find the hooks */

  /* First look for the notify hook provided by aCC runtime libs */
  /* If we find this symbol, we conclude that the executable must
     have HP aCC exception support built in.  If this symbol is not
     found, even though we're a HP SOM-SOM file, we may have been
     built with some other compiler (not aCC).  This results percolates
     back up to our callers in breakpoint.c which can decide to
     try the g++ style of exception support instead.
     If this symbol is found but the other symbols we require are
     not found, there is something weird going on, and g++ support
     should *not* be tried as an alternative.

     ASSUMPTION: Only HP aCC code will have __eh_notify_hook defined.  
     ASSUMPTION: HP aCC and g++ modules cannot be linked together. */

  /* libCsup has this hook; it'll usually be non-debuggable */
  msym = lookup_minimal_symbol (HP_ACC_EH_notify_hook, NULL, NULL);
  if (msym)
    {
      eh_notify_hook_addr = SYMBOL_VALUE_ADDRESS (msym);
      hp_cxx_exception_support = 1;
    }
  else
    {
      warning ("Unable to find exception callback hook (%s).", HP_ACC_EH_notify_hook);
      warning ("Executable may not have been compiled debuggable with HP aCC.");
      warning ("GDB will be unable to intercept exception events.");
      eh_notify_hook_addr = 0;
      hp_cxx_exception_support = 0;
      return 0;
    }

  /* Next look for the notify callback routine in end.o */
  /* This is always available in the SOM symbol dictionary if end.o is linked in */
  msym = lookup_minimal_symbol (HP_ACC_EH_notify_callback, NULL, NULL);
  if (msym)
    {
      eh_notify_callback_addr = SYMBOL_VALUE_ADDRESS (msym);
      hp_cxx_exception_support = 1;
    }
  else
    {
      warning ("Unable to find exception callback routine (%s).", HP_ACC_EH_notify_callback);
      warning ("Suggest linking executable with -g (links in /opt/langtools/lib/end.o).");
      warning ("GDB will be unable to intercept exception events.");
      eh_notify_callback_addr = 0;
      return 0;
    }

#ifndef GDB_TARGET_IS_HPPA_20W
  /* Check whether the executable is dynamically linked or archive bound */
  /* With an archive-bound executable we can use the raw addresses we find
     for the callback function, etc. without modification. For an executable
     with shared libraries, we have to do more work to find the plabel, which
     can be the target of a call through $$dyncall from the aCC runtime support
     library (libCsup) which is linked shared by default by aCC. */
  /* This test below was copied from somsolib.c/somread.c.  It may not be a very
     reliable one to test that an executable is linked shared. pai/1997-07-18 */
  shlib_info = bfd_get_section_by_name (symfile_objfile->obfd, "$SHLIB_INFO$");
  if (shlib_info && (bfd_section_size (symfile_objfile->obfd, shlib_info) != 0))
    {
      /* The minsym we have has the local code address, but that's not the
         plabel that can be used by an inter-load-module call. */
      /* Find solib handle for main image (which has end.o), and use that
         and the min sym as arguments to __d_shl_get() (which does the equivalent
         of shl_findsym()) to find the plabel. */

      args_for_find_stub args;
      static char message[] = "Error while finding exception callback hook:\n";

      args.solib_handle = som_solib_get_solib_by_pc (eh_notify_callback_addr);
      args.msym = msym;
      args.return_val = 0;

      recurse++;
      catch_errors (cover_find_stub_with_shl_get, &args, message,
		    RETURN_MASK_ALL);
      eh_notify_callback_addr = args.return_val;
      recurse--;

      exception_catchpoints_are_fragile = 1;

      if (!eh_notify_callback_addr)
	{
	  /* We can get here either if there is no plabel in the export list
	     for the main image, or if something strange happened (?) */
	  warning ("Couldn't find a plabel (indirect function label) for the exception callback.");
	  warning ("GDB will not be able to intercept exception events.");
	  return 0;
	}
    }
  else
    exception_catchpoints_are_fragile = 0;
#endif

  /* Now, look for the breakpointable routine in end.o */
  /* This should also be available in the SOM symbol dict. if end.o linked in */
  msym = lookup_minimal_symbol (HP_ACC_EH_break, NULL, NULL);
  if (msym)
    {
      eh_break_addr = SYMBOL_VALUE_ADDRESS (msym);
      hp_cxx_exception_support = 1;
    }
  else
    {
      warning ("Unable to find exception callback routine to set breakpoint (%s).", HP_ACC_EH_break);
      warning ("Suggest linking executable with -g (link in /opt/langtools/lib/end.o).");
      warning ("GDB will be unable to intercept exception events.");
      eh_break_addr = 0;
      return 0;
    }

  /* Next look for the catch enable flag provided in end.o */
  sym = lookup_symbol (HP_ACC_EH_catch_catch, (struct block *) NULL,
		       VAR_DOMAIN, 0, (struct symtab **) NULL);
  if (sym)			/* sometimes present in debug info */
    {
      eh_catch_catch_addr = SYMBOL_VALUE_ADDRESS (sym);
      hp_cxx_exception_support = 1;
    }
  else
    /* otherwise look in SOM symbol dict. */
    {
      msym = lookup_minimal_symbol (HP_ACC_EH_catch_catch, NULL, NULL);
      if (msym)
	{
	  eh_catch_catch_addr = SYMBOL_VALUE_ADDRESS (msym);
	  hp_cxx_exception_support = 1;
	}
      else
	{
	  warning ("Unable to enable interception of exception catches.");
	  warning ("Executable may not have been compiled debuggable with HP aCC.");
	  warning ("Suggest linking executable with -g (link in /opt/langtools/lib/end.o).");
	  return 0;
	}
    }

  /* Next look for the catch enable flag provided end.o */
  sym = lookup_symbol (HP_ACC_EH_catch_catch, (struct block *) NULL,
		       VAR_DOMAIN, 0, (struct symtab **) NULL);
  if (sym)			/* sometimes present in debug info */
    {
      eh_catch_throw_addr = SYMBOL_VALUE_ADDRESS (sym);
      hp_cxx_exception_support = 1;
    }
  else
    /* otherwise look in SOM symbol dict. */
    {
      msym = lookup_minimal_symbol (HP_ACC_EH_catch_throw, NULL, NULL);
      if (msym)
	{
	  eh_catch_throw_addr = SYMBOL_VALUE_ADDRESS (msym);
	  hp_cxx_exception_support = 1;
	}
      else
	{
	  warning ("Unable to enable interception of exception throws.");
	  warning ("Executable may not have been compiled debuggable with HP aCC.");
	  warning ("Suggest linking executable with -g (link in /opt/langtools/lib/end.o).");
	  return 0;
	}
    }

  /* Set the flags */
  hp_cxx_exception_support = 2;	/* everything worked so far */
  hp_cxx_exception_support_initialized = 1;
  exception_support_initialized = 1;

  return 1;
}

/* Target operation for enabling or disabling interception of
   exception events.
   KIND is either EX_EVENT_THROW or EX_EVENT_CATCH
   ENABLE is either 0 (disable) or 1 (enable).
   Return value is NULL if no support found;
   -1 if something went wrong,
   or a pointer to a symtab/line struct if the breakpointable
   address was found. */

struct symtab_and_line *
child_enable_exception_callback (enum exception_event_kind kind, int enable)
{
  char buf[4];

  if (!exception_support_initialized || !hp_cxx_exception_support_initialized)
    if (!initialize_hp_cxx_exception_support ())
      return NULL;

  switch (hp_cxx_exception_support)
    {
    case 0:
      /* Assuming no HP support at all */
      return NULL;
    case 1:
      /* HP support should be present, but something went wrong */
      return (struct symtab_and_line *) -1;	/* yuck! */
      /* there may be other cases in the future */
    }

  /* Set the EH hook to point to the callback routine */
  store_unsigned_integer (buf, 4, enable ? eh_notify_callback_addr : 0);	/* FIXME 32x64 problem */
  /* pai: (temp) FIXME should there be a pack operation first? */
  if (target_write_memory (eh_notify_hook_addr, buf, 4))	/* FIXME 32x64 problem */
    {
      warning ("Could not write to target memory for exception event callback.");
      warning ("Interception of exception events may not work.");
      return (struct symtab_and_line *) -1;
    }
  if (enable)
    {
      /* Ensure that __d_pid is set up correctly -- end.c code checks this. :-( */
      if (PIDGET (inferior_ptid) > 0)
	{
	  if (setup_d_pid_in_inferior ())
	    return (struct symtab_and_line *) -1;
	}
      else
	{
	  warning ("Internal error: Invalid inferior pid?  Cannot intercept exception events.");
	  return (struct symtab_and_line *) -1;
	}
    }

  switch (kind)
    {
    case EX_EVENT_THROW:
      store_unsigned_integer (buf, 4, enable ? 1 : 0);
      if (target_write_memory (eh_catch_throw_addr, buf, 4))	/* FIXME 32x64? */
	{
	  warning ("Couldn't enable exception throw interception.");
	  return (struct symtab_and_line *) -1;
	}
      break;
    case EX_EVENT_CATCH:
      store_unsigned_integer (buf, 4, enable ? 1 : 0);
      if (target_write_memory (eh_catch_catch_addr, buf, 4))	/* FIXME 32x64? */
	{
	  warning ("Couldn't enable exception catch interception.");
	  return (struct symtab_and_line *) -1;
	}
      break;
    default:
      error ("Request to enable unknown or unsupported exception event.");
    }

  /* Copy break address into new sal struct, malloc'ing if needed. */
  if (!break_callback_sal)
    {
      break_callback_sal = (struct symtab_and_line *) xmalloc (sizeof (struct symtab_and_line));
    }
  init_sal (break_callback_sal);
  break_callback_sal->symtab = NULL;
  break_callback_sal->pc = eh_break_addr;
  break_callback_sal->line = 0;
  break_callback_sal->end = eh_break_addr;

  return break_callback_sal;
}

/* Record some information about the current exception event */
static struct exception_event_record current_ex_event;
/* Convenience struct */
static struct symtab_and_line null_symtab_and_line =
{NULL, 0, 0, 0};

/* Report current exception event.  Returns a pointer to a record
   that describes the kind of the event, where it was thrown from,
   and where it will be caught.  More information may be reported
   in the future */
struct exception_event_record *
child_get_current_exception_event (void)
{
  CORE_ADDR event_kind;
  CORE_ADDR throw_addr;
  CORE_ADDR catch_addr;
  struct frame_info *fi, *curr_frame;
  int level = 1;

  curr_frame = get_current_frame ();
  if (!curr_frame)
    return (struct exception_event_record *) NULL;

  /* Go up one frame to __d_eh_notify_callback, because at the
     point when this code is executed, there's garbage in the
     arguments of __d_eh_break. */
  fi = find_relative_frame (curr_frame, &level);
  if (level != 0)
    return (struct exception_event_record *) NULL;

  select_frame (fi);

  /* Read in the arguments */
  /* __d_eh_notify_callback() is called with 3 arguments:
     1. event kind catch or throw
     2. the target address if known
     3. a flag -- not sure what this is. pai/1997-07-17 */
  event_kind = read_register (ARG0_REGNUM);
  catch_addr = read_register (ARG1_REGNUM);

  /* Now go down to a user frame */
  /* For a throw, __d_eh_break is called by
     __d_eh_notify_callback which is called by
     __notify_throw which is called
     from user code.
     For a catch, __d_eh_break is called by
     __d_eh_notify_callback which is called by
     <stackwalking stuff> which is called by
     __throw__<stuff> or __rethrow_<stuff> which is called
     from user code. */
  /* FIXME: Don't use such magic numbers; search for the frames */
  level = (event_kind == EX_EVENT_THROW) ? 3 : 4;
  fi = find_relative_frame (curr_frame, &level);
  if (level != 0)
    return (struct exception_event_record *) NULL;

  select_frame (fi);
  throw_addr = get_frame_pc (fi);

  /* Go back to original (top) frame */
  select_frame (curr_frame);

  current_ex_event.kind = (enum exception_event_kind) event_kind;
  current_ex_event.throw_sal = find_pc_line (throw_addr, 1);
  current_ex_event.catch_sal = find_pc_line (catch_addr, 1);

  return &current_ex_event;
@


1.138
log
@2004-04-03  Andrew Cagney  <cagney@@redhat.com>

	* config/pa/tm-hppa.h (REG_PARM_STACK_SPACE): Delete.
	* config/pa/tm-hppa64.h (PA20W_CALLING_CONVENTIONS)
	(REG_PARM_STACK_SPACE): Delete.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_push_dummy_call):
	Inline reference to REG_PARM_STACK_SPACE.
@
text
@d2237 1
a2237 1
    CORE_ADDR end_pc = skip_prologue_using_sal (pc);
d2241 1
@


1.137
log
@        * hppa-tdep.c (hppa32_push_dummy_call): Set the Stack Pointer.
        (hppa64_push_dummy_call): Likewise.
@
text
@d901 1
a901 2
	  param_end = struct_end + max (align_up (param_ptr, 8),
					REG_PARM_STACK_SPACE);
d1024 1
a1024 2
	  param_end = struct_end + max (align_up (param_ptr, 16),
					REG_PARM_STACK_SPACE);
@


1.136
log
@2004-03-07  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c: Replace DEPRECATED_FP_REGNUM with HPPA_FP_REGNUM,
	FP0_REGNUM with HPPA_FP0_REGNUM, and SP_REGNUM with
	HPPA_SP_REGNUM.
	(hppa_register_raw_size, hppa_register_byte, hppa_read_fp)
	(hppa_target_read_fp): Delete.
	(hppa_gdbarch_init): Do not set deprecated register_raw_size,
	register_virtual_size, max_register_raw_size,
	max_register_virtual_size, register_byte, register_size,
	target_read_fp, fp_regnum, and register_bytes.  Set register_type
	instead of register_virtual_type.
	(hppa32_register_type, hppa64_register_type): Replace
	hppa32_register_virtual_type and hppa64_register_virtual_type.
	* config/pa/tm-hppa.h (HPPA_FP0_REGNUM, HPPA_SP_REGNUM)
	(HPPA_FP_REGNUM): Define.
@
text
@d914 3
d1037 3
@


1.135
log
@2004-03-07  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa_gdbarch_init): Add missing "break".
@
text
@a149 4
int hppa_register_raw_size (int reg_nr);
int hppa_register_byte (int reg_nr);
struct type * hppa32_register_virtual_type (int reg_nr);
struct type * hppa64_register_virtual_type (int reg_nr);
a153 1
CORE_ADDR hppa_target_read_fp (void);
a1152 25
/* If the pid is in a syscall, then the FP register is not readable.
   We'll return zero in that case, rather than attempting to read it
   and cause a warning. */

CORE_ADDR
hppa_read_fp (int pid)
{
  int flags = read_register (FLAGS_REGNUM);

  if (flags & 2)
    {
      return (CORE_ADDR) 0;
    }

  /* This is the only site that may directly read_register () the FP
     register.  All others must use deprecated_read_fp (). */
  return read_register (DEPRECATED_FP_REGNUM);
}

CORE_ADDR
hppa_target_read_fp (void)
{
  return hppa_read_fp (PIDGET (inferior_ptid));
}

d1698 1
a1698 1
		    (read_register (SP_REGNUM) - 8, 4)) & ~0x3;
d1712 1
a1712 1
		  (read_register (SP_REGNUM) - 24, TARGET_PTR_BIT / 8)) & ~0x3;
d1724 1
a1724 1
		  (read_register (SP_REGNUM) - 24, TARGET_PTR_BIT / 8)) & ~0x3;
d1911 1
a1911 1
      if (u->Save_SP && i == DEPRECATED_FP_REGNUM)
d2205 1
a2205 1
      if (u->Save_SP && i == DEPRECATED_FP_REGNUM)
d2275 1
a2275 1
	    cache->saved_regs[DEPRECATED_FP_REGNUM].addr = 0;
d2281 1
a2281 1
	    && (!u->Save_SP || reg != DEPRECATED_FP_REGNUM))
d2341 1
a2341 1
		cache->saved_regs[reg + FP0_REGNUM + 4].addr = fp_loc;
d2360 1
a2360 1
    CORE_ADDR this_sp = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
d2363 1
a2363 1
    if (u->Save_SP && trad_frame_addr_p (cache->saved_regs, SP_REGNUM))
d2372 1
a2372 1
    trad_frame_set_value (cache->saved_regs, SP_REGNUM, cache->base);
d2482 1
a2482 1
							 SP_REGNUM),
a3097 18
int
hppa_register_raw_size (int reg_nr)
{
  /* All registers have the same size.  */
  return DEPRECATED_REGISTER_SIZE;
}

/* Index within the register vector of the first byte of the space i
   used for register REG_NR.  */

int
hppa_register_byte (int reg_nr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  return reg_nr * tdep->bytes_per_address;
}

d3101 2
a3102 2
struct type *
hppa32_register_virtual_type (int reg_nr)
d3105 1
a3105 1
     return builtin_type_int;
d3107 1
a3107 1
     return builtin_type_float;
d3113 2
a3114 2
struct type *
hppa64_register_virtual_type (int reg_nr)
d3117 1
a3117 1
     return builtin_type_unsigned_long_long;
d3119 1
a3119 1
     return builtin_type_double;
d3232 1
a3232 2
        set_gdbarch_deprecated_register_virtual_type
          (gdbarch, hppa32_register_virtual_type);
d3237 1
a3237 2
        set_gdbarch_deprecated_register_virtual_type
          (gdbarch, hppa64_register_virtual_type);
a3243 4
  /* The following gdbarch vector elements depend on other parts of this
     vector which have been set above, depending on the ABI.  */
  set_gdbarch_deprecated_register_bytes
    (gdbarch, gdbarch_num_regs (gdbarch) * tdep->bytes_per_address);
d3261 2
a3262 9
  set_gdbarch_deprecated_register_size (gdbarch, tdep->bytes_per_address);
  set_gdbarch_deprecated_fp_regnum (gdbarch, 3);
  set_gdbarch_sp_regnum (gdbarch, 30);
  set_gdbarch_fp0_regnum (gdbarch, 64);
  set_gdbarch_deprecated_register_raw_size (gdbarch, hppa_register_raw_size);
  set_gdbarch_deprecated_register_byte (gdbarch, hppa_register_byte);
  set_gdbarch_deprecated_register_virtual_size (gdbarch, hppa_register_raw_size);
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, tdep->bytes_per_address);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 8);
a3268 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, hppa_target_read_fp);
@


1.134
log
@2004-03-07  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (pa_do_registers_info, pa_do_strcat_registers_info)
	(pa_print_registers, pa_print_fp_reg, pa_strcat_registers)
	(pa_strcat_fp_reg, pa_register_look_aside): Delete.
	* config/pa/tm-hppa.h (DEPRECATED_DO_REGISTERS_INFO)
	(pa_do_registers_info): Delete.
@
text
@d3366 1
@


1.133
log
@2004-03-07  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c (legacy_push_dummy_code): Delete #ifdef
	GDB_TARGET_IS_HPPA code.
	* config/pa/tm-hppa.h (DEPRECATED_FIX_CALL_DUMMY)
	(hppa_fix_call_dummy, DEPRECATED_CALL_DUMMY_HAS_COMPLETED)
	(DEPRECATED_DUMMY_WRITE_SP, CALL_DUMMY): Delete.
	* config/pa/tm-hppa64.h (CALL_DUMMY): Delete.
	* hppa-tdep.c (hppa_frame_chain, hppa_frame_chain_valid)
	(hppa_push_dummy_frame, hppa_pop_frame, hppa_push_arguments)
	(hppa_fix_call_dummy, hppa64_stack_align, hppa_frame_saved_pc)
	(hppa_init_extra_frame_info, hppa_saved_pc_after_call)
	(hppa64_call_dummy_breakpoint_offset, hppa_frame_init_saved_regs)
	(hppa_frameless_function_invocation, hppa64_store_return_value)
	(hppa_store_struct_return, hppa64_extract_return_value)
	(hppa64_use_struct_convention, hppa_frame_find_saved_regs)
	(hppa32_call_dummy_length, hppa64_call_dummy_length)
	(find_dummy_frame_regs, FUNC_LDIL_OFFSET, FUNC_LDO_OFFSET)
	(find_proc_framesize, deposit_21, restore_pc_queue)
	(find_return_regnum, pc_in_interrupt_handler, deposit_14)
	(rp_saved, pc_in_linker_stub):
@
text
@a138 5
static void pa_print_registers (char *, int, int);
static void pa_strcat_registers (char *, int, int, struct ui_file *);
static void pa_register_look_aside (char *, int, long *);
static void pa_print_fp_reg (int);
static void pa_strcat_fp_reg (int, struct ui_file *, enum precision_type);
a1252 384
}

/* Print the register regnum, or all registers if regnum is -1 */

void
pa_do_registers_info (int regnum, int fpregs)
{
  char *raw_regs = alloca (DEPRECATED_REGISTER_BYTES);
  int i;

  /* Make a copy of gdb's save area (may cause actual
     reads from the target). */
  for (i = 0; i < NUM_REGS; i++)
    frame_register_read (deprecated_selected_frame, i,
			 raw_regs + DEPRECATED_REGISTER_BYTE (i));

  if (regnum == -1)
    pa_print_registers (raw_regs, regnum, fpregs);
  else if (regnum < FP4_REGNUM)
    {
      long reg_val[2];

      /* Why is the value not passed through "extract_signed_integer"
         as in "pa_print_registers" below? */
      pa_register_look_aside (raw_regs, regnum, &reg_val[0]);

      if (!is_pa_2)
	{
	  printf_unfiltered ("%s %lx\n", REGISTER_NAME (regnum), reg_val[1]);
	}
      else
	{
	  /* Fancy % formats to prevent leading zeros. */
	  if (reg_val[0] == 0)
	    printf_unfiltered ("%s %lx\n", REGISTER_NAME (regnum), reg_val[1]);
	  else
	    printf_unfiltered ("%s %lx%8.8lx\n", REGISTER_NAME (regnum),
			       reg_val[0], reg_val[1]);
	}
    }
  else
    /* Note that real floating point values only start at
       FP4_REGNUM.  FP0 and up are just status and error
       registers, which have integral (bit) values. */
    pa_print_fp_reg (regnum);
}

/********** new function ********************/
void
pa_do_strcat_registers_info (int regnum, int fpregs, struct ui_file *stream,
			     enum precision_type precision)
{
  char *raw_regs = alloca (DEPRECATED_REGISTER_BYTES);
  int i;

  /* Make a copy of gdb's save area (may cause actual
     reads from the target). */
  for (i = 0; i < NUM_REGS; i++)
    frame_register_read (deprecated_selected_frame, i,
			 raw_regs + DEPRECATED_REGISTER_BYTE (i));

  if (regnum == -1)
    pa_strcat_registers (raw_regs, regnum, fpregs, stream);

  else if (regnum < FP4_REGNUM)
    {
      long reg_val[2];

      /* Why is the value not passed through "extract_signed_integer"
         as in "pa_print_registers" below? */
      pa_register_look_aside (raw_regs, regnum, &reg_val[0]);

      if (!is_pa_2)
	{
	  fprintf_unfiltered (stream, "%s %lx", REGISTER_NAME (regnum), reg_val[1]);
	}
      else
	{
	  /* Fancy % formats to prevent leading zeros. */
	  if (reg_val[0] == 0)
	    fprintf_unfiltered (stream, "%s %lx", REGISTER_NAME (regnum),
				reg_val[1]);
	  else
	    fprintf_unfiltered (stream, "%s %lx%8.8lx", REGISTER_NAME (regnum),
				reg_val[0], reg_val[1]);
	}
    }
  else
    /* Note that real floating point values only start at
       FP4_REGNUM.  FP0 and up are just status and error
       registers, which have integral (bit) values. */
    pa_strcat_fp_reg (regnum, stream, precision);
}

/* If this is a PA2.0 machine, fetch the real 64-bit register
   value.  Otherwise use the info from gdb's saved register area.

   Note that reg_val is really expected to be an array of longs,
   with two elements. */
static void
pa_register_look_aside (char *raw_regs, int regnum, long *raw_val)
{
  static int know_which = 0;	/* False */

  int regaddr;
  unsigned int offset;
  int i;
  int start;


  char buf[MAX_REGISTER_SIZE];
  long long reg_val;

  if (!know_which)
    {
      if (CPU_PA_RISC2_0 == sysconf (_SC_CPU_VERSION))
	{
	  is_pa_2 = (1 == 1);
	}

      know_which = 1;		/* True */
    }

  raw_val[0] = 0;
  raw_val[1] = 0;

  if (!is_pa_2)
    {
      raw_val[1] = *(long *) (raw_regs + DEPRECATED_REGISTER_BYTE (regnum));
      return;
    }

  /* Code below copied from hppah-nat.c, with fixes for wide
     registers, using different area of save_state, etc. */
  if (regnum == FLAGS_REGNUM || regnum >= FP0_REGNUM ||
      !HAVE_STRUCT_SAVE_STATE_T || !HAVE_STRUCT_MEMBER_SS_WIDE)
    {
      /* Use narrow regs area of save_state and default macro. */
      offset = U_REGS_OFFSET;
      regaddr = register_addr (regnum, offset);
      start = 1;
    }
  else
    {
      /* Use wide regs area, and calculate registers as 8 bytes wide.

         We'd like to do this, but current version of "C" doesn't
         permit "offsetof":

         offset  = offsetof(save_state_t, ss_wide);

         Note that to avoid "C" doing typed pointer arithmetic, we
         have to cast away the type in our offset calculation:
         otherwise we get an offset of 1! */

      /* NB: save_state_t is not available before HPUX 9.
         The ss_wide field is not available previous to HPUX 10.20,
         so to avoid compile-time warnings, we only compile this for
         PA 2.0 processors.  This control path should only be followed
         if we're debugging a PA 2.0 processor, so this should not cause
         problems. */

      /* #if the following code out so that this file can still be
         compiled on older HPUX boxes (< 10.20) which don't have
         this structure/structure member.  */
#if HAVE_STRUCT_SAVE_STATE_T == 1 && HAVE_STRUCT_MEMBER_SS_WIDE == 1
      save_state_t temp;

      offset = ((int) &temp.ss_wide) - ((int) &temp);
      regaddr = offset + regnum * 8;
      start = 0;
#endif
    }

  for (i = start; i < 2; i++)
    {
      errno = 0;
      raw_val[i] = call_ptrace (PT_RUREGS, PIDGET (inferior_ptid),
				(PTRACE_ARG3_TYPE) regaddr, 0);
      if (errno != 0)
	{
	  /* Warning, not error, in case we are attached; sometimes the
	     kernel doesn't let us at the registers.  */
	  char *err = safe_strerror (errno);
	  char *msg = alloca (strlen (err) + 128);
	  sprintf (msg, "reading register %s: %s", REGISTER_NAME (regnum), err);
	  warning (msg);
	  goto error_exit;
	}

      regaddr += sizeof (long);
    }

  if (regnum == PCOQ_HEAD_REGNUM || regnum == PCOQ_TAIL_REGNUM)
    raw_val[1] &= ~0x3;		/* I think we're masking out space bits */

error_exit:
  ;
}

/* "Info all-reg" command */

static void
pa_print_registers (char *raw_regs, int regnum, int fpregs)
{
  int i, j;
  /* Alas, we are compiled so that "long long" is 32 bits */
  long raw_val[2];
  long long_val;
  int rows = 48, columns = 2;

  for (i = 0; i < rows; i++)
    {
      for (j = 0; j < columns; j++)
	{
	  /* We display registers in column-major order.  */
	  int regnum = i + j * rows;

	  /* Q: Why is the value passed through "extract_signed_integer",
	     while above, in "pa_do_registers_info" it isn't?
	     A: ? */
	  pa_register_look_aside (raw_regs, regnum, &raw_val[0]);

	  /* Even fancier % formats to prevent leading zeros
	     and still maintain the output in columns. */
	  if (!is_pa_2)
	    {
	      /* Being big-endian, on this machine the low bits
	         (the ones we want to look at) are in the second longword. */
	      long_val = extract_signed_integer (&raw_val[1], 4);
	      printf_filtered ("%10.10s: %8lx   ",
			       REGISTER_NAME (regnum), long_val);
	    }
	  else
	    {
	      /* raw_val = extract_signed_integer(&raw_val, 8); */
	      if (raw_val[0] == 0)
		printf_filtered ("%10.10s:         %8lx   ",
				 REGISTER_NAME (regnum), raw_val[1]);
	      else
		printf_filtered ("%10.10s: %8lx%8.8lx   ",
				 REGISTER_NAME (regnum),
				 raw_val[0], raw_val[1]);
	    }
	}
      printf_unfiltered ("\n");
    }

  if (fpregs)
    for (i = FP4_REGNUM; i < NUM_REGS; i++)	/* FP4_REGNUM == 72 */
      pa_print_fp_reg (i);
}

/************* new function ******************/
static void
pa_strcat_registers (char *raw_regs, int regnum, int fpregs,
		     struct ui_file *stream)
{
  int i, j;
  long raw_val[2];		/* Alas, we are compiled so that "long long" is 32 bits */
  long long_val;
  enum precision_type precision;

  precision = unspecified_precision;

  for (i = 0; i < 18; i++)
    {
      for (j = 0; j < 4; j++)
	{
	  /* Q: Why is the value passed through "extract_signed_integer",
	     while above, in "pa_do_registers_info" it isn't?
	     A: ? */
	  pa_register_look_aside (raw_regs, i + (j * 18), &raw_val[0]);

	  /* Even fancier % formats to prevent leading zeros
	     and still maintain the output in columns. */
	  if (!is_pa_2)
	    {
	      /* Being big-endian, on this machine the low bits
	         (the ones we want to look at) are in the second longword. */
	      long_val = extract_signed_integer (&raw_val[1], 4);
	      fprintf_filtered (stream, "%8.8s: %8lx  ",
				REGISTER_NAME (i + (j * 18)), long_val);
	    }
	  else
	    {
	      /* raw_val = extract_signed_integer(&raw_val, 8); */
	      if (raw_val[0] == 0)
		fprintf_filtered (stream, "%8.8s:         %8lx  ",
				  REGISTER_NAME (i + (j * 18)), raw_val[1]);
	      else
		fprintf_filtered (stream, "%8.8s: %8lx%8.8lx  ",
				  REGISTER_NAME (i + (j * 18)), raw_val[0],
				  raw_val[1]);
	    }
	}
      fprintf_unfiltered (stream, "\n");
    }

  if (fpregs)
    for (i = FP4_REGNUM; i < NUM_REGS; i++)	/* FP4_REGNUM == 72 */
      pa_strcat_fp_reg (i, stream, precision);
}

static void
pa_print_fp_reg (int i)
{
  char raw_buffer[MAX_REGISTER_SIZE];
  char virtual_buffer[MAX_REGISTER_SIZE];

  /* Get 32bits of data.  */
  frame_register_read (deprecated_selected_frame, i, raw_buffer);

  /* Put it in the buffer.  No conversions are ever necessary.  */
  memcpy (virtual_buffer, raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (i));

  fputs_filtered (REGISTER_NAME (i), gdb_stdout);
  print_spaces_filtered (8 - strlen (REGISTER_NAME (i)), gdb_stdout);
  fputs_filtered ("(single precision)     ", gdb_stdout);

  val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0, gdb_stdout, 0,
	     1, 0, Val_pretty_default);
  printf_filtered ("\n");

  /* If "i" is even, then this register can also be a double-precision
     FP register.  Dump it out as such.  */
  if ((i % 2) == 0)
    {
      /* Get the data in raw format for the 2nd half.  */
      frame_register_read (deprecated_selected_frame, i + 1, raw_buffer);

      /* Copy it into the appropriate part of the virtual buffer.  */
      memcpy (virtual_buffer + DEPRECATED_REGISTER_RAW_SIZE (i), raw_buffer,
	      DEPRECATED_REGISTER_RAW_SIZE (i));

      /* Dump it as a double.  */
      fputs_filtered (REGISTER_NAME (i), gdb_stdout);
      print_spaces_filtered (8 - strlen (REGISTER_NAME (i)), gdb_stdout);
      fputs_filtered ("(double precision)     ", gdb_stdout);

      val_print (builtin_type_double, virtual_buffer, 0, 0, gdb_stdout, 0,
		 1, 0, Val_pretty_default);
      printf_filtered ("\n");
    }
}

/*************** new function ***********************/
static void
pa_strcat_fp_reg (int i, struct ui_file *stream, enum precision_type precision)
{
  char raw_buffer[MAX_REGISTER_SIZE];
  char virtual_buffer[MAX_REGISTER_SIZE];

  fputs_filtered (REGISTER_NAME (i), stream);
  print_spaces_filtered (8 - strlen (REGISTER_NAME (i)), stream);

  /* Get 32bits of data.  */
  frame_register_read (deprecated_selected_frame, i, raw_buffer);

  /* Put it in the buffer.  No conversions are ever necessary.  */
  memcpy (virtual_buffer, raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (i));

  if (precision == double_precision && (i % 2) == 0)
    {

      char raw_buf[MAX_REGISTER_SIZE];

      /* Get the data in raw format for the 2nd half.  */
      frame_register_read (deprecated_selected_frame, i + 1, raw_buf);

      /* Copy it into the appropriate part of the virtual buffer.  */
      memcpy (virtual_buffer + DEPRECATED_REGISTER_RAW_SIZE (i), raw_buf,
	      DEPRECATED_REGISTER_RAW_SIZE (i));

      val_print (builtin_type_double, virtual_buffer, 0, 0, stream, 0,
		 1, 0, Val_pretty_default);

    }
  else
    {
      val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0, stream, 0,
		 1, 0, Val_pretty_default);
    }

@


1.132
log
@2004-03-07  Andrew Cagney  <cagney@@redhat.com>

	Unconditionally enable 64-bit frame and ABI code.
	* hppa-tdep.c (hppa_gdbarch_init): Do not set deprecated
	call_dummy_breakpoint_offset, call_dummy_length, stack_align,
	push_dummy_frame, fix_call_dummy, push_arguments,
	call_dummy_location, extract_return_value, use_struct_convention,
	store_return_value, store_struct_return, saved_pc_after_call,
	init_frame_pc, frame_init_saved_regs, init_extra_frame_info,
	frame_chain, frame_chain_valid, frameless_function_invocation,
	frame_saved_pc, and pop_frame.
@
text
@a78 9
static const int hppa64_call_dummy_breakpoint_offset = 22 * 4;

/* DEPRECATED_CALL_DUMMY_LENGTH is computed based on the size of a
   word on the target machine, not the size of an instruction.  Since
   a word on this target holds two instructions we have to divide the
   instruction size by two to get the word size of the dummy.  */
static const int hppa32_call_dummy_length = INSTRUCTION_SIZE * 28;
static const int hppa64_call_dummy_length = INSTRUCTION_SIZE * 26 / 2;

a84 5
/* Define offsets into the call dummy for the target function address.
   See comments related to CALL_DUMMY for more info.  */
#define FUNC_LDIL_OFFSET (INSTRUCTION_SIZE * 9)
#define FUNC_LDO_OFFSET (INSTRUCTION_SIZE * 10)

a106 8
static void hppa_frame_init_saved_regs (struct frame_info *frame);

static void find_dummy_frame_regs (struct frame_info *, CORE_ADDR *);

static int find_proc_framesize (CORE_ADDR);

static int find_return_regnum (CORE_ADDR);

a110 2
static unsigned deposit_21 (unsigned int, unsigned int);

a112 2
static unsigned deposit_14 (int, unsigned int);

a120 2
static int restore_pc_queue (CORE_ADDR *);

a130 4
static int pc_in_interrupt_handler (CORE_ADDR);

static int pc_in_linker_stub (CORE_ADDR);

a151 1
CORE_ADDR hppa_saved_pc_after_call (struct frame_info *frame);
a152 1
CORE_ADDR hppa64_stack_align (CORE_ADDR sp);
a158 5
void hppa_store_struct_return (CORE_ADDR addr, CORE_ADDR sp);
void hppa64_extract_return_value (struct type *type, char *regbuf,
                                  char *valbuf);
int hppa64_use_struct_convention (int gcc_p, struct type *type);
void hppa64_store_return_value (struct type *type, char *valbuf);
a159 14
void hppa_init_extra_frame_info (int fromleaf, struct frame_info *frame);
CORE_ADDR hppa_frame_chain (struct frame_info *frame);
int hppa_frame_chain_valid (CORE_ADDR chain, struct frame_info *thisframe);
int hppa_frameless_function_invocation (struct frame_info *frame);
CORE_ADDR hppa_frame_saved_pc (struct frame_info *frame);
CORE_ADDR hppa_frame_args_address (struct frame_info *fi);
int hppa_frame_num_args (struct frame_info *frame);
void hppa_push_dummy_frame (void);
void hppa_pop_frame (void);
CORE_ADDR hppa_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun,
                               int nargs, struct value **args,
                               struct type *type, int gcc_p);
CORE_ADDR hppa_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		               int struct_return, CORE_ADDR struct_addr);
a182 9
/* Should call_function allocate stack space for a struct return?  */

int
hppa64_use_struct_convention (int gcc_p, struct type *type)
{
  /* RM: struct upto 128 bits are returned in registers */
  return TYPE_LENGTH (type) > 16;
}

a349 10
/* deposit a 14 bit constant in a word */

static unsigned
deposit_14 (int opnd, unsigned word)
{
  unsigned sign = (opnd < 0 ? 1 : 0);

  return word | ((unsigned) opnd << 1 & MASK_14) | sign;
}

a370 21
/* deposit a 21 bit constant in a word. Although 21 bit constants are
   usually the top 21 bits of a 32 bit constant, we assume that only
   the low 21 bits of opnd are relevant */

static unsigned
deposit_21 (unsigned opnd, unsigned word)
{
  unsigned val = 0;

  val |= get_field (opnd, 11 + 14, 11 + 18);
  val <<= 2;
  val |= get_field (opnd, 11 + 12, 11 + 13);
  val <<= 2;
  val |= get_field (opnd, 11 + 19, 11 + 20);
  val <<= 11;
  val |= get_field (opnd, 11 + 1, 11 + 11);
  val <<= 1;
  val |= get_field (opnd, 11 + 0, 11 + 0);
  return word | val;
}

d795 2
a796 1236
/* Return the adjustment necessary to make for addresses on the stack
   as presented by hpread.c.

   This is necessary because of the stack direction on the PA and the
   bizarre way in which someone (?) decided they wanted to handle
   frame pointerless code in GDB.  */
int
hpread_adjust_stack_address (CORE_ADDR func_addr)
{
  struct unwind_table_entry *u;

  u = find_unwind_entry (func_addr);
  if (!u)
    return 0;
  else
    return u->Total_frame_size << 3;
}

/* Called to determine if PC is in an interrupt handler of some
   kind.  */

static int
pc_in_interrupt_handler (CORE_ADDR pc)
{
  struct unwind_table_entry *u;
  struct minimal_symbol *msym_us;

  u = find_unwind_entry (pc);
  if (!u)
    return 0;

  /* Oh joys.  HPUX sets the interrupt bit for _sigreturn even though
     its frame isn't a pure interrupt frame.  Deal with this.  */
  msym_us = lookup_minimal_symbol_by_pc (pc);

  return (u->HP_UX_interrupt_marker
	  && !PC_IN_SIGTRAMP (pc, DEPRECATED_SYMBOL_NAME (msym_us)));
}

/* Called when no unwind descriptor was found for PC.  Returns 1 if it
   appears that PC is in a linker stub.

   ?!? Need to handle stubs which appear in PA64 code.  */

static int
pc_in_linker_stub (CORE_ADDR pc)
{
  int found_magic_instruction = 0;
  int i;
  char buf[4];

  /* If unable to read memory, assume pc is not in a linker stub.  */
  if (target_read_memory (pc, buf, 4) != 0)
    return 0;

  /* We are looking for something like

     ; $$dyncall jams RP into this special spot in the frame (RP')
     ; before calling the "call stub"
     ldw     -18(sp),rp

     ldsid   (rp),r1         ; Get space associated with RP into r1
     mtsp    r1,sp           ; Move it into space register 0
     be,n    0(sr0),rp)      ; back to your regularly scheduled program */

  /* Maximum known linker stub size is 4 instructions.  Search forward
     from the given PC, then backward.  */
  for (i = 0; i < 4; i++)
    {
      /* If we hit something with an unwind, stop searching this direction.  */

      if (find_unwind_entry (pc + i * 4) != 0)
	break;

      /* Check for ldsid (rp),r1 which is the magic instruction for a 
         return from a cross-space function call.  */
      if (read_memory_integer (pc + i * 4, 4) == 0x004010a1)
	{
	  found_magic_instruction = 1;
	  break;
	}
      /* Add code to handle long call/branch and argument relocation stubs
         here.  */
    }

  if (found_magic_instruction != 0)
    return 1;

  /* Now look backward.  */
  for (i = 0; i < 4; i++)
    {
      /* If we hit something with an unwind, stop searching this direction.  */

      if (find_unwind_entry (pc - i * 4) != 0)
	break;

      /* Check for ldsid (rp),r1 which is the magic instruction for a 
         return from a cross-space function call.  */
      if (read_memory_integer (pc - i * 4, 4) == 0x004010a1)
	{
	  found_magic_instruction = 1;
	  break;
	}
      /* Add code to handle long call/branch and argument relocation stubs
         here.  */
    }
  return found_magic_instruction;
}

static int
find_return_regnum (CORE_ADDR pc)
{
  struct unwind_table_entry *u;

  u = find_unwind_entry (pc);

  if (!u)
    return RP_REGNUM;

  if (u->Millicode)
    return 31;

  return RP_REGNUM;
}

/* Return size of frame, or -1 if we should use a frame pointer.  */
static int
find_proc_framesize (CORE_ADDR pc)
{
  struct unwind_table_entry *u;
  struct minimal_symbol *msym_us;

  /* This may indicate a bug in our callers... */
  if (pc == (CORE_ADDR) 0)
    return -1;

  u = find_unwind_entry (pc);

  if (!u)
    {
      if (pc_in_linker_stub (pc))
	/* Linker stubs have a zero size frame.  */
	return 0;
      else
	return -1;
    }

  msym_us = lookup_minimal_symbol_by_pc (pc);

  /* If Save_SP is set, and we're not in an interrupt or signal caller,
     then we have a frame pointer.  Use it.  */
  if (u->Save_SP
      && !pc_in_interrupt_handler (pc)
      && msym_us
      && !PC_IN_SIGTRAMP (pc, DEPRECATED_SYMBOL_NAME (msym_us)))
    return -1;

  return u->Total_frame_size << 3;
}

/* Return offset from sp at which rp is saved, or 0 if not saved.  */
static int rp_saved (CORE_ADDR);

static int
rp_saved (CORE_ADDR pc)
{
  struct unwind_table_entry *u;

  /* A function at, and thus a return PC from, address 0?  Not in HP-UX! */
  if (pc == (CORE_ADDR) 0)
    return 0;

  u = find_unwind_entry (pc);

  if (!u)
    {
      if (pc_in_linker_stub (pc))
	/* This is the so-called RP'.  */
	return -24;
      else
	return 0;
    }

  if (u->Save_RP)
    return (TARGET_PTR_BIT == 64 ? -16 : -20);
  else if (u->stub_unwind.stub_type != 0)
    {
      switch (u->stub_unwind.stub_type)
	{
	case EXPORT:
	case IMPORT:
	  return -24;
	case PARAMETER_RELOCATION:
	  return -8;
	default:
	  return 0;
	}
    }
  else
    return 0;
}

int
hppa_frameless_function_invocation (struct frame_info *frame)
{
  struct unwind_table_entry *u;

  u = find_unwind_entry (get_frame_pc (frame));

  if (u == 0)
    return 0;

  return (u->Total_frame_size == 0 && u->stub_unwind.stub_type == 0);
}

/* Immediately after a function call, return the saved pc.
   Can't go through the frames for this because on some machines
   the new frame is not set up until the new function executes
   some instructions.  */

CORE_ADDR
hppa_saved_pc_after_call (struct frame_info *frame)
{
  int ret_regnum;
  CORE_ADDR pc;
  struct unwind_table_entry *u;

  ret_regnum = find_return_regnum (get_frame_pc (frame));
  pc = read_register (ret_regnum) & ~0x3;

  /* If PC is in a linker stub, then we need to dig the address
     the stub will return to out of the stack.  */
  u = find_unwind_entry (pc);
  if (u && u->stub_unwind.stub_type != 0)
    return DEPRECATED_FRAME_SAVED_PC (frame);
  else
    return pc;
}

CORE_ADDR
hppa_frame_saved_pc (struct frame_info *frame)
{
  CORE_ADDR pc = get_frame_pc (frame);
  struct unwind_table_entry *u;
  CORE_ADDR old_pc = 0;
  int spun_around_loop = 0;
  int rp_offset = 0;

  /* BSD, HPUX & OSF1 all lay out the hardware state in the same manner
     at the base of the frame in an interrupt handler.  Registers within
     are saved in the exact same order as GDB numbers registers.  How
     convienent.  */
  if (pc_in_interrupt_handler (pc))
    return read_memory_integer (get_frame_base (frame) + PCOQ_HEAD_REGNUM * 4,
				TARGET_PTR_BIT / 8) & ~0x3;

  if ((get_frame_pc (frame) >= get_frame_base (frame)
       && (get_frame_pc (frame)
	   <= (get_frame_base (frame)
	       /* A call dummy is sized in words, but it is actually a
		  series of instructions.  Account for that scaling
		  factor.  */
	       + ((DEPRECATED_REGISTER_SIZE / INSTRUCTION_SIZE)
		  * DEPRECATED_CALL_DUMMY_LENGTH)
	       /* Similarly we have to account for 64bit wide register
		  saves.  */
	       + (32 * DEPRECATED_REGISTER_SIZE)
	       /* We always consider FP regs 8 bytes long.  */
	       + (NUM_REGS - FP0_REGNUM) * 8
	       /* Similarly we have to account for 64bit wide register
		  saves.  */
	       + (6 * DEPRECATED_REGISTER_SIZE)))))
    {
      return read_memory_integer ((get_frame_base (frame)
				   + (TARGET_PTR_BIT == 64 ? -16 : -20)),
				  TARGET_PTR_BIT / 8) & ~0x3;
    }

#ifdef FRAME_SAVED_PC_IN_SIGTRAMP
  /* Deal with signal handler caller frames too.  */
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
    {
      CORE_ADDR rp;
      FRAME_SAVED_PC_IN_SIGTRAMP (frame, &rp);
      return rp & ~0x3;
    }
#endif

  if (hppa_frameless_function_invocation (frame))
    {
      int ret_regnum;

      ret_regnum = find_return_regnum (pc);

      /* If the next frame is an interrupt frame or a signal
         handler caller, then we need to look in the saved
         register area to get the return pointer (the values
         in the registers may not correspond to anything useful).  */
      if (get_next_frame (frame)
	  && ((get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME)
	      || pc_in_interrupt_handler (get_frame_pc (get_next_frame (frame)))))
	{
	  CORE_ADDR *saved_regs;
	  hppa_frame_init_saved_regs (get_next_frame (frame));
	  saved_regs = deprecated_get_frame_saved_regs (get_next_frame (frame));
	  if (read_memory_integer (saved_regs[FLAGS_REGNUM],
				   TARGET_PTR_BIT / 8) & 0x2)
	    {
	      pc = read_memory_integer (saved_regs[31],
					TARGET_PTR_BIT / 8) & ~0x3;

	      /* Syscalls are really two frames.  The syscall stub itself
	         with a return pointer in %rp and the kernel call with
	         a return pointer in %r31.  We return the %rp variant
	         if %r31 is the same as frame->pc.  */
	      if (pc == get_frame_pc (frame))
		pc = read_memory_integer (saved_regs[RP_REGNUM],
					  TARGET_PTR_BIT / 8) & ~0x3;
	    }
	  else
	    pc = read_memory_integer (saved_regs[RP_REGNUM],
				      TARGET_PTR_BIT / 8) & ~0x3;
	}
      else
	pc = read_register (ret_regnum) & ~0x3;
    }
  else
    {
      spun_around_loop = 0;
      old_pc = pc;

    restart:
      rp_offset = rp_saved (pc);

      /* Similar to code in frameless function case.  If the next
         frame is a signal or interrupt handler, then dig the right
         information out of the saved register info.  */
      if (rp_offset == 0
	  && get_next_frame (frame)
	  && ((get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME)
	      || pc_in_interrupt_handler (get_frame_pc (get_next_frame (frame)))))
	{
	  CORE_ADDR *saved_regs;
	  hppa_frame_init_saved_regs (get_next_frame (frame));
	  saved_regs = deprecated_get_frame_saved_regs (get_next_frame (frame));
	  if (read_memory_integer (saved_regs[FLAGS_REGNUM],
				   TARGET_PTR_BIT / 8) & 0x2)
	    {
	      pc = read_memory_integer (saved_regs[31],
					TARGET_PTR_BIT / 8) & ~0x3;

	      /* Syscalls are really two frames.  The syscall stub itself
	         with a return pointer in %rp and the kernel call with
	         a return pointer in %r31.  We return the %rp variant
	         if %r31 is the same as frame->pc.  */
	      if (pc == get_frame_pc (frame))
		pc = read_memory_integer (saved_regs[RP_REGNUM],
					  TARGET_PTR_BIT / 8) & ~0x3;
	    }
	  else
	    pc = read_memory_integer (saved_regs[RP_REGNUM],
				      TARGET_PTR_BIT / 8) & ~0x3;
	}
      else if (rp_offset == 0)
	{
	  old_pc = pc;
	  pc = read_register (RP_REGNUM) & ~0x3;
	}
      else
	{
	  old_pc = pc;
	  pc = read_memory_integer (get_frame_base (frame) + rp_offset,
				    TARGET_PTR_BIT / 8) & ~0x3;
	}
    }

  /* If PC is inside a linker stub, then dig out the address the stub
     will return to. 

     Don't do this for long branch stubs.  Why?  For some unknown reason
     _start is marked as a long branch stub in hpux10.  */
  u = find_unwind_entry (pc);
  if (u && u->stub_unwind.stub_type != 0
      && u->stub_unwind.stub_type != LONG_BRANCH)
    {
      unsigned int insn;

      /* If this is a dynamic executable, and we're in a signal handler,
         then the call chain will eventually point us into the stub for
         _sigreturn.  Unlike most cases, we'll be pointed to the branch
         to the real sigreturn rather than the code after the real branch!. 

         Else, try to dig the address the stub will return to in the normal
         fashion.  */
      insn = read_memory_integer (pc, 4);
      if ((insn & 0xfc00e000) == 0xe8000000)
	return (pc + extract_17 (insn) + 8) & ~0x3;
      else
	{
	  if (old_pc == pc)
	    spun_around_loop++;

	  if (spun_around_loop > 1)
	    {
	      /* We're just about to go around the loop again with
	         no more hope of success.  Die. */
	      error ("Unable to find return pc for this frame");
	    }
	  else
	    goto restart;
	}
    }

  return pc;
}

/* We need to correct the PC and the FP for the outermost frame when we are
   in a system call.  */

void
hppa_init_extra_frame_info (int fromleaf, struct frame_info *frame)
{
  int flags;
  int framesize;

  if (get_next_frame (frame) && !fromleaf)
    return;

  /* If the next frame represents a frameless function invocation then
     we have to do some adjustments that are normally done by
     DEPRECATED_FRAME_CHAIN.  (DEPRECATED_FRAME_CHAIN is not called in
     this case.)  */
  if (fromleaf)
    {
      /* Find the framesize of *this* frame without peeking at the PC
         in the current frame structure (it isn't set yet).  */
      framesize = find_proc_framesize (DEPRECATED_FRAME_SAVED_PC (get_next_frame (frame)));

      /* Now adjust our base frame accordingly.  If we have a frame pointer
         use it, else subtract the size of this frame from the current
         frame.  (we always want frame->frame to point at the lowest address
         in the frame).  */
      if (framesize == -1)
	deprecated_update_frame_base_hack (frame, deprecated_read_fp ());
      else
	deprecated_update_frame_base_hack (frame, get_frame_base (frame) - framesize);
      return;
    }

  flags = read_register (FLAGS_REGNUM);
  if (flags & 2)		/* In system call? */
    deprecated_update_frame_pc_hack (frame, read_register (31) & ~0x3);

  /* The outermost frame is always derived from PC-framesize

     One might think frameless innermost frames should have
     a frame->frame that is the same as the parent's frame->frame.
     That is wrong; frame->frame in that case should be the *high*
     address of the parent's frame.  It's complicated as hell to
     explain, but the parent *always* creates some stack space for
     the child.  So the child actually does have a frame of some
     sorts, and its base is the high address in its parent's frame.  */
  framesize = find_proc_framesize (get_frame_pc (frame));
  if (framesize == -1)
    deprecated_update_frame_base_hack (frame, deprecated_read_fp ());
  else
    deprecated_update_frame_base_hack (frame, read_register (SP_REGNUM) - framesize);
}

/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct, and
   then DEPRECATED_INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC
   will be called for the new frame.

   This may involve searching through prologues for several functions
   at boundaries where GCC calls HP C code, or where code which has
   a frame pointer calls code without a frame pointer.  */

CORE_ADDR
hppa_frame_chain (struct frame_info *frame)
{
  int my_framesize, caller_framesize;
  struct unwind_table_entry *u;
  CORE_ADDR frame_base;
  struct frame_info *tmp_frame;

  /* A frame in the current frame list, or zero.  */
  struct frame_info *saved_regs_frame = 0;
  /* Where the registers were saved in saved_regs_frame.  If
     saved_regs_frame is zero, this is garbage.  */
  CORE_ADDR *saved_regs = NULL;

  CORE_ADDR caller_pc;

  struct minimal_symbol *min_frame_symbol;
  struct symbol *frame_symbol;
  char *frame_symbol_name;

  /* If this is a threaded application, and we see the
     routine "__pthread_exit", treat it as the stack root
     for this thread. */
  min_frame_symbol = lookup_minimal_symbol_by_pc (get_frame_pc (frame));
  frame_symbol = find_pc_function (get_frame_pc (frame));

  if ((min_frame_symbol != 0) /* && (frame_symbol == 0) */ )
    {
      /* The test above for "no user function name" would defend
         against the slim likelihood that a user might define a
         routine named "__pthread_exit" and then try to debug it.

         If it weren't commented out, and you tried to debug the
         pthread library itself, you'd get errors.

         So for today, we don't make that check. */
      frame_symbol_name = DEPRECATED_SYMBOL_NAME (min_frame_symbol);
      if (frame_symbol_name != 0)
	{
	  if (0 == strncmp (frame_symbol_name,
			    THREAD_INITIAL_FRAME_SYMBOL,
			    THREAD_INITIAL_FRAME_SYM_LEN))
	    {
	      /* Pretend we've reached the bottom of the stack. */
	      return (CORE_ADDR) 0;
	    }
	}
    }				/* End of hacky code for threads. */

  /* Handle HPUX, BSD, and OSF1 style interrupt frames first.  These
     are easy; at *sp we have a full save state strucutre which we can
     pull the old stack pointer from.  Also see frame_saved_pc for
     code to dig a saved PC out of the save state structure.  */
  if (pc_in_interrupt_handler (get_frame_pc (frame)))
    frame_base = read_memory_integer (get_frame_base (frame) + SP_REGNUM * 4,
				      TARGET_PTR_BIT / 8);
#ifdef FRAME_BASE_BEFORE_SIGTRAMP
  else if ((get_frame_type (frame) == SIGTRAMP_FRAME))
    {
      FRAME_BASE_BEFORE_SIGTRAMP (frame, &frame_base);
    }
#endif
  else
    frame_base = get_frame_base (frame);

  /* Get frame sizes for the current frame and the frame of the 
     caller.  */
  my_framesize = find_proc_framesize (get_frame_pc (frame));
  caller_pc = DEPRECATED_FRAME_SAVED_PC (frame);

  /* If we can't determine the caller's PC, then it's not likely we can
     really determine anything meaningful about its frame.  We'll consider
     this to be stack bottom. */
  if (caller_pc == (CORE_ADDR) 0)
    return (CORE_ADDR) 0;

  caller_framesize = find_proc_framesize (DEPRECATED_FRAME_SAVED_PC (frame));

  /* If caller does not have a frame pointer, then its frame
     can be found at current_frame - caller_framesize.  */
  if (caller_framesize != -1)
    {
      return frame_base - caller_framesize;
    }
  /* Both caller and callee have frame pointers and are GCC compiled
     (SAVE_SP bit in unwind descriptor is on for both functions.
     The previous frame pointer is found at the top of the current frame.  */
  if (caller_framesize == -1 && my_framesize == -1)
    {
      return read_memory_integer (frame_base, TARGET_PTR_BIT / 8);
    }
  /* Caller has a frame pointer, but callee does not.  This is a little
     more difficult as GCC and HP C lay out locals and callee register save
     areas very differently.

     The previous frame pointer could be in a register, or in one of 
     several areas on the stack.

     Walk from the current frame to the innermost frame examining 
     unwind descriptors to determine if %r3 ever gets saved into the
     stack.  If so return whatever value got saved into the stack.
     If it was never saved in the stack, then the value in %r3 is still
     valid, so use it. 

     We use information from unwind descriptors to determine if %r3
     is saved into the stack (Entry_GR field has this information).  */

  for (tmp_frame = frame; tmp_frame; tmp_frame = get_next_frame (tmp_frame))
    {
      u = find_unwind_entry (get_frame_pc (tmp_frame));

      if (!u)
	{
	  /* We could find this information by examining prologues.  I don't
	     think anyone has actually written any tools (not even "strip")
	     which leave them out of an executable, so maybe this is a moot
	     point.  */
	  /* ??rehrauer: Actually, it's quite possible to stepi your way into
	     code that doesn't have unwind entries.  For example, stepping into
	     the dynamic linker will give you a PC that has none.  Thus, I've
	     disabled this warning. */
#if 0
	  warning ("Unable to find unwind for PC 0x%x -- Help!", get_frame_pc (tmp_frame));
#endif
	  return (CORE_ADDR) 0;
	}

      if (u->Save_SP
	  || (get_frame_type (tmp_frame) == SIGTRAMP_FRAME)
	  || pc_in_interrupt_handler (get_frame_pc (tmp_frame)))
	break;

      /* Entry_GR specifies the number of callee-saved general registers
         saved in the stack.  It starts at %r3, so %r3 would be 1.  */
      if (u->Entry_GR >= 1)
	{
	  /* The unwind entry claims that r3 is saved here.  However,
	     in optimized code, GCC often doesn't actually save r3.
	     We'll discover this if we look at the prologue.  */
	  hppa_frame_init_saved_regs (tmp_frame);
	  saved_regs = deprecated_get_frame_saved_regs (tmp_frame);
	  saved_regs_frame = tmp_frame;

	  /* If we have an address for r3, that's good.  */
	  if (saved_regs[DEPRECATED_FP_REGNUM])
	    break;
	}
    }

  if (tmp_frame)
    {
      /* We may have walked down the chain into a function with a frame
         pointer.  */
      if (u->Save_SP
	  && !(get_frame_type (tmp_frame) == SIGTRAMP_FRAME)
	  && !pc_in_interrupt_handler (get_frame_pc (tmp_frame)))
	{
	  return read_memory_integer (get_frame_base (tmp_frame), TARGET_PTR_BIT / 8);
	}
      /* %r3 was saved somewhere in the stack.  Dig it out.  */
      else
	{
	  /* Sick.

	     For optimization purposes many kernels don't have the
	     callee saved registers into the save_state structure upon
	     entry into the kernel for a syscall; the optimization
	     is usually turned off if the process is being traced so
	     that the debugger can get full register state for the
	     process.

	     This scheme works well except for two cases:

	     * Attaching to a process when the process is in the
	     kernel performing a system call (debugger can't get
	     full register state for the inferior process since
	     the process wasn't being traced when it entered the
	     system call).

	     * Register state is not complete if the system call
	     causes the process to core dump.


	     The following heinous code is an attempt to deal with
	     the lack of register state in a core dump.  It will
	     fail miserably if the function which performs the
	     system call has a variable sized stack frame.  */

	  if (tmp_frame != saved_regs_frame)
	    {
	      hppa_frame_init_saved_regs (tmp_frame);
	      saved_regs = deprecated_get_frame_saved_regs (tmp_frame);
	    }

	  /* Abominable hack.  */
	  if (current_target.to_has_execution == 0
	      && ((saved_regs[FLAGS_REGNUM]
		   && (read_memory_integer (saved_regs[FLAGS_REGNUM],
					    TARGET_PTR_BIT / 8)
		       & 0x2))
		  || (saved_regs[FLAGS_REGNUM] == 0
		      && read_register (FLAGS_REGNUM) & 0x2)))
	    {
	      u = find_unwind_entry (DEPRECATED_FRAME_SAVED_PC (frame));
	      if (!u)
		{
		  return read_memory_integer (saved_regs[DEPRECATED_FP_REGNUM],
					      TARGET_PTR_BIT / 8);
		}
	      else
		{
		  return frame_base - (u->Total_frame_size << 3);
		}
	    }

	  return read_memory_integer (saved_regs[DEPRECATED_FP_REGNUM],
				      TARGET_PTR_BIT / 8);
	}
    }
  else
    {
      /* Get the innermost frame.  */
      tmp_frame = frame;
      while (get_next_frame (tmp_frame) != NULL)
	tmp_frame = get_next_frame (tmp_frame);

      if (tmp_frame != saved_regs_frame)
	{
	  hppa_frame_init_saved_regs (tmp_frame);
	  saved_regs = deprecated_get_frame_saved_regs (tmp_frame);
	}

      /* Abominable hack.  See above.  */
      if (current_target.to_has_execution == 0
	  && ((saved_regs[FLAGS_REGNUM]
	       && (read_memory_integer (saved_regs[FLAGS_REGNUM],
					TARGET_PTR_BIT / 8)
		   & 0x2))
	      || (saved_regs[FLAGS_REGNUM] == 0
		  && read_register (FLAGS_REGNUM) & 0x2)))
	{
	  u = find_unwind_entry (DEPRECATED_FRAME_SAVED_PC (frame));
	  if (!u)
	    {
	      return read_memory_integer (saved_regs[DEPRECATED_FP_REGNUM],
					  TARGET_PTR_BIT / 8);
	    }
	  else
	    {
	      return frame_base - (u->Total_frame_size << 3);
	    }
	}

      /* The value in %r3 was never saved into the stack (thus %r3 still
         holds the value of the previous frame pointer).  */
      return deprecated_read_fp ();
    }
}


/* To see if a frame chain is valid, see if the caller looks like it
   was compiled with gcc. */

int
hppa_frame_chain_valid (CORE_ADDR chain, struct frame_info *thisframe)
{
  struct minimal_symbol *msym_us;
  struct minimal_symbol *msym_start;
  struct unwind_table_entry *u, *next_u = NULL;
  struct frame_info *next;

  u = find_unwind_entry (get_frame_pc (thisframe));

  if (u == NULL)
    return 1;

  /* We can't just check that the same of msym_us is "_start", because
     someone idiotically decided that they were going to make a Ltext_end
     symbol with the same address.  This Ltext_end symbol is totally
     indistinguishable (as nearly as I can tell) from the symbol for a function
     which is (legitimately, since it is in the user's namespace)
     named Ltext_end, so we can't just ignore it.  */
  msym_us = lookup_minimal_symbol_by_pc (DEPRECATED_FRAME_SAVED_PC (thisframe));
  msym_start = lookup_minimal_symbol ("_start", NULL, NULL);
  if (msym_us
      && msym_start
      && SYMBOL_VALUE_ADDRESS (msym_us) == SYMBOL_VALUE_ADDRESS (msym_start))
    return 0;

  /* Grrrr.  Some new idiot decided that they don't want _start for the
     PRO configurations; $START$ calls main directly....  Deal with it.  */
  msym_start = lookup_minimal_symbol ("$START$", NULL, NULL);
  if (msym_us
      && msym_start
      && SYMBOL_VALUE_ADDRESS (msym_us) == SYMBOL_VALUE_ADDRESS (msym_start))
    return 0;

  next = get_next_frame (thisframe);
  if (next)
    next_u = find_unwind_entry (get_frame_pc (next));

  /* If this frame does not save SP, has no stack, isn't a stub,
     and doesn't "call" an interrupt routine or signal handler caller,
     then its not valid.  */
  if (u->Save_SP || u->Total_frame_size || u->stub_unwind.stub_type != 0
      || (get_next_frame (thisframe) && (get_frame_type (get_next_frame (thisframe)) == SIGTRAMP_FRAME))
      || (next_u && next_u->HP_UX_interrupt_marker))
    return 1;

  if (pc_in_linker_stub (get_frame_pc (thisframe)))
    return 1;

  return 0;
}

/* These functions deal with saving and restoring register state
   around a function call in the inferior.  They keep the stack
   double-word aligned;  eventually, on an hp700, the stack will have
   to be aligned to a 64-byte boundary.  */

void
hppa_push_dummy_frame (void)
{
  CORE_ADDR sp, pc, pcspace;
  int regnum;
  CORE_ADDR int_buffer;
  double freg_buffer;

  pc = hppa_target_read_pc (inferior_ptid);
  int_buffer = read_register (FLAGS_REGNUM);
  if (int_buffer & 0x2)
    {
      const unsigned int sid = (pc >> 30) & 0x3;
      if (sid == 0)
	pcspace = read_register (SR4_REGNUM);
      else
	pcspace = read_register (SR4_REGNUM + 4 + sid);
    }
  else
    pcspace = read_register (PCSQ_HEAD_REGNUM);

  /* Space for "arguments"; the RP goes in here. */
  sp = read_register (SP_REGNUM) + 48;
  int_buffer = read_register (RP_REGNUM) | 0x3;

  /* The 32bit and 64bit ABIs save the return pointer into different
     stack slots.  */
  if (DEPRECATED_REGISTER_SIZE == 8)
    write_memory (sp - 16, (char *) &int_buffer, DEPRECATED_REGISTER_SIZE);
  else
    write_memory (sp - 20, (char *) &int_buffer, DEPRECATED_REGISTER_SIZE);

  int_buffer = deprecated_read_fp ();
  write_memory (sp, (char *) &int_buffer, DEPRECATED_REGISTER_SIZE);

  write_register (DEPRECATED_FP_REGNUM, sp);

  sp += 2 * DEPRECATED_REGISTER_SIZE;

  for (regnum = 1; regnum < 32; regnum++)
    if (regnum != RP_REGNUM && regnum != DEPRECATED_FP_REGNUM)
      sp = push_word (sp, read_register (regnum));

  /* This is not necessary for the 64bit ABI.  In fact it is dangerous.  */
  if (DEPRECATED_REGISTER_SIZE != 8)
    sp += 4;

  for (regnum = FP0_REGNUM; regnum < NUM_REGS; regnum++)
    {
      deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (regnum),
				      (char *) &freg_buffer, 8);
      sp = push_bytes (sp, (char *) &freg_buffer, 8);
    }
  sp = push_word (sp, read_register (IPSW_REGNUM));
  sp = push_word (sp, read_register (SAR_REGNUM));
  sp = push_word (sp, pc);
  sp = push_word (sp, pcspace);
  sp = push_word (sp, pc + 4);
  sp = push_word (sp, pcspace);
  write_register (SP_REGNUM, sp);
}

static void
find_dummy_frame_regs (struct frame_info *frame,
		       CORE_ADDR frame_saved_regs[])
{
  CORE_ADDR fp = get_frame_base (frame);
  int i;

  /* The 32bit and 64bit ABIs save RP into different locations.  */
  if (DEPRECATED_REGISTER_SIZE == 8)
    frame_saved_regs[RP_REGNUM] = (fp - 16) & ~0x3;
  else
    frame_saved_regs[RP_REGNUM] = (fp - 20) & ~0x3;

  frame_saved_regs[DEPRECATED_FP_REGNUM] = fp;

  frame_saved_regs[1] = fp + (2 * DEPRECATED_REGISTER_SIZE);

  for (fp += 3 * DEPRECATED_REGISTER_SIZE, i = 3; i < 32; i++)
    {
      if (i != DEPRECATED_FP_REGNUM)
	{
	  frame_saved_regs[i] = fp;
	  fp += DEPRECATED_REGISTER_SIZE;
	}
    }

  /* This is not necessary or desirable for the 64bit ABI.  */
  if (DEPRECATED_REGISTER_SIZE != 8)
    fp += 4;

  for (i = FP0_REGNUM; i < NUM_REGS; i++, fp += 8)
    frame_saved_regs[i] = fp;

  frame_saved_regs[IPSW_REGNUM] = fp;
  frame_saved_regs[SAR_REGNUM] = fp + DEPRECATED_REGISTER_SIZE;
  frame_saved_regs[PCOQ_HEAD_REGNUM] = fp + 2 * DEPRECATED_REGISTER_SIZE;
  frame_saved_regs[PCSQ_HEAD_REGNUM] = fp + 3 * DEPRECATED_REGISTER_SIZE;
  frame_saved_regs[PCOQ_TAIL_REGNUM] = fp + 4 * DEPRECATED_REGISTER_SIZE;
  frame_saved_regs[PCSQ_TAIL_REGNUM] = fp + 5 * DEPRECATED_REGISTER_SIZE;
}

void
hppa_pop_frame (void)
{
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR fp, npc, target_pc;
  int regnum;
  CORE_ADDR *fsr;
  double freg_buffer;

  fp = get_frame_base (frame);
  hppa_frame_init_saved_regs (frame);
  fsr = deprecated_get_frame_saved_regs (frame);

#ifndef NO_PC_SPACE_QUEUE_RESTORE
  if (fsr[IPSW_REGNUM])	/* Restoring a call dummy frame */
    restore_pc_queue (fsr);
#endif

  for (regnum = 31; regnum > 0; regnum--)
    if (fsr[regnum])
      write_register (regnum, read_memory_integer (fsr[regnum],
						   DEPRECATED_REGISTER_SIZE));

  for (regnum = NUM_REGS - 1; regnum >= FP0_REGNUM; regnum--)
    if (fsr[regnum])
      {
	read_memory (fsr[regnum], (char *) &freg_buffer, 8);
	deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (regnum),
					 (char *) &freg_buffer, 8);
      }

  if (fsr[IPSW_REGNUM])
    write_register (IPSW_REGNUM,
		    read_memory_integer (fsr[IPSW_REGNUM],
					 DEPRECATED_REGISTER_SIZE));

  if (fsr[SAR_REGNUM])
    write_register (SAR_REGNUM,
		    read_memory_integer (fsr[SAR_REGNUM],
					 DEPRECATED_REGISTER_SIZE));

  /* If the PC was explicitly saved, then just restore it.  */
  if (fsr[PCOQ_TAIL_REGNUM])
    {
      npc = read_memory_integer (fsr[PCOQ_TAIL_REGNUM],
				 DEPRECATED_REGISTER_SIZE);
      write_register (PCOQ_TAIL_REGNUM, npc);
    }
  /* Else use the value in %rp to set the new PC.  */
  else
    {
      npc = read_register (RP_REGNUM);
      write_pc (npc);
    }

  write_register (DEPRECATED_FP_REGNUM, read_memory_integer (fp, DEPRECATED_REGISTER_SIZE));

  if (fsr[IPSW_REGNUM])	/* call dummy */
    write_register (SP_REGNUM, fp - 48);
  else
    write_register (SP_REGNUM, fp);

  /* The PC we just restored may be inside a return trampoline.  If so
     we want to restart the inferior and run it through the trampoline.

     Do this by setting a momentary breakpoint at the location the
     trampoline returns to. 

     Don't skip through the trampoline if we're popping a dummy frame.  */
  target_pc = SKIP_TRAMPOLINE_CODE (npc & ~0x3) & ~0x3;
  if (target_pc && !fsr[IPSW_REGNUM])
    {
      struct symtab_and_line sal;
      struct breakpoint *breakpoint;
      struct cleanup *old_chain;

      /* Set up our breakpoint.   Set it to be silent as the MI code
         for "return_command" will print the frame we returned to.  */
      sal = find_pc_line (target_pc, 0);
      sal.pc = target_pc;
      breakpoint = set_momentary_breakpoint (sal, null_frame_id, bp_finish);
      breakpoint->silent = 1;

      /* So we can clean things up.  */
      old_chain = make_cleanup_delete_breakpoint (breakpoint);

      /* Start up the inferior.  */
      clear_proceed_status ();
      proceed_to_finish = 1;
      proceed ((CORE_ADDR) -1, TARGET_SIGNAL_DEFAULT, 0);

      /* Perform our cleanups.  */
      do_cleanups (old_chain);
    }
  flush_cached_frames ();
}

/* After returning to a dummy on the stack, restore the instruction
   queue space registers. */

static int
restore_pc_queue (CORE_ADDR *fsr)
{
  CORE_ADDR pc = read_pc ();
  CORE_ADDR new_pc = read_memory_integer (fsr[PCOQ_HEAD_REGNUM],
					  TARGET_PTR_BIT / 8);
  struct target_waitstatus w;
  int insn_count;

  /* Advance past break instruction in the call dummy. */
  write_register (PCOQ_HEAD_REGNUM, pc + 4);
  write_register (PCOQ_TAIL_REGNUM, pc + 8);

  /* HPUX doesn't let us set the space registers or the space
     registers of the PC queue through ptrace. Boo, hiss.
     Conveniently, the call dummy has this sequence of instructions
     after the break:
     mtsp r21, sr0
     ble,n 0(sr0, r22)

     So, load up the registers and single step until we are in the
     right place. */

  write_register (21, read_memory_integer (fsr[PCSQ_HEAD_REGNUM],
					   DEPRECATED_REGISTER_SIZE));
  write_register (22, new_pc);

  for (insn_count = 0; insn_count < 3; insn_count++)
    {
      /* FIXME: What if the inferior gets a signal right now?  Want to
         merge this into wait_for_inferior (as a special kind of
         watchpoint?  By setting a breakpoint at the end?  Is there
         any other choice?  Is there *any* way to do this stuff with
         ptrace() or some equivalent?).  */
      resume (1, 0);
      target_wait (inferior_ptid, &w);

      if (w.kind == TARGET_WAITKIND_SIGNALLED)
	{
	  stop_signal = w.value.sig;
	  terminal_ours_for_output ();
	  printf_unfiltered ("\nProgram terminated with signal %s, %s.\n",
			     target_signal_to_name (stop_signal),
			     target_signal_to_string (stop_signal));
	  gdb_flush (gdb_stdout);
	  return 0;
	}
    }
  target_terminal_ours ();
  target_fetch_registers (-1);
  return 1;
}


#ifdef PA20W_CALLING_CONVENTIONS

/* This function pushes a stack frame with arguments as part of the
   inferior function calling mechanism.

   This is the version for the PA64, in which later arguments appear
   at higher addresses.  (The stack always grows towards higher
   addresses.)

   We simply allocate the appropriate amount of stack space and put
   arguments into their proper slots.  The call dummy code will copy
   arguments into registers as needed by the ABI.

   This ABI also requires that the caller provide an argument pointer
   to the callee, so we do that too.  */
   
CORE_ADDR
hppa_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		     int struct_return, CORE_ADDR struct_addr)
{
  /* array of arguments' offsets */
  int *offset = (int *) alloca (nargs * sizeof (int));

  /* array of arguments' lengths: real lengths in bytes, not aligned to
     word size */
  int *lengths = (int *) alloca (nargs * sizeof (int));

  /* The value of SP as it was passed into this function after
     aligning.  */
  CORE_ADDR orig_sp = DEPRECATED_STACK_ALIGN (sp);

  /* The number of stack bytes occupied by the current argument.  */
  int bytes_reserved;

  /* The total number of bytes reserved for the arguments.  */
  int cum_bytes_reserved = 0;

  /* Similarly, but aligned.  */
  int cum_bytes_aligned = 0;
  int i;

  /* Iterate over each argument provided by the user.  */
  for (i = 0; i < nargs; i++)
    {
      struct type *arg_type = VALUE_TYPE (args[i]);

      /* Integral scalar values smaller than a register are padded on
         the left.  We do this by promoting them to full-width,
         although the ABI says to pad them with garbage.  */
      if (is_integral_type (arg_type)
	  && TYPE_LENGTH (arg_type) < DEPRECATED_REGISTER_SIZE)
	{
	  args[i] = value_cast ((TYPE_UNSIGNED (arg_type)
				 ? builtin_type_unsigned_long
				 : builtin_type_long),
				args[i]);
	  arg_type = VALUE_TYPE (args[i]);
	}

      lengths[i] = TYPE_LENGTH (arg_type);

      /* Align the size of the argument to the word size for this
	 target.  */
      bytes_reserved = (lengths[i] + DEPRECATED_REGISTER_SIZE - 1) & -DEPRECATED_REGISTER_SIZE;

      offset[i] = cum_bytes_reserved;

      /* Aggregates larger than eight bytes (the only types larger
         than eight bytes we have) are aligned on a 16-byte boundary,
         possibly padded on the right with garbage.  This may leave an
         empty word on the stack, and thus an unused register, as per
         the ABI.  */
      if (bytes_reserved > 8)
	{
	  /* Round up the offset to a multiple of two slots.  */
	  int new_offset = ((offset[i] + 2*DEPRECATED_REGISTER_SIZE-1)
			    & -(2*DEPRECATED_REGISTER_SIZE));

	  /* Note the space we've wasted, if any.  */
	  bytes_reserved += new_offset - offset[i];
	  offset[i] = new_offset;
	}

      cum_bytes_reserved += bytes_reserved;
    }

  /* CUM_BYTES_RESERVED already accounts for all the arguments
     passed by the user.  However, the ABIs mandate minimum stack space
     allocations for outgoing arguments.

     The ABIs also mandate minimum stack alignments which we must
     preserve.  */
  cum_bytes_aligned = DEPRECATED_STACK_ALIGN (cum_bytes_reserved);
  sp += max (cum_bytes_aligned, REG_PARM_STACK_SPACE);

  /* Now write each of the args at the proper offset down the stack.  */
  for (i = 0; i < nargs; i++)
    write_memory (orig_sp + offset[i], VALUE_CONTENTS (args[i]), lengths[i]);

  /* If a structure has to be returned, set up register 28 to hold its
     address */
  if (struct_return)
    write_register (28, struct_addr);

  /* For the PA64 we must pass a pointer to the outgoing argument list.
     The ABI mandates that the pointer should point to the first byte of
     storage beyond the register flushback area.

     However, the call dummy expects the outgoing argument pointer to
     be passed in register %r4.  */
  write_register (4, orig_sp + REG_PARM_STACK_SPACE);

  /* ?!? This needs further work.  We need to set up the global data
     pointer for this procedure.  This assumes the same global pointer
     for every procedure.   The call dummy expects the dp value to
     be passed in register %r6.  */
  write_register (6, read_register (27));
  
  /* The stack will have 64 bytes of additional space for a frame marker.  */
  return sp + 64;
}

#else

/* This function pushes a stack frame with arguments as part of the
   inferior function calling mechanism.

   This is the version of the function for the 32-bit PA machines, in
   which later arguments appear at lower addresses.  (The stack always
   grows towards higher addresses.)

   We simply allocate the appropriate amount of stack space and put
   arguments into their proper slots.  The call dummy code will copy
   arguments into registers as needed by the ABI. */
   
CORE_ADDR
hppa_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		     int struct_return, CORE_ADDR struct_addr)
{
  /* array of arguments' offsets */
  int *offset = (int *) alloca (nargs * sizeof (int));

  /* array of arguments' lengths: real lengths in bytes, not aligned to
     word size */
  int *lengths = (int *) alloca (nargs * sizeof (int));

  /* The number of stack bytes occupied by the current argument.  */
  int bytes_reserved;

  /* The total number of bytes reserved for the arguments.  */
  int cum_bytes_reserved = 0;

  /* Similarly, but aligned.  */
  int cum_bytes_aligned = 0;
  int i;

  /* Iterate over each argument provided by the user.  */
  for (i = 0; i < nargs; i++)
    {
      lengths[i] = TYPE_LENGTH (VALUE_TYPE (args[i]));

      /* Align the size of the argument to the word size for this
	 target.  */
      bytes_reserved = (lengths[i] + DEPRECATED_REGISTER_SIZE - 1) & -DEPRECATED_REGISTER_SIZE;

      offset[i] = (cum_bytes_reserved
		   + (lengths[i] > 4 ? bytes_reserved : lengths[i]));

      /* If the argument is a double word argument, then it needs to be
	 double word aligned.  */
      if ((bytes_reserved == 2 * DEPRECATED_REGISTER_SIZE)
	  && (offset[i] % 2 * DEPRECATED_REGISTER_SIZE))
	{
	  int new_offset = 0;
	  /* BYTES_RESERVED is already aligned to the word, so we put
	     the argument at one word more down the stack.

	     This will leave one empty word on the stack, and one unused
	     register as mandated by the ABI.  */
	  new_offset = ((offset[i] + 2 * DEPRECATED_REGISTER_SIZE - 1)
			& -(2 * DEPRECATED_REGISTER_SIZE));
d798 7
a804 6
	  if ((new_offset - offset[i]) >= 2 * DEPRECATED_REGISTER_SIZE)
	    {
	      bytes_reserved += DEPRECATED_REGISTER_SIZE;
	      offset[i] += DEPRECATED_REGISTER_SIZE;
	    }
	}
d806 5
a810 26
      cum_bytes_reserved += bytes_reserved;

    }

  /* CUM_BYTES_RESERVED already accounts for all the arguments passed
     by the user.  However, the ABI mandates minimum stack space
     allocations for outgoing arguments.

     The ABI also mandates minimum stack alignments which we must
     preserve.  */
  cum_bytes_aligned = DEPRECATED_STACK_ALIGN (cum_bytes_reserved);
  sp += max (cum_bytes_aligned, REG_PARM_STACK_SPACE);

  /* Now write each of the args at the proper offset down the stack.
     ?!? We need to promote values to a full register instead of skipping
     words in the stack.  */
  for (i = 0; i < nargs; i++)
    write_memory (sp - offset[i], VALUE_CONTENTS (args[i]), lengths[i]);

  /* If a structure has to be returned, set up register 28 to hold its
     address */
  if (struct_return)
    write_register (28, struct_addr);

  /* The stack will have 32 bytes of additional space for a frame marker.  */
  return sp + 32;
a812 2
#endif

a1162 394
/* Insert the specified number of args and function address
   into a call sequence of the above form stored at DUMMYNAME.

   On the hppa we need to call the stack dummy through $$dyncall.
   Therefore our version of DEPRECATED_FIX_CALL_DUMMY takes an extra
   argument, real_pc, which is the location where gdb should start up
   the inferior to do the function call.

   This has to work across several versions of hpux, bsd, osf1.  It has to
   work regardless of what compiler was used to build the inferior program.
   It should work regardless of whether or not end.o is available.  It has
   to work even if gdb can not call into the dynamic loader in the inferior
   to query it for symbol names and addresses.

   Yes, all those cases should work.  Luckily code exists to handle most
   of them.  The complexity is in selecting exactly what scheme should
   be used to perform the inferior call.

   At the current time this routine is known not to handle cases where
   the program was linked with HP's compiler without including end.o.

   Please contact Jeff Law (law@@cygnus.com) before changing this code.  */

CORE_ADDR
hppa_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs,
		     struct value **args, struct type *type, int gcc_p)
{
  CORE_ADDR dyncall_addr;
  struct minimal_symbol *msymbol;
  struct minimal_symbol *trampoline;
  int flags = read_register (FLAGS_REGNUM);
  struct unwind_table_entry *u = NULL;
  CORE_ADDR new_stub = 0;
  CORE_ADDR solib_handle = 0;

  /* Nonzero if we will use GCC's PLT call routine.  This routine must be
     passed an import stub, not a PLABEL.  It is also necessary to set %r19
     (the PIC register) before performing the call.

     If zero, then we are using __d_plt_call (HP's PLT call routine) or we
     are calling the target directly.  When using __d_plt_call we want to
     use a PLABEL instead of an import stub.  */
  int using_gcc_plt_call = 1;

#ifdef GDB_TARGET_IS_HPPA_20W
  /* We currently use completely different code for the PA2.0W inferior
     function call sequences.  This needs to be cleaned up.  */
  {
    CORE_ADDR pcsqh, pcsqt, pcoqh, pcoqt, sr5;
    struct target_waitstatus w;
    int inst1, inst2;
    char buf[4];
    int status;
    struct objfile *objfile;

    /* We can not modify the PC space queues directly, so we start
       up the inferior and execute a couple instructions to set the
       space queues so that they point to the call dummy in the stack.  */
    pcsqh = read_register (PCSQ_HEAD_REGNUM);
    sr5 = read_register (SR5_REGNUM);
    if (1)
      {
        pcoqh = read_register (PCOQ_HEAD_REGNUM);
        pcoqt = read_register (PCOQ_TAIL_REGNUM);
        if (target_read_memory (pcoqh, buf, 4) != 0)
          error ("Couldn't modify space queue\n");
        inst1 = extract_unsigned_integer (buf, 4);

        if (target_read_memory (pcoqt, buf, 4) != 0)
          error ("Couldn't modify space queue\n");
        inst2 = extract_unsigned_integer (buf, 4);

        /* BVE (r1) */
        *((int *) buf) = 0xe820d000;
        if (target_write_memory (pcoqh, buf, 4) != 0)
          error ("Couldn't modify space queue\n");

        /* NOP */
        *((int *) buf) = 0x08000240;
        if (target_write_memory (pcoqt, buf, 4) != 0)
          {
            *((int *) buf) = inst1;
            target_write_memory (pcoqh, buf, 4);
            error ("Couldn't modify space queue\n");
          }

        write_register (1, pc);

        /* Single step twice, the BVE instruction will set the space queue
	   such that it points to the PC value written immediately above
	   (ie the call dummy).  */
        resume (1, 0);
        target_wait (inferior_ptid, &w);
        resume (1, 0);
        target_wait (inferior_ptid, &w);

	/* Restore the two instructions at the old PC locations.  */
        *((int *) buf) = inst1;
        target_write_memory (pcoqh, buf, 4);
        *((int *) buf) = inst2;
        target_write_memory (pcoqt, buf, 4);
      }

    /* The call dummy wants the ultimate destination address initially
       in register %r5.  */
    write_register (5, fun);

    /* We need to see if this objfile has a different DP value than our
       own (it could be a shared library for example).  */
    ALL_OBJFILES (objfile)
      {
	struct obj_section *s;
	obj_private_data_t *obj_private;

	/* See if FUN is in any section within this shared library.  */
	for (s = objfile->sections; s < objfile->sections_end; s++)
	  if (s->addr <= fun && fun < s->endaddr)
	    break;

        if (s >= objfile->sections_end)
	  continue;

	obj_private = (obj_private_data_t *) objfile->obj_private;
	
	/* The DP value may be different for each objfile.  But within an
	   objfile each function uses the same dp value.  Thus we do not need
	   to grope around the opd section looking for dp values.

	   ?!? This is not strictly correct since we may be in a shared library
	   and want to call back into the main program.  To make that case
	   work correctly we need to set obj_private->dp for the main program's
	   objfile, then remove this conditional.  */
	if (obj_private->dp)
	  write_register (27, obj_private->dp);
	break;
      }
    return pc;
  }
#endif

#ifndef GDB_TARGET_IS_HPPA_20W
  /* Prefer __gcc_plt_call over the HP supplied routine because
     __gcc_plt_call works for any number of arguments.  */
  trampoline = NULL;
  if (lookup_minimal_symbol ("__gcc_plt_call", NULL, NULL) == NULL)
    using_gcc_plt_call = 0;

  msymbol = lookup_minimal_symbol ("$$dyncall", NULL, NULL);
  if (msymbol == NULL)
    error ("Can't find an address for $$dyncall trampoline");

  dyncall_addr = SYMBOL_VALUE_ADDRESS (msymbol);

  /* FUN could be a procedure label, in which case we have to get
     its real address and the value of its GOT/DP if we plan to
     call the routine via gcc_plt_call.  */
  if ((fun & 0x2) && using_gcc_plt_call)
    {
      /* Get the GOT/DP value for the target function.  It's
         at *(fun+4).  Note the call dummy is *NOT* allowed to
         trash %r19 before calling the target function.  */
      write_register (19, read_memory_integer ((fun & ~0x3) + 4,
					       DEPRECATED_REGISTER_SIZE));

      /* Now get the real address for the function we are calling, it's
         at *fun.  */
      fun = (CORE_ADDR) read_memory_integer (fun & ~0x3,
					     TARGET_PTR_BIT / 8);
    }
  else
    {

#ifndef GDB_TARGET_IS_PA_ELF
      /* FUN could be an export stub, the real address of a function, or
         a PLABEL.  When using gcc's PLT call routine we must call an import
         stub rather than the export stub or real function for lazy binding
         to work correctly

         If we are using the gcc PLT call routine, then we need to
         get the import stub for the target function.  */
      if (using_gcc_plt_call && som_solib_get_got_by_pc (fun))
	{
	  struct objfile *objfile;
	  struct minimal_symbol *funsymbol, *stub_symbol;
	  CORE_ADDR newfun = 0;

	  funsymbol = lookup_minimal_symbol_by_pc (fun);
	  if (!funsymbol)
	    error ("Unable to find minimal symbol for target function.\n");

	  /* Search all the object files for an import symbol with the
	     right name. */
	  ALL_OBJFILES (objfile)
	  {
	    stub_symbol
	      = lookup_minimal_symbol_solib_trampoline
	      (DEPRECATED_SYMBOL_NAME (funsymbol), objfile);

	    if (!stub_symbol)
	      stub_symbol = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (funsymbol),
						   NULL, objfile);

	    /* Found a symbol with the right name.  */
	    if (stub_symbol)
	      {
		struct unwind_table_entry *u;
		/* It must be a shared library trampoline.  */
		if (MSYMBOL_TYPE (stub_symbol) != mst_solib_trampoline)
		  continue;

		/* It must also be an import stub.  */
		u = find_unwind_entry (SYMBOL_VALUE (stub_symbol));
		if (u == NULL
		    || (u->stub_unwind.stub_type != IMPORT
#ifdef GDB_NATIVE_HPUX_11
			/* Sigh.  The hpux 10.20 dynamic linker will blow
			   chunks if we perform a call to an unbound function
			   via the IMPORT_SHLIB stub.  The hpux 11.00 dynamic
			   linker will blow chunks if we do not call the
			   unbound function via the IMPORT_SHLIB stub.

			   We currently have no way to select bevahior on just
			   the target.  However, we only support HPUX/SOM in
			   native mode.  So we conditinalize on a native
			   #ifdef.  Ugly.  Ugly.  Ugly  */
			&& u->stub_unwind.stub_type != IMPORT_SHLIB
#endif
			))
		  continue;

		/* OK.  Looks like the correct import stub.  */
		newfun = SYMBOL_VALUE (stub_symbol);
		fun = newfun;

		/* If we found an IMPORT stub, then we want to stop
		   searching now.  If we found an IMPORT_SHLIB, we want
		   to continue the search in the hopes that we will find
		   an IMPORT stub.  */
		if (u->stub_unwind.stub_type == IMPORT)
		  break;
	      }
	  }

	  /* Ouch.  We did not find an import stub.  Make an attempt to
	     do the right thing instead of just croaking.  Most of the
	     time this will actually work.  */
	  if (newfun == 0)
	    write_register (19, som_solib_get_got_by_pc (fun));

	  u = find_unwind_entry (fun);
	  if (u
	      && (u->stub_unwind.stub_type == IMPORT
		  || u->stub_unwind.stub_type == IMPORT_SHLIB))
	    trampoline = lookup_minimal_symbol ("__gcc_plt_call", NULL, NULL);

	  /* If we found the import stub in the shared library, then we have
	     to set %r19 before we call the stub.  */
	  if (u && u->stub_unwind.stub_type == IMPORT_SHLIB)
	    write_register (19, som_solib_get_got_by_pc (fun));
	}
#endif
    }

  /* If we are calling into another load module then have sr4export call the
     magic __d_plt_call routine which is linked in from end.o.

     You can't use _sr4export to make the call as the value in sp-24 will get
     fried and you end up returning to the wrong location.  You can't call the
     target as the code to bind the PLT entry to a function can't return to a
     stack address.

     Also, query the dynamic linker in the inferior to provide a suitable
     PLABEL for the target function.  */
  if (!using_gcc_plt_call)
    {
      CORE_ADDR new_fun;

      /* Get a handle for the shared library containing FUN.  Given the
         handle we can query the shared library for a PLABEL.  */
      solib_handle = som_solib_get_solib_by_pc (fun);

      if (solib_handle)
	{
	  struct minimal_symbol *fmsymbol = lookup_minimal_symbol_by_pc (fun);

	  trampoline = lookup_minimal_symbol ("__d_plt_call", NULL, NULL);

	  if (trampoline == NULL)
	    {
	      error ("Can't find an address for __d_plt_call or __gcc_plt_call trampoline\nSuggest linking executable with -g or compiling with gcc.");
	    }

	  /* This is where sr4export will jump to.  */
	  new_fun = SYMBOL_VALUE_ADDRESS (trampoline);

	  /* If the function is in a shared library, then call __d_shl_get to
	     get a PLABEL for the target function.  */
	  new_stub = find_stub_with_shl_get (fmsymbol, solib_handle);

	  if (new_stub == 0)
	    error ("Can't find an import stub for %s", DEPRECATED_SYMBOL_NAME (fmsymbol));

	  /* We have to store the address of the stub in __shlib_funcptr.  */
	  msymbol = lookup_minimal_symbol ("__shlib_funcptr", NULL,
					   (struct objfile *) NULL);

	  if (msymbol == NULL)
	    error ("Can't find an address for __shlib_funcptr");
	  target_write_memory (SYMBOL_VALUE_ADDRESS (msymbol),
			       (char *) &new_stub, 4);

	  /* We want sr4export to call __d_plt_call, so we claim it is
	     the final target.  Clear trampoline.  */
	  fun = new_fun;
	  trampoline = NULL;
	}
    }

  /* Store upper 21 bits of function address into ldil.  fun will either be
     the final target (most cases) or __d_plt_call when calling into a shared
     library and __gcc_plt_call is not available.  */
  store_unsigned_integer
    (&dummy[FUNC_LDIL_OFFSET],
     INSTRUCTION_SIZE,
     deposit_21 (fun >> 11,
		 extract_unsigned_integer (&dummy[FUNC_LDIL_OFFSET],
					   INSTRUCTION_SIZE)));

  /* Store lower 11 bits of function address into ldo */
  store_unsigned_integer
    (&dummy[FUNC_LDO_OFFSET],
     INSTRUCTION_SIZE,
     deposit_14 (fun & MASK_11,
		 extract_unsigned_integer (&dummy[FUNC_LDO_OFFSET],
					   INSTRUCTION_SIZE)));
#ifdef SR4EXPORT_LDIL_OFFSET

  {
    CORE_ADDR trampoline_addr;

    /* We may still need sr4export's address too.  */

    if (trampoline == NULL)
      {
	msymbol = lookup_minimal_symbol ("_sr4export", NULL, NULL);
	if (msymbol == NULL)
	  error ("Can't find an address for _sr4export trampoline");

	trampoline_addr = SYMBOL_VALUE_ADDRESS (msymbol);
      }
    else
      trampoline_addr = SYMBOL_VALUE_ADDRESS (trampoline);


    /* Store upper 21 bits of trampoline's address into ldil */
    store_unsigned_integer
      (&dummy[SR4EXPORT_LDIL_OFFSET],
       INSTRUCTION_SIZE,
       deposit_21 (trampoline_addr >> 11,
		   extract_unsigned_integer (&dummy[SR4EXPORT_LDIL_OFFSET],
					     INSTRUCTION_SIZE)));

    /* Store lower 11 bits of trampoline's address into ldo */
    store_unsigned_integer
      (&dummy[SR4EXPORT_LDO_OFFSET],
       INSTRUCTION_SIZE,
       deposit_14 (trampoline_addr & MASK_11,
		   extract_unsigned_integer (&dummy[SR4EXPORT_LDO_OFFSET],
					     INSTRUCTION_SIZE)));
  }
#endif

  write_register (22, pc);

  /* If we are in a syscall, then we should call the stack dummy
     directly.  $$dyncall is not needed as the kernel sets up the
     space id registers properly based on the value in %r31.  In
     fact calling $$dyncall will not work because the value in %r22
     will be clobbered on the syscall exit path. 

     Similarly if the current PC is in a shared library.  Note however,
     this scheme won't work if the shared library isn't mapped into
     the same space as the stack.  */
  if (flags & 2)
    return pc;
#ifndef GDB_TARGET_IS_PA_ELF
  else if (som_solib_get_got_by_pc (hppa_target_read_pc (inferior_ptid)))
    return pc;
#endif
  else
    return dyncall_addr;
#endif
}

a2590 256
/* Put here the code to store, into the SAVED_REGS, the addresses of
   the saved registers of frame described by FRAME_INFO.  This
   includes special registers such as pc and fp saved in special ways
   in the stack frame.  sp is even more special: the address we return
   for it IS the sp for the next frame.  */

void
hppa_frame_find_saved_regs (struct frame_info *frame_info,
			    CORE_ADDR frame_saved_regs[])
{
  CORE_ADDR pc;
  struct unwind_table_entry *u;
  unsigned long inst, stack_remaining, save_gr, save_fr, save_rp, save_sp;
  int status, i, reg;
  char buf[4];
  int fp_loc = -1;
  int final_iteration;

  /* Zero out everything.  */
  memset (frame_saved_regs, '\0', SIZEOF_FRAME_SAVED_REGS);

  /* Call dummy frames always look the same, so there's no need to
     examine the dummy code to determine locations of saved registers;
     instead, let find_dummy_frame_regs fill in the correct offsets
     for the saved registers.  */
  if ((get_frame_pc (frame_info) >= get_frame_base (frame_info)
       && (get_frame_pc (frame_info)
	   <= (get_frame_base (frame_info)
	       /* A call dummy is sized in words, but it is actually a
		  series of instructions.  Account for that scaling
		  factor.  */
	       + ((DEPRECATED_REGISTER_SIZE / INSTRUCTION_SIZE)
		  * DEPRECATED_CALL_DUMMY_LENGTH)
	       /* Similarly we have to account for 64bit wide register
		  saves.  */
	       + (32 * DEPRECATED_REGISTER_SIZE)
	       /* We always consider FP regs 8 bytes long.  */
	       + (NUM_REGS - FP0_REGNUM) * 8
	       /* Similarly we have to account for 64bit wide register
		  saves.  */
	       + (6 * DEPRECATED_REGISTER_SIZE)))))
    find_dummy_frame_regs (frame_info, frame_saved_regs);

  /* Interrupt handlers are special too.  They lay out the register
     state in the exact same order as the register numbers in GDB.  */
  if (pc_in_interrupt_handler (get_frame_pc (frame_info)))
    {
      for (i = 0; i < NUM_REGS; i++)
	{
	  /* SP is a little special.  */
	  if (i == SP_REGNUM)
	    frame_saved_regs[SP_REGNUM]
	      = read_memory_integer (get_frame_base (frame_info) + SP_REGNUM * 4,
				     TARGET_PTR_BIT / 8);
	  else
	    frame_saved_regs[i] = get_frame_base (frame_info) + i * 4;
	}
      return;
    }

#ifdef FRAME_FIND_SAVED_REGS_IN_SIGTRAMP
  /* Handle signal handler callers.  */
  if ((get_frame_type (frame_info) == SIGTRAMP_FRAME))
    {
      FRAME_FIND_SAVED_REGS_IN_SIGTRAMP (frame_info, frame_saved_regs);
      return;
    }
#endif

  /* Get the starting address of the function referred to by the PC
     saved in frame.  */
  pc = get_frame_func (frame_info);

  /* Yow! */
  u = find_unwind_entry (pc);
  if (!u)
    return;

  /* This is how much of a frame adjustment we need to account for.  */
  stack_remaining = u->Total_frame_size << 3;

  /* Magic register saves we want to know about.  */
  save_rp = u->Save_RP;
  save_sp = u->Save_SP;

  /* Turn the Entry_GR field into a bitmask.  */
  save_gr = 0;
  for (i = 3; i < u->Entry_GR + 3; i++)
    {
      /* Frame pointer gets saved into a special location.  */
      if (u->Save_SP && i == DEPRECATED_FP_REGNUM)
	continue;

      save_gr |= (1 << i);
    }

  /* Turn the Entry_FR field into a bitmask too.  */
  save_fr = 0;
  for (i = 12; i < u->Entry_FR + 12; i++)
    save_fr |= (1 << i);

  /* The frame always represents the value of %sp at entry to the
     current function (and is thus equivalent to the "saved" stack
     pointer.  */
  frame_saved_regs[SP_REGNUM] = get_frame_base (frame_info);

  /* Loop until we find everything of interest or hit a branch.

     For unoptimized GCC code and for any HP CC code this will never ever
     examine any user instructions.

     For optimized GCC code we're faced with problems.  GCC will schedule
     its prologue and make prologue instructions available for delay slot
     filling.  The end result is user code gets mixed in with the prologue
     and a prologue instruction may be in the delay slot of the first branch
     or call.

     Some unexpected things are expected with debugging optimized code, so
     we allow this routine to walk past user instructions in optimized
     GCC code.  */
  final_iteration = 0;
  while ((save_gr || save_fr || save_rp || save_sp || stack_remaining > 0)
	 && pc <= get_frame_pc (frame_info))
    {
      status = target_read_memory (pc, buf, 4);
      inst = extract_unsigned_integer (buf, 4);

      /* Yow! */
      if (status != 0)
	return;

      /* Note the interesting effects of this instruction.  */
      stack_remaining -= prologue_inst_adjust_sp (inst);

      /* There are limited ways to store the return pointer into the
	 stack.  */
      if (inst == 0x6bc23fd9) /* stw rp,-0x14(sr0,sp) */
	{
	  save_rp = 0;
	  frame_saved_regs[RP_REGNUM] = get_frame_base (frame_info) - 20;
	}
      else if (inst == 0x0fc212c1) /* std rp,-0x10(sr0,sp) */
	{
	  save_rp = 0;
	  frame_saved_regs[RP_REGNUM] = get_frame_base (frame_info) - 16;
	}

      /* Note if we saved SP into the stack.  This also happens to indicate
	 the location of the saved frame pointer.  */
      if (   (inst & 0xffffc000) == 0x6fc10000  /* stw,ma r1,N(sr0,sp) */
          || (inst & 0xffffc00c) == 0x73c10008) /* std,ma r1,N(sr0,sp) */
	{
	  frame_saved_regs[DEPRECATED_FP_REGNUM] = get_frame_base (frame_info);
	  save_sp = 0;
	}

      /* Account for general and floating-point register saves.  */
      reg = inst_saves_gr (inst);
      if (reg >= 3 && reg <= 18
	  && (!u->Save_SP || reg != DEPRECATED_FP_REGNUM))
	{
	  save_gr &= ~(1 << reg);

	  /* stwm with a positive displacement is a *post modify*.  */
	  if ((inst >> 26) == 0x1b
	      && extract_14 (inst) >= 0)
	    frame_saved_regs[reg] = get_frame_base (frame_info);
	  /* A std has explicit post_modify forms.  */
	  else if ((inst & 0xfc00000c) == 0x70000008)
	    frame_saved_regs[reg] = get_frame_base (frame_info);
	  else
	    {
	      CORE_ADDR offset;

	      if ((inst >> 26) == 0x1c)
		offset = (inst & 0x1 ? -1 << 13 : 0) | (((inst >> 4) & 0x3ff) << 3);
	      else if ((inst >> 26) == 0x03)
		offset = low_sign_extend (inst & 0x1f, 5);
	      else
		offset = extract_14 (inst);

	      /* Handle code with and without frame pointers.  */
	      if (u->Save_SP)
		frame_saved_regs[reg]
		  = get_frame_base (frame_info) + offset;
	      else
		frame_saved_regs[reg]
		  = (get_frame_base (frame_info) + (u->Total_frame_size << 3)
		     + offset);
	    }
	}


      /* GCC handles callee saved FP regs a little differently.  

         It emits an instruction to put the value of the start of
         the FP store area into %r1.  It then uses fstds,ma with
         a basereg of %r1 for the stores.

         HP CC emits them at the current stack pointer modifying
         the stack pointer as it stores each register.  */

      /* ldo X(%r3),%r1 or ldo X(%r30),%r1.  */
      if ((inst & 0xffffc000) == 0x34610000
	  || (inst & 0xffffc000) == 0x37c10000)
	fp_loc = extract_14 (inst);

      reg = inst_saves_fr (inst);
      if (reg >= 12 && reg <= 21)
	{
	  /* Note +4 braindamage below is necessary because the FP status
	     registers are internally 8 registers rather than the expected
	     4 registers.  */
	  save_fr &= ~(1 << reg);
	  if (fp_loc == -1)
	    {
	      /* 1st HP CC FP register store.  After this instruction
	         we've set enough state that the GCC and HPCC code are
	         both handled in the same manner.  */
	      frame_saved_regs[reg + FP4_REGNUM + 4] = get_frame_base (frame_info);
	      fp_loc = 8;
	    }
	  else
	    {
	      frame_saved_regs[reg + FP0_REGNUM + 4]
		= get_frame_base (frame_info) + fp_loc;
	      fp_loc += 8;
	    }
	}

      /* Quit if we hit any kind of branch the previous iteration. */
      if (final_iteration)
	break;

      /* We want to look precisely one instruction beyond the branch
	 if we have not found everything yet.  */
      if (is_branch (inst))
	final_iteration = 1;

      /* Bump the PC.  */
      pc += 4;
    }
}

/* XXX - deprecated.  This is a compatibility function for targets
   that do not yet implement DEPRECATED_FRAME_INIT_SAVED_REGS.  */
/* Find the addresses in which registers are saved in FRAME.  */

static void
hppa_frame_init_saved_regs (struct frame_info *frame)
{
  if (deprecated_get_frame_saved_regs (frame) == NULL)
    frame_saved_regs_zalloc (frame);
  hppa_frame_find_saved_regs (frame, deprecated_get_frame_saved_regs (frame));
}

a3461 56
/* Same as hppa32_store_return_value(), but for the PA64 ABI.  */

void
hppa64_store_return_value (struct type *type, char *valbuf)
{
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    deprecated_write_register_bytes
      (DEPRECATED_REGISTER_BYTE (FP4_REGNUM)
        + DEPRECATED_REGISTER_SIZE - TYPE_LENGTH (type),
       valbuf, TYPE_LENGTH (type));
  else if (is_integral_type(type))
    deprecated_write_register_bytes
      (DEPRECATED_REGISTER_BYTE (28)
        + DEPRECATED_REGISTER_SIZE - TYPE_LENGTH (type),
       valbuf, TYPE_LENGTH (type));
  else if (TYPE_LENGTH (type) <= 8)
    deprecated_write_register_bytes
      (DEPRECATED_REGISTER_BYTE (28),valbuf, TYPE_LENGTH (type));
  else if (TYPE_LENGTH (type) <= 16)
    {
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (28),valbuf, 8);
      deprecated_write_register_bytes
        (DEPRECATED_REGISTER_BYTE (29), valbuf + 8, TYPE_LENGTH (type) - 8);
    }
}

/* Same as hppa32_extract_return_value but for the PA64 ABI case.  */

void
hppa64_extract_return_value (struct type *type, char *regbuf, char *valbuf)
{
  /* RM: Floats are returned in FR4R, doubles in FR4.
         Integral values are in r28, padded on the left.
         Aggregates less that 65 bits are in r28, right padded.
         Aggregates upto 128 bits are in r28 and r29, right padded.  */ 
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    memcpy (valbuf,
            regbuf + DEPRECATED_REGISTER_BYTE (FP4_REGNUM)
             + DEPRECATED_REGISTER_SIZE - TYPE_LENGTH (type),
            TYPE_LENGTH (type));
  else if (is_integral_type(type))
    memcpy (valbuf,
            regbuf + DEPRECATED_REGISTER_BYTE (28)
             + DEPRECATED_REGISTER_SIZE - TYPE_LENGTH (type),
            TYPE_LENGTH (type));
  else if (TYPE_LENGTH (type) <= 8)
    memcpy (valbuf, regbuf + DEPRECATED_REGISTER_BYTE (28),
	    TYPE_LENGTH (type));
  else if (TYPE_LENGTH (type) <= 16)
    {
      memcpy (valbuf, regbuf + DEPRECATED_REGISTER_BYTE (28), 8);
      memcpy (valbuf + 8, regbuf + DEPRECATED_REGISTER_BYTE (29),
	      TYPE_LENGTH (type) - 8);
    }
}

a3476 7
CORE_ADDR
hppa64_stack_align (CORE_ADDR sp)
{
  /* The PA64 ABI mandates a 16 byte stack alignment.  */
  return ((sp % 16) ? (sp + 15) & -16 : sp);
}

a3558 8
/* Store the address of the place in which to copy the structure the
   subroutine will return.  This is called from call_function.  */

void
hppa_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  write_register (28, addr);
}
@


1.131
log
@2004-03-07  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c: Replace PC_REGNUM with PCOQ_HEAD_REGNUM.
	(hppa64_return_value, hppa64_push_dummy_call): Rewrite.
	(hppa_gdbarch_init): Do not set PC_REGNUM.
@
text
@d5810 2
a5811 19
      if (0)
	{
	  set_gdbarch_push_dummy_call (gdbarch, hppa64_push_dummy_call);
	  set_gdbarch_frame_align (gdbarch, hppa64_frame_align);
	  break;
	}
      else
	{
	  set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, hppa64_call_dummy_breakpoint_offset);
	  set_gdbarch_deprecated_call_dummy_length (gdbarch, hppa64_call_dummy_length);
	  set_gdbarch_deprecated_stack_align (gdbarch, hppa64_stack_align);
	  break;
	  set_gdbarch_deprecated_push_dummy_frame (gdbarch, hppa_push_dummy_frame);
	  /* set_gdbarch_deprecated_fix_call_dummy (gdbarch, hppa_fix_call_dummy); */
	  set_gdbarch_deprecated_push_arguments (gdbarch, hppa_push_arguments);
	  set_gdbarch_deprecated_use_generic_dummy_frames (gdbarch, 0);
	  set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_on_stack);
	  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
	}
d5813 2
d5824 1
a5824 10
      if (0)
	set_gdbarch_return_value (gdbarch, hppa64_return_value);
      else
	{
	  set_gdbarch_deprecated_extract_return_value (gdbarch, hppa64_extract_return_value);
	  set_gdbarch_use_struct_convention (gdbarch, hppa64_use_struct_convention);
	  set_gdbarch_deprecated_store_return_value (gdbarch, hppa64_store_return_value);
	  set_gdbarch_deprecated_store_struct_return (gdbarch, hppa_store_struct_return);
	}
      break;
d5830 4
a5833 22
  switch (tdep->bytes_per_address)
    {
    case 4:
      set_gdbarch_unwind_dummy_id (gdbarch, hppa_unwind_dummy_id);
      set_gdbarch_unwind_pc (gdbarch, hppa_unwind_pc);
      frame_unwind_append_sniffer (gdbarch, hppa_frame_unwind_sniffer);
      frame_base_append_sniffer (gdbarch, hppa_frame_base_sniffer);
      break;
    case 8:
      set_gdbarch_deprecated_saved_pc_after_call (gdbarch, hppa_saved_pc_after_call);
      set_gdbarch_deprecated_init_frame_pc (gdbarch, deprecated_init_frame_pc_default);
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, hppa_frame_init_saved_regs);
      set_gdbarch_deprecated_init_extra_frame_info (gdbarch, hppa_init_extra_frame_info);
      set_gdbarch_deprecated_frame_chain (gdbarch, hppa_frame_chain);
      set_gdbarch_deprecated_frame_chain_valid (gdbarch, hppa_frame_chain_valid);
      set_gdbarch_deprecated_frameless_function_invocation (gdbarch, hppa_frameless_function_invocation);
      set_gdbarch_deprecated_frame_saved_pc (gdbarch, hppa_frame_saved_pc);
      set_gdbarch_deprecated_pop_frame (gdbarch, hppa_pop_frame);
      break;
    default:
      internal_error (__FILE__, __LINE__, "bad switch");
    }
@


1.130
log
@        * hppa-tdep.c (hppa_frame_cache): Avoid undefined return value.
@
text
@d306 2
a307 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
d337 1
a337 1
	  int part = (TYPE_LENGTH (type) - b - 1) % 8 + 1;
d339 1
a339 1
	    regcache_cooked_read_part (regcache, 28, 0, part,
d342 1
a342 1
	    regcache_cooked_write_part (regcache, 28, 0, part,
d345 1
a345 1
  return RETURN_VALUE_REGISTER_CONVENTION;
d1141 1
a1141 1
    return read_memory_integer (get_frame_base (frame) + PC_REGNUM * 4,
d2296 2
a2297 2
  /* Array of arguments' offsets.  */
  int *offset = (int *) alloca (nargs * sizeof (int));
d2299 5
a2303 3
  /* Array of arguments' lengths: real lengths in bytes, not aligned
     to word size.  */
  int *lengths = (int *) alloca (nargs * sizeof (int));
d2305 3
a2307 2
  /* The value of SP as it was passed into this function.  */
  CORE_ADDR orig_sp = sp;
d2309 4
a2312 12
  /* The number of stack bytes occupied by the current argument.  */
  int bytes_reserved;

  /* The total number of bytes reserved for the arguments.  */
  int cum_bytes_reserved = 0;

  /* Similarly, but aligned.  */
  int cum_bytes_aligned = 0;
  int i;

  /* Iterate over each argument provided by the user.  */
  for (i = 0; i < nargs; i++)
d2314 4
a2317 7
      struct type *arg_type = VALUE_TYPE (args[i]);

      /* Integral scalar values smaller than a register are padded on
         the left.  We do this by promoting them to full-width,
         although the ABI says to pad them with garbage.  */
      if (is_integral_type (arg_type)
	  && TYPE_LENGTH (arg_type) < DEPRECATED_REGISTER_SIZE)
d2319 52
a2370 5
	  args[i] = value_cast ((TYPE_UNSIGNED (arg_type)
				 ? builtin_type_unsigned_long
				 : builtin_type_long),
				args[i]);
	  arg_type = VALUE_TYPE (args[i]);
d2372 2
a2373 15

      lengths[i] = TYPE_LENGTH (arg_type);

      /* Align the size of the argument to the word size for this
	 target.  */
      bytes_reserved = (lengths[i] + DEPRECATED_REGISTER_SIZE - 1) & -DEPRECATED_REGISTER_SIZE;

      offset[i] = cum_bytes_reserved;

      /* Aggregates larger than eight bytes (the only types larger
         than eight bytes we have) are aligned on a 16-byte boundary,
         possibly padded on the right with garbage.  This may leave an
         empty word on the stack, and thus an unused register, as per
         the ABI.  */
      if (bytes_reserved > 8)
d2375 8
a2382 7
	  /* Round up the offset to a multiple of two slots.  */
	  int new_offset = ((offset[i] + 2*DEPRECATED_REGISTER_SIZE-1)
			    & -(2*DEPRECATED_REGISTER_SIZE));

	  /* Note the space we've wasted, if any.  */
	  bytes_reserved += new_offset - offset[i];
	  offset[i] = new_offset;
a2383 2

      cum_bytes_reserved += bytes_reserved;
a2385 14
  /* CUM_BYTES_RESERVED already accounts for all the arguments passed
     by the user.  However, the ABIs mandate minimum stack space
     allocations for outgoing arguments.

     The ABIs also mandate minimum stack alignments which we must
     preserve.  */
  cum_bytes_aligned = align_up (cum_bytes_reserved, 16);
  sp += max (cum_bytes_aligned, REG_PARM_STACK_SPACE);

  /* Now write each of the args at the proper offset down the
     stack.  */
  for (i = 0; i < nargs; i++)
    write_memory (orig_sp + offset[i], VALUE_CONTENTS (args[i]), lengths[i]);

a2390 14
  /* For the PA64 we must pass a pointer to the outgoing argument
     list.  The ABI mandates that the pointer should point to the
     first byte of storage beyond the register flushback area.

     However, the call dummy expects the outgoing argument pointer to
     be passed in register %r4.  */
  write_register (4, orig_sp + REG_PARM_STACK_SPACE);

  /* ?!? This needs further work.  We need to set up the global data
     pointer for this procedure.  This assumes the same global pointer
     for every procedure.  The call dummy expects the dp value to be
     passed in register %r6.  */
  write_register (6, read_register (27));
  
d2394 2
a2395 4
  /* The stack will have 64 bytes of additional space for a frame
     marker.  */
  return sp + 64;

d2945 1
a2945 1
  return read_register_pid (PC_REGNUM, ptid) & ~0x3;
d2964 1
a2964 1
  write_register_pid (PC_REGNUM, v, ptid);
d4907 1
a4907 1
  return frame_unwind_register_signed (next_frame, PC_REGNUM) & ~3;
a5777 1
  set_gdbarch_pc_regnum (gdbarch, PCOQ_HEAD_REGNUM);
@


1.129
log
@2004-02-27  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa_gdbarch_init): On 32-bit systems always use
	the new frame unwind code.
	(hppa_frame_cache): Use PCOQ_HEAD_REGNUM instead of PC_REGNUM.
	(hppa_frame_prev_register): Compute PCOQ_TAIL_REGNUM from
	PCOQ_HEAD_REGNUM.
@
text
@d4620 1
a4620 1
    return;
@


1.129.2.1
log
@        * hppa-tdep.c (hppa_frame_cache): Avoid undefined return value.
@
text
@d4620 1
a4620 1
    return (*this_cache);
@


1.129.2.2
log
@        * hppa-tdep.c (hppa32_push_dummy_call): Set the Stack Pointer.
        (hppa64_push_dummy_call): Likewise.
@
text
@a2271 3
  /* Update the Stack Pointer.  */
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, param_end + 32);

a2394 3

  /* Update the Stack Pointer.  */
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, sp + 64);
@


1.128
log
@Index: ChangeLog
2004-02-27  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa_gdbarch_init): On 32-bit systems always
	"return_value" and "push_dummy_call".
	(hppa32_use_struct_convention): Delete unused function.
	(hppa32_store_return_value): Delete unused function.
	(hppa32_extract_return_value): Delete unused function.
	(hppa32_stack_align): Delete function.
@
text
@d4797 2
a4798 1
  /* The PC is found in the "return register".  */
d4800 1
a4800 1
    cache->saved_regs[PC_REGNUM] = cache->saved_regs[31];
d4802 1
a4802 1
    cache->saved_regs[PC_REGNUM] = cache->saved_regs[RP_REGNUM];
d4833 30
a4862 2
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
d5859 1
a5859 1
  if (0)
d5861 1
d5866 2
a5867 3
    }
  else
    {
d5877 3
@


1.127
log
@2004-02-27  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa32_push_dummy_call): Fix code reserving
	inferior stack space - the stack needs to grow upwards.
	(hppa32_frame_align): New function.
	(hppa64_frame_align): Replace hppa_frame_align.
	(hppa_gdbarch_init): Update.
@
text
@a185 1
CORE_ADDR hppa32_stack_align (CORE_ADDR sp);
a193 2
void hppa32_extract_return_value (struct type *type, char *regbuf,
                                  char *valbuf);
a195 1
int hppa32_use_struct_convention (int gcc_p, struct type *type);
a196 1
void hppa32_store_return_value (struct type *type, char *valbuf);
a238 8
hppa32_use_struct_convention (int gcc_p, struct type *type)
{
  return (TYPE_LENGTH (type) > 2 * DEPRECATED_REGISTER_SIZE);
}

/* Same as hppa32_use_struct_convention() for the PA64 ABI.  */

int
a5435 24
/* Copy the function value from VALBUF into the proper location
   for a function return.

   Called only in the context of the "return" command.  */

void
hppa32_store_return_value (struct type *type, char *valbuf)
{
  /* For software floating point, the return value goes into the
     integer registers.  But we do not have any flag to key this on,
     so we always store the value into the integer registers.

     If its a float value, then we also store it into the floating
     point registers.  */
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (28)
				   + (TYPE_LENGTH (type) > 4
				      ? (8 - TYPE_LENGTH (type))
				      : (4 - TYPE_LENGTH (type))),
				   valbuf, TYPE_LENGTH (type));
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (FP4_REGNUM),
				     valbuf, TYPE_LENGTH (type));
}

a5461 22
/* Copy the function's return value into VALBUF.

   This function is called only in the context of "target function calls",
   ie. when the debugger forces a function to be called in the child, and
   when the debugger forces a fucntion to return prematurely via the
   "return" command.  */

void
hppa32_extract_return_value (struct type *type, char *regbuf, char *valbuf)
{
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    memcpy (valbuf, regbuf + DEPRECATED_REGISTER_BYTE (FP4_REGNUM), TYPE_LENGTH (type));
  else
    memcpy (valbuf,
	    (regbuf
	     + DEPRECATED_REGISTER_BYTE (28)
	     + (TYPE_LENGTH (type) > 4
		? (8 - TYPE_LENGTH (type))
		: (4 - TYPE_LENGTH (type)))),
	    TYPE_LENGTH (type));
}

a5507 9
hppa32_stack_align (CORE_ADDR sp)
{
  /* elz: adjust the quantity to the next highest value which is
     64-bit aligned.  This is used in valops.c, when the sp is adjusted.
     On hppa the sp must always be kept 64-bit aligned */
  return ((sp % 8) ? (sp + 7) & -8 : sp);
}

CORE_ADDR
d5779 1
a5779 1
  if (0)
d5781 6
a5786 1
      switch (tdep->bytes_per_address)
a5787 5
	case 4:
	  set_gdbarch_push_dummy_call (gdbarch, hppa32_push_dummy_call);
	  set_gdbarch_frame_align (gdbarch, hppa32_frame_align);
	  break;
	case 8:
d5792 1
a5792 4
    }
  else
    {
      switch (tdep->bytes_per_address)
a5793 6
	case 4:
	  set_gdbarch_deprecated_call_dummy_length (gdbarch, hppa32_call_dummy_length);
	  set_gdbarch_deprecated_stack_align (gdbarch, hppa32_stack_align);
	  set_gdbarch_deprecated_reg_struct_has_addr (gdbarch, hppa_reg_struct_has_addr);
	  break;
	case 8:
d5798 6
d5805 1
a5805 6
      set_gdbarch_deprecated_push_dummy_frame (gdbarch, hppa_push_dummy_frame);
      /* set_gdbarch_deprecated_fix_call_dummy (gdbarch, hppa_fix_call_dummy); */
      set_gdbarch_deprecated_push_arguments (gdbarch, hppa_push_arguments);
      set_gdbarch_deprecated_use_generic_dummy_frames (gdbarch, 0);
      set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_on_stack);
      set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
d5809 1
a5809 1
  if (0)
d5811 7
a5817 1
      switch (tdep->bytes_per_address)
a5818 20
	case 4:
	  set_gdbarch_return_value (gdbarch, hppa32_return_value);
	  break;
	case 8:
	  set_gdbarch_return_value (gdbarch, hppa64_return_value);
	  break;
	default:
	  internal_error (__FILE__, __LINE__, "bad switch");
	}
    }
  else
    {
      switch (tdep->bytes_per_address)
	{
	case 4:
	  set_gdbarch_deprecated_extract_return_value (gdbarch, hppa32_extract_return_value);
	  set_gdbarch_use_struct_convention (gdbarch, hppa32_use_struct_convention);
	  set_gdbarch_deprecated_store_return_value (gdbarch, hppa32_store_return_value);
	  break;
	case 8:
d5822 1
a5822 1
	  break;
d5824 3
a5826 1
      set_gdbarch_deprecated_store_struct_return (gdbarch, hppa_store_struct_return);
@


1.126
log
@2004-02-25  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa32_push_dummy_call): Rewrite.
@
text
@d2208 2
a2209 2
      CORE_ADDR struct_ptr = struct_end;
      CORE_ADDR param_ptr = param_end;
d2226 1
a2226 1
	      struct_ptr -= align_up (TYPE_LENGTH (type), 8);
d2228 1
a2228 1
		write_memory (struct_ptr, VALUE_CONTENTS (arg),
d2230 1
a2230 1
	      store_unsigned_integer (param_val, 4, struct_ptr);
d2249 1
a2249 1
	  param_ptr -= param_len;
d2253 1
a2253 1
	      write_memory (param_ptr, param_val, param_len);
d2415 8
d2426 1
a2426 1
hppa_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
a5848 1
      set_gdbarch_frame_align (gdbarch, hppa_frame_align);
d5853 1
d5857 1
@


1.125
log
@2004-02-23  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa_frame_align): New function.
	(hppa32_push_dummy_call): New function.
	(hppa64_push_dummy_call): New function.
	(hppa_gdbarch_init): Set frame_align and push_dummy_call; keep
	disabled.
@
text
@d2177 115
a2412 99
}

/* This function pushes a stack frame with arguments as part of the
   inferior function calling mechanism.

   This is the version of the function for the 32-bit PA machines, in
   which later arguments appear at lower addresses.  (The stack always
   grows towards higher addresses.)

   We simply allocate the appropriate amount of stack space and put
   arguments into their proper slots.  */
   
CORE_ADDR
hppa32_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			struct regcache *regcache, CORE_ADDR bp_addr,
			int nargs, struct value **args, CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_addr)
{
  struct tdep *tdep = gdbarch_tdep (gdbarch);

  /* array of arguments' offsets */
  int *offset = (int *) alloca (nargs * sizeof (int));

  /* array of arguments' lengths: real lengths in bytes, not aligned to
     word size */
  int *lengths = (int *) alloca (nargs * sizeof (int));

  /* The number of stack bytes occupied by the current argument.  */
  int bytes_reserved;

  /* The total number of bytes reserved for the arguments.  */
  int cum_bytes_reserved = 0;

  /* Similarly, but aligned.  */
  int cum_bytes_aligned = 0;
  int i;

  /* Iterate over each argument provided by the user.  */
  for (i = 0; i < nargs; i++)
    {
      lengths[i] = TYPE_LENGTH (VALUE_TYPE (args[i]));

      /* Align the size of the argument to the word size for this
	 target.  */
      bytes_reserved = (lengths[i] + 4 - 1) & -4;

      offset[i] = (cum_bytes_reserved + (lengths[i] > 4
					 ? bytes_reserved : lengths[i]));

      /* If the argument is a double word argument, then it needs to be
	 double word aligned.  */
      if ((bytes_reserved == 2 * 4)
	  && (offset[i] % 2 * 4))
	{
	  int new_offset = 0;
	  /* BYTES_RESERVED is already aligned to the word, so we put
	     the argument at one word more down the stack.

	     This will leave one empty word on the stack, and one
	     unused register as mandated by the ABI.  */
	  new_offset = ((offset[i] + 2 * 4 - 1)
			& -(2 * 4));

	  if ((new_offset - offset[i]) >= 2 * 4)
	    {
	      bytes_reserved += 4;
	      offset[i] += 4;
	    }
	}

      cum_bytes_reserved += bytes_reserved;

    }

  /* CUM_BYTES_RESERVED already accounts for all the arguments passed
     by the user.  However, the ABI mandates minimum stack space
     allocations for outgoing arguments.

     The ABI also mandates minimum stack alignments which we must
     preserve.  */
  cum_bytes_aligned = align_up (cum_bytes_reserved, 8);
  sp += max (cum_bytes_aligned, REG_PARM_STACK_SPACE);

  /* Now write each of the args at the proper offset down the stack.
     ?!? We need to promote values to a full register instead of skipping
     words in the stack.  */
  for (i = 0; i < nargs; i++)
    write_memory (sp - offset[i], VALUE_CONTENTS (args[i]), lengths[i]);

  /* If a structure has to be returned, set up register 28 to hold its
     address */
  if (struct_return)
    write_register (28, struct_addr);

  /* Set the return address.  */
  regcache_cooked_write_unsigned (regcache, RP_REGNUM, bp_addr);

  /* The stack will have 32 bytes of additional space for a frame marker.  */
  return sp + 32;
@


1.124
log
@2004-02-22  Andrew Cagney  <cagney@@redhat.com>

	* config/pa/tm-hppa.h (CALL_DUMMY_LOCATION): Delete macro.
	(DEPRECATED_PC_IN_CALL_DUMMY): Delete macro.
	(DEPRECATED_USE_GENERIC_DUMMY_FRAMES): Delete macro.
	* hppa-tdep.c (hppa_gdbarch_init): Clear deprecated
	use_generic_dummy_frames, set deprecated pc_in_call_dummy, set
	call_dummy_location to ON_STACK.
@
text
@d2174 235
d5825 10
@


1.123
log
@2004-02-22  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa32_return_value): New function.
	(hppa64_return_value): New function.
	(hppa_gdbarch_init): Set return_value; keep disabled.
@
text
@d5609 3
@


1.122
log
@2004-02-22  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa_gdbarch_init): Re-order separating
	struct-return and inferior function call methods.
@
text
@d258 105
d5614 11
@


1.121
log
@Index: ChangeLog
2004-02-22  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c: Include "trad-frame.h", "frame-unwind.h", and
	"frame-base.h".
	(struct hppa_frame_cache): Define.
	(hppa_frame_cache, hppa_frame_this_id): New functions.
	(hppa_frame_prev_register): New function.
	(hppa_frame_unwind, hppa_frame_base): New variables.
	(hppa_frame_unwind_sniffer): New function.
	(hppa_frame_base_address, hppa_unwind_pc): New function.
	(hppa_gdbarch_init): Set unwind_dummy_id, unwind_pc, frame unwind
	sniffer, and frame base sniffer; keep disabled.
	(hppa_frame_base_sniffer, hppa_unwind_dummy_id): New functions.
	* Makefile.in: Update dependencies, fix s/nbsd/obsd/ typo.
@
text
@d5494 21
a5519 3
	  set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, hppa64_call_dummy_breakpoint_offset);
	  set_gdbarch_deprecated_call_dummy_length (gdbarch, hppa64_call_dummy_length);
	  set_gdbarch_deprecated_stack_align (gdbarch, hppa64_stack_align);
a5525 3
      set_gdbarch_deprecated_push_dummy_frame (gdbarch, hppa_push_dummy_frame);
      /* set_gdbarch_deprecated_fix_call_dummy (gdbarch, hppa_fix_call_dummy); */
      set_gdbarch_deprecated_push_arguments (gdbarch, hppa_push_arguments);
@


1.120
log
@2004-02-22  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa_gdbarch_init): Convert compile time #if0s into
	runtime if(0).
@
text
@d43 3
d4243 291
d5516 4
@


1.119
log
@2004-02-22  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa_breakpoint_from_pc): Make "breakpoint"
	unsigned.
	(hppa_frame_find_saved_regs): Fix "std" instruction pattern
@
text
@d5189 1
a5189 3
#if 0
#else
  switch (tdep->bytes_per_address)
a5190 16
    case 4:
      set_gdbarch_deprecated_call_dummy_length (gdbarch, hppa32_call_dummy_length);
      set_gdbarch_deprecated_stack_align (gdbarch, hppa32_stack_align);
      set_gdbarch_deprecated_reg_struct_has_addr (gdbarch, hppa_reg_struct_has_addr);
      set_gdbarch_deprecated_extract_return_value (gdbarch, hppa32_extract_return_value);
      set_gdbarch_use_struct_convention (gdbarch, hppa32_use_struct_convention);
      set_gdbarch_deprecated_store_return_value (gdbarch, hppa32_store_return_value);
      break;
    case 8:
      set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, hppa64_call_dummy_breakpoint_offset);
      set_gdbarch_deprecated_call_dummy_length (gdbarch, hppa64_call_dummy_length);
      set_gdbarch_deprecated_stack_align (gdbarch, hppa64_stack_align);
      set_gdbarch_deprecated_extract_return_value (gdbarch, hppa64_extract_return_value);
      set_gdbarch_use_struct_convention (gdbarch, hppa64_use_struct_convention);
      set_gdbarch_deprecated_store_return_value (gdbarch, hppa64_store_return_value);
      break;
d5192 27
a5218 6
  set_gdbarch_deprecated_store_struct_return (gdbarch, hppa_store_struct_return);
  set_gdbarch_deprecated_push_dummy_frame (gdbarch, hppa_push_dummy_frame);
  /* set_gdbarch_deprecated_fix_call_dummy (gdbarch, hppa_fix_call_dummy); */
  set_gdbarch_deprecated_push_arguments (gdbarch, hppa_push_arguments);
#endif

d5220 15
a5234 12
#if 0
#else
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, hppa_saved_pc_after_call);
  set_gdbarch_deprecated_init_frame_pc (gdbarch, deprecated_init_frame_pc_default);
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, hppa_frame_init_saved_regs);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, hppa_init_extra_frame_info);
  set_gdbarch_deprecated_frame_chain (gdbarch, hppa_frame_chain);
  set_gdbarch_deprecated_frame_chain_valid (gdbarch, hppa_frame_chain_valid);
  set_gdbarch_deprecated_frameless_function_invocation (gdbarch, hppa_frameless_function_invocation);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, hppa_frame_saved_pc);
  set_gdbarch_deprecated_pop_frame (gdbarch, hppa_pop_frame);
#endif
@


1.118
log
@2004-02-22  Andrew Cagney  <cagney@@redhat.com>

	* config/pa/tm-hppa.h: Update copyright.
	(DEPRECATED_INIT_FRAME_PC): Delete macro.
	(deprecated_init_frame_pc_default): Delete declaration.
	(hppa_frame_init_saved_regs): Delete declaration.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Delete macro.
	* hppa-tdep.c: Include "arch-utils.h".
	(hppa_gdbarch_init): Set deprecated init_frame_pc
	and deprecated frame_init_saved_regs.
	(hppa_frame_init_saved_regs): Make static.
@
text
@d705 1
a705 1
  static const char breakpoint[] = {0x00, 0x01, 0x00, 0x04};
d4152 1
a4152 1
	  else if ((inst & 0xfc00000c0) == 0x70000008)
@


1.117
log
@2004-02-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAMELESS_FUNCTION_INVOCATION): Predicate
	and function replacing FRAMELESS_FUNCTION_INVOCATION.
	* blockframe.c (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* frame.h (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	(delta68_frame_args_address): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	(frv_frameless_function_invocation): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	(cris_frameless_function_invocation): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* stack.c (frame_info): Update, call predicate.
	* rs6000-tdep.c (rs6000_frame_chain): Update, call predicate..
	* frame.c (legacy_get_prev_frame): Update, call predicate..
	* arch-utils.c (generic_frameless_function_invocation_not): Delete.
	* arch-utils.h (generic_frameless_function_invocation_not): Delete.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set frameless function
	invocation.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
@
text
@d38 1
d118 2
d4232 1
a4232 1
void
d5220 2
@


1.117.2.1
log
@Merge mainline to intercu branch.
@
text
@a37 1
#include "arch-utils.h"
a41 3
#include "trad-frame.h"
#include "frame-unwind.h"
#include "frame-base.h"
d75 9
d90 5
d117 6
d127 2
d131 2
d141 2
d153 4
d165 5
d178 1
d180 2
d184 13
d198 14
d215 1
d235 9
a243 1
/* Handle 32/64-bit struct return conventions.  */
d245 2
a246 4
static enum return_value_convention
hppa32_return_value (struct gdbarch *gdbarch,
		     struct type *type, struct regcache *regcache,
		     void *readbuf, const void *writebuf)
d248 2
a249 97
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    {
      if (readbuf != NULL)
	regcache_cooked_read_part (regcache, FP4_REGNUM, 0,
				   TYPE_LENGTH (type), readbuf);
      if (writebuf != NULL)
	regcache_cooked_write_part (regcache, FP4_REGNUM, 0,
				    TYPE_LENGTH (type), writebuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_LENGTH (type) <= 2 * 4)
    {
      /* The value always lives in the right hand end of the register
	 (or register pair)?  */
      int b;
      int reg = 28;
      int part = TYPE_LENGTH (type) % 4;
      /* The left hand register contains only part of the value,
	 transfer that first so that the rest can be xfered as entire
	 4-byte registers.  */
      if (part > 0)
	{
	  if (readbuf != NULL)
	    regcache_cooked_read_part (regcache, reg, 4 - part,
				       part, readbuf);
	  if (writebuf != NULL)
	    regcache_cooked_write_part (regcache, reg, 4 - part,
					part, writebuf);
	  reg++;
	}
      /* Now transfer the remaining register values.  */
      for (b = part; b < TYPE_LENGTH (type); b += 4)
	{
	  if (readbuf != NULL)
	    regcache_cooked_read (regcache, reg, (char *) readbuf + b);
	  if (writebuf != NULL)
	    regcache_cooked_write (regcache, reg, (const char *) writebuf + b);
	  reg++;
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else
    return RETURN_VALUE_STRUCT_CONVENTION;
}

static enum return_value_convention
hppa64_return_value (struct gdbarch *gdbarch,
		     struct type *type, struct regcache *regcache,
		     void *readbuf, const void *writebuf)
{
  /* RM: Floats are returned in FR4R, doubles in FR4.  Integral values
     are in r28, padded on the left.  Aggregates less that 65 bits are
     in r28, right padded.  Aggregates upto 128 bits are in r28 and
     r29, right padded.  */ 
  if (TYPE_CODE (type) == TYPE_CODE_FLT
      && TYPE_LENGTH (type) <= 8)
    {
      /* Floats are right aligned?  */
      int offset = register_size (gdbarch, FP4_REGNUM) - TYPE_LENGTH (type);
      if (readbuf != NULL)
	regcache_cooked_read_part (regcache, FP4_REGNUM, offset,
				   TYPE_LENGTH (type), readbuf);
      if (writebuf != NULL)
	regcache_cooked_write_part (regcache, FP4_REGNUM, offset,
				    TYPE_LENGTH (type), writebuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_LENGTH (type) <= 8 && is_integral_type (type))
    {
      /* Integrals are right aligned.  */
      int offset = register_size (gdbarch, FP4_REGNUM) - TYPE_LENGTH (type);
      if (readbuf != NULL)
	regcache_cooked_read_part (regcache, 28, offset,
				   TYPE_LENGTH (type), readbuf);
      if (writebuf != NULL)
	regcache_cooked_write_part (regcache, 28, offset,
				    TYPE_LENGTH (type), writebuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_LENGTH (type) <= 2 * 8)
    {
      /* Composite values are left aligned.  */
      int b;
      for (b = 0; b < TYPE_LENGTH (type); b += 8)
	{
	  int part = min (8, TYPE_LENGTH (type) - b);
	  if (readbuf != NULL)
	    regcache_cooked_read_part (regcache, 28 + b / 8, 0, part,
				       (char *) readbuf + b);
	  if (writebuf != NULL)
	    regcache_cooked_write_part (regcache, 28 + b / 8, 0, part,
					(const char *) writebuf + b);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else
    return RETURN_VALUE_STRUCT_CONVENTION;
d313 10
d344 21
d702 1
a702 1
  static const unsigned char breakpoint[] = {0x00, 0x01, 0x00, 0x04};
d807 20
a826 2
/* This function pushes a stack frame with arguments as part of the
   inferior function calling mechanism.
d828 2
a829 3
   This is the version of the function for the 32-bit PA machines, in
   which later arguments appear at lower addresses.  (The stack always
   grows towards higher addresses.)
d831 1
a831 81
   We simply allocate the appropriate amount of stack space and put
   arguments into their proper slots.  */
   
CORE_ADDR
hppa32_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			struct regcache *regcache, CORE_ADDR bp_addr,
			int nargs, struct value **args, CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_addr)
{
  /* NOTE: cagney/2004-02-27: This is a guess - its implemented by
     reverse engineering testsuite failures.  */

  /* Stack base address at which any pass-by-reference parameters are
     stored.  */
  CORE_ADDR struct_end = 0;
  /* Stack base address at which the first parameter is stored.  */
  CORE_ADDR param_end = 0;

  /* The inner most end of the stack after all the parameters have
     been pushed.  */
  CORE_ADDR new_sp = 0;

  /* Two passes.  First pass computes the location of everything,
     second pass writes the bytes out.  */
  int write_pass;
  for (write_pass = 0; write_pass < 2; write_pass++)
    {
      CORE_ADDR struct_ptr = 0;
      CORE_ADDR param_ptr = 0;
      int reg = 27;	      /* NOTE: Registers go down.  */
      int i;
      for (i = 0; i < nargs; i++)
	{
	  struct value *arg = args[i];
	  struct type *type = check_typedef (VALUE_TYPE (arg));
	  /* The corresponding parameter that is pushed onto the
	     stack, and [possibly] passed in a register.  */
	  char param_val[8];
	  int param_len;
	  memset (param_val, 0, sizeof param_val);
	  if (TYPE_LENGTH (type) > 8)
	    {
	      /* Large parameter, pass by reference.  Store the value
		 in "struct" area and then pass its address.  */
	      param_len = 4;
	      struct_ptr += align_up (TYPE_LENGTH (type), 8);
	      if (write_pass)
		write_memory (struct_end - struct_ptr, VALUE_CONTENTS (arg),
			      TYPE_LENGTH (type));
	      store_unsigned_integer (param_val, 4, struct_end - struct_ptr);
	    }
	  else if (TYPE_CODE (type) == TYPE_CODE_INT
		   || TYPE_CODE (type) == TYPE_CODE_ENUM)
	    {
	      /* Integer value store, right aligned.  "unpack_long"
		 takes care of any sign-extension problems.  */
	      param_len = align_up (TYPE_LENGTH (type), 4);
	      store_unsigned_integer (param_val, param_len,
				      unpack_long (type,
						   VALUE_CONTENTS (arg)));
	    }
	  else
	    {
	      /* Small struct value, store right aligned?  */
	      param_len = align_up (TYPE_LENGTH (type), 4);
	      memcpy (param_val + param_len - TYPE_LENGTH (type),
		      VALUE_CONTENTS (arg), TYPE_LENGTH (type));
	    }
	  param_ptr += param_len;
	  reg -= param_len / 4;
	  if (write_pass)
	    {
	      write_memory (param_end - param_ptr, param_val, param_len);
	      if (reg >= 23)
		{
		  regcache_cooked_write (regcache, reg, param_val);
		  if (param_len > 4)
		    regcache_cooked_write (regcache, reg + 1, param_val + 4);
		}
	    }
	}
d833 6
a838 13
      /* Update the various stack pointers.  */
      if (!write_pass)
	{
	  struct_end = sp + struct_ptr;
	  /* PARAM_PTR already accounts for all the arguments passed
	     by the user.  However, the ABI mandates minimum stack
	     space allocations for outgoing arguments.  The ABI also
	     mandates minimum stack alignments which we must
	     preserve.  */
	  param_end = struct_end + max (align_up (param_ptr, 8),
					REG_PARM_STACK_SPACE);
	}
    }
d840 3
a842 4
  /* If a structure has to be returned, set up register 28 to hold its
     address */
  if (struct_return)
    write_register (28, struct_addr);
d844 1
a844 2
  /* Set the return address.  */
  regcache_cooked_write_unsigned (regcache, RP_REGNUM, bp_addr);
d846 3
a848 3
  /* The stack will have 32 bytes of additional space for a frame marker.  */
  return param_end + 32;
}
d850 3
a852 2
/* This function pushes a stack frame with arguments as part of the
   inferior function calling mechanism.
d854 5
a858 3
   This is the version for the PA64, in which later arguments appear
   at higher addresses.  (The stack always grows towards higher
   addresses.)
d860 2
a861 2
   We simply allocate the appropriate amount of stack space and put
   arguments into their proper slots.
d863 3
a865 87
   This ABI also requires that the caller provide an argument pointer
   to the callee, so we do that too.  */
   
CORE_ADDR
hppa64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			struct regcache *regcache, CORE_ADDR bp_addr,
			int nargs, struct value **args, CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_addr)
{
  /* NOTE: cagney/2004-02-27: This is a guess - its implemented by
     reverse engineering testsuite failures.  */

  /* Stack base address at which any pass-by-reference parameters are
     stored.  */
  CORE_ADDR struct_end = 0;
  /* Stack base address at which the first parameter is stored.  */
  CORE_ADDR param_end = 0;

  /* The inner most end of the stack after all the parameters have
     been pushed.  */
  CORE_ADDR new_sp = 0;

  /* Two passes.  First pass computes the location of everything,
     second pass writes the bytes out.  */
  int write_pass;
  for (write_pass = 0; write_pass < 2; write_pass++)
    {
      CORE_ADDR struct_ptr = 0;
      CORE_ADDR param_ptr = 0;
      int i;
      for (i = 0; i < nargs; i++)
	{
	  struct value *arg = args[i];
	  struct type *type = check_typedef (VALUE_TYPE (arg));
	  if ((TYPE_CODE (type) == TYPE_CODE_INT
	       || TYPE_CODE (type) == TYPE_CODE_ENUM)
	      && TYPE_LENGTH (type) <= 8)
	    {
	      /* Integer value store, right aligned.  "unpack_long"
		 takes care of any sign-extension problems.  */
	      param_ptr += 8;
	      if (write_pass)
		{
		  ULONGEST val = unpack_long (type, VALUE_CONTENTS (arg));
		  int reg = 27 - param_ptr / 8;
		  write_memory_unsigned_integer (param_end - param_ptr,
						 val, 8);
		  if (reg >= 19)
		    regcache_cooked_write_unsigned (regcache, reg, val);
		}
	    }
	  else
	    {
	      /* Small struct value, store left aligned?  */
	      int reg;
	      if (TYPE_LENGTH (type) > 8)
		{
		  param_ptr = align_up (param_ptr, 16);
		  reg = 26 - param_ptr / 8;
		  param_ptr += align_up (TYPE_LENGTH (type), 16);
		}
	      else
		{
		  param_ptr = align_up (param_ptr, 8);
		  reg = 26 - param_ptr / 8;
		  param_ptr += align_up (TYPE_LENGTH (type), 8);
		}
	      if (write_pass)
		{
		  int byte;
		  write_memory (param_end - param_ptr, VALUE_CONTENTS (arg),
				TYPE_LENGTH (type));
		  for (byte = 0; byte < TYPE_LENGTH (type); byte += 8)
		    {
		      if (reg >= 19)
			{
			  int len = min (8, TYPE_LENGTH (type) - byte);
			  regcache_cooked_write_part (regcache, reg, 0, len,
						      VALUE_CONTENTS (arg) + byte);
			}
		      reg--;
		    }
		}
	    }
	}
      /* Update the various stack pointers.  */
      if (!write_pass)
d867 2
a868 8
	  struct_end = sp + struct_ptr;
	  /* PARAM_PTR already accounts for all the arguments passed
	     by the user.  However, the ABI mandates minimum stack
	     space allocations for outgoing arguments.  The ABI also
	     mandates minimum stack alignments which we must
	     preserve.  */
	  param_end = struct_end + max (align_up (param_ptr, 16),
					REG_PARM_STACK_SPACE);
d870 2
d874 7
a880 4
  /* If a structure has to be returned, set up register 28 to hold its
     address */
  if (struct_return)
    write_register (28, struct_addr);
d882 2
a883 2
  /* Set the return address.  */
  regcache_cooked_write_unsigned (regcache, RP_REGNUM, bp_addr);
d885 11
a895 2
  /* The stack will have 32 bytes of additional space for a frame marker.  */
  return param_end + 64;
d898 2
a899 2
static CORE_ADDR
hppa32_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
d901 1
a901 4
  /* HP frames are 64-byte (or cache line) aligned (yes that's _byte_
     and not _bit_)!  */
  return align_up (addr, 64);
}
d903 1
a903 1
/* Force all frames to 16-byte alignment.  Better safe than sorry.  */
d905 2
a906 6
static CORE_ADDR
hppa64_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  /* Just always 16-byte align.  */
  return align_up (addr, 16);
}
d908 2
d911 2
a912 18
/* elz: Used to lookup a symbol in the shared libraries.
   This function calls shl_findsym, indirectly through a
   call to __d_shl_get. __d_shl_get is in end.c, which is always
   linked in by the hp compilers/linkers. 
   The call to shl_findsym cannot be made directly because it needs
   to be active in target address space. 
   inputs: - minimal symbol pointer for the function we want to look up
   - address in target space of the descriptor for the library
   where we want to look the symbol up.
   This address is retrieved using the 
   som_solib_get_solib_by_pc function (somsolib.c). 
   output: - real address in the library of the function.          
   note: the handle can be null, in which case shl_findsym will look for
   the symbol in all the loaded shared libraries.
   files to look at if you need reference on this stuff:
   dld.c, dld_shl_findsym.c
   end.c
   man entry for shl_findsym */
d914 3
a916 2
CORE_ADDR
find_stub_with_shl_get (struct minimal_symbol *function, CORE_ADDR handle)
d918 2
a919 6
  struct symbol *get_sym, *symbol2;
  struct minimal_symbol *buff_minsym, *msymbol;
  struct type *ftype;
  struct value **args;
  struct value *funcval;
  struct value *val;
d921 3
a923 3
  int x, namelen, err_value, tmp = -1;
  CORE_ADDR endo_buff_addr, value_return_addr, errno_return_addr;
  CORE_ADDR stub_addr;
d925 1
d927 8
a934 10
  args = alloca (sizeof (struct value *) * 8);		/* 6 for the arguments and one null one??? */
  funcval = find_function_in_inferior ("__d_shl_get");
  get_sym = lookup_symbol ("__d_shl_get", NULL, VAR_DOMAIN, NULL, NULL);
  buff_minsym = lookup_minimal_symbol ("__buffer", NULL, NULL);
  msymbol = lookup_minimal_symbol ("__shldp", NULL, NULL);
  symbol2 = lookup_symbol ("__shldp", NULL, VAR_DOMAIN, NULL, NULL);
  endo_buff_addr = SYMBOL_VALUE_ADDRESS (buff_minsym);
  namelen = strlen (DEPRECATED_SYMBOL_NAME (function));
  value_return_addr = endo_buff_addr + namelen;
  ftype = check_typedef (SYMBOL_TYPE (get_sym));
d936 1
a936 3
  /* do alignment */
  if ((x = value_return_addr % 64) != 0)
    value_return_addr = value_return_addr + 64 - x;
d938 7
a944 1
  errno_return_addr = value_return_addr + 64;
d946 2
d949 2
a950 1
  /* set up stuff needed by __d_shl_get in buffer in end.o */
d952 4
a955 1
  target_write_memory (endo_buff_addr, DEPRECATED_SYMBOL_NAME (function), namelen);
d957 3
a959 1
  target_write_memory (value_return_addr, (char *) &tmp, 4);
d961 1
a961 1
  target_write_memory (errno_return_addr, (char *) &tmp, 4);
d963 8
a970 2
  target_write_memory (SYMBOL_VALUE_ADDRESS (msymbol),
		       (char *) &handle, 4);
d972 23
a994 1
  /* now prepare the arguments for the call */
d996 1
a996 6
  args[0] = value_from_longest (TYPE_FIELD_TYPE (ftype, 0), 12);
  args[1] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 1), SYMBOL_VALUE_ADDRESS (msymbol));
  args[2] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 2), endo_buff_addr);
  args[3] = value_from_longest (TYPE_FIELD_TYPE (ftype, 3), TYPE_PROCEDURE);
  args[4] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 4), value_return_addr);
  args[5] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 5), errno_return_addr);
d998 2
a999 1
  /* now call the function */
d1001 2
a1002 1
  val = call_function_by_hand (funcval, 6, args);
d1004 4
a1007 1
  /* now get the results */
d1009 6
a1014 1
  target_read_memory (errno_return_addr, (char *) &err_value, sizeof (err_value));
d1016 2
a1017 3
  target_read_memory (value_return_addr, (char *) &stub_addr, sizeof (stub_addr));
  if (stub_addr <= 0)
    error ("call to __d_shl_get failed, error code is %d", err_value);
d1019 7
a1025 1
  return (stub_addr);
d1027 55
d1083 1494
a2576 8
/* Cover routine for find_stub_with_shl_get to pass to catch_errors */
static int
cover_find_stub_with_shl_get (void *args_untyped)
{
  args_for_find_stub *args = args_untyped;
  args->return_val = find_stub_with_shl_get (args->msym, args->solib_handle);
  return 0;
}
d2579 414
a2992 1
   bits.  */
d2994 3
a2996 2
CORE_ADDR
hppa_target_read_pc (ptid_t ptid)
d2998 5
a3002 1
  int flags = read_register_pid (FLAGS_REGNUM, ptid);
d3004 2
a3005 5
  /* The following test does not belong here.  It is OS-specific, and belongs
     in native code.  */
  /* Test SS_INSYSCALL */
  if (flags & 2)
    return read_register_pid (31, ptid) & ~0x3;
d3007 2
a3008 2
  return read_register_pid (PCOQ_HEAD_REGNUM, ptid) & ~0x3;
}
d3010 2
a3011 2
/* Write out the PC.  If currently in a syscall, then also write the new
   PC value into %r31.  */
d3013 1
a3013 4
void
hppa_target_write_pc (CORE_ADDR v, ptid_t ptid)
{
  int flags = read_register_pid (FLAGS_REGNUM, ptid);
d3015 2
a3016 7
  /* The following test does not belong here.  It is OS-specific, and belongs
     in native code.  */
  /* If in a syscall, then set %r31.  Also make sure to get the 
     privilege bits set correctly.  */
  /* Test SS_INSYSCALL */
  if (flags & 2)
    write_register_pid (31, v | 0x3, ptid);
d3018 3
a3020 3
  write_register_pid (PCOQ_HEAD_REGNUM, v, ptid);
  write_register_pid (PCOQ_TAIL_REGNUM, v + 4, ptid);
}
d3022 2
a3023 2
/* return the alignment of a type in bytes. Structures have the maximum
   alignment required by their fields. */
d3025 2
a3026 6
static int
hppa_alignof (struct type *type)
{
  int max_align, align, i;
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type))
d3028 2
a3029 22
    case TYPE_CODE_PTR:
    case TYPE_CODE_INT:
    case TYPE_CODE_FLT:
      return TYPE_LENGTH (type);
    case TYPE_CODE_ARRAY:
      return hppa_alignof (TYPE_FIELD_TYPE (type, 0));
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      max_align = 1;
      for (i = 0; i < TYPE_NFIELDS (type); i++)
	{
	  /* Bit fields have no real alignment. */
	  /* if (!TYPE_FIELD_BITPOS (type, i)) */
	  if (!TYPE_FIELD_BITSIZE (type, i))	/* elz: this should be bitsize */
	    {
	      align = hppa_alignof (TYPE_FIELD_TYPE (type, i));
	      max_align = max (max_align, align);
	    }
	}
      return max_align;
    default:
      return 4;
d3031 1
d3507 1
a3507 1
		    (read_register (HPPA_SP_REGNUM) - 8, 4)) & ~0x3;
d3521 1
a3521 1
		  (read_register (HPPA_SP_REGNUM) - 24, TARGET_PTR_BIT / 8)) & ~0x3;
d3533 1
a3533 1
		  (read_register (HPPA_SP_REGNUM) - 24, TARGET_PTR_BIT / 8)) & ~0x3;
d3720 1
a3720 1
      if (u->Save_SP && i == HPPA_FP_REGNUM)
d3981 9
a3989 1
struct hppa_frame_cache
d3991 1
a3991 12
  CORE_ADDR base;
  struct trad_frame_saved_reg *saved_regs;
};

static struct hppa_frame_cache *
hppa_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct hppa_frame_cache *cache;
  long saved_gr_mask;
  long saved_fr_mask;
  CORE_ADDR this_sp;
  long frame_size;
d3993 56
a4048 1
  int i;
d4050 3
a4052 5
  if ((*this_cache) != NULL)
    return (*this_cache);
  cache = FRAME_OBSTACK_ZALLOC (struct hppa_frame_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d4055 1
a4055 1
  u = find_unwind_entry (frame_func_unwind (next_frame));
d4057 8
a4064 1
    return (*this_cache);
d4067 1
a4067 1
  saved_gr_mask = 0;
d4071 1
a4071 1
      if (u->Save_SP && i == HPPA_FP_REGNUM)
d4073 2
a4074 2
	
      saved_gr_mask |= (1 << i);
d4078 1
a4078 1
  saved_fr_mask = 0;
d4080 6
a4085 1
    saved_fr_mask |= (1 << i);
d4101 6
a4106 79
  {
    int final_iteration = 0;
    CORE_ADDR pc;
    CORE_ADDR end_pc = skip_prologue_using_sal (pc);
    int looking_for_sp = u->Save_SP;
    int looking_for_rp = u->Save_RP;
    int fp_loc = -1;
    if (end_pc == 0)
      end_pc = frame_pc_unwind (next_frame);
    frame_size = 0;
    for (pc = frame_func_unwind (next_frame);
	 ((saved_gr_mask || saved_fr_mask
	   || looking_for_sp || looking_for_rp
	   || frame_size < (u->Total_frame_size << 3))
	  && pc <= end_pc);
	 pc += 4)
      {
	int reg;
	char buf4[4];
	long status = target_read_memory (pc, buf4, sizeof buf4);
	long inst = extract_unsigned_integer (buf4, sizeof buf4);
	
	/* Note the interesting effects of this instruction.  */
	frame_size += prologue_inst_adjust_sp (inst);
	
	/* There are limited ways to store the return pointer into the
	   stack.  */
	if (inst == 0x6bc23fd9) /* stw rp,-0x14(sr0,sp) */
	  {
	    looking_for_rp = 0;
	    cache->saved_regs[RP_REGNUM].addr = -20;
	  }
	else if (inst == 0x0fc212c1) /* std rp,-0x10(sr0,sp) */
	  {
	    looking_for_rp = 0;
	    cache->saved_regs[RP_REGNUM].addr = -16;
	  }
	
	/* Check to see if we saved SP into the stack.  This also
	   happens to indicate the location of the saved frame
	   pointer.  */
	if ((inst & 0xffffc000) == 0x6fc10000  /* stw,ma r1,N(sr0,sp) */
	    || (inst & 0xffffc00c) == 0x73c10008) /* std,ma r1,N(sr0,sp) */
	  {
	    looking_for_sp = 0;
	    cache->saved_regs[HPPA_FP_REGNUM].addr = 0;
	  }
	
	/* Account for general and floating-point register saves.  */
	reg = inst_saves_gr (inst);
	if (reg >= 3 && reg <= 18
	    && (!u->Save_SP || reg != HPPA_FP_REGNUM))
	  {
	    saved_gr_mask &= ~(1 << reg);
	    if ((inst >> 26) == 0x1b && extract_14 (inst) >= 0)
	      /* stwm with a positive displacement is a _post_
		 _modify_.  */
	      cache->saved_regs[reg].addr = 0;
	    else if ((inst & 0xfc00000c) == 0x70000008)
	      /* A std has explicit post_modify forms.  */
	      cache->saved_regs[reg].addr = 0;
	    else
	      {
		CORE_ADDR offset;
		
		if ((inst >> 26) == 0x1c)
		  offset = (inst & 0x1 ? -1 << 13 : 0) | (((inst >> 4) & 0x3ff) << 3);
		else if ((inst >> 26) == 0x03)
		  offset = low_sign_extend (inst & 0x1f, 5);
		else
		  offset = extract_14 (inst);
		
		/* Handle code with and without frame pointers.  */
		if (u->Save_SP)
		  cache->saved_regs[reg].addr = offset;
		else
		  cache->saved_regs[reg].addr = (u->Total_frame_size << 3) + offset;
	      }
	  }
d4108 3
a4110 5
	/* GCC handles callee saved FP regs a little differently.  
	   
	   It emits an instruction to put the value of the start of
	   the FP store area into %r1.  It then uses fstds,ma with a
	   basereg of %r1 for the stores.
d4112 2
a4113 39
	   HP CC emits them at the current stack pointer modifying the
	   stack pointer as it stores each register.  */
	
	/* ldo X(%r3),%r1 or ldo X(%r30),%r1.  */
	if ((inst & 0xffffc000) == 0x34610000
	    || (inst & 0xffffc000) == 0x37c10000)
	  fp_loc = extract_14 (inst);
	
	reg = inst_saves_fr (inst);
	if (reg >= 12 && reg <= 21)
	  {
	    /* Note +4 braindamage below is necessary because the FP
	       status registers are internally 8 registers rather than
	       the expected 4 registers.  */
	    saved_fr_mask &= ~(1 << reg);
	    if (fp_loc == -1)
	      {
		/* 1st HP CC FP register store.  After this
		   instruction we've set enough state that the GCC and
		   HPCC code are both handled in the same manner.  */
		cache->saved_regs[reg + FP4_REGNUM + 4].addr = 0;
		fp_loc = 8;
	      }
	    else
	      {
		cache->saved_regs[reg + HPPA_FP0_REGNUM + 4].addr = fp_loc;
		fp_loc += 8;
	      }
	  }
	
	/* Quit if we hit any kind of branch the previous iteration. */
	if (final_iteration)
	  break;
	/* We want to look precisely one instruction beyond the branch
	   if we have not found everything yet.  */
	if (is_branch (inst))
	  final_iteration = 1;
      }
  }
d4115 12
a4126 18
  {
    /* The frame base always represents the value of %sp at entry to
       the current function (and is thus equivalent to the "saved"
       stack pointer.  */
    CORE_ADDR this_sp = frame_unwind_register_unsigned (next_frame, HPPA_SP_REGNUM);
    /* FIXME: cagney/2004-02-22: This assumes that the frame has been
       created.  If it hasn't everything will be out-of-wack.  */
    if (u->Save_SP && trad_frame_addr_p (cache->saved_regs, HPPA_SP_REGNUM))
      /* Both we're expecting the SP to be saved and the SP has been
	 saved.  The entry SP value is saved at this frame's SP
	 address.  */
      cache->base = read_memory_integer (this_sp, TARGET_PTR_BIT / 8);
    else
      /* The prologue has been slowly allocating stack space.  Adjust
	 the SP back.  */
      cache->base = this_sp - frame_size;
    trad_frame_set_value (cache->saved_regs, HPPA_SP_REGNUM, cache->base);
  }
d4128 8
a4135 6
  /* The PC is found in the "return register", "Millicode" uses "r31"
     as the return register while normal code uses "rp".  */
  if (u->Millicode)
    cache->saved_regs[PCOQ_HEAD_REGNUM] = cache->saved_regs[31];
  else
    cache->saved_regs[PCOQ_HEAD_REGNUM] = cache->saved_regs[RP_REGNUM];
d4137 6
a4142 9
  {
    /* Convert all the offsets into addresses.  */
    int reg;
    for (reg = 0; reg < NUM_REGS; reg++)
      {
	if (trad_frame_addr_p (cache->saved_regs, reg))
	  cache->saved_regs[reg].addr += cache->base;
      }
  }
d4144 10
a4153 2
  return (*this_cache);
}
d4155 6
a4160 7
static void
hppa_frame_this_id (struct frame_info *next_frame, void **this_cache,
			   struct frame_id *this_id)
{
  struct hppa_frame_cache *info = hppa_frame_cache (next_frame, this_cache);
  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
}
d4162 9
a4170 31
static void
hppa_frame_prev_register (struct frame_info *next_frame,
				 void **this_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *valuep)
{
  struct hppa_frame_cache *info = hppa_frame_cache (next_frame, this_cache);
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  if (regnum == PCOQ_TAIL_REGNUM)
    {
      /* The PCOQ TAIL, or NPC, needs to be computed from the unwound
	 PC register.  */
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = 0;
      if (valuep)
	{
	  int regsize = register_size (gdbarch, PCOQ_HEAD_REGNUM);
	  CORE_ADDR pc;
	  int optimized;
	  enum lval_type lval;
	  CORE_ADDR addr;
	  int realnum;
	  bfd_byte value[MAX_REGISTER_SIZE];
	  trad_frame_prev_register (next_frame, info->saved_regs,
				    PCOQ_HEAD_REGNUM, &optimized, &lval, &addr,
				    &realnum, &value);
	  pc = extract_unsigned_integer (&value, regsize);
	  store_unsigned_integer (valuep, regsize, pc + 4);
a4171 7
    }
  else
    {
      trad_frame_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
    }
}
a4172 6
static const struct frame_unwind hppa_frame_unwind =
{
  NORMAL_FRAME,
  hppa_frame_this_id,
  hppa_frame_prev_register
};
d4174 36
a4209 5
static const struct frame_unwind *
hppa_frame_unwind_sniffer (struct frame_info *next_frame)
{
  return &hppa_frame_unwind;
}
d4211 3
a4213 8
static CORE_ADDR
hppa_frame_base_address (struct frame_info *next_frame,
				void **this_cache)
{
  struct hppa_frame_cache *info = hppa_frame_cache (next_frame,
							   this_cache);
  return info->base;
}
d4215 4
a4218 6
static const struct frame_base hppa_frame_base = {
  &hppa_frame_unwind,
  hppa_frame_base_address,
  hppa_frame_base_address,
  hppa_frame_base_address
};
d4220 3
a4222 4
static const struct frame_base *
hppa_frame_base_sniffer (struct frame_info *next_frame)
{
  return &hppa_frame_base;
d4225 3
a4227 7
static struct frame_id
hppa_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_id_build (frame_unwind_register_unsigned (next_frame,
							 HPPA_SP_REGNUM),
			 frame_pc_unwind (next_frame));
}
d4229 2
a4230 2
static CORE_ADDR
hppa_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
d4232 3
a4234 1
  return frame_unwind_register_signed (next_frame, PCOQ_HEAD_REGNUM) & ~3;
d4788 102
d4905 16
d4961 18
d4982 2
a4983 2
static struct type *
hppa32_register_type (struct gdbarch *gdbarch, int reg_nr)
d4986 1
a4986 1
     return builtin_type_uint32;
d4988 1
a4988 1
     return builtin_type_ieee_single_big;
d4994 2
a4995 2
static struct type *
hppa64_register_type (struct gdbarch *gdbarch, int reg_nr)
d4998 1
a4998 1
     return builtin_type_uint64;
d5000 1
a5000 1
     return builtin_type_ieee_double_big;
d5003 8
d5121 2
a5122 1
        set_gdbarch_register_type (gdbarch, hppa32_register_type);
d5127 2
a5128 1
        set_gdbarch_register_type (gdbarch, hppa64_register_type);
d5135 4
d5156 10
a5165 2
  set_gdbarch_sp_regnum (gdbarch, HPPA_SP_REGNUM);
  set_gdbarch_fp0_regnum (gdbarch, HPPA_FP0_REGNUM);
d5172 1
d5186 2
d5191 6
a5196 2
      set_gdbarch_push_dummy_call (gdbarch, hppa32_push_dummy_call);
      set_gdbarch_frame_align (gdbarch, hppa32_frame_align);
d5199 6
a5204 2
      set_gdbarch_push_dummy_call (gdbarch, hppa64_push_dummy_call);
      set_gdbarch_frame_align (gdbarch, hppa64_frame_align);
a5205 2
    default:
      internal_error (__FILE__, __LINE__, "bad switch");
d5207 6
a5212 14
      
  /* Struct return methods.  */
  switch (tdep->bytes_per_address)
    {
    case 4:
      set_gdbarch_return_value (gdbarch, hppa32_return_value);
      break;
    case 8:
      set_gdbarch_return_value (gdbarch, hppa64_return_value);
      break;
    default:
      internal_error (__FILE__, __LINE__, "bad switch");
    }
      
d5214 10
a5223 4
  set_gdbarch_unwind_dummy_id (gdbarch, hppa_unwind_dummy_id);
  set_gdbarch_unwind_pc (gdbarch, hppa_unwind_pc);
  frame_unwind_append_sniffer (gdbarch, hppa_frame_unwind_sniffer);
  frame_base_append_sniffer (gdbarch, hppa_frame_base_sniffer);
@


1.117.2.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@a913 3
  /* Update the Stack Pointer.  */
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, param_end + 32);

a1033 3

  /* Update the Stack Pointer.  */
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, param_end + 64);
@


1.117.2.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d28 1
d31 1
d34 1
d37 1
d41 1
d47 21
d70 2
a74 2
static int hppa_debug = 0;

a78 8
/* hppa-specific object data -- unwind and solib info.
   TODO/maybe: think about splitting this into two parts; the unwind data is 
   common to all hppa targets, but is only used in this file; we can register 
   that separately and make this static. The solib data is probably hpux-
   specific, so we can create a separate extern objfile_data that is registered
   by hppa-hpux-tdep.c and shared with pa64solib.c and somsolib.c.  */
const struct objfile_data *hppa_objfile_priv_data = NULL;

d85 10
d99 41
d142 6
d150 22
d180 10
d195 1
a195 1
      int reg = TYPE_CODE (type) == TYPE_CODE_FLT ? HPPA_FP4_REGNUM : 28;
d238 1
a238 1
      int offset = register_size (gdbarch, HPPA_FP4_REGNUM) - TYPE_LENGTH (type);
d240 1
a240 1
	regcache_cooked_read_part (regcache, HPPA_FP4_REGNUM, offset,
d243 1
a243 1
	regcache_cooked_write_part (regcache, HPPA_FP4_REGNUM, offset,
d250 1
a250 1
      int offset = register_size (gdbarch, HPPA_FP4_REGNUM) - TYPE_LENGTH (type);
d285 2
a286 2
int
hppa_sign_extend (unsigned val, unsigned bits)
d293 2
a294 2
int
hppa_low_hppa_sign_extend (unsigned val, unsigned bits)
d302 2
a303 2
int
hppa_get_field (unsigned word, int from, int to)
d310 2
a311 2
int
hppa_extract_5_load (unsigned word)
d313 1
a313 1
  return hppa_low_hppa_sign_extend (word >> 16 & MASK_5, 5);
d318 2
a319 2
unsigned
hppa_extract_5r_store (unsigned word)
d326 2
a327 2
unsigned
hppa_extract_5R_store (unsigned word)
d334 2
a335 2
int
hppa_extract_14 (unsigned word)
d337 1
a337 1
  return hppa_low_hppa_sign_extend (word & MASK_14, 14);
d342 2
a343 2
int
hppa_extract_21 (unsigned word)
d349 1
a349 1
  val = hppa_get_field (word, 20, 20);
d351 1
a351 1
  val |= hppa_get_field (word, 9, 19);
d353 1
a353 1
  val |= hppa_get_field (word, 5, 6);
d355 1
a355 1
  val |= hppa_get_field (word, 0, 4);
d357 2
a358 2
  val |= hppa_get_field (word, 7, 8);
  return hppa_sign_extend (val, 21) << 11;
d364 2
a365 2
int
hppa_extract_17 (unsigned word)
d367 3
a369 3
  return hppa_sign_extend (hppa_get_field (word, 19, 28) |
		      hppa_get_field (word, 29, 29) << 10 |
		      hppa_get_field (word, 11, 15) << 11 |
a371 12

CORE_ADDR 
hppa_symbol_address(const char *sym)
{
  struct minimal_symbol *minsym;

  minsym = lookup_minimal_symbol (sym, NULL, NULL);
  if (minsym)
    return SYMBOL_VALUE_ADDRESS (minsym);
  else
    return (CORE_ADDR)-1;
}
d392 2
d395 1
a395 1
record_text_segment_lowaddr (bfd *abfd, asection *section, void *data)
d397 1
a397 1
  if ((section->flags & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
d399 2
a400 7
    {
      bfd_vma value = section->vma - section->filepos;
      CORE_ADDR *low_text_segment_address = (CORE_ADDR *)data;

      if (value < *low_text_segment_address)
          *low_text_segment_address = value;
    }
a409 1

a414 1
      CORE_ADDR low_text_segment_address;
d416 3
a418 1
      /* For ELF targets, then unwinds are supposed to
d424 1
a424 1
      if (gdbarch_tdep (current_gdbarch)->is_elf && text_offset == 0)
a425 2
          low_text_segment_address = -1;

d427 1
a427 2
				 record_text_segment_lowaddr, 
				 &low_text_segment_address);
d429 5
a433 1
	  text_offset = low_text_segment_address;
d505 2
a506 2
  struct hppa_unwind_info *ui;
  struct hppa_objfile_private *obj_private;
d509 2
a510 2
  ui = (struct hppa_unwind_info *) obstack_alloc (&objfile->objfile_obstack,
					   sizeof (struct hppa_unwind_info));
d619 5
a623 8
  obj_private = (struct hppa_objfile_private *) 
	        objfile_data (objfile, hppa_objfile_priv_data);
  if (obj_private == NULL)
    {
      obj_private = (struct hppa_objfile_private *)
	obstack_alloc (&objfile->objfile_obstack, 
                       sizeof (struct hppa_objfile_private));
      set_objfile_data (objfile, hppa_objfile_priv_data, obj_private);
d627 2
d630 1
a643 5
  struct hppa_objfile_private *priv;

  if (hppa_debug)
    fprintf_unfiltered (gdb_stdlog, "{ find_unwind_entry 0x%s -> ",
		        paddr_nz (pc));
d647 1
a647 5
    {
      if (hppa_debug)
	fprintf_unfiltered (gdb_stdlog, "NULL }\n");
      return NULL;
    }
d651 1
a651 1
    struct hppa_unwind_info *ui;
d653 2
a654 3
    priv = objfile_data (objfile, hppa_objfile_priv_data);
    if (priv)
      ui = ((struct hppa_objfile_private *) priv)->unwind_info;
d659 1
a659 2
        priv = objfile_data (objfile, hppa_objfile_priv_data);
	if (priv == NULL)
d661 1
a661 1
        ui = ((struct hppa_objfile_private *) priv)->unwind_info;
d669 1
a669 6
      {
	if (hppa_debug)
	  fprintf_unfiltered (gdb_stdlog, "0x%s (cached) }\n",
            paddr_nz ((CORE_ADDR) ui->cache));
        return ui->cache;
      }
a682 3
	    if (hppa_debug)
	      fprintf_unfiltered (gdb_stdlog, "0x%s }\n",
                paddr_nz ((CORE_ADDR) ui->cache));
a691 4

  if (hppa_debug)
    fprintf_unfiltered (gdb_stdlog, "NULL (not found) }\n");

d695 1
a695 1
static const unsigned char *
d783 20
d814 1
a814 1
hppa32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
d819 3
a834 6

  /* Global pointer (r19) of the function we are trying to call.  */
  CORE_ADDR gp;

  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

d838 2
a839 4
      /* The first parameter goes into sp-36, each stack slot is 4-bytes.  
         struct_ptr is adjusted for each argument below, so the first
	 argument will end up at sp-36.  */
      CORE_ADDR param_ptr = 32;
a840 2
      int small_struct = 0;

a870 6
	  else if (TYPE_CODE (type) == TYPE_CODE_FLT)
            {
	      /* Floating point value store, right aligned.  */
	      param_len = align_up (TYPE_LENGTH (type), 4);
	      memcpy (param_val, VALUE_CONTENTS (arg), param_len);
            }
d873 1
a874 2

	      /* Small struct value are stored right-aligned.  */
a876 7

	      /* Structures of size 5, 6 and 7 bytes are special in that
	         the higher-ordered word is stored in the lower-ordered
		 argument, and even though it is a 8-byte quantity the
		 registers need not be 8-byte aligned.  */
	      if (param_len > 4 && param_len < 8)
		small_struct = 1;
a877 1

d879 1
a879 10
	  if (param_len == 8 && !small_struct)
            param_ptr = align_up (param_ptr, 8);

	  /* First 4 non-FP arguments are passed in gr26-gr23.
	     First 4 32-bit FP arguments are passed in fr4L-fr7L.
	     First 2 64-bit FP arguments are passed in fr5 and fr7.

	     The rest go on the stack, starting at sp-36, towards lower
	     addresses.  8-byte arguments must be aligned to a 8-byte
	     stack boundary.  */
d883 1
a883 5

	      /* There are some cases when we don't know the type
		 expected by the callee (e.g. for variadic functions), so 
		 pass the parameters in both general and fp regs.  */
	      if (param_ptr <= 48)
d885 1
a885 7
		  int grreg = 26 - (param_ptr - 36) / 4;
		  int fpLreg = 72 + (param_ptr - 36) / 4 * 2;
		  int fpreg = 74 + (param_ptr - 32) / 8 * 4;

		  regcache_cooked_write (regcache, grreg, param_val);
		  regcache_cooked_write (regcache, fpLreg, param_val);

d887 1
a887 8
		    {
		      regcache_cooked_write (regcache, grreg + 1, 
					     param_val + 4);

		      regcache_cooked_write (regcache, fpreg, param_val);
		      regcache_cooked_write (regcache, fpreg + 1, 
					     param_val + 4);
		    }
d895 1
a895 1
	  struct_end = sp + align_up (struct_ptr, 64);
d901 2
a902 1
	  param_end = struct_end + align_up (param_ptr, 64);
a910 5
  gp = tdep->find_global_pointer (function);

  if (gp != 0)
    write_register (19, gp);

d912 1
a912 1
  regcache_cooked_write_unsigned (regcache, HPPA_RP_REGNUM, bp_addr);
d915 1
a915 1
  regcache_cooked_write_unsigned (regcache, HPPA_SP_REGNUM, param_end);
d917 2
a918 1
  return param_end;
d935 1
a935 1
hppa64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
d1025 2
a1026 1
	  param_end = struct_end + max (align_up (param_ptr, 16), 64);
d1036 1
a1036 1
  regcache_cooked_write_unsigned (regcache, HPPA_RP_REGNUM, bp_addr);
d1039 1
a1039 1
  regcache_cooked_write_unsigned (regcache, HPPA_SP_REGNUM, param_end + 64);
a1045 16
hppa32_convert_from_func_ptr_addr (struct gdbarch *gdbarch,
				   CORE_ADDR addr,
				   struct target_ops *targ)
{
  if (addr & 2)
    {
      CORE_ADDR plabel;

      plabel = addr & ~3;
      target_read_memory(plabel, (char *)&addr, 4);
    }

  return addr;
}

static CORE_ADDR
d1063 96
d1162 1
a1162 1
static CORE_ADDR
d1165 1
a1165 1
  int flags = read_register_pid (HPPA_FLAGS_REGNUM, ptid);
d1173 1
a1173 1
  return read_register_pid (HPPA_PCOQ_HEAD_REGNUM, ptid) & ~0x3;
d1179 1
a1179 1
static void
d1182 1
a1182 1
  int flags = read_register_pid (HPPA_FLAGS_REGNUM, ptid);
d1192 2
a1193 2
  write_register_pid (HPPA_PCOQ_HEAD_REGNUM, v, ptid);
  write_register_pid (HPPA_PCOQ_TAIL_REGNUM, v + 4, ptid);
d1231 1
a1231 2
/* For the given instruction (INST), return any adjustment it makes
   to the stack pointer or zero for no adjustment. 
d1233 2
a1234 1
   This only handles instructions commonly found in prologues.  */
d1236 2
a1237 2
static int
prologue_inst_adjust_sp (unsigned long inst)
d1239 18
a1256 2
  /* This must persist across calls.  */
  static int save_high21;
d1258 6
a1263 3
  /* The most common way to perform a stack adjustment ldo X(sp),sp */
  if ((inst & 0xffffc000) == 0x37de0000)
    return hppa_extract_14 (inst);
d1265 3
a1267 3
  /* stwm X,D(sp) */
  if ((inst & 0xffe00000) == 0x6fc00000)
    return hppa_extract_14 (inst);
d1269 1
a1269 3
  /* std,ma X,D(sp) */
  if ((inst & 0xffe00008) == 0x73c00008)
    return (inst & 0x1 ? -1 << 13 : 0) | (((inst >> 4) & 0x3ff) << 3);
d1271 3
a1273 5
  /* addil high21,%r1; ldo low11,(%r1),%r30)
     save high bits in save_high21 for later use.  */
  if ((inst & 0xffe00000) == 0x28200000)
    {
      save_high21 = hppa_extract_21 (inst);
a1274 1
    }
d1276 13
a1288 2
  if ((inst & 0xffff0000) == 0x343e0000)
    return save_high21 + hppa_extract_14 (inst);
d1290 14
a1303 3
  /* fstws as used by the HP compilers.  */
  if ((inst & 0xffffffe0) == 0x2fd01220)
    return hppa_extract_5_load (inst);
d1305 4
a1308 3
  /* No adjustment.  */
  return 0;
}
d1310 2
a1311 1
/* Return nonzero if INST is a branch of some kind, else return zero.  */
d1313 2
a1314 4
static int
is_branch (unsigned long inst)
{
  switch (inst >> 26)
d1316 6
a1321 19
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x23:
    case 0x27:
    case 0x28:
    case 0x29:
    case 0x2a:
    case 0x2b:
    case 0x2f:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x38:
    case 0x39:
    case 0x3a:
    case 0x3b:
      return 1;
d1323 7
a1329 2
    default:
      return 0;
a1330 1
}
d1332 2
a1333 2
/* Return the register number for a GR which is saved by INST or
   zero it INST does not save a GR.  */
d1335 3
a1337 9
static int
inst_saves_gr (unsigned long inst)
{
  /* Does it look like a stw?  */
  if ((inst >> 26) == 0x1a || (inst >> 26) == 0x1b
      || (inst >> 26) == 0x1f
      || ((inst >> 26) == 0x1f
	  && ((inst >> 6) == 0xa)))
    return hppa_extract_5R_store (inst);
d1339 5
a1343 5
  /* Does it look like a std?  */
  if ((inst >> 26) == 0x1c
      || ((inst >> 26) == 0x03
	  && ((inst >> 6) & 0xf) == 0xb))
    return hppa_extract_5R_store (inst);
d1345 3
a1347 3
  /* Does it look like a stwm?  GCC & HPC may use this in prologues. */
  if ((inst >> 26) == 0x1b)
    return hppa_extract_5R_store (inst);
d1349 3
a1351 7
  /* Does it look like sth or stb?  HPC versions 9.0 and later use these
     too.  */
  if ((inst >> 26) == 0x19 || (inst >> 26) == 0x18
      || ((inst >> 26) == 0x3
	  && (((inst >> 6) & 0xf) == 0x8
	      || (inst >> 6) & 0xf) == 0x9))
    return hppa_extract_5R_store (inst);
d1353 5
a1357 2
  return 0;
}
d1359 491
a1849 2
/* Return the register number for a FR which is saved by INST or
   zero it INST does not save a FR.
d1861 1
a1861 1
    return hppa_extract_5r_store (inst);
d1863 1
a1863 1
    return hppa_extract_5R_store (inst);
d1866 1
a1866 1
    return hppa_extract_5r_store (inst);
d1868 1
a1868 1
    return hppa_extract_5R_store (inst);
d1959 1
a1959 1
      status = deprecated_read_memory_nobpt (pc, buf, 4);
d2008 1
a2008 1
	      status = deprecated_read_memory_nobpt (pc, buf, 4);
d2021 1
a2021 1
      status = deprecated_read_memory_nobpt (pc + 4, buf, 4);
d2048 1
a2048 1
	      status = deprecated_read_memory_nobpt (pc, buf, 4);
d2054 1
a2054 1
	      status = deprecated_read_memory_nobpt (pc + 4, buf, 4);
d2152 1
a2152 1
static CORE_ADDR
a2192 1
  CORE_ADDR prologue_end;
a2194 4
  if (hppa_debug)
    fprintf_unfiltered (gdb_stdlog, "{ hppa_frame_cache (frame=%d) -> ",
      frame_relative_level(next_frame));

d2196 1
a2196 6
    {
      if (hppa_debug)
        fprintf_unfiltered (gdb_stdlog, "base=0x%s (cached) }", 
          paddr_nz (((struct hppa_frame_cache *)*this_cache)->base));
      return (*this_cache);
    }
d2204 1
a2204 5
    {
      if (hppa_debug)
        fprintf_unfiltered (gdb_stdlog, "base=NULL (no unwind entry) }");
      return (*this_cache);
    }
d2238 2
a2239 1
    CORE_ADDR pc, end_pc;
d2243 2
a2244 12

    /* We have to use hppa_skip_prologue instead of just 
       skip_prologue_using_sal, in case we stepped into a function without
       symbol information.  hppa_skip_prologue also bounds the returned
       pc by the passed in pc, so it will not return a pc in the next
       function.  */
    prologue_end = hppa_skip_prologue (frame_func_unwind (next_frame));
    end_pc = frame_pc_unwind (next_frame);

    if (prologue_end != 0 && end_pc > prologue_end)
      end_pc = prologue_end;

a2245 1

d2250 1
a2250 1
	  && pc < end_pc);
d2255 1
a2255 1
	long status = deprecated_read_memory_nobpt (pc, buf4, sizeof buf4);
d2257 1
a2257 1

d2266 1
a2266 1
	    cache->saved_regs[HPPA_RP_REGNUM].addr = -20;
d2271 1
a2271 1
	    cache->saved_regs[HPPA_RP_REGNUM].addr = -16;
d2290 1
a2290 1
	    if ((inst >> 26) == 0x1b && hppa_extract_14 (inst) >= 0)
d2304 1
a2304 1
		  offset = hppa_low_hppa_sign_extend (inst & 0x1f, 5);
d2306 1
a2306 1
		  offset = hppa_extract_14 (inst);
d2328 1
a2328 1
	  fp_loc = hppa_extract_14 (inst);
d2342 1
a2342 1
		cache->saved_regs[reg + HPPA_FP4_REGNUM + 4].addr = 0;
d2367 7
a2373 53
    CORE_ADDR fp;

    if (hppa_debug)
      fprintf_unfiltered (gdb_stdlog, " (this_sp=0x%s, pc=0x%s, "
		          "prologue_end=0x%s) ",
		          paddr_nz (this_sp),
			  paddr_nz (frame_pc_unwind (next_frame)),
			  paddr_nz (prologue_end));

     /* Check to see if a frame pointer is available, and use it for
        frame unwinding if it is.
 
        There are some situations where we need to rely on the frame
        pointer to do stack unwinding.  For example, if a function calls
        alloca (), the stack pointer can get adjusted inside the body of
        the function.  In this case, the ABI requires that the compiler
        maintain a frame pointer for the function.
 
        The unwind record has a flag (alloca_frame) that indicates that
        a function has a variable frame; unfortunately, gcc/binutils 
        does not set this flag.  Instead, whenever a frame pointer is used
        and saved on the stack, the Save_SP flag is set.  We use this to
        decide whether to use the frame pointer for unwinding.
	
	fp may be zero if it is not available in an inner frame because
	it has been modified by not yet saved.
	
        TODO: For the HP compiler, maybe we should use the alloca_frame flag 
	instead of Save_SP.  */
 
     fp = frame_unwind_register_unsigned (next_frame, HPPA_FP_REGNUM);
 
     if (frame_pc_unwind (next_frame) >= prologue_end
         && u->Save_SP && fp != 0)
      {
 	cache->base = fp;
 
 	if (hppa_debug)
	  fprintf_unfiltered (gdb_stdlog, " (base=0x%s) [frame pointer] }",
 	    paddr_nz (cache->base));
      }
     else if (u->Save_SP 
	      && trad_frame_addr_p (cache->saved_regs, HPPA_SP_REGNUM))
      {
            /* Both we're expecting the SP to be saved and the SP has been
	       saved.  The entry SP value is saved at this frame's SP
	       address.  */
            cache->base = read_memory_integer (this_sp, TARGET_PTR_BIT / 8);

	    if (hppa_debug)
	      fprintf_unfiltered (gdb_stdlog, " (base=0x%s) [saved] }",
			          paddr_nz (cache->base));
      }
d2375 3
a2377 9
      {
        /* The prologue has been slowly allocating stack space.  Adjust
	   the SP back.  */
        cache->base = this_sp - frame_size;
	if (hppa_debug)
	  fprintf_unfiltered (gdb_stdlog, " (base=0x%s) [unwind adjust] } ",
			      paddr_nz (cache->base));

      }
d2384 1
a2384 9
    {
      if (trad_frame_addr_p (cache->saved_regs, 31))
        cache->saved_regs[HPPA_PCOQ_HEAD_REGNUM] = cache->saved_regs[31];
      else
	{
	  ULONGEST r31 = frame_unwind_register_unsigned (next_frame, 31);
	  trad_frame_set_value (cache->saved_regs, HPPA_PCOQ_HEAD_REGNUM, r31);
        }
    }
d2386 1
a2386 17
    {
      if (trad_frame_addr_p (cache->saved_regs, HPPA_RP_REGNUM))
        cache->saved_regs[HPPA_PCOQ_HEAD_REGNUM] = cache->saved_regs[HPPA_RP_REGNUM];
      else
	{
	  ULONGEST rp = frame_unwind_register_unsigned (next_frame, HPPA_RP_REGNUM);
	  trad_frame_set_value (cache->saved_regs, HPPA_PCOQ_HEAD_REGNUM, rp);
	}
    }

  /* If the frame pointer was not saved in this frame, but we should be saving
     it, set it to an invalid value so that another frame will not pick up the 
     wrong frame pointer.  This can happen if we start unwinding after the 
     frame pointer has been modified, but before we've saved it to the
     stack.  */
  if (u->Save_SP && !trad_frame_addr_p (cache->saved_regs, HPPA_FP_REGNUM))
    trad_frame_set_value (cache->saved_regs, HPPA_FP_REGNUM, 0);
a2397 3
  if (hppa_debug)
    fprintf_unfiltered (gdb_stdlog, "base=0x%s }", 
      paddr_nz (((struct hppa_frame_cache *)*this_cache)->base));
d2411 4
a2414 4
			  void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *valuep)
d2417 30
a2446 2
  hppa_frame_prev_register_helper (next_frame, info->saved_regs, regnum,
		                   optimizedp, lvalp, addrp, realnump, valuep);
d2459 2
a2460 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d2462 7
a2468 4
  if (find_unwind_entry (pc))
    return &hppa_frame_unwind;

  return NULL;
d2471 6
a2476 7
/* This is a generic fallback frame unwinder that kicks in if we fail all
   the other ones.  Normally we would expect the stub and regular unwinder
   to work, but in some cases we might hit a function that just doesn't
   have any unwind information available.  In this case we try to do
   unwinding solely based on code reading.  This is obviously going to be
   slow, so only use this as a last resort.  Currently this will only
   identify the stack and pc for the frame.  */
d2478 2
a2479 2
static struct hppa_frame_cache *
hppa_fallback_frame_cache (struct frame_info *next_frame, void **this_cache)
d2481 2
a2482 3
  struct hppa_frame_cache *cache;
  unsigned int frame_size;
  CORE_ADDR pc, start_pc, end_pc, cur_pc;
d2484 7
a2490 3
  cache = FRAME_OBSTACK_ZALLOC (struct hppa_frame_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d2492 5
a2496 3
  pc = frame_func_unwind (next_frame);
  cur_pc = frame_pc_unwind (next_frame);
  frame_size = 0;
d2498 24
a2521 1
  find_pc_partial_function (pc, NULL, &start_pc, &end_pc);
d2523 35
a2557 1
  if (start_pc == 0 || end_pc == 0)
d2559 3
a2561 3
      error ("Cannot find bounds of current function (@@0x%s), unwinding will "
	     "fail.", paddr_nz (pc));
      return cache;
d2564 10
a2573 2
  if (end_pc > cur_pc)
    end_pc = cur_pc;
d2575 6
a2580 3
  for (pc = start_pc; pc < end_pc; pc += 4)
    {
      unsigned int insn;
d2582 15
a2596 1
      insn = read_memory_unsigned_integer (pc, 4);
d2598 4
a2601 1
      frame_size += prologue_inst_adjust_sp (insn);
d2603 6
a2608 6
      /* There are limited ways to store the return pointer into the
	 stack.  */
      if (insn == 0x6bc23fd9) /* stw rp,-0x14(sr0,sp) */
	 cache->saved_regs[HPPA_RP_REGNUM].addr = -20;
      else if (insn == 0x0fc212c1) /* std rp,-0x10(sr0,sp) */
	 cache->saved_regs[HPPA_RP_REGNUM].addr = -16;
d2611 9
a2619 2
  cache->base = frame_unwind_register_unsigned (next_frame, HPPA_SP_REGNUM) - frame_size;
  trad_frame_set_value (cache->saved_regs, HPPA_SP_REGNUM, cache->base);
d2621 19
a2639 1
  if (trad_frame_addr_p (cache->saved_regs, HPPA_RP_REGNUM))
d2641 2
a2642 2
      cache->saved_regs[HPPA_RP_REGNUM].addr += cache->base;
      cache->saved_regs[HPPA_PCOQ_HEAD_REGNUM] = cache->saved_regs[HPPA_RP_REGNUM];
d2646 6
a2651 2
      ULONGEST rp = frame_unwind_register_unsigned (next_frame, HPPA_RP_REGNUM);
      trad_frame_set_value (cache->saved_regs, HPPA_PCOQ_HEAD_REGNUM, rp);
d2654 16
a2669 2
  return cache;
}
d2671 45
a2715 8
static void
hppa_fallback_frame_this_id (struct frame_info *next_frame, void **this_cache,
			     struct frame_id *this_id)
{
  struct hppa_frame_cache *info = 
    hppa_fallback_frame_cache (next_frame, this_cache);
  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
}
d2717 16
a2732 12
static void
hppa_fallback_frame_prev_register (struct frame_info *next_frame,
			  void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *valuep)
{
  struct hppa_frame_cache *info = 
    hppa_fallback_frame_cache (next_frame, this_cache);
  hppa_frame_prev_register_helper (next_frame, info->saved_regs, regnum,
		                   optimizedp, lvalp, addrp, realnump, valuep);
}
d2734 25
a2758 6
static const struct frame_unwind hppa_fallback_frame_unwind =
{
  NORMAL_FRAME,
  hppa_fallback_frame_this_id,
  hppa_fallback_frame_prev_register
};
d2760 25
a2784 5
static const struct frame_unwind *
hppa_fallback_unwind_sniffer (struct frame_info *next_frame)
{
  return &hppa_fallback_frame_unwind;
}
d2786 16
a2801 6
/* Stub frames, used for all kinds of call stubs.  */
struct hppa_stub_unwind_cache
{
  CORE_ADDR base;
  struct trad_frame_saved_reg *saved_regs;
};
d2803 2
a2804 3
static struct hppa_stub_unwind_cache *
hppa_stub_frame_unwind_cache (struct frame_info *next_frame,
			      void **this_cache)
d2806 1
a2806 3
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct hppa_stub_unwind_cache *info;
  struct unwind_table_entry *u;
d2808 3
a2810 2
  if (*this_cache)
    return *this_cache;
d2812 10
a2821 3
  info = FRAME_OBSTACK_ZALLOC (struct hppa_stub_unwind_cache);
  *this_cache = info;
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d2823 23
a2845 1
  info->base = frame_unwind_register_unsigned (next_frame, HPPA_SP_REGNUM);
d2847 1
a2847 1
  if (gdbarch_osabi (gdbarch) == GDB_OSABI_HPUX_SOM)
d2849 11
a2859 6
      /* HPUX uses export stubs in function calls; the export stub clobbers
         the return value of the caller, and, later restores it from the
	 stack.  */
      u = find_unwind_entry (frame_pc_unwind (next_frame));

      if (u && u->stub_unwind.stub_type == EXPORT)
d2861 2
a2862 3
          info->saved_regs[HPPA_PCOQ_HEAD_REGNUM].addr = info->base - 24;

	  return info;
d2864 3
d2869 79
a2947 54
  /* By default we assume that stubs do not change the rp.  */
  info->saved_regs[HPPA_PCOQ_HEAD_REGNUM].realreg = HPPA_RP_REGNUM;

  return info;
}

static void
hppa_stub_frame_this_id (struct frame_info *next_frame,
			 void **this_prologue_cache,
			 struct frame_id *this_id)
{
  struct hppa_stub_unwind_cache *info
    = hppa_stub_frame_unwind_cache (next_frame, this_prologue_cache);
  *this_id = frame_id_build (info->base, frame_pc_unwind (next_frame));
}

static void
hppa_stub_frame_prev_register (struct frame_info *next_frame,
			       void **this_prologue_cache,
			       int regnum, int *optimizedp,
			       enum lval_type *lvalp, CORE_ADDR *addrp,
			       int *realnump, void *valuep)
{
  struct hppa_stub_unwind_cache *info
    = hppa_stub_frame_unwind_cache (next_frame, this_prologue_cache);
  hppa_frame_prev_register_helper (next_frame, info->saved_regs, regnum,
		                   optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind hppa_stub_frame_unwind = {
  NORMAL_FRAME,
  hppa_stub_frame_this_id,
  hppa_stub_frame_prev_register
};

static const struct frame_unwind *
hppa_stub_unwind_sniffer (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);

  if (pc == 0
      || IN_SOLIB_CALL_TRAMPOLINE (pc, NULL)
      || IN_SOLIB_RETURN_TRAMPOLINE (pc, NULL))
    return &hppa_stub_frame_unwind;
  return NULL;
}

static struct frame_id
hppa_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_id_build (frame_unwind_register_unsigned (next_frame,
							 HPPA_SP_REGNUM),
			 frame_pc_unwind (next_frame));
}
d2949 1
a2949 4
static CORE_ADDR
hppa_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_signed (next_frame, HPPA_PCOQ_HEAD_REGNUM) & ~3;
d3042 2
a3043 2
  write_register (HPPA_PCOQ_HEAD_REGNUM, read_register (HPPA_PCOQ_TAIL_REGNUM));
  write_register (HPPA_PCSQ_HEAD_REGNUM, read_register (HPPA_PCSQ_TAIL_REGNUM));
d3045 1
a3045 1
  write_register (HPPA_PCOQ_TAIL_REGNUM, read_register (HPPA_PCOQ_TAIL_REGNUM) + 4);
d3050 15
d3098 2
a3099 2
  const int ipsw = (int) read_register (HPPA_IPSW_REGNUM);
  const int flags = (int) read_register (HPPA_FLAGS_REGNUM);
d3110 1
a3110 1
   if (reg_nr < HPPA_FP4_REGNUM)
d3122 1
a3122 1
   if (reg_nr < HPPA_FP4_REGNUM)
d3131 1
a3131 1
static int
d3135 3
a3137 3
          || regnum == HPPA_PCSQ_HEAD_REGNUM
          || (regnum >= HPPA_PCSQ_TAIL_REGNUM && regnum < HPPA_IPSW_REGNUM)
          || (regnum > HPPA_IPSW_REGNUM && regnum < HPPA_FP4_REGNUM));
d3141 1
a3141 1
static CORE_ADDR
d3160 1
a3160 1
  get_frame_register (frame, HPPA_R0_REGNUM + 26 - argi, &addr);
a3163 52
static void
hppa_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int regnum, void *buf)
{
    ULONGEST tmp;

    regcache_raw_read_unsigned (regcache, regnum, &tmp);
    if (regnum == HPPA_PCOQ_HEAD_REGNUM || regnum == HPPA_PCOQ_TAIL_REGNUM)
      tmp &= ~0x3;
    store_unsigned_integer (buf, sizeof(tmp), tmp);
}

static CORE_ADDR
hppa_find_global_pointer (struct value *function)
{
  return 0;
}

void
hppa_frame_prev_register_helper (struct frame_info *next_frame,
			         struct trad_frame_saved_reg saved_regs[],
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *valuep)
{
  if (regnum == HPPA_PCOQ_TAIL_REGNUM)
    {
      if (valuep)
	{
	  CORE_ADDR pc;

	  trad_frame_get_prev_register (next_frame, saved_regs,
					HPPA_PCOQ_HEAD_REGNUM, optimizedp,
					lvalp, addrp, realnump, valuep);

	  pc = extract_unsigned_integer (valuep, 4);
	  store_unsigned_integer (valuep, 4, pc + 4);
	}

      /* It's a computed value.  */
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      return;
    }

  trad_frame_get_prev_register (next_frame, saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
}


d3219 1
a3219 1
  tdep = XZALLOC (struct gdbarch_tdep);
a3230 2
  tdep->find_global_pointer = hppa_find_global_pointer;

d3262 5
a3266 1
  set_gdbarch_inner_than (gdbarch, core_addr_greaterthan);
a3269 1
  set_gdbarch_cannot_fetch_register (gdbarch, hppa_cannot_store_register);
a3292 2
      set_gdbarch_convert_from_func_ptr_addr
        (gdbarch, hppa32_convert_from_func_ptr_addr);
a3314 3
  set_gdbarch_breakpoint_from_pc (gdbarch, hppa_breakpoint_from_pc);
  set_gdbarch_pseudo_register_read (gdbarch, hppa_pseudo_register_read);

d3318 2
a3323 5
  /* Hook in the default unwinders.  */
  frame_unwind_append_sniffer (gdbarch, hppa_stub_unwind_sniffer);
  frame_unwind_append_sniffer (gdbarch, hppa_frame_unwind_sniffer);
  frame_unwind_append_sniffer (gdbarch, hppa_fallback_unwind_sniffer);

d3330 1
a3330 5
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  fprintf_unfiltered (file, "bytes_per_address = %d\n", 
                      tdep->bytes_per_address);
  fprintf_unfiltered (file, "elf = %s\n", tdep->is_elf ? "yes" : "no");
a3342 2
  hppa_objfile_priv_data = register_objfile_data ();

d3376 1
a3377 7
  /* Debug this files internals. */
  deprecated_add_show_from_set
    (add_set_cmd ("hppa", class_maintenance, var_zinteger,
		  &hppa_debug, "Set hppa debugging.\n\
When non-zero, hppa specific debugging is enabled.", &setdebuglist),
     &showdebuglist);
}
@


1.116
log
@2004-02-11  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa_gdbarch_init): Re-order so that the frame and
	abi code are are separatly grouped.
@
text
@d5220 1
a5220 2
  set_gdbarch_frameless_function_invocation
    (gdbarch, hppa_frameless_function_invocation);
@


1.115
log
@2004-02-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_SKIP): Default to 0.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@a5122 11
        set_gdbarch_deprecated_call_dummy_length
          (gdbarch, hppa32_call_dummy_length);
        set_gdbarch_deprecated_stack_align (gdbarch, hppa32_stack_align);
        set_gdbarch_deprecated_reg_struct_has_addr
	  (gdbarch, hppa_reg_struct_has_addr);
        set_gdbarch_deprecated_extract_return_value
          (gdbarch, hppa32_extract_return_value);
        set_gdbarch_use_struct_convention
          (gdbarch, hppa32_use_struct_convention);
        set_gdbarch_deprecated_store_return_value
          (gdbarch, hppa32_store_return_value);
a5128 11
        set_gdbarch_deprecated_call_dummy_breakpoint_offset
          (gdbarch, hppa64_call_dummy_breakpoint_offset);
        set_gdbarch_deprecated_call_dummy_length
          (gdbarch, hppa64_call_dummy_length);
        set_gdbarch_deprecated_stack_align (gdbarch, hppa64_stack_align);
        set_gdbarch_deprecated_extract_return_value
          (gdbarch, hppa64_extract_return_value);
        set_gdbarch_use_struct_convention
          (gdbarch, hppa64_use_struct_convention);
        set_gdbarch_deprecated_store_return_value
          (gdbarch, hppa64_store_return_value);
a5154 1
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, hppa_saved_pc_after_call);
a5165 1
  set_gdbarch_deprecated_store_struct_return (gdbarch, hppa_store_struct_return);
a5166 10
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, hppa_init_extra_frame_info);
  set_gdbarch_deprecated_frame_chain (gdbarch, hppa_frame_chain);
  set_gdbarch_deprecated_frame_chain_valid (gdbarch, hppa_frame_chain_valid);
  set_gdbarch_frameless_function_invocation
    (gdbarch, hppa_frameless_function_invocation);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, hppa_frame_saved_pc);
  set_gdbarch_deprecated_push_dummy_frame (gdbarch, hppa_push_dummy_frame);
  set_gdbarch_deprecated_pop_frame (gdbarch, hppa_pop_frame);
  /* set_gdbarch_deprecated_fix_call_dummy (gdbarch, hppa_fix_call_dummy); */
  set_gdbarch_deprecated_push_arguments (gdbarch, hppa_push_arguments);
d5184 41
@


1.114
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (dbx_symfile_init, start_psymtab, end_psymtab,
	coffstab_build_psymtabs, elfstab_build_psymtabs)
	(stabsect_build_psymtabs): Replace psymbol_obstack with
	objfile_obstack.
	* dwarf2-frame.c (decode_frame_entry_1): Ditto.
	* dwarf2read.c (dwarf2_build_psymtabs_hard, dwarf2_read_section):
	Ditto.
	* dwarfread.c (scan_compilation_units): Ditto.
	* elfread.c (elfstab_offset_sections): Ditto.
	* hppa-tdep.c (read_unwind_info): Ditto.
	* hpread.c (hpread_build_psymtabs, hpread_start_psymtab)
	(hpread_end_psymtab): Ditto.
	* mdebugread.c (mdebug_build_psymtabs, add_pending)
	(parse_partial_symbols, new_psymtab, elfmdebug_build_psymtabs):
	Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* objfiles.c (add_to_objfile_sections)
	(build_objfile_section_table): Ditto.
	(allocate_objfile): Remove init of psymbol_obstack.
	(free_objfile): Remove freeing of psymbol_obstack.
	* objfiles.h (struct objfile): Remove field
	psymbol_obstack. Update comments.
	* pa64solib.c (pa64_solib_add_solib_objfile): Replace
	psymbol_obstack with objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
        psymbol_obstack.
	* somread.c (som_symfile_offsets, init_import_symbols)
	(init_export_symbols): Replace psymbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
	* symfile.c (default_symfile_offsets, syms_from_objfile)
	(reread_symbols): Remove freeing and init of psymbol_obstack.
	(cashier_psymtab): Update comment.
	* symmisc.c (print_objfile_statistics): Don't report stats for
	psymbol obstack.
	* symtab.h (struct general_symbol_info, struct partial_symtab):
	Update comments.
	* xcoffread.c (xcoff_start_psymtab, xcoff_end_psymtab, swap_sym)
	(xcoff_symfile_offsets): Replace psymbol_obstack with
	objfile_obstack.
@
text
@a5196 1
  set_gdbarch_frame_args_skip (gdbarch, 0);
@


1.113
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* mcore-tdep.c: Update copyright.
	(mcore_extract_struct_value_address): Delete function.  Update
	comments.
	(mcore_gdbarch_init): Update.
	* mn10300-tdep.c: Update copyright.
	(mn10300_extract_struct_value_address): Delete function.
	(mn10300_gdbarch_init): Update.
	* v850-tdep.c: Update copyright.
	(v850_extract_struct_value_address): Delete.
	(v850_gdbarch_init): Update.
	* ns32k-tdep.c: Update copyright.
	(ns32k_extract_struct_value_address): Delete.
	(ns32k_gdbarch_init): Update.
	* hppa-tdep.c (hppa_extract_struct_value_address): Delete.
	(hppa_gdbarch_init): Update.
	* vax-tdep.c: Update copyright.
	(vax_extract_struct_value_address): Delete.
	(vax_gdbarch_init): Update.
@
text
@d513 1
a513 1
  ui = (struct obj_unwind_info *) obstack_alloc (&objfile->psymbol_obstack,
d563 1
a563 1
    obstack_alloc (&objfile->psymbol_obstack, total_size);
d626 1
a626 1
	obstack_alloc (&objfile->psymbol_obstack,
@


1.112
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c: Update copyright year.
	(hppa_target_write_pc): Use PCOQ_TAIL_REGNUM instead
	of NPC_REGNUM.
	(hppa_gdbarch_init): Do not set deprecated_npc_regnum.
@
text
@a196 1
CORE_ADDR hppa_extract_struct_value_address (char *regbuf);
a5010 20

CORE_ADDR
hppa_extract_struct_value_address (char *regbuf)
{
  /* Extract from an array REGBUF containing the (raw) register state
     the address in which a function should return its structure value,
     as a CORE_ADDR (or an expression that can be used as one).  */
  /* FIXME: brobecker 2002-12-26.
     The current implementation is historical, but we should eventually
     implement it in a more robust manner as it relies on the fact that
     the address size is equal to the size of an int* _on the host_...
     One possible implementation that crossed my mind is to use
     extract_address.  */
  /* FIXME: cagney/2003-09-27: This function can probably go.  ELZ
     writes: We cannot assume on the pa that r28 still contains the
     address of the returned structure. Usually this will be
     overwritten by the callee.  */
  return (*(int *)(regbuf + DEPRECATED_REGISTER_BYTE (28)));
}

a5189 2
  set_gdbarch_deprecated_extract_struct_value_address
    (gdbarch, hppa_extract_struct_value_address);
@


1.111
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DECR_PC_AFTER_BREAK): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	DECR_PC_AFTER_BREAK to zero.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* i386-nto-tdep.c (i386nto_init_abi): Add comment.
@
text
@d4 2
a5 1
   1996, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d2613 1
a2613 1
  write_register_pid (DEPRECATED_NPC_REGNUM, v + 4, ptid);
a5204 1
  set_gdbarch_deprecated_npc_regnum (gdbarch, PCOQ_TAIL_REGNUM);
@


1.110
log
@2004-01-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FUNCTION_START_OFFSET): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	FUNCTION_START_OFFSET.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@a5198 1
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
@


1.109
log
@2003-12-18  Michael Chastain  <mec.gnu@@mindspring.com>

	* hppa-tdep.c (hppa_gdbarch_init): Set long double floating
	point type to floatformat_ia64_quad_big.
@
text
@a5191 1
  set_gdbarch_function_start_offset (gdbarch, 0);
@


1.108
log
@2003-12-18  Michael Chastain  <mec.gnu@@mindspring.com>

	* hppa-tdep.c (hppa_gdbarch_init): Set sizeof(long_double) to 128.
	Document type sizes for hppa*-*-hpux* compilers available to me.
@
text
@d5095 5
d5188 1
@


1.107
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@d5067 30
d5177 4
d5182 1
a5182 1
  set_gdbarch_ptr_bit (gdbarch, tdep->bytes_per_address * TARGET_CHAR_BIT);
@


1.106
log
@2003-11-22  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa_value_returned_from_stack): Delete function.
	* config/pa/tm-hppa.h (hppa_value_returned_from_stack): Delete
	declaration.
	(DEPRECATED_VALUE_RETURNED_FROM_STACK): Delete macro.
	* infcall.c (call_function_by_hand): Delete #ifdef
	DEPRECATED_VALUE_RETURNED_FROM_STACK code.
	* infcmd.c (print_return_value): Ditto.
@
text
@d3382 1
a3382 1
		&& STREQ (DEPRECATED_SYMBOL_NAME (msymbol), DEPRECATED_SYMBOL_NAME (msym)))
@


1.105
log
@2003-10-16  Elena Zannoni  <ezannoni@@redhat.com>

	* minsyms.c (lookup_minimal_symbol_solib_trampoline): Remove
	second parameter, which is always null. Remove
	SOFUN_ADDRESS_MAYBE_MISSING ifdeffed code.
	* symtab.h (lookup_minimal_symbol_solib_trampoline): Update
	accordingly.
	* somsolib.c (som_solib_create_inferior_hook,
	som_solib_desire_dynamic_linker_symbols): Update callers.
	* hppa-tdep.c (hppa_fix_call_dummy): Ditto.
@
text
@a2062 24
/* elz: this function returns a value which is built looking at the given address.
   It is called from call_function_by_hand, in case we need to return a 
   value which is larger than 64 bits, and it is stored in the stack rather than 
   in the registers r28 and r29 or fr4.
   This function does the same stuff as value_being_returned in values.c, but
   gets the value from the stack rather than from the buffer where all the
   registers were saved when the function called completed. */
/* FIXME: cagney/2003-09-27: This function is no longer needed.  The
   inferior function call code now directly handles the case described
   above.  */
struct value *
hppa_value_returned_from_stack (struct type *valtype, CORE_ADDR addr)
{
  struct value *val;

  val = allocate_value (valtype);
  CHECK_TYPEDEF (valtype);
  target_read_memory (addr, VALUE_CONTENTS_RAW (val), TYPE_LENGTH (valtype));

  return val;
}



@


1.104
log
@	* hppa-tdep.c (hppa_in_solib_call_trampoline): Don't refer directly to
	_cooked_size and vma;  Use bfd_section_size and bfd_get_section_vma.
	Correct test for pc within section.
@
text
@d2379 1
a2379 1
	      (DEPRECATED_SYMBOL_NAME (funsymbol), NULL, objfile);
@


1.103
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d3098 3
a3100 2
    if (sec->vma <= pc
	&& sec->vma + sec->_cooked_size < pc)
@


1.102
log
@2003-10-01  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c (call_function_by_hand): When STRUCT_RETURN, always
	use STRUCT_ADDR.  When not using "struct return convention", pass
	"0" to "value_being_returned".  Add FIXMEs.
	* infcmd.c (print_return_value): Pass an explicit 0/1 to
	value_being_returned.  Add comments.
	* values.c (value_being_returned): Add fixme.
	* hppa-tdep.c (hppa_extract_struct_value_address): Add FIXME.
	(hppa_value_returned_from_stack): Add FIXME.
@
text
@d2986 1
a2986 1
  memcpy (virtual_buffer, raw_buffer, REGISTER_RAW_SIZE (i));
d3004 2
a3005 2
      memcpy (virtual_buffer + REGISTER_RAW_SIZE (i), raw_buffer,
	      REGISTER_RAW_SIZE (i));
d3032 1
a3032 1
  memcpy (virtual_buffer, raw_buffer, REGISTER_RAW_SIZE (i));
d3043 2
a3044 1
      memcpy (virtual_buffer + REGISTER_RAW_SIZE (i), raw_buf, REGISTER_RAW_SIZE (i));
@


1.101
log
@2003-09-29  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_VIRTUAL_TYPE): Rename
	DEPRECATED_REGISTER_VIRTUAL_TYPE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arch-utils.c,	hppa-tdep.c, regcache.c, regcache.h: Update.
	* sh64-tdep.c, sparc-tdep.c: Update.

2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_VIRTUAL_TYPE to DEPRECATED_REGISTER_VIRTUAL_TYPE.
@
text
@d2070 3
d5046 4
@


1.100
log
@2003-09-28  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_read_unsigned_register): Delete function.
	* frame.h (frame_read_unsigned_register): Delete declaration.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	get_frame_register_unsigned.
	(sparc_frame_saved_pc, sparc_pop_frame): Ditto.
	* m68hc11-tdep.c (m68hc11_print_register): Ditto.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.

	* frame.h (frame_read_register): Delete declaration.
	* frame.c (frame_read_register): Delete function.
	* arch-utils.c (legacy_register_to_value): Use get_frame_register.
	* sparc-tdep.c (sparc_fetch_pointer_argument): Ditto.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* hppa-tdep.c (hppa_fetch_pointer_argument): Ditto.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.

	* frame.c (frame_read_signed_register): Delete function.
	(frame_read_unsigned_register): Update comments.
	* frame.h (frame_read_signed_register): Delete declaration.
	* h8300-tdep.c (h8300_print_register): Use
	get_frame_register_signed.
	* m68hc11-tdep.c (m68hc11_print_register): Ditto.
@
text
@d2989 1
a2989 1
  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0, gdb_stdout, 0,
d3048 1
a3048 1
      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0, stream, 0,
@


1.99
log
@2003-09-25  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_frame_saved_regs): Rename
	get_frame_saved_regs.
	* cris-tdep.c, frame.c, h8300-tdep.c, hppa-tdep.c: Update.
	* mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, ppc-linux-tdep.c, rs6000-tdep.c: Update.
	* s390-tdep.c, sh64-tdep.c, stack.c: Update.
	* v850-tdep.c, vax-tdep.c, xstormy16-tdep.c: Update.
@
text
@d5078 1
a5078 1
  frame_read_register (frame, R0_REGNUM + 26 - argi, &addr);
@


1.98
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_NPC_REGNUM): Deprecate NPC_REGNUM.
	* gdbarch.h, gdbarch.c: Regenerate.
	* core-sol2.c, hppa-tdep.c, lynx-nat.c, procfs.c: Update.
	* regcache.c, remote-vxsparc.c, sparc-linux-nat.c: Update.
	* sparc-nat.c, sparc-tdep.c, sparc64-tdep.c: Update.
	* sparcnbsd-tdep.c: Update.
@
text
@d1093 1
a1093 1
	  saved_regs = get_frame_saved_regs (get_next_frame (frame));
d1133 1
a1133 1
	  saved_regs = get_frame_saved_regs (get_next_frame (frame));
d1407 1
a1407 1
	  saved_regs = get_frame_saved_regs (tmp_frame);
d1458 1
a1458 1
	      saved_regs = get_frame_saved_regs (tmp_frame);
d1496 1
a1496 1
	  saved_regs = get_frame_saved_regs (tmp_frame);
d1701 1
a1701 1
  fsr = get_frame_saved_regs (frame);
d4251 1
a4251 1
  if (get_frame_saved_regs (frame) == NULL)
d4253 1
a4253 1
  hppa_frame_find_saved_regs (frame, get_frame_saved_regs (frame));
@


1.97
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTE): Rename REGISTER_BYTE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-linux-tdep.c, core-sol2.c, cris-tdep.c: Update.
	* d10v-tdep.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, irix5-nat.c, lynx-nat.c, m68knbsd-nat.c: Update.
	* mcore-tdep.c, mips-linux-tdep.c, mips-tdep.c: Update.
	* mipsv4-nat.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* ns32knbsd-nat.c, ppc-bdm.c, regcache.c, remote-sds.c: Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh64-tdep.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, v850-tdep.c: Update.
	* v850ice.c, vax-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-cisco.h, config/m68k/tm-delta68.h: Update.
	* config/pa/nm-hppah.h: Update.

2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* mi/mi-main.c: Rename REGISTER_BYTE to DEPRECATED_REGISTER_BYTE.
@
text
@d2633 1
a2633 1
  write_register_pid (NPC_REGNUM, v + 4, ptid);
d5181 1
a5181 1
  set_gdbarch_npc_regnum (gdbarch, PCOQ_TAIL_REGNUM);
@


1.96
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@d1636 1
a1636 1
      deprecated_read_register_bytes (REGISTER_BYTE (regnum),
d1717 1
a1717 1
	deprecated_write_register_bytes (REGISTER_BYTE (regnum),
d2682 2
a2683 1
    frame_register_read (deprecated_selected_frame, i, raw_regs + REGISTER_BYTE (i));
d2727 2
a2728 1
    frame_register_read (deprecated_selected_frame, i, raw_regs + REGISTER_BYTE (i));
d2797 1
a2797 1
      raw_val[1] = *(long *) (raw_regs + REGISTER_BYTE (regnum));
d4821 1
a4821 1
  deprecated_write_register_bytes (REGISTER_BYTE (28)
d4827 1
a4827 1
    deprecated_write_register_bytes (REGISTER_BYTE (FP4_REGNUM),
d4838 1
a4838 1
      (REGISTER_BYTE (FP4_REGNUM)
d4843 1
a4843 1
      (REGISTER_BYTE (28)
d4848 1
a4848 1
      (REGISTER_BYTE (28),valbuf, TYPE_LENGTH (type));
d4851 1
a4851 1
      deprecated_write_register_bytes (REGISTER_BYTE (28),valbuf, 8);
d4853 1
a4853 1
        (REGISTER_BYTE (29), valbuf + 8, TYPE_LENGTH (type) - 8);
d4868 1
a4868 1
    memcpy (valbuf, regbuf + REGISTER_BYTE (FP4_REGNUM), TYPE_LENGTH (type));
d4872 1
a4872 1
	     + REGISTER_BYTE (28)
d4890 1
a4890 1
            regbuf + REGISTER_BYTE (FP4_REGNUM)
d4895 1
a4895 1
            regbuf + REGISTER_BYTE (28)
d4899 2
a4900 1
    memcpy (valbuf, regbuf + REGISTER_BYTE (28), TYPE_LENGTH (type));
d4903 3
a4905 2
      memcpy (valbuf, regbuf + REGISTER_BYTE (28), 8);
      memcpy (valbuf + 8, regbuf + REGISTER_BYTE (29), TYPE_LENGTH (type) - 8);
d5043 1
a5043 1
  return (*(int *)(regbuf + REGISTER_BYTE (28)));
@


1.95
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d2071 1
a2071 1
hppa_value_returned_from_stack (register struct type *valtype, CORE_ADDR addr)
@


1.94
log
@* cris-tdep.c (cris_gdbarch_init): Set
deprecated_reg_struct_has_addr instead of reg_struct_has_addr.
* hppa-tdep.c (hppa_gdbarch_init): Likewise.
* mcore-tdep.c (mcore_gdbarch_init): Likewise.
* mips-tdep.c (mips_gdbarch_init): Likewise.
* mn10300-tdep.c (mn10300_gdbarch_init): Likewise.
* sparc-tdep.c (sparc_gdbarch_init): Likewise.
@
text
@d1591 1
a1591 1
  register int regnum;
d1693 3
a1695 3
  register struct frame_info *frame = get_current_frame ();
  register CORE_ADDR fp, npc, target_pc;
  register int regnum;
d2073 1
a2073 1
  register struct value *val;
d2773 1
a2773 1
  register int i;
@


1.93
log
@2003-09-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STACK_ALIGN): Rename STACK_ALIGN.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Update.
	* hppa-tdep.c (hppa_push_arguments): Update.
	* ada-lang.c (place_on_stack): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Delete comment refering to
	stack_align.
@
text
@d5122 2
a5123 1
        set_gdbarch_reg_struct_has_addr (gdbarch, hppa_reg_struct_has_addr);
@


1.92
log
@        * hppa-tdep.c: Include "dis-asm.h". Fixes a build failure.
        * Makefile.in (hppa-tdep.o): Update dependencies.
@
text
@d1873 1
a1873 1
  CORE_ADDR orig_sp = STACK_ALIGN (sp);
d1936 1
a1936 1
  cum_bytes_aligned = STACK_ALIGN (cum_bytes_reserved);
d2043 1
a2043 1
  cum_bytes_aligned = STACK_ALIGN (cum_bytes_reserved);
d5121 1
a5121 1
        set_gdbarch_stack_align (gdbarch, hppa32_stack_align);
d5139 1
a5139 1
        set_gdbarch_stack_align (gdbarch, hppa64_stack_align);
@


1.91
log
@2003-09-04  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa_gdbarch_init): Set
	"have_nonsteppable_watchpoint".
	* config/pa/nm-hppah.h (HAVE_NONSTEPPABLE_WATCHPOINT): Delete.
	* mips-tdep.c (mips_dump_tdep): Do not print
	HAVE_NONSTEPPABLE_WATCHPOINT.
	(mips_gdbarch_init): Set "have_nonsteppable_watchpoint".
	* config/mips/tm-embed.h (HAVE_NONSTEPPABLE_WATCHPOINT): Delete.
	* config/mips/nm-irix5.h (HAVE_NONSTEPPABLE_WATCHPOINT): Delete.
	* config/mips/nm-irix4.h (HAVE_NONSTEPPABLE_WATCHPOINT): Delete.
@
text
@d40 1
@


1.90
log
@2003-08-27  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (cris-tdep.o): Update dependencies.
	* cris-tdep.c: Include "gdb_assert.h".
	(cris_gdbarch_init): Set print_insn.
	(_initialize_cris_tdep): Do not set deprecated_tm_print_insn.
	(cris_delayed_get_disassembler): Simplify, directly call the
	disassembler returned by cris_get_disassembler.
	* hppa-tdep.c (hppa_gdbarch_init): Set print_insn.
	(_initialize_hppa_tdep): Do not set deprecated_tm_print_insn.
	* ns32k-tdep.c (ns32k_gdbarch_init): Set print_insn.
	(_initialize_ns32k_tdep): Do not set deprecated_tm_print_insn.
	* mn10300-tdep.c (mn10300_gdbarch_init): Set print_insn.
	(_initialize_mn10300_tdep): Do not set deprecated_tm_print_insn.
	* mcore-tdep.c (mcore_gdbarch_init): Set print_insn.
	(_initialize_mcore_tdep): Do not set deprecated_tm_print_insn.
	* frv-tdep.c (frv_gdbarch_init): Set print_insn.
	(_initialize_frv_tdep): Do not set deprecated_tm_print_insn.
	* sparc-tdep.c (sparc_gdbarch_init): Set print_insn.
	(gdb_print_insn_sparc): Delete function.
	(_initialize_sparc_tdep): Do not set deprecated_tm_print_insn or
	deprecated_tm_print_insn_info.
	* v850-tdep.c (v850_gdbarch_init): Set print_insn.
	(_initialize_v850_tdep): Do not set deprecated_tm_print_insn.
	(v850_gdbarch_init): Do not set deprecated_tm_print_insn_info.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set print_insn.
	(_initialize_xstormy16_tdep): Do not set deprecated_tm_print_insn.
	* s390-tdep.c (gdb_print_insn_s390): Delete function.
	(_initialize_s390_tdep): Do not set deprecated_tm_print_insn.
	(s390_gdbarch_init): Set print_insn.
@
text
@d5208 6
@


1.89
log
@        Further multiarching work mostly for hppa64-*-hpux11:
        * hppa-tdep.h: New file.
        * hppa-tdep.c: #include hppa-tdep.c.
        (hppa32_num_regs): Renamed from hppa_num_regs.
        (hppa64_num_regs): New constant.
        (hppa64_call_dummy_breakpoint_offset): New constant.
        (hppa32_call_dummy_length): New constant.
        (hppa64_call_dummy_length): New constant.
        (hppa32_stack_align): Make name 32bit explicit.
        (hppa32_register_virtual_type): Likewise.
        (hppa32_extract_return_value): Likewise.
        (hppa32_use_struct_convention): Likewise.
        (hppa32_store_return_value): Likewise.
        (hppa64_register_virtual_type): New function.
        (hppa64_extract_return_value): New function.
        (hppa64_use_struct_convention): New function.
        (hppa64_store_return_value): New function.
        (hppa_frame_locals_address): Remove declaration, function does
        not exist anymore.
        (hppa_register_byte): Add support for PA64 ABI.
        (hppa_gdbarch_init): Add support for PA64 ABI.
        * hppa-hpux-tdep.c (hppa32_hpux_frame_saved_pc_in_sigtramp):
        Make name 32bit explicit.
        (hppa32_hpux_frame_base_before_sigtramp): Likewise.
        (hppa32_hpux_frame_find_saved_regs_in_sigtramp): Likewise.
        (hppa64_hpux_frame_saved_pc_in_sigtramp): New function.
        (hppa64_hpux_frame_base_before_sigtramp): New function.
        (hppa64_hpux_frame_find_saved_regs_in_sigtramp): New function.
        * config/pa/tm-hppa64.h: Remove macros that are no longer
        necessary now that the gdbarch vector is properly setup.
        Transform some macros into function calls. Some minor cleanup.
        * config/pa/tm-hppah.h: Update function calls in macros
        following the function renaming in hppa-hpux-tdep.c.
        * Makefile.in (hppa_tdep_h): New variable.
        (hppa-tdep.o): Add dependency over hppa_tdep_h.
@
text
@d5206 2
a5228 1
  deprecated_tm_print_insn = print_insn_hppa;
@


1.88
log
@       * hppa-tdep.c (hppa_gdbarch_init): Perform the ABI-specific gdbarch
       initialization after the common gdbarch initialization, not before.
@
text
@d67 1
d70 11
a80 1
static const int hppa_num_regs = 128;
d178 2
a179 1
CORE_ADDR hppa_stack_align (CORE_ADDR sp);
d184 2
a185 1
struct type * hppa_register_virtual_type (int reg_nr);
d187 8
a194 3
void hppa_extract_return_value (struct type *type, char *regbuf, char *valbuf);
int hppa_use_struct_convention (int gcc_p, struct type *type);
void hppa_store_return_value (struct type *type, char *valbuf);
a202 1
CORE_ADDR hppa_frame_locals_address (struct frame_info *fi);
d237 1
a237 1
hppa_use_struct_convention (int gcc_p, struct type *type)
d241 9
a249 1

d709 1
a709 1
hppa_register_name (int i)
d4810 1
a4810 1
hppa_store_return_value (struct type *type, char *valbuf)
d4828 26
d4862 1
a4862 1
hppa_extract_return_value (struct type *type, char *regbuf, char *valbuf)
d4865 1
a4865 3
    memcpy (valbuf,
	    (char *)regbuf + REGISTER_BYTE (FP4_REGNUM),
	    TYPE_LENGTH (type));
d4868 1
a4868 1
	    ((char *)regbuf
d4876 28
d4920 1
a4920 1
hppa_stack_align (CORE_ADDR sp)
d4928 7
d4988 3
a4990 1
  return reg_nr * 4;
d4997 1
a4997 1
hppa_register_virtual_type (int reg_nr)
d5005 12
d5080 1
d5097 61
a5157 1
  gdbarch = gdbarch_alloc (&info, NULL);
d5159 2
a5160 1
  set_gdbarch_reg_struct_has_addr (gdbarch, hppa_reg_struct_has_addr);
a5168 1
  set_gdbarch_stack_align (gdbarch, hppa_stack_align);
d5170 1
a5170 2
  set_gdbarch_deprecated_register_size (gdbarch, 4);
  set_gdbarch_num_regs (gdbarch, hppa_num_regs);
a5176 1
  set_gdbarch_deprecated_register_bytes (gdbarch, hppa_num_regs * 4);
d5179 1
a5179 1
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 4);
a5180 2
  set_gdbarch_deprecated_register_virtual_type (gdbarch, hppa_register_virtual_type);
  set_gdbarch_register_name (gdbarch, hppa_register_name);
a5181 4
  set_gdbarch_deprecated_extract_return_value (gdbarch,
                                               hppa_extract_return_value);
  set_gdbarch_use_struct_convention (gdbarch, hppa_use_struct_convention);
  set_gdbarch_deprecated_store_return_value (gdbarch, hppa_store_return_value);
a5193 1
  set_gdbarch_deprecated_call_dummy_length (gdbarch, INSTRUCTION_SIZE * 28);
@


1.87
log
@        * hppa-tdep.c (hppa_gdbarch_init): Set the addr_bits_remove
        gdbarch method to clear the 2 low bits of text addresses.
@
text
@a4999 3
  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

d5055 3
@


1.86
log
@2003-07-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (REGISTER_NAME): Do not supply a default.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h (REGISTER_NAME): Define.
	(legacy_register_name): Declare.
	* config/sparc/tm-sp64.h (legacy_register_name): Declare.
	(REGISTER_NAME): Define.
	* sparc-tdep.c (legacy_register_name): New function.
	* config/pa/tm-hppa64.h (REGISTER_NAMES): Delete macro.
	(REGISTER_NAME): Define.
	(hppa64_register_name): Declare.
	* config/pa/tm-hppa.h (REGISTER_NAMES): Delete macro.
	* hppa-tdep.c (hppa_gdbarch_init): Set hppa_register_name.
	(hppa64_register_name): New function.
	(hppa_register_name): New function.
	* arch-utils.c (legacy_register_name): Delete.
	* arch-utils.h (legacy_register_name): Delete.
@
text
@d5049 1
@


1.85
log
@	* arch-utils.c (default_prepare_to_proceed): Remove.
	(generic_prepare_to_proceed): Remove.
	* arch-utils.h (default_prepare_to_proceed): Remove prototype.
	(generic_prepare_to_proceed): Remove prototype.
	* gdbarch.sh (PREPARE_TO_PROCEED): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-tdep.c (hppa_prepare_to_proceed): Remove dangling prototype.
	* hppah-nat.c (hppa_switched_threads): Remove.
	* infrun.c (prepare_to_proceed): New static function, copied from
	generic_prepare_to_proceed.  Remove select_it argument.
	(proceed): Call prepare_to_proceed.
	* infttrace.c (old_gdb_pid, reported_pid, reported_bpt): Remove
	variables.
	(ptrace_wait): Don't set the removed variables.
	(hppa_switched_threads): Remove.
	* lin-lwp.c (lin_lwp_prepare_to_proceed): Remove.
	* config/nm-linux.h (PREPARE_TO_PROCEED): Don't define.
	(lin_lwp_prepare_to_proceed): Remove prototype.
	* config/i386/nm-x86-64linux.h (PREPARE_TO_PROCEED): Don't undefine.
	* config/pa/nm-hppah.h (PREPARE_TO_PROCEED): Don't define.
@
text
@d681 82
d5028 1
@


1.85.2.1
log
@2003-07-27  Andrew Cagney  <cagney@@redhat.com>

	Sync HP/UX with mainline:
	* config/pa/tm-hppa.h (init_frame_pc_default): Declare.
	* infcall.c (legacy_push_dummy_code) [GDB_TARGET_IS_HPPA]: Update
	REAL_PC and not the pointer.
	* hppa-hpux-tdep.c: Include frame.h
	* config/pa/tm-hppa64.h (GDB_MULTI_ARCH): Set to
	GDB_MULTI_ACH_PARTIAL.
	* config/pa/tm-hppa64.h (FRAME_SAVED_PC_IN_SIGTRAMP): Use
	get_frame_base.
	(FRAME_BASE_BEFORE_SIGTRAMP): Ditto.
	(FRAME_FIND_SAVED_REGS_IN_SIGTRAMP): Ditto.
	(struct value): Add opaque declaration.
	(DEPRECATED_FRAME_ARGS_ADDRESS): Delete.
	* config/pa/tm-hppa64.h (REGISTER_NAMES): Delete macro.
	(REGISTER_NAME): Define.
	(hppa64_register_name): Declare.
	* config/pa/tm-hppa.h (REGISTER_NAMES): Delete macro.
	* hppa-tdep.c (hppa_gdbarch_init): Set hppa_register_name.
	(hppa64_register_name): New function.
	(hppa_register_name): New function.
@
text
@a680 82
/* Return the name of a register.  */

const char *
hppa_register_name (int i)
{
  static char *names[] = {
    "flags",  "r1",      "rp",     "r3",
    "r4",     "r5",      "r6",     "r7",
    "r8",     "r9",      "r10",    "r11",
    "r12",    "r13",     "r14",    "r15",
    "r16",    "r17",     "r18",    "r19",
    "r20",    "r21",     "r22",    "r23",
    "r24",    "r25",     "r26",    "dp",
    "ret0",   "ret1",    "sp",     "r31",
    "sar",    "pcoqh",   "pcsqh",  "pcoqt",
    "pcsqt",  "eiem",    "iir",    "isr",
    "ior",    "ipsw",    "goto",   "sr4",
    "sr0",    "sr1",     "sr2",    "sr3",
    "sr5",    "sr6",     "sr7",    "cr0",
    "cr8",    "cr9",     "ccr",    "cr12",
    "cr13",   "cr24",    "cr25",   "cr26",
    "mpsfu_high","mpsfu_low","mpsfu_ovflo","pad",
    "fpsr",    "fpe1",   "fpe2",   "fpe3",
    "fpe4",   "fpe5",    "fpe6",   "fpe7",
    "fr4",     "fr4R",   "fr5",    "fr5R",
    "fr6",    "fr6R",    "fr7",    "fr7R",
    "fr8",     "fr8R",   "fr9",    "fr9R",
    "fr10",   "fr10R",   "fr11",   "fr11R",
    "fr12",    "fr12R",  "fr13",   "fr13R",
    "fr14",   "fr14R",   "fr15",   "fr15R",
    "fr16",    "fr16R",  "fr17",   "fr17R",
    "fr18",   "fr18R",   "fr19",   "fr19R",
    "fr20",    "fr20R",  "fr21",   "fr21R",
    "fr22",   "fr22R",   "fr23",   "fr23R",
    "fr24",    "fr24R",  "fr25",   "fr25R",
    "fr26",   "fr26R",   "fr27",   "fr27R",
    "fr28",    "fr28R",  "fr29",   "fr29R",
    "fr30",   "fr30R",   "fr31",   "fr31R"
  };
  if (i < 0 || i >= (sizeof (names) / sizeof (*names)))
    return NULL;
  else
    return names[i];
}

const char *
hppa64_register_name (int i)
{
  static char *names[] = {
    "flags",  "r1",      "rp",     "r3",
    "r4",     "r5",      "r6",     "r7",
    "r8",     "r9",      "r10",    "r11",
    "r12",    "r13",     "r14",    "r15",
    "r16",    "r17",     "r18",    "r19",
    "r20",    "r21",     "r22",    "r23",
    "r24",    "r25",     "r26",    "dp",
    "ret0",   "ret1",    "sp",     "r31",
    "sar",    "pcoqh",   "pcsqh",  "pcoqt",
    "pcsqt",  "eiem",    "iir",    "isr",
    "ior",    "ipsw",    "goto",   "sr4",
    "sr0",    "sr1",     "sr2",    "sr3",
    "sr5",    "sr6",     "sr7",    "cr0",
    "cr8",    "cr9",     "ccr",    "cr12",
    "cr13",   "cr24",    "cr25",   "cr26",
    "mpsfu_high","mpsfu_low","mpsfu_ovflo","pad",
    "fpsr",    "fpe1",   "fpe2",   "fpe3",
    "fr4",    "fr5",     "fr6",    "fr7",
    "fr8",     "fr9",    "fr10",   "fr11",
    "fr12",   "fr13",    "fr14",   "fr15",
    "fr16",    "fr17",   "fr18",   "fr19",
    "fr20",   "fr21",    "fr22",   "fr23",
    "fr24",    "fr25",   "fr26",   "fr27",
    "fr28",  "fr29",    "fr30",   "fr31"
  };
  if (i < 0 || i >= (sizeof (names) / sizeof (*names)))
    return NULL;
  else
    return names[i];
}



a4945 1
  set_gdbarch_register_name (gdbarch, hppa_register_name);
@


1.84
log
@2003-06-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Update comments on registers, re-order.
	(deprecated_register_byte): Rename register_byte.
	(deprecated_register_raw_size): Rename register_raw_size.
	(deprecated_register_virtual_size): Rename register_virtual_size.
	(deprecated_register_virtual_type): Rename register_virtual_type.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c: Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
@
text
@a131 3
/* To support multi-threading and stepping. */
int hppa_prepare_to_proceed ();

@


1.83
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* vax-tdep.c (vax_frame_locals_address): Delete function.
	(vax_gdbarch_init): Do not set frame_locals_address.
	* m68hc11-tdep.c (m68hc11_frame_locals_address): Delete function.
	(m68hc11_gdbarch_init): Do not set frame_locals_address.
	* s390-tdep.c (s390_frame_args_address): Delete function.
	(s390_gdbarch_init): Do not set frame_args_address or
	frame_locals_address.
	* ns32k-tdep.c (ns32k_frame_locals_address): Delete.
	(ns32k_gdbarch_init): Do not set frame_locals_address.
	* hppa-tdep.c (hppa_frame_args_address): Delete function.
	(hppa_frame_locals_address): Delete function.
	(hppa_gdbarch_init): Do not set frame_args_address, or
	frame_locals_address.
	* arm-tdep.c (arm_frame_args_address): Delete.
	(arm_frame_locals_address): Delete.
	(arm_gdbarch_init): Do not set frame_args_address, or
	frame_locals_address.
@
text
@d4942 1
a4942 1
  set_gdbarch_register_raw_size (gdbarch, hppa_register_raw_size);
d4944 2
a4945 2
  set_gdbarch_register_byte (gdbarch, hppa_register_byte);
  set_gdbarch_register_virtual_size (gdbarch, hppa_register_raw_size);
d4948 1
a4948 1
  set_gdbarch_register_virtual_type (gdbarch, hppa_register_virtual_type);
@


1.82
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_NUM_ARGS): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (frame_num_args_unknown): Delete both declarations.
	* arch-utils.c (frame_num_args_unknown): Delete function.
	* stack.c (print_args_stub): Use FRAME_NUM_ARGS_P.
	(frame_info): Use FRAME_NUM_ARGS_P.
	* arm-tdep.c (arm_frame_num_args): Delete function.
	(arm_gdbarch_init): Do not set frame_num_args.
	* config/pa/tm-hppa64.h (FRAME_NUM_ARGS): Delete.
	* hppa-tdep.c (hppa_frame_num_args): Delete function.
	(hppa_gdbarch_init): Do not set frame_num_args.
	* config/sparc/tm-sparc.h (FRAME_NUM_ARGS): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	frame_num_args to default frame_num_args_unknown.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@a4877 12
hppa_frame_args_address (struct frame_info *fi)
{
  return get_frame_base (fi);
}

CORE_ADDR
hppa_frame_locals_address (struct frame_info *fi)
{
  return get_frame_base (fi);
}

CORE_ADDR
a4962 2
  set_gdbarch_frame_args_address (gdbarch, hppa_frame_args_address);
  set_gdbarch_frame_locals_address (gdbarch, hppa_frame_locals_address);
@


1.81
log
@        * config/pa/nm-hppah.h (PREPARE_TO_PROCEED): Use the generic
        prepare_to_proceed procedure instead of the hppa-specific one.
        * hppa-tdep.c (hppa_prepare_to_proceed): Remove, no longer used.
@
text
@a4888 8
int
hppa_frame_num_args (struct frame_info *frame)
{
  /* We can't tell how many args there are now that the C compiler delays
     popping them.  */
  return -1;
}

a4976 1
  set_gdbarch_frame_num_args (gdbarch, hppa_frame_num_args);
@


1.80
log
@* gdbarch.sh (function_list): Add FETCH_POINTER_ARGUMENT.
* gdbarch.[ch]: Regenerate.
* hppa-tdep.c (hppa_fetch_pointer_argument): New function.
(hppa_gdbarch_init): Set it in the gdbarch vector.
* i386-tdep.c (i386_fetch_pointer_argument): New
(i386_gdbarch_init): Set it into gdbarch.
* rs6000-tdep.c (rs6000_fetch_pointer_argument): New.
(rs6000_gdbarch_init): Set it in gdbarch.
* sparc-tdep.c (sparc_fetch_pointer_argument): New
(sparc_gdbarch_init): Set it in gdbarch.
@
text
@a4675 86
#ifdef PREPARE_TO_PROCEED

/* If the user has switched threads, and there is a breakpoint
   at the old thread's pc location, then switch to that thread
   and return TRUE, else return FALSE and don't do a thread
   switch (or rather, don't seem to have done a thread switch).

   Ptrace-based gdb will always return FALSE to the thread-switch
   query, and thus also to PREPARE_TO_PROCEED.

   The important thing is whether there is a BPT instruction,
   not how many user breakpoints there are.  So we have to worry
   about things like these:

   o  Non-bp stop -- NO

   o  User hits bp, no switch -- NO

   o  User hits bp, switches threads -- YES

   o  User hits bp, deletes bp, switches threads -- NO

   o  User hits bp, deletes one of two or more bps
   at that PC, user switches threads -- YES

   o  Plus, since we're buffering events, the user may have hit a
   breakpoint, deleted the breakpoint and then gotten another
   hit on that same breakpoint on another thread which
   actually hit before the delete. (FIXME in breakpoint.c
   so that "dead" breakpoints are ignored?) -- NO

   For these reasons, we have to violate information hiding and
   call "breakpoint_here_p".  If core gdb thinks there is a bpt
   here, that's what counts, as core gdb is the one which is
   putting the BPT instruction in and taking it out.

   Note that this implementation is potentially redundant now that
   default_prepare_to_proceed() has been added.

   FIXME This may not support switching threads after Ctrl-C
   correctly. The default implementation does support this. */
int
hppa_prepare_to_proceed (void)
{
  pid_t old_thread;
  pid_t current_thread;

  old_thread = hppa_switched_threads (PIDGET (inferior_ptid));
  if (old_thread != 0)
    {
      /* Switched over from "old_thread".  Try to do
         as little work as possible, 'cause mostly
         we're going to switch back. */
      CORE_ADDR new_pc;
      CORE_ADDR old_pc = read_pc ();

      /* Yuk, shouldn't use global to specify current
         thread.  But that's how gdb does it. */
      current_thread = PIDGET (inferior_ptid);
      inferior_ptid = pid_to_ptid (old_thread);

      new_pc = read_pc ();
      if (new_pc != old_pc	/* If at same pc, no need */
	  && breakpoint_here_p (new_pc))
	{
	  /* User hasn't deleted the BP.
	     Return TRUE, finishing switch to "old_thread". */
	  flush_cached_frames ();
	  registers_changed ();
#if 0
	  printf ("---> PREPARE_TO_PROCEED (was %d, now %d)!\n",
		  current_thread, PIDGET (inferior_ptid));
#endif

	  return 1;
	}

      /* Otherwise switch back to the user-chosen thread. */
      inferior_ptid = pid_to_ptid (current_thread);
      new_pc = read_pc ();	/* Re-prime register cache */
    }

  return 0;
}
#endif /* PREPARE_TO_PROCEED */

@


1.79
log
@        * config/pa/tm-hppa.h: Delete some unused macros. Move some
        macro definitions from here...
        * hppa-tdep.c: ...to there.
@
text
@d4996 10
d5083 3
@


1.78
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@d71 16
d92 6
d249 9
d309 1
a309 1
  val = GET_FIELD (word, 20, 20);
d311 1
a311 1
  val |= GET_FIELD (word, 9, 19);
d313 1
a313 1
  val |= GET_FIELD (word, 5, 6);
d315 1
a315 1
  val |= GET_FIELD (word, 0, 4);
d317 1
a317 1
  val |= GET_FIELD (word, 7, 8);
d330 1
a330 1
  val |= GET_FIELD (opnd, 11 + 14, 11 + 18);
d332 1
a332 1
  val |= GET_FIELD (opnd, 11 + 12, 11 + 13);
d334 1
a334 1
  val |= GET_FIELD (opnd, 11 + 19, 11 + 20);
d336 1
a336 1
  val |= GET_FIELD (opnd, 11 + 1, 11 + 11);
d338 1
a338 1
  val |= GET_FIELD (opnd, 11 + 0, 11 + 0);
d348 3
a350 3
  return sign_extend (GET_FIELD (word, 19, 28) |
		      GET_FIELD (word, 29, 29) << 10 |
		      GET_FIELD (word, 11, 15) << 11 |
@


1.77
log
@2003-05-15  Andrew Cagney  <cagney@@redhat.com>

	* arch-utils.h (legacy_breakpoint_from_pc): Delete declaration.
	* target.h (memory_breakpoint_from_pc): Delete declaration.
	* mem-break.c (memory_breakpoint_from_pc): Delete function.
	* arch-utils.c (legacy_breakpoint_from_pc): Delete function.
	* monitor.c (monitor_insert_breakpoint): Use
	gdbarch_breakpoint_from_pc instead of memory_breakpoint_from_pc.
	* gdbarch.sh (BREAKPOINT_FROM_PC): Do not provide a default.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sparc-tdep.c (sparc_breakpoint_from_pc): New function.
	(sparc_gdbarch_init): Set breakpoint_from_pc to
	sparc_breakpoint_from_pc.
	* config/sparc/tm-sparc.h (BREAKPOINT): Delete macro.
	(BREAKPOINT_FROM_PC): Define.
	(sparc_breakpoint_from_pc): Declare.
	* hppa-tdep.c (hppa_breakpoint_from_pc): New function.
	* config/pa/tm-hppa.h (hppa_breakpoint_from_pc): Declare.
	(BREAKPOINT_FROM_PC): Define.
	(BREAKPOINT): Delete macro.
	* target.h: Update comment.
	* s390-tdep.c (s390_gdbarch_init): Update comments.
	* remote.c: Update comments.
	* remote-mips.c: Update comments.
	* proc-api.c (write_with_trace): Do not check for a breakpoint.
	* mem-break.c: Update comment.
	* ia64-tdep.c (IA64_BREAKPOINT): Rename BREAKPOINT.
	(ia64_memory_insert_breakpoint): Update.
	* config/sparc/tm-sparc.h: Update comment.
	* config/pa/tm-hppa64.h: Update comment.
	* rs6000-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(rs6000_breakpoint_from_pc): Update.
	* mips-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(PMON_BIG_BREAKPOINT, PMON_LITTLE_BREAKPOINT): Delete macro.
	(IDT_LITTLE_BREAKPOINT, IDT_LITTLE_BREAKPOINT): Delete macro.
	(MIPS16_LITTLE_BREAKPOINT, MIPS16_BIG_BREAKPOINT): Delete macro.
	(mips_breakpoint_from_pc): Update.
	(mips_dump_tdep): Update.
@
text
@d2540 1
a2540 1
  char raw_regs[REGISTER_BYTES];
d2584 1
a2584 1
  char raw_regs[REGISTER_BYTES];
d5008 1
a5008 1
  set_gdbarch_register_bytes (gdbarch, hppa_num_regs * 4);
@


1.76
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d645 8
@


1.75
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (max_register_size): Delete declaration.
	* regcache.c (max_register_size): Delete function.
	(struct regcache_descr): Delete field "max_register_size".
	(init_regcache_descr, init_legacy_regcache_descr): Assert that all
	registers fit in MAX_REGISTER_SIZE.
	(regcache_save): Replace max_register_size with MAX_REGISTER_SIZE.
	(regcache_restore, regcache_xfer_part, regcache_dump): Ditto.
	* thread-db.c: Replace max_register_size with MAX_REGISTER_SIZE.
	* sh-tdep.c, rom68k-rom.c, remote-sim.c, remote-mips.c: Ditto.
	* remote-e7000.c, monitor.c, mipsv4-nat.c, mips-nat.c: Ditto.
	* m68klinux-nat.c, lynx-nat.c, irix4-nat.c: Ditto.
	* hpux-thread.c, hppah-nat.c, hppab-nat.c, hppa-tdep.c: Ditto.
	* dve3900-rom.c, hppa-tdep.c: Ditto.
@
text
@d1976 1
a1976 1
  get_sym = lookup_symbol ("__d_shl_get", NULL, VAR_NAMESPACE, NULL, NULL);
d1979 1
a1979 1
  symbol2 = lookup_symbol ("__shldp", NULL, VAR_NAMESPACE, NULL, NULL);
d4348 1
a4348 1
		       VAR_NAMESPACE, 0, (struct symtab **) NULL);
d4374 1
a4374 1
		       VAR_NAMESPACE, 0, (struct symtab **) NULL);
@


1.74
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d2633 1
a2633 1
  char *buf = alloca (max_register_size (current_gdbarch));
d2830 2
a2831 2
  char *raw_buffer = alloca (max_register_size (current_gdbarch));
  char *virtual_buffer = alloca (max_register_size (current_gdbarch));
d2873 2
a2874 2
  char *raw_buffer = alloca (max_register_size (current_gdbarch));
  char *virtual_buffer = alloca (max_register_size (current_gdbarch));
d2888 1
a2888 1
      char *raw_buf = alloca (max_register_size (current_gdbarch));
@


1.73
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d203 1
a203 1
  return (TYPE_LENGTH (type) > 2 * REGISTER_SIZE);
d907 2
a908 2
	       + ((REGISTER_SIZE / INSTRUCTION_SIZE)
		  * CALL_DUMMY_LENGTH)
d911 1
a911 1
	       + (32 * REGISTER_SIZE)
d916 1
a916 1
	       + (6 * REGISTER_SIZE)))))
d1470 2
a1471 2
  if (REGISTER_SIZE == 8)
    write_memory (sp - 16, (char *) &int_buffer, REGISTER_SIZE);
d1473 1
a1473 1
    write_memory (sp - 20, (char *) &int_buffer, REGISTER_SIZE);
d1476 1
a1476 1
  write_memory (sp, (char *) &int_buffer, REGISTER_SIZE);
d1480 1
a1480 1
  sp += 2 * REGISTER_SIZE;
d1487 1
a1487 1
  if (REGISTER_SIZE != 8)
d1513 1
a1513 1
  if (REGISTER_SIZE == 8)
d1520 1
a1520 1
  frame_saved_regs[1] = fp + (2 * REGISTER_SIZE);
d1522 1
a1522 1
  for (fp += 3 * REGISTER_SIZE, i = 3; i < 32; i++)
d1527 1
a1527 1
	  fp += REGISTER_SIZE;
d1532 1
a1532 1
  if (REGISTER_SIZE != 8)
d1539 5
a1543 5
  frame_saved_regs[SAR_REGNUM] = fp + REGISTER_SIZE;
  frame_saved_regs[PCOQ_HEAD_REGNUM] = fp + 2 * REGISTER_SIZE;
  frame_saved_regs[PCSQ_HEAD_REGNUM] = fp + 3 * REGISTER_SIZE;
  frame_saved_regs[PCOQ_TAIL_REGNUM] = fp + 4 * REGISTER_SIZE;
  frame_saved_regs[PCSQ_TAIL_REGNUM] = fp + 5 * REGISTER_SIZE;
d1567 1
a1567 1
		      REGISTER_SIZE));
d1580 1
a1580 1
					 REGISTER_SIZE));
d1585 1
a1585 1
					 REGISTER_SIZE));
d1591 1
a1591 1
				 REGISTER_SIZE);
d1601 1
a1601 1
  write_register (DEPRECATED_FP_REGNUM, read_memory_integer (fp, REGISTER_SIZE));
d1670 1
a1670 1
					   REGISTER_SIZE));
d1750 1
a1750 1
	  && TYPE_LENGTH (arg_type) < REGISTER_SIZE)
d1763 1
a1763 1
      bytes_reserved = (lengths[i] + REGISTER_SIZE - 1) & -REGISTER_SIZE;
d1775 2
a1776 2
	  int new_offset = ((offset[i] + 2*REGISTER_SIZE-1)
			    & -(2*REGISTER_SIZE));
d1863 1
a1863 1
      bytes_reserved = (lengths[i] + REGISTER_SIZE - 1) & -REGISTER_SIZE;
d1870 2
a1871 2
      if ((bytes_reserved == 2 * REGISTER_SIZE)
	  && (offset[i] % 2 * REGISTER_SIZE))
d1879 2
a1880 2
	  new_offset = ((offset[i] + 2 * REGISTER_SIZE - 1)
			& -(2 * REGISTER_SIZE));
d1882 1
a1882 1
	  if ((new_offset - offset[i]) >= 2 * REGISTER_SIZE)
d1884 2
a1885 2
	      bytes_reserved += REGISTER_SIZE;
	      offset[i] += REGISTER_SIZE;
d2040 3
a2042 3
   Therefore our version of FIX_CALL_DUMMY takes an extra argument,
   real_pc, which is the location where gdb should start up the
   inferior to do the function call. 
d2198 1
a2198 1
		      REGISTER_SIZE));
d3885 2
a3886 2
	       + ((REGISTER_SIZE / INSTRUCTION_SIZE)
		  * CALL_DUMMY_LENGTH)
d3889 1
a3889 1
	       + (32 * REGISTER_SIZE)
d3894 1
a3894 1
	       + (6 * REGISTER_SIZE)))))
d4863 1
a4863 1
  return REGISTER_SIZE;
d4992 1
a4992 1
  set_gdbarch_register_size (gdbarch, 4);
d5026 2
a5027 2
  set_gdbarch_call_dummy_length (gdbarch, INSTRUCTION_SIZE * 28);
  /* set_gdbarch_fix_call_dummy (gdbarch, hppa_fix_call_dummy); */
@


1.72
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_tm_print_insn): Rename tm_print_insn.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (_initialize_xstormy16_tdep): Update.
	* vax-tdep.c (_initialize_vax_tdep): Update.
	* v850-tdep.c (_initialize_v850_tdep): Update.
	* sparc-tdep.c (_initialize_sparc_tdep): Update.
	* s390-tdep.c (_initialize_s390_tdep): Update.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Update.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* m68k-tdep.c (_initialize_m68k_tdep): Update.
	* ia64-tdep.c (_initialize_ia64_tdep): Update.
	* hppa-tdep.c (_initialize_hppa_tdep): Update.
	* h8300-tdep.c (_initialize_h8300_tdep): Update.
	* frv-tdep.c (_initialize_frv_tdep): Update.
	* cris-tdep.c (cris_delayed_get_disassembler): Update.
	(_initialize_cris_tdep): Update.
	* arch-utils.c (legacy_print_insn): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	"tm_print_insn" to "deprecated_tm_print_insn".
@
text
@d1088 1
a1088 1
	deprecated_update_frame_base_hack (frame, TARGET_READ_FP ());
d1109 1
a1109 1
    deprecated_update_frame_base_hack (frame, TARGET_READ_FP ());
d1267 1
a1267 1
	  if (saved_regs[FP_REGNUM])
d1329 1
a1329 1
		  return read_memory_integer (saved_regs[FP_REGNUM],
d1338 1
a1338 1
	  return read_memory_integer (saved_regs[FP_REGNUM],
d1367 1
a1367 1
	      return read_memory_integer (saved_regs[FP_REGNUM],
d1378 1
a1378 1
      return TARGET_READ_FP ();
d1475 1
a1475 1
  int_buffer = TARGET_READ_FP ();
d1478 1
a1478 1
  write_register (FP_REGNUM, sp);
d1483 1
a1483 1
    if (regnum != RP_REGNUM && regnum != FP_REGNUM)
d1518 1
a1518 1
  frame_saved_regs[FP_REGNUM] = fp;
d1524 1
a1524 1
      if (i != FP_REGNUM)
d1601 1
a1601 1
  write_register (FP_REGNUM, read_memory_integer (fp, REGISTER_SIZE));
d2445 2
a2446 2
     register.  All others must use TARGET_READ_FP (). */
  return read_register (FP_REGNUM);
d3593 1
a3593 1
      if (u->Save_SP && i == FP_REGNUM)
d3944 1
a3944 1
      if (u->Save_SP && i == FP_REGNUM)
d4006 1
a4006 1
	  frame_saved_regs[FP_REGNUM] = get_frame_base (frame_info);
d4013 1
a4013 1
	  && (!u->Save_SP || reg != FP_REGNUM))
d4994 1
a4994 1
  set_gdbarch_fp_regnum (gdbarch, 3);
d5033 1
a5033 1
  set_gdbarch_read_fp (gdbarch, hppa_target_read_fp);
@


1.71
log
@        * config/pa/tm-hppa.h (SOFT_FLOAT): Delete this macro.
        Update all the tests using SOFT_FLOAT considering the fact that
        this macro was always set to 0.
        * config/pa/tm-hppa64.h: Update all the tests using SOFT_FLOAT
        considering the fact that this macro was always set to 0.
        * hppa-tdep.h (hppa_store_return_value): Likewise.
        (hppa_extract_return_value): Likewise.
@
text
@d5053 1
a5053 1
  tm_print_insn = print_insn_hppa;
@


1.70
log
@2003-04-21  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c: New file.
	* infcall.h: New file.
	* valarith.c: Include "infcall.h".
	* scm-lang.c, objc-lang.cm, hppa-tdep.c, gcore.c: Ditto.
	* eval.c, ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (valarith.o, scm-lang.o): Update dependencies.
	(objc-lang.o, hppa-tdep.o, gcore.o): Update dependencies.
	(eval.o, ada-valprint.o, ada-lang.o): Update dependencies.
	(SFILES): Add "infcall.c"
	(COMMON_OBS): Add "infcall.o".
	(infcall.o): Specify dependencies.
	* value.h (call_function_by_hand): Delete declaration.
	* inferior.h (run_stack_dummy): Delete declaration.
	* infcmd.c (breakpoint_auto_delete_contents): Move to "infcall.c".
	(run_stack_dummy): Move to "infcall.c", merged into
	call_function_by_hand.
	* valops.c (call_function_by_hand): Moved to "infcall.c".
	(find_function_addr, value_arg_coerce): Ditto.
	(unwindonsignal_p, coerce_float_to_double): Ditto.
	(_initialize_valops): Move "set/show coerce-float-to-double", and
	"set/show unwindonsignal" commands to "infcall.c".
	* v850-tdep.c, target.h: Update comments.
	* sparc-tdep.c (sparc_fix_call_dummy): Update comments.
	* sh-tdep.c (sh_init_extra_frame_info): Update comments.
	(sh64_init_extra_frame_info): Update comments.
	* mn10300-tdep.c: Update comments.
	* mcore-tdep.c (mcore_init_extra_frame_info): Update comments.
	* config/sparc/tm-sparc.h: Update comments.
	* breakpoint.h: Update comments.
	* avr-tdep.c (avr_init_extra_frame_info): Update comments.
	* arm-tdep.c: Update comment.
@
text
@d4766 1
a4766 1
  if (! SOFT_FLOAT && TYPE_CODE (type) == TYPE_CODE_FLT)
d4781 1
a4781 1
  if (! SOFT_FLOAT && TYPE_CODE (type) == TYPE_CODE_FLT)
@


1.69
log
@2003-04-13  Andrew Cagney  <cagney@@redhat.com>

	* frame.h: Mention what replaced what in "struct frame_info".
	* hppa-hpux-tdep.c: Use get_frame_base, get_frame_pc and
	deprecated_update_frame_base_hack and
	deprecated_update_frame_pc_hack.
	* hppa-tdep.c: Ditto.
@
text
@d39 1
@


1.69.2.1
log
@Merge from mainline.
@
text
@a38 1
#include "infcall.h"
d1087 1
a1087 1
	deprecated_update_frame_base_hack (frame, deprecated_read_fp ());
d1108 1
a1108 1
    deprecated_update_frame_base_hack (frame, deprecated_read_fp ());
d1266 1
a1266 1
	  if (saved_regs[DEPRECATED_FP_REGNUM])
d1328 1
a1328 1
		  return read_memory_integer (saved_regs[DEPRECATED_FP_REGNUM],
d1337 1
a1337 1
	  return read_memory_integer (saved_regs[DEPRECATED_FP_REGNUM],
d1366 1
a1366 1
	      return read_memory_integer (saved_regs[DEPRECATED_FP_REGNUM],
d1377 1
a1377 1
      return deprecated_read_fp ();
d1474 1
a1474 1
  int_buffer = deprecated_read_fp ();
d1477 1
a1477 1
  write_register (DEPRECATED_FP_REGNUM, sp);
d1482 1
a1482 1
    if (regnum != RP_REGNUM && regnum != DEPRECATED_FP_REGNUM)
d1517 1
a1517 1
  frame_saved_regs[DEPRECATED_FP_REGNUM] = fp;
d1523 1
a1523 1
      if (i != DEPRECATED_FP_REGNUM)
d1600 1
a1600 1
  write_register (DEPRECATED_FP_REGNUM, read_memory_integer (fp, REGISTER_SIZE));
d2444 2
a2445 2
     register.  All others must use deprecated_read_fp (). */
  return read_register (DEPRECATED_FP_REGNUM);
d3592 1
a3592 1
      if (u->Save_SP && i == DEPRECATED_FP_REGNUM)
d3943 1
a3943 1
      if (u->Save_SP && i == DEPRECATED_FP_REGNUM)
d4005 1
a4005 1
	  frame_saved_regs[DEPRECATED_FP_REGNUM] = get_frame_base (frame_info);
d4012 1
a4012 1
	  && (!u->Save_SP || reg != DEPRECATED_FP_REGNUM))
d4765 1
a4765 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
d4780 1
a4780 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
d4993 1
a4993 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, 3);
d5032 1
a5032 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, hppa_target_read_fp);
d5052 1
a5052 1
  deprecated_tm_print_insn = print_insn_hppa;
@


1.68
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_SAVED_PC_AFTER_CALL): Deprecate
	SAVED_PC_AFTER_CALL.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_saved_pc_after_call): Update declaration.
	* i386ly-tdep.c (i386lynx_init_abi): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	* infrun.c (step_over_function): Update.
	* i386-linux-tdep.c (skip_hurd_resolver): Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	* arm-linux-tdep.c (skip_hurd_resolver): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	* x86-64-tdep.h (x86_64_linux_saved_pc_after_call): Update
	declaration.
@
text
@d851 1
a851 1
  u = find_unwind_entry (frame->pc);
d897 1
a897 1
    return read_memory_integer (frame->frame + PC_REGNUM * 4,
d900 16
a915 15
  if ((frame->pc >= frame->frame
       && frame->pc <= (frame->frame
                        /* A call dummy is sized in words, but it is
                           actually a series of instructions.  Account
                           for that scaling factor.  */
                        + ((REGISTER_SIZE / INSTRUCTION_SIZE)
                           * CALL_DUMMY_LENGTH)
                        /* Similarly we have to account for 64bit
                           wide register saves.  */
                        + (32 * REGISTER_SIZE)
                        /* We always consider FP regs 8 bytes long.  */
                        + (NUM_REGS - FP0_REGNUM) * 8
                        /* Similarly we have to account for 64bit
                           wide register saves.  */
                        + (6 * REGISTER_SIZE))))
d917 1
a917 1
      return read_memory_integer ((frame->frame
d942 3
a944 3
      if (frame->next
	  && ((get_frame_type (frame->next) == SIGTRAMP_FRAME)
	      || pc_in_interrupt_handler (frame->next->pc)))
d947 2
a948 2
	  hppa_frame_init_saved_regs (frame->next);
	  saved_regs = get_frame_saved_regs (frame->next);
d959 1
a959 1
	      if (pc == frame->pc)
d982 3
a984 3
	  && frame->next
	  && ((get_frame_type (frame->next) == SIGTRAMP_FRAME)
	      || pc_in_interrupt_handler (frame->next->pc)))
d987 2
a988 2
	  hppa_frame_init_saved_regs (frame->next);
	  saved_regs = get_frame_saved_regs (frame->next);
d999 1
a999 1
	      if (pc == frame->pc)
d1015 1
a1015 1
	  pc = read_memory_integer (frame->frame + rp_offset,
d1069 1
a1069 1
  if (frame->next && !fromleaf)
d1087 1
a1087 1
	frame->frame = TARGET_READ_FP ();
d1089 1
a1089 1
	frame->frame -= framesize;
d1095 1
a1095 1
    frame->pc = read_register (31) & ~0x3;
d1106 1
a1106 1
  framesize = find_proc_framesize (frame->pc);
d1108 1
a1108 1
    frame->frame = TARGET_READ_FP ();
d1110 1
a1110 1
    frame->frame = read_register (SP_REGNUM) - framesize;
d1145 2
a1146 2
  min_frame_symbol = lookup_minimal_symbol_by_pc (frame->pc);
  frame_symbol = find_pc_function (frame->pc);
d1175 2
a1176 2
  if (pc_in_interrupt_handler (frame->pc))
    frame_base = read_memory_integer (frame->frame + SP_REGNUM * 4,
d1185 1
a1185 1
    frame_base = frame->frame;
d1189 1
a1189 1
  my_framesize = find_proc_framesize (frame->pc);
d1229 1
a1229 1
  for (tmp_frame = frame; tmp_frame; tmp_frame = tmp_frame->next)
d1231 1
a1231 1
      u = find_unwind_entry (tmp_frame->pc);
d1244 1
a1244 1
	  warning ("Unable to find unwind for PC 0x%x -- Help!", tmp_frame->pc);
d1251 1
a1251 1
	  || pc_in_interrupt_handler (tmp_frame->pc))
d1277 1
a1277 1
	  && !pc_in_interrupt_handler (tmp_frame->pc))
d1279 1
a1279 1
	  return read_memory_integer (tmp_frame->frame, TARGET_PTR_BIT / 8);
d1345 2
a1346 2
      while (tmp_frame->next != NULL)
	tmp_frame = tmp_frame->next;
d1393 1
a1393 1
  u = find_unwind_entry (thisframe->pc);
d1421 1
a1421 1
    next_u = find_unwind_entry (next->pc);
d1427 1
a1427 1
      || (thisframe->next && (get_frame_type (thisframe->next) == SIGTRAMP_FRAME))
d1431 1
a1431 1
  if (pc_in_linker_stub (thisframe->pc))
d1508 1
a1508 1
  CORE_ADDR fp = frame->frame;
d3878 16
a3893 15
  if ((frame_info->pc >= frame_info->frame
       && frame_info->pc <= (frame_info->frame
			     /* A call dummy is sized in words, but it is
				actually a series of instructions.  Account
				for that scaling factor.  */
			     + ((REGISTER_SIZE / INSTRUCTION_SIZE)
				* CALL_DUMMY_LENGTH)
			     /* Similarly we have to account for 64bit
				wide register saves.  */
			     + (32 * REGISTER_SIZE)
			     /* We always consider FP regs 8 bytes long.  */
			     + (NUM_REGS - FP0_REGNUM) * 8
			     /* Similarly we have to account for 64bit
				wide register saves.  */
			     + (6 * REGISTER_SIZE))))
d3898 1
a3898 1
  if (pc_in_interrupt_handler (frame_info->pc))
d3905 1
a3905 1
	      = read_memory_integer (frame_info->frame + SP_REGNUM * 4,
d3908 1
a3908 1
	    frame_saved_regs[i] = frame_info->frame + i * 4;
d3957 1
a3957 1
  frame_saved_regs[SP_REGNUM] = frame_info->frame;
d3975 1
a3975 1
	 && pc <= frame_info->pc)
d3992 1
a3992 1
	  frame_saved_regs[RP_REGNUM] = frame_info->frame - 20;
d3997 1
a3997 1
	  frame_saved_regs[RP_REGNUM] = frame_info->frame - 16;
d4005 1
a4005 1
	  frame_saved_regs[FP_REGNUM] = frame_info->frame;
d4019 1
a4019 1
	    frame_saved_regs[reg] = frame_info->frame;
d4022 1
a4022 1
	    frame_saved_regs[reg] = frame_info->frame;
d4037 1
a4037 1
		  = frame_info->frame + offset;
d4040 1
a4040 1
		  = (frame_info->frame + (u->Total_frame_size << 3)
d4072 1
a4072 1
	      frame_saved_regs[reg + FP4_REGNUM + 4] = frame_info->frame;
d4078 1
a4078 1
		= frame_info->frame + fp_loc;
d4551 1
a4551 1
  throw_addr = fi->pc;
d4926 1
a4926 1
  return fi->frame;
d4932 1
a4932 1
  return fi->frame;
@


1.67
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	Eliminate FRAME_FIND_SAVED_REGS.
	* config/pa/tm-hppah.h (hppa_hpux_frame_find_saved_regs_in_sigtramp):
	Change FSR parameter to a pointer.
	* config/pa/tm-hppa64.h (FRAME_FIND_SAVED_REGS_IN_SIGTRAMP):
	Assume FSR parameter is a pointer.
	* hppa-hpux-tdep.c (hppa_hpux_frame_find_saved_regs_in_sigtramp):
	Make fsr a pointer.
	* hppa-tdep.c (hppa_frame_find_saved_regs): New function.
	(hppa_frame_saved_pc): Call hppa_frame_init_saved_regs.  Make
	saved_regs a pointer.
	(hppa_frame_saved_pc): Ditto.
	(find_dummy_frame_regs): Make frame_saved_regs a pointer
	(hppa_pop_frame): Call hppa_frame_init_saved_regs.  Make fsr a
	pointer.
	(restore_pc_queue): Make fsr a pointer.
	(hppa_frame_find_saved_regs): Make frame_saved_regs a pointer.
	(hppa_frame_chain): Make saved_regs a pointer, call
	hppa_frame_init_saved_regs.
	* sparc-tdep.c: Include "gdb_assert.h".
	(sparc_frame_find_saved_regs): Replace internal_error with
	gdb_assert.
	* remote-vxsparc.c (vx_read_register): Delete reference to
	FRAME_FIND_SAVED_REGS.
	* gdbarch.sh: Delete check for FRAME_FIND_SAVED_REGS.
	* gdbarch.h: Regenerate.
	* frame.h (DEPRECATED_FRAME_INIT_SAVED_REGS): Delete macro.
	(deprecated_get_frame_saved_regs): Delete declaration.
	(struct frame_saved_regs): Delete definition.
	* frame.c (deprecated_get_frame_saved_regs): Delete function.
	* config/pa/tm-hppa.h (hppa_frame_init_saved_regs): Declare.
	(hppa_frame_find_saved_regs): Delete declaration.
	(FRAME_FIND_SAVED_REGS): Delete macro.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Define.
	* config/i386/tm-ptx.h (FRAME_FIND_SAVED_REGS): Delete
	FRAME_FIND_SAVED_REGS in comment.
@
text
@d4985 1
a4985 1
  set_gdbarch_saved_pc_after_call (gdbarch, hppa_saved_pc_after_call);
@


1.66
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_func_unwind, get_frame_func): New functions.
	* frame.h (get_frame_func, frame_func_unwind): Declare.
	(struct frame_info): Add field "prev_func" for caching the
	previous frame's function address.
	* arm-tdep.c (arm_frameless_function_invocation): Combine
	get_pc_function_start and get_frame_pc into get_frame_func.
	* sh-tdep.c (sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	* s390-tdep.c (s390_function_start): Ditto.
	* rs6000-tdep.c (rs6000_pop_frame): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc): Ditto.
	* m68k-tdep.c (m68k_frame_init_saved_regs): Ditto.
	* ia64-tdep.c (ia64_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frameless_signal_p): Ditto.
	(i386_frame_init_saved_regs): Ditto.
	* hppa-tdep.c (hppa_frame_find_saved_regs): Ditto.
	* d10v-tdep.c (d10v_frame_unwind_cache): Combine
	get_pc_function_start and frame_pc_unwind into frame_func_unwind.
	* cris-tdep.c (cris_frame_init_saved_regs): Ditto.
	* blockframe.c (frameless_look_for_prologue): Ditto.
@
text
@d81 1
a81 2
static void find_dummy_frame_regs (struct frame_info *,
				   struct frame_saved_regs *);
d105 1
a105 1
static int restore_pc_queue (struct frame_saved_regs *);
d945 4
a948 4
	  struct frame_saved_regs saved_regs;

	  deprecated_get_frame_saved_regs (frame->next, &saved_regs);
	  if (read_memory_integer (saved_regs.regs[FLAGS_REGNUM],
d951 1
a951 1
	      pc = read_memory_integer (saved_regs.regs[31],
d959 1
a959 1
		pc = read_memory_integer (saved_regs.regs[RP_REGNUM],
d963 1
a963 1
	    pc = read_memory_integer (saved_regs.regs[RP_REGNUM],
d985 4
a988 4
	  struct frame_saved_regs saved_regs;

	  deprecated_get_frame_saved_regs (frame->next, &saved_regs);
	  if (read_memory_integer (saved_regs.regs[FLAGS_REGNUM],
d991 1
a991 1
	      pc = read_memory_integer (saved_regs.regs[31],
d999 1
a999 1
		pc = read_memory_integer (saved_regs.regs[RP_REGNUM],
d1003 1
a1003 1
	    pc = read_memory_integer (saved_regs.regs[RP_REGNUM],
d1131 3
a1133 3
  /* Where the registers were saved in saved_regs_frame.
     If saved_regs_frame is zero, this is garbage.  */
  struct frame_saved_regs saved_regs;
d1260 2
a1261 1
	  deprecated_get_frame_saved_regs (tmp_frame, &saved_regs);
d1265 1
a1265 1
	  if (saved_regs.regs[FP_REGNUM])
d1310 4
a1313 1
	    deprecated_get_frame_saved_regs (tmp_frame, &saved_regs);
d1317 2
a1318 2
	      && ((saved_regs.regs[FLAGS_REGNUM]
		   && (read_memory_integer (saved_regs.regs[FLAGS_REGNUM],
d1321 1
a1321 1
		  || (saved_regs.regs[FLAGS_REGNUM] == 0
d1327 1
a1327 1
		  return read_memory_integer (saved_regs.regs[FP_REGNUM],
d1336 1
a1336 1
	  return read_memory_integer (saved_regs.regs[FP_REGNUM],
d1348 4
a1351 1
	deprecated_get_frame_saved_regs (tmp_frame, &saved_regs);
d1355 2
a1356 2
	  && ((saved_regs.regs[FLAGS_REGNUM]
	       && (read_memory_integer (saved_regs.regs[FLAGS_REGNUM],
d1359 1
a1359 1
	      || (saved_regs.regs[FLAGS_REGNUM] == 0
d1365 1
a1365 1
	      return read_memory_integer (saved_regs.regs[FP_REGNUM],
d1505 1
a1505 1
		       struct frame_saved_regs *frame_saved_regs)
d1512 1
a1512 1
    frame_saved_regs->regs[RP_REGNUM] = (fp - 16) & ~0x3;
d1514 1
a1514 1
    frame_saved_regs->regs[RP_REGNUM] = (fp - 20) & ~0x3;
d1516 1
a1516 1
  frame_saved_regs->regs[FP_REGNUM] = fp;
d1518 1
a1518 1
  frame_saved_regs->regs[1] = fp + (2 * REGISTER_SIZE);
d1524 1
a1524 1
	  frame_saved_regs->regs[i] = fp;
d1534 1
a1534 1
    frame_saved_regs->regs[i] = fp;
d1536 6
a1541 6
  frame_saved_regs->regs[IPSW_REGNUM] = fp;
  frame_saved_regs->regs[SAR_REGNUM] = fp + REGISTER_SIZE;
  frame_saved_regs->regs[PCOQ_HEAD_REGNUM] = fp + 2 * REGISTER_SIZE;
  frame_saved_regs->regs[PCSQ_HEAD_REGNUM] = fp + 3 * REGISTER_SIZE;
  frame_saved_regs->regs[PCOQ_TAIL_REGNUM] = fp + 4 * REGISTER_SIZE;
  frame_saved_regs->regs[PCSQ_TAIL_REGNUM] = fp + 5 * REGISTER_SIZE;
d1550 1
a1550 1
  struct frame_saved_regs fsr;
d1554 2
a1555 1
  deprecated_get_frame_saved_regs (frame, &fsr);
d1558 2
a1559 2
  if (fsr.regs[IPSW_REGNUM])	/* Restoring a call dummy frame */
    restore_pc_queue (&fsr);
d1563 2
a1564 2
    if (fsr.regs[regnum])
      write_register (regnum, read_memory_integer (fsr.regs[regnum],
d1568 1
a1568 1
    if (fsr.regs[regnum])
d1570 1
a1570 1
	read_memory (fsr.regs[regnum], (char *) &freg_buffer, 8);
d1575 1
a1575 1
  if (fsr.regs[IPSW_REGNUM])
d1577 1
a1577 1
		    read_memory_integer (fsr.regs[IPSW_REGNUM],
d1580 1
a1580 1
  if (fsr.regs[SAR_REGNUM])
d1582 1
a1582 1
		    read_memory_integer (fsr.regs[SAR_REGNUM],
d1586 1
a1586 1
  if (fsr.regs[PCOQ_TAIL_REGNUM])
d1588 1
a1588 1
      npc = read_memory_integer (fsr.regs[PCOQ_TAIL_REGNUM],
d1601 1
a1601 1
  if (fsr.regs[IPSW_REGNUM])	/* call dummy */
d1614 1
a1614 1
  if (target_pc && !fsr.regs[IPSW_REGNUM])
d1645 1
a1645 1
restore_pc_queue (struct frame_saved_regs *fsr)
d1648 1
a1648 1
  CORE_ADDR new_pc = read_memory_integer (fsr->regs[PCOQ_HEAD_REGNUM],
d1667 1
a1667 1
  write_register (21, read_memory_integer (fsr->regs[PCSQ_HEAD_REGNUM],
d3852 5
a3856 5
/* Put here the code to store, into a struct frame_saved_regs,
   the addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.  */
d3860 1
a3860 1
			    struct frame_saved_regs *frame_saved_regs)
d3871 1
a3871 1
  memset (frame_saved_regs, '\0', sizeof (struct frame_saved_regs));
d3902 1
a3902 1
	    frame_saved_regs->regs[SP_REGNUM]
d3906 1
a3906 1
	    frame_saved_regs->regs[i] = frame_info->frame + i * 4;
d3955 1
a3955 1
  frame_saved_regs->regs[SP_REGNUM] = frame_info->frame;
d3990 1
a3990 1
	  frame_saved_regs->regs[RP_REGNUM] = frame_info->frame - 20;
d3995 1
a3995 1
	  frame_saved_regs->regs[RP_REGNUM] = frame_info->frame - 16;
d4003 1
a4003 1
	  frame_saved_regs->regs[FP_REGNUM] = frame_info->frame;
d4017 1
a4017 1
	    frame_saved_regs->regs[reg] = frame_info->frame;
d4020 1
a4020 1
	    frame_saved_regs->regs[reg] = frame_info->frame;
d4034 1
a4034 1
		frame_saved_regs->regs[reg]
d4037 1
a4037 1
		frame_saved_regs->regs[reg]
d4070 1
a4070 1
	      frame_saved_regs->regs[reg + FP4_REGNUM + 4] = frame_info->frame;
d4075 1
a4075 1
	      frame_saved_regs->regs[reg + FP0_REGNUM + 4]
d4095 11
@


1.65
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_START_OFFSET): Default to zero.
	CALL_DUMMY_LENGTH): Ditto.
	* gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_START_OFFSET): Delete macro.
	(CALL_DUMMY_LENGTH): Delete macro.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set above when zero.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@d3915 1
a3915 1
  pc = get_pc_function_start (frame_info->pc);
@


1.65.2.1
log
@Merge with mainline.
@
text
@d81 2
a82 1
static void find_dummy_frame_regs (struct frame_info *, CORE_ADDR *);
d106 1
a106 1
static int restore_pc_queue (CORE_ADDR *);
d946 4
a949 4
	  CORE_ADDR *saved_regs;
	  hppa_frame_init_saved_regs (frame->next);
	  saved_regs = get_frame_saved_regs (frame->next);
	  if (read_memory_integer (saved_regs[FLAGS_REGNUM],
d952 1
a952 1
	      pc = read_memory_integer (saved_regs[31],
d960 1
a960 1
		pc = read_memory_integer (saved_regs[RP_REGNUM],
d964 1
a964 1
	    pc = read_memory_integer (saved_regs[RP_REGNUM],
d986 4
a989 4
	  CORE_ADDR *saved_regs;
	  hppa_frame_init_saved_regs (frame->next);
	  saved_regs = get_frame_saved_regs (frame->next);
	  if (read_memory_integer (saved_regs[FLAGS_REGNUM],
d992 1
a992 1
	      pc = read_memory_integer (saved_regs[31],
d1000 1
a1000 1
		pc = read_memory_integer (saved_regs[RP_REGNUM],
d1004 1
a1004 1
	    pc = read_memory_integer (saved_regs[RP_REGNUM],
d1132 3
a1134 3
  /* Where the registers were saved in saved_regs_frame.  If
     saved_regs_frame is zero, this is garbage.  */
  CORE_ADDR *saved_regs = NULL;
d1261 1
a1261 2
	  hppa_frame_init_saved_regs (tmp_frame);
	  saved_regs = get_frame_saved_regs (tmp_frame);
d1265 1
a1265 1
	  if (saved_regs[FP_REGNUM])
d1310 1
a1310 4
	    {
	      hppa_frame_init_saved_regs (tmp_frame);
	      saved_regs = get_frame_saved_regs (tmp_frame);
	    }
d1314 2
a1315 2
	      && ((saved_regs[FLAGS_REGNUM]
		   && (read_memory_integer (saved_regs[FLAGS_REGNUM],
d1318 1
a1318 1
		  || (saved_regs[FLAGS_REGNUM] == 0
d1324 1
a1324 1
		  return read_memory_integer (saved_regs[FP_REGNUM],
d1333 1
a1333 1
	  return read_memory_integer (saved_regs[FP_REGNUM],
d1345 1
a1345 4
	{
	  hppa_frame_init_saved_regs (tmp_frame);
	  saved_regs = get_frame_saved_regs (tmp_frame);
	}
d1349 2
a1350 2
	  && ((saved_regs[FLAGS_REGNUM]
	       && (read_memory_integer (saved_regs[FLAGS_REGNUM],
d1353 1
a1353 1
	      || (saved_regs[FLAGS_REGNUM] == 0
d1359 1
a1359 1
	      return read_memory_integer (saved_regs[FP_REGNUM],
d1499 1
a1499 1
		       CORE_ADDR frame_saved_regs[])
d1506 1
a1506 1
    frame_saved_regs[RP_REGNUM] = (fp - 16) & ~0x3;
d1508 1
a1508 1
    frame_saved_regs[RP_REGNUM] = (fp - 20) & ~0x3;
d1510 1
a1510 1
  frame_saved_regs[FP_REGNUM] = fp;
d1512 1
a1512 1
  frame_saved_regs[1] = fp + (2 * REGISTER_SIZE);
d1518 1
a1518 1
	  frame_saved_regs[i] = fp;
d1528 1
a1528 1
    frame_saved_regs[i] = fp;
d1530 6
a1535 6
  frame_saved_regs[IPSW_REGNUM] = fp;
  frame_saved_regs[SAR_REGNUM] = fp + REGISTER_SIZE;
  frame_saved_regs[PCOQ_HEAD_REGNUM] = fp + 2 * REGISTER_SIZE;
  frame_saved_regs[PCSQ_HEAD_REGNUM] = fp + 3 * REGISTER_SIZE;
  frame_saved_regs[PCOQ_TAIL_REGNUM] = fp + 4 * REGISTER_SIZE;
  frame_saved_regs[PCSQ_TAIL_REGNUM] = fp + 5 * REGISTER_SIZE;
d1544 1
a1544 1
  CORE_ADDR *fsr;
d1548 1
a1548 2
  hppa_frame_init_saved_regs (frame);
  fsr = get_frame_saved_regs (frame);
d1551 2
a1552 2
  if (fsr[IPSW_REGNUM])	/* Restoring a call dummy frame */
    restore_pc_queue (fsr);
d1556 2
a1557 2
    if (fsr[regnum])
      write_register (regnum, read_memory_integer (fsr[regnum],
d1561 1
a1561 1
    if (fsr[regnum])
d1563 1
a1563 1
	read_memory (fsr[regnum], (char *) &freg_buffer, 8);
d1568 1
a1568 1
  if (fsr[IPSW_REGNUM])
d1570 1
a1570 1
		    read_memory_integer (fsr[IPSW_REGNUM],
d1573 1
a1573 1
  if (fsr[SAR_REGNUM])
d1575 1
a1575 1
		    read_memory_integer (fsr[SAR_REGNUM],
d1579 1
a1579 1
  if (fsr[PCOQ_TAIL_REGNUM])
d1581 1
a1581 1
      npc = read_memory_integer (fsr[PCOQ_TAIL_REGNUM],
d1594 1
a1594 1
  if (fsr[IPSW_REGNUM])	/* call dummy */
d1607 1
a1607 1
  if (target_pc && !fsr[IPSW_REGNUM])
d1638 1
a1638 1
restore_pc_queue (CORE_ADDR *fsr)
d1641 1
a1641 1
  CORE_ADDR new_pc = read_memory_integer (fsr[PCOQ_HEAD_REGNUM],
d1660 1
a1660 1
  write_register (21, read_memory_integer (fsr[PCSQ_HEAD_REGNUM],
d3845 5
a3849 5
/* Put here the code to store, into the SAVED_REGS, the addresses of
   the saved registers of frame described by FRAME_INFO.  This
   includes special registers such as pc and fp saved in special ways
   in the stack frame.  sp is even more special: the address we return
   for it IS the sp for the next frame.  */
d3853 1
a3853 1
			    CORE_ADDR frame_saved_regs[])
d3864 1
a3864 1
  memset (frame_saved_regs, '\0', SIZEOF_FRAME_SAVED_REGS);
d3895 1
a3895 1
	    frame_saved_regs[SP_REGNUM]
d3899 1
a3899 1
	    frame_saved_regs[i] = frame_info->frame + i * 4;
d3915 1
a3915 1
  pc = get_frame_func (frame_info);
d3948 1
a3948 1
  frame_saved_regs[SP_REGNUM] = frame_info->frame;
d3983 1
a3983 1
	  frame_saved_regs[RP_REGNUM] = frame_info->frame - 20;
d3988 1
a3988 1
	  frame_saved_regs[RP_REGNUM] = frame_info->frame - 16;
d3996 1
a3996 1
	  frame_saved_regs[FP_REGNUM] = frame_info->frame;
d4010 1
a4010 1
	    frame_saved_regs[reg] = frame_info->frame;
d4013 1
a4013 1
	    frame_saved_regs[reg] = frame_info->frame;
d4027 1
a4027 1
		frame_saved_regs[reg]
d4030 1
a4030 1
		frame_saved_regs[reg]
d4063 1
a4063 1
	      frame_saved_regs[reg + FP4_REGNUM + 4] = frame_info->frame;
d4068 1
a4068 1
	      frame_saved_regs[reg + FP0_REGNUM + 4]
a4087 11
/* XXX - deprecated.  This is a compatibility function for targets
   that do not yet implement DEPRECATED_FRAME_INIT_SAVED_REGS.  */
/* Find the addresses in which registers are saved in FRAME.  */

void
hppa_frame_init_saved_regs (struct frame_info *frame)
{
  if (get_frame_saved_regs (frame) == NULL)
    frame_saved_regs_zalloc (frame);
  hppa_frame_find_saved_regs (frame, get_frame_saved_regs (frame));
}
@


1.64
log
@2003-03-29  Andrew Cagney  <cagney@@redhat.com>

	* infttrace.h: New file.
	* hpread.c: Include "gdb_assert.h" and "somsolib.h".
	(hpread_get_textlow): Detect an uninitialized dn_bufp.
	(hpread_read_doc_function_type): Detect an initialized type1.
	(hpread_quick_traverse): Initialize mod_name_string.
	* somsolib.h: Add #ifdef SOMSOLIB_H wrapper.
	(som_solib_get_solib_by_pc): Declare.
	(so_lib_thread_start_addr): Declare.
	(no_shared_libraries): Declare.
	* somread.c (init_import_symbols): Make static.  Add forward
	declaration.
	* config/pa/nm-hppah.h: Include "infttrace.h" for
	parent_attach_all.
	(hppa_insert_hw_watchpoint): Declare.
	(hppa_can_use_hw_watchpoint, hppa_remove_hw_watchpoint): Declare.
	* hppah-nat.c: Include "gdb_string.h".
	(parent_attach_all): Delete extern declaration, moved to
	"infttrace.h".
	(hppa_can_use_hw_watchpoint): Change type of "type" parameter to
	int.
	(hppa_remove_hw_watchpoint, hppa_insert_hw_watchpoint): Ditto.
	* Makefile.in (infttrace_h): Define.
	(hpread.o): Update dependencies.
	(hppah-nat.o, hppa-hpux-tdep.o, hppa-tdep.o): Ditto.
	* hppa-hpux-tdep.c: Include "gdb_string.h".
	* hppa-tdep.c (hppa_frame_saved_pc): Initialize "old_pc".
	* infrun.c (handle_inferior_event): Always initialize
	stepped_after_stopped_by_watchpoint.  Add default and remove
	fallthrough in switch statement.
	* infttrace.c (hppa_can_use_hw_watchpoint): Change type of "type"
	parameter to int.
	(hppa_remove_hw_watchpoint): Ditto.
@
text
@a5005 1
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
@


1.63
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_ARGUMENTS): Rename PUSH_ARGUMENTS.
	(push_dummy_call): New pure multi-arch replacement with gdbarch,
	regcache and dummy_addr parameters.
	* gdbarch.h, gdbarch.c: Re-generate.
	* valops.c (hand_function_call): Use gdbarch_push_dummy_call when
	available; assume it will handle stack alignment and return
	address issues.  Fall back to DEPRECATED_PUSH_ARGUMENTS and
	legacy_push_arguments.
	(legacy_push_arguments): Rename default_push_arguments.
	* value.h (legacy_push_arguments): Rename default_push_arguments.
	* i386-tdep.c (i386_push_arguments): Call legacy_push_arguments.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/i386/tm-symmetry.h: Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* arm-linux-tdep.c (arm_linux_init_abi): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	PUSH_ARGUMENTS with push_dummy_call, add gdbarch, regcache and
	dummy_addr parameters.
@
text
@d36 1
a36 1

d889 1
a889 1
  CORE_ADDR old_pc;
@


1.62
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_EXTRA_STACK_ALIGNMENT_NEEDED): Replace
	EXTRA_STACK_ALIGNMENT_NEEDED.  Default to 0 not 1.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h
	(DEPRECATED_EXTRA_STACK_ALIGNMENT_NEEDED): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Set
	deprecated_extra_stack_alignment_needed.
	* config/pa/tm-hppa.h (EXTRA_STACK_ALIGNMENT_NEEDED): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not clear
	extra_stack_alignment_needed.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
@
text
@d5008 1
a5008 1
  set_gdbarch_push_arguments (gdbarch, hppa_push_arguments);
@


1.62.2.1
log
@Merge with mainline.
@
text
@d36 1
a36 1
#include "infttrace.h"
d889 1
a889 1
  CORE_ADDR old_pc = 0;
d5008 1
a5008 1
  set_gdbarch_deprecated_push_arguments (gdbarch, hppa_push_arguments);
@


1.61
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STORE_STRUCT_RETURN): Replace
	STORE_STRUCT_RETURN.
	* gdbarch.h, gdbarch.c: Regenerate.
	* d10v-tdep.c (d10v_store_struct_return): Delete function.
	(d10v_push_arguments): Set the struct return register.
	(d10v_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@a4969 1
  set_gdbarch_extra_stack_alignment_needed (gdbarch, 0);
@


1.60
log
@Index: ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_CHAIN): Replace FRAME_CHAIN.
	(DEPRECATED_FRAME_CHAIN_VALID): Replace FRAME_CHAIN_VALID.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update.
	* objfiles.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame, get_prev_frame, legacy_frame_p): Update.
	* dummy-frame.h: Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* config/m68k/tm-vx68.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-os68k.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-sun3.h: Update.
	* blockframe.c (inside_main_func, frame_chain_valid): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_frame_chain, sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	(rs6000_gdbarch_init, rs6000_frame_saved_pc): Update.
	(frame_get_saved_regs): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_frame_num_args, i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	(i386_interix_back_one_frame): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	(hppa_init_extra_frame_info): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Algorithms, Target Architecture Definition):
	Deprecate FRAME_CHAIN and FRAME_CHAIN_VALID.
@
text
@d4986 1
a4986 1
  set_gdbarch_store_struct_return (gdbarch, hppa_store_struct_return);
@


1.59
log
@        * hppa-tdep.c (hppa_gdbarch_init): Set the push_dummy_frame gdbarch
        method, now that hppa_push_dummy_frame has a conformant prototype.
        * config/pa/tm-hppa.h (DEPRECATED_PUSH_DUMMY_FRAME): Wrap macro
        inside "#if !GDB_MULTI_ARCH ... #endif" conditional, in preparation
        for the switch to multiarch partial.
@
text
@d1072 4
a1075 3
  /* If the next frame represents a frameless function invocation
     then we have to do some adjustments that are normally done by
     FRAME_CHAIN.  (FRAME_CHAIN is not called in this case.)  */
d4995 2
a4996 2
  set_gdbarch_frame_chain (gdbarch, hppa_frame_chain);
  set_gdbarch_frame_chain_valid (gdbarch, hppa_frame_chain_valid);
@


1.58
log
@        Continuing work to convert the hppa targets to multiarch partial.
        * hppa-tdep.c (hppa_push_dummy_frame): Remove unused function
        parameter. Reformat comment.
        * config/pa/tm-hppa.h (hppa_push_dummy_frame): Update profile.
        (DEPRECATED_PUSH_DUMMY_FRAME): Update call to hppa_push_dummy_frame()
        to match new profile.
@
text
@d5003 1
a5003 1
  /* set_gdbarch_deprecated_push_dummy_frame (gdbarch, hppa_push_dummy_frame);  */
@


1.57
log
@        * hppa-tdep.c (hppa_push_dummy_frame): Remove hack which does not
        appear to be working in any case.
@
text
@d168 1
a168 1
void hppa_push_dummy_frame (struct inferior_status *inf_status);
d1429 4
a1432 5
/*
   These functions deal with saving and restoring register state
   around a function call in the inferior. They keep the stack
   double-word aligned; eventually, on an hp700, the stack will have
   to be aligned to a 64-byte boundary. */
d1435 1
a1435 1
hppa_push_dummy_frame (struct inferior_status *inf_status)
@


1.56
log
@        * hppa-tdep.c (gdb_assert.h): Add missing #include.
        * somsolib.c (gdb_assert.h): Likewise.
        * Makefile.in (hppa-tdep.o): Add dependency on gdb_assert.h.
        (somsolib.o): Likewise.
@
text
@a1442 9
  /* Oh, what a hack.  If we're trying to perform an inferior call
     while the inferior is asleep, we have to make sure to clear
     the "in system call" bit in the flag register (the call will
     start after the syscall returns, so we're no longer in the system
     call!)  This state is kept in "inf_status", change it there.

     We also need a number of horrid hacks to deal with lossage in the
     PC queue registers (apparently they're not valid when the in syscall
     bit is set).  */
d1447 1
a1447 6
      unsigned int sid;
      int_buffer &= ~0x2;
      write_inferior_status_register (inf_status, 0, int_buffer);
      write_inferior_status_register (inf_status, PCOQ_HEAD_REGNUM, pc + 0);
      write_inferior_status_register (inf_status, PCOQ_TAIL_REGNUM, pc + 4);
      sid = (pc >> 30) & 0x3;
a1451 2
      write_inferior_status_register (inf_status, PCSQ_HEAD_REGNUM, pcspace);
      write_inferior_status_register (inf_status, PCSQ_TAIL_REGNUM, pcspace);
@


1.55
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_POP_FRAME): Replace POP_FRAME.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update comment.
	* stack.c (return_command): Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_POP_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_POP_FRAME): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	POP_FRAME with DEPRECATED_POP_FRAME.  Update description.
@
text
@d35 1
@


1.54
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_SAVED_PC): Replace FRAME_SAVED_PC.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.h: Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* sh-tdep.c (sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Update.
	* xstormy16-tdep.c (xstormy16_pop_frame): Update.
	(xstormy16_frame_chain_valid): Update.
	* vax-tdep.c (vax_saved_pc_after_call): Update.
	* v850-tdep.c (v850_frame_chain): Update.
	(v850_pop_frame): Update.
	(v850_init_extra_frame_info): Update.
	* sparc-tdep.c (setup_arbitrary_frame): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* s390-tdep.c (s390_pop_frame_regular): Update.
	* mn10300-tdep.c (mn10300_frame_chain): Update.
	(mn10300_pop_frame_regular): Update.
	(mn10300_init_extra_frame_info): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	(mips_frame_chain): Update.
	(mips_pop_frame): Update.
	* mcore-tdep.c (mcore_frame_chain): Update.
	(mcore_pop_frame): Update.
	(mcore_init_extra_frame_info): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* m68k-tdep.c (isi_frame_num_args): Update.
	(delta68_frame_num_args): Update.
	(news_frame_num_args): Update.
	* ia64-tdep.c (ia64_pop_frame_regular): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	(alpha_frame_chain): Update.
	(alpha_pop_frame): Update.
	* hppa-tdep.c (hppa_saved_pc_after_call): Update.
	(hppa_init_extra_frame_info): Update.
	(hppa_frame_chain): Update.
	(hppa_frame_chain_valid): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_init_extra_frame_info): Update.
	* arm-tdep.c (arm_frame_chain_valid): Update.
	(arm_init_extra_frame_info): Update.
	(arm_pop_frame): Update.
	* frame.c (frame_pc_unwind): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_SAVED_PC): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-linux.h (DEPRECATED_FRAME_SAVED_PC): Update.

2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_SAVED_PC to DEPRECATED_FRAME_SAVED_PC.
@
text
@d5020 1
a5020 1
  set_gdbarch_pop_frame (gdbarch, hppa_pop_frame);
@


1.53
log
@2003-03-03  Andrew Cagney  <cagney@@redhat.com>

	Make MAX_REGISTER_RAW_SIZE and MAX_REGISTER_VIRTUAL_SIZE optional.
	* gdbarch.sh (DEPRECATED_MAX_REGISTER_RAW_SIZE): Variable with
	predicate.  Replace MAX_REGISTER_RAW_SIZE.
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto for
	MAX_REGISTER_VIRTUAL_SIZE.
	* regcache.c (legacy_max_register_raw_size): New function.
	(legacy_max_register_virtual_size): New function.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Define.
	(MAX_REGISTER_RAW_SIZE): Define.
	(legacy_max_register_raw_size): Declare.
	(legacy_max_register_virtual_size): Declare.
	* config/sparc/tm-sparc.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/i386/tm-ptx.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Do not set
	max_register_raw_size or max_register_virtual_size.
@
text
@d878 1
a878 1
    return FRAME_SAVED_PC (frame);
d1078 1
a1078 1
      framesize = find_proc_framesize (FRAME_SAVED_PC (get_next_frame (frame)));
d1188 1
a1188 1
  caller_pc = FRAME_SAVED_PC (frame);
d1196 1
a1196 1
  caller_framesize = find_proc_framesize (FRAME_SAVED_PC (frame));
d1319 1
a1319 1
	      u = find_unwind_entry (FRAME_SAVED_PC (frame));
d1354 1
a1354 1
	  u = find_unwind_entry (FRAME_SAVED_PC (frame));
d1395 1
a1395 1
  msym_us = lookup_minimal_symbol_by_pc (FRAME_SAVED_PC (thisframe));
d5014 1
a5014 1
  set_gdbarch_frame_saved_pc (gdbarch, hppa_frame_saved_pc);
@


1.53.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d878 1
a878 1
    return DEPRECATED_FRAME_SAVED_PC (frame);
d1078 1
a1078 1
      framesize = find_proc_framesize (DEPRECATED_FRAME_SAVED_PC (get_next_frame (frame)));
d1188 1
a1188 1
  caller_pc = DEPRECATED_FRAME_SAVED_PC (frame);
d1196 1
a1196 1
  caller_framesize = find_proc_framesize (DEPRECATED_FRAME_SAVED_PC (frame));
d1319 1
a1319 1
	      u = find_unwind_entry (DEPRECATED_FRAME_SAVED_PC (frame));
d1354 1
a1354 1
	  u = find_unwind_entry (DEPRECATED_FRAME_SAVED_PC (frame));
d1395 1
a1395 1
  msym_us = lookup_minimal_symbol_by_pc (DEPRECATED_FRAME_SAVED_PC (thisframe));
d5014 1
a5014 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, hppa_frame_saved_pc);
d5020 1
a5020 1
  set_gdbarch_deprecated_pop_frame (gdbarch, hppa_pop_frame);
@


1.52
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename
	INIT_EXTRA_FRAME_INFO.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-tdep.c: Update comments.
	* sh-tdep.c, mcore-tdep.c, m68hc11-tdep.c: Ditto.
	* i386-interix-tdep.c, hppa-tdep.c, h8300-tdep.c: Ditto.
	* frame.h, avr-tdep.c: Ditto.
	* frame.c (get_prev_frame): DEPRECATED_INIT_EXTRA_FRAME_INFO.
	(create_new_frame, legacy_get_prev_frame): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* config/pa/tm-hppa.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Initialize
	deprecated_init_extra_frame_info instead of init_extra_frame_info.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.

Index: doc/ChangeLog
2003-02-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo: Rename INIT_EXTRA_FRAME_INFO to
	DEPRECATED_INIT_EXTRA_FRAME_INFO.
@
text
@d4998 2
a4999 2
  set_gdbarch_max_register_raw_size (gdbarch, 4);
  set_gdbarch_max_register_virtual_size (gdbarch, 8);
@


1.51
log
@2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_DUMMY_FRAME): Procedure with
	predicate.  Replaces PUSH_DUMMY_FRAME.
	* gdbarch.h, gdbarch.c: Regnerate.
	* valops.c (hand_function_call): Update.  Call
	generic_push_dummy_frame directly.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* inferior.h (PUSH_DUMMY_FRAME): Delete definition.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Don't set
	push_dummy_frame to generic_push_dummy_frame.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@d1113 2
a1114 2
   then INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC will be
   called for the new frame.
d5009 1
a5009 1
  set_gdbarch_init_extra_frame_info (gdbarch, hppa_init_extra_frame_info);
@


1.50
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d5019 1
a5019 1
  /* set_gdbarch_push_dummy_frame (gdbarch, hppa_push_dummy_frame);  */
@


1.49
log
@2003-02-02  Andrew Cagney  <ac131313@@redhat.com>

	* mips-nat.c (zerobuf): Delete.
	(fetch_inferior_registers): Alloc local zerobuf.
	(fetch_core_registers): Alloc local zerobuf.
	* d10v-tdep.c (show_regs): Don't allocate a dynamic array using
	MAX_REGISTER_RAW_SIZE or MAX_REGISTER_VIRTUAL_SIZE.
	* thread-db.c (thread_db_store_registers): Ditto.
	* sh-tdep.c (sh_do_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote-sim.c (gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* monitor.c (monitor_supply_register): Ditto.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	* m68klinux-nat.c (fetch_register): Ditto.
	* lynx-nat.c (fetch_inferior_registers): Ditto.
	(fetch_inferior_registers): Ditto.
	* irix4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (fetch_register): Ditto.
	* hppab-nat.c (fetch_register): Ditto.
	* hppa-tdep.c (pa_register_look_aside): Ditto.
	(pa_print_fp_reg, pa_strcat_fp_reg): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register): Ditto.
@
text
@d680 1
a680 1
	  && !PC_IN_SIGTRAMP (pc, SYMBOL_NAME (msym_us)));
d798 1
a798 1
      && !PC_IN_SIGTRAMP (pc, SYMBOL_NAME (msym_us)))
d1156 1
a1156 1
      frame_symbol_name = SYMBOL_NAME (min_frame_symbol);
d1987 1
a1987 1
  namelen = strlen (SYMBOL_NAME (function));
d2000 1
a2000 1
  target_write_memory (endo_buff_addr, SYMBOL_NAME (function), namelen);
d2238 1
a2238 1
	      (SYMBOL_NAME (funsymbol), NULL, objfile);
d2241 1
a2241 1
	      stub_symbol = lookup_minimal_symbol (SYMBOL_NAME (funsymbol),
d2342 1
a2342 1
	    error ("Can't find an import stub for %s", SYMBOL_NAME (fmsymbol));
d3018 1
a3018 1
  if (minsym && strcmp (SYMBOL_NAME (minsym), ".stub") == 0)
d3261 1
a3261 1
		&& STREQ (SYMBOL_NAME (msymbol), SYMBOL_NAME (msym)))
d3356 1
a3356 1
	  libsym = lookup_minimal_symbol (SYMBOL_NAME (stubsym), NULL, NULL);
d3360 1
a3360 1
		       SYMBOL_NAME (stubsym));
@


1.48
log
@2003-02-01  Andrew Cagney  <ac131313@@redhat.com>

	* defs.h (host_pointer_to_address): Delete declaration.
	(address_to_host_pointer): Delete declaration.
	* utils.c (host_pointer_to_address): Delete function.
	(address_to_host_pointer): Delete function.
	* procfs.c (procfs_address_to_host_pointer): New function.
	* procfs.c (proc_set_watchpoint): Use.
	(procfs_can_use_hw_breakpoint): Update comments.
	* somsolib.c (hpux_address_to_host_pointer_hack): New function.
	(som_solib_add): Use.
	* hppa-tdep.c (hppa_pointer_to_address_hack): New function.
	* hppa-tdep.c (unwind_command): Use.
@
text
@d2639 1
a2639 1
  char buf[MAX_REGISTER_RAW_SIZE];
d2836 2
a2837 2
  char raw_buffer[MAX_REGISTER_RAW_SIZE];
  char virtual_buffer[MAX_REGISTER_VIRTUAL_SIZE];
d2879 2
a2880 2
  char raw_buffer[MAX_REGISTER_RAW_SIZE];
  char virtual_buffer[MAX_REGISTER_VIRTUAL_SIZE];
d2894 1
a2894 1
      char raw_buf[MAX_REGISTER_RAW_SIZE];
@


1.47
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d4558 10
d4590 1
a4590 1
		     paddr_nz (host_pointer_to_address (u)));
@


1.46
log
@	* arm-tdep.c (arm_frame_chain_valid):  Remove unnecessary test.
	* d10v-tdep.c (d10v_frame_chain_valid): Remove unnecessary tests.
	* hppa-tdep.c (hppa_frame_chain_valid): Remove unnecessary test.

	* blockframe.c: Include "gdbcmd.h" and "command.h".
	(backtrace_below_main): New variable.
	(file_frame_chain_valid, func_frame_chain_valid)
	(nonnull_frame_chain_valid, generic_file_frame_chain_valid)
	(generic_func_frame_chain_valid): Remove functions.
	(frame_chain_valid, do_flush_frames_sfunc): New functions.
	(_initialize_blockframe): New function.
	* Makefile.in (blockframe.o): Update dependencies.
	* frame.c (frame_saved_regs_id_unwind, get_prev_frame): Remove FIXME
	comment.  Call frame_chain_valid ().
	* frame.h: Remove old prototypes.  Add prototype for
	frame_chain_valid and update comments to match.
	* gdbarch.sh: Change FRAME_CHAIN_VALID into a predicated function.
	Remove old comment.
	* gdbarch.h: Regenerated.
	* gdbarch.c: Regenerated.

Plus updates to all other targets not to provide a FRAME_CHAIN_VALID.
@
text
@d187 1
a187 1
static int cover_find_stub_with_shl_get (PTR);
d376 1
a376 1
				 record_text_segment_lowaddr, (PTR) NULL);
d577 1
a577 1
      objfile->obj_private = (PTR) obj_private;
d2035 1
a2035 1
cover_find_stub_with_shl_get (PTR args_untyped)
d4303 1
a4303 1
      catch_errors (cover_find_stub_with_shl_get, (PTR) &args, message,
@


1.45
log
@	* arch-utils.c (gdbarch_info_init): Set osabi to
	GDB_OSABI_UNINITIALIZED.
	* gdbarch.sh: Add osabi to struct gdbarch and to struct
	gdbarch_info.  Include "osabi.h" in gdbarch.c.  Check osabi
	in gdbarch_list_lookup_by_info and in gdbarch_update_p.
	* gdbarch.c: Regenerated.
	* gdbarch.h: Regenerated.
	* osabi.c (gdbarch_lookup_osabi): Return GDB_OSABI_UNINITIALIZED if
	there's no BFD.
	(gdbarch_init_osabi): Remove osabi argument; use info.osabi.
	* osabi.h (enum gdb_osabi): Move to defs.h.
	(gdbarch_init_osabi): Update prototype.
	* defs.h (enum gdb_osabi): Moved here.
	* Makefile.in: Update dependencies.

Plus updates to alpha, arm, hppa, i386, mips, ns32k, ppc, sh, sparc, and vax
ports to match.
@
text
@a1383 3
  if (!chain)
    return 0;

@


1.44
log
@gdb/
	* buildsym.h (processing_hp_compilation): Remove obsolete variable.
	* gdbarch.sh Remove include of "value.h" in gdbarch.h.
	(COERCE_FLOAT_TO_DOUBLE): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* Makefile.in: Remove value_h from gdbarch_h.
	* valops.c (coerce_float_to_double): New variable.
	(default_coerce_float_to_double): Remove.
	(standard_coerce_float_to_double): Remove.
	(value_arg_coerce): Use coerce_float_to_double.
	(_initialize_valops): Add "set coerce-float-to-double".
	* value.h (default_coerce_float_to_double): Remove prototype.
	(standard_coerce_float_to_double): Remove prototype.

	* hpread.c (hpread_process_one_debug_symbol): Mark C++ functions as
	prototyped.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Mark all functions as prototyped.

	* hppa-tdep.c (hppa_coerce_float_to_double): Remove.
	* alpha-tdep.c (alpha_gdbarch_init): Remove call to
	set_gdbarch_coerce_float_to_double.
	* arm-tdep.c (arm_gdbarch_init): Likewise.
	* frv-tdep.c (frv_gdbarch_init): Likewise.
	* h8300-tdep.c (h8300_gdbarch_init): Likewise (commented out).
	* i386-sol2-tdep.c (i386_sol2_init_abi): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	(mips_coerce_float_to_double): Remove.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	(rs6000_coerce_float_to_double): Remove.
	* s390-tdep.c (s390_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	(sh_coerce_float_to_double): Remove.
	* sparc-tdep.c (sparc_gdbarch_init): Likewise.
	(sparc_coerce_float_to_double): Remove.
	* v850-tdep.c (v850_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.
	* config/m32r/tm-m32r.h (COERCE_FLOAT_TO_DOUBLE): Remove.
	* config/pa/tm-hppa.h: (COERCE_FLOAT_TO_DOUBLE): Remove.
	(hppa_coerce_float_to_double): Remove prototype.
	* config/sparc/tm-sparc.h (COERCE_FLOAT_TO_DOUBLE): Remove.
doc/
	* gdb.texinfo (Controlling GDB): Add ABI section.  Document
	"set coerce-float-to-double".
	* gdbint.texinfo (COERCE_FLOAT_TO_DOUBLE): Remove documentation.
testsuite/
	* gdb.base/callfuncs.exp: Don't XFAIL unprototyped functions for
	stabs.
	* gdb.base/completion.exp: Allow marker1(void) as well as marker1().
	* gdb.base/whatis.exp: Always allow (void) after function names.
@
text
@a4947 1
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
d4950 1
a4950 2

  if (info.abfd != NULL)
d4952 3
a4954 7
      osabi = gdbarch_lookup_osabi (info.abfd);
      if (osabi == GDB_OSABI_UNKNOWN)
	{
	  /* If it's a SOM file, assume it's HP/UX SOM.  */
	  if (bfd_get_flavour (info.abfd) == bfd_target_som_flavour)
	    osabi = GDB_OSABI_HPUX_SOM;
	}
d4966 1
a4966 1
  gdbarch_init_osabi (info, gdbarch, osabi);
@


1.43
log
@        Continuing work to convert the hppa targets to multiarch partil.

        * hppa-tdep.c: Add some missing forward declarations.
        (frameless_function_invocation): Prefix the function name
        by "hppa_" to avoid polluting the namespace.  Update all calls
        to use the new function name.
        (saved_pc_after_call): Ditto.
        (init_extra_frame_info): Ditto.
        (frame_chain): Ditto.
        (push_dummy_frame): Ditto.
        (target_read_pc): Ditto.
        (target_write_pc): Ditto.
        (in_solib_call_trampoline): Ditto.
        (in_solib_return_trampoline): Ditto.
        (skip_trampoline_code): Ditto.
        (hppa_read_fp): New function, renamed from target_read_fp.
        (hppa_target_read_fp): New function, using hppa_read_fp.
        This function conforms to the function profile for the
        READ_FP gdbarch method.
        (hppa_extract_struct_value_address): New function, extracted
        from the definition of the DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS
        macro.
        (hppa_frame_num_args): New function.
        (hppa_gdbarch_init): Setup the gdbarch vector for the hppa target.

        * config/pa/tm-hppa.h: Wrap around all gdbarch-eligible macros
        inside "#if !GDB_MULTI_ARCH ... #endif" conditional, in preparation
        for the switch to multiarch partial.
        Update some of the macros definitions to match some changes
        described above in the name of the function they are calling.
        (PUSH_DUMMY_FRAME): Add a FIXME explaining why this macro will
        not be straightforward to convert. Do now wrap it inside
        "#if !... #endif" to remember that this macro has still not
        been taken care of.
        (FIX_CALL_DUMMY): Likewise.
@
text
@d4 1
a4 1
   1996, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
a177 1
int hppa_coerce_float_to_double (struct type *formal, struct type *actual);
a4943 13
int
hppa_coerce_float_to_double (struct type *formal, struct type *actual)
{
   /* FIXME: For the pa, it appears that the debug info marks the
      parameters as floats regardless of whether the function is
      prototyped, but the actual values are passed as doubles for the
      non-prototyped case and floats for the prototyped case.  Thus we
      choose to make the non-prototyped case work for C and break the
      prototyped case, since the non-prototyped case is probably much
      more common.  */
  return (current_language -> la_language == language_c);
}

a5028 1
  set_gdbarch_coerce_float_to_double (gdbarch, hppa_coerce_float_to_double);
@


1.42
log
@       Continuing work to convert the hppa targets to multiarch partial.

       * hppa-tdep.c: (hppa_register_raw_size): New function replacing
       the body of macro REGISTER_RAW_SIZE.
       * hppa-hpux-tdep.c: Add new functions replacing macro bodies from
       config/pa/tm-hppah.h. These functions will be used to initialize
       the gdbarch structure.
       (hppa_hpux_pc_in_sigtramp): New function.
       (hppa_hpux_frame_saved_pc_in_sigtramp): New function.
       (hppa_hpux_frame_base_before_sigtramp): New function.
       (hppa_hpux_frame_find_saved_regs_in_sigtramp): New function.
       Add gdbcore.h #include.
       * config/pa/tm-hppa.h (REGISTER_RAW_SIZE): Change the definition
       of this gdbarch-eligible macro to a call to the new associated
       function.
       * config/pa/tm-hppah.h (PC_IN_SIGTRAMP): Likewise.
       (FRAME_SAVED_PC_IN_SIGTRAMP): Change the definition of this macro
       into a call to the new associated function.
       (FRAME_BASE_BEFORE_SIGTRAMP): Likewise.
       (FRAME_FIND_SAVED_REGS_IN_SIGTRAMP): Likewise.
       * Makefile.in (hppa-hpux-tdep.o): Add dependency on gdbcore.h.
@
text
@d66 3
d141 5
d154 4
d159 5
d166 8
d175 3
d848 1
a848 1
frameless_function_invocation (struct frame_info *frame)
d866 1
a866 1
saved_pc_after_call (struct frame_info *frame)
d932 1
a932 1
  if (frameless_function_invocation (frame))
d1064 1
a1064 1
init_extra_frame_info (int fromleaf, struct frame_info *frame)
d1122 1
a1122 1
frame_chain (struct frame_info *frame)
d1439 1
a1439 1
push_dummy_frame (struct inferior_status *inf_status)
d1455 1
a1455 1
  pc = target_read_pc (inferior_ptid);
d2432 1
a2432 1
  else if (som_solib_get_got_by_pc (target_read_pc (inferior_ptid)))
a2439 3



d2443 1
d2445 1
a2445 1
target_read_fp (int pid)
d2459 5
d2469 1
a2469 1
target_read_pc (ptid_t ptid)
d2486 1
a2486 1
target_write_pc (CORE_ADDR v, ptid_t ptid)
d2924 1
a2924 1
in_solib_call_trampoline (CORE_ADDR pc, char *name)
d3084 1
a3084 1
in_solib_return_trampoline (CORE_ADDR pc, char *name)
d3157 1
a3157 1
skip_trampoline_code (CORE_ADDR pc, char *name)
d4884 15
d4924 8
d4987 57
@


1.41
log
@        * hppa-hpux-tdep.c: New file.
        * hppa-tdep.c (hppa_gdbarch_init): call the registered osabi-
        specific initialization routines.
        * Makefile.in (ALLDEPFILES): Add hppa-hpux-tdep.c.
        (hppa-hpux-tdep.o): Add rule.
        * config/pa/hppahpux.mt (TDEPFILES): Add hppa-hpux-tdep.o.
        * config/pa/hppa64.mt (TDEPFILES): Likewise.
@
text
@d142 1
d4814 7
@


1.40
log
@       * hppa-tdep.c (hppa_pop_frame): Fix a compilation error introduced
       in the previous prototype change to set_momentary_breakpoint.
@
text
@d4923 3
@


1.39
log
@2002-12-11  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_get_frame_saved_regs): Rename
	get_frame_saved_regs.
	* frame.h (deprecated_get_frame_saved_regs): Update declaration.
	* sparc-tdep.c: Update.
	* hppa-tdep.c: Update.
	* h8500-tdep.c: Update.
@
text
@d1607 1
a1607 1
      breakpoint = set_momentary_breakpoint (sal, NULL, bp_finish);
@


1.38
log
@2002-12-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
	Change to a function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Update.  Test
	DEPRECATED_INIT_FRAME_PC_P.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/mn10200/tm-mn10200.h (DEPRECATED_INIT_FRAME_PC): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* arm-tdep.c: Update comments.
	* h8300-tdep.c (h8300_gdbarch_init): Explicitly set init_frame_pc.
	* config/m32r/tm-m32r.h (DEPRECATED_INIT_FRAME_PC): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC_FIRST): Delete macro.
	(DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
@
text
@d919 1
a919 1
	  get_frame_saved_regs (frame->next, &saved_regs);
d959 1
a959 1
	  get_frame_saved_regs (frame->next, &saved_regs);
d1231 1
a1231 1
	  get_frame_saved_regs (tmp_frame, &saved_regs);
d1280 1
a1280 1
	    get_frame_saved_regs (tmp_frame, &saved_regs);
d1315 1
a1315 1
	get_frame_saved_regs (tmp_frame, &saved_regs);
d1538 1
a1538 1
  get_frame_saved_regs (frame, &fsr);
@


1.37
log
@       * hppa-tdep.c: Add #include "osabi.h" (for hppa_gdbarch_init).
       (hppa_gdbarch_init): Detect osabi from objfile. Will be needed
       later to set the proper gdbarch methods depending on the osabi.
       * Makefile.in (hppa-tdep.o): Add dependency on osabi.h.
@
text
@d1083 4
a1086 3
/* Given a GDB frame, determine the address of the calling function's frame.
   This will be used to create a new GDB frame struct, and then
   INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.
@


1.36
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d34 1
d4899 14
@


1.35
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@d2514 1
a2514 1
    frame_register_read (selected_frame, i, raw_regs + REGISTER_BYTE (i));
d2558 1
a2558 1
    frame_register_read (selected_frame, i, raw_regs + REGISTER_BYTE (i));
d2810 1
a2810 1
  frame_register_read (selected_frame, i, raw_buffer);
d2828 1
a2828 1
      frame_register_read (selected_frame, i + 1, raw_buffer);
d2856 1
a2856 1
  frame_register_read (selected_frame, i, raw_buffer);
d2867 1
a2867 1
      frame_register_read (selected_frame, i + 1, raw_buf);
@


1.34
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (enum frame_type): Define.
	(get_frame_type): Declare.
	(struct frame_info): Add field `type'.  Delete field
	signal_handler_caller.
	(deprecated_set_frame_signal_handler_caller): Declare.
	* frame.c (get_frame_type): New function.
	(deprecated_set_frame_type): New function.
	(create_new_frame): Set the frame's type.
	(get_prev_frame): Similar.
	* sparc-tdep.c: Use get_frame_type instead of signal_handler_caller.
	* s390-tdep.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* x86-64-linux-tdep.c: Ditto.
	* vax-tdep.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* i386-interix-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* m68k-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* cris-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* i386-tdep.c: Ditto.
	* stack.c: Ditto.
	* ada-lang.c: Ditto.
	* blockframe.c: Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Use
	deprecated_set_frame_type instead of signal_handler_caller.
	* ppc-linux-tdep.c (ppc_linux_init_extra_frame_info): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	* breakpoint.h: Delete FIXME suggesting get_frame_type.

Index: tui/ChangeLog
2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	signal_handler_caller.
@
text
@d1535 1
a1535 1
  fp = FRAME_FP (frame);
@


1.33
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@d894 1
a894 1
  if (frame->signal_handler_caller)
d913 1
a913 1
	  && (frame->next->signal_handler_caller
d953 1
a953 1
	  && (frame->next->signal_handler_caller
d1147 1
a1147 1
  else if (frame->signal_handler_caller)
d1218 1
a1218 1
	  || tmp_frame->signal_handler_caller
d1243 1
a1243 1
	  && !tmp_frame->signal_handler_caller
d1391 1
a1391 1
      || (thisframe->next && thisframe->next->signal_handler_caller)
d3891 1
a3891 1
  if (frame_info->signal_handler_caller)
@


1.32
log
@        Preparation work to convert the hppa targets to multiarch partial.

        * hppa-tdep.c: Add new functions replacing macro bodies from
        config/pa/tm-hppa.h. These function will be used to initialize
        the gdbarch structure. Import some comments from tm-hppa.h,
        and place them where appropriate, to avoid loosing them when
        we cleanup this file.
        (hppa_reg_struct_has_addr): New function.
        (hppa_inner_than): New function.
        (hppa_stack_align): New function.
        (hppa_pc_requires_run_before_use): New function.
        (hppa_instruction_nullified): New function.
        (hppa_register_byte): New function.
        (hppa_register_virtual_type): New function.
        (hppa_store_struct_return): New function.
        (hppa_cannot_store_register): New function.
        (hppa_frame_args_address): New function.
        (hppa_frame_locals_address): New function.
        (hppa_smash_text_address): New function.
        (hppa_coerce_float_to_double): New function. Requires the inclusion
        of "language.h".

        * Makefile.in (hppa-tdep.o): Add dependency on language.h.

        * tm-hppa.h (REG_STRUCT_HAS_ADDR): Change the definition of this
        gdbarch-eligible macro to a call to the new associated function
        created in hppa-tdep.c.
        (INNER_THAN): Likewise.
        (STACK_ALIGN): Likewise.
        (PC_REQUIRES_RUN_BEFORE_USE): Likewise.
        (INSTRUCTION_NULLIFIED): Likewise.
        (REGISTER_BYTE): Likewise.
        (REGISTER_VIRTUAL_TYPE): Likewise.
        (STORE_STRUCT_RETURN): Likewise.
        (CANNOT_STORE_REGISTER): Likewise.
        (FRAME_ARGS_ADDRESS): Likewise.
        (FRAME_LOCALS_ADDRESS): Likewise.
        (SMASH_TEXT_ADDRESS): Likewise.
        (COERCE_FLOAT_TO_DOUBLE): Likewise.
        (ABOUT_TO_RETURN): Delete, as no longer used.
@
text
@d1472 2
a1473 1
      read_register_bytes (REGISTER_BYTE (regnum), (char *) &freg_buffer, 8);
d1552 2
a1553 1
	write_register_bytes (REGISTER_BYTE (regnum), (char *) &freg_buffer, 8);
d4715 5
a4719 6
  write_register_bytes (REGISTER_BYTE (28)
		        + (TYPE_LENGTH (type) > 4
			   ? (8 - TYPE_LENGTH (type))
			   : (4 - TYPE_LENGTH (type))),
			valbuf,
			TYPE_LENGTH (type));
d4721 2
a4722 3
    write_register_bytes (REGISTER_BYTE (FP4_REGNUM),
			  valbuf,
			  TYPE_LENGTH (type));
@


1.31
log
@       Put in place the framework necessary for multiarching the hppa targets.
       * hppa-tdep.c (hppa_gdbarch_init): New function.
       (hppa_dump_tdep): New function.
       (_initialize_hppa_tdep): Register the hppa gdbarch init function and
       tdep structure dumper.
       * config/pa/tm-hppa.h (GDB_MULTI_ARCH): New macro, defined to 0
       until the multi-arching conversion has partially been completed.
@
text
@d33 1
d134 15
d169 1
d830 5
d4747 145
@


1.30
log
@        * hppa-tdep.c (_initialize_hppa_tdep): Move function body
        to end of file, to be more consistent with the pratice followed
        by other targets.
@
text
@d4727 22
d4757 1
@


1.29
log
@       * hppa-tdep.c (find_function_in_inferior): Remove this extern,
       as this is already provided by value.h, and was actually causing
       a compilation error because of a conflict in parameter type
       declaration due to a missing const keyword.
       (low_text_segment_addres): Fix a compilation warning.
@
text
@a4676 45
void
_initialize_hppa_tdep (void)
{
  struct cmd_list_element *c;
  void break_at_finish_command (char *arg, int from_tty);
  void tbreak_at_finish_command (char *arg, int from_tty);
  void break_at_finish_at_depth_command (char *arg, int from_tty);

  tm_print_insn = print_insn_hppa;

  add_cmd ("unwind", class_maintenance, unwind_command,
	   "Print unwind table entry at given address.",
	   &maintenanceprintlist);

  deprecate_cmd (add_com ("xbreak", class_breakpoint, 
			  break_at_finish_command,
			  concat ("Set breakpoint at procedure exit. \n\
Argument may be function name, or \"*\" and an address.\n\
If function is specified, break at end of code for that function.\n\
If an address is specified, break at the end of the function that contains \n\
that exact address.\n",
		   "With no arg, uses current execution address of selected stack frame.\n\
This is useful for breaking on return to a stack frame.\n\
\n\
Multiple breakpoints at one place are permitted, and useful if conditional.\n\
\n\
Do \"help breakpoints\" for info on other commands dealing with breakpoints.", NULL)), NULL);
  deprecate_cmd (add_com_alias ("xb", "xbreak", class_breakpoint, 1), NULL);
  deprecate_cmd (add_com_alias ("xbr", "xbreak", class_breakpoint, 1), NULL);
  deprecate_cmd (add_com_alias ("xbre", "xbreak", class_breakpoint, 1), NULL);
  deprecate_cmd (add_com_alias ("xbrea", "xbreak", class_breakpoint, 1), NULL);

  deprecate_cmd (c = add_com ("txbreak", class_breakpoint, 
			      tbreak_at_finish_command,
"Set temporary breakpoint at procedure exit.  Either there should\n\
be no argument or the argument must be a depth.\n"), NULL);
  set_cmd_completer (c, location_completer);
  
  if (xdb_commands)
    deprecate_cmd (add_com ("bx", class_breakpoint, 
			    break_at_finish_at_depth_command,
"Set breakpoint at procedure exit.  Either there should\n\
be no argument or the argument must be a depth.\n"), NULL);
}

d4726 46
@


1.28
log
@2002-10-24  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (INIT_SAL): Delete macro.
	(init_sal): Export.
	* symtab.c (init_sal): New function.

	* ada-lang.c (ada_finish_decode_line_1): Change INIT_SAL macro
	to init_sal function call.
	(find_sal_from_funcs_and_line): Ditto.
	(all_sals_for_line): Ditto.
	* breakpoint.c (create_internal_breakpoint): Ditto.
	(create_fork_vfork_event_catchpoint): Ditto.
	(create_exec_event_catchpoint): Ditto.
	(parse_breakpoint_sals): Ditto.
	(watch_command_1): Ditto.
	(handle_gnu_4_16_catch_command): Ditto.
	(clear_command): Ditto.
	* hppa-tdep.c (child_enable_exception_callback): Ditto.
	* infcmd.c (run_stack_dummy): Ditto.
	* infrun.c (process_event_stop_test): Ditto.
	(check_sigtramp2): Ditto.
	(step_over_function): Ditto.
	* linespec.c (decode_line_2): Ditto.
	(decode_line_1): Ditto.
	* source.c (line_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
@
text
@a151 3
/* This is defined in valops.c. */
extern struct value *find_function_in_inferior (char *);

d300 1
a300 1
  if ((section->flags & (SEC_ALLOC | SEC_LOAD | SEC_READONLY)
@


1.27
log
@* frame.h (select_frame): Delete level parameter.
* stack.c (select_frame): Update.  Use frame_relative_level to
obtain the frame's level.
(select_and_print_frame): Update call.
(select_frame_command): Ditto.
(up_silently_base): Ditto.
(down_silently_base): Ditto.
* ocd.c (ocd_start_remote): Ditto.
* remote-rdp.c (remote_rdp_open): Ditto.
* remote-mips.c (mips_initialize): Ditto.
(common_open): Ditto.
* remote-e7000.c (e7000_start_remote): Ditto.
* m3-nat.c (select_thread): Ditto.
* hppa-tdep.c (child_get_current_exception_event): Ditto.
(child_get_current_exception_event): Ditto.
* varobj.c (varobj_create): Ditto.
(varobj_update): Ditto.
(c_value_of_root): Ditto.
* tracepoint.c (finish_tfind_command): Ditto.
* corelow.c (core_open): Ditto.
* arch-utils.c (generic_prepare_to_proceed): Ditto.
* thread.c (info_threads_command): Ditto.
(switch_to_thread): Ditto.
* infrun.c (normal_stop): Ditto.
(restore_selected_frame): Ditto.
(restore_inferior_status): Ditto.
* breakpoint.c (insert_breakpoints): Ditto.
(watchpoint_check): Ditto.
(bpstat_stop_status): Ditto.
(do_enable_breakpoint): Ditto.
* blockframe.c (flush_cached_frames): Ditto.
(reinit_frame_cache): Ditto.
@
text
@d4429 1
a4429 1
  INIT_SAL (break_callback_sal);
@


1.27.6.1
log
@merge from mainline
@
text
@d152 3
d303 1
a303 1
  if (((section->flags & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
d4429 1
a4429 1
  init_sal (break_callback_sal);
@


1.27.12.1
log
@        * hppa-tdep.c (low_text_segment_addres): Fix a compilation warning.
@
text
@d303 1
a303 1
  if (((section->flags & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
@


1.27.16.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d4429 1
a4429 1
  init_sal (break_callback_sal);
@


1.27.16.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 1
a4 1
   1996, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d33 1
a33 4
#include "language.h"
#include "osabi.h"
#include "gdb_assert.h"
#include "infttrace.h"
a35 2
#include "infcall.h"
#include "dis-asm.h"
a62 30
#include "hppa-tdep.h"

/* Some local constants.  */
static const int hppa32_num_regs = 128;
static const int hppa64_num_regs = 96;

static const int hppa64_call_dummy_breakpoint_offset = 22 * 4;

/* DEPRECATED_CALL_DUMMY_LENGTH is computed based on the size of a
   word on the target machine, not the size of an instruction.  Since
   a word on this target holds two instructions we have to divide the
   instruction size by two to get the word size of the dummy.  */
static const int hppa32_call_dummy_length = INSTRUCTION_SIZE * 28;
static const int hppa64_call_dummy_length = INSTRUCTION_SIZE * 26 / 2;

/* Get at various relevent fields of an instruction word. */
#define MASK_5 0x1f
#define MASK_11 0x7ff
#define MASK_14 0x3fff
#define MASK_21 0x1fffff

/* Define offsets into the call dummy for the target function address.
   See comments related to CALL_DUMMY for more info.  */
#define FUNC_LDIL_OFFSET (INSTRUCTION_SIZE * 9)
#define FUNC_LDO_OFFSET (INSTRUCTION_SIZE * 10)

/* Define offsets into the call dummy for the _sr4export address.
   See comments related to CALL_DUMMY for more info.  */
#define SR4EXPORT_LDIL_OFFSET (INSTRUCTION_SIZE * 12)
#define SR4EXPORT_LDO_OFFSET (INSTRUCTION_SIZE * 13)
a68 6
/* Sizes (in bytes) of the native unwind entries.  */
#define UNWIND_ENTRY_SIZE 16
#define STUB_UNWIND_ENTRY_SIZE 8

static int get_field (unsigned word, int from, int to);

d75 2
a76 1
static void find_dummy_frame_regs (struct frame_info *, CORE_ADDR *);
d100 1
a100 1
static int restore_pc_queue (CORE_ADDR *);
d104 3
a132 46
/* FIXME: brobecker 2002-11-07: We will likely be able to make the
   following functions static, once we hppa is partially multiarched.  */
int hppa_reg_struct_has_addr (int gcc_p, struct type *type);
CORE_ADDR hppa_skip_prologue (CORE_ADDR pc);
CORE_ADDR hppa_skip_trampoline_code (CORE_ADDR pc);
int hppa_in_solib_call_trampoline (CORE_ADDR pc, char *name);
int hppa_in_solib_return_trampoline (CORE_ADDR pc, char *name);
CORE_ADDR hppa_saved_pc_after_call (struct frame_info *frame);
int hppa_inner_than (CORE_ADDR lhs, CORE_ADDR rhs);
CORE_ADDR hppa32_stack_align (CORE_ADDR sp);
CORE_ADDR hppa64_stack_align (CORE_ADDR sp);
int hppa_pc_requires_run_before_use (CORE_ADDR pc);
int hppa_instruction_nullified (void);
int hppa_register_raw_size (int reg_nr);
int hppa_register_byte (int reg_nr);
struct type * hppa32_register_virtual_type (int reg_nr);
struct type * hppa64_register_virtual_type (int reg_nr);
void hppa_store_struct_return (CORE_ADDR addr, CORE_ADDR sp);
void hppa32_extract_return_value (struct type *type, char *regbuf,
                                  char *valbuf);
void hppa64_extract_return_value (struct type *type, char *regbuf,
                                  char *valbuf);
int hppa32_use_struct_convention (int gcc_p, struct type *type);
int hppa64_use_struct_convention (int gcc_p, struct type *type);
void hppa32_store_return_value (struct type *type, char *valbuf);
void hppa64_store_return_value (struct type *type, char *valbuf);
CORE_ADDR hppa_extract_struct_value_address (char *regbuf);
int hppa_cannot_store_register (int regnum);
void hppa_init_extra_frame_info (int fromleaf, struct frame_info *frame);
CORE_ADDR hppa_frame_chain (struct frame_info *frame);
int hppa_frame_chain_valid (CORE_ADDR chain, struct frame_info *thisframe);
int hppa_frameless_function_invocation (struct frame_info *frame);
CORE_ADDR hppa_frame_saved_pc (struct frame_info *frame);
CORE_ADDR hppa_frame_args_address (struct frame_info *fi);
int hppa_frame_num_args (struct frame_info *frame);
void hppa_push_dummy_frame (void);
void hppa_pop_frame (void);
CORE_ADDR hppa_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun,
                               int nargs, struct value **args,
                               struct type *type, int gcc_p);
CORE_ADDR hppa_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		               int struct_return, CORE_ADDR struct_addr);
CORE_ADDR hppa_smash_text_address (CORE_ADDR addr);
CORE_ADDR hppa_target_read_pc (ptid_t ptid);
void hppa_target_write_pc (CORE_ADDR v, ptid_t ptid);
CORE_ADDR hppa_target_read_fp (void);
d142 1
a142 1
static int cover_find_stub_with_shl_get (void *);
d152 3
a155 1

d157 1
a157 1
hppa32_use_struct_convention (int gcc_p, struct type *type)
d159 1
a159 10
  return (TYPE_LENGTH (type) > 2 * DEPRECATED_REGISTER_SIZE);
}

/* Same as hppa32_use_struct_convention() for the PA64 ABI.  */

int
hppa64_use_struct_convention (int gcc_p, struct type *type)
{
  /* RM: struct upto 128 bits are returned in registers */
  return TYPE_LENGTH (type) > 16;
d161 1
a182 9
/* Extract the bits at positions between FROM and TO, using HP's numbering
   (MSB = 0). */

static int
get_field (unsigned word, int from, int to)
{
  return ((word) >> (31 - (to)) & ((1 << ((to) - (from) + 1)) - 1));
}

d234 1
a234 1
  val = get_field (word, 20, 20);
d236 1
a236 1
  val |= get_field (word, 9, 19);
d238 1
a238 1
  val |= get_field (word, 5, 6);
d240 1
a240 1
  val |= get_field (word, 0, 4);
d242 1
a242 1
  val |= get_field (word, 7, 8);
d255 1
a255 1
  val |= get_field (opnd, 11 + 14, 11 + 18);
d257 1
a257 1
  val |= get_field (opnd, 11 + 12, 11 + 13);
d259 1
a259 1
  val |= get_field (opnd, 11 + 19, 11 + 20);
d261 1
a261 1
  val |= get_field (opnd, 11 + 1, 11 + 11);
d263 1
a263 1
  val |= get_field (opnd, 11 + 0, 11 + 0);
d273 3
a275 3
  return sign_extend (get_field (word, 19, 28) |
		      get_field (word, 29, 29) << 10 |
		      get_field (word, 11, 15) << 11 |
d303 1
a303 1
  if (((section->flags & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
d333 1
a333 1
				 record_text_segment_lowaddr, NULL);
d534 1
a534 1
      objfile->obj_private = obj_private;
a600 90
const unsigned char *
hppa_breakpoint_from_pc (CORE_ADDR *pc, int *len)
{
  static const char breakpoint[] = {0x00, 0x01, 0x00, 0x04};
  (*len) = sizeof (breakpoint);
  return breakpoint;
}

/* Return the name of a register.  */

const char *
hppa32_register_name (int i)
{
  static char *names[] = {
    "flags",  "r1",      "rp",     "r3",
    "r4",     "r5",      "r6",     "r7",
    "r8",     "r9",      "r10",    "r11",
    "r12",    "r13",     "r14",    "r15",
    "r16",    "r17",     "r18",    "r19",
    "r20",    "r21",     "r22",    "r23",
    "r24",    "r25",     "r26",    "dp",
    "ret0",   "ret1",    "sp",     "r31",
    "sar",    "pcoqh",   "pcsqh",  "pcoqt",
    "pcsqt",  "eiem",    "iir",    "isr",
    "ior",    "ipsw",    "goto",   "sr4",
    "sr0",    "sr1",     "sr2",    "sr3",
    "sr5",    "sr6",     "sr7",    "cr0",
    "cr8",    "cr9",     "ccr",    "cr12",
    "cr13",   "cr24",    "cr25",   "cr26",
    "mpsfu_high","mpsfu_low","mpsfu_ovflo","pad",
    "fpsr",    "fpe1",   "fpe2",   "fpe3",
    "fpe4",   "fpe5",    "fpe6",   "fpe7",
    "fr4",     "fr4R",   "fr5",    "fr5R",
    "fr6",    "fr6R",    "fr7",    "fr7R",
    "fr8",     "fr8R",   "fr9",    "fr9R",
    "fr10",   "fr10R",   "fr11",   "fr11R",
    "fr12",    "fr12R",  "fr13",   "fr13R",
    "fr14",   "fr14R",   "fr15",   "fr15R",
    "fr16",    "fr16R",  "fr17",   "fr17R",
    "fr18",   "fr18R",   "fr19",   "fr19R",
    "fr20",    "fr20R",  "fr21",   "fr21R",
    "fr22",   "fr22R",   "fr23",   "fr23R",
    "fr24",    "fr24R",  "fr25",   "fr25R",
    "fr26",   "fr26R",   "fr27",   "fr27R",
    "fr28",    "fr28R",  "fr29",   "fr29R",
    "fr30",   "fr30R",   "fr31",   "fr31R"
  };
  if (i < 0 || i >= (sizeof (names) / sizeof (*names)))
    return NULL;
  else
    return names[i];
}

const char *
hppa64_register_name (int i)
{
  static char *names[] = {
    "flags",  "r1",      "rp",     "r3",
    "r4",     "r5",      "r6",     "r7",
    "r8",     "r9",      "r10",    "r11",
    "r12",    "r13",     "r14",    "r15",
    "r16",    "r17",     "r18",    "r19",
    "r20",    "r21",     "r22",    "r23",
    "r24",    "r25",     "r26",    "dp",
    "ret0",   "ret1",    "sp",     "r31",
    "sar",    "pcoqh",   "pcsqh",  "pcoqt",
    "pcsqt",  "eiem",    "iir",    "isr",
    "ior",    "ipsw",    "goto",   "sr4",
    "sr0",    "sr1",     "sr2",    "sr3",
    "sr5",    "sr6",     "sr7",    "cr0",
    "cr8",    "cr9",     "ccr",    "cr12",
    "cr13",   "cr24",    "cr25",   "cr26",
    "mpsfu_high","mpsfu_low","mpsfu_ovflo","pad",
    "fpsr",    "fpe1",   "fpe2",   "fpe3",
    "fr4",    "fr5",     "fr6",    "fr7",
    "fr8",     "fr9",    "fr10",   "fr11",
    "fr12",   "fr13",    "fr14",   "fr15",
    "fr16",    "fr17",   "fr18",   "fr19",
    "fr20",   "fr21",    "fr22",   "fr23",
    "fr24",    "fr25",   "fr26",   "fr27",
    "fr28",  "fr29",    "fr30",   "fr31"
  };
  if (i < 0 || i >= (sizeof (names) / sizeof (*names)))
    return NULL;
  else
    return names[i];
}



d637 1
a637 1
	  && !PC_IN_SIGTRAMP (pc, DEPRECATED_SYMBOL_NAME (msym_us)));
d755 1
a755 1
      && !PC_IN_SIGTRAMP (pc, DEPRECATED_SYMBOL_NAME (msym_us)))
d804 1
a804 1
hppa_frameless_function_invocation (struct frame_info *frame)
d808 1
a808 1
  u = find_unwind_entry (get_frame_pc (frame));
a815 5
/* Immediately after a function call, return the saved pc.
   Can't go through the frames for this because on some machines
   the new frame is not set up until the new function executes
   some instructions.  */

d817 1
a817 1
hppa_saved_pc_after_call (struct frame_info *frame)
d830 1
a830 1
    return DEPRECATED_FRAME_SAVED_PC (frame);
d840 1
a840 1
  CORE_ADDR old_pc = 0;
d849 1
a849 1
    return read_memory_integer (get_frame_base (frame) + PC_REGNUM * 4,
d852 15
a866 16
  if ((get_frame_pc (frame) >= get_frame_base (frame)
       && (get_frame_pc (frame)
	   <= (get_frame_base (frame)
	       /* A call dummy is sized in words, but it is actually a
		  series of instructions.  Account for that scaling
		  factor.  */
	       + ((DEPRECATED_REGISTER_SIZE / INSTRUCTION_SIZE)
		  * DEPRECATED_CALL_DUMMY_LENGTH)
	       /* Similarly we have to account for 64bit wide register
		  saves.  */
	       + (32 * DEPRECATED_REGISTER_SIZE)
	       /* We always consider FP regs 8 bytes long.  */
	       + (NUM_REGS - FP0_REGNUM) * 8
	       /* Similarly we have to account for 64bit wide register
		  saves.  */
	       + (6 * DEPRECATED_REGISTER_SIZE)))))
d868 1
a868 1
      return read_memory_integer ((get_frame_base (frame)
d875 1
a875 1
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
d883 1
a883 1
  if (hppa_frameless_function_invocation (frame))
d893 8
a900 8
      if (get_next_frame (frame)
	  && ((get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME)
	      || pc_in_interrupt_handler (get_frame_pc (get_next_frame (frame)))))
	{
	  CORE_ADDR *saved_regs;
	  hppa_frame_init_saved_regs (get_next_frame (frame));
	  saved_regs = deprecated_get_frame_saved_regs (get_next_frame (frame));
	  if (read_memory_integer (saved_regs[FLAGS_REGNUM],
d903 1
a903 1
	      pc = read_memory_integer (saved_regs[31],
d910 2
a911 2
	      if (pc == get_frame_pc (frame))
		pc = read_memory_integer (saved_regs[RP_REGNUM],
d915 1
a915 1
	    pc = read_memory_integer (saved_regs[RP_REGNUM],
d933 8
a940 8
	  && get_next_frame (frame)
	  && ((get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME)
	      || pc_in_interrupt_handler (get_frame_pc (get_next_frame (frame)))))
	{
	  CORE_ADDR *saved_regs;
	  hppa_frame_init_saved_regs (get_next_frame (frame));
	  saved_regs = deprecated_get_frame_saved_regs (get_next_frame (frame));
	  if (read_memory_integer (saved_regs[FLAGS_REGNUM],
d943 1
a943 1
	      pc = read_memory_integer (saved_regs[31],
d950 2
a951 2
	      if (pc == get_frame_pc (frame))
		pc = read_memory_integer (saved_regs[RP_REGNUM],
d955 1
a955 1
	    pc = read_memory_integer (saved_regs[RP_REGNUM],
d966 1
a966 1
	  pc = read_memory_integer (get_frame_base (frame) + rp_offset,
d1015 1
a1015 1
hppa_init_extra_frame_info (int fromleaf, struct frame_info *frame)
d1020 1
a1020 1
  if (get_next_frame (frame) && !fromleaf)
d1023 3
a1025 4
  /* If the next frame represents a frameless function invocation then
     we have to do some adjustments that are normally done by
     DEPRECATED_FRAME_CHAIN.  (DEPRECATED_FRAME_CHAIN is not called in
     this case.)  */
d1030 1
a1030 1
      framesize = find_proc_framesize (DEPRECATED_FRAME_SAVED_PC (get_next_frame (frame)));
d1037 1
a1037 1
	deprecated_update_frame_base_hack (frame, deprecated_read_fp ());
d1039 1
a1039 1
	deprecated_update_frame_base_hack (frame, get_frame_base (frame) - framesize);
d1045 1
a1045 1
    deprecated_update_frame_pc_hack (frame, read_register (31) & ~0x3);
d1056 1
a1056 1
  framesize = find_proc_framesize (get_frame_pc (frame));
d1058 1
a1058 1
    deprecated_update_frame_base_hack (frame, deprecated_read_fp ());
d1060 1
a1060 1
    deprecated_update_frame_base_hack (frame, read_register (SP_REGNUM) - framesize);
d1063 3
a1065 4
/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct, and
   then DEPRECATED_INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC
   will be called for the new frame.
d1072 1
a1072 1
hppa_frame_chain (struct frame_info *frame)
d1081 3
a1083 3
  /* Where the registers were saved in saved_regs_frame.  If
     saved_regs_frame is zero, this is garbage.  */
  CORE_ADDR *saved_regs = NULL;
d1094 2
a1095 2
  min_frame_symbol = lookup_minimal_symbol_by_pc (get_frame_pc (frame));
  frame_symbol = find_pc_function (get_frame_pc (frame));
d1107 1
a1107 1
      frame_symbol_name = DEPRECATED_SYMBOL_NAME (min_frame_symbol);
d1124 2
a1125 2
  if (pc_in_interrupt_handler (get_frame_pc (frame)))
    frame_base = read_memory_integer (get_frame_base (frame) + SP_REGNUM * 4,
d1128 1
a1128 1
  else if ((get_frame_type (frame) == SIGTRAMP_FRAME))
d1134 1
a1134 1
    frame_base = get_frame_base (frame);
d1138 2
a1139 2
  my_framesize = find_proc_framesize (get_frame_pc (frame));
  caller_pc = DEPRECATED_FRAME_SAVED_PC (frame);
d1147 1
a1147 1
  caller_framesize = find_proc_framesize (DEPRECATED_FRAME_SAVED_PC (frame));
d1178 1
a1178 1
  for (tmp_frame = frame; tmp_frame; tmp_frame = get_next_frame (tmp_frame))
d1180 1
a1180 1
      u = find_unwind_entry (get_frame_pc (tmp_frame));
d1193 1
a1193 1
	  warning ("Unable to find unwind for PC 0x%x -- Help!", get_frame_pc (tmp_frame));
d1199 2
a1200 2
	  || (get_frame_type (tmp_frame) == SIGTRAMP_FRAME)
	  || pc_in_interrupt_handler (get_frame_pc (tmp_frame)))
d1210 1
a1210 2
	  hppa_frame_init_saved_regs (tmp_frame);
	  saved_regs = deprecated_get_frame_saved_regs (tmp_frame);
d1214 1
a1214 1
	  if (saved_regs[DEPRECATED_FP_REGNUM])
d1224 2
a1225 2
	  && !(get_frame_type (tmp_frame) == SIGTRAMP_FRAME)
	  && !pc_in_interrupt_handler (get_frame_pc (tmp_frame)))
d1227 1
a1227 1
	  return read_memory_integer (get_frame_base (tmp_frame), TARGET_PTR_BIT / 8);
d1259 1
a1259 4
	    {
	      hppa_frame_init_saved_regs (tmp_frame);
	      saved_regs = deprecated_get_frame_saved_regs (tmp_frame);
	    }
d1263 2
a1264 2
	      && ((saved_regs[FLAGS_REGNUM]
		   && (read_memory_integer (saved_regs[FLAGS_REGNUM],
d1267 1
a1267 1
		  || (saved_regs[FLAGS_REGNUM] == 0
d1270 1
a1270 1
	      u = find_unwind_entry (DEPRECATED_FRAME_SAVED_PC (frame));
d1273 1
a1273 1
		  return read_memory_integer (saved_regs[DEPRECATED_FP_REGNUM],
d1282 1
a1282 1
	  return read_memory_integer (saved_regs[DEPRECATED_FP_REGNUM],
d1290 2
a1291 2
      while (get_next_frame (tmp_frame) != NULL)
	tmp_frame = get_next_frame (tmp_frame);
d1294 1
a1294 4
	{
	  hppa_frame_init_saved_regs (tmp_frame);
	  saved_regs = deprecated_get_frame_saved_regs (tmp_frame);
	}
d1298 2
a1299 2
	  && ((saved_regs[FLAGS_REGNUM]
	       && (read_memory_integer (saved_regs[FLAGS_REGNUM],
d1302 1
a1302 1
	      || (saved_regs[FLAGS_REGNUM] == 0
d1305 1
a1305 1
	  u = find_unwind_entry (DEPRECATED_FRAME_SAVED_PC (frame));
d1308 1
a1308 1
	      return read_memory_integer (saved_regs[DEPRECATED_FP_REGNUM],
d1319 1
a1319 1
      return deprecated_read_fp ();
d1335 4
a1338 1
  u = find_unwind_entry (get_frame_pc (thisframe));
d1349 1
a1349 1
  msym_us = lookup_minimal_symbol_by_pc (DEPRECATED_FRAME_SAVED_PC (thisframe));
d1366 1
a1366 1
    next_u = find_unwind_entry (get_frame_pc (next));
d1372 1
a1372 1
      || (get_next_frame (thisframe) && (get_frame_type (get_next_frame (thisframe)) == SIGTRAMP_FRAME))
d1376 1
a1376 1
  if (pc_in_linker_stub (get_frame_pc (thisframe)))
d1382 5
a1386 4
/* These functions deal with saving and restoring register state
   around a function call in the inferior.  They keep the stack
   double-word aligned;  eventually, on an hp700, the stack will have
   to be aligned to a 64-byte boundary.  */
d1389 1
a1389 1
hppa_push_dummy_frame (void)
d1392 1
a1392 1
  int regnum;
d1396 10
a1405 1
  pc = hppa_target_read_pc (inferior_ptid);
d1409 6
a1414 1
      const unsigned int sid = (pc >> 30) & 0x3;
d1419 2
d1431 2
a1432 2
  if (DEPRECATED_REGISTER_SIZE == 8)
    write_memory (sp - 16, (char *) &int_buffer, DEPRECATED_REGISTER_SIZE);
d1434 1
a1434 1
    write_memory (sp - 20, (char *) &int_buffer, DEPRECATED_REGISTER_SIZE);
d1436 2
a1437 2
  int_buffer = deprecated_read_fp ();
  write_memory (sp, (char *) &int_buffer, DEPRECATED_REGISTER_SIZE);
d1439 1
a1439 1
  write_register (DEPRECATED_FP_REGNUM, sp);
d1441 1
a1441 1
  sp += 2 * DEPRECATED_REGISTER_SIZE;
d1444 1
a1444 1
    if (regnum != RP_REGNUM && regnum != DEPRECATED_FP_REGNUM)
d1448 1
a1448 1
  if (DEPRECATED_REGISTER_SIZE != 8)
d1453 1
a1453 2
      deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (regnum),
				      (char *) &freg_buffer, 8);
d1467 1
a1467 1
		       CORE_ADDR frame_saved_regs[])
d1469 1
a1469 1
  CORE_ADDR fp = get_frame_base (frame);
d1473 2
a1474 2
  if (DEPRECATED_REGISTER_SIZE == 8)
    frame_saved_regs[RP_REGNUM] = (fp - 16) & ~0x3;
d1476 1
a1476 1
    frame_saved_regs[RP_REGNUM] = (fp - 20) & ~0x3;
d1478 1
a1478 1
  frame_saved_regs[DEPRECATED_FP_REGNUM] = fp;
d1480 1
a1480 1
  frame_saved_regs[1] = fp + (2 * DEPRECATED_REGISTER_SIZE);
d1482 1
a1482 1
  for (fp += 3 * DEPRECATED_REGISTER_SIZE, i = 3; i < 32; i++)
d1484 1
a1484 1
      if (i != DEPRECATED_FP_REGNUM)
d1486 2
a1487 2
	  frame_saved_regs[i] = fp;
	  fp += DEPRECATED_REGISTER_SIZE;
d1492 1
a1492 1
  if (DEPRECATED_REGISTER_SIZE != 8)
d1496 1
a1496 1
    frame_saved_regs[i] = fp;
d1498 6
a1503 6
  frame_saved_regs[IPSW_REGNUM] = fp;
  frame_saved_regs[SAR_REGNUM] = fp + DEPRECATED_REGISTER_SIZE;
  frame_saved_regs[PCOQ_HEAD_REGNUM] = fp + 2 * DEPRECATED_REGISTER_SIZE;
  frame_saved_regs[PCSQ_HEAD_REGNUM] = fp + 3 * DEPRECATED_REGISTER_SIZE;
  frame_saved_regs[PCOQ_TAIL_REGNUM] = fp + 4 * DEPRECATED_REGISTER_SIZE;
  frame_saved_regs[PCSQ_TAIL_REGNUM] = fp + 5 * DEPRECATED_REGISTER_SIZE;
d1509 4
a1512 4
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR fp, npc, target_pc;
  int regnum;
  CORE_ADDR *fsr;
d1515 2
a1516 3
  fp = get_frame_base (frame);
  hppa_frame_init_saved_regs (frame);
  fsr = deprecated_get_frame_saved_regs (frame);
d1519 2
a1520 2
  if (fsr[IPSW_REGNUM])	/* Restoring a call dummy frame */
    restore_pc_queue (fsr);
d1524 3
a1526 3
    if (fsr[regnum])
      write_register (regnum, read_memory_integer (fsr[regnum],
						   DEPRECATED_REGISTER_SIZE));
d1529 1
a1529 1
    if (fsr[regnum])
d1531 2
a1532 3
	read_memory (fsr[regnum], (char *) &freg_buffer, 8);
	deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (regnum),
					 (char *) &freg_buffer, 8);
d1535 1
a1535 1
  if (fsr[IPSW_REGNUM])
d1537 2
a1538 2
		    read_memory_integer (fsr[IPSW_REGNUM],
					 DEPRECATED_REGISTER_SIZE));
d1540 1
a1540 1
  if (fsr[SAR_REGNUM])
d1542 2
a1543 2
		    read_memory_integer (fsr[SAR_REGNUM],
					 DEPRECATED_REGISTER_SIZE));
d1546 1
a1546 1
  if (fsr[PCOQ_TAIL_REGNUM])
d1548 2
a1549 2
      npc = read_memory_integer (fsr[PCOQ_TAIL_REGNUM],
				 DEPRECATED_REGISTER_SIZE);
d1559 1
a1559 1
  write_register (DEPRECATED_FP_REGNUM, read_memory_integer (fp, DEPRECATED_REGISTER_SIZE));
d1561 1
a1561 1
  if (fsr[IPSW_REGNUM])	/* call dummy */
d1574 1
a1574 1
  if (target_pc && !fsr[IPSW_REGNUM])
d1584 1
a1584 1
      breakpoint = set_momentary_breakpoint (sal, null_frame_id, bp_finish);
d1605 1
a1605 1
restore_pc_queue (CORE_ADDR *fsr)
d1608 1
a1608 1
  CORE_ADDR new_pc = read_memory_integer (fsr[PCOQ_HEAD_REGNUM],
d1627 2
a1628 2
  write_register (21, read_memory_integer (fsr[PCSQ_HEAD_REGNUM],
					   DEPRECATED_REGISTER_SIZE));
d1687 1
a1687 1
  CORE_ADDR orig_sp = DEPRECATED_STACK_ALIGN (sp);
d1708 1
a1708 1
	  && TYPE_LENGTH (arg_type) < DEPRECATED_REGISTER_SIZE)
d1721 1
a1721 1
      bytes_reserved = (lengths[i] + DEPRECATED_REGISTER_SIZE - 1) & -DEPRECATED_REGISTER_SIZE;
d1733 2
a1734 2
	  int new_offset = ((offset[i] + 2*DEPRECATED_REGISTER_SIZE-1)
			    & -(2*DEPRECATED_REGISTER_SIZE));
d1750 1
a1750 1
  cum_bytes_aligned = DEPRECATED_STACK_ALIGN (cum_bytes_reserved);
d1821 1
a1821 1
      bytes_reserved = (lengths[i] + DEPRECATED_REGISTER_SIZE - 1) & -DEPRECATED_REGISTER_SIZE;
d1828 2
a1829 2
      if ((bytes_reserved == 2 * DEPRECATED_REGISTER_SIZE)
	  && (offset[i] % 2 * DEPRECATED_REGISTER_SIZE))
d1837 2
a1838 2
	  new_offset = ((offset[i] + 2 * DEPRECATED_REGISTER_SIZE - 1)
			& -(2 * DEPRECATED_REGISTER_SIZE));
d1840 1
a1840 1
	  if ((new_offset - offset[i]) >= 2 * DEPRECATED_REGISTER_SIZE)
d1842 2
a1843 2
	      bytes_reserved += DEPRECATED_REGISTER_SIZE;
	      offset[i] += DEPRECATED_REGISTER_SIZE;
d1857 1
a1857 1
  cum_bytes_aligned = DEPRECATED_STACK_ALIGN (cum_bytes_reserved);
d1877 21
d1934 1
a1934 1
  get_sym = lookup_symbol ("__d_shl_get", NULL, VAR_DOMAIN, NULL, NULL);
d1937 1
a1937 1
  symbol2 = lookup_symbol ("__shldp", NULL, VAR_DOMAIN, NULL, NULL);
d1939 1
a1939 1
  namelen = strlen (DEPRECATED_SYMBOL_NAME (function));
d1952 1
a1952 1
  target_write_memory (endo_buff_addr, DEPRECATED_SYMBOL_NAME (function), namelen);
d1987 1
a1987 1
cover_find_stub_with_shl_get (void *args_untyped)
d1998 3
a2000 3
   Therefore our version of DEPRECATED_FIX_CALL_DUMMY takes an extra
   argument, real_pc, which is the location where gdb should start up
   the inferior to do the function call.
d2156 1
a2156 1
					       DEPRECATED_REGISTER_SIZE));
d2190 1
a2190 1
	      (DEPRECATED_SYMBOL_NAME (funsymbol), objfile);
d2193 1
a2193 1
	      stub_symbol = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (funsymbol),
d2294 1
a2294 1
	    error ("Can't find an import stub for %s", DEPRECATED_SYMBOL_NAME (fmsymbol));
d2380 1
a2380 1
  else if (som_solib_get_got_by_pc (hppa_target_read_pc (inferior_ptid)))
d2388 3
a2393 1

d2395 1
a2395 1
hppa_read_fp (int pid)
d2405 2
a2406 2
     register.  All others must use deprecated_read_fp (). */
  return read_register (DEPRECATED_FP_REGNUM);
a2408 5
CORE_ADDR
hppa_target_read_fp (void)
{
  return hppa_read_fp (PIDGET (inferior_ptid));
}
d2414 1
a2414 1
hppa_target_read_pc (ptid_t ptid)
d2431 1
a2431 1
hppa_target_write_pc (CORE_ADDR v, ptid_t ptid)
d2444 1
a2444 1
  write_register_pid (DEPRECATED_NPC_REGNUM, v + 4, ptid);
d2487 1
a2487 1
  char *raw_regs = alloca (DEPRECATED_REGISTER_BYTES);
d2493 1
a2493 2
    frame_register_read (deprecated_selected_frame, i,
			 raw_regs + DEPRECATED_REGISTER_BYTE (i));
d2531 1
a2531 1
  char *raw_regs = alloca (DEPRECATED_REGISTER_BYTES);
d2537 1
a2537 2
    frame_register_read (deprecated_selected_frame, i,
			 raw_regs + DEPRECATED_REGISTER_BYTE (i));
d2584 1
a2584 1
  int i;
d2588 1
a2588 1
  char buf[MAX_REGISTER_SIZE];
d2606 1
a2606 1
      raw_val[1] = *(long *) (raw_regs + DEPRECATED_REGISTER_BYTE (regnum));
d2785 2
a2786 2
  char raw_buffer[MAX_REGISTER_SIZE];
  char virtual_buffer[MAX_REGISTER_SIZE];
d2789 1
a2789 1
  frame_register_read (deprecated_selected_frame, i, raw_buffer);
d2792 1
a2792 1
  memcpy (virtual_buffer, raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (i));
d2798 1
a2798 1
  val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0, gdb_stdout, 0,
d2807 1
a2807 1
      frame_register_read (deprecated_selected_frame, i + 1, raw_buffer);
d2810 2
a2811 2
      memcpy (virtual_buffer + DEPRECATED_REGISTER_RAW_SIZE (i), raw_buffer,
	      DEPRECATED_REGISTER_RAW_SIZE (i));
d2828 2
a2829 2
  char raw_buffer[MAX_REGISTER_SIZE];
  char virtual_buffer[MAX_REGISTER_SIZE];
d2835 1
a2835 1
  frame_register_read (deprecated_selected_frame, i, raw_buffer);
d2838 1
a2838 1
  memcpy (virtual_buffer, raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (i));
d2843 1
a2843 1
      char raw_buf[MAX_REGISTER_SIZE];
d2846 1
a2846 1
      frame_register_read (deprecated_selected_frame, i + 1, raw_buf);
d2849 1
a2849 2
      memcpy (virtual_buffer + DEPRECATED_REGISTER_RAW_SIZE (i), raw_buf,
	      DEPRECATED_REGISTER_RAW_SIZE (i));
d2857 1
a2857 1
      val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0, stream, 0,
d2869 1
a2869 1
hppa_in_solib_call_trampoline (CORE_ADDR pc, char *name)
d2903 2
a2904 3
    if (bfd_get_section_vma (sec->owner, sec) <= pc
	&& pc < (bfd_get_section_vma (sec->owner, sec)
		 + bfd_section_size (sec->owner, sec)))
d2967 1
a2967 1
  if (minsym && strcmp (DEPRECATED_SYMBOL_NAME (minsym), ".stub") == 0)
d3029 1
a3029 1
hppa_in_solib_return_trampoline (CORE_ADDR pc, char *name)
d3102 1
a3102 1
hppa_skip_trampoline_code (CORE_ADDR pc)
d3210 1
a3210 1
		&& DEPRECATED_STREQ (DEPRECATED_SYMBOL_NAME (msymbol), DEPRECATED_SYMBOL_NAME (msym)))
d3305 1
a3305 1
	  libsym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (stubsym), NULL, NULL);
d3309 1
a3309 1
		       DEPRECATED_SYMBOL_NAME (stubsym));
d3548 1
a3548 1
      if (u->Save_SP && i == DEPRECATED_FP_REGNUM)
d3809 5
a3813 5
/* Put here the code to store, into the SAVED_REGS, the addresses of
   the saved registers of frame described by FRAME_INFO.  This
   includes special registers such as pc and fp saved in special ways
   in the stack frame.  sp is even more special: the address we return
   for it IS the sp for the next frame.  */
d3817 1
a3817 1
			    CORE_ADDR frame_saved_regs[])
d3828 1
a3828 1
  memset (frame_saved_regs, '\0', SIZEOF_FRAME_SAVED_REGS);
d3834 15
a3848 16
  if ((get_frame_pc (frame_info) >= get_frame_base (frame_info)
       && (get_frame_pc (frame_info)
	   <= (get_frame_base (frame_info)
	       /* A call dummy is sized in words, but it is actually a
		  series of instructions.  Account for that scaling
		  factor.  */
	       + ((DEPRECATED_REGISTER_SIZE / INSTRUCTION_SIZE)
		  * DEPRECATED_CALL_DUMMY_LENGTH)
	       /* Similarly we have to account for 64bit wide register
		  saves.  */
	       + (32 * DEPRECATED_REGISTER_SIZE)
	       /* We always consider FP regs 8 bytes long.  */
	       + (NUM_REGS - FP0_REGNUM) * 8
	       /* Similarly we have to account for 64bit wide register
		  saves.  */
	       + (6 * DEPRECATED_REGISTER_SIZE)))))
d3853 1
a3853 1
  if (pc_in_interrupt_handler (get_frame_pc (frame_info)))
d3859 2
a3860 2
	    frame_saved_regs[SP_REGNUM]
	      = read_memory_integer (get_frame_base (frame_info) + SP_REGNUM * 4,
d3863 1
a3863 1
	    frame_saved_regs[i] = get_frame_base (frame_info) + i * 4;
d3870 1
a3870 1
  if ((get_frame_type (frame_info) == SIGTRAMP_FRAME))
d3879 1
a3879 1
  pc = get_frame_func (frame_info);
d3898 1
a3898 1
      if (u->Save_SP && i == DEPRECATED_FP_REGNUM)
d3912 1
a3912 1
  frame_saved_regs[SP_REGNUM] = get_frame_base (frame_info);
d3930 1
a3930 1
	 && pc <= get_frame_pc (frame_info))
d3947 1
a3947 1
	  frame_saved_regs[RP_REGNUM] = get_frame_base (frame_info) - 20;
d3952 1
a3952 1
	  frame_saved_regs[RP_REGNUM] = get_frame_base (frame_info) - 16;
d3960 1
a3960 1
	  frame_saved_regs[DEPRECATED_FP_REGNUM] = get_frame_base (frame_info);
d3967 1
a3967 1
	  && (!u->Save_SP || reg != DEPRECATED_FP_REGNUM))
d3974 1
a3974 1
	    frame_saved_regs[reg] = get_frame_base (frame_info);
d3977 1
a3977 1
	    frame_saved_regs[reg] = get_frame_base (frame_info);
d3991 2
a3992 2
		frame_saved_regs[reg]
		  = get_frame_base (frame_info) + offset;
d3994 2
a3995 2
		frame_saved_regs[reg]
		  = (get_frame_base (frame_info) + (u->Total_frame_size << 3)
d4027 1
a4027 1
	      frame_saved_regs[reg + FP4_REGNUM + 4] = get_frame_base (frame_info);
d4032 2
a4033 2
	      frame_saved_regs[reg + FP0_REGNUM + 4]
		= get_frame_base (frame_info) + fp_loc;
a4051 11
/* XXX - deprecated.  This is a compatibility function for targets
   that do not yet implement DEPRECATED_FRAME_INIT_SAVED_REGS.  */
/* Find the addresses in which registers are saved in FRAME.  */

void
hppa_frame_init_saved_regs (struct frame_info *frame)
{
  if (deprecated_get_frame_saved_regs (frame) == NULL)
    frame_saved_regs_zalloc (frame);
  hppa_frame_find_saved_regs (frame, deprecated_get_frame_saved_regs (frame));
}
d4252 1
a4252 1
      catch_errors (cover_find_stub_with_shl_get, &args, message,
d4291 1
a4291 1
		       VAR_DOMAIN, 0, (struct symtab **) NULL);
d4317 1
a4317 1
		       VAR_DOMAIN, 0, (struct symtab **) NULL);
d4495 1
a4495 1
  throw_addr = get_frame_pc (fi);
a4506 10
/* Instead of this nasty cast, add a method pvoid() that prints out a
   host VOID data type (remember %p isn't portable).  */

static CORE_ADDR
hppa_pointer_to_address_hack (void *ptr)
{
  gdb_assert (sizeof (ptr) == TYPE_LENGTH (builtin_type_void_data_ptr));
  return POINTER_TO_ADDRESS (builtin_type_void_data_ptr, &ptr);
}

d4529 1
a4529 1
		     paddr_nz (hppa_pointer_to_address_hack (u)));
d4570 1
a4570 5
void
hppa_skip_permanent_breakpoint (void)
{
  /* To step over a breakpoint instruction on the PA takes some
     fiddling with the instruction address queue.
d4572 4
a4575 6
     When we stop at a breakpoint, the IA queue front (the instruction
     we're executing now) points at the breakpoint instruction, and
     the IA queue back (the next instruction to execute) points to
     whatever instruction we would execute after the breakpoint, if it
     were an ordinary instruction.  This is the case even if the
     breakpoint is in the delay slot of a branch instruction.
d4577 2
a4578 6
     Clearly, to step past the breakpoint, we need to set the queue
     front to the back.  But what do we put in the back?  What
     instruction comes after that one?  Because of the branch delay
     slot, the next insn is always at the back + 4.  */
  write_register (PCOQ_HEAD_REGNUM, read_register (PCOQ_TAIL_REGNUM));
  write_register (PCSQ_HEAD_REGNUM, read_register (PCSQ_TAIL_REGNUM));
d4580 3
a4582 3
  write_register (PCOQ_TAIL_REGNUM, read_register (PCOQ_TAIL_REGNUM) + 4);
  /* We can leave the tail's space the same, since there's no jump.  */
}
d4584 1
a4584 2
/* Copy the function value from VALBUF into the proper location
   for a function return.
d4586 1
a4586 1
   Called only in the context of the "return" command.  */
d4588 1
a4588 6
void
hppa32_store_return_value (struct type *type, char *valbuf)
{
  /* For software floating point, the return value goes into the
     integer registers.  But we do not have any flag to key this on,
     so we always store the value into the integer registers.
d4590 1
a4590 11
     If its a float value, then we also store it into the floating
     point registers.  */
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (28)
				   + (TYPE_LENGTH (type) > 4
				      ? (8 - TYPE_LENGTH (type))
				      : (4 - TYPE_LENGTH (type))),
				   valbuf, TYPE_LENGTH (type));
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (FP4_REGNUM),
				     valbuf, TYPE_LENGTH (type));
}
d4592 2
a4593 1
/* Same as hppa32_store_return_value(), but for the PA64 ABI.  */
d4595 5
a4599 23
void
hppa64_store_return_value (struct type *type, char *valbuf)
{
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    deprecated_write_register_bytes
      (DEPRECATED_REGISTER_BYTE (FP4_REGNUM)
        + DEPRECATED_REGISTER_SIZE - TYPE_LENGTH (type),
       valbuf, TYPE_LENGTH (type));
  else if (is_integral_type(type))
    deprecated_write_register_bytes
      (DEPRECATED_REGISTER_BYTE (28)
        + DEPRECATED_REGISTER_SIZE - TYPE_LENGTH (type),
       valbuf, TYPE_LENGTH (type));
  else if (TYPE_LENGTH (type) <= 8)
    deprecated_write_register_bytes
      (DEPRECATED_REGISTER_BYTE (28),valbuf, TYPE_LENGTH (type));
  else if (TYPE_LENGTH (type) <= 16)
    {
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (28),valbuf, 8);
      deprecated_write_register_bytes
        (DEPRECATED_REGISTER_BYTE (29), valbuf + 8, TYPE_LENGTH (type) - 8);
    }
}
d4601 4
a4604 1
/* Copy the function's return value into VALBUF.
d4606 2
a4607 4
   This function is called only in the context of "target function calls",
   ie. when the debugger forces a function to be called in the child, and
   when the debugger forces a fucntion to return prematurely via the
   "return" command.  */
d4609 4
a4612 2
void
hppa32_extract_return_value (struct type *type, char *regbuf, char *valbuf)
d4614 2
a4615 13
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    memcpy (valbuf, regbuf + DEPRECATED_REGISTER_BYTE (FP4_REGNUM), TYPE_LENGTH (type));
  else
    memcpy (valbuf,
	    (regbuf
	     + DEPRECATED_REGISTER_BYTE (28)
	     + (TYPE_LENGTH (type) > 4
		? (8 - TYPE_LENGTH (type))
		: (4 - TYPE_LENGTH (type)))),
	    TYPE_LENGTH (type));
}

/* Same as hppa32_extract_return_value but for the PA64 ABI case.  */
d4617 2
a4618 21
void
hppa64_extract_return_value (struct type *type, char *regbuf, char *valbuf)
{
  /* RM: Floats are returned in FR4R, doubles in FR4.
         Integral values are in r28, padded on the left.
         Aggregates less that 65 bits are in r28, right padded.
         Aggregates upto 128 bits are in r28 and r29, right padded.  */ 
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    memcpy (valbuf,
            regbuf + DEPRECATED_REGISTER_BYTE (FP4_REGNUM)
             + DEPRECATED_REGISTER_SIZE - TYPE_LENGTH (type),
            TYPE_LENGTH (type));
  else if (is_integral_type(type))
    memcpy (valbuf,
            regbuf + DEPRECATED_REGISTER_BYTE (28)
             + DEPRECATED_REGISTER_SIZE - TYPE_LENGTH (type),
            TYPE_LENGTH (type));
  else if (TYPE_LENGTH (type) <= 8)
    memcpy (valbuf, regbuf + DEPRECATED_REGISTER_BYTE (28),
	    TYPE_LENGTH (type));
  else if (TYPE_LENGTH (type) <= 16)
d4620 23
a4642 5
      memcpy (valbuf, regbuf + DEPRECATED_REGISTER_BYTE (28), 8);
      memcpy (valbuf + 8, regbuf + DEPRECATED_REGISTER_BYTE (29),
	      TYPE_LENGTH (type) - 8);
    }
}
d4644 2
a4645 7
int
hppa_reg_struct_has_addr (int gcc_p, struct type *type)
{
  /* On the PA, any pass-by-value structure > 8 bytes is actually passed
     via a pointer regardless of its type or the compiler used.  */
  return (TYPE_LENGTH (type) > 8);
}
d4647 4
a4650 6
int
hppa_inner_than (CORE_ADDR lhs, CORE_ADDR rhs)
{
  /* Stack grows upward */
  return (lhs > rhs);
}
d4652 1
a4652 96
CORE_ADDR
hppa32_stack_align (CORE_ADDR sp)
{
  /* elz: adjust the quantity to the next highest value which is
     64-bit aligned.  This is used in valops.c, when the sp is adjusted.
     On hppa the sp must always be kept 64-bit aligned */
  return ((sp % 8) ? (sp + 7) & -8 : sp);
}

CORE_ADDR
hppa64_stack_align (CORE_ADDR sp)
{
  /* The PA64 ABI mandates a 16 byte stack alignment.  */
  return ((sp % 16) ? (sp + 15) & -16 : sp);
}

int
hppa_pc_requires_run_before_use (CORE_ADDR pc)
{
  /* Sometimes we may pluck out a minimal symbol that has a negative address.
  
     An example of this occurs when an a.out is linked against a foo.sl.
     The foo.sl defines a global bar(), and the a.out declares a signature
     for bar().  However, the a.out doesn't directly call bar(), but passes
     its address in another call.
  
     If you have this scenario and attempt to "break bar" before running,
     gdb will find a minimal symbol for bar() in the a.out.  But that
     symbol's address will be negative.  What this appears to denote is
     an index backwards from the base of the procedure linkage table (PLT)
     into the data linkage table (DLT), the end of which is contiguous
     with the start of the PLT.  This is clearly not a valid address for
     us to set a breakpoint on.
  
     Note that one must be careful in how one checks for a negative address.
     0xc0000000 is a legitimate address of something in a shared text
     segment, for example.  Since I don't know what the possible range
     is of these "really, truly negative" addresses that come from the
     minimal symbols, I'm resorting to the gross hack of checking the
     top byte of the address for all 1's.  Sigh.  */

  return (!target_has_stack && (pc & 0xFF000000));
}

int
hppa_instruction_nullified (void)
{
  /* brobecker 2002/11/07: Couldn't we use a ULONGEST here? It would
     avoid the type cast.  I'm leaving it as is for now as I'm doing
     semi-mechanical multiarching-related changes.  */
  const int ipsw = (int) read_register (IPSW_REGNUM);
  const int flags = (int) read_register (FLAGS_REGNUM);

  return ((ipsw & 0x00200000) && !(flags & 0x2));
}

int
hppa_register_raw_size (int reg_nr)
{
  /* All registers have the same size.  */
  return DEPRECATED_REGISTER_SIZE;
}

/* Index within the register vector of the first byte of the space i
   used for register REG_NR.  */

int
hppa_register_byte (int reg_nr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  return reg_nr * tdep->bytes_per_address;
}

/* Return the GDB type object for the "standard" data type of data
   in register N.  */

struct type *
hppa32_register_virtual_type (int reg_nr)
{
   if (reg_nr < FP4_REGNUM)
     return builtin_type_int;
   else
     return builtin_type_float;
}

/* Return the GDB type object for the "standard" data type of data
   in register N.  hppa64 version.  */

struct type *
hppa64_register_virtual_type (int reg_nr)
{
   if (reg_nr < FP4_REGNUM)
     return builtin_type_unsigned_long_long;
   else
     return builtin_type_double;
d4654 1
a4654 3

/* Store the address of the place in which to copy the structure the
   subroutine will return.  This is called from call_function.  */
d4657 1
a4657 1
hppa_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
d4659 2
a4660 2
  write_register (28, addr);
}
d4662 6
a4667 18
CORE_ADDR
hppa_extract_struct_value_address (char *regbuf)
{
  /* Extract from an array REGBUF containing the (raw) register state
     the address in which a function should return its structure value,
     as a CORE_ADDR (or an expression that can be used as one).  */
  /* FIXME: brobecker 2002-12-26.
     The current implementation is historical, but we should eventually
     implement it in a more robust manner as it relies on the fact that
     the address size is equal to the size of an int* _on the host_...
     One possible implementation that crossed my mind is to use
     extract_address.  */
  /* FIXME: cagney/2003-09-27: This function can probably go.  ELZ
     writes: We cannot assume on the pa that r28 still contains the
     address of the returned structure. Usually this will be
     overwritten by the callee.  */
  return (*(int *)(regbuf + DEPRECATED_REGISTER_BYTE (28)));
}
d4669 6
a4674 2
/* Return True if REGNUM is not a register available to the user
   through ptrace().  */
d4676 2
a4677 181
int
hppa_cannot_store_register (int regnum)
{
  return (regnum == 0
          || regnum == PCSQ_HEAD_REGNUM
          || (regnum >= PCSQ_TAIL_REGNUM && regnum < IPSW_REGNUM)
          || (regnum > IPSW_REGNUM && regnum < FP4_REGNUM));

}

CORE_ADDR
hppa_smash_text_address (CORE_ADDR addr)
{
  /* The low two bits of the PC on the PA contain the privilege level.
     Some genius implementing a (non-GCC) compiler apparently decided
     this means that "addresses" in a text section therefore include a
     privilege level, and thus symbol tables should contain these bits.
     This seems like a bonehead thing to do--anyway, it seems to work
     for our purposes to just ignore those bits.  */

  return (addr &= ~0x3);
}

/* Get the ith function argument for the current function.  */
CORE_ADDR
hppa_fetch_pointer_argument (struct frame_info *frame, int argi, 
			     struct type *type)
{
  CORE_ADDR addr;
  get_frame_register (frame, R0_REGNUM + 26 - argi, &addr);
  return addr;
}

static struct gdbarch *
hppa_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;
  
  /* Try to determine the ABI of the object we are loading.  */
  if (info.abfd != NULL && info.osabi == GDB_OSABI_UNKNOWN)
    {
      /* If it's a SOM file, assume it's HP/UX SOM.  */
      if (bfd_get_flavour (info.abfd) == bfd_target_som_flavour)
	info.osabi = GDB_OSABI_HPUX_SOM;
    }

  /* find a candidate among the list of pre-declared architectures.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return (arches->gdbarch);

  /* If none found, then allocate and initialize one.  */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  /* Determine from the bfd_arch_info structure if we are dealing with
     a 32 or 64 bits architecture.  If the bfd_arch_info is not available,
     then default to a 32bit machine.  */
  if (info.bfd_arch_info != NULL)
    tdep->bytes_per_address =
      info.bfd_arch_info->bits_per_address / info.bfd_arch_info->bits_per_byte;
  else
    tdep->bytes_per_address = 4;

  /* Some parts of the gdbarch vector depend on whether we are running
     on a 32 bits or 64 bits target.  */
  switch (tdep->bytes_per_address)
    {
      case 4:
        set_gdbarch_num_regs (gdbarch, hppa32_num_regs);
        set_gdbarch_register_name (gdbarch, hppa32_register_name);
        set_gdbarch_deprecated_register_virtual_type
          (gdbarch, hppa32_register_virtual_type);
        set_gdbarch_deprecated_call_dummy_length
          (gdbarch, hppa32_call_dummy_length);
        set_gdbarch_deprecated_stack_align (gdbarch, hppa32_stack_align);
        set_gdbarch_deprecated_reg_struct_has_addr
	  (gdbarch, hppa_reg_struct_has_addr);
        set_gdbarch_deprecated_extract_return_value
          (gdbarch, hppa32_extract_return_value);
        set_gdbarch_use_struct_convention
          (gdbarch, hppa32_use_struct_convention);
        set_gdbarch_deprecated_store_return_value
          (gdbarch, hppa32_store_return_value);
        break;
      case 8:
        set_gdbarch_num_regs (gdbarch, hppa64_num_regs);
        set_gdbarch_register_name (gdbarch, hppa64_register_name);
        set_gdbarch_deprecated_register_virtual_type
          (gdbarch, hppa64_register_virtual_type);
        set_gdbarch_deprecated_call_dummy_breakpoint_offset
          (gdbarch, hppa64_call_dummy_breakpoint_offset);
        set_gdbarch_deprecated_call_dummy_length
          (gdbarch, hppa64_call_dummy_length);
        set_gdbarch_deprecated_stack_align (gdbarch, hppa64_stack_align);
        set_gdbarch_deprecated_extract_return_value
          (gdbarch, hppa64_extract_return_value);
        set_gdbarch_use_struct_convention
          (gdbarch, hppa64_use_struct_convention);
        set_gdbarch_deprecated_store_return_value
          (gdbarch, hppa64_store_return_value);
        break;
      default:
        internal_error (__FILE__, __LINE__, "Unsupported address size: %d",
                        tdep->bytes_per_address);
    }

  /* The following gdbarch vector elements depend on other parts of this
     vector which have been set above, depending on the ABI.  */
  set_gdbarch_deprecated_register_bytes
    (gdbarch, gdbarch_num_regs (gdbarch) * tdep->bytes_per_address);
  set_gdbarch_long_bit (gdbarch, tdep->bytes_per_address * TARGET_CHAR_BIT);
  set_gdbarch_long_long_bit (gdbarch, 64);
  set_gdbarch_ptr_bit (gdbarch, tdep->bytes_per_address * TARGET_CHAR_BIT);

  /* The following gdbarch vector elements do not depend on the address
     size, or in any other gdbarch element previously set.  */
  set_gdbarch_function_start_offset (gdbarch, 0);
  set_gdbarch_skip_prologue (gdbarch, hppa_skip_prologue);
  set_gdbarch_skip_trampoline_code (gdbarch, hppa_skip_trampoline_code);
  set_gdbarch_in_solib_call_trampoline (gdbarch, hppa_in_solib_call_trampoline);
  set_gdbarch_in_solib_return_trampoline (gdbarch,
                                          hppa_in_solib_return_trampoline);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, hppa_saved_pc_after_call);
  set_gdbarch_inner_than (gdbarch, hppa_inner_than);
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
  set_gdbarch_deprecated_register_size (gdbarch, tdep->bytes_per_address);
  set_gdbarch_deprecated_fp_regnum (gdbarch, 3);
  set_gdbarch_sp_regnum (gdbarch, 30);
  set_gdbarch_fp0_regnum (gdbarch, 64);
  set_gdbarch_pc_regnum (gdbarch, PCOQ_HEAD_REGNUM);
  set_gdbarch_deprecated_npc_regnum (gdbarch, PCOQ_TAIL_REGNUM);
  set_gdbarch_deprecated_register_raw_size (gdbarch, hppa_register_raw_size);
  set_gdbarch_deprecated_register_byte (gdbarch, hppa_register_byte);
  set_gdbarch_deprecated_register_virtual_size (gdbarch, hppa_register_raw_size);
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, tdep->bytes_per_address);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 8);
  set_gdbarch_deprecated_store_struct_return (gdbarch, hppa_store_struct_return);
  set_gdbarch_deprecated_extract_struct_value_address
    (gdbarch, hppa_extract_struct_value_address);
  set_gdbarch_cannot_store_register (gdbarch, hppa_cannot_store_register);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, hppa_init_extra_frame_info);
  set_gdbarch_deprecated_frame_chain (gdbarch, hppa_frame_chain);
  set_gdbarch_deprecated_frame_chain_valid (gdbarch, hppa_frame_chain_valid);
  set_gdbarch_frameless_function_invocation
    (gdbarch, hppa_frameless_function_invocation);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, hppa_frame_saved_pc);
  set_gdbarch_frame_args_skip (gdbarch, 0);
  set_gdbarch_deprecated_push_dummy_frame (gdbarch, hppa_push_dummy_frame);
  set_gdbarch_deprecated_pop_frame (gdbarch, hppa_pop_frame);
  /* set_gdbarch_deprecated_fix_call_dummy (gdbarch, hppa_fix_call_dummy); */
  set_gdbarch_deprecated_push_arguments (gdbarch, hppa_push_arguments);
  set_gdbarch_addr_bits_remove (gdbarch, hppa_smash_text_address);
  set_gdbarch_smash_text_address (gdbarch, hppa_smash_text_address);
  set_gdbarch_believe_pcc_promotion (gdbarch, 1);
  set_gdbarch_read_pc (gdbarch, hppa_target_read_pc);
  set_gdbarch_write_pc (gdbarch, hppa_target_write_pc);
  set_gdbarch_deprecated_target_read_fp (gdbarch, hppa_target_read_fp);

  /* Helper for function argument information.  */
  set_gdbarch_fetch_pointer_argument (gdbarch, hppa_fetch_pointer_argument);

  set_gdbarch_print_insn (gdbarch, print_insn_hppa);

  /* When a hardware watchpoint triggers, we'll move the inferior past
     it by removing all eventpoints; stepping past the instruction
     that caused the trigger; reinserting eventpoints; and checking
     whether any watched location changed.  */
  set_gdbarch_have_nonsteppable_watchpoint (gdbarch, 1);

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  return gdbarch;
}

static void
hppa_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
{
   /* Nothing to print for the moment.  */
d4688 1
a4688 1
  gdbarch_register (bfd_arch_hppa, hppa_gdbarch_init, hppa_dump_tdep);
d4725 49
@


1.27.16.3
log
@Merge from mainline.
@
text
@a5066 35
/* Here is a table of C type sizes on hppa with various compiles
   and options.  I measured this on PA 9000/800 with HP-UX 11.11
   and these compilers:

     /usr/ccs/bin/cc    HP92453-01 A.11.01.21
     /opt/ansic/bin/cc  HP92453-01 B.11.11.28706.GP
     /opt/aCC/bin/aCC   B3910B A.03.45
     gcc                gcc 3.3.2 native hppa2.0w-hp-hpux11.11

     cc            : 1 2 4 4 8 : 4 8 -- : 4 4
     ansic +DA1.1  : 1 2 4 4 8 : 4 8 16 : 4 4
     ansic +DA2.0  : 1 2 4 4 8 : 4 8 16 : 4 4
     ansic +DA2.0W : 1 2 4 8 8 : 4 8 16 : 8 8
     acc   +DA1.1  : 1 2 4 4 8 : 4 8 16 : 4 4
     acc   +DA2.0  : 1 2 4 4 8 : 4 8 16 : 4 4
     acc   +DA2.0W : 1 2 4 8 8 : 4 8 16 : 8 8
     gcc           : 1 2 4 4 8 : 4 8 16 : 4 4

   Each line is:

     compiler and options
     char, short, int, long, long long
     float, double, long double
     char *, void (*)()

   So all these compilers use either ILP32 or LP64 model.
   TODO: gcc has more options so it needs more investigation.

   For floating point types, see:

     http://docs.hp.com/hpux/pdf/B3906-90006.pdf
     HP-UX floating-point guide, hpux 11.00

   -- chastain 2003-12-18  */

d5147 1
a5148 6

  /* The following gdbarch vector elements are the same in both ILP32
     and LP64, but might show differences some day.  */
  set_gdbarch_long_long_bit (gdbarch, 64);
  set_gdbarch_long_double_bit (gdbarch, 128);
  set_gdbarch_long_double_format (gdbarch, &floatformat_ia64_quad_big);
@


1.27.16.4
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d4 1
a4 2
   1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d196 1
d513 1
a513 1
  ui = (struct obj_unwind_info *) obstack_alloc (&objfile->objfile_obstack,
d563 1
a563 1
    obstack_alloc (&objfile->objfile_obstack, total_size);
d626 1
a626 1
	obstack_alloc (&objfile->objfile_obstack,
d2612 1
a2612 1
  write_register_pid (PCOQ_TAIL_REGNUM, v + 4, ptid);
d5011 20
d5192 1
d5200 1
d5206 1
d5213 2
@


1.27.14.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d4429 1
a4429 1
  init_sal (break_callback_sal);
@


1.27.14.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a32 1
#include "language.h"
a132 15
/* FIXME: brobecker 2002-11-07: We will likely be able to make the
   following functions static, once we hppa is partially multiarched.  */
int hppa_reg_struct_has_addr (int gcc_p, struct type *type);
int hppa_inner_than (CORE_ADDR lhs, CORE_ADDR rhs);
CORE_ADDR hppa_stack_align (CORE_ADDR sp);
int hppa_pc_requires_run_before_use (CORE_ADDR pc);
int hppa_instruction_nullified (void);
int hppa_register_byte (int reg_nr);
struct type * hppa_register_virtual_type (int reg_nr);
void hppa_store_struct_return (CORE_ADDR addr, CORE_ADDR sp);
int hppa_cannot_store_register (int regnum);
CORE_ADDR hppa_frame_args_address (struct frame_info *fi);
CORE_ADDR hppa_frame_locals_address (struct frame_info *fi);
CORE_ADDR hppa_smash_text_address (CORE_ADDR addr);
int hppa_coerce_float_to_double (struct type *formal, struct type *actual);
d152 3
a155 1

d303 1
a303 1
  if (((section->flags & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
a815 5
/* Immediately after a function call, return the saved pc.
   Can't go through the frames for this because on some machines
   the new frame is not set up until the new function executes
   some instructions.  */

d1453 1
a1453 2
      deprecated_read_register_bytes (REGISTER_BYTE (regnum),
				      (char *) &freg_buffer, 8);
d1532 1
a1532 2
	deprecated_write_register_bytes (REGISTER_BYTE (regnum),
					 (char *) &freg_buffer, 8);
a4679 215
/* Copy the function value from VALBUF into the proper location
   for a function return.

   Called only in the context of the "return" command.  */

void
hppa_store_return_value (struct type *type, char *valbuf)
{
  /* For software floating point, the return value goes into the
     integer registers.  But we do not have any flag to key this on,
     so we always store the value into the integer registers.

     If its a float value, then we also store it into the floating
     point registers.  */
  deprecated_write_register_bytes (REGISTER_BYTE (28)
				   + (TYPE_LENGTH (type) > 4
				      ? (8 - TYPE_LENGTH (type))
				      : (4 - TYPE_LENGTH (type))),
				   valbuf, TYPE_LENGTH (type));
  if (! SOFT_FLOAT && TYPE_CODE (type) == TYPE_CODE_FLT)
    deprecated_write_register_bytes (REGISTER_BYTE (FP4_REGNUM),
				     valbuf, TYPE_LENGTH (type));
}

/* Copy the function's return value into VALBUF.

   This function is called only in the context of "target function calls",
   ie. when the debugger forces a function to be called in the child, and
   when the debugger forces a fucntion to return prematurely via the
   "return" command.  */

void
hppa_extract_return_value (struct type *type, char *regbuf, char *valbuf)
{
  if (! SOFT_FLOAT && TYPE_CODE (type) == TYPE_CODE_FLT)
    memcpy (valbuf,
	    (char *)regbuf + REGISTER_BYTE (FP4_REGNUM),
	    TYPE_LENGTH (type));
  else
    memcpy (valbuf,
	    ((char *)regbuf
	     + REGISTER_BYTE (28)
	     + (TYPE_LENGTH (type) > 4
		? (8 - TYPE_LENGTH (type))
		: (4 - TYPE_LENGTH (type)))),
	    TYPE_LENGTH (type));
}

int
hppa_reg_struct_has_addr (int gcc_p, struct type *type)
{
  /* On the PA, any pass-by-value structure > 8 bytes is actually passed
     via a pointer regardless of its type or the compiler used.  */
  return (TYPE_LENGTH (type) > 8);
}

int
hppa_inner_than (CORE_ADDR lhs, CORE_ADDR rhs)
{
  /* Stack grows upward */
  return (lhs > rhs);
}

CORE_ADDR
hppa_stack_align (CORE_ADDR sp)
{
  /* elz: adjust the quantity to the next highest value which is
     64-bit aligned.  This is used in valops.c, when the sp is adjusted.
     On hppa the sp must always be kept 64-bit aligned */
  return ((sp % 8) ? (sp + 7) & -8 : sp);
}

int
hppa_pc_requires_run_before_use (CORE_ADDR pc)
{
  /* Sometimes we may pluck out a minimal symbol that has a negative address.
  
     An example of this occurs when an a.out is linked against a foo.sl.
     The foo.sl defines a global bar(), and the a.out declares a signature
     for bar().  However, the a.out doesn't directly call bar(), but passes
     its address in another call.
  
     If you have this scenario and attempt to "break bar" before running,
     gdb will find a minimal symbol for bar() in the a.out.  But that
     symbol's address will be negative.  What this appears to denote is
     an index backwards from the base of the procedure linkage table (PLT)
     into the data linkage table (DLT), the end of which is contiguous
     with the start of the PLT.  This is clearly not a valid address for
     us to set a breakpoint on.
  
     Note that one must be careful in how one checks for a negative address.
     0xc0000000 is a legitimate address of something in a shared text
     segment, for example.  Since I don't know what the possible range
     is of these "really, truly negative" addresses that come from the
     minimal symbols, I'm resorting to the gross hack of checking the
     top byte of the address for all 1's.  Sigh.  */

  return (!target_has_stack && (pc & 0xFF000000));
}

int
hppa_instruction_nullified (void)
{
  /* brobecker 2002/11/07: Couldn't we use a ULONGEST here? It would
     avoid the type cast.  I'm leaving it as is for now as I'm doing
     semi-mechanical multiarching-related changes.  */
  const int ipsw = (int) read_register (IPSW_REGNUM);
  const int flags = (int) read_register (FLAGS_REGNUM);

  return ((ipsw & 0x00200000) && !(flags & 0x2));
}

/* Index within the register vector of the first byte of the space i
   used for register REG_NR.  */

int
hppa_register_byte (int reg_nr)
{
  return reg_nr * 4;
}

/* Return the GDB type object for the "standard" data type of data
   in register N.  */

struct type *
hppa_register_virtual_type (int reg_nr)
{
   if (reg_nr < FP4_REGNUM)
     return builtin_type_int;
   else
     return builtin_type_float;
}

/* Store the address of the place in which to copy the structure the
   subroutine will return.  This is called from call_function.  */

void
hppa_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  write_register (28, addr);
}

/* Return True if REGNUM is not a register available to the user
   through ptrace().  */

int
hppa_cannot_store_register (int regnum)
{
  return (regnum == 0
          || regnum == PCSQ_HEAD_REGNUM
          || (regnum >= PCSQ_TAIL_REGNUM && regnum < IPSW_REGNUM)
          || (regnum > IPSW_REGNUM && regnum < FP4_REGNUM));

}

CORE_ADDR
hppa_frame_args_address (struct frame_info *fi)
{
  return fi->frame;
}

CORE_ADDR
hppa_frame_locals_address (struct frame_info *fi)
{
  return fi->frame;
}

CORE_ADDR
hppa_smash_text_address (CORE_ADDR addr)
{
  /* The low two bits of the PC on the PA contain the privilege level.
     Some genius implementing a (non-GCC) compiler apparently decided
     this means that "addresses" in a text section therefore include a
     privilege level, and thus symbol tables should contain these bits.
     This seems like a bonehead thing to do--anyway, it seems to work
     for our purposes to just ignore those bits.  */

  return (addr &= ~0x3);
}

int
hppa_coerce_float_to_double (struct type *formal, struct type *actual)
{
   /* FIXME: For the pa, it appears that the debug info marks the
      parameters as floats regardless of whether the function is
      prototyped, but the actual values are passed as doubles for the
      non-prototyped case and floats for the prototyped case.  Thus we
      choose to make the non-prototyped case work for C and break the
      prototyped case, since the non-prototyped case is probably much
      more common.  */
  return (current_language -> la_language == language_c);
}

static struct gdbarch *
hppa_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;

  /* find a candidate among the list of pre-declared architectures.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return (arches->gdbarch);

  /* If none found, then allocate and initialize one.  */
  gdbarch = gdbarch_alloc (&info, NULL);

  return gdbarch;
}

static void
hppa_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
{
   /* Nothing to print for the moment.  */
}

a4687 1
  gdbarch_register (bfd_arch_hppa, hppa_gdbarch_init, hppa_dump_tdep);
d4725 49
@


1.27.14.3
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@d1941 1
a1941 1
  struct symbol *get_sym;
d1955 1
a1955 1
  get_sym = lookup_symbol_linkage ("__d_shl_get");
d1958 1
d4311 2
a4312 1
  sym = lookup_symbol_linkage (HP_ACC_EH_catch_catch);
d4337 2
a4338 1
  sym = lookup_symbol (HP_ACC_EH_catch_catch);
@


1.27.14.4
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a33 1
#include "osabi.h"
d894 1
a894 1
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
d913 1
a913 1
	  && ((get_frame_type (frame->next) == SIGTRAMP_FRAME)
d918 1
a918 1
	  deprecated_get_frame_saved_regs (frame->next, &saved_regs);
d953 1
a953 1
	  && ((get_frame_type (frame->next) == SIGTRAMP_FRAME)
d958 1
a958 1
	  deprecated_get_frame_saved_regs (frame->next, &saved_regs);
d1082 3
a1084 4
/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct, and
   then INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC will be
   called for the new frame.
d1147 1
a1147 1
  else if ((get_frame_type (frame) == SIGTRAMP_FRAME))
d1218 1
a1218 1
	  || (get_frame_type (tmp_frame) == SIGTRAMP_FRAME)
d1229 1
a1229 1
	  deprecated_get_frame_saved_regs (tmp_frame, &saved_regs);
d1243 1
a1243 1
	  && !(get_frame_type (tmp_frame) == SIGTRAMP_FRAME)
d1278 1
a1278 1
	    deprecated_get_frame_saved_regs (tmp_frame, &saved_regs);
d1313 1
a1313 1
	deprecated_get_frame_saved_regs (tmp_frame, &saved_regs);
d1391 1
a1391 1
      || (thisframe->next && (get_frame_type (thisframe->next) == SIGTRAMP_FRAME))
d1535 2
a1536 2
  fp = get_frame_base (frame);
  deprecated_get_frame_saved_regs (frame, &fsr);
d1605 1
a1605 1
      breakpoint = set_momentary_breakpoint (sal, null_frame_id, bp_finish);
d2513 1
a2513 1
    frame_register_read (deprecated_selected_frame, i, raw_regs + REGISTER_BYTE (i));
d2557 1
a2557 1
    frame_register_read (deprecated_selected_frame, i, raw_regs + REGISTER_BYTE (i));
d2809 1
a2809 1
  frame_register_read (deprecated_selected_frame, i, raw_buffer);
d2827 1
a2827 1
      frame_register_read (deprecated_selected_frame, i + 1, raw_buffer);
d2855 1
a2855 1
  frame_register_read (deprecated_selected_frame, i, raw_buffer);
d2866 1
a2866 1
      frame_register_read (deprecated_selected_frame, i + 1, raw_buf);
d3890 1
a3890 1
  if ((get_frame_type (frame_info) == SIGTRAMP_FRAME))
a4894 14
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
  
  /* Try to determine the ABI of the object we are loading.  */

  if (info.abfd != NULL)
    {
      osabi = gdbarch_lookup_osabi (info.abfd);
      if (osabi == GDB_OSABI_UNKNOWN)
	{
	  /* If it's a SOM file, assume it's HP/UX SOM.  */
	  if (bfd_get_flavour (info.abfd) == bfd_target_som_flavour)
	    osabi = GDB_OSABI_HPUX_SOM;
	}
    }
a4902 3

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch, osabi);
@


1.27.14.5
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d4 1
a4 1
   1996, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a65 3
/* Some local constants.  */
static const int hppa_num_regs = 128;

a137 5
CORE_ADDR hppa_skip_prologue (CORE_ADDR pc);
CORE_ADDR hppa_skip_trampoline_code (CORE_ADDR pc);
int hppa_in_solib_call_trampoline (CORE_ADDR pc, char *name);
int hppa_in_solib_return_trampoline (CORE_ADDR pc, char *name);
CORE_ADDR hppa_saved_pc_after_call (struct frame_info *frame);
a141 1
int hppa_register_raw_size (int reg_nr);
a144 4
void hppa_extract_return_value (struct type *type, char *regbuf, char *valbuf);
int hppa_use_struct_convention (int gcc_p, struct type *type);
void hppa_store_return_value (struct type *type, char *valbuf);
CORE_ADDR hppa_extract_struct_value_address (char *regbuf);
a145 5
void hppa_init_extra_frame_info (int fromleaf, struct frame_info *frame);
CORE_ADDR hppa_frame_chain (struct frame_info *frame);
int hppa_frame_chain_valid (CORE_ADDR chain, struct frame_info *thisframe);
int hppa_frameless_function_invocation (struct frame_info *frame);
CORE_ADDR hppa_frame_saved_pc (struct frame_info *frame);
a147 8
int hppa_frame_num_args (struct frame_info *frame);
void hppa_push_dummy_frame (struct inferior_status *inf_status);
void hppa_pop_frame (void);
CORE_ADDR hppa_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun,
                               int nargs, struct value **args,
                               struct type *type, int gcc_p);
CORE_ADDR hppa_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		               int struct_return, CORE_ADDR struct_addr);
d149 1
a149 3
CORE_ADDR hppa_target_read_pc (ptid_t ptid);
void hppa_target_write_pc (CORE_ADDR v, ptid_t ptid);
CORE_ADDR hppa_target_read_fp (void);
d159 1
a159 1
static int cover_find_stub_with_shl_get (void *);
d348 1
a348 1
				 record_text_segment_lowaddr, NULL);
d549 1
a549 1
      objfile->obj_private = obj_private;
d819 1
a819 1
hppa_frameless_function_invocation (struct frame_info *frame)
d837 1
a837 1
hppa_saved_pc_after_call (struct frame_info *frame)
d903 1
a903 1
  if (hppa_frameless_function_invocation (frame))
d1035 1
a1035 1
hppa_init_extra_frame_info (int fromleaf, struct frame_info *frame)
d1093 1
a1093 1
hppa_frame_chain (struct frame_info *frame)
d1356 3
d1410 1
a1410 1
hppa_push_dummy_frame (struct inferior_status *inf_status)
d1426 1
a1426 1
  pc = hppa_target_read_pc (inferior_ptid);
d2009 1
a2009 1
cover_find_stub_with_shl_get (void *args_untyped)
d2402 1
a2402 1
  else if (som_solib_get_got_by_pc (hppa_target_read_pc (inferior_ptid)))
d2410 3
a2415 1

d2417 1
a2417 1
hppa_read_fp (int pid)
a2430 5
CORE_ADDR
hppa_target_read_fp (void)
{
  return hppa_read_fp (PIDGET (inferior_ptid));
}
d2436 1
a2436 1
hppa_target_read_pc (ptid_t ptid)
d2453 1
a2453 1
hppa_target_write_pc (CORE_ADDR v, ptid_t ptid)
d2610 1
a2610 1
  char *buf = alloca (max_register_size (current_gdbarch));
d2807 2
a2808 2
  char *raw_buffer = alloca (max_register_size (current_gdbarch));
  char *virtual_buffer = alloca (max_register_size (current_gdbarch));
d2850 2
a2851 2
  char *raw_buffer = alloca (max_register_size (current_gdbarch));
  char *virtual_buffer = alloca (max_register_size (current_gdbarch));
d2865 1
a2865 1
      char *raw_buf = alloca (max_register_size (current_gdbarch));
d2891 1
a2891 1
hppa_in_solib_call_trampoline (CORE_ADDR pc, char *name)
d3051 1
a3051 1
hppa_in_solib_return_trampoline (CORE_ADDR pc, char *name)
d3124 1
a3124 1
hppa_skip_trampoline_code (CORE_ADDR pc)
d4274 1
a4274 1
      catch_errors (cover_find_stub_with_shl_get, &args, message,
a4526 10
/* Instead of this nasty cast, add a method pvoid() that prints out a
   host VOID data type (remember %p isn't portable).  */

static CORE_ADDR
hppa_pointer_to_address_hack (void *ptr)
{
  gdb_assert (sizeof (ptr) == TYPE_LENGTH (builtin_type_void_data_ptr));
  return POINTER_TO_ADDRESS (builtin_type_void_data_ptr, &ptr);
}

d4549 1
a4549 1
		     paddr_nz (hppa_pointer_to_address_hack (u)));
a4811 7
int
hppa_register_raw_size (int reg_nr)
{
  /* All registers have the same size.  */
  return REGISTER_SIZE;
}

a4841 15
CORE_ADDR
hppa_extract_struct_value_address (char *regbuf)
{
  /* Extract from an array REGBUF containing the (raw) register state
     the address in which a function should return its structure value,
     as a CORE_ADDR (or an expression that can be used as one).  */
  /* FIXME: brobecker 2002-12-26.
     The current implementation is historical, but we should eventually
     implement it in a more robust manner as it relies on the fact that
     the address size is equal to the size of an int* _on the host_...
     One possible implementation that crossed my mind is to use
     extract_address.  */
  return (*(int *)(regbuf + REGISTER_BYTE (28)));
}

a4866 8
int
hppa_frame_num_args (struct frame_info *frame)
{
  /* We can't tell how many args there are now that the C compiler delays
     popping them.  */
  return -1;
}

d4880 13
d4897 1
d4900 2
a4901 1
  if (info.abfd != NULL && info.osabi == GDB_OSABI_UNKNOWN)
d4903 7
a4909 3
      /* If it's a SOM file, assume it's HP/UX SOM.  */
      if (bfd_get_flavour (info.abfd) == bfd_target_som_flavour)
	info.osabi = GDB_OSABI_HPUX_SOM;
d4921 1
a4921 57
  gdbarch_init_osabi (info, gdbarch);

  set_gdbarch_reg_struct_has_addr (gdbarch, hppa_reg_struct_has_addr);
  set_gdbarch_function_start_offset (gdbarch, 0);
  set_gdbarch_skip_prologue (gdbarch, hppa_skip_prologue);
  set_gdbarch_skip_trampoline_code (gdbarch, hppa_skip_trampoline_code);
  set_gdbarch_in_solib_call_trampoline (gdbarch, hppa_in_solib_call_trampoline);
  set_gdbarch_in_solib_return_trampoline (gdbarch,
                                          hppa_in_solib_return_trampoline);
  set_gdbarch_saved_pc_after_call (gdbarch, hppa_saved_pc_after_call);
  set_gdbarch_inner_than (gdbarch, hppa_inner_than);
  set_gdbarch_stack_align (gdbarch, hppa_stack_align);
  set_gdbarch_extra_stack_alignment_needed (gdbarch, 0);
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
  set_gdbarch_register_size (gdbarch, 4);
  set_gdbarch_num_regs (gdbarch, hppa_num_regs);
  set_gdbarch_fp_regnum (gdbarch, 3);
  set_gdbarch_sp_regnum (gdbarch, 30);
  set_gdbarch_fp0_regnum (gdbarch, 64);
  set_gdbarch_pc_regnum (gdbarch, PCOQ_HEAD_REGNUM);
  set_gdbarch_npc_regnum (gdbarch, PCOQ_TAIL_REGNUM);
  set_gdbarch_register_raw_size (gdbarch, hppa_register_raw_size);
  set_gdbarch_register_bytes (gdbarch, hppa_num_regs * 4);
  set_gdbarch_register_byte (gdbarch, hppa_register_byte);
  set_gdbarch_register_virtual_size (gdbarch, hppa_register_raw_size);
  set_gdbarch_max_register_raw_size (gdbarch, 4);
  set_gdbarch_max_register_virtual_size (gdbarch, 8);
  set_gdbarch_register_virtual_type (gdbarch, hppa_register_virtual_type);
  set_gdbarch_store_struct_return (gdbarch, hppa_store_struct_return);
  set_gdbarch_deprecated_extract_return_value (gdbarch,
                                               hppa_extract_return_value);
  set_gdbarch_use_struct_convention (gdbarch, hppa_use_struct_convention);
  set_gdbarch_deprecated_store_return_value (gdbarch, hppa_store_return_value);
  set_gdbarch_deprecated_extract_struct_value_address
    (gdbarch, hppa_extract_struct_value_address);
  set_gdbarch_cannot_store_register (gdbarch, hppa_cannot_store_register);
  set_gdbarch_init_extra_frame_info (gdbarch, hppa_init_extra_frame_info);
  set_gdbarch_frame_chain (gdbarch, hppa_frame_chain);
  set_gdbarch_frame_chain_valid (gdbarch, hppa_frame_chain_valid);
  set_gdbarch_frameless_function_invocation
    (gdbarch, hppa_frameless_function_invocation);
  set_gdbarch_frame_saved_pc (gdbarch, hppa_frame_saved_pc);
  set_gdbarch_frame_args_address (gdbarch, hppa_frame_args_address);
  set_gdbarch_frame_locals_address (gdbarch, hppa_frame_locals_address);
  set_gdbarch_frame_num_args (gdbarch, hppa_frame_num_args);
  set_gdbarch_frame_args_skip (gdbarch, 0);
  /* set_gdbarch_push_dummy_frame (gdbarch, hppa_push_dummy_frame);  */
  set_gdbarch_pop_frame (gdbarch, hppa_pop_frame);
  set_gdbarch_call_dummy_length (gdbarch, INSTRUCTION_SIZE * 28);
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
  /* set_gdbarch_fix_call_dummy (gdbarch, hppa_fix_call_dummy); */
  set_gdbarch_push_arguments (gdbarch, hppa_push_arguments);
  set_gdbarch_smash_text_address (gdbarch, hppa_smash_text_address);
  set_gdbarch_believe_pcc_promotion (gdbarch, 1);
  set_gdbarch_read_pc (gdbarch, hppa_target_read_pc);
  set_gdbarch_write_pc (gdbarch, hppa_target_write_pc);
  set_gdbarch_read_fp (gdbarch, hppa_target_read_fp);
@


1.27.14.6
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d680 1
a680 1
	  && !PC_IN_SIGTRAMP (pc, DEPRECATED_SYMBOL_NAME (msym_us)));
d798 1
a798 1
      && !PC_IN_SIGTRAMP (pc, DEPRECATED_SYMBOL_NAME (msym_us)))
d1113 2
a1114 2
   then DEPRECATED_INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC
   will be called for the new frame.
d1156 1
a1156 1
      frame_symbol_name = DEPRECATED_SYMBOL_NAME (min_frame_symbol);
d1986 1
a1986 1
  namelen = strlen (DEPRECATED_SYMBOL_NAME (function));
d1999 1
a1999 1
  target_write_memory (endo_buff_addr, DEPRECATED_SYMBOL_NAME (function), namelen);
d2237 1
a2237 1
	      (DEPRECATED_SYMBOL_NAME (funsymbol), NULL, objfile);
d2240 1
a2240 1
	      stub_symbol = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (funsymbol),
d2341 1
a2341 1
	    error ("Can't find an import stub for %s", DEPRECATED_SYMBOL_NAME (fmsymbol));
d3017 1
a3017 1
  if (minsym && strcmp (DEPRECATED_SYMBOL_NAME (minsym), ".stub") == 0)
d3260 1
a3260 1
		&& STREQ (DEPRECATED_SYMBOL_NAME (msymbol), DEPRECATED_SYMBOL_NAME (msym)))
d3355 1
a3355 1
	  libsym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (stubsym), NULL, NULL);
d3359 1
a3359 1
		       DEPRECATED_SYMBOL_NAME (stubsym));
d4995 2
a4996 2
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 4);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 8);
d5006 1
a5006 1
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, hppa_init_extra_frame_info);
d5016 1
a5016 1
  /* set_gdbarch_deprecated_push_dummy_frame (gdbarch, hppa_push_dummy_frame);  */
@


1.27.14.7
log
@2003-03-07  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Replace uses of
	SYMBOL_MATCHES_NATURAL_NAME by equivalent uses of
	SYMBOL_NATURAL_NAME, strcmp_iw.
	* symtab.h (SYMBOL_MATCHES_NATURAL_NAME): Delete.
	* minsyms.c (lookup_minimal_symbol_linkage): Make static.
	(lookup_minimal_symbol_natural): Ditto.
	(lookup_minimal_symbol): Only search on linkage names; rename
	first argument to 'linkage_name'.
	(lookup_minimal_symbol_linkage): Delete.
	(lookup_minimal_symbol_natural): Delete.
	(add_minsym_to_demangled_hash_table): Go back to using
	SYMBOL_DEMANGLED_NAME instead of SYMBOL_NATURAL_NAME.
	(lookup_minimal_symbol_aux): Don't use
	SYMBOL_MATCHES_NATURAL_NAME: do a strcmp_iw on
	SYMBOL_DEMANGLED_NAME instead.  Add comment.
	(build_minimal_symbol_hash_tables): Go back to only adding to
	demangled has table if SYMBOL_DEMANGLED_NAME is non-NULL.
	* symtab.h: Delete declarations for lookup_minimal_symbol_linkage
	and lookup_minimal_symbol_natural.
	* valops.c (find_function_in_inferior): Use lookup_symbol_linkage
	instead of lookup_symbol.  Change comment.
	* remote.c (remote_check_symbols): Use
	lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol, but add FIXME comment as well.
	* objc-lang.c: Ditto.
	* c-exp.y: Use lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol.
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y (push_expression_name): Ditto.
	* f-exp.y: Ditto.
	* printcmd.c (address_info): Ditto.
	* symtab.h: Declare lookup_minimal_symbol_linkage_or_natural.
	* minsyms.c (lookup_minimal_symbol_linkage_or_natural): New.
	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME instead of
	DEPRECATED_SYMBOL_NAME.
	* tracepoint.c (scope_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* sol-thread.c (info_cb): Ditto.
	* printcmd.c (address_info): Ditto.
	* hppa-tdep.c (hppa_fix_call_dummy): Ditto.
	(hppa_in_solib_call_trampoline): Ditto.
	* findvar.c (read_var_value): Ditto.
@
text
@d2237 1
a2237 1
	      (SYMBOL_LINKAGE_NAME (funsymbol), NULL, objfile);
d2240 1
a2240 1
	      stub_symbol = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (funsymbol),
d3017 1
a3017 1
  if (minsym && strcmp (SYMBOL_LINKAGE_NAME (minsym), ".stub") == 0)
d3355 1
a3355 1
	  libsym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (stubsym), NULL, NULL);
@


1.27.14.8
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d35 1
a35 2
#include "gdb_assert.h"
#include "infttrace.h"
d80 2
a81 1
static void find_dummy_frame_regs (struct frame_info *, CORE_ADDR *);
d105 1
a105 1
static int restore_pc_queue (CORE_ADDR *);
d167 1
a167 1
void hppa_push_dummy_frame (void);
d851 1
a851 1
  u = find_unwind_entry (get_frame_pc (frame));
d878 1
a878 1
    return DEPRECATED_FRAME_SAVED_PC (frame);
d888 1
a888 1
  CORE_ADDR old_pc = 0;
d897 1
a897 1
    return read_memory_integer (get_frame_base (frame) + PC_REGNUM * 4,
d900 15
a914 16
  if ((get_frame_pc (frame) >= get_frame_base (frame)
       && (get_frame_pc (frame)
	   <= (get_frame_base (frame)
	       /* A call dummy is sized in words, but it is actually a
		  series of instructions.  Account for that scaling
		  factor.  */
	       + ((REGISTER_SIZE / INSTRUCTION_SIZE)
		  * CALL_DUMMY_LENGTH)
	       /* Similarly we have to account for 64bit wide register
		  saves.  */
	       + (32 * REGISTER_SIZE)
	       /* We always consider FP regs 8 bytes long.  */
	       + (NUM_REGS - FP0_REGNUM) * 8
	       /* Similarly we have to account for 64bit wide register
		  saves.  */
	       + (6 * REGISTER_SIZE)))))
d916 1
a916 1
      return read_memory_integer ((get_frame_base (frame)
d941 8
a948 8
      if (get_next_frame (frame)
	  && ((get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME)
	      || pc_in_interrupt_handler (get_frame_pc (get_next_frame (frame)))))
	{
	  CORE_ADDR *saved_regs;
	  hppa_frame_init_saved_regs (get_next_frame (frame));
	  saved_regs = get_frame_saved_regs (get_next_frame (frame));
	  if (read_memory_integer (saved_regs[FLAGS_REGNUM],
d951 1
a951 1
	      pc = read_memory_integer (saved_regs[31],
d958 2
a959 2
	      if (pc == get_frame_pc (frame))
		pc = read_memory_integer (saved_regs[RP_REGNUM],
d963 1
a963 1
	    pc = read_memory_integer (saved_regs[RP_REGNUM],
d981 8
a988 8
	  && get_next_frame (frame)
	  && ((get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME)
	      || pc_in_interrupt_handler (get_frame_pc (get_next_frame (frame)))))
	{
	  CORE_ADDR *saved_regs;
	  hppa_frame_init_saved_regs (get_next_frame (frame));
	  saved_regs = get_frame_saved_regs (get_next_frame (frame));
	  if (read_memory_integer (saved_regs[FLAGS_REGNUM],
d991 1
a991 1
	      pc = read_memory_integer (saved_regs[31],
d998 2
a999 2
	      if (pc == get_frame_pc (frame))
		pc = read_memory_integer (saved_regs[RP_REGNUM],
d1003 1
a1003 1
	    pc = read_memory_integer (saved_regs[RP_REGNUM],
d1014 1
a1014 1
	  pc = read_memory_integer (get_frame_base (frame) + rp_offset,
d1068 1
a1068 1
  if (get_next_frame (frame) && !fromleaf)
d1071 3
a1073 4
  /* If the next frame represents a frameless function invocation then
     we have to do some adjustments that are normally done by
     DEPRECATED_FRAME_CHAIN.  (DEPRECATED_FRAME_CHAIN is not called in
     this case.)  */
d1078 1
a1078 1
      framesize = find_proc_framesize (DEPRECATED_FRAME_SAVED_PC (get_next_frame (frame)));
d1085 1
a1085 1
	deprecated_update_frame_base_hack (frame, TARGET_READ_FP ());
d1087 1
a1087 1
	deprecated_update_frame_base_hack (frame, get_frame_base (frame) - framesize);
d1093 1
a1093 1
    deprecated_update_frame_pc_hack (frame, read_register (31) & ~0x3);
d1104 1
a1104 1
  framesize = find_proc_framesize (get_frame_pc (frame));
d1106 1
a1106 1
    deprecated_update_frame_base_hack (frame, TARGET_READ_FP ());
d1108 1
a1108 1
    deprecated_update_frame_base_hack (frame, read_register (SP_REGNUM) - framesize);
d1130 3
a1132 3
  /* Where the registers were saved in saved_regs_frame.  If
     saved_regs_frame is zero, this is garbage.  */
  CORE_ADDR *saved_regs = NULL;
d1143 2
a1144 2
  min_frame_symbol = lookup_minimal_symbol_by_pc (get_frame_pc (frame));
  frame_symbol = find_pc_function (get_frame_pc (frame));
d1173 2
a1174 2
  if (pc_in_interrupt_handler (get_frame_pc (frame)))
    frame_base = read_memory_integer (get_frame_base (frame) + SP_REGNUM * 4,
d1183 1
a1183 1
    frame_base = get_frame_base (frame);
d1187 2
a1188 2
  my_framesize = find_proc_framesize (get_frame_pc (frame));
  caller_pc = DEPRECATED_FRAME_SAVED_PC (frame);
d1196 1
a1196 1
  caller_framesize = find_proc_framesize (DEPRECATED_FRAME_SAVED_PC (frame));
d1227 1
a1227 1
  for (tmp_frame = frame; tmp_frame; tmp_frame = get_next_frame (tmp_frame))
d1229 1
a1229 1
      u = find_unwind_entry (get_frame_pc (tmp_frame));
d1242 1
a1242 1
	  warning ("Unable to find unwind for PC 0x%x -- Help!", get_frame_pc (tmp_frame));
d1249 1
a1249 1
	  || pc_in_interrupt_handler (get_frame_pc (tmp_frame)))
d1259 1
a1259 2
	  hppa_frame_init_saved_regs (tmp_frame);
	  saved_regs = get_frame_saved_regs (tmp_frame);
d1263 1
a1263 1
	  if (saved_regs[FP_REGNUM])
d1274 1
a1274 1
	  && !pc_in_interrupt_handler (get_frame_pc (tmp_frame)))
d1276 1
a1276 1
	  return read_memory_integer (get_frame_base (tmp_frame), TARGET_PTR_BIT / 8);
d1308 1
a1308 4
	    {
	      hppa_frame_init_saved_regs (tmp_frame);
	      saved_regs = get_frame_saved_regs (tmp_frame);
	    }
d1312 2
a1313 2
	      && ((saved_regs[FLAGS_REGNUM]
		   && (read_memory_integer (saved_regs[FLAGS_REGNUM],
d1316 1
a1316 1
		  || (saved_regs[FLAGS_REGNUM] == 0
d1319 1
a1319 1
	      u = find_unwind_entry (DEPRECATED_FRAME_SAVED_PC (frame));
d1322 1
a1322 1
		  return read_memory_integer (saved_regs[FP_REGNUM],
d1331 1
a1331 1
	  return read_memory_integer (saved_regs[FP_REGNUM],
d1339 2
a1340 2
      while (get_next_frame (tmp_frame) != NULL)
	tmp_frame = get_next_frame (tmp_frame);
d1343 1
a1343 4
	{
	  hppa_frame_init_saved_regs (tmp_frame);
	  saved_regs = get_frame_saved_regs (tmp_frame);
	}
d1347 2
a1348 2
	  && ((saved_regs[FLAGS_REGNUM]
	       && (read_memory_integer (saved_regs[FLAGS_REGNUM],
d1351 1
a1351 1
	      || (saved_regs[FLAGS_REGNUM] == 0
d1354 1
a1354 1
	  u = find_unwind_entry (DEPRECATED_FRAME_SAVED_PC (frame));
d1357 1
a1357 1
	      return read_memory_integer (saved_regs[FP_REGNUM],
d1384 1
a1384 1
  u = find_unwind_entry (get_frame_pc (thisframe));
d1395 1
a1395 1
  msym_us = lookup_minimal_symbol_by_pc (DEPRECATED_FRAME_SAVED_PC (thisframe));
d1412 1
a1412 1
    next_u = find_unwind_entry (get_frame_pc (next));
d1418 1
a1418 1
      || (get_next_frame (thisframe) && (get_frame_type (get_next_frame (thisframe)) == SIGTRAMP_FRAME))
d1422 1
a1422 1
  if (pc_in_linker_stub (get_frame_pc (thisframe)))
d1428 5
a1432 4
/* These functions deal with saving and restoring register state
   around a function call in the inferior.  They keep the stack
   double-word aligned;  eventually, on an hp700, the stack will have
   to be aligned to a 64-byte boundary.  */
d1435 1
a1435 1
hppa_push_dummy_frame (void)
d1442 9
d1455 6
a1460 1
      const unsigned int sid = (pc >> 30) & 0x3;
d1465 2
d1514 1
a1514 1
		       CORE_ADDR frame_saved_regs[])
d1516 1
a1516 1
  CORE_ADDR fp = get_frame_base (frame);
d1521 1
a1521 1
    frame_saved_regs[RP_REGNUM] = (fp - 16) & ~0x3;
d1523 1
a1523 1
    frame_saved_regs[RP_REGNUM] = (fp - 20) & ~0x3;
d1525 1
a1525 1
  frame_saved_regs[FP_REGNUM] = fp;
d1527 1
a1527 1
  frame_saved_regs[1] = fp + (2 * REGISTER_SIZE);
d1533 1
a1533 1
	  frame_saved_regs[i] = fp;
d1543 1
a1543 1
    frame_saved_regs[i] = fp;
d1545 6
a1550 6
  frame_saved_regs[IPSW_REGNUM] = fp;
  frame_saved_regs[SAR_REGNUM] = fp + REGISTER_SIZE;
  frame_saved_regs[PCOQ_HEAD_REGNUM] = fp + 2 * REGISTER_SIZE;
  frame_saved_regs[PCSQ_HEAD_REGNUM] = fp + 3 * REGISTER_SIZE;
  frame_saved_regs[PCOQ_TAIL_REGNUM] = fp + 4 * REGISTER_SIZE;
  frame_saved_regs[PCSQ_TAIL_REGNUM] = fp + 5 * REGISTER_SIZE;
d1559 1
a1559 1
  CORE_ADDR *fsr;
d1563 1
a1563 2
  hppa_frame_init_saved_regs (frame);
  fsr = get_frame_saved_regs (frame);
d1566 2
a1567 2
  if (fsr[IPSW_REGNUM])	/* Restoring a call dummy frame */
    restore_pc_queue (fsr);
d1571 2
a1572 2
    if (fsr[regnum])
      write_register (regnum, read_memory_integer (fsr[regnum],
d1576 1
a1576 1
    if (fsr[regnum])
d1578 1
a1578 1
	read_memory (fsr[regnum], (char *) &freg_buffer, 8);
d1583 1
a1583 1
  if (fsr[IPSW_REGNUM])
d1585 1
a1585 1
		    read_memory_integer (fsr[IPSW_REGNUM],
d1588 1
a1588 1
  if (fsr[SAR_REGNUM])
d1590 1
a1590 1
		    read_memory_integer (fsr[SAR_REGNUM],
d1594 1
a1594 1
  if (fsr[PCOQ_TAIL_REGNUM])
d1596 1
a1596 1
      npc = read_memory_integer (fsr[PCOQ_TAIL_REGNUM],
d1609 1
a1609 1
  if (fsr[IPSW_REGNUM])	/* call dummy */
d1622 1
a1622 1
  if (target_pc && !fsr[IPSW_REGNUM])
d1653 1
a1653 1
restore_pc_queue (CORE_ADDR *fsr)
d1656 1
a1656 1
  CORE_ADDR new_pc = read_memory_integer (fsr[PCOQ_HEAD_REGNUM],
d1675 1
a1675 1
  write_register (21, read_memory_integer (fsr[PCSQ_HEAD_REGNUM],
d3859 5
a3863 5
/* Put here the code to store, into the SAVED_REGS, the addresses of
   the saved registers of frame described by FRAME_INFO.  This
   includes special registers such as pc and fp saved in special ways
   in the stack frame.  sp is even more special: the address we return
   for it IS the sp for the next frame.  */
d3867 1
a3867 1
			    CORE_ADDR frame_saved_regs[])
d3878 1
a3878 1
  memset (frame_saved_regs, '\0', SIZEOF_FRAME_SAVED_REGS);
d3884 15
a3898 16
  if ((get_frame_pc (frame_info) >= get_frame_base (frame_info)
       && (get_frame_pc (frame_info)
	   <= (get_frame_base (frame_info)
	       /* A call dummy is sized in words, but it is actually a
		  series of instructions.  Account for that scaling
		  factor.  */
	       + ((REGISTER_SIZE / INSTRUCTION_SIZE)
		  * CALL_DUMMY_LENGTH)
	       /* Similarly we have to account for 64bit wide register
		  saves.  */
	       + (32 * REGISTER_SIZE)
	       /* We always consider FP regs 8 bytes long.  */
	       + (NUM_REGS - FP0_REGNUM) * 8
	       /* Similarly we have to account for 64bit wide register
		  saves.  */
	       + (6 * REGISTER_SIZE)))))
d3903 1
a3903 1
  if (pc_in_interrupt_handler (get_frame_pc (frame_info)))
d3909 2
a3910 2
	    frame_saved_regs[SP_REGNUM]
	      = read_memory_integer (get_frame_base (frame_info) + SP_REGNUM * 4,
d3913 1
a3913 1
	    frame_saved_regs[i] = get_frame_base (frame_info) + i * 4;
d3929 1
a3929 1
  pc = get_frame_func (frame_info);
d3962 1
a3962 1
  frame_saved_regs[SP_REGNUM] = get_frame_base (frame_info);
d3980 1
a3980 1
	 && pc <= get_frame_pc (frame_info))
d3997 1
a3997 1
	  frame_saved_regs[RP_REGNUM] = get_frame_base (frame_info) - 20;
d4002 1
a4002 1
	  frame_saved_regs[RP_REGNUM] = get_frame_base (frame_info) - 16;
d4010 1
a4010 1
	  frame_saved_regs[FP_REGNUM] = get_frame_base (frame_info);
d4024 1
a4024 1
	    frame_saved_regs[reg] = get_frame_base (frame_info);
d4027 1
a4027 1
	    frame_saved_regs[reg] = get_frame_base (frame_info);
d4041 2
a4042 2
		frame_saved_regs[reg]
		  = get_frame_base (frame_info) + offset;
d4044 2
a4045 2
		frame_saved_regs[reg]
		  = (get_frame_base (frame_info) + (u->Total_frame_size << 3)
d4077 1
a4077 1
	      frame_saved_regs[reg + FP4_REGNUM + 4] = get_frame_base (frame_info);
d4082 2
a4083 2
	      frame_saved_regs[reg + FP0_REGNUM + 4]
		= get_frame_base (frame_info) + fp_loc;
a4101 11
/* XXX - deprecated.  This is a compatibility function for targets
   that do not yet implement DEPRECATED_FRAME_INIT_SAVED_REGS.  */
/* Find the addresses in which registers are saved in FRAME.  */

void
hppa_frame_init_saved_regs (struct frame_info *frame)
{
  if (get_frame_saved_regs (frame) == NULL)
    frame_saved_regs_zalloc (frame);
  hppa_frame_find_saved_regs (frame, get_frame_saved_regs (frame));
}
d4543 1
a4543 1
  throw_addr = get_frame_pc (fi);
d4918 1
a4918 1
  return get_frame_base (fi);
d4924 1
a4924 1
  return get_frame_base (fi);
d4979 1
a4979 1
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, hppa_saved_pc_after_call);
d4982 1
d4998 1
a4998 1
  set_gdbarch_deprecated_store_struct_return (gdbarch, hppa_store_struct_return);
d5007 2
a5008 2
  set_gdbarch_deprecated_frame_chain (gdbarch, hppa_frame_chain);
  set_gdbarch_deprecated_frame_chain_valid (gdbarch, hppa_frame_chain_valid);
d5011 1
a5011 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, hppa_frame_saved_pc);
d5016 2
a5017 2
  set_gdbarch_deprecated_push_dummy_frame (gdbarch, hppa_push_dummy_frame);
  set_gdbarch_deprecated_pop_frame (gdbarch, hppa_pop_frame);
d5019 1
d5021 1
a5021 1
  set_gdbarch_deprecated_push_arguments (gdbarch, hppa_push_arguments);
@


1.27.14.9
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@a38 1
#include "infcall.h"
d1087 1
a1087 1
	deprecated_update_frame_base_hack (frame, deprecated_read_fp ());
d1108 1
a1108 1
    deprecated_update_frame_base_hack (frame, deprecated_read_fp ());
d1266 1
a1266 1
	  if (saved_regs[DEPRECATED_FP_REGNUM])
d1328 1
a1328 1
		  return read_memory_integer (saved_regs[DEPRECATED_FP_REGNUM],
d1337 1
a1337 1
	  return read_memory_integer (saved_regs[DEPRECATED_FP_REGNUM],
d1366 1
a1366 1
	      return read_memory_integer (saved_regs[DEPRECATED_FP_REGNUM],
d1377 1
a1377 1
      return deprecated_read_fp ();
d1474 1
a1474 1
  int_buffer = deprecated_read_fp ();
d1477 1
a1477 1
  write_register (DEPRECATED_FP_REGNUM, sp);
d1482 1
a1482 1
    if (regnum != RP_REGNUM && regnum != DEPRECATED_FP_REGNUM)
d1517 1
a1517 1
  frame_saved_regs[DEPRECATED_FP_REGNUM] = fp;
d1523 1
a1523 1
      if (i != DEPRECATED_FP_REGNUM)
d1600 1
a1600 1
  write_register (DEPRECATED_FP_REGNUM, read_memory_integer (fp, REGISTER_SIZE));
d2443 2
a2444 2
     register.  All others must use deprecated_read_fp (). */
  return read_register (DEPRECATED_FP_REGNUM);
d3591 1
a3591 1
      if (u->Save_SP && i == DEPRECATED_FP_REGNUM)
d3942 1
a3942 1
      if (u->Save_SP && i == DEPRECATED_FP_REGNUM)
d4004 1
a4004 1
	  frame_saved_regs[DEPRECATED_FP_REGNUM] = get_frame_base (frame_info);
d4011 1
a4011 1
	  && (!u->Save_SP || reg != DEPRECATED_FP_REGNUM))
d4762 1
a4762 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
d4777 1
a4777 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
d4990 1
a4990 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, 3);
d5029 1
a5029 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, hppa_target_read_fp);
d5049 1
a5049 1
  deprecated_tm_print_insn = print_insn_hppa;
@


1.27.14.10
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a70 16
/* Get at various relevent fields of an instruction word. */
#define MASK_5 0x1f
#define MASK_11 0x7ff
#define MASK_14 0x3fff
#define MASK_21 0x1fffff

/* Define offsets into the call dummy for the target function address.
   See comments related to CALL_DUMMY for more info.  */
#define FUNC_LDIL_OFFSET (INSTRUCTION_SIZE * 9)
#define FUNC_LDO_OFFSET (INSTRUCTION_SIZE * 10)

/* Define offsets into the call dummy for the _sr4export address.
   See comments related to CALL_DUMMY for more info.  */
#define SR4EXPORT_LDIL_OFFSET (INSTRUCTION_SIZE * 12)
#define SR4EXPORT_LDO_OFFSET (INSTRUCTION_SIZE * 13)

a75 6
/* Sizes (in bytes) of the native unwind entries.  */
#define UNWIND_ENTRY_SIZE 16
#define STUB_UNWIND_ENTRY_SIZE 8

static int get_field (unsigned word, int from, int to);

d203 1
a203 1
  return (TYPE_LENGTH (type) > 2 * DEPRECATED_REGISTER_SIZE);
a226 9
/* Extract the bits at positions between FROM and TO, using HP's numbering
   (MSB = 0). */

static int
get_field (unsigned word, int from, int to)
{
  return ((word) >> (31 - (to)) & ((1 << ((to) - (from) + 1)) - 1));
}

d278 1
a278 1
  val = get_field (word, 20, 20);
d280 1
a280 1
  val |= get_field (word, 9, 19);
d282 1
a282 1
  val |= get_field (word, 5, 6);
d284 1
a284 1
  val |= get_field (word, 0, 4);
d286 1
a286 1
  val |= get_field (word, 7, 8);
d299 1
a299 1
  val |= get_field (opnd, 11 + 14, 11 + 18);
d301 1
a301 1
  val |= get_field (opnd, 11 + 12, 11 + 13);
d303 1
a303 1
  val |= get_field (opnd, 11 + 19, 11 + 20);
d305 1
a305 1
  val |= get_field (opnd, 11 + 1, 11 + 11);
d307 1
a307 1
  val |= get_field (opnd, 11 + 0, 11 + 0);
d317 3
a319 3
  return sign_extend (get_field (word, 19, 28) |
		      get_field (word, 29, 29) << 10 |
		      get_field (word, 11, 15) << 11 |
a644 8
const unsigned char *
hppa_breakpoint_from_pc (CORE_ADDR *pc, int *len)
{
  static const char breakpoint[] = {0x00, 0x01, 0x00, 0x04};
  (*len) = sizeof (breakpoint);
  return breakpoint;
}

d907 2
a908 2
	       + ((DEPRECATED_REGISTER_SIZE / INSTRUCTION_SIZE)
		  * DEPRECATED_CALL_DUMMY_LENGTH)
d911 1
a911 1
	       + (32 * DEPRECATED_REGISTER_SIZE)
d916 1
a916 1
	       + (6 * DEPRECATED_REGISTER_SIZE)))))
d1470 2
a1471 2
  if (DEPRECATED_REGISTER_SIZE == 8)
    write_memory (sp - 16, (char *) &int_buffer, DEPRECATED_REGISTER_SIZE);
d1473 1
a1473 1
    write_memory (sp - 20, (char *) &int_buffer, DEPRECATED_REGISTER_SIZE);
d1476 1
a1476 1
  write_memory (sp, (char *) &int_buffer, DEPRECATED_REGISTER_SIZE);
d1480 1
a1480 1
  sp += 2 * DEPRECATED_REGISTER_SIZE;
d1487 1
a1487 1
  if (DEPRECATED_REGISTER_SIZE != 8)
d1513 1
a1513 1
  if (DEPRECATED_REGISTER_SIZE == 8)
d1520 1
a1520 1
  frame_saved_regs[1] = fp + (2 * DEPRECATED_REGISTER_SIZE);
d1522 1
a1522 1
  for (fp += 3 * DEPRECATED_REGISTER_SIZE, i = 3; i < 32; i++)
d1527 1
a1527 1
	  fp += DEPRECATED_REGISTER_SIZE;
d1532 1
a1532 1
  if (DEPRECATED_REGISTER_SIZE != 8)
d1539 5
a1543 5
  frame_saved_regs[SAR_REGNUM] = fp + DEPRECATED_REGISTER_SIZE;
  frame_saved_regs[PCOQ_HEAD_REGNUM] = fp + 2 * DEPRECATED_REGISTER_SIZE;
  frame_saved_regs[PCSQ_HEAD_REGNUM] = fp + 3 * DEPRECATED_REGISTER_SIZE;
  frame_saved_regs[PCOQ_TAIL_REGNUM] = fp + 4 * DEPRECATED_REGISTER_SIZE;
  frame_saved_regs[PCSQ_TAIL_REGNUM] = fp + 5 * DEPRECATED_REGISTER_SIZE;
d1567 1
a1567 1
						   DEPRECATED_REGISTER_SIZE));
d1580 1
a1580 1
					 DEPRECATED_REGISTER_SIZE));
d1585 1
a1585 1
					 DEPRECATED_REGISTER_SIZE));
d1591 1
a1591 1
				 DEPRECATED_REGISTER_SIZE);
d1601 1
a1601 1
  write_register (DEPRECATED_FP_REGNUM, read_memory_integer (fp, DEPRECATED_REGISTER_SIZE));
d1670 1
a1670 1
					   DEPRECATED_REGISTER_SIZE));
d1750 1
a1750 1
	  && TYPE_LENGTH (arg_type) < DEPRECATED_REGISTER_SIZE)
d1763 1
a1763 1
      bytes_reserved = (lengths[i] + DEPRECATED_REGISTER_SIZE - 1) & -DEPRECATED_REGISTER_SIZE;
d1775 2
a1776 2
	  int new_offset = ((offset[i] + 2*DEPRECATED_REGISTER_SIZE-1)
			    & -(2*DEPRECATED_REGISTER_SIZE));
d1863 1
a1863 1
      bytes_reserved = (lengths[i] + DEPRECATED_REGISTER_SIZE - 1) & -DEPRECATED_REGISTER_SIZE;
d1870 2
a1871 2
      if ((bytes_reserved == 2 * DEPRECATED_REGISTER_SIZE)
	  && (offset[i] % 2 * DEPRECATED_REGISTER_SIZE))
d1879 2
a1880 2
	  new_offset = ((offset[i] + 2 * DEPRECATED_REGISTER_SIZE - 1)
			& -(2 * DEPRECATED_REGISTER_SIZE));
d1882 1
a1882 1
	  if ((new_offset - offset[i]) >= 2 * DEPRECATED_REGISTER_SIZE)
d1884 2
a1885 2
	      bytes_reserved += DEPRECATED_REGISTER_SIZE;
	      offset[i] += DEPRECATED_REGISTER_SIZE;
d2039 3
a2041 3
   Therefore our version of DEPRECATED_FIX_CALL_DUMMY takes an extra
   argument, real_pc, which is the location where gdb should start up
   the inferior to do the function call.
d2197 1
a2197 1
					       DEPRECATED_REGISTER_SIZE));
d2531 1
a2531 1
  char *raw_regs = alloca (DEPRECATED_REGISTER_BYTES);
d2575 1
a2575 1
  char *raw_regs = alloca (DEPRECATED_REGISTER_BYTES);
d2632 1
a2632 1
  char buf[MAX_REGISTER_SIZE];
d2829 2
a2830 2
  char raw_buffer[MAX_REGISTER_SIZE];
  char virtual_buffer[MAX_REGISTER_SIZE];
d2872 2
a2873 2
  char raw_buffer[MAX_REGISTER_SIZE];
  char virtual_buffer[MAX_REGISTER_SIZE];
d2887 1
a2887 1
      char raw_buf[MAX_REGISTER_SIZE];
d3884 2
a3885 2
	       + ((DEPRECATED_REGISTER_SIZE / INSTRUCTION_SIZE)
		  * DEPRECATED_CALL_DUMMY_LENGTH)
d3888 1
a3888 1
	       + (32 * DEPRECATED_REGISTER_SIZE)
d3893 1
a3893 1
	       + (6 * DEPRECATED_REGISTER_SIZE)))))
d4371 1
a4371 1
  sym = lookup_symbol_linkage (HP_ACC_EH_catch_catch);
d4860 1
a4860 1
  return DEPRECATED_REGISTER_SIZE;
d4989 1
a4989 1
  set_gdbarch_deprecated_register_size (gdbarch, 4);
d4997 1
a4997 1
  set_gdbarch_deprecated_register_bytes (gdbarch, hppa_num_regs * 4);
d5023 2
a5024 2
  set_gdbarch_deprecated_call_dummy_length (gdbarch, INSTRUCTION_SIZE * 28);
  /* set_gdbarch_deprecated_fix_call_dummy (gdbarch, hppa_fix_call_dummy); */
@


1.27.14.11
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d132 3
d4673 86
d4961 20
a4992 10
/* Get the ith function argument for the current function.  */
CORE_ADDR
hppa_fetch_pointer_argument (struct frame_info *frame, int argi, 
			     struct type *type)
{
  CORE_ADDR addr;
  frame_read_register (frame, R0_REGNUM + 26 - argi, &addr);
  return addr;
}

d5035 1
a5035 1
  set_gdbarch_deprecated_register_raw_size (gdbarch, hppa_register_raw_size);
d5037 2
a5038 2
  set_gdbarch_deprecated_register_byte (gdbarch, hppa_register_byte);
  set_gdbarch_deprecated_register_virtual_size (gdbarch, hppa_register_raw_size);
d5041 1
a5041 1
  set_gdbarch_deprecated_register_virtual_type (gdbarch, hppa_register_virtual_type);
d5056 3
a5069 3

  /* Helper for function argument information.  */
  set_gdbarch_fetch_pointer_argument (gdbarch, hppa_fetch_pointer_argument);
@


1.27.14.12
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a680 82
/* Return the name of a register.  */

const char *
hppa_register_name (int i)
{
  static char *names[] = {
    "flags",  "r1",      "rp",     "r3",
    "r4",     "r5",      "r6",     "r7",
    "r8",     "r9",      "r10",    "r11",
    "r12",    "r13",     "r14",    "r15",
    "r16",    "r17",     "r18",    "r19",
    "r20",    "r21",     "r22",    "r23",
    "r24",    "r25",     "r26",    "dp",
    "ret0",   "ret1",    "sp",     "r31",
    "sar",    "pcoqh",   "pcsqh",  "pcoqt",
    "pcsqt",  "eiem",    "iir",    "isr",
    "ior",    "ipsw",    "goto",   "sr4",
    "sr0",    "sr1",     "sr2",    "sr3",
    "sr5",    "sr6",     "sr7",    "cr0",
    "cr8",    "cr9",     "ccr",    "cr12",
    "cr13",   "cr24",    "cr25",   "cr26",
    "mpsfu_high","mpsfu_low","mpsfu_ovflo","pad",
    "fpsr",    "fpe1",   "fpe2",   "fpe3",
    "fpe4",   "fpe5",    "fpe6",   "fpe7",
    "fr4",     "fr4R",   "fr5",    "fr5R",
    "fr6",    "fr6R",    "fr7",    "fr7R",
    "fr8",     "fr8R",   "fr9",    "fr9R",
    "fr10",   "fr10R",   "fr11",   "fr11R",
    "fr12",    "fr12R",  "fr13",   "fr13R",
    "fr14",   "fr14R",   "fr15",   "fr15R",
    "fr16",    "fr16R",  "fr17",   "fr17R",
    "fr18",   "fr18R",   "fr19",   "fr19R",
    "fr20",    "fr20R",  "fr21",   "fr21R",
    "fr22",   "fr22R",   "fr23",   "fr23R",
    "fr24",    "fr24R",  "fr25",   "fr25R",
    "fr26",   "fr26R",   "fr27",   "fr27R",
    "fr28",    "fr28R",  "fr29",   "fr29R",
    "fr30",   "fr30R",   "fr31",   "fr31R"
  };
  if (i < 0 || i >= (sizeof (names) / sizeof (*names)))
    return NULL;
  else
    return names[i];
}

const char *
hppa64_register_name (int i)
{
  static char *names[] = {
    "flags",  "r1",      "rp",     "r3",
    "r4",     "r5",      "r6",     "r7",
    "r8",     "r9",      "r10",    "r11",
    "r12",    "r13",     "r14",    "r15",
    "r16",    "r17",     "r18",    "r19",
    "r20",    "r21",     "r22",    "r23",
    "r24",    "r25",     "r26",    "dp",
    "ret0",   "ret1",    "sp",     "r31",
    "sar",    "pcoqh",   "pcsqh",  "pcoqt",
    "pcsqt",  "eiem",    "iir",    "isr",
    "ior",    "ipsw",    "goto",   "sr4",
    "sr0",    "sr1",     "sr2",    "sr3",
    "sr5",    "sr6",     "sr7",    "cr0",
    "cr8",    "cr9",     "ccr",    "cr12",
    "cr13",   "cr24",    "cr25",   "cr26",
    "mpsfu_high","mpsfu_low","mpsfu_ovflo","pad",
    "fpsr",    "fpe1",   "fpe2",   "fpe3",
    "fr4",    "fr5",     "fr6",    "fr7",
    "fr8",     "fr9",    "fr10",   "fr11",
    "fr12",   "fr13",    "fr14",   "fr15",
    "fr16",    "fr17",   "fr18",   "fr19",
    "fr20",   "fr21",    "fr22",   "fr23",
    "fr24",    "fr25",   "fr26",   "fr27",
    "fr28",  "fr29",    "fr30",   "fr31"
  };
  if (i < 0 || i >= (sizeof (names) / sizeof (*names)))
    return NULL;
  else
    return names[i];
}



a4942 1
  set_gdbarch_register_name (gdbarch, hppa_register_name);
@


1.27.14.13
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a39 1
#include "dis-asm.h"
a66 1
#include "hppa-tdep.h"
d69 1
a69 11
static const int hppa32_num_regs = 128;
static const int hppa64_num_regs = 96;

static const int hppa64_call_dummy_breakpoint_offset = 22 * 4;

/* DEPRECATED_CALL_DUMMY_LENGTH is computed based on the size of a
   word on the target machine, not the size of an instruction.  Since
   a word on this target holds two instructions we have to divide the
   instruction size by two to get the word size of the dummy.  */
static const int hppa32_call_dummy_length = INSTRUCTION_SIZE * 28;
static const int hppa64_call_dummy_length = INSTRUCTION_SIZE * 26 / 2;
d167 1
a167 2
CORE_ADDR hppa32_stack_align (CORE_ADDR sp);
CORE_ADDR hppa64_stack_align (CORE_ADDR sp);
d172 1
a172 2
struct type * hppa32_register_virtual_type (int reg_nr);
struct type * hppa64_register_virtual_type (int reg_nr);
d174 3
a176 8
void hppa32_extract_return_value (struct type *type, char *regbuf,
                                  char *valbuf);
void hppa64_extract_return_value (struct type *type, char *regbuf,
                                  char *valbuf);
int hppa32_use_struct_convention (int gcc_p, struct type *type);
int hppa64_use_struct_convention (int gcc_p, struct type *type);
void hppa32_store_return_value (struct type *type, char *valbuf);
void hppa64_store_return_value (struct type *type, char *valbuf);
d185 1
d220 1
a220 1
hppa32_use_struct_convention (int gcc_p, struct type *type)
d224 1
a224 9

/* Same as hppa32_use_struct_convention() for the PA64 ABI.  */

int
hppa64_use_struct_convention (int gcc_p, struct type *type)
{
  /* RM: struct upto 128 bits are returned in registers */
  return TYPE_LENGTH (type) > 16;
}
d684 1
a684 1
hppa32_register_name (int i)
d1565 1
a1565 1
  int regnum;
d1610 1
a1610 1
      deprecated_read_register_bytes (DEPRECATED_REGISTER_BYTE (regnum),
d1667 3
a1669 3
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR fp, npc, target_pc;
  int regnum;
d1691 1
a1691 1
	deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (regnum),
d1847 1
a1847 1
  CORE_ADDR orig_sp = DEPRECATED_STACK_ALIGN (sp);
d1910 1
a1910 1
  cum_bytes_aligned = DEPRECATED_STACK_ALIGN (cum_bytes_reserved);
d2017 1
a2017 1
  cum_bytes_aligned = DEPRECATED_STACK_ALIGN (cum_bytes_reserved);
d2045 1
a2045 1
hppa_value_returned_from_stack (struct type *valtype, CORE_ADDR addr)
d2047 1
a2047 1
  struct value *val;
d2606 1
a2606 1
  write_register_pid (DEPRECATED_NPC_REGNUM, v + 4, ptid);
d2655 1
a2655 2
    frame_register_read (deprecated_selected_frame, i,
			 raw_regs + DEPRECATED_REGISTER_BYTE (i));
d2699 1
a2699 2
    frame_register_read (deprecated_selected_frame, i,
			 raw_regs + DEPRECATED_REGISTER_BYTE (i));
d2746 1
a2746 1
  int i;
d2768 1
a2768 1
      raw_val[1] = *(long *) (raw_regs + DEPRECATED_REGISTER_BYTE (regnum));
d4782 1
a4782 1
hppa32_store_return_value (struct type *type, char *valbuf)
d4790 1
a4790 1
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (28)
d4796 1
a4796 1
    deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (FP4_REGNUM),
a4799 26
/* Same as hppa32_store_return_value(), but for the PA64 ABI.  */

void
hppa64_store_return_value (struct type *type, char *valbuf)
{
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    deprecated_write_register_bytes
      (DEPRECATED_REGISTER_BYTE (FP4_REGNUM)
        + DEPRECATED_REGISTER_SIZE - TYPE_LENGTH (type),
       valbuf, TYPE_LENGTH (type));
  else if (is_integral_type(type))
    deprecated_write_register_bytes
      (DEPRECATED_REGISTER_BYTE (28)
        + DEPRECATED_REGISTER_SIZE - TYPE_LENGTH (type),
       valbuf, TYPE_LENGTH (type));
  else if (TYPE_LENGTH (type) <= 8)
    deprecated_write_register_bytes
      (DEPRECATED_REGISTER_BYTE (28),valbuf, TYPE_LENGTH (type));
  else if (TYPE_LENGTH (type) <= 16)
    {
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (28),valbuf, 8);
      deprecated_write_register_bytes
        (DEPRECATED_REGISTER_BYTE (29), valbuf + 8, TYPE_LENGTH (type) - 8);
    }
}

d4808 1
a4808 1
hppa32_extract_return_value (struct type *type, char *regbuf, char *valbuf)
d4811 3
a4813 1
    memcpy (valbuf, regbuf + DEPRECATED_REGISTER_BYTE (FP4_REGNUM), TYPE_LENGTH (type));
d4816 2
a4817 2
	    (regbuf
	     + DEPRECATED_REGISTER_BYTE (28)
a4823 30
/* Same as hppa32_extract_return_value but for the PA64 ABI case.  */

void
hppa64_extract_return_value (struct type *type, char *regbuf, char *valbuf)
{
  /* RM: Floats are returned in FR4R, doubles in FR4.
         Integral values are in r28, padded on the left.
         Aggregates less that 65 bits are in r28, right padded.
         Aggregates upto 128 bits are in r28 and r29, right padded.  */ 
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    memcpy (valbuf,
            regbuf + DEPRECATED_REGISTER_BYTE (FP4_REGNUM)
             + DEPRECATED_REGISTER_SIZE - TYPE_LENGTH (type),
            TYPE_LENGTH (type));
  else if (is_integral_type(type))
    memcpy (valbuf,
            regbuf + DEPRECATED_REGISTER_BYTE (28)
             + DEPRECATED_REGISTER_SIZE - TYPE_LENGTH (type),
            TYPE_LENGTH (type));
  else if (TYPE_LENGTH (type) <= 8)
    memcpy (valbuf, regbuf + DEPRECATED_REGISTER_BYTE (28),
	    TYPE_LENGTH (type));
  else if (TYPE_LENGTH (type) <= 16)
    {
      memcpy (valbuf, regbuf + DEPRECATED_REGISTER_BYTE (28), 8);
      memcpy (valbuf + 8, regbuf + DEPRECATED_REGISTER_BYTE (29),
	      TYPE_LENGTH (type) - 8);
    }
}

d4840 1
a4840 1
hppa32_stack_align (CORE_ADDR sp)
a4847 7
CORE_ADDR
hppa64_stack_align (CORE_ADDR sp)
{
  /* The PA64 ABI mandates a 16 byte stack alignment.  */
  return ((sp % 16) ? (sp + 15) & -16 : sp);
}

d4901 1
a4901 3
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  return reg_nr * tdep->bytes_per_address;
d4908 1
a4908 1
hppa32_register_virtual_type (int reg_nr)
a4915 12
/* Return the GDB type object for the "standard" data type of data
   in register N.  hppa64 version.  */

struct type *
hppa64_register_virtual_type (int reg_nr)
{
   if (reg_nr < FP4_REGNUM)
     return builtin_type_unsigned_long_long;
   else
     return builtin_type_double;
}

d4937 1
a4937 1
  return (*(int *)(regbuf + DEPRECATED_REGISTER_BYTE (28)));
a4978 1
  struct gdbarch_tdep *tdep;
d4995 1
a4995 2
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);
d4997 2
a4998 8
  /* Determine from the bfd_arch_info structure if we are dealing with
     a 32 or 64 bits architecture.  If the bfd_arch_info is not available,
     then default to a 32bit machine.  */
  if (info.bfd_arch_info != NULL)
    tdep->bytes_per_address =
      info.bfd_arch_info->bits_per_address / info.bfd_arch_info->bits_per_byte;
  else
    tdep->bytes_per_address = 4;
d5000 1
a5000 53
  /* Some parts of the gdbarch vector depend on whether we are running
     on a 32 bits or 64 bits target.  */
  switch (tdep->bytes_per_address)
    {
      case 4:
        set_gdbarch_num_regs (gdbarch, hppa32_num_regs);
        set_gdbarch_register_name (gdbarch, hppa32_register_name);
        set_gdbarch_deprecated_register_virtual_type
          (gdbarch, hppa32_register_virtual_type);
        set_gdbarch_deprecated_call_dummy_length
          (gdbarch, hppa32_call_dummy_length);
        set_gdbarch_deprecated_stack_align (gdbarch, hppa32_stack_align);
        set_gdbarch_deprecated_reg_struct_has_addr
	  (gdbarch, hppa_reg_struct_has_addr);
        set_gdbarch_deprecated_extract_return_value
          (gdbarch, hppa32_extract_return_value);
        set_gdbarch_use_struct_convention
          (gdbarch, hppa32_use_struct_convention);
        set_gdbarch_deprecated_store_return_value
          (gdbarch, hppa32_store_return_value);
        break;
      case 8:
        set_gdbarch_num_regs (gdbarch, hppa64_num_regs);
        set_gdbarch_register_name (gdbarch, hppa64_register_name);
        set_gdbarch_deprecated_register_virtual_type
          (gdbarch, hppa64_register_virtual_type);
        set_gdbarch_deprecated_call_dummy_breakpoint_offset
          (gdbarch, hppa64_call_dummy_breakpoint_offset);
        set_gdbarch_deprecated_call_dummy_length
          (gdbarch, hppa64_call_dummy_length);
        set_gdbarch_deprecated_stack_align (gdbarch, hppa64_stack_align);
        set_gdbarch_deprecated_extract_return_value
          (gdbarch, hppa64_extract_return_value);
        set_gdbarch_use_struct_convention
          (gdbarch, hppa64_use_struct_convention);
        set_gdbarch_deprecated_store_return_value
          (gdbarch, hppa64_store_return_value);
        break;
      default:
        internal_error (__FILE__, __LINE__, "Unsupported address size: %d",
                        tdep->bytes_per_address);
    }

  /* The following gdbarch vector elements depend on other parts of this
     vector which have been set above, depending on the ABI.  */
  set_gdbarch_deprecated_register_bytes
    (gdbarch, gdbarch_num_regs (gdbarch) * tdep->bytes_per_address);
  set_gdbarch_long_bit (gdbarch, tdep->bytes_per_address * TARGET_CHAR_BIT);
  set_gdbarch_long_long_bit (gdbarch, 64);
  set_gdbarch_ptr_bit (gdbarch, tdep->bytes_per_address * TARGET_CHAR_BIT);

  /* The following gdbarch vector elements do not depend on the address
     size, or in any other gdbarch element previously set.  */
d5009 1
d5011 2
a5012 1
  set_gdbarch_deprecated_register_size (gdbarch, tdep->bytes_per_address);
d5017 1
a5017 1
  set_gdbarch_deprecated_npc_regnum (gdbarch, PCOQ_TAIL_REGNUM);
d5019 1
d5022 1
a5022 1
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, tdep->bytes_per_address);
d5024 2
d5027 4
d5043 1
a5045 1
  set_gdbarch_addr_bits_remove (gdbarch, hppa_smash_text_address);
a5054 11
  set_gdbarch_print_insn (gdbarch, print_insn_hppa);

  /* When a hardware watchpoint triggers, we'll move the inferior past
     it by removing all eventpoints; stepping past the instruction
     that caused the trigger; reinserting eventpoints; and checking
     whether any watched location changed.  */
  set_gdbarch_have_nonsteppable_watchpoint (gdbarch, 1);

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

d5073 1
@


1.27.14.14
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1093 1
a1093 1
	  saved_regs = deprecated_get_frame_saved_regs (get_next_frame (frame));
d1133 1
a1133 1
	  saved_regs = deprecated_get_frame_saved_regs (get_next_frame (frame));
d1407 1
a1407 1
	  saved_regs = deprecated_get_frame_saved_regs (tmp_frame);
d1458 1
a1458 1
	      saved_regs = deprecated_get_frame_saved_regs (tmp_frame);
d1496 1
a1496 1
	  saved_regs = deprecated_get_frame_saved_regs (tmp_frame);
d1701 1
a1701 1
  fsr = deprecated_get_frame_saved_regs (frame);
a2069 3
/* FIXME: cagney/2003-09-27: This function is no longer needed.  The
   inferior function call code now directly handles the case described
   above.  */
d2375 1
a2375 1
	      (SYMBOL_LINKAGE_NAME (funsymbol), objfile);
d2982 1
a2982 1
  memcpy (virtual_buffer, raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (i));
d2988 1
a2988 1
  val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0, gdb_stdout, 0,
d3000 2
a3001 2
      memcpy (virtual_buffer + DEPRECATED_REGISTER_RAW_SIZE (i), raw_buffer,
	      DEPRECATED_REGISTER_RAW_SIZE (i));
d3028 1
a3028 1
  memcpy (virtual_buffer, raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (i));
d3039 1
a3039 2
      memcpy (virtual_buffer + DEPRECATED_REGISTER_RAW_SIZE (i), raw_buf,
	      DEPRECATED_REGISTER_RAW_SIZE (i));
d3047 1
a3047 1
      val_print (DEPRECATED_REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0, stream, 0,
d3093 2
a3094 3
    if (bfd_get_section_vma (sec->owner, sec) <= pc
	&& pc < (bfd_get_section_vma (sec->owner, sec)
		 + bfd_section_size (sec->owner, sec)))
d4250 1
a4250 1
  if (deprecated_get_frame_saved_regs (frame) == NULL)
d4252 1
a4252 1
  hppa_frame_find_saved_regs (frame, deprecated_get_frame_saved_regs (frame));
a5039 4
  /* FIXME: cagney/2003-09-27: This function can probably go.  ELZ
     writes: We cannot assume on the pa that r28 still contains the
     address of the returned structure. Usually this will be
     overwritten by the callee.  */
d5075 1
a5075 1
  get_frame_register (frame, R0_REGNUM + 26 - argi, &addr);
@


1.27.14.15
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d2063 24
d3405 1
a3405 1
		&& DEPRECATED_STREQ (DEPRECATED_SYMBOL_NAME (msymbol), DEPRECATED_SYMBOL_NAME (msym)))
@


1.27.14.16
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d4 1
a4 2
   1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d196 1
d2611 1
a2611 1
  write_register_pid (PCOQ_TAIL_REGNUM, v + 4, ptid);
d5008 20
a5063 35
/* Here is a table of C type sizes on hppa with various compiles
   and options.  I measured this on PA 9000/800 with HP-UX 11.11
   and these compilers:

     /usr/ccs/bin/cc    HP92453-01 A.11.01.21
     /opt/ansic/bin/cc  HP92453-01 B.11.11.28706.GP
     /opt/aCC/bin/aCC   B3910B A.03.45
     gcc                gcc 3.3.2 native hppa2.0w-hp-hpux11.11

     cc            : 1 2 4 4 8 : 4 8 -- : 4 4
     ansic +DA1.1  : 1 2 4 4 8 : 4 8 16 : 4 4
     ansic +DA2.0  : 1 2 4 4 8 : 4 8 16 : 4 4
     ansic +DA2.0W : 1 2 4 8 8 : 4 8 16 : 8 8
     acc   +DA1.1  : 1 2 4 4 8 : 4 8 16 : 4 4
     acc   +DA2.0  : 1 2 4 4 8 : 4 8 16 : 4 4
     acc   +DA2.0W : 1 2 4 8 8 : 4 8 16 : 8 8
     gcc           : 1 2 4 4 8 : 4 8 16 : 4 4

   Each line is:

     compiler and options
     char, short, int, long, long long
     float, double, long double
     char *, void (*)()

   So all these compilers use either ILP32 or LP64 model.
   TODO: gcc has more options so it needs more investigation.

   For floating point types, see:

     http://docs.hp.com/hpux/pdf/B3906-90006.pdf
     HP-UX floating-point guide, hpux 11.00

   -- chastain 2003-12-18  */

d5144 1
a5146 6
  /* The following gdbarch vector elements are the same in both ILP32
     and LP64, but might show differences some day.  */
  set_gdbarch_long_long_bit (gdbarch, 64);
  set_gdbarch_long_double_bit (gdbarch, 128);
  set_gdbarch_long_double_format (gdbarch, &floatformat_ia64_quad_big);

d5149 1
d5157 1
d5163 1
d5170 2
@


1.26
log
@* arch-utils.h: Update copyright.

* gdbarch.sh (PC_IN_SIGTRAMP): Add.
* gdbarch.h, gdbarch.c: Re-generate.

* inferior.h (IN_SIGTRAMP): Delete definition.
* arch-utils.c (legacy_pc_in_sigtramp): New function.
* arch-utils.h (legacy_pc_in_sigtramp): Declare.

* mips-tdep.c (mips_init_extra_frame_info): Use PC_IN_SIGTRAMP.
(mips_dump_tdep): Do not print value of IN_SIGTRAMP.
* hppa-tdep.c (pc_in_interrupt_handler):  Use PC_IN_SIGTRAMP.
(find_proc_framesize): Ditto.
* alpha-tdep.c (alpha_osf_skip_sigtramp_frame): Ditto.
(alpha_init_extra_frame_info): Ditto.
* infrun.c (handle_inferior_event): Ditto.
(handle_inferior_event): Ditto.
(check_sigtramp2): Ditto.
* blockframe.c (create_new_frame): Ditto.
(get_prev_frame): Ditto.
* ppc-linux-tdep.c: Update comments.
* i386-linux-tdep.c: Update comments.
* breakpoint.c (bpstat_what): Update comment.

* gdbint.texinfo (Target Architecture Definition): Replace
IN_SIGTRAMP with PC_IN_SIGTRAMP.
@
text
@d4468 1
a4468 1
  select_frame (fi, -1);
d4494 1
a4494 1
  select_frame (fi, -1);
d4498 1
a4498 1
  select_frame (curr_frame, -1);
@


1.25
log
@* defs.h (read_relative_register_raw_bytes): Delete declaration.
* frame.c (frame_register_read): New function.  Return non-zero on
success.
(read_relative_register_raw_bytes_for_frame): Delete.
(read_relative_register_raw_bytes): Delete.
* frame.h (frame_register_read): Declare.
* d30v-tdep.c: Update Copyright.  Use frame_register_read.
* sh-tdep.c: Ditto.
* infcmd.c (do_registers_info): Ditto.
* hppa-tdep.c: Ditto.
* rs6000-tdep.c: Ditto.
* h8500-tdep.c: Ditto.
* mips-tdep.c: Ditto.
* h8300-tdep.c: Ditto.
* z8k-tdep.c: Ditto.
@
text
@d636 2
a637 1
  return u->HP_UX_interrupt_marker && !IN_SIGTRAMP (pc, SYMBOL_NAME (msym_us));
d755 1
a755 1
      && !IN_SIGTRAMP (pc, SYMBOL_NAME (msym_us)))
@


1.24
log
@        * somread.c (som_symtab_read): Remove some commented out code and
        updated related comments.  Do not set the minimal symbol table to
        mst_solib_trampoline for ST_ENTRY symbols with SS_LOCAL scope
        in a dynamic executable.
        * hppa-tdep.c (find_proc_framesize): Sanely handle the case
        where we are unable to find the minimal symbol for the given
        PC value.
@
text
@d2 3
a4 2
   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d2492 1
a2492 1
    read_relative_register_raw_bytes (i, raw_regs + REGISTER_BYTE (i));
d2536 1
a2536 1
    read_relative_register_raw_bytes (i, raw_regs + REGISTER_BYTE (i));
d2788 1
a2788 1
  read_relative_register_raw_bytes (i, raw_buffer);
d2806 1
a2806 1
      read_relative_register_raw_bytes (i + 1, raw_buffer);
d2834 1
a2834 1
  read_relative_register_raw_bytes (i, raw_buffer);
d2845 1
a2845 1
      read_relative_register_raw_bytes (i + 1, raw_buf);
@


1.23
log
@* cli/cli-decode.c (set_cmd_completer): New function.
* command.h (set_cmd_completer): Declare.
* cli/cli-decode.h (set_cmd_completer): Ditto.

* breakpoint.c (_initialize_breakpoint): Use set_cmd_completer.
* cli/cli-cmds.c (init_cli_cmds): Ditto.
* win32-nat.c (_initialize_inftarg): Ditto.
* remote-rdi.c (_initialize_remote_rdi): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* hppa-tdep.c (_initialize_hppa_tdep): Ditto.
* source.c (_initialize_source): Ditto.
* exec.c (_initialize_exec): Ditto.
* solib.c (_initialize_solib): Ditto.
* top.c (init_main): Ditto.
* tracepoint.c (_initialize_tracepoint): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* printcmd.c (_initialize_printcmd): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
@
text
@d750 3
a752 1
  if (u->Save_SP && !pc_in_interrupt_handler (pc)
@


1.22
log
@	* breakpoint.c (break_at_finish_command): Really export.
	(break_at_finish_at_depth_command): Ditto.
	(tbreak_at_finish_command): Ditto.
	* hppa-tdep.c: Include completer.h.
	* Makefile.in (hppa-tdep.o): Add dependency on $(completer_h).
	(COMMON_OBS): Remove duplicate ui-file.o, frame.o, doublest.o.
@
text
@d4712 1
a4712 1
  c->completer = location_completer;
@


1.21
log
@2002-02-01  Michael Snyder  <msnyder@@redhat.com>

	* hppa-tdep.c: Deprecate xbreak, txbreak and bx commands.
@
text
@d31 1
@


1.20
log
@2002-01-31  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (break_at_finish_command): Export.
	(break_at_finish_at_depth_command): Export.
	(tbreak_at_finish_command): Export.
	(_initialize_breakpoint): Delete "xbreak" and "tbreak" commands.
	* hppa-tdep.c (_initialize_hppa_tdep): Add "xbreak" and
	"tbreak" commands, which are HPPA specific.
@
text
@d4689 3
a4691 2
  add_com ("xbreak", class_breakpoint, break_at_finish_command,
	   concat ("Set breakpoint at procedure exit. \n\
d4701 5
a4705 5
Do \"help breakpoints\" for info on other commands dealing with breakpoints.", NULL));
  add_com_alias ("xb", "xbreak", class_breakpoint, 1);
  add_com_alias ("xbr", "xbreak", class_breakpoint, 1);
  add_com_alias ("xbre", "xbreak", class_breakpoint, 1);
  add_com_alias ("xbrea", "xbreak", class_breakpoint, 1);
d4707 4
a4710 3
  c = add_com ("txbreak", class_breakpoint, tbreak_at_finish_command,
	       "Set temporary breakpoint at procedure exit.  Either there should\n\
be no argument or the argument must be a depth.\n");
d4712 1
a4712 1

d4714 4
a4717 3
    add_com ("bx", class_breakpoint, break_at_finish_at_depth_command,
	     "Set breakpoint at procedure exit.  Either there should\n\
be no argument or the argument must be a depth.\n");
@


1.19
log
@* hppa-tdep.c (hppa_push_arguments): Correct handling of 5-7 byte
structures passed in registers.
@
text
@d4678 5
d4688 27
@


1.18
log
@        * config/pa/tm-hppa.h (STORE_RETURN_VALUE): Use hppa_store_return_value.
        (EXTRACT_RETURN_VALUE): Similarly.
        * hppa-tdep.c (hppa_store_return_value): New function.
        (hppa_extract_return_value): New function.
@
text
@d1818 2
a1819 1
      offset[i] = cum_bytes_reserved + lengths[i];
@


1.17
log
@Fix -Wformat for hpux.
@
text
@d4683 50
@


1.16
log
@s/value_ptr/struct value */
@
text
@d2501 1
a2501 1
	  printf_unfiltered ("%s %x\n", REGISTER_NAME (regnum), reg_val[1]);
d2507 1
a2507 1
	    printf_unfiltered ("%s %x\n", REGISTER_NAME (regnum), reg_val[1]);
d2509 1
a2509 1
	    printf_unfiltered ("%s %x%8.8x\n", REGISTER_NAME (regnum),
d2546 1
a2546 1
	  fprintf_unfiltered (stream, "%s %x", REGISTER_NAME (regnum), reg_val[1]);
d2552 1
a2552 1
	    fprintf_unfiltered (stream, "%s %x", REGISTER_NAME (regnum),
d2555 1
a2555 1
	    fprintf_unfiltered (stream, "%s %x%8.8x", REGISTER_NAME (regnum),
d2702 1
a2702 1
	      printf_filtered ("%10.10s: %8x   ",
d2709 1
a2709 1
		printf_filtered ("%10.10s:         %8x   ",
d2712 1
a2712 1
		printf_filtered ("%10.10s: %8x%8.8x   ",
d2753 2
a2754 1
	      fprintf_filtered (stream, "%8.8s: %8x  ", REGISTER_NAME (i + (j * 18)), long_val);
d2760 5
a2764 1
		fprintf_filtered (stream, "%8.8s:         %8x  ", REGISTER_NAME (i + (j * 18)),
a2765 3
	      else
		fprintf_filtered (stream, "%8.8s: %8x%8.8x  ", REGISTER_NAME (i + (j * 18)),
				  raw_val[0], raw_val[1]);
d3295 1
a3295 1
	      warning ("Unable to find symbol for 0x%x", loc);
d4522 2
a4523 1
  printf_unfiltered ("unwind_table_entry (0x%x):\n", u);
@


1.15
log
@
* arch-utils.c (generic_prepare_to_proceed): Allow for having
stopped due to a Ctrl-C as well as breakpoints.

* hppa-tdep.c (hppa_prepare_to_proceed): Add FIXME as this may not
support thread switches after Ctrl-C.
* lin-lwp.c (lin_lwp_prepare_to_proceed): Ditto.
* linux-thread.c (linuxthreads_prepare_to_proceed): Ditto.
* m3-nat.c (mach3_prepare_to_proceed): Ditto.
@
text
@d151 1
a151 1
extern value_ptr find_function_in_inferior (char *);
d1670 1
a1670 1
hppa_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
d1789 1
a1789 1
hppa_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
d1878 1
a1878 1
value_ptr
d1881 1
a1881 1
  register value_ptr val;
d1917 3
a1919 2
  value_ptr *args;
  value_ptr funcval, val;
d1926 1
a1926 1
  args = (value_ptr *) alloca (sizeof (value_ptr) * 8);		/* 6 for the arguments and one null one??? */
d2013 1
a2013 1
		     value_ptr *args, struct type *type, int gcc_p)
@


1.14
log
@Tweeks from RDBrown to fix compiling on HP/UX using HP's compiler.
@
text
@d4597 4
a4600 1
   default_prepare_to_proceed() has been added.  */
@


1.13
log
@Phase 1 of the ptid_t changes.
@
text
@d4253 1
a4253 1
	     for the main image, or if something strange happened (??) */
@


1.12
log
@2001-04-06  David Smith  <dsmith@@redhat.com>

	* arch-utils.c (default_prepare_to_proceed)
	(generic_prepare_to_proceed): Added new functions.
	* arch-utils.h: New function declarations for
	default_prepare_to_proceed() and generic_prepare_to_proceed().
	* gdbarch.sh: Added PREPARE_TO_PROCEED.
	* gdbarch.c: Regenerated.
	* gdbarch.h: Regenerated.
	* inferior.h: Added get_last_target_status() declaration.
	* infrun.c (get_last_target_status): Added new function.
	(handle_inferior_event): Saves last pid and waitstatus, which will
	get returned by get_last_target_status().

	* hppa-tdep.c (prepare_to_proceed):  Added comment stating that
	prepare_to_proceed() is potentially redundant since
	default_prepare_to_proceed() has been added.
	* linux-thread.c (prepare_to_proceed): Ditto.
	* lin-lwp.c (prepare_to_proceed): Ditto.
	* m3-nat.c (prepare_to_proceed): Ditto.
@
text
@d1400 1
a1400 1
  pc = target_read_pc (inferior_pid);
d1634 1
a1634 1
      target_wait (inferior_pid, &w);
d2079 1
a2079 1
        target_wait (inferior_pid, &w);
d2081 1
a2081 1
        target_wait (inferior_pid, &w);
d2165 1
a2165 1
         /* If we are using the gcc PLT call routine, then we need to
d2373 1
a2373 1
  else if (som_solib_get_got_by_pc (target_read_pc (inferior_pid)))
d2407 1
a2407 1
target_read_pc (int pid)
d2409 1
a2409 1
  int flags = read_register_pid (FLAGS_REGNUM, pid);
d2415 1
a2415 1
    return read_register_pid (31, pid) & ~0x3;
d2417 1
a2417 1
  return read_register_pid (PC_REGNUM, pid) & ~0x3;
d2424 1
a2424 1
target_write_pc (CORE_ADDR v, int pid)
d2426 1
a2426 1
  int flags = read_register_pid (FLAGS_REGNUM, pid);
d2434 1
a2434 1
    write_register_pid (31, v | 0x3, pid);
d2436 2
a2437 2
  write_register_pid (PC_REGNUM, v, pid);
  write_register_pid (NPC_REGNUM, v + 4, pid);
d2648 1
a2648 1
      raw_val[i] = call_ptrace (PT_RUREGS, inferior_pid,
d4029 1
a4029 1
      /* Quit if we hit any kind of branch the previous iteration.
d4111 1
a4111 1
  store_unsigned_integer (buf, 4, inferior_pid);	/* FIXME 32x64? */
d4381 1
a4381 1
      if (inferior_pid > 0)
d4604 1
a4604 1
  old_thread = hppa_switched_threads (inferior_pid);
d4615 2
a4616 2
      current_thread = inferior_pid;
      inferior_pid = old_thread;
d4628 1
a4628 1
		  current_thread, inferior_pid);
d4635 1
a4635 1
      inferior_pid = current_thread;
@


1.11
log
@Eliminate some uses of __STDC__.
@
text
@d4594 4
a4597 1
   putting the BPT instruction in and taking it out. */
@


1.10
log
@Update/correct copyright notices.
@
text
@a4526 1
#ifdef __STDC__
a4527 3
#else
#define pif(FLD) if (u->FLD) printf_unfiltered (" FLD");
#endif
a4551 1
#ifdef __STDC__
a4552 3
#else
#define pin(FLD) printf_unfiltered ("\tFLD = 0x%x\n", u->FLD);
#endif
@


1.9
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1986, 1987, 1989-1996, 1999-2000, 2001 Free Software
   Foundation, Inc.
@


1.8
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright 1986, 1987, 1989-1996, 1999-2000 Free Software Foundation, Inc.
d30 1
@


1.7
log
@2000-08-10  Kazu Hirata  <kazu@@hxi.com>

	* hppa_tdep.c: Fix a comment typo.
@
text
@d297 1
a297 4
record_text_segment_lowaddr (abfd, section, ignored)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
     PTR ignored ATTRIBUTE_UNUSED;
@


1.6
log
@Protoization.
@
text
@d2903 1
a2903 1
    /* Find out where we we think we are within the stub.  */
@


1.5
log
@PARAMS removal.
@
text
@d153 1
a153 3
hppa_use_struct_convention (gcc_p, type)
     int gcc_p;
     struct type *type;
d166 1
a166 2
sign_extend (val, bits)
     unsigned val, bits;
d174 1
a174 2
low_sign_extend (val, bits)
     unsigned val, bits;
d182 1
a182 2
extract_5_load (word)
     unsigned word;
d190 1
a190 2
extract_5r_store (word)
     unsigned word;
d198 1
a198 2
extract_5R_store (word)
     unsigned word;
d206 1
a206 2
extract_14 (word)
     unsigned word;
d214 1
a214 3
deposit_14 (opnd, word)
     int opnd;
     unsigned word;
d224 1
a224 2
extract_21 (word)
     unsigned word;
d247 1
a247 2
deposit_21 (opnd, word)
     unsigned opnd, word;
d267 1
a267 2
extract_17 (word)
     unsigned word;
d281 1
a281 3
compare_unwind_entries (arg1, arg2)
     const void *arg1;
     const void *arg2;
d309 3
a311 6
internalize_unwinds (objfile, table, section, entries, size, text_offset)
     struct objfile *objfile;
     struct unwind_table_entry *table;
     asection *section;
     unsigned int entries, size;
     CORE_ADDR text_offset;
d403 1
a403 2
read_unwind_info (objfile)
     struct objfile *objfile;
d545 1
a545 2
find_unwind_entry (pc)
     CORE_ADDR pc;
d607 1
a607 2
hpread_adjust_stack_address (func_addr)
     CORE_ADDR func_addr;
d622 1
a622 2
pc_in_interrupt_handler (pc)
     CORE_ADDR pc;
d644 1
a644 2
pc_in_linker_stub (pc)
     CORE_ADDR pc;
d709 1
a709 2
find_return_regnum (pc)
     CORE_ADDR pc;
d726 1
a726 2
find_proc_framesize (pc)
     CORE_ADDR pc;
d761 1
a761 2
rp_saved (pc)
     CORE_ADDR pc;
d800 1
a800 2
frameless_function_invocation (frame)
     struct frame_info *frame;
d813 1
a813 2
saved_pc_after_call (frame)
     struct frame_info *frame;
d832 1
a832 2
hppa_frame_saved_pc (frame)
     struct frame_info *frame;
d1011 1
a1011 3
init_extra_frame_info (fromleaf, frame)
     int fromleaf;
     struct frame_info *frame;
d1068 1
a1068 2
frame_chain (frame)
     struct frame_info *frame;
d1324 1
a1324 3
hppa_frame_chain_valid (chain, thisframe)
     CORE_ADDR chain;
     struct frame_info *thisframe;
d1385 1
a1385 2
push_dummy_frame (inf_status)
     struct inferior_status *inf_status;
d1462 2
a1463 3
find_dummy_frame_regs (frame, frame_saved_regs)
     struct frame_info *frame;
     struct frame_saved_regs *frame_saved_regs;
d1503 1
a1503 1
hppa_pop_frame ()
d1601 1
a1601 2
restore_pc_queue (fsr)
     struct frame_saved_regs *fsr;
d1671 2
a1672 6
hppa_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     int struct_return;
     CORE_ADDR struct_addr;
d1790 2
a1791 6
hppa_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     int struct_return;
     CORE_ADDR struct_addr;
d1880 1
a1880 3
hppa_value_returned_from_stack (valtype, addr)
     register struct type *valtype;
     CORE_ADDR addr;
d1913 1
a1913 3
find_stub_with_shl_get (function, handle)
     struct minimal_symbol *function;
     CORE_ADDR handle;
d2012 2
a2013 8
hppa_fix_call_dummy (dummy, pc, fun, nargs, args, type, gcc_p)
     char *dummy;
     CORE_ADDR pc;
     CORE_ADDR fun;
     int nargs;
     value_ptr *args;
     struct type *type;
     int gcc_p;
d2389 1
a2389 2
target_read_fp (pid)
     int pid;
d2408 1
a2408 2
target_read_pc (pid)
     int pid;
d2425 1
a2425 3
target_write_pc (v, pid)
     CORE_ADDR v;
     int pid;
d2445 1
a2445 2
hppa_alignof (type)
     struct type *type;
d2479 1
a2479 3
pa_do_registers_info (regnum, fpregs)
     int regnum;
     int fpregs;
d2522 2
a2523 5
pa_do_strcat_registers_info (regnum, fpregs, stream, precision)
     int regnum;
     int fpregs;
     struct ui_file *stream;
     enum precision_type precision;
d2572 1
a2572 4
pa_register_look_aside (raw_regs, regnum, raw_val)
     char *raw_regs;
     int regnum;
     long *raw_val;
d2675 1
a2675 4
pa_print_registers (raw_regs, regnum, fpregs)
     char *raw_regs;
     int regnum;
     int fpregs;
d2727 2
a2728 5
pa_strcat_registers (raw_regs, regnum, fpregs, stream)
     char *raw_regs;
     int regnum;
     int fpregs;
     struct ui_file *stream;
d2775 1
a2775 2
pa_print_fp_reg (i)
     int i;
d2818 1
a2818 4
pa_strcat_fp_reg (i, stream, precision)
     int i;
     struct ui_file *stream;
     enum precision_type precision;
d2861 1
a2861 3
in_solib_call_trampoline (pc, name)
     CORE_ADDR pc;
     char *name;
d3021 1
a3021 3
in_solib_return_trampoline (pc, name)
     CORE_ADDR pc;
     char *name;
d3094 1
a3094 3
skip_trampoline_code (pc, name)
     CORE_ADDR pc;
     char *name;
d3369 1
a3369 2
prologue_inst_adjust_sp (inst)
     unsigned long inst;
d3408 1
a3408 2
is_branch (inst)
     unsigned long inst;
d3441 1
a3441 2
inst_saves_gr (inst)
     unsigned long inst;
d3480 1
a3480 2
inst_saves_fr (inst)
     unsigned long inst;
d3503 1
a3503 2
skip_prologue_hard_way (pc)
     CORE_ADDR pc;
d3735 1
a3735 2
after_prologue (pc)
     CORE_ADDR pc;
d3776 1
a3776 2
hppa_skip_prologue (pc)
     CORE_ADDR pc;
d3808 2
a3809 3
hppa_frame_find_saved_regs (frame_info, frame_saved_regs)
     struct frame_info *frame_info;
     struct frame_saved_regs *frame_saved_regs;
d4096 1
a4096 1
setup_d_pid_in_inferior ()
d4130 1
a4130 1
initialize_hp_cxx_exception_support ()
d4351 1
a4351 3
child_enable_exception_callback (kind, enable)
     enum exception_event_kind kind;
     int enable;
d4441 1
a4441 1
child_get_current_exception_event ()
d4500 1
a4500 3
unwind_command (exp, from_tty)
     char *exp;
     int from_tty;
d4605 1
a4605 1
hppa_prepare_to_proceed ()
d4650 1
a4650 1
hppa_skip_permanent_breakpoint ()
d4674 1
a4674 1
_initialize_hppa_tdep ()
@


1.4
log
@Cleanup delete_breakpoint cleanups.
@
text
@d65 1
a65 1
static int extract_5_load PARAMS ((unsigned int));
d67 1
a67 1
static unsigned extract_5R_store PARAMS ((unsigned int));
d69 1
a69 1
static unsigned extract_5r_store PARAMS ((unsigned int));
d71 2
a72 2
static void find_dummy_frame_regs PARAMS ((struct frame_info *,
					   struct frame_saved_regs *));
d74 1
a74 1
static int find_proc_framesize PARAMS ((CORE_ADDR));
d76 1
a76 1
static int find_return_regnum PARAMS ((CORE_ADDR));
d78 1
a78 1
struct unwind_table_entry *find_unwind_entry PARAMS ((CORE_ADDR));
d80 1
a80 1
static int extract_17 PARAMS ((unsigned int));
d82 1
a82 1
static unsigned deposit_21 PARAMS ((unsigned int, unsigned int));
d84 1
a84 1
static int extract_21 PARAMS ((unsigned));
d86 1
a86 1
static unsigned deposit_14 PARAMS ((int, unsigned int));
d88 1
a88 1
static int extract_14 PARAMS ((unsigned));
d90 1
a90 1
static void unwind_command PARAMS ((char *, int));
d92 1
a92 1
static int low_sign_extend PARAMS ((unsigned int, unsigned int));
d94 1
a94 1
static int sign_extend PARAMS ((unsigned int, unsigned int));
d96 1
a96 1
static int restore_pc_queue PARAMS ((struct frame_saved_regs *));
d98 1
a98 1
static int hppa_alignof PARAMS ((struct type *));
d101 1
a101 1
int hppa_prepare_to_proceed PARAMS (());
d103 1
a103 1
static int prologue_inst_adjust_sp PARAMS ((unsigned long));
d105 1
a105 1
static int is_branch PARAMS ((unsigned long));
d107 1
a107 1
static int inst_saves_gr PARAMS ((unsigned long));
d109 1
a109 1
static int inst_saves_fr PARAMS ((unsigned long));
d111 1
a111 1
static int pc_in_interrupt_handler PARAMS ((CORE_ADDR));
d113 1
a113 1
static int pc_in_linker_stub PARAMS ((CORE_ADDR));
d115 1
a115 1
static int compare_unwind_entries PARAMS ((const void *, const void *));
d117 1
a117 1
static void read_unwind_info PARAMS ((struct objfile *));
d119 5
a123 5
static void internalize_unwinds PARAMS ((struct objfile *,
					 struct unwind_table_entry *,
					 asection *, unsigned int,
					 unsigned int, CORE_ADDR));
static void pa_print_registers PARAMS ((char *, int, int));
d125 2
a126 2
static void pa_register_look_aside PARAMS ((char *, int, long *));
static void pa_print_fp_reg PARAMS ((int));
d128 1
a128 1
static void record_text_segment_lowaddr PARAMS ((bfd *, asection *, void *));
d149 1
a149 2
extern value_ptr
  find_function_in_inferior PARAMS ((char *));
d783 1
a783 1
static int rp_saved PARAMS ((CORE_ADDR));
@


1.3
log
@* gdbarch.sh (POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Two new
functions which architectures can redefine, defaulting to
generic_pointer_to_address and generic_address_to_pointer.
* findvar.c (extract_typed_address, store_typed_address,
generic_pointer_to_address, generic_address_to_pointer): New
functions.
(POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Provide default
definitions.
(extract_address, store_address): Doc fixes.
* values.c (value_as_pointer): Doc fix.
(value_from_pointer): New function.
* defs.h (extract_typed_address, store_typed_address): New
declarations.
* inferior.h (generic_address_to_pointer,
generic_pointer_to_address): New declarations.
* value.h (value_from_pointer): New declaration.

* ax-gdb.c (const_var_ref): Use value_from_pointer, not
value_from_longest.
* blockframe.c (generic_push_dummy_frame): Use read_pc and
read_sp, not read_register.
* c-valprint.c (c_val_print): Use extract_typed_address instead of
extract_address to extract vtable entries and references.
* cp-valprint.c (cp_print_value_fields): Use value_from_pointer
instead of value_from_longest to extract the vtable's address.
* eval.c (evaluate_subexp_standard): Use value_from_pointer
instead of value_from_longest to compute `this', and for doing
pointer-to-member dereferencing.
* findvar.c (read_register): Use extract_unsigned_integer, not
extract_address.
(read_var_value): Use store_typed_address instead of store_address
for building label values.
(locate_var_value): Use value_from_pointer instead of
value_from_longest.
* hppa-tdep.c (find_stub_with_shl_get): Use value_from_pointer,
instead of value_from_longest, to build arguments to __d_shl_get.
* printcmd.c (set_next_address): Use value_from_pointer, not
value_from_longest.
(x_command): Use value_from_pointer, not value_from_longest.
* tracepoint.c (set_traceframe_context): Use value_from_pointer,
not value_from_longest.
* valarith.c (value_add, value_sub): Use value_from_pointer, not
value_from_longest.
* valops.c (find_function_in_inferior, value_coerce_array,
value_coerce_function, value_addr, hand_function_call): Same.
* value.h (COERCE_REF): Use unpack_pointer, not unpack_long.
* values.c (unpack_long): Use extract_typed_address to produce
addresses from pointers and references, not extract_address.
(value_from_longest): Use store_typed_address instead of
store_address to produce pointer and reference values.
@
text
@d1621 1
a1621 1
      old_chain = make_cleanup ((make_cleanup_func) delete_breakpoint, breakpoint);
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d2008 2
a2009 2
  args[1] = value_from_longest (TYPE_FIELD_TYPE (ftype, 1), SYMBOL_VALUE_ADDRESS (msymbol));
  args[2] = value_from_longest (TYPE_FIELD_TYPE (ftype, 2), endo_buff_addr);
d2011 2
a2012 2
  args[4] = value_from_longest (TYPE_FIELD_TYPE (ftype, 4), value_return_addr);
  args[5] = value_from_longest (TYPE_FIELD_TYPE (ftype, 5), errno_return_addr);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 2
   Copyright 1986, 87, 89, 90, 91, 92, 93, 94, 95, 96, 1999
   Free Software Foundation, Inc.
d7 1
a7 1
This file is part of GDB.
d9 14
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d49 1
a49 1
/*#include <sys/user.h>		After a.out.h  */
d52 1
a52 1
#include "wait.h"
a59 3
/* To support asking "What CPU is this?" */
#include <unistd.h>

d64 1
a64 1
 
d124 1
a124 1
static void pa_strcat_registers PARAMS ((char *, int, int, GDB_FILE *));
d127 2
a128 1
static void pa_strcat_fp_reg PARAMS ((int, GDB_FILE *, enum precision_type));
d130 7
a136 4
typedef struct {
  struct minimal_symbol * msym;
  CORE_ADDR solib_handle;
} args_for_find_stub;
d138 1
a138 1
static CORE_ADDR cover_find_stub_with_shl_get PARAMS ((args_for_find_stub *));
d140 1
a140 1
static int is_pa_2 = 0;  /* False */
d142 1
a142 1
/* This is declared in symtab.c; set to 1 in hp-symtab-read.c */ 
d150 1
a150 1
find_function_in_inferior PARAMS((char *));
d158 1
a158 1
  return (TYPE_LENGTH (type) > 8);
d160 1
a161 1

d172 1
a172 1
  return (int)(val >> (bits - 1) ? (-1 << bits) | val : val);
d181 1
a181 1
  return (int)((val & 0x1 ? (-1 << (bits - 1)) : 0) | val >> 1);
a185 29
#if 0

unsigned
get_field (val, from, to)
     unsigned val, from, to;
{
  val = val >> 31 - to;
  return val & ((1 << 32 - from) - 1);
}

unsigned
set_field (val, from, to, new_val)
     unsigned *val, from, to;
{
  unsigned mask = ~((1 << (to - from + 1)) << (31 - from));
  return *val = *val & mask | (new_val << (31 - from));
}

/* extract a 3-bit space register number from a be, ble, mtsp or mfsp */

int
extract_3 (word)
     unsigned word;
{
  return GET_FIELD (word, 18, 18) << 2 | GET_FIELD (word, 16, 17);
}

#endif

a192 13
#if 0

/* extract the immediate field from a st{bhw}s instruction */

int
extract_5_store (word)
     unsigned word;
{
  return low_sign_extend (word & MASK_5, 5);
}

#endif	/* 0 */
       
a210 13
/* extract an 11 bit immediate field */

#if 0

int
extract_11 (word)
     unsigned word;
{
  return low_sign_extend (word & MASK_11, 11);
}

#endif

d229 1
a229 1
  return word | ((unsigned)opnd << 1 & MASK_14)  | sign;
a275 29
/* extract a 12 bit constant from branch instructions */

#if 0

int
extract_12 (word)
     unsigned word;
{
  return sign_extend (GET_FIELD (word, 19, 28) |
		      GET_FIELD (word, 29, 29) << 10 |
		      (word & 0x1) << 11, 12) << 2;
}

/* Deposit a 17 bit constant in an instruction (like bl). */

unsigned int
deposit_17 (opnd, word)
     unsigned opnd, word;
{
  word |= GET_FIELD (opnd, 15 + 0, 15 + 0); /* w */
  word |= GET_FIELD (opnd, 15 + 1, 15 + 5) << 16; /* w1 */
  word |= GET_FIELD (opnd, 15 + 6, 15 + 6) << 2; /* w2[10] */
  word |= GET_FIELD (opnd, 15 + 7, 15 + 16) << 3; /* w2[0..9] */

  return word;
}

#endif

d310 14
d340 20
d363 1
a363 1
	 endian issues.  */
d367 1
a367 1
					      (bfd_byte *)buf);
d370 1
a370 1
	  table[i].region_end = bfd_get_32 (objfile->obfd, (bfd_byte *)buf);
d373 1
a373 1
	  tmp = bfd_get_32 (objfile->obfd, (bfd_byte *)buf);
d399 1
a399 1
	  tmp = bfd_get_32 (objfile->obfd, (bfd_byte *)buf);
d408 1
a408 1
          /* Stub unwinds are handled elsewhere. */
d425 3
a427 3
  asection *unwind_sec, *elf_unwind_sec, *stub_unwind_sec;
  unsigned unwind_size, elf_unwind_size, stub_unwind_size, total_size;
  unsigned index, unwind_entries, elf_unwind_entries;
d434 2
a435 2
  ui = (struct obj_unwind_info *)obstack_alloc (&objfile->psymbol_obstack,
						sizeof (struct obj_unwind_info));
d441 17
a457 5
  /* Get hooks to all unwind sections.   Note there is no linker-stub unwind
     section in ELF at the moment.  */
  unwind_sec = bfd_get_section_by_name (objfile->obfd, "$UNWIND_START$");
  elf_unwind_sec = bfd_get_section_by_name (objfile->obfd, ".PARISC.unwind");
  stub_unwind_sec = bfd_get_section_by_name (objfile->obfd, "$UNWIND_END$");
d459 2
a460 10
  /* Get sizes and unwind counts for all sections.  */
  if (unwind_sec)
    {
      unwind_size = bfd_section_size (objfile->obfd, unwind_sec);
      unwind_entries = unwind_size / UNWIND_ENTRY_SIZE;
    }
  else
    {
      unwind_size = 0;
      unwind_entries = 0;
d463 3
a465 10
  if (elf_unwind_sec)
    {
      elf_unwind_size = bfd_section_size (objfile->obfd, elf_unwind_sec); /* purecov: deadcode */
      elf_unwind_entries = elf_unwind_size / UNWIND_ENTRY_SIZE; /* purecov: deadcode */
    }
  else
    {
      elf_unwind_size = 0;
      elf_unwind_entries = 0;
    }
d479 1
a479 1
  total_entries = unwind_entries + elf_unwind_entries + stub_entries;
d485 1
a485 1
   ui->last = total_entries - 1;
d487 2
a488 1
  /* Internalize the standard unwind entries.  */
d490 9
a498 6
  internalize_unwinds (objfile, &ui->table[index], unwind_sec,
		       unwind_entries, unwind_size, text_offset);
  index += unwind_entries;
  internalize_unwinds (objfile, &ui->table[index], elf_unwind_sec,
		       elf_unwind_entries, elf_unwind_size, text_offset);
  index += elf_unwind_entries;
d500 7
a506 1
  /* Now internalize the stub unwind entries.  */
d529 1
a529 1
                                                              (bfd_byte *) buf);
d532 2
a533 2
	    = ui->table[index].region_start + 4 * 
	      (bfd_get_16 (objfile->obfd, (bfd_byte *) buf) - 1);
d544 1
a544 1
  if(objfile->obj_private == NULL)
d547 2
a548 2
	obstack_alloc(&objfile->psymbol_obstack,
		      sizeof(obj_private_data_t));
d550 3
a552 2
      obj_private->so_info     = NULL;
      
d555 1
a555 1
  obj_private = (obj_private_data_t *)objfile->obj_private; 
d565 1
a565 1
find_unwind_entry(pc)
d576 5
a580 5
    {
      struct obj_unwind_info *ui;
      ui = NULL;
      if (objfile->obj_private)
	ui = ((obj_private_data_t *)(objfile->obj_private))->unwind_info;
d582 7
a588 7
      if (!ui)
	{
	  read_unwind_info (objfile);
	  if (objfile->obj_private == NULL)
	    error ("Internal error reading unwind information."); /* purecov: deadcode */
	  ui = ((obj_private_data_t *)(objfile->obj_private))->unwind_info;
	}
d590 1
a590 1
      /* First, check the cache */
d592 4
a595 4
      if (ui->cache
	  && pc >= ui->cache->region_start
	  && pc <= ui->cache->region_end)
	return ui->cache;
d597 1
a597 1
      /* Not in the cache, do a binary search */
d599 2
a600 2
      first = 0;
      last = ui->last;
d602 9
a610 9
      while (first <= last)
	{
	  middle = (first + last) / 2;
	  if (pc >= ui->table[middle].region_start
	      && pc <= ui->table[middle].region_end)
	    {
	      ui->cache = &ui->table[middle];
	      return &ui->table[middle];
	    }
d612 6
a617 6
	  if (pc < ui->table[middle].region_start)
	    last = middle - 1;
	  else
	    first = middle + 1;
	}
    }				/* ALL_OBJFILES() */
d662 3
a664 1
   appears that PC is in a linker stub.  */
d698 1
a698 1
	 return from a cross-space function call.  */
d705 1
a705 1
	 here.  */
d720 1
a720 1
	 return from a cross-space function call.  */
d727 1
a727 1
	 here.  */
d733 1
a733 1
find_return_regnum(pc)
d758 1
a758 1
  if (pc == (CORE_ADDR)0)
d760 1
a760 1
  
d808 1
a808 1
    return -20;
d850 1
a850 1
  
d867 2
a868 2
  int  spun_around_loop = 0;
  int  rp_offset = 0;
d875 23
a897 1
    return read_memory_integer (frame->frame + PC_REGNUM * 4, 4) & ~0x3;
d916 4
a919 4
	 handler caller, then we need to look in the saved
	 register area to get the return pointer (the values
	 in the registers may not correspond to anything useful).  */
      if (frame->next 
d926 2
a927 1
	  if (read_memory_integer (saved_regs.regs[FLAGS_REGNUM], 4) & 0x2)
d929 2
a930 1
	      pc = read_memory_integer (saved_regs.regs[31], 4) & ~0x3;
d933 3
a935 3
		 with a return pointer in %rp and the kernel call with
		 a return pointer in %r31.  We return the %rp variant
		 if %r31 is the same as frame->pc.  */
d937 2
a938 1
		pc = read_memory_integer (saved_regs.regs[RP_REGNUM], 4) & ~0x3;
d941 2
a942 1
	    pc = read_memory_integer (saved_regs.regs[RP_REGNUM], 4) & ~0x3;
d950 1
a950 1
      old_pc           = pc;
d952 1
a952 1
restart:
d956 2
a957 2
	 frame is a signal or interrupt handler, then dig the right
	 information out of the saved register info.  */
d966 2
a967 1
	  if (read_memory_integer (saved_regs.regs[FLAGS_REGNUM], 4) & 0x2)
d969 2
a970 1
	      pc = read_memory_integer (saved_regs.regs[31], 4) & ~0x3;
d973 3
a975 3
		 with a return pointer in %rp and the kernel call with
		 a return pointer in %r31.  We return the %rp variant
		 if %r31 is the same as frame->pc.  */
d977 2
a978 1
		pc = read_memory_integer (saved_regs.regs[RP_REGNUM], 4) & ~0x3;
d981 2
a982 1
	    pc = read_memory_integer (saved_regs.regs[RP_REGNUM], 4) & ~0x3;
d985 4
a988 4
        {
          old_pc = pc;
          pc = read_register (RP_REGNUM) & ~0x3;
        }
d990 5
a994 4
        {
          old_pc = pc;
          pc = read_memory_integer (frame->frame + rp_offset, 4) & ~0x3;
        }
d1009 3
a1011 3
	 then the call chain will eventually point us into the stub for
	 _sigreturn.  Unlike most cases, we'll be pointed to the branch
	 to the real sigreturn rather than the code after the real branch!. 
d1013 2
a1014 2
	 Else, try to dig the address the stub will return to in the normal
	 fashion.  */
d1020 11
a1030 11
        if (old_pc == pc)
            spun_around_loop++;
        
        if (spun_around_loop > 1) 
	  {
           /* We're just about to go around the loop again with
              no more hope of success.  Die. */
           error("Unable to find return pc for this frame");
	  }
        else
	  goto restart;
d1057 1
a1057 1
	 in the current frame structure (it isn't set yet).  */
d1061 3
a1063 3
	 use it, else subtract the size of this frame from the current
	 frame.  (we always want frame->frame to point at the lowest address
	 in the frame).  */
d1072 1
a1072 1
  if (flags & 2)	/* In system call? */
d1084 1
a1084 1
  framesize = find_proc_framesize(frame->pc);
d1108 7
a1114 1
  CORE_ADDR  caller_pc;
d1117 2
a1118 2
  struct symbol         *frame_symbol;
  char                  *frame_symbol_name;
d1123 2
a1124 2
  min_frame_symbol  = lookup_minimal_symbol_by_pc (frame->pc);
  frame_symbol      = find_pc_function(frame->pc);
d1126 1
a1126 1
  if ((min_frame_symbol != 0) /* && (frame_symbol == 0) */)
d1128 21
a1148 19
    /* The test above for "no user function name" would defend
       against the slim likelihood that a user might define a
       routine named "__pthread_exit" and then try to debug it.

       If it weren't commented out, and you tried to debug the
       pthread library itself, you'd get errors.
      
       So for today, we don't make that check. */
    frame_symbol_name = SYMBOL_NAME(min_frame_symbol);
    if (frame_symbol_name != 0) {
      if (0 == strncmp(frame_symbol_name,
		       THREAD_INITIAL_FRAME_SYMBOL,
		       THREAD_INITIAL_FRAME_SYM_LEN)) {
         /* Pretend we've reached the bottom of the stack. */
         return (CORE_ADDR) 0;
         }
       }  
    }  /* End of hacky code for threads. */
    
d1154 2
a1155 1
    frame_base = read_memory_integer (frame->frame + SP_REGNUM * 4, 4);
d1168 1
a1168 1
  caller_pc = FRAME_SAVED_PC(frame);
d1176 1
a1176 1
  caller_framesize = find_proc_framesize (FRAME_SAVED_PC(frame));
d1189 1
a1189 1
      return read_memory_integer (frame_base, 4);
d1207 1
a1207 2
  tmp_frame = frame;
  while (tmp_frame)
d1217 4
a1220 4
          /* ??rehrauer: Actually, it's quite possible to stepi your way into
             code that doesn't have unwind entries.  For example, stepping into
             the dynamic linker will give you a PC that has none.  Thus, I've
             disabled this warning. */
d1227 1
a1227 3
      /* Entry_GR specifies the number of callee-saved general registers
	 saved in the stack.  It starts at %r3, so %r3 would be 1.  */
      if (u->Entry_GR >= 1 || u->Save_SP
d1231 15
a1245 2
      else
	tmp_frame = tmp_frame->next;
d1251 1
a1251 1
	 pointer.  */
d1256 1
a1256 1
	  return read_memory_integer (tmp_frame->frame, 4);
d1259 1
a1259 1
      else 
a1260 2
	  struct frame_saved_regs saved_regs;

d1269 1
a1269 1
	      
d1272 5
a1276 5
	       * Attaching to a process when the process is in the
	       kernel performing a system call (debugger can't get
	       full register state for the inferior process since
	       the process wasn't being traced when it entered the
	       system call).
d1278 2
a1279 2
	       * Register state is not complete if the system call
	       causes the process to core dump.
d1287 2
a1288 1
	  get_frame_saved_regs (tmp_frame, &saved_regs);
d1293 2
a1294 1
	           && (read_memory_integer (saved_regs.regs[FLAGS_REGNUM], 4)
d1302 2
a1303 1
		  return read_memory_integer (saved_regs.regs[FP_REGNUM], 4);
d1310 3
a1312 2
	
	  return read_memory_integer (saved_regs.regs[FP_REGNUM], 4);
a1316 2
      struct frame_saved_regs saved_regs;

d1322 3
a1324 1
      get_frame_saved_regs (tmp_frame, &saved_regs);
d1328 2
a1329 1
	       && (read_memory_integer (saved_regs.regs[FLAGS_REGNUM], 4)
d1332 1
a1332 1
		  && read_register (FLAGS_REGNUM)  & 0x2)))
d1337 6
a1342 1
	      return read_memory_integer (saved_regs.regs[FP_REGNUM], 4);
a1343 4
	   else
	     {
	       return frame_base - (u->Total_frame_size << 3);
	     }
d1345 1
a1345 1
	
d1347 1
a1347 1
	 holds the value of the previous frame pointer).  */
d1351 1
a1352 1

d1425 1
a1425 1
  int int_buffer;
d1443 3
a1445 5
      memcpy (inf_status->registers, &int_buffer, 4);
      memcpy (inf_status->registers + REGISTER_BYTE (PCOQ_HEAD_REGNUM), &pc, 4);
      pc += 4;
      memcpy (inf_status->registers + REGISTER_BYTE (PCOQ_TAIL_REGNUM), &pc, 4);
      pc -= 4;
d1451 2
a1452 4
      memcpy (inf_status->registers + REGISTER_BYTE (PCSQ_HEAD_REGNUM),
	      &pcspace, 4);
      memcpy (inf_status->registers + REGISTER_BYTE (PCSQ_TAIL_REGNUM),
	      &pcspace, 4);
d1460 7
a1466 1
  write_memory (sp - 20, (char *)&int_buffer, 4);
d1469 1
a1469 1
  write_memory (sp, (char *)&int_buffer, 4);
d1473 1
a1473 1
  sp += 8;
d1479 3
a1481 1
  sp += 4;
d1485 2
a1486 2
      read_register_bytes (REGISTER_BYTE (regnum), (char *)&freg_buffer, 8);
      sp = push_bytes (sp, (char *)&freg_buffer, 8);
d1505 6
a1510 1
  frame_saved_regs->regs[RP_REGNUM] = (fp - 20) & ~0x3;
a1511 1
  frame_saved_regs->regs[1] = fp + 8;
d1513 3
a1515 1
  for (fp += 12, i = 3; i < 32; i++)
d1520 1
a1520 1
	  fp += 4;
d1524 4
a1527 1
  fp += 4;
d1532 5
a1536 5
  frame_saved_regs->regs[SAR_REGNUM] = fp + 4;
  frame_saved_regs->regs[PCOQ_HEAD_REGNUM] = fp + 8;
  frame_saved_regs->regs[PCSQ_HEAD_REGNUM] = fp + 12;
  frame_saved_regs->regs[PCOQ_TAIL_REGNUM] = fp + 16;
  frame_saved_regs->regs[PCSQ_TAIL_REGNUM] = fp + 20;
d1552 1
a1552 1
  if (fsr.regs[IPSW_REGNUM])    /* Restoring a call dummy frame */
d1558 2
a1559 1
      write_register (regnum, read_memory_integer (fsr.regs[regnum], 4));
d1561 1
a1561 1
  for (regnum = NUM_REGS - 1; regnum >= FP0_REGNUM ; regnum--)
d1564 2
a1565 2
	read_memory (fsr.regs[regnum], (char *)&freg_buffer, 8);
        write_register_bytes (REGISTER_BYTE (regnum), (char *)&freg_buffer, 8);
d1570 2
a1571 1
                    read_memory_integer (fsr.regs[IPSW_REGNUM], 4));
d1575 2
a1576 1
                    read_memory_integer (fsr.regs[SAR_REGNUM], 4));
d1581 2
a1582 1
      npc = read_memory_integer (fsr.regs[PCOQ_TAIL_REGNUM], 4);
d1586 1
a1586 1
  else 
d1592 1
a1592 1
  write_register (FP_REGNUM, read_memory_integer (fp, 4));
d1594 1
a1594 1
  if (fsr.regs[IPSW_REGNUM])    /* call dummy */
d1614 1
a1614 1
	 for "return_command" will print the frame we returned to.  */
d1642 2
a1643 1
  CORE_ADDR new_pc = read_memory_integer (fsr->regs[PCOQ_HEAD_REGNUM], 4);
d1655 3
a1657 3
        mtsp r21, sr0
        ble,n 0(sr0, r22)
    
d1661 2
a1662 1
  write_register (21, read_memory_integer (fsr->regs[PCSQ_HEAD_REGNUM], 4));
d1668 4
a1671 4
	 merge this into wait_for_inferior (as a special kind of
	 watchpoint?  By setting a breakpoint at the end?  Is there
	 any other choice?  Is there *any* way to do this stuff with
	 ptrace() or some equivalent?).  */
d1676 4
a1679 4
        {
          stop_signal = w.value.sig;
          terminal_ours_for_output ();
          printf_unfiltered ("\nProgram terminated with signal %s, %s.\n",
d1682 3
a1684 3
          gdb_flush (gdb_stdout);
          return 0;
        }
d1691 17
a1707 1
#if 0
d1717 21
a1737 4
  int *offset = (int *)alloca(nargs * sizeof (int));
  int cum = 0;
  int i, alignment;
  
d1740 14
a1753 4
      int x = 0;
      /* cum is the sum of the lengths in bytes of
	 the arguments seen so far */
      cum += TYPE_LENGTH (VALUE_TYPE (args[i]));
d1755 1
a1755 3
    /* value must go at proper alignment. Assume alignment is a
	 power of two. */
      alignment = hppa_alignof (VALUE_TYPE (args[i]));
d1757 21
a1777 3
      if (cum % alignment)
	cum = (cum + alignment) & -alignment;
      offset[i] = -cum;
d1779 1
a1780 1
  sp += max ((cum + 7) & -8, 16);
d1782 10
d1793 1
a1793 2
    write_memory (sp + offset[i], VALUE_CONTENTS (args[i]),
		  TYPE_LENGTH (VALUE_TYPE (args[i])));
d1795 2
d1799 17
a1815 1
  return sp + 32;
a1816 1
#endif
d1818 1
a1818 13
/* elz: I am rewriting this function, because the one above is a very 
   obscure piece of code.
   This function pushes the arguments on the stack. The stack grows up
   on the PA. 
   Each argument goes in one (or more) word (4 bytes) on the stack.
   The first four words for the args must be allocated, even if they 
   are not used. 
   The 'topmost' arg is arg0, the 'bottom-most' is arg3. (if you think of 
   them as 1 word long).
   Below these there can be any number of arguments, as needed by the function.
   If an arg is bigger than one word, it will be written on the stack 
   occupying as many words as needed. Args that are bigger than 64bits
   are not copied on the stack, a pointer is passed instead.
d1820 2
a1821 2
   On top of the arg0 word there are other 8 words (32bytes) which are used
   for other purposes */
d1823 8
d1840 17
a1856 25
  int *offset = (int *)alloca(nargs * sizeof (int));
  /* array of arguments' lengths: real lengths in bytes, not aligned to word size */
  int *lengths = (int *)alloca(nargs * sizeof (int));

  int bytes_reserved; /* this is the number of bytes on the stack occupied by an
                         argument. This will be always a multiple of 4 */

  int cum_bytes_reserved = 0; /* this is the total number of bytes reserved by the args
                                 seen so far. It is a multiple of 4 always */
  int cum_bytes_aligned = 0; /* same as above, but aligned on 8 bytes */
  int i; 

  /* When an arg does not occupy a whole word, for instance in bitfields:
     if the arg is x bits (0<x<32), it must be written
     starting from the (x-1)-th position  down until the 0-th position. 
     It is enough to align it to the word. */ 
  /* if an arg occupies 8 bytes, it must be aligned on the 64-bits 
     high order word in odd arg word. */
  /* if an arg is larger than 64 bits, we need to pass a pointer to it, and
     copy the actual value on the stack, so that the callee can play with it.
     This is taken care of in valops.c in the call_function_by_hand function.
     The argument that is received in this function here has already be converted
     to a pointer to whatever is needed, so that it just can be pushed
     as a word argument */
  
a1858 1

d1861 3
a1863 4
      if (lengths[i] % 4)
        bytes_reserved = (lengths[i] / 4) * 4 + 4;
      else 
        bytes_reserved = lengths[i];
d1867 20
a1886 17
      if ((bytes_reserved == 8) && (offset[i] % 8)) /* if 64-bit arg is not 64 bit aligned */
      {
        int new_offset=0;
        /* bytes_reserved is already aligned to the word, so we put it at one word
           more down the stack. This will leave one empty word on the
           stack, and one unused register. This is OK, see the calling
           convention doc */
        /* the offset may have to be moved to the corresponding position
           one word down the stack, to maintain 
           alignment. */
        new_offset = (offset[i] / 8) * 8 + 8;
        if ((new_offset - offset[i]) >=4) 
        {
         bytes_reserved += 4;
         offset[i] += 4;
        }
      }
d1892 6
a1897 3
  /* now move up the sp to reserve at least 4 words required for the args,
     or more than this if needed */
  /* wee also need to keep the sp aligned to 8 bytes */
d1899 1
a1899 1
  sp += max (cum_bytes_aligned, 16);
d1901 3
a1903 1
  /* now write each of the args at the proper offset down the stack */
a1905 1
		  
d1907 2
a1908 1
 /* if a structure has to be returned, set up register 28 to hold its address */
d1912 1
a1912 1
 /* the stack will have other 8 words on top of the args */
d1916 1
d1926 1
a1926 1
hppa_value_returned_from_stack (valtype , addr)
d1934 1
a1934 1
  target_read_memory(addr, VALUE_CONTENTS_RAW (val), TYPE_LENGTH (valtype));
d1942 17
a1958 17
 This function calls shl_findsym, indirectly through a
 call to __d_shl_get. __d_shl_get is in end.c, which is always
 linked in by the hp compilers/linkers. 
 The call to shl_findsym cannot be made directly because it needs
 to be active in target address space. 
 inputs: - minimal symbol pointer for the function we want to look up
         - address in target space of the descriptor for the library
           where we want to look the symbol up.
           This address is retrieved using the 
           som_solib_get_solib_by_pc function (somsolib.c). 
 output: - real address in the library of the function.          
 note: the handle can be null, in which case shl_findsym will look for
       the symbol in all the loaded shared libraries.
 files to look at if you need reference on this stuff:
 dld.c, dld_shl_findsym.c
 end.c
 man entry for shl_findsym */        
d1961 38
a1998 29
find_stub_with_shl_get(function, handle) 
  struct minimal_symbol *function;
  CORE_ADDR handle;
{
 struct symbol *get_sym, *symbol2;
 struct minimal_symbol *buff_minsym, *msymbol;
 struct type *ftype;
 value_ptr *args;
 value_ptr funcval, val;

 int x, namelen, err_value, tmp = -1;
 CORE_ADDR endo_buff_addr, value_return_addr, errno_return_addr;
 CORE_ADDR stub_addr;


    args           = (value_ptr *) alloca (sizeof (value_ptr) * 8);  /* 6 for the arguments and one null one??? */
    funcval        = find_function_in_inferior("__d_shl_get");
    get_sym        = lookup_symbol("__d_shl_get", NULL, VAR_NAMESPACE, NULL, NULL);
    buff_minsym    = lookup_minimal_symbol("__buffer", NULL, NULL);
    msymbol        = lookup_minimal_symbol ("__shldp", NULL, NULL);
    symbol2 = lookup_symbol("__shldp", NULL, VAR_NAMESPACE, NULL, NULL);
    endo_buff_addr = SYMBOL_VALUE_ADDRESS (buff_minsym);
    namelen        = strlen(SYMBOL_NAME(function));
    value_return_addr = endo_buff_addr + namelen;
    ftype          = check_typedef(SYMBOL_TYPE(get_sym));

    /* do alignment */
    if ((x=value_return_addr % 64) !=0)
       value_return_addr = value_return_addr + 64 - x;
d2000 1
a2000 1
    errno_return_addr = value_return_addr + 64;
d2002 2
a2003 2
    
    /* set up stuff needed by __d_shl_get in buffer in end.o */
d2005 1
a2005 5
    target_write_memory(endo_buff_addr, SYMBOL_NAME(function), namelen);
    
    target_write_memory(value_return_addr, (char *) &tmp, 4);
    
    target_write_memory(errno_return_addr, (char *) &tmp, 4);
d2007 6
a2012 4
    target_write_memory(SYMBOL_VALUE_ADDRESS(msymbol), 
                        (char *)&handle, 4);
    
    /* now prepare the arguments for the call */
d2014 1
a2014 6
    args[0] = value_from_longest (TYPE_FIELD_TYPE(ftype, 0), 12);
    args[1] = value_from_longest (TYPE_FIELD_TYPE(ftype, 1), SYMBOL_VALUE_ADDRESS(msymbol));
    args[2] = value_from_longest (TYPE_FIELD_TYPE(ftype, 2), endo_buff_addr);
    args[3] = value_from_longest (TYPE_FIELD_TYPE(ftype, 3), TYPE_PROCEDURE);
    args[4] = value_from_longest (TYPE_FIELD_TYPE(ftype, 4), value_return_addr);
    args[5] = value_from_longest (TYPE_FIELD_TYPE(ftype, 5), errno_return_addr);
d2016 1
a2016 1
    /* now call the function */
d2018 1
a2018 1
    val = call_function_by_hand(funcval, 6, args);
d2020 1
a2020 1
    /* now get the results */
d2022 3
a2024 1
    target_read_memory(errno_return_addr, (char *) &err_value, sizeof(err_value));
d2026 1
a2026 5
    target_read_memory(value_return_addr, (char *) &stub_addr, sizeof(stub_addr));
    if (stub_addr <= 0)
        error("call to __d_shl_get failed, error code is %d", err_value); /* purecov: deadcode */
    
    return(stub_addr);
d2029 3
a2031 4
/* Cover routine for find_stub_with_shl_get to pass to catch_errors */ 
static CORE_ADDR
cover_find_stub_with_shl_get (args)
  args_for_find_stub * args;
d2033 3
a2035 1
  return find_stub_with_shl_get (args->msym, args->solib_handle);
a2037 1

d2044 16
a2059 1
   inferior to do the function call. */
d2075 108
a2182 3
  struct unwind_table_entry *u;
  CORE_ADDR new_stub=0;
  CORE_ADDR solib_handle=0;
d2184 3
d2188 3
d2193 1
a2193 1
    error ("Can't find an address for $$dyncall trampoline"); /* purecov: deadcode */
d2198 3
a2200 2
     its real address and the value of its GOT/DP.  */
  if (fun & 0x2)
d2203 4
a2206 3
	 at *(fun+4).  Note the call dummy is *NOT* allowed to
	 trash %r19 before calling the target function.  */
      write_register (19, read_memory_integer ((fun & ~0x3) + 4, 4));
d2209 3
a2211 2
	 at *fun.  */
      fun = (CORE_ADDR) read_memory_integer (fun & ~0x3, 4);
d2217 8
a2224 14
      /* FUN could be either an export stub, or the real address of a
	 function in a shared library.  We must call an import stub
	 rather than the export stub or real function for lazy binding
	 to work correctly.  */

      /* elz: let's see if fun is in a shared library */
      solib_handle = som_solib_get_solib_by_pc(fun);

      /* elz: for 10.30 and 11.00 the calls via __d_plt_call cannot be made
	 via import stubs, only via plables, so this code here becomes useless.
	 On 10.20, the plables mechanism works too, so we just ignore this import 
	 stub stuff */
#if 0
      if (solib_handle)
d2232 1
a2232 1
	    error ("Unable to find minimal symbol for target fucntion.\n");
d2237 6
a2242 1
	    {
d2245 45
a2289 18
	      /* Found a symbol with the right name.  */
	      if (stub_symbol)
		{
		  struct unwind_table_entry *u;
		  /* It must be a shared library trampoline.  */
		  if (MSYMBOL_TYPE (stub_symbol) != mst_solib_trampoline)
		    continue;

		  /* It must also be an import stub.  */
		  u = find_unwind_entry (SYMBOL_VALUE (stub_symbol));
		  if (!u || u->stub_unwind.stub_type != IMPORT)
		    continue;

		  /* OK.  Looks like the correct import stub.  */
		  newfun = SYMBOL_VALUE (stub_symbol);
		  fun = newfun;
		}
	    }
d2292 11
a2303 1
#endif /* end of if 0 */
d2307 11
a2317 28
  /* If we are calling an import stub (eg calling into a dynamic library)
     then have sr4export call the magic __d_plt_call routine which is linked
     in from end.o.  (You can't use _sr4export to call the import stub as
     the value in sp-24 will get fried and you end up returning to the
     wrong location.  You can't call the import stub directly as the code
     to bind the PLT entry to a function can't return to a stack address.)  */

  /* elz:
     There does not have to be an import stub to call a routine in a
     different load module (note: a "load module" is an a.out or a shared
     library).  If you call a routine indirectly, going through $$dyncall (or
     $$dyncall_external), you won't go through an import stub.  Import stubs
     are only used for direct calls to an imported routine.

     What you (wdb) need is to go through $$dyncall with a proper plabel for
     the imported routine.  shl_findsym() returns you the address of a plabel
     suitable for use in making an indirect call through, e.g., through
     $$dyncall.
     This is taken care below with the call to find_stub_.... */
#if 0
  /* elz: this check here is not necessary if we are going to call stuff through
     plabels only, we just now check whether the function we call is in a shlib */
  u = find_unwind_entry (fun);

  if (u && u->stub_unwind.stub_type == IMPORT || 
      (!(u && u->stub_unwind.stub_type == IMPORT) && solib_handle))
#endif /* 0 */
  if (solib_handle)
d2321 24
a2344 31
      /* Prefer __gcc_plt_call over the HP supplied routine because
	 __gcc_plt_call works for any number of arguments.  */
      trampoline = lookup_minimal_symbol ("__gcc_plt_call", NULL, NULL);
      if (trampoline == NULL)
	trampoline = lookup_minimal_symbol ("__d_plt_call", NULL, NULL);

      if (trampoline == NULL)
	{
	  error ("Can't find an address for __d_plt_call or __gcc_plt_call trampoline\nSuggest linking executable with -g (links in /opt/langtools/lib/end.o)");
	}
      /* This is where sr4export will jump to.  */
      new_fun = SYMBOL_VALUE_ADDRESS (trampoline);

      if (strcmp (SYMBOL_NAME (trampoline), "__d_plt_call") == 0)
	{
          /* if the function is in a shared library, but we have no import sub for 
             it, we need to get the plabel from a call to __d_shl_get, which is a 
             function in end.o. To call this function we need to set up various things */
	  
	  /* actually now we just use the plabel any time we make the call,
	     because on 10.30 and 11.00 this is the only acceptable way. This also
	     works fine for 10.20 */
	  /* if (!(u && u->stub_unwind.stub_type == IMPORT) && solib_handle) */
            {
              struct minimal_symbol *fmsymbol = lookup_minimal_symbol_by_pc(fun);
              
              new_stub = find_stub_with_shl_get(fmsymbol, solib_handle);

              if (new_stub == NULL) 
                error("Can't find an import stub for %s", SYMBOL_NAME(fmsymbol)); /* purecov: deadcode */
            }
d2347 7
a2353 10
	    msymbol = lookup_minimal_symbol ("__shlib_funcptr", NULL,
					     (struct objfile *)NULL);
	    if (msymbol == NULL)
	      error ("Can't find an address for __shlib_funcptr"); /* purecov: deadcode */

         /* if (new_stub != NULL) */
	     target_write_memory (SYMBOL_VALUE_ADDRESS (msymbol), (char *)&new_stub, 4);
         /* this is no longer used */
         /* else
	     target_write_memory (SYMBOL_VALUE_ADDRESS (msymbol), (char *)&fun, 4); */
d2357 2
a2358 2
	    fun = new_fun;
	    trampoline = NULL;
d2390 1
a2390 1
	  error ("Can't find an address for _sr4export trampoline"); /* purecov: deadcode */
d2435 1
a2435 1

d2446 1
a2446 1
  int  pid;
d2450 4
a2453 3
  if (flags & 2) {
    return (CORE_ADDR) 0;
  }
d2525 1
a2525 1
	  if (!TYPE_FIELD_BITSIZE (type, i)) /* elz: this should be bitsize */
d2544 1
a2544 1
  char raw_regs [REGISTER_BYTES];
d2554 12
a2565 14
  else if (regnum < FP4_REGNUM) {
    long reg_val[2];
      
    /* Why is the value not passed through "extract_signed_integer"
       as in "pa_print_registers" below? */
    pa_register_look_aside(raw_regs, regnum, &reg_val[0]);

    if(!is_pa_2) {
      printf_unfiltered ("%s %x\n", REGISTER_NAME (regnum), reg_val[1]);
    }
    else {
      /* Fancy % formats to prevent leading zeros. */
      if(reg_val[0] == 0)
	printf_unfiltered("%s %x\n", REGISTER_NAME (regnum), reg_val[1]);
d2567 8
a2574 2
	printf_unfiltered("%s %x%8.8x\n", REGISTER_NAME (regnum),
			   reg_val[0], reg_val[1]);        
a2575 1
  }
d2577 3
a2579 3
      /* Note that real floating point values only start at
         FP4_REGNUM.  FP0 and up are just status and error
         registers, which have integral (bit) values. */
d2588 1
a2588 1
     GDB_FILE *stream;
d2591 1
a2591 1
  char raw_regs [REGISTER_BYTES];
d2595 1
a2595 1
     reads from the target). */  
d2602 12
a2613 15
  else if (regnum < FP4_REGNUM) {
    long reg_val[2];
      
    /* Why is the value not passed through "extract_signed_integer"
       as in "pa_print_registers" below? */
    pa_register_look_aside(raw_regs, regnum, &reg_val[0]);

    if(!is_pa_2) {
      fprintf_unfiltered (stream, "%s %x", REGISTER_NAME (regnum), reg_val[1]);
    }
    else {
      /* Fancy % formats to prevent leading zeros. */
      if(reg_val[0] == 0)
	fprintf_unfiltered(stream, "%s %x", REGISTER_NAME (regnum),
			   reg_val[1]);
d2615 9
a2623 2
	fprintf_unfiltered(stream, "%s %x%8.8x", REGISTER_NAME (regnum),
			   reg_val[0], reg_val[1]);        
a2624 1
  }
d2626 3
a2628 3
      /* Note that real floating point values only start at
         FP4_REGNUM.  FP0 and up are just status and error
         registers, which have integral (bit) values. */
d2638 1
a2638 1
pa_register_look_aside(raw_regs, regnum, raw_val)
d2640 1
a2640 1
     int   regnum;
d2643 1
a2643 1
  static int know_which = 0;  /* False */
d2645 1
a2645 1
  int          regaddr;
d2648 3
a2650 3
  int          start;
  
  
d2654 9
a2662 7
  if(!know_which) {
     if(CPU_PA_RISC2_0 == sysconf(_SC_CPU_VERSION)) {
        is_pa_2 = (1==1);
     }
     
     know_which = 1;  /* True */
  }
d2667 3
a2669 2
  if(!is_pa_2) {
      raw_val[1] = *(long *)(raw_regs + REGISTER_BYTE(regnum));
d2671 1
a2671 1
  }
d2676 2
a2677 1
      !HAVE_STRUCT_SAVE_STATE_T || !HAVE_STRUCT_MEMBER_SS_WIDE) {
d2679 6
a2684 5
      offset  = U_REGS_OFFSET;
      regaddr = register_addr(regnum, offset);
      start   = 1;
  }
  else {
d2690 1
a2690 1
            offset  = offsetof(save_state_t, ss_wide);
d2696 7
d2711 1
a2711 1
      start   = 0;
d2713 3
a2715 3
  }
   
  for(i = start; i < 2; i++)
d2719 1
a2719 1
  	 	                (PTRACE_ARG3_TYPE) regaddr, 0);
d2733 1
a2733 1
    
d2735 1
a2735 1
    raw_val[1] &= ~0x3; /* I think we're masking out space bits */
d2742 1
a2742 1
                                                    
d2749 3
a2751 2
  int i,j;
  long raw_val[2];   /* Alas, we are compiled so that "long long" is 32 bits */
d2753 1
d2755 1
a2755 1
  for (i = 0; i < 18; i++)
d2757 1
a2757 1
      for (j = 0; j < 4; j++)
d2759 29
a2787 23
          /* Q: Why is the value passed through "extract_signed_integer",
	        while above, in "pa_do_registers_info" it isn't?
             A: ? */
	  pa_register_look_aside(raw_regs, i+(j*18), &raw_val[0]);

          /* Even fancier % formats to prevent leading zeros
             and still maintain the output in columns. */
          if(!is_pa_2) {
              /* Being big-endian, on this machine the low bits
                 (the ones we want to look at) are in the second longword. */
   	      long_val = extract_signed_integer (&raw_val[1], 4);
  	      printf_filtered ("%8.8s: %8x  ",
			       REGISTER_NAME (i+(j*18)), long_val);
	  }
          else {
   	      /* raw_val = extract_signed_integer(&raw_val, 8); */
              if(raw_val[0] == 0)
  	          printf_filtered("%8.8s:         %8x  ",
				  REGISTER_NAME (i+(j*18)), raw_val[1]);
              else
  	          printf_filtered("%8.8s: %8x%8.8x  ", REGISTER_NAME (i+(j*18)),
				  raw_val[0], raw_val[1]);
          }
d2791 1
a2791 1
  
d2793 1
a2793 1
  for (i = FP4_REGNUM; i < NUM_REGS; i++)  /* FP4_REGNUM == 72 */
d2797 1
a2797 1
/************* new function ******************/                                                    
d2803 1
a2803 1
     GDB_FILE *stream;
d2805 2
a2806 2
  int i,j;
  long raw_val[2];   /* Alas, we are compiled so that "long long" is 32 bits */
d2816 24
a2839 22
          /* Q: Why is the value passed through "extract_signed_integer",
                while above, in "pa_do_registers_info" it isn't?
             A: ? */
	  pa_register_look_aside(raw_regs, i+(j*18), &raw_val[0]);

          /* Even fancier % formats to prevent leading zeros
             and still maintain the output in columns. */
          if(!is_pa_2) {
              /* Being big-endian, on this machine the low bits
                 (the ones we want to look at) are in the second longword. */
   	      long_val = extract_signed_integer(&raw_val[1], 4);
  	      fprintf_filtered (stream, "%8.8s: %8x  ", REGISTER_NAME (i+(j*18)), long_val);
	  }
          else {
   	      /* raw_val = extract_signed_integer(&raw_val, 8); */
              if(raw_val[0] == 0)
  	          fprintf_filtered(stream, "%8.8s:         %8x  ", REGISTER_NAME (i+(j*18)),
                                   raw_val[1]);
              else
  	          fprintf_filtered(stream, "%8.8s: %8x%8.8x  ", REGISTER_NAME (i+(j*18)),
                                    raw_val[0], raw_val[1]);
          }
d2843 1
a2843 1
  
d2845 1
a2845 1
  for (i = FP4_REGNUM; i < NUM_REGS; i++)  /* FP4_REGNUM == 72 */
d2896 1
a2896 1
     GDB_FILE *stream;
d2914 10
a2923 10
    char raw_buf[MAX_REGISTER_RAW_SIZE];
 
    /* Get the data in raw format for the 2nd half.  */
    read_relative_register_raw_bytes (i + 1, raw_buf);
 
    /* Copy it into the appropriate part of the virtual buffer.  */
    memcpy (virtual_buffer + REGISTER_RAW_SIZE(i), raw_buf, REGISTER_RAW_SIZE (i));

    val_print (builtin_type_double, virtual_buffer, 0, 0 , stream, 0, 
               1, 0, Val_pretty_default);
d2926 5
a2930 4
  else { 
    val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0, stream, 0,
	       1, 0, Val_pretty_default);
  }
d2949 67
a3015 2
/* FIXME XXX - dyncall and sr4export must be initialized whenever we get a
   new exec file */
d3039 4
d3071 1
a3071 1
	 or the end of the stub.  */
d3088 2
a3089 2
      warning ("Unable to find branch in parameter relocation stub.\n"); /* purecov: deadcode */
      return 0; /* purecov: deadcode */
d3093 1
a3093 1
  return 0; /* purecov: deadcode */
d3133 1
a3133 1
	 or the end of the stub.  */
d3150 2
a3151 2
      warning ("Unable to find branch in parameter relocation stub.\n"); /* purecov: deadcode */
      return 0; /* purecov: deadcode */
d3155 1
a3155 1
  return 0; /* purecov: deadcode */
a3175 11
# if 0
CORE_ADDR
skip_trampoline_code (pc, name)
     CORE_ADDR pc;
     char *name;
{
  return find_solib_trampoline_target(pc);
}

#endif

d3189 2
a3190 3

/* FIXME XXX - dyncall and sr4export must be initialized whenever we get a
   new exec file */
d3226 2
a3227 2
	 the PLT entry for this function, not the address of the function
	 itself.  Bit 31 has meaning too, but only for MPE.  */
d3229 1
a3229 1
	pc = (CORE_ADDR) read_memory_integer (pc & ~0x3, 4);
d3234 1
a3234 1
      pc = (CORE_ADDR) read_memory_integer (pc & ~0x3, 4);
d3261 1
a3261 1
     Hopefully this is correct most of the times. */ 
d3263 1
a3263 1
  {
d3268 25
a3292 1
    msym = lookup_minimal_symbol_by_pc (pc);
d3294 14
a3307 2
    if (msym == NULL || MSYMBOL_TYPE (msym) != mst_solib_trampoline)
      return orig_pc == pc ? 0 : pc & ~0x3;
a3308 36
    else if (msym != NULL && MSYMBOL_TYPE (msym) == mst_solib_trampoline)
         {
          struct objfile *objfile;
          struct minimal_symbol *msymbol;
          int function_found = 0;

             /* go look if there is another minimal symbol with the same name as 
                this one, but with type mst_text. This would happen if the msym
                is an actual trampoline, in which case there would be another
                symbol with the same name corresponding to the real function */

             ALL_MSYMBOLS (objfile, msymbol)
             {
               if (MSYMBOL_TYPE (msymbol) == mst_text
                    && STREQ (SYMBOL_NAME (msymbol) , SYMBOL_NAME (msym)))
                 {
                  function_found = 1;
                  break;
                 }
             }

            if (function_found)  
                   /* the type of msym is correct (mst_solib_trampoline), but
                      the unwind info is wrong, so set it to the correct value */
                u->stub_unwind.stub_type = EXPORT;
            else
                   /* the stub type info in the unwind is correct (this is not a
                      trampoline), but the msym type information is wrong, it
                      should be mst_text. So we need to fix the msym, and also
                      get out of this function */
              {
                  MSYMBOL_TYPE (msym) = mst_text;
                  return orig_pc == pc ? 0 : pc & ~0x3;
              }
         }
               
d3310 1
a3310 1
  }
d3333 1
a3333 1
	 branch from the stub to the actual function.  */
d3352 1
a3352 1
	 import stub to an export stub.
d3354 14
a3367 14
	 It is impossible to determine the target of the branch via
	 simple examination of instructions and/or data (consider
	 that the address in the plabel may be the address of the
	 bind-on-reference routine in the dynamic loader).

	 So we have try an alternative approach.

	 Get the name of the symbol at our current location; it should
	 be a stub symbol with the same name as the symbol in the
	 shared library.

	 Then lookup a minimal symbol with the same name; we should
	 get the minimal symbol for the target routine in the shared
	 library as those take precedence of import/export stubs.  */
d3369 3
a3371 3
          (curr_inst == 0xe2a00002) ||
          (curr_inst == 0xeaa0d000) ||
          (curr_inst == 0xeaa0d002))
d3394 2
a3395 2
	 branch from the stub to the actual function.  */
      /*elz*/
d3398 1
a3398 1
               || (curr_inst & 0xffe0e000) == 0xe800A000)
d3402 4
a3405 4
	 current stack pointer being the same as the stack
	 pointer in the stub itself!  This is a branch on from the
	 stub back to the original caller.  */
      /*else if ((curr_inst & 0xffe0e000) == 0xe840c000)*/
d3425 2
a3426 2
	  return (read_memory_integer 
		  (read_register (SP_REGNUM) - 24, 4)) & ~0x3;
d3430 1
a3430 1
	 the original caller from the stub.  Used in dynamic executables.  */
d3437 2
a3438 2
	  return (read_memory_integer 
		  (read_register (SP_REGNUM) - 24, 4)) & ~0x3;
d3442 1
a3442 1
	 Keep looking.  */
d3468 4
d3503 1
d3508 1
d3516 1
d3532 10
a3541 1
  if ((inst >> 26) == 0x1a)
d3550 4
a3553 1
  if ((inst >> 26) == 0x19 || (inst >> 26) == 0x18)
d3555 1
a3555 1
      
d3571 1
a3571 1
  /* is this an FSTDS ?*/
d3574 3
a3576 1
  /* is this an FSTWS ?*/
d3579 2
d3609 1
a3609 1
  /* If we are not at the beginning of a function, then return now. */ 
d3665 1
a3665 1
	 (only for HPC).  */
d3674 1
a3674 1
       
d3682 3
a3684 2
      /* There is only one instruction used for saving RP into the stack.  */
      if (inst == 0x6bc23fd9)
d3687 4
a3690 3
      /* This is the only way we save SP into the stack.  At this time
	 the HP compilers never bother to save SP into the stack.  */
      if ((inst & 0xffffc000) == 0x6fc10000)
d3693 9
d3707 2
a3708 2
	 Unfortunately args_stored only tells us that some arguments
	 where stored into the stack.  Not how many or what kind!
d3710 7
a3716 7
	 This is a kludge as on the HP compiler sets this bit and it
	 never does prologue scheduling.  So once we see one, skip past
	 all of them.   We have similar code for the fp arg stores below.

	 FIXME.  Can still die if we have a mix of GR and FR argument
	 stores!  */
      if (reg_num >= 23 && reg_num <= 26)
d3718 1
a3718 1
	  while (reg_num >= 23 && reg_num <= 26)
d3736 1
a3736 1
       
d3742 1
a3742 1
	 save.  */
d3745 1
a3745 1
	  && inst_saves_fr (next_inst) <= 7)
d3753 4
a3756 4
	 This is a kludge as on the HP compiler sets this bit and it
	 never does prologue scheduling.  So once we see one, skip past
	 all of them.  */
      if (reg_num >= 4 && reg_num <= 7)
d3758 1
a3758 1
	  while (reg_num >= 4 && reg_num <= 7)
d3778 1
a3778 1
	 instruction is in the delay slot of the first call/branch.  */
d3783 8
a3790 8
	 arguments were stored into the stack (boo hiss).  This could
	 cause this code to then skip a bunch of user insns (up to the
	 first branch).

	 To combat this we try to identify when args_stored was bogusly
	 set and clear it.   We only do this when args_stored is nonzero,
	 all other resources are accounted for, and nothing changed on
	 this pass.  */
d3792 1
a3792 1
	  && ! (save_gr || save_fr || save_rp || save_sp || stack_remaining > 0)
d3797 1
a3797 1
      
d3809 1
a3809 1
  if (save_gr || (save_fr && ! (restart_fr || restart_gr)))
d3821 2
a3822 5



/* return 0 if we cannot determine the end of the prologue,
   return the new pc value if we know where the prologue ends */
d3832 3
d3836 1
a3836 5
    return 0;                   /* Unknown */

  f = find_pc_function (pc);
  if (!f)
    return 0;			/* no debug info, do it the hard way! */
d3838 1
d3841 10
d3852 3
a3854 29
  {
  /* this happens when the function has no prologue, because the way 
     find_pc_line works: elz. Note: this may not be a very good
     way to decide whether a function has a prologue or not, but
     it is the best I can do with the info available
     Also, this will work for functions like: int f()
                                              {
                                               return 2;
                                              }
    I.e. the bp will be inserted at the first open brace.
    For functions where the body is only one line written like this:
                                             int f()
                                             { return 2; }
   this will make the breakpoint to be at the last brace, after the body
   has been executed already. What's the point of stepping through a function
   without any variables anyway??  */

    if ((SYMBOL_LINE(f) > 0) && (SYMBOL_LINE(f) < sal.line))
     return pc; /*no adjusment will be made*/
    else
     return sal.end; /* this is the end of the prologue */
  }
  /* The line after the prologue is after the end of the function.  In this
     case, put the end of the prologue is the beginning of the function.  */
  /* This should happen only when the function is prologueless and has no
     code in it. For instance void dumb(){} Note: this kind of function
     is  used quite a lot in the test system */

  else return pc; /* no adjustment will be made */
d3867 1
a3867 1
skip_prologue (pc)
d3870 4
a3873 4
    unsigned long inst;
    int offset;
    CORE_ADDR post_prologue_pc;
    char buf[4];
d3875 16
a3890 80
#ifdef GDB_TARGET_HAS_SHARED_LIBS
    /* Silently return the unaltered pc upon memory errors.
       This could happen on OSF/1 if decode_line_1 tries to skip the
       prologue for quickstarted shared library functions when the
       shared library is not yet mapped in.
       Reading target memory is slow over serial lines, so we perform
       this check only if the target has shared libraries.  */
    if (target_read_memory (pc, buf, 4))
      return pc;
#endif

    /* See if we can determine the end of the prologue via the symbol table.
       If so, then return either PC, or the PC after the prologue, whichever
       is greater.  */

    post_prologue_pc = after_prologue (pc);

    if (post_prologue_pc != 0)
      return max (pc, post_prologue_pc);


   /* Can't determine prologue from the symbol table, (this can happen if there
      is no debug information)  so we need to fall back on the old code, which
      looks at the instructions */
  /* FIXME (elz) !!!!: this may create a problem if, once the bp is hit, the user says
     where: the backtrace info is not right: this is because the point at which we
     break is at the very first instruction of the function. At this time the stuff that
     needs to be saved on the stack, has not been saved yet, so the backtrace
     cannot know all it needs to know. This will need to be fixed in the
     actual backtrace code. (Note: this is what DDE does) */

    else 

      return (skip_prologue_hard_way(pc));

#if 0
/* elz: I am keeping this code around just in case, but remember, all the
   instructions are for alpha: you should change all to the hppa instructions */

    /* Can't determine prologue from the symbol table, need to examine
       instructions.  */

    /* Skip the typical prologue instructions. These are the stack adjustment
       instruction and the instructions that save registers on the stack
       or in the gcc frame.  */
    for (offset = 0; offset < 100; offset += 4)
      {
        int status;

        status = read_memory_nobpt (pc + offset, buf, 4);
        if (status)
          memory_error (status, pc + offset);
        inst = extract_unsigned_integer (buf, 4);

        /* The alpha has no delay slots. But let's keep the lenient stuff,
           we might need it for something else in the future.  */
        if (lenient && 0)
          continue;

        if ((inst & 0xffff0000) == 0x27bb0000) /* ldah $gp,n($t12) */
	  continue;
        if ((inst & 0xffff0000) == 0x23bd0000) /* lda $gp,n($gp) */
            continue;
        if ((inst & 0xffff0000) == 0x23de0000) /* lda $sp,n($sp) */
            continue;
        else if ((inst & 0xfc1f0000) == 0xb41e0000
                 && (inst & 0xffff0000) != 0xb7fe0000)
            continue;				/* stq reg,n($sp) */
						/* reg != $zero */
        else if ((inst & 0xfc1f0000) == 0x9c1e0000
                 && (inst & 0xffff0000) != 0x9ffe0000)
            continue;				/* stt reg,n($sp) */
						/* reg != $zero */
        else if (inst == 0x47de040f)            /* bis sp,sp,fp */
            continue;
        else
            break;
	    }
    return pc + offset;
#endif /* 0 */
d3910 1
d3920 14
a3933 3
       && frame_info->pc <= (frame_info->frame + CALL_DUMMY_LENGTH
			     + 32 * 4 +	 (NUM_REGS - FP0_REGNUM) * 8
			     + 6 * 4)))	
d3945 2
a3946 1
	      = read_memory_integer (frame_info->frame + SP_REGNUM * 4, 4);
d4004 1
a4004 1
     For optimzied GCC code we're faced with problems.  GCC will schedule
d4013 3
a4015 1
  while (save_gr || save_fr || save_rp || save_sp || stack_remaining > 0)
d4027 3
a4029 2
      /* There is only one instruction used for saving RP into the stack.  */
      if (inst == 0x6bc23fd9)
d4034 5
d4040 8
a4047 4
      /* Just note that we found the save of SP into the stack.  The
	 value for frame_saved_regs was computed above.  */
      if ((inst & 0xffffc000) == 0x6fc10000)
	save_sp = 0;
d4060 3
d4065 9
d4077 1
a4077 1
		  = frame_info->frame + extract_14 (inst);
d4080 2
a4081 2
		  = frame_info->frame + (u->Total_frame_size << 3)
		    + extract_14 (inst);
d4088 3
a4090 3
	 It emits an instruction to put the value of the start of
	 the FP store area into %r1.  It then uses fstds,ma with
	 a basereg of %r1 for the stores.
d4092 2
a4093 2
	 HP CC emits them at the current stack pointer modifying
	 the stack pointer as it stores each register.  */
d4099 1
a4099 1
	
d4110 2
a4111 2
		 we've set enough state that the GCC and HPCC code are
		 both handled in the same manner.  */
d4123 6
a4128 2
      /* Quit if we hit any kind of branch.  This can happen if a prologue
	 instruction is in the delay slot of the first call/branch.  */
d4130 1
a4130 1
	break;
d4144 4
a4147 4
static char HP_ACC_EH_notify_hook[]     = "__eh_notify_hook";
/* The name of the function to be used to set the hook value */ 
static char HP_ACC_EH_set_hook_value[]  = "__eh_set_hook_value";
/* The name of the callback function in end.o */ 
d4149 13
a4161 11
/* Name of function in end.o on which a break is set (called by above) */ 
static char HP_ACC_EH_break[]           = "__d_eh_break";
/* Name of flag (in end.o) that enables catching throws */ 
static char HP_ACC_EH_catch_throw[]     = "__d_eh_catch_throw";
/* Name of flag (in end.o) that enables catching catching */ 
static char HP_ACC_EH_catch_catch[]     = "__d_eh_catch_catch";
/* The enum used by aCC */ 
typedef enum {
  __EH_NOTIFY_THROW,
  __EH_NOTIFY_CATCH
} __eh_notification;
d4170 1
a4170 1
static CORE_ADDR eh_notify_hook_addr = NULL;
d4172 1
a4172 1
static CORE_ADDR eh_notify_callback_addr = NULL;
d4174 1
a4174 1
static CORE_ADDR eh_break_addr = NULL;
d4176 1
a4176 1
static CORE_ADDR eh_catch_catch_addr = NULL;
d4178 1
a4178 1
static CORE_ADDR eh_catch_throw_addr = NULL;
d4180 1
a4180 1
static struct symtab_and_line * break_callback_sal = NULL;
d4187 1
a4187 1
   1 => failure  */ 
d4192 3
a4194 3
  struct minimal_symbol * msymbol;
  char buf[4]; /* FIXME 32x64? */
  
d4205 2
a4206 2
  store_unsigned_integer (buf, 4, inferior_pid); /* FIXME 32x64? */
  if (target_write_memory (anaddr, buf, 4)) /* FIXME 32x64? */
d4220 1
a4220 1
          1 => success          */
d4226 2
a4227 2
  struct cleanup * old_chain;
  struct cleanup * canonical_strings_chain = NULL;
d4229 3
a4231 3
  char * addr_start;
  char * addr_end = NULL;
  char ** canonical = (char **) NULL;
d4233 3
a4235 3
  struct symbol * sym = NULL;
  struct minimal_symbol * msym = NULL;
  struct objfile * objfile;
d4243 2
a4244 2
  static int recurse = 0;  
  if (recurse > 0) 
d4260 1
a4260 1
  
d4273 1
a4273 1
     
d4276 1
a4276 1
  
d4283 1
a4283 1
    }  
a4293 4
#if 0 /* DEBUGGING */
  printf ("Hook addr found is %lx\n", eh_notify_hook_addr);
#endif

d4295 1
a4295 1
  /* This is always available in the SOM symbol dictionary if end.o is linked in */ 
d4301 2
a4302 2
    }  
  else 
d4311 1
d4319 1
a4319 1
     reliable one to test that an executable is linked shared. pai/1997-07-18 */ 
d4327 1
a4327 1
         of shl_findsym()) to find the plabel. */ 
d4331 1
a4331 1
      
d4334 2
a4335 1
      
d4337 3
a4339 3
      eh_notify_callback_addr = catch_errors ((int (*) PARAMS ((char *))) cover_find_stub_with_shl_get,
                                              (char *) &args,
                                              message, RETURN_MASK_ALL);
a4340 4
      
#if 0 /* DEBUGGING  */
      printf ("found plabel for eh notify callback: %x\n", eh_notify_callback_addr);
#endif
d4343 1
a4343 1
      
d4345 7
a4351 7
        {
          /* We can get here either if there is no plabel in the export list
             for the main image, or if something strange happened (??) */ 
          warning ("Couldn't find a plabel (indirect function label) for the exception callback.");
          warning ("GDB will not be able to intercept exception events.");
          return 0;
        }
a4354 3

#if 0  /* DEBUGGING */
  printf ("Cb addr found is %lx\n", eh_notify_callback_addr);
d4358 1
a4358 1
  /* This should also be available in the SOM symbol dict. if end.o linked in */ 
d4364 1
a4364 1
    }  
a4373 4
#if 0  /* DEBUGGING */
  printf ("break addr found is %lx\n", eh_break_addr);  
#endif
  
d4376 2
a4377 2
                       VAR_NAMESPACE, 0, (struct symtab **) NULL);
  if (sym) /* sometimes present in debug info */ 
d4382 2
a4383 1
  else  /* otherwise look in SOM symbol dict. */ 
d4387 4
a4390 4
        {
          eh_catch_catch_addr = SYMBOL_VALUE_ADDRESS (msym);
          hp_cxx_exception_support = 1;
        }  
d4392 6
a4397 6
        {
          warning ("Unable to enable interception of exception catches.");
          warning ("Executable may not have been compiled debuggable with HP aCC.");
          warning ("Suggest linking executable with -g (link in /opt/langtools/lib/end.o).");
          return 0;
        }
a4399 4
#if 0  /* DEBUGGING */
  printf ("catch catch addr found is %lx\n", eh_catch_catch_addr);
#endif

d4402 2
a4403 2
                       VAR_NAMESPACE, 0, (struct symtab **) NULL);
  if (sym) /* sometimes present in debug info */ 
d4408 2
a4409 1
  else /* otherwise look in SOM symbol dict. */ 
d4413 4
a4416 4
        {
          eh_catch_throw_addr = SYMBOL_VALUE_ADDRESS (msym);
          hp_cxx_exception_support = 1;
        }  
d4418 6
a4423 6
        {
          warning ("Unable to enable interception of exception throws.");
          warning ("Executable may not have been compiled debuggable with HP aCC.");
          warning ("Suggest linking executable with -g (link in /opt/langtools/lib/end.o).");
          return 0;
        }
d4426 2
a4427 6
#if 0  /* DEBUGGING */
  printf ("catch throw addr found is %lx\n", eh_catch_throw_addr);
#endif

  /* Set the flags */ 
  hp_cxx_exception_support = 2; /* everything worked so far */ 
d4441 1
a4441 1
   address was found. */ 
d4443 1
a4443 1
struct symtab_and_line * 
d4445 2
a4446 2
  enum exception_event_kind kind;
  int enable;
d4456 7
a4462 7
      case 0:
        /* Assuming no HP support at all */ 
        return NULL;
      case 1:
        /* HP support should be present, but something went wrong */ 
        return (struct symtab_and_line *) -1; /* yuck! */ 
      /* there may be other cases in the future */ 
d4464 1
a4464 1
        
d4466 1
a4466 1
  store_unsigned_integer (buf, 4, enable ? eh_notify_callback_addr : 0); /* FIXME 32x64 problem */
d4468 1
a4468 1
  if (target_write_memory (eh_notify_hook_addr, buf, 4))    /* FIXME 32x64 problem */
d4472 1
a4472 1
      return (struct symtab_and_line *) -1; 
d4476 1
a4476 1
      /* Ensure that __d_pid is set up correctly -- end.c code checks this. :-(*/
d4478 4
a4481 4
        {
          if (setup_d_pid_in_inferior ())
            return (struct symtab_and_line *) -1; 
        }
d4483 4
a4486 4
        {
          warning ("Internal error: Invalid inferior pid?  Cannot intercept exception events."); /* purecov: deadcode */
          return (struct symtab_and_line *) -1; /* purecov: deadcode */
        }
d4488 1
a4488 1
  
d4491 18
a4508 18
      case EX_EVENT_THROW:
        store_unsigned_integer (buf, 4, enable ? 1 : 0);
        if (target_write_memory (eh_catch_throw_addr, buf, 4)) /* FIXME 32x64? */
          {
            warning ("Couldn't enable exception throw interception.");
            return (struct symtab_and_line *) -1;
          }
        break;
      case EX_EVENT_CATCH:
        store_unsigned_integer (buf, 4, enable ? 1 : 0);
        if (target_write_memory (eh_catch_catch_addr, buf, 4)) /* FIXME 32x64? */
          {
            warning ("Couldn't enable exception catch interception.");
            return (struct symtab_and_line *) -1;
          }
        break;
      default: /* purecov: deadcode */
        error ("Request to enable unknown or unsupported exception event."); /* purecov: deadcode */
d4510 1
a4510 1
  
d4516 1
a4516 1
  INIT_SAL(break_callback_sal);
d4521 1
a4521 1
  
d4525 1
a4525 1
/* Record some information about the current exception event */ 
d4527 3
a4529 2
/* Convenience struct */ 
static struct symtab_and_line null_symtab_and_line = { NULL, 0, 0, 0 };
d4534 1
a4534 1
   in the future */ 
d4538 3
a4540 3
  CORE_ADDR  event_kind;
  CORE_ADDR  throw_addr;
  CORE_ADDR  catch_addr;
d4544 1
a4544 1
  curr_frame = get_current_frame();
d4559 4
a4562 4
          1. event kind catch or throw
          2. the target address if known
          3. a flag -- not sure what this is. pai/1997-07-17 */
  event_kind = read_register (ARG0_REGNUM);  
d4567 3
a4569 3
                  __d_eh_notify_callback which is called by
                  __notify_throw which is called
                  from user code.
d4571 5
a4575 5
                  __d_eh_notify_callback which is called by
                  <stackwalking stuff> which is called by
                  __throw__<stuff> or __rethrow_<stuff> which is called
                  from user code. */
  /* FIXME: Don't use such magic numbers; search for the frames */ 
a4593 3

#ifdef MAINTENANCE_CMDS

a4664 1
#endif /* MAINTENANCE_CMDS */
d4689 1
a4689 1
      at that PC, user switches threads -- YES
d4692 4
a4695 4
      breakpoint, deleted the breakpoint and then gotten another
      hit on that same breakpoint on another thread which
      actually hit before the delete. (FIXME in breakpoint.c
      so that "dead" breakpoints are ignored?) -- NO
d4702 1
a4702 1
hppa_prepare_to_proceed()
d4707 1
a4707 1
  old_thread = hppa_switched_threads(inferior_pid);
d4714 1
a4714 1
      CORE_ADDR old_pc = read_pc();
d4719 1
a4719 1
      inferior_pid   = old_thread;
d4721 2
a4722 2
      new_pc = read_pc();
      if (new_pc != old_pc          /* If at same pc, no need */
d4724 1
a4724 1
        {
d4726 1
a4726 1
             Return TRUE, finishing switch to "old_thread". */
d4730 1
a4730 1
	  printf("---> PREPARE_TO_PROCEED (was %d, now %d)!\n",
d4733 1
a4733 1
               
d4735 1
a4735 1
        }
d4739 1
a4739 1
      new_pc       = read_pc();       /* Re-prime register cache */
d4747 24
a4774 1
#ifdef MAINTENANCE_CMDS
a4777 1
#endif /* MAINTENANCE_CMDS */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d1428 5
a1432 3
      write_inferior_status_register (inf_status, 0, int_buffer);
      write_inferior_status_register (inf_status, PCOQ_HEAD_REGNUM, pc + 0);
      write_inferior_status_register (inf_status, PCOQ_TAIL_REGNUM, pc + 4);
d1438 4
a1441 2
      write_inferior_status_register (inf_status, PCSQ_HEAD_REGNUM, pcspace);
      write_inferior_status_register (inf_status, PCSQ_TAIL_REGNUM, pcspace);
a2431 7
      /* NB: save_state_t is not available before HPUX 9.
	 The ss_wide field is not available previous to HPUX 10.20,
         so to avoid compile-time warnings, we only compile this for
         PA 2.0 processors.  This control path should only be followed
         if we're debugging a PA 2.0 processor, so this should not cause
         problems. */

d4279 3
d4353 1
d4440 1
d4444 1
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@d3516 1
a3516 1
hppa_skip_prologue (pc)
@


1.1.1.4
log
@import gdb-1999-06-07 snapshot
@
text
@d1926 1
a1926 16
   inferior to do the function call. 

   This has to work across several versions of hpux, bsd, osf1.  It has to
   work regardless of what compiler was used to build the inferior program.
   It should work regardless of whether or not end.o is available.  It has
   to work even if gdb can not call into the dynamic loader in the inferior
   to query it for symbol names and addresses.

   Yes, all those cases should work.  Luckily code exists to handle most
   of them.  The complexity is in selecting exactly what scheme should
   be used to perform the inferior call.

   At the current time this routine is known not to handle cases where
   the program was linked with HP's compiler without including end.o.

   Please contact Jeff Law (law@@cygnus.com) before changing this code.  */
d1942 3
a1944 12
  struct unwind_table_entry *u = NULL;
  CORE_ADDR new_stub = 0;
  CORE_ADDR solib_handle = 0;

  /* Nonzero if we will use GCC's PLT call routine.  This routine must be
     passed an import stub, not a PLABEL.  It is also necessary to set %r19	
     (the PIC register) before performing the call. 

     If zero, then we are using __d_plt_call (HP's PLT call routine) or we
     are calling the target directly.  When using __d_plt_call we want to
     use a PLABEL instead of an import stub.  */
  int using_gcc_plt_call = 1;
a1945 2
  /* Prefer __gcc_plt_call over the HP supplied routine because
      __gcc_plt_call works for any number of arguments.  */
a1946 3
  if (lookup_minimal_symbol ("__gcc_plt_call", NULL, NULL) == NULL)
    using_gcc_plt_call = 0;

d1949 1
a1949 1
    error ("Can't find an address for $$dyncall trampoline");
d1954 2
a1955 3
     its real address and the value of its GOT/DP if we plan to
     call the routine via gcc_plt_call.  */
  if ((fun & 0x2) && using_gcc_plt_call)
d1970 14
a1983 8
      /* FUN could be an export stub, the real address of a function, or
	 a PLABEL.  When using gcc's PLT call routine we must call an import
	 stub rather than the export stub or real function for lazy binding
	 to work correctly

      /* If we are using the gcc PLT call routine, then we need to
	 get the import stub for the target function.  */
      if (using_gcc_plt_call && som_solib_get_got_by_pc (fun))
d1997 2
a1998 8
	      stub_symbol
		= lookup_minimal_symbol_solib_trampoline
		    (SYMBOL_NAME (funsymbol), NULL, objfile);

	      if (! stub_symbol)
		stub_symbol = lookup_minimal_symbol (SYMBOL_NAME (funsymbol),
						     NULL, objfile);

d2009 1
a2009 3
		  if (!u
		      || (u->stub_unwind.stub_type != IMPORT)
			  && u->stub_unwind.stub_type != IMPORT_SHLIB)
a2016 4

	  /* Ouch.  We did not find an import stub.  Make an attempt to
	     do the right thing instead of just croaking.  Most of the
	     time this will actually work.  */
a2018 11

	  u = find_unwind_entry (fun);
	  if (u 
	      && (u->stub_unwind.stub_type == IMPORT
		  || u->stub_unwind.stub_type == IMPORT_SHLIB))
	    trampoline = lookup_minimal_symbol ("__gcc_plt_call", NULL, NULL);

	  /* If we found the import stub in the shared library, then we have
	     to set %r19 before we call the stub.  */
	  if (u && u->stub_unwind.stub_type == IMPORT_SHLIB)
	    write_register (19, som_solib_get_got_by_pc (fun));
d2020 1
d2024 23
a2046 2
  /* If we are calling into another load module then have sr4export call the
     magic __d_plt_call routine which is linked in from end.o.
d2048 4
a2051 8
     You can't use _sr4export to make the call as the value in sp-24 will get
     fried and you end up returning to the wrong location.  You can't call the
     target as the code to bind the PLT entry to a function can't return to a
     stack address.

     Also, query the dynamic linker in the inferior to provide a suitable
     PLABEL for the target function.  */
  if (! using_gcc_plt_call)
d2055 31
a2085 24
      /* Get a handle for the shared library containing FUN.  Given the
	 handle we can query the shared library for a PLABEL.  */
      solib_handle = som_solib_get_solib_by_pc (fun);

      if (solib_handle)
	{
	  struct minimal_symbol *fmsymbol = lookup_minimal_symbol_by_pc (fun);

	  trampoline = lookup_minimal_symbol ("__d_plt_call", NULL, NULL);

	  if (trampoline == NULL)
	    {
	      error ("Can't find an address for __d_plt_call or __gcc_plt_call trampoline\nSuggest linking executable with -g or compiling with gcc.");
	    }

	  /* This is where sr4export will jump to.  */
	  new_fun = SYMBOL_VALUE_ADDRESS (trampoline);

	  /* If the function is in a shared library, then call __d_shl_get to
	     get a PLABEL for the target function.  */
	  new_stub = find_stub_with_shl_get (fmsymbol, solib_handle);

	  if (new_stub == 0) 
	    error ("Can't find an import stub for %s", SYMBOL_NAME (fmsymbol));
d2088 10
a2097 7
	  msymbol = lookup_minimal_symbol ("__shlib_funcptr", NULL,
					   (struct objfile *)NULL);

	  if (msymbol == NULL)
	    error ("Can't find an address for __shlib_funcptr");
	  target_write_memory (SYMBOL_VALUE_ADDRESS (msymbol),
			       (char *)&new_stub, 4);
d2101 2
a2102 2
	  fun = new_fun;
	  trampoline = NULL;
d2134 1
a2134 1
	  error ("Can't find an address for _sr4export trampoline");
d2179 1
d3964 4
d4014 4
d4032 4
d4053 4
d4082 4
d4110 4
@


1.1.1.5
log
@import gdb-1999-07-07 post reformat
@
text
@d8 1
a8 1
   This file is part of GDB.
d10 13
a22 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d49 1
a49 1
/*#include <sys/user.h>         After a.out.h  */
d67 1
a67 1

d132 4
a135 6
typedef struct
  {
    struct minimal_symbol *msym;
    CORE_ADDR solib_handle;
  }
args_for_find_stub;
d139 1
a139 1
static int is_pa_2 = 0;		/* False */
d141 1
a141 1
/* This is declared in symtab.c; set to 1 in hp-symtab-read.c */
d149 1
a149 1
  find_function_in_inferior PARAMS ((char *));
d159 1
a160 1

d171 1
a171 1
  return (int) (val >> (bits - 1) ? (-1 << bits) | val : val);
d180 1
a180 1
  return (int) ((val & 0x1 ? (-1 << (bits - 1)) : 0) | val >> 1);
d232 2
a233 2
#endif /* 0 */

d283 1
a283 1
  return word | ((unsigned) opnd << 1 & MASK_14) | sign;
d349 4
a352 4
  word |= GET_FIELD (opnd, 15 + 0, 15 + 0);	/* w */
  word |= GET_FIELD (opnd, 15 + 1, 15 + 5) << 16;	/* w1 */
  word |= GET_FIELD (opnd, 15 + 6, 15 + 6) << 2;	/* w2[10] */
  word |= GET_FIELD (opnd, 15 + 7, 15 + 16) << 3;	/* w2[0..9] */
d412 1
a412 1
         endian issues.  */
d416 1
a416 1
					      (bfd_byte *) buf);
d419 1
a419 1
	  table[i].region_end = bfd_get_32 (objfile->obfd, (bfd_byte *) buf);
d422 1
a422 1
	  tmp = bfd_get_32 (objfile->obfd, (bfd_byte *) buf);
d448 1
a448 1
	  tmp = bfd_get_32 (objfile->obfd, (bfd_byte *) buf);
d457 1
a457 1
	  /* Stub unwinds are handled elsewhere. */
d483 2
a484 2
  ui = (struct obj_unwind_info *) obstack_alloc (&objfile->psymbol_obstack,
					   sizeof (struct obj_unwind_info));
d510 2
a511 2
      elf_unwind_size = bfd_section_size (objfile->obfd, elf_unwind_sec);	/* purecov: deadcode */
      elf_unwind_entries = elf_unwind_size / UNWIND_ENTRY_SIZE;		/* purecov: deadcode */
d537 1
a537 1
  ui->last = total_entries - 1;
d571 1
a571 1
							  (bfd_byte *) buf);
d574 2
a575 2
	    = ui->table[index].region_start + 4 *
	    (bfd_get_16 (objfile->obfd, (bfd_byte *) buf) - 1);
d586 1
a586 1
  if (objfile->obj_private == NULL)
d589 2
a590 2
	obstack_alloc (&objfile->psymbol_obstack,
		       sizeof (obj_private_data_t));
d592 2
a593 2
      obj_private->so_info = NULL;

d596 1
a596 1
  obj_private = (obj_private_data_t *) objfile->obj_private;
d606 1
a606 1
find_unwind_entry (pc)
d617 5
a621 5
  {
    struct obj_unwind_info *ui;
    ui = NULL;
    if (objfile->obj_private)
      ui = ((obj_private_data_t *) (objfile->obj_private))->unwind_info;
d623 7
a629 7
    if (!ui)
      {
	read_unwind_info (objfile);
	if (objfile->obj_private == NULL)
	  error ("Internal error reading unwind information.");		/* purecov: deadcode */
	ui = ((obj_private_data_t *) (objfile->obj_private))->unwind_info;
      }
d631 1
a631 1
    /* First, check the cache */
d633 4
a636 4
    if (ui->cache
	&& pc >= ui->cache->region_start
	&& pc <= ui->cache->region_end)
      return ui->cache;
d638 1
a638 1
    /* Not in the cache, do a binary search */
d640 2
a641 2
    first = 0;
    last = ui->last;
d643 9
a651 9
    while (first <= last)
      {
	middle = (first + last) / 2;
	if (pc >= ui->table[middle].region_start
	    && pc <= ui->table[middle].region_end)
	  {
	    ui->cache = &ui->table[middle];
	    return &ui->table[middle];
	  }
d653 6
a658 6
	if (pc < ui->table[middle].region_start)
	  last = middle - 1;
	else
	  first = middle + 1;
      }
  }				/* ALL_OBJFILES() */
d737 1
a737 1
         return from a cross-space function call.  */
d744 1
a744 1
         here.  */
d759 1
a759 1
         return from a cross-space function call.  */
d766 1
a766 1
         here.  */
d772 1
a772 1
find_return_regnum (pc)
d797 1
a797 1
  if (pc == (CORE_ADDR) 0)
d799 1
a799 1

d889 1
a889 1

d906 2
a907 2
  int spun_around_loop = 0;
  int rp_offset = 0;
d933 4
a936 4
         handler caller, then we need to look in the saved
         register area to get the return pointer (the values
         in the registers may not correspond to anything useful).  */
      if (frame->next
d948 3
a950 3
	         with a return pointer in %rp and the kernel call with
	         a return pointer in %r31.  We return the %rp variant
	         if %r31 is the same as frame->pc.  */
d963 1
a963 1
      old_pc = pc;
d965 1
a965 1
    restart:
d969 2
a970 2
         frame is a signal or interrupt handler, then dig the right
         information out of the saved register info.  */
d984 3
a986 3
	         with a return pointer in %rp and the kernel call with
	         a return pointer in %r31.  We return the %rp variant
	         if %r31 is the same as frame->pc.  */
d994 4
a997 4
	{
	  old_pc = pc;
	  pc = read_register (RP_REGNUM) & ~0x3;
	}
d999 4
a1002 4
	{
	  old_pc = pc;
	  pc = read_memory_integer (frame->frame + rp_offset, 4) & ~0x3;
	}
d1017 3
a1019 3
         then the call chain will eventually point us into the stub for
         _sigreturn.  Unlike most cases, we'll be pointed to the branch
         to the real sigreturn rather than the code after the real branch!. 
d1021 2
a1022 2
         Else, try to dig the address the stub will return to in the normal
         fashion.  */
d1028 11
a1038 11
	  if (old_pc == pc)
	    spun_around_loop++;

	  if (spun_around_loop > 1)
	    {
	      /* We're just about to go around the loop again with
	         no more hope of success.  Die. */
	      error ("Unable to find return pc for this frame");
	    }
	  else
	    goto restart;
d1065 1
a1065 1
         in the current frame structure (it isn't set yet).  */
d1069 3
a1071 3
         use it, else subtract the size of this frame from the current
         frame.  (we always want frame->frame to point at the lowest address
         in the frame).  */
d1080 1
a1080 1
  if (flags & 2)		/* In system call? */
d1092 1
a1092 1
  framesize = find_proc_framesize (frame->pc);
d1116 1
a1116 1
  CORE_ADDR caller_pc;
d1119 2
a1120 2
  struct symbol *frame_symbol;
  char *frame_symbol_name;
d1125 2
a1126 2
  min_frame_symbol = lookup_minimal_symbol_by_pc (frame->pc);
  frame_symbol = find_pc_function (frame->pc);
d1128 1
a1128 1
  if ((min_frame_symbol != 0) /* && (frame_symbol == 0) */ )
d1130 19
a1148 21
      /* The test above for "no user function name" would defend
         against the slim likelihood that a user might define a
         routine named "__pthread_exit" and then try to debug it.

         If it weren't commented out, and you tried to debug the
         pthread library itself, you'd get errors.

         So for today, we don't make that check. */
      frame_symbol_name = SYMBOL_NAME (min_frame_symbol);
      if (frame_symbol_name != 0)
	{
	  if (0 == strncmp (frame_symbol_name,
			    THREAD_INITIAL_FRAME_SYMBOL,
			    THREAD_INITIAL_FRAME_SYM_LEN))
	    {
	      /* Pretend we've reached the bottom of the stack. */
	      return (CORE_ADDR) 0;
	    }
	}
    }				/* End of hacky code for threads. */

d1167 1
a1167 1
  caller_pc = FRAME_SAVED_PC (frame);
d1175 1
a1175 1
  caller_framesize = find_proc_framesize (FRAME_SAVED_PC (frame));
d1217 4
a1220 4
	  /* ??rehrauer: Actually, it's quite possible to stepi your way into
	     code that doesn't have unwind entries.  For example, stepping into
	     the dynamic linker will give you a PC that has none.  Thus, I've
	     disabled this warning. */
d1228 1
a1228 1
         saved in the stack.  It starts at %r3, so %r3 would be 1.  */
d1240 1
a1240 1
         pointer.  */
d1248 1
a1248 1
      else
d1260 1
a1260 1

d1263 5
a1267 5
	     * Attaching to a process when the process is in the
	     kernel performing a system call (debugger can't get
	     full register state for the inferior process since
	     the process wasn't being traced when it entered the
	     system call).
d1269 2
a1270 2
	     * Register state is not complete if the system call
	     causes the process to core dump.
d1283 1
a1283 1
		   && (read_memory_integer (saved_regs.regs[FLAGS_REGNUM], 4)
d1298 1
a1298 1

d1318 1
a1318 1
		  && read_register (FLAGS_REGNUM) & 0x2)))
d1325 4
a1328 4
	  else
	    {
	      return frame_base - (u->Total_frame_size << 3);
	    }
d1330 1
a1330 1

d1332 1
a1332 1
         holds the value of the previous frame pointer).  */
d1336 1
a1337 1

d1445 1
a1445 1
  write_memory (sp - 20, (char *) &int_buffer, 4);
d1448 1
a1448 1
  write_memory (sp, (char *) &int_buffer, 4);
d1462 2
a1463 2
      read_register_bytes (REGISTER_BYTE (regnum), (char *) &freg_buffer, 8);
      sp = push_bytes (sp, (char *) &freg_buffer, 8);
d1520 1
a1520 1
  if (fsr.regs[IPSW_REGNUM])	/* Restoring a call dummy frame */
d1528 1
a1528 1
  for (regnum = NUM_REGS - 1; regnum >= FP0_REGNUM; regnum--)
d1531 2
a1532 2
	read_memory (fsr.regs[regnum], (char *) &freg_buffer, 8);
	write_register_bytes (REGISTER_BYTE (regnum), (char *) &freg_buffer, 8);
d1537 1
a1537 1
		    read_memory_integer (fsr.regs[IPSW_REGNUM], 4));
d1541 1
a1541 1
		    read_memory_integer (fsr.regs[SAR_REGNUM], 4));
d1550 1
a1550 1
  else
d1558 1
a1558 1
  if (fsr.regs[IPSW_REGNUM])	/* call dummy */
d1578 1
a1578 1
         for "return_command" will print the frame we returned to.  */
d1590 1
a1590 1
      proceed ((CORE_ADDR) - 1, TARGET_SIGNAL_DEFAULT, 0);
d1618 3
a1620 3
     mtsp r21, sr0
     ble,n 0(sr0, r22)

d1630 4
a1633 4
         merge this into wait_for_inferior (as a special kind of
         watchpoint?  By setting a breakpoint at the end?  Is there
         any other choice?  Is there *any* way to do this stuff with
         ptrace() or some equivalent?).  */
d1638 4
a1641 4
	{
	  stop_signal = w.value.sig;
	  terminal_ours_for_output ();
	  printf_unfiltered ("\nProgram terminated with signal %s, %s.\n",
d1644 3
a1646 3
	  gdb_flush (gdb_stdout);
	  return 0;
	}
d1663 1
a1663 1
  int *offset = (int *) alloca (nargs * sizeof (int));
d1666 1
a1666 1

d1671 1
a1671 1
         the arguments seen so far */
d1674 2
a1675 2
      /* value must go at proper alignment. Assume alignment is a
         power of two. */
d1721 1
a1721 1
  int *offset = (int *) alloca (nargs * sizeof (int));
d1723 1
a1723 1
  int *lengths = (int *) alloca (nargs * sizeof (int));
d1725 2
a1726 2
  int bytes_reserved;		/* this is the number of bytes on the stack occupied by an
				   argument. This will be always a multiple of 4 */
d1728 4
a1731 4
  int cum_bytes_reserved = 0;	/* this is the total number of bytes reserved by the args
				   seen so far. It is a multiple of 4 always */
  int cum_bytes_aligned = 0;	/* same as above, but aligned on 8 bytes */
  int i;
d1736 1
a1736 1
     It is enough to align it to the word. */
d1745 1
a1745 1

d1752 3
a1754 3
	bytes_reserved = (lengths[i] / 4) * 4 + 4;
      else
	bytes_reserved = lengths[i];
d1758 17
a1774 17
      if ((bytes_reserved == 8) && (offset[i] % 8))	/* if 64-bit arg is not 64 bit aligned */
	{
	  int new_offset = 0;
	  /* bytes_reserved is already aligned to the word, so we put it at one word
	     more down the stack. This will leave one empty word on the
	     stack, and one unused register. This is OK, see the calling
	     convention doc */
	  /* the offset may have to be moved to the corresponding position
	     one word down the stack, to maintain 
	     alignment. */
	  new_offset = (offset[i] / 8) * 8 + 8;
	  if ((new_offset - offset[i]) >= 4)
	    {
	      bytes_reserved += 4;
	      offset[i] += 4;
	    }
	}
d1789 1
d1791 1
a1791 2

  /* if a structure has to be returned, set up register 28 to hold its address */
d1795 1
a1795 1
  /* the stack will have other 8 words on top of the args */
d1808 1
a1808 1
hppa_value_returned_from_stack (valtype, addr)
d1816 1
a1816 1
  target_read_memory (addr, VALUE_CONTENTS_RAW (val), TYPE_LENGTH (valtype));
d1824 17
a1840 17
   This function calls shl_findsym, indirectly through a
   call to __d_shl_get. __d_shl_get is in end.c, which is always
   linked in by the hp compilers/linkers. 
   The call to shl_findsym cannot be made directly because it needs
   to be active in target address space. 
   inputs: - minimal symbol pointer for the function we want to look up
   - address in target space of the descriptor for the library
   where we want to look the symbol up.
   This address is retrieved using the 
   som_solib_get_solib_by_pc function (somsolib.c). 
   output: - real address in the library of the function.          
   note: the handle can be null, in which case shl_findsym will look for
   the symbol in all the loaded shared libraries.
   files to look at if you need reference on this stuff:
   dld.c, dld_shl_findsym.c
   end.c
   man entry for shl_findsym */
d1843 66
a1908 66
find_stub_with_shl_get (function, handle)
     struct minimal_symbol *function;
     CORE_ADDR handle;
{
  struct symbol *get_sym, *symbol2;
  struct minimal_symbol *buff_minsym, *msymbol;
  struct type *ftype;
  value_ptr *args;
  value_ptr funcval, val;

  int x, namelen, err_value, tmp = -1;
  CORE_ADDR endo_buff_addr, value_return_addr, errno_return_addr;
  CORE_ADDR stub_addr;


  args = (value_ptr *) alloca (sizeof (value_ptr) * 8);		/* 6 for the arguments and one null one??? */
  funcval = find_function_in_inferior ("__d_shl_get");
  get_sym = lookup_symbol ("__d_shl_get", NULL, VAR_NAMESPACE, NULL, NULL);
  buff_minsym = lookup_minimal_symbol ("__buffer", NULL, NULL);
  msymbol = lookup_minimal_symbol ("__shldp", NULL, NULL);
  symbol2 = lookup_symbol ("__shldp", NULL, VAR_NAMESPACE, NULL, NULL);
  endo_buff_addr = SYMBOL_VALUE_ADDRESS (buff_minsym);
  namelen = strlen (SYMBOL_NAME (function));
  value_return_addr = endo_buff_addr + namelen;
  ftype = check_typedef (SYMBOL_TYPE (get_sym));

  /* do alignment */
  if ((x = value_return_addr % 64) != 0)
    value_return_addr = value_return_addr + 64 - x;

  errno_return_addr = value_return_addr + 64;


  /* set up stuff needed by __d_shl_get in buffer in end.o */

  target_write_memory (endo_buff_addr, SYMBOL_NAME (function), namelen);

  target_write_memory (value_return_addr, (char *) &tmp, 4);

  target_write_memory (errno_return_addr, (char *) &tmp, 4);

  target_write_memory (SYMBOL_VALUE_ADDRESS (msymbol),
		       (char *) &handle, 4);

  /* now prepare the arguments for the call */

  args[0] = value_from_longest (TYPE_FIELD_TYPE (ftype, 0), 12);
  args[1] = value_from_longest (TYPE_FIELD_TYPE (ftype, 1), SYMBOL_VALUE_ADDRESS (msymbol));
  args[2] = value_from_longest (TYPE_FIELD_TYPE (ftype, 2), endo_buff_addr);
  args[3] = value_from_longest (TYPE_FIELD_TYPE (ftype, 3), TYPE_PROCEDURE);
  args[4] = value_from_longest (TYPE_FIELD_TYPE (ftype, 4), value_return_addr);
  args[5] = value_from_longest (TYPE_FIELD_TYPE (ftype, 5), errno_return_addr);

  /* now call the function */

  val = call_function_by_hand (funcval, 6, args);

  /* now get the results */

  target_read_memory (errno_return_addr, (char *) &err_value, sizeof (err_value));

  target_read_memory (value_return_addr, (char *) &stub_addr, sizeof (stub_addr));
  if (stub_addr <= 0)
    error ("call to __d_shl_get failed, error code is %d", err_value);	/* purecov: deadcode */

  return (stub_addr);
d1911 1
a1911 1
/* Cover routine for find_stub_with_shl_get to pass to catch_errors */
d1914 1
a1914 1
     args_for_find_stub *args;
d1962 1
a1962 1
     passed an import stub, not a PLABEL.  It is also necessary to set %r19     
d1971 1
a1971 1
     __gcc_plt_call works for any number of arguments.  */
d1988 2
a1989 2
         at *(fun+4).  Note the call dummy is *NOT* allowed to
         trash %r19 before calling the target function.  */
d1993 1
a1993 1
         at *fun.  */
d2001 3
a2003 3
         a PLABEL.  When using gcc's PLT call routine we must call an import
         stub rather than the export stub or real function for lazy binding
         to work correctly
d2005 2
a2006 2
         /* If we are using the gcc PLT call routine, then we need to
         get the import stub for the target function.  */
d2020 29
a2048 29
	  {
	    stub_symbol
	      = lookup_minimal_symbol_solib_trampoline
	      (SYMBOL_NAME (funsymbol), NULL, objfile);

	    if (!stub_symbol)
	      stub_symbol = lookup_minimal_symbol (SYMBOL_NAME (funsymbol),
						   NULL, objfile);

	    /* Found a symbol with the right name.  */
	    if (stub_symbol)
	      {
		struct unwind_table_entry *u;
		/* It must be a shared library trampoline.  */
		if (MSYMBOL_TYPE (stub_symbol) != mst_solib_trampoline)
		  continue;

		/* It must also be an import stub.  */
		u = find_unwind_entry (SYMBOL_VALUE (stub_symbol));
		if (!u
		    || (u->stub_unwind.stub_type != IMPORT)
		    && u->stub_unwind.stub_type != IMPORT_SHLIB)
		  continue;

		/* OK.  Looks like the correct import stub.  */
		newfun = SYMBOL_VALUE (stub_symbol);
		fun = newfun;
	      }
	  }
d2057 1
a2057 1
	  if (u
d2080 1
a2080 1
  if (!using_gcc_plt_call)
d2085 1
a2085 1
         handle we can query the shared library for a PLABEL.  */
d2106 1
a2106 1
	  if (new_stub == 0)
d2111 1
a2111 1
					   (struct objfile *) NULL);
d2116 1
a2116 1
			       (char *) &new_stub, 4);
d2208 1
a2208 1
     int pid;
d2212 3
a2214 4
  if (flags & 2)
    {
      return (CORE_ADDR) 0;
    }
d2286 1
a2286 1
	  if (!TYPE_FIELD_BITSIZE (type, i))	/* elz: this should be bitsize */
d2305 1
a2305 1
  char raw_regs[REGISTER_BYTES];
d2315 14
a2328 12
  else if (regnum < FP4_REGNUM)
    {
      long reg_val[2];

      /* Why is the value not passed through "extract_signed_integer"
         as in "pa_print_registers" below? */
      pa_register_look_aside (raw_regs, regnum, &reg_val[0]);

      if (!is_pa_2)
	{
	  printf_unfiltered ("%s %x\n", REGISTER_NAME (regnum), reg_val[1]);
	}
d2330 2
a2331 8
	{
	  /* Fancy % formats to prevent leading zeros. */
	  if (reg_val[0] == 0)
	    printf_unfiltered ("%s %x\n", REGISTER_NAME (regnum), reg_val[1]);
	  else
	    printf_unfiltered ("%s %x%8.8x\n", REGISTER_NAME (regnum),
			       reg_val[0], reg_val[1]);
	}
d2333 1
d2335 3
a2337 3
    /* Note that real floating point values only start at
       FP4_REGNUM.  FP0 and up are just status and error
       registers, which have integral (bit) values. */
d2349 1
a2349 1
  char raw_regs[REGISTER_BYTES];
d2353 1
a2353 1
     reads from the target). */
d2360 15
a2374 12
  else if (regnum < FP4_REGNUM)
    {
      long reg_val[2];

      /* Why is the value not passed through "extract_signed_integer"
         as in "pa_print_registers" below? */
      pa_register_look_aside (raw_regs, regnum, &reg_val[0]);

      if (!is_pa_2)
	{
	  fprintf_unfiltered (stream, "%s %x", REGISTER_NAME (regnum), reg_val[1]);
	}
d2376 2
a2377 9
	{
	  /* Fancy % formats to prevent leading zeros. */
	  if (reg_val[0] == 0)
	    fprintf_unfiltered (stream, "%s %x", REGISTER_NAME (regnum),
				reg_val[1]);
	  else
	    fprintf_unfiltered (stream, "%s %x%8.8x", REGISTER_NAME (regnum),
				reg_val[0], reg_val[1]);
	}
d2379 1
d2381 3
a2383 3
    /* Note that real floating point values only start at
       FP4_REGNUM.  FP0 and up are just status and error
       registers, which have integral (bit) values. */
d2393 1
a2393 1
pa_register_look_aside (raw_regs, regnum, raw_val)
d2395 1
a2395 1
     int regnum;
d2398 1
a2398 1
  static int know_which = 0;	/* False */
d2400 1
a2400 1
  int regaddr;
d2403 3
a2405 3
  int start;


d2409 7
a2415 9
  if (!know_which)
    {
      if (CPU_PA_RISC2_0 == sysconf (_SC_CPU_VERSION))
	{
	  is_pa_2 = (1 == 1);
	}

      know_which = 1;		/* True */
    }
d2420 2
a2421 3
  if (!is_pa_2)
    {
      raw_val[1] = *(long *) (raw_regs + REGISTER_BYTE (regnum));
d2423 1
a2423 1
    }
d2428 1
a2428 2
      !HAVE_STRUCT_SAVE_STATE_T || !HAVE_STRUCT_MEMBER_SS_WIDE)
    {
d2430 5
a2434 6
      offset = U_REGS_OFFSET;
      regaddr = register_addr (regnum, offset);
      start = 1;
    }
  else
    {
d2440 1
a2440 1
         offset  = offsetof(save_state_t, ss_wide);
d2447 1
a2447 1
         The ss_wide field is not available previous to HPUX 10.20,
d2461 1
a2461 1
      start = 0;
d2463 3
a2465 3
    }

  for (i = start; i < 2; i++)
d2469 1
a2469 1
				(PTRACE_ARG3_TYPE) regaddr, 0);
d2483 1
a2483 1

d2485 1
a2485 1
    raw_val[1] &= ~0x3;		/* I think we're masking out space bits */
d2492 1
a2492 1

d2499 2
a2500 2
  int i, j;
  long raw_val[2];		/* Alas, we are compiled so that "long long" is 32 bits */
d2507 23
a2529 25
	  /* Q: Why is the value passed through "extract_signed_integer",
	     while above, in "pa_do_registers_info" it isn't?
	     A: ? */
	  pa_register_look_aside (raw_regs, i + (j * 18), &raw_val[0]);

	  /* Even fancier % formats to prevent leading zeros
	     and still maintain the output in columns. */
	  if (!is_pa_2)
	    {
	      /* Being big-endian, on this machine the low bits
	         (the ones we want to look at) are in the second longword. */
	      long_val = extract_signed_integer (&raw_val[1], 4);
	      printf_filtered ("%8.8s: %8x  ",
			       REGISTER_NAME (i + (j * 18)), long_val);
	    }
	  else
	    {
	      /* raw_val = extract_signed_integer(&raw_val, 8); */
	      if (raw_val[0] == 0)
		printf_filtered ("%8.8s:         %8x  ",
				 REGISTER_NAME (i + (j * 18)), raw_val[1]);
	      else
		printf_filtered ("%8.8s: %8x%8.8x  ", REGISTER_NAME (i + (j * 18)),
				 raw_val[0], raw_val[1]);
	    }
d2533 1
a2533 1

d2535 1
a2535 1
    for (i = FP4_REGNUM; i < NUM_REGS; i++)	/* FP4_REGNUM == 72 */
d2539 1
a2539 1
/************* new function ******************/
d2547 2
a2548 2
  int i, j;
  long raw_val[2];		/* Alas, we are compiled so that "long long" is 32 bits */
d2558 22
a2579 24
	  /* Q: Why is the value passed through "extract_signed_integer",
	     while above, in "pa_do_registers_info" it isn't?
	     A: ? */
	  pa_register_look_aside (raw_regs, i + (j * 18), &raw_val[0]);

	  /* Even fancier % formats to prevent leading zeros
	     and still maintain the output in columns. */
	  if (!is_pa_2)
	    {
	      /* Being big-endian, on this machine the low bits
	         (the ones we want to look at) are in the second longword. */
	      long_val = extract_signed_integer (&raw_val[1], 4);
	      fprintf_filtered (stream, "%8.8s: %8x  ", REGISTER_NAME (i + (j * 18)), long_val);
	    }
	  else
	    {
	      /* raw_val = extract_signed_integer(&raw_val, 8); */
	      if (raw_val[0] == 0)
		fprintf_filtered (stream, "%8.8s:         %8x  ", REGISTER_NAME (i + (j * 18)),
				  raw_val[1]);
	      else
		fprintf_filtered (stream, "%8.8s: %8x%8.8x  ", REGISTER_NAME (i + (j * 18)),
				  raw_val[0], raw_val[1]);
	    }
d2583 1
a2583 1

d2585 1
a2585 1
    for (i = FP4_REGNUM; i < NUM_REGS; i++)	/* FP4_REGNUM == 72 */
d2654 10
a2663 10
      char raw_buf[MAX_REGISTER_RAW_SIZE];

      /* Get the data in raw format for the 2nd half.  */
      read_relative_register_raw_bytes (i + 1, raw_buf);

      /* Copy it into the appropriate part of the virtual buffer.  */
      memcpy (virtual_buffer + REGISTER_RAW_SIZE (i), raw_buf, REGISTER_RAW_SIZE (i));

      val_print (builtin_type_double, virtual_buffer, 0, 0, stream, 0,
		 1, 0, Val_pretty_default);
d2666 4
a2669 5
  else
    {
      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0, stream, 0,
		 1, 0, Val_pretty_default);
    }
d2741 1
a2741 1
         or the end of the stub.  */
d2758 2
a2759 2
      warning ("Unable to find branch in parameter relocation stub.\n");	/* purecov: deadcode */
      return 0;			/* purecov: deadcode */
d2763 1
a2763 1
  return 0;			/* purecov: deadcode */
d2803 1
a2803 1
         or the end of the stub.  */
d2820 2
a2821 2
      warning ("Unable to find branch in parameter relocation stub.\n");	/* purecov: deadcode */
      return 0;			/* purecov: deadcode */
d2825 1
a2825 1
  return 0;			/* purecov: deadcode */
d2846 1
a2846 1
#if 0
d2852 1
a2852 1
  return find_solib_trampoline_target (pc);
d2908 2
a2909 2
         the PLT entry for this function, not the address of the function
         itself.  Bit 31 has meaning too, but only for MPE.  */
d2943 1
a2943 1
     Hopefully this is correct most of the times. */
d2945 1
a2945 1
    {
d2950 1
a2950 1
      msym = lookup_minimal_symbol_by_pc (pc);
d2952 2
a2953 38
      if (msym == NULL || MSYMBOL_TYPE (msym) != mst_solib_trampoline)
	return orig_pc == pc ? 0 : pc & ~0x3;

      else if (msym != NULL && MSYMBOL_TYPE (msym) == mst_solib_trampoline)
	{
	  struct objfile *objfile;
	  struct minimal_symbol *msymbol;
	  int function_found = 0;

	  /* go look if there is another minimal symbol with the same name as 
	     this one, but with type mst_text. This would happen if the msym
	     is an actual trampoline, in which case there would be another
	     symbol with the same name corresponding to the real function */

	  ALL_MSYMBOLS (objfile, msymbol)
	  {
	    if (MSYMBOL_TYPE (msymbol) == mst_text
		&& STREQ (SYMBOL_NAME (msymbol), SYMBOL_NAME (msym)))
	      {
		function_found = 1;
		break;
	      }
	  }

	  if (function_found)
	    /* the type of msym is correct (mst_solib_trampoline), but
	       the unwind info is wrong, so set it to the correct value */
	    u->stub_unwind.stub_type = EXPORT;
	  else
	    /* the stub type info in the unwind is correct (this is not a
	       trampoline), but the msym type information is wrong, it
	       should be mst_text. So we need to fix the msym, and also
	       get out of this function */
	    {
	      MSYMBOL_TYPE (msym) = mst_text;
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }
	}
d2955 36
d2992 1
a2992 1
    }
d3015 1
a3015 1
         branch from the stub to the actual function.  */
d3034 1
a3034 1
         import stub to an export stub.
d3036 14
a3049 14
         It is impossible to determine the target of the branch via
         simple examination of instructions and/or data (consider
         that the address in the plabel may be the address of the
         bind-on-reference routine in the dynamic loader).

         So we have try an alternative approach.

         Get the name of the symbol at our current location; it should
         be a stub symbol with the same name as the symbol in the
         shared library.

         Then lookup a minimal symbol with the same name; we should
         get the minimal symbol for the target routine in the shared
         library as those take precedence of import/export stubs.  */
d3051 3
a3053 3
	  (curr_inst == 0xe2a00002) ||
	  (curr_inst == 0xeaa0d000) ||
	  (curr_inst == 0xeaa0d002))
d3076 2
a3077 2
         branch from the stub to the actual function.  */
      /*elz */
d3080 1
a3080 1
	       || (curr_inst & 0xffe0e000) == 0xe800A000)
d3084 4
a3087 4
         current stack pointer being the same as the stack
         pointer in the stub itself!  This is a branch on from the
         stub back to the original caller.  */
      /*else if ((curr_inst & 0xffe0e000) == 0xe840c000) */
d3107 1
a3107 1
	  return (read_memory_integer
d3112 1
a3112 1
         the original caller from the stub.  Used in dynamic executables.  */
d3119 1
a3119 1
	  return (read_memory_integer
d3124 1
a3124 1
         Keep looking.  */
d3218 1
a3218 1

d3234 1
a3234 1
  /* is this an FSTDS ? */
d3237 1
a3237 1
  /* is this an FSTWS ? */
d3268 1
a3268 1
  /* If we are not at the beginning of a function, then return now. */
d3324 1
a3324 1
         (only for HPC).  */
d3333 1
a3333 1

d3346 1
a3346 1
         the HP compilers never bother to save SP into the stack.  */
d3355 2
a3356 2
         Unfortunately args_stored only tells us that some arguments
         where stored into the stack.  Not how many or what kind!
d3358 3
a3360 3
         This is a kludge as on the HP compiler sets this bit and it
         never does prologue scheduling.  So once we see one, skip past
         all of them.   We have similar code for the fp arg stores below.
d3362 2
a3363 2
         FIXME.  Can still die if we have a mix of GR and FR argument
         stores!  */
d3384 1
a3384 1

d3390 1
a3390 1
         save.  */
d3401 3
a3403 3
         This is a kludge as on the HP compiler sets this bit and it
         never does prologue scheduling.  So once we see one, skip past
         all of them.  */
d3426 1
a3426 1
         instruction is in the delay slot of the first call/branch.  */
d3431 8
a3438 8
         arguments were stored into the stack (boo hiss).  This could
         cause this code to then skip a bunch of user insns (up to the
         first branch).

         To combat this we try to identify when args_stored was bogusly
         set and clear it.   We only do this when args_stored is nonzero,
         all other resources are accounted for, and nothing changed on
         this pass.  */
d3440 1
a3440 1
       && !(save_gr || save_fr || save_rp || save_sp || stack_remaining > 0)
d3445 1
a3445 1

d3457 1
a3457 1
  if (save_gr || (save_fr && !(restart_fr || restart_gr)))
d3484 1
a3484 1
    return 0;			/* Unknown */
d3493 16
a3508 16
    {
      /* this happens when the function has no prologue, because the way 
         find_pc_line works: elz. Note: this may not be a very good
         way to decide whether a function has a prologue or not, but
         it is the best I can do with the info available
         Also, this will work for functions like: int f()
         {
         return 2;
         }
         I.e. the bp will be inserted at the first open brace.
         For functions where the body is only one line written like this:
         int f()
         { return 2; }
         this will make the breakpoint to be at the last brace, after the body
         has been executed already. What's the point of stepping through a function
         without any variables anyway??  */
d3510 5
a3514 5
      if ((SYMBOL_LINE (f) > 0) && (SYMBOL_LINE (f) < sal.line))
	return pc;		/*no adjusment will be made */
      else
	return sal.end;		/* this is the end of the prologue */
    }
d3521 1
a3521 2
  else
    return pc;			/* no adjustment will be made */
d3537 4
a3540 4
  unsigned long inst;
  int offset;
  CORE_ADDR post_prologue_pc;
  char buf[4];
d3543 8
a3550 8
  /* Silently return the unaltered pc upon memory errors.
     This could happen on OSF/1 if decode_line_1 tries to skip the
     prologue for quickstarted shared library functions when the
     shared library is not yet mapped in.
     Reading target memory is slow over serial lines, so we perform
     this check only if the target has shared libraries.  */
  if (target_read_memory (pc, buf, 4))
    return pc;
d3553 3
a3555 3
  /* See if we can determine the end of the prologue via the symbol table.
     If so, then return either PC, or the PC after the prologue, whichever
     is greater.  */
d3557 1
a3557 1
  post_prologue_pc = after_prologue (pc);
d3559 2
a3560 2
  if (post_prologue_pc != 0)
    return max (pc, post_prologue_pc);
d3563 3
a3565 3
  /* Can't determine prologue from the symbol table, (this can happen if there
     is no debug information)  so we need to fall back on the old code, which
     looks at the instructions */
d3573 3
a3575 2
  else
    return (skip_prologue_hard_way (pc));
d3581 2
a3582 2
  /* Can't determine prologue from the symbol table, need to examine
     instructions.  */
d3584 6
a3589 11
  /* Skip the typical prologue instructions. These are the stack adjustment
     instruction and the instructions that save registers on the stack
     or in the gcc frame.  */
  for (offset = 0; offset < 100; offset += 4)
    {
      int status;

      status = read_memory_nobpt (pc + offset, buf, 4);
      if (status)
	memory_error (status, pc + offset);
      inst = extract_unsigned_integer (buf, 4);
d3591 9
a3599 4
      /* The alpha has no delay slots. But let's keep the lenient stuff,
         we might need it for something else in the future.  */
      if (lenient && 0)
	continue;
d3601 20
a3620 20
      if ((inst & 0xffff0000) == 0x27bb0000)	/* ldah $gp,n($t12) */
	continue;
      if ((inst & 0xffff0000) == 0x23bd0000)	/* lda $gp,n($gp) */
	continue;
      if ((inst & 0xffff0000) == 0x23de0000)	/* lda $sp,n($sp) */
	continue;
      else if ((inst & 0xfc1f0000) == 0xb41e0000
	       && (inst & 0xffff0000) != 0xb7fe0000)
	continue;		/* stq reg,n($sp) */
      /* reg != $zero */
      else if ((inst & 0xfc1f0000) == 0x9c1e0000
	       && (inst & 0xffff0000) != 0x9ffe0000)
	continue;		/* stt reg,n($sp) */
      /* reg != $zero */
      else if (inst == 0x47de040f)	/* bis sp,sp,fp */
	continue;
      else
	break;
    }
  return pc + offset;
d3651 2
a3652 2
			     + 32 * 4 + (NUM_REGS - FP0_REGNUM) * 8
			     + 6 * 4)))
d3751 1
a3751 1
         value for frame_saved_regs was computed above.  */
d3775 1
a3775 1
		  + extract_14 (inst);
d3782 3
a3784 3
         It emits an instruction to put the value of the start of
         the FP store area into %r1.  It then uses fstds,ma with
         a basereg of %r1 for the stores.
d3786 2
a3787 2
         HP CC emits them at the current stack pointer modifying
         the stack pointer as it stores each register.  */
d3793 1
a3793 1

d3804 2
a3805 2
	         we've set enough state that the GCC and HPCC code are
	         both handled in the same manner.  */
d3818 1
a3818 1
         instruction is in the delay slot of the first call/branch.  */
d3834 4
a3837 4
static char HP_ACC_EH_notify_hook[] = "__eh_notify_hook";
/* The name of the function to be used to set the hook value */
static char HP_ACC_EH_set_hook_value[] = "__eh_set_hook_value";
/* The name of the callback function in end.o */
d3839 11
a3849 13
/* Name of function in end.o on which a break is set (called by above) */
static char HP_ACC_EH_break[] = "__d_eh_break";
/* Name of flag (in end.o) that enables catching throws */
static char HP_ACC_EH_catch_throw[] = "__d_eh_catch_throw";
/* Name of flag (in end.o) that enables catching catching */
static char HP_ACC_EH_catch_catch[] = "__d_eh_catch_catch";
/* The enum used by aCC */
typedef enum
  {
    __EH_NOTIFY_THROW,
    __EH_NOTIFY_CATCH
  }
__eh_notification;
d3868 1
a3868 1
static struct symtab_and_line *break_callback_sal = NULL;
d3875 1
a3875 1
   1 => failure  */
d3880 3
a3882 3
  struct minimal_symbol *msymbol;
  char buf[4];			/* FIXME 32x64? */

d3893 2
a3894 2
  store_unsigned_integer (buf, 4, inferior_pid);	/* FIXME 32x64? */
  if (target_write_memory (anaddr, buf, 4))	/* FIXME 32x64? */
d3908 1
a3908 1
   1 => success          */
d3914 2
a3915 2
  struct cleanup *old_chain;
  struct cleanup *canonical_strings_chain = NULL;
d3917 3
a3919 3
  char *addr_start;
  char *addr_end = NULL;
  char **canonical = (char **) NULL;
d3921 3
a3923 3
  struct symbol *sym = NULL;
  struct minimal_symbol *msym = NULL;
  struct objfile *objfile;
d3931 2
a3932 2
  static int recurse = 0;
  if (recurse > 0)
d3948 1
a3948 1

d3961 1
a3961 1

d3964 1
a3964 1

d3971 1
a3971 1
    }
d3983 1
a3983 1
  /* This is always available in the SOM symbol dictionary if end.o is linked in */
d3989 2
a3990 2
    }
  else
d4006 1
a4006 1
     reliable one to test that an executable is linked shared. pai/1997-07-18 */
d4014 1
a4014 1
         of shl_findsym()) to find the plabel. */
d4018 1
a4018 1

d4021 1
a4021 1

d4023 3
a4025 3
      eh_notify_callback_addr = catch_errors ((int (*)PARAMS ((char *))) cover_find_stub_with_shl_get,
					      (char *) &args,
					      message, RETURN_MASK_ALL);
d4027 1
a4027 1

d4029 1
a4029 1

d4031 7
a4037 7
	{
	  /* We can get here either if there is no plabel in the export list
	     for the main image, or if something strange happened (??) */
	  warning ("Couldn't find a plabel (indirect function label) for the exception callback.");
	  warning ("GDB will not be able to intercept exception events.");
	  return 0;
	}
d4043 1
a4043 1
  /* This should also be available in the SOM symbol dict. if end.o linked in */
d4049 1
a4049 1
    }
d4061 2
a4062 2
		       VAR_NAMESPACE, 0, (struct symtab **) NULL);
  if (sym)			/* sometimes present in debug info */
d4067 1
a4067 2
  else
    /* otherwise look in SOM symbol dict. */
d4071 4
a4074 4
	{
	  eh_catch_catch_addr = SYMBOL_VALUE_ADDRESS (msym);
	  hp_cxx_exception_support = 1;
	}
d4076 6
a4081 6
	{
	  warning ("Unable to enable interception of exception catches.");
	  warning ("Executable may not have been compiled debuggable with HP aCC.");
	  warning ("Suggest linking executable with -g (link in /opt/langtools/lib/end.o).");
	  return 0;
	}
d4086 2
a4087 2
		       VAR_NAMESPACE, 0, (struct symtab **) NULL);
  if (sym)			/* sometimes present in debug info */
d4092 1
a4092 2
  else
    /* otherwise look in SOM symbol dict. */
d4096 4
a4099 4
	{
	  eh_catch_throw_addr = SYMBOL_VALUE_ADDRESS (msym);
	  hp_cxx_exception_support = 1;
	}
d4101 6
a4106 6
	{
	  warning ("Unable to enable interception of exception throws.");
	  warning ("Executable may not have been compiled debuggable with HP aCC.");
	  warning ("Suggest linking executable with -g (link in /opt/langtools/lib/end.o).");
	  return 0;
	}
d4109 2
a4110 2
  /* Set the flags */
  hp_cxx_exception_support = 2;	/* everything worked so far */
d4124 1
a4124 1
   address was found. */
d4126 1
a4126 1
struct symtab_and_line *
d4128 2
a4129 2
     enum exception_event_kind kind;
     int enable;
d4139 7
a4145 7
    case 0:
      /* Assuming no HP support at all */
      return NULL;
    case 1:
      /* HP support should be present, but something went wrong */
      return (struct symtab_and_line *) -1;	/* yuck! */
      /* there may be other cases in the future */
d4147 1
a4147 1

d4149 1
a4149 1
  store_unsigned_integer (buf, 4, enable ? eh_notify_callback_addr : 0);	/* FIXME 32x64 problem */
d4151 1
a4151 1
  if (target_write_memory (eh_notify_hook_addr, buf, 4))	/* FIXME 32x64 problem */
d4155 1
a4155 1
      return (struct symtab_and_line *) -1;
d4159 1
a4159 1
      /* Ensure that __d_pid is set up correctly -- end.c code checks this. :-( */
d4161 4
a4164 4
	{
	  if (setup_d_pid_in_inferior ())
	    return (struct symtab_and_line *) -1;
	}
d4166 4
a4169 4
	{
	  warning ("Internal error: Invalid inferior pid?  Cannot intercept exception events.");	/* purecov: deadcode */
	  return (struct symtab_and_line *) -1;		/* purecov: deadcode */
	}
d4171 1
a4171 1

d4174 18
a4191 18
    case EX_EVENT_THROW:
      store_unsigned_integer (buf, 4, enable ? 1 : 0);
      if (target_write_memory (eh_catch_throw_addr, buf, 4))	/* FIXME 32x64? */
	{
	  warning ("Couldn't enable exception throw interception.");
	  return (struct symtab_and_line *) -1;
	}
      break;
    case EX_EVENT_CATCH:
      store_unsigned_integer (buf, 4, enable ? 1 : 0);
      if (target_write_memory (eh_catch_catch_addr, buf, 4))	/* FIXME 32x64? */
	{
	  warning ("Couldn't enable exception catch interception.");
	  return (struct symtab_and_line *) -1;
	}
      break;
    default:			/* purecov: deadcode */
      error ("Request to enable unknown or unsupported exception event.");	/* purecov: deadcode */
d4193 1
a4193 1

d4199 1
a4199 1
  INIT_SAL (break_callback_sal);
d4204 1
a4204 1

d4208 1
a4208 1
/* Record some information about the current exception event */
d4210 2
a4211 3
/* Convenience struct */
static struct symtab_and_line null_symtab_and_line =
{NULL, 0, 0, 0};
d4216 1
a4216 1
   in the future */
d4220 3
a4222 3
  CORE_ADDR event_kind;
  CORE_ADDR throw_addr;
  CORE_ADDR catch_addr;
d4226 1
a4226 1
  curr_frame = get_current_frame ();
d4241 4
a4244 4
     1. event kind catch or throw
     2. the target address if known
     3. a flag -- not sure what this is. pai/1997-07-17 */
  event_kind = read_register (ARG0_REGNUM);
d4249 3
a4251 3
     __d_eh_notify_callback which is called by
     __notify_throw which is called
     from user code.
d4253 5
a4257 5
     __d_eh_notify_callback which is called by
     <stackwalking stuff> which is called by
     __throw__<stuff> or __rethrow_<stuff> which is called
     from user code. */
  /* FIXME: Don't use such magic numbers; search for the frames */
d4371 1
a4371 1
   at that PC, user switches threads -- YES
d4374 4
a4377 4
   breakpoint, deleted the breakpoint and then gotten another
   hit on that same breakpoint on another thread which
   actually hit before the delete. (FIXME in breakpoint.c
   so that "dead" breakpoints are ignored?) -- NO
d4384 1
a4384 1
hppa_prepare_to_proceed ()
d4389 1
a4389 1
  old_thread = hppa_switched_threads (inferior_pid);
d4396 1
a4396 1
      CORE_ADDR old_pc = read_pc ();
d4401 1
a4401 1
      inferior_pid = old_thread;
d4403 2
a4404 2
      new_pc = read_pc ();
      if (new_pc != old_pc	/* If at same pc, no need */
d4406 1
a4406 1
	{
d4408 1
a4408 1
	     Return TRUE, finishing switch to "old_thread". */
d4412 1
a4412 1
	  printf ("---> PREPARE_TO_PROCEED (was %d, now %d)!\n",
d4415 1
a4415 1

d4417 1
a4417 1
	}
d4421 1
a4421 1
      new_pc = read_pc ();	/* Re-prime register cache */
@


1.1.1.6
log
@import gdb-1999-07-19 snapshot
@
text
@a2129 1
#ifndef GDB_TARGET_IS_HPPA_20W
a2146 1
#endif /* GDB_TARGET_IS_HPPA_20W */
d2517 1
a2517 2
  /* Alas, we are compiled so that "long long" is 32 bits */
  long raw_val[2];
a2518 1
  int rows = 24, columns = 3;
d2520 1
a2520 1
  for (i = 0; i < rows; i++)
d2522 1
a2522 1
      for (j = 0; j < columns; j++)
a2523 3
	  /* We display registers in column-major order.  */
	  int regnum = i + j * rows;

d2527 1
a2527 1
	  pa_register_look_aside (raw_regs, regnum, &raw_val[0]);
d2536 2
a2537 2
	      printf_filtered ("%8.8s: %8x",
			       REGISTER_NAME (regnum), long_val);
d2543 2
a2544 2
		printf_filtered ("%8.8s:         %8x",
				 REGISTER_NAME (regnum), raw_val[1]);
d2546 1
a2546 1
		printf_filtered ("%8.8s: %8x%8.8x", REGISTER_NAME (regnum),
@


1.1.1.7
log
@import gdb-1999-08-02 snapshot
@
text
@a136 1
    CORE_ADDR return_val;
d140 1
a140 1
static int cover_find_stub_with_shl_get (PTR);
d1917 3
a1919 2
static int
cover_find_stub_with_shl_get (PTR args_untyped)
d1921 1
a1921 3
  args_for_find_stub *args = args_untyped;
  args->return_val = find_stub_with_shl_get (args->msym, args->solib_handle);
  return 0;
d1924 1
d2522 1
a2522 1
  int rows = 48, columns = 2;
d2543 1
a2543 1
	      printf_filtered ("%10.10s: %8x   ",
d2550 1
a2550 1
		printf_filtered ("%10.10s:         %8x   ",
d2553 1
a2553 2
		printf_filtered ("%10.10s: %8x%8.8x   ",
				 REGISTER_NAME (regnum),
d3889 1
a3889 1
static CORE_ADDR eh_notify_hook_addr = 0;
d3891 1
a3891 1
static CORE_ADDR eh_notify_callback_addr = 0;
d3893 1
a3893 1
static CORE_ADDR eh_break_addr = 0;
d3895 1
a3895 1
static CORE_ADDR eh_catch_catch_addr = 0;
d3897 1
a3897 1
static CORE_ADDR eh_catch_throw_addr = 0;
d3899 1
a3899 1
static struct symtab_and_line *break_callback_sal = 0;
a4051 1
      args.return_val = 0;
d4054 3
a4056 3
      catch_errors (cover_find_stub_with_shl_get, (PTR) &args, message,
		    RETURN_MASK_ALL);
      eh_notify_callback_addr = args.return_val;
@


1.1.1.8
log
@import gdb-1999-08-16 snapshot
@
text
@d189 29
d225 13
d256 13
d334 29
a3211 1
    case 0x27:
a3215 1
    case 0x2f:
a3222 1
    case 0x3b:
d3238 1
a3238 10
  if ((inst >> 26) == 0x1a || (inst >> 26) == 0x1b
      || (inst >> 26) == 0x1f
      || ((inst >> 26) == 0x1f
	  && ((inst >> 6) == 0xa)))
    return extract_5R_store (inst);

  /* Does it look like a std?  */
  if ((inst >> 26) == 0x1c
      || ((inst >> 26) == 0x03
	  && ((inst >> 6) & 0xf) == 0xb))
d3247 1
a3247 4
  if ((inst >> 26) == 0x19 || (inst >> 26) == 0x18
      || ((inst >> 26) == 0x3
	  && (((inst >> 6) & 0xf) == 0x8
	      || (inst >> 6) & 0xf) == 0x9))
d3265 1
a3265 1
  /* is this an FSTD ? */
d3268 1
a3268 3
  if ((inst & 0xfc000002) == 0x70000002)
    return extract_5R_store (inst);
  /* is this an FSTW ? */
a3270 2
  if ((inst & 0xfc000002) == 0x7c000000)
    return extract_5R_store (inst);
d3372 2
a3373 3
      /* There are limited ways to store the return pointer into the
	 stack.  */
      if (inst == 0x6bc23fd9 || inst == 0x0fc212c1)
d3500 5
a3504 2
/* Return the address of the PC after the last prologue instruction if
   we can determine it from the debug symbols.  Else return zero.  */
a3513 3
  /* If we can not find the symbol in the partial symbol table, then
     there is no hope we can determine the function's start address
     with this code.  */
d3515 5
a3519 1
    return 0;
a3520 1
  /* Get the line associated with FUNC_ADDR.  */
a3522 10
  /* There are only two cases to consider.  First, the end of the source line
     is within the function bounds.  In that case we return the end of the
     source line.  Second is the end of the source line extends beyond the
     bounds of the current function.  We need to use the slow code to
     examine instructions in that case. 

     Anything else is simply a bug elsewhere.  Fixing it here is absolutely
     the wrong thing to do.  In fact, it should be entirely possible for this
     function to always return zero since the slow instruction scanning code
     is supposed to *always* work.  If it does not, then it is a bug.  */
d3524 28
a3551 1
    return sal.end;
d3553 1
a3553 1
    return 0;
d3574 11
a3590 6
  /* If after_prologue returned a useful address, then use it.  Else
     fall back on the instruction skipping code.

     Some folks have claimed this causes problems because the breakpoint
     may be the first instruction of the prologue.  If that happens, then
     the instruction skipping code has a bug that needs to be fixed.  */
d3593 12
d3607 46
d3753 1
a3753 1
     For optimized GCC code we're faced with problems.  GCC will schedule
@


1.1.1.9
log
@import gdb-1999-08-23 snapshot
@
text
@a131 1
static void record_text_segment_lowaddr PARAMS ((bfd *, asection *, void *));
a312 14
static CORE_ADDR low_text_segment_address;

static void
record_text_segment_lowaddr (abfd, section, ignored)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
     PTR ignored ATTRIBUTE_UNUSED;
{
  if ((section->flags & (SEC_ALLOC | SEC_LOAD | SEC_READONLY)
       == (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
      && section->vma < low_text_segment_address)
    low_text_segment_address = section->vma;
}

a328 16
      low_text_segment_address = -1;

      /* If addresses are 64 bits wide, then unwinds are supposed to
	 be segment relative offsets instead of absolute addresses.  */
      if (TARGET_PTR_BIT == 64)
	{
	  bfd_map_over_sections (objfile->obfd,
				 record_text_segment_lowaddr, (PTR) NULL);

	  /* ?!? Mask off some low bits.  Should this instead subtract
	     out the lowest section's filepos or something like that?
	     This looks very hokey to me.  */
	  low_text_segment_address &= ~0xfff;
	  text_offset += low_text_segment_address;
	}

a512 1
      obj_private->dp = 0;
d767 1
a767 1
    return (TARGET_PTR_BIT == 64 ? -16 : -20);
d834 1
a834 2
    return read_memory_integer (frame->frame + PC_REGNUM * 4,
				TARGET_PTR_BIT / 8) & ~0x3;
d863 1
a863 2
	  if (read_memory_integer (saved_regs.regs[FLAGS_REGNUM],
				   TARGET_PTR_BIT / 8) & 0x2)
d865 1
a865 2
	      pc = read_memory_integer (saved_regs.regs[31],
					TARGET_PTR_BIT / 8) & ~0x3;
d872 1
a872 2
		pc = read_memory_integer (saved_regs.regs[RP_REGNUM],
					  TARGET_PTR_BIT / 8) & ~0x3;
d875 1
a875 2
	    pc = read_memory_integer (saved_regs.regs[RP_REGNUM],
				      TARGET_PTR_BIT / 8) & ~0x3;
d899 1
a899 2
	  if (read_memory_integer (saved_regs.regs[FLAGS_REGNUM],
				   TARGET_PTR_BIT / 8) & 0x2)
d901 1
a901 2
	      pc = read_memory_integer (saved_regs.regs[31],
					TARGET_PTR_BIT / 8) & ~0x3;
d908 1
a908 2
		pc = read_memory_integer (saved_regs.regs[RP_REGNUM],
					  TARGET_PTR_BIT / 8) & ~0x3;
d911 1
a911 2
	    pc = read_memory_integer (saved_regs.regs[RP_REGNUM],
				      TARGET_PTR_BIT / 8) & ~0x3;
d921 1
a921 2
	  pc = read_memory_integer (frame->frame + rp_offset,
				    TARGET_PTR_BIT / 8) & ~0x3;
d1076 1
a1076 2
    frame_base = read_memory_integer (frame->frame + SP_REGNUM * 4,
				      TARGET_PTR_BIT / 8);
d1110 1
a1110 1
      return read_memory_integer (frame_base, TARGET_PTR_BIT / 8);
d1167 1
a1167 1
	  return read_memory_integer (tmp_frame->frame, TARGET_PTR_BIT / 8);
d1205 1
a1205 2
		   && (read_memory_integer (saved_regs.regs[FLAGS_REGNUM],
					    TARGET_PTR_BIT / 8)
d1213 1
a1213 2
		  return read_memory_integer (saved_regs.regs[FP_REGNUM],
					      TARGET_PTR_BIT / 8);
d1221 1
a1221 2
	  return read_memory_integer (saved_regs.regs[FP_REGNUM],
				      TARGET_PTR_BIT / 8);
d1237 1
a1237 2
	       && (read_memory_integer (saved_regs.regs[FLAGS_REGNUM],
					TARGET_PTR_BIT / 8)
d1245 1
a1245 2
	      return read_memory_integer (saved_regs.regs[FP_REGNUM],
					  TARGET_PTR_BIT / 8);
d1332 1
a1332 1
  CORE_ADDR int_buffer;
d1367 1
a1367 7

  /* The 32bit and 64bit ABIs save the return pointer into different
     stack slots.  */
  if (REGISTER_SIZE == 8)
    write_memory (sp - 16, (char *) &int_buffer, REGISTER_SIZE);
  else
    write_memory (sp - 20, (char *) &int_buffer, REGISTER_SIZE);
d1370 1
a1370 1
  write_memory (sp, (char *) &int_buffer, REGISTER_SIZE);
d1374 1
a1374 1
  sp += 2 * REGISTER_SIZE;
d1380 1
a1380 3
  /* This is not necessary for the 64bit ABI.  In fact it is dangerous.  */
  if (REGISTER_SIZE != 8)
    sp += 4;
d1404 1
a1404 6
  /* The 32bit and 64bit ABIs save RP into different locations.  */
  if (REGISTER_SIZE == 8)
    frame_saved_regs->regs[RP_REGNUM] = (fp - 16) & ~0x3;
  else
    frame_saved_regs->regs[RP_REGNUM] = (fp - 20) & ~0x3;

d1406 1
d1408 1
a1408 3
  frame_saved_regs->regs[1] = fp + (2 * REGISTER_SIZE);

  for (fp += 3 * REGISTER_SIZE, i = 3; i < 32; i++)
d1413 1
a1413 1
	  fp += REGISTER_SIZE;
d1417 1
a1417 4
  /* This is not necessary or desirable for the 64bit ABI.  */
  if (REGISTER_SIZE != 8)
    fp += 4;

d1422 5
a1426 5
  frame_saved_regs->regs[SAR_REGNUM] = fp + REGISTER_SIZE;
  frame_saved_regs->regs[PCOQ_HEAD_REGNUM] = fp + 2 * REGISTER_SIZE;
  frame_saved_regs->regs[PCSQ_HEAD_REGNUM] = fp + 3 * REGISTER_SIZE;
  frame_saved_regs->regs[PCOQ_TAIL_REGNUM] = fp + 4 * REGISTER_SIZE;
  frame_saved_regs->regs[PCSQ_TAIL_REGNUM] = fp + 5 * REGISTER_SIZE;
d1448 1
a1448 2
      write_register (regnum, read_memory_integer (fsr.regs[regnum],
		      REGISTER_SIZE));
d1459 1
a1459 2
		    read_memory_integer (fsr.regs[IPSW_REGNUM],
					 REGISTER_SIZE));
d1463 1
a1463 2
		    read_memory_integer (fsr.regs[SAR_REGNUM],
					 REGISTER_SIZE));
d1468 1
a1468 2
      npc = read_memory_integer (fsr.regs[PCOQ_TAIL_REGNUM],
				 REGISTER_SIZE);
d1478 1
a1478 1
  write_register (FP_REGNUM, read_memory_integer (fp, REGISTER_SIZE));
d1528 1
a1528 2
  CORE_ADDR new_pc = read_memory_integer (fsr->regs[PCOQ_HEAD_REGNUM],
					  TARGET_PTR_BIT / 8);
d1546 1
a1546 2
  write_register (21, read_memory_integer (fsr->regs[PCSQ_HEAD_REGNUM],
					   REGISTER_SIZE));
d1575 1
a1575 14
/* This function pushes a stack frame with arguments as part of the
   inferior function calling mechanism.

   For PAs the stack always grows to higher addresses.  However the arguments
   may grow to either higher or lower addresses depending on which ABI is
   currently in use.

   We simply allocate the appropriate amount of stack space and put
   arguments into their proper slots.  The call dummy code will copy
   arguments into registers as needed by the ABI.

   Note for the PA64 ABI we load up the argument pointer since the caller
   must provide the argument pointer to the callee.  */
   
d1586 2
d1589 41
a1629 3
  /* array of arguments' lengths: real lengths in bytes, not aligned to
     word size */
  int *lengths = (int *) alloca (nargs * sizeof (int));
d1631 2
a1632 3
  /* The value of SP as it was passed into this function after
     aligning.  */
  CORE_ADDR orig_sp = STACK_ALIGN (sp);
d1634 12
a1645 2
  /* The number of stack bytes occupied by the current argument.  */
  int bytes_reserved;
d1647 2
a1648 2
  /* The total number of bytes reserved for the arguments.  */
  int cum_bytes_reserved = 0;
d1650 3
a1652 2
  /* Similarly, but aligned.  */
  int cum_bytes_aligned = 0;
d1655 13
a1667 1
  /* Iterate over each argument provided by the user.  */
d1670 1
d1673 4
a1676 3
      /* Align the size of the argument to the word size for this
	 target.  */
      bytes_reserved = (lengths[i] + REGISTER_SIZE - 1) & -REGISTER_SIZE;
a1677 1
#ifdef ARGS_GROW_DOWNWARD
a1678 12
#else
      /* If the arguments grow towards lower addresses, then we want
	 offset[i] to point to the start of the argument rather than
	 the end of the argument.  */
      offset[i] = cum_bytes_reserved;

      offset[i] += (lengths[i] < REGISTER_SIZE
		    ? REGISTER_SIZE - lengths[i] : 0);
#endif

      /* If the argument is a double word argument, then it needs to be
	 double word aligned. 
d1680 1
a1680 3
	 ?!? I do not think this code is correct when !ARGS_GROW_DOWNWAR.  */
      if ((bytes_reserved == 2 * REGISTER_SIZE)
	   && (offset[i] % 2 * REGISTER_SIZE))
d1683 9
a1691 9
	  /* BYTES_RESERVED is already aligned to the word, so we put
	     the argument at one word more down the stack.

	     This will leave one empty word on the stack, and one unused
	     register as mandated by the ABI.  */
	  new_offset = ((offset[i] + 2 * REGISTER_SIZE - 1)
			& -(2 * REGISTER_SIZE));

	  if ((new_offset - offset[i]) >= 2 * REGISTER_SIZE)
d1693 2
a1694 2
	      bytes_reserved += REGISTER_SIZE;
	      offset[i] += REGISTER_SIZE;
d1702 3
a1704 6
  /* CUM_BYTES_RESERVED already accounts for all the arguments
     passed by the user.  However, the ABIs mandate minimum stack space
     allocations for outgoing arguments.

     The ABIs also mandate minimum stack alignments which we must
     preserve.  */
d1706 1
a1706 3
  sp += max (cum_bytes_aligned, REG_PARM_STACK_SPACE);

  /* Now write each of the args at the proper offset down the stack.
d1708 1
a1708 9
     The two ABIs write arguments in different directions using different
     starting points.  What fun. 

     ?!? We need to promote values to a full register instead of skipping
     words in the stack.  */
#ifndef ARGS_GROW_DOWNWARD
  for (i = 0; i < nargs; i++)
    write_memory (orig_sp + offset[i], VALUE_CONTENTS (args[i]), lengths[i]);
#else
a1710 1
#endif
d1712 2
a1713 2
  /* If a structure has to be returned, set up register 28 to hold its
     address */
d1717 1
a1717 17
#ifndef ARGS_GROW_DOWNWARD
  /* For the PA64 we must pass a pointer to the outgoing argument list.
     The ABI mandates that the pointer should point to the first byte of
     storage beyond the register flushback area.

     However, the call dummy expects the outgoing argument pointer to
     be passed in register %r4.  */
  write_register (4, orig_sp + REG_PARM_STACK_SPACE);

  /* ?!? This needs further work.  We need to set up the global data
     pointer for this procedure.  This assumes the same global pointer
     for every procedure.   The call dummy expects the dp value to
     be passed in register %r6.  */
  write_register (6, read_register (27));
#endif
  
  /* The stack will have 32 bytes of additional space for a frame marker.  */
a1891 97
#ifdef GDB_TARGET_IS_HPPA_20W
  /* We currently use completely different code for the PA2.0W inferior
     function call sequences.  This needs to be cleaned up.  */
  {
    CORE_ADDR pcsqh, pcsqt, pcoqh, pcoqt, sr5;
    struct target_waitstatus w;
    int inst1, inst2;
    char buf[4];
    int status;
    struct objfile *objfile;

    /* We can not modify the PC space queues directly, so we start
       up the inferior and execute a couple instructions to set the
       space queues so that they point to the call dummy in the stack.  */
    pcsqh = read_register (PCSQ_HEAD_REGNUM);
    sr5 = read_register (SR5_REGNUM);
    if (1)
      {
        pcoqh = read_register (PCOQ_HEAD_REGNUM);
        pcoqt = read_register (PCOQ_TAIL_REGNUM);
        if (target_read_memory (pcoqh, buf, 4) != 0)
          error ("Couldn't modify space queue\n");
        inst1 = extract_unsigned_integer (buf, 4);

        if (target_read_memory (pcoqt, buf, 4) != 0)
          error ("Couldn't modify space queue\n");
        inst2 = extract_unsigned_integer (buf, 4);

        /* BVE (r1) */
        *((int *) buf) = 0xe820d000;
        if (target_write_memory (pcoqh, buf, 4) != 0)
          error ("Couldn't modify space queue\n");

        /* NOP */
        *((int *) buf) = 0x08000240;
        if (target_write_memory (pcoqt, buf, 4) != 0)
          {
            *((int *) buf) = inst1;
            target_write_memory (pcoqh, buf, 4);
            error ("Couldn't modify space queue\n");
          }

        write_register (1, pc);

        /* Single step twice, the BVE instruction will set the space queue
	   such that it points to the PC value written immediately above
	   (ie the call dummy).  */
        resume (1, 0);
        target_wait (inferior_pid, &w);
        resume (1, 0);
        target_wait (inferior_pid, &w);

	/* Restore the two instructions at the old PC locations.  */
        *((int *) buf) = inst1;
        target_write_memory (pcoqh, buf, 4);
        *((int *) buf) = inst2;
        target_write_memory (pcoqt, buf, 4);
      }

    /* The call dummy wants the ultimate destination address initially
       in register %r5.  */
    write_register (5, fun);

    /* We need to see if this objfile has a different DP value than our
       own (it could be a shared library for example.  */
    ALL_OBJFILES (objfile)
      {
	struct obj_section *s;
	obj_private_data_t *obj_private;

	/* See if FUN is in any section within this shared library.  */
	for (s = objfile->sections; s < objfile->sections_end; s++)
	  if (s->addr <= fun && fun < s->endaddr)
	    break;

        if (s >= objfile->sections_end)
	  continue;

	obj_private = (obj_private_data_t *) objfile->obj_private;
	
	/* The DP value may be different for each objfile.  But within an
	   objfile each function uses the same dp value.  Thus we do not need
	   to grope around the opd section looking for dp values.

	   ?!? This is not strictly correct since we may be in a shared library
	   and want to call back into the main program.  To make that case
	   work correctly we need to set obj_private->dp for the main program's
	   objfile, then remove this conditional.  */
	if (obj_private->dp)
	  write_register (27, obj_private->dp);
	break;
      }
    return pc;
  }
#endif

#ifndef GDB_TARGET_IS_HPPA_20W
d1912 1
a1912 2
      write_register (19, read_memory_integer ((fun & ~0x3) + 4,
		      REGISTER_SIZE));
d1916 1
a1916 2
      fun = (CORE_ADDR) read_memory_integer (fun & ~0x3,
					     TARGET_PTR_BIT / 8);
d2047 1
d2065 1
a2121 1
#endif
d2793 11
d2858 1
a2858 1
	pc = (CORE_ADDR) read_memory_integer (pc & ~0x3, TARGET_PTR_BIT / 8);
d2863 1
a2863 1
      pc = (CORE_ADDR) read_memory_integer (pc & ~0x3, TARGET_PTR_BIT / 8);
d3055 1
a3055 1
		  (read_register (SP_REGNUM) - 24, TARGET_PTR_BIT / 8)) & ~0x3;
d3067 1
a3067 1
		  (read_register (SP_REGNUM) - 24, TARGET_PTR_BIT / 8)) & ~0x3;
d3534 3
a3536 14
       && frame_info->pc <= (frame_info->frame
			     /* A call dummy is sized in words, but it is
				actually a series of instructions.  Account
				for that scaling factor.  */
			     + ((REGISTER_SIZE / INSTRUCTION_SIZE)
				* CALL_DUMMY_LENGTH)
			     /* Similarly we have to account for 64bit
				wide register saves.  */
			     + (32 * REGISTER_SIZE)
			     /* We always consider FP regs 8 bytes long.  */
			     + (NUM_REGS - FP0_REGNUM) * 8
			     /* Similarly we have to account for 64bit
				wide register saves.  */
			     + (6 * REGISTER_SIZE))))
d3548 1
a3548 2
	      = read_memory_integer (frame_info->frame + SP_REGNUM * 4,
				     TARGET_PTR_BIT / 8);
a3884 1
#ifndef GDB_TARGET_IS_HPPA_20W
a3927 1
#endif
@


1.1.1.10
log
@import gdb-1999-08-30 snapshot
@
text
@d61 3
d162 1
a162 1
  return (TYPE_LENGTH (type) > 2 * REGISTER_SIZE);
d461 2
a462 2
      elf_unwind_size = bfd_section_size (objfile->obfd, elf_unwind_sec);
      elf_unwind_entries = elf_unwind_size / UNWIND_ENTRY_SIZE;
d579 1
a579 1
	  error ("Internal error reading unwind information.");
d655 1
a655 3
   appears that PC is in a linker stub.

   ?!? Need to handle stubs which appear in PA64 code.  */
a868 21
  if ((frame->pc >= frame->frame
       && frame->pc <= (frame->frame
                        /* A call dummy is sized in words, but it is
                           actually a series of instructions.  Account
                           for that scaling factor.  */
                        + ((REGISTER_SIZE / INSTRUCTION_SIZE)
                           * CALL_DUMMY_LENGTH)
                        /* Similarly we have to account for 64bit
                           wide register saves.  */
                        + (32 * REGISTER_SIZE)
                        /* We always consider FP regs 8 bytes long.  */
                        + (NUM_REGS - FP0_REGNUM) * 8
                        /* Similarly we have to account for 64bit
                           wide register saves.  */
                        + (6 * REGISTER_SIZE))))
    {
      return read_memory_integer ((frame->frame
				   + (TARGET_PTR_BIT == 64 ? -16 : -20)),
				  TARGET_PTR_BIT / 8) & ~0x3;
    }

d1893 1
a1893 1
    error ("call to __d_shl_get failed, error code is %d", err_value);
a2822 4
  minsym = lookup_minimal_symbol_by_pc (pc);
  if (minsym && strcmp (SYMBOL_NAME (minsym), ".stub") == 0)
    return 1;

d2868 2
a2869 2
      warning ("Unable to find branch in parameter relocation stub.\n");
      return 0;
d2873 1
a2873 1
  return 0;
d2930 2
a2931 2
      warning ("Unable to find branch in parameter relocation stub.\n");
      return 0;
d2935 1
a2935 1
  return 0;
a3248 4
  /* std,ma X,D(sp) */
  if ((inst & 0xffe00008) == 0x73c00008)
    return (inst & 0x1 ? -1 << 16 : 0) | (((inst >> 4) & 0x3ff) << 3);

d3464 1
a3464 1
      /* These are the only ways we save SP into the stack.  At this time
d3466 1
a3466 2
      if ((inst & 0xffffc000) == 0x6fc10000
	  || (inst & 0xffffc00c) == 0x73c10008)
d3791 2
a3792 3
      /* There are limited ways to store the return pointer into the
	 stack.  */
      if (inst == 0x6bc23fd9 || inst == 0x0fc212c1)
d3798 4
a3801 8
      /* Note if we saved SP into the stack.  This also happens to indicate
	 the location of the saved frame pointer.  */
      if ((inst & 0xffffc000) == 0x6fc10000
          || (inst & 0xffffc00c) == 0x73c10008)
	{
	  frame_saved_regs->regs[FP_REGNUM] = frame_info->frame;
	  save_sp = 0;
	}
a3813 3
	  /* A std has explicit post_modify forms.  */
	  else if ((inst & 0xfc00000c0) == 0x70000008)
	    frame_saved_regs->regs[reg] = frame_info->frame;
a3815 9
	      CORE_ADDR offset;

	      if ((inst >> 26) == 0x1c)
		offset = (inst & 0x1 ? -1 << 16 : 0) | (((inst >> 4) & 0x3ff) << 3);
	      else if ((inst >> 26) == 0x03)
		offset = low_sign_extend (inst & 0x1f, 5);
	      else
		offset = extract_14 (inst);

d3819 1
a3819 1
		  = frame_info->frame + offset;
d3822 2
a3823 2
		  = (frame_info->frame + (u->Total_frame_size << 3)
		     + offset);
d4222 2
a4223 2
	  warning ("Internal error: Invalid inferior pid?  Cannot intercept exception events.");
	  return (struct symtab_and_line *) -1;
d4245 2
a4246 2
    default:
      error ("Request to enable unknown or unsupported exception event.");
@


1.1.1.11
log
@import gdb-1999-09-08 snapshot
@
text
@d422 3
a424 3
  asection *unwind_sec, *stub_unwind_sec;
  unsigned unwind_size, stub_unwind_size, total_size;
  unsigned index, unwind_entries;
d438 5
a442 4
  /* For reasons unknown the HP PA64 tools generate multiple unwinder
     sections in a single executable.  So we just iterate over every
     section in the BFD looking for unwinder sections intead of trying
     to do a lookup with bfd_get_section_by_name. 
d444 7
a450 6
     First determine the total size of the unwind tables so that we
     can allocate memory in a nice big hunk.  */
  total_entries = 0;
  for (unwind_sec = objfile->obfd->sections;
       unwind_sec;
       unwind_sec = unwind_sec->next)
d452 3
a454 5
      if (strcmp (unwind_sec->name, "$UNWIND_START$") == 0
	  || strcmp (unwind_sec->name, ".PARISC.unwind") == 0)
	{
	  unwind_size = bfd_section_size (objfile->obfd, unwind_sec);
	  unwind_entries = unwind_size / UNWIND_ENTRY_SIZE;
d456 9
a464 2
	  total_entries += unwind_entries;
	}
a466 4
  /* Now compute the size of the stub unwinds.  Note the ELF tools do not
     use stub unwinds at the curren time.  */
  stub_unwind_sec = bfd_get_section_by_name (objfile->obfd, "$UNWIND_END$");

d479 1
a479 1
  total_entries += stub_entries;
d487 1
a487 2
  /* Now read in each unwind section and internalize the standard unwind
     entries.  */
d489 6
a494 15
  for (unwind_sec = objfile->obfd->sections;
       unwind_sec;
       unwind_sec = unwind_sec->next)
    {
      if (strcmp (unwind_sec->name, "$UNWIND_START$") == 0
	  || strcmp (unwind_sec->name, ".PARISC.unwind") == 0)
	{
	  unwind_size = bfd_section_size (objfile->obfd, unwind_sec);
	  unwind_entries = unwind_size / UNWIND_ENTRY_SIZE;

	  internalize_unwinds (objfile, &ui->table[index], unwind_sec,
			       unwind_entries, unwind_size, text_offset);
	  index += unwind_entries;
	}
    }
d496 1
a496 1
  /* Now read in and internalize the stub unwind entries.  */
d3275 1
a3275 1
    return (inst & 0x1 ? -1 << 13 : 0) | (((inst >> 4) & 0x3ff) << 3);
a3705 1
  int final_iteration;
d3808 1
a3808 3
  final_iteration = 0;
  while ((save_gr || save_fr || save_rp || save_sp || stack_remaining > 0)
	 && pc <= frame_info->pc)
d3856 1
a3856 1
		offset = (inst & 0x1 ? -1 << 13 : 0) | (((inst >> 4) & 0x3ff) << 3);
d3911 3
a3913 2
      /* Quit if we hit any kind of branch the previous iteration.
      if (final_iteration)
a3914 5

      /* We want to look precisely one instruction beyond the branch
	 if we have not found everything yet.  */
      if (is_branch (inst))
	final_iteration = 1;
@


1.1.1.12
log
@import gdb-1999-09-21
@
text
@d344 2
a345 6
	 be segment relative offsets instead of absolute addresses. 

	 Note that when loading a shared library (text_offset != 0) the
	 unwinds are already relative to the text_offset that will be
	 passed in.  */
      if (TARGET_PTR_BIT == 64 && text_offset == 0)
a1104 6
  /* A frame in the current frame list, or zero.  */
  struct frame_info *saved_regs_frame = 0;
  /* Where the registers were saved in saved_regs_frame.
     If saved_regs_frame is zero, this is garbage.  */
  struct frame_saved_regs saved_regs;

d1198 2
a1199 1
  for (tmp_frame = frame; tmp_frame; tmp_frame = tmp_frame->next)
d1219 3
a1221 1
      if (u->Save_SP
d1225 2
a1226 15

      /* Entry_GR specifies the number of callee-saved general registers
         saved in the stack.  It starts at %r3, so %r3 would be 1.  */
      if (u->Entry_GR >= 1)
	{
	  /* The unwind entry claims that r3 is saved here.  However,
	     in optimized code, GCC often doesn't actually save r3.
	     We'll discover this if we look at the prologue.  */
	  get_frame_saved_regs (tmp_frame, &saved_regs);
	  saved_regs_frame = tmp_frame;

	  /* If we have an address for r3, that's good.  */
	  if (saved_regs.regs[FP_REGNUM])
	    break;
	}
d1242 2
d1270 1
a1270 2
	  if (tmp_frame != saved_regs_frame)
	    get_frame_saved_regs (tmp_frame, &saved_regs);
d1299 2
d1306 1
a1306 3
      if (tmp_frame != saved_regs_frame)
	get_frame_saved_regs (tmp_frame, &saved_regs);

a1672 3

#ifdef PA20W_CALLING_CONVENTIONS

d1676 3
a1678 3
   This is the version for the PA64, in which later arguments appear
   at higher addresses.  (The stack always grows towards higher
   addresses.)
d1684 2
a1685 2
   This ABI also requires that the caller provide an argument pointer
   to the callee, so we do that too.  */
d1719 1
a1719 16
      struct type *arg_type = VALUE_TYPE (args[i]);

      /* Integral scalar values smaller than a register are padded on
         the left.  We do this by promoting them to full-width,
         although the ABI says to pad them with garbage.  */
      if (is_integral_type (arg_type)
	  && TYPE_LENGTH (arg_type) < REGISTER_SIZE)
	{
	  args[i] = value_cast ((TYPE_UNSIGNED (arg_type)
				 ? builtin_type_unsigned_long
				 : builtin_type_long),
				args[i]);
	  arg_type = VALUE_TYPE (args[i]);
	}

      lengths[i] = TYPE_LENGTH (arg_type);
d1725 6
d1733 3
a1735 15
      /* Aggregates larger than eight bytes (the only types larger
         than eight bytes we have) are aligned on a 16-byte boundary,
         possibly padded on the right with garbage.  This may leave an
         empty word on the stack, and thus an unused register, as per
         the ABI.  */
      if (bytes_reserved > 8)
	{
	  /* Round up the offset to a multiple of two slots.  */
	  int new_offset = ((offset[i] + 2*REGISTER_SIZE-1)
			    & -(2*REGISTER_SIZE));

	  /* Note the space we've wasted, if any.  */
	  bytes_reserved += new_offset - offset[i];
	  offset[i] = new_offset;
	}
d1737 2
a1738 72
      cum_bytes_reserved += bytes_reserved;
    }

  /* CUM_BYTES_RESERVED already accounts for all the arguments
     passed by the user.  However, the ABIs mandate minimum stack space
     allocations for outgoing arguments.

     The ABIs also mandate minimum stack alignments which we must
     preserve.  */
  cum_bytes_aligned = STACK_ALIGN (cum_bytes_reserved);
  sp += max (cum_bytes_aligned, REG_PARM_STACK_SPACE);

  /* Now write each of the args at the proper offset down the stack.  */
  for (i = 0; i < nargs; i++)
    write_memory (orig_sp + offset[i], VALUE_CONTENTS (args[i]), lengths[i]);

  /* If a structure has to be returned, set up register 28 to hold its
     address */
  if (struct_return)
    write_register (28, struct_addr);

  /* For the PA64 we must pass a pointer to the outgoing argument list.
     The ABI mandates that the pointer should point to the first byte of
     storage beyond the register flushback area.

     However, the call dummy expects the outgoing argument pointer to
     be passed in register %r4.  */
  write_register (4, orig_sp + REG_PARM_STACK_SPACE);

  /* ?!? This needs further work.  We need to set up the global data
     pointer for this procedure.  This assumes the same global pointer
     for every procedure.   The call dummy expects the dp value to
     be passed in register %r6.  */
  write_register (6, read_register (27));
  
  /* The stack will have 64 bytes of additional space for a frame marker.  */
  return sp + 64;
}

#else

/* This function pushes a stack frame with arguments as part of the
   inferior function calling mechanism.

   This is the version of the function for the 32-bit PA machines, in
   which later arguments appear at lower addresses.  (The stack always
   grows towards higher addresses.)

   We simply allocate the appropriate amount of stack space and put
   arguments into their proper slots.  The call dummy code will copy
   arguments into registers as needed by the ABI. */
   
CORE_ADDR
hppa_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     int struct_return;
     CORE_ADDR struct_addr;
{
  /* array of arguments' offsets */
  int *offset = (int *) alloca (nargs * sizeof (int));

  /* array of arguments' lengths: real lengths in bytes, not aligned to
     word size */
  int *lengths = (int *) alloca (nargs * sizeof (int));

  /* The number of stack bytes occupied by the current argument.  */
  int bytes_reserved;

  /* The total number of bytes reserved for the arguments.  */
  int cum_bytes_reserved = 0;
d1740 1
a1740 17
  /* Similarly, but aligned.  */
  int cum_bytes_aligned = 0;
  int i;

  /* Iterate over each argument provided by the user.  */
  for (i = 0; i < nargs; i++)
    {
      lengths[i] = TYPE_LENGTH (VALUE_TYPE (args[i]));

      /* Align the size of the argument to the word size for this
	 target.  */
      bytes_reserved = (lengths[i] + REGISTER_SIZE - 1) & -REGISTER_SIZE;

      offset[i] = cum_bytes_reserved + lengths[i];

      /* If the argument is a double word argument, then it needs to be
	 double word aligned.  */
d1742 1
a1742 1
	  && (offset[i] % 2 * REGISTER_SIZE))
d1764 2
a1765 2
  /* CUM_BYTES_RESERVED already accounts for all the arguments passed
     by the user.  However, the ABI mandates minimum stack space
d1768 1
a1768 1
     The ABI also mandates minimum stack alignments which we must
d1774 4
d1780 4
d1786 1
d1793 16
a1812 1
#endif
d1976 2
a1977 2
     passed an import stub, not a PLABEL.  It is also necessary to set %r19
     (the PIC register) before performing the call.
d2048 1
a2048 1
       own (it could be a shared library for example).  */
d2825 2
a2826 67
#ifdef GDB_TARGET_IS_HPPA_20W
  /* PA64 has a completely different stub/trampoline scheme.  Is it
     better?  Maybe.  It's certainly harder to determine with any
     certainty that we are in a stub because we can not refer to the
     unwinders to help. 

     The heuristic is simple.  Try to lookup the current PC value in th
     minimal symbol table.  If that fails, then assume we are not in a
     stub and return.

     Then see if the PC value falls within the section bounds for the
     section containing the minimal symbol we found in the first
     step.  If it does, then assume we are not in a stub and return.

     Finally peek at the instructions to see if they look like a stub.  */
  {
    struct minimal_symbol *minsym;
    asection *sec;
    CORE_ADDR addr;
    int insn, i;

    minsym = lookup_minimal_symbol_by_pc (pc);
    if (! minsym)
      return 0;

    sec = SYMBOL_BFD_SECTION (minsym);

    if (sec->vma <= pc
	&& sec->vma + sec->_cooked_size < pc)
      return 0;

    /* We might be in a stub.  Peek at the instructions.  Stubs are 3
       instructions long. */
    insn = read_memory_integer (pc, 4);

    /* Find out where we we think we are within the stub.  */
    if ((insn & 0xffffc00e) == 0x53610000)
      addr = pc;
    else if ((insn & 0xffffffff) == 0xe820d000)
      addr = pc - 4;
    else if ((insn & 0xffffc00e) == 0x537b0000)
      addr = pc - 8;
    else
      return 0;

    /* Now verify each insn in the range looks like a stub instruction.  */
    insn = read_memory_integer (addr, 4);
    if ((insn & 0xffffc00e) != 0x53610000)
      return 0;
	
    /* Now verify each insn in the range looks like a stub instruction.  */
    insn = read_memory_integer (addr + 4, 4);
    if ((insn & 0xffffffff) != 0xe820d000)
      return 0;
    
    /* Now verify each insn in the range looks like a stub instruction.  */
    insn = read_memory_integer (addr + 8, 4);
    if ((insn & 0xffffc00e) != 0x537b0000)
      return 0;

    /* Looks like a stub.  */
    return 1;
  }
#endif

  /* FIXME XXX - dyncall and sr4export must be initialized whenever we get a
     new exec file */
d3000 3
a3002 2
  /* FIXME XXX - dyncall and sr4export must be initialized whenever we get a
     new exec file */
d3832 1
a3832 1
      if (inst == 0x6bc23fd9) /* stw rp,-0x14(sr0,sp) */
a3836 5
      else if (inst == 0x0fc212c1) /* std rp,-0x10(sr0,sp) */
	{
	  save_rp = 0;
	  frame_saved_regs->regs[RP_REGNUM] = frame_info->frame - 16;
	}
d3840 2
a3841 2
      if (   (inst & 0xffffc000) == 0x6fc10000  /* stw,ma r1,N(sr0,sp) */
          || (inst & 0xffffc00c) == 0x73c10008) /* std,ma r1,N(sr0,sp) */
a4542 24

void
hppa_skip_permanent_breakpoint ()
{
  /* To step over a breakpoint instruction on the PA takes some
     fiddling with the instruction address queue.

     When we stop at a breakpoint, the IA queue front (the instruction
     we're executing now) points at the breakpoint instruction, and
     the IA queue back (the next instruction to execute) points to
     whatever instruction we would execute after the breakpoint, if it
     were an ordinary instruction.  This is the case even if the
     breakpoint is in the delay slot of a branch instruction.

     Clearly, to step past the breakpoint, we need to set the queue
     front to the back.  But what do we put in the back?  What
     instruction comes after that one?  Because of the branch delay
     slot, the next insn is always at the back + 4.  */
  write_register (PCOQ_HEAD_REGNUM, read_register (PCOQ_TAIL_REGNUM));
  write_register (PCSQ_HEAD_REGNUM, read_register (PCSQ_TAIL_REGNUM));

  write_register (PCOQ_TAIL_REGNUM, read_register (PCOQ_TAIL_REGNUM) + 4);
  /* We can leave the tail's space the same, since there's no jump.  */
}
@


1.1.1.13
log
@import gdb-1999-09-28 snapshot
@
text
@d2257 3
a2259 16
		if (u == NULL
		    || (u->stub_unwind.stub_type != IMPORT
#ifdef GDB_NATIVE_HPUX_11
			/* Sigh.  The hpux 10.20 dynamic linker will blow
			   chunks if we perform a call to an unbound function
			   via the IMPORT_SHLIB stub.  The hpux 11.00 dynamic
			   linker will blow chunks if we do not call the
			   unbound function via the IMPORT_SHLIB stub.

			   We currently have no way to select bevahior on just
			   the target.  However, we only support HPUX/SOM in
			   native mode.  So we conditinalize on a native
			   #ifdef.  Ugly.  Ugly.  Ugly  */
			&& u->stub_unwind.stub_type != IMPORT_SHLIB
#endif
			))
a2264 7

		/* If we found an IMPORT stub, then we want to stop
		   searching now.  If we found an IMPORT_SHLIB, we want
		   to continue the search in the hopes that we will find
		   an IMPORT stub.  */
		if (u->stub_unwind.stub_type == IMPORT)
		  break;
a3673 9
      /* Are we loading some register with an offset from the argument
         pointer?  */
      if ((inst & 0xffe00000) == 0x37a00000
	  || (inst & 0xffffffe0) == 0x081d0240)
	{
	  pc += 4;
	  continue;
	}

d3688 1
a3688 1
      if (reg_num >= (TARGET_PTR_BIT == 64 ? 19 : 23) && reg_num <= 26)
d3690 1
a3690 1
	  while (reg_num >= (TARGET_PTR_BIT == 64 ? 19 : 23) && reg_num <= 26)
d3717 1
a3717 1
	  && inst_saves_fr (next_inst) <= (TARGET_PTR_BIT == 64 ? 11 : 7))
d3728 1
a3728 1
      if (reg_num >= 4 && reg_num <= (TARGET_PTR_BIT == 64 ? 11 : 7))
d3730 1
a3730 1
	  while (reg_num >= 4 && reg_num <= (TARGET_PTR_BIT == 64 ? 11 : 7))
@


1.1.1.14
log
@import gdb-1999-10-04 snapshot
@
text
@d1627 1
a1627 1
      proceed ((CORE_ADDR) -1, TARGET_SIGNAL_DEFAULT, 0);
@


1.1.1.15
log
@import gdb-1999-11-16 snapshot
@
text
@d2233 1
a2233 1
	    error ("Unable to find minimal symbol for target function.\n");
@


1.1.1.16
log
@import gdb-2000-02-01 snapshot
@
text
@d2 2
a3 1
   Copyright 1986, 1987, 1989-1996, 1999-2000 Free Software Foundation, Inc.
d125 1
a125 1
static void pa_strcat_registers (char *, int, int, struct ui_file *);
d128 1
a128 1
static void pa_strcat_fp_reg (int, struct ui_file *, enum precision_type);
d2589 1
a2589 1
     struct ui_file *stream;
d2804 1
a2804 1
     struct ui_file *stream;
d2897 1
a2897 1
     struct ui_file *stream;
@


