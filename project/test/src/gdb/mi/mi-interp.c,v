head	1.88;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.84
	gdb_7_6-2013-04-26-release:1.84
	gdb_7_6-branch:1.84.0.2
	gdb_7_6-2013-03-12-branchpoint:1.84
	gdb_7_5_1-2012-11-29-release:1.75
	gdb_7_5-2012-08-17-release:1.75
	gdb_7_5-branch:1.75.0.2
	gdb_7_5-2012-07-18-branchpoint:1.75
	gdb_7_4_1-2012-04-26-release:1.69.2.1
	gdb_7_4-2012-01-24-release:1.69.2.1
	gdb_7_4-branch:1.69.0.2
	gdb_7_4-2011-12-13-branchpoint:1.69
	gdb_7_3_1-2011-09-04-release:1.63.2.1
	gdb_7_3-2011-07-26-release:1.63.2.1
	gdb_7_3-branch:1.63.0.2
	gdb_7_3-2011-04-01-branchpoint:1.63
	gdb_7_2-2010-09-02-release:1.58
	gdb_7_2-branch:1.58.0.2
	gdb_7_2-2010-07-07-branchpoint:1.58
	gdb_7_1-2010-03-18-release:1.54
	gdb_7_1-branch:1.54.0.2
	gdb_7_1-2010-02-18-branchpoint:1.54
	gdb_7_0_1-2009-12-22-release:1.50
	gdb_7_0-2009-10-06-release:1.50
	gdb_7_0-branch:1.50.0.4
	gdb_7_0-2009-09-16-branchpoint:1.50
	arc-sim-20090309:1.23
	msnyder-checkpoint-072509-branch:1.50.0.2
	msnyder-checkpoint-072509-branchpoint:1.50
	arc-insight_6_8-branch:1.23.0.6
	arc-insight_6_8-branchpoint:1.23
	insight_6_8-branch:1.23.0.4
	insight_6_8-branchpoint:1.23
	reverse-20081226-branch:1.39.0.4
	reverse-20081226-branchpoint:1.39
	multiprocess-20081120-branch:1.39.0.2
	multiprocess-20081120-branchpoint:1.39
	reverse-20080930-branch:1.35.0.4
	reverse-20080930-branchpoint:1.35
	reverse-20080717-branch:1.35.0.2
	reverse-20080717-branchpoint:1.35
	msnyder-reverse-20080609-branch:1.30.0.2
	msnyder-reverse-20080609-branchpoint:1.30
	drow-reverse-20070409-branch:1.19.0.2
	drow-reverse-20070409-branchpoint:1.19
	gdb_6_8-2008-03-27-release:1.23
	gdb_6_8-branch:1.23.0.2
	gdb_6_8-2008-02-26-branchpoint:1.23
	gdb_6_7_1-2007-10-29-release:1.22
	gdb_6_7-2007-10-10-release:1.22
	gdb_6_7-branch:1.22.0.2
	gdb_6_7-2007-09-07-branchpoint:1.22
	insight_6_6-20070208-release:1.17
	gdb_6_6-2006-12-18-release:1.17
	gdb_6_6-branch:1.17.0.18
	gdb_6_6-2006-11-15-branchpoint:1.17
	insight_6_5-20061003-release:1.17
	gdb-csl-symbian-6_4_50_20060226-12:1.17
	gdb-csl-sourcerygxx-3_4_4-25:1.15
	nickrob-async-20060828-mergepoint:1.17
	gdb-csl-symbian-6_4_50_20060226-11:1.17
	gdb-csl-sourcerygxx-4_1-17:1.17
	gdb-csl-20060226-branch-local-2:1.17
	gdb-csl-sourcerygxx-4_1-14:1.17
	gdb-csl-sourcerygxx-4_1-13:1.17
	gdb-csl-sourcerygxx-4_1-12:1.17
	gdb-csl-sourcerygxx-3_4_4-21:1.17
	gdb_6_5-20060621-release:1.17
	gdb-csl-sourcerygxx-4_1-9:1.17
	gdb-csl-sourcerygxx-4_1-8:1.17
	gdb-csl-sourcerygxx-4_1-7:1.17
	gdb-csl-arm-2006q1-6:1.17
	gdb-csl-sourcerygxx-4_1-6:1.17
	gdb-csl-symbian-6_4_50_20060226-10:1.17
	gdb-csl-symbian-6_4_50_20060226-9:1.17
	gdb-csl-symbian-6_4_50_20060226-8:1.17
	gdb-csl-coldfire-4_1-11:1.17
	gdb-csl-sourcerygxx-3_4_4-19:1.17
	gdb-csl-coldfire-4_1-10:1.17
	gdb_6_5-branch:1.17.0.16
	gdb_6_5-2006-05-14-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-5:1.17
	nickrob-async-20060513-branch:1.17.0.14
	nickrob-async-20060513-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-4:1.17
	msnyder-reverse-20060502-branch:1.17.0.12
	msnyder-reverse-20060502-branchpoint:1.17
	gdb-csl-morpho-4_1-4:1.17
	gdb-csl-sourcerygxx-3_4_4-17:1.17
	readline_5_1-import-branch:1.17.0.10
	readline_5_1-import-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.17
	gdb-csl-symbian-20060226-branch:1.17.0.8
	gdb-csl-symbian-20060226-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.17
	msnyder-reverse-20060331-branch:1.17.0.6
	msnyder-reverse-20060331-branchpoint:1.17
	gdb-csl-available-20060303-branch:1.17.0.4
	gdb-csl-available-20060303-branchpoint:1.17
	gdb-csl-20060226-branch:1.17.0.2
	gdb-csl-20060226-branchpoint:1.17
	gdb_6_4-20051202-release:1.15
	msnyder-fork-checkpoint-branch:1.15.0.8
	msnyder-fork-checkpoint-branchpoint:1.15
	gdb-csl-gxxpro-6_3-branch:1.15.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.15
	gdb_6_4-branch:1.15.0.4
	gdb_6_4-2005-11-01-branchpoint:1.15
	gdb-csl-arm-20051020-branch:1.15.0.2
	gdb-csl-arm-20051020-branchpoint:1.15
	msnyder-tracepoint-checkpoint-branch:1.14.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.14
	gdb-csl-arm-20050325-2005-q1b:1.13
	gdb-csl-arm-20050325-2005-q1a:1.13
	csl-arm-20050325-branch:1.13.0.2
	csl-arm-20050325-branchpoint:1.13
	gdb-post-i18n-errorwarning-20050211:1.13
	gdb-pre-i18n-errorwarning-20050211:1.13
	gdb_6_3-20041109-release:1.11
	gdb_6_3-branch:1.11.0.2
	gdb_6_3-20041019-branchpoint:1.11
	drow_intercu-merge-20040921:1.11
	drow_intercu-merge-20040915:1.11
	jimb-gdb_6_2-e500-branch:1.10.0.6
	jimb-gdb_6_2-e500-branchpoint:1.10
	gdb_6_2-20040730-release:1.10
	gdb_6_2-branch:1.10.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.10
	gdb_6_1_1-20040616-release:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.12
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.10
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.6
	drow_intercu-20040221-branchpoint:1.7
	cagney_bfdfile-20040213-branch:1.7.0.4
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.2
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-branch:1.6.0.8
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.4.4.2
	kettenis_sparc-20030918-branch:1.6.0.6
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.4
	cagney_x86i386-20030821-branch:1.6.0.2
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.4
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.3.0.26
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.24
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.20
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.3
	carlton_dictionary-20030430-merge:1.3
	kettenis_i386newframe-20030419-branch:1.3.0.16
	kettenis_i386newframe-20030419-branchpoint:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	kettenis_i386newframe-20030406-branch:1.3.0.14
	kettenis_i386newframe-20030406-branchpoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.12
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.10
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.8
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.6
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.4
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.2
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-branch:1.2.0.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.1.0.4
	kseitz_interps-20020528-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.88
date	2013.09.30.11.50.12;	author luisgpm;	state Exp;
branches;
next	1.87;

1.87
date	2013.09.17.18.26.39;	author palves;	state Exp;
branches;
next	1.86;

1.86
date	2013.08.29.16.59.48;	author aburgess;	state Exp;
branches;
next	1.85;

1.85
date	2013.08.02.10.31.40;	author aburgess;	state Exp;
branches;
next	1.84;

1.84
date	2013.03.12.18.50.39;	author kseitz;	state Exp;
branches;
next	1.83;

1.83
date	2013.02.06.14.45.19;	author qiyao;	state Exp;
branches;
next	1.82;

1.82
date	2013.01.01.06.33.00;	author brobecke;	state Exp;
branches;
next	1.81;

1.81
date	2012.11.09.19.58.03;	author tromey;	state Exp;
branches;
next	1.80;

1.80
date	2012.10.17.00.53.23;	author qiyao;	state Exp;
branches;
next	1.79;

1.79
date	2012.09.21.01.46.43;	author qiyao;	state Exp;
branches;
next	1.78;

1.78
date	2012.09.18.12.09.27;	author qiyao;	state Exp;
branches;
next	1.77;

1.77
date	2012.09.18.11.33.42;	author qiyao;	state Exp;
branches;
next	1.76;

1.76
date	2012.08.09.12.53.45;	author qiyao;	state Exp;
branches;
next	1.75;

1.75
date	2012.06.28.22.11.22;	author shebs;	state Exp;
branches;
next	1.74;

1.74
date	2012.06.06.06.04.46;	author shebs;	state Exp;
branches;
next	1.73;

1.73
date	2012.03.14.07.58.05;	author jkratoch;	state Exp;
branches;
next	1.72;

1.72
date	2012.03.06.22.48.53;	author shebs;	state Exp;
branches;
next	1.71;

1.71
date	2012.01.06.03.34.46;	author sergiodj;	state Exp;
branches;
next	1.70;

1.70
date	2012.01.04.08.17.24;	author brobecke;	state Exp;
branches;
next	1.69;

1.69
date	2011.11.22.21.25.18;	author tromey;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2011.11.22.21.21.54;	author tromey;	state Exp;
branches;
next	1.67;

1.67
date	2011.09.12.21.24.50;	author palves;	state Exp;
branches;
next	1.66;

1.66
date	2011.08.04.19.10.14;	author palves;	state Exp;
branches;
next	1.65;

1.65
date	2011.06.03.15.32.44;	author tromey;	state Exp;
branches;
next	1.64;

1.64
date	2011.04.27.10.17.37;	author vprus;	state Exp;
branches;
next	1.63;

1.63
date	2011.01.12.21.09.39;	author tromey;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2011.01.11.15.10.03;	author msnyder;	state Exp;
branches;
next	1.61;

1.61
date	2011.01.06.00.57.02;	author msnyder;	state Exp;
branches;
next	1.60;

1.60
date	2011.01.01.15.33.25;	author brobecke;	state Exp;
branches;
next	1.59;

1.59
date	2010.11.28.04.31.25;	author jkratoch;	state Exp;
branches;
next	1.58;

1.58
date	2010.05.17.20.49.39;	author msnyder;	state Exp;
branches;
next	1.57;

1.57
date	2010.05.06.00.32.38;	author msnyder;	state Exp;
branches;
next	1.56;

1.56
date	2010.05.02.21.14.59;	author jkratoch;	state Exp;
branches;
next	1.55;

1.55
date	2010.02.24.07.51.46;	author vprus;	state Exp;
branches;
next	1.54;

1.54
date	2010.01.12.21.40.24;	author vprus;	state Exp;
branches;
next	1.53;

1.53
date	2010.01.01.07.31.50;	author brobecke;	state Exp;
branches;
next	1.52;

1.52
date	2009.11.06.14.26.13;	author vprus;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.19.09.51.42;	author palves;	state Exp;
branches;
next	1.50;

1.50
date	2009.05.29.19.06.12;	author palves;	state Exp;
branches;
next	1.49;

1.49
date	2009.05.24.21.06.53;	author devans;	state Exp;
branches;
next	1.48;

1.48
date	2009.05.21.15.21.28;	author palves;	state Exp;
branches;
next	1.47;

1.47
date	2009.05.18.14.07.18;	author palves;	state Exp;
branches;
next	1.46;

1.46
date	2009.03.25.21.53.11;	author palves;	state Exp;
branches;
next	1.45;

1.45
date	2009.03.22.18.06.07;	author palves;	state Exp;
branches;
next	1.44;

1.44
date	2009.03.22.17.59.59;	author palves;	state Exp;
branches;
next	1.43;

1.43
date	2009.03.12.19.54.54;	author vprus;	state Exp;
branches;
next	1.42;

1.42
date	2009.02.18.07.28.33;	author vprus;	state Exp;
branches;
next	1.41;

1.41
date	2009.02.14.15.24.43;	author vprus;	state Exp;
branches;
next	1.40;

1.40
date	2009.01.03.05.57.57;	author brobecke;	state Exp;
branches;
next	1.39;

1.39
date	2008.11.17.16.43.33;	author vprus;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.17.12.34.19;	author vprus;	state Exp;
branches;
next	1.37;

1.37
date	2008.11.17.12.28.05;	author vprus;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.04.14.58.54;	author vprus;	state Exp;
branches;
next	1.35;

1.35
date	2008.07.05.17.57.24;	author vprus;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.25.15.15.42;	author vprus;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.25.14.32.33;	author vprus;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.10.10.23.54;	author vprus;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.10.09.35.08;	author vprus;	state Exp;
branches;
next	1.30;

1.30
date	2008.05.03.15.10.42;	author vprus;	state Exp;
branches;
next	1.29;

1.29
date	2008.04.26.17.58.48;	author vprus;	state Exp;
branches;
next	1.28;

1.28
date	2008.04.24.11.13.44;	author vprus;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.04.21.59.25;	author palves;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.14.18.57.43;	author vprus;	state Exp;
branches;
next	1.25;

1.25
date	2008.03.14.17.21.08;	author vprus;	state Exp;
branches;
next	1.24;

1.24
date	2008.03.08.16.03.30;	author vprus;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.01.22.53.14;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2007.08.23.18.08.48;	author brobecke;	state Exp;
branches;
next	1.21;

1.21
date	2007.08.14.19.51.37;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.28.21.52.38;	author uweigand;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.29.18.55.01;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.09.17.59.08;	author drow;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.23.18.57.46;	author eliz;	state Exp;
branches
	1.17.14.1;
next	1.16;

1.16
date	2005.12.06.05.53.46;	author fred;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.31.20.56.26;	author drow;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.26.05.03.40;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.14.01.20.38;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.13.02.35.38;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.13.18.26.31;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.01.13.33.58;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.01.13.15.02;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.21.23.52.21;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.19.01.20.12;	author cagney;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	2003.08.08.19.00.08;	author cagney;	state Exp;
branches
	1.6.4.1
	1.6.8.1;
next	1.5;

1.5
date	2003.08.07.17.47.42;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.08.18.27.14;	author cagney;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2003.02.09.10.47.37;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.06.05.30.17;	author cagney;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2002.05.29.20.03.17;	author kseitz;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.69.2.1
date	2012.01.06.04.43.40;	author brobecke;	state Exp;
branches;
next	;

1.63.2.1
date	2011.06.03.15.32.13;	author tromey;	state Exp;
branches;
next	;

1.17.14.1
date	2006.05.12.07.40.18;	author nickrob;	state Exp;
branches;
next	1.17.14.2;

1.17.14.2
date	2006.09.14.02.25.03;	author nickrob;	state Exp;
branches;
next	;

1.7.6.1
date	2004.09.16.17.01.37;	author drow;	state Exp;
branches;
next	;

1.6.4.1
date	2004.03.23.20.15.09;	author ezannoni;	state Exp;
branches;
next	;

1.6.8.1
date	2003.12.14.20.27.44;	author drow;	state Exp;
branches;
next	1.6.8.2;

1.6.8.2
date	2004.02.09.19.43.54;	author drow;	state Exp;
branches;
next	;

1.4.4.1
date	2003.08.07.18.09.30;	author cagney;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2003.08.08.18.35.23;	author cagney;	state Exp;
branches;
next	;

1.2.2.1
date	2003.02.07.19.17.57;	author carlton;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2003.03.06.00.56.36;	author carlton;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2003.06.27.21.50.19;	author carlton;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2003.09.17.21.28.48;	author carlton;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2004.01.26.19.11.40;	author carlton;	state Exp;
branches;
next	;

1.1.2.1
date	2002.05.29.20.03.17;	author kseitz;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.06.19.18.51.32;	author kseitz;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.06.25.00.00.51;	author kseitz;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.07.22.22.01.31;	author kseitz;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2002.07.25.17.20.56;	author kseitz;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2002.08.09.19.53.56;	author kseitz;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2002.08.13.16.54.58;	author kseitz;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2002.08.21.23.04.27;	author kseitz;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2002.08.28.19.05.04;	author kseitz;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2002.11.04.16.18.02;	author ezannoni;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2002.11.04.21.43.51;	author ezannoni;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2002.11.04.22.08.26;	author ezannoni;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	2002.11.04.22.47.26;	author ezannoni;	state Exp;
branches;
next	1.1.2.14;

1.1.2.14
date	2002.11.04.23.27.32;	author ezannoni;	state Exp;
branches;
next	1.1.2.15;

1.1.2.15
date	2002.11.04.23.45.13;	author ezannoni;	state Exp;
branches;
next	;

1.1.4.1
date	2003.02.03.06.02.46;	author cagney;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.02.04.01.26.55;	author cagney;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.02.04.07.02.36;	author cagney;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.02.04.19.59.02;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.88
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@/* MI Interpreter Definitions and Commands for GDB, the GNU debugger.

   Copyright (C) 2002-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdb_string.h"
#include "interps.h"
#include "event-top.h"
#include "event-loop.h"
#include "inferior.h"
#include "ui-out.h"
#include "top.h"
#include "exceptions.h"
#include "mi-main.h"
#include "mi-cmds.h"
#include "mi-out.h"
#include "mi-console.h"
#include "mi-common.h"
#include "observer.h"
#include "gdbthread.h"
#include "solist.h"
#include "gdb.h"
#include "objfiles.h"
#include "tracepoint.h"

/* These are the interpreter setup, etc. functions for the MI
   interpreter.  */

static void mi_execute_command_wrapper (const char *cmd);
static void mi_execute_command_input_handler (char *cmd);
static void mi_command_loop (void *data);

/* These are hooks that we put in place while doing interpreter_exec
   so we can report interesting things that happened "behind the MI's
   back" in this command.  */

static int mi_interp_query_hook (const char *ctlstr, va_list ap)
  ATTRIBUTE_PRINTF (1, 0);

static void mi_insert_notify_hooks (void);
static void mi_remove_notify_hooks (void);
static void mi_on_normal_stop (struct bpstats *bs, int print_frame);

static void mi_new_thread (struct thread_info *t);
static void mi_thread_exit (struct thread_info *t, int silent);
static void mi_record_changed (struct inferior*, int);
static void mi_inferior_added (struct inferior *inf);
static void mi_inferior_appeared (struct inferior *inf);
static void mi_inferior_exit (struct inferior *inf);
static void mi_inferior_removed (struct inferior *inf);
static void mi_on_resume (ptid_t ptid);
static void mi_solib_loaded (struct so_list *solib);
static void mi_solib_unloaded (struct so_list *solib);
static void mi_about_to_proceed (void);
static void mi_traceframe_changed (int tfnum, int tpnum);
static void mi_tsv_created (const struct trace_state_variable *tsv);
static void mi_tsv_deleted (const struct trace_state_variable *tsv);
static void mi_tsv_modified (const struct trace_state_variable *tsv);
static void mi_breakpoint_created (struct breakpoint *b);
static void mi_breakpoint_deleted (struct breakpoint *b);
static void mi_breakpoint_modified (struct breakpoint *b);
static void mi_command_param_changed (const char *param, const char *value);
static void mi_memory_changed (struct inferior *inf, CORE_ADDR memaddr,
			       ssize_t len, const bfd_byte *myaddr);

static int report_initial_inferior (struct inferior *inf, void *closure);

static void *
mi_interpreter_init (struct interp *interp, int top_level)
{
  struct mi_interp *mi = XMALLOC (struct mi_interp);
  const char *name;
  int mi_version;

  /* Assign the output channel created at startup to its own global,
     so that we can create a console channel that encapsulates and
     prefixes all gdb_output-type bits coming from the rest of the
     debugger.  */

  raw_stdout = gdb_stdout;

  /* Create MI console channels, each with a different prefix so they
     can be distinguished.  */
  mi->out = mi_console_file_new (raw_stdout, "~", '"');
  mi->err = mi_console_file_new (raw_stdout, "&", '"');
  mi->log = mi->err;
  mi->targ = mi_console_file_new (raw_stdout, "@@", '"');
  mi->event_channel = mi_console_file_new (raw_stdout, "=", 0);

  name = interp_name (interp);
  /* INTERP_MI selects the most recent released version.  "mi2" was
     released as part of GDB 6.0.  */
  if (strcmp (name, INTERP_MI) == 0)
    mi_version = 2;
  else if (strcmp (name, INTERP_MI1) == 0)
    mi_version = 1;
  else if (strcmp (name, INTERP_MI2) == 0)
    mi_version = 2;
  else if (strcmp (name, INTERP_MI3) == 0)
    mi_version = 3;
  else
    gdb_assert_not_reached ("unhandled MI version");

  mi->uiout = mi_out_new (mi_version);

  if (top_level)
    {
      observer_attach_new_thread (mi_new_thread);
      observer_attach_thread_exit (mi_thread_exit);
      observer_attach_inferior_added (mi_inferior_added);
      observer_attach_inferior_appeared (mi_inferior_appeared);
      observer_attach_inferior_exit (mi_inferior_exit);
      observer_attach_inferior_removed (mi_inferior_removed);
      observer_attach_record_changed (mi_record_changed);
      observer_attach_normal_stop (mi_on_normal_stop);
      observer_attach_target_resumed (mi_on_resume);
      observer_attach_solib_loaded (mi_solib_loaded);
      observer_attach_solib_unloaded (mi_solib_unloaded);
      observer_attach_about_to_proceed (mi_about_to_proceed);
      observer_attach_traceframe_changed (mi_traceframe_changed);
      observer_attach_tsv_created (mi_tsv_created);
      observer_attach_tsv_deleted (mi_tsv_deleted);
      observer_attach_tsv_modified (mi_tsv_modified);
      observer_attach_breakpoint_created (mi_breakpoint_created);
      observer_attach_breakpoint_deleted (mi_breakpoint_deleted);
      observer_attach_breakpoint_modified (mi_breakpoint_modified);
      observer_attach_command_param_changed (mi_command_param_changed);
      observer_attach_memory_changed (mi_memory_changed);

      /* The initial inferior is created before this function is
	 called, so we need to report it explicitly.  Use iteration in
	 case future version of GDB creates more than one inferior
	 up-front.  */
      iterate_over_inferiors (report_initial_inferior, mi);
    }

  return mi;
}

static int
mi_interpreter_resume (void *data)
{
  struct mi_interp *mi = data;

  /* As per hack note in mi_interpreter_init, swap in the output
     channels... */
  gdb_setup_readline ();

  /* These overwrite some of the initialization done in
     _intialize_event_loop.  */
  call_readline = gdb_readline2;
  input_handler = mi_execute_command_input_handler;
  async_command_editing_p = 0;
  /* FIXME: This is a total hack for now.  PB's use of the MI
     implicitly relies on a bug in the async support which allows
     asynchronous commands to leak through the commmand loop.  The bug
     involves (but is not limited to) the fact that sync_execution was
     erroneously initialized to 0.  Duplicate by initializing it thus
     here...  */
  sync_execution = 0;

  gdb_stdout = mi->out;
  /* Route error and log output through the MI.  */
  gdb_stderr = mi->err;
  gdb_stdlog = mi->log;
  /* Route target output through the MI.  */
  gdb_stdtarg = mi->targ;
  /* Route target error through the MI as well.  */
  gdb_stdtargerr = mi->targ;

  /* Replace all the hooks that we know about.  There really needs to
     be a better way of doing this... */
  clear_interpreter_hooks ();

  deprecated_show_load_progress = mi_load_progress;

  return 1;
}

static int
mi_interpreter_suspend (void *data)
{
  gdb_disable_readline ();
  return 1;
}

static struct gdb_exception
mi_interpreter_exec (void *data, const char *command)
{
  mi_execute_command_wrapper (command);
  return exception_none;
}

/* Never display the default GDB prompt in MI case.  */

static int
mi_interpreter_prompt_p (void *data)
{
  return 0;
}

void
mi_cmd_interpreter_exec (char *command, char **argv, int argc)
{
  struct interp *interp_to_use;
  int i;
  char *mi_error_message = NULL;
  struct cleanup *old_chain;

  if (argc < 2)
    error (_("-interpreter-exec: "
	     "Usage: -interpreter-exec interp command"));

  interp_to_use = interp_lookup (argv[0]);
  if (interp_to_use == NULL)
    error (_("-interpreter-exec: could not find interpreter \"%s\""),
	   argv[0]);

  if (!interp_exec_p (interp_to_use))
    error (_("-interpreter-exec: interpreter \"%s\" "
	     "does not support command execution"),
	      argv[0]);

  /* Insert the MI out hooks, making sure to also call the
     interpreter's hooks if it has any.  */
  /* KRS: We shouldn't need this... Events should be installed and
     they should just ALWAYS fire something out down the MI
     channel.  */
  mi_insert_notify_hooks ();

  /* Now run the code.  */

  old_chain = make_cleanup (null_cleanup, 0);
  for (i = 1; i < argc; i++)
    {
      struct gdb_exception e = interp_exec (interp_to_use, argv[i]);

      if (e.reason < 0)
	{
	  mi_error_message = xstrdup (e.message);
	  make_cleanup (xfree, mi_error_message);
	  break;
	}
    }

  mi_remove_notify_hooks ();

  if (mi_error_message != NULL)
    error ("%s", mi_error_message);
  do_cleanups (old_chain);
}

/* This inserts a number of hooks that are meant to produce
   async-notify ("=") MI messages while running commands in another
   interpreter using mi_interpreter_exec.  The canonical use for this
   is to allow access to the gdb CLI interpreter from within the MI,
   while still producing MI style output when actions in the CLI
   command change GDB's state.  */

static void
mi_insert_notify_hooks (void)
{
  deprecated_query_hook = mi_interp_query_hook;
}

static void
mi_remove_notify_hooks (void)
{
  deprecated_query_hook = NULL;
}

static int
mi_interp_query_hook (const char *ctlstr, va_list ap)
{
  return 1;
}

static void
mi_execute_command_wrapper (const char *cmd)
{
  mi_execute_command (cmd, stdin == instream);
}

/* mi_execute_command_wrapper wrapper suitable for INPUT_HANDLER.  */

static void
mi_execute_command_input_handler (char *cmd)
{
  mi_execute_command_wrapper (cmd);

  fputs_unfiltered ("(gdb) \n", raw_stdout);
  gdb_flush (raw_stdout);
}

static void
mi_command_loop (void *data)
{
  /* Turn off 8 bit strings in quoted output.  Any character with the
     high bit set is printed using C's octal format.  */
  sevenbit_strings = 1;

  /* Tell the world that we're alive.  */
  fputs_unfiltered ("(gdb) \n", raw_stdout);
  gdb_flush (raw_stdout);

  start_event_loop ();
}

static void
mi_new_thread (struct thread_info *t)
{
  struct mi_interp *mi = top_level_interpreter_data ();
  struct inferior *inf = find_inferior_pid (ptid_get_pid (t->ptid));

  gdb_assert (inf);

  fprintf_unfiltered (mi->event_channel, 
		      "thread-created,id=\"%d\",group-id=\"i%d\"",
		      t->num, inf->num);
  gdb_flush (mi->event_channel);
}

static void
mi_thread_exit (struct thread_info *t, int silent)
{
  struct mi_interp *mi;
  struct inferior *inf;

  if (silent)
    return;

  inf = find_inferior_pid (ptid_get_pid (t->ptid));

  mi = top_level_interpreter_data ();
  target_terminal_ours ();
  fprintf_unfiltered (mi->event_channel, 
		      "thread-exited,id=\"%d\",group-id=\"i%d\"",
		      t->num, inf->num);
  gdb_flush (mi->event_channel);
}

/* Emit notification on changing the state of record.  */

static void
mi_record_changed (struct inferior *inferior, int started)
{
  struct mi_interp *mi = top_level_interpreter_data ();

  fprintf_unfiltered (mi->event_channel,  "record-%s,thread-group=\"i%d\"",
		      started ? "started" : "stopped", inferior->num);

  gdb_flush (mi->event_channel);
}

static void
mi_inferior_added (struct inferior *inf)
{
  struct mi_interp *mi = top_level_interpreter_data ();

  target_terminal_ours ();
  fprintf_unfiltered (mi->event_channel,
		      "thread-group-added,id=\"i%d\"",
		      inf->num);
  gdb_flush (mi->event_channel);
}

static void
mi_inferior_appeared (struct inferior *inf)
{
  struct mi_interp *mi = top_level_interpreter_data ();

  target_terminal_ours ();
  fprintf_unfiltered (mi->event_channel,
		      "thread-group-started,id=\"i%d\",pid=\"%d\"",
		      inf->num, inf->pid);
  gdb_flush (mi->event_channel);
}

static void
mi_inferior_exit (struct inferior *inf)
{
  struct mi_interp *mi = top_level_interpreter_data ();

  target_terminal_ours ();
  if (inf->has_exit_code)
    fprintf_unfiltered (mi->event_channel,
			"thread-group-exited,id=\"i%d\",exit-code=\"%s\"",
			inf->num, int_string (inf->exit_code, 8, 0, 0, 1));
  else
    fprintf_unfiltered (mi->event_channel,
			"thread-group-exited,id=\"i%d\"", inf->num);

  gdb_flush (mi->event_channel);  
}

static void
mi_inferior_removed (struct inferior *inf)
{
  struct mi_interp *mi = top_level_interpreter_data ();

  target_terminal_ours ();
  fprintf_unfiltered (mi->event_channel,
		      "thread-group-removed,id=\"i%d\"",
		      inf->num);
  gdb_flush (mi->event_channel);
}

static void
mi_on_normal_stop (struct bpstats *bs, int print_frame)
{
  /* Since this can be called when CLI command is executing,
     using cli interpreter, be sure to use MI uiout for output,
     not the current one.  */
  struct ui_out *mi_uiout = interp_ui_out (top_level_interpreter ());

  if (print_frame)
    {
      int core;

      if (current_uiout != mi_uiout)
	{
	  /* The normal_stop function has printed frame information
	     into CLI uiout, or some other non-MI uiout.  There's no
	     way we can extract proper fields from random uiout
	     object, so we print the frame again.  In practice, this
	     can only happen when running a CLI command in MI.  */
	  struct ui_out *saved_uiout = current_uiout;
	  struct target_waitstatus last;
	  ptid_t last_ptid;

	  current_uiout = mi_uiout;

	  get_last_target_status (&last_ptid, &last);
	  bpstat_print (bs, last.kind);

	  print_stack_frame (get_selected_frame (NULL), 0, SRC_AND_LOC, 1);
	  current_uiout = saved_uiout;
	}

      ui_out_field_int (mi_uiout, "thread-id",
			pid_to_thread_id (inferior_ptid));
      if (non_stop)
	{
	  struct cleanup *back_to = make_cleanup_ui_out_list_begin_end 
	    (mi_uiout, "stopped-threads");

	  ui_out_field_int (mi_uiout, NULL,
			    pid_to_thread_id (inferior_ptid));
	  do_cleanups (back_to);
	}
      else
	ui_out_field_string (mi_uiout, "stopped-threads", "all");

      core = target_core_of_thread (inferior_ptid);
      if (core != -1)
	ui_out_field_int (mi_uiout, "core", core);
    }
  
  fputs_unfiltered ("*stopped", raw_stdout);
  mi_out_put (mi_uiout, raw_stdout);
  mi_out_rewind (mi_uiout);
  mi_print_timing_maybe ();
  fputs_unfiltered ("\n", raw_stdout);
  gdb_flush (raw_stdout);
}

static void
mi_about_to_proceed (void)
{
  /* Suppress output while calling an inferior function.  */

  if (!ptid_equal (inferior_ptid, null_ptid))
    {
      struct thread_info *tp = inferior_thread ();

      if (tp->control.in_infcall)
	return;
    }

  mi_proceeded = 1;
}

/* When the element is non-zero, no MI notifications will be emitted in
   response to the corresponding observers.  */

struct mi_suppress_notification mi_suppress_notification =
  {
    0,
    0,
    0,
  };

/* Emit notification on changing a traceframe.  */

static void
mi_traceframe_changed (int tfnum, int tpnum)
{
  struct mi_interp *mi = top_level_interpreter_data ();

  if (mi_suppress_notification.traceframe)
    return;

  target_terminal_ours ();

  if (tfnum >= 0)
    fprintf_unfiltered (mi->event_channel, "traceframe-changed,"
			"num=\"%d\",tracepoint=\"%d\"\n",
			tfnum, tpnum);
  else
    fprintf_unfiltered (mi->event_channel, "traceframe-changed,end");

  gdb_flush (mi->event_channel);
}

/* Emit notification on creating a trace state variable.  */

static void
mi_tsv_created (const struct trace_state_variable *tsv)
{
  struct mi_interp *mi = top_level_interpreter_data ();

  target_terminal_ours ();

  fprintf_unfiltered (mi->event_channel, "tsv-created,"
		      "name=\"%s\",initial=\"%s\"\n",
		      tsv->name, plongest (tsv->initial_value));

  gdb_flush (mi->event_channel);
}

/* Emit notification on deleting a trace state variable.  */

static void
mi_tsv_deleted (const struct trace_state_variable *tsv)
{
  struct mi_interp *mi = top_level_interpreter_data ();

  target_terminal_ours ();

  if (tsv != NULL)
    fprintf_unfiltered (mi->event_channel, "tsv-deleted,"
			"name=\"%s\"\n", tsv->name);
  else
    fprintf_unfiltered (mi->event_channel, "tsv-deleted\n");

  gdb_flush (mi->event_channel);
}

/* Emit notification on modifying a trace state variable.  */

static void
mi_tsv_modified (const struct trace_state_variable *tsv)
{
  struct mi_interp *mi = top_level_interpreter_data ();
  struct ui_out *mi_uiout = interp_ui_out (top_level_interpreter ());

  target_terminal_ours ();

  fprintf_unfiltered (mi->event_channel,
		      "tsv-modified");

  ui_out_redirect (mi_uiout, mi->event_channel);

  ui_out_field_string (mi_uiout, "name", tsv->name);
  ui_out_field_string (mi_uiout, "initial",
		       plongest (tsv->initial_value));
  if (tsv->value_known)
    ui_out_field_string (mi_uiout, "current", plongest (tsv->value));

  ui_out_redirect (mi_uiout, NULL);

  gdb_flush (mi->event_channel);
}

/* Emit notification about a created breakpoint.  */

static void
mi_breakpoint_created (struct breakpoint *b)
{
  struct mi_interp *mi = top_level_interpreter_data ();
  struct ui_out *mi_uiout = interp_ui_out (top_level_interpreter ());
  volatile struct gdb_exception e;

  if (mi_suppress_notification.breakpoint)
    return;

  if (b->number <= 0)
    return;

  target_terminal_ours ();
  fprintf_unfiltered (mi->event_channel,
		      "breakpoint-created");
  /* We want the output from gdb_breakpoint_query to go to
     mi->event_channel.  One approach would be to just call
     gdb_breakpoint_query, and then use mi_out_put to send the current
     content of mi_outout into mi->event_channel.  However, that will
     break if anything is output to mi_uiout prior to calling the
     breakpoint_created notifications.  So, we use
     ui_out_redirect.  */
  ui_out_redirect (mi_uiout, mi->event_channel);
  TRY_CATCH (e, RETURN_MASK_ERROR)
    gdb_breakpoint_query (mi_uiout, b->number, NULL);
  ui_out_redirect (mi_uiout, NULL);

  gdb_flush (mi->event_channel);
}

/* Emit notification about deleted breakpoint.  */

static void
mi_breakpoint_deleted (struct breakpoint *b)
{
  struct mi_interp *mi = top_level_interpreter_data ();

  if (mi_suppress_notification.breakpoint)
    return;

  if (b->number <= 0)
    return;

  target_terminal_ours ();

  fprintf_unfiltered (mi->event_channel, "breakpoint-deleted,id=\"%d\"",
		      b->number);

  gdb_flush (mi->event_channel);
}

/* Emit notification about modified breakpoint.  */

static void
mi_breakpoint_modified (struct breakpoint *b)
{
  struct mi_interp *mi = top_level_interpreter_data ();
  struct ui_out *mi_uiout = interp_ui_out (top_level_interpreter ());
  volatile struct gdb_exception e;

  if (mi_suppress_notification.breakpoint)
    return;

  if (b->number <= 0)
    return;

  target_terminal_ours ();
  fprintf_unfiltered (mi->event_channel,
		      "breakpoint-modified");
  /* We want the output from gdb_breakpoint_query to go to
     mi->event_channel.  One approach would be to just call
     gdb_breakpoint_query, and then use mi_out_put to send the current
     content of mi_outout into mi->event_channel.  However, that will
     break if anything is output to mi_uiout prior to calling the
     breakpoint_created notifications.  So, we use
     ui_out_redirect.  */
  ui_out_redirect (mi_uiout, mi->event_channel);
  TRY_CATCH (e, RETURN_MASK_ERROR)
    gdb_breakpoint_query (mi_uiout, b->number, NULL);
  ui_out_redirect (mi_uiout, NULL);

  gdb_flush (mi->event_channel);
}

static int
mi_output_running_pid (struct thread_info *info, void *arg)
{
  ptid_t *ptid = arg;

  if (ptid_get_pid (*ptid) == ptid_get_pid (info->ptid))
    fprintf_unfiltered (raw_stdout,
			"*running,thread-id=\"%d\"\n",
			info->num);

  return 0;
}

static int
mi_inferior_count (struct inferior *inf, void *arg)
{
  if (inf->pid != 0)
    {
      int *count_p = arg;
      (*count_p)++;
    }

  return 0;
}

static void
mi_on_resume (ptid_t ptid)
{
  struct thread_info *tp = NULL;

  if (ptid_equal (ptid, minus_one_ptid) || ptid_is_pid (ptid))
    tp = inferior_thread ();
  else
    tp = find_thread_ptid (ptid);

  /* Suppress output while calling an inferior function.  */
  if (tp->control.in_infcall)
    return;

  /* To cater for older frontends, emit ^running, but do it only once
     per each command.  We do it here, since at this point we know
     that the target was successfully resumed, and in non-async mode,
     we won't return back to MI interpreter code until the target
     is done running, so delaying the output of "^running" until then
     will make it impossible for frontend to know what's going on.

     In future (MI3), we'll be outputting "^done" here.  */
  if (!running_result_record_printed && mi_proceeded)
    {
      fprintf_unfiltered (raw_stdout, "%s^running\n",
			  current_token ? current_token : "");
    }

  if (ptid_get_pid (ptid) == -1)
    fprintf_unfiltered (raw_stdout, "*running,thread-id=\"all\"\n");
  else if (ptid_is_pid (ptid))
    {
      int count = 0;

      /* Backwards compatibility.  If there's only one inferior,
	 output "all", otherwise, output each resumed thread
	 individually.  */
      iterate_over_inferiors (mi_inferior_count, &count);

      if (count == 1)
	fprintf_unfiltered (raw_stdout, "*running,thread-id=\"all\"\n");
      else
	iterate_over_threads (mi_output_running_pid, &ptid);
    }
  else
    {
      struct thread_info *ti = find_thread_ptid (ptid);

      gdb_assert (ti);
      fprintf_unfiltered (raw_stdout, "*running,thread-id=\"%d\"\n", ti->num);
    }

  if (!running_result_record_printed && mi_proceeded)
    {
      running_result_record_printed = 1;
      /* This is what gdb used to do historically -- printing prompt even if
	 it cannot actually accept any input.  This will be surely removed
	 for MI3, and may be removed even earler.  */
      /* FIXME: review the use of target_is_async_p here -- is that
	 what we want? */
      if (!target_is_async_p ())
	fputs_unfiltered ("(gdb) \n", raw_stdout);
    }
  gdb_flush (raw_stdout);
}

static void
mi_solib_loaded (struct so_list *solib)
{
  struct mi_interp *mi = top_level_interpreter_data ();

  target_terminal_ours ();
  if (gdbarch_has_global_solist (target_gdbarch ()))
    fprintf_unfiltered (mi->event_channel,
			"library-loaded,id=\"%s\",target-name=\"%s\","
			"host-name=\"%s\",symbols-loaded=\"%d\"",
			solib->so_original_name, solib->so_original_name,
			solib->so_name, solib->symbols_loaded);
  else
    fprintf_unfiltered (mi->event_channel,
			"library-loaded,id=\"%s\",target-name=\"%s\","
			"host-name=\"%s\",symbols-loaded=\"%d\","
			"thread-group=\"i%d\"",
			solib->so_original_name, solib->so_original_name,
			solib->so_name, solib->symbols_loaded,
			current_inferior ()->num);

  gdb_flush (mi->event_channel);
}

static void
mi_solib_unloaded (struct so_list *solib)
{
  struct mi_interp *mi = top_level_interpreter_data ();

  target_terminal_ours ();
  if (gdbarch_has_global_solist (target_gdbarch ()))
    fprintf_unfiltered (mi->event_channel,
			"library-unloaded,id=\"%s\",target-name=\"%s\","
			"host-name=\"%s\"",
			solib->so_original_name, solib->so_original_name,
			solib->so_name);
  else
    fprintf_unfiltered (mi->event_channel,
			"library-unloaded,id=\"%s\",target-name=\"%s\","
			"host-name=\"%s\",thread-group=\"i%d\"",
			solib->so_original_name, solib->so_original_name,
			solib->so_name, current_inferior ()->num);

  gdb_flush (mi->event_channel);
}

/* Emit notification about the command parameter change.  */

static void
mi_command_param_changed (const char *param, const char *value)
{
  struct mi_interp *mi = top_level_interpreter_data ();
  struct ui_out *mi_uiout = interp_ui_out (top_level_interpreter ());

  if (mi_suppress_notification.cmd_param_changed)
    return;

  target_terminal_ours ();

  fprintf_unfiltered (mi->event_channel,
		      "cmd-param-changed");

  ui_out_redirect (mi_uiout, mi->event_channel);

  ui_out_field_string (mi_uiout, "param", param);
  ui_out_field_string (mi_uiout, "value", value);

  ui_out_redirect (mi_uiout, NULL);

  gdb_flush (mi->event_channel);
}

/* Emit notification about the target memory change.  */

static void
mi_memory_changed (struct inferior *inferior, CORE_ADDR memaddr,
		   ssize_t len, const bfd_byte *myaddr)
{
  struct mi_interp *mi = top_level_interpreter_data ();
  struct ui_out *mi_uiout = interp_ui_out (top_level_interpreter ());
  struct obj_section *sec;

  if (mi_suppress_notification.memory)
    return;

  target_terminal_ours ();

  fprintf_unfiltered (mi->event_channel,
		      "memory-changed");

  ui_out_redirect (mi_uiout, mi->event_channel);

  ui_out_field_fmt (mi_uiout, "thread-group", "i%d", inferior->num);
  ui_out_field_core_addr (mi_uiout, "addr", target_gdbarch (), memaddr);
  ui_out_field_fmt (mi_uiout, "len", "0x%zx", len);

  /* Append 'type=code' into notification if MEMADDR falls in the range of
     sections contain code.  */
  sec = find_pc_section (memaddr);
  if (sec != NULL && sec->objfile != NULL)
    {
      flagword flags = bfd_get_section_flags (sec->objfile->obfd,
					      sec->the_bfd_section);

      if (flags & SEC_CODE)
	ui_out_field_string (mi_uiout, "type", "code");
    }

  ui_out_redirect (mi_uiout, NULL);

  gdb_flush (mi->event_channel);
}

static int
report_initial_inferior (struct inferior *inf, void *closure)
{
  /* This function is called from mi_intepreter_init, and since
     mi_inferior_added assumes that inferior is fully initialized
     and top_level_interpreter_data is set, we cannot call
     it here.  */
  struct mi_interp *mi = closure;

  target_terminal_ours ();
  fprintf_unfiltered (mi->event_channel,
		      "thread-group-added,id=\"i%d\"",
		      inf->num);
  gdb_flush (mi->event_channel);
  return 0;
}

static struct ui_out *
mi_ui_out (struct interp *interp)
{
  struct mi_interp *mi = interp_data (interp);

  return mi->uiout;
}

/* Save the original value of raw_stdout here when logging, so we can
   restore correctly when done.  */

static struct ui_file *saved_raw_stdout;

/* Do MI-specific logging actions; save raw_stdout, and change all
   the consoles to use the supplied ui-file(s).  */

static int
mi_set_logging (struct interp *interp, int start_log,
		struct ui_file *out, struct ui_file *logfile)
{
  struct mi_interp *mi = interp_data (interp);

  if (!mi)
    return 0;

  if (start_log)
    {
      /* The tee created already is based on gdb_stdout, which for MI
	 is a console and so we end up in an infinite loop of console
	 writing to ui_file writing to console etc.  So discard the
	 existing tee (it hasn't been used yet, and MI won't ever use
	 it), and create one based on raw_stdout instead.  */
      if (logfile)
	{
	  ui_file_delete (out);
	  out = tee_file_new (raw_stdout, 0, logfile, 0);
	}

      saved_raw_stdout = raw_stdout;
      raw_stdout = out;
    }
  else
    {
      raw_stdout = saved_raw_stdout;
      saved_raw_stdout = NULL;
    }
  
  mi_console_set_raw (mi->out, raw_stdout);
  mi_console_set_raw (mi->err, raw_stdout);
  mi_console_set_raw (mi->log, raw_stdout);
  mi_console_set_raw (mi->targ, raw_stdout);
  mi_console_set_raw (mi->event_channel, raw_stdout);

  return 1;
}

extern initialize_file_ftype _initialize_mi_interp; /* -Wmissing-prototypes */

void
_initialize_mi_interp (void)
{
  static const struct interp_procs procs =
    {
      mi_interpreter_init,	/* init_proc */
      mi_interpreter_resume,	/* resume_proc */
      mi_interpreter_suspend,	/* suspend_proc */
      mi_interpreter_exec,	/* exec_proc */
      mi_interpreter_prompt_p,	/* prompt_proc_p */
      mi_ui_out, 		/* ui_out_proc */
      mi_set_logging,		/* set_logging_proc */
      mi_command_loop		/* command_loop_proc */
    };

  /* The various interpreter levels.  */
  interp_add (interp_new (INTERP_MI1, &procs));
  interp_add (interp_new (INTERP_MI2, &procs));
  interp_add (interp_new (INTERP_MI3, &procs));
  interp_add (interp_new (INTERP_MI, &procs));
}
@


1.87
log
@PR gdb/15911: "info threads" changes the default source and line (for "break", "list")

"info threads" changes the default source for "break" and "list", to
whatever the location of the first/bottom thread in the thread list
is...

 (gdb) b start
 (gdb) c
 ...
 (gdb) list
 *lists "start"*
 (gdb) b 23
 Breakpoint 3 at 0x400614: file test.c, line 23.
 (gdb) info threads
   Id   Target Id         Frame
 * 2    Thread 0x7ffff7fcb700 (LWP 1760) "test" start (arg=0x0) at test.c:23
   1    Thread 0x7ffff7fcc740 (LWP 1748) "test" 0x000000323dc08e60 in pthread_join (threadid=140737353922304, thread_return=0x0) at pthread_join.c:93
 (gdb) b 23
 Breakpoint 4 at 0x323dc08d90: file pthread_join.c, line 23.
                                    ^^^^^^^^^^^^^^^
 (gdb) list
 93          lll_wait_tid (pd->tid);
 94
 95
 96        /* Restore cancellation mode.  */
 97        CANCEL_RESET (oldtype);
 98
 99        /* Remove the handler.  */
 100       pthread_cleanup_pop (0);
 101
 102

The issue is that print_stack_frame always sets the current sal to the
frame's sal.  print_frame_info (which print_stack_frame calls to do
most of the work) also sets the last displayed sal, but only if
print_what isn't LOCATION.  Now the call in question, from within
thread.c:print_thread_info, does pass in LOCATION as print_what, but
print_stack_frame doesn't have the same check print_frame_info has.
We could consider adding it, but setting these globals depending on
print_what isn't very clean, IMO.  What we have is two logically
distinct operations mixed in the same function(s):

  #1 - print frame, in the format specified by {print_what,
    print_level and print_args}.

  #2 - We're displaying a frame to the user, and I want the default
    sal to point here, because the program stopped here, or the user
    did some context-changing command (up, down, etc.).

So I added a new parameter to print_stack_frame & friends for point
#2, and went through all calls in the tree adjusting as necessary.

Tested on x86_64 Fedora 17.

gdb/
2013-09-17  Pedro Alves  <palves@@redhat.com>

	PR gdb/15911
	* ada-tasks.c (task_command_1): Adjust call to print_stack_frame.
	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd):
	* corelow.c (core_open):
	* frame.h (print_stack_frame, print_frame_info): New
	'set_current_sal' parameter.
	* infcmd.c (finish_command, kill_command): Adjust call to
	print_stack_frame.
	* inferior.c (inferior_command): Likewise.
	* infrun.c (normal_stop): Likewise.
	* linux-fork.c (linux_fork_context): Likewise.
	* record-full.c (record_full_goto_entry, record_full_restore):
	Likewise.
	* remote-mips.c (common_open): Likewise.
	* stack.c (print_stack_frame): New 'set_current_sal' parameter.
	Use it.
	(print_frame_info): New 'set_current_sal' parameter.  Set the last
	displayed sal depending on the new paremeter instead of looking at
	print_what.
	(backtrace_command_1, select_and_print_frame, frame_command)
	(current_frame_command, up_command, down_command): Adjust call to
	print_stack_frame.
	* thread.c (print_thread_info, restore_selected_frame)
	(do_captured_thread_select): Adjust call to print_stack_frame.
	* tracepoint.c (tfind_1): Likewise.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_frame): Likewise.
	* mi/mi-interp.c (mi_on_normal_stop): Likewise.
	* mi/mi-main.c (mi_cmd_exec_return, mi_cmd_trace_find): Likewise.

	gdb/testsuite/
	* gdb.threads/info-threads-cur-sal-2.c: New file.
	* gdb.threads/info-threads-cur-sal.c: New file.
	* gdb.threads/info-threads-cur-sal.exp: New file.
@
text
@d730 1
a730 1
  if (PIDGET (ptid) == -1)
@


1.86
log
@Remove use of deprecated_command_loop_hook from mi code.

  https://sourceware.org/ml/gdb-patches/2013-08/msg00605.html

gdb/ChangeLog

	* mi/mi-interp.c (mi_command_loop): Change signature to match
	interp_command_loop_ftype.
	(mi1_command_loop): Remove.
	(mi2_command_loop): Remove.
	(mi3_command_loop): Remove.
	(mi_interpreter_resume): Remove setting of
	deprecated_command_loop_hook.
	(_initialize_mi_interp): Set mi_command_loop as the command loop
	callback.
@
text
@d451 1
a451 1
	  print_stack_frame (get_selected_frame (NULL), 0, SRC_AND_LOC);
@


1.85
log
@Remove duplicate call to add_file_handler.

  http://sourceware.org/ml/gdb-patches/2013-08/msg00067.html

This call to add_file_handler is a duplicate of one that is in
gdb_setup_readline that is always executed.

gdb/ChangeLog

        * mi/mi-interp.c (mi_interpreter_resume): Remove call to
        add_file_handler.
@
text
@d46 1
a46 1
static void mi_command_loop (int mi_version);
a54 4
static void mi3_command_loop (void);
static void mi2_command_loop (void);
static void mi1_command_loop (void);

a191 10
  /* If we're _the_ interpreter, take control.  */
  if (current_interp_named_p (INTERP_MI1))
    deprecated_command_loop_hook = mi1_command_loop;
  else if (current_interp_named_p (INTERP_MI2))
    deprecated_command_loop_hook = mi2_command_loop;
  else if (current_interp_named_p (INTERP_MI3))
    deprecated_command_loop_hook = mi3_command_loop;
  else
    deprecated_command_loop_hook = mi2_command_loop;

d311 1
a311 19
mi1_command_loop (void)
{
  mi_command_loop (1);
}

static void
mi2_command_loop (void)
{
  mi_command_loop (2);
}

static void
mi3_command_loop (void)
{
  mi_command_loop (3);
}

static void
mi_command_loop (int mi_version)
d967 2
a968 1
      mi_set_logging		/* set_logging_proc */
@


1.84
log
@	* mi/mi-cmds.h (mi_execute_command): Make "cmd" const.
	* mi/mi-interp.c (mi_interpreter_exec): Make "command" const.
	Remove temporary copy of input string.
	(mi_execute_command_wrapper): Make "cmd" const.
	* mi/mi-main.c (mi_execute_command): Make "string_ptr" const.
	* mi/mi-parse.c (mi_parse_argv): Make "args" const.
	Use const strings.
	(mi_parse): Make "cmd" const.
	Use const strings.
	* mi/mi-parse.h (mi_parse): Make "cmd" const.
@
text
@a171 1
  add_file_handler (input_fd, stdin_event_handler, 0);
@


1.83
log
@gdb/doc:

2013-02-06  Yao Qi  <yao@@codesourcery.com>

	* gdb.texinfo (GDB/MI Async Records): Document new MI
	notification "=tsv-modified".  Update the document of MI
	notification "=tsv-created".
	* observer.texi (GDB Observers): New observer tsv_modified.
	Update observer tsv_created and tsv_deleted.

gdb:

2013-02-06  Yao Qi  <yao@@codesourcery.com>

	* mi/mi-interp.c: Include "tracepoint.h".
	(mi_tsv_modified): Declare.
	(mi_tsv_created, mi_tsv_deleted): Update declaration.
	(mi_interpreter_init): Call observer_attach_tsv_modified.
	(mi_tsv_modified): New.
	(mi_tsv_created, mi_tsv_deleted): Update.
	* tracepoint.c (trace_variable_command): Call
	observer_notify_tsv_modified if the initial value of tsv is
	changed.
	(delete_trace_state_variable): Call
	observer_notify_tsv_deleted earlier.
	(trace_variable_command): Caller update.
	(create_tsv_from_upload): Likewise.
	* observer.sh: Declare "struct trace_state_variable".

	* NEWS: Mention the new MI notification "=tsv-modified".

gdb/testsuite:

2013-02-06  Yao Qi  <yao@@codesourcery.com>

	* gdb.trace/mi-tsv-changed.exp (test_create_delete_tsv): Rename
	to ...
	(test_create_delete_modify_tsv): ... here.  New test on modifying
	the initial value of a tsv.
@
text
@d44 1
a44 1
static void mi_execute_command_wrapper (char *cmd);
d220 1
a220 4
  char *tmp = alloca (strlen (command) + 1);

  strcpy (tmp, command);
  mi_execute_command_wrapper (tmp);
d309 1
a309 1
mi_execute_command_wrapper (char *cmd)
@


1.82
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d39 1
d75 3
a77 2
static void mi_tsv_created (const char *name, LONGEST value);
static void mi_tsv_deleted (const char *name);
d142 1
d569 1
a569 1
mi_tsv_created (const char *name, LONGEST value)
d576 2
a577 2
		      "name=\"%s\",value=\"%s\"\n",
		      name, plongest (value));
d585 1
a585 1
mi_tsv_deleted (const char *name)
d591 1
a591 1
  if (name != NULL)
d593 1
a593 1
			"name=\"%s\"\n", name);
d600 26
@


1.81
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d3 1
a3 1
   Copyright (C) 2002-2005, 2007-2012 Free Software Foundation, Inc.
@


1.80
log
@gdb:
	* breakpoint.c (invalidate_bp_value_on_memory_change): Add one
	more parameter 'inferior'.
	* corefile.c (write_memory_with_notification): Caller update.

	* mi/mi-cmd-var.c: Include "mi-main.h".
	(mi_cmd_var_assign): Set mi_suppress_notification.data_write_memory
	to 1 and restore it later.
	* mi/mi-cmds.c (mi_cmd mi_cmds): Update for "data-write-memory"
	and "data-write-memory-bytes.
	* mi/mi-interp.c: Include objfiles.h.
	(mi_interpreter_init): Call observer_attach_memory_changed.
	(mi_memory_changed): New.
	* mi/mi-main.h (struct mi_suppress_notification) <memory>:
	New field.

	* NEWS: Mention new MI notification "memory-changed".

gdb/doc:

	* observer.texi (GDB Observers): Update observer
	'memory_changed'.
	* gdb.texinfo (GDB/MI Async Records): Document for
	"memory-changed" notification.

gdb/testsuite:

	* gdb.mi/mi-memory-changed.exp: New.
@
text
@d781 1
a781 1
  if (gdbarch_has_global_solist (target_gdbarch))
d805 1
a805 1
  if (gdbarch_has_global_solist (target_gdbarch))
d868 1
a868 1
  ui_out_field_core_addr (mi_uiout, "addr", target_gdbarch, memaddr);
@


1.79
log
@gdb/doc:
2012-09-21  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo (GDB/MI Async Records): Document notification
	'record-started' and 'record-stopped'.
	* observer.texi (GDB Observers): New observer 'record-changed'.
gdb:
2012-09-21  Yao Qi  <yao@@codesourcery.com>

	* mi/mi-interp.c: Declare mi_record_changed.
	(mi_interpreter_init): Call observer_attach_record_changed.
	(mi_record_changed): New.
	* record.c (record_open): Call observer_notify_record_changed.
	(cmd_record_stop): Call observer_notify_record_changed.
	* NEWS: Mention it.

gdb/testsuite:
2012-09-21  Yao Qi  <yao@@codesourcery.com>

	* gdb.mi/mi-record-changed.exp: New.
	* gdb.mi/mi-reverse.exp: Adjust expected output.
@
text
@d38 1
d80 2
d144 1
d847 41
@


1.78
log
@gdb/doc:

	* gdb.texinfo (GDB/MI Async Records): Document new MI
	notifications '=tsv-created' and '=tsv-deleted'.
	* observer.texi (GDB Observers): New observer tsv_created and
	tsv_deleted.

gdb:

	* mi/mi-interp.c: Declare mi_tsv_created and mi_tsv_deleted.
	(mi_interpreter_init): Call observer_attach_tsv_created and
	observer_attach_tsv_deleted.
	(mi_tsv_created, mi_tsv_deleted): New.
	* tracepoint.c (delete_trace_state_variable): Call
	observer_notify_tsv_deleted.
	(trace_variable_command): Call observer_notify_tsv_created.
	(delete_trace_variable_command): Call
	observer_notify_tsv_deleted.
	(create_tsv_from_upload): Call observer_notify_tsv_created.
	* NEWS: Mention it.

gdb/testsuite:

	gdb.trace/mi-tsv-changed.exp: New.
@
text
@d63 1
d128 1
d386 13
@


1.77
log
@gdb/doc:

	* observer.texi (GDB Observers): New observer 'traceframe_changed'.
	* gdb.texinfo (GDB/MI Async Records): Mention new MI notification
	'=traceframe-changed'.

gdb:

	* tracepoint.c (tfind_1): Call observer_notify_traceframe_changed
	if traceframe changed.

	* mi/mi-cmds.c (mi_cmd mi_cmds): Adjust for command
	"trace-find".
	* mi/mi-interp.c: Declare 'mi_traceframe_changed'.
	(mi_interpreter_init): Hook mi_traceframe_changed to observer
	'traceframe_changed'.
	(mi_traceframe_changed): New.
	* mi/mi-main.h (struct mi_suppress_notification) <traceframe>:
	New field.

	* NEWS: Mention the new MI notification.

gdb/testsuite:

	* gdb.trace/mi-traceframe-changed.exp: New.
@
text
@d72 2
d133 2
d544 34
@


1.76
log
@gdb/

	* cli/cli-decode.c (set_cmd_prefix): New.
	(lookup_cmd_for_prefixlist): New.
	(add_prefix_cmd): Call set_cmd_prefix and update field 'prefix'
	of each cmd_list_element in *prefixlist.
	(add_setshow_cmd_full): set_cmd_prefix.
	(add_alias_cmd): Likewise.
	* cli/cli-decode.h (struct cmd_list_element) <prefix>: New field.
	Declare 'auto_boolean_enums'.
	* cli/cli-setshow.c: Include "observer.h".
	(notify_command_param_changed_p): New.
	(add_setshow_auto_boolean_cmd): Move auto_boolean_enums out.
	Remove 'static'.
	(do_setshow_command): Split it to ...
	(do_set_command, do_show_command): ... them.  New.
	(do_set_command): Call observer_notify_command_param_changed if
	notify_command_param_changed_p returns true.
	(cmd_show_list): Caller update.
	* auto-load.c (set_auto_load_cmd): Likewise.
	* remote.c (show_remote_cmd): Likewise.
	* cli/cli-setshow.h: Update declarations.
	* top.c (execute_command): Call do_set_command and do_show_command.

	* NEWS: Mention new MI notification.
	* mi/mi-interp.c: Declare mi_command_param_changed.
	(mi_interpreter_init): Attach mi_command_param_changed to
	observer command_param_changed.
	(mi_command_param_changed): New.
	Remove mi_suppress_breakpoint_notifications.
	Define global variable mi_suppress_notification.
	(mi_breakpoint_created): Update.
	(mi_breakpoint_deleted): Likewise.
	(mi_breakpoint_modified): Likewise.
	* mi/mi-main.c (mi_cmd_execute): Likewise.  Check command
	'gdb-set' and set mi_suppress_notification.
	* mi/mi-main.h: (mi_suppress_notification): New struct.

gdb/doc/

	* observer.texi: New observer command_param_changed.
	* gdb.texinfo (GDB/MI Async Records): Doc for '=cmd-param-changed'.

gdb/testsuite/

	* gdb.mi/mi-cmd-param-changed.exp: New.
	* gdb.mi/mi-cli.exp: Update for MI notification "=cmd-param-changed".
	* gdb.mi/mi-var-rtti.exp, gdb.mi/mi2-cli.exp: Likewise.
	* gdb.mi/mi2-prompt.exp: Likewise.
@
text
@d71 1
d130 1
d515 1
d518 22
@


1.75
log
@	Make logging work for MI.
	* NEWS: Mention it.
	* interps.h (interp_set_logging_ftype): New typedef.
	(struct interp_procs): New field set_logging_proc.
	(current_interp_set_logging): Declare.
	* interps.c (current_interp_set_logging): New function.
	* cli/cli-logging.c: Include interps.h.
	(set_logging_redirect): Call current_interp_set_logging.
	(pop_output_files): Ditto.
	(handle_redirections): Ditto, plus skip ui-out redirect if MI.
	* mi/mi-console.h (mi_console_set_raw): Declare.
	* mi/mi-console.c (mi_console_set_raw): New function.
	* mi/mi-interp.c (saved_raw_stdout): New global.
	(mi_set_logging): New function.
	(_initialize_mi_interp): Add it to interp procs.

	* gdb.mi/mi-logging.exp: New file.
@
text
@d74 1
d132 1
d506 2
a507 2
/* When non-zero, no MI notifications will be emitted in
   response to breakpoint change observers.  */
d509 5
a513 1
int mi_suppress_breakpoint_notifications = 0;
d524 1
a524 1
  if (mi_suppress_breakpoint_notifications)
d555 1
a555 1
  if (mi_suppress_breakpoint_notifications)
d578 1
a578 1
  if (mi_suppress_breakpoint_notifications)
d739 26
@


1.74
log
@	* mi/mi-interp.c (mi_interpreter_init): Set raw_stdout from
	gdb_stdout.
@
text
@d758 48
d818 2
a819 1
      mi_ui_out 		/* ui_out_proc */
@


1.73
log
@gdb/
	Fix double prompt of 'interpreter-exec mi'.
	* mi/mi-interp.c (mi_execute_command_input_handler): New prototype.
	(mi_interpreter_resume): use it.
	(mi_execute_command_input_handler): New function.
	* mi/mi-main.c (mi_execute_command): Move prompt printing to
	mi_execute_command_input_handler.

gdb/testsuite/
	* gdb.mi/mi2-prompt.exp: New file.
@
text
@d84 4
a87 5
  /* HACK: We need to force stdout/stderr to point at the console.
     This avoids any potential side effects caused by legacy code that
     is still using the TUI / fputs_unfiltered_hook.  So we set up
     output channels for this now, and swap them in when we are
     run.  */
d89 1
a89 1
  raw_stdout = stdio_fileopen (stdout);
@


1.72
log
@	* mi/mi-cmd-break.c: Enforce coding standards, fix comments.
	* mi/mi-cmd-disas.c: Ditto.
	* mi/mi-cmd-env.c: Ditto.
	* mi/mi-cmd-file.c: Ditto.
	* mi/mi-cmd-stack.c: Ditto.
	* mi/mi-cmd-target.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-cmds.c: Ditto.
	* mi/mi-cmds.h: Ditto.
	* mi/mi-console.c: Ditto.
	* mi/mi-getopt.c: Ditto.
	* mi/mi-getopt.h: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
	* mi/mi-out.c: Ditto.
	* mi/mi-parse.c: Ditto.
	* mi/mi-parse.h: Ditto.
	* mi/mi-symbol-cmds.c: Ditto.

	* mi/mi-getopt.h: Move mi_opt struct up.
	* mi/mi-main.c (captured_mi_execute_command): Remove redundant
	return.
	* mi/mi-out.c (_initialize_mi_out): Remove empty initialize.
@
text
@d43 1
d155 1
a155 1
  input_handler = mi_execute_command_wrapper;
d301 11
@


1.71
log
@2012-01-06  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* ada-lang.c (ada_exception_name_addr): Add `volatile' keyword
	before `struct gdb_exception'.
	* breakpoint.c (update_global_location_list_nothrow)
	(update_breakpoint_locations, enable_breakpoint_disp): Likewise.
	* cp-abi.c (value_rtti_type): Likewise.
	* cp-support.c (cp_validate_operator): Likewise.
	* infrun.c (insert_exception_resume_breakpoint)
	(check_exception_resume, keep_going): Likewise.
	* mi-interp.c (mi_breakpoint_created)
	(mi_breakpoint_modified): Likewise.
	* rs6000-aix-tdep.c (rs6000_convert_from_func_ptr_addr): Likewise.
	* solib-ia64-hpux.c (ia64_hpux_at_dld_breakpoint_p)
	(ia64_hpux_handle_dld_breakpoint_1): Likewise.
@
text
@d39 3
a41 1
/* These are the interpreter setup, etc. functions for the MI interpreter */
d46 3
a48 2
   so we can report interesting things that happened "behind the mi's
   back" in this command */
d50 1
a50 1
     ATTRIBUTE_PRINTF (1, 0);
d83 5
a87 4
  /* HACK: We need to force stdout/stderr to point at the console.  This avoids
     any potential side effects caused by legacy code that is still
     using the TUI / fputs_unfiltered_hook.  So we set up output channels for
     this now, and swap them in when we are run. */
d91 2
a92 1
  /* Create MI channels */
d132 4
a135 3
      /* The initial inferior is created before this function is called, so we
	 need to report it explicitly.  Use iteration in case future version
	 of GDB creates more than one inferior up-front.  */
d147 2
a148 1
  /* As per hack note in mi_interpreter_init, swap in the output channels... */
d166 1
a166 1
  /* Route error and log output through the MI */
d169 1
a169 1
  /* Route target output through the MI. */
d171 1
a171 1
  /* Route target error through the MI as well. */
d180 1
a180 1
  /* If we're _the_ interpreter, take control. */
d210 2
a211 1
/* Never display the default gdb prompt in mi case.  */
d240 5
a244 4
  /* Insert the MI out hooks, making sure to also call the interpreter's hooks
     if it has any. */
  /* KRS: We shouldn't need this... Events should be installed and they should
     just ALWAYS fire something out down the MI channel... */
d247 1
a247 1
  /* Now run the code... */
d269 6
a274 8
/*
 * mi_insert_notify_hooks - This inserts a number of hooks that are
 * meant to produce async-notify ("=") MI messages while running
 * commands in another interpreter using mi_interpreter_exec.  The
 * canonical use for this is to allow access to the gdb CLI
 * interpreter from within the MI, while still producing MI style
 * output when actions in the CLI command change gdb's state.
*/
d322 1
a322 1
     high bit set is printed using C's octal format. */
d324 2
a325 1
  /* Tell the world that we're alive */
d328 1
d432 5
a436 5
	  /* The normal_stop function has printed frame information into 
	     CLI uiout, or some other non-MI uiout.  There's no way we
	     can extract proper fields from random uiout object, so we print
	     the frame again.  In practice, this can only happen when running
	     a CLI command in MI.  */
d495 1
d499 1
d517 6
a522 6
     mi->event_channel.  One approach would be to just
     call gdb_breakpoint_query, and then use mi_out_put to
     send the current content of mi_outout into mi->event_channel.
     However, that will break if anything is output to mi_uiout
     prior the calling the breakpoint_created notifications.
     So, we use ui_out_redirect.  */
d532 1
d553 1
d571 6
a576 6
     mi->event_channel.  One approach would be to just
     call gdb_breakpoint_query, and then use mi_out_put to
     send the current content of mi_outout into mi->event_channel.
     However, that will break if anything is output to mi_uiout
     prior the calling the breakpoint_created notifications.
     So, we use ui_out_redirect.  */
a584 1

d753 8
a760 8
  {
    mi_interpreter_init,	/* init_proc */
    mi_interpreter_resume,	/* resume_proc */
    mi_interpreter_suspend,	/* suspend_proc */
    mi_interpreter_exec,	/* exec_proc */
    mi_interpreter_prompt_p,	/* prompt_proc_p */
    mi_ui_out 			/* ui_out_proc */
  };
@


1.70
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d494 1
a494 1
  struct gdb_exception e;
d546 1
a546 1
  struct gdb_exception e;
@


1.69
log
@gdb
	PR mi/8444:
	* mi/mi-common.h (EXEC_ASYNC_SOLIB_EVENT, EXEC_ASYNC_FORK)
	(EXEC_ASYNC_VFORK, EXEC_ASYNC_SYSCALL_ENTRY)
	(EXEC_ASYNC_SYSCALL_RETURN, EXEC_ASYNC_EXEC): New constants.
	* mi/mi-common.c (async_reason_string_lookup): Add new reasons.
	* breakpoint.c (print_it_catch_fork, print_it_catch_vfork)
	(print_it_catch_syscall, print_it_catch_exec)
	(internal_bkpt_print_it): Use ui_out.  Emit stop reason.
	(bpstat_print): Add 'kind' argument.  Handle
	TARGET_WAITKIND_LOADED.
	* infrun.c (normal_stop): Update for bpstat_print change.  Don't
	handle TARGET_WAITKIND_LOADED here.
	* breakpoint.h (bpstat_print): Update.
gdb/testsuite
	* lib/mi-support.exp (mi_run_cmd_full): Rename from mi_run_cmd.
	Add "use_mi_command" argument.
	(mi_run_cmd, mi_run_with_cli): New procs.
	* gdb.mi/solib-lib.c: New file.
	* gdb.mi/solib-main.c: New file.
	* gdb.mi/mi-solib.exp: New file.
gdb/doc
	* gdb.texinfo (GDB/MI Async Records): Document new *stopped
	reasons.
@
text
@d3 1
a3 2
   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.69.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2002-2005, 2007-2012 Free Software Foundation, Inc.
@


1.68
log
@	* mi/mi-interp.c (mi_on_normal_stop): Call bpstat_print.
@
text
@d430 2
d434 4
a437 1
	  bpstat_print (bs);
@


1.67
log
@gdb/
2011-09-12  Pedro Alves  <pedro@@codesourcery.com>
	    Matt Rice  <ratmice@@gmail.com>

	PR gdb/13175

	* interps.c (struct interp) <interpreter_out>: Delete field.
	(interp_new): Remove the data and uiout parameters and adjust.
	(interp_set): Only set the current_uiout from the interpreter's
	uiout after initializing the interpreter.  Adjust call to
	init_proc.
	(interp_ui_out): Adjust to call procs->ui_out_proc.
	(interp_data, interp_name): New.
	* interps.h (interp_init_ftype): Add `self' parameter.
	(interp_ui_out_ftype): New typedef.
	(struct interp_procs) <ui_out_proc>: New method pointer.
	(interp_new): Remove the data and uiout parameters.
	(interp_data, interp_name): Declare.
	* tui/tui-interp.c (tui_init): Adjust prototype.
	(tui_ui_out): New.
	(_initialize_tui_interp): Install tui_ui_out.  Don't instanciate
	tui_out here.  Adjust call to interp_new.
	* tui/tui-io.c (tui_initialize_io): Don't set current_uiout here.
	* cli/cli-interp.c (cli_interpreter_init): Adjust prototype.
	(cli_ui_out): New.
	(_initialize_cli_interp): Install it.  Adjust call to interp_new.
	* mi/mi-common.h (struct mi_interp) <uiout>: New field.
	* mi/mi-interp.c (mi_interpreter_init): Adjust prototype.
	Initialize mi->uiout depending on the mi_version as extracted from
	the interpreter's name.
	(mi_ui_out): New.
	(_initialize_mi_interp): Install mi_ui_out.  Adjust calls to
	interp_new.  Don't allocate the ui_out's of the interpreters here.

gdb/testsuite/
2011-09-12  Matt Rice  <ratmice@@gmail.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	PR gdb/13175

	* gdb.base/interp.exp: New tests.
	* gdb.base/interp.c: New file.
@
text
@d432 1
@


1.66
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* ui-out.h (uiout): Rename to ...
	(current_uiout): ... this.
	* ui-out.c (uiout): Rename to ...
	(current_uiout): ... this.
	* ada-lang.c (print_it_exception, print_one_exception)
	(print_mention_exception): Adjust.
	* breakpoint.c (watchpoint_check): Adjust.
	(print_breakpoint_location, print_one_breakpoint, breakpoint_1)
	(default_collect_info, watchpoints_info, print_one_catch_fork)
	(print_one_catch_vfork, print_one_catch_syscall)
	(print_one_catch_exec, mention, print_it_ranged_breakpoint)
	(print_one_ranged_breakpoint, print_mention_ranged_breakpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_it_masked_watchpoint, print_mention_masked_watchpoint)
	(print_it_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint, say_where, bkpt_print_it)
	(bkpt_print_mention, momentary_bkpt_print_it)
	(tracepoint_print_mention, update_static_tracepoint)
	(tracepoints_info, save_breakpoints): Adjust.
	* cli-out.c (field_separator): Adjust.
	* cp-abi.c (list_cp_abis, show_cp_abi_cmd): Adjust.
	* exceptions.c (catch_exceptions_with_msg, catch_errors): Adjust.
	* frame.c (get_current_frame): Adjust.
	* infcmd.c (run_command_1, print_return_value): Adjust.
	* inferior.c (inferior_command, info_inferiors_command): Adjust.
	* infrun.c (print_end_stepping_range_reason): Adjust.
	(print_signal_exited_reason, print_exited_reason): Adjust.
	(print_signal_received_reason, print_no_history_reason): Adjust.
	* interps.c (interp_set): Adjust.
	* osdata.c (info_osdata_command): Adjust.
	* progspace.c (maintenance_info_program_spaces_command): Adjust.
	* remote-fileio.c (remote_fileio_request): Adjust.
	* remote.c (show_remote_cmd): Adjust.
	* solib.c (info_sharedlibrary_command): Adjust.
	* source.c (print_source_lines_base): Adjust.
	* stack.c (print_stack_frame): Adjust.
	(do_gdb_disassembly, print_frame_info, print_frame): Adjust.
	* symfile-mem.c (add_vsyscall_page): Adjust.
	* symfile.c (load_progress, generic_load)
	(print_transfer_performance): Adjust.
	* thread.c (info_threads_command, restore_selected_frame)
	(thread_command): Adjust.
	* top.c (make_cleanup_restore_ui_file): Adjust.
	* tracepoint.c (tvariables_info_1, trace_status_mi, tfind_1)
	(print_one_static_tracepoint_marker): Adjust.
	* cli/cli-cmds.c (print_disassembly): Adjust.
	* cli/cli-decode.c (print_doc_line): Adjust.
	* cli/cli-interp.c (safe_execute_command): Adjust.
	* cli/cli-logging.c (set_logging_redirect, pop_output_files)
	(handle_redirections): Adjust.
	* cli/cli-script.c (show_user_1): Adjust.
	* cli/cli-setshow.c (do_setshow_command, cmd_show_list): Adjust.
	* mi/mi-cmd-break.c (breakpoint_notify): Adjust.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Adjust.
	* mi/mi-cmd-env.c (mi_cmd_env_pwd, mi_cmd_env_path)
	(mi_cmd_env_dir): Adjust.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(print_partial_file_name, mi_cmd_file_list_exec_source_files): Adjust.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_depth, mi_cmd_stack_list_args)
	(list_args_or_locals): Adjust.
	* mi/mi-cmd-var.c (print_varobj, mi_cmd_var_create)
	(mi_cmd_var_delete, mi_cmd_var_set_format, mi_cmd_var_set_frozen)
	(mi_cmd_var_show_format, mi_cmd_var_info_num_children)
	(mi_cmd_var_list_children, mi_cmd_var_info_type)
	(mi_cmd_var_info_path_expression, mi_cmd_var_info_expression)
	(mi_cmd_var_show_attributes, mi_cmd_var_evaluate_expression)
	(mi_cmd_var_assign, mi_cmd_var_update, varobj_update_one): Adjust.
	* mi/mi-interp.c (mi_on_normal_stop): Adjust.
	* mi/mi-main.c (mi_cmd_gdb_exit, mi_cmd_thread_select)
	(mi_cmd_thread_list_ids, mi_cmd_thread_info, print_one_inferior)
	(list_available_thread_groups, mi_cmd_list_thread_groups)
	(mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers)
	(mi_cmd_data_list_register_values, get_register)
	(mi_cmd_data_evaluate_expression, mi_cmd_data_read_memory)
	(mi_cmd_data_read_memory_bytes, mi_cmd_list_features)
	(mi_cmd_list_target_features, mi_cmd_add_inferior)
	(mi_execute_command, mi_load_progress): Adjust.
	* mi/mi-symbol-cmds.c (mi_cmd_symbol_list_lines): Adjust.
	* python/py-auto-load.c (print_script, info_auto_load_scripts):
	Adjust.
	* python/py-breakpoint.c (bppy_get_commands): Adjust.
	* tui/tui-interp.c (tui_command_loop): Adjust.
	* tui/tui-io.c (tui_setup_io, tui_initialize_io): Adjust.
@
text
@d75 1
a75 1
mi_interpreter_init (int top_level)
d78 2
d95 16
d722 8
d741 2
a742 1
    mi_interpreter_prompt_p	/* prompt_proc_p */
d746 4
a749 7
  interp_add (interp_new (INTERP_MI1, NULL, mi_out_new (1), &procs));
  interp_add (interp_new (INTERP_MI2, NULL, mi_out_new (2), &procs));
  interp_add (interp_new (INTERP_MI3, NULL, mi_out_new (3), &procs));

  /* "mi" selects the most recent released version.  "mi2" was
     released as part of GDB 6.0.  */
  interp_add (interp_new (INTERP_MI, NULL, mi_out_new (2), &procs));
@


1.65
log
@gdb
	* python/py-inferior.c (python_inferior_exit): Use inferior's exit
	code fields.
	* python/py-exitedevent.c (create_exited_event_object): Change
	type of 'exit_code'.  Optionally add exit_code attribute.
	(emit_exited_event): Change type of 'exit_code'.
	* python/py-event.h (emit_exited_event): Update.
	* mi/mi-interp.c (mi_inferior_exit): Print exit code.
	* infrun.c (handle_inferior_event): Set exit code fields on
	inferior.
	* inferior.h (struct inferior) <has_exit_code, exit_code>: New
	fields.
	* inferior.c (exit_inferior_1): Initialize new fields.
gdb/doc
	* gdb.texinfo (GDB/MI Async Records): Document 'exit-code' field.
	(Events In Python): Note that exit_code is optional.
@
text
@d404 1
a404 1
      if (uiout != mi_uiout)
d411 1
a411 1
	  struct ui_out *saved_uiout = uiout;
d413 1
a413 1
	  uiout = mi_uiout;
d415 1
a415 1
	  uiout = saved_uiout;
@


1.64
log
@	MI breakpoint notifications.

        * annotate.c (breakpoint_changed): Adjust parameter type.
        * breakpoint.c (set_breakpoint_condition): Adjust to change
        in breakpoint_modified type.
        (breakpoint_set_commands): Likewise.
        (do_map_commands_command): Likewise.
        (bpstat_check_breakpoint_conditions): Notify that breakpoint has
        changed after bumping hit count.
        (bpstat_stop_status): Likewise.
        (print_one_breakpoint_location): Don't wrap in tuple here.
        (print_one_breakpoint): Always print individual locations.
        For locations, use unnamed tuple.
        (disable_breakpoints_in_unloaded_shlib): Notify that breakpoint
        has changed.
        (create_catchpoint, create_syscall_event_catchpoint): Call
        breakpoint_created obsever.
        (mention): Don't call breakpoint_created observer.
        (create_breakpoint_sal): Call breakpoint_created observer.
        (create_breakpoint, watch_command_1): Likewise.
        (create_ada_exception_breakpoint): Likewise.
        (delete_breakpoint): Call breakpoint_deleted breakpoint.
        (locations_are_equal): New.
        (update_breakpoint_locations): If locations were changed, notify.
        (set_ignore_count, disable_breakpoint, do_enable_breakpoint):
        Call breakpoint_modified observer.

        * mi/mi-cmd-break.c (breakpoint_notify): Adjust.
        (mi_cmd_break_insert): Don't set observers for modify and delete.
        * mi/mi-interp.c (mi_suppress_breakpoint_notifications): New.
        (mi_breakpoint_created, mi_breakpoint_deleted)
        (mi_breakpoint_modified): New.
        (mi_interpreter_init): Hook the above.
        * mi/mi-main.c (mi_cmd_execute): Disable breakpoint notifications
        while -break-* commands are executing.
        * mi/mi-main.h (mi_suppress_breakpoint_notifications): New.
        * mi/mi-out.c (struct ui_out_data): New field original_buffer.
        (mi_redirect): New.
        (mi_ui_out_impl): Hook in mi_redirect.
        (mi_field_skip): True to the name, skip the field, don't output
        a field with an empty value.

        * python/py-breakpoint.c (gdbpy_breakpoint_created)
        (gdbpy_breakpoint_deleted): Adjust.
        * tui/tui-hooks.c (tui_event_create_breakpoint)
        (tui_event_delete_breakpoint, tui_event_modify_breakpoint): Adjust.
@
text
@d369 8
a376 2
  fprintf_unfiltered (mi->event_channel, "thread-group-exited,id=\"i%d\"",
		      inf->num);
@


1.63
log
@gdb
	* mi/mi-symbol-cmds.c (mi_cmd_symbol_list_lines): Fix error
	messages.
	* mi/mi-main.c (mi_cmd_thread_select): Fix error messages.
	(mi_cmd_thread_list_ids): Likewise.
	(mi_cmd_data_list_changed_registers): Likewise.
	(mi_cmd_data_list_register_values): Likewise.
	(mi_cmd_data_write_register_values): Likewise.
	(mi_cmd_data_evaluate_expression): Likewise.
	(mi_cmd_data_read_memory): Likewise.
	(mi_cmd_data_read_memory_bytes): Likewise.
	(mi_cmd_data_write_memory): Likewise.
	(mi_cmd_enable_timings): Likewise.
	* mi/mi-interp.c (mi_cmd_interpreter_exec): Fix error messages.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Fix error messages.
	(mi_cmd_var_delete): Likewise.
	(mi_cmd_var_set_format): Likewise.
	(mi_cmd_var_show_format): Likewise.
	(mi_cmd_var_info_num_children): Likewise.
	(mi_cmd_var_list_children): Likewise.
	(mi_cmd_var_info_type): Likewise.
	(mi_cmd_var_info_expression): Likewise.
	(mi_cmd_var_show_attributes): Likewise.
	(mi_cmd_var_assign): Likewise.
	(mi_cmd_var_update): Likewise.
	(mi_cmd_enable_pretty_printing): Likewise.
	(mi_cmd_var_set_update_range): Likewise.
	* mi/mi-cmd-target.c (mi_cmd_target_file_get): Fix error
	messages.
	(mi_cmd_target_file_put): Likewise.
	(mi_cmd_target_file_delete): Likewise.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames): Fix error
	messages.
	(mi_cmd_stack_info_depth): Likewise.
	(mi_cmd_stack_list_locals): Likewise.
	(mi_cmd_stack_list_args): Likewise.
	(mi_cmd_stack_select_frame): Likewise.
	(mi_cmd_stack_select_frame): Likewise.
	(mi_cmd_stack_info_frame): Likewise.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file): Fix error
	messages.
	(mi_cmd_file_list_exec_source_files): Likewise.
	* mi/mi-cmd-env.c (mi_cmd_env_pwd): Fix error messages.
	(mi_cmd_env_cd): Likewise.
	(mi_cmd_env_path): Likewise.
	(mi_cmd_env_dir): Likewise.
	(mi_cmd_inferior_tty_show): Likewise.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Fix error messages.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Fix error messages.
	(mi_cmd_break_watch): Likewise.
gdb/testsuite
	* gdb.mi/gdb2549.exp: Update for error message changes.
	* gdb.mi/mi-cli.exp: Likewise.
	* gdb.mi/mi-disassemble.exp: Likewise.
	* gdb.mi/mi-pthreads.exp: Likewise.
	* gdb.mi/mi-regs.exp: Likewise.
	* gdb.mi/mi-stack.exp: Likewise.
	* gdb.mi/mi-var-block.exp: Likewise.
	* gdb.mi/mi-var-cmd.exp: Likewise.
	* gdb.mi/mi2-cli.exp: Likewise.
	* gdb.mi/mi2-disassemble.exp: Likewise.
	* gdb.mi/mi2-pthreads.exp: Likewise.
	* gdb.mi/mi2-regs.exp: Likewise.
	* gdb.mi/mi2-stack.exp: Likewise.
	* gdb.mi/mi2-var-block.exp: Likewise.
	* gdb.mi/mi2-var-cmd.exp: Likewise.
@
text
@d38 1
d68 3
d106 3
d455 89
@


1.63.2.1
log
@gdb
	* python/py-inferior.c (python_inferior_exit): Use inferior's exit
	code fields.
	* python/py-exitedevent.c (create_exited_event_object): Change
	type of 'exit_code'.  Optionally add exit_code attribute.
	(emit_exited_event): Change type of 'exit_code'.
	* python/py-event.h (emit_exited_event): Update.
	* mi/mi-interp.c (mi_inferior_exit): Print exit code.
	* infrun.c (handle_inferior_event): Set exit code fields on
	inferior.
	* inferior.h (struct inferior) <has_exit_code, exit_code>: New
	fields.
	* inferior.c (exit_inferior_1): Initialize new fields.
gdb/doc
	* gdb.texinfo (GDB/MI Async Records): Document 'exit-code' field.
	(Events In Python): Note that exit_code is optional.
@
text
@d362 2
a363 8
  if (inf->has_exit_code)
    fprintf_unfiltered (mi->event_channel,
			"thread-group-exited,id=\"i%d\",exit-code=\"%s\"",
			inf->num, int_string (inf->exit_code, 8, 0, 0, 1));
  else
    fprintf_unfiltered (mi->event_channel,
			"thread-group-exited,id=\"i%d\"", inf->num);

@


1.62
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Internationalization.
	* c-lang.c: Ditto.
	* charset.c: Ditto.
	* fork-child.c: Ditto.
	* nto-procfs.c: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* procfs.c: Ditto.
	* remote-mips.c: Ditto.
	* remote.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* target.c: Ditto.
	* valops.c: Ditto.
	* value.c: Ditto.
	* xml-support.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
@
text
@d195 1
a195 1
    error (_("mi_cmd_interpreter_exec: "
d200 1
a200 1
    error (_("mi_cmd_interpreter_exec: could not find interpreter \"%s\""),
d204 1
a204 1
    error (_("mi_cmd_interpreter_exec: interpreter \"%s\" "
@


1.61
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* cli/cli-cmds.c: Shorten lines of >= 80 columns.
	* cli/cli-decode.c: Ditto.
	* cli/cli-dump.c: Ditto.
	* cli/cli-logging.c: Ditto.
	* cli/cli-script.c: Ditto.
	* cli/cli-setshow.c: Ditto.
	* common/signals.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-disas.c: Ditto.
	* mi/mi-cmd-stack.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-cmds.c: Ditto.
	* mi/mi-common.h: Ditto.
	* mi/mi-console.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
	* osf-share/cma_attr.c: Ditto.
	* osf-share/cma_deb_core.h: Ditto.
	* osf-share/cma_debug_client.h: Ditto.
	* osf-share/cma_handle.h: Ditto.
	* osf-share/cma_mutex.h: Ditto.
	* osf-share/cma_stack_int.h: Ditto.
	* osf-share/cma_tcb_defs.h: Ditto.
	* python/py-auto-load.c: Ditto.
	* python/py-breakpoint.c: Ditto.
	* python/py-cmd.c: Ditto.
	* python/py-frame.c: Ditto.
	* python/py-objfile.c: Ditto.
	* python/py-param.c: Ditto.
	* python/py-progspace.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-value.c: Ditto.
	* python/python-internal.h: Ditto.
	* python/python.c: Ditto.
	* tui/tui-data.c: Ditto.
	* tui/tui-disasm.c: Ditto.
	* tui/tui-hooks.c: Ditto.
	* tui/tui-io.c: Ditto.
	* tui/tui-layout.c: Ditto.
	* tui/tui-regs.c: Ditto.
	* tui/tui-source.c: Ditto.
	* tui/tui-stack.c: Ditto.
	* tui/tui-win.c: Ditto.
	* tui/tui-windata.c: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d195 2
a196 1
    error ("mi_cmd_interpreter_exec: Usage: -interpreter-exec interp command");
d200 1
a200 1
    error ("mi_cmd_interpreter_exec: could not find interpreter \"%s\"",
d204 2
a205 2
    error ("mi_cmd_interpreter_exec: interpreter \"%s\" "
	   "does not support command execution",
@


1.60
log
@run copyright.sh for 2011.
@
text
@d199 2
a200 1
    error ("mi_cmd_interpreter_exec: could not find interpreter \"%s\"", argv[0]);
d203 2
a204 1
    error ("mi_cmd_interpreter_exec: interpreter \"%s\" does not support command execution",
d236 6
a241 5
 * mi_insert_notify_hooks - This inserts a number of hooks that are meant to produce
 * async-notify ("=") MI messages while running commands in another interpreter
 * using mi_interpreter_exec.  The canonical use for this is to allow access to
 * the gdb CLI interpreter from within the MI, while still producing MI style output
 * when actions in the CLI command change gdb's state.
@


1.59
log
@gdb/
	Rename and move inferior_thread_state and inferior_status.
	* gdbthread.h (struct thread_control_state): New struct, move fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step and stop_bpstat here from struct thread_info.
	(struct thread_suspend_state): New struct, move field stop_signal here
	from struct thread_info.
	(struct thread_info): Move the fields above from this struct.
	* inferior.h: Move the inferior_thread_state and inferior_status
	declarations comment to their definitions at infrun.c.
	(struct inferior_control_state): New struct, move field stop_soon from
	struct inferior here.
	(struct inferior_suspend_state): New empty struct.
	(struct inferior): New fields control and suspend.  Move out field
	stop_soon.
	* infrun.c (struct inferior_thread_state): Rename to ...
	(infcall_suspend_state): ... here.  Replace field stop_signal by
	fields thread_suspend and inferior_suspend.
	(save_inferior_thread_state): Rename to ...
	(save_infcall_suspend_state): ... here.  New variable inf.  Update the
	code for new fields.
	(restore_inferior_thread_state): Rename to ...
	(restore_infcall_suspend_state): ... here.  New variable inf.  Update
	the code for new fields.
	(do_restore_inferior_thread_state_cleanup): Rename to ...
	(do_restore_infcall_suspend_state_cleanup): ... here.
	(make_cleanup_restore_inferior_thread_state): Rename to ...
	(make_cleanup_restore_infcall_suspend_state): ... here.
	(discard_inferior_thread_state): Rename to ...
	(discard_infcall_suspend_state): ... here.
	(get_inferior_thread_state_regcache): Rename to ...
	(get_infcall_suspend_state_regcache): ... here.
	(struct inferior_status): Rename to ...
	(struct infcall_control_state): ... here.  Replace fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step, stop_bpstat and stop_soon by fields thread_control and
	inferior_control.
	(save_inferior_status): Rename to ...
	(save_infcall_control_state): ... here.  Update the code for new
	fields.
	(restore_inferior_status): Rename to ...
	(restore_infcall_control_state): ... here.  Update the code for new
	fields.
	(do_restore_inferior_status_cleanup): Rename to ...
	(do_restore_infcall_control_state_cleanup): ... here.
	(make_cleanup_restore_inferior_status): Rename to ...
	(make_cleanup_restore_infcall_control_state): ... here.
	(discard_inferior_status): Rename to ...
	(discard_infcall_control_state): ... here.
	* alpha-tdep.c, breakpoint.c, dummy-frame.c, dummy-frame.h,
	exceptions.c, fbsd-nat.c, gdbthread.h, infcall.c, infcmd.c,
	inferior.c, inferior.h, infrun.c, linux-nat.c, mi/mi-interp.c,
	mips-tdep.c, procfs.c, solib-irix.c, solib-osf.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, thread.c, windows-nat.c: Update all the
	references to the moved fields and renamed functions.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010
@


1.58
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* mi/mi-cmd-break.c: White space.
	* mi/mi-cmd-env.c: White space.
	* mi/mi-cmds.c: White space.
	* mi/mi-cmd-stack.c: White space.
	* mi/mi-cmd-var.c: White space.
	* mi/mi-console.c: White space.
	* mi/mi-getopt.c: White space.
	* mi/mi-interp.c: White space.
	* mi/mi-main.c: White space.
	* mi/mi-out.c: White space.
	* mi/mi-parse.c: White space.
@
text
@d437 1
a437 1
      if (tp->in_infcall)
d480 1
a480 1
  if (tp->in_infcall)
@


1.57
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* mi/mi-out.c (mi_table_begin): Delete unused variable.
	* mi/mi-cmd-var.c (print_varobj): Delete unused variable.
	(mi_cmd_var_list_children): Delete unused variable.
	(varobj_update_one): Delete unused variable.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Delete unused variables.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_locals):
	Delete unused variable.
	(mi_cmd_stack_list_variables): Delete unused variable.
	(list_args_or_locals): Delete unused variable.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file):
	Delete unused variables.
	(mi_cmd_file_list_exec_source_files): Delete unused variable.
	* mi/mi-cmd-target.c (mi_cmd_target_file_delete):
	Delete unused variable.
	* mi/mi-interp.c (mi_interpreter_exec): Delete unused variable.
	(mi_cmd_interpreter_exec): Delete unused variable.
	(mi_on_normal_stop): Delete unused variable.
	* mi/mi-main.c (run_one_inferior): Delete unused variable.
	(print_one_inferior): Delete unused variables.
	(mi_execute_command): Delete unused variable.
	(mi_cmd_execute): Delete unused variable.
	(timestamp): Delete unused variable.
@
text
@d116 1
a117 1

d173 1
d217 1
d332 1
d344 1
d356 1
d367 1
d386 1
d395 1
d407 1
d409 1
a409 1
			    pid_to_thread_id (inferior_ptid));		  		  
d436 1
d516 1
d539 1
d563 1
d589 1
@


1.56
log
@gdb/
	* ada-lang.c (lim_warning): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* amd64-tdep.c (amd64_insn_length_fprintf): Likewise.
	* cli-out.c (cli_field_fmt): New ATTRIBUTE_PRINTF.
	(cli_message, out_field_fmt): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* complaints.c (find_complaint): New ATTRIBUTE_PRINTF.
	(vcomplaint): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* complaints.h (complaint, internal_complaint): Likewise.
	* defs.h: Change ATTR_FORMAT to ATTRIBUTE_PRINTF in the top comment.
	(ATTR_FORMAT): Remove.
	(query, nquery, yquery, vprintf_filtered, vfprintf_filtered)
	(fprintf_filtered, fprintfi_filtered, printf_filtered, printfi_filtered)
	(vprintf_unfiltered, vfprintf_unfiltered, fprintf_unfiltered)
	(printf_unfiltered, xasprintf, xvasprintf, xstrprintf, xstrvprintf)
	(xsnprintf, verror, error, vfatal, fatal, internal_verror)
	(internal_error, internal_vwarning, internal_warning, warning)
	(vwarning): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* disasm.c (fprintf_disasm): Likewise.
	* exceptions.c (throw_it): Likewise.
	* exceptions.h (exception_fprintf, throw_verror, throw_vfatal)
	(throw_error): Likewise.
	* language.h (type_error, range_error): Likewise.
	* linespec.c (cplusplus_error): Likewise.
	* mi/mi-interp.c (mi_interp_query_hook): Likewise.
	* mi/mi-out.c (mi_field_fmt, mi_message): Likewise.
	* monitor.c (monitor_debug): Likewise.
	* parser-defs.h (parser_fprintf): Likewise.
	* serial.h (serial_printf): Likewise.
	* tui/tui-hooks.c (tui_query_hook): Likewise.
	* ui-out.c (default_field_fmt, default_message, uo_field_fmt)
	(uo_message): Likewise.
	* ui-out.h (ui_out_field_fmt, ui_out_message): Likewise.
	* utils.c (vfprintf_maybe_filtered, internal_vproblem, defaulted_query):
	Likewise.
	* xml-support.h (gdb_xml_debug, gdb_xml_error): Likewise.
@
text
@a171 1
  static struct gdb_exception ok;
a189 1
  struct interp_procs *procs;
a375 1
  struct mi_interp *mi = top_level_interpreter_data ();
@


1.55
log
@	Multiexec MI

	* breakpoint.c (clear_syscall_counts): Take struct inferior*.
	* inferior.c (add_inferior_silent): Notify inferior_added
	observer.
	(delete_inferior_1): Notify inferior_removed observer.
	(exit_inferior_1): Pass inferior, not pid, to observer.
	(inferior_appeared): Likewise.
	(add_inferior_with_spaces): New.
	(add_inferior_command): Use the above.
	* inferior.h (delete_inferior_1, add_inferior_with_spaces):
	Declare.

	* inflow.c (inflow_inferior_exit): Likewise.
	* jit.c (jit_inferior_exit_hook): Likewise.

	* mi/mi-cmds.c (mi_cmds): Register add-inferior and
	remove-inferior.
	* mi/mi-cmds.h (mi_cmd_add_inferior, mi_cmd_remove_inferior): New.
	* mi/mi-interp.c (mi_inferior_added, mi_inferior_removed): New.
	(report_initial_inferior): New.
	(mi_inferior_removed): Register the above. Make sure
	inferior_added observer is called on the first inferior.
	(mi_new_thread, mi_thread_exit): Thread group is now identified by
	inferior number, not pid.
	(mi_solib_loaded, mi_solib_unloaded): Report which inferiors are
	affected.
	* mi/mi-main.c (current_context): New.
	(proceed_thread_callback): Use typed closure.
	Proceed everything if pid is 0. Most implementation split into
	(proceed_thread): ... this.
	(run_one_inferior): New.
	(mi_cmd_exec_continue, mi_cmd_exec_interrupt, mi_cmd_exec_run):
	Adjust for multiexec behaviour.
	(mi_cmd_add_inferior, mi_cmd_remove_inferior): New.
	(mi_cmd_execute): Handle the 'thread-group' option here.
	Do some extra checks.
	* mi-parse.c (mi_parse): Handle the --all and --thread-group
	options.
	* mi-parse.h (struct mi_parse): New fields all and thread_group.
@
text
@d47 1
a47 1
     ATTR_FORMAT (printf, 1, 0);
@


1.54
log
@	Implement core awareness.

	* bcache.c (compare_ints): Remove
	(print_percentage): Use compare_positive_ints.
	* defs.h (compare_positive_ints): Declare.
	* linux-nat.h (struct lin_lwp): New field core.
	(linux_nat_core_of_thread_1): Declare.
	* linux-nat.c (add_lwp): Init the 'core' field.
	(linux_nat_wait_1): Record the core.
	(linux_nat_core_of_thread_1, linux_nat_core_of_thread): New.
	(linux_nat_add_target): Register the above.
	* linux-thread-db.c (update_thread_core): New.
	(thread_db_find_new_threads): Update core information for
	every thread.
	* remote.c (struct private_thread_info): New.
	(free_private_thread_info, demand_private_info): New.
	(PACKET_qXfer_threads, use_osdata_threads): New.
	(struct thread_item, threads_parsing_context
	(start_thread, end_thread, thread_attributes)
	(thread_children, threads_children, threads_elements): New.
	(remote_threads_info): Try qXfer:threads before anything
	else.
	(remote_protocol_packets): Register qXfer:threads.
	(remote_open_1): Init use_osdata_threads.
	(struct stop_reply): New field 'core'.
	(remote_parse_stop_reply): Parse core number.
	(process_stop_reply): Record core number.
	(remote_xfer_partial): Handle qXfer:threads.
	(remote_core_of_thread): New.
	(init_remote_ops): Register remote_core_of_thread.
	(_initialize_remote): Register qXfer:read.
	* target.c (target_core_of_thread): New
	* target.h (enum target_object): New value TARGET_OBJECT_THREADS.
	(struct target_ops): New field to_core_of_threads.
	(target_core_of_thread): Declare.
	* gdbthread.h (struct thread_info): New field private_dtor.
	* thread.c (print_thread_info): Report the core.
	* ui-out.c (MAX_UI_OUT_LEVELS): Increase.
	* utils.c (compare_positive_ints): New.
	* features/threads.dtd: New.
	* mi/mi-interp.c (mi_on_normal_stop): Report the core.
	* mi/mi-main.c (struct collect_cores_data, collect_cores)
	(do_nothing, free_vector_of_osdata_items)
	(splay_tree_int_comparator, free_splay_tree): New.
	(print_one_inferior_data): Implemented printing of selected
	inferiors.  Collect and print cores.
	(output_cores): New.
	(mi_cmd_list_thread_groups): Support --recurse.  Permit specifying
	thread groups together with --available.
@
text
@d59 4
a62 2
static void mi_inferior_appeared (int pid);
static void mi_inferior_exit (int pid);
d68 2
d93 1
d96 1
d102 5
d299 3
d304 2
a305 2
		      "thread-created,id=\"%d\",group-id=\"%d\"", 
		      t->num, t->ptid.pid);
d313 1
d318 2
d323 13
a335 2
		      "thread-exited,id=\"%d\",group-id=\"%d\"", 
		      t->num,t->ptid.pid);
d339 2
a340 2
void
mi_inferior_appeared (int pid)
d344 3
a346 2
  fprintf_unfiltered (mi->event_channel, "thread-group-created,id=\"%d\"",
		      pid);
d351 1
a351 1
mi_inferior_exit (int pid)
d355 2
a356 2
  fprintf_unfiltered (mi->event_channel, "thread-group-exited,id=\"%d\"", 
		      pid);
d361 11
d532 15
a546 4
  fprintf_unfiltered (mi->event_channel, 
		      "library-loaded,id=\"%s\",target-name=\"%s\",host-name=\"%s\",symbols-loaded=\"%d\"", 
		      solib->so_original_name, solib->so_original_name, 
		      solib->so_name, solib->symbols_loaded);
d555 13
a567 4
  fprintf_unfiltered (mi->event_channel, 
		      "library-unloaded,id=\"%s\",target-name=\"%s\",host-name=\"%s\"", 
		      solib->so_original_name, solib->so_original_name, 
		      solib->so_name);
d571 15
@


1.53
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d342 1
d368 4
@


1.52
log
@        Prevent program output from mix with "^running".

	gdb/
	* mi/mi-interp.c (mi_on_resume): Output token
	and "^running" together, so that nothing else gets
	in between.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009
@


1.51
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d441 2
a442 3
      if (current_token)
	fputs_unfiltered (current_token, raw_stdout);
      fputs_unfiltered ("^running\n", raw_stdout);
@


1.50
log
@	* mi/mi-interp.c (mi_on_resume): Initialize `count' to 0.
@
text
@d59 1
a59 1
static void mi_new_inferior (int pid);
d89 1
a89 1
      observer_attach_new_inferior (mi_new_inferior);
d311 2
a312 2
static void
mi_new_inferior (int pid)
d316 1
a316 1
  fprintf_unfiltered (mi->event_channel, "thread-group-created,id=\"%d\"", 
@


1.49
log
@gdb:
	Global renaming of find_thread_pid to find_thread_ptid.
	* gdbthread.h (find_thread_ptid): Renamed from find_thread_pid.
	* thread.c (find_thread_ptid): Renamed from find_thread_pid.
	All callers updated.
gdbserver:
	Global renaming of find_thread_pid to find_thread_ptid.
	* server.h (find_thread_ptid): Renamed from find_thread_pid.
	* inferiors.c (find_thread_ptid): Renamed from find_thread_pid.
	All callers updated.
@
text
@d450 1
a450 1
      int count;
@


1.48
log
@	* mi/mi-interp.c (mi_on_resume): Account for whole process
	resumes.
@
text
@d425 1
a425 1
    tp = find_thread_pid (ptid);
d464 1
a464 1
      struct thread_info *ti = find_thread_pid (ptid);
@


1.47
log
@	* fork-child.c (fork_inferior): Only reset the thread list if this
	is the first inferior.
	(startup_inferior): If the target support multi-process, tell it
	to resume only the new process.
	* linux-nat.c (num_lwps): Delete global.
	(purge_lwp_list): New function.
	(num_lwps): New function.
	(add_lwp, delete_lwp): Adjust.
	(ptid_match): New.
	(iterate_over_lwps): Add filter argument.  Handle it.
	(linux_nat_attach): Remove FIXME note.
	(linux_nat_detach): Adjust to iterate over threads of the inferior
	we're detaching from.  Adjust to num_lwps being a function.  Don't
	assume the head of the lwp list is the main thread of the process
	we're detaching from.  Don't destroy the LWP list.
	(resume_callback): Add debug output.
	(linux_nat_resume): Handle resuming a single inferior.  Allow a
	wildcard resume in non-stop mode.
	(linux_handle_extended_wait): Don't assume inferior_ptid is the
	correct inferior of the parent LWP.
	(status_callback): Also check lp->waitstatus.
	(select_event_lwp): Add new filter parameter.  Handle it.
	(linux_nat_filter_event): Adjust to num_lwps being a function.
	(linux_nat_wait_1): When adding the first lwp of the inferior, use
	an is_lwp check instead of checking for the number of lwps.
	(linux_nat_wait_1): Handle waiting for a specific tgid.  Handle
	pending process exit statuses.
	(linux_nat_mourn_inferior): Don't destroy all the LWP info.
	Instead delete LWPs of the inferior that we're mourning.  Don't
	unregister from the event loop here.
	(linux_nat_pid_to_str): Use `num_lwps'.
	(linux_nat_make_corefile_notes): Adjust to walk over lwps of a
	single inferior.
	(linux_nat_is_async_p): Check if async was masked out.
	(linux_multi_process): New global.
	(linux_nat_supports_multi_process): New.
	(linux_nat_stop_lwp): Remove LWP filtering.  It is done by the
	caller.
	(linux_nat_stop): Adjust to make iterate_over_lwps itself do the
	LWP filtering.
	(linux_nat_close): New.
	(linux_nat_add_target): Register linux_nat_close and
	linux_nat_supports_multi_process.
	* linux-nat.h (iterate_over_lwps): Add filter argument.
	* linux-thread-db.c (thread_db_handle): Delete.
	(proc_handle, thread_agent, td_init_p, td_ta_new_p)
	(td_ta_map_id2thr_p, td_ta_map_lwp2thr_p, td_ta_thr_iter_p)
	(td_ta_event_addr_p, td_ta_set_event_p, td_ta_event_getmsg_p)
	(td_thr_validate_p, td_thr_get_info_p, td_thr_event_enable_p)
	(td_thr_tls_get_addr_p, td_create_bp_addr, td_death_bp_addr): No
	longer globals, moved to...
	(struct thread_db_info): ... this new structure.
	(thread_db_list): New.
	(add_thread_db_info, get_thread_db_info, delete_thread_db_info):
	New.
	(have_threads_callback): Filter out threads of all inferiors but
	the one specified by the ARGS argument.
	(have_threads): Add ptid argument specifying the inferior we're
	interested in.  Handle it.
	(struct thread_get_info_inout): New.
	(thread_get_info_callback, thread_from_lwp): Adjust to use it.
	(thread_db_attach_lwp): Check that inferior of the passed in
	thread is using thread-db.  Adjust.
	(enable_thread_event): Remove thread_agent parameter.  Instead,
	get it from the per-inferior thread-db info.
	(dladdr_to_soname): Move higher up.
	(enable_thread_event_reporting): Adjust to use per-inferior
	thread-db info.
	(try_thread_db_load_1): Replace `handle' parameter by a
	thread_db_info parameter.  Adjust to use per-inferior thread-db
	info.
	(try_thread_db_load): Adjust to use per-inferior thread-db info.
	(thread_db_load, disable_thread_event_reporting): Ditto.
	(check_for_thread_db): Remove conditional reporting of which
	libthread_db is in use.
	(thread_db_new_objfile): Add comment about inferior_ptid.
	(attach_thread): Adjust to use per-inferior thread-db info.
	(thread_db_detach): Adjust to use per-inferior thread-db info.
	Remove thread event breakpoints of the current inferior.  Only
	unpush the thread-db target if there are no more processes using
	it.
	(check_event): Adjust to use per-inferior thread-db info.
	(thread_db_wait): Adjust to use per-inferior thread-db info.  Only
	unpush the thread-db target if there are no more processes using
	it.
	(thread_db_mourn_inferior): Adjust to use per-inferior thread-db
	info.  Mark breakpoints of the current inferior out before
	deleting them.  Only unpush the thread-db target if there are no
	more processes using it.
	(find_new_threads_callback): Adjust to use per-inferior thread_db
	info.
	(thread_db_find_new_threads_1): Add new ptid argument.  Adjust to
	use per-inferior thread-db info.
	(thread_db_find_new_threads): Adjust to use per-inferior thread-db
	info.
	(thread_db_get_thread_local_address): Adjust.
	(thread_db_get_ada_task_ptid): Adjust.
	* inf-ptrace.c (inf_ptrace_mourn_inferior): Only unpush the target
	if there no more processes left to debug.
	* thread.c (set_running, set_executing): Handle resuming all
	threads of a single inferior.
	* mi/mi-interp.c (mi_output_running_pid): New.
	(mi_inferior_count): New.
	(mi_on_resume): For backwards compatibility, if resuming all
	threads of an inferior, and there is only one inferior, output
	"all".
@
text
@d422 1
a422 1
  if (ptid_equal (ptid, minus_one_ptid))
@


1.46
log
@gdb/
	* infrun.c (infrun_thread_thread_exit): New.
	(_initialize_infrun): Attach it to the thread_exit observer.
	* thread.c (delete_thread_1): Always call the observer, passing it
	the silent flag.
	* mi/mi-interp.c (mi_thread_exit): Add "silent" parameter.  If
	SILENT, return immediately.

gdb/doc/
	* observer.texi (thread_exit): Add "silent" parameter.
@
text
@d392 25
d448 1
a448 1
  else if (thread_count () == 0)
d450 11
a460 3
      /* This is a target where for single-threaded programs the thread
	 table has zero threads.  Don't print any thread-id field.  */
      fprintf_unfiltered (raw_stdout, "*running\n");
@


1.45
log
@gdb/

	* mi/mi-interp.c (mi_interpreter_init): Attach mi_about_to_proceed
	to the about_to_proceed observer notification.
	(mi_about_to_proceed): New.
	(mi_on_resume): Only output ^running and the prompt here if the
	target was proceeded.
	* breakpoint.c (breakpoint_proceeded): New static.
	(breakpoint_about_to_proceed): New.
	(_initialize_breakpoints): Attach breakpoint_about_to_proceed to
	the about_to_proceed observer notification.
	* inferior.h (breakpoint_proceeded): Delete declaration.
	* infrun.c (clear_proceed_status): Don't set breakpoint_proceeded.
	Notify the about_to_proceed observers.
	(struct inferior_status): Delete breakpoint_proceeded member.
	(save_inferior_status): Don't save it.
	(restore_inferior_status): Don't restore it.
	* mi-main.h (mi_proceeded): Declare.
	* mi/mi-main.c (mi_cmd_execute): Clear mi_proceeded before running
	a command.

gdb/doc/

	* observer.texi (about_to_proceed): New.
@
text
@d58 1
a58 1
static void mi_thread_exit (struct thread_info *t);
d296 1
a296 1
mi_thread_exit (struct thread_info *t)
d298 6
a303 1
  struct mi_interp *mi = top_level_interpreter_data ();
@


1.44
log
@	* gdbthread.h (struct thread_info): Add in_infcall member.
	* infcall.c (run_inferior_call): Save, set and restore in_infcall.
	Remove reverences to suppress_resume_observer.  Refresh
	`call_thread' after returning from `proceed'.
	* infcmd.c (suppress_resume_observer): Delete.
	* inferior.h (suppress_resume_observer): Delete declaration.
	* mi/mi-interp.c (mi_on_resume): Suppress output while calling an
	inferior function.
	* thread.c (set_running): Remove references to
	suppress_resume_observer.
	* infrun.c (struct inferior_status): Add in_infcall member.
	(save_inferior_status): Save it.
	(restore_inferior_status): Restore it.
@
text
@d64 1
d95 1
d373 15
d409 1
a409 1
  if (!running_result_record_printed)
d431 1
a431 1
  if (!running_result_record_printed)
@


1.43
log
@	Fix MI timings.

        * mi/mi-main.c (mi_print_timing_maybe): New.
        (captured_mi_execute_command): Simplify. Output timings to
        CLI commands, too.
        (mi_execute_async_cli_command): Do not print timings.
        * mi/mi-main.h (mi_print_timing_maybe): Declare.
        * mi/mi-interp.c (mi_on_normal_stop): Call mi_print_timing_maybe.
@
text
@d373 11
@


1.42
log
@	* mi/mi-interp.c (mi_solib_loaded, mi_solib_unloaded): New.
	(mi_interpreter_init): Register the above.
	* solib.c (clear_solib): Notify solib unload.
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib): Do not
	disable breakpoints on a.out targets.
@
text
@d365 1
@


1.41
log
@        Include frame information for *stopped due to CLI commands.

        * ada-tasks.c (ada_normal_stop_observer): Adjust prototype.
        * infcmd.c (finish_command_continuation): Pass '1' for
        'print_frame' parameter to the observer.
        * infrun.c (normal_stop): Don't print mi-specific information
        here. Pass 'stop_print_frame' to the 'print_frame' parameter
        of the observer.
        * mi/mi-interp.c (mi_on_normal_stop): Adjust prototype.
        If we need to print frame, and current uiout is not the MI one,
        print frame again.
@
text
@d37 1
d62 2
d92 2
d416 25
@


1.40
log
@        Updated copyright notices for most files.
@
text
@d54 1
a54 1
static void mi_on_normal_stop (struct bpstats *bs);
d320 1
a320 1
mi_on_normal_stop (struct bpstats *bs)
d325 1
a325 1
  struct ui_out *uiout = interp_ui_out (top_level_interpreter ());
d328 29
d358 2
a359 2
  mi_out_put (uiout, raw_stdout);
  mi_out_rewind (uiout);
@


1.39
log
@	Implement =thread-selected notification.

        * mi/mi-common.h (struct mi_interp): New, moved from ...
        * mi/mi-interp.c: ...here.
        * mi/mi-main.c (mi_execute_command): If the thread changed
        as result of command, report that.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008
@


1.38
log
@	Include group-id in thread-created notification.

        * mi/mi-interp.c (mi_new_thread, mi_thread_exit): Include
        group id in the output.
@
text
@d34 1
a37 15
struct mi_interp
{
  /* MI's output channels */
  struct ui_file *out;
  struct ui_file *err;
  struct ui_file *log;
  struct ui_file *targ;
  struct ui_file *event_channel;

  /* This is the interpreter for the mi... */
  struct interp *mi2_interp;
  struct interp *mi1_interp;
  struct interp *mi_interp;
};

@


1.37
log
@	Notification for attach/detach.

        * inferior.c: Call the process observers.
        * mi/mi-interp.c (mi_new_inferior, mi_inferior_exit): New.
        (mi_interpreter_init): Register the above.
@
text
@d296 3
a298 1
  fprintf_unfiltered (mi->event_channel, "thread-created,id=\"%d\"", t->num);
d307 3
a309 1
  fprintf_unfiltered (mi->event_channel, "thread-exited,id=\"%d\"", t->num);
@


1.36
log
@	* mi/mi-interp.c (mi_on_resume): Flush raw_stdout.
@
text
@d72 2
d99 2
d310 20
@


1.35
log
@	* mi/mi-interp.c (mi_on_resume): Don't try to report
	resumed thread it the thread list is empty.
@
text
@d365 1
@


1.34
log
@	Kill the return value for all MI command functions.
	* mi/mi-cmds.h (enum mi_cmd_result): Remove.
	(mi_cmd_argv_ftype): Change return type to void.

	* mi/mi-main.c: Adjust all function that implement
	MI commands to return nothing.
	(struct captured_mi_execute_command_actions):
	Remove the rc field.
	(mi_cmd_execute): Return nothing.
	(mi_execute_async_cli_command): Return nothing.
	(mi_cmd_exec_interrupt): Don't print ^done here.
	(mi_cmd_target_select): Don't print ^connected here.
	(captured_mi_execute_command): Don't check for MI_CMD_DONE.
	Special-case -target-select and output ^connected, not ^done.

	* mi/mi-cmd-break.c: Adjust.
	* mi/mi-cmd-disas.c: Adjust.
	* mi/mi-cmd-env.c: Adjust.
	* mi/mi-cmd-file.c: Adjust.
	* mi/mi-cmd-stack.c: Adjust.
	* mi/mi-cmd-target.c: Adjust.
	* mi/mi-cmd-var.c: Adjust.
	* mi/mi-interp.c: Adjust.
	* mi/mi-symbol-cmds.c: Adjust.
@
text
@d341 6
@


1.33
log
@	Emit ^running via observer.
	* mi/mi-interp.c (mi_cmd_interpreter_exec): Do no print
        ^running here.
        (mi_on_resume): Print ^running if not previously output.
        * mi/mi-main.c (running_result_record_printed): New.
        (captured_mi_execute_command): Reset
        running_result_record_printed.  Use running_result_record_printed
        to decide if we should skip ^done.
        (mi_execute_async_cli_command): Don't print ^running here.
        * mi/mi-main.h (current_token, running_result_record_printed):
        Declare.
@
text
@d178 1
a178 1
enum mi_cmd_result
a222 1
  return MI_CMD_DONE;
@


1.32
log
@	Implement *running.
        * Makefile.in: Update dependencies.
        * gdbthread.h (struct thread_info): New field
        running_.
        (set_running, is_running): New.
        * thread.c (set_running, is_running): New.
        * inferior.h (suppress_normal_stop_observer): Rename to...
        (suppress_run_stop_observers): ..this.
        * infcmd.c (suppress_normal_stop_observer): Rename to...
        (suppress_run_stop_observers): ..this.
        (finish_command_continuation, finish_command): Adjust.
        * infcall.c (call_function_by_hand): Adjust.
        * infrun.c (normal_stop): Call set_running.
        * target.c (target_resume): New.  Call set_running.
        * target.h (target_resume): Convert from macro to
        a function.

        * mi/mi-interp.c (mi_on_resume): New.
        (mi_interpreter_init): Register mi_on_resume.
@
text
@a219 10
  /* Okay, now let's see if the command set the inferior going...
     Tricky point - have to do this AFTER resetting the interpreter, since
     changing the interpreter will clear out all the continuations for
     that interpreter... */

  if (target_can_async_p () && target_executing)
    {
      fputs_unfiltered ("^running\n", raw_stdout);
    }

d325 15
d348 12
@


1.31
log
@	Use observers to report stop events in MI.
        * mi/mi-interp.c (mi_on_normal_stop): New.
        (mi_interpreter_init): Register mi_on_normal_stop.
        (mi_interpreter_exec_continuation): Remove.
        (mi_cmd_interpreter_exec): Don't register the above.
        * mi/mi-main.c (captured_mi_execute_command): Don't care
        about sync_execution.
        (mi_execute_async_cli_command): Don't install continuation.  Don't
        print *stopped.
        (mi_exec_async_cli_cmd_continuation): Remove.
@
text
@d72 1
d98 1
d332 13
@


1.30
log
@2008-05-03  Pedro Alves  <pedro@@codesourcery.com>

	* thread.c (delete_thread): Call observer_notify_thread_exit.
        * mi/mi-interp.c (mi_interpreter_init): Register mi_thread_exit as
        thread_exit observer.
        (mi_thread_exit): New.
@
text
@d68 1
d96 1
a175 20
static void
mi_interpreter_exec_continuation (struct continuation_arg *arg, int error_p)
{
  bpstat_do_actions (&stop_bpstat);
  /* It's not clear what to do in the case of errror -- should we assume that
     the target is stopped, or that it still runs?  */
  if (!target_executing)
    {
      fputs_unfiltered ("*stopped", raw_stdout);
      mi_out_put (uiout, raw_stdout);
      fputs_unfiltered ("\n", raw_stdout);
      fputs_unfiltered ("(gdb) \n", raw_stdout);
      gdb_flush (raw_stdout);
    }
  else if (target_can_async_p ())
    {
      add_continuation (mi_interpreter_exec_continuation, NULL);
    }
}

a225 1
      add_continuation (mi_interpreter_exec_continuation, NULL);
a308 1

d314 16
@


1.29
log
@	* mi/mi-interp.c (mi_new_thread): Quote the thread id.
@
text
@d70 1
d92 4
a95 1
    observer_attach_new_thread (mi_new_thread);
d324 10
@


1.28
log
@	exec_cleanup murder.
	* breakpoint.c (until_break_command_continuation): Add
	the 'error' parameter.  Directly delete the breakoint as
	opposed to running cleanups.
	(until_break_command): Install continuation only
	after starting the target.  Don't use exec cleanups,
	use ordinary cleanups.  Discard cleanups is successfully
	started the target in async mode.
	(make_cleanup_delete_breakpoint): Remove.
	* breakpoint.h (make_cleanup_delete_breakpoint): Remove
	declaration.
	* defs.h (do_exec_cleanups, make_exec_cleanup): Remove
	declarations.
	(struct continations): Add the 'error' parameter to the
	continuation_hook field.
	(add_continuation, do_all_continuations)
	(add_intermediate_continuation)
	(do_all_intermediate_continuations): Add the 'error' parameter.
	* exceptions.c (throw_exception): Don't call do_exec_cleanups.
	* inf-loop.c (inferior_event_handler): Instead of calling
	discard_all_continuations, use do_all_continuations with 1 as
	'error' parameter.  Pass 0 as 'error' parameter in existing uses
	of discard_all_continuations.
	* infcmd.c (step_1): Do not use exec cleanup.  For async case, discard
	cleanups.
	(step_once): Install continuation only after resuming the target.
	(step_1_continuation): Disable longjmp breakpoint on error.
	(finish_command_continuation): Add the error parameter.  Delete
	the finish breakpoint directly, do not use cleanups.
	(finish_command): Do not use exec_cleanups. Always setup
	continuation.  For sync case, immediately run them.
	(attach_command_continuation): Add the error parameter.
	* infrun.c (fetch_inferior_event): Do not use exec cleanups to
	remove step_resume_breakpoint -- adjust delete it directly.
	* interps.c (interp_set): Adjust call to do_all_continations.
	* mi/mi-interp.c (mi_interpreter_exec_continuation): Do not
	do exec cleanups.
	* mi/mi-main.c (mi_cmd_target_select): Do not do exec
	cleanups.
	(mi_cmd_execute): Do not use exec_cleanup.
	(mi_execute_async_cli_command): Simplify the string concatenation
	logic.  Do no use exec cleanup.
	(mi_exec_async_cli_cmd_continuation): New parameter error.
	Free last_async_command.
	* top.c (command_line_handler_continuation): New parameter error.
	* utils.c (exec_cleanup_chain, make_exec_cleanup)
	(do_exec_cleanups): Remove.
	(add_continuation, do_all_continations)
	(add_intermediate_continuation)
	(do_all_intermediate_continuations): New parameter error.
@
text
@d316 1
a316 1
  fprintf_unfiltered (mi->event_channel, "thread-created,id=%d", t->num);
@


1.27
log
@gdb/
2008-04-04  Pedro Alves  <pedro@@codesourcery.com>

	* mi/mi-cmds.h (enum mi_cmd_result): Delete MI_CMD_ERROR.
	(mi_error_message): Delete declaration.
	* mi/mi-interp.c (mi_cmd_interpreter_exec): Call error instead of
	returning MI_CMD_ERROR.
	* mi/mi-main.c (mi_error_message): Delete.
	(mi_cmd_exec_interrupt):
	(mi_cmd_thread_select, mi_cmd_thread_list_ids)
	(mi_cmd_thread_info): Call error instead of returning
	MI_CMD_ERROR.
	(mi_cmd_data_list_register_values): Call error instead of
	returning MI_CMD_ERROR.  Adapt to new get_register interface.
	(get_register): Change return typo to void.  Call error instead of
	returning MI_CMD_ERROR.
	(mi_cmd_data_write_register_values): Call error instead of
	returning MI_CMD_ERROR.
	(mi_cmd_list_features): Return MI_CMD_DONE.
	(captured_mi_execute_command): Remove MI_CMD_ERROR handling.
	(mi_execute_command): Always print exceptions with -error.

gdb/testsuite/
2008-04-04  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.mi/mi-disassemble.exp, gdb.mi/mi-stack.exp,
	gdb.mi/mi-syn-frame.exp, gdb.mi/mi-var-block.exp,
	gdb.mi/mi-var-cmd.exp, gdb.mi/mi-var-display.exp,
	gdb.mi/mi2-disassemble.exp, gdb.mi/mi2-stack.exp,
	gdb.mi/mi2-syn-frame.exp, gdb.mi/mi2-var-block.exp,
	gdb.mi/mi2-var-cmd.exp, gdb.mi/mi2-var-display.exp: Update to not
	expect an mi error duplicated in stderr.
@
text
@d171 1
a171 1
mi_interpreter_exec_continuation (struct continuation_arg *arg)
d174 2
a182 1
      do_exec_cleanups (ALL_CLEANUPS);
@


1.26
log
@	Async mode fixes.
        * Makefile.in (infcmd.o, inf-loop.o): Update dependencies.
        * breakpoint.c (bpstat_do_actions): In async mode,
        don't jump to top expecting stop_bpstat to be already
        updated.
        * event-loop.c (start_event_loop): Call async_enable_stdin
        on exception.
        * event-top.c (async_enable_stdin): Do nothing if sync_execution
        is not set.
        (command_handler): Do not setup continuation here.
        (command_line_handler_continuation): Move to...
        * top.c (command_line_handler_continuation): ... here.
        (execute_command): In async mode, register continuation.
        Don't check frame's language in running in async mode.
        * exceptions.c (throw_exception): Don't do exec_error_cleanups.
        * inf-loop.c (complete_execution): Inline into...
        (inferior_event_handler): ... here.  Clear target_executing before
        doing any cleanups.  Don't try to show prompt if the target was
        resumed.
        * infcmd.c (signal_command): Add support for async mode.
        (finish_command): Only add continuation if the target was
        successfully resumed.
        * remote.c (init_async_opts): Register to_get_thread_local_address
        handler.
        * mi/mi-interp.c (mi_cmd_interpreter_exec): Don't mess
        with sync_execution.
        * tui/tui-interp.c (tui_command_loop): Call async_enable_stdin
        on exception.
@
text
@a192 1
  enum mi_cmd_result result = MI_CMD_DONE;
d195 2
d199 1
a199 4
    {
      mi_error_message = xstrprintf ("mi_cmd_interpreter_exec: Usage: -interpreter-exec interp command");
      return MI_CMD_ERROR;
    }
d203 1
a203 4
    {
      mi_error_message = xstrprintf ("mi_cmd_interpreter_exec: could not find interpreter \"%s\"", argv[0]);
      return MI_CMD_ERROR;
    }
d206 2
a207 5
    {
      mi_error_message = xstrprintf ("mi_cmd_interpreter_exec: interpreter \"%s\" does not support command execution",
				     argv[0]);
      return MI_CMD_ERROR;
    }
d217 1
d224 1
a224 1
	  result = MI_CMD_ERROR;
d242 4
a245 1
  return result;
@


1.25
log
@	Implement MI notification for new threads.
        * doc/observer.texi (new_thread): Document.
        * observer.sh: Forward declare struct thread_info.
        * thread.c (add_thread): Notify observer.

        * interps.h (interp_init_ftype): New parameter
        top_level.
        (interp_set): Likewise.
        (top_level_interpreter_data): Declare.
        * interps.c (interp_set): New parameter top_level.
        Pass it to interpreter's init function.  Remember
        top level interpreter.
        (interpreter_exec_cmd): Adjust.
        (top_level_interpreter_data): New.
        * main.c (captured_main): Pass 1 for top_level
        parameter of interp_set.
	* cli/cli-interp.c (cli_interpreter_init): New
        parameter top_level.
        * tui/tui-interp.c (tui_init): New parameter top_level.

        * mi/mi-interp.c (mi_new_thread): New.
        (mi_interpreter_init): If top level, register
        observer for new threads.

        * Makefile.in (mi-interp.o, thread.o): Update dependencies.
@
text
@d227 7
a233 17
      /* We had to set sync_execution = 0 for the mi (well really for Project
         Builder's use of the mi - particularly so interrupting would work.
         But for console commands to work, we need to initialize it to 1 -
         since that is what the cli expects - before running the command,
         and then set it back to 0 when we are done. */
      sync_execution = 1;
      {
	struct gdb_exception e = interp_exec (interp_to_use, argv[i]);
	if (e.reason < 0)
	  {
	    mi_error_message = xstrdup (e.message);
	    result = MI_CMD_ERROR;
	    break;
	  }
      }
      do_exec_error_cleanups (ALL_CLEANUPS);
      sync_execution = 0;
@


1.24
log
@        * mi/mi-interp.c (mi_command_loop): Remove
        commented-out code.
@
text
@d34 2
d69 2
d72 1
a72 1
mi_interpreter_init (void)
d90 3
d324 9
@


1.23
log
@	Updated copyright notices for most files.
@
text
@a307 38
#if 0
  /* HACK: Force stdout/stderr to point at the console.  This avoids
     any potential side effects caused by legacy code that is still
     using the TUI / fputs_unfiltered_hook */
  raw_stdout = stdio_fileopen (stdout);
  /* Route normal output through the MIx */
  gdb_stdout = mi_console_file_new (raw_stdout, "~", '"');
  /* Route error and log output through the MI */
  gdb_stderr = mi_console_file_new (raw_stdout, "&", '"');
  gdb_stdlog = gdb_stderr;
  /* Route target output through the MI. */
  gdb_stdtarg = mi_console_file_new (raw_stdout, "@@", '"');
  /* HACK: Poke the ui_out table directly.  Should we be creating a
     mi_out object wired up to the above gdb_stdout / gdb_stderr? */
  uiout = mi_out_new (mi_version);
  /* HACK: Override any other interpreter hooks.  We need to create a
     real event table and pass in that. */
  deprecated_init_ui_hook = 0;
  /* deprecated_command_loop_hook = 0; */
  deprecated_print_frame_info_listing_hook = 0;
  deprecated_query_hook = 0;
  deprecated_warning_hook = 0;
  deprecated_create_breakpoint_hook = 0;
  deprecated_delete_breakpoint_hook = 0;
  deprecated_modify_breakpoint_hook = 0;
  deprecated_interactive_hook = 0;
  deprecated_readline_begin_hook = 0;
  deprecated_readline_hook = 0;
  deprecated_readline_end_hook = 0;
  deprecated_register_changed_hook = 0;
  deprecated_memory_changed_hook = 0;
  deprecated_context_hook = 0;
  deprecated_target_wait_hook = 0;
  deprecated_call_command_hook = 0;
  deprecated_error_hook = 0;
  deprecated_error_begin_hook = 0;
  deprecated_show_load_progress = mi_load_progress;
#endif
@


1.22
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d3 2
a4 1
   Copyright (C) 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.21
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* mi/mi-interp.c (mi_cmd_interpreter_exec): Dead code, dead variable.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.20
log
@	* gdbarch.sh: Remove deprecated_register_byte.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_register_size, generic_register_byte): Remove.
	* arch-utils.c (generic_register_size, generic_register_byte): Remove.

	* regcache.h (regcache_valid_p): Make REGCACHE parameter const.
	* regcache.c (regcache_valid_p): Allow to query cooked registers in
	read-only register caches.  Make REGCACHE parameter const.
	(regcache_dump): Do not check DEPRECATED_REGISTER_BYTE.

	* mi/mi-main.c (old_regs): Remove.
	(mi_setup_architecture_data, _initialize_mi_main): Remove.
	(register_changed_p): Reimplement to compare two register caches.
	(mi_cmd_data_list_changed_registers): Update caller.
	* mi/mi-main.h (mi_setup_architecture_data): Remove.
	* mi/mi-interp.c (mi_interpreter_init): Do not call
	mi_setup_architecture_data.
@
text
@a220 12
      char *buff = NULL;
      /* Do this in a cleaner way...  We want to force execution to be
         asynchronous for commands that run the target.  */
      if (target_can_async_p () && (strcmp (argv[0], "console") == 0))
	{
	  int len = strlen (argv[i]);
	  buff = xmalloc (len + 2);
	  memcpy (buff, argv[i], len);
	  buff[len] = '&';
	  buff[len + 1] = '\0';
	}

a235 1
      xfree (buff);
@


1.19
log
@	* defs.h (deprecated_registers_changed_hook): Delete declaration.
	* interps.c (clear_interpreter_hooks): Do not clear
	deprecated_registers_changed_hook.
	* regcache.c (registers_changed): Do not call it.
	* top.c (deprecated_registers_changed_hook): Do not define it.
	* mi/mi-interp.c (mi_command_loop): Do not clear it.
	* tui/tui-hooks.c (tui_install_hooks): Do not install it.
	(tui_remove_hooks): Do not remove it.
	(tui_selected_frame_level_changed_hook): Check for negative level.
	Use get_selected_frame.
	(tui_registers_changed_hook): Deleted.
@
text
@a72 4
  /* Why is this a part of the mi architecture? */

  mi_setup_architecture_data ();

@


1.18
log
@Copyright updates for 2007.
@
text
@a351 1
  deprecated_registers_changed_hook = 0;
@


1.17
log
@	* mi/mi-symbol-cmds.c:
	* mi/mi-parse.h:
	* mi/mi-parse.c:
	* mi/mi-out.h:
	* mi/mi-out.c:
	* mi/mi-main.h:
	* mi/mi-main.c:
	* mi/mi-interp.c:
	* mi/mi-getopt.h:
	* mi/mi-getopt.c:
	* mi/mi-console.h:
	* mi/mi-console.c:
	* mi/mi-common.h:
	* mi/mi-common.c:
	* mi/mi-cmds.h:
	* mi/mi-cmds.c:
	* mi/mi-cmd-var.c:
	* mi/mi-cmd-stack.c:
	* mi/mi-cmd-file.c:
	* mi/mi-cmd-env.c:
	* mi/mi-cmd-disas.c:
	* mi/mi-cmd-break.c: Add (C) after Copyright.  Update the FSF
	address.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
@


1.17.14.1
log
@2006-05-13    Changes based on Apple GDB (CVS repository 5th Sept 2005)

	* async-nat-inferior.c, async-nat-inferior.h,
	* async-nat-sigthread.c, async-nat-sigthread.h: New files

	* linux-nat.c: Include async-nat-inferior.h.
	(linux_nat_wait): Add extra argument.  If target_can_async_p
	do something completely different.

	* interps.h (interp_set, interp_set_quiet): New externs.

	* interps.c (interp_set): Make asynchronous.
	(interp_set_quiet): Don't make static.
	(current_interp_command_loop): Call functions with new arguments.

	* target.h (target_wait): Add extra argument.
	(gdb_override_async, gdb_set_async_override) New externs.
	(target_can_async_p): Make conditional on gdb_override_async.

	* target.c (gdb_override_async): New variable.
	(gdb_set_async_override, do_restore_target_async_mask):
	New functions.
	(debug_to_wait): Add extra argument.

	* linux-thread-db.c (thread_db_wait): Add extra argument.

	* wrapper.h (safe_execute_command): Declare structure.

	* top.c (*deprecated_target_wait_hook): Add extra argument.
	(read_command_file): Make asynchronous.

	* remote.c (remote_wait, remote_async_wait): Add extra argument.

	* infrun.c: Include event-top.h
	(wait_for_inferior, fetch_inferior_event): Add extra argument to
	target_wait.
	(proceed): Set target_executing = 0.
	(handle_inferior_event): Call async_disable_stdin if async.

	* inf-ptrace.c: Include inf-loop.h, async-nat-inferior.h.
	(inf_ptrace_him): Create a signal thread.
	(inf_ptrace_wait): Add extra argument to target_wait.

	* inf-loop.c (inferior_event_handler, complete_execution):
	Changes for asynchronous operation (copied verbatim).

	* inf-child.c: Include async-nat-inferior.h.
	(inf_child_target): Use methods async_terminal_inferior
	and async_terminal_ours.

	* i386-linux-nat.c: Include inf-loop.h, async-nat-inferior.h.
	(i386_linux_resume): Call gdb_process_events and then
	async methods.

	* exec.c: Include event-loop.h, async-nat-inferior.h.
	(async_file_handler, standard_async, standard_is_async_p)
	(standard_can_async_p): New functions.
	(init_exec_ops): Initialise above methods.

	* event-top.h (cli_command_loop): Make argument void*.

	* event-top.c (display_gdb_prompt, async_enable_stdin)
	(async_disable_stdin, handle_sigint, async_request_quit)
	(gdb_setup_readline, _initialize_event_loop):
	Changes for asynchronous operation (copied verbatim).
	(cli_command_loop): Make argument void*.

	* event-loop.h (gdb_client_data): Move typedef to defs.h.
	(gdb_create_event): Declare.
	(event_handler_func): Move typedef from event-loop.c.

	* event-loop.c (use_poll): Set to 0.
	(gdb_queue_event, gdb_create_event): New functions.
	(async_queue_event): Don't make static.
	(create_file_event): Use gdb_create_event.
	(gdb_event): Change component from int to void*.
	(process_event, handle_file_event, handle_timer_event):
	Change according to gdb_event.
	(event_handler_func): Move typedef to event-loop.c.

	* defs.h: (gdb_mi_run_status, event_loop_p): New externs.
	(gdb_client_data): Move typedef from event-loop.h.
	(*deprecated_command_loop_hook): Make argument void*.
	(*deprecated_target_wait_hook): Add argument.

	* cli-out.h (cli_quoted_out_new): Declare.

	* cli-out.c (cli_quoted_out_new): New function.
	Include mi/mi-console.h.

	* cli/cli-interp.c: Include inferior.h, mi/mi-console.h.
	(safe_execute_command): Make static.
	(cli_interpreter_resume, cli_interpreter_exec):
	Make asynchronous.
	(cli_quoted_interpreter_resume): New function.
	(_initialize_cli_interp): Add li_command_loop to procs.
	Initialize the console-quoted interpreter.

	* tui/tui-hooks.c (tui_target_wait_hook): Add extra argument.

	* mi/mi-main.h (mi_dont_register_continuation)
	(current_command_token,  mi_interp, mi_interpreter_exec_continuation)
	(mi_continuation_arg): New externs.
	(mi_setup_continuation_arg): Declare.

	* mi/mi-main.c: Include wrapper.h.
	(struct mi_continuation_arg): New structure.
	(mi_interpreter_exec_continuation): Move to mi-interp.c.
	(mi_execute_async_cli_command)
	(mi_exec_async_cli_cmd_continuation): Make asynchronous.
	(mi_setup_continuation_arg): New function.

	* mi/mi-interp.c (mi_interpreter_exec_continuation):
	Move from mi-main.c
	(mi_cmd_interpreter_exec): Switch interpreters.  Make
	asynchronous.
	(mi1_command_loop, mi2_command_loop, mi3_command_loop):
	Make argument void*.

	* Makefile.in (async_nat_inferior_h, async_nat_sigthread_h):
	New variables.
	(gdb$(EXEEXT), $(TUI)$(EXEEXT)): Link with libpthread.
	(async-nat-inferior.o, async-nat-sigthread.o): New rules.
	(COMMON_OBS): Add above object files.
	(exec.o, i386-linux-nat.o, inf-ptrace.o, linux-nat.o):
	Update dependencies.

2006-05-13  Nick Roberts  <nickrob@@snap.net.nz>

	* main.c: (event_loop_p): Re-instate variable.
	(captured_main): Re-instate async/noasync option.
	(print_gdb_help): Describe option again.

	* exec.c(init_exec_ops): Only initialise async methods with async
	option.

	* inf-ptrace.c (inf_ptrace_him): Only reate a signal thread with
	async option.

	* README.async, TODO.async, PROBLEMS.async: New files.
@
text
@d61 3
a63 3
static void mi3_command_loop (void* data);
static void mi2_command_loop (void* data);
static void mi1_command_loop (void* data);
d168 19
a190 1
  struct interp *old_interp;
d193 1
a193 1
  int old_quiet;
a213 15
  
  old_quiet = interp_set_quiet (interp_to_use, 1);

  old_interp = interp_set (interp_to_use); 
  if (old_interp == NULL)
    {
      asprintf (&mi_error_message,
                "Could not switch to interpreter \"%s\".", argv[0]);
      return MI_CMD_ERROR;
    }  
  
  /* Set the global mi_interp.  We need this so that the hook functions
     can leave their results in the mi interpreter, rather than dumping
     them to the console.  */
  mi_interp = old_interp;
a218 8

  /* APPLE LOCAL: I disagree, how do we know the mi is going to always
     be the parent interpreter for whatever child interpreter we are
     running?  The only reason this works in the FSF version is that
     they don't actually switch interpreters, they just hack the
     cli_exec command so it knows how to set just enough of itself not
     to get in the mi's way, which seems a little hacky to me.  */

a256 4
  /* Now do the switch */
  interp_set (old_interp);
  mi_interp = NULL;

a257 1
  interp_set_quiet (interp_to_use, old_quiet);
d263 2
a264 7
  
  /* APPLE LOCAL: The FSF version leaves out the 
     mi_dont_register_continuation.  Maybe this hadn't been added yet when
     they adopted the code.  */
  
  if (target_can_async_p () && target_executing
      && !mi_dont_register_continuation)
a265 6
      struct mi_continuation_arg *cont_args =
        mi_setup_continuation_arg (NULL);
      
      if (current_command_token)
        fputs_unfiltered (current_command_token, raw_stdout);
      
d267 2
a268 3
      add_continuation (mi_interpreter_exec_continuation,
                        (void *) cont_args);
    }  
d306 1
a306 1
mi1_command_loop (void* data)
d312 1
a312 1
mi2_command_loop (void* data)
d318 1
a318 1
mi3_command_loop (void* data)
@


1.17.14.2
log
@(mi_cmd_interpreter_exec): Remove out-of date
comment.
@
text
@d274 4
@


1.16
log
@	* mi/mi-interp.c (mi_interpreter_resume): Route target error
	through the MI.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.15
log
@From  Kaveh R. Ghazi  <ghazi@@caip.rutgers.edu>:
gdb/
	* cli-out.c (cli_field_fmt, cli_message, out_field_fmt): Add
	ATTR_FORMAT or ATTRIBUTE_FPTR_PRINTF.
	* complaints.c (vcomplaint): Likewise.
	* defs.h (xvasprintf, xstrvprintf, verror, vfatal)
	(internal_verror, internal_vwarning, vwarning)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_readline_begin_hook): Likewise.
	* disasm.c (fprintf_disasm): Likewise.
	* exceptions.c (throw_it): Likewise.
	* exceptions.h (throw_verror, throw_vfatal): Likewise.
	* mi/mi-interp.c (mi_interp_query_hook): Likewise.
	* mi/mi-out.c (mi_field_fmt, mi_message): Likewise.
	* tui/tui-hooks.c (tui_query_hook): Likewise.
	* tui/tui-out.c (tui_field_fmt, tui_message, out_field_fmt):
	Likewise.
	* ui-out.c (default_field_fmt, default_message, uo_field_fmt)
	(uo_message): Likewise.
	* ui-out.h (ui_out_field_fmt, ui_out_message, field_fmt_ftype)
	(message_ftype): Likewise.
	* utils.c (vfprintf_maybe_filtered, internal_vproblem)
	(defaulted_query, printchar): Likewise.
gdb/gdbserver/
	* server.h (error, fatal, warning): Add ATTR_FORMAT.
@
text
@d122 2
@


1.14
log
@2005-04-26  Andrew Cagney  <cagney@@gnu.org>

	Rename 'struct exception' to 'struct gdb_exception'.
	* wrapper.c: Update.
	* varobj.c: Update.
	* tui/tui-interp.c: Update.
	* remote.c: Update.
	* mi/mi-main.c: Update.
	* mi/mi-interp.c: Update.
	* linux-thread-db.c: Update.
	* interps.h: Update.
	* interps.c: Update.
	* exceptions.h: Update.
	* exceptions.c: Update.
	* dwarf2loc.c: Update.
	* cli/cli-interp.c: Update.
	* cli/cli-script.c: Update.
	* breakpoint.c: Update.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2003 Free Software Foundation, Inc.
d58 2
a59 1
static int mi_interp_query_hook (const char *ctlstr, va_list ap);
@


1.13
log
@2005-01-13  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (error_last_message, error_init): Delete declaration.
	* utils.c (fatal, vfatal): Call throw_vfatal.
	(error, verror): Call throw_verror;
	(do_write, error_stream_1): Delete function.
	(error_stream): Simplify, call error.
	(error_last_message, error_init, gdb_lasterr): Delete.
	(error_silent): Simplify, call throw_vsilent.
	* mi/mi-interp.c (mi_cmd_interpreter_exec): Dup the message.
	* main.c (captured_main): Delete call to error_init.
	* exceptions.c (throw_verror, throw_verror)
	(throw_vsilent): New functions.
	(do_write, print_and_throw): New functions.
	(last_message): New global.
	(throw_reason): Replace error_last_message with last_message.
	(catch_exceptions_with_msg): Dup the message.
	* exceptions.h (throw_verror, throw_vfatal, throw_vsilent):
	Declare.
@
text
@d148 1
a148 1
static struct exception
d151 1
a151 1
  static struct exception ok;
d241 1
a241 1
	struct exception e = interp_exec (interp_to_use, argv[i]);
@


1.12
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.c (exception_none): New variable.
	* Makefile.in: Update dependencies.
	* interps.c: Include "exceptions.h".
	(interpreter_exec_cmd, interp_exec): Update to return "struct
	exception"
	* exceptions.h (no_exception): Declare.
	* tui/tui-interp.c (tui_exec): Update to return "struct exception"
	* mi/mi-interp.c: Include "exceptions.h".
	(mi_cmd_interpreter_exec, mi_interpreter_exec): Update to return
	'struct exception".
	* cli/cli-interp.c (cli_interpreter_exec, safe_execute_command)
	(do_captured_execute_command): Update to use catch_exception.
	* interps.h: Include "exceptions.h".
	(interp_exec_ftype, interp_exec): Return "struct exception".
@
text
@d244 1
a244 1
	    mi_error_message = e.message;
@


1.11
log
@2004-09-13  Andrew Cagney  <cagney@@gnu.org>

	Eliminate event_loop_p, always has the value 1.
	* defs.h (event_loop_p): Delete macro.
	* breakpoint.c (until_break_command): Simplify.
	* utils.c (prompt_for_continue): Simplify.
	* tracepoint.c (read_actions): Simplify.
	* top.c (throw_exception, execute_command, gdb_readline_wrapper)
	(gdb_rl_operate_and_get_next, command_line_input, get_prompt)
	(set_prompt, init_main): Simplify.
	(init_signals, disconnect): Delete, unused.
	* remote.c (remote_async_resume)
	(extended_remote_async_create_inferior): Simplify.
	* mi/mi-interp.c (mi_input): Delete, unused.
	(mi_interpreter_resume, mi_command_loop): Simplify.
	* interps.c (current_interp_command_loop): Simplify.
	* infrun.c (proceed): Simplify.
	* infcmd.c (run_command, continue_command, step_1, jump_command)
	(until_command, advance_command, finish_command)
	(interrupt_target_command): Simplify.
	* event-top.c (gdb_setup_readline, gdb_disable_readline): Simplify.
@
text
@d30 1
a30 1

d148 1
a148 1
static int
d151 1
d155 1
a155 1
  return 1;
d240 9
a248 6
      if (interp_exec (interp_to_use, argv[i]) < 0)
	{
	  mi_error_message = error_last_message ();
	  result = MI_CMD_ERROR;
	  break;
	}
@


1.10
log
@2004-06-01  Andrew Cagney  <cagney@@gnu.org>

	* mi/mi-cmd-env.c (env_execute_cli_command): Use xstrprintf
	instead of xasprintf.
	* mi/mi-main.c (mi_error_last_message, mi_cmd_exec_interrupt)
	(mi_cmd_thread_select, mi_cmd_thread_list_ids)
	(mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers)
	(mi_cmd_data_list_register_values)
	(get_register, mi_cmd_data_write_register_values)
	(mi_cmd_data_write_register_values)
	(mi_cmd_data_assign, mi_cmd_data_evaluate_expression)
	(mi_cmd_target_download, mi_cmd_target_select)
	(mi_cmd_data_read_memory, mi_cmd_data_write_memory)
	(mi_execute_cli_command, mi_execute_async_cli_command)
	(mi_execute_async_cli_command): Ditto.
	* mi/mi-interp.c (mi_cmd_interpreter_exec) Ditto.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Ditto.
@
text
@a53 1
static char *mi_input (char *);
d101 13
a113 16
  if (event_loop_p)
    {
      /* These overwrite some of the initialization done in
         _intialize_event_loop. */
      call_readline = gdb_readline2;
      input_handler = mi_execute_command_wrapper;
      add_file_handler (input_fd, stdin_event_handler, 0);
      async_command_editing_p = 0;
      /* FIXME: This is a total hack for now.  PB's use of the MI implicitly
         relies on a bug in the async support which allows asynchronous
         commands to leak through the commmand loop.  The bug involves
         (but is not limited to) the fact that sync_execution was
         erroneously initialized to 0.  Duplicate by initializing it
         thus here... */
      sync_execution = 0;
    }
d364 1
a364 10
  if (!event_loop_p)
    simplified_command_loop (mi_input, mi_execute_command);
  else
    start_event_loop ();
}

static char *
mi_input (char *buf)
{
  return gdb_readline (NULL);
@


1.9
log
@2004-06-01  Andrew Cagney  <cagney@@gnu.org>

	* mi/mi-cmds.h (mi_error_last_message): Delete declaration.
	* mi/mi-interp.c (mi_cmd_interpreter_exec): Call
	error_last_message instead of mi_error_last_message.
	* mi/mi-main.c (mi_error_last_message): Delete function.
@
text
@d197 1
a197 2
      xasprintf (&mi_error_message,
		 "mi_cmd_interpreter_exec: Usage: -interpreter-exec interp command");
d204 1
a204 3
      xasprintf (&mi_error_message,
		 "mi_cmd_interpreter_exec: could not find interpreter \"%s\"",
		 argv[0]);
d210 2
a211 3
      xasprintf (&mi_error_message,
		 "mi_cmd_interpreter_exec: interpreter \"%s\" does not support command execution",
		 argv[0]);
@


1.8
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d249 1
a249 1
	  mi_error_last_message ();
@


1.7
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* remote-sds.c (tohex): Delete unused function.  Update copyright.
	* xstormy16-tdep.c (xstormy16_register_virtual_size): Ditto.
	* v850-tdep.c (v850_register_virtual_size): Ditto.
	* target.c (normal_target_post_startup_inferior): Ditto.
	* source.c (ambiguous_line_spec): Ditto.
	* remote.c (adapt_remote_get_threadinfo): Ditto.
	* mi/mi-out.c (out_field_fmt): Ditto.
	* mi/mi-interp.c (mi_interp_read_one_line_hook): Ditto.
	(output_control_change_notification): Ditto.
	* m68k-tdep.c (m68k_register_byte): Ditto.
	(m68k_remote_breakpoint_from_pc): Ditto.
	* ui-out.c (init_ui_out_state): Delete unused declaration.
	* stabsread.c (search_value): Ditto.
	* mi/mi-cmd-env.c (env_cli_command): Ditto.
	* maint.c (print_section_table): Ditto.
	* infrun.c (set_follow_fork_mode_command): Ditto.
@
text
@d130 1
a130 1
  show_load_progress = mi_load_progress;
d134 1
a134 1
    command_loop_hook = mi1_command_loop;
d136 1
a136 1
    command_loop_hook = mi2_command_loop;
d138 1
a138 1
    command_loop_hook = mi3_command_loop;
d140 1
a140 1
    command_loop_hook = mi2_command_loop;
d285 1
a285 1
  query_hook = mi_interp_query_hook;
d291 1
a291 1
  query_hook = NULL;
d344 21
a364 21
  init_ui_hook = 0;
  /* command_loop_hook = 0; */
  print_frame_info_listing_hook = 0;
  query_hook = 0;
  warning_hook = 0;
  create_breakpoint_hook = 0;
  delete_breakpoint_hook = 0;
  modify_breakpoint_hook = 0;
  interactive_hook = 0;
  registers_changed_hook = 0;
  readline_begin_hook = 0;
  readline_hook = 0;
  readline_end_hook = 0;
  register_changed_hook = 0;
  memory_changed_hook = 0;
  context_hook = 0;
  target_wait_hook = 0;
  call_command_hook = 0;
  error_hook = 0;
  error_begin_hook = 0;
  show_load_progress = mi_load_progress;
@


1.7.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d54 1
d102 16
a117 13
  /* These overwrite some of the initialization done in
     _intialize_event_loop.  */
  call_readline = gdb_readline2;
  input_handler = mi_execute_command_wrapper;
  add_file_handler (input_fd, stdin_event_handler, 0);
  async_command_editing_p = 0;
  /* FIXME: This is a total hack for now.  PB's use of the MI
     implicitly relies on a bug in the async support which allows
     asynchronous commands to leak through the commmand loop.  The bug
     involves (but is not limited to) the fact that sync_execution was
     erroneously initialized to 0.  Duplicate by initializing it thus
     here...  */
  sync_execution = 0;
d130 1
a130 1
  deprecated_show_load_progress = mi_load_progress;
d134 1
a134 1
    deprecated_command_loop_hook = mi1_command_loop;
d136 1
a136 1
    deprecated_command_loop_hook = mi2_command_loop;
d138 1
a138 1
    deprecated_command_loop_hook = mi3_command_loop;
d140 1
a140 1
    deprecated_command_loop_hook = mi2_command_loop;
d197 2
a198 1
      mi_error_message = xstrprintf ("mi_cmd_interpreter_exec: Usage: -interpreter-exec interp command");
d205 3
a207 1
      mi_error_message = xstrprintf ("mi_cmd_interpreter_exec: could not find interpreter \"%s\"", argv[0]);
d213 3
a215 2
      mi_error_message = xstrprintf ("mi_cmd_interpreter_exec: interpreter \"%s\" does not support command execution",
				     argv[0]);
d249 1
a249 1
	  mi_error_message = error_last_message ();
d285 1
a285 1
  deprecated_query_hook = mi_interp_query_hook;
d291 1
a291 1
  deprecated_query_hook = NULL;
d344 21
a364 21
  deprecated_init_ui_hook = 0;
  /* deprecated_command_loop_hook = 0; */
  deprecated_print_frame_info_listing_hook = 0;
  deprecated_query_hook = 0;
  deprecated_warning_hook = 0;
  deprecated_create_breakpoint_hook = 0;
  deprecated_delete_breakpoint_hook = 0;
  deprecated_modify_breakpoint_hook = 0;
  deprecated_interactive_hook = 0;
  deprecated_registers_changed_hook = 0;
  deprecated_readline_begin_hook = 0;
  deprecated_readline_hook = 0;
  deprecated_readline_end_hook = 0;
  deprecated_register_changed_hook = 0;
  deprecated_memory_changed_hook = 0;
  deprecated_context_hook = 0;
  deprecated_target_wait_hook = 0;
  deprecated_call_command_hook = 0;
  deprecated_error_hook = 0;
  deprecated_error_begin_hook = 0;
  deprecated_show_load_progress = mi_load_progress;
d372 10
a381 1
  start_event_loop ();
@


1.6
log
@2003-08-08  Andrew Cagney  <cagney@@redhat.com>

	* interps.c (interp_set): Check for a NULL "old_interp".

Index: mi/ChangeLog
2003-08-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (captured_mi_execute_command): Add "mi2" and "mi3" to
	interpreters that hack around CLI.
	* mi-interp.c (mi3_command_loop): New function.
	(mi_interpreter_resume): Check for "mi3", default to "mi2".
@
text
@d3 1
a3 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
a59 2
static char *mi_interp_read_one_line_hook (char *prompt, int repeat,
					   char *anno);
a297 19
}

static char *
mi_interp_read_one_line_hook (char *prompt, int repeat, char *anno)
{
  static char buff[256];
  printf_unfiltered ("=read-one-line,prompt=\"%s\"\n", prompt);
  gdb_flush (gdb_stdout);
  (void) fgets (buff, sizeof (buff), stdin);
  buff[(strlen (buff) - 1)] = 0;
  return buff;
}

static void
output_control_change_notification (char *notification)
{
  printf_unfiltered ("^");
  printf_unfiltered ("%s\n", notification);
  gdb_flush (gdb_stdout);
@


1.6.4.1
log
@merge mainline changes into branch
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2003 Free Software Foundation, Inc.
d60 2
d300 19
@


1.6.8.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.6.8.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2003 Free Software Foundation, Inc.
d60 2
d300 19
@


1.5
log
@Index: ChangeLog
2003-08-07  Andrew Cagney  <cagney@@redhat.com>

	* interps.h (INTERP_MI2, INTERP_MI3): Define.

Index: doc/ChangeLog
2003-08-07  Andrew Cagney  <cagney@@redhat.com>

	* gdb.texinfo (Mode Options): Mention that "mi2" was included in
	GDB 6.0.

Index: mi/ChangeLog
2003-08-07  Andrew Cagney  <cagney@@redhat.com>

	* mi-interp.c (_initialize_mi_interp): Register "mi2" and "mi3".
	Make "mi" select "mi2".

Index: testsuite/gdb.mi/ChangeLog
2003-08-07  Andrew Cagney  <cagney@@redhat.com>

	* mi2-basics.exp: Copy base MI .exp file, set MIFLAGS to -i=mi2.
	* mi2-break.exp, mi2-cli.exp, mi2-console.exp: Ditto.
	* mi2-disassemble.exp, mi2-eval.exp, mi2-file.exp: Ditto.
	* mi2-hack-cli.exp, mi2-pthreads.exp, mi2-read-memory.exp: Ditto.
	* mi2-regs.exp, mi2-return.exp, mi2-simplerun.exp: Ditto.
	* mi2-stack.exp, mi2-stepi.exp, mi2-syn-frame.exp: Ditto.
	* mi2-until.exp, mi2-var-block.exp, mi2-var-child.exp: Ditto.
	* mi2-var-cmd.exp, mi2-var-display.exp, mi2-watch.exp: Ditto.
@
text
@d63 1
d137 1
a137 1
  else if (current_interp_named_p (INTERP_MI))
d139 2
d142 1
a142 1
    return 0;
d337 6
@


1.4
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@d410 1
a410 1
  /* Create MI1 interpreter */
d412 2
d415 3
a417 1
  interp_add (interp_new (INTERP_MI, NULL, mi_out_new (3), &procs));
@


1.4.4.1
log
@Index: ChangeLog
2003-08-07  Andrew Cagney  <cagney@@redhat.com>

	* interps.h (INTERP_MI2, INTERP_MI3): Define.

Index: doc/ChangeLog
2003-08-07  Andrew Cagney  <cagney@@redhat.com>

	* gdb.texinfo (Mode Options): Mention that "mi2" was included in
	GDB 6.0.

Index: mi/ChangeLog
2003-08-07  Andrew Cagney  <cagney@@redhat.com>

	* mi-interp.c (_initialize_mi_interp): Register "mi2" and "mi3".
	Make "mi" select "mi2".

Index: testsuite/gdb.mi/ChangeLog
2003-08-07  Andrew Cagney  <cagney@@redhat.com>

	* mi2-basics.exp: Copy base MI .exp file, set MIFLAGS to -i=mi2.
	* mi2-break.exp, mi2-cli.exp, mi2-console.exp: Ditto.
	* mi2-disassemble.exp, mi2-eval.exp, mi2-file.exp: Ditto.
	* mi2-hack-cli.exp, mi2-pthreads.exp, mi2-read-memory.exp: Ditto.
	* mi2-regs.exp, mi2-return.exp, mi2-simplerun.exp: Ditto.
	* mi2-stack.exp, mi2-stepi.exp, mi2-syn-frame.exp: Ditto.
	* mi2-until.exp, mi2-var-block.exp, mi2-var-child.exp: Ditto.
	* mi2-var-cmd.exp, mi2-var-display.exp, mi2-watch.exp: Ditto.
@
text
@d410 1
a410 1
  /* The various interpreter levels.  */
a411 2
  interp_add (interp_new (INTERP_MI2, NULL, mi_out_new (2), &procs));
  interp_add (interp_new (INTERP_MI3, NULL, mi_out_new (3), &procs));
d413 1
a413 3
  /* "mi" selects the most recent released version.  "mi2" was
     released as part of GDB 6.0.  */
  interp_add (interp_new (INTERP_MI, NULL, mi_out_new (2), &procs));
@


1.4.4.2
log
@2003-08-08  Andrew Cagney  <cagney@@redhat.com>

	* interps.c (interp_set): Check for a NULL "old_interp".

Index: mi/ChangeLog
2003-08-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (captured_mi_execute_command): Add "mi2" and "mi3" to
	interpreters that hack around CLI.
	* mi-interp.c (mi3_command_loop): New function.
	(mi_interpreter_resume): Check for "mi3", default to "mi2".
@
text
@a62 1
static void mi3_command_loop (void);
d136 1
a136 1
  else if (current_interp_named_p (INTERP_MI2))
a137 2
  else if (current_interp_named_p (INTERP_MI3))
    command_loop_hook = mi3_command_loop;
d139 1
a139 1
    command_loop_hook = mi2_command_loop;
a333 6
}

static void
mi3_command_loop (void)
{
  mi_command_loop (3);
@


1.3
log
@2003-02-09  Andrew Cagney  <ac131313@@redhat.com>

	* interps.c (clear_interpreter_hooks): Convert function definition
	to ISO C.

Index: mi/ChangeLog
2003-02-09  Andrew Cagney  <ac131313@@redhat.com>

	* mi-interp.c (mi_remove_notify_hooks): Convert function
	definition to ISO C.
@
text
@d396 2
@


1.2
log
@Add missing files from last commit :-(
@
text
@d288 1
a288 1
mi_remove_notify_hooks ()
@


1.2.2.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@@


1.2.2.2
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d288 1
a288 1
mi_remove_notify_hooks (void)
@


1.2.2.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a395 2
extern initialize_file_ftype _initialize_mi_interp; /* -Wmissing-prototypes */

@


1.2.2.4
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a62 1
static void mi3_command_loop (void);
d136 1
a136 1
  else if (current_interp_named_p (INTERP_MI2))
a137 2
  else if (current_interp_named_p (INTERP_MI3))
    command_loop_hook = mi3_command_loop;
d139 1
a139 1
    command_loop_hook = mi2_command_loop;
a336 6
mi3_command_loop (void)
{
  mi_command_loop (3);
}

static void
d410 1
a410 1
  /* The various interpreter levels.  */
a411 2
  interp_add (interp_new (INTERP_MI2, NULL, mi_out_new (2), &procs));
  interp_add (interp_new (INTERP_MI3, NULL, mi_out_new (3), &procs));
d413 1
a413 3
  /* "mi" selects the most recent released version.  "mi2" was
     released as part of GDB 6.0.  */
  interp_add (interp_new (INTERP_MI, NULL, mi_out_new (2), &procs));
@


1.2.2.5
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2003 Free Software Foundation, Inc.
d60 2
d300 19
@


1.1
log
@file mi-interp.c was initially added on branch kseitz_interps-20020528-branch.
@
text
@d1 412
@


1.1.4.1
log
@Merge kseitz_interps-20020528-branch.
@
text
@a0 450
/* MI Interpreter Definitions and Commands
   Copyright 2002 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdb_string.h"
#include "interps.h"
#include "event-top.h"
#include "event-loop.h"
#include "inferior.h"
#include "ui-out.h"
#include "top.h"

#include "mi.h"
#include "mi-cmds.h"
#include "mi-out.h"
#include "mi-console.h"

/* MI's output channels */
struct ui_file *mi_stdout;
struct ui_file *mi_stderr;
struct ui_file *mi_stdlog;
struct ui_file *mi_stdtarg;
struct ui_file *mi_event_channel;

/* This is the interpreter for the mi... */
struct gdb_interpreter *mi2_interp;
struct gdb_interpreter *mi1_interp;
struct gdb_interpreter *mi_interp;

/* These are the interpreter setup, etc. functions for the MI interpreter */
static int mi_interpreter_init (void *data);
static int mi_interpreter_resume (void *data);
static int mi_interpreter_suspend (void *data);
static int mi_interpreter_exec (void *data, char *command);
static int mi_interpreter_prompt_p (void);

static void mi_execute_command_wrapper (char *cmd);
static void mi_command_loop (int mi_version);
static char *mi_input (char *);

/* These are hooks that we put in place while doing interpreter_exec
   so we can report interesting things that happened "behind the mi's
   back" in this command */
static int mi_interp_query_hook (const char *ctlstr, va_list ap);
static char *mi_interp_read_one_line_hook (char *prompt, int repeat,
					   char *anno);

static void mi2_command_loop (void);
static void mi1_command_loop (void);

static void mi_insert_notify_hooks (void);
static void mi_remove_notify_hooks (void);

static int
mi_interpreter_init (void *data)
{
  static struct gdb_events handlers;

  /* Why is this a part of the mi architecture? */

  mi_setup_architecture_data ();

  /* HACK: We need to force stdout/stderr to point at the console.  This avoids
     any potential side effects caused by legacy code that is still
     using the TUI / fputs_unfiltered_hook.  So we set up output channels for
     this now, and swap them in when we are run. */

  raw_stdout = stdio_fileopen (stdout);

  /* Create MI channels */
  mi_stdout = mi_console_file_new (raw_stdout, "~", '"');
  mi_stderr = mi_console_file_new (raw_stdout, "&", '"');
  mi_stdlog = mi_stderr;
  mi_stdtarg = mi_console_file_new (raw_stdout, "@@", '"');
  mi_event_channel = mi_console_file_new (raw_stdout, "=", 0);

  return 1;
}

static int
mi_interpreter_resume (void *data)
{
  /* As per hack note in mi_interpreter_init, swap in the output channels... */

  gdb_setup_readline ();
  mi_register_gdbarch_swap ();

  if (event_loop_p)
    {
      /* These overwrite some of the initialization done in
         _intialize_event_loop. */
      call_readline = gdb_readline2;
      input_handler = mi_execute_command_wrapper;
      add_file_handler (input_fd, stdin_event_handler, 0);
      async_command_editing_p = 0;
      /* FIXME: This is a total hack for now.  PB's use of the MI implicitly
         relies on a bug in the async support which allows asynchronous
         commands to leak through the commmand loop.  The bug involves
         (but is not limited to) the fact that sync_execution was
         erroneously initialized to 0.  Duplicate by initializing it
         thus here... */
      sync_execution = 0;
    }

  gdb_stdout = mi_stdout;
  /* Route error and log output through the MI */
  gdb_stderr = mi_stderr;
  gdb_stdlog = mi_stdlog;
  /* Route target output through the MI. */
  gdb_stdtarg = mi_stdtarg;

  /* Replace all the hooks that we know about.  There really needs to
     be a better way of doing this... */
  clear_interpreter_hooks ();
  set_gdb_event_hooks (&mi_event_handlers);

  show_load_progress = mi_load_progress;

  /* If we're _the_ interpreter, take control. */
  if (gdb_interpreter_current_is_named_p (GDB_INTERPRETER_MI2))
    command_loop_hook = mi2_command_loop;
  else if (gdb_interpreter_current_is_named_p (GDB_INTERPRETER_MI1))
    command_loop_hook = mi1_command_loop;
  else if (gdb_interpreter_current_is_named_p (GDB_INTERPRETER_MI))
    command_loop_hook = mi2_command_loop;
  else
    return 0;

  return 1;
}

static int
mi_interpreter_suspend (void *data)
{
  gdb_disable_readline ();
  return 1;
}

static int
mi_interpreter_exec (void *data, char *command)
{
  mi_execute_command_wrapper (command);
  return 1;
}

/* Never display the default gdb prompt in mi case.  */
static int
mi_interpreter_prompt_p (void)
{
  return 0;
}

static void
mi_interpreter_exec_continuation (struct continuation_arg *arg)
{
  bpstat_do_actions (&stop_bpstat);
  if (!target_executing)
    {
      fputs_unfiltered ("*stopped", raw_stdout);
      mi_out_put (uiout, raw_stdout);
      fputs_unfiltered ("\n", raw_stdout);
      fputs_unfiltered ("(gdb) \n", raw_stdout);
      gdb_flush (raw_stdout);
      do_exec_cleanups (ALL_CLEANUPS);
    }
  else if (target_can_async_p ())
    {
      add_continuation (mi_interpreter_exec_continuation, NULL);
    }
}

enum mi_cmd_result
mi_cmd_interpreter_exec (char *command, char **argv, int argc)
{
  struct gdb_interpreter *interp_to_use;
  enum mi_cmd_result result = MI_CMD_DONE;
  int i;
  struct gdb_interpreter_procs *procs;

  if (argc < 2)
    {
      xasprintf (&mi_error_message,
		 "mi_cmd_interpreter_exec: Usage: -interpreter-exec interp command");
      return MI_CMD_ERROR;
    }

  interp_to_use = gdb_interpreter_lookup (argv[0]);
  if (interp_to_use == NULL)
    {
      xasprintf (&mi_error_message,
		 "mi_cmd_interpreter_exec: could not find interpreter \"%s\"",
		 argv[0]);
      return MI_CMD_ERROR;
    }

  procs = gdb_interpreter_get_procs (interp_to_use);
  if (!procs->exec_proc)
    {
      xasprintf (&mi_error_message,
		 "mi_cmd_interpreter_exec: interpreter \"%s\" does not support command execution",
		 argv[0]);
      return MI_CMD_ERROR;
    }

  /* Insert the MI out hooks, making sure to also call the interpreter's hooks
     if it has any. */
  /* KRS: We shouldn't need this... Events should be installed and they should
     just ALWAYS fire something out down the MI channel... */
  mi_insert_notify_hooks ();

  /* Now run the code... */

  for (i = 1; i < argc; i++)
    {
      char *buff = NULL;
      /* Do this in a cleaner way...  We want to force execution to be
         asynchronous for commands that run the target.  */
      if (target_can_async_p () && (strcmp (argv[0], "console") == 0))
	{
	  int len = strlen (argv[i]);
	  buff = xmalloc (len + 2);
	  memcpy (buff, argv[i], len);
	  buff[len] = '&';
	  buff[len + 1] = '\0';
	}

      /* We had to set sync_execution = 0 for the mi (well really for Project
         Builder's use of the mi - particularly so interrupting would work.
         But for console commands to work, we need to initialize it to 1 -
         since that is what the cli expects - before running the command,
         and then set it back to 0 when we are done. */
      sync_execution = 1;
      if (procs->exec_proc (gdb_interpreter_get_data (interp_to_use), argv[i]) < 0)
	{
	  mi_error_last_message ();
	  result = MI_CMD_ERROR;
	  break;
	}
      xfree (buff);
      do_exec_error_cleanups (ALL_CLEANUPS);
      sync_execution = 0;
    }

  mi_remove_notify_hooks ();

  /* Okay, now let's see if the command set the inferior going...
     Tricky point - have to do this AFTER resetting the interpreter, since
     changing the interpreter will clear out all the continuations for
     that interpreter... */

  if (target_can_async_p () && target_executing)
    {
      fputs_unfiltered ("^running\n", raw_stdout);
      add_continuation (mi_interpreter_exec_continuation, NULL);
    }

  return result;
}

/*
 * mi_insert_notify_hooks - This inserts a number of hooks that are meant to produce
 * async-notify ("=") MI messages while running commands in another interpreter
 * using mi_interpreter_exec.  The canonical use for this is to allow access to
 * the gdb CLI interpreter from within the MI, while still producing MI style output
 * when actions in the CLI command change gdb's state.
*/

static void
mi_insert_notify_hooks (void)
{
  query_hook = mi_interp_query_hook;
}

static void
mi_remove_notify_hooks ()
{
  query_hook = NULL;
}

static int
mi_interp_query_hook (const char *ctlstr, va_list ap)
{
  return 1;
}

static char *
mi_interp_read_one_line_hook (char *prompt, int repeat, char *anno)
{
  static char buff[256];
  printf_unfiltered ("=read-one-line,prompt=\"%s\"\n", prompt);
  gdb_flush (gdb_stdout);
  (void) fgets (buff, sizeof (buff), stdin);
  buff[(strlen (buff) - 1)] = 0;
  return buff;
}

static void
output_control_change_notification (char *notification)
{
  printf_unfiltered ("^");
  printf_unfiltered ("%s\n", notification);
  gdb_flush (gdb_stdout);
}

static void
mi_execute_command_wrapper (char *cmd)
{
  mi_execute_command (cmd, stdin == instream);
}

static void
mi1_command_loop (void)
{
  mi_command_loop (1);
}

static void
mi2_command_loop (void)
{
  mi_command_loop (2);
}

static void
mi_command_loop (int mi_version)
{
#if 0
  /* HACK: Force stdout/stderr to point at the console.  This avoids
     any potential side effects caused by legacy code that is still
     using the TUI / fputs_unfiltered_hook */
  raw_stdout = stdio_fileopen (stdout);
  /* Route normal output through the MIx */
  gdb_stdout = mi_console_file_new (raw_stdout, "~", '"');
  /* Route error and log output through the MI */
  gdb_stderr = mi_console_file_new (raw_stdout, "&", '"');
  gdb_stdlog = gdb_stderr;
  /* Route target output through the MI. */
  gdb_stdtarg = mi_console_file_new (raw_stdout, "@@", '"');
  /* HACK: Poke the ui_out table directly.  Should we be creating a
     mi_out object wired up to the above gdb_stdout / gdb_stderr? */
  uiout = mi_out_new (mi_version);
  /* HACK: Override any other interpreter hooks.  We need to create a
     real event table and pass in that. */
  init_ui_hook = 0;
  /* command_loop_hook = 0; */
  print_frame_info_listing_hook = 0;
  query_hook = 0;
  warning_hook = 0;
  create_breakpoint_hook = 0;
  delete_breakpoint_hook = 0;
  modify_breakpoint_hook = 0;
  interactive_hook = 0;
  registers_changed_hook = 0;
  readline_begin_hook = 0;
  readline_hook = 0;
  readline_end_hook = 0;
  register_changed_hook = 0;
  memory_changed_hook = 0;
  context_hook = 0;
  target_wait_hook = 0;
  call_command_hook = 0;
  error_hook = 0;
  error_begin_hook = 0;
  show_load_progress = mi_load_progress;
#endif
  /* Turn off 8 bit strings in quoted output.  Any character with the
     high bit set is printed using C's octal format. */
  sevenbit_strings = 1;
  /* Tell the world that we're alive */
  fputs_unfiltered ("(gdb) \n", raw_stdout);
  gdb_flush (raw_stdout);
  if (!event_loop_p)
    simplified_command_loop (mi_input, mi_execute_command);
  else
    start_event_loop ();
}

static char *
mi_input (char *buf)
{
  return gdb_readline (NULL);
}

void
_initialize_mi_interp (void)
{
  struct gdb_interpreter_procs procs =
    {
      mi_interpreter_init,	/* init_proc */
      mi_interpreter_resume,	/* resume_proc */
      mi_interpreter_suspend,	/* suspend_proc */
      mi_interpreter_exec,	/* exec_proc */
      mi_interpreter_prompt_p	/* prompt_proc_p */
    };

  /* Create MI1 interpreter */
  if (mi1_interp == NULL)
    {
      mi1_interp =
	gdb_interpreter_new (GDB_INTERPRETER_MI1, NULL, mi_out_new (1),
			     &procs);
      if (mi1_interp == NULL)
	error
	  ("Couldn't allocate a new interpreter for the mi1 interpreter\n");
      if (gdb_interpreter_add (mi1_interp) != 1)
	error ("Couldn't add the mi1 interpreter to gdb.\n");
    }

  /* Create MI2 interpreter */
  if (mi2_interp == NULL)
    {
      mi2_interp =
	gdb_interpreter_new (GDB_INTERPRETER_MI2, NULL, mi_out_new (2),
			     &procs);
      if (mi2_interp == NULL)
	error
	  ("Couldn't allocate a new interpreter for the mi2 interpreter\n");
      if (gdb_interpreter_add (mi2_interp) != 1)
	error ("Couldn't add the mi2 interpreter to gdb.\n");
    }

  /* Create MI3 interpreter */
  if (mi_interp == NULL)
    {
      mi_interp =
	gdb_interpreter_new (GDB_INTERPRETER_MI, NULL, mi_out_new (3),
			     &procs);
      if (mi_interp == NULL)
	error
	  ("Couldn't allocate a new interpreter for the mi interpreter\n");
      if (gdb_interpreter_add (mi_interp) != 1)
	error ("Couldn't add the mi interpreter to gdb.\n");
    }
}
@


1.1.4.2
log
@Kill off anything not directly related to the CLI command.
@
text
@d132 1
@


1.1.4.3
log
@Clean up.
@
text
@d35 11
a45 14
struct mi_interp
{
  /* MI's output channels */
  struct ui_file *out;
  struct ui_file *err;
  struct ui_file *log;
  struct ui_file *targ;
  struct ui_file *event_channel;

  /* This is the interpreter for the mi... */
  struct interp *mi2_interp;
  struct interp *mi1_interp;
  struct interp *mi_interp;
};
d48 6
d71 2
a72 2
static void *
mi_interpreter_init (void)
d74 1
a74 1
  struct mi_interp *mi = XMALLOC (struct mi_interp);
d88 5
a92 5
  mi->out = mi_console_file_new (raw_stdout, "~", '"');
  mi->err = mi_console_file_new (raw_stdout, "&", '"');
  mi->log = mi->err;
  mi->targ = mi_console_file_new (raw_stdout, "@@", '"');
  mi->event_channel = mi_console_file_new (raw_stdout, "=", 0);
d94 1
a94 1
  return mi;
a99 1
  struct mi_interp *mi = data;
d122 1
a122 1
  gdb_stdout = mi->out;
d124 2
a125 2
  gdb_stderr = mi->err;
  gdb_stdlog = mi->log;
d127 1
a127 1
  gdb_stdtarg = mi->targ;
d136 3
a138 1
  if (current_interp_named_p (INTERP_MI1))
d140 1
a140 1
  else if (current_interp_named_p (INTERP_MI))
d156 1
a156 1
mi_interpreter_exec (void *data, const char *command)
d158 1
a158 3
  char *tmp = alloca (strlen (command) + 1);
  strcpy (tmp, command);
  mi_execute_command_wrapper (tmp);
d164 1
a164 1
mi_interpreter_prompt_p (void *data)
d191 1
a191 1
  struct interp *interp_to_use;
d194 1
a194 1
  struct interp_procs *procs;
d203 1
a203 1
  interp_to_use = interp_lookup (argv[0]);
d212 2
a213 1
  if (!interp_exec_p (interp_to_use))
d249 1
a249 1
      if (interp_exec (interp_to_use, argv[i]) < 0)
d402 8
a409 8
  static const struct interp_procs procs =
  {
    mi_interpreter_init,	/* init_proc */
    mi_interpreter_resume,	/* resume_proc */
    mi_interpreter_suspend,	/* suspend_proc */
    mi_interpreter_exec,	/* exec_proc */
    mi_interpreter_prompt_p	/* prompt_proc_p */
  };
d412 24
a435 1
  interp_add (interp_new (INTERP_MI1, NULL, mi_out_new (1), &procs));
d437 12
a448 1
  interp_add (interp_new (INTERP_MI, NULL, mi_out_new (3), &procs));
@


1.1.4.4
log
@Overhaul changelog entries.
@
text
@d1 2
a2 3
/* MI Interpreter Definitions and Commands for GDB, the GNU debugger.

   Copyright 2002, 2003 Free Software Foundation, Inc.
d30 1
a30 1
#include "mi-main.h"
d101 1
@


1.1.2.1
log
@Add files mentioned in yesterday's changelog. Oops.
@
text
@a0 500
/* MI Interpreter Definitions and Commands
   Copyright 2002 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "interps.h"
#include "event-top.h"
#include "event-loop.h"
#include "inferior.h"
#include "ui-out.h"
#include "top.h"

#include "mi.h"
#include "mi-cmds.h"
#include "mi-out.h"
#include "mi-console.h"

/* MI's output channels */
struct ui_file *mi_stdout;
struct ui_file *mi_stderr;
struct ui_file *mi_stdlog;
struct ui_file *mi_stdtarg;

/* This is the interpreter for the mi... */
struct gdb_interpreter *mi0_interp;
struct gdb_interpreter *mi_interp;

/* These are the interpreter setup, etc. functions for the MI interpreter */
static int mi_interpreter_init (void *data);
static int mi_interpreter_resume (void *data);
static int mi_interpreter_do_one_event (void *data);
static int mi_interpreter_suspend (void *data);
static int mi_interpreter_delete (void *data);
static int mi_interpreter_prompt (void *data, char *new_prompt);

static void mi_execute_command_wrapper (char *cmd);
static void mi_command_loop (int mi_version);
static char *mi_input (char *);

/* These are hooks that we put in place while doing interpreter_exec
   so we can report interesting things that happened "behind the mi's
   back" in this command */
static int mi_interp_query_hook (const char *ctlstr, va_list ap);
static void mi_interp_stack_changed_hook (void);
static char *mi_interp_read_one_line_hook (char *prompt, int repeat,
					   char *anno);

static void mi0_command_loop (void);
static void mi1_command_loop (void);

static void mi_insert_notify_hooks (void);
static void mi_remove_notify_hooks (void);

int
mi_interpreter_init (void *data)
{
  /* Why is this a part of the mi architecture? */

  mi_setup_architecture_data ();

  /* HACK: We need to force stdout/stderr to point at the console.  This avoids
     any potential side effects caused by legacy code that is still
     using the TUI / fputs_unfiltered_hook.  So we set up output channels for
     this now, and swap them in when we are run. */

  raw_stdout = stdio_fileopen (stdout);
  /* Route normal output through the MIx */
  mi_stdout = mi_console_file_new (raw_stdout, "~");
  /* Route error and log output through the MI */
  mi_stderr = mi_console_file_new (raw_stdout, "&");
  mi_stdlog = mi_stderr;
  /* Route target output through the MI. */
  mi_stdtarg = mi_console_file_new (raw_stdout, "@@");

  return 1;
}

int
mi_interpreter_resume (void *data)
{
  /* As per hack note in mi_interpreter_init, swap in the output channels... */

  gdb_setup_readline ();
  mi_register_gdbarch_swap ();

  if (event_loop_p)
    {
      /* These overwrite some of the initialization done in
         _intialize_event_loop. */
      call_readline = gdb_readline2;
      input_handler = mi_execute_command_wrapper;
      add_file_handler (input_fd, stdin_event_handler, 0);
      async_command_editing_p = 0;
      /* FIXME: This is a total hack for now.  PB's use of the MI implicitly
         relies on a bug in the async support which allows asynchronous
         commands to leak through the commmand loop.  The bug involves
         (but is not limited to) the fact that sync_execution was
         erroneously initialized to 0.  Duplicate by initializing it
         thus here... */
      sync_execution = 0;
    }

  gdb_stdout = mi_stdout;
  /* Route error and log output through the MI */
  gdb_stderr = mi_stderr;
  gdb_stdlog = mi_stdlog;
  /* Route target output through the MI. */
  gdb_stdtarg = mi_stdtarg;

  /* Replace all the hooks that we know about.  There really needs to be a better way
     of doing this... */
  clear_interpreter_hooks ();

  show_load_progress = mi_load_progress;

  /* If we're _the_ interpreter, take control. */
  if (gdb_current_interpreter_is_named (GDB_INTERPRETER_MI0))
    command_loop_hook = mi0_command_loop;
  else if (gdb_current_interpreter_is_named (GDB_INTERPRETER_MI))
    command_loop_hook = mi1_command_loop;
  else
    return 0;

  return 1;
}

int
mi_interpreter_suspend (void *data)
{
  gdb_disable_readline ();
  return 1;
}

int
mi_interpreter_delete (void *data)
{
  return 1;
}

int
mi_interpreter_prompt (void *data, char *new_prompt)
{
  return 1;
}

int
mi_do_one_event (void *data)
{
  return 1;
}

void
mi_interpreter_exec_continuation (struct continuation_arg *arg)
{
  bpstat_do_actions (&stop_bpstat);
  if (!target_executing)
    {
      fputs_unfiltered ("*stopped", raw_stdout);
      mi_out_put (uiout, raw_stdout);
      fputs_unfiltered ("\n", raw_stdout);
      fputs_unfiltered ("(gdb) \n", raw_stdout);
      gdb_flush (raw_stdout);
      do_exec_cleanups (ALL_CLEANUPS);
    }
  else if (target_can_async_p ())
    {
      add_continuation (mi_interpreter_exec_continuation, NULL);
    }
}

enum mi_cmd_result
mi_cmd_interpreter_exec (char *command, char **argv, int argc)
{
  struct gdb_interpreter *old_interp, *interp_to_use;
  enum mi_cmd_result result = MI_CMD_DONE;
  int i, old_quiet;
  struct gdb_interpreter_procs *procs;

  if (argc < 2)
    {
      xasprintf (&mi_error_message,
		 "Wrong # or arguments, should be \"%s interp cmd <cmd ...>\".",
		 command);
      return MI_CMD_ERROR;
    }

  old_interp = gdb_current_interpreter ();

  interp_to_use = gdb_lookup_interpreter (argv[0]);
  if (interp_to_use == NULL)
    {
      xasprintf (&mi_error_message,
		 "Could not find interpreter \"%s\".", argv[0]);
      return MI_CMD_ERROR;
    }

  procs = gdb_interpreter_get_procs (interp_to_use);
  if (!procs->exec_proc)
    {
      xasprintf (&mi_error_message,
		 "Interpreter \"%s\" does not support command execution.",
		 argv[0]);
      return MI_CMD_ERROR;
    }
  old_quiet = gdb_interpreter_set_quiet (interp_to_use, 1);

  if (!gdb_set_interpreter (interp_to_use))
    {
      xasprintf (&mi_error_message,
		 "Could not switch to interpreter \"%s\".", argv[0]);
      return MI_CMD_ERROR;
    }

  /* Insert the MI out hooks, making sure to also call the interpreter's hooks
     if it has any. */

  mi_insert_notify_hooks ();

  /* Now run the code... */

  for (i = 1; i < argc; i++)
    {
      char *buff = NULL;
      /* Do this in a cleaner way...  We want to force execution to be
         asynchronous for commands that run the target.  */
      if (target_can_async_p () && (strcmp (argv[0], "console") == 0))
	{
	  int len = strlen (argv[i]);
	  buff = xmalloc (len + 2);
	  memcpy (buff, argv[i], len);
	  buff[len] = '&';
	  buff[len + 1] = '\0';
	}

      /* We had to set sync_execution = 0 for the mi (well really for Project
         Builder's use of the mi - particularly so interrupting would work.
         But for console commands to work, we need to initialize it to 1 -
         since that is what the cli expects - before running the command,
         and then set it back to 0 when we are done. */
      sync_execution = 1;
      if (!procs->exec_proc (gdb_interpreter_get_data (interp_to_use), argv[i]))
	{
	  xasprintf (&mi_error_message,
		     "mi_interpreter_execute: error in command: \"%s\".",
		     argv[i]);

	  result = MI_CMD_ERROR;
	  break;
	}
      xfree (buff);
      do_exec_error_cleanups (ALL_CLEANUPS);
      sync_execution = 0;

    }

  /* Now do the switch... */

  gdb_set_interpreter (old_interp);
  mi_remove_notify_hooks ();
  gdb_interpreter_set_quiet (interp_to_use, old_quiet);

  /* Okay, now let's see if the command set the inferior going...
     Tricky point - have to do this AFTER resetting the interpreter, since
     changing the interpreter will clear out all the continuations for
     that interpreter... */

  if (target_can_async_p () && target_executing)
    {
      fputs_unfiltered ("^running\n", raw_stdout);
      add_continuation (mi_interpreter_exec_continuation, NULL);
    }

  return result;
}

enum mi_cmd_result
mi_cmd_interpreter_set (char *command, char **argv, int argc)
{
  struct gdb_interpreter *interp;
  int result;

  if (argc != 1)
    {
      xasprintf (&mi_error_message,
		 "mi_cmd_interpreter_set: wrong #of args, should be 1 ");
      return MI_CMD_ERROR;
    }
  interp = gdb_lookup_interpreter (argv[0]);
  if (interp == NULL)
    {
      xasprintf (&mi_error_message,
		 "mi_cmd_interpreter_set: could not find interpreter %s",
		 argv[0]);
      return MI_CMD_ERROR;
    }

  if (interp != gdb_current_interpreter ())
    {
      result = gdb_set_interpreter (interp);
      if (result != 1)
	{
	  xasprintf (&mi_error_message,
		     "mi_cmd_interpreter_set: error setting interpreter %s",
		     argv[0]);
	  return MI_CMD_ERROR;
	}
    }

  /* We don't want to put up the "done" and whatnot here, since we
   * are going over to another interpreter.
   */
  return MI_CMD_QUIET;
}

/*
 * mi_insert_notify_hooks - This inserts a number of hooks that are meant to produce
 * async-notify ("=") MI messages while running commands in another interpreter
 * using mi_interpreter_exec.  The canonical use for this is to allow access to
 * the gdb CLI interpreter from within the MI, while still producing MI style output
 * when actions in the CLI command change gdb's state.
*/

static void
mi_insert_notify_hooks (void)
{

  create_breakpoint_hook = mi_interp_create_breakpoint_hook;
  delete_breakpoint_hook = mi_interp_delete_breakpoint_hook;
  modify_breakpoint_hook = mi_interp_modify_breakpoint_hook;
  selected_frame_level_changed_hook = mi_interp_frame_changed_hook;
  context_hook = mi_interp_context_hook;
  query_hook = mi_interp_query_hook;
}

static void
mi_remove_notify_hooks ()
{
  create_breakpoint_hook = NULL;
  delete_breakpoint_hook = NULL;
  modify_breakpoint_hook = NULL;
  selected_frame_level_changed_hook = NULL;
  context_hook = NULL;
  query_hook = NULL;
}

int
mi_interp_query_hook (const char *ctlstr, va_list ap)
{
  return 1;
}

char *
mi_interp_read_one_line_hook (char *prompt, int repeat, char *anno)
{
  static char buff[256];
  printf_unfiltered ("=read-one-line,prompt=\"%s\"\n", prompt);
  gdb_flush (gdb_stdout);
  (void) fgets (buff, sizeof (buff), stdin);
  buff[(strlen (buff) - 1)] = 0;
  return buff;
}

static void
output_control_change_notification (char *notification)
{
  printf_unfiltered ("^");
  printf_unfiltered ("%s\n", notification);
  gdb_flush (gdb_stdout);
}

static void
mi_execute_command_wrapper (char *cmd)
{
  mi_execute_command (cmd, stdin == instream);
}

static void
mi0_command_loop (void)
{
  mi_command_loop (0);
}

static void
mi1_command_loop (void)
{
  mi_command_loop (1);
}

static void
mi_command_loop (int mi_version)
{
  /* HACK: Force stdout/stderr to point at the console.  This avoids
     any potential side effects caused by legacy code that is still
     using the TUI / fputs_unfiltered_hook */
  raw_stdout = stdio_fileopen (stdout);
  /* Route normal output through the MIx */
  gdb_stdout = mi_console_file_new (raw_stdout, "~");
  /* Route error and log output through the MI */
  gdb_stderr = mi_console_file_new (raw_stdout, "&");
  gdb_stdlog = gdb_stderr;
  /* Route target output through the MI. */
  gdb_stdtarg = mi_console_file_new (raw_stdout, "@@");
  /* HACK: Poke the ui_out table directly.  Should we be creating a
     mi_out object wired up to the above gdb_stdout / gdb_stderr? */
  uiout = mi_out_new (mi_version);
  /* HACK: Override any other interpreter hooks.  We need to create a
     real event table and pass in that. */
  init_ui_hook = 0;
  /* command_loop_hook = 0; */
  print_frame_info_listing_hook = 0;
  query_hook = 0;
  warning_hook = 0;
  create_breakpoint_hook = 0;
  delete_breakpoint_hook = 0;
  modify_breakpoint_hook = 0;
  interactive_hook = 0;
  registers_changed_hook = 0;
  readline_begin_hook = 0;
  readline_hook = 0;
  readline_end_hook = 0;
  register_changed_hook = 0;
  memory_changed_hook = 0;
  context_hook = 0;
  target_wait_hook = 0;
  call_command_hook = 0;
  error_hook = 0;
  error_begin_hook = 0;
  show_load_progress = mi_load_progress;
  /* Turn off 8 bit strings in quoted output.  Any character with the
     high bit set is printed using C's octal format. */
  sevenbit_strings = 1;
  /* Tell the world that we're alive */
  fputs_unfiltered ("(gdb) \n", raw_stdout);
  gdb_flush (raw_stdout);
  if (!event_loop_p)
    simplified_command_loop (mi_input, mi_execute_command);
  else
    start_event_loop ();
}

static char *
mi_input (char *buf)
{
  return gdb_readline (NULL);
}

void
_initialize_mi_interp (void)
{
  struct gdb_interpreter_procs procs =
    {
      mi_interpreter_init,	/* init_proc */
      mi_interpreter_resume,	/* resume_proc */
      NULL,			/* do_one_event_proc */
      mi_interpreter_suspend,	/* suspend_proc */
      mi_interpreter_delete,	/* delete_proc */
      NULL,			/* exec_proc */
      mi_interpreter_prompt	/* prompt_proc */
    };

  if (mi0_interp == NULL)
    {
      mi0_interp =
	gdb_new_interpreter (GDB_INTERPRETER_MI0, NULL, mi_out_new (0),
			     &procs);
      if (mi0_interp == NULL)
	error
	  ("Couldn't allocate a new interpreter for the mi0 interpreter\n");
      if (gdb_add_interpreter (mi0_interp) != 1)
	error ("Couldn't add the mi0 interpreter to gdb.\n");
    }

  if (mi_interp == NULL)
    {
      mi_interp =
	gdb_new_interpreter (GDB_INTERPRETER_MI, NULL, mi_out_new (1),
			     &procs);
      if (mi_interp == NULL)
	error
	  ("Couldn't allocate a new interpreter for the mi interpreter\n");
      if (gdb_add_interpreter (mi_interp) != 1)
	error ("Couldn't add the mi interpreter to gdb.\n");
    }
}
@


1.1.2.2
log
@        * mi-cmd-break.c (breakpoint_notify): Only query the breakpoint
        for user breakpoints.
        (mi_cmd_break_insert): Only reset event handlers for MI0 and MI1
        interpreters.
        (mi_cmd_break_watch): Reset uiout output to clear watchpoint
        query. This is only used for MI0 and MI1.

        * mi-console.h (mi_console_file_new): Add "quote" parameter.
        * mi_console.c (struct mi_console_file): Add "quote".
        (mi_console_file_new): Add "quote" parameter.
        (mi_console_raw_packet): Use the quote character specified in
        mi_console_file_new, instead of assuming it is '"'.

        * mi-interp.c (mi_event_channel): New channel for event notifications.
        (mi_interpreter_init): Make static.
        Set event handlers.
        (mi_interpreter_resume): Make static.
        Deal with MI version bump.
        (mi_interpreter_suspend): Make static.
        (mi_interpreter_delete): Ditto.
        (mi_do_one_event): Ditto.
        (mi_cmd_exec_continuation): Ditto.
        (mi_interp_query_hook): Ditto.
        (mi_interp_read_one_line_hook): Ditto.
        (_initialize_mi_interp): Create explicit mi1 interp.

        * mi-events.c (notify_event): New helper function.
        (mi_create_breakpoint, mi_modify_breakpoint, mi_delete_breakpoint,
        mi_create_tracepoint, mi_modify_tracepoint, mi_delete_tracepoint,
        mi_architecture_changed): New functions.

        * mi.h: Add declarations for mi_create_breakpoint, mi_modify_breakpoint,
        mi_delete_breakpoint, mi_create_tracepoint, mi_modify_tracepoint,
        mi_delete_tracepoint, mi_architecture_changed, mi_stdout, mi_stderr,
        mi_stdtarg, mi_stdlog, and mi_eventchannel.

        * mi-main.c (captured_mi_execute_command): Deal with mi version
        bump.
        (mi_load_progress): Ditto.

        * gdbmi.texinfo: Expand notify-async-output to include GDB events.
        Update all examples to show breakpoint events and
        remove redundant breakpoint info on "-break-insert" and "-break-watch".
        The event now supplies everything that is needed.
@
text
@a38 1
struct ui_file *mi_event_channel;
a41 1
struct gdb_interpreter *mi1_interp;
d70 1
a70 1
static int
a72 2
  static struct gdb_events handlers;

d83 4
a86 4

  /* Create MI channels */
  mi_stdout = mi_console_file_new (raw_stdout, "~", '"');
  mi_stderr = mi_console_file_new (raw_stdout, "&", '"');
d88 2
a89 12
  mi_stdtarg = mi_console_file_new (raw_stdout, "@@", '"');
  mi_event_channel = mi_console_file_new (raw_stdout, "=", 0);

  /* Add global event handlers */
  handlers.breakpoint_create = mi_create_breakpoint;
  handlers.breakpoint_modify = mi_modify_breakpoint;
  handlers.breakpoint_delete = mi_delete_breakpoint;
  handlers.tracepoint_create = mi_create_tracepoint;
  handlers.tracepoint_modify = mi_modify_tracepoint;
  handlers.tracepoint_delete = mi_delete_tracepoint;
  handlers.architecture_changed = mi_architecture_changed;
  set_gdb_event_hooks (&handlers);
d94 1
a94 1
static int
a134 2
  else if (gdb_current_interpreter_is_named (GDB_INTERPRETER_MI1))
    command_loop_hook = mi1_command_loop;
d143 1
a143 1
static int
d150 1
a150 1
static int
d156 1
a156 1
static int
d162 1
a162 1
static int
d168 1
a168 1
static void
d232 1
a232 2
  /* KRS: We shouldn't need this... Events should be installed and they should
     just ALWAYS fire something out down the MI channel... */
d269 1
d362 1
a362 1
static int
d368 1
a368 1
static char *
d413 1
a413 1
  gdb_stdout = mi_console_file_new (raw_stdout, "~", '"');
d415 1
a415 1
  gdb_stderr = mi_console_file_new (raw_stdout, "&", '"');
d418 1
a418 1
  gdb_stdtarg = mi_console_file_new (raw_stdout, "@@", '"');
a476 1
  /* Create MI0 interpreter */
a488 14
  /* Create MI1 interpreter */
  if (mi1_interp == NULL)
    {
      mi1_interp =
	gdb_new_interpreter (GDB_INTERPRETER_MI1, NULL, mi_out_new (1),
			     &procs);
      if (mi1_interp == NULL)
	error
	  ("Couldn't allocate a new interpreter for the mi1 interpreter\n");
      if (gdb_add_interpreter (mi1_interp) != 1)
	error ("Couldn't add the mi1 interpreter to gdb.\n");
    }

  /* Create MI2 interpreter */
d492 1
a492 1
	gdb_new_interpreter (GDB_INTERPRETER_MI, NULL, mi_out_new (2),
@


1.1.2.3
log
@        * mi-cmds.h (mi_execute_command): Add "extern".
        (mi_error_last_message): New function.
        * mi-main.c (mi_error_last_message): New function.
        * mi-interp.c (mi_event_handlers): New static global.
        (mi_interpreter_init): Don't install mi event handlers here.
        (mi_interpreter_resume): Install mi event handlers here.
        (mi_interpreter_exec): Don't actually switch interpreters.
        Update error messages.
        exec_proc will return <0 if an error occurs.
@
text
@a71 11
static struct gdb_events mi_event_handlers =
  {
    mi_create_breakpoint,
    mi_delete_breakpoint,
    mi_modify_breakpoint,
    mi_create_tracepoint,
    mi_delete_tracepoint,
    mi_modify_tracepoint,
    mi_architecture_changed
  };

d95 10
a142 1
  set_gdb_event_hooks (&mi_event_handlers);
d206 1
a206 1
  struct gdb_interpreter *interp_to_use;
d208 1
a208 1
  int i;
d214 2
a215 1
		 "mi_cmd_interpreter_exec: Usage: -interpreter-exec interp command");
d219 2
d225 1
a225 2
		 "mi_cmd_interpreter_exec: could not find interpreter \"%s\"",
		 argv[0]);
d233 1
a233 1
		 "mi_cmd_interpreter_exec: interpreter \"%s\" does not support command execution",
d237 8
d274 1
a274 1
      if (procs->exec_proc (gdb_interpreter_get_data (interp_to_use), argv[i]) < 0)
d276 4
a279 1
	  mi_error_last_message ();
d288 3
d292 1
@


1.1.2.4
log
@        * mi-events.c (mi_register_update): New function.
        * mi-interp.c (mi_event_handlers): Add mi_register_update
        event handler.
        * mi.h (mi_register_update): Add declaration.
@
text
@d80 1
a80 2
    mi_architecture_changed,
    mi_register_update
@


1.1.2.5
log
@        * mi-interp.c (mi_event_handlers): Add selected_frame_level_changed
        handler.
        (mi_insert_notify_hooks): Remove breakpoint hooks and frame
        changed hook.
        (mi_remove_notify_hooks): Likewise.
        * mi-events.c (mi_selected_frame_level_changed): New function.
        (mi_interp_frame_changed_hook): Remove.
        (mi_interp_create_breakpoint_hook): Remove.
        (mi_interp_modify_breakpoint_hook): Remove.
        (mi_interp_delete_breakpoint_hook): Remove.
        * mi.h (mi_selected_frame_level_changed): Add declaration.
        (mi_interp_create_breakpoint_hook): Remove declaration.
        (mi_interp_modify_breakpoint_hook): Remove declaration.
        (mi_interp_delete_breakpoint_hook): Remove declaration.
        * mi-cmd-stack.c (mi_cmd_stack_select_frame): If the stack level changes,
        issue a selected_frame_level_changed event.
@
text
@d62 1
d81 1
a81 2
    mi_register_update,
    mi_selected_frame_level_changed
d344 5
d356 4
@


1.1.2.6
log
@        * mi-interp.c (mi_event_handlers): Add context_changed event
        handler.
        (mi_command_loop): Remove big block of code repeated in
        mi_interpreter_resume. I don't think this is needed.
        (mi_insert_notify_hooks): Remove context_hook.
        (mi_remove_notify_hooks): Likewise.
        * mi-events.c (mi_context_changed): New function.
        * mi.h (mi_context_changed): Add declaration.
@
text
@d81 1
a81 2
    mi_selected_frame_level_changed,
    mi_context_changed
d344 1
d351 1
a400 1
#if 0
a437 1
#endif
@


1.1.2.7
log
@        * mi-interp.c (mi_cmd_interpreter_set): Remove. We're not going
        to allow this.
        * mi-cmds.c: Remove "interpreter-set" command.
        * mi-cmds.h (mi_cmd_interpreter_set): Remove.
@
text
@d295 39
@


1.1.2.8
log
@        * mi-events.c (mi_target_changed): Renamed from mi_register_update.
        * mi.h (mi_target_changed): Ditto.
        * mi-interp.c (mi_event_handlers): Ditto.
@
text
@d80 1
a80 1
    mi_target_changed,
@


1.1.2.9
log
@        * mi-interp.c (_initialize_mi_interp): Add exec_proc.
        (mi_interpreter_exec): New function. MI's exec_proc.
@
text
@a51 1
static int mi_interpreter_exec (void *data, char *command);
a176 7
mi_interpreter_exec (void *data, char *command)
{
  mi_execute_command_wrapper (command);
  return 1;
}

static int
d428 1
a428 1
      mi_interpreter_exec,	/* exec_proc */
@


1.1.2.10
log
@2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* interps.h (GDB_INTERPRETER_MI2): Define.
	(GDB_INTERPRETER_MI0): Remove.

2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-interp.c: Increment mi version numbers: 0->1, 1->2,
	and 2->3. Remove MI0 references.
	* mi-events.c: Ditto.
	* mi-main.c: Ditto. Remove erroneously merged code.
	* mi.h: Ditto.
@
text
@d42 1
a42 1
struct gdb_interpreter *mi2_interp;
d66 1
a66 1
static void mi2_command_loop (void);
d152 2
a153 2
  if (gdb_current_interpreter_is_named (GDB_INTERPRETER_MI2))
    command_loop_hook = mi2_command_loop;
d157 1
a157 1
    command_loop_hook = mi2_command_loop;
d355 1
a355 1
mi1_command_loop (void)
d357 1
a357 1
  mi_command_loop (1);
d361 1
a361 1
mi2_command_loop (void)
d363 1
a363 1
  mi_command_loop (2);
d440 13
a466 13
  if (mi2_interp == NULL)
    {
      mi2_interp =
	gdb_new_interpreter (GDB_INTERPRETER_MI2, NULL, mi_out_new (2),
			     &procs);
      if (mi2_interp == NULL)
	error
	  ("Couldn't allocate a new interpreter for the mi2 interpreter\n");
      if (gdb_add_interpreter (mi2_interp) != 1)
	error ("Couldn't add the mi2 interpreter to gdb.\n");
    }

  /* Create MI3 interpreter */
d470 1
a470 1
	gdb_new_interpreter (GDB_INTERPRETER_MI, NULL, mi_out_new (3),
@


1.1.2.11
log
@2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* interps.h (struct gdb_interpreter_procs): Remove do_one_event_proc.
	(interp_do_one_event_ftype): Delete.
	* interps.c (gdb_new_interpreter): Remove setup of do_one_event
	procedure.
	(interpreter_do_one_event): Delete.
	* event-loop.c (start_event_loop): Remove no-op call to
	interpreter_do_one_event.
	* cli/cli-interps.c: (cli_interpreter_do_one_event): Delete.

2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-interp.c (mi_interpreter_do_one_event): Remove.
@
text
@d49 1
d190 6
d433 1
@


1.1.2.12
log
@2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* cli/cli-interp.c (cli_interpreter_delete): Delete.
	(_initialize_cli_interp): Remove delete_proc.

	* interps.h (struct gdb_interpreter_procs): Remove delete_proc.
	(interp_delete_ftype): Delete.
	(gdb_delete_interpreter): Remove.

	* interps.c (gdb_delete_interpreter): Remove.
	(gdb_new_interpreter): Don't initialize delete_proc.

2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-interp.c mi_interpreter_delete): Remove.
	(_initialize_mi_interp): Remove mi_interpreter_delete.
@
text
@d50 1
d171 6
d427 1
@


1.1.2.13
log
@2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* event-top.c (display_gdb_prompt): Use
	gdb_interpreter_display_prompt_p.
	* cli/cli-interp.c (cli_interpreter_display_prompt_p): Rename from
	cli_interpreter_display_prompt and rewrite.
	(_initialize_cli_interp): New proc name is
	cli_interpreter_display_prompt_p.
	* interps.c (gdb_new_interpreter): Initialize prompt_proc_p
	instead of prompt_proc.
	(gdb_interpreter_display_prompt_p): Rewrite as a predicate.
	* interps.h (interp_prompt_ftype): Update typedef.
	(struct gdb_interpreter_procs): Rename prompt_proc to
	prompt_proc_p.
	(gdb_interpreter_display_prompt_p): Export this instead of old
	function.

2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-interp.c (_initialize_mi_interp): Use mi_interpreter_prompt_p
	instead of mi_interpreter_prompt.
	(mi_interpreter_prompt_p): Rename from mi_interpreter_prompt and
	rewrite.
@
text
@d51 1
a51 1
static int mi_interpreter_prompt_p (void);
a175 1
/* Never display the default gdb prompt in mi case.  */
d177 1
a177 1
mi_interpreter_prompt_p (void)
d179 1
a179 1
  return 0;
d421 1
a421 1
      mi_interpreter_prompt_p	/* prompt_proc_p */
@


1.1.2.14
log
@2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* cli/cli-interp.c (_initialize_cli_interp): Call
	gdb_interpreter_new and gdb_interpreter_add.
	* top.c (gdb_init): Call gdb_interpreter_lookup.
	(gdb_init): Call gdb_interpreter_set.
	* interps.c (gdb_interpreter_new): Renamed from
	gdb_new_interpreter.
	(gdb_interpreter_add): Renamed from gdb_add_interpreter.
	(gdb_interpreter_set): Renamed from gdb_set_interpreter.
	(gdb_interpreter_lookup): Renamed from gdb_lookup_interpreter.
	(gdb_interpreter_current): Renamed from gdb_current_interpreter.
	Update all callers.
	* interps.h: Ditto.

2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-interp.c (mi_interpreter_resume): Ditto.
	(mi_cmd_interpreter_exec): Use gdb_interpreter_lookup.
	(_initialize_mi_interp): Use gdb_interpreter_new,
	gdb_interpreter_add.
	* mi-cmd-break.c (mi_cmd_break_insert): Use
	gdb_interpreter_current_is_named_p.
	(mi_cmd_break_watch): Ditto.
	* mi-events.c (mi_interp_stack_changed_hook): Ditto.
	(event_notify): Ditto.
	* mi-main.c (captured_mi_execute_command): Use
	gdb_interpreter_current_is_named_p.
	(mi_load_progress): Ditto.
@
text
@d142 2
a143 2
  /* Replace all the hooks that we know about.  There really needs to
     be a better way of doing this... */
d150 1
a150 1
  if (gdb_interpreter_current_is_named_p (GDB_INTERPRETER_MI2))
d152 1
a152 1
  else if (gdb_interpreter_current_is_named_p (GDB_INTERPRETER_MI1))
d154 1
a154 1
  else if (gdb_interpreter_current_is_named_p (GDB_INTERPRETER_MI))
d217 1
a217 1
  interp_to_use = gdb_interpreter_lookup (argv[0]);
d429 1
a429 1
	gdb_interpreter_new (GDB_INTERPRETER_MI1, NULL, mi_out_new (1),
d434 1
a434 1
      if (gdb_interpreter_add (mi1_interp) != 1)
d442 1
a442 1
	gdb_interpreter_new (GDB_INTERPRETER_MI2, NULL, mi_out_new (2),
d447 1
a447 1
      if (gdb_interpreter_add (mi2_interp) != 1)
d455 1
a455 1
	gdb_interpreter_new (GDB_INTERPRETER_MI, NULL, mi_out_new (3),
d460 1
a460 1
      if (gdb_interpreter_add (mi_interp) != 1)
@


1.1.2.15
log
@2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* interps.h (clear_interpreter_hooks): Add 'extern' keyword.

2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* mi.h: Clean up interface, removing unnecessarily exported
	functions and data structures.
	* mi-events.c (mi_event_handlers): Move here...
	* mi-interps.c: .. from here.
	Include gdb_string.h.
@
text
@a21 1
#include "gdb_string.h"
d69 14
@


