head	1.18;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.18
	gdb_7_6-2013-04-26-release:1.18
	gdb_7_6-branch:1.18.0.2
	gdb_7_6-2013-03-12-branchpoint:1.18
	gdb_7_5_1-2012-11-29-release:1.16
	gdb_7_5-2012-08-17-release:1.16
	gdb_7_5-branch:1.16.0.2
	gdb_7_5-2012-07-18-branchpoint:1.16
	gdb_7_4_1-2012-04-26-release:1.15.2.1
	gdb_7_4-2012-01-24-release:1.15.2.1
	gdb_7_4-branch:1.15.0.2
	gdb_7_4-2011-12-13-branchpoint:1.15
	gdb_7_3_1-2011-09-04-release:1.14
	gdb_7_3-2011-07-26-release:1.14
	gdb_7_3-branch:1.14.0.2
	gdb_7_3-2011-04-01-branchpoint:1.14
	gdb_7_2-2010-09-02-release:1.11
	gdb_7_2-branch:1.11.0.2
	gdb_7_2-2010-07-07-branchpoint:1.11
	gdb_7_1-2010-03-18-release:1.10
	gdb_7_1-branch:1.10.0.2
	gdb_7_1-2010-02-18-branchpoint:1.10
	gdb_7_0_1-2009-12-22-release:1.9
	gdb_7_0-2009-10-06-release:1.9
	gdb_7_0-branch:1.9.0.4
	gdb_7_0-2009-09-16-branchpoint:1.9
	arc-sim-20090309:1.7
	msnyder-checkpoint-072509-branch:1.9.0.2
	msnyder-checkpoint-072509-branchpoint:1.9
	arc-insight_6_8-branch:1.7.0.16
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.14
	insight_6_8-branchpoint:1.7
	reverse-20081226-branch:1.7.0.12
	reverse-20081226-branchpoint:1.7
	multiprocess-20081120-branch:1.7.0.10
	multiprocess-20081120-branchpoint:1.7
	reverse-20080930-branch:1.7.0.8
	reverse-20080930-branchpoint:1.7
	reverse-20080717-branch:1.7.0.6
	reverse-20080717-branchpoint:1.7
	msnyder-reverse-20080609-branch:1.7.0.4
	msnyder-reverse-20080609-branchpoint:1.7
	drow-reverse-20070409-branch:1.4.0.2
	drow-reverse-20070409-branchpoint:1.4
	gdb_6_8-2008-03-27-release:1.7
	gdb_6_8-branch:1.7.0.2
	gdb_6_8-2008-02-26-branchpoint:1.7
	gdb_6_7_1-2007-10-29-release:1.6
	gdb_6_7-2007-10-10-release:1.6
	gdb_6_7-branch:1.6.0.2
	gdb_6_7-2007-09-07-branchpoint:1.6
	insight_6_6-20070208-release:1.2
	gdb_6_6-2006-12-18-release:1.2
	gdb_6_6-branch:1.2.0.12
	gdb_6_6-2006-11-15-branchpoint:1.2
	insight_6_5-20061003-release:1.2
	gdb-csl-symbian-6_4_50_20060226-12:1.1.2.1
	nickrob-async-20060828-mergepoint:1.2
	gdb-csl-symbian-6_4_50_20060226-11:1.1.2.1
	gdb-csl-sourcerygxx-4_1-17:1.1.2.1
	gdb-csl-20060226-branch-local-2:1.1.2.1
	gdb-csl-sourcerygxx-4_1-14:1.1.2.1
	gdb-csl-sourcerygxx-4_1-13:1.1.2.1
	gdb-csl-sourcerygxx-4_1-12:1.1.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.1.2.1
	gdb_6_5-20060621-release:1.2
	gdb-csl-sourcerygxx-4_1-9:1.1.2.1
	gdb-csl-sourcerygxx-4_1-8:1.1.2.1
	gdb-csl-sourcerygxx-4_1-7:1.1.2.1
	gdb-csl-arm-2006q1-6:1.1.2.1
	gdb-csl-sourcerygxx-4_1-6:1.1.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.1.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.1.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.1.2.1
	gdb-csl-coldfire-4_1-11:1.1.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.1.2.1
	gdb-csl-coldfire-4_1-10:1.1.2.1
	gdb_6_5-branch:1.2.0.10
	gdb_6_5-2006-05-14-branchpoint:1.2
	gdb-csl-sourcerygxx-4_1-5:1.1.2.1
	nickrob-async-20060513-branch:1.2.0.8
	nickrob-async-20060513-branchpoint:1.2
	gdb-csl-sourcerygxx-4_1-4:1.1.2.1
	msnyder-reverse-20060502-branch:1.2.0.6
	msnyder-reverse-20060502-branchpoint:1.2
	gdb-csl-morpho-4_1-4:1.1.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.1.2.1
	readline_5_1-import-branch:1.2.0.4
	readline_5_1-import-branchpoint:1.2
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.1.2.1
	gdb-csl-symbian-20060226-branch:1.1.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.1.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.1.2.1
	msnyder-reverse-20060331-branch:1.2.0.2
	msnyder-reverse-20060331-branchpoint:1.2
	gdb-csl-20060226-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.18
date	2013.02.12.19.03.54;	author palves;	state Exp;
branches;
next	1.17;

1.17
date	2013.01.01.06.32.49;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2012.01.04.08.17.09;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2011.07.05.04.34.56;	author bauermann;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2011.01.10.20.38.50;	author msnyder;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.01.15.33.13;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2010.08.18.19.13.33;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.16.01.27.02;	author msnyder;	state Exp;
branches;
next	1.10;

1.10
date	2010.01.01.07.31.38;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.17.18.39.13;	author uweigand;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.13.17.59.50;	author uweigand;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.09.17.58.56;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.18.23.57.08;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.28.19.19.16;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.21.02.13.35;	author pbrook;	state dead;
branches
	1.1.2.1;
next	;

1.15.2.1
date	2012.01.06.04.43.26;	author brobecke;	state Exp;
branches;
next	;

1.1.2.1
date	2006.03.21.02.13.35;	author pbrook;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Consistent use of (C) after "Copyright".

While writing the previous patch, I noticed that we're not consistent
with the (C) in the copyright header.  The maintainers manual prefers
having it, though also says it's optional.  We have over 10x more
files with (C) than without in gdb's code, so I spent a few minutes
grepping and fixing.  Funny enough, the testsuite has it backwards.
I'll leave that for another time.

gdb/
2013-02-12  Pedro Alves  <palves@@redhat.com>

	* amd64-darwin-tdep.c: Add (C) after Copyright.
	* cli/cli-cmds.h: Ditto.
	* cli/cli-decode.c: Ditto.
	* cli/cli-decode.h: Ditto.
	* cli/cli-dump.c: Ditto.
	* cli/cli-dump.h: Ditto.
	* cli/cli-interp.c: Ditto.
	* cli/cli-logging.c: Ditto.
	* cli/cli-script.c: Ditto.
	* cli/cli-script.h: Ditto.
	* cli/cli-setshow.c: Ditto.
	* cli/cli-setshow.h: Ditto.
	* cli/cli-utils.c: Ditto.
	* cli/cli-utils.h: Ditto.
	* config/alpha/nm-osf3.h: Ditto.
	* config/djgpp/djconfig.sh: Ditto.
	* config/i386/nm-fbsd.h: Ditto.
	* config/i386/nm-i386gnu.h: Ditto.
	* config/nm-linux.h: Ditto.
	* config/nm-nto.h: Ditto.
	* config/rs6000/nm-rs6000.h: Ditto.
	* config/sparc/nm-sol2.h: Ditto.
	* darwin-nat-info.c: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* gdb-demangle.h: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386-darwin-tdep.c: Ditto.
	* linux-fork.h: Ditto.
	* m32c-tdep.c: Ditto.
	* microblaze-linux-tdep.c: Ditto.
	* microblaze-rom.c: Ditto.
	* microblaze-tdep.c: Ditto.
	* microblaze-tdep.h: Ditto.
	* mips-linux-tdep.h: Ditto.
	* ppc-ravenscar-thread.c: Ditto.
	* ppc-ravenscar-thread.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* sparc-ravenscar-thread.c: Ditto.
	* sparc-ravenscar-thread.h: Ditto.
	* tilegx-linux-tdep.c: Ditto.
	* unwind_stop_reasons.def: Ditto.
	* windows-nat.h: Ditto.
	* xtensa-linux-tdep.c: Ditto.
	* xtensa-xtregs.c: Ditto.
	* regformats/regdat.sh: Ditto.
	* regformats/regdef.h: Ditto.

gdb/gdbserver/
2013-02-12  Pedro Alves  <palves@@redhat.com>

	* linux-xtensa-low.c: Ditto.
	* xtensa-xtregs.c: Ditto.
@
text
@/* Prologue value handling for GDB.
   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdb_string.h"
#include "gdb_assert.h"
#include "prologue-value.h"
#include "regcache.h"


/* Constructors.  */

pv_t
pv_unknown (void)
{
  pv_t v = { pvk_unknown, 0, 0 };

  return v;
}


pv_t
pv_constant (CORE_ADDR k)
{
  pv_t v;

  v.kind = pvk_constant;
  v.reg = -1;                   /* for debugging */
  v.k = k;

  return v;
}


pv_t
pv_register (int reg, CORE_ADDR k)
{
  pv_t v;

  v.kind = pvk_register;
  v.reg = reg;
  v.k = k;

  return v;
}



/* Arithmetic operations.  */

/* If one of *A and *B is a constant, and the other isn't, swap the
   values as necessary to ensure that *B is the constant.  This can
   reduce the number of cases we need to analyze in the functions
   below.  */
static void
constant_last (pv_t *a, pv_t *b)
{
  if (a->kind == pvk_constant
      && b->kind != pvk_constant)
    {
      pv_t temp = *a;
      *a = *b;
      *b = temp;
    }
}


pv_t
pv_add (pv_t a, pv_t b)
{
  constant_last (&a, &b);

  /* We can add a constant to a register.  */
  if (a.kind == pvk_register
      && b.kind == pvk_constant)
    return pv_register (a.reg, a.k + b.k);

  /* We can add a constant to another constant.  */
  else if (a.kind == pvk_constant
           && b.kind == pvk_constant)
    return pv_constant (a.k + b.k);

  /* Anything else we don't know how to add.  We don't have a
     representation for, say, the sum of two registers, or a multiple
     of a register's value (adding a register to itself).  */
  else
    return pv_unknown ();
}


pv_t
pv_add_constant (pv_t v, CORE_ADDR k)
{
  /* Rather than thinking of all the cases we can and can't handle,
     we'll just let pv_add take care of that for us.  */
  return pv_add (v, pv_constant (k));
}


pv_t
pv_subtract (pv_t a, pv_t b)
{
  /* This isn't quite the same as negating B and adding it to A, since
     we don't have a representation for the negation of anything but a
     constant.  For example, we can't negate { pvk_register, R1, 10 },
     but we do know that { pvk_register, R1, 10 } minus { pvk_register,
     R1, 5 } is { pvk_constant, <ignored>, 5 }.

     This means, for example, that we could subtract two stack
     addresses; they're both relative to the original SP.  Since the
     frame pointer is set based on the SP, its value will be the
     original SP plus some constant (probably zero), so we can use its
     value just fine, too.  */

  constant_last (&a, &b);

  /* We can subtract two constants.  */
  if (a.kind == pvk_constant
      && b.kind == pvk_constant)
    return pv_constant (a.k - b.k);

  /* We can subtract a constant from a register.  */
  else if (a.kind == pvk_register
           && b.kind == pvk_constant)
    return pv_register (a.reg, a.k - b.k);

  /* We can subtract a register from itself, yielding a constant.  */
  else if (a.kind == pvk_register
           && b.kind == pvk_register
           && a.reg == b.reg)
    return pv_constant (a.k - b.k);

  /* We don't know how to subtract anything else.  */
  else
    return pv_unknown ();
}


pv_t
pv_logical_and (pv_t a, pv_t b)
{
  constant_last (&a, &b);

  /* We can 'and' two constants.  */
  if (a.kind == pvk_constant
      && b.kind == pvk_constant)
    return pv_constant (a.k & b.k);

  /* We can 'and' anything with the constant zero.  */
  else if (b.kind == pvk_constant
           && b.k == 0)
    return pv_constant (0);

  /* We can 'and' anything with ~0.  */
  else if (b.kind == pvk_constant
           && b.k == ~ (CORE_ADDR) 0)
    return a;

  /* We can 'and' a register with itself.  */
  else if (a.kind == pvk_register
           && b.kind == pvk_register
           && a.reg == b.reg
           && a.k == b.k)
    return a;

  /* Otherwise, we don't know.  */
  else
    return pv_unknown ();
}



/* Examining prologue values.  */

int
pv_is_identical (pv_t a, pv_t b)
{
  if (a.kind != b.kind)
    return 0;

  switch (a.kind)
    {
    case pvk_unknown:
      return 1;
    case pvk_constant:
      return (a.k == b.k);
    case pvk_register:
      return (a.reg == b.reg && a.k == b.k);
    default:
      gdb_assert_not_reached ("unexpected prologue value kind");
    }
}


int
pv_is_constant (pv_t a)
{
  return (a.kind == pvk_constant);
}


int
pv_is_register (pv_t a, int r)
{
  return (a.kind == pvk_register
          && a.reg == r);
}


int
pv_is_register_k (pv_t a, int r, CORE_ADDR k)
{
  return (a.kind == pvk_register
          && a.reg == r
          && a.k == k);
}


enum pv_boolean
pv_is_array_ref (pv_t addr, CORE_ADDR size,
                 pv_t array_addr, CORE_ADDR array_len,
                 CORE_ADDR elt_size,
                 int *i)
{
  /* Note that, since .k is a CORE_ADDR, and CORE_ADDR is unsigned, if
     addr is *before* the start of the array, then this isn't going to
     be negative...  */
  pv_t offset = pv_subtract (addr, array_addr);

  if (offset.kind == pvk_constant)
    {
      /* This is a rather odd test.  We want to know if the SIZE bytes
         at ADDR don't overlap the array at all, so you'd expect it to
         be an || expression: "if we're completely before || we're
         completely after".  But with unsigned arithmetic, things are
         different: since it's a number circle, not a number line, the
         right values for offset.k are actually one contiguous range.  */
      if (offset.k <= -size
          && offset.k >= array_len * elt_size)
        return pv_definite_no;
      else if (offset.k % elt_size != 0
               || size != elt_size)
        return pv_maybe;
      else
        {
          *i = offset.k / elt_size;
          return pv_definite_yes;
        }
    }
  else
    return pv_maybe;
}



/* Areas.  */


/* A particular value known to be stored in an area.

   Entries form a ring, sorted by unsigned offset from the area's base
   register's value.  Since entries can straddle the wrap-around point,
   unsigned offsets form a circle, not a number line, so the list
   itself is structured the same way --- there is no inherent head.
   The entry with the lowest offset simply follows the entry with the
   highest offset.  Entries may abut, but never overlap.  The area's
   'entry' pointer points to an arbitrary node in the ring.  */
struct area_entry
{
  /* Links in the doubly-linked ring.  */
  struct area_entry *prev, *next;

  /* Offset of this entry's address from the value of the base
     register.  */
  CORE_ADDR offset;

  /* The size of this entry.  Note that an entry may wrap around from
     the end of the address space to the beginning.  */
  CORE_ADDR size;

  /* The value stored here.  */
  pv_t value;
};


struct pv_area
{
  /* This area's base register.  */
  int base_reg;

  /* The mask to apply to addresses, to make the wrap-around happen at
     the right place.  */
  CORE_ADDR addr_mask;

  /* An element of the doubly-linked ring of entries, or zero if we
     have none.  */
  struct area_entry *entry;
};


struct pv_area *
make_pv_area (int base_reg, int addr_bit)
{
  struct pv_area *a = (struct pv_area *) xmalloc (sizeof (*a));

  memset (a, 0, sizeof (*a));

  a->base_reg = base_reg;
  a->entry = 0;

  /* Remember that shift amounts equal to the type's width are
     undefined.  */
  a->addr_mask = ((((CORE_ADDR) 1 << (addr_bit - 1)) - 1) << 1) | 1;

  return a;
}


/* Delete all entries from AREA.  */
static void
clear_entries (struct pv_area *area)
{
  struct area_entry *e = area->entry;

  if (e)
    {
      /* This needs to be a do-while loop, in order to actually
         process the node being checked for in the terminating
         condition.  */
      do
        {
          struct area_entry *next = e->next;

          xfree (e);
          e = next;
        }
      while (e != area->entry);

      area->entry = 0;
    }
}


void
free_pv_area (struct pv_area *area)
{
  clear_entries (area);
  xfree (area);
}


static void
do_free_pv_area_cleanup (void *arg)
{
  free_pv_area ((struct pv_area *) arg);
}


struct cleanup *
make_cleanup_free_pv_area (struct pv_area *area)
{
  return make_cleanup (do_free_pv_area_cleanup, (void *) area);
}


int
pv_area_store_would_trash (struct pv_area *area, pv_t addr)
{
  /* It may seem odd that pvk_constant appears here --- after all,
     that's the case where we know the most about the address!  But
     pv_areas are always relative to a register, and we don't know the
     value of the register, so we can't compare entry addresses to
     constants.  */
  return (addr.kind == pvk_unknown
          || addr.kind == pvk_constant
          || (addr.kind == pvk_register && addr.reg != area->base_reg));
}


/* Return a pointer to the first entry we hit in AREA starting at
   OFFSET and going forward.

   This may return zero, if AREA has no entries.

   And since the entries are a ring, this may return an entry that
   entirely precedes OFFSET.  This is the correct behavior: depending
   on the sizes involved, we could still overlap such an area, with
   wrap-around.  */
static struct area_entry *
find_entry (struct pv_area *area, CORE_ADDR offset)
{
  struct area_entry *e = area->entry;

  if (! e)
    return 0;

  /* If the next entry would be better than the current one, then scan
     forward.  Since we use '<' in this loop, it always terminates.

     Note that, even setting aside the addr_mask stuff, we must not
     simplify this, in high school algebra fashion, to
     (e->next->offset < e->offset), because of the way < interacts
     with wrap-around.  We have to subtract offset from both sides to
     make sure both things we're comparing are on the same side of the
     discontinuity.  */
  while (((e->next->offset - offset) & area->addr_mask)
         < ((e->offset - offset) & area->addr_mask))
    e = e->next;

  /* If the previous entry would be better than the current one, then
     scan backwards.  */
  while (((e->prev->offset - offset) & area->addr_mask)
         < ((e->offset - offset) & area->addr_mask))
    e = e->prev;

  /* In case there's some locality to the searches, set the area's
     pointer to the entry we've found.  */
  area->entry = e;

  return e;
}


/* Return non-zero if the SIZE bytes at OFFSET would overlap ENTRY;
   return zero otherwise.  AREA is the area to which ENTRY belongs.  */
static int
overlaps (struct pv_area *area,
          struct area_entry *entry,
          CORE_ADDR offset,
          CORE_ADDR size)
{
  /* Think carefully about wrap-around before simplifying this.  */
  return (((entry->offset - offset) & area->addr_mask) < size
          || ((offset - entry->offset) & area->addr_mask) < entry->size);
}


void
pv_area_store (struct pv_area *area,
               pv_t addr,
               CORE_ADDR size,
               pv_t value)
{
  /* Remove any (potentially) overlapping entries.  */
  if (pv_area_store_would_trash (area, addr))
    clear_entries (area);
  else
    {
      CORE_ADDR offset = addr.k;
      struct area_entry *e = find_entry (area, offset);

      /* Delete all entries that we would overlap.  */
      while (e && overlaps (area, e, offset, size))
        {
          struct area_entry *next = (e->next == e) ? 0 : e->next;

          e->prev->next = e->next;
          e->next->prev = e->prev;

          xfree (e);
          e = next;
        }

      /* Move the area's pointer to the next remaining entry.  This
         will also zero the pointer if we've deleted all the entries.  */
      area->entry = e;
    }

  /* Now, there are no entries overlapping us, and area->entry is
     either zero or pointing at the closest entry after us.  We can
     just insert ourselves before that.

     But if we're storing an unknown value, don't bother --- that's
     the default.  */
  if (value.kind == pvk_unknown)
    return;
  else
    {
      CORE_ADDR offset = addr.k;
      struct area_entry *e = (struct area_entry *) xmalloc (sizeof (*e));

      e->offset = offset;
      e->size = size;
      e->value = value;

      if (area->entry)
        {
          e->prev = area->entry->prev;
          e->next = area->entry;
          e->prev->next = e->next->prev = e;
        }
      else
        {
          e->prev = e->next = e;
          area->entry = e;
        }
    }
}


pv_t
pv_area_fetch (struct pv_area *area, pv_t addr, CORE_ADDR size)
{
  /* If we have no entries, or we can't decide how ADDR relates to the
     entries we do have, then the value is unknown.  */
  if (! area->entry
      || pv_area_store_would_trash (area, addr))
    return pv_unknown ();
  else
    {
      CORE_ADDR offset = addr.k;
      struct area_entry *e = find_entry (area, offset);

      /* If this entry exactly matches what we're looking for, then
         we're set.  Otherwise, say it's unknown.  */
      if (e->offset == offset && e->size == size)
        return e->value;
      else
        return pv_unknown ();
    }
}


int
pv_area_find_reg (struct pv_area *area,
                  struct gdbarch *gdbarch,
                  int reg,
                  CORE_ADDR *offset_p)
{
  struct area_entry *e = area->entry;

  if (e)
    do
      {
        if (e->value.kind == pvk_register
            && e->value.reg == reg
            && e->value.k == 0
            && e->size == register_size (gdbarch, reg))
          {
            if (offset_p)
              *offset_p = e->offset;
            return 1;
          }

        e = e->next;
      }
    while (e != area->entry);

  return 0;
}


void
pv_area_scan (struct pv_area *area,
              void (*func) (void *closure,
                            pv_t addr,
                            CORE_ADDR size,
                            pv_t value),
              void *closure)
{
  struct area_entry *e = area->entry;
  pv_t addr;

  addr.kind = pvk_register;
  addr.reg = area->base_reg;

  if (e)
    do
      {
        addr.k = e->offset;
        func (closure, addr, e->size, e->value);
        e = e->next;
      }
    while (e != area->entry);
}
@


1.17
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d2 1
a2 1
   Copyright 2003-2013 Free Software Foundation, Inc.
@


1.16
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
   Copyright 2003-2005, 2007-2012 Free Software Foundation, Inc.
@


1.15
log
@gdb/
	* ada-lang.c: Fix typos.
	* amd64-tdep.c: Likewise.
	* breakpoint.c: Likewise.
	* cli/cli-decode.c: Likewise.
	* findcmd.c: Likewise.
	* inline-frame.c: Likewise.
	* mi/mi-main.c: Likewise.
	* minsyms.c: Likewise.
	* monitor.c: Likewise.
	* monitor.h: Likewise.
	* prologue-value.c: Likewise.
	* reverse.c: Likewise.
	* s390-tdep.c: Likewise.

gdb/testsuite/
	* gdb.base/call-sc.c: Likewise.
	* gdb.base/ifelse.exp: Likewise.
	* gdb.base/structs.c: Likewise.

gdb/doc/
	* gdb.texinfo: Likewise.
@
text
@d2 1
a2 2
   Copyright 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.15.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright 2003-2005, 2007-2012 Free Software Foundation, Inc.
@


1.14
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d402 1
a402 1
   entirely preceeds OFFSET.  This is the correct behavior: depending
@


1.13
log
@run copyright.sh for 2011.
@
text
@d18 1
a18 1
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */
@


1.12
log
@	* gdb_assert.h (gdb_assert_not_reached): New macro.
	(gdb_assert_fail): Fix typo in comment.
	* avr-tdep.c (avr_return_value): Use gdb_assert_not_reached instead of
	gdb_assert (0).
	* darwin-nat.c (darwin_check_new_threads): Ditto.
	* dwarf2read.c (dwarf2_get_section_info): Ditto.
	(munmap_section_buffer): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	(m32c_decode_srcdest4, m32c_decode_sd23, m32c_frame_base): Ditto.
	* macroexp.c (get_character_constant): Ditto.
	(get_string_literal): Ditto.
	* mep-tdep.c (mep_pseudo_cr_size): Ditto.
	(mep_pseudo_cr_index, mep_register_type): Ditto.
	(mep_pseudo_register_read, mep_pseudo_register_write): Ditto.
	(mep_get_insn, mep_analyze_prologue): Ditto.
	* objfiles.c (qsort_cmp): Ditto.
	* prologue-value.c (pv_is_identical): Ditto.
	* record.c (record_get_loc): Ditto.
	* value.c (value_static_field): Ditto.
	* xtensa-tdep.c (call0_track_op): Ditto.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2007, 2008, 2009, 2010
@


1.11
log
@2010-05-15  Michael Snyder  <msnyder@@vmware.com>

	* parse.c: White space.
	* p-lang.c: White space.
	* posix-hdep.c: White space.
	* printcmd.c: White space.
	* progspace.c: White space.
	* prologue-value.c: White space.
	* psymtab.c: White space.
	* p-typeprint.c: White space.
	* p-valprint.c: White space.
@
text
@d206 1
a206 1
      gdb_assert (0);
@


1.10
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d349 1
d472 1
d497 1
@


1.9
log
@	* prologue-value.c (make_pv_area): Add ADDR_BIT argument.
	Use it instead of address bits of current_gdbarch.
	* prologue-value.c (make_pv_area): Add ADDR_BIT argument.
	* arm-tdep.c (thumb_analyze_prologue): Pass address bits to
	make_pv_area.
	(arm_scan_prologue): Likewise.
	* m32c-tdep.c (m32c_analyze_prologue): Likewise.
	* mep-tdep.c (mep_analyze_prologue): Likewise.
	* mn10300-tdep.c (mn10300_analyze_prologue): Likewise.
	* s390-tdep.c (s390_analyze_prologue): Likewise.
@
text
@d2 2
a3 1
   Copyright 2003, 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.8
log
@        Updated copyright notices for most files.
@
text
@d317 1
a317 1
make_pv_area (int base_reg)
d328 1
a328 2
  a->addr_mask = ((((CORE_ADDR) 1
		   << (gdbarch_addr_bit (current_gdbarch) - 1)) - 1) << 1) | 1;
@


1.7
log
@	Updated copyright notices for most files.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.6
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.5
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_ADDR_BIT): Replace by gdbarch_addr_bit.
	* valops.c (value_cast): Likewise.
	* utils.c (strlen_paddr, paddr, paddr_nz, paddress): Likewise.
	* ui-out.c (ui_out_field_core_addr): Likewise.
	* tracepoint.c (tracepoints_info): Likewise.
	* symtab.c (print_msymbol_info): Likewise.
	* solib-irix.c (irix_current_sos)
	(irix_open_symbol_file_object): Likewise.
	* remote.c (build_remote_gdbarch_data): Likewise.
	* prologue-value.c (make_pv_area): Likewise.
	* procfs.c (info_mappings_callback): Likewise.
	* printcmd.c (print_scalar_formatted)
	(deprecated_print_address_numeric): Likewise.
	* memattr.c (mem_info_command): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* gdbtypes.c (build_flt, gdbtypes_post_init): Likewise.
	* exec.c (print_section_info): Likewise.
	* dwarf2read.c (read_subrange_type): Likewise.
	* dwarf2loc.c (find_location_expression): Likewise.
	* dwarf2expr.c (dwarf2_read_address, unsigned_address_type)
	(signed_address_type, execute_stack_op): Likewise.
	* breakpoint.c (print_one_breakpoint, breakpoint_1): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d8 1
a8 1
   the Free Software Foundation; either version 2 of the License, or
d17 1
a17 6
   along with this program; if not, write to:

        Free Software Foundation, Inc.
        51 Franklin St - Fifth Floor
        Boston, MA 02110-1301
        USA */
@


1.4
log
@Copyright updates for 2007.
@
text
@d333 2
a334 1
  a->addr_mask = ((((CORE_ADDR) 1 << (TARGET_ADDR_BIT - 1)) - 1) << 1) | 1;
@


1.3
log
@	* prologue-value.c (clear_entries): Fix memory leak.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005 Free Software Foundation, Inc.
@


1.2
log
@src/gdb/ChangeLog:
2006-03-28  Jim Blandy  <jimb@@codesourcery.com>

	* prologue-value.c, prologue-value.h: New files.
	* Makefile.in (prologue_value_h): New variable.
	(HFILES_NO_SRCDIR): List prologue-value.h.
	(SFILES): List prologue-value.c.
	(COMMON_OBS): List prologue-value.o.
	(prologue-value.o): New rule.

src/gdb/doc/ChangeLog:
2006-03-28  Jim Blandy  <jimb@@codesourcery.com>

	* gdbint.texinfo (Prologue Analysis): New section.
@
text
@d354 1
@


1.1
log
@file prologue-value.c was initially added on branch gdb-csl-20060226-branch.
@
text
@d1 591
@


1.1.2.1
log
@2006-03-21  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz <dan@@codesourcery.com>
	Jim Blandy <jimb@@codesourcery.com>

	* gdb/Makefile.in: Add prologue_value.{c,h}
	* gdb/arm-tdep.c: Include prologue-value.h.
	(thumb_skip_prologue): Remove.
	(thumb_analyze_prologue): New function.
	(arm_skip_prologue): Use thumb_analyze_prologue.
	(thumb_scan_prologue): Ditto.
	* gdb/prologue-value.c: New file.
	* gdb/prologue-value.h: New file.
	* gdb/config/arm/embed.mt (TDEPFILES): Add prologue-value.o.
	* gdb/config/arm/linux.mt (TDEPFILES): Add prologue-value.o.
	* gdb/config/arm/nbsd.mt (TDEPFILES): Add prologue-value.o.
	* gdb/config/arm/wince.mt (TDEPFILES): Add prologue-value.o.
	* gdb/testsuite/gdb.arch/thumb-prologue.c: New file.
	* gdb/testsuite/gdb.arch/thumb-prologue.exp: New file.
@
text
@a0 591
/* Prologue value handling for GDB.
   Copyright 2003, 2004, 2005 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to:

        Free Software Foundation, Inc.
        51 Franklin St - Fifth Floor
        Boston, MA 02110-1301
        USA */

#include "defs.h"
#include "gdb_string.h"
#include "gdb_assert.h"
#include "prologue-value.h"
#include "regcache.h"


/* Constructors.  */

pv_t
pv_unknown (void)
{
  pv_t v = { pvk_unknown, 0, 0 };

  return v;
}


pv_t
pv_constant (CORE_ADDR k)
{
  pv_t v;

  v.kind = pvk_constant;
  v.reg = -1;                   /* for debugging */
  v.k = k;

  return v;
}


pv_t
pv_register (int reg, CORE_ADDR k)
{
  pv_t v;

  v.kind = pvk_register;
  v.reg = reg;
  v.k = k;

  return v;
}



/* Arithmetic operations.  */

/* If one of *A and *B is a constant, and the other isn't, swap the
   values as necessary to ensure that *B is the constant.  This can
   reduce the number of cases we need to analyze in the functions
   below.  */
static void
constant_last (pv_t *a, pv_t *b)
{
  if (a->kind == pvk_constant
      && b->kind != pvk_constant)
    {
      pv_t temp = *a;
      *a = *b;
      *b = temp;
    }
}


pv_t
pv_add (pv_t a, pv_t b)
{
  constant_last (&a, &b);

  /* We can add a constant to a register.  */
  if (a.kind == pvk_register
      && b.kind == pvk_constant)
    return pv_register (a.reg, a.k + b.k);

  /* We can add a constant to another constant.  */
  else if (a.kind == pvk_constant
           && b.kind == pvk_constant)
    return pv_constant (a.k + b.k);

  /* Anything else we don't know how to add.  We don't have a
     representation for, say, the sum of two registers, or a multiple
     of a register's value (adding a register to itself).  */
  else
    return pv_unknown ();
}


pv_t
pv_add_constant (pv_t v, CORE_ADDR k)
{
  /* Rather than thinking of all the cases we can and can't handle,
     we'll just let pv_add take care of that for us.  */
  return pv_add (v, pv_constant (k));
}


pv_t
pv_subtract (pv_t a, pv_t b)
{
  /* This isn't quite the same as negating B and adding it to A, since
     we don't have a representation for the negation of anything but a
     constant.  For example, we can't negate { pvk_register, R1, 10 },
     but we do know that { pvk_register, R1, 10 } minus { pvk_register,
     R1, 5 } is { pvk_constant, <ignored>, 5 }.

     This means, for example, that we could subtract two stack
     addresses; they're both relative to the original SP.  Since the
     frame pointer is set based on the SP, its value will be the
     original SP plus some constant (probably zero), so we can use its
     value just fine, too.  */

  constant_last (&a, &b);

  /* We can subtract two constants.  */
  if (a.kind == pvk_constant
      && b.kind == pvk_constant)
    return pv_constant (a.k - b.k);

  /* We can subtract a constant from a register.  */
  else if (a.kind == pvk_register
           && b.kind == pvk_constant)
    return pv_register (a.reg, a.k - b.k);

  /* We can subtract a register from itself, yielding a constant.  */
  else if (a.kind == pvk_register
           && b.kind == pvk_register
           && a.reg == b.reg)
    return pv_constant (a.k - b.k);

  /* We don't know how to subtract anything else.  */
  else
    return pv_unknown ();
}


pv_t
pv_logical_and (pv_t a, pv_t b)
{
  constant_last (&a, &b);

  /* We can 'and' two constants.  */
  if (a.kind == pvk_constant
      && b.kind == pvk_constant)
    return pv_constant (a.k & b.k);

  /* We can 'and' anything with the constant zero.  */
  else if (b.kind == pvk_constant
           && b.k == 0)
    return pv_constant (0);
  
  /* We can 'and' anything with ~0.  */
  else if (b.kind == pvk_constant
           && b.k == ~ (CORE_ADDR) 0)
    return a;

  /* We can 'and' a register with itself.  */
  else if (a.kind == pvk_register
           && b.kind == pvk_register
           && a.reg == b.reg
           && a.k == b.k)
    return a;

  /* Otherwise, we don't know.  */
  else
    return pv_unknown ();
}



/* Examining prologue values.  */

int
pv_is_identical (pv_t a, pv_t b)
{
  if (a.kind != b.kind)
    return 0;

  switch (a.kind)
    {
    case pvk_unknown:
      return 1;
    case pvk_constant:
      return (a.k == b.k);
    case pvk_register:
      return (a.reg == b.reg && a.k == b.k);
    default:
      gdb_assert (0);
    }
}


int
pv_is_constant (pv_t a)
{
  return (a.kind == pvk_constant);
}


int
pv_is_register (pv_t a, int r)
{
  return (a.kind == pvk_register
          && a.reg == r);
}


int
pv_is_register_k (pv_t a, int r, CORE_ADDR k)
{
  return (a.kind == pvk_register
          && a.reg == r
          && a.k == k);
}


enum pv_boolean
pv_is_array_ref (pv_t addr, CORE_ADDR size,
                 pv_t array_addr, CORE_ADDR array_len, 
                 CORE_ADDR elt_size,
                 int *i)
{
  /* Note that, since .k is a CORE_ADDR, and CORE_ADDR is unsigned, if
     addr is *before* the start of the array, then this isn't going to
     be negative...  */
  pv_t offset = pv_subtract (addr, array_addr);

  if (offset.kind == pvk_constant)
    {
      /* This is a rather odd test.  We want to know if the SIZE bytes
         at ADDR don't overlap the array at all, so you'd expect it to
         be an || expression: "if we're completely before || we're
         completely after".  But with unsigned arithmetic, things are
         different: since it's a number circle, not a number line, the
         right values for offset.k are actually one contiguous range.  */
      if (offset.k <= -size
          && offset.k >= array_len * elt_size)
        return pv_definite_no;
      else if (offset.k % elt_size != 0
               || size != elt_size)
        return pv_maybe;
      else
        {
          *i = offset.k / elt_size;
          return pv_definite_yes;
        }
    }
  else
    return pv_maybe;
}



/* Areas.  */


/* A particular value known to be stored in an area.

   Entries form a ring, sorted by unsigned offset from the area's base
   register's value.  Since entries can straddle the wrap-around point,
   unsigned offsets form a circle, not a number line, so the list
   itself is structured the same way --- there is no inherent head.
   The entry with the lowest offset simply follows the entry with the
   highest offset.  Entries may abut, but never overlap.  The area's
   'entry' pointer points to an arbitrary node in the ring.  */
struct area_entry
{
  /* Links in the doubly-linked ring.  */
  struct area_entry *prev, *next;

  /* Offset of this entry's address from the value of the base
     register.  */
  CORE_ADDR offset;

  /* The size of this entry.  Note that an entry may wrap around from
     the end of the address space to the beginning.  */
  CORE_ADDR size;

  /* The value stored here.  */
  pv_t value;
};


struct pv_area
{
  /* This area's base register.  */
  int base_reg;

  /* The mask to apply to addresses, to make the wrap-around happen at
     the right place.  */
  CORE_ADDR addr_mask;

  /* An element of the doubly-linked ring of entries, or zero if we
     have none.  */
  struct area_entry *entry;
};


struct pv_area *
make_pv_area (int base_reg)
{
  struct pv_area *a = (struct pv_area *) xmalloc (sizeof (*a));

  memset (a, 0, sizeof (*a));

  a->base_reg = base_reg;
  a->entry = 0;

  /* Remember that shift amounts equal to the type's width are
     undefined.  */
  a->addr_mask = ((((CORE_ADDR) 1 << (TARGET_ADDR_BIT - 1)) - 1) << 1) | 1;

  return a;
}


/* Delete all entries from AREA.  */
static void
clear_entries (struct pv_area *area)
{
  struct area_entry *e = area->entry;

  if (e)
    {
      /* This needs to be a do-while loop, in order to actually
         process the node being checked for in the terminating
         condition.  */
      do
        {
          struct area_entry *next = e->next;
          xfree (e);
        }
      while (e != area->entry);

      area->entry = 0;
    }
}


void
free_pv_area (struct pv_area *area)
{
  clear_entries (area);
  xfree (area);
}


static void
do_free_pv_area_cleanup (void *arg)
{
  free_pv_area ((struct pv_area *) arg);
}


struct cleanup *
make_cleanup_free_pv_area (struct pv_area *area)
{
  return make_cleanup (do_free_pv_area_cleanup, (void *) area);
}


int
pv_area_store_would_trash (struct pv_area *area, pv_t addr)
{
  /* It may seem odd that pvk_constant appears here --- after all,
     that's the case where we know the most about the address!  But
     pv_areas are always relative to a register, and we don't know the
     value of the register, so we can't compare entry addresses to
     constants.  */
  return (addr.kind == pvk_unknown
          || addr.kind == pvk_constant
          || (addr.kind == pvk_register && addr.reg != area->base_reg));
}


/* Return a pointer to the first entry we hit in AREA starting at
   OFFSET and going forward.

   This may return zero, if AREA has no entries.

   And since the entries are a ring, this may return an entry that
   entirely preceeds OFFSET.  This is the correct behavior: depending
   on the sizes involved, we could still overlap such an area, with
   wrap-around.  */
static struct area_entry *
find_entry (struct pv_area *area, CORE_ADDR offset)
{
  struct area_entry *e = area->entry;

  if (! e)
    return 0;

  /* If the next entry would be better than the current one, then scan
     forward.  Since we use '<' in this loop, it always terminates.
     
     Note that, even setting aside the addr_mask stuff, we must not
     simplify this, in high school algebra fashion, to
     (e->next->offset < e->offset), because of the way < interacts
     with wrap-around.  We have to subtract offset from both sides to
     make sure both things we're comparing are on the same side of the
     discontinuity.  */
  while (((e->next->offset - offset) & area->addr_mask)
         < ((e->offset - offset) & area->addr_mask))
    e = e->next;

  /* If the previous entry would be better than the current one, then
     scan backwards.  */
  while (((e->prev->offset - offset) & area->addr_mask)
         < ((e->offset - offset) & area->addr_mask))
    e = e->prev;

  /* In case there's some locality to the searches, set the area's
     pointer to the entry we've found.  */
  area->entry = e;

  return e;
}


/* Return non-zero if the SIZE bytes at OFFSET would overlap ENTRY;
   return zero otherwise.  AREA is the area to which ENTRY belongs.  */
static int
overlaps (struct pv_area *area,
          struct area_entry *entry,
          CORE_ADDR offset,
          CORE_ADDR size)
{
  /* Think carefully about wrap-around before simplifying this.  */
  return (((entry->offset - offset) & area->addr_mask) < size
          || ((offset - entry->offset) & area->addr_mask) < entry->size);
}


void
pv_area_store (struct pv_area *area,
               pv_t addr,
               CORE_ADDR size,
               pv_t value)
{
  /* Remove any (potentially) overlapping entries.  */
  if (pv_area_store_would_trash (area, addr))
    clear_entries (area);
  else
    {
      CORE_ADDR offset = addr.k;
      struct area_entry *e = find_entry (area, offset);

      /* Delete all entries that we would overlap.  */
      while (e && overlaps (area, e, offset, size))
        {
          struct area_entry *next = (e->next == e) ? 0 : e->next;
          e->prev->next = e->next;
          e->next->prev = e->prev;

          xfree (e);
          e = next;
        }

      /* Move the area's pointer to the next remaining entry.  This
         will also zero the pointer if we've deleted all the entries.  */
      area->entry = e;
    }

  /* Now, there are no entries overlapping us, and area->entry is
     either zero or pointing at the closest entry after us.  We can
     just insert ourselves before that.

     But if we're storing an unknown value, don't bother --- that's
     the default.  */
  if (value.kind == pvk_unknown)
    return;
  else
    {
      CORE_ADDR offset = addr.k;
      struct area_entry *e = (struct area_entry *) xmalloc (sizeof (*e));
      e->offset = offset;
      e->size = size;
      e->value = value;

      if (area->entry)
        {
          e->prev = area->entry->prev;
          e->next = area->entry;
          e->prev->next = e->next->prev = e;
        }
      else
        {
          e->prev = e->next = e;
          area->entry = e;
        }
    }
}


pv_t
pv_area_fetch (struct pv_area *area, pv_t addr, CORE_ADDR size)
{
  /* If we have no entries, or we can't decide how ADDR relates to the
     entries we do have, then the value is unknown.  */
  if (! area->entry
      || pv_area_store_would_trash (area, addr))
    return pv_unknown ();
  else
    {
      CORE_ADDR offset = addr.k;
      struct area_entry *e = find_entry (area, offset);

      /* If this entry exactly matches what we're looking for, then
         we're set.  Otherwise, say it's unknown.  */
      if (e->offset == offset && e->size == size)
        return e->value;
      else
        return pv_unknown ();
    }
}


int
pv_area_find_reg (struct pv_area *area,
                  struct gdbarch *gdbarch,
                  int reg,
                  CORE_ADDR *offset_p)
{
  struct area_entry *e = area->entry;

  if (e)
    do
      {
        if (e->value.kind == pvk_register
            && e->value.reg == reg
            && e->value.k == 0
            && e->size == register_size (gdbarch, reg))
          {
            if (offset_p)
              *offset_p = e->offset;
            return 1;
          }

        e = e->next;
      }
    while (e != area->entry);

  return 0;
}


void
pv_area_scan (struct pv_area *area,
              void (*func) (void *closure,
                            pv_t addr,
                            CORE_ADDR size,
                            pv_t value),
              void *closure)
{
  struct area_entry *e = area->entry;
  pv_t addr;

  addr.kind = pvk_register;
  addr.reg = area->base_reg;

  if (e)
    do
      {
        addr.k = e->offset;
        func (closure, addr, e->size, e->value);
        e = e->next;
      }
    while (e != area->entry);
}
@

