head	1.103;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.94.2.1
	gdb_7_6-2013-04-26-release:1.94
	gdb_7_6-branch:1.94.0.2
	gdb_7_6-2013-03-12-branchpoint:1.94
	gdb_7_5_1-2012-11-29-release:1.86
	gdb_7_5-2012-08-17-release:1.86
	gdb_7_5-branch:1.86.0.2
	gdb_7_5-2012-07-18-branchpoint:1.86
	gdb_7_4_1-2012-04-26-release:1.82.4.1
	gdb_7_4-2012-01-24-release:1.82.4.1
	gdb_7_4-branch:1.82.0.4
	gdb_7_4-2011-12-13-branchpoint:1.82
	gdb_7_3_1-2011-09-04-release:1.82
	gdb_7_3-2011-07-26-release:1.82
	gdb_7_3-branch:1.82.0.2
	gdb_7_3-2011-04-01-branchpoint:1.82
	gdb_7_2-2010-09-02-release:1.79
	gdb_7_2-branch:1.79.0.2
	gdb_7_2-2010-07-07-branchpoint:1.79
	gdb_7_1-2010-03-18-release:1.78
	gdb_7_1-branch:1.78.0.2
	gdb_7_1-2010-02-18-branchpoint:1.78
	gdb_7_0_1-2009-12-22-release:1.77
	gdb_7_0-2009-10-06-release:1.77
	gdb_7_0-branch:1.77.0.4
	gdb_7_0-2009-09-16-branchpoint:1.77
	arc-sim-20090309:1.63.2.1
	msnyder-checkpoint-072509-branch:1.77.0.2
	msnyder-checkpoint-072509-branchpoint:1.77
	arc-insight_6_8-branch:1.63.2.1.0.4
	arc-insight_6_8-branchpoint:1.63.2.1
	insight_6_8-branch:1.63.2.1.0.2
	insight_6_8-branchpoint:1.63.2.1
	reverse-20081226-branch:1.69.0.4
	reverse-20081226-branchpoint:1.69
	multiprocess-20081120-branch:1.69.0.2
	multiprocess-20081120-branchpoint:1.69
	reverse-20080930-branch:1.68.0.2
	reverse-20080930-branchpoint:1.68
	reverse-20080717-branch:1.65.0.2
	reverse-20080717-branchpoint:1.65
	msnyder-reverse-20080609-branch:1.64.0.2
	msnyder-reverse-20080609-branchpoint:1.64
	drow-reverse-20070409-branch:1.53.0.2
	drow-reverse-20070409-branchpoint:1.53
	gdb_6_8-2008-03-27-release:1.63.2.1
	gdb_6_8-branch:1.63.0.2
	gdb_6_8-2008-02-26-branchpoint:1.63
	gdb_6_7_1-2007-10-29-release:1.60.2.1
	gdb_6_7-2007-10-10-release:1.60
	gdb_6_7-branch:1.60.0.2
	gdb_6_7-2007-09-07-branchpoint:1.60
	insight_6_6-20070208-release:1.52
	gdb_6_6-2006-12-18-release:1.52
	gdb_6_6-branch:1.52.0.10
	gdb_6_6-2006-11-15-branchpoint:1.52
	insight_6_5-20061003-release:1.52
	gdb-csl-symbian-6_4_50_20060226-12:1.51.8.1
	gdb-csl-sourcerygxx-3_4_4-25:1.50
	nickrob-async-20060828-mergepoint:1.52
	gdb-csl-symbian-6_4_50_20060226-11:1.51.8.1
	gdb-csl-sourcerygxx-4_1-17:1.51
	gdb-csl-20060226-branch-local-2:1.51
	gdb-csl-sourcerygxx-4_1-14:1.51
	gdb-csl-sourcerygxx-4_1-13:1.51
	gdb-csl-sourcerygxx-4_1-12:1.51
	gdb-csl-sourcerygxx-3_4_4-21:1.51
	gdb_6_5-20060621-release:1.52
	gdb-csl-sourcerygxx-4_1-9:1.51
	gdb-csl-sourcerygxx-4_1-8:1.51
	gdb-csl-sourcerygxx-4_1-7:1.51
	gdb-csl-arm-2006q1-6:1.51
	gdb-csl-sourcerygxx-4_1-6:1.51
	gdb-csl-symbian-6_4_50_20060226-10:1.51.8.1
	gdb-csl-symbian-6_4_50_20060226-9:1.51.8.1
	gdb-csl-symbian-6_4_50_20060226-8:1.51.8.1
	gdb-csl-coldfire-4_1-11:1.51
	gdb-csl-sourcerygxx-3_4_4-19:1.51
	gdb-csl-coldfire-4_1-10:1.51
	gdb_6_5-branch:1.52.0.8
	gdb_6_5-2006-05-14-branchpoint:1.52
	gdb-csl-sourcerygxx-4_1-5:1.51
	nickrob-async-20060513-branch:1.52.0.6
	nickrob-async-20060513-branchpoint:1.52
	gdb-csl-sourcerygxx-4_1-4:1.51
	msnyder-reverse-20060502-branch:1.52.0.4
	msnyder-reverse-20060502-branchpoint:1.52
	gdb-csl-morpho-4_1-4:1.51
	gdb-csl-sourcerygxx-3_4_4-17:1.51
	readline_5_1-import-branch:1.52.0.2
	readline_5_1-import-branchpoint:1.52
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.51
	gdb-csl-symbian-20060226-branch:1.51.0.8
	gdb-csl-symbian-20060226-branchpoint:1.51
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.51
	msnyder-reverse-20060331-branch:1.51.0.6
	msnyder-reverse-20060331-branchpoint:1.51
	gdb-csl-available-20060303-branch:1.51.0.4
	gdb-csl-available-20060303-branchpoint:1.51
	gdb-csl-20060226-branch:1.51.0.2
	gdb-csl-20060226-branchpoint:1.51
	gdb_6_4-20051202-release:1.50
	msnyder-fork-checkpoint-branch:1.50.0.8
	msnyder-fork-checkpoint-branchpoint:1.50
	gdb-csl-gxxpro-6_3-branch:1.50.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.50
	gdb_6_4-branch:1.50.0.4
	gdb_6_4-2005-11-01-branchpoint:1.50
	gdb-csl-arm-20051020-branch:1.50.0.2
	gdb-csl-arm-20051020-branchpoint:1.50
	msnyder-tracepoint-checkpoint-branch:1.49.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.49
	gdb-csl-arm-20050325-2005-q1b:1.47
	gdb-csl-arm-20050325-2005-q1a:1.47
	csl-arm-20050325-branch:1.47.0.2
	csl-arm-20050325-branchpoint:1.47
	gdb-post-i18n-errorwarning-20050211:1.46
	gdb-pre-i18n-errorwarning-20050211:1.45
	gdb_6_3-20041109-release:1.45
	gdb_6_3-branch:1.45.0.2
	gdb_6_3-20041019-branchpoint:1.45
	drow_intercu-merge-20040921:1.44
	drow_intercu-merge-20040915:1.44
	jimb-gdb_6_2-e500-branch:1.42.0.6
	jimb-gdb_6_2-e500-branchpoint:1.42
	gdb_6_2-20040730-release:1.42
	gdb_6_2-branch:1.42.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.42
	gdb_6_1_1-20040616-release:1.39
	gdb_6_1-2004-04-05-release:1.39
	drow_intercu-merge-20040402:1.39
	drow_intercu-merge-20040327:1.39
	ezannoni_pie-20040323-branch:1.39.0.10
	ezannoni_pie-20040323-branchpoint:1.39
	cagney_tramp-20040321-mergepoint:1.39
	cagney_tramp-20040309-branch:1.39.0.8
	cagney_tramp-20040309-branchpoint:1.39
	gdb_6_1-branch:1.39.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.39
	drow_intercu-20040221-branch:1.39.0.4
	drow_intercu-20040221-branchpoint:1.39
	cagney_bfdfile-20040213-branch:1.39.0.2
	cagney_bfdfile-20040213-branchpoint:1.39
	drow-cplus-merge-20040208:1.39
	carlton_dictionary-20040126-merge:1.38
	cagney_bigcore-20040122-branch:1.38.0.2
	cagney_bigcore-20040122-branchpoint:1.38
	drow-cplus-merge-20040113:1.38
	drow-cplus-merge-20031224:1.38
	drow-cplus-merge-20031220:1.38
	carlton_dictionary-20031215-merge:1.38
	drow-cplus-merge-20031214:1.38
	carlton-dictionary-20031111-merge:1.38
	gdb_6_0-2003-10-04-release:1.35.14.1
	kettenis_sparc-20030918-branch:1.37.0.4
	kettenis_sparc-20030918-branchpoint:1.37
	carlton_dictionary-20030917-merge:1.37
	ezannoni_pie-20030916-branchpoint:1.37
	ezannoni_pie-20030916-branch:1.37.0.2
	cagney_x86i386-20030821-branch:1.36.0.2
	cagney_x86i386-20030821-branchpoint:1.36
	carlton_dictionary-20030805-merge:1.35
	carlton_dictionary-20030627-merge:1.35
	gdb_6_0-branch:1.35.0.14
	gdb_6_0-2003-06-23-branchpoint:1.35
	jimb-ppc64-linux-20030613-branch:1.35.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.35
	cagney_convert-20030606-branch:1.35.0.10
	cagney_convert-20030606-branchpoint:1.35
	cagney_writestrings-20030508-branch:1.35.0.8
	cagney_writestrings-20030508-branchpoint:1.35
	jimb-ppc64-linux-20030528-branch:1.35.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.35
	carlton_dictionary-20030523-merge:1.35
	cagney_fileio-20030521-branch:1.35.0.4
	cagney_fileio-20030521-branchpoint:1.35
	kettenis_i386newframe-20030517-mergepoint:1.35
	jimb-ppc64-linux-20030509-branch:1.35.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.35
	kettenis_i386newframe-20030504-mergepoint:1.34
	carlton_dictionary-20030430-merge:1.34
	kettenis_i386newframe-20030419-branch:1.34.0.16
	kettenis_i386newframe-20030419-branchpoint:1.34
	carlton_dictionary-20030416-merge:1.34
	cagney_frameaddr-20030409-mergepoint:1.34
	kettenis_i386newframe-20030406-branch:1.34.0.14
	kettenis_i386newframe-20030406-branchpoint:1.34
	cagney_frameaddr-20030403-branchpoint:1.34
	cagney_frameaddr-20030403-branch:1.34.0.12
	cagney_framebase-20030330-mergepoint:1.34
	cagney_framebase-20030326-branch:1.34.0.10
	cagney_framebase-20030326-branchpoint:1.34
	cagney_lazyid-20030317-branch:1.34.0.8
	cagney_lazyid-20030317-branchpoint:1.34
	kettenis-i386newframe-20030316-mergepoint:1.34
	offbyone-20030313-branch:1.34.0.6
	offbyone-20030313-branchpoint:1.34
	kettenis-i386newframe-20030308-branch:1.34.0.4
	kettenis-i386newframe-20030308-branchpoint:1.34
	carlton_dictionary-20030305-merge:1.34
	cagney_offbyone-20030303-branch:1.34.0.2
	cagney_offbyone-20030303-branchpoint:1.34
	carlton_dictionary-20030207-merge:1.33
	interps-20030203-mergepoint:1.32
	interps-20030202-branch:1.32.0.4
	interps-20030202-branchpoint:1.32
	cagney-unwind-20030108-branch:1.32.0.2
	cagney-unwind-20030108-branchpoint:1.32
	carlton_dictionary-20021223-merge:1.32
	gdb_5_3-2002-12-12-release:1.30
	carlton_dictionary-20021115-merge:1.32
	kseitz_interps-20021105-merge:1.30
	kseitz_interps-20021103-merge:1.30
	drow-cplus-merge-20021020:1.30
	drow-cplus-merge-20021025:1.30
	carlton_dictionary-20021025-merge:1.30
	carlton_dictionary-20021011-merge:1.30
	drow-cplus-branch:1.30.0.6
	drow-cplus-branchpoint:1.30
	kseitz_interps-20020930-merge:1.30
	carlton_dictionary-20020927-merge:1.30
	carlton_dictionary-branch:1.30.0.4
	carlton_dictionary-20020920-branchpoint:1.30
	gdb_5_3-branch:1.30.0.2
	gdb_5_3-2002-09-04-branchpoint:1.30
	kseitz_interps-20020829-merge:1.30
	cagney_sysregs-20020825-branch:1.29.0.12
	cagney_sysregs-20020825-branchpoint:1.29
	readline_4_3-import-branch:1.29.0.10
	readline_4_3-import-branchpoint:1.29
	gdb_5_2_1-2002-07-23-release:1.29
	kseitz_interps-20020528-branch:1.29.0.8
	kseitz_interps-20020528-branchpoint:1.29
	cagney_regbuf-20020515-branch:1.29.0.6
	cagney_regbuf-20020515-branchpoint:1.29
	jimb-macro-020506-branch:1.29.0.4
	jimb-macro-020506-branchpoint:1.29
	gdb_5_2-2002-04-29-release:1.29
	gdb_5_2-branch:1.29.0.2
	gdb_5_2-2002-03-03-branchpoint:1.29
	gdb_5_1_1-2002-01-24-release:1.27
	gdb_5_1_0_1-2002-01-03-release:1.27
	cygnus_cvs_20020108_pre:1.28
	gdb_5_1_0_1-2002-01-03-branchpoint:1.27
	gdb_5_1_0_1-2002-01-03-branch:1.27.0.8
	gdb_5_1-2001-11-21-release:1.27
	gdb_s390-2001-09-26-branch:1.27.0.6
	gdb_s390-2001-09-26-branchpoint:1.27
	gdb_5_1-2001-07-29-branch:1.27.0.4
	gdb_5_1-2001-07-29-branchpoint:1.27
	dberlin-typesystem-branch:1.27.0.2
	dberlin-typesystem-branchpoint:1.27
	gdb-post-ptid_t-2001-05-03:1.25
	gdb-pre-ptid_t-2001-05-03:1.24
	insight-precleanup-2001-01-01:1.19
	gdb-post-protoization-2000-07-29:1.12
	gdb-pre-protoization-2000-07-29:1.11
	gdb-premipsmulti-2000-06-06-branch:1.11.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.11
	gdb-post-params-removal-2000-06-04:1.11
	gdb-pre-params-removal-2000-06-04:1.10
	gdb-post-params-removal-2000-05-28:1.9
	gdb-pre-params-removal-2000-05-28:1.8
	gdb_5_0-2000-05-19-release:1.5.2.1
	gdb_4_18_2-2000-05-18-release:1.5.2.1
	gdb_4_95_1-2000-05-11-snapshot:1.5.2.1
	gdb_4_95_0-2000-04-27-snapshot:1.5.2.1
	gdb_5_0-2000-04-10-branch:1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.5
	repo-unification-2000-02-06:1.1.1.10
	insight-2000-02-04:1.1.1.10
	gdb-2000-02-04:1.1.1.10
	gdb-2000-02-02:1.1.1.10
	gdb-2000-02-01:1.1.1.10
	gdb-2000-01-31:1.1.1.10
	gdb-2000-01-26:1.1.1.10
	gdb-2000-01-24:1.1.1.10
	gdb-2000-01-17:1.1.1.10
	gdb-2000-01-10:1.1.1.10
	gdb-2000-01-05:1.1.1.10
	gdb-1999-12-21:1.1.1.9
	gdb-1999-12-13:1.1.1.8
	gdb-1999-12-07:1.1.1.8
	gdb-1999-12-06:1.1.1.8
	gdb-1999-11-16:1.1.1.8
	gdb-1999-11-08:1.1.1.7
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.6
	gdb-1999-10-11:1.1.1.6
	gdb-1999-10-04:1.1.1.6
	gdb-1999-09-28:1.1.1.6
	gdb-1999-09-21:1.1.1.6
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.103
date	2013.09.30.11.50.12;	author luisgpm;	state Exp;
branches;
next	1.102;

1.102
date	2013.08.05.16.54.27;	author tromey;	state Exp;
branches;
next	1.101;

1.101
date	2013.05.10.12.10.20;	author brobecke;	state Exp;
branches;
next	1.100;

1.100
date	2013.05.08.06.25.21;	author brobecke;	state Exp;
branches;
next	1.99;

1.99
date	2013.05.08.06.23.50;	author brobecke;	state Exp;
branches;
next	1.98;

1.98
date	2013.05.08.06.19.32;	author brobecke;	state Exp;
branches;
next	1.97;

1.97
date	2013.05.06.12.55.52;	author brobecke;	state Exp;
branches;
next	1.96;

1.96
date	2013.04.30.11.52.13;	author brobecke;	state Exp;
branches;
next	1.95;

1.95
date	2013.04.30.11.36.45;	author brobecke;	state Exp;
branches;
next	1.94;

1.94
date	2013.01.01.06.32.50;	author brobecke;	state Exp;
branches
	1.94.2.1;
next	1.93;

1.93
date	2012.11.20.22.51.04;	author muller;	state Exp;
branches;
next	1.92;

1.92
date	2012.11.09.19.58.00;	author tromey;	state Exp;
branches;
next	1.91;

1.91
date	2012.09.27.12.53.57;	author brobecke;	state Exp;
branches;
next	1.90;

1.90
date	2012.09.27.12.53.44;	author brobecke;	state Exp;
branches;
next	1.89;

1.89
date	2012.09.27.12.53.13;	author brobecke;	state Exp;
branches;
next	1.88;

1.88
date	2012.09.27.12.52.53;	author brobecke;	state Exp;
branches;
next	1.87;

1.87
date	2012.09.27.12.52.10;	author brobecke;	state Exp;
branches;
next	1.86;

1.86
date	2012.05.24.16.39.11;	author palves;	state Exp;
branches;
next	1.85;

1.85
date	2012.05.02.23.18.36;	author brobecke;	state Exp;
branches;
next	1.84;

1.84
date	2012.05.02.23.06.58;	author brobecke;	state Exp;
branches;
next	1.83;

1.83
date	2012.01.04.08.17.11;	author brobecke;	state Exp;
branches;
next	1.82;

1.82
date	2011.02.26.02.07.08;	author msnyder;	state Exp;
branches
	1.82.4.1;
next	1.81;

1.81
date	2011.01.11.21.53.24;	author msnyder;	state Exp;
branches;
next	1.80;

1.80
date	2011.01.01.15.33.14;	author brobecke;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.07.15.24.16;	author brobecke;	state Exp;
branches;
next	1.78;

1.78
date	2010.01.01.07.31.41;	author brobecke;	state Exp;
branches;
next	1.77;

1.77
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.76;

1.76
date	2009.07.02.17.06.44;	author uweigand;	state Exp;
branches;
next	1.75;

1.75
date	2009.06.07.22.33.24;	author palves;	state Exp;
branches;
next	1.74;

1.74
date	2009.06.07.18.41.40;	author palves;	state Exp;
branches;
next	1.73;

1.73
date	2009.05.21.15.48.41;	author palves;	state Exp;
branches;
next	1.72;

1.72
date	2009.02.23.00.03.50;	author palves;	state Exp;
branches;
next	1.71;

1.71
date	2009.02.06.22.21.26;	author palves;	state Exp;
branches;
next	1.70;

1.70
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.69;

1.69
date	2008.11.09.11.27.18;	author vprus;	state Exp;
branches;
next	1.68;

1.68
date	2008.09.12.20.10.57;	author devans;	state Exp;
branches;
next	1.67;

1.67
date	2008.09.08.21.31.54;	author palves;	state Exp;
branches;
next	1.66;

1.66
date	2008.08.21.18.14.39;	author drow;	state Exp;
branches;
next	1.65;

1.65
date	2008.07.09.22.49.56;	author palves;	state Exp;
branches;
next	1.64;

1.64
date	2008.03.12.20.00.21;	author brobecke;	state Exp;
branches;
next	1.63;

1.63
date	2008.01.23.11.26.28;	author vprus;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.61;

1.61
date	2007.10.24.13.57.58;	author drow;	state Exp;
branches;
next	1.60;

1.60
date	2007.08.23.18.08.38;	author brobecke;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2007.06.16.17.16.25;	author uweigand;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.14.17.33.33;	author drow;	state Exp;
branches;
next	1.57;

1.57
date	2007.05.11.19.55.20;	author uweigand;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.06.18.55.41;	author uweigand;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.06.14.34.38;	author uweigand;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.06.14.32.31;	author uweigand;	state Exp;
branches;
next	1.53;

1.53
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.52;

1.52
date	2006.04.18.19.20.06;	author drow;	state Exp;
branches;
next	1.51;

1.51
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches
	1.51.8.1;
next	1.50;

1.50
date	2005.06.25.12.49.01;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2005.05.15.22.13.53;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.12.21.36.08;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2005.02.14.18.10.10;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2005.02.11.04.06.05;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2004.10.08.20.29.55;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2004.07.24.01.00.21;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.25.14.58.31;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.16.13.28.03;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.21.23.52.21;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2004.02.01.22.35.28;	author roland;	state Exp;
branches
	1.39.4.1;
next	1.38;

1.38
date	2003.09.21.01.26.45;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2003.09.06.21.09.21;	author kettenis;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2003.08.10.14.05.47;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.05.17.56.56;	author cagney;	state Exp;
branches
	1.35.14.1;
next	1.34;

1.34
date	2003.02.25.21.36.19;	author carlton;	state Exp;
branches
	1.34.16.1;
next	1.33;

1.33
date	2003.02.07.05.33.45;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2002.11.14.20.37.29;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.12.21.43.55;	author drow;	state Exp;
branches;
next	1.30;

1.30
date	2002.08.26.19.18.33;	author ciceron;	state Exp;
branches
	1.30.4.1
	1.30.6.1;
next	1.29;

1.29
date	2002.01.09.00.36.58;	author msnyder;	state Exp;
branches
	1.29.8.1;
next	1.28;

1.28
date	2001.11.01.16.17.08;	author fnf;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.15.00.03.36;	author kevinb;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.06.22.22.03;	author kevinb;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.04.04.15.27;	author kevinb;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.06.08.21.16;	author kevinb;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.07.03.44.24;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.06.20.05.41;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.24.21.01.02;	author jtc;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.30.21.50.58;	author jtc;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.18.03.29.25;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.28.07.53.41;	author schauer;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.05.17.43.00;	author msnyder;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.05.17.40.57;	author msnyder;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.31.00.39.10;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.30.00.58.58;	author msnyder;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.01.22.19.03;	author msnyder;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.26.23.22.41;	author msnyder;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.08.22.34.38;	author msnyder;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.13.16.31.50;	author nsd;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.07.17.18.57;	author schauer;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.04.07.01.14.08;	author nsd;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.23.21.44.50;	author msnyder;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.29.13.53.59;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.94.2.1
date	2013.05.10.12.30.05;	author brobecke;	state Exp;
branches;
next	;

1.82.4.1
date	2012.01.06.04.43.29;	author brobecke;	state Exp;
branches;
next	;

1.63.2.1
date	2008.03.12.20.03.12;	author brobecke;	state Exp;
branches;
next	;

1.60.2.1
date	2007.10.24.13.58.25;	author drow;	state Exp;
branches;
next	;

1.51.8.1
date	2006.04.11.21.58.24;	author drow;	state Exp;
branches;
next	;

1.39.4.1
date	2004.09.16.17.01.19;	author drow;	state Exp;
branches;
next	;

1.37.2.1
date	2003.09.29.22.40.19;	author ezannoni;	state Exp;
branches;
next	;

1.35.14.1
date	2003.08.10.14.08.39;	author kettenis;	state Exp;
branches;
next	;

1.34.16.1
date	2003.05.18.09.44.21;	author kettenis;	state Exp;
branches;
next	;

1.30.4.1
date	2002.11.15.19.18.55;	author carlton;	state Exp;
branches;
next	1.30.4.2;

1.30.4.2
date	2003.02.07.19.17.52;	author carlton;	state Exp;
branches;
next	1.30.4.3;

1.30.4.3
date	2003.03.06.00.56.31;	author carlton;	state Exp;
branches;
next	1.30.4.4;

1.30.4.4
date	2003.03.07.22.52.55;	author carlton;	state Exp;
branches;
next	1.30.4.5;

1.30.4.5
date	2003.05.23.18.40.45;	author carlton;	state Exp;
branches;
next	1.30.4.6;

1.30.4.6
date	2003.09.17.21.28.31;	author carlton;	state Exp;
branches;
next	1.30.4.7;

1.30.4.7
date	2003.11.11.23.50.54;	author carlton;	state Exp;
branches;
next	;

1.30.6.1
date	2003.12.14.20.27.30;	author drow;	state Exp;
branches;
next	1.30.6.2;

1.30.6.2
date	2004.02.09.19.43.48;	author drow;	state Exp;
branches;
next	;

1.29.8.1
date	2002.08.30.22.52.45;	author kseitz;	state Exp;
branches;
next	;

1.5.2.1
date	2000.04.19.07.24.09;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.18;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.42.54;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.09.58;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.31.01.06.01;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.09.08.23.59.30;	author shebs;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.11.09.01.23.07;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.11.17.02.30.28;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.12.22.21.45.10;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2000.01.06.03.06.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.103
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@/* Solaris threads debugging interface.

   Copyright (C) 1996-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This module implements a sort of half target that sits between the
   machine-independent parts of GDB and the /proc interface (procfs.c)
   to provide access to the Solaris user-mode thread implementation.

   Solaris threads are true user-mode threads, which are invoked via
   the thr_* and pthread_* (native and POSIX respectivly) interfaces.
   These are mostly implemented in user-space, with all thread context
   kept in various structures that live in the user's heap.  These
   should not be confused with lightweight processes (LWPs), which are
   implemented by the kernel, and scheduled without explicit
   intervention by the process.

   Just to confuse things a little, Solaris threads (both native and
   POSIX) are actually implemented using LWPs.  In general, there are
   going to be more threads than LWPs.  There is no fixed
   correspondence between a thread and an LWP.  When a thread wants to
   run, it gets scheduled onto the first available LWP and can
   therefore migrate from one LWP to another as time goes on.  A
   sleeping thread may not be associated with an LWP at all!

   To make it possible to mess with threads, Sun provides a library
   called libthread_db.so.1 (not to be confused with
   libthread_db.so.0, which doesn't have a published interface).  This
   interface has an upper part, which it provides, and a lower part
   which we provide.  The upper part consists of the td_* routines,
   which allow us to find all the threads, query their state, etc...
   The lower part consists of all of the ps_*, which are used by the
   td_* routines to read/write memory, manipulate LWPs, lookup
   symbols, etc...  The ps_* routines actually do most of their work
   by calling functions in procfs.c.  */

#include "defs.h"
#include <thread.h>
#include <proc_service.h>
#include <thread_db.h>
#include "gdbthread.h"
#include "target.h"
#include "inferior.h"
#include <fcntl.h>
#include "gdb_stat.h"
#include <dlfcn.h>
#include "gdbcmd.h"
#include "gdbcore.h"
#include "regcache.h"
#include "solib.h"
#include "symfile.h"
#include "observer.h"
#include "gdb_string.h"
#include "procfs.h"

struct target_ops sol_thread_ops;

/* Prototypes for supply_gregset etc.  */
#include "gregset.h"

/* This struct is defined by us, but mainly used for the proc_service
   interface.  We don't have much use for it, except as a handy place
   to get a real PID for memory accesses.  */

struct ps_prochandle
{
  ptid_t ptid;
};

struct string_map
{
  int num;
  char *str;
};

static struct ps_prochandle main_ph;
static td_thragent_t *main_ta;
static int sol_thread_active = 0;

static void init_sol_thread_ops (void);

/* Default definitions: These must be defined in tm.h if they are to
   be shared with a process module such as procfs.  */

/* Pointers to routines from libthread_db resolved by dlopen().  */

static void (*p_td_log)(const int on_off);
static td_err_e (*p_td_ta_new)(const struct ps_prochandle *ph_p,
			       td_thragent_t **ta_pp);
static td_err_e (*p_td_ta_delete)(td_thragent_t *ta_p);
static td_err_e (*p_td_init)(void);
static td_err_e (*p_td_ta_get_ph)(const td_thragent_t *ta_p,
				  struct ps_prochandle **ph_pp);
static td_err_e (*p_td_ta_get_nthreads)(const td_thragent_t *ta_p,
					int *nthread_p);
static td_err_e (*p_td_ta_tsd_iter)(const td_thragent_t *ta_p,
				    td_key_iter_f *cb, void *cbdata_p);
static td_err_e (*p_td_ta_thr_iter)(const td_thragent_t *ta_p,
				    td_thr_iter_f *cb, void *cbdata_p,
				    td_thr_state_e state, int ti_pri,
				    sigset_t *ti_sigmask_p,
				    unsigned ti_user_flags);
static td_err_e (*p_td_thr_validate)(const td_thrhandle_t *th_p);
static td_err_e (*p_td_thr_tsd)(const td_thrhandle_t * th_p,
				const thread_key_t key, void **data_pp);
static td_err_e (*p_td_thr_get_info)(const td_thrhandle_t *th_p,
				     td_thrinfo_t *ti_p);
static td_err_e (*p_td_thr_getfpregs)(const td_thrhandle_t *th_p,
				      prfpregset_t *fpregset);
static td_err_e (*p_td_thr_getxregsize)(const td_thrhandle_t *th_p,
					int *xregsize);
static td_err_e (*p_td_thr_getxregs)(const td_thrhandle_t *th_p,
				     const caddr_t xregset);
static td_err_e (*p_td_thr_sigsetmask)(const td_thrhandle_t *th_p,
				       const sigset_t ti_sigmask);
static td_err_e (*p_td_thr_setprio)(const td_thrhandle_t *th_p,
				    const int ti_pri);
static td_err_e (*p_td_thr_setsigpending)(const td_thrhandle_t *th_p,
					  const uchar_t ti_pending_flag,
					  const sigset_t ti_pending);
static td_err_e (*p_td_thr_setfpregs)(const td_thrhandle_t *th_p,
				      const prfpregset_t *fpregset);
static td_err_e (*p_td_thr_setxregs)(const td_thrhandle_t *th_p,
				     const caddr_t xregset);
static td_err_e (*p_td_ta_map_id2thr)(const td_thragent_t *ta_p,
				      thread_t tid,
				      td_thrhandle_t *th_p);
static td_err_e (*p_td_ta_map_lwp2thr)(const td_thragent_t *ta_p,
				       lwpid_t lwpid,
				       td_thrhandle_t *th_p);
static td_err_e (*p_td_thr_getgregs)(const td_thrhandle_t *th_p,
				     prgregset_t regset);
static td_err_e (*p_td_thr_setgregs)(const td_thrhandle_t *th_p,
				     const prgregset_t regset);


/* Return the libthread_db error string associated with ERRCODE.  If
   ERRCODE is unknown, return an appropriate message.  */

static char *
td_err_string (td_err_e errcode)
{
  static struct string_map td_err_table[] =
  {
    { TD_OK, "generic \"call succeeded\"" },
    { TD_ERR, "generic error." },
    { TD_NOTHR, "no thread can be found to satisfy query" },
    { TD_NOSV, "no synch. variable can be found to satisfy query" },
    { TD_NOLWP, "no lwp can be found to satisfy query" },
    { TD_BADPH, "invalid process handle" },
    { TD_BADTH, "invalid thread handle" },
    { TD_BADSH, "invalid synchronization handle" },
    { TD_BADTA, "invalid thread agent" },
    { TD_BADKEY, "invalid key" },
    { TD_NOMSG, "td_thr_event_getmsg() called when there was no message" },
    { TD_NOFPREGS, "FPU register set not available for given thread" },
    { TD_NOLIBTHREAD, "application not linked with libthread" },
    { TD_NOEVENT, "requested event is not supported" },
    { TD_NOCAPAB, "capability not available" },
    { TD_DBERR, "Debugger service failed" },
    { TD_NOAPLIC, "Operation not applicable to" },
    { TD_NOTSD, "No thread specific data for this thread" },
    { TD_MALLOC, "Malloc failed" },
    { TD_PARTIALREG, "Only part of register set was written/read" },
    { TD_NOXREGS, "X register set not available for given thread" }
  };
  const int td_err_size = sizeof td_err_table / sizeof (struct string_map);
  int i;
  static char buf[50];

  for (i = 0; i < td_err_size; i++)
    if (td_err_table[i].num == errcode)
      return td_err_table[i].str;

  xsnprintf (buf, sizeof (buf), "Unknown libthread_db error code: %d",
	     errcode);

  return buf;
}

/* Return the libthread_db state string assicoated with STATECODE.
   If STATECODE is unknown, return an appropriate message.  */

static char *
td_state_string (td_thr_state_e statecode)
{
  static struct string_map td_thr_state_table[] =
  {
    { TD_THR_ANY_STATE, "any state" },
    { TD_THR_UNKNOWN, "unknown" },
    { TD_THR_STOPPED, "stopped" },
    { TD_THR_RUN, "run" },
    { TD_THR_ACTIVE, "active" },
    { TD_THR_ZOMBIE, "zombie" },
    { TD_THR_SLEEP, "sleep" },
    { TD_THR_STOPPED_ASLEEP, "stopped asleep" }
  };
  const int td_thr_state_table_size =
    sizeof td_thr_state_table / sizeof (struct string_map);
  int i;
  static char buf[50];

  for (i = 0; i < td_thr_state_table_size; i++)
    if (td_thr_state_table[i].num == statecode)
      return td_thr_state_table[i].str;

  xsnprintf (buf, sizeof (buf), "Unknown libthread_db state code: %d",
	     statecode);

  return buf;
}


/* Convert a POSIX or Solaris thread ID into a LWP ID.  If THREAD_ID
   doesn't exist, that's an error.  If it's an inactive thread, return
   DEFAULT_LWP.

   NOTE: This function probably shouldn't call error().  */

static ptid_t
thread_to_lwp (ptid_t thread_id, int default_lwp)
{
  td_thrinfo_t ti;
  td_thrhandle_t th;
  td_err_e val;

  if (ptid_lwp_p (thread_id))
    return thread_id;		/* It's already an LWP ID.  */

  /* It's a thread.  Convert to LWP.  */

  val = p_td_ta_map_id2thr (main_ta, ptid_get_tid (thread_id), &th);
  if (val == TD_NOTHR)
    return pid_to_ptid (-1);	/* Thread must have terminated.  */
  else if (val != TD_OK)
    error (_("thread_to_lwp: td_ta_map_id2thr %s"), td_err_string (val));

  val = p_td_thr_get_info (&th, &ti);
  if (val == TD_NOTHR)
    return pid_to_ptid (-1);	/* Thread must have terminated.  */
  else if (val != TD_OK)
    error (_("thread_to_lwp: td_thr_get_info: %s"), td_err_string (val));

  if (ti.ti_state != TD_THR_ACTIVE)
    {
      if (default_lwp != -1)
	return pid_to_ptid (default_lwp);
      error (_("thread_to_lwp: thread state not active: %s"),
	     td_state_string (ti.ti_state));
    }

  return ptid_build (ptid_get_pid (thread_id), ti.ti_lid, 0);
}

/* Convert an LWP ID into a POSIX or Solaris thread ID.  If LWP_ID
   doesn't exists, that's an error.

   NOTE: This function probably shouldn't call error().  */

static ptid_t
lwp_to_thread (ptid_t lwp)
{
  td_thrinfo_t ti;
  td_thrhandle_t th;
  td_err_e val;

  if (ptid_tid_p (lwp))
    return lwp;			/* It's already a thread ID.  */

  /* It's an LWP.  Convert it to a thread ID.  */

  if (!target_thread_alive (lwp))
    return pid_to_ptid (-1);	/* Must be a defunct LPW.  */

  val = p_td_ta_map_lwp2thr (main_ta, ptid_get_lwp (lwp), &th);
  if (val == TD_NOTHR)
    return pid_to_ptid (-1);	/* Thread must have terminated.  */
  else if (val != TD_OK)
    error (_("lwp_to_thread: td_ta_map_lwp2thr: %s."), td_err_string (val));

  val = p_td_thr_validate (&th);
  if (val == TD_NOTHR)
    return lwp;			/* Unknown to libthread; just return LPW,  */
  else if (val != TD_OK)
    error (_("lwp_to_thread: td_thr_validate: %s."), td_err_string (val));

  val = p_td_thr_get_info (&th, &ti);
  if (val == TD_NOTHR)
    return pid_to_ptid (-1);	/* Thread must have terminated.  */
  else if (val != TD_OK)
    error (_("lwp_to_thread: td_thr_get_info: %s."), td_err_string (val));

  return ptid_build (ptid_get_pid (lwp), 0 , ti.ti_tid);
}


/* Most target vector functions from here on actually just pass
   through to the layer beneath, as they don't need to do anything
   specific for threads.  */

/* Take a program previously attached to and detaches it.  The program
   resumes execution and will no longer stop on signals, etc.  We'd
   better not have left any breakpoints in the program or it'll die
   when it hits one.  For this to work, it may be necessary for the
   process to have been previously attached.  It *might* work if the
   program was started via the normal ptrace (PTRACE_TRACEME).  */

static void
sol_thread_detach (struct target_ops *ops, char *args, int from_tty)
{
  struct target_ops *beneath = find_target_beneath (ops);

  sol_thread_active = 0;
  inferior_ptid = pid_to_ptid (ptid_get_pid (main_ph.ptid));
  unpush_target (ops);
  beneath->to_detach (beneath, args, from_tty);
}

/* Resume execution of process PTID.  If STEP is nozero, then just
   single step it.  If SIGNAL is nonzero, restart it with that signal
   activated.  We may have to convert PTID from a thread ID to an LWP
   ID for procfs.  */

static void
sol_thread_resume (struct target_ops *ops,
		   ptid_t ptid, int step, enum gdb_signal signo)
{
  struct cleanup *old_chain;
  struct target_ops *beneath = find_target_beneath (ops);

  old_chain = save_inferior_ptid ();

  inferior_ptid = thread_to_lwp (inferior_ptid, ptid_get_pid (main_ph.ptid));
  if (ptid_get_pid (inferior_ptid) == -1)
    inferior_ptid = procfs_first_available ();

  if (ptid_get_pid (ptid) != -1)
    {
      ptid_t save_ptid = ptid;

      ptid = thread_to_lwp (ptid, -2);
      if (ptid_get_pid (ptid) == -2)		/* Inactive thread.  */
	error (_("This version of Solaris can't start inactive threads."));
      if (info_verbose && ptid_get_pid (ptid) == -1)
	warning (_("Specified thread %ld seems to have terminated"),
		 ptid_get_tid (save_ptid));
    }

  beneath->to_resume (beneath, ptid, step, signo);

  do_cleanups (old_chain);
}

/* Wait for any threads to stop.  We may have to convert PTID from a
   thread ID to an LWP ID, and vice versa on the way out.  */

static ptid_t
sol_thread_wait (struct target_ops *ops,
		 ptid_t ptid, struct target_waitstatus *ourstatus, int options)
{
  ptid_t rtnval;
  ptid_t save_ptid;
  struct target_ops *beneath = find_target_beneath (ops);
  struct cleanup *old_chain;

  save_ptid = inferior_ptid;
  old_chain = save_inferior_ptid ();

  inferior_ptid = thread_to_lwp (inferior_ptid, ptid_get_pid (main_ph.ptid));
  if (ptid_get_pid (inferior_ptid) == -1)
    inferior_ptid = procfs_first_available ();

  if (ptid_get_pid (ptid) != -1)
    {
      ptid_t save_ptid = ptid;

      ptid = thread_to_lwp (ptid, -2);
      if (ptid_get_pid (ptid) == -2)		/* Inactive thread.  */
	error (_("This version of Solaris can't start inactive threads."));
      if (info_verbose && ptid_get_pid (ptid) == -1)
	warning (_("Specified thread %ld seems to have terminated"),
		 ptid_get_tid (save_ptid));
    }

  rtnval = beneath->to_wait (beneath, ptid, ourstatus, options);

  if (ourstatus->kind != TARGET_WAITKIND_EXITED)
    {
      /* Map the LWP of interest back to the appropriate thread ID.  */
      rtnval = lwp_to_thread (rtnval);
      if (ptid_get_pid (rtnval) == -1)
	rtnval = save_ptid;

      /* See if we have a new thread.  */
      if (ptid_tid_p (rtnval)
	  && !ptid_equal (rtnval, save_ptid)
	  && (!in_thread_list (rtnval)
	      || is_exited (rtnval)))
	add_thread (rtnval);
    }

  /* During process initialization, we may get here without the thread
     package being initialized, since that can only happen after we've
     found the shared libs.  */

  do_cleanups (old_chain);

  return rtnval;
}

static void
sol_thread_fetch_registers (struct target_ops *ops,
			    struct regcache *regcache, int regnum)
{
  thread_t thread;
  td_thrhandle_t thandle;
  td_err_e val;
  prgregset_t gregset;
  prfpregset_t fpregset;
  gdb_gregset_t *gregset_p = &gregset;
  gdb_fpregset_t *fpregset_p = &fpregset;
  struct target_ops *beneath = find_target_beneath (ops);

  if (!ptid_tid_p (inferior_ptid))
    {
      /* It's an LWP; pass the request on to the layer beneath.  */
      beneath->to_fetch_registers (beneath, regcache, regnum);
      return;
    }

  /* Solaris thread: convert INFERIOR_PTID into a td_thrhandle_t.  */
  thread = ptid_get_tid (inferior_ptid);
  if (thread == 0)
    error (_("sol_thread_fetch_registers: thread == 0"));

  val = p_td_ta_map_id2thr (main_ta, thread, &thandle);
  if (val != TD_OK)
    error (_("sol_thread_fetch_registers: td_ta_map_id2thr: %s"),
	   td_err_string (val));

  /* Get the general-purpose registers.  */

  val = p_td_thr_getgregs (&thandle, gregset);
  if (val != TD_OK && val != TD_PARTIALREG)
    error (_("sol_thread_fetch_registers: td_thr_getgregs %s"),
	   td_err_string (val));

  /* For SPARC, TD_PARTIALREG means that only %i0...%i7, %l0..%l7, %pc
     and %sp are saved (by a thread context switch).  */

  /* And, now the floating-point registers.  */

  val = p_td_thr_getfpregs (&thandle, &fpregset);
  if (val != TD_OK && val != TD_NOFPREGS)
    error (_("sol_thread_fetch_registers: td_thr_getfpregs %s"),
	   td_err_string (val));

  /* Note that we must call supply_gregset and supply_fpregset *after*
     calling the td routines because the td routines call ps_lget*
     which affect the values stored in the registers array.  */

  supply_gregset (regcache, (const gdb_gregset_t *) gregset_p);
  supply_fpregset (regcache, (const gdb_fpregset_t *) fpregset_p);
}

static void
sol_thread_store_registers (struct target_ops *ops,
			    struct regcache *regcache, int regnum)
{
  thread_t thread;
  td_thrhandle_t thandle;
  td_err_e val;
  prgregset_t gregset;
  prfpregset_t fpregset;

  if (!ptid_tid_p (inferior_ptid))
    {
      struct target_ops *beneath = find_target_beneath (ops);

      /* It's an LWP; pass the request on to the layer beneath.  */
      beneath->to_store_registers (beneath, regcache, regnum);
      return;
    }

  /* Solaris thread: convert INFERIOR_PTID into a td_thrhandle_t.  */
  thread = ptid_get_tid (inferior_ptid);

  val = p_td_ta_map_id2thr (main_ta, thread, &thandle);
  if (val != TD_OK)
    error (_("sol_thread_store_registers: td_ta_map_id2thr %s"),
	   td_err_string (val));

  if (regnum != -1)
    {
      /* Not writing all the registers.  */
      char old_value[MAX_REGISTER_SIZE];

      /* Save new register value.  */
      regcache_raw_collect (regcache, regnum, old_value);

      val = p_td_thr_getgregs (&thandle, gregset);
      if (val != TD_OK)
	error (_("sol_thread_store_registers: td_thr_getgregs %s"),
	       td_err_string (val));
      val = p_td_thr_getfpregs (&thandle, &fpregset);
      if (val != TD_OK)
	error (_("sol_thread_store_registers: td_thr_getfpregs %s"),
	       td_err_string (val));

      /* Restore new register value.  */
      regcache_raw_supply (regcache, regnum, old_value);
    }

  fill_gregset (regcache, (gdb_gregset_t *) &gregset, regnum);
  fill_fpregset (regcache, (gdb_fpregset_t *) &fpregset, regnum);

  val = p_td_thr_setgregs (&thandle, gregset);
  if (val != TD_OK)
    error (_("sol_thread_store_registers: td_thr_setgregs %s"),
	   td_err_string (val));
  val = p_td_thr_setfpregs (&thandle, &fpregset);
  if (val != TD_OK)
    error (_("sol_thread_store_registers: td_thr_setfpregs %s"),
	   td_err_string (val));
}

/* Perform partial transfers on OBJECT.  See target_read_partial and
   target_write_partial for details of each variant.  One, and only
   one, of readbuf or writebuf must be non-NULL.  */

static LONGEST
sol_thread_xfer_partial (struct target_ops *ops, enum target_object object,
			  const char *annex, gdb_byte *readbuf,
			  const gdb_byte *writebuf,
			 ULONGEST offset, LONGEST len)
{
  int retval;
  struct cleanup *old_chain;
  struct target_ops *beneath = find_target_beneath (ops);

  old_chain = save_inferior_ptid ();

  if (ptid_tid_p (inferior_ptid) || !target_thread_alive (inferior_ptid))
    {
      /* It's either a thread or an LWP that isn't alive.  Any live
         LWP will do so use the first available.

	 NOTE: We don't need to call switch_to_thread; we're just
	 reading memory.  */
      inferior_ptid = procfs_first_available ();
    }

  retval = beneath->to_xfer_partial (beneath, object, annex,
				     readbuf, writebuf, offset, len);

  do_cleanups (old_chain);

  return retval;
}

static void
check_for_thread_db (void)
{
  td_err_e err;
  ptid_t ptid;

  /* Do nothing if we couldn't load libthread_db.so.1.  */
  if (p_td_ta_new == NULL)
    return;

  if (sol_thread_active)
    /* Nothing to do.  The thread library was already detected and the
       target vector was already activated.  */
    return;

  /* Now, initialize libthread_db.  This needs to be done after the
     shared libraries are located because it needs information from
     the user's thread library.  */

  err = p_td_init ();
  if (err != TD_OK)
    {
      warning (_("sol_thread_new_objfile: td_init: %s"), td_err_string (err));
      return;
    }

  /* Now attempt to open a connection to the thread library.  */
  err = p_td_ta_new (&main_ph, &main_ta);
  switch (err)
    {
    case TD_NOLIBTHREAD:
      /* No thread library was detected.  */
      break;

    case TD_OK:
      printf_unfiltered (_("[Thread debugging using libthread_db enabled]\n"));

      /* The thread library was detected.  Activate the sol_thread target.  */
      push_target (&sol_thread_ops);
      sol_thread_active = 1;

      main_ph.ptid = inferior_ptid; /* Save for xfer_memory.  */
      ptid = lwp_to_thread (inferior_ptid);
      if (ptid_get_pid (ptid) != -1)
	inferior_ptid = ptid;

      target_find_new_threads ();
      break;

    default:
      warning (_("Cannot initialize thread debugging library: %s"),
	       td_err_string (err));
      break;
    }
}

/* This routine is called whenever a new symbol table is read in, or
   when all symbol tables are removed.  libthread_db can only be
   initialized when it finds the right variables in libthread.so.
   Since it's a shared library, those variables don't show up until
   the library gets mapped and the symbol table is read in.  */

static void
sol_thread_new_objfile (struct objfile *objfile)
{
  if (objfile != NULL)
    check_for_thread_db ();
}

/* Clean up after the inferior dies.  */

static void
sol_thread_mourn_inferior (struct target_ops *ops)
{
  struct target_ops *beneath = find_target_beneath (ops);

  sol_thread_active = 0;

  unpush_target (ops);

  beneath->to_mourn_inferior (beneath);
}

/* Return true if PTID is still active in the inferior.  */

static int
sol_thread_alive (struct target_ops *ops, ptid_t ptid)
{
  if (ptid_tid_p (ptid))
    {
      /* It's a (user-level) thread.  */
      td_err_e val;
      td_thrhandle_t th;
      int pid;

      pid = ptid_get_tid (ptid);
      if ((val = p_td_ta_map_id2thr (main_ta, pid, &th)) != TD_OK)
	return 0;		/* Thread not found.  */
      if ((val = p_td_thr_validate (&th)) != TD_OK)
	return 0;		/* Thread not valid.  */
      return 1;			/* Known thread.  */
    }
  else
    {
      struct target_ops *beneath = find_target_beneath (ops);

      /* It's an LPW; pass the request on to the layer below.  */
      return beneath->to_thread_alive (beneath, ptid);
    }
}


/* These routines implement the lower half of the thread_db interface,
   i.e. the ps_* routines.  */

/* Various versions of <proc_service.h> have slightly different
   function prototypes.  In particular, we have

   NEWER                        OLDER
   struct ps_prochandle *       const struct ps_prochandle *
   void*                        char*
   const void*          	char*
   int                  	size_t

   Which one you have depends on the Solaris version and what patches
   you've applied.  On the theory that there are only two major
   variants, we have configure check the prototype of ps_pdwrite (),
   and use that info to make appropriate typedefs here.  */

#ifdef PROC_SERVICE_IS_OLD
typedef const struct ps_prochandle *gdb_ps_prochandle_t;
typedef char *gdb_ps_read_buf_t;
typedef char *gdb_ps_write_buf_t;
typedef int gdb_ps_size_t;
typedef psaddr_t gdb_ps_addr_t;
#else
typedef struct ps_prochandle *gdb_ps_prochandle_t;
typedef void *gdb_ps_read_buf_t;
typedef const void *gdb_ps_write_buf_t;
typedef size_t gdb_ps_size_t;
typedef psaddr_t gdb_ps_addr_t;
#endif

/* The next four routines are called by libthread_db to tell us to
   stop and stop a particular process or lwp.  Since GDB ensures that
   these are all stopped by the time we call anything in thread_db,
   these routines need to do nothing.  */

/* Process stop.  */

ps_err_e
ps_pstop (gdb_ps_prochandle_t ph)
{
  return PS_OK;
}

/* Process continue.  */

ps_err_e
ps_pcontinue (gdb_ps_prochandle_t ph)
{
  return PS_OK;
}

/* LWP stop.  */

ps_err_e
ps_lstop (gdb_ps_prochandle_t ph, lwpid_t lwpid)
{
  return PS_OK;
}

/* LWP continue.  */

ps_err_e
ps_lcontinue (gdb_ps_prochandle_t ph, lwpid_t lwpid)
{
  return PS_OK;
}

/* Looks up the symbol LD_SYMBOL_NAME in the debugger's symbol table.  */

ps_err_e
ps_pglobal_lookup (gdb_ps_prochandle_t ph, const char *ld_object_name,
		   const char *ld_symbol_name, gdb_ps_addr_t *ld_symbol_addr)
{
  struct minimal_symbol *ms;

  ms = lookup_minimal_symbol (ld_symbol_name, NULL, NULL);
  if (!ms)
    return PS_NOSYM;

  *ld_symbol_addr = SYMBOL_VALUE_ADDRESS (ms);
  return PS_OK;
}

/* Common routine for reading and writing memory.  */

static ps_err_e
rw_common (int dowrite, const struct ps_prochandle *ph, gdb_ps_addr_t addr,
	   gdb_byte *buf, int size)
{
  int ret;
  struct cleanup *old_chain;

  old_chain = save_inferior_ptid ();

  if (ptid_tid_p (inferior_ptid) || !target_thread_alive (inferior_ptid))
    {
      /* It's either a thread or an LWP that isn't alive.  Any live
         LWP will do so use the first available.

	 NOTE: We don't need to call switch_to_thread; we're just
	 reading memory.  */
      inferior_ptid = procfs_first_available ();
    }

#if defined (__sparcv9)
  /* For Sparc64 cross Sparc32, make sure the address has not been
     accidentally sign-extended (or whatever) to beyond 32 bits.  */
  if (bfd_get_arch_size (exec_bfd) == 32)
    addr &= 0xffffffff;
#endif

  if (dowrite)
    ret = target_write_memory (addr, (gdb_byte *) buf, size);
  else
    ret = target_read_memory (addr, (gdb_byte *) buf, size);

  do_cleanups (old_chain);

  return (ret == 0 ? PS_OK : PS_ERR);
}

/* Copies SIZE bytes from target process .data segment to debugger memory.  */

ps_err_e
ps_pdread (gdb_ps_prochandle_t ph, gdb_ps_addr_t addr,
	   gdb_ps_read_buf_t buf, gdb_ps_size_t size)
{
  return rw_common (0, ph, addr, buf, size);
}

/* Copies SIZE bytes from debugger memory .data segment to target process.  */

ps_err_e
ps_pdwrite (gdb_ps_prochandle_t ph, gdb_ps_addr_t addr,
	    gdb_ps_write_buf_t buf, gdb_ps_size_t size)
{
  return rw_common (1, ph, addr, (gdb_byte *) buf, size);
}

/* Copies SIZE bytes from target process .text segment to debugger memory.  */

ps_err_e
ps_ptread (gdb_ps_prochandle_t ph, gdb_ps_addr_t addr,
	   gdb_ps_read_buf_t buf, gdb_ps_size_t size)
{
  return rw_common (0, ph, addr, buf, size);
}

/* Copies SIZE bytes from debugger memory .text segment to target process.  */

ps_err_e
ps_ptwrite (gdb_ps_prochandle_t ph, gdb_ps_addr_t addr,
	    gdb_ps_write_buf_t buf, gdb_ps_size_t size)
{
  return rw_common (1, ph, addr, (gdb_byte *) buf, size);
}

/* Get general-purpose registers for LWP.  */

ps_err_e
ps_lgetregs (gdb_ps_prochandle_t ph, lwpid_t lwpid, prgregset_t gregset)
{
  struct cleanup *old_chain;
  struct regcache *regcache;

  old_chain = save_inferior_ptid ();

  inferior_ptid = ptid_build (ptid_get_pid (inferior_ptid), lwpid, 0);
  regcache = get_thread_arch_regcache (inferior_ptid, target_gdbarch ());

  target_fetch_registers (regcache, -1);
  fill_gregset (regcache, (gdb_gregset_t *) gregset, -1);

  do_cleanups (old_chain);

  return PS_OK;
}

/* Set general-purpose registers for LWP.  */

ps_err_e
ps_lsetregs (gdb_ps_prochandle_t ph, lwpid_t lwpid,
	     const prgregset_t gregset)
{
  struct cleanup *old_chain;
  struct regcache *regcache;

  old_chain = save_inferior_ptid ();

  inferior_ptid = ptid_build (ptid_get_pid (inferior_ptid), lwpid, 0);
  regcache = get_thread_arch_regcache (inferior_ptid, target_gdbarch ());

  supply_gregset (regcache, (const gdb_gregset_t *) gregset);
  target_store_registers (regcache, -1);

  do_cleanups (old_chain);

  return PS_OK;
}

/* Log a message (sends to gdb_stderr).  */

void
ps_plog (const char *fmt, ...)
{
  va_list args;

  va_start (args, fmt);

  vfprintf_filtered (gdb_stderr, fmt, args);
}

/* Get size of extra register set.  Currently a noop.  */

ps_err_e
ps_lgetxregsize (gdb_ps_prochandle_t ph, lwpid_t lwpid, int *xregsize)
{
  return PS_OK;
}

/* Get extra register set.  Currently a noop.  */

ps_err_e
ps_lgetxregs (gdb_ps_prochandle_t ph, lwpid_t lwpid, caddr_t xregset)
{
  return PS_OK;
}

/* Set extra register set.  Currently a noop.  */

ps_err_e
ps_lsetxregs (gdb_ps_prochandle_t ph, lwpid_t lwpid, caddr_t xregset)
{
  return PS_OK;
}

/* Get floating-point registers for LWP.  */

ps_err_e
ps_lgetfpregs (gdb_ps_prochandle_t ph, lwpid_t lwpid,
	       prfpregset_t *fpregset)
{
  struct cleanup *old_chain;
  struct regcache *regcache;

  old_chain = save_inferior_ptid ();

  inferior_ptid = ptid_build (ptid_get_pid (inferior_ptid), lwpid, 0);
  regcache = get_thread_arch_regcache (inferior_ptid, target_gdbarch ());

  target_fetch_registers (regcache, -1);
  fill_fpregset (regcache, (gdb_fpregset_t *) fpregset, -1);

  do_cleanups (old_chain);

  return PS_OK;
}

/* Set floating-point regs for LWP.  */

ps_err_e
ps_lsetfpregs (gdb_ps_prochandle_t ph, lwpid_t lwpid,
	       const prfpregset_t * fpregset)
{
  struct cleanup *old_chain;
  struct regcache *regcache;

  old_chain = save_inferior_ptid ();

  inferior_ptid = ptid_build (ptid_get_pid (inferior_ptid), lwpid, 0);
  regcache = get_thread_arch_regcache (inferior_ptid, target_gdbarch ());

  supply_fpregset (regcache, (const gdb_fpregset_t *) fpregset);
  target_store_registers (regcache, -1);

  do_cleanups (old_chain);

  return PS_OK;
}

#ifdef PR_MODEL_LP64
/* Identify process as 32-bit or 64-bit.  At the moment we're using
   BFD to do this.  There might be a more Solaris-specific
   (e.g. procfs) method, but this ought to work.  */

ps_err_e
ps_pdmodel (gdb_ps_prochandle_t ph, int *data_model)
{
  if (exec_bfd == 0)
    *data_model = PR_MODEL_UNKNOWN;
  else if (bfd_get_arch_size (exec_bfd) == 32)
    *data_model = PR_MODEL_ILP32;
  else
    *data_model = PR_MODEL_LP64;

  return PS_OK;
}
#endif /* PR_MODEL_LP64 */

#if (defined(__i386__) || defined(__x86_64__)) && defined (sun)

/* Reads the local descriptor table of a LWP.

   This function is necessary on x86-solaris only.  Without it, the loading
   of libthread_db would fail because of ps_lgetLDT being undefined.  */

ps_err_e
ps_lgetLDT (gdb_ps_prochandle_t ph, lwpid_t lwpid,
	    struct ssd *pldt)
{
  /* NOTE: only used on Solaris, therefore OK to refer to procfs.c.  */
  struct ssd *ret;

  /* FIXME: can't I get the process ID from the prochandle or
     something?  */

  if (ptid_get_pid (inferior_ptid) <= 0 || lwpid <= 0)
    return PS_BADLID;

  ret = procfs_find_LDT_entry (ptid_build (ptid_get_pid (inferior_ptid),
			       lwpid, 0));
  if (ret)
    {
      memcpy (pldt, ret, sizeof (struct ssd));
      return PS_OK;
    }
  else
    /* LDT not found.  */
    return PS_ERR;
}
#endif


/* Convert PTID to printable form.  */

static char *
solaris_pid_to_str (struct target_ops *ops, ptid_t ptid)
{
  static char buf[100];

  if (ptid_tid_p (ptid))
    {
      ptid_t lwp;

      lwp = thread_to_lwp (ptid, -2);

      if (ptid_get_pid (lwp) == -1)
	xsnprintf (buf, sizeof (buf), "Thread %ld (defunct)",
		   ptid_get_tid (ptid));
      else if (ptid_get_pid (lwp) != -2)
	xsnprintf (buf, sizeof (buf), "Thread %ld (LWP %ld)",
		 ptid_get_tid (ptid), ptid_get_lwp (lwp));
      else
	xsnprintf (buf, sizeof (buf), "Thread %ld        ",
		   ptid_get_tid (ptid));
    }
  else if (ptid_get_lwp (ptid) != 0)
    xsnprintf (buf, sizeof (buf), "LWP    %ld        ", ptid_get_lwp (ptid));
  else
    xsnprintf (buf, sizeof (buf), "process %d    ", ptid_get_pid (ptid));

  return buf;
}


/* Worker bee for find_new_threads.  Callback function that gets
   called once per user-level thread (i.e. not for LWP's).  */

static int
sol_find_new_threads_callback (const td_thrhandle_t *th, void *ignored)
{
  td_err_e retval;
  td_thrinfo_t ti;
  ptid_t ptid;

  retval = p_td_thr_get_info (th, &ti);
  if (retval != TD_OK)
    return -1;

  ptid = ptid_build (ptid_get_pid (inferior_ptid), 0, ti.ti_tid);
  if (!in_thread_list (ptid) || is_exited (ptid))
    add_thread (ptid);

  return 0;
}

static void
sol_find_new_threads (struct target_ops *ops)
{
  struct target_ops *beneath = find_target_beneath (ops);

  /* First Find any new LWP's.  */
  if (beneath->to_find_new_threads != NULL)
    beneath->to_find_new_threads (beneath);

  /* Then find any new user-level threads.  */
  p_td_ta_thr_iter (main_ta, sol_find_new_threads_callback, (void *) 0,
		    TD_THR_ANY_STATE, TD_THR_LOWEST_PRIORITY,
		    TD_SIGNO_MASK, TD_THR_ANY_USER_FLAGS);
}

/* Worker bee for the "info sol-thread" command.  This is a callback
   function that gets called once for each Solaris user-level thread
   (i.e. not for LWPs) in the inferior.  Print anything interesting
   that we can think of.  */

static int
info_cb (const td_thrhandle_t *th, void *s)
{
  td_err_e ret;
  td_thrinfo_t ti;

  ret = p_td_thr_get_info (th, &ti);
  if (ret == TD_OK)
    {
      printf_filtered ("%s thread #%d, lwp %d, ",
		       ti.ti_type == TD_THR_SYSTEM ? "system" : "user  ",
		       ti.ti_tid, ti.ti_lid);
      switch (ti.ti_state)
	{
	default:
	case TD_THR_UNKNOWN:
	  printf_filtered ("<unknown state>");
	  break;
	case TD_THR_STOPPED:
	  printf_filtered ("(stopped)");
	  break;
	case TD_THR_RUN:
	  printf_filtered ("(run)    ");
	  break;
	case TD_THR_ACTIVE:
	  printf_filtered ("(active) ");
	  break;
	case TD_THR_ZOMBIE:
	  printf_filtered ("(zombie) ");
	  break;
	case TD_THR_SLEEP:
	  printf_filtered ("(asleep) ");
	  break;
	case TD_THR_STOPPED_ASLEEP:
	  printf_filtered ("(stopped asleep)");
	  break;
	}
      /* Print thr_create start function.  */
      if (ti.ti_startfunc != 0)
	{
	  const struct bound_minimal_symbol msym
	    = lookup_minimal_symbol_by_pc (ti.ti_startfunc);

	  printf_filtered ("   startfunc=%s",
			   msym.minsym
			   ? SYMBOL_PRINT_NAME (msym.minsym)
			   : paddress (target_gdbarch (), ti.ti_startfunc));
	}

      /* If thread is asleep, print function that went to sleep.  */
      if (ti.ti_state == TD_THR_SLEEP)
	{
	  const struct bound_minimal_symbol msym
	    = lookup_minimal_symbol_by_pc (ti.ti_pc);

	  printf_filtered ("   sleepfunc=%s",
			   msym.minsym
			   ? SYMBOL_PRINT_NAME (msym.minsym)
			   : paddress (target_gdbarch (), ti.ti_pc));
	}

      printf_filtered ("\n");
    }
  else
    warning (_("info sol-thread: failed to get info for thread."));

  return 0;
}

/* List some state about each Solaris user-level thread in the
   inferior.  */

static void
info_solthreads (char *args, int from_tty)
{
  p_td_ta_thr_iter (main_ta, info_cb, args,
		    TD_THR_ANY_STATE, TD_THR_LOWEST_PRIORITY,
		    TD_SIGNO_MASK, TD_THR_ANY_USER_FLAGS);
}

/* Callback routine used to find a thread based on the TID part of
   its PTID.  */

static int
thread_db_find_thread_from_tid (struct thread_info *thread, void *data)
{
  long *tid = (long *) data;

  if (ptid_get_tid (thread->ptid) == *tid)
    return 1;

  return 0;
}

static ptid_t
sol_get_ada_task_ptid (long lwp, long thread)
{
  struct thread_info *thread_info =
    iterate_over_threads (thread_db_find_thread_from_tid, &thread);

  if (thread_info == NULL)
    {
      /* The list of threads is probably not up to date.  Find any
         thread that is missing from the list, and try again.  */
      sol_find_new_threads (&current_target);
      thread_info = iterate_over_threads (thread_db_find_thread_from_tid,
                                          &thread);
    }

  gdb_assert (thread_info != NULL);

  return (thread_info->ptid);
}

static void
init_sol_thread_ops (void)
{
  sol_thread_ops.to_shortname = "solaris-threads";
  sol_thread_ops.to_longname = "Solaris threads and pthread.";
  sol_thread_ops.to_doc = "Solaris threads and pthread support.";
  sol_thread_ops.to_detach = sol_thread_detach;
  sol_thread_ops.to_resume = sol_thread_resume;
  sol_thread_ops.to_wait = sol_thread_wait;
  sol_thread_ops.to_fetch_registers = sol_thread_fetch_registers;
  sol_thread_ops.to_store_registers = sol_thread_store_registers;
  sol_thread_ops.to_xfer_partial = sol_thread_xfer_partial;
  sol_thread_ops.to_mourn_inferior = sol_thread_mourn_inferior;
  sol_thread_ops.to_thread_alive = sol_thread_alive;
  sol_thread_ops.to_pid_to_str = solaris_pid_to_str;
  sol_thread_ops.to_find_new_threads = sol_find_new_threads;
  sol_thread_ops.to_stratum = thread_stratum;
  sol_thread_ops.to_get_ada_task_ptid = sol_get_ada_task_ptid;
  sol_thread_ops.to_magic = OPS_MAGIC;
}

/* Silence -Wmissing-prototypes.  */
extern void _initialize_sol_thread (void);

void
_initialize_sol_thread (void)
{
  void *dlhandle;

  init_sol_thread_ops ();

  dlhandle = dlopen ("libthread_db.so.1", RTLD_NOW);
  if (!dlhandle)
    goto die;

#define resolve(X) \
  if (!(p_##X = dlsym (dlhandle, #X))) \
    goto die;

  resolve (td_log);
  resolve (td_ta_new);
  resolve (td_ta_delete);
  resolve (td_init);
  resolve (td_ta_get_ph);
  resolve (td_ta_get_nthreads);
  resolve (td_ta_tsd_iter);
  resolve (td_ta_thr_iter);
  resolve (td_thr_validate);
  resolve (td_thr_tsd);
  resolve (td_thr_get_info);
  resolve (td_thr_getfpregs);
  resolve (td_thr_getxregsize);
  resolve (td_thr_getxregs);
  resolve (td_thr_sigsetmask);
  resolve (td_thr_setprio);
  resolve (td_thr_setsigpending);
  resolve (td_thr_setfpregs);
  resolve (td_thr_setxregs);
  resolve (td_ta_map_id2thr);
  resolve (td_ta_map_lwp2thr);
  resolve (td_thr_getgregs);
  resolve (td_thr_setgregs);

  complete_target_initialization (&sol_thread_ops);

  add_cmd ("sol-threads", class_maintenance, info_solthreads,
	   _("Show info on Solaris user threads."), &maintenanceinfolist);

  /* Hook into new_objfile notification.  */
  observer_attach_new_objfile (sol_thread_new_objfile);
  return;

 die:
  fprintf_unfiltered (gdb_stderr, "\
[GDB will not be able to debug user-mode threads: %s]\n", dlerror ());

  if (dlhandle)
    dlclose (dlhandle);

  return;
}
@


1.102
log
@more add_target removals

This removes a few more erroneous calls to add_target.  These calls
end up installing the target in a user-visible way; but these targets
are all auto-activated and, I think, should never be explicitly
requested.

I have no way to test these.

	* aix-thread.c (_initialize_aix_thread): Use
	complete_target_initialization.
	* bsd-uthread.c (_initialize_bsd_uthread): Use
	complete_target_initialization.
	* dec-thread.c (_initialize_dec_thread): Use
	complete_target_initialization.
	* ravenscar-thread.c (_initialize_ravenscar): Use
	complete_target_initialization.
	* sol-thread.c (_initialize_sol_thread): Use
	complete_target_initialization.
	* spu-multiarch.c (_initialize_spu_multiarch): Use
	complete_target_initialization.
@
text
@a98 10
#define GET_PID(ptid)		ptid_get_pid (ptid)
#define GET_LWP(ptid)		ptid_get_lwp (ptid)
#define GET_THREAD(ptid)	ptid_get_tid (ptid)

#define is_lwp(ptid)		(GET_LWP (ptid) != 0)
#define is_thread(ptid)		(GET_THREAD (ptid) != 0)

#define BUILD_LWP(lwp, pid)	ptid_build (pid, lwp, 0)
#define BUILD_THREAD(tid, pid)	ptid_build (pid, 0, tid)

d241 1
a241 1
  if (is_lwp (thread_id))
d246 1
a246 1
  val = p_td_ta_map_id2thr (main_ta, GET_THREAD (thread_id), &th);
d266 1
a266 1
  return BUILD_LWP (ti.ti_lid, PIDGET (thread_id));
d281 1
a281 1
  if (is_thread (lwp))
d289 1
a289 1
  val = p_td_ta_map_lwp2thr (main_ta, GET_LWP (lwp), &th);
d307 1
a307 1
  return BUILD_THREAD (ti.ti_tid, PIDGET (lwp));
d328 1
a328 1
  inferior_ptid = pid_to_ptid (PIDGET (main_ph.ptid));
d347 2
a348 2
  inferior_ptid = thread_to_lwp (inferior_ptid, PIDGET (main_ph.ptid));
  if (PIDGET (inferior_ptid) == -1)
d351 1
a351 1
  if (PIDGET (ptid) != -1)
d356 1
a356 1
      if (PIDGET (ptid) == -2)		/* Inactive thread.  */
d358 1
a358 1
      if (info_verbose && PIDGET (ptid) == -1)
d360 1
a360 1
		 GET_THREAD (save_ptid));
d383 2
a384 2
  inferior_ptid = thread_to_lwp (inferior_ptid, PIDGET (main_ph.ptid));
  if (PIDGET (inferior_ptid) == -1)
d387 1
a387 1
  if (PIDGET (ptid) != -1)
d392 1
a392 1
      if (PIDGET (ptid) == -2)		/* Inactive thread.  */
d394 1
a394 1
      if (info_verbose && PIDGET (ptid) == -1)
d396 1
a396 1
		 GET_THREAD (save_ptid));
d405 1
a405 1
      if (PIDGET (rtnval) == -1)
d409 1
a409 1
      if (is_thread (rtnval)
d438 1
a438 1
  if (!is_thread (inferior_ptid))
d446 1
a446 1
  thread = GET_THREAD (inferior_ptid);
d490 1
a490 1
  if (!is_thread (inferior_ptid))
d500 1
a500 1
  thread = GET_THREAD (inferior_ptid);
d557 1
a557 1
  if (is_thread (inferior_ptid) || !target_thread_alive (inferior_ptid))
d618 1
a618 1
      if (PIDGET (ptid) != -1)
d663 1
a663 1
  if (is_thread (ptid))
d670 1
a670 1
      pid = GET_THREAD (ptid);
d782 1
a782 1
  if (is_thread (inferior_ptid) || !target_thread_alive (inferior_ptid))
d855 1
a855 1
  inferior_ptid = BUILD_LWP (lwpid, PIDGET (inferior_ptid));
d877 1
a877 1
  inferior_ptid = BUILD_LWP (lwpid, PIDGET (inferior_ptid));
d935 1
a935 1
  inferior_ptid = BUILD_LWP (lwpid, PIDGET (inferior_ptid));
d957 1
a957 1
  inferior_ptid = BUILD_LWP (lwpid, PIDGET (inferior_ptid));
d1004 1
a1004 1
  if (PIDGET (inferior_ptid) <= 0 || lwpid <= 0)
d1007 2
a1008 1
  ret = procfs_find_LDT_entry (BUILD_LWP (lwpid, PIDGET (inferior_ptid)));
d1028 1
a1028 1
  if (is_thread (ptid))
d1034 1
a1034 1
      if (PIDGET (lwp) == -1)
d1036 2
a1037 2
		   GET_THREAD (ptid));
      else if (PIDGET (lwp) != -2)
d1039 1
a1039 1
		 GET_THREAD (ptid), GET_LWP (lwp));
d1041 2
a1042 1
	xsnprintf (buf, sizeof (buf), "Thread %ld        ", GET_THREAD (ptid));
d1044 2
a1045 2
  else if (GET_LWP (ptid) != 0)
    xsnprintf (buf, sizeof (buf), "LWP    %ld        ", GET_LWP (ptid));
d1047 1
a1047 1
    xsnprintf (buf, sizeof (buf), "process %d    ", PIDGET (ptid));
d1067 1
a1067 1
  ptid = BUILD_THREAD (ti.ti_tid, PIDGET (inferior_ptid));
@


1.101
log
@move sparc-sol-thread.c back into sol-thread.c.

The routines in sparc-sol-thread used to be SPARC-specific (and
documented as such in the ptrace man page), and therefore hosting them
in a sparc-specific file made sense.  However, newer versions of
Solaris now use those callbacks (Solaris 10 Update 10, apparently),
and thus the note about these callbacks being specific to SPARC
was removed.

So this patch deletes sparc-sol-thread.c and moves the code back
inside sol-thread.c.

gdb/ChangeLog:

        PR tdep/15420:
        * sol-thread.c (ps_lgetxregsize, ps_lgetxregs, ps_lsetxregs):
        New functions, directly copied from sparc-sol-thread.c.
        * sparc-sol-thread.c: Delete.
        * configure.ac: Remove code handling sparc-solaris-thread.c.
        * configure: Regenerate.
@
text
@d1279 1
a1279 1
  add_target (&sol_thread_ops);
@


1.100
log
@Avoid duplicating text in sol-thread.c:info_cb

This is a minor cleanup that helps avoiding duplicating the output
of a command when handling alternative situations.

gdb/ChangeLog:

        * sol-thread.c (info_cb): Factorize the code a little.
@
text
@d910 24
@


1.99
log
@Improve output of "maintenance info sol-threads" command.

This patch does the following:
  - Puts the startfunc and "Sleep func" info on the same line;
  - Renames "Sleep func" into "sleepfunc" to be consistent with
    "startfunc"
  - Avoids the use of a '-' as a separate before the "sleepfunc"
    output, because the '-' looks odd and out of place when the
    "startfunc" field is not printed (ti.ti_startfunc is nul).
  - Use a '=' instead of ':' and avoids the space between
    the name of the value and its value, mostly to help group
    the value with its name.

For the record, this is how the new outout now looks like:

    (gdb) maintenance info sol-threads
    user   thread #1, lwp 1, (active)
    system thread #2, lwp 2, (active)
    system thread #3, lwp 0, (asleep)    sleepfunc=0xff32d9e0
    user   thread #4, lwp 4, (asleep)    startfunc=[...].task_wrapper   sleepfunc=0xff3290f0
    system thread #5, lwp 7, (active)    startfunc=_co_timerset
    user   thread #6, lwp 8, (active)    startfunc=[...].task_wrapper

gdb/ChangeLog:

        * sol-thread.c (info_cb): Rework the output of the "maintenance
        info sol-threads" command a bit.
@
text
@d1121 4
a1124 6
	  if (msym.minsym)
	    printf_filtered ("   startfunc=%s",
			     SYMBOL_PRINT_NAME (msym.minsym));
	  else
	    printf_filtered ("   startfunc=%s",
			     paddress (target_gdbarch (), ti.ti_startfunc));
d1133 4
a1136 6
	  if (msym.minsym)
	    printf_filtered ("   sleepfunc=%s",
			     SYMBOL_PRINT_NAME (msym.minsym));
	  else
	    printf_filtered ("   sleepfunc=%s",
			     paddress (target_gdbarch (), ti.ti_pc));
@


1.98
log
@ti.ti_pc vs ti.ti_startfunc copy-pasto in sol-thread.c:info_cb

gdb/ChangeLog:

        * sol-thread.c (info_cb) [ti.ti_state == TD_THR_SLEEP]:
        Replace ti.ti_startfunc by ti.ti_pc.

Probably OK to commit without approval, so will likely do so in the
next few days.
@
text
@d1122 1
a1122 1
	    printf_filtered ("   startfunc: %s\n",
d1125 1
a1125 1
	    printf_filtered ("   startfunc: %s\n",
d1136 1
a1136 1
	    printf_filtered (" - Sleep func: %s\n",
d1139 1
a1139 1
	    printf_filtered (" - Sleep func: %s\n",
d1143 1
a1143 3
      /* Wrap up line, if necessary.  */
      if (ti.ti_state != TD_THR_SLEEP && ti.ti_startfunc == 0)
	printf_filtered ("\n");	/* don't you hate counting newlines?  */
@


1.97
log
@Fix -Wpointer-sign warning in sol-thread.c

gdb/ChangeLog:

        * sol-thread.c (rw_common): Cast BUF to "gdb_byte *" in calls
        to target_write_memory and target_read_memory.
@
text
@d1140 1
a1140 1
			     paddress (target_gdbarch (), ti.ti_startfunc));
@


1.96
log
@Fix -Wpointer-sign warning in sol-thread.c

This fixes a couple of compiler warnings in rw_common when calling
target_read_memory/target_write_memory due to the type of parameter
"buf" (char *) not matching what these function expect (gdb_byte *).

gdb/ChangeLog:

        * sol-thread.c (rw_common): Change type of parameter "buf"
        to "gdb_byte *".
        (ps_pdwrite, ps_ptwrite): Cast parameter "buf" in call to
        rw_common to "gdb_byte *" instead of "char *".
@
text
@d810 1
a810 1
    ret = target_write_memory (addr, buf, size);
d812 1
a812 1
    ret = target_read_memory (addr, buf, size);
@


1.95
log
@Fix build error in sol-thread.c:info_cb

gdb/ChangeLog:

        * sol-thread.c (info_cb) [ti.ti_startfunc != 0]: Change type
        of local variable msym to const struct bound_minimal_symbol.
        Adjust use accordingly.
        [ti.ti_state == TD_THR_SLEEP]: Likewise.
@
text
@d785 1
a785 1
	   char *buf, int size)
d834 1
a834 1
  return rw_common (1, ph, addr, (char *) buf, size);
d852 1
a852 1
  return rw_common (1, ph, addr, (char *) buf, size);
@


1.94
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1118 4
a1121 3
	  struct minimal_symbol *msym;
	  msym = lookup_minimal_symbol_by_pc (ti.ti_startfunc);
	  if (msym)
d1123 1
a1123 1
			     SYMBOL_PRINT_NAME (msym));
d1132 4
a1135 3
	  struct minimal_symbol *msym;
	  msym = lookup_minimal_symbol_by_pc (ti.ti_pc);
	  if (msym)
d1137 1
a1137 1
			     SYMBOL_PRINT_NAME (msym));
@


1.94.2.1
log
@move sparc-sol-thread.c back into sol-thread.c.

The routines in sparc-sol-thread used to be SPARC-specific (and
documented as such in the ptrace man page), and therefore hosting them
in a sparc-specific file made sense.  However, newer versions of
Solaris now use those callbacks (Solaris 10 Update 10, apparently),
and thus the note about these callbacks being specific to SPARC
was removed.

So this patch deletes sparc-sol-thread.c and moves the code back
inside sol-thread.c.

gdb/ChangeLog:

        PR tdep/15420:
        * sol-thread.c (ps_lgetxregsize, ps_lgetxregs, ps_lsetxregs):
        New functions, directly copied from sparc-sol-thread.c.
        * sparc-sol-thread.c: Delete.
        * configure.ac: Remove code handling sparc-solaris-thread.c.
        * configure: Regenerate.
@
text
@a909 24
/* Get size of extra register set.  Currently a noop.  */

ps_err_e
ps_lgetxregsize (gdb_ps_prochandle_t ph, lwpid_t lwpid, int *xregsize)
{
  return PS_OK;
}

/* Get extra register set.  Currently a noop.  */

ps_err_e
ps_lgetxregs (gdb_ps_prochandle_t ph, lwpid_t lwpid, caddr_t xregset)
{
  return PS_OK;
}

/* Set extra register set.  Currently a noop.  */

ps_err_e
ps_lsetxregs (gdb_ps_prochandle_t ph, lwpid_t lwpid, caddr_t xregset)
{
  return PS_OK;
}

@


1.93
log
@	ARI fixes: sprintf rule.
	Replace sprintf function calls for char arrays by
	calls to xsnprintf calls.
	* arm-tdep.c (arm_push_dummy_call): Replace sprintf by xsnprintf.
	(arm_dwarf_reg_to_regnum, arm_return_value): Ditto.
	(arm_neon_quad_read, arm_pseudo_read): Ditto.
	(arm_neon_quad_write, arm_pseudo_write): Ditto.
	* breakpoint.c (condition_completer): Ditto.
	(create_tracepoint_from_upload): Ditto.
	* dwarf2read.c (file_full_name): Ditto.
	* gcore.c (gcore_command): Ditto.
	* gnu-nat.c (proc_string, gnu_pid_to_str): Ditto.
	* go32-nat.c (go32_sysinfo): Ditto.
	* interps.c (interp_set): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	* ppc-linux-nat.c (fetch_register, store_register): Ditto.
	* remote-m32r-sdi.c (m32r_open): Ditto.
	* sol-thread.c (td_err_string): Ditto.
	(td_state_string, solaris_pid_to_str): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	* cli/cli-script.c (execute_control_command): Ditto.
	(define_command, document_command): Ditto.
	* tui/tui-io.c (tui_rl_display_match_list): Ditto.
	* tui/tui-stack.c (tui_make_status_line): Ditto.
	* tui/tui-win.c (tui_update_gdb_sizes): Ditto.
@
text
@d3 1
a3 1
   Copyright (C) 1996-2005, 2007-2012 Free Software Foundation, Inc.
@


1.92
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d199 2
a200 1
  sprintf (buf, "Unknown libthread_db error code: %d", errcode);
d231 2
a232 1
  sprintf (buf, "Unknown libthread_db state code: %d", statecode);
d1020 2
a1021 1
	sprintf (buf, "Thread %ld (defunct)", GET_THREAD (ptid));
d1023 1
a1023 1
	sprintf (buf, "Thread %ld (LWP %ld)",
d1026 1
a1026 1
	sprintf (buf, "Thread %ld        ", GET_THREAD (ptid));
d1029 1
a1029 1
    sprintf (buf, "LWP    %ld        ", GET_LWP (ptid));
d1031 1
a1031 1
    sprintf (buf, "process %d    ", PIDGET (ptid));
@


1.91
log
@sol-thread.c: Remove commented-out code.

gdb/ChangeLog:

        * sol-thread.c (sol_thread_fetch_registers)
        (sol_thread_store_registers): Delete commented out code.
@
text
@d864 1
a864 1
  regcache = get_thread_arch_regcache (inferior_ptid, target_gdbarch);
d886 1
a886 1
  regcache = get_thread_arch_regcache (inferior_ptid, target_gdbarch);
d920 1
a920 1
  regcache = get_thread_arch_regcache (inferior_ptid, target_gdbarch);
d942 1
a942 1
  regcache = get_thread_arch_regcache (inferior_ptid, target_gdbarch);
d1122 1
a1122 1
			     paddress (target_gdbarch, ti.ti_startfunc));
d1135 1
a1135 1
			     paddress (target_gdbarch, ti.ti_startfunc));
@


1.90
log
@New unit sparc-sol-thread.c extracted from sol-thread.c

Moving some sparc-specific routines out of sol-thread.c into their
own (new) file.

gdb/ChangeLog:

        * sol-thread.c (ps_lgetxregsize, ps_lgetxregs, ps_lsetxregs):
        Move these functions to sparc-sol-thread.c.
        * sparc-sol-thread.c: New file.
        * configure.ac: Add sparc-sol-thread.o to CONFIG_OBS and
        sparc-sol-thread.c to CONFIG_SRCS for sparc-solaris native
        configurations.
        * configure: Regenerate.
@
text
@a445 5
#if 0
  int xregsize;
  caddr_t xregset;
#endif

a485 17

#if 0
  /* FIXME: libthread_db doesn't seem to handle this right.  */
  val = td_thr_getxregsize (&thandle, &xregsize);
  if (val != TD_OK && val != TD_NOXREGS)
    error (_("sol_thread_fetch_registers: td_thr_getxregsize %s"),
	   td_err_string (val));

  if (val == TD_OK)
    {
      xregset = alloca (xregsize);
      val = td_thr_getxregs (&thandle, xregset);
      if (val != TD_OK)
	error (_("sol_thread_fetch_registers: td_thr_getxregs %s"),
	       td_err_string (val));
    }
#endif
a496 4
#if 0
  int xregsize;
  caddr_t xregset;
#endif
a533 17

#if 0
      /* FIXME: libthread_db doesn't seem to handle this right.  */
      val = td_thr_getxregsize (&thandle, &xregsize);
      if (val != TD_OK && val != TD_NOXREGS)
	error (_("sol_thread_store_registers: td_thr_getxregsize %s"),
	       td_err_string (val));

      if (val == TD_OK)
	{
	  xregset = alloca (xregsize);
	  val = td_thr_getxregs (&thandle, xregset);
	  if (val != TD_OK)
	    error (_("sol_thread_store_registers: td_thr_getxregs %s"),
		   td_err_string (val));
	}
#endif
a546 11

#if 0
  /* FIXME: libthread_db doesn't seem to handle this right.  */
  val = td_thr_getxregsize (&thandle, &xregsize);
  if (val != TD_OK && val != TD_NOXREGS)
    error (_("sol_thread_store_registers: td_thr_getxregsize %s"),
	   td_err_string (val));

  /* ??? Should probably do something about writing the xregs here,
     but what are they?  */
#endif
@


1.89
log
@sol-thread.c: Remove #if 0-ed code.

gdb/ChangeLog:

        * sol-thread.c (ps_lgetxregsize, ps_lgetxregs, ps_lsetxregs):
        Remove commented-out code.
@
text
@a961 28
#if defined (__sparc) || defined (__sparcv9)

/* Get size of extra register set.  Currently a noop.  */

ps_err_e
ps_lgetxregsize (gdb_ps_prochandle_t ph, lwpid_t lwpid, int *xregsize)
{
  return PS_OK;
}

/* Get extra register set.  Currently a noop.  */

ps_err_e
ps_lgetxregs (gdb_ps_prochandle_t ph, lwpid_t lwpid, caddr_t xregset)
{
  return PS_OK;
}

/* Set extra register set.  Currently a noop.  */

ps_err_e
ps_lsetxregs (gdb_ps_prochandle_t ph, lwpid_t lwpid, caddr_t xregset)
{
  return PS_OK;
}

#endif /* defined (__sparc) || defined (__sparcv9) */

@


1.88
log
@sol-thread.c: conditionalize some sparc-specific libthread_db functions.

gdb/ChangeLog:

        * sol-thread.c (ps_lgetxregsize, ps_lgetxregs, ps_lsetxregs):
        Enable this code for sparc hosts only.
@
text
@a968 20
#if 0
  int lwp_fd;
  int regsize;
  ps_err_e val;

  val = get_lwp_fd (ph, lwpid, &lwp_fd);
  if (val != PS_OK)
    return val;

  if (ioctl (lwp_fd, PIOCGXREGSIZE, &regsize))
    {
      if (errno == EINVAL)
	return PS_NOFREGS;	/* XXX Wrong code, but this is the closest
				   thing in proc_service.h  */

      print_sys_errmsg ("ps_lgetxregsize (): PIOCGXREGSIZE", errno);
      return PS_ERR;
    }
#endif

a976 15
#if 0
  int lwp_fd;
  ps_err_e val;

  val = get_lwp_fd (ph, lwpid, &lwp_fd);
  if (val != PS_OK)
    return val;

  if (ioctl (lwp_fd, PIOCGXREG, xregset))
    {
      print_sys_errmsg ("ps_lgetxregs (): PIOCGXREG", errno);
      return PS_ERR;
    }
#endif

a984 15
#if 0
  int lwp_fd;
  ps_err_e val;

  val = get_lwp_fd (ph, lwpid, &lwp_fd);
  if (val != PS_OK)
    return val;

  if (ioctl (lwp_fd, PIOCSXREG, xregset))
    {
      print_sys_errmsg ("ps_lsetxregs (): PIOCSXREG", errno);
      return PS_ERR;
    }
#endif

@


1.87
log
@Add procfs_find_LDT_entry declaration (procfs.h).

Add a declaration for procfs_find_LDT_entry in order to prevent
a compiler warning about this function missing one. This also
helps making sure that declaration and definition remain consistent.

gdb/ChangeLog:

        * procfs.h (procfs_find_LDT_entry): Add declaration.
        * sol-thread.c (ps_lgetLDT): Delete local declaration of
        function procfs_find_LDT_entry.
@
text
@d962 2
d1038 2
@


1.86
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@a1110 1
  extern struct ssd *procfs_find_LDT_entry (ptid_t);
@


1.85
log
@Fix -Wmissing-prototypes errors in sol-thread.c

gdb/ChangeLog:

        * sol-thread.c (solaris_pid_to_str): Make static.
        (_initialize_sol_thread): Add prototype.
@
text
@d348 1
a348 1
		   ptid_t ptid, int step, enum target_signal signo)
@


1.84
log
@Delete unused procfs_pid_to_str extern in sol-thread.c

gdb/ChangeLog:

        * sol-thread.c (procfs_pid_to_str): Delete extern declaration.
@
text
@d1135 1
a1135 1
char *
d1343 3
@


1.83
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a71 2
extern char *procfs_pid_to_str (struct target_ops *ops, ptid_t ptid);

@


1.82
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d3 1
a3 2
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.82.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 1996-2005, 2007-2012 Free Software Foundation, Inc.
@


1.81
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d207 1
a207 1
/* Return the the libthread_db state string assicoated with STATECODE.
@


1.80
log
@run copyright.sh for 2011.
@
text
@d75 1
a75 1
/* Prototypes for supply_gregset etc. */
d767 1
a767 1
   and use that info to make appropriate typedefs here. */
d1061 1
a1061 1
/* Set floating-point regs for LWP */
d1272 1
a1272 1
	printf_filtered ("\n");	/* don't you hate counting newlines? */
@


1.79
log
@Implement task switching on solaris targets.

        * sol-thread.c (thread_db_find_thread_from_tid)
        (sol_get_ada_task_ptid): New functions.
        (init_sol_thread_ops): Set sol_thread_ops.to_get_ada_task_ptid.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.78
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1291 34
d1342 1
@


1.77
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d4 1
a4 1
   2007, 2008, 2009 Free Software Foundation, Inc.
@


1.76
log
@	* target.h (struct target_ops): New member to_thread_architecture.
	(target_thread_architecture): New macro.
	* target.c (update_current_target): Inherit to_thread_architecture.
	(default_thread_architecture): New function.
	(debug_to_thread_architecture): New function.
	(setup_target_debug): Handle to_thread_architecture.

	* regcache.h (get_thread_arch_regcache): New.
	* regcache.c (struct regcache_list): New data type.
	(current_regcache): Hold regcache list instead of single regcache.
	(current_thread_ptid, current_thread_arch): New static variables.
	(get_thread_arch_regcache): New function.
	(get_thread_regcache): Use it.  Call target_thread_architecture.
	(regcache_thread_ptid_changed): Update to current_regcache changes.
	(registers_changed): Likewise.  Reset current_thread_arch and
	current_thread_ptid.

	* remote.c (remote_wait): Access target registers in target_gdbarch.
	* linux-nat.c (linux_nat_do_thread_registers): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* solib-svr4.c (enable_break): Likewise.
	(svr4_relocate_main_executable): Likewise.
@
text
@d1253 2
a1254 1
	    printf_filtered ("   startfunc: 0x%s\n", paddr (ti.ti_startfunc));
d1266 2
a1267 1
	    printf_filtered (" - Sleep func: 0x%s\n", paddr (ti.ti_startfunc));
@


1.75
log
@2009-06-07  Pedro Alves  <pedro@@codesourcery.com>

	* procfs.h: New.
	* proc-utils.h (procfs_first_available): Don't declare here.
	* sol-thread.c: Include procfs.h instead of sys/procfs.h and
	proc-utils.h.
	* procfs.c: Include procfs.h.
	(procfs_target): Make it public.  Don't register
	procfs_can_use_hw_breakpoint here.
	(proc_set_watchpoint): Check for PCWATCH or PIOCSWATCH being
	defined instead of TARGET_HAS_HARDWARE_WATCHPOINTS.
	(procfs_can_use_hw_breakpoint): Remove check of
	TARGET_HAS_HARDWARE_WATCHPOINTS.
	(procfs_use_watchpoints): Register procfs_can_use_hw_breakpoint
	here.
	(_initialize_procfs): Don't add the procfs target here.

	* i386-sol2-nat.c: Include target.h and procfs.h.
	(_initialize_amd64_sol2_nat): Install the procfs target here,
	customized with watchpoints support.
	* irix5-nat.c: Include target.h.
	(_initialize_core_irix5): Rename to ...
	(_initialize_irix5_nat): ... this.  Install the procfs target
	here, customized with watchpoints support.
	* alpha-nat.c: Include procfs.h.
	(_initialize_core_alpha): Rename to...
	(_initialize_alpha_nat): ... this.  Install the procfs target
	here, customized with watchpoints support.
	* sparc-sol2-nat.c: Include target.h and procfs.h.
	(_initialize_sparc_sol2_nat): New.

	* config/i386/nm-i386sol2.h (TARGET_HAS_HARDWARE_WATCHPOINTS): Delete.
	* config/sparc/nm-sol2.h (TARGET_HAS_HARDWARE_WATCHPOINTS): Delete.
	* config/mips/irix5.mh (NAT_FILE): Delete.
	* config/mips/irix6.mh (NAT_FILE): Delete.
	* config/mips/nm-irix5.h: Delete.

2009-06-07  Pedro Alves  <pedro@@codesourcery.com>

	* gdbint.texinfo (TARGET_HAS_HARDWARE_WATCHPOINTS): Delete all
	references.
@
text
@d921 1
a921 1
  regcache = get_thread_regcache (inferior_ptid);
d943 1
a943 1
  regcache = get_thread_regcache (inferior_ptid);
d1051 1
a1051 1
  regcache = get_thread_regcache (inferior_ptid);
d1073 1
a1073 1
  regcache = get_thread_regcache (inferior_ptid);
@


1.74
log
@	* inferior.h (procfs_first_available): Move declaration to...
	* proc-utils.h: ... here.
	* sol-thread.c: Include procfs.h and proc-utils.h.
@
text
@d69 1
a69 2
#include <sys/procfs.h>
#include "proc-utils.h"
@


1.73
log
@	* target.h (TARGET_WNOHANG): New.
	* target.c (target_wait): Add `options' argument.  Adjust.
	(struct target_ops) <to_wait>: Add `options' argument.
	(target_wait): Add `options' argument.
	* infrun.c (wait_for_inferior): Pass 0 as options to
	target_wait (blocking wait).
	(fetch_inferior_event): Pass TARGET_WNOHANG as options to
	target_wait.
	* fork-child.c (startup_inferior): Pass 0 as options to
	target_wait (blocking wait).
	* linux-nat.c (linux_nat_create_inferior): Remove async masking.
	(linux_nat_wait_1): Add `target_options' argument.  Use it instead
	of checking on target_can_async_p.
	(linux_nat_wait): Add `target_options' argument.  Adjust.
	* remote.c (remote_wait_ns): Add `options' argument.  Adjust to
	check on TARGET_WNOWAIT instead of checking on remote_is_async_p.
	(remote_wait_as): Add `options' argument.  Adjust to check on
	TARGET_WNOWAIT instead of checking on remote_is_async_p.  If doing
	a blocking wait, keep waiting until an interesting event comes
	out.
	(remote_wait): Add `options' argument.  Don't loop here if the
	target is in async mode, and a blocking wait has been requested.

	* top.c (deprecated_target_wait_hook): Add `options' argument.
	* linux-thread-db.c (thread_db_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ptrace.c (inf_ptrace_wait): Add `options' argument.
	* record.c (record_beneath_to_wait): Add `options' argument.
	(record_wait): Add `options' argument, and pass it down to the
	layer beneath.
	* bsd-uthread.c (bsd_uthread_wait): Add `options' argument.
	* darwin-nat.c (darwin_wait): Likewise.
	* defs.h (deprecated_target_wait_hook): Likewise.
	* gnu-nat.c (gnu_wait): Add `options' argument.
	* go32-nat.c (go32_wait): Likewise.
	* hpux-thread.c (hpux_thread_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ttrace.c (inf_ttrace_wait): Add `options' argument.
	* monitor.c (monitor_wait): Likewise.
	* nto-procfs.c (procfs_wait): Likewise.
	* remote-mips.c (mips_wait): Add `options' argument.
	* remote-sim.c (gdbsim_wait): Likewise.
	* rs6000-nat.c (rs6000_wait): Add `options' argument.
	* sol-thread.c (sol_thread_wait): Add `options' argument, and pass
	it down to the layer beneath.
	* spu-linux-nat.c (spu_child_wait): Add `options' argument.
	* windows-nat.c (windows_wait): Likewise.
	* tui/tui-hooks.c (tui_target_wait_hook): Likewise.  Adjust.
@
text
@a67 1

d69 2
@


1.72
log
@	* corelow.c (get_core_registers): Adjust.
	(core_file_thread_alive): Rename to...
	(core_thread_alive): ... this.
	(core_pid_to_str): Try gdbarch_core_pid_to_str first.
	(init_core_ops): Adjust.
	(coreops_suppress_target): Delete.
	(_initialize_corelow): Unconditionally add core_ops.
	* procfs.c: Include "inf-child.h".
	(procfs_ops): Delete.
	(init_procfs_ops): Delete.  Reimplement as...
	(procfs_target): ... this, inheriting from inf-child.
	(procfs_attach, procfs_detach, procfs_fetch_registers): Adjust.
	(procfs_prepare_to_store): Delete.
	(procfs_store_registers, procfs_resume): Adjust.
	(procfs_open): Delete.
	(procfs_suppress_run): Delete.
	(procfs_can_run): Delete.
	(procfs_mourn_inferior): Adjust.
	(procfs_init_inferior): Add target_ops parameter.  Adjust.
	(procfs_create_inferior): Don't pass procfs_init_inferior to
	fork_inferior.  Instead call it after fork_inferior returns.
	(procfs_find_new_threads): Adjust.
	(_initialize_procfs): Adjust to use procfs_target instead of
	init_procfs_ops.
	* sol-thread.c (orig_core_ops, sol_core_ops): Delete.
	(lwp_to_thread): Use target_thread_alive.
	(sol_thread_open): Delete.
	(sol_thread_attach): Delete.
	(sol_thread_detach, sol_thread_resume, sol_thread_wait)
	(sol_thread_fetch_registers, sol_thread_store_registers): Adjust
	to use find_target_beneath.
	(sol_thread_prepare_to_store, sol_thread_xfer_memory): Delete.
	(sol_thread_xfer_partial): Adjust to use find_target_beneath.
	(sol_thread_files_info, sol_thread_kill_inferior): Delete.
	(check_for_thread_db): New.
	(sol_thread_notice_signals, sol_thread_create_inferior): Delete.
	(sol_thread_new_objfile): Call check_for_thread_db.
	(sol_thread_mourn_inferior): Adjust to use find_target_beneath.
	(sol_thread_can_run): Delete.
	(sol_thread_alive): Adjust to use find_target_beneath.
	(sol_thread_stop): Delete.
	(rw_common): Use target_write_memory or target_read_memory.
	(ps_lgetregs, ps_lgetfpregs): Use target_fetch_registers.
	(ps_lsetregs, ps_lsetfpregs): Use target_store_registers.
	(solaris_pid_to_str): Remove check for libthread_db initialization
	failing.
	(sol_find_new_threads): Remove check for libthread_db
	initialization failing, or for an invalid inferior_ptid.  Adjust
	to use find_target_beneath.
	(sol_core_open, sol_core_close, sol_core_detach,
	sol_core_files_info, sol_find_memory_regions,
	sol_make_note_section, ignore): Delete.
	(init_sol_thread_ops): Make it a thread_stratum target.  Remove
	unneeded callback settings.
	(init_sol_core_ops): Delete.
	(_initialize_sol_thread): No longer call init_sol_core_ops, set
	procfs_suppress_run, or hack with core_ops.

	* target.h (struct target_ops): Add a target_ops * parameter to
	to_resume, to_fetch_registers, to_store_registers, to_thread_alive
	and to_find_new_threads.
	(target_fetch_registers, target_store_registers)
	(target_thread_alive, target_find_new_threads): Redeclare as
	function.

	* target.c (update_current_target): Do not inherit or de_fault
	to_resume, to_fetch_registers, to_store_registers,
	to_thread_alive, to_find_new_threads.
	(target_resume): Adjust.
	(target_thread_alive, target_find_new_threads): New.
	(debug_to_resume, debug_to_fetch_registers): Delete.
	(target_fetch_registers): New.
	(debug_to_store_registers): Delete.
	(target_store_registers): New.
	(debug_to_thread_alive, debug_to_find_new_threads): Delete.
	(setup_target_debug): Adjust.

	* gdbcore.h (core_ops): Delete declaration.

	* inf-ptrace.c, linux-nat.c, remote.c, amd64-linux-nat.c,
	inf-child.c, linux-thread-db.c, bsd-uthread.c, inf-ttrace.c,
	i386-sol2-tdep.c, darwin-nat.c, gnu-nat.c, go32-nat.c,
	hpux-thread.c, i386-linux-nat.c, i386fbsd-nat.c, monitor.c,
	nto-procfs.c, remote-m32r-sdi.c, remote-mips.c, windows-nat.c,
	alphabsd-nat.c, amd64bsd-nat.c, arm-linux-nat.c, armnbsd-nat.c,
	bsd-kvm.c, hppa-hpux-nat.c, hppa-linux-nat.c, hppabsd-nat.c,
	hppanbsd-nat.c, i386-darwin-nat.c, i386bsd-nat.c,
	ia64-linux-nat.c, m32r-linux-nat.c, m68kbsd-nat.c,
	m68klinux-nat.c, m88kbsd-nat.c, mips-linux-nat.c,
	mips64obsd-nat.c, mipsnbsd-nat.c, ppc-linux-nat.c, ppcnbsd-nat.c,
	ppcobsd-nat.c, remote-sim.c, rs6000-nat.c, s390-nat.c,
	shnbsd-nat.c, sparc-nat.c, sparc-nat.h, spu-linux-nat.c,
	vaxbsd-nat.c, xtensa-linux-nat.c: Adjust to target_ops changes.

	* gdbarch.sh (core_pid_to_str): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* sol2-tdep.c: Include "inferior.h".
	(sol2_core_pid_to_str): New.
	* sol2-tdep.h (sol2_core_pid_to_str): Declare.

	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Set it.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Set it.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Set it.
@
text
@d384 1
a384 1
		 ptid_t ptid, struct target_waitstatus *ourstatus)
d410 1
a410 1
  rtnval = beneath->to_wait (beneath, ptid, ourstatus);
@


1.71
log
@	* linux-nat.c (linux_nat_wait): Adjust.
	(linux_nat_pid_to_str): Adjust.  Remove call to thread_db_init.
	* linux-nat.h (thread_db_init): Delete declaration.
	* linux-thread-db.c (target_beneath): Delete.
	(thread_db_init): Delete.
	(thread_db_detach): Use find_target_beneath.
	(thread_db_wait): Adjust interface.  Use find_target_beneath.
	(thread_db_mourn_inferior): Use find_target_beneath.
	(thread_db_can_async_p, thread_db_is_async_p, thread_db_async)
	(thread_db_async_mask): Delete.
	(thread_db_pid_to_str): Adjust interface.  Use
	find_target_beneath.
	(thread_db_get_thread_local_address): Adjust interface.  Use
	find_target_beneath.
	(init_thread_db_ops): Delete references to delete functions.
	* target.c (update_current_target): Don't inherit or default
	to_wait.  Don't inherit to_pid_to_str and
	to_get_thread_local_address.
	(target_translate_tls_address): Look for a pushed target that
	implements to_get_thread_local_address, and use it instead of
	checking for target_get_thread_local_address_p.
	(target_wait, target_pid_to_str): Reimplement as functions.
	(dummy_pid_to_str): New.
	(init_dummy_target): Register it.
	(debug_to_wait): Delete.
	* target.h (struct target_ops): Make to_wait, to_pid_to_str and
	to_get_thread_local_address accept a pointer to struct target_ops.
	(target_wait): Delete macro, and declare as function.
	(target_pid_to_str): Likewise.
	(target_get_thread_local_address)
	(target_get_thread_local_address_p): Delete.
	(noprocess): Add NORETURN and ATTR_NORETURN tags.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	(inf_ptrace_pid_to_str): New.
	(inf_ptrace_target): Use inf_ptrace_pid_to_str.
	* aix-thread.c (aix_thread_wait, aix_thread_pid_to_str): Adjust.
	* bsd-kvm.c (bsd_kvm_pid_to_str): Adjust.
	* bsd-uthread.c (bsd_uthread_wait, bsd_uthread_pid_to_str):
	Adjust.
	* corelow.c (core_pid_to_str): Adjust.
	* darwin-nat.c (darwin_wait, darwin_pid_to_str): Adjust.
	* dec-thread.c (dec_thread_wait, dec_thread_pid_to_str): Adjust.
	* gnu-nat.c (gnu_wait, gnu_pid_to_str): Adjust.
	* go32-nat.c (go32_wait, go32_pid_to_str): Adjust.
	* hpux-thread.c (hpux_thread_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait, inf_ttrace_pid_to_str): Adjust.
	* monitor.c (monitor_wait, monitor_pid_to_str): Adjust.
	* nto-procfs.c (procfs_wait, procfs_pid_to_str): Adjust.
	* procfs.c (procfs_pid_to_str): Adjust.
	* remote-m32r-sdi.c (m32r_wait, m32r_pid_to_str): Adjust.
	* remote-mips.c (mips_wait): Adjust.
	* remote-sim.c (gdbsim_wait, gdbsim_pid_to_str): Adjust.
	* remote.c (remote_wait, remote_pid_to_str)
	(remote_get_thread_local_address): Adjust.
	* rs6000-nat.c (rs6000_wait): Adjust.
	* sol-thread.c (procfs_pid_to_str): Adjust declaration.
	(sol_thread_wait, solaris_pid_to_str): Adjust.
	* spu-linux-nat.c (spu_child_wait): Adjust.
	* windows-nat.c (windows_wait, windows_pid_to_str): Adjust.
@
text
@a70 6
extern struct target_ops sol_thread_ops;	/* Forward declaration */
extern struct target_ops sol_core_ops;	/* Forward declaration */

/* place to store core_ops before we overwrite it */
static struct target_ops orig_core_ops;

a71 1
struct target_ops sol_core_ops;
a72 3
extern int procfs_suppress_run;
extern struct target_ops procfs_ops;	/* target vector for procfs.c */
extern struct target_ops core_ops;	/* target vector for corelow.c */
a96 4
static void sol_thread_resume (ptid_t ptid, int step, enum target_signal signo);
static int sol_thread_alive (ptid_t ptid);
static void sol_core_close (int quitting);

a97 1
static void init_sol_core_ops (void);
d297 1
a297 1
  if (!sol_thread_alive (lwp))
d323 2
a324 35
   through to procfs.c, as they don't need to do anything specific for
   threads.  */

static void
sol_thread_open (char *arg, int from_tty)
{
  procfs_ops.to_open (arg, from_tty);
}

/* Attach to process PID, then initialize for debugging it and wait
   for the trace-trap that results from attaching.  */

static void
sol_thread_attach (struct target_ops *ops, char *args, int from_tty)
{
  sol_thread_active = 0;
  procfs_ops.to_attach (&procfs_ops, args, from_tty);

  /* Must get symbols from shared libraries before libthread_db can run!  */
  solib_add (NULL, from_tty, (struct target_ops *) 0, auto_solib_add);

  if (sol_thread_active)
    {
      ptid_t ptid;
      printf_filtered ("sol-thread active.\n");
      main_ph.ptid = inferior_ptid; /* Save for xfer_memory.  */
      push_target (&sol_thread_ops);
      ptid = lwp_to_thread (inferior_ptid);
      if (PIDGET (ptid) != -1)
	thread_change_ptid (inferior_ptid, ptid);
    }

  /* FIXME: Might want to iterate over all the threads and register
     them.  */
}
d336 2
d340 2
a341 2
  unpush_target (&sol_thread_ops);
  procfs_ops.to_detach (&procfs_ops, args, from_tty);
d350 2
a351 1
sol_thread_resume (ptid_t ptid, int step, enum target_signal signo)
d354 1
d374 1
a374 1
  procfs_ops.to_resume (ptid, step, signo);
d388 1
d410 1
a410 1
  rtnval = procfs_ops.to_wait (&procfs_ops, ptid, ourstatus);
d437 2
a438 1
sol_thread_fetch_registers (struct regcache *regcache, int regnum)
d447 1
d456 2
a457 5
      /* It's an LWP; pass the request on to procfs.  */
      if (target_has_execution)
	procfs_ops.to_fetch_registers (regcache, regnum);
      else
	orig_core_ops.to_fetch_registers (regcache, regnum);
d514 2
a515 1
sol_thread_store_registers (struct regcache *regcache, int regnum)
d529 4
a532 2
      /* It's an LWP; pass the request on to procfs.c.  */
      procfs_ops.to_store_registers (regcache, regnum);
a605 50
/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On
   machines which store all the registers in one fell swoop, this
   makes sure that registers contains all the registers from the
   program being debugged.  */

static void
sol_thread_prepare_to_store (struct regcache *regcache)
{
  procfs_ops.to_prepare_to_store (regcache);
}

/* Transfer LEN bytes between GDB address MYADDR and target address
   MEMADDR.  If DOWRITE is non-zero, transfer them to the target,
   otherwise transfer them from the target.  TARGET is unused.

   Returns the number of bytes transferred.  */

static int
sol_thread_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len,
			int dowrite, struct mem_attrib *attrib,
			struct target_ops *target)
{
  int retval;
  struct cleanup *old_chain;

  old_chain = save_inferior_ptid ();

  if (is_thread (inferior_ptid) || !target_thread_alive (inferior_ptid))
    {
      /* It's either a thread or an LWP that isn't alive.  Any live
         LWP will do so use the first available.

	 NOTE: We don't need to call switch_to_thread; we're just
	 reading memory.  */
      inferior_ptid = procfs_first_available ();
    }

  if (target_has_execution)
    retval = procfs_ops.deprecated_xfer_memory (memaddr, myaddr, len,
						dowrite, attrib, target);
  else
    retval = orig_core_ops.deprecated_xfer_memory (memaddr, myaddr, len,
						   dowrite, attrib, target);

  do_cleanups (old_chain);

  return retval;
}

d618 1
d632 2
a633 6
  if (target_has_execution)
    retval = procfs_ops.to_xfer_partial (ops, object, annex,
					 readbuf, writebuf, offset, len);
  else
    retval = orig_core_ops.to_xfer_partial (ops, object, annex,
					    readbuf, writebuf, offset, len);
a639 2
/* Print status information about what we're accessing.  */

d641 1
a641 1
sol_thread_files_info (struct target_ops *ignore)
d643 2
a644 2
  procfs_ops.to_files_info (ignore);
}
d646 3
a648 5
static void
sol_thread_kill_inferior (void)
{
  procfs_ops.to_kill ();
}
d650 4
a653 5
static void
sol_thread_notice_signals (ptid_t ptid)
{
  procfs_ops.to_notice_signals (pid_to_ptid (PIDGET (ptid)));
}
d655 3
a657 1
/* Fork an inferior process, and start debugging it with /proc.  */
d659 6
a664 6
static void
sol_thread_create_inferior (struct target_ops *ops, char *exec_file,
			    char *allargs, char **env, int from_tty)
{
  sol_thread_active = 0;
  procfs_ops.to_create_inferior (&procfs_ops, exec_file, allargs, env, from_tty);
d666 7
a672 3
  if (sol_thread_active && !ptid_equal (inferior_ptid, null_ptid))
    {
      ptid_t ptid;
d674 2
a675 2
      /* Save for xfer_memory.  */
      main_ph.ptid = inferior_ptid;
d677 1
d679 1
d681 1
d684 9
a692 1
	thread_change_ptid (inferior_ptid, ptid);
d705 2
a706 34
  td_err_e val;

  if (!objfile)
    {
      sol_thread_active = 0;
      return;
    }

  /* Don't do anything if init failed to resolve the libthread_db
     library.  */
  if (!procfs_suppress_run)
    return;

  /* Now, initialize libthread_db.  This needs to be done after the
     shared libraries are located because it needs information from
     the user's thread library.  */

  val = p_td_init ();
  if (val != TD_OK)
    {
      warning (_("sol_thread_new_objfile: td_init: %s"), td_err_string (val));
      return;
    }

  val = p_td_ta_new (&main_ph, &main_ta);
  if (val == TD_NOLIBTHREAD)
    return;
  else if (val != TD_OK)
    {
      warning (_("sol_thread_new_objfile: td_ta_new: %s"), td_err_string (val));
      return;
    }

  sol_thread_active = 1;
d714 2
a716 3
  unpush_target (&sol_thread_ops);
  procfs_ops.to_mourn_inferior (&procfs_ops);
}
d718 1
a718 2
/* Mark our target-struct as eligible for stray "run" and "attach"
   commands.  */
d720 1
a720 4
static int
sol_thread_can_run (void)
{
  return procfs_suppress_run;
a722 16
/*

   LOCAL FUNCTION

   sol_thread_alive     - test thread for "aliveness"

   SYNOPSIS

   static bool sol_thread_alive (ptid_t ptid);

   DESCRIPTION

   returns true if thread still active in inferior.

 */

d726 1
a726 1
sol_thread_alive (ptid_t ptid)
d744 4
a747 5
      /* It's an LPW; pass the request on to procfs.  */
      if (target_has_execution)
	return procfs_ops.to_thread_alive (ptid);
      else
	return orig_core_ops.to_thread_alive (ptid);
a750 5
static void
sol_thread_stop (ptid_t ptid)
{
  procfs_ops.to_stop (ptid);
}
d842 1
d864 4
a867 40
  while (size > 0)
    {
      int cc;

      /* FIXME: passing 0 as attrib argument.  */
      if (target_has_execution)
	cc = procfs_ops.deprecated_xfer_memory (addr, buf, size,
						dowrite, 0, &procfs_ops);
      else
	cc = orig_core_ops.deprecated_xfer_memory (addr, buf, size,
						   dowrite, 0, &core_ops);

      if (cc < 0)
	{
	  if (dowrite == 0)
	    print_sys_errmsg ("rw_common (): read", errno);
	  else
	    print_sys_errmsg ("rw_common (): write", errno);

	  do_cleanups (old_chain);

	  return PS_ERR;
	}
      else if (cc == 0)
	{
	  if (dowrite == 0)
	    warning (_("rw_common (): unable to read at addr 0x%lx"),
		     (long) addr);
	  else
	    warning (_("rw_common (): unable to write at addr 0x%lx"),
		     (long) addr);

	  do_cleanups (old_chain);

	  return PS_ERR;
	}

      size -= cc;
      buf += cc;
    }
d871 1
a871 1
  return PS_OK;
d923 1
a923 4
  if (target_has_execution)
    procfs_ops.to_fetch_registers (regcache, -1);
  else
    orig_core_ops.to_fetch_registers (regcache, -1);
d946 1
a946 4
  if (target_has_execution)
    procfs_ops.to_store_registers (regcache, -1);
  else
    orig_core_ops.to_store_registers (regcache, -1);
d1053 1
a1053 4
  if (target_has_execution)
    procfs_ops.to_fetch_registers (regcache, -1);
  else
    orig_core_ops.to_fetch_registers (regcache, -1);
d1076 1
a1076 4
  if (target_has_execution)
    procfs_ops.to_store_registers (regcache, -1);
  else
    orig_core_ops.to_store_registers (regcache, -1);
a1142 4
  /* In case init failed to resolve the libthread_db library.  */
  if (!procfs_suppress_run)
    return procfs_pid_to_str (&procfs_ops, ptid);

d1188 1
a1188 1
sol_find_new_threads (void)
d1190 1
a1190 10
  /* Don't do anything if init failed to resolve the libthread_db
     library.  */
  if (!procfs_suppress_run)
    return;

  if (PIDGET (inferior_ptid) == -1)
    {
      printf_filtered ("No process.\n");
      return;
    }
d1193 2
a1194 1
  procfs_ops.to_find_new_threads ();
a1201 25
static void
sol_core_open (char *filename, int from_tty)
{
  orig_core_ops.to_open (filename, from_tty);
}

static void
sol_core_close (int quitting)
{
  orig_core_ops.to_close (quitting);
}

static void
sol_core_detach (struct target_ops *ops, char *args, int from_tty)
{
  unpush_target (&core_ops);
  orig_core_ops.to_detach (&orig_core_ops, args, from_tty);
}

static void
sol_core_files_info (struct target_ops *t)
{
  orig_core_ops.to_files_info (t);
}

a1288 20
static int
sol_find_memory_regions (int (*func) (CORE_ADDR, unsigned long,
				      int, int, int, void *),
			 void *data)
{
  return procfs_ops.to_find_memory_regions (func, data);
}

static char *
sol_make_note_section (bfd *obfd, int *note_size)
{
  return procfs_ops.to_make_corefile_notes (obfd, note_size);
}

static int
ignore (struct bp_target_info *bp_tgt)
{
  return 0;
}

a1294 2
  sol_thread_ops.to_open = sol_thread_open;
  sol_thread_ops.to_attach = sol_thread_attach;
a1299 2
  sol_thread_ops.to_prepare_to_store = sol_thread_prepare_to_store;
  sol_thread_ops.deprecated_xfer_memory = sol_thread_xfer_memory;
a1300 11
  sol_thread_ops.to_files_info = sol_thread_files_info;
  sol_thread_ops.to_insert_breakpoint = memory_insert_breakpoint;
  sol_thread_ops.to_remove_breakpoint = memory_remove_breakpoint;
  sol_thread_ops.to_terminal_init = terminal_init_inferior;
  sol_thread_ops.to_terminal_inferior = terminal_inferior;
  sol_thread_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  sol_thread_ops.to_terminal_ours = terminal_ours;
  sol_thread_ops.to_terminal_save_ours = terminal_save_ours;
  sol_thread_ops.to_terminal_info = child_terminal_info;
  sol_thread_ops.to_kill = sol_thread_kill_inferior;
  sol_thread_ops.to_create_inferior = sol_thread_create_inferior;
a1301 2
  sol_thread_ops.to_can_run = sol_thread_can_run;
  sol_thread_ops.to_notice_signals = sol_thread_notice_signals;
d1305 1
a1305 10
  sol_thread_ops.to_stop = sol_thread_stop;
  sol_thread_ops.to_stratum = process_stratum;
  sol_thread_ops.to_has_all_memory = 1;
  sol_thread_ops.to_has_memory = 1;
  sol_thread_ops.to_has_stack = 1;
  sol_thread_ops.to_has_registers = 1;
  sol_thread_ops.to_has_execution = 1;
  sol_thread_ops.to_has_thread_control = tc_none;
  sol_thread_ops.to_find_memory_regions = sol_find_memory_regions;
  sol_thread_ops.to_make_corefile_notes = sol_make_note_section;
a1308 40
static void
init_sol_core_ops (void)
{
  sol_core_ops.to_shortname = "solaris-core";
  sol_core_ops.to_longname = "Solaris core threads and pthread.";
  sol_core_ops.to_doc = "Solaris threads and pthread support for core files.";
  sol_core_ops.to_open = sol_core_open;
  sol_core_ops.to_close = sol_core_close;
  sol_core_ops.to_attach = sol_thread_attach;
  sol_core_ops.to_detach = sol_core_detach;
  sol_core_ops.to_fetch_registers = sol_thread_fetch_registers;
  sol_core_ops.deprecated_xfer_memory = sol_thread_xfer_memory;
  sol_core_ops.to_xfer_partial = sol_thread_xfer_partial;
  sol_core_ops.to_files_info = sol_core_files_info;
  sol_core_ops.to_insert_breakpoint = ignore;
  sol_core_ops.to_remove_breakpoint = ignore;
  sol_core_ops.to_create_inferior = sol_thread_create_inferior;
  sol_core_ops.to_stratum = core_stratum;
  sol_core_ops.to_has_memory = 1;
  sol_core_ops.to_has_stack = 1;
  sol_core_ops.to_has_registers = 1;
  sol_core_ops.to_has_thread_control = tc_none;
  sol_core_ops.to_thread_alive = sol_thread_alive;
  sol_core_ops.to_pid_to_str = solaris_pid_to_str;
  /* On Solaris/x86, when debugging a threaded core file from process
     <n>, the following causes "info threads" to produce "procfs:
     couldn't find pid <n> in procinfo list" where <n> is the pid of
     the process that produced the core file.  Disable it for now. */
#if 0
  sol_core_ops.to_find_new_threads = sol_find_new_threads;
#endif
  sol_core_ops.to_magic = OPS_MAGIC;
}

/* We suppress the call to add_target of core_ops in corelow because
   if there are two targets in the stratum core_stratum,
   find_core_target won't know which one to return.  See corelow.c for
   an additonal comment on coreops_suppress_target.  */
int coreops_suppress_target = 1;

a1314 1
  init_sol_core_ops ();
a1349 2
  procfs_suppress_run = 1;

a1352 8
  /* FIXME: This code takes errant advantage of the order in which
     initialization routines are run.  _initialize_corelow must run before
     this one otherwise orig_core_ops will still contain zeros and the work
     of init_sol_core_ops will be undone.  */
  memcpy (&orig_core_ops, &core_ops, sizeof (struct target_ops));
  memcpy (&core_ops, &sol_core_ops, sizeof (struct target_ops));
  add_target (&core_ops);

a1363 3
  /* Allow the user to debug non-threaded core files.  */
  add_target (&core_ops);

@


1.70
log
@        Updated copyright notices for most files.
@
text
@d83 1
a83 1
extern char *procfs_pid_to_str (ptid_t ptid);
d427 2
a428 1
sol_thread_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
d453 1
a453 1
  rtnval = procfs_ops.to_wait (ptid, ourstatus);
d1327 1
a1327 1
solaris_pid_to_str (ptid_t ptid)
d1333 1
a1333 1
    return procfs_pid_to_str (ptid);
@


1.69
log
@	Kill pthread_ops_hack

	* target.h (struct target_ops): Make to_attach, to_detach,
	to_create_inferior and to_mourn_inferior accept a pointer
    	to struct target_ops.
	(target_attach, target_create_inferior, target_create_inferior):
	Convert from macros to function.  Find the right target to
	invoke a method of.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.
	* corefile.c (core_file_command): Pass target to to_detach.
	* corelow.c (core_detach): Add 'ops' parameter.
	* fork-child.c (fork_inferior): Return the pid.  Allow
	init_trace_fun to be NULL.
	* inf-ptrace (ptrace_ops_hack): Remove.
	(inf_ptrace_him): Remove, moving all logic into....
	(inf_ptrace_create_inferior): ... here.  Push the target
	passed as parameter.
	(inf_ptrace_mourn_inferior, inf_ptrace_attach, inf_ptrace_detach):
	Push/pop target passed as parameter, no ptrace_ops_hack.
	(inf_ptrace_target): Don't remember result.
	* inferior.h (fork_inferior): Adjust prototype.
	* linux-nat.c (linux_nat_create_inferior, linux_nat_attach)
	(linux_nat_detach, linux_nat_mourn_inferior): New parameter ops.
	Pass it to linux_ops target.
	* linux-thread-db.c (thread_db_detach, thread_db_mourn_inferior):
	New parameter ops. Pass it to the target beneath.
	* remote.c (remote_mourn, extended_remote_mourn, remote_detach)
	(extended_remote_create_inferior): New parameter ops. Pass it
	further.
	* target.c (debug_to_attach, debug_to_detach)
	(debug_to_mourn_inferior): New parameter ops.
	(target_create_inferior): New.
	(update_current_target): Do not inherit to_attach, to_detach,
	to_create_inferiour, to_mourn_inferior.  Do not default
	to_detach and to_mourn_inferior.
	(target_detach): Find the right target to use.
	(target_mourn_inferior): New.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.  Pass the found target when calling its method.
	(init_dummy_target): Provide fallback definition of to_detach.
	(target_attach): New.
	(debug_to_attach, debug_to_detach, debug_to_create_inferior)
	(debug_to_mourn_inferiour): New parameter ops.
        * aix-thread.c: Adjust.
        * bsd-uthread.c: Adjust.
        * gnu-nat.c: Adjust.
        * go32-nat.c: Adjust.
        * hpux-thread.c: Adjust.
        * inf-ttrace.c: Ajust.
        * monitor.c: Adjust.
        * nto-procfs.c: Adjust.
        * procfs.c: Adjust.
        * remote-m32r-sdi.c: Adjust.
        * remote-mips.c: Adjust.
        * remote-sim.c: Adjust.
        * rs6000-nat.c: Adjust.
        * sol-thread.c: Adjust.
        * win32-nat.c: Adjust.
	* dec-thread.c: Adjust.
@
text
@d4 1
a4 1
   2007, 2008 Free Software Foundation, Inc.
@


1.68
log
@	* sol-thread.c (_initialize_sol_thread): Add FIXME regarding
	order of _initialize_* fns.
@
text
@d351 1
a351 1
sol_thread_attach (char *args, int from_tty)
d354 1
a354 1
  procfs_ops.to_attach (args, from_tty);
d382 1
a382 1
sol_thread_detach (char *args, int from_tty)
d387 1
a387 1
  procfs_ops.to_detach (args, from_tty);
d756 2
a757 2
sol_thread_create_inferior (char *exec_file, char *allargs, char **env,
			    int from_tty)
d760 1
a760 1
  procfs_ops.to_create_inferior (exec_file, allargs, env, from_tty);
d825 1
a825 1
sol_thread_mourn_inferior (void)
d829 1
a829 1
  procfs_ops.to_mourn_inferior ();
d1414 1
a1414 1
sol_core_detach (char *args, int from_tty)
d1417 1
a1417 1
  orig_core_ops.to_detach (args, from_tty);
@


1.67
log
@	* procfs.c (to_attach): Create a procinfo for the current lwp.
	Add it to gdb's thread list.
	(procfs_fetch_registers, procfs_store_registers): Assume there's
	always an lwp.
	(procfs_wait): Don't add the main thread here.
	(procfs_init_inferior): Create a procinfo for the main lwp here.
	Change main thread's ptid with thread_change_ptid.
	(procfs_notice_thread): Check for exited threads.
	(procfs_corefile_thread_callback): Remove check for the main
	process.
	(procfs_make_note_section): Assume there is always a thread.

	* sol-thread.c (sol_thread_attach): Clear sol_thread_active before
	attaching.  Change the main thread ptid with thread_change_ptid.
	(sol_thread_detach): Clear sol_thread_active.
	(sol_thread_wait): Check for exited threads.
	(sol_thread_create_inferior): Clear sol_thread_active before
	creating a new inferior.  Change the main thread ptid with
	thread_change_ptid.
	(sol_thread_mourn_inferior): Clear sol_thread_active.
	(sol_find_new_threads_callback): Check for exited threads.
@
text
@d1666 4
@


1.66
log
@	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME.
	* blockframe.c (find_pc_partial_function): Likewise.
	* buildsym.c (find_symbol_in_list): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* coffread.c (patch_opaque_types, process_coff_symbol): Likewise.
	(coff_read_enum_type): Likewise.  Use SYMBOL_SET_LINKAGE_NAME.
	* cp-support.c (cp_remove_params): Renamed from remove_params and
	made global.
	(overload_list_add_symbol): Update call to remove_params.
	* cp-support.h (cp_remove_params): Declare.
	* dwarf2read.c (process_enumeration_scope): Use SYMBOL_LINKAGE_NAME.
	(dwarf2_const_value): Use SYMBOL_PRINT_NAME.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* f-valprint.c (info_common_command, there_is_a_visible_common_named):
	Use SYMBOL_LINKAGE_NAME to find symbols and SYMBOL_PRINT_NAME
	for messages.
	* findvar.c (read_var_value): Use SYMBOL_LINKAGE_NAME.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Use SYMBOL_LINKAGE_NAME to find
	symbols and SYMBOL_PRINT_NAME for messages.
	* jv-lang.c (add_class_symbol): Use SYMBOL_SET_LINKAGE_NAME.
	* linespec.c (decode_line_2): Use SYMBOL_LINKAGE_NAME.
	* mdebugread.c (parse_symbol): Use SYMBOL_LINKAGE_NAME and
	SYMBOL_SET_LINKAGE_NAME.
	(mylookup_symbol): Use SYMBOL_LINKAGE_NAME.
	* minsyms.c (add_minsym_to_demangled_hash_table): Use
	SYMBOL_SEARCH_NAME.
	(lookup_minimal_symbol): Use SYMBOL_LINKAGE_NAME or
	SYMBOL_MATCHES_SEARCH_NAME, depending on the pass.
	* objfiles.h (ALL_OBJFILE_MSYMBOLS): Use SYMBOL_LINKAGE_NAME.
	* printcmd.c (build_address_symbolic): Use SYMBOL_LINKAGE_NAME.
	(address_info): Use SYMBOL_PRINT_NAME for messages and
	SYMBOL_LINKAGE_NAME for lookups.
	* sol-thread.c (info_cb): Use SYMBOL_PRINT_NAME for messages.
	* stabsread.c (patch_block_stabs, define_symbol)
	(read_type, read_enum_type, common_block_end)
	(cleanup_undefined_types_1, scan_file_globals): Use
	SYMBOL_LINKAGE_NAME, SYMBOL_SET_LINKAGE_NAME, ALL_OBJFILE_MSYMBOLS,
	and SYMBOL_PRINT_NAME.
	* stack.c (print_frame_args): Use SYMBOL_LINKAGE_NAME.
	(print_frame, frame_info): Use SYMBOL_PRINT_NAME for output.  Use
	cp_remove_params instead of cplus_demangle.
	(print_block_frame_labels, print_frame_arg_vars): Use
	SYMBOL_LINKAGE_NAME.
	* symmisc.c (dump_msymbols): Use ALL_OBJFILE_MSYMBOLS and
	SYMBOL_LINKAGE_NAME.
	(dump_symtab_1, print_symbol, print_partial_symbols)
	(maintenance_check_symtabs): Use SYMBOL_LINKAGE_NAME.
	* symtab.h (DEPRECATED_SYMBOL_NAME): Delete.
	(SYMBOL_SET_LINKAGE_NAME): New.
	(SYMBOL_SET_NAMES): Add a comment.
	* tracepoint.c (set_traceframe_context, validate_actionline)
	(collect_symbol, scope_info): Use SYMBOL_LINKAGE_NAME for
	lookups and SYMBOL_PRINT_NAME for output.
	* typeprint.c (typedef_print): Use SYMBOL_LINKAGE_NAME.
	* xcoffread.c (process_xcoff_symbol): Use SYMBOL_SET_LINKAGE_NAME.
@
text
@d256 1
a256 1
   DEFAULT_LPW.
d353 1
d361 1
d365 3
a367 5
      inferior_ptid = lwp_to_thread (inferior_ptid);
      if (PIDGET (inferior_ptid) == -1)
	inferior_ptid = main_ph.ptid;
      else
	add_thread (inferior_ptid);
d384 1
d423 1
a423 1
/* Wait for any threads to stop.  We may have to convert PIID from a
d464 2
a465 1
	  && !in_thread_list (rtnval))
d759 1
d764 2
d771 3
a773 6
      inferior_ptid = lwp_to_thread (inferior_ptid);
      if (PIDGET (inferior_ptid) == -1)
	inferior_ptid = main_ph.ptid;

      if (!in_thread_list (inferior_ptid))
	add_thread (inferior_ptid);
d827 1
d1372 1
a1372 1
  if (!in_thread_list (ptid))
@


1.65
log
@	Adjust all targets to new target_stop interface.

	* gnu-nat.c (gnu_stop): Add ptid argument.
	* go32-nat.c (go32_stop): Add ptid argument.
	(go32_create_inferior): Pass inferior_ptid to go32_stop.
	* hpux-thread.c (hpux_thread_stop): Add ptid argument.
	* monitor.c (monitor_stop): Add ptid argument.
	(monitor_open): Pass inferior_ptid to monitor_stop.
	(monitor_interrupt): Pass inferior_ptid to target_stop.
	(monitor_stop): Add ptid argument.
	* nto-procfs.c (nto_interrupt): Pass inferior_ptid to target_stop.
	(procfs_create_inferior): Add ptid argument.
	* procfs.c (procfs_stop): Add ptid argument.
	* remote-m32r-sdi.c (m32r_stop): Add ptid argument.
	* remote-sim.c (gdbsim_stop): Add ptid argument.
	* sol-thread.c (sol_thread_stop): Add ptid argument.
	* win32-nat.c (win32_stop): Add ptid argument.
@
text
@d1472 1
a1472 1
			     DEPRECATED_SYMBOL_NAME (msym));
d1484 1
a1484 1
			     DEPRECATED_SYMBOL_NAME (msym));
@


1.64
log
@        * sol-thread.c: Replace use of TM_I386SOL2_H by an expression
        that is true only on x86-solaris and x86_64-solaris.
        * procfs.c: Likewise. Move procfs_find_LDT_entry up together
        with proc_get_LDT_entry.
@
text
@d884 1
a884 1
sol_thread_stop (void)
d886 1
a886 1
  procfs_ops.to_stop ();
@


1.63
log
@        Inform about new thread in a single place.

        * thread.c (add_thread_silent): Renamed
        from add_thread.
        (print_thread_events): New variable definition.
        (show_print_thread_events): New function.
        (_initialize_thread): Add "set print thread-events" and
        "show print thread-events" commands.
        (add_thread): Announce new thread.
        * gdbthread.h (add_thread_silent): Declare.
        (print_thread_events): New variable declaration.
        * inf-ttrace.c (inf_ttrace_wait): Don't
        inform about new thread, as add_thread is always
        called too, and will take care of that.
        * infrun.c (handle_inferior_event): Likewise.
        * procfs.c (procfs_wait): Likewise.
        * remote.c (remote_currthread): Likewise.
        * sol-thread.c (sol_thread_wait): Likewise.
        * win32-nat.c (get_win32_debug_event): Likewise.
        * linux-thread-db.c (attach_thread): Likewise.
        Remove the verbose parameter.
        (check_event): Make detach_thread be verbose
        only if print_thread_events is set.
        * linux-nat.c (lin_lwp_attach_lwp): Don't inform
        about new thread.  This is called only from
        linux-thread-db.c:attach_thread, which will take care.
        Remove the verbose parameter.
        * linux-nat.h (lin_lwp_attach_lwp): Adjust prototype.
@
text
@d1286 1
a1286 1
#ifdef TM_I386SOL2_H
d1288 4
a1291 1
/* Reads the local descriptor table of a LWP.  */
d1317 1
a1317 1
#endif /* TM_I386SOL2_H */
@


1.63.2.1
log
@        * sol-thread.c: Replace use of TM_I386SOL2_H by an expression
        that is true only on x86-solaris and x86_64-solaris.
        * procfs.c: Likewise. Move procfs_find_LDT_entry up together
        with proc_get_LDT_entry.
@
text
@d1286 1
a1286 1
#if (defined(__i386__) || defined(__x86_64__)) && defined (sun)
d1288 1
a1288 4
/* Reads the local descriptor table of a LWP.

   This function is necessary on x86-solaris only.  Without it, the loading
   of libthread_db would fail because of ps_lgetLDT being undefined.  */
d1314 1
a1314 1
#endif
@


1.62
log
@	Updated copyright notices for most files.
@
text
@d464 1
a464 4
	{
	  printf_filtered ("[New %s]\n", target_pid_to_str (rtnval));
	  add_thread (rtnval);
	}
@


1.61
log
@2007-10-24  Pedro Alves  <pedro_alves@@portugalmail.pt>

	PR gdb/2341
	* sol-thread.c (sol_thread_fetch_registers): Work around gcc 3.4
	alias warning bug.
@
text
@d4 1
a4 1
   2007 Free Software Foundation, Inc.
@


1.60
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d487 3
d536 2
a537 2
  supply_gregset (regcache, (const gdb_gregset_t *) &gregset);
  supply_fpregset (regcache, (const gdb_fpregset_t *) &fpregset);
@


1.60.2.1
log
@2007-10-24  Pedro Alves  <pedro_alves@@portugalmail.pt>

	PR gdb/2341
	* sol-thread.c (sol_thread_fetch_registers): Work around gcc 3.4
	alias warning bug.
@
text
@a486 3
  gdb_gregset_t *gregset_p = &gregset;
  gdb_fpregset_t *fpregset_p = &fpregset;

d533 2
a534 2
  supply_gregset (regcache, (const gdb_gregset_t *) gregset_p);
  supply_fpregset (regcache, (const gdb_fpregset_t *) fpregset_p);
@


1.59
log
@	* regcache.c (struct regcache): Add ptid_t member.
	(regcache_xmalloc): Initialize it.
	(regcache_cpy_no_passthrough): Do not refer to current_regcache.
	(regcache_dup): Likewise.
	(regcache_dup_no_passthrough): Likewise.
	(current_regcache): Make static.
	(registers_ptid): Remove variable.
	(get_thread_regcache): New function.
	(get_current_regcache): New function.
	(registers_changed): Implement by freeing current regcache.
	(regcache_raw_read): Do not refer to current_regcache.  Set
	inferior_ptid to regcache->ptid while calling target routines.
	(regcache_raw_write): Likewise.
	(regcache_raw_supply): Do not refer to current_regcache.
	(read_pc_pid): Use thread regcache.  Do not modify inferior_ptid.
	(write_pc_pid): Likewise.
	(build_regcache): Remove.
	(_initialize_regcache): Do not call DEPRECATED_REGISTER_GDBARCH_SWAP
	or deprecated_register_gdbarch_swap.  Do not initialize
	registers_ptid.
	* regcache.h (get_current_regcache): Add prototype.
	(get_thread_regcache): Likewise.
	(current_regcache): Remove declaration.

	* corelow.c (core_open): Replace current_regcache by
	get_current_regcache ().
	* frame.c (frame_pop): Likewise.
	(put_frame_register): Likewise.
	(get_current_frame, create_new_frame): Likewise.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Likewise.
	* stack.c (return_command): Likewise.
	* infcall.c (call_function_by_hand): Likewise.
	* infrun.c (resume): Likewise.
	(save_inferior_status, restore_inferior_status): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	(fork_save_infrun_state): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* i386fbsd-nat.c (i386fbsd_resume): Likewise.
	* monitor.c (monitor_wait): Likewise.
	* remote.c (remote_wait): Likewise.
	* remote-mips.c (mips_wait): Likewise.

	* bsd-kvm.c (bsd_kvm_open): Likewise
	(bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Likewise.
	* fbsd-nat.c (fbsd_make_corefile_notes): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint): Likewise.
	(ia64_linux_stopped_data_address): Likewise.

	* frv-tdep.c (frv_fdpic_loadmap_addresses): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* mep-tdep.c (current_me_module, current_options): Likewise.
	* mips-tdep.c (deprecated_mips_set_processor_regs_hack): Likewise.

	* linux-nat.c (linux_nat_do_thread_registers): Use thread
	regcache instead of current_regcache.  Call target_fetch_registers.
	(linux_nat_corefile_thread_callback): Update call site.
	(linux_nat_do_registers): Likewise.
	* procfs.c (procfs_do_thread_registers): Use thread regcache instead
	of current_regcache.
	(procfs_make_note_section): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.58
log
@	* gdb_proc_service.h (paddr_t): Delete typedef.
	* proc-service.c (ps_addr_to_core_addr, core_addr_to_ps_addr): New.
	(ps_xfer_memory): Take a psaddr_t.  Use ps_addr_to_core_addr.
	(ps_pglobal_lookup): Take a psaddr_t *.  Use core_addr_to_ps_addr.
	(ps_pdread, ps_pdwrite, ps_ptread, ps_ptwrite): Take a psaddr_t.
	* sol-thread.c (gdb_ps_addr_t): Use psaddr_t instead of paddr_t.
	* Makefile.in (proc-service.o): Update.
@
text
@d1090 1
d1095 1
d1098 1
a1098 1
    procfs_ops.to_fetch_registers (current_regcache, -1);
d1100 2
a1101 2
    orig_core_ops.to_fetch_registers (current_regcache, -1);
  fill_gregset (current_regcache, (gdb_gregset_t *) gregset, -1);
d1115 1
d1120 1
d1122 1
a1122 1
  supply_gregset (current_regcache, (const gdb_gregset_t *) gregset);
d1124 1
a1124 1
    procfs_ops.to_store_registers (current_regcache, -1);
d1126 1
a1126 1
    orig_core_ops.to_store_registers (current_regcache, -1);
d1226 1
d1231 1
d1234 1
a1234 1
    procfs_ops.to_fetch_registers (current_regcache, -1);
d1236 2
a1237 2
    orig_core_ops.to_fetch_registers (current_regcache, -1);
  fill_fpregset (current_regcache, (gdb_fpregset_t *) fpregset, -1);
d1251 1
d1256 1
d1258 1
a1258 1
  supply_fpregset (current_regcache, (const gdb_fpregset_t *) fpregset);
d1260 1
a1260 1
    procfs_ops.to_store_registers (current_regcache, -1);
d1262 1
a1262 1
    orig_core_ops.to_store_registers (current_regcache, -1);
@


1.57
log
@doc/ChangeLog:

	* observer.texi (GDB Observers): New observer "new_objfile".

ChangeLog:

	* observer.sh: Add "struct objfile" forward declaration.
	* target.h (deprecated_target_new_objfile_hook): Remove.
	* symfile.c (deprecated_target_new_objfile_hook): Remove.
	(clear_symtab_users): Call observer_notify_new_objfile.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	* rs6000-nat.c: Include "observer.h".
	(vmap_ldinfo): Call observer_notify_new_objfile.
	(xcoff_relocate_core): Likewise.
	* remote.c (remote_new_objfile_chain): Remove.
	(remote_new_objfile): Do not call remote_new_objfile_chain.
	(_initialize_remote): Use observer_attach_new_objfile.
	* tui/tui-hooks.c (tui_target_new_objfile_chain): Remove.
	(tui_new_objfile_hook): Do not call tui_target_new_objfile_chain.
	(_initialize_tui_hooks): Use observer_attach_new_objfile.
	* aix-thread.c: Include "observer.h".
	(target_new_objfile_chain): Remove.
	(new_objfile): Do not call target_new_objfile_chain.
	(_initialize_aix_thread): Use observer_attach_new_objfile.
	* hpux-thread.c: Include "observer.h"
	(target_new_objfile_chain): Remove.
	(hpux_thread_new_objfile): Make static.  Do not call
	target_new_objfile_chain.
	(_initialize_hpux_thread): Use observer_attach_new_objfile.
	* linux-thread-db.c: Include "observer.h".
	(target_new_objfile_chain): Remove.
	(thread_db_new_objfile): Do not call target_new_objfile_chain.
	(_initialize_thread_db): Use observer_attach_new_objfile.
	* sol-thread.c: Include "observer.h".
	(target_new_objfile_chain): Remove.
	(sol_thread_new_objfile): Make static.  Do not call
	target_new_objfile_chain.
	(_initialize_sol_thread): Use observer_attach_new_objfile.
	* Makefile.in (aix-thread.o, hpux-thread.o, linux-thread-db.o,
	rs6000-nat.o, sol-thread.o, tui-hooks.o): Add dependency on
	$(observer_h).
@
text
@d913 1
a913 1
typedef paddr_t gdb_ps_addr_t;
@


1.56
log
@	* target.h (struct target_ops): Add REGCACHE parameter to
	to_prepare_to_store.
	(target_prepare_to_store): Likewise.
	* target.c (debug_to_prepare_to_store): Add REGCACHE parameter.
	(update_current_target): Adapt prepare_to_store de_fault rule.

	* regcache.c (regcache_raw_write): Pass regcache to
	target_prepare_to_store.

	* inftarg.c (child_prepare_to_store): Add REGCACHE parameter.
	Do not call CHILD_PREPARE_TO_STORE.
	* gnu-nat.c (gnu_prepare_to_store): Likewise.
	* procfs.c (procfs_prepare_to_store): Likewise.

	* inf-child.c (inf_child_prepare_to_store): Add REGCACHE parameter.
	* go32-nat.c (go32_prepare_to_store): Likewise.
	* monitor.c (monitor_prepare_to_store): Likewise.
	* nto-procfs.c (procfs_prepare_to_store): Likewise.
	* remote-m32r-sdi.c (m32r_prepare_to_store): Likewise.
	* remote-mips.c (mips_prepare_to_store): Likewise.
	* remote-sim.c (gdbsim_prepare_to_store): Likewise.
	* win32-nat.c (win32_prepare_to_store): Likewise.

	* remote.c (remote_prepare_to_store): Add REGCACHE parameter.
	Use it instead of current_regcache.

	* hpux-thread.c (hpux_thread_prepare_to_store): Add REGCACHE
	parameter.  Pass it on to next target.
	* sol-thread.c (sol_thread_prepare_to_store): Likewise.
@
text
@d69 1
d781 1
a781 1
   the library gets mapped and the symbol table is read in.
d783 1
a783 8
   This new_objfile event is managed by a chained function pointer.
   It is the callee's responsability to call the next client on the
   chain.  */

/* Saved pointer to previous owner of the new_objfile event. */
static void (*target_new_objfile_chain) (struct objfile *);

void
d791 1
a791 1
      goto quit;
d797 1
a797 1
    goto quit;
d807 1
a807 1
      goto quit;
d812 1
a812 1
    goto quit;
d816 1
a816 1
      goto quit;
a819 5

quit:
  /* Call predecessor on chain, if any.  */
  if (target_new_objfile_chain)
    target_new_objfile_chain (objfile);
d1659 1
a1659 2
  target_new_objfile_chain = deprecated_target_new_objfile_hook;
  deprecated_target_new_objfile_hook  = sol_thread_new_objfile;
@


1.55
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d652 1
a652 1
sol_thread_prepare_to_store (void)
d654 1
a654 1
  procfs_ops.to_prepare_to_store ();
@


1.54
log
@	* gregset.h (struct regcache): Add forward declaration.
	(supply_gregset): Add REGCACHE parameter, make GREGS const.
	(supply_fpregset): Add REGCACHE parameter, make FPREGS const.
	(supply_fpxregset): Add REGCACHE parameter, make FPXREGS const.
	(fill_gregset): Add REGCACHE parameter.
	(fill_fpregset): Likewise.
	(fill_fpxregset): Likewise.

	Update all definitions accordingly:
	* alphabsd-nat.c, alpha-linux-nat.c, alpha-nat.c, amd64-linux-nat.c,
	arm-linux-nat.c, hppa-linux-nat.c, i386gnu-nat.c, i386-linux-nat.c,
	i386-sol2-nat.c, i386v4-nat.c, ia64-linux-nat.c, irix5-nat.c,
	m32r-linux-nat.c, m68klinux-nat.c, mips-linux-nat.c, ppc-linux-nat.c,
	s390-nat.c, sparc64-linux-nat.c, sparc-linux-nat.c, sparc-sol2-nat.c
	(supply_gregset): Add REGCACHE parameter, use it instead of
	current_regcache.  Make GREGSETP parameter const, adapt casts.
	(supply_fpregset): Add REGCACHE parameter, use it instead of
	current_regcache.  Make FPREGSETP parameter const, adapt casts.
	(fill_gregset): Add REGCACHE parameter, use it instead of
	current_regcache.
	(fill_fpregset): Likewise.

	Update all callers to pass in current_regcache as the new argument:
	* core-regset.c: Include "regcache.h".
	(fetch_core_registers): Update supply_gregset,and supply_fpregset calls.
	* procfs.c: Include "regcache.h".
	(procfs_fetch_registers): Update supply_gregset, supply_fpregset calls.
	(procfs_store_registers): Update fill_gregset, fill_fpregset calls.
	(procfs_do_thread_registers): Likewise.
	(procfs_make_note_section): Likewise.
	* proc-service.c: Include "regcache.h".
	(ps_lgetregs): Update fill_gregset call.
	(ps_lsetregs): Update supply_gregset call.
	(ps_lgetfpregs): Update fill_fpregset call.
	(ps_lsetfpregs): Update supply_fpregset call.
	* sol-thread.c (sol_thread_fetch_registers): Update supply_gregset,
	supply_fpregset calls.
	(sol_thread_store_registers): Update fill_gregset, fill_fpregset calls.
	(ps_lgetregs): Update fill_gregset call.
	(ps_lsetregs): Update supply_gregset call.
	(ps_lgetfpregs): Update fill_fpregset call.
	(ps_lsetfpregs): Update supply_fpregset call.

	* linux-nat.c (linux_nat_do_thread_registers): Update fill_gregset,
	fill_fpregset, and fill_fpxregset calls.
	* i386-linux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.
	(fetch_fpxregs): Update supply_fpxregset call.
	(store_fpxregs): Update fill_fpxregset call.
	* m32r-linux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	* m68klinux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.
	(fetch_core_registers): Update supply_gregset, supply_fpregset calls.
	* s390-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.

	* Makefile.in (core-regset.o, procfs.o, proc-service.o): Update
	dependencies.
@
text
@d481 1
a481 1
sol_thread_fetch_registers (int regnum)
d497 1
a497 1
	procfs_ops.to_fetch_registers (regnum);
d499 1
a499 1
	orig_core_ops.to_fetch_registers (regnum);
d534 2
a535 2
  supply_gregset (current_regcache, (const gdb_gregset_t *) &gregset);
  supply_fpregset (current_regcache, (const gdb_fpregset_t *) &fpregset);
d556 1
a556 1
sol_thread_store_registers (int regnum)
d571 1
a571 1
      procfs_ops.to_store_registers (regnum);
d589 1
a589 1
      regcache_raw_collect (current_regcache, regnum, old_value);
d601 1
a601 1
      regcache_raw_supply (current_regcache, regnum, old_value);
d621 2
a622 2
  fill_gregset (current_regcache, (gdb_gregset_t *) &gregset, regnum);
  fill_fpregset (current_regcache, (gdb_fpregset_t *) &fpregset, regnum);
d1107 1
a1107 1
    procfs_ops.to_fetch_registers (-1);
d1109 1
a1109 1
    orig_core_ops.to_fetch_registers (-1);
d1131 1
a1131 1
    procfs_ops.to_store_registers (-1);
d1133 1
a1133 1
    orig_core_ops.to_store_registers (-1);
d1239 1
a1239 1
    procfs_ops.to_fetch_registers (-1);
d1241 1
a1241 1
    orig_core_ops.to_fetch_registers (-1);
d1263 1
a1263 1
    procfs_ops.to_store_registers (-1);
d1265 1
a1265 1
    orig_core_ops.to_store_registers (-1);
@


1.53
log
@Copyright updates for 2007.
@
text
@d534 2
a535 2
  supply_gregset ((gdb_gregset_t *) &gregset);
  supply_fpregset ((gdb_fpregset_t *) &fpregset);
d621 2
a622 2
  fill_gregset ((gdb_gregset_t *) &gregset, regnum);
  fill_fpregset ((gdb_fpregset_t *) &fpregset, regnum);
d1110 1
a1110 1
  fill_gregset ((gdb_gregset_t *) gregset, -1);
d1129 1
a1129 1
  supply_gregset ((gdb_gregset_t *) gregset);
d1242 1
a1242 1
  fill_fpregset ((gdb_fpregset_t *) fpregset, -1);
d1261 1
a1261 1
  supply_fpregset ((gdb_fpregset_t *) fpregset);
@


1.52
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@d3 2
a4 2
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005 Free Software Foundation, Inc.
@


1.51
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d1527 1
a1527 1
ignore (CORE_ADDR addr, gdb_byte *contents)
@


1.51.8.1
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d1527 1
a1527 1
ignore (CORE_ADDR addr, struct bp_location *bpt)
@


1.50
log
@* sol-thread.c (sol_thread_xfer_memory): Change type of second
argument to `gdb_byte *'.
(sol_thread_xfer_partial): Change type of readbuf and writebuf
arguments to `gdb_byte *'.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.49
log
@* sol-thread.c (ignore): Change last argument to `gdb_byte.'
@
text
@d664 2
a665 2
sol_thread_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int dowrite,
			struct mem_attrib *attrib,
d701 3
a703 2
			  const char *annex, void *readbuf,
			  const void *writebuf, ULONGEST offset, LONGEST len)
@


1.48
log
@* sol-thread.c: Include "solib.h".
(sol_thread_attach): Use solib_add instead of SOLIB_ADD.
* Makefile.in (sol-thread.o): Update dependencies.
@
text
@d1526 1
a1526 1
ignore (CORE_ADDR addr, char *contents)
@


1.47
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d67 1
d357 1
a357 1
  SOLIB_ADD ((char *) 0, from_tty, (struct target_ops *) 0, auto_solib_add);
@


1.46
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d1661 1
a1661 1
	   "Show info on Solaris user threads.\n", &maintenanceinfolist);
@


1.45
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@d276 1
a276 1
    error ("thread_to_lwp: td_ta_map_id2thr %s", td_err_string (val));
d282 1
a282 1
    error ("thread_to_lwp: td_thr_get_info: %s", td_err_string (val));
d288 1
a288 1
      error ("thread_to_lwp: thread state not active: %s",
d319 1
a319 1
    error ("lwp_to_thread: td_ta_map_lwp2thr: %s.", td_err_string (val));
d325 1
a325 1
    error ("lwp_to_thread: td_thr_validate: %s.", td_err_string (val));
d331 1
a331 1
    error ("lwp_to_thread: td_thr_get_info: %s.", td_err_string (val));
d411 1
a411 1
	error ("This version of Solaris can't start inactive threads.");
d413 1
a413 1
	warning ("Specified thread %ld seems to have terminated",
d445 1
a445 1
	error ("This version of Solaris can't start inactive threads.");
d447 1
a447 1
	warning ("Specified thread %ld seems to have terminated",
d505 1
a505 1
    error ("sol_thread_fetch_registers: thread == 0");
d509 1
a509 1
    error ("sol_thread_fetch_registers: td_ta_map_id2thr: %s",
d516 1
a516 1
    error ("sol_thread_fetch_registers: td_thr_getgregs %s",
d526 1
a526 1
    error ("sol_thread_fetch_registers: td_thr_getfpregs %s",
d540 1
a540 1
    error ("sol_thread_fetch_registers: td_thr_getxregsize %s",
d548 1
a548 1
	error ("sol_thread_fetch_registers: td_thr_getxregs %s",
d579 1
a579 1
    error ("sol_thread_store_registers: td_ta_map_id2thr %s",
d592 1
a592 1
	error ("sol_thread_store_registers: td_thr_getgregs %s",
d596 1
a596 1
	error ("sol_thread_store_registers: td_thr_getfpregs %s",
d606 1
a606 1
	error ("sol_thread_store_registers: td_thr_getxregsize %s",
d614 1
a614 1
	    error ("sol_thread_store_registers: td_thr_getxregs %s",
d625 1
a625 1
    error ("sol_thread_store_registers: td_thr_setgregs %s",
d629 1
a629 1
    error ("sol_thread_store_registers: td_thr_setfpregs %s",
d636 1
a636 1
    error ("sol_thread_store_registers: td_thr_getxregsize %s",
d810 1
a810 1
      warning ("sol_thread_new_objfile: td_init: %s", td_err_string (val));
d819 1
a819 1
      warning ("sol_thread_new_objfile: td_ta_new: %s", td_err_string (val));
d1037 1
a1037 1
	    warning ("rw_common (): unable to read at addr 0x%lx",
d1040 1
a1040 1
	    warning ("rw_common (): unable to write at addr 0x%lx",
d1494 1
a1494 1
    warning ("info sol-thread: failed to get info for thread.");
@


1.44
log
@2004-07-23  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_collect instead of regcache_collect.
	* regcache.h (regcache_collect): Delete declaration.
	* regcache.c (regcache_colect): Delete function.
	* win32-nat.c (do_child_store_inferior_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_fill_reg): Update.
	* rs6000-nat.c (store_register): Update.
	* remote.c (store_register_using_P, remote_store_registers): Update.
	* ppcnbsd-tdep.c (ppcnbsd_fill_reg): Update.
	* ppc-linux-nat.c (store_altivec_register, store_spe_register)
	(fill_vrregset, store_spe_registers, fill_gregset)
	(fill_gregset): Update.
	* nto-procfs.c (procfs_store_registers): Update.
	* mipsnbsd-tdep.c (mipsnbsd_fill_reg): Update.
	* mips-linux-tdep.c (fill_gregset, mips64_fill_gregset): Update.
	* m68klinux-nat.c (store_register, fill_gregset): Update.
	* m68k-tdep.c (fill_gregset): Update.
	* infptrace.c (store_register): Update.
	* i386-nto-tdep.c (i386nto_regset_fill): Update.
	* i386-linux-nat.c (store_register, fill_gregset): Update.
	* hppa-linux-nat.c (fill_gregset): Update.
	* go32-nat.c (store_register): Update.
	* armnbsd-nat.c (store_register, store_regs, store_fp_register)
	(store_fp_regs): Update.
	* arm-linux-nat.c (store_nwfpe_single, store_nwfpe_double)
	(store_nwfpe_extended, store_fpregister, store_fpregs)
	(store_register, store_regs, fill_gregset, fill_fpregset): Update.
	* alpha-tdep.c (alpha_fill_int_regs, alpha_fill_fp_regs): Update.
	* aix-thread.c (fill_gprs64, fill_fprs, fill_sprs64, fill_sprs32)
	(store_regs_user_thread, store_regs_kernel_thread): Update.
@
text
@d683 2
a684 2
    retval = procfs_ops.to_xfer_memory (memaddr, myaddr, len,
					dowrite, attrib, target);
d686 2
a687 2
    retval = orig_core_ops.to_xfer_memory (memaddr, myaddr, len,
					   dowrite, attrib, target);
d1017 2
a1018 2
	cc = procfs_ops.to_xfer_memory (addr, buf, size,
					dowrite, 0, &procfs_ops);
d1020 2
a1021 2
	cc = orig_core_ops.to_xfer_memory (addr, buf, size,
					   dowrite, 0, &core_ops);
d1544 1
a1544 1
  sol_thread_ops.to_xfer_memory = sol_thread_xfer_memory;
d1587 1
a1587 1
  sol_core_ops.to_xfer_memory = sol_thread_xfer_memory;
@


1.43
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d588 1
a588 1
      regcache_collect (regnum, old_value);
@


1.42
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@d600 1
a600 1
      supply_register (regnum, old_value);
@


1.41
log
@* sol-thread.c Update copyright year.  Fix various coding
standards violations.  Tweak a few comments.
(td_err_string, td_state_string, thread_to_lwp, lwp_to_thread):
Delete prototypes.
@
text
@d753 2
a754 1
sol_thread_create_inferior (char *exec_file, char *allargs, char **env)
d756 1
a756 1
  procfs_ops.to_create_inferior (exec_file, allargs, env);
@


1.40
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d1 3
a3 2
/* Low level interface for debugging Solaris threads for GDB, the GNU debugger.
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d24 2
a25 2
   machine-independent parts of GDB and the /proc interface (procfs.c) to
   provide access to the Solaris user-mode thread implementation.
d27 14
a40 12
   Solaris threads are true user-mode threads, which are invoked via the thr_*
   and pthread_* (native and Posix respectivly) interfaces.  These are mostly
   implemented in user-space, with all thread context kept in various
   structures that live in the user's heap.  These should not be confused with
   lightweight processes (LWPs), which are implemented by the kernel, and
   scheduled without explicit intervention by the process.

   Just to confuse things a little, Solaris threads (both native and Posix) are
   actually implemented using LWPs.  In general, there are going to be more
   threads than LWPs.  There is no fixed correspondence between a thread and an
   LWP.  When a thread wants to run, it gets scheduled onto the first available
   LWP and can therefore migrate from one LWP to another as time goes on.  A
d43 10
a52 9
   To make it possible to mess with threads, Sun provides a library called
   libthread_db.so.1 (not to be confused with libthread_db.so.0, which doesn't
   have a published interface).  This interface has an upper part, which it
   provides, and a lower part which I provide.  The upper part consists of the
   td_* routines, which allow me to find all the threads, query their state,
   etc...  The lower part consists of all of the ps_*, which are used by the
   td_* routines to read/write memory, manipulate LWPs, lookup symbols, etc...
   The ps_* routines actually do most of their work by calling functions in
   procfs.c.  */
d88 3
a90 3
/* This struct is defined by us, but mainly used for the proc_service interface.
   We don't have much use for it, except as a handy place to get a real pid
   for memory accesses.  */
d93 3
a95 3
  {
    ptid_t ptid;
  };
d98 4
a101 4
  {
    int num;
    char *str;
  };
a106 3
static char *td_err_string (td_err_e errcode);
static char *td_state_string (td_thr_state_e statecode);
static ptid_t thread_to_lwp (ptid_t thread_id, int default_lwp);
a107 1
static ptid_t lwp_to_thread (ptid_t lwp);
d114 2
a115 2
/* Default definitions: These must be defined in tm.h
   if they are to be shared with a process module such as procfs.  */
d127 1
a127 1
/* Pointers to routines from lithread_db resolved by dlopen() */
d129 49
a177 67
static void     (*p_td_log)               (const int on_off);
static td_err_e (*p_td_ta_new)            (const struct ps_prochandle * ph_p,
					   td_thragent_t ** ta_pp);
static td_err_e (*p_td_ta_delete)         (td_thragent_t * ta_p);
static td_err_e (*p_td_init)              (void);
static td_err_e (*p_td_ta_get_ph)         (const td_thragent_t * ta_p,
					   struct ps_prochandle ** ph_pp);
static td_err_e (*p_td_ta_get_nthreads)   (const td_thragent_t * ta_p,
					   int *nthread_p);
static td_err_e (*p_td_ta_tsd_iter)       (const td_thragent_t * ta_p,
					   td_key_iter_f * cb,
					   void *cbdata_p);
static td_err_e (*p_td_ta_thr_iter)       (const td_thragent_t * ta_p,
					   td_thr_iter_f * cb,
					   void *cbdata_p,
					   td_thr_state_e state,
					   int ti_pri,
					   sigset_t * ti_sigmask_p,
					   unsigned ti_user_flags);
static td_err_e (*p_td_thr_validate)      (const td_thrhandle_t * th_p);
static td_err_e (*p_td_thr_tsd)           (const td_thrhandle_t * th_p,
					   const thread_key_t key,
					   void **data_pp);
static td_err_e (*p_td_thr_get_info)      (const td_thrhandle_t * th_p,
					   td_thrinfo_t * ti_p);
static td_err_e (*p_td_thr_getfpregs)     (const td_thrhandle_t * th_p,
					   prfpregset_t * fpregset);
static td_err_e (*p_td_thr_getxregsize)   (const td_thrhandle_t * th_p,
					   int *xregsize);
static td_err_e (*p_td_thr_getxregs)      (const td_thrhandle_t * th_p,
					   const caddr_t xregset);
static td_err_e (*p_td_thr_sigsetmask)    (const td_thrhandle_t * th_p,
					   const sigset_t ti_sigmask);
static td_err_e (*p_td_thr_setprio)       (const td_thrhandle_t * th_p,
					   const int ti_pri);
static td_err_e (*p_td_thr_setsigpending) (const td_thrhandle_t * th_p,
					   const uchar_t ti_pending_flag,
					   const sigset_t ti_pending);
static td_err_e (*p_td_thr_setfpregs)     (const td_thrhandle_t * th_p,
					   const prfpregset_t * fpregset);
static td_err_e (*p_td_thr_setxregs)      (const td_thrhandle_t * th_p,
					   const caddr_t xregset);
static td_err_e (*p_td_ta_map_id2thr)     (const td_thragent_t * ta_p,
					   thread_t tid,
					   td_thrhandle_t * th_p);
static td_err_e (*p_td_ta_map_lwp2thr)    (const td_thragent_t * ta_p,
					   lwpid_t lwpid,
					   td_thrhandle_t * th_p);
static td_err_e (*p_td_thr_getgregs)      (const td_thrhandle_t * th_p,
					   prgregset_t regset);
static td_err_e (*p_td_thr_setgregs)      (const td_thrhandle_t * th_p,
					   const prgregset_t regset);

/*

   LOCAL FUNCTION

   td_err_string - Convert a thread_db error code to a string

   SYNOPSIS

   char * td_err_string (errcode)

   DESCRIPTION

   Return the thread_db error string associated with errcode.  If errcode
   is unknown, then return a message.
d179 2
a180 1
 */
d185 1
a185 2
  static struct string_map
    td_err_table[] =
d187 21
a207 21
    {TD_OK, "generic \"call succeeded\""},
    {TD_ERR, "generic error."},
    {TD_NOTHR, "no thread can be found to satisfy query"},
    {TD_NOSV, "no synch. variable can be found to satisfy query"},
    {TD_NOLWP, "no lwp can be found to satisfy query"},
    {TD_BADPH, "invalid process handle"},
    {TD_BADTH, "invalid thread handle"},
    {TD_BADSH, "invalid synchronization handle"},
    {TD_BADTA, "invalid thread agent"},
    {TD_BADKEY, "invalid key"},
    {TD_NOMSG, "td_thr_event_getmsg() called when there was no message"},
    {TD_NOFPREGS, "FPU register set not available for given thread"},
    {TD_NOLIBTHREAD, "application not linked with libthread"},
    {TD_NOEVENT, "requested event is not supported"},
    {TD_NOCAPAB, "capability not available"},
    {TD_DBERR, "Debugger service failed"},
    {TD_NOAPLIC, "Operation not applicable to"},
    {TD_NOTSD, "No thread specific data for this thread"},
    {TD_MALLOC, "Malloc failed"},
    {TD_PARTIALREG, "Only part of register set was written/read"},
    {TD_NOXREGS, "X register set not available for given thread"}
d217 1
a217 1
  sprintf (buf, "Unknown thread_db error code: %d", errcode);
a220 15

/*

   LOCAL FUNCTION

   td_state_string - Convert a thread_db state code to a string

   SYNOPSIS

   char * td_state_string (statecode)

   DESCRIPTION

   Return the thread_db state string associated with statecode.  If
   statecode is unknown, then return a message.
d222 2
a223 1
 */
d228 1
a228 2
  static struct string_map
    td_thr_state_table[] =
d230 8
a237 8
    {TD_THR_ANY_STATE, "any state"},
    {TD_THR_UNKNOWN, "unknown"},
    {TD_THR_STOPPED, "stopped"},
    {TD_THR_RUN, "run"},
    {TD_THR_ACTIVE, "active"},
    {TD_THR_ZOMBIE, "zombie"},
    {TD_THR_SLEEP, "sleep"},
    {TD_THR_STOPPED_ASLEEP, "stopped asleep"}
d239 2
a240 1
  const int td_thr_state_table_size = sizeof td_thr_state_table / sizeof (struct string_map);
d248 1
a248 1
  sprintf (buf, "Unknown thread_db state code: %d", statecode);
a252 3
/*

   LOCAL FUNCTION
d254 3
a256 1
   thread_to_lwp - Convert a Posix or Solaris thread id to a LWP id.
d258 1
a258 15
   SYNOPSIS

   tpid_t thread_to_lwp (thread_id, default_lwp)

   DESCRIPTION

   This function converts a Posix or Solaris thread id to a lightweight
   process id.  If thread_id is non-existent, that's an error.  If it's
   an inactive thread, then we return default_lwp.

   NOTES

   This function probably shouldn't call error()...

 */
d268 1
a268 1
    return thread_id;		/* It's already an LWP id */
d270 1
a270 1
  /* It's a thread.  Convert to lwp */
d274 1
a274 1
    return pid_to_ptid (-1);		/* thread must have terminated */
d280 1
a280 1
    return pid_to_ptid (-1);		/* thread must have terminated */
a293 2

/*
d295 2
a296 1
   LOCAL FUNCTION
d298 1
a298 16
   lwp_to_thread - Convert a LWP id to a Posix or Solaris thread id.

   SYNOPSIS

   int lwp_to_thread (lwp_id)

   DESCRIPTION

   This function converts a lightweight process id to a Posix or Solaris
   thread id.  If thread_id is non-existent, that's an error.

   NOTES

   This function probably shouldn't call error()...

 */
d308 1
a308 1
    return lwp;			/* It's already a thread id */
d310 1
a310 1
  /* It's an lwp.  Convert it to a thread id.  */
d313 1
a313 1
    return pid_to_ptid (-1);	/* defunct lwp */
d317 1
a317 1
    return pid_to_ptid (-1);	/* thread must have terminated */
d323 1
a323 2
    return lwp;			/* libthread doesn't know about it;
				   just return lwp */
d329 1
a329 1
    return pid_to_ptid (-1);	/* thread must have terminated */
d337 3
a339 2
/* Most target vector functions from here on actually just pass through to
   procfs.c, as they don't need to do anything specific for threads.  */
d347 2
a348 2
/* Attach to process PID, then initialize for debugging it
   and wait for the trace-trap that results from attaching.  */
d355 1
a355 1
  /* Must get symbols from solibs before libthread_db can run! */
d361 1
a361 1
      main_ph.ptid = inferior_ptid;		/* Save for xfer_memory */
d369 3
a371 1
  /* XXX - might want to iterate over all the threads and register them. */
d374 6
a379 7
/* Take a program previously attached to and detaches it.
   The program resumes execution and will no longer stop
   on signals, etc.  We'd better not have left any breakpoints
   in the program or it'll die when it hits one.  For this
   to work, it may be necessary for the process to have been
   previously attached.  It *might* work if the program was
   started via the normal ptrace (PTRACE_TRACEME).  */
d389 4
a392 4
/* Resume execution of process PID.  If STEP is nozero, then
   just single step it.  If SIGNAL is nonzero, restart it with that
   signal activated.  We may have to convert pid from a thread-id to an LWP id
   for procfs.  */
d410 1
a410 1
      if (PIDGET (ptid) == -2)		/* Inactive thread */
d422 2
a423 2
/* Wait for any threads to stop.  We may have to convert PID from a thread id
   to a LWP id, and vice versa on the way out.  */
d444 1
a444 1
      if (PIDGET (ptid) == -2)		/* Inactive thread */
d455 1
a455 1
      /* Map the LWP of interest back to the appropriate thread ID */
d460 1
a460 1
      /* See if we have a new thread */
d470 3
a472 3
  /* During process initialization, we may get here without the thread package
     being initialized, since that can only happen after we've found the shared
     libs.  */
d480 1
a480 1
sol_thread_fetch_registers (int regno)
d493 2
a494 1
    {				/* LWP: pass the request on to procfs.c */
d496 1
a496 1
	procfs_ops.to_fetch_registers (regno);
d498 1
a498 1
	orig_core_ops.to_fetch_registers (regno);
d502 1
a502 2
  /* Solaris thread: convert inferior_ptid into a td_thrhandle_t */

a503 1

d505 1
a505 1
    error ("sol_thread_fetch_registers:  thread == 0");
d512 1
a512 1
  /* Get the integer regs */
d515 1
a515 2
  if (val != TD_OK
      && val != TD_PARTIALREG)
d519 2
a520 2
  /* For the sparc, TD_PARTIALREG means that only i0->i7, l0->l7, pc and sp
     are saved (by a thread context switch).  */
d522 1
a522 1
  /* And, now the fp regs */
d525 1
a525 2
  if (val != TD_OK
      && val != TD_NOFPREGS)
d529 3
a531 3
/* Note that we must call supply_{g fp}regset *after* calling the td routines
   because the td routines call ps_lget* which affect the values stored in the
   registers array.  */
d533 1
a533 1
  supply_gregset  ((gdb_gregset_t *)  &gregset);
d537 1
a537 1
/* thread_db doesn't seem to handle this right */
d555 1
a555 1
sol_thread_store_registers (int regno)
d560 1
a560 1
  prgregset_t  gregset;
d568 3
a570 2
    {				/* LWP: pass the request on to procfs.c */
      procfs_ops.to_store_registers (regno);
d574 1
a574 2
  /* Solaris thread: convert inferior_ptid into a td_thrhandle_t */

d582 3
a584 2
  if (regno != -1)
    {				/* Not writing all the regs */
d588 1
a588 1
      regcache_collect (regno, old_value);
d600 1
a600 1
      supply_register (regno, old_value);
d603 1
a603 1
/* thread_db doesn't seem to handle this right */
d620 2
a621 2
  fill_gregset  ((gdb_gregset_t *)  &gregset,  regno);
  fill_fpregset ((gdb_fpregset_t *) &fpregset, regno);
d633 1
a633 1
/* thread_db doesn't seem to handle this right */
d639 2
a640 2
  /* Should probably do something about writing the xregs here, but what are
     they? */
d645 4
a648 4
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */
d660 1
a660 1
   Returns the number of bytes transferred. */
d672 9
a680 4
  if (is_thread (inferior_ptid) ||	/* A thread */
      !target_thread_alive (inferior_ptid))	/* An lwp, but not alive */
    inferior_ptid = procfs_first_available ();	/* Find any live lwp.  */
  /* Note: don't need to call switch_to_thread; we're just reading memory.  */
d694 3
a696 3
/* Perform partial transfers on OBJECT.  See target_read_partial
   and target_write_partial for details of each variant.  One, and
   only one, of readbuf or writebuf must be non-NULL.  */
d708 9
a716 4
  if (is_thread (inferior_ptid) ||	/* A thread */
      !target_thread_alive (inferior_ptid))	/* An lwp, but not alive */
    inferior_ptid = procfs_first_available ();	/* Find any live lwp.  */
  /* Note: don't need to call switch_to_thread; we're just reading memory.  */
d759 2
a760 1
      main_ph.ptid = inferior_ptid;	/* Save for xfer_memory */
d773 9
a781 9
/* This routine is called whenever a new symbol table is read in, or when all
   symbol tables are removed.  libthread_db can only be initialized when it
   finds the right variables in libthread.so.  Since it's a shared library,
   those variables don't show up until the library gets mapped and the symbol
   table is read in.  */

/* This new_objfile event is now managed by a chained function pointer.
 * It is the callee's responsability to call the next client on the chain.
 */
d797 2
a798 1
  /* don't do anything if init failed to resolve the libthread_db library */
d802 3
a804 3
  /* Now, initialize the thread debugging library.  This needs to be done after
     the shared libraries are located because it needs information from the
     user's thread library.  */
d823 1
d825 1
a825 1
  /* Call predecessor on chain, if any. */
d839 2
a840 1
/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */
d864 2
d869 1
a869 1
  if (is_thread (ptid))		/* non-kernel thread */
d871 1
d878 1
a878 1
	return 0;		/* thread not found */
d880 2
a881 2
	return 0;		/* thread not valid */
      return 1;			/* known thread: return true */
a883 1
    /* kernel thread (LWP): let procfs test it */
d885 1
d899 2
a900 2
/* These routines implement the lower half of the thread_db interface.  Ie: the
   ps_* routines.  */
d902 2
a903 2
/* Various versions of <proc_service.h> have slightly
   different function prototypes.  In particular, we have
d908 2
a909 2
   const void*          char*
   int                  size_t
d911 4
a914 5
   Which one you have depends on solaris version and what
   patches you've applied.  On the theory that there are
   only two major variants, we have configure check the
   prototype of ps_pdwrite (), and use that info to make
   appropriate typedefs here. */
d930 4
d935 1
a935 6
/* The next four routines are called by thread_db to tell us to stop and stop
   a particular process or lwp.  Since GDB ensures that these are all stopped
   by the time we call anything in thread_db, these routines need to do
   nothing.  */

/* Process stop */
d943 1
a943 1
/* Process continue */
d951 1
a951 1
/* LWP stop */
d959 1
a959 1
/* LWP continue */
d971 1
a971 1
		   const char *ld_symbol_name, gdb_ps_addr_t * ld_symbol_addr)
a975 1

a979 1

d993 9
a1001 4
  if (is_thread (inferior_ptid) ||	/* A thread */
      !target_thread_alive (inferior_ptid))	/* An lwp, but not alive */
    inferior_ptid = procfs_first_available ();	/* Find any live lwp.  */
  /* Note: don't need to call switch_to_thread; we're just reading memory.  */
d1092 1
a1092 1
/* Get integer regs for LWP */
d1095 1
a1095 2
ps_lgetregs (gdb_ps_prochandle_t ph, lwpid_t lwpid,
	     prgregset_t gregset)
d1114 1
a1114 1
/* Set integer regs for LWP */
d1140 1
a1140 1
ps_plog (const char *fmt,...)
d1223 1
a1223 1
/* Get floating-point regs for LWP */
d1227 1
a1227 1
	       prfpregset_t * fpregset)
d1270 3
a1272 4
/* Identify process as 32-bit or 64-bit.
   At the moment I'm using bfd to do this.
   There might be a more solaris-specific (eg. procfs) method,
   but this ought to work.  */
d1296 1
a1296 1
  /* NOTE: only used on Solaris, therefore OK to refer to procfs.c */
d1300 2
a1301 2
  /* FIXME: can't I get the process ID from the prochandle or something?
   */
d1312 2
a1313 1
  else	/* LDT not found. */
d1318 2
a1319 1
/* Convert a pid to printable form. */
d1326 1
a1326 1
  /* in case init failed to resolve the libthread_db library */
d1339 2
a1340 1
	sprintf (buf, "Thread %ld (LWP %ld)", GET_THREAD (ptid), GET_LWP (lwp));
d1353 2
a1354 3
/* Worker bee for find_new_threads
   Callback function that gets called once per USER thread (i.e., not
   kernel) thread. */
d1363 4
a1366 4
  if ((retval = p_td_thr_get_info (th, &ti)) != TD_OK)
    {
      return -1;
    }
d1377 2
a1378 1
  /* don't do anything if init failed to resolve the libthread_db library */
d1387 5
a1391 1
  procfs_ops.to_find_new_threads ();	/* first find new kernel threads */
d1422 4
a1425 3
/* Worker bee for info sol-thread command.  This is a callback function that
   gets called once for each Solaris thread (ie. not kernel thread) in the
   inferior.  Print anything interesting that we can think of.  */
d1433 2
a1434 1
  if ((ret = p_td_thr_get_info (th, &ti)) == TD_OK)
d1464 1
a1464 1
      /* Print thr_create start function: */
d1470 2
a1471 1
	    printf_filtered ("   startfunc: %s\n", DEPRECATED_SYMBOL_NAME (msym));
d1476 1
a1476 1
      /* If thread is asleep, print function that went to sleep: */
d1482 2
a1483 1
	    printf_filtered (" - Sleep func: %s\n", DEPRECATED_SYMBOL_NAME (msym));
d1488 1
a1488 1
      /* Wrap up line, if necessary */
d1498 2
a1499 1
/* List some state about each Solaris user thread in the inferior.  */
d1510 2
a1511 4
sol_find_memory_regions (int (*func) (CORE_ADDR,
				      unsigned long,
				      int, int, int,
				      void *),
a1528 1

a1574 1

d1599 7
a1605 5
  /* On Solaris/x86, when debugging a threaded core file from process <n>,
     the following causes "info threads" to produce "procfs: couldn't find pid
     <n> in procinfo list" where <n> is the pid of the process that produced
     the core file.  Disable it for now. */
  /* sol_core_ops.to_find_new_threads = sol_find_new_threads; */
d1609 4
a1612 4
/* we suppress the call to add_target of core_ops in corelow because
   if there are two targets in the stratum core_stratum, find_core_target
   won't know which one to return.  see corelow.c for an additonal
   comment on coreops_suppress_target. */
d1666 1
a1666 1
  /* Hook into new_objfile notification. */
d1671 3
a1673 3
die:

  fprintf_unfiltered (gdb_stderr, "[GDB will not be able to debug user-mode threads: %s]\n", dlerror ());
d1678 1
a1678 1
  /* allow the user to debug non-threaded core files */
@


1.39
log
@2004-01-28  Roland McGrath  <roland@@redhat.com>

	* sol-thread.c (sol_thread_xfer_partial): New function.
	(init_sol_thread_ops): Use that for to_xfer_partial hook.
	(init_sol_core_ops): Likewise.
@
text
@d1705 2
a1706 2
  target_new_objfile_chain = target_new_objfile_hook;
  target_new_objfile_hook  = sol_thread_new_objfile;
@


1.39.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1 2
a2 3
/* Solaris threads debugging interface.

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d23 2
a24 2
   machine-independent parts of GDB and the /proc interface (procfs.c)
   to provide access to the Solaris user-mode thread implementation.
d26 12
a37 14
   Solaris threads are true user-mode threads, which are invoked via
   the thr_* and pthread_* (native and POSIX respectivly) interfaces.
   These are mostly implemented in user-space, with all thread context
   kept in various structures that live in the user's heap.  These
   should not be confused with lightweight processes (LWPs), which are
   implemented by the kernel, and scheduled without explicit
   intervention by the process.

   Just to confuse things a little, Solaris threads (both native and
   POSIX) are actually implemented using LWPs.  In general, there are
   going to be more threads than LWPs.  There is no fixed
   correspondence between a thread and an LWP.  When a thread wants to
   run, it gets scheduled onto the first available LWP and can
   therefore migrate from one LWP to another as time goes on.  A
d40 9
a48 10
   To make it possible to mess with threads, Sun provides a library
   called libthread_db.so.1 (not to be confused with
   libthread_db.so.0, which doesn't have a published interface).  This
   interface has an upper part, which it provides, and a lower part
   which we provide.  The upper part consists of the td_* routines,
   which allow us to find all the threads, query their state, etc...
   The lower part consists of all of the ps_*, which are used by the
   td_* routines to read/write memory, manipulate LWPs, lookup
   symbols, etc...  The ps_* routines actually do most of their work
   by calling functions in procfs.c.  */
d84 3
a86 3
/* This struct is defined by us, but mainly used for the proc_service
   interface.  We don't have much use for it, except as a handy place
   to get a real PID for memory accesses.  */
d89 3
a91 3
{
  ptid_t ptid;
};
d94 4
a97 4
{
  int num;
  char *str;
};
d103 3
d107 1
d114 2
a115 2
/* Default definitions: These must be defined in tm.h if they are to
   be shared with a process module such as procfs.  */
d127 66
a192 1
/* Pointers to routines from libthread_db resolved by dlopen().  */
d194 2
a195 49
static void (*p_td_log)(const int on_off);
static td_err_e (*p_td_ta_new)(const struct ps_prochandle *ph_p,
			       td_thragent_t **ta_pp);
static td_err_e (*p_td_ta_delete)(td_thragent_t *ta_p);
static td_err_e (*p_td_init)(void);
static td_err_e (*p_td_ta_get_ph)(const td_thragent_t *ta_p,
				  struct ps_prochandle **ph_pp);
static td_err_e (*p_td_ta_get_nthreads)(const td_thragent_t *ta_p,
					int *nthread_p);
static td_err_e (*p_td_ta_tsd_iter)(const td_thragent_t *ta_p,
				    td_key_iter_f *cb, void *cbdata_p);
static td_err_e (*p_td_ta_thr_iter)(const td_thragent_t *ta_p,
				    td_thr_iter_f *cb, void *cbdata_p,
				    td_thr_state_e state, int ti_pri,
				    sigset_t *ti_sigmask_p,
				    unsigned ti_user_flags);
static td_err_e (*p_td_thr_validate)(const td_thrhandle_t *th_p);
static td_err_e (*p_td_thr_tsd)(const td_thrhandle_t * th_p,
				const thread_key_t key, void **data_pp);
static td_err_e (*p_td_thr_get_info)(const td_thrhandle_t *th_p,
				     td_thrinfo_t *ti_p);
static td_err_e (*p_td_thr_getfpregs)(const td_thrhandle_t *th_p,
				      prfpregset_t *fpregset);
static td_err_e (*p_td_thr_getxregsize)(const td_thrhandle_t *th_p,
					int *xregsize);
static td_err_e (*p_td_thr_getxregs)(const td_thrhandle_t *th_p,
				     const caddr_t xregset);
static td_err_e (*p_td_thr_sigsetmask)(const td_thrhandle_t *th_p,
				       const sigset_t ti_sigmask);
static td_err_e (*p_td_thr_setprio)(const td_thrhandle_t *th_p,
				    const int ti_pri);
static td_err_e (*p_td_thr_setsigpending)(const td_thrhandle_t *th_p,
					  const uchar_t ti_pending_flag,
					  const sigset_t ti_pending);
static td_err_e (*p_td_thr_setfpregs)(const td_thrhandle_t *th_p,
				      const prfpregset_t *fpregset);
static td_err_e (*p_td_thr_setxregs)(const td_thrhandle_t *th_p,
				     const caddr_t xregset);
static td_err_e (*p_td_ta_map_id2thr)(const td_thragent_t *ta_p,
				      thread_t tid,
				      td_thrhandle_t *th_p);
static td_err_e (*p_td_ta_map_lwp2thr)(const td_thragent_t *ta_p,
				       lwpid_t lwpid,
				       td_thrhandle_t *th_p);
static td_err_e (*p_td_thr_getgregs)(const td_thrhandle_t *th_p,
				     prgregset_t regset);
static td_err_e (*p_td_thr_setgregs)(const td_thrhandle_t *th_p,
				     const prgregset_t regset);

d197 1
a197 2
/* Return the libthread_db error string associated with ERRCODE.  If
   ERRCODE is unknown, return an appropriate message.  */
d202 2
a203 1
  static struct string_map td_err_table[] =
d205 21
a225 21
    { TD_OK, "generic \"call succeeded\"" },
    { TD_ERR, "generic error." },
    { TD_NOTHR, "no thread can be found to satisfy query" },
    { TD_NOSV, "no synch. variable can be found to satisfy query" },
    { TD_NOLWP, "no lwp can be found to satisfy query" },
    { TD_BADPH, "invalid process handle" },
    { TD_BADTH, "invalid thread handle" },
    { TD_BADSH, "invalid synchronization handle" },
    { TD_BADTA, "invalid thread agent" },
    { TD_BADKEY, "invalid key" },
    { TD_NOMSG, "td_thr_event_getmsg() called when there was no message" },
    { TD_NOFPREGS, "FPU register set not available for given thread" },
    { TD_NOLIBTHREAD, "application not linked with libthread" },
    { TD_NOEVENT, "requested event is not supported" },
    { TD_NOCAPAB, "capability not available" },
    { TD_DBERR, "Debugger service failed" },
    { TD_NOAPLIC, "Operation not applicable to" },
    { TD_NOTSD, "No thread specific data for this thread" },
    { TD_MALLOC, "Malloc failed" },
    { TD_PARTIALREG, "Only part of register set was written/read" },
    { TD_NOXREGS, "X register set not available for given thread" }
d235 1
a235 1
  sprintf (buf, "Unknown libthread_db error code: %d", errcode);
d239 15
d255 1
a255 2
/* Return the the libthread_db state string assicoated with STATECODE.
   If STATECODE is unknown, return an appropriate message.  */
d260 2
a261 1
  static struct string_map td_thr_state_table[] =
d263 8
a270 8
    { TD_THR_ANY_STATE, "any state" },
    { TD_THR_UNKNOWN, "unknown" },
    { TD_THR_STOPPED, "stopped" },
    { TD_THR_RUN, "run" },
    { TD_THR_ACTIVE, "active" },
    { TD_THR_ZOMBIE, "zombie" },
    { TD_THR_SLEEP, "sleep" },
    { TD_THR_STOPPED_ASLEEP, "stopped asleep" }
d272 1
a272 2
  const int td_thr_state_table_size =
    sizeof td_thr_state_table / sizeof (struct string_map);
d280 1
a280 1
  sprintf (buf, "Unknown libthread_db state code: %d", statecode);
d285 3
d289 1
a289 3
/* Convert a POSIX or Solaris thread ID into a LWP ID.  If THREAD_ID
   doesn't exist, that's an error.  If it's an inactive thread, return
   DEFAULT_LPW.
d291 15
a305 1
   NOTE: This function probably shouldn't call error().  */
d315 1
a315 1
    return thread_id;		/* It's already an LWP ID.  */
d317 1
a317 1
  /* It's a thread.  Convert to LWP.  */
d321 1
a321 1
    return pid_to_ptid (-1);	/* Thread must have terminated.  */
d327 1
a327 1
    return pid_to_ptid (-1);	/* Thread must have terminated.  */
d341 2
d344 1
a344 2
/* Convert an LWP ID into a POSIX or Solaris thread ID.  If LWP_ID
   doesn't exists, that's an error.
d346 16
a361 1
   NOTE: This function probably shouldn't call error().  */
d371 1
a371 1
    return lwp;			/* It's already a thread ID.  */
d373 1
a373 1
  /* It's an LWP.  Convert it to a thread ID.  */
d376 1
a376 1
    return pid_to_ptid (-1);	/* Must be a defunct LPW.  */
d380 1
a380 1
    return pid_to_ptid (-1);	/* Thread must have terminated.  */
d386 2
a387 1
    return lwp;			/* Unknown to libthread; just return LPW,  */
d393 1
a393 1
    return pid_to_ptid (-1);	/* Thread must have terminated.  */
d401 2
a402 3
/* Most target vector functions from here on actually just pass
   through to procfs.c, as they don't need to do anything specific for
   threads.  */
d410 2
a411 2
/* Attach to process PID, then initialize for debugging it and wait
   for the trace-trap that results from attaching.  */
d418 1
a418 1
  /* Must get symbols from shared libraries before libthread_db can run!  */
d424 1
a424 1
      main_ph.ptid = inferior_ptid; /* Save for xfer_memory.  */
d432 1
a432 3

  /* FIXME: Might want to iterate over all the threads and register
     them.  */
d435 7
a441 6
/* Take a program previously attached to and detaches it.  The program
   resumes execution and will no longer stop on signals, etc.  We'd
   better not have left any breakpoints in the program or it'll die
   when it hits one.  For this to work, it may be necessary for the
   process to have been previously attached.  It *might* work if the
   program was started via the normal ptrace (PTRACE_TRACEME).  */
d451 4
a454 4
/* Resume execution of process PTID.  If STEP is nozero, then just
   single step it.  If SIGNAL is nonzero, restart it with that signal
   activated.  We may have to convert PTID from a thread ID to an LWP
   ID for procfs.  */
d472 1
a472 1
      if (PIDGET (ptid) == -2)		/* Inactive thread.  */
d484 2
a485 2
/* Wait for any threads to stop.  We may have to convert PIID from a
   thread ID to an LWP ID, and vice versa on the way out.  */
d506 1
a506 1
      if (PIDGET (ptid) == -2)		/* Inactive thread.  */
d517 1
a517 1
      /* Map the LWP of interest back to the appropriate thread ID.  */
d522 1
a522 1
      /* See if we have a new thread.  */
d532 3
a534 3
  /* During process initialization, we may get here without the thread
     package being initialized, since that can only happen after we've
     found the shared libs.  */
d542 1
a542 1
sol_thread_fetch_registers (int regnum)
d555 1
a555 2
    {
      /* It's an LWP; pass the request on to procfs.  */
d557 1
a557 1
	procfs_ops.to_fetch_registers (regnum);
d559 1
a559 1
	orig_core_ops.to_fetch_registers (regnum);
d563 2
a564 1
  /* Solaris thread: convert INFERIOR_PTID into a td_thrhandle_t.  */
d566 1
d568 1
a568 1
    error ("sol_thread_fetch_registers: thread == 0");
d575 1
a575 1
  /* Get the general-purpose registers.  */
d578 2
a579 1
  if (val != TD_OK && val != TD_PARTIALREG)
d583 2
a584 2
  /* For SPARC, TD_PARTIALREG means that only %i0...%i7, %l0..%l7, %pc
     and %sp are saved (by a thread context switch).  */
d586 1
a586 1
  /* And, now the floating-point registers.  */
d589 2
a590 1
  if (val != TD_OK && val != TD_NOFPREGS)
d594 3
a596 3
  /* Note that we must call supply_gregset and supply_fpregset *after*
     calling the td routines because the td routines call ps_lget*
     which affect the values stored in the registers array.  */
d598 1
a598 1
  supply_gregset ((gdb_gregset_t *) &gregset);
d602 1
a602 1
  /* FIXME: libthread_db doesn't seem to handle this right.  */
d620 1
a620 1
sol_thread_store_registers (int regnum)
d625 1
a625 1
  prgregset_t gregset;
d633 2
a634 3
    {
      /* It's an LWP; pass the request on to procfs.c.  */
      procfs_ops.to_store_registers (regnum);
d638 2
a639 1
  /* Solaris thread: convert INFERIOR_PTID into a td_thrhandle_t.  */
d647 2
a648 3
  if (regnum != -1)
    {
      /* Not writing all the registers.  */
d652 1
a652 1
      regcache_raw_collect (current_regcache, regnum, old_value);
d664 1
a664 1
      regcache_raw_supply (current_regcache, regnum, old_value);
d667 1
a667 1
      /* FIXME: libthread_db doesn't seem to handle this right.  */
d684 2
a685 2
  fill_gregset ((gdb_gregset_t *) &gregset, regnum);
  fill_fpregset ((gdb_fpregset_t *) &fpregset, regnum);
d697 1
a697 1
  /* FIXME: libthread_db doesn't seem to handle this right.  */
d703 2
a704 2
  /* ??? Should probably do something about writing the xregs here,
     but what are they?  */
d709 4
a712 4
   individual registers, this doesn't need to do anything.  On
   machines which store all the registers in one fell swoop, this
   makes sure that registers contains all the registers from the
   program being debugged.  */
d724 1
a724 1
   Returns the number of bytes transferred.  */
d736 4
a739 9
  if (is_thread (inferior_ptid) || !target_thread_alive (inferior_ptid))
    {
      /* It's either a thread or an LWP that isn't alive.  Any live
         LWP will do so use the first available.

	 NOTE: We don't need to call switch_to_thread; we're just
	 reading memory.  */
      inferior_ptid = procfs_first_available ();
    }
d753 3
a755 3
/* Perform partial transfers on OBJECT.  See target_read_partial and
   target_write_partial for details of each variant.  One, and only
   one, of readbuf or writebuf must be non-NULL.  */
d767 4
a770 9
  if (is_thread (inferior_ptid) || !target_thread_alive (inferior_ptid))
    {
      /* It's either a thread or an LWP that isn't alive.  Any live
         LWP will do so use the first available.

	 NOTE: We don't need to call switch_to_thread; we're just
	 reading memory.  */
      inferior_ptid = procfs_first_available ();
    }
d807 1
a807 2
sol_thread_create_inferior (char *exec_file, char *allargs, char **env,
			    int from_tty)
d809 1
a809 1
  procfs_ops.to_create_inferior (exec_file, allargs, env, from_tty);
d813 1
a813 2
      /* Save for xfer_memory.  */
      main_ph.ptid = inferior_ptid;
d826 9
a834 9
/* This routine is called whenever a new symbol table is read in, or
   when all symbol tables are removed.  libthread_db can only be
   initialized when it finds the right variables in libthread.so.
   Since it's a shared library, those variables don't show up until
   the library gets mapped and the symbol table is read in.

   This new_objfile event is managed by a chained function pointer.
   It is the callee's responsability to call the next client on the
   chain.  */
d850 1
a850 2
  /* Don't do anything if init failed to resolve the libthread_db
     library.  */
d854 3
a856 3
  /* Now, initialize libthread_db.  This needs to be done after the
     shared libraries are located because it needs information from
     the user's thread library.  */
a874 1

d876 1
a876 1
  /* Call predecessor on chain, if any.  */
d890 1
a890 2
/* Mark our target-struct as eligible for stray "run" and "attach"
   commands.  */
a913 2
/* Return true if PTID is still active in the inferior.  */

d917 1
a917 1
  if (is_thread (ptid))
a918 1
      /* It's a (user-level) thread.  */
d925 1
a925 1
	return 0;		/* Thread not found.  */
d927 2
a928 2
	return 0;		/* Thread not valid.  */
      return 1;			/* Known thread.  */
d931 1
a932 1
      /* It's an LPW; pass the request on to procfs.  */
d946 2
a947 2
/* These routines implement the lower half of the thread_db interface,
   i.e. the ps_* routines.  */
d949 2
a950 2
/* Various versions of <proc_service.h> have slightly different
   function prototypes.  In particular, we have
d955 2
a956 2
   const void*          	char*
   int                  	size_t
d958 5
a962 4
   Which one you have depends on the Solaris version and what patches
   you've applied.  On the theory that there are only two major
   variants, we have configure check the prototype of ps_pdwrite (),
   and use that info to make appropriate typedefs here. */
a977 4
/* The next four routines are called by libthread_db to tell us to
   stop and stop a particular process or lwp.  Since GDB ensures that
   these are all stopped by the time we call anything in thread_db,
   these routines need to do nothing.  */
d979 6
a984 1
/* Process stop.  */
d992 1
a992 1
/* Process continue.  */
d1000 1
a1000 1
/* LWP stop.  */
d1008 1
a1008 1
/* LWP continue.  */
d1020 1
a1020 1
		   const char *ld_symbol_name, gdb_ps_addr_t *ld_symbol_addr)
d1025 1
d1030 1
d1044 4
a1047 9
  if (is_thread (inferior_ptid) || !target_thread_alive (inferior_ptid))
    {
      /* It's either a thread or an LWP that isn't alive.  Any live
         LWP will do so use the first available.

	 NOTE: We don't need to call switch_to_thread; we're just
	 reading memory.  */
      inferior_ptid = procfs_first_available ();
    }
d1138 1
a1138 1
/* Get general-purpose registers for LWP.  */
d1141 2
a1142 1
ps_lgetregs (gdb_ps_prochandle_t ph, lwpid_t lwpid, prgregset_t gregset)
d1161 1
a1161 1
/* Set general-purpose registers for LWP.  */
d1187 1
a1187 1
ps_plog (const char *fmt, ...)
d1270 1
a1270 1
/* Get floating-point registers for LWP.  */
d1274 1
a1274 1
	       prfpregset_t *fpregset)
d1317 4
a1320 3
/* Identify process as 32-bit or 64-bit.  At the moment we're using
   BFD to do this.  There might be a more Solaris-specific
   (e.g. procfs) method, but this ought to work.  */
d1344 1
a1344 1
  /* NOTE: only used on Solaris, therefore OK to refer to procfs.c.  */
d1348 2
a1349 2
  /* FIXME: can't I get the process ID from the prochandle or
     something?  */
d1360 1
a1360 2
  else
    /* LDT not found.  */
d1365 1
a1365 2

/* Convert PTID to printable form.  */
d1372 1
a1372 1
  /* In case init failed to resolve the libthread_db library.  */
d1385 1
a1385 2
	sprintf (buf, "Thread %ld (LWP %ld)",
		 GET_THREAD (ptid), GET_LWP (lwp));
d1398 3
a1400 2
/* Worker bee for find_new_threads.  Callback function that gets
   called once per user-level thread (i.e. not for LWP's).  */
d1409 4
a1412 4
  retval = p_td_thr_get_info (th, &ti);
  if (retval != TD_OK)
    return -1;

d1423 1
a1423 2
  /* Don't do anything if init failed to resolve the libthread_db
     library.  */
d1432 1
a1432 5

  /* First Find any new LWP's.  */
  procfs_ops.to_find_new_threads ();

  /* Then find any new user-level threads.  */
d1463 3
a1465 4
/* Worker bee for the "info sol-thread" command.  This is a callback
   function that gets called once for each Solaris user-level thread
   (i.e. not for LWPs) in the inferior.  Print anything interesting
   that we can think of.  */
d1473 1
a1473 2
  ret = p_td_thr_get_info (th, &ti);
  if (ret == TD_OK)
d1503 1
a1503 1
      /* Print thr_create start function.  */
d1509 1
a1509 2
	    printf_filtered ("   startfunc: %s\n",
			     DEPRECATED_SYMBOL_NAME (msym));
d1514 1
a1514 1
      /* If thread is asleep, print function that went to sleep.  */
d1520 1
a1520 2
	    printf_filtered (" - Sleep func: %s\n",
			     DEPRECATED_SYMBOL_NAME (msym));
d1525 1
a1525 1
      /* Wrap up line, if necessary.  */
d1535 1
a1535 2
/* List some state about each Solaris user-level thread in the
   inferior.  */
d1546 4
a1549 2
sol_find_memory_regions (int (*func) (CORE_ADDR, unsigned long,
				      int, int, int, void *),
d1567 1
d1614 1
d1639 5
a1643 7
  /* On Solaris/x86, when debugging a threaded core file from process
     <n>, the following causes "info threads" to produce "procfs:
     couldn't find pid <n> in procinfo list" where <n> is the pid of
     the process that produced the core file.  Disable it for now. */
#if 0
  sol_core_ops.to_find_new_threads = sol_find_new_threads;
#endif
d1647 4
a1650 4
/* We suppress the call to add_target of core_ops in corelow because
   if there are two targets in the stratum core_stratum,
   find_core_target won't know which one to return.  See corelow.c for
   an additonal comment on coreops_suppress_target.  */
d1704 3
a1706 3
  /* Hook into new_objfile notification.  */
  target_new_objfile_chain = deprecated_target_new_objfile_hook;
  deprecated_target_new_objfile_hook  = sol_thread_new_objfile;
d1709 3
a1711 3
 die:
  fprintf_unfiltered (gdb_stderr, "\
[GDB will not be able to debug user-mode threads: %s]\n", dlerror ());
d1716 1
a1716 1
  /* Allow the user to debug non-threaded core files.  */
@


1.38
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d114 1
a114 1
/* Default definitions: These must be defined in tm.h 
d130 1
a130 1
static td_err_e (*p_td_ta_new)            (const struct ps_prochandle * ph_p, 
d134 1
a134 1
static td_err_e (*p_td_ta_get_ph)         (const td_thragent_t * ta_p, 
d136 1
a136 1
static td_err_e (*p_td_ta_get_nthreads)   (const td_thragent_t * ta_p, 
d138 2
a139 2
static td_err_e (*p_td_ta_tsd_iter)       (const td_thragent_t * ta_p, 
					   td_key_iter_f * cb, 
d141 3
a143 3
static td_err_e (*p_td_ta_thr_iter)       (const td_thragent_t * ta_p, 
					   td_thr_iter_f * cb, 
					   void *cbdata_p, 
d145 2
a146 2
					   int ti_pri, 
					   sigset_t * ti_sigmask_p, 
d149 2
a150 2
static td_err_e (*p_td_thr_tsd)           (const td_thrhandle_t * th_p, 
					   const thread_key_t key, 
d152 1
a152 1
static td_err_e (*p_td_thr_get_info)      (const td_thrhandle_t * th_p, 
d154 1
a154 1
static td_err_e (*p_td_thr_getfpregs)     (const td_thrhandle_t * th_p, 
d156 1
a156 1
static td_err_e (*p_td_thr_getxregsize)   (const td_thrhandle_t * th_p, 
d158 1
a158 1
static td_err_e (*p_td_thr_getxregs)      (const td_thrhandle_t * th_p, 
d160 1
a160 1
static td_err_e (*p_td_thr_sigsetmask)    (const td_thrhandle_t * th_p, 
d162 1
a162 1
static td_err_e (*p_td_thr_setprio)       (const td_thrhandle_t * th_p, 
d164 2
a165 2
static td_err_e (*p_td_thr_setsigpending) (const td_thrhandle_t * th_p, 
					   const uchar_t ti_pending_flag, 
d167 1
a167 1
static td_err_e (*p_td_thr_setfpregs)     (const td_thrhandle_t * th_p, 
d169 1
a169 1
static td_err_e (*p_td_thr_setxregs)      (const td_thrhandle_t * th_p, 
d171 2
a172 2
static td_err_e (*p_td_ta_map_id2thr)     (const td_thragent_t * ta_p, 
					   thread_t tid, 
d174 2
a175 2
static td_err_e (*p_td_ta_map_lwp2thr)    (const td_thragent_t * ta_p, 
					   lwpid_t lwpid, 
d177 1
a177 1
static td_err_e (*p_td_thr_getgregs)      (const td_thrhandle_t * th_p, 
d179 1
a179 1
static td_err_e (*p_td_thr_setgregs)      (const td_thrhandle_t * th_p, 
d650 1
a650 1
      
d742 1
a742 1
    retval = procfs_ops.to_xfer_memory (memaddr, myaddr, len, 
d753 31
d832 1
a832 1
/* This new_objfile event is now managed by a chained function pointer. 
d898 1
a898 1
/* 
d1062 1
a1062 1
	cc = procfs_ops.to_xfer_memory (addr, buf, size, 
d1065 1
a1065 1
	cc = orig_core_ops.to_xfer_memory (addr, buf, size, 
d1082 1
a1082 1
	    warning ("rw_common (): unable to read at addr 0x%lx", 
d1085 1
a1085 1
	    warning ("rw_common (): unable to write at addr 0x%lx", 
d1464 1
a1464 1
   gets called once for each Solaris thread (ie. not kernel thread) in the 
d1546 4
a1549 4
sol_find_memory_regions (int (*func) (CORE_ADDR, 
				      unsigned long, 
				      int, int, int, 
				      void *), 
d1583 1
d1627 1
@


1.37
log
@* sol-thread.c: Include "gdb_string.h".
@
text
@a403 2

/* ARGSUSED */
@


1.37.2.1
log
@2003-09-29  Elena Zannoni  <ezannoni@@redhat.com>

	* exec.c (exec_set_find_memory_regions): Update parameter list.
	* defs.h (exec_set_find_memory_regions): Update parameter list.
	* fbsd-proc.c (fbsd_find_memory_regions): Likewise. Update call to
	function parameter.
	* gcore.c (gcore_create_callback): Update paramter list.
	(objfile_find_memory_regions): Update parameter list. Update calls
	to function parameter.
	* gnu-nat.c (gnu_find_memory_regions): Update parameter
	list. Update calls to function parameter.
	* inftarg.c (inftarg_set_find_memory_regions): Update parameter
	list.
	* linux-proc.c (read_mapping): Prune the leading whitespaces in
	the filename.
	(linux_find_memory_regions): Update parameter list. Update call to
	function parameter.
	* procfs.c (find_memory_regions_callback): Update paremeters and
	calls.
	(proc_find_memory_regions): Update parameters.
	* sol-thread.c (sol_find_memory_regions): Update parameter list.
	* target.h (struct target_ops): Update definition of
	to_find_memory_regions field.
@
text
@d1520 1
a1520 1
				      char *, void *), 
@


1.36
log
@* sol-thread.c (sol_thread_store_registers): Use regcache_collect
and supply_register instead of manipulating the register buffer
directly.

From Peter Schauer (Peter.Schauer@@regent.e-technik.tu-muenchen.de):
@
text
@d65 2
@


1.35
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d649 4
a652 4
      /* save new register value */
      char* old_value = (char*) alloca (DEPRECATED_REGISTER_SIZE);
      memcpy (old_value, &deprecated_registers[REGISTER_BYTE (regno)],
	      DEPRECATED_REGISTER_SIZE);
d663 2
a664 3
      /* restore new register value */
      memcpy (&deprecated_registers[REGISTER_BYTE (regno)], old_value,
	      DEPRECATED_REGISTER_SIZE);
@


1.35.14.1
log
@* sol-thread.c (sol_thread_store_registers): Use regcache_collect
and supply_register instead of manipulating the register buffer
directly.

From Peter Schauer (Peter.Schauer@@regent.e-technik.tu-muenchen.de):
@
text
@d649 4
a652 4
      char old_value[MAX_REGISTER_SIZE];
      
      /* Save new register value.  */
      regcache_collect (regno, old_value);
d663 3
a665 2
      /* Restore new register value.  */
      supply_register (regno, old_value);
@


1.34
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d650 1
a650 1
      char* old_value = (char*) alloca (REGISTER_SIZE);
d652 1
a652 1
	      REGISTER_SIZE);
d665 1
a665 1
	      REGISTER_SIZE);
@


1.34.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d650 1
a650 1
      char* old_value = (char*) alloca (DEPRECATED_REGISTER_SIZE);
d652 1
a652 1
	      DEPRECATED_REGISTER_SIZE);
d665 1
a665 1
	      DEPRECATED_REGISTER_SIZE);
@


1.33
log
@2003-02-07  Andrew Cagney  <ac131313@@redhat.com>

	* sol-thread.c, hpux-thread.c: Include "gdb_stat.h" instead of
	<sys/stat.h>.
	* Makefile.in (sol-thread.o, hpux-thread.o): Update dependencies.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d1479 1
a1479 1
	    printf_filtered ("   startfunc: %s\n", SYMBOL_NAME (msym));
d1490 1
a1490 1
	    printf_filtered (" - Sleep func: %s\n", SYMBOL_NAME (msym));
@


1.32
log
@2002-11-14  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_registers): Rename registers.
	* a68v-nat.c, alpha-nat.c, arch-utils.c, core-sol2.c: Update.
	* hp300ux-nat.c, hppab-nat.c, hppah-nat.c: Update.
	* hppam3-nat.c, hpux-thread.c, i386gnu-nat.c: Update.
	* ia64-aix-nat.c, ia64-linux-nat.c, ia64-tdep.c: Update.
	* irix4-nat.c, irix5-nat.c, lynx-nat.c, m68k-tdep.c: Update.
	* m68knbsd-nat.c, mips-linux-tdep.c, mipsm3-nat.c: Update.
	* mipsv4-nat.c, ns32knbsd-nat.c, ppc-bdm.c: Update.
	* ppc-sysv-tdep.c, ptx4-nat.c, regcache.c, remote-es.c: Update.
	* remote-sds.c, remote-vx68.c, remote-vxmips.c: Update.
	* remote-vxsparc.c, rs6000-tdep.c, sol-thread.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, symm-nat.c: Update.
	* v850ice.c: Update.
@
text
@d58 1
a58 1
#include <sys/stat.h>
@


1.31
log
@	* gnu-nat.c (init_gnu_ops): Remove NULL initializations.
	* monitor.c (init_base_monitor_ops): Likewise.
	* ppc-bdm.c (init_bdm_ppc_ops): Likewise.
	* remote-array.c (init_array_ops): Likewise.
	* remote-e7000.c (init_e7000_ops): Likewise.
	* remote-es.c (init_es1800_ops): Likewise.
	(init_es1800_child_ops): Likewise.
	* remote-rdp.c (init_remote_rdp_ops): Likewise.
	* remote-sim.c (init_gdbsim_ops): Likewise.
	* remote-st.c (init_st2000_ops): Likewise.
	* sol-thread.c (init_sol_core_ops): Likewise.
	(init_sol_thread_ops): Likewise.
	* v850ice.c (init_850ice_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
@
text
@d651 2
a652 1
      memcpy (old_value, &registers[REGISTER_BYTE (regno)], REGISTER_SIZE);
d664 2
a665 1
      memcpy (&registers[REGISTER_BYTE (regno)], old_value, REGISTER_SIZE);
@


1.30
log
@	Fix PR gdb/393:
	* inflow.c (terminal_save_ours): New function to save terminal
	settings.
	* inferior.h (terminal_save_ours): Declare.
	* target.c (debug_to_terminal_save_ours): New function.
	(cleanup_target): Defaults to_terminal_save_ours.
	(update_current_target): Inherit to_terminal_save_ours.
	(setup_target_debug): Set to_terminal_save_ours.
	* target.h (target_terminal_save_ours): New to save terminal settings.
	(target_ops): New member to_terminal_save_ours.
	* gnu-nat.c (init_gnu_ops): Set to_terminal_save_ours.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* inftarg.c (init_child_ops): Likewise.
	* m3-nat.c (init_m3_ops): Likewise.
	* procfs.c (init_procfs_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* sol-thread.c (init_sol_thread_ops): Likewise.
@
text
@a1542 1
  sol_thread_ops.to_close = 0;
a1560 2
  sol_thread_ops.to_load = 0;
  sol_thread_ops.to_lookup_symbol = 0;
a1575 2
  sol_thread_ops.to_sections = 0;
  sol_thread_ops.to_sections_end = 0;
a1591 2
  /* sol_core_ops.to_resume  = 0; */
  /* sol_core_ops.to_wait  = 0;  */
a1592 2
  /* sol_core_ops.to_store_registers  = 0; */
  /* sol_core_ops.to_prepare_to_store  = 0; */
a1596 8
  /* sol_core_ops.to_terminal_init  = 0; */
  /* sol_core_ops.to_terminal_inferior  = 0; */
  /* sol_core_ops.to_terminal_ours_for_output  = 0; */
  /* sol_core_ops.to_terminal_ours  = 0; */
  /* sol_core_ops.to_terminal_info  = 0; */
  /* sol_core_ops.to_kill  = 0; */
  /* sol_core_ops.to_load  = 0; */
  /* sol_core_ops.to_lookup_symbol  = 0; */
a1598 1
  sol_core_ops.to_has_all_memory = 0;
a1601 1
  sol_core_ops.to_has_execution = 0;
a1609 2
  sol_core_ops.to_sections = 0;
  sol_core_ops.to_sections_end = 0;
@


1.30.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d58 1
a58 1
#include "gdb_stat.h"
a64 2
#include "gdb_string.h"

d402 2
d649 3
a651 4
      char old_value[MAX_REGISTER_SIZE];
      
      /* Save new register value.  */
      regcache_collect (regno, old_value);
d662 2
a663 2
      /* Restore new register value.  */
      supply_register (regno, old_value);
d1477 1
a1477 1
	    printf_filtered ("   startfunc: %s\n", DEPRECATED_SYMBOL_NAME (msym));
d1488 1
a1488 1
	    printf_filtered (" - Sleep func: %s\n", DEPRECATED_SYMBOL_NAME (msym));
d1543 1
d1562 2
d1579 2
d1597 2
d1600 2
d1606 8
d1616 1
d1620 1
d1629 2
@


1.30.6.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d114 1
a114 1
/* Default definitions: These must be defined in tm.h
d130 1
a130 1
static td_err_e (*p_td_ta_new)            (const struct ps_prochandle * ph_p,
d134 1
a134 1
static td_err_e (*p_td_ta_get_ph)         (const td_thragent_t * ta_p,
d136 1
a136 1
static td_err_e (*p_td_ta_get_nthreads)   (const td_thragent_t * ta_p,
d138 2
a139 2
static td_err_e (*p_td_ta_tsd_iter)       (const td_thragent_t * ta_p,
					   td_key_iter_f * cb,
d141 3
a143 3
static td_err_e (*p_td_ta_thr_iter)       (const td_thragent_t * ta_p,
					   td_thr_iter_f * cb,
					   void *cbdata_p,
d145 2
a146 2
					   int ti_pri,
					   sigset_t * ti_sigmask_p,
d149 2
a150 2
static td_err_e (*p_td_thr_tsd)           (const td_thrhandle_t * th_p,
					   const thread_key_t key,
d152 1
a152 1
static td_err_e (*p_td_thr_get_info)      (const td_thrhandle_t * th_p,
d154 1
a154 1
static td_err_e (*p_td_thr_getfpregs)     (const td_thrhandle_t * th_p,
d156 1
a156 1
static td_err_e (*p_td_thr_getxregsize)   (const td_thrhandle_t * th_p,
d158 1
a158 1
static td_err_e (*p_td_thr_getxregs)      (const td_thrhandle_t * th_p,
d160 1
a160 1
static td_err_e (*p_td_thr_sigsetmask)    (const td_thrhandle_t * th_p,
d162 1
a162 1
static td_err_e (*p_td_thr_setprio)       (const td_thrhandle_t * th_p,
d164 2
a165 2
static td_err_e (*p_td_thr_setsigpending) (const td_thrhandle_t * th_p,
					   const uchar_t ti_pending_flag,
d167 1
a167 1
static td_err_e (*p_td_thr_setfpregs)     (const td_thrhandle_t * th_p,
d169 1
a169 1
static td_err_e (*p_td_thr_setxregs)      (const td_thrhandle_t * th_p,
d171 2
a172 2
static td_err_e (*p_td_ta_map_id2thr)     (const td_thragent_t * ta_p,
					   thread_t tid,
d174 2
a175 2
static td_err_e (*p_td_ta_map_lwp2thr)    (const td_thragent_t * ta_p,
					   lwpid_t lwpid,
d177 1
a177 1
static td_err_e (*p_td_thr_getgregs)      (const td_thrhandle_t * th_p,
d179 1
a179 1
static td_err_e (*p_td_thr_setgregs)      (const td_thrhandle_t * th_p,
d650 1
a650 1

d742 1
a742 1
    retval = procfs_ops.to_xfer_memory (memaddr, myaddr, len,
a752 31
/* Perform partial transfers on OBJECT.  See target_read_partial
   and target_write_partial for details of each variant.  One, and
   only one, of readbuf or writebuf must be non-NULL.  */

static LONGEST
sol_thread_xfer_partial (struct target_ops *ops, enum target_object object,
			  const char *annex, void *readbuf,
			  const void *writebuf, ULONGEST offset, LONGEST len)
{
  int retval;
  struct cleanup *old_chain;

  old_chain = save_inferior_ptid ();

  if (is_thread (inferior_ptid) ||	/* A thread */
      !target_thread_alive (inferior_ptid))	/* An lwp, but not alive */
    inferior_ptid = procfs_first_available ();	/* Find any live lwp.  */
  /* Note: don't need to call switch_to_thread; we're just reading memory.  */

  if (target_has_execution)
    retval = procfs_ops.to_xfer_partial (ops, object, annex,
					 readbuf, writebuf, offset, len);
  else
    retval = orig_core_ops.to_xfer_partial (ops, object, annex,
					    readbuf, writebuf, offset, len);

  do_cleanups (old_chain);

  return retval;
}

d801 1
a801 1
/* This new_objfile event is now managed by a chained function pointer.
d867 1
a867 1
/*
d1031 1
a1031 1
	cc = procfs_ops.to_xfer_memory (addr, buf, size,
d1034 1
a1034 1
	cc = orig_core_ops.to_xfer_memory (addr, buf, size,
d1051 1
a1051 1
	    warning ("rw_common (): unable to read at addr 0x%lx",
d1054 1
a1054 1
	    warning ("rw_common (): unable to write at addr 0x%lx",
d1433 1
a1433 1
   gets called once for each Solaris thread (ie. not kernel thread) in the
d1515 4
a1518 4
sol_find_memory_regions (int (*func) (CORE_ADDR,
				      unsigned long,
				      int, int, int,
				      void *),
a1551 1
  sol_thread_ops.to_xfer_partial = sol_thread_xfer_partial;
a1594 1
  sol_core_ops.to_xfer_partial = sol_thread_xfer_partial;
@


1.30.4.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d651 1
a651 2
      memcpy (old_value, &deprecated_registers[REGISTER_BYTE (regno)],
	      REGISTER_SIZE);
d663 1
a663 2
      memcpy (&deprecated_registers[REGISTER_BYTE (regno)], old_value,
	      REGISTER_SIZE);
d1543 1
d1562 2
d1579 2
d1597 2
d1600 2
d1606 8
d1616 1
d1620 1
d1629 2
@


1.30.4.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d58 1
a58 1
#include "gdb_stat.h"
@


1.30.4.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d1479 1
a1479 1
	    printf_filtered ("   startfunc: %s\n", DEPRECATED_SYMBOL_NAME (msym));
d1490 1
a1490 1
	    printf_filtered (" - Sleep func: %s\n", DEPRECATED_SYMBOL_NAME (msym));
@


1.30.4.4
log
@2003-03-07  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Replace uses of
	SYMBOL_MATCHES_NATURAL_NAME by equivalent uses of
	SYMBOL_NATURAL_NAME, strcmp_iw.
	* symtab.h (SYMBOL_MATCHES_NATURAL_NAME): Delete.
	* minsyms.c (lookup_minimal_symbol_linkage): Make static.
	(lookup_minimal_symbol_natural): Ditto.
	(lookup_minimal_symbol): Only search on linkage names; rename
	first argument to 'linkage_name'.
	(lookup_minimal_symbol_linkage): Delete.
	(lookup_minimal_symbol_natural): Delete.
	(add_minsym_to_demangled_hash_table): Go back to using
	SYMBOL_DEMANGLED_NAME instead of SYMBOL_NATURAL_NAME.
	(lookup_minimal_symbol_aux): Don't use
	SYMBOL_MATCHES_NATURAL_NAME: do a strcmp_iw on
	SYMBOL_DEMANGLED_NAME instead.  Add comment.
	(build_minimal_symbol_hash_tables): Go back to only adding to
	demangled has table if SYMBOL_DEMANGLED_NAME is non-NULL.
	* symtab.h: Delete declarations for lookup_minimal_symbol_linkage
	and lookup_minimal_symbol_natural.
	* valops.c (find_function_in_inferior): Use lookup_symbol_linkage
	instead of lookup_symbol.  Change comment.
	* remote.c (remote_check_symbols): Use
	lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol, but add FIXME comment as well.
	* objc-lang.c: Ditto.
	* c-exp.y: Use lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol.
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y (push_expression_name): Ditto.
	* f-exp.y: Ditto.
	* printcmd.c (address_info): Ditto.
	* symtab.h: Declare lookup_minimal_symbol_linkage_or_natural.
	* minsyms.c (lookup_minimal_symbol_linkage_or_natural): New.
	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME instead of
	DEPRECATED_SYMBOL_NAME.
	* tracepoint.c (scope_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* sol-thread.c (info_cb): Ditto.
	* printcmd.c (address_info): Ditto.
	* hppa-tdep.c (hppa_fix_call_dummy): Ditto.
	(hppa_in_solib_call_trampoline): Ditto.
	* findvar.c (read_var_value): Ditto.
@
text
@d1479 1
a1479 1
	    printf_filtered ("   startfunc: %s\n", SYMBOL_LINKAGE_NAME (msym));
@


1.30.4.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d650 1
a650 1
      char* old_value = (char*) alloca (DEPRECATED_REGISTER_SIZE);
d652 1
a652 1
	      DEPRECATED_REGISTER_SIZE);
d665 1
a665 1
	      DEPRECATED_REGISTER_SIZE);
@


1.30.4.6
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a64 2
#include "gdb_string.h"

d649 4
a652 4
      char old_value[MAX_REGISTER_SIZE];
      
      /* Save new register value.  */
      regcache_collect (regno, old_value);
d663 3
a665 2
      /* Restore new register value.  */
      supply_register (regno, old_value);
@


1.30.4.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d404 2
@


1.29
log
@2002-01-03  Michael Snyder  <msnyder@@redhat.com>

	Implement a "generate-core-file" command in gdb, save target state.
	* gcore.c: New file.  Implement new command 'generate-core-file'.
	Save a corefile image of the current state of the inferior.
	* linux-proc.c: Add linux-specific code for saving corefiles.
	* target.h (struct target_ops): Add new target vectors for saving
	corefiles; to_find_memory_regions and to_make_corefile_notes.
	(target_find_memory_regions): New macro.
	(target_make_corefile_notes): New macro.
	* target.c (update_current_target): Inherit new target methods.
	(dummy_find_memory_regions): New place-holder method.
	(dummy_make_corefile_notes): New place-holder method.
	(init_dummy_target): Initialize new dummy target vectors.
	* exec.c (exec_set_find_memory_regions): New function.
	Allow the exec_ops vector for memory regions to be taken over.
	(exec_make_note_section): New function, target vector method.
	* defs.h (exec_set_find_memory_regions): Export prototype.
	* procfs.c (proc_find_memory_regions): New function, corefile method.
	(procfs_make_note_section): New function, corefile method.
	(init_procfs_ops): Set new target vector pointers.
	(find_memory_regions_callback): New function.
	(procfs_do_thread_registers): New function.
	(procfs_corefile_thread_callback): New function.
	* sol-thread.c (sol_find_memory_regions): New function.
	(sol_make_note_section): New function.
	(init_sol_thread_ops): Initialize new target vectors.
	* inftarg.c (inftarg_set_find_memory_regions): New function.
	Allow to_find_memory_regions vector to be taken over.
	(inftarg_set_make_corefile_notes): New function.
	Allow to_make_corefile_notes vector to be taken over.
	* thread-db.c (thread_db_new_objfile): Don't activate thread-db
	interface layer if not target_has_execution (may be a corefile).
	* config/i386/linux.mh: Add gcore.o to NATDEPFILES.
	* config/sparc/sun4sol2.mh: Ditto.
	* config/alpha/alpha-linux.mh: Ditto.
	* config/arm/linux.mh: Ditto.
	* config/i386/x86-64linux.mh: Ditto.
	* config/ia64/linux.mh: Ditto.
	* config/m68k/linux.mh: Ditto.
	* config/mips/linux.mh: Ditto.
	* config/powerpc/linux.mh: Ditto.
	* config/sparc/linux.mh: Ditto.
@
text
@d1559 1
@


1.29.8.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a1558 1
  sol_thread_ops.to_terminal_save_ours = terminal_save_ours;
@


1.28
log
@Approved by kev@@cygnus.com
ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* coff-solib.c (coff_solib_add): Add new readsyms arg.
	* irix5-nat.c (solib_add): Ditto.
	* osfsolib.c (solib_add): Ditto.
	* pa64solib.c (pa64_solib_add): Ditto.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* solib.c (solib_add): Ditto.
	* somsolib.c (som_solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* coff-solib.h (coff_solib_add): Add new readsyms arg to prototype.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* pa64solib.h (pa64_solib_add): Ditto.
	* solib.h (solib_add): Ditto.
	* somsolib.h (som_solib_add): Ditto.
	* config/i386/tm-cygwin.h (child_solib_add): Ditto.

	* coff-solib.c (coff_solib_add):  If readsyms is zero don't read
	symbols but do any other needed work for shared libs.
	* irix5-nat.c: Ditto.
	* osfsolib.c (solib_add): Ditto.
	* solib.c (solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* irix5-nat.c (sharedlibrary_command): Pass 1 as readsyms to
	solib_add to force reading of shared library symbols.
	* osfsolib.c (sharedlibrary_command;): Ditto.
	* pa64solib.c (pa64_solib_sharedlibrary_command): Ditto.
	* solib.c (sharedlibrary_command): Ditto.
	* somsolib.c (som_solib_sharedlibrary_command): Ditto.
	* xcoffsolib.c (sharedlibrary_command): Ditto.

	* coff-solib.c (coff_solib_create_inferior_hook): Call solib_add
	unconditionally with auto_solib_add.
	* irix5-nat.c (solib_create_inferior_hook): Ditto.
	* osfsolib.c (solib_create_inferior_hook): Ditto.
	* solib.c (solib_create_inferior_hook): Ditto.
	* solib-osf.c (osf_solib_create_inferior_hook): Ditto.
	* solib-svr4.c (enable_break): Ditto.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Ditto.

	* corelow.c (solib_add_stub): Add auto_solib_add to args passed
	via SOLIB_ADD.
	* sol-thread.c (sol_thread_attach): Ditto.
	* config/rs6000/nm-rs6000.h (SOLIB_ADD): Ditto.

	* infcmd.c (attach_command): Remove auto_solib_add decl.
	Call SOLIB_ADD directly with auto_solib_add.
	* infrun.c (handle_inferior_event): Ditto.

	* coff-solib.h (SOLIB_ADD): Add readsyms arg.
	* pa64solib.h (SOLIB_ADD): Ditto.
	* solib.h (SOLIB_ADD): Ditto.
	* somsolib.h (SOLIB_ADD): Ditto.
	* config/i386/tm-cygwin.h (SOLIB_ADD): Ditto.

	* fork-child.c (clone_and_follow_inferior): Remove unused
	auto_solib_add decl.

	* pa64solib.c (pa64_solib_add): Call add_to_solist with readsyms.
	(read_dld_descriptor): Ditto.
	(pa64_solib_add): Call read_dld_descriptor with	readsyms.
	(pa64_solib_in_dynamic_linker): Ditto.

	* corelow.c (symfile.h): Need this for auto_solib_add declaration.
	* sol-thread.c (symfile.h): Ditto.

Approved by eliz@@is.elta.co.il
doc/ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* gdbint.texinfo (SOLIB_ADD): Document additional new
	"readsyms" arg.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d1514 16
d1580 2
@


1.27
log
@Redefine ptid_t to be a struct rather than an int.
@
text
@d63 1
d419 1
a419 1
  SOLIB_ADD ((char *) 0, from_tty, (struct target_ops *) 0);
@


1.26
log
@Consolidate save_inferior_ptid/restore_inferior_ptid implementation to
one source file.
@
text
@d114 3
a116 6
#define THREAD_FLAG		0x80000000
#define is_thread(ARG)		(((ARG) & THREAD_FLAG) != 0)
#define is_lwp(ARG)		(((ARG) & THREAD_FLAG) == 0)
#define GET_LWP(PID)		TIDGET (PID)
#define GET_THREAD(PID)		TIDGET (PID)
#define BUILD_LWP(TID, PID)	MERGEPID (PID, TID)
d118 5
a122 1
#define BUILD_THREAD(TID, PID)	(MERGEPID (PID, TID) | THREAD_FLAG)
@


1.25
log
@Phase 1 of the ptid_t changes.
@
text
@a99 2
static struct cleanup *save_inferior_ptid (void);
static void restore_inferior_ptid (void *pid);
a393 44
}

/*

   LOCAL FUNCTION

   save_inferior_ptid - Save inferior_ptid on the cleanup list
   restore_inferior_ptid - Restore inferior_ptid from the cleanup list

   SYNOPSIS

   struct cleanup *save_inferior_ptid ()
   void restore_inferior_ptid (int pid)

   DESCRIPTION

   These two functions act in unison to restore inferior_ptid in
   case of an error.

   NOTES

   inferior_ptid is a global variable that needs to be changed by many of
   these routines before calling functions in procfs.c.  In order to
   guarantee that inferior_ptid gets restored (in case of errors), you
   need to call save_inferior_ptid before changing it.  At the end of the
   function, you should invoke do_cleanups to restore it.

 */


static struct cleanup *
save_inferior_ptid (void)
{
  ptid_t *saved_ptid = xmalloc (sizeof (ptid_t));
  *saved_ptid = inferior_ptid;
  return make_cleanup (restore_inferior_ptid, saved_ptid);
}

static void
restore_inferior_ptid (void *data)
{
  ptid_t *saved_ptid = data;
  inferior_ptid = *saved_ptid;
  xfree (saved_ptid);
@


1.24
log
@Update/correct copyright notices.
@
text
@d76 1
a76 1
extern char *procfs_pid_to_str (int pid);
d87 1
a87 1
    pid_t pid;
d100 2
a101 2
static struct cleanup *save_inferior_pid (void);
static void restore_inferior_pid (void *pid);
d104 4
a107 4
static int thread_to_lwp (int thread_id, int default_lwp);
static void sol_thread_resume (int pid, int step, enum target_signal signo);
static int lwp_to_thread (int lwp);
static int sol_thread_alive (int pid);
d291 1
a291 1
   int thread_to_lwp (thread_id, default_lwp)
d305 2
a306 2
static int
thread_to_lwp (int thread_id, int default_lwp)
d319 1
a319 1
    return -1;			/* thread must have terminated */
d325 1
a325 1
    return -1;			/* thread must have terminated */
d332 1
a332 1
	return default_lwp;
d361 2
a362 2
static int
lwp_to_thread (int lwp)
d374 1
a374 1
    return -1;			/* defunct lwp */
d378 1
a378 1
    return -1;			/* thread must have terminated */
d391 1
a391 1
    return -1;			/* thread must have terminated */
d402 2
a403 2
   save_inferior_pid - Save inferior_pid on the cleanup list
   restore_inferior_pid - Restore inferior_pid from the cleanup list
d407 2
a408 2
   struct cleanup *save_inferior_pid ()
   void restore_inferior_pid (int pid)
d412 1
a412 1
   These two functions act in unison to restore inferior_pid in
d417 1
a417 1
   inferior_pid is a global variable that needs to be changed by many of
d419 2
a420 2
   guarantee that inferior_pid gets restored (in case of errors), you
   need to call save_inferior_pid before changing it.  At the end of the
d427 1
a427 1
save_inferior_pid (void)
d429 3
a431 3
  int *saved_pid = xmalloc (sizeof (int));
  *saved_pid = inferior_pid;
  return make_cleanup (restore_inferior_pid, saved_pid);
d435 1
a435 1
restore_inferior_pid (void *data)
d437 3
a439 3
  int *saved_pid = data;
  inferior_pid = *saved_pid;
  xfree (saved_pid);
d468 1
a468 1
      main_ph.pid = inferior_pid;	/* Save for xfer_memory */
d470 3
a472 3
      inferior_pid = lwp_to_thread (inferior_pid);
      if (inferior_pid == -1)
	inferior_pid = main_ph.pid;
d474 1
a474 1
	add_thread (inferior_pid);
d490 1
a490 1
  inferior_pid = PIDGET (main_ph.pid);
d501 1
a501 1
sol_thread_resume (int pid, int step, enum target_signal signo)
d505 1
a505 1
  old_chain = save_inferior_pid ();
d507 3
a509 3
  inferior_pid = thread_to_lwp (inferior_pid, main_ph.pid);
  if (inferior_pid == -1)
    inferior_pid = procfs_first_available ();
d511 1
a511 1
  if (pid != -1)
d513 1
a513 1
      int save_pid = pid;
d515 2
a516 2
      pid = thread_to_lwp (pid, -2);
      if (pid == -2)		/* Inactive thread */
d518 3
a520 3
      if (info_verbose && pid == -1)
	warning ("Specified thread %d seems to have terminated",
		 GET_THREAD (save_pid));
d523 1
a523 1
  procfs_ops.to_resume (pid, step, signo);
d531 2
a532 2
static int
sol_thread_wait (int pid, struct target_waitstatus *ourstatus)
d534 2
a535 2
  int rtnval;
  int save_pid;
d538 2
a539 2
  save_pid = inferior_pid;
  old_chain = save_inferior_pid ();
d541 3
a543 3
  inferior_pid = thread_to_lwp (inferior_pid, main_ph.pid);
  if (inferior_pid == -1)
    inferior_pid = procfs_first_available ();
d545 1
a545 1
  if (pid != -1)
d547 1
a547 1
      int save_pid = pid;
d549 2
a550 2
      pid = thread_to_lwp (pid, -2);
      if (pid == -2)		/* Inactive thread */
d552 3
a554 3
      if (info_verbose && pid == -1)
	warning ("Specified thread %d seems to have terminated",
		 GET_THREAD (save_pid));
d557 1
a557 1
  rtnval = procfs_ops.to_wait (pid, ourstatus);
d563 2
a564 2
      if (rtnval == -1)
	rtnval = save_pid;
d568 1
a568 1
	  && rtnval != save_pid
d598 1
a598 1
  if (!is_thread (inferior_pid))
d607 1
a607 1
  /* Solaris thread: convert inferior_pid into a td_thrhandle_t */
d609 1
a609 1
  thread = GET_THREAD (inferior_pid);
d676 1
a676 1
  if (!is_thread (inferior_pid))
d682 1
a682 1
  /* Solaris thread: convert inferior_pid into a td_thrhandle_t */
d684 1
a684 1
  thread = GET_THREAD (inferior_pid);
d777 1
a777 1
  old_chain = save_inferior_pid ();
d779 3
a781 3
  if (is_thread (inferior_pid) ||	/* A thread */
      !target_thread_alive (inferior_pid))	/* An lwp, but not alive */
    inferior_pid = procfs_first_available ();	/* Find any live lwp.  */
d811 1
a811 1
sol_thread_notice_signals (int pid)
d813 1
a813 1
  procfs_ops.to_notice_signals (PIDGET (pid));
d823 1
a823 1
  if (sol_thread_active && inferior_pid != 0)
d825 1
a825 1
      main_ph.pid = inferior_pid;	/* Save for xfer_memory */
d829 3
a831 3
      inferior_pid = lwp_to_thread (inferior_pid);
      if (inferior_pid == -1)
	inferior_pid = main_ph.pid;
d833 2
a834 2
      if (!in_thread_list (inferior_pid))
	add_thread (inferior_pid);
d918 1
a918 1
   static bool sol_thread_alive (int pid);
d927 1
a927 1
sol_thread_alive (int pid)
d929 1
a929 1
  if (is_thread (pid))		/* non-kernel thread */
d933 1
d935 1
a935 1
      pid = GET_THREAD (pid);
d946 1
a946 1
	return procfs_ops.to_thread_alive (pid);
d948 1
a948 1
	return orig_core_ops.to_thread_alive (pid);
d1054 1
a1054 1
  old_chain = save_inferior_pid ();
d1056 3
a1058 3
  if (is_thread (inferior_pid) ||	/* A thread */
      !target_thread_alive (inferior_pid))	/* An lwp, but not alive */
    inferior_pid = procfs_first_available ();	/* Find any live lwp.  */
d1158 1
a1158 1
  old_chain = save_inferior_pid ();
d1160 1
a1160 1
  inferior_pid = BUILD_LWP (lwpid, PIDGET (inferior_pid));
d1181 1
a1181 1
  old_chain = save_inferior_pid ();
d1183 1
a1183 1
  inferior_pid = BUILD_LWP (lwpid, PIDGET (inferior_pid));
d1290 1
a1290 1
  old_chain = save_inferior_pid ();
d1292 1
a1292 1
  inferior_pid = BUILD_LWP (lwpid, PIDGET (inferior_pid));
d1313 1
a1313 1
  old_chain = save_inferior_pid ();
d1315 1
a1315 1
  inferior_pid = BUILD_LWP (lwpid, PIDGET (inferior_pid));
d1357 1
a1357 1
  extern struct ssd *procfs_find_LDT_entry (int);
d1363 1
a1363 1
  if (inferior_pid <= 0 || lwpid <= 0)
d1366 1
a1366 1
  ret = procfs_find_LDT_entry (BUILD_LWP (lwpid, PIDGET (inferior_pid)));
d1380 1
a1380 1
solaris_pid_to_str (int pid)
d1386 1
a1386 1
    return procfs_pid_to_str (pid);
d1388 1
a1388 1
  if (is_thread (pid))
d1390 1
a1390 1
      int lwp;
d1392 1
a1392 1
      lwp = thread_to_lwp (pid, -2);
d1394 4
a1397 4
      if (lwp == -1)
	sprintf (buf, "Thread %d (defunct)", GET_THREAD (pid));
      else if (lwp != -2)
	sprintf (buf, "Thread %d (LWP %d)", GET_THREAD (pid), GET_LWP (lwp));
d1399 1
a1399 1
	sprintf (buf, "Thread %d        ", GET_THREAD (pid));
d1401 2
a1402 2
  else if (GET_LWP (pid) != 0)
    sprintf (buf, "LWP    %d        ", GET_LWP (pid));
d1404 1
a1404 1
    sprintf (buf, "process %d    ", PIDGET (pid));
d1419 1
a1419 1
  int pid;
d1425 3
a1427 3
  pid = BUILD_THREAD (ti.ti_tid, PIDGET (inferior_pid));
  if (!in_thread_list (pid))
    add_thread (pid);
d1439 1
a1439 1
  if (inferior_pid == -1)
d1444 1
a1444 1
  procfs_find_new_threads ();	/* first find new kernel threads. */
@


1.23
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 2000, 2001 Free Software Foundation,
   Inc.
@


1.22
log
@* sol-thread.c (restore_inferior_pid): Save the PID in a freshly
allocated buffer.
(save_inferior_pid): Restore the PID from that tempoary
buffer. Delete the buffer.
* utils.c (make_cleanup_close, do_close_cleanup): Ditto for FD.
@
text
@d2 2
a3 1
   Copyright 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
d62 1
@


1.21
log
@2001-02-06  Michael Snyder  <msnyder@@makita.cygnus.com>
	Submitted by Paul Hilfinger (hilfingr@@gnat.com)
	and Andrei Petrov (and@@genesyslab.com).
	* findvar.c: Buffers of size MAX_REGISTER_RAW_SIZE or REGISTER_BYTES
	must be allocated dynamically, since these are no longer constants.
	* infcmd.c: Ditto.
	* regcache.c: Ditto.
	* remote.c: Ditto.
	* sol-thread.c: Ditto.
	* valops.c: Ditto.
	* config/sparc/sun4sol2.mh (MH_CFLAGS): Add -I/usr/include/v9, as a
	work-around for a missing Sun header file in solaris for sparc64.
@
text
@d427 3
a429 1
  return make_cleanup (restore_inferior_pid, (void *) inferior_pid);
d433 1
a433 1
restore_inferior_pid (void *pid)
d435 3
a437 1
  inferior_pid = (int) pid;
@


1.20
log
@* dcache.c (dcache_write_line): Fix typo.

* memattr.c (delete_mem_region): Replace free() with xfree().
(mem_number): Add explicit type.

* sol-thread.c (sol_thread_xfer_memory): Add attrib argument.
(rw_common): Likewise.
@
text
@d688 1
a688 1
      char old_value[REGISTER_SIZE];
@


1.19
log
@* gdbarch.sh, hp-psymtab-read.c, hpread.c, m3-nat.c, mcore-tdep.c,
mips-tdep.c, monitor.c, regcache.c, remote-es.c, ser-unix.c,
somread.c, tracepoint.c: Fix spelling errors in comments.
* gdbarch.c: Regenerate.

* gnu-nat.c (S_exception_raise_request): Fix typos and spelling
errors in strings.
* m3-nat.c (intercept_exec_calls, mach_thread_parse_id): Likewise.
* mcore-tdep.c (mcore_analyze_prologue): Likewise.
* mips-tdep.c (mips16_next_pc, _initialize_mips_tdep): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-rdp.c (handle_swi): Likewise.
* remote-vx.c (vx_load_command): Likewise.
* sh-tdep.c (sh_do_pseudo_register): Likewise.
* sol-thread.c (td_err_string): Likewise.
* symtab.c (decode_line_2): Likewise.
-------------------------------------------------------------------
@
text
@d765 1
d779 2
a780 1
    retval = procfs_ops.to_xfer_memory (memaddr, myaddr, len, dowrite, target);
d783 1
a783 1
					   dowrite, target);
d1065 1
d1067 2
a1068 1
	cc = procfs_ops.to_xfer_memory (addr, buf, size, dowrite, &procfs_ops);
d1070 2
a1071 1
	cc = orig_core_ops.to_xfer_memory (addr, buf, size, dowrite, &core_ops);
@


1.18
log
@Protoization.
@
text
@d220 1
a220 1
    {TD_PARTIALREG, "Only part of register set was writen/read"},
@


1.17
log
@	* sol-thread.c (ps_pdmodel):  Return PR_MODEL_UNKNOWN instead of
	PS_ERR if exec_bfd is not yet open.
@
text
@d757 6
d764 2
a765 6
sol_thread_xfer_memory (memaddr, myaddr, len, dowrite, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int dowrite;
     struct target_ops *target;	/* ignored */
@


1.16
log
@Fix mistaken check-in.
@
text
@d1324 2
a1325 3
    return PS_ERR;

  if (bfd_get_arch_size (exec_bfd) == 32)
@


1.15
log
@2000-09-05  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * sol-thread.c (ps_pdmodel): Protect with an ifdef.
@
text
@d456 3
a458 5
  if (auto_solib_add)
    {
      /* Must get symbols from solibs before libthread_db can run! */
      SOLIB_ADD ((char *) 0, from_tty, (struct target_ops *) 0);
    }
@


1.14
log
@Rename bfd_elf_get_arch_size to bfd_get_arch_size().
@
text
@d455 6
a460 2
  /* Must get symbols from solibs before libthread_db can run! */
  SOLIB_ADD ((char *) 0, from_tty, (struct target_ops *) 0);
d1316 1
d1335 1
@


1.13
log
@2000-08-29  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * valops.c (value_cast): Indentation fix-up.
        * acconfig.h (HAVE_PRGREGSET32_T, HAVE_PRFPREGSET32_T,
        HAVE_STRUCT_LINK_MAP32): New configure macros.
        * config.in: Ditto.
        * configure.in: Test for the above new macros.
        * breakpoint.c: Update copyright date.
        * core-sol2.c: Include v9/sys/privregs.h directly to
        work around a bug in Sun's Solaris 8 header files.
        (fetch_core_registers): Use the above new configure macros to
        handle cross-debugging of 32-bit core files on a 64-bit host.
        * sol-thread.c (ps_pdmodel) New function.
        (rw_common): For debugging of 32-bit apps on a 64-bit host,
        truncate addresses to 32 bits.
        * solib.c (solib_extract_address): Functionize.  Make 32/64 aware.
        (LM_ADDR, LM_NEXT, LM_NAME): Ditto.
        (IGNORE_FIRST_LINK_MAP): Ditto.
        (first_link_map_member): Make 32/64 aware.
        (open_symbol_file_object): Ditto.
        (current_sos): Ditto.
@
text
@d1051 1
a1051 1
  if (bfd_elf_get_arch_size (exec_bfd) == 32)
d1323 1
a1323 1
  if (bfd_elf_get_arch_size (exec_bfd) == 32)
@


1.12
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998 Free Software Foundation, Inc.
d60 1
d1048 7
d1308 19
@


1.11
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d195 1
a195 2
td_err_string (errcode)
     td_err_e errcode;
d253 1
a253 2
td_state_string (statecode)
     td_thr_state_e statecode;
d303 1
a303 3
thread_to_lwp (thread_id, default_lwp)
     int thread_id;
     int default_lwp;
d359 1
a359 2
lwp_to_thread (lwp)
     int lwp;
d424 1
a424 1
save_inferior_pid ()
d430 1
a430 2
restore_inferior_pid (pid)
     void *pid;
d442 1
a442 3
sol_thread_open (arg, from_tty)
     char *arg;
     int from_tty;
d451 1
a451 3
sol_thread_attach (args, from_tty)
     char *args;
     int from_tty;
d479 1
a479 3
sol_thread_detach (args, from_tty)
     char *args;
     int from_tty;
d492 1
a492 4
sol_thread_resume (pid, step, signo)
     int pid;
     int step;
     enum target_signal signo;
d523 1
a523 3
sol_thread_wait (pid, ourstatus)
     int pid;
     struct target_waitstatus *ourstatus;
d577 1
a577 2
sol_thread_fetch_registers (regno)
     int regno;
d655 1
a655 2
sol_thread_store_registers (regno)
     int regno;
d749 1
a749 1
sol_thread_prepare_to_store ()
d786 1
a786 2
sol_thread_files_info (ignore)
     struct target_ops *ignore;
d792 1
a792 1
sol_thread_kill_inferior ()
d798 1
a798 2
sol_thread_notice_signals (pid)
     int pid;
d806 1
a806 4
sol_thread_create_inferior (exec_file, allargs, env)
     char *exec_file;
     char *allargs;
     char **env;
d839 1
a839 2
sol_thread_new_objfile (objfile)
     struct objfile *objfile;
d883 1
a883 1
sol_thread_mourn_inferior ()
d892 1
a892 1
sol_thread_can_run ()
d914 1
a914 2
sol_thread_alive (pid)
     int pid;
d939 1
a939 1
sol_thread_stop ()
d1336 1
a1336 2
solaris_pid_to_str (pid)
     int pid;
d1371 1
a1371 3
sol_find_new_threads_callback (th, ignored)
     const td_thrhandle_t *th;
     void *ignored;
d1389 1
a1389 1
sol_find_new_threads ()
d1407 1
a1407 3
sol_core_open (filename, from_tty)
     char *filename;
     int from_tty;
d1413 1
a1413 2
sol_core_close (quitting)
     int quitting;
d1419 1
a1419 3
sol_core_detach (args, from_tty)
     char *args;
     int from_tty;
d1426 1
a1426 2
sol_core_files_info (t)
     struct target_ops *t;
d1436 1
a1436 3
info_cb (th, s)
     const td_thrhandle_t *th;
     void *s;
d1506 1
a1506 3
info_solthreads (args, from_tty)
     char *args;
     int from_tty;
d1514 1
a1514 3
ignore (addr, contents)
     CORE_ADDR addr;
     char *contents;
d1521 1
a1521 1
init_sol_thread_ops ()
d1569 1
a1569 1
init_sol_core_ops ()
d1622 1
a1622 1
_initialize_sol_thread ()
@


1.10
log
@2000-06-01  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * sol-thread.c (rw_common): Circumstances (eg. a bug in Sun's
        thread_db library) may cause this function to be called with an
        illegal address, in which case procfs_to_xfer_memory will
        return zero.  Return an error code instead of looping forever.
@
text
@d860 1
a860 1
static void (*target_new_objfile_chain) PARAMS ((struct objfile *));
@


1.9
log
@PARAMS removal.
@
text
@d1093 14
@


1.8
log
@2000-05-26  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * gregset.h: New file.  Typedefs for gdb_gregset_t and
        gdb_fpregset_t, prototypes for supply_gregset and friends.
        * procfs.c: Include gregset.h.  Delete local prototypes for
        supply_gregset etc., and local typedef gdb_gregset_t etc.
        * sol-thread.c: Include gregset.h, delete local prototypes,
        add appropriate casts to gdb_gregset_t.
        * uw-thread.c, lin-thread.c, core-sol2.c, core-regset.c,
        sparc-tdep.c, ptx4-nat.c, ppc-linux-nat.c, mipsv4-nat.c,
        m88k-nat.c, m68klinux-nat.c, m68k-tdep.c, irix5-nat.c,
        irix4-nat.c, ia64-linux-nat.c, i386v4-nat.c, cxux-nat.c,
        arm-linux-nat.c, alpha-nat.c: Include gregset.h.
        * config/nm-linux.h: Define GDB_GREGSET_T, GDB_FPREGET_T.
        * config/sparc/tm-sun4sol2.h: Ditto.
@
text
@d73 1
a73 1
extern char *procfs_pid_to_str PARAMS ((int pid));
d97 9
a105 10
static struct cleanup *save_inferior_pid PARAMS ((void));
static void restore_inferior_pid PARAMS ((void *pid));
static char *td_err_string PARAMS ((td_err_e errcode));
static char *td_state_string PARAMS ((td_thr_state_e statecode));
static int thread_to_lwp PARAMS ((int thread_id, int default_lwp));
static void sol_thread_resume PARAMS ((int pid, int step,
				       enum target_signal signo));
static int lwp_to_thread PARAMS ((int lwp));
static int sol_thread_alive PARAMS ((int pid));
static void sol_core_close PARAMS ((int quitting));
d107 2
a108 2
static void init_sol_thread_ops PARAMS ((void));
static void init_sol_core_ops PARAMS ((void));
@


1.7
log
@2000-05-08  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * sol-thread.c (sol_thread_create_inferior): only add the thread
        to the thread list if it is not already in there.
        (prototypes for thread_db func ptrs): pretty up formatting.
@
text
@d75 2
a76 13
/* Note that these prototypes differ slightly from those used in procfs.c
   for of two reasons.  One, we can't use gregset_t, as that's got a whole
   different meaning under Solaris (also, see above).  Two, we can't use the
   pointer form here as these are actually arrays of ints (for Sparc's at
   least), and are automatically coerced into pointers to ints when used as
   parameters.  That makes it impossible to avoid a compiler warning when
   passing pr{g fp}regset_t's from a parameter to an argument of one of
   these functions.  */

extern void supply_gregset PARAMS ((const prgregset_t));
extern void fill_gregset PARAMS ((prgregset_t, int));
extern void supply_fpregset PARAMS ((const prfpregset_t *));
extern void fill_fpregset PARAMS ((prfpregset_t *, int));
d652 2
a653 2
  supply_gregset (gregset);
  supply_fpregset (&fpregset);
d680 1
a680 1
  prgregset_t regset;
d708 1
a708 1
      val = p_td_thr_getgregs (&thandle, regset);
d738 2
a739 2
  fill_gregset (regset, regno);
  fill_fpregset (&fpregset, regno);
d741 1
a741 1
  val = p_td_thr_setgregs (&thandle, regset);
d1155 1
a1155 1
  fill_gregset (gregset, -1);
d1174 1
a1174 1
  supply_gregset (gregset);
d1287 1
a1287 1
  fill_fpregset (fpregset, -1);
d1306 1
a1306 1
  supply_fpregset (fpregset);
@


1.6
log
@	* sol-thread.c (init_sol_core_ops): Initialize to_thread_alive
	and document to_find_new_threads bug.
@
text
@d136 53
a188 48
static void
  (*p_td_log) (const int on_off);
static td_err_e
  (*p_td_ta_new) (const struct ps_prochandle * ph_p, td_thragent_t ** ta_pp);
static td_err_e
  (*p_td_ta_delete) (td_thragent_t * ta_p);
static td_err_e
  (*p_td_init) (void);
static td_err_e
  (*p_td_ta_get_ph) (const td_thragent_t * ta_p, struct ps_prochandle ** ph_pp);
static td_err_e
  (*p_td_ta_get_nthreads) (const td_thragent_t * ta_p, int *nthread_p);
static td_err_e
  (*p_td_ta_tsd_iter) (const td_thragent_t * ta_p, td_key_iter_f * cb, void *cbdata_p);
static td_err_e
  (*p_td_ta_thr_iter) (const td_thragent_t * ta_p, td_thr_iter_f * cb, void *cbdata_p, td_thr_state_e state,
	       int ti_pri, sigset_t * ti_sigmask_p, unsigned ti_user_flags);
static td_err_e
  (*p_td_thr_validate) (const td_thrhandle_t * th_p);
static td_err_e
  (*p_td_thr_tsd) (const td_thrhandle_t * th_p, const thread_key_t key, void **data_pp);
static td_err_e
  (*p_td_thr_get_info) (const td_thrhandle_t * th_p, td_thrinfo_t * ti_p);
static td_err_e
  (*p_td_thr_getfpregs) (const td_thrhandle_t * th_p, prfpregset_t * fpregset);
static td_err_e
  (*p_td_thr_getxregsize) (const td_thrhandle_t * th_p, int *xregsize);
static td_err_e
  (*p_td_thr_getxregs) (const td_thrhandle_t * th_p, const caddr_t xregset);
static td_err_e
  (*p_td_thr_sigsetmask) (const td_thrhandle_t * th_p, const sigset_t ti_sigmask);
static td_err_e
  (*p_td_thr_setprio) (const td_thrhandle_t * th_p, const int ti_pri);
static td_err_e
  (*p_td_thr_setsigpending) (const td_thrhandle_t * th_p, const uchar_t ti_pending_flag, const sigset_t ti_pending);
static td_err_e
  (*p_td_thr_setfpregs) (const td_thrhandle_t * th_p, const prfpregset_t * fpregset);
static td_err_e
  (*p_td_thr_setxregs) (const td_thrhandle_t * th_p, const caddr_t xregset);
static td_err_e
  (*p_td_ta_map_id2thr) (const td_thragent_t * ta_p, thread_t tid, td_thrhandle_t * th_p);
static td_err_e
  (*p_td_ta_map_lwp2thr) (const td_thragent_t * ta_p, lwpid_t lwpid, td_thrhandle_t * th_p);
static td_err_e
  (*p_td_thr_getgregs) (const td_thrhandle_t * th_p, prgregset_t regset);
static td_err_e
  (*p_td_thr_setgregs) (const td_thrhandle_t * th_p, const prgregset_t regset);

d398 2
a399 1
    return lwp;			/* libthread doesn't know about it, just return lwp */
d856 2
a857 1
      add_thread (inferior_pid);
@


1.5
log
@	* sol-thread.c (gdb_ps_addr_t):  New typedef, depends on definition
	of PROC_SERVICE_IS_OLD.
	(ps_pglobal_lookup, ps_pdread, ps_pdwrite, ps_ptread, ps_ptwrite,
	rw_common):  Change argument type from psaddr_t to gdb_ps_addr_t.
@
text
@d1635 1
d1637 5
@


1.5.2.1
log
@* sol-thread.c (init_sol_core_ops): Initialize to_thread_alive
and document to_find_new_threads bug.
@
text
@a1634 1
  sol_core_ops.to_thread_alive = sol_thread_alive;
a1635 5
  /* On Solaris/x86, when debugging a threaded core file from process <n>,
     the following causes "info threads" to produce "procfs: couldn't find pid
     <n> in procinfo list" where <n> is the pid of the process that produced
     the core file.  Disable it for now. */
  /* sol_core_ops.to_find_new_threads = sol_find_new_threads; */
@


1.4
log
@	* sol-thread.c (GET_LWP, GET_THREAD, BUILD_LWP, BUILD_THREAD):
	Change to rely on PIDGET etc.
	* config/i386/nm-i386sol2.h (TARGET_HAS_WATCHPOINTS,
	TARGET_CAN_USE_HARDWARE_WATCHPOINT, HAVE_CONTINUABLE_WATCHPOINT,
	STOPPED_BY_WATCHPOINT, target_[insert/remove]_watchpoint):
	define.  Allow target to use procfs hardware watchpoints.
	* config/sparc/nm-sun4sol2.h: ditto.
	* config/i386/tm-i386sol2.h (PIDGET, TIDGET, MERGEPID): modify
	definitions to use 16 bits for the pid, 15 bits for the tid, and
	1 bit for the flag.
	* config/sparc/tm-sun4sol2.h: ditto.
	(SOFTWARE_SINGLE_STEP, SOFTWARE_SINGLE_STEP_P): undefine.
	* testsuite/gdb.threads/pthreads.exp (all_threads_running): Allow
	for more than 15 thread increments.
@
text
@d998 1
d1004 1
d1049 1
a1049 1
		   const char *ld_symbol_name, psaddr_t * ld_symbol_addr)
d1066 1
a1066 1
rw_common (int dowrite, const struct ps_prochandle *ph, psaddr_t addr,
d1110 1
a1110 1
ps_pdread (gdb_ps_prochandle_t ph, psaddr_t addr,
d1119 1
a1119 1
ps_pdwrite (gdb_ps_prochandle_t ph, psaddr_t addr,
d1128 1
a1128 1
ps_ptread (gdb_ps_prochandle_t ph, psaddr_t addr,
d1137 1
a1137 1
ps_ptwrite (gdb_ps_prochandle_t ph, psaddr_t addr,
@


1.3
log
@2000-03-23  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * sol-thread.c (ps_pglobal_lookup): Change argument type from
        paddr_t to psaddr_t.  This mistake appears to date from an
        erroneous man page in Solaris 2.5 -- the correct type from the
        system headers has always been psaddr_t.
        (ps_pdread, ps_pdwrite, ps_ptread, ps_ptwrite): ditto.
        (rw_common): ditto.
@
text
@d125 6
a130 6
#define THREAD_FLAG            0x80000000
#define is_thread(ARG)         (((ARG) & THREAD_FLAG) != 0)
#define is_lwp(ARG)            (((ARG) & THREAD_FLAG) == 0)
#define GET_LWP(PID)           TIDGET (PID)
#define GET_THREAD(PID)        (((PID) >> 16) & 0x7fff)
#define BUILD_LWP(TID, PID)    ((TID) << 16 | (PID))
d132 1
a132 1
#define BUILD_THREAD(THREAD_ID, PID) (THREAD_FLAG | BUILD_LWP (THREAD_ID, PID))
d1330 6
@


1.2
log
@From Peter Schauer: Fix Solaris/x86 threads by copying linux code.
@
text
@d1047 1
a1047 1
		   const char *ld_symbol_name, paddr_t * ld_symbol_addr)
d1064 1
a1064 1
rw_common (int dowrite, const struct ps_prochandle *ph, paddr_t addr,
d1108 1
a1108 1
ps_pdread (gdb_ps_prochandle_t ph, paddr_t addr,
d1117 1
a1117 1
ps_pdwrite (gdb_ps_prochandle_t ph, paddr_t addr,
d1126 1
a1126 1
ps_ptread (gdb_ps_prochandle_t ph, paddr_t addr,
d1135 1
a1135 1
ps_ptwrite (gdb_ps_prochandle_t ph, paddr_t addr,
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a56 1
#include <unistd.h>
d61 2
a62 2
extern struct target_ops sol_thread_ops; /* Forward declaration */
extern struct target_ops sol_core_ops; /* Forward declaration */
d71 2
a72 2
extern struct target_ops procfs_ops; /* target vector for procfs.c */
extern struct target_ops core_ops; /* target vector for corelow.c */
d94 3
a96 3
{
  pid_t pid;
};
d99 4
a102 4
{
  int num;
  char *str;
};
d108 2
a109 2
static struct cleanup * save_inferior_pid PARAMS ((void));
static void restore_inferior_pid PARAMS ((int pid));
d112 1
a112 1
static int  thread_to_lwp PARAMS ((int thread_id, int default_lwp));
d122 10
a131 6
#define THREAD_FLAG 0x80000000
#define is_thread(ARG) (((ARG) & THREAD_FLAG) != 0)
#define is_lwp(ARG) (((ARG) & THREAD_FLAG) == 0)
#define GET_LWP(LWP_ID) (TIDGET(LWP_ID))
#define GET_THREAD(THREAD_ID) (((THREAD_ID) >> 16) & 0x7fff)
#define BUILD_LWP(LWP_ID, PID) ((LWP_ID) << 16 | (PID))
d139 1
a139 1
  (*p_td_ta_new) (const struct ps_prochandle *ph_p, td_thragent_t **ta_pp);
d141 1
a141 1
  (*p_td_ta_delete) (td_thragent_t *ta_p);
d145 1
a145 1
  (*p_td_ta_get_ph) (const td_thragent_t *ta_p, struct ps_prochandle **ph_pp);
d147 1
a147 1
  (*p_td_ta_get_nthreads) (const td_thragent_t *ta_p, int *nthread_p);
d149 1
a149 1
  (*p_td_ta_tsd_iter) (const td_thragent_t *ta_p, td_key_iter_f *cb, void *cbdata_p);
d151 2
a152 2
  (*p_td_ta_thr_iter) (const td_thragent_t *ta_p, td_thr_iter_f *cb, void *cbdata_p, td_thr_state_e state,
		       int ti_pri, sigset_t *ti_sigmask_p, unsigned ti_user_flags);
d154 1
a154 1
  (*p_td_thr_validate) (const td_thrhandle_t *th_p);
d156 1
a156 1
  (*p_td_thr_tsd) (const td_thrhandle_t *th_p, const thread_key_t key, void **data_pp);
d158 1
a158 1
  (*p_td_thr_get_info) (const td_thrhandle_t *th_p, td_thrinfo_t *ti_p);
d160 1
a160 1
  (*p_td_thr_getfpregs) (const td_thrhandle_t *th_p, prfpregset_t *fpregset);
d162 1
a162 1
  (*p_td_thr_getxregsize) (const td_thrhandle_t *th_p, int *xregsize);
d164 1
a164 1
  (*p_td_thr_getxregs) (const td_thrhandle_t *th_p, const caddr_t xregset);
d166 1
a166 1
  (*p_td_thr_sigsetmask) (const td_thrhandle_t *th_p, const sigset_t ti_sigmask);
d168 1
a168 1
  (*p_td_thr_setprio) (const td_thrhandle_t *th_p, const int ti_pri);
d170 1
a170 1
  (*p_td_thr_setsigpending) (const td_thrhandle_t *th_p, const uchar_t ti_pending_flag, const sigset_t ti_pending);
d172 1
a172 1
  (*p_td_thr_setfpregs) (const td_thrhandle_t *th_p, const prfpregset_t *fpregset);
d174 1
a174 1
  (*p_td_thr_setxregs) (const td_thrhandle_t *th_p, const caddr_t xregset);
d176 1
a176 1
  (*p_td_ta_map_id2thr) (const td_thragent_t *ta_p, thread_t tid, td_thrhandle_t *th_p);
d178 1
a178 1
  (*p_td_ta_map_lwp2thr) (const td_thragent_t *ta_p, lwpid_t lwpid, td_thrhandle_t *th_p);
d180 1
a180 1
  (*p_td_thr_getgregs) (const td_thrhandle_t *th_p, prgregset_t regset);
d182 1
a182 1
  (*p_td_thr_setgregs) (const td_thrhandle_t *th_p, const prgregset_t regset);
d186 1
a186 1
LOCAL FUNCTION
d188 1
a188 1
	td_err_string - Convert a thread_db error code to a string
d190 1
a190 1
SYNOPSIS
d192 1
a192 1
	char * td_err_string (errcode)
d194 1
a194 1
DESCRIPTION
d196 2
a197 2
	Return the thread_db error string associated with errcode.  If errcode
	is unknown, then return a message.
d206 24
a229 23
    td_err_table[] = {
      {TD_OK,		"generic \"call succeeded\""},
      {TD_ERR,		"generic error."},
      {TD_NOTHR,	"no thread can be found to satisfy query"},
      {TD_NOSV,		"no synch. variable can be found to satisfy query"},
      {TD_NOLWP,	"no lwp can be found to satisfy query"},
      {TD_BADPH,	"invalid process handle"},
      {TD_BADTH,	"invalid thread handle"},
      {TD_BADSH,	"invalid synchronization handle"},
      {TD_BADTA,	"invalid thread agent"},
      {TD_BADKEY,	"invalid key"},
      {TD_NOMSG,	"td_thr_event_getmsg() called when there was no message"},
      {TD_NOFPREGS,	"FPU register set not available for given thread"},
      {TD_NOLIBTHREAD,	"application not linked with libthread"},
      {TD_NOEVENT,	"requested event is not supported"},
      {TD_NOCAPAB,	"capability not available"},
      {TD_DBERR,	"Debugger service failed"},
      {TD_NOAPLIC,	"Operation not applicable to"},
      {TD_NOTSD,	"No thread specific data for this thread"},
      {TD_MALLOC,	"Malloc failed"},
      {TD_PARTIALREG,	"Only part of register set was writen/read"},
      {TD_NOXREGS,	"X register set not available for given thread"}
    };
d237 1
a237 1
		  
d245 1
a245 1
LOCAL FUNCTION
d247 1
a247 1
	td_state_string - Convert a thread_db state code to a string
d249 1
a249 1
SYNOPSIS
d251 1
a251 1
	char * td_state_string (statecode)
d253 1
a253 1
DESCRIPTION
d255 2
a256 2
	Return the thread_db state string associated with statecode.  If
	statecode is unknown, then return a message.
d265 11
a275 10
    td_thr_state_table[] = {
      {TD_THR_ANY_STATE, "any state"},
      {TD_THR_UNKNOWN,	"unknown"},
      {TD_THR_STOPPED,	"stopped"},
      {TD_THR_RUN,	"run"},
      {TD_THR_ACTIVE,	"active"},
      {TD_THR_ZOMBIE,	"zombie"},
      {TD_THR_SLEEP,	"sleep"},
      {TD_THR_STOPPED_ASLEEP, "stopped asleep"}
    };
d283 1
a283 1
		  
d291 1
a291 1
LOCAL FUNCTION
d293 1
a293 1
	thread_to_lwp - Convert a Posix or Solaris thread id to a LWP id.
d295 1
a295 1
SYNOPSIS
d297 1
a297 1
	int thread_to_lwp (thread_id, default_lwp)
d299 1
a299 1
DESCRIPTION
d301 3
a303 3
	This function converts a Posix or Solaris thread id to a lightweight
	process id.  If thread_id is non-existent, that's an error.  If it's
	an inactive thread, then we return default_lwp.
d305 1
a305 1
NOTES
d307 1
a307 1
	This function probably shouldn't call error()...
d321 1
a321 1
    return thread_id;			/* It's already an LWP id */
d327 1
a327 1
    return -1;		/* thread must have terminated */
d333 1
a333 1
    return -1;		/* thread must have terminated */
d350 1
a350 1
LOCAL FUNCTION
d352 1
a352 1
	lwp_to_thread - Convert a LWP id to a Posix or Solaris thread id.
d354 1
a354 1
SYNOPSIS
d356 1
a356 1
	int lwp_to_thread (lwp_id)
d358 1
a358 1
DESCRIPTION
d360 2
a361 2
	This function converts a lightweight process id to a Posix or Solaris
	thread id.  If thread_id is non-existent, that's an error.
d363 1
a363 1
NOTES
d365 1
a365 1
	This function probably shouldn't call error()...
d387 1
a387 1
    return -1;		/* thread must have terminated */
d399 1
a399 1
    return -1;		/* thread must have terminated */
d408 1
a408 1
LOCAL FUNCTION
d410 2
a411 2
	save_inferior_pid - Save inferior_pid on the cleanup list
	restore_inferior_pid - Restore inferior_pid from the cleanup list
d413 1
a413 1
SYNOPSIS
d415 2
a416 2
	struct cleanup *save_inferior_pid ()
	void restore_inferior_pid (int pid)
d418 1
a418 1
DESCRIPTION
d420 2
a421 2
	These two functions act in unison to restore inferior_pid in
	case of an error.
d423 1
a423 1
NOTES
d425 5
a429 5
	inferior_pid is a global variable that needs to be changed by many of
	these routines before calling functions in procfs.c.  In order to
	guarantee that inferior_pid gets restored (in case of errors), you
	need to call save_inferior_pid before changing it.  At the end of the
	function, you should invoke do_cleanups to restore it.
d437 1
a437 1
  return make_cleanup (restore_inferior_pid, inferior_pid);
d442 1
a442 1
     int pid;
d444 1
a444 1
  inferior_pid = pid;
d471 1
a471 1
  SOLIB_ADD ((char *)0, from_tty, (struct target_ops *)0);
d475 1
a475 1
      main_ph.pid = inferior_pid; /* Save for xfer_memory */
d499 1
d531 1
a531 1
	warning ("Specified thread %d seems to have terminated", 
d567 1
a567 1
	warning ("Specified thread %d seems to have terminated", 
d614 1
a614 1
    { /* LWP: pass the request on to procfs.c */
d693 1
a693 1
    { /* LWP: pass the request on to procfs.c */
d711 1
a711 1
      memcpy(old_value, & registers[REGISTER_BYTE(regno)], REGISTER_SIZE);
d723 1
a723 1
      memcpy(& registers[REGISTER_BYTE(regno)], old_value, REGISTER_SIZE);
d785 1
a785 1
     struct target_ops *target; /* ignored */
d792 1
a792 1
  if (is_thread (inferior_pid) ||		/* A thread */
d842 1
a842 1
      main_ph.pid = inferior_pid; /* Save for xfer_memory */
d860 7
d876 1
a876 2

      return;
d881 1
a881 1
    return;
d889 4
a892 1
    error ("target_new_objfile: td_init: %s", td_err_string (val));
d896 1
a896 1
    return;
d898 4
a901 1
    error ("target_new_objfile: td_ta_new: %s", td_err_string (val));
d904 4
d929 1
a929 1
LOCAL FUNCTION
d931 1
a931 1
	sol_thread_alive     - test thread for "aliveness"
d933 1
a933 1
SYNOPSIS
d935 1
a935 1
	static bool sol_thread_alive (int pid);
d937 1
a937 1
DESCRIPTION
d939 1
a939 1
	returns true if thread still active in inferior.
d954 1
a954 1
	return 0;	/* thread not found */
d956 2
a957 2
	return 0;	/* thread not valid */
      return 1;		/* known thread: return true */
d959 2
a960 1
  else			/* kernel thread (LWP): let procfs test it */
d981 5
a985 5
      NEWER		    	OLDER
      struct ps_prochandle *  	const struct ps_prochandle *
      void*			char*
      const void*		char*
      int			size_t
d994 3
a996 3
typedef const struct ps_prochandle * gdb_ps_prochandle_t;
typedef char * gdb_ps_read_buf_t;
typedef char * gdb_ps_write_buf_t;
d999 3
a1001 3
typedef struct ps_prochandle * gdb_ps_prochandle_t;
typedef void * gdb_ps_read_buf_t;
typedef const void * gdb_ps_write_buf_t;
d1011 2
d1019 2
d1027 2
d1035 2
d1043 2
d1047 1
a1047 1
		   const char *ld_symbol_name, paddr_t *ld_symbol_addr)
d1071 1
a1071 1
  if (is_thread (inferior_pid) ||		/* A thread */
d1105 2
d1114 2
d1120 1
a1120 1
  return rw_common (1, ph, addr, (char*) buf, size);
d1123 2
d1132 2
d1138 1
a1138 1
  return rw_common (1, ph, addr, (char*) buf, size);
d1141 1
a1141 1
/* Get integer regs */
d1152 1
a1152 1
  
d1164 1
a1164 1
/* Set integer regs */
d1175 1
a1175 1
  
d1187 2
d1190 1
a1190 1
ps_plog (const char *fmt, ...)
d1273 1
a1273 1
/* Get floating-point regs.  */
d1277 1
a1277 1
	       prfpregset_t *fpregset)
d1296 1
a1296 1
/* Set floating-point regs.  */
d1300 1
a1300 1
	       const prfpregset_t *fpregset)
d1307 1
a1307 1
  
d1321 1
a1321 8
/* Get local descriptor table.  */

#include <sys/procfs.h>
#include <sys/reg.h>
#include <sys/sysi86.h>

static int nldt_allocated = 0;
static struct ssd *ldt_bufp = NULL;
d1327 3
a1329 14
  gregset_t gregset;
  int lwp_fd;
  ps_err_e val;
  int nldt;
  int i;

  /* Get procfs file descriptor for the LWP.  */
  lwp_fd = procfs_get_pid_fd (BUILD_LWP (lwpid, PIDGET (inferior_pid)));
  if (lwp_fd < 0)
    return PS_BADLID;

  /* Fetch registers und LDT descriptors.  */
  if (ioctl (lwp_fd, PIOCGREG, &gregset) == -1)
    return PS_ERR;
d1331 2
a1332 4
  if (ioctl (lwp_fd, PIOCNLDT, &nldt) == -1)
    return PS_ERR;

  if (nldt_allocated < nldt)
d1334 2
a1335 3
      ldt_bufp
	= (struct ssd *) xrealloc (ldt_bufp, (nldt + 1) * sizeof (struct ssd));
      nldt_allocated = nldt;
d1337 1
a1337 2

  if (ioctl (lwp_fd, PIOCLDT, ldt_bufp) == -1)
d1339 1
a1339 14

  /* Search LDT for the LWP via register GS.  */
  for (i = 0; i < nldt; i++)
    {
      if (ldt_bufp[i].sel == (gregset[GS] & 0xffff))
	{
	  *pldt = ldt_bufp[i];
	  return PS_OK;
	}
    }

  /* LDT not found.  */
  return PS_ERR;
}        
d1381 1
a1381 1
sol_find_new_threads_callback(th, ignored)
d1389 1
a1389 1
  if ((retval = p_td_thr_get_info(th, &ti)) != TD_OK)
d1393 3
a1395 3
  pid = BUILD_THREAD(ti.ti_tid, PIDGET(inferior_pid));
  if (!in_thread_list(pid))
    add_thread(pid);
d1400 2
a1401 2
void
sol_find_new_threads()
d1409 1
a1409 1
      printf_filtered("No process.\n");
d1412 2
a1413 1
  p_td_ta_thr_iter (main_ta, sol_find_new_threads_callback, (void *)0,
a1448 1
#ifdef MAINTENANCE_CMDS
d1453 1
a1453 1
static int 
a1459 1
  struct minimal_symbol *msym;
d1463 2
a1464 2
      printf_filtered ("%s thread #%d, lwp %d, ", 
		       ti.ti_type == TD_THR_SYSTEM ? "system" : "user  ", 
d1466 2
a1467 1
      switch (ti.ti_state) {
d1469 22
a1490 9
	case TD_THR_UNKNOWN: printf_filtered ("<unknown state>");	break;
	case TD_THR_STOPPED: printf_filtered ("(stopped)");	break;
	case TD_THR_RUN:     printf_filtered ("(run)    ");	break;
	case TD_THR_ACTIVE:  printf_filtered ("(active) ");	break;
	case TD_THR_ZOMBIE:  printf_filtered ("(zombie) ");	break;
	case TD_THR_SLEEP:   printf_filtered ("(asleep) ");	break;
	case TD_THR_STOPPED_ASLEEP: 
	  printf_filtered ("(stopped asleep)");			break;
      }
d1493 8
a1500 4
	if (msym = lookup_minimal_symbol_by_pc (ti.ti_startfunc))
	  printf_filtered ("   startfunc: %s\n", SYMBOL_NAME (msym));
	else
	  printf_filtered ("   startfunc: 0x%08x\n", ti.ti_startfunc);
d1504 8
a1511 4
	if (msym = lookup_minimal_symbol_by_pc (ti.ti_pc))
	  printf_filtered (" - Sleep func: %s\n", SYMBOL_NAME (msym));
	else
	  printf_filtered (" - Sleep func: 0x%08x\n", ti.ti_startfunc);
d1520 1
a1520 1
  return 0;    
d1530 1
a1530 1
  p_td_ta_thr_iter (main_ta, info_cb, args, 
a1533 1
#endif /* MAINTENANCE_CMDS */
d1576 2
d1595 7
a1601 7
  sol_core_ops.to_shortname  = "solaris-core";
  sol_core_ops.to_longname  = "Solaris core threads and pthread.";
  sol_core_ops.to_doc  = "Solaris threads and pthread support for core files.";
  sol_core_ops.to_open  = sol_core_open;
  sol_core_ops.to_close  = sol_core_close;
  sol_core_ops.to_attach  = sol_thread_attach;
  sol_core_ops.to_detach  = sol_core_detach;
d1603 2
a1604 2
  /* sol_core_ops.to_wait  = 0;	 */
  sol_core_ops.to_fetch_registers  = sol_thread_fetch_registers;
d1607 4
a1610 4
  sol_core_ops.to_xfer_memory  = sol_thread_xfer_memory;
  sol_core_ops.to_files_info  = sol_core_files_info;
  sol_core_ops.to_insert_breakpoint  = ignore;
  sol_core_ops.to_remove_breakpoint  = ignore;
d1619 12
a1630 11
  sol_core_ops.to_create_inferior  = sol_thread_create_inferior;
  sol_core_ops.to_stratum  = core_stratum;
  sol_core_ops.to_has_all_memory  = 0;
  sol_core_ops.to_has_memory  = 1;
  sol_core_ops.to_has_stack  = 1;
  sol_core_ops.to_has_registers  = 1;
  sol_core_ops.to_has_execution  = 0;
  sol_core_ops.to_has_thread_control  = tc_none;
  sol_core_ops.to_sections  = 0;
  sol_core_ops.to_sections_end  = 0;
  sol_core_ops.to_magic  = OPS_MAGIC;
d1683 2
a1684 4
#ifdef MAINTENANCE_CMDS
  add_cmd ("sol-threads", class_maintenance, info_solthreads, 
	    "Show info on Solaris user threads.\n", &maintenanceinfolist);
#endif /* MAINTENANCE_CMDS */
d1686 2
a1687 2
  memcpy(&orig_core_ops, &core_ops, sizeof (struct target_ops));
  memcpy(&core_ops, &sol_core_ops, sizeof (struct target_ops));
d1690 3
d1695 1
a1695 1
 die:
d1703 1
a1703 1
  add_target(&core_ops);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d109 1
a109 1
static void restore_inferior_pid PARAMS ((void *pid));
d431 1
a431 1
  return make_cleanup (restore_inferior_pid, (void*) inferior_pid);
d436 1
a436 1
     void *pid;
d438 1
a438 1
  inferior_pid = (int) pid;
d1439 1
d1504 1
d1651 1
d1654 1
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@d1392 1
a1392 1
sol_find_new_threads ()
a1544 1
  sol_thread_ops.to_find_new_threads = sol_find_new_threads;
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d61 2
a62 2
extern struct target_ops sol_thread_ops;	/* Forward declaration */
extern struct target_ops sol_core_ops;	/* Forward declaration */
d71 2
a72 2
extern struct target_ops procfs_ops;	/* target vector for procfs.c */
extern struct target_ops core_ops;	/* target vector for corelow.c */
d94 3
a96 3
  {
    pid_t pid;
  };
d99 4
a102 4
  {
    int num;
    char *str;
  };
d108 1
a108 1
static struct cleanup *save_inferior_pid PARAMS ((void));
d112 1
a112 1
static int thread_to_lwp PARAMS ((int thread_id, int default_lwp));
d135 1
a135 1
  (*p_td_ta_new) (const struct ps_prochandle * ph_p, td_thragent_t ** ta_pp);
d137 1
a137 1
  (*p_td_ta_delete) (td_thragent_t * ta_p);
d141 1
a141 1
  (*p_td_ta_get_ph) (const td_thragent_t * ta_p, struct ps_prochandle ** ph_pp);
d143 1
a143 1
  (*p_td_ta_get_nthreads) (const td_thragent_t * ta_p, int *nthread_p);
d145 1
a145 1
  (*p_td_ta_tsd_iter) (const td_thragent_t * ta_p, td_key_iter_f * cb, void *cbdata_p);
d147 2
a148 2
  (*p_td_ta_thr_iter) (const td_thragent_t * ta_p, td_thr_iter_f * cb, void *cbdata_p, td_thr_state_e state,
	       int ti_pri, sigset_t * ti_sigmask_p, unsigned ti_user_flags);
d150 1
a150 1
  (*p_td_thr_validate) (const td_thrhandle_t * th_p);
d152 1
a152 1
  (*p_td_thr_tsd) (const td_thrhandle_t * th_p, const thread_key_t key, void **data_pp);
d154 1
a154 1
  (*p_td_thr_get_info) (const td_thrhandle_t * th_p, td_thrinfo_t * ti_p);
d156 1
a156 1
  (*p_td_thr_getfpregs) (const td_thrhandle_t * th_p, prfpregset_t * fpregset);
d158 1
a158 1
  (*p_td_thr_getxregsize) (const td_thrhandle_t * th_p, int *xregsize);
d160 1
a160 1
  (*p_td_thr_getxregs) (const td_thrhandle_t * th_p, const caddr_t xregset);
d162 1
a162 1
  (*p_td_thr_sigsetmask) (const td_thrhandle_t * th_p, const sigset_t ti_sigmask);
d164 1
a164 1
  (*p_td_thr_setprio) (const td_thrhandle_t * th_p, const int ti_pri);
d166 1
a166 1
  (*p_td_thr_setsigpending) (const td_thrhandle_t * th_p, const uchar_t ti_pending_flag, const sigset_t ti_pending);
d168 1
a168 1
  (*p_td_thr_setfpregs) (const td_thrhandle_t * th_p, const prfpregset_t * fpregset);
d170 1
a170 1
  (*p_td_thr_setxregs) (const td_thrhandle_t * th_p, const caddr_t xregset);
d172 1
a172 1
  (*p_td_ta_map_id2thr) (const td_thragent_t * ta_p, thread_t tid, td_thrhandle_t * th_p);
d174 1
a174 1
  (*p_td_ta_map_lwp2thr) (const td_thragent_t * ta_p, lwpid_t lwpid, td_thrhandle_t * th_p);
d176 1
a176 1
  (*p_td_thr_getgregs) (const td_thrhandle_t * th_p, prgregset_t regset);
d178 1
a178 1
  (*p_td_thr_setgregs) (const td_thrhandle_t * th_p, const prgregset_t regset);
d182 1
a182 1
   LOCAL FUNCTION
d184 1
a184 1
   td_err_string - Convert a thread_db error code to a string
d186 1
a186 1
   SYNOPSIS
d188 1
a188 1
   char * td_err_string (errcode)
d190 1
a190 1
   DESCRIPTION
d192 2
a193 2
   Return the thread_db error string associated with errcode.  If errcode
   is unknown, then return a message.
d202 23
a224 24
    td_err_table[] =
  {
    {TD_OK, "generic \"call succeeded\""},
    {TD_ERR, "generic error."},
    {TD_NOTHR, "no thread can be found to satisfy query"},
    {TD_NOSV, "no synch. variable can be found to satisfy query"},
    {TD_NOLWP, "no lwp can be found to satisfy query"},
    {TD_BADPH, "invalid process handle"},
    {TD_BADTH, "invalid thread handle"},
    {TD_BADSH, "invalid synchronization handle"},
    {TD_BADTA, "invalid thread agent"},
    {TD_BADKEY, "invalid key"},
    {TD_NOMSG, "td_thr_event_getmsg() called when there was no message"},
    {TD_NOFPREGS, "FPU register set not available for given thread"},
    {TD_NOLIBTHREAD, "application not linked with libthread"},
    {TD_NOEVENT, "requested event is not supported"},
    {TD_NOCAPAB, "capability not available"},
    {TD_DBERR, "Debugger service failed"},
    {TD_NOAPLIC, "Operation not applicable to"},
    {TD_NOTSD, "No thread specific data for this thread"},
    {TD_MALLOC, "Malloc failed"},
    {TD_PARTIALREG, "Only part of register set was writen/read"},
    {TD_NOXREGS, "X register set not available for given thread"}
  };
d232 1
a232 1

d240 1
a240 1
   LOCAL FUNCTION
d242 1
a242 1
   td_state_string - Convert a thread_db state code to a string
d244 1
a244 1
   SYNOPSIS
d246 1
a246 1
   char * td_state_string (statecode)
d248 1
a248 1
   DESCRIPTION
d250 2
a251 2
   Return the thread_db state string associated with statecode.  If
   statecode is unknown, then return a message.
d260 10
a269 11
    td_thr_state_table[] =
  {
    {TD_THR_ANY_STATE, "any state"},
    {TD_THR_UNKNOWN, "unknown"},
    {TD_THR_STOPPED, "stopped"},
    {TD_THR_RUN, "run"},
    {TD_THR_ACTIVE, "active"},
    {TD_THR_ZOMBIE, "zombie"},
    {TD_THR_SLEEP, "sleep"},
    {TD_THR_STOPPED_ASLEEP, "stopped asleep"}
  };
d277 1
a277 1

d285 1
a285 1
   LOCAL FUNCTION
d287 1
a287 1
   thread_to_lwp - Convert a Posix or Solaris thread id to a LWP id.
d289 1
a289 1
   SYNOPSIS
d291 1
a291 1
   int thread_to_lwp (thread_id, default_lwp)
d293 1
a293 1
   DESCRIPTION
d295 3
a297 3
   This function converts a Posix or Solaris thread id to a lightweight
   process id.  If thread_id is non-existent, that's an error.  If it's
   an inactive thread, then we return default_lwp.
d299 1
a299 1
   NOTES
d301 1
a301 1
   This function probably shouldn't call error()...
d315 1
a315 1
    return thread_id;		/* It's already an LWP id */
d321 1
a321 1
    return -1;			/* thread must have terminated */
d327 1
a327 1
    return -1;			/* thread must have terminated */
d344 1
a344 1
   LOCAL FUNCTION
d346 1
a346 1
   lwp_to_thread - Convert a LWP id to a Posix or Solaris thread id.
d348 1
a348 1
   SYNOPSIS
d350 1
a350 1
   int lwp_to_thread (lwp_id)
d352 1
a352 1
   DESCRIPTION
d354 2
a355 2
   This function converts a lightweight process id to a Posix or Solaris
   thread id.  If thread_id is non-existent, that's an error.
d357 1
a357 1
   NOTES
d359 1
a359 1
   This function probably shouldn't call error()...
d381 1
a381 1
    return -1;			/* thread must have terminated */
d393 1
a393 1
    return -1;			/* thread must have terminated */
d402 1
a402 1
   LOCAL FUNCTION
d404 2
a405 2
   save_inferior_pid - Save inferior_pid on the cleanup list
   restore_inferior_pid - Restore inferior_pid from the cleanup list
d407 1
a407 1
   SYNOPSIS
d409 2
a410 2
   struct cleanup *save_inferior_pid ()
   void restore_inferior_pid (int pid)
d412 1
a412 1
   DESCRIPTION
d414 2
a415 2
   These two functions act in unison to restore inferior_pid in
   case of an error.
d417 1
a417 1
   NOTES
d419 5
a423 5
   inferior_pid is a global variable that needs to be changed by many of
   these routines before calling functions in procfs.c.  In order to
   guarantee that inferior_pid gets restored (in case of errors), you
   need to call save_inferior_pid before changing it.  At the end of the
   function, you should invoke do_cleanups to restore it.
d431 1
a431 1
  return make_cleanup (restore_inferior_pid, (void *) inferior_pid);
d465 1
a465 1
  SOLIB_ADD ((char *) 0, from_tty, (struct target_ops *) 0);
d469 1
a469 1
      main_ph.pid = inferior_pid;	/* Save for xfer_memory */
d524 1
a524 1
	warning ("Specified thread %d seems to have terminated",
d560 1
a560 1
	warning ("Specified thread %d seems to have terminated",
d607 1
a607 1
    {				/* LWP: pass the request on to procfs.c */
d686 1
a686 1
    {				/* LWP: pass the request on to procfs.c */
d704 1
a704 1
      memcpy (old_value, &registers[REGISTER_BYTE (regno)], REGISTER_SIZE);
d716 1
a716 1
      memcpy (&registers[REGISTER_BYTE (regno)], old_value, REGISTER_SIZE);
d778 1
a778 1
     struct target_ops *target;	/* ignored */
d785 1
a785 1
  if (is_thread (inferior_pid) ||	/* A thread */
d835 1
a835 1
      main_ph.pid = inferior_pid;	/* Save for xfer_memory */
d906 1
a906 1
   LOCAL FUNCTION
d908 1
a908 1
   sol_thread_alive     - test thread for "aliveness"
d910 1
a910 1
   SYNOPSIS
d912 1
a912 1
   static bool sol_thread_alive (int pid);
d914 1
a914 1
   DESCRIPTION
d916 1
a916 1
   returns true if thread still active in inferior.
d931 1
a931 1
	return 0;		/* thread not found */
d933 2
a934 2
	return 0;		/* thread not valid */
      return 1;			/* known thread: return true */
d936 1
a936 2
  else
    /* kernel thread (LWP): let procfs test it */
d957 5
a961 5
   NEWER                        OLDER
   struct ps_prochandle *       const struct ps_prochandle *
   void*                        char*
   const void*          char*
   int                  size_t
d970 3
a972 3
typedef const struct ps_prochandle *gdb_ps_prochandle_t;
typedef char *gdb_ps_read_buf_t;
typedef char *gdb_ps_write_buf_t;
d975 3
a977 3
typedef struct ps_prochandle *gdb_ps_prochandle_t;
typedef void *gdb_ps_read_buf_t;
typedef const void *gdb_ps_write_buf_t;
d1013 1
a1013 1
		   const char *ld_symbol_name, paddr_t * ld_symbol_addr)
d1037 1
a1037 1
  if (is_thread (inferior_pid) ||	/* A thread */
d1082 1
a1082 1
  return rw_common (1, ph, addr, (char *) buf, size);
d1096 1
a1096 1
  return rw_common (1, ph, addr, (char *) buf, size);
d1110 1
a1110 1

d1133 1
a1133 1

d1146 1
a1146 1
ps_plog (const char *fmt,...)
d1233 1
a1233 1
	       prfpregset_t * fpregset)
d1256 1
a1256 1
	       const prfpregset_t * fpregset)
d1263 1
a1263 1

d1330 1
a1330 1
}
d1372 1
a1372 1
sol_find_new_threads_callback (th, ignored)
d1380 1
a1380 1
  if ((retval = p_td_thr_get_info (th, &ti)) != TD_OK)
d1384 3
a1386 3
  pid = BUILD_THREAD (ti.ti_tid, PIDGET (inferior_pid));
  if (!in_thread_list (pid))
    add_thread (pid);
d1400 1
a1400 1
      printf_filtered ("No process.\n");
d1403 1
a1403 1
  p_td_ta_thr_iter (main_ta, sol_find_new_threads_callback, (void *) 0,
d1443 1
a1443 1
static int
d1454 2
a1455 2
      printf_filtered ("%s thread #%d, lwp %d, ",
		       ti.ti_type == TD_THR_SYSTEM ? "system" : "user  ",
d1457 1
a1457 2
      switch (ti.ti_state)
	{
d1459 9
a1467 22
	case TD_THR_UNKNOWN:
	  printf_filtered ("<unknown state>");
	  break;
	case TD_THR_STOPPED:
	  printf_filtered ("(stopped)");
	  break;
	case TD_THR_RUN:
	  printf_filtered ("(run)    ");
	  break;
	case TD_THR_ACTIVE:
	  printf_filtered ("(active) ");
	  break;
	case TD_THR_ZOMBIE:
	  printf_filtered ("(zombie) ");
	  break;
	case TD_THR_SLEEP:
	  printf_filtered ("(asleep) ");
	  break;
	case TD_THR_STOPPED_ASLEEP:
	  printf_filtered ("(stopped asleep)");
	  break;
	}
d1489 1
a1489 1
  return 0;
d1499 1
a1499 1
  p_td_ta_thr_iter (main_ta, info_cb, args,
d1563 7
a1569 7
  sol_core_ops.to_shortname = "solaris-core";
  sol_core_ops.to_longname = "Solaris core threads and pthread.";
  sol_core_ops.to_doc = "Solaris threads and pthread support for core files.";
  sol_core_ops.to_open = sol_core_open;
  sol_core_ops.to_close = sol_core_close;
  sol_core_ops.to_attach = sol_thread_attach;
  sol_core_ops.to_detach = sol_core_detach;
d1571 2
a1572 2
  /* sol_core_ops.to_wait  = 0;  */
  sol_core_ops.to_fetch_registers = sol_thread_fetch_registers;
d1575 4
a1578 4
  sol_core_ops.to_xfer_memory = sol_thread_xfer_memory;
  sol_core_ops.to_files_info = sol_core_files_info;
  sol_core_ops.to_insert_breakpoint = ignore;
  sol_core_ops.to_remove_breakpoint = ignore;
d1587 11
a1597 11
  sol_core_ops.to_create_inferior = sol_thread_create_inferior;
  sol_core_ops.to_stratum = core_stratum;
  sol_core_ops.to_has_all_memory = 0;
  sol_core_ops.to_has_memory = 1;
  sol_core_ops.to_has_stack = 1;
  sol_core_ops.to_has_registers = 1;
  sol_core_ops.to_has_execution = 0;
  sol_core_ops.to_has_thread_control = tc_none;
  sol_core_ops.to_sections = 0;
  sol_core_ops.to_sections_end = 0;
  sol_core_ops.to_magic = OPS_MAGIC;
d1650 2
a1651 2
  add_cmd ("sol-threads", class_maintenance, info_solthreads,
	   "Show info on Solaris user threads.\n", &maintenanceinfolist);
d1653 2
a1654 2
  memcpy (&orig_core_ops, &core_ops, sizeof (struct target_ops));
  memcpy (&core_ops, &sol_core_ops, sizeof (struct target_ops));
d1659 1
a1659 1
die:
d1667 1
a1667 1
  add_target (&core_ops);
@


1.1.1.5
log
@import gdb-1999-08-30 snapshot
@
text
@d57 1
@


1.1.1.6
log
@import gdb-1999-09-08 snapshot
@
text
@d122 6
a127 10
/* Default definitions: These must be defined in tm.h 
   if they are to be shared with a process module such as procfs.  */

#define THREAD_FLAG            0x80000000
#define is_thread(ARG)         (((ARG) & THREAD_FLAG) != 0)
#define is_lwp(ARG)            (((ARG) & THREAD_FLAG) == 0)
#define GET_LWP(PID)           TIDGET (PID)
#define GET_THREAD(PID)        (((PID) >> 16) & 0x7fff)
#define BUILD_LWP(TID, PID)    ((TID) << 16 | (PID))

a494 1
  inferior_pid = PIDGET (main_ph.pid);
a989 2
/* Process stop */

a995 2
/* Process continue */

a1001 2
/* LWP stop */

a1007 2
/* LWP continue */

a1013 2
/* Looks up the symbol LD_SYMBOL_NAME in the debugger's symbol table.  */

a1073 2
/* Copies SIZE bytes from target process .data segment to debugger memory.  */

a1080 2
/* Copies SIZE bytes from debugger memory .data segment to target process.  */

a1087 2
/* Copies SIZE bytes from target process .text segment to debugger memory.  */

a1094 2
/* Copies SIZE bytes from debugger memory .text segment to target process.  */

d1102 1
a1102 1
/* Get integer regs for LWP */
d1125 1
a1125 1
/* Set integer regs for LWP */
a1147 2
/* Log a message (sends to gdb_stderr).  */

d1232 1
a1232 1
/* Get floating-point regs for LWP */
d1255 1
a1255 1
/* Set floating-point regs for LWP */
a1288 2
/* Reads the local descriptor table of a LWP.  */

d1394 1
a1394 1
static void
@


1.1.1.7
log
@import gdb-1999-11-08 snapshot
@
text
@a859 7
/* This new_objfile event is now managed by a chained function pointer. 
 * It is the callee's responsability to call the next client on the chain.
 */

/* Saved pointer to previous owner of the new_objfile event. */
static void (*target_new_objfile_chain) PARAMS ((struct objfile *));

d869 2
a870 1
      goto quit;
d875 1
a875 1
    goto quit;
d883 1
a883 4
    {
      warning ("sol_thread_new_objfile: td_init: %s", td_err_string (val));
      goto quit;
    }
d887 1
a887 1
    goto quit;
d889 1
a889 4
    {
      warning ("sol_thread_new_objfile: td_ta_new: %s", td_err_string (val));
      goto quit;
    }
a891 4
quit:
  /* Call predecessor on chain, if any. */
  if (target_new_objfile_chain)
    target_new_objfile_chain (objfile);
a1700 3
  /* Hook into new_objfile notification. */
  target_new_objfile_chain = target_new_objfile_hook;
  target_new_objfile_hook  = sol_thread_new_objfile;
@


1.1.1.8
log
@import gdb-1999-11-16 snapshot
@
text
@d1496 1
d1530 4
a1533 8
	{
	  struct minimal_symbol *msym;
	  msym = lookup_minimal_symbol_by_pc (ti.ti_startfunc);
	  if (msym)
	    printf_filtered ("   startfunc: %s\n", SYMBOL_NAME (msym));
	  else
	    printf_filtered ("   startfunc: 0x%s\n", paddr (ti.ti_startfunc));
	}
d1537 4
a1540 8
	{
	  struct minimal_symbol *msym;
	  msym = lookup_minimal_symbol_by_pc (ti.ti_pc);
	  if (msym)
	    printf_filtered (" - Sleep func: %s\n", SYMBOL_NAME (msym));
	  else
	    printf_filtered (" - Sleep func: 0x%s\n", paddr (ti.ti_startfunc));
	}
@


1.1.1.9
log
@import gdb-1999-12-21 snapshot
@
text
@a1611 1
  sol_thread_ops.to_pid_to_str = solaris_pid_to_str;
a1661 1
  sol_core_ops.to_pid_to_str = solaris_pid_to_str;
@


1.1.1.10
log
@import gdb-2000-01-05 snapshot
@
text
@a1448 1
  procfs_find_new_threads ();	/* first find new kernel threads. */
@


