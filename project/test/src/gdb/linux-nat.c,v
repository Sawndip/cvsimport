head	1.272;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.264
	gdb_7_6-2013-04-26-release:1.264
	gdb_7_6-branch:1.264.0.2
	gdb_7_6-2013-03-12-branchpoint:1.264
	gdb_7_5_1-2012-11-29-release:1.255
	gdb_7_5-2012-08-17-release:1.255
	gdb_7_5-branch:1.255.0.2
	gdb_7_5-2012-07-18-branchpoint:1.255
	gdb_7_4_1-2012-04-26-release:1.229.2.1
	gdb_7_4-2012-01-24-release:1.229.2.1
	gdb_7_4-branch:1.229.0.2
	gdb_7_4-2011-12-13-branchpoint:1.229
	gdb_7_3_1-2011-09-04-release:1.199.2.1
	gdb_7_3-2011-07-26-release:1.199.2.1
	gdb_7_3-branch:1.199.0.2
	gdb_7_3-2011-04-01-branchpoint:1.199
	gdb_7_2-2010-09-02-release:1.173
	gdb_7_2-branch:1.173.0.2
	gdb_7_2-2010-07-07-branchpoint:1.173
	gdb_7_1-2010-03-18-release:1.163.2.1
	gdb_7_1-branch:1.163.0.2
	gdb_7_1-2010-02-18-branchpoint:1.163
	gdb_7_0_1-2009-12-22-release:1.147
	gdb_7_0-2009-10-06-release:1.147
	gdb_7_0-branch:1.147.0.2
	gdb_7_0-2009-09-16-branchpoint:1.147
	arc-sim-20090309:1.74
	msnyder-checkpoint-072509-branch:1.145.0.2
	msnyder-checkpoint-072509-branchpoint:1.145
	arc-insight_6_8-branch:1.74.0.6
	arc-insight_6_8-branchpoint:1.74
	insight_6_8-branch:1.74.0.4
	insight_6_8-branchpoint:1.74
	reverse-20081226-branch:1.113.0.2
	reverse-20081226-branchpoint:1.113
	multiprocess-20081120-branch:1.110.0.2
	multiprocess-20081120-branchpoint:1.110
	reverse-20080930-branch:1.106.0.2
	reverse-20080930-branchpoint:1.106
	reverse-20080717-branch:1.94.0.2
	reverse-20080717-branchpoint:1.94
	msnyder-reverse-20080609-branch:1.86.0.2
	msnyder-reverse-20080609-branchpoint:1.86
	drow-reverse-20070409-branch:1.56.0.2
	drow-reverse-20070409-branchpoint:1.56
	gdb_6_8-2008-03-27-release:1.74
	gdb_6_8-branch:1.74.0.2
	gdb_6_8-2008-02-26-branchpoint:1.74
	gdb_6_7_1-2007-10-29-release:1.67
	gdb_6_7-2007-10-10-release:1.67
	gdb_6_7-branch:1.67.0.2
	gdb_6_7-2007-09-07-branchpoint:1.67
	insight_6_6-20070208-release:1.50.2.1
	gdb_6_6-2006-12-18-release:1.50.2.1
	gdb_6_6-branch:1.50.0.2
	gdb_6_6-2006-11-15-branchpoint:1.50
	insight_6_5-20061003-release:1.47
	gdb-csl-symbian-6_4_50_20060226-12:1.38.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.34
	nickrob-async-20060828-mergepoint:1.49
	gdb-csl-symbian-6_4_50_20060226-11:1.38.2.1
	gdb-csl-sourcerygxx-4_1-17:1.38.2.1
	gdb-csl-20060226-branch-local-2:1.38.2.1
	gdb-csl-sourcerygxx-4_1-14:1.38.2.1
	gdb-csl-sourcerygxx-4_1-13:1.38.2.1
	gdb-csl-sourcerygxx-4_1-12:1.38.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.38.2.1
	gdb_6_5-20060621-release:1.47
	gdb-csl-sourcerygxx-4_1-9:1.38.2.1
	gdb-csl-sourcerygxx-4_1-8:1.38.2.1
	gdb-csl-sourcerygxx-4_1-7:1.38.2.1
	gdb-csl-arm-2006q1-6:1.38.2.1
	gdb-csl-sourcerygxx-4_1-6:1.38.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.38.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.38.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.38.2.1
	gdb-csl-coldfire-4_1-11:1.38.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.38.2.1
	gdb-csl-coldfire-4_1-10:1.38.2.1
	gdb_6_5-branch:1.47.0.4
	gdb_6_5-2006-05-14-branchpoint:1.47
	gdb-csl-sourcerygxx-4_1-5:1.38.2.1
	nickrob-async-20060513-branch:1.47.0.2
	nickrob-async-20060513-branchpoint:1.47
	gdb-csl-sourcerygxx-4_1-4:1.38.2.1
	msnyder-reverse-20060502-branch:1.43.0.4
	msnyder-reverse-20060502-branchpoint:1.43
	gdb-csl-morpho-4_1-4:1.38.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.38.2.1
	readline_5_1-import-branch:1.43.0.2
	readline_5_1-import-branchpoint:1.43
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.38.2.1
	gdb-csl-symbian-20060226-branch:1.38.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.38.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.38.2.1
	msnyder-reverse-20060331-branch:1.40.0.2
	msnyder-reverse-20060331-branchpoint:1.40
	gdb-csl-available-20060303-branch:1.38.0.4
	gdb-csl-available-20060303-branchpoint:1.38
	gdb-csl-20060226-branch:1.38.0.2
	gdb-csl-20060226-branchpoint:1.38
	gdb_6_4-20051202-release:1.33.4.1
	msnyder-fork-checkpoint-branch:1.34.0.4
	msnyder-fork-checkpoint-branchpoint:1.34
	gdb-csl-gxxpro-6_3-branch:1.34.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.34
	gdb_6_4-branch:1.33.0.4
	gdb_6_4-2005-11-01-branchpoint:1.33
	gdb-csl-arm-20051020-branch:1.33.0.2
	gdb-csl-arm-20051020-branchpoint:1.33
	msnyder-tracepoint-checkpoint-branch:1.30.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.30
	gdb-csl-arm-20050325-2005-q1b:1.27
	gdb-csl-arm-20050325-2005-q1a:1.27
	csl-arm-20050325-branch:1.27.0.2
	csl-arm-20050325-branchpoint:1.27
	gdb-post-i18n-errorwarning-20050211:1.20
	gdb-pre-i18n-errorwarning-20050211:1.19
	gdb_6_3-20041109-release:1.15
	gdb_6_3-branch:1.15.0.2
	gdb_6_3-20041019-branchpoint:1.15
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.6.0.6
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.20
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.18
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.14
	drow_intercu-20040221-branchpoint:1.5
	cagney_bfdfile-20040213-branch:1.5.0.12
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.10
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-branch:1.5.0.8
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.3.2.2
	kettenis_sparc-20030918-branch:1.5.0.6
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.4
	cagney_x86i386-20030821-branch:1.5.0.2
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-branch:1.3.0.4
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.2
	gdb_6_0-2003-06-23-branchpoint:1.3;
locks; strict;
comment	@ * @;


1.272
date	2013.09.30.11.50.11;	author luisgpm;	state Exp;
branches;
next	1.271;

1.271
date	2013.09.03.17.22.45;	author luisgpm;	state Exp;
branches;
next	1.270;

1.270
date	2013.08.22.23.46.28;	author luisgpm;	state Exp;
branches;
next	1.269;

1.269
date	2013.08.19.13.44.41;	author palves;	state Exp;
branches;
next	1.268;

1.268
date	2013.07.01.11.28.30;	author palves;	state Exp;
branches;
next	1.267;

1.267
date	2013.04.22.16.46.15;	author tromey;	state Exp;
branches;
next	1.266;

1.266
date	2013.03.22.14.52.26;	author palves;	state Exp;
branches;
next	1.265;

1.265
date	2013.03.20.15.46.24;	author jkratoch;	state Exp;
branches;
next	1.264;

1.264
date	2013.02.13.14.59.49;	author palves;	state Exp;
branches;
next	1.263;

1.263
date	2013.01.31.18.37.37;	author aristovski;	state Exp;
branches;
next	1.262;

1.262
date	2013.01.01.06.32.46;	author brobecke;	state Exp;
branches;
next	1.261;

1.261
date	2012.11.26.14.19.32;	author palves;	state Exp;
branches;
next	1.260;

1.260
date	2012.11.09.19.57.59;	author tromey;	state Exp;
branches;
next	1.259;

1.259
date	2012.11.09.01.47.15;	author palves;	state Exp;
branches;
next	1.258;

1.258
date	2012.08.16.23.54.50;	author brobecke;	state Exp;
branches;
next	1.257;

1.257
date	2012.08.02.09.36.39;	author qiyao;	state Exp;
branches;
next	1.256;

1.256
date	2012.07.20.16.57.32;	author palves;	state Exp;
branches;
next	1.255;

1.255
date	2012.07.16.19.07.16;	author marckhouzam;	state Exp;
branches;
next	1.254;

1.254
date	2012.07.07.12.13.56;	author jkratoch;	state Exp;
branches;
next	1.253;

1.253
date	2012.07.06.16.52.20;	author jkratoch;	state Exp;
branches;
next	1.252;

1.252
date	2012.07.06.16.49.43;	author jkratoch;	state Exp;
branches;
next	1.251;

1.251
date	2012.06.28.16.34.03;	author palves;	state Exp;
branches;
next	1.250;

1.250
date	2012.05.24.16.51.34;	author palves;	state Exp;
branches;
next	1.249;

1.249
date	2012.05.24.16.39.10;	author palves;	state Exp;
branches;
next	1.248;

1.248
date	2012.05.22.15.04.56;	author palves;	state Exp;
branches;
next	1.247;

1.247
date	2012.04.16.11.24.47;	author qiyao;	state Exp;
branches;
next	1.246;

1.246
date	2012.03.21.13.43.54;	author tschwinge;	state Exp;
branches;
next	1.245;

1.245
date	2012.03.13.15.02.22;	author jkratoch;	state Exp;
branches;
next	1.244;

1.244
date	2012.03.13.15.00.31;	author jkratoch;	state Exp;
branches;
next	1.243;

1.243
date	2012.03.05.21.07.46;	author jkratoch;	state Exp;
branches;
next	1.242;

1.242
date	2012.03.03.09.51.28;	author qiyao;	state Exp;
branches;
next	1.241;

1.241
date	2012.03.01.21.13.58;	author palves;	state Exp;
branches;
next	1.240;

1.240
date	2012.02.27.16.22.13;	author palves;	state Exp;
branches;
next	1.239;

1.239
date	2012.02.16.21.07.20;	author tromey;	state Exp;
branches;
next	1.238;

1.238
date	2012.01.24.13.46.54;	author jkratoch;	state Exp;
branches;
next	1.237;

1.237
date	2012.01.20.09.59.15;	author uweigand;	state Exp;
branches;
next	1.236;

1.236
date	2012.01.20.09.56.55;	author uweigand;	state Exp;
branches;
next	1.235;

1.235
date	2012.01.20.09.49.58;	author uweigand;	state Exp;
branches;
next	1.234;

1.234
date	2012.01.20.09.49.01;	author uweigand;	state Exp;
branches;
next	1.233;

1.233
date	2012.01.19.16.32.58;	author palves;	state Exp;
branches;
next	1.232;

1.232
date	2012.01.04.08.17.05;	author brobecke;	state Exp;
branches;
next	1.231;

1.231
date	2011.12.20.10.40.15;	author palves;	state Exp;
branches;
next	1.230;

1.230
date	2011.12.14.17.20.30;	author palves;	state Exp;
branches;
next	1.229;

1.229
date	2011.12.05.18.49.49;	author palves;	state Exp;
branches
	1.229.2.1;
next	1.228;

1.228
date	2011.11.10.20.17.52;	author palves;	state Exp;
branches;
next	1.227;

1.227
date	2011.11.03.18.24.45;	author jkratoch;	state Exp;
branches;
next	1.226;

1.226
date	2011.11.02.18.47.16;	author jkratoch;	state Exp;
branches;
next	1.225;

1.225
date	2011.10.28.18.29.59;	author palves;	state Exp;
branches;
next	1.224;

1.224
date	2011.10.24.14.25.52;	author palves;	state Exp;
branches;
next	1.223;

1.223
date	2011.10.12.12.11.26;	author palves;	state Exp;
branches;
next	1.222;

1.222
date	2011.10.11.14.58.21;	author palves;	state Exp;
branches;
next	1.221;

1.221
date	2011.10.11.13.58.18;	author palves;	state Exp;
branches;
next	1.220;

1.220
date	2011.10.11.03.31.59;	author devans;	state Exp;
branches;
next	1.219;

1.219
date	2011.10.10.16.40.02;	author palves;	state Exp;
branches;
next	1.218;

1.218
date	2011.10.10.13.50.50;	author palves;	state Exp;
branches;
next	1.217;

1.217
date	2011.10.10.13.23.53;	author palves;	state Exp;
branches;
next	1.216;

1.216
date	2011.10.07.12.06.46;	author uweigand;	state Exp;
branches;
next	1.215;

1.215
date	2011.09.09.19.27.50;	author palves;	state Exp;
branches;
next	1.214;

1.214
date	2011.09.09.19.20.24;	author palves;	state Exp;
branches;
next	1.213;

1.213
date	2011.09.02.21.03.06;	author palves;	state Exp;
branches;
next	1.212;

1.212
date	2011.08.26.19.55.00;	author palves;	state Exp;
branches;
next	1.211;

1.211
date	2011.08.26.19.26.40;	author palves;	state Exp;
branches;
next	1.210;

1.210
date	2011.08.24.12.07.25;	author luisgpm;	state Exp;
branches;
next	1.209;

1.209
date	2011.07.21.23.46.09;	author kcy;	state Exp;
branches;
next	1.208;

1.208
date	2011.06.06.12.47.07;	author palves;	state Exp;
branches;
next	1.207;

1.207
date	2011.05.30.19.26.36;	author jkratoch;	state Exp;
branches;
next	1.206;

1.206
date	2011.05.27.16.55.38;	author jkratoch;	state Exp;
branches;
next	1.205;

1.205
date	2011.05.18.18.03.29;	author jkratoch;	state Exp;
branches;
next	1.204;

1.204
date	2011.05.13.17.28.19;	author devans;	state Exp;
branches;
next	1.203;

1.203
date	2011.05.09.18.43.56;	author devans;	state Exp;
branches;
next	1.202;

1.202
date	2011.04.29.15.54.12;	author palves;	state Exp;
branches;
next	1.201;

1.201
date	2011.04.27.13.29.14;	author uweigand;	state Exp;
branches;
next	1.200;

1.200
date	2011.04.26.15.36.03;	author qiyao;	state Exp;
branches;
next	1.199;

1.199
date	2011.03.09.12.48.55;	author palves;	state Exp;
branches
	1.199.2.1;
next	1.198;

1.198
date	2011.03.02.18.27.41;	author msnyder;	state Exp;
branches;
next	1.197;

1.197
date	2011.03.01.00.40.22;	author msnyder;	state Exp;
branches;
next	1.196;

1.196
date	2011.02.27.16.25.37;	author msnyder;	state Exp;
branches;
next	1.195;

1.195
date	2011.02.26.23.34.44;	author msnyder;	state Exp;
branches;
next	1.194;

1.194
date	2011.02.08.22.35.57;	author msnyder;	state Exp;
branches;
next	1.193;

1.193
date	2011.01.19.17.21.36;	author tromey;	state Exp;
branches;
next	1.192;

1.192
date	2011.01.11.19.16.20;	author bauermann;	state Exp;
branches;
next	1.191;

1.191
date	2011.01.09.03.08.57;	author msnyder;	state Exp;
branches;
next	1.190;

1.190
date	2011.01.07.17.35.27;	author msnyder;	state Exp;
branches;
next	1.189;

1.189
date	2011.01.05.22.22.49;	author msnyder;	state Exp;
branches;
next	1.188;

1.188
date	2011.01.01.15.33.09;	author brobecke;	state Exp;
branches;
next	1.187;

1.187
date	2010.11.28.04.31.24;	author jkratoch;	state Exp;
branches;
next	1.186;

1.186
date	2010.11.02.01.37.32;	author jkratoch;	state Exp;
branches;
next	1.185;

1.185
date	2010.10.17.18.24.47;	author jkratoch;	state Exp;
branches;
next	1.184;

1.184
date	2010.09.06.13.59.02;	author jkratoch;	state Exp;
branches;
next	1.183;

1.183
date	2010.09.02.01.19.32;	author qiyao;	state Exp;
branches;
next	1.182;

1.182
date	2010.08.31.18.08.43;	author jkratoch;	state Exp;
branches;
next	1.181;

1.181
date	2010.08.28.08.38.25;	author jkratoch;	state Exp;
branches;
next	1.180;

1.180
date	2010.07.27.21.22.09;	author jkratoch;	state Exp;
branches;
next	1.179;

1.179
date	2010.07.27.20.51.37;	author jkratoch;	state Exp;
branches;
next	1.178;

1.178
date	2010.07.25.09.31.12;	author jkratoch;	state Exp;
branches;
next	1.177;

1.177
date	2010.07.23.12.19.00;	author jkratoch;	state Exp;
branches;
next	1.176;

1.176
date	2010.07.20.12.54.57;	author jkratoch;	state Exp;
branches;
next	1.175;

1.175
date	2010.07.20.12.33.30;	author jkratoch;	state Exp;
branches;
next	1.174;

1.174
date	2010.07.18.21.21.53;	author jkratoch;	state Exp;
branches;
next	1.173;

1.173
date	2010.07.07.12.28.32;	author uweigand;	state Exp;
branches;
next	1.172;

1.172
date	2010.07.01.15.36.16;	author palves;	state Exp;
branches;
next	1.171;

1.171
date	2010.06.18.23.06.30;	author shebs;	state Exp;
branches;
next	1.170;

1.170
date	2010.05.28.18.23.15;	author jkratoch;	state Exp;
branches;
next	1.169;

1.169
date	2010.05.28.18.00.46;	author jkratoch;	state Exp;
branches;
next	1.168;

1.168
date	2010.05.14.23.41.05;	author msnyder;	state Exp;
branches;
next	1.167;

1.167
date	2010.05.05.20.16.45;	author msnyder;	state Exp;
branches;
next	1.166;

1.166
date	2010.04.05.22.18.53;	author muller;	state Exp;
branches;
next	1.165;

1.165
date	2010.03.17.16.17.00;	author tromey;	state Exp;
branches;
next	1.164;

1.164
date	2010.02.24.17.01.57;	author palves;	state Exp;
branches;
next	1.163;

1.163
date	2010.02.08.15.44.09;	author palves;	state Exp;
branches
	1.163.2.1;
next	1.162;

1.162
date	2010.01.19.09.39.11;	author brobecke;	state Exp;
branches;
next	1.161;

1.161
date	2010.01.14.21.14.59;	author jkratoch;	state Exp;
branches;
next	1.160;

1.160
date	2010.01.12.21.40.24;	author vprus;	state Exp;
branches;
next	1.159;

1.159
date	2010.01.08.22.52.03;	author jkratoch;	state Exp;
branches;
next	1.158;

1.158
date	2010.01.01.07.31.36;	author brobecke;	state Exp;
branches;
next	1.157;

1.157
date	2009.12.21.21.23.42;	author devans;	state Exp;
branches;
next	1.156;

1.156
date	2009.11.20.19.48.45;	author palves;	state Exp;
branches;
next	1.155;

1.155
date	2009.11.15.20.08.03;	author palves;	state Exp;
branches;
next	1.154;

1.154
date	2009.10.20.11.09.01;	author palves;	state Exp;
branches;
next	1.153;

1.153
date	2009.10.19.09.51.41;	author palves;	state Exp;
branches;
next	1.152;

1.152
date	2009.10.15.18.06.15;	author ppluzhnikov;	state Exp;
branches;
next	1.151;

1.151
date	2009.10.09.01.57.12;	author palves;	state Exp;
branches;
next	1.150;

1.150
date	2009.10.02.16.51.04;	author palves;	state Exp;
branches;
next	1.149;

1.149
date	2009.09.28.21.09.15;	author devans;	state Exp;
branches;
next	1.148;

1.148
date	2009.09.28.18.39.29;	author devans;	state Exp;
branches;
next	1.147;

1.147
date	2009.09.15.03.30.06;	author sergiodj;	state Exp;
branches;
next	1.146;

1.146
date	2009.07.31.15.25.21;	author uweigand;	state Exp;
branches;
next	1.145;

1.145
date	2009.07.13.20.16.47;	author jkratoch;	state Exp;
branches
	1.145.2.1;
next	1.144;

1.144
date	2009.07.02.21.57.27;	author palves;	state Exp;
branches;
next	1.143;

1.143
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.142;

1.142
date	2009.07.02.17.06.43;	author uweigand;	state Exp;
branches;
next	1.141;

1.141
date	2009.06.17.18.44.23;	author uweigand;	state Exp;
branches;
next	1.140;

1.140
date	2009.06.07.16.46.48;	author palves;	state Exp;
branches;
next	1.139;

1.139
date	2009.05.27.19.44.50;	author palves;	state Exp;
branches;
next	1.138;

1.138
date	2009.05.24.21.06.53;	author devans;	state Exp;
branches;
next	1.137;

1.137
date	2009.05.24.18.00.08;	author palves;	state Exp;
branches;
next	1.136;

1.136
date	2009.05.21.16.00.13;	author palves;	state Exp;
branches;
next	1.135;

1.135
date	2009.05.21.15.48.41;	author palves;	state Exp;
branches;
next	1.134;

1.134
date	2009.05.19.02.46.45;	author palves;	state Exp;
branches;
next	1.133;

1.133
date	2009.05.18.17.11.25;	author palves;	state Exp;
branches;
next	1.132;

1.132
date	2009.05.18.14.07.17;	author palves;	state Exp;
branches;
next	1.131;

1.131
date	2009.05.17.19.20.32;	author palves;	state Exp;
branches;
next	1.130;

1.130
date	2009.05.11.12.08.03;	author palves;	state Exp;
branches;
next	1.129;

1.129
date	2009.05.08.22.34.47;	author devans;	state Exp;
branches;
next	1.128;

1.128
date	2009.04.01.19.07.50;	author brobecke;	state Exp;
branches;
next	1.127;

1.127
date	2009.04.01.18.56.29;	author brobecke;	state Exp;
branches;
next	1.126;

1.126
date	2009.03.25.10.02.13;	author muller;	state Exp;
branches;
next	1.125;

1.125
date	2009.03.18.16.47.45;	author devans;	state Exp;
branches;
next	1.124;

1.124
date	2009.03.17.19.28.09;	author brobecke;	state Exp;
branches;
next	1.123;

1.123
date	2009.02.23.00.03.49;	author palves;	state Exp;
branches;
next	1.122;

1.122
date	2009.02.21.16.14.48;	author palves;	state Exp;
branches;
next	1.121;

1.121
date	2009.02.07.14.50.25;	author palves;	state Exp;
branches;
next	1.120;

1.120
date	2009.02.06.23.06.58;	author palves;	state Exp;
branches;
next	1.119;

1.119
date	2009.02.06.22.59.00;	author palves;	state Exp;
branches;
next	1.118;

1.118
date	2009.02.06.22.21.26;	author palves;	state Exp;
branches;
next	1.117;

1.117
date	2009.01.26.22.34.55;	author palves;	state Exp;
branches;
next	1.116;

1.116
date	2009.01.06.18.31.59;	author jimb;	state Exp;
branches;
next	1.115;

1.115
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.114;

1.114
date	2008.12.28.16.14.57;	author palves;	state Exp;
branches;
next	1.113;

1.113
date	2008.12.18.21.35.22;	author palves;	state Exp;
branches;
next	1.112;

1.112
date	2008.12.16.11.15.57;	author gingold;	state Exp;
branches;
next	1.111;

1.111
date	2008.12.02.07.57.36;	author vprus;	state Exp;
branches;
next	1.110;

1.110
date	2008.11.09.11.27.17;	author vprus;	state Exp;
branches
	1.110.2.1;
next	1.109;

1.109
date	2008.10.28.15.22.12;	author tromey;	state Exp;
branches;
next	1.108;

1.108
date	2008.10.23.23.11.21;	author palves;	state Exp;
branches;
next	1.107;

1.107
date	2008.10.03.16.36.10;	author ppluzhnikov;	state Exp;
branches;
next	1.106;

1.106
date	2008.09.25.14.13.44;	author bauermann;	state Exp;
branches
	1.106.2.1;
next	1.105;

1.105
date	2008.09.22.15.20.08;	author palves;	state Exp;
branches;
next	1.104;

1.104
date	2008.09.22.15.16.51;	author palves;	state Exp;
branches;
next	1.103;

1.103
date	2008.09.22.11.00.41;	author palves;	state Exp;
branches;
next	1.102;

1.102
date	2008.09.08.21.51.18;	author palves;	state Exp;
branches;
next	1.101;

1.101
date	2008.09.08.21.40.39;	author palves;	state Exp;
branches;
next	1.100;

1.100
date	2008.09.08.21.25.05;	author palves;	state Exp;
branches;
next	1.99;

1.99
date	2008.09.08.21.22.49;	author palves;	state Exp;
branches;
next	1.98;

1.98
date	2008.08.19.13.22.14;	author vprus;	state Exp;
branches;
next	1.97;

1.97
date	2008.08.19.13.05.01;	author vprus;	state Exp;
branches;
next	1.96;

1.96
date	2008.07.27.21.12.40;	author drow;	state Exp;
branches;
next	1.95;

1.95
date	2008.07.27.21.05.37;	author drow;	state Exp;
branches;
next	1.94;

1.94
date	2008.07.11.11.07.38;	author palves;	state Exp;
branches
	1.94.2.1;
next	1.93;

1.93
date	2008.07.10.22.58.37;	author palves;	state Exp;
branches;
next	1.92;

1.92
date	2008.07.10.09.30.59;	author jkratoch;	state Exp;
branches;
next	1.91;

1.91
date	2008.07.09.22.23.05;	author palves;	state Exp;
branches;
next	1.90;

1.90
date	2008.07.09.22.16.14;	author palves;	state Exp;
branches;
next	1.89;

1.89
date	2008.07.08.10.59.57;	author palves;	state Exp;
branches;
next	1.88;

1.88
date	2008.06.28.11.15.33;	author palves;	state Exp;
branches;
next	1.87;

1.87
date	2008.06.26.17.40.23;	author vprus;	state Exp;
branches;
next	1.86;

1.86
date	2008.05.24.16.32.01;	author cseo;	state Exp;
branches;
next	1.85;

1.85
date	2008.05.15.20.11.48;	author palves;	state Exp;
branches;
next	1.84;

1.84
date	2008.05.04.14.12.34;	author uweigand;	state Exp;
branches;
next	1.83;

1.83
date	2008.05.03.15.10.41;	author vprus;	state Exp;
branches;
next	1.82;

1.82
date	2008.05.01.22.48.49;	author palves;	state Exp;
branches;
next	1.81;

1.81
date	2008.05.01.18.50.14;	author drow;	state Exp;
branches;
next	1.80;

1.80
date	2008.03.25.12.26.21;	author palves;	state Exp;
branches;
next	1.79;

1.79
date	2008.03.25.12.20.10;	author palves;	state Exp;
branches;
next	1.78;

1.78
date	2008.03.21.17.09.35;	author palves;	state Exp;
branches;
next	1.77;

1.77
date	2008.03.21.15.44.53;	author drow;	state Exp;
branches;
next	1.76;

1.76
date	2008.03.17.14.54.07;	author palves;	state Exp;
branches;
next	1.75;

1.75
date	2008.03.17.14.49.06;	author palves;	state Exp;
branches;
next	1.74;

1.74
date	2008.01.29.22.47.20;	author drow;	state Exp;
branches;
next	1.73;

1.73
date	2008.01.23.11.26.28;	author vprus;	state Exp;
branches;
next	1.72;

1.72
date	2008.01.02.13.36.37;	author jkratoch;	state Exp;
branches;
next	1.71;

1.71
date	2008.01.01.22.53.11;	author drow;	state Exp;
branches;
next	1.70;

1.70
date	2007.10.11.19.35.29;	author uweigand;	state Exp;
branches;
next	1.69;

1.69
date	2007.10.02.16.33.35;	author uweigand;	state Exp;
branches;
next	1.68;

1.68
date	2007.10.01.00.22.50;	author drow;	state Exp;
branches;
next	1.67;

1.67
date	2007.09.02.14.04.31;	author jkratoch;	state Exp;
branches;
next	1.66;

1.66
date	2007.08.23.18.08.35;	author brobecke;	state Exp;
branches;
next	1.65;

1.65
date	2007.07.03.17.01.55;	author schwab;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.16.17.16.25;	author uweigand;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.13.17.59.50;	author uweigand;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.09.13.55.51;	author uweigand;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.10.21.36.00;	author uweigand;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.07.00.18.39;	author uweigand;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.06.14.34.38;	author uweigand;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.06.14.32.30;	author uweigand;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.25.22.17.47;	author uweigand;	state Exp;
branches;
next	1.56;

1.56
date	2007.02.09.20.52.16;	author gdr;	state Exp;
branches;
next	1.55;

1.55
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.54;

1.54
date	2007.01.08.21.09.46;	author drow;	state Exp;
branches;
next	1.53;

1.53
date	2007.01.03.19.01.25;	author drow;	state Exp;
branches;
next	1.52;

1.52
date	2006.12.31.21.04.51;	author drow;	state Exp;
branches;
next	1.51;

1.51
date	2006.11.20.21.47.06;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2006.09.16.09.48.12;	author nickrob;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2006.07.23.21.21.01;	author drow;	state Exp;
branches;
next	1.48;

1.48
date	2006.07.12.18.13.45;	author drow;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.06.23.55.36;	author davem;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2006.05.05.23.48.28;	author uweigand;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.05.23.46.58;	author uweigand;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.05.22.39.12;	author davem;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.07.23.34.26;	author davem;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.07.21.42.33;	author davem;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.30.16.34.23;	author drow;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.24.23.08.16;	author drow;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.10.20.15.42;	author msnyder;	state Exp;
branches;
next	1.38;

1.38
date	2006.02.20.17.01.28;	author drow;	state Exp;
branches
	1.38.2.1
	1.38.4.1;
next	1.37;

1.37
date	2006.02.02.02.29.29;	author drow;	state Exp;
branches;
next	1.36;

1.36
date	2006.01.04.19.34.58;	author msnyder;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.03.19.31.38;	author drow;	state Exp;
branches
	1.34.4.1;
next	1.33;

1.33
date	2005.09.10.18.11.02;	author drow;	state Exp;
branches
	1.33.4.1;
next	1.32;

1.32
date	2005.09.04.16.18.20;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.09.16.35.45;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.28.16.44.29;	author drow;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.23.21.19.48;	author msnyder;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.15.17.00.37;	author drow;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.06.16.42.20;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.02.15.07.49;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.24.13.51.34;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.18.18.58.56;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.15.15.49.12;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.12.00.39.20;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.11.18.13.50;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.11.04.05.56;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.18.17.04.28;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.04.17.21.26;	author drow;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.21.20.10.02;	author drow;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.08.16.05.12;	author schwab;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.08.20.29.47;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.05.22.40.30;	author jimb;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.05.21.53.33;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.29.15.55.55;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.29.14.20.25;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.29.13.54.32;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.28.17.29.05;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.27.19.55.17;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.15.15.51.40;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.29.18.07.14;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.17.20.17.02;	author drow;	state Exp;
branches
	1.5.8.1
	1.5.14.1;
next	1.4;

1.4
date	2003.08.17.18.22.25;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.19.22.52.03;	author msnyder;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2003.06.18.23.33.30;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.15.20.56.47;	author drow;	state Exp;
branches;
next	;

1.229.2.1
date	2012.01.06.04.43.19;	author brobecke;	state Exp;
branches;
next	;

1.199.2.1
date	2011.04.29.16.02.10;	author palves;	state Exp;
branches;
next	;

1.163.2.1
date	2010.03.17.17.27.14;	author tromey;	state Exp;
branches;
next	;

1.145.2.1
date	2009.07.26.01.44.32;	author msnyder;	state Exp;
branches;
next	;

1.110.2.1
date	2008.11.21.02.31.57;	author shebs;	state Exp;
branches;
next	1.110.2.2;

1.110.2.2
date	2008.12.18.22.16.15;	author palves;	state Exp;
branches;
next	;

1.106.2.1
date	2008.10.03.17.50.15;	author msnyder;	state Exp;
branches;
next	1.106.2.2;

1.106.2.2
date	2008.10.18.13.45.18;	author teawater;	state Exp;
branches;
next	1.106.2.3;

1.106.2.3
date	2008.11.06.02.18.11;	author teawater;	state Exp;
branches;
next	;

1.94.2.1
date	2008.07.20.14.30.11;	author teawater;	state Exp;
branches;
next	1.94.2.2;

1.94.2.2
date	2008.07.24.08.58.37;	author teawater;	state Exp;
branches;
next	1.94.2.3;

1.94.2.3
date	2008.09.02.09.18.28;	author teawater;	state Exp;
branches;
next	1.94.2.4;

1.94.2.4
date	2008.10.03.23.03.47;	author msnyder;	state Exp;
branches;
next	;

1.50.2.1
date	2006.11.20.21.58.51;	author cagney;	state Exp;
branches;
next	;

1.47.2.1
date	2006.08.21.10.21.21;	author nickrob;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2006.08.28.06.12.56;	author nickrob;	state Exp;
branches;
next	1.47.2.3;

1.47.2.3
date	2006.08.28.07.48.48;	author nickrob;	state Exp;
branches;
next	1.47.2.4;

1.47.2.4
date	2006.09.02.09.43.17;	author nickrob;	state Exp;
branches;
next	1.47.2.5;

1.47.2.5
date	2006.09.03.22.36.09;	author nickrob;	state Exp;
branches;
next	1.47.2.6;

1.47.2.6
date	2006.09.14.02.26.04;	author nickrob;	state Exp;
branches;
next	1.47.2.7;

1.47.2.7
date	2006.09.15.22.51.33;	author nickrob;	state Exp;
branches;
next	1.47.2.8;

1.47.2.8
date	2006.09.17.12.28.19;	author nickrob;	state Exp;
branches;
next	;

1.38.2.1
date	2006.04.03.00.47.40;	author drow;	state Exp;
branches;
next	;

1.38.4.1
date	2006.03.03.20.46.37;	author drow;	state Exp;
branches;
next	;

1.34.4.1
date	2005.11.22.00.42.28;	author msnyder;	state Exp;
branches;
next	1.34.4.2;

1.34.4.2
date	2005.11.24.02.22.38;	author msnyder;	state Exp;
branches;
next	1.34.4.3;

1.34.4.3
date	2005.11.25.22.18.52;	author msnyder;	state Exp;
branches;
next	1.34.4.4;

1.34.4.4
date	2005.11.26.04.27.17;	author msnyder;	state Exp;
branches;
next	1.34.4.5;

1.34.4.5
date	2005.11.26.04.42.03;	author msnyder;	state Exp;
branches;
next	1.34.4.6;

1.34.4.6
date	2005.11.26.22.52.10;	author msnyder;	state Exp;
branches;
next	1.34.4.7;

1.34.4.7
date	2005.11.27.00.02.46;	author msnyder;	state Exp;
branches;
next	1.34.4.8;

1.34.4.8
date	2005.11.28.22.28.33;	author msnyder;	state Exp;
branches;
next	1.34.4.9;

1.34.4.9
date	2005.12.02.03.19.17;	author msnyder;	state Exp;
branches;
next	;

1.33.4.1
date	2005.11.03.19.51.40;	author drow;	state Exp;
branches;
next	;

1.5.8.1
date	2003.12.14.20.27.20;	author drow;	state Exp;
branches;
next	;

1.5.14.1
date	2004.04.02.16.47.47;	author drow;	state Exp;
branches;
next	1.5.14.2;

1.5.14.2
date	2004.09.16.17.01.12;	author drow;	state Exp;
branches;
next	;

1.3.2.1
date	2003.08.17.18.22.33;	author drow;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.08.22.21.14.39;	author drow;	state Exp;
branches;
next	;

1.3.4.1
date	2003.06.27.21.50.05;	author carlton;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2003.09.17.21.28.23;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.272
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@/* GNU/Linux native-dependent code common to multiple platforms.

   Copyright (C) 2001-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "inferior.h"
#include "target.h"
#include "nat/linux-nat.h"
#include "nat/linux-waitpid.h"
#include "gdb_string.h"
#include "gdb_wait.h"
#include "gdb_assert.h"
#ifdef HAVE_TKILL_SYSCALL
#include <unistd.h>
#include <sys/syscall.h>
#endif
#include <sys/ptrace.h>
#include "linux-nat.h"
#include "linux-ptrace.h"
#include "linux-procfs.h"
#include "linux-fork.h"
#include "gdbthread.h"
#include "gdbcmd.h"
#include "regcache.h"
#include "regset.h"
#include "inf-child.h"
#include "inf-ptrace.h"
#include "auxv.h"
#include <sys/procfs.h>		/* for elf_gregset etc.  */
#include "elf-bfd.h"		/* for elfcore_write_* */
#include "gregset.h"		/* for gregset */
#include "gdbcore.h"		/* for get_exec_file */
#include <ctype.h>		/* for isdigit */
#include "gdbthread.h"		/* for struct thread_info etc.  */
#include "gdb_stat.h"		/* for struct stat */
#include <fcntl.h>		/* for O_RDONLY */
#include "inf-loop.h"
#include "event-loop.h"
#include "event-top.h"
#include <pwd.h>
#include <sys/types.h>
#include "gdb_dirent.h"
#include "xml-support.h"
#include "terminal.h"
#include <sys/vfs.h>
#include "solib.h"
#include "linux-osdata.h"
#include "linux-tdep.h"
#include "symfile.h"
#include "agent.h"
#include "tracepoint.h"
#include "exceptions.h"
#include "linux-ptrace.h"
#include "buffer.h"
#include "target-descriptions.h"
#include "filestuff.h"

#ifndef SPUFS_MAGIC
#define SPUFS_MAGIC 0x23c9b64e
#endif

#ifdef HAVE_PERSONALITY
# include <sys/personality.h>
# if !HAVE_DECL_ADDR_NO_RANDOMIZE
#  define ADDR_NO_RANDOMIZE 0x0040000
# endif
#endif /* HAVE_PERSONALITY */

/* This comment documents high-level logic of this file.

Waiting for events in sync mode
===============================

When waiting for an event in a specific thread, we just use waitpid, passing
the specific pid, and not passing WNOHANG.

When waiting for an event in all threads, waitpid is not quite good.  Prior to
version 2.4, Linux can either wait for event in main thread, or in secondary
threads.  (2.4 has the __WALL flag).  So, if we use blocking waitpid, we might
miss an event.  The solution is to use non-blocking waitpid, together with
sigsuspend.  First, we use non-blocking waitpid to get an event in the main 
process, if any.  Second, we use non-blocking waitpid with the __WCLONED
flag to check for events in cloned processes.  If nothing is found, we use
sigsuspend to wait for SIGCHLD.  When SIGCHLD arrives, it means something
happened to a child process -- and SIGCHLD will be delivered both for events
in main debugged process and in cloned processes.  As soon as we know there's
an event, we get back to calling nonblocking waitpid with and without 
__WCLONED.

Note that SIGCHLD should be blocked between waitpid and sigsuspend calls,
so that we don't miss a signal.  If SIGCHLD arrives in between, when it's
blocked, the signal becomes pending and sigsuspend immediately
notices it and returns.

Waiting for events in async mode
================================

In async mode, GDB should always be ready to handle both user input
and target events, so neither blocking waitpid nor sigsuspend are
viable options.  Instead, we should asynchronously notify the GDB main
event loop whenever there's an unprocessed event from the target.  We
detect asynchronous target events by handling SIGCHLD signals.  To
notify the event loop about target events, the self-pipe trick is used
--- a pipe is registered as waitable event source in the event loop,
the event loop select/poll's on the read end of this pipe (as well on
other event sources, e.g., stdin), and the SIGCHLD handler writes a
byte to this pipe.  This is more portable than relying on
pselect/ppoll, since on kernels that lack those syscalls, libc
emulates them with select/poll+sigprocmask, and that is racy
(a.k.a. plain broken).

Obviously, if we fail to notify the event loop if there's a target
event, it's bad.  OTOH, if we notify the event loop when there's no
event from the target, linux_nat_wait will detect that there's no real
event to report, and return event of type TARGET_WAITKIND_IGNORE.
This is mostly harmless, but it will waste time and is better avoided.

The main design point is that every time GDB is outside linux-nat.c,
we have a SIGCHLD handler installed that is called when something
happens to the target and notifies the GDB event loop.  Whenever GDB
core decides to handle the event, and calls into linux-nat.c, we
process things as in sync mode, except that the we never block in
sigsuspend.

While processing an event, we may end up momentarily blocked in
waitpid calls.  Those waitpid calls, while blocking, are guarantied to
return quickly.  E.g., in all-stop mode, before reporting to the core
that an LWP hit a breakpoint, all LWPs are stopped by sending them
SIGSTOP, and synchronously waiting for the SIGSTOP to be reported.
Note that this is different from blocking indefinitely waiting for the
next event --- here, we're already handling an event.

Use of signals
==============

We stop threads by sending a SIGSTOP.  The use of SIGSTOP instead of another
signal is not entirely significant; we just need for a signal to be delivered,
so that we can intercept it.  SIGSTOP's advantage is that it can not be
blocked.  A disadvantage is that it is not a real-time signal, so it can only
be queued once; we do not keep track of other sources of SIGSTOP.

Two other signals that can't be blocked are SIGCONT and SIGKILL.  But we can't
use them, because they have special behavior when the signal is generated -
not when it is delivered.  SIGCONT resumes the entire thread group and SIGKILL
kills the entire thread group.

A delivered SIGSTOP would stop the entire thread group, not just the thread we
tkill'd.  But we never let the SIGSTOP be delivered; we always intercept and 
cancel it (by PTRACE_CONT without passing SIGSTOP).

We could use a real-time signal instead.  This would solve those problems; we
could use PTRACE_GETSIGINFO to locate the specific stop signals sent by GDB.
But we would still have to have some support for SIGSTOP, since PTRACE_ATTACH
generates it, and there are races with trying to find a signal that is not
blocked.  */

#ifndef O_LARGEFILE
#define O_LARGEFILE 0
#endif

/* The single-threaded native GNU/Linux target_ops.  We save a pointer for
   the use of the multi-threaded target.  */
static struct target_ops *linux_ops;
static struct target_ops linux_ops_saved;

/* The method to call, if any, when a new thread is attached.  */
static void (*linux_nat_new_thread) (struct lwp_info *);

/* The method to call, if any, when a new fork is attached.  */
static linux_nat_new_fork_ftype *linux_nat_new_fork;

/* The method to call, if any, when a process is no longer
   attached.  */
static linux_nat_forget_process_ftype *linux_nat_forget_process_hook;

/* Hook to call prior to resuming a thread.  */
static void (*linux_nat_prepare_to_resume) (struct lwp_info *);

/* The method to call, if any, when the siginfo object needs to be
   converted between the layout returned by ptrace, and the layout in
   the architecture of the inferior.  */
static int (*linux_nat_siginfo_fixup) (siginfo_t *,
				       gdb_byte *,
				       int);

/* The saved to_xfer_partial method, inherited from inf-ptrace.c.
   Called by our to_xfer_partial.  */
static LONGEST (*super_xfer_partial) (struct target_ops *, 
				      enum target_object,
				      const char *, gdb_byte *, 
				      const gdb_byte *,
				      ULONGEST, LONGEST);

static unsigned int debug_linux_nat;
static void
show_debug_linux_nat (struct ui_file *file, int from_tty,
		      struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Debugging of GNU/Linux lwp module is %s.\n"),
		    value);
}

struct simple_pid_list
{
  int pid;
  int status;
  struct simple_pid_list *next;
};
struct simple_pid_list *stopped_pids;

/* Async mode support.  */

/* The read/write ends of the pipe registered as waitable file in the
   event loop.  */
static int linux_nat_event_pipe[2] = { -1, -1 };

/* Flush the event pipe.  */

static void
async_file_flush (void)
{
  int ret;
  char buf;

  do
    {
      ret = read (linux_nat_event_pipe[0], &buf, 1);
    }
  while (ret >= 0 || (ret == -1 && errno == EINTR));
}

/* Put something (anything, doesn't matter what, or how much) in event
   pipe, so that the select/poll in the event-loop realizes we have
   something to process.  */

static void
async_file_mark (void)
{
  int ret;

  /* It doesn't really matter what the pipe contains, as long we end
     up with something in it.  Might as well flush the previous
     left-overs.  */
  async_file_flush ();

  do
    {
      ret = write (linux_nat_event_pipe[1], "+", 1);
    }
  while (ret == -1 && errno == EINTR);

  /* Ignore EAGAIN.  If the pipe is full, the event loop will already
     be awakened anyway.  */
}

static void linux_nat_async (void (*callback)
			     (enum inferior_event_type event_type,
			      void *context),
			     void *context);
static int kill_lwp (int lwpid, int signo);

static int stop_callback (struct lwp_info *lp, void *data);

static void block_child_signals (sigset_t *prev_mask);
static void restore_child_signals_mask (sigset_t *prev_mask);

struct lwp_info;
static struct lwp_info *add_lwp (ptid_t ptid);
static void purge_lwp_list (int pid);
static void delete_lwp (ptid_t ptid);
static struct lwp_info *find_lwp_pid (ptid_t ptid);


/* Trivial list manipulation functions to keep track of a list of
   new stopped processes.  */
static void
add_to_pid_list (struct simple_pid_list **listp, int pid, int status)
{
  struct simple_pid_list *new_pid = xmalloc (sizeof (struct simple_pid_list));

  new_pid->pid = pid;
  new_pid->status = status;
  new_pid->next = *listp;
  *listp = new_pid;
}

static int
in_pid_list_p (struct simple_pid_list *list, int pid)
{
  struct simple_pid_list *p;

  for (p = list; p != NULL; p = p->next)
    if (p->pid == pid)
      return 1;
  return 0;
}

static int
pull_pid_from_list (struct simple_pid_list **listp, int pid, int *statusp)
{
  struct simple_pid_list **p;

  for (p = listp; *p != NULL; p = &(*p)->next)
    if ((*p)->pid == pid)
      {
	struct simple_pid_list *next = (*p)->next;

	*statusp = (*p)->status;
	xfree (*p);
	*p = next;
	return 1;
      }
  return 0;
}

/* Initialize ptrace warnings and check for supported ptrace
   features given PID.  */

static void
linux_init_ptrace (pid_t pid)
{
  linux_enable_event_reporting (pid);
  linux_ptrace_init_warnings ();
}

static void
linux_child_post_attach (int pid)
{
  linux_init_ptrace (pid);
}

static void
linux_child_post_startup_inferior (ptid_t ptid)
{
  linux_init_ptrace (ptid_get_pid (ptid));
}

/* Return the number of known LWPs in the tgid given by PID.  */

static int
num_lwps (int pid)
{
  int count = 0;
  struct lwp_info *lp;

  for (lp = lwp_list; lp; lp = lp->next)
    if (ptid_get_pid (lp->ptid) == pid)
      count++;

  return count;
}

/* Call delete_lwp with prototype compatible for make_cleanup.  */

static void
delete_lwp_cleanup (void *lp_voidp)
{
  struct lwp_info *lp = lp_voidp;

  delete_lwp (lp->ptid);
}

static int
linux_child_follow_fork (struct target_ops *ops, int follow_child,
			 int detach_fork)
{
  int has_vforked;
  int parent_pid, child_pid;

  has_vforked = (inferior_thread ()->pending_follow.kind
		 == TARGET_WAITKIND_VFORKED);
  parent_pid = ptid_get_lwp (inferior_ptid);
  if (parent_pid == 0)
    parent_pid = ptid_get_pid (inferior_ptid);
  child_pid
    = ptid_get_pid (inferior_thread ()->pending_follow.value.related_pid);

  if (has_vforked
      && !non_stop /* Non-stop always resumes both branches.  */
      && (!target_is_async_p () || sync_execution)
      && !(follow_child || detach_fork || sched_multi))
    {
      /* The parent stays blocked inside the vfork syscall until the
	 child execs or exits.  If we don't let the child run, then
	 the parent stays blocked.  If we're telling the parent to run
	 in the foreground, the user will not be able to ctrl-c to get
	 back the terminal, effectively hanging the debug session.  */
      fprintf_filtered (gdb_stderr, _("\
Can not resume the parent process over vfork in the foreground while\n\
holding the child stopped.  Try \"set detach-on-fork\" or \
\"set schedule-multiple\".\n"));
      /* FIXME output string > 80 columns.  */
      return 1;
    }

  if (! follow_child)
    {
      struct lwp_info *child_lp = NULL;

      /* We're already attached to the parent, by default.  */

      /* Detach new forked process?  */
      if (detach_fork)
	{
	  struct cleanup *old_chain;

	  /* Before detaching from the child, remove all breakpoints
	     from it.  If we forked, then this has already been taken
	     care of by infrun.c.  If we vforked however, any
	     breakpoint inserted in the parent is visible in the
	     child, even those added while stopped in a vfork
	     catchpoint.  This will remove the breakpoints from the
	     parent also, but they'll be reinserted below.  */
	  if (has_vforked)
	    {
	      /* keep breakpoints list in sync.  */
	      remove_breakpoints_pid (ptid_get_pid (inferior_ptid));
	    }

	  if (info_verbose || debug_linux_nat)
	    {
	      target_terminal_ours ();
	      fprintf_filtered (gdb_stdlog,
				"Detaching after fork from "
				"child process %d.\n",
				child_pid);
	    }

	  old_chain = save_inferior_ptid ();
	  inferior_ptid = ptid_build (child_pid, child_pid, 0);

	  child_lp = add_lwp (inferior_ptid);
	  child_lp->stopped = 1;
	  child_lp->last_resume_kind = resume_stop;
	  make_cleanup (delete_lwp_cleanup, child_lp);

	  if (linux_nat_prepare_to_resume != NULL)
	    linux_nat_prepare_to_resume (child_lp);
	  ptrace (PTRACE_DETACH, child_pid, 0, 0);

	  do_cleanups (old_chain);
	}
      else
	{
	  struct inferior *parent_inf, *child_inf;
	  struct cleanup *old_chain;

	  /* Add process to GDB's tables.  */
	  child_inf = add_inferior (child_pid);

	  parent_inf = current_inferior ();
	  child_inf->attach_flag = parent_inf->attach_flag;
	  copy_terminal_info (child_inf, parent_inf);
	  child_inf->gdbarch = parent_inf->gdbarch;
	  copy_inferior_target_desc_info (child_inf, parent_inf);

	  old_chain = save_inferior_ptid ();
	  save_current_program_space ();

	  inferior_ptid = ptid_build (child_pid, child_pid, 0);
	  add_thread (inferior_ptid);
	  child_lp = add_lwp (inferior_ptid);
	  child_lp->stopped = 1;
	  child_lp->last_resume_kind = resume_stop;
	  child_inf->symfile_flags = SYMFILE_NO_READ;

	  /* If this is a vfork child, then the address-space is
	     shared with the parent.  */
	  if (has_vforked)
	    {
	      child_inf->pspace = parent_inf->pspace;
	      child_inf->aspace = parent_inf->aspace;

	      /* The parent will be frozen until the child is done
		 with the shared region.  Keep track of the
		 parent.  */
	      child_inf->vfork_parent = parent_inf;
	      child_inf->pending_detach = 0;
	      parent_inf->vfork_child = child_inf;
	      parent_inf->pending_detach = 0;
	    }
	  else
	    {
	      child_inf->aspace = new_address_space ();
	      child_inf->pspace = add_program_space (child_inf->aspace);
	      child_inf->removable = 1;
	      set_current_program_space (child_inf->pspace);
	      clone_program_space (child_inf->pspace, parent_inf->pspace);

	      /* Let the shared library layer (solib-svr4) learn about
		 this new process, relocate the cloned exec, pull in
		 shared libraries, and install the solib event
		 breakpoint.  If a "cloned-VM" event was propagated
		 better throughout the core, this wouldn't be
		 required.  */
	      solib_create_inferior_hook (0);
	    }

	  /* Let the thread_db layer learn about this new process.  */
	  check_for_thread_db ();

	  do_cleanups (old_chain);
	}

      if (has_vforked)
	{
	  struct lwp_info *parent_lp;
	  struct inferior *parent_inf;

	  parent_inf = current_inferior ();

	  /* If we detached from the child, then we have to be careful
	     to not insert breakpoints in the parent until the child
	     is done with the shared memory region.  However, if we're
	     staying attached to the child, then we can and should
	     insert breakpoints, so that we can debug it.  A
	     subsequent child exec or exit is enough to know when does
	     the child stops using the parent's address space.  */
	  parent_inf->waiting_for_vfork_done = detach_fork;
	  parent_inf->pspace->breakpoints_not_allowed = detach_fork;

	  parent_lp = find_lwp_pid (pid_to_ptid (parent_pid));
	  gdb_assert (linux_supports_tracefork () >= 0);

	  if (linux_supports_tracevforkdone ())
	    {
  	      if (debug_linux_nat)
  		fprintf_unfiltered (gdb_stdlog,
  				    "LCFF: waiting for VFORK_DONE on %d\n",
  				    parent_pid);
	      parent_lp->stopped = 1;

	      /* We'll handle the VFORK_DONE event like any other
		 event, in target_wait.  */
	    }
	  else
	    {
	      /* We can't insert breakpoints until the child has
		 finished with the shared memory region.  We need to
		 wait until that happens.  Ideal would be to just
		 call:
		 - ptrace (PTRACE_SYSCALL, parent_pid, 0, 0);
		 - waitpid (parent_pid, &status, __WALL);
		 However, most architectures can't handle a syscall
		 being traced on the way out if it wasn't traced on
		 the way in.

		 We might also think to loop, continuing the child
		 until it exits or gets a SIGTRAP.  One problem is
		 that the child might call ptrace with PTRACE_TRACEME.

		 There's no simple and reliable way to figure out when
		 the vforked child will be done with its copy of the
		 shared memory.  We could step it out of the syscall,
		 two instructions, let it go, and then single-step the
		 parent once.  When we have hardware single-step, this
		 would work; with software single-step it could still
		 be made to work but we'd have to be able to insert
		 single-step breakpoints in the child, and we'd have
		 to insert -just- the single-step breakpoint in the
		 parent.  Very awkward.

		 In the end, the best we can do is to make sure it
		 runs for a little while.  Hopefully it will be out of
		 range of any breakpoints we reinsert.  Usually this
		 is only the single-step breakpoint at vfork's return
		 point.  */

  	      if (debug_linux_nat)
  		fprintf_unfiltered (gdb_stdlog,
				    "LCFF: no VFORK_DONE "
				    "support, sleeping a bit\n");

	      usleep (10000);

	      /* Pretend we've seen a PTRACE_EVENT_VFORK_DONE event,
		 and leave it pending.  The next linux_nat_resume call
		 will notice a pending event, and bypasses actually
		 resuming the inferior.  */
	      parent_lp->status = 0;
	      parent_lp->waitstatus.kind = TARGET_WAITKIND_VFORK_DONE;
	      parent_lp->stopped = 1;

	      /* If we're in async mode, need to tell the event loop
		 there's something here to process.  */
	      if (target_can_async_p ())
		async_file_mark ();
	    }
	}
    }
  else
    {
      struct inferior *parent_inf, *child_inf;
      struct lwp_info *child_lp;
      struct program_space *parent_pspace;

      if (info_verbose || debug_linux_nat)
	{
	  target_terminal_ours ();
	  if (has_vforked)
	    fprintf_filtered (gdb_stdlog,
			      _("Attaching after process %d "
				"vfork to child process %d.\n"),
			      parent_pid, child_pid);
	  else
	    fprintf_filtered (gdb_stdlog,
			      _("Attaching after process %d "
				"fork to child process %d.\n"),
			      parent_pid, child_pid);
	}

      /* Add the new inferior first, so that the target_detach below
	 doesn't unpush the target.  */

      child_inf = add_inferior (child_pid);

      parent_inf = current_inferior ();
      child_inf->attach_flag = parent_inf->attach_flag;
      copy_terminal_info (child_inf, parent_inf);
      child_inf->gdbarch = parent_inf->gdbarch;
      copy_inferior_target_desc_info (child_inf, parent_inf);

      parent_pspace = parent_inf->pspace;

      /* If we're vforking, we want to hold on to the parent until the
	 child exits or execs.  At child exec or exit time we can
	 remove the old breakpoints from the parent and detach or
	 resume debugging it.  Otherwise, detach the parent now; we'll
	 want to reuse it's program/address spaces, but we can't set
	 them to the child before removing breakpoints from the
	 parent, otherwise, the breakpoints module could decide to
	 remove breakpoints from the wrong process (since they'd be
	 assigned to the same address space).  */

      if (has_vforked)
	{
	  gdb_assert (child_inf->vfork_parent == NULL);
	  gdb_assert (parent_inf->vfork_child == NULL);
	  child_inf->vfork_parent = parent_inf;
	  child_inf->pending_detach = 0;
	  parent_inf->vfork_child = child_inf;
	  parent_inf->pending_detach = detach_fork;
	  parent_inf->waiting_for_vfork_done = 0;
	}
      else if (detach_fork)
	target_detach (NULL, 0);

      /* Note that the detach above makes PARENT_INF dangling.  */

      /* Add the child thread to the appropriate lists, and switch to
	 this new thread, before cloning the program space, and
	 informing the solib layer about this new process.  */

      inferior_ptid = ptid_build (child_pid, child_pid, 0);
      add_thread (inferior_ptid);
      child_lp = add_lwp (inferior_ptid);
      child_lp->stopped = 1;
      child_lp->last_resume_kind = resume_stop;

      /* If this is a vfork child, then the address-space is shared
	 with the parent.  If we detached from the parent, then we can
	 reuse the parent's program/address spaces.  */
      if (has_vforked || detach_fork)
	{
	  child_inf->pspace = parent_pspace;
	  child_inf->aspace = child_inf->pspace->aspace;
	}
      else
	{
	  child_inf->aspace = new_address_space ();
	  child_inf->pspace = add_program_space (child_inf->aspace);
	  child_inf->removable = 1;
	  child_inf->symfile_flags = SYMFILE_NO_READ;
	  set_current_program_space (child_inf->pspace);
	  clone_program_space (child_inf->pspace, parent_pspace);

	  /* Let the shared library layer (solib-svr4) learn about
	     this new process, relocate the cloned exec, pull in
	     shared libraries, and install the solib event breakpoint.
	     If a "cloned-VM" event was propagated better throughout
	     the core, this wouldn't be required.  */
	  solib_create_inferior_hook (0);
	}

      /* Let the thread_db layer learn about this new process.  */
      check_for_thread_db ();
    }

  return 0;
}


static int
linux_child_insert_fork_catchpoint (int pid)
{
  return !linux_supports_tracefork ();
}

static int
linux_child_remove_fork_catchpoint (int pid)
{
  return 0;
}

static int
linux_child_insert_vfork_catchpoint (int pid)
{
  return !linux_supports_tracefork ();
}

static int
linux_child_remove_vfork_catchpoint (int pid)
{
  return 0;
}

static int
linux_child_insert_exec_catchpoint (int pid)
{
  return !linux_supports_tracefork ();
}

static int
linux_child_remove_exec_catchpoint (int pid)
{
  return 0;
}

static int
linux_child_set_syscall_catchpoint (int pid, int needed, int any_count,
				    int table_size, int *table)
{
  if (!linux_supports_tracesysgood ())
    return 1;

  /* On GNU/Linux, we ignore the arguments.  It means that we only
     enable the syscall catchpoints, but do not disable them.

     Also, we do not use the `table' information because we do not
     filter system calls here.  We let GDB do the logic for us.  */
  return 0;
}

/* On GNU/Linux there are no real LWP's.  The closest thing to LWP's
   are processes sharing the same VM space.  A multi-threaded process
   is basically a group of such processes.  However, such a grouping
   is almost entirely a user-space issue; the kernel doesn't enforce
   such a grouping at all (this might change in the future).  In
   general, we'll rely on the threads library (i.e. the GNU/Linux
   Threads library) to provide such a grouping.

   It is perfectly well possible to write a multi-threaded application
   without the assistance of a threads library, by using the clone
   system call directly.  This module should be able to give some
   rudimentary support for debugging such applications if developers
   specify the CLONE_PTRACE flag in the clone system call, and are
   using the Linux kernel 2.4 or above.

   Note that there are some peculiarities in GNU/Linux that affect
   this code:

   - In general one should specify the __WCLONE flag to waitpid in
     order to make it report events for any of the cloned processes
     (and leave it out for the initial process).  However, if a cloned
     process has exited the exit status is only reported if the
     __WCLONE flag is absent.  Linux kernel 2.4 has a __WALL flag, but
     we cannot use it since GDB must work on older systems too.

   - When a traced, cloned process exits and is waited for by the
     debugger, the kernel reassigns it to the original parent and
     keeps it around as a "zombie".  Somehow, the GNU/Linux Threads
     library doesn't notice this, which leads to the "zombie problem":
     When debugged a multi-threaded process that spawns a lot of
     threads will run out of processes, even if the threads exit,
     because the "zombies" stay around.  */

/* List of known LWPs.  */
struct lwp_info *lwp_list;


/* Original signal mask.  */
static sigset_t normal_mask;

/* Signal mask for use with sigsuspend in linux_nat_wait, initialized in
   _initialize_linux_nat.  */
static sigset_t suspend_mask;

/* Signals to block to make that sigsuspend work.  */
static sigset_t blocked_mask;

/* SIGCHLD action.  */
struct sigaction sigchld_action;

/* Block child signals (SIGCHLD and linux threads signals), and store
   the previous mask in PREV_MASK.  */

static void
block_child_signals (sigset_t *prev_mask)
{
  /* Make sure SIGCHLD is blocked.  */
  if (!sigismember (&blocked_mask, SIGCHLD))
    sigaddset (&blocked_mask, SIGCHLD);

  sigprocmask (SIG_BLOCK, &blocked_mask, prev_mask);
}

/* Restore child signals mask, previously returned by
   block_child_signals.  */

static void
restore_child_signals_mask (sigset_t *prev_mask)
{
  sigprocmask (SIG_SETMASK, prev_mask, NULL);
}

/* Mask of signals to pass directly to the inferior.  */
static sigset_t pass_mask;

/* Update signals to pass to the inferior.  */
static void
linux_nat_pass_signals (int numsigs, unsigned char *pass_signals)
{
  int signo;

  sigemptyset (&pass_mask);

  for (signo = 1; signo < NSIG; signo++)
    {
      int target_signo = gdb_signal_from_host (signo);
      if (target_signo < numsigs && pass_signals[target_signo])
        sigaddset (&pass_mask, signo);
    }
}



/* Prototypes for local functions.  */
static int stop_wait_callback (struct lwp_info *lp, void *data);
static int linux_thread_alive (ptid_t ptid);
static char *linux_child_pid_to_exec_file (int pid);


/* Convert wait status STATUS to a string.  Used for printing debug
   messages only.  */

static char *
status_to_str (int status)
{
  static char buf[64];

  if (WIFSTOPPED (status))
    {
      if (WSTOPSIG (status) == SYSCALL_SIGTRAP)
	snprintf (buf, sizeof (buf), "%s (stopped at syscall)",
		  strsignal (SIGTRAP));
      else
	snprintf (buf, sizeof (buf), "%s (stopped)",
		  strsignal (WSTOPSIG (status)));
    }
  else if (WIFSIGNALED (status))
    snprintf (buf, sizeof (buf), "%s (terminated)",
	      strsignal (WTERMSIG (status)));
  else
    snprintf (buf, sizeof (buf), "%d (exited)", WEXITSTATUS (status));

  return buf;
}

/* Destroy and free LP.  */

static void
lwp_free (struct lwp_info *lp)
{
  xfree (lp->arch_private);
  xfree (lp);
}

/* Remove all LWPs belong to PID from the lwp list.  */

static void
purge_lwp_list (int pid)
{
  struct lwp_info *lp, *lpprev, *lpnext;

  lpprev = NULL;

  for (lp = lwp_list; lp; lp = lpnext)
    {
      lpnext = lp->next;

      if (ptid_get_pid (lp->ptid) == pid)
	{
	  if (lp == lwp_list)
	    lwp_list = lp->next;
	  else
	    lpprev->next = lp->next;

	  lwp_free (lp);
	}
      else
	lpprev = lp;
    }
}

/* Add the LWP specified by PTID to the list.  PTID is the first LWP
   in the process.  Return a pointer to the structure describing the
   new LWP.

   This differs from add_lwp in that we don't let the arch specific
   bits know about this new thread.  Current clients of this callback
   take the opportunity to install watchpoints in the new thread, and
   we shouldn't do that for the first thread.  If we're spawning a
   child ("run"), the thread executes the shell wrapper first, and we
   shouldn't touch it until it execs the program we want to debug.
   For "attach", it'd be okay to call the callback, but it's not
   necessary, because watchpoints can't yet have been inserted into
   the inferior.  */

static struct lwp_info *
add_initial_lwp (ptid_t ptid)
{
  struct lwp_info *lp;

  gdb_assert (ptid_lwp_p (ptid));

  lp = (struct lwp_info *) xmalloc (sizeof (struct lwp_info));

  memset (lp, 0, sizeof (struct lwp_info));

  lp->last_resume_kind = resume_continue;
  lp->waitstatus.kind = TARGET_WAITKIND_IGNORE;

  lp->ptid = ptid;
  lp->core = -1;

  lp->next = lwp_list;
  lwp_list = lp;

  return lp;
}

/* Add the LWP specified by PID to the list.  Return a pointer to the
   structure describing the new LWP.  The LWP should already be
   stopped.  */

static struct lwp_info *
add_lwp (ptid_t ptid)
{
  struct lwp_info *lp;

  lp = add_initial_lwp (ptid);

  /* Let the arch specific bits know about this new thread.  Current
     clients of this callback take the opportunity to install
     watchpoints in the new thread.  We don't do this for the first
     thread though.  See add_initial_lwp.  */
  if (linux_nat_new_thread != NULL)
    linux_nat_new_thread (lp);

  return lp;
}

/* Remove the LWP specified by PID from the list.  */

static void
delete_lwp (ptid_t ptid)
{
  struct lwp_info *lp, *lpprev;

  lpprev = NULL;

  for (lp = lwp_list; lp; lpprev = lp, lp = lp->next)
    if (ptid_equal (lp->ptid, ptid))
      break;

  if (!lp)
    return;

  if (lpprev)
    lpprev->next = lp->next;
  else
    lwp_list = lp->next;

  lwp_free (lp);
}

/* Return a pointer to the structure describing the LWP corresponding
   to PID.  If no corresponding LWP could be found, return NULL.  */

static struct lwp_info *
find_lwp_pid (ptid_t ptid)
{
  struct lwp_info *lp;
  int lwp;

  if (ptid_lwp_p (ptid))
    lwp = ptid_get_lwp (ptid);
  else
    lwp = ptid_get_pid (ptid);

  for (lp = lwp_list; lp; lp = lp->next)
    if (lwp == ptid_get_lwp (lp->ptid))
      return lp;

  return NULL;
}

/* Call CALLBACK with its second argument set to DATA for every LWP in
   the list.  If CALLBACK returns 1 for a particular LWP, return a
   pointer to the structure describing that LWP immediately.
   Otherwise return NULL.  */

struct lwp_info *
iterate_over_lwps (ptid_t filter,
		   int (*callback) (struct lwp_info *, void *),
		   void *data)
{
  struct lwp_info *lp, *lpnext;

  for (lp = lwp_list; lp; lp = lpnext)
    {
      lpnext = lp->next;

      if (ptid_match (lp->ptid, filter))
	{
	  if ((*callback) (lp, data))
	    return lp;
	}
    }

  return NULL;
}

/* Update our internal state when changing from one checkpoint to
   another indicated by NEW_PTID.  We can only switch single-threaded
   applications, so we only create one new LWP, and the previous list
   is discarded.  */

void
linux_nat_switch_fork (ptid_t new_ptid)
{
  struct lwp_info *lp;

  purge_lwp_list (ptid_get_pid (inferior_ptid));

  lp = add_lwp (new_ptid);
  lp->stopped = 1;

  /* This changes the thread's ptid while preserving the gdb thread
     num.  Also changes the inferior pid, while preserving the
     inferior num.  */
  thread_change_ptid (inferior_ptid, new_ptid);

  /* We've just told GDB core that the thread changed target id, but,
     in fact, it really is a different thread, with different register
     contents.  */
  registers_changed ();
}

/* Handle the exit of a single thread LP.  */

static void
exit_lwp (struct lwp_info *lp)
{
  struct thread_info *th = find_thread_ptid (lp->ptid);

  if (th)
    {
      if (print_thread_events)
	printf_unfiltered (_("[%s exited]\n"), target_pid_to_str (lp->ptid));

      delete_thread (lp->ptid);
    }

  delete_lwp (lp->ptid);
}

/* Wait for the LWP specified by LP, which we have just attached to.
   Returns a wait status for that LWP, to cache.  */

static int
linux_nat_post_attach_wait (ptid_t ptid, int first, int *cloned,
			    int *signalled)
{
  pid_t new_pid, pid = ptid_get_lwp (ptid);
  int status;

  if (linux_proc_pid_is_stopped (pid))
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LNPAW: Attaching to a stopped process\n");

      /* The process is definitely stopped.  It is in a job control
	 stop, unless the kernel predates the TASK_STOPPED /
	 TASK_TRACED distinction, in which case it might be in a
	 ptrace stop.  Make sure it is in a ptrace stop; from there we
	 can kill it, signal it, et cetera.

         First make sure there is a pending SIGSTOP.  Since we are
	 already attached, the process can not transition from stopped
	 to running without a PTRACE_CONT; so we know this signal will
	 go into the queue.  The SIGSTOP generated by PTRACE_ATTACH is
	 probably already in the queue (unless this kernel is old
	 enough to use TASK_STOPPED for ptrace stops); but since SIGSTOP
	 is not an RT signal, it can only be queued once.  */
      kill_lwp (pid, SIGSTOP);

      /* Finally, resume the stopped process.  This will deliver the SIGSTOP
	 (or a higher priority signal, just like normal PTRACE_ATTACH).  */
      ptrace (PTRACE_CONT, pid, 0, 0);
    }

  /* Make sure the initial process is stopped.  The user-level threads
     layer might want to poke around in the inferior, and that won't
     work if things haven't stabilized yet.  */
  new_pid = my_waitpid (pid, &status, 0);
  if (new_pid == -1 && errno == ECHILD)
    {
      if (first)
	warning (_("%s is a cloned process"), target_pid_to_str (ptid));

      /* Try again with __WCLONE to check cloned processes.  */
      new_pid = my_waitpid (pid, &status, __WCLONE);
      *cloned = 1;
    }

  gdb_assert (pid == new_pid);

  if (!WIFSTOPPED (status))
    {
      /* The pid we tried to attach has apparently just exited.  */
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog, "LNPAW: Failed to stop %d: %s",
			    pid, status_to_str (status));
      return status;
    }

  if (WSTOPSIG (status) != SIGSTOP)
    {
      *signalled = 1;
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LNPAW: Received %s after attaching\n",
			    status_to_str (status));
    }

  return status;
}

/* Attach to the LWP specified by PID.  Return 0 if successful, -1 if
   the new LWP could not be attached, or 1 if we're already auto
   attached to this thread, but haven't processed the
   PTRACE_EVENT_CLONE event of its parent thread, so we just ignore
   its existance, without considering it an error.  */

int
lin_lwp_attach_lwp (ptid_t ptid)
{
  struct lwp_info *lp;
  int lwpid;

  gdb_assert (ptid_lwp_p (ptid));

  lp = find_lwp_pid (ptid);
  lwpid = ptid_get_lwp (ptid);

  /* We assume that we're already attached to any LWP that has an id
     equal to the overall process id, and to any LWP that is already
     in our list of LWPs.  If we're not seeing exit events from threads
     and we've had PID wraparound since we last tried to stop all threads,
     this assumption might be wrong; fortunately, this is very unlikely
     to happen.  */
  if (lwpid != ptid_get_pid (ptid) && lp == NULL)
    {
      int status, cloned = 0, signalled = 0;

      if (ptrace (PTRACE_ATTACH, lwpid, 0, 0) < 0)
	{
	  if (linux_supports_tracefork ())
	    {
	      /* If we haven't stopped all threads when we get here,
		 we may have seen a thread listed in thread_db's list,
		 but not processed the PTRACE_EVENT_CLONE yet.  If
		 that's the case, ignore this new thread, and let
		 normal event handling discover it later.  */
	      if (in_pid_list_p (stopped_pids, lwpid))
		{
		  /* We've already seen this thread stop, but we
		     haven't seen the PTRACE_EVENT_CLONE extended
		     event yet.  */
		  return 0;
		}
	      else
		{
		  int new_pid;
		  int status;

		  /* See if we've got a stop for this new child
		     pending.  If so, we're already attached.  */
		  new_pid = my_waitpid (lwpid, &status, WNOHANG);
		  if (new_pid == -1 && errno == ECHILD)
		    new_pid = my_waitpid (lwpid, &status, __WCLONE | WNOHANG);
		  if (new_pid != -1)
		    {
		      if (WIFSTOPPED (status))
			add_to_pid_list (&stopped_pids, lwpid, status);
		      return 1;
		    }
		}
	    }

	  /* If we fail to attach to the thread, issue a warning,
	     but continue.  One way this can happen is if thread
	     creation is interrupted; as of Linux kernel 2.6.19, a
	     bug may place threads in the thread list and then fail
	     to create them.  */
	  warning (_("Can't attach %s: %s"), target_pid_to_str (ptid),
		   safe_strerror (errno));
	  return -1;
	}

      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LLAL: PTRACE_ATTACH %s, 0, 0 (OK)\n",
			    target_pid_to_str (ptid));

      status = linux_nat_post_attach_wait (ptid, 0, &cloned, &signalled);
      if (!WIFSTOPPED (status))
	return 1;

      lp = add_lwp (ptid);
      lp->stopped = 1;
      lp->cloned = cloned;
      lp->signalled = signalled;
      if (WSTOPSIG (status) != SIGSTOP)
	{
	  lp->resumed = 1;
	  lp->status = status;
	}

      target_post_attach (ptid_get_lwp (lp->ptid));

      if (debug_linux_nat)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "LLAL: waitpid %s received %s\n",
			      target_pid_to_str (ptid),
			      status_to_str (status));
	}
    }
  else
    {
      /* We assume that the LWP representing the original process is
         already stopped.  Mark it as stopped in the data structure
         that the GNU/linux ptrace layer uses to keep track of
         threads.  Note that this won't have already been done since
         the main thread will have, we assume, been stopped by an
         attach from a different layer.  */
      if (lp == NULL)
	lp = add_lwp (ptid);
      lp->stopped = 1;
    }

  lp->last_resume_kind = resume_stop;
  return 0;
}

static void
linux_nat_create_inferior (struct target_ops *ops, 
			   char *exec_file, char *allargs, char **env,
			   int from_tty)
{
#ifdef HAVE_PERSONALITY
  int personality_orig = 0, personality_set = 0;
#endif /* HAVE_PERSONALITY */

  /* The fork_child mechanism is synchronous and calls target_wait, so
     we have to mask the async mode.  */

#ifdef HAVE_PERSONALITY
  if (disable_randomization)
    {
      errno = 0;
      personality_orig = personality (0xffffffff);
      if (errno == 0 && !(personality_orig & ADDR_NO_RANDOMIZE))
	{
	  personality_set = 1;
	  personality (personality_orig | ADDR_NO_RANDOMIZE);
	}
      if (errno != 0 || (personality_set
			 && !(personality (0xffffffff) & ADDR_NO_RANDOMIZE)))
	warning (_("Error disabling address space randomization: %s"),
		 safe_strerror (errno));
    }
#endif /* HAVE_PERSONALITY */

  /* Make sure we report all signals during startup.  */
  linux_nat_pass_signals (0, NULL);

  linux_ops->to_create_inferior (ops, exec_file, allargs, env, from_tty);

#ifdef HAVE_PERSONALITY
  if (personality_set)
    {
      errno = 0;
      personality (personality_orig);
      if (errno != 0)
	warning (_("Error restoring address space randomization: %s"),
		 safe_strerror (errno));
    }
#endif /* HAVE_PERSONALITY */
}

static void
linux_nat_attach (struct target_ops *ops, char *args, int from_tty)
{
  struct lwp_info *lp;
  int status;
  ptid_t ptid;
  volatile struct gdb_exception ex;

  /* Make sure we report all signals during attach.  */
  linux_nat_pass_signals (0, NULL);

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      linux_ops->to_attach (ops, args, from_tty);
    }
  if (ex.reason < 0)
    {
      pid_t pid = parse_pid_to_attach (args);
      struct buffer buffer;
      char *message, *buffer_s;

      message = xstrdup (ex.message);
      make_cleanup (xfree, message);

      buffer_init (&buffer);
      linux_ptrace_attach_warnings (pid, &buffer);

      buffer_grow_str0 (&buffer, "");
      buffer_s = buffer_finish (&buffer);
      make_cleanup (xfree, buffer_s);

      throw_error (ex.error, "%s%s", buffer_s, message);
    }

  /* The ptrace base target adds the main thread with (pid,0,0)
     format.  Decorate it with lwp info.  */
  ptid = ptid_build (ptid_get_pid (inferior_ptid),
		     ptid_get_pid (inferior_ptid),
		     0);
  thread_change_ptid (inferior_ptid, ptid);

  /* Add the initial process as the first LWP to the list.  */
  lp = add_initial_lwp (ptid);

  status = linux_nat_post_attach_wait (lp->ptid, 1, &lp->cloned,
				       &lp->signalled);
  if (!WIFSTOPPED (status))
    {
      if (WIFEXITED (status))
	{
	  int exit_code = WEXITSTATUS (status);

	  target_terminal_ours ();
	  target_mourn_inferior ();
	  if (exit_code == 0)
	    error (_("Unable to attach: program exited normally."));
	  else
	    error (_("Unable to attach: program exited with code %d."),
		   exit_code);
	}
      else if (WIFSIGNALED (status))
	{
	  enum gdb_signal signo;

	  target_terminal_ours ();
	  target_mourn_inferior ();

	  signo = gdb_signal_from_host (WTERMSIG (status));
	  error (_("Unable to attach: program terminated with signal "
		   "%s, %s."),
		 gdb_signal_to_name (signo),
		 gdb_signal_to_string (signo));
	}

      internal_error (__FILE__, __LINE__,
		      _("unexpected status %d for PID %ld"),
		      status, (long) ptid_get_lwp (ptid));
    }

  lp->stopped = 1;

  /* Save the wait status to report later.  */
  lp->resumed = 1;
  if (debug_linux_nat)
    fprintf_unfiltered (gdb_stdlog,
			"LNA: waitpid %ld, saving status %s\n",
			(long) ptid_get_pid (lp->ptid), status_to_str (status));

  lp->status = status;

  if (target_can_async_p ())
    target_async (inferior_event_handler, 0);
}

/* Get pending status of LP.  */
static int
get_pending_status (struct lwp_info *lp, int *status)
{
  enum gdb_signal signo = GDB_SIGNAL_0;

  /* If we paused threads momentarily, we may have stored pending
     events in lp->status or lp->waitstatus (see stop_wait_callback),
     and GDB core hasn't seen any signal for those threads.
     Otherwise, the last signal reported to the core is found in the
     thread object's stop_signal.

     There's a corner case that isn't handled here at present.  Only
     if the thread stopped with a TARGET_WAITKIND_STOPPED does
     stop_signal make sense as a real signal to pass to the inferior.
     Some catchpoint related events, like
     TARGET_WAITKIND_(V)FORK|EXEC|SYSCALL, have their stop_signal set
     to GDB_SIGNAL_SIGTRAP when the catchpoint triggers.  But,
     those traps are debug API (ptrace in our case) related and
     induced; the inferior wouldn't see them if it wasn't being
     traced.  Hence, we should never pass them to the inferior, even
     when set to pass state.  Since this corner case isn't handled by
     infrun.c when proceeding with a signal, for consistency, neither
     do we handle it here (or elsewhere in the file we check for
     signal pass state).  Normally SIGTRAP isn't set to pass state, so
     this is really a corner case.  */

  if (lp->waitstatus.kind != TARGET_WAITKIND_IGNORE)
    signo = GDB_SIGNAL_0; /* a pending ptrace event, not a real signal.  */
  else if (lp->status)
    signo = gdb_signal_from_host (WSTOPSIG (lp->status));
  else if (non_stop && !is_executing (lp->ptid))
    {
      struct thread_info *tp = find_thread_ptid (lp->ptid);

      signo = tp->suspend.stop_signal;
    }
  else if (!non_stop)
    {
      struct target_waitstatus last;
      ptid_t last_ptid;

      get_last_target_status (&last_ptid, &last);

      if (ptid_get_lwp (lp->ptid) == ptid_get_lwp (last_ptid))
	{
	  struct thread_info *tp = find_thread_ptid (lp->ptid);

	  signo = tp->suspend.stop_signal;
	}
    }

  *status = 0;

  if (signo == GDB_SIGNAL_0)
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "GPT: lwp %s has no pending signal\n",
			    target_pid_to_str (lp->ptid));
    }
  else if (!signal_pass_state (signo))
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "GPT: lwp %s had signal %s, "
			    "but it is in no pass state\n",
			    target_pid_to_str (lp->ptid),
			    gdb_signal_to_string (signo));
    }
  else
    {
      *status = W_STOPCODE (gdb_signal_to_host (signo));

      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "GPT: lwp %s has pending signal %s\n",
			    target_pid_to_str (lp->ptid),
			    gdb_signal_to_string (signo));
    }

  return 0;
}

static int
detach_callback (struct lwp_info *lp, void *data)
{
  gdb_assert (lp->status == 0 || WIFSTOPPED (lp->status));

  if (debug_linux_nat && lp->status)
    fprintf_unfiltered (gdb_stdlog, "DC:  Pending %s for %s on detach.\n",
			strsignal (WSTOPSIG (lp->status)),
			target_pid_to_str (lp->ptid));

  /* If there is a pending SIGSTOP, get rid of it.  */
  if (lp->signalled)
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "DC: Sending SIGCONT to %s\n",
			    target_pid_to_str (lp->ptid));

      kill_lwp (ptid_get_lwp (lp->ptid), SIGCONT);
      lp->signalled = 0;
    }

  /* We don't actually detach from the LWP that has an id equal to the
     overall process id just yet.  */
  if (ptid_get_lwp (lp->ptid) != ptid_get_pid (lp->ptid))
    {
      int status = 0;

      /* Pass on any pending signal for this LWP.  */
      get_pending_status (lp, &status);

      if (linux_nat_prepare_to_resume != NULL)
	linux_nat_prepare_to_resume (lp);
      errno = 0;
      if (ptrace (PTRACE_DETACH, ptid_get_lwp (lp->ptid), 0,
		  WSTOPSIG (status)) < 0)
	error (_("Can't detach %s: %s"), target_pid_to_str (lp->ptid),
	       safe_strerror (errno));

      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "PTRACE_DETACH (%s, %s, 0) (OK)\n",
			    target_pid_to_str (lp->ptid),
			    strsignal (WSTOPSIG (status)));

      delete_lwp (lp->ptid);
    }

  return 0;
}

static void
linux_nat_detach (struct target_ops *ops, char *args, int from_tty)
{
  int pid;
  int status;
  struct lwp_info *main_lwp;

  pid = ptid_get_pid (inferior_ptid);

  /* Don't unregister from the event loop, as there may be other
     inferiors running. */

  /* Stop all threads before detaching.  ptrace requires that the
     thread is stopped to sucessfully detach.  */
  iterate_over_lwps (pid_to_ptid (pid), stop_callback, NULL);
  /* ... and wait until all of them have reported back that
     they're no longer running.  */
  iterate_over_lwps (pid_to_ptid (pid), stop_wait_callback, NULL);

  iterate_over_lwps (pid_to_ptid (pid), detach_callback, NULL);

  /* Only the initial process should be left right now.  */
  gdb_assert (num_lwps (ptid_get_pid (inferior_ptid)) == 1);

  main_lwp = find_lwp_pid (pid_to_ptid (pid));

  /* Pass on any pending signal for the last LWP.  */
  if ((args == NULL || *args == '\0')
      && get_pending_status (main_lwp, &status) != -1
      && WIFSTOPPED (status))
    {
      /* Put the signal number in ARGS so that inf_ptrace_detach will
	 pass it along with PTRACE_DETACH.  */
      args = alloca (8);
      sprintf (args, "%d", (int) WSTOPSIG (status));
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LND: Sending signal %s to %s\n",
			    args,
			    target_pid_to_str (main_lwp->ptid));
    }

  if (linux_nat_prepare_to_resume != NULL)
    linux_nat_prepare_to_resume (main_lwp);
  delete_lwp (main_lwp->ptid);

  if (forks_exist_p ())
    {
      /* Multi-fork case.  The current inferior_ptid is being detached
	 from, but there are other viable forks to debug.  Detach from
	 the current fork, and context-switch to the first
	 available.  */
      linux_fork_detach (args, from_tty);
    }
  else
    linux_ops->to_detach (ops, args, from_tty);
}

/* Resume LP.  */

static void
resume_lwp (struct lwp_info *lp, int step, enum gdb_signal signo)
{
  if (lp->stopped)
    {
      struct inferior *inf = find_inferior_pid (ptid_get_pid (lp->ptid));

      if (inf->vfork_child != NULL)
	{
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"RC: Not resuming %s (vfork parent)\n",
				target_pid_to_str (lp->ptid));
	}
      else if (lp->status == 0
	       && lp->waitstatus.kind == TARGET_WAITKIND_IGNORE)
	{
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"RC: Resuming sibling %s, %s, %s\n",
				target_pid_to_str (lp->ptid),
				(signo != GDB_SIGNAL_0
				 ? strsignal (gdb_signal_to_host (signo))
				 : "0"),
				step ? "step" : "resume");

	  if (linux_nat_prepare_to_resume != NULL)
	    linux_nat_prepare_to_resume (lp);
	  linux_ops->to_resume (linux_ops,
				pid_to_ptid (ptid_get_lwp (lp->ptid)),
				step, signo);
	  lp->stopped = 0;
	  lp->step = step;
	  lp->stopped_by_watchpoint = 0;
	}
      else
	{
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"RC: Not resuming sibling %s (has pending)\n",
				target_pid_to_str (lp->ptid));
	}
    }
  else
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "RC: Not resuming sibling %s (not stopped)\n",
			    target_pid_to_str (lp->ptid));
    }
}

/* Resume LWP, with the last stop signal, if it is in pass state.  */

static int
linux_nat_resume_callback (struct lwp_info *lp, void *data)
{
  enum gdb_signal signo = GDB_SIGNAL_0;

  if (lp->stopped)
    {
      struct thread_info *thread;

      thread = find_thread_ptid (lp->ptid);
      if (thread != NULL)
	{
	  if (signal_pass_state (thread->suspend.stop_signal))
	    signo = thread->suspend.stop_signal;
	  thread->suspend.stop_signal = GDB_SIGNAL_0;
	}
    }

  resume_lwp (lp, 0, signo);
  return 0;
}

static int
resume_clear_callback (struct lwp_info *lp, void *data)
{
  lp->resumed = 0;
  lp->last_resume_kind = resume_stop;
  return 0;
}

static int
resume_set_callback (struct lwp_info *lp, void *data)
{
  lp->resumed = 1;
  lp->last_resume_kind = resume_continue;
  return 0;
}

static void
linux_nat_resume (struct target_ops *ops,
		  ptid_t ptid, int step, enum gdb_signal signo)
{
  struct lwp_info *lp;
  int resume_many;

  if (debug_linux_nat)
    fprintf_unfiltered (gdb_stdlog,
			"LLR: Preparing to %s %s, %s, inferior_ptid %s\n",
			step ? "step" : "resume",
			target_pid_to_str (ptid),
			(signo != GDB_SIGNAL_0
			 ? strsignal (gdb_signal_to_host (signo)) : "0"),
			target_pid_to_str (inferior_ptid));

  /* A specific PTID means `step only this process id'.  */
  resume_many = (ptid_equal (minus_one_ptid, ptid)
		 || ptid_is_pid (ptid));

  /* Mark the lwps we're resuming as resumed.  */
  iterate_over_lwps (ptid, resume_set_callback, NULL);

  /* See if it's the current inferior that should be handled
     specially.  */
  if (resume_many)
    lp = find_lwp_pid (inferior_ptid);
  else
    lp = find_lwp_pid (ptid);
  gdb_assert (lp != NULL);

  /* Remember if we're stepping.  */
  lp->step = step;
  lp->last_resume_kind = step ? resume_step : resume_continue;

  /* If we have a pending wait status for this thread, there is no
     point in resuming the process.  But first make sure that
     linux_nat_wait won't preemptively handle the event - we
     should never take this short-circuit if we are going to
     leave LP running, since we have skipped resuming all the
     other threads.  This bit of code needs to be synchronized
     with linux_nat_wait.  */

  if (lp->status && WIFSTOPPED (lp->status))
    {
      if (!lp->step
	  && WSTOPSIG (lp->status)
	  && sigismember (&pass_mask, WSTOPSIG (lp->status)))
	{
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"LLR: Not short circuiting for ignored "
				"status 0x%x\n", lp->status);

	  /* FIXME: What should we do if we are supposed to continue
	     this thread with a signal?  */
	  gdb_assert (signo == GDB_SIGNAL_0);
	  signo = gdb_signal_from_host (WSTOPSIG (lp->status));
	  lp->status = 0;
	}
    }

  if (lp->status || lp->waitstatus.kind != TARGET_WAITKIND_IGNORE)
    {
      /* FIXME: What should we do if we are supposed to continue
	 this thread with a signal?  */
      gdb_assert (signo == GDB_SIGNAL_0);

      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LLR: Short circuiting for status 0x%x\n",
			    lp->status);

      if (target_can_async_p ())
	{
	  target_async (inferior_event_handler, 0);
	  /* Tell the event loop we have something to process.  */
	  async_file_mark ();
	}
      return;
    }

  /* Mark LWP as not stopped to prevent it from being continued by
     linux_nat_resume_callback.  */
  lp->stopped = 0;

  if (resume_many)
    iterate_over_lwps (ptid, linux_nat_resume_callback, NULL);

  /* Convert to something the lower layer understands.  */
  ptid = pid_to_ptid (ptid_get_lwp (lp->ptid));

  if (linux_nat_prepare_to_resume != NULL)
    linux_nat_prepare_to_resume (lp);
  linux_ops->to_resume (linux_ops, ptid, step, signo);
  lp->stopped_by_watchpoint = 0;

  if (debug_linux_nat)
    fprintf_unfiltered (gdb_stdlog,
			"LLR: %s %s, %s (resume event thread)\n",
			step ? "PTRACE_SINGLESTEP" : "PTRACE_CONT",
			target_pid_to_str (ptid),
			(signo != GDB_SIGNAL_0
			 ? strsignal (gdb_signal_to_host (signo)) : "0"));

  if (target_can_async_p ())
    target_async (inferior_event_handler, 0);
}

/* Send a signal to an LWP.  */

static int
kill_lwp (int lwpid, int signo)
{
  /* Use tkill, if possible, in case we are using nptl threads.  If tkill
     fails, then we are not using nptl threads and we should be using kill.  */

#ifdef HAVE_TKILL_SYSCALL
  {
    static int tkill_failed;

    if (!tkill_failed)
      {
	int ret;

	errno = 0;
	ret = syscall (__NR_tkill, lwpid, signo);
	if (errno != ENOSYS)
	  return ret;
	tkill_failed = 1;
      }
  }
#endif

  return kill (lwpid, signo);
}

/* Handle a GNU/Linux syscall trap wait response.  If we see a syscall
   event, check if the core is interested in it: if not, ignore the
   event, and keep waiting; otherwise, we need to toggle the LWP's
   syscall entry/exit status, since the ptrace event itself doesn't
   indicate it, and report the trap to higher layers.  */

static int
linux_handle_syscall_trap (struct lwp_info *lp, int stopping)
{
  struct target_waitstatus *ourstatus = &lp->waitstatus;
  struct gdbarch *gdbarch = target_thread_architecture (lp->ptid);
  int syscall_number = (int) gdbarch_get_syscall_number (gdbarch, lp->ptid);

  if (stopping)
    {
      /* If we're stopping threads, there's a SIGSTOP pending, which
	 makes it so that the LWP reports an immediate syscall return,
	 followed by the SIGSTOP.  Skip seeing that "return" using
	 PTRACE_CONT directly, and let stop_wait_callback collect the
	 SIGSTOP.  Later when the thread is resumed, a new syscall
	 entry event.  If we didn't do this (and returned 0), we'd
	 leave a syscall entry pending, and our caller, by using
	 PTRACE_CONT to collect the SIGSTOP, skips the syscall return
	 itself.  Later, when the user re-resumes this LWP, we'd see
	 another syscall entry event and we'd mistake it for a return.

	 If stop_wait_callback didn't force the SIGSTOP out of the LWP
	 (leaving immediately with LWP->signalled set, without issuing
	 a PTRACE_CONT), it would still be problematic to leave this
	 syscall enter pending, as later when the thread is resumed,
	 it would then see the same syscall exit mentioned above,
	 followed by the delayed SIGSTOP, while the syscall didn't
	 actually get to execute.  It seems it would be even more
	 confusing to the user.  */

      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LHST: ignoring syscall %d "
			    "for LWP %ld (stopping threads), "
			    "resuming with PTRACE_CONT for SIGSTOP\n",
			    syscall_number,
			    ptid_get_lwp (lp->ptid));

      lp->syscall_state = TARGET_WAITKIND_IGNORE;
      ptrace (PTRACE_CONT, ptid_get_lwp (lp->ptid), 0, 0);
      return 1;
    }

  if (catch_syscall_enabled ())
    {
      /* Always update the entry/return state, even if this particular
	 syscall isn't interesting to the core now.  In async mode,
	 the user could install a new catchpoint for this syscall
	 between syscall enter/return, and we'll need to know to
	 report a syscall return if that happens.  */
      lp->syscall_state = (lp->syscall_state == TARGET_WAITKIND_SYSCALL_ENTRY
			   ? TARGET_WAITKIND_SYSCALL_RETURN
			   : TARGET_WAITKIND_SYSCALL_ENTRY);

      if (catching_syscall_number (syscall_number))
	{
	  /* Alright, an event to report.  */
	  ourstatus->kind = lp->syscall_state;
	  ourstatus->value.syscall_number = syscall_number;

	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"LHST: stopping for %s of syscall %d"
				" for LWP %ld\n",
				lp->syscall_state
				== TARGET_WAITKIND_SYSCALL_ENTRY
				? "entry" : "return",
				syscall_number,
				ptid_get_lwp (lp->ptid));
	  return 0;
	}

      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LHST: ignoring %s of syscall %d "
			    "for LWP %ld\n",
			    lp->syscall_state == TARGET_WAITKIND_SYSCALL_ENTRY
			    ? "entry" : "return",
			    syscall_number,
			    ptid_get_lwp (lp->ptid));
    }
  else
    {
      /* If we had been syscall tracing, and hence used PT_SYSCALL
	 before on this LWP, it could happen that the user removes all
	 syscall catchpoints before we get to process this event.
	 There are two noteworthy issues here:

	 - When stopped at a syscall entry event, resuming with
	   PT_STEP still resumes executing the syscall and reports a
	   syscall return.

	 - Only PT_SYSCALL catches syscall enters.  If we last
	   single-stepped this thread, then this event can't be a
	   syscall enter.  If we last single-stepped this thread, this
	   has to be a syscall exit.

	 The points above mean that the next resume, be it PT_STEP or
	 PT_CONTINUE, can not trigger a syscall trace event.  */
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LHST: caught syscall event "
			    "with no syscall catchpoints."
			    " %d for LWP %ld, ignoring\n",
			    syscall_number,
			    ptid_get_lwp (lp->ptid));
      lp->syscall_state = TARGET_WAITKIND_IGNORE;
    }

  /* The core isn't interested in this event.  For efficiency, avoid
     stopping all threads only to have the core resume them all again.
     Since we're not stopping threads, if we're still syscall tracing
     and not stepping, we can't use PTRACE_CONT here, as we'd miss any
     subsequent syscall.  Simply resume using the inf-ptrace layer,
     which knows when to use PT_SYSCALL or PT_CONTINUE.  */

  /* Note that gdbarch_get_syscall_number may access registers, hence
     fill a regcache.  */
  registers_changed ();
  if (linux_nat_prepare_to_resume != NULL)
    linux_nat_prepare_to_resume (lp);
  linux_ops->to_resume (linux_ops, pid_to_ptid (ptid_get_lwp (lp->ptid)),
			lp->step, GDB_SIGNAL_0);
  return 1;
}

/* Handle a GNU/Linux extended wait response.  If we see a clone
   event, we need to add the new LWP to our list (and not report the
   trap to higher layers).  This function returns non-zero if the
   event should be ignored and we should wait again.  If STOPPING is
   true, the new LWP remains stopped, otherwise it is continued.  */

static int
linux_handle_extended_wait (struct lwp_info *lp, int status,
			    int stopping)
{
  int pid = ptid_get_lwp (lp->ptid);
  struct target_waitstatus *ourstatus = &lp->waitstatus;
  int event = status >> 16;

  if (event == PTRACE_EVENT_FORK || event == PTRACE_EVENT_VFORK
      || event == PTRACE_EVENT_CLONE)
    {
      unsigned long new_pid;
      int ret;

      ptrace (PTRACE_GETEVENTMSG, pid, 0, &new_pid);

      /* If we haven't already seen the new PID stop, wait for it now.  */
      if (! pull_pid_from_list (&stopped_pids, new_pid, &status))
	{
	  /* The new child has a pending SIGSTOP.  We can't affect it until it
	     hits the SIGSTOP, but we're already attached.  */
	  ret = my_waitpid (new_pid, &status,
			    (event == PTRACE_EVENT_CLONE) ? __WCLONE : 0);
	  if (ret == -1)
	    perror_with_name (_("waiting for new child"));
	  else if (ret != new_pid)
	    internal_error (__FILE__, __LINE__,
			    _("wait returned unexpected PID %d"), ret);
	  else if (!WIFSTOPPED (status))
	    internal_error (__FILE__, __LINE__,
			    _("wait returned unexpected status 0x%x"), status);
	}

      ourstatus->value.related_pid = ptid_build (new_pid, new_pid, 0);

      if (event == PTRACE_EVENT_FORK || event == PTRACE_EVENT_VFORK)
	{
	  /* The arch-specific native code may need to know about new
	     forks even if those end up never mapped to an
	     inferior.  */
	  if (linux_nat_new_fork != NULL)
	    linux_nat_new_fork (lp, new_pid);
	}

      if (event == PTRACE_EVENT_FORK
	  && linux_fork_checkpointing_p (ptid_get_pid (lp->ptid)))
	{
	  /* Handle checkpointing by linux-fork.c here as a special
	     case.  We don't want the follow-fork-mode or 'catch fork'
	     to interfere with this.  */

	  /* This won't actually modify the breakpoint list, but will
	     physically remove the breakpoints from the child.  */
	  detach_breakpoints (ptid_build (new_pid, new_pid, 0));

	  /* Retain child fork in ptrace (stopped) state.  */
	  if (!find_fork_pid (new_pid))
	    add_fork (new_pid);

	  /* Report as spurious, so that infrun doesn't want to follow
	     this fork.  We're actually doing an infcall in
	     linux-fork.c.  */
	  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;

	  /* Report the stop to the core.  */
	  return 0;
	}

      if (event == PTRACE_EVENT_FORK)
	ourstatus->kind = TARGET_WAITKIND_FORKED;
      else if (event == PTRACE_EVENT_VFORK)
	ourstatus->kind = TARGET_WAITKIND_VFORKED;
      else
	{
	  struct lwp_info *new_lp;

	  ourstatus->kind = TARGET_WAITKIND_IGNORE;

	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"LHEW: Got clone event "
				"from LWP %d, new child is LWP %ld\n",
				pid, new_pid);

	  new_lp = add_lwp (ptid_build (ptid_get_pid (lp->ptid), new_pid, 0));
	  new_lp->cloned = 1;
	  new_lp->stopped = 1;

	  if (WSTOPSIG (status) != SIGSTOP)
	    {
	      /* This can happen if someone starts sending signals to
		 the new thread before it gets a chance to run, which
		 have a lower number than SIGSTOP (e.g. SIGUSR1).
		 This is an unlikely case, and harder to handle for
		 fork / vfork than for clone, so we do not try - but
		 we handle it for clone events here.  We'll send
		 the other signal on to the thread below.  */

	      new_lp->signalled = 1;
	    }
	  else
	    {
	      struct thread_info *tp;

	      /* When we stop for an event in some other thread, and
		 pull the thread list just as this thread has cloned,
		 we'll have seen the new thread in the thread_db list
		 before handling the CLONE event (glibc's
		 pthread_create adds the new thread to the thread list
		 before clone'ing, and has the kernel fill in the
		 thread's tid on the clone call with
		 CLONE_PARENT_SETTID).  If that happened, and the core
		 had requested the new thread to stop, we'll have
		 killed it with SIGSTOP.  But since SIGSTOP is not an
		 RT signal, it can only be queued once.  We need to be
		 careful to not resume the LWP if we wanted it to
		 stop.  In that case, we'll leave the SIGSTOP pending.
		 It will later be reported as GDB_SIGNAL_0.  */
	      tp = find_thread_ptid (new_lp->ptid);
	      if (tp != NULL && tp->stop_requested)
		new_lp->last_resume_kind = resume_stop;
	      else
		status = 0;
	    }

	  if (non_stop)
	    {
	      /* Add the new thread to GDB's lists as soon as possible
		 so that:

		 1) the frontend doesn't have to wait for a stop to
		 display them, and,

		 2) we tag it with the correct running state.  */

	      /* If the thread_db layer is active, let it know about
		 this new thread, and add it to GDB's list.  */
	      if (!thread_db_attach_lwp (new_lp->ptid))
		{
		  /* We're not using thread_db.  Add it to GDB's
		     list.  */
		  target_post_attach (ptid_get_lwp (new_lp->ptid));
		  add_thread (new_lp->ptid);
		}

	      if (!stopping)
		{
		  set_running (new_lp->ptid, 1);
		  set_executing (new_lp->ptid, 1);
		  /* thread_db_attach_lwp -> lin_lwp_attach_lwp forced
		     resume_stop.  */
		  new_lp->last_resume_kind = resume_continue;
		}
	    }

	  if (status != 0)
	    {
	      /* We created NEW_LP so it cannot yet contain STATUS.  */
	      gdb_assert (new_lp->status == 0);

	      /* Save the wait status to report later.  */
	      if (debug_linux_nat)
		fprintf_unfiltered (gdb_stdlog,
				    "LHEW: waitpid of new LWP %ld, "
				    "saving status %s\n",
				    (long) ptid_get_lwp (new_lp->ptid),
				    status_to_str (status));
	      new_lp->status = status;
	    }

	  /* Note the need to use the low target ops to resume, to
	     handle resuming with PT_SYSCALL if we have syscall
	     catchpoints.  */
	  if (!stopping)
	    {
	      new_lp->resumed = 1;

	      if (status == 0)
		{
		  gdb_assert (new_lp->last_resume_kind == resume_continue);
		  if (debug_linux_nat)
		    fprintf_unfiltered (gdb_stdlog,
					"LHEW: resuming new LWP %ld\n",
					ptid_get_lwp (new_lp->ptid));
		  if (linux_nat_prepare_to_resume != NULL)
		    linux_nat_prepare_to_resume (new_lp);
		  linux_ops->to_resume (linux_ops, pid_to_ptid (new_pid),
					0, GDB_SIGNAL_0);
		  new_lp->stopped = 0;
		}
	    }

	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"LHEW: resuming parent LWP %d\n", pid);
	  if (linux_nat_prepare_to_resume != NULL)
	    linux_nat_prepare_to_resume (lp);
	  linux_ops->to_resume (linux_ops,
				pid_to_ptid (ptid_get_lwp (lp->ptid)),
				0, GDB_SIGNAL_0);

	  return 1;
	}

      return 0;
    }

  if (event == PTRACE_EVENT_EXEC)
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LHEW: Got exec event from LWP %ld\n",
			    ptid_get_lwp (lp->ptid));

      ourstatus->kind = TARGET_WAITKIND_EXECD;
      ourstatus->value.execd_pathname
	= xstrdup (linux_child_pid_to_exec_file (pid));

      return 0;
    }

  if (event == PTRACE_EVENT_VFORK_DONE)
    {
      if (current_inferior ()->waiting_for_vfork_done)
	{
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"LHEW: Got expected PTRACE_EVENT_"
				"VFORK_DONE from LWP %ld: stopping\n",
				ptid_get_lwp (lp->ptid));

	  ourstatus->kind = TARGET_WAITKIND_VFORK_DONE;
	  return 0;
	}

      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LHEW: Got PTRACE_EVENT_VFORK_DONE "
			    "from LWP %ld: resuming\n",
			    ptid_get_lwp (lp->ptid));
      ptrace (PTRACE_CONT, ptid_get_lwp (lp->ptid), 0, 0);
      return 1;
    }

  internal_error (__FILE__, __LINE__,
		  _("unknown ptrace event %d"), event);
}

/* Wait for LP to stop.  Returns the wait status, or 0 if the LWP has
   exited.  */

static int
wait_lwp (struct lwp_info *lp)
{
  pid_t pid;
  int status = 0;
  int thread_dead = 0;
  sigset_t prev_mask;

  gdb_assert (!lp->stopped);
  gdb_assert (lp->status == 0);

  /* Make sure SIGCHLD is blocked for sigsuspend avoiding a race below.  */
  block_child_signals (&prev_mask);

  for (;;)
    {
      /* If my_waitpid returns 0 it means the __WCLONE vs. non-__WCLONE kind
	 was right and we should just call sigsuspend.  */

      pid = my_waitpid (ptid_get_lwp (lp->ptid), &status, WNOHANG);
      if (pid == -1 && errno == ECHILD)
	pid = my_waitpid (ptid_get_lwp (lp->ptid), &status, __WCLONE | WNOHANG);
      if (pid == -1 && errno == ECHILD)
	{
	  /* The thread has previously exited.  We need to delete it
	     now because, for some vendor 2.4 kernels with NPTL
	     support backported, there won't be an exit event unless
	     it is the main thread.  2.6 kernels will report an exit
	     event for each thread that exits, as expected.  */
	  thread_dead = 1;
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog, "WL: %s vanished.\n",
				target_pid_to_str (lp->ptid));
	}
      if (pid != 0)
	break;

      /* Bugs 10970, 12702.
	 Thread group leader may have exited in which case we'll lock up in
	 waitpid if there are other threads, even if they are all zombies too.
	 Basically, we're not supposed to use waitpid this way.
	 __WCLONE is not applicable for the leader so we can't use that.
	 LINUX_NAT_THREAD_ALIVE cannot be used here as it requires a STOPPED
	 process; it gets ESRCH both for the zombie and for running processes.

	 As a workaround, check if we're waiting for the thread group leader and
	 if it's a zombie, and avoid calling waitpid if it is.

	 This is racy, what if the tgl becomes a zombie right after we check?
	 Therefore always use WNOHANG with sigsuspend - it is equivalent to
	 waiting waitpid but linux_proc_pid_is_zombie is safe this way.  */

      if (ptid_get_pid (lp->ptid) == ptid_get_lwp (lp->ptid)
	  && linux_proc_pid_is_zombie (ptid_get_lwp (lp->ptid)))
	{
	  thread_dead = 1;
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"WL: Thread group leader %s vanished.\n",
				target_pid_to_str (lp->ptid));
	  break;
	}

      /* Wait for next SIGCHLD and try again.  This may let SIGCHLD handlers
	 get invoked despite our caller had them intentionally blocked by
	 block_child_signals.  This is sensitive only to the loop of
	 linux_nat_wait_1 and there if we get called my_waitpid gets called
	 again before it gets to sigsuspend so we can safely let the handlers
	 get executed here.  */

      sigsuspend (&suspend_mask);
    }

  restore_child_signals_mask (&prev_mask);

  if (!thread_dead)
    {
      gdb_assert (pid == ptid_get_lwp (lp->ptid));

      if (debug_linux_nat)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "WL: waitpid %s received %s\n",
			      target_pid_to_str (lp->ptid),
			      status_to_str (status));
	}

      /* Check if the thread has exited.  */
      if (WIFEXITED (status) || WIFSIGNALED (status))
	{
	  thread_dead = 1;
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog, "WL: %s exited.\n",
				target_pid_to_str (lp->ptid));
	}
    }

  if (thread_dead)
    {
      exit_lwp (lp);
      return 0;
    }

  gdb_assert (WIFSTOPPED (status));

  /* Handle GNU/Linux's syscall SIGTRAPs.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SYSCALL_SIGTRAP)
    {
      /* No longer need the sysgood bit.  The ptrace event ends up
	 recorded in lp->waitstatus if we care for it.  We can carry
	 on handling the event like a regular SIGTRAP from here
	 on.  */
      status = W_STOPCODE (SIGTRAP);
      if (linux_handle_syscall_trap (lp, 1))
	return wait_lwp (lp);
    }

  /* Handle GNU/Linux's extended waitstatus for trace events.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "WL: Handling extended status 0x%06x\n",
			    status);
      if (linux_handle_extended_wait (lp, status, 1))
	return wait_lwp (lp);
    }

  return status;
}

/* Send a SIGSTOP to LP.  */

static int
stop_callback (struct lwp_info *lp, void *data)
{
  if (!lp->stopped && !lp->signalled)
    {
      int ret;

      if (debug_linux_nat)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "SC:  kill %s **<SIGSTOP>**\n",
			      target_pid_to_str (lp->ptid));
	}
      errno = 0;
      ret = kill_lwp (ptid_get_lwp (lp->ptid), SIGSTOP);
      if (debug_linux_nat)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "SC:  lwp kill %d %s\n",
			      ret,
			      errno ? safe_strerror (errno) : "ERRNO-OK");
	}

      lp->signalled = 1;
      gdb_assert (lp->status == 0);
    }

  return 0;
}

/* Request a stop on LWP.  */

void
linux_stop_lwp (struct lwp_info *lwp)
{
  stop_callback (lwp, NULL);
}

/* Return non-zero if LWP PID has a pending SIGINT.  */

static int
linux_nat_has_pending_sigint (int pid)
{
  sigset_t pending, blocked, ignored;

  linux_proc_pending_signals (pid, &pending, &blocked, &ignored);

  if (sigismember (&pending, SIGINT)
      && !sigismember (&ignored, SIGINT))
    return 1;

  return 0;
}

/* Set a flag in LP indicating that we should ignore its next SIGINT.  */

static int
set_ignore_sigint (struct lwp_info *lp, void *data)
{
  /* If a thread has a pending SIGINT, consume it; otherwise, set a
     flag to consume the next one.  */
  if (lp->stopped && lp->status != 0 && WIFSTOPPED (lp->status)
      && WSTOPSIG (lp->status) == SIGINT)
    lp->status = 0;
  else
    lp->ignore_sigint = 1;

  return 0;
}

/* If LP does not have a SIGINT pending, then clear the ignore_sigint flag.
   This function is called after we know the LWP has stopped; if the LWP
   stopped before the expected SIGINT was delivered, then it will never have
   arrived.  Also, if the signal was delivered to a shared queue and consumed
   by a different thread, it will never be delivered to this LWP.  */

static void
maybe_clear_ignore_sigint (struct lwp_info *lp)
{
  if (!lp->ignore_sigint)
    return;

  if (!linux_nat_has_pending_sigint (ptid_get_lwp (lp->ptid)))
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "MCIS: Clearing bogus flag for %s\n",
			    target_pid_to_str (lp->ptid));
      lp->ignore_sigint = 0;
    }
}

/* Fetch the possible triggered data watchpoint info and store it in
   LP.

   On some archs, like x86, that use debug registers to set
   watchpoints, it's possible that the way to know which watched
   address trapped, is to check the register that is used to select
   which address to watch.  Problem is, between setting the watchpoint
   and reading back which data address trapped, the user may change
   the set of watchpoints, and, as a consequence, GDB changes the
   debug registers in the inferior.  To avoid reading back a stale
   stopped-data-address when that happens, we cache in LP the fact
   that a watchpoint trapped, and the corresponding data address, as
   soon as we see LP stop with a SIGTRAP.  If GDB changes the debug
   registers meanwhile, we have the cached data we can rely on.  */

static void
save_sigtrap (struct lwp_info *lp)
{
  struct cleanup *old_chain;

  if (linux_ops->to_stopped_by_watchpoint == NULL)
    {
      lp->stopped_by_watchpoint = 0;
      return;
    }

  old_chain = save_inferior_ptid ();
  inferior_ptid = lp->ptid;

  lp->stopped_by_watchpoint = linux_ops->to_stopped_by_watchpoint ();

  if (lp->stopped_by_watchpoint)
    {
      if (linux_ops->to_stopped_data_address != NULL)
	lp->stopped_data_address_p =
	  linux_ops->to_stopped_data_address (&current_target,
					      &lp->stopped_data_address);
      else
	lp->stopped_data_address_p = 0;
    }

  do_cleanups (old_chain);
}

/* See save_sigtrap.  */

static int
linux_nat_stopped_by_watchpoint (void)
{
  struct lwp_info *lp = find_lwp_pid (inferior_ptid);

  gdb_assert (lp != NULL);

  return lp->stopped_by_watchpoint;
}

static int
linux_nat_stopped_data_address (struct target_ops *ops, CORE_ADDR *addr_p)
{
  struct lwp_info *lp = find_lwp_pid (inferior_ptid);

  gdb_assert (lp != NULL);

  *addr_p = lp->stopped_data_address;

  return lp->stopped_data_address_p;
}

/* Commonly any breakpoint / watchpoint generate only SIGTRAP.  */

static int
sigtrap_is_event (int status)
{
  return WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP;
}

/* SIGTRAP-like events recognizer.  */

static int (*linux_nat_status_is_event) (int status) = sigtrap_is_event;

/* Check for SIGTRAP-like events in LP.  */

static int
linux_nat_lp_status_is_event (struct lwp_info *lp)
{
  /* We check for lp->waitstatus in addition to lp->status, because we can
     have pending process exits recorded in lp->status
     and W_EXITCODE(0,0) == 0.  We should probably have an additional
     lp->status_p flag.  */

  return (lp->waitstatus.kind == TARGET_WAITKIND_IGNORE
	  && linux_nat_status_is_event (lp->status));
}

/* Set alternative SIGTRAP-like events recognizer.  If
   breakpoint_inserted_here_p there then gdbarch_decr_pc_after_break will be
   applied.  */

void
linux_nat_set_status_is_event (struct target_ops *t,
			       int (*status_is_event) (int status))
{
  linux_nat_status_is_event = status_is_event;
}

/* Wait until LP is stopped.  */

static int
stop_wait_callback (struct lwp_info *lp, void *data)
{
  struct inferior *inf = find_inferior_pid (ptid_get_pid (lp->ptid));

  /* If this is a vfork parent, bail out, it is not going to report
     any SIGSTOP until the vfork is done with.  */
  if (inf->vfork_child != NULL)
    return 0;

  if (!lp->stopped)
    {
      int status;

      status = wait_lwp (lp);
      if (status == 0)
	return 0;

      if (lp->ignore_sigint && WIFSTOPPED (status)
	  && WSTOPSIG (status) == SIGINT)
	{
	  lp->ignore_sigint = 0;

	  errno = 0;
	  ptrace (PTRACE_CONT, ptid_get_lwp (lp->ptid), 0, 0);
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"PTRACE_CONT %s, 0, 0 (%s) "
				"(discarding SIGINT)\n",
				target_pid_to_str (lp->ptid),
				errno ? safe_strerror (errno) : "OK");

	  return stop_wait_callback (lp, NULL);
	}

      maybe_clear_ignore_sigint (lp);

      if (WSTOPSIG (status) != SIGSTOP)
	{
	  /* The thread was stopped with a signal other than SIGSTOP.  */

	  save_sigtrap (lp);

	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"SWC: Pending event %s in %s\n",
				status_to_str ((int) status),
				target_pid_to_str (lp->ptid));

	  /* Save the sigtrap event.  */
	  lp->status = status;
	  gdb_assert (!lp->stopped);
	  gdb_assert (lp->signalled);
	  lp->stopped = 1;
	}
      else
	{
	  /* We caught the SIGSTOP that we intended to catch, so
	     there's no SIGSTOP pending.  */

	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"SWC: Delayed SIGSTOP caught for %s.\n",
				target_pid_to_str (lp->ptid));

	  lp->stopped = 1;

	  /* Reset SIGNALLED only after the stop_wait_callback call
	     above as it does gdb_assert on SIGNALLED.  */
	  lp->signalled = 0;
	}
    }

  return 0;
}

/* Return non-zero if LP has a wait status pending.  */

static int
status_callback (struct lwp_info *lp, void *data)
{
  /* Only report a pending wait status if we pretend that this has
     indeed been resumed.  */
  if (!lp->resumed)
    return 0;

  if (lp->waitstatus.kind != TARGET_WAITKIND_IGNORE)
    {
      /* A ptrace event, like PTRACE_FORK|VFORK|EXEC, syscall event,
	 or a pending process exit.  Note that `W_EXITCODE(0,0) ==
	 0', so a clean process exit can not be stored pending in
	 lp->status, it is indistinguishable from
	 no-pending-status.  */
      return 1;
    }

  if (lp->status != 0)
    return 1;

  return 0;
}

/* Return non-zero if LP isn't stopped.  */

static int
running_callback (struct lwp_info *lp, void *data)
{
  return (!lp->stopped
	  || ((lp->status != 0
	       || lp->waitstatus.kind != TARGET_WAITKIND_IGNORE)
	      && lp->resumed));
}

/* Count the LWP's that have had events.  */

static int
count_events_callback (struct lwp_info *lp, void *data)
{
  int *count = data;

  gdb_assert (count != NULL);

  /* Count only resumed LWPs that have a SIGTRAP event pending.  */
  if (lp->resumed && linux_nat_lp_status_is_event (lp))
    (*count)++;

  return 0;
}

/* Select the LWP (if any) that is currently being single-stepped.  */

static int
select_singlestep_lwp_callback (struct lwp_info *lp, void *data)
{
  if (lp->last_resume_kind == resume_step
      && lp->status != 0)
    return 1;
  else
    return 0;
}

/* Select the Nth LWP that has had a SIGTRAP event.  */

static int
select_event_lwp_callback (struct lwp_info *lp, void *data)
{
  int *selector = data;

  gdb_assert (selector != NULL);

  /* Select only resumed LWPs that have a SIGTRAP event pending.  */
  if (lp->resumed && linux_nat_lp_status_is_event (lp))
    if ((*selector)-- == 0)
      return 1;

  return 0;
}

static int
cancel_breakpoint (struct lwp_info *lp)
{
  /* Arrange for a breakpoint to be hit again later.  We don't keep
     the SIGTRAP status and don't forward the SIGTRAP signal to the
     LWP.  We will handle the current event, eventually we will resume
     this LWP, and this breakpoint will trap again.

     If we do not do this, then we run the risk that the user will
     delete or disable the breakpoint, but the LWP will have already
     tripped on it.  */

  struct regcache *regcache = get_thread_regcache (lp->ptid);
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  CORE_ADDR pc;

  pc = regcache_read_pc (regcache) - gdbarch_decr_pc_after_break (gdbarch);
  if (breakpoint_inserted_here_p (get_regcache_aspace (regcache), pc))
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "CB: Push back breakpoint for %s\n",
			    target_pid_to_str (lp->ptid));

      /* Back up the PC if necessary.  */
      if (gdbarch_decr_pc_after_break (gdbarch))
	regcache_write_pc (regcache, pc);

      return 1;
    }
  return 0;
}

static int
cancel_breakpoints_callback (struct lwp_info *lp, void *data)
{
  struct lwp_info *event_lp = data;

  /* Leave the LWP that has been elected to receive a SIGTRAP alone.  */
  if (lp == event_lp)
    return 0;

  /* If a LWP other than the LWP that we're reporting an event for has
     hit a GDB breakpoint (as opposed to some random trap signal),
     then just arrange for it to hit it again later.  We don't keep
     the SIGTRAP status and don't forward the SIGTRAP signal to the
     LWP.  We will handle the current event, eventually we will resume
     all LWPs, and this one will get its breakpoint trap again.

     If we do not do this, then we run the risk that the user will
     delete or disable the breakpoint, but the LWP will have already
     tripped on it.  */

  if (linux_nat_lp_status_is_event (lp)
      && cancel_breakpoint (lp))
    /* Throw away the SIGTRAP.  */
    lp->status = 0;

  return 0;
}

/* Select one LWP out of those that have events pending.  */

static void
select_event_lwp (ptid_t filter, struct lwp_info **orig_lp, int *status)
{
  int num_events = 0;
  int random_selector;
  struct lwp_info *event_lp;

  /* Record the wait status for the original LWP.  */
  (*orig_lp)->status = *status;

  /* Give preference to any LWP that is being single-stepped.  */
  event_lp = iterate_over_lwps (filter,
				select_singlestep_lwp_callback, NULL);
  if (event_lp != NULL)
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "SEL: Select single-step %s\n",
			    target_pid_to_str (event_lp->ptid));
    }
  else
    {
      /* No single-stepping LWP.  Select one at random, out of those
         which have had SIGTRAP events.  */

      /* First see how many SIGTRAP events we have.  */
      iterate_over_lwps (filter, count_events_callback, &num_events);

      /* Now randomly pick a LWP out of those that have had a SIGTRAP.  */
      random_selector = (int)
	((num_events * (double) rand ()) / (RAND_MAX + 1.0));

      if (debug_linux_nat && num_events > 1)
	fprintf_unfiltered (gdb_stdlog,
			    "SEL: Found %d SIGTRAP events, selecting #%d\n",
			    num_events, random_selector);

      event_lp = iterate_over_lwps (filter,
				    select_event_lwp_callback,
				    &random_selector);
    }

  if (event_lp != NULL)
    {
      /* Switch the event LWP.  */
      *orig_lp = event_lp;
      *status = event_lp->status;
    }

  /* Flush the wait status for the event LWP.  */
  (*orig_lp)->status = 0;
}

/* Return non-zero if LP has been resumed.  */

static int
resumed_callback (struct lwp_info *lp, void *data)
{
  return lp->resumed;
}

/* Stop an active thread, verify it still exists, then resume it.  If
   the thread ends up with a pending status, then it is not resumed,
   and *DATA (really a pointer to int), is set.  */

static int
stop_and_resume_callback (struct lwp_info *lp, void *data)
{
  int *new_pending_p = data;

  if (!lp->stopped)
    {
      ptid_t ptid = lp->ptid;

      stop_callback (lp, NULL);
      stop_wait_callback (lp, NULL);

      /* Resume if the lwp still exists, and the core wanted it
	 running.  */
      lp = find_lwp_pid (ptid);
      if (lp != NULL)
	{
	  if (lp->last_resume_kind == resume_stop
	      && lp->status == 0)
	    {
	      /* The core wanted the LWP to stop.  Even if it stopped
		 cleanly (with SIGSTOP), leave the event pending.  */
	      if (debug_linux_nat)
		fprintf_unfiltered (gdb_stdlog,
				    "SARC: core wanted LWP %ld stopped "
				    "(leaving SIGSTOP pending)\n",
				    ptid_get_lwp (lp->ptid));
	      lp->status = W_STOPCODE (SIGSTOP);
	    }

	  if (lp->status == 0)
	    {
	      if (debug_linux_nat)
		fprintf_unfiltered (gdb_stdlog,
				    "SARC: re-resuming LWP %ld\n",
				    ptid_get_lwp (lp->ptid));
	      resume_lwp (lp, lp->step, GDB_SIGNAL_0);
	    }
	  else
	    {
	      if (debug_linux_nat)
		fprintf_unfiltered (gdb_stdlog,
				    "SARC: not re-resuming LWP %ld "
				    "(has pending)\n",
				    ptid_get_lwp (lp->ptid));
	      if (new_pending_p)
		*new_pending_p = 1;
	    }
	}
    }
  return 0;
}

/* Check if we should go on and pass this event to common code.
   Return the affected lwp if we are, or NULL otherwise.  If we stop
   all lwps temporarily, we may end up with new pending events in some
   other lwp.  In that case set *NEW_PENDING_P to true.  */

static struct lwp_info *
linux_nat_filter_event (int lwpid, int status, int *new_pending_p)
{
  struct lwp_info *lp;

  *new_pending_p = 0;

  lp = find_lwp_pid (pid_to_ptid (lwpid));

  /* Check for stop events reported by a process we didn't already
     know about - anything not already in our LWP list.

     If we're expecting to receive stopped processes after
     fork, vfork, and clone events, then we'll just add the
     new one to our list and go back to waiting for the event
     to be reported - the stopped process might be returned
     from waitpid before or after the event is.

     But note the case of a non-leader thread exec'ing after the
     leader having exited, and gone from our lists.  The non-leader
     thread changes its tid to the tgid.  */

  if (WIFSTOPPED (status) && lp == NULL
      && (WSTOPSIG (status) == SIGTRAP && status >> 16 == PTRACE_EVENT_EXEC))
    {
      /* A multi-thread exec after we had seen the leader exiting.  */
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: Re-adding thread group leader LWP %d.\n",
			    lwpid);

      lp = add_lwp (ptid_build (lwpid, lwpid, 0));
      lp->stopped = 1;
      lp->resumed = 1;
      add_thread (lp->ptid);
    }

  if (WIFSTOPPED (status) && !lp)
    {
      add_to_pid_list (&stopped_pids, lwpid, status);
      return NULL;
    }

  /* Make sure we don't report an event for the exit of an LWP not in
     our list, i.e. not part of the current process.  This can happen
     if we detach from a program we originally forked and then it
     exits.  */
  if (!WIFSTOPPED (status) && !lp)
    return NULL;

  /* Handle GNU/Linux's syscall SIGTRAPs.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SYSCALL_SIGTRAP)
    {
      /* No longer need the sysgood bit.  The ptrace event ends up
	 recorded in lp->waitstatus if we care for it.  We can carry
	 on handling the event like a regular SIGTRAP from here
	 on.  */
      status = W_STOPCODE (SIGTRAP);
      if (linux_handle_syscall_trap (lp, 0))
	return NULL;
    }

  /* Handle GNU/Linux's extended waitstatus for trace events.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: Handling extended status 0x%06x\n",
			    status);
      if (linux_handle_extended_wait (lp, status, 0))
	return NULL;
    }

  if (linux_nat_status_is_event (status))
    save_sigtrap (lp);

  /* Check if the thread has exited.  */
  if ((WIFEXITED (status) || WIFSIGNALED (status))
      && num_lwps (ptid_get_pid (lp->ptid)) > 1)
    {
      /* If this is the main thread, we must stop all threads and verify
	 if they are still alive.  This is because in the nptl thread model
	 on Linux 2.4, there is no signal issued for exiting LWPs
	 other than the main thread.  We only get the main thread exit
	 signal once all child threads have already exited.  If we
	 stop all the threads and use the stop_wait_callback to check
	 if they have exited we can determine whether this signal
	 should be ignored or whether it means the end of the debugged
	 application, regardless of which threading model is being
	 used.  */
      if (ptid_get_pid (lp->ptid) == ptid_get_lwp (lp->ptid))
	{
	  lp->stopped = 1;
	  iterate_over_lwps (pid_to_ptid (ptid_get_pid (lp->ptid)),
			     stop_and_resume_callback, new_pending_p);
	}

      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: %s exited.\n",
			    target_pid_to_str (lp->ptid));

      if (num_lwps (ptid_get_pid (lp->ptid)) > 1)
       {
	 /* If there is at least one more LWP, then the exit signal
	    was not the end of the debugged application and should be
	    ignored.  */
	 exit_lwp (lp);
	 return NULL;
       }
    }

  /* Check if the current LWP has previously exited.  In the nptl
     thread model, LWPs other than the main thread do not issue
     signals when they exit so we must check whenever the thread has
     stopped.  A similar check is made in stop_wait_callback().  */
  if (num_lwps (ptid_get_pid (lp->ptid)) > 1 && !linux_thread_alive (lp->ptid))
    {
      ptid_t ptid = pid_to_ptid (ptid_get_pid (lp->ptid));

      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: %s exited.\n",
			    target_pid_to_str (lp->ptid));

      exit_lwp (lp);

      /* Make sure there is at least one thread running.  */
      gdb_assert (iterate_over_lwps (ptid, running_callback, NULL));

      /* Discard the event.  */
      return NULL;
    }

  /* Make sure we don't report a SIGSTOP that we sent ourselves in
     an attempt to stop an LWP.  */
  if (lp->signalled
      && WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP)
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: Delayed SIGSTOP caught for %s.\n",
			    target_pid_to_str (lp->ptid));

      lp->signalled = 0;

      if (lp->last_resume_kind != resume_stop)
	{
	  /* This is a delayed SIGSTOP.  */

	  registers_changed ();

	  if (linux_nat_prepare_to_resume != NULL)
	    linux_nat_prepare_to_resume (lp);
	  linux_ops->to_resume (linux_ops,
				pid_to_ptid (ptid_get_lwp (lp->ptid)),
				lp->step, GDB_SIGNAL_0);
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"LLW: %s %s, 0, 0 (discard SIGSTOP)\n",
				lp->step ?
				"PTRACE_SINGLESTEP" : "PTRACE_CONT",
				target_pid_to_str (lp->ptid));

	  lp->stopped = 0;
	  gdb_assert (lp->resumed);

	  /* Discard the event.  */
	  return NULL;
	}
    }

  /* Make sure we don't report a SIGINT that we have already displayed
     for another thread.  */
  if (lp->ignore_sigint
      && WIFSTOPPED (status) && WSTOPSIG (status) == SIGINT)
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: Delayed SIGINT caught for %s.\n",
			    target_pid_to_str (lp->ptid));

      /* This is a delayed SIGINT.  */
      lp->ignore_sigint = 0;

      registers_changed ();
      if (linux_nat_prepare_to_resume != NULL)
	linux_nat_prepare_to_resume (lp);
      linux_ops->to_resume (linux_ops, pid_to_ptid (ptid_get_lwp (lp->ptid)),
			    lp->step, GDB_SIGNAL_0);
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: %s %s, 0, 0 (discard SIGINT)\n",
			    lp->step ?
			    "PTRACE_SINGLESTEP" : "PTRACE_CONT",
			    target_pid_to_str (lp->ptid));

      lp->stopped = 0;
      gdb_assert (lp->resumed);

      /* Discard the event.  */
      return NULL;
    }

  /* An interesting event.  */
  gdb_assert (lp);
  lp->status = status;
  return lp;
}

/* Detect zombie thread group leaders, and "exit" them.  We can't reap
   their exits until all other threads in the group have exited.  */

static void
check_zombie_leaders (void)
{
  struct inferior *inf;

  ALL_INFERIORS (inf)
    {
      struct lwp_info *leader_lp;

      if (inf->pid == 0)
	continue;

      leader_lp = find_lwp_pid (pid_to_ptid (inf->pid));
      if (leader_lp != NULL
	  /* Check if there are other threads in the group, as we may
	     have raced with the inferior simply exiting.  */
	  && num_lwps (inf->pid) > 1
	  && linux_proc_pid_is_zombie (inf->pid))
	{
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"CZL: Thread group leader %d zombie "
				"(it exited, or another thread execd).\n",
				inf->pid);

	  /* A leader zombie can mean one of two things:

	     - It exited, and there's an exit status pending
	     available, or only the leader exited (not the whole
	     program).  In the latter case, we can't waitpid the
	     leader's exit status until all other threads are gone.

	     - There are 3 or more threads in the group, and a thread
	     other than the leader exec'd.  On an exec, the Linux
	     kernel destroys all other threads (except the execing
	     one) in the thread group, and resets the execing thread's
	     tid to the tgid.  No exit notification is sent for the
	     execing thread -- from the ptracer's perspective, it
	     appears as though the execing thread just vanishes.
	     Until we reap all other threads except the leader and the
	     execing thread, the leader will be zombie, and the
	     execing thread will be in `D (disc sleep)'.  As soon as
	     all other threads are reaped, the execing thread changes
	     it's tid to the tgid, and the previous (zombie) leader
	     vanishes, giving place to the "new" leader.  We could try
	     distinguishing the exit and exec cases, by waiting once
	     more, and seeing if something comes out, but it doesn't
	     sound useful.  The previous leader _does_ go away, and
	     we'll re-add the new one once we see the exec event
	     (which is just the same as what would happen if the
	     previous leader did exit voluntarily before some other
	     thread execs).  */

	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"CZL: Thread group leader %d vanished.\n",
				inf->pid);
	  exit_lwp (leader_lp);
	}
    }
}

static ptid_t
linux_nat_wait_1 (struct target_ops *ops,
		  ptid_t ptid, struct target_waitstatus *ourstatus,
		  int target_options)
{
  static sigset_t prev_mask;
  enum resume_kind last_resume_kind;
  struct lwp_info *lp;
  int status;

  if (debug_linux_nat)
    fprintf_unfiltered (gdb_stdlog, "LLW: enter\n");

  /* The first time we get here after starting a new inferior, we may
     not have added it to the LWP list yet - this is the earliest
     moment at which we know its PID.  */
  if (ptid_is_pid (inferior_ptid))
    {
      /* Upgrade the main thread's ptid.  */
      thread_change_ptid (inferior_ptid,
			  ptid_build (ptid_get_pid (inferior_ptid),
				      ptid_get_pid (inferior_ptid), 0));

      lp = add_initial_lwp (inferior_ptid);
      lp->resumed = 1;
    }

  /* Make sure SIGCHLD is blocked until the sigsuspend below.  */
  block_child_signals (&prev_mask);

retry:
  lp = NULL;
  status = 0;

  /* First check if there is a LWP with a wait status pending.  */
  if (ptid_equal (ptid, minus_one_ptid) || ptid_is_pid (ptid))
    {
      /* Any LWP in the PTID group that's been resumed will do.  */
      lp = iterate_over_lwps (ptid, status_callback, NULL);
      if (lp)
	{
	  if (debug_linux_nat && lp->status)
	    fprintf_unfiltered (gdb_stdlog,
				"LLW: Using pending wait status %s for %s.\n",
				status_to_str (lp->status),
				target_pid_to_str (lp->ptid));
	}
    }
  else if (ptid_lwp_p (ptid))
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: Waiting for specific LWP %s.\n",
			    target_pid_to_str (ptid));

      /* We have a specific LWP to check.  */
      lp = find_lwp_pid (ptid);
      gdb_assert (lp);

      if (debug_linux_nat && lp->status)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: Using pending wait status %s for %s.\n",
			    status_to_str (lp->status),
			    target_pid_to_str (lp->ptid));

      /* We check for lp->waitstatus in addition to lp->status,
	 because we can have pending process exits recorded in
	 lp->status and W_EXITCODE(0,0) == 0.  We should probably have
	 an additional lp->status_p flag.  */
      if (lp->status == 0 && lp->waitstatus.kind == TARGET_WAITKIND_IGNORE)
	lp = NULL;
    }

  if (!target_can_async_p ())
    {
      /* Causes SIGINT to be passed on to the attached process.  */
      set_sigint_trap ();
    }

  /* But if we don't find a pending event, we'll have to wait.  */

  while (lp == NULL)
    {
      pid_t lwpid;

      /* Always use -1 and WNOHANG, due to couple of a kernel/ptrace
	 quirks:

	 - If the thread group leader exits while other threads in the
	   thread group still exist, waitpid(TGID, ...) hangs.  That
	   waitpid won't return an exit status until the other threads
	   in the group are reapped.

	 - When a non-leader thread execs, that thread just vanishes
	   without reporting an exit (so we'd hang if we waited for it
	   explicitly in that case).  The exec event is reported to
	   the TGID pid.  */

      errno = 0;
      lwpid = my_waitpid (-1, &status,  __WCLONE | WNOHANG);
      if (lwpid == 0 || (lwpid == -1 && errno == ECHILD))
	lwpid = my_waitpid (-1, &status, WNOHANG);

      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LNW: waitpid(-1, ...) returned %d, %s\n",
			    lwpid, errno ? safe_strerror (errno) : "ERRNO-OK");

      if (lwpid > 0)
	{
	  /* If this is true, then we paused LWPs momentarily, and may
	     now have pending events to handle.  */
	  int new_pending;

	  if (debug_linux_nat)
	    {
	      fprintf_unfiltered (gdb_stdlog,
				  "LLW: waitpid %ld received %s\n",
				  (long) lwpid, status_to_str (status));
	    }

	  lp = linux_nat_filter_event (lwpid, status, &new_pending);

	  /* STATUS is now no longer valid, use LP->STATUS instead.  */
	  status = 0;

	  if (lp && !ptid_match (lp->ptid, ptid))
	    {
	      gdb_assert (lp->resumed);

	      if (debug_linux_nat)
		fprintf (stderr,
			 "LWP %ld got an event %06x, leaving pending.\n",
			 ptid_get_lwp (lp->ptid), lp->status);

	      if (WIFSTOPPED (lp->status))
		{
		  if (WSTOPSIG (lp->status) != SIGSTOP)
		    {
		      /* Cancel breakpoint hits.  The breakpoint may
			 be removed before we fetch events from this
			 process to report to the core.  It is best
			 not to assume the moribund breakpoints
			 heuristic always handles these cases --- it
			 could be too many events go through to the
			 core before this one is handled.  All-stop
			 always cancels breakpoint hits in all
			 threads.  */
		      if (non_stop
			  && linux_nat_lp_status_is_event (lp)
			  && cancel_breakpoint (lp))
			{
			  /* Throw away the SIGTRAP.  */
			  lp->status = 0;

			  if (debug_linux_nat)
			    fprintf (stderr,
				     "LLW: LWP %ld hit a breakpoint while"
				     " waiting for another process;"
				     " cancelled it\n",
				     ptid_get_lwp (lp->ptid));
			}
		      lp->stopped = 1;
		    }
		  else
		    {
		      lp->stopped = 1;
		      lp->signalled = 0;
		    }
		}
	      else if (WIFEXITED (lp->status) || WIFSIGNALED (lp->status))
		{
		  if (debug_linux_nat)
		    fprintf (stderr,
			     "Process %ld exited while stopping LWPs\n",
			     ptid_get_lwp (lp->ptid));

		  /* This was the last lwp in the process.  Since
		     events are serialized to GDB core, and we can't
		     report this one right now, but GDB core and the
		     other target layers will want to be notified
		     about the exit code/signal, leave the status
		     pending for the next time we're able to report
		     it.  */

		  /* Prevent trying to stop this thread again.  We'll
		     never try to resume it because it has a pending
		     status.  */
		  lp->stopped = 1;

		  /* Dead LWP's aren't expected to reported a pending
		     sigstop.  */
		  lp->signalled = 0;

		  /* Store the pending event in the waitstatus as
		     well, because W_EXITCODE(0,0) == 0.  */
		  store_waitstatus (&lp->waitstatus, lp->status);
		}

	      /* Keep looking.  */
	      lp = NULL;
	    }

	  if (new_pending)
	    {
	      /* Some LWP now has a pending event.  Go all the way
		 back to check it.  */
	      goto retry;
	    }

	  if (lp)
	    {
	      /* We got an event to report to the core.  */
	      break;
	    }

	  /* Retry until nothing comes out of waitpid.  A single
	     SIGCHLD can indicate more than one child stopped.  */
	  continue;
	}

      /* Check for zombie thread group leaders.  Those can't be reaped
	 until all other threads in the thread group are.  */
      check_zombie_leaders ();

      /* If there are no resumed children left, bail.  We'd be stuck
	 forever in the sigsuspend call below otherwise.  */
      if (iterate_over_lwps (ptid, resumed_callback, NULL) == NULL)
	{
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog, "LLW: exit (no resumed LWP)\n");

	  ourstatus->kind = TARGET_WAITKIND_NO_RESUMED;

	  if (!target_can_async_p ())
	    clear_sigint_trap ();

	  restore_child_signals_mask (&prev_mask);
	  return minus_one_ptid;
	}

      /* No interesting event to report to the core.  */

      if (target_options & TARGET_WNOHANG)
	{
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog, "LLW: exit (ignore)\n");

	  ourstatus->kind = TARGET_WAITKIND_IGNORE;
	  restore_child_signals_mask (&prev_mask);
	  return minus_one_ptid;
	}

      /* We shouldn't end up here unless we want to try again.  */
      gdb_assert (lp == NULL);

      /* Block until we get an event reported with SIGCHLD.  */
      sigsuspend (&suspend_mask);
    }

  if (!target_can_async_p ())
    clear_sigint_trap ();

  gdb_assert (lp);

  status = lp->status;
  lp->status = 0;

  /* Don't report signals that GDB isn't interested in, such as
     signals that are neither printed nor stopped upon.  Stopping all
     threads can be a bit time-consuming so if we want decent
     performance with heavily multi-threaded programs, especially when
     they're using a high frequency timer, we'd better avoid it if we
     can.  */

  if (WIFSTOPPED (status))
    {
      enum gdb_signal signo = gdb_signal_from_host (WSTOPSIG (status));

      /* When using hardware single-step, we need to report every signal.
	 Otherwise, signals in pass_mask may be short-circuited.  */
      if (!lp->step
	  && WSTOPSIG (status) && sigismember (&pass_mask, WSTOPSIG (status)))
	{
	  /* FIMXE: kettenis/2001-06-06: Should we resume all threads
	     here?  It is not clear we should.  GDB may not expect
	     other threads to run.  On the other hand, not resuming
	     newly attached threads may cause an unwanted delay in
	     getting them running.  */
	  registers_changed ();
	  if (linux_nat_prepare_to_resume != NULL)
	    linux_nat_prepare_to_resume (lp);
	  linux_ops->to_resume (linux_ops,
				pid_to_ptid (ptid_get_lwp (lp->ptid)),
				lp->step, signo);
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"LLW: %s %s, %s (preempt 'handle')\n",
				lp->step ?
				"PTRACE_SINGLESTEP" : "PTRACE_CONT",
				target_pid_to_str (lp->ptid),
				(signo != GDB_SIGNAL_0
				 ? strsignal (gdb_signal_to_host (signo))
				 : "0"));
	  lp->stopped = 0;
	  goto retry;
	}

      if (!non_stop)
	{
	  /* Only do the below in all-stop, as we currently use SIGINT
	     to implement target_stop (see linux_nat_stop) in
	     non-stop.  */
	  if (signo == GDB_SIGNAL_INT && signal_pass_state (signo) == 0)
	    {
	      /* If ^C/BREAK is typed at the tty/console, SIGINT gets
		 forwarded to the entire process group, that is, all LWPs
		 will receive it - unless they're using CLONE_THREAD to
		 share signals.  Since we only want to report it once, we
		 mark it as ignored for all LWPs except this one.  */
	      iterate_over_lwps (pid_to_ptid (ptid_get_pid (ptid)),
					      set_ignore_sigint, NULL);
	      lp->ignore_sigint = 0;
	    }
	  else
	    maybe_clear_ignore_sigint (lp);
	}
    }

  /* This LWP is stopped now.  */
  lp->stopped = 1;

  if (debug_linux_nat)
    fprintf_unfiltered (gdb_stdlog, "LLW: Candidate event %s in %s.\n",
			status_to_str (status), target_pid_to_str (lp->ptid));

  if (!non_stop)
    {
      /* Now stop all other LWP's ...  */
      iterate_over_lwps (minus_one_ptid, stop_callback, NULL);

      /* ... and wait until all of them have reported back that
	 they're no longer running.  */
      iterate_over_lwps (minus_one_ptid, stop_wait_callback, NULL);

      /* If we're not waiting for a specific LWP, choose an event LWP
	 from among those that have had events.  Giving equal priority
	 to all LWPs that have had events helps prevent
	 starvation.  */
      if (ptid_equal (ptid, minus_one_ptid) || ptid_is_pid (ptid))
	select_event_lwp (ptid, &lp, &status);

      /* Now that we've selected our final event LWP, cancel any
	 breakpoints in other LWPs that have hit a GDB breakpoint.
	 See the comment in cancel_breakpoints_callback to find out
	 why.  */
      iterate_over_lwps (minus_one_ptid, cancel_breakpoints_callback, lp);

      /* We'll need this to determine whether to report a SIGSTOP as
	 TARGET_WAITKIND_0.  Need to take a copy because
	 resume_clear_callback clears it.  */
      last_resume_kind = lp->last_resume_kind;

      /* In all-stop, from the core's perspective, all LWPs are now
	 stopped until a new resume action is sent over.  */
      iterate_over_lwps (minus_one_ptid, resume_clear_callback, NULL);
    }
  else
    {
      /* See above.  */
      last_resume_kind = lp->last_resume_kind;
      resume_clear_callback (lp, NULL);
    }

  if (linux_nat_status_is_event (status))
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: trap ptid is %s.\n",
			    target_pid_to_str (lp->ptid));
    }

  if (lp->waitstatus.kind != TARGET_WAITKIND_IGNORE)
    {
      *ourstatus = lp->waitstatus;
      lp->waitstatus.kind = TARGET_WAITKIND_IGNORE;
    }
  else
    store_waitstatus (ourstatus, status);

  if (debug_linux_nat)
    fprintf_unfiltered (gdb_stdlog, "LLW: exit\n");

  restore_child_signals_mask (&prev_mask);

  if (last_resume_kind == resume_stop
      && ourstatus->kind == TARGET_WAITKIND_STOPPED
      && WSTOPSIG (status) == SIGSTOP)
    {
      /* A thread that has been requested to stop by GDB with
	 target_stop, and it stopped cleanly, so report as SIG0.  The
	 use of SIGSTOP is an implementation detail.  */
      ourstatus->value.sig = GDB_SIGNAL_0;
    }

  if (ourstatus->kind == TARGET_WAITKIND_EXITED
      || ourstatus->kind == TARGET_WAITKIND_SIGNALLED)
    lp->core = -1;
  else
    lp->core = linux_common_core_of_thread (lp->ptid);

  return lp->ptid;
}

/* Resume LWPs that are currently stopped without any pending status
   to report, but are resumed from the core's perspective.  */

static int
resume_stopped_resumed_lwps (struct lwp_info *lp, void *data)
{
  ptid_t *wait_ptid_p = data;

  if (lp->stopped
      && lp->resumed
      && lp->status == 0
      && lp->waitstatus.kind == TARGET_WAITKIND_IGNORE)
    {
      struct regcache *regcache = get_thread_regcache (lp->ptid);
      struct gdbarch *gdbarch = get_regcache_arch (regcache);
      CORE_ADDR pc = regcache_read_pc (regcache);

      gdb_assert (is_executing (lp->ptid));

      /* Don't bother if there's a breakpoint at PC that we'd hit
	 immediately, and we're not waiting for this LWP.  */
      if (!ptid_match (lp->ptid, *wait_ptid_p))
	{
	  if (breakpoint_inserted_here_p (get_regcache_aspace (regcache), pc))
	    return 0;
	}

      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "RSRL: resuming stopped-resumed LWP %s at %s: step=%d\n",
			    target_pid_to_str (lp->ptid),
			    paddress (gdbarch, pc),
			    lp->step);

      registers_changed ();
      if (linux_nat_prepare_to_resume != NULL)
	linux_nat_prepare_to_resume (lp);
      linux_ops->to_resume (linux_ops, pid_to_ptid (ptid_get_lwp (lp->ptid)),
			    lp->step, GDB_SIGNAL_0);
      lp->stopped = 0;
      lp->stopped_by_watchpoint = 0;
    }

  return 0;
}

static ptid_t
linux_nat_wait (struct target_ops *ops,
		ptid_t ptid, struct target_waitstatus *ourstatus,
		int target_options)
{
  ptid_t event_ptid;

  if (debug_linux_nat)
    {
      char *options_string;

      options_string = target_options_to_string (target_options);
      fprintf_unfiltered (gdb_stdlog,
			  "linux_nat_wait: [%s], [%s]\n",
			  target_pid_to_str (ptid),
			  options_string);
      xfree (options_string);
    }

  /* Flush the async file first.  */
  if (target_can_async_p ())
    async_file_flush ();

  /* Resume LWPs that are currently stopped without any pending status
     to report, but are resumed from the core's perspective.  LWPs get
     in this state if we find them stopping at a time we're not
     interested in reporting the event (target_wait on a
     specific_process, for example, see linux_nat_wait_1), and
     meanwhile the event became uninteresting.  Don't bother resuming
     LWPs we're not going to wait for if they'd stop immediately.  */
  if (non_stop)
    iterate_over_lwps (minus_one_ptid, resume_stopped_resumed_lwps, &ptid);

  event_ptid = linux_nat_wait_1 (ops, ptid, ourstatus, target_options);

  /* If we requested any event, and something came out, assume there
     may be more.  If we requested a specific lwp or process, also
     assume there may be more.  */
  if (target_can_async_p ()
      && ((ourstatus->kind != TARGET_WAITKIND_IGNORE
	   && ourstatus->kind != TARGET_WAITKIND_NO_RESUMED)
	  || !ptid_equal (ptid, minus_one_ptid)))
    async_file_mark ();

  /* Get ready for the next event.  */
  if (target_can_async_p ())
    target_async (inferior_event_handler, 0);

  return event_ptid;
}

static int
kill_callback (struct lwp_info *lp, void *data)
{
  /* PTRACE_KILL may resume the inferior.  Send SIGKILL first.  */

  errno = 0;
  kill (ptid_get_lwp (lp->ptid), SIGKILL);
  if (debug_linux_nat)
    fprintf_unfiltered (gdb_stdlog,
			"KC:  kill (SIGKILL) %s, 0, 0 (%s)\n",
			target_pid_to_str (lp->ptid),
			errno ? safe_strerror (errno) : "OK");

  /* Some kernels ignore even SIGKILL for processes under ptrace.  */

  errno = 0;
  ptrace (PTRACE_KILL, ptid_get_lwp (lp->ptid), 0, 0);
  if (debug_linux_nat)
    fprintf_unfiltered (gdb_stdlog,
			"KC:  PTRACE_KILL %s, 0, 0 (%s)\n",
			target_pid_to_str (lp->ptid),
			errno ? safe_strerror (errno) : "OK");

  return 0;
}

static int
kill_wait_callback (struct lwp_info *lp, void *data)
{
  pid_t pid;

  /* We must make sure that there are no pending events (delayed
     SIGSTOPs, pending SIGTRAPs, etc.) to make sure the current
     program doesn't interfere with any following debugging session.  */

  /* For cloned processes we must check both with __WCLONE and
     without, since the exit status of a cloned process isn't reported
     with __WCLONE.  */
  if (lp->cloned)
    {
      do
	{
	  pid = my_waitpid (ptid_get_lwp (lp->ptid), NULL, __WCLONE);
	  if (pid != (pid_t) -1)
	    {
	      if (debug_linux_nat)
		fprintf_unfiltered (gdb_stdlog,
				    "KWC: wait %s received unknown.\n",
				    target_pid_to_str (lp->ptid));
	      /* The Linux kernel sometimes fails to kill a thread
		 completely after PTRACE_KILL; that goes from the stop
		 point in do_fork out to the one in
		 get_signal_to_deliever and waits again.  So kill it
		 again.  */
	      kill_callback (lp, NULL);
	    }
	}
      while (pid == ptid_get_lwp (lp->ptid));

      gdb_assert (pid == -1 && errno == ECHILD);
    }

  do
    {
      pid = my_waitpid (ptid_get_lwp (lp->ptid), NULL, 0);
      if (pid != (pid_t) -1)
	{
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"KWC: wait %s received unk.\n",
				target_pid_to_str (lp->ptid));
	  /* See the call to kill_callback above.  */
	  kill_callback (lp, NULL);
	}
    }
  while (pid == ptid_get_lwp (lp->ptid));

  gdb_assert (pid == -1 && errno == ECHILD);
  return 0;
}

static void
linux_nat_kill (struct target_ops *ops)
{
  struct target_waitstatus last;
  ptid_t last_ptid;
  int status;

  /* If we're stopped while forking and we haven't followed yet,
     kill the other task.  We need to do this first because the
     parent will be sleeping if this is a vfork.  */

  get_last_target_status (&last_ptid, &last);

  if (last.kind == TARGET_WAITKIND_FORKED
      || last.kind == TARGET_WAITKIND_VFORKED)
    {
      ptrace (PT_KILL, ptid_get_pid (last.value.related_pid), 0, 0);
      wait (&status);

      /* Let the arch-specific native code know this process is
	 gone.  */
      linux_nat_forget_process (ptid_get_pid (last.value.related_pid));
    }

  if (forks_exist_p ())
    linux_fork_killall ();
  else
    {
      ptid_t ptid = pid_to_ptid (ptid_get_pid (inferior_ptid));

      /* Stop all threads before killing them, since ptrace requires
	 that the thread is stopped to sucessfully PTRACE_KILL.  */
      iterate_over_lwps (ptid, stop_callback, NULL);
      /* ... and wait until all of them have reported back that
	 they're no longer running.  */
      iterate_over_lwps (ptid, stop_wait_callback, NULL);

      /* Kill all LWP's ...  */
      iterate_over_lwps (ptid, kill_callback, NULL);

      /* ... and wait until we've flushed all events.  */
      iterate_over_lwps (ptid, kill_wait_callback, NULL);
    }

  target_mourn_inferior ();
}

static void
linux_nat_mourn_inferior (struct target_ops *ops)
{
  int pid = ptid_get_pid (inferior_ptid);

  purge_lwp_list (pid);

  if (! forks_exist_p ())
    /* Normal case, no other forks available.  */
    linux_ops->to_mourn_inferior (ops);
  else
    /* Multi-fork case.  The current inferior_ptid has exited, but
       there are other viable forks to debug.  Delete the exiting
       one and context-switch to the first available.  */
    linux_fork_mourn_inferior ();

  /* Let the arch-specific native code know this process is gone.  */
  linux_nat_forget_process (pid);
}

/* Convert a native/host siginfo object, into/from the siginfo in the
   layout of the inferiors' architecture.  */

static void
siginfo_fixup (siginfo_t *siginfo, gdb_byte *inf_siginfo, int direction)
{
  int done = 0;

  if (linux_nat_siginfo_fixup != NULL)
    done = linux_nat_siginfo_fixup (siginfo, inf_siginfo, direction);

  /* If there was no callback, or the callback didn't do anything,
     then just do a straight memcpy.  */
  if (!done)
    {
      if (direction == 1)
	memcpy (siginfo, inf_siginfo, sizeof (siginfo_t));
      else
	memcpy (inf_siginfo, siginfo, sizeof (siginfo_t));
    }
}

static LONGEST
linux_xfer_siginfo (struct target_ops *ops, enum target_object object,
                    const char *annex, gdb_byte *readbuf,
		    const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
{
  int pid;
  siginfo_t siginfo;
  gdb_byte inf_siginfo[sizeof (siginfo_t)];

  gdb_assert (object == TARGET_OBJECT_SIGNAL_INFO);
  gdb_assert (readbuf || writebuf);

  pid = ptid_get_lwp (inferior_ptid);
  if (pid == 0)
    pid = ptid_get_pid (inferior_ptid);

  if (offset > sizeof (siginfo))
    return -1;

  errno = 0;
  ptrace (PTRACE_GETSIGINFO, pid, (PTRACE_TYPE_ARG3) 0, &siginfo);
  if (errno != 0)
    return -1;

  /* When GDB is built as a 64-bit application, ptrace writes into
     SIGINFO an object with 64-bit layout.  Since debugging a 32-bit
     inferior with a 64-bit GDB should look the same as debugging it
     with a 32-bit GDB, we need to convert it.  GDB core always sees
     the converted layout, so any read/write will have to be done
     post-conversion.  */
  siginfo_fixup (&siginfo, inf_siginfo, 0);

  if (offset + len > sizeof (siginfo))
    len = sizeof (siginfo) - offset;

  if (readbuf != NULL)
    memcpy (readbuf, inf_siginfo + offset, len);
  else
    {
      memcpy (inf_siginfo + offset, writebuf, len);

      /* Convert back to ptrace layout before flushing it out.  */
      siginfo_fixup (&siginfo, inf_siginfo, 1);

      errno = 0;
      ptrace (PTRACE_SETSIGINFO, pid, (PTRACE_TYPE_ARG3) 0, &siginfo);
      if (errno != 0)
	return -1;
    }

  return len;
}

static LONGEST
linux_nat_xfer_partial (struct target_ops *ops, enum target_object object,
			const char *annex, gdb_byte *readbuf,
			const gdb_byte *writebuf,
			ULONGEST offset, LONGEST len)
{
  struct cleanup *old_chain;
  LONGEST xfer;

  if (object == TARGET_OBJECT_SIGNAL_INFO)
    return linux_xfer_siginfo (ops, object, annex, readbuf, writebuf,
			       offset, len);

  /* The target is connected but no live inferior is selected.  Pass
     this request down to a lower stratum (e.g., the executable
     file).  */
  if (object == TARGET_OBJECT_MEMORY && ptid_equal (inferior_ptid, null_ptid))
    return 0;

  old_chain = save_inferior_ptid ();

  if (ptid_lwp_p (inferior_ptid))
    inferior_ptid = pid_to_ptid (ptid_get_lwp (inferior_ptid));

  xfer = linux_ops->to_xfer_partial (ops, object, annex, readbuf, writebuf,
				     offset, len);

  do_cleanups (old_chain);
  return xfer;
}

static int
linux_thread_alive (ptid_t ptid)
{
  int err, tmp_errno;

  gdb_assert (ptid_lwp_p (ptid));

  /* Send signal 0 instead of anything ptrace, because ptracing a
     running thread errors out claiming that the thread doesn't
     exist.  */
  err = kill_lwp (ptid_get_lwp (ptid), 0);
  tmp_errno = errno;
  if (debug_linux_nat)
    fprintf_unfiltered (gdb_stdlog,
			"LLTA: KILL(SIG0) %s (%s)\n",
			target_pid_to_str (ptid),
			err ? safe_strerror (tmp_errno) : "OK");

  if (err != 0)
    return 0;

  return 1;
}

static int
linux_nat_thread_alive (struct target_ops *ops, ptid_t ptid)
{
  return linux_thread_alive (ptid);
}

static char *
linux_nat_pid_to_str (struct target_ops *ops, ptid_t ptid)
{
  static char buf[64];

  if (ptid_lwp_p (ptid)
      && (ptid_get_pid (ptid) != ptid_get_lwp (ptid)
	  || num_lwps (ptid_get_pid (ptid)) > 1))
    {
      snprintf (buf, sizeof (buf), "LWP %ld", ptid_get_lwp (ptid));
      return buf;
    }

  return normal_pid_to_str (ptid);
}

static char *
linux_nat_thread_name (struct thread_info *thr)
{
  int pid = ptid_get_pid (thr->ptid);
  long lwp = ptid_get_lwp (thr->ptid);
#define FORMAT "/proc/%d/task/%ld/comm"
  char buf[sizeof (FORMAT) + 30];
  FILE *comm_file;
  char *result = NULL;

  snprintf (buf, sizeof (buf), FORMAT, pid, lwp);
  comm_file = gdb_fopen_cloexec (buf, "r");
  if (comm_file)
    {
      /* Not exported by the kernel, so we define it here.  */
#define COMM_LEN 16
      static char line[COMM_LEN + 1];

      if (fgets (line, sizeof (line), comm_file))
	{
	  char *nl = strchr (line, '\n');

	  if (nl)
	    *nl = '\0';
	  if (*line != '\0')
	    result = line;
	}

      fclose (comm_file);
    }

#undef COMM_LEN
#undef FORMAT

  return result;
}

/* Accepts an integer PID; Returns a string representing a file that
   can be opened to get the symbols for the child process.  */

static char *
linux_child_pid_to_exec_file (int pid)
{
  char *name1, *name2;

  name1 = xmalloc (PATH_MAX);
  name2 = xmalloc (PATH_MAX);
  make_cleanup (xfree, name1);
  make_cleanup (xfree, name2);
  memset (name2, 0, PATH_MAX);

  sprintf (name1, "/proc/%d/exe", pid);
  if (readlink (name1, name2, PATH_MAX - 1) > 0)
    return name2;
  else
    return name1;
}

/* Records the thread's register state for the corefile note
   section.  */

static char *
linux_nat_collect_thread_registers (const struct regcache *regcache,
				    ptid_t ptid, bfd *obfd,
				    char *note_data, int *note_size,
				    enum gdb_signal stop_signal)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  const struct regset *regset;
  int core_regset_p;
  gdb_gregset_t gregs;
  gdb_fpregset_t fpregs;

  core_regset_p = gdbarch_regset_from_core_section_p (gdbarch);

  if (core_regset_p
      && (regset = gdbarch_regset_from_core_section (gdbarch, ".reg",
						     sizeof (gregs)))
	 != NULL && regset->collect_regset != NULL)
    regset->collect_regset (regset, regcache, -1, &gregs, sizeof (gregs));
  else
    fill_gregset (regcache, &gregs, -1);

  note_data = (char *) elfcore_write_prstatus
			 (obfd, note_data, note_size, ptid_get_lwp (ptid),
			  gdb_signal_to_host (stop_signal), &gregs);

  if (core_regset_p
      && (regset = gdbarch_regset_from_core_section (gdbarch, ".reg2",
						     sizeof (fpregs)))
	  != NULL && regset->collect_regset != NULL)
    regset->collect_regset (regset, regcache, -1, &fpregs, sizeof (fpregs));
  else
    fill_fpregset (regcache, &fpregs, -1);

  note_data = (char *) elfcore_write_prfpreg (obfd, note_data, note_size,
					      &fpregs, sizeof (fpregs));

  return note_data;
}

/* Fills the "to_make_corefile_note" target vector.  Builds the note
   section for a corefile, and returns it in a malloc buffer.  */

static char *
linux_nat_make_corefile_notes (bfd *obfd, int *note_size)
{
  /* FIXME: uweigand/2011-10-06: Once all GNU/Linux architectures have been
     converted to gdbarch_core_regset_sections, this function can go away.  */
  return linux_make_corefile_notes (target_gdbarch (), obfd, note_size,
				    linux_nat_collect_thread_registers);
}

/* Implement the to_xfer_partial interface for memory reads using the /proc
   filesystem.  Because we can use a single read() call for /proc, this
   can be much more efficient than banging away at PTRACE_PEEKTEXT,
   but it doesn't support writes.  */

static LONGEST
linux_proc_xfer_partial (struct target_ops *ops, enum target_object object,
			 const char *annex, gdb_byte *readbuf,
			 const gdb_byte *writebuf,
			 ULONGEST offset, LONGEST len)
{
  LONGEST ret;
  int fd;
  char filename[64];

  if (object != TARGET_OBJECT_MEMORY || !readbuf)
    return 0;

  /* Don't bother for one word.  */
  if (len < 3 * sizeof (long))
    return 0;

  /* We could keep this file open and cache it - possibly one per
     thread.  That requires some juggling, but is even faster.  */
  sprintf (filename, "/proc/%d/mem", ptid_get_pid (inferior_ptid));
  fd = gdb_open_cloexec (filename, O_RDONLY | O_LARGEFILE, 0);
  if (fd == -1)
    return 0;

  /* If pread64 is available, use it.  It's faster if the kernel
     supports it (only one syscall), and it's 64-bit safe even on
     32-bit platforms (for instance, SPARC debugging a SPARC64
     application).  */
#ifdef HAVE_PREAD64
  if (pread64 (fd, readbuf, len, offset) != len)
#else
  if (lseek (fd, offset, SEEK_SET) == -1 || read (fd, readbuf, len) != len)
#endif
    ret = 0;
  else
    ret = len;

  close (fd);
  return ret;
}


/* Enumerate spufs IDs for process PID.  */
static LONGEST
spu_enumerate_spu_ids (int pid, gdb_byte *buf, ULONGEST offset, LONGEST len)
{
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());
  LONGEST pos = 0;
  LONGEST written = 0;
  char path[128];
  DIR *dir;
  struct dirent *entry;

  xsnprintf (path, sizeof path, "/proc/%d/fd", pid);
  dir = opendir (path);
  if (!dir)
    return -1;

  rewinddir (dir);
  while ((entry = readdir (dir)) != NULL)
    {
      struct stat st;
      struct statfs stfs;
      int fd;

      fd = atoi (entry->d_name);
      if (!fd)
	continue;

      xsnprintf (path, sizeof path, "/proc/%d/fd/%d", pid, fd);
      if (stat (path, &st) != 0)
	continue;
      if (!S_ISDIR (st.st_mode))
	continue;

      if (statfs (path, &stfs) != 0)
	continue;
      if (stfs.f_type != SPUFS_MAGIC)
	continue;

      if (pos >= offset && pos + 4 <= offset + len)
	{
	  store_unsigned_integer (buf + pos - offset, 4, byte_order, fd);
	  written += 4;
	}
      pos += 4;
    }

  closedir (dir);
  return written;
}

/* Implement the to_xfer_partial interface for the TARGET_OBJECT_SPU
   object type, using the /proc file system.  */
static LONGEST
linux_proc_xfer_spu (struct target_ops *ops, enum target_object object,
		     const char *annex, gdb_byte *readbuf,
		     const gdb_byte *writebuf,
		     ULONGEST offset, LONGEST len)
{
  char buf[128];
  int fd = 0;
  int ret = -1;
  int pid = ptid_get_pid (inferior_ptid);

  if (!annex)
    {
      if (!readbuf)
	return -1;
      else
	return spu_enumerate_spu_ids (pid, readbuf, offset, len);
    }

  xsnprintf (buf, sizeof buf, "/proc/%d/fd/%s", pid, annex);
  fd = gdb_open_cloexec (buf, writebuf? O_WRONLY : O_RDONLY, 0);
  if (fd <= 0)
    return -1;

  if (offset != 0
      && lseek (fd, (off_t) offset, SEEK_SET) != (off_t) offset)
    {
      close (fd);
      return 0;
    }

  if (writebuf)
    ret = write (fd, writebuf, (size_t) len);
  else if (readbuf)
    ret = read (fd, readbuf, (size_t) len);

  close (fd);
  return ret;
}


/* Parse LINE as a signal set and add its set bits to SIGS.  */

static void
add_line_to_sigset (const char *line, sigset_t *sigs)
{
  int len = strlen (line) - 1;
  const char *p;
  int signum;

  if (line[len] != '\n')
    error (_("Could not parse signal set: %s"), line);

  p = line;
  signum = len * 4;
  while (len-- > 0)
    {
      int digit;

      if (*p >= '0' && *p <= '9')
	digit = *p - '0';
      else if (*p >= 'a' && *p <= 'f')
	digit = *p - 'a' + 10;
      else
	error (_("Could not parse signal set: %s"), line);

      signum -= 4;

      if (digit & 1)
	sigaddset (sigs, signum + 1);
      if (digit & 2)
	sigaddset (sigs, signum + 2);
      if (digit & 4)
	sigaddset (sigs, signum + 3);
      if (digit & 8)
	sigaddset (sigs, signum + 4);

      p++;
    }
}

/* Find process PID's pending signals from /proc/pid/status and set
   SIGS to match.  */

void
linux_proc_pending_signals (int pid, sigset_t *pending,
			    sigset_t *blocked, sigset_t *ignored)
{
  FILE *procfile;
  char buffer[PATH_MAX], fname[PATH_MAX];
  struct cleanup *cleanup;

  sigemptyset (pending);
  sigemptyset (blocked);
  sigemptyset (ignored);
  sprintf (fname, "/proc/%d/status", pid);
  procfile = gdb_fopen_cloexec (fname, "r");
  if (procfile == NULL)
    error (_("Could not open %s"), fname);
  cleanup = make_cleanup_fclose (procfile);

  while (fgets (buffer, PATH_MAX, procfile) != NULL)
    {
      /* Normal queued signals are on the SigPnd line in the status
	 file.  However, 2.6 kernels also have a "shared" pending
	 queue for delivering signals to a thread group, so check for
	 a ShdPnd line also.

	 Unfortunately some Red Hat kernels include the shared pending
	 queue but not the ShdPnd status field.  */

      if (strncmp (buffer, "SigPnd:\t", 8) == 0)
	add_line_to_sigset (buffer + 8, pending);
      else if (strncmp (buffer, "ShdPnd:\t", 8) == 0)
	add_line_to_sigset (buffer + 8, pending);
      else if (strncmp (buffer, "SigBlk:\t", 8) == 0)
	add_line_to_sigset (buffer + 8, blocked);
      else if (strncmp (buffer, "SigIgn:\t", 8) == 0)
	add_line_to_sigset (buffer + 8, ignored);
    }

  do_cleanups (cleanup);
}

static LONGEST
linux_nat_xfer_osdata (struct target_ops *ops, enum target_object object,
		       const char *annex, gdb_byte *readbuf,
		       const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
{
  gdb_assert (object == TARGET_OBJECT_OSDATA);

  return linux_common_xfer_osdata (annex, readbuf, offset, len);
}

static LONGEST
linux_xfer_partial (struct target_ops *ops, enum target_object object,
                    const char *annex, gdb_byte *readbuf,
		    const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
{
  LONGEST xfer;

  if (object == TARGET_OBJECT_AUXV)
    return memory_xfer_auxv (ops, object, annex, readbuf, writebuf,
			     offset, len);

  if (object == TARGET_OBJECT_OSDATA)
    return linux_nat_xfer_osdata (ops, object, annex, readbuf, writebuf,
                               offset, len);

  if (object == TARGET_OBJECT_SPU)
    return linux_proc_xfer_spu (ops, object, annex, readbuf, writebuf,
				offset, len);

  /* GDB calculates all the addresses in possibly larget width of the address.
     Address width needs to be masked before its final use - either by
     linux_proc_xfer_partial or inf_ptrace_xfer_partial.

     Compare ADDR_BIT first to avoid a compiler warning on shift overflow.  */

  if (object == TARGET_OBJECT_MEMORY)
    {
      int addr_bit = gdbarch_addr_bit (target_gdbarch ());

      if (addr_bit < (sizeof (ULONGEST) * HOST_CHAR_BIT))
	offset &= ((ULONGEST) 1 << addr_bit) - 1;
    }

  xfer = linux_proc_xfer_partial (ops, object, annex, readbuf, writebuf,
				  offset, len);
  if (xfer != 0)
    return xfer;

  return super_xfer_partial (ops, object, annex, readbuf, writebuf,
			     offset, len);
}

static void
cleanup_target_stop (void *arg)
{
  ptid_t *ptid = (ptid_t *) arg;

  gdb_assert (arg != NULL);

  /* Unpause all */
  target_resume (*ptid, 0, GDB_SIGNAL_0);
}

static VEC(static_tracepoint_marker_p) *
linux_child_static_tracepoint_markers_by_strid (const char *strid)
{
  char s[IPA_CMD_BUF_SIZE];
  struct cleanup *old_chain;
  int pid = ptid_get_pid (inferior_ptid);
  VEC(static_tracepoint_marker_p) *markers = NULL;
  struct static_tracepoint_marker *marker = NULL;
  char *p = s;
  ptid_t ptid = ptid_build (pid, 0, 0);

  /* Pause all */
  target_stop (ptid);

  memcpy (s, "qTfSTM", sizeof ("qTfSTM"));
  s[sizeof ("qTfSTM")] = 0;

  agent_run_command (pid, s, strlen (s) + 1);

  old_chain = make_cleanup (free_current_marker, &marker);
  make_cleanup (cleanup_target_stop, &ptid);

  while (*p++ == 'm')
    {
      if (marker == NULL)
	marker = XCNEW (struct static_tracepoint_marker);

      do
	{
	  parse_static_tracepoint_marker_definition (p, &p, marker);

	  if (strid == NULL || strcmp (strid, marker->str_id) == 0)
	    {
	      VEC_safe_push (static_tracepoint_marker_p,
			     markers, marker);
	      marker = NULL;
	    }
	  else
	    {
	      release_static_tracepoint_marker (marker);
	      memset (marker, 0, sizeof (*marker));
	    }
	}
      while (*p++ == ',');	/* comma-separated list */

      memcpy (s, "qTsSTM", sizeof ("qTsSTM"));
      s[sizeof ("qTsSTM")] = 0;
      agent_run_command (pid, s, strlen (s) + 1);
      p = s;
    }

  do_cleanups (old_chain);

  return markers;
}

/* Create a prototype generic GNU/Linux target.  The client can override
   it with local methods.  */

static void
linux_target_install_ops (struct target_ops *t)
{
  t->to_insert_fork_catchpoint = linux_child_insert_fork_catchpoint;
  t->to_remove_fork_catchpoint = linux_child_remove_fork_catchpoint;
  t->to_insert_vfork_catchpoint = linux_child_insert_vfork_catchpoint;
  t->to_remove_vfork_catchpoint = linux_child_remove_vfork_catchpoint;
  t->to_insert_exec_catchpoint = linux_child_insert_exec_catchpoint;
  t->to_remove_exec_catchpoint = linux_child_remove_exec_catchpoint;
  t->to_set_syscall_catchpoint = linux_child_set_syscall_catchpoint;
  t->to_pid_to_exec_file = linux_child_pid_to_exec_file;
  t->to_post_startup_inferior = linux_child_post_startup_inferior;
  t->to_post_attach = linux_child_post_attach;
  t->to_follow_fork = linux_child_follow_fork;
  t->to_make_corefile_notes = linux_nat_make_corefile_notes;

  super_xfer_partial = t->to_xfer_partial;
  t->to_xfer_partial = linux_xfer_partial;

  t->to_static_tracepoint_markers_by_strid
    = linux_child_static_tracepoint_markers_by_strid;
}

struct target_ops *
linux_target (void)
{
  struct target_ops *t;

  t = inf_ptrace_target ();
  linux_target_install_ops (t);

  return t;
}

struct target_ops *
linux_trad_target (CORE_ADDR (*register_u_offset)(struct gdbarch *, int, int))
{
  struct target_ops *t;

  t = inf_ptrace_trad_target (register_u_offset);
  linux_target_install_ops (t);

  return t;
}

/* target_is_async_p implementation.  */

static int
linux_nat_is_async_p (void)
{
  /* NOTE: palves 2008-03-21: We're only async when the user requests
     it explicitly with the "set target-async" command.
     Someday, linux will always be async.  */
  return target_async_permitted;
}

/* target_can_async_p implementation.  */

static int
linux_nat_can_async_p (void)
{
  /* NOTE: palves 2008-03-21: We're only async when the user requests
     it explicitly with the "set target-async" command.
     Someday, linux will always be async.  */
  return target_async_permitted;
}

static int
linux_nat_supports_non_stop (void)
{
  return 1;
}

/* True if we want to support multi-process.  To be removed when GDB
   supports multi-exec.  */

int linux_multi_process = 1;

static int
linux_nat_supports_multi_process (void)
{
  return linux_multi_process;
}

static int
linux_nat_supports_disable_randomization (void)
{
#ifdef HAVE_PERSONALITY
  return 1;
#else
  return 0;
#endif
}

static int async_terminal_is_ours = 1;

/* target_terminal_inferior implementation.  */

static void
linux_nat_terminal_inferior (void)
{
  if (!target_is_async_p ())
    {
      /* Async mode is disabled.  */
      terminal_inferior ();
      return;
    }

  terminal_inferior ();

  /* Calls to target_terminal_*() are meant to be idempotent.  */
  if (!async_terminal_is_ours)
    return;

  delete_file_handler (input_fd);
  async_terminal_is_ours = 0;
  set_sigint_trap ();
}

/* target_terminal_ours implementation.  */

static void
linux_nat_terminal_ours (void)
{
  if (!target_is_async_p ())
    {
      /* Async mode is disabled.  */
      terminal_ours ();
      return;
    }

  /* GDB should never give the terminal to the inferior if the
     inferior is running in the background (run&, continue&, etc.),
     but claiming it sure should.  */
  terminal_ours ();

  if (async_terminal_is_ours)
    return;

  clear_sigint_trap ();
  add_file_handler (input_fd, stdin_event_handler, 0);
  async_terminal_is_ours = 1;
}

static void (*async_client_callback) (enum inferior_event_type event_type,
				      void *context);
static void *async_client_context;

/* SIGCHLD handler that serves two purposes: In non-stop/async mode,
   so we notice when any child changes state, and notify the
   event-loop; it allows us to use sigsuspend in linux_nat_wait_1
   above to wait for the arrival of a SIGCHLD.  */

static void
sigchld_handler (int signo)
{
  int old_errno = errno;

  if (debug_linux_nat)
    ui_file_write_async_safe (gdb_stdlog,
			      "sigchld\n", sizeof ("sigchld\n") - 1);

  if (signo == SIGCHLD
      && linux_nat_event_pipe[0] != -1)
    async_file_mark (); /* Let the event loop know that there are
			   events to handle.  */

  errno = old_errno;
}

/* Callback registered with the target events file descriptor.  */

static void
handle_target_event (int error, gdb_client_data client_data)
{
  (*async_client_callback) (INF_REG_EVENT, async_client_context);
}

/* Create/destroy the target events pipe.  Returns previous state.  */

static int
linux_async_pipe (int enable)
{
  int previous = (linux_nat_event_pipe[0] != -1);

  if (previous != enable)
    {
      sigset_t prev_mask;

      /* Block child signals while we create/destroy the pipe, as
	 their handler writes to it.  */
      block_child_signals (&prev_mask);

      if (enable)
	{
	  if (gdb_pipe_cloexec (linux_nat_event_pipe) == -1)
	    internal_error (__FILE__, __LINE__,
			    "creating event pipe failed.");

	  fcntl (linux_nat_event_pipe[0], F_SETFL, O_NONBLOCK);
	  fcntl (linux_nat_event_pipe[1], F_SETFL, O_NONBLOCK);
	}
      else
	{
	  close (linux_nat_event_pipe[0]);
	  close (linux_nat_event_pipe[1]);
	  linux_nat_event_pipe[0] = -1;
	  linux_nat_event_pipe[1] = -1;
	}

      restore_child_signals_mask (&prev_mask);
    }

  return previous;
}

/* target_async implementation.  */

static void
linux_nat_async (void (*callback) (enum inferior_event_type event_type,
				   void *context), void *context)
{
  if (callback != NULL)
    {
      async_client_callback = callback;
      async_client_context = context;
      if (!linux_async_pipe (1))
	{
	  add_file_handler (linux_nat_event_pipe[0],
			    handle_target_event, NULL);
	  /* There may be pending events to handle.  Tell the event loop
	     to poll them.  */
	  async_file_mark ();
	}
    }
  else
    {
      async_client_callback = callback;
      async_client_context = context;
      delete_file_handler (linux_nat_event_pipe[0]);
      linux_async_pipe (0);
    }
  return;
}

/* Stop an LWP, and push a GDB_SIGNAL_0 stop status if no other
   event came out.  */

static int
linux_nat_stop_lwp (struct lwp_info *lwp, void *data)
{
  if (!lwp->stopped)
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LNSL: running -> suspending %s\n",
			    target_pid_to_str (lwp->ptid));


      if (lwp->last_resume_kind == resume_stop)
	{
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"linux-nat: already stopping LWP %ld at "
				"GDB's request\n",
				ptid_get_lwp (lwp->ptid));
	  return 0;
	}

      stop_callback (lwp, NULL);
      lwp->last_resume_kind = resume_stop;
    }
  else
    {
      /* Already known to be stopped; do nothing.  */

      if (debug_linux_nat)
	{
	  if (find_thread_ptid (lwp->ptid)->stop_requested)
	    fprintf_unfiltered (gdb_stdlog,
				"LNSL: already stopped/stop_requested %s\n",
				target_pid_to_str (lwp->ptid));
	  else
	    fprintf_unfiltered (gdb_stdlog,
				"LNSL: already stopped/no "
				"stop_requested yet %s\n",
				target_pid_to_str (lwp->ptid));
	}
    }
  return 0;
}

static void
linux_nat_stop (ptid_t ptid)
{
  if (non_stop)
    iterate_over_lwps (ptid, linux_nat_stop_lwp, NULL);
  else
    linux_ops->to_stop (ptid);
}

static void
linux_nat_close (void)
{
  /* Unregister from the event loop.  */
  if (linux_nat_is_async_p ())
    linux_nat_async (NULL, 0);

  if (linux_ops->to_close)
    linux_ops->to_close ();
}

/* When requests are passed down from the linux-nat layer to the
   single threaded inf-ptrace layer, ptids of (lwpid,0,0) form are
   used.  The address space pointer is stored in the inferior object,
   but the common code that is passed such ptid can't tell whether
   lwpid is a "main" process id or not (it assumes so).  We reverse
   look up the "main" process id from the lwp here.  */

static struct address_space *
linux_nat_thread_address_space (struct target_ops *t, ptid_t ptid)
{
  struct lwp_info *lwp;
  struct inferior *inf;
  int pid;

  pid = ptid_get_lwp (ptid);
  if (ptid_get_lwp (ptid) == 0)
    {
      /* An (lwpid,0,0) ptid.  Look up the lwp object to get at the
	 tgid.  */
      lwp = find_lwp_pid (ptid);
      pid = ptid_get_pid (lwp->ptid);
    }
  else
    {
      /* A (pid,lwpid,0) ptid.  */
      pid = ptid_get_pid (ptid);
    }

  inf = find_inferior_pid (pid);
  gdb_assert (inf != NULL);
  return inf->aspace;
}

/* Return the cached value of the processor core for thread PTID.  */

static int
linux_nat_core_of_thread (struct target_ops *ops, ptid_t ptid)
{
  struct lwp_info *info = find_lwp_pid (ptid);

  if (info)
    return info->core;
  return -1;
}

void
linux_nat_add_target (struct target_ops *t)
{
  /* Save the provided single-threaded target.  We save this in a separate
     variable because another target we've inherited from (e.g. inf-ptrace)
     may have saved a pointer to T; we want to use it for the final
     process stratum target.  */
  linux_ops_saved = *t;
  linux_ops = &linux_ops_saved;

  /* Override some methods for multithreading.  */
  t->to_create_inferior = linux_nat_create_inferior;
  t->to_attach = linux_nat_attach;
  t->to_detach = linux_nat_detach;
  t->to_resume = linux_nat_resume;
  t->to_wait = linux_nat_wait;
  t->to_pass_signals = linux_nat_pass_signals;
  t->to_xfer_partial = linux_nat_xfer_partial;
  t->to_kill = linux_nat_kill;
  t->to_mourn_inferior = linux_nat_mourn_inferior;
  t->to_thread_alive = linux_nat_thread_alive;
  t->to_pid_to_str = linux_nat_pid_to_str;
  t->to_thread_name = linux_nat_thread_name;
  t->to_has_thread_control = tc_schedlock;
  t->to_thread_address_space = linux_nat_thread_address_space;
  t->to_stopped_by_watchpoint = linux_nat_stopped_by_watchpoint;
  t->to_stopped_data_address = linux_nat_stopped_data_address;

  t->to_can_async_p = linux_nat_can_async_p;
  t->to_is_async_p = linux_nat_is_async_p;
  t->to_supports_non_stop = linux_nat_supports_non_stop;
  t->to_async = linux_nat_async;
  t->to_terminal_inferior = linux_nat_terminal_inferior;
  t->to_terminal_ours = linux_nat_terminal_ours;
  t->to_close = linux_nat_close;

  /* Methods for non-stop support.  */
  t->to_stop = linux_nat_stop;

  t->to_supports_multi_process = linux_nat_supports_multi_process;

  t->to_supports_disable_randomization
    = linux_nat_supports_disable_randomization;

  t->to_core_of_thread = linux_nat_core_of_thread;

  /* We don't change the stratum; this target will sit at
     process_stratum and thread_db will set at thread_stratum.  This
     is a little strange, since this is a multi-threaded-capable
     target, but we want to be on the stack below thread_db, and we
     also want to be used for single-threaded processes.  */

  add_target (t);
}

/* Register a method to call whenever a new thread is attached.  */
void
linux_nat_set_new_thread (struct target_ops *t,
			  void (*new_thread) (struct lwp_info *))
{
  /* Save the pointer.  We only support a single registered instance
     of the GNU/Linux native target, so we do not need to map this to
     T.  */
  linux_nat_new_thread = new_thread;
}

/* See declaration in linux-nat.h.  */

void
linux_nat_set_new_fork (struct target_ops *t,
			linux_nat_new_fork_ftype *new_fork)
{
  /* Save the pointer.  */
  linux_nat_new_fork = new_fork;
}

/* See declaration in linux-nat.h.  */

void
linux_nat_set_forget_process (struct target_ops *t,
			      linux_nat_forget_process_ftype *fn)
{
  /* Save the pointer.  */
  linux_nat_forget_process_hook = fn;
}

/* See declaration in linux-nat.h.  */

void
linux_nat_forget_process (pid_t pid)
{
  if (linux_nat_forget_process_hook != NULL)
    linux_nat_forget_process_hook (pid);
}

/* Register a method that converts a siginfo object between the layout
   that ptrace returns, and the layout in the architecture of the
   inferior.  */
void
linux_nat_set_siginfo_fixup (struct target_ops *t,
			     int (*siginfo_fixup) (siginfo_t *,
						   gdb_byte *,
						   int))
{
  /* Save the pointer.  */
  linux_nat_siginfo_fixup = siginfo_fixup;
}

/* Register a method to call prior to resuming a thread.  */

void
linux_nat_set_prepare_to_resume (struct target_ops *t,
				 void (*prepare_to_resume) (struct lwp_info *))
{
  /* Save the pointer.  */
  linux_nat_prepare_to_resume = prepare_to_resume;
}

/* See linux-nat.h.  */

int
linux_nat_get_siginfo (ptid_t ptid, siginfo_t *siginfo)
{
  int pid;

  pid = ptid_get_lwp (ptid);
  if (pid == 0)
    pid = ptid_get_pid (ptid);

  errno = 0;
  ptrace (PTRACE_GETSIGINFO, pid, (PTRACE_TYPE_ARG3) 0, siginfo);
  if (errno != 0)
    {
      memset (siginfo, 0, sizeof (*siginfo));
      return 0;
    }
  return 1;
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_linux_nat;

void
_initialize_linux_nat (void)
{
  add_setshow_zuinteger_cmd ("lin-lwp", class_maintenance,
			     &debug_linux_nat, _("\
Set debugging of GNU/Linux lwp module."), _("\
Show debugging of GNU/Linux lwp module."), _("\
Enables printf debugging output."),
			     NULL,
			     show_debug_linux_nat,
			     &setdebuglist, &showdebuglist);

  /* Save this mask as the default.  */
  sigprocmask (SIG_SETMASK, NULL, &normal_mask);

  /* Install a SIGCHLD handler.  */
  sigchld_action.sa_handler = sigchld_handler;
  sigemptyset (&sigchld_action.sa_mask);
  sigchld_action.sa_flags = SA_RESTART;

  /* Make it the default.  */
  sigaction (SIGCHLD, &sigchld_action, NULL);

  /* Make sure we don't block SIGCHLD during a sigsuspend.  */
  sigprocmask (SIG_SETMASK, NULL, &suspend_mask);
  sigdelset (&suspend_mask, SIGCHLD);

  sigemptyset (&blocked_mask);
}


/* FIXME: kettenis/2000-08-26: The stuff on this page is specific to
   the GNU/Linux Threads library and therefore doesn't really belong
   here.  */

/* Read variable NAME in the target and return its value if found.
   Otherwise return zero.  It is assumed that the type of the variable
   is `int'.  */

static int
get_signo (const char *name)
{
  struct minimal_symbol *ms;
  int signo;

  ms = lookup_minimal_symbol (name, NULL, NULL);
  if (ms == NULL)
    return 0;

  if (target_read_memory (SYMBOL_VALUE_ADDRESS (ms), (gdb_byte *) &signo,
			  sizeof (signo)) != 0)
    return 0;

  return signo;
}

/* Return the set of signals used by the threads library in *SET.  */

void
lin_thread_get_thread_signals (sigset_t *set)
{
  struct sigaction action;
  int restart, cancel;

  sigemptyset (&blocked_mask);
  sigemptyset (set);

  restart = get_signo ("__pthread_sig_restart");
  cancel = get_signo ("__pthread_sig_cancel");

  /* LinuxThreads normally uses the first two RT signals, but in some legacy
     cases may use SIGUSR1/SIGUSR2.  NPTL always uses RT signals, but does
     not provide any way for the debugger to query the signal numbers -
     fortunately they don't change!  */

  if (restart == 0)
    restart = __SIGRTMIN;

  if (cancel == 0)
    cancel = __SIGRTMIN + 1;

  sigaddset (set, restart);
  sigaddset (set, cancel);

  /* The GNU/Linux Threads library makes terminating threads send a
     special "cancel" signal instead of SIGCHLD.  Make sure we catch
     those (to prevent them from terminating GDB itself, which is
     likely to be their default action) and treat them the same way as
     SIGCHLD.  */

  action.sa_handler = sigchld_handler;
  sigemptyset (&action.sa_mask);
  action.sa_flags = SA_RESTART;
  sigaction (cancel, &action, NULL);

  /* We block the "cancel" signal throughout this code ...  */
  sigaddset (&blocked_mask, cancel);
  sigprocmask (SIG_BLOCK, &blocked_mask, NULL);

  /* ... except during a sigsuspend.  */
  sigdelset (&suspend_mask, cancel);
}
@


1.271
log
@	* inf-child.c (inf_child_follow_fork) New parameter
	detach_fork.
	* inf-ptrace.c (inf_ptrace_follow_fork): Likewise.
	* inf-ttrace.c (inf_ttrace_follow_fork): Likewise.
	* inferior.h (detach_fork): Remove.
	* infrun.c (detach_fork): Adjust comment and make it
	static.
	(follow_fork): Pass detach_fork parameter to
	target_follow_fork.
	* linux-nat.c (linux_child_follow_fork): New parameter
	detach_fork.
	* target.c (target_follow_fork): New parameter detach_fork.
	Pass detach_fork as parameter and print its value.
	* target.h (struct target_ops) <to_follow_fork>: New int
	parameter.
	(target_follow_fork): New parameter detach_fork.
@
text
@d390 2
a391 1
  child_pid = PIDGET (inferior_thread ()->pending_follow.value.related_pid);
d432 1
a432 1
	      remove_breakpoints_pid (GET_PID (inferior_ptid));
d939 1
a939 1
  gdb_assert (is_lwp (ptid));
d1011 2
a1012 2
  if (is_lwp (ptid))
    lwp = GET_LWP (ptid);
d1014 1
a1014 1
    lwp = GET_PID (ptid);
d1017 1
a1017 1
    if (lwp == GET_LWP (lp->ptid))
d1059 1
a1059 1
  purge_lwp_list (GET_PID (inferior_ptid));
d1100 1
a1100 1
  pid_t new_pid, pid = GET_LWP (ptid);
d1178 1
a1178 1
  gdb_assert (is_lwp (ptid));
d1181 1
a1181 1
  lwpid = GET_LWP (ptid);
d1189 1
a1189 1
  if (lwpid != GET_PID (ptid) && lp == NULL)
d1257 1
a1257 1
      target_post_attach (GET_LWP (lp->ptid));
d1366 3
a1368 1
  ptid = BUILD_LWP (GET_PID (inferior_ptid), GET_PID (inferior_ptid));
d1406 1
a1406 1
		      status, (long) GET_LWP (ptid));
d1416 1
a1416 1
			(long) GET_PID (lp->ptid), status_to_str (status));
d1468 1
a1468 1
      if (GET_LWP (lp->ptid) == GET_LWP (last_ptid))
d1526 1
a1526 1
      kill_lwp (GET_LWP (lp->ptid), SIGCONT);
d1532 1
a1532 1
  if (GET_LWP (lp->ptid) != GET_PID (lp->ptid))
d1542 1
a1542 1
      if (ptrace (PTRACE_DETACH, GET_LWP (lp->ptid), 0,
d1566 1
a1566 1
  pid = GET_PID (inferior_ptid);
d1581 1
a1581 1
  gdb_assert (num_lwps (GET_PID (inferior_ptid)) == 1);
d1624 1
a1624 1
      struct inferior *inf = find_inferior_pid (GET_PID (lp->ptid));
d1648 1
a1648 1
				pid_to_ptid (GET_LWP (lp->ptid)),
d1801 1
a1801 1
  ptid = pid_to_ptid (GET_LWP (lp->ptid));
d1889 1
a1889 1
			    GET_LWP (lp->ptid));
d1892 1
a1892 1
      ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
d1921 1
a1921 1
				GET_LWP (lp->ptid));
d1932 1
a1932 1
			    GET_LWP (lp->ptid));
d1958 1
a1958 1
			    GET_LWP (lp->ptid));
d1974 1
a1974 1
  linux_ops->to_resume (linux_ops, pid_to_ptid (GET_LWP (lp->ptid)),
d1989 1
a1989 1
  int pid = GET_LWP (lp->ptid);
d2030 1
a2030 1
	  && linux_fork_checkpointing_p (GET_PID (lp->ptid)))
d2069 1
a2069 1
	  new_lp = add_lwp (BUILD_LWP (new_pid, GET_PID (lp->ptid)));
d2126 1
a2126 1
		  target_post_attach (GET_LWP (new_lp->ptid));
d2150 1
a2150 1
				    (long) GET_LWP (new_lp->ptid),
d2168 1
a2168 1
					GET_LWP (new_lp->ptid));
d2182 2
a2183 1
	  linux_ops->to_resume (linux_ops, pid_to_ptid (GET_LWP (lp->ptid)),
d2197 1
a2197 1
			    GET_LWP (lp->ptid));
d2214 1
a2214 1
				GET_LWP (lp->ptid));
d2224 2
a2225 2
			    GET_LWP (lp->ptid));
      ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
d2255 1
a2255 1
      pid = my_waitpid (GET_LWP (lp->ptid), &status, WNOHANG);
d2257 1
a2257 1
	pid = my_waitpid (GET_LWP (lp->ptid), &status, __WCLONE | WNOHANG);
d2288 2
a2289 2
      if (GET_PID (lp->ptid) == GET_LWP (lp->ptid)
	  && linux_proc_pid_is_zombie (GET_LWP (lp->ptid)))
d2313 1
a2313 1
      gdb_assert (pid == GET_LWP (lp->ptid));
d2383 1
a2383 1
      ret = kill_lwp (GET_LWP (lp->ptid), SIGSTOP);
d2451 1
a2451 1
  if (!linux_nat_has_pending_sigint (GET_LWP (lp->ptid)))
d2571 1
a2571 1
  struct inferior *inf = find_inferior_pid (GET_PID (lp->ptid));
d2592 1
a2592 1
	  ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
d2880 1
a2880 1
				    GET_LWP (lp->ptid));
d2889 1
a2889 1
				    GET_LWP (lp->ptid));
d2898 1
a2898 1
				    GET_LWP (lp->ptid));
d2943 1
a2943 1
      lp = add_lwp (BUILD_LWP (lwpid, lwpid));
d2990 1
a2990 1
      && num_lwps (GET_PID (lp->ptid)) > 1)
d3002 1
a3002 1
      if (GET_PID (lp->ptid) == GET_LWP (lp->ptid))
d3005 1
a3005 1
	  iterate_over_lwps (pid_to_ptid (GET_PID (lp->ptid)),
d3014 1
a3014 1
      if (num_lwps (GET_PID (lp->ptid)) > 1)
d3028 1
a3028 1
  if (num_lwps (GET_PID (lp->ptid)) > 1 && !linux_thread_alive (lp->ptid))
d3030 1
a3030 1
      ptid_t ptid = pid_to_ptid (GET_PID (lp->ptid));
d3066 3
a3068 2
	  linux_ops->to_resume (linux_ops, pid_to_ptid (GET_LWP (lp->ptid)),
			    lp->step, GDB_SIGNAL_0);
d3100 1
a3100 1
      linux_ops->to_resume (linux_ops, pid_to_ptid (GET_LWP (lp->ptid)),
d3207 2
a3208 2
			  BUILD_LWP (GET_PID (inferior_ptid),
				     GET_PID (inferior_ptid)));
d3235 1
a3235 1
  else if (is_lwp (ptid))
d3479 2
a3480 1
	  linux_ops->to_resume (linux_ops, pid_to_ptid (GET_LWP (lp->ptid)),
d3638 1
a3638 1
      linux_ops->to_resume (linux_ops, pid_to_ptid (GET_LWP (lp->ptid)),
d3704 1
a3704 1
  kill (GET_LWP (lp->ptid), SIGKILL);
d3714 1
a3714 1
  ptrace (PTRACE_KILL, GET_LWP (lp->ptid), 0, 0);
d3740 1
a3740 1
	  pid = my_waitpid (GET_LWP (lp->ptid), NULL, __WCLONE);
d3755 1
a3755 1
      while (pid == GET_LWP (lp->ptid));
d3762 1
a3762 1
      pid = my_waitpid (GET_LWP (lp->ptid), NULL, 0);
d3773 1
a3773 1
  while (pid == GET_LWP (lp->ptid));
d3795 1
a3795 1
      ptrace (PT_KILL, PIDGET (last.value.related_pid), 0, 0);
d3800 1
a3800 1
      linux_nat_forget_process (PIDGET (last.value.related_pid));
d3880 1
a3880 1
  pid = GET_LWP (inferior_ptid);
d3882 1
a3882 1
    pid = GET_PID (inferior_ptid);
d3942 2
a3943 2
  if (is_lwp (inferior_ptid))
    inferior_ptid = pid_to_ptid (GET_LWP (inferior_ptid));
d3957 1
a3957 1
  gdb_assert (is_lwp (ptid));
d3962 1
a3962 1
  err = kill_lwp (GET_LWP (ptid), 0);
d3987 3
a3989 3
  if (is_lwp (ptid)
      && (GET_PID (ptid) != GET_LWP (ptid)
	  || num_lwps (GET_PID (ptid)) > 1))
d3991 1
a3991 1
      snprintf (buf, sizeof (buf), "LWP %ld", GET_LWP (ptid));
d4135 1
a4135 1
  sprintf (filename, "/proc/%d/mem", PIDGET (inferior_ptid));
d4219 1
a4219 1
  int pid = PIDGET (inferior_ptid);
d4782 2
a4783 2
  pid = GET_LWP (ptid);
  if (GET_LWP (ptid) == 0)
d4788 1
a4788 1
      pid = GET_PID (lwp->ptid);
d4793 1
a4793 1
      pid = GET_PID (ptid);
d4938 1
a4938 1
  pid = GET_LWP (ptid);
d4940 1
a4940 1
    pid = GET_PID (ptid);
@


1.270
log
@	Unify ptrace options discovery code and make both GDB and
	gdbserver use it.

	gdb/
	* Makefile.in (HFILES_NO_SRCDIR): Add nat/linux-nat.h and
	nat/linux-waitpid.h.
	(linux-waitpid.o): New object file rule.
	* common/linux-ptrace.c: Include nat/linux-waitpid.h.
	(current_ptrace_options): Moved from linux-nat.c.
	(linux_ptrace_test_ret_to_nx): Use type casts for ptrace
	parameters.
	(linux_fork_to_function): New function.
	(linux_grandchild_function): Likewise.
	(linux_child_function): Likewise.
	(linux_check_ptrace_features): New function, heavily
	based on linux-nat.c:linux_test_for_tracefork.
	(linux_enable_event_reporting): New function.
	(ptrace_supports_feature): Likewise.
	(linux_supports_tracefork): Likewise.
	(linux_supports_traceclone): Likewise.
	(linux_supports_tracevforkdone): Likewise.
	(linux_supports_tracesysgood): Likewise.
	* common/linux-ptrace.h (HAS_NOMMU): Moved from
	gdbserver/linux-low.c.
	(linux_enable_event_reporting): New declaration.
	(linux_supports_tracefork): Likewise.
	(linux_supports_traceclone): Likewise.
	(linux_supports_tracevforkdone): Likewise.
	(linux_supports_tracesysgood): Likewise.
	* config.in (PTRACE_TYPE_ARG4): Regenerate.
	* config/aarch64/linux.mh (NATDEPFILES): Add linux-waitpid.o.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Likewise.
	* config/arm/linux.mh (NATDEPFILES): Likewise.
	* config/i386/linux.mh (NATDEPFILES): Likewise.
	* config/i386/linux64.mh (NATDEPFILES): Likewise.
	* config/ia64/linux.mh (NATDEPFILES): Likewise.
	* config/m32r/linux.mh (NATDEPFILES): Likewise.
	* config/m68k/linux.mh (NATDEPFILES): Likewise.
	* config/mips/linux.mh (NATDEPFILES): Likewise.
	* config/pa/linux.mh (NATDEPFILES): Likewise..
	* config/powerpc/linux.mh (NATDEPFILES): Likewise..
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/spu-linux.mh (NATDEPFILES): Likewise.
	* config/sparc/linux.mh (NATDEPFILES): Likewise.
	* config/sparc/linux64.mh (NATDEPFILES): Likewise.
	* config/tilegx/linux.mh (NATDEPFILES): Likewise.
	* config/xtensa/linux.mh (NATDEPFILES): Likewise.
	* configure.ac (AC_CACHE_CHECK): Add void * to the list of
	ptrace's 4th argument's types.
	Check the type of PTRACE_TYPE_ARG4.
	* configure: Regenerate.
	* linux-nat.c: Include nat/linux-nat.h and nat/linux-waitpid.h.
	(SYSCALL_SIGTRAP): Moved to nat/linux-nat.h.
	(linux_supports_tracefork_flag): Remove.
	(linux_supports_tracesysgood_flag): Likewise.
	(linux_supports_tracevforkdone_flag): Likewise.
	(current_ptrace_options): Moved to
	common/linux-ptrace.c.
	(linux_tracefork_child): Remove.
	(my_waitpid): Remove.
	(linux_test_for_tracefork): Renamed to
	linux_check_ptrace_features and moved to common/linux-ptrace.c.
	(linux_test_for_tracesysgood): Remove.
	(linux_supports_tracesysgood): Remove.
	(linux_supports_tracefork): Remove.
	(linux_supports_tracevforkdone): Remove.
	(linux_enable_tracesysgood): Remove.
	(linux_enable_event_reporting): Remove.
	(linux_init_ptrace): New function.
	(linux_child_post_attach): Call linux_init_ptrace.
	(linux_child_post_startup_inferior): Call linux_init_ptrace.
	(linux_child_follow_fork): Call linux_supports_tracefork
	and linux_supports_tracevforkdone.
	(linux_child_insert_fork_catchpoint): Call
	linux_supports_tracefork.
	(linux_child_insert_vfork_catchpoint): Likewise.
	(linux_child_set_syscall_catchpoint): Call
	linux_supports_tracesysgood.
	(lin_lwp_attach_lwp): Call linux_supports_tracefork.
	* nat/linux-nat.h: New file.
	* nat/linux-waitpid.c: New file.
	* nat/linux-waitpid.h: New file.

	gdb/gdbserver/
	* Makefile.in: Explain why ../target and ../nat are not
	listed as include file search paths.
	(linux-waitpid.o): New object file rule.
	* configure.srv (srv_native_linux_obj): New variable.
	Replace all occurrences of linux native object files with
	$srv_native_linux_obj.
	* linux-low.c: Include nat/linux-nat.h and nat/linux-waitpid.h.
	(HAS_NOMMU): Move defining logic to common/linux-ptrace.c.
	(linux_enable_event_reporting): Remove declaration.
	(my_waitpid): Moved to common/linux-waitpid.c.
	(linux_wait_for_event): Pass ptid when calling
	linux_enable_event_reporting.
	(linux_supports_tracefork_flag): Remove.
	(linux_enable_event_reporting): Likewise.
	(linux_tracefork_grandchild): Remove.
	(STACK_SIZE): Moved to common/linux-ptrace.c.
	(linux_tracefork_child): Remove.
	(linux_test_for_tracefork): Remove.
	(linux_look_up_symbols): Call linux_supports_traceclone.
	(initialize_low): Remove call to linux_test_for_tracefork.
	* linux-low.h (PTRACE_TYPE_ARG3): Move to
	common/linux-ptrace.h.
	(PTRACE_TYPE_ARG4): Likewise.
	Include linux-ptrace.h.
@
text
@d379 2
a380 1
linux_child_follow_fork (struct target_ops *ops, int follow_child)
@


1.269
log
@linux-nat.c: no need to block child signals so aggressively.

In http://sourceware.org/ml/gdb-patches/2013-08/msg00174.html , the
issue of child signal handling around ptrace option support discovery
being different between GDB and GDBserver came up.

I recalled adding these block_child_signals calls, and the "We don't
want those ptrace calls to be interrupted" comment, but not exactly
why.  So I looked into it.  My first guess is that I got confused.
The patch that added this
<http://sourceware.org/ml/gdb-patches/2009-04/msg00125.html> rewrote
the linux native async support completely, and the old async support
code had the SIGCHLD handler itself do waitpid, so in places that we'd
want a blocking waitpid, we'd have to have the signal handler blocked.
That was probably the mindset I had at the time.  Anyway, whatever the
case, looks like I was wrong on the need for this blocking.
Given GDBserver doesn't block like this, I investigated why this is
currently needed on GDB but not on GDBserver.

I removed the block_child_signals (and restore) calls, and hacked
linux-nat.c to call linux_test_for_tracefork in a loop, like:

 @@@@ -534,7 +534,10 @@@@ static int
  linux_supports_tracefork (int pid)
  {
    if (linux_supports_tracefork_flag == -1)
 -    linux_test_for_tracefork (pid);
 +    {
 +      while (1)
 +       linux_test_for_tracefork (pid);
 +    }
    return linux_supports_tracefork_flag;
  }

Running the resulting GDB, I then saw bad things happening.
Specifically, I'd end up with a bunch of zombies, and eventually, the
machine would refuse to spawn new processes, claming insufficient
resources.

The issue is that linux_test_for_tracefork test forks, and has the
child fork again.  If we don't block SIGCHLD on entry to the function,
the children will inherit SIGCHLD's action/disposition (meaning,
SIGCHLD will be unblocked in the child).  When the first child forks
again a second child, and that child exits, the first child gets a
SIGCHLD.  Now, when we try to wrap up for the whole options test, we
kill the first child, and collect the waitstatus.  Here, when SIGCHLD
isn't blocked, GDB will first see the child reporting a stop with
SIGCHLD.  gdbserver's ptrace options test does a PTRACE_KILL loop at
the end, which catches the SIGCHLD, and retries the kill.  The GDB
version did not do that.  So the GDB version would proceed, leaving
the child zombie (until GDB exists), as nothing collected its final
waitstatus.

So this patch makes the GDB version of linux_test_for_tracefork do the
exact same as the GDBserver version, removes all this unnecessary
blocking throughout, and adds a couple comments at places that do need
it -- namely: places where we'll use sleep with sigsuspend; and
linux_async_pipe, as that destroys the pipe the signal handler
touches.

Tested on x86_64 Fedora 17, sync and async.

gdb/
2013-08-19  Pedro Alves  <palves@@redhat.com>

	* linux-nat.c (linux_test_for_tracefork)
	(linux_test_for_tracesysgood, linux_child_follow_fork)
	(lin_lwp_attach_lwp, linux_nat_resume): Don't block child signals.
	(linux_nat_wait_1): Extend comment.
	(linux_async_pipe): Add comment.
@
text
@d23 2
a175 5
/* Unlike other extended result codes, WSTOPSIG (status) on
   PTRACE_O_TRACESYSGOOD syscall events doesn't return SIGTRAP, but
   instead SIGTRAP with bit 7 set.  */
#define SYSCALL_SIGTRAP (SIGTRAP | 0x80)

a225 18
/* This variable is a tri-state flag: -1 for unknown, 0 if PTRACE_O_TRACEFORK
   can not be used, 1 if it can.  */

static int linux_supports_tracefork_flag = -1;

/* This variable is a tri-state flag: -1 for unknown, 0 if
   PTRACE_O_TRACESYSGOOD can not be used, 1 if it can.  */

static int linux_supports_tracesysgood_flag = -1;

/* If we have PTRACE_O_TRACEFORK, this flag indicates whether we also have
   PTRACE_O_TRACEVFORKDONE.  */

static int linux_supports_tracevforkdone_flag = -1;

/* Stores the current used ptrace() options.  */
static int current_ptrace_options = 0;

d331 2
a332 2

/* A helper function for linux_test_for_tracefork, called after fork ().  */
d335 1
a335 1
linux_tracefork_child (void)
d337 2
a338 216
  ptrace (PTRACE_TRACEME, 0, 0, 0);
  kill (getpid (), SIGSTOP);
  fork ();
  _exit (0);
}

/* Wrapper function for waitpid which handles EINTR.  */

static int
my_waitpid (int pid, int *statusp, int flags)
{
  int ret;

  do
    {
      ret = waitpid (pid, statusp, flags);
    }
  while (ret == -1 && errno == EINTR);

  return ret;
}

/* Determine if PTRACE_O_TRACEFORK can be used to follow fork events.

   First, we try to enable fork tracing on ORIGINAL_PID.  If this fails,
   we know that the feature is not available.  This may change the tracing
   options for ORIGINAL_PID, but we'll be setting them shortly anyway.

   However, if it succeeds, we don't know for sure that the feature is
   available; old versions of PTRACE_SETOPTIONS ignored unknown options.  We
   create a child process, attach to it, use PTRACE_SETOPTIONS to enable
   fork tracing, and let it fork.  If the process exits, we assume that we
   can't use TRACEFORK; if we get the fork notification, and we can extract
   the new child's PID, then we assume that we can.  */

static void
linux_test_for_tracefork (int original_pid)
{
  int child_pid, ret, status;
  long second_pid;

  linux_supports_tracefork_flag = 0;
  linux_supports_tracevforkdone_flag = 0;

  ret = ptrace (PTRACE_SETOPTIONS, original_pid, 0, PTRACE_O_TRACEFORK);
  if (ret != 0)
    return;

  child_pid = fork ();
  if (child_pid == -1)
    perror_with_name (("fork"));

  if (child_pid == 0)
    linux_tracefork_child ();

  ret = my_waitpid (child_pid, &status, 0);
  if (ret == -1)
    perror_with_name (("waitpid"));
  else if (ret != child_pid)
    error (_("linux_test_for_tracefork: waitpid: unexpected result %d."), ret);
  if (! WIFSTOPPED (status))
    error (_("linux_test_for_tracefork: waitpid: unexpected status %d."),
	   status);

  ret = ptrace (PTRACE_SETOPTIONS, child_pid, 0, PTRACE_O_TRACEFORK);
  if (ret != 0)
    {
      ret = ptrace (PTRACE_KILL, child_pid, 0, 0);
      if (ret != 0)
	{
	  warning (_("linux_test_for_tracefork: failed to kill child"));
	  return;
	}

      ret = my_waitpid (child_pid, &status, 0);
      if (ret != child_pid)
	warning (_("linux_test_for_tracefork: failed "
		   "to wait for killed child"));
      else if (!WIFSIGNALED (status))
	warning (_("linux_test_for_tracefork: unexpected "
		   "wait status 0x%x from killed child"), status);

      return;
    }

  /* Check whether PTRACE_O_TRACEVFORKDONE is available.  */
  ret = ptrace (PTRACE_SETOPTIONS, child_pid, 0,
		PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORKDONE);
  linux_supports_tracevforkdone_flag = (ret == 0);

  ret = ptrace (PTRACE_CONT, child_pid, 0, 0);
  if (ret != 0)
    warning (_("linux_test_for_tracefork: failed to resume child"));

  ret = my_waitpid (child_pid, &status, 0);

  if (ret == child_pid && WIFSTOPPED (status)
      && status >> 16 == PTRACE_EVENT_FORK)
    {
      second_pid = 0;
      ret = ptrace (PTRACE_GETEVENTMSG, child_pid, 0, &second_pid);
      if (ret == 0 && second_pid != 0)
	{
	  int second_status;

	  linux_supports_tracefork_flag = 1;
	  my_waitpid (second_pid, &second_status, 0);
	  ret = ptrace (PTRACE_KILL, second_pid, 0, 0);
	  if (ret != 0)
	    warning (_("linux_test_for_tracefork: "
		       "failed to kill second child"));
	  my_waitpid (second_pid, &status, 0);
	}
    }
  else
    warning (_("linux_test_for_tracefork: unexpected result from waitpid "
	     "(%d, status 0x%x)"), ret, status);

  do
    {
      ret = ptrace (PTRACE_KILL, child_pid, 0, 0);
      if (ret != 0)
	warning ("linux_test_for_tracefork: failed to kill child");
      my_waitpid (child_pid, &status, 0);
    }
  while (WIFSTOPPED (status));
}

/* Determine if PTRACE_O_TRACESYSGOOD can be used to follow syscalls.

   We try to enable syscall tracing on ORIGINAL_PID.  If this fails,
   we know that the feature is not available.  This may change the tracing
   options for ORIGINAL_PID, but we'll be setting them shortly anyway.  */

static void
linux_test_for_tracesysgood (int original_pid)
{
  int ret;

  linux_supports_tracesysgood_flag = 0;

  ret = ptrace (PTRACE_SETOPTIONS, original_pid, 0, PTRACE_O_TRACESYSGOOD);
  if (ret != 0)
    return;

  linux_supports_tracesysgood_flag = 1;
}

/* Determine wether we support PTRACE_O_TRACESYSGOOD option available.
   This function also sets linux_supports_tracesysgood_flag.  */

static int
linux_supports_tracesysgood (int pid)
{
  if (linux_supports_tracesysgood_flag == -1)
    linux_test_for_tracesysgood (pid);
  return linux_supports_tracesysgood_flag;
}

/* Return non-zero iff we have tracefork functionality available.
   This function also sets linux_supports_tracefork_flag.  */

static int
linux_supports_tracefork (int pid)
{
  if (linux_supports_tracefork_flag == -1)
    linux_test_for_tracefork (pid);
  return linux_supports_tracefork_flag;
}

static int
linux_supports_tracevforkdone (int pid)
{
  if (linux_supports_tracefork_flag == -1)
    linux_test_for_tracefork (pid);
  return linux_supports_tracevforkdone_flag;
}

static void
linux_enable_tracesysgood (ptid_t ptid)
{
  int pid = ptid_get_lwp (ptid);

  if (pid == 0)
    pid = ptid_get_pid (ptid);

  if (linux_supports_tracesysgood (pid) == 0)
    return;

  current_ptrace_options |= PTRACE_O_TRACESYSGOOD;

  ptrace (PTRACE_SETOPTIONS, pid, 0, current_ptrace_options);
}


void
linux_enable_event_reporting (ptid_t ptid)
{
  int pid = ptid_get_lwp (ptid);

  if (pid == 0)
    pid = ptid_get_pid (ptid);

  if (! linux_supports_tracefork (pid))
    return;

  current_ptrace_options |= PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK
    | PTRACE_O_TRACEEXEC | PTRACE_O_TRACECLONE;

  if (linux_supports_tracevforkdone (pid))
    current_ptrace_options |= PTRACE_O_TRACEVFORKDONE;

  /* Do not enable PTRACE_O_TRACEEXIT until GDB is more prepared to support
     read-only process state.  */

  ptrace (PTRACE_SETOPTIONS, pid, 0, current_ptrace_options);
d344 1
a344 3
  linux_enable_event_reporting (pid_to_ptid (pid));
  linux_enable_tracesysgood (pid_to_ptid (pid));
  linux_ptrace_init_warnings ();
d350 1
a350 3
  linux_enable_event_reporting (ptid);
  linux_enable_tracesysgood (ptid);
  linux_ptrace_init_warnings ();
d536 1
a536 1
	  gdb_assert (linux_supports_tracefork_flag >= 0);
d538 1
a538 1
	  if (linux_supports_tracevforkdone (0))
d709 1
a709 1
  return !linux_supports_tracefork (pid);
d721 1
a721 1
  return !linux_supports_tracefork (pid);
d733 1
a733 1
  return !linux_supports_tracefork (pid);
d746 1
a746 1
  if (!linux_supports_tracesysgood (pid))
d1193 1
a1193 1
	  if (linux_supports_tracefork_flag)
@


1.268
log
@Normalize on PATH_MAX instead of MAXPATHLEN throughout.

With the pathmax gnulib module in place, we can use PATH_MAX
consistently throughout, instead of the current mixbag of PATH_MAX and
MAXPATHLEN uses.  It's no longer necessary to include sys/param.h
(supposedly, I can't check all ports touched here) for MAXPATHLEN.

Don't remove sys/param.h from GDB's configure.ac, as later tests in
the file use HAVE_SYS_PARAM_H checks.

Tested on x86_64 Fedora 17.

Also cross-built for --host=i686-w64-mingw32, and --host=i586-pc-msdosdjgpp.

gdb/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* defs.h: Include "pathmax.h".
	* utils.c: Don't include sys/param.h.
	(gdb_realpath): Remove code that checks for MAXPATHLEN.
	* solib-ia64-hpux.c (ia64_hpux_handle_load_event): Use PATH_MAX
	instead of MAXPATHLEN.
	* solib-sunos.c: Don't include sys/param.h.
	* xcoffread.c: Don't include sys/param.h.
	* bsd-kvm.c: Don't include sys/param.h.
	* darwin-nat.c: Don't include sys/param.h.
	(darwin_pid_to_exec_file): Use PATH_MAX instead of MAXPATHLEN.
	* darwin-nat-info.c: Don't include sys/param.h.
	* fbsd-nat.c (fbsd_pid_to_exec_file): Use PATH_MAX instead of
	MAXPATHLEN.
	* i386obsd-nat.c: Don't include sys/param.h.
	* inf-child.c: Don't include sys/param.h.
	(inf_child_fileio_readlink): Use PATH_MAX instead of MAXPATHLEN.
	* linux-fork.c: Don't include sys/param.h.
	(fork_save_infrun_state): Use PATH_MAX instead of MAXPATHLEN.
	* linux-nat.c: Don't include sys/param.h.
	(linux_child_pid_to_exec_file, linux_proc_pending_signals)
	(linux_proc_pending_signals): Use PATH_MAX instead of MAXPATHLEN.
	* m68klinux-nat.c: Don't include sys/param.h.
	* nbsd-nat.c: Don't include sys/param.h.
	(nbsd_pid_to_exec_file): Use PATH_MAX instead of MAXPATHLEN.
	* ppc-linux-nat.c: Don't include sys/param.h.
	* rs6000-nat.c: Don't include sys/param.h.
	* spu-linux-nat.c. Don't include sys/param.h.
	* windows-nat.c: Don't include sys/param.h.
	* xtensa-linux-nat.c: Don't include sys/param.h.
	* config/i386/nm-fbsd.h: Don't include sys/param.h.

gdb/gdbserver/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* server.h: Include "pathmax.h".
	* linux-low.c: Don't include sys/param.h.
	(linux_pid_exe_is_elf_64_file): Use PATH_MAX instead of
	MAXPATHLEN.
	* win32-low.c: Don't include sys/param.h.
	(win32_create_inferior): Use PATH_MAX instead of MAXPATHLEN.
@
text
@a397 4
  sigset_t prev_mask;

  /* We don't want those ptrace calls to be interrupted.  */
  block_child_signals (&prev_mask);
d404 1
a404 4
    {
      restore_child_signals_mask (&prev_mask);
      return;
    }
a428 1
	  restore_child_signals_mask (&prev_mask);
a439 1
      restore_child_signals_mask (&prev_mask);
d476 8
a483 6
  ret = ptrace (PTRACE_KILL, child_pid, 0, 0);
  if (ret != 0)
    warning (_("linux_test_for_tracefork: failed to kill child"));
  my_waitpid (child_pid, &status, 0);

  restore_child_signals_mask (&prev_mask);
a495 4
  sigset_t prev_mask;

  /* We don't want those ptrace calls to be interrupted.  */
  block_child_signals (&prev_mask);
d501 1
a501 1
    goto out;
a503 2
out:
  restore_child_signals_mask (&prev_mask);
a619 1
  sigset_t prev_mask;
a622 2
  block_child_signals (&prev_mask);

a940 1
  restore_child_signals_mask (&prev_mask);
a1412 1
  sigset_t prev_mask;
a1416 2
  block_child_signals (&prev_mask);

a1443 1
		  restore_child_signals_mask (&prev_mask);
a1459 2

		      restore_child_signals_mask (&prev_mask);
a1471 1
	  restore_child_signals_mask (&prev_mask);
d1482 1
a1482 4
	{
	  restore_child_signals_mask (&prev_mask);
	  return 1;
	}
a1517 1
  restore_child_signals_mask (&prev_mask);
a1949 1
  sigset_t prev_mask;
a1961 2
  block_child_signals (&prev_mask);

a2018 1
      restore_child_signals_mask (&prev_mask);
a2050 1
  restore_child_signals_mask (&prev_mask);
d3447 1
a3447 1
  /* Make sure SIGCHLD is blocked.  */
d4877 2
@


1.267
log
@	PR gdb/7912:
	* Makefile.in (SFILES): Add filestuff.c
	(COMMON_OBS): Add filestuff.o.
	(filestuff.o): New target.
	* auto-load.c (auto_load_objfile_script_1): Use
	gdb_fopen_cloexec.
	* auxv.c (procfs_xfer_auxv): Use gdb_open_cloexec.
	* cli/cli-cmds.c (shell_escape): Call close_most_fds.
	* cli/cli-dump.c (fopen_with_cleanup): Use gdb_fopen_cloexec.
	* common/agent.c (gdb_connect_sync_socket): Use
	gdb_socket_cloexec.
	* common/filestuff.c: New file.
	* common/filestuff.h: New file.
	* common/linux-osdata.c (linux_common_core_of_thread)
	(command_from_pid, commandline_from_pid, print_source_lines)
	(linux_xfer_osdata_shm, linux_xfer_osdata_sem)
	(linux_xfer_osdata_msg, linux_xfer_osdata_modules): Use
	gdb_fopen_cloexec.
	* common/linux-procfs.c (linux_proc_get_int)
	(linux_proc_pid_has_state): Use gdb_fopen_cloexec.
	* config.in, configure: Rebuild.
	* configure.ac: Don't check for sys/socket.h.  Check for
	fdwalk, pipe2.
	* corelow.c (core_open): Use gdb_open_cloexec.
	* dwarf2read.c (write_psymtabs_to_index): Use gdb_fopen_cloexec.
	* fork-child.c (fork_inferior): Call close_most_fds.
	* gdb_bfd.c (gdb_bfd_open): Use gdb_open_cloexec.
	* inf-child.c (inf_child_fileio_readlink): Use gdb_open_cloexec.
	* linux-nat.c (linux_nat_thread_name, linux_proc_pending_signals):
	Use gdb_fopen_cloexec.
	(linux_proc_xfer_partial, linux_proc_xfer_spu): Use
	gdb_open_cloexec.
	(linux_async_pipe): Use gdb_pipe_cloexec.
	* remote-fileio.c (remote_fileio_func_open): Use
	gdb_open_cloexec.
	* remote.c (remote_file_put, remote_file_get): Use
	gdb_fopen_cloexec.
	* ser-pipe.c (pipe_open): Use gdb_socketpair_cloexec,
	close_most_fds.
	* ser-tcp.c (net_open): Use gdb_socket_cloexec.
	* ser-unix.c (hardwire_open): Use gdb_open_cloexec.
	* solib.c (solib_find): Use gdb_open_cloexec.
	* source.c (openp, find_and_open_source): Use gdb_open_cloexec.
	* tracepoint.c (tfile_start): Use gdb_fopen_cloexec.
	(tfile_open): Use gdb_open_cloexec.
	* tui/tui-io.c (tui_initialize_io): Use gdb_pipe_cloexec.
	* ui-file.c (gdb_fopen): Use gdb_fopen_cloexec.
	* xml-support.c (xml_fetch_content_from_file): Use
	gdb_fopen_cloexec.
	* main.c (captured_main): Call notice_open_fds.
gdbserver
	* Makefile.in (SFILES): Add filestuff.c.
	(OBS): Add filestuff.o.
	(filestuff.o): New target.
	* config.in, configure: Rebuild.
	* configure.ac: Check for fdwalk, pipe2.
@
text
@a41 1
#include <sys/param.h>		/* for MAXPATHLEN */
d4308 2
a4309 2
  name1 = xmalloc (MAXPATHLEN);
  name2 = xmalloc (MAXPATHLEN);
d4312 1
a4312 1
  memset (name2, 0, MAXPATHLEN);
d4315 1
a4315 1
  if (readlink (name1, name2, MAXPATHLEN - 1) > 0)
d4564 1
a4564 1
  char buffer[MAXPATHLEN], fname[MAXPATHLEN];
d4576 1
a4576 1
  while (fgets (buffer, MAXPATHLEN, procfile) != NULL)
@


1.266
log
@Linux: No need to set ptrace event options in fork/clone children.

Oleg Nesterov told me that the Linux kernel copies the parent's ptrace
options to fork/clone children, so there's no need for GDB to do that
manually.

I was actually a bit surprised, since I thought the ptracer had to
always set the ptrace options itself, and GDB is indeed calling
PTRACE_SETOPTIONS for each new fork child, if it'll stay attached.

Looking at the history of that code, I found that is was actually I
who added that set-ptrace-options-in-children bit, back in
http://sourceware.org/ml/gdb-patches/2009-05/msg00656.html.  But,
honestly, I don't recall why I needed that.  I think I may have just
blindly believed it was necessary.

I then looked back at the history of all the PTRACE_SETOPTIONS code we
have, and found that gdb never did copy the ptrace options before my
patch.  But, when gdbserver learnt to use PTRACE_EVENT_CLONE, at
http://sourceware.org/ml/gdb-patches/2007-10/msg00547.html, it was
made to do 'ptrace (PTRACE_SETOPTIONS, new_pid, 0,
PTRACE_O_TRACECLONE)' for all new clones.  Hmmm.  But, GDB itself
never did that, so it can't really ever have been necessary, I
believe, otherwise GDB should have been doing it too.

(GDBserver doesn't support following forks, and so naturally doesn't
do any PTRACE_SETOPTIONS on fork children.)

So this patch removes the -I believe- unnecessary ptrace syscalls.

Tested on x86_64 Fedora 17, native/gdbserver, and on x86_64 RHEL5
native/gdbserver (Linux 2.6.18, I think a ptrace-on-utrace kernel).
No regressions.

gdb/
2013-03-22  Pedro Alves  <palves@@redhat.com>

	* linux-nat.c (linux_child_follow_fork): Don't call
	linux_enable_event_reporting.
	(linux_handle_extended_wait): Don't call
	linux_enable_event_reporting.

gdb/gdbserver/
2013-03-22  Pedro Alves  <palves@@redhat.com>

	* linux-low.c (handle_extended_wait): Don't call
	linux_enable_event_reporting.
@
text
@d70 1
d4275 1
a4275 1
  comm_file = fopen (buf, "r");
d4402 1
a4402 1
  fd = open (filename, O_RDONLY | O_LARGEFILE);
d4496 1
a4496 1
  fd = open (buf, writebuf? O_WRONLY : O_RDONLY);
d4572 1
a4572 1
  procfile = fopen (fname, "r");
d4915 1
a4915 1
	  if (pipe (linux_nat_event_pipe) == -1)
@


1.265
log
@gdb/
	Code cleanup.
	* bfd-target.c (target_bfd_xclose): Remove parameter quitting.
	* bsd-kvm.c (bsd_kvm_close): Likewise.
	* bsd-uthread.c (bsd_uthread_close): Likewise.
	* corelow.c (core_close): Likewise.
	(core_close_cleanup): Remove parameter quitting from a caller.
	* event-top.c (async_disconnect): Likewise.
	* exec.c (exec_close_1): Remove parameter quitting.
	* go32-nat.c (go32_close): Likewise.
	* linux-nat.c (linux_nat_close): Remove parameter quitting.  Remove
	parameter quitting from a caller.
	* mips-linux-nat.c (super_close): Remove parameter quitting from the
	variable.
	(mips_linux_close): Remove parameter quitting.  Remove parameter
	quitting from a caller.
	* monitor.c (monitor_close): Remove parameter quitting.
	* monitor.h (monitor_close): Likewise.
	* record-btrace.c (record_btrace_close): Likewise.
	* record-full.c (record_full_close): Likewise.
	* remote-m32r-sdi.c (m32r_close): Remove parameter quitting and remove
	it also from fprintf_unfiltered.
	* remote-mips.c (mips_close): Remove parameter quitting.
	(mips_detach): Remove parameter quitting from a caller.
	* remote-sim.c (gdbsim_close): Remove parameter quitting.
	(gdbsim_close): Remove duplicate function comment.  Remove parameter
	quitting and remove it also from printf_filtered.
	* remote.c (remote_close): Remove parameter quitting.
	* solib-svr4.c (enable_break): Remove parameter quitting from a caller.
	* target.c (update_current_target): Remove parameter int from to_close
	de_fault.
	(push_target, unpush_target, pop_target): Remove parameter quitting from
	a caller.
	(pop_all_targets_above, pop_all_targets): Remove parameter quitting.
	Remove parameter quitting from a caller.
	(target_preopen): Remove parameter quitting from a caller.
	(target_close): Remove parameter quitting.  Remove parameter quitting
	from a caller two times.  Remove parameter quitting also from
	fprintf_unfiltered.
	* target.h (struct target_ops): Remove parameter quitting and as int
	from fields to_xclose and to_close.
	(extern struct target_ops current_target):
	(target_close, pop_all_targets): Remove parameter quitting.  Update the
	comment.
	(pop_all_targets_above): Remove parameter quitting.
	* top.c (quit_target): Remove parameter quitting from a caller.
	* tracepoint.c (tfile_close): Remove parameter quitting.
	* windows-nat.c (windows_close): Remove parameter quitting.
@
text
@a645 3
  if (!detach_fork)
    linux_enable_event_reporting (pid_to_ptid (child_pid));

a2315 1
	  linux_enable_event_reporting (pid_to_ptid (new_pid));
@


1.264
log
@[native x86 GNU/Linux] Access debug register mirror from the corresponding process.

While reviewing the native AArch64 patch, I noticed a problem:

On 02/06/2013 08:46 PM, Pedro Alves wrote:
>
>> > +static void
>> > +aarch64_linux_prepare_to_resume (struct lwp_info *lwp)
>> > +{
>> > +  struct arch_lwp_info *info = lwp->arch_private;
>> > +
>> > +  /* NULL means this is the main thread still going through the shell,
>> > +     or, no watchpoint has been set yet.  In that case, there's
>> > +     nothing to do.  */
>> > +  if (info == NULL)
>> > +    return;
>> > +
>> > +  if (DR_HAS_CHANGED (info->dr_changed_bp)
>> > +      || DR_HAS_CHANGED (info->dr_changed_wp))
>> > +    {
>> > +      int tid = GET_LWP (lwp->ptid);
>> > +      struct aarch64_debug_reg_state *state = aarch64_get_debug_reg_state ();
> Hmm.  This is always fetching the debug_reg_state of
> the current inferior, but may not be the inferior of lwp.
> I see the same bug on x86.  Sorry about that.  I'll fix it.

A natural fix would be to make xxx_get_debug_reg_state take an
inferior argument, but that doesn't work because of the case where we
detach breakpoints/watchpoints from the child fork, at a time there's
no inferior for the child fork at all.  We do a nasty hack in
i386_inferior_data_get, but that relies on all callers pointing the
current inferior to the correct inferior, which isn't actually being
done by all callers, and I don't think we want to enforce that -- deep
in the bowls of linux-nat.c, there are many cases we resume lwps
behind the scenes, and it's be better to not have that code rely on
global state (as it doesn't today).

The fix is to decouple the watchpoints code from inferiors, making it
track target processes instead.  This way, we can freely keep track of
the watchpoint mirrors for these processes behind the core's back.
Checkpoints also play dirty tricks with swapping the process behind
the inferior, so they get special treatment too in the patch (which
just amounts to calling a new hook).  Instead of the old hack in
i386_inferior_data_get, where we returned a copy of the current
inferior's debug registers mirror, as soon as we detect a fork in the
target, we copy the debug register mirror from the parent to the child
process.

I don't have an old kernel handy to test, but I stepped through gdb doing
the watchpoint removal in the fork child in the watchpoint-fork test
seeing that the debug registers end up cleared in the child.

I didn't find the need for linux_nat_iterate_watchpoint_lwps.  If
we use plain iterate_over_lwps instead, what happens is that
when removing watchpoints, that iterate_over_lwps doesn't actually
iterate over anything, since the fork child is not added to the
lwp list until later, at detach time, in linux_child_follow_fork.
And if we don't iterate over that lwp, we don't mark its debug
registers as needing update.  But linux_child_follow_fork takes
care of doing that explicitly:

	  child_lp = add_lwp (inferior_ptid);
	  child_lp->stopped = 1;
	  child_lp->last_resume_kind = resume_stop;
	  make_cleanup (delete_lwp_cleanup, child_lp);

	  /* CHILD_LP has new PID, therefore linux_nat_new_thread is not called for it.
	     See i386_inferior_data_get for the Linux kernel specifics.
	     Ensure linux_nat_prepare_to_resume will reset the hardware debug
	     registers.  It is done by the linux_nat_new_thread call, which is
	     being skipped in add_lwp above for the first lwp of a pid.  */
	  gdb_assert (num_lwps (GET_PID (child_lp->ptid)) == 1);
	  if (linux_nat_new_thread != NULL)
	    linux_nat_new_thread (child_lp);

	  if (linux_nat_prepare_to_resume != NULL)
	    linux_nat_prepare_to_resume (child_lp);
	  ptrace (PTRACE_DETACH, child_pid, 0, 0);

so unless I'm missing something (quite possible) it ends up all
the same.  But, the !detach-on-fork, and the "follow-fork child" paths
should also call linux_nat_new_thread, and they don't presently.  It
seems to me in those cases we're not clearing debug regs correctly
when that's needed.  Instead of copying that bit that works around
add_lwp bypassing the linux_nat_new_thread call, I thought it'd
be better to add an add_initial_lwp call to be used in the case we
really need to bypass linux_nat_new_thread, and make
add_lwp always call linux_nat_new_thread.

i386_cleanup_dregs is rewritten to forget about the current process
debug mirrors, which takes cares of other i386 ports.  Only a couple
of extra tweaks here and there were needed, as some targets wheren't
actually calling i386_cleanup_dregs.

Tested on Fedora 17 x86_64 -m64/-m32.

GDBserver already fetches the i386_debug_reg_state from the right
process, and, it doesn't handle forks at all, so no fix is needed over
there.

gdb/
2013-02-13  Pedro Alves  <palves@@redhat.com>

	* amd64-linux-nat.c (update_debug_registers_callback):
	Update comment.
	(amd64_linux_dr_set_control, amd64_linux_dr_set_addr): Use
	iterate_over_lwps.
	(amd64_linux_prepare_to_resume): Pass the lwp's pid to
	i386_debug_reg_state.
	(amd64_linux_new_fork): New function.
	(_initialize_amd64_linux_nat): Install amd64_linux_new_fork as
	linux_nat_new_fork hook, and i386_forget_process as
	linux_nat_forget_process hook.
	* i386-linux-nat.c (update_debug_registers_callback):
	Update comment.
	(amd64_linux_dr_set_control, amd64_linux_dr_set_addr): Use
	iterate_over_lwps.
	(i386_linux_prepare_to_resume): Pass the lwp's pid to
	i386_debug_reg_state.
	(i386_linux_new_fork): New function.
	(_initialize_i386_linux_nat): Install i386_linux_new_fork as
	linux_nat_new_fork hook, and i386_forget_process as
	linux_nat_forget_process hook.
	* i386-nat.c (i386_init_dregs): Delete.
	(i386_inferior_data, struct i386_inferior_data):
	Delete.
	(struct i386_process_info): New.
	(i386_process_list): New global.
	(i386_find_process_pid, i386_add_process, i386_process_info_get):
	New functions.
	(i386_inferior_data_get): Delete.
	(i386_process_info_get): New function.
	(i386_debug_reg_state): New parameter 'pid'.  Reimplement.
	(i386_forget_process): New function.
	(i386_cleanup_dregs): Rewrite.
	(i386_update_inferior_debug_regs, i386_insert_watchpoint)
	(i386_remove_watchpoint, i386_region_ok_for_watchpoint)
	(i386_stopped_data_address, i386_insert_hw_breakpoint)
	(i386_remove_hw_breakpoint): Adjust to pass the current process id
	to i386_debug_reg_state.
	(i386_use_watchpoints): Don't register inferior data.
	* i386-nat.h (i386_debug_reg_state): Add new 'pid' parameter, and
	adjust comment.
	(i386_forget_process): Declare.
	* linux-fork.c (delete_fork): Call linux_nat_forget_process.
	* linux-nat.c (linux_nat_new_fork, linux_nat_forget_process_hook):
	New static globals.
	(linux_child_follow_fork): Don't call linux_nat_new_thread here.
	(add_initial_lwp): New, factored out from ...
	(add_lwp): ... this.  Don't check the number of lwps before
	calling linux_nat_new_thread.
	(linux_nat_iterate_watchpoint_lwps): Delete.
	(linux_nat_attach): Use add_initial_lwp instead of add_lwp.
	(linux_handle_extended_wait): Call the linux_nat_new_fork hook on
	forks and vforks.
	(linux_nat_wait_1): Use add_initial_lwp instead of add_lwp for the
	initial lwp.
	(linux_nat_kill, linux_nat_mourn_inferior): Call
	linux_nat_forget_process.
	(linux_nat_set_new_fork, linux_nat_set_forget_process)
	(linux_nat_forget_process): New functions.
	* linux-nat.h (linux_nat_iterate_watchpoint_lwps_ftype): Delete
	type.
	(linux_nat_iterate_watchpoint_lwps): Delete declaration.
	(linux_nat_new_fork_ftype, linux_nat_forget_process_ftype): New
	types.
	(linux_nat_set_new_fork, linux_nat_set_forget_process)
	(linux_nat_forget_process): New declarations.

	* amd64fbsd-nat.c (super_mourn_inferior): New global.
	(amd64fbsd_mourn_inferior): New function.
	(_initialize_amd64fbsd_nat): Override to_mourn_inferior.
	* windows-nat.c (windows_detach): Call i386_cleanup_dregs.
@
text
@d5025 1
a5025 1
linux_nat_close (int quitting)
d5032 1
a5032 1
    linux_ops->to_close (quitting);
@


1.263
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* charset.c (intermediate_encoding): Remove unused i.
	* completer.c (signal_completer): Remove unused i.
	* continuations.c (discard_my_continuations_1): Remove unused
	continuation_ptr.
	* corelow.c (core_close): Remove unuseD name.
	(get_core_siginfo): Remove unused pid.
	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Remove unused
	i, cps.
	* dwarf2loc.c (dwarf2_compile_expr_to_ax): Remove unused base_offset.
	(loclist_describe_location): Remove unused first.
	* event-top.c (command_line_handler): Remove unused got_eof.
	* exec.c (exec_close_1): Remove unused need_symtab_cleanup.
	(resize_section_table): Remove unused old_value.
	* gdb_bfd.c (gdb_bfd_map_section): Remove unused header.
	* gnu-v3-abi.c (compute_vtable_size): Remove unused addr.
	* i386-tdep.c (i386_process_record): Remove unused rex.
	* infcmd.c (get_return_value): Remove unused uiout.
	* jv-lang.c (type_from_class): Remove unused is_array.
	* jv-valprint.c (java_val_print): Remove unused i.
	* linux-nat.c (linux_nat_stop_lwp): Remove unused ptid.
	* linux-thread-db.c (thread_db_find_new_threads_2): Remove unuseD pid.
	* m2-typeprint.c (m2_print_type): Remove unused code.
	* macroexp.c (get_character_constant): Remove unused body_start.
	(macro_stringify): Remove unused result.
	* objc-lang.c (find_methods): Remove unused gdbarch.
	* objfiles.c (filter_overlapping_sections): Remove unused abfd1, abfd2.
	* regcache.c (regcache_cooked_read): Remove unused gdbarch.
	* stack.c (print_frame_args): Remove unused summary.
	* thread.c (thread_apply_command): Remove unused p.
	* valarith.c (value_x_unop): Remove unused mangle_ptr.
	* valops.c (search_struct_method): Remove unused skip.
	* valprint.c (generic_val_print): Remove unused byte_order.
	* varobj.c (varobj_update): Remove unused changed.
	* cli/cli-cmds.c (complete_command): Remove unused next_item.
	(alias_command): Remove unused c.
	* mi/mi-cmd-catch.c (mi_catch_load_unload): Remove unused c.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Remove unused
	format.
	(mi_cmd_data_write_memory): Remove unused word_format.
	(mi_cmd_data_write_memory_bytes): Remove unused r.
	* python/py-gdb-readline.c (gdbpy_readline_wrapper): Remove unused
	p_start, p_end.
	* python/python.c (_initialize_python): Remove unused cmd_name, cmd.
	* tui/tui-disasm.c (tui_set_disassem_content): Remove unused
	line_width.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00766.html
@
text
@d187 7
a707 9
	  /* CHILD_LP has new PID, therefore linux_nat_new_thread is not called for it.
	     See i386_inferior_data_get for the Linux kernel specifics.
	     Ensure linux_nat_prepare_to_resume will reset the hardware debug
	     registers.  It is done by the linux_nat_new_thread call, which is
	     being skipped in add_lwp above for the first lwp of a pid.  */
	  gdb_assert (num_lwps (GET_PID (child_lp->ptid)) == 1);
	  if (linux_nat_new_thread != NULL)
	    linux_nat_new_thread (child_lp);

d1177 13
a1189 3
/* Add the LWP specified by PID to the list.  Return a pointer to the
   structure describing the new LWP.  The LWP should already be stopped
   (with an exception for the very first LWP).  */
d1192 1
a1192 1
add_lwp (ptid_t ptid)
d1211 14
d1227 3
a1229 7
     watchpoints in the new thread.  Don't do this for the first
     thread though.  If we're spawning a child ("run"), the thread
     executes the shell wrapper first, and we shouldn't touch it until
     it execs the program we want to debug.  For "attach", it'd be
     okay to call the callback, but it's not necessary, because
     watchpoints can't yet have been inserted into the inferior.  */
  if (num_lwps (GET_PID (ptid)) > 1 && linux_nat_new_thread != NULL)
a1305 39
/* Iterate like iterate_over_lwps does except when forking-off a child call
   CALLBACK with CALLBACK_DATA specifically only for that new child PID.  */

void
linux_nat_iterate_watchpoint_lwps
  (linux_nat_iterate_watchpoint_lwps_ftype callback, void *callback_data)
{
  int inferior_pid = ptid_get_pid (inferior_ptid);
  struct inferior *inf = current_inferior ();

  if (inf->pid == inferior_pid)
    {
      /* Iterate all the threads of the current inferior.  Without specifying
	 INFERIOR_PID it would iterate all threads of all inferiors, which is
	 inappropriate for watchpoints.  */

      iterate_over_lwps (pid_to_ptid (inferior_pid), callback, callback_data);
    }
  else
    {
      /* Detaching a new child PID temporarily present in INFERIOR_PID.  */

      struct lwp_info *child_lp;
      struct cleanup *old_chain;
      pid_t child_pid = GET_PID (inferior_ptid);
      ptid_t child_ptid = ptid_build (child_pid, child_pid, 0);

      gdb_assert (find_lwp_pid (child_ptid) == NULL);
      child_lp = add_lwp (child_ptid);
      child_lp->stopped = 1;
      child_lp->last_resume_kind = resume_stop;
      old_chain = make_cleanup (delete_lwp_cleanup, child_lp);

      callback (child_lp, callback_data);

      do_cleanups (old_chain);
    }
}

d1638 1
a1638 1
  lp = add_lwp (ptid);
d2291 9
d3480 1
a3480 1
      lp = add_lwp (inferior_ptid);
d4066 4
d4098 3
a4100 1
  purge_lwp_list (ptid_get_pid (inferior_ptid));
d4110 3
d5146 29
@


1.262
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a4978 2
      ptid_t ptid = lwp->ptid;

@


1.261
log
@gdb/
2012-11-26  Maxime Villard  <rustyBSD@@gmx.fr>
	    Pedro Alves  <palves@@redhat.com>

	* common/linux-osdata.c (linux_xfer_osdata_fds): Decrease buffer
	size parameter passed to readlink by one byte.
	* fbsd-nat.c (fbsd_pid_to_exec_file): Ditto.
	* linux-nat.c (linux_child_pid_to_exec_file): Ditto.
	* nbsd-nat.c (nbsd_pid_to_exec_file): Ditto.
	* inf-child.c (inf_child_fileio_readlink): Decrease local buffer's
	size by one byte.

gdb/gdbserver/
2012-11-26  Maxime Villard  <rustyBSD@@gmx.fr>

	* hostio.c (handle_readlink): Decrease buffer size
	parameter passed to readlink by one byte.
@
text
@d3 1
a3 1
   Copyright (C) 2001-2012 Free Software Foundation, Inc.
@


1.260
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d4322 1
a4322 1
  if (readlink (name1, name2, MAXPATHLEN) > 0)
@


1.259
log
@gdb/
2012-11-09  Pedro Alves  <palves@@redhat.com>

	* gdbarch.sh (target_gdbarch) <gdbarch.h>: Reimplement as macro.
	(get_target_gdbarch) <gdbarch.h>: New function.
	(startup_gdbarch) <gdbarch.h>: Declare.
	<gdbarch.c> (target_gdbarch): Delete.
	<gdbarch.c> (deprecated_target_gdbarch_select_hack): Set the
	current inferior's gdbarch.
	<gdbarch.c> (get_target_gdbarch): New function.
	* inferior.c: Include target-descriptions.h.
	(free_inferior): Free target description info.
	(add_inferior_with_spaces): Set the inferior's initial
	architecture.
	(clone_inferior_command): Copy the original inferior's target
	description if it was user specified.
	(initialize_inferiors): Add comment.
	* inferior.h (struct target_desc_info): Forward declare.
	(struct inferior) <gdbarch>: New field.
	* linux-nat.c: Include target-descriptions.h.
	(linux_child_follow_fork): Copy the parent's architecture and
	target description to the child.
	* target-descriptions.c: Include inferior.h.
	(struct target_desc_info): New structure, holding the equivalents
	of ...
	(target_desc_fetched, current_target_desc)
	(target_description_filename): ... these removed globals.
	(get_tdesc_info, target_desc_info_from_user_p)
	(copy_inferior_target_desc_info, target_desc_info_free): New.
	(target_desc_fetched, current_target_desc)
	(target_description_filename): Reimplemented as convenience
	macros.
	(tdesc_filename_cmd_string): New global.
	(set_tdesc_filename_cmd): Copy the string manipulated by the "set
	tdescs filename ..." commands to the per-inferior equivalent.
	(show_tdesc_filename_cmd): Get the value to show from the
	per-inferior description filename.
	(_initilize_target_descriptions): Change the "set/show tdesc
	filename" commands' variable.
	* target-descriptions.h (struct target_desc, struct target_desc_info)
	(struct inferior): Forward declare.
	(target_find_description, target_clear_description)
	(target_current_description): Adjust comments.
	(copy_inferior_target_desc_info, target_desc_info_free)
	(target_desc_info_from_user_p). Declare.

gdb/testsuite/
2012-11-09  Pedro Alves  <palves@@redhat.com>

	* gdb.multi/multi-arch.exp: New.
@
text
@d4379 1
a4379 1
  return linux_make_corefile_notes (target_gdbarch, obfd, note_size,
d4434 1
a4434 1
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch);
d4643 1
a4643 1
      int addr_bit = gdbarch_addr_bit (target_gdbarch);
@


1.258
log
@Change detach_breakpoints to take a ptid instead of a pid

Before this change, detach_breakpoints would take a pid, and then
set inferior_ptid to a ptid that it constructs using pid_to_ptid (pid).
Unfortunately, this ptid is not necessarily valid.  Consider for
instance the case of ia64-hpux, where ttrace refuses a register-read
operation if the LWP is not provided.

This problems shows up when GDB is trying to handle fork events.
Assuming GDB is configured to follow the parent, GDB will try to
detach from the child. But before doing so, it needs to remove
all breakpoints inside that child.  On ia64, this involves reading
inferior (the child's) memory. And on ia64-hpux, reading memory
requires us to read the bsp and bspstore registers, in order to
determine where that memory is relative to the value of those
registers, and thus to determine which ttrace operation to use in
order to fetch that memory (see ia64_hpux_xfer_memory).

This patch therefore changes detach_breakpoints to take a ptid instead
of a pid, and then updates all callers.

One of the consequences of this patch is that it trips an assert
on GNU/Linux targets.  But this assert appears to have not actual
purpose, and is thus removed.

gdb/ChangeLog:

        * breakpoint.h (detach_breakpoints): pid parameter is now a ptid.
        * breakpoint.c (detach_breakpoints): Change pid parameter into
        a ptid.  Adjust code accordingly.
        * infrun.c (handle_inferior_event): Delete variable child_pid.
        Update call to detach_breakpoints to pass the child ptid for
        fork events.
        * linux-nat.c (linux_nat_iterate_watchpoint_lwps): Remove
        assert that inferior_ptid's lwp is zero.
        (linux_handle_extended_wait): Update call to detach_breakpoints.
        * inf-ttrace.c (inf_ttrace_follow_fork): Update call to
        detach_breakpoints.
@
text
@d69 1
d727 2
d893 2
@


1.257
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@a1309 1
      gdb_assert (!is_lwp (inferior_ptid));
d2316 1
a2316 1
	  detach_breakpoints (new_pid);
@


1.256
log
@2012-07-20  Pedro Alves  <palves@@redhat.com>

	* linux-nat.c (linux_nat_wait): Dump the passed in target options.
	* target.c (target_wait): Likewise.
	(str_comma_list_concat_elem, do_option, target_options_to_string):
	New functions.
	* target.h (target_options_to_string): Declare.
@
text
@d204 1
a204 1
static int debug_linux_nat;
d5197 2
a5198 2
  add_setshow_zinteger_cmd ("lin-lwp", class_maintenance,
			    &debug_linux_nat, _("\
d5202 3
a5204 3
			    NULL,
			    show_debug_linux_nat,
			    &setdebuglist, &showdebuglist);
@


1.255
log
@2012-07-16  Marc Khouzam  <marc.khouzam@@ericsson.com>
	    Pedro Alves  <palves@@redhat.com>

	* linux-nat.c (linux_nat_detach): Don't unregister from the event
	loop.
@
text
@d3932 10
a3941 2
    fprintf_unfiltered (gdb_stdlog,
			"linux_nat_wait: [%s]\n", target_pid_to_str (ptid));
@


1.254
log
@gdb/
	* common/linux-ptrace.c: Include gdb_assert.h.
	<__i386__> (linux_ptrace_test_ret_to_nx_instr): New declaration.
	<__i386__>: Include sys/reg.h, sys/mman.h, signal.h, sys/wait.h and
	stdint.h.
	(linux_ptrace_test_ret_to_nx, linux_ptrace_init_warnings): New
	functions.
	* common/linux-ptrace.h (linux_ptrace_init_warnings): New declarations.
	* linux-nat.c (linux_child_post_attach)
	(linux_child_post_startup_inferior): Call linux_ptrace_init_warnings.

gdb/gdbserver/
	* gdbserver/linux-low.c (initialize_low): Call
	linux_ptrace_init_warnings.
@
text
@d1851 2
a1852 2
  if (target_can_async_p ())
    linux_nat_async (NULL, 0);
a1894 3

      if (non_stop && target_can_async_p ())
 	target_async (inferior_event_handler, 0);
@


1.253
log
@gdb/
	* linux-nat.c (resume_lwp, linux_nat_resume): Remove LP->SIGINFO
	clearing.
	(save_siginfo): Remove.
	(stop_wait_callback, linux_nat_filter_event): Remove the save_siginfo
	call.
	(resume_stopped_resumed_lwps): Remove LP->SIGINFO clearing.
	(linux_nat_get_siginfo): Use PTRACE_GETSIGINFO.
	* linux-nat.h (struct lwp_info): Remove field siginfo.
@
text
@d586 1
d594 1
@


1.252
log
@gdb/
	Code cleanup for the next patch.
	* arm-linux-nat.c (arm_linux_stopped_data_address): Change variable
	siginfo_p to siginfo, update its users incl. the linux_nat_get_siginfo
	call for it.
	* ia64-linux-nat.c (ia64_linux_stopped_data_address): Likewise.
	(ia64_linux_stopped_data_address):
	* linux-nat.c (linux_nat_get_siginfo): Add parameter siginfo, change
	the return value.
	* linux-nat.h (linux_nat_get_siginfo): Likewise.
	* ppc-linux-nat.c (ppc_linux_stopped_data_address): Change variable
	siginfo_p to siginfo, update its users incl. the linux_nat_get_siginfo
	call for it.
@
text
@a1935 1
	  memset (&lp->siginfo, 0, sizeof (lp->siginfo));
a2093 1
  memset (&lp->siginfo, 0, sizeof (lp->siginfo));
a2646 16
/* Save the most recent siginfo for LP.  This is currently only called
   for SIGTRAP; some ports use the si_addr field for
   target_stopped_data_address.  In the future, it may also be used to
   restore the siginfo of requeued signals.  */

static void
save_siginfo (struct lwp_info *lp)
{
  errno = 0;
  ptrace (PTRACE_GETSIGINFO, GET_LWP (lp->ptid),
	  (PTRACE_TYPE_ARG3) 0, &lp->siginfo);

  if (errno != 0)
    memset (&lp->siginfo, 0, sizeof (lp->siginfo));
}

a2888 3
	  /* Save the trap's siginfo in case we need it later.  */
	  save_siginfo (lp);

d3266 1
a3266 6
    {
      /* Save the trap's siginfo in case we need it later.  */
      save_siginfo (lp);

      save_sigtrap (lp);
    }
a3918 1
      memset (&lp->siginfo, 0, sizeof (lp->siginfo));
d5168 1
a5168 1
  struct lwp_info *lp = find_lwp_pid (ptid);
d5170 3
a5172 3
  gdb_assert (lp != NULL);

  *siginfo = lp->siginfo;
d5174 7
@


1.251
log
@gdb/
2012-06-28  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdbthread.h (ALL_THREADS): New macro.
	(thread_list): Declare.
	* infrun.c (handle_inferior_event) <spurious signal>: Don't keep
	going, but instead fall through to the stepping handling.
	* linux-nat.c (resume_lwp): New parameter 'signo'.  Resume with
	the passed in signal.  Adjust debug output.
	(resume_callback): Rename to ...
	(linux_nat_resume_callback): ... this.  Pass the thread's last
	stop signal, if in "pass" state.
	(linux_nat_resume): Adjust to rename.
	(stop_wait_callback): New assertion.  Don't respawn signals;
	instead let the LWP remain with SIGNALLED set.
	(linux_nat_wait_1): Remove flushing of pending SIGSTOPs.
	* remote.c (append_pending_thread_resumptions): New.
	(remote_vcont_resume): Call it.
	* target.h (target_resume): Extend comment.

gdb/testsuite/
2012-06-28  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdb.threads/siginfo-threads.exp: New file.
	* gdb.threads/siginfo-threads.c: New file.
	* gdb.threads/sigstep-threads.exp: New file.
	* gdb.threads/sigstep-threads.c: New file.
@
text
@d5190 4
a5193 3
/* Return the saved siginfo associated with PTID.  */
siginfo_t *
linux_nat_get_siginfo (ptid_t ptid)
d5199 3
a5201 1
  return &lp->siginfo;
@


1.250
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d1904 1
a1904 1
resume_lwp (struct lwp_info *lp, int step)
d1922 6
a1927 2
				"RC:  PTRACE_CONT %s, 0, 0 (resuming sibling)\n",
				target_pid_to_str (lp->ptid));
d1933 1
a1933 1
				step, GDB_SIGNAL_0);
d1956 2
d1959 1
a1959 1
resume_callback (struct lwp_info *lp, void *data)
d1961 16
a1976 1
  resume_lwp (lp, 0);
d2083 1
a2083 1
     resume_callback.  */
d2087 1
a2087 1
    iterate_over_lwps (ptid, resume_callback, NULL);
d2905 6
a2910 50
	  if (linux_nat_status_is_event (status))
	    {
	      /* If a LWP other than the LWP that we're reporting an
	         event for has hit a GDB breakpoint (as opposed to
	         some random trap signal), then just arrange for it to
	         hit it again later.  We don't keep the SIGTRAP status
	         and don't forward the SIGTRAP signal to the LWP.  We
	         will handle the current event, eventually we will
	         resume all LWPs, and this one will get its breakpoint
	         trap again.

	         If we do not do this, then we run the risk that the
	         user will delete or disable the breakpoint, but the
	         thread will have already tripped on it.  */

	      /* Save the trap's siginfo in case we need it later.  */
	      save_siginfo (lp);

	      save_sigtrap (lp);

	      /* Now resume this LWP and get the SIGSTOP event.  */
	      errno = 0;
	      ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
	      if (debug_linux_nat)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "PTRACE_CONT %s, 0, 0 (%s)\n",
				      target_pid_to_str (lp->ptid),
				      errno ? safe_strerror (errno) : "OK");

		  fprintf_unfiltered (gdb_stdlog,
				      "SWC: Candidate SIGTRAP event in %s\n",
				      target_pid_to_str (lp->ptid));
		}
	      /* Hold this event/waitstatus while we check to see if
		 there are any more (we still want to get that SIGSTOP).  */
	      stop_wait_callback (lp, NULL);

	      /* Hold the SIGTRAP for handling by linux_nat_wait.  If
		 there's another event, throw it back into the
		 queue.  */
	      if (lp->status)
		{
		  if (debug_linux_nat)
		    fprintf_unfiltered (gdb_stdlog,
					"SWC: kill %s, %s\n",
					target_pid_to_str (lp->ptid),
					status_to_str ((int) status));
		  kill_lwp (GET_LWP (lp->ptid), WSTOPSIG (lp->status));
		}
d2912 5
a2916 8
	      /* Save the sigtrap event.  */
	      lp->status = status;
	      return 0;
	    }
	  else
	    {
	      /* The thread was stopped with a signal other than
	         SIGSTOP, and didn't accidentally trip a breakpoint.  */
d2918 5
a2922 38
	      if (debug_linux_nat)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "SWC: Pending event %s in %s\n",
				      status_to_str ((int) status),
				      target_pid_to_str (lp->ptid));
		}
	      /* Now resume this LWP and get the SIGSTOP event.  */
	      errno = 0;
	      ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
	      if (debug_linux_nat)
		fprintf_unfiltered (gdb_stdlog,
				    "SWC: PTRACE_CONT %s, 0, 0 (%s)\n",
				    target_pid_to_str (lp->ptid),
				    errno ? safe_strerror (errno) : "OK");

	      /* Hold this event/waitstatus while we check to see if
	         there are any more (we still want to get that SIGSTOP).  */
	      stop_wait_callback (lp, NULL);

	      /* If the lp->status field is still empty, use it to
		 hold this event.  If not, then this event must be
		 returned to the event queue of the LWP.  */
	      if (lp->status)
		{
		  if (debug_linux_nat)
		    {
		      fprintf_unfiltered (gdb_stdlog,
					  "SWC: kill %s, %s\n",
					  target_pid_to_str (lp->ptid),
					  status_to_str ((int) status));
		    }
		  kill_lwp (GET_LWP (lp->ptid), WSTOPSIG (status));
		}
	      else
		lp->status = status;
	      return 0;
	    }
d2928 6
d2935 3
d3191 1
a3191 1
	      resume_lwp (lp, lp->step);
a3564 48
  if (lp && lp->signalled && lp->last_resume_kind != resume_stop)
    {
      /* A pending SIGSTOP may interfere with the normal stream of
         events.  In a typical case where interference is a problem,
         we have a SIGSTOP signal pending for LWP A while
         single-stepping it, encounter an event in LWP B, and take the
         pending SIGSTOP while trying to stop LWP A.  After processing
         the event in LWP B, LWP A is continued, and we'll never see
         the SIGTRAP associated with the last time we were
         single-stepping LWP A.  */

      /* Resume the thread.  It should halt immediately returning the
         pending SIGSTOP.  */
      registers_changed ();
      if (linux_nat_prepare_to_resume != NULL)
	linux_nat_prepare_to_resume (lp);
      linux_ops->to_resume (linux_ops, pid_to_ptid (GET_LWP (lp->ptid)),
			    lp->step, GDB_SIGNAL_0);
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: %s %s, 0, 0 (expect SIGSTOP)\n",
			    lp->step ? "PTRACE_SINGLESTEP" : "PTRACE_CONT",
			    target_pid_to_str (lp->ptid));
      lp->stopped = 0;
      gdb_assert (lp->resumed);

      /* Catch the pending SIGSTOP.  */
      status = lp->status;
      lp->status = 0;

      stop_wait_callback (lp, NULL);

      /* If the lp->status field isn't empty, we caught another signal
	 while flushing the SIGSTOP.  Return it back to the event
	 queue of the LWP, as we already have an event to handle.  */
      if (lp->status)
	{
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"LLW: kill %s, %s\n",
				target_pid_to_str (lp->ptid),
				status_to_str (lp->status));
	  kill_lwp (GET_LWP (lp->ptid), WSTOPSIG (lp->status));
	}

      lp->status = status;
    }

@


1.249
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d1709 1
a1709 1
  enum gdb_signal signo = TARGET_SIGNAL_0;
d1722 1
a1722 1
     to TARGET_SIGNAL_SIGTRAP when the catchpoint triggers.  But,
d1733 1
a1733 1
    signo = TARGET_SIGNAL_0; /* a pending ptrace event, not a real signal.  */
d1759 1
a1759 1
  if (signo == TARGET_SIGNAL_0)
d1929 1
a1929 1
				step, TARGET_SIGNAL_0);
d1988 1
a1988 1
			(signo != TARGET_SIGNAL_0
d2034 1
a2034 1
	  gdb_assert (signo == TARGET_SIGNAL_0);
d2044 1
a2044 1
      gdb_assert (signo == TARGET_SIGNAL_0);
d2082 1
a2082 1
			(signo != TARGET_SIGNAL_0
d2245 1
a2245 1
			lp->step, TARGET_SIGNAL_0);
d2364 1
a2364 1
		 It will later be reported as TARGET_SIGNAL_0.  */
d2434 1
a2434 1
					0, TARGET_SIGNAL_0);
d2445 1
a2445 1
				0, TARGET_SIGNAL_0);
d3423 1
a3423 1
			    lp->step, TARGET_SIGNAL_0);
d3456 1
a3456 1
			    lp->step, TARGET_SIGNAL_0);
d3632 1
a3632 1
			    lp->step, TARGET_SIGNAL_0);
d3890 1
a3890 1
				(signo != TARGET_SIGNAL_0
d3902 1
a3902 1
	  if (signo == TARGET_SIGNAL_INT && signal_pass_state (signo) == 0)
d3991 1
a3991 1
      ourstatus->value.sig = TARGET_SIGNAL_0;
d4041 1
a4041 1
			    lp->step, TARGET_SIGNAL_0);
d4780 1
a4780 1
  target_resume (*ptid, 0, TARGET_SIGNAL_0);
d5085 1
a5085 1
/* Stop an LWP, and push a TARGET_SIGNAL_0 stop status if no other
@


1.248
log
@2012-05-22  Pedro Alves  <palves@@redhat.com>

	* target.h (store_waitstatus): Move declaration ...
	* inf-child.h (store_waitstatus): ... here.
	* target.c: Move inclusion of gdb_wait.h, and ...
	(store_waitstatus): ... this ...
	* inf-child.c: ... here.
	* linux-nat.c: Include inf-child.h.
	* rs6000-nat.c: Include inf-child.h.
	* spu-linux-nat.c: Include inf-child.h.
@
text
@d1096 1
a1096 1
      int target_signo = target_signal_from_host (signo);
d1673 1
a1673 1
	  enum target_signal signo;
d1678 1
a1678 1
	  signo = target_signal_from_host (WTERMSIG (status));
d1681 2
a1682 2
		 target_signal_to_name (signo),
		 target_signal_to_string (signo));
d1709 1
a1709 1
  enum target_signal signo = TARGET_SIGNAL_0;
d1735 1
a1735 1
    signo = target_signal_from_host (WSTOPSIG (lp->status));
d1773 1
a1773 1
			    target_signal_to_string (signo));
d1777 1
a1777 1
      *status = W_STOPCODE (target_signal_to_host (signo));
d1783 1
a1783 1
			    target_signal_to_string (signo));
d1977 1
a1977 1
		  ptid_t ptid, int step, enum target_signal signo)
d1989 1
a1989 1
			 ? strsignal (target_signal_to_host (signo)) : "0"),
d2035 1
a2035 1
	  signo = target_signal_from_host (WSTOPSIG (lp->status));
d2083 1
a2083 1
			 ? strsignal (target_signal_to_host (signo)) : "0"));
d3867 1
a3867 1
      enum target_signal signo = target_signal_from_host (WSTOPSIG (status));
d3891 1
a3891 1
				 ? strsignal (target_signal_to_host (signo))
d4449 1
a4449 1
				    enum target_signal stop_signal)
d4469 1
a4469 1
			  target_signal_to_host (stop_signal), &gregs);
@


1.247
log
@gdb/

	* common/agent.c (agent_run_command): Add one more parameter `len'.
	Update callers.
	* common/agent.h: Update declaration.
	* linux-nat.c (linux_child_static_tracepoint_markers_by_strid):
	Update.
	(linux_child_static_tracepoint_markers_by_strid): Ditto.

gdb/gdbserver/

	* tracepoint.c (COPY_FIELD_TO_BUF): New macro.
	(struct tracepoint_action_ops) <send>: New field.
	(m_tracepoint_action_send, r_tracepoint_action_send): New.
	(agent_expr_send, x_tracepoint_action_send): New.
	(l_tracepoint_action_send): New.
	(cmd_qtdp): Download and install tracepoint
	according to `use_agent'.
	(run_inferior_command): Add one more parameter `len'.
	Update callers.
	(tracepoint_send_agent): New.
	(cmd_qtdp, cmd_qtstart): Call tracepoint_send_agent.
@
text
@d39 1
@


1.246
log
@struct siginfo vs. siginfo_t

gdb/
	* amd64-linux-nat.c (amd64_linux_siginfo_fixup): Use siginfo_t instead
	of struct siginfo.
	* arm-linux-nat.c (arm_linux_stopped_data_address): Likewise.
	* ia64-linux-nat.c (ia64_linux_stopped_data_address): Likewise.
	* linux-nat.c (linux_nat_siginfo_fixup, siginfo_fixup)
	(linux_xfer_siginfo, linux_nat_set_siginfo_fixup)
	(linux_nat_get_siginfo): Likewise.
	* linux-nat.h (struct lwp_info, linux_nat_set_siginfo_fixup)
	(linux_nat_get_siginfo): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* ppc-linux-nat.c (ppc_linux_stopped_data_address): Likewise.
	* procfs.c (gdb_siginfo_t): Likewise.

gdbserver/
	* linux-arm-low.c (arm_stopped_by_watchpoint): Use siginfo_t instead of
	struct siginfo.
	* linux-low.c (siginfo_fixup, linux_xfer_siginfo): Likewise.
	* linux-x86-low.c (x86_siginfo_fixup): Likewise.
	* linux-low.h: Include <signal.h>.
	(struct siginfo): Remove forward declaration.
	(struct linux_target_ops) <siginfo_fixup>: Use siginfo_t instead of
	struct siginfo.
@
text
@d4799 1
a4799 1
  agent_run_command (pid, s);
d4829 1
a4829 1
      agent_run_command (pid, s);
@


1.245
log
@gdb/
	* common/linux-procfs.c (linux_proc_get_int): New, from
	linux_proc_get_tgid, change its LWPID type to pid_t, add parameter
	field.
	(linux_proc_get_tgid): Only call linux_proc_get_int.
	(linux_proc_get_tracerpid): New.
	(linux_proc_pid_has_state): New, from linux_proc_pid_is_zombie.
	(linux_proc_pid_is_stopped, linux_proc_pid_is_zombie): Only call
	linux_proc_pid_has_state.
	* common/linux-procfs.h (linux_proc_get_tracerpid): New declaration.
	* common/linux-ptrace.c: Include linux-procfs.h and buffer.h.
	(linux_ptrace_attach_warnings): New.
	* common/linux-ptrace.h (struct buffer, linux_ptrace_attach_warnings):
	New declaration.
	* linux-nat.c: Include exceptions.h, linux-ptrace.h and buffer.h.
	(linux_nat_attach): New variables ex, buffer, message and message_s.
	Wrap to_attach by TRY_CATCH and call linux_ptrace_attach_warnings.

gdb/gdbserver/
	* linux-low.c (linux_attach_lwp_1): New variable buffer.  Call
	linux_ptrace_attach_warnings.

gdb/testsuite/
	* gdb.base/attach-twice.c: New files.
	* gdb.base/attach-twice.exp: New files.
@
text
@d191 1
a191 1
static int (*linux_nat_siginfo_fixup) (struct siginfo *,
d4235 1
a4235 1
siginfo_fixup (struct siginfo *siginfo, gdb_byte *inf_siginfo, int direction)
d4247 1
a4247 1
	memcpy (siginfo, inf_siginfo, sizeof (struct siginfo));
d4249 1
a4249 1
	memcpy (inf_siginfo, siginfo, sizeof (struct siginfo));
d4259 2
a4260 2
  struct siginfo siginfo;
  gdb_byte inf_siginfo[sizeof (struct siginfo)];
d5269 1
a5269 1
			     int (*siginfo_fixup) (struct siginfo *,
d5288 1
a5288 1
struct siginfo *
@


1.244
log
@gdb/
	* Makefile.in (linux-ptrace.o): New.
	* common/linux-procfs.c (linux_proc_pid_is_zombie): New,
	from linux-nat.c.
	* common/linux-procfs.h (linux_proc_pid_is_zombie): New declaration.
	* common/linux-ptrace.c: New file.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Add linux-ptrace.o.
	* config/arm/linux.mh: Likewise.
	* config/i386/linux.mh: Likewise.
	* config/i386/linux64.mh: Likewise.
	* config/ia64/linux.mh: Likewise.
	* config/m32r/linux.mh: Likewise.
	* config/m68k/linux.mh: Likewise.
	* config/mips/linux.mh: Likewise.
	* config/pa/linux.mh: Likewise.
	* config/powerpc/linux.mh: Likewise.
	* config/powerpc/ppc64-linux.mh: Likewise.
	* config/powerpc/spu-linux.mh: Likewise.
	* config/s390/s390.mh: Likewise.
	* config/sparc/linux.mh: Likewise.
	* config/sparc/linux64.mh: Likewise.
	* config/xtensa/linux.mh: Likewise.
	* linux-nat.c (linux_lwp_is_zombie): Remove, move it to
	common/linux-procfs.c.
	(wait_lwp): Rename linux_lwp_is_zombie to linux_proc_pid_is_zombie.

gdb/gdbserver/
	* Makefile.in (linux-ptrace.o): New.
	* configure.srv (arm*-*-linux*, bfin-*-*linux*, crisv32-*-linux*)
	(cris-*-linux*, i[34567]86-*-linux*, ia64-*-linux*, m32r*-*-linux*)
	(m68*-*-linux*, m68*-*-uclinux*, mips*-*-linux*, powerpc*-*-linux*)
	(s390*-*-linux*, sh*-*-linux*, sparc*-*-linux*, tic6x-*-uclinux)
	(x86_64-*-linux*, xtensa*-*-linux*): Add linux-ptrace.o to SRV_TGTOBJ
	of these targets.
	* linux-low.c (linux_attach_lwp_1): Remove redundent else clause.
@
text
@d65 3
d1618 1
d1623 22
a1644 1
  linux_ops->to_attach (ops, args, from_tty);
@


1.243
log
@gdb/
	Code cleanup.
	* common/linux-osdata.c (linux_common_core_of_thread): New function
	comment.
	* linux-nat.c (linux_nat_wait_1): Replace linux_nat_core_of_thread_1
	call by linux_common_core_of_thread.
	(linux_nat_core_of_thread_1): Remove.
	* linux-nat.h (linux_nat_core_of_thread_1): Remove declaration.
	* linux-thread-db.c: Include linux-osdata.h.
	(update_thread_core): Replace linux_nat_core_of_thread_1 call by
	linux_common_core_of_thread.
@
text
@a2467 31
/* Return non-zero if LWP is a zombie.  */

static int
linux_lwp_is_zombie (long lwp)
{
  char buffer[MAXPATHLEN];
  FILE *procfile;
  int retval;
  int have_state;

  xsnprintf (buffer, sizeof (buffer), "/proc/%ld/status", lwp);
  procfile = fopen (buffer, "r");
  if (procfile == NULL)
    {
      warning (_("unable to open /proc file '%s'"), buffer);
      return 0;
    }

  have_state = 0;
  while (fgets (buffer, sizeof (buffer), procfile) != NULL)
    if (strncmp (buffer, "State:", 6) == 0)
      {
	have_state = 1;
	break;
      }
  retval = (have_state
	    && strcmp (buffer, "State:\tZ (zombie)\n") == 0);
  fclose (procfile);
  return retval;
}

d2521 1
a2521 1
	 waiting waitpid but the linux_lwp_is_zombie is safe this way.  */
d2524 1
a2524 1
	  && linux_lwp_is_zombie (GET_LWP (lp->ptid)))
d3471 1
a3471 1
	  && linux_lwp_is_zombie (inf->pid))
@


1.242
log
@gdb:
	* common/agent.c (agent_look_up_symbols): Add one parameter 'arg'.
	* common/agent.h: Update declaration.
	* inf-child.c (inf_child_use_agent): New.
	(inf_child_can_use_agent): New.
	(inf_child_target): Initialize fields `to_use_agent'
	and `to_can_use_agent'.
	* agent.c (agent_new_objfile): New.
        (_initialize_agent): Add agent_new_objfile to new_objfile
	observer.

	* linux-nat.c (linux_child_static_tracepoint_markers_by_strid):
	New.
        (linux_target_install_ops): Initialize field
	`to_static_tracepoint_markers_by_strid'.
	* remote.c (free_current_marker): Move it to ...
	* tracepoint.c (free_current_marker): ... here.  New.
	(cleanup_target_stop): New.
	* tracepoint.h: Declare free_current_marker.
	* NEWS: Add one entry about `info static-tracepoint-marker'.

gdb/gdbserver:
	* tracepoint.c (tracepoint_look_up_symbols): Update call to
	agent_look_up_symbols.

gdb/testsuite:
	* gdb.trace/strace.exp: run strace_info_marker in linux native gdb.
@
text
@d4003 1
a4003 1
    lp->core = linux_nat_core_of_thread_1 (lp->ptid);
a5191 65
int
linux_nat_core_of_thread_1 (ptid_t ptid)
{
  struct cleanup *back_to;
  char *filename;
  FILE *f;
  char *content = NULL;
  char *p;
  char *ts = 0;
  int content_read = 0;
  int i;
  int core;

  filename = xstrprintf ("/proc/%d/task/%ld/stat",
			 GET_PID (ptid), GET_LWP (ptid));
  back_to = make_cleanup (xfree, filename);

  f = fopen (filename, "r");
  if (!f)
    {
      do_cleanups (back_to);
      return -1;
    }

  make_cleanup_fclose (f);

  for (;;)
    {
      int n;

      content = xrealloc (content, content_read + 1024);
      n = fread (content + content_read, 1, 1024, f);
      content_read += n;
      if (n < 1024)
	{
	  content[content_read] = '\0';
	  break;
	}
    }

  make_cleanup (xfree, content);

  p = strchr (content, '(');

  /* Skip ")".  */
  if (p != NULL)
    p = strchr (p, ')');
  if (p != NULL)
    p++;

  /* If the first field after program name has index 0, then core number is
     the field with index 36.  There's no constant for that anywhere.  */
  if (p != NULL)
    p = strtok_r (p, " ", &ts);
  for (i = 0; p != NULL && i != 36; ++i)
    p = strtok_r (NULL, " ", &ts);

  if (p == NULL || sscanf (p, "%d", &core) == 0)
    core = -1;

  do_cleanups (back_to);

  return core;
}

@


1.241
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* amd64-linux-tdep.c (amd64_linux_record_signal): Make static.
	* breakpoint.c (create_exception_master_breakpoint, trace_command)
	(ftrace_command, strace_command): Make static.
	* d-lang.c (_initialize_d_language): Declare.
	* dwarf2expr.c (_initialize_dwarf2expr): Declare.
	* dwarf2loc.c (_initialize_dwarf2loc):
	* dwarf2read.c (process_psymtab_comp_unit): Make static.
	* exec.c (exec_get_section_table): Make static.
	* i386-linux-tdep.c (i386_linux_record_signal): Make static.
	* infcmd.c (ensure_valid_thread, ensure_not_tfind_mode): Make static.
	* inferior.c (remove_inferior_command, add_inferior_command)
	(clone_inferior_command): Make static.
	* linux-nat.c (linux_nat_thread_address_space)
	(linux_nat_core_of_thread): Make static.
	* linux-tdep.c (_initialize_linux_tdep): Declare.
	* objc-lang.c (_initialize_objc_lang): Declare.
	* opencl-lang.c (builtin_opencl_type, opencl_language_arch_info):
	Make static.
	(_initialize_opencl_language): Declare.
	* record.c (_initialize_record): Declare.
	* remote.c (demand_private_info, remote_get_tib_address)
	(remote_supports_cond_tracepoints)
	(remote_supports_fast_tracepoints, remote_get_tracepoint_status):
	Make static.
	* skip.c (_initialize_step_skip): Declare.
	* symtab.c (skip_prologue_using_lineinfo): Make static.
	* tracepoint.c (delete_trace_state_variable)
	(trace_variable_command, delete_trace_variable_command)
	(get_uploaded_tsv, find_matching_tracepoint_location)
	(find_matching_tsv, create_tsv_from_upload, get_traceframe_info):
	Make static.
	* value.c (pack_unsigned_long): Make static.
	* varobj.c (varobj_ensure_python_env): Make static.
	* windows-tdep.c (_initialize_windows_tdep): Declare.
	* xml-syscall.c (make_cleanup_free_syscalls_info): Make static.
@
text
@d63 2
d4777 67
d4865 3
@


1.240
log
@2012-02-27  Pedro Alves  <palves@@redhat.com>

	gdb/gdbserver/
	* linux-low.c (pid_is_stopped): Delete, moved to common/.
	(linux_attach_lwp_1): Adjust to use linux_proc_pid_is_stopped.

	gdb/
	* linux-nat.c (pid_is_stopped): Delete, moved to common/.
	(linux_nat_post_attach_wait): Adjust to use
	linux_proc_pid_is_stopped.

	* common/linux-procfs.h (linux_proc_pid_is_stopped): Declare.
	* common/linux-procfs.c (linux_proc_pid_is_stopped): New function,
	based on pid_is_stopped from both linux-nat.c and
	gdbserver/linux-low.c, and renamed.
@
text
@d5094 1
a5094 1
struct address_space *
d5187 1
a5187 1
int
@


1.239
log
@	* symfile.c (symbol_file_add_main_1): Use inferior's
	symfile_flags.
	* solib.c (solib_read_symbols): Use inferior's symfile_flags.
	* linux-nat.c (linux_child_follow_fork): Set symfile_flags on
	inferior.
	* infrun.c (handle_vfork_child_exec_or_exit): Set symfile_flags on
	inferior.
	(follow_exec): Use inferior's symfile_flags.
	* inferior.h (struct inferior) <symfile_flags>: New field.
@
text
@a1358 31
/* Detect `T (stopped)' in `/proc/PID/status'.
   Other states including `T (tracing stop)' are reported as false.  */

static int
pid_is_stopped (pid_t pid)
{
  FILE *status_file;
  char buf[100];
  int retval = 0;

  snprintf (buf, sizeof (buf), "/proc/%d/status", (int) pid);
  status_file = fopen (buf, "r");
  if (status_file != NULL)
    {
      int have_state = 0;

      while (fgets (buf, sizeof (buf), status_file))
	{
	  if (strncmp (buf, "State:", 6) == 0)
	    {
	      have_state = 1;
	      break;
	    }
	}
      if (have_state && strstr (buf, "T (stopped)") != NULL)
	retval = 1;
      fclose (status_file);
    }
  return retval;
}

d1369 1
a1369 1
  if (pid_is_stopped (pid))
@


1.238
log
@gdb/
	Fix watchpoints across inferior fork.
	* amd64-linux-nat.c (update_debug_registers_callback): Update the
	comment for linux_nat_iterate_watchpoint_lwps.
	(amd64_linux_dr_set_control, amd64_linux_dr_set_addr): Use
	linux_nat_iterate_watchpoint_lwps.
	(amd64_linux_prepare_to_resume): New comment on Linux kernel.
	* i386-linux-nat.c (update_debug_registers_callback): Update the
	comment for linux_nat_iterate_watchpoint_lwps.
	(i386_linux_dr_set_control, i386_linux_dr_set_addr): Use
	linux_nat_iterate_watchpoint_lwps.
	(i386_linux_prepare_to_resume): New comment on Linux kernel.
	* i386-nat.c: Include inferior.h.
	(dr_mirror): Remove.
	(i386_inferior_data, struct i386_inferior_data)
	(i386_inferior_data_get): New.
	(i386_debug_reg_state): Use i386_inferior_data_get.
	(i386_cleanup_dregs, i386_update_inferior_debug_regs)
	(i386_insert_watchpoint, i386_remove_watchpoint)
	(i386_stopped_data_address, i386_insert_hw_breakpoint)
	(i386_remove_hw_breakpoint): New variable state, use
	i386_debug_reg_state instead of DR_MIRROR.
	* linux-nat.c (delete_lwp): New declaration.
	(num_lwps): Move here from downwards.
	(delete_lwp_cleanup): New.
	(linux_child_follow_fork): Create new child_lp, call
	linux_nat_new_thread and linux_nat_prepare_to_resume before calling
	PTRACE_DETACH.
	(num_lwps): Move upwards.
	(linux_nat_iterate_watchpoint_lwps): New.
	* linux-nat.h (linux_nat_iterate_watchpoint_lwps_ftype): New.
	(linux_nat_iterate_watchpoint_lwps_ftype): New declaration.

gdb/testsuite/
	Fix watchpoints across inferior fork.
	* gdb.threads/watchpoint-fork-child.c: New file.
	* gdb.threads/watchpoint-fork-mt.c: New file.
	* gdb.threads/watchpoint-fork-parent.c: New file.
	* gdb.threads/watchpoint-fork-st.c: New file.
	* gdb.threads/watchpoint-fork.exp: New file.
	* gdb.threads/watchpoint-fork.h: New file.
@
text
@d62 1
d727 1
d933 1
@


1.237
log
@	* gdbarch.sh (find_memory_regions): New callback.
	* gdbarch.c, gdbarch.h: Regenerate.

	* gcore.c (gcore_memory_sections): Try gdbarch find_memory_regions
	callback before falling back to target method.

	* linux-nat.c (read_mapping, linux_nat_find_memory_regions): Remove.
	(linux_target_install_ops): No longer install it.

	* linux-tdep.c (linux_find_memory_regions): New function.
	(linux_init_abi): Install it.
@
text
@d291 1
d588 25
d659 2
d683 19
d703 2
a1162 15
/* Return the number of known LWPs in the tgid given by PID.  */

static int
num_lwps (int pid)
{
  int count = 0;
  struct lwp_info *lp;

  for (lp = lwp_list; lp; lp = lp->next)
    if (ptid_get_pid (lp->ptid) == pid)
      count++;

  return count;
}

d1272 40
@


1.236
log
@	* gdbarch.sh (make_corefile_notes): New architecture callback.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.

	* gcore.c (write_gcore_file): Try gdbarch_make_corefile_notes
	before target_make_corefile_notes.  If NULL is returned, the
	target does not support core file generation.

	* linux-nat.c: Include "linux-tdep.h".
	(find_signalled_thread, find_stop_signal): Remove.
	(linux_nat_do_thread_registers): Likewise.
	(struct linux_nat_corefile_thread_data): Likewise.
	(linux_nat_corefile_thread_callback): Likewise.
	(iterate_over_spus): Likewise.
	(struct linux_spu_corefile_data): Likewise.
	(linux_spu_corefile_callback): Likewise.
	(linux_spu_make_corefile_notes): Likewise.
	(linux_nat_collect_thread_registers): New function.
	(linux_nat_make_corefile_notes): Replace contents by call to
	linux_make_corefile_notes passing linux_nat_collect_thread_registers
	as native-only callback.

	* linux-tdep.h: Include "bfd.h".
	(struct regcache): Add forward declaration.
	(linux_collect_thread_registers_ftype): New typedef.
	(linux_make_corefile_notes): Add prototype.
	* linux-tdep.c: Include "gdbthread.h", "gdbcore.h", "regcache.h",
	"regset.h", and "elf-bfd.h".
	(find_signalled_thread, find_stop_signal): New functions.
	(linux_spu_make_corefile_notes): Likewise.
	(linux_collect_thread_registers): Likewise.
	(struct linux_corefile_thread_data): New data structure.
	(linux_corefile_thread_callback): New funcion.
	(linux_make_corefile_notes): Likewise.
	(linux_make_corefile_notes_1): Likewise.
	(linux_init_abi): Install it.
@
text
@a4398 84
/* Service function for corefiles and info proc.  */

static int
read_mapping (FILE *mapfile,
	      long long *addr,
	      long long *endaddr,
	      char *permissions,
	      long long *offset,
	      char *device, long long *inode, char *filename)
{
  int ret = fscanf (mapfile, "%llx-%llx %s %llx %s %llx",
		    addr, endaddr, permissions, offset, device, inode);

  filename[0] = '\0';
  if (ret > 0 && ret != EOF)
    {
      /* Eat everything up to EOL for the filename.  This will prevent
         weird filenames (such as one with embedded whitespace) from
         confusing this code.  It also makes this code more robust in
         respect to annotations the kernel may add after the filename.

         Note the filename is used for informational purposes
         only.  */
      ret += fscanf (mapfile, "%[^\n]\n", filename);
    }

  return (ret != 0 && ret != EOF);
}

/* Fills the "to_find_memory_regions" target vector.  Lists the memory
   regions in the inferior for a corefile.  */

static int
linux_nat_find_memory_regions (find_memory_region_ftype func, void *obfd)
{
  int pid = PIDGET (inferior_ptid);
  char mapsfilename[MAXPATHLEN];
  FILE *mapsfile;
  long long addr, endaddr, size, offset, inode;
  char permissions[8], device[8], filename[MAXPATHLEN];
  int read, write, exec;
  struct cleanup *cleanup;

  /* Compose the filename for the /proc memory map, and open it.  */
  sprintf (mapsfilename, "/proc/%d/maps", pid);
  if ((mapsfile = fopen (mapsfilename, "r")) == NULL)
    error (_("Could not open %s."), mapsfilename);
  cleanup = make_cleanup_fclose (mapsfile);

  if (info_verbose)
    fprintf_filtered (gdb_stdout,
		      "Reading memory regions from %s\n", mapsfilename);

  /* Now iterate until end-of-file.  */
  while (read_mapping (mapsfile, &addr, &endaddr, &permissions[0],
		       &offset, &device[0], &inode, &filename[0]))
    {
      size = endaddr - addr;

      /* Get the segment's permissions.  */
      read = (strchr (permissions, 'r') != 0);
      write = (strchr (permissions, 'w') != 0);
      exec = (strchr (permissions, 'x') != 0);

      if (info_verbose)
	{
	  fprintf_filtered (gdb_stdout,
			    "Save segment, %s bytes at %s (%c%c%c)",
			    plongest (size), paddress (target_gdbarch, addr),
			    read ? 'r' : ' ',
			    write ? 'w' : ' ', exec ? 'x' : ' ');
	  if (filename[0])
	    fprintf_filtered (gdb_stdout, " for %s", filename);
	  fprintf_filtered (gdb_stdout, "\n");
	}

      /* Invoke the callback function to create the corefile
	 segment.  */
      func (addr, size, read, write, exec, obfd);
    }
  do_cleanups (cleanup);
  return 0;
}

a4745 1
  t->to_find_memory_regions = linux_nat_find_memory_regions;
@


1.235
log
@	* gdbarch.sh (info_proc): New callback.
	* gdbarch.c, gdbarch.h: Regenerate.

	* infcmd.c (info_proc_cmd_1): Try gdbarch info_proc callback
	before falling back to the target info_proc callback.

	* linux-nat.c: Do not include "cli/cli-utils.h".
	(linux_nat_info_proc): Remove.
	(linux_target_install_ops): No longer install it.

	* linux-tdep.c: Include "cli/cli-utils.h" and <ctype.h>.
	(read_mapping): New function.
	(linux_info_proc): Likewise.
	(linux_init_abi): Install it.
@
text
@d61 1
a4482 22
static int
find_signalled_thread (struct thread_info *info, void *data)
{
  if (info->suspend.stop_signal != TARGET_SIGNAL_0
      && ptid_get_pid (info->ptid) == ptid_get_pid (inferior_ptid))
    return 1;

  return 0;
}

static enum target_signal
find_stop_signal (void)
{
  struct thread_info *info =
    iterate_over_threads (find_signalled_thread, NULL);

  if (info)
    return info->suspend.stop_signal;
  else
    return TARGET_SIGNAL_0;
}

d4487 6
a4492 7
linux_nat_do_thread_registers (bfd *obfd, ptid_t ptid,
			       char *note_data, int *note_size,
			       enum target_signal stop_signal)
{
  unsigned long lwp = ptid_get_lwp (ptid);
  struct gdbarch *gdbarch = target_gdbarch;
  struct regcache *regcache = get_thread_arch_regcache (ptid, gdbarch);
d4495 2
a4496 8
  struct cleanup *old_chain;
  struct core_regset_section *sect_list;
  char *gdb_regset;

  old_chain = save_inferior_ptid ();
  inferior_ptid = ptid;
  target_fetch_registers (regcache, -1);
  do_cleanups (old_chain);
a4498 30
  sect_list = gdbarch_core_regset_sections (gdbarch);

  /* The loop below uses the new struct core_regset_section, which stores
     the supported section names and sizes for the core file.  Note that
     note PRSTATUS needs to be treated specially.  But the other notes are
     structurally the same, so they can benefit from the new struct.  */
  if (core_regset_p && sect_list != NULL)
    while (sect_list->sect_name != NULL)
      {
	regset = gdbarch_regset_from_core_section (gdbarch,
						   sect_list->sect_name,
						   sect_list->size);
	gdb_assert (regset && regset->collect_regset);
	gdb_regset = xmalloc (sect_list->size);
	regset->collect_regset (regset, regcache, -1,
				gdb_regset, sect_list->size);

	if (strcmp (sect_list->sect_name, ".reg") == 0)
	  note_data = (char *) elfcore_write_prstatus
				(obfd, note_data, note_size,
				 lwp, target_signal_to_host (stop_signal),
				 gdb_regset);
	else
	  note_data = (char *) elfcore_write_register_note
				(obfd, note_data, note_size,
				 sect_list->sect_name, gdb_regset,
				 sect_list->size);
	xfree (gdb_regset);
	sect_list++;
      }
d4500 5
a4504 3
  /* For architectures that does not have the struct core_regset_section
     implemented, we use the old method.  When all the architectures have
     the new support, the code below should be deleted.  */
d4506 1
a4506 3
    {
      gdb_gregset_t gregs;
      gdb_fpregset_t fpregs;
d4508 7
a4514 3
      if (core_regset_p
	  && (regset = gdbarch_regset_from_core_section (gdbarch, ".reg",
							 sizeof (gregs)))
d4516 3
a4518 17
	regset->collect_regset (regset, regcache, -1,
				&gregs, sizeof (gregs));
      else
	fill_gregset (regcache, &gregs, -1);

      note_data = (char *) elfcore_write_prstatus
	(obfd, note_data, note_size, lwp, target_signal_to_host (stop_signal),
	 &gregs);

      if (core_regset_p
          && (regset = gdbarch_regset_from_core_section (gdbarch, ".reg2",
							 sizeof (fpregs)))
	  != NULL && regset->collect_regset != NULL)
	regset->collect_regset (regset, regcache, -1,
				&fpregs, sizeof (fpregs));
      else
	fill_fpregset (regcache, &fpregs, -1);
d4520 2
a4521 5
      note_data = (char *) elfcore_write_prfpreg (obfd,
						  note_data,
						  note_size,
						  &fpregs, sizeof (fpregs));
    }
a4525 141
struct linux_nat_corefile_thread_data
{
  bfd *obfd;
  char *note_data;
  int *note_size;
  int num_notes;
  enum target_signal stop_signal;
};

/* Called by gdbthread.c once per thread.  Records the thread's
   register state for the corefile note section.  */

static int
linux_nat_corefile_thread_callback (struct lwp_info *ti, void *data)
{
  struct linux_nat_corefile_thread_data *args = data;

  args->note_data = linux_nat_do_thread_registers (args->obfd,
						   ti->ptid,
						   args->note_data,
						   args->note_size,
						   args->stop_signal);
  args->num_notes++;

  return 0;
}

/* Enumerate spufs IDs for process PID.  */

static void
iterate_over_spus (int pid, void (*callback) (void *, int), void *data)
{
  char path[128];
  DIR *dir;
  struct dirent *entry;

  xsnprintf (path, sizeof path, "/proc/%d/fd", pid);
  dir = opendir (path);
  if (!dir)
    return;

  rewinddir (dir);
  while ((entry = readdir (dir)) != NULL)
    {
      struct stat st;
      struct statfs stfs;
      int fd;

      fd = atoi (entry->d_name);
      if (!fd)
	continue;

      xsnprintf (path, sizeof path, "/proc/%d/fd/%d", pid, fd);
      if (stat (path, &st) != 0)
	continue;
      if (!S_ISDIR (st.st_mode))
	continue;

      if (statfs (path, &stfs) != 0)
	continue;
      if (stfs.f_type != SPUFS_MAGIC)
	continue;

      callback (data, fd);
    }

  closedir (dir);
}

/* Generate corefile notes for SPU contexts.  */

struct linux_spu_corefile_data
{
  bfd *obfd;
  char *note_data;
  int *note_size;
};

static void
linux_spu_corefile_callback (void *data, int fd)
{
  struct linux_spu_corefile_data *args = data;
  int i;

  static const char *spu_files[] =
    {
      "object-id",
      "mem",
      "regs",
      "fpcr",
      "lslr",
      "decr",
      "decr_status",
      "signal1",
      "signal1_type",
      "signal2",
      "signal2_type",
      "event_mask",
      "event_status",
      "mbox_info",
      "ibox_info",
      "wbox_info",
      "dma_info",
      "proxydma_info",
   };

  for (i = 0; i < sizeof (spu_files) / sizeof (spu_files[0]); i++)
    {
      char annex[32], note_name[32];
      gdb_byte *spu_data;
      LONGEST spu_len;

      xsnprintf (annex, sizeof annex, "%d/%s", fd, spu_files[i]);
      spu_len = target_read_alloc (&current_target, TARGET_OBJECT_SPU,
				   annex, &spu_data);
      if (spu_len > 0)
	{
	  xsnprintf (note_name, sizeof note_name, "SPU/%s", annex);
	  args->note_data = elfcore_write_note (args->obfd, args->note_data,
						args->note_size, note_name,
						NT_SPU, spu_data, spu_len);
	  xfree (spu_data);
	}
    }
}

static char *
linux_spu_make_corefile_notes (bfd *obfd, char *note_data, int *note_size)
{
  struct linux_spu_corefile_data args;

  args.obfd = obfd;
  args.note_data = note_data;
  args.note_size = note_size;

  iterate_over_spus (PIDGET (inferior_ptid),
		     linux_spu_corefile_callback, &args);

  return args.note_data;
}

d4532 4
a4535 57
  struct linux_nat_corefile_thread_data thread_args;
  /* The variable size must be >= sizeof (prpsinfo_t.pr_fname).  */
  char fname[16] = { '\0' };
  /* The variable size must be >= sizeof (prpsinfo_t.pr_psargs).  */
  char psargs[80] = { '\0' };
  char *note_data = NULL;
  ptid_t filter = pid_to_ptid (ptid_get_pid (inferior_ptid));
  gdb_byte *auxv;
  int auxv_len;

  if (get_exec_file (0))
    {
      strncpy (fname, lbasename (get_exec_file (0)), sizeof (fname));
      strncpy (psargs, get_exec_file (0), sizeof (psargs));
      if (get_inferior_args ())
	{
	  char *string_end;
	  char *psargs_end = psargs + sizeof (psargs);

	  /* linux_elfcore_write_prpsinfo () handles zero unterminated
	     strings fine.  */
	  string_end = memchr (psargs, 0, sizeof (psargs));
	  if (string_end != NULL)
	    {
	      *string_end++ = ' ';
	      strncpy (string_end, get_inferior_args (),
		       psargs_end - string_end);
	    }
	}
      note_data = (char *) elfcore_write_prpsinfo (obfd,
						   note_data,
						   note_size, fname, psargs);
    }

  /* Dump information for threads.  */
  thread_args.obfd = obfd;
  thread_args.note_data = note_data;
  thread_args.note_size = note_size;
  thread_args.num_notes = 0;
  thread_args.stop_signal = find_stop_signal ();
  iterate_over_lwps (filter, linux_nat_corefile_thread_callback, &thread_args);
  gdb_assert (thread_args.num_notes != 0);
  note_data = thread_args.note_data;

  auxv_len = target_read_alloc (&current_target, TARGET_OBJECT_AUXV,
				NULL, &auxv);
  if (auxv_len > 0)
    {
      note_data = elfcore_write_note (obfd, note_data, note_size,
				      "CORE", NT_AUXV, auxv, auxv_len);
      xfree (auxv);
    }

  note_data = linux_spu_make_corefile_notes (obfd, note_data, note_size);

  make_cleanup (xfree, note_data);
  return note_data;
@


1.234
log
@ChangeLog:

	* defs.h (enum info_proc_what): Moved here from linux-nat.c
	* infcmd.c: (info_proc_cmd_1): New function.
	(info_proc_cmd): New function, moved here from equivalent routine
	orignally in linux-nat.c.
	(info_proc_cmd_mappings): Likewise.
	(info_proc_cmd_stat): Likewise.
	(info_proc_cmd_status): Likewise.
	(info_proc_cmd_cwd): Likewise.
	(info_proc_cmd_cmdline): Likewise.
	(info_proc_cmd_exe): Likewise.
	(info_proc_cmd_all): Likewise.
	(_initialize_infcmd): Install "info proc" command and subcommands.

	* target.h (struct target_ops): Add to_info_proc.
	(target_info_proc): Add prototype.
	* target.c (target_info_proc): New function.

	* procfs.c (procfs_info_proc): Add prototype.
	(info_proc_cmd): Rename into ...
	(procfs_info_proc): ... this.  Update argument types as appropriate
	for a to_info_proc implementation.  Handle "what" argument.
	(procfs_target): Install procfs_info_proc.
	(_initialize_procfs): No longer install "info proc" command.

	* linux-nat.c: (enum info_proc_what): Remove.
	(linux_nat_info_proc_cmd_1): Rename into ...
	(linux_nat_info_proc): ... this.  Update argument types as appropriate
	for a to_info_proc implementation.
	(linux_nat_info_proc_cmd): Remove.
	(linux_nat_info_proc_cmd_mappings): Likewise.
	(linux_nat_info_proc_cmd_stat): Likewise.
	(linux_nat_info_proc_cmd_status): Likewise.
	(linux_nat_info_proc_cmd_cwd): Likewise.
	(linux_nat_info_proc_cmd_cmdline): Likewise.
	(linux_nat_info_proc_cmd_exe): Likewise.
	(linux_nat_info_proc_cmd_all): Likewise.
	(linux_target_install_ops): Install linux_nat_info_proc.
	(_initialize_linux_nat): No longer install "info proc" command
	and subcommands.

testsuite/ChangeLog:

	* gdb.base/info-proc.exp: Also run on remote targets.  Main
	"info proc" command is now always present; whether target supports
	actual info proc operation is detected when attempting to issue
	the command.
@
text
@a60 1
#include "cli/cli-utils.h"
a4802 245
/* Implement the "info proc" command.  */

static void
linux_nat_info_proc (struct target_ops *ops, char *args,
		     enum info_proc_what what)
{
  /* A long is used for pid instead of an int to avoid a loss of precision
     compiler warning from the output of strtoul.  */
  long pid = PIDGET (inferior_ptid);
  FILE *procfile;
  char buffer[MAXPATHLEN];
  char fname1[MAXPATHLEN], fname2[MAXPATHLEN];
  int cmdline_f = (what == IP_MINIMAL || what == IP_CMDLINE || what == IP_ALL);
  int cwd_f = (what == IP_MINIMAL || what == IP_CWD || what == IP_ALL);
  int exe_f = (what == IP_MINIMAL || what == IP_EXE || what == IP_ALL);
  int mappings_f = (what == IP_MAPPINGS || what == IP_ALL);
  int status_f = (what == IP_STATUS || what == IP_ALL);
  int stat_f = (what == IP_STAT || what == IP_ALL);
  struct stat dummy;

  if (args && isdigit (args[0]))
    pid = strtoul (args, &args, 10);

  args = skip_spaces (args);
  if (args && args[0])
    error (_("Too many parameters: %s"), args);

  if (pid == 0)
    error (_("No current process: you must name one."));

  sprintf (fname1, "/proc/%ld", pid);
  if (stat (fname1, &dummy) != 0)
    error (_("No /proc directory: '%s'"), fname1);

  printf_filtered (_("process %ld\n"), pid);
  if (cmdline_f)
    {
      sprintf (fname1, "/proc/%ld/cmdline", pid);
      if ((procfile = fopen (fname1, "r")) != NULL)
	{
	  struct cleanup *cleanup = make_cleanup_fclose (procfile);

          if (fgets (buffer, sizeof (buffer), procfile))
            printf_filtered ("cmdline = '%s'\n", buffer);
          else
            warning (_("unable to read '%s'"), fname1);
	  do_cleanups (cleanup);
	}
      else
	warning (_("unable to open /proc file '%s'"), fname1);
    }
  if (cwd_f)
    {
      sprintf (fname1, "/proc/%ld/cwd", pid);
      memset (fname2, 0, sizeof (fname2));
      if (readlink (fname1, fname2, sizeof (fname2)) > 0)
	printf_filtered ("cwd = '%s'\n", fname2);
      else
	warning (_("unable to read link '%s'"), fname1);
    }
  if (exe_f)
    {
      sprintf (fname1, "/proc/%ld/exe", pid);
      memset (fname2, 0, sizeof (fname2));
      if (readlink (fname1, fname2, sizeof (fname2)) > 0)
	printf_filtered ("exe = '%s'\n", fname2);
      else
	warning (_("unable to read link '%s'"), fname1);
    }
  if (mappings_f)
    {
      sprintf (fname1, "/proc/%ld/maps", pid);
      if ((procfile = fopen (fname1, "r")) != NULL)
	{
	  long long addr, endaddr, size, offset, inode;
	  char permissions[8], device[8], filename[MAXPATHLEN];
	  struct cleanup *cleanup;

	  cleanup = make_cleanup_fclose (procfile);
	  printf_filtered (_("Mapped address spaces:\n\n"));
	  if (gdbarch_addr_bit (target_gdbarch) == 32)
	    {
	      printf_filtered ("\t%10s %10s %10s %10s %7s\n",
			   "Start Addr",
			   "  End Addr",
			   "      Size", "    Offset", "objfile");
            }
	  else
            {
	      printf_filtered ("  %18s %18s %10s %10s %7s\n",
			   "Start Addr",
			   "  End Addr",
			   "      Size", "    Offset", "objfile");
	    }

	  while (read_mapping (procfile, &addr, &endaddr, &permissions[0],
			       &offset, &device[0], &inode, &filename[0]))
	    {
	      size = endaddr - addr;

	      /* FIXME: carlton/2003-08-27: Maybe the printf_filtered
		 calls here (and possibly above) should be abstracted
		 out into their own functions?  Andrew suggests using
		 a generic local_address_string instead to print out
		 the addresses; that makes sense to me, too.  */

	      if (gdbarch_addr_bit (target_gdbarch) == 32)
	        {
	          printf_filtered ("\t%#10lx %#10lx %#10x %#10x %7s\n",
			       (unsigned long) addr,	/* FIXME: pr_addr */
			       (unsigned long) endaddr,
			       (int) size,
			       (unsigned int) offset,
			       filename[0] ? filename : "");
		}
	      else
	        {
	          printf_filtered ("  %#18lx %#18lx %#10x %#10x %7s\n",
			       (unsigned long) addr,	/* FIXME: pr_addr */
			       (unsigned long) endaddr,
			       (int) size,
			       (unsigned int) offset,
			       filename[0] ? filename : "");
	        }
	    }

	  do_cleanups (cleanup);
	}
      else
	warning (_("unable to open /proc file '%s'"), fname1);
    }
  if (status_f)
    {
      sprintf (fname1, "/proc/%ld/status", pid);
      if ((procfile = fopen (fname1, "r")) != NULL)
	{
	  struct cleanup *cleanup = make_cleanup_fclose (procfile);

	  while (fgets (buffer, sizeof (buffer), procfile) != NULL)
	    puts_filtered (buffer);
	  do_cleanups (cleanup);
	}
      else
	warning (_("unable to open /proc file '%s'"), fname1);
    }
  if (stat_f)
    {
      sprintf (fname1, "/proc/%ld/stat", pid);
      if ((procfile = fopen (fname1, "r")) != NULL)
	{
	  int itmp;
	  char ctmp;
	  long ltmp;
	  struct cleanup *cleanup = make_cleanup_fclose (procfile);

	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered (_("Process: %d\n"), itmp);
	  if (fscanf (procfile, "(%[^)]) ", &buffer[0]) > 0)
	    printf_filtered (_("Exec file: %s\n"), buffer);
	  if (fscanf (procfile, "%c ", &ctmp) > 0)
	    printf_filtered (_("State: %c\n"), ctmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered (_("Parent process: %d\n"), itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered (_("Process group: %d\n"), itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered (_("Session id: %d\n"), itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered (_("TTY: %d\n"), itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered (_("TTY owner process group: %d\n"), itmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)
	    printf_filtered (_("Flags: 0x%lx\n"), ltmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)
	    printf_filtered (_("Minor faults (no memory page): %lu\n"),
			     (unsigned long) ltmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)
	    printf_filtered (_("Minor faults, children: %lu\n"),
			     (unsigned long) ltmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)
	    printf_filtered (_("Major faults (memory page faults): %lu\n"),
			     (unsigned long) ltmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)
	    printf_filtered (_("Major faults, children: %lu\n"),
			     (unsigned long) ltmp);
	  if (fscanf (procfile, "%ld ", &ltmp) > 0)
	    printf_filtered (_("utime: %ld\n"), ltmp);
	  if (fscanf (procfile, "%ld ", &ltmp) > 0)
	    printf_filtered (_("stime: %ld\n"), ltmp);
	  if (fscanf (procfile, "%ld ", &ltmp) > 0)
	    printf_filtered (_("utime, children: %ld\n"), ltmp);
	  if (fscanf (procfile, "%ld ", &ltmp) > 0)
	    printf_filtered (_("stime, children: %ld\n"), ltmp);
	  if (fscanf (procfile, "%ld ", &ltmp) > 0)
	    printf_filtered (_("jiffies remaining in current "
			       "time slice: %ld\n"), ltmp);
	  if (fscanf (procfile, "%ld ", &ltmp) > 0)
	    printf_filtered (_("'nice' value: %ld\n"), ltmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)
	    printf_filtered (_("jiffies until next timeout: %lu\n"),
			     (unsigned long) ltmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)
	    printf_filtered (_("jiffies until next SIGALRM: %lu\n"),
			     (unsigned long) ltmp);
	  if (fscanf (procfile, "%ld ", &ltmp) > 0)
	    printf_filtered (_("start time (jiffies since "
			       "system boot): %ld\n"), ltmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)
	    printf_filtered (_("Virtual memory size: %lu\n"),
			     (unsigned long) ltmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)
	    printf_filtered (_("Resident set size: %lu\n"),
			     (unsigned long) ltmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)
	    printf_filtered (_("rlim: %lu\n"), (unsigned long) ltmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)
	    printf_filtered (_("Start of text: 0x%lx\n"), ltmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)
	    printf_filtered (_("End of text: 0x%lx\n"), ltmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)
	    printf_filtered (_("Start of stack: 0x%lx\n"), ltmp);
#if 0	/* Don't know how architecture-dependent the rest is...
	   Anyway the signal bitmap info is available from "status".  */
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)	/* FIXME arch?  */
	    printf_filtered (_("Kernel stack pointer: 0x%lx\n"), ltmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)	/* FIXME arch?  */
	    printf_filtered (_("Kernel instr pointer: 0x%lx\n"), ltmp);
	  if (fscanf (procfile, "%ld ", &ltmp) > 0)
	    printf_filtered (_("Pending signals bitmap: 0x%lx\n"), ltmp);
	  if (fscanf (procfile, "%ld ", &ltmp) > 0)
	    printf_filtered (_("Blocked signals bitmap: 0x%lx\n"), ltmp);
	  if (fscanf (procfile, "%ld ", &ltmp) > 0)
	    printf_filtered (_("Ignored signals bitmap: 0x%lx\n"), ltmp);
	  if (fscanf (procfile, "%ld ", &ltmp) > 0)
	    printf_filtered (_("Catched signals bitmap: 0x%lx\n"), ltmp);
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)	/* FIXME arch?  */
	    printf_filtered (_("wchan (system call): 0x%lx\n"), ltmp);
#endif
	  do_cleanups (cleanup);
	}
      else
	warning (_("unable to open /proc file '%s'"), fname1);
    }
}

a5096 1
  t->to_info_proc = linux_nat_info_proc;
@


1.233
log
@2012-01-19  Pedro Alves  <palves@@redhat.com>

	* linux-nat.c (linux_nat_close): Call linux_nat_is_async_p and
	linux_nat_async directly instead of going through the target
	vector.
	* target.c (unpush_target): Close target after unpushing it, not
	before.
@
text
@a4805 27
enum info_proc_what
  {
    /* Display the default cmdline, cwd and exe outputs.  */
    IP_MINIMAL,

    /* Display `info proc mappings'.  */
    IP_MAPPINGS,

    /* Display `info proc status'.  */
    IP_STATUS,

    /* Display `info proc stat'.  */
    IP_STAT,

    /* Display `info proc cmdline'.  */
    IP_CMDLINE,

    /* Display `info proc exe'.  */
    IP_EXE,

    /* Display `info proc cwd'.  */
    IP_CWD,

    /* Display all of the above.  */
    IP_ALL
  };

d4807 2
a4808 1
linux_nat_info_proc_cmd_1 (char *args, enum info_proc_what what, int from_tty)
a5048 64
/* Implement `info proc' when given without any futher parameters.  */

static void
linux_nat_info_proc_cmd (char *args, int from_tty)
{
  linux_nat_info_proc_cmd_1 (args, IP_MINIMAL, from_tty);
}

/* Implement `info proc mappings'.  */

static void
linux_nat_info_proc_cmd_mappings (char *args, int from_tty)
{
  linux_nat_info_proc_cmd_1 (args, IP_MAPPINGS, from_tty);
}

/* Implement `info proc stat'.  */

static void
linux_nat_info_proc_cmd_stat (char *args, int from_tty)
{
  linux_nat_info_proc_cmd_1 (args, IP_STAT, from_tty);
}

/* Implement `info proc status'.  */

static void
linux_nat_info_proc_cmd_status (char *args, int from_tty)
{
  linux_nat_info_proc_cmd_1 (args, IP_STATUS, from_tty);
}

/* Implement `info proc cwd'.  */

static void
linux_nat_info_proc_cmd_cwd (char *args, int from_tty)
{
  linux_nat_info_proc_cmd_1 (args, IP_CWD, from_tty);
}

/* Implement `info proc cmdline'.  */

static void
linux_nat_info_proc_cmd_cmdline (char *args, int from_tty)
{
  linux_nat_info_proc_cmd_1 (args, IP_CMDLINE, from_tty);
}

/* Implement `info proc exe'.  */

static void
linux_nat_info_proc_cmd_exe (char *args, int from_tty)
{
  linux_nat_info_proc_cmd_1 (args, IP_EXE, from_tty);
}

/* Implement `info proc all'.  */

static void
linux_nat_info_proc_cmd_all (char *args, int from_tty)
{
  linux_nat_info_proc_cmd_1 (args, IP_ALL, from_tty);
}

d5343 1
a5853 37
  static struct cmd_list_element *info_proc_cmdlist;

  add_prefix_cmd ("proc", class_info, linux_nat_info_proc_cmd,
		  _("\
Show /proc process information about any running process.\n\
Specify any process id, or use the program being debugged by default."),
		  &info_proc_cmdlist, "info proc ",
		  1/*allow-unknown*/, &infolist);

  add_cmd ("mappings", class_info, linux_nat_info_proc_cmd_mappings, _("\
List of mapped memory regions."),
	   &info_proc_cmdlist);

  add_cmd ("stat", class_info, linux_nat_info_proc_cmd_stat, _("\
List process info from /proc/PID/stat."),
	   &info_proc_cmdlist);

  add_cmd ("status", class_info, linux_nat_info_proc_cmd_status, _("\
List process info from /proc/PID/status."),
	   &info_proc_cmdlist);

  add_cmd ("cwd", class_info, linux_nat_info_proc_cmd_cwd, _("\
List current working directory of the process."),
	   &info_proc_cmdlist);

  add_cmd ("cmdline", class_info, linux_nat_info_proc_cmd_cmdline, _("\
List command line arguments of the process."),
	   &info_proc_cmdlist);

  add_cmd ("exe", class_info, linux_nat_info_proc_cmd_exe, _("\
List absolute filename for executable of the process."),
	   &info_proc_cmdlist);

  add_cmd ("all", class_info, linux_nat_info_proc_cmd_all, _("\
List all available /proc info."),
	   &info_proc_cmdlist);

@


1.232
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d5720 2
a5721 2
  if (target_is_async_p ())
    target_async (NULL, 0);
@


1.231
log
@2011-12-20  Pedro Alves  <alves.ped@@gmail.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

        * linux-nat.c (add_lwp): Don't call linux_nat_new_thread on the
	first LWP.
	* amd64-linux-nat.c (update_debug_registers_callback): Instantiate
	`lwp->arch_private' if NULL.
	(amd64_linux_prepare_to_resume): Do nothing if `lwp->arch_private'
	is NULL.
	* i386-linux-nat.c (update_debug_registers_callback): Instantiate
	`lwp->arch_private' if NULL.
	(i386_linux_prepare_to_resume): Do nothing if `lwp->arch_private'
	is NULL.
@
text
@d3 1
a3 2
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
   2011 Free Software Foundation, Inc.
@


1.230
log
@gdb/
2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	PR threads/10729

	* linux-nat.c (linux_nat_new_thread): Change parameter to an lwp
	pointer.
	(linux_nat_prepare_to_resume): New global.
	(lwp_free): New.
	(purge_lwp_list): Use it.
	(add_lwp): Call linux_nat_new_thread even on the first LWP.
	Adjust to interface change.
	(delete_lwp): Call lwp_free instead of xfree.
	(detach_callback, linux_nat_detach, resume_lwp, linux_nat_resume)
	(linux_handle_syscall_trap, linux_handle_extended_wait)
	(linux_nat_filter_event, resume_stopped_resumed_lwps): Call
	linux_nat_prepare_to_resume before resuming.
	(linux_stop_lwp): New.
	(linux_nat_set_new_thread): Adjust.
	(linux_nat_set_prepare_to_resume): New.
	* linux-nat.h (struct arch_lwp_info): Forward declare.
	(struct lwp_info) <arch_private>: New field.
	(linux_stop_lwp): Declare.
	(linux_nat_set_new_thread): Adjust.
	(linux_nat_set_prepare_to_resume): New.

	* i386-nat.c (DR_NADDR, DR_STATUS, DR_CONTROL)
	(struct i386_debug_reg_state): Move to i386-nat.h.
	(dr_mirror): Comment.
	(i386_debug_reg_state): New.
	(i386_update_inferior_debug_regs): Simplify.
	(i386_stopped_data_address): Use the debug register state from the
	inferior, not from the local cache.
	* i386-nat.h (struct i386_dr_low_type): Delete reset_addr and
	unset_status fields.  New get_addr and get_control fields.
	(DR_FIRSTADDR, DR_LASTADDR, DR_CONTROL): Moved from i386-nat.c.
	(DR_NADDR, DR_STATUS): New.
	(struct i386_debug_reg_state): Moved from i386-nat.c.

	* amd64-linux-nat.c (struct arch_lwp_info): New.
	(amd64_linux_dr): Delete global.
	(amd64_linux_dr_get_addr): New.
	(amd64_linux_dr_get_control): New.
	(amd64_linux_dr_unset_status): Delete.
	(amd64_linux_dr_set_addr): Reimplement.
	(amd64_linux_dr_reset_addr): Delete.
	(update_debug_registers_callback): New.
	(amd64_linux_dr_set_control): Reimplement.
	(amd64_linux_dr_set_addr): Reimplement.
	(amd64_linux_prepare_to_resume): New.
	(amd64_linux_new_thread): Change parameter to an lwp pointer.
	Reimplement.
	(_initialize_amd64_linux_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	amd64_linux_dr_get_control as i386_dr_low.get_control.  Install
	amd64_linux_dr_get_addr as i386_dr_low.get_addr.  Install
	amd64_linux_prepare_to_resume.
	* i386-linux-nat.c (DR_FIRSTADDR, DR_LASTADDR, DR_STATUS)
	(DR_CONTROL): Delete.
	(struct arch_lwp_info): New.
	(i386_linux_dr): Delete global.
	(i386_linux_dr_set_control): Reimplement.
	(i386_linux_dr_get_addr): New.
	(i386_linux_dr_set_addr): Reimplement.
	(i386_linux_dr_get_control): New.
	(update_debug_registers_callback): New.
	(i386_linux_dr_unset_status): Delete.
	(i386_linux_dr_set_addr): Reimplement.
	(i386_linux_prepare_to_resume): New.
	(i386_linux_new_thread): Change parameter to an lwp pointer.
	Reimplement.
	(_initialize_i386_linux_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	i386_linux_dr_get_control as i386_dr_low.get_control.  Install
	i386_linux_dr_get_addr as i386_dr_low.get_addr.  Install
	i386_linux_prepare_to_resume.

	* arm-linux-nat.c (arm_linux_new_thread): Change parameter to an
	lwp pointer.  Adjust.
	* ia64-linux-nat.c (ia64_linux_new_thread): Likewise.
	* mips-linux-nat.c (mips_linux_new_thread): Likewise.
	* ppc-linux-nat.c (ppc_linux_new_thread): Likewise.
	* s390-nat.c (s390_fix_watch_points): Likewise.

	* i386-darwin-nat.c (DR_FIRSTADDR, DR_LASTADDR, DR_STATUS)
	(DR_CONTROL): Delete.
	(i386_darwin_dr_reset_addr): Delete.
	(i386_darwin_dr_get_addr): New.
	(i386_darwin_dr_get_control): New.
	* go32-nat.c
	(go32_get_dr7, go32_get_dr): New.
	(init_go32_ops): No longer install i386_dr_low.reset_addr.
	Install go32_get_dr7 as i386_dr_low.get_control.  Install
	go32_get_dr as i386_dr_low.get_addr.
	* i386bsd-nat.c (i386bsd_dr_get): New.
	(i386bsd_dr_reset_addr): Delete.
	(i386bsd_dr_get_addr): New.
	(i386bsd_dr_get_status): Use i386bsd_dr_get.
	(i386bsd_dr_get_control): New.
	* i386bsd-nat.h (i386bsd_dr_reset_addr): Delete.
	(i386bsd_dr_get_addr): New.
	(i386bsd_dr_get_control): New.
	* i386fbsd-nat.c (_initialize_i386fbsd_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	i386bsd_dr_get_control as i386_dr_low.get_control.  Install
	i386bsd_dr_get_addr as i386_dr_low.get_addr.
	* windows-nat.c (init_windows_ops): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	cygwin_get_dr7 as i386_dr_low.get_control.  Install cygwin_get_dr
	as i386_dr_low.get_addr.
	(cygwin_get_dr): New.
	(cygwin_get_dr7): New.

gdb/testsuite/
2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	PR threads/10729

	* gdb.mi/watch-nonstop.c: New file.
 	* gdb.mi/mi-watch-nonstop.exp: New file.
@
text
@d1154 9
a1162 1
  if (linux_nat_new_thread != NULL)
@


1.229
log
@2011-12-05  Pedro Alves  <pedro@@codesourcery.com>

	* linux-nat.c (resume_stopped_resumed_lwps): Call
	registers_changed.
@
text
@d178 4
a181 1
static void (*linux_nat_new_thread) (ptid_t);
d1079 9
d1108 1
a1108 1
	  xfree (lp);
d1154 2
a1155 2
  if (num_lwps (GET_PID (ptid)) > 1 && linux_nat_new_thread != NULL)
    linux_nat_new_thread (ptid);
d1181 1
a1181 1
  xfree (lp);
d1739 2
d1801 2
d1844 2
d1990 2
d2161 2
d2350 2
d2361 2
d2626 8
d3370 2
d3403 2
d3579 2
d3830 2
d3988 2
d5887 2
a5888 1
linux_nat_set_new_thread (struct target_ops *t, void (*new_thread) (ptid_t))
d5909 10
@


1.229.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2001-2012 Free Software Foundation, Inc.
@


1.228
log
@2011-11-10  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* linux-nat.c (linux_nat_wait): Don't force waking up the event
	loop when returning a TARGET_WAITKIND_NO_RESUMED.
@
text
@d3924 4
a3933 3
	  struct regcache *regcache = get_thread_regcache (lp->ptid);
	  CORE_ADDR pc = regcache_read_pc (regcache);

d3940 4
a3943 2
			    "RSRL: resuming stopped-resumed LWP %s\n",
			    target_pid_to_str (lp->ptid));
d3945 1
@


1.227
log
@gdb/
	* linux-nat.c (_initialize_linux_nat): Improve help
	for `info proc stat', `info proc status', `info proc cwd',
	`info proc cmdline' and `info proc exe'.
@
text
@d3983 2
a3984 1
      && (ourstatus->kind != TARGET_WAITKIND_IGNORE
@


1.226
log
@gdb/
	* linux-nat.c: Include cli/cli-utils.h.
	(enum info_proc_what): New.
	(linux_nat_info_proc_cmd): Rename to ...
	(linux_nat_info_proc_cmd_1): ... here.  Remove variables argv and all.
	New parameter what.  Initialize cmdline_f, cwd_f, exe_f, mappings_f,
	status_f and stat_f from WHAT.  Throw error on extra parameters.
	(linux_nat_info_proc_cmd, linux_nat_info_proc_cmd_mappings)
	(linux_nat_info_proc_cmd_stat, linux_nat_info_proc_cmd_status)
	(linux_nat_info_proc_cmd_cwd, linux_nat_info_proc_cmd_cmdline)
	(linux_nat_info_proc_cmd_exe, linux_nat_info_proc_cmd_all): New.
	(_initialize_linux_nat): New variable info_proc_cmdlist.  Install `info
	proc mappings', `info proc stat`, `info proc status', `info proc cwd',
	`info proc cmdline', `info proc exe' and `info proc all' as real
	subcommands of `info proc'.
@
text
@d5890 1
a5890 1
List a bunch of random process info."),
d5894 1
a5894 1
List a different bunch of random process info."),
d5898 1
a5898 1
List a different bunch of random process info."),
d5902 1
a5902 1
List a different bunch of random process info."),
d5906 1
a5906 1
List a different bunch of random process info."),
@


1.225
log
@2011-10-28  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* linux-nat.c (linux_nat_filter_event): Remove `options'
	parameter, and dead code that used it.  If we're handling a
	PTRACE_EVENT_EXEC event, and the thread group leader is no longer
	in our lwp list, re-add it.
	(check_zombie_leaders): New.
	(linux_nat_wait_1): Remove `options' and `pid' locals.  Always
	wait for children with WNOHANG, and always wait for all children.
	Don't check for no resumed children upfront.  Simplify wait loop.
	Check for zombie thread group leaders after handling all wait
	statuses.  Return TARGET_WAITKIND_NO_RESUMED if there no
	unwaited-for children left.
	* infrun.c (fetch_inferior_event): Handle TARGET_WAITKIND_NO_RESUMED.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_RESUMED.
	(normal_stop): Handle TARGET_WAITKIND_NO_RESUMED.
	* target.h (enum target_waitkind) <TARGET_WAITKIND_NO_RESUMED>: New.

	gdb/testsuite/
	* gdb.threads/no-unwaited-for-left.c: New.
	* gdb.threads/no-unwaited-for-left.exp: New.
	* gdb.threads/non-ldr-exc-1.c: New.
	* gdb.threads/non-ldr-exc-1.exp: New.
	* gdb.threads/non-ldr-exc-2.c: New.
	* gdb.threads/non-ldr-exc-2.exp: New.
	* gdb.threads/non-ldr-exc-3.c: New.
	* gdb.threads/non-ldr-exc-3.exp: New.
	* gdb.threads/non-ldr-exc-4.c: New.
	* gdb.threads/non-ldr-exc-4.exp: New.
@
text
@d62 1
d4750 27
d4778 1
a4778 1
linux_nat_info_proc_cmd (char *args, int from_tty)
a4783 1
  char **argv = NULL;
d4786 6
a4791 7
  int cmdline_f = 1;
  int cwd_f = 1;
  int exe_f = 1;
  int mappings_f = 0;
  int status_f = 0;
  int stat_f = 0;
  int all = 0;
d4794 7
a4800 46
  if (args)
    {
      /* Break up 'args' into an argv array.  */
      argv = gdb_buildargv (args);
      make_cleanup_freeargv (argv);
    }
  while (argv != NULL && *argv != NULL)
    {
      if (isdigit (argv[0][0]))
	{
	  pid = strtoul (argv[0], NULL, 10);
	}
      else if (strncmp (argv[0], "mappings", strlen (argv[0])) == 0)
	{
	  mappings_f = 1;
	}
      else if (strcmp (argv[0], "status") == 0)
	{
	  status_f = 1;
	}
      else if (strcmp (argv[0], "stat") == 0)
	{
	  stat_f = 1;
	}
      else if (strcmp (argv[0], "cmd") == 0)
	{
	  cmdline_f = 1;
	}
      else if (strncmp (argv[0], "exe", strlen (argv[0])) == 0)
	{
	  exe_f = 1;
	}
      else if (strcmp (argv[0], "cwd") == 0)
	{
	  cwd_f = 1;
	}
      else if (strncmp (argv[0], "all", strlen (argv[0])) == 0)
	{
	  all = 1;
	}
      else
	{
	  /* [...] (future options here).  */
	}
      argv++;
    }
d4809 1
a4809 1
  if (cmdline_f || all)
d4825 1
a4825 1
  if (cwd_f || all)
d4834 1
a4834 1
  if (exe_f || all)
d4843 1
a4843 1
  if (mappings_f || all)
d4905 1
a4905 1
  if (status_f || all)
d4919 1
a4919 1
  if (stat_f || all)
d5019 64
d5876 4
a5879 1
  add_info ("proc", linux_nat_info_proc_cmd, _("\
d5881 31
a5911 6
Specify any process id, or use the program being debugged by default.\n\
Specify any of the following keywords for detailed info:\n\
  mappings -- list of mapped memory regions.\n\
  stat     -- list a bunch of random process info.\n\
  status   -- list a different bunch of random process info.\n\
  all      -- list all available /proc info."));
@


1.224
log
@2011-10-24  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* linux-nat.c (linux_handle_extended_wait): When handling a clone
	event, in non-stop, if not stopping, make sure the new lwp has
	last_resume_kind set to resume_continue.  Assert that when we're
	resuming the new lwp, its last_resume_kind is resume_continue.
@
text
@d3179 1
a3179 1
linux_nat_filter_event (int lwpid, int status, int options, int *new_pending_p)
d3194 21
a3214 1
     from waitpid before or after the event is.  */
a3227 27
  /* NOTE drow/2003-06-17: This code seems to be meant for debugging
     CLONE_PTRACE processes which do not use the thread library -
     otherwise we wouldn't find the new LWP this way.  That doesn't
     currently work, and the following code is currently unreachable
     due to the two blocks above.  If it's fixed some day, this code
     should be broken out into a function so that we can also pick up
     LWPs from the new interface.  */
  if (!lp)
    {
      lp = add_lwp (BUILD_LWP (lwpid, GET_PID (inferior_ptid)));
      if (options & __WCLONE)
	lp->cloned = 1;

      gdb_assert (WIFSTOPPED (status)
		  && WSTOPSIG (status) == SIGSTOP);
      lp->signalled = 1;

      if (!in_thread_list (inferior_ptid))
	{
	  inferior_ptid = BUILD_LWP (GET_PID (inferior_ptid),
				     GET_PID (inferior_ptid));
	  add_thread (inferior_ptid);
	}

      add_thread (lp->ptid);
    }

d3388 65
a3460 1
  int options;
a3461 1
  pid_t pid;
a3482 11
  if (ptid_equal (ptid, minus_one_ptid))
    pid = -1;
  else if (ptid_is_pid (ptid))
    /* A request to wait for a specific tgid.  This is not possible
       with waitpid, so instead, we wait for any child, and leave
       children we're not interested in right now with a pending
       status to report later.  */
    pid = -1;
  else
    pid = GET_LWP (ptid);

a3485 16
  options = 0;

  /* Make sure that of those LWPs we want to get an event from, there
     is at least one LWP that has been resumed.  If there's none, just
     bail out.  The core may just be flushing asynchronously all
     events.  */
  if (iterate_over_lwps (ptid, resumed_callback, NULL) == NULL)
    {
      ourstatus->kind = TARGET_WAITKIND_IGNORE;

      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog, "LLW: exit (no resumed LWP)\n");

      restore_child_signals_mask (&prev_mask);
      return minus_one_ptid;
    }
d3488 1
a3488 1
  if (pid == -1)
d3490 1
a3490 1
      /* Any LWP that's been resumed will do.  */
a3499 5

      /* But if we don't find one, we'll have to wait, and check both
	 cloned and uncloned processes.  We start with the cloned
	 processes.  */
      options = __WCLONE | WNOHANG;
a3517 6
      /* If we have to wait, take into account whether PID is a cloned
         process or not.  And we have to convert it to something that
         the layer beneath us can understand.  */
      options = lp->cloned ? __WCLONE : 0;
      pid = GET_LWP (ptid);

d3578 1
a3578 3
  /* Translate generic target_wait options into waitpid options.  */
  if (target_options & TARGET_WNOHANG)
    options |= WNOHANG;
d3584 22
a3605 1
      lwpid = my_waitpid (pid, &status, options);
a3612 2
	  gdb_assert (pid == -1 || lwpid == pid);

d3620 1
a3620 1
	  lp = linux_nat_filter_event (lwpid, status, options, &new_pending);
d3625 1
a3625 3
	  if (lp
	      && ptid_is_pid (ptid)
	      && ptid_get_pid (lp->ptid) != ptid_get_pid (ptid))
a3697 3
	      if (new_pending)
		goto retry;

d3700 7
a3706 1
	      continue;
a3709 2
	    break;
	  else
d3711 3
a3713 2
	      if (new_pending)
		goto retry;
d3715 3
a3717 7
	      if (pid == -1)
		{
		  /* waitpid did return something.  Restart over.  */
		  options |= __WCLONE;
		}
	      continue;
	    }
d3720 7
a3726 1
      if (pid == -1)
d3728 2
a3729 2
	  /* Alternate between checking cloned and uncloned processes.  */
	  options ^= __WCLONE;
d3731 4
a3734 9
	  /* And every time we have checked both:
	     In async mode, return to event loop;
	     In sync mode, suspend waiting for a SIGCHLD signal.  */
	  if (options & __WCLONE)
	    {
	      if (target_options & TARGET_WNOHANG)
		{
		  /* No interesting event.  */
		  ourstatus->kind = TARGET_WAITKIND_IGNORE;
d3736 3
a3738 2
		  if (debug_linux_nat)
		    fprintf_unfiltered (gdb_stdlog, "LLW: exit (ignore)\n");
d3740 1
a3740 3
		  restore_child_signals_mask (&prev_mask);
		  return minus_one_ptid;
		}
d3742 1
a3742 4
	      sigsuspend (&suspend_mask);
	    }
	}
      else if (target_options & TARGET_WNOHANG)
a3743 3
	  /* No interesting event for PID yet.  */
	  ourstatus->kind = TARGET_WAITKIND_IGNORE;

d3747 1
d3754 3
d3845 1
a3845 1
      if (pid == -1)
@


1.223
log
@2011-10-12  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* linux-nat.c (stop_and_resume_callback): Don't re-resume LWPs if
	the core wanted them stopped, or if they now have a pending event
	to report.
@
text
@d2292 3
d2322 1
@


1.222
log
@2011-10-11  Pedro Alves  <pedro@@codesourcery.com>

	* linux-nat.c (linux_handle_extended_wait): Always dump both the
	parent and child's pids as soon as we detect a clone event.
	Adjust another debug message.
@
text
@d3112 3
a3114 1
/* Stop an active thread, verify it still exists, then resume it.  */
d3119 2
a3122 1
      enum resume_kind last_resume_kind = lp->last_resume_kind;
d3130 2
a3131 1
      if (last_resume_kind != resume_stop)
d3133 31
a3163 3
	  lp = find_lwp_pid (ptid);
	  if (lp)
	    resume_lwp (lp, lp->step);
d3170 4
a3173 1
   Return the affected lwp if we are, or NULL otherwise.  */
d3175 1
a3175 1
linux_nat_filter_event (int lwpid, int status, int options)
d3179 2
d3280 1
a3280 1
			     stop_and_resume_callback, NULL);
d3398 3
a3400 3
  struct lwp_info *lp = NULL;
  int options = 0;
  int status = 0;
d3437 1
d3568 4
d3581 1
a3581 1
	  lp = linux_nat_filter_event (lwpid, status, options);
d3661 3
d3673 3
@


1.221
log
@2011-10-11  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* linux-nat.c (linux_lwp_is_zombie): Return early if the LWP is
	not zombie instead of reading the whole file.
@
text
@d2221 6
d2331 1
a2331 3
				"LHEW: Got clone event "
				"from LWP %ld, resuming\n",
				GET_LWP (lp->ptid));
@


1.220
log
@	* linux-thread-db.c (thread_db_new_objfile): Only try to load
	libthread_db when we load libpthread or the main symbol file.
	(thread_db_inferior_created): New function.
	(_initialize_thread_db): Attach inferior_created observer.
	* linux-nat.c (linux_child_post_attach): Remove call to
	check_for_thread_db.
	(linux_child_post_startup_inferior): Ditto.
	* objfiles.h (OBJF_MAINLINE): Define.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Pass it to
	allocate_objfile when appropriate.
@
text
@d2385 2
a2386 1
  int retval = 0;
d2395 2
d2398 1
a2398 1
    if (strcmp (buffer, "State:\tZ (zombie)\n") == 0)
d2400 1
a2400 1
	retval = 1;
d2403 2
a2405 1

@


1.219
log
@2011-10-10  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* linux-nat.c (linux_handle_extended_wait): Don't resume the new
	new clone lwp if the core asked it to stop.  Don't pass on
	unexpected signals to the new clone; leave them pending instead.
@
text
@a573 1
  check_for_thread_db ();
a580 1
  check_for_thread_db ();
@


1.218
log
@2011-10-10  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* linux-nat.c (resume_lwp): Remove redundant debug output.
@
text
@d2240 23
a2262 1
	    status = 0;
d2291 15
a2310 3
	      enum target_signal signo;

	      new_lp->stopped = 0;
a2311 5
	      new_lp->last_resume_kind = resume_continue;

	      signo = (status
		       ? target_signal_from_host (WSTOPSIG (status))
		       : TARGET_SIGNAL_0);
d2313 1
a2313 6
	      linux_ops->to_resume (linux_ops, pid_to_ptid (new_pid),
				    0, signo);
	    }
	  else
	    {
	      if (status != 0)
a2314 4
		  /* We created NEW_LP so it cannot yet contain STATUS.  */
		  gdb_assert (new_lp->status == 0);

		  /* Save the wait status to report later.  */
d2317 5
a2321 5
					"LHEW: waitpid of new LWP %ld, "
					"saving status %s\n",
					(long) GET_LWP (new_lp->ptid),
					status_to_str (status));
		  new_lp->status = status;
@


1.217
log
@2011-10-10  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* linux-nat.c (linux_nat_wait_1): Copy the event lwp's
	last_resume_kind before clearing it, and use the copy instead to
	determine whether to report a SIGSTOP as TARGET_SIGNAL_0.  Use
	resume_clear_callback in the non-stop path too.
@
text
@a1831 4
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"RC:  PTRACE_CONT %s, 0, 0 (resume sibling)\n",
				target_pid_to_str (lp->ptid));
@


1.216
log
@	* inferior.h (disable_randomization): Declare.
	* infrun.c (disable_randomization): New global variable.
	(show_disable_randomization): New function.
	(set_disable_randomization): Likewise.
	(_initialize_infrun): Install set/show disable-randomization
	commands.
	* linux-nat.c (disable_randomization): Remove.
	(show_disable_randomization): Likewise.
	(set_disable_randomization): Likewise.
	(_initialize_linux_nat): No longer install set/show
	disable-randomization commands here.
	(linux_nat_supports_disable_randomization): New function.
	(linux_nat_add_target): Install it.
	* remote.c (PACKET_QDisableRandomization): New enum value.
	(remote_protocol_packets): Support QDisableRandomization.
	(_initialize_remote): Likewise.
	(remote_supports_disable_randomization): New function.
	(init_remote_ops): Install it.
	(extended_remote_supports_disable_randomization): New function.
	(init_extended_remote_ops): Install it.
	(extended_remote_disable_randomization): New function.
	(extended_remote_create_inferior_1): Call it.
	* target.h (struct target_ops): Add to_supports_disable_randomization.
	(target_supports_disable_randomization): Add prototype.
	* target.c (target_supports_disable_randomization): New function.
	(find_default_supports_disable_randomization): Likewise.
	(init_dummy_target): Install it.

doc/
	* gdb.texinfo (Starting your Program): "set disable-randomization"
	is no longer Linux-specific.
	(Remote Configuration): Document "set remote
	disable-randomization-packet".
	(General Query Packets): Document "QDisableRandomization" packet
	and add it to "qSupported" list.

gdbserver/
	* configure.ac: Check support for personality routine.
	* configure: Regenerate.
	* config.in: Likewise.
	* linux-low.c: Include <sys/personality.h>.
	Define ADDR_NO_RANDOMIZE if necessary.
	(linux_create_inferior): Disable address space randomization when
	forking inferior, if requested.
	(linux_supports_disable_randomization): New function.
	(linux_target_ops): Install it.
	* server.h (disable_randomization): Declare.
	* server.c (disable_randomization): New global variable.
	(handle_general_set): Handle QDisableRandomization.
	(handle_query): Likewise for qSupported.
	(main): Support --disable-randomization and --no-disable-randomization
	command line arguments.
	* target.h (struct target_ops): Add supports_disable_randomization.
	(target_supports_disable_randomization): New macro.
@
text
@d3338 1
d3751 5
d3762 3
a3764 2
      lp->resumed = 0;
      lp->last_resume_kind = resume_stop;
d3788 1
a3788 1
  if (lp->last_resume_kind == resume_stop
@


1.215
log
@2011-09-09  Pedro Alves  <pedro@@codesourcery.com>

	* linux-nat.h (enum resume_kind): New.
	(struct lwp_info) <last_resume_kind>: New field.
	(linux_child_follow_fork): Set last_resume_kind to resume_stop on
	the new lwp.
	(add_lwp): Set last_resume_kind as resume_continue by default.
	(lin_lwp_attach_lwp): Set last_resume_kind as resume_stop.
	(resume_lwp): New, factored out from resume_callback.  Also check
	for pending status in lp->waitstatus.
	(resume_callback): Reimplement.
	(resume_clear_callback): Set last_resume_kind as resume_stop.
	(resume_set_callback): Set last_resume_kind as resume_continue.
	(linux_nat_resume, linux_handle_extended_wait): Set
	last_resume_kind.
	(running_callback): Also check lp->waitstatus for pending events.
	(select_singlestep_lwp_callback): Check that lp->last_resume_kind
	is resume_step.
	(stop_and_resume_callback): Don't re-resume if the core wanted the
	lwp stopped.  Use resume_lwp instead of resume_callback.  Avoid
	using an invalidated pointer.
	(linux_nat_filter_event): Don't discard SIGSTOPs as delayed
	SIGSTOPs if the core wanted the LWP to stop.
	(linux_nat_wait_1) Don't consume a pending SIGSTOP if the core
	wanted the lwp to stop.  If the core wanted the lwp to stop, and
	the lwp stopped with a SIGSTOP, report a TARGET_SIGNAL_0 instead
	of TARGET_SIGNAL_STOP.
	(linux_nat_stop_lwp): Don't synchronously wait for the lwp to stop
	here.  Instead, signal the lwp, and set the last_resume_kind to
	resume_stop.
@
text
@a202 29
static int disable_randomization = 1;

static void
show_disable_randomization (struct ui_file *file, int from_tty,
			    struct cmd_list_element *c, const char *value)
{
#ifdef HAVE_PERSONALITY
  fprintf_filtered (file,
		    _("Disabling randomization of debuggee's "
		      "virtual address space is %s.\n"),
		    value);
#else /* !HAVE_PERSONALITY */
  fputs_filtered (_("Disabling randomization of debuggee's "
		    "virtual address space is unsupported on\n"
		    "this platform.\n"), file);
#endif /* !HAVE_PERSONALITY */
}

static void
set_disable_randomization (char *args, int from_tty,
			   struct cmd_list_element *c)
{
#ifndef HAVE_PERSONALITY
  error (_("Disabling randomization of debuggee's "
	   "virtual address space is unsupported on\n"
	   "this platform."));
#endif /* !HAVE_PERSONALITY */
}

d5282 10
d5661 3
a5748 11

  add_setshow_boolean_cmd ("disable-randomization", class_support,
			   &disable_randomization, _("\
Set disabling of debuggee's virtual address space randomization."), _("\
Show disabling of debuggee's virtual address space randomization."), _("\
When this mode is on (which is the default), randomization of the virtual\n\
address space is disabled.  Standalone programs run with the randomization\n\
enabled by default on some platforms."),
			   &set_disable_randomization,
			   &show_disable_randomization,
			   &setlist, &showlist);
@


1.214
log
@2011-09-09  Pedro Alves  <pedro@@codesourcery.com>

	* linux-nat.c (lin_lwp_attach_lwp): Return 1 (ignore) instead of
	-1 (error), if the lwp exits right after attaching.
@
text
@d704 1
d895 1
d1163 1
d1521 1
d1836 2
a1837 2
static int
resume_callback (struct lwp_info *lp, void *data)
d1839 18
a1856 1
  struct inferior *inf = find_inferior_pid (GET_PID (lp->ptid));
d1858 19
a1876 6
  if (lp->stopped && inf->vfork_child != NULL)
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "RC: Not resuming %s (vfork parent)\n",
			    target_pid_to_str (lp->ptid));
d1878 1
a1878 1
  else if (lp->stopped && lp->status == 0)
d1882 1
a1882 9
			    "RC:  PTRACE_CONT %s, 0, 0 (resuming sibling)\n",
			    target_pid_to_str (lp->ptid));

      linux_ops->to_resume (linux_ops,
			    pid_to_ptid (GET_LWP (lp->ptid)),
			    0, TARGET_SIGNAL_0);
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "RC:  PTRACE_CONT %s, 0, 0 (resume sibling)\n",
a1883 4
      lp->stopped = 0;
      lp->step = 0;
      memset (&lp->siginfo, 0, sizeof (lp->siginfo));
      lp->stopped_by_watchpoint = 0;
d1885 1
a1885 8
  else if (lp->stopped && debug_linux_nat)
    fprintf_unfiltered (gdb_stdlog,
			"RC: Not resuming sibling %s (has pending)\n",
			target_pid_to_str (lp->ptid));
  else if (debug_linux_nat)
    fprintf_unfiltered (gdb_stdlog,
			"RC: Not resuming sibling %s (not stopped)\n",
			target_pid_to_str (lp->ptid));
d1887 4
d1898 1
d1906 1
d1946 1
d2311 1
d2944 4
a2947 1
  return (lp->stopped == 0 || (lp->status != 0 && lp->resumed));
d2971 2
a2972 1
  if (lp->step && lp->status != 0)
d3124 4
a3127 1
  struct lwp_info *ptr;
a3128 2
  if (!lp->stopped && !lp->signalled)
    {
d3131 9
a3139 7
      /* Resume if the lwp still exists.  */
      for (ptr = lwp_list; ptr; ptr = ptr->next)
	if (lp == ptr)
	  {
	    resume_callback (lp, NULL);
	    resume_set_callback (lp, NULL);
	  }
a3299 1
      /* This is a delayed SIGSTOP.  */
d3302 5
a3306 1
      registers_changed ();
d3308 1
a3308 1
      linux_ops->to_resume (linux_ops, pid_to_ptid (GET_LWP (lp->ptid)),
d3310 6
a3315 6
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: %s %s, 0, 0 (discard SIGSTOP)\n",
			    lp->step ?
			    "PTRACE_SINGLESTEP" : "PTRACE_CONT",
			    target_pid_to_str (lp->ptid));
d3317 2
a3318 2
      lp->stopped = 0;
      gdb_assert (lp->resumed);
d3320 3
a3322 2
      /* Discard the event.  */
      return NULL;
d3472 1
a3472 1
  if (lp && lp->signalled)
d3784 4
a3787 1
    lp->resumed = 0;
d3810 10
d5476 10
d5487 1
a5487 15
      stop_wait_callback (lwp, NULL);

      /* If the lwp exits while we try to stop it, there's nothing
	 else to do.  */
      lwp = find_lwp_pid (ptid);
      if (lwp == NULL)
	return 0;

      /* If we didn't collect any signal other than SIGSTOP while
	 stopping the LWP, push a SIGNAL_0 event.  In either case, the
	 event-loop will end up calling target_wait which will collect
	 these.  */
      if (lwp->status == 0)
	lwp->status = W_STOPCODE (0);
      async_file_mark ();
@


1.213
log
@2011-09-02  Pedro Alves  <pedro@@codesourcery.com>

	* linux-nat.c (in_pid_list_p): New.
	(linux_record_stopped_pid): Delete.
	(lin_lwp_attach_lwp): Check if PTRACE_ATTACH failed because we're
	already attached to the LWP.  Return an indication if so.
	(linux_nat_filter_event): Adjust.
	* linux-thread-db.c (attach_thread): Handle lin_lwp_attach_lwp
	returning an indication to ignore this thread.
@
text
@d1482 1
a1482 1
	  return -1;
@


1.212
log
@2011-08-26  Pedro Alves  <pedro@@codesourcery.com>

	* linux-nat.c (linux_child_follow_fork): Don't set lp->resumed on
	either the parent or the child forks.  Rename a couple locals.
@
text
@d334 11
a361 6
static void
linux_record_stopped_pid (int pid, int status)
{
  add_to_pid_list (&stopped_pids, pid, status);
}

d1394 5
a1398 2
/* Attach to the LWP specified by PID.  Return 0 if successful or -1
   if the new LWP could not be attached.  */
d1405 1
d1412 1
d1420 1
a1420 1
  if (GET_LWP (ptid) != GET_PID (ptid) && lp == NULL)
d1424 1
a1424 1
      if (ptrace (PTRACE_ATTACH, GET_LWP (ptid), 0, 0) < 0)
d1426 36
d3133 1
a3133 1
      linux_record_stopped_pid (lwpid, status);
@


1.211
log
@2011-08-26  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* linux-nat.c (wait_lwp): Avoid assuming errno is preserved by a
	library call.  Avoid reading the `status' local if all waitpid
	calls failed.
@
text
@a698 1
	  child_lp->resumed = 1;
d740 1
a740 1
	  struct lwp_info *lp;
d755 1
a755 1
	  lp = find_lwp_pid (pid_to_ptid (parent_pid));
d757 1
d764 1
a764 3

	      lp->stopped = 1;
	      lp->resumed = 1;
d813 3
a815 4
	      lp->status = 0;
	      lp->waitstatus.kind = TARGET_WAITKIND_VFORK_DONE;
	      lp->stopped = 0;
	      lp->resumed = 1;
d827 1
a827 1
      struct lwp_info *lp;
d887 2
a888 3
      lp = add_lwp (inferior_ptid);
      lp->stopped = 1;
      lp->resumed = 1;
@


1.210
log
@Move common linux procfs code to common/
@
text
@d2380 12
a2432 13
  if (pid == -1 && errno == ECHILD)
    {
      /* The thread has previously exited.  We need to delete it
	 now because, for some vendor 2.4 kernels with NPTL
	 support backported, there won't be an exit event unless
	 it is the main thread.  2.6 kernels will report an exit
	 event for each thread that exits, as expected.  */
      thread_dead = 1;
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog, "WL: %s vanished.\n",
			    target_pid_to_str (lp->ptid));
    }

a2443 1
    }
d2445 8
a2452 7
  /* Check if the thread has exited.  */
  if (WIFEXITED (status) || WIFSIGNALED (status))
    {
      thread_dead = 1;
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog, "WL: %s exited.\n",
			    target_pid_to_str (lp->ptid));
@


1.209
log
@2011-07-22  Kwok Cheung Yeung  <kcy@@codesourcery.com>

gdb/
	* defs.h: Add guard against inclusion in gdbserver.
	(struct ptid, ptid_t): Move to common/ptid.h.
	(xfree, xzalloc, xasprintf, xvasprintf, xstrprintf, xstrvprintf,
	xsnprintf, internal_error): Move to common/common-utils.h.
	(nomem): Delete.
	* gdb_assert.h: Move into common/ sub-directory.
	* gdb_locale.h: Ditto.
	* gdb_dirent.h: Ditto.
	* inferior.h (minus_one_ptid, null_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal, ptid_is_pid):
	Move into common/ptid.h.
	* xml-support.c (xml_escape_text): Move into common/xml-utils.c.
	(gdb_xml_create_parser_and_cleanup_1, xml_fetch_context_from_file):
	Change nomem to malloc_failure.
	* xml-support.h (xml_escape_text): Move into common/xml-utils.h.
	* utils.c (nomem): Rename to malloc_failure.
	(xmalloc, xzalloc, xrealloc, xcalloc, xfree, xstrprintf, xasprintf,
	xvasprintf, xstrvprintf, xsnprintf): Move to common/common-utils.c.
	(gdb_buildargv): Change nomem to malloc_failure.
	* infrun.c (null_ptid, minus_one_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal,
	ptid_is_pid): Move into common/ptid.c.
	(initialize_infrun): Delete initialization of null_ptid and
	minus_one_ptid.
	* linux-nat.c (linux_nat_xfer_osdata): Defer to
	linux_common_xfer_osdata.
	* Makefile.in (SFILES): Add common/common-utils.c, common/xml-utils.c,
	common/ptid.c and common/buffer.c.
	(HFILES_NO_SRCDIR): Add common/common-utils.h, common/xml-utils.h,
	common/ptid.h, common/buffer.h and common/linux-osdata.h.
	(COMMON_OBS): Add xml-utils.o, common-utils.o, buffer.o and ptid.o.
	(common-utils.o, xml-utils.o, ptid.o, buffer.o, linux-osdata.o): New
	rules.
	* common/gdb_assert.h: New.
	* common/gdb_dirent.h: New.
	* common/gdb_locale.h: New.
	* common/buffer.c: New.
	* common/buffer.h: New.
	* common/ptid.c: New.
	* common/ptid.h: New.
	* common/xml-utils.c: New.
	* common/xml-utils.h: New.
	* common/common-utils.c: New.
	* common/common-utils.h: New.
	* common/linux-osdata.c: New.
	* common/linux-osdata.h: New.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Add linux-osdata.o.
	* config/arm/linux.mh (NATDEPFILES): Ditto.
	* config/i386/linux.mh (NATDEPFILES): Ditto.
	* config/i386/linux64.mh (NATDEPFILES): Ditto.
	* config/ia64/linux.mh (NATDEPFILES): Ditto.
	* config/m32r/linux.mh (NATDEPFILES): Ditto.
	* config/m68k/linux.mh (NATDEPFILES): Ditto.
	* config/mips/linux.mh (NATDEPFILES): Ditto.
	* config/pa/linux.mh (NATDEPFILES): Ditto.
	* config/powerpc/linux.mh (NATDEPFILES): Ditto.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Ditto.
	* config/s390/s390.mh (NATDEPFILES): Ditto.
	* config/sparc/linux.mh (NATDEPFILES): Ditto.
	* config/sparc/linux64.mh (NATDEPFILES): Ditto.
	* config/xtensa/linux.mh (NATDEPFILES): Ditto.

gdbserver/
	* linux-low.c (compare_ints, unique, list_threads, show_process,
	linux_core_of_thread): Delete.
	(linux_target_ops): Change linux_core_of_thread to
	linux_common_core_of_thread.
	(linux_qxfer_osdata): Defer to linux_common_xfer_osdata.
	* utils.c (malloc_failure): Change type of argument.
	(xmalloc, xrealloc, xcalloc, xsnprintf): Delete.
	* Makefile.in (SFILES): Add common/common-utils.c, common/xml-utils.c,
	common/linux-osdata.c, common/ptid.c and common/buffer.c.
	(OBS): Add xml-utils.o, common-utils.o, ptid.o and buffer.o.
	(IPA_OBJS): Add common-utils-ipa.o.
	(ptid_h, linux_osdata_h): New macros.
	(server_h): Add common/common-utils.h, common/xml-utils.h,
	common/buffer.h, common/gdb_assert.h, common/gdb_locale.h and
	common/ptid.h.
	(common-utils-ipa.o, common-utils.o, xml-utils.o, linux-osdata.o,
	ptid.o, buffer.o): New rules.
	(linux-low.o): Add common/linux-osdata.h as a dependency.
	* configure.srv (srv_tgtobj): Add linux-osdata.o to Linux targets.
	* configure.ac: Add AC_HEADER_DIRENT check.
	* config.in: Regenerate.
	* configure: Regenerate.
	* remote-utils.c (xml_escape_text): Delete.
	(buffer_grow, buffer_free, buffer_init, buffer_finish,
	buffer_xml_printf): Move to common/buffer.c.
	* server.c (main): Remove call to initialize_inferiors.
	* server.h (struct ptid, ptid_t, minus_one_ptid, null_ptid,
	ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp, ptid_get_tid,
	ptid_equal, ptid_is_pid, initialize_inferiors, xml_escape_text,
	internal_error, gdb_assert, gdb_assert_fail): Delete.
	(struct buffer, buffer_grow, buffer_free, buffer_init, buffer_finish,
	buffer_xml_printf, buffer_grow_str, buffer_grow_str0): Move to
	common/buffer.h.
	* inferiors.c (null_ptid, minus_one_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal, ptid_is_pid,
	initialize_inferiors): Delete.
@
text
@d34 1
a1288 28
/* Return an lwp's tgid, found in `/proc/PID/status'.  */

int
linux_proc_get_tgid (int lwpid)
{
  FILE *status_file;
  char buf[100];
  int tgid = -1;

  snprintf (buf, sizeof (buf), "/proc/%d/status", (int) lwpid);
  status_file = fopen (buf, "r");
  if (status_file != NULL)
    {
      while (fgets (buf, sizeof (buf), status_file))
	{
	  if (strncmp (buf, "Tgid:", 5) == 0)
	    {
	      tgid = strtoul (buf + strlen ("Tgid:"), NULL, 10);
	      break;
	    }
	}

      fclose (status_file);
    }

  return tgid;
}

@


1.208
log
@2011-06-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* infcall.c (run_inferior_call): Don't mask async.  Instead force
	a synchronous wait, if the target can async.

	* target.h (struct target_ops): Delete to_async_mask.
	(target_async_mask): Delete.
	* target.c (update_current_target): Delete references to to_async_mask.
	* linux-nat.c (linux_nat_async_mask_value): Delete.
	(linux_nat_is_async_p, linux_nat_can_async_p): Remove references
	to linux_nat_async_mask_value.
	(linux_nat_async_mask): Delete.
	(linux_nat_async, linux_nat_close): Remove references to
	linux_nat_async_mask_value.
	* record.c (record_async_mask_value): Delete.
	(record_async): Remove references to record_async_mask_value.
	(record_async_mask): Delete.
	(record_can_async_p, record_is_async_p): Remove references to
	record_async_mask_value.
	(init_record_ops, init_record_core_ops): Remove references to
	record_async_mask.
	* remote.c (remote_async_mask_value): Delete.
	(init_remote_ops): Remove reference to remote_async_mask.
	(remote_can_async_p, remote_is_async_p): Remove references to
	remote_async_mask_value.
	(remote_async): Remove references to remote_async_mask_value.
	(remote_async_mask): Delete.

	* infrun.c (fetch_inferior_event): Don't claim registers changed
	if the current thread is already not executing.
@
text
@d60 1
a5117 8
  /* We make the process list snapshot when the object starts to be
     read.  */
  static const char *buf;
  static LONGEST len_avail = -1;
  static struct obstack obstack;

  DIR *dirp;

d5120 1
a5120 132
  if (!annex)
    {
      if (offset == 0)
	{
	  if (len_avail != -1 && len_avail != 0)
	    obstack_free (&obstack, NULL);
	  len_avail = 0;
	  buf = NULL;
	  obstack_init (&obstack);
	  obstack_grow_str (&obstack, "<osdata type=\"types\">\n");

	  obstack_xml_printf (&obstack,
			      "<item>"
			      "<column name=\"Type\">processes</column>"
			      "<column name=\"Description\">"
			      "Listing of all processes</column>"
			      "</item>");

	  obstack_grow_str0 (&obstack, "</osdata>\n");
	  buf = obstack_finish (&obstack);
	  len_avail = strlen (buf);
	}

      if (offset >= len_avail)
	{
	  /* Done.  Get rid of the obstack.  */
	  obstack_free (&obstack, NULL);
	  buf = NULL;
	  len_avail = 0;
	  return 0;
	}

      if (len > len_avail - offset)
	len = len_avail - offset;
      memcpy (readbuf, buf + offset, len);

      return len;
    }

  if (strcmp (annex, "processes") != 0)
    return 0;

  gdb_assert (readbuf && !writebuf);

  if (offset == 0)
    {
      if (len_avail != -1 && len_avail != 0)
	obstack_free (&obstack, NULL);
      len_avail = 0;
      buf = NULL;
      obstack_init (&obstack);
      obstack_grow_str (&obstack, "<osdata type=\"processes\">\n");

      dirp = opendir ("/proc");
      if (dirp)
	{
	  struct dirent *dp;

	  while ((dp = readdir (dirp)) != NULL)
	    {
	      struct stat statbuf;
	      char procentry[sizeof ("/proc/4294967295")];

	      if (!isdigit (dp->d_name[0])
		  || NAMELEN (dp) > sizeof ("4294967295") - 1)
		continue;

	      sprintf (procentry, "/proc/%s", dp->d_name);
	      if (stat (procentry, &statbuf) == 0
		  && S_ISDIR (statbuf.st_mode))
		{
		  char *pathname;
		  FILE *f;
		  char cmd[MAXPATHLEN + 1];
		  struct passwd *entry;

		  pathname = xstrprintf ("/proc/%s/cmdline", dp->d_name);
		  entry = getpwuid (statbuf.st_uid);

		  if ((f = fopen (pathname, "r")) != NULL)
		    {
		      size_t length = fread (cmd, 1, sizeof (cmd) - 1, f);

		      if (length > 0)
			{
			  int i;

			  for (i = 0; i < length; i++)
			    if (cmd[i] == '\0')
			      cmd[i] = ' ';
			  cmd[length] = '\0';

			  obstack_xml_printf (
			    &obstack,
			    "<item>"
			    "<column name=\"pid\">%s</column>"
			    "<column name=\"user\">%s</column>"
			    "<column name=\"command\">%s</column>"
			    "</item>",
			    dp->d_name,
			    entry ? entry->pw_name : "?",
			    cmd);
			}
		      fclose (f);
		    }

		  xfree (pathname);
		}
	    }

	  closedir (dirp);
	}

      obstack_grow_str0 (&obstack, "</osdata>\n");
      buf = obstack_finish (&obstack);
      len_avail = strlen (buf);
    }

  if (offset >= len_avail)
    {
      /* Done.  Get rid of the obstack.  */
      obstack_free (&obstack, NULL);
      buf = NULL;
      len_avail = 0;
      return 0;
    }

  if (len > len_avail - offset)
    len = len_avail - offset;
  memcpy (readbuf, buf + offset, len);

  return len;
@


1.207
log
@gdb/
	* linux-nat.c (linux_lwp_is_zombie): Use xsnprintf.
@
text
@a252 6
/* Async mode support.  */

/* Zero if the async mode, although enabled, is masked, which means
   linux_nat_wait should behave as if async mode was off.  */
static int linux_nat_async_mask_value = 1;

d256 2
a304 1
static int linux_nat_async_mask (int mask);
d5357 1
a5357 5
  if (!target_async_permitted)
    return 0;

  /* See target.h/target_async_mask.  */
  return linux_nat_async_mask_value;
d5368 1
a5368 5
  if (!target_async_permitted)
    return 0;

  /* See target.h/target_async_mask.  */
  return linux_nat_async_mask_value;
a5387 31
/* target_async_mask implementation.  */

static int
linux_nat_async_mask (int new_mask)
{
  int curr_mask = linux_nat_async_mask_value;

  if (curr_mask != new_mask)
    {
      if (new_mask == 0)
	{
	  linux_nat_async (NULL, 0);
	  linux_nat_async_mask_value = new_mask;
	}
      else
	{
	  linux_nat_async_mask_value = new_mask;

	  /* If we're going out of async-mask in all-stop, then the
	     inferior is stopped.  The next resume will call
	     target_async.  In non-stop, the target event source
	     should be always registered in the event loop.  Do so
	     now.  */
	  if (non_stop)
	    linux_nat_async (inferior_event_handler, 0);
	}
    }

  return curr_mask;
}

a5513 4
  if (linux_nat_async_mask_value == 0 || !target_async_permitted)
    internal_error (__FILE__, __LINE__,
		    "Calling target_async when async is masked");

a5605 3
  /* Reset the async_masking.  */
  linux_nat_async_mask_value = 1;

a5751 1
  t->to_async_mask = linux_nat_async_mask;
@


1.206
log
@gdb/
	Fix PR 10970, PR 12702.
	* linux-nat.c (linux_lwp_is_zombie): New function.
	(wait_lwp): Initialize status.  New variable prev_mask.  Block signals.
	Check for linux_lwp_is_zombie.  Use WNOHANG and sigsuspend.

gdb/testsuite/
	* gdb.threads/leader-exit.c: New file.
	* gdb.threads/leader-exit.exp: New file.
@
text
@d2368 1
a2368 1
  sprintf (buffer, "/proc/%ld/status", lwp);
@


1.205
log
@gdb/
	* linux-nat.c (kill_callback): Use SIGKILL first.

gdb/testsuite/
	* gdb.base/kill-after-signal.c: New file.
	* gdb.base/kill-after-signal.exp: New file.
@
text
@d2359 27
d2393 1
a2393 1
  int status;
d2395 1
d2400 4
a2403 2
  pid = my_waitpid (GET_LWP (lp->ptid), &status, 0);
  if (pid == -1 && errno == ECHILD)
d2405 4
a2408 1
      pid = my_waitpid (GET_LWP (lp->ptid), &status, __WCLONE);
d2410 21
a2431 5
	  /* The thread has previously exited.  We need to delete it
	     now because, for some vendor 2.4 kernels with NPTL
	     support backported, there won't be an exit event unless
	     it is the main thread.  2.6 kernels will report an exit
	     event for each thread that exits, as expected.  */
d2434 2
a2435 1
	    fprintf_unfiltered (gdb_stdlog, "WL: %s vanished.\n",
d2437 1
d2439 24
@


1.204
log
@	* linux-nat.c (debug_linux_nat_async): Delete.
	Replace all references to use debug_linux_nat instead.
	(show_debug_linux_nat_async): Delete.
	(sigchld_handler): Call ui_file_write_async_safe instead of
	fprintf_unfiltered.
	(_initialize_linux_nat): Remove `set debug lin-lwp-async'.
	* ui-file.c (struct ui_file): New member to_write_async_safe.
	(null_file_write_async_safe): New function.
	(ui_file_write_async_safe): New function.
	(set_ui_file_write_async_safe): New function.
	(ui_file_new): Initialize to_write_async_safe.
	(stdio_file_write_async_safe): New function.
	(struct stdio_file): New member fd.
	(stdio_file_new): Initialize to_write_async_safe, fd.
	(stdio_file_read, stdio_file_isatty): New stdio->fd instead of calling fileno.
	* ui-file.h (ui_file_write_async_safe_ftype): New typedef.
	(set_ui_file_write_async_safe): Declare.
	(ui_file_write_async_safe): Declare.

	doc/
	* gdb.texinfo (Completion): Update example.
	(Debugging Output): Delete `set/show debug lin-lwp-async'.
@
text
@d3783 12
@


1.203
log
@	* linux-nat.c (lin_lwp_attach_lwp): For !WIPSTOPPED case,
	adding missing call to restore_child_signals_mask.
@
text
@a200 10
static int debug_linux_nat_async = 0;
static void
show_debug_linux_nat_async (struct ui_file *file, int from_tty,
			    struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("Debugging of GNU/Linux async lwp module is %s.\n"),
		    value);
}

d3253 1
a3253 1
  if (debug_linux_nat_async)
d3296 1
a3296 1
      if (debug_linux_nat_async)
d3539 1
a3539 1
		  if (debug_linux_nat_async)
d3554 1
a3554 1
	  if (debug_linux_nat_async)
d3683 1
a3683 1
  if (debug_linux_nat_async)
d5409 3
a5411 2
  if (debug_linux_nat_async)
    fprintf_unfiltered (gdb_stdlog, "sigchld\n");
a5794 9
  add_setshow_zinteger_cmd ("lin-lwp-async", class_maintenance,
			    &debug_linux_nat_async, _("\
Set debugging of GNU/Linux async lwp module."), _("\
Show debugging of GNU/Linux async lwp module."), _("\
Enables printf debugging output."),
			    NULL,
			    show_debug_linux_nat_async,
			    &setdebuglist, &showdebuglist);

@


1.202
log
@	* linux-nat.c (linux_child_remove_fork_catchpoint)
	(linux_child_remove_vfork_catchpoint)
	(linux_child_remove_exec_catchpoint): New functions.
	(linux_target_install_ops): Install them.
@
text
@d1479 4
a1482 1
	return -1;
@


1.201
log
@	* target.h (struct target_ops): Remove to_notice_signals;
	add to_pass_signals.
	(target_notice_signals): Remove.
	(target_pass_signals): Add prototype.
	* target.c (update_current_target): Remove to_notice_signals;
	mention to_pass_signals.
	(target_pass_signals): New function.
	(debug_to_notice_signals): Remove.
	(setup_target_debug): Do not install debug_to_notice_signals.

	* infrun.c (signal_pass): New global.
	(resume): Call target_pass_signals.
	(handle_inferior_event): Report all signals while stepping over
	non-steppable watchpoint.  Reset trap_expected to ensure breakpoints
	are re-inserted when stepping over a signal handler.
	(signal_cache_update): New function.
	(signal_stop_update): Call it.
	(signal_print_update): Likewise.
	(signal_pass_update): Likewise.
	(handle_command): Call signal_cache_update and target_pass_signals
	instead of target_notice_signals.
	(_initialize_infrun): Initialize signal_pass.

	* linux-nat.c (pass_mask): New global.
	(linux_nat_pass_signals): New function.
	(linux_nat_create_inferior): Report all signals initially.
	(linux_nat_attach): Likewise.
	(linux_nat_resume): Use pass_mask to decide whether to directly
	handle an inferior signal.
	(linux_nat_wait_1): Likewise.
	(linux_nat_add_target): Install to_pass_signals callback.

	* nto-procfs.c (notice_signals): Remove.
	(procfs_resume): Do not call notice_signals.
	(procfs_notice_signals): Remove.
	(procfs_pass_signals): New function.
	(init_procfs_ops): Install to_pass_signals callback instead of
	to_notice_signals callback.
	(_initialize_procfs): Report all signals initially.

	* procfs.c (procfs_notice_signals): Remove.
	(procfs_pass_signals): New function.
	(procfs_target): Install to_pass_signals callback instead of
	to_notice_signals callback.
	(register_gdb_signals): Remove.
	(procfs_debug_inferior): Report all signals initially.
	(procfs_init_inferior): Remove redundant register_gdb_signals call.

	* remote.c (remote_pass_signals): Add numsigs and pass_signals
	parameters; use them instead of calling signal_..._state routines.
	(remote_notice_signals): Remove.
	(remote_start_remote): Report all signals initially.
	(remote_resume): Do not call remote_pass_signals.
	(_initialize_remote): Install to_pass_signals callback instead of
	to_notice_signals callback.
@
text
@d947 6
d959 6
d971 6
d5235 1
d5237 1
d5239 1
@


1.200
log
@gdb/

        * linux-nat.c: Move common macros to ...
        Include linux-ptrace.h.
        * common/linux-ptrace.h: ... here.  New.

gdb/gdbserver/

        * linux-low.c: Move common macros to linux-ptrace.h.
        Include linux-ptrace.h.
	* Makefile.in (linux_ptrace_h): New.
	(linux-low.o): Depends on linux-ptrace.h.
@
text
@d1044 20
d1529 3
d1553 3
d1914 3
a1916 13
      enum target_signal saved_signo;
      struct inferior *inf;

      inf = find_inferior_pid (ptid_get_pid (lp->ptid));
      gdb_assert (inf);
      saved_signo = target_signal_from_host (WSTOPSIG (lp->status));

      /* Defer to common code if we're gaining control of the
	 inferior.  */
      if (inf->control.stop_soon == NO_STOP_QUIETLY
	  && signal_stop_state (saved_signo) == 0
	  && signal_print_state (saved_signo) == 0
	  && signal_pass_state (saved_signo) == 1)
d1926 1
a1926 1
	  signo = saved_signo;
a3571 4
      struct inferior *inf;

      inf = find_inferior_pid (ptid_get_pid (lp->ptid));
      gdb_assert (inf);
d3573 2
a3574 4
      /* Defer to common code if we get a signal while
	 single-stepping, since that may need special care, e.g. to
	 skip the signal handler, or, if we're gaining control of the
	 inferior.  */
d3576 1
a3576 4
	  && inf->control.stop_soon == NO_STOP_QUIETLY
	  && signal_stop_state (signo) == 0
	  && signal_print_state (signo) == 0
	  && signal_pass_state (signo) == 1)
d5685 1
@


1.199
log
@	* cli/cli-cmds.c (shell_escape): Use lbasename.
	* coffread.c (coff_start_symtab): Constify parameter.
	(complete_symtab): Constify `name' parameter.
	(coff_symtab_read): Constify `filestring' local.
	(coff_getfilename): Constify return and `result' local.
	Use lbasename.
	* fbsd-nat.c (fbsd_make_corefile_notes): Use lbasename.
	* linux-fork.c (info_checkpoints_command): Use lbasename.
	* linux-nat.c (linux_nat_make_corefile_notes): Use lbasename.
	* minsyms.c (lookup_minimal_symbol): Use lbasename.
	* nto-tdep.c (nto_find_and_open_solib): Use lbasename.
	* procfs.c (procfs_make_note_section): Use lbasename.
	* tui/tui-io.c (printable_part): Constity return and parameter.
	Use lbasename.
	(print_filename): Constify parameters, and local `s'.
	(tui_rl_display_match_list): Constify local `temp'.
@
text
@d33 1
a163 26
/* If the system headers did not provide the constants, hard-code the normal
   values.  */
#ifndef PTRACE_EVENT_FORK

#define PTRACE_SETOPTIONS	0x4200
#define PTRACE_GETEVENTMSG	0x4201

/* Options set using PTRACE_SETOPTIONS.  */
#define PTRACE_O_TRACESYSGOOD	0x00000001
#define PTRACE_O_TRACEFORK	0x00000002
#define PTRACE_O_TRACEVFORK	0x00000004
#define PTRACE_O_TRACECLONE	0x00000008
#define PTRACE_O_TRACEEXEC	0x00000010
#define PTRACE_O_TRACEVFORKDONE	0x00000020
#define PTRACE_O_TRACEEXIT	0x00000040

/* Wait extended result codes for the above trace options.  */
#define PTRACE_EVENT_FORK	1
#define PTRACE_EVENT_VFORK	2
#define PTRACE_EVENT_CLONE	3
#define PTRACE_EVENT_EXEC	4
#define PTRACE_EVENT_VFORK_DONE	5
#define PTRACE_EVENT_EXIT	6

#endif /* PTRACE_EVENT_FORK */

a168 12
/* We can't always assume that this flag is available, but all systems
   with the ptrace event handlers also have __WALL, so it's safe to use
   here.  */
#ifndef __WALL
#define __WALL          0x40000000 /* Wait for any child.  */
#endif

#ifndef PTRACE_GETSIGINFO
# define PTRACE_GETSIGINFO    0x4202
# define PTRACE_SETSIGINFO    0x4203
#endif

@


1.199.2.1
log
@2011-04-29  Pedro Alves  <pedro@@codesourcery.com>

	* linux-nat.c (linux_child_remove_fork_catchpoint)
	(linux_child_remove_vfork_catchpoint)
	(linux_child_remove_exec_catchpoint): New functions.
	(linux_target_install_ops): Install them.
@
text
@a983 6
linux_child_remove_fork_catchpoint (int pid)
{
  return 0;
}

static int
a989 6
linux_child_remove_vfork_catchpoint (int pid)
{
  return 0;
}

static int
a995 6
linux_child_remove_exec_catchpoint (int pid)
{
  return 0;
}

static int
a5246 1
  t->to_remove_fork_catchpoint = linux_child_remove_fork_catchpoint;
a5247 1
  t->to_remove_vfork_catchpoint = linux_child_remove_vfork_catchpoint;
a5248 1
  t->to_remove_exec_catchpoint = linux_child_remove_exec_catchpoint;
@


1.198
log
@2011-03-02  Michael Snyder  <msnyder@@vmware.com>

	* linux-nat.c (linux_nat_xfer_partial): Preserve errno around
	a function call.
@
text
@d4494 1
a4494 1
      strncpy (fname, strrchr (get_exec_file (0), '/') + 1, sizeof (fname));
@


1.197
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* linux-nat.c (linux_handle_extended_wait): Delete unused variable.
@
text
@d4035 1
a4035 1
  int err;
d4043 1
a4043 1

d4048 1
a4048 1
			err ? safe_strerror (err) : "OK");
@


1.196
log
@2011-02-27  Michael Snyder  <msnyder@@vmware.com>

	* darwin-nat-info.c: Fix comment typo.
	* dwarf2expr.h: Ditto.
	* fbsd-nat.c: Ditto.
	* fbsd-nat.h: Ditto.
	* frame-unwind.h: Ditto.
	* frame.h: Ditto.
	* hppa-hpux-tdep.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* linux-nat.c: Ditto.
	* nbsd-nat.c: Ditto.
	* nbsd-nat.h: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* serial.c: Ditto.
	* ui-file.h: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@a2200 2
	  struct fork_info *fp;

d2210 2
a2211 3
	  fp = find_fork_pid (new_pid);
	  if (!fp)
	    fp = add_fork (new_pid);
@


1.195
log
@2011-02-26  Michael Snyder  <msnyder@@vmware.com>

	* linux-low.c (linux_nat_xfer_osdata): Rename local variable so
	that it does not shadow a function parameter.
@
text
@d2831 1
a2831 1
	 or a a pending process exit.  Note that `W_EXITCODE(0,0) ==
@


1.194
log
@2011-02-08  Michael Snyder  <msnyder@@vmware.com>

	* linux-nat.c (linux_nat_filter_event): Fix typo in comment.
@
text
@d5148 1
a5148 1
		      size_t len = fread (cmd, 1, sizeof (cmd) - 1, f);
d5150 1
a5150 1
		      if (len > 0)
d5154 1
a5154 1
			  for (i = 0; i < len; i++)
d5157 1
a5157 1
			  cmd[len] = '\0';
@


1.193
log
@gdb
	PR mi/8618:
	* thread.c (free_thread): Free 'name'.
	(print_thread_info): Emit thread name.  Change CLI output.
	(thread_name_command): New function.
	(do_captured_thread_select): Emit newline.
	(_initialize_thread): Register 'thread name' command.
	* target.h (struct target_ops) <to_thread_name>: New field.
	(target_thread_name): New macro.
	* target.c (update_current_target): Handle to_thread_name.
	* python/py-infthread.c (thpy_get_name): New function.
	(thpy_set_name): Likewise.
	(thread_object_getset): Add "name".
	* linux-nat.c (linux_nat_thread_name): New function.
	(linux_nat_add_target): Set to_thread_name.
	* gdbthread.h (struct thread_info) <name>: New field.
gdb/doc
	* gdb.texinfo (Threads): Document thread name output and `thread
	name' command.
	(Threads In Python): Document Thread.name attribute.
	(GDB/MI Thread Commands): Document thread attributes.
gdb/testsuite
	* gdb.python/py-infthread.exp: Add thread tests.
@
text
@d3067 1
a3067 1
     if we detach from a program we original forked and then it
@


1.192
log
@2010-01-11  Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Convert hardware watchpoints to use breakpoint_ops.

gdb/
	* breakpoint.h (breakpoint_ops) <insert>: Rename to...
	<insert_location>: ... this.  Return int instead of void.
	Accept pointer to struct bp_location instead of pointer to
	struct breakpoint.  Adapt all implementations.
	(breakpoint_ops) <remove>: Rename to...
	<remove_location>: ... this.  Accept pointer to struct bp_location
	instead of pointer to struct breakpoint.  Adapt all implementations.
	* breakpoint.c (insert_catchpoint): Delete function.
	(insert_bp_location): Call the watchpoint or catchpoint's
	breakpoint_ops.insert method.
	(remove_breakpoint_1): Call the watchpoint or catchpoint's
	breakpoint_ops.remove method.
	(insert_watchpoint, remove_watchpoint): New functions.
	(watchpoint_breakpoint_ops): New structure.
	(watch_command_1): Initialize the OPS field.
	* inf-child.c (inf_child_insert_fork_catchpoint)
	(inf_child_remove_fork_catchpoint, inf_child_insert_vfork_catchpoint)
	(inf_child_remove_vfork_catchpoint, inf_child_insert_exec_catchpoint)
	(inf_child_remove_exec_catchpoint, inf_child_set_syscall_catchpoint):
	Delete functions.
	(inf_child_target): Remove initialization of to_insert_fork_catchpoint,
	to_remove_fork_catchpoint, to_insert_vfork_catchpoint,
	to_remove_vfork_catchpoint, to_insert_exec_catchpoint,
	to_remove_exec_catchpoint and to_set_syscall_catchpoint.
	* target.c (update_current_target): Change default implementation of
	to_insert_fork_catchpoint, to_remove_fork_catchpoint,
	to_insert_vfork_catchpoint, to_remove_vfork_catchpoint,
	to_insert_exec_catchpoint, to_remove_exec_catchpoint and
	to_set_syscall_catchpoint to return_one.
	(debug_to_insert_fork_catchpoint, debug_to_insert_vfork_catchpoint)
	(debug_to_insert_exec_catchpoint): Report return value.
	* target.h (to_insert_fork_catchpoint, to_insert_vfork_catchpoint)
	(to_insert_exec_catchpoint): Change declaration to return int instead
	of void.

gdb/testsuite/
	* gdb.base/foll-exec.exp: Adapt to new error string when the catchpoint
	type is not supported.
	* gdb.base/foll-fork.exp: Likewise.
	* gdb.base/foll-vfork.exp: Likewise.
@
text
@d4081 37
d5723 1
@


1.191
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* h8300-tdep.c: Comment cleanup, mostly periods and spaces.
	* hppa-hpux-tdep.c: Ditto.
	* hppa-linux-nat.c: Ditto.
	* hppa-linux-tdep.c: Ditto.
	* hppanbsd-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* hppa-tdep.h: Ditto.
	* hpux-thread.c: Ditto.
	* i386-cygwin-tdep.c: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386gnu-nat.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* i386-linux-tdep.c: Ditto.
	* i386-nat.c: Ditto.
	* i386-nat.h: Ditto.
	* i386nbsd-tdep.c: Ditto.
	* i386-sol2-nat.c: Ditto.
	* i386-stub.c: Ditto.
	* i386-tdep.c: Ditto.
	* i386-tdep.h: Ditto.
	* i387-tdep.c: Ditto.
	* ia64-linux-nat.c: Ditto.
	* ia64-linux-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* infcall.c: Ditto.
	* infcall.h: Ditto.
	* infcmd.c: Ditto.
	* inferior.c: Ditto.
	* inferior.h: Ditto.
	* infloop.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* interps.c: Ditto.
	* interps.h: Ditto.
	* iq2000-tdep.c: Ditto.
	* irix5-nat.c: Ditto.
	* jit.c: Ditto.
	* jit.h: Ditto.
	* jv-exp.y: Ditto.
	* jv-lang.c: Ditto.
	* jv-lang.h: Ditto.
	* jv-typeprint.c: Ditto.
	* jv-valprint.c: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* linespec.c: Ditto.
	* linux-fork.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-thread-db.c: Ditto.
	* lm32-tdep.c: Ditto.
@
text
@d977 1
a977 1
static void
d980 1
a980 2
  if (! linux_supports_tracefork (pid))
    error (_("Your system does not support fork catchpoints."));
d983 1
a983 1
static void
d986 1
a986 2
  if (!linux_supports_tracefork (pid))
    error (_("Your system does not support vfork catchpoints."));
d989 1
a989 1
static void
d992 1
a992 2
  if (!linux_supports_tracefork (pid))
    error (_("Your system does not support exec catchpoints."));
d999 3
a1001 2
  if (! linux_supports_tracesysgood (pid))
    error (_("Your system does not support syscall catchpoints."));
d1004 1
a1004 1
     
@


1.190
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ax-gdb.c: Adjust some long output strings.
	* breakpoint.c: Ditto.
	* charset.c: Ditto.
	* cp-abi.c: Ditto.
	* infcall.c: Ditto.
	* infrun.c: Ditto.
	* linux-nat.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
@
text
@d41 1
a41 1
#include <sys/procfs.h>		/* for elf_gregset etc. */
d46 1
a46 1
#include "gdbthread.h"		/* for struct thread_info etc. */
d71 1
a71 1
/* This comment documents high-level logic of this file. 
d79 1
a79 1
When waiting for an event in all threads, waitpid is not quite good. Prior to
d81 1
a81 1
threads. (2.4 has the __WALL flag).  So, if we use blocking waitpid, we might
d84 1
a84 1
process, if any. Second, we use non-blocking waitpid with the __WCLONED
d93 1
a93 1
so that we don't miss a signal. If SIGCHLD arrives in between, when it's
d170 1
a170 1
/* options set using PTRACE_SETOPTIONS */
d300 1
a300 1
/* Async mode support */
d701 1
a701 1
      /* We're already attached to the parent, by default. */
d2729 1
a2729 1
	      /* Now resume this LWP and get the SIGSTOP event. */
d2744 1
a2744 1
		 there are any more (we still want to get that SIGSTOP). */
d2749 1
a2749 1
		 queue. */
d2760 1
a2760 1
	      /* Save the sigtrap event. */
d2767 1
a2767 1
	         SIGSTOP, and didn't accidentally trip a breakpoint. */
d2776 1
a2776 1
	      /* Now resume this LWP and get the SIGSTOP event. */
d2786 1
a2786 1
	         there are any more (we still want to get that SIGSTOP). */
d2890 1
a2890 1
  /* Select only resumed LWPs that have a SIGTRAP event pending. */
d3068 1
a3068 1
     our list, i.e.  not part of the current process.  This can happen
d4572 1
a4572 1
	  /* [...] (future options here) */
d4772 1
a4772 1
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)	/* FIXME arch? */
d4774 1
a4774 1
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)	/* FIXME arch? */
d4784 1
a4784 1
	  if (fscanf (procfile, "%lu ", &ltmp) > 0)	/* FIXME arch? */
@


1.189
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d689 5
a693 6
      fprintf_filtered (gdb_stderr,
			_("Can not resume the parent process "
			  "over vfork in the foreground while\n"
			  "holding the child stopped.  "
			  "Try \"set detach-on-fork\" or "
			  "\"set schedule-multiple\".\n"));
@


1.188
log
@run copyright.sh for 2011.
@
text
@d89 2
a90 1
an event, we get back to calling nonblocking waitpid with and without __WCLONED.
d243 2
a244 1
  fprintf_filtered (file, _("Debugging of GNU/Linux async lwp module is %s.\n"),
d255 3
a257 2
  fprintf_filtered (file, _("\
Disabling randomization of debuggee's virtual address space is %s.\n"),
d260 3
a262 3
  fputs_filtered (_("\
Disabling randomization of debuggee's virtual address space is unsupported on\n\
this platform.\n"), file);
d267 2
a268 1
set_disable_randomization (char *args, int from_tty, struct cmd_list_element *c)
d271 3
a273 3
  error (_("\
Disabling randomization of debuggee's virtual address space is unsupported on\n\
this platform."));
d290 2
a291 2
/* This variable is a tri-state flag: -1 for unknown, 0 if PTRACE_O_TRACESYSGOOD
   can not be used, 1 if it can.  */
d353 2
a354 1
			     (enum inferior_event_type event_type, void *context),
d481 2
a482 1
    error (_("linux_test_for_tracefork: waitpid: unexpected status %d."), status);
d497 2
a498 1
	warning (_("linux_test_for_tracefork: failed to wait for killed child"));
d500 2
a501 2
	warning (_("linux_test_for_tracefork: unexpected wait status 0x%x from "
		 "killed child"), status);
d531 2
a532 1
	    warning (_("linux_test_for_tracefork: failed to kill second child"));
d689 6
a694 4
      fprintf_filtered (gdb_stderr, _("\
Can not resume the parent process over vfork in the foreground while\n\
holding the child stopped.  Try \"set detach-on-fork\" or \
\"set schedule-multiple\".\n"));
d724 2
a725 1
				"Detaching after fork from child process %d.\n",
d857 2
a858 1
  				    "LCFF: no VFORK_DONE support, sleeping a bit\n");
d888 3
a890 2
	    fprintf_filtered (gdb_stdlog, _("\
Attaching after process %d vfork to child process %d.\n"),
d893 3
a895 2
	    fprintf_filtered (gdb_stdlog, _("\
Attaching after process %d fork to child process %d.\n"),
d1694 3
a1696 2
	fprintf_unfiltered (gdb_stdlog, "\
GPT: lwp %s had signal %s, but it is in no pass state\n",
d1856 2
a1857 1
    fprintf_unfiltered (gdb_stdlog, "RC: Not resuming sibling %s (has pending)\n",
d1860 2
a1861 1
    fprintf_unfiltered (gdb_stdlog, "RC: Not resuming sibling %s (not stopped)\n",
d2100 2
a2101 1
				lp->syscall_state == TARGET_WAITKIND_SYSCALL_ENTRY
d2137 2
a2138 1
			    "LHST: caught syscall event with no syscall catchpoints."
d2322 2
a2323 1
				"LHEW: Got clone event from LWP %ld, resuming\n",
d2353 3
a2355 2
	    fprintf_unfiltered (gdb_stdlog, "\
LHEW: Got expected PTRACE_EVENT_VFORK_DONE from LWP %ld: stopping\n",
d2363 3
a2365 2
	fprintf_unfiltered (gdb_stdlog, "\
LHEW: Got PTRACE_EVENT_VFORK_DONE from LWP %ld: resuming\n",
d2698 2
a2699 1
				"PTRACE_CONT %s, 0, 0 (%s) (discarding SIGINT)\n",
d3454 2
a3455 1
		fprintf (stderr, "LWP %ld got an event %06x, leaving pending.\n",
d3480 3
a3482 2
				     "LLW: LWP %ld hit a breakpoint while waiting "
				     "for another process; cancelled it\n",
d3496 2
a3497 1
		    fprintf (stderr, "Process %ld exited while stopping LWPs\n",
d3771 2
a3772 1
    fprintf_unfiltered (gdb_stdlog, "linux_nat_wait: [%s]\n", target_pid_to_str (ptid));
d4275 2
a4276 2
							 sizeof (gregs))) != NULL
	  && regset->collect_regset != NULL)
d4288 2
a4289 2
							 sizeof (fpregs))) != NULL
	  && regset->collect_regset != NULL)
d4744 2
a4745 2
	    printf_filtered (_("jiffies remaining in current time slice: %ld\n"),
			     ltmp);
d4755 2
a4756 2
	    printf_filtered (_("start time (jiffies since system boot): %ld\n"),
			     ltmp);
d4761 2
a4762 1
	    printf_filtered (_("Resident set size: %lu\n"), (unsigned long) ltmp);
d4771 2
a4772 2
#if 0				/* Don't know how architecture-dependent the rest is...
				   Anyway the signal bitmap info is available from "status".  */
d4979 2
a4980 1
linux_proc_pending_signals (int pid, sigset_t *pending, sigset_t *blocked, sigset_t *ignored)
d5044 1
a5044 2
	  obstack_xml_printf (
			      &obstack,
d5047 2
a5048 1
			      "<column name=\"Description\">Listing of all processes</column>"
d5522 2
a5523 2
	    fprintf_unfiltered (gdb_stdlog, "\
LNSL: already stopped/stop_requested %s\n",
d5526 3
a5528 2
	    fprintf_unfiltered (gdb_stdlog, "\
LNSL: already stopped/no stop_requested yet %s\n",
@


1.187
log
@gdb/
	Rename and move inferior_thread_state and inferior_status.
	* gdbthread.h (struct thread_control_state): New struct, move fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step and stop_bpstat here from struct thread_info.
	(struct thread_suspend_state): New struct, move field stop_signal here
	from struct thread_info.
	(struct thread_info): Move the fields above from this struct.
	* inferior.h: Move the inferior_thread_state and inferior_status
	declarations comment to their definitions at infrun.c.
	(struct inferior_control_state): New struct, move field stop_soon from
	struct inferior here.
	(struct inferior_suspend_state): New empty struct.
	(struct inferior): New fields control and suspend.  Move out field
	stop_soon.
	* infrun.c (struct inferior_thread_state): Rename to ...
	(infcall_suspend_state): ... here.  Replace field stop_signal by
	fields thread_suspend and inferior_suspend.
	(save_inferior_thread_state): Rename to ...
	(save_infcall_suspend_state): ... here.  New variable inf.  Update the
	code for new fields.
	(restore_inferior_thread_state): Rename to ...
	(restore_infcall_suspend_state): ... here.  New variable inf.  Update
	the code for new fields.
	(do_restore_inferior_thread_state_cleanup): Rename to ...
	(do_restore_infcall_suspend_state_cleanup): ... here.
	(make_cleanup_restore_inferior_thread_state): Rename to ...
	(make_cleanup_restore_infcall_suspend_state): ... here.
	(discard_inferior_thread_state): Rename to ...
	(discard_infcall_suspend_state): ... here.
	(get_inferior_thread_state_regcache): Rename to ...
	(get_infcall_suspend_state_regcache): ... here.
	(struct inferior_status): Rename to ...
	(struct infcall_control_state): ... here.  Replace fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step, stop_bpstat and stop_soon by fields thread_control and
	inferior_control.
	(save_inferior_status): Rename to ...
	(save_infcall_control_state): ... here.  Update the code for new
	fields.
	(restore_inferior_status): Rename to ...
	(restore_infcall_control_state): ... here.  Update the code for new
	fields.
	(do_restore_inferior_status_cleanup): Rename to ...
	(do_restore_infcall_control_state_cleanup): ... here.
	(make_cleanup_restore_inferior_status): Rename to ...
	(make_cleanup_restore_infcall_control_state): ... here.
	(discard_inferior_status): Rename to ...
	(discard_infcall_control_state): ... here.
	* alpha-tdep.c, breakpoint.c, dummy-frame.c, dummy-frame.h,
	exceptions.c, fbsd-nat.c, gdbthread.h, infcall.c, infcmd.c,
	inferior.c, inferior.h, infrun.c, linux-nat.c, mi/mi-interp.c,
	mips-tdep.c, procfs.c, solib-irix.c, solib-osf.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, thread.c, windows-nat.c: Update all the
	references to the moved fields and renamed functions.
@
text
@d3 2
a4 2
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
@


1.186
log
@gdb/
	Revert:
	2010-10-17  Jan Kratochvil  <jan.kratochvil@@redhat.com>
		    Pedro Alves  <pedro@@codesourcery.com>
	* gdbthread.h (currently_stepping): New declaration.
	* infrun.c (currently_stepping): Remove the forward declaration.
	(currently_stepping): Make it global.
	* linux-nat.c (resume_callback) <lp->stopped && lp->status == 0>: New
	variables tp and step, initialized them.  Pass STEP to to_resume.
	Print also possibly "PTRACE_SINGLESTEP" if STEP.  Initialize LP->STEP.
	* remote.c (currently_stepping_callback): New.
	(remote_vcont_resume)
	<ptid_equal (ptid, minus_one_ptid) || ptid_is_pid (ptid)>:
	New variable tp.  Call currently_stepping_callback and step such
	thread.

gdb/testsuite/
	Revert:
	2010-10-17  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	* gdb.threads/sigstep-threads.exp: New file.
	* gdb.threads/sigstep-threads.c: New file.
@
text
@d1651 1
a1651 1
      signo = tp->stop_signal;
d1664 1
a1664 1
	  signo = tp->stop_signal;
d1920 1
a1920 1
      if (inf->stop_soon == NO_STOP_QUIETLY
d3583 1
a3583 1
	  && inf->stop_soon == NO_STOP_QUIETLY
d4165 1
a4165 1
  if (info->stop_signal != TARGET_SIGNAL_0
d4179 1
a4179 1
    return info->stop_signal;
@


1.185
log
@gdb/
	* gdbthread.h (currently_stepping): New declaration.
	* infrun.c (currently_stepping): Remove the forward declaration.
	(currently_stepping): Make it global.
	* linux-nat.c (resume_callback) <lp->stopped && lp->status == 0>: New
	variables tp and step, initialized them.  Pass STEP to to_resume.
	Print also possibly "PTRACE_SINGLESTEP" if STEP.  Initialize LP->STEP.
	* remote.c (currently_stepping_callback): New.
	(remote_vcont_resume)
	<ptid_equal (ptid, minus_one_ptid) || ptid_is_pid (ptid)>:
	New variable tp.  Call currently_stepping_callback and step such
	thread.

gdb/testsuite/
	* gdb.threads/sigstep-threads.exp: New file.
	* gdb.threads/sigstep-threads.c: New file.
@
text
@a1822 4
      struct thread_info *tp = find_thread_ptid (lp->ptid);
      /* lp->step may already contain a stale value.  */
      int step = tp ? currently_stepping (tp) : 0;

d1825 1
a1825 2
			    "RC:  %s %s, 0, 0 (resuming sibling)\n",
			    step ? "PTRACE_SINGLESTEP" : "PTRACE_CONT",
d1830 1
a1830 1
			    step, TARGET_SIGNAL_0);
d1833 1
a1833 2
			    "RC:  %s %s, 0, 0 (resume sibling)\n",
			    step ? "PTRACE_SINGLESTEP" : "PTRACE_CONT",
d1836 1
a1836 1
      lp->step = step;
@


1.184
log
@gdb/
	* corelow.c (core_open): Use target_signal_from_host if CORE_GDBARCH
	is NULL.
	* fork-child.c (startup_inferior) <resume_signal>: Use enum
	target_signal type.
	* linux-nat.c (linux_nat_resume): Use target_signal_to_host before
	calling strsignal.  Use enum target_signal type for saved_signo.
	(linux_handle_extended_wait) <signo>: Use enum target_signal type.
	(linux_nat_wait_1): Use enum target_signal type for signo.  Use
	target_signal_to_host before calling strsignal.
	* remote-m32r-sdi.c (m32r_wait, m32r_detach): Replace 0 by
	TARGET_SIGNAL_0.

gdb/gdbserver/
	* target.c (mywait) <TARGET_WAITKIND_EXITED>: Fix to use INTEGER.
@
text
@d1823 4
d1829 2
a1830 1
			    "RC:  PTRACE_CONT %s, 0, 0 (resuming sibling)\n",
d1835 1
a1835 1
			    0, TARGET_SIGNAL_0);
d1838 2
a1839 1
			    "RC:  PTRACE_CONT %s, 0, 0 (resume sibling)\n",
d1842 1
a1842 1
      lp->step = 0;
@


1.183
log
@2010-09-02  Yao Qi  <yao@@codesourcery.com>

        * linux-nat.c (status_to_str): Use WTERMSIG to extract the signal
        number from a WIFSIGNALED status.
@
text
@d1877 2
a1878 1
			signo ? strsignal (signo) : "0",
d1911 1
a1911 1
      int saved_signo;
d1978 2
a1979 1
			signo ? strsignal (signo) : "0");
d2271 1
a2271 1
	      int signo;
d3572 1
a3572 1
      int signo = target_signal_from_host (WSTOPSIG (status));
d3602 3
a3604 1
				signo ? strsignal (signo) : "0");
@


1.182
log
@gdb/
	Code cleanup.
	* defs.h (find_memory_region_ftype): New typedef.
	(exec_set_find_memory_regions): Use it.
	* exec.c (exec_set_find_memory_regions): Use find_memory_region_ftype.
	* fbsd-nat.c (fbsd_find_memory_regions): Likewise.
	* gcore.c (objfile_find_memory_regions): Likewise.
	* gnu-nat.c (gnu_find_memory_regions): Likewise.
	* linux-nat.c (linux_nat_find_memory_regions): Likewise.
	* procfs.c (iterate_over_mappings_cb_ftype): Remove.
	(iterate_over_mappings): Rename iterate_over_mappings_cb_ftype to
	find_memory_region_ftype.
	(insert_dbx_link_bpt_in_region): Likewise.
	(iterate_over_mappings): Likewise.  Drop the comment part about the
	function prototype.
	(find_memory_regions_callback): Use find_memory_region_ftype.
	(proc_find_memory_regions): Likewise.
	(info_mappings_callback): Rename iterate_over_mappings_cb_ftype to
	find_memory_region_ftype.
	* target.c (dummy_find_memory_regions): Use find_memory_region_ftype.
	* target.h (struct target_ops) <to_find_memory_regions>: Likewise.
@
text
@d1097 1
a1097 1
	      strsignal (WSTOPSIG (status)));
@


1.181
log
@gdb/
	Code cleanup.
	* linux-nat.c (pull_pid_from_list): Rename status to statusp.
	(my_waitpid): Likewise.
@
text
@d4107 1
a4107 3
linux_nat_find_memory_regions (int (*func) (CORE_ADDR,
					    unsigned long,
					    int, int, int, void *), void *obfd)
@


1.180
log
@gdb/
	* linux-nat.c (linux_nat_lp_status_is_event): New function.
	(count_events_callback, select_event_lwp_callback)
	(cancel_breakpoints_callback, linux_nat_wait_1): Use it.
@
text
@d379 1
a379 1
pull_pid_from_list (struct simple_pid_list **listp, int pid, int *status)
d388 1
a388 1
	*status = (*p)->status;
d417 1
a417 1
my_waitpid (int pid, int *status, int flags)
d423 1
a423 1
      ret = waitpid (pid, status, flags);
@


1.179
log
@gdb/
	* ia64-linux-nat.c (ia64_linux_status_is_event): New function.
	(_initialize_ia64_linux_nat): Install it.
	* linux-nat.c (sigtrap_is_event, linux_nat_status_is_event)
	(linux_nat_set_status_is_event): New.
	(stop_wait_callback, count_events_callback, select_event_lwp_callback)
	cancel_breakpoints_callback, linux_nat_filter_event)
	(linux_nat_wait_1): Use linux_nat_status_is_event.
	* linux-nat.h (linux_nat_set_status_is_event): New prototype.

gdb/testsuite/
	* gdb.threads/ia64-sigill.exp: New file.
	* gdb.threads/ia64-sigill.c: New file.
@
text
@d2620 14
d2840 1
a2840 2
  if (lp->status != 0 && lp->resumed
      && linux_nat_status_is_event (lp->status))
d2867 1
a2867 2
  if (lp->status != 0 && lp->resumed
      && linux_nat_status_is_event (lp->status))
d2927 1
a2927 3
  if (lp->waitstatus.kind == TARGET_WAITKIND_IGNORE
      && lp->status != 0
      && linux_nat_status_is_event (lp->status)
d3446 1
a3446 2
			  && lp->waitstatus.kind == TARGET_WAITKIND_IGNORE
			  && linux_nat_status_is_event (lp->status)
@


1.178
log
@gdb/
	* linux-nat.c (linux_nat_do_thread_registers): Convert STOP_SIGNAL to
	the host signal first.
@
text
@d2608 23
d2671 1
a2671 1
	  if (WSTOPSIG (status) == SIGTRAP)
d2827 1
a2827 1
      && WIFSTOPPED (lp->status) && WSTOPSIG (lp->status) == SIGTRAP)
d2855 1
a2855 1
      && WIFSTOPPED (lp->status) && WSTOPSIG (lp->status) == SIGTRAP)
d2917 1
a2917 1
      && WIFSTOPPED (lp->status) && WSTOPSIG (lp->status) == SIGTRAP
d3090 1
a3090 1
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP)
d3437 1
a3437 1
			  && WSTOPSIG (lp->status) == SIGTRAP
d3653 1
a3653 1
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP)
@


1.177
log
@gdb/
	* linux-nat.c (cancel_breakpoint): Remove unused forward declaration.
@
text
@d4193 2
a4194 1
				 lwp, stop_signal, gdb_regset);
d4221 3
a4223 5
      note_data = (char *) elfcore_write_prstatus (obfd,
						   note_data,
						   note_size,
						   lwp,
						   stop_signal, &gregs);
@


1.176
log
@gdb/
	* linux-nat.c (linux_handle_extended_wait): Handle case when
	event == PTRACE_EVENT_CLONE && stopping && WSTOPSIG (status) != SIGSTOP.
@
text
@a1075 1
static int cancel_breakpoint (struct lwp_info *lp);
@


1.175
log
@gdb/
	Code cleanup.
	* linux-nat.c (linux_nat_wait_1): Reset STATUS after calling
	linux_nat_wait_1.  Use always LP->STATUS afterwards.
@
text
@d2282 17
@


1.174
log
@gdb/
	* linux-nat.c (linux_handle_extended_wait): Move variable new_lp into
	a more inner block.  Remove its unused declaration initializer.
@
text
@d3370 3
d3381 1
a3381 1
			 ptid_get_lwp (lp->ptid), status);
d3418 1
a3418 1
	      else if (WIFEXITED (status) || WIFSIGNALED (status))
@


1.173
log
@	* linux-nat.c (linux_nat_do_thread_registers): Use section size
	from gdbarch_core_regset_sections also for .reg if present.

	* amd64-linux-tdep.c (amd64_linux_regset_sections): Fix incorrect
	section size for .reg.
	* ppc-linux-tdep.c (ppc_linux_vsx_regset_sections): Likewise.
	(ppc_linux_vmx_regset_sections): Likewise.
	(ppc_linux_fp_regset_sections): Likewise.
	(ppc64_linux_vsx_regset_sections): New variable.
	(ppc64_linux_vmx_regset_sections): Likewise.
	(ppc64_linux_fp_regset_sections): Likewise.
	(ppc_linux_init_abi): Install core_regset_section lists appropriate
	for current word size.
@
text
@a2151 1
  struct lwp_info *new_lp = NULL;
d2215 2
d2218 1
@


1.172
log
@	* breakpoint.c (update_watchpoint, _initialize_breakpoint): Remove
	unnecessary space in string.
	* filesystem.c (_initialize_filesystem): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* infcmd.c (step_once): Ditto.
	* infrun.c (_initialize_infrun): Ditto.
	* linux-nat.c (linux_child_follow_fork): Ditto.
	* maint.c (maintenance_deprecate): Ditto.
	* memattr.c (_initialize_mem): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* monitor.c (monitor_open): Ditto.
	* procfs.c (procfs_xfer_memory): Ditto.
	* reverse.c (bookmarks_info): Ditto.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Ditto.
	* stack.c (_initialize_stack): Ditto.
	* tracepoint.c (_initialize_tracepoint): Ditto.
	* xtensa-tdep.c (xtensa_supply_gregset,
	xtensa_regset_from_core_section): Ditto.
@
text
@a4136 2
  gdb_gregset_t gregs;
  gdb_fpregset_t fpregs;
a4153 15
  if (core_regset_p
      && (regset = gdbarch_regset_from_core_section (gdbarch, ".reg",
						     sizeof (gregs))) != NULL
      && regset->collect_regset != NULL)
    regset->collect_regset (regset, regcache, -1,
			    &gregs, sizeof (gregs));
  else
    fill_gregset (regcache, &gregs, -1);

  note_data = (char *) elfcore_write_prstatus (obfd,
					       note_data,
					       note_size,
					       lwp,
					       stop_signal, &gregs);

a4160 6
	/* .reg was already handled above.  */
	if (strcmp (sect_list->sect_name, ".reg") == 0)
	  {
	    sect_list++;
	    continue;
	  }
d4168 10
a4177 6
	note_data = (char *) elfcore_write_register_note (obfd,
							  note_data,
							  note_size,
							  sect_list->sect_name,
							  gdb_regset,
							  sect_list->size);
d4187 18
@


1.171
log
@2010-06-18  Stan Shebs  <stan@@codesourcery.com>

	* osdata.c (get_osdata): Warn separately if target does not report
	type list.
	(info_osdata_command): Allow empty type, report error if target
	does not return available types of OS data.
	* linux-nat.c (linux_nat_xfer_osdata): Report list of OS data
	types if no annex supplied.

	* gdb.texinfo (Operating System Auxiliary Information): Describe
	"info os" when no arguments given.
@
text
@d682 1
a682 1
Can not resume the parent process over vfork in the foreground while \n\
@


1.170
log
@gdb/
	* linux-nat.c (linux_nat_core_of_thread_1): Fix crash on invalid
	CONTENT.

gdb/gdbserver/
	* linux-low.c (linux_core_of_thread): Fix crash on invalid CONTENT.
	New comment.
@
text
@d4951 39
@


1.169
log
@gdb/
	* linux-nat.c (linux_nat_wait_1): Do not call
	linux_nat_core_of_thread_1 on TARGET_WAITKIND_EXITED or
	TARGET_WAITKIND_SIGNALLED.
@
text
@d5512 6
a5517 1
  p = strchr (p, ')') + 2; /* skip ")" and a whitespace. */
d5521 3
a5523 2
  p = strtok_r (p, " ", &ts);
  for (i = 0; i != 36; ++i)
d5526 1
a5526 1
  if (sscanf (p, "%d", &core) == 0)
@


1.168
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* jv-lang.c: White space.
	* jv-typeprint.c: White space.
	* jv-valprint.c: White space.
	* language.c: White space.
	* libunwind-frame.c: White space.
	* linespec.c: White space.
	* linux-nat.c: White space.
	* linux-record.c: White space.
	* linux-thread-db.c: White space.
@
text
@d3629 7
a3635 1
  lp->core = linux_nat_core_of_thread_1 (lp->ptid);
@


1.167
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* linux-nat.c (top level): Delete unused global variable.
	(linux_tracefork_child): Delete unused variable.
	(linux_child_follow_fork): Delete unused variable.
	(linux_nat_detach): Delete unused variable.
	(linux_handle_extended_wait): Delete unused variable.
	(linux_nat_has_pending_sigint): Delete unused variable.
	(linux_nat_find_memory_regions): Delete unused variable.
	(linux_nat_make_corefile_notes): Delete unused variables.
	(linux_nat_info_proc_cmd): Delete unused variable.
	(linux_proc_pending_signals): Delete unused variable.
	(linux_nat_stop_lwp): Delete unused variables.
	(_initialize_linux_nat): Delete unused variable.
@
text
@d371 1
d387 1
d1651 1
d1664 1
d3809 1
d4348 1
d4505 1
d4601 1
d4932 2
a4933 2
                    const char *annex, gdb_byte *readbuf,
                    const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
d4953 1
a4953 1
       obstack_free (&obstack, NULL);
d4961 54
a5014 51
       {
         struct dirent *dp;
         while ((dp = readdir (dirp)) != NULL)
           {
             struct stat statbuf;
             char procentry[sizeof ("/proc/4294967295")];

             if (!isdigit (dp->d_name[0])
                 || NAMELEN (dp) > sizeof ("4294967295") - 1)
               continue;

             sprintf (procentry, "/proc/%s", dp->d_name);
             if (stat (procentry, &statbuf) == 0
                 && S_ISDIR (statbuf.st_mode))
               {
                 char *pathname;
                 FILE *f;
                 char cmd[MAXPATHLEN + 1];
                 struct passwd *entry;

                 pathname = xstrprintf ("/proc/%s/cmdline", dp->d_name);
                 entry = getpwuid (statbuf.st_uid);

                 if ((f = fopen (pathname, "r")) != NULL)
                   {
                     size_t len = fread (cmd, 1, sizeof (cmd) - 1, f);
                     if (len > 0)
                       {
                         int i;
                         for (i = 0; i < len; i++)
                           if (cmd[i] == '\0')
                             cmd[i] = ' ';
                         cmd[len] = '\0';

                         obstack_xml_printf (
			   &obstack,
			   "<item>"
			   "<column name=\"pid\">%s</column>"
			   "<column name=\"user\">%s</column>"
			   "<column name=\"command\">%s</column>"
			   "</item>",
			   dp->d_name,
			   entry ? entry->pw_name : "?",
			   cmd);
                       }
                     fclose (f);
                   }

                 xfree (pathname);
               }
           }
d5016 2
a5017 2
         closedir (dirp);
       }
d5492 1
d5528 1
@


1.166
log
@	Remove remaining "%ll" uses.
	* go32-nat.c (go32_pte_for_address): Replace "0x%llx" using
	hex_string call.
	* rs6000-nat.c (rs6000_ptrace64): Idem.
	* solib-pa64.c (pa64_current_sos): Idem.
	* solib-spu.c (spu_current_sos): Idem.
	* linux-nat.c (linux_nat_find_memory_regions): Replace "%lld" using
	plongest call.
	* nto-procfs.c (procfs_meminfo): Replace "0x%016llx" using
	phex (VAR, 8) call.
	* sh64-tdep.c (sh64_show_media_regs): Idem.
@
text
@a272 2
static int linux_parent_pid;

a405 2
  int ret;

a865 1
      struct thread_info *tp;
a1749 1
  enum target_signal sig;
a2211 2
	  struct cleanup *old_chain;

a2469 1
  int i;
a4052 1
  int ret;
a4359 1
  struct cleanup *old_chain;
a4364 1
  ptid_t current_ptid = inferior_ptid;
a4433 1
  int environ_f = 0;
a4887 1
  int signum;
a5351 1
      int pid, status;
a5611 2
  sigset_t mask;

@


1.165
log
@	* linux-nat.c (linux_nat_detach): Check debug_linux_nat.
@
text
@d4089 2
a4090 2
			    "Save segment, %lld bytes at %s (%c%c%c)",
			    size, paddress (target_gdbarch, addr),
@


1.164
log
@	* inferior.h (ptid_match): Declare.
	* infrun.c (ptid_match): New.
	* remote.c (queued_stop_reply): Rewrite and use ptid_match.
	(handle_notification): Add debug output.
	* linux-nat.c (ptid_match): Delete.
@
text
@d1786 5
a1790 4
      fprintf_unfiltered (gdb_stdlog,
			  "LND: Sending signal %s to %s\n",
			  args,
 			  target_pid_to_str (main_lwp->ptid));
@


1.163
log
@	* linux-nat.c (linux_nat_resume): In non-stop, also only tag
	resumed LWPs as resumed.
	(linux_nat_wait_1): If there's no resumed LWP in the set of LWPs
	we're waiting for, bail out with TARGET_WAITKIND_IGNORE, instead
	of throwing an internal error.  If an LWP of a process we're not
	waiting for reports a signal, don't force collecting a SIGSTOP,
	and if it was breakpoint hit in non-stop mode, cancel it.  Don't
	go through all LWPs cancelling breakpoints in non-stop mode.
	(resume_stopped_resumed_lwps): New.
	(linux_nat_wait): Use it.
@
text
@a1223 27
/* Returns true if PTID matches filter FILTER.  FILTER can be the wild
   card MINUS_ONE_PTID (all ptid match it); can be a ptid representing
   a process (ptid_is_pid returns true), in which case, all lwps of
   that give process match, lwps of other process do not; or, it can
   represent a specific thread, in which case, only that thread will
   match true.  PTID must represent an LWP, it can never be a wild
   card.  */

static int
ptid_match (ptid_t ptid, ptid_t filter)
{
  /* Since both parameters have the same type, prevent easy mistakes
     from happening.  */
  gdb_assert (!ptid_equal (ptid, minus_one_ptid)
	      && !ptid_equal (ptid, null_ptid));

  if (ptid_equal (filter, minus_one_ptid))
    return 1;
  if (ptid_is_pid (filter)
      && ptid_get_pid (ptid) == ptid_get_pid (filter))
    return 1;
  else if (ptid_equal (ptid, filter))
    return 1;

  return 0;
}

@


1.163.2.1
log
@	* linux-nat.c (linux_nat_detach): Check debug_linux_nat.
@
text
@d1813 4
a1816 5
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LND: Sending signal %s to %s\n",
			    args,
			    target_pid_to_str (main_lwp->ptid));
@


1.162
log
@Delete unused or undefined functions.

        * breakpoint.c (ep_parse_optional_filename): Delete.
        * dcache.c (dcache_write_line): Remove declaration.
        * infrun.c (build_infrun): Remove declaration.
        * tracepoint.c (tracepoint_save_command): Remove declaration.
        * linux-nat.c (init_lwp_list): Delete. No longer used.
        * event-loop.c (check_async_signal_handlers): Delete declaration.
        * infrun.c (init_execution_control_state): Delete.
        (proceed): Update comment to avoid mentioning
        init_execution_control_state.
        * target.c (kill_or_be_killed, nosupport_runtime): Delete.
        * ada-lang.c (ada_to_static_fixed_value): Delete.
        * scm-lang.c (evaluate_subexp_scm): Delete declaration.
        * cp-namespace.c (cp_copy_usings): Delete.
        * xml-syscall.c (xml_number_of_syscalls): Delete.
        * progspace.c (find_program_space_by_num): Delete.
        * inflow.c (handle_sigio): Delete declaration.
        * hppa-tdep.c (hppa_alignof): Delete.
        * mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset)
        (mipsnbsd_core_osabi_sniffer): Delete.
@
text
@d1915 2
a1916 8
  if (!non_stop)
    {
      /* Mark the lwps we're resuming as resumed.  */
      iterate_over_lwps (minus_one_ptid, resume_clear_callback, NULL);
      iterate_over_lwps (ptid, resume_set_callback, NULL);
    }
  else
    iterate_over_lwps (minus_one_ptid, resume_set_callback, NULL);
d3259 14
a3272 2
  /* Make sure there is at least one LWP that has been resumed.  */
  gdb_assert (iterate_over_lwps (ptid, resumed_callback, NULL));
d3403 2
d3413 24
a3436 6
		      stop_callback (lp, NULL);

		      /* Resume in order to collect the sigstop.  */
		      ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);

		      stop_wait_callback (lp, NULL);
d3626 10
d3637 2
a3638 5

  /* Now that we've selected our final event LWP, cancel any
     breakpoints in other LWPs that have hit a GDB breakpoint.  See
     the comment in cancel_breakpoints_callback to find out why.  */
  iterate_over_lwps (minus_one_ptid, cancel_breakpoints_callback, lp);
d3664 41
d3719 10
@


1.161
log
@gdb/
	Support Valgrind attachments broken by the PIE support.
	* auxv.c: Include gdbcore.h.
	(procfs_xfer_auxv): Make static.  Reduce its comment.  Drop its
	parameters ops, object and annex.  Remove their assertions.
	(ld_so_xfer_auxv, memory_xfer_auxv): New function.
	* auxv.h (procfs_xfer_auxv): Remove comment.  Rename to ...
	(memory_xfer_auxv): ... here.
	* linux-nat.c (linux_xfer_partial): Rename procfs_xfer_auxv to
	memory_xfer_auxv.
	* procfs.c (procfs_xfer_partial): Likewise.
	* solib-svr4.c (svr4_relocate_main_executable): New prototype.
	(svr4_special_symbol_handling): Call svr4_relocate_main_executable.
	(svr4_solib_create_inferior_hook): Conditionalize the
	svr4_relocate_main_executable call.

gdb/testsuite/
	* gdb.base/valgrind-db-attach.exp, gdb.base/valgrind-db-attach.c: New.
@
text
@a1107 19
/* Initialize the list of LWPs.  Note that this module, contrary to
   what GDB's generic threads layer does for its thread list,
   re-initializes the LWP lists whenever we mourn or detach (which
   doesn't involve mourning) the inferior.  */

static void
init_lwp_list (void)
{
  struct lwp_info *lp, *lpnext;

  for (lp = lwp_list; lp; lp = lpnext)
    {
      lpnext = lp->next;
      xfree (lp);
    }

  lwp_list = NULL;
}

@


1.160
log
@	Implement core awareness.

	* bcache.c (compare_ints): Remove
	(print_percentage): Use compare_positive_ints.
	* defs.h (compare_positive_ints): Declare.
	* linux-nat.h (struct lin_lwp): New field core.
	(linux_nat_core_of_thread_1): Declare.
	* linux-nat.c (add_lwp): Init the 'core' field.
	(linux_nat_wait_1): Record the core.
	(linux_nat_core_of_thread_1, linux_nat_core_of_thread): New.
	(linux_nat_add_target): Register the above.
	* linux-thread-db.c (update_thread_core): New.
	(thread_db_find_new_threads): Update core information for
	every thread.
	* remote.c (struct private_thread_info): New.
	(free_private_thread_info, demand_private_info): New.
	(PACKET_qXfer_threads, use_osdata_threads): New.
	(struct thread_item, threads_parsing_context
	(start_thread, end_thread, thread_attributes)
	(thread_children, threads_children, threads_elements): New.
	(remote_threads_info): Try qXfer:threads before anything
	else.
	(remote_protocol_packets): Register qXfer:threads.
	(remote_open_1): Init use_osdata_threads.
	(struct stop_reply): New field 'core'.
	(remote_parse_stop_reply): Parse core number.
	(process_stop_reply): Record core number.
	(remote_xfer_partial): Handle qXfer:threads.
	(remote_core_of_thread): New.
	(init_remote_ops): Register remote_core_of_thread.
	(_initialize_remote): Register qXfer:read.
	* target.c (target_core_of_thread): New
	* target.h (enum target_object): New value TARGET_OBJECT_THREADS.
	(struct target_ops): New field to_core_of_threads.
	(target_core_of_thread): Declare.
	* gdbthread.h (struct thread_info): New field private_dtor.
	* thread.c (print_thread_info): Report the core.
	* ui-out.c (MAX_UI_OUT_LEVELS): Increase.
	* utils.c (compare_positive_ints): New.
	* features/threads.dtd: New.
	* mi/mi-interp.c (mi_on_normal_stop): Report the core.
	* mi/mi-main.c (struct collect_cores_data, collect_cores)
	(do_nothing, free_vector_of_osdata_items)
	(splay_tree_int_comparator, free_splay_tree): New.
	(print_one_inferior_data): Implemented printing of selected
	inferiors.  Collect and print cores.
	(output_cores): New.
	(mi_cmd_list_thread_groups): Support --recurse.  Permit specifying
	thread groups together with --available.
@
text
@d5012 1
a5012 1
    return procfs_xfer_auxv (ops, object, annex, readbuf, writebuf,
@


1.159
log
@gdb/
	Add from_tty to solib_create_inferior_hook.
	* infcmd.c (post_create_inferior): Move solib_add after
	solib_create_inferior_hook.  Pass from_tty to
	solib_create_inferior_hook.  Call solib_add and SOLIB_ADD with
	0 from_tty and comment why.
	* infrun.c (follow_exec): Pass from_tty solib_create_inferior_hook as 0.
	* linux-nat.c (linux_child_follow_fork): Likewise.
	* nto-procfs.c (procfs_post_attach, procfs_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): New parameter
	from_tty.
	* solib-frv.c (frv_solib_create_inferior_hook): Likewise.
	* solib-irix.c (irix_solib_create_inferior_hook): Likewise.
	* solib-null.c (null_solib_create_inferior_hook): Likewise.
	* solib-osf.c (osf_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-som.c (som_solib_create_inferior_hook): Likewise.
	* solib-spu.c (spu_solib_create_inferior_hook): New parameter from_tty.
	Pass it to svr4_so_ops.solib_create_inferior_hook.
	* solib-sunos.c (sunos_solib_create_inferior_hook): New parameter
	from_tty.
	* solib-svr4.c (enable_break): New parameter from_tty.  Pass it to
	solib_add.
	(svr4_solib_create_inferior_hook): New parameter from_tty.  Pass it to
	enable_break.
	* solib-target.c (solib_target_solib_create_inferior_hook): New
	parameter from_tty.
	* solib.c (solib_create_inferior_hook): New parameter from_tty.  Pass
	it to ops->solib_create_inferior_hook.
	(reload_shared_libraries): Pass from_tty to solib_create_inferior_hook.
	Move solib_add after solib_create_inferior_hook, call it now with
	from_tty as 0.  New comment there.
	* solib.h (solib_create_inferior_hook): New parameter from_tty.
	* solist.h (struct target_so_ops <solib_create_inferior_hook>):
	Likewise.
@
text
@d1187 1
d3646 1
d5428 69
d5537 2
@


1.158
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d772 1
a772 1
	      solib_create_inferior_hook ();
d955 1
a955 1
	  solib_create_inferior_hook ();
@


1.157
log
@	gdb/
	* linux-nat.c (kill_lwp): Minor cleanup, move definition of
	tkill_failed into ifdef HAVE_TKILL_SYSCALL.  Move setting of errno
	there too.  Delete unnecessary resetting of errno after syscall.
	Minor comment changes to match gdbserver/linux-low.c:kill_lwp.

	gdbserver/
	* linux-low.c (kill_lwp): Use __NR_tkill instead of SYS_tkill.
	Move definition of tkill_failed to ifdef __NR_tkill to avoid gcc
	warning ifndef __NR_tkill.  Move setting of errno there too.
	Delete unnecessary resetting of errno after syscall.
	Minor comment changes to match gdb/linux-nat.c:kill_lwp.
@
text
@d3 1
a3 1
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.156
log
@gdb/
2009-11-20  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	Fix reordered watchpoints triggered in other threads during all-stop.

	* linux-nat.c (resume_callback, linux_nat_resume): Clear
	stopped_by_watchpoint.
	(save_sigtrap, linux_nat_stopped_by_watchpoint)
	(linux_nat_stopped_data_address): New.
	(stop_wait_callback, linux_nat_filter_event): Call save_sigtrap.
	(linux_nat_add_target): Install linux_nat_stopped_by_watchpoint
	and linux_nat_stopped_data_address.
	* linux-nat.h (struct lwp_info): New fields stopped_by_watchpoint,
	stopped_data_address_p and stopped_data_address.

gdb/testsuite/
2009-11-20  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* gdb.base/watchthreads-reorder.exp,
	gdb.base/watchthreads-reorder.c: New.
@
text
@d2037 1
a2037 3
/* Issue kill to specified lwp.  */

static int tkill_failed;
d2042 6
a2047 1
  errno = 0;
d2049 3
a2051 2
/* Use tkill, if possible, in case we are using nptl threads.  If tkill
   fails, then we are not using nptl threads and we should be using kill.  */
d2053 7
a2059 9
#ifdef HAVE_TKILL_SYSCALL
  if (!tkill_failed)
    {
      int ret = syscall (__NR_tkill, lwpid, signo);
      if (errno != ENOSYS)
	return ret;
      errno = 0;
      tkill_failed = 1;
    }
@


1.155
log
@	* breakpoint.c (should_be_inserted): Don't insert breakpoints if
	the pspace doesn't allow breakpoints.
	(insert_breakpoint_locations): Remove waiting_for_vfork_done
	special case.  Expect watchpoints that shouldn't be inserted, to
	not be inserted.
	* progspace.h (struct program_space) <breakpoints_not_allowed>:
	New field.
	* infrun.c (handle_inferior_event): Clear it.
	* linux-nat.c (linux_child_follow_fork): Set it.
@
text
@d1885 1
d2023 1
d2575 68
d2701 2
a3101 1
  /* Save the trap's siginfo in case we need it later.  */
d3103 6
a3108 1
    save_siginfo (lp);
d5447 2
@


1.154
log
@	* linux-nat.c (linux_nat_thread_address_space): New.
	(linux_nat_add_target): Install it.
	* progspace.c (address_space_num): New.
	* progspace.h (address_space_num): Declare.
	* target.c (target_thread_address_space): Really query the target.
	* target.h (struct target_ops) <to_thread_address_space>: New
	field.
@
text
@d796 1
@


1.153
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d5314 33
d5369 1
@


1.152
log
@2009-10-15  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* linux-nat.c (linux_nat_post_attach_wait): Adjust assert.
	(lin_lwp_attach_lwp, linux_nat_attach): Handle disappearing LWP.
@
text
@d58 1
d673 17
d692 2
a695 11
      /* Before detaching from the child, remove all breakpoints from
         it.  If we forked, then this has already been taken care of
         by infrun.c.  If we vforked however, any breakpoint inserted
         in the parent is visible in the child, even those added while
         stopped in a vfork catchpoint.  This won't actually modify
         the breakpoint list, but will physically remove the
         breakpoints from the child.  This will remove the breakpoints
         from the parent also, but they'll be reinserted below.  */
      if (has_vforked)
	detach_breakpoints (child_pid);

d699 13
a724 1
	  struct lwp_info *lp;
d735 1
d739 35
a773 2
	  lp = add_lwp (inferior_ptid);
	  lp->stopped = 1;
d775 1
d783 15
d801 4
a804 1
	      int status;
d806 5
a810 5
	      ptrace (PTRACE_CONT, parent_pid, 0, 0);
	      my_waitpid (parent_pid, &status, __WALL);
	      if ((status >> 16) != PTRACE_EVENT_VFORK_DONE)
		warning (_("Unexpected waitpid result %06x when waiting for "
			 "vfork-done"), status);
d845 4
d850 14
a864 4

	  /* Since we vforked, breakpoints were removed in the parent
	     too.  Put them back.  */
	  reattach_breakpoints (parent_pid);
d872 1
a872 3

      /* Before detaching from the parent, remove all breakpoints from it. */
      remove_breakpoints ();
d877 8
a884 3
	  fprintf_filtered (gdb_stdlog,
			    "Attaching after fork to child process %d.\n",
			    child_pid);
d896 11
a906 17
      /* If we're vforking, we may want to hold on to the parent until
	 the child exits or execs.  At exec time we can remove the old
	 breakpoints from the parent and detach it; at exit time we
	 could do the same (or even, sneakily, resume debugging it - the
	 child's exec has failed, or something similar).

	 This doesn't clean up "properly", because we can't call
	 target_detach, but that's OK; if the current target is "child",
	 then it doesn't need any further cleanups, and lin_lwp will
	 generally not encounter vfork (vfork is defined to fork
	 in libpthread.so).

	 The holding part is very easy if we have VFORKDONE events;
	 but keeping track of both processes is beyond GDB at the
	 moment.  So we don't expose the parent to the rest of GDB.
	 Instead we quietly hold onto it until such time as we can
	 safely resume it.  */
d910 7
a916 18
	  struct lwp_info *parent_lwp;

	  linux_parent_pid = parent_pid;

	  /* Get rid of the inferior on the core side as well.  */
	  inferior_ptid = null_ptid;
	  detach_inferior (parent_pid);

	  /* Also get rid of all its lwps.  We will detach from this
	     inferior soon-ish, but, we will still get an exit event
	     reported through waitpid when it exits.  If we didn't get
	     rid of the lwps from our list, we would end up reporting
	     the inferior exit to the core, which would then try to
	     mourn a non-existing (from the core's perspective)
	     inferior.  */
	  parent_lwp = find_lwp_pid (pid_to_ptid (parent_pid));
	  purge_lwp_list (GET_PID (parent_lwp->ptid));
	  linux_parent_pid = parent_pid;
d921 6
d931 25
d957 1
d1858 10
a1867 1
  if (lp->stopped && lp->status == 0)
d1988 1
a1988 1
  if (lp->status)
d2354 6
a2359 1
      if (linux_parent_pid)
d2361 4
a2364 2
	  detach_breakpoints (linux_parent_pid);
	  ptrace (PTRACE_DETACH, linux_parent_pid, 0, 0);
d2366 2
a2367 1
	  linux_parent_pid = 0;
d2370 6
a2375 11
      /* At this point, all inserted breakpoints are gone.  Doing this
	 as soon as we detect an exec prevents the badness of deleting
	 a breakpoint writing the current "shadow contents" to lift
	 the bp.  That shadow is NOT valid after an exec.

	 Note that we have to do this after the detach_breakpoints
	 call above, otherwise breakpoints wouldn't be lifted from the
	 parent on a vfork, because detach_breakpoints would think
	 that breakpoints are not inserted.  */
      mark_breakpoints_out ();
      return 0;
d2577 7
d2818 1
a2818 1
  if (breakpoint_inserted_here_p (pc))
@


1.151
log
@	* linux-nat.c (linux_nat_wait_1): Bail out, if TARGET_WNOHANG and
	we found no event while waiting for a specific LWP.
	* infrun.c (handle_inferior_event): Handle TARGET_WAITKIND_IGNORE
	before anything else.
@
text
@d1341 10
a1350 1
  gdb_assert (pid == new_pid && WIFSTOPPED (status));
d1408 3
d1510 33
@


1.150
log
@	* linux-nat.c (TRAP_IS_SYSCALL, TRAP_REMOVE_SYSCALL_FLAG): Delete.
	(SYSCALL_SIGTRAP): New.
	(status_to_str): Adjust.
	(get_pending_status): Pending events in lp->waitstatus don't map
	to any signal.  Simplify.
	(linux_handle_syscall_trap): New.
	(linux_handle_extended_wait): When handling PTRACE_EVENT_CLONE
	events, use linux_ops->to_resume instead of direct ptrace with
	PTRACE_CONT.  Remove all TRAP_IS_SYSCALL handling.
	(wait_lwp): Handle syscall traps with linux_handle_syscall_trap,
	and clear the sysgood bit.
	(status_callback): Make it clearer and add comments.
	(cancel_breakpoints_callback): Ignore if LP has waitstatus set.
	(linux_nat_filter_event): Handle syscall traps with
	linux_handle_syscall_trap, and clear the sysgood bit.  Move the
	check for storing siginfo to after handling extended statuses and
	syscall traps.  Store status in the lwp object.
	(linux_wait_1): Don't swap the pending status out of the lwp
	object until after deciding we found an lwp with an interesting
	event.  Requeue a new pending signal if we find one while getting
	rid or a pending SIGSTOP we sent ourselves.  Don't clear the
	sysgood bit here.

	* infrun.c (deal_with_syscall_event): Rename to ...
	(handle_syscall_event): ... this.  Always context switch and set
	stop_pc, even if not catching the syscall.  If not catching the
	syscall, always resume with keep_going.
	(handle_inferior_event): Adjust.
@
text
@d3258 11
@


1.149
log
@	(TRAP_REMOVE_SYSCALL_FLAG): New macro.
	(linux_nat_wait_1): Mask off is-syscall bit in wait status for
	TRAP_IS_SYSCALL before passing value to caller.
@
text
@a69 5
/* To be used when one needs to know wether a
   WSTOPSIG (status) is a syscall */
#define TRAP_IS_SYSCALL (SIGTRAP | 0x80)
#define TRAP_REMOVE_SYSCALL_FLAG(status) ((status) & ~(0x80 << 8))

d187 5
d985 1
a985 1
      if (WSTOPSIG (status) == TRAP_IS_SYSCALL)
d1517 1
a1517 2
  struct target_waitstatus last;
  ptid_t last_ptid;
d1519 20
a1538 1
  get_last_target_status (&last_ptid, &last);
d1540 13
a1552 4
  /* If this lwp is the ptid that GDB is processing an event from, the
     signal will be in stop_signal.  Otherwise, we may cache pending
     events in lp->status while trying to stop all threads (see
     stop_wait_callback).  */
d1554 1
a1554 1
  *status = 0;
d1556 1
a1556 5
  if (non_stop)
    {
      enum target_signal signo = TARGET_SIGNAL_0;

      if (is_executing (lp->ptid))
a1557 14
	  /* If the core thought this lwp was executing --- e.g., the
	     executing property hasn't been updated yet, but the
	     thread has been stopped with a stop_callback /
	     stop_wait_callback sequence (see linux_nat_detach for
	     example) --- we can only have pending events in the local
	     queue.  */
	  signo = target_signal_from_host (WSTOPSIG (lp->status));
	}
      else
	{
	  /* If the core knows the thread is not executing, then we
	     have the last signal recorded in
	     thread_info->stop_signal.  */

d1561 1
d1563 13
a1575 5
      if (signo != TARGET_SIGNAL_0
	  && !signal_pass_state (signo))
	{
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog, "\
d1577 2
a1578 14
				target_pid_to_str (lp->ptid),
				target_signal_to_string (signo));
	}
      else
	{
	  if (signo != TARGET_SIGNAL_0)
	    *status = W_STOPCODE (target_signal_to_host (signo));

	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"GPT: lwp %s as pending signal %s\n",
				target_pid_to_str (lp->ptid),
				target_signal_to_string (signo));
	}
d1582 7
a1588 9
      if (GET_LWP (lp->ptid) == GET_LWP (last_ptid))
	{
	  struct thread_info *tp = find_thread_ptid (lp->ptid);
	  if (tp->stop_signal != TARGET_SIGNAL_0
	      && signal_pass_state (tp->stop_signal))
	    *status = W_STOPCODE (target_signal_to_host (tp->stop_signal));
	}
      else
	*status = lp->status;
d1900 127
d2152 3
d2157 2
d2161 7
a2167 2
	      ptrace (PTRACE_CONT, new_pid, 0,
		      status ? WSTOPSIG (status) : 0);
d2174 2
a2175 1
	  ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
a2214 41
  /* Used for 'catch syscall' feature.  */
  if (WSTOPSIG (status) == TRAP_IS_SYSCALL)
    {
      if (catch_syscall_enabled () == 0)
	  ourstatus->kind = TARGET_WAITKIND_IGNORE;
      else
	{
	  struct regcache *regcache = get_thread_regcache (lp->ptid);
	  struct gdbarch *gdbarch = get_regcache_arch (regcache);

	  ourstatus->value.syscall_number =
	    (int) gdbarch_get_syscall_number (gdbarch, lp->ptid);

	  /* If we are catching this specific syscall number, then we
	     should update the target_status to reflect which event
	     has occurred.  But if this syscall is not to be caught,
	     then we can safely mark the event as a SYSCALL_RETURN.

	     This is particularly needed if:

	       - We are catching any syscalls, or
	       - We are catching the syscall "exit"

	     In this case, as the syscall "exit" *doesn't* return,
	     then GDB would be confused because it would mark the last
	     syscall event as a SYSCALL_ENTRY.  After that, if we re-ran the
	     inferior GDB will think that the first syscall event is
	     the opposite of a SYSCALL_ENTRY, which is the SYSCALL_RETURN.
	     Therefore, GDB would report inverted syscall events.  */
	  if (catching_syscall_number (ourstatus->value.syscall_number))
	    ourstatus->kind = 
	      (lp->syscall_state == TARGET_WAITKIND_SYSCALL_ENTRY) ?
	      TARGET_WAITKIND_SYSCALL_RETURN : TARGET_WAITKIND_SYSCALL_ENTRY;
	  else
	    ourstatus->kind = TARGET_WAITKIND_SYSCALL_RETURN;

	  lp->syscall_state = ourstatus->kind;
	}
      return 0;
    }

d2280 12
d2558 17
a2574 6
  /* We check for lp->waitstatus in addition to lp->status, because we
     can have pending process exits recorded in lp->waitstatus, and
     W_EXITCODE(0,0) == 0.  */
  return ((lp->status != 0
	   || lp->waitstatus.kind != TARGET_WAITKIND_IGNORE)
	  && lp->resumed);
d2684 2
a2685 1
  if (lp->status != 0
d2836 11
a2846 4
  /* Save the trap's siginfo in case we need it later.  */
  if (WIFSTOPPED (status)
      && (WSTOPSIG (status) == SIGTRAP || WSTOPSIG (status) == TRAP_IS_SYSCALL))
    save_siginfo (lp);
d2848 2
a2849 6
  /* Handle GNU/Linux's extended waitstatus for trace events.
     It is necessary to check if WSTOPSIG is signaling that
     the inferior is entering/exiting a system call.  */
  if (WIFSTOPPED (status)
      && ((WSTOPSIG (status) == TRAP_IS_SYSCALL)
          || (WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)))
d2859 4
d2984 1
d3044 1
a3044 4
	  status = lp->status;
	  lp->status = 0;

	  if (debug_linux_nat && status)
d3047 1
a3047 1
				status_to_str (status),
a3065 2
      status = lp->status;
      lp->status = 0;
d3067 1
a3067 1
      if (debug_linux_nat && status)
d3070 1
a3070 1
			    status_to_str (status),
d3083 1
a3083 1
      if (status == 0 && lp->waitstatus.kind == TARGET_WAITKIND_IGNORE)
d3111 4
a3114 1
      /* This should catch the pending SIGSTOP.  */
d3116 15
a3161 6
	  /* If this was a syscall trap, we no longer need or want
	     the 0x80 flag, remove it.  */
	  if (WIFSTOPPED (status)
	      && WSTOPSIG (status) == TRAP_IS_SYSCALL)
	    status = TRAP_REMOVE_SYSCALL_FLAG (status);

d3170 1
a3170 1
	      if (WIFSTOPPED (status))
d3172 1
a3172 1
		  if (WSTOPSIG (status) != SIGSTOP)
a3173 2
		      lp->status = status;

a3199 1
		  lp->status = status;
d3212 1
a3212 1
		  store_waitstatus (&lp->waitstatus, status);
d3268 3
@


1.148
log
@	* linux-nat.c (status_to_str): Handle TRAP_IS_SYSCALL.
@
text
@d73 1
d3016 6
@


1.147
log
@Implementing catch syscall.

* amd64-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(amd64_linux_get_syscall_number): New function.
(amd64_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* breakpoint.c: New include: xml-syscall.h.
(set_raw_breakpoint_without_location): Setting the parameters
for the catch syscall feature.
(insert_catch_syscall): New.
(remove_catch_syscall): New.
(breakpoint_hit_catch_syscall): New.
(print_it_catch_syscall): New.
(print_one_catch_syscall): New.
(print_mention_catch_syscall): New.
(catch_syscall_breakpoint_ops): New.
(syscall_catchpoint_p): New.
(create_catchpoint_without_mention): New.
(create_catchpoint): Modified in order to use
create_catchpoint_without_mention.
(create_syscall_event_catchpoint): New.
(clean_up_filters): New.
(catch_syscall_split_args): New.
(catch_syscall_command_1): New.
(delete_breakpoint): Add cleanup for catch syscall.
(is_syscall_catchpoint_enabled): New.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
(catch_syscall_completer): New completer function.
(add_catch_command): Add the completer function for catchpoints.
* breakpoint.h (syscalls_to_be_caught): New vector.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
* gdbarch.c: Regenerated.
* gdbarch.h: Regenerated.
* gdbarch.sh: Add syscall catchpoint functions and structures.
(get_syscall_number): New.
(UNKNOWN_SYSCALL): New definition.
* i386-linux-nat.c (i386_linux_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* i386-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(i386_linux_get_syscall_number): New.
(i386_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* inf-child.c (inf_child_set_syscall_catchpoint): New.
(inf_child_target): Assign default values to target_ops.
* inf-ptrace.c (inf_ptrace_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* inferior.h (struct inferior): Included new variables
any_syscall_count, syscalls_counts and total_syscalls_count,
used to keep track of requested syscall catchpoints.
* infrun.c (resume): Add syscall catchpoint.
(deal_with_syscall_event): New.
(handle_inferior_event): Add syscall entry/return events.
(inferior_has_called_syscall): New.
* linux-nat.c: Define some helpful variables to track wether we have
support for the needed ptrace option.
(linux_test_for_tracesysgood): New.
(linux_supports_tracesysgood): New.
(linux_enable_tracesysgood): New.
(linux_enable_event_reporting): Save the current used ptrace
options.
(linux_child_post_attach): Calling linux_enable_tracesysgood.
(linux_child_post_startup_inferior): Likewise.
(linux_child_set_syscall_catchpoint): New function.
(linux_handle_extended_wait): Handle the case which the inferior stops
because it has called or returned from a syscall.
(linux_target_install_ops): Install the necessary functions to handle
syscall catchpoints.
* linux-nat.h (struct lwp_info): Include syscall_state into the
structure, which indicates if we are in a syscall entry or return.
* ppc-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall filename for the arch.
(ppc_linux_get_syscall_number): New.
(ppc_linux_init_abi): Register the correct functions for syscall
catchpoint; setting the correct name for the XML syscall file.
* target.c (update_current_target): Update/copy functions related to
syscall catchpoint.
(target_waitstatus_to_string): Add syscall catchpoint entry/return
events.
* target.h (struct target_waitstatus): Add syscall number.
(struct syscall): New struct to hold information about syscalls
in the system.
(struct target_ops): Add ops for syscall catchpoint.
(inferior_has_called_syscall): New.
(target_set_syscall_catchpoint): New.
* xml-support.c (xml_fetch_content_from_file): New function,
transferred from xml-tdesc.c.
* xml-support.h (xml_fetch_content_from_file): New.
* xml-tdesc.c (fetch_xml_from_file): Function removed;
transferred to xml-support.c.
(file_read_description_xml): Updated to use the new
xml_fetch_content_from_file function.
* syscalls/gdb-syscalls.dtd: New definition file for syscall's XML
support.
* syscalls/amd64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use amd64 architecture.
* syscalls/i386-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use i386 architecture.
* syscalls/ppc-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC architecture.
* syscalls/ppc64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC64 architecture.
* xml-syscall.c: New file containing functions for manipulating
syscall's XML files.
* xml-syscall.h: New file, exporting the functions above mentioned.
* Makefile.in: Support for relocatable GDB datadir and XML
syscall.
* NEWS: Added information about the catch syscall feature.
* doc/gdb.texinfo (Set Catchpoints): Documentation about the new
feature.
* testsuite/Makefile.in: Inclusion of catch-syscall object.
* testsuite/gdb.base/catch-syscall.c: New file.
* testsuite/gdb.base/catch-syscall.exp: New file.
@
text
@d983 8
a990 2
    snprintf (buf, sizeof (buf), "%s (stopped)",
	      strsignal (WSTOPSIG (status)));
@


1.146
log
@ChangeLog:

	* linux-nat.c: Include <sys/vfs.h>.
	(SPUFS_MAGIC): Define.
	(spu_enumerate_spu_ids): New function.
	(linux_proc_xfer_spu): New function.
	(linux_xfer_partial): Handle TARGET_OBJECT_SPU.

	(iterate_over_spus): New function.
	(struct linux_spu_corefile_data): New data type.
	(linux_spu_corefile_callback): New function.
	(linux_spu_make_corefile_notes): New function.
	(linux_nat_make_corefile_notes): Call it.

	* corelow.c (struct spuid_list): New data type.
	(add_to_spuid_list): New function.
	(core_xfer_partial): Handle TARGET_OBJECT_SPU.

gdbserver/ChangeLog:

	* linux-low.c: Include <sys/stat.h> and <sys/vfs.h>.
	(SPUFS_MAGIC): Define.
	(spu_enumerate_spu_ids): New function.
	(linux_qxfer_spu): New function.
	(linux_target_ops): Install linux_qxfer_spu.
@
text
@d70 4
d286 5
d302 3
d540 37
d596 16
a616 1
  int options;
d624 3
a626 2
  options = PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | PTRACE_O_TRACEEXEC
    | PTRACE_O_TRACECLONE;
d628 1
a628 1
    options |= PTRACE_O_TRACEVFORKDONE;
d633 1
a633 1
  ptrace (PTRACE_SETOPTIONS, pid, 0, options);
d641 1
d649 1
d880 14
d2066 41
d2705 2
a2706 1
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP)
d2709 6
a2714 2
  /* Handle GNU/Linux's extended waitstatus for trace events.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
d4640 1
@


1.145
log
@gdb/
	Fix memory access from signed 32bit inferior registers on 64bit GDB.
	* linux-nat.c (linux_xfer_partial <TARGET_OBJECT_MEMORY>): New variable
	addr_bit.  Mask OFFSET by the ADDR_BIT width.

gdb/testsuite/
	* gdb.arch/amd64-i386-address.exp, gdb.arch/amd64-i386-address.S: New.
@
text
@d57 5
d3669 113
d3843 2
d4178 94
d4477 4
@


1.145.2.1
log
@2009-07-25  Michael Snyder  <msnyder@@vmware.com>

	* inf-child.c (inf_child_target): Initialize target_ops only once.
	* inf-ptrace.c (inf_ptrace_target): Ditto.
	(inf_ptrace_trad_target): Ditto.
	* linux-nat.c (linux_target): Ditto.
	(linux_trad_target): Ditto.

	* linux-fork.c (_initialize_linux_fork): Rather than calling
	add_cmd to add checkpoint commands, use 'linux_target' to
	get the target vector, add the checkpoint functions to it,
	and call checkpoint_init to activate the user commands.
	(linux_fork_killall): Add optional verbose output.
@
text
@d4309 4
a4312 1
  static struct target_ops *t;
a4313 5
  if (t == NULL)
    {
      t = inf_ptrace_target ();
      linux_target_install_ops (t);
    }
d4320 4
a4323 1
  static struct target_ops *t;
a4324 5
  if (t == NULL)
    {
      t = inf_ptrace_trad_target (register_u_offset);
      linux_target_install_ops (t);
    }
@


1.144
log
@gdb/
2009-07-02  Pedro Alves  <pedro@@codesourcery.com>

	* linux-nat.c (linux_child_follow_fork): If we're staying attached
	to the child process, enable event reporting on it.  Don't handle
	checkpoints here.  Instead, add the child fork to the lwp thread
	and inferior lists without clobbering the previous inferior.  Let
	the thread_db layer learn about a new child process, even if
	following the parent.
	(linux_nat_switch_fork): Delete lwps of the current inferior only,
	instead of clearing the whole list.  Use thread_change_ptid to
	give the core the illusion the new checkpoint is still the same
	inferior.  Clear the register cache.
	(linux_handle_extended_wait): Handle checkpoints here.
	(linux_multi_process): Turn on.
	* linux-fork.c (struct fork_info) <pc>: Remove field.
	(init_fork_list): Do not delete the checkpoint from the inferior
	list (it is not there).
	(fork_load_infrun_state): Don't switch inferior_ptid here.  Pass
	the new checkpoint's ptid to linux_nat_switch_fork.
	(fork_save_infrun_state): Make static.  Don't stop the pc field of
	fork_info, it's gone.
	(linux_fork_mourn_inferior): Don't delete the checkpoint from the
	inferior list, it's not there.
	(linux_fork_detach): Ditto.
	(delete_fork_command): Replace mention of fork/checkpoint by
	checkpoint only.
	(detach_fork_command): Likewise.  Don't delete the checkpoint from
	the inferior list.
	(info_forks_command): Adjust.
	(restore_detach_fork): Delete.
	(checkpointing_pid): New.
	(linux_fork_checkpointing_p): New.
	(save_detach_fork): Delete.
	(checkpoint_command): Delete temp_detach_fork.  Don't remove
	breakpoints, that's a nop.  Store the pid of the process we're
	checkpointing, and use make_cleanup_restore_integer to restore it.
	Don't reinsert breakpoints here.
	(process_command, fork_command): Delete.
	(restart_command): Update comments to only mention checkpoints,
	not forks.
	(_initialize_linux_fork): Delete "fork", "process", "info forks"
	commands.
	* linux-fork.h (fork_save_infrun_state, fork_list): Delete
	declarations.
	(linux_fork_checkpointing_p): Declare.
	* cli/cli-cmds.c (killlist): New.
	* cli/cli-cmds.h (killlist): Declare.
	* gdbcmd.h (killlist): Declare.
	* inferior.c: Include "gdbthread.h".
	(detach_inferior_command, kill_inferior_command)
	(inferior_command): New.
	(info_inferiors_command): Allow specifying a specific inferior id.
	(_initialize_inferiors): Register "inferior", "kill inferior" and
	"detach inferior" commands.
	* infcmd.c (_initialize_infcmd): Make "kill" a prefix command.
	* gdbthread.h (any_thread_of_process): Declare.
	* thread.c (any_thread_of_process): New.

	* NEWS: Mention multi-inferior debugging.  Mention 'info
	inferiors', 'inferior', 'detach inferior' and 'kill inferior' as
	new commands.
	(Removed commands): New section, mentioning that 'info forks',
	'fork', 'process', 'delete fork' and 'detach fork' are now gone.

gdb/testsuite/
2009-07-02  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.base/multi-forks.exp: Only run detach-on-fork tests on
	linux.  Adjust to use "inferior", "info inferiors", "detach
	inferior" and "kill inferior" instead of "restart", "info fork",
	"detach fork" and "delete fork".
	* gdb.base/ending-run.exp: Spell out "info".
	* gdb.base/help.exp: Adjust to use test_prefix_command_help for
	the "kill" command.

gdb/doc/
2009-07-02  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Debugging multiple inferiors): Document the
	"inferior", "detach inferior" and "kill inferior" commands.
	(Debugging Programs with Multiple Processes): Adjust to mention
	generic "inferior" commands.  Delete mention of "detach fork" and
	"delete fork".  Cross reference to "Debugging multiple inferiors"
	section.
@
text
@d4263 14
@


1.143
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d341 6
d596 3
a628 1
	  struct fork_info *fp;
d630 2
d640 10
a649 5
	  /* Retain child fork in ptrace (stopped) state.  */
	  fp = find_fork_pid (child_pid);
	  if (!fp)
	    fp = add_fork (child_pid);
	  fork_save_infrun_state (fp, 0);
d710 1
d752 2
d755 3
a758 9
	}
      else if (!detach_fork)
	{
	  struct fork_info *fp;
	  /* Retain parent fork in ptrace (stopped) state.  */
	  fp = find_fork_pid (parent_pid);
	  if (!fp)
	    fp = add_fork (parent_pid);
	  fork_save_infrun_state (fp, 0);
d760 10
a769 5
	  /* Also add an entry for the child fork.  */
	  fp = find_fork_pid (child_pid);
	  if (!fp)
	    fp = add_fork (child_pid);
	  fork_save_infrun_state (fp, 0);
d771 1
a771 1
      else
d775 3
a778 1
      linux_nat_switch_fork (inferior_ptid);
d1095 4
a1098 4
/* Update our internal state when changing from one fork (checkpoint,
   et cetera) to another indicated by NEW_PTID.  We can only switch
   single-threaded applications, so we only create one new LWP, and
   the previous list is discarded.  */
d1105 2
a1106 1
  init_lwp_list ();
d1110 9
a1118 2
  init_thread_list ();
  add_thread_silent (new_ptid);
d1845 28
d4353 1
a4353 1
int linux_multi_process = 0;
@


1.142
log
@	* target.h (struct target_ops): New member to_thread_architecture.
	(target_thread_architecture): New macro.
	* target.c (update_current_target): Inherit to_thread_architecture.
	(default_thread_architecture): New function.
	(debug_to_thread_architecture): New function.
	(setup_target_debug): Handle to_thread_architecture.

	* regcache.h (get_thread_arch_regcache): New.
	* regcache.c (struct regcache_list): New data type.
	(current_regcache): Hold regcache list instead of single regcache.
	(current_thread_ptid, current_thread_arch): New static variables.
	(get_thread_arch_regcache): New function.
	(get_thread_regcache): Use it.  Call target_thread_architecture.
	(regcache_thread_ptid_changed): Update to current_regcache changes.
	(registers_changed): Likewise.  Reset current_thread_arch and
	current_thread_ptid.

	* remote.c (remote_wait): Access target registers in target_gdbarch.
	* linux-nat.c (linux_nat_do_thread_registers): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* solib-svr4.c (enable_break): Likewise.
	(svr4_relocate_main_executable): Likewise.
@
text
@d3448 2
a3449 2
			    "Save segment, %lld bytes at 0x%s (%c%c%c)",
			    size, paddr_nz (addr),
@


1.141
log
@	* ada-tasks.c (read_known_tasks_array): Use target_gdbarch instead
	of current_gdbarch.
	* aix-thread.c (pd_enable): Likewise.
	* amd64-linux-nat.c (ps_get_thread_area): Likewise.
	* bsd-uthread.c (bsd_uthread_activate): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* linux-thread-db.c (enable_thread_event): Likewise.
	* monitor.c (monitor_write_memory, monitor_read_memory): Likewise.
	* nto-procfs.c (procfs_open): Likewise.
	* procfs.c (invalidate_cache, procfs_insert_watchpoint,
	info_proc_mappings, info_mappings_callback): Likewise.
	* record.c (record_open): Likewise.
	* rs6000-nat.c (ARCH64): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	(darwin_bfd_open): Likewise.
	* memattr.c (mem_info_command): Likewise.

	* windows-nat.c (win32_resume): Use current regcache architecture
	instead of current_gdbarch.

	* dbug-rom.c (dbug_regname): Remove check against number of
	registers in current_gdbarch.
	* solib-pa64.c (read_dynamic_info): Remove unused variable.
@
text
@d3498 2
a3499 2
  struct regcache *regcache = get_thread_regcache (ptid);
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
@


1.140
log
@	* target.h (struct target_ops): Make to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	methods instead of variables.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1)
	(target_has_registers_1, target_has_execution_1): Declare
	functions.
	(target_has_all_memory): Rewrite to call target_has_all_memory_1.
	(target_has_memory): Rewrite to call target_has_memory_1.
	(target_has_stack): Rewrite to call target_has_all_stack_1.
	(target_has_registers): Rewrite to call target_has_registers_1.
	(target_has_execution): Rewrite to call target_has_execution_1.
	(default_child_has_all_memory, default_child_has_memory)
	(default_child_has_stack, default_child_has_registers)
	(default_child_has_execution): Declare.
	(target_mark_running, target_mark_exited): Delete declarations.
	* target.c (default_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution): New.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1,
	target_has_registers_1, target_has_execution_1): New.
	(add_target): Default the to_has_all_memory, to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	callbacks to return 0.
	(update_current_target): Do not inherit to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers or to_has_execution.
	(target_mark_running, target_mark_exited): Delete.
	(memory_xfer_partial): Adjust.
	(target_read_memory, target_write_memory, target_search_memory):
	Dispatch to the the top-most target, not the flattened
	current_target.
	(target_info): Adjust.
	(init_dummy_target): Install return_zero as callback for
	to_has_all_memory, to_has_memory, to_has_stack, to_has_registers,
	to_has_execution.
	(set_maintenance_target_async_permitted): Use have_live_inferiors
	instead of target_has_execution.
	* target-memory.c (target_write_memory_blocks): Dispatch memory
	writes to the the top-most target, not the flattened
	current_target.

	* breakpoint.c (insert_breakpoints): Don't check for
	target_has_execution here.
	(update_global_location_list): Check if there are live inferiors
	to debug instead of target_has_execution.
	* infcmd.c (kill_command, detach_command): Check if there are
	inferiors instead of target_has_execution.
	* inferior.h (have_live_inferiors): Declare.
	* inferior.c (have_live_inferiors): New.
	* infrun.c (normal_stop): Don't check for target_has_execution to
	finish the thread states.
	* thread.c (is_thread_state, is_stopped, is_exited, is_running)
	(any_running, is_executing): Remove checks for
	target_has_execution.
	* top.c (kill_or_detach): Don't try to kill core inferiors.
	(quit_target): Don't check for target_has_execution.

	* corelow.c (core_has_memory, core_has_stack, core_has_registers):
	New.
	(init_core_ops): Install core_has_memory, core_has_stack and
	core_has_registers.
	* exec.c (exec_has_memory): New.
	(init_exec_ops): Install exec_has_memory.
	* remote.c (remote_add_inferior): Don't call target_mark_running.
	(remote_start_remote): Don't call target_mark_exited or call
	target_mark_running.
	(remote_open_1): Use have_inferiors instead of
	target_has_execution.  Don't use target_mark_exited.
	(init_remote_ops): Install deafult_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution.
	* bsd-kvm.c (bsd_kvm_return_one): New.
	(bsd_kvm_add_target): Register bsd_kvm_return_one as
	to_has_memory, to_has_stack and to_has_registers callbacks.
	* remote-m32r-sdi.c (m32r_return_one): New.
	(init_m32r_ops): Register it.
	* inf-child.c (inf_child_target): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.
	* gnu-nat.c (init_gnu_ops): Likewise.
	* go32-nat.c (init_go32_ops): Likewise.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* monitor.c (init_base_monitor_ops): Likewise.
	* nto-procfs.c (init_procfs_ops): Likewise.
	* remote-mips.c (_initialize_remote_mips): Likewise.
	* windows-nat.c (init_windows_ops): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Don't use
	target_mark_running or target_mark_exited.
	(gdbsim_mourn_inferior): Don't call target_mark_exited.
	(init_gdbsim_ops): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.

	* linux-nat.c (linux_nat_xfer_partial): If reading memory, and
	there's no inferior selected, defer to a lower stratum.
@
text
@d3794 1
a3794 1
	  if (gdbarch_addr_bit (current_gdbarch) == 32)
d3820 1
a3820 1
	      if (gdbarch_addr_bit (current_gdbarch) == 32)
@


1.139
log
@gdb/
	* infrun.c (follow_exec): Clear the stop_requested flag.
	* linux-nat.c (linux_handle_extended_wait) <PTRACE_EVENT_EXEC>:
	Add debug output.

gdb/testsuite/
	* gdb.mi/nsthrexec.c, gdb.mi/mi-nsthrexec.exp: New.
@
text
@d3293 6
@


1.138
log
@gdb:
	Global renaming of find_thread_pid to find_thread_ptid.
	* gdbthread.h (find_thread_ptid): Renamed from find_thread_pid.
	* thread.c (find_thread_ptid): Renamed from find_thread_pid.
	All callers updated.
gdbserver:
	Global renaming of find_thread_pid to find_thread_ptid.
	* server.h (find_thread_ptid): Renamed from find_thread_pid.
	* inferiors.c (find_thread_ptid): Renamed from find_thread_pid.
	All callers updated.
@
text
@d1895 5
@


1.137
log
@gdb/
	* gdbthread.h (struct thread_info): New `pending_follow' field.
	* thread.c (new_thread): New function.
	(add_thread_silent): Use it.
	* breakpoint.c (internal_breakpoint_number): New global, moved
	from inside...
	(create_internal_breakpoint): ... this.
	(clone_momentary_breakpoint): New.
	* breakpoint.h (clone_momentary_breakpoint): Declare.
	* infrun.c (nullify_last_target_wait_ptid): Move declaration
	higher.
	(pending_follow): Delete.
	(follow_fork): Handle pending follow fork event here.  Moved the
	preserving of thread stepping state here.
	(resume): Don't handle pending follow fork events here.  Only
	install the inferior's terminal modes if we're about to resume it.
	(proceed): Handle possible pending follow fork events here.
	(init_wait_for_inferior): No need to clear pending_follow anymore,
	it's gone.
	(handle_inferior_event): Adjust to per-thread `pending_follow'.
	Call `follow_fork' to handle following the fork.  If the
	follow-fork is cancelled, stop stepping.
	* linux-nat.c (linux_child_follow_fork): Adjust to per-thread
	`pending_follow' events.  Remove code that handled preserving the
	thread stepping state.
	* inf-ptrace.c (inf_ptrace_follow_fork): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork): Ditto.

gdb/testsuite/
	* gdb.threads/fork-thread-pending.c: New.
	* gdb.threads/fork-thread-pending.exp: New.
@
text
@d1099 1
a1099 1
  struct thread_info *th = find_thread_pid (lp->ptid);
d1429 1
a1429 1
	  struct thread_info *tp = find_thread_pid (lp->ptid);
d1458 1
a1458 1
	  struct thread_info *tp = find_thread_pid (lp->ptid);
d4518 1
a4518 1
	  if (find_thread_pid (lwp->ptid)->stop_requested)
@


1.136
log
@	* linux-nat.c (linux_nat_terminal_inferior)
	(linux_nat_terminal_ours): Don't check sync_execution.
	* remote.c (remote_terminal_inferior, remote_terminal_ours):
	Don't check sync_execution.  Update comments.
	* target.c (target_terminal_inferior): New.
	* target.h (target_terminal_inferior): Delete macro, and declare
	as function.
	* event-top.c (async_disable_stdin): Make idempotent.  Don't give
	the target the terminal here.
	* inflow.c (terminal_ours_1): Don't return early without setting
	`terminal_is_ours'.
@
text
@a577 2
  ptid_t last_ptid;
  struct target_waitstatus last_status;
d583 3
a585 3
  get_last_target_status (&last_ptid, &last_status);
  has_vforked = (last_status.kind == TARGET_WAITKIND_VFORKED);
  parent_pid = ptid_get_lwp (last_ptid);
d587 2
a588 2
    parent_pid = ptid_get_pid (last_ptid);
  child_pid = PIDGET (last_status.value.related_pid);
d626 1
a626 1
	  parent_inf = find_inferior_pid (GET_PID (last_ptid));
a692 1
      struct thread_info *last_tp = find_thread_pid (last_ptid);
a693 1
      char child_pid_spelling[40];
a695 10
      /* Copy user stepping state to the new inferior thread.  */
      struct breakpoint *step_resume_breakpoint = last_tp->step_resume_breakpoint;
      CORE_ADDR step_range_start = last_tp->step_range_start;
      CORE_ADDR step_range_end = last_tp->step_range_end;
      struct frame_id step_frame_id = last_tp->step_frame_id;

      /* Otherwise, deleting the parent would get rid of this
	 breakpoint.  */
      last_tp->step_resume_breakpoint = NULL;

d712 1
a712 1
      parent_inf = find_inferior_pid (GET_PID (last_ptid));
a760 9

      tp = inferior_thread ();
      tp->step_resume_breakpoint = step_resume_breakpoint;
      tp->step_range_start = step_range_start;
      tp->step_range_end = step_range_end;
      tp->step_frame_id = step_frame_id;

      /* Reset breakpoints in the child as appropriate.  */
      follow_inferior_reset_breakpoints ();
@


1.135
log
@	* target.h (TARGET_WNOHANG): New.
	* target.c (target_wait): Add `options' argument.  Adjust.
	(struct target_ops) <to_wait>: Add `options' argument.
	(target_wait): Add `options' argument.
	* infrun.c (wait_for_inferior): Pass 0 as options to
	target_wait (blocking wait).
	(fetch_inferior_event): Pass TARGET_WNOHANG as options to
	target_wait.
	* fork-child.c (startup_inferior): Pass 0 as options to
	target_wait (blocking wait).
	* linux-nat.c (linux_nat_create_inferior): Remove async masking.
	(linux_nat_wait_1): Add `target_options' argument.  Use it instead
	of checking on target_can_async_p.
	(linux_nat_wait): Add `target_options' argument.  Adjust.
	* remote.c (remote_wait_ns): Add `options' argument.  Adjust to
	check on TARGET_WNOWAIT instead of checking on remote_is_async_p.
	(remote_wait_as): Add `options' argument.  Adjust to check on
	TARGET_WNOWAIT instead of checking on remote_is_async_p.  If doing
	a blocking wait, keep waiting until an interesting event comes
	out.
	(remote_wait): Add `options' argument.  Don't loop here if the
	target is in async mode, and a blocking wait has been requested.

	* top.c (deprecated_target_wait_hook): Add `options' argument.
	* linux-thread-db.c (thread_db_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ptrace.c (inf_ptrace_wait): Add `options' argument.
	* record.c (record_beneath_to_wait): Add `options' argument.
	(record_wait): Add `options' argument, and pass it down to the
	layer beneath.
	* bsd-uthread.c (bsd_uthread_wait): Add `options' argument.
	* darwin-nat.c (darwin_wait): Likewise.
	* defs.h (deprecated_target_wait_hook): Likewise.
	* gnu-nat.c (gnu_wait): Add `options' argument.
	* go32-nat.c (go32_wait): Likewise.
	* hpux-thread.c (hpux_thread_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ttrace.c (inf_ttrace_wait): Add `options' argument.
	* monitor.c (monitor_wait): Likewise.
	* nto-procfs.c (procfs_wait): Likewise.
	* remote-mips.c (mips_wait): Add `options' argument.
	* remote-sim.c (gdbsim_wait): Likewise.
	* rs6000-nat.c (rs6000_wait): Add `options' argument.
	* sol-thread.c (sol_thread_wait): Add `options' argument, and pass
	it down to the layer beneath.
	* spu-linux-nat.c (spu_child_wait): Add `options' argument.
	* windows-nat.c (windows_wait): Likewise.
	* tui/tui-hooks.c (tui_target_wait_hook): Likewise.  Adjust.
@
text
@a4362 6
  /* GDB should never give the terminal to the inferior, if the
     inferior is running in the background (run&, continue&, etc.).
     This check can be removed when the common code is fixed.  */
  if (!sync_execution)
    return;

d4365 1
a4390 3
  if (!sync_execution)
    return;

@


1.134
log
@	* fork-child.c: Don't include frame.h.  Include terminal.h.
	(fork_inferior): Call new_tty_postfork after forking adn adding
	the child to the inferior list.
	* inferior.h (new_tty_prefork, gdb_has_a_terminal): Don't declare
	here.
	* inflow.c (struct terminal_info): Remove const qualifier from
	`run_terminal' field.
	(inferior_thisrun_terminal): Tweak comment.
	(inflow_inferior_exit): Release the `run_terminal' field.
	(copy_terminal_info): New function.
	(new_tty_postfork): New function.
	* terminal.h (new_tty_prefork, new_tty, new_tty_postfork,
	(copy_terminal_info, gdb_has_a_terminal, gdb_setpgid): Declare.
	* inf-ptrace.c: Include terminal.h.
	(inf_ptrace_follow_fork): Copy the parent's terminal info to the
	child.
	* linux-nat.c: Include terminal.h.
	(linux_child_follow_fork): Copy the parent's terminal info to the
	child.
	* inf-ttrace.c: Include terminal.h.
	(inf_ttrace_follow_fork): Copy the parent's terminal info to the
	child.
@
text
@a1343 1
  int saved_async = 0;
a1350 5
  if (target_can_async_p ())
    /* Mask async mode.  Creating a child requires a loop calling
       wait_for_inferior currently.  */
    saved_async = linux_nat_async_mask (0);

a1379 3

  if (saved_async)
    linux_nat_async_mask (saved_async);
d2681 2
a2682 1
		  ptid_t ptid, struct target_waitstatus *ourstatus)
d2817 3
a2819 2
  if (target_can_async_p ())
    options |= WNOHANG; /* In async mode, don't block.  */
d2924 1
a2924 1
	      if (target_can_async_p ())
d3068 2
a3069 1
		ptid_t ptid, struct target_waitstatus *ourstatus)
d3080 1
a3080 1
  event_ptid = linux_nat_wait_1 (ops, ptid, ourstatus);
@


1.133
log
@	* linux-nat.h (linux_proc_get_tgid): Declare.
	* linux-nat.c (linux_proc_get_tgid): New.
	* linux-thread-db.c (struct thread_db_info): New field
	`need_stale_parent_threads_check'.
	(add_thread_db_info): Set it.
	(find_new_threads_callback): Ignore stale fork parent threads.
	(thread_db_resume): New.
	(init_thread_db_ops): Install thread_db_resume.
@
text
@d56 1
d630 1
d728 1
@


1.132
log
@	* fork-child.c (fork_inferior): Only reset the thread list if this
	is the first inferior.
	(startup_inferior): If the target support multi-process, tell it
	to resume only the new process.
	* linux-nat.c (num_lwps): Delete global.
	(purge_lwp_list): New function.
	(num_lwps): New function.
	(add_lwp, delete_lwp): Adjust.
	(ptid_match): New.
	(iterate_over_lwps): Add filter argument.  Handle it.
	(linux_nat_attach): Remove FIXME note.
	(linux_nat_detach): Adjust to iterate over threads of the inferior
	we're detaching from.  Adjust to num_lwps being a function.  Don't
	assume the head of the lwp list is the main thread of the process
	we're detaching from.  Don't destroy the LWP list.
	(resume_callback): Add debug output.
	(linux_nat_resume): Handle resuming a single inferior.  Allow a
	wildcard resume in non-stop mode.
	(linux_handle_extended_wait): Don't assume inferior_ptid is the
	correct inferior of the parent LWP.
	(status_callback): Also check lp->waitstatus.
	(select_event_lwp): Add new filter parameter.  Handle it.
	(linux_nat_filter_event): Adjust to num_lwps being a function.
	(linux_nat_wait_1): When adding the first lwp of the inferior, use
	an is_lwp check instead of checking for the number of lwps.
	(linux_nat_wait_1): Handle waiting for a specific tgid.  Handle
	pending process exit statuses.
	(linux_nat_mourn_inferior): Don't destroy all the LWP info.
	Instead delete LWPs of the inferior that we're mourning.  Don't
	unregister from the event loop here.
	(linux_nat_pid_to_str): Use `num_lwps'.
	(linux_nat_make_corefile_notes): Adjust to walk over lwps of a
	single inferior.
	(linux_nat_is_async_p): Check if async was masked out.
	(linux_multi_process): New global.
	(linux_nat_supports_multi_process): New.
	(linux_nat_stop_lwp): Remove LWP filtering.  It is done by the
	caller.
	(linux_nat_stop): Adjust to make iterate_over_lwps itself do the
	LWP filtering.
	(linux_nat_close): New.
	(linux_nat_add_target): Register linux_nat_close and
	linux_nat_supports_multi_process.
	* linux-nat.h (iterate_over_lwps): Add filter argument.
	* linux-thread-db.c (thread_db_handle): Delete.
	(proc_handle, thread_agent, td_init_p, td_ta_new_p)
	(td_ta_map_id2thr_p, td_ta_map_lwp2thr_p, td_ta_thr_iter_p)
	(td_ta_event_addr_p, td_ta_set_event_p, td_ta_event_getmsg_p)
	(td_thr_validate_p, td_thr_get_info_p, td_thr_event_enable_p)
	(td_thr_tls_get_addr_p, td_create_bp_addr, td_death_bp_addr): No
	longer globals, moved to...
	(struct thread_db_info): ... this new structure.
	(thread_db_list): New.
	(add_thread_db_info, get_thread_db_info, delete_thread_db_info):
	New.
	(have_threads_callback): Filter out threads of all inferiors but
	the one specified by the ARGS argument.
	(have_threads): Add ptid argument specifying the inferior we're
	interested in.  Handle it.
	(struct thread_get_info_inout): New.
	(thread_get_info_callback, thread_from_lwp): Adjust to use it.
	(thread_db_attach_lwp): Check that inferior of the passed in
	thread is using thread-db.  Adjust.
	(enable_thread_event): Remove thread_agent parameter.  Instead,
	get it from the per-inferior thread-db info.
	(dladdr_to_soname): Move higher up.
	(enable_thread_event_reporting): Adjust to use per-inferior
	thread-db info.
	(try_thread_db_load_1): Replace `handle' parameter by a
	thread_db_info parameter.  Adjust to use per-inferior thread-db
	info.
	(try_thread_db_load): Adjust to use per-inferior thread-db info.
	(thread_db_load, disable_thread_event_reporting): Ditto.
	(check_for_thread_db): Remove conditional reporting of which
	libthread_db is in use.
	(thread_db_new_objfile): Add comment about inferior_ptid.
	(attach_thread): Adjust to use per-inferior thread-db info.
	(thread_db_detach): Adjust to use per-inferior thread-db info.
	Remove thread event breakpoints of the current inferior.  Only
	unpush the thread-db target if there are no more processes using
	it.
	(check_event): Adjust to use per-inferior thread-db info.
	(thread_db_wait): Adjust to use per-inferior thread-db info.  Only
	unpush the thread-db target if there are no more processes using
	it.
	(thread_db_mourn_inferior): Adjust to use per-inferior thread-db
	info.  Mark breakpoints of the current inferior out before
	deleting them.  Only unpush the thread-db target if there are no
	more processes using it.
	(find_new_threads_callback): Adjust to use per-inferior thread_db
	info.
	(thread_db_find_new_threads_1): Add new ptid argument.  Adjust to
	use per-inferior thread-db info.
	(thread_db_find_new_threads): Adjust to use per-inferior thread-db
	info.
	(thread_db_get_thread_local_address): Adjust.
	(thread_db_get_ada_task_ptid): Adjust.
	* inf-ptrace.c (inf_ptrace_mourn_inferior): Only unpush the target
	if there no more processes left to debug.
	* thread.c (set_running, set_executing): Handle resuming all
	threads of a single inferior.
	* mi/mi-interp.c (mi_output_running_pid): New.
	(mi_inferior_count): New.
	(mi_on_resume): For backwards compatibility, if resuming all
	threads of an inferior, and there is only one inferior, output
	"all".
@
text
@d1132 28
@


1.131
log
@gdb/
2009-05-17  Pedro Alves  <pedro@@codesourcery.com>

	* infrun.c (handle_inferior_event): When handling a
	TARGET_WAITKIND_FORKED, detach breakpoints from the fork child
	immediatelly.
	* linux-nat.c (linux_child_follow_fork): Only detach breakpoint
	from the child if vforking.
	* inf-ptrace.c (inf_ptrace_follow_fork): No need to detach
	breakpoints from the child here.

gdb/testsuite/
2009-05-17  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.base/foll-fork.c: Include stdlib.h.  Add markers for
	`gdb_get_line_number'.  Call `callee' in both parent and child.
	* gdb.base/foll-fork.exp (catch_fork_child_follow): Use
	`gdb_get_line_number' instead of hardcoding line numbers.
	(catch_fork_unpatch_child): New procedure to test detaching
	breakpoints from child fork.
	(tcatch_fork_parent_follow): Use `gdb_get_line_number' instead of
	hardcoding line numbers.
	(do_fork_tests): Run `catch_fork_unpatch_child'.
@
text
@a843 3

/* Number of LWPs in the list.  */
static int num_lwps;
d926 42
a967 1
  num_lwps = 0;
a990 1
  ++num_lwps;
d992 1
a992 1
  if (num_lwps > 1 && linux_nat_new_thread != NULL)
a1013 2
  num_lwps--;

d1043 27
d1076 3
a1078 1
iterate_over_lwps (int (*callback) (struct lwp_info *, void *), void *data)
d1085 6
a1090 2
      if ((*callback) (lp, data))
	return lp;
a1366 2
  /* FIXME: We should probably accept a list of process id's, and
     attach all of them.  */
d1526 3
d1535 1
a1535 1
  iterate_over_lwps (stop_callback, NULL);
d1538 1
a1538 1
  iterate_over_lwps (stop_wait_callback, NULL);
d1540 1
a1540 1
  iterate_over_lwps (detach_callback, NULL);
d1543 3
a1545 1
  gdb_assert (num_lwps == 1);
d1549 1
a1549 1
      && get_pending_status (lwp_list, &status) != -1
d1559 1
a1559 1
			  target_pid_to_str (lwp_list->ptid));
d1562 1
a1562 4
  /* Destroy LWP info; it's no longer valid.  */
  init_lwp_list ();

  pid = ptid_get_pid (inferior_ptid);
d1586 5
d1632 1
a1632 1
  int resume_all;
d1645 2
a1646 5
  resume_all = (PIDGET (ptid) == -1);

  if (non_stop && resume_all)
    internal_error (__FILE__, __LINE__,
		    "can't resume all in non-stop mode");
d1650 3
a1652 4
      if (resume_all)
	iterate_over_lwps (resume_set_callback, NULL);
      else
	iterate_over_lwps (resume_clear_callback, NULL);
d1654 2
d1657 6
a1662 6
  /* If PID is -1, it's the current inferior that should be
     handled specially.  */
  if (PIDGET (ptid) == -1)
    ptid = inferior_ptid;

  lp = find_lwp_pid (ptid);
a1664 3
  /* Convert to something the lower layer understands.  */
  ptid = pid_to_ptid (GET_LWP (lp->ptid));

a1667 3
  /* Mark this LWP as resumed.  */
  lp->resumed = 1;

d1681 1
a1681 1
      inf = find_inferior_pid (ptid_get_pid (ptid));
d1730 5
a1734 2
  if (resume_all)
    iterate_over_lwps (resume_callback, NULL);
d1828 1
a1828 1
	  new_lp = add_lwp (BUILD_LWP (new_pid, GET_PID (inferior_ptid)));
d2252 6
a2257 1
  return (lp->status != 0 && lp->resumed);
d2379 1
a2379 1
select_event_lwp (struct lwp_info **orig_lp, int *status)
d2389 2
a2390 1
  event_lp = iterate_over_lwps (select_singlestep_lwp_callback, NULL);
d2404 1
a2404 1
      iterate_over_lwps (count_events_callback, &num_events);
d2415 2
a2416 1
      event_lp = iterate_over_lwps (select_event_lwp_callback,
d2534 2
a2535 1
  if ((WIFEXITED (status) || WIFSIGNALED (status)) && num_lwps > 1)
d2550 2
a2551 1
	  iterate_over_lwps (stop_and_resume_callback, NULL);
d2559 1
a2559 1
      if (num_lwps > 1)
d2573 1
a2573 1
  if (num_lwps > 1 && !linux_thread_alive (lp->ptid))
d2575 2
d2585 1
a2585 1
      gdb_assert (iterate_over_lwps (running_callback, NULL));
d2665 1
a2665 1
  pid_t pid = PIDGET (ptid);
d2673 1
a2673 1
  if (num_lwps == 0)
a2674 2
      gdb_assert (!is_lwp (inferior_ptid));

d2687 11
d2699 2
d2703 1
a2703 1
  gdb_assert (iterate_over_lwps (resumed_callback, NULL));
d2709 1
a2709 1
      lp = iterate_over_lwps (status_callback, NULL);
d2751 7
d2760 1
a2760 1
  if (status && lp->signalled)
d2797 1
a2797 1
  while (status == 0)
d2815 4
a2818 1
	  if (!lp)
d2820 54
a2873 2
	      /* A discarded event.  */
	      status = 0;
d2877 11
a2887 1
	  break;
d2917 1
a2917 1
      gdb_assert (status == 0);
a2965 1
	  status = 0;
d2981 2
a2982 1
	      iterate_over_lwps (set_ignore_sigint, NULL);
d3000 1
a3000 1
      iterate_over_lwps (stop_callback, NULL);
d3004 1
a3004 1
      iterate_over_lwps (stop_wait_callback, NULL);
d3011 1
a3011 1
	select_event_lwp (&lp, &status);
d3017 1
a3017 1
  iterate_over_lwps (cancel_breakpoints_callback, lp);
d3165 1
d3168 1
a3168 1
      iterate_over_lwps (stop_callback, NULL);
d3171 1
a3171 1
      iterate_over_lwps (stop_wait_callback, NULL);
d3174 1
a3174 1
      iterate_over_lwps (kill_callback, NULL);
d3177 1
a3177 1
      iterate_over_lwps (kill_wait_callback, NULL);
d3186 1
a3186 2
  /* Destroy LWP info; it's no longer valid.  */
  init_lwp_list ();
d3189 2
a3190 7
    {
      /* Normal case, no other forks available.  */
      linux_ops->to_mourn_inferior (ops);

      if (target_can_async_p ())
	linux_nat_async (NULL, 0);
    }
d3334 2
a3335 2
      && ((lwp_list && lwp_list->next)
	  || GET_PID (ptid) != GET_LWP (ptid)))
d3610 1
d3644 1
a3644 1
  iterate_over_lwps (linux_nat_corefile_thread_callback, &thread_args);
d4257 2
a4258 1
  return 1;
d4282 11
d4490 9
a4498 1
  ptid_t ptid = * (ptid_t *) data;
a4499 9
  if (ptid_equal (lwp->ptid, ptid)
      || ptid_equal (minus_one_ptid, ptid)
      || (ptid_is_pid (ptid)
	  && ptid_get_pid (ptid) == ptid_get_pid (lwp->ptid)))
    {
      if (!lwp->stopped)
	{
	  int pid, status;
	  ptid_t ptid = lwp->ptid;
d4501 2
a4502 4
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"LNSL: running -> suspending %s\n",
				target_pid_to_str (lwp->ptid));
d4504 5
d4510 11
a4520 2
	  stop_callback (lwp, NULL);
	  stop_wait_callback (lwp, NULL);
d4522 1
a4522 15
	  /* If the lwp exits while we try to stop it, there's nothing
	     else to do.  */
	  lwp = find_lwp_pid (ptid);
	  if (lwp == NULL)
	    return 0;

	  /* If we didn't collect any signal other than SIGSTOP while
	     stopping the LWP, push a SIGNAL_0 event.  In either case,
	     the event-loop will end up calling target_wait which will
	     collect these.  */
	  if (lwp->status == 0)
	    lwp->status = W_STOPCODE (0);
	  async_file_mark ();
	}
      else
d4524 2
a4525 6
	  /* Already known to be stopped; do nothing.  */

	  if (debug_linux_nat)
	    {
	      if (find_thread_pid (lwp->ptid)->stop_requested)
		fprintf_unfiltered (gdb_stdlog, "\
d4527 3
a4529 3
				    target_pid_to_str (lwp->ptid));
	      else
		fprintf_unfiltered (gdb_stdlog, "\
d4531 1
a4531 2
				    target_pid_to_str (lwp->ptid));
	    }
d4541 1
a4541 1
    iterate_over_lwps (linux_nat_stop_lwp, &ptid);
d4546 14
d4590 1
d4595 2
@


1.130
log
@	* linux-nat.c (enum sigchld_state): Delete.
	(linux_nat_async_events_state): Delete.
	(struct waitpid_result): Delete.
	(waitpid_queue): Delete.
	(queued_waitpid_1): Delete.
	(async_file_flush): New.
	(queued_waitpid, push_waitpid): Delete.
	(async_file_mark): New.
	(drain_queued_events): Delete.
	(my_waitpid): Remove locally queued events handling.
	(linux_test_for_tracefork): Upjust.
	(linux_child_follow_fork): Ditto.
	(sync_sigchld_action): Delete.
	(blocked_mask): Reinstate.
	(async_sigchld_action): Rename to...
	(sigchld_action): ... this.
	(block_child_signals): New.
	(restore_child_signals_mask): New.
	(lin_lwp_attach_lwp): Adjust.
	(linux_nat_create_inferior): Ditto.
	(linux_nat_attach): Also use lp->status in async mode.
	(get_pending_status): Don't use queued_waitpid.
	(linux_nat_detach): Don't drain locally queued events.
	(linux_nat_resume): Allow pending wait statuses stored lp->status
	in async mode.  If returning early due to a pending event,
	re-register the event source.
	(stop_wait_callback): Allow pending wait statuses stored
	lp->status in async mode.
	(pipe_to_local_event_queue, local_event_queue_to_pipe): Delete.
	(linux_nat_wait): Rename to ...
	(linux_nat_wait_1): ... this.  Allow pending wait statuses stored
	lp->status in async mode.  Always add WNOHANG to the waitpid
	options in async mode.
	(linux_nat_wait): New.
	(kill_callback): Don't drain locally queued events.
	(sigchld_handler): Rewrite.
	(linux_nat_is_async_p, linux_nat_can_async_p): Fix comments to
	refer to "set target-async".
	(linux_nat_async_mask): If in non-stop, and re-enabling async
	mode, re-register the target event source in the event loop.
	(linux_nat_event_pipe_pop, linux_nat_event_pipe_push)
	(get_pending_events, async_sigchld_handler)
	(linux_nat_async_events): Delete.
	(handle_target_event): New.
	(linux_nat_async_file_handler): Delete.
	(linux_async_pipe): New.
	(linux_nat_async): Only re-register in the event loop if not
	registered yet.  Always notify the event-loop once if enabling the
	event source.
	(linux_nat_stop_lwp): Rewrite to handle pending events stored in
	lp->status, not in the locally queued event list.
	(linux_nat_stop): Don't mask out async event handling.
	(linux_nat_setup_async): Delete.
	(_initialize_linux_nat): Adjust.
	(lin_thread_get_thread_signals): blocked_mask is global again.
	Adjust.
@
text
@d596 9
a604 5
         it.  (This won't actually modify the breakpoint list, but will
         physically remove the breakpoints from the child.) */
      /* If we vforked this will remove the breakpoints from the parent
	 also, but they'll be reinserted below.  */
      detach_breakpoints (child_pid);
a707 4
      /* Needed to keep the breakpoint lists in sync.  */
      if (! has_vforked)
	detach_breakpoints (child_pid);

@


1.129
log
@	* linux-nat.c (linux_xfer_siginfo): Delete unused locals lp, n.
@
text
@d92 34
a125 42
In async mode, GDB should always be ready to handle both user input and target
events, so neither blocking waitpid nor sigsuspend are viable
options. Instead, we should notify the GDB main event loop whenever there's
unprocessed event from the target.  The only way to notify this event loop is
to make it wait on input from a pipe, and write something to the pipe whenever
there's event. Obviously, if we fail to notify the event loop if there's
target event, it's bad.  If we notify the event loop when there's no event
from target, linux-nat.c will detect that there's no event, actually, and
report event of type TARGET_WAITKIND_IGNORE, but it will waste time and
better avoided.

The main design point is that every time GDB is outside linux-nat.c, we have a
SIGCHLD handler installed that is called when something happens to the target
and notifies the GDB event loop. Also, the event is extracted from the target
using waitpid and stored for future use.  Whenever GDB core decides to handle
the event, and calls into linux-nat.c, we disable SIGCHLD and process things
as in sync mode, except that before waitpid call we check if there are any
previously read events.

It could happen that during event processing, we'll try to get more events
than there are events in the local queue, which will result to waitpid call.
Those waitpid calls, while blocking, are guarantied to always have
something for waitpid to return.  E.g., stopping a thread with SIGSTOP, and
waiting for the lwp to stop.

The event loop is notified about new events using a pipe. SIGCHLD handler does
waitpid and writes the results in to a pipe. GDB event loop has the other end
of the pipe among the sources. When event loop starts to process the event
and calls a function in linux-nat.c, all events from the pipe are transferred
into a local queue and SIGCHLD is blocked. Further processing goes as in sync
mode. Before we return from linux_nat_wait, we transfer all unprocessed events
from local queue back to the pipe, so that when we get back to event loop,
event loop will notice there's something more to do.

SIGCHLD is blocked when we're inside target_wait, so that should we actually
want to wait for some more events, SIGCHLD handler does not steal them from
us. Technically, it would be possible to add new events to the local queue but
it's about the same amount of work as blocking SIGCHLD.

This moving of events from pipe into local queue and back into pipe when we
enter/leave linux-nat.c is somewhat ugly. Unfortunately, GDB event loop is
home-grown and incapable to wait on any queue.
d291 1
a291 2
/* Number of queued events in the pipe.  */
static volatile int linux_nat_num_queued_events;
d293 2
a294 3
/* The possible SIGCHLD handling states.  */

enum sigchld_state
d296 2
a297 9
  /* SIGCHLD disabled, with action set to sigchld_handler, for the
     sigsuspend in linux_nat_wait.  */
  sigchld_sync,
  /* SIGCHLD enabled, with action set to async_sigchld_handler.  */
  sigchld_async,
  /* Set SIGCHLD to default action.  Used while creating an
     inferior.  */
  sigchld_default
};
d299 1
a299 54
/* The current SIGCHLD handling state.  */
static enum sigchld_state linux_nat_async_events_state;

static enum sigchld_state linux_nat_async_events (enum sigchld_state enable);
static void pipe_to_local_event_queue (void);
static void local_event_queue_to_pipe (void);
static void linux_nat_event_pipe_push (int pid, int status, int options);
static int linux_nat_event_pipe_pop (int* ptr_status, int* ptr_options);
static void linux_nat_set_async_mode (int on);
static void linux_nat_async (void (*callback)
			     (enum inferior_event_type event_type, void *context),
			     void *context);
static int linux_nat_async_mask (int mask);
static int kill_lwp (int lwpid, int signo);

static int stop_callback (struct lwp_info *lp, void *data);

/* Captures the result of a successful waitpid call, along with the
   options used in that call.  */
struct waitpid_result
{
  int pid;
  int status;
  int options;
  struct waitpid_result *next;
};

/* A singly-linked list of the results of the waitpid calls performed
   in the async SIGCHLD handler.  */
static struct waitpid_result *waitpid_queue = NULL;

/* Similarly to `waitpid', but check the local event queue instead of
   querying the kernel queue.  If PEEK, don't remove the event found
   from the queue.  */

static int
queued_waitpid_1 (int pid, int *status, int flags, int peek)
{
  struct waitpid_result *msg = waitpid_queue, *prev = NULL;

  if (debug_linux_nat_async)
    fprintf_unfiltered (gdb_stdlog,
			"\
QWPID: linux_nat_async_events_state(%d), linux_nat_num_queued_events(%d)\n",
			linux_nat_async_events_state,
			linux_nat_num_queued_events);

  if (flags & __WALL)
    {
      for (; msg; prev = msg, msg = msg->next)
	if (pid == -1 || pid == msg->pid)
	  break;
    }
  else if (flags & __WCLONE)
d301 1
a301 11
      for (; msg; prev = msg, msg = msg->next)
	if (msg->options & __WCLONE
	    && (pid == -1 || pid == msg->pid))
	  break;
    }
  else
    {
      for (; msg; prev = msg, msg = msg->next)
	if ((msg->options & __WCLONE) == 0
	    && (pid == -1 || pid == msg->pid))
	  break;
d303 1
a303 33

  if (msg)
    {
      int pid;

      if (status)
	*status = msg->status;
      pid = msg->pid;

      if (debug_linux_nat_async)
	fprintf_unfiltered (gdb_stdlog, "QWPID: pid(%d), status(%x)\n",
			    pid, msg->status);

      if (!peek)
	{
	  if (prev)
	    prev->next = msg->next;
	  else
	    waitpid_queue = msg->next;

	  msg->next = NULL;
	  xfree (msg);
	}

      return pid;
    }

  if (debug_linux_nat_async)
    fprintf_unfiltered (gdb_stdlog, "QWPID: miss\n");

  if (status)
    *status = 0;
  return -1;
d306 3
a308 7
/* Similarly to `waitpid', but check the local event queue.  */

static int
queued_waitpid (int pid, int *status, int flags)
{
  return queued_waitpid_1 (pid, status, flags, 0);
}
d311 1
a311 1
push_waitpid (int pid, int status, int options)
d313 1
a313 1
  struct waitpid_result *event, *new_event;
d315 4
a318 5
  new_event = xmalloc (sizeof (*new_event));
  new_event->pid = pid;
  new_event->status = status;
  new_event->options = options;
  new_event->next = NULL;
d320 1
a320 1
  if (waitpid_queue)
d322 3
a324 4
      for (event = waitpid_queue;
	   event && event->next;
	   event = event->next)
	;
d326 2
a327 4
      event->next = new_event;
    }
  else
    waitpid_queue = new_event;
d330 7
a336 8
/* Drain all queued events of PID.  If PID is -1, the effect is of
   draining all events.  */
static void
drain_queued_events (int pid)
{
  while (queued_waitpid (pid, NULL, __WALL) != -1)
    ;
}
d338 2
d390 1
a390 2
/* Wrapper function for waitpid which handles EINTR, and checks for
   locally queued events.  */
a396 7
  /* There should be no concurrent calls to waitpid.  */
  gdb_assert (linux_nat_async_events_state == sigchld_sync);

  ret = queued_waitpid (pid, status, flags);
  if (ret != -1)
    return ret;

d424 1
a424 1
  enum sigchld_state async_events_original_state;
d426 2
a427 1
  async_events_original_state = linux_nat_async_events (sigchld_sync);
d434 4
a437 1
    return;
d461 1
a461 1
	  linux_nat_async_events (async_events_original_state);
d472 1
a472 1
      linux_nat_async_events (async_events_original_state);
d513 1
a513 1
  linux_nat_async_events (async_events_original_state);
d576 1
d582 1
a582 2
  if (target_can_async_p ())
    target_async (NULL, 0);
d783 1
a783 3
  if (target_can_async_p ())
    target_async (inferior_event_handler, 0);

d856 5
a860 2
/* SIGCHLD action for synchronous mode.  */
struct sigaction sync_sigchld_action;
d862 2
a863 2
/* SIGCHLD action for asynchronous mode.  */
static struct sigaction async_sigchld_action;
d865 18
a882 2
/* SIGCHLD default action, to pass to new inferiors.  */
static struct sigaction sigchld_default_action;
d1166 1
a1166 1
  enum sigchld_state async_events_original_state;
d1170 1
a1170 1
  async_events_original_state = linux_nat_async_events (sigchld_sync);
d1193 1
d1236 1
a1236 1
  linux_nat_async_events (async_events_original_state);
a1256 14
  else
    {
      /* Restore the original signal mask.  */
      sigprocmask (SIG_SETMASK, &normal_mask, NULL);
      /* Make sure we don't block SIGCHLD during a sigsuspend.  */
      suspend_mask = normal_mask;
      sigdelset (&suspend_mask, SIGCHLD);
    }

  /* Set SIGCHLD to the default action, until after execing the child,
     since the inferior inherits the superior's signal mask.  It will
     be blocked again in linux_nat_wait, which is only reached after
     the inferior execing.  */
  linux_nat_async_events (sigchld_default);
a1302 9
  if (!target_can_async_p ())
    {
      /* Restore the original signal mask.  */
      sigprocmask (SIG_SETMASK, &normal_mask, NULL);
      /* Make sure we don't block SIGCHLD during a sigsuspend.  */
      suspend_mask = normal_mask;
      sigdelset (&suspend_mask, SIGCHLD);
    }

d1322 4
a1325 12
  if (!target_can_async_p ())
    lp->status = status;
  else
    {
      /* We already waited for this LWP, so put the wait result on the
	 pipe.  The event loop will wake up and gets us to handling
	 this event.  */
      linux_nat_event_pipe_push (GET_PID (lp->ptid), status,
				 lp->cloned ? __WCLONE : 0);
      /* Register in the event loop.  */
      target_async (inferior_event_handler, 0);
    }
d1338 3
a1340 4
     signal will be in stop_signal.  Otherwise, in all-stop + sync
     mode, we may cache pending events in lp->status while trying to
     stop all threads (see stop_wait_callback).  In async mode, the
     events are always cached in waitpid_queue.  */
d1356 1
a1356 8
	  if (queued_waitpid (GET_LWP (lp->ptid), status, __WALL) != -1)
	    {
	      if (WIFSTOPPED (*status))
		signo = target_signal_from_host (WSTOPSIG (*status));

	      /* If not stopped, then the lwp is gone, no use in
		 resending a signal.  */
	    }
a1397 2
      else if (target_can_async_p ())
	queued_waitpid (GET_LWP (lp->ptid), status, __WALL);
d1446 1
a1446 1
			    strsignal (WSTOPSIG (lp->status)));
a1495 3
  if (target_can_async_p ())
    drain_queued_events (pid);

d1557 1
d1569 1
a1569 3
  if (target_can_async_p ())
    /* Block events while we're here.  */
    linux_nat_async_events (sigchld_sync);
a1610 4
  /* In async mode, we never have pending wait status.  */
  if (target_can_async_p () && lp->status)
    internal_error (__FILE__, __LINE__, "Pending status in async mode");

d1651 7
d1678 1
d2104 4
a2107 1
	      if (target_can_async_p ())
d2109 6
a2114 31
		  /* Don't leave a pending wait status in async mode.
		     Retrigger the breakpoint.  */
		  if (!cancel_breakpoint (lp))
		    {
		      /* There was no gdb breakpoint set at pc.  Put
			 the event back in the queue.  */
		      if (debug_linux_nat)
			fprintf_unfiltered (gdb_stdlog, "\
SWC: leaving SIGTRAP in local queue of %s\n", target_pid_to_str (lp->ptid));
		      push_waitpid (GET_LWP (lp->ptid),
				    W_STOPCODE (SIGTRAP),
				    lp->cloned ? __WCLONE : 0);
		    }
		}
	      else
		{
		  /* Hold the SIGTRAP for handling by
		     linux_nat_wait. */
		  /* If there's another event, throw it back into the
		     queue. */
		  if (lp->status)
		    {
		      if (debug_linux_nat)
			fprintf_unfiltered (gdb_stdlog,
					    "SWC: kill %s, %s\n",
					    target_pid_to_str (lp->ptid),
					    status_to_str ((int) status));
		      kill_lwp (GET_LWP (lp->ptid), WSTOPSIG (lp->status));
		    }
		  /* Save the sigtrap event. */
		  lp->status = status;
d2116 3
d2149 1
a2149 1
	      if (lp->status || target_can_async_p ())
a2577 46
/* Get the events stored in the pipe into the local queue, so they are
   accessible to queued_waitpid.  We need to do this, since it is not
   always the case that the event at the head of the pipe is the event
   we want.  */

static void
pipe_to_local_event_queue (void)
{
  if (debug_linux_nat_async)
    fprintf_unfiltered (gdb_stdlog,
			"PTLEQ: linux_nat_num_queued_events(%d)\n",
			linux_nat_num_queued_events);
  while (linux_nat_num_queued_events)
    {
      int lwpid, status, options;
      lwpid = linux_nat_event_pipe_pop (&status, &options);
      gdb_assert (lwpid > 0);
      push_waitpid (lwpid, status, options);
    }
}

/* Get the unprocessed events stored in the local queue back into the
   pipe, so the event loop realizes there's something else to
   process.  */

static void
local_event_queue_to_pipe (void)
{
  struct waitpid_result *w = waitpid_queue;
  while (w)
    {
      struct waitpid_result *next = w->next;
      linux_nat_event_pipe_push (w->pid,
				 w->status,
				 w->options);
      xfree (w);
      w = next;
    }
  waitpid_queue = NULL;

  if (debug_linux_nat_async)
    fprintf_unfiltered (gdb_stdlog,
			"LEQTP: linux_nat_num_queued_events(%d)\n",
			linux_nat_num_queued_events);
}

d2579 2
a2580 2
linux_nat_wait (struct target_ops *ops,
		ptid_t ptid, struct target_waitstatus *ourstatus)
d2582 1
d2607 2
a2608 2
  /* Block events while we're here.  */
  linux_nat_async_events (sigchld_sync);
a2621 4
	  if (target_can_async_p ())
	    internal_error (__FILE__, __LINE__,
			    "Found an LWP with a pending status in async mode.");

d2633 2
a2634 2
         cloned and uncloned processes.  We start with the cloned
         processes.  */
d2697 3
d2704 1
a2704 6
      if (target_can_async_p ())
	/* In async mode, don't ever block.  Only look at the locally
	   queued events.  */
	lwpid = queued_waitpid (pid, &status, options);
      else
	lwpid = my_waitpid (pid, &status, options);
a2742 3
		  /* Get ready for the next event.  */
		  target_async (inferior_event_handler, 0);

d2746 1
d2873 30
d2907 1
a2907 4
  if (debug_linux_nat_async)
    fprintf_unfiltered (gdb_stdlog, "LLW: exit\n");

  return lp->ptid;
a2985 3
  if (target_can_async_p ())
    target_async (NULL, 0);

d3000 1
a3000 4
    {
      linux_fork_killall ();
      drain_queued_events (-1);
    }
d3029 2
a3032 1
      linux_ops->to_mourn_inferior (ops);
a3186 15
static void
sigchld_handler (int signo)
{
  if (target_async_permitted
      && linux_nat_async_events_state != sigchld_sync
      && signo == SIGCHLD)
    /* It is *always* a bug to hit this.  */
    internal_error (__FILE__, __LINE__,
		    "sigchld_handler called when async events are enabled");

  /* Do nothing.  The only reason for this handler is that it allows
     us to use sigsuspend in linux_nat_wait above to wait for the
     arrival of a SIGCHLD.  */
}

d4094 1
a4094 1
     it explicitly with the "maintenance set target-async" command.
d4108 1
a4108 1
     it explicitly with the "maintenance set target-async" command.
d4126 1
a4126 1
linux_nat_async_mask (int mask)
d4128 1
a4128 2
  int current_state;
  current_state = linux_nat_async_mask_value;
d4130 1
a4130 1
  if (current_state != mask)
d4132 1
a4132 1
      if (mask == 0)
d4135 1
a4135 1
	  linux_nat_async_mask_value = mask;
d4139 1
a4139 4
	  linux_nat_async_mask_value = mask;
	  linux_nat_async (inferior_event_handler, 0);
	}
    }
d4141 7
a4147 176
  return current_state;
}

/* Pop an event from the event pipe.  */

static int
linux_nat_event_pipe_pop (int* ptr_status, int* ptr_options)
{
  struct waitpid_result event = {0};
  int ret;

  do
    {
      ret = read (linux_nat_event_pipe[0], &event, sizeof (event));
    }
  while (ret == -1 && errno == EINTR);

  gdb_assert (ret == sizeof (event));

  *ptr_status = event.status;
  *ptr_options = event.options;

  linux_nat_num_queued_events--;

  return event.pid;
}

/* Push an event into the event pipe.  */

static void
linux_nat_event_pipe_push (int pid, int status, int options)
{
  int ret;
  struct waitpid_result event = {0};
  event.pid = pid;
  event.status = status;
  event.options = options;

  do
    {
      ret = write (linux_nat_event_pipe[1], &event, sizeof (event));
      gdb_assert ((ret == -1 && errno == EINTR) || ret == sizeof (event));
    } while (ret == -1 && errno == EINTR);

  linux_nat_num_queued_events++;
}

static void
get_pending_events (void)
{
  int status, options, pid;

  if (!target_async_permitted
      || linux_nat_async_events_state != sigchld_async)
    internal_error (__FILE__, __LINE__,
		    "get_pending_events called with async masked");

  while (1)
    {
      status = 0;
      options = __WCLONE | WNOHANG;

      do
	{
	  pid = waitpid (-1, &status, options);
	}
      while (pid == -1 && errno == EINTR);

      if (pid <= 0)
	{
	  options = WNOHANG;
	  do
	    {
	      pid = waitpid (-1, &status, options);
	    }
	  while (pid == -1 && errno == EINTR);
	}

      if (pid <= 0)
	/* No more children reporting events.  */
	break;

      if (debug_linux_nat_async)
	fprintf_unfiltered (gdb_stdlog, "\
get_pending_events: pid(%d), status(%x), options (%x)\n",
			    pid, status, options);

      linux_nat_event_pipe_push (pid, status, options);
    }

  if (debug_linux_nat_async)
    fprintf_unfiltered (gdb_stdlog, "\
get_pending_events: linux_nat_num_queued_events(%d)\n",
			linux_nat_num_queued_events);
}

/* SIGCHLD handler for async mode.  */

static void
async_sigchld_handler (int signo)
{
  if (debug_linux_nat_async)
    fprintf_unfiltered (gdb_stdlog, "async_sigchld_handler\n");

  get_pending_events ();
}

/* Set SIGCHLD handling state to STATE.  Returns previous state.  */

static enum sigchld_state
linux_nat_async_events (enum sigchld_state state)
{
  enum sigchld_state current_state = linux_nat_async_events_state;

  if (debug_linux_nat_async)
    fprintf_unfiltered (gdb_stdlog,
			"LNAE: state(%d): linux_nat_async_events_state(%d), "
			"linux_nat_num_queued_events(%d)\n",
			state, linux_nat_async_events_state,
			linux_nat_num_queued_events);

  if (current_state != state)
    {
      sigset_t mask;
      sigemptyset (&mask);
      sigaddset (&mask, SIGCHLD);

      /* Always block before changing state.  */
      sigprocmask (SIG_BLOCK, &mask, NULL);

      /* Set new state.  */
      linux_nat_async_events_state = state;

      switch (state)
	{
	case sigchld_sync:
	  {
	    /* Block target events.  */
	    sigprocmask (SIG_BLOCK, &mask, NULL);
	    sigaction (SIGCHLD, &sync_sigchld_action, NULL);
	    /* Get events out of queue, and make them available to
	       queued_waitpid / my_waitpid.  */
	    pipe_to_local_event_queue ();
	  }
	  break;
	case sigchld_async:
	  {
	    /* Unblock target events for async mode.  */

	    sigprocmask (SIG_BLOCK, &mask, NULL);

	    /* Put events we already waited on, in the pipe first, so
	       events are FIFO.  */
	    local_event_queue_to_pipe ();
	    /* While in masked async, we may have not collected all
	       the pending events.  Get them out now.  */
	    get_pending_events ();

	    /* Let'em come.   */
	    sigaction (SIGCHLD, &async_sigchld_action, NULL);
	    sigprocmask (SIG_UNBLOCK, &mask, NULL);
	  }
	  break;
	case sigchld_default:
	  {
	    /* SIGCHLD default mode.  */
	    sigaction (SIGCHLD, &sigchld_default_action, NULL);

	    /* Get events out of queue, and make them available to
	       queued_waitpid / my_waitpid.  */
	    pipe_to_local_event_queue ();

	    /* Unblock SIGCHLD.  */
	    sigprocmask (SIG_UNBLOCK, &mask, NULL);
	  }
	  break;
d4151 1
a4151 1
  return current_state;
d4216 23
d4240 9
a4248 1
linux_nat_async_file_handler (int error, gdb_client_data client_data)
d4250 29
a4278 1
  async_client_callback (INF_REG_EVENT, async_client_context);
d4295 8
a4302 4
      add_file_handler (linux_nat_event_pipe[0],
			linux_nat_async_file_handler, NULL);

      linux_nat_async_events (sigchld_async);
a4307 2

      linux_nat_async_events (sigchld_sync);
d4309 1
d4330 1
a4336 4
	  /* Peek once, to check if we've already waited for this
	     LWP.  */
	  pid = queued_waitpid_1 (ptid_get_lwp (lwp->ptid), &status,
				  lwp->cloned ? __WCLONE : 0,  1 /* peek */);
d4338 2
a4339 3
	  if (pid == -1)
	    {
	      ptid_t ptid = lwp->ptid;
d4341 5
a4345 13
	      stop_callback (lwp, NULL);
	      stop_wait_callback (lwp, NULL);

	      /* If the lwp exits while we try to stop it, there's
		 nothing else to do.  */
	      lwp = find_lwp_pid (ptid);
	      if (lwp == NULL)
		return 0;

	      pid = queued_waitpid_1 (ptid_get_lwp (lwp->ptid), &status,
				      lwp->cloned ? __WCLONE : 0,
				      1 /* peek */);
	    }
d4351 3
a4353 3
	  if (pid == -1)
	    push_waitpid (ptid_get_lwp (lwp->ptid), W_STOPCODE (0),
			  lwp->cloned ? __WCLONE : 0);
d4379 1
a4379 5
    {
      linux_nat_async_events (sigchld_sync);
      iterate_over_lwps (linux_nat_stop_lwp, &ptid);
      target_async (inferior_event_handler, 0);
    }
a4460 12
/* Enable/Disable async mode.  */

static void
linux_nat_setup_async (void)
{
  if (pipe (linux_nat_event_pipe) == -1)
    internal_error (__FILE__, __LINE__,
		    "creating event pipe failed.");
  fcntl (linux_nat_event_pipe[0], F_SETFL, O_NONBLOCK);
  fcntl (linux_nat_event_pipe[1], F_SETFL, O_NONBLOCK);
}

a4495 11
  /* Get the default SIGCHLD action.  Used while forking an inferior
     (see linux_nat_create_inferior/linux_nat_async_events).  */
  sigaction (SIGCHLD, NULL, &sigchld_default_action);

  /* Block SIGCHLD by default.  Doing this early prevents it getting
     unblocked if an exception is thrown due to an error while the
     inferior is starting (sigsetjmp/siglongjmp).  */
  sigemptyset (&mask);
  sigaddset (&mask, SIGCHLD);
  sigprocmask (SIG_BLOCK, &mask, NULL);

d4499 4
a4502 4
  /* The synchronous SIGCHLD handler.  */
  sync_sigchld_action.sa_handler = sigchld_handler;
  sigemptyset (&sync_sigchld_action.sa_mask);
  sync_sigchld_action.sa_flags = SA_RESTART;
d4505 1
a4505 1
  sigaction (SIGCHLD, &sync_sigchld_action, NULL);
d4511 1
a4511 6
  /* SIGCHLD handler for async mode.  */
  async_sigchld_action.sa_handler = async_sigchld_handler;
  sigemptyset (&async_sigchld_action.sa_mask);
  async_sigchld_action.sa_flags = SA_RESTART;

  linux_nat_setup_async ();
a4557 1
  sigset_t blocked_mask;
@


1.128
log
@        * linux-nat.c (linux_nat_filter_event): Minor comment reformatting.
@
text
@a3263 2
  struct lwp_info *lp;
  LONGEST n;
@


1.127
log
@        * linux-nat.c (linux_nat_filter_events): Do not delete the lwp if
        this is the last one.
@
text
@d2635 1
a2635 1
	 used.	*/
@


1.126
log
@	ARI fix: "strlen d_name" rule.
	* linux-nat.c (linux_nat_xfer_osdata): Use NAMELEN macro.
@
text
@d2626 3
a2628 3
      /* If this is the main thread, we must stop all threads and
	 verify if they are still alive.  This is because in the nptl
	 thread model, there is no signal issued for exiting LWPs
d2635 1
a2635 1
	 used.  */
d2647 8
a2654 7
      exit_lwp (lp);

      /* If there is at least one more LWP, then the exit signal was
	 not the end of the debugged application and should be
	 ignored.  */
      if (num_lwps > 0)
	return NULL;
@


1.125
log
@	* linux-nat.c (linux_nat_find_memory_regions): Result of PIDGET is an
	int, not a long long.
	(linux_nat_info_proc_cmd): Store pid in long instead of long long.
@
text
@d4166 1
a4166 1
                 || strlen (dp->d_name) > sizeof ("4294967295") - 1)
@


1.124
log
@        Add a target_ops parameter to the to_kill method in struct target_ops.

        * target.h (struct target_ops): Add a "target_ops *" parameter to
        method to_kill.
        (target_kill): Remove macro. Add declaration.
        * target.c (debug_to_kill): Delete, no longer necessary.
        (target_kill): New function.
        (update_current_target):  Stop inheriting the to_kill method.
        Do not de_fault it to no_process either.
        (setup_target_debug): Do not set current_target.to_kill.
        * gnu-nat.c, go32-nat.c, hpux-thread.c, inf-ptrace.c, inf-ttrace.c,
        linux-nat.c, monitor.c, nto-procfs.c, procfs.c, remote-m32r-sdi.c,
        remote-mips.c, remote-sim.c, remote.c, windows-nat.c: Update
        accordingly.
@
text
@d3457 1
a3457 1
  long long pid = PIDGET (inferior_ptid);
d3467 1
a3467 1
  sprintf (mapsfilename, "/proc/%lld/maps", pid);
d3720 3
a3722 1
  long long pid = PIDGET (inferior_ptid);
d3786 1
a3786 1
  sprintf (fname1, "/proc/%lld", pid);
d3790 1
a3790 1
  printf_filtered (_("process %lld\n"), pid);
d3793 1
a3793 1
      sprintf (fname1, "/proc/%lld/cmdline", pid);
d3808 1
a3808 1
      sprintf (fname1, "/proc/%lld/cwd", pid);
d3817 1
a3817 1
      sprintf (fname1, "/proc/%lld/exe", pid);
d3826 1
a3826 1
      sprintf (fname1, "/proc/%lld/maps", pid);
d3888 1
a3888 1
      sprintf (fname1, "/proc/%lld/status", pid);
d3901 1
a3901 1
      sprintf (fname1, "/proc/%lld/stat", pid);
@


1.123
log
@	* corelow.c (get_core_registers): Adjust.
	(core_file_thread_alive): Rename to...
	(core_thread_alive): ... this.
	(core_pid_to_str): Try gdbarch_core_pid_to_str first.
	(init_core_ops): Adjust.
	(coreops_suppress_target): Delete.
	(_initialize_corelow): Unconditionally add core_ops.
	* procfs.c: Include "inf-child.h".
	(procfs_ops): Delete.
	(init_procfs_ops): Delete.  Reimplement as...
	(procfs_target): ... this, inheriting from inf-child.
	(procfs_attach, procfs_detach, procfs_fetch_registers): Adjust.
	(procfs_prepare_to_store): Delete.
	(procfs_store_registers, procfs_resume): Adjust.
	(procfs_open): Delete.
	(procfs_suppress_run): Delete.
	(procfs_can_run): Delete.
	(procfs_mourn_inferior): Adjust.
	(procfs_init_inferior): Add target_ops parameter.  Adjust.
	(procfs_create_inferior): Don't pass procfs_init_inferior to
	fork_inferior.  Instead call it after fork_inferior returns.
	(procfs_find_new_threads): Adjust.
	(_initialize_procfs): Adjust to use procfs_target instead of
	init_procfs_ops.
	* sol-thread.c (orig_core_ops, sol_core_ops): Delete.
	(lwp_to_thread): Use target_thread_alive.
	(sol_thread_open): Delete.
	(sol_thread_attach): Delete.
	(sol_thread_detach, sol_thread_resume, sol_thread_wait)
	(sol_thread_fetch_registers, sol_thread_store_registers): Adjust
	to use find_target_beneath.
	(sol_thread_prepare_to_store, sol_thread_xfer_memory): Delete.
	(sol_thread_xfer_partial): Adjust to use find_target_beneath.
	(sol_thread_files_info, sol_thread_kill_inferior): Delete.
	(check_for_thread_db): New.
	(sol_thread_notice_signals, sol_thread_create_inferior): Delete.
	(sol_thread_new_objfile): Call check_for_thread_db.
	(sol_thread_mourn_inferior): Adjust to use find_target_beneath.
	(sol_thread_can_run): Delete.
	(sol_thread_alive): Adjust to use find_target_beneath.
	(sol_thread_stop): Delete.
	(rw_common): Use target_write_memory or target_read_memory.
	(ps_lgetregs, ps_lgetfpregs): Use target_fetch_registers.
	(ps_lsetregs, ps_lsetfpregs): Use target_store_registers.
	(solaris_pid_to_str): Remove check for libthread_db initialization
	failing.
	(sol_find_new_threads): Remove check for libthread_db
	initialization failing, or for an invalid inferior_ptid.  Adjust
	to use find_target_beneath.
	(sol_core_open, sol_core_close, sol_core_detach,
	sol_core_files_info, sol_find_memory_regions,
	sol_make_note_section, ignore): Delete.
	(init_sol_thread_ops): Make it a thread_stratum target.  Remove
	unneeded callback settings.
	(init_sol_core_ops): Delete.
	(_initialize_sol_thread): No longer call init_sol_core_ops, set
	procfs_suppress_run, or hack with core_ops.

	* target.h (struct target_ops): Add a target_ops * parameter to
	to_resume, to_fetch_registers, to_store_registers, to_thread_alive
	and to_find_new_threads.
	(target_fetch_registers, target_store_registers)
	(target_thread_alive, target_find_new_threads): Redeclare as
	function.

	* target.c (update_current_target): Do not inherit or de_fault
	to_resume, to_fetch_registers, to_store_registers,
	to_thread_alive, to_find_new_threads.
	(target_resume): Adjust.
	(target_thread_alive, target_find_new_threads): New.
	(debug_to_resume, debug_to_fetch_registers): Delete.
	(target_fetch_registers): New.
	(debug_to_store_registers): Delete.
	(target_store_registers): New.
	(debug_to_thread_alive, debug_to_find_new_threads): Delete.
	(setup_target_debug): Adjust.

	* gdbcore.h (core_ops): Delete declaration.

	* inf-ptrace.c, linux-nat.c, remote.c, amd64-linux-nat.c,
	inf-child.c, linux-thread-db.c, bsd-uthread.c, inf-ttrace.c,
	i386-sol2-tdep.c, darwin-nat.c, gnu-nat.c, go32-nat.c,
	hpux-thread.c, i386-linux-nat.c, i386fbsd-nat.c, monitor.c,
	nto-procfs.c, remote-m32r-sdi.c, remote-mips.c, windows-nat.c,
	alphabsd-nat.c, amd64bsd-nat.c, arm-linux-nat.c, armnbsd-nat.c,
	bsd-kvm.c, hppa-hpux-nat.c, hppa-linux-nat.c, hppabsd-nat.c,
	hppanbsd-nat.c, i386-darwin-nat.c, i386bsd-nat.c,
	ia64-linux-nat.c, m32r-linux-nat.c, m68kbsd-nat.c,
	m68klinux-nat.c, m88kbsd-nat.c, mips-linux-nat.c,
	mips64obsd-nat.c, mipsnbsd-nat.c, ppc-linux-nat.c, ppcnbsd-nat.c,
	ppcobsd-nat.c, remote-sim.c, rs6000-nat.c, s390-nat.c,
	shnbsd-nat.c, sparc-nat.c, sparc-nat.h, spu-linux-nat.c,
	vaxbsd-nat.c, xtensa-linux-nat.c: Adjust to target_ops changes.

	* gdbarch.sh (core_pid_to_str): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* sol2-tdep.c: Include "inferior.h".
	(sol2_core_pid_to_str): New.
	* sol2-tdep.h (sol2_core_pid_to_str): Declare.

	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Set it.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Set it.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Set it.
@
text
@d3170 1
a3170 1
linux_nat_kill (void)
@


1.122
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d993 1
a993 1
static int linux_nat_thread_alive (ptid_t ptid);
d1667 2
a1668 1
      linux_ops->to_resume (pid_to_ptid (GET_LWP (lp->ptid)),
d1703 2
a1704 1
linux_nat_resume (ptid_t ptid, int step, enum target_signal signo)
d1815 1
a1815 1
  linux_ops->to_resume (ptid, step, signo);
d2660 1
a2660 1
  if (num_lwps > 1 && !linux_nat_thread_alive (lp->ptid))
d2691 1
a2691 1
      linux_ops->to_resume (pid_to_ptid (GET_LWP (lp->ptid)),
d2721 1
a2721 1
      linux_ops->to_resume (pid_to_ptid (GET_LWP (lp->ptid)),
d2890 1
a2890 1
      linux_ops->to_resume (pid_to_ptid (GET_LWP (lp->ptid)),
d3011 1
a3011 1
	  linux_ops->to_resume (pid_to_ptid (GET_LWP (lp->ptid)),
d3339 1
a3339 1
linux_nat_thread_alive (ptid_t ptid)
d3362 6
@


1.121
log
@	* linux-nat.c (PTRACE_SETSIGINFO): Define if PTRACE_GETSIGINFO
	isn't defined.
@
text
@d4561 1
a4561 1
void
d4802 3
@


1.120
log
@	* amd64-linux-nat.c (compat_int_t, compat_uptr_t, compat_time_t)
	(compat_timer_t, compat_clock_t, struct compat_timeval)
	(compat_sigval_t, compat_siginfo_t): New types.
	(cpt_si_pid, cpt_si_uid, cpt_si_timerid, cpt_si_overrun)
	(cpt_si_status, cpt_si_utime, cpt_si_stime, cpt_si_ptr)
	(cpt_si_addr, cpt_si_band, cpt_si_fd): New defines.
	(compat_siginfo_from_siginfo, siginfo_from_compat_siginfo)
	(amd64_linux_siginfo_fixup): New.
	* linux-nat.c (linux_nat_siginfo_fixup): New.
	(siginfo_fixup): New.
	(linux_xfer_siginfo): Use siginfo_fixup to convert between the
	siginfo layout expected by ptrace and the siginfo layout of the
	inferior.
	(linux_nat_set_siginfo_fixup): New.
	* linux-nat.h (linux_nat_set_siginfo_fixup): Declare.
@
text
@d197 2
a198 1
#define PTRACE_GETSIGINFO    0x4202
@


1.119
log
@2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* target.h (enum target_object): Add new TARGET_OBJECT_SIGNAL_INFO.
	* infrun.c (siginfo_value_read, siginfo_value_write): New.
	(siginfo_value_funcs): New.
	(siginfo_make_value): New.
	(_initialize_infrun): Create the $_siginfo convenience variable.
	* gdbtypes.h (append_composite_type_field_aligned): Declare.
	* gdbtypes.c (append_composite_type_field): Rename to...
	(append_composite_type_field_aligned): ... this.  Add ALIGNMENT
	argument.  Handle it.
	(append_composite_type_field): Rewrite on top of
	append_composite_type_field_aligned.
	* value.h (internalvar_make_value): New typedef.
	(struct internalvar) <make_value>: New field.
	(create_internalvar_type_lazy): Declare.
	* value.c (create_internalvar): Clear make_value.
	(create_internalvar_type_lazy): New.
	(value_of_internalvar): If make_value is set use it.
	(preserve_values): Skip internal variables that don't have a
	value.
	* gdbarch.sh (get_siginfo_type): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.h, linux-tdep.c: New.
	* amd64-linux-tdep.c: Include "linux-tdep.h".
	(amd64_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.
	* i386-linux-tdep.c: Include "linux-tdep.h".
	(i386_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.
	* arm-linux-tdep.c: Include "linux-tdep.h".
	(i386_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.

	* linux-nat.c (linux_xfer_siginfo): New.
	(linux_nat_xfer_partial): Handle TARGET_OBJECT_SIGNAL_INFO.
	* remote.c (PACKET_qXfer_siginfo_read)
	(PACKET_qXfer_siginfo_write): New.
	(feature remote_protocol_features): Add "qXfer:siginfo:read" and
	"qXfer:siginfo:write" features.
	(remote_xfer_partial): Handle TARGET_OBJECT_SIGNAL_INFO.
	(_initialize_remote): Add "set/show remote read-siginfo-object"
	and "set/show remote write-siginfo-object" commands.

	* Makefile.in (ALL_TARGET_OBS): Add linux-tdep.o.
	(HFILES_NO_SRCDIR): Add linux-tdep.h.
	(ALLDEPFILES): Add linux-tdep.c.

	* configure.tgt (arm*-*-linux* | arm*-*-uclinux*)
	(i[34567]86-*-linux*, x86_64-*-linux*): Add linux-tdep.o to
	gdb_target_obs.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/gdbserver/
	* server.c (handle_query): Report qXfer:siginfo:read and
	qXfer:siginfo:write as supported and handle them.
	* target.h (struct target_ops) <qxfer_siginfo>: New field.
	* linux-low.c (linux_xfer_siginfo): New.
	(linux_target_ops): Set it.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Signals): Document $_siginfo.
	(Convenience Variables): Mention $_siginfo.
	(Remote Configuration): Document qXfer:siginfo:read,
	qXfer:siginfo:write packets, and the read-siginfo-object,
	write-siginfo-object commands.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/siginfo-obj.c, gdb.base/siginfo-obj.exp: New.
@
text
@d208 7
d3233 22
d3264 1
d3281 8
d3293 1
a3293 1
    memcpy (readbuf, (char *)&siginfo + offset, len);
d3296 5
a3300 1
      memcpy ((char *)&siginfo + offset, writebuf, len);
d4765 13
@


1.118
log
@	* linux-nat.c (linux_nat_wait): Adjust.
	(linux_nat_pid_to_str): Adjust.  Remove call to thread_db_init.
	* linux-nat.h (thread_db_init): Delete declaration.
	* linux-thread-db.c (target_beneath): Delete.
	(thread_db_init): Delete.
	(thread_db_detach): Use find_target_beneath.
	(thread_db_wait): Adjust interface.  Use find_target_beneath.
	(thread_db_mourn_inferior): Use find_target_beneath.
	(thread_db_can_async_p, thread_db_is_async_p, thread_db_async)
	(thread_db_async_mask): Delete.
	(thread_db_pid_to_str): Adjust interface.  Use
	find_target_beneath.
	(thread_db_get_thread_local_address): Adjust interface.  Use
	find_target_beneath.
	(init_thread_db_ops): Delete references to delete functions.
	* target.c (update_current_target): Don't inherit or default
	to_wait.  Don't inherit to_pid_to_str and
	to_get_thread_local_address.
	(target_translate_tls_address): Look for a pushed target that
	implements to_get_thread_local_address, and use it instead of
	checking for target_get_thread_local_address_p.
	(target_wait, target_pid_to_str): Reimplement as functions.
	(dummy_pid_to_str): New.
	(init_dummy_target): Register it.
	(debug_to_wait): Delete.
	* target.h (struct target_ops): Make to_wait, to_pid_to_str and
	to_get_thread_local_address accept a pointer to struct target_ops.
	(target_wait): Delete macro, and declare as function.
	(target_pid_to_str): Likewise.
	(target_get_thread_local_address)
	(target_get_thread_local_address_p): Delete.
	(noprocess): Add NORETURN and ATTR_NORETURN tags.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	(inf_ptrace_pid_to_str): New.
	(inf_ptrace_target): Use inf_ptrace_pid_to_str.
	* aix-thread.c (aix_thread_wait, aix_thread_pid_to_str): Adjust.
	* bsd-kvm.c (bsd_kvm_pid_to_str): Adjust.
	* bsd-uthread.c (bsd_uthread_wait, bsd_uthread_pid_to_str):
	Adjust.
	* corelow.c (core_pid_to_str): Adjust.
	* darwin-nat.c (darwin_wait, darwin_pid_to_str): Adjust.
	* dec-thread.c (dec_thread_wait, dec_thread_pid_to_str): Adjust.
	* gnu-nat.c (gnu_wait, gnu_pid_to_str): Adjust.
	* go32-nat.c (go32_wait, go32_pid_to_str): Adjust.
	* hpux-thread.c (hpux_thread_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait, inf_ttrace_pid_to_str): Adjust.
	* monitor.c (monitor_wait, monitor_pid_to_str): Adjust.
	* nto-procfs.c (procfs_wait, procfs_pid_to_str): Adjust.
	* procfs.c (procfs_pid_to_str): Adjust.
	* remote-m32r-sdi.c (m32r_wait, m32r_pid_to_str): Adjust.
	* remote-mips.c (mips_wait): Adjust.
	* remote-sim.c (gdbsim_wait, gdbsim_pid_to_str): Adjust.
	* remote.c (remote_wait, remote_pid_to_str)
	(remote_get_thread_local_address): Adjust.
	* rs6000-nat.c (rs6000_wait): Adjust.
	* sol-thread.c (procfs_pid_to_str): Adjust declaration.
	(sol_thread_wait, solaris_pid_to_str): Adjust.
	* spu-linux-nat.c (spu_child_wait): Adjust.
	* windows-nat.c (windows_wait, windows_pid_to_str): Adjust.
@
text
@d3227 42
d3274 1
a3274 1
  struct cleanup *old_chain = save_inferior_ptid ();
d3277 6
@


1.117
log
@	* linux-nat.c (linux_child_follow_fork): Copy attach_flag from the
	parent to the child.
	* inf-ttrace.c (inf_ttrace_follow_fork): Likewise.
	* inf-ptrace.c (inf_ptrace_follow_fork): Likewise.  Use
	remove_breakpoints to remove breakpoints from the parent.
@
text
@d2779 2
a2780 1
linux_nat_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
d3270 1
a3270 1
linux_nat_pid_to_str (ptid_t ptid)
a4662 4

  /* TODO: Eliminate this and have libthread_db use
     find_target_beneath.  */
  thread_db_init (t);
@


1.116
log
@Check return values of functions declared with warn_unused_result
attribute in GLIBC 2.8.
* cli/cli-cmds.c (pwd_command): Check return value from getcwd.
* inflow.c (check_syscall): New function.
(new_tty): Use check_syscall to check return values from open and dup.
* linux-nat.c (linux_nat_info_proc_cmd): Check return value from fgets.
* main.c (captured_main): Call cwd after setting up gdb_stderr;
check for errors from getcwd.
* mi/mi-cmd-env.c (mi_cmd_env_pwd): Check return value from getcwd.
* ui-file.c (stdio_file_write): Ignore return value from fwrite.
(stdio_file_fputs): Same.
* utils.c (internal_vproblem): abort if last-ditch error message
write fails.
@
text
@d733 1
d736 4
a739 1
	  add_inferior (child_pid);
d807 1
d837 4
a840 1
      add_inferior (child_pid);
@


1.115
log
@        Updated copyright notices for most files.
@
text
@d3687 4
a3690 2
	  fgets (buffer, sizeof (buffer), procfile);
	  printf_filtered ("cmdline = '%s'\n", buffer);
@


1.114
log
@	* linux-fork.c (linux_fork_detach): New.
	* linux-fork.h (linux_fork_detach): Declare.
	* linux-nat.c (linux_child_follow_fork): When following the fork
	child, add the child inferior before possibly detaching from the
	parent.  Don't reinstall ourselves.
	(linux_nat_detach): Call linux_fork_detach if there are other
	forks to debug.
	* linux-thread-db.c (thread_db_detach): Don't call
	target_mourn_inferior.  Instead inline the necessary bits.
	* inf-ptrace.c (inf_ptrace_detach): Don't unpush the target if
	there are other inferiors to debug.
@
text
@d3 1
a3 1
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.113
log
@	* linux-nat.c (linux_child_follow_fork): If following the child,
	and not detaching the parent, also add the child fork to the fork
	list.
	* linux-fork.c (linux_fork_context): Remove dead error call.
	Assert that the incoming newfp argument is not null.  Do not add a
	new fork for inferior_ptid.  Assert that there is one already.
@
text
@d829 5
a875 4
      add_inferior (child_pid);

      /* Reinstall ourselves, since we might have been removed in
	 target_detach (which does other necessary cleanup).  */
a876 1
      push_target (ops);
d1624 1
a1624 3
  pid = GET_PID (inferior_ptid);
  inferior_ptid = pid_to_ptid (pid);
  linux_ops->to_detach (ops, args, from_tty);
d1628 14
@


1.112
log
@2008-12-16  Tristan Gingold  <gingold@@adacore.com>

	* inflow.c: Remove old_sigio, handle_sigio, old_fcntl_flags,
	set_sigio_trap, clear_sigio_trap definitions.
	* inferior.h: Remove set_sigio_trap and clear_sigio_trap declarations.
	* inf-ptrace.c (inf_ptrace_wait): Remove call to set_sigio_trap
	and clear_sigio_trap.
	* inf-ttrace.c (inf_ttrace_wait): Ditto.
	* linux-nat.c (linux_nat_wait): Ditto.
	* spu-linux-nat.c (spu_child_wait): Ditto.
	* rs6000-nat.c (rs6000_wait): Ditto.
	* target.c: Remove target_activity_function and target_activity_fd.
	* target.h: Remove target_activity_function and target_activity_fd
	declarations.
@
text
@d860 6
@


1.111
log
@	Implement -list-thread-groups --available

        * Makefile.in (XMLFILES): Add osdata.dtd.
        (SFILES): Add osdata.c.
        (COMMON_OBS): Add osdata.o.
        * linux-nat.c: Include pwd.h, sys/types.h, gdb_dirent.h and xml-support.h.
        (linux_nat_xfer_osdata): New function.
        (linux_xfer_partial): Handle TARGET_OBJECT_OSDATA.
        * osdata.c: New file.
        * osdata.h: New file.
        * remote.c (PACKET_qXfer_osdata): New packet enum.
        (remote_protocol_features): Add "qXfer:osdata:read".
        (remote_read_qxfer): Handle TARGET_OBJECT_OSDATA.
        (extended_remote_can_run): New.
        (init_extended_remote_ops): Set to_can_run to
        extended_remote_can_run.
        (_initialize_remote): Add packet config command for
        "qXfer:osdata:read".
        * xml-support.c (obstack_xml_printf): New function.
        * xml-support.h (obstack_xml_printf): Declare.
        * target.c (target_get_osdata): New function.
        * target.h (enum target_object): Add TARGET_OBJECT_OSDATA.
        (target_os_data): Declare.
        * features/osdata.dtd: New file.
        * mi/mi-main.c (mi_list_thread_groups): Handle the --available
        option.
@
text
@a2870 1
      set_sigio_trap ();
d2939 1
a2939 4
    {
      clear_sigio_trap ();
      clear_sigint_trap ();
    }
@


1.110
log
@	Kill pthread_ops_hack

	* target.h (struct target_ops): Make to_attach, to_detach,
	to_create_inferior and to_mourn_inferior accept a pointer
    	to struct target_ops.
	(target_attach, target_create_inferior, target_create_inferior):
	Convert from macros to function.  Find the right target to
	invoke a method of.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.
	* corefile.c (core_file_command): Pass target to to_detach.
	* corelow.c (core_detach): Add 'ops' parameter.
	* fork-child.c (fork_inferior): Return the pid.  Allow
	init_trace_fun to be NULL.
	* inf-ptrace (ptrace_ops_hack): Remove.
	(inf_ptrace_him): Remove, moving all logic into....
	(inf_ptrace_create_inferior): ... here.  Push the target
	passed as parameter.
	(inf_ptrace_mourn_inferior, inf_ptrace_attach, inf_ptrace_detach):
	Push/pop target passed as parameter, no ptrace_ops_hack.
	(inf_ptrace_target): Don't remember result.
	* inferior.h (fork_inferior): Adjust prototype.
	* linux-nat.c (linux_nat_create_inferior, linux_nat_attach)
	(linux_nat_detach, linux_nat_mourn_inferior): New parameter ops.
	Pass it to linux_ops target.
	* linux-thread-db.c (thread_db_detach, thread_db_mourn_inferior):
	New parameter ops. Pass it to the target beneath.
	* remote.c (remote_mourn, extended_remote_mourn, remote_detach)
	(extended_remote_create_inferior): New parameter ops. Pass it
	further.
	* target.c (debug_to_attach, debug_to_detach)
	(debug_to_mourn_inferior): New parameter ops.
	(target_create_inferior): New.
	(update_current_target): Do not inherit to_attach, to_detach,
	to_create_inferiour, to_mourn_inferior.  Do not default
	to_detach and to_mourn_inferior.
	(target_detach): Find the right target to use.
	(target_mourn_inferior): New.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.  Pass the found target when calling its method.
	(init_dummy_target): Provide fallback definition of to_detach.
	(target_attach): New.
	(debug_to_attach, debug_to_detach, debug_to_create_inferior)
	(debug_to_mourn_inferiour): New parameter ops.
        * aix-thread.c: Adjust.
        * bsd-uthread.c: Adjust.
        * gnu-nat.c: Adjust.
        * go32-nat.c: Adjust.
        * hpux-thread.c: Adjust.
        * inf-ttrace.c: Ajust.
        * monitor.c: Adjust.
        * nto-procfs.c: Adjust.
        * procfs.c: Adjust.
        * remote-m32r-sdi.c: Adjust.
        * remote-mips.c: Adjust.
        * remote-sim.c: Adjust.
        * rs6000-nat.c: Adjust.
        * sol-thread.c: Adjust.
        * win32-nat.c: Adjust.
	* dec-thread.c: Adjust.
@
text
@d52 4
d4002 107
d4119 4
@


1.110.2.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@a52 2
extern int detach_fork;

a690 2
  struct inferior *child_inf, *parent_inf;
  struct exec *parent_exec = NULL;
a701 4
  parent_inf = find_inferior_pid (parent_pid);
  if (parent_inf)
    parent_exec = parent_inf->exec;

d731 1
a731 3
	  child_inf = add_inferior (child_pid);

	  set_inferior_exec (child_inf, parent_exec);
d861 1
a861 3
      child_inf = add_inferior (child_pid);

      set_inferior_exec (child_inf, parent_exec);
@


1.110.2.2
log
@	* linux-nat.c (linux_child_follow_fork): If following the child,
	and not detaching the parent, also add the child fork to the fork
	list.
	* linux-fork.c (linux_fork_context): Remove dead error call.
	Assert that the incoming newfp argument is not null.  Do not add a
	new fork for inferior_ptid.  Assert that there is one already.
@
text
@a865 6

	  /* Also add an entry for the child fork.  */
	  fp = find_fork_pid (child_pid);
	  if (!fp)
	    fp = add_fork (child_pid);
	  fork_save_infrun_state (fp, 0);
@


1.109
log
@	* cli/cli-script.c (do_fclose_cleanup): Remove.
	(script_from_file): Use make_cleanup_fclose.
	* xml-tdesc.c (do_cleanup_fclose): Remove.
	(fetch_xml_from_file): Use make_cleanup_fclose.
	* tracepoint.c (tracepoint_save_command): Use
	make_cleanup_fclose.  Always free pathname.
	* source.c (print_source_lines_base): Use make_cleanup_fclose.
	* remote.c (fclose_cleanup): Remove.
	(remote_file_put): Use make_cleanup_fclose.
	(remote_file_get): Likewise.
	* linux-nat.c (linux_nat_find_memory_regions): Use
	make_cleanup_fclose.
	(linux_nat_info_proc_cmd): Likewise.
	(linux_proc_pending_signals): Likewise.
	* fbsd-nat.c (fbsd_find_memory_regions): Use make_cleanup_fclose.
	Free file name.
	* cli/cli-dump.c (do_fclose_cleanup): Remove.
	(make_cleanup_fclose): Remove.
	* defs.h (make_cleanup_fclose): Declare.
	* utils.c (do_fclose_cleanup): New function.
	(make_cleanup_fclose): Likewise.
@
text
@d1320 2
a1321 1
linux_nat_create_inferior (char *exec_file, char *allargs, char **env,
d1368 1
a1368 1
  linux_ops->to_create_inferior (exec_file, allargs, env, from_tty);
d1386 1
a1386 1
linux_nat_attach (char *args, int from_tty)
d1394 1
a1394 1
  linux_ops->to_attach (args, from_tty);
d1575 1
a1575 1
linux_nat_detach (char *args, int from_tty)
d1616 1
a1616 1
  linux_ops->to_detach (args, from_tty);
d3180 1
a3180 1
linux_nat_mourn_inferior (void)
d3190 1
a3190 1
      linux_ops->to_mourn_inferior ();
@


1.108
log
@gdb/
2008-10-23  Pedro Alves  <pedro@@codesourcery.com>

	* defs.h: Mention ptid_is_pid.
	* inferior.h (ptid_is_pid): Declare.
	* gdbthread.h (struct thread_info) <stop_requested>: New field.
	(set_stop_requested): Declare.
	* infcmd.c (interrupt_target_1): Call set_stop_requested.
	* infrun.c (clear_proceed_status): Clear stop_requested.
	(infrun_thread_stop_requested_callback,
	infrun_thread_stop_requested): New.
	(handle_inferior_event): If a TARGET_SIGNAL_TRAP is reported on a
	thread that had an explicit stop request, pretend we got a
	TARGET_SIGNAL_0.  Always stop if the thread had an explicit stop
	request.
	(print_stop_reason): In the SIGNAL_RECEIVED case, if we're not
	outputting to MI, and we got a TARGET_SIGNAL_0, print "# Stopped",
	instead of mentioning signal 0.
	(ptid_is_pid): New.
	* thread.c (set_stop_requested): New.

	* linux-nat.c (queued_waitpid): Rename to ...
	(queued_waitpid_1): ... this.  Add `peek' argument.  Handle it.
	(queued_waitpid): New, as wrapper to queued_waitpid_1.
	(push_waitpid): Push the SIGTRAP to the local event queue, to the
	kernel's.
	(send_sigint_callback): Delete.
	(linux_nat_stop_lwp): New.
	(linux_nat_stop): Use it.

gdb/doc/
2008-10-23  Pedro Alves  <pedro@@codesourcery.com>

	* observer.texi (thread_stop_requested): New.

gdb/testsuite/
2008-10-23  Pedro Alves  <pedro@@codesourcery.com>

	* lib/mi-support.exp (mi_expect_interrupt): Expect signal 0
	instead of SIGINT.
@
text
@d3337 1
d3343 1
d3376 1
a3376 1
  fclose (mapsfile);
d3667 1
d3670 1
a3670 1
	  fclose (procfile);
d3700 1
d3702 1
d3750 1
a3750 1
	  fclose (procfile);
d3760 1
d3763 1
a3763 1
	  fclose (procfile);
d3776 1
d3860 1
a3860 1
	  fclose (procfile);
d3962 1
d3971 1
d3993 1
a3993 1
  fclose (procfile);
@


1.107
log
@2008-10-03  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* utils.c, defs.h (gdb_buildargv): New fn. Wrap buildargv
	and check for out-of-memory condition.
	* exec.c (exec_file_command): Call it.
	* infrun.c (handle_command, xdb_handle_command): Likewise.
	* interps.c (interpreter_exec_cmd): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* procfs.c (info_proc_cmd): Likewise.
	* remote-mips.c (common_open): Likewise.
	* remote-sim.c (gdbsim_kill, gdbsim_create_inferior)
	(gdbsim_open): Likewise.
	* remote.c (extended_remote_run, remote_put_command)
	(remote_get_command, remote_delete_command): Likewise.
	* ser-mingw.c (pipe_windows_open): Likesise.
	* source.c (add_path, show_substitute_path_command)
	(unset_substitute_path_command, set_substitute_path_command):
	Likewise.
	* stack.c (backtrace_command): Likewise.
	* symfile.c (symbol_file_command, generic_load)
	(add_symbol_file_command): Likesise.
	* symmisc.c (maintenance_print_symbols, maintenance_print_psymbols)
	(maintenance_print_msymbols): Likewise.
@
text
@a318 1
static int send_sigint_callback (struct lwp_info *lp, void *data);
d335 4
d340 1
a340 1
queued_waitpid (int pid, int *status, int flags)
a375 6
      if (prev)
	prev->next = msg->next;
      else
	waitpid_queue = msg->next;

      msg->next = NULL;
d383 11
a393 1
      xfree (msg);
d406 8
d2218 5
a2222 5
			fprintf_unfiltered (gdb_stdlog,
					    "SWC: kill %s, %s\n",
					    target_pid_to_str (lp->ptid),
					    status_to_str ((int) status));
		      kill_lwp (GET_LWP (lp->ptid), WSTOPSIG (status));
d4386 3
d4390 1
a4390 1
send_sigint_callback (struct lwp_info *lp, void *data)
d4392 64
a4455 6
  /* Use is_running instead of !lp->stopped, because the lwp may be
     stopped due to an internal event, and we want to interrupt it in
     that case too.  What we want is to check if the thread is stopped
     from the point of view of the user.  */
  if (is_running (lp->ptid))
    kill_lwp (GET_LWP (lp->ptid), SIGINT);
d4464 3
a4466 7
      if (ptid_equal (ptid, minus_one_ptid))
	iterate_over_lwps (send_sigint_callback, &ptid);
      else
	{
	  struct lwp_info *lp = find_lwp_pid (ptid);
	  send_sigint_callback (lp, NULL);
	}
@


1.106
log
@2008-09-25  Srgio Durigan Jnior  <sergiodj@@linux.vnet.ibm.com>

	* linux-nat.c (get_pending_status): Fix argument to WIFSTOPPED.
@
text
@d3594 2
a3595 4
      if ((argv = buildargv (args)) == NULL)
	nomem (0);
      else
	make_cleanup_freeargv (argv);
@


1.106.2.1
log
@2008-10-02  Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_open): Call target_can_async_p() instead
	of relying on a global variable.
	* record.h (record_linux_async_permitted): Delete.
	* linux-nat.h (record_linux_async_permitted): Delete reference.
@
text
@a52 2
#include "record.h"

a505 101
extern struct bp_location *bp_location_chain;
static struct lwp_info * find_lwp_pid (ptid_t ptid);
static int
my_waitpid_record (int pid, int *status, int flags)
{
  int ret;
  struct bp_location *bl;
  struct breakpoint *b;
  CORE_ADDR pc;
  struct lwp_info *lp;

wait_begin:
  ret = my_waitpid (pid, status, flags);
  if (ret == -1)
    {
      return ret;
    }

  if (ret == 0)
    {
      goto wait_begin;
    }

  if (WIFSTOPPED (*status) && WSTOPSIG (*status) == SIGTRAP)
    {
      /* Check if there is a breakpoint */
      pc = 0;
      registers_changed ();
      for (bl = bp_location_chain; bl; bl = bl->global_next)
	{
	  b = bl->owner;
	  gdb_assert (b);
	  if (b->enable_state != bp_enabled
	      && b->enable_state != bp_permanent)
	    continue;
	  if (!pc)
	    {
	      pc = regcache_read_pc (get_thread_regcache (pid_to_ptid (ret)));
	    }
	  switch (b->type)
	    {
	    default:
	      if (bl->address == pc)
		{
		  goto out;
		}
	      break;

	    case bp_watchpoint:
	      /*XXX teawater: I still not very clear how to deal with it. */
	      goto out;
	      break;

	    case bp_catch_fork:
	      if (inferior_has_forked (inferior_ptid, &b->forked_inferior_pid))
		{
		  goto out;
		}
	      break;

	    case bp_catch_vfork:
	      if (inferior_has_vforked (inferior_ptid, &b->forked_inferior_pid))
		{
		  goto out;
		}
	      break;

	    case bp_catch_exec:
	      if (inferior_has_execd (inferior_ptid, &b->exec_pathname))
		{
		  goto out;
		}
	      break;

	    case bp_hardware_watchpoint:
	    case bp_read_watchpoint:
	    case bp_access_watchpoint:
	      if (STOPPED_BY_WATCHPOINT (0))
		{
		  goto out;
		}
	      break;
	    }
	}

      lp = find_lwp_pid (pid_to_ptid (ret));
      if (lp)
        lp->stopped = 1;

      /* record message */
      record_message (current_gdbarch);

      /* resume program */
      linux_ops->to_resume (pid_to_ptid (ret), 1, TARGET_SIGNAL_0);
      goto wait_begin;
    }

out:
  return ret;
}

d2863 1
a2863 10
	{
	  if (RECORD_IS_USED && !record_resume_step)
	    {
	      lwpid = my_waitpid_record (pid, &status, options);
	    }
	  else
	    {
	      lwpid = my_waitpid (pid, &status, options);
	    }
	}
a4443 3
  /* Point out that this target support record wait. */
  t->to_support_record_wait = 1;

@


1.106.2.2
log
@2008-10-18  Hui Zhu  <teawater@@gmail.com>

	Remove "to_support_record_wait".

	* target.c (add_target): Remove "to_support_record_wait".
	* target.h (target_ops): Ditto.
	* linux-nat.c (linux_nat_add_target): Ditto.
	* record.h (RECORD_TARGET_SUPPORT_RECORD_WAIT): This macro is removed.
@
text
@d4556 3
@


1.106.2.3
log
@2008-11-06  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_wait): Set pc if forward execute,
	gdbarch_decr_pc_after_break is not 0 and this is not single
	step in replay mode.
	* linux-nat.c (my_waitpid_record): Add
	gdbarch_decr_pc_after_break to pc if need.
@
text
@a516 1
  CORE_ADDR decr_pc_after_break;
a517 1
  int is_breakpoint = 1;
d533 1
a533 1
      /* Check if there is a breakpoint.  */
a604 2
  is_breakpoint = 0;

a605 17
  /* Add gdbarch_decr_pc_after_break to pc because pc will be break at address
     add gdbarch_decr_pc_after_break when inferior non-step execute.  */
  if (is_breakpoint)
    {
      decr_pc_after_break = gdbarch_decr_pc_after_break
	(get_regcache_arch (get_thread_regcache (pid_to_ptid (ret))));
      if (decr_pc_after_break)
	{
	  if (!pc)
	    {
	      pc = regcache_read_pc (get_thread_regcache (pid_to_ptid (ret)));
	    }
	  regcache_write_pc (get_thread_regcache (pid_to_ptid (ret)),
			     pc + decr_pc_after_break);
	}
    }

@


1.105
log
@	Make the stop_soon global be per-inferior instead.

	* infcmd.c (attach_command_post_wait): Adjust.
	(attach_command): Likewise.

	* inferior.h (stop_soon): Delete.
	(struct inferior): Add stop_soon member.

	* infrun.c (stop_soon): Delete.
	(clear_proceed_status, start_remote)
	(fetch_inferior_event, handle_inferior_event): Adjust.
	(signal_stop_state): Don't check stop_soon here.  Check in callers
	instead.
	(save_inferior_status, restore_inferior_status): Adjust.

	* linux-nat.c (linux_nat_resume, linux_nat_wait): Always pass
	signals to common code if starting up the inferior.

	* inferior.h (struct inferior_info): Added stop_soon member.
	* inferior.c (add_inferior) Clear stop_soon.

	* mips-tdep.c (heuristic_proc_start): Adjust.
	* nto-procfs.c (procfs_create_inferior): Adjust.
	* solib-irix.c (irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Adjust.

	* win32-nat.c (do_initial_win32_stuff): Adjust.

	* alpha-tdep.c (alpha_heuristic_proc_start): Adjust.
@
text
@d1453 2
a1454 2
	      if (WIFSTOPPED (status))
		signo = target_signal_from_host (WSTOPSIG (status));
@


1.104
log
@	* gnu-nat.c (gnu_attach): Add process to inferiors table.
	(gnu_detach): Remove it.
	* go32-nat.c (go32_create_inferior): Add process to gdb's inferior
	table.
	* inf-ptrace.c (inf_ptrace_follow_fork): Delete and add inferiors
	to inferior table accordingly.
	(inf_ptrace_attach): Add new process to inferior table.
	(inf_ptrace_detach): Remove it.
	* inf-ttrace.c (inf_ttrace_follow_fork): Delete and add inferiors
	to inferior table accordingly.
	(inf_ttrace_attach): Add process to inferior table.
	(inf_ttrace_detach): Remove it.
	* linux-fork.c (init_fork_list): Delete any left over inferior.
	(linux_fork_mourn_inferior, detach_fork_command): Also delete
	processes from inferior list.
	* monitor.c (monitor_open): Add process to inferior list.
	(monitor_close): Remove it.
	* nto-procfs.c (procfs_attach): Add process to inferior list.
	Find threads after pushing the target.
	(procfs_detach): Remove process from inferior list.
	(procfs_create_inferior): Add process to inferior list.
	* procfs.c (procfs_detach): Remove process from inferior list.
	(do_attach): Add process to inferior list.
	* remote-sim.c (sim_create_inferior): Add process to inferior list.
	(gdbsim_close): Remove it.
	* target.c (generic_mourn_inferior): If inferior_ptid is not
	null_ptid, remove the corresponding inferior from inferior list.
	* win32-nat.c (do_initial_win32_stuff): Add process to inferior list.
	(win32_detach): Remove it.
	* linux-nat.c (linux_child_follow_fork): Delete and add inferiors
	to inferior list accordingly.
	* fork-child.c (fork_inferior): Add process to inferior list.
	* corelow.c (CORELOW_PID): Define.
	(core_close): Remove core from inferior list.
	(core_open): Add it.
@
text
@d1711 2
a1712 1
      int saved_signo = target_signal_from_host (WSTOPSIG (lp->status));
d1714 8
a1721 1
      if (signal_stop_state (saved_signo) == 0
d2937 1
d2939 7
a2945 2
      /* If we get a signal while single-stepping, we may need special
	 care, e.g. to skip the signal handler.  Defer to common code.  */
d2947 1
@


1.103
log
@gdb/
	* linux-nat.c (linux_nat_wait): Only use set_ignore_sigint in
	all-stop mode.

gdb/testsuite/
	* lib/mi-support.exp (mi_expect_interrupt): New.
	(mi_reverse_list, mi_check_thread_states): New, moved and renamed
	from gdb.mi/mi-nonstop.exp.
	* gdb.mi/mi-nsintrall.exp, gdb.mi/nsintrall.c: New.
	* gdb.mi/mi-nonstop.exp (myreverse, check_thread_states): Moved to
	lib/mi-support.exp.
	Use mi_check_thread_states throughout.  Avoid ".*" and do not
	require an anchor after -exec-run.
@
text
@d714 4
d829 4
a832 1
	linux_parent_pid = parent_pid;
d846 1
@


1.102
log
@	Remove the global stop_signal in favour of a per-thread
	stop_signal.

	* inferior.h (stop_signal): Delete.
	* gdbthread.h (save_infrun_state, load_infrun_state): Remove
	stop_signal argument.
	* thread.c (load_infrun_state, save_infrun_state): Remove
	stop_signal argument.  Don't reference it.

	* infcmd.c (stop_signal): Delete.
	(program_info): Adjust.
	* infrun.c (resume): Clear stop_signal.
	(proceed): Adjust.  Pass the last stop_signal to the thread we're
	resuming.
	(context_switch): Don't context-switch stop_signal.
	(handle_inferior_event, keep_going): Adjust.
	(save_inferior_status, restore_inferior_status): Adjust.

	* fbsd-nat.c: Include "gdbthread.h".
	(find_signalled_thread, find_stop_signal): New.
	(fbsd_make_corefile_notes): Use it.
	* fork-child.c (startup_inferior): Adjust.

	* linux-nat.c (get_pending_status): Adjust.
	(linux_nat_do_thread_registers): Adjust.
	(find_signalled_thread, find_stop_signal): New.
	(linux_nat_do_thread_registers): Add stop_signal parameter.
	(struct linux_nat_corefile_thread_data): Add stop_signal member.
	(linux_nat_corefile_thread_callback): Pass stop_signal.
	(linux_nat_do_registers): Delete.
	(linux_nat_make_corefile_notes): Use find_stop_signal.  Assume
	there's always a thread.

	* procfs.c (find_signalled_thread, find_stop_signal): New.
	(find_stop_signal): New.
	(procfs_do_thread_registers): Add stop_signal parameter.
	(struct procfs_corefile_thread_data): Add stop_signal member.
	(procfs_corefile_thread_callback): Pass args->stop_signal.
	(procfs_make_note_section): Find the last stop_signal.

	* solib-irix.c: Include gdbthread.h.
	(irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c: Include gdbthread.h.
	(osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c: Include gdbthread.h.
	(sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c: Include gdbthread.h.
	(svr4_solib_create_inferior_hook): Adjust.

	* win32-nat.c (do_initial_win32_stuff): Adjust.
@
text
@d2949 1
a2949 1
      if (signo == TARGET_SIGNAL_INT && signal_pass_state (signo) == 0)
d2951 15
a2965 7
	  /* If ^C/BREAK is typed at the tty/console, SIGINT gets
	     forwarded to the entire process group, that is, all LWPs
	     will receive it - unless they're using CLONE_THREAD to
	     share signals.  Since we only want to report it once, we
	     mark it as ignored for all LWPs except this one.  */
	  iterate_over_lwps (set_ignore_sigint, NULL);
	  lp->ignore_sigint = 0;
a2966 2
      else
	maybe_clear_ignore_sigint (lp);
@


1.101
log
@	Remove context switching in favour of accessing thread_info fields
	directly.

	* infrun.c (stepping_over_breakpoint, step_resume_breakpoint):
	Delete.
	(struct thread_stepping_state): Delete.
	(gtss, tss): Delete.
	(follow_inferior_reset_breakpoints, follow_exec)
	(resume, clear_proceed_status): Adjust.
	(prev_pc): Delete.
	(proceed, start_remote, init_wait_for_inferior): Adjust.
	(struct execution_control_state): Add event_thread member.
	(delete_step_resume_breakpoint_callback)
	(delete_step_thread_step_resume_breakpoint)
	(delete_step_thread_step_resume_breakpoint_cleanup)
	(delete_step_thread_step_resume_breakpoint): New.
	(wait_for_inferior, init_execution_control_state): Use
	delete_step_thread_step_resume_breakpoint_cleanup.
	(wait_for_inferior): Set the event_thread.
	(fetch_inferior_event): Ditto.  Delete the step-resume breakpoint
	with delete_step_thread_step_resume_breakpoint.
	(init_thread_stepping_state): Change parameter type to
	thread_info.  Adjust.
	(context_switch): Don't context switch prev_pc,
	stepping_over_breakpoint, step_resume_breakpoint,
	step_range_start, step_range_end, step_frame_id,
	tss->stepping_over_breakpoint,
	tss->stepping_through_solib_after_catch,
	tss->stepping_through_solib_catchpoints, tss->current_line, or
	tss->current_symtab.
	(adjust_pc_after_break, handle_inferior_event)
	(currently_stepping, step_into_function)
	(insert_step_resume_breakpoint_at_sal)
	(insert_longjmp_resume_breakpoint, keep_going): Adjust.
	(clear_stepping_state): New.
	(normal_stop): Adjust.
	(save_inferior_status, restore_inferior_status): Adjust.

	* gdbthread.h (struct thread_info): Comments describing the
	members moved here.  Add step_after_step_resume_breakpoint.
	(delete_step_resume_breakpoint): Add thread_info argument.
	(save_infrun_state, load_infrun_state): Remove prev_pc,
	trap_expected, step_resume_breakpoint, step_range_start,
	step_range_end, step_frame_id, another_trap,
	stepping_through_solib_after_catch,
	stepping_through_solib_catchpoints, current_line and
	current_symtab function arguments.
	(inferior_thread): Declare.

	* thread.c (inferior_thread): New.
	(delete_step_resume_breakpoint): Add a thread_info parameter and
	rewrite.
	(load_infrun_state, save_infrun_state): Remove prev_pc,
	trap_expected, step_resume_breakpoint, step_range_start,
	step_range_end, step_frame_id, stepping_over_breakpoint,
	stepping_through_solib_after_catch,
	stepping_through_solib_catchpoints, current_line and
	current_symtab args.  Remove code referencing them.

	* infcmd.c (step_range_start, step_range_end, step_frame_id):
	Delete.
	(step_1, step_once, until_next_command): Adjust.

	* inferior.h (step_range_start, step_range_end, step_frame_id):
	Delete.

	* linux-nat.c (linux_child_follow_fork): If following the child,
	move the step state to it.  Adjust.
	* inf-ptrace.c (inf_ptrace_follow_fork): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork): Ditto.
@
text
@d1456 1
a1456 3
	     thread_info->stop_signal, unless this is inferior_ptid,
	     in which case, it's in the global stop_signal, due to
	     context switching.  */
d1458 2
a1459 8
	  if (ptid_equal (lp->ptid, inferior_ptid))
	    signo = stop_signal;
	  else
	    {
	      struct thread_info *tp = find_thread_pid (lp->ptid);
	      gdb_assert (tp);
	      signo = tp->stop_signal;
	    }
d1487 4
a1490 3
	  if (stop_signal != TARGET_SIGNAL_0
	      && signal_pass_state (stop_signal))
	    *status = W_STOPCODE (target_signal_to_host (stop_signal));
d3334 22
d3361 2
a3362 1
			       char *note_data, int *note_size)
d3457 1
d3471 2
a3472 1
						   args->note_size);
a3477 13
/* Records the register state for the corefile note section.  */

static char *
linux_nat_do_registers (bfd *obfd, ptid_t ptid,
			char *note_data, int *note_size)
{
  return linux_nat_do_thread_registers (obfd,
					ptid_build (ptid_get_pid (inferior_ptid),
						    ptid_get_pid (inferior_ptid),
						    0),
					note_data, note_size);
}

d3524 1
d3526 2
a3527 11
  if (thread_args.num_notes == 0)
    {
      /* iterate_over_threads didn't come up with any threads; just
         use inferior_ptid.  */
      note_data = linux_nat_do_registers (obfd, inferior_ptid,
					  note_data, note_size);
    }
  else
    {
      note_data = thread_args.note_data;
    }
@


1.100
log
@	* inf-ptrace.c: Include "gdbthread.h".
	(inf_ptrace_attach): Add the main thread here.
	* linux-nat.c (linux_nat_attach): Don't add the main thread here.
	Decorate the main thread id with the lwp id.
@
text
@d777 2
d781 10
d847 6
@


1.99
log
@	* linux-nat.c (linux_nat_wait): Update inferior_ptid's ptid with
	thread_change_ptid.  Don't add or mark the main thread as running
	and executing here.
	* fork-child.c (fork_inferior): Add the main thread here.
@
text
@d1348 1
d1363 5
d1369 1
a1369 2
  inferior_ptid = BUILD_LWP (GET_PID (inferior_ptid), GET_PID (inferior_ptid));
  lp = add_lwp (inferior_ptid);
a1374 4
  /* If this process is not using thread_db, then we still don't
     detect any other threads, but add at least this one.  */
  add_thread_silent (lp->ptid);

@


1.98
log
@	Make sure target supports non-stop.
        * infcmd.c (run_command_1, attach_command): If non-stop mode
        is requested, verify the target supports it.
        * linux-nat.c (linux_nat_supports_non_stop): New.
        (linux_nat_add_target): Register the above.
        * target.c (find_default_supports_non_stop)
        (target_supports_non_stop): New.
        (init_dummy_target): Register find_default_supports_non_stop.
        * target.h (struct target_ops): New field to_supports_non_stop.
        (target_supports_non_stop): New.
@
text
@d2722 5
a2726 2
      inferior_ptid = BUILD_LWP (GET_PID (inferior_ptid),
				 GET_PID (inferior_ptid));
a2728 4
      /* Add the main thread to GDB's thread list.  */
      add_thread_silent (lp->ptid);
      set_running (lp->ptid, 1);
      set_executing (lp->ptid, 1);
@


1.97
log
@	* target.c (target_async_permitted, target_async_permitted_1)
        (set_maintenance_target_async_permitted)
        (show_maintenance_target_async_permitted): New.
        (initialize_targets): Register 'set target-async'.
        * target.h (target_async_permitted): Declare.
        * linux-nat.c (linux_nat_async_enabled)
        (linux_nat_async_permitted, set_maintenance_linux_async_permitted)
        (show_maintenance_linux_async_permitted): Remove.
        (sigchld_handler, linux_nat_is_async_p, linux_nat_can_async_p)
        (get_pending_events, linux_nat_async): Use target_async_permitted.
        (linux_nat_set_async_mode): Remove, moving the only used bits
        into...
        (linux_nat_setup_async): This.
        (_initialize_linux_nat): Do not register 'maint set linux-async'.
        Use linux_nat_setup_async.
        * remote.c (remote_async_permitted, remote_async_permitted_set)
        (set_maintenance_remote_async_permitted)
        (show_maintenance_remote_async_permitted): Remove.
        (remote_open_1, remote_terminal_inferior, remote_can_async_p)
        (remote_is_async_p): Use target_async_permitted.
        (_initialize_remote): Don't register 'main set remote-async'.
        * mi/mi-cmds.c (mi_cmds): Register -list-target-features.
        * mi/mi-cmds.h (mi_cmd_list_target_features): New.
        * mi/mi-main.c (mi_cmd_list_target_features): New.
@
text
@d4021 6
d4383 1
@


1.96
log
@	* linux-nat.c (resume_callback): Add more debugging output.
	(linux_nat_has_pending_sigint): New function, based on
	linux_nat_has_pending.
	(set_ignore_sigint, maybe_clear_ignore_sigint): New functions.
	(stop_wait_callback): Remove flush_mask handling.  Honor
	ignore_sigint.  Call maybe_clear_ignore_sigint.  Pass NULL
	to recursive calls.
	(linux_nat_has_pending, flush_callback): Remove.
	(linux_nat_filter_event): Check for ignore_sigint.
	(linux_nat_wait): Remove flush_mask support and call to
	flush_callback.  Use set_ignore_sigint and maybe_clear_ignore_sigint.
	* linux-nat.h (struct lwp_info): Add ignore_sigint field.

	* gdb.threads/manythreads.exp: Use remote_expect instead of after.
	Add a test for duplicated SIGINTs.
@
text
@a278 3
/* True if async mode is currently on.  */
static int linux_nat_async_enabled;

d3205 1
a3205 1
  if (linux_nat_async_enabled
a3991 30
/* Controls if async mode is permitted.  */
static int linux_async_permitted = 0;

/* The set command writes to this variable.  If the inferior is
   executing, linux_nat_async_permitted is *not* updated.  */
static int linux_async_permitted_1 = 0;

static void
set_maintenance_linux_async_permitted (char *args, int from_tty,
			       struct cmd_list_element *c)
{
  if (target_has_execution)
    {
      linux_async_permitted_1 = linux_async_permitted;
      error (_("Cannot change this setting while the inferior is running."));
    }

  linux_async_permitted = linux_async_permitted_1;
  linux_nat_set_async_mode (linux_async_permitted);
}

static void
show_maintenance_linux_async_permitted (struct ui_file *file, int from_tty,
			    struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("\
Controlling the GNU/Linux inferior in asynchronous mode is %s.\n"),
		    value);
}

d3998 1
a3998 1
     it explicitly with the "maintenance set linux-async" command.
d4000 1
a4000 1
  if (!linux_async_permitted)
d4012 1
a4012 1
     it explicitly with the "maintenance set linux-async" command.
d4014 1
a4014 1
  if (!linux_async_permitted)
d4095 1
a4095 1
  if (!linux_nat_async_enabled
d4299 1
a4299 1
  if (linux_nat_async_mask_value == 0 || !linux_nat_async_enabled)
a4322 29
/* Enable/Disable async mode.  */

static void
linux_nat_set_async_mode (int on)
{
  if (linux_nat_async_enabled != on)
    {
      if (on)
	{
	  gdb_assert (waitpid_queue == NULL);
	  if (pipe (linux_nat_event_pipe) == -1)
	    internal_error (__FILE__, __LINE__,
			    "creating event pipe failed.");
	  fcntl (linux_nat_event_pipe[0], F_SETFL, O_NONBLOCK);
	  fcntl (linux_nat_event_pipe[1], F_SETFL, O_NONBLOCK);
	}
      else
	{
	  drain_queued_events (-1);
	  linux_nat_num_queued_events = 0;
	  close (linux_nat_event_pipe[0]);
	  close (linux_nat_event_pipe[1]);
	  linux_nat_event_pipe[0] = linux_nat_event_pipe[1] = -1;

	}
    }
  linux_nat_async_enabled = on;
}

d4419 12
a4462 10
  add_setshow_boolean_cmd ("linux-async", class_maintenance,
			   &linux_async_permitted_1, _("\
Set whether gdb controls the GNU/Linux inferior in asynchronous mode."), _("\
Show whether gdb controls the GNU/Linux inferior in asynchronous mode."), _("\
Tells gdb whether to control the GNU/Linux inferior in asynchronous mode."),
			   set_maintenance_linux_async_permitted,
			   show_maintenance_linux_async_permitted,
			   &maintenance_set_cmdlist,
			   &maintenance_show_cmdlist);

d4494 1
a4494 2
  /* Install the default mode.  */
  linux_nat_set_async_mode (linux_async_permitted);
@


1.95
log
@	* linux-nat.c (count_events_callback, select_event_lwp_callback): Only
	report events from resumed threads.

	* gdb.threads/schedlock.exp (get_args): Update to work for any
	value of NUM.
	(Top level): Report the number of threads that did not resume.
@
text
@d1606 6
d2045 56
a2100 2
/* Wait until LP is stopped.  If DATA is non-null it is interpreted as
   a pointer to a set of signals to be flushed immediately.  */
a2104 2
  sigset_t *flush_mask = data;

d2113 2
a2114 2
      /* Ignore any signals in FLUSH_MASK.  */
      if (flush_mask && sigismember (flush_mask, WSTOPSIG (status)))
d2116 1
a2116 5
	  if (!lp->signalled)
	    {
	      lp->stopped = 1;
	      return 0;
	    }
d2122 1
a2122 1
				"PTRACE_CONT %s, 0, 0 (%s)\n",
d2126 1
a2126 1
	  return stop_wait_callback (lp, flush_mask);
d2129 2
d2167 1
a2167 1
	      stop_wait_callback (lp, data);
d2228 1
a2228 1
	      stop_wait_callback (lp, data);
a2260 90
/* Check whether PID has any pending signals in FLUSH_MASK.  If so set
   the appropriate bits in PENDING, and return 1 - otherwise return 0.  */

static int
linux_nat_has_pending (int pid, sigset_t *pending, sigset_t *flush_mask)
{
  sigset_t blocked, ignored;
  int i;

  linux_proc_pending_signals (pid, pending, &blocked, &ignored);

  if (!flush_mask)
    return 0;

  for (i = 1; i < NSIG; i++)
    if (sigismember (pending, i))
      if (!sigismember (flush_mask, i)
	  || sigismember (&blocked, i)
	  || sigismember (&ignored, i))
	sigdelset (pending, i);

  if (sigisemptyset (pending))
    return 0;

  return 1;
}

/* DATA is interpreted as a mask of signals to flush.  If LP has
   signals pending, and they are all in the flush mask, then arrange
   to flush them.  LP should be stopped, as should all other threads
   it might share a signal queue with.  */

static int
flush_callback (struct lwp_info *lp, void *data)
{
  sigset_t *flush_mask = data;
  sigset_t pending, intersection, blocked, ignored;
  int pid, status;

  /* Normally, when an LWP exits, it is removed from the LWP list.  The
     last LWP isn't removed till later, however.  So if there is only
     one LWP on the list, make sure it's alive.  */
  if (lwp_list == lp && lp->next == NULL)
    if (!linux_nat_thread_alive (lp->ptid))
      return 0;

  /* Just because the LWP is stopped doesn't mean that new signals
     can't arrive from outside, so this function must be careful of
     race conditions.  However, because all threads are stopped, we
     can assume that the pending mask will not shrink unless we resume
     the LWP, and that it will then get another signal.  We can't
     control which one, however.  */

  if (lp->status)
    {
      if (debug_linux_nat)
	printf_unfiltered (_("FC: LP has pending status %06x\n"), lp->status);
      if (WIFSTOPPED (lp->status) && sigismember (flush_mask, WSTOPSIG (lp->status)))
	lp->status = 0;
    }

  /* While there is a pending signal we would like to flush, continue
     the inferior and collect another signal.  But if there's already
     a saved status that we don't want to flush, we can't resume the
     inferior - if it stopped for some other reason we wouldn't have
     anywhere to save the new status.  In that case, we must leave the
     signal unflushed (and possibly generate an extra SIGINT stop).
     That's much less bad than losing a signal.  */
  while (lp->status == 0
	 && linux_nat_has_pending (GET_LWP (lp->ptid), &pending, flush_mask))
    {
      int ret;
      
      errno = 0;
      ret = ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stderr,
			    "FC: Sent PTRACE_CONT, ret %d %d\n", ret, errno);

      lp->stopped = 0;
      stop_wait_callback (lp, flush_mask);
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stderr,
			    "FC: Wait finished; saved status is %d\n",
			    lp->status);
    }

  return 0;
}

d2626 30
a2713 1
  sigset_t flush_mask;
a2734 2
  sigemptyset (&flush_mask);

d2944 6
a2949 4
	     forwarded to the entire process group, that is, all LWP's
	     will receive it.  Since we only want to report it once,
	     we try to flush it from all LWPs except this one.  */
	  sigaddset (&flush_mask, SIGINT);
d2951 2
d2969 1
a2969 2
      iterate_over_lwps (stop_wait_callback, &flush_mask);
      iterate_over_lwps (flush_callback, &flush_mask);
@


1.94
log
@	Exited threads.

	* thread.c (enum thread_state): New.
	(thread_state main_thread_running): Delete, in favor of...
	(thread_state main_thread_state): ... this.  Update throughout.
	(clear_thread_inferior_resources): New, split from free_thread.
	(free_thread): Call clear_thread_inferior_resources.
	(init_thread_list): Set main thread to stopped state.
	(add_thread_silent): Take care of PTID reuses.
	(delete_thread): If deleting inferior_ptid or a thread with
	refcount > 0, mark it as exited, but still keep it in the list.
	Only notify of thread exits, if we haven't done so yet.
	(iterate_over_threads): Make it safe to delete threads while
	iterating over them.
	(do_captured_list_thread_ids): Don't account for exited threads.
	(thread_alive): Check for the THREAD_EXITED state, and don't set
	ptid to -1 on exited threads.
	(set_running): Update to account for extra possible states.
	(is_thread_state): New.
	(is_stopped, is_exited): New.
	(is_running): Implement in terms of is_thread_state.
	(any_running): Update.
	(print_thread_info): Update.  Account for exited threads.  Don't
	warn about missed frame restoring here, its done in the cleanup.
	(switch_to_thread): Don't read from a thread that has gone.
	(restore_current_thread): In non-stop mode, do a full context
	switch.
	(restore_selected_frame): Add a frame_level argument.  Rewrite.
	(struct current_thread_cleanup): Add selected_frame_level and
	was_stopped members.
	(do_restore_current_thread_cleanup): Check if thread was stopped
	and still is, and if the target has registers, stack and memory
	before restoring the selected frame.  Don't delete the cleanup
	argument here.
	(restore_current_thread_cleanup_dtor): New.
	(make_cleanup_restore_current_thread): Remove all arguments.
	Rewrite.
	(thread_apply_all_command): Update.  Prune threads.
	(thread_apply_command): Update.
	(thread_command): Account for currently selected exited thread.
	(do_captured_thread_select): Check for a running thread.  Prune
	threads.
	(_initialize_thread): Make "info threads", "thread", "thread
	apply", and "thread apply all" appliable without a selected thread.
	* gdbthread.h (struct thread_info): Replace running_ by state_.
	Add refcount.
	(is_exited, is_stopped): Declare.
	(make_cleanup_restore_current_thread): Remove all arguments.
	* infrun.c: Include "event-top.h".
	(fetch_inferior_event): In non-stop mode, restore selected thread
	and frame after handling the event and running breakpoint
	commands.  Display GDB prompt if needed.
	(normal_stop): In non-stop mode, don't print thread switching
	notice.
	* cli/cli-decode.c (set_cmd_no_selected_thread_ok)
	(get_cmd_no_selected_thread_ok): New.
	* cli/cli-decode.h (CMD_NO_SELECTED_THREAD_OK): New.
	(set_cmd_no_selected_thread_ok, get_cmd_no_selected_thread_ok):
	Declare.
	* cli/cli-cmds.c: Set "pwd", "help", "info", "show" as
	no-selected-thread ok.
	* top.c (execute_command): Check for non no-selected-thread-ok
	commands.
	* linux-nat.c (struct saved_ptids, threads_to_delete)
	(record_dead_thread, prune_lwps): Delete.
	(exit_lwp): Unconditionally delete thread.
	(linux_nat_resume): Remove prune_lwps call.
	* infcmd.c (proceed_thread_callback): Check if !is_stopped instead
	of is_running.  Adjust to make_cleanup_restore_current_thread
	interface change.
	* mi/mi-main.c (mi_cmd_execute): Only allow a few commands if the
	selected thread has exited.
	* inf-loop.c (inferior_event_handler): Don't display the prompt
	here.
	* varobj.c (c_value_of_root): Update.
	* defs.h (make_cleanup_dtor): Declare.
	* utils.c (make_cleanup_dtor): New.

	* Makefile.in (infrun.o): Depend on $(event_top_h).
@
text
@d2322 2
a2323 2
  /* Count only LWPs that have a SIGTRAP event pending.  */
  if (lp->status != 0
d2350 2
a2351 2
  /* Select only LWPs that have a SIGTRAP event pending. */
  if (lp->status != 0
@


1.94.2.1
log
@Add record target to GDB.
@
text
@a52 2
#include "record.h"

a508 101
extern struct bp_location *bp_location_chain;
static struct lwp_info * find_lwp_pid (ptid_t ptid);
static int
my_waitpid_record (int pid, int *status, int flags)
{
  int ret;
  struct bp_location *bl;
  struct breakpoint *b;
  CORE_ADDR pc;
  struct lwp_info *lp;

wait_begin:
  ret = my_waitpid (pid, status, flags);
  if (ret == -1)
    {
      return ret;
    }

  if (ret == 0)
    {
      goto wait_begin;
    }

  if (WIFSTOPPED (*status) && WSTOPSIG (*status) == SIGTRAP)
    {
      /* Check if there is a breakpoint */
      pc = 0;
      registers_changed ();
      for (bl = bp_location_chain; bl; bl = bl->global_next)
	{
	  b = bl->owner;
	  gdb_assert (b);
	  if (b->enable_state != bp_enabled
	      && b->enable_state != bp_permanent)
	    continue;
	  if (!pc)
	    {
	      pc = regcache_read_pc (get_thread_regcache (pid_to_ptid (ret)));
	    }
	  switch (b->type)
	    {
	    default:
	      if (bl->address == pc)
		{
		  goto out;
		}
	      break;

	    case bp_watchpoint:
	      /*XXX teawater: I still not very clear how to deal with it. */
	      goto out;
	      break;

	    case bp_catch_fork:
	      if (inferior_has_forked (inferior_ptid, &b->forked_inferior_pid))
		{
		  goto out;
		}
	      break;

	    case bp_catch_vfork:
	      if (inferior_has_vforked (inferior_ptid, &b->forked_inferior_pid))
		{
		  goto out;
		}
	      break;

	    case bp_catch_exec:
	      if (inferior_has_execd (inferior_ptid, &b->exec_pathname))
		{
		  goto out;
		}
	      break;

	    case bp_hardware_watchpoint:
	    case bp_read_watchpoint:
	    case bp_access_watchpoint:
	      if (STOPPED_BY_WATCHPOINT (0))
		{
		  goto out;
		}
	      break;
	    }
	}

      lp = find_lwp_pid (pid_to_ptid (ret));
      if (lp)
        lp->stopped = 1;

      /* record message */
      record_message (current_gdbarch);

      /* resume program */
      linux_ops->to_resume (pid_to_ptid (ret), 1, TARGET_SIGNAL_0);
      goto wait_begin;
    }

out:
  return ret;
}

d2846 1
a2846 10
	{
	  if (RECORD_IS_USED && !record_resume_step)
	    {
	      lwpid = my_waitpid_record (pid, &status, options);
	    }
	  else
	    {
	      lwpid = my_waitpid (pid, &status, options);
	    }
	}
@


1.94.2.2
log
@Add a element "to_support_record_wait" to target_ops.
Optimize infrun.c.
@
text
@a4570 3
  /* Point out that this target support record wait. */
  t->to_support_record_wait = 1;

@


1.94.2.3
log
@
	the insn number.
	(record_registers_change): Call function
	"record_check_insn_num" check the insn number. Increase
	"record_insn_num" if need.
	(record_xfer_partial): Call function "record_check_insn_num"
	check the insn number. Increase "record_insn_num" if need.

2008-08-10  Hui Zhu  <teawater@@gmail.com>

	Add the real beneath function pointers for record target.

	* Makefile.in: Add record.h to depend of target.c.
	* record.c (record_beneath_to_resume, record_beneath_to_wait,
	record_beneath_to_prepare_to_store,
	record_beneath_to_xfer_partial,
	record_beneath_to_insert_breakpoint,
	record_beneath_to_remove_breakpoint): New function pointers.
	The real beneath function pointers.
	(record_resume): Change "record_ops.beneath->to_resume" to
	"record_beneath_to_resume".
	(record_wait): Change "record_ops.beneath->to_wait" to
	"record_beneath_to_wait".
	(record_prepare_to_store): Change
	"record_ops.beneath->to_prepare_to_store" to
	"record_beneath_to_prepare_to_store".
	(record_xfer_partial): Change
	"record_ops.beneath->to_xfer_partial" to
	"record_beneath_to_xfer_partial".
	(record_insert_breakpoint): Change
	"record_ops.beneath->to_insert_breakpoint" to
	"record_beneath_to_insert_breakpoint".
	(record_remove_breakpoint): Change
	"record_ops.beneath->to_remove_breakpoint" to
	"record_beneath_to_remove_breakpoint".
	* record.h (record_beneath_to_resume,
	record_beneath_to_wait,
	record_beneath_to_prepare_to_store,
	record_beneath_to_xfer_partial,
	record_beneath_to_insert_breakpoint,
	record_beneath_to_remove_breakpoint): Extern.
	* target.c: Add include of "record.h".
	(update_current_target): Set the real beneath function
	pointers.
@
text
@a4128 1
  record_linux_async_permitted = linux_async_permitted;
@


1.94.2.4
log
@2008-10-02  Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_open): Call target_can_async_p() instead
	of relying on a global variable.
	* record.h (record_linux_async_permitted): Delete.
	* linux-nat.c (record_linux_async_permitted): Delete reference.
@
text
@d4129 1
@


1.93
log
@	Non-stop linux native.

	* linux-nat.c (linux_test_for_tracefork): Block events while we're
	here.
	(get_pending_status): Implement non-stop mode.
	(linux_nat_detach): Stop threads before detaching.
	(linux_nat_resume): In non-stop mode, always resume only a single
	PTID.
	(linux_handle_extended_wait): On a clone event, in non-stop mode,
	add new lwp to GDB's thread table, and mark as running, executing
	and stopped appropriately.
	(linux_nat_filter_event): Don't assume there are other running
	threads when a thread exits.
	(linux_nat_wait): Mark the main thread as running and executing.
	In non-stop mode, don't stop all lwps.
	(linux_nat_kill): Stop lwps before killing them.
	(linux_nat_thread_alive): Use signal 0 to detect if a thread is
	alive.
	(send_sigint_callback): New.
	(linux_nat_stop): New.
	(linux_nat_add_target): Set to_stop to linux_nat_stop.

	* linux-nat.h (thread_db_attach_lwp): Declare.

	* linux-thread-db.c (thread_get_info_callback): Check for new
	threads if we have none.
	(thread_from_lwp, enable_thread_event): Set proc_handle.pid to the
	stopped lwp.  Check for new threads if we have none.
	(thread_db_attach_lwp): New.
	(thread_db_init): Set proc_handle.pid to inferior_ptid.
	(check_event): Set proc_handle.pid to the stopped lwp.
	(thread_db_find_new_threads): Set proc_handle.pid to any stopped
	lwp available, bail out if there is none.

	* linux-fork.c (linux_fork_killall): Use SIGKILL instead of
	PTRACE_KILL.
@
text
@a1079 1
  init_thread_list ();
a1081 1
  add_thread_silent (new_ptid);
a1082 1
}
d1084 2
a1085 35
/* Record a PTID for later deletion.  */

struct saved_ptids
{
  ptid_t ptid;
  struct saved_ptids *next;
};
static struct saved_ptids *threads_to_delete;

static void
record_dead_thread (ptid_t ptid)
{
  struct saved_ptids *p = xmalloc (sizeof (struct saved_ptids));
  p->ptid = ptid;
  p->next = threads_to_delete;
  threads_to_delete = p;
}

/* Delete any dead threads which are not the current thread.  */

static void
prune_lwps (void)
{
  struct saved_ptids **p = &threads_to_delete;

  while (*p)
    if (! ptid_equal ((*p)->ptid, inferior_ptid))
      {
	struct saved_ptids *tmp = *p;
	delete_thread (tmp->ptid);
	*p = tmp->next;
	xfree (tmp);
      }
    else
      p = &(*p)->next;
d1100 1
a1100 5
      /* Core GDB cannot deal with us deleting the current thread.  */
      if (!ptid_equal (lp->ptid, inferior_ptid))
	delete_thread (lp->ptid);
      else
	record_dead_thread (lp->ptid);
a1637 2
  prune_lwps ();

@


1.92
log
@gdb/
	* NEWS (New commands): Mention "set disable-randomization".
	* configure.ac: Add check for HAVE_PERSONALITY and
	HAVE_DECL_ADDR_NO_RANDOMIZE.
	* configure, config.in: Regenerate.
	* linux-nat.c [HAVE_PERSONALITY]: New include <sys/personality.h>.
	[HAVE_PERSONALITY] [!HAVE_DECL_ADDR_NO_RANDOMIZE]: Set
	ADDR_NO_RANDOMIZE.
	(disable_randomization, show_disable_randomization)
	(set_disable_randomization): New.
	(linux_nat_create_inferior) [HAVE_PERSONALITY]: New variables
	PERSONALITY_ORIG and PERSONALITY_SET.  Disable randomization upon the
	variable DISABLE_RANDOMIZATION.
	(_initialize_linux_nat): Call ADD_SETSHOW_BOOLEAN_CMD for the variable
	DISABLE_RANDOMIZATION.

gdb/doc/
	* gdb.texinfo (Starting): Document "set disable-randomization".

gdb/testsuite/
	* gdb.base/randomize.exp, gdb.base/randomize.c: New files.
@
text
@d322 3
d527 3
d560 1
d571 1
d611 2
d1454 2
a1455 1
  if (GET_LWP (lp->ptid) == GET_LWP (last_ptid))
d1457 57
a1513 3
      if (stop_signal != TARGET_SIGNAL_0
	  && signal_pass_state (stop_signal))
	*status = W_STOPCODE (target_signal_to_host (stop_signal));
a1514 2
  else if (target_can_async_p ())
    queued_waitpid (GET_LWP (lp->ptid), status, __WALL);
d1516 12
a1527 1
    *status = lp->status;
d1591 7
d1687 11
a1697 4
  if (resume_all)
    iterate_over_lwps (resume_set_callback, NULL);
  else
    iterate_over_lwps (resume_clear_callback, NULL);
d1707 1
d1858 2
d1863 1
d1880 28
a1907 3
	  if (stopping)
	    new_lp->stopped = 1;
	  else
d1909 1
d1911 1
a1911 2
	      ptrace (PTRACE_CONT,
		      PIDGET (lp->waitstatus.value.related_pid), 0,
d2648 1
a2648 7
	{
	  /* Make sure there is at least one thread running.  */
	  gdb_assert (iterate_over_lwps (running_callback, NULL));

	  /* Discard the event.  */
	  return NULL;
	}
d2778 2
d3007 4
a3010 2
  /* Now stop all other LWP's ...  */
  iterate_over_lwps (stop_callback, NULL);
d3012 12
a3023 10
  /* ... and wait until all of them have reported back that they're no
     longer running.  */
  iterate_over_lwps (stop_wait_callback, &flush_mask);
  iterate_over_lwps (flush_callback, &flush_mask);

  /* If we're not waiting for a specific LWP, choose an event LWP from
     among those that have had events.  Giving equal priority to all
     LWPs that have had events helps prevent starvation.  */
  if (pid == -1)
    select_event_lwp (&lp, &status);
d3155 7
d3214 2
d3218 5
a3222 2
  errno = 0;
  ptrace (PTRACE_PEEKUSER, GET_LWP (ptid), 0, 0);
d3225 1
a3225 1
			"LLTA: PTRACE_PEEKUSER %s, 0, 0 (%s)\n",
d3227 1
a3227 1
			errno ? safe_strerror (errno) : "OK");
d3229 1
a3229 6
  /* Not every Linux kernel implements PTRACE_PEEKUSER.  But we can
     handle that case gracefully since ptrace will first do a lookup
     for the process based upon the passed-in pid.  If that fails we
     will get either -ESRCH or -EPERM, otherwise the child exists and
     is alive.  */
  if (errno == ESRCH || errno == EPERM)
d4431 29
d4490 3
@


1.91
log
@	Adjust fork/vfork/exec to pass ptids around.

	* target.h (struct target_waitstatus): Store related_pid as a ptid.
	(inferior_has_forked, inferior_has_vforked, inferior_has_execd):
	Take a ptid_t.
	* breakpoint.h (struct breakpoint): Change forked_inferior_pid
	type to ptid.
	* breakpoint.c (print_it_typical, bpstat_check_location)
	(print_one_breakpoint_location, set_raw_breakpoint_without_location)
	(create_fork_vfork_event_catchpoint): Adjust.
	* infrun.c (fork_event): Change parent_pid and child_pid types to
	ptid.
	(follow_exec, inferior_has_forked, inferior_has_vforked)
	(inferior_has_execd): Take a ptid_t and don't trim it.
	* linux-thread-db.c (thread_db_wait): Don't trim the returned ptid.
	* linux-nat.c (linux_child_follow_fork): Adjust.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait): Adjust.
	* win32-nat.c (get_win32_debug_event): Don't set related_pid.
@
text
@d53 7
d230 27
d1316 3
d1342 17
d1361 11
d4446 11
@


1.90
log
@	Add "executing" property to threads.

	* inferior.h (target_executing): Delete.
	* gdbthread.h (struct thread_info): Add executing_ field.
	(set_executing, is_executing): New.
	* thread.c (main_thread_executing): New.
	(init_thread_list): Clear it and also main_thread_running.
	(is_running): Return false if target has no execution.
	(any_running, is_executing, set_executing): New.

	* top.c: Include "gdbthread.h".
	(target_executing): Delete.
	(execute_command): Replace target_executing check by any_running.
	* event-top.c: Include "gdbthread.h".
	(display_gdb_prompt, command_handler): Replace target_executing by
	is_running.
	* inf-loop.c: Include "gdbthread.h".  Don't mark as not executing
	here.  Replace target_executing by is_running.
	* infrun.c (handle_inferior_event): Mark all threads as
	not-executing.
	* linux-nat.c (linux_nat_resume): Don't mark thread as executing
	here.
	* stack.c (get_selected_block): Return null if inferior is
	executing.
	* target.c (target_resume): Mark resumed ptid as executing.
	* breakpoint.c (until_break_command): Replace target_executing
	check by is_executing.
	* remote.c (remote_async_resume): Don't mark inferior as executing
	here.
	* mi/mi-interp.c (mi_cmd_interpreter_exec): Replace target_executing
	by any_running.

	* mi/mi-main.c (mi_cmd_exec_interrupt, mi_cmd_execute)
	(mi_execute_async_cli_command): Replace target_executing by
	is_running.

	* frame.c (get_current_frame): Error out if the current thread is
	executing.
	(has_stack_frames): New.
	(get_selected_frame, deprecated_safe_get_selected_frame): Check
	has_stack_frames.

	* Makefile.in (event-top.o, frame.o, inf-loop.o, top.o): Depend on
	$(gdbthread_h).
@
text
@d644 1
a644 1
  child_pid = last_status.value.related_pid;
d1696 1
a1696 1
      ourstatus->value.related_pid = new_pid;
d1728 2
a1729 1
	      ptrace (PTRACE_CONT, lp->waitstatus.value.related_pid, 0,
d2962 1
a2962 1
      ptrace (PT_KILL, last.value.related_pid, 0, 0);
@


1.89
log
@	* breakpoint.c (mark_breakpoints_out): Make public.
	(update_breakpoints_after_exec): Don't call mark_breakpoints_out
	here.  Update comment.
	* breakpoint.h (mark_breakpoints_out): Declare.

	* linux-nat.c (linux_handle_extended_wait): On
	TARGET_WAITKIND_EXECD, call mark_breakpoints_out.
	* inf-ttrace.c (inf_ttrace_wait): Likewise.
@
text
@d1627 1
a1627 4
    {
      target_executing = 1;
      target_async (inferior_event_handler, 0);
    }
@


1.88
log
@gdb/
2008-06-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-nat.c (enum sigchld_state): New.
	(linux_nat_async_events_state): Renamed from
	linux_nat_async_events_enabled.
	(linux_nat_event_pipe_push, my_waitpid): Adjust.
	(sigchld_default_action): New.
	(lin_lwp_attach_lwp): Adjust.  Call linux_nat_async_events
	unconditionally.
	(linux_nat_create_inferior): Set events state to sigchld_default
	state.
	(linux_nat_resume): Adjust.
	(linux_nat_wait): Call linux_nat_async_events unconditionally.
	(sigchld_handler): Adjust.
	(linux_nat_async_mask): Don't set SIGCHLD actions here.
	(get_pending_events): Adjust.
	(linux_nat_async_events): Rewrite to handle enum sigchld_state
	instead of a boolean.
	(linux_nat_async): Adjust.
	(_initialize_linux_nat): Capture default SIGCHLD action into
	sigchld_default_action.

gdb/testsuite/
2008-06-28  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.base/sigchld.c, gdb.base/sigchld.exp: New test.
@
text
@d1761 10
@


1.87
log
@	* linux-nat.c: Add description of overall logic.
@
text
@d259 1
a259 3
/* If async mode is on, true if we're listening for events; false if
   target events are blocked.  */
static int linux_nat_async_events_enabled;
d261 16
a276 1
static int linux_nat_async_events (int enable);
d310 2
a311 2
QWPID: linux_nat_async_events_enabled(%d), linux_nat_num_queued_events(%d)\n",
			linux_nat_async_events_enabled,
d457 1
a457 1
  gdb_assert (!linux_nat_async_events_enabled);
d878 3
d1204 1
a1204 1
  int async_events_were_enabled = 0;
d1208 1
a1208 2
  if (target_can_async_p ())
    async_events_were_enabled = linux_nat_async_events (0);
d1273 1
a1273 3
  if (async_events_were_enabled)
    linux_nat_async_events (1);

d1287 2
d1299 6
d1536 1
a1536 1
    linux_nat_async_events (0);
d2598 2
a2599 3
  if (target_can_async_p ())
    /* Block events while we're here.  */
    target_async (NULL, 0);
d3058 1
a3058 1
      && linux_nat_async_events_enabled
a3916 4
	  /* We're in sync mode.  Make sure SIGCHLD isn't handled by
	     async_sigchld_handler when we come out of sigsuspend in
	     linux_nat_wait.  */
	  sigaction (SIGCHLD, &sync_sigchld_action, NULL);
a3919 2
	  /* Restore the async handler.  */
	  sigaction (SIGCHLD, &async_sigchld_action, NULL);
d3977 2
a3978 1
  if (!linux_nat_async_enabled || !linux_nat_async_events_enabled)
d4032 1
a4032 1
/* Enable or disable async SIGCHLD handling.  */
d4034 2
a4035 2
static int
linux_nat_async_events (int enable)
d4037 1
a4037 1
  int current_state = linux_nat_async_events_enabled;
d4041 1
a4041 1
			"LNAE: enable(%d): linux_nat_async_events_enabled(%d), "
d4043 1
a4043 1
			enable, linux_nat_async_events_enabled,
d4046 1
a4046 1
  if (current_state != enable)
d4051 8
a4058 1
      if (enable)
d4060 15
a4074 2
	  /* Unblock target events.  */
	  linux_nat_async_events_enabled = 1;
d4076 25
a4100 14
	  local_event_queue_to_pipe ();
	  /* While in masked async, we may have not collected all the
	     pending events.  Get them out now.  */
	  get_pending_events ();
	  sigprocmask (SIG_UNBLOCK, &mask, NULL);
	}
      else
	{
	  /* Block target events.  */
	  sigprocmask (SIG_BLOCK, &mask, NULL);
	  linux_nat_async_events_enabled = 0;
	  /* Get events out of queue, and make them available to
	     queued_waitpid / my_waitpid.  */
	  pipe_to_local_event_queue ();
d4192 1
a4192 1
      linux_nat_async_events (1);
d4199 1
a4199 1
      linux_nat_async_events (0);
a4214 2
	  sigaction (SIGCHLD, &async_sigchld_action, NULL);

a4217 1

a4222 2
	  sigaction (SIGCHLD, &sync_sigchld_action, NULL);

a4223 1

d4340 4
@


1.86
log
@
	* gdbarch.sh: Added new gdbarch struct
	core_regset_sections.
	* gdbarch.c: Refreshed.
	* gdbarch.h: Refreshed.
	* regset.h (core_regset_section): Declared.
	* linux-nat.c (linux_nat_do_thread_registers): Added
	support for the new gdbarch struct core_regset_sections.
	* utils.c (host_address_to_string): New function.
	* defs.h (host_address_to_string): New prototype.
	* i386-linux-tdep.c (i386_regset_rections): New register
	sections list for i386.
	  (i386_linux_init_abi): Initialized new gdbarch struct
	  core_regset_sections.
	* Makefile.in: Updated to reflect dependency changes.
	* ppc-linux-tdep.c (ppc_regset_sections): Register
	sections list for ppc.
	  (ppc_linux_init_abi): Initialized new gdbarch struct
	  core_regset_sections
@
text
@d53 1
a53 1
/* Note on this file's use of signals:
d55 92
a146 21
   We stop threads by sending a SIGSTOP.  The use of SIGSTOP instead
   of another signal is not entirely significant; we just need for a
   signal to be delivered, so that we can intercept it.  SIGSTOP's
   advantage is that it can not be blocked.  A disadvantage is that it
   is not a real-time signal, so it can only be queued once; we do not
   keep track of other sources of SIGSTOP.

   Two other signals that can't be blocked are SIGCONT and SIGKILL.
   But we can't use them, because they have special behavior when the
   signal is generated - not when it is delivered.  SIGCONT resumes
   the entire thread group and SIGKILL kills the entire thread group.

   A delivered SIGSTOP would stop the entire thread group, not just the
   thread we tkill'd.  But we never let the SIGSTOP deliver; we always
   intercept and cancel it (by PTRACE_CONT without passing SIGSTOP).

   We could use a real-time signal instead.  This would solve those
   problems; we could use PTRACE_GETSIGINFO to locate the specific
   stop signals sent by GDB.  But we would still have to have some
   support for SIGSTOP, since PTRACE_ATTACH generates it, and there
   are races with trying to find a signal that is not blocked.  */
a244 11
/* To listen to target events asynchronously, we install a SIGCHLD
   handler whose duty is to call waitpid (-1, ..., WNOHANG) to get all
   the pending events into a pipe.  Whenever we're ready to handle
   events asynchronously, this pipe is registered as the waitable file
   handle in the event loop.  When we get to entry target points
   coming out of the common code (target_wait, target_resume, ...),
   that are going to call waitpid, we block SIGCHLD signals, and
   remove all the events placed in the pipe into a local queue.  All
   the subsequent calls to my_waitpid (a waitpid wrapper) check this
   local queue first.  */

a852 11
/* Since we cannot wait (in linux_nat_wait) for the initial process and
   any cloned processes with a single call to waitpid, we have to use
   the WNOHANG flag and call waitpid in a loop.  To optimize
   things a bit we use `sigsuspend' to wake us up when a process has
   something to report (it will send us a SIGCHLD if it has).  To make
   this work we have to juggle with the signal mask.  We save the
   original signal mask such that we can restore it before creating a
   new process in order to avoid blocking certain signals in the
   inferior.  We then block SIGCHLD during the waitpid/sigsuspend
   loop.  */

@


1.85
log
@	* linux-nat.c (trap_ptid): Delete.
	(linux_nat_detach, linux_nat_wait, linux_nat_mourn_inferior):
	Adjust.
	* linux-thread-db.c (thread_db_wait): Adjust.
@
text
@a3114 3
#ifdef FILL_FPXREGSET
  gdb_fpxregset_t fpxregs;
#endif
d3121 2
d3130 2
d3147 33
a3179 6
  if (core_regset_p
      && (regset = gdbarch_regset_from_core_section (gdbarch, ".reg2",
						     sizeof (fpregs))) != NULL
      && regset->collect_regset != NULL)
    regset->collect_regset (regset, regcache, -1,
			    &fpregs, sizeof (fpregs));
d3181 9
a3189 1
    fill_fpregset (regcache, &fpregs, -1);
d3191 5
a3195 4
  note_data = (char *) elfcore_write_prfpreg (obfd,
					      note_data,
					      note_size,
					      &fpregs, sizeof (fpregs));
a3196 15
#ifdef FILL_FPXREGSET
  if (core_regset_p
      && (regset = gdbarch_regset_from_core_section (gdbarch, ".reg-xfp",
						     sizeof (fpxregs))) != NULL
      && regset->collect_regset != NULL)
    regset->collect_regset (regset, regcache, -1,
			    &fpxregs, sizeof (fpxregs));
  else
    fill_fpxregset (regcache, &fpxregs, -1);

  note_data = (char *) elfcore_write_prxfpreg (obfd,
					       note_data,
					       note_size,
					       &fpxregs, sizeof (fpxregs));
#endif
@


1.84
log
@	* inferior.h (read_pc_pid, write_pc_pid): Remove.
	* regcache.h (regcache_read_pc, regcache_write_pc): Add prototypes.

	* regcache.c (read_pc_pid): Remove, replace by ...
	(regcache_read_pc): ... this function.
	(write_pc_pid): Remove, replace by ...
	(regcache_write_pc): ... this function.
	(read_pc, write_pc): Update.

	* infrun.c (displaced_step_prepare): Replace read_pc_pid and
	write_pc_pid by regcache_read_pc and regcache_write_pc.
	(displaced_step_fixup): Likewise.
	(resume): Likewise.  Use regcache arch instead of current_gdbarch.
	(prepare_to_proceed): Likewise.
	(proceed): Likewise.
	(adjust_pc_after_break): Likewise.
	(handle_inferior_event): Likewise.

	* linux-nat.c (cancel_breakpoint): Likewise.
	* linux-thread-db.c (check_event): Likewise.
	* aix-thread.c (aix_thread_wait): Likewise.
	* tracepoint.c (trace_dump_command): Likewise.
@
text
@a792 5
/* If the last reported event was a SIGTRAP, this variable is set to
   the process id of the LWP/thread that got it.  */
ptid_t trap_ptid;


a1401 2
  trap_ptid = null_ptid;

a2772 1
      trap_ptid = lp->ptid;
d2775 2
a2776 2
			    "LLW: trap_ptid is %s.\n",
			    target_pid_to_str (trap_ptid));
a2777 2
  else
    trap_ptid = null_ptid;
a2908 2
  trap_ptid = null_ptid;

@


1.83
log
@2008-05-03  Pedro Alves  <pedro@@codesourcery.com>

	* thread.c (delete_thread): Call observer_notify_thread_exit.
        * mi/mi-interp.c (mi_interpreter_init): Register mi_thread_exit as
        thread_exit observer.
        (mi_thread_exit): New.
@
text
@d2160 6
a2165 3
  if (breakpoint_inserted_here_p (read_pc_pid (lp->ptid) -
				  gdbarch_decr_pc_after_break
				  (current_gdbarch)))
d2173 3
a2175 4
      if (gdbarch_decr_pc_after_break (current_gdbarch))
	write_pc_pid (read_pc_pid (lp->ptid) - gdbarch_decr_pc_after_break
		      (current_gdbarch),
		      lp->ptid);
@


1.82
log
@	* linux-nat.c (linux_nat_switch_fork): Reinit GDB's thread list
	and register the fork's PTID as a thread.
@
text
@d1025 3
a1027 1
  if (in_thread_list (lp->ptid))
@


1.81
log
@2008-05-01  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	Based on work by Jan Kratochvil <jan.kratochvil@@redhat.com> and Jeff
 	Johnston <jjohnstn@@redhat.com>.

	* NEWS: Mention attach to stopped process fix.
	* infcmd.c (detach_command, disconnect_command): Discard the thread
	list.
	* infrun.c (handle_inferior_event): Do not ignore non-SIGSTOP while
	attaching.  Use signal_stop_state.
	(signal_stop_state): Check stop_soon.
	* linux-nat.c (kill_lwp): Declare earlier.
	(pid_is_stopped, linux_nat_post_attach_wait): New.
	(lin_lwp_attach_lwp): Use linux_nat_post_attach_wait.  Update
	comments.
	(linux_nat_attach): Use linux_nat_post_attach_wait.
	(detach_callback, linux_nat_detach): Improve handling for signalled
	processes.
	(linux_nat_pid_to_str): Always print out the LWP ID if it differs
	from the process ID.
	* Makefile.in (infcmd.o): Update.

2008-05-01  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb.threads/attach-into-signal.c, gdb.threads/attach-into-signal.exp,
	gdb.threads/attach-stopped.c, gdb.threads/attach-stopped.exp,
	gdb.threads/attachstop-mt.c, gdb.threads/attachstop-mt.exp: New.
@
text
@d976 1
d979 1
@


1.80
log
@	* linux-nat.c (linux_nat_attach): Add the pid we attached to, to
	gdb's thread list.
	(linux_nat_wait): Add main lwp to gdb's thread list.
	* linux-thread-db.c (find_new_threads_callback): Also attach to
	already listed threads which thread_db didn't know about yet.
@
text
@d53 24
d213 1
d1038 97
a1134 4
/* Attach to the LWP specified by PID.  If VERBOSE is non-zero, print
   a message telling the user that a new LWP has been added to the
   process.  Return 0 if successful or -1 if the new LWP could not
   be attached.  */
d1157 1
a1157 3
      pid_t pid;
      int status;
      int cloned = 0;
d1176 6
a1181 2
      pid = my_waitpid (GET_LWP (ptid), &status, 0);
      if (pid == -1 && errno == ECHILD)
d1183 2
a1184 3
	  /* Try again with __WCLONE to check cloned processes.  */
	  pid = my_waitpid (GET_LWP (ptid), &status, __WCLONE);
	  cloned = 1;
d1187 1
a1187 10
      gdb_assert (pid == GET_LWP (ptid)
		  && WIFSTOPPED (status) && WSTOPSIG (status));

      if (lp == NULL)
	lp = add_lwp (ptid);
      lp->cloned = cloned;

      target_post_attach (pid);

      lp->stopped = 1;
a1245 1
  pid_t pid;
a1246 2
  int cloned = 0;
  int options = 0;
a1260 17
  /* Make sure the initial process is stopped.  The user-level threads
     layer might want to poke around in the inferior, and that won't
     work if things haven't stabilized yet.  */
  pid = my_waitpid (GET_PID (inferior_ptid), &status, options);
  if (pid == -1 && errno == ECHILD)
    {
      warning (_("%s is a cloned process"), target_pid_to_str (inferior_ptid));

      /* Try again with __WCLONE to check cloned processes.  */
      options = __WCLONE;
      pid = my_waitpid (GET_PID (inferior_ptid), &status, options);
      cloned = 1;
    }

  gdb_assert (pid == GET_PID (inferior_ptid)
	      && WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP);

d1264 4
a1267 1
  lp->cloned = cloned;
d1273 1
a1273 1
  lp->stopped = 1;
d1275 4
d1281 1
a1281 7
    {
      /* Fake the SIGSTOP that core GDB expects.  */
      lp->status = W_STOPCODE (SIGSTOP);
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LNA: waitpid %ld, faking SIGSTOP\n", (long) pid);
    }
d1287 2
a1288 1
      linux_nat_event_pipe_push (pid, status, options);
d1294 30
d1334 2
a1335 1
  while (lp->signalled && lp->stopped)
a1336 6
      errno = 0;
      if (ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0,
		  WSTOPSIG (lp->status)) < 0)
	error (_("Can't continue %s: %s"), target_pid_to_str (lp->ptid),
	       safe_strerror (errno));

d1339 2
a1340 3
			    "DC:  PTRACE_CONTINUE (%s, 0, %s) (OK)\n",
			    target_pid_to_str (lp->ptid),
			    status_to_str (lp->status));
d1342 1
a1342 1
      lp->stopped = 0;
a1343 9
      lp->status = 0;
      /* FIXME drow/2003-08-26: There was a call to stop_wait_callback
	 here.  But since lp->signalled was cleared above,
	 stop_wait_callback didn't do anything; the process was left
	 running.  Shouldn't we be waiting for it to stop?
	 I've removed the call, since stop_wait_callback now does do
	 something when called with lp->signalled == 0.  */

      gdb_assert (lp->status == 0 || WIFSTOPPED (lp->status));
d1350 5
d1357 1
a1357 1
		  WSTOPSIG (lp->status)) < 0)
a1366 1
      drain_queued_events (GET_LWP (lp->ptid));
d1377 3
d1388 15
d2980 3
a2982 1
  if (lwp_list && lwp_list->next && is_lwp (ptid))
a4338 1

@


1.79
log
@2008-03-25  Pedro Alves  <pedro@@codesourcery.com>

	* linux-nat.c (drain_queued_events): Fix comment typo.
	(linux_nat_attach): In async mode, don't rely on storing a pending
	status.  Instead place the wait status on the pipe.
	(linux_nat_resume): Remove unreacheable shortcut code in async
	mode.
	(stop_wait_callback): In async mode, don't store pending status.
	Instead, cancel breakpoints or resend the signal appropriatelly.
	(cancel_breakpoint): New, refactored from
	cancel_breakpoints_callback.
	(cancel_breakpoints_callback): Call cancel_breakpoint.
	(pipe_to_local_event_queue): Remove special token processing.
	(linux_nat_wait): Issue an internal error if a pending status is
	found in async mode.
@
text
@d1176 4
d2394 2
@


1.78
log
@gdb/
	* target.h (struct target_ops): Delete to_async_mask_value and add
	to_async_mask.
	(target_is_async_p, target_async): Formatting.
	(target_async_mask_value): Delete.
	(target_async_mask): Delete function declaration, and add new
	target macro with the same name.

	* target.c (update_current_target): Replace to_async_mask_value by
	to_async_mask.  Default to_async_mask to return_one.
	(target_async_mask): Delete.
	(find_default_can_async_p, find_default_is_async_p): New.
	(init_dummy_target): register find_default_can_async_p and
	find_default_is_async_p on the dummy target.

	* linux-nat.c: Include inf-loop.h, event-loop.h and event-top.h.
	(debug_linux_nat_async): New global.
	(show_debug_linux_nat_async): New function.
	(linux_nat_async_enabled, linux_nat_async_mask_value)
	(linux_nat_event_pipe, linux_nat_num_queued_events)
	(linux_nat_async_events_enabled): New globals.
	(struct waitpid_result): New struct.
	(waitpid_queue): New global.
	(queued_waitpid, push_waitpid, drain_queued_events): New.
	(my_waitpid): Call queued_waitpid.
	(linux_child_follow_fork): Disable async events during the call.
	(blocked_mask): Delete.
	(sync_sigchld_action, async_sigchld_action): New globals.
	(lin_lwp_attach_lwp): In sync mode, don't reblock SIGCHLD.  In
	async mode, block events during the call.
	(linux_nat_create_inferior): New.
	(linux_nat_attach): In sync mode, restore the mask states.  In
	async mode, wake the event loop immediatelly.
	(detach_callback): Drain all queued events of the lwp we're
	detaching from.
	(linux_nat_detach): Block async mode, and drain events of the main
	process.
	(linux_nat_resume): If in async mode, mask async events during the
	call.  If short circuiting, force event loop to wake up.  If
	resuming, set target_executing, and register target events in the
	event loop.
	(pipe_to_local_event_queue, local_event_queue_to_pipe): New.
	(linux_nat_wait): In async mode, block events during the call.
	Only enable/disable passing SIGINT to the inferior in sync mode.
	Get events from local waitpid queue.  If no interesting events was
	found, return to events loop.  Reregister target events in the
	event loop on exit.  In sync mode, no need to reblock SIGCHLD.
	(linux_nat_kill): Disable events on entry.
	(linux_nat_mourn_inferior): In sync mode, don't restore the masks
	here.  Detach async mode from the event loop if there are no more
	forks available, otherwise leave it on.
	(sigchld_handler): Assure this is called only in sync mode.
	(linux_async_permitted, linux_async_permitted_1): New globals.
	(set_maintenance_linux_async_permitted)
	(show_maintenance_linux_async_permitted): New functions.
	(linux_nat_is_async_p, linux_nat_can_async_p)
	(linux_nat_async_mask): New.
	(linux_nat_event_pipe_pop, linux_nat_event_pipe_push): New.
	(get_pending_events, async_sigchld_handler): New.
	(linux_nat_async_events): New.
	(async_terminal_is_ours): New global.
	(linux_nat_terminal_inferior, linux_nat_terminal_ours): New.
	(async_client_callback, async_client_context): New.
	(linux_nat_async_file_handler, linux_nat_async)
	(linux_nat_disable_async, linux_nat_enable_async): New.
	(linux_nat_add_target): Register linux_nat_create_inferior,
	linux_nat_can_async_p, linux_nat_is_async_p, linux_nat_async,
	linux_nat_async_mask, linux_nat_terminal_inferior and
	linux_nat_terminal_ours.
	(_initialize_linux_nat): Remove local action variable, and update
	code that used it to use sync_sigchld_action.  Add new
	"lin-lwp-async" debug set/show command.  Put the "lin-lwp" debug
	set/show command in the maintenance class.  Add new "linux-async"
	maintenance set/show command.  Block SIGCHLD by default.  Setup
	async_sichld_action, and sync_sigchld_action.  Install the default
	async mode.
	(lin_thread_get_thread_signals): Use a local sigset_t for blocking
	the cancel signals.

	* linux-thread-db.c (re_check_for_thread_db): New.
	(clear_lwpid_callback): Handle TARGET_WAITKIND_IGNORE.
	(thread_db_can_async_p, thread_db_is_async_p, thread_db_async)
	(thread_db_async_mask): New.
	(init_thread_db_ops): Register thread_db_can_async_p,
	thread_db_is_async_p, thread_db_async and thread_db_async_mask.

	* remote.c (remote_async_mask_value): New.
	(remote_return_zero): New.
	(init_remote_ops): Register remote_return_zero as callbacks of
	to_can_async_p and to_is_async_p.
	(remote_can_async_p, remote_is_async_p, remote_async): Update to
	use remote_async_mask_value.
	(remote_async_mask): New.
	(init_remote_async_ops): Remove to_async_mask_value setting and
	register remote_async_mask as to_async_mask callback in
	remote_async_ops.

	* Makefile.in (linux-nat.o): Update.

gdb/doc/
	* gdb.texinfo (Debugging Output): Document
	"set/show debug lin-lwp-async".
	(Maintenance Commands): Document "maint set/show linux-async".
@
text
@d291 1
a291 1
/* Drain all queued event of PID.  If PID is -1, the effect is of
d802 2
d1139 1
d1157 1
a1157 1
  pid = my_waitpid (GET_PID (inferior_ptid), &status, 0);
d1163 2
a1164 1
      pid = my_waitpid (GET_PID (inferior_ptid), &status, __WCLONE);
d1177 1
d1179 9
a1187 7
  /* Fake the SIGSTOP that core GDB expects.  */
  lp->status = W_STOPCODE (SIGSTOP);
  lp->resumed = 1;
  if (debug_linux_nat)
    fprintf_unfiltered (gdb_stdlog,
			"LNA: waitpid %ld, faking SIGSTOP\n", (long) pid);
  if (target_can_async_p ())
d1189 4
a1192 2
      /* Wake event loop with special token, to get to WFI.  */
      linux_nat_event_pipe_push (-1, -1, -1);
d1370 4
a1405 7
      if (target_can_async_p ())
	{
	  /* Wake event loop with special token, to get to WFI.  */
	  linux_nat_event_pipe_push (-1, -1, -1);

	  target_async (inferior_event_handler, 0);
	}
d1761 2
a1762 1
	      /* Hold the SIGTRAP for handling by linux_nat_wait. */
d1764 18
a1781 2
	      /* If there's another event, throw it back into the queue. */
	      if (lp->status)
d1783 5
a1787 1
		  if (debug_linux_nat)
d1789 6
a1794 4
		      fprintf_unfiltered (gdb_stdlog,
					  "SWC: kill %s, %s\n",
					  target_pid_to_str (lp->ptid),
					  status_to_str ((int) status));
d1796 2
a1797 1
		  kill_lwp (GET_LWP (lp->ptid), WSTOPSIG (lp->status));
a1798 2
	      /* Save the sigtrap event. */
	      lp->status = status;
d1825 5
a1829 6
	      /* If the lp->status field is still empty, use it to hold
	         this event.  If not, then this event must be returned
	         to the event queue of the LWP.  */
	      if (lp->status == 0)
		lp->status = status;
	      else
d1840 2
d2012 31
d2064 3
a2066 18
      && breakpoint_inserted_here_p (read_pc_pid (lp->ptid) -
				     gdbarch_decr_pc_after_break
				       (current_gdbarch)))
    {
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "CBC: Push back breakpoint for %s\n",
			    target_pid_to_str (lp->ptid));

      /* Back up the PC if necessary.  */
      if (gdbarch_decr_pc_after_break (current_gdbarch))
	write_pc_pid (read_pc_pid (lp->ptid) - gdbarch_decr_pc_after_break
						 (current_gdbarch),
		      lp->ptid);

      /* Throw away the SIGTRAP.  */
      lp->status = 0;
    }
a2335 1

a2336 4
      if (lwpid == -1 && status == -1 && options == -1)
	/* Special wake up event loop token.  */
	continue;

d2410 4
@


1.77
log
@2008-03-21  Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdbthread.h (add_thread_with_info): New.
	* linux-thread-db.c: Add some documentation.
	(GET_LWP, GET_PID, GET_THREAD, is_lwp, is_thread, BUILD_LWP): Delete.
	(struct private_thread_info): Remove th_valid and ti_valid.
	Replace ti with tid.
	(thread_get_info_callback): Do not add TID to the new ptid.  Do
	not cache th or ti.
	(thread_db_map_id2thr, lwp_from_thread): Delete functions.
	(thread_from_lwp): Assert that the LWP is set.  Do not add TID to the
	new PTID.
	(attach_thread): Handle an already-existing thread.  Use
	add_thread_with_info.  Cache the th and tid.
	(detach_thread): Verify that private was set.  Remove verbose
	argument and printing.  Update caller.
	(thread_db_detach): Do not adjust inferior_ptid.
	(clear_lwpid_callback, thread_db_resume, thread_db_kill): Delete.
	(check_event, find_new_threads_callback): Do not add TID to the new PTID.
	(thread_db_wait): Do not use lwp_from_thread.
	(thread_db_pid_to_str): Use the cached TID.
	(thread_db_extra_thread_info): Check that private is set.
	(same_ptid_callback): Delete.
	(thread_db_get_thread_local_address): Do not use it or check
	is_thread.  Check that private is set.  Assume that the thread
	handle is already cached.
	(init_thread_db_ops): Remove to_resume and to_kill.
	* thread.c (add_thread_with_info): New.
	(add_thread): Use it.
	* linux-nat.c (find_thread_from_lwp): Delete.
	(exit_lwp): Do not use it.  Check print_thread_events.  Print before
	deleting the thread.
	(GET_PID, GET_LWP, BUILD_LWP, is_lwp): Move to...
	* linux-nat.h (GET_PID, GET_LWP, BUILD_LWP, is_lwp): ...here.
	* inf-ttrace.c (inf_ttrace_wait): Use print_thread_events and
	printf_unfiltered for thread exits.
	* procfs.c (procfs_wait): Likewise.

2008-03-21  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.threads/fork-child-threads.exp: Test next over fork.
@
text
@d49 3
d119 9
d148 152
d350 2
a351 1
/* Wrapper function for waitpid which handles EINTR.  */
d357 8
d538 3
d685 1
a685 3
	{
	  target_detach (NULL, 0);
	}
d700 3
d791 5
a795 2
/* Signals to block to make that sigsuspend work.  */
static sigset_t blocked_mask;
d1020 1
d1024 2
a1025 7
  /* Make sure SIGCHLD is blocked.  We don't want SIGCHLD events
     to interrupt either the ptrace() or waitpid() calls below.  */
  if (!sigismember (&blocked_mask, SIGCHLD))
    {
      sigaddset (&blocked_mask, SIGCHLD);
      sigprocmask (SIG_BLOCK, &blocked_mask, NULL);
    }
d1098 3
d1105 26
d1142 9
d1178 3
d1182 4
a1185 2
      fprintf_unfiltered (gdb_stdlog,
			  "LLA: waitpid %ld, faking SIGSTOP\n", (long) pid);
d1242 1
d1252 4
d1266 3
a1268 3
  /* Restore the original signal mask.  */
  sigprocmask (SIG_SETMASK, &normal_mask, NULL);
  sigemptyset (&blocked_mask);
d1270 2
a1271 2
  inferior_ptid = pid_to_ptid (GET_PID (inferior_ptid));
  linux_ops->to_detach (args, from_tty);
d1325 4
d1393 7
d1419 6
d2276 51
d2336 3
d2354 3
a2356 6
  /* Make sure SIGCHLD is blocked.  */
  if (!sigismember (&blocked_mask, SIGCHLD))
    {
      sigaddset (&blocked_mask, SIGCHLD);
      sigprocmask (SIG_BLOCK, &blocked_mask, NULL);
    }
d2380 1
a2380 1
      /* But if we don't fine one, we'll have to wait, and check both
d2439 6
a2444 3
  set_sigint_trap ();		/* Causes SIGINT to be passed on to the
				   attached process. */
  set_sigio_trap ();
d2450 7
a2456 1
      lwpid = my_waitpid (pid, &status, options);
d2484 3
a2486 1
	  /* And suspend every time we have checked both.  */
d2488 17
a2504 1
	    sigsuspend (&suspend_mask);
d2511 5
a2515 2
  clear_sigio_trap ();
  clear_sigint_trap ();
d2612 7
d2698 3
d2715 4
a2718 1
    linux_fork_killall ();
a2738 4
  /* Restore the original signal mask.  */
  sigprocmask (SIG_SETMASK, &normal_mask, NULL);
  sigemptyset (&blocked_mask);

d2740 6
a2745 2
    /* Normal case, no other forks available.  */
    linux_ops->to_mourn_inferior ();
d2813 7
d3578 370
d3959 1
d3971 7
d4015 1
a4015 1
  struct sigaction action;
d4026 36
a4061 1
  /* Save the original signal mask.  */
d4064 7
a4070 4
  action.sa_handler = sigchld_handler;
  sigemptyset (&action.sa_mask);
  action.sa_flags = SA_RESTART;
  sigaction (SIGCHLD, &action, NULL);
d4076 4
a4079 1
  sigemptyset (&blocked_mask);
d4081 2
a4082 7
  add_setshow_zinteger_cmd ("lin-lwp", no_class, &debug_linux_nat, _("\
Set debugging of GNU/Linux lwp module."), _("\
Show debugging of GNU/Linux lwp module."), _("\
Enables printf debugging output."),
			    NULL,
			    show_debug_linux_nat,
			    &setdebuglist, &showdebuglist);
d4118 1
d4120 1
@


1.76
log
@	* linux-nat.c (linux_nat_filter_event): Fix comment typo.
@
text
@a590 5
#define GET_LWP(ptid)		ptid_get_lwp (ptid)
#define GET_PID(ptid)		ptid_get_pid (ptid)
#define is_lwp(ptid)		(GET_LWP (ptid) != 0)
#define BUILD_LWP(lwp, pid)	ptid_build (pid, lwp, 0)

a810 14
/* Callback for iterate_over_threads that finds a thread corresponding
   to the given LWP.  */

static int
find_thread_from_lwp (struct thread_info *thr, void *dummy)
{
  ptid_t *ptid_p = dummy;

  if (GET_LWP (thr->ptid) && GET_LWP (thr->ptid) == GET_LWP (*ptid_p))
    return 1;
  else
    return 0;
}

d818 3
a825 21
      printf_unfiltered (_("[%s exited]\n"),
			 target_pid_to_str (lp->ptid));
    }
  else
    {
      /* Even if LP->PTID is not in the global GDB thread list, the
	 LWP may be - with an additional thread ID.  We don't need
	 to print anything in this case; thread_db is in use and
	 already took care of that.  But it didn't delete the thread
	 in order to handle zombies correctly.  */

      struct thread_info *thr;

      thr = iterate_over_threads (find_thread_from_lwp, &lp->ptid);
      if (thr)
	{
	  if (!ptid_equal (thr->ptid, inferior_ptid))
	    delete_thread (thr->ptid);
	  else
	    record_dead_thread (thr->ptid);
	}
@


1.75
log
@	* linux-nat.c (linux_nat_filter_event): New, refactored from
	linux_nat_wait.
	(linux_nat_wait): Call linux_nat_filter_event.
@
text
@d1906 1
a1906 1
   Return the affected lpw if we are, or NULL otherwise.  */
@


1.74
log
@	* Makefile.in (symfile.o): Update.
	* NEWS: Mention exec tracing support.
	* inf-ttrace.c (inf_ttrace_wait): Return TARGET_WAITKIND_EXECD for
	exec events.
	* infcmd.c (kill_if_already_running, detach_command)
	(disconnect_command): Replace SOLIB_RESTART with no_shared_libraries.
	* infrun.c (MAY_FOLLOW_EXEC, may_follow_exec): Delete.
	(follow_exec): Do not check may_follow_exec.  Do not mourn and push
	targets.  Apply the sysroot path to the loaded executable.  Use
	no_shared_libraries.
	* linux-nat.c (linux_child_follow_fork): Print fork following
	messages if verbose.
	(kill_wait_callback): Kill again before waiting a second time.
	* symfile.c (symbol_file_clear): Replace SOLIB_RESTART with
	no_shared_libraries.

	* gdb.base/foll-exec.exp: Update header.  Skip on remote targets.
	Run on GNU/Linux.
	(do_exec_tests): Check for systems which do not support catchpoints.
	Do not match START.
	* gdb.base/foll-fork.exp: Update header.  Skip on remote targets.
	Run on GNU/Linux.  Enable verbose output.
	(check_fork_catchpoints): New.
	(explicit_fork_child_follow, catch_fork_child_follow)
	(tcatch_fork_parent_follow): Update expected messages.
	(do_fork_tests): Use check_fork_catchpoints.
	* gdb.base/foll-vfork.exp: Update header.  Skip on remote targets.
	Run on GNU/Linux.  Enable verbose output.
	(check_vfork_catchpoints): New.
	(vfork_parent_follow_to_bp, tcatch_vfork_then_child_follow): Update
	expected messages.
	(do_vfork_and_exec_tests): Use check_fork_catchpoints.
@
text
@d1905 167
d2204 1
a2204 35
	  lp = find_lwp_pid (pid_to_ptid (lwpid));

	  /* Check for stop events reported by a process we didn't
	     already know about - anything not already in our LWP
	     list.

	     If we're expecting to receive stopped processes after
	     fork, vfork, and clone events, then we'll just add the
	     new one to our list and go back to waiting for the event
	     to be reported - the stopped process might be returned
	     from waitpid before or after the event is.  */
	  if (WIFSTOPPED (status) && !lp)
	    {
	      linux_record_stopped_pid (lwpid, status);
	      status = 0;
	      continue;
	    }

	  /* Make sure we don't report an event for the exit of an LWP not in
	     our list, i.e.  not part of the current process.  This can happen
	     if we detach from a program we original forked and then it
	     exits.  */
	  if (!WIFSTOPPED (status) && !lp)
	    {
	      status = 0;
	      continue;
	    }

	  /* NOTE drow/2003-06-17: This code seems to be meant for debugging
	     CLONE_PTRACE processes which do not use the thread library -
	     otherwise we wouldn't find the new LWP this way.  That doesn't
	     currently work, and the following code is currently unreachable
	     due to the two blocks above.  If it's fixed some day, this code
	     should be broken out into a function so that we can also pick up
	     LWPs from the new interface.  */
d2207 1
a2207 124
	      lp = add_lwp (BUILD_LWP (lwpid, GET_PID (inferior_ptid)));
	      if (options & __WCLONE)
		lp->cloned = 1;

	      gdb_assert (WIFSTOPPED (status)
			  && WSTOPSIG (status) == SIGSTOP);
	      lp->signalled = 1;

	      if (!in_thread_list (inferior_ptid))
		{
		  inferior_ptid = BUILD_LWP (GET_PID (inferior_ptid),
					     GET_PID (inferior_ptid));
		  add_thread (inferior_ptid);
		}

	      add_thread (lp->ptid);
	    }

	  /* Save the trap's siginfo in case we need it later.  */
	  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP)
	    save_siginfo (lp);

	  /* Handle GNU/Linux's extended waitstatus for trace events.  */
	  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
	    {
	      if (debug_linux_nat)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: Handling extended status 0x%06x\n",
				    status);
	      if (linux_handle_extended_wait (lp, status, 0))
		{
		  status = 0;
		  continue;
		}
	    }

	  /* Check if the thread has exited.  */
	  if ((WIFEXITED (status) || WIFSIGNALED (status)) && num_lwps > 1)
	    {
	      /* If this is the main thread, we must stop all threads and
	         verify if they are still alive.  This is because in the nptl
	         thread model, there is no signal issued for exiting LWPs
	         other than the main thread.  We only get the main thread
	         exit signal once all child threads have already exited.
	         If we stop all the threads and use the stop_wait_callback
	         to check if they have exited we can determine whether this
	         signal should be ignored or whether it means the end of the
	         debugged application, regardless of which threading model
	         is being used.  */
	      if (GET_PID (lp->ptid) == GET_LWP (lp->ptid))
		{
		  lp->stopped = 1;
		  iterate_over_lwps (stop_and_resume_callback, NULL);
		}

	      if (debug_linux_nat)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: %s exited.\n",
				    target_pid_to_str (lp->ptid));

	      exit_lwp (lp);

	      /* If there is at least one more LWP, then the exit signal
	         was not the end of the debugged application and should be
	         ignored.  */
	      if (num_lwps > 0)
		{
		  /* Make sure there is at least one thread running.  */
		  gdb_assert (iterate_over_lwps (running_callback, NULL));

		  /* Discard the event.  */
		  status = 0;
		  continue;
		}
	    }

	  /* Check if the current LWP has previously exited.  In the nptl
	     thread model, LWPs other than the main thread do not issue
	     signals when they exit so we must check whenever the thread
	     has stopped.  A similar check is made in stop_wait_callback().  */
	  if (num_lwps > 1 && !linux_nat_thread_alive (lp->ptid))
	    {
	      if (debug_linux_nat)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: %s exited.\n",
				    target_pid_to_str (lp->ptid));

	      exit_lwp (lp);

	      /* Make sure there is at least one thread running.  */
	      gdb_assert (iterate_over_lwps (running_callback, NULL));

	      /* Discard the event.  */
	      status = 0;
	      continue;
	    }

	  /* Make sure we don't report a SIGSTOP that we sent
	     ourselves in an attempt to stop an LWP.  */
	  if (lp->signalled
	      && WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP)
	    {
	      if (debug_linux_nat)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: Delayed SIGSTOP caught for %s.\n",
				    target_pid_to_str (lp->ptid));

	      /* This is a delayed SIGSTOP.  */
	      lp->signalled = 0;

	      registers_changed ();
	      linux_ops->to_resume (pid_to_ptid (GET_LWP (lp->ptid)),
				    lp->step, TARGET_SIGNAL_0);
	      if (debug_linux_nat)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: %s %s, 0, 0 (discard SIGSTOP)\n",
				    lp->step ?
				    "PTRACE_SINGLESTEP" : "PTRACE_CONT",
				    target_pid_to_str (lp->ptid));

	      lp->stopped = 0;
	      gdb_assert (lp->resumed);

	      /* Discard the event.  */
@


1.73
log
@        Inform about new thread in a single place.

        * thread.c (add_thread_silent): Renamed
        from add_thread.
        (print_thread_events): New variable definition.
        (show_print_thread_events): New function.
        (_initialize_thread): Add "set print thread-events" and
        "show print thread-events" commands.
        (add_thread): Announce new thread.
        * gdbthread.h (add_thread_silent): Declare.
        (print_thread_events): New variable declaration.
        * inf-ttrace.c (inf_ttrace_wait): Don't
        inform about new thread, as add_thread is always
        called too, and will take care of that.
        * infrun.c (handle_inferior_event): Likewise.
        * procfs.c (procfs_wait): Likewise.
        * remote.c (remote_currthread): Likewise.
        * sol-thread.c (sol_thread_wait): Likewise.
        * win32-nat.c (get_win32_debug_event): Likewise.
        * linux-thread-db.c (attach_thread): Likewise.
        Remove the verbose parameter.
        (check_event): Make detach_thread be verbose
        only if print_thread_events is set.
        * linux-nat.c (lin_lwp_attach_lwp): Don't inform
        about new thread.  This is called only from
        linux-thread-db.c:attach_thread, which will take care.
        Remove the verbose parameter.
        * linux-nat.h (lin_lwp_attach_lwp): Adjust prototype.
@
text
@d386 1
a386 1
	  if (debug_linux_nat)
d471 1
a471 1
      if (debug_linux_nat)
d2351 1
a2351 1
	  if (pid != (pid_t) -1 && debug_linux_nat)
d2353 10
a2362 3
	      fprintf_unfiltered (gdb_stdlog,
				  "KWC: wait %s received unknown.\n",
				  target_pid_to_str (lp->ptid));
d2373 1
a2373 1
      if (pid != (pid_t) -1 && debug_linux_nat)
d2375 6
a2380 3
	  fprintf_unfiltered (gdb_stdlog,
			      "KWC: wait %s received unk.\n",
			      target_pid_to_str (lp->ptid));
@


1.72
log
@	* linux-nat.c (linux_child_follow_fork): Call also CHECK_FOR_THREAD_DB.

	* gdb.threads/fork-child-threads.exp, gdb.threads/fork-child-threads.c:
	New files
@
text
@d874 1
a874 1
lin_lwp_attach_lwp (ptid_t ptid, int verbose)
a958 3
  if (verbose)
    printf_filtered (_("[New %s]\n"), target_pid_to_str (ptid));

a2089 2
	      printf_unfiltered (_("[New %s]\n"),
				 target_pid_to_str (lp->ptid));
@


1.71
log
@	Updated copyright notices for most files.
@
text
@d520 1
@


1.70
log
@	* linux-nat.c (lin_lwp_attach_lwp): Use "Linux kernel 2.6.19"
	instead of "Linux 2.6.19" in comment.
	(linux_xfer_partial): Use "GNU/Linux target" instead of
	"Linux target" in comment.
	* m68klinux-tdep.c (m68k_linux_inferior_created): Likewise.
	(m68k_linux_get_sigtramp_info): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.69
log
@2007-10-02  Markus Deuling  <deuling@@de.ibm.com>

	* linux-nat.c (PTRACE_GETSIGINFO): Add define.
@
text
@d905 1
a905 1
	     creation is interrupted; as of Linux 2.6.19, a kernel
d3215 1
a3215 1
/* Create a prototype generic Linux target.  The client can override
@


1.68
log
@	* linux-nat.c (linux_nat_new_thread): New variable.
	(linux_child_follow_fork): Set inferior_ptid to include LWP ID.  Use
	linux_nat_switch_fork.
	(lwp_list): Make public.
	(add_lwp): Call linux_nat_new_thread.
	(lin_lwp_attach_lwp, linux_nat_attach): Call add_lwp after stopping
	the new thread.
	(resume_callback): Clear lp->siginfo.  Remove unused variable.
	(linux_nat_resume): Assert that the LWP list is already initialized.
	Clear lp->siginfo.
	(save_siginfo): New.
	(stop_wait_callback, linux_nat_wait): Call it.
	(linux_nat_set_new_thread, linux_nat_get_siginfo): New.
	* linux-nat.h (struct lwp_info): Add siginfo.
	(lwp_list, linux_nat_set_new_thread, linux_nat_get_siginfo): Declare.
	(ALL_LWPS): Define.

	* amd64-linux-nat.c (amd64_linux_dr): New.
	(amd64_linux_dr_get): Take a PTID argument.  Correct typo.
	(amd64_linux_dr_set): Take a PTID argument.
	(amd64_linux_dr_set_control, amd64_linux_dr_set_addr): Use ALL_LWPS.
	(amd64_linux_dr_reset_addr): Use amd64_linux_dr_set_addr.
	(amd64_linux_dr_get_status): Pass inferior_ptid to amd64_linux_dr_get.
	(amd64_linux_new_thread): New.
	(_initialize_amd64_linux_nat): Call linux_nat_set_new_thread.
	* i386-linux-nat.c (i386_linux_dr): New.
	(i386_linux_dr_get, i386_linux_dr_set): Take a PTID argument.
	(i386_linux_dr_set_control, i386_linux_dr_set_addr): Use ALL_LWPS.
	(i386_linux_dr_reset_addr): Use i386_linux_dr_set_addr.
	(i386_linux_dr_get_status): Pass inferior_ptid to i386_linux_dr_get.
	(i386_linux_new_thread): New.
	(i386_linux_resume): Remove unnecessary PID check.
	(_initialize_i386_linux_nat): Call linux_nat_set_new_thread.
	* ia64-linux-nat.c (enable_watchpoints_in_psr): Take PTID argument.
	(fetch_debug_register, fetch_debug_register_pair): Delete.
	(debug_registers): New.
	(ia64_linux_insert_watchpoint, ia64_linux_remove_watchpoint): Use
	ALL_LWPS and debug_registers.
	(ia64_linux_new_thread): New.
	(ia64_linux_stopped_data_address): Use linux_nat_get_siginfo.
	(_initialize_ia64_linux_nat): Call linux_nat_set_new_thread.
	* ppc-linux-nat.c (last_stopped_data_address): Delete.
	(saved_dabr_value): New.
	(ppc_linux_insert_watchpoint, ppc_linux_remove_watchpoint): Use
	ALL_LWPS.
	(ppc_linux_new_thread): New.
	(ppc_linux_stopped_data_address): Use linux_nat_get_siginfo.
	(ppc_linux_stopped_by_watchpoint): Call ppc_linux_stopped_data_address.
	(_initialize_ppc_linux_nat): Call linux_nat_set_new_thread.
	* s390-nat.c (s390_stopped_by_watchpoint): Clear the watchpoint status
	after reading it.
	(s390_fix_watch_points): Take a PTID argument.
	(s390_insert_watchpoint, s390_remove_watchpoint): Use ALL_LWPS.
	(_initialize_s390_nat): Call linux_nat_set_new_thread.
@
text
@d87 4
@


1.67
log
@	* linux-nat.c (linux_nat_make_corefile_notes): Fixed a buffer overflow.
@
text
@d92 3
d509 1
a509 1
      inferior_ptid = pid_to_ptid (child_pid);
d515 1
d580 1
a580 1
static struct lwp_info *lwp_list;
d664 2
a665 1
   structure describing the new LWP.  */
d686 3
d895 1
a908 3
      if (lp == NULL)
	lp = add_lwp (ptid);

d919 1
a919 1
	  lp->cloned = 1;
d925 4
d966 1
a971 4
  /* Add the initial process as the first LWP to the list.  */
  inferior_ptid = BUILD_LWP (GET_PID (inferior_ptid), GET_PID (inferior_ptid));
  lp = add_lwp (inferior_ptid);

d982 1
a982 1
      lp->cloned = 1;
d988 5
a1091 2
      struct thread_info *tp;

d1100 1
d1150 1
a1150 3
  if (lp)
    {
      ptid = pid_to_ptid (GET_LWP (lp->ptid));
d1152 1
a1152 2
      /* Remember if we're stepping.  */
      lp->step = step;
d1154 2
a1155 2
      /* Mark this LWP as resumed.  */
      lp->resumed = 1;
d1157 2
a1158 20
      /* If we have a pending wait status for this thread, there is no
	 point in resuming the process.  But first make sure that
	 linux_nat_wait won't preemptively handle the event - we
	 should never take this short-circuit if we are going to
	 leave LP running, since we have skipped resuming all the
	 other threads.  This bit of code needs to be synchronized
	 with linux_nat_wait.  */

      if (lp->status && WIFSTOPPED (lp->status))
	{
	  int saved_signo = target_signal_from_host (WSTOPSIG (lp->status));

	  if (signal_stop_state (saved_signo) == 0
	      && signal_print_state (saved_signo) == 0
	      && signal_pass_state (saved_signo) == 1)
	    {
	      if (debug_linux_nat)
		fprintf_unfiltered (gdb_stdlog,
				    "LLR: Not short circuiting for ignored "
				    "status 0x%x\n", lp->status);
d1160 20
a1179 7
	      /* FIXME: What should we do if we are supposed to continue
		 this thread with a signal?  */
	      gdb_assert (signo == TARGET_SIGNAL_0);
	      signo = saved_signo;
	      lp->status = 0;
	    }
	}
a1180 2
      if (lp->status)
	{
d1184 4
d1189 5
a1193 4
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"LLR: Short circuiting for status 0x%x\n",
				lp->status);
d1195 4
a1198 2
	  return;
	}
d1200 1
a1200 3
      /* Mark LWP as not stopped to prevent it from being continued by
         resume_callback.  */
      lp->stopped = 0;
d1203 4
d1211 2
d1431 16
d1532 3
d2092 4
d3288 21
@


1.66
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d2689 1
d2691 1
d2704 12
a2715 3
	  strncat (psargs, " ", sizeof (psargs) - strlen (psargs));
	  strncat (psargs, get_inferior_args (),
		   sizeof (psargs) - strlen (psargs));
@


1.65
log
@	* linux-nat.c (linux_nat_info_proc_cmd): Fix parsing of columns in
	/proc/../stat.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.64
log
@	* regcache.c (struct regcache): Add ptid_t member.
	(regcache_xmalloc): Initialize it.
	(regcache_cpy_no_passthrough): Do not refer to current_regcache.
	(regcache_dup): Likewise.
	(regcache_dup_no_passthrough): Likewise.
	(current_regcache): Make static.
	(registers_ptid): Remove variable.
	(get_thread_regcache): New function.
	(get_current_regcache): New function.
	(registers_changed): Implement by freeing current regcache.
	(regcache_raw_read): Do not refer to current_regcache.  Set
	inferior_ptid to regcache->ptid while calling target routines.
	(regcache_raw_write): Likewise.
	(regcache_raw_supply): Do not refer to current_regcache.
	(read_pc_pid): Use thread regcache.  Do not modify inferior_ptid.
	(write_pc_pid): Likewise.
	(build_regcache): Remove.
	(_initialize_regcache): Do not call DEPRECATED_REGISTER_GDBARCH_SWAP
	or deprecated_register_gdbarch_swap.  Do not initialize
	registers_ptid.
	* regcache.h (get_current_regcache): Add prototype.
	(get_thread_regcache): Likewise.
	(current_regcache): Remove declaration.

	* corelow.c (core_open): Replace current_regcache by
	get_current_regcache ().
	* frame.c (frame_pop): Likewise.
	(put_frame_register): Likewise.
	(get_current_frame, create_new_frame): Likewise.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Likewise.
	* stack.c (return_command): Likewise.
	* infcall.c (call_function_by_hand): Likewise.
	* infrun.c (resume): Likewise.
	(save_inferior_status, restore_inferior_status): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	(fork_save_infrun_state): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* i386fbsd-nat.c (i386fbsd_resume): Likewise.
	* monitor.c (monitor_wait): Likewise.
	* remote.c (remote_wait): Likewise.
	* remote-mips.c (mips_wait): Likewise.

	* bsd-kvm.c (bsd_kvm_open): Likewise
	(bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Likewise.
	* fbsd-nat.c (fbsd_make_corefile_notes): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint): Likewise.
	(ia64_linux_stopped_data_address): Likewise.

	* frv-tdep.c (frv_fdpic_loadmap_addresses): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* mep-tdep.c (current_me_module, current_options): Likewise.
	* mips-tdep.c (deprecated_mips_set_processor_regs_hack): Likewise.

	* linux-nat.c (linux_nat_do_thread_registers): Use thread
	regcache instead of current_regcache.  Call target_fetch_registers.
	(linux_nat_corefile_thread_callback): Update call site.
	(linux_nat_do_registers): Likewise.
	* procfs.c (procfs_do_thread_registers): Use thread regcache instead
	of current_regcache.
	(procfs_make_note_section): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
@
text
@d2929 1
d2933 1
a2933 1
	  if (fscanf (procfile, "%s ", &buffer[0]) > 0)
d2947 49
a2995 49
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered (_("Flags: 0x%x\n"), itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered (_("Minor faults (no memory page): %u\n"),
			     (unsigned int) itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered (_("Minor faults, children: %u\n"),
			     (unsigned int) itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered (_("Major faults (memory page faults): %u\n"),
			     (unsigned int) itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered (_("Major faults, children: %u\n"),
			     (unsigned int) itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("utime: %d\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("stime: %d\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("utime, children: %d\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("stime, children: %d\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered (_("jiffies remaining in current time slice: %d\n"),
			     itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("'nice' value: %d\n", itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered (_("jiffies until next timeout: %u\n"),
			     (unsigned int) itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("jiffies until next SIGALRM: %u\n",
			     (unsigned int) itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered (_("start time (jiffies since system boot): %d\n"),
			     itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered (_("Virtual memory size: %u\n"),
			     (unsigned int) itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered (_("Resident set size: %u\n"), (unsigned int) itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("rlim: %u\n", (unsigned int) itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered (_("Start of text: 0x%x\n"), itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered (_("End of text: 0x%x\n"), itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered (_("Start of stack: 0x%x\n"), itmp);
d2998 14
a3011 14
	  if (fscanf (procfile, "%u ", &itmp) > 0)	/* FIXME arch? */
	    printf_filtered (_("Kernel stack pointer: 0x%x\n"), itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)	/* FIXME arch? */
	    printf_filtered (_("Kernel instr pointer: 0x%x\n"), itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered (_("Pending signals bitmap: 0x%x\n"), itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered (_("Blocked signals bitmap: 0x%x\n"), itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered (_("Ignored signals bitmap: 0x%x\n"), itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered (_("Catched signals bitmap: 0x%x\n"), itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)	/* FIXME arch? */
	    printf_filtered (_("wchan (system call): 0x%x\n"), itmp);
@


1.63
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_ADDR_BIT): Replace by gdbarch_addr_bit.
	* valops.c (value_cast): Likewise.
	* utils.c (strlen_paddr, paddr, paddr_nz, paddress): Likewise.
	* ui-out.c (ui_out_field_core_addr): Likewise.
	* tracepoint.c (tracepoints_info): Likewise.
	* symtab.c (print_msymbol_info): Likewise.
	* solib-irix.c (irix_current_sos)
	(irix_open_symbol_file_object): Likewise.
	* remote.c (build_remote_gdbarch_data): Likewise.
	* prologue-value.c (make_pv_area): Likewise.
	* procfs.c (info_mappings_callback): Likewise.
	* printcmd.c (print_scalar_formatted)
	(deprecated_print_address_numeric): Likewise.
	* memattr.c (mem_info_command): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* gdbtypes.c (build_flt, gdbtypes_post_init): Likewise.
	* exec.c (print_section_info): Likewise.
	* dwarf2read.c (read_subrange_type): Likewise.
	* dwarf2loc.c (find_location_expression): Likewise.
	* dwarf2expr.c (dwarf2_read_address, unsigned_address_type)
	(signed_address_type, execute_stack_op): Likewise.
	* breakpoint.c (print_one_breakpoint, breakpoint_1): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d2586 2
a2587 1
  struct gdbarch *gdbarch = current_gdbarch;
d2590 6
d2602 1
a2602 1
    regset->collect_regset (regset, current_regcache, -1,
d2605 1
a2605 1
    fill_gregset (current_regcache, &gregs, -1);
d2617 1
a2617 1
    regset->collect_regset (regset, current_regcache, -1,
d2620 1
a2620 1
    fill_fpregset (current_regcache, &fpregs, -1);
d2632 1
a2632 1
    regset->collect_regset (regset, current_regcache, -1,
d2635 1
a2635 1
    fill_fpxregset (current_regcache, &fpxregs, -1);
a2659 1
  ptid_t saved_ptid = inferior_ptid;
a2660 4
  inferior_ptid = ti->ptid;
  registers_changed ();
  /* FIXME should not be necessary; fill_gregset should do it automatically. */
  target_fetch_registers (current_regcache, -1);
a2665 4
  inferior_ptid = saved_ptid;
  registers_changed ();
  /* FIXME should not be necessary; fill_gregset should do it automatically. */
  target_fetch_registers (current_regcache, -1);
a2675 3
  registers_changed ();
  /* FIXME should not be necessary; fill_gregset should do it automatically. */
  target_fetch_registers (current_regcache, -1);
a2680 1
  return note_data;
@


1.62
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (DECR_PC_AFTER_BREAK): Replace by
	gdbarch_decr_pc_after_break.
	* tracepoint.c (trace_dump_command): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* linux-thread-db.c (check_event): Likewise.
	* linux-nat.c (cancel_breakpoints_callback): Likewise.
	* infrun.c (adjust_pc_after_break, normal_stop): Likewise.
	* frame.h: Likewise (comment).
	* dummy-frame.c (deprecated_pc_in_call_dummy): Likewise.
	* aix-thread.c (aix_thread_wait): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d2865 1
a2865 1
	  if (TARGET_ADDR_BIT == 32)
d2891 1
a2891 1
	      if (TARGET_ADDR_BIT == 32)
@


1.61
log
@	* inf-ptrace.c (inf_ptrace_register_u_offset): Adapt parameter list.
	(inf_ptrace_fetch_register): Add register_u_offset callback parameters
	GDBARCH and STORE_P.  Handle callback (CORE_ADDR) -1 return value.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_trad_target): Adapt register_u_offset parameter list.
	* inf-ptrace.h (inf_ptrace_trad_target): Likewise.

	* vax-nat.c (vax_register_u_offset): Adapt parameter list.

	* linux-nat.c (linux_trad_target): Adapt parameter list.
	* linux-nat.h (linux_trad_target): Likewise.

	* alpha-linux-nat.c (alpha_linux_register_u_offset): Adapt parameters.

	* mips-linux-nat.c (mips_linux_cannot_fetch_register): Remove.
	(mips_linux_cannot_store_register): Likewise.
	(mips_linux_register_addr): Add GDBARCH and STORE_P parameters.
	Return (CORE_ADDR) -1 for registers that cannot be fetched or
	stored via ptrace.  Use GDBARCH instead of current_gdbarch.
	(mips64_linux_register_addr): Likewise.
	(mips_linux_register_u_offset): Adapt parameter list.  Pass
	GDBARCH and STORE_P on to mips{64}_linux_register_addr.

	* config/mips/linux.mh (NAT_FILE): Set to config/nm-linux.h.
	* config/mips/nm-linux.h: Delete file.
@
text
@d1770 2
a1771 1
				     DECR_PC_AFTER_BREAK))
d1779 4
a1782 2
      if (DECR_PC_AFTER_BREAK)
	write_pc_pid (read_pc_pid (lp->ptid) - DECR_PC_AFTER_BREAK, lp->ptid);
@


1.60
log
@	* linux-nat.c (child_post_attach): Rename to ...
	(linux_child_post_attach): ... this.  Make static.
	(child_follow_fork): Rename to ...
	(linux_child_follow_fork): ... this.  Make static.
	(child_insert_fork_catchpoint): Rename to ...
	(linux_child_insert_fork_catchpoint): ... this.  Make static.
	(child_insert_vfork_catchpoint): Rename to ...
	(linux_child_insert_vfork_catchpoint): ... this.  Make static.
	(child_insert_exec_catchpoint): Rename to ...
	(linux_child_insert_exec_catchpoint): ... this.  Make static.
	(child_pid_to_exec_file): Rename to ...
	(linux_child_pid_to_exec_file): ... this.  Make static.
	Add prototype.
	(linux_handle_extended_wait): Update call.
	(linux_xfer_partial): Update callback routine names.
@
text
@d3201 1
a3201 1
linux_trad_target (CORE_ADDR (*register_u_offset)(int))
@


1.59
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d338 2
a339 2
void
child_post_attach (int pid)
d352 2
a353 2
int
child_follow_fork (struct target_ops *ops, int follow_child)
d523 2
a524 2
void
child_insert_fork_catchpoint (int pid)
d530 2
a531 2
void
child_insert_vfork_catchpoint (int pid)
d537 2
a538 2
void
child_insert_exec_catchpoint (int pid)
d619 1
d1329 1
a1329 1
	= xstrdup (child_pid_to_exec_file (pid));
d2467 2
a2468 2
char *
child_pid_to_exec_file (int pid)
d3175 4
a3178 4
  t->to_insert_fork_catchpoint = child_insert_fork_catchpoint;
  t->to_insert_vfork_catchpoint = child_insert_vfork_catchpoint;
  t->to_insert_exec_catchpoint = child_insert_exec_catchpoint;
  t->to_pid_to_exec_file = child_pid_to_exec_file;
d3180 2
a3181 2
  t->to_post_attach = child_post_attach;
  t->to_follow_fork = child_follow_fork;
@


1.58
log
@	* gregset.h (struct regcache): Add forward declaration.
	(supply_gregset): Add REGCACHE parameter, make GREGS const.
	(supply_fpregset): Add REGCACHE parameter, make FPREGS const.
	(supply_fpxregset): Add REGCACHE parameter, make FPXREGS const.
	(fill_gregset): Add REGCACHE parameter.
	(fill_fpregset): Likewise.
	(fill_fpxregset): Likewise.

	Update all definitions accordingly:
	* alphabsd-nat.c, alpha-linux-nat.c, alpha-nat.c, amd64-linux-nat.c,
	arm-linux-nat.c, hppa-linux-nat.c, i386gnu-nat.c, i386-linux-nat.c,
	i386-sol2-nat.c, i386v4-nat.c, ia64-linux-nat.c, irix5-nat.c,
	m32r-linux-nat.c, m68klinux-nat.c, mips-linux-nat.c, ppc-linux-nat.c,
	s390-nat.c, sparc64-linux-nat.c, sparc-linux-nat.c, sparc-sol2-nat.c
	(supply_gregset): Add REGCACHE parameter, use it instead of
	current_regcache.  Make GREGSETP parameter const, adapt casts.
	(supply_fpregset): Add REGCACHE parameter, use it instead of
	current_regcache.  Make FPREGSETP parameter const, adapt casts.
	(fill_gregset): Add REGCACHE parameter, use it instead of
	current_regcache.
	(fill_fpregset): Likewise.

	Update all callers to pass in current_regcache as the new argument:
	* core-regset.c: Include "regcache.h".
	(fetch_core_registers): Update supply_gregset,and supply_fpregset calls.
	* procfs.c: Include "regcache.h".
	(procfs_fetch_registers): Update supply_gregset, supply_fpregset calls.
	(procfs_store_registers): Update fill_gregset, fill_fpregset calls.
	(procfs_do_thread_registers): Likewise.
	(procfs_make_note_section): Likewise.
	* proc-service.c: Include "regcache.h".
	(ps_lgetregs): Update fill_gregset call.
	(ps_lsetregs): Update supply_gregset call.
	(ps_lgetfpregs): Update fill_fpregset call.
	(ps_lsetfpregs): Update supply_fpregset call.
	* sol-thread.c (sol_thread_fetch_registers): Update supply_gregset,
	supply_fpregset calls.
	(sol_thread_store_registers): Update fill_gregset, fill_fpregset calls.
	(ps_lgetregs): Update fill_gregset call.
	(ps_lsetregs): Update supply_gregset call.
	(ps_lgetfpregs): Update fill_fpregset call.
	(ps_lsetfpregs): Update supply_fpregset call.

	* linux-nat.c (linux_nat_do_thread_registers): Update fill_gregset,
	fill_fpregset, and fill_fpxregset calls.
	* i386-linux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.
	(fetch_fpxregs): Update supply_fpxregset call.
	(store_fpxregs): Update fill_fpxregset call.
	* m32r-linux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	* m68klinux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.
	(fetch_core_registers): Update supply_gregset, supply_fpregset calls.
	* s390-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.

	* Makefile.in (core-regset.o, procfs.o, proc-service.o): Update
	dependencies.
@
text
@d2653 2
a2654 2
  target_fetch_registers (-1);	/* FIXME should not be necessary;
				   fill_gregset should do it automatically. */
d2662 3
a2664 2
  target_fetch_registers (-1);	/* FIXME should not be necessary;
				   fill_gregset should do it automatically. */
d2675 2
a2676 2
  target_fetch_registers (-1);	/* FIXME should not be necessary;
				   fill_gregset should do it automatically. */
@


1.57
log
@	* linux-nat.c (linux_register_u_offset): Remove.
	(linux_target_install_ops): New function.
	(linux_target): Use it.
	(linux_trad_target): New function.
	* linux-nat.h (linux_trad_target): Declare.

	* alpha-linux-nat.c: Include "gdbcore.h".
	(alpha_linux_register_u_offset): New function.
	(_initialize_alpha_linux_nat): Use linux_trad_target.

	* mips-linux-nat.c: Include "gdbcore.h".
	(mips_linux_register_u_offset): New function.
	(_initialize_mips_linux_nat): Use linux_trad_target.

	* config/arm/linux.mh (NAT_FILE): Set to config/nm-linux.h.
	* config/arm/nm-linux.h: Delete file.

	* config/i386/nm-linux64.h (FETCH_INFERIOR_REGISTERS): Remove.
	* config/i386/nm-linux.h (FETCH_INFERIOR_REGISTERS): Remove.

	* config/ia64/linux.mh (NAT_FILE): Set to config/nm-linux.h.
	* config/ia64/nm-linux.h: Delete file.

	* config/m32r/linux.mh (NAT_FILE): Set to config/nm-linux.h.
	* config/m32r/nm-linux.h: Delete file.

	* config/m68k/linux.mh (NAT_FILE): Set to config/nm-linux.h.
	* config/m68k/nm-linux.h: Delete file.

	* config/pa/linux.mh (NAT_FILE): Set to config/nm-linux.h.
	* config/pa/nm-linux.h: Delete file.

	* config/powerpc/linux.mh (NAT_FILE): Set to config/nm-linux.h.
	* config/powerpc/ppc64-linux.mh (NAT_FILE): Likewise.
	* config/powerpc/nm-linux.h: Delete file.

	* config/s390/s390.mh (NAT_FILE): Set to config/nm-linux.h.
	* config/s390/nm-linux.h: Delete file.

	* config/sparc/linux.mh (NAT_FILE): Set to config/nm-linux.h.
	* config/sparc/linux64.mh (NAT_FILE): Likewise.
	* config/sparc/nm-linux.h: Delete file.

	* Makefile.in (alpha-linux-nat.o): Update dependencies.
	(mips-linux-nat.o): Likewise.
@
text
@d2594 1
a2594 1
    fill_gregset (&gregs, -1);
d2609 1
a2609 1
    fill_fpregset (&fpregs, -1);
d2624 1
a2624 1
    fill_fpxregset (&fpxregs, -1);
@


1.56
log
@2007-02-09  Gabriel Dos Reis  <gdr@@integrable-solutions.net>

        * ada-lang.c (remove_out_of_scope_renamings): Change third
          parameter's
        type to a pointer to const struct block.
        (ada_lookup_symbol_list): Don't cast away constness when
          calling
        remove_out_of_scope_renamings.

2007-02-09  Gabriel Dos Reis  <gdr@@integrable-solutions.net>

        * linux-nat.c (linux_nat_find_memory_regions): Don't check the
        address of 'filename'; it is always non null.
@
text
@a3166 16
#ifndef FETCH_INFERIOR_REGISTERS

/* Return the address in the core dump or inferior of register
   REGNO.  */

static CORE_ADDR
linux_register_u_offset (int regno)
{
  /* FIXME drow/2005-09-04: The hardcoded use of register_addr should go
     away.  This requires disentangling the various definitions of it
     (particularly alpha-nat.c's).  */
  return register_addr (regno, 0);
}

#endif

d3170 2
a3171 2
struct target_ops *
linux_target (void)
a3172 7
  struct target_ops *t;

#ifdef FETCH_INFERIOR_REGISTERS
  t = inf_ptrace_target ();
#else
  t = inf_ptrace_trad_target (linux_register_u_offset);
#endif
d3185 20
@


1.55
log
@Copyright updates for 2007.
@
text
@d2556 1
a2556 1
	  if (filename && filename[0])
@


1.54
log
@	* linux-nat.c (struct simple_pid_list): Add status.
	(add_to_pid_list): Record the PID's status.
	(linux_record_stopped_pid): Likewise.  Make static.
	(pull_pid_from_list): Return the saved status.
	(linux_nat_handle_extended): Deleted.
	(linux_handle_extended_wait): Combine with linux_nat_handle_extended.
	Make static.  Handle non-SIGSTOP for a new thread's first signal.
	(flush_callback): Handle unexpected pending signals.
	(linux_nat_wait): Update calls to changed functions.
	* linux-nat.h (linux_record_stopped_pid, linux_handle_extended_wait):
	Remove prototypes for newly static functions.

	* gdb.threads/sigthread.c, gdb.threads/sigthread.exp: New.
@
text
@d3 1
a3 1
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006
@


1.53
log
@	Warning fixes.
	* ada-lang.c (find_struct_field): Initialize *byte_offset_p.
	* breakpoint.c (do_enable_breakpoint): Ignore both mem_cnt and i.
	* c-typeprint.c (c_type_print_varspec_suffix): Don't test length
	greater than or equal to zero.
	* m2-typeprint.c (m2_array): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	* gdbtypes.c (copy_type_recursive): Correct == typo.
	* i386-tdep.c (i386_skip_prologue): Remove stray semicolon.
	* linux-nat.c (linux_nat_info_proc_cmd): Don't compare a pointer
	greater than zero.
	* macroscope.c (sal_macro_scope): Don't name a local variable "main".
	(default_macro_scope): Remove unused variable.
	* prologue-value.h (pv_area_find_reg): Don't name an argument
	"register".
	* remote-fileio.c (remote_fio_func_map): Add missing braces.
	* remote.c (sigint_remote_twice_token, sigint_remote_token): Change
	type.
	(cleanup_sigint_signal_handler): Remove casts.
	* valprint.c (val_print): Use a volatile local for the modified
	argument.
	* varobj.c (languages): Remove extra array dimension.
	(varobj_create): Correct access to languages array.
	* mi/mi-cmd-break.c (mi_cmd_break_insert, mi_cmd_break_watch): Add
	missing braces.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Likewise.
	* mi/mi-cmd-env.c (mi_cmd_env_path, mi_cmd_env_dir): Likewise.
	* mi/mi-getopt.c (mi_valid_noargs): Likewise.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	(mi_cmd_data_write_memory): Likewise.
	* signals/signals.c (target_signal_to_string): Cast to int before
	comparing.
	* tui/tui-layout.c (init_and_make_win): Take and return a void *.
	Update all callers.
@
text
@d116 1
d135 1
a135 1
add_to_pid_list (struct simple_pid_list **listp, int pid)
d139 1
d145 1
a145 1
pull_pid_from_list (struct simple_pid_list **listp, int pid)
d153 1
d161 2
a162 2
void
linux_record_stopped_pid (int pid)
d164 1
a164 1
  add_to_pid_list (&stopped_pids, pid);
a521 63
ptid_t
linux_handle_extended_wait (int pid, int status,
			    struct target_waitstatus *ourstatus)
{
  int event = status >> 16;

  if (event == PTRACE_EVENT_FORK || event == PTRACE_EVENT_VFORK
      || event == PTRACE_EVENT_CLONE)
    {
      unsigned long new_pid;
      int ret;

      ptrace (PTRACE_GETEVENTMSG, pid, 0, &new_pid);

      /* If we haven't already seen the new PID stop, wait for it now.  */
      if (! pull_pid_from_list (&stopped_pids, new_pid))
	{
	  /* The new child has a pending SIGSTOP.  We can't affect it until it
	     hits the SIGSTOP, but we're already attached.  */
	  ret = my_waitpid (new_pid, &status,
			    (event == PTRACE_EVENT_CLONE) ? __WCLONE : 0);
	  if (ret == -1)
	    perror_with_name (_("waiting for new child"));
	  else if (ret != new_pid)
	    internal_error (__FILE__, __LINE__,
			    _("wait returned unexpected PID %d"), ret);
	  else if (!WIFSTOPPED (status) || WSTOPSIG (status) != SIGSTOP)
	    internal_error (__FILE__, __LINE__,
			    _("wait returned unexpected status 0x%x"), status);
	}

      if (event == PTRACE_EVENT_FORK)
	ourstatus->kind = TARGET_WAITKIND_FORKED;
      else if (event == PTRACE_EVENT_VFORK)
	ourstatus->kind = TARGET_WAITKIND_VFORKED;
      else
	ourstatus->kind = TARGET_WAITKIND_SPURIOUS;

      ourstatus->value.related_pid = new_pid;
      return inferior_ptid;
    }

  if (event == PTRACE_EVENT_EXEC)
    {
      ourstatus->kind = TARGET_WAITKIND_EXECD;
      ourstatus->value.execd_pathname
	= xstrdup (child_pid_to_exec_file (pid));

      if (linux_parent_pid)
	{
	  detach_breakpoints (linux_parent_pid);
	  ptrace (PTRACE_DETACH, linux_parent_pid, 0, 0);

	  linux_parent_pid = 0;
	}

      return inferior_ptid;
    }

  internal_error (__FILE__, __LINE__,
		  _("unknown ptrace event %d"), event);
}

d1236 5
a1240 6
/* Handle a GNU/Linux extended wait response.  Most of the work we
   just pass off to linux_handle_extended_wait, but if it reports a
   clone event we need to add the new LWP to our list (and not report
   the trap to higher layers).  This function returns non-zero if
   the event should be ignored and we should wait again.  If STOPPING
   is true, the new LWP remains stopped, otherwise it is continued.  */
d1243 7
a1249 4
linux_nat_handle_extended (struct lwp_info *lp, int status, int stopping)
{
  linux_handle_extended_wait (GET_LWP (lp->ptid), status,
			      &lp->waitstatus);
d1251 2
a1252 2
  /* TARGET_WAITKIND_SPURIOUS is used to indicate clone events.  */
  if (lp->waitstatus.kind == TARGET_WAITKIND_SPURIOUS)
d1254 23
a1276 4
      struct lwp_info *new_lp;
      new_lp = add_lwp (BUILD_LWP (lp->waitstatus.value.related_pid,
				   GET_PID (inferior_ptid)));
      new_lp->cloned = 1;
d1278 4
a1281 2
      if (stopping)
	new_lp->stopped = 1;
d1283 19
a1301 1
	ptrace (PTRACE_CONT, lp->waitstatus.value.related_pid, 0, 0);
d1303 31
a1333 1
      lp->waitstatus.kind = TARGET_WAITKIND_IGNORE;
d1335 2
a1336 5
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog,
			    "LLHE: Got clone event from LWP %ld, resuming\n",
			    GET_LWP (lp->ptid));
      ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
d1338 1
a1338 1
      return 1;
d1341 2
a1342 1
  return 0;
d1413 1
a1413 1
      if (linux_nat_handle_extended (lp, status, 1))
d1653 9
a1661 1
  while (linux_nat_has_pending (GET_LWP (lp->ptid), &pending, flush_mask))
d2015 1
a2015 1
	      linux_record_stopped_pid (lwpid);
d2066 1
a2066 1
	      if (linux_nat_handle_extended (lp, status, 0))
@


1.52
log
@	* linux-nat.c (lin_lwp_attach_lwp): Return a status.  Do not
	add the LWP to our list until we are attached.  Warn instead
	of erroring if the attach fails.
	* linux-nat.h (lin_lwp_attach_lwp): New prototype.
	* linux-thread-db.c (attach_thread): Call lin_lwp_attach_lwp
	directly.  Do not add the thread to our list until we are
	successfully attached.
	* config/nm-linux.h (lin_lwp_attach_lwp, ATTACH_LWP): Delete.
@
text
@d2807 1
a2807 1
      if ((procfile = fopen (fname1, "r")) > 0)
d2837 1
a2837 1
      if ((procfile = fopen (fname1, "r")) > 0)
d2897 1
a2897 1
      if ((procfile = fopen (fname1, "r")) > 0)
d2909 1
a2909 1
      if ((procfile = fopen (fname1, "r")) > 0)
@


1.51
log
@Index: ChangeLog
2006-11-20  Andrew Cagney  <cagney@@redhat.com>

	* linux-nat.h: Refer to GNU/Linux or Linux kernel.
	* linux-nat.c (lin_lwp_attach_lwp, linux_nat_thread_alive): Ditto.
	* infcmd.c (attach_command): Ditto.
	* hppa-linux-tdep.c (hppa_linux_regset): Ditto.
	* mn10300-linux-tdep.c: Ditto.  Update copyright year.
	* frv-linux-tdep.c: Ditto.  Update copyright year.
@
text
@d918 2
a919 1
   process.  */
d921 1
a921 1
void
d924 1
a924 1
  struct lwp_info *lp, *found_lp;
d936 1
a936 6
  if (verbose)
    printf_filtered (_("[New %s]\n"), target_pid_to_str (ptid));

  found_lp = lp = find_lwp_pid (ptid);
  if (lp == NULL)
    lp = add_lwp (ptid);
d944 1
a944 1
  if (GET_LWP (ptid) != GET_PID (ptid) && found_lp == NULL)
d950 13
a962 2
	error (_("Can't attach %s: %s"), target_pid_to_str (ptid),
	       safe_strerror (errno));
d1000 2
d1004 5
@


1.50
log
@(linux_test_for_tracefork): Don't leave zombie
process.
@
text
@d989 4
a992 4
         that the linux ptrace layer uses to keep track of threads.
         Note that this won't have already been done since the main
         thread will have, we assume, been stopped by an attach from a
         different layer.  */
d2399 5
a2403 5
  /* Not every Linux target implements PTRACE_PEEKUSER.
     But we can handle that case gracefully since ptrace
     will first do a lookup for the process based upon the
     passed-in pid.  If that fails we will get either -ESRCH
     or -EPERM, otherwise the child exists and is alive.  */
@


1.50.2.1
log
@Index: ChangeLog
2006-11-20  Andrew Cagney  <cagney@@redhat.com>

	* linux-nat.h: Refer to GNU/Linux or Linux kernel.
	* linux-nat.c (lin_lwp_attach_lwp, linux_nat_thread_alive): Ditto.
	* infcmd.c (attach_command): Ditto.
	* hppa-linux-tdep.c (hppa_linux_regset): Ditto.
	* mn10300-linux-tdep.c: Ditto.  Update copyright year.
	* frv-linux-tdep.c: Ditto.  Update copyright year.
@
text
@d989 4
a992 4
         that the GNU/linux ptrace layer uses to keep track of
         threads.  Note that this won't have already been done since
         the main thread will have, we assume, been stopped by an
         attach from a different layer.  */
d2399 5
a2403 5
  /* Not every Linux kernel implements PTRACE_PEEKUSER.  But we can
     handle that case gracefully since ptrace will first do a lookup
     for the process based upon the passed-in pid.  If that fails we
     will get either -ESRCH or -EPERM, otherwise the child exists and
     is alive.  */
@


1.49
log
@	* linux-nat.c (linux_nat_add_target): Remove extern.
	* linux-nat.h (thread_db_init): New prototype.
@
text
@d279 1
@


1.48
log
@	* target.c (target_read): Stop if target_read_partial returns 0
	when some bytes have already been read.
	(target_write): Likewise for target_write_partial.
	(target_read_partial, target_write_partial): Make static.
	(target_read_alloc): New.
	* target.h: Doc fixes.
	(target_read_partial, target_write_partial): Delete prototypes.
	(target_read_alloc): New prototype.

	* auxv.c (target_auxv_read): Delete.
	(target_auxv_search, fprint_target_auxv): Use target_read_alloc.
	* auxv.h (target_auxv_read): Delete prototype.
	* avr-tdep.c (avr_io_reg_read_command): Use target_read_alloc.
	* ia64-tdep.c (getunwind_table, get_kernel_table): Likewise.
	* linux-nat.c (linux_nat_make_corefile_notes): Likewise.
	* procfs.c (procfs_make_note_section): Likewise.
	* remote.c (remote_xfer_partial): Don't loop here.
	* sparc-tdep.c (sparc_fetch_wcookie): Use target_read.
@
text
@a3182 2
  extern void thread_db_init (struct target_ops *);

@


1.47
log
@	* linux-nat.c (linux_nat_do_thread_registers): Check for
	NULL collect_regset method.
@
text
@d2700 2
a2701 1
  auxv_len = target_auxv_read (&current_target, &auxv);
@


1.47.2.1
log
@(linux_nat_wait): Commit the changes described but
not committed on 2006-05-13.
@
text
@a50 1
#include "async-nat-inferior.h"
d1839 1
a1839 2
linux_nat_wait (ptid_t ptid, struct target_waitstatus *ourstatus,
		gdb_client_data client_data)
d1841 20
d1862 2
a1863 1
  if (target_can_async_p ())
d1865 3
a1867 2
      if (client_data != NULL)
	return gdb_process_pending_event (gdb_status, ourstatus, client_data);
d1869 1
a1869 3
      set_sigint_trap ();	/* Causes SIGINT to be passed on to the
				   attached process.  */
      set_sigio_trap ();
d1871 2
a1872 4
      ourstatus->kind = TARGET_WAITKIND_IGNORE;
      ourstatus->kind = TARGET_WAITKIND_SPURIOUS;
      while (ourstatus->kind == TARGET_WAITKIND_SPURIOUS)
      	gdb_process_events (gdb_status, ourstatus, -1, 1);
d1874 9
a1882 2
      clear_sigio_trap ();
      clear_sigint_trap ();
d1884 6
a1889 3
      if ((ourstatus->kind == TARGET_WAITKIND_EXITED)
	  || (ourstatus->kind == TARGET_WAITKIND_SIGNALLED))
	return null_ptid;
d1891 4
a1894 1
      return pid_to_ptid (gdb_status->pid);
d1896 1
a1896 1
  else
d1898 4
a1901 5
      struct lwp_info *lp = NULL;
      int options = 0;
      int status = 0;
      pid_t pid = PIDGET (ptid);
      sigset_t flush_mask;
d1903 5
a1907 6
      /* The first time we get here after starting a new inferior, we may
	 not have added it to the LWP list yet - this is the earliest
	 moment at which we know its PID.  */
      if (num_lwps == 0)
	{
	  gdb_assert (!is_lwp (inferior_ptid));
d1909 5
a1913 5
	  inferior_ptid = BUILD_LWP (GET_PID (inferior_ptid),
				     GET_PID (inferior_ptid));
	  lp = add_lwp (inferior_ptid);
	  lp->resumed = 1;
	}
d1915 30
a1944 1
      sigemptyset (&flush_mask);
d1946 3
a1948 6
      /* Make sure SIGCHLD is blocked.  */
      if (!sigismember (&blocked_mask, SIGCHLD))
	{
	  sigaddset (&blocked_mask, SIGCHLD);
	  sigprocmask (SIG_BLOCK, &blocked_mask, NULL);
	}
d1950 3
a1952 1
    retry:
d1954 3
a1956 2
      /* Make sure there is at least one LWP that has been resumed.  */
      gdb_assert (iterate_over_lwps (resumed_callback, NULL));
d1958 2
a1959 2
      /* First check if there is a LWP with a wait status pending.  */
      if (pid == -1)
d1961 3
a1963 3
	  /* Any LWP that's been resumed will do.  */
	  lp = iterate_over_lwps (status_callback, NULL);
	  if (lp)
d1965 3
a1967 8
	      status = lp->status;
	      lp->status = 0;

	      if (debug_linux_nat && status)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: Using pending wait status %s for %s.\n",
				    status_to_str (status),
				    target_pid_to_str (lp->ptid));
d1970 1
a1970 11
	  /* But if we don't fine one, we'll have to wait, and check both
	     cloned and uncloned processes.  We start with the cloned
	     processes.  */
	  options = __WCLONE | WNOHANG;
	}
      else if (is_lwp (ptid))
	{
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"LLW: Waiting for specific LWP %s.\n",
				target_pid_to_str (ptid));
d1972 15
a1986 5
	  /* We have a specific LWP to check.  */
	  lp = find_lwp_pid (ptid);
	  gdb_assert (lp);
	  status = lp->status;
	  lp->status = 0;
d1988 9
a1996 5
	  if (debug_linux_nat && status)
	    fprintf_unfiltered (gdb_stdlog,
				"LLW: Using pending wait status %s for %s.\n",
				status_to_str (status),
				target_pid_to_str (lp->ptid));
d1998 12
a2009 17
	  /* If we have to wait, take into account whether PID is a cloned
	     process or not.  And we have to convert it to something that
	     the layer beneath us can understand.  */
	  options = lp->cloned ? __WCLONE : 0;
	  pid = GET_LWP (ptid);
	}

      if (status && lp->signalled)
	{
	  /* A pending SIGSTOP may interfere with the normal stream of
	     events.  In a typical case where interference is a problem,
	     we have a SIGSTOP signal pending for LWP A while
	     single-stepping it, encounter an event in LWP B, and take the
	     pending SIGSTOP while trying to stop LWP A.  After processing
	     the event in LWP B, LWP A is continued, and we'll never see
	     the SIGTRAP associated with the last time we were
	     single-stepping LWP A.  */
d2011 3
a2013 12
	  /* Resume the thread.  It should halt immediately returning the
	     pending SIGSTOP.  */
	  registers_changed ();
	  linux_ops->to_resume (pid_to_ptid (GET_LWP (lp->ptid)),
				lp->step, TARGET_SIGNAL_0);
	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"LLW: %s %s, 0, 0 (expect SIGSTOP)\n",
				lp->step ? "PTRACE_SINGLESTEP" : "PTRACE_CONT",
				target_pid_to_str (lp->ptid));
	  lp->stopped = 0;
	  gdb_assert (lp->resumed);
d2015 6
a2020 3
	  /* This should catch the pending SIGSTOP.  */
	  stop_wait_callback (lp, NULL);
	}
d2022 4
a2025 3
      set_sigint_trap ();		/* Causes SIGINT to be passed on to the
					   attached process. */
      set_sigio_trap ();
d2027 2
a2028 6
      while (status == 0)
	{
	  pid_t lwpid;

	  lwpid = my_waitpid (pid, &status, options);
	  if (lwpid > 0)
a2029 2
	      gdb_assert (pid == -1 || lwpid == pid);

d2031 4
a2035 19
		  fprintf_unfiltered (gdb_stdlog,
				      "LLW: waitpid %ld received %s\n",
				      (long) lwpid, status_to_str (status));
		}

	      lp = find_lwp_pid (pid_to_ptid (lwpid));

	      /* Check for stop events reported by a process we didn't
		 already know about - anything not already in our LWP
		 list.

		 If we're expecting to receive stopped processes after
		 fork, vfork, and clone events, then we'll just add the
		 new one to our list and go back to waiting for the event
		 to be reported - the stopped process might be returned
		 from waitpid before or after the event is.  */
	      if (WIFSTOPPED (status) && !lp)
		{
		  linux_record_stopped_pid (lwpid);
d2039 1
d2041 14
a2054 5
	      /* Make sure we don't report an event for the exit of an LWP not in
		 our list, i.e.  not part of the current process.  This can happen
		 if we detach from a program we original forked and then it
		 exits.  */
	      if (!WIFSTOPPED (status) && !lp)
d2056 2
a2057 2
		  status = 0;
		  continue;
d2060 4
a2063 28
	      /* NOTE drow/2003-06-17: This code seems to be meant for debugging
		 CLONE_PTRACE processes which do not use the thread library -
		 otherwise we wouldn't find the new LWP this way.  That doesn't
		 currently work, and the following code is currently unreachable
		 due to the two blocks above.  If it's fixed some day, this code
		 should be broken out into a function so that we can also pick up
		 LWPs from the new interface.  */
	      if (!lp)
		{
		  lp = add_lwp (BUILD_LWP (lwpid, GET_PID (inferior_ptid)));
		  if (options & __WCLONE)
		    lp->cloned = 1;

		  gdb_assert (WIFSTOPPED (status)
			      && WSTOPSIG (status) == SIGSTOP);
		  lp->signalled = 1;

		  if (!in_thread_list (inferior_ptid))
		    {
		      inferior_ptid = BUILD_LWP (GET_PID (inferior_ptid),
						 GET_PID (inferior_ptid));
		      add_thread (inferior_ptid);
		    }

		  add_thread (lp->ptid);
		  printf_unfiltered (_("[New %s]\n"),
				     target_pid_to_str (lp->ptid));
		}
d2065 1
a2065 13
	      /* Handle GNU/Linux's extended waitstatus for trace events.  */
	      if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
		{
		  if (debug_linux_nat)
		    fprintf_unfiltered (gdb_stdlog,
					"LLW: Handling extended status 0x%06x\n",
					status);
		  if (linux_nat_handle_extended (lp, status, 0))
		    {
		      status = 0;
		      continue;
		    }
		}
d2067 4
a2070 2
	      /* Check if the thread has exited.  */
	      if ((WIFEXITED (status) || WIFSIGNALED (status)) && num_lwps > 1)
a2071 50
		  /* If this is the main thread, we must stop all threads and
		     verify if they are still alive.  This is because in the nptl
		     thread model, there is no signal issued for exiting LWPs
		     other than the main thread.  We only get the main thread
		     exit signal once all child threads have already exited.
		     If we stop all the threads and use the stop_wait_callback
		     to check if they have exited we can determine whether this
		     signal should be ignored or whether it means the end of the
		     debugged application, regardless of which threading model
		     is being used.  */
		  if (GET_PID (lp->ptid) == GET_LWP (lp->ptid))
		    {
		      lp->stopped = 1;
		      iterate_over_lwps (stop_and_resume_callback, NULL);
		    }

		  if (debug_linux_nat)
		    fprintf_unfiltered (gdb_stdlog,
					"LLW: %s exited.\n",
					target_pid_to_str (lp->ptid));

		  exit_lwp (lp);

		  /* If there is at least one more LWP, then the exit signal
		     was not the end of the debugged application and should be
		     ignored.  */
		  if (num_lwps > 0)
		    {
		      /* Make sure there is at least one thread running.  */
		      gdb_assert (iterate_over_lwps (running_callback, NULL));

		      /* Discard the event.  */
		      status = 0;
		      continue;
		    }
		}

	      /* Check if the current LWP has previously exited.  In the nptl
		 thread model, LWPs other than the main thread do not issue
		 signals when they exit so we must check whenever the thread
		 has stopped.  A similar check is made in stop_wait_callback().  */
	      if (num_lwps > 1 && !linux_nat_thread_alive (lp->ptid))
		{
		  if (debug_linux_nat)
		    fprintf_unfiltered (gdb_stdlog,
					"LLW: %s exited.\n",
					target_pid_to_str (lp->ptid));

		  exit_lwp (lp);

d2079 1
d2081 10
a2090 22
	      /* Make sure we don't report a SIGSTOP that we sent
		 ourselves in an attempt to stop an LWP.  */
	      if (lp->signalled
		  && WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP)
		{
		  if (debug_linux_nat)
		    fprintf_unfiltered (gdb_stdlog,
					"LLW: Delayed SIGSTOP caught for %s.\n",
					target_pid_to_str (lp->ptid));

		  /* This is a delayed SIGSTOP.  */
		  lp->signalled = 0;

		  registers_changed ();
		  linux_ops->to_resume (pid_to_ptid (GET_LWP (lp->ptid)),
					lp->step, TARGET_SIGNAL_0);
		  if (debug_linux_nat)
		    fprintf_unfiltered (gdb_stdlog,
					"LLW: %s %s, 0, 0 (discard SIGSTOP)\n",
					lp->step ?
					"PTRACE_SINGLESTEP" : "PTRACE_CONT",
					target_pid_to_str (lp->ptid));
d2092 1
a2092 2
		  lp->stopped = 0;
		  gdb_assert (lp->resumed);
d2094 2
a2095 4
		  /* Discard the event.  */
		  status = 0;
		  continue;
		}
d2097 3
a2099 1
	      break;
d2102 4
a2105 1
	  if (pid == -1)
d2107 4
a2110 11
	      /* Alternate between checking cloned and uncloned processes.  */
	      options ^= __WCLONE;

	      /* And suspend every time we have checked both.  */
	      if (options & __WCLONE)
		sigsuspend (&suspend_mask);
	    }

	  /* We shouldn't end up here unless we want to try again.  */
	  gdb_assert (status == 0);
	}
d2112 2
a2113 2
      clear_sigio_trap ();
      clear_sigint_trap ();
a2114 25
      gdb_assert (lp);

      /* Don't report signals that GDB isn't interested in, such as
	 signals that are neither printed nor stopped upon.  Stopping all
	 threads can be a bit time-consuming so if we want decent
	 performance with heavily multi-threaded programs, especially when
	 they're using a high frequency timer, we'd better avoid it if we
	 can.  */

      if (WIFSTOPPED (status))
	{
	  int signo = target_signal_from_host (WSTOPSIG (status));

	  /* If we get a signal while single-stepping, we may need special
	     care, e.g. to skip the signal handler.  Defer to common code.  */
	  if (!lp->step
	      && signal_stop_state (signo) == 0
	      && signal_print_state (signo) == 0
	      && signal_pass_state (signo) == 1)
	    {
	      /* FIMXE: kettenis/2001-06-06: Should we resume all threads
		 here?  It is not clear we should.  GDB may not expect
		 other threads to run.  On the other hand, not resuming
		 newly attached threads may cause an unwanted delay in
		 getting them running.  */
d2117 1
a2117 1
				    lp->step, signo);
d2120 1
a2120 1
				    "LLW: %s %s, %s (preempt 'handle')\n",
d2123 2
a2124 2
				    target_pid_to_str (lp->ptid),
				    signo ? strsignal (signo) : "0");
d2126 3
d2130 1
a2130 1
	      goto retry;
d2133 11
a2143 8
	  if (signo == TARGET_SIGNAL_INT && signal_pass_state (signo) == 0)
	    {
	      /* If ^C/BREAK is typed at the tty/console, SIGINT gets
		 forwarded to the entire process group, that is, all LWP's
		 will receive it.  Since we only want to report it once,
		 we try to flush it from all LWPs except this one.  */
	      sigaddset (&flush_mask, SIGINT);
	    }
d2146 3
a2148 2
      /* This LWP is stopped now.  */
      lp->stopped = 1;
d2150 2
a2151 3
      if (debug_linux_nat)
	fprintf_unfiltered (gdb_stdlog, "LLW: Candidate event %s in %s.\n",
			    status_to_str (status), target_pid_to_str (lp->ptid));
d2153 1
a2153 2
      /* Now stop all other LWP's ...  */
      iterate_over_lwps (stop_callback, NULL);
d2155 6
a2160 10
      /* ... and wait until all of them have reported back that they're no
	 longer running.  */
      iterate_over_lwps (stop_wait_callback, &flush_mask);
      iterate_over_lwps (flush_callback, &flush_mask);

      /* If we're not waiting for a specific LWP, choose an event LWP from
	 among those that have had events.  Giving equal priority to all
	 LWPs that have had events helps prevent starvation.  */
      if (pid == -1)
	select_event_lwp (&lp, &status);
d2162 3
a2164 4
      /* Now that we've selected our final event LWP, cancel any
	 breakpoints in other LWPs that have hit a GDB breakpoint.  See
	 the comment in cancel_breakpoints_callback to find out why.  */
      iterate_over_lwps (cancel_breakpoints_callback, lp);
d2166 15
a2180 3
      if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP)
	{
	  trap_ptid = lp->ptid;
d2183 8
a2190 2
				"LLW: trap_ptid is %s.\n",
				target_pid_to_str (trap_ptid));
a2191 2
      else
	trap_ptid = null_ptid;
d2193 1
a2193 1
      if (lp->waitstatus.kind != TARGET_WAITKIND_IGNORE)
d2195 5
a2199 2
	  *ourstatus = lp->waitstatus;
	  lp->waitstatus.kind = TARGET_WAITKIND_IGNORE;
d2201 38
a2238 2
      else
	store_waitstatus (ourstatus, status);
d2240 4
a2243 1
      return lp->ptid;
d2245 4
@


1.47.2.2
log
@* linux-nat.c (linux_nat_attach, linux_nat_detach): Make attach/
detach work asynchronously.

* inf-ptrace.c (inf_ptrace_attach): Ditto.

* infcmd.c (attach_command): Ditto.

* inf-child.c (inf_child_target): Reset to_terminal_inferior/
to_terminal_ours to synchronous methods.

* async-nat-inferior.c (gdb_process_events): Don't poll for
exceptions.
(gdb_process_pending_event): Use pid_to_ptid.
(gdb_inferior_reset): Remove last_thread component.

* async-nat-inferior.h (struct gdb_inferior_status): Remove
last_thread component.
@
text
@d1008 9
a1016 1
  if (!target_can_async_p ())
d1018 1
a1018 11
      /* Add the initial process as the first LWP to the list.  */
      inferior_ptid = BUILD_LWP (GET_PID (inferior_ptid), GET_PID (inferior_ptid));
      lp = add_lwp (inferior_ptid);

      /* Make sure the initial process is stopped.  The user-level threads
	 layer might want to poke around in the inferior, and that won't
	 work if things haven't stabilized yet.  */
      pid = my_waitpid (GET_PID (inferior_ptid), &status, 0);
      if (pid == -1 && errno == ECHILD)
	{
	  warning (_("%s is a cloned process"), target_pid_to_str (inferior_ptid));
d1020 4
a1023 4
	  /* Try again with __WCLONE to check cloned processes.  */
	  pid = my_waitpid (GET_PID (inferior_ptid), &status, __WCLONE);
	  lp->cloned = 1;
	}
d1025 2
a1026 2
      gdb_assert (pid == GET_PID (inferior_ptid)
		  && WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP);
d1028 1
a1028 1
      lp->stopped = 1;
d1030 7
a1036 8
      /* Fake the SIGSTOP that core GDB expects.  */
      lp->status = W_STOPCODE (SIGSTOP);
      lp->resumed = 1;
      if (debug_linux_nat)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "LLA: waitpid %ld, faking SIGSTOP\n", (long) pid);
	}
d1102 1
a1102 3
  if (!target_can_async_p ())
    {
      iterate_over_lwps (detach_callback, NULL);
d1104 2
a1105 2
      /* Only the initial process should be left right now.  */
      gdb_assert (num_lwps == 1);
d1107 1
a1107 1
      trap_ptid = null_ptid;
d1109 2
a1110 3
      /* Destroy LWP info; it's no longer valid.  */
      init_lwp_list ();
    }
@


1.47.2.3
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d2735 1
a2735 2
  auxv_len = target_read_alloc (&current_target, TARGET_OBJECT_AUXV,
				NULL, &auxv);
d3217 2
@


1.47.2.4
log
@(linux_nat_mourn_inferior): Destroy thread.
Clear any pending events
@
text
@a2383 3
  if (target_can_async_p ())
    gdb_inferior_destroy (gdb_status);

a2398 2

  if (target_can_async_p ()) gdb_clear_pending_events ();
@


1.47.2.5
log
@(linux_nat_wait): Add inferior to LWP list for
async too and include lwp no in return value.
@
text
@a1848 28
  struct lwp_info *lp = NULL;
  int options = 0;
  int status = 0;
  pid_t pid = PIDGET (ptid);
  sigset_t flush_mask;

  /* The first time we get here after starting a new inferior, we may
     not have added it to the LWP list yet - this is the earliest
     moment at which we know its PID.  */
  if (num_lwps == 0)
    {
      gdb_assert (!is_lwp (inferior_ptid));

      inferior_ptid = BUILD_LWP (GET_PID (inferior_ptid),
				 GET_PID (inferior_ptid));
      lp = add_lwp (inferior_ptid);
      lp->resumed = 1;
      
    }

  sigemptyset (&flush_mask);

  /* Make sure SIGCHLD is blocked.  */
  if (!sigismember (&blocked_mask, SIGCHLD))
    {
      sigaddset (&blocked_mask, SIGCHLD);
      sigprocmask (SIG_BLOCK, &blocked_mask, NULL);
    }
d1859 1
d1871 1
a1871 1
      return BUILD_LWP (gdb_status->pid, gdb_status->pid);
d1875 28
@


1.47.2.6
log
@(linux_nat_resume): Move async stuff from
i386_linux_resume to here.
(linux_nat_attach): Add initial process for sync too.
@
text
@a50 1
#include "inf-loop.h"
a1007 4
  /* Add the initial process as the first LWP to the list.  */
  inferior_ptid = BUILD_LWP (GET_PID (inferior_ptid), GET_PID (inferior_ptid));
  lp = add_lwp (inferior_ptid);

d1010 4
d1020 1
a1020 2
	  warning (_("%s is a cloned process"),
		   target_pid_to_str (inferior_ptid));
a1164 1
  struct target_waitstatus status;
a1253 20

  if (target_can_async_p ())
    {
      status.kind = TARGET_WAITKIND_SPURIOUS;
      gdb_process_events (gdb_status, &status, 0, 0);

      if (gdb_post_pending_event ())
	{
	  /* QUESTION: Do I need to lie about target_executing here? */
	  if (target_is_async_p ())
	    target_executing = 1;
	  return;
	}

      target_async (inferior_event_handler, 0);
    }

  if (target_is_async_p ())
    target_executing = 1;

@


1.47.2.7
log
@(linux_test_for_tracefork): Re-insert call to
my_waitpid (removed inadvertantly).
(linux_nat_detach): Call init_lwp_list for asynchronous case too.
@
text
@a280 1
	  my_waitpid (second_pid, &status, 0);
d1110 1
a1110 1
      
a1112 1
    }
d1114 1
a1114 1
  trap_ptid = null_ptid;
d1116 3
a1118 2
  /* Destroy LWP info; it's no longer valid.  */
  init_lwp_list ();
@


1.47.2.8
log
@(linux_nat_resume): Call to_resume method later.
@
text
@d1257 2
a1260 5
      /* Check for pending events.  If we find any, then we won't really
     resume, but rather we will extract the first event from the pending events
     queue, and post it to the gdb event queue, and then "pretend" that we have
     in fact resumed. */

a1270 3
    }

  linux_ops->to_resume (ptid, step, signo);
a1271 1
  if (target_can_async_p ())
d1273 1
d1920 1
a1920 3
	{
	  return null_ptid;
	}
@


1.46
log
@	* linux-nat.c (exit_lwp): Fix NULL pointer access.
	(linux_nat_handle_extended): New parameter STOPPING.
	(wait_lwp): Call it with STOPPING equals 1.
	(linux_nat_wait): Call it with STOPPING equals 0.
@
text
@d2552 1
a2552 1
  int core_regset_p, record_reg_p;
d2555 6
a2560 11
  record_reg_p = 1;
  if (core_regset_p)
    {
      regset = gdbarch_regset_from_core_section (gdbarch, ".reg",
						 sizeof (gregs));
      if (regset)
	regset->collect_regset (regset, current_regcache, -1,
				&gregs, sizeof (gregs));
      else
	record_reg_p = 0;
    }
d2564 12
a2575 18
  if (record_reg_p)
    note_data = (char *) elfcore_write_prstatus (obfd,
						 note_data,
						 note_size,
						 lwp,
						 stop_signal, &gregs);

  record_reg_p = 1;
  if (core_regset_p)
    {
      regset = gdbarch_regset_from_core_section (gdbarch, ".reg2",
						 sizeof (fpregs));
      if (regset)
	regset->collect_regset (regset, current_regcache, -1,
				&fpregs, sizeof (fpregs));
      else
	record_reg_p = 0;
    }
d2579 4
a2582 5
  if (record_reg_p)
    note_data = (char *) elfcore_write_prfpreg (obfd,
						note_data,
						note_size,
						&fpregs, sizeof (fpregs));
d2585 6
a2590 11
  record_reg_p = 1;
  if (core_regset_p)
    {
      regset = gdbarch_regset_from_core_section (gdbarch, ".reg-xfp",
						 sizeof (fpxregs));
      if (regset)
	regset->collect_regset (regset, current_regcache, -1,
				&fpxregs, sizeof (fpxregs));
      else
	record_reg_p = 0;
    }
d2594 4
a2597 5
  if (record_reg_p)
    note_data = (char *) elfcore_write_prxfpreg (obfd,
						 note_data,
						 note_size,
						 &fpxregs, sizeof (fpxregs));
@


1.45
log
@	* linux-nat.c (linux_nat_wait): Do not short-cut reporting
	of 'uninteresting' signals when single-stepping.
@
text
@d903 7
a909 4
      if (thr && !ptid_equal (thr->ptid, inferior_ptid))
	delete_thread (thr->ptid);
      else
	record_dead_thread (thr->ptid);
d1285 2
a1286 1
   the event should be ignored and we should wait again.  */
d1289 1
a1289 1
linux_nat_handle_extended (struct lwp_info *lp, int status)
d1301 5
a1305 1
      new_lp->stopped = 1;
d1389 1
a1389 1
      if (linux_nat_handle_extended (lp, status))
d2034 1
a2034 1
	      if (linux_nat_handle_extended (lp, status))
@


1.44
log
@	* linux-nat.c (linux_nat_do_thread_registers): Use the
	regset_from_core_section infrastructure if the target
	supports it.
	* Makefile.in: Update dependencies.
@
text
@d2158 4
a2161 1
      if (signal_stop_state (signo) == 0
@


1.43
log
@Fix typo in previous commit.
@
text
@d39 1
d2539 45
a2584 12
  fill_gregset (&gregs, -1);
  note_data = (char *) elfcore_write_prstatus (obfd,
					       note_data,
					       note_size,
					       lwp,
					       stop_signal, &gregs);

  fill_fpregset (&fpregs, -1);
  note_data = (char *) elfcore_write_prfpreg (obfd,
					      note_data,
					      note_size,
					      &fpregs, sizeof (fpregs));
d2586 19
a2604 5
  fill_fpxregset (&fpxregs, -1);
  note_data = (char *) elfcore_write_prxfpreg (obfd,
					       note_data,
					       note_size,
					       &fpxregs, sizeof (fpxregs));
@


1.42
log
@	* linux-nat.c (linux_nat_thread_alive): Handle targets that
	do not implement PTRACE_PEEKUSER.
@
text
@d2391 1
a2391 1
  if (errno == -ESRCH || errno == -EPERM)
@


1.41
log
@	* linux-thread-db.c: Include "linux-nat.h".
	(check_for_thread_db): New function, split out from
	thread_db_new_objfile.  Remove dead check for active
	thread_db on inapplicable targets.
	(thread_db_new_objfile): Call check_for_thread_db.
	* Makefile.in (linux-thread-db.o): Update.
	* linux-nat.c (child_post_attach): Call check_for_thread_db.
	(linux_child_post_startup_inferior): Likewise.
	(lin_lwp_attach_lwp): Call target_post_attach instead of
	child_post_attach.
	* linux-nat.h (check_for_thread_db): New prototype.
@
text
@d2385 7
a2391 1
  if (errno)
@


1.40
log
@	* linux-nat.c (linux_ops_saved): New.
	(super_mourn_inferior, kill_inferior, threaded, linux_nat_ops)
	(child_mourn_inferior, child_wait, linux_nat_create_inferior)
	(linux_nat_fetch_registers, linux_nat_store_registers)
	(linux_nat_child_post_startup_inferior, init_linux_nat_ops): Delete.
	(init_lwp_list): Don't set threaded.
	(add_lwp): Don't modify threaded.
	(delete_lwp): Don't mention non-threaded mode.
	(linux_nat_switch_fork): New.
	(linux_nat_attach): Update inferior_ptid.
	(linux_nat_wait): Handle num_lwps == 0 at entry.  Don't check
	threaded flag.
	(linux_nat_kill): Handle pending forks and saved forks.
	(linux_nat_mourn_inferior): Handle saved forks.
	(linux_nat_pid_to_str): Don't use the LWP form when there is
	only one thread.
	(linux_target): Don't set to_wait, to_kill, or to_mourn_inferior.
	(linux_nat_add_target): New.
	(_initialize_linux_nat): Don't initialize the linux native target
	here.
	* linux-nat.h (linux_nat_add_target, linux_nat_switch_fork): New
	prototypes.
	* linux-fork.c: Include "linux-nat.h".
	(add_fork): Update initial PID.
	(fork_load_infrun_state): Call linux_nat_switch_fork.
	* Makefile.in (linux-fork.o): Update.

	* alpha-linux-nat.c (_initialize_alpha_linux_nat): Use
	linux_nat_add_target instead of add_target.
	* amd64-linux-nat.c (_initialize_amd64_linux_nat): Likewise.
	* arm-linux-nat.c (_initialize_arm_linux_nat): Likewise.
	* hppa-linux-nat.c (_initialize_hppa_linux_nat): Likewise.
	* ia64-linux-nat.c (_initialize_ia64_linux_nat): Likewise.
	* i386-linux-nat.c (_initialize_i386_linux_nat): Likewise.
	* m32r-linux-nat.c (_initialize_m32r_linux_nat): Likewise.
	* m68klinux-nat.c (_initialize_m68k_linux_nat): Likewise.
	* mips-linux-nat.c (_initialize_mips_linux_nat): Likewise.
	* ppc-linux-nat.c (_initialize_ppc_linux_nat): Likewise.
	* s390-nat.c (_initialize_s390_nat): Likewise.
	* sparc-linux-nat.c (_initialize_sparc_linux_nat): Likewise.
	* sparc64-linux-nat.c (_initialize_sparc64_linux_nat): Likewise.
@
text
@d337 1
d344 1
d968 1
a968 1
      child_post_attach (pid);
@


1.39
log
@2006-03-09  Michael Snyder  <msnyder@@redhat.com>

	* linux-nat.c (kill_inferior): Just call target_mourn_inferior
	instead of getting tricky for the multi-fork case.
	* linux-fork.c (linux_fork_killall): Call PT_KILL and waitpid
	for each fork, and then use init_fork_list to delete them.
@
text
@d91 1
a100 4
/* The saved to_mourn_inferior method, inherited from inf-ptrace.c.
   Called by our to_mourn_inferior.  */
static void (*super_mourn_inferior) (void);

a599 48
void
kill_inferior (void)
{
  int status;
  int pid =  PIDGET (inferior_ptid);
  struct target_waitstatus last;
  ptid_t last_ptid;
  int ret;

  if (pid == 0)
    return;

  /* First cut -- let's crudely do everything inline.  */
  if (forks_exist_p ())
    {
      linux_fork_killall ();
    }
  else
    {
      /* If we're stopped while forking and we haven't followed yet,
	 kill the other task.  We need to do this first because the
	 parent will be sleeping if this is a vfork.  */

      get_last_target_status (&last_ptid, &last);

      if (last.kind == TARGET_WAITKIND_FORKED
	  || last.kind == TARGET_WAITKIND_VFORKED)
	{
	  ptrace (PT_KILL, last.value.related_pid, 0, 0);
	  wait (&status);
	}

      /* Kill the current process.  */
      ptrace (PT_KILL, pid, 0, 0);
      ret = wait (&status);

      /* We might get a SIGCHLD instead of an exit status.  This is
	 aggravated by the first kill above - a child has just died.  */

      while (ret == pid && WIFSTOPPED (status))
	{
	  ptrace (PT_KILL, pid, 0, 0);
	  ret = wait (&status);
	}
    }
  target_mourn_inferior ();
}

a637 3

/* Non-zero if we're running in "threaded" mode.  */
static int threaded;
a649 3
/* This module's target-specific operations.  */
static struct target_ops linux_nat_ops;

a713 1
  threaded = 0;
d716 2
a717 3
/* Add the LWP specified by PID to the list.  If this causes the
   number of LWPs to become larger than one, go into "threaded" mode.
   Return a pointer to the structure describing the new LWP.  */
d736 1
a736 2
  if (++num_lwps > 1)
    threaded = 1;
a756 2
  /* We don't go back to "non-threaded" mode if the number of threads
     becomes less than two.  */
d808 15
d1002 2
a1003 1
  lp = add_lwp (BUILD_LWP (GET_PID (inferior_ptid), GET_PID (inferior_ptid)));
a1804 128
/* Local mourn_inferior -- we need to override mourn_inferior
   so that we can do something clever if one of several forks
   has exited.  */

static void
child_mourn_inferior (void)
{
  int status;

  if (! forks_exist_p ())
    {
      /* Normal case, no other forks available.  */
      super_mourn_inferior ();
      return;
    }
  else
    {
      /* Multi-fork case.  The current inferior_ptid has exited, but
	 there are other viable forks to debug.  Delete the exiting
	 one and context-switch to the first available.  */
      linux_fork_mourn_inferior ();
    }
}

/* We need to override child_wait to support attaching to cloned
   processes, since a normal wait (as done by the default version)
   ignores those processes.  */

/* Wait for child PTID to do something.  Return id of the child,
   minus_one_ptid in case of error; store status into *OURSTATUS.  */

ptid_t
child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  int save_errno;
  int status;
  pid_t pid;

  ourstatus->kind = TARGET_WAITKIND_IGNORE;

  do
    {
      set_sigint_trap ();	/* Causes SIGINT to be passed on to the
				   attached process.  */
      set_sigio_trap ();

      pid = my_waitpid (GET_PID (ptid), &status, 0);
      if (pid == -1 && errno == ECHILD)
	/* Try again with __WCLONE to check cloned processes.  */
	pid = my_waitpid (GET_PID (ptid), &status, __WCLONE);

      if (debug_linux_nat)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "CW:  waitpid %ld received %s\n",
			      (long) pid, status_to_str (status));
	}

      save_errno = errno;

      /* Make sure we don't report an event for the exit of the
         original program, if we've detached from it.  */
      if (pid != -1 && !WIFSTOPPED (status) && pid != GET_PID (inferior_ptid))
	{
	  pid = -1;
	  save_errno = EINTR;
	}

      /* Check for stop events reported by a process we didn't already
	 know about - in this case, anything other than inferior_ptid.

	 If we're expecting to receive stopped processes after fork,
	 vfork, and clone events, then we'll just add the new one to
	 our list and go back to waiting for the event to be reported
	 - the stopped process might be returned from waitpid before
	 or after the event is.  If we want to handle debugging of
	 CLONE_PTRACE processes we need to do more here, i.e. switch
	 to multi-threaded mode.  */
      if (pid != -1 && WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP
	  && pid != GET_PID (inferior_ptid))
	{
	  linux_record_stopped_pid (pid);
	  pid = -1;
	  save_errno = EINTR;
	}

      /* Handle GNU/Linux's extended waitstatus for trace events.  */
      if (pid != -1 && WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP
	  && status >> 16 != 0)
	{
	  linux_handle_extended_wait (pid, status, ourstatus);

	  /* If we see a clone event, detach the child, and don't
	     report the event.  It would be nice to offer some way to
	     switch into a non-thread-db based threaded mode at this
	     point.  */
	  if (ourstatus->kind == TARGET_WAITKIND_SPURIOUS)
	    {
	      ptrace (PTRACE_DETACH, ourstatus->value.related_pid, 0, 0);
	      ourstatus->kind = TARGET_WAITKIND_IGNORE;
	      ptrace (PTRACE_CONT, pid, 0, 0);
	      pid = -1;
	      save_errno = EINTR;
	    }
	}

      clear_sigio_trap ();
      clear_sigint_trap ();
    }
  while (pid == -1 && save_errno == EINTR);

  if (pid == -1)
    {
      warning (_("Child process unexpectedly missing: %s"),
	       safe_strerror (errno));

      /* Claim it exited with unknown signal.  */
      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
      ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
      return minus_one_ptid;
    }

  if (ourstatus->kind == TARGET_WAITKIND_IGNORE)
    store_waitstatus (ourstatus, status);

  return pid_to_ptid (pid);
}

d1836 13
d1860 2
a1861 3
  /* Make sure there is at least one LWP that has been resumed, at
     least if there are any LWPs at all.  */
  gdb_assert (num_lwps == 0 || iterate_over_lwps (resumed_callback, NULL));
d2000 5
a2004 1
	      if (threaded)
d2006 4
a2009 3
		  gdb_assert (WIFSTOPPED (status)
			      && WSTOPSIG (status) == SIGSTOP);
		  lp->signalled = 1;
d2011 3
a2013 11
		  if (!in_thread_list (inferior_ptid))
		    {
		      inferior_ptid = BUILD_LWP (GET_PID (inferior_ptid),
						 GET_PID (inferior_ptid));
		      add_thread (inferior_ptid);
		    }

		  add_thread (lp->ptid);
		  printf_unfiltered (_("[New %s]\n"),
				     target_pid_to_str (lp->ptid));
		}
a2214 3
  /* If we're not running in "threaded" mode, we'll report the bare
     process id.  */

d2217 1
a2217 1
      trap_ptid = (threaded ? lp->ptid : pid_to_ptid (GET_LWP (lp->ptid)));
d2234 1
a2234 1
  return (threaded ? lp->ptid : pid_to_ptid (GET_LWP (lp->ptid)));
d2299 7
a2305 2
  /* Kill all LWP's ...  */
  iterate_over_lwps (kill_callback, NULL);
d2307 19
a2325 2
  /* ... and wait until we've flushed all events.  */
  iterate_over_lwps (kill_wait_callback, NULL);
a2330 7
linux_nat_create_inferior (char *exec_file, char *allargs, char **env,
			 int from_tty)
{
  linux_ops->to_create_inferior (exec_file, allargs, env, from_tty);
}

static void
d2342 8
a2349 1
  linux_ops->to_mourn_inferior ();
d2394 1
a2394 1
  if (is_lwp (ptid))
a2403 53
linux_nat_fetch_registers (int regnum)
{
  /* to_fetch_registers will honor the LWP ID, so we can use it directly.  */
  linux_ops->to_fetch_registers (regnum);
}

static void
linux_nat_store_registers (int regnum)
{
  /* to_store_registers will honor the LWP ID, so we can use it directly.  */
  linux_ops->to_store_registers (regnum);
}

static void
linux_nat_child_post_startup_inferior (ptid_t ptid)
{
  linux_ops->to_post_startup_inferior (ptid);
}

static void
init_linux_nat_ops (void)
{
#if 0
  linux_nat_ops.to_open = linux_nat_open;
#endif
  linux_nat_ops.to_shortname = "lwp-layer";
  linux_nat_ops.to_longname = "lwp-layer";
  linux_nat_ops.to_doc = "Low level threads support (LWP layer)";
  linux_nat_ops.to_attach = linux_nat_attach;
  linux_nat_ops.to_detach = linux_nat_detach;
  linux_nat_ops.to_resume = linux_nat_resume;
  linux_nat_ops.to_wait = linux_nat_wait;
  linux_nat_ops.to_fetch_registers = linux_nat_fetch_registers;
  linux_nat_ops.to_store_registers = linux_nat_store_registers;
  linux_nat_ops.to_xfer_partial = linux_nat_xfer_partial;
  linux_nat_ops.to_kill = linux_nat_kill;
  linux_nat_ops.to_create_inferior = linux_nat_create_inferior;
  linux_nat_ops.to_mourn_inferior = linux_nat_mourn_inferior;
  linux_nat_ops.to_thread_alive = linux_nat_thread_alive;
  linux_nat_ops.to_pid_to_str = linux_nat_pid_to_str;
  linux_nat_ops.to_post_startup_inferior
    = linux_nat_child_post_startup_inferior;
  linux_nat_ops.to_post_attach = child_post_attach;
  linux_nat_ops.to_insert_fork_catchpoint = child_insert_fork_catchpoint;
  linux_nat_ops.to_insert_vfork_catchpoint = child_insert_vfork_catchpoint;
  linux_nat_ops.to_insert_exec_catchpoint = child_insert_exec_catchpoint;

  linux_nat_ops.to_stratum = thread_stratum;
  linux_nat_ops.to_has_thread_control = tc_schedlock;
  linux_nat_ops.to_magic = OPS_MAGIC;
}

static void
a3113 2
  t->to_wait = child_wait;
  t->to_kill = kill_inferior;
d3127 2
a3128 2
  super_mourn_inferior = t->to_mourn_inferior;
  t->to_mourn_inferior = child_mourn_inferior;
d3130 35
a3164 2
  linux_ops = t;
  return t;
a3170 1
  extern void thread_db_init (struct target_ops *);
a3180 4
  init_linux_nat_ops ();
  add_target (&linux_nat_ops);
  thread_db_init (&linux_nat_ops);

@


1.38
log
@	* linux-nat.c (lin_thread_get_thread_signals): Default to __SIGRTMIN
	and __SIGRTMIN + 1.
@
text
@a618 2
      pop_target ();
      generic_mourn_inferior ();
a646 1
      target_mourn_inferior ();
d648 1
@


1.38.2.1
log
@Merge XML and VFP support to this branch.
@
text
@d2852 1
a2852 2
  auxv_len = target_read_whole (&current_target, TARGET_OBJECT_AUXV, NULL,
				&auxv);
@


1.38.4.1
log
@Initial version of available features support.
@
text
@d2852 1
a2852 2
  auxv_len = target_read_whole (&current_target, TARGET_OBJECT_AUXV, NULL,
				&auxv);
@


1.37
log
@	* linux-nat.c (struct saved_ptids, threads_to_delete)
	(record_dead_thread, prune_lwps, find_thread_from_lwp)
	(exit_lwp): New.
	(linux_nat_resume): Call prune_lwps.
	(wait_lwp, linux_nat_wait): Call exit_lwp.
@
text
@d3416 7
d3424 1
a3424 1
    return;
a3425 1
  cancel = get_signo ("__pthread_sig_cancel");
d3427 1
a3427 1
    return;
@


1.36
log
@2006-01-04  Michael Snyder  <msnyder@@redhat.com>

	Checkpoint/Restart for Linux.
	* linux-nat.c: Add support for debugging multiple forks.
	Add #include for linux-fork.h (interface spec).
	(super_mourn_inferior): New function pointer.
	(child_mourn_inferior): New function / target method.
	(linux_target): Claim to_mourn_inferior method pointer.
	(child_follow_fork): Call interface to linux-fork, conditionally
	add new fork processes to list of debugged processes.
	(kill_inferior): Use interface to linux-fork to kill
	multiple processes.

	* linux-fork.h: New file.
	* linux-fork.c: New file.  Support for debugging multiple forks
	of the same program.  Support for checkpoint and restart commands.

	* infrun.c (nullify_last_target_wait_ptid): New function.

	* Makefile.in: Add linux-fork.
	* config/*/linux.mh: Add linux-fork.
	* NEWS: Mention new functionality.
@
text
@d3 2
a4 1
   Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d872 86
d1211 2
d1413 1
a1413 10
      if (in_thread_list (lp->ptid))
	{
	  /* Core GDB cannot deal with us deleting the current thread.  */
	  if (!ptid_equal (lp->ptid, inferior_ptid))
	    delete_thread (lp->ptid);
	  printf_unfiltered (_("[%s exited]\n"),
			     target_pid_to_str (lp->ptid));
	}

      delete_lwp (lp->ptid);
a2199 10
	      if (in_thread_list (lp->ptid))
		{
		  /* Core GDB cannot deal with us deleting the current
		     thread.  */
		  if (!ptid_equal (lp->ptid, inferior_ptid))
		    delete_thread (lp->ptid);
		  printf_unfiltered (_("[%s exited]\n"),
				     target_pid_to_str (lp->ptid));
		}

d2221 1
a2221 1
	      delete_lwp (lp->ptid);
a2242 9
	      if (in_thread_list (lp->ptid))
		{
		  /* Core GDB cannot deal with us deleting the current
		     thread.  */
		  if (!ptid_equal (lp->ptid, inferior_ptid))
		    delete_thread (lp->ptid);
		  printf_unfiltered (_("[%s exited]\n"),
				     target_pid_to_str (lp->ptid));
		}
d2248 1
a2248 1
	      delete_lwp (lp->ptid);
@


1.35
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d34 1
d91 6
a96 4
/* The saved to_xfer_partial method, inherited from inf-ptrace.c.  Called
   by our to_xfer_partial.   */
static LONGEST (*super_xfer_partial) (struct target_ops *, enum target_object,
				      const char *, gdb_byte *, const gdb_byte *,
d99 4
d373 14
a386 1
      if (debug_linux_nat)
d388 6
a393 4
	  target_terminal_ours ();
	  fprintf_unfiltered (gdb_stdlog,
			      "Detaching after fork from child process %d.\n",
			      child_pid);
a395 2
      ptrace (PTRACE_DETACH, child_pid, 0, 0);

d464 3
a466 3
	  fprintf_unfiltered (gdb_stdlog,
			      "Attaching after fork to child process %d.\n",
			      child_pid);
d489 9
d499 3
a501 1
	target_detach (NULL, 0);
d507 1
d614 2
a615 8
  /* If we're stopped while forking and we haven't followed yet, kill the
     other task.  We need to do this first because the parent will be
     sleeping if this is a vfork.  */

  get_last_target_status (&last_ptid, &last);

  if (last.kind == TARGET_WAITKIND_FORKED
      || last.kind == TARGET_WAITKIND_VFORKED)
d617 3
a619 2
      ptrace (PT_KILL, last.value.related_pid, 0, 0);
      wait (&status);
d621 5
d627 1
a627 3
  /* Kill the current process.  */
  ptrace (PT_KILL, pid, 0, 0);
  ret = wait (&status);
d629 6
a634 2
  /* We might get a SIGCHLD instead of an exit status.  This is
     aggravated by the first kill above - a child has just died.  */
d636 1
a636 2
  while (ret == pid && WIFSTOPPED (status))
    {
d639 10
a649 2

  target_mourn_inferior ();
d1721 1
a1721 1
  /* Record the wait status for the origional LWP.  */
d1773 24
d3269 3
d3383 1
@


1.34
log
@	* linux-nat.c (linux_nat_resume): Add more debugging messages.  Do
	not short-circuit resuming all threads if the signal will be ignored
	in linux_nat_wait.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.34.4.1
log
@2005-11-21  Michael Snyder  <msnyder@@redhat.com>

	* linux-nat.c: Add crude checkpoint/restart using forks.

	(child_follow_fork): Put a conditional around PTRACE_DETACH.
	FIXME needs to be done in the parent branch too.
	(__initialize_linux_nat): Call checkpoint_init.
	(struct fork_info): Analog of thread_info.
	(fork_load_infrun_state, fork_save_infrun_state):
	Save and restore necessary info for fork context switch.
	(add_fork, free_fork, delete_fork, find_fork_id, init_fork_list,
	find_fork_ptid, iterate_over_forks, valid_fork_id, pid_to_fork_id,
	fork_id_to_ptid, in_fork_list): Analogs to thread_list methods.
	(info_forks_command): Implement "info forks" (info checkpoints).
	(delete_checkpoint): Implement "delete-checkpoint" command.
	(checkpoint_command): Implement "checkpoint" command.
	(restart_command): Implement "restart" command.
	(checkpoint_init): Initialization for checkpoint sub-module.

	* infrun.c (set_last_target_status): Supporting function
	for checkpoint/restart based on forks (linux).
@
text
@a48 2
#include "infcall.h"		/* for call_function_by_hand */

a339 2
int forky_forky;

d374 1
a374 3
      /* Don't detach if doing forky command.  */
      if (!forky_forky)
	ptrace (PTRACE_DETACH, child_pid, 0, 0);
a3210 1
  static void checkpoint_init (void);
a3247 1
  checkpoint_init ();
a3314 378

/* Hack and slash, steal code from all over the place, 
   and just try stuff out.  */

struct fork_info
{
  struct fork_info *next;
  ptid_t ptid;			/* "Actual process id";
				    In fact, this may be overloaded with 
				    kernel thread id, etc.  */
  int num;			/* Convenient handle (GDB fork id) */
  struct inferior_status *status;
  struct regcache *savedregs;

  ptid_t last_target_ptid;
  struct target_waitstatus last_target_waitstatus;
};

/* Load infrun state for the fork PTID.  */

static void
fork_load_infrun_state (struct fork_info *fp)
{
  if (fp->status)
    {
      restore_inferior_status (fp->status);
      fp->status = NULL;
    }
  if (fp->savedregs)
    regcache_cpy (current_regcache, fp->savedregs);
  set_last_target_status (fp->ptid, fp->last_target_waitstatus);
}

/* Save infrun state for the fork PTID.  */

static void
fork_save_infrun_state (struct fork_info *fp)
{
  fp->status = save_inferior_status (0);
  fp->savedregs = regcache_dup (current_regcache);
  get_last_target_status (&fp->last_target_ptid, 
			  &fp->last_target_waitstatus);
}

static struct fork_info *fork_list = NULL;
static int highest_fork_num;

struct fork_info *
add_fork (ptid_t ptid)
{
  struct fork_info *fp;

  fp = (struct fork_info *) xmalloc (sizeof (*fp));
  memset (fp, 0, sizeof (*fp));
  fp->ptid = ptid;
  fp->num = ++highest_fork_num;
  fp->next = fork_list;
  fork_list = fp;
  return fp;
}

static void
free_fork (struct fork_info *fp)
{
  /* FIXME: take care of any left-over step_resume breakpoints.  */
  if (fp)
    {
      if (fp->status)
	xfree (fp->status);
      if (fp->savedregs)
	regcache_xfree (fp->savedregs);
      xfree (fp);
    }
}

void
delete_fork (ptid_t ptid)
{
  struct fork_info *fp, *fpprev;

  fpprev = NULL;

  for (fp = fork_list; fp; fpprev = fp, fp = fp->next)
    if (ptid_equal (fp->ptid, ptid))
      break;

  if (!fp)
    return;

  if (fpprev)
    fpprev->next = fp->next;
  else
    fork_list = fp->next;

  free_fork (fp);
}

static struct fork_info *
find_fork_id (int num)
{
  struct fork_info *fp;

  for (fp = fork_list; fp; fp = fp->next)
    if (fp->num == num)
      return fp;

  return NULL;
}

void
init_fork_list (void)
{
  struct fork_info *fp, *fpnext;

  highest_fork_num = 0;
  if (!fork_list)
    return;

  for (fp = fork_list; fp; fp = fpnext)
    {
      fpnext = fp->next;
      free_fork (fp);
    }

  fork_list = NULL;
}

/* Find a fork_info by matching PTID.  */
struct fork_info *
find_fork_ptid (ptid_t ptid)
{
  struct fork_info *fp;

  for (fp = fork_list; fp; fp = fp->next)
    if (ptid_equal (fp->ptid, ptid))
      return fp;

  return NULL;
}

/*
 * Fork iterator function.
 *
 * Calls a callback function once for each fork, so long as
 * the callback function returns false.  If the callback function
 * returns true, the iteration will end and the current fork
 * will be returned.  This can be useful for implementing a 
 * search for a fork with arbitrary attributes, or for applying
 * some operation to every fork.
 *
 * FIXME: some of the existing functionality, such as 
 * "Fork apply all", might be rewritten using this functionality.
 */

struct fork_info *
iterate_over_forks (int (*callback) (struct fork_info *, void *),
		      void *data)
{
  struct fork_info *fp;

  for (fp = fork_list; fp; fp = fp->next)
    if ((*callback) (fp, data))
      return fp;

  return NULL;
}

int
valid_fork_id (int num)
{
  struct fork_info *fp;

  for (fp = fork_list; fp; fp = fp->next)
    if (fp->num == num)
      return 1;

  return 0;
}

int
pid_to_fork_id (ptid_t ptid)
{
  struct fork_info *fp;

  for (fp = fork_list; fp; fp = fp->next)
    if (ptid_equal (fp->ptid, ptid))
      return fp->num;

  return 0;
}

ptid_t
fork_id_to_ptid (int num)
{
  struct fork_info *fork = find_fork_id (num);
  if (fork)
    return fork->ptid;
  else
    return pid_to_ptid (-1);
}

static void
delete_checkpoint (char *args, int from_tty)
{
  ptid_t ptid;

  if (!args || !*args)
    error ("Requires argument (checkpoint id to delete, see info checkpoint)");

  ptid = fork_id_to_ptid (strtol (args, NULL, 0));
  if (ptrace (PTRACE_KILL, ptid, 0, 0))
    error ("Unable to kill pid %s", target_tid_to_str (ptid));

  delete_fork (ptid);
}

int
in_fork_list (ptid_t ptid)
{
  struct fork_info *fp;

  for (fp = fork_list; fp; fp = fp->next)
    if (ptid_equal (fp->ptid, ptid))
      return 1;

  return 0;			/* Never heard of 'im */
}

/* Print information about currently known forks 

 * Note: this has the drawback that it _really_ switches
 *       forks, which frees the frame cache.  A no-side
 *       effects info-forks command would be nicer.
 */

static void
info_forks_command (char *arg, int from_tty)
{
  struct frame_info *cur_frame;
  struct symtab_and_line sal;
  struct symtab *cur_symtab;
  struct fork_info *fp;
  int cur_line;
  ULONGEST pc;

  for (fp = fork_list; fp; fp = fp->next)
    {
      if (ptid_equal (fp->ptid, inferior_ptid))
	printf_filtered ("* ");
      else
	printf_filtered ("  ");
      printf_filtered ("%d %s", fp->num, target_tid_to_str (fp->ptid));
      regcache_raw_read_unsigned (fp->savedregs, PC_REGNUM, &pc);
      printf_filtered (" at ");
      deprecated_print_address_numeric (pc, 1, gdb_stdout);

      sal = find_pc_line (pc, 0);
      if (sal.symtab)
	printf_filtered (", file %s", sal.symtab->filename);
      if (sal.line)
	printf_filtered (", line %d", sal.line);

      putchar_filtered ('\n');
    }
}

static void
checkpoint_command (char *args, int from_tty)
{
  struct target_waitstatus last_target_waitstatus;
  ptid_t last_target_ptid;
  struct value *fork_fn = NULL, *ret;
  struct fork_info *fp;
  pid_t retpid;
  long i;

  /* Make the inferior fork, record its (and gdb's) state.  */

  if (lookup_minimal_symbol ("fork", NULL, NULL) != NULL)
    fork_fn = find_function_in_inferior ("fork");
  if (!fork_fn)
    if (lookup_minimal_symbol ("_fork", NULL, NULL) != NULL)
      fork_fn = find_function_in_inferior ("fork");
  if (!fork_fn)
    error ("checkpoint: can't find fork function in inferior.");

  ret = value_from_longest (builtin_type_int, 0);
  forky_forky = 1;
  ret = call_function_by_hand (fork_fn, 0, &ret);
  forky_forky = 0;
  if (!ret)	/* Probably can't happen.  */
    error ("checkpoint: call_function_by_hand returned null.");

  retpid = value_as_long (ret);
  get_last_target_status (&last_target_ptid, &last_target_waitstatus);
  if (from_tty)
    {
      int parent_pid;

      printf_filtered ("checkpoint: fork returned %ld.\n", (long) retpid);
      parent_pid = ptid_get_lwp (last_target_ptid);
      if (parent_pid == 0)
	parent_pid = ptid_get_pid (last_target_ptid);
      printf_filtered ("   gdb says parent = %ld.\n", (long) parent_pid);
    }

  fp = add_fork (pid_to_ptid (retpid));
  fork_save_infrun_state (fp);

  /* FIXME: The new fork is still in the call_function_by_hand
     state, in the call to fork.  It should be sufficient to just
     copy its registers from the current state.  */

  if (info_verbose && from_tty)
    {
      printf_filtered ("retpid registers:\n");
      errno = 0;
      for (i = 0; errno == 0; i += 4)
	printf_filtered ("0x%08lx\n", 
			 ptrace (PTRACE_PEEKUSER, retpid, i, 0));
      errno = 0;
    }
}

#include "string.h"

static void
restart_command (char *args, int from_tty)
{
  /* Now we attempt to switch processes.  */
  struct fork_info *oldfp = find_fork_ptid (inferior_ptid);
  struct fork_info *newfp;
  ptid_t ptid;
  int id;

  if (!args || !*args)
    error ("Requires argument (checkpoint or fork id, see info checkpoint)");

  id = strtol (args, NULL, 0);
  newfp = find_fork_id (id);
  if (!newfp)
    error ("No such checkpoint id: %d\n", id);

  if (!oldfp)
    {
      oldfp = add_fork (inferior_ptid);
    }

  fork_save_infrun_state (oldfp);
  inferior_ptid = newfp->ptid;
  fork_load_infrun_state (newfp);
  flush_cached_frames ();
  registers_changed ();
  stop_pc = read_pc ();
  select_frame (get_current_frame ());
  printf_filtered ("Switching to %s\n", 
		   target_pid_or_tid_to_str (inferior_ptid));
  print_stack_frame (get_selected_frame (NULL), 1, SRC_AND_LOC);
}




static void
checkpoint_init (void)
{
  init_fork_list ();
  add_com ("checkpoint", class_obscure, checkpoint_command, _("\
Fork a duplicate process (experimental)."));
  add_com ("restart", class_obscure, restart_command, _("\
Flip from parent to child (experimental)."));
  add_com ("delete-checkpoint", class_obscure, delete_checkpoint, _("\
Delete a fork/checkpoint (experimental)."));
  add_info ("checkpoints", info_forks_command,
	    _("IDs of currently known forks/checkpoints."));
  add_info_alias ("forks", "checkpoints", 0);
}

@


1.34.4.2
log
@2005-11-23  Michael Snyder  <msnyder@@redhat.com>

	* linux-nat.c: Adapt fork list to work with follow_fork.

	(child_follow_fork): Add non-detached fork to fork list.
	Handle follow-child as well as follow-parent.
	(fork_load_infrun_state, fork_save_infrun_state):
	Don't save any actual infrun state except for last_ptid.
	Just save registers, and add the option of NOT restoring them.
	Also don't leak regcache objects.
	(add_fork): Accept a pid instead of a ptid.
	(find_fork_pid): New function.
	(pid_to_fork_id): Delete function.
	(detach_fork_command): New command.
	(checkpoint_command): Remember previous setting of detach_fork.
	Don't call add_fork, it's now done by child_follow_fork.
	FIXME get rid of call to target_fetch_registers.
	(checkpoint_init): Add setshow detach-on-fork.
	Add detach-fork.
@
text
@d342 1
a342 5
struct fork_info;
static int detach_fork = 1;
static struct fork_info *add_fork (pid_t);
static struct fork_info *find_fork_pid (pid_t);
static void fork_save_infrun_state (struct fork_info *, int);
d379 2
a380 13
      if (detach_fork)
	{
	  ptrace (PTRACE_DETACH, child_pid, 0, 0);
	}
      else
	{
	  struct fork_info *fp;
	  /* Retain child fork in ptrace (stopped) state.  */
	  fp = find_fork_pid (child_pid);
	  if (!fp)
	    fp = add_fork (child_pid);
	  fork_save_infrun_state (fp, 0);
	}
a474 9
      else if (!detach_fork)
	{
	  struct fork_info *fp;
	  /* Retain parent fork in ptrace (stopped) state.  */
	  fp = find_fork_pid (parent_pid);
	  if (!fp)
	    fp = add_fork (parent_pid);
	  fork_save_infrun_state (fp, 0);
	}
a481 5
      /* FIXME: As written, we may do a push_target WITHOUT doing
	 a target_detach (if has_vforked).  I'm going to momentarily
	 assume that that means it's OK to do the same if we've
	 forked but not detached.  */

a3335 1
  int clobber_regs;		/* True if we should restore saved regs.  */
a3345 2
  extern void set_last_target_status (ptid_t, struct target_waitstatus);

d3351 1
a3351 1
  if (fp->savedregs && fp->clobber_regs)
a3352 1

d3359 1
a3359 1
fork_save_infrun_state (struct fork_info *fp, int clobber_regs)
a3360 2
#if 0
  /* I claim that I no longer need any infrun status.  */
a3361 4
#endif
  if (fp->savedregs)
    regcache_xfree (fp->savedregs);

a3364 1
  fp->clobber_regs = clobber_regs;
d3370 2
a3371 2
static struct fork_info *
add_fork (pid_t pid)
d3375 3
a3377 2
  fp = XZALLOC (struct fork_info);
  fp->ptid = pid_to_ptid (pid);
d3451 1
a3451 1
static struct fork_info *
a3462 15
/* Find a fork_info by matching pid.  */
static struct fork_info *
find_fork_pid (pid_t pid)
{
  struct fork_info *fp;

  for (fp = fork_list; fp; fp = fp->next)
    if (pid == ptid_get_pid (fp->ptid))
      return fp;

  return NULL;
}



d3502 12
a3531 1
  /* FIXME: check for not-found!  */
a3538 22
static void
detach_fork_command (char *args, int from_tty)
{
  ptid_t ptid;

  if (!args || !*args)
    error ("Requires argument (fork id to delete, see info fork)");

  /* FIXME: check for not-found!  */
  ptid = fork_id_to_ptid (strtol (args, NULL, 0));
  if (ptid_equal (ptid, inferior_ptid))
    error ("Please switch to another fork before detaching the current fork");

  if (ptrace (PTRACE_DETACH, ptid, 0, 0))
    error ("Unable to detach pid %s", target_tid_to_str (ptid));

  if (from_tty)
    printf_filtered ("Detached process %s\n", 
		     target_pid_or_tid_to_str (inferior_ptid));
  delete_fork (ptid);
}

a3596 1
  int save_detach_fork;
d3610 1
a3610 2
  save_detach_fork = detach_fork;
  detach_fork = 0;
d3612 1
a3612 1
  detach_fork = save_detach_fork;
d3629 6
a3634 11
#if 0 /* child_follow_fork will have created the new fork.
	 We still need to save its register state, to update
	 the savedregs.  */
  fp = add_fork (retpid);
  fork_save_infrun_state (fp, 1);
#else
  fp = find_fork_ptid (pid_to_ptid (retpid));
  if (!fp)
    error ("Failed to find new fork");
  fork_save_infrun_state (fp, 1);
#endif
d3668 1
a3668 1
      oldfp = add_fork (ptid_get_pid (inferior_ptid));
d3671 1
a3671 1
  fork_save_infrun_state (oldfp, 1);
d3674 1
a3675 4
  /* FIXME lose this.  */
  target_fetch_registers (-1);	/* FIXME should not be necessary;
				   fill_gregset should do it automatically. */
  reinit_frame_cache ();
d3683 3
a3689 7

  add_setshow_boolean_cmd ("detach-on-fork", class_obscure, &detach_fork, _("\
Set whether gdb will detach the child of a fork."), _("\
Show whether gdb will detach the child of a fork."), _("\
Tells gdb whether to detach the child of a fork."), 
			   NULL, NULL, &setlist, &showlist);

d3693 1
a3693 1
Flip from parent to child fork (experimental)."));
a3695 2
  add_com ("detach-fork", class_obscure, detach_fork_command, _("\
Detach from a fork/checkpoint (experimental)."));
@


1.34.4.3
log
@2005-11-25  Michael Snyder  <msnyder@@redhat.com>

	* linux-nat.c (child_follow_fork): Add verbose messages when
	detaching from parent or child (to match HPUX tests in testsuite).
@
text
@d374 8
a384 8
	  if (1/*debug_linux_nat*/)
	    {
	      target_terminal_ours ();
	      fprintf_filtered (gdb_stdlog,
				"Detaching after fork from child process %d.\n",
				child_pid);
	    }

d500 1
a500 8
	{
	  fprintf_filtered (gdb_stdlog, 
			    "Detaching from program: %d.  ", parent_pid);
	  fprintf_filtered (gdb_stdlog, 
			    "Attaching after fork to process %d.\n",
			    child_pid);
	  target_detach (NULL, 0);
	}
@


1.34.4.4
log
@2005-11-25  Michael Snyder  <msnyder@@redhat.com>

	* infrun.c (set_last_target_status): Remove, replace with following.
	(nullify_last_target_wait_ptid): New function.  Now we don't need
	to save this bit of state in linux-nat.

	* linux-nat.c (struct fork_info): Get rid of last_target_ptid,
	last_target_waitstatus, and inferior status.
	(fork_load_infrun_state): Forget about infrun status and target
	wait ptid.  Call nullify_last_target_wait_ptid instead.
	(fork_save_infrun_state): Forget about infrun status and target
	wait ptid.
	(free_fork): Forget about infrun status.
	(detach_fork_command): Output cleanup.

	* linux-nat.c (child_follow_fork): Add verbose messages when
	detaching from parent or child (to match HPUX tests in testsuite).
@
text
@d513 4
d3370 1
d3373 3
d3383 1
a3383 1
  extern void nullify_last_target_wait_ptid ();
d3385 5
d3393 1
a3393 1
  nullify_last_target_wait_ptid ();
d3401 4
d3409 2
d3436 2
d3603 1
a3603 1
    error ("Unable to detach %s", target_tid_to_str (ptid));
d3606 2
a3607 2
    printf_filtered ("Detached %s\n", target_pid_or_tid_to_str (ptid));

@


1.34.4.5
log
@2005-11-25  Michael Snyder  <msnyder@@redhat.com>

	* linux-nat.c (restart_auto_finish): New set/show variable.
	(restart_command): Automatically do "finish" a few times
	on request.
@
text
@a3706 2
static int restart_auto_finish;

d3714 1
a3714 1
  int id, i;
a3740 6

  for (i = 0; i < restart_auto_finish; i++)
    {
      execute_command ("finish", from_tty);
    }

a3754 8
  add_setshow_integer_cmd ("restart-auto-finish", class_obscure, 
			   &restart_auto_finish, _("\
Set number of finish commands gdb should do on restart of a fork."), _("\
Show number of finish commands gdb should do on restart of a fork."), _("\
Tells gdb how many finish commands to do on restart of a fork."),
			   NULL, NULL, &setlist, &showlist);


d3758 1
a3758 2
Switch between parent and child fork (experimental)."));
  add_com_alias ("fork", "restart", class_obscure, 1);
a3760 1
  add_com_alias ("delete-fork", "delete-checkpoint", class_obscure, 1);
d3767 1
@


1.34.4.6
log
@2005-11-26  Michael Snyder  <msnyder@@redhat.com>

	* linux-fork.h: New file.
	* linux-nat.c: Include linux-fork.h, remove forward declarations.
	(kill_inferior): Loop over forks and PTRACE_KILL them all.
	(add_fork): Special case -- insert original fork as special
	zeroeth element in list.
	(info_forks_command): Use current PC instead of savedregs pc
	for current fork.  If no SAL, print a minsym.  Identify the
	zeroeth fork as "main process".
@
text
@a33 1
#include "linux-fork.h"
d342 1
d344 3
d620 8
a627 2
  /* First cut -- let's crudely do everything inline.  */
  if (fork_list)
d629 2
a630 14
      /* Walk list and kill every pid.  No need to treat the
	 current inferior_ptid as special (we do not return a
	 status for it) -- however any process may be a child
	 or a parent, so may get a SIGCHLD from a previously
	 killed child.  Wait them all out.  */
      
      do {
	pid = PIDGET (fork_list->ptid);
	do {
	  ptrace (PT_KILL, pid, 0, 0);
	  ret = waitpid (pid, &status, 0);
	} while (ret == pid && WIFSTOPPED (status));
	delete_fork (fork_list->ptid);
      } while (fork_list != NULL);
a631 5
  else
    {
      /* If we're stopped while forking and we haven't followed yet,
	 kill the other task.  We need to do this first because the
	 parent will be sleeping if this is a vfork.  */
d633 3
a635 1
      get_last_target_status (&last_ptid, &last);
d637 2
a638 6
      if (last.kind == TARGET_WAITKIND_FORKED
	  || last.kind == TARGET_WAITKIND_VFORKED)
	{
	  ptrace (PT_KILL, last.value.related_pid, 0, 0);
	  wait (&status);
	}
d640 2
a641 1
      /* Kill the current process.  */
a643 9

      /* We might get a SIGCHLD instead of an exit status.  This is
	 aggravated by the first kill above - a child has just died.  */

      while (ret == pid && WIFSTOPPED (status))
	{
	  ptrace (PT_KILL, pid, 0, 0);
	  ret = wait (&status);
	}
d3359 11
d3385 1
a3385 1
extern void
d3395 1
a3395 1
struct fork_info *fork_list = NULL;
d3398 1
a3398 1
extern struct fork_info *
a3402 11
  if (fork_list == NULL &&
      pid != PIDGET (inferior_ptid))
    {
      /* Special case -- if this is the first fork in the list
	 (the list is hitherto empty), and if this new fork is
	 NOT the current inferior_ptid, then add inferior_ptid
	 first, as a special zeroeth fork id.  */
      highest_fork_num = -1;
      add_fork (PIDGET (inferior_ptid));	/* safe recursion */
    }

d3423 1
a3423 1
extern void
d3489 1
a3489 1
extern struct fork_info *
d3622 1
a3622 4
	{
	  printf_filtered ("* ");
	  pc = read_pc ();
	}
d3624 1
a3624 4
	{
	  printf_filtered ("  ");
	  regcache_raw_read_unsigned (fp->savedregs, PC_REGNUM, &pc);
	}
d3626 1
a3626 2
      if (fp->num == 0)
	printf_filtered (" (main process)");
a3634 8
      if (!sal.symtab && !sal.line)
	{
	  struct minimal_symbol *msym;

	  msym = lookup_minimal_symbol_by_pc (pc);
	  if (msym)
	    printf_filtered (", <%s>", SYMBOL_LINKAGE_NAME (msym));
	}
a3731 1
  oldfp->been_restarted = 1;
a3740 8

  if (!newfp->been_restarted)
    for (i = 0; i < restart_auto_finish; i++)
      {
	execute_command ("finish", from_tty);
      }

  newfp->been_restarted = 1;
d3744 5
@


1.34.4.7
log
@2005-11-26  Michael Snyder  <msnyder@@redhat.com>

	* linux-nat.c (super_mourn_inferior): New function pointer.
	(child_mourn_inferior): New method, overrides to_mourn_inferior.
	Handles multiple forks.
	(linux_target): Intercept to_mourn_inferior, save pointer to
	parent method.
@
text
@d93 4
a96 6
/* The saved to_xfer_partial method, inherited from inf-ptrace.c.
   Called by our to_xfer_partial.  */
static LONGEST (*super_xfer_partial) (struct target_ops *, 
				      enum target_object,
				      const char *, gdb_byte *, 
				      const gdb_byte *,
a98 4
/* The saved to_mourn_inferior method, inherited from inf-ptrace.c.
   Called by our to_mourn_inferior.  */
static void (*super_mourn_inferior) (void);

a1787 42
/* Local mourn_inferior -- we need to override mourn_inferior
   so that we can do something clever if one of several forks
   has exited.  */

static void
child_mourn_inferior (void)
{
  int status;

  if (fork_list && 
      fork_list->next == NULL &&
      ptid_equal (fork_list->ptid, inferior_ptid))
    {
      /* Last fork -- delete from list and handle as solo process.  */
      delete_fork (inferior_ptid);
    }

  if (fork_list == NULL)
    {
      /* Normal case, no other forks available.  */
      super_mourn_inferior ();
      return;
    }

  /* Multi-fork case.  */
  /* Wait just one more time to collect the inferior's exit status.
     Do not check whether this succeeds though, since we may be
     dealing with a process that we attached to.  Such a process will
     only report its exit status to its origional parent.  */
  waitpid (ptid_get_pid (inferior_ptid), &status, 0);

  /* OK, presumably inferior_ptid is the one who has exited.
     We need to delete that one from the fork_list, and switch
     to the next available fork.  FIXME safety?  */
  delete_fork (inferior_ptid);
  inferior_ptid = fork_list[0].ptid;
  printf_filtered ("[Switching to %s]\n", 
		   target_pid_to_str (inferior_ptid));

  /* Is that enough?  Maybe infrun will take care of everything else... */
}

a3259 3
  super_mourn_inferior = t->to_mourn_inferior;
  t->to_mourn_inferior = child_mourn_inferior;

a3769 1
#if 0
a3771 1
#endif
d3784 1
a3784 1
		   target_pid_to_str (inferior_ptid));
@


1.34.4.8
log
@2005-11-28  Michael Snyder  <msnyder@@redhat.com>

	* linux-fork.c: New file.  Move fork list and fork commands here.
	* linux-fork.h: Now acts as interface between linux-nat and linux-fork.
	* linux-nat.c: Move all fork-related functions to linux-fork.c.
	(child_mourn_inferior): Use new API to linux-fork, instead of
	manipulating the fork list directly.
	(kill_inferior): Ditto.
@
text
@d50 2
d349 2
d377 1
a377 1
      /* Detach new forked process?  */
d624 1
a624 1
  if (FORKS_EXIST ())
d626 14
a639 1
      linux_fork_killall ();
d1803 9
a1811 1
  if (! FORKS_EXIST ())
d1817 17
a1833 8
  else
    {
      /* Multi-fork case.  The current inferior_ptid has exited,
	 but there are other viable forks to debug.  Delete the
         exiting one and context-switch to the first available.  
      */
      linux_fork_mourn_inferior ();
    }
d3318 1
d3356 1
d3425 450
@


1.34.4.9
log
@2005-12-01  Michael Snyder  <msnyder@@redhat.com>

	* linux-fork.c (fork_save_infrun_state): Close the DIR.
	(info_forks_command): Print bare filename, not full path.
	* linux-nat.c (kill_inferior): For multi-fork, pop target
	and call generic_mourn_inferior, not target_mourn_inferior.
@
text
@a622 2
      pop_target ();
      generic_mourn_inferior ();
a650 1
      target_mourn_inferior ();
d652 2
@


1.33
log
@	* Makefile.in (ALLDEPFILES): Update.
	(alpha-linux-nat.o, sparc-linux-nat.o): New rules.
	(amd64-linux-nat.o, arm-linux-nat.o, hppa-linux-nat.o)
	(i386-linux-nat.o, ia64-linux-nat.o, linux-nat.o, m32r-linux-nat.o)
	(m68klinux-nat.o, mips-linux-nat.o, ppc-linux-nat.o, s390-nat.o)
	(sparc64-linux-nat.o): Update dependencies.
	* alpha-linux-nat.c, sparc-linux-nat.c: New files.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(amd64_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(amd64_linux_child_post_start_inferior): Renamed from
	child_post_startup_inferior and made static.  Call
	super_post_startup_inferior.
	(super_post_startup_inferior): New.
	(_initialize_amd64_linux_nat): Set it.  Call linux_target and
	add_target.
	* arm-linux-nat.c (arm_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(arm_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_arm_linux_nat): Add a prototype.  Use linux_target and
	add_target.
	* hppa-linux-nat.c (hppa_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(hppa_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_hppa_linux_nat): New function.
	* i386-linux-nat.c (i386_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(i386_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(i386_linux_resume): Renamed from child_resume and made static.
	(i386_linux_child_post_start_inferior): Renamed from
	child_post_startup_inferior and made static.  Call
	super_post_startup_inferior.
	(super_post_startup_inferior): New.
	(_initialize_i386_linux_nat): New function.
	* i386-nat.c: Remove LINUX_CHILD_POST_STARTUP_INFERIOR #ifndef.
	* ia64-linux-nat.c (ia64_linux_xfer_unwind_table): Remove.
	(super_xfer_partial): New.
	(ia64_linux_xfer_partial): New function.  Use it.
	(_initialize_ia64_linux_nat): New function.
	* ia64-tdep.c (getunwind_table): Revert 2005-06-08 change; use
	target_read_partial and document the problem.
	* inf-ptrace.c (inf_ptrace_fetch_register): Use
	CANNOT_FETCH_REGISTER.  Fix some comments.
	(inf_ptrace_store_register): Use CANNOT_STORE_REGISTER.  Fix some
	comments.
	* linux-nat.c: Include "inf-ptrace.h" and "auxv.h".
	(linux_ops, super_xfer_partial): New variables.
	(linux_child_post_startup_inferior): Make static.
	(child_post_startup_inferior): Delete.
	(linux_nat_attach, linux_nat_detach, resume_callback)
	(linux_nat_resume, linux_nat_wait, linux_nat_create_inferior)
	(linux_nat_mourn_inferior): Use linux_ops instead of
	deprecated_child_ops.
	(child_wait): Do not depend on CHILD_WAIT.
	(linux_nat_xfer_memory): Remove, replace by ...
	(linux_nat_xfer_partial): ... this.  Use linux_ops->to_xfer_partial
	instead of linux_proc_xfer_memory and child_xfer_memory.
	(linux_nat_fetch_registers, linux_nat_store_registers)
	(linux_nat_child_post_startup_inferior): New functions.
	(init_linux_nat_ops): Use the new functions.
	(linux_proc_xfer_memory): Remove, replace by ...
	(linux_proc_xfer_partial): ... this.  Make static.
	(linux_xfer_partial, linux_register_u_offset, linux_target): New
	functions.
	(_initialize_linux_nat): Do not modify deprecated_child_ops.
	* linux-nat.h (linux_proc_xfer_memory): Remove prototype.
	(struct mem_attrib, struct target_ops): Remove forward declarations.
	(linux_child_post_startup_inferior): Remove prototype.
	(linux_target): Add prototype.
	* linux-thread-db.c (thread_db_xfer_memory): Remove, replace by ...
	(thread_db_xfer_partial): ... this.
	(init_thread_db_ops): Set to_xfer_partial instead of
	deprecated_xfer_memory.
	* m32r-linux-nat.c (m32r_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(m32r_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_m32r_linux_nat): New function.
	* m68klinux-nat.c (m68k_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(m68k_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(old_fetch_inferior_registers, old_store_inferior_registers): Made
	static.
	(_initialize_m68k_linux_nat): Use linux_target and add_target.
	* mips-linux-nat.c (_initialize_mips_linux_nat): New function.
	* ppc-linux-nat.c (ppc_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(ppc_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_ppc_linux_nat): New function.
	* s390-nat.c (s390_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(s390_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_s390_nat): New function.
	* sparc64-linux-nat.c (_initialize_sparc64_linux_nat): Use
	linux_target and add_target.
	* config/nm-linux.h: Don't include "auxv.h".
	(struct target_waitstatus, child_wait, CHILD_WAIT)
	(CHILD_PID_TO_EXEC_FILE, CHILD_INSERT_FORK_CATCHPOINT)
	(CHILD_INSERT_VFORK_CATCHPOINT, CHILD_INSERT_EXEC_CATCHPOINT)
	(CHILD_POST_STARTUP_INFERIOR, CHILD_POST_ATTACH, CHILD_FOLLOW_FORK)
	(DEPRECATED_KILL_INFERIOR, NATIVE_XFER_AUXV): Delete.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Replace infptrace.o
	and inftarg.o with inf-ptrace.o and alpha-linux-nat.o.
	* config/sparc/linux.mh (NATDEPFILES): Replace infptrace.o and
	inftarg.o with sparc-linux-nat.o.
	* config/sparc/linux64.mh (NATDEPFILES): Remove infptrace.o and
	inftarg.o.
	* config/arm/linux.mh (NATDEPFILES): Replace infptrace.o and
	inftarg.o with inf-ptrace.o.
	* config/i386/linux.mh (NATDEPFILES): Likewise.
	* config/i386/linux64.mh (NATDEPFILES): Likewise.
	* config/ia64/linux.mh (NATDEPFILES): Likewise.
	* config/m32r/linux.mh (NATDEPFILES): Likewise.
	* config/m68k/linux.mh (NATDEPFILES): Likewise.
	* config/mips/linux.mh (NATDEPFILES): Likewise.
	* config/pa/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Likewise.
	* config/s390/s390.mh (NATDEPFILES): Likewise.
	* config/i386/nm-linux.h (DEPRECATED_CHILD_RESUME): Don't define.
	(LINUX_CHILD_POST_STARTUP_INFERIOR): Don't define.
	* config/i386/nm-linux64.h (LINUX_CHILD_POST_STARTUP_INFERIOR):
	Don't define.
	* config/ia64/nm-linux.h: Don't include "target.h".
	(NATIVE_XFER_UNWIND_TABLE, ia64_linux_xfer_unwind_table): Remove.
	* config/djgpp/fnchange.lst: Add alpha-linux-tdep.c,
	alpha-linux-nat.c, sparc-linux-tdep.c, and sparc-linux-nat.c.
@
text
@d1075 8
d1108 28
a1135 1
         point in resuming the process.  */
d1141 6
@


1.33.4.1
log
@	* linux-nat.c (linux_nat_resume): Add more debugging messages.  Do
	not short-circuit resuming all threads if the signal will be ignored
	in linux_nat_wait.
@
text
@a1074 8
  if (debug_linux_nat)
    fprintf_unfiltered (gdb_stdlog,
			"LLR: Preparing to %s %s, %s, inferior_ptid %s\n",
			step ? "step" : "resume",
			target_pid_to_str (ptid),
			signo ? strsignal (signo) : "0",
			target_pid_to_str (inferior_ptid));

d1100 1
a1100 28
	 point in resuming the process.  But first make sure that
	 linux_nat_wait won't preemptively handle the event - we
	 should never take this short-circuit if we are going to
	 leave LP running, since we have skipped resuming all the
	 other threads.  This bit of code needs to be synchronized
	 with linux_nat_wait.  */

      if (lp->status && WIFSTOPPED (lp->status))
	{
	  int saved_signo = target_signal_from_host (WSTOPSIG (lp->status));

	  if (signal_stop_state (saved_signo) == 0
	      && signal_print_state (saved_signo) == 0
	      && signal_pass_state (saved_signo) == 1)
	    {
	      if (debug_linux_nat)
		fprintf_unfiltered (gdb_stdlog,
				    "LLR: Not short circuiting for ignored "
				    "status 0x%x\n", lp->status);

	      /* FIXME: What should we do if we are supposed to continue
		 this thread with a signal?  */
	      gdb_assert (signo == TARGET_SIGNAL_0);
	      signo = saved_signo;
	      lp->status = 0;
	    }
	}

a1105 6

	  if (debug_linux_nat)
	    fprintf_unfiltered (gdb_stdlog,
				"LLR: Short circuiting for status 0x%x\n",
				lp->status);

@


1.32
log
@	* inf-child.c (inf_child_follow_fork): Add OPS argument.
	* inf-ptrace.c (inf_ptrace_follow_fork): Likewise.
	* inf-ttrace.c (inf_ttrace_follow_fork): Likewise.
	* inftarg.c (child_follow_fork): Likewise.
	* linux-nat.c (child_follow_fork): Likewise.  Use ops instead of
	&deprecated_child_ops.
	* target.c (update_current_target): Do not inherit to_follow_fork.
	(target_follow_fork): New function.
	(debug_to_follow_fork): Remove.
	(setup_target_debug): Don't set to_follow_fork.
	* target.h (struct target_ops): Add struct target_ops * to
	to_follow_fork.
	(child_follow_fork): Add struct target_ops * argument.
	(target_follow_fork): Replace macro with prototype.
@
text
@d37 2
d86 10
d334 1
a334 1
void
a339 8
#ifndef LINUX_CHILD_POST_STARTUP_INFERIOR
void
child_post_startup_inferior (ptid_t ptid)
{
  linux_child_post_startup_inferior (ptid);
}
#endif

d920 1
a920 1
  deprecated_child_ops.to_attach (args, from_tty);
d1030 1
a1030 1
  deprecated_child_ops.to_detach (args, from_tty);
d1042 2
a1043 1
      child_resume (pid_to_ptid (GET_LWP (lp->ptid)), 0, TARGET_SIGNAL_0);
d1117 1
a1117 1
  child_resume (ptid, step, signo);
a1690 2
#ifdef CHILD_WAIT

a1794 2
#endif

d1903 2
a1904 2
      child_resume (pid_to_ptid (GET_LWP (lp->ptid)), lp->step,
		    TARGET_SIGNAL_0);
d2105 2
a2106 2
	      child_resume (pid_to_ptid (GET_LWP (lp->ptid)), lp->step,
			    TARGET_SIGNAL_0);
d2165 2
a2166 1
	  child_resume (pid_to_ptid (GET_LWP (lp->ptid)), lp->step, signo);
d2315 1
a2315 1
  deprecated_child_ops.to_create_inferior (exec_file, allargs, env, from_tty);
d2330 1
a2330 1
  deprecated_child_ops.to_mourn_inferior ();
d2333 5
a2337 4
static int
linux_nat_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len,
		       int write, struct mem_attrib *attrib,
		       struct target_ops *target)
d2340 1
a2340 1
  int xfer;
d2345 2
a2346 3
  xfer = linux_proc_xfer_memory (memaddr, myaddr, len, write, attrib, target);
  if (xfer == 0)
    xfer = child_xfer_memory (memaddr, myaddr, len, write, attrib, target);
d2385 20
d2417 3
a2419 5
  /* fetch_inferior_registers and store_inferior_registers will
     honor the LWP id, so we can use them directly.  */
  linux_nat_ops.to_fetch_registers = fetch_inferior_registers;
  linux_nat_ops.to_store_registers = store_inferior_registers;
  linux_nat_ops.deprecated_xfer_memory = linux_nat_xfer_memory;
d2425 2
a2426 1
  linux_nat_ops.to_post_startup_inferior = child_post_startup_inferior;
d2972 10
a2981 3
int
linux_proc_xfer_memory (CORE_ADDR addr, gdb_byte *myaddr, int len, int write,
			struct mem_attrib *attrib, struct target_ops *target)
d2983 2
a2984 1
  int fd, ret;
d2987 1
a2987 1
  if (write)
d3006 1
a3006 1
  if (pread64 (fd, myaddr, len, addr) != len)
d3008 1
a3008 1
  if (lseek (fd, addr, SEEK_SET) == -1 || read (fd, myaddr, len) != len)
d3099 68
a3172 3
  deprecated_child_ops.to_find_memory_regions = linux_nat_find_memory_regions;
  deprecated_child_ops.to_make_corefile_notes = linux_nat_make_corefile_notes;

@


1.31
log
@2005-08-09  Andrew Cagney  <cagney@@gnu.org>

	* linux-nat.h (linux_proc_xfer_memory): Change type of "myaddr" a
	"gdb_byte" pointer.
	* linux-nat.c (linux_proc_xfer_memory): Update.
	(get_signo): Cast signo to a "gdb_byte" pointer.
	* i386-linux-nat.c (child_resume): Make "buf" a gdb_byte, delete
	redundant casts.
	(child_resume): Cast eflags to a "gdb_byte" pointer.
@
text
@d337 1
a337 1
child_follow_fork (int follow_child)
d469 4
a472 1
      push_target (&deprecated_child_ops);
@


1.30
log
@	* dwarf2-frame.c (dwarf2_frame_prev_register): Use gdb_byte.
	* i386-linux-nat.c (fetch_register, store_register, supply_gregset)
	(fill_gregset): Likewise.
	* i386-tdep.c (i386_frame_prev_register)
	(i386_sigtramp_frame_prev_register): Likewise.
	* linux-nat.c (linux_nat_xfer_memory, linux_nat_make_corefile_notes):
	Likewise.
	* linux-thread-db.c (thread_db_xfer_memory): Likewise.
	* remote.c (remote_insert_hw_breakpoint, remote_remove_hw_breakpoint):
	Likewise.
	* target.c (debug_to_insert_hw_breakpoint)
	(debug_to_remove_hw_breakpoint, update_current_target): Likewise.
@
text
@d2949 1
a2949 1
linux_proc_xfer_memory (CORE_ADDR addr, char *myaddr, int len, int write,
d3131 1
a3131 1
  if (target_read_memory (SYMBOL_VALUE_ADDRESS (ms), (char *) &signo,
@


1.29
log
@2005-05-23  Michael Snyder  <msnyder@@redhat.com>
        From Nora Pan <qpan@@mvista.com>
        * linux-nat.c (read_mapping): Don't stumble over entries in
        mapping that have name but zero inode.
@
text
@d2329 3
a2331 2
linux_nat_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		     struct mem_attrib *attrib, struct target_ops *target)
d2625 1
a2625 1
  char *auxv;
@


1.28
log
@	* linux-nat.c (child_follow_fork, linux_handle_extended_wait)
	(lin_lwp_attach_lwp, linux_nat_attach, wait_lwp, child_wait)
	(linux_nat_wait, kill_wait_callback): Use my_waitpid.
	(_initialize_linux_nat, lin_thread_get_thread_signals): Use
	SA_RESTART.
@
text
@d2454 2
a2455 1
  if (ret > 0 && ret != EOF && *inode != 0)
d2466 1
a2466 5
  else
    {
      filename[0] = '\0';	/* no filename */
      fscanf (mapfile, "\n");
    }
@


1.27
log
@	* linux-nat.c (child_follow_fork): Call target_terminal_ours before
	printing output.  Use fprintf_unfiltered.  Only print output when
	debugging.
@
text
@d380 1
a380 1
	      waitpid (parent_pid, &status, __WALL);
d497 2
a498 4
	  do {
	    ret = waitpid (new_pid, &status,
			   (event == PTRACE_EVENT_CLONE) ? __WCLONE : 0);
	  } while (ret == -1 && errno == EINTR);
d869 1
a869 1
      pid = waitpid (GET_LWP (ptid), &status, 0);
d873 1
a873 1
	  pid = waitpid (GET_LWP (ptid), &status, __WCLONE);
d921 1
a921 1
  pid = waitpid (GET_PID (inferior_ptid), &status, 0);
d927 1
a927 1
      pid = waitpid (GET_PID (inferior_ptid), &status, __WCLONE);
d1192 1
a1192 1
  pid = waitpid (GET_LWP (lp->ptid), &status, 0);
d1195 1
a1195 1
      pid = waitpid (GET_LWP (lp->ptid), &status, __WCLONE);
d1707 1
a1707 1
      pid = waitpid (GET_PID (ptid), &status, 0);
d1710 1
a1710 1
	pid = waitpid (GET_PID (ptid), &status, __WCLONE);
d1921 1
a1921 1
      lwpid = waitpid (pid, &status, options);
d2265 1
a2265 1
	  pid = waitpid (GET_LWP (lp->ptid), NULL, __WCLONE);
d2280 1
a2280 1
      pid = waitpid (GET_LWP (lp->ptid), NULL, 0);
d3096 1
a3096 1
  action.sa_flags = 0;
d3169 1
a3169 1
  action.sa_flags = 0;
@


1.26
log
@	* linux-nat.c (linux_supports_tracevforkdone, child_follow_fork):
	Use LWP IDs.
@
text
@d362 7
a368 3
      fprintf_filtered (gdb_stdout,
			"Detaching after fork from child process %d.\n",
			child_pid);
d437 7
a443 3
      fprintf_filtered (gdb_stdout,
			"Attaching after fork to child process %d.\n",
			child_pid);
@


1.25
log
@2005-02-24  Andrew Cagney  <cagney@@gnu.org>

	Add show_VARIABLE functions, update add_setshow call.
	* varobj.c (_initialize_varobj, show_varobjdebug): Add and update.
	* valprint.c (_initialize_valprint, show_print_max)
	(show_stop_print_at_null, show_repeat_count_threshold)
	(show_prettyprint_structs, show_unionprint)
	(show_prettyprint_arrays, show_addressprint, show_input_radix)
	(show_output_radix): Ditto.
	* valops.c (_initialize_valops, show_overload_resolution): Ditto.
	* utils.c (initialize_utils, show_chars_per_line)
	(show_lines_per_page, show_demangle, show_pagination_enabled)
	(show_sevenbit_strings, show_asm_demangle): Ditto
	* tui/tui-win.c (_initialize_tui_win, show_tui_border_kind)
	(show_tui_border_mode, show_tui_active_border_mode): Ditto.
	* top.c (init_main, show_new_async_prompt)
	(show_async_command_editing_p, show_write_history_p)
	(show_history_size, show_history_filename, show_caution)
	(show_annotation_level, init_main): Ditto.
	* target.c (initialize_targets, show_targetdebug)
	(show_trust_readonly): Ditto.
	* symfile.c (_initialize_symfile, show_symbol_reloading)
	(show_ext_args, show_download_write_size)
	(show_debug_file_directory): Ditto.
	* source.c (_initialize_source, show_lines_to_list): Ditto.
	* solib.c (_initialize_solib, show_auto_solib_add)
	(show_solib_search_path): Ditto.
	* p-valprint.c (_initialize_pascal_valprint)
	(show_pascal_static_field_print): Ditto.
	* printcmd.c (_initialize_printcmd, show_max_symbolic_offset)
	(show_print_symbol_filename): Add and update.
	* parse.c (_initialize_parse, show_expressiondebug): Dito.
	* observer.c (_initialize_observer, show_observer_debug): Dito.
	* maint.c (_initialize_maint_cmds, show_watchdog)
	(show_maintenance_profile_p): Dito.
	* linux-nat.c (_initialize_linux_nat, show_debug_linux_nat): Dito.
	* infrun.c (_initialize_infrun, show_debug_infrun)
	(show_stop_on_solib_events, show_follow_fork_mode_string)
	(show_scheduler_mode, show_step_stop_if_no_debug): Ditto.
	* infcall.c (_initialize_infcall, show_coerce_float_to_double_p)
	(show_unwind_on_signal_p): Ditto.
	* gdbtypes.c (build_gdbtypes, show_opaque_type_resolution)
	(_initialize_gdbtypes, show_overload_debug): Ditto.
	* gdb-events.c, gdb-events.sh (_initialize_gdb_events)
	(show_gdb_events_debug): Ditto.
	* gdbarch.c, gdbarch.sh (show_gdbarch_debug)
	(_initialize_gdbarch): Ditto.
	* frame.c (_initialize_frame, show_backtrace_past_main)
	(show_backtrace_past_entry, show_backtrace_limit)
	(show_frame_debug): Ditto.
	* exec.c (_initialize_exec, show_write_files): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read)
	(show_dwarf2_max_cache_age): Ditto.
	* demangle.c (_initialize_demangler)
	(show_demangling_style_names): Ditto.
	* dcache.c (_initialize_dcache, show_dcache_enabled_p): Ditto.
	* cp-valprint.c (show_static_field_print)
	(_initialize_cp_valprint, show_vtblprint, show_objectprint): Ditto.
	* corefile.c (_initialize_core, show_gnutarget_string): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging)
	(show_logging_overwrite, show_logging_redirect)
	(show_logging_filename): Ditto.
	* cli/cli-cmds.c (show_info_verbose, show_history_expansion_p)
	(init_cli_cmds, show_baud_rate, show_remote_debug)
	(show_remote_timeout, show_max_user_call_depth): Ditto.
	* charset.c (show_host_charset_name, show_target_charset_name)
	(initialize_charset): Ditto.
	* breakpoint.c (show_can_use_hw_watchpoints)
	(show_pending_break_support, _initialize_breakpoint): Ditto.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d296 1
a296 1
  int pid = ptid_get_pid (ptid);
d299 3
d346 3
a348 1
  parent_pid = ptid_get_pid (last_ptid);
@


1.24
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_zinteger_cmd through out.  Re-sync gdbarch.sh
	and gdbarch.c.
	* breakpoint.c, frame.c, gdb-events.sh, gdbarch.sh: Update.
	* gdbtypes.c, infrun.c, linux-nat.c, maint.c, monitor.c: Update.
	* pa64solib.c, parse.c, remote-mips.c, ser-go32.c: Update.
	* serial.c, solib-frv.c, somsolib.c, target.c, top.c: Update.
	* varobj.c, cli/cli-cmds.c: Update.
	* gdbarch.c, gdb-events.c: Regenerate.
@
text
@d85 7
d3099 1
a3099 1
			    NULL, /* FIXME: i18n: */
@


1.23
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d3087 7
a3093 5
  deprecated_add_show_from_set
    (add_set_cmd ("lin-lwp", no_class, var_zinteger,
		  (char *) &debug_linux_nat,
		  "Set debugging of GNU/Linux lwp module.\n\
Enables printf debugging output.\n", &setdebuglist), &showdebuglist);
@


1.22
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d3060 2
a3061 2
  add_info ("proc", linux_nat_info_proc_cmd,
	    "Show /proc process information about any running process.\n\
d3067 1
a3067 1
  all      -- list all available /proc info.");
@


1.21
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d825 1
a825 1
    printf_filtered ("[New %s]\n", target_pid_to_str (ptid));
d1221 1
a1221 1
	  printf_unfiltered ("[%s exited]\n",
d1473 1
a1473 1
	printf_unfiltered ("FC: LP has pending status %06x\n", lp->status);
d1970 1
a1970 1
		  printf_unfiltered ("[New %s]\n",
d1998 1
a1998 1
		  printf_unfiltered ("[%s exited]\n",
d2051 1
a2051 1
		  printf_unfiltered ("[%s exited]\n",
d2732 1
a2732 1
  printf_filtered ("process %lld\n", pid);
d2771 1
a2771 1
	  printf_filtered ("Mapped address spaces:\n\n");
d2844 1
a2844 1
	    printf_filtered ("Process: %d\n", itmp);
d2846 1
a2846 1
	    printf_filtered ("Exec file: %s\n", buffer);
d2848 1
a2848 1
	    printf_filtered ("State: %c\n", ctmp);
d2850 1
a2850 1
	    printf_filtered ("Parent process: %d\n", itmp);
d2852 1
a2852 1
	    printf_filtered ("Process group: %d\n", itmp);
d2854 1
a2854 1
	    printf_filtered ("Session id: %d\n", itmp);
d2856 1
a2856 1
	    printf_filtered ("TTY: %d\n", itmp);
d2858 1
a2858 1
	    printf_filtered ("TTY owner process group: %d\n", itmp);
d2860 1
a2860 1
	    printf_filtered ("Flags: 0x%x\n", itmp);
d2862 1
a2862 1
	    printf_filtered ("Minor faults (no memory page): %u\n",
d2865 1
a2865 1
	    printf_filtered ("Minor faults, children: %u\n",
d2868 1
a2868 1
	    printf_filtered ("Major faults (memory page faults): %u\n",
d2871 1
a2871 1
	    printf_filtered ("Major faults, children: %u\n",
d2882 1
a2882 1
	    printf_filtered ("jiffies remaining in current time slice: %d\n",
d2887 1
a2887 1
	    printf_filtered ("jiffies until next timeout: %u\n",
d2893 1
a2893 1
	    printf_filtered ("start time (jiffies since system boot): %d\n",
d2896 1
a2896 1
	    printf_filtered ("Virtual memory size: %u\n",
d2899 1
a2899 1
	    printf_filtered ("Resident set size: %u\n", (unsigned int) itmp);
d2903 1
a2903 1
	    printf_filtered ("Start of text: 0x%x\n", itmp);
d2905 1
a2905 1
	    printf_filtered ("End of text: 0x%x\n", itmp);
d2907 1
a2907 1
	    printf_filtered ("Start of stack: 0x%x\n", itmp);
d2911 1
a2911 1
	    printf_filtered ("Kernel stack pointer: 0x%x\n", itmp);
d2913 1
a2913 1
	    printf_filtered ("Kernel instr pointer: 0x%x\n", itmp);
d2915 1
a2915 1
	    printf_filtered ("Pending signals bitmap: 0x%x\n", itmp);
d2917 1
a2917 1
	    printf_filtered ("Blocked signals bitmap: 0x%x\n", itmp);
d2919 1
a2919 1
	    printf_filtered ("Ignored signals bitmap: 0x%x\n", itmp);
d2921 1
a2921 1
	    printf_filtered ("Catched signals bitmap: 0x%x\n", itmp);
d2923 1
a2923 1
	    printf_filtered ("wchan (system call): 0x%x\n", itmp);
@


1.20
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d196 1
a196 1
    perror_with_name ("linux_test_for_tracefork: fork");
d203 1
a203 1
    perror_with_name ("linux_test_for_tracefork: waitpid");
d482 1
a482 1
	    perror_with_name ("waiting for new child");
d485 1
a485 1
			    "wait returned unexpected PID %d", ret);
d488 1
a488 1
			    "wait returned unexpected status 0x%x", status);
d520 1
a520 1
		  "unknown ptrace event %d", event);
@


1.19
log
@2005-01-18  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Change return type of
	to_insert_fork_catchpoint, to_insert_vfork_catchpoint and
	to_insert_exec_catchpoint to void.
	(child_insert_fork_catchpoint, child_insert_vfork_catchpoint)
	(child_insert_exec_catchpoint): Change return type to void.
	* target.c (update_current_target): Update.
	(debug_to_insert_fork_catchpoint)
	(debug_to_insert_vfork_catchpoint)
	(debug_to_insert_exec_catchpoint): Update.
	* inf-child.c (inf_child_insert_fork_catchpoint)
	(inf_child_insert_vfork_catchpoint)
	(inf_child_insert_exec_catchpoint): Update.
	* breakpoint.c (insert_catchpoint): Update, do not throw an error.
	* linux-nat.c (child_insert_fork_catchpoint)
	(child_insert_vfork_catchpoint)
	(child_insert_exec_catchpoint): Update.
	* inftarg.c (child_insert_fork_catchpoint)
	(child_insert_vfork_catchpoint,)
	(child_insert_exec_catchpoint): Update.
@
text
@d205 1
a205 1
    error ("linux_test_for_tracefork: waitpid: unexpected result %d.", ret);
d207 1
a207 1
    error ("linux_test_for_tracefork: waitpid: unexpected status %d.", status);
d215 1
a215 1
	  warning ("linux_test_for_tracefork: failed to kill child");
d221 1
a221 1
	warning ("linux_test_for_tracefork: failed to wait for killed child");
d223 2
a224 2
	warning ("linux_test_for_tracefork: unexpected wait status 0x%x from "
		 "killed child", status);
d236 1
a236 1
    warning ("linux_test_for_tracefork: failed to resume child");
d253 1
a253 1
	    warning ("linux_test_for_tracefork: failed to kill second child");
d257 2
a258 2
    warning ("linux_test_for_tracefork: unexpected result from waitpid "
	     "(%d, status 0x%x)", ret, status);
d262 1
a262 1
    warning ("linux_test_for_tracefork: failed to kill child");
d366 2
a367 2
		warning ("Unexpected waitpid result %06x when waiting for "
			 "vfork-done", status);
d528 1
a528 1
    error ("Your system does not support fork catchpoints.");
d535 1
a535 1
    error ("Your system does not support vfork catchpoints.");
d542 1
a542 1
    error ("Your system does not support exec catchpoints.");
d843 1
a843 1
	error ("Can't attach %s: %s", target_pid_to_str (ptid),
d906 1
a906 1
      warning ("%s is a cloned process", target_pid_to_str (inferior_ptid));
d943 1
a943 1
	error ("Can't continue %s: %s", target_pid_to_str (lp->ptid),
d972 1
a972 1
	error ("Can't detach %s: %s", target_pid_to_str (lp->ptid),
d1756 1
a1756 1
      warning ("Child process unexpectedly missing: %s",
d2474 1
a2474 1
    error ("Could not open %s\n", mapsfilename);
d2726 1
a2726 1
    error ("No current process: you must name one.");
d2730 1
a2730 1
    error ("No /proc directory: '%s'", fname1);
d2743 1
a2743 1
	warning ("unable to open /proc file '%s'", fname1);
d2752 1
a2752 1
	warning ("unable to read link '%s'", fname1);
d2761 1
a2761 1
	warning ("unable to read link '%s'", fname1);
d2821 1
a2821 1
	warning ("unable to open /proc file '%s'", fname1);
d2833 1
a2833 1
	warning ("unable to open /proc file '%s'", fname1);
d2928 1
a2928 1
	warning ("unable to open /proc file '%s'", fname1);
d2980 1
a2980 1
    error ("Could not parse signal set: %s", line);
d2993 1
a2993 1
	error ("Could not parse signal set: %s", line);
d3026 1
a3026 1
    error ("Could not open %s", fname);
@


1.18
log
@	PR tui/1703
	* linux-nat.c (linux_tracefork_child): Use _exit instead of exit.
	Suggested by Joshua Neuheisel.
@
text
@d524 1
a524 1
int
a528 2

  return 0;
d531 1
a531 1
int
a535 2

  return 0;
d538 1
a538 1
int
a542 2

  return 0;
@


1.17
log
@	* linux-nat.c (my_waitpid): New function.
	(linux_test_for_tracefork): Make more robust and verbose.  Take
	an ORIGINAL_PID argument and test for PTRACE_SETOPTIONS first.
	(linux_supports_tracefork, linux_supports_tracevforkdone): Take a PID
	argument.  Update calls to linux_test_for_tracefork.
	(linux_enable_event_reporting, child_follow_fork)
	(child_insert_fork_catchpoint, child_insert_vfork_catchpoint)
	(child_insert_exec_catchpoint): Update calls to
	linux_supports_tracefork and linux_supports_tracevforkdone.
@
text
@d150 1
a150 1
  exit (0);
@


1.16
log
@	* linux-nat.c (PTRACE_EVENT_VFORK_DONE): Renamed from
	PTRACE_EVENT_VFORKDONE.
	(child_follow_fork): Adjust.
@
text
@d153 23
a175 1
/* Determine if PTRACE_O_TRACEFORK can be used to follow fork events.  We
d177 3
a179 3
   fork tracing, and let it fork.  If the process exits, we assume that
   we can't use TRACEFORK; if we get the fork notification, and we can
   extract the new child's PID, then we assume that we can.  */
d182 1
a182 1
linux_test_for_tracefork (void)
d187 7
d201 1
a201 1
  ret = waitpid (child_pid, &status, 0);
a208 2
  linux_supports_tracefork_flag = 0;

d212 14
a225 2
      ptrace (PTRACE_KILL, child_pid, 0, 0);
      waitpid (child_pid, &status, 0);
d234 6
a239 2
  ptrace (PTRACE_CONT, child_pid, 0, 0);
  ret = waitpid (child_pid, &status, 0);
d250 4
a253 2
	  waitpid (second_pid, &second_status, 0);
	  ptrace (PTRACE_DETACH, second_pid, 0, 0);
d256 3
d260 4
a263 5
  if (WIFSTOPPED (status))
    {
      ptrace (PTRACE_DETACH, child_pid, 0, 0);
      waitpid (child_pid, &status, 0);
    }
d270 1
a270 1
linux_supports_tracefork (void)
d273 1
a273 1
    linux_test_for_tracefork ();
d278 1
a278 1
linux_supports_tracevforkdone (void)
d281 1
a281 1
    linux_test_for_tracefork ();
d292 1
a292 1
  if (! linux_supports_tracefork ())
d297 1
a297 1
  if (linux_supports_tracevforkdone ())
d358 2
a359 1
	  if (linux_supports_tracevforkdone ())
d527 1
a527 1
  if (! linux_supports_tracefork ())
d536 1
a536 1
  if (!linux_supports_tracefork ())
d545 1
a545 1
  if (!linux_supports_tracefork ())
@


1.15
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@d72 1
a72 1
#define PTRACE_EVENT_VFORKDONE	5
d317 1
a317 1
	      if ((status >> 16) != PTRACE_EVENT_VFORKDONE)
@


1.14
log
@* linux-nat.c (_initialize_linux_nat): Rename child_ops.
(Previous change missed some uses.)
@
text
@d2335 1
a2335 1
  linux_nat_ops.to_xfer_memory = linux_nat_xfer_memory;
@


1.13
log
@2004-10-05  Andrew Cagney  <cagney@@gnu.org>

	* target.h (deprecated_child_ops): Rename child_ops.
	* wince.c: Update copyright.  Rename child_ops.
	* win32-nat.c: Rename child_ops.
	* target.c: Rename child_ops.
	* rs6000-nat.c: Rename child_ops.
	* linux-nat.c: Rename child_ops.
	* infttrace.c: Rename child_ops.
	* inftarg.c: Rename child_ops.
	* infptrace.c: Rename child_ops.
	* hppah-nat.c: Update copyright.  Rename child_ops.
	* hpux-thread.c: Update copyright.  Rename child_ops.
@
text
@d3015 2
a3016 2
  child_ops.to_find_memory_regions = linux_nat_find_memory_regions;
  child_ops.to_make_corefile_notes = linux_nat_make_corefile_notes;
@


1.12
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* infptrace.c (ptrace_wait): Mention problem with HPUX.
	(kill_inferior): Inline ptrace_wait call.
	* linux-nat.c (kill_inferior): Inline ptrace_wait call.
	* inftarg.c (child_wait): Inline ptrace_wait call.
@
text
@d401 1
a401 1
      push_target (&child_ops);
d853 1
a853 1
  child_ops.to_attach (args, from_tty);
d963 1
a963 1
  child_ops.to_detach (args, from_tty);
d2250 1
a2250 1
  child_ops.to_create_inferior (exec_file, allargs, env, from_tty);
d2265 1
a2265 1
  child_ops.to_mourn_inferior ();
@


1.11
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* inftarg.c (inftarg_set_find_memory_regions)
	(inftarg_set_make_corefile_notes): Delete functions.
	(_initialize_linux_nat): Inline calls.
@
text
@d525 1
a525 1
      ptrace_wait (null_ptid, &status);
d530 1
a530 1
  ret = ptrace_wait (null_ptid, &status);
d538 1
a538 1
      ret = ptrace_wait (null_ptid, &status);
@


1.10
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* target.h (child_ops): Declare.
	* inftarg.c (child_ops): Move from here ...
	* target.c (child_ops): ... to here.
	* wince.c (child_ops): Delete extern declaration.
	* win32-nat.c (child_ops): Delete extern declaration.
	* linux-nat.c (child_ops): Delete extern declaration.
	* hpux-thread.c (child_ops): Delete extern declaration.
@
text
@a3013 2
  extern void inftarg_set_find_memory_regions ();
  extern void inftarg_set_make_corefile_notes ();
d3015 2
a3016 2
  inftarg_set_find_memory_regions (linux_nat_find_memory_regions);
  inftarg_set_make_corefile_notes (linux_nat_make_corefile_notes);
@


1.9
log
@2004-09-28  Andrew Cagney  <cagney@@gnu.org>

	* linux-proc.c: Delete file.
	* Makefile.in: Update.
	* config/sparc/linux64.mh (NATDEPFILES):
	* config/sparc/linux.mh (NATDEPFILES): Update.
	* config/s390/s390.mh (NATDEPFILES): Update.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Update.
	* config/powerpc/linux.mh (NATDEPFILES): Update.
	* config/pa/linux.mh (NATDEPFILES): Update.
	* config/mips/linux.mh (NATDEPFILES): Update.
	* config/m68k/linux.mh (NATDEPFILES): Update.
	* config/ia64/linux.mh (NATDEPFILES): Update.
	* config/i386/linux64.mh (NATDEPFILES): Update.
	* config/i386/linux.mh (NATDEPFILES): Update.
	* config/arm/linux.mh (NATDEPFILES): Update.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Update.
	* linux-nat.c: Update copyright.  Include <sys/param.h>,
	<sys/procfs.h>, "elf-bfd.h", "gregset.h", <ctype.h>,
	"gdbthread.h", "gdb_stat.h", <fcntl.h>.
	(O_LARGEFILE): Possibly define.
	(_initialize_linux_nat, linux_proc_pending_signals)
	(add_line_to_sigset, linux_proc_xfer_memory)
	(linux_nat_info_proc_cmd, linux_nat_make_corefile_notes)
	(linux_nat_do_registers, linux_nat_corefile_thread_callback)
	(struct linux_corefile_thread_data)
	(linux_nat_do_thread_registers, linux_nat_find_memory_regions)
	(child_pid_to_exec_file): Insert code previously in linux-proc.c.
@
text
@a85 2
extern struct target_ops child_ops;

a599 3
/* The standard child operations.  */
extern struct target_ops child_ops;

@


1.8
log
@2004-09-16  Andrew Cagney  <cagney@@gnu.org>

	* lin-lwp.c: Delete file.
	* linux-nat.c: Include "gdb_assert.h", "gdb_string.h", <unistd.h>,
	<sys/syscall.h>, "gdbthread.h", "gdbcmd.h", "regcache.h".
	(status_to_str, init_lwp_list, add_lwp, delete_lwp)
	(find_lwp_pid, iterate_over_lwps, lin_lwp_attach_lwp)
	(linux_nat_attach, detach_callback, linux_nat_detach)
	(resume_callback, resume_clear_callback, linux_nat_resume)
	(kill_lwp, linux_nat_handle_extended, wait_lwp, stop_callback)
	(stop_wait_callback, linux_nat_has_pending, flush_callback)
	(status_callback, running_callback, count_events_callback)
	(select_singlestep_lwp_callback, select_event_lwp_callback)
	(cancel_breakpoints_callback, select_event_lwp, resumed_callback)
	(child_wait, stop_and_resume_callback, linux_nat_wait)
	(kill_callback, kill_wait_callback, linux_nat_kill)
	(linux_nat_create_inferior, linux_nat_mourn_inferior)
	(linux_nat_xfer_memory, linux_nat_thread_alive)
	(linux_nat_pid_to_str, init_linux_nat_ops, sigchld_handler)
	(_initialize_linux_nat): New functions.
	* Makefile.in: Update all dependencies.
	* config/sparc/linux64.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/sparc/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/s390/s390.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/powerpc/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/pa/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/mips/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/m68k/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/ia64/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/i386/linux64.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/i386/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/arm/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Remove lin-lwp.o.
@
text
@d2 2
a3 1
   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
d37 13
d2365 649
d3018 3
d3022 11
a3032 1
  extern void thread_db_init (struct target_ops *);
@


1.7
log
@* linux-nat.c (kill_inferior): Add missing third and fourth
arguments to ptrace call.  Don't use PTRACE_ARG3_TYPE.
@
text
@d24 1
a24 1

d26 5
a31 1

d33 3
d70 2
d531 1917
@


1.6
log
@	* Makefile.in (linux_nat_h): Update dependencies.
	* configure.in: Check for <gnu/libc-version.h>.
	* configure: Regenerate.
	* config.in: Regenerate.
	* linux-nat.h: Include "target.h".  Add waitstatus field to
	struct lwp_info.
	* lin-lwp.c (add_lwp): Initialize waitstatus.kind.
	(lin_lwp_attach_lwp): Don't attach to LWPs we have already attached
	to.
	(lin_lwp_handle_extended): New function.  Handle clone events.
	(wait_lwp): Use lin_lwp_handle_extended.  Update comment about
	thread exit events.
	(child_wait): Handle clone events.
	(lin_lwp_wait: Use lin_lwp_handle_extended and handle clone events.
	* linux-nat.c (linux_enable_event_reporting): Turn on
	PTRACE_O_TRACECLONE.
	(linux_handle_extended_wait): Handle clone events.
	* thread-db.c: Include <gnu/libc-version.h>.
	(struct private_thread_info): Add dying flag.
	(enable_thread_event_reporting): Enable TD_DEATH for glibc 2.2 and
	higher.
	(attach_thread): Update comments.  Handle dying threads.
	(detach_thread): Set the dying flag.
	(check_event): Always call attach_thread.
@
text
@d503 1
a503 1
      ptrace (PT_KILL, last.value.related_pid);
d508 1
a508 1
  ptrace (PT_KILL, pid, (PTRACE_ARG3_TYPE) 0, 0);
d516 1
a516 1
      ptrace (PT_KILL, pid, (PTRACE_ARG3_TYPE) 0, 0);
@


1.5
log
@	* linux-nat.c (PTRACE_O_TRACEVFORKDONE, PTRACE_O_TRACEEXIT): Define.
	(PTRACE_EVENT_VFORKDONE, PTRACE_EVENT_EXIT): Define.
	(linux_parent_pid, linux_supports_tracevforkdone_flag): New variable.
	(linux_test_for_tracefork): Set linux_supports_tracevforkdone_flag.
	(linux_supports_tracevforkdone): New function.
	(linux_enable_event_reporting): Enable TRACEVFORK, TRACEEXEC, and
	TRACEVFORKDONE.
	(child_follow_fork): Handle vfork.
	(linux_handle_extended_wait): Likewise.  Also handle exec.
	(child_insert_vfork_catchpoint, child_insert_exec_catchpoint): Enable.
	* NEWS: Mention fork tracing.
@
text
@d2 1
a2 1
   Copyright (C) 2003 Free Software Foundation, Inc.
d227 2
a228 1
  options = PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | PTRACE_O_TRACEEXEC;
d395 2
a396 5
  if (event == PTRACE_EVENT_CLONE)
    internal_error (__FILE__, __LINE__,
		    "unexpected clone event");

  if (event == PTRACE_EVENT_FORK || event == PTRACE_EVENT_VFORK)
d407 1
a407 4
	     hits the SIGSTOP, but we're already attached.

	     It won't be a clone (we didn't ask for clones in the event mask)
	     so we can just call waitpid and wait for the SIGSTOP.  */
d409 2
a410 1
	    ret = waitpid (new_pid, &status, 0);
d422 7
a428 2
      ourstatus->kind = (event == PTRACE_EVENT_FORK)
	? TARGET_WAITKIND_FORKED : TARGET_WAITKIND_VFORKED;
@


1.5.14.1
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
d227 1
a227 2
  options = PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | PTRACE_O_TRACEEXEC
    | PTRACE_O_TRACECLONE;
d394 5
a398 2
  if (event == PTRACE_EVENT_FORK || event == PTRACE_EVENT_VFORK
      || event == PTRACE_EVENT_CLONE)
d409 4
a412 1
	     hits the SIGSTOP, but we're already attached.  */
d414 1
a414 2
	    ret = waitpid (new_pid, &status,
			   (event == PTRACE_EVENT_CLONE) ? __WCLONE : 0);
d426 2
a427 7
      if (event == PTRACE_EVENT_FORK)
	ourstatus->kind = TARGET_WAITKIND_FORKED;
      else if (event == PTRACE_EVENT_VFORK)
	ourstatus->kind = TARGET_WAITKIND_VFORKED;
      else
	ourstatus->kind = TARGET_WAITKIND_SPURIOUS;

@


1.5.14.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d503 1
a503 1
      ptrace (PT_KILL, last.value.related_pid, 0, 0);
d508 1
a508 1
  ptrace (PT_KILL, pid, 0, 0);
d516 1
a516 1
      ptrace (PT_KILL, pid, 0, 0);
@


1.5.8.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.4
log
@	* Makefile.in (i386-linux-nat.o): Update dependencies.
	* config/i386/nm-linux.h (LINUX_CHILD_POST_STARTUP_INFERIOR): Define.
	* config/nm-linux.h (CHILD_POST_STARTUP_INFERIOR, CHILD_POST_ATTACH)
	(CHILD_FOLLOW_FORK, KILL_INFERIOR): Define.
	* i386-linux-nat.c: Include "linux-nat.h".
	(child_post_startup_inferior): New function.
	* i386-nat.c (child_post_startup_inferior): Wrap in #ifdef.
	* infptrace.c (kill_inferior): Wrap in #ifdef.
	* lin-lwp.c (lin_lwp_attach_lwp): Call child_post_attach after
	attaching to each LWP.
	(child_wait, lin_lwp_wait): Call linux_handle_extended_wait.
	(init_lin_lwp_ops): Fill in some more operations.
	* linux-nat.h (linux_enable_event_reporting)
	(linux_handle_extended_wait, linux_child_post_startup_inferior): New
	prototypes.
	* linux-nat.c (linux_enable_event_reporting): New function.
	(child_post_attach, linux_child_post_startup_inferior)
	(child_post_startup_inferior, child_follow_fork)
	(linux_handle_extended_wait, kill_inferior): New functions.
@
text
@d43 2
d51 2
d65 2
d79 5
d169 5
d209 8
d227 6
a232 1
  options = PTRACE_O_TRACEFORK;
d262 1
d266 1
d277 2
d286 53
d345 2
a346 1
      detach_breakpoints (child_pid);
d355 22
a376 1
      target_detach (NULL, 0);
d398 1
a398 1
  if (event == PTRACE_EVENT_FORK)
d426 2
a427 1
      ourstatus->kind = TARGET_WAITKIND_FORKED;
d432 17
d466 1
a466 3
  if (linux_supports_tracefork ())
    error ("Vfork catchpoints have not been implemented yet.");
  else
d468 2
d475 1
a475 3
  if (linux_supports_tracefork ())
    error ("Exec catchpoints have not been implemented yet.");
  else
d477 2
@


1.3
log
@2003-06-19  Michael Snyder  <msnyder@@redhat.com>

	* linux-nat.h: New file.
	* linux-nat.c: Include linux-nat.h.
	* lin-lwp.c: Include linux-nat.h.
	Move struct lwp_info def to linux-nat.h.
	* linux-proc.c: Include linux-nat.h.
	(linux_make_note_section): Iterate over lwps instead of threads.
	(linux_do_thread_registers): Use lwp instead of merged pid.
	* config/nm-linux.h: Move miscelaneous def'ns to linux-nat.h.
	* Makefile.in (lin-lwp.o, linux-proc.o, linux-nat.o):
	Add dependency on linux_nat_h.
@
text
@d59 2
d194 134
d331 1
a331 3
  if (linux_supports_tracefork ())
    error ("Fork catchpoints have not been implemented yet.");
  else
d333 2
d355 17
d373 22
@


1.3.2.1
log
@	* Makefile.in (i386-linux-nat.o): Update dependencies.
	* config/i386/nm-linux.h (LINUX_CHILD_POST_STARTUP_INFERIOR): Define.
	* config/nm-linux.h (CHILD_POST_STARTUP_INFERIOR, CHILD_POST_ATTACH)
	(CHILD_FOLLOW_FORK, KILL_INFERIOR): Define.
	* i386-linux-nat.c: Include "linux-nat.h".
	(child_post_startup_inferior): New function.
	* i386-nat.c (child_post_startup_inferior): Wrap in #ifdef.
	* infptrace.c (kill_inferior): Wrap in #ifdef.
	* lin-lwp.c (lin_lwp_attach_lwp): Call child_post_attach after
	attaching to each LWP.
	(child_wait, lin_lwp_wait): Call linux_handle_extended_wait.
	(init_lin_lwp_ops): Fill in some more operations.
	* linux-nat.h (linux_enable_event_reporting)
	(linux_handle_extended_wait, linux_child_post_startup_inferior): New
	prototypes.
	* linux-nat.c (linux_enable_event_reporting): New function.
	(child_post_attach, linux_child_post_startup_inferior)
	(child_post_startup_inferior, child_follow_fork)
	(linux_handle_extended_wait, kill_inferior): New functions.
@
text
@a58 2
extern struct target_ops child_ops;

a191 34
void
linux_enable_event_reporting (ptid_t ptid)
{
  int pid = ptid_get_pid (ptid);
  int options;

  if (! linux_supports_tracefork ())
    return;

  options = PTRACE_O_TRACEFORK;

  ptrace (PTRACE_SETOPTIONS, pid, 0, options);
}

void
child_post_attach (int pid)
{
  linux_enable_event_reporting (pid_to_ptid (pid));
}

void
linux_child_post_startup_inferior (ptid_t ptid)
{
  linux_enable_event_reporting (ptid);
}

#ifndef LINUX_CHILD_POST_STARTUP_INFERIOR
void
child_post_startup_inferior (ptid_t ptid)
{
  linux_child_post_startup_inferior (ptid);
}
#endif

d193 1
a193 1
child_follow_fork (int follow_child)
d195 2
a196 23
  ptid_t last_ptid;
  struct target_waitstatus last_status;
  int parent_pid, child_pid;

  get_last_target_status (&last_ptid, &last_status);
  parent_pid = ptid_get_pid (last_ptid);
  child_pid = last_status.value.related_pid;

  if (! follow_child)
    {
      /* We're already attached to the parent, by default. */

      /* Before detaching from the child, remove all breakpoints from
         it.  (This won't actually modify the breakpoint list, but will
         physically remove the breakpoints from the child.) */
      detach_breakpoints (child_pid);

      fprintf_filtered (gdb_stdout,
			"Detaching after fork from child process %d.\n",
			child_pid);

      ptrace (PTRACE_DETACH, child_pid, 0, 0);
    }
a197 77
    {
      char child_pid_spelling[40];

      /* Needed to keep the breakpoint lists in sync.  */
      detach_breakpoints (child_pid);

      /* Before detaching from the parent, remove all breakpoints from it. */
      remove_breakpoints ();

      fprintf_filtered (gdb_stdout,
			"Attaching after fork to child process %d.\n",
			child_pid);

      target_detach (NULL, 0);

      inferior_ptid = pid_to_ptid (child_pid);
      push_target (&child_ops);

      /* Reset breakpoints in the child as appropriate.  */
      follow_inferior_reset_breakpoints ();
    }

  return 0;
}

ptid_t
linux_handle_extended_wait (int pid, int status,
			    struct target_waitstatus *ourstatus)
{
  int event = status >> 16;

  if (event == PTRACE_EVENT_CLONE)
    internal_error (__FILE__, __LINE__,
		    "unexpected clone event");

  if (event == PTRACE_EVENT_FORK)
    {
      unsigned long new_pid;
      int ret;

      ptrace (PTRACE_GETEVENTMSG, pid, 0, &new_pid);

      /* If we haven't already seen the new PID stop, wait for it now.  */
      if (! pull_pid_from_list (&stopped_pids, new_pid))
	{
	  /* The new child has a pending SIGSTOP.  We can't affect it until it
	     hits the SIGSTOP, but we're already attached.

	     It won't be a clone (we didn't ask for clones in the event mask)
	     so we can just call waitpid and wait for the SIGSTOP.  */
	  do {
	    ret = waitpid (new_pid, &status, 0);
	  } while (ret == -1 && errno == EINTR);
	  if (ret == -1)
	    perror_with_name ("waiting for new child");
	  else if (ret != new_pid)
	    internal_error (__FILE__, __LINE__,
			    "wait returned unexpected PID %d", ret);
	  else if (!WIFSTOPPED (status) || WSTOPSIG (status) != SIGSTOP)
	    internal_error (__FILE__, __LINE__,
			    "wait returned unexpected status 0x%x", status);
	}

      ourstatus->kind = TARGET_WAITKIND_FORKED;
      ourstatus->value.related_pid = new_pid;
      return inferior_ptid;
    }

  internal_error (__FILE__, __LINE__,
		  "unknown ptrace event %d", event);
}


int
child_insert_fork_catchpoint (int pid)
{
  if (! linux_supports_tracefork ())
a198 2

  return 0;
a218 17
void
kill_inferior (void)
{
  int status;
  int pid =  PIDGET (inferior_ptid);
  struct target_waitstatus last;
  ptid_t last_ptid;
  int ret;

  if (pid == 0)
    return;

  /* If we're stopped while forking and we haven't followed yet, kill the
     other task.  We need to do this first because the parent will be
     sleeping if this is a vfork.  */

  get_last_target_status (&last_ptid, &last);
a219 22
  if (last.kind == TARGET_WAITKIND_FORKED
      || last.kind == TARGET_WAITKIND_VFORKED)
    {
      ptrace (PT_KILL, last.value.related_pid);
      ptrace_wait (null_ptid, &status);
    }

  /* Kill the current process.  */
  ptrace (PT_KILL, pid, (PTRACE_ARG3_TYPE) 0, 0);
  ret = ptrace_wait (null_ptid, &status);

  /* We might get a SIGCHLD instead of an exit status.  This is
     aggravated by the first kill above - a child has just died.  */

  while (ret == pid && WIFSTOPPED (status))
    {
      ptrace (PT_KILL, pid, (PTRACE_ARG3_TYPE) 0, 0);
      ret = ptrace_wait (null_ptid, &status);
    }

  target_mourn_inferior ();
}
@


1.3.2.2
log
@	* linux-nat.c (PTRACE_O_TRACEVFORKDONE, PTRACE_O_TRACEEXIT): Define.
	(PTRACE_EVENT_VFORKDONE, PTRACE_EVENT_EXIT): Define.
	(linux_parent_pid, linux_supports_tracevforkdone_flag): New variable.
	(linux_test_for_tracefork): Set linux_supports_tracevforkdone_flag.
	(linux_supports_tracevforkdone): New function.
	(linux_enable_event_reporting): Enable TRACEVFORK, TRACEEXEC, and
	TRACEVFORKDONE.
	(child_follow_fork): Handle vfork.
	(linux_handle_extended_wait): Likewise.  Also handle exec.
	(child_insert_vfork_catchpoint, child_insert_exec_catchpoint): Enable.
	* NEWS: Mention fork tracing.
@
text
@a42 2
#define PTRACE_O_TRACEVFORKDONE	0x00000020
#define PTRACE_O_TRACEEXIT	0x00000040
a48 2
#define PTRACE_EVENT_VFORKDONE	5
#define PTRACE_EVENT_EXIT	6
a60 2
static int linux_parent_pid;

a72 5
/* If we have PTRACE_O_TRACEFORK, this flag indicates whether we also have
   PTRACE_O_TRACEVFORKDONE.  */

static int linux_supports_tracevforkdone_flag = -1;

a157 5
  /* Check whether PTRACE_O_TRACEVFORKDONE is available.  */
  ret = ptrace (PTRACE_SETOPTIONS, child_pid, 0,
		PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORKDONE);
  linux_supports_tracevforkdone_flag = (ret == 0);

a192 8
static int
linux_supports_tracevforkdone (void)
{
  if (linux_supports_tracefork_flag == -1)
    linux_test_for_tracefork ();
  return linux_supports_tracevforkdone_flag;
}

d203 1
a203 6
  options = PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | PTRACE_O_TRACEEXEC;
  if (linux_supports_tracevforkdone ())
    options |= PTRACE_O_TRACEVFORKDONE;

  /* Do not enable PTRACE_O_TRACEEXIT until GDB is more prepared to support
     read-only process state.  */
a232 1
  int has_vforked;
a235 1
  has_vforked = (last_status.kind == TARGET_WAITKIND_VFORKED);
a245 2
      /* If we vforked this will remove the breakpoints from the parent
	 also, but they'll be reinserted below.  */
a252 53

      if (has_vforked)
	{
	  if (linux_supports_tracevforkdone ())
	    {
	      int status;

	      ptrace (PTRACE_CONT, parent_pid, 0, 0);
	      waitpid (parent_pid, &status, __WALL);
	      if ((status >> 16) != PTRACE_EVENT_VFORKDONE)
		warning ("Unexpected waitpid result %06x when waiting for "
			 "vfork-done", status);
	    }
	  else
	    {
	      /* We can't insert breakpoints until the child has
		 finished with the shared memory region.  We need to
		 wait until that happens.  Ideal would be to just
		 call:
		 - ptrace (PTRACE_SYSCALL, parent_pid, 0, 0);
		 - waitpid (parent_pid, &status, __WALL);
		 However, most architectures can't handle a syscall
		 being traced on the way out if it wasn't traced on
		 the way in.

		 We might also think to loop, continuing the child
		 until it exits or gets a SIGTRAP.  One problem is
		 that the child might call ptrace with PTRACE_TRACEME.

		 There's no simple and reliable way to figure out when
		 the vforked child will be done with its copy of the
		 shared memory.  We could step it out of the syscall,
		 two instructions, let it go, and then single-step the
		 parent once.  When we have hardware single-step, this
		 would work; with software single-step it could still
		 be made to work but we'd have to be able to insert
		 single-step breakpoints in the child, and we'd have
		 to insert -just- the single-step breakpoint in the
		 parent.  Very awkward.

		 In the end, the best we can do is to make sure it
		 runs for a little while.  Hopefully it will be out of
		 range of any breakpoints we reinsert.  Usually this
		 is only the single-step breakpoint at vfork's return
		 point.  */

	      usleep (10000);
	    }

	  /* Since we vforked, breakpoints were removed in the parent
	     too.  Put them back.  */
	  reattach_breakpoints (parent_pid);
	}
d259 1
a259 2
      if (! has_vforked)
	detach_breakpoints (child_pid);
d268 1
a268 22
      /* If we're vforking, we may want to hold on to the parent until
	 the child exits or execs.  At exec time we can remove the old
	 breakpoints from the parent and detach it; at exit time we
	 could do the same (or even, sneakily, resume debugging it - the
	 child's exec has failed, or something similar).

	 This doesn't clean up "properly", because we can't call
	 target_detach, but that's OK; if the current target is "child",
	 then it doesn't need any further cleanups, and lin_lwp will
	 generally not encounter vfork (vfork is defined to fork
	 in libpthread.so).

	 The holding part is very easy if we have VFORKDONE events;
	 but keeping track of both processes is beyond GDB at the
	 moment.  So we don't expose the parent to the rest of GDB.
	 Instead we quietly hold onto it until such time as we can
	 safely resume it.  */

      if (has_vforked)
	linux_parent_pid = parent_pid;
      else
	target_detach (NULL, 0);
d290 1
a290 1
  if (event == PTRACE_EVENT_FORK || event == PTRACE_EVENT_VFORK)
d318 1
a318 2
      ourstatus->kind = (event == PTRACE_EVENT_FORK)
	? TARGET_WAITKIND_FORKED : TARGET_WAITKIND_VFORKED;
a322 17
  if (event == PTRACE_EVENT_EXEC)
    {
      ourstatus->kind = TARGET_WAITKIND_EXECD;
      ourstatus->value.execd_pathname
	= xstrdup (child_pid_to_exec_file (pid));

      if (linux_parent_pid)
	{
	  detach_breakpoints (linux_parent_pid);
	  ptrace (PTRACE_DETACH, linux_parent_pid, 0, 0);

	  linux_parent_pid = 0;
	}

      return inferior_ptid;
    }

d340 3
a342 1
  if (!linux_supports_tracefork ())
a343 2

  return 0;
d349 3
a351 1
  if (!linux_supports_tracefork ())
a352 2

  return 0;
@


1.3.4.1
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@@


1.3.4.2
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a42 2
#define PTRACE_O_TRACEVFORKDONE	0x00000020
#define PTRACE_O_TRACEEXIT	0x00000040
a48 2
#define PTRACE_EVENT_VFORKDONE	5
#define PTRACE_EVENT_EXIT	6
a58 4
extern struct target_ops child_ops;

static int linux_parent_pid;

a70 5
/* If we have PTRACE_O_TRACEFORK, this flag indicates whether we also have
   PTRACE_O_TRACEVFORKDONE.  */

static int linux_supports_tracevforkdone_flag = -1;

a155 5
  /* Check whether PTRACE_O_TRACEVFORKDONE is available.  */
  ret = ptrace (PTRACE_SETOPTIONS, child_pid, 0,
		PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORKDONE);
  linux_supports_tracevforkdone_flag = (ret == 0);

a190 8
static int
linux_supports_tracevforkdone (void)
{
  if (linux_supports_tracefork_flag == -1)
    linux_test_for_tracefork ();
  return linux_supports_tracevforkdone_flag;
}

a191 39
void
linux_enable_event_reporting (ptid_t ptid)
{
  int pid = ptid_get_pid (ptid);
  int options;

  if (! linux_supports_tracefork ())
    return;

  options = PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | PTRACE_O_TRACEEXEC;
  if (linux_supports_tracevforkdone ())
    options |= PTRACE_O_TRACEVFORKDONE;

  /* Do not enable PTRACE_O_TRACEEXIT until GDB is more prepared to support
     read-only process state.  */

  ptrace (PTRACE_SETOPTIONS, pid, 0, options);
}

void
child_post_attach (int pid)
{
  linux_enable_event_reporting (pid_to_ptid (pid));
}

void
linux_child_post_startup_inferior (ptid_t ptid)
{
  linux_enable_event_reporting (ptid);
}

#ifndef LINUX_CHILD_POST_STARTUP_INFERIOR
void
child_post_startup_inferior (ptid_t ptid)
{
  linux_child_post_startup_inferior (ptid);
}
#endif

d193 1
a193 1
child_follow_fork (int follow_child)
d195 2
a196 80
  ptid_t last_ptid;
  struct target_waitstatus last_status;
  int has_vforked;
  int parent_pid, child_pid;

  get_last_target_status (&last_ptid, &last_status);
  has_vforked = (last_status.kind == TARGET_WAITKIND_VFORKED);
  parent_pid = ptid_get_pid (last_ptid);
  child_pid = last_status.value.related_pid;

  if (! follow_child)
    {
      /* We're already attached to the parent, by default. */

      /* Before detaching from the child, remove all breakpoints from
         it.  (This won't actually modify the breakpoint list, but will
         physically remove the breakpoints from the child.) */
      /* If we vforked this will remove the breakpoints from the parent
	 also, but they'll be reinserted below.  */
      detach_breakpoints (child_pid);

      fprintf_filtered (gdb_stdout,
			"Detaching after fork from child process %d.\n",
			child_pid);

      ptrace (PTRACE_DETACH, child_pid, 0, 0);

      if (has_vforked)
	{
	  if (linux_supports_tracevforkdone ())
	    {
	      int status;

	      ptrace (PTRACE_CONT, parent_pid, 0, 0);
	      waitpid (parent_pid, &status, __WALL);
	      if ((status >> 16) != PTRACE_EVENT_VFORKDONE)
		warning ("Unexpected waitpid result %06x when waiting for "
			 "vfork-done", status);
	    }
	  else
	    {
	      /* We can't insert breakpoints until the child has
		 finished with the shared memory region.  We need to
		 wait until that happens.  Ideal would be to just
		 call:
		 - ptrace (PTRACE_SYSCALL, parent_pid, 0, 0);
		 - waitpid (parent_pid, &status, __WALL);
		 However, most architectures can't handle a syscall
		 being traced on the way out if it wasn't traced on
		 the way in.

		 We might also think to loop, continuing the child
		 until it exits or gets a SIGTRAP.  One problem is
		 that the child might call ptrace with PTRACE_TRACEME.

		 There's no simple and reliable way to figure out when
		 the vforked child will be done with its copy of the
		 shared memory.  We could step it out of the syscall,
		 two instructions, let it go, and then single-step the
		 parent once.  When we have hardware single-step, this
		 would work; with software single-step it could still
		 be made to work but we'd have to be able to insert
		 single-step breakpoints in the child, and we'd have
		 to insert -just- the single-step breakpoint in the
		 parent.  Very awkward.

		 In the end, the best we can do is to make sure it
		 runs for a little while.  Hopefully it will be out of
		 range of any breakpoints we reinsert.  Usually this
		 is only the single-step breakpoint at vfork's return
		 point.  */

	      usleep (10000);
	    }

	  /* Since we vforked, breakpoints were removed in the parent
	     too.  Put them back.  */
	  reattach_breakpoints (parent_pid);
	}
    }
a197 117
    {
      char child_pid_spelling[40];

      /* Needed to keep the breakpoint lists in sync.  */
      if (! has_vforked)
	detach_breakpoints (child_pid);

      /* Before detaching from the parent, remove all breakpoints from it. */
      remove_breakpoints ();

      fprintf_filtered (gdb_stdout,
			"Attaching after fork to child process %d.\n",
			child_pid);

      /* If we're vforking, we may want to hold on to the parent until
	 the child exits or execs.  At exec time we can remove the old
	 breakpoints from the parent and detach it; at exit time we
	 could do the same (or even, sneakily, resume debugging it - the
	 child's exec has failed, or something similar).

	 This doesn't clean up "properly", because we can't call
	 target_detach, but that's OK; if the current target is "child",
	 then it doesn't need any further cleanups, and lin_lwp will
	 generally not encounter vfork (vfork is defined to fork
	 in libpthread.so).

	 The holding part is very easy if we have VFORKDONE events;
	 but keeping track of both processes is beyond GDB at the
	 moment.  So we don't expose the parent to the rest of GDB.
	 Instead we quietly hold onto it until such time as we can
	 safely resume it.  */

      if (has_vforked)
	linux_parent_pid = parent_pid;
      else
	target_detach (NULL, 0);

      inferior_ptid = pid_to_ptid (child_pid);
      push_target (&child_ops);

      /* Reset breakpoints in the child as appropriate.  */
      follow_inferior_reset_breakpoints ();
    }

  return 0;
}

ptid_t
linux_handle_extended_wait (int pid, int status,
			    struct target_waitstatus *ourstatus)
{
  int event = status >> 16;

  if (event == PTRACE_EVENT_CLONE)
    internal_error (__FILE__, __LINE__,
		    "unexpected clone event");

  if (event == PTRACE_EVENT_FORK || event == PTRACE_EVENT_VFORK)
    {
      unsigned long new_pid;
      int ret;

      ptrace (PTRACE_GETEVENTMSG, pid, 0, &new_pid);

      /* If we haven't already seen the new PID stop, wait for it now.  */
      if (! pull_pid_from_list (&stopped_pids, new_pid))
	{
	  /* The new child has a pending SIGSTOP.  We can't affect it until it
	     hits the SIGSTOP, but we're already attached.

	     It won't be a clone (we didn't ask for clones in the event mask)
	     so we can just call waitpid and wait for the SIGSTOP.  */
	  do {
	    ret = waitpid (new_pid, &status, 0);
	  } while (ret == -1 && errno == EINTR);
	  if (ret == -1)
	    perror_with_name ("waiting for new child");
	  else if (ret != new_pid)
	    internal_error (__FILE__, __LINE__,
			    "wait returned unexpected PID %d", ret);
	  else if (!WIFSTOPPED (status) || WSTOPSIG (status) != SIGSTOP)
	    internal_error (__FILE__, __LINE__,
			    "wait returned unexpected status 0x%x", status);
	}

      ourstatus->kind = (event == PTRACE_EVENT_FORK)
	? TARGET_WAITKIND_FORKED : TARGET_WAITKIND_VFORKED;
      ourstatus->value.related_pid = new_pid;
      return inferior_ptid;
    }

  if (event == PTRACE_EVENT_EXEC)
    {
      ourstatus->kind = TARGET_WAITKIND_EXECD;
      ourstatus->value.execd_pathname
	= xstrdup (child_pid_to_exec_file (pid));

      if (linux_parent_pid)
	{
	  detach_breakpoints (linux_parent_pid);
	  ptrace (PTRACE_DETACH, linux_parent_pid, 0, 0);

	  linux_parent_pid = 0;
	}

      return inferior_ptid;
    }

  internal_error (__FILE__, __LINE__,
		  "unknown ptrace event %d", event);
}


int
child_insert_fork_catchpoint (int pid)
{
  if (! linux_supports_tracefork ())
a198 2

  return 0;
d204 3
a206 1
  if (!linux_supports_tracefork ())
a207 2

  return 0;
d213 3
a215 1
  if (!linux_supports_tracefork ())
a216 2

  return 0;
a218 8
void
kill_inferior (void)
{
  int status;
  int pid =  PIDGET (inferior_ptid);
  struct target_waitstatus last;
  ptid_t last_ptid;
  int ret;
a219 31
  if (pid == 0)
    return;

  /* If we're stopped while forking and we haven't followed yet, kill the
     other task.  We need to do this first because the parent will be
     sleeping if this is a vfork.  */

  get_last_target_status (&last_ptid, &last);

  if (last.kind == TARGET_WAITKIND_FORKED
      || last.kind == TARGET_WAITKIND_VFORKED)
    {
      ptrace (PT_KILL, last.value.related_pid);
      ptrace_wait (null_ptid, &status);
    }

  /* Kill the current process.  */
  ptrace (PT_KILL, pid, (PTRACE_ARG3_TYPE) 0, 0);
  ret = ptrace_wait (null_ptid, &status);

  /* We might get a SIGCHLD instead of an exit status.  This is
     aggravated by the first kill above - a child has just died.  */

  while (ret == pid && WIFSTOPPED (status))
    {
      ptrace (PT_KILL, pid, (PTRACE_ARG3_TYPE) 0, 0);
      ret = ptrace_wait (null_ptid, &status);
    }

  target_mourn_inferior ();
}
@


1.2
log
@	* config/nm-linux.h (linux_record_stopped_pid): New prototype.
	* lin-lwp.c (child_wait): Call linux_record_stopped_pid.
	(lin_lwp_wait): Likewise.  Update comments.
	* linux-nat.c (struct simple_pid_list, add_to_pid_list)
	(pull_pid_from_list, linux_record_stopped_pid): New.
@
text
@d28 2
@


1.1
log
@	* Makefile.in (linux-nat.o): Add rule.
	* linux-nat.c: New file.
	* config/nm-linux.h (CHILD_INSERT_FORK_CATCHPOINT): Define.
	(CHILD_INSERT_VFORK_CATCHPOINT): Define.
	(CHILD_INSERT_EXEC_CATCHPOINT): Define.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Add linux-nat.o.
	* config/arm/linux.mh (NATDEPFILES): Likewise.
	* config/i386/linux.mh (NATDEPFILES): Likewise.
	* config/i386/x86-64linux.mh (NATDEPFILES): Likewise.
	* config/ia64/linux.mh (NATDEPFILES): Likewise.
	* config/m68k/linux.mh (NATDEPFILES): Likewise.
	* config/mips/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/linux.mh (NATDEPFILES): Likewise.
	* config/s390/s390.mh (NATDEPFILES): Likewise.
	* config/sparc/linux.mh (NATDEPFILES): Likewise.
@
text
@d57 7
d68 34
@

