head	1.5;
access;
symbols
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	gdb_6_4-20051202-release:1.4
	msnyder-fork-checkpoint-branch:1.4.0.80
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.78
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.4.0.76
	gdb_6_4-2005-11-01-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.74
	gdb-csl-arm-20051020-branchpoint:1.4
	msnyder-tracepoint-checkpoint-branch:1.4.0.72
	msnyder-tracepoint-checkpoint-branchpoint:1.4
	gdb-csl-arm-20050325-2005-q1b:1.4
	gdb-csl-arm-20050325-2005-q1a:1.4
	csl-arm-20050325-branch:1.4.0.70
	csl-arm-20050325-branchpoint:1.4
	gdb-post-i18n-errorwarning-20050211:1.4
	gdb-pre-i18n-errorwarning-20050211:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.66
	gdb_6_3-20041019-branchpoint:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.68
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.64
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.4
	gdb_6_1-2004-04-05-release:1.4
	drow_intercu-merge-20040402:1.4
	drow_intercu-merge-20040327:1.4
	ezannoni_pie-20040323-branch:1.4.0.62
	ezannoni_pie-20040323-branchpoint:1.4
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.4.0.60
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.58
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow_intercu-20040221-branch:1.4.0.56
	drow_intercu-20040221-branchpoint:1.4
	cagney_bfdfile-20040213-branch:1.4.0.54
	cagney_bfdfile-20040213-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.52
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.4.0.50
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.48
	cagney_x86i386-20030821-branch:1.4.0.46
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.44
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.40
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.38
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.34
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.30
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.28
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.26
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.24
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.22
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.20
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.18
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.16
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030203-mergepoint:1.4
	interps-20030202-branch:1.4.0.14
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.12
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.4
	carlton_dictionary-20021115-merge:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.10
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.8
	carlton_dictionary-20020920-branchpoint:1.4
	gdb_5_3-branch:1.4.0.6
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.4
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.2
	readline_4_3-import-branchpoint:1.4
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.3.0.8
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.6
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.4
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.2
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.6
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.4
	gdb_5_1-2001-07-29-branchpoint:1.2
	dberlin-typesystem-branch:1.2.0.2
	dberlin-typesystem-branchpoint:1.2
	gdb-post-ptid_t-2001-05-03:1.2
	gdb-pre-ptid_t-2001-05-03:1.2
	insight-precleanup-2001-01-01:1.1.1.5
	gdb-post-protoization-2000-07-29:1.1.1.5
	gdb-pre-protoization-2000-07-29:1.1.1.5
	gdb-premipsmulti-2000-06-06-branch:1.1.1.5.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.5
	gdb-post-params-removal-2000-06-04:1.1.1.5
	gdb-pre-params-removal-2000-06-04:1.1.1.5
	gdb-post-params-removal-2000-05-28:1.1.1.5
	gdb-pre-params-removal-2000-05-28:1.1.1.5
	gdb_5_0-2000-05-19-release:1.1.1.5
	gdb_4_18_2-2000-05-18-release:1.1.1.5
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.5
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.5
	gdb_5_0-2000-04-10-branch:1.1.1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.5
	repo-unification-2000-02-06:1.1.1.5
	insight-2000-02-04:1.1.1.5
	gdb-2000-02-04:1.1.1.5
	gdb-2000-02-02:1.1.1.5
	gdb-2000-02-01:1.1.1.5
	gdb-2000-01-31:1.1.1.5
	gdb-2000-01-26:1.1.1.5
	gdb-2000-01-24:1.1.1.5
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2006.01.21.01.29.04;	author mmitchel;	state dead;
branches;
next	1.4;

1.4
date	2002.06.08.20.34.41;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.20.22.44.44;	author cagney;	state Exp;
branches
	1.3.6.1
	1.3.8.1;
next	1.2;

1.2
date	2001.05.03.13.41.17;	author jlarmour;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.27;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.27;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.11.02.04.44.26;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.11.09.01.23.14;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.01.06.03.06.50;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.01.25.02.40.14;	author jsm;	state Exp;
branches;
next	;

1.3.6.1
date	2002.06.15.16.43.14;	author cagney;	state Exp;
branches;
next	;

1.3.8.1
date	2002.06.20.01.36.28;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@	* Makefile.in (remote-rdi.o): Remove.
	(rdi-share/libangsd.a): Likewise.
	* README: Don't mention remote-rdi.c.
	* NEWS: Mention removal of rdi-share.
	* configure.ac: Don't configure rdi-share subdirectory.
	* remote-rdi.c: Remove.
	* config/arm/embed.mt (TDEPFILES): Remove remote-rdi.o.
	(TDEPLIBS): Remove rdi-share/libangsd.a.
	* rdi-share/Makefile.am: Remove.
	* rdi-share/Makefile.in: Likewise.
	* rdi-share/README.CYGNUS: Likewise.
	* rdi-share/aclocal.m4: Likewise.
	* rdi-share/adp.h: Likewise.
	* rdi-share/adperr.h: Likewise.
	* rdi-share/angel.h: Likewise.
	* rdi-share/angel_bytesex.c: Likewise.
	* rdi-share/angel_bytesex.h: Likewise.
	* rdi-share/angel_endian.h: Likewise.
	* rdi-share/ardi.c: Likewise.
	* rdi-share/ardi.h: Likewise.
	* rdi-share/armdbg.h: Likewise.
	* rdi-share/buffers.h: Likewise.
	* rdi-share/chandefs.h: Likewise.
	* rdi-share/channels.h: Likewise.
	* rdi-share/chanpriv.h: Likewise.
	* rdi-share/configure: Likewise.
	* rdi-share/configure.in: Likewise.
	* rdi-share/crc.c: Likewise.
	* rdi-share/crc.h: Likewise.
	* rdi-share/dbg_conf.h: Likewise.
	* rdi-share/dbg_cp.h: Likewise.
	* rdi-share/dbg_hif.h: Likewise.
	* rdi-share/dbg_rdi.h: Likewise.
	* rdi-share/devclnt.h: Likewise.
	* rdi-share/devices.h: Likewise.
	* rdi-share/devsw.c: Likewise.
	* rdi-share/devsw.h: Likewise.
	* rdi-share/drivers.c: Likewise.
	* rdi-share/drivers.h: Likewise.
	* rdi-share/etherdrv.c: Likewise.
	* rdi-share/ethernet.h: Likewise.
	* rdi-share/host.h: Likewise.
	* rdi-share/hostchan.c: Likewise.
	* rdi-share/hostchan.h: Likewise.
	* rdi-share/hsys.c: Likewise.
	* rdi-share/hsys.h: Likewise.
	* rdi-share/logging.c: Likewise.
	* rdi-share/logging.h: Likewise.
	* rdi-share/msgbuild.c: Likewise.
	* rdi-share/msgbuild.h: Likewise.
	* rdi-share/params.c: Likewise.
	* rdi-share/params.h: Likewise.
	* rdi-share/rx.c: Likewise.
	* rdi-share/rxtx.h: Likewise.
	* rdi-share/serdrv.c: Likewise.
	* rdi-share/serpardr.c: Likewise.
	* rdi-share/sys.h: Likewise.
	* rdi-share/tx.c: Likewise.
	* rdi-share/unixcomm.c: Likewise.
	* rdi-share/unixcomm.h: Likewise.
@
text
@/* 
 * Copyright (C) 1995 Advanced RISC Machines Limited. All rights reserved.
 * 
 * This software may be freely used, copied, modified, and distributed
 * provided that the above copyright notice is preserved in all copies of the
 * software.
 */

/* -*-C-*-
 *
 * $Revision: 1.8 $
 *     $Date: 2000/01/20 16:08:00 $
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <time.h>

#include "adp.h"
#include "sys.h"
#include "hsys.h"
#include "rxtx.h"
#include "drivers.h"
#include "buffers.h"
#include "devclnt.h"
#include "adperr.h"
#include "devsw.h"
#include "hostchan.h"
#include "logging.h"

static char *angelDebugFilename = NULL;
static FILE *angelDebugLogFile = NULL;
static int angelDebugLogEnable = 0;

static void openLogFile ()
{
  time_t t;
  
  if (angelDebugFilename == NULL || *angelDebugFilename =='\0')
    return;
  
  angelDebugLogFile = fopen (angelDebugFilename,"a");
  
  if (!angelDebugLogFile)
    {
      fprintf (stderr,"Error opening log file '%s'\n",angelDebugFilename);
      perror ("fopen");
    }
  else
    {
      /* The following line is equivalent to: */
      /* setlinebuf (angelDebugLogFile); */
      setvbuf(angelDebugLogFile, (char *)NULL, _IOLBF, 0);
#if defined(__CYGWIN__)
      setmode(fileno(angelDebugLogFile), O_TEXT);
#endif
    }
  
  time (&t);
  fprintf (angelDebugLogFile,"ADP log file opened at %s\n",asctime(localtime(&t)));
}


static void closeLogFile (void)
{
  time_t t;
  
  if (!angelDebugLogFile)
    return;
  
  time (&t);
  fprintf (angelDebugLogFile,"ADP log file closed at %s\n",asctime(localtime(&t)));
  
  fclose (angelDebugLogFile);
  angelDebugLogFile = NULL;
}

void DevSW_SetLogEnable (int logEnableFlag)
{
  if (logEnableFlag && !angelDebugLogFile)
    openLogFile ();
  else if (!logEnableFlag && angelDebugLogFile)
    closeLogFile ();
  
  angelDebugLogEnable = logEnableFlag;
}


void DevSW_SetLogfile (const char *filename)
{
  closeLogFile ();
  
  if (angelDebugFilename)
    {
      free (angelDebugFilename);
      angelDebugFilename = NULL;
    }
  
  if (filename && *filename)
    {
      angelDebugFilename = strdup (filename);
      if (angelDebugLogEnable)
        openLogFile ();
    }
}


#define WordAt(p)  ((unsigned long) ((p)[0] | ((p)[1]<<8) | ((p)[2]<<16) | ((p)[3]<<24)))

static void dumpPacket(FILE *fp, char *label, struct data_packet *p)
{
  unsigned r;
  int i;
  unsigned char channel;
  
  if (!fp)
    return;
  
  fprintf(fp,"%s [T=%d L=%d] ",label,p->type,p->len);
  for (i=0; i<p->len; ++i)
    fprintf(fp,"%02x ",p->data[i]);
  fprintf(fp,"\n");

  channel = p->data[0];

  r = WordAt(p->data+4);
  
  fprintf(fp,"R=%08x ",r);
  fprintf(fp,"%s ", r&0x80000000 ? "H<-T" : "H->T");

  switch (channel)
    {
     case CI_PRIVATE: fprintf(fp,"CI_PRIVATE: "); break;
     case CI_HADP: fprintf(fp,"CI_HADP: "); break;
     case CI_TADP: fprintf(fp,"CI_TADP: "); break;
     case CI_HBOOT: fprintf(fp,"CI_HBOOT: "); break;
     case CI_TBOOT: fprintf(fp,"CI_TBOOT: "); break;
     case CI_CLIB: fprintf(fp,"CI_CLIB: "); break;
     case CI_HUDBG: fprintf(fp,"CI_HUDBG: "); break;
     case CI_TUDBG: fprintf(fp,"CI_TUDBG: "); break;
     case CI_HTDCC: fprintf(fp,"CI_HTDCC: "); break;
     case CI_TTDCC: fprintf(fp,"CI_TTDCC: "); break;
     case CI_TLOG: fprintf(fp,"CI_TLOG: "); break;
     default:      fprintf(fp,"BadChan: "); break;
    }

  switch (r & 0xffffff)
    {
     case ADP_Booted: fprintf(fp," ADP_Booted "); break;
#if defined(ADP_TargetResetIndication)
     case ADP_TargetResetIndication: fprintf(fp," ADP_TargetResetIndication "); break;
#endif
     case ADP_Reboot: fprintf(fp," ADP_Reboot "); break;
     case ADP_Reset: fprintf(fp," ADP_Reset "); break;
#if defined(ADP_HostResetIndication)
     case ADP_HostResetIndication: fprintf(fp," ADP_HostResetIndication "); break;
#endif      
     case ADP_ParamNegotiate: fprintf(fp," ADP_ParamNegotiate "); break;
     case ADP_LinkCheck: fprintf(fp," ADP_LinkCheck "); break;
     case ADP_HADPUnrecognised: fprintf(fp," ADP_HADPUnrecognised "); break;
     case ADP_Info: fprintf(fp," ADP_Info "); break;
     case ADP_Control: fprintf(fp," ADP_Control "); break;
     case ADP_Read: fprintf(fp," ADP_Read "); break;
     case ADP_Write: fprintf(fp," ADP_Write "); break;
     case ADP_CPUread: fprintf(fp," ADP_CPUread "); break;
     case ADP_CPUwrite: fprintf(fp," ADP_CPUwrite "); break;
     case ADP_CPread: fprintf(fp," ADP_CPread "); break;
     case ADP_CPwrite: fprintf(fp," ADP_CPwrite "); break;
     case ADP_SetBreak: fprintf(fp," ADP_SetBreak "); break;
     case ADP_ClearBreak: fprintf(fp," ADP_ClearBreak "); break;
     case ADP_SetWatch: fprintf(fp," ADP_SetWatch "); break;
     case ADP_ClearWatch: fprintf(fp," ADP_ClearWatch "); break;
     case ADP_Execute: fprintf(fp," ADP_Execute "); break;
     case ADP_Step: fprintf(fp," ADP_Step "); break;
     case ADP_InterruptRequest: fprintf(fp," ADP_InterruptRequest "); break;
     case ADP_HW_Emulation: fprintf(fp," ADP_HW_Emulation "); break;
     case ADP_ICEbreakerHADP: fprintf(fp," ADP_ICEbreakerHADP "); break;
     case ADP_ICEman: fprintf(fp," ADP_ICEman "); break;
     case ADP_Profile: fprintf(fp," ADP_Profile "); break;
     case ADP_InitialiseApplication: fprintf(fp," ADP_InitialiseApplication "); break;
     case ADP_End: fprintf(fp," ADP_End "); break;
     case ADP_TADPUnrecognised: fprintf(fp," ADP_TADPUnrecognised "); break;
     case ADP_Stopped: fprintf(fp," ADP_Stopped "); break;
     case ADP_TDCC_ToHost: fprintf(fp," ADP_TDCC_ToHost "); break;
     case ADP_TDCC_FromHost: fprintf(fp," ADP_TDCC_FromHost "); break;

     case CL_Unrecognised: fprintf(fp," CL_Unrecognised "); break;
     case CL_WriteC: fprintf(fp," CL_WriteC "); break;
     case CL_Write0: fprintf(fp," CL_Write0 "); break;
     case CL_ReadC: fprintf(fp," CL_ReadC "); break;
     case CL_System: fprintf(fp," CL_System "); break;
     case CL_GetCmdLine: fprintf(fp," CL_GetCmdLine "); break;
     case CL_Clock: fprintf(fp," CL_Clock "); break;
     case CL_Time: fprintf(fp," CL_Time "); break;
     case CL_Remove: fprintf(fp," CL_Remove "); break;
     case CL_Rename: fprintf(fp," CL_Rename "); break;
     case CL_Open: fprintf(fp," CL_Open "); break;
     case CL_Close: fprintf(fp," CL_Close "); break;
     case CL_Write: fprintf(fp," CL_Write "); break;
     case CL_WriteX: fprintf(fp," CL_WriteX "); break;
     case CL_Read: fprintf(fp," CL_Read "); break;
     case CL_ReadX: fprintf(fp," CL_ReadX "); break;
     case CL_Seek: fprintf(fp," CL_Seek "); break;
     case CL_Flen: fprintf(fp," CL_Flen "); break;
     case CL_IsTTY: fprintf(fp," CL_IsTTY "); break;
     case CL_TmpNam: fprintf(fp," CL_TmpNam "); break;

     default: fprintf(fp," BadReason "); break;
    }

  i = 20;
  
  if (((r & 0xffffff) == ADP_CPUread ||
       (r & 0xffffff) == ADP_CPUwrite) && (r&0x80000000)==0)
    {
      fprintf(fp,"%02x ", p->data[i]);
      ++i;
    }
  
  for (; i<p->len; i+=4)
    fprintf(fp,"%08x ",WordAt(p->data+i));
  
  fprintf(fp,"\n");
}


/*
 * TODO: this should be adjustable - it could be done by defining
 *       a reason code for DevSW_Ioctl.  It could even be a
 *       per-devicechannel parameter.
 */
static const unsigned int allocsize = ADP_BUFFER_MIN_SIZE;

#define illegalDevChanID(type)  ((type) >= DC_NUM_CHANNELS)

/**********************************************************************/

/*
 *  Function: initialise_read
 *   Purpose: Set up a read request for another packet
 *
 *    Params:
 *      In/Out: ds      State structure to be initialised
 *
 *   Returns:
 *          OK: 0
 *       Error: -1
 */
static int initialise_read(DevSWState *ds)
{
    struct data_packet *dp;

    /*
     * try to claim the structure that will
     * eventually hold the new packet.
     */
    if ((ds->ds_nextreadpacket = DevSW_AllocatePacket(allocsize)) == NULL)
        return -1;

    /*
     * Calls into the device driver use the DriverCall structure: use
     * the buffer we have just allocated, and declare its size.  We
     * are also obliged to clear the driver's context pointer.
     */
    dp = &ds->ds_activeread.dc_packet;
    dp->buf_len = allocsize;
    dp->data = ds->ds_nextreadpacket->pk_buffer;

    ds->ds_activeread.dc_context = NULL;

    return 0;
}

/*
 *  Function: initialise_write
 *   Purpose: Set up a write request for another packet
 *
 *    Params:
 *       Input: packet  The packet to be written
 *
 *              type    The type of the packet
 *
 *      In/Out: dc      The structure to be intialised
 *
 *   Returns: Nothing
 */
static void initialise_write(DriverCall *dc, Packet *packet, DevChanID type)
{
    struct data_packet *dp = &dc->dc_packet;

    dp->len = packet->pk_length;
    dp->data = packet->pk_buffer;
    dp->type = type;

    /*
     * we are required to clear the state structure for the driver
     */
    dc->dc_context = NULL;
}

/*
 *  Function: enqueue_packet
 *   Purpose: move a newly read packet onto the appropriate queue
 *              of read packets
 *
 *    Params:
 *      In/Out: ds      State structure with new packet
 *
 *   Returns: Nothing
 */
static void enqueue_packet(DevSWState *ds)
{
    struct data_packet *dp = &ds->ds_activeread.dc_packet;
    Packet *packet = ds->ds_nextreadpacket;

    /*
     * transfer the length
     */
    packet->pk_length = dp->len;

    /*
     * take this packet out of the incoming slot
     */
    ds->ds_nextreadpacket = NULL;

    /*
     * try to put it on the correct input queue
     */
    if (illegalDevChanID(dp->type))
    {
        /* this shouldn't happen */
        WARN("Illegal type for Rx packet");
        DevSW_FreePacket(packet);
    }
    else
        Adp_addToQueue(&ds->ds_readqueue[dp->type], packet);
}

/*
 *  Function: flush_packet
 *   Purpose: Send a packet to the device driver
 *
 *    Params:
 *       Input: device  The device to be written to
 *
 *      In/Out: dc      Describes the packet to be sent
 *
 *   Returns: Nothing
 *
 * Post-conditions: If the whole packet was accepted by the device
 *                      driver, then dc->dc_packet.data will be
 *                      set to NULL.
 */
static void flush_packet(const DeviceDescr *device, DriverCall *dc)
{
    if (device->DeviceWrite(dc) > 0)
        /*
         * the whole packet was swallowed
         */
        dc->dc_packet.data = NULL;
}

/**********************************************************************/

/*
 * These are the externally visible functions.  They are documented in
 * devsw.h
 */
Packet *DevSW_AllocatePacket(const unsigned int length)
{
    Packet *pk;

    if ((pk = malloc(sizeof(*pk))) == NULL)
    {
        WARN("malloc failure");
        return NULL;
    }

    if ((pk->pk_buffer = malloc(length+CHAN_HEADER_SIZE)) == NULL)
    {
        WARN("malloc failure");
        free(pk);
        return NULL;
    }

    return pk;
}

void DevSW_FreePacket(Packet *pk)
{
    free(pk->pk_buffer);
    free(pk);
}

AdpErrs DevSW_Open(DeviceDescr *device, const char *name, const char *arg,
                   const DevChanID type)
{
    DevSWState *ds;

    /*
     * is this the very first open call for this driver?
     */
    if ((ds = (DevSWState *)(device->SwitcherState)) == NULL)
    {
        /*
         * yes, it is: initialise state
         */
        if ((ds = malloc(sizeof(*ds))) == NULL)
            /* give up */
            return adp_malloc_failure;

        (void)memset(ds, 0, sizeof(*ds));
        device->SwitcherState = (void *)ds;
    }

    /*
     * check that we haven't already been opened for this type
     */
    if ((ds->ds_opendevchans & (1 << type)) != 0)
        return adp_device_already_open;

    /*
     * if no opens have been done for this device, then do it now
     */
    if (ds->ds_opendevchans == 0)
        if (device->DeviceOpen(name, arg) < 0)
            return adp_device_open_failed;

    /*
     * open has finished
     */
    ds->ds_opendevchans |= (1 << type);
    return adp_ok;
}

AdpErrs DevSW_Match(const DeviceDescr *device, const char *name,
                    const char *arg)
{
    return (device->DeviceMatch(name, arg) == -1) ? adp_failed : adp_ok;
}

AdpErrs DevSW_Close (DeviceDescr *device, const DevChanID type)
{
    DevSWState *ds = (DevSWState *)(device->SwitcherState);
    Packet *pk;

    if ((ds->ds_opendevchans & (1 << type)) == 0)
        return adp_device_not_open;

    ds->ds_opendevchans &= ~(1 << type);

    /*
     * if this is the last close for this channel, then inform the driver
     */
    if (ds->ds_opendevchans == 0)
        device->DeviceClose();

    /*
     * release all packets of the appropriate type
     */
    for (pk = Adp_removeFromQueue(&(ds->ds_readqueue[type]));
         pk != NULL;
         pk = Adp_removeFromQueue(&(ds->ds_readqueue[type])))
        DevSW_FreePacket(pk);

    /* Free memory */
    free ((char *) device->SwitcherState);
    device->SwitcherState = 0x0;

    /* that's all */
    return adp_ok;
}

AdpErrs DevSW_Read(const DeviceDescr *device, const DevChanID type,
                   Packet **packet, bool block)
{
  int read_err;
  DevSWState *ds = device->SwitcherState;

    /*
     * To try to get information out of the device driver as
     * quickly as possible, we try and read more packets, even
     * if a completed packet is already available.
     */

    /*
     * have we got a packet currently pending?
     */
  if (ds->ds_nextreadpacket == NULL)
    /*
       * no - set things up
       */
    if (initialise_read(ds) < 0) {
      /*
       * we failed to initialise the next packet, but can
       * still return a packet that has already arrived.
       */
      *packet = Adp_removeFromQueue(&ds->ds_readqueue[type]); 
      return adp_ok;
    }
  read_err = device->DeviceRead(&ds->ds_activeread, block);
  switch (read_err) {
  case 1:
    /*
     * driver has pulled in a complete packet, queue it up
     */
#ifdef RET_DEBUG
    printf("got a complete packet\n");
#endif
    
    if (angelDebugLogEnable)
      dumpPacket(angelDebugLogFile,"rx:",&ds->ds_activeread.dc_packet);

    enqueue_packet(ds);
    *packet = Adp_removeFromQueue(&ds->ds_readqueue[type]);
    return adp_ok;
  case 0:
    /*
     * OK, return the head of the read queue for the given type
     */
    /*    enqueue_packet(ds); */
    *packet = Adp_removeFromQueue(&ds->ds_readqueue[type]);
    return adp_ok;
  case -1:
#ifdef RET_DEBUG
    printf("got a bad packet\n");
#endif
    /* bad packet */
    *packet = NULL;
    return adp_bad_packet;
  default:
    panic("DevSW_Read: bad read status %d", read_err);
  }
  return 0; /* get rid of a potential compiler warning */
}


AdpErrs DevSW_FlushPendingWrite(const DeviceDescr *device)
{
    struct DriverCall *dc;
    struct data_packet *dp;

    dc = &((DevSWState *)(device->SwitcherState))->ds_activewrite;
    dp = &dc->dc_packet;

    /*
     * try to flush any packet that is still being written
     */
    if (dp->data != NULL)
    {
        flush_packet(device, dc);

        /* see if it has gone */
        if (dp->data != NULL)
           return adp_write_busy;
        else
           return adp_ok;
    }
    else
       return adp_ok;
}


AdpErrs DevSW_Write(const DeviceDescr *device, Packet *packet, DevChanID type)
{
    struct DriverCall *dc;
    struct data_packet *dp;

    dc = &((DevSWState *)(device->SwitcherState))->ds_activewrite;
    dp = &dc->dc_packet;

    if (illegalDevChanID(type))
        return adp_illegal_args;

    /*
     * try to flush any packet that is still being written
     */
    if (DevSW_FlushPendingWrite(device) != adp_ok)
       return adp_write_busy;

    /*
     * we can take this packet - set things up, then try to get rid of it
     */
    initialise_write(dc, packet, type);
  
    if (angelDebugLogEnable)
      dumpPacket(angelDebugLogFile,"tx:",&dc->dc_packet);
  
    flush_packet(device, dc);

    return adp_ok;
}

AdpErrs DevSW_Ioctl(const DeviceDescr *device, const int opcode, void *args)
{
    return (device->DeviceIoctl(opcode, args) < 0) ? adp_failed : adp_ok;
}

bool DevSW_WriteFinished(const DeviceDescr *device)
{
    struct DriverCall *dc;
    struct data_packet *dp;

    dc = &((DevSWState *)(device->SwitcherState))->ds_activewrite;
    dp = &dc->dc_packet;

    return (dp == NULL || dp->data == NULL);
}

/* EOF devsw.c */
@


1.4
log
@* sparcl-tdep.c: Use __CYGWIN__ instead of __CYGWIN32__.
* rdi-share/serpardr.c: Ditto.
* rdi-share/unixcomm.c: Ditto.
* rdi-share/serdrv.c: Ditto.
* rdi-share/hostchan.h: Ditto.
* rdi-share/hostchan.c: Ditto.
* rdi-share/host.h: Ditto.
* rdi-share/devsw.c: Ditto.
@
text
@@


1.3
log
@* rdi-share/devsw.c (openLogFile): Delete unused ``struct tm lt''.
(closeLogFile): Ditto.
@
text
@d56 1
a56 1
#if defined(__CYGWIN32__) || defined(__CYGWIN__)
@


1.3.8.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d56 1
a56 1
#if defined(__CYGWIN__)
@


1.3.6.1
log
@merge from trunk
@
text
@d56 1
a56 1
#if defined(__CYGWIN__)
@


1.2
log
@        * rdi-share/devsw.c: Include <time.h> for struct tm
@
text
@a39 1
  struct tm lt;
a68 1
  struct tm lt;
@


1.1
log
@Initial revision
@
text
@d11 2
a12 2
 * $Revision: 1.3 $
 *     $Date: 1998/09/25 19:04:45 $
d17 3
d22 1
d33 198
d446 1
a446 1
AdpErrs DevSW_Close(const DeviceDescr *device, const DevChanID type)
d514 4
d589 4
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-11-01 snapshot
@
text
@d11 2
a12 2
 * $Revision: 1.4 $
 *     $Date: 1999/11/01 12:11:35 $
a16 1
#include <string.h>
a28 166
static char *angelDebugFilename = NULL;
static FILE *angelDebugLogFile = NULL;
static int angelDebugLogEnable = 0;

static void openLogFile ()
{
  time_t t;
  struct tm lt;
  
  if (angelDebugFilename == NULL || *angelDebugFilename =='\0')
    return;
  
  angelDebugLogFile = fopen (angelDebugFilename,"a");
  
  if (!angelDebugLogFile)
    {
      fprintf (stderr,"Error opening log file '%s'\n",angelDebugFilename);
      perror ("fopen");
    }
  else
    setlinebuf (angelDebugLogFile);
  
  time (&t);
  fprintf (angelDebugLogFile,"ADP log file opened at %s\n",asctime(localtime(&t)));
}


static void closeLogFile (void)
{
  time_t t;
  struct tm lt;
  
  if (!angelDebugLogFile)
    return;
  
  time (&t);
  fprintf (angelDebugLogFile,"ADP log file closed at %s\n",asctime(localtime(&t)));
  
  fclose (angelDebugLogFile);
  angelDebugLogFile = NULL;
}

void DevSW_SetLogEnable (int logEnableFlag)
{
  if (logEnableFlag && !angelDebugLogFile)
    openLogFile ();
  else if (!logEnableFlag && angelDebugLogFile)
    closeLogFile ();
  
  angelDebugLogEnable = logEnableFlag;
}


void DevSW_SetLogfile (const char *filename)
{
  closeLogFile ();
  
  if (angelDebugFilename)
    {
      free (angelDebugFilename);
      angelDebugFilename = NULL;
    }
  
  if (filename && *filename)
    {
      angelDebugFilename = strdup (filename);
      if (angelDebugLogEnable)
        openLogFile ();
    }
}


#define WordAt(p)  ((unsigned long) ((p)[0] | ((p)[1]<<8) | ((p)[2]<<16) | ((p)[3]<<24)))

static void dumpPacket(FILE *fp, char *label, struct data_packet *p)
{
  unsigned r;
  int i;
  
  if (!fp)
    return;
  
  fprintf(fp,"%s [T=%d L=%d] ",label,p->type,p->len);
  for (i=0; i<p->len; ++i)
    fprintf(fp,"%02x ",p->data[i]);
  fprintf(fp,"\n");

  r = WordAt(p->data+4);
  
  fprintf(fp,"R=%08x ",r);
  fprintf(fp,"%s ", r&0x80000000 ? "H<-T" : "H->T");

  switch ((r>>16) & 0xff)
    {
     case CI_PRIVATE: fprintf(fp,"CI_PRIVATE: "); break;
     case CI_HADP: fprintf(fp,"CI_HADP: "); break;
     case CI_TADP: fprintf(fp,"CI_TADP: "); break;
     case CI_HBOOT: fprintf(fp,"CI_HBOOT: "); break;
     case CI_TBOOT: fprintf(fp,"CI_TBOOT: "); break;
     case CI_CLIB: fprintf(fp,"CI_CLIB: "); break;
     case CI_HUDBG: fprintf(fp,"CI_HUDBG: "); break;
     case CI_TUDBG: fprintf(fp,"CI_TUDBG: "); break;
     case CI_HTDCC: fprintf(fp,"CI_HTDCC: "); break;
     case CI_TTDCC: fprintf(fp,"CI_TTDCC: "); break;
     case CI_TLOG: fprintf(fp,"CI_TLOG: "); break;
     default:      fprintf(fp,"BadChan: "); break;
    }

  switch (r & 0xffffff)
    {
     case ADP_Booted: fprintf(fp," ADP_Booted "); break;
#if defined(ADP_TargetResetIndication)
     case ADP_TargetResetIndication: fprintf(fp," ADP_TargetResetIndication "); break;
#endif
     case ADP_Reboot: fprintf(fp," ADP_Reboot "); break;
     case ADP_Reset: fprintf(fp," ADP_Reset "); break;
#if defined(ADP_HostResetIndication)
     case ADP_HostResetIndication: fprintf(fp," ADP_HostResetIndication "); break;
#endif      
     case ADP_ParamNegotiate: fprintf(fp," ADP_ParamNegotiate "); break;
     case ADP_LinkCheck: fprintf(fp," ADP_LinkCheck "); break;
     case ADP_HADPUnrecognised: fprintf(fp," ADP_HADPUnrecognised "); break;
     case ADP_Info: fprintf(fp," ADP_Info "); break;
     case ADP_Control: fprintf(fp," ADP_Control "); break;
     case ADP_Read: fprintf(fp," ADP_Read "); break;
     case ADP_Write: fprintf(fp," ADP_Write "); break;
     case ADP_CPUread: fprintf(fp," ADP_CPUread "); break;
     case ADP_CPUwrite: fprintf(fp," ADP_CPUwrite "); break;
     case ADP_CPread: fprintf(fp," ADP_CPread "); break;
     case ADP_CPwrite: fprintf(fp," ADP_CPwrite "); break;
     case ADP_SetBreak: fprintf(fp," ADP_SetBreak "); break;
     case ADP_ClearBreak: fprintf(fp," ADP_ClearBreak "); break;
     case ADP_SetWatch: fprintf(fp," ADP_SetWatch "); break;
     case ADP_ClearWatch: fprintf(fp," ADP_ClearWatch "); break;
     case ADP_Execute: fprintf(fp," ADP_Execute "); break;
     case ADP_Step: fprintf(fp," ADP_Step "); break;
     case ADP_InterruptRequest: fprintf(fp," ADP_InterruptRequest "); break;
     case ADP_HW_Emulation: fprintf(fp," ADP_HW_Emulation "); break;
     case ADP_ICEbreakerHADP: fprintf(fp," ADP_ICEbreakerHADP "); break;
     case ADP_ICEman: fprintf(fp," ADP_ICEman "); break;
     case ADP_Profile: fprintf(fp," ADP_Profile "); break;
     case ADP_InitialiseApplication: fprintf(fp," ADP_InitialiseApplication "); break;
     case ADP_End: fprintf(fp," ADP_End "); break;
     case ADP_TADPUnrecognised: fprintf(fp," ADP_TADPUnrecognised "); break;
     case ADP_Stopped: fprintf(fp," ADP_Stopped "); break;
     case ADP_TDCC_ToHost: fprintf(fp," ADP_TDCC_ToHost "); break;
     case ADP_TDCC_FromHost: fprintf(fp," ADP_TDCC_FromHost "); break;
     default: fprintf(fp," BadReason "); break;
    }

  i = 20;
  
  if (((r & 0xffffff) == ADP_CPUread ||
       (r & 0xffffff) == ADP_CPUwrite) && (r&0x80000000)==0)
    {
      fprintf(fp,"%02x ", p->data[i]);
      ++i;
    }
  
  for (; i<p->len; i+=4)
    fprintf(fp,"%08x ",WordAt(p->data+i));
  
  fprintf(fp,"\n");
}


a311 4
    
    if (angelDebugLogEnable)
      dumpPacket(angelDebugLogFile,"rx:",&ds->ds_activeread.dc_packet);

a382 4
  
    if (angelDebugLogEnable)
      dumpPacket(angelDebugLogFile,"tx:",&dc->dc_packet);
  
@


1.1.1.3
log
@import gdb-1999-11-08 snapshot
@
text
@d11 2
a12 2
 * $Revision: 1.5 $
 *     $Date: 1999/11/02 11:28:53 $
d50 1
a50 3
    /* The following line is equivalent to: */
    /* setlinebuf (angelDebugLogFile); */
    setvbuf(angelDebugLogFile, (char *)NULL, _IOLBF, 0);
@


1.1.1.4
log
@import gdb-2000-01-05 snapshot
@
text
@d11 2
a12 2
 * $Revision: 1.7 $
 *     $Date: 2000/01/04 14:56:32 $
a19 1
#include "sys.h"
a109 1
  unsigned char channel;
a118 2
  channel = p->data[0];

d124 1
a124 1
  switch (channel)
a178 22

     case CL_Unrecognised: fprintf(fp," CL_Unrecognised "); break;
     case CL_WriteC: fprintf(fp," CL_WriteC "); break;
     case CL_Write0: fprintf(fp," CL_Write0 "); break;
     case CL_ReadC: fprintf(fp," CL_ReadC "); break;
     case CL_System: fprintf(fp," CL_System "); break;
     case CL_GetCmdLine: fprintf(fp," CL_GetCmdLine "); break;
     case CL_Clock: fprintf(fp," CL_Clock "); break;
     case CL_Time: fprintf(fp," CL_Time "); break;
     case CL_Remove: fprintf(fp," CL_Remove "); break;
     case CL_Rename: fprintf(fp," CL_Rename "); break;
     case CL_Open: fprintf(fp," CL_Open "); break;
     case CL_Close: fprintf(fp," CL_Close "); break;
     case CL_Write: fprintf(fp," CL_Write "); break;
     case CL_WriteX: fprintf(fp," CL_WriteX "); break;
     case CL_Read: fprintf(fp," CL_Read "); break;
     case CL_ReadX: fprintf(fp," CL_ReadX "); break;
     case CL_Seek: fprintf(fp," CL_Seek "); break;
     case CL_Flen: fprintf(fp," CL_Flen "); break;
     case CL_IsTTY: fprintf(fp," CL_IsTTY "); break;
     case CL_TmpNam: fprintf(fp," CL_TmpNam "); break;

d413 1
a413 1
AdpErrs DevSW_Close (DeviceDescr *device, const DevChanID type)
@


1.1.1.5
log
@import gdb-2000-01-24 snapshot
@
text
@d11 2
a12 2
 * $Revision: 1.8 $
 *     $Date: 2000/01/20 16:08:00 $
a17 1
#include <fcntl.h>
d51 3
a53 8
    {
      /* The following line is equivalent to: */
      /* setlinebuf (angelDebugLogFile); */
      setvbuf(angelDebugLogFile, (char *)NULL, _IOLBF, 0);
#if defined(__CYGWIN32__) || defined(__CYGWIN__)
      setmode(fileno(angelDebugLogFile), O_TEXT);
#endif
    }
@


