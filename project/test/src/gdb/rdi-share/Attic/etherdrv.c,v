head	1.2;
access;
symbols
	gdb-csl-sourcerygxx-3_4_4-25:1.1.1.3
	gdb_6_4-20051202-release:1.1.1.3
	msnyder-fork-checkpoint-branch:1.1.1.3.0.100
	msnyder-fork-checkpoint-branchpoint:1.1.1.3
	gdb-csl-gxxpro-6_3-branch:1.1.1.3.0.98
	gdb-csl-gxxpro-6_3-branchpoint:1.1.1.3
	gdb_6_4-branch:1.1.1.3.0.96
	gdb_6_4-2005-11-01-branchpoint:1.1.1.3
	gdb-csl-arm-20051020-branch:1.1.1.3.0.94
	gdb-csl-arm-20051020-branchpoint:1.1.1.3
	msnyder-tracepoint-checkpoint-branch:1.1.1.3.0.92
	msnyder-tracepoint-checkpoint-branchpoint:1.1.1.3
	gdb-csl-arm-20050325-2005-q1b:1.1.1.3
	gdb-csl-arm-20050325-2005-q1a:1.1.1.3
	csl-arm-20050325-branch:1.1.1.3.0.90
	csl-arm-20050325-branchpoint:1.1.1.3
	gdb-post-i18n-errorwarning-20050211:1.1.1.3
	gdb-pre-i18n-errorwarning-20050211:1.1.1.3
	gdb_6_3-20041109-release:1.1.1.3
	gdb_6_3-branch:1.1.1.3.0.86
	gdb_6_3-20041019-branchpoint:1.1.1.3
	drow_intercu-merge-20040921:1.1.1.3
	drow_intercu-merge-20040915:1.1.1.3
	jimb-gdb_6_2-e500-branch:1.1.1.3.0.88
	jimb-gdb_6_2-e500-branchpoint:1.1.1.3
	gdb_6_2-20040730-release:1.1.1.3
	gdb_6_2-branch:1.1.1.3.0.84
	gdb_6_2-2004-07-10-gmt-branchpoint:1.1.1.3
	gdb_6_1_1-20040616-release:1.1.1.3
	gdb_6_1-2004-04-05-release:1.1.1.3
	drow_intercu-merge-20040402:1.1.1.3
	drow_intercu-merge-20040327:1.1.1.3
	ezannoni_pie-20040323-branch:1.1.1.3.0.82
	ezannoni_pie-20040323-branchpoint:1.1.1.3
	cagney_tramp-20040321-mergepoint:1.1.1.3
	cagney_tramp-20040309-branch:1.1.1.3.0.80
	cagney_tramp-20040309-branchpoint:1.1.1.3
	gdb_6_1-branch:1.1.1.3.0.78
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1.1.3
	drow_intercu-20040221-branch:1.1.1.3.0.76
	drow_intercu-20040221-branchpoint:1.1.1.3
	cagney_bfdfile-20040213-branch:1.1.1.3.0.74
	cagney_bfdfile-20040213-branchpoint:1.1.1.3
	drow-cplus-merge-20040208:1.1.1.3
	carlton_dictionary-20040126-merge:1.1.1.3
	cagney_bigcore-20040122-branch:1.1.1.3.0.72
	cagney_bigcore-20040122-branchpoint:1.1.1.3
	drow-cplus-merge-20040113:1.1.1.3
	drow-cplus-merge-20031224:1.1.1.3
	drow-cplus-merge-20031220:1.1.1.3
	carlton_dictionary-20031215-merge:1.1.1.3
	drow-cplus-merge-20031214:1.1.1.3
	carlton-dictionary-20031111-merge:1.1.1.3
	gdb_6_0-2003-10-04-release:1.1.1.3
	kettenis_sparc-20030918-branch:1.1.1.3.0.70
	kettenis_sparc-20030918-branchpoint:1.1.1.3
	carlton_dictionary-20030917-merge:1.1.1.3
	ezannoni_pie-20030916-branchpoint:1.1.1.3
	ezannoni_pie-20030916-branch:1.1.1.3.0.68
	cagney_x86i386-20030821-branch:1.1.1.3.0.66
	cagney_x86i386-20030821-branchpoint:1.1.1.3
	carlton_dictionary-20030805-merge:1.1.1.3
	carlton_dictionary-20030627-merge:1.1.1.3
	gdb_6_0-branch:1.1.1.3.0.64
	gdb_6_0-2003-06-23-branchpoint:1.1.1.3
	jimb-ppc64-linux-20030613-branch:1.1.1.3.0.62
	jimb-ppc64-linux-20030613-branchpoint:1.1.1.3
	cagney_convert-20030606-branch:1.1.1.3.0.60
	cagney_convert-20030606-branchpoint:1.1.1.3
	cagney_writestrings-20030508-branch:1.1.1.3.0.58
	cagney_writestrings-20030508-branchpoint:1.1.1.3
	jimb-ppc64-linux-20030528-branch:1.1.1.3.0.56
	jimb-ppc64-linux-20030528-branchpoint:1.1.1.3
	carlton_dictionary-20030523-merge:1.1.1.3
	cagney_fileio-20030521-branch:1.1.1.3.0.54
	cagney_fileio-20030521-branchpoint:1.1.1.3
	kettenis_i386newframe-20030517-mergepoint:1.1.1.3
	jimb-ppc64-linux-20030509-branch:1.1.1.3.0.52
	jimb-ppc64-linux-20030509-branchpoint:1.1.1.3
	kettenis_i386newframe-20030504-mergepoint:1.1.1.3
	carlton_dictionary-20030430-merge:1.1.1.3
	kettenis_i386newframe-20030419-branch:1.1.1.3.0.50
	kettenis_i386newframe-20030419-branchpoint:1.1.1.3
	carlton_dictionary-20030416-merge:1.1.1.3
	cagney_frameaddr-20030409-mergepoint:1.1.1.3
	kettenis_i386newframe-20030406-branch:1.1.1.3.0.48
	kettenis_i386newframe-20030406-branchpoint:1.1.1.3
	cagney_frameaddr-20030403-branchpoint:1.1.1.3
	cagney_frameaddr-20030403-branch:1.1.1.3.0.46
	cagney_framebase-20030330-mergepoint:1.1.1.3
	cagney_framebase-20030326-branch:1.1.1.3.0.44
	cagney_framebase-20030326-branchpoint:1.1.1.3
	cagney_lazyid-20030317-branch:1.1.1.3.0.42
	cagney_lazyid-20030317-branchpoint:1.1.1.3
	kettenis-i386newframe-20030316-mergepoint:1.1.1.3
	offbyone-20030313-branch:1.1.1.3.0.40
	offbyone-20030313-branchpoint:1.1.1.3
	kettenis-i386newframe-20030308-branch:1.1.1.3.0.38
	kettenis-i386newframe-20030308-branchpoint:1.1.1.3
	carlton_dictionary-20030305-merge:1.1.1.3
	cagney_offbyone-20030303-branch:1.1.1.3.0.36
	cagney_offbyone-20030303-branchpoint:1.1.1.3
	carlton_dictionary-20030207-merge:1.1.1.3
	interps-20030203-mergepoint:1.1.1.3
	interps-20030202-branch:1.1.1.3.0.34
	interps-20030202-branchpoint:1.1.1.3
	cagney-unwind-20030108-branch:1.1.1.3.0.32
	cagney-unwind-20030108-branchpoint:1.1.1.3
	carlton_dictionary-20021223-merge:1.1.1.3
	gdb_5_3-2002-12-12-release:1.1.1.3
	carlton_dictionary-20021115-merge:1.1.1.3
	kseitz_interps-20021105-merge:1.1.1.3
	kseitz_interps-20021103-merge:1.1.1.3
	drow-cplus-merge-20021020:1.1.1.3
	drow-cplus-merge-20021025:1.1.1.3
	carlton_dictionary-20021025-merge:1.1.1.3
	carlton_dictionary-20021011-merge:1.1.1.3
	drow-cplus-branch:1.1.1.3.0.30
	drow-cplus-branchpoint:1.1.1.3
	kseitz_interps-20020930-merge:1.1.1.3
	carlton_dictionary-20020927-merge:1.1.1.3
	carlton_dictionary-branch:1.1.1.3.0.28
	carlton_dictionary-20020920-branchpoint:1.1.1.3
	gdb_5_3-branch:1.1.1.3.0.26
	gdb_5_3-2002-09-04-branchpoint:1.1.1.3
	kseitz_interps-20020829-merge:1.1.1.3
	cagney_sysregs-20020825-branch:1.1.1.3.0.24
	cagney_sysregs-20020825-branchpoint:1.1.1.3
	readline_4_3-import-branch:1.1.1.3.0.22
	readline_4_3-import-branchpoint:1.1.1.3
	gdb_5_2_1-2002-07-23-release:1.1.1.3
	kseitz_interps-20020528-branch:1.1.1.3.0.20
	kseitz_interps-20020528-branchpoint:1.1.1.3
	cagney_regbuf-20020515-branch:1.1.1.3.0.18
	cagney_regbuf-20020515-branchpoint:1.1.1.3
	jimb-macro-020506-branch:1.1.1.3.0.16
	jimb-macro-020506-branchpoint:1.1.1.3
	gdb_5_2-2002-04-29-release:1.1.1.3
	gdb_5_2-branch:1.1.1.3.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.3
	gdb_5_1_1-2002-01-24-release:1.1.1.3
	gdb_5_1_0_1-2002-01-03-release:1.1.1.3
	cygnus_cvs_20020108_pre:1.1.1.3
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.3.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.3
	gdb_5_1-2001-11-21-release:1.1.1.3
	gdb_s390-2001-09-26-branch:1.1.1.3.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.3
	gdb_5_1-2001-07-29-branch:1.1.1.3.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.3
	dberlin-typesystem-branch:1.1.1.3.0.6
	dberlin-typesystem-branchpoint:1.1.1.3
	gdb-post-ptid_t-2001-05-03:1.1.1.3
	gdb-pre-ptid_t-2001-05-03:1.1.1.3
	insight-precleanup-2001-01-01:1.1.1.3
	gdb-post-protoization-2000-07-29:1.1.1.3
	gdb-pre-protoization-2000-07-29:1.1.1.3
	gdb-premipsmulti-2000-06-06-branch:1.1.1.3.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.3
	gdb-post-params-removal-2000-06-04:1.1.1.3
	gdb-pre-params-removal-2000-06-04:1.1.1.3
	gdb-post-params-removal-2000-05-28:1.1.1.3
	gdb-pre-params-removal-2000-05-28:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2006.01.21.01.29.04;	author mmitchel;	state dead;
branches;
next	1.1;

1.1
date	99.04.16.01.34.27;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.27;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.11.02.04.44.26;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.01.06.03.06.50;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@	* Makefile.in (remote-rdi.o): Remove.
	(rdi-share/libangsd.a): Likewise.
	* README: Don't mention remote-rdi.c.
	* NEWS: Mention removal of rdi-share.
	* configure.ac: Don't configure rdi-share subdirectory.
	* remote-rdi.c: Remove.
	* config/arm/embed.mt (TDEPFILES): Remove remote-rdi.o.
	(TDEPLIBS): Remove rdi-share/libangsd.a.
	* rdi-share/Makefile.am: Remove.
	* rdi-share/Makefile.in: Likewise.
	* rdi-share/README.CYGNUS: Likewise.
	* rdi-share/aclocal.m4: Likewise.
	* rdi-share/adp.h: Likewise.
	* rdi-share/adperr.h: Likewise.
	* rdi-share/angel.h: Likewise.
	* rdi-share/angel_bytesex.c: Likewise.
	* rdi-share/angel_bytesex.h: Likewise.
	* rdi-share/angel_endian.h: Likewise.
	* rdi-share/ardi.c: Likewise.
	* rdi-share/ardi.h: Likewise.
	* rdi-share/armdbg.h: Likewise.
	* rdi-share/buffers.h: Likewise.
	* rdi-share/chandefs.h: Likewise.
	* rdi-share/channels.h: Likewise.
	* rdi-share/chanpriv.h: Likewise.
	* rdi-share/configure: Likewise.
	* rdi-share/configure.in: Likewise.
	* rdi-share/crc.c: Likewise.
	* rdi-share/crc.h: Likewise.
	* rdi-share/dbg_conf.h: Likewise.
	* rdi-share/dbg_cp.h: Likewise.
	* rdi-share/dbg_hif.h: Likewise.
	* rdi-share/dbg_rdi.h: Likewise.
	* rdi-share/devclnt.h: Likewise.
	* rdi-share/devices.h: Likewise.
	* rdi-share/devsw.c: Likewise.
	* rdi-share/devsw.h: Likewise.
	* rdi-share/drivers.c: Likewise.
	* rdi-share/drivers.h: Likewise.
	* rdi-share/etherdrv.c: Likewise.
	* rdi-share/ethernet.h: Likewise.
	* rdi-share/host.h: Likewise.
	* rdi-share/hostchan.c: Likewise.
	* rdi-share/hostchan.h: Likewise.
	* rdi-share/hsys.c: Likewise.
	* rdi-share/hsys.h: Likewise.
	* rdi-share/logging.c: Likewise.
	* rdi-share/logging.h: Likewise.
	* rdi-share/msgbuild.c: Likewise.
	* rdi-share/msgbuild.h: Likewise.
	* rdi-share/params.c: Likewise.
	* rdi-share/params.h: Likewise.
	* rdi-share/rx.c: Likewise.
	* rdi-share/rxtx.h: Likewise.
	* rdi-share/serdrv.c: Likewise.
	* rdi-share/serpardr.c: Likewise.
	* rdi-share/sys.h: Likewise.
	* rdi-share/tx.c: Likewise.
	* rdi-share/unixcomm.c: Likewise.
	* rdi-share/unixcomm.h: Likewise.
@
text
@/* 
 * Copyright (C) 1995 Advanced RISC Machines Limited. All rights reserved.
 * 
 * This software may be freely used, copied, modified, and distributed
 * provided that the above copyright notice is preserved in all copies of the
 * software.
 */

/* -*-C-*-
 *
 * $Revision: 1.6 $
 *     $Date: 1998/04/16 20:14:51 $
 *
 *
 * etherdrv.c - Ethernet Driver for Angel.
 */

#ifdef __hpux
# define _POSIX_SOURCE 1
# define _HPUX_SOURCE 1
# define _XOPEN_SOURCE 1
#endif

#include <stdio.h>
#ifdef __hpux
# define uint hide_HPs_uint
#endif
#ifdef STDC_HEADERS
# include <unistd.h>
# ifdef __hpux
#   undef uint
# endif
#endif
#include <stdlib.h>
#include <string.h>
#ifdef __hpux
# define uint hide_HPs_uint
#endif
#include <fcntl.h>
#ifdef __hpux
# undef uint
#endif
#include <errno.h>
#include <stdarg.h>
#include <ctype.h>
#include "host.h"

#ifdef COMPILING_ON_WINDOWS
  typedef char * caddr_t;
# undef IGNORE
# include <winsock.h>
# include "angeldll.h"
#else
# ifdef __hpux
#   define uint hide_HPs_uint
# endif
# include <sys/types.h>
# include <sys/socket.h>
# ifdef __hpux
#   undef uint
# endif
# include <netdb.h>
# include <sys/time.h>
# include <sys/ioctl.h>
# ifdef HAVE_SYS_FILIO_H
#   include <sys/filio.h>
# endif
# include <netinet/in.h>
# include <arpa/inet.h>
#endif

#include "hsys.h"
#include "devices.h"
#include "endian.h"
#include "buffers.h"
#include "hostchan.h"
#include "params.h"
#include "logging.h"
#include "ethernet.h"


#if !defined(COMPILING_ON_WINDOWS) && !defined(STDC_HEADERS)
/* These two might not work for windows.  */
extern int sys_nerr;
extern char * sys_errlist[];
#endif

#ifndef UNUSED
# define UNUSED(x) (x = x)      /* Silence compiler warnings */
#endif

/*
 * forward declarations of static functions
 */
static int EthernetOpen(const char *name, const char *arg);
static int EthernetMatch(const char *name, const char *arg);
static void EthernetClose(void);
static int EthernetRead(DriverCall *dc, bool block);
static int EthernetWrite(DriverCall *dc);
static int EthernetIoctl(const int opcode, void *args);

/*
 * the device descriptor for Ethernet
 */
DeviceDescr angel_EthernetDevice =
{
    "Ethernet",
    EthernetOpen,
    EthernetMatch,
    EthernetClose,
    EthernetRead,
    EthernetWrite,
    EthernetIoctl
};

/*
 * descriptor for the socket that we talk down
 */
static int sock = -1;

/*
 * address of the remote target
 */
static struct sockaddr_in remote, *ia = &remote;

/*
 * array of dynamic port numbers on target
 */
static unsigned short int ports[2];

/*
 *  Function: set_address
 *   Purpose: Try to get an address into an understandable form
 *
 *    Params:
 *       Input: addr    The address to parse
 *
 *      Output: ia      Structure to hold the parsed address
 *
 *   Returns:
 *          OK:  0
 *       Error: -1
 */
static int set_address(const char *const addr, struct sockaddr_in *const ia)
{
    ia->sin_family = AF_INET;

    /*
     * Try address as a dotted decimal
     */
    ia->sin_addr.s_addr = inet_addr(addr);

    /*
     * If that failed, try it as a hostname
     */
    if (ia->sin_addr.s_addr == (u_int)-1)
    {
        struct hostent *hp = gethostbyname(addr);

        if (hp == NULL)
            return -1;

        (void)memcpy((caddr_t)&ia->sin_addr, hp->h_addr, hp->h_length);
    }

    return 0;
}

/*
 *  Function: open_socket
 *   Purpose: Open a non-blocking UDP socket, and bind it to a port
 *              assigned by the system.
 *
 *    Params: None
 *
 *   Returns:
 *          OK: socket descriptor
 *       Error: -1
 */
static int open_socket(void)
{
    int sfd;
#if 0                           /* see #if 0 just below -VVV- */
    int yesplease = 1;
#endif
    struct sockaddr_in local;

    /*
     * open the socket
     */
#ifdef COMPILING_ON_WINDOWS
    if ((sfd = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
        return -1;
#else
    if ((sfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
# ifdef DEBUG
        perror("socket");
# endif
        return -1;
    }
#endif

    /*
     * 960731 KWelton
     *
     * I don't believe that this should be necessary - if we
     * use select(), then non-blocking I/O is redundant.
     * Unfortunately, select() appears to be broken (under
     * Solaris, with a limited amount of time available for
     * debug), so this code stays in for the time being
     */
#if 0
    /*
     * enable non-blocking I/O
     */
    if (ioctlsocket(sfd, FIONBIO, &yesplease) < 0)
    {
# ifdef DEBUG
        perror("ioctl(FIONBIO)");
# endif
        closesocket(sfd);

        return -1;
    }
#endif /* 0/1 */

    /*
     * bind local address to a system-assigned port
     */
    memset((char *)&local, 0, sizeof(local));
    local.sin_family = AF_INET;
    local.sin_port = htons(0);
    local.sin_addr.s_addr = INADDR_ANY;
    if (bind(sfd, (struct sockaddr *)&local, sizeof(local)) < 0)
    {
#ifdef DEBUG
        perror("bind");
#endif
        closesocket(sfd);

        return -1;
    }

    /*
     * all done
     */
    return sfd;
}

/*
 *  Function: fetch_ports
 *   Purpose: Request assigned port numbers from remote target
 *
 *    Params: None
 *
 *   Returns: Nothing
 *
 * Post-conditions: This routine will *always* return something for the
 *                      port numbers.  If the remote target does not
 *                      respond, then it makes something up - this allows
 *                      the standard error message (from ardi.c) to be
 *                      generated when the target is dead for whatever
 *                      reason.
 */
static void fetch_ports(void)
{
    int i;
    const char ctrlpacket[] = CTRL_MAGIC;
        CtrlResponse response;

    /*
     * we will try 3 times to elicit a response from the target
     */
    for (i = 0; i < 3; ++i)
    {
        struct timeval tv;
        fd_set fdset;

        /*
         * send the magic string to the control
         * port on the remote target
         */
        ia->sin_port = htons(CTRL_PORT);
        if (sendto(sock, ctrlpacket, sizeof(ctrlpacket), 0,
                       (struct sockaddr *)ia, sizeof(*ia)) < 0)
        {
#ifdef DEBUG
            perror("fetch_ports: sendto");
#endif
            return;
        }

        FD_ZERO(&fdset);
        FD_SET(sock, &fdset);
        tv.tv_sec = 0;
        tv.tv_usec = 250000;

        if (select(sock + 1, &fdset, NULL, NULL, &tv) < 0)
        {
#ifdef DEBUG
            perror("fetch_ports: select");
#endif
            return;
        }

        if (FD_ISSET(sock, &fdset))
        {
            /*
             * there is something there - read it
             */
            if (recv(sock, (char *)&response, sizeof(response), 0) < 0)
            {
#ifdef COMPILING_ON_WINDOWS
                unsigned int werrno = WSAGetLastError();

                if (werrno == WSAEWOULDBLOCK || werrno == 0)
#else
                if (errno == EWOULDBLOCK)
#endif
                {
                    --i;
                    continue;
                }
                else
                {
#ifdef DEBUG
                    perror("fetch_ports: recv");
#endif
                    return;
                }
            }
            {
                /*
                 * XXX
                 *
                 * this is *very* unpleasant - try to match the structure
                 * layout
                 */
                unsigned short *sptr = (unsigned short *)(response + RESP_DBUG);

                if (strcmp(response, ctrlpacket) == 0)
                {
                    ports[DBUG_INDEX] = htons(*sptr);
                    sptr++;
                    ports[APPL_INDEX] = htons(*sptr);
                }

#ifdef DEBUG
                printf("fetch_ports: got response, DBUG=%d, APPL=%d\n",
                       ports[DBUG_INDEX], ports[APPL_INDEX]);
#endif
                return;
            }
        }
    }

    /*
     * we failed to get a response
     */
#ifdef DEBUG
    printf("fetch_ports: failed to get a real answer\n");
#endif
}

/*
 *  Function: read_packet
 *   Purpose: read a packet, and pass it back to higher levels
 *
 *    Params:
 *      In/Out: packet  Holder for the read packet
 *
 *   Returns:  1 - Packet is complete
 *             0 - No complete packet read
 *
 * Post-conditions: Will call panic() if something goes wrong with the OS
 */
static int read_packet(struct data_packet *const packet)
{
    struct sockaddr_in from;
    int nbytes, fromlen = sizeof(from);
    DevChanID devchan;

    /*
     * try to get the packet
     */
    if ((nbytes = recvfrom(sock, (char *)(packet->data), packet->buf_len, 0,
                           (struct sockaddr *)&from, &fromlen)) < 0)
    {
#ifdef COMPILING_ON_WINDOWS
        if (nbytes == SOCKET_ERROR && WSAGetLastError() != WSAEWOULDBLOCK)
            MessageBox(GetFocus(), "Error receiving packet\n", "Angel", MB_OK | MB_ICONSTOP);
#else
        if (errno != EWOULDBLOCK)
        {
# ifdef DEBUG
            perror("recv");
# endif
            panic("ethernet recv failure");
        }
#endif
        return 0;
    }

#ifdef COMPILING_ON_WINDOWS
    if (pfnProgressCallback != NULL && nbytes != SOCKET_ERROR)
    {
        progressInfo.nRead += nbytes;
        (*pfnProgressCallback)(&progressInfo);
    }
#endif

    /*
     * work out where the packet was from
     */
    if (from.sin_addr.s_addr != remote.sin_addr.s_addr)
    {
        /*
         * not from our target - ignore it
         */
#ifdef DEBUG
        printf("read_packet: ignoring packet from %s\n",
               inet_ntoa(from.sin_addr));
#endif

        return 0;
    }
    else if (ntohs(from.sin_port) == ports[DBUG_INDEX])
        devchan = DC_DBUG;
    else if (ntohs(from.sin_port) == ports[APPL_INDEX])
        devchan = DC_APPL;
    else
    {
        /*
         * unknown port number - ignore it
         */
#ifdef DEBUG
        printf("read_packet: ignore packet from port %hd\n",
               htons(from.sin_port));
#endif

        return 0;
    }

#if defined(DEBUG) && !defined(DO_TRACE)
    printf("EthernetRead: %d bytes from %s channel\n",
           nbytes, (devchan == DC_DBUG) ? "DBUG" : "APPL");
#endif

#ifdef DO_TRACE
    printf("[%d on %d]\n", nbytes, devchan);
    {
        int i = 0;
        unsigned char *cptr = packet->data;

        while (i < nbytes)
        {
            printf("<%02X ", *(cptr++));

            if (!(++i % 16))
                printf("\n");
        }

        if (i % 16)
            printf("\n");
    }
#endif

    /*
     * OK - fill in the details
     */
    packet->type = devchan;
    packet->len = nbytes;
    return 1;
}

/**********************************************************************/

/*
 *  Function: Ethernet_Open
 *   Purpose: Open the Ethernet device.  See the documentation for
 *              DeviceOpen in drivers.h
 *
 * Post-conditions: Will have updated struct sockaddr_in remote (*ia)
 *                      with the address of the remote target.
 */
static int EthernetOpen(const char *name, const char *arg)
{
#ifdef COMPILING_ON_WINDOWS
    WORD wVersionRequested;
    WSADATA wsaData;
#endif
    /*
     * name is passed as e=<blah>, so skip 1st two characters
     */
    const char *etheraddr = name + 2;

#ifdef DEBUG
    printf("EthernetOpen: name `%s'\n", name);
#endif

    /* Check that the name is a valid one */
    if (EthernetMatch(name, arg) != 0)
        return -1;

#ifdef COMPILING_ON_WINDOWS
    wVersionRequested = MAKEWORD(1, 1);
    if (WSAStartup(wVersionRequested, &wsaData) != 0)
        /*
         * Couldn't find a useable winsock.dll.
         */
        return -1;

    if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 )
    {
        WSACleanup();

        /*
         * Couldn't find a winsock.dll with supported version.
         */
        return -1;
    }
#endif

    memset((char *)ia, 0, sizeof(*ia));
    if (set_address(etheraddr, ia) < 0)
    {
#ifdef COMPILING_ON_WINDOWS
        /*
         * SJ - I'm not sure that this is the correct way to handle this
         * as Fail calls remote_disable and exits, while panic just exits.
         * However at the time of writing remote_disable does nothing!
         */
 /*     Panic("EthernetOpen: bad name `%s'\n", etheraddr); */
#else
        Fail("EthernetOpen: bad name `%s'\n", etheraddr);
#endif
        return -1;
    }

    if ((sock = open_socket()) < 0)
        return -1;

    /*
     * fetch the port numbers assigned by the remote target
     * to its Debug and Application sockets
     */
    fetch_ports();

    return 0;
}

static int EthernetMatch(const char *name, const char *arg)
{
    /* IGNORE arg */
    if (0)
        arg = arg;

    if (name == NULL)
        return -1;

    if (tolower(name[0]) != 'e' || name[1] != '=')
        return -1;

    return 0;
}

static void EthernetClose(void)
{
    if (sock >= 0)
    {
        closesocket(sock);
        sock = -1;
    }

#ifdef COMPILING_ON_WINDOWS
    WSACleanup();
#endif
}

static int EthernetRead(DriverCall *dc, bool block)
{
    fd_set fdset;
    struct timeval tv;
    int err;

    FD_ZERO(&fdset);
    FD_SET(sock, &fdset);

#ifdef COMPILING_ON_WINDOWS
    UNUSED(block);
    tv.tv_sec = tv.tv_usec = 0;
#else
    tv.tv_sec = 0;
    tv.tv_usec = (block ? 10000 : 0);
#endif

    err = select(sock + 1, &fdset, NULL, NULL, &tv);

    if (err < 0) {
      if (errno == EINTR) {
        return 0;
      }
      panic("ethernet select failure (errno=%i)",errno);
      return 0;
    }

    if (FD_ISSET(sock, &fdset))
      return read_packet(&dc->dc_packet);
    else
      return 0;
}

static int EthernetWrite(DriverCall *dc)
{
    int nbytes;
    struct data_packet *packet = &dc->dc_packet;

    if (packet->type == DC_DBUG)
        ia->sin_port = htons(ports[DBUG_INDEX]);
    else if (packet->type == DC_APPL)
        ia->sin_port = htons(ports[APPL_INDEX]);
    else
    {
        panic("EthernetWrite: unknown devchan");
        return 0;
    }

#if defined(DEBUG) && !defined(DO_TRACE)
    printf("EthernetWrite: %d bytes to %s channel\n",
           packet->len, (packet->type == DC_DBUG) ? "DBUG" : "APPL");
#endif

#ifdef DO_TRACE
    printf("[%d on %d]\n", packet->len, packet->type);
    {
        int i = 0;
        unsigned char *cptr = packet->data;

        while (i < packet->len)
        {
            printf(">%02X ", *(cptr++));

            if (!(++i % 16))
                printf("\n");
        }

        if (i % 16)
            printf("\n");
    }
#endif

    if ((nbytes = sendto(sock, (char *)(packet->data), packet->len, 0,
                         (struct sockaddr *)ia, sizeof(*ia))) != packet->len)
    {
#ifdef COMPILING_ON_WINDOWS
        if (nbytes == SOCKET_ERROR && WSAGetLastError() != WSAEWOULDBLOCK)
#else
        if (nbytes < 0 && errno != EWOULDBLOCK)
#endif
        {
#ifdef DEBUG
            perror("sendto");
#endif

#ifdef COMPILING_ON_WINDOWS
            panic("ethernet send failure\n");
#else
            /* might not work for Windows */
            panic("ethernet send failure [%s]\n",
#ifdef STDC_HEADERS
		  strerror(errno));
#else
                  errno < sys_nerr ? sys_errlist[errno] : "unknown errno");
#endif /* STDC_HEADERS */
#endif
        }
#ifdef DEBUG
        else if (nbytes >= 0)
            fprintf(stderr, "ethernet send: asked for %d, sent %d\n", packet->len, nbytes);
#endif
        return 0;
    }

#ifdef COMPILING_ON_WINDOWS
    if (pfnProgressCallback != NULL && nbytes != SOCKET_ERROR)
    {
        progressInfo.nWritten += nbytes;
        (*pfnProgressCallback)(&progressInfo);
    }
#endif

    return 1;
}

static int EthernetIoctl(const int opcode, void *args)
{
#ifdef DEBUG
    printf( "EthernetIoctl: op %d arg %x\n", opcode, args );
#endif

    /*
     * IGNORE(opcode)
     */
    if (0)
    {
        int dummy = opcode;
        UNUSED(dummy);
    }
    UNUSED(args);

    switch ( opcode )
    {
        case DC_RESYNC:
        {
#ifdef DEBUG
            printf( "EthernetIoctl: resync\n" );
#endif
            fetch_ports();
            return 0;
        }

        default:
        {
            return -1;
        }
    }
}

/* EOF etherdrv.c */
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-11-01 snapshot
@
text
@d11 2
a12 2
 * $Revision: 1.8 $
 *     $Date: 1999/11/01 15:32:58 $
d74 1
a74 1
#include "angel_endian.h"
a284 4
#ifdef DEBUG
	printf("CTLR_PORT=0x%04x  sin_port=0x%04x\n");
#endif

@


1.1.1.3
log
@import gdb-2000-01-05 snapshot
@
text
@d11 2
a12 2
 * $Revision: 1.9 $
 *     $Date: 2000/01/04 15:24:18 $
d269 2
a270 2
    char ctrlpacket[10];
    CtrlResponse response;
a271 3
    memset (ctrlpacket, 0, 10);
    strcpy (ctrlpacket, CTRL_MAGIC);
    memset (response, 0, sizeof(CtrlResponse));
@


