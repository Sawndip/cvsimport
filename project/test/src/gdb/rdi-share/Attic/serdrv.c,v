head	1.3;
access;
symbols
	gdb-csl-sourcerygxx-3_4_4-25:1.2
	gdb_6_4-20051202-release:1.2
	msnyder-fork-checkpoint-branch:1.2.0.80
	msnyder-fork-checkpoint-branchpoint:1.2
	gdb-csl-gxxpro-6_3-branch:1.2.0.78
	gdb-csl-gxxpro-6_3-branchpoint:1.2
	gdb_6_4-branch:1.2.0.76
	gdb_6_4-2005-11-01-branchpoint:1.2
	gdb-csl-arm-20051020-branch:1.2.0.74
	gdb-csl-arm-20051020-branchpoint:1.2
	msnyder-tracepoint-checkpoint-branch:1.2.0.72
	msnyder-tracepoint-checkpoint-branchpoint:1.2
	gdb-csl-arm-20050325-2005-q1b:1.2
	gdb-csl-arm-20050325-2005-q1a:1.2
	csl-arm-20050325-branch:1.2.0.70
	csl-arm-20050325-branchpoint:1.2
	gdb-post-i18n-errorwarning-20050211:1.2
	gdb-pre-i18n-errorwarning-20050211:1.2
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.66
	gdb_6_3-20041019-branchpoint:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.68
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.64
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.62
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.60
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.58
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.56
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.54
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.52
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.50
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.48
	cagney_x86i386-20030821-branch:1.2.0.46
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.44
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.40
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.38
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.34
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.30
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.28
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.26
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.24
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.22
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.20
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.18
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.16
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030203-mergepoint:1.2
	interps-20030202-branch:1.2.0.14
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.12
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.10
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.8
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.6
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.4
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.2
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.3
	kseitz_interps-20020528-branch:1.1.1.3.0.20
	kseitz_interps-20020528-branchpoint:1.1.1.3
	cagney_regbuf-20020515-branch:1.1.1.3.0.18
	cagney_regbuf-20020515-branchpoint:1.1.1.3
	jimb-macro-020506-branch:1.1.1.3.0.16
	jimb-macro-020506-branchpoint:1.1.1.3
	gdb_5_2-2002-04-29-release:1.1.1.3
	gdb_5_2-branch:1.1.1.3.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.3
	gdb_5_1_1-2002-01-24-release:1.1.1.3
	gdb_5_1_0_1-2002-01-03-release:1.1.1.3
	cygnus_cvs_20020108_pre:1.1.1.3
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.3.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.3
	gdb_5_1-2001-11-21-release:1.1.1.3
	gdb_s390-2001-09-26-branch:1.1.1.3.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.3
	gdb_5_1-2001-07-29-branch:1.1.1.3.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.3
	dberlin-typesystem-branch:1.1.1.3.0.6
	dberlin-typesystem-branchpoint:1.1.1.3
	gdb-post-ptid_t-2001-05-03:1.1.1.3
	gdb-pre-ptid_t-2001-05-03:1.1.1.3
	insight-precleanup-2001-01-01:1.1.1.3
	gdb-post-protoization-2000-07-29:1.1.1.3
	gdb-pre-protoization-2000-07-29:1.1.1.3
	gdb-premipsmulti-2000-06-06-branch:1.1.1.3.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.3
	gdb-post-params-removal-2000-06-04:1.1.1.3
	gdb-pre-params-removal-2000-06-04:1.1.1.3
	gdb-post-params-removal-2000-05-28:1.1.1.3
	gdb-pre-params-removal-2000-05-28:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2006.01.21.01.29.04;	author mmitchel;	state dead;
branches;
next	1.2;

1.2
date	2002.06.08.20.34.41;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.28;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.28;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.01.11.03.07.32;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.01.18.00.54.36;	author jsm;	state Exp;
branches
	1.1.1.3.18.1
	1.1.1.3.20.1;
next	;

1.1.1.3.18.1
date	2002.06.15.16.43.14;	author cagney;	state Exp;
branches;
next	;

1.1.1.3.20.1
date	2002.06.20.01.36.29;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.3
log
@	* Makefile.in (remote-rdi.o): Remove.
	(rdi-share/libangsd.a): Likewise.
	* README: Don't mention remote-rdi.c.
	* NEWS: Mention removal of rdi-share.
	* configure.ac: Don't configure rdi-share subdirectory.
	* remote-rdi.c: Remove.
	* config/arm/embed.mt (TDEPFILES): Remove remote-rdi.o.
	(TDEPLIBS): Remove rdi-share/libangsd.a.
	* rdi-share/Makefile.am: Remove.
	* rdi-share/Makefile.in: Likewise.
	* rdi-share/README.CYGNUS: Likewise.
	* rdi-share/aclocal.m4: Likewise.
	* rdi-share/adp.h: Likewise.
	* rdi-share/adperr.h: Likewise.
	* rdi-share/angel.h: Likewise.
	* rdi-share/angel_bytesex.c: Likewise.
	* rdi-share/angel_bytesex.h: Likewise.
	* rdi-share/angel_endian.h: Likewise.
	* rdi-share/ardi.c: Likewise.
	* rdi-share/ardi.h: Likewise.
	* rdi-share/armdbg.h: Likewise.
	* rdi-share/buffers.h: Likewise.
	* rdi-share/chandefs.h: Likewise.
	* rdi-share/channels.h: Likewise.
	* rdi-share/chanpriv.h: Likewise.
	* rdi-share/configure: Likewise.
	* rdi-share/configure.in: Likewise.
	* rdi-share/crc.c: Likewise.
	* rdi-share/crc.h: Likewise.
	* rdi-share/dbg_conf.h: Likewise.
	* rdi-share/dbg_cp.h: Likewise.
	* rdi-share/dbg_hif.h: Likewise.
	* rdi-share/dbg_rdi.h: Likewise.
	* rdi-share/devclnt.h: Likewise.
	* rdi-share/devices.h: Likewise.
	* rdi-share/devsw.c: Likewise.
	* rdi-share/devsw.h: Likewise.
	* rdi-share/drivers.c: Likewise.
	* rdi-share/drivers.h: Likewise.
	* rdi-share/etherdrv.c: Likewise.
	* rdi-share/ethernet.h: Likewise.
	* rdi-share/host.h: Likewise.
	* rdi-share/hostchan.c: Likewise.
	* rdi-share/hostchan.h: Likewise.
	* rdi-share/hsys.c: Likewise.
	* rdi-share/hsys.h: Likewise.
	* rdi-share/logging.c: Likewise.
	* rdi-share/logging.h: Likewise.
	* rdi-share/msgbuild.c: Likewise.
	* rdi-share/msgbuild.h: Likewise.
	* rdi-share/params.c: Likewise.
	* rdi-share/params.h: Likewise.
	* rdi-share/rx.c: Likewise.
	* rdi-share/rxtx.h: Likewise.
	* rdi-share/serdrv.c: Likewise.
	* rdi-share/serpardr.c: Likewise.
	* rdi-share/sys.h: Likewise.
	* rdi-share/tx.c: Likewise.
	* rdi-share/unixcomm.c: Likewise.
	* rdi-share/unixcomm.h: Likewise.
@
text
@/* 
 * Copyright (C) 1995 Advanced RISC Machines Limited. All rights reserved.
 * 
 * This software may be freely used, copied, modified, and distributed
 * provided that the above copyright notice is preserved in all copies of the
 * software.
 */

/* -*-C-*-
 *
 * $Revision: 1.7 $
 *     $Date: 2000/01/12 12:53:29 $
 *
 *
 * serdrv.c - Synchronous Serial Driver for Angel.
 *            This is nice and simple just to get something going.
 */

#ifdef __hpux
#  define _POSIX_SOURCE 1
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "crc.h"
#include "devices.h"
#include "buffers.h"
#include "rxtx.h"
#include "hostchan.h"
#include "params.h"
#include "logging.h"

extern int baud_rate;   /* From gdb/top.c */

#ifdef COMPILING_ON_WINDOWS
#  undef   ERROR
#  undef   IGNORE
#  include <windows.h>
#  include "angeldll.h"
#  include "comb_api.h"
#else
#  ifdef __hpux
#    define _TERMIOS_INCLUDED
#    include <sys/termio.h>
#    undef _TERMIOS_INCLUDED
#  else
#    include <termios.h>
#  endif
#  include "unixcomm.h"
#endif

#ifndef UNUSED
#  define UNUSED(x) (x = x)      /* Silence compiler warnings */
#endif
 
#define MAXREADSIZE 512
#define MAXWRITESIZE 512

#define SERIAL_FC_SET  ((1<<serial_XON)|(1<<serial_XOFF))
#define SERIAL_CTL_SET ((1<<serial_STX)|(1<<serial_ETX)|(1<<serial_ESC))
#define SERIAL_ESC_SET (SERIAL_FC_SET|SERIAL_CTL_SET)

static const struct re_config config = {
    serial_STX, serial_ETX, serial_ESC, /* self-explanatory?               */
    SERIAL_FC_SET,                      /* set of flow-control characters  */
    SERIAL_ESC_SET,                     /* set of characters to be escaped */
    NULL /* serial_flow_control */, NULL  ,    /* what to do with FC chars */
    angel_DD_RxEng_BufferAlloc, NULL                /* how to get a buffer */
};

static struct re_state rxstate;

typedef struct writestate {
  unsigned int wbindex;
  /*  static te_status testatus;*/
  unsigned char writebuf[MAXWRITESIZE];
  struct te_state txstate;
} writestate;

static struct writestate wstate;

/*
 * The set of parameter options supported by the device
 */
static unsigned int baud_options[] = {
#if defined(B115200) || defined(__hpux)
    115200,
#endif
#if defined(B57600) || defined(__hpux)
    57600, 
#endif
    38400, 19200, 9600
};

static ParameterList param_list[] = {
    { AP_BAUD_RATE,
      sizeof(baud_options)/sizeof(unsigned int),
      baud_options }
};

static const ParameterOptions serial_options = {
    sizeof(param_list)/sizeof(ParameterList), param_list };

/* 
 * The default parameter config for the device
 */
static Parameter param_default[] = {
    { AP_BAUD_RATE, 9600 }
};

static ParameterConfig serial_defaults = {
    sizeof(param_default)/sizeof(Parameter), param_default };

/*
 * The user-modified options for the device
 */
static unsigned int user_baud_options[sizeof(baud_options)/sizeof(unsigned)];

static ParameterList param_user_list[] = {
    { AP_BAUD_RATE,
      sizeof(user_baud_options)/sizeof(unsigned),
      user_baud_options }
};

static ParameterOptions user_options = {
    sizeof(param_user_list)/sizeof(ParameterList), param_user_list };

static bool user_options_set;

/* forward declarations */
static int serial_reset( void );
static int serial_set_params( const ParameterConfig *config );
static int SerialMatch(const char *name, const char *arg);

static void process_baud_rate( unsigned int target_baud_rate )
{
    const ParameterList *full_list;
    ParameterList       *user_list;

    /* create subset of full options */
    full_list = Angel_FindParamList( &serial_options, AP_BAUD_RATE );
    user_list = Angel_FindParamList( &user_options,   AP_BAUD_RATE );

    if ( full_list != NULL && user_list != NULL )
    {
        unsigned int i, j;
        unsigned int def_baud = 0;

        /* find lower or equal to */
        for ( i = 0; i < full_list->num_options; ++i )
           if ( target_baud_rate >= full_list->option[i] )
           {
               /* copy remaining */
               for ( j = 0; j < (full_list->num_options - i); ++j )
                  user_list->option[j] = full_list->option[i+j];
               user_list->num_options = j;

               /* check this is not the default */
               Angel_FindParam( AP_BAUD_RATE, &serial_defaults, &def_baud );
               if ( (j == 1) && (user_list->option[0] == def_baud) )
               {
#ifdef DEBUG
                   printf( "user selected default\n" );
#endif
               }
               else
               {
                   user_options_set = TRUE;
#ifdef DEBUG
                   printf( "user options are: " );
                   for ( j = 0; j < user_list->num_options; ++j )
                      printf( "%u ", user_list->option[j] );
                   printf( "\n" );
#endif
               }

               break;   /* out of i loop */
           }
                
#ifdef DEBUG
        if ( i >= full_list->num_options )
           printf( "couldn't match baud rate %u\n", target_baud_rate );
#endif
    }
#ifdef DEBUG
    else
       printf( "failed to find lists\n" );
#endif
}

static int SerialOpen(const char *name, const char *arg)
{
    const char *port_name = name;

#ifdef DEBUG
    printf("SerialOpen: name %s arg %s\n", name, arg ? arg : "<NULL>");
#endif

#ifdef COMPILING_ON_WINDOWS
    if (IsOpenSerial()) return -1;
#else
    if (Unix_IsSerialInUse()) return -1;
#endif

#ifdef COMPILING_ON_WINDOWS
    if (SerialMatch(name, arg) != adp_ok)
        return adp_failed;
#else
    port_name = Unix_MatchValidSerialDevice(port_name);
# ifdef DEBUG
    printf("translated port to %s\n", port_name == 0 ? "NULL" : port_name);
# endif
    if (port_name == 0) return adp_failed;
#endif

    user_options_set = FALSE;

    /* interpret and store the arguments */
    if ( arg != NULL )
    {
        unsigned int target_baud_rate;
        target_baud_rate = (unsigned int)strtoul(arg, NULL, 10);
        if (target_baud_rate > 0)
        {
#ifdef DEBUG
            printf( "user selected baud rate %u\n", target_baud_rate );
#endif
            process_baud_rate( target_baud_rate );
        }
#ifdef DEBUG
        else
           printf( "could not understand baud rate %s\n", arg );
#endif
    }
    else if (baud_rate > 0)
    {
      /* If the user specified a baud rate on the command line "-b" or via
         the "set remotebaud" command then try to use that one */
      process_baud_rate( baud_rate );
    }

#ifdef COMPILING_ON_WINDOWS
    {
        int port = IsValidDevice(name);
        if (OpenSerial(port, FALSE) != COM_OK)
            return -1;
    }
#else
    if (Unix_OpenSerial(port_name) < 0)
      return -1;
#endif

    serial_reset();

#if defined(__unix) || defined(__CYGWIN__)
    Unix_ioctlNonBlocking();
#endif

    Angel_RxEngineInit(&config, &rxstate);
    /*
     * DANGER!: passing in NULL as the packet is ok for now as it is just
     * IGNOREd but this may well change
     */
    Angel_TxEngineInit(&config, NULL, &wstate.txstate); 
    return 0;
}

static int SerialMatch(const char *name, const char *arg)
{
    UNUSED(arg);
#ifdef COMPILING_ON_WINDOWS
    if (IsValidDevice(name) == COM_DEVICENOTVALID)
        return -1;
    else
        return 0;
#else
    return Unix_MatchValidSerialDevice(name) == 0 ? -1 : 0;
#endif
}

static void SerialClose(void)
{
#ifdef DO_TRACE
    printf("SerialClose()\n");
#endif

#ifdef COMPILING_ON_WINDOWS
    CloseSerial();
#else
    Unix_CloseSerial();
#endif
}

static int SerialRead(DriverCall *dc, bool block) {
  static unsigned char readbuf[MAXREADSIZE];
  static int rbindex=0;

  int nread;
  int read_errno;
  int c=0;
  re_status restatus;
  int ret_code = -1;            /* assume bad packet or error */

  /* must not overflow buffer and must start after the existing data */
#ifdef COMPILING_ON_WINDOWS
  {
    BOOL dummy = FALSE;
    nread = BytesInRXBufferSerial();

    if (nread > MAXREADSIZE - rbindex)
      nread = MAXREADSIZE - rbindex;

    if ((read_errno = ReadSerial(readbuf+rbindex, nread, &dummy)) == COM_READFAIL)
    {
        MessageBox(GetFocus(), "Read error\n", "Angel", MB_OK | MB_ICONSTOP);
        return -1;   /* SJ - This really needs to return a value, which is picked up in */
                     /*      DevSW_Read as meaning stop debugger but don't kill. */
    }
    else if (pfnProgressCallback != NULL && read_errno == COM_OK)
    {
      progressInfo.nRead += nread;
      (*pfnProgressCallback)(&progressInfo);
    }
  }
#else
  nread = Unix_ReadSerial(readbuf+rbindex, MAXREADSIZE-rbindex, block);
  read_errno = errno;
#endif

  if ((nread > 0) || (rbindex > 0)) {

#ifdef DO_TRACE
    printf("[%d@@%d] ", nread, rbindex);
#endif

    if (nread>0)
       rbindex = rbindex+nread;

    do {
      restatus = Angel_RxEngine(readbuf[c], &(dc->dc_packet), &rxstate);
#ifdef DO_TRACE
      printf("<%02X ",readbuf[c]);
      if (!(++c % 16))
          printf("\n");
#else
      c++;
#endif
    } while (c<rbindex &&
             ((restatus == RS_IN_PKT) || (restatus == RS_WAIT_PKT)));

#ifdef DO_TRACE
   if (c % 16)
        printf("\n");
#endif

    switch(restatus) {
      
      case RS_GOOD_PKT:
        ret_code = 1;
        /* fall through to: */

      case RS_BAD_PKT:
        /*
         * We now need to shuffle any left over data down to the
         * beginning of our private buffer ready to be used 
         *for the next packet 
         */
#ifdef DO_TRACE
        printf("SerialRead() processed %d, moving down %d\n", c, rbindex-c);
#endif
        if (c != rbindex) memmove((char *) readbuf, (char *) (readbuf+c),
                                  rbindex-c);
        rbindex -= c;
        break;

      case RS_IN_PKT:
      case RS_WAIT_PKT:
        rbindex = 0;            /* will have processed all we had */
        ret_code = 0;
        break;

      default:
#ifdef DEBUG
        printf("Bad re_status in serialRead()\n");
#endif
        break;
    }
  } else if (nread == 0)
    ret_code = 0;               /* nothing to read */
  else if (read_errno == ERRNO_FOR_BLOCKED_IO) /* nread < 0 */
    ret_code = 0;

#ifdef DEBUG
  if ((nread<0) && (read_errno!=ERRNO_FOR_BLOCKED_IO))
    perror("read() error in serialRead()");
#endif

  return ret_code;
}


static int SerialWrite(DriverCall *dc) {
  int nwritten = 0;
  te_status testatus = TS_IN_PKT;

  if (dc->dc_context == NULL) {
    Angel_TxEngineInit(&config, &(dc->dc_packet), &(wstate.txstate));
    wstate.wbindex = 0;
    dc->dc_context = &wstate;
  }

  while ((testatus == TS_IN_PKT) && (wstate.wbindex < MAXWRITESIZE))
  {
    /* send the raw data through the tx engine to escape and encapsulate */
    testatus = Angel_TxEngine(&(dc->dc_packet), &(wstate.txstate),
                              &(wstate.writebuf)[wstate.wbindex]);
    if (testatus != TS_IDLE) wstate.wbindex++;
  }

  if (testatus == TS_IDLE) {
#ifdef DEBUG
    printf("SerialWrite: testatus is TS_IDLE during preprocessing\n");
#endif
  }

#ifdef DO_TRACE
  { 
    int i = 0;

    while (i<wstate.wbindex)
    {
        printf(">%02X ",wstate.writebuf[i]);

        if (!(++i % 16))
            printf("\n");
    }
    if (i % 16)
        printf("\n");
  }
#endif

#ifdef COMPILING_ON_WINDOWS
  if (WriteSerial(wstate.writebuf, wstate.wbindex) == COM_OK)
  {
    nwritten = wstate.wbindex;
    if (pfnProgressCallback != NULL)
    {
      progressInfo.nWritten += nwritten;
      (*pfnProgressCallback)(&progressInfo);
    }
  }
  else
  {
      MessageBox(GetFocus(), "Write error\n", "Angel", MB_OK | MB_ICONSTOP);
      return -1;   /* SJ - This really needs to return a value, which is picked up in */
                   /*      DevSW_Read as meaning stop debugger but don't kill. */
  }
#else
  nwritten = Unix_WriteSerial(wstate.writebuf, wstate.wbindex);

  if (nwritten < 0) {
    nwritten=0;
  }
#endif

#ifdef DEBUG
  if (nwritten > 0)
    printf("Wrote %#04x bytes\n", nwritten);
#endif

  if ((unsigned) nwritten == wstate.wbindex && 
      (testatus == TS_DONE_PKT || testatus == TS_IDLE)) {

    /* finished sending the packet */

#ifdef DEBUG
    printf("SerialWrite: calling Angel_TxEngineInit after sending packet (len=%i)\n",wstate.wbindex);
#endif
    testatus = TS_IN_PKT;
    wstate.wbindex = 0;
    return 1;
  }
  else {
#ifdef DEBUG
    printf("SerialWrite: Wrote part of packet wbindex=%i, nwritten=%i\n",
           wstate.wbindex, nwritten);
#endif
   
    /*
     *  still some data left to send shuffle whats left down and reset
     * the ptr
     */
    memmove((char *) wstate.writebuf, (char *) (wstate.writebuf+nwritten),
            wstate.wbindex-nwritten);
    wstate.wbindex -= nwritten;
    return 0;
  }
  return -1;
}


static int serial_reset( void )
{
#ifdef DEBUG
    printf( "serial_reset\n" );
#endif

#ifdef COMPILING_ON_WINDOWS
    FlushSerial();
#else
    Unix_ResetSerial();
#endif

    return serial_set_params( &serial_defaults );
}


static int find_baud_rate( unsigned int *speed )
{
    static struct {
          unsigned int baud;
          int termiosValue;
    } possibleBaudRates[] = {
#if defined(__hpux)
        {115200,_B115200}, {57600,_B57600},
#else
#ifdef B115200
        {115200,B115200},
#endif
#ifdef B57600
	{57600,B57600},
#endif
#endif
#ifdef COMPILING_ON_WINDOWS
        {38400,CBR_38400}, {19200,CBR_19200}, {9600, CBR_9600}, {0,0}
#else
        {38400,B38400}, {19200,B19200}, {9600, B9600}, {0,0}
#endif
    };
    unsigned int i;

    /* look for lower or matching -- will always terminate at 0 end marker */
    for ( i = 0; possibleBaudRates[i].baud > *speed; ++i )
       /* do nothing */ ;

    if ( possibleBaudRates[i].baud > 0 )
       *speed = possibleBaudRates[i].baud;

    return possibleBaudRates[i].termiosValue;
}


static int serial_set_params( const ParameterConfig *config )
{
    unsigned int speed;
    int termios_value;

#ifdef DEBUG
    printf( "serial_set_params\n" );
#endif

    if ( ! Angel_FindParam( AP_BAUD_RATE, config, &speed ) )
    {
#ifdef DEBUG
        printf( "speed not found in config\n" );
#endif
        return DE_OKAY;
    }

    termios_value = find_baud_rate( &speed );
    if ( termios_value == 0 )
    {
#ifdef DEBUG
        printf( "speed not valid: %u\n", speed );
#endif
        return DE_OKAY;
    }

#ifdef DEBUG
    printf( "setting speed to %u\n", speed );
#endif

#ifdef COMPILING_ON_WINDOWS
    SetBaudRate((WORD)termios_value);
#else
    Unix_SetSerialBaudRate(termios_value);
#endif

    return DE_OKAY;
}


static int serial_get_user_params( ParameterOptions **p_options )
{
#ifdef DEBUG
    printf( "serial_get_user_params\n" );
#endif

    if ( user_options_set )
    {
        *p_options = &user_options;
    }
    else
    {
        *p_options = NULL;
    }

    return DE_OKAY;
}


static int serial_get_default_params( ParameterConfig **p_config )
{
#ifdef DEBUG
    printf( "serial_get_default_params\n" );
#endif

    *p_config = (ParameterConfig *) &serial_defaults;
    return DE_OKAY;
}


static int SerialIoctl(const int opcode, void *args) {

    int ret_code;

#ifdef DEBUG
    printf( "SerialIoctl: op %d arg %p\n", opcode, args ? args : "<NULL>");
#endif

    switch (opcode)
    {
       case DC_RESET:         
           ret_code = serial_reset();
           break;

       case DC_SET_PARAMS:     
           ret_code = serial_set_params((const ParameterConfig *)args);
           break;

       case DC_GET_USER_PARAMS:     
           ret_code = serial_get_user_params((ParameterOptions **)args);
           break;

       case DC_GET_DEFAULT_PARAMS:
           ret_code = serial_get_default_params((ParameterConfig **)args);
           break;

       default:               
           ret_code = DE_BAD_OP;
           break;
    }

  return ret_code;
}

DeviceDescr angel_SerialDevice = {
    "SERIAL",
    SerialOpen,
    SerialMatch,
    SerialClose,
    SerialRead,
    SerialWrite,
    SerialIoctl
};
@


1.2
log
@* sparcl-tdep.c: Use __CYGWIN__ instead of __CYGWIN32__.
* rdi-share/serpardr.c: Ditto.
* rdi-share/unixcomm.c: Ditto.
* rdi-share/serdrv.c: Ditto.
* rdi-share/hostchan.h: Ditto.
* rdi-share/hostchan.c: Ditto.
* rdi-share/host.h: Ditto.
* rdi-share/devsw.c: Ditto.
@
text
@@


1.1
log
@Initial revision
@
text
@d11 2
a12 2
 * $Revision: 1.4 $
 *     $Date: 1999/01/28 03:50:16 $
d35 2
d88 5
a92 2
#ifdef __hpux
    115200, 57600, 
d237 6
d257 1
a257 1
#if defined(__unix) || defined(__CYGWIN32__)
d528 7
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-2000-01-10 snapshot
@
text
@d11 2
a12 2
 * $Revision: 1.6 $
 *     $Date: 2000/01/06 14:01:53 $
a34 2
extern int baud_rate;   /* From gdb/top.c */

d86 2
a87 5
#ifdef B115200 || __hpux
    115200,
#endif
#ifdef B57600 || __hpux
    57600, 
a231 6
    else if (baud_rate > 0)
    {
      /* If the user specified a baud rate on the command line "-b" or via
         the "set remotebaud" command then try to use that one */
      process_baud_rate( baud_rate );
    }
a516 7
#else
#ifdef B115200
        {115200,B115200},
#endif
#ifdef B57600
	{57600,B57600},
#endif
@


1.1.1.3
log
@import gdb-2000-01-17 snapshot
@
text
@d11 2
a12 2
 * $Revision: 1.7 $
 *     $Date: 2000/01/12 12:53:29 $
d88 1
a88 1
#if defined(B115200) || defined(__hpux)
d91 1
a91 1
#if defined(B57600) || defined(__hpux)
@


1.1.1.3.20.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d257 1
a257 1
#if defined(__unix) || defined(__CYGWIN__)
@


1.1.1.3.18.1
log
@merge from trunk
@
text
@d257 1
a257 1
#if defined(__unix) || defined(__CYGWIN__)
@


