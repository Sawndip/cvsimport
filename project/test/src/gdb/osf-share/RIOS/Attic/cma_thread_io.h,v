head	1.2;
access;
symbols
	gdb_7_5_1-2012-11-29-release:1.1.1.1
	gdb_7_5-2012-08-17-release:1.1.1.1
	gdb_7_5-branch:1.1.1.1.0.154
	gdb_7_5-2012-07-18-branchpoint:1.1.1.1
	gdb_7_4_1-2012-04-26-release:1.1.1.1
	gdb_7_4-2012-01-24-release:1.1.1.1
	gdb_7_4-branch:1.1.1.1.0.152
	gdb_7_4-2011-12-13-branchpoint:1.1.1.1
	gdb_7_3_1-2011-09-04-release:1.1.1.1
	gdb_7_3-2011-07-26-release:1.1.1.1
	gdb_7_3-branch:1.1.1.1.0.150
	gdb_7_3-2011-04-01-branchpoint:1.1.1.1
	gdb_7_2-2010-09-02-release:1.1.1.1
	gdb_7_2-branch:1.1.1.1.0.148
	gdb_7_2-2010-07-07-branchpoint:1.1.1.1
	gdb_7_1-2010-03-18-release:1.1.1.1
	gdb_7_1-branch:1.1.1.1.0.146
	gdb_7_1-2010-02-18-branchpoint:1.1.1.1
	gdb_7_0_1-2009-12-22-release:1.1.1.1
	gdb_7_0-2009-10-06-release:1.1.1.1
	gdb_7_0-branch:1.1.1.1.0.144
	gdb_7_0-2009-09-16-branchpoint:1.1.1.1
	arc-sim-20090309:1.1.1.1
	msnyder-checkpoint-072509-branch:1.1.1.1.0.142
	msnyder-checkpoint-072509-branchpoint:1.1.1.1
	arc-insight_6_8-branch:1.1.1.1.0.140
	arc-insight_6_8-branchpoint:1.1.1.1
	insight_6_8-branch:1.1.1.1.0.138
	insight_6_8-branchpoint:1.1.1.1
	reverse-20081226-branch:1.1.1.1.0.136
	reverse-20081226-branchpoint:1.1.1.1
	multiprocess-20081120-branch:1.1.1.1.0.134
	multiprocess-20081120-branchpoint:1.1.1.1
	reverse-20080930-branch:1.1.1.1.0.132
	reverse-20080930-branchpoint:1.1.1.1
	reverse-20080717-branch:1.1.1.1.0.130
	reverse-20080717-branchpoint:1.1.1.1
	msnyder-reverse-20080609-branch:1.1.1.1.0.128
	msnyder-reverse-20080609-branchpoint:1.1.1.1
	drow-reverse-20070409-branch:1.1.1.1.0.126
	drow-reverse-20070409-branchpoint:1.1.1.1
	gdb_6_8-2008-03-27-release:1.1.1.1
	gdb_6_8-branch:1.1.1.1.0.124
	gdb_6_8-2008-02-26-branchpoint:1.1.1.1
	gdb_6_7_1-2007-10-29-release:1.1.1.1
	gdb_6_7-2007-10-10-release:1.1.1.1
	gdb_6_7-branch:1.1.1.1.0.122
	gdb_6_7-2007-09-07-branchpoint:1.1.1.1
	insight_6_6-20070208-release:1.1.1.1
	gdb_6_6-2006-12-18-release:1.1.1.1
	gdb_6_6-branch:1.1.1.1.0.120
	gdb_6_6-2006-11-15-branchpoint:1.1.1.1
	insight_6_5-20061003-release:1.1.1.1
	gdb-csl-symbian-6_4_50_20060226-12:1.1.1.1
	gdb-csl-sourcerygxx-3_4_4-25:1.1.1.1
	nickrob-async-20060828-mergepoint:1.1.1.1
	gdb-csl-symbian-6_4_50_20060226-11:1.1.1.1
	gdb-csl-sourcerygxx-4_1-17:1.1.1.1
	gdb-csl-20060226-branch-local-2:1.1.1.1
	gdb-csl-sourcerygxx-4_1-14:1.1.1.1
	gdb-csl-sourcerygxx-4_1-13:1.1.1.1
	gdb-csl-sourcerygxx-4_1-12:1.1.1.1
	gdb-csl-sourcerygxx-3_4_4-21:1.1.1.1
	gdb_6_5-20060621-release:1.1.1.1
	gdb-csl-sourcerygxx-4_1-9:1.1.1.1
	gdb-csl-sourcerygxx-4_1-8:1.1.1.1
	gdb-csl-sourcerygxx-4_1-7:1.1.1.1
	gdb-csl-arm-2006q1-6:1.1.1.1
	gdb-csl-sourcerygxx-4_1-6:1.1.1.1
	gdb-csl-symbian-6_4_50_20060226-10:1.1.1.1
	gdb-csl-symbian-6_4_50_20060226-9:1.1.1.1
	gdb-csl-symbian-6_4_50_20060226-8:1.1.1.1
	gdb-csl-coldfire-4_1-11:1.1.1.1
	gdb-csl-sourcerygxx-3_4_4-19:1.1.1.1
	gdb-csl-coldfire-4_1-10:1.1.1.1
	gdb_6_5-branch:1.1.1.1.0.118
	gdb_6_5-2006-05-14-branchpoint:1.1.1.1
	gdb-csl-sourcerygxx-4_1-5:1.1.1.1
	nickrob-async-20060513-branch:1.1.1.1.0.116
	nickrob-async-20060513-branchpoint:1.1.1.1
	gdb-csl-sourcerygxx-4_1-4:1.1.1.1
	msnyder-reverse-20060502-branch:1.1.1.1.0.114
	msnyder-reverse-20060502-branchpoint:1.1.1.1
	gdb-csl-morpho-4_1-4:1.1.1.1
	gdb-csl-sourcerygxx-3_4_4-17:1.1.1.1
	readline_5_1-import-branch:1.1.1.1.0.112
	readline_5_1-import-branchpoint:1.1.1.1
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.1.1.1
	gdb-csl-symbian-20060226-branch:1.1.1.1.0.110
	gdb-csl-symbian-20060226-branchpoint:1.1.1.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.1.1.1
	msnyder-reverse-20060331-branch:1.1.1.1.0.108
	msnyder-reverse-20060331-branchpoint:1.1.1.1
	gdb-csl-available-20060303-branch:1.1.1.1.0.106
	gdb-csl-available-20060303-branchpoint:1.1.1.1
	gdb-csl-20060226-branch:1.1.1.1.0.104
	gdb-csl-20060226-branchpoint:1.1.1.1
	gdb_6_4-20051202-release:1.1.1.1
	msnyder-fork-checkpoint-branch:1.1.1.1.0.102
	msnyder-fork-checkpoint-branchpoint:1.1.1.1
	gdb-csl-gxxpro-6_3-branch:1.1.1.1.0.100
	gdb-csl-gxxpro-6_3-branchpoint:1.1.1.1
	gdb_6_4-branch:1.1.1.1.0.98
	gdb_6_4-2005-11-01-branchpoint:1.1.1.1
	gdb-csl-arm-20051020-branch:1.1.1.1.0.96
	gdb-csl-arm-20051020-branchpoint:1.1.1.1
	msnyder-tracepoint-checkpoint-branch:1.1.1.1.0.94
	msnyder-tracepoint-checkpoint-branchpoint:1.1.1.1
	gdb-csl-arm-20050325-2005-q1b:1.1.1.1
	gdb-csl-arm-20050325-2005-q1a:1.1.1.1
	csl-arm-20050325-branch:1.1.1.1.0.92
	csl-arm-20050325-branchpoint:1.1.1.1
	gdb-post-i18n-errorwarning-20050211:1.1.1.1
	gdb-pre-i18n-errorwarning-20050211:1.1.1.1
	gdb_6_3-20041109-release:1.1.1.1
	gdb_6_3-branch:1.1.1.1.0.88
	gdb_6_3-20041019-branchpoint:1.1.1.1
	drow_intercu-merge-20040921:1.1.1.1
	drow_intercu-merge-20040915:1.1.1.1
	jimb-gdb_6_2-e500-branch:1.1.1.1.0.90
	jimb-gdb_6_2-e500-branchpoint:1.1.1.1
	gdb_6_2-20040730-release:1.1.1.1
	gdb_6_2-branch:1.1.1.1.0.86
	gdb_6_2-2004-07-10-gmt-branchpoint:1.1.1.1
	gdb_6_1_1-20040616-release:1.1.1.1
	gdb_6_1-2004-04-05-release:1.1.1.1
	drow_intercu-merge-20040402:1.1.1.1
	drow_intercu-merge-20040327:1.1.1.1
	ezannoni_pie-20040323-branch:1.1.1.1.0.84
	ezannoni_pie-20040323-branchpoint:1.1.1.1
	cagney_tramp-20040321-mergepoint:1.1.1.1
	cagney_tramp-20040309-branch:1.1.1.1.0.82
	cagney_tramp-20040309-branchpoint:1.1.1.1
	gdb_6_1-branch:1.1.1.1.0.80
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1.1.1
	drow_intercu-20040221-branch:1.1.1.1.0.78
	drow_intercu-20040221-branchpoint:1.1.1.1
	cagney_bfdfile-20040213-branch:1.1.1.1.0.76
	cagney_bfdfile-20040213-branchpoint:1.1.1.1
	drow-cplus-merge-20040208:1.1.1.1
	carlton_dictionary-20040126-merge:1.1.1.1
	cagney_bigcore-20040122-branch:1.1.1.1.0.74
	cagney_bigcore-20040122-branchpoint:1.1.1.1
	drow-cplus-merge-20040113:1.1.1.1
	drow-cplus-merge-20031224:1.1.1.1
	drow-cplus-merge-20031220:1.1.1.1
	carlton_dictionary-20031215-merge:1.1.1.1
	drow-cplus-merge-20031214:1.1.1.1
	carlton-dictionary-20031111-merge:1.1.1.1
	gdb_6_0-2003-10-04-release:1.1.1.1
	kettenis_sparc-20030918-branch:1.1.1.1.0.72
	kettenis_sparc-20030918-branchpoint:1.1.1.1
	carlton_dictionary-20030917-merge:1.1.1.1
	ezannoni_pie-20030916-branchpoint:1.1.1.1
	ezannoni_pie-20030916-branch:1.1.1.1.0.70
	cagney_x86i386-20030821-branch:1.1.1.1.0.68
	cagney_x86i386-20030821-branchpoint:1.1.1.1
	carlton_dictionary-20030805-merge:1.1.1.1
	carlton_dictionary-20030627-merge:1.1.1.1
	gdb_6_0-branch:1.1.1.1.0.66
	gdb_6_0-2003-06-23-branchpoint:1.1.1.1
	jimb-ppc64-linux-20030613-branch:1.1.1.1.0.64
	jimb-ppc64-linux-20030613-branchpoint:1.1.1.1
	cagney_convert-20030606-branch:1.1.1.1.0.62
	cagney_convert-20030606-branchpoint:1.1.1.1
	cagney_writestrings-20030508-branch:1.1.1.1.0.60
	cagney_writestrings-20030508-branchpoint:1.1.1.1
	jimb-ppc64-linux-20030528-branch:1.1.1.1.0.58
	jimb-ppc64-linux-20030528-branchpoint:1.1.1.1
	carlton_dictionary-20030523-merge:1.1.1.1
	cagney_fileio-20030521-branch:1.1.1.1.0.56
	cagney_fileio-20030521-branchpoint:1.1.1.1
	kettenis_i386newframe-20030517-mergepoint:1.1.1.1
	jimb-ppc64-linux-20030509-branch:1.1.1.1.0.54
	jimb-ppc64-linux-20030509-branchpoint:1.1.1.1
	kettenis_i386newframe-20030504-mergepoint:1.1.1.1
	carlton_dictionary-20030430-merge:1.1.1.1
	kettenis_i386newframe-20030419-branch:1.1.1.1.0.52
	kettenis_i386newframe-20030419-branchpoint:1.1.1.1
	carlton_dictionary-20030416-merge:1.1.1.1
	cagney_frameaddr-20030409-mergepoint:1.1.1.1
	kettenis_i386newframe-20030406-branch:1.1.1.1.0.50
	kettenis_i386newframe-20030406-branchpoint:1.1.1.1
	cagney_frameaddr-20030403-branchpoint:1.1.1.1
	cagney_frameaddr-20030403-branch:1.1.1.1.0.48
	cagney_framebase-20030330-mergepoint:1.1.1.1
	cagney_framebase-20030326-branch:1.1.1.1.0.46
	cagney_framebase-20030326-branchpoint:1.1.1.1
	cagney_lazyid-20030317-branch:1.1.1.1.0.44
	cagney_lazyid-20030317-branchpoint:1.1.1.1
	kettenis-i386newframe-20030316-mergepoint:1.1.1.1
	offbyone-20030313-branch:1.1.1.1.0.42
	offbyone-20030313-branchpoint:1.1.1.1
	kettenis-i386newframe-20030308-branch:1.1.1.1.0.40
	kettenis-i386newframe-20030308-branchpoint:1.1.1.1
	carlton_dictionary-20030305-merge:1.1.1.1
	cagney_offbyone-20030303-branch:1.1.1.1.0.38
	cagney_offbyone-20030303-branchpoint:1.1.1.1
	carlton_dictionary-20030207-merge:1.1.1.1
	interps-20030203-mergepoint:1.1.1.1
	interps-20030202-branch:1.1.1.1.0.36
	interps-20030202-branchpoint:1.1.1.1
	cagney-unwind-20030108-branch:1.1.1.1.0.34
	cagney-unwind-20030108-branchpoint:1.1.1.1
	carlton_dictionary-20021223-merge:1.1.1.1
	gdb_5_3-2002-12-12-release:1.1.1.1
	carlton_dictionary-20021115-merge:1.1.1.1
	kseitz_interps-20021105-merge:1.1.1.1
	kseitz_interps-20021103-merge:1.1.1.1
	drow-cplus-merge-20021020:1.1.1.1
	drow-cplus-merge-20021025:1.1.1.1
	carlton_dictionary-20021025-merge:1.1.1.1
	carlton_dictionary-20021011-merge:1.1.1.1
	drow-cplus-branch:1.1.1.1.0.32
	drow-cplus-branchpoint:1.1.1.1
	kseitz_interps-20020930-merge:1.1.1.1
	carlton_dictionary-20020927-merge:1.1.1.1
	carlton_dictionary-branch:1.1.1.1.0.30
	carlton_dictionary-20020920-branchpoint:1.1.1.1
	gdb_5_3-branch:1.1.1.1.0.28
	gdb_5_3-2002-09-04-branchpoint:1.1.1.1
	kseitz_interps-20020829-merge:1.1.1.1
	cagney_sysregs-20020825-branch:1.1.1.1.0.26
	cagney_sysregs-20020825-branchpoint:1.1.1.1
	readline_4_3-import-branch:1.1.1.1.0.24
	readline_4_3-import-branchpoint:1.1.1.1
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.22
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.20
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	jimb-macro-020506-branch:1.1.1.1.0.18
	jimb-macro-020506-branchpoint:1.1.1.1
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.16
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.14
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.12
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.10
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	dberlin-typesystem-branch:1.1.1.1.0.8
	dberlin-typesystem-branchpoint:1.1.1.1
	gdb-post-ptid_t-2001-05-03:1.1.1.1
	gdb-pre-ptid_t-2001-05-03:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-post-protoization-2000-07-29:1.1.1.1
	gdb-pre-protoization-2000-07-29:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb-post-params-removal-2000-06-04:1.1.1.1
	gdb-pre-params-removal-2000-06-04:1.1.1.1
	gdb-post-params-removal-2000-05-28:1.1.1.1
	gdb-pre-params-removal-2000-05-28:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2012.12.07.02.57.50;	author brobecke;	state dead;
branches;
next	1.1;

1.1
date	99.04.16.01.34.27;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.27;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Delete the gdb/osf-share directory.

These are old files that GDB does not use anymore, and probably has not
used for a long time.

gdb/ChangeLog:

        * osf-share/AT386/cma_thread_io.h: Delete.
        * osf-share/HP800/cma_thread_io.h: Delete.
        * osf-share/README: Delete.
        * osf-share/RIOS/cma_thread_io.h: Delete.
        * osf-share/cma_attr.h: Delete.
        * osf-share/cma_deb_core.h: Delete.
        * osf-share/cma_debug_client.h: Delete.
        * osf-share/cma_errors.h: Delete.
        * osf-share/cma_handle.h: Delete.
        * osf-share/cma_init.h: Delete.
        * osf-share/cma_list.h: Delete.
        * osf-share/cma_mutex.h: Delete.
        * osf-share/cma_sched.h: Delete.
        * osf-share/cma_semaphore_defs.h: Delete.
        * osf-share/cma_sequence.h: Delete.
        * osf-share/cma_stack.h: Delete.
        * osf-share/cma_stack_int.h: Delete.
        * osf-share/cma_tcb_defs.h: Delete.
        * osf-share/cma_util.h: Delete.
        * Makefile.in (HFILES_NO_SRCDIR): Remove entries for the files
        in osf-share.
        * config/djgpp/fnchange.lst: Remove osf-share/cma_stack_int.h entry.
        * contrib/ari/gdb_find.sh: Remove handling of osf-share.
        * copyright.sh (NOT_FSF_LIST): Remove "gdb/osf-share" entry.
@
text
@/* 
 * (c) Copyright 1990-1996 OPEN SOFTWARE FOUNDATION, INC.
 * (c) Copyright 1990-1996 HEWLETT-PACKARD COMPANY
 * (c) Copyright 1990-1996 DIGITAL EQUIPMENT CORPORATION
 * (c) Copyright 1991, 1992 Siemens-Nixdorf Information Systems
 * To anyone who acknowledges that this file is provided "AS IS" without
 * any express or implied warranty: permission to use, copy, modify, and
 * distribute this file for any purpose is hereby granted without fee,
 * provided that the above copyright notices and this notice appears in
 * all source code copies, and that none of the names listed above be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission.  None of these organizations
 * makes any representations about the suitability of this software for
 * any purpose.
 */
/*
 *	Header file for thread synchrounous I/O
 */

#ifndef CMA_THREAD_IO
#define CMA_THREAD_IO

/*
 *  INCLUDE FILES
 */

#include <cma_config.h>
#include <sys/select.h>
#include <cma.h>
#include <sys/types.h>
#include <sys/time.h>
#include <cma_init.h>
#include <cma_errors.h>

/*
 * CONSTANTS
 */

/*
 * Maximum number of files (ie, max_fd+1)
 */
#define cma__c_mx_file	FD_SETSIZE

/*
 * Number of bits per file descriptor bit mask (ie number of bytes * bits/byte)
 */
#define cma__c_nbpm	NFDBITS

/*
 * TYPE DEFINITIONS
 */

typedef enum CMA__T_IO_TYPE {
    cma__c_io_read   = 0,
    cma__c_io_write  = 1,
    cma__c_io_except = 2
    } cma__t_io_type;
#define cma__c_max_io_type	2

/*
 * From our local <sys/types.h>:
 *
 *  typedef long    fd_mask;
 *
 *  typedef struct fd_set {
 *          fd_mask fds_bits[howmany(FD_SETSIZE, NFDBITS)];
 *  } fd_set;
 *
 */
typedef fd_mask cma__t_mask;
typedef fd_set  cma__t_file_mask;



/*
 *  GLOBAL DATA
 */

/*
 * Maximum number of files (ie, max_fd+1) as determined by getdtablesize().
 */
extern int	cma__g_mx_file;

/*
 * Number of submasks (ie "int" sized chunks) per file descriptor mask as
 * determined by getdtablesize().
 */
extern int	cma__g_nspm;

/*
 * MACROS
 */

/*
 * Define a constant for the errno value which indicates that the requested
 * operation was not performed because it would block the process.
 */
# define cma__is_blocking(s) \
    ((s == EAGAIN) || (s == EWOULDBLOCK) || (s == EINPROGRESS) || \
     (s == EALREADY) || (s == EDEADLK))

/*
*	It is necessary to issue an I/O function, before calling cma__io_wait()
*	in the following cases:
*
*		*	This file descriptor has been set non-blocking by CMA
*		*	This file descriptor has been set non-blocking by the user.
*/

#define cma__issue_io_call(fd)					\
	( (cma__g_file[fd]->non_blocking) || \
	  (cma__g_file[fd]->user_fl.user_non_blocking) )


#define cma__set_user_nonblocking(flags) \

/*
 * Determine if the file is open
 */
/*
 * If the file gets closed while waiting for the mutex cma__g_file[rfd]
 * gets set to null. This results in a crash if NDEBUG is set to 0 
 * since cma__int_lock tries to dereference it to set the mutex ownership 
 * after it gets the mutex. The following will still set the ownership
 * in cma__int_lock so we'll set it back to noone if cma__g_file is null
 * when we come back just in case it matters. It shouldn't since its no
 * longer in use but..... 
 * Callers of this should recheck cma__g_file after the reservation to
 * make sure continueing makes sense.
 */
#define cma__fd_reserve(rfd) 	\
		{ \
		cma__t_int_mutex *__mutex__; \
		__mutex__ = cma__g_file[rfd]->mutex; \
		cma__int_lock (__mutex__); \
		if(cma__g_file[rfd] == (cma__t_file_obj *)cma_c_null_ptr) \
			cma__int_unlock(__mutex__); \
		}
		

/*
 * Unreserve a file descriptor
 */
#define cma__fd_unreserve(ufd)	cma__int_unlock (cma__g_file[ufd]->mutex)

/*
 * AND together two select file descriptor masks
 */
#define cma__fdm_and(target,a,b)					\
	{								\
	int __i__ = cma__g_nspm;					\
	while (__i__--)							\
	    (target)->fds_bits[__i__] =					\
		(a)->fds_bits[__i__] & (b)->fds_bits[__i__];		\
	}

/*
 * Clear a bit in a select file descriptor mask
 *
 * FD_CLR(n, p)  :=  ((p)->fds_bits[(n)/NFDBITS] &= ~(1 << ((n) % NFDBITS)))
 */
#define cma__fdm_clr_bit(n,p)	FD_CLR (n, p)

/*
 * Copy the contents of one file descriptor mask into another.  If the 
 * destination operand is null, do nothing; if the source operand is null, 
 * simply zero the destination.
 */
#define cma__fdm_copy(src,dst,nfds) {					\
	if (dst)							\
	    if (src) {							\
		cma__t_mask *__s__ = (cma__t_mask *)(src);		\
		cma__t_mask *__d__ = (cma__t_mask *)(dst);		\
		int __i__;						\
		for (__i__ = 0; __i__ < (nfds); __i__ += cma__c_nbpm)	\
		    *__d__++ = *__s__++;				\
		}							\
	    else							\
		cma__fdm_zero (dst);					\
	    }

/*
 * To increment count for each bit set in fd - mask
 */
#define cma__fdm_count_bits(map,count)					\
	{								\
	int	__i__ = cma__g_nspm;					\
	while (__i__--) {						\
	    cma__t_mask    __tm__;				        \
	    __tm__ = (map)->fds_bits[__i__];				\
	    while(__tm__) {						\
		(count)++;						\
		__tm__ &= ~(__tm__ & (-__tm__)); /* Assumes 2's comp */	\
		}							\
	    }								\
	}

/*
 * Test if a bit is set in a select file descriptor mask
 *
 * FD_ISSET(n,p)  :=  ((p)->fds_bits[(n)/NFDBITS] & (1 << ((n) % NFDBITS)))
 */
#define cma__fdm_is_set(n,p)	FD_ISSET (n, p)

/*
 * OR together two select file descriptor masks
 */
#define cma__fdm_or(target,a,b)						\
	{								\
	int __i__ = cma__g_nspm;					\
	while (__i__--)							\
	    (target)->fds_bits[__i__] =					\
		(a)->fds_bits[__i__] | (b)->fds_bits[__i__];		\
	}

/*
 * Set a bit in a select file descriptor mask
 * 
 * FD_SET(n,p)  :=  ((p)->fds_bits[(n)/NFDBITS] |= (1 << ((n) % NFDBITS)))
 */
#define cma__fdm_set_bit(n,p)	FD_SET (n, p)

/*
 * Clear a select file descriptor mask.
 */
#define cma__fdm_zero(n)						\
	cma__memset ((char *) n, 0, cma__g_nspm * sizeof(cma__t_mask))





/*
 * CMA "thread-synchronous" I/O read/write operations
 */

    /*
     * Since all CMA "thread-synchronous" I/O (read or write) operations on 
     * U*ix follow the exact same structure, the wrapper routines have been
     * condensed into a macro.
     *
     * The steps performed are as follows:
     *	1. Check that the file descriptor is a legitimate value.
     *	2. Check that the entry in the CMA file "database" which corresponds to 
     *	    the file descriptor indicates that the "file" was "opened" by CMA.
     *  3. Reserve the file, to serialized access to files.  This not only 
     *	    simplifies things, but also defends against non-reentrancy.
     *  4. If the "file" is "set" for non-blocking I/O, check if we
     *      have actually set the file non-blocking yet, and if not do so.
     *	    Then, issue the I/O operantion.
     *	    Success or failure is returned immediately, after unreserving the 
     *	    file.  If the error indicates that the operation would have caused
     *	    the process to block, continue to the next step.
     *	5. The I/O prolog adds this "file" to the global bit mask, which 
     *	    represents all "files" which have threads waiting to perform I/O on 
     *	    them, and causes the thread to block on the condition variable for
     *	    this "file".  Periodically, a select is done on this global bit 
     *	    mask, and the condition variables corresponding to "files" which 
     *	    are ready for I/O are signaled, releasing those waiting threads to
     *	    perform their I/O.
     *  6. When the thread returns from the I/O prolog, it can (hopefully) 
     *	    perform its operation without blocking the process.
     *	7. The I/O epilog clears the bit in the global mask and/or signals the 
     *	    the next thread waiting for this "file", as appropriate.
     *  8. If the I/O failed, continue to loop.
     *	9. Finally, the "file" is unreserved, as we're done with it, and the
     *	    result of the operation is returned.
     *
     *
     * Note:  currently, we believe that timeslicing which is based on the
     *	    virtual-time timer does not cause system calls to return EINTR.  
     *	    Threfore, any EINTR returns are relayed directly to the caller.
     *	    On platforms which do not support a virtual-time timer, the code
     *	    should probably catch EINTR returns and restart the system call.
     */

/*
 * This macro is used for both read-type and write-type functions.
 *
 * Note:  the second call to "func" may require being bracketed in a
 *	  cma__interrupt_disable/cma__interrupt_enable pair, but we'll 
 *	  wait and see if this is necessary.
 */
#define cma__ts_func(func,fd,arglist,type,post_process)	{ \
    cma_t_integer   __res__; \
    cma_t_boolean   __done__ = cma_c_false; \
    if ((fd < 0) || (fd >= cma__g_mx_file)) return (cma__set_errno (EBADF), -1); \
    if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \
    cma__fd_reserve (fd); \
    if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \
    if (cma__issue_io_call(fd)) {\
	if ((!cma__g_file[fd]->set_non_blocking) && \
		(cma__g_file[fd]->non_blocking == cma_c_true)) \
	    cma__set_nonblocking(fd); \
        cma__interrupt_disable (0); \
	TRY { \
	    __res__ = func arglist; \
	    } \
	CATCH_ALL { \
	    cma__interrupt_enable (0); \
	    cma__fd_unreserve (fd); \
	    RERAISE; \
	    } \
	ENDTRY \
        cma__interrupt_enable (0); \
	if ((__res__ != -1) \
		|| (!cma__is_blocking (errno)) \
		|| (cma__g_file[fd]->user_fl.user_non_blocking)) \
	    __done__ = cma_c_true; \
	} \
    if (__done__) { \
	cma__fd_unreserve (fd); \
	} \
    else { \
	TRY { \
	    cma__io_prolog (type, fd); \
	    while (!__done__) { \
		cma__io_wait (type, fd); \
		__res__ = func arglist; \
		if ((__res__ != -1) \
			|| (!cma__is_blocking (errno)) \
			|| (cma__g_file[fd]->user_fl.user_non_blocking)) \
		    __done__ = cma_c_true; \
		} \
	    } \
	FINALLY { \
	    cma__io_epilog (type, fd); \
	    cma__fd_unreserve (fd); \
	    } \
	ENDTRY \
	} \
    if (__res__ != -1)  post_process; \
    return __res__;  \
    }

    /*
     * Since most CMA "thread-synchronous" I/O ("open"-type) operations on 
     * U*ix follow the exact same structure, the wrapper routines have been
     * condensed into a macro.
     *
     * The steps performed are as follows:
     *	1. Issue the open function.
     *	2. If the value returned indicates an error, return it to the caller.
     *  3. If the file descriptor returned is larger than what we think is the
     *	    maximum value (ie if it is too big for our database) then bugcheck.
     *  4. "Open" the "file" in the CMA file database.
     *	5. Return the file descriptor value to the caller.
     *
     * FIX-ME: for the time being, if the I/O operation returns EINTR, we 
     *	    simply return it to the caller; eventually, we should catch this 
     *	    and "do the right thing" (if we can figure out what that is).
     */

/*
 * This macro is used for all "open"-type functions which return a single file
 * desciptor by immediate value.
 */
#define cma__ts_open(func,arglist,post_process)  {		\
    int	__fd__;							\
    TRY {							\
	cma__int_init ();					\
	cma__int_lock (cma__g_io_data_mutex);			\
	__fd__ = func arglist;					\
	cma__int_unlock (cma__g_io_data_mutex);			\
	if (__fd__ >= 0 && __fd__ < cma__g_mx_file)		\
	    post_process;					\
	}							\
    CATCH_ALL							\
	{							\
	cma__set_errno (EBADF);					\
	__fd__ = -1;						\
	}							\
    ENDTRY							\
    if (__fd__ >= cma__g_mx_file)				\
	cma__bugcheck ("cma__ts_open:  fd is too large");	\
    return __fd__;						\
    }
/*
 * This macro is used for all "open"-type functions which return a pair of file
 * desciptors by reference parameter.
 */
#define cma__ts_open2(func,fdpair,arglist,post_process)  {		\
    int	    __res__;							\
    TRY {								\
	cma__int_init ();						\
	cma__int_lock (cma__g_io_data_mutex);				\
	__res__ = func arglist;						\
	cma__int_unlock (cma__g_io_data_mutex);				\
	if (__res__ >= 0 && fdpair[0] < cma__g_mx_file			\
		&& fdpair[1] < cma__g_mx_file)				\
	    post_process;						\
	}								\
    CATCH_ALL								\
	{								\
	cma__set_errno (EBADF);						\
	__res__ = -1;							\
	}								\
    ENDTRY								\
    if ((fdpair[0] >= cma__g_mx_file) || (fdpair[1] >= cma__g_mx_file)) \
	cma__bugcheck ("cma__ts_open2:  one of fd's is too large"); \
    return __res__;							\
    }

/*
 * INTERNAL INTERFACES
 */
extern void cma__close_general (int);

extern void
cma__init_thread_io (void);

extern cma_t_boolean cma__io_available  (cma__t_io_type,int,struct timeval *);

extern void cma__io_epilog  (cma__t_io_type,int);

extern void cma__io_prolog  (cma__t_io_type,int);

extern void cma__io_wait  (cma__t_io_type,int);

extern void cma__open_general  (int);

extern void cma__reinit_thread_io  (int);

extern void cma__set_nonblocking  (int);

extern void cma__set_user_nonblock_flags  (int,int);

extern cma_t_boolean
cma__is_open (int fd);


#endif


@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

