head	1.26;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.26
	gdb_7_6-2013-04-26-release:1.26
	gdb_7_6-branch:1.26.0.2
	gdb_7_6-2013-03-12-branchpoint:1.26
	gdb_7_5_1-2012-11-29-release:1.25
	gdb_7_5-2012-08-17-release:1.25
	gdb_7_5-branch:1.25.0.2
	gdb_7_5-2012-07-18-branchpoint:1.25
	gdb_7_4_1-2012-04-26-release:1.22.2.1
	gdb_7_4-2012-01-24-release:1.22.2.1
	gdb_7_4-branch:1.22.0.2
	gdb_7_4-2011-12-13-branchpoint:1.22
	gdb_7_3_1-2011-09-04-release:1.21
	gdb_7_3-2011-07-26-release:1.21
	gdb_7_3-branch:1.21.0.2
	gdb_7_3-2011-04-01-branchpoint:1.21
	gdb_7_2-2010-09-02-release:1.14
	gdb_7_2-branch:1.14.0.2
	gdb_7_2-2010-07-07-branchpoint:1.14
	gdb_7_1-2010-03-18-release:1.12
	gdb_7_1-branch:1.12.0.2
	gdb_7_1-2010-02-18-branchpoint:1.12
	gdb_7_0_1-2009-12-22-release:1.11
	gdb_7_0-2009-10-06-release:1.11
	gdb_7_0-branch:1.11.0.4
	gdb_7_0-2009-09-16-branchpoint:1.11
	arc-sim-20090309:1.9
	msnyder-checkpoint-072509-branch:1.11.0.2
	msnyder-checkpoint-072509-branchpoint:1.11
	arc-insight_6_8-branch:1.9.0.16
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.14
	insight_6_8-branchpoint:1.9
	reverse-20081226-branch:1.9.0.12
	reverse-20081226-branchpoint:1.9
	multiprocess-20081120-branch:1.9.0.10
	multiprocess-20081120-branchpoint:1.9
	reverse-20080930-branch:1.9.0.8
	reverse-20080930-branchpoint:1.9
	reverse-20080717-branch:1.9.0.6
	reverse-20080717-branchpoint:1.9
	msnyder-reverse-20080609-branch:1.9.0.4
	msnyder-reverse-20080609-branchpoint:1.9
	drow-reverse-20070409-branch:1.7.0.2
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.9
	gdb_6_8-branch:1.9.0.2
	gdb_6_8-2008-02-26-branchpoint:1.9
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.2
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.18
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.6
	gdb-csl-sourcerygxx-3_4_4-25:1.5
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.6
	gdb-csl-sourcerygxx-4_1-17:1.6
	gdb-csl-20060226-branch-local-2:1.6
	gdb-csl-sourcerygxx-4_1-14:1.6
	gdb-csl-sourcerygxx-4_1-13:1.6
	gdb-csl-sourcerygxx-4_1-12:1.6
	gdb-csl-sourcerygxx-3_4_4-21:1.6
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.6
	gdb-csl-sourcerygxx-4_1-8:1.6
	gdb-csl-sourcerygxx-4_1-7:1.6
	gdb-csl-arm-2006q1-6:1.6
	gdb-csl-sourcerygxx-4_1-6:1.6
	gdb-csl-symbian-6_4_50_20060226-10:1.6
	gdb-csl-symbian-6_4_50_20060226-9:1.6
	gdb-csl-symbian-6_4_50_20060226-8:1.6
	gdb-csl-coldfire-4_1-11:1.6
	gdb-csl-sourcerygxx-3_4_4-19:1.6
	gdb-csl-coldfire-4_1-10:1.6
	gdb_6_5-branch:1.6.0.16
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.6
	nickrob-async-20060513-branch:1.6.0.14
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.6
	msnyder-reverse-20060502-branch:1.6.0.12
	msnyder-reverse-20060502-branchpoint:1.6
	gdb-csl-morpho-4_1-4:1.6
	gdb-csl-sourcerygxx-3_4_4-17:1.6
	readline_5_1-import-branch:1.6.0.10
	readline_5_1-import-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.6
	gdb-csl-symbian-20060226-branch:1.6.0.8
	gdb-csl-symbian-20060226-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.6
	msnyder-reverse-20060331-branch:1.6.0.6
	msnyder-reverse-20060331-branchpoint:1.6
	gdb-csl-available-20060303-branch:1.6.0.4
	gdb-csl-available-20060303-branchpoint:1.6
	gdb-csl-20060226-branch:1.6.0.2
	gdb-csl-20060226-branchpoint:1.6
	gdb_6_4-20051202-release:1.5
	msnyder-fork-checkpoint-branch:1.5.0.12
	msnyder-fork-checkpoint-branchpoint:1.5
	gdb-csl-gxxpro-6_3-branch:1.5.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.5
	gdb_6_4-branch:1.5.0.8
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb-csl-arm-20051020-branch:1.5.0.6
	gdb-csl-arm-20051020-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb-csl-arm-20050325-2005-q1b:1.5
	gdb-csl-arm-20050325-2005-q1a:1.5
	csl-arm-20050325-branch:1.5.0.2
	csl-arm-20050325-branchpoint:1.5
	gdb-post-i18n-errorwarning-20050211:1.4
	gdb-pre-i18n-errorwarning-20050211:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.4
	gdb_6_3-20041019-branchpoint:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.6
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.2.20.1
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.24
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.22
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.20
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.18
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.16
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.14
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-branch:1.2.0.12
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.10
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.8
	cagney_x86i386-20030821-branch:1.2.0.6
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.4
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.2
	carlton_dictionary-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.26
date	2013.01.01.06.32.41;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2012.07.10.20.12.49;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.04.08.17.00;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2011.12.21.07.10.58;	author brobecke;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.06.19.50.04;	author jkratoch;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2011.01.07.19.36.15;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.05.22.22.48;	author msnyder;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.01.15.33.00;	author brobecke;	state Exp;
branches;
next	1.18;

1.18
date	2010.11.24.19.01.51;	author jkratoch;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.26.14.50.13;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.07.08.32.41;	author hilfingr;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.07.06.53.44;	author hilfingr;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.14.00.23.26;	author msnyder;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.06.19.14.08;	author msnyder;	state Exp;
branches;
next	1.12;

1.12
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.01.22.39.41;	author jkratoch;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.23.18.08.28;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.11.18.13.49;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.02.21.01.55;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.20.09.51.34;	author hilfingr;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.11.23.29.47;	author carlton;	state Exp;
branches
	1.2.12.1
	1.2.18.1
	1.2.20.1;
next	1.1;

1.1
date	2002.09.20.23.55.03;	author carlton;	state dead;
branches
	1.1.2.1;
next	;

1.22.2.1
date	2012.01.06.04.43.07;	author brobecke;	state Exp;
branches;
next	;

1.2.12.1
date	2003.12.14.20.27.10;	author drow;	state Exp;
branches;
next	;

1.2.18.1
date	2004.09.16.17.01.02;	author drow;	state Exp;
branches;
next	;

1.2.20.1
date	2004.06.02.21.03.25;	author cagney;	state Exp;
branches;
next	;

1.1.2.1
date	2002.09.20.23.55.03;	author carlton;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.09.24.00.04.50;	author carlton;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.09.25.00.19.26;	author carlton;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.09.26.00.04.42;	author carlton;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2002.09.27.00.18.17;	author carlton;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2002.09.30.22.57.22;	author carlton;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2003.02.20.23.54.58;	author carlton;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2003.03.06.00.56.27;	author carlton;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2003.05.01.00.46.47;	author carlton;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2003.05.23.18.40.36;	author carlton;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2003.06.27.21.49.52;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Routines for name->symbol lookups in GDB.
   
   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   Contributed by David Carlton <carlton@@bactrian.org> and by Kealia,
   Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include <ctype.h>
#include "gdb_obstack.h"
#include "symtab.h"
#include "buildsym.h"
#include "gdb_assert.h"
#include "dictionary.h"

/* This file implements dictionaries, which are tables that associate
   symbols to names.  They are represented by an opaque type 'struct
   dictionary'.  That type has various internal implementations, which
   you can choose between depending on what properties you need
   (e.g. fast lookup, order-preserving, expandable).

   Each dictionary starts with a 'virtual function table' that
   contains the functions that actually implement the various
   operations that dictionaries provide.  (Note, however, that, for
   the sake of client code, we also provide some functions that can be
   implemented generically in terms of the functions in the vtable.)

   To add a new dictionary implementation <impl>, what you should do
   is:

   * Add a new element DICT_<IMPL> to dict_type.
   
   * Create a new structure dictionary_<impl>.  If your new
   implementation is a variant of an existing one, make sure that
   their structs have the same initial data members.  Define accessor
   macros for your new data members.

   * Implement all the functions in dict_vector as static functions,
   whose name is the same as the corresponding member of dict_vector
   plus _<impl>.  You don't have to do this for those members where
   you can reuse existing generic functions
   (e.g. add_symbol_nonexpandable, free_obstack) or in the case where
   your new implementation is a variant of an existing implementation
   and where the variant doesn't affect the member function in
   question.

   * Define a static const struct dict_vector dict_<impl>_vector.

   * Define a function dict_create_<impl> to create these
   gizmos.  Add its declaration to dictionary.h.

   To add a new operation <op> on all existing implementations, what
   you should do is:

   * Add a new member <op> to struct dict_vector.

   * If there is useful generic behavior <op>, define a static
   function <op>_something_informative that implements that behavior.
   (E.g. add_symbol_nonexpandable, free_obstack.)

   * For every implementation <impl> that should have its own specific
   behavior for <op>, define a static function <op>_<impl>
   implementing it.

   * Modify all existing dict_vector_<impl>'s to include the appropriate
   member.

   * Define a function dict_<op> that looks up <op> in the dict_vector
   and calls the appropriate function.  Add a declaration for
   dict_<op> to dictionary.h.  */

/* An enum representing the various implementations of dictionaries.
   Used only for debugging.  */

enum dict_type
  {
    /* Symbols are stored in a fixed-size hash table.  */
    DICT_HASHED,
    /* Symbols are stored in an expandable hash table.  */
    DICT_HASHED_EXPANDABLE,
    /* Symbols are stored in a fixed-size array.  */
    DICT_LINEAR,
    /* Symbols are stored in an expandable array.  */
    DICT_LINEAR_EXPANDABLE
  };

/* The virtual function table.  */

struct dict_vector
{
  /* The type of the dictionary.  This is only here to make debugging
     a bit easier; it's not actually used.  */
  enum dict_type type;
  /* The function to free a dictionary.  */
  void (*free) (struct dictionary *dict);
  /* Add a symbol to a dictionary, if possible.  */
  void (*add_symbol) (struct dictionary *dict, struct symbol *sym);
  /* Iterator functions.  */
  struct symbol *(*iterator_first) (const struct dictionary *dict,
				    struct dict_iterator *iterator);
  struct symbol *(*iterator_next) (struct dict_iterator *iterator);
  /* Functions to iterate over symbols with a given name.  */
  struct symbol *(*iter_match_first) (const struct dictionary *dict,
				      const char *name,
				      symbol_compare_ftype *equiv,
				      struct dict_iterator *iterator);
  struct symbol *(*iter_match_next) (const char *name,
				     symbol_compare_ftype *equiv,
				     struct dict_iterator *iterator);
  /* A size function, for maint print symtabs.  */
  int (*size) (const struct dictionary *dict);
};

/* Now comes the structs used to store the data for different
   implementations.  If two implementations have data in common, put
   the common data at the top of their structs, ordered in the same
   way.  */

struct dictionary_hashed
{
  int nbuckets;
  struct symbol **buckets;
};

struct dictionary_hashed_expandable
{
  /* How many buckets we currently have.  */
  int nbuckets;
  struct symbol **buckets;
  /* How many syms we currently have; we need this so we will know
     when to add more buckets.  */
  int nsyms;
};

struct dictionary_linear
{
  int nsyms;
  struct symbol **syms;
};

struct dictionary_linear_expandable
{
  /* How many symbols we currently have.  */
  int nsyms;
  struct symbol **syms;
  /* How many symbols we can store before needing to reallocate.  */
  int capacity;
};

/* And now, the star of our show.  */

struct dictionary
{
  const struct dict_vector *vector;
  union
  {
    struct dictionary_hashed hashed;
    struct dictionary_hashed_expandable hashed_expandable;
    struct dictionary_linear linear;
    struct dictionary_linear_expandable linear_expandable;
  }
  data;
};

/* Accessor macros.  */

#define DICT_VECTOR(d)			(d)->vector

/* These can be used for DICT_HASHED_EXPANDABLE, too.  */

#define DICT_HASHED_NBUCKETS(d)		(d)->data.hashed.nbuckets
#define DICT_HASHED_BUCKETS(d)		(d)->data.hashed.buckets
#define DICT_HASHED_BUCKET(d,i)		DICT_HASHED_BUCKETS (d) [i]

#define DICT_HASHED_EXPANDABLE_NSYMS(d)	(d)->data.hashed_expandable.nsyms

/* These can be used for DICT_LINEAR_EXPANDABLEs, too.  */

#define DICT_LINEAR_NSYMS(d)		(d)->data.linear.nsyms
#define DICT_LINEAR_SYMS(d)		(d)->data.linear.syms
#define DICT_LINEAR_SYM(d,i)		DICT_LINEAR_SYMS (d) [i]

#define DICT_LINEAR_EXPANDABLE_CAPACITY(d) \
		(d)->data.linear_expandable.capacity

/* The initial size of a DICT_*_EXPANDABLE dictionary.  */

#define DICT_EXPANDABLE_INITIAL_CAPACITY 10

/* This calculates the number of buckets we'll use in a hashtable,
   given the number of symbols that it will contain.  */

#define DICT_HASHTABLE_SIZE(n)	((n)/5 + 1)

/* Accessor macros for dict_iterators; they're here rather than
   dictionary.h because code elsewhere should treat dict_iterators as
   opaque.  */

/* The dictionary that the iterator is associated to.  */
#define DICT_ITERATOR_DICT(iter)		(iter)->dict
/* For linear dictionaries, the index of the last symbol returned; for
   hashed dictionaries, the bucket of the last symbol returned.  */
#define DICT_ITERATOR_INDEX(iter)		(iter)->index
/* For hashed dictionaries, this points to the last symbol returned;
   otherwise, this is unused.  */
#define DICT_ITERATOR_CURRENT(iter)		(iter)->current

/* Declarations of functions for vectors.  */

/* Functions that might work across a range of dictionary types.  */

static void add_symbol_nonexpandable (struct dictionary *dict,
				      struct symbol *sym);

static void free_obstack (struct dictionary *dict);

/* Functions for DICT_HASHED and DICT_HASHED_EXPANDABLE
   dictionaries.  */

static struct symbol *iterator_first_hashed (const struct dictionary *dict,
					     struct dict_iterator *iterator);

static struct symbol *iterator_next_hashed (struct dict_iterator *iterator);

static struct symbol *iter_match_first_hashed (const struct dictionary *dict,
					       const char *name,
					       symbol_compare_ftype *compare,
					      struct dict_iterator *iterator);

static struct symbol *iter_match_next_hashed (const char *name,
					      symbol_compare_ftype *compare,
					      struct dict_iterator *iterator);

static unsigned int dict_hash (const char *string);

/* Functions only for DICT_HASHED.  */

static int size_hashed (const struct dictionary *dict);

/* Functions only for DICT_HASHED_EXPANDABLE.  */

static void free_hashed_expandable (struct dictionary *dict);

static void add_symbol_hashed_expandable (struct dictionary *dict,
					  struct symbol *sym);

static int size_hashed_expandable (const struct dictionary *dict);

/* Functions for DICT_LINEAR and DICT_LINEAR_EXPANDABLE
   dictionaries.  */

static struct symbol *iterator_first_linear (const struct dictionary *dict,
					     struct dict_iterator *iterator);

static struct symbol *iterator_next_linear (struct dict_iterator *iterator);

static struct symbol *iter_match_first_linear (const struct dictionary *dict,
					       const char *name,
					       symbol_compare_ftype *compare,
					       struct dict_iterator *iterator);

static struct symbol *iter_match_next_linear (const char *name,
					      symbol_compare_ftype *compare,
					      struct dict_iterator *iterator);

static int size_linear (const struct dictionary *dict);

/* Functions only for DICT_LINEAR_EXPANDABLE.  */

static void free_linear_expandable (struct dictionary *dict);

static void add_symbol_linear_expandable (struct dictionary *dict,
					  struct symbol *sym);

/* Various vectors that we'll actually use.  */

static const struct dict_vector dict_hashed_vector =
  {
    DICT_HASHED,			/* type */
    free_obstack,			/* free */
    add_symbol_nonexpandable,		/* add_symbol */
    iterator_first_hashed,		/* iterator_first */
    iterator_next_hashed,		/* iterator_next */
    iter_match_first_hashed,		/* iter_name_first */
    iter_match_next_hashed,		/* iter_name_next */
    size_hashed,			/* size */
  };

static const struct dict_vector dict_hashed_expandable_vector =
  {
    DICT_HASHED_EXPANDABLE,		/* type */
    free_hashed_expandable,		/* free */
    add_symbol_hashed_expandable,	/* add_symbol */
    iterator_first_hashed,		/* iterator_first */
    iterator_next_hashed,		/* iterator_next */
    iter_match_first_hashed,		/* iter_name_first */
    iter_match_next_hashed,		/* iter_name_next */
    size_hashed_expandable,		/* size */
  };

static const struct dict_vector dict_linear_vector =
  {
    DICT_LINEAR,			/* type */
    free_obstack,			/* free */
    add_symbol_nonexpandable,		/* add_symbol */
    iterator_first_linear,		/* iterator_first */
    iterator_next_linear,		/* iterator_next */
    iter_match_first_linear,		/* iter_name_first */
    iter_match_next_linear,		/* iter_name_next */
    size_linear,			/* size */
  };

static const struct dict_vector dict_linear_expandable_vector =
  {
    DICT_LINEAR_EXPANDABLE,		/* type */
    free_linear_expandable,		/* free */
    add_symbol_linear_expandable,	/* add_symbol */
    iterator_first_linear,		/* iterator_first */
    iterator_next_linear,		/* iterator_next */
    iter_match_first_linear,		/* iter_name_first */
    iter_match_next_linear,		/* iter_name_next */
    size_linear,			/* size */
  };

/* Declarations of helper functions (i.e. ones that don't go into
   vectors).  */

static struct symbol *iterator_hashed_advance (struct dict_iterator *iter);

static void insert_symbol_hashed (struct dictionary *dict,
				  struct symbol *sym);

static void expand_hashtable (struct dictionary *dict);

/* The creation functions.  */

/* Create a dictionary implemented via a fixed-size hashtable.  All
   memory it uses is allocated on OBSTACK; the environment is
   initialized from SYMBOL_LIST.  */

struct dictionary *
dict_create_hashed (struct obstack *obstack,
		    const struct pending *symbol_list)
{
  struct dictionary *retval;
  int nsyms = 0, nbuckets, i;
  struct symbol **buckets;
  const struct pending *list_counter;

  retval = obstack_alloc (obstack, sizeof (struct dictionary));
  DICT_VECTOR (retval) = &dict_hashed_vector;

  /* Calculate the number of symbols, and allocate space for them.  */
  for (list_counter = symbol_list;
       list_counter != NULL;
       list_counter = list_counter->next)
    {
      nsyms += list_counter->nsyms;
    }
  nbuckets = DICT_HASHTABLE_SIZE (nsyms);
  DICT_HASHED_NBUCKETS (retval) = nbuckets;
  buckets = obstack_alloc (obstack, nbuckets * sizeof (struct symbol *));
  memset (buckets, 0, nbuckets * sizeof (struct symbol *));
  DICT_HASHED_BUCKETS (retval) = buckets;

  /* Now fill the buckets.  */
  for (list_counter = symbol_list;
       list_counter != NULL;
       list_counter = list_counter->next)
    {
      for (i = list_counter->nsyms - 1; i >= 0; --i)
	{
	  insert_symbol_hashed (retval, list_counter->symbol[i]);
	}
    }

  return retval;
}

/* Create a dictionary implemented via a hashtable that grows as
   necessary.  The dictionary is initially empty; to add symbols to
   it, call dict_add_symbol().  Call dict_free() when you're done with
   it.  */

extern struct dictionary *
dict_create_hashed_expandable (void)
{
  struct dictionary *retval;

  retval = xmalloc (sizeof (struct dictionary));
  DICT_VECTOR (retval) = &dict_hashed_expandable_vector;
  DICT_HASHED_NBUCKETS (retval) = DICT_EXPANDABLE_INITIAL_CAPACITY;
  DICT_HASHED_BUCKETS (retval) = xcalloc (DICT_EXPANDABLE_INITIAL_CAPACITY,
					  sizeof (struct symbol *));
  DICT_HASHED_EXPANDABLE_NSYMS (retval) = 0;

  return retval;
}

/* Create a dictionary implemented via a fixed-size array.  All memory
   it uses is allocated on OBSTACK; the environment is initialized
   from the SYMBOL_LIST.  The symbols are ordered in the same order
   that they're found in SYMBOL_LIST.  */

struct dictionary *
dict_create_linear (struct obstack *obstack,
		    const struct pending *symbol_list)
{
  struct dictionary *retval;
  int nsyms = 0, i, j;
  struct symbol **syms;
  const struct pending *list_counter;

  retval = obstack_alloc (obstack, sizeof (struct dictionary));
  DICT_VECTOR (retval) = &dict_linear_vector;

  /* Calculate the number of symbols, and allocate space for them.  */
  for (list_counter = symbol_list;
       list_counter != NULL;
       list_counter = list_counter->next)
    {
      nsyms += list_counter->nsyms;
    }
  DICT_LINEAR_NSYMS (retval) = nsyms;
  syms = obstack_alloc (obstack, nsyms * sizeof (struct symbol *));
  DICT_LINEAR_SYMS (retval) = syms;

  /* Now fill in the symbols.  Start filling in from the back, so as
     to preserve the original order of the symbols.  */
  for (list_counter = symbol_list, j = nsyms - 1;
       list_counter != NULL;
       list_counter = list_counter->next)
    {
      for (i = list_counter->nsyms - 1;
	   i >= 0;
	   --i, --j)
	{
	  syms[j] = list_counter->symbol[i];
	}
    }

  return retval;
}

/* Create a dictionary implemented via an array that grows as
   necessary.  The dictionary is initially empty; to add symbols to
   it, call dict_add_symbol().  Call dict_free() when you're done with
   it.  */

struct dictionary *
dict_create_linear_expandable (void)
{
  struct dictionary *retval;

  retval = xmalloc (sizeof (struct dictionary));
  DICT_VECTOR (retval) = &dict_linear_expandable_vector;
  DICT_LINEAR_NSYMS (retval) = 0;
  DICT_LINEAR_EXPANDABLE_CAPACITY (retval)
    = DICT_EXPANDABLE_INITIAL_CAPACITY;
  DICT_LINEAR_SYMS (retval)
    = xmalloc (DICT_LINEAR_EXPANDABLE_CAPACITY (retval)
	       * sizeof (struct symbol *));

  return retval;
}

/* The functions providing the dictionary interface.  */

/* Free the memory used by a dictionary that's not on an obstack.  (If
   any.)  */

void
dict_free (struct dictionary *dict)
{
  (DICT_VECTOR (dict))->free (dict);
}

/* Add SYM to DICT.  DICT had better be expandable.  */

void
dict_add_symbol (struct dictionary *dict, struct symbol *sym)
{
  (DICT_VECTOR (dict))->add_symbol (dict, sym);
}

/* Utility to add a list of symbols to a dictionary.
   DICT must be an expandable dictionary.  */

void
dict_add_pending (struct dictionary *dict, const struct pending *symbol_list)
{
  const struct pending *list;
  int i;

  for (list = symbol_list; list != NULL; list = list->next)
    {
      for (i = 0; i < list->nsyms; ++i)
	dict_add_symbol (dict, list->symbol[i]);
    }
}

/* Initialize ITERATOR to point at the first symbol in DICT, and
   return that first symbol, or NULL if DICT is empty.  */

struct symbol *
dict_iterator_first (const struct dictionary *dict,
		     struct dict_iterator *iterator)
{
  return (DICT_VECTOR (dict))->iterator_first (dict, iterator);
}

/* Advance ITERATOR, and return the next symbol, or NULL if there are
   no more symbols.  */

struct symbol *
dict_iterator_next (struct dict_iterator *iterator)
{
  return (DICT_VECTOR (DICT_ITERATOR_DICT (iterator)))
    ->iterator_next (iterator);
}

struct symbol *
dict_iter_name_first (const struct dictionary *dict,
		      const char *name,
		      struct dict_iterator *iterator)
{
  return dict_iter_match_first (dict, name, strcmp_iw, iterator);
}

struct symbol *
dict_iter_name_next (const char *name, struct dict_iterator *iterator)
{
  return dict_iter_match_next (name, strcmp_iw, iterator);
}

struct symbol *
dict_iter_match_first (const struct dictionary *dict,
		       const char *name, symbol_compare_ftype *compare,
		       struct dict_iterator *iterator)
{
  return (DICT_VECTOR (dict))->iter_match_first (dict, name,
						 compare, iterator);
}

struct symbol *
dict_iter_match_next (const char *name, symbol_compare_ftype *compare,
		      struct dict_iterator *iterator)
{
  return (DICT_VECTOR (DICT_ITERATOR_DICT (iterator)))
    ->iter_match_next (name, compare, iterator);
}

int
dict_size (const struct dictionary *dict)
{
  return (DICT_VECTOR (dict))->size (dict);
}
 
/* Now come functions (well, one function, currently) that are
   implemented generically by means of the vtable.  Typically, they're
   rarely used.  */

/* Test to see if DICT is empty.  */

int
dict_empty (struct dictionary *dict)
{
  struct dict_iterator iter;

  return (dict_iterator_first (dict, &iter) == NULL);
}


/* The functions implementing the dictionary interface.  */

/* Generic functions, where appropriate.  */

static void
free_obstack (struct dictionary *dict)
{
  /* Do nothing!  */
}

static void
add_symbol_nonexpandable (struct dictionary *dict, struct symbol *sym)
{
  internal_error (__FILE__, __LINE__,
		  _("dict_add_symbol: non-expandable dictionary"));
}

/* Functions for DICT_HASHED and DICT_HASHED_EXPANDABLE.  */

static struct symbol *
iterator_first_hashed (const struct dictionary *dict,
		       struct dict_iterator *iterator)
{
  DICT_ITERATOR_DICT (iterator) = dict;
  DICT_ITERATOR_INDEX (iterator) = -1;
  return iterator_hashed_advance (iterator);
}

static struct symbol *
iterator_next_hashed (struct dict_iterator *iterator)
{
  struct symbol *next;

  next = DICT_ITERATOR_CURRENT (iterator)->hash_next;
  
  if (next == NULL)
    return iterator_hashed_advance (iterator);
  else
    {
      DICT_ITERATOR_CURRENT (iterator) = next;
      return next;
    }
}

static struct symbol *
iterator_hashed_advance (struct dict_iterator *iterator)
{
  const struct dictionary *dict = DICT_ITERATOR_DICT (iterator);
  int nbuckets = DICT_HASHED_NBUCKETS (dict);
  int i;

  for (i = DICT_ITERATOR_INDEX (iterator) + 1; i < nbuckets; ++i)
    {
      struct symbol *sym = DICT_HASHED_BUCKET (dict, i);
      
      if (sym != NULL)
	{
	  DICT_ITERATOR_INDEX (iterator) = i;
	  DICT_ITERATOR_CURRENT (iterator) = sym;
	  return sym;
	}
    }

  return NULL;
}

static struct symbol *
iter_match_first_hashed (const struct dictionary *dict, const char *name,
			 symbol_compare_ftype *compare,
			 struct dict_iterator *iterator)
{
  unsigned int hash_index = dict_hash (name) % DICT_HASHED_NBUCKETS (dict);
  struct symbol *sym;

  DICT_ITERATOR_DICT (iterator) = dict;

  /* Loop through the symbols in the given bucket, breaking when SYM
     first matches.  If SYM never matches, it will be set to NULL;
     either way, we have the right return value.  */
  
  for (sym = DICT_HASHED_BUCKET (dict, hash_index);
       sym != NULL;
       sym = sym->hash_next)
    {
      /* Warning: the order of arguments to compare matters!  */
      if (compare (SYMBOL_SEARCH_NAME (sym), name) == 0)
	{
	  break;
	}
	
    }

  DICT_ITERATOR_CURRENT (iterator) = sym;
  return sym;
}

static struct symbol *
iter_match_next_hashed (const char *name, symbol_compare_ftype *compare,
			struct dict_iterator *iterator)
{
  struct symbol *next;

  for (next = DICT_ITERATOR_CURRENT (iterator)->hash_next;
       next != NULL;
       next = next->hash_next)
    {
      if (compare (SYMBOL_SEARCH_NAME (next), name) == 0)
	break;
    }

  DICT_ITERATOR_CURRENT (iterator) = next;

  return next;
}

/* Insert SYM into DICT.  */

static void
insert_symbol_hashed (struct dictionary *dict,
		      struct symbol *sym)
{
  unsigned int hash_index;
  struct symbol **buckets = DICT_HASHED_BUCKETS (dict);

  hash_index = 
    dict_hash (SYMBOL_SEARCH_NAME (sym)) % DICT_HASHED_NBUCKETS (dict);
  sym->hash_next = buckets[hash_index];
  buckets[hash_index] = sym;
}

static int
size_hashed (const struct dictionary *dict)
{
  return DICT_HASHED_NBUCKETS (dict);
}

/* Functions only for DICT_HASHED_EXPANDABLE.  */

static void
free_hashed_expandable (struct dictionary *dict)
{
  xfree (DICT_HASHED_BUCKETS (dict));
  xfree (dict);
}

static void
add_symbol_hashed_expandable (struct dictionary *dict,
			      struct symbol *sym)
{
  int nsyms = ++DICT_HASHED_EXPANDABLE_NSYMS (dict);

  if (DICT_HASHTABLE_SIZE (nsyms) > DICT_HASHED_NBUCKETS (dict))
    expand_hashtable (dict);

  insert_symbol_hashed (dict, sym);
  DICT_HASHED_EXPANDABLE_NSYMS (dict) = nsyms;
}

static int
size_hashed_expandable (const struct dictionary *dict)
{
  return DICT_HASHED_EXPANDABLE_NSYMS (dict);
}

static void
expand_hashtable (struct dictionary *dict)
{
  int old_nbuckets = DICT_HASHED_NBUCKETS (dict);
  struct symbol **old_buckets = DICT_HASHED_BUCKETS (dict);
  int new_nbuckets = 2*old_nbuckets + 1;
  struct symbol **new_buckets = xcalloc (new_nbuckets,
					 sizeof (struct symbol *));
  int i;

  DICT_HASHED_NBUCKETS (dict) = new_nbuckets;
  DICT_HASHED_BUCKETS (dict) = new_buckets;

  for (i = 0; i < old_nbuckets; ++i)
    {
      struct symbol *sym, *next_sym;

      sym = old_buckets[i];
      if (sym != NULL) 
	{
	  for (next_sym = sym->hash_next;
	       next_sym != NULL;
	       next_sym = sym->hash_next)
	    {
	      insert_symbol_hashed (dict, sym);
	      sym = next_sym;
	    }

	  insert_symbol_hashed (dict, sym);
	}
    }

  xfree (old_buckets);
}

/* Produce an unsigned hash value from STRING0 that is consistent
   with strcmp_iw, strcmp, and, at least on Ada symbols, wild_match.
   That is, two identifiers equivalent according to any of those three
   comparison operators hash to the same value.  */

static unsigned int
dict_hash (const char *string0)
{
  /* The Ada-encoded version of a name P1.P2...Pn has either the form
     P1__P2__...Pn<suffix> or _ada_P1__P2__...Pn<suffix> (where the Pi
     are lower-cased identifiers).  The <suffix> (which can be empty)
     encodes additional information about the denoted entity.  This
     routine hashes such names to msymbol_hash_iw(Pn).  It actually
     does this for a superset of both valid Pi and of <suffix>, but 
     in other cases it simply returns msymbol_hash_iw(STRING0).  */

  const char *string;
  unsigned int hash;

  string = string0;
  if (*string == '_')
    {
      if (strncmp (string, "_ada_", 5) == 0)
	string += 5;
      else
	return msymbol_hash_iw (string0);
    }

  hash = 0;
  while (*string)
    {
      /* Ignore "TKB" suffixes.

	 These are used by Ada for subprograms implementing a task body.
	 For instance for a task T inside package Pck, the name of the
	 subprogram implementing T's body is `pck__tTKB'.  We need to
	 ignore the "TKB" suffix because searches for this task body
	 subprogram are going to be performed using `pck__t' (the encoded
	 version of the natural name `pck.t').  */
      if (strcmp (string, "TKB") == 0)
	return hash;

      switch (*string)
	{
	case '$':
	case '.':
	case 'X':
	  if (string0 == string)
	    return msymbol_hash_iw (string0);
	  else
	    return hash;
	case ' ':
	case '(':
	  return msymbol_hash_iw (string0);
	case '_':
	  if (string[1] == '_' && string != string0)
	    {
	      int c = string[2];

	      if ((c < 'a' || c > 'z') && c != 'O')
		return hash;
	      hash = 0;
	      string += 2;
	      break;
	    }
	  /* FALL THROUGH */
	default:
	  hash = SYMBOL_HASH_NEXT (hash, *string);
	  string += 1;
	  break;
	}
    }
  return hash;
}

/* Functions for DICT_LINEAR and DICT_LINEAR_EXPANDABLE.  */

static struct symbol *
iterator_first_linear (const struct dictionary *dict,
		       struct dict_iterator *iterator)
{
  DICT_ITERATOR_DICT (iterator) = dict;
  DICT_ITERATOR_INDEX (iterator) = 0;
  return DICT_LINEAR_NSYMS (dict) ? DICT_LINEAR_SYM (dict, 0) : NULL;
}

static struct symbol *
iterator_next_linear (struct dict_iterator *iterator)
{
  const struct dictionary *dict = DICT_ITERATOR_DICT (iterator);

  if (++DICT_ITERATOR_INDEX (iterator) >= DICT_LINEAR_NSYMS (dict))
    return NULL;
  else
    return DICT_LINEAR_SYM (dict, DICT_ITERATOR_INDEX (iterator));
}

static struct symbol *
iter_match_first_linear (const struct dictionary *dict,
			 const char *name, symbol_compare_ftype *compare,
			 struct dict_iterator *iterator)
{
  DICT_ITERATOR_DICT (iterator) = dict;
  DICT_ITERATOR_INDEX (iterator) = -1;

  return iter_match_next_linear (name, compare, iterator);
}

static struct symbol *
iter_match_next_linear (const char *name, symbol_compare_ftype *compare,
			struct dict_iterator *iterator)
{
  const struct dictionary *dict = DICT_ITERATOR_DICT (iterator);
  int i, nsyms = DICT_LINEAR_NSYMS (dict);
  struct symbol *sym, *retval = NULL;

  for (i = DICT_ITERATOR_INDEX (iterator) + 1; i < nsyms; ++i)
    {
      sym = DICT_LINEAR_SYM (dict, i);
      if (compare (SYMBOL_SEARCH_NAME (sym), name) == 0)
	{
	  retval = sym;
	  break;
	}
    }

  DICT_ITERATOR_INDEX (iterator) = i;
  
  return retval;
}

static int
size_linear (const struct dictionary *dict)
{
  return DICT_LINEAR_NSYMS (dict);
}

/* Functions only for DICT_LINEAR_EXPANDABLE.  */

static void
free_linear_expandable (struct dictionary *dict)
{
  xfree (DICT_LINEAR_SYMS (dict));
  xfree (dict);
}


static void
add_symbol_linear_expandable (struct dictionary *dict,
			      struct symbol *sym)
{
  int nsyms = ++DICT_LINEAR_NSYMS (dict);

  /* Do we have enough room?  If not, grow it.  */
  if (nsyms > DICT_LINEAR_EXPANDABLE_CAPACITY (dict))
    {
      DICT_LINEAR_EXPANDABLE_CAPACITY (dict) *= 2;
      DICT_LINEAR_SYMS (dict)
	= xrealloc (DICT_LINEAR_SYMS (dict),
		    DICT_LINEAR_EXPANDABLE_CAPACITY (dict)
		    * sizeof (struct symbol *));
    }

  DICT_LINEAR_SYM (dict, nsyms - 1) = sym;
}
@


1.25
log
@	* dictionary.c (dict_add_pending): New function.
	* dictionary.h (dict_add_pending): Declare.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2007-2012 Free Software Foundation, Inc.
@


1.24
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d501 16
@


1.23
log
@[Ada] Breakpoints on task bodies

Consider the following declaration:

    package Pck is
       task Dummy_Task is
          entry Start;
       end Dummy_Task;
    end Pck;

Inserting a breakpoint on the body of that task does not currently
work:

    (gdb) b pck.dummy_task
    "pck.dummy_task" is not a function
    Make breakpoint pending on future shared library load? (y or [n]) n

What happens here is that the compiler generates two symbols:

  (a) Symbol `pck__dummy_task' which is a *variable* referencing
      the task;

  (b) Symbol `pck__dummy_taskTKB' which is the subprogram implementing
      the body of the task.

The symbol lookup only finds the variable before of the TKB suffix in
the subprogram name. This patch fixes the problem by adjusting the
ada-lang.c:is_name_suffix routine to recognize "TKB" suffixes.  But
that's not enough, because the search in the symtab is performed via
the block dictionary, using a hashing algorithm. So, for the search
to find `pck__dummy_taskTKB', I had to modify the hashing function
to ignore TKB suffixes as well.

gdb/ChangeLog:

        * ada-lang.c (is_name_suffix): Add handling of "TKB" suffixes.
        Update function documentation.
        * dictionary.c (dict_hash): Ignore "TKB" suffixes in hash
        computation.

gdb/testsuite/ChangeLog:

        * gdb.ada/task_bp: New testcase.
@
text
@d3 1
a3 2
   Copyright (C) 2003, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.22
log
@gdb/
	Code cleanup.
	* dictionary.c (dict_hash): Use SYMBOL_HASH_NEXT.
	* dwarf2read.c (mapped_index_string_hash): Refer to SYMBOL_HASH_NEXT
	in the function comment, a new note on values compatibility.
	* minsyms.c (msymbol_hash_iw, msymbol_hash): Use SYMBOL_HASH_NEXT.
	* symtab.h (SYMBOL_HASH_NEXT): New.
@
text
@d804 11
@


1.22.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2003, 2007-2012 Free Software Foundation, Inc.
@


1.21
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d829 1
a829 1
	  hash = hash * 67 + *string - 113;
@


1.20
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d86 1
a86 3
   dict_<op> to dictionary.h.
   
*/
@


1.19
log
@run copyright.sh for 2011.
@
text
@d543 2
a544 1
  return (DICT_VECTOR (dict))->iter_match_first (dict, name, compare, iterator);
@


1.18
log
@gdb/
	Code cleanup.
	* dictionary.c
	(struct dict_vector) <iter_match_first, iter_match_next>
	(iter_match_first_hashed, iter_match_next_hashed)
	(iter_match_first_linear, iter_match_next_linear)
	(dict_iter_match_first, dict_iter_match_next, iter_match_first_hashed)
	(iter_match_next_hashed, iter_match_first_linear)
	(iter_match_next_linear): Use symbol_compare_ftype.
	* dictionary.h: Include symfile.h.
	(dict_iter_match_first, dict_iter_match_next): Use
	symbol_compare_ftype.
	* dwarf2read.c (dw2_map_matching_symbols): Likewise.
	* psymtab.c (match_partial_symbol, match_partial_symbol, map_block)
	(map_matching_symbols_psymtab): Likewise.
	* symfile.h (symbol_compare_ftype): New typedef.
	(struct quick_symbol_functions) <map_matching_symbols): Use
	symbol_compare_ftype.
@
text
@d3 2
a4 1
   Copyright (C) 2003, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.17
log
@avoid assignment inside if condition (dictionary.c)

This change gets rid of an ARI warning which was recently introduced
by one of our changes.

gdb/ChangeLog:

        * dictionary.c (dict_hash): Move assignment out of if condition.
@
text
@d121 3
a123 4
				     const char *name,
				     int (*equiv) (const char *,
						   const char *),
				     struct dict_iterator *iterator);
d125 1
a125 2
				     int (*equiv) (const char *,
						   const char *),
d244 1
a244 2
					       int (*compare) (const char *,
							       const char *),
d248 1
a248 2
					      int (*compare) (const char *,
							      const char *),
d276 1
a276 2
					       int (*compare) (const char *,
							       const char *),
d280 1
a280 2
					      int (*compare) (const char *,
							      const char *),
d539 1
a539 2
		       const char *name,
		       int (*compare) (const char *, const char *),
d546 1
a546 2
dict_iter_match_next (const char *name,
		      int (*compare) (const char *, const char *),
d641 2
a642 3
iter_match_first_hashed (const struct dictionary *dict,
			 const char *name,
			 int (*compare) (const char *, const char *),
d671 1
a671 2
iter_match_next_hashed (const char *name,
			int (*compare) (const char *, const char *),
d861 1
a861 2
			 const char *name,
			 int (*compare) (const char *, const char *),
d871 1
a871 2
iter_match_next_linear (const char *name,
			int (*compare) (const char *, const char *),
@


1.16
log
@Correct dict_hash to our most recent version.

Several changes to dict_hash from Adacore's local version were inadvertantly
left out of the last change to that function.  These changes conservatively
cause dict_hash to revert to msymbol_hash_iw in more cases where the symbol
being hashed is known not to be Ada-encoded.  This avoids a few cases where
the function hashes large groups of names with similar prefixes to the same
value.

Changelog:

	gdb/
	* dictionary.c (dict_hash): Revert to msymbol_hash_iw in
	more cases.
@
text
@a800 1
  int c;
d829 3
a831 1
	      if (((c = string[2]) < 'a' || c > 'z') && c != 'O')
@


1.15
log
@Extend hashed symbol dictionaries to work with Ada

This patch allows Ada to speed up symbol lookup by using the facilities
in dictionary.[ch] for hashed lookups.  First, we generalize dictionary
search to allow clients to specify any matching function compatible with
the hashing function. Next, we modify the hashing algorithm so that symbols
that wild-match a name hash to the same value.  Finally, we modify Ada
symbol lookup to use these facilities.

Because this patch touches on a hashing algorithm used by other
languages, I took the precaution of doing a speed test on a list of
about 12000 identifiers (repeatedly inserting all of them into a table
and then doing a lookup on a million names at random, thus testing the
speed of the hashing algorithm and how well it distributed names).
There was actually a slight speedup, probably as a result of open-
coding some of the tests in msymbol_hash_iw.  By design, the revised
hashing algorithm produces the same results as the original on most
"normal" C identifiers.

We considered augmenting the dictionary interface still further by allowing
different hashing algorithms for different dictionaries, based on the
(supposed) language of the symbols in that dictionary.  While this produced
better isolation of the changes to Ada programs, the additional flexibility
also complicated the dictionary interface.  I'd prefer to keep things
simple for now.

Tested w/o regressions on Linux i686.

ChangeLog:

	gdb/
	* ada-lang.c (ada_match_name): Use new API for wild_match.
	(wild_match): Change API to be consistent with that of strcmp_iw;
	return 0 for a match, and switch operand order.
	(full_match): New function.
	(ada_add_block_symbols): Use dict_iter_match_{first,next} for
	matching to allow use of hashing.
	* dictionary.c (struct dict_vector): Generalize iter_name_first,
	iter_name_next ot iter_match_first, iter_match_next.
	(iter_name_first_hashed): Replace with iter_match_first_hashed.
	(iter_name_next_hashed): Replace with iter_match_next_hashed.
	(iter_name_first_linear): Replace with iter_match_first_linear.
	(iter_name_next_linear): Replace with iter_match_next_linear.
	(dict_iter_name_first): Re-implement to use dict_iter_match_first.
	(dict_iter_name_next): Re-implement to use dict_iter_match_next.
	(dict_iter_match_first): New function.
	(dict_iter_match_next): New function.
	(dict_hash): New function.
	* dictionary.h (dict_iter_match_first, dict_iter_match_next): Declare.
	* psymtab.c (ada_lookup_partial_symbol): Use new wild_match API.
@
text
@d789 1
a789 1
dict_hash (const char *string)
d799 1
d803 8
a810 2
  if (*string == '_' && strncmp (string, "_ada_", 5) == 0)
    string += 5;
d820 5
d826 1
a826 4
	  return hash;
	case ' ':
	  string += 1;
	  break;
d828 1
a828 1
	  if (string[1] == '_')
@


1.14
log
@2010-05-13  Michael Snyder  <msnyder@@vmware.com>

	* dictionary.c: Re-indent to GNU coding standard.
@
text
@d24 1
d120 1
a120 1
  struct symbol *(*iter_name_first) (const struct dictionary *dict,
d122 6
a128 2
  struct symbol *(*iter_name_next) (const char *name,
				    struct dict_iterator *iterator);
d244 4
a247 2
static struct symbol *iter_name_first_hashed (const struct dictionary *dict,
					      const char *name,
d250 6
a255 2
static struct symbol *iter_name_next_hashed (const char *name,
					     struct dict_iterator *iterator);
d278 9
a286 2
static struct symbol *iter_name_first_linear (const struct dictionary *dict,
					      const char *name,
a288 3
static struct symbol *iter_name_next_linear (const char *name,
					     struct dict_iterator *iterator);

d307 2
a308 2
    iter_name_first_hashed,		/* iter_name_first */
    iter_name_next_hashed,		/* iter_name_next */
d319 2
a320 2
    iter_name_first_hashed,		/* iter_name_first */
    iter_name_next_hashed,		/* iter_name_next */
d331 2
a332 2
    iter_name_first_linear,		/* iter_name_first */
    iter_name_next_linear,		/* iter_name_next */
d343 2
a344 2
    iter_name_first_linear,		/* iter_name_first */
    iter_name_next_linear,		/* iter_name_next */
d534 1
a534 1
  return (DICT_VECTOR (dict))->iter_name_first (dict, name, iterator);
d540 17
d558 1
a558 1
    ->iter_name_next (name, iterator);
d649 4
a652 3
iter_name_first_hashed (const struct dictionary *dict,
			const char *name,
			struct dict_iterator *iterator)
d654 1
a654 2
  unsigned int hash_index
    = msymbol_hash_iw (name) % DICT_HASHED_NBUCKETS (dict);
d667 2
a668 2
      /* Warning: the order of arguments to strcmp_iw matters!  */
      if (strcmp_iw (SYMBOL_SEARCH_NAME (sym), name) == 0)
d680 3
a682 1
iter_name_next_hashed (const char *name, struct dict_iterator *iterator)
d690 1
a690 1
      if (strcmp_iw (SYMBOL_SEARCH_NAME (next), name) == 0)
d708 2
a709 2
  hash_index = (msymbol_hash_iw (SYMBOL_SEARCH_NAME (sym))
		% DICT_HASHED_NBUCKETS (dict));
d783 54
d860 4
a863 3
iter_name_first_linear (const struct dictionary *dict,
			const char *name,
			struct dict_iterator *iterator)
d868 1
a868 1
  return iter_name_next_linear (name, iterator);
d872 3
a874 1
iter_name_next_linear (const char *name, struct dict_iterator *iterator)
d883 1
a883 1
      if (strcmp_iw (SYMBOL_SEARCH_NAME (sym), name) == 0)
@


1.13
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* linespec.c (decode_compound): Delete unused variable.
	* dictionary.c (iterator_next_hashed): Delete unused variable.
	* infcall.c (call_function_by_hand): Delete unused variable.
	* infcmd.c (step_1): Delete unused variable.
	(registers_info): Delete unused variable.
	(attach_command): Delete unused variable.
	* infrun.c (follow_exec): Delete unused variable.
	(handle_step_into_function_backwards): Delete unused variable.
	(_initialize_infrun): Delete unused variable.
	* stack.c (parse_frame_specification_1): Delete unused variable.
	(frame_info): Delete unused variable.
	(backtrace_command_1): Delete unused variable.
	(catch_info): Delete unused variable.
@
text
@d727 3
a729 2
  for (i = 0; i < old_nbuckets; ++i) {
    struct symbol *sym, *next_sym;
d731 10
a740 8
    sym = old_buckets[i];
    if (sym != NULL) {
      for (next_sym = sym->hash_next;
	   next_sym != NULL;
	   next_sym = sym->hash_next) {
	insert_symbol_hashed (dict, sym);
	sym = next_sym;
      }
d742 2
a743 1
      insert_symbol_hashed (dict, sym);
a744 1
  }
d827 8
a834 7
  if (nsyms > DICT_LINEAR_EXPANDABLE_CAPACITY (dict)) {
    DICT_LINEAR_EXPANDABLE_CAPACITY (dict) *= 2;
    DICT_LINEAR_SYMS (dict)
      = xrealloc (DICT_LINEAR_SYMS (dict),
		  DICT_LINEAR_EXPANDABLE_CAPACITY (dict)
		  * sizeof (struct symbol *));
  }
@


1.12
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a580 1
  const struct dictionary *dict = DICT_ITERATOR_DICT (iterator);
@


1.11
log
@gdb/
	* dictionary.c (dict_hashed_vector, dict_hashed_expandable_vector)
	(dict_linear_vector, dict_linear_expandable_vector): Fix a comment typo.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.10
log
@        Updated copyright notices for most files.
@
text
@d290 1
a290 1
    iterator_first_hashed,		/* iteractor_first */
d302 1
a302 1
    iterator_first_hashed,		/* iteractor_first */
d314 1
a314 1
    iterator_first_linear,		/* iteractor_first */
d326 1
a326 1
    iterator_first_linear,		/* iteractor_first */
@


1.9
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2007, 2008 Free Software Foundation, Inc.
@


1.8
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2007 Free Software Foundation, Inc.
@


1.7
log
@Copyright updates for 2007.
@
text
@d12 2
a13 2
   the Free Software Foundation; either version 2 of the License, or (at
   your option) any later version.
d15 4
a18 4
   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.6
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 1
a3 1
   Copyright (C) 2003 Free Software Foundation, Inc.
@


1.5
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d3 1
a3 1
   Copyright 2003 Free Software Foundation, Inc.
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.4
log
@2004-06-02  Albert Chin-A-Young  <china@@thewrittenword.com>

	Committed by Andrew Cagney.
	* gdb/dictionary.c, gdb/gdbtypes.h: Remove trailing comma
	after last enum constant to avoid error from IBM C
	compiler.
@
text
@d566 1
a566 1
		  "dict_add_symbol: non-expandable dictionary");
@


1.3
log
@* symtab.h (SYMBOL_SEARCH_NAME): New definition.
(SYMBOL_MATCHES_SEARCH_NAME): New definition.
(symbol_search_name): Declare.

* dictionary.c (iter_name_first_hashed): Match on SYMBOL_SEARCH_NAME.
(iter_name_next_hashed): Ditto.
(iter_name_next_linear): Ditto.
(insert_symbol_hashed): Hash on SYMBOL_SEARCH_NAME.

* symtab.c (lookup_partial_symbol): Assume symbols ordered by
search name, using SYMBOL_SEARCH_NAME and SYMBOL_MATCHES_SEARCH_NAME.
(symbol_search_name): New function.

* symfile.c (compare_psymbols): Order by SYMBOL_SEARCH_NAME.

* minsyms.c (build_minimal_symbol_hash_tables): Change
test for adding to demangled hash table to check for difference
between SYMBOL_SEARCH_NAME and SYMBOL_LINKAGE_NAME.
@
text
@d102 1
a102 1
    DICT_LINEAR_EXPANDABLE,
@


1.2
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* dictionary.h: New.
	* dictionary.c: New.
	* block.h: Add opaque declaration for struct dictionary.
	(struct block): Add 'dict' member; delete 'hashtable', 'nsyms',
	'sym' members.
	(BLOCK_DICT): New macro.
	Delete macros BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM,
	BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE,
	BLOCK_SHOULD_SORT.
	(ALL_BLOCK_SYMBOLS): Update definition.
	* Makefile.in (SFILES): Add dictionary.c.
	(dictionary_h): New.
	(COMMON_OBS): Add dictionary.o.
	(dictionary.o): New.
	(ada-lang.o): Depend on dictionary_h.
	(buildsym.o, coffread.o, jv-lang.o, mdebugread.o, objfiles.o)
	(stack.o, symmisc.o, symtab.o, tracepoint.o, valops.o)
	(mi-cmd-stack.o): Ditto.
	(gdbtk-cmds.o): Update dependencies.
	(gdbtk-stack.o): Ditto.
	* ada-lang.c: Include dictionary.h.
	(symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Ditto.
	(ada_add_block_symbols): Update uses of ALL_BLOCK_SYMBOLS; replace
	explicit iteration by use of ALL_BLOCK_SYMBOLS.  Delete variable
	'is_sorted'.
	* mdebugread.c: Include dictionary.h.
	(struct parse_stack): Delete 'maxsyms' member.
	(parse_symbol): Update calls to new_block.  Delete calls to
	shrink_block.  Use dictionary methods.
	(psymtab_to_symtab_1): Delete calls to sort_symtab_syms.
	Update calls to new_symtab.  Don't maintain maxsyms data.
	(mylookup_symbol): Update use of ALL_BLOCK_SYMBOLS.
	(add_symbol): Just call dict_add_symbol.
	(new_symtab): Delete 'maxsyms' argument.
	(new_symtab): Update calls to new_block.
	(new_block): Delete 'maxsyms' argument; add 'function' argument.
	(shrink_block): Delete function.
	(fixup_sigtramp): Update call to new_block.  Add symbol via
	dict_add_symbol.
	* jv-lang.c: Include dictionary.h.
	(get_java_class_symtab): Set the BLOCK_DICT of the blocks
	appropriately.  Set class_symtab->free_func.  Make sure the
	blockvector is big enough to hold two blocks.
	(add_class_symtab_symbol): Use dictionary methods.
	(free_class_block): New function.
	(type_from_class): Replace explicit iteration by
	ALL_BLOCK_SYMBOLS.
	* symtab.h (struct symtab): Replace 'free_ptr' method by
	'free_func'.
	* dwarf2read.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* dwarfread.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Delete call to sort_symtab_syms.
	Include dictionary.h.
	(patch_opaque_types): Update use of ALL_BLOCK_SYMBOLS.
	* dbxread.c (dbx_psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* objfiles.c: Include dictionary.h.
	(objfile_relocate): Update use of ALL_BLOCK_SYMBOLS.
	* buildsym.c: Include dictionary.h.
	(finish_block): Use dictionary methods.
	(end_symtab): Set free_func to NULL, not free_ptr.
	* tracepoint.c: Include dictionary.h.
	(add_local_symbols): Update use of ALL_BLOCK_SYMBOLS.
	(scope_info): Ditto.
	* stack.c: Include dictionary.h.
	(print_block_frame_locals): Update use of ALL_BLOCK_SYMBOLS.
	(print_block_frame_labels, print_frame_arg_vars)
	(print_frame_args): Ditto.
	* symmisc.c (free_symtab_block): Use dictionary methods.
	(dump_symtab): Ditto.
	(free_symtab): Replace use of 'free_ptr' by 'free_func'.
	Include	dictionary.h.
	* symfile.h: Delete declarations of sort_block_syms,
	sort_symtab_syms.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Delete.
	* symtab.c: Include dictionary.h.
	(lookup_block_symbol): Use dictionary iterators.
	(find_pc_sect_symtab): Update use of ALL_BLOCK_SYMBOLS.
	(search_symbols, make_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* valops.c (value_of_local): Use dict_empty.
	Include dictionary.h.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* generic/gdbtk-stack.c: Include dictionary.h.
	(gdb_block_vars): Update use of ALL_BLOCK_SYMBOLS.
	(gdb_get_blocks, gdb_get_vars_command): Ditto.
	* generic/gdbtk-cmds.c: Include dictionary.h.
	(gdb_listfuncs): Update use of ALL_BLOCK_SYMBOLS.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* mi-cmd-stack.c: Include dictionary.h.
	(list_args_or_locals): Update use of ALL_BLOCK_SYMBOLS.
@
text
@d639 1
a639 1
      if (strcmp_iw (SYMBOL_NATURAL_NAME (sym), name) == 0)
d659 1
a659 1
      if (strcmp_iw (SYMBOL_NATURAL_NAME (next), name) == 0)
d677 1
a677 1
  hash_index = (msymbol_hash_iw (SYMBOL_NATURAL_NAME (sym))
d792 1
a792 1
      if (strcmp_iw (SYMBOL_NATURAL_NAME (sym), name) == 0)
@


1.2.18.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d102 1
a102 1
    DICT_LINEAR_EXPANDABLE
d639 1
a639 1
      if (strcmp_iw (SYMBOL_SEARCH_NAME (sym), name) == 0)
d659 1
a659 1
      if (strcmp_iw (SYMBOL_SEARCH_NAME (next), name) == 0)
d677 1
a677 1
  hash_index = (msymbol_hash_iw (SYMBOL_SEARCH_NAME (sym))
d792 1
a792 1
      if (strcmp_iw (SYMBOL_SEARCH_NAME (sym), name) == 0)
@


1.2.20.1
log
@2004-06-02  Albert Chin-A-Young  <china@@thewrittenword.com>

	Committed by Andrew Cagney.
	* gdb/dictionary.c, gdb/gdbtypes.h: Remove trailing comma
	after last enum constant to avoid error from IBM C
	compiler.
@
text
@d102 1
a102 1
    DICT_LINEAR_EXPANDABLE
@


1.2.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.1
log
@file dictionary.c was initially added on branch carlton_dictionary-branch.
@
text
@d1 836
@


1.1.2.1
log
@2002-09-20  David Carlton  <carlton@@math.stanford.edu>

	* jv-lang.c (get_java_class_symtab): Use xmalloc to allocate
	GLOBAL_BLOCK rather than xmmalloc.
	(free_class_block): Use xfree rather than xmfree.
	* mdebugread.c: #include "dictionary.h"
	(new_block): Remove argument.  Initialize BLOCK_DICT.
	(parse_symbol): Update call to new_block.
	(new_symtab): Ditto.
	(fixup_sigtramp): Ditto.
	Delete MAXSYMS member of struct parse_stack.
	(psymtab_to_symtab_1): Don't set maxsyms.
	(new_symtab): Remove maxsyms argument.
	(psymtab_to_symtab_1): Update call to new_symtab.
	(shrink_block): Delete function.
	(add_symbol): Add symbols via dict_add_symbol_block.
	* jv-lang.c (add_class_symtab_symbol): Add symbols via
	dict_add_symbol_block.
	Delete variable class_symtab_space.
	* Makefile.in (jv-lang.o): Add dictionary_h.
	* jv-lang.c: #include "dictionary.h"
	* symmisc.c (free_symtab): Call free_func rather than freeing free_ptr.
	* jv-lang.c (get_java_class_symtab): Initialize free_func rather
	than free_ptr.
	(free_class_block): New function.
	(add_class_symtab_symbol): Delete reference to free_ptr.
	* buildsym.c (end_symtab): Initialize free_func rather than free_ptr.
	* symtab.h (struct symtab): Replace free_ptr by free_func.
	* jv-lang.c (get_java_class_symtab): Add DICT_BLOCK assignments.
	* Makefile.in (buildsym.o): Add dictionary_h.
	* buildsym.c (finish_block): Initialize BLOCK_DICT (block).
	#include "dictionary.h"
	* symtab.h (struct block): Add 'dict' member.
	(BLOCK_DICT): New macro.
	* dictionary.c: New file.
	* dictionary.h: New file.
	* Makefile.in (SFILES): Add dictionary.c
	(dictionary_h): New variable.
	(COMMON_OBS): Add dictionary.o.
	(dictionary.o): New rule.
	(carlton): New rule.
@
text
@a0 215
/* Routines for name->symbol lookups in GDB.
   
   Copyright 2002 Free Software Foundation, Inc.

   Contributed by David Carlton <carlton@@bactrian.org>.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or (at
   your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "dictionary.h"
#include "gdb_obstack.h"
#include "symtab.h"
#include "buildsym.h"
#include "gdb_assert.h"

/* This file implements dictionaries, which are tables that associate
   symbols to names.  They are represented by an opaque type 'struct
   dictionary'.  That type has various internal implementations, which
   you can choose between depending on what properties you need
   (e.g. fast lookup, order-preserving, expandable).

   Each dictionary starts with a 'virtual function table' that
   contains the functions that actually implement the various
   operations that dictionaries provide.  */

/* NOTE: carlton/2002-09-20: Originally, I'd had each dictionary start
   with a dict_type member, and had implemented the various functions
   via big switch statements.  But that led to some really large
   functions, and might cause problems in the future (e.g. if I were
   to provide two different allocators for a single type that either
   allocate using obstacks or using xfree(), then we'd have to expand
   the number of dict_types to get dict_free() to work), so I'm going
   with dict_vtbl instead.  I left the dict_type in the dict_vtbl,
   but it's never used: it's just there to make debugging a bit
   easier.  */

/* An enum representing the various implementations of dictionaries.
   Used only for debugging.  */

enum dict_type
  {
    /* Symbols are stored in a (fixed-size) hash table.  */
    DICT_HASHED,
    /* Symbols are stored in a (fixed-size) array.  */
    DICT_LINEAR,
    /* Symbols are stored in an expandable array.  */
    DICT_LINEAR_EXPANDABLE,
    /* Symbols are stored in a fixed-size block.  */
    DICT_BLOCK,
    /* Symbols are stored in an expandable block.  */
    DICT_BLOCK_EXPANDABLE,
  };

/* The virtual function table.  */

struct dict_vtbl
{
  /* The type of the dictionary.  This is only here to make debugging
     a bit easier; it's not actually used.  */
  enum dict_type type;
  /* The function to free a dictionary.  */
  void (*free)(struct dictionary *);
};

/* Now comes the structs used to store the data for different
   implementations.  If two implementations have data in common, put
   the common data at the top of their structs, ordered in the same
   way.  */

struct dictionary_block
{
  struct block *block;
};

struct dictionary_block_expandable
{
  struct block *block;
  unsigned int maxsyms;
};

/* And now, the star of our show.  */

struct dictionary
{
  const struct dict_vtbl *vtbl;
  union
  {
    struct dictionary_block block;
    struct dictionary_block_expandable block_expandable;
  }
  data;
};

/* Accessor macros.  */

#define DICT_VTBL(d)			(d)->vtbl

/* This can be used for block_expandables, too.  */

#define DICT_BLOCK_BLOCK(d)		(d)->data.block.block

#define DICT_BLOCK_EXPANDABLE_MAXSYMS(d) (d)->data.block_expandable.maxsyms


#define DICT_BLOCK_EXPANDABLE_INITIAL_MAXSYMS 10

/* Declarations of functions for vtbls.  */

static void dict_free_block(struct dictionary *dict);

/* Various vtbls that we'll actually use.  */

const struct dict_vtbl dict_block_vtbl =
  {
    DICT_BLOCK, dict_free_block,
  };

const struct dict_vtbl dict_block_expandable_vtbl =
  {
    DICT_BLOCK_EXPANDABLE, dict_free_block,
  };

/* The creation functions.  */

/* Allocate a dictionary in which symbol lookup is implemented via
   BLOCK.  Needs to be freed by dict_free; I won't worry about that,
   however, since this will go away soon.  */
struct dictionary *
dict_create_block (struct block *block)
{
  struct dictionary *retval = xmalloc (sizeof (struct dictionary));

  DICT_VTBL (retval) = &dict_block_vtbl;
  DICT_BLOCK_BLOCK (retval) = block;

  return retval;
}

struct dictionary *
dict_create_block_expandable (struct block *block)
{
  struct dictionary *retval = xmalloc (sizeof (struct dictionary));

  DICT_VTBL (retval) = &dict_block_expandable_vtbl;
  DICT_BLOCK_BLOCK (retval) = block;
  /* We'll resize the block the first time we add a symbol to it.  */
  DICT_BLOCK_EXPANDABLE_MAXSYMS (retval) = 0;

  return retval;
}

/* The functions providing the dictionary interface.  */

void
dict_free (struct dictionary *dict)
{
  (DICT_VTBL (dict))->free (dict);
}

/* The functions implementing the dictionary interface.  */

/* First, for DICT_BLOCK and DICT_BLOCK_EXPANDABLE.  */

static void
dict_free_block (struct dictionary *dict)
{
  xfree (dict);
}

/* A special-case function for DICT_BLOCK_EXPANDABLE.  */

/* FIXME: carlton/2002-09-20: But some callers use xmmalloc!!!
   Crap.  */

struct block *
dict_add_symbol_block (struct dictionary *dict, struct symbol *sym)
{
  gdb_assert ((DICT_VTBL (dict))->type == DICT_BLOCK_EXPANDABLE);

  struct block *block = DICT_BLOCK_BLOCK (dict);

  if (++BLOCK_NSYMS (block) > DICT_BLOCK_EXPANDABLE_MAXSYMS (dict))
    {
      if (DICT_BLOCK_EXPANDABLE_MAXSYMS (dict))
	DICT_BLOCK_EXPANDABLE_MAXSYMS (dict) *= 2;
      else
	DICT_BLOCK_EXPANDABLE_MAXSYMS (dict)
	  = DICT_BLOCK_EXPANDABLE_INITIAL_MAXSYMS;

      block = xrealloc (block,
			sizeof (struct block)
			+ ((DICT_BLOCK_EXPANDABLE_MAXSYMS (dict) -1)
			   * sizeof (struct symbol)));
      DICT_BLOCK_BLOCK (dict) = block;
    }

  BLOCK_SYM (block, BLOCK_NSYMS (block) - 1) = sym;

  return block;
}
@


1.1.2.2
log
@2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c (struct dict_vtbl): 'add_symbol' field.
	(add_symbol_generic): New function.
	(free_obstack): New function.
	(dict_create_hashed): New function.
	(lookup_hashed): New function.
	(iterator_first_hashed): New function.
	(iterator_hashed_advance): New function.
	(iterator_next_hashed): New function.
	* dictionary.h: A few more declarations.
	* mdebugread.c (parse_symbol): Use dict_iterator when finding
	parameters.
	* Makefile.in (valops.o): Depend on dictionary_h.
	* valops.c (value_of_this): Check empty block via dict_empty.
	#include "dictionary.h"
	* symfile.c (free_named_symtabs): Check empty block via dict_empty.
	* dictionary.h: Declare dict_empty.
	* symmisc.c (dump_symtab): Don't print out number of
	symbols/buckets.
	* printcmd.c (print_frame_args): Delete assertion that block isn't
	a hashtable.
	* symmisc.c (free_symtab_block): Update to use dictionary
	methods.
	* symtab.h (struct symtab): Comment on free_contents.
	* jv-lang.c (get_java_class_symtab): Set class_symtab->free_code.
	* mdebugread.c (add_symbol): Delete 'nsyms' variable.
	(fixup_sigtramp): Add symbol via dict_add_symbol_block.
	* Makefile.in (mi-cmd-stack.o): Depend on dictionary_h.
	* ada-lang.c (symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(ada_add_block_symbols): Ditto.
	(debug_print_block): Ditto.
	(fill_in_ada_prototype): Ditto.
	* breakpoint.c (get_catch_sals): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	(scope_info): Ditto.
	* symtab.c (find_pc_sect_symtab): Ditto.
	(search_symbols): Ditto.
	(make_symbol_completion_list): Ditto.
	(find_addr_symbol): Ditto.
	(make_file_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* symmisc.c (dump_symtab): Ditto.
	* stack.c (print_block_frame_locals): Ditto.
	(print_block_frame_labels): Ditto.
	(print_frame_arg_vars): Ditto.
	* printcmd.c (print_frame_args): Ditto.
	* objfiles.c (objfile_relocate): Ditto.
	* mdebugread.c (mylookup_symbol): Ditto.
	* Makefile.in (ada-lang.o): Depend on dictionary_h.
	* Makefile.in (tracepoint.o): Ditto.
	* Makefile.in (symmisc.o): Ditto.
	* Makefile.in (stack.o): Ditto.
	* Makefile.in (printcmd.o): Ditto.
	* Makefile.in (objfiles.o): Ditto.
	* Makefile.in (coffread.o): Ditto.
	* Makefile.in (breakpoint.o): Ditto.
	* ada-lang.c: #include "dictionary.h"
	* tracepoint.c: Ditto.
	* symmisc.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* coffread.c: Ditto.
	* breakpoint.c: Ditto.
	* symtab.h: Comment out ALL_BLOCK_SYMBOLS.  (Moved to
	dictionary.h.)
	* dictionary.c: Dict_iterator accessor macros.
	(struct dict_vtbl): Add iterator_first, iterator_next.
	(dict_iterator_first): New function.
	(dict_iterator_next): New function.
	(iterator_first_block): New function.
	(iterator_next_block): New function.
	(iterator_block_hashed_advance): New function.
	* dictionary.h: Add dict_iterator stuff.
	* Makefile.in (symtab.o): Depend on dictionary_h.
	* symtab.c: #include "dictionary.h"
	* dictionary.c: Move down #include "dictionary.h", for now...
	(free_block): Rename from dict_free_block.
	(struct dict_vtbl): Add LOOKUP member.
	(dict_lookup): New function.
	(lookup_block): New function.
	* dictionary.h: Declare dict_lookup.
	* symtab.c (lookup_block_symbol): Use dict_lookup.

2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c (list_args_or_locals): Update use of
	ALL_BLOCK_SYMBOLS.
	#include "dictionary.h"
@
text
@d25 1
a29 1
#include "dictionary.h"
d77 1
a77 11
  void (*free) (struct dictionary *dict);
  /* The symbol lookup function.  */
  struct symbol *(*lookup) (const struct dictionary *dict,
			    const char *name,
			    const char *mangled_name,
			    const namespace_enum namespace);
  /* Iterator functions.  */
  struct symbol *(*iterator_first) (const struct dictionary *dict,
				    struct dict_iterator *iterator);
  struct symbol *(*iterator_next) (struct dict_iterator *iterator);
  void (*add_symbol) (struct dictionary *dict, struct symbol *sym);
a84 6
struct dictionary_hashed
{
  int nbuckets;
  struct symbol **buckets;
};

a102 1
    struct dictionary_hashed hashed;
a112 4
#define DICT_HASHED_NBUCKETS(d)		(d)->data.hashed.nbuckets
#define DICT_HASHED_BUCKETS(d)		(d)->data.hashed.buckets
#define DICT_HASHED_BUCKET(d,i)		DICT_HASHED_BUCKETS (d) [i]

a118 27
/* The initial size of a DICT_HASHED dictionary.  */

#define DICT_HASHED_INITIAL_MAXSYMS 10
#define DICT_BLOCK_EXPANDABLE_INITIAL_MAXSYMS DICT_HASHED_INITIAL_MAXSYMS

/* This calculates the number of buckets we'll use in a hashtable,
   given the number of symbols that it will contain.  */

#define DICT_HASHTABLE_SIZE(n)	((n)/5 + 1)

/* Accessor macros for dict_iterators; they're here rather than
   dictionary.h because code elsewhere should treat dict_iterators as
   opaque.  */

/* The dictionary that the iterator is associated to.  */
#define DICT_ITERATOR_DICT(iter)		(iter)->dict
/* For linear dictionaries, the index of the last symbol returned; for
   hashed dictionaries, the bucket of the last symbol returned.  */
#define DICT_ITERATOR_INDEX(iter)		(iter)->index
/* For hashed dictionaries, this points to the last symbol returned;
   otherwise, this is unused.  */
#define DICT_ITERATOR_CURRENT(iter)		(iter)->current

/* Functions to handle some of the common code in dict_iterator_first and
   dict_iterator_next.  */

static struct symbol *iterator_hashed_advance (struct dict_iterator *iter);
d120 1
a120 2
static struct symbol *iterator_block_hashed_advance (struct dict_iterator
						     *iter);
d124 1
a124 33
/* Functions that might work across a range of dictionary types.  */

static void add_symbol_nonexpandable (struct dictionary *dict,
				      struct symbol *sym);

static void free_obstack (struct dictionary *dict);

/* Functions for DICT_HASHED dictionaries.  */

static struct symbol *lookup_hashed (const struct dictionary *dict,
				     const char *name,
				     const char *mangled_name,
				     const namespace_enum namespace);

static struct symbol *iterator_first_hashed (const struct dictionary *dict,
					     struct dict_iterator *iterator);

static struct symbol *iterator_next_hashed (struct dict_iterator *iterator);

/* Functions for blocks.  */

static struct symbol *lookup_block (const struct dictionary *dict,
				    const char *name,
				    const char *mangled_name,
				    const namespace_enum namespace);


static void free_block(struct dictionary *dict);

static struct symbol *iterator_first_block (const struct dictionary *dict,
					    struct dict_iterator *iterator);

static struct symbol *iterator_next_block (struct dict_iterator *iterator);
a127 6
const struct dict_vtbl dict_hashed_vtbl =
  {
    DICT_HASHED, free_obstack, lookup_hashed, iterator_first_hashed,
    iterator_next_hashed, add_symbol_nonexpandable,
  };

d130 1
a130 2
    DICT_BLOCK, free_block, lookup_block, iterator_first_block,
    iterator_next_block, add_symbol_nonexpandable,
d135 1
a135 2
    DICT_BLOCK_EXPANDABLE, free_block, lookup_block, iterator_first_block,
    iterator_next_block, add_symbol_nonexpandable,
a139 75
/* Create a dictionary implemented via a fixed-size hashtable.  All
   memory it uses is allocated on OBSTACK; the environment is
   initialized from SYMBOL_LIST.  */

struct dictionary *
dict_create_hashed (struct obstack *obstack,
		    const struct pending *symbol_list)
{
  struct dictionary *retval;
  int nsyms, nbuckets, i;
  struct symbol **buckets;
  const struct pending *list_counter;

  retval = obstack_alloc (obstack, sizeof (struct dictionary));
  DICT_VTBL (retval) = &dict_hashed_vtbl;

  /* Calculate the number of symbols, and allocate space for them.  */
  for (nsyms = 0, list_counter = symbol_list;
       list_counter != NULL;
       nsyms += list_counter->nsyms, list_counter = list_counter->next)
    {
      /* EMPTY */ ;
    }
  nbuckets = DICT_HASHTABLE_SIZE (nsyms);
  DICT_HASHED_NBUCKETS (retval) = nbuckets;
  buckets = obstack_alloc (obstack, nbuckets * sizeof (struct symbol *));
  memset (buckets, 0, nbuckets * sizeof (struct symbol *));
  DICT_HASHED_BUCKETS (retval) = buckets;

  /* Now fill the buckets.  */
  for (list_counter = symbol_list;
       list_counter != NULL;
       list_counter = list_counter->next)
    {
      for (i = list_counter->nsyms - 1; i >= 0; --i)
	{
	  struct symbol *sym = list_counter->symbol[i];
	  unsigned int hash_index;
	  const char *name = SYMBOL_DEMANGLED_NAME (sym);
	  if (name == NULL)
	    name = SYMBOL_NAME (sym);
	  hash_index = msymbol_hash_iw (name) % nbuckets;
	  sym->hash_next = buckets[hash_index];
	  buckets[hash_index] = sym;
	}
    }

  return retval;
}

#if 0
/* Create a dictionary implemented via a fixed-size array.  All memory
   it uses is allocated on OBSTACK; the environment is initialized
   from the SYMBOL_LIST.  The symbols are ordered in the same order
   that they're found in SYMBOL_LIST.  */

struct dictionary *
dict_create_linear (struct obstack *obstack,
		    const struct pending *symbol_list)

/* Create a dictionary implemented via an array that grows as
   necessary.  The dictionary is initially empty; to add symbols to
   it, call dict_add_symbol().  Call dict_free() when you're done with
   it.  */

/* FIXME: carlton/2002-09-11: This environment type exists only to
   make mdebugread.c and jv-lang.c happy.  The former should be
   converted over to the buildsym.c mechanisms (or made obsolete, I
   suggest in an excess of optimism); the latter should perhaps be
   rethought.  */

struct dictionary *
dict_create_linear_expandable (void)
#endif

a142 1

a168 3
/* Free the memory used by a dictionary that's not on an obstack.  (If
   any.)  */

a174 59
/* Search DICT for symbol NAME in NAMESPACE.

   If MANGLED_NAME is non-NULL, verify that any symbol we find has this
   particular mangled name.
*/

/* FIXME: carlton/2002-09-23: namespace_enum is a typedef in
   symtab.h...  */

struct symbol *
dict_lookup (const struct dictionary *dict,
	     const char *name,
	     const char *mangled_name,
	     const namespace_enum namespace)
{
  return (DICT_VTBL (dict))->lookup (dict, name, mangled_name, namespace);
}

/* Initialize ITERATOR to point at the first symbol in DICT, and
   return that first symbol, or NULL if DICT is empty.  */

struct symbol *
dict_iterator_first (const struct dictionary *dict,
		     struct dict_iterator *iterator)
{
  return (DICT_VTBL (dict))->iterator_first (dict, iterator);
}

/* Advance ITERATOR, and return the next symbol, or NULL if there are
   no more symbols.  */

struct symbol *
dict_iterator_next (struct dict_iterator *iterator)
{
  return (DICT_VTBL (DICT_ITERATOR_DICT (iterator)))
    ->iterator_next (iterator);
}

/* Test to see if DICT is empty.  I could put this in the vtable, but
   it's easy enough to do generically and doesn't get called a
   lot.  */

extern int
dict_empty (struct dictionary *dict)
{
  struct dict_iterator iter;

  return (dict_iterator_first (dict, &iter) == NULL);
}

/* Add SYM to DICT.  DICT had better be expandable.  */

extern void
dict_add_symbol (struct dictionary *dict, struct symbol *sym)
{
  (DICT_VTBL (dict))->add_symbol (dict, sym);
}


d177 1
a177 92
/* Generic functions, where appropriate.  */

static void
free_obstack (struct dictionary *dict)
{
  /* Do nothing!  */
}

static void
add_symbol_nonexpandable (struct dictionary *dict, struct symbol *sym)
{
  internal_error (__FILE__, __LINE__,
		  "dict_add_symbol: non-expandable dictionary");
}

/* Functions for DICT_HASHED.  */

static struct symbol *
lookup_hashed (const struct dictionary *dict,
	       const char *name,
	       const char *mangled_name,
	       const namespace_enum namespace)
{
  unsigned int hash_index
    = msymbol_hash_iw (name) % DICT_HASHED_NBUCKETS (dict);
  struct symbol *sym;
  
  for (sym = DICT_HASHED_BUCKET (dict, hash_index);
       sym;
       sym = sym->hash_next)
    {
      if (SYMBOL_NAMESPACE (sym) == namespace
	  && (mangled_name
	      ? strcmp (SYMBOL_NAME (sym), mangled_name) == 0
	      : SYMBOL_MATCHES_NAME (sym, name)))
	return sym;
    }
  
  return NULL;
}

static struct symbol *
iterator_first_hashed (const struct dictionary *dict,
		       struct dict_iterator *iterator)
{
  DICT_ITERATOR_DICT (iterator) = dict;
  DICT_ITERATOR_INDEX (iterator) = -1;
  return iterator_hashed_advance (iterator);
}

static struct symbol *
iterator_next_hashed (struct dict_iterator *iterator)
{
  const struct dictionary *dict = DICT_ITERATOR_DICT (iterator);
  struct symbol *next;

  /* FIXME: carlton/2002-09-23: Should I assert that
     DICT_ITERATOR_CURRENT (iterator) != NULL?  */
  next = DICT_ITERATOR_CURRENT (iterator)->hash_next;
  
  if (next == NULL)
    return iterator_hashed_advance (iterator);
  else
    {
      DICT_ITERATOR_CURRENT (iterator) = next;
      return next;
    }
}

static struct symbol *
iterator_hashed_advance (struct dict_iterator *iterator)
{
  const struct dictionary *dict = DICT_ITERATOR_DICT (iterator);
  int nbuckets = DICT_HASHED_NBUCKETS (dict);
  int i;

  for (i = DICT_ITERATOR_INDEX (iterator) + 1; i < nbuckets; ++i)
    {
      struct symbol *sym = DICT_HASHED_BUCKET (dict, i);
      
      if (sym != NULL)
	{
	  DICT_ITERATOR_INDEX (iterator) = i;
	  DICT_ITERATOR_CURRENT (iterator) = sym;
	  return sym;
	}
    }

  return NULL;
}

/* Functions for DICT_BLOCK and DICT_BLOCK_EXPANDABLE.  */
d180 1
a180 1
free_block (struct dictionary *dict)
a182 173
}

static struct symbol *
lookup_block (const struct dictionary *dict,
	      const char *name,
	      const char *mangled_name,
	      const namespace_enum namespace)
{
  struct block *block = DICT_BLOCK_BLOCK (dict);
  register int bot, top;
  register struct symbol *sym;
  register struct symbol *sym_found = NULL;

  if (BLOCK_HASHTABLE (block))
    {
      unsigned int hash_index;
      hash_index = msymbol_hash_iw (name);
      hash_index = hash_index % BLOCK_BUCKETS (block);
      for (sym = BLOCK_BUCKET (block, hash_index); sym; sym = sym->hash_next)
	{
	  if (SYMBOL_NAMESPACE (sym) == namespace 
	      && (mangled_name
		  ? strcmp (SYMBOL_NAME (sym), mangled_name) == 0
		  : SYMBOL_MATCHES_NAME (sym, name)))
	    return sym;
	}
      return NULL;
    }
  else
    {
      /* Note that parameter symbols do not always show up last in the
	 list.  This loop makes sure to take anything else other than
	 parameter symbols first; it only uses parameter symbols as a
	 last resort.  Note that this only takes up extra computation
	 time on a match.  */
      top = BLOCK_NSYMS (block);
      bot = 0;
      while (bot < top)
	{
	  sym = BLOCK_SYM (block, bot);
	  /* If there is more than one symbol with the right name and
	     namespace, we return the first one; I believe it is now
	     impossible for us to encounter two symbols with the same
	     name and namespace here, because blocks containing
	     argument symbols are no longer sorted.  The exception is
	     for C++, where multiple functions (cloned constructors /
	     destructors, in particular) can have the same demangled
	     name.  So if we have a particular mangled name to match,
	     try to do so.  */
	  if (SYMBOL_NAMESPACE (sym) == namespace
	      && (mangled_name
		  ? strcmp (SYMBOL_NAME (sym), mangled_name) == 0
		  : SYMBOL_MATCHES_NAME (sym, name)))
	    {
#if 0
	      /* FIXME: carlton/2002-09-11: According to
		 <http://sources.redhat.com/ml/gdb/2002-03/msg00232.html>,
		 the SYMBOL_ALIASES stuff is unused, and it makes
		 the code messier, so I'm #if'ing it out here.  */

	      /* If SYM has aliases, then use any alias that is active
	         at the current PC.  If no alias is active at the current
	         PC, then use the main symbol.

	         ?!? Is checking the current pc correct?  Is this routine
	         ever called to look up a symbol from another context?

		 FIXME: No, it's not correct.  If someone sets a
		 conditional breakpoint at an address, then the
		 breakpoint's `struct expression' should refer to the
		 `struct symbol' appropriate for the breakpoint's
		 address, which may not be the PC.

		 Even if it were never called from another context,
		 it's totally bizarre for lookup_symbol's behavior to
		 depend on the value of the inferior's current PC.  We
		 should pass in the appropriate PC as well as the
		 block.  The interface to lookup_symbol should change
		 to require the caller to provide a PC.  */

	      if (SYMBOL_ALIASES (sym))
		sym = find_active_alias (sym, read_pc ());
#endif /* 0 */

	      sym_found = sym;
	      if (SYMBOL_CLASS (sym) != LOC_ARG &&
		  SYMBOL_CLASS (sym) != LOC_LOCAL_ARG &&
		  SYMBOL_CLASS (sym) != LOC_REF_ARG &&
		  SYMBOL_CLASS (sym) != LOC_REGPARM &&
		  SYMBOL_CLASS (sym) != LOC_REGPARM_ADDR &&
		  SYMBOL_CLASS (sym) != LOC_BASEREG_ARG)
		{
		  break;
		}
	    }
	  bot++;
	}
      return (sym_found);		/* Will be NULL if not found. */
    }  
}

static struct symbol *
iterator_first_block (const struct dictionary *dict,
		      struct dict_iterator *iterator)
{
  struct block *block = DICT_BLOCK_BLOCK (dict);

  DICT_ITERATOR_DICT (iterator) = dict;
	
  if (BLOCK_HASHTABLE (block))
    {
      DICT_ITERATOR_INDEX (iterator) = -1;
      return iterator_block_hashed_advance (iterator);
    }
  else
    {
      DICT_ITERATOR_INDEX (iterator) = 0;
      return BLOCK_NSYMS (block) ? BLOCK_SYM (block, 0) : NULL;
    }
}

static struct symbol *
iterator_next_block (struct dict_iterator *iterator)
{
  const struct dictionary *dict = DICT_ITERATOR_DICT (iterator);
  struct block *block = DICT_BLOCK_BLOCK (dict);
	
  if (BLOCK_HASHTABLE (block))
    {
      struct symbol *next = DICT_ITERATOR_CURRENT (iterator)->hash_next;
	    
      if (next == NULL)
	return iterator_block_hashed_advance (iterator);
      else
	{
	  DICT_ITERATOR_CURRENT (iterator) = next;
	  return next;
	}
    }
  else
    {
      if (++(DICT_ITERATOR_INDEX (iterator)) >= BLOCK_NSYMS (block))
	return NULL;
      else
	return BLOCK_SYM (block, DICT_ITERATOR_INDEX (iterator));
    }
}

/* A helper function for iterator_first_block and
   iterator_first_block_next_block.  Search for the next nonempty
   bucket; update iterator accordingly, and return it.  */

static struct symbol *
iterator_block_hashed_advance (struct dict_iterator *iterator)
{
  struct block *block =
    DICT_BLOCK_BLOCK (DICT_ITERATOR_DICT (iterator));
  int nbuckets = BLOCK_BUCKETS (block);
  int i;

  for (i = DICT_ITERATOR_INDEX (iterator) + 1; i < nbuckets; ++i)
    {
      struct symbol *sym = BLOCK_BUCKET (block, i);
      
      if (sym != NULL)
	{
	  DICT_ITERATOR_INDEX (iterator) = i;
	  DICT_ITERATOR_CURRENT (iterator) = sym;
	  return sym;
	}
    }

  return NULL;
@


1.1.2.3
log
@2002-09-24  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c: Comment out block-specific stuff.
	* jv-lang.c (get_java_class_symtab): Allocate GLOBAL_BLOCK on
	obstack.
	(free_class_block): Don't free GLOBAL_BLOCK.
	* dictionary.h: Comment out block-specific stuff.
	* symtab.h: Comment out the members of struct block that
	BLOCK_DICT obsoletes, and their accessors.
	* Makefile.in (buildsym.o): Depend on gdb_assert_h.
	* buildsym.c (finish_block): Don't count number of symbols.
	(finish_block): Replace BLOCK_SYM reference with use of iterator.
	#include "gdb_assert.h"
	* symfile.c (free_named_symtabs): Fix calls to dict_empty
	(which would seem to be #if'd out; oops...).
	* buildsym.c (finish_block): Don't set BLOCK_HASHTABLE.
	* jv-lang.c (get_java_class_symtab): Don't set BLOCK_HASHTABLE and
	BLOCK_NSYMS.
	* mdebugread.c (new_block): Allocate BLOCK_DICT via
	dict_create_linear_expandable.
	(add_symbol): Add symbol via dict_add_symbol; no need to chase
	pointers.
	(fixup_sigtramp): Add symbol via dict_add_symbol.
	(new_symtab): Add FIXME comment on freeing blocks.
	* jv-lang.c (get_java_class_symtab): Allocate GLOBAL_BLOCK's dict
	using dict_create_linear_expandable.
	(add_class_symtab_symbol): Add symbol using dict_add_symbol.
	* dictionary.c (struct dictionary_linear_expandable): New struct.
	(struct dictionary): Added member 'linear_expandable'.
	(DICT_LINEAR_EXPANDABLE_MAXSYMS): New macro.
	New variable dict_block_vtbl.  Made all the _vtbl variables static.
	Renamed all 'maxsyms' to 'capacity'.
	(dict_create_linear_expandable): New function.
	(add_symbol_linear_expandable): New function.
	(free_linear_expandable): New function.
	* jv-lang.c (get_java_class_symtab): Create static block's
	dictionary with dict_create_linear.
	* buildsym.c (finish_block): Create function blocks' dictionaries
	with dict_create_linear.
	* dictionary.c (lookup_linear): New function.
	(iterator_first_linear): New function.
	(iterator_next_linear): New function.
	* dictionary.h: Moved comment.
	* dictionary.c (struct dictionary_linear): New struct.
	(struct dictionary): Added 'linear' member.
	(DICT_LINEAR_NSYMS): New macro.
	(DICT_LINEAR_SYMS): New macro.
	(DICT_LINEAR_SYM): New macro.
	New variable dict_linear_vtbl.
	(dict_create_linear): New function.
@
text
@a62 1
#if 0
a66 2
    
#endif
a100 20
struct dictionary_linear
{
  int nsyms;
  struct symbol **syms;
};

/* In this implementation, symbols are stored in an array that grows
   as necessary.  Note: the entries are ordered so that its initial
   segment matches dictionary_linear.  */

struct dictionary_linear_expandable
{
  /* How many symbols we currently have.  */
  int nsyms;
  struct symbol **syms;
  /* How many symbols we can store before needing to reallocate.  */
  int capacity;
};

#if 0
d109 1
a109 1
  unsigned int capacity;
a110 1
#endif
a119 3
    struct dictionary_linear linear;
    struct dictionary_linear_expandable linear_expandable;
#if 0
a121 1
#endif
d134 1
a134 11
/* These can be used for DICT_LINEAR_EXPANDABLEs, too.  */

#define DICT_LINEAR_NSYMS(d)		(d)->data.linear.nsyms
#define DICT_LINEAR_SYMS(d)		(d)->data.linear.syms
#define DICT_LINEAR_SYM(d,i)		DICT_LINEAR_SYMS (d) [i]

#define DICT_LINEAR_EXPANDABLE_CAPACITY(d) \
		(d)->data.linear_expandable.capacity

#if 0
/* This can be used for DICT_BLOCK_EXPANDABLES, too.  */
d138 1
a138 6
#define DICT_BLOCK_EXPANDABLE_CAPACITY(d) (d)->data.block_expandable.capacity

#endif
/* The initial size of a DICT_LINEAR_EXPANDABLE dictionary.  */

#define DICT_LINEAR_EXPANDABLE_INITIAL_CAPACITY 10
d140 1
a140 3
#if 0
#define DICT_BLOCK_EXPANDABLE_INITIAL_CAPACITY \
		DICT_LINEAR_EXPANDABLE_INITIAL_CAPACITY
d142 2
a143 1
#endif
a167 1
#if 0
a169 1
#endif
a191 21
/* Functions for DICT_LINEAR and DICT_LINEAR_EXPANDABLE
   dictionaries.  */

static struct symbol *lookup_linear (const struct dictionary *dict,
				     const char *name,
				     const char *mangled_name,
				     const namespace_enum namespace);

static struct symbol *iterator_first_linear (const struct dictionary *dict,
					     struct dict_iterator *iterator);

static struct symbol *iterator_next_linear (struct dict_iterator *iterator);

/* Functions only for DICT_LINEAR_EXPANDABLE.  */

static void free_linear_expandable (struct dictionary *dict);

static void add_symbol_linear_expandable (struct dictionary *dict,
					  struct symbol *sym);

#if 0
a206 2
#endif

d209 1
a209 1
static const struct dict_vtbl dict_hashed_vtbl =
d215 1
a215 15
static const struct dict_vtbl dict_linear_vtbl =
  {
    DICT_LINEAR, free_obstack, lookup_linear, iterator_first_linear,
    iterator_next_linear, add_symbol_nonexpandable,
  };

static const struct dict_vtbl dict_linear_expandable_vtbl =
  {
    DICT_LINEAR_EXPANDABLE, free_linear_expandable, lookup_linear,
    iterator_first_linear, iterator_next_linear,
    add_symbol_linear_expandable,
  };

#if 0
static const struct dict_vtbl dict_block_vtbl =
d221 1
a221 1
static const struct dict_vtbl dict_block_expandable_vtbl =
a225 1
#endif
d279 1
a287 36
{
  struct dictionary *retval;
  int nsyms, i, j;
  struct symbol **syms;
  const struct pending *list_counter;

  retval = obstack_alloc (obstack, sizeof (struct dictionary));
  DICT_VTBL (retval) = &dict_linear_vtbl;

  /* Calculate the number of symbols, and allocate space for them.  */
  for (nsyms = 0, list_counter = symbol_list;
       list_counter != NULL;
       nsyms += list_counter->nsyms, list_counter = list_counter->next)
    {
      /* EMPTY */ ;
    }
  DICT_LINEAR_NSYMS (retval) = nsyms;
  syms = obstack_alloc (obstack, nsyms * sizeof (struct symbol *));
  DICT_LINEAR_SYMS (retval) = syms;

  /* Now fill in the symbols.  Start filling in from the back, so as
     to preserve the original order of the symbols.  */
  for (list_counter = symbol_list, j = nsyms - 1;
       list_counter != NULL;
       list_counter = list_counter->next)
    {
      for (i = list_counter->nsyms - 1;
	   i >= 0;
	   --i, --j)
	{
	  syms[j] = list_counter->symbol[i];
	}
    }

  return retval;
}
d302 1
a302 2
{
  struct dictionary *retval;
a303 13
  retval = xmalloc (sizeof (struct dictionary));
  DICT_VTBL (retval) = &dict_linear_expandable_vtbl;
  DICT_LINEAR_NSYMS (retval) = 0;
  DICT_LINEAR_EXPANDABLE_CAPACITY (retval)
    = DICT_LINEAR_EXPANDABLE_INITIAL_CAPACITY;
  DICT_LINEAR_SYMS (retval)
    = xmalloc (DICT_LINEAR_EXPANDABLE_CAPACITY (retval)
	       * sizeof (struct symbol *));

  return retval;
}

#if 0
d327 1
a327 1
  DICT_BLOCK_EXPANDABLE_CAPACITY (retval) = 0;
a331 2
#endif

a494 144
/* Functions for DICT_LINEAR and DICT_LINEAR_EXPANDABLE.  */

static struct symbol *
lookup_linear (const struct dictionary *dict,
	       const char *name,
	       const char *mangled_name,
	       const namespace_enum namespace)
{
  /* More or less copied from lookup_block_symbol() in symtab.c,
     including the comments.  */

  int i, nsyms = DICT_LINEAR_NSYMS (dict);
  struct symbol *sym, *sym_found = NULL;
  
  for (i = 0; i < nsyms; ++i)
    {
      sym = DICT_LINEAR_SYM (dict, i);

      /* NOTE: carlton/2002-09-24: I copied the following comment here
	 from the sorted linear symbol case of lookup_block_symbol.
	 But Jim Blandy complained, and said it didn't belong in the
	 non-sorted case.  (Understandable, since it refers to
	 sorting!)  I wish I understood exactly what its purpose
	 had been.  */

      /* If there is more than one symbol with the right name and
	 namespace, we return the first one; I believe it is now
	 impossible for us to encounter two symbols with the same name
	 and namespace here, because blocks containing argument
	 symbols are no longer sorted.  The exception is for C++,
	 where multiple functions (cloned constructors / destructors,
	 in particular) can have the same demangled name.  So if we
	 have a particular mangled name to match, try to do so.  */
      if (SYMBOL_NAMESPACE (sym) == namespace
	  && (mangled_name
	      ? strcmp (SYMBOL_NAME (sym), mangled_name) == 0
	      : SYMBOL_MATCHES_NAME (sym, name)))
	{

#if 0
	  /* FIXME: carlton/2002-09-11: According to
	     <http://sources.redhat.com/ml/gdb/2002-03/msg00232.html>,
	     the SYMBOL_ALIASES stuff is unused, and it makes the code
	     messier, so I'm #if'ing it out here.  */

	  /* If SYM has aliases, then use any alias that is active at
	     the current PC.  If no alias is active at the current PC,
	     then use the main symbol.
	     
	     ?!? Is checking the current pc correct?  Is this routine
	     ever called to look up a symbol from another context?
		   
	     FIXME: No, it's not correct.  If someone sets a
	     conditional breakpoint at an address, then the
	     breakpoint's `struct expression' should refer to the
	     `struct symbol' appropriate for the breakpoint's address,
	     which may not be the PC.
		   
	     Even if it were never called from another context, it's
	     totally bizarre for lookup_symbol's behavior to depend on
	     the value of the inferior's current PC.  We should pass
	     in the appropriate PC as well as the block.  The
	     interface to lookup_symbol should change to require the
	     caller to provide a PC.  */

	  if (SYMBOL_ALIASES (sym))
	    sym = find_active_alias (sym, read_pc ());
#endif /* 0 */
	  /* NOTE: carlton/2002-09-11: I wish I understood exactly the
	     situations where this next bit is important.  Sigh.  */
		
	  /* Note that parameter symbols do not always show up last in
	     the list; this loop makes sure to take anything else
	     other than parameter symbols first; it only uses
	     parameter symbols as a last resort.  Note that this only
	     takes up extra computation time on a match.  */

	  sym_found = sym;
	  if (SYMBOL_CLASS (sym) != LOC_ARG &&
	      SYMBOL_CLASS (sym) != LOC_LOCAL_ARG &&
	      SYMBOL_CLASS (sym) != LOC_REF_ARG &&
	      SYMBOL_CLASS (sym) != LOC_REGPARM &&
	      SYMBOL_CLASS (sym) != LOC_REGPARM_ADDR &&
	      SYMBOL_CLASS (sym) != LOC_BASEREG_ARG)
	    {
	      break;
	    }
	}
    }
  
  return (sym_found);		/* Will be NULL if not found. */
}

static struct symbol *
iterator_first_linear (const struct dictionary *dict,
		       struct dict_iterator *iterator)
{
  DICT_ITERATOR_DICT (iterator) = dict;
  DICT_ITERATOR_INDEX (iterator) = 0;
  return DICT_LINEAR_NSYMS (dict) ? DICT_LINEAR_SYM (dict, 0) : NULL;
}

static struct symbol *
iterator_next_linear (struct dict_iterator *iterator)
{
  const struct dictionary *dict = DICT_ITERATOR_DICT (iterator);

  if (++DICT_ITERATOR_INDEX (iterator) >= DICT_LINEAR_NSYMS (dict))
    return NULL;
  else
    return DICT_LINEAR_SYM (dict, DICT_ITERATOR_INDEX (iterator));
}

/* Functions only for DICT_LINEAR_EXPANDABLE.  */

static void
free_linear_expandable (struct dictionary *dict)
{
  xfree (DICT_LINEAR_SYMS (dict));
  xfree (dict);
}


static void
add_symbol_linear_expandable (struct dictionary *dict,
			      struct symbol *sym)
{
  int nsyms = ++DICT_LINEAR_NSYMS (dict);

  /* Do we have enough room?  If not, grow it.  */
  if (nsyms > DICT_LINEAR_EXPANDABLE_CAPACITY (dict)) {
    DICT_LINEAR_EXPANDABLE_CAPACITY (dict) *= 2;
    DICT_LINEAR_SYMS (dict)
      = xrealloc (DICT_LINEAR_SYMS (dict),
		  DICT_LINEAR_EXPANDABLE_CAPACITY (dict)
		  * sizeof (struct symbol *));
  }

  DICT_LINEAR_SYM (dict, nsyms - 1) = sym;
}


#if 0

d688 1
a688 1
  if (++BLOCK_NSYMS (block) > DICT_BLOCK_EXPANDABLE_CAPACITY (dict))
d690 2
a691 2
      if (DICT_BLOCK_EXPANDABLE_CAPACITY (dict))
	DICT_BLOCK_EXPANDABLE_CAPACITY (dict) *= 2;
d693 2
a694 2
	DICT_BLOCK_EXPANDABLE_CAPACITY (dict)
	  = DICT_BLOCK_EXPANDABLE_INITIAL_CAPACITY;
d698 1
a698 1
			+ ((DICT_BLOCK_EXPANDABLE_CAPACITY (dict) -1)
a706 1
#endif
@


1.1.2.4
log
@2002-09-25  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c: Commented what needs to be done to add stuff to
	this file.
	* dictionary.h: Expand on namespace_enum comment.
	* Makefile.in (cris-tdep.o): Depend on gdb_string_h.
	(mcore-tdep.o): Ditto.
	(ns32k-tdep.o): Ditto.
	(sh3-rom.o): Ditto.
	(vax-tdep.o): Ditto.
	* cris-tdep.c: #include "gdb_string.h"
	* mcore-tdep.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* sh3-rom.c: Ditto.
	* vax-tdep.c: Ditto.
@
text
@d39 1
a39 47
   operations that dictionaries provide.

   To add a new dictionary implementation <impl>, what you should do
   is:

   * Add a new element DICT_<IMPL> to dict_type.
   
   * Create a new structure dictionary_<impl>.  If your new
   implementation is a variant of an existing one, make sure that
   their structs have the same initial data members.  Define accessor
   macros for your new data members.

   * Implement all the functions in dict_vtbl as static functions,
   whose name is the same as the corresponding member of dict_vtbl
   plus _<impl>.  You don't have to do this for those members where
   you can reuse existing generic functions
   (e.g. add_symbol_nonexpandable, free_obstack) or in the case where
   your new implementation is a variant of an existing implementation
   and where the variant doesn't affect the member function in
   question.

   * Define a static const struct dict_vtbl dict_<impl>_vtbl.

   * Define a function dict_create_<impl> to create these
   gizmos.  Add its declaration to dictionary.h.

   To add a new operation <op> on all existing implementations, what
   you should do is:

   * Add a new member <op> to struct dict_vtbl.

   * If there is useful generic behavior <op>, define a static
   function <op>_something_informative that implements that behavior.
   (E.g. add_symbol_nonexpandable, free_obstack.)

   * For every implementation <impl> that should have its own specific
   behavior for <op>, define a static function <op>_<impl>
   implementing it.

   * Modify all existing dict_vtbl_<impl>'s to include the appropriate
   member.

   * Define a function dict_<op> that looks up <op> in the dict_vtbl
   and calls the appropriate function.  Add a declaration for
   dict_<op> to dictionary.h.
   
*/
@


1.1.2.5
log
@2002-09-26  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c (dict_iter_name_first): New function.
	(dict_iter_name_next): New function.
	Initialize new members of dict_hashed_vtbl, dict_linear_vtbl, and
	dict_linear_expandable_vtbl.
	(iter_name_first_hashed): New function.
	(iter_name_next_hashed): New function.
	(iter_name_first_linear): New function.
	(iter_name_next_linear): New function.
	(lookup_hashed): Rewrite following new declaration/semantics.
	(lookup_linear): Ditto.
	(dict_lookup): Ditto.
	* symtab.c (lookup_block_symbol): Rewrite to use
	dict_iter_name_first and dict_iter_name_next instead of
	dict_lookup.
	* dictionary.c (struct dict_vtbl): Change member 'lookup'; new
	members 'iter_name_first' and 'iter_name_next'.
	* dictionary.h: Delete all traces of block stuff.
	Change declaration for dict_lookup; new declarations
	dict_iter_name_first and dict_iter_name_next.
	* dictionary.c: Delete all traces of block stuff.
	* symtab.h (SYMBOL_BEST_NAME): New macro.
	(SYMBOL_SOURCE_NAME): Rewrite in terms of SYMBOL_BEST_NAME.
	(SYMBOL_LINKAGE_NAME): Ditto.
	Comment questioning SYMBOL_MATCHES_NAME and
	SYMBOL_MATCHES_REGEXP.
	* Makefile.in (ns32knbsd-tdep.o): Depend on gdb_string_h.
	* ns32knbsd-tdep.c: #include "gdb_string.h"
@
text
@d109 7
d129 3
a131 1
			    const char *name);
a136 5
  struct symbol *(*iter_name_first) (const struct dictionary *dict,
				     const char *name,
				     struct dict_iterator *iterator);
  struct symbol *(*iter_name_next) (const char *name,
				    struct dict_iterator *iterator);
d169 13
d192 4
d217 8
d229 6
d258 5
d275 3
a277 1
				     const char *name);
a283 7
static struct symbol *iter_name_first_hashed (const struct dictionary *dict,
					      const char *name,
					      struct dict_iterator *iterator);

static struct symbol *iter_name_next_hashed (const char *name,
					     struct dict_iterator *iterator);

d288 3
a290 1
				     const char *name);
a296 8
static struct symbol *iter_name_first_linear (const struct dictionary *dict,
					      const char *name,
					      struct dict_iterator *iterator);

static struct symbol *iter_name_next_linear (const char *name,
					     struct dict_iterator *iterator);


d304 18
d327 1
a327 2
    iterator_next_hashed, add_symbol_nonexpandable, iter_name_first_hashed,
    iter_name_next_hashed,
d333 1
a333 2
    iterator_next_linear, add_symbol_nonexpandable, iter_name_first_linear,
    iter_name_next_linear,
d340 8
a347 2
    add_symbol_linear_expandable, iter_name_first_linear,
    iter_name_next_linear,
d350 7
d397 4
a400 1
	  hash_index = msymbol_hash_iw (SYMBOL_BEST_NAME (sym)) % nbuckets;
d482 31
d535 3
a537 1
	     const char *name)
d539 1
a539 1
  return (DICT_VTBL (dict))->lookup (dict, name);
d566 1
a566 1
int
d576 1
a576 1
void
a581 16
struct symbol *
dict_iter_name_first (const struct dictionary *dict,
		      const char *name,
		      struct dict_iterator *iterator)
{
  return (DICT_VTBL (dict))->iter_name_first (dict, name, iterator);
}

struct symbol *
dict_iter_name_next (const char *name, struct dict_iterator *iterator)
{
  return (DICT_VTBL (DICT_ITERATOR_DICT (iterator)))
    ->iter_name_next (name, iterator);
}
 

d604 3
a606 1
	       const char *name)
d616 4
a619 2
      /* Warning: the order of arguments to strcmp_iw matters!  */
      if (strcmp_iw (SYMBOL_BEST_NAME (sym), name) == 0)
d641 2
a642 3
  /* FIXME: carlton/2002-09-23: Should I gdb_assert that
     DICT_ITERATOR_CURRENT (iterator) != NULL?  (Ditto for
     iter_name_next_hashed.)  */
d676 1
a676 10
static struct symbol *
iter_name_first_hashed (const struct dictionary *dict,
			const char *name,
			struct dict_iterator *iterator)
{
  DICT_ITERATOR_DICT (iterator) = dict;
  DICT_ITERATOR_CURRENT (iterator) = lookup_hashed (dict, name);

  return DICT_ITERATOR_CURRENT (iterator);
}
d679 4
a682 1
iter_name_next_hashed (const char *name, struct dict_iterator *iterator)
d684 2
a685 1
  struct symbol *next;
d687 4
a690 2
  for (next = DICT_ITERATOR_CURRENT (iterator)->hash_next;
       next; next = next->hash_next)
d692 1
a692 3
      if (strcmp_iw (SYMBOL_BEST_NAME (next), name) == 0)
	break;
    }
d694 20
a713 1
  DICT_ITERATOR_CURRENT (iterator) = next;
d715 52
a766 14
  return next;
}

/* Functions for DICT_LINEAR and DICT_LINEAR_EXPANDABLE.  */

static struct symbol *
lookup_linear (const struct dictionary *dict, const char *name)
{
  /* NOTE: carlton/2002-09-26: I don't expect this to get called much,
     so let's just use iter_name_first_linear.  */

  struct dict_iterator iter;

  return iter_name_first_linear (dict, name, &iter);
a788 33
static struct symbol *
iter_name_first_linear (const struct dictionary *dict,
			const char *name,
			struct dict_iterator *iterator)
{
  DICT_ITERATOR_DICT (iterator) = dict;
  DICT_ITERATOR_INDEX (iterator) = -1;

  return iter_name_next_linear (name, iterator);
}

static struct symbol *
iter_name_next_linear (const char *name, struct dict_iterator *iterator)
{
  const struct dictionary *dict = DICT_ITERATOR_DICT (iterator);
  int i, nsyms = DICT_LINEAR_NSYMS (dict);
  struct symbol *sym, *retval = NULL;

  for (i = DICT_ITERATOR_INDEX (iterator) + 1; i < nsyms; ++i)
    {
      sym = DICT_LINEAR_SYM (dict, i);
      if (strcmp_iw (SYMBOL_BEST_NAME (sym), name) == 0)
	{
	  retval = sym;
	  break;
	}
    }

  DICT_ITERATOR_INDEX (iterator) = i;
  
  return retval;
}

d816 217
@


1.1.2.6
log
@2002-09-30  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.h: Augment comment above dict_lookup.
	* dictionary.c (struct dict_vtbl): Delete 'lookup' member, and
	move add_symbol to precede the iterators.
	Make corresponding changes to dict_hashed_vtbl, dict_linear_vtbl,
	dict_linear_expandable_vtbl.
	(dict_lookup): Implement by means of dict_iterator_name_first.
	(iter_name_first_hashed): Don't use lookup_hashed to implement.
	(lookup_hashed): Delete.
	(lookup_linear): Delete.
	* symtab.c (lookup_symbol_aux_global_symtabs): Delete 'block'
	argument, rename local variable 'b' to 'block', and make it point
	to a const struct block.
	(lookup_symbol_aux_minsym_non_hpuxhppa): Ditto.
	(lookup_symbol_aux_global_psymtabs): Ditto.
	(lookup_symbol_aux_static_symtabs): Ditto.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux_minsym_hpuxhppa): Ditto.
	(lookup_symbol_aux): Correct calls to above functions.
	(lookup_symbol_aux_minsym_non_hpuxhppa): When recursively calling
	lookup_symbol_aux, pass 'NULL' as block argument.
	(lookup_symbol_aux_minsym_hpuxhppa): Ditto.
	(lookup_symbol_aux_global_symtabs): Don't initialize objfile and
	s.
	(lookup_symbol_aux_minsym_non_hpuxhppa): Don't initialize s.
	(lookup_symbol_aux_global_psymtabs): Ditto.
	(lookup_symbol_aux_static_symtabs): Ditto.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux_minsym_hpuxhppa): Ditto.
	(lookup_symbol_aux_global_psymtabs): Don't initialize objfile.
	(lookup_symbol_aux_static_symtabs): Ditto.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux_minsym_hpuxhppa): Delete local variable
	objfile.
	(lookup_symbol_aux_static_symtabs): Delete, to be replaced by
	lookup_symbol_aux_symtabs.
	(lookup_symbol_aux_global_symtabs): Ditto.
	(lookup_symbol_aux_symtabs): New function.
	(lookup_symbol_aux_psymtabs): New function.
	(lookup_symbol_aux_global_psymtabs): Delete, to be replaced by
	lookup_symbol_aux_psymtabs.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux_minsym_hpuxhppa): Delete, to be replaced by
	lookup_symbol_aux_minsyms.
	(lookup_symbol_aux_minsym_non_hpuxhppa): Ditto.
	(lookup_symbol_aux_minsyms): New function.
	(lookup_symbol_aux): Replace function calls by calls to functions
	with new names.
	(lookup_symbol_aux): Search global psymtabs before minimal
	symbols.
	* Makefile.in (ppc-sysv-tdep.o): Depend on gdb_string_h.
	* ppc-sysv-tdep.c: #include "gdb_string.h".

2002-09-27  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Run through gdb_indent.sh.
	(lookup_symbol_aux): Delete code that isn't called.
	(lookup_symbol_aux): Don't declare variables 'register'.
	(lookup_symbol_aux): Move each chunk of code into its own
	function.
	(lookup_symbol_aux_local): New function.
	(lookup_symbol_aux_global_symtabs): New function.
	(lookup_symbol_aux_minsym_non_hpuxhppa): New function.
	(lookup_symbol_aux_global_psymtabs): New function.
	(lookup_symbol_aux_static_symtabs): New function.
	(lookup_symbol_aux_static_psymtabs): New function.
	(lookup_symbol_aux_minsym_hpuxhppa): New function.
	(lookup_symbol_aux_global_psymtabs): Remove embedded newlines from
	strings because CC mode can't deal with them.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux): Delete local variables that are now
	obsolete.
	* remote-sds.c (getmessage): Add semicolon after 'retry' label to
	pacify GCC.

2002-09-27  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (cris-tdep.o): Depend on gdb_string_h.
	(mcore-tdep.o): Ditto.
	(ns32k-tdep.o): Ditto.
	(ns32knbsd-tdep.o): Ditto.
	(sh3-rom.o): Ditto.
	(vax-tdep.o): Ditto.
	* cris-tdep.c: #include "gdb_string.h"
	* mcore-tdep.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* ns32knbsd-tdep.c: Ditto.
	* sh3-rom.c: Ditto.
	* vax-tdep.c: Ditto.
@
text
@d39 1
a39 3
   operations that dictionaries provide.  (Note, however, that, for
   the sake of client code, we also provide some functions that can be
   implemented generically in terms of the functions in the vtable.)
d120 3
a122 2
  /* Add a symbol to a dictionary, if possible.  */
  void (*add_symbol) (struct dictionary *dict, struct symbol *sym);
d127 1
a127 1
  /* Functions to iterate over symbols with a given name.  */
d234 3
d252 3
d279 3
a281 3
    DICT_HASHED, free_obstack, add_symbol_nonexpandable,
    iterator_first_hashed, iterator_next_hashed,
    iter_name_first_hashed, iter_name_next_hashed,
d286 3
a288 3
    DICT_LINEAR, free_obstack,  add_symbol_nonexpandable,
    iterator_first_linear, iterator_next_linear,
    iter_name_first_linear, iter_name_next_linear,
d293 1
a293 2
    DICT_LINEAR_EXPANDABLE, free_linear_expandable,
    add_symbol_linear_expandable, 
d295 2
a296 1
    iter_name_first_linear, iter_name_next_linear,
d432 8
a439 1
/* Add SYM to DICT.  DICT had better be expandable.  */
d441 3
a443 2
void
dict_add_symbol (struct dictionary *dict, struct symbol *sym)
d445 1
a445 1
  (DICT_VTBL (dict))->add_symbol (dict, sym);
d468 20
a502 23
/* These are functions that are implemented generically by means of
   the vtable.  Typically, they're rarely used.  */

/* Lookup NAME in DICT.  */

struct symbol *
dict_lookup (const struct dictionary *dict,
	     const char *name)
{
  struct dict_iterator iter;

  return dict_iter_name_first (dict, name, &iter);
}

/* Test to see if DICT is empty.  */

int
dict_empty (struct dictionary *dict)
{
  struct dict_iterator iter;

  return (dict_iterator_first (dict, &iter) == NULL);
}
d525 20
a599 4
  unsigned int hash_index
    = msymbol_hash_iw (name) % DICT_HASHED_NBUCKETS (dict);
  struct symbol *sym;

d601 1
d603 1
a603 18
  /* Loop through the symbols in the given bucket, breaking when SYM
     first matches.  If SYM never matches, it will be set to NULL;
     either way, we have the right return value.  */
  
  for (sym = DICT_HASHED_BUCKET (dict, hash_index);
       sym;
       sym = sym->hash_next)
    {
      /* Warning: the order of arguments to strcmp_iw matters!  */
      if (strcmp_iw (SYMBOL_BEST_NAME (sym), name) == 0)
	{
	  break;
	}
	
    }

  DICT_ITERATOR_CURRENT (iterator) = sym;
  return sym;
d624 11
@


1.1.2.7
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mdebugread.c (new_block): Add 'function' arg.
	(parse_symbol): New arg to new_block.
	(new_symtab): Ditto.
	(fixup_sigtramp): Ditto.
	* cp-support.c (initialize_namespace_blocks): Use
	dict_hashed_expandable instead of dict_linear_expandable.
	* jv-lang.c (get_java_class_symtab): Ditto.
	* dictionary.c (enum dict_type): Add DICT_HASHED_EXPANDABLE.
	(struct dictionary_hashed_expandable): New.
	(struct dictionary): Add hashed_expandable member.
	(DICT_EXPANDABLE_INITIAL_CAPACITY): Rename from
	DICT_LINEAR_EXPANDABLE_INITIAL_CAPACITY.
	(dict_create_linear_expandable): Use
	DICT_EXPANDABLE_INITIAL_CAPACITY.
	(dict_linear_vtbl): New.
	(dict_create_hashed_expandable): New.
	(add_symbol_hashed_expandable): New.
	(dict_create_hashed): Move code into insert_symbol_hashed.
	(insert_symbol_hashed): New.
	(expand_hashtable): New.
	* dictionary.h: Declare dict_create_hashed_expandable.
@
text
@d105 1
a105 1
    /* Symbols are stored in a fixed-size hash table.  */
d107 1
a107 3
    /* Symbols are stored in an expandable hash table.  */
    DICT_HASHED_EXPANDABLE,
    /* Symbols are stored in a fixed-size array.  */
a146 10
struct dictionary_hashed_expandable
{
  /* How many buckets we currently have.  */
  int nbuckets;
  struct symbol **buckets;
  /* How many syms we currently have; we need this so we will know
     when to add more buckets.  */
  int nsyms;
};

a173 1
    struct dictionary_hashed_expandable hashed_expandable;
a183 2
/* These can be used for DICT_HASHED_EXPANDABLE, too.  */

a187 2
#define DICT_HASHED_EXPANDABLE_NSYMS(d)	(d)->data.hashed_expandable.nsyms

d197 1
a197 1
/* The initial size of a DICT_*_EXPANDABLE dictionary.  */
d199 1
a199 1
#define DICT_EXPANDABLE_INITIAL_CAPACITY 10
d219 5
d233 1
a233 2
/* Functions for DICT_HASHED and DICT_HASHED_EXPANDABLE
   dictionaries.  */
a246 7
/* Functions only for DICT_HASHED_EXPANDABLE.  */

static void free_hashed_expandable (struct dictionary *dict);

static void add_symbol_hashed_expandable (struct dictionary *dict,
					  struct symbol *sym);

a278 8
static const struct dict_vtbl dict_hashed_expandable_vtbl =
  {
    DICT_HASHED_EXPANDABLE, free_hashed_expandable,
    add_symbol_hashed_expandable,
    iterator_first_hashed, iterator_next_hashed,
    iter_name_first_hashed, iter_name_next_hashed,
  };

a293 10
/* Declarations of helper functions (i.e. ones that don't go into
   vtbls).  */

static struct symbol *iterator_hashed_advance (struct dict_iterator *iter);

static void insert_symbol_hashed (struct dictionary *dict,
				  struct symbol *sym);

static void expand_hashtable (struct dictionary *dict);

d332 5
a336 1
	  insert_symbol_hashed (retval, list_counter->symbol[i]);
a342 20
/* Create a dictionary implemented via a hashtable that grows as
   necessary.  The dictionary is initially empty; to add symbols to
   it, call dict_add_symbol().  Call dict_free() when you're done with
   it.  */

extern struct dictionary *
dict_create_hashed_expandable (void)
{
  struct dictionary *retval;

  retval = xmalloc (sizeof (struct dictionary));
  DICT_VTBL (retval) = &dict_hashed_expandable_vtbl;
  DICT_HASHED_NBUCKETS (retval) = DICT_EXPANDABLE_INITIAL_CAPACITY;
  DICT_HASHED_BUCKETS (retval) = xcalloc (DICT_EXPANDABLE_INITIAL_CAPACITY,
					  sizeof (struct symbol *));
  DICT_HASHED_EXPANDABLE_NSYMS (retval) = 0;

  return retval;
}

d393 6
d408 1
a408 1
    = DICT_EXPANDABLE_INITIAL_CAPACITY;
d512 1
a512 1
/* Functions for DICT_HASHED and DICT_HASHED_EXPANDABLE.  */
a610 69
}

/* Insert SYM into DICT.  */

static void
insert_symbol_hashed (struct dictionary *dict,
		      struct symbol *sym)
{
  unsigned int hash_index;
  struct symbol **buckets = DICT_HASHED_BUCKETS (dict);

  hash_index = (msymbol_hash_iw (SYMBOL_BEST_NAME (sym))
		% DICT_HASHED_NBUCKETS (dict));
  sym->hash_next = buckets[hash_index];
  buckets[hash_index] = sym;
}

/* Functions only for DICT_HASHED_EXPANDABLE.  */

static void
free_hashed_expandable (struct dictionary *dict)
{
  xfree (DICT_HASHED_BUCKETS (dict));
  xfree (dict);
}

static void
add_symbol_hashed_expandable (struct dictionary *dict,
			      struct symbol *sym)
{
  int nsyms = ++DICT_HASHED_EXPANDABLE_NSYMS (dict);

  if (DICT_HASHTABLE_SIZE (nsyms) > DICT_HASHED_NBUCKETS (dict))
    expand_hashtable (dict);

  insert_symbol_hashed (dict, sym);
  DICT_HASHED_EXPANDABLE_NSYMS (dict) = nsyms;
}

static void
expand_hashtable (struct dictionary *dict)
{
  int old_nbuckets = DICT_HASHED_NBUCKETS (dict);
  struct symbol **old_buckets = DICT_HASHED_BUCKETS (dict);
  int new_nbuckets = 2*old_nbuckets + 1;
  struct symbol **new_buckets = xcalloc (new_nbuckets,
					 sizeof (struct symbol *));
  int i;

  DICT_HASHED_NBUCKETS (dict) = new_nbuckets;
  DICT_HASHED_BUCKETS (dict) = new_buckets;

  for (i = 0; i < old_nbuckets; ++i) {
    struct symbol *sym, *next_sym;

    sym = old_buckets[i];
    if (sym != NULL) {
      for (next_sym = sym->hash_next;
	   next_sym != NULL;
	   next_sym = sym->hash_next) {
	insert_symbol_hashed (dict, sym);
	sym = next_sym;
      }

      insert_symbol_hashed (dict, sym);
    }
  }

  xfree (old_buckets);
@


1.1.2.8
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d633 1
a633 1
      if (strcmp_iw (SYMBOL_NATURAL_NAME (sym), name) == 0)
d652 1
a652 1
      if (strcmp_iw (SYMBOL_NATURAL_NAME (next), name) == 0)
d670 1
a670 1
  hash_index = (msymbol_hash_iw (SYMBOL_NATURAL_NAME (sym))
d773 1
a773 1
      if (strcmp_iw (SYMBOL_NATURAL_NAME (sym), name) == 0)
@


1.1.2.9
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d3 1
a3 1
   Copyright 2003 Free Software Foundation, Inc.
d5 1
a5 2
   Contributed by David Carlton <carlton@@bactrian.org> and by Kealia,
   Inc.
d89 11
d165 4
d343 1
a343 1
  int nsyms = 0, nbuckets, i;
d351 1
a351 1
  for (list_counter = symbol_list;
d353 1
a353 1
       list_counter = list_counter->next)
d355 1
a355 1
      nsyms += list_counter->nsyms;
d407 1
a407 1
  int nsyms = 0, i, j;
d415 1
a415 1
  for (list_counter = symbol_list;
d417 1
a417 1
       list_counter = list_counter->next)
d419 1
a419 1
      nsyms += list_counter->nsyms;
d518 13
a530 3
/* Now come functions (well, one function, currently) that are
   implemented generically by means of the vtable.  Typically, they're
   rarely used.  */
d577 3
d629 1
a629 1
       sym != NULL;
d650 1
a650 2
       next != NULL;
       next = next->hash_next)
@


1.1.2.10
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a645 1
  gdb_assert (sym != buckets[hash_index]);
@


1.1.2.11
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d54 2
a55 2
   * Implement all the functions in dict_vector as static functions,
   whose name is the same as the corresponding member of dict_vector
d63 1
a63 1
   * Define a static const struct dict_vector dict_<impl>_vector.
d71 1
a71 1
   * Add a new member <op> to struct dict_vector.
d81 1
a81 1
   * Modify all existing dict_vector_<impl>'s to include the appropriate
d84 1
a84 1
   * Define a function dict_<op> that looks up <op> in the dict_vector
d107 1
a107 1
struct dict_vector
a125 2
  /* A size function, for maint print symtabs.  */
  int (*size) (const struct dictionary *dict);
d168 1
a168 1
  const struct dict_vector *vector;
d181 1
a181 1
#define DICT_VECTOR(d)			(d)->vector
d222 1
a222 1
/* Declarations of functions for vectors.  */
a245 4
/* Functions only for DICT_HASHED.  */

static int size_hashed (const struct dictionary *dict);

a252 2
static int size_hashed_expandable (const struct dictionary *dict);

a267 1
static int size_linear (const struct dictionary *dict);
d276 1
a276 1
/* Various vectors that we'll actually use.  */
d278 1
a278 1
static const struct dict_vector dict_hashed_vector =
d280 3
a282 8
    DICT_HASHED,			/* type */
    free_obstack,			/* free */
    add_symbol_nonexpandable,		/* add_symbol */
    iterator_first_hashed,		/* iteractor_first */
    iterator_next_hashed,		/* iterator_next */
    iter_name_first_hashed,		/* iter_name_first */
    iter_name_next_hashed,		/* iter_name_next */
    size_hashed,			/* size */
d285 1
a285 1
static const struct dict_vector dict_hashed_expandable_vector =
d287 4
a290 8
    DICT_HASHED_EXPANDABLE,		/* type */
    free_hashed_expandable,		/* free */
    add_symbol_hashed_expandable,	/* add_symbol */
    iterator_first_hashed,		/* iteractor_first */
    iterator_next_hashed,		/* iterator_next */
    iter_name_first_hashed,		/* iter_name_first */
    iter_name_next_hashed,		/* iter_name_next */
    size_hashed_expandable,		/* size */
d293 1
a293 1
static const struct dict_vector dict_linear_vector =
d295 3
a297 8
    DICT_LINEAR,			/* type */
    free_obstack,			/* free */
    add_symbol_nonexpandable,		/* add_symbol */
    iterator_first_linear,		/* iteractor_first */
    iterator_next_linear,		/* iterator_next */
    iter_name_first_linear,		/* iter_name_first */
    iter_name_next_linear,		/* iter_name_next */
    size_linear,			/* size */
d300 1
a300 1
static const struct dict_vector dict_linear_expandable_vector =
d302 4
a305 8
    DICT_LINEAR_EXPANDABLE,		/* type */
    free_linear_expandable,		/* free */
    add_symbol_linear_expandable,	/* add_symbol */
    iterator_first_linear,		/* iteractor_first */
    iterator_next_linear,		/* iterator_next */
    iter_name_first_linear,		/* iter_name_first */
    iter_name_next_linear,		/* iter_name_next */
    size_linear,			/* size */
d309 1
a309 1
   vectors).  */
d334 1
a334 1
  DICT_VECTOR (retval) = &dict_hashed_vector;
d374 1
a374 1
  DICT_VECTOR (retval) = &dict_hashed_expandable_vector;
d398 1
a398 1
  DICT_VECTOR (retval) = &dict_linear_vector;
d439 1
a439 1
  DICT_VECTOR (retval) = &dict_linear_expandable_vector;
d458 1
a458 1
  (DICT_VECTOR (dict))->free (dict);
d466 1
a466 1
  (DICT_VECTOR (dict))->add_symbol (dict, sym);
d476 1
a476 1
  return (DICT_VECTOR (dict))->iterator_first (dict, iterator);
d485 1
a485 1
  return (DICT_VECTOR (DICT_ITERATOR_DICT (iterator)))
d494 1
a494 1
  return (DICT_VECTOR (dict))->iter_name_first (dict, name, iterator);
d500 1
a500 1
  return (DICT_VECTOR (DICT_ITERATOR_DICT (iterator)))
a502 6

int
dict_size (const struct dictionary *dict)
{
  return (DICT_VECTOR (dict))->size (dict);
}
d646 1
a650 6
static int
size_hashed (const struct dictionary *dict)
{
  return DICT_HASHED_NBUCKETS (dict);
}

a672 6
static int
size_hashed_expandable (const struct dictionary *dict)
{
  return DICT_HASHED_EXPANDABLE_NSYMS (dict);
}

a757 6
}

static int
size_linear (const struct dictionary *dict)
{
  return DICT_LINEAR_NSYMS (dict);
@


