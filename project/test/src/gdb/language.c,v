head	1.115;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.114
	gdb_7_6-2013-04-26-release:1.114
	gdb_7_6-branch:1.114.0.2
	gdb_7_6-2013-03-12-branchpoint:1.114
	gdb_7_5_1-2012-11-29-release:1.111
	gdb_7_5-2012-08-17-release:1.111
	gdb_7_5-branch:1.111.0.2
	gdb_7_5-2012-07-18-branchpoint:1.111
	gdb_7_4_1-2012-04-26-release:1.103.2.1
	gdb_7_4-2012-01-24-release:1.103.2.1
	gdb_7_4-branch:1.103.0.2
	gdb_7_4-2011-12-13-branchpoint:1.103
	gdb_7_3_1-2011-09-04-release:1.102
	gdb_7_3-2011-07-26-release:1.102
	gdb_7_3-branch:1.102.0.2
	gdb_7_3-2011-04-01-branchpoint:1.102
	gdb_7_2-2010-09-02-release:1.98
	gdb_7_2-branch:1.98.0.2
	gdb_7_2-2010-07-07-branchpoint:1.98
	gdb_7_1-2010-03-18-release:1.94
	gdb_7_1-branch:1.94.0.2
	gdb_7_1-2010-02-18-branchpoint:1.94
	gdb_7_0_1-2009-12-22-release:1.90
	gdb_7_0-2009-10-06-release:1.90
	gdb_7_0-branch:1.90.0.2
	gdb_7_0-2009-09-16-branchpoint:1.90
	arc-sim-20090309:1.74
	msnyder-checkpoint-072509-branch:1.84.0.2
	msnyder-checkpoint-072509-branchpoint:1.84
	arc-insight_6_8-branch:1.74.0.6
	arc-insight_6_8-branchpoint:1.74
	insight_6_8-branch:1.74.0.4
	insight_6_8-branchpoint:1.74
	reverse-20081226-branch:1.80.0.4
	reverse-20081226-branchpoint:1.80
	multiprocess-20081120-branch:1.80.0.2
	multiprocess-20081120-branchpoint:1.80
	reverse-20080930-branch:1.79.0.2
	reverse-20080930-branchpoint:1.79
	reverse-20080717-branch:1.76.0.4
	reverse-20080717-branchpoint:1.76
	msnyder-reverse-20080609-branch:1.76.0.2
	msnyder-reverse-20080609-branchpoint:1.76
	drow-reverse-20070409-branch:1.65.0.2
	drow-reverse-20070409-branchpoint:1.65
	gdb_6_8-2008-03-27-release:1.74
	gdb_6_8-branch:1.74.0.2
	gdb_6_8-2008-02-26-branchpoint:1.74
	gdb_6_7_1-2007-10-29-release:1.67
	gdb_6_7-2007-10-10-release:1.67
	gdb_6_7-branch:1.67.0.2
	gdb_6_7-2007-09-07-branchpoint:1.67
	insight_6_6-20070208-release:1.64
	gdb_6_6-2006-12-18-release:1.64
	gdb_6_6-branch:1.64.0.18
	gdb_6_6-2006-11-15-branchpoint:1.64
	insight_6_5-20061003-release:1.64
	gdb-csl-symbian-6_4_50_20060226-12:1.64
	gdb-csl-sourcerygxx-3_4_4-25:1.63
	nickrob-async-20060828-mergepoint:1.64
	gdb-csl-symbian-6_4_50_20060226-11:1.64
	gdb-csl-sourcerygxx-4_1-17:1.64
	gdb-csl-20060226-branch-local-2:1.64
	gdb-csl-sourcerygxx-4_1-14:1.64
	gdb-csl-sourcerygxx-4_1-13:1.64
	gdb-csl-sourcerygxx-4_1-12:1.64
	gdb-csl-sourcerygxx-3_4_4-21:1.64
	gdb_6_5-20060621-release:1.64
	gdb-csl-sourcerygxx-4_1-9:1.64
	gdb-csl-sourcerygxx-4_1-8:1.64
	gdb-csl-sourcerygxx-4_1-7:1.64
	gdb-csl-arm-2006q1-6:1.64
	gdb-csl-sourcerygxx-4_1-6:1.64
	gdb-csl-symbian-6_4_50_20060226-10:1.64
	gdb-csl-symbian-6_4_50_20060226-9:1.64
	gdb-csl-symbian-6_4_50_20060226-8:1.64
	gdb-csl-coldfire-4_1-11:1.64
	gdb-csl-sourcerygxx-3_4_4-19:1.64
	gdb-csl-coldfire-4_1-10:1.64
	gdb_6_5-branch:1.64.0.16
	gdb_6_5-2006-05-14-branchpoint:1.64
	gdb-csl-sourcerygxx-4_1-5:1.64
	nickrob-async-20060513-branch:1.64.0.14
	nickrob-async-20060513-branchpoint:1.64
	gdb-csl-sourcerygxx-4_1-4:1.64
	msnyder-reverse-20060502-branch:1.64.0.12
	msnyder-reverse-20060502-branchpoint:1.64
	gdb-csl-morpho-4_1-4:1.64
	gdb-csl-sourcerygxx-3_4_4-17:1.64
	readline_5_1-import-branch:1.64.0.10
	readline_5_1-import-branchpoint:1.64
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.64
	gdb-csl-symbian-20060226-branch:1.64.0.8
	gdb-csl-symbian-20060226-branchpoint:1.64
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.64
	msnyder-reverse-20060331-branch:1.64.0.6
	msnyder-reverse-20060331-branchpoint:1.64
	gdb-csl-available-20060303-branch:1.64.0.4
	gdb-csl-available-20060303-branchpoint:1.64
	gdb-csl-20060226-branch:1.64.0.2
	gdb-csl-20060226-branchpoint:1.64
	gdb_6_4-20051202-release:1.63
	msnyder-fork-checkpoint-branch:1.63.0.8
	msnyder-fork-checkpoint-branchpoint:1.63
	gdb-csl-gxxpro-6_3-branch:1.63.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.63
	gdb_6_4-branch:1.63.0.4
	gdb_6_4-2005-11-01-branchpoint:1.63
	gdb-csl-arm-20051020-branch:1.63.0.2
	gdb-csl-arm-20051020-branchpoint:1.63
	msnyder-tracepoint-checkpoint-branch:1.60.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.60
	gdb-csl-arm-20050325-2005-q1b:1.59
	gdb-csl-arm-20050325-2005-q1a:1.59
	csl-arm-20050325-branch:1.59.0.2
	csl-arm-20050325-branchpoint:1.59
	gdb-post-i18n-errorwarning-20050211:1.55
	gdb-pre-i18n-errorwarning-20050211:1.54
	gdb_6_3-20041109-release:1.52
	gdb_6_3-branch:1.52.0.2
	gdb_6_3-20041019-branchpoint:1.52
	drow_intercu-merge-20040921:1.51
	drow_intercu-merge-20040915:1.51
	jimb-gdb_6_2-e500-branch:1.45.0.6
	jimb-gdb_6_2-e500-branchpoint:1.45
	gdb_6_2-20040730-release:1.45
	gdb_6_2-branch:1.45.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.45
	gdb_6_1_1-20040616-release:1.43
	gdb_6_1-2004-04-05-release:1.43
	drow_intercu-merge-20040402:1.43
	drow_intercu-merge-20040327:1.43
	ezannoni_pie-20040323-branch:1.43.0.10
	ezannoni_pie-20040323-branchpoint:1.43
	cagney_tramp-20040321-mergepoint:1.43
	cagney_tramp-20040309-branch:1.43.0.8
	cagney_tramp-20040309-branchpoint:1.43
	gdb_6_1-branch:1.43.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.43
	drow_intercu-20040221-branch:1.43.0.4
	drow_intercu-20040221-branchpoint:1.43
	cagney_bfdfile-20040213-branch:1.43.0.2
	cagney_bfdfile-20040213-branchpoint:1.43
	drow-cplus-merge-20040208:1.43
	carlton_dictionary-20040126-merge:1.43
	cagney_bigcore-20040122-branch:1.42.0.2
	cagney_bigcore-20040122-branchpoint:1.42
	drow-cplus-merge-20040113:1.42
	drow-cplus-merge-20031224:1.42
	drow-cplus-merge-20031220:1.42
	carlton_dictionary-20031215-merge:1.42
	drow-cplus-merge-20031214:1.42
	carlton-dictionary-20031111-merge:1.41
	gdb_6_0-2003-10-04-release:1.35
	kettenis_sparc-20030918-branch:1.37.0.4
	kettenis_sparc-20030918-branchpoint:1.37
	carlton_dictionary-20030917-merge:1.37
	ezannoni_pie-20030916-branchpoint:1.37
	ezannoni_pie-20030916-branch:1.37.0.2
	cagney_x86i386-20030821-branch:1.36.0.2
	cagney_x86i386-20030821-branchpoint:1.36
	carlton_dictionary-20030805-merge:1.35
	carlton_dictionary-20030627-merge:1.35
	gdb_6_0-branch:1.35.0.10
	gdb_6_0-2003-06-23-branchpoint:1.35
	jimb-ppc64-linux-20030613-branch:1.35.0.8
	jimb-ppc64-linux-20030613-branchpoint:1.35
	cagney_convert-20030606-branch:1.35.0.6
	cagney_convert-20030606-branchpoint:1.35
	cagney_writestrings-20030508-branch:1.33.0.10
	cagney_writestrings-20030508-branchpoint:1.33
	jimb-ppc64-linux-20030528-branch:1.35.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.35
	carlton_dictionary-20030523-merge:1.35
	cagney_fileio-20030521-branch:1.35.0.2
	cagney_fileio-20030521-branchpoint:1.35
	kettenis_i386newframe-20030517-mergepoint:1.34
	jimb-ppc64-linux-20030509-branch:1.33.0.8
	jimb-ppc64-linux-20030509-branchpoint:1.33
	kettenis_i386newframe-20030504-mergepoint:1.33
	carlton_dictionary-20030430-merge:1.33
	kettenis_i386newframe-20030419-branch:1.33.0.6
	kettenis_i386newframe-20030419-branchpoint:1.33
	carlton_dictionary-20030416-merge:1.33
	cagney_frameaddr-20030409-mergepoint:1.33
	kettenis_i386newframe-20030406-branch:1.33.0.4
	kettenis_i386newframe-20030406-branchpoint:1.33
	cagney_frameaddr-20030403-branchpoint:1.33
	cagney_frameaddr-20030403-branch:1.33.0.2
	cagney_framebase-20030330-mergepoint:1.32
	cagney_framebase-20030326-branch:1.32.0.2
	cagney_framebase-20030326-branchpoint:1.32
	cagney_lazyid-20030317-branch:1.31.0.10
	cagney_lazyid-20030317-branchpoint:1.31
	kettenis-i386newframe-20030316-mergepoint:1.31
	offbyone-20030313-branch:1.31.0.8
	offbyone-20030313-branchpoint:1.31
	kettenis-i386newframe-20030308-branch:1.31.0.6
	kettenis-i386newframe-20030308-branchpoint:1.31
	carlton_dictionary-20030305-merge:1.31
	cagney_offbyone-20030303-branch:1.31.0.4
	cagney_offbyone-20030303-branchpoint:1.31
	carlton_dictionary-20030207-merge:1.31
	interps-20030203-mergepoint:1.31
	interps-20030202-branch:1.31.0.2
	interps-20030202-branchpoint:1.31
	cagney-unwind-20030108-branch:1.30.0.2
	cagney-unwind-20030108-branchpoint:1.30
	carlton_dictionary-20021223-merge:1.29
	gdb_5_3-2002-12-12-release:1.26
	carlton_dictionary-20021115-merge:1.29
	kseitz_interps-20021105-merge:1.29
	kseitz_interps-20021103-merge:1.29
	drow-cplus-merge-20021020:1.29
	drow-cplus-merge-20021025:1.29
	carlton_dictionary-20021025-merge:1.29
	carlton_dictionary-20021011-merge:1.28
	drow-cplus-branch:1.28.0.4
	drow-cplus-branchpoint:1.28
	kseitz_interps-20020930-merge:1.28
	carlton_dictionary-20020927-merge:1.28
	carlton_dictionary-branch:1.28.0.2
	carlton_dictionary-20020920-branchpoint:1.28
	gdb_5_3-branch:1.26.0.6
	gdb_5_3-2002-09-04-branchpoint:1.26
	kseitz_interps-20020829-merge:1.26
	cagney_sysregs-20020825-branch:1.26.0.4
	cagney_sysregs-20020825-branchpoint:1.26
	readline_4_3-import-branch:1.26.0.2
	readline_4_3-import-branchpoint:1.26
	gdb_5_2_1-2002-07-23-release:1.22
	kseitz_interps-20020528-branch:1.24.0.4
	kseitz_interps-20020528-branchpoint:1.24
	cagney_regbuf-20020515-branch:1.24.0.2
	cagney_regbuf-20020515-branchpoint:1.24
	jimb-macro-020506-branch:1.23.0.2
	jimb-macro-020506-branchpoint:1.23
	gdb_5_2-2002-04-29-release:1.22
	gdb_5_2-branch:1.22.0.2
	gdb_5_2-2002-03-03-branchpoint:1.22
	gdb_5_1_1-2002-01-24-release:1.16
	gdb_5_1_0_1-2002-01-03-release:1.16
	cygnus_cvs_20020108_pre:1.17
	gdb_5_1_0_1-2002-01-03-branchpoint:1.16
	gdb_5_1_0_1-2002-01-03-branch:1.16.0.8
	gdb_5_1-2001-11-21-release:1.16
	gdb_s390-2001-09-26-branch:1.16.0.6
	gdb_s390-2001-09-26-branchpoint:1.16
	gdb_5_1-2001-07-29-branch:1.16.0.4
	gdb_5_1-2001-07-29-branchpoint:1.16
	dberlin-typesystem-branch:1.16.0.2
	dberlin-typesystem-branchpoint:1.16
	gdb-post-ptid_t-2001-05-03:1.15
	gdb-pre-ptid_t-2001-05-03:1.15
	insight-precleanup-2001-01-01:1.11
	gdb-post-protoization-2000-07-29:1.8
	gdb-pre-protoization-2000-07-29:1.7
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb-post-params-removal-2000-06-04:1.5
	gdb-pre-params-removal-2000-06-04:1.5
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.4
	gdb_5_0-2000-05-19-release:1.4
	gdb_4_18_2-2000-05-18-release:1.4
	gdb_4_95_1-2000-05-11-snapshot:1.4
	gdb_4_95_0-2000-04-27-snapshot:1.4
	gdb_5_0-2000-04-10-branch:1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.4
	repo-unification-2000-02-06:1.1.1.8
	insight-2000-02-04:1.1.1.8
	gdb-2000-02-04:1.1.1.8
	gdb-2000-02-02:1.1.1.8
	gdb-2000-02-01:1.1.1.8
	gdb-2000-01-31:1.1.1.7
	gdb-2000-01-26:1.1.1.7
	gdb-2000-01-24:1.1.1.7
	gdb-2000-01-17:1.1.1.7
	gdb-2000-01-10:1.1.1.7
	gdb-2000-01-05:1.1.1.7
	gdb-1999-12-21:1.1.1.7
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.5
	gdb-1999-12-06:1.1.1.5
	gdb-1999-11-16:1.1.1.5
	gdb-1999-11-08:1.1.1.5
	gdb-1999-11-01:1.1.1.5
	gdb-1999-10-25:1.1.1.5
	gdb-1999-10-18:1.1.1.5
	gdb-1999-10-11:1.1.1.5
	gdb-1999-10-04:1.1.1.5
	gdb-1999-09-28:1.1.1.5
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.5
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.5
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.115
date	2013.04.15.17.30.36;	author tromey;	state Exp;
branches;
next	1.114;

1.114
date	2013.01.01.06.32.46;	author brobecke;	state Exp;
branches;
next	1.113;

1.113
date	2012.11.12.17.14.55;	author tromey;	state Exp;
branches;
next	1.112;

1.112
date	2012.08.17.17.36.59;	author kseitz;	state Exp;
branches;
next	1.111;

1.111
date	2012.03.02.19.29.01;	author brobecke;	state Exp;
branches;
next	1.110;

1.110
date	2012.03.01.19.26.13;	author tromey;	state Exp;
branches;
next	1.109;

1.109
date	2012.03.01.19.22.22;	author tromey;	state Exp;
branches;
next	1.108;

1.108
date	2012.02.08.19.54.36;	author brobecke;	state Exp;
branches;
next	1.107;

1.107
date	2012.01.28.18.08.18;	author jkratoch;	state Exp;
branches;
next	1.106;

1.106
date	2012.01.26.04.20.36;	author brobecke;	state Exp;
branches;
next	1.105;

1.105
date	2012.01.04.18.57.01;	author devans;	state Exp;
branches;
next	1.104;

1.104
date	2012.01.04.08.17.05;	author brobecke;	state Exp;
branches;
next	1.103;

1.103
date	2011.12.06.18.54.39;	author tromey;	state Exp;
branches
	1.103.2.1;
next	1.102;

1.102
date	2011.02.22.18.53.45;	author tromey;	state Exp;
branches;
next	1.101;

1.101
date	2011.01.09.03.08.57;	author msnyder;	state Exp;
branches;
next	1.100;

1.100
date	2011.01.05.22.22.49;	author msnyder;	state Exp;
branches;
next	1.99;

1.99
date	2011.01.01.15.33.09;	author brobecke;	state Exp;
branches;
next	1.98;

1.98
date	2010.06.14.08.26.56;	author jkratoch;	state Exp;
branches;
next	1.97;

1.97
date	2010.06.11.15.36.04;	author tromey;	state Exp;
branches;
next	1.96;

1.96
date	2010.05.14.23.41.04;	author msnyder;	state Exp;
branches;
next	1.95;

1.95
date	2010.04.29.14.45.38;	author brobecke;	state Exp;
branches;
next	1.94;

1.94
date	2010.01.14.08.03.36;	author pmuldoon;	state Exp;
branches;
next	1.93;

1.93
date	2010.01.01.07.31.36;	author brobecke;	state Exp;
branches;
next	1.92;

1.92
date	2009.12.29.23.57.59;	author shebs;	state Exp;
branches;
next	1.91;

1.91
date	2009.09.25.21.39.52;	author tromey;	state Exp;
branches;
next	1.90;

1.90
date	2009.08.18.16.17.14;	author tromey;	state Exp;
branches;
next	1.89;

1.89
date	2009.08.14.00.32.32;	author palves;	state Exp;
branches;
next	1.88;

1.88
date	2009.08.13.14.58.26;	author palves;	state Exp;
branches;
next	1.87;

1.87
date	2009.08.13.14.56.19;	author palves;	state Exp;
branches;
next	1.86;

1.86
date	2009.08.07.23.28.13;	author tromey;	state Exp;
branches;
next	1.85;

1.85
date	2009.08.07.20.44.14;	author tromey;	state Exp;
branches;
next	1.84;

1.84
date	2009.05.23.16.17.17;	author jkratoch;	state Exp;
branches;
next	1.83;

1.83
date	2009.03.20.23.04.33;	author tromey;	state Exp;
branches;
next	1.82;

1.82
date	2009.02.05.12.16.25;	author bauermann;	state Exp;
branches;
next	1.81;

1.81
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.80;

1.80
date	2008.10.28.17.19.56;	author tromey;	state Exp;
branches;
next	1.79;

1.79
date	2008.09.30.17.21.27;	author tromey;	state Exp;
branches;
next	1.78;

1.78
date	2008.09.27.21.29.29;	author tromey;	state Exp;
branches;
next	1.77;

1.77
date	2008.09.11.14.11.40;	author uweigand;	state Exp;
branches;
next	1.76;

1.76
date	2008.05.19.15.50.09;	author uweigand;	state Exp;
branches;
next	1.75;

1.75
date	2008.04.06.08.56.36;	author vprus;	state Exp;
branches;
next	1.74;

1.74
date	2008.02.05.22.17.40;	author brobecke;	state Exp;
branches;
next	1.73;

1.73
date	2008.01.03.04.23.46;	author brobecke;	state Exp;
branches;
next	1.72;

1.72
date	2008.01.01.22.53.11;	author drow;	state Exp;
branches;
next	1.71;

1.71
date	2007.12.28.06.13.51;	author brobecke;	state Exp;
branches;
next	1.70;

1.70
date	2007.12.04.23.33.00;	author uweigand;	state Exp;
branches;
next	1.69;

1.69
date	2007.11.02.19.34.11;	author uweigand;	state Exp;
branches;
next	1.68;

1.68
date	2007.09.23.16.25.05;	author drow;	state Exp;
branches;
next	1.67;

1.67
date	2007.08.23.18.08.35;	author brobecke;	state Exp;
branches;
next	1.66;

1.66
date	2007.06.15.22.39.52;	author uweigand;	state Exp;
branches;
next	1.65;

1.65
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.64;

1.64
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.63;

1.63
date	2005.10.03.21.21.20;	author brobecke;	state Exp;
branches;
next	1.62;

1.62
date	2005.08.29.12.57.49;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2005.07.04.13.29.12;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2005.05.09.21.20.34;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2005.02.21.06.21.07;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2005.02.15.15.49.12;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2005.02.12.00.39.19;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2005.02.11.18.13.50;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2005.02.11.04.05.56;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2005.01.29.01.59.30;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2005.01.29.00.11.11;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2004.09.22.20.23.54;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2004.09.11.15.04.16;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2004.09.11.10.24.47;	author hilfingr;	state Exp;
branches;
next	1.49;

1.49
date	2004.08.29.10.12.24;	author dsl;	state Exp;
branches;
next	1.48;

1.48
date	2004.07.28.04.33.49;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.28.02.46.23;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2004.07.26.14.53.02;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2004.07.06.19.29.31;	author jjohnstn;	state Exp;
branches;
next	1.44;

1.44
date	2004.04.10.22.10.00;	author hilfingr;	state Exp;
branches;
next	1.43;

1.43
date	2004.01.23.23.03.29;	author carlton;	state Exp;
branches
	1.43.4.1;
next	1.42;

1.42
date	2003.11.23.20.41.17;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2003.11.08.00.13.02;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2003.10.06.22.37.37;	author brobecke;	state Exp;
branches;
next	1.39;

1.39
date	2003.10.06.22.21.52;	author brobecke;	state Exp;
branches;
next	1.38;

1.38
date	2003.09.25.08.40.45;	author hilfingr;	state Exp;
branches;
next	1.37;

1.37
date	2003.09.09.08.05.42;	author hilfingr;	state Exp;
branches;
next	1.36;

1.36
date	2003.08.07.22.35.03;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.20.01.55.17;	author carlton;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.14.17.43.18;	author ezannoni;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.02.03.02.46;	author fedor;	state Exp;
branches
	1.33.6.1
	1.33.10.1;
next	1.32;

1.32
date	2003.03.26.03.39.44;	author fedor;	state Exp;
branches;
next	1.31;

1.31
date	2003.01.14.00.49.04;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2003.01.02.14.27.26;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.12.16.03.30;	author fedor;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.19.03.58.41;	author cagney;	state Exp;
branches
	1.28.2.1
	1.28.4.1;
next	1.27;

1.27
date	2002.09.19.01.34.51;	author msnyder;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.01.17.18.32;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.11.13.50.49;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.12.04.20.05;	author cagney;	state Exp;
branches
	1.24.4.1;
next	1.23;

1.23
date	2002.03.28.01.35.55;	author msnyder;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.13.18.49.30;	author chastain;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.05.04.37.21;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.02.02.28.40;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.12.20.00.07;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.12.05.19.10;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.10.21.34.56;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.08.21.19.43;	author msnyder;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.27.20.36.23;	author jtc;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.06.08.21.09;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.15.01.01.47;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.15.07.08.11;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.11.01.02.35;	author guo;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.24.05.04.17;	author green;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.19.10.14.22;	author muller;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.28.01.12.28;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.17.10.19.22;	author phdm;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.04.05.11.19;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.04.04.56.46;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.103.2.1
date	2012.01.06.04.43.19;	author brobecke;	state Exp;
branches;
next	;

1.43.4.1
date	2004.09.16.17.01.09;	author drow;	state Exp;
branches;
next	;

1.33.6.1
date	2003.05.18.09.44.15;	author kettenis;	state Exp;
branches;
next	;

1.33.10.1
date	2003.06.03.20.54.38;	author cagney;	state Exp;
branches;
next	;

1.28.2.1
date	2002.10.25.23.49.54;	author carlton;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2002.11.24.18.47.18;	author carlton;	state Exp;
branches;
next	1.28.2.3;

1.28.2.3
date	2002.11.28.00.53.23;	author carlton;	state Exp;
branches;
next	1.28.2.4;

1.28.2.4
date	2003.02.07.19.17.50;	author carlton;	state Exp;
branches;
next	1.28.2.5;

1.28.2.5
date	2003.04.16.19.56.53;	author carlton;	state Exp;
branches;
next	1.28.2.6;

1.28.2.6
date	2003.05.23.18.40.41;	author carlton;	state Exp;
branches;
next	1.28.2.7;

1.28.2.7
date	2003.09.17.21.28.23;	author carlton;	state Exp;
branches;
next	1.28.2.8;

1.28.2.8
date	2003.11.11.23.50.48;	author carlton;	state Exp;
branches;
next	1.28.2.9;

1.28.2.9
date	2003.12.16.00.00.40;	author carlton;	state Exp;
branches;
next	1.28.2.10;

1.28.2.10
date	2004.01.26.19.11.27;	author carlton;	state Exp;
branches;
next	;

1.28.4.1
date	2002.10.26.17.12.08;	author drow;	state Exp;
branches;
next	1.28.4.2;

1.28.4.2
date	2003.12.14.20.27.20;	author drow;	state Exp;
branches;
next	1.28.4.3;

1.28.4.3
date	2004.02.09.19.43.41;	author drow;	state Exp;
branches;
next	;

1.24.4.1
date	2002.07.22.21.47.00;	author kseitz;	state Exp;
branches;
next	1.24.4.2;

1.24.4.2
date	2002.08.09.18.34.25;	author kseitz;	state Exp;
branches;
next	1.24.4.3;

1.24.4.3
date	2002.11.04.00.17.31;	author ezannoni;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.05.25.18.02.29;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.17.21.55;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.07.33;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.09.21.33.37;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.12.14.01.05.33;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.12.22.21.45.07;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2000.02.02.00.21.08;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.115
log
@	PR c++/11990:
	* c-lang.c (cplus_language_defn): Use gdb_demangle.
	* c-typeprint.c (c_type_print_base): Use gdb_demangle.
	* cp-support.c (mangled_name_to_comp): Use gdb_demangle.
	(gdb_demangle): New function.
	* cp-support.h (gdb_demangle): Declare.
	* dwarf2read.c (dwarf2_physname, fixup_partial_die)
	(dwarf2_name): Use gdb_demangle.
	* gdbtypes.c (check_stub_method): Use gdb_demangle.
	* gnu-v3-abi.c (gnuv3_rtti_type): Strip @@plt and version
	suffixes from name.
	(gnuv3_print_method_ptr): Use gdb_demangle.
	* jv-lang.c (java_demangle): Use gdb_demangle.
	* jv-typeprint.c (java_type_print_base): Use gdb_demangle.
	* language.c (unk_lang_demangle): Use gdb_demangle.
	* symtab.c (symbol_find_demangled_name)
	(demangle_for_lookup): Use gdb_demangle.
@
text
@/* Multiple source language support for GDB.

   Copyright (C) 1991-2013 Free Software Foundation, Inc.

   Contributed by the Department of Computer Science at the State University
   of New York at Buffalo.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This file contains functions that return things that are specific
   to languages.  Each function should examine current_language if necessary,
   and return the appropriate result.  */

/* FIXME:  Most of these would be better organized as macros which
   return data out of a "language-specific" struct pointer that is set
   whenever the working language changes.  That would be a lot faster.  */

#include "defs.h"
#include <ctype.h>
#include "gdb_string.h"

#include "symtab.h"
#include "gdbtypes.h"
#include "value.h"
#include "gdbcmd.h"
#include "expression.h"
#include "language.h"
#include "target.h"
#include "parser-defs.h"
#include "jv-lang.h"
#include "demangle.h"
#include "symfile.h"
#include "cp-support.h"

extern void _initialize_language (void);

static void unk_lang_error (char *);

static int unk_lang_parser (void);

static void show_check (char *, int);

static void set_check (char *, int);

static void set_range_case (void);

static void unk_lang_emit_char (int c, struct type *type,
				struct ui_file *stream, int quoter);

static void unk_lang_printchar (int c, struct type *type,
				struct ui_file *stream);

static void unk_lang_value_print (struct value *, struct ui_file *,
				  const struct value_print_options *);

static CORE_ADDR unk_lang_trampoline (struct frame_info *, CORE_ADDR pc);

/* Forward declaration */
extern const struct language_defn unknown_language_defn;

/* The current (default at startup) state of type and range checking.
   (If the modes are set to "auto", though, these are changed based
   on the default language at startup, and then again based on the
   language of the first source file.  */

enum range_mode range_mode = range_mode_auto;
enum range_check range_check = range_check_off;
enum case_mode case_mode = case_mode_auto;
enum case_sensitivity case_sensitivity = case_sensitive_on;

/* The current language and language_mode (see language.h).  */

const struct language_defn *current_language = &unknown_language_defn;
enum language_mode language_mode = language_mode_auto;

/* The language that the user expects to be typing in (the language
   of main(), or the last language we notified them about, or C).  */

const struct language_defn *expected_language;

/* The list of supported languages.  The list itself is malloc'd.  */

static const struct language_defn **languages;
static unsigned languages_size;
static unsigned languages_allocsize;
#define	DEFAULT_ALLOCSIZE 4

/* The current values of the "set language/type/range" enum
   commands.  */
static const char *language;
static const char *type;
static const char *range;
static const char *case_sensitive;

/* Warning issued when current_language and the language of the current
   frame do not match.  */
char lang_frame_mismatch_warn[] =
"Warning: the current language does not match this frame.";

/* This page contains the functions corresponding to GDB commands
   and their helpers.  */

/* Show command.  Display a warning if the language set
   does not match the frame.  */
static void
show_language_command (struct ui_file *file, int from_tty,
		       struct cmd_list_element *c, const char *value)
{
  enum language flang;		/* The language of the current frame.  */

  if (language_mode == language_mode_auto)
    fprintf_filtered (gdb_stdout,
		      _("The current source language is "
			"\"auto; currently %s\".\n"),
		      current_language->la_name);
  else
    fprintf_filtered (gdb_stdout,
		      _("The current source language is \"%s\".\n"),
		      current_language->la_name);

  flang = get_frame_language ();
  if (flang != language_unknown &&
      language_mode == language_mode_manual &&
      current_language->la_language != flang)
    printf_filtered ("%s\n", lang_frame_mismatch_warn);
}

/* Set command.  Change the current working language.  */
static void
set_language_command (char *ignore, int from_tty, struct cmd_list_element *c)
{
  int i;
  enum language flang;

  /* Search the list of languages for a match.  */
  for (i = 0; i < languages_size; i++)
    {
      if (strcmp (languages[i]->la_name, language) == 0)
	{
	  /* Found it!  Go into manual mode, and use this language.  */
	  if (languages[i]->la_language == language_auto)
	    {
	      /* Enter auto mode.  Set to the current frame's language, if
                 known, or fallback to the initial language.  */
	      language_mode = language_mode_auto;
	      flang = get_frame_language ();
	      if (flang != language_unknown)
		set_language (flang);
	      else
		set_initial_language ();
	      expected_language = current_language;
	      return;
	    }
	  else
	    {
	      /* Enter manual mode.  Set the specified language.  */
	      language_mode = language_mode_manual;
	      current_language = languages[i];
	      set_range_case ();
	      expected_language = current_language;
	      return;
	    }
	}
    }

  internal_error (__FILE__, __LINE__,
		  "Couldn't find language `%s' in known languages list.",
		  language);
}

/* Show command.  Display a warning if the range setting does
   not match the current language.  */
static void
show_range_command (struct ui_file *file, int from_tty,
		    struct cmd_list_element *c, const char *value)
{
  if (range_mode == range_mode_auto)
    {
      char *tmp;

      switch (range_check)
	{
	case range_check_on:
	  tmp = "on";
	  break;
	case range_check_off:
	  tmp = "off";
	  break;
	case range_check_warn:
	  tmp = "warn";
	  break;
	default:
	  internal_error (__FILE__, __LINE__,
			  "Unrecognized range check setting.");
	}

      fprintf_filtered (gdb_stdout,
			_("Range checking is \"auto; currently %s\".\n"),
			tmp);
    }
  else
    fprintf_filtered (gdb_stdout, _("Range checking is \"%s\".\n"),
		      value);

  if (range_check != current_language->la_range_check)
    warning (_("the current range check setting "
	       "does not match the language.\n"));
}

/* Set command.  Change the setting for range checking.  */
static void
set_range_command (char *ignore, int from_tty, struct cmd_list_element *c)
{
  if (strcmp (range, "on") == 0)
    {
      range_check = range_check_on;
      range_mode = range_mode_manual;
    }
  else if (strcmp (range, "warn") == 0)
    {
      range_check = range_check_warn;
      range_mode = range_mode_manual;
    }
  else if (strcmp (range, "off") == 0)
    {
      range_check = range_check_off;
      range_mode = range_mode_manual;
    }
  else if (strcmp (range, "auto") == 0)
    {
      range_mode = range_mode_auto;
      set_range_case ();
      return;
    }
  else
    {
      internal_error (__FILE__, __LINE__,
		      _("Unrecognized range check setting: \"%s\""), range);
    }
  if (range_check != current_language->la_range_check)
    warning (_("the current range check setting "
	       "does not match the language.\n"));
}

/* Show command.  Display a warning if the case sensitivity setting does
   not match the current language.  */
static void
show_case_command (struct ui_file *file, int from_tty,
		   struct cmd_list_element *c, const char *value)
{
  if (case_mode == case_mode_auto)
    {
      char *tmp = NULL;

      switch (case_sensitivity)
	{
	case case_sensitive_on:
	  tmp = "on";
	  break;
	case case_sensitive_off:
	  tmp = "off";
	  break;
	default:
	  internal_error (__FILE__, __LINE__,
			  "Unrecognized case-sensitive setting.");
	}

      fprintf_filtered (gdb_stdout,
			_("Case sensitivity in "
			  "name search is \"auto; currently %s\".\n"),
			tmp);
    }
  else
    fprintf_filtered (gdb_stdout,
		      _("Case sensitivity in name search is \"%s\".\n"),
		      value);

  if (case_sensitivity != current_language->la_case_sensitivity)
    warning (_("the current case sensitivity setting does not match "
	       "the language.\n"));
}

/* Set command.  Change the setting for case sensitivity.  */

static void
set_case_command (char *ignore, int from_tty, struct cmd_list_element *c)
{
   if (strcmp (case_sensitive, "on") == 0)
     {
       case_sensitivity = case_sensitive_on;
       case_mode = case_mode_manual;
     }
   else if (strcmp (case_sensitive, "off") == 0)
     {
       case_sensitivity = case_sensitive_off;
       case_mode = case_mode_manual;
     }
   else if (strcmp (case_sensitive, "auto") == 0)
     {
       case_mode = case_mode_auto;
       set_range_case ();
       return;
     }
   else
     {
       internal_error (__FILE__, __LINE__,
		       "Unrecognized case-sensitive setting: \"%s\"",
		       case_sensitive);
     }

   if (case_sensitivity != current_language->la_case_sensitivity)
     warning (_("the current case sensitivity setting does not match "
		"the language.\n"));
}

/* Set the status of range and type checking and case sensitivity based on
   the current modes and the current language.
   If SHOW is non-zero, then print out the current language,
   type and range checking status.  */
static void
set_range_case (void)
{
  if (range_mode == range_mode_auto)
    range_check = current_language->la_range_check;

  if (case_mode == case_mode_auto)
    case_sensitivity = current_language->la_case_sensitivity;
}

/* Set current language to (enum language) LANG.  Returns previous
   language.  */

enum language
set_language (enum language lang)
{
  int i;
  enum language prev_language;

  prev_language = current_language->la_language;

  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->la_language == lang)
	{
	  current_language = languages[i];
	  set_range_case ();
	  break;
	}
    }

  return prev_language;
}


/* Print out the current language settings: language, range and
   type checking.  If QUIETLY, print only what has changed.  */

void
language_info (int quietly)
{
  if (quietly && expected_language == current_language)
    return;

  expected_language = current_language;
  printf_unfiltered (_("Current language:  %s\n"), language);
  show_language_command (NULL, 1, NULL, NULL);

  if (!quietly)
    {
      printf_unfiltered (_("Range checking:    %s\n"), range);
      show_range_command (NULL, 1, NULL, NULL);
      printf_unfiltered (_("Case sensitivity:  %s\n"), case_sensitive);
      show_case_command (NULL, 1, NULL, NULL);
    }
}


/* Returns non-zero if the value is a pointer type.  */
int
pointer_type (struct type *type)
{
  return TYPE_CODE (type) == TYPE_CODE_PTR ||
    TYPE_CODE (type) == TYPE_CODE_REF;
}


/* This page contains functions that return info about
   (struct value) values used in GDB.  */

/* Returns non-zero if the value VAL represents a true value.  */
int
value_true (struct value *val)
{
  /* It is possible that we should have some sort of error if a non-boolean
     value is used in this context.  Possibly dependent on some kind of
     "boolean-checking" option like range checking.  But it should probably
     not depend on the language except insofar as is necessary to identify
     a "boolean" value (i.e. in C using a float, pointer, etc., as a boolean
     should be an error, probably).  */
  return !value_logical_not (val);
}

/* This page contains functions for the printing out of
   error messages that occur during type- and range-
   checking.  */

/* This is called when a language fails a range-check.  The
   first argument should be a printf()-style format string, and the
   rest of the arguments should be its arguments.  If range_check is
   range_check_on, an error is printed;  if range_check_warn, a warning;
   otherwise just the message.  */

void
range_error (const char *string,...)
{
  va_list args;

  va_start (args, string);
  switch (range_check)
    {
    case range_check_warn:
      vwarning (string, args);
      break;
    case range_check_on:
      verror (string, args);
      break;
    case range_check_off:
      /* FIXME: cagney/2002-01-30: Should this function print anything
         when range error is off?  */
      vfprintf_filtered (gdb_stderr, string, args);
      fprintf_filtered (gdb_stderr, "\n");
      break;
    default:
      internal_error (__FILE__, __LINE__, _("bad switch"));
    }
  va_end (args);
}


/* This page contains miscellaneous functions.  */

/* Return the language enum for a given language string.  */

enum language
language_enum (char *str)
{
  int i;

  for (i = 0; i < languages_size; i++)
    if (strcmp (languages[i]->la_name, str) == 0)
      return languages[i]->la_language;

  return language_unknown;
}

/* Return the language struct for a given language enum.  */

const struct language_defn *
language_def (enum language lang)
{
  int i;

  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->la_language == lang)
	{
	  return languages[i];
	}
    }
  return NULL;
}

/* Return the language as a string.  */
char *
language_str (enum language lang)
{
  int i;

  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->la_language == lang)
	{
	  return languages[i]->la_name;
	}
    }
  return "Unknown";
}

static void
set_check (char *ignore, int from_tty)
{
  printf_unfiltered (
     "\"set check\" must be followed by the name of a check subcommand.\n");
  help_list (setchecklist, "set check ", -1, gdb_stdout);
}

static void
show_check (char *ignore, int from_tty)
{
  cmd_show_list (showchecklist, from_tty, "");
}

/* Add a language to the set of known languages.  */

void
add_language (const struct language_defn *lang)
{
  /* For the "set language" command.  */
  static char **language_names = NULL;
  /* For the "help set language" command.  */
  char *language_set_doc = NULL;

  int i;
  struct ui_file *tmp_stream;

  if (lang->la_magic != LANG_MAGIC)
    {
      fprintf_unfiltered (gdb_stderr,
			  "Magic number of %s language struct wrong\n",
			  lang->la_name);
      internal_error (__FILE__, __LINE__,
		      _("failed internal consistency check"));
    }

  if (!languages)
    {
      languages_allocsize = DEFAULT_ALLOCSIZE;
      languages = (const struct language_defn **) xmalloc
	(languages_allocsize * sizeof (*languages));
    }
  if (languages_size >= languages_allocsize)
    {
      languages_allocsize *= 2;
      languages = (const struct language_defn **) xrealloc ((char *) languages,
				 languages_allocsize * sizeof (*languages));
    }
  languages[languages_size++] = lang;

  /* Build the language names array, to be used as enumeration in the
     set language" enum command.  */
  language_names = xrealloc (language_names,
			     (languages_size + 1) * sizeof (const char *));
  for (i = 0; i < languages_size; ++i)
    language_names[i] = languages[i]->la_name;
  language_names[i] = NULL;

  /* Build the "help set language" docs.  */
  tmp_stream = mem_fileopen ();

  fprintf_unfiltered (tmp_stream,
		      _("Set the current source language.\n"
			"The currently understood settings are:\n\nlocal or "
			"auto    Automatic setting based on source file\n"));

  for (i = 0; i < languages_size; ++i)
    {
      /* Already dealt with these above.  */
      if (languages[i]->la_language == language_unknown
	  || languages[i]->la_language == language_auto)
	continue;

      /* FIXME: i18n: for now assume that the human-readable name
	 is just a capitalization of the internal name.  */
      fprintf_unfiltered (tmp_stream, "%-16s Use the %c%s language\n",
			  languages[i]->la_name,
			  /* Capitalize first letter of language
			     name.  */
			  toupper (languages[i]->la_name[0]),
			  languages[i]->la_name + 1);
    }

  language_set_doc = ui_file_xstrdup (tmp_stream, NULL);
  ui_file_delete (tmp_stream);

  add_setshow_enum_cmd ("language", class_support,
			(const char **) language_names,
			&language,
			language_set_doc,
			_("Show the current source language."),
			NULL, set_language_command,
			show_language_command,
			&setlist, &showlist);

  xfree (language_set_doc);
}

/* Iterate through all registered languages looking for and calling
   any non-NULL struct language_defn.skip_trampoline() functions.
   Return the result from the first that returns non-zero, or 0 if all
   `fail'.  */
CORE_ADDR 
skip_language_trampoline (struct frame_info *frame, CORE_ADDR pc)
{
  int i;

  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->skip_trampoline)
	{
	  CORE_ADDR real_pc = (languages[i]->skip_trampoline) (frame, pc);

	  if (real_pc)
	    return real_pc;
	}
    }

  return 0;
}

/* Return demangled language symbol, or NULL.
   FIXME: Options are only useful for certain languages and ignored
   by others, so it would be better to remove them here and have a
   more flexible demangler for the languages that need it.
   FIXME: Sometimes the demangler is invoked when we don't know the
   language, so we can't use this everywhere.  */
char *
language_demangle (const struct language_defn *current_language, 
				const char *mangled, int options)
{
  if (current_language != NULL && current_language->la_demangle)
    return current_language->la_demangle (mangled, options);
  return NULL;
}

/* Return class name from physname or NULL.  */
char *
language_class_name_from_physname (const struct language_defn *lang,
				   const char *physname)
{
  if (lang != NULL && lang->la_class_name_from_physname)
    return lang->la_class_name_from_physname (physname);
  return NULL;
}

/* Return non-zero if TYPE should be passed (and returned) by
   reference at the language level.  */
int
language_pass_by_reference (struct type *type)
{
  return current_language->la_pass_by_reference (type);
}

/* Return zero; by default, types are passed by value at the language
   level.  The target ABI may pass or return some structs by reference
   independent of this.  */
int
default_pass_by_reference (struct type *type)
{
  return 0;
}

/* Return the default string containing the list of characters
   delimiting words.  This is a reasonable default value that
   most languages should be able to use.  */

char *
default_word_break_characters (void)
{
  return " \t\n!@@#$%^&*()+=|~`}{[]\"';:?/>.<,-";
}

/* Print the index of array elements using the C99 syntax.  */

void
default_print_array_index (struct value *index_value, struct ui_file *stream,
			   const struct value_print_options *options)
{
  fprintf_filtered (stream, "[");
  LA_VALUE_PRINT (index_value, stream, options);
  fprintf_filtered (stream, "] = ");
}

void
default_get_string (struct value *value, gdb_byte **buffer, int *length,
		    struct type **char_type, const char **charset)
{
  error (_("Getting a string is unsupported in this language."));
}

/* Define the language that is no language.  */

static int
unk_lang_parser (void)
{
  return 1;
}

static void
unk_lang_error (char *msg)
{
  error (_("Attempted to parse an expression with unknown language"));
}

static void
unk_lang_emit_char (int c, struct type *type, struct ui_file *stream,
		    int quoter)
{
  error (_("internal error - unimplemented "
	   "function unk_lang_emit_char called."));
}

static void
unk_lang_printchar (int c, struct type *type, struct ui_file *stream)
{
  error (_("internal error - unimplemented "
	   "function unk_lang_printchar called."));
}

static void
unk_lang_printstr (struct ui_file *stream, struct type *type,
		   const gdb_byte *string, unsigned int length,
		   const char *encoding, int force_ellipses,
		   const struct value_print_options *options)
{
  error (_("internal error - unimplemented "
	   "function unk_lang_printstr called."));
}

static void
unk_lang_print_type (struct type *type, const char *varstring,
		     struct ui_file *stream, int show, int level,
		     const struct type_print_options *flags)
{
  error (_("internal error - unimplemented "
	   "function unk_lang_print_type called."));
}

static void
unk_lang_val_print (struct type *type, const gdb_byte *valaddr,
		    int embedded_offset, CORE_ADDR address,
		    struct ui_file *stream, int recurse,
		    const struct value *val,
		    const struct value_print_options *options)
{
  error (_("internal error - unimplemented "
	   "function unk_lang_val_print called."));
}

static void
unk_lang_value_print (struct value *val, struct ui_file *stream,
		      const struct value_print_options *options)
{
  error (_("internal error - unimplemented "
	   "function unk_lang_value_print called."));
}

static CORE_ADDR unk_lang_trampoline (struct frame_info *frame, CORE_ADDR pc)
{
  return 0;
}

/* Unknown languages just use the cplus demangler.  */
static char *unk_lang_demangle (const char *mangled, int options)
{
  return gdb_demangle (mangled, options);
}

static char *unk_lang_class_name (const char *mangled)
{
  return NULL;
}

static const struct op_print unk_op_print_tab[] =
{
  {NULL, OP_NULL, PREC_NULL, 0}
};

static void
unknown_language_arch_info (struct gdbarch *gdbarch,
			    struct language_arch_info *lai)
{
  lai->string_char_type = builtin_type (gdbarch)->builtin_char;
  lai->bool_type_default = builtin_type (gdbarch)->builtin_int;
  lai->primitive_type_vector = GDBARCH_OBSTACK_CALLOC (gdbarch, 1,
						       struct type *);
}

const struct language_defn unknown_language_defn =
{
  "unknown",
  language_unknown,
  range_check_off,
  case_sensitive_on,
  array_row_major,
  macro_expansion_no,
  &exp_descriptor_standard,
  unk_lang_parser,
  unk_lang_error,
  null_post_parser,
  unk_lang_printchar,		/* Print character constant */
  unk_lang_printstr,
  unk_lang_emit_char,
  unk_lang_print_type,		/* Print a type using appropriate syntax */
  default_print_typedef,	/* Print a typedef using appropriate syntax */
  unk_lang_val_print,		/* Print a value using appropriate syntax */
  unk_lang_value_print,		/* Print a top-level value */
  default_read_var_value,	/* la_read_var_value */
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  "this",        	    	/* name_of_this */
  basic_lookup_symbol_nonlocal, /* lookup_symbol_nonlocal */
  basic_lookup_transparent_type,/* lookup_transparent_type */
  unk_lang_demangle,		/* Language specific symbol demangler */
  unk_lang_class_name,		/* Language specific
				   class_name_from_physname */
  unk_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays */
  0,				/* String lower bound */
  default_word_break_characters,
  default_make_symbol_completion_list,
  unknown_language_arch_info,	/* la_language_arch_info.  */
  default_print_array_index,
  default_pass_by_reference,
  default_get_string,
  NULL,				/* la_get_symbol_name_cmp */
  iterate_over_symbols,
  LANG_MAGIC
};

/* These two structs define fake entries for the "local" and "auto"
   options.  */
const struct language_defn auto_language_defn =
{
  "auto",
  language_auto,
  range_check_off,
  case_sensitive_on,
  array_row_major,
  macro_expansion_no,
  &exp_descriptor_standard,
  unk_lang_parser,
  unk_lang_error,
  null_post_parser,
  unk_lang_printchar,		/* Print character constant */
  unk_lang_printstr,
  unk_lang_emit_char,
  unk_lang_print_type,		/* Print a type using appropriate syntax */
  default_print_typedef,	/* Print a typedef using appropriate syntax */
  unk_lang_val_print,		/* Print a value using appropriate syntax */
  unk_lang_value_print,		/* Print a top-level value */
  default_read_var_value,	/* la_read_var_value */
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  "this",		        /* name_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal */
  basic_lookup_transparent_type,/* lookup_transparent_type */
  unk_lang_demangle,		/* Language specific symbol demangler */
  unk_lang_class_name,		/* Language specific
				   class_name_from_physname */
  unk_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays */
  0,				/* String lower bound */
  default_word_break_characters,
  default_make_symbol_completion_list,
  unknown_language_arch_info,	/* la_language_arch_info.  */
  default_print_array_index,
  default_pass_by_reference,
  default_get_string,
  NULL,				/* la_get_symbol_name_cmp */
  iterate_over_symbols,
  LANG_MAGIC
};

const struct language_defn local_language_defn =
{
  "local",
  language_auto,
  range_check_off,
  case_sensitive_on,
  array_row_major,
  macro_expansion_no,
  &exp_descriptor_standard,
  unk_lang_parser,
  unk_lang_error,
  null_post_parser,
  unk_lang_printchar,		/* Print character constant */
  unk_lang_printstr,
  unk_lang_emit_char,
  unk_lang_print_type,		/* Print a type using appropriate syntax */
  default_print_typedef,	/* Print a typedef using appropriate syntax */
  unk_lang_val_print,		/* Print a value using appropriate syntax */
  unk_lang_value_print,		/* Print a top-level value */
  default_read_var_value,	/* la_read_var_value */
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  "this", 		        /* name_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal */
  basic_lookup_transparent_type,/* lookup_transparent_type */
  unk_lang_demangle,		/* Language specific symbol demangler */
  unk_lang_class_name,		/* Language specific
				   class_name_from_physname */
  unk_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays */
  0,				/* String lower bound */
  default_word_break_characters,
  default_make_symbol_completion_list,
  unknown_language_arch_info,	/* la_language_arch_info.  */
  default_print_array_index,
  default_pass_by_reference,
  default_get_string,
  NULL,				/* la_get_symbol_name_cmp */
  iterate_over_symbols,
  LANG_MAGIC
};

/* Per-architecture language information.  */

static struct gdbarch_data *language_gdbarch_data;

struct language_gdbarch
{
  /* A vector of per-language per-architecture info.  Indexed by "enum
     language".  */
  struct language_arch_info arch_info[nr_languages];
};

static void *
language_gdbarch_post_init (struct gdbarch *gdbarch)
{
  struct language_gdbarch *l;
  int i;

  l = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct language_gdbarch);
  for (i = 0; i < languages_size; i++)
    {
      if (languages[i] != NULL
	  && languages[i]->la_language_arch_info != NULL)
	languages[i]->la_language_arch_info
	  (gdbarch, l->arch_info + languages[i]->la_language);
    }
  return l;
}

struct type *
language_string_char_type (const struct language_defn *la,
			   struct gdbarch *gdbarch)
{
  struct language_gdbarch *ld = gdbarch_data (gdbarch,
					      language_gdbarch_data);

  return ld->arch_info[la->la_language].string_char_type;
}

struct type *
language_bool_type (const struct language_defn *la,
		    struct gdbarch *gdbarch)
{
  struct language_gdbarch *ld = gdbarch_data (gdbarch,
					      language_gdbarch_data);

  if (ld->arch_info[la->la_language].bool_type_symbol)
    {
      struct symbol *sym;

      sym = lookup_symbol (ld->arch_info[la->la_language].bool_type_symbol,
			   NULL, VAR_DOMAIN, NULL);
      if (sym)
	{
	  struct type *type = SYMBOL_TYPE (sym);

	  if (type && TYPE_CODE (type) == TYPE_CODE_BOOL)
	    return type;
	}
    }

  return ld->arch_info[la->la_language].bool_type_default;
}

struct type *
language_lookup_primitive_type_by_name (const struct language_defn *la,
					struct gdbarch *gdbarch,
					const char *name)
{
  struct language_gdbarch *ld = gdbarch_data (gdbarch,
					      language_gdbarch_data);
  struct type *const *p;

  for (p = ld->arch_info[la->la_language].primitive_type_vector;
       (*p) != NULL;
       p++)
    {
      if (strcmp (TYPE_NAME (*p), name) == 0)
	return (*p);
    }
  return (NULL);
}

/* Initialize the language routines.  */

void
_initialize_language (void)
{
  static const char *const type_or_range_names[]
    = { "on", "off", "warn", "auto", NULL };

  static const char *const case_sensitive_names[]
    = { "on", "off", "auto", NULL };

  language_gdbarch_data
    = gdbarch_data_register_post_init (language_gdbarch_post_init);

  /* GDB commands for language specific stuff.  */

  add_prefix_cmd ("check", no_class, set_check,
		  _("Set the status of the type/range checker."),
		  &setchecklist, "set check ", 0, &setlist);
  add_alias_cmd ("c", "check", no_class, 1, &setlist);
  add_alias_cmd ("ch", "check", no_class, 1, &setlist);

  add_prefix_cmd ("check", no_class, show_check,
		  _("Show the status of the type/range checker."),
		  &showchecklist, "show check ", 0, &showlist);
  add_alias_cmd ("c", "check", no_class, 1, &showlist);
  add_alias_cmd ("ch", "check", no_class, 1, &showlist);

  add_setshow_enum_cmd ("range", class_support, type_or_range_names,
			&range,
			_("Set range checking.  (on/warn/off/auto)"),
			_("Show range checking.  (on/warn/off/auto)"),
			NULL, set_range_command,
			show_range_command,
			&setchecklist, &showchecklist);

  add_setshow_enum_cmd ("case-sensitive", class_support, case_sensitive_names,
			&case_sensitive, _("\
Set case sensitivity in name search.  (on/off/auto)"), _("\
Show case sensitivity in name search.  (on/off/auto)"), _("\
For Fortran the default is off; for other languages the default is on."),
			set_case_command,
			show_case_command,
			&setlist, &showlist);

  add_language (&auto_language_defn);
  add_language (&local_language_defn);
  add_language (&unknown_language_defn);

  language = xstrdup ("auto");
  type = xstrdup ("auto");
  range = xstrdup ("auto");
  case_sensitive = xstrdup ("auto");

  /* Have the above take effect.  */
  set_language (language_auto);
}
@


1.114
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d46 1
d768 1
a768 1
  return cplus_demangle (mangled, options);
@


1.113
log
@	* ada-lang.c (user_select_syms, ada_print_subexp): Pass flags
	to type-printing functions.
	* ada-lang.h (ada_print_type): Add argument.
	* ada-typeprint.c (print_array_type, print_variant_clauses,
	print_variant_part, print_selected_record_field_types,
	print_record_field_types, print_unchecked_union_type,
	print_func_type, ada_print_type): Add flags argument.
	(ada_print_typedef): Update.
	* c-exp.y (OPERATOR conversion_type_id): Update.
	* c-lang.h (c_print_type, c_type_print_base): Update.
	* c-typeprint.c (c_print_type, c_type_print_varspec_prefix,
	c_type_print_modifier, c_type_print_args,
	c_type_print_varspec_suffix, c_type_print_base): Add flags
	argument.
	* cp-valprint.c (cp_print_class_member): Update.
	* dwarf2read.c (dwarf2_compute_name): Update.
	* f-lang.h (f_print_type): Add argument.
	* f-typeprint.c (f_print_type): Add flags argument.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update.
	* go-lang.h (go_print_type): Add argument.
	* go-typeprint.c (go_print_type): Add flags argument.
	* jv-lang.h (java_print_type): Add argument.
	* jv-typeprint.c (java_type_print_base, java_print_type): Add
	flags argument.
	* language.c (unk_lang_print_type): Add flags argument.
	* language.h (struct language_defn) <la_print_type>: Add flags
	argument.
	(LA_PRINT_TYPE): Likewise.
	* m2-lang.h (m2_print_type): Add argument.
	* m2-typeprint.c (m2_print_type, m2_range, m2_typedef,
	m2_array, m2_pointer, m2_ref, m2_procedure, m2_long_set,
	m2_unbounded_array, m2_record_fields): Add flags argument.
	* p-lang.h (pascal_print_type, pascal_type_print_base,
	pascal_type_print_varspec_prefix): Add argument.
	* p-typeprint.c (pascal_print_type,
	pascal_type_print_varspec_prefix, pascal_print_func_args,
	pascal_type_print_varspec_suffix, pascal_type_print_base): Add
	flags argument.
	* symmisc.c (print_symbol): Update.
	* typeprint.c (type_print_raw_options, default_ptype_flags):
	New globals.
	(type_print): Update.
	* typeprint.h (struct type_print_options): New.
	(type_print_raw_options): Declare.
	(c_type_print_varspec_suffix, c_type_print_args): Add argument.
@
text
@d3 1
a3 2
   Copyright (C) 1991-1996, 1998-2005, 2007-2012 Free Software
   Foundation, Inc.
@


1.112
log
@	PR c++/13356
	* gdbtypes.c (strict_type_checking): New variable.
	(show_strict_type_checking): New function.
	(rank_one_type): Return NS_POINTER_INTEGER_CONVERSION_BADNESS
	if strict type checking is disabled.
	(_initialize_gdbtypes): Add "check type" subcommand.
	* gdbtypes.h (NS_INTEGER_POINTER_CONVERSION_BADNESS): New struct.

	PR c++/13356
	* gdb.base/default.exp: Update all "check type" tests.
	* gdb.base/help.exp: Likewise.
	* gdb.base/setshow.exp: Likewise.
	* gdb.cp/converts.cc (foo1_type_check): New function.
	(foo2_type_check): New function.
	(foo3_type_check): New function.
	(main): Call new functions.
	* converts.exp: Add tests for integer-to-pointer conversions
	with/without strict type-checking.

	PR c++/13356
	* gdb.texinfo (Type and Range Checking): Remove warning.
	Remove spurious commas.
	Update text and examples for re-implementation of set/show
	check type.
	(C and C++ Type and Range Checks): Likewise.

	* language.h (type_mode): Remove.
	(type_check): Remove.
	(struct language_defn): Remove la_type_check.
	(STRICT_TYPE): Remove unused macro.
	(type_error): Remove.
	* language.c (set_type_range_case): Renamed to ...
	(set_range_case): ... this.  Update all callers.
	Remove type_mode/type_check.
	(type_mode): Remove.
	(type_check): Remove.
	(show_type_command): Remove.
	(set_type_command): Remove.
	(language_info): Remove type checking output.
	(type_error): Remove unused function.
	(range_error): Update comment.
	(unknown_language_defn): Remove la_type_check.
	(auto_language_defn): Likewise.
	(local_language_defn): Likewise.
	(_initialize_language): Remove "check type" subcommand.
	* ada-lang.c (ada_language_defn): Remove la_type_check.
	* c-lang.c (c_language_defn): Likewise.
	(cplus_language_defn): Likewise.
	(asm_language_defn): Likewise.
	(minimal_language_defn): Likewise.
	* d-lang.c (d_language_defn): Likewise.
	* f-lang.c (f_language_defn): Likewise.
	* go-lang.c (go_language_defn): Likewise.
	* jv-lang.c (java_language_defn): Likewise.
	* m2-lang.c (m2_language_defn): Likewise.
	* objc-lang.c (objc_language_defn): Likewise.
	* opencl-lang.c (opencl_language_defn): Likewise.
	* p-lang.c (pascal_language_defn): Likewise.
@
text
@a65 3
static void unk_lang_print_type (struct type *, const char *, struct ui_file *,
				 int, int);

d734 2
a735 1
		     struct ui_file *stream, int show, int level)
@


1.111
log
@language-specific read_var_value for Ada renamings

The purpose of this patch is to better support renamings in the
"info locals" command. Consider ...

    procedure Foo is
       GV : Integer renames Pck.Global_Variable;
    begin
       Increment (GV); -- STOP
    end Foo;

... Pck.Global_Variable is just an integer. After having stopped at
the "STOP" line, "info locals" yields:

    (gdb) info locals
    gv = <error reading variable gv (Cannot access memory at address 0xffffffffffffffff)>

In reality, two things are happening:

   (1) Variable "GV" does not exist, which is normal, since there is
       "GV" the renaming of another variable;

   (2) But to allow the user access to that renaming the same way
       the code has, the compiler produces an artificial variable
       whose name encodes the renaming:

        gv___XR_pck__global_variable___XE

       For practical reasons, the artificial variable itself is given
       irrelevant types and addresses.

But the "info locals" command does not act as if it was a short-cut
of "foreach VAR in locals, print VAR". Instead it gets the value of
each VAR directly, which does not work in this case, since the variable
is artificial and needs to be decoded first.

This patch makes the "read_var_value" routine language-specific.
The old implementation of "read_var_value" gets renamed to
"default_read_var_value" and all languages now use it (unchanged
behavior), except for Ada. In Ada, the new function ada_read_var_value
checks if we have a renaming, and if so, evaluates its value, or else
defers to default_read_var_value.

gdb/ChangeLog:

        * language.h (struct language_defn): New "method" la_read_var_value.
        * findvar.c: #include "language.h".
        (default_read_var_value): Renames read_var_value.  Rewrite
        function description.
        (read_var_value): New function.
        * value.h (default_read_var_value): Add prototype.
        * ada-lang.c (ada_read_renaming_var_value, ada_read_var_value):
        New functions.
        (ada_language_defn): Add entry for la_read_var_value.
        * c-lang.c, d-lang.c, f-lang.c, jv-lang.c, language.c,
        * m2-lang.c, objc-lang.c, opencl-lang.c, p-lang.c: Update
        language_defn structures to add entry for new la_read_var_value
        field.
@
text
@d58 1
a58 1
static void set_type_range_case (void);
a83 2
enum type_mode type_mode = type_mode_auto;
enum type_check type_check = type_check_off;
d175 1
a175 1
	      set_type_range_case ();
a186 73
/* Show command.  Display a warning if the type setting does
   not match the current language.  */
static void
show_type_command (struct ui_file *file, int from_tty,
		   struct cmd_list_element *c, const char *value)
{
  if (type_mode == type_mode_auto)
    {
      char *tmp = NULL;

      switch (type_check)
	{
	case type_check_on:
	  tmp = "on";
	  break;
	case type_check_off:
	  tmp = "off";
	  break;
	case type_check_warn:
	  tmp = "warn";
	  break;
	default:
	  internal_error (__FILE__, __LINE__,
			  "Unrecognized type check setting.");
	}

      fprintf_filtered (gdb_stdout,
			_("Type checking is \"auto; currently %s\".\n"),
			tmp);
    }
  else
    fprintf_filtered (gdb_stdout, _("Type checking is \"%s\".\n"),
		      value);

   if (type_check != current_language->la_type_check)
    warning (_("the current type check setting"
	       " does not match the language.\n"));
}

/* Set command.  Change the setting for type checking.  */
static void
set_type_command (char *ignore, int from_tty, struct cmd_list_element *c)
{
  if (strcmp (type, "on") == 0)
    {
      type_check = type_check_on;
      type_mode = type_mode_manual;
    }
  else if (strcmp (type, "warn") == 0)
    {
      type_check = type_check_warn;
      type_mode = type_mode_manual;
    }
  else if (strcmp (type, "off") == 0)
    {
      type_check = type_check_off;
      type_mode = type_mode_manual;
    }
  else if (strcmp (type, "auto") == 0)
    {
      type_mode = type_mode_auto;
      set_type_range_case ();
      return;
    }
  else
    internal_error (__FILE__, __LINE__,
		    _("Unrecognized type check setting: \"%s\""), type);

  if (type_check != current_language->la_type_check)
    warning (_("the current type check setting"
	       " does not match the language.\n"));
}

d248 1
a248 1
      set_type_range_case ();
d317 1
a317 1
       set_type_range_case ();
d337 1
a337 1
set_type_range_case (void)
a341 3
  if (type_mode == type_mode_auto)
    type_check = current_language->la_type_check;

d362 1
a362 1
	  set_type_range_case ();
a385 2
      printf_unfiltered (_("Type checking:     %s\n"), type);
      show_type_command (NULL, 1, NULL, NULL);
d423 1
a423 1
/* These are called when a language fails a type- or range-check.  The
d425 3
a427 30
   rest of the arguments should be its arguments.  If
   [type|range]_check is [type|range]_check_on, an error is printed;
   if [type|range]_check_warn, a warning; otherwise just the
   message.  */

void
type_error (const char *string,...)
{
  va_list args;

  va_start (args, string);
  switch (type_check)
    {
    case type_check_warn:
      vwarning (string, args);
      break;
    case type_check_on:
      verror (string, args);
      break;
    case type_check_off:
      /* FIXME: cagney/2002-01-30: Should this function print anything
         when type error is off?  */
      vfprintf_filtered (gdb_stderr, string, args);
      fprintf_filtered (gdb_stderr, "\n");
      break;
    default:
      internal_error (__FILE__, __LINE__, _("bad switch"));
    }
  va_end (args);
}
a797 1
  type_check_off,
a840 1
  type_check_off,
a881 1
  type_check_off,
a1027 7
  add_setshow_enum_cmd ("type", class_support, type_or_range_names, &type,
			_("Set type checking.  (on/warn/off/auto)"),
			_("Show type checking.  (on/warn/off/auto)"),
			NULL, set_type_command,
			show_type_command,
			&setchecklist, &showchecklist);

@


1.110
log
@	* valprint.c (val_print): Update.
	* p-valprint (pascal_val_print): Return void.
	* p-lang.h (pascal_val_print): Return void.
	* m2-valprint.c (m2_val_print): Return void.
	* m2-lang.h (m2_val_print): Return void.
	* language.h (struct language_defn) <la_val_print>: Return void.
	* language.c (unk_lang_val_print): Return void.
	* jv-valprint.c (java_val_print): Return void.
	* jv-lang.h (java_val_print): Return void.
	* f-valprint.c (f_val_print): Return void.
	* f-lang.h (f_val_print): Return void.
	* d-valprint.c (d_val_print): Return void.
	(dynamic_array_type): Update.
	* d-lang.h (d_val_print): Return void.
	* c-valprint.c (c_val_print): Return void.
	* c-lang.h (c_val_print): Return void.
	* ada-valprint.c (ada_vada_val_print, ada_val_print_1): Return
	void.
	* ada-lang.h (ada_val_print): Return void.
@
text
@d920 1
d964 1
d1006 1
@


1.109
log
@	* value.h (value_print): Return void.
	* valprint.c (value_print): Return void.
	* p-valprint.c (pascal_value_print): Return void.
	* p-lang.h (pascal_value_print): Return void.
	* language.h (struct language_defn) <la_value_print>: Return
	void.
	* language.c (unk_lang_value_print): Return void.
	* jv-valprint.c (java_value_print): Return void.
	* jv-lang.h (java_value_print): Return void.
	* f-valprint.c (c_value_print): Don't declare.
	Include c-lang.h.
	* c-valprint.c (c_value_print): Return void.
	* c-lang.h (c_value_print): Return void.
	* ada-valprint.c (ada_value_print): Return void.
	* ada-lang.h (ada_value_print): Return void.
@
text
@d850 1
a850 1
static int
@


1.108
log
@Rename la_get_symbol_name_match_p into la_get_symbol_name_cmp

The la_get_symbol_name_match_p language hook was poorly named, as
it suggested that the function should return nonzero if the names
match, whereas it is the exact opposite.  This patch therefore
renames the hook and associated typedef, as well some of the code
that uses that hook.

gdb/ChangeLog:

        * language.h (symbol_name_cmp_ftype): Renames
        symbol_name_match_p_ftype.
        (struct language_defn)[la_get_symbol_name_cmp]: Renames
        la_get_symbol_name_match_p.
        * ada-lang.c (ada_get_symbol_name_cmp): Renames
        ada_get_symbol_name_match_p.  Update comment.
        (ada_language_defn)[la_get_symbol_name_cmp]: Update value.
        * linespec.c (struct symbol_matcher_data)[symbol_name_cmp]:
        Renames symbol_name_match_p.  Update field type.
        (iterate_name_matcher, iterate_over_all_matching_symtabs): Adjust.
        * c-lang.c, d-lang.c, f-lang.c, jv-lang.c, m2-lang.c, objc-lang.c,
        opencl-lang.c, p-lang.c: Replace "la_get_symbol_name_match_p" by
        "la_get_symbol_name_cmp" in comments.
        * language.c: Likewise.
@
text
@d69 2
a70 2
static int unk_lang_value_print (struct value *, struct ui_file *,
				 const struct value_print_options *);
d861 1
a861 1
static int
@


1.107
log
@gdb/
	Code cleanup: Make 1440 bytes of data segment read-only.
	* arch-utils.c (endian_enum): Make it const char *const [].
	* arm-tdep.c (fp_model_strings, arm_abi_strings, arm_mode_strings):
	Likewise.
	* breakpoint.c (always_inserted_enums): Likewise.
	* cli/cli-cmds.c (script_ext_enums): Likewise.
	* cli/cli-decode.c (add_setshow_enum_cmd, complete_on_enum): Make the
	enumlist parameter const char *const *.
	* cli/cli-decode.h (struct cmd_list_element): Make the enums field
	const char *const *.
	* command.h (complete_on_enum, add_setshow_enum_cmd): Make the enumlist
	parameter const char *const *.
	* cris-tdep.c (cris_modes): Make it const char *const [].
	* filesystem.c (target_file_system_kinds): Likewise.
	* i386-tdep.c (valid_flavors, valid_conventions): Likewise.
	* infrun.c (follow_fork_mode_kind_names, follow_exec_mode_names)
	(can_use_displaced_stepping_enum, scheduler_enums)
	(exec_direction_names): Likewise.
	* language.c (_initialize_language): Make the type_or_range_names and
	case_sensitive_names variables const char *const [].
	* mips-tdep.c (mips_abi_strings): Make it const char *const [].
	* python/python.c (python_excp_enums): Likewise.
	* remote.c (interrupt_sequence_modes): Likewise.
	* rs6000-tdep.c (powerpc_vector_strings): Likewise.
	* serial.c (logbase_enums): Likewise.
	* sh-tdep.c (sh_cc_enum): Likewise.
	* stack.c (print_frame_arguments_choices, print_entry_values_choices):
	Likewise.
	* symtab.c (multiple_symbols_modes): Likewise.
	* tui/tui-win.c (tui_border_kind_enums, tui_border_mode_enums):
	Likewise.
	* utils.c (internal_problem_modes): Likewise.
@
text
@d936 1
a936 1
  NULL,				/* la_get_symbol_name_match_p */
d979 1
a979 1
  NULL,				/* la_get_symbol_name_match_p */
d1020 1
a1020 1
  NULL,				/* la_get_symbol_name_match_p */
@


1.106
log
@Ada: allow unqualified function names in linespecs

This is the meat, where we replace the old la_symbol_name_compare
language method with the new ada_get_symbol_name_match_p.
It fixes the problem when trying to insert a breakpoint on "+".

gdb/ChangeLog:

        * language.h (symbol_name_match_p_ftype): New typedef.
        (struct language_defn): Replace field la_symbol_name_compare
        by la_get_symbol_name_match_p.
        * ada-lang.c (ada_get_symbol_name_match_p): New function.
        (ada_language_defn): Use it.
        * linespec.c (struct symbol_matcher_data): New type.
        (iterate_name_matcher): Rewrite.
        (iterate_over_all_matching_symtabs): Pass a pointer to
        a symbol_matcher_data struct to expand_symtabs_matching
        instead of just the lookup name.
        * c-lang.c, d-lang.c, jv-lang.c, m2-lang.c, objc-lang.c,
        opencl-lang.c, p-lang.c, language.c: Delete field
        la_symbol_name_compare, and replace by NULL for new field
        la_get_symbol_name_match_p.
        * symfile.h (struct quick_symbol_functions): Update comment.
@
text
@d1112 1
a1112 1
  static const char *type_or_range_names[]
d1115 1
a1115 1
  static const char *case_sensitive_names[]
@


1.105
log
@	Delete #if 0'd out code.
	* language.c (binop_result_type): Delete.
	(simple_type, ordered_type, same_type, integral_type): Delete.
	(numeric_type, character_type, string_type, boolean_type): Delete.
	(float_type, structured_type): Delete.
	* language.h: Update.
@
text
@d936 1
a936 1
  strcmp_iw_ordered,
d979 1
a979 1
  strcmp_iw_ordered,
d1020 1
a1020 1
  strcmp_iw_ordered,
@


1.104
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a472 237
/* Return the result of a binary operation.  */

#if 0				/* Currently unused */

struct type *
binop_result_type (struct value *v1, struct value *v2)
{
  int size, uns;
  struct type *t1 = check_typedef (VALUE_TYPE (v1));
  struct type *t2 = check_typedef (VALUE_TYPE (v2));

  int l1 = TYPE_LENGTH (t1);
  int l2 = TYPE_LENGTH (t2);

  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
    case language_d:
    case language_objc:
      if (TYPE_CODE (t1) == TYPE_CODE_FLT)
	return TYPE_CODE (t2) == TYPE_CODE_FLT && l2 > l1 ?
	  VALUE_TYPE (v2) : VALUE_TYPE (v1);
      else if (TYPE_CODE (t2) == TYPE_CODE_FLT)
	return TYPE_CODE (t1) == TYPE_CODE_FLT && l1 > l2 ?
	  VALUE_TYPE (v1) : VALUE_TYPE (v2);
      else if (TYPE_UNSIGNED (t1) && l1 > l2)
	return VALUE_TYPE (v1);
      else if (TYPE_UNSIGNED (t2) && l2 > l1)
	return VALUE_TYPE (v2);
      else			/* Both are signed.  Result is the
				   longer type.  */
	return l1 > l2 ? VALUE_TYPE (v1) : VALUE_TYPE (v2);
      break;
    case language_m2:
      /* If we are doing type-checking, l1 should equal l2, so this is
         not needed.  */
      return l1 > l2 ? VALUE_TYPE (v1) : VALUE_TYPE (v2);
      break;
    }
  internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
  return (struct type *) 0;	/* For lint */
}

#endif /* 0 */
#if 0
/* This page contains functions that are used in type/range checking.
   They all return zero if the type/range check fails.

   It is hoped that these will make extending GDB to parse different
   languages a little easier.  These are primarily used in eval.c when
   evaluating expressions and making sure that their types are correct.
   Instead of having a mess of conjucted/disjuncted expressions in an "if",
   the ideas of type can be wrapped up in the following functions.

   Note that some of them are not currently dependent upon which language
   is currently being parsed.  For example, floats are the same in
   C and Modula-2 (ie. the only floating point type has TYPE_CODE of
   TYPE_CODE_FLT), while booleans are different.  */

/* Returns non-zero if its argument is a simple type.  This is the same for
   both Modula-2 and for C.  In the C case, TYPE_CODE_CHAR will never occur,
   and thus will never cause the failure of the test.  */
int
simple_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_FLT:
    case TYPE_CODE_RANGE:
    case TYPE_CODE_BOOL:
      return 1;

    default:
      return 0;
    }
}

/* Returns non-zero if its argument is of an ordered type.
   An ordered type is one in which the elements can be tested for the
   properties of "greater than", "less than", etc, or for which the
   operations "increment" or "decrement" make sense.  */
int
ordered_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_FLT:
    case TYPE_CODE_RANGE:
      return 1;

    default:
      return 0;
    }
}

/* Returns non-zero if the two types are the same.  */
int
same_type (struct type *arg1, struct type *arg2)
{
  CHECK_TYPEDEF (type);
  if (structured_type (arg1)
      ? !structured_type (arg2) : structured_type (arg2))
    /* One is structured and one isn't.  */
    return 0;
  else if (structured_type (arg1) && structured_type (arg2))
    return arg1 == arg2;
  else if (numeric_type (arg1) && numeric_type (arg2))
    return (TYPE_CODE (arg2) == TYPE_CODE (arg1)) &&
      (TYPE_UNSIGNED (arg1) == TYPE_UNSIGNED (arg2))
      ? 1 : 0;
  else
    return arg1 == arg2;
}

/* Returns non-zero if the type is integral.  */
int
integral_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
    case language_d:
    case language_objc:
      return (TYPE_CODE (type) != TYPE_CODE_INT) &&
	(TYPE_CODE (type) != TYPE_CODE_ENUM) ? 0 : 1;
    case language_m2:
    case language_pascal:
      return TYPE_CODE (type) != TYPE_CODE_INT ? 0 : 1;
    default:
      error (_("Language not supported."));
    }
}

/* Returns non-zero if the value is numeric.  */
int
numeric_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_FLT:
      return 1;

    default:
      return 0;
    }
}

/* Returns non-zero if the value is a character type.  */
int
character_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (current_language->la_language)
    {
    case language_m2:
    case language_pascal:
      return TYPE_CODE (type) != TYPE_CODE_CHAR ? 0 : 1;

    case language_c:
    case language_cplus:
    case language_d:
    case language_objc:
      return (TYPE_CODE (type) == TYPE_CODE_INT) &&
	TYPE_LENGTH (type) == sizeof (char)
      ? 1 : 0;
    default:
      return (0);
    }
}

/* Returns non-zero if the value is a string type.  */
int
string_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (current_language->la_language)
    {
    case language_m2:
    case language_pascal:
      return TYPE_CODE (type) != TYPE_CODE_STRING ? 0 : 1;

    case language_c:
    case language_cplus:
    case language_d:
    case language_objc:
      /* C does not have distinct string type.  */
      return (0);
    default:
      return (0);
    }
}

/* Returns non-zero if the value is a boolean type.  */
int
boolean_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  if (TYPE_CODE (type) == TYPE_CODE_BOOL)
    return 1;
  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
    case language_d:
    case language_objc:
      /* Might be more cleanly handled by having a
         TYPE_CODE_INT_NOT_BOOL for (the deleted) CHILL and such
         languages, or a TYPE_CODE_INT_OR_BOOL for C.  */
      if (TYPE_CODE (type) == TYPE_CODE_INT)
	return 1;
    default:
      break;
    }
  return 0;
}

/* Returns non-zero if the value is a floating-point type.  */
int
float_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  return TYPE_CODE (type) == TYPE_CODE_FLT;
}
#endif
a481 29
#if 0
/* Returns non-zero if the value is a structured type.  */
int
structured_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
    case language_d:
    case language_objc:
      return (TYPE_CODE (type) == TYPE_CODE_STRUCT) ||
	(TYPE_CODE (type) == TYPE_CODE_UNION) ||
	(TYPE_CODE (type) == TYPE_CODE_ARRAY);
   case language_pascal:
      return (TYPE_CODE(type) == TYPE_CODE_STRUCT) ||
	 (TYPE_CODE(type) == TYPE_CODE_UNION) ||
	 (TYPE_CODE(type) == TYPE_CODE_SET) ||
	    (TYPE_CODE(type) == TYPE_CODE_ARRAY);
    case language_m2:
      return (TYPE_CODE (type) == TYPE_CODE_STRUCT) ||
	(TYPE_CODE (type) == TYPE_CODE_SET) ||
	(TYPE_CODE (type) == TYPE_CODE_ARRAY);
    default:
      return (0);
    }
}
#endif
@


1.103
log
@the "ambiguous linespec" series
gdb
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * language.h (struct language_defn): Add new component
        la_symbol_name_compare.
        * symfile.h (struct quick_symbol_functions): Update the profile
        of parameter "name_matcher" for the expand_symtabs_matching
        method.  Update the documentation accordingly.
        * ada-lang.h (ada_name_for_lookup): Add declaration.
        * ada-lang.c (ada_name_for_lookup): New function, extracted out
        from ada_iterate_over_symbols.
        (ada_iterate_over_symbols): Do not encode symbol name anymore.
        (ada_expand_partial_symbol_name): Adjust profile.
        (ada_language_defn): Add value for la_symbol_name_compare field.
        * linespec.c: #include "ada-lang.h".
        (iterate_name_matcher): Add language parameter. Replace call
        to strcmp_iw by call to language->la_symbol_name_compare.
        (decode_variable): Encode COPY if current language is Ada.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust profile
        of name_matcher parameter.  Adjust call to name_matcher.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (expand_partial_symbol_names): Update profile of parameter "fun".
        * psymtab.h (expand_partial_symbol_names): Update profile of
        parameter "fun".
        * symtab.c (demangle_for_lookup): Update function documentation.
        (search_symbols_name_matches): Add language parameter.
        (expand_partial_symbol_name): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn)
        (asm_language_defn, minimal_language_defn): Add value for
        la_symbol_name_compare field.
        * d-lang.c (d_language_defn): Likewise.
        * f-lang.c (f_language_defn): Ditto.
        * jv-lang.c (java_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * opencl-lang.c (opencl_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * language.c (unknown_language_defn, auto_language_defn)
        (local_language_defn): Ditto.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* linespec.c (iterate_over_all_matching_symtabs): Use
	LA_ITERATE_OVER_SYMBOLS.
	(lookup_prefix_sym, add_matching_symbols_to_info): Likewise.
	(find_function_symbols, decode_variable): Remove Ada special
	case.
	* language.h (struct language_defn) <la_iterate_over_symbols>: New
	field.
	(LA_ITERATE_OVER_SYMBOLS): New macro.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Update.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Update.
	* d-lang.c (d_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* m2-lang.c (m2_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* opencl-lang.c (opencl_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* ada-lang.c (ada_iterate_over_symbols): New function.
	(ada_language_defn): Update.

2011-12-06  Tom Tromey  <tromey@@redhat.com>
	    Joel Brobecker  <brobecker@@acacore.com>

	PR breakpoints/13105, PR objc/8341, PR objc/8343, PR objc/8366,
	PR objc/8535, PR breakpoints/11657, PR breakpoints/11970,
	PR breakpoints/12023, PR breakpoints/12334, PR breakpoints/12856,
	PR shlibs/8929, PR shlibs/7393:
	* python/py-type.c (compare_maybe_null_strings): Rename from
	compare_strings.
	(check_types_equal): Update.
	* utils.c (compare_strings): New function.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Update for
	location changes.
	* tracepoint.c (scope_info): Update.
	(trace_find_line_command): Use DECODE_LINE_FUNFIRSTLINE.
	* symtab.h (iterate_over_minimal_symbols)
	(iterate_over_some_symtabs, iterate_over_symtabs)
	(find_pcs_for_symtab_line, iterate_over_symbols)
	(demangle_for_lookup): Declare.
	(expand_line_sal): Remove.
	* symtab.c (iterate_over_some_symtabs, iterate_over_symtabs)
	(lookup_symtab_callback): New functions.
	(lookup_symtab): Rewrite.
	(demangle_for_lookup): New function, extract from
	lookup_symbol_in_language.
	(lookup_symbol_in_language): Use it.
	(iterate_over_symbols): New function.
	(find_line_symtab): Update.
	(find_pcs_for_symtab_line): New functions.
	(find_line_common): Add 'start' argument.
	(decode_line_spec): Update.  Change argument to 'flags', change
	interpretation.
	(append_expanded_sal): Remove.
	(append_exact_match_to_sals): Remove.
	(expand_line_sal): Remove.
	* symfile.h (struct quick_symbol_functions) <lookup_symtab>:
	Remove.
	<map_symtabs_matching_filename>: New field.
	* stack.c (func_command): Only look in the current program space.
	Use DECODE_LINE_FUNFIRSTLINE.
	* source.c (line_info): Set pspace on sal.  Check program space in
	the loop.  Use DECODE_LINE_LIST_MODE.
	(select_source_symtab): Use DECODE_LINE_FUNFIRSTLINE.
	* solib-target.c: Remove DEF_VEC_I(CORE_ADDR).
	* python/python.c (gdbpy_decode_line): Update.
	* psymtab.c (partial_map_expand_apply): New function.
	(partial_map_symtabs_matching_filename): Rename from
	lookup_partial_symbol.  Update arguments.
	(lookup_symtab_via_partial_symtab): Remove.
	(psym_functions): Update.
	* objc-lang.h (parse_selector, parse_method): Don't declare.
	(find_imps): Update.
	* objc-lang.c (parse_selector, parse_method): Now static.
	(find_methods): Change arguments.  Fill in a vector of symbol
	names.
	(uniquify_strings): New function.
	(find_imps): Change arguments.
	* minsyms.c (iterate_over_minimal_symbols): New function.
	* linespec.h (enum decode_line_flags): New.
	(struct linespec_sals): New.
	(struct linespec_result) <canonical>: Remove.
	<pre_expanded, addr_string, sals>: New fields.
	(destroy_linespec_result, make_cleanup_destroy_linespec_result)
	(decode_line_full): Declare.
	(decode_line_1): Update.
	* linespec.c (struct address_entry, struct linespec_state, struct
	collect_info): New types.
	(add_sal_to_sals_basic, add_sal_to_sals, hash_address_entry)
	(eq_address_entry, maybe_add_address): New functions.
	(total_number_of_methods): Remove.
	(iterate_name_matcher, iterate_over_all_matching_symtabs): New
	functions.
	(find_methods): Change arguments.  Don't canonicalize input.
	Simplify logic.
	(add_matching_methods, add_constructors)
	(build_canonical_line_spec): Remove.
	(filter_results, convert_results_to_lsals): New functions.
	(decode_line_2): Change arguments.  Rewrite for new data
	structures.
	(decode_line_internal): Rename from decode_line_1.  Change
	arguments.  Add cleanups.  Update for new data structures.
	(linespec_state_constructor, linespec_state_destructor)
	(decode_line_full, decode_line_1): New functions.
	(decode_indirect): Change arguments.  Update.
	(locate_first_half): Use skip_spaces.
	(decode_objc): Change arguments.  Update for new data structures.
	Simplify logic.
	(decode_compound): Change arguments.  Add cleanups.  Remove
	fallback code, replace with error.
	(struct decode_compound_collector): New type.
	(collect_one_symbol): New function.
	(lookup_prefix_sym): Change arguments.  Update.
	(compare_symbol_name, add_all_symbol_names_from_pspace)
	(find_superclass_methods ): New functions.
	(find_method): Rewrite.
	(struct symtab_collector): New type.
	(add_symtabs_to_list, collect_symtabs_from_filename): New
	functions.
	(symtabs_from_filename): Change API.  Rename from
	symtab_from_filename.
	(collect_function_symbols): New function.
	(find_function_symbols): Change API.  Rename from
	find_function_symbol.  Rewrite.
	(decode_all_digits): Change arguments.  Rewrite.
	(decode_dollar): Change arguments.  Use decode_variable.
	(decode_label): Change arguments.  Rewrite.
	(collect_symbols): New function.
	(minsym_found): Change arguments.  Rewrite.
	(check_minsym, search_minsyms_for_name)
	(add_matching_symbols_to_info): New function.
	(decode_variable): Change arguments.  Iterate over all symbols.
	(symbol_found): Remove.
	(symbol_to_sal): New function.
	(init_linespec_result, destroy_linespec_result)
	(cleanup_linespec_result, make_cleanup_destroy_linespec_result):
	New functions.
	(decode_digits_list_mode, decode_digits_ordinary): New functions.
	* dwarf2read.c (dw2_map_expand_apply): New function.
	(dw2_map_symtabs_matching_filename): Rename from
	dw2_lookup_symtab.  Change arguments.
	(dwarf2_gdb_index_functions): Update.
	* dwarf2loc.c: Remove DEF_VEC_I(CORE_ADDR).
	* defs.h (compare_strings): Declare.
	* cli/cli-cmds.c (compare_strings): Move to utils.c.
	(edit_command, list_command): Use DECODE_LINE_LIST_MODE.  Call
	filter_sals.
	(compare_symtabs, filter_sals): New functions.
	* breakpoint.h (struct bp_location) <line_number, source_file>:
	New fields.
	(struct breakpoint) <line_number, source_file>: Remove.
	<filter>: New field.
	* breakpoint.c (print_breakpoint_location, init_raw_breakpoint)
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	Update for changes to locations.
	(init_breakpoint_sal): Add 'filter' argument.  Set 'filter' on
	breakpoint.
	(create_breakpoint_sal): Add 'filter' argument.
	(remove_sal, expand_line_sal_maybe): Remove.
	(create_breakpoints_sal): Remove 'sals' argument.  Handle
	pre-expanded sals and the filter.
	(parse_breakpoint_sals): Use decode_line_full.
	(check_fast_tracepoint_sals): Use get_sal_arch.
	(create_breakpoint): Create a linespec_sals.  Update.
	(break_range_command): Use decode_line_full.  Update.
	(until_break_command): Update.
	(clear_command): Update match conditions for linespec.c changes.
	Use DECODE_LINE_LIST_MODE.
	(say_where): Update for changes to locations.
	(bp_location_dtor): Free 'source_file'.
	(base_breakpoint_dtor): Free 'filter'.  Don't free 'source_file'.
	(update_static_tracepoint): Update for changes to locations.
	(update_breakpoint_locations): Disable ranged breakpoint if too
	many locations match.  Update.
	(addr_string_to_sals): Use decode_line_full.  Resolve all sal
	PCs.
	(breakpoint_re_set_default): Don't call expand_line_sal_maybe.
	(decode_line_spec_1): Update.  Change argument name to 'flags',
	change interpretation.
	* block.h (block_containing_function): Declare.
	* block.c (block_containing_function): New function.
	* skip.c (skip_function_command): Update.
	(skip_re_set): Update.
	* infcmd.c (jump_command): Use DECODE_LINE_FUNFIRSTLINE.
	* mi/mi-main.c (mi_cmd_trace_find): Use DECODE_LINE_FUNFIRSTLINE.
	* NEWS: Add entry.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Allow
	breakpoint's pspace to be NULL.
	* breakpoint.h (struct breakpoint) <pspace>: Update comment.
	* breakpoint.c (init_raw_breakpoint): Conditionally set
	breakpoint's pspace.
	(init_breakpoint_sal): Don't set breakpoint's pspace.
	(prepare_re_set_context): Conditionally switch program space.
	(addr_string_to_sals): Check executing_startup on location's
	program space.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* breakpoint.h (enum enable_state) <bp_startup_disabled>: Remove.
	* breakpoint.c (should_be_inserted): Explicitly check if program
	space is executing startup.
	(describe_other_breakpoints): Update.
	(disable_breakpoints_before_startup): Change executing_startup
	earlier.  Remove loop.
	(enable_breakpoints_after_startup): Likewise.
	(init_breakpoint_sal): Don't use bp_startup_disabled.
	(create_breakpoint): Don't use bp_startup_disabled.
	(update_global_location_list): Use should_be_inserted.
	(bkpt_re_set): Update.
gdb/testsuite
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * gdb.ada/fullname_bp.exp: Add tests for other valid linespecs
        involving a fully qualified function name.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.ada/homonym.exp: Add three breakpoint tests.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.base/solib-weak.exp (do_test): Remove kfail.
	* gdb.trace/tracecmd.exp: Disable pending breakpoints earlier.
	* gdb.objc/objcdecode.exp: Update for output changes.
	* gdb.linespec/linespec.exp: New file.
	* gdb.linespec/lspec.cc: New file.
	* gdb.linespec/lspec.h: New file.
	* gdb.linespec/body.h: New file.
	* gdb.linespec/base/two/thefile.cc: New file.
	* gdb.linespec/base/one/thefile.cc: New file.
	* gdb.linespec/Makefile.in: New file.
	* gdb.cp/templates.exp (test_template_breakpoints): Update for
	output changes.
	* gdb.cp/re-set-overloaded.exp: Remove kfail.
	* gdb.cp/ovldbreak.exp: Update for output changes.  "all" test now
	makes one breakpoint.
	* gdb.cp/method2.exp (test_break): Update for output changes.
	* gdb.cp/mb-templates.exp: Update for output changes.
	* gdb.cp/mb-inline.exp: Update for output changes.
	* gdb.cp/mb-ctor.exp: Update for output changes.
	* gdb.cp/ovsrch.exp: Use fully-qualified names.
	* gdb.base/solib-symbol.exp: Run to main later.  Breakpoint now
	has multiple matches.
	* gdb.base/sepdebug.exp: Disable pending breakpoints.  Update for
	error message change.
	* gdb.base/list.exp (test_list_filename_and_number): Update for
	error message change.
	* gdb.base/break.exp: Disable pending breakpoints.  Update for
	output changes.
	* configure.ac: Add gdb.linespec.
	* configure: Rebuild.
	* Makefile.in (ALL_SUBDIRS): Add gdb.linespec.
gdb/doc
2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Set Breaks): Update for new behavior.
@
text
@d3 2
a4 3
   Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.103.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 2
   Copyright (C) 1991-1996, 1998-2005, 2007-2012 Free Software
   Foundation, Inc.
@


1.102
log
@	* language.c (language_class_name_from_physname): Rename
	'curr_language' argument to 'lang'; use in body.
@
text
@d1203 2
d1246 2
d1287 2
@


1.101
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* h8300-tdep.c: Comment cleanup, mostly periods and spaces.
	* hppa-hpux-tdep.c: Ditto.
	* hppa-linux-nat.c: Ditto.
	* hppa-linux-tdep.c: Ditto.
	* hppanbsd-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* hppa-tdep.h: Ditto.
	* hpux-thread.c: Ditto.
	* i386-cygwin-tdep.c: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386gnu-nat.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* i386-linux-tdep.c: Ditto.
	* i386-nat.c: Ditto.
	* i386-nat.h: Ditto.
	* i386nbsd-tdep.c: Ditto.
	* i386-sol2-nat.c: Ditto.
	* i386-stub.c: Ditto.
	* i386-tdep.c: Ditto.
	* i386-tdep.h: Ditto.
	* i387-tdep.c: Ditto.
	* ia64-linux-nat.c: Ditto.
	* ia64-linux-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* infcall.c: Ditto.
	* infcall.h: Ditto.
	* infcmd.c: Ditto.
	* inferior.c: Ditto.
	* inferior.h: Ditto.
	* infloop.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* interps.c: Ditto.
	* interps.h: Ditto.
	* iq2000-tdep.c: Ditto.
	* irix5-nat.c: Ditto.
	* jit.c: Ditto.
	* jit.h: Ditto.
	* jv-exp.y: Ditto.
	* jv-lang.c: Ditto.
	* jv-lang.h: Ditto.
	* jv-typeprint.c: Ditto.
	* jv-valprint.c: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* linespec.c: Ditto.
	* linux-fork.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-thread-db.c: Ditto.
	* lm32-tdep.c: Ditto.
@
text
@d1017 1
a1017 1
language_class_name_from_physname (const struct language_defn *curr_language,
d1020 2
a1021 3
  if (current_language != NULL
      && current_language->la_class_name_from_physname)
    return current_language->la_class_name_from_physname (physname);
@


1.100
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d27 1
a27 1
   and return the appropriate result. */
d90 1
a90 1
/* The current language and language_mode (see language.h) */
d115 1
a115 1
   frame do not match. */
d120 1
a120 1
   and their helpers. */
d123 1
a123 1
   does not match the frame. */
d128 1
a128 1
  enum language flang;		/* The language of the current frame */
d147 1
a147 1
/* Set command.  Change the current working language. */
d191 1
a191 1
   not match the current language. */
d229 1
a229 1
/* Set command.  Change the setting for type checking. */
d264 1
a264 1
   not match the current language. */
d302 1
a302 1
/* Set command.  Change the setting for range checking. */
d338 1
a338 1
   not match the current language. */
d411 1
a411 1
   type and range checking status. */
d425 2
a426 1
/* Set current language to (enum language) LANG.  Returns previous language. */
d474 1
a474 1
/* Return the result of a binary operation. */
d510 1
a510 1
         not needed. */
d532 1
a532 1
   TYPE_CODE_FLT), while booleans are different. */
d536 1
a536 1
   and thus will never cause the failure of the test. */
d559 1
a559 1
   operations "increment" or "decrement" make sense. */
d578 1
a578 1
/* Returns non-zero if the two types are the same */
d585 1
a585 1
    /* One is structured and one isn't */
d597 1
a597 1
/* Returns non-zero if the type is integral */
d618 1
a618 1
/* Returns non-zero if the value is numeric */
d634 1
a634 1
/* Returns non-zero if the value is a character type */
d657 1
a657 1
/* Returns non-zero if the value is a string type */
d672 1
a672 1
      /* C does not have distinct string type. */
d679 1
a679 1
/* Returns non-zero if the value is a boolean type */
d703 1
a703 1
/* Returns non-zero if the value is a floating-point type */
d712 1
a712 1
/* Returns non-zero if the value is a pointer type */
d721 1
a721 1
/* Returns non-zero if the value is a structured type */
d751 1
a751 1
   (struct value) values used in GDB. */
d753 1
a753 1
/* Returns non-zero if the value VAL represents a true value. */
d768 1
a768 1
   checking. */
d775 1
a775 1
   message. */
d830 1
a830 1
/* This page contains miscellaneous functions */
d832 1
a832 1
/* Return the language enum for a given language string. */
d846 1
a846 1
/* Return the language struct for a given language enum. */
d863 1
a863 1
/* Return the language as a string */
d1000 1
a1000 1
/* Return demangled language symbol, or NULL.  
d1003 1
a1003 1
   more flexible demangler for the languages that need it.  
d1017 1
a1017 1
language_class_name_from_physname (const struct language_defn *current_language,
d1207 2
a1208 1
/* These two structs define fake entries for the "local" and "auto" options. */
d1369 1
a1369 1
/* Initialize the language routines */
d1383 1
a1383 1
  /* GDB commands for language specific stuff */
d1430 1
a1430 1
  /* Have the above take effect */
@


1.99
log
@run copyright.sh for 2011.
@
text
@d136 2
a137 1
    fprintf_filtered (gdb_stdout, _("The current source language is \"%s\".\n"),
d366 2
a367 1
    fprintf_filtered (gdb_stdout, _("Case sensitivity in name search is \"%s\".\n"),
d503 2
a504 1
      else			/* Both are signed.  Result is the longer type */
d582 2
a583 1
  if (structured_type (arg1) ? !structured_type (arg2) : structured_type (arg2))
d907 2
a908 1
      fprintf_unfiltered (gdb_stderr, "Magic number of %s language struct wrong\n",
d910 2
a911 1
      internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
d939 4
a942 4
  fprintf_unfiltered (tmp_stream, _("\
Set the current source language.\n\
The currently understood settings are:\n\n\
local or auto    Automatic setting based on source file\n"));
d967 3
a969 3
			language_set_doc, _("\
Show the current source language."), NULL,
			set_language_command,
d1019 2
a1020 1
  if (current_language != NULL && current_language->la_class_name_from_physname)
d1088 2
a1089 1
  error (_("internal error - unimplemented function unk_lang_emit_char called."));
d1095 2
a1096 1
  error (_("internal error - unimplemented function unk_lang_printchar called."));
d1105 2
a1106 1
  error (_("internal error - unimplemented function unk_lang_printstr called."));
d1113 2
a1114 1
  error (_("internal error - unimplemented function unk_lang_print_type called."));
d1124 2
a1125 1
  error (_("internal error - unimplemented function unk_lang_val_print called."));
d1132 2
a1133 1
  error (_("internal error - unimplemented function unk_lang_value_print called."));
d1192 2
a1193 1
  unk_lang_class_name,		/* Language specific class_name_from_physname */
d1232 2
a1233 1
  unk_lang_class_name,		/* Language specific class_name_from_physname */
d1271 2
a1272 1
  unk_lang_class_name,		/* Language specific class_name_from_physname */
d1395 4
a1398 4
  add_setshow_enum_cmd ("type", class_support, type_or_range_names, &type, _("\
Set type checking.  (on/warn/off/auto)"), _("\
Show type checking.  (on/warn/off/auto)"), NULL,
			set_type_command,
d1403 4
a1406 4
			&range, _("\
Set range checking.  (on/warn/off/auto)"), _("\
Show range checking.  (on/warn/off/auto)"), NULL,
			set_range_command,
@


1.98
log
@gdb/
	* ada-lang.h (ada_print_type): Make varstring const.
	* ada-typeprint.c (print_func_type): Make name const.
	(ada_print_type): Make varstring const.
	* c-lang.h (c_print_type): Make varstring const.
	* c-typeprint.c (c_print_type): Likewise.
	* f-lang.h (f_print_type): Likewise.
	* f-typeprint.c (f_print_type): Likewise.
	* jv-lang.h (java_print_type): Likewise.
	* jv-typeprint.c (java_print_type): Likewise.
	* language.c (unk_lang_print_type): Likewise.
	* language.h (struct language_defn) <la_print_type>: Likewise.
	* m2-lang.h (m2_print_type): Likewise.
	* m2-typeprint.c (m2_print_type): Likewise.
	* p-lang.h (pascal_print_type): Likewise.
	* p-typeprint.c (pascal_print_type): Likewise.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010
@


1.97
log
@gdb
	PR gdb/9977, PR exp/11636:
	* value.h (value_offset): Update.
	(struct lval_funcs) <check_validity>: New field.
	<copy_closure>: Make argument const.
	(value_computed_closure): Update.
	(value_contents_for_printing): Declare.
	(value_bits_valid): Likewise.
	(val_print): Likewise.
	(set_value_component_location): Update.
	(value_entirely_optimized_out): Declare.
	* value.c (value_offset): Argument now const.
	(require_not_optimized_out): New function.
	(value_contents_for_printing): New function.
	(value_contents_all): Call require_not_optimized_out.
	(value_contents): Likewise.
	(value_bits_valid): New function.
	(value_computed_closure): Argument now const.
	(set_value_component_location): Make 'whole' argument const.
	(value_entirely_optimized_out): New function.
	(value_bitsize): Argument now 'const'.
	(value_bitpos): Likewise.
	(value_type): Likewise.
	* valprint.h (val_print_array_elements): Update.
	* valprint.c (val_print): Add 'val' argument.  Use
	valprint_check_validity.
	(valprint_check_validity): New function.
	(value_check_printable): Use value_entirely_optimized_out.
	(common_val_print): Update.
	(value_print): Likewise.
	(val_print_array_elements): Add 'val' argument.
	* valops.c (value_fetch_lazy): Use value_contents_for_printing,
	value_bits_valid.  Reinit frame cache for lval_computed.
	* sh64-tdep.c (sh64_do_register): Update.
	* scm-valprint.c (scm_val_print): Add 'val' argument.
	* scm-lang.h (scm_val_print): Update.
	* python/python.h (apply_val_pretty_printer): Update.
	* python/py-prettyprint.c (apply_val_pretty_printer): Add 'val'
	argument.  Call set_value_component_location.
	* printcmd.c (print_scalar_formatted): Update.
	* p-valprint.c (pascal_val_print): Add 'val' argument.
	(pascal_object_print_value_fields): Likewise.
	(pascal_object_print_value): Likewise.
	(pascal_object_print_static_field): Update.
	* p-lang.h (pascal_val_print): Update.
	(pascal_object_print_value_fields): Update.
	* mt-tdep.c (mt_registers_info): Update.
	* mi/mi-main.c (get_register): Update.
	(mi_cmd_data_evaluate_expression): Use common_val_print.
	* m2-valprint.c (m2_print_array_contents): Add 'val' argument.
	(m2_print_unbounded_array): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* language.h (struct language_defn) <la_val_print>: Add 'val'
	argument.
	(LA_VAL_PRINT): Likewise.
	* language.c (unk_lang_val_print): Add 'val' argument.
	* jv-valprint.c (java_print_value_fields): Add 'val' argument.
	(java_val_print): Likewise.
	* jv-lang.h (java_val_print): Add 'val' argument.
	* infcmd.c (default_print_registers_info): Update.
	* f-valprint.c (f77_print_array_1): Add 'val' argument.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Add 'val' argument.
	* dwarf2loc.c (read_pieced_value): Use value_bitsize and
	value_bitpos.
	<DWARF_VALUE_OPTIMIZED_OUT>: Don't print warning.  Call
	set_value_optimized_out.
	(write_pieced_value): Use value_bitsize and value_bitpos.
	<default>: Don't exit loop.
	(check_pieced_value_validity): New function.
	(pieced_value_funcs): Reference check_pieced_value_validity,
	check_pieced_value_invalid.
	(copy_pieced_value_closure): Update.
	(check_pieced_value_bits): New function.
	(check_pieced_value_invalid): New function.
	* d-valprint.c (dynamic_array_type): Add 'val' argument.
	(d_val_print): Likewise.
	* d-lang.h (d_val_print): Update.
	* cp-valprint.c (cp_print_value_fields): Add 'val' argument.
	(cp_print_value_fields_rtti): Likewise.
	(cp_print_value): Likewise.
	(cp_print_static_field): Update.
	* c-valprint.c (c_val_print): Add 'val' argument.
	(c_value_print): Update.
	* c-lang.h (c_val_print): Update.
	(cp_print_value_fields): Likewise.
	(cp_print_value_fields_rtti): Likewise.
	* ada-valprint.c (struct ada_val_print_args): Remove.
	(val_print_packed_array_elements): Add 'val' argument.
	(ada_val_print): Likewise.  Rewrite.
	(ada_val_print_stub): Remove.
	(ada_val_print_array): Add 'val' argument.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Update.
	(print_record): Add 'val' argument.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print): Update.
gdb/testsuite
	PR gdb/9977, PR exp/11636::
	* gdb.dwarf2/pieces.exp (pieces_test_f3): Remove kfail.
	(pieces_test_f6): Update expected output.
@
text
@d67 1
a67 1
static void unk_lang_print_type (struct type *, char *, struct ui_file *,
d1100 2
a1101 2
unk_lang_print_type (struct type *type, char *varstring, struct ui_file *stream,
		     int show, int level)
@


1.96
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* jv-lang.c: White space.
	* jv-typeprint.c: White space.
	* jv-valprint.c: White space.
	* language.c: White space.
	* libunwind-frame.c: White space.
	* linespec.c: White space.
	* linux-nat.c: White space.
	* linux-record.c: White space.
	* linux-thread-db.c: White space.
@
text
@d1110 1
@


1.95
log
@D language support.

gdb/ChangeLog:

        D language support.
        * Makefile.in (SFILES): Add d-lang.c d-valprint.c.
        (COMMON_OBS): Add d-lang.o d-valprint.o.
        (HFILES_NO_SRCDIR): Add d-lang.h.
        * NEWS: Mention D language support.
        * c-lang.c (c_emit_char, exp_descriptor_c): Make public.
        * c-lang.h (c_emit_char, exp_descriptor_c): Add declaration.
        * d-lang.c: New file.
        * d-lang.h: New file.
        * d-valprint.c: New file.
        * defs.h (enum language): Add language_d.
        * dwarf2read.c (set_cu_language): Add DW_LANG_D.
        * language.c (binop_result_type, integral_type, character_type)
        (string_type, boolean_type, structured_type): Add language_d.
        * symfile.c (init_filename_language_table): Add language_d.
        * symtab.c: Include d-lang.h.
        (symbol_init_language_specific, symbol_find_demangled_name)
        (symbol_natural_name, lookup_symbol_in_language)
        (symbol_demangled_name, symbol_matches_domain): Add language_d.

gdb/doc/ChangeLog:

        * gdb.texinfo: (Summary) Add mention about D language support.
        (Filenames): Add D suffixes.
        (D): New node.

gdb/testsuite/ChangeLog:

        * gdb.base/default.exp: Fix "set language" test.
@
text
@d776 1
a777 1

d802 1
a803 1

d984 1
d1302 1
d1316 1
d1322 1
d1339 1
@


1.94
log
@2010-01-13  Phil Muldoon  <pmuldoon@@redhat.com>

	PR python/10705

	* python/python-internal.h: Add lazy_string_object_type
	definition.
	(create_lazy_string_object, gdbpy_initialize_lazy_string)
	(gdbpy_is_lazystring, gdbpy_extract_lazy_string): Define.
	* python/py-value.c (valpy_lazy_string): New function.
	(convert_value_from_python): Add lazy string conversion.
	* python/py-prettyprint.c (pretty_print_one_value): Check if
	return is also a lazy string.
	(print_string_repr): Add lazy string printing branch.
	(print_children): Likewise.
	* python/py-lazy-string.c: New file. Implement lazy strings.
	* python/python.c (_initialize_python): Call
	gdbpy_initialize_lazy_string.
	* varobj.c (value_get_print_value): Add lazy string printing
	branch.  Account for encoding.
	* c-lang.c (c_printstr): Account for new encoding argument.  If
	encoding is NULL, find encoding suited for type, otherwise use
	user encoding.
	* language.h (language_defn): Add encoding argument.
	(LA_PRINT_STRING): Likewise.
	* language.c (unk_lang_printstr): Update to reflect new encoding
	argument to language_defn.
	* ada-lang.h (ada_printstr): Likewise.
	* c-lang.h (c_printstr): Likewise.
	* p-lang.h (pascal_printstr);
	* f-lang.c (f_printstr): Likewise.
	* m2-lang.c (m2_printstr): Likewise.
	* objc-lang.c (objc_printstr): Likewise.
	* p-lang.c (pascal_printstr): Likewise.
	* scm-lang.c (scm_printstr): Likewise.
	* c-valprint.c (c_val_print): Update LA_PRINT_STRING call for
	encoding argument.
	* ada-valprint.c (ada_printstr): Likewise.
	* f-valprint.c (f_val_print): Likewise
	* m2-valprint.c (m2_val_print): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	* expprint.c (print_subexp_standard): Likewise.
	* valprint.c (val_print_string): Likewise.
	* Makefile.in (SUBDIR_PYTHON_OBS): Add py-lazy-string.
	(SUBDIR_PYTHON_SRCS): Likewise.
	(py-lazy-string.o): New rule.

2010-01-13  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.texinfo (Values From Inferior): Document lazy_string value
	method.
	(Python API): Add Lazy strings menu item.
	(Lazy Strings In Python): New node.

2010-01-13  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/py-value.exp (test_lazy_strings): Add lazy string test.
	* gdb.python/py-prettyprint.py (pp_ls): New printer.
	* gdb.python/py-prettyprint.exp (run_lang_tests): Add lazy string
	test.
	* gdb.python/py-prettyprint.c: Define lazystring test structure.
	* gdb.python/py-mi.exp: Add lazy string test.
@
text
@d489 1
d601 1
d642 1
d665 1
d685 1
d725 1
@


1.93
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1086 1
a1086 1
		   int force_ellipses,
@


1.92
log
@	* language.c (pointer_type): Un-comment out.
	* ax-gdb.c: Include language.h, use pointer_type throughout
	instead of testing TYPE_CODE_PTR.
	(gen_fetch): Include TYPE_CODE_REF.
	(gen_cast): Ditto.
@
text
@d4 2
a5 1
   2002, 2003, 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.91
log
@gdb
	PR python/10664:
	* language.h (struct language_defn) <la_get_string>: Add
	'char_type' argument.
	(LA_GET_STRING): Likewise.
	(default_get_string, c_get_string): Update.
	* language.c (default_get_string): Add 'char_type' argument.
	* c-valprint.c (c_textual_element_type): Rename from
	textual_element_type.  No longer static.  Update callers.
	* c-lang.h (c_textual_element_type): Declare.
	* c-lang.c (c_get_string): Add 'char_type' argument.
gdb/testsuite
	PR python/10664:
	* gdb.base/charset.exp: Test utf-16 strings with Python.
@
text
@d699 1
d709 1
@


1.90
log
@	* utils.c (add_internal_problem_command): Free set_doc and
	show_doc.
	* remote.c (add_packet_config_cmd): Free set_doc and show_doc.
	* language.c (add_language): Free language_set_doc.
@
text
@d1048 1
a1048 1
		    const char **charset)
@


1.89
log
@	* ui-file.h (ui_file_xstrdup): Mention that the length argument
	may be NULL.
	* ui-file.c (ui_file_xstrdup): Don't dereference LENGTH if it is
	NULL.
	* aix-thread.c (aix_thread_extra_thread_info): Pass NULL as length
	parameter to ui_file_xstrdup.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* infrun.c (print_target_wait_results): Ditto.
	* language.c (add_language): Ditto.
	* linespec.c (cplusplus_error): Ditto.
	* remote.c (escape_buffer): Ditto.
	* typeprint.c (type_to_string): Ditto.
	* utils.c (error_stream): Ditto.
	* varobj.c (value_get_print_value): Ditto.
	* xtensa-tdep.c (xtensa_verify_config): Replace `dummy' local with
	`length' local.  Pass it to ui_file_xstrdup, and avoid an strlen
	call.
	* gdbarch.sh (verify_gdbarch): Ditto.
	* gdbarch.c: Regenerate.
	* cli/cli-setshow.c (do_setshow_command): Pass NULL as length
	parameter to ui_file_xstrdup.
	* python/python-frame.c (frapy_str): Ditto.
	* python/python-type.c (typy_str): Use the length local instead of
	calling strlen.
	* python/python-value.c (valpy_str): Pass NULL as length parameter
	to ui_file_xstrdup.
@
text
@d887 1
a887 1
  static char *language_set_doc = NULL;
a945 1
  xfree (language_set_doc);
d957 2
@


1.88
log
@2009-08-13  Pedro Alves  <pedro@@codesourcery.com>

	PR gdb/8869:

	* language.c (language, type, range, case_sensitive): Make const.
	(show_language_command): Don't call deprecated_show_value_hack.
	Special case "auto".
	(set_language_command): An unrecognized language is now an
	internal error instead of a user error.  Don't call set_lang_str.
	(show_type_command): Don't call deprecated_show_value_hack.
	Special case "auto".  Use warning.
	(set_type_command): An unrecognized type is now an internal error
	instead of a user error.  Output type check mismatch with language
	here.  Don't call set_type_str.
	(show_range_command): Don't call deprecated_show_value_hack.
	Special case "auto".  Use warning.
	(set_range_command): An unrecognized range check is now an
	internal error instead of a warning.  Output range check mismatch
	with language here.  Don't call set_range_str.
	(show_case_command): Don't call deprecated_show_value_hack.
	Special case "auto".  Use warning.
	(set_case_command): Don't call set_case_str.  An unrecognized case
	check is now an internal error instead of a warning.  Output range
	check mismatch with language here.  Don't call set_case_str.
	(set_type_range_case): Don't call set_type_str, set_range_str or
	set_case_str here.
	(set_lang_str, set_type_str, set_range_str, set_case_str): Delete.
	(add_language): Install or reinstall the "set language" command
	here, and make it an enum command.  Build the enumeration and the
	help string from the current list of known languages.
	(_initialize_language): Don't install "set language" here.  Make
	"set check type", "set check range" and "set case-sensitive" enum
	commands.  Register the "auto" "local" and "unknown" languages in
	that order.

2009-08-13  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.base/default.exp: Adjust "set language test": it's now an
	enum command.  Larger help string moved to "help set language".
	* gdb.base/help.exp: Adjust "help set language" expected output,
	now lists all known languages.
@
text
@a890 1
  long len;
d947 1
a947 1
  language_set_doc = ui_file_xstrdup (tmp_stream, &len);
@


1.87
log
@	Revert 2009-08-07 changes for PR gdb/8869:

	* language.c (set_language_command): Strip whitespace.
	(set_type_command): Likewise.
	(set_range_command): Likewise.

	* language.c (language_completer): New function.
	(range_or_type_completer): New function.
	(case_completer): New function.
	(_initialize_language): Set completers.
	* cli/cli-decode.c (add_setshow_string_cmd): Return the "set"
	command.
	(add_setshow_string_noescape_cmd): Likewise.
	(add_setshow_integer_cmd): Likewise.
	(add_setshow_uinteger_cmd): Likewise.
	(add_setshow_zinteger_cmd): Likewise.
	(add_setshow_zuinteger_cmd): Likewise.
	* command.h (add_setshow_string_cmd,
	add_setshow_string_noescape_cmd, add_setshow_uinteger_cmd,
	add_setshow_zinteger_cmd, add_setshow_zuinteger_cmd): Update.
@
text
@a49 8
static void set_case_str (void);

static void set_range_str (void);

static void set_type_str (void);

static void set_lang_str (void);

d106 6
a111 10
/* The "set language/type/range" commands all put stuff in these
   buffers.  This is to make them work as set/show commands.  The
   user's string is copied here, then the set_* commands look at
   them and update them to something that looks nice when it is
   printed out. */

static char *language;
static char *type;
static char *range;
static char *case_sensitive;
d129 9
a137 1
  deprecated_show_value_hack (file, from_tty, c, value);
a150 28
  char *err_lang;

  if (!language || !language[0])
    {
      printf_unfiltered (_("\
The currently understood settings are:\n\n\
local or auto    Automatic setting based on source file\n"));

      for (i = 0; i < languages_size; ++i)
	{
	  /* Already dealt with these above.  */
	  if (languages[i]->la_language == language_unknown
	      || languages[i]->la_language == language_auto)
	    continue;

	  /* FIXME: i18n: for now assume that the human-readable name
	     is just a capitalization of the internal name.  */
	  printf_unfiltered ("%-16s Use the %c%s language\n",
			     languages[i]->la_name,
	  /* Capitalize first letter of language
	     name.  */
			     toupper (languages[i]->la_name[0]),
			     languages[i]->la_name + 1);
	}
      /* Restore the silly string. */
      set_language (current_language->la_language);
      return;
    }
a176 1
	      set_lang_str ();
d183 3
a185 6
  /* Reset the language (esp. the global string "language") to the 
     correct values. */
  err_lang = xstrdup (language);
  make_cleanup (xfree, err_lang);	/* Free it after error */
  set_language (current_language->la_language);
  error (_("Unknown language `%s'."), err_lang);
d194 31
a224 4
  deprecated_show_value_hack (file, from_tty, c, value);
  if (type_check != current_language->la_type_check)
    printf_unfiltered (
			"Warning: the current type check setting does not match the language.\n");
a249 2
      /* Avoid hitting the set_type_str call below.  We
         did it in set_type_range_case. */
d253 6
a258 5
    {
      warning (_("Unrecognized type check setting: \"%s\""), type);
    }
  set_type_str ();
  show_type_command (NULL, from_tty, NULL, NULL);
d267 28
a294 1
  deprecated_show_value_hack (file, from_tty, c, value);
d296 2
a297 2
    printf_unfiltered (
			"Warning: the current range check setting does not match the language.\n");
a322 2
      /* Avoid hitting the set_range_str call below.  We
         did it in set_type_range_case. */
d327 2
a328 1
      warning (_("Unrecognized range check setting: \"%s\""), range);
d330 3
a332 2
  set_range_str ();
  show_range_command (NULL, from_tty, NULL, NULL);
d341 26
a366 1
  deprecated_show_value_hack (file, from_tty, c, value);
d368 2
a369 2
    printf_unfiltered(
"Warning: the current case sensitivity setting does not match the language.\n");
a390 2
       /* Avoid hitting the set_case_str call below.  We did it in
	  set_type_range_case.  */
d395 3
a397 2
       warning (_("Unrecognized case-sensitive setting: \"%s\""),
		case_sensitive);
d399 4
a402 2
   set_case_str();
   show_case_command (NULL, from_tty, NULL, NULL);
a411 1

a419 4

  set_type_str ();
  set_range_str ();
  set_case_str ();
a437 1
	  set_lang_str ();
a444 94
/* This page contains functions that update the global vars
   language, type and range. */
static void
set_lang_str (void)
{
  char *prefix = "";

  if (language)
    xfree (language);
  if (language_mode == language_mode_auto)
    prefix = "auto; currently ";

  language = concat (prefix, current_language->la_name, (char *)NULL);
}

static void
set_type_str (void)
{
  char *tmp = NULL, *prefix = "";

  if (type)
    xfree (type);
  if (type_mode == type_mode_auto)
    prefix = "auto; currently ";

  switch (type_check)
    {
    case type_check_on:
      tmp = "on";
      break;
    case type_check_off:
      tmp = "off";
      break;
    case type_check_warn:
      tmp = "warn";
      break;
    default:
      error (_("Unrecognized type check setting."));
    }

  type = concat (prefix, tmp, (char *)NULL);
}

static void
set_range_str (void)
{
  char *tmp, *pref = "";

  if (range_mode == range_mode_auto)
    pref = "auto; currently ";

  switch (range_check)
    {
    case range_check_on:
      tmp = "on";
      break;
    case range_check_off:
      tmp = "off";
      break;
    case range_check_warn:
      tmp = "warn";
      break;
    default:
      error (_("Unrecognized range check setting."));
    }

  if (range)
    xfree (range);
  range = concat (pref, tmp, (char *)NULL);
}

static void
set_case_str (void)
{
   char *tmp = NULL, *prefix = "";

   if (case_mode==case_mode_auto)
      prefix = "auto; currently ";

   switch (case_sensitivity)
   {
   case case_sensitive_on:
     tmp = "on";
     break;
   case case_sensitive_off:
     tmp = "off";
     break;
   default:
     error (_("Unrecognized case-sensitive setting."));
   }

   xfree (case_sensitive);
   case_sensitive = concat (prefix, tmp, (char *)NULL);
}
d884 9
d913 46
d1341 5
a1345 1
  struct cmd_list_element *set, *show;
a1351 9
  /* FIXME: cagney/2005-02-20: This should be implemented using an
     enum.  */
  add_setshow_string_noescape_cmd ("language", class_support, &language, _("\
Set the current source language."), _("\
Show the current source language."), NULL,
				   set_language_command,
				   show_language_command,
				   &setlist, &showlist);

d1364 1
a1364 3
  /* FIXME: cagney/2005-02-20: This should be implemented using an
     enum.  */
  add_setshow_string_noescape_cmd ("type", class_support, &type, _("\
d1367 6
a1372 7
				   set_type_command,
				   show_type_command,
				   &setchecklist, &showchecklist);

  /* FIXME: cagney/2005-02-20: This should be implemented using an
     enum.  */
  add_setshow_string_noescape_cmd ("range", class_support, &range, _("\
d1375 6
a1380 8
				   set_range_command,
				   show_range_command,
				   &setchecklist, &showchecklist);

  /* FIXME: cagney/2005-02-20: This should be implemented using an
     enum.  */
  add_setshow_string_noescape_cmd ("case-sensitive", class_support,
				   &case_sensitive, _("\
d1384 3
a1386 3
				   set_case_command,
				   show_case_command,
				   &setlist, &showlist);
d1388 2
a1390 2
  add_language (&local_language_defn);
  add_language (&auto_language_defn);
@


1.86
log
@gdb
	* language.c (set_language_command): Strip whitespace.
	(set_type_command): Likewise.
	(set_range_command): Likewise.
gdb/testsuite
	* gdb.base/setshow.exp: Add tests for changes to set language, set
	check range, and set check type.
@
text
@d153 1
a153 1
  int i, len;
d155 1
a155 11
  char *err_lang, *tem;

  /* Strip trailing whitespace.  */
  if (!language)
    len = 0;
  else
    {
      len = strlen (language);
      while (len > 0 && language[len - 1] == ' ')
	--len;
    }
d157 1
a157 1
  if (len == 0)
a183 5
  /* Reset LANGUAGE to avoid trailing spaces.  */
  tem = savestring (language, len);
  xfree (language);
  language = tem;

a223 14
static char **
language_completer (struct cmd_list_element *self, char *text, char *word)
{
  int i;
  const char **langnames
    = (const char **) alloca ((languages_size + 1) * sizeof (const char *));

  for (i = 0; i < languages_size; ++i)
    langnames[i] = languages[i]->la_name;
  langnames[i] = NULL;

  return complete_on_enum (langnames, text, word);
}

a239 12
  int len;
  char *tem;

  /* Strip trailing whitespace.  */
  len = strlen (type);
  while (len > 0 && type[len - 1] == ' ')
    --len;
  /* Reset TYPE.  */
  tem = savestring (type, len);
  xfree (type);
  type = tem;

a286 12
  int len;
  char *tem;

  /* Strip trailing whitespace.  */
  len = strlen (range);
  while (len > 0 && range[len - 1] == ' ')
    --len;
  /* Reset RANGE.  */
  tem = savestring (range, len);
  xfree (range);
  range = tem;

a317 8
/* Completer for range and type parameters.  */
static char **
range_or_type_completer (struct cmd_list_element *self, char *text, char *word)
{
  static const char *values[] = { "on", "off", "warn", "auto", NULL };
  return complete_on_enum (values, text, word);
}

a361 8
/* Completer for case-sensitive parameter.  */
static char **
case_completer (struct cmd_list_element *self, char *text, char *word)
{
  static const char *values[] = { "on", "off", "auto", NULL };
  return complete_on_enum (values, text, word);
}

d1343 1
a1343 1
  struct cmd_list_element *command;
d1350 3
a1352 2
  command = add_setshow_string_noescape_cmd ("language", class_support,
					     &language, _("\
d1355 3
a1357 4
					     set_language_command,
					     show_language_command,
					     &setlist, &showlist);
  set_cmd_completer (command, language_completer);
d1371 3
a1373 3
  command =
    add_setshow_string_noescape_cmd ("type", class_support,
				     &type, _("\
d1376 7
a1382 8
				     set_type_command,
				     show_type_command,
				     &setchecklist, &showchecklist);
  set_cmd_completer (command, range_or_type_completer);

  command =
    add_setshow_string_noescape_cmd ("range", class_support,
				     &range, _("\
d1385 8
a1392 8
				     set_range_command,
				     show_range_command,
				     &setchecklist, &showchecklist);
  set_cmd_completer (command, range_or_type_completer);

  command =
    add_setshow_string_noescape_cmd ("case-sensitive", class_support,
				     &case_sensitive, _("\
d1396 3
a1398 4
				     set_case_command,
				     show_case_command,
				     &setlist, &showlist);
  set_cmd_completer (command, case_completer);
@


1.85
log
@	PR gdb/8869:
	* language.c (language_completer): New function.
	(range_or_type_completer): New function.
	(case_completer): New function.
	(_initialize_language): Set completers.
	* cli/cli-decode.c (add_setshow_string_cmd): Return the "set"
	command.
	(add_setshow_string_noescape_cmd): Likewise.
	(add_setshow_integer_cmd): Likewise.
	(add_setshow_uinteger_cmd): Likewise.
	(add_setshow_zinteger_cmd): Likewise.
	(add_setshow_zuinteger_cmd): Likewise.
	* command.h (add_setshow_string_cmd,
	add_setshow_string_noescape_cmd, add_setshow_uinteger_cmd,
	add_setshow_zinteger_cmd, add_setshow_zuinteger_cmd): Update.
@
text
@d153 1
a153 1
  int i;
d155 11
a165 1
  char *err_lang;
d167 1
a167 1
  if (!language || !language[0])
d194 5
d269 12
d328 12
@


1.84
log
@gdb/
	Replace the savestring calls by xstrdup calls where possible.
	* breakpoint.c (condition_command, set_raw_breakpoint)
	(create_catchpoint, update_breakpoint_locations): Replace the
	savestring calls by xstrdup calls where possible.
	* buildsym.c (start_subfile, patch_subfile_names, record_debugformat)
	(record_producer): Likewise.
	* coffread.c (coff_start_symtab, complete_symtab): Likewise.
	* corefile.c (set_gnutarget): Likewise.
	* dbxread.c (add_new_header_file): Likewise.
	* demangle.c (set_demangling_command, set_demangling_style): Likewise.
	* event-top.c (push_prompt, pop_prompt, command_line_handler)
	(set_async_prompt): Likewise.
	* infcmd.c (set_inferior_io_terminal, attach_command_post_wait):
	Likewise.
	* language.c (set_language_command, _initialize_language): Likewise.
	* linespec.c (decode_line_2): Likewise.
	* rs6000-nat.c (add_vmap): Likewise.
	* top.c (set_prompt, init_history, init_main): Likewise.
	* tracepoint.c (stringify_collection_list): Likewise.
	* varobj.c (varobj_create): Remove variable expr_len.  Replace the
	savestring calls by xstrdup calls where possible.
	(value_of_root, c_name_of_variable, c_describe_child): Replace the
	savestring calls by xstrdup calls where possible.
	* xcoffread.c (complete_symtab): Likewise.
	* cli/cli-script.c (build_command_line, define_command): Likewise.
	* cli/cli-setshow.c (do_setshow_command): Likewise.
@
text
@d224 14
d332 8
d384 8
d1373 1
a1373 1
  struct cmd_list_element *set, *show;
d1380 2
a1381 3
  /* FIXME: cagney/2005-02-20: This should be implemented using an
     enum.  */
  add_setshow_string_noescape_cmd ("language", class_support, &language, _("\
d1384 4
a1387 3
				   set_language_command,
				   show_language_command,
				   &setlist, &showlist);
d1401 3
a1403 3
  /* FIXME: cagney/2005-02-20: This should be implemented using an
     enum.  */
  add_setshow_string_noescape_cmd ("type", class_support, &type, _("\
d1406 8
a1413 7
				   set_type_command,
				   show_type_command,
				   &setchecklist, &showchecklist);

  /* FIXME: cagney/2005-02-20: This should be implemented using an
     enum.  */
  add_setshow_string_noescape_cmd ("range", class_support, &range, _("\
d1416 8
a1423 8
				   set_range_command,
				   show_range_command,
				   &setchecklist, &showchecklist);

  /* FIXME: cagney/2005-02-20: This should be implemented using an
     enum.  */
  add_setshow_string_noescape_cmd ("case-sensitive", class_support,
				   &case_sensitive, _("\
d1427 4
a1430 3
				   set_case_command,
				   show_case_command,
				   &setlist, &showlist);
@


1.83
log
@gdb:
2009-03-19  Tom Tromey  <tromey@@redhat.com>
	    Julian Brown  <julian@@codesourcery.com>

	PR i18n/7220, PR i18n/7821, PR exp/8815, PR exp/9103,
	PR i18n/9401, PR exp/9613:
	* NEWS: Update
	* value.h (value_typed_string): Declare.
	(val_print_string): Update.
	* valprint.h (print_char_chars): Update.
	* valprint.c (print_char_chars): Add type argument.  Update.
	(val_print_string): Likewise.
	* valops.c (value_typed_string): New function.
	* utils.c (host_char_to_target): New function.
	(parse_escape): Use host_char_to_target, host_hex_value.  Update.
	Remove '^' case.
	(no_control_char_error): Remove.
	* typeprint.c (print_type_scalar): Update.
	* scm-valprint.c (scm_scmval_print): Update.
	* scm-lang.h (scm_printchar, scm_printstr): Update.
	* scm-lang.c (scm_printchar): Add type argument.
	(scm_printstr): Likewise.
	* printcmd.c (print_formatted): Update.
	(print_scalar_formatted): Update.
	(printf_command) <wide_string_arg, wide_char_arg>: New constants.
	Handle '%lc' and '%ls'.
	* parser-defs.h (struct typed_stoken): New type.
	(struct stoken_vector): Likewise.
	(write_exp_string_vector): Declare.
	* parse.c (write_exp_string_vector): New function.
	* p-valprint.c (pascal_val_print): Update.
	* p-lang.h (is_pascal_string_type, pascal_printchar,
	pascal_printstr): Update.
	* p-lang.c (is_pascal_string_type): Remove 'char_size' argument.
	Add 'char_type' argument.
	(pascal_emit_char): Add type argument.
	(pascal_printchar): Likewise.
	(pascal_printstr): Likewise.
	* objc-lang.c (objc_emit_char): Add type argument.
	(objc_printchar): Likewise.
	(objc_printstr): Likewise.
	* macroexp.c (get_character_constant): Handle unicode characters.
	Use c_parse_escape.
	(get_string_literal): Handle unicode strings.  Use
	c_parse_escape.
	* m2-valprint.c (print_unpacked_pointer): Update.
	(m2_print_array_contents): Update.
	(m2_val_print): Update.
	* m2-lang.c (m2_emit_char): Add type argument.
	(m2_printchar): Likewise.
	(m2_printstr): Likewise.
	* language.h (struct language_defn) <la_printchar>: Add type
	argument.
	<la_printstr, la_emitchar>: Likewise.
	(LA_PRINT_CHAR): Likewise.
	(LA_PRINT_STRING): Likewise.
	(LA_EMIT_CHAR): Likewise.
	* language.c (unk_lang_emit_char): Add type argument.
	(unk_lang_printchar): Likewise.
	(unk_lang_printstr): Likewise.
	* jv-valprint.c (java_val_print): Update.
	* jv-lang.c (java_emit_char): Add type argument.
	* f-valprint.c (f_val_print): Update.
	* f-lang.c (f_emit_char): Add type argument.
	(f_printchar): Likewise.
	(f_printstr): Likewise.
	* expprint.c (print_subexp_standard): Update.
	* charset.h (target_wide_charset): Declare.
	(c_target_char_has_backslash_escape, c_parse_backslash,
	host_char_print_literally, host_char_to_target,
	target_char_to_host, target_char_to_control_char): Remove.
	(enum transliterations): New type.
	(convert_between_encodings): Declare.
	(HOST_ESCAPE_CHAR): New define.
	(host_letter_to_control_character, host_hex_value): Declare.
	(enum wchar_iterate_result): New enum.
	(struct wchar_iterator): Declare.
	(make_wchar_iterator, make_cleanup_wchar_iterator, wchar_iterator,
	wchar_push_back): Declare.
	* charset-list.h: New file.
	* c-valprint.c (textual_name): New function.
	(textual_element_type): Handle wide character types.
	(c_val_print): Pass original type to textual_element_type.  Handle
	wide character types.
	(c_value_print): Use textual_element_type.  Pass original type of
	value to val_print.
	* c-lang.h (enum c_string_type): New type.
	(c_printchar, c_printstr): Update.
	* c-lang.c (classify_type): New function.
	(print_wchar): Likewise.
	(c_emit_char): Add type argument.  Handle wide characters.
	(c_printchar): Likewise.
	(c_printstr): Add type argument.  Handle wide and multibyte
	character sets.
	(convert_ucn): New function.
	(emit_numeric_character): Likewise.
	(convert_octal): Likewise.
	(convert_hex): Likewise.
	(ADVANCE): New macro.
	(convert_escape): New function.
	(parse_one_string): Likewise.
	(evaluate_subexp_c): Likewise.
	(exp_descriptor_c): New global.
	(c_language_defn): Use exp_descriptor_c.
	(cplus_language_defn): Likewise.
	(asm_language_defn): Likewise.
	(minimal_language_defn): Likewise.
	(charset_for_string_type): New function.
	* c-exp.y (%union): Add 'svec' and 'tsval'.
	(CHAR): New token.
	(exp): Add CHAR production.
	(string_exp): Rewrite.
	(exp) <string_exp>: Rewrite.
	(tempbuf): Now global.
	(tempbuf_init): New global.
	(parse_string_or_char): New function.
	(yylex) <tempbuf>: Now global.
	<tokptr, tempbufindex, tempbufsize, token_string, class_prefix>:
	Remove.
	Handle 'u', 'U', and 'L' prefixes.  Call parse_string_or_char.
	(c_parse_escape): New function.
	* auxv.c (fprint_target_auxv): Update.
	* ada-valprint.c (ada_emit_char): Add type argument.
	(ada_printchar): Likewise.
	(ada_print_scalar): Update.
	(printstr): Add type argument.  Update calls to ada_emit_char.
	(ada_printstr): Add type argument.
	(ada_val_print_array): Update.
	(ada_val_print_1): Likewise.
	* ada-lang.c (emit_char): Add type argument.
	* ada-lang.h (ada_emit_char, ada_printchar, ada_printstr): Add
	type arguments.
	* gdb_locale.h: Include langinfo.h.
	* charset.c (_initialize_charset): Set default host charset from
	the locale.  Don't register charsets.  Add target-wide-charset
	commands.  Call find_charset_names.
	(struct charset, struct translation): Remove.
	(GDB_DEFAULT_HOST_CHARSET): Remove.
	(GDB_DEFAULT_TARGET_WIDE_CHARSET): New define.
	(target_wide_charset_name): New global.
	(show_host_charset_name): Handle "auto".
	(show_target_wide_charset_name): New function.
	(host_charset_enum, target_charset_enum): Remove.
	(charset_enum): New global.
	(all_charsets, register_charset, lookup_charset, all_translations,
	register_translation, lookup_translation): Remove.
	(simple_charset, ascii_print_literally, ascii_to_control): Remove.
	(iso_8859_print_literally, iso_8859_to_control,
	iso_8859_family_charset): Remove.
	(ebcdic_print_literally, ebcdic_to_control,
	ebcdic_family_charset): Remove.
	(struct cached_iconv, check_iconv_cache, cached_iconv_convert,
	register_iconv_charsets): Remove.
	(target_wide_charset_be_name, target_wide_charset_le_name): New
	globals.
	(identity_either_char_to_other): Remove.
	(set_be_le_names, validate): New functions.
	(backslashable, backslashed, represented): Remove.
	(default_c_target_char_has_backslash_escape): Remove.
	(default_c_parse_backslash, iconv_convert): Remove.
	(ascii_to_iso_8859_1_table, ascii_to_ebcdic_us_table,
	ascii_to_ibm1047_table, iso_8859_1_to_ascii_table,
	iso_8859_1_to_ebcdic_us_table, iso_8859_1_to_ibm1047_table,
	ebcdic_us_to_ascii_table, ebcdic_us_to_iso_8859_1_table,
	ebcdic_us_to_ibm1047_table, ibm1047_to_ascii_table,
	ibm1047_to_iso_8859_1_table, ibm1047_to_ebcdic_us_table): Remove.
	(table_convert_char, table_translation, simple_table_translation):
	Remove.
	(current_host_charset, current_target_charset,
	c_target_char_has_backslash_escape_func,
	c_target_char_has_backslash_escape_baton): Remove.
	(c_parse_backslash_func, c_parse_backslash_baton): Remove.
	(host_char_to_target_func, host_char_to_target_baton): Remove.
	(target_char_to_host_func, target_char_to_host_baton): Remove.
	(cached_iconv_host_to_target, cached_iconv_target_to_host):
	Remove.
	(lookup_charset_or_error, check_valid_host_charset): Remove.
	(set_host_and_target_charsets): Remove.
	(set_host_charset, set_target_charset): Remove.
	(set_host_charset_sfunc, set_target_charset_sfunc): Rewrite.
	(set_target_wide_charset_sfunc): New function.
	(show_charset): Print target wide character set.
	(host_charset, target_charset): Rewrite.
	(target_wide_charset): New function.
	(c_target_char_has_backslash_escape): Remove.
	(c_parse_backslash): Remove.
	(host_letter_to_control_character): New function.
	(host_char_print_literally): Remove.
	(host_hex_value): New function.
	(target_char_to_control_char): Remove.
	(cleanup_iconv): New function.
	(convert_between_encodings): New function.
	(target_char_to_host): Remove.
	(struct wchar_iterator): Define.
	(make_wchar_iterator, make_cleanup_wchar_iterator, wchar_iterator,
	wchar_push_back): New functions.
	(do_cleanup_iterator): New function.
	(char_ptr): New typedef.
	(charsets): New global.
	(add_one, find_charset_names): New functions.
	(default_charset_names): New global.
	(auto_host_charset_name): Likewise.
	* aclocal.m4, config.in, configure: Rebuild.
	* configure.ac: Call AM_LANGINFO_CODESET.
	(GDB_DEFAULT_HOST_CHARSET): Default to UTF-8.
	(AM_ICONV): Invoke earlier.
	* acinclude.m4: Include codeset.m4.  Subst LIBICONV_INCLUDE and
	LIBICONV_LIBDIR.  Check for libiconv in build tree.
	* Makefile.in (LIBICONV_LIBDIR, LIBICONV_INCLUDE): New macros.
	(INTERNAL_CFLAGS_BASE): Add LIBICONV_INCLUDE.
	(INTERNAL_LDFLAGS): Add LIBICONV_LIBDIR.
	* gdb_obstack.h (obstack_grow_wstr): New define.
        * gdb_wchar.h: New file.
        * defs.h: Include it.
gdb/testsuite:
	* gdb.base/store.exp: Update for change to escape output.
	* gdb.base/callfuncs.exp (fetch_all_registers): Update for change
	to escape output.
	* gdb.base/pointers.exp: Update for change to escape output.
	* gdb.base/long_long.exp (gdb_test_long_long): Update for change
	to escape output.
	* gdb.base/constvars.exp (do_constvar_tests): Update for change to
	escape output.
	* gdb.base/call-rt-st.exp (print_struct_call): Update for change
	to escape output.
	* gdb.cp/ref-types.exp (gdb_start_again): Update for change to
	escape output.
	* gdb.base/setvar.exp: Update for change to escape output.
	* lib/gdb.exp (default_gdb_start): Set LC_CTYPE to C.
	* gdb.base/printcmds.exp (test_print_all_chars): Update for change
	to escape output.
	(test_print_string_constants): Likewise.
	* gdb.base/charset.exp (valid_host_charset): Check size of
	wchar_t.  Handle UCS-2 and UCS-4.  Add tests for wide and unicode
	cases.  Handle "auto"-related output.
	* gdb.base/charset.c (char16_t, char32_t): New typedefs.
	(uvar, Uvar): New globals.
gdb/doc:
	* gdb.texinfo (Character Sets): Remove obsolete text.  Document
	set target-wide-charset.
	(Requirements): Mention iconv.
@
text
@d218 1
a218 1
  err_lang = savestring (language, strlen (language));
d1404 4
a1407 4
  language = savestring ("auto", strlen ("auto"));
  type = savestring ("auto", strlen ("auto"));
  range = savestring ("auto", strlen ("auto"));
  case_sensitive = savestring ("auto",strlen ("auto"));
@


1.82
log
@2009-02-05  Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* language.h (language_dfn): Add la_get_string member.
	(LA_GET_STRING): New macro.
	(default_get_string): New prototype.
	* language.c (default_get_string): New function.
	(unknown_language_defn, auto_language_defn, local_language_defn): Use
	default_get_string for la_get_string.
	* c-lang.c (c_get_string): New function.
	(c_language_defn, cplus_language_defn, asm_language_defn): Use
	c_get_string for la_get_string.
	(minimal_language_defn): Likewise
	* ada-lang.c (ada_language_defn): Likewise.
	* f-lang.c (f_language_defn): Use default_get_string for
	la_get_string.
	* jv-lang.c (java_language_defn): Likewise.
	* m2-lang.c (m2_language_defn): Likewise.
	* objc-lang.c (objc_language_defn): Likewise.
	* p-lang.c (p_language_defn): Likewise.
	* scm-lang.c (scm_language_defn): Likewise.
	* typeprint.c (type_to_string): New function.
	* value.h (type_to_string): New prototype.
	* valprint.c (val_print_string): Factor out code for reading string
	from the inferior into its own function.  Put 2 spaces after period
	in comments.
	(read_string): New function.
	* valprint.h (read_string): New prototype.
@
text
@d68 2
a69 1
static void unk_lang_emit_char (int c, struct ui_file *stream, int quoter);
d71 2
a72 1
static void unk_lang_printchar (int c, struct ui_file *stream);
d1070 2
a1071 1
unk_lang_emit_char (int c, struct ui_file *stream, int quoter)
d1077 1
a1077 1
unk_lang_printchar (int c, struct ui_file *stream)
d1083 3
a1085 2
unk_lang_printstr (struct ui_file *stream, const gdb_byte *string,
		   unsigned int length, int width, int force_ellipses,
@


1.81
log
@        Updated copyright notices for most files.
@
text
@d1046 7
d1175 1
d1214 1
d1252 1
@


1.80
log
@gdb
	* varobj.c (value_get_print_value): Include valprint.h.
	(value_get_print_value): Use get_formatted_print_options.
	* value.h (struct value_print_options): Declare.
	(value_print, val_print, common_val_print, val_print_string):
	Update.
	* value.c: Include valprint.h.
	(show_values): Use get_user_print_options.
	(show_convenience): Likewise.
	* valprint.h (prettyprint_arrays, prettyprint_structs): Don't
	declare.
	(struct value_print_options): New type.
	(vtblprint, unionprint, addressprint, objectprint, print_max,
	inspect_it, repeat_count_threshold, output_format,
	stop_print_at_null): Don't declare.
	(user_print_options, get_user_print_options,
	get_raw_print_options, get_formatted_print_options): Declare.
	(print_array_indexes_p): Don't declare.
	(maybe_print_array_index, val_print_array_elements): Update.
	* valprint.c (print_max): Remove.
	(user_print_options): New global.
	(get_user_print_options, get_raw_print_options,
	get_formatted_print_options): New functions.
	(print_array_indexes, repeat_count_threshold, stop_print_at_null,
	prettyprint_structs, prettyprint_arrays, unionprint,
	addressprint): Remove.
	(val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(common_val_print): Likewise.
	(print_array_indexes_p): Remove.
	(maybe_print_array_index): Remove format, pretty arguments; add
	options.  Update.
	(val_print_array_elements): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(val_print_string): Add options argument.  Update.
	(_initialize_valprint): Use user_print_options.
	(output_format): Remove.
	(set_output_radix_1): Use user_print_options.
	* typeprint.c: Include valprint.h.
	(objectprint): Don't declare.
	(whatis_exp): Use get_user_print_options.
	* tui/tui-regs.c: Include valprint.h.
	(tui_register_format): Use get_formatted_print_options.
	* tracepoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(trace_mention): Use get_user_print_options.
	(tracepoints_info): Likewise.
	* stack.c (print_frame_args): Use get_raw_print_options.
	(print_frame_info): Use get_user_print_options.
	(print_frame): Likewise.
	* sh64-tdep.c: Include valprint.h
	(sh64_do_register): Use get_formatted_print_options.
	* scm-valprint.c (scm_inferior_print): Remove format, deref_ref,
	pretty arguments; add options.
	(scm_scmlist_print): Likewise.  Update.
	(scm_scmval_print): Likewise.
	(scm_val_print): Likewise.
	(scm_value_print): Remove format, pretty arguments; add options.
	Update.
	* scm-lang.h (scm_value_print, scm_val_print, scm_scmval_print):
	Update.
	* scm-lang.c (scm_printstr): Add options argument.
	* python/python-value.c: Include valprint.h.
	(valpy_str): Use get_user_print_options.
	* printcmd.c: Include valprint.h.
	(addressprint): Don't declare.
	(inspect_it): Remove.
	(print_formatted): Remove format option; add options.  Update.
	(print_scalar_formatted): Likewise.
	(print_address_demangle): Use get_user_print_options.
	(do_examine): Use get_formatted_print_options.
	(print_command_1): Likewise.
	(output_command): Use get_formatted_print_options.
	(do_one_display): Likewise.
	(print_variable_value): Use get_user_print_options.
	* p-valprint.c (pascal_val_print): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(pascal_value_print): Remove format, pretty arguments; add
	options.  Update.
	(vtblprint, objectprint): Don't declare.
	(pascal_static_field_print): Remove.
	(pascal_object_print_value_fields): Remove format, pretty
	arguments; add options.  Update.
	(pascal_object_print_static_field): Likewise.
	(_initialize_pascal_valprint): Use user_print_options.  Update.
	* p-lang.h (pascal_val_print, pascal_value_print,
	pascal_printstr, pascal_object_print_value_fields): Update.
	(vtblprint, static_field_print): Don't declare.
	* p-lang.c (pascal_printstr): Add options argument.  Update.
	* objc-lang.c (objc_printstr): Add options argument.  Update.
	* mt-tdep.c: Include valprint.h.
	(mt_registers_info): Use get_raw_print_options.
	* mips-tdep.c: Include valprint.h.
	(mips_print_fp_register): Use get_formatted_print_options.
	(mips_print_register): Likewise.
	* mi/mi-main.c: Include valprint.h.
	(get_register): Use get_user_print_options.
	(mi_cmd_data_evaluate_expression): Likewise.
	(mi_cmd_data_read_memory): Use get_formatted_print_options.
	* mi/mi-cmd-stack.c: Include valprint.h.
	(list_args_or_locals): Use get_raw_print_options.
	* m2-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(m2_print_long_set): Remove format, pretty arguments.
	(m2_print_unbounded_array): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(print_unpacked_pointer): Remove format argument; add options.
	Now static.  Update.
	(print_variable_at_address): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(m2_print_array_contents): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* m2-lang.c (m2_printstr): Add options argument. Update.
	* language.h (struct value_print_options): Declare.
	(struct language_defn) <la_printstr>: Add options argument.
	<la_val_print>: Remove format, deref_ref, pretty argument; add
	options.
	<la_value_print>: Remove format, pretty arguments; add options.
	<la_print_array_index>: Likewise.
	(LA_VAL_PRINT, LA_VALUE_PRINT, LA_PRINT_STRING,
	LA_PRINT_ARRAY_INDEX): Update.
	(default_print_array_index): Update.
	* language.c (default_print_array_index): Remove format, pretty
	arguments; add options.  Update.
	(unk_lang_printstr): Add options argument.
	(unk_lang_val_print): Remove format, deref_ref, pretty arguments;
	add options.
	(unk_lang_value_print): Remove format, pretty arguments; add
	options.
	* jv-valprint.c (java_value_print): Remove format, pretty
	arguments; add options.  Update.
	(java_print_value_fields): Likewise.
	(java_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	* jv-lang.h (java_val_print, java_value_print): Declare.
	* infcmd.c: Include valprint.h.
	(print_return_value): Use get_raw_print_options.
	(default_print_registers_info): Use get_user_print_options,
	get_formatted_print_options.
	(registers_info): Use get_formatted_print_options.
	* gdbtypes.h (struct value_print_options): Declare.
	(print_scalar_formatted): Update.
	* f-valprint.c (f77_print_array_1): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Update.
	* f-lang.c (f_printstr): Add options argument.  Update.
	(c_value_print): Update declaration.
	* expprint.c: Include valprint.h.
	(print_subexp_standard): Use get_raw_print_options,
	get_user_print_options.
	* eval.c: Include valprint.h.
	(objectprint): Don't declare.
	(evaluate_subexp_standard): Use get_user_print_options.
	* cp-valprint.c (vtblprint, objectprint, static_field_print):
	Remove.
	(cp_print_value_fields): Remove format, pretty arguments; add
	options.  Update.
	(cp_print_value): Likewise.
	(cp_print_static_field): Likewise.
	(_initialize_cp_valprint): Use user_print_options.  Update.
	* c-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(c_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(c_value_print): Add options argument.  Update.
	* c-lang.h (c_val_print, c_value_print, c_printstr): Update.
	(vtblprint, static_field_print): Don't declare.
	(cp_print_value_fields): Update.
	* c-lang.c (c_printstr): Add options argument.  Update.
	* breakpoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(watchpoint_value_print): Use get_user_print_options.
	(print_one_breakpoint_location): Likewise.
	(breakpoint_1, print_it_catch_fork, print_it_catch_vfork, mention,
	print_exception_catchpoint): Likewise.
	* auxv.c (fprint_target_auxv): Don't declare addressprint.  Use
	get_user_print_options.
	* ada-valprint.c (struct ada_val_print_args): Remove format,
	deref_ref, and pretty; add options.
	(print_optional_low_bound): Add options argument.
	(val_print_packed_array_elements): Remove format and pretty
	arguments; add options.  Update.
	(printstr): Add options argument.  Update.
	(ada_printstr): Likewise.
	(ada_val_print): Remove format, deref_ref, pretty arguments; add
	options argument.  Update.
	(ada_val_print_stub): Update.
	(ada_val_print_array): Remove format, deref_ref, pretty arguments;
	add options.  Update.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Remove format, pretty arguments; add options.
	Update.
	(print_record): Likewise.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print, ada_value_print, ada_printstr):
	Update.
	* ada-lang.c (ada_print_array_index): Add options argument; remove
	format and pretty arguments.
	(print_one_exception): Use get_user_print_options.
gdb/testsuite
	* gdb.base/exprs.exp (test_expr): Add enum formatting tests.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.79
log
@gdb
	PR gdb/2484:
	* symtab.c (struct add_macro_name_data): New struct.
	(add_macro_name): New function.
	(default_make_symbol_completion_list): Complete macro names.
	* scm-lang.c (scm_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* macrotab.h (macro_callback_fn): Add user_data argument.
	(macro_for_each): Likewise.
	(macro_for_each_in_scope): Declare.
	* macrotab.c: (struct macro_for_each_data): New struct.
	(foreach_macro): Use it.
	(macro_for_each): Likewise.
	(foreach_macro_in_scope): New function.
	(macro_for_each_in_scope): Likewise.
	* macrocmd.c (print_one_macro): Add argument.
	(macro_list_command): Pass NULL to macro_for_each.
	* m2-lang.c (m2_language_defn): Update.
	* language.h (struct language_defn) <la_macro_expansion>: New
	field.
	(macro_expansion): New enum.
	* language.c (unknown_language_defn): Update.  Fix order of
	initializers.
	(auto_language_defn): Likewise.
	(local_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* c-lang.c (c_language_defn): Update.
	(cplus_language_defn): Likewise.
	(asm_language_defn): Likewise.
	(minimal_language_defn): Likewise.
	* ada-lang.c (ada_language_defn): Update.
gdb/testsuite
	* gdb.base/macscp.exp: Add completion tests.
	* gdb.base/macscp1.c (FIFTY_SEVEN): New macro.
	(TWENTY_THREE): Likewise.
	(FORTY_EIGHT): Likewise.
@
text
@d75 2
a76 1
static int unk_lang_value_print (struct value *, struct ui_file *, int, enum val_prettyprint);
d1039 1
a1039 1
                           int format, enum val_prettyprint pretty)
d1042 1
a1042 1
  LA_VALUE_PRINT (index_value, stream, format, pretty);
d1074 2
a1075 1
		   unsigned int length, int width, int force_ellipses)
d1090 2
a1091 2
		    struct ui_file *stream, int format,
		    int deref_ref, int recurse, enum val_prettyprint pretty)
d1097 2
a1098 2
unk_lang_value_print (struct value *val, struct ui_file *stream, int format,
		      enum val_prettyprint pretty)
@


1.78
log
@gdb
	* scm-lang.c (scm_language_defn): Update.
	* p-typeprint.c (pascal_print_typedef): New function.
	* p-lang.h: (pascal_print_typedef): Declare.
	* p-lang.c (pascal_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* m2-typeprint.c (m2_print_typedef): New function.
	* m2-lang.h (m2_print_typedef): Declare.
	* m2-lang.c (m2_language_defn): Update.
	* language.h (_LANG_c, _LANG_m2, _LANG_fortran, _LANG_pascal):
	Remove.
	(struct language_defn) <la_print_typedef>: New field.
	(default_print_typedef): Declare.
	(LA_PRINT_TYPEDEF): New define.
	* language.c (unknown_language_defn): Update.
	(auto_language_defn): Update.
	(local_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* c-typeprint.c (c_print_typedef): New function.
	* c-lang.h (c_print_typedef): Declare.
	* c-lang.c (c_language_defn): Update.
	(cplus_language_defn): Update.
	(asm_language_defn): Update.
	(minimal_language_defn): Update.
	* ada-lang.c (ada_language_defn): Update.
	* typeprint.c (default_print_typedef): New function.
gdb/doc
	* gdbint.texinfo (Language Support): Remove text about omitting
	support for a language.
@
text
@d1138 1
d1140 1
a1140 1
  case_sensitive_on,
d1176 1
d1178 1
a1178 1
  case_sensitive_on,
d1215 1
@


1.77
log
@	* language.h (struct language_arch_info): New members
	bool_type_default and bool_type_symbol.
	(lang_bool_type): Remove prototype.
	(LA_BOOL_TYPE): Remove macro.
	(language_bool_type): Add prototype.
	* language.c (lang_bool_type): Remove.
	(language_bool_type): New function.

	* value.h (value_in): Change return value to int.
	* value.c (value_in): Return int instead of struct value *.

	* eval.c (evaluate_subexp_standard): Call language_bool_type instead
	of using LA_BOOL_TYPE.  Update call to value_in.
	* ada-lang.c (ada_evaluate_subexp): Call language_bool_type instead
	of using LA_BOOL_TYPE or builtin_type_int for boolean values.

	* language.c (unknown_language_arch_info): Set bool_type_default member
	of struct language_arch_info.
	* ada-lang.c (ada_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* c-lang.c (c_language_arch_info): Set bool_type_default member
	of struct language_arch_info.
	(cplus_language_arch_info): Set bool_type_symbol and bool_type_default
	members of struct language_arch_info.
	* f-lang.c (f_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* jv-lang.c (java_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* m2-lang.c (m2_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* p-lang.c (p_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
@
text
@d1148 1
d1185 1
d1221 1
@


1.76
log
@	* symtab.h (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	* symtab.c (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	(search_symbols): Update.

	* linespec.c (find_methods, collect_methods): Update.
	(add_matching_methods, add_constructors): Update.
	(decode_compound, decode_dollar, decode_variable): Update.
	(lookup_prefix_sym): Update.

	(symbol_found): Remove SYM_SYMTAB parameter.
	Use SYMBOL_SYMTAB (sym) instead.

	* gdbtypes.c (lookup_typename): Update.
	(lookup_struct, lookup_union, lookup_enum): Update.
	(lookup_template_type): Update.
	(check_typedef): Update.
	* language.c (lang_bool_type): Update.
	* mdebugread.c (parse_procedure): Update.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* parse.c (write_dollar_variable): Update.
	* printcmd.c (address_info): Update.
	* source.c (select_source_symtab): Update.
	* stack.c (print_frame_args, print_frame_arg_vars): Update.
	* valops.c (find_function_in_inferior): Update.
	(value_struct_elt_for_reference): Update.
	* value.c (value_static_field, value_fn_field): Update.

	* alpha-mdebug-tdep.c (find_proc_desc): Update.
	* arm-tdep.c (arm_skip_prologue): Update.
	* mt-tdep.c (mt_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Update.

	* ada-lang.h (struct ada_symbol_info): Remove SYMTAB member.
	* ada-lang.c (ada_add_block_symbols): Remove SYMTAB parameter.
	(add_defn_to_vec): Likewise.
	(ada_add_block_symbols): Likewise.
	(lookup_cached_symbol, cache_symbol): Likewise.
	(standard_lookup): Update.
	(ada_lookup_symbol_list): Update.

	* c-valprint.c (c_val_print): Update.
	* cp-support.c (cp_lookup_rtti_type): Update.
	* jv-lang.c (java_lookup_class, get_java_object_type): Update.
	* objc-lang.c (lookup_struct_typedef, find_imps): Update.
	* p-valprint.c (pascal_val_print): Update.
	* scm-lang.c (scm_lookup_name): Update.

	* c-exp.y: Update.
	* f-exp.y: Update.
	* jv-exp.y: Update.
	* m2-exp.y: Update.
	* objc-exp.y: Update.
	* p-exp.y: Update.
@
text
@a789 45
struct type *
lang_bool_type (void)
{
  struct symbol *sym;
  struct type *type;
  switch (current_language->la_language)
    {
    case language_fortran:
      sym = lookup_symbol ("logical", NULL, VAR_DOMAIN, NULL);
      if (sym)
	{
	  type = SYMBOL_TYPE (sym);
	  if (type && TYPE_CODE (type) == TYPE_CODE_BOOL)
	    return type;
	}
      return builtin_type_f_logical_s2;
    case language_cplus:
    case language_pascal:
    case language_ada:
      if (current_language->la_language==language_cplus)
        {sym = lookup_symbol ("bool", NULL, VAR_DOMAIN, NULL);}
      else
        {sym = lookup_symbol ("boolean", NULL, VAR_DOMAIN, NULL);}
      if (sym)
	{
	  type = SYMBOL_TYPE (sym);
	  if (type && TYPE_CODE (type) == TYPE_CODE_BOOL)
	    return type;
	}
      return builtin_type_bool;
    case language_java:
      sym = lookup_symbol ("boolean", NULL, VAR_DOMAIN, NULL);
      if (sym)
	{
	  type = SYMBOL_TYPE (sym);
	  if (type && TYPE_CODE (type) == TYPE_CODE_BOOL)
	    return type;
	}
      return java_boolean_type;
      
    default:
      return builtin_type_int;
    }
}

d1127 1
d1276 23
@


1.75
log
@	Fix breakpoint condition that use member variables.
        * valops.c (check_field): Remove.
        (check_field_in): Rename to check_field.
        (value_of_this): Use la_name_of_this.
        * value.h (check_field): Adjust prototype.

        * language.h (la_value_of_this): Rename to la_name_of_this.
        * language.c (unknown_language_defn): Specify "this" for
        name_of_this.
        (auto_language_defn): Likewise.
        (local_language_defn): Likewise.
        * ada-lang.c (ada_language_defn): Adjust comment.
        * c-lang.c (c_language_defn): Adjust comment.
        (cplus_language_defn): Specify "this" for name_of_this.
        (asm_language_defn): Adjust comment.
        (minimal_language_defn): Adjust comment.
        * f-lang.c (f_language_defn): Specify NULL for name_of_this.
        * jv-lang.c (java_language_defn): Specify "this" for name_of_this.
        * m2-lang.c (m2_language_defn): Specify "this" for name_of_this.
        * objc-lang.c (objc_language_defn): Specify "self" for
        name_of_this.
        * p-lang.c (pascal_language_defn): Specify "this" for
        name_of_this.
        * scm-lang.c (scm_language_defn): Specify NULL for name_of_this.

        * symtab.c (lookup_symbol_aux): Lookup "this" in the
        proper scope, and check for field in type of "this", without
        trying to create a value.
@
text
@d798 1
a798 1
      sym = lookup_symbol ("logical", NULL, VAR_DOMAIN, NULL, NULL);
d810 1
a810 1
        {sym = lookup_symbol ("bool", NULL, VAR_DOMAIN, NULL, NULL);}
d812 1
a812 1
        {sym = lookup_symbol ("boolean", NULL, VAR_DOMAIN, NULL, NULL);}
d821 1
a821 1
      sym = lookup_symbol ("boolean", NULL, VAR_DOMAIN, NULL, NULL);
@


1.74
log
@        * language.h (struct language_defn): Add new field
        la_make_symbol_completion_list.
        * symtab.c (default_make_symbol_completion_list): Renames
        make_symbol_completion_list.
        (make_symbol_completion_list): New function.
        * symtab.h (default_make_symbol_completion_list): Add declaration.
        * langauge.c (unknown_language): Set la_make_symbol_completion_list.
        (auto_language, local_language): Likewise.
        * objc-lang.c (objc_language_defn): Likewise.
        * scm-lang.c (scm_language_defn): Likewise.
        * m2-lang.c (m2_language_defn): Likewise.
        * f-lang.c (f_language_defn): Likewise.
        * jv-lang.c (java_language_defn): Likewise.
        * p-lang.c (pascal_language_defn): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn, asm_language_defn)
        (minimal_language_defn): Likewise.
        * ada-lang.c (struct string_vector): New structure.
        (new_string_vector, string_vector_append, ada_unqualified_name)
        (add_angle_brackets, symbol_completion_match, symbol_completion_add)
        (ada_make_symbol_completion_list): New functions.
        (ada_language_defn): Set la_make_symbol_completion_list.
        * ada-lang.h (ada_make_symbol_completion_list): Remove declaration,
        this function is static.
@
text
@d1195 1
a1195 1
  value_of_this,		/* value_of_this */
d1231 1
a1231 1
  value_of_this,		/* value_of_this */
d1266 1
a1266 1
  value_of_this,		/* value_of_this */
@


1.73
log
@        * symfile.c (set_initial_language): Make non-static.
        * symfile.h (set_initial_language): Add declaration.
        * language.c: #include "symfile.h".
        (set_language): Call set_initial_language if the frame language
        could not be determined.
@
text
@d1204 1
d1240 1
d1275 1
@


1.72
log
@	Updated copyright notices for most files.
@
text
@d46 1
d189 2
a190 1
	      /* Enter auto mode.  Set to the current frame's language, if known.  */
d195 2
@


1.71
log
@        * ada-lang.c (ada_evaluate_subexp): Add cases for BINOP_LOGICAL_AND,
        BINOP_LOGICAL_OR, UNOP_LOGICAL_NOT, BINOP_BITWISE_IOR,
        BINOP_BITWISE_XOR, BINOP_BITWISE_AND.
        * language.c (lang_bool_type): Add Ada case.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.70
log
@	* coffread.c (decode_type): Use builtin_type_int32 instead
	of FT_INTEGER fundamental type for array range index type.
	(decode_base_type): Use builtin types of current_gdbarch
	instead of fundamental types.

	* dwarf2read.c (struct dwarf2_cu): Remove ftypes member.
	(read_file_scope): Do not initialize ftypes member.
	(dwarf_base_type, dwarf2_fundamental_types): Remove functions.
	(read_array_type): Use builtin_type_int32 instead of FT_INTEGER
	fundamental type for array range index type.
	(read_tag_string_type): Likewise for string range index type.
	Also, do not overwrite FT_CHAR type with new string type.
	(read_base_type): If DW_AT_name is missing, create unnamed type
	with given properties instead of looking for a fundamental type.
	Create new types as TYPE_TARGET_TYPE for DW_ATE_address and
	DW_ATE_complex_float types.
	(read_subrange_type): Create new type to represent missing
	DW_AT_type instead of looking for a fundamental type.
	(die_type): Use builtin type to represent "void" instead of
	looking for a fundamental type.

	* stabsread.c (define_symbol): Use builtin types to represent
	'r' and 'i' floating-point and integer constants.

	* gdbtypes.c (lookup_fundamental_type): Remove.
	* gdbtypes.h (lookup_fundamental_type): Remove prototype.
	(FT_VOID, FT_BOOLEAN, FT_CHAR, FT_SIGNED_CHAR, FT_UNSIGNED_CHAR,
	FT_SHORT, FT_SIGNED_SHORT, FT_UNSIGNED_SHORT, FT_INTEGER,
	FT_SIGNED_INTEGER, FT_UNSIGNED_INTEGER, FT_LONG, FT_SIGNED_LONG,
	FT_UNSIGNED_LONG, FT_LONG_LONG, FT_SIGNED_LONG_LONG,
	FT_UNSIGNED_LONG_LONG, FT_FLOAT, FT_DBL_PREC_FLOAT, FT_EXT_PREC_FLOAT,
	FT_COMPLEX, FT_DBL_PREC_COMPLEX, FT_EXT_PREC_COMPLEX, FT_STRING,
	FT_FIXED_DECIMAL, FT_FLOAT_DECIMAL, FT_BYTE, FT_UNSIGNED_BYTE,
	FT_TEMPLATE_ARG, FT_DECFLOAT, FT_DBL_PREC_DECFLOAT,
	FT_EXT_PREC_DECFLOAT, FT_NUM_MEMBERS): Remove macros.
	* objfiles.c (struct objfile): Remove fundamental_types member.
	* symfile.c (reread_symbols): Do not clear fundamental_types.

	* language.h (struct language_defn): Remove la_fund_type member.
	(create_fundamental_type): Remove.
	* language.c (unk_lang_create_fundamental_type): Remove.
	(unknown_language_defn, auto_language_defn,
	local_language_defn): Adapt initializer.
	* ada-lang.c (ada_create_fundamental_type): Remove.
	(ada_language_defn): Adapt initializer.
	* c-lang.h (c_create_fundamental_type): Remove prototype.
	* c-lang.c (c_create_fundamental_type): Remove.
	(c_language_defn, cplus_language_defn, asm_language_defn,
	minimal_language_defn): Adapt initializer.
	* f-lang.c (f_create_fundamental_type): Remove.
	(f_language_defn): Adapt initializer.
	* jv-lang.c (java_create_fundamental_type): Remove.
	(java_language_defn): Adapt initializer.
	* m2-lang.c (m2_create_fundamental_type): Remove.
	(m2_language_defn): Adapt initializer.
	* objc-lang.c (objc_create_fundamental_type): Remove.
	(objc_language_defn): Adapt initializer.
	* p-lang.h (pascal_create_fundamental_type): Remove prototype.
	* p-lang.c (pascal_create_fundamental_type): Remove.
	(pascal_language_defn): Adapt initializer.
	* scm-lang.c (scm_language_defn): Adapt initializer.
@
text
@d804 1
d825 1
@


1.69
log
@	* language.h (struct language_defn): Remove la_builtin_type_vector
	and string_char_type members.
	* language.c (language_string_char_type): No longer consult
	la->string_char_type.
	(language_lookup_primitive_type_by_name): No longer consult
	current_language->la_builtin_type_vector.

	* language.c (unknown_language_defn, auto_language_defn,
	local_language_defn): Adapt initializer.
	* ada-lang.c (ada_language_defn): Likewise.
	* c-lang.c (c_language_defn, cplus_language_defn, asm_language_defn,
	minimal_language_defn): Likewise.
	* f-lang.c (f_language_defn): Likewise.
	* jv-lang.c (java_language_defn): Likewise.
	* m2-lang.c (m2_language_defn): Likewise.
	* objc-lang.c (objc_language_defn): Likewise.
	* p-lang.c (pascal_language_defn): Likewise.
	* scm-lang.c (scm_language_defn): Likewise.
@
text
@a70 2
static struct type *unk_lang_create_fundamental_type (struct objfile *, int);

a1116 6
static struct type *
unk_lang_create_fundamental_type (struct objfile *objfile, int typeid)
{
  error (_("internal error - unimplemented function unk_lang_create_fundamental_type called."));
}

a1184 1
  unk_lang_create_fundamental_type,
a1219 1
  unk_lang_create_fundamental_type,
a1253 1
  unk_lang_create_fundamental_type,
@


1.68
log
@	* infcall.c (call_function_by_hand): Handle language-specific
	pass and return by reference.

	* cp-abi.c (cp_pass_by_reference): New.
	* cp-abi.h (cp_pass_by_reference): Declare.
	(struct cp_abi_ops): Add pass_by_reference.
	* gnu-v3-abi.c (gnuv3_pass_by_reference): New.
	(init_gnuv3_ops): Set pass_by_reference.

	* language.c (language_pass_by_reference): New.
	(default_pass_by_reference): New.
	(unknown_language_defn, auto_language_defn, local_language_defn): Add
	default_pass_by_reference.
	* langauge.h (struct language_defn): Add la_pass_by_reference.
	(language_pass_by_reference, default_pass_by_reference): Declare.
	* ada-lang.c (ada_language_defn): Add default_pass_by_reference.
	* c-lang.c (c_language_defn, asm_language_defn)
	(minimal_language_defn): Likewise.
	(cplus_language_defn): Add cp_pass_by_reference.
	* f-lang.c (f_language_defn): Add default_pass_by_reference.
	* jv-lang.c (java_language_defn): Likewise.
	* m2-lang.c (m2_language_defn): Likewise.
	* objc-lang.c (objc_language_defn): Likewise.
	* p-lang.c (pascal_language_defn): Likewise.
	* scm-lang.c (scm_language_defn): Likewise

	* gdb.cp/pass-by-ref.cc, gdb.cp/pass-by-ref.exp: New files.
@
text
@a1181 1
  NULL,
a1205 1
  NULL,
a1217 1
  NULL,
a1241 1
  NULL,
a1252 1
  NULL,
a1276 1
  NULL,
d1318 1
a1318 4
  if (ld->arch_info[la->la_language].string_char_type != NULL)
    return ld->arch_info[la->la_language].string_char_type;
  else
    return (*la->string_char_type);
d1328 4
a1331 1
  if (ld->arch_info[la->la_language].primitive_type_vector != NULL)
d1333 2
a1334 17
      struct type *const *p;
      for (p = ld->arch_info[la->la_language].primitive_type_vector;
	   (*p) != NULL;
	   p++)
	{
	  if (strcmp (TYPE_NAME (*p), name) == 0)
	    return (*p);
	}
    }
  else
    {
      struct type **const *p;
      for (p = current_language->la_builtin_type_vector; *p != NULL; p++)
	{
	  if (strcmp (TYPE_NAME (**p), name) == 0)
	    return (**p);
	}
@


1.67
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d1048 17
d1211 1
d1249 1
d1286 1
@


1.66
log
@	* gdbarch.sh (skip_trampoline_code): Add FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (generic_skip_trampoline_code): Add FRAME argument.
	* arch-utils.h (generic_skip_trampoline_code): Likewise.
	* infrun.c (handle_inferior_event): Pass current frame to
	gdbarch_skip_trampoline_code and skip_language_trampoline.

	* language.c (unk_lang_trampoline): Add FRAME argument.
	(skip_language_trampoline): Add FRAME argument.  Pass it to
	skip_trampoline callback.
	* language.h: Add forward declaration of struct frame_info.
	(struct language_defn): Add FRAME argument to skip_trampoline.
	(skip_language_trampoline): Add FRAME argument.
	* cp-abi.c (cplus_skip_trampoline): Add FRAME argument.  Pass it
	to skip_trampoline callback.
	* cp-abi.h: Add forward declaration of struct frame_info.
	(cplus_skip_trampoline): Add FRAME argument.
	(struct cp_abi_ops): Add FRAME argument to skip_trampoline callback.
	* gnu-v3-abi.c (gnuv3_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.
	* objc-lang.c (objc_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.

	* minsyms.c (find_solib_trampoline_target): Add FRAME argument.
	* symtab.h (find_solib_trampoline_target): Likewise.
	* obsd-tdep.c (obsd_skip_solib_resolver): Pass current frame to
	find_solib_trampoline_target.

	* arm-tdep.c (arm_skip_stub): Add FRAME argument.  Read registers
	from FRAME instead of calling read_register.

	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code): Add FRAME
	argument.  Read registers from FRAME instead of using read_register.
	* hppa-tdep.c (hppa_skip_trampoline_code): Likewise.
	* hppa-tdep.h (hppa_skip_trampoline_code): Add FRAME argument.

	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Add FRAME
	argument.

	* m32c-tdep.c (m32c_skip_trampoline_code): Add FRAME argument.

	* mips-tdep.c (mips_skip_trampoline_code): Add FRAME argument.  Read
	registers from FRAME instead of using read_signed_register.

	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Add FRAME
	argument.
	(ppc64_standard_linkage_target): Likewise.  Read registers from FRAME
	instead of using read_register.
	(ppc64_skip_trampoline_code): Add FRAME argument.  Pass it to
	ppc64_standard_linkage_target.
	* rs6000-tdep.c (rs6000_skip_trampoline_code): Add FRAME argument.
	Pass it to find_solib_trampoline_target.  Read registers from FRAME
	instead of using read_register.

	* xstormy16-tdep.c (xstormy16_skip_trampoline_code): Add FRAME
	argument.
@
text
@d13 1
a13 1
   the Free Software Foundation; either version 2 of the License, or
d22 1
a22 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.65
log
@Copyright updates for 2007.
@
text
@d80 1
a80 1
static CORE_ADDR unk_lang_trampoline (CORE_ADDR pc);
d1008 1
a1008 1
skip_language_trampoline (CORE_ADDR pc)
d1016 1
a1016 1
	  CORE_ADDR real_pc = (languages[i]->skip_trampoline) (pc);
d1133 1
a1133 1
static CORE_ADDR unk_lang_trampoline (CORE_ADDR pc)
@


1.64
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 2
a4 2
   Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
@


1.63
log
@2005-10-03  Joel Brobecker  <brobecker@@adacore.com>

        * language.h (language_defn): New field la_print_array_index.
        (LA_PRINT_ARRAY_INDEX): New macro.
        (default_print_array_index): Add declaration.
        * language.c (default_print_array_index): new function.
        (unknown_language): Add value for new field.
        (auto_language): Likewise.
        (local_language): Likewise.
        * ada-lang.c (ada_print_array_index): New function.
        (ada_language_defn): Add value for new field.
        * c-lang.c (c_language_defn): Likewise.
        (cpluc_language_defn): Likewise.
        (asm_language_defn): Likewise.
        (minimal_language_defn): Likewise.
        * f-lang.c (f_language_defn): Likewise.
        * jv-lang.c (java_language_defn): Likewise.
        * m2-lang.c (m2_language_defn): Likewise.
        * objc-lang.c (objc_language_defn): Likewise.
        * p-lang.c (pascal_language_defn): Likewise.
        * scm-lang.c (scm_language_defn): Likewise.
        * valprint.h (print_array_indexes_p): Add declaration.
        (get_array_low_bound): Add declaration.
        (maybe_print_array_index): Add declaration.
        * valprint.c (print_array_indexes): New static variable.
        (show_print_array_indexes): New function.
        (print_array_indexes_p): New function.
        (get_array_low_bound): New function.
        (maybe_print_array_index): New function.
        (val_print_array_elements): Print the index of each element if
        requested by the user.
        (_initialize_valprint): Add new array-indexes "set/show print" command.
        * ada-valprint.c (print_optional_low_bound): Replace extracted code
        by call to ada_get_array_low_bound_and_type(). Stop printing the low
        bound if indexes will be printed for all elements of the array.
        (val_print_packed_array_elements): Print the index of each element
        of the array if necessary.
@
text
@d3 1
a3 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
d23 2
a24 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.62
log
@* environ.c (unset_in_environ): Use strncmp instead of
DEPRECATED_STREQN.
* exec.c (exec_file_attach): Remove DEPRECATED_HPUX_TEXT_END.
* language.c (set_case_command, language_enum): Use strcmp instead
of DEPRECATED_STREQ.
* source.c (select_source_symtab): Sprinkle a few consts.  Use
strcmp instead of DEPRECATED_STREQ.
@
text
@d1060 11
d1195 1
d1232 1
d1268 1
@


1.61
log
@* bsd-kvm.c (bsd_kvm_open): Properly cast sentinel in concat call.
* coffread.c (patch_type, process_coff_symbol): Likewise.
* corelow.c (core_open): Likewise.
* dwarf2read.c (dwarf_decode_lines, dwarf2_start_subfile):
* language.c (set_lang_str, set_type_str, set_range_str)
(set_case_str): Likewise.
* source.c (add_path, openp): Likewise.
* stabsread.c: Likewise.
* top.c (init_history): Likewise.
* utils.c (xfullpath): Likewise.
* value.c (lookup_internalvar): Likewise.
* cli/cli-cmds.c (cd_command): Likewise.
* cli/cli-dump.c (add_dump_command): Likewise.
@
text
@d327 2
a328 1
/* Set command.  Change the setting for case sensitivity. */
d332 18
a349 18
   if (DEPRECATED_STREQ (case_sensitive, "on"))
   {
      case_sensitivity = case_sensitive_on;
      case_mode = case_mode_manual;
   }
   else if (DEPRECATED_STREQ (case_sensitive, "off"))
   {
      case_sensitivity = case_sensitive_off;
      case_mode = case_mode_manual;
   }
   else if (DEPRECATED_STREQ (case_sensitive, "auto"))
   {
      case_mode = case_mode_auto;
      set_type_range_case ();
      /* Avoid hitting the set_case_str call below.  We
         did it in set_type_range_case. */
      return;
   }
d351 4
a354 3
   {
      warning (_("Unrecognized case-sensitive setting: \"%s\""), case_sensitive);
   }
d923 1
a923 1
    if (DEPRECATED_STREQ (languages[i]->la_name, str))
@


1.60
log
@2005-05-09  Andrew Cagney  <cagney@@gnu.org>

	Use gdb_byte in preference to bfd_byte.
	* gdbarch.sh: Update.
	* gdbarch.h, gdbarch.c: Re-generate.
	* ada-lang.c, ada-lang.h, ada-valprint.c, arch-utils.c: Update.
	* c-lang.c, c-lang.h, c-valprint.c, cp-valprint.c: Update.
	* f-lang.c, f-lang.h, f-valprint.c, gdbcore.h, jv-lang.h: Update.
	* jv-valprint.c, language.c, language.h, m2-lang.c: Update.
	* m2-lang.h, m2-valprint.c, objc-lang.c, p-lang.c: Update.
	* p-lang.h, p-valprint.c, regcache.c, scm-lang.c: Update.
	* scm-lang.h, scm-valprint.c, target.c, target.h: Update.
	* tramp-frame.c, valarith.c, valops.c, valprint.c: Update.
	* valprint.h, value.c, value.h: Update.
@
text
@d415 1
a415 1
  language = concat (prefix, current_language->la_name, NULL);
d443 1
a443 1
  type = concat (prefix, tmp, NULL);
d471 1
a471 1
  range = concat (pref, tmp, NULL);
d495 1
a495 1
   case_sensitive = concat (prefix, tmp, NULL);
@


1.59
log
@2005-02-21  Andrew Cagney  <cagney@@gnu.org>

	Add more uses of add_setshow_string_cmd, add_setshow_integer_cmd,
	and add_setshow_string_noescape_cmd.
	* cli/cli-setshow.c (deprecated_show_value_hack): Do not print a
	NULL command's value.
	* kod.c, language.c, ocd.c, remote-e7000.c, remote-mips.c: Update.
	* remote-sds.c, remote.c, symfile.c, top.c: Update.
@
text
@d1085 1
a1085 1
unk_lang_printstr (struct ui_file *stream, const bfd_byte *string,
d1105 1
a1105 1
unk_lang_val_print (struct type *type, const bfd_byte *valaddr,
@


1.58
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@a50 16
static void show_language_command (char *, int);

static void set_language_command (char *, int);

static void show_type_command (char *, int);

static void set_type_command (char *, int);

static void show_range_command (char *, int);

static void set_range_command (char *, int);

static void show_case_command (char *, int);

static void set_case_command (char *, int);

d136 2
a137 1
show_language_command (char *ignore, int from_tty)
d141 1
d151 1
a151 1
set_language_command (char *ignore, int from_tty)
d224 2
a225 1
show_type_command (char *ignore, int from_tty)
d227 1
d235 1
a235 1
set_type_command (char *ignore, int from_tty)
d265 1
a265 1
  show_type_command ((char *) NULL, from_tty);
d271 2
a272 1
show_range_command (char *ignore, int from_tty)
d274 1
a274 1

d282 1
a282 1
set_range_command (char *ignore, int from_tty)
d312 1
a312 1
  show_range_command ((char *) 0, from_tty);
d318 2
a319 1
show_case_command (char *ignore, int from_tty)
d321 3
a323 2
   if (case_sensitivity != current_language->la_case_sensitivity)
      printf_unfiltered(
d329 1
a329 1
set_case_command (char *ignore, int from_tty)
d354 1
a354 1
   show_case_command ((char *) NULL, from_tty);
d509 1
a509 1
  show_language_command ((char *) 0, 1);
d514 1
a514 1
      show_type_command ((char *) 0, 1);
d516 1
a516 1
      show_range_command ((char *) 0, 1);
d518 1
a518 1
      show_case_command ((char *) 0, 1);
d1338 8
a1345 7
  set = add_set_cmd ("language", class_support, var_string_noescape,
		     (char *) &language,
		     "Set the current source language.",
		     &setlist);
  show = deprecated_add_show_from_set (set, &showlist);
  set_cmd_cfunc (set, set_language_command);
  set_cmd_cfunc (show, show_language_command);
d1359 28
a1386 24
  set = add_set_cmd ("type", class_support, var_string_noescape,
		     (char *) &type,
		     "Set type checking.  (on/warn/off/auto)",
		     &setchecklist);
  show = deprecated_add_show_from_set (set, &showchecklist);
  set_cmd_cfunc (set, set_type_command);
  set_cmd_cfunc (show, show_type_command);

  set = add_set_cmd ("range", class_support, var_string_noescape,
		     (char *) &range,
		     "Set range checking.  (on/warn/off/auto)",
		     &setchecklist);
  show = deprecated_add_show_from_set (set, &showchecklist);
  set_cmd_cfunc (set, set_range_command);
  set_cmd_cfunc (show, show_range_command);

  set = add_set_cmd ("case-sensitive", class_support, var_string_noescape,
                     (char *) &case_sensitive,
                     "Set case sensitivity in name search.  (on/off/auto)\n\
For Fortran the default is off; for other languages the default is on.",
                     &setlist);
  show = deprecated_add_show_from_set (set, &showlist);
  set_cmd_cfunc (set, set_case_command);
  set_cmd_cfunc (show, show_case_command);
@


1.57
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d1356 1
a1356 1
		  "Set the status of the type/range checker.",
d1362 1
a1362 1
		  "Show the status of the type/range checker.",
@


1.56
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d173 3
a175 2
      printf_unfiltered ("The currently understood settings are:\n\n");
      printf_unfiltered ("local or auto    Automatic setting based on source file\n");
d184 2
a185 2
	  /* FIXME for now assume that the human-readable name is just
	     a capitalization of the internal name.  */
d517 1
a517 1
  printf_unfiltered ("Current language:  %s\n", language);
d522 1
a522 1
      printf_unfiltered ("Type checking:     %s\n", type);
d524 1
a524 1
      printf_unfiltered ("Range checking:    %s\n", range);
d526 1
a526 1
      printf_unfiltered ("Case sensitivity:  %s\n", case_sensitive);
@


1.55
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d568 1
a568 1
  internal_error (__FILE__, __LINE__, "failed internal consistency check");
d887 1
a887 1
      internal_error (__FILE__, __LINE__, "bad switch");
d913 1
a913 1
      internal_error (__FILE__, __LINE__, "bad switch");
d991 1
a991 1
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
@


1.54
log
@2005-01-28  Andrew Cagney  <cagney@@gnu.org>

	* language.h (struct language_defn): Make la_val_print's buffer
	parameter a const bfd_byte.
	* cp-valprint.c (cp_print_value_fields, cp_print_value): Update.
	* ada-lang.c (ada_aligned_value_addr)
	(ada_value_primitive_packed_val, ada_which_variant_applies): Update.
	* valprint.c (val_print_array_elements): Update.
	* valprint.h (val_print_array_elements): Update.
	* ada-lang.h (ada_val_print, ada_aligned_value_addr)
	(ada_value_primitive_packed_val, ada_which_variant_applies): Update.
	* ada-valprint.c (ada_val_print, struct ada_val_print_args)
	(ada_val_print_1, ada_print_floating, printable_val_type)
	(print_record, val_print_packed_array_elements)
	(print_field_values, print_variant_part): Update.
	* c-lang.h (c_val_print, cp_print_value_fields): Update.
	* c-valprint.c (c_val_print): Update.
	* f-lang.h (f_val_print): Update.
	* f-valprint.c (f_val_print, f77_print_array_1)
	(f77_print_array): Update.
	* jv-lang.h (java_val_print): Update.
	* jv-valprint.c (java_print_value_fields, java_val_print): Update.
	* language.c (unk_lang_val_print): Update.
	* m2-lang.h (m2_val_print): Update.
	* m2-valprint.c (m2_val_print): Update.
	* p-lang.h (pascal_val_print): Update.
	(pascal_object_print_value_fields): Update.
	* p-valprint.c (pascal_val_print)
	(pascal_object_print_value_fields, pascal_object_print_value)
	(pascal_object_print_value): Update.
	* scm-lang.h (scm_val_print): Update.
	* scm-valprint.c (scm_val_print): Update.
	* value.h (val_print): Update.
@
text
@d231 1
a231 1
  error ("Unknown language `%s'.", err_lang);
d273 1
a273 1
      warning ("Unrecognized type check setting: \"%s\"", type);
d319 1
a319 1
      warning ("Unrecognized range check setting: \"%s\"", range);
d359 1
a359 1
      warning ("Unrecognized case-sensitive setting: \"%s\"", case_sensitive);
d448 1
a448 1
      error ("Unrecognized type check setting.");
d474 1
a474 1
      error ("Unrecognized range check setting.");
d499 1
a499 1
     error ("Unrecognized case-sensitive setting.");
d666 1
a666 1
      error ("Language not supported.");
d1077 1
a1077 1
  error ("Attempted to parse an expression with unknown language");
d1083 1
a1083 1
  error ("internal error - unimplemented function unk_lang_emit_char called.");
d1089 1
a1089 1
  error ("internal error - unimplemented function unk_lang_printchar called.");
d1096 1
a1096 1
  error ("internal error - unimplemented function unk_lang_printstr called.");
d1102 1
a1102 1
  error ("internal error - unimplemented function unk_lang_create_fundamental_type called.");
d1109 1
a1109 1
  error ("internal error - unimplemented function unk_lang_print_type called.");
d1118 1
a1118 1
  error ("internal error - unimplemented function unk_lang_val_print called.");
d1125 1
a1125 1
  error ("internal error - unimplemented function unk_lang_value_print called.");
@


1.53
log
@2005-01-28  Andrew Cagney  <cagney@@gnu.org>

	* language.h (struct language_defn): Make la_printstr's buffer
	parameter a const bfd_byte.
	* p-lang.h (pascal_printstr): Update function to match.
	* ada-valprint.c (ada_printstr): Update function to match.
	* scm-lang.c (scm_printstr): Update function to match.
	* p-lang.c (pascal_printstr): Update function to match.
	* ada-lang.h (ada_printstr): Update function to match.
	* m2-lang.c (m2_printstr): Update function to match.
	* objc-lang.c (objc_printstr): Update function to match.
	* c-lang.h (c_printstr): Update function to match.
	* f-lang.c (f_printstr): Update function to match.
	* c-lang.c (c_printstr): Update function to match.
	* language.c (unk_lang_printstr): Update function to match.
@
text
@a93 4
static int unk_lang_val_print (struct type *, char *, int, CORE_ADDR,
			       struct ui_file *, int, int, int,
			       enum val_prettyprint);

d1113 3
a1115 2
unk_lang_val_print (struct type *type, char *valaddr, int embedded_offset,
		    CORE_ADDR address, struct ui_file *stream, int format,
@


1.52
log
@* language.c (language_gdbarch_post_init): Fix off-by one error.
@
text
@d4 1
a4 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a88 4
static void unk_lang_printstr (struct ui_file * stream, char *string,
			       unsigned int length, int width,
			       int force_ellipses);

d1097 2
a1098 2
unk_lang_printstr (struct ui_file *stream, char *string, unsigned int length,
		   int width, int force_ellipses)
@


1.51
log
@2004-09-11  Andrew Cagney  <cagney@@gnu.org>

	* language.c (hex_string, hex_string_custom): Move from here ...
	* utils.c (hex_string, hex_string_custom): ... to here, rewrite.
	(CELLSIZE): Increase to 50.
	* language.h (hex_string, hex_string_custom): Move from here ...
	* defs.h: ... to here.
	* Makefile.in: Update all dependencies.
@
text
@d1289 1
a1289 1
  for (i = 0; i <= languages_size; i++)
@


1.50
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@a580 42


/* This page contains functions that return format strings for
   printf for printing out numbers in different formats */

#define MAX_NUM_STRING_LEN 50

/* Converts a LONGEST to a C-format hexadecimal literal and stores it in
   a static string.  Returns a pointer to this string. */
char *
hex_string (LONGEST num)
{
  static char result[MAX_NUM_STRING_LEN];
  sprintf (result, "0x%s", phex_nz (num, sizeof (num)));
  return result;
}

/* Converts a LONGEST number to a C-format hexadecimal literal and stores 
   it in a static string.  Returns a pointer to this string that is 
   valid until the next call.  The number is padded on the left with 
   0s to at least WIDTH characters. */

char *
hex_string_custom (LONGEST num, int width)
{
  static char result[MAX_NUM_STRING_LEN];
  char *result_end = result + MAX_NUM_STRING_LEN - 1;
  const char* hex = phex_nz (num, sizeof (num));
  int hex_len = strlen (hex);

  if (hex_len > width)
    width = hex_len;
  if (width + 2 >= MAX_NUM_STRING_LEN)
    internal_error (__FILE__, __LINE__,
		    "hex_string_custom: insufficient space to store result");

  strcpy (result_end - width - 2, "0x");
  memset (result_end - width, '0', width);
  strcpy (result_end - hex_len, hex);
  return result_end - width - 2;
}

@


1.49
log
@2004-08-29  David Lecomber  <david@@streamline-computing.com>

	Fix PR gdb/648
	* language.h (enum array_ordering): New enum.
	* language.h (struct language_defn): New la_array_ordering
	attribute.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Ditto.
	* ada-lang.c (ada_language_defn): Ditto.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Ditto.
	* f-lang.c (f_language_defn): Ditto.
	* jv-lang.c (java_language_defn): Ditto.
	* m2-lang.c (f_language_defn): Ditto.
	* objc-lang.c (objc_language_defn): Ditto.
	* p-lang.c (pascal_language_defn): Ditto.
	* scm-lang.c (scm_language_defn): Ditto.
	* eval.c (evaluate_subexp_standard): Assume Fortran arrays are
	oriented large to small in type structure.
	* dwarf2read.c (read_array_order): New function.
	(read_array_type): Use read_array_order to check row/column
	major ordering.
@
text
@d586 1
a586 14
/* Returns the appropriate printf format for hexadecimal
   numbers. */
char *
local_hex_format_custom (char *pre)
{
  static char form[50];

  strcpy (form, local_hex_format_prefix ());
  strcat (form, "%");
  strcat (form, pre);
  strcat (form, local_hex_format_specifier ());
  strcat (form, local_hex_format_suffix ());
  return form;
}
d588 2
a589 2
/* Converts a LONGEST to custom hexadecimal and stores it in a static
   string.  Returns a pointer to this string. */
d591 1
a591 1
local_hex_string (LONGEST num)
d593 3
a595 1
  return local_hex_string_custom (num, "l");
d598 4
a601 3
/* Converts a LONGEST number to custom hexadecimal and stores it in a static
   string.  Returns a pointer to this string. Note that the width parameter
   should end with "l", e.g. "08l" as with calls to local_hex_string_custom */
d604 1
a604 1
local_hex_string_custom (LONGEST num, char *width)
d606 8
a613 36
#define RESULT_BUF_LEN 50
  static char res2[RESULT_BUF_LEN];
  char format[RESULT_BUF_LEN];
  int field_width;
  int num_len;
  int num_pad_chars;
  char *pad_char;		/* string with one character */
  int pad_on_left;
  char *parse_ptr;
  char temp_nbr_buf[RESULT_BUF_LEN];

  /* Use phex_nz to print the number into a string, then
     build the result string from local_hex_format_prefix, padding and 
     the hex representation as indicated by "width".  */
  strcpy (temp_nbr_buf, phex_nz (num, sizeof (num)));
  /* parse width */
  parse_ptr = width;
  pad_on_left = 1;
  pad_char = " ";
  if (*parse_ptr == '-')
    {
      parse_ptr++;
      pad_on_left = 0;
    }
  if (*parse_ptr == '0')
    {
      parse_ptr++;
      if (pad_on_left)
	pad_char = "0";		/* If padding is on the right, it is blank */
    }
  field_width = atoi (parse_ptr);
  num_len = strlen (temp_nbr_buf);
  num_pad_chars = field_width - strlen (temp_nbr_buf);	/* possibly negative */

  if (strlen (local_hex_format_prefix ()) + num_len + num_pad_chars
      >= RESULT_BUF_LEN)		/* paranoia */
d615 1
a615 44
		    "local_hex_string_custom: insufficient space to store result");

  strcpy (res2, local_hex_format_prefix ());
  if (pad_on_left)
    {
      while (num_pad_chars > 0)
	{
	  strcat (res2, pad_char);
	  num_pad_chars--;
	}
    }
  strcat (res2, temp_nbr_buf);
  if (!pad_on_left)
    {
      while (num_pad_chars > 0)
	{
	  strcat (res2, pad_char);
	  num_pad_chars--;
	}
    }
  return res2;

}				/* local_hex_string_custom */

/* Returns the appropriate printf format for octal
   numbers. */
char *
local_octal_format_custom (char *pre)
{
  static char form[50];

  strcpy (form, local_octal_format_prefix ());
  strcat (form, "%");
  strcat (form, pre);
  strcat (form, local_octal_format_specifier ());
  strcat (form, local_octal_format_suffix ());
  return form;
}

/* Returns the appropriate printf format for decimal numbers. */
char *
local_decimal_format_custom (char *pre)
{
  static char form[50];
d617 4
a620 6
  strcpy (form, local_decimal_format_prefix ());
  strcat (form, "%");
  strcat (form, pre);
  strcat (form, local_decimal_format_specifier ());
  strcat (form, local_decimal_format_suffix ());
  return form;
a1232 4
  {"", "", "", ""},		/* Binary format info */
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
a1268 4
  {"", "", "", ""},		/* Binary format info */
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
a1303 4
  {"", "", "", ""},		/* Binary format info */
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
@


1.48
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* language.h (struct language_arch_info): Fix typo
	s/primative/primitive/.
	* gdbtypes.c (lookup_primitive_typename): Ditto.
	* language.c (language_lookup_primitive_type_by_name)
	(unknown_language_arch_info): Ditto.
@
text
@d1297 1
d1337 1
d1377 1
@


1.47
log
@2004-07-27  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (enum language): Add nr_languages.
	* language.h (struct language_arch_info): Define.
	(struct language_defn): Add la_language_arch_info.
	(language_lookup_primative_type_by_name): Declare.
	(language_string_char_type): Declare.
	* language.c (_initialize_language, language_gdbarch_post_init)
	(struct language_gdbarch, language_gdbarch_data): Implement
	per-architecture language information.
	(unknown_language_arch_info, language_string_char_type)
	(language_lookup_primative_type_by_name): New functions.
	(unknown_language_defn, auto_language_defn)
	(local_language_defn): Set la_language_arch_info to
	unknown_language_arch_info.
	(unknown_builtin_types): Delete.
	* gdbtypes.c (lookup_primitive_typename): Use
	language_lookup_primative_type_by_name.
	(create_string_type): Use language_string_char_type.
	* values.c (value_from_string): Use language_string_char_type.
	* scm-lang.c (scm_language_defn): Add NULL la_language_arch_info.
	* p-lang.c (pascal_language_defn): Ditto.
	* m2-lang.c (m2_language_defn): Ditto.
	* jv-lang.c (java_language_defn): Ditto.
	* objc-lang.c (objc_language_defn): Ditto.
	* f-lang.c (f_language_defn): Ditto.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Ditto.
@
text
@d1286 1
a1286 1
  lai->primative_type_vector = GDBARCH_OBSTACK_CALLOC (gdbarch, 1,
d1446 1
a1446 1
language_lookup_primative_type_by_name (const struct language_defn *la,
d1452 1
a1452 1
  if (ld->arch_info[la->la_language].primative_type_vector != NULL)
d1455 1
a1455 1
      for (p = ld->arch_info[la->la_language].primative_type_vector;
@


1.46
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@a1275 4
static struct type **const (unknown_builtin_types[]) =
{
  0
};
d1281 9
d1294 1
a1294 1
  &unknown_builtin_types[0],
d1322 1
a1322 1
  &builtin_type_char,		/* Type of string elements */
d1324 1
d1333 1
a1333 1
  &unknown_builtin_types[0],
d1361 1
a1361 1
  &builtin_type_char,		/* Type of string elements */
d1363 1
d1371 1
a1371 1
  &unknown_builtin_types[0],
d1399 1
a1399 1
  &builtin_type_char,		/* Type of string elements */
d1401 1
d1405 70
d1482 3
@


1.45
log
@
2004-07-06  Jeff Johnston <jjohnstn@@redhat.com>

        * language.h (struct_language_defn): Add new function pointer:
        la_class_name_from_physname.  Also add new prototype for
        language_class_name_from_physname.
        * language.c (language_class_name_from_physname): New function.
        (unk_lang_class_name): Ditto.
        (unknown_language_defn, auto_language_defn): Change
        to add unk_lang_class_name function pointer for
        la_class_name_from_physname.
        (local_language_defn): Ditto.
        * dwarf2read.c (guess_structure_name): Change to call
        language_class_name_from_physname.
        (determine_class_name): Ditto.
        * cp-support.c (class_name_from_physname): Renamed.
        (cp_class_name_from_physname): New name of function.
        * cp-support.h: Ditto.
        * c-lang.c (c_language_defn): Change to add NULL
        for class_name_from_physname function pointer.
        (cplus_language_defn): Change to add cp_class_name_from_physname.
        * jv-lang.c (java_class_name_physname): New function.
        (java_find_last_component): New static routine.
        (java_language_defn): Add java_class_name_from_physname pointer.
        * ada-lang.c (ada_language_defn): Change to add NULL
        for class_name_from_physname function pointer.
        * f-lang.c (f_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * scm-lang.c (scm_language_defn): Ditto.
@
text
@d1410 1
a1410 1
  show = add_show_from_set (set, &showlist);
d1430 1
a1430 1
  show = add_show_from_set (set, &showchecklist);
d1438 1
a1438 1
  show = add_show_from_set (set, &showchecklist);
d1447 1
a1447 1
  show = add_show_from_set (set, &showlist);
@


1.44
log
@* language.h (language_defn): Add new la_post_parser field.
* parser-defs.h (null_post_parser): New declaration (default for
la_post_parser).

* parse.c (parse_exp_1): Move code to parse_exp_in_context and
insert call to that function.
(parse_exp_in_context): New function, including code formerly in
parse_exp_1.  Calls language-dependent post-parser after
prefixification.
(parse_expression_in_context): New exported function.
(null_post_parser): New definition.
* expression.h (parse_expression_in_context): Add declaration.

* p-lang.c (pascal_language_defn): Add trivial post-parser.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* language.c (unknown_language_defn): Ditto.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* obj-lang.c (objc_language_defn): Ditto.
@
text
@d1179 10
d1271 4
d1309 1
d1347 1
d1384 1
@


1.43
log
@2004-01-23  David Carlton  <carlton@@kealia.com>

	Partial workaround for PR c++/1511:
	* cp-namespace.c: Include frame.h.
	(cp_lookup_transparent_type): New
	(cp_lookup_transparent_type_loop): New.
	* cp-support.h: Declare cp_lookup_transparent_type.
	* symtab.c (basic_lookup_transparent_type): Renamed from
	lookup_transparent_type.
	(lookup_transparent_type): Replace old body by a call to
	current_language->la_lookup_transparent_type.
	* symtab.h: Update copyright.  Declare
	basic_lookup_transparent_type.
	* language.h: Update copyright.
	(struct language_defn): Add la_lookup_transparent_type.
	* language.c: Update copyright.
	(unknown_language_defn): Add basic_lookup_transparent_type.
	(auto_language_defn): Add basic_lookup_transparent_type.
	(local_language_defn): Add basic_lookup_transparent_type.
	* ada-lang.c: Update copyright.
	(ada_language_defn): Add basic_lookup_transparent_type.
	* c-lang.c: Update copyright.
	(c_language_defn): Add basic_lookup_transparent_type.
	(cplus_language_defn): Add basic_lookup_transparent_type.
	(asm_language_defn): Add basic_lookup_transparent_type.
	(minimal_language_defn): Add basic_lookup_transparent_type.
	* f-lang.c: Update copyright.
	(f_language_defn): Add basic_lookup_transparent_type.
	* jv-lang.c: Update copyright.
	(java_language_defn): Add basic_lookup_transparent_type.
	* m2-lang.c: Update copyright.
	(m2_language_defn): Add basic_lookup_transparent_type.
	* objc-lang.c: Update copyright.
	(objc_language_defn): Add basic_lookup_transparent_type.
	* p-lang.c: Update copyright.
	(p_language_defn): Add basic_lookup_transparent_type.
	* scm-lang.c: Update copyright.
	(scm_language_defn): Add basic_lookup_transparent_type.
	* Makefile.in (cp-namespace.o): Depend on frame.h.

2004-01-23  David Carlton  <carlton@@kealia.com>

	* gdb.cp/rtti.exp: Don't include full path in ${srcfile}.  Add
	test for cp_lookup_transparent_type.
	* gdb.cp/rtti1.cc: Update copyright.  Add n2::func and refer_to;
	call them.
@
text
@d1282 1
d1319 1
d1355 1
@


1.43.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d581 125
a1178 10
/* Return class name from physname or NULL.  */
char *
language_class_name_from_physname (const struct language_defn *current_language,
				   const char *physname)
{
  if (current_language != NULL && current_language->la_class_name_from_physname)
    return current_language->la_class_name_from_physname (physname);
  return NULL;
}

d1261 2
a1262 1
static char *unk_lang_class_name (const char *mangled)
d1264 2
a1265 3
  return NULL;
}

a1270 9
static void
unknown_language_arch_info (struct gdbarch *gdbarch,
			    struct language_arch_info *lai)
{
  lai->string_char_type = builtin_type (gdbarch)->builtin_char;
  lai->primitive_type_vector = GDBARCH_OBSTACK_CALLOC (gdbarch, 1,
						       struct type *);
}

d1275 1
a1275 1
  NULL,
a1277 1
  array_row_major,
a1281 1
  null_post_parser,
d1294 4
a1297 1
  unk_lang_class_name,		/* Language specific class_name_from_physname */
d1301 1
a1301 1
  NULL,
a1302 1
  unknown_language_arch_info,	/* la_language_arch_info.  */
d1311 1
a1311 1
  NULL,
a1313 1
  array_row_major,
a1317 1
  null_post_parser,
d1330 4
a1333 1
  unk_lang_class_name,		/* Language specific class_name_from_physname */
d1337 1
a1337 1
  NULL,
a1338 1
  unknown_language_arch_info,	/* la_language_arch_info.  */
d1346 1
a1346 1
  NULL,
a1349 1
  array_row_major,
a1352 1
  null_post_parser,
d1365 4
a1368 1
  unk_lang_class_name,		/* Language specific class_name_from_physname */
d1372 1
a1372 1
  NULL,
a1373 1
  unknown_language_arch_info,	/* la_language_arch_info.  */
a1376 70
/* Per-architecture language information.  */

static struct gdbarch_data *language_gdbarch_data;

struct language_gdbarch
{
  /* A vector of per-language per-architecture info.  Indexed by "enum
     language".  */
  struct language_arch_info arch_info[nr_languages];
};

static void *
language_gdbarch_post_init (struct gdbarch *gdbarch)
{
  struct language_gdbarch *l;
  int i;

  l = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct language_gdbarch);
  for (i = 0; i <= languages_size; i++)
    {
      if (languages[i] != NULL
	  && languages[i]->la_language_arch_info != NULL)
	languages[i]->la_language_arch_info
	  (gdbarch, l->arch_info + languages[i]->la_language);
    }
  return l;
}

struct type *
language_string_char_type (const struct language_defn *la,
			   struct gdbarch *gdbarch)
{
  struct language_gdbarch *ld = gdbarch_data (gdbarch,
					      language_gdbarch_data);
  if (ld->arch_info[la->la_language].string_char_type != NULL)
    return ld->arch_info[la->la_language].string_char_type;
  else
    return (*la->string_char_type);
}

struct type *
language_lookup_primitive_type_by_name (const struct language_defn *la,
					struct gdbarch *gdbarch,
					const char *name)
{
  struct language_gdbarch *ld = gdbarch_data (gdbarch,
					      language_gdbarch_data);
  if (ld->arch_info[la->la_language].primitive_type_vector != NULL)
    {
      struct type *const *p;
      for (p = ld->arch_info[la->la_language].primitive_type_vector;
	   (*p) != NULL;
	   p++)
	{
	  if (strcmp (TYPE_NAME (*p), name) == 0)
	    return (*p);
	}
    }
  else
    {
      struct type **const *p;
      for (p = current_language->la_builtin_type_vector; *p != NULL; p++)
	{
	  if (strcmp (TYPE_NAME (**p), name) == 0)
	    return (**p);
	}
    }
  return (NULL);
}

a1383 3
  language_gdbarch_data
    = gdbarch_data_register_post_init (language_gdbarch_post_init);

d1390 1
a1390 1
  show = deprecated_add_show_from_set (set, &showlist);
d1410 1
a1410 1
  show = deprecated_add_show_from_set (set, &showchecklist);
d1418 1
a1418 1
  show = deprecated_add_show_from_set (set, &showchecklist);
d1427 1
a1427 1
  show = deprecated_add_show_from_set (set, &showlist);
@


1.42
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@d4 1
a4 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d1292 1
d1328 1
d1363 1
@


1.41
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@d347 1
a347 1
   if (STREQ (case_sensitive, "on"))
d352 1
a352 1
   else if (STREQ (case_sensitive, "off"))
d357 1
a357 1
   else if (STREQ (case_sensitive, "auto"))
d1062 1
a1062 1
    if (STREQ (languages[i]->la_name, str))
@


1.40
log
@        * language.h (language_defn): new field, la_word_break_characters.
        * language.c (unknown_language_defn): Set new field to
        default_word_break_characters.
        (auto_language_defn): Likewise.
        (local_language_defn): Likewise.
        * ada-lang.c (ada_language_defn): Likewise.
        * c-lang.c (c_language_defn): Likewise.
        (cplus_language_defn): Likewise.
        (asm_language_defn): Likewise.
        (minimal_language_defn): Likewise.
        * f-lang.c (f_language_defn): Likewise.
        * jv-lang.c (java_language_defn): Likewise.
        * m2-lang.c (m2_language_defn): Likewise.
        * objc-lang.c (objc_language_defn): Likewise.
        * p-lang.c (pascal_language_defn): Likewise.
        * scm-lang.c (scm_language_defn): Likewise.
@
text
@d208 1
a208 1
      if (STREQ (languages[i]->la_name, language))
d256 1
a256 1
  if (STREQ (type, "on"))
d261 1
a261 1
  else if (STREQ (type, "warn"))
d266 1
a266 1
  else if (STREQ (type, "off"))
d271 1
a271 1
  else if (STREQ (type, "auto"))
d302 1
a302 1
  if (STREQ (range, "on"))
d307 1
a307 1
  else if (STREQ (range, "warn"))
d312 1
a312 1
  else if (STREQ (range, "off"))
d317 1
a317 1
  else if (STREQ (range, "auto"))
@


1.39
log
@        * language.h (default_word_break_characters): Add prototype.
        * language.c (default_word_break_characters): New function.
@
text
@d1301 1
d1336 1
d1370 1
@


1.38
log
@* parser-defs.h (struct exp_descriptor): New definition, containing
language-specific info for printing, prefixifying, dumping, and
evaluating expressions.
(exp_descriptor_standard): Declare new variable.
(print_subexp): Make global and declare here (from expprint.c).
(dump_subexp): Ditto.
(dump_subexp_body_standard): Declare.
(operator_length_standard): Declare.
(op_name_standard): Declare.
(print_subexp): Declare.
(print_subexp_standard): Declare.

* language.h (struct language_defn): Add la_exp_desc field to hold
pointer to table for language-specific operators.
Remove evaluate_exp field, which is now in struct exp_descriptor.

* parse.c (operator_length): Move most code to new
operator_length_standard function.  Use language-specific information.
(operator_length_standard): New function taking most code from
operator_length.
(exp_descriptor_standard): New constant.

* expression.h (enum exp_opcode): Add definitions of OP_EXTENDED0
and OP_EXTENDED_LAST.

* expprint.c (print_subexp): Use language-specific print_subexp.
Make global; remove static declaration.
Move most code to print_subexp_standard.
(print_subexp_standard): New function, containing code formerly in
print_subexp.
(op_name): Add expression to argument signature.
Use langauge-specific op_name.
Move most code to op_name_standard.
(op_name_standard): New function, containing code formerly in op_name.
(dump_subexp): 	Use new version of op_name function.
Use language-specific dump_subexp_body, and move most existing code to
dump_subexp_body_standard.
(dump_raw_expression): Use new op_name interface.
(dump_subexp_body): Move most code to dump_subexp_body_standard.
(dump_subexp_body_standard): New function, containing code formerly
in dump_subexp_body.

* language.c (unknown_language): Add default la_exp_desc field and
remove evaluate_exp field.
(auto_language): Ditto.
(local_language): Ditto.
* f-lang.c (f_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* p-lang.c (pascal_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.

* jv-lang.c (exp_descriptor_java): New variable, containing
Java-specific expression evaluator.
(java_language_defn): Add la_exp_desc field and remove evaluate_exp
field.
* scm-lang.c (exp_descriptor_scm): New variable, containing
Scheme-specific expression evaluator.
(scm_language_defn): Add la_exp_desc field and remove evaluate_exp
field.
* objc-lang.c (print_object_command): Take evaluate_exp from the
la_exp_desc field.

* Makefile.in (eval.o): Add dependency on parser-defs.h.

* eval.c: Include parser-defs.h for the full declaration of
la_exp_desc's type.
(evaluate_subexp): Get evaluate_exp out of la_exp_desc field.
@
text
@d1179 9
@


1.37
log
@2003-09-09  Paul N. Hilfinger  <hilfingr@@gnat.com>

	* p-lang.c: Eliminate "register".
	* c-lang.c: Ditto.
	* expprint.c: Ditto.
	* f-lang.c: Ditto.
	* jv-lang.c: Ditto.
	* language.c: Ditto.
	* m2-lang.c: Ditto.
	* parse.c: Ditto.
	* scm-lang.c: Ditto.
	* objc-lang.c: Ditto.
@
text
@d1270 1
a1272 1
  evaluate_subexp_standard,
d1304 1
a1306 1
  evaluate_subexp_standard,
d1337 1
a1339 1
  evaluate_subexp_standard,
@


1.36
log
@2003-08-07  Andrew Cagney  <cagney@@redhat.com>

	* language.c (op_error): Delete function.
	(binop_type_check): Delete function.
	* language.h (type_op_error, range_op_error): Delete macros.
	(op_error): Delete declaration.
@
text
@d1195 1
a1195 1
unk_lang_emit_char (register int c, struct ui_file *stream, int quoter)
d1201 1
a1201 1
unk_lang_printchar (register int c, struct ui_file *stream)
@


1.35
log
@2003-05-19  David Carlton  <carlton@@bactrian.org>

	* language.h (struct language_defn): Add 'la_value_of_this'
	and 'la_lookup_symbol_nonlocal' members.
	* symtab.h: Declare basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global,
	lookup_symbol_aux_block.
	* symtab.c (lookup_symbol_aux): Call language hooks to determine
	if we should search fields of this and how to do static/global
	lookup.
	(lookup_symbol_aux_block): Make extern.
	(basic_lookup_symbol_nonlocal): New.
	(lookup_symbol_static, lookup_symbol_global): Ditto.
	* ada-lang.c (ada_language_defn): Set 'la_value_of_this' and
	'la_lookup_symbol_nonlocal' members.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Ditto.
	* jv-lang.c (java_language_defn): Ditto.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Ditto.
	* m2-lang.c (m2_language_defn): Ditto.
	* objc-lang.c (objc_language_defn): Ditto.
	* scm-lang.c (scm_language_defn): Ditto.
	* f-lang.c (f_language_defn): Ditto, and include value.h as well.
	* p-lang.c (pascal_language_defn): Ditto for both.
	* Makefile.in (f-lang.o): Depend on value_h.
	(p-lang.o): Ditto.
@
text
@a153 1

a987 185
/* Returns non-zero if the operator OP is defined on
   the values ARG1 and ARG2. */

#if 0				/* Currently unused */

void
binop_type_check (struct value *arg1, struct value *arg2, int op)
{
  struct type *t1, *t2;

  /* If we're not checking types, always return success. */
  if (!STRICT_TYPE)
    return;

  t1 = VALUE_TYPE (arg1);
  if (arg2 != NULL)
    t2 = VALUE_TYPE (arg2);
  else
    t2 = NULL;

  switch (op)
    {
    case BINOP_ADD:
    case BINOP_SUB:
      if ((numeric_type (t1) && pointer_type (t2)) ||
	  (pointer_type (t1) && numeric_type (t2)))
	{
	  warning ("combining pointer and integer.\n");
	  break;
	}
    case BINOP_MUL:
    case BINOP_LSH:
    case BINOP_RSH:
      if (!numeric_type (t1) || !numeric_type (t2))
	type_op_error ("Arguments to %s must be numbers.", op);
      else if (!same_type (t1, t2))
	type_op_error ("Arguments to %s must be of the same type.", op);
      break;

    case BINOP_LOGICAL_AND:
    case BINOP_LOGICAL_OR:
      if (!boolean_type (t1) || !boolean_type (t2))
	type_op_error ("Arguments to %s must be of boolean type.", op);
      break;

    case BINOP_EQUAL:
      if ((pointer_type (t1) && !(pointer_type (t2) || integral_type (t2))) ||
	  (pointer_type (t2) && !(pointer_type (t1) || integral_type (t1))))
	type_op_error ("A pointer can only be compared to an integer or pointer.", op);
      else if ((pointer_type (t1) && integral_type (t2)) ||
	       (integral_type (t1) && pointer_type (t2)))
	{
	  warning ("combining integer and pointer.\n");
	  break;
	}
      else if (!simple_type (t1) || !simple_type (t2))
	type_op_error ("Arguments to %s must be of simple type.", op);
      else if (!same_type (t1, t2))
	type_op_error ("Arguments to %s must be of the same type.", op);
      break;

    case BINOP_REM:
    case BINOP_MOD:
      if (!integral_type (t1) || !integral_type (t2))
	type_op_error ("Arguments to %s must be of integral type.", op);
      break;

    case BINOP_LESS:
    case BINOP_GTR:
    case BINOP_LEQ:
    case BINOP_GEQ:
      if (!ordered_type (t1) || !ordered_type (t2))
	type_op_error ("Arguments to %s must be of ordered type.", op);
      else if (!same_type (t1, t2))
	type_op_error ("Arguments to %s must be of the same type.", op);
      break;

    case BINOP_ASSIGN:
      if (pointer_type (t1) && !integral_type (t2))
	type_op_error ("A pointer can only be assigned an integer.", op);
      else if (pointer_type (t1) && integral_type (t2))
	{
	  warning ("combining integer and pointer.");
	  break;
	}
      else if (!simple_type (t1) || !simple_type (t2))
	type_op_error ("Arguments to %s must be of simple type.", op);
      else if (!same_type (t1, t2))
	type_op_error ("Arguments to %s must be of the same type.", op);
      break;

    case BINOP_CONCAT:
      /* FIXME:  Needs to handle bitstrings as well. */
      if (!(string_type (t1) || character_type (t1) || integral_type (t1))
	|| !(string_type (t2) || character_type (t2) || integral_type (t2)))
	type_op_error ("Arguments to %s must be strings or characters.", op);
      break;

      /* Unary checks -- arg2 is null */

    case UNOP_LOGICAL_NOT:
      if (!boolean_type (t1))
	type_op_error ("Argument to %s must be of boolean type.", op);
      break;

    case UNOP_PLUS:
    case UNOP_NEG:
      if (!numeric_type (t1))
	type_op_error ("Argument to %s must be of numeric type.", op);
      break;

    case UNOP_IND:
      if (integral_type (t1))
	{
	  warning ("combining pointer and integer.\n");
	  break;
	}
      else if (!pointer_type (t1))
	type_op_error ("Argument to %s must be a pointer.", op);
      break;

    case UNOP_PREINCREMENT:
    case UNOP_POSTINCREMENT:
    case UNOP_PREDECREMENT:
    case UNOP_POSTDECREMENT:
      if (!ordered_type (t1))
	type_op_error ("Argument to %s must be of an ordered type.", op);
      break;

    default:
      /* Ok.  The following operators have different meanings in
         different languages. */
      switch (current_language->la_language)
	{
#ifdef _LANG_c
	case language_c:
	case language_cplus:
	case language_objc:
	  switch (op)
	    {
	    case BINOP_DIV:
	      if (!numeric_type (t1) || !numeric_type (t2))
		type_op_error ("Arguments to %s must be numbers.", op);
	      break;
	    }
	  break;
#endif

#ifdef _LANG_m2
	case language_m2:
	  switch (op)
	    {
	    case BINOP_DIV:
	      if (!float_type (t1) || !float_type (t2))
		type_op_error ("Arguments to %s must be floating point numbers.", op);
	      break;
	    case BINOP_INTDIV:
	      if (!integral_type (t1) || !integral_type (t2))
		type_op_error ("Arguments to %s must be of integral type.", op);
	      break;
	    }
#endif

#ifdef _LANG_pascal
      case language_pascal:
	 switch(op)
	 {
	 case BINOP_DIV:
	    if (!float_type(t1) && !float_type(t2))
	       type_op_error ("Arguments to %s must be floating point numbers.",op);
	    break;
	 case BINOP_INTDIV:
	    if (!integral_type(t1) || !integral_type(t2))
	       type_op_error ("Arguments to %s must be of integral type.",op);
	    break;
	 }
#endif

	}
    }
}

#endif /* 0 */


a990 15

/* Prints the format string FMT with the operator as a string
   corresponding to the opcode OP.  If FATAL is non-zero, then
   this is an error and error () is called.  Otherwise, it is
   a warning and printf() is called. */
void
op_error (char *fmt, enum exp_opcode op, int fatal)
{
  if (fatal)
    error (fmt, op_string (op));
  else
    {
      warning (fmt, op_string (op));
    }
}
@


1.34
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d1482 2
d1516 2
d1549 2
@


1.33
log
@* Makefile.in (c_lang.o, jv_lang.o, language.o): Add $(demangle_h).
* language.h (struct language_defn): Add la_demangle.
(language_demangle): Declare.
* language.c (language_demangle): New function.
(unk_lang_demangle): Likewise.
(unknown_language_defn, auto_language_defn, local_language_defn):
Add ukn_lang_demangle.
* ada-lang.c (ada_language_defn): Add NULL for la_demangle element.
* f-lang.c, m2-lang.c, p-lang.c, scm-lang.c: Likewise.
* c-lang.c (c_language_defn, asm_language_defn): Likewise.
(cplus_language_defn): Add cplus_demangle for la_demangle element.
* jv-lang.c (java_demangle): New function
(java_language_defn): Use it for la_demangle element.
* objc-lang.c (objc_demangle): Add options argument
(objc_language_defn): Use objc_demangle for la_demangle element.
* maint.c (maintenance_demangle): Replace switch with
call to language_demangle.
* utils.c (fprintf_symbol_filtered): Likewise.
@
text
@d938 1
a938 1
      sym = lookup_symbol ("logical", NULL, VAR_NAMESPACE, NULL, NULL);
d949 1
a949 1
        {sym = lookup_symbol ("bool", NULL, VAR_NAMESPACE, NULL, NULL);}
d951 1
a951 1
        {sym = lookup_symbol ("boolean", NULL, VAR_NAMESPACE, NULL, NULL);}
d960 1
a960 1
      sym = lookup_symbol ("boolean", NULL, VAR_NAMESPACE, NULL, NULL);
@


1.33.10.1
log
@Snap const char * mess.
@
text
@d51 1
a51 1
static void show_language_command (const char *, int);
d53 1
a53 1
static void set_language_command (const char *, int);
d55 1
a55 1
static void show_type_command (const char *, int);
d57 1
a57 1
static void set_type_command (const char *, int);
d59 1
a59 1
static void show_range_command (const char *, int);
d61 1
a61 1
static void set_range_command (const char *, int);
d63 1
a63 1
static void show_case_command (const char *, int);
d65 1
a65 1
static void set_case_command (const char *, int);
d79 1
a79 1
static void show_check (const char *, int);
d81 1
a81 1
static void set_check (const char *, int);
d161 1
a161 1
show_language_command (const char *ignore, int from_tty)
d174 1
a174 1
set_language_command (const char *ignore, int from_tty)
d246 1
a246 1
show_type_command (const char *ignore, int from_tty)
d255 1
a255 1
set_type_command (const char *ignore, int from_tty)
d291 1
a291 1
show_range_command (const char *ignore, int from_tty)
d301 1
a301 1
set_range_command (const char *ignore, int from_tty)
d337 1
a337 1
show_case_command (const char *ignore, int from_tty)
d346 1
a346 1
set_case_command (const char *ignore, int from_tty)
d1303 1
a1303 1
set_check (const char *ignore, int from_tty)
d1311 1
a1311 1
show_check (const char *ignore, int from_tty)
@


1.33.6.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d938 1
a938 1
      sym = lookup_symbol ("logical", NULL, VAR_DOMAIN, NULL, NULL);
d949 1
a949 1
        {sym = lookup_symbol ("bool", NULL, VAR_DOMAIN, NULL, NULL);}
d951 1
a951 1
        {sym = lookup_symbol ("boolean", NULL, VAR_DOMAIN, NULL, NULL);}
d960 1
a960 1
      sym = lookup_symbol ("boolean", NULL, VAR_DOMAIN, NULL, NULL);
@


1.32
log
@* Makefile.in (infrun.o): Add $(language_h)
* infrun.c (handle_inferior_event): Use skip_language_trampoline
for language specific trampolines.
* language.h (struct language_defn): Add skip_trampoline.
(skip_language_trampoline): Declare.
* language.c (unk_lang_trampoline, skip_language_trampoline):
New functions.
(unknown_language_defn, auto_language_defn, local_language_defn):
Add ukn_lang_trampoline.
* ada-lang.c (ada_language_defn): Add NULL for language
specific skip_trampoline.
* c-lang.c, f-lang.c, jv-lang.c, m2-lang.c, p-lang.c,
scm-lang.c: Likewise.
* objc-lang.c (objc_skip_trampoline): New function.
(objc_language_defn): Add objc_skip_trampoline.
@
text
@d47 1
d1365 15
d1447 7
d1482 1
d1514 1
d1545 1
@


1.31
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d103 2
d1342 23
d1426 5
d1458 1
d1489 1
d1519 1
@


1.30
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* valarith.c (value_binop): Delete obsolete code and comments.
	* configure.host: Ditto.
	* buildsym.h (make_blockvector): Ditto.
	* buildsym.c (make_blockvector): Ditto.
	* defs.h (enum language): Ditto.
	(chill_demangle): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* dwarfread.c (CHILL_PRODUCER): Ditto.
	(set_cu_language): Ditto.
	(handle_producer): Ditto.
	* expprint.c (print_subexp): Ditto.
	* gdbtypes.c (chill_varying_type): Ditto.
	* gdbtypes.h (builtin_type_chill_bool): Ditto.
	(builtin_type_chill_char, builtin_type_chill_long): Ditto.
	(builtin_type_chill_ulong, builtin_type_chill_real): Ditto.
	(chill_varying_type): Ditto.
	* language.h (_LANG_chill): Ditto.
	* language.c (binop_result_type, integral_type): Ditto.
	(character_type, string_type, structured_type): Ditto.
	(lang_bool_type, binop_type_check): Ditto.
	* stabsread.h (os9k_stabs): Ditto.
	* stabsread.c (os9k_type_vector, dbx_lookup_type): Ditto.
	(define_symbol, read_type, read_struct_fields): Ditto.
	(read_array_type, read_enum_type, read_huge_number): Ditto.
	(read_range_type, start_stabs): Ditto.
	* symfile.c (init_filename_language_table): Ditto.
	(add_psymbol_with_dem_name_to_list): Ditto.
	* symtab.c (symbol_init_language_specific): Ditto.
	(symbol_init_demangled_name, symbol_demangled_name): Ditto.
	* symtab.h (struct general_symbol_info): Ditto.
	(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* valops.c (value_cast, search_struct_field, value_slice): Delete
	obsolete code.
	(varying_to_slice): Delete function.
	* value.h (COERCE_VARYING_ARRAY): Delete obsolete macro contents.
	(varying_to_slice): Delete declaration.
	* MAINTAINERS: Update.
@
text
@d2 4
a5 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
@


1.29
log
@language.c (binop_result_type): Add language_objc to case.
(integral_type): Likewise.
(character_type): Likewise.
(string_type): Likewise.
(boolean_type): Likewise.
(structured_type): Likewise.
(binop_type_check): Likewise.
@
text
@a570 2
      /* OBSOLETE case language_chill: */
      /* OBSOLETE    error ("Missing Chill support in function binop_result_check.");  */	/*FIXME */
a793 2
      /* OBSOLETE case language_chill: */
      /* OBSOLETE   error ("Missing Chill support in function integral_type.");	*//*FIXME */
a821 1
      /* OBSOLETE case language_chill: */
a843 1
      /* OBSOLETE case language_chill: */
d871 1
a871 1
         TYPE_CODE_INT_NOT_BOOL for (OBSOLETE) CHILL and such
a918 2
      /* OBSOLETE case language_chill: */
      /* OBSOLETE     error ("Missing Chill support in function structured_type.");	*//*FIXME */
a931 4
#if 0
      /* OBSOLETE case language_chill: */
      /* OBSOLETE    return builtin_type_chill_bool; */
#endif
a1159 5
#endif

#ifdef _LANG_chill /* OBSOLETE */
	 /* OBSOLETE case language_chill: */
	 /* OBSOLETE   error ("Missing Chill support in function binop_type_check.");	*//*FIXME */
@


1.28
log
@Revert previous change.  Not obvious.
@
text
@d552 1
d790 1
d833 1
d856 1
d875 1
d912 1
d1133 1
@


1.28.4.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a551 1
    case language_objc:
a788 1
    case language_objc:
a830 1
    case language_objc:
a852 1
    case language_objc:
a870 1
    case language_objc:
a906 1
    case language_objc:
a1126 1
	case language_objc:
@


1.28.4.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 2
a3 4

   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2001, 2002, 2003 Free Software Foundation, Inc.

a44 1
#include "demangle.h"
a100 2
static CORE_ADDR unk_lang_trampoline (CORE_ADDR pc);

d149 1
d204 1
a204 1
      if (strcmp (languages[i]->la_name, language) == 0)
d252 1
a252 1
  if (strcmp (type, "on") == 0)
d257 1
a257 1
  else if (strcmp (type, "warn") == 0)
d262 1
a262 1
  else if (strcmp (type, "off") == 0)
d267 1
a267 1
  else if (strcmp (type, "auto") == 0)
d298 1
a298 1
  if (strcmp (range, "on") == 0)
d303 1
a303 1
  else if (strcmp (range, "warn") == 0)
d308 1
a308 1
  else if (strcmp (range, "off") == 0)
d313 1
a313 1
  else if (strcmp (range, "auto") == 0)
d343 1
a343 1
   if (DEPRECATED_STREQ (case_sensitive, "on"))
d348 1
a348 1
   else if (DEPRECATED_STREQ (case_sensitive, "off"))
d353 1
a353 1
   else if (DEPRECATED_STREQ (case_sensitive, "auto"))
d571 2
d796 2
d826 1
d849 1
d877 1
a877 1
         TYPE_CODE_INT_NOT_BOOL for (the deleted) CHILL and such
d925 2
d940 4
d945 1
a945 1
      sym = lookup_symbol ("logical", NULL, VAR_DOMAIN, NULL, NULL);
d956 1
a956 1
        {sym = lookup_symbol ("bool", NULL, VAR_DOMAIN, NULL, NULL);}
d958 1
a958 1
        {sym = lookup_symbol ("boolean", NULL, VAR_DOMAIN, NULL, NULL);}
d967 1
a967 1
      sym = lookup_symbol ("boolean", NULL, VAR_DOMAIN, NULL, NULL);
d996 190
d1190 15
d1275 1
a1275 1
    if (DEPRECATED_STREQ (languages[i]->la_name, str))
a1354 47
/* Iterate through all registered languages looking for and calling
   any non-NULL struct language_defn.skip_trampoline() functions.
   Return the result from the first that returns non-zero, or 0 if all
   `fail'.  */
CORE_ADDR 
skip_language_trampoline (CORE_ADDR pc)
{
  int i;

  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->skip_trampoline)
	{
	  CORE_ADDR real_pc = (languages[i]->skip_trampoline) (pc);
	  if (real_pc)
	    return real_pc;
	}
    }

  return 0;
}

/* Return demangled language symbol, or NULL.  
   FIXME: Options are only useful for certain languages and ignored
   by others, so it would be better to remove them here and have a
   more flexible demangler for the languages that need it.  
   FIXME: Sometimes the demangler is invoked when we don't know the
   language, so we can't use this everywhere.  */
char *
language_demangle (const struct language_defn *current_language, 
				const char *mangled, int options)
{
  if (current_language != NULL && current_language->la_demangle)
    return current_language->la_demangle (mangled, options);
  return NULL;
}

/* Return the default string containing the list of characters
   delimiting words.  This is a reasonable default value that
   most languages should be able to use.  */

char *
default_word_break_characters (void)
{
  return " \t\n!@@#$%^&*()+=|~`}{[]\"';:?/>.<,-";
}

d1370 1
a1370 1
unk_lang_emit_char (int c, struct ui_file *stream, int quoter)
d1376 1
a1376 1
unk_lang_printchar (int c, struct ui_file *stream)
a1415 12
static CORE_ADDR unk_lang_trampoline (CORE_ADDR pc)
{
  return 0;
}

/* Unknown languages just use the cplus demangler.  */
static char *unk_lang_demangle (const char *mangled, int options)
{
  return cplus_demangle (mangled, options);
}


a1432 1
  &exp_descriptor_standard,
d1435 1
a1442 4
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal, /* lookup_symbol_nonlocal */
  unk_lang_demangle,		/* Language specific symbol demangler */
a1450 1
  default_word_break_characters,
a1462 1
  &exp_descriptor_standard,
d1465 1
a1472 4
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal */
  unk_lang_demangle,		/* Language specific symbol demangler */
a1480 1
  default_word_break_characters,
a1491 1
  &exp_descriptor_standard,
d1494 1
a1501 4
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal */
  unk_lang_demangle,		/* Language specific symbol demangler */
a1509 1
  default_word_break_characters,
@


1.28.4.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d4 1
a4 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a1291 1
  basic_lookup_transparent_type,/* lookup_transparent_type */
a1326 1
  basic_lookup_transparent_type,/* lookup_transparent_type */
a1360 1
  basic_lookup_transparent_type,/* lookup_transparent_type */
@


1.28.2.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@a551 1
    case language_objc:
a788 1
    case language_objc:
a830 1
    case language_objc:
a852 1
    case language_objc:
a870 1
    case language_objc:
a906 1
    case language_objc:
a1126 1
	case language_objc:
@


1.28.2.2
log
@2002-11-24  David Carlton  <carlton@@bactrian.org>

	* Makefile.in (c-typeprint.o): Depend on gdb_assert_h.
	* c-typeprint.c: #include "gdb_assert.h"
	* gdbtypes.c (recursive_dump_type): Handle TYPE_CODE_NAMESPACE.
	* c-typeprint.c (c_type_print_varspec_prefix): Ditto.
	(c_type_print_varspec_suffix): Ditto.
	(c_type_print_base): Ditto.
	* typeprint.c (print_type_scalar): Ditto.
	* printcmd.c (print_formatted): Ditto.
	* language.c (structured_type): Ditto.
	* cp-support.c (cp_check_namespace_symbol): Allocate type via
	init_type.
	* gdbtypes.c (init_type): Handle TYPE_CODE_NAMESPACE.
	* valops.c (value_namespace_elt): Handle sym == NULL.

2002-11-24  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/namespace.exp: Eliminate some of the single quotes, and
	duplicate some of the single quote tests without the quotes.
	Change "print E::ce" test.
	Add some ptype <namespace> tests.
	* carlton_runnamespace: Use different files for compiler with and
	without debug info.
@
text
@d913 3
a915 4
      return (TYPE_CODE (type) == TYPE_CODE_STRUCT)
	|| (TYPE_CODE (type) == TYPE_CODE_UNION)
	|| (TYPE_CODE (type) == TYPE_CODE_ARRAY)
	|| (TYPE_CODE (type) == TYPE_CODE_NAMESPACE);
@


1.28.2.3
log
@2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (add_partial_enumeration): New function.
	(scan_partial_symbols): Call add_partial_enumeration.
	(locate_pdi_sibling): New function.
	(scan_partial_symbols): Call locate_pdi_sibling.  Get rid of
	nesting_level.
	(pdi_needs_namespace): New function.
	(add_partial_symbol): Add 'namespace' arg; calculate full name
	when appropriate.
	(scan_partial_symbols): Update calls to add_partial_symbol.
	(add_partial_enumeration): Ditto.
	(read_enumeration): Add processing_current_prefix to name when
	appropriate.
	(new_symbol): Set names of enumerators and typedefs appropriately
	if processing_has_namespace_info.
	* symtab.c (lookup_symbol_namespace): Rename 'namespace' argument
	to 'namespace_name'.
	* symtab.h: Ditto.
	* symtab.c (lookup_symbol_namespace): Delete FIXME comments; add a
	new one.
	(lookup_symbol_aux_file): New function.
	(lookup_symbol_aux): Delete FIXME comment.
	(lookup_symbol_aux): Don't search static block explicitly; delete
	FIXME comments.
	* valops.c (value_namespace_elt): Update call to
	lookup_symbol_namespace.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* symtab.c (lookup_symbol_namespace): Delete 'using' argument and
	add 'block' argument; get using directives via iterators.
	(lookup_symbol_aux_using_loop): Delete 'using' argument and add
	'block' argument.
	(lookup_symbol_aux_using): Don't calculate using directives.
	* block.c (block_using_iterator_first): New function.
	(block_using_iterator_next): Ditto.
	* block.h: Add comment.
	(struct block_using_iterator): New struct.
	Declare block_using_iterator_first, block_using_iterator_next.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Set type name and
	processing_current_prefix appropriately.
	(new_symbol): Make sure that, in symbols associated to class
	types, the name includes appropriate namespaces.
	* buildsym.h: Rename processing_current_namespace to
	processing_current_prefix.
	* buildsym.c (finish_block): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	(read_namespace): Ditto.  Also rename previous_namespace to
	previous_prefix.

	Now come a thousand and one const correctness fixes:
	* p-typeprint.c (pascal_print_type): Const.
	(pascal_type_print_method_args): Const.
	* p-lang.h: Const.
	* m2-typeprint.c (m2_print_type): Const.
	* valops.c (hand_function_call): Const.
	* jv-lang.c (java_primitive_type_from_name): Const.
	* jv-lang.h: Const.
	* jv-typeprint.c (java_print_type): Const.
	* language.c: (unk_lang_print_type): Const.
	* stack.c (frame_info): Const.
	* linespec.c (find_methods): Const.
	(find_method_name): Const
	* f-lang.h: Const.
	* f-typeprint.c (f_print_type): Const.
	* c-typeprint.c (c_print_type): Const.
	* c-lang.h: Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (lookup_primitive_typename): Const.
	* stack.c (print_frame): Const.
	(func_command): Delete pointless cast.
	* linespec.c (find_method_name): Const.
	* language.h: Const.
	* symfile.c (compare_psymbols): Const.
	* symtab.c (completion_list_add_name): Const.
	* breakpoint.c (break_at_finish_at_depth_command_1): Remove
	useless cast.
	(break_at_finish_command_1): Ditto.
	* typeprint.c (type_print): Const.
	* symtab.h: Const.
	* symtab.c (gdb_mangle_name): Const.
	(symbol_init_demangled_name): Const.
	(symbol_demangled_name): Const.
	* defs.h: Const.
	* printcmd.c (build_address_symbolic): Const.
	* valops.c (search_struct_method): Const.
	* cp-valprint.c (cp_is_vtbl_ptr_type): Const.
	(cp_print_value): Const.
	(cp_print_class_member): Const.
	* c-typeprint.c (cp_type_print_derivation_info): Const.
	(c_type_print_varspec_prefix): Const.
	(c_type_print_base): Const.
	* p-valprint.c (pascal_object_is_vtbl_ptr_type): Const.
	(pascal_object_print_value): Const.
	(pascal_object_print_class_member): Const.
	* p-typeprint.c (pascal_type_print_derivation_info): Const.
	(pascal_type_print_varspec_prefix): Const.
	(pascal_type_print_base): Const.
	* jv-typeprint.c (java_type_print_base): Const.
	* jv-lang.h (java_demangle_type_signature): Const.
	* jv-lang.c (java_demangle_type_signature): Const.
	(java_demangled_signature_length): Const.
	(java_demangled_signature_copy): Const.
	* jv-typeprint.c (java_type_print_derivation_info): Const.
	* jv-valprint.c (java_value_print): Const.
	(java_print_value_fields): Const.
	* jv-lang.c (is_object_type): Const.
	(evaluate_subexp_java): Const.
	* stabsread.c (read_cpp_abbrev): Const.
	(complain_about_struct_wipeout): Const.
	(cleanup_undefined_types): Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (add_name): Second arg const.
	(lookup_typename): Const.
	(lookup_unsigned_typename): Const.
	(lookup_signed_typename): Const.
	* linespec.c (find_methods): const char *class_name.
	* symtab.c (gdb_mangle_name): const char *newname.
	* valops.c (destructor_name_p): const char *dname.
	(search_struct_field): First arg const.
	* gdbtypes.c (check_typedef): const char *name (multiple places).
	(cfront_mangle_name): const char *newname.
	* gdbtypes.c (add_mangled_type): const char *tname.
	* valops.c (find_overload_match): const char *obj_type_name.
	* utils.c (gdb_print_host_address): Make first arg const.
	* defs.h: Declare first arg of gdb_print_host_address to be
	const.
	* valarith.c (find_size_for_pointer_math): const char *name.

2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/m-data.cc (main): Add marker comment.
	* gdb.c++/m-data.exp: Use marker comment instead of line numbers.
	* gdb.c++/m-data.cc: Delete superfluous namespace.
	* gdb.c++/m-static.cc: Ditto.
	* gdb.c++/m-static1.cc: Ditto.
	* carlton_runtest: Compare based on gdb.sum, not based on output.
	* carlton_runnamespace: Ditto.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Put tests for CClass.
	* gdb.c++/namespace.cc (C): Add CClass.
@
text
@d92 1
a92 1
static void unk_lang_print_type (struct type *, const char *, struct ui_file *,
d1396 1
a1396 1
unk_lang_print_type (struct type *type, const char *varstring, struct ui_file *stream,
@


1.28.2.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 2
a3 4

   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2001, 2002, 2003 Free Software Foundation, Inc.

d571 2
d796 2
d826 1
d849 1
d877 1
a877 1
         TYPE_CODE_INT_NOT_BOOL for (the deleted) CHILL and such
d926 2
d941 4
d1173 5
@


1.28.2.5
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a46 1
#include "demangle.h"
a102 2
static CORE_ADDR unk_lang_trampoline (CORE_ADDR pc);

a1340 38
/* Iterate through all registered languages looking for and calling
   any non-NULL struct language_defn.skip_trampoline() functions.
   Return the result from the first that returns non-zero, or 0 if all
   `fail'.  */
CORE_ADDR 
skip_language_trampoline (CORE_ADDR pc)
{
  int i;

  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->skip_trampoline)
	{
	  CORE_ADDR real_pc = (languages[i]->skip_trampoline) (pc);
	  if (real_pc)
	    return real_pc;
	}
    }

  return 0;
}

/* Return demangled language symbol, or NULL.  
   FIXME: Options are only useful for certain languages and ignored
   by others, so it would be better to remove them here and have a
   more flexible demangler for the languages that need it.  
   FIXME: Sometimes the demangler is invoked when we don't know the
   language, so we can't use this everywhere.  */
char *
language_demangle (const struct language_defn *current_language, 
				const char *mangled, int options)
{
  if (current_language != NULL && current_language->la_demangle)
    return current_language->la_demangle (mangled, options);
  return NULL;
}


a1401 12
static CORE_ADDR unk_lang_trampoline (CORE_ADDR pc)
{
  return 0;
}

/* Unknown languages just use the cplus demangler.  */
static char *unk_lang_demangle (const char *mangled, int options)
{
  return cplus_demangle (mangled, options);
}


a1428 2
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  unk_lang_demangle,		/* Language specific symbol demangler */
a1458 2
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  unk_lang_demangle,		/* Language specific symbol demangler */
a1487 2
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  unk_lang_demangle,		/* Language specific symbol demangler */
@


1.28.2.6
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d939 1
a939 1
      sym = lookup_symbol ("logical", NULL, VAR_DOMAIN, NULL, NULL);
d950 1
a950 1
        {sym = lookup_symbol ("bool", NULL, VAR_DOMAIN, NULL, NULL);}
d952 1
a952 1
        {sym = lookup_symbol ("boolean", NULL, VAR_DOMAIN, NULL, NULL);}
d961 1
a961 1
      sym = lookup_symbol ("boolean", NULL, VAR_DOMAIN, NULL, NULL);
a1482 2
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal, /* lookup_symbol_nonlocal */
a1514 2
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal */
a1545 2
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal */
@


1.28.2.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d154 1
d990 185
d1179 15
d1397 1
a1397 1
unk_lang_emit_char (int c, struct ui_file *stream, int quoter)
d1403 1
a1403 1
unk_lang_printchar (int c, struct ui_file *stream)
@


1.28.2.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d208 1
a208 1
      if (strcmp (languages[i]->la_name, language) == 0)
d256 1
a256 1
  if (strcmp (type, "on") == 0)
d261 1
a261 1
  else if (strcmp (type, "warn") == 0)
d266 1
a266 1
  else if (strcmp (type, "off") == 0)
d271 1
a271 1
  else if (strcmp (type, "auto") == 0)
d302 1
a302 1
  if (strcmp (range, "on") == 0)
d307 1
a307 1
  else if (strcmp (range, "warn") == 0)
d312 1
a312 1
  else if (strcmp (range, "off") == 0)
d317 1
a317 1
  else if (strcmp (range, "auto") == 0)
a1179 9
/* Return the default string containing the list of characters
   delimiting words.  This is a reasonable default value that
   most languages should be able to use.  */

char *
default_word_break_characters (void)
{
  return " \t\n!@@#$%^&*()+=|~`}{[]\"';:?/>.<,-";
}
a1270 1
  &exp_descriptor_standard,
d1273 1
a1292 1
  default_word_break_characters,
a1304 1
  &exp_descriptor_standard,
d1307 1
a1326 1
  default_word_break_characters,
a1337 1
  &exp_descriptor_standard,
d1340 1
a1359 1
  default_word_break_characters,
@


1.28.2.9
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d347 1
a347 1
   if (DEPRECATED_STREQ (case_sensitive, "on"))
d352 1
a352 1
   else if (DEPRECATED_STREQ (case_sensitive, "off"))
d357 1
a357 1
   else if (DEPRECATED_STREQ (case_sensitive, "auto"))
d1063 1
a1063 1
    if (DEPRECATED_STREQ (languages[i]->la_name, str))
@


1.28.2.10
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d4 1
a4 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a1292 1
  basic_lookup_transparent_type,/* lookup_transparent_type */
a1327 1
  basic_lookup_transparent_type,/* lookup_transparent_type */
a1361 1
  basic_lookup_transparent_type,/* lookup_transparent_type */
@


1.27
log
@2002-09-18  Michael Snyder  <msnyder@@redhat.com>

	Preliminary support for Objective-C:
	* defs.h (language_objc): New enum value.
	(puts_filtered_tabular): Declaration only, exported from utils.c.
	(skip_quoted): Delete, declared in completer.h.
	* c-exp.y: Include completer.h.
	* p-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* expression.h (OP_MSGCALL, OP_SELECTOR, OP_SELF, OP_NSSTRING):
	New operator enum values.
	* language.h (CAST_IS_CONVERSION): Test for language_objc.
	* language.c (binop_result_type): Handle language_objc case.
	(integral_type, character_type, string_type, boolean_type,
	structured_type, binop_type_check): Ditto.
	* symtab.h (SYMBOL_OBJC_DEMANGLED_NAME): Define.
	(struct objc_specific): Add to general_symbol_info.
	(SYMBOL_INIT_LANGUAGE_SPECIFIC): Add objc initialization.
	(SYMBOL_DEMANGLED_NAME): Handle objc case.
	* parser-defs.h (struct objc_class_str): New struct type.
	(start_msglist, end_msglist, add_msglist): Declaration only,
	exported from objc-lang.c.
	* value.h (value_of_local, value_nsstring,
	call_function_by_hand_expecting_type): Exported from valops.c.
	* valops.c (find_function_addr): Export.
	(call_function_by_hand_expecting_type): New function.
	(value_of_local): New function.
	* symfile.c (init_filename_language_table): Add ".m" extension
	for Objective-C.
	* utils.c (puts_filtered_tabular): New function.
	(fprintf_symbol_filtered): Add objc demangling support (disabled).
	(set/show demangle): Extend help-string to refer to ObjC.
	* elfread.c (elf_symtab_read): Skip Objective-C special symbols.
	* stabsread.c (symbol_reference_defined): Objective-C symbols
	may contain colons: make allowances when scanning stabs strings
	for colons.
	(objc_find_colon): New function.
	* printcmd.c (address_info): If language == objc then print
	"self" instead of "this".
	* parse.c (length_of_subexp): Handle new operators OP_MSGCALL,
	OP_NSSTRING, and OP_SELF.
	(prefixify_subexp): Ditto.
	* source.c (print_source_lines): Mention objc in comment.
	* breakpoint.c (parse_breakpoint_sals): Recognize Objective-C
	method names.
@
text
@a551 1
    case language_objc:
a788 1
    case language_objc:
a830 1
    case language_objc:
a852 1
    case language_objc:
a870 1
    case language_objc:
a906 1
    case language_objc:
a1126 1
	case language_objc:
@


1.26
log
@2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* NEWS: Menion that CHILL has been made obsolete.

* gdbtypes.c (chill_varying_type): Make chill references obsolete.
* gdbserver/Makefile.in: Ditto.
* stabsread.c (read_range_type): Ditto.
* gdbtypes.h: Ditto.
* language.c (binop_type_check): Ditto.
(binop_result_type): Ditto.
(integral_type): Ditto.
(character_type): Ditto.
(string_type): Ditto.
(boolean_type): Ditto.
(structured_type): Ditto.
(lang_bool_type): Ditto.
(binop_type_check): Ditto.
* language.h (_LANG_chill): Ditto.
* dwarfread.c (set_cu_language): Ditto.
* dwarfread.c (CHILL_PRODUCER): Ditto.
* dwarfread.c (handle_producer): Ditto.
* expression.h (enum exp_opcode): Ditto.
* eval.c: Ditto for comments.
* typeprint.c (typedef_print) [_LANG_chill]: Ditto.
* expprint.c (print_subexp): Ditto.
(print_subexp): Ditto.
* valops.c (value_cast): Ditto.
(search_struct_field): Ditto.
* value.h (COERCE_VARYING_ARRAY): Ditto.
* symfile.c (init_filename_language_table): Ditto.
(add_psymbol_with_dem_name_to_list): Ditto.
* valarith.c (value_binop): Ditto.
(value_neg): Ditto.
* valops.c (value_slice): Ditto.
* symtab.h (union language_specific): Ditto.
(SYMBOL_INIT_LANGUAGE_SPECIFIC): Ditto.
(SYMBOL_DEMANGLED_NAME): Ditto.
(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
* defs.h (enum language): Ditto.
* symtab.c (got_symtab): Ditto.
* utils.c (fprintf_symbol_filtered): Ditto.

* ch-typeprint.c: Make file obsolete.
* ch-valprint.c: Make file obsolete.
* ch-lang.h: Make file obsolete.
* ch-exp.c: Make file obsolete.
* ch-lang.c: Make file obsolete.

* Makefile.in (FLAGS_TO_PASS): Do not pass CHILL or CHILLFLAGS or
CHILL_LIB.
(TARGET_FLAGS_TO_PASS): Ditto.
(CHILLFLAGS): Obsolete.
(CHILL): Obsolete.
(CHILL_FOR_TARGET): Obsolete.
(CHILL_LIB): Obsolete.
(SFILES): Remove ch-exp.c, ch-lang.c, ch-typeprint.c and
ch-valprint.c.
(HFILES_NO_SRCDIR): Remove ch-lang.h.
(COMMON_OBS): Remove ch-valprint.o, ch-typeprint.o, ch-exp.o and
ch-lang.o.
(ch-exp.o, ch-lang.o, ch-typeprint.o, ch-valprint.o): Delete
targets.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* stabs.texinfo, gdb.texinfo, gdbint.texinfo: Obsolete references
to CHILL.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* Makefile.in (TARGET_FLAGS_TO_PASS): Remove CHILLFLAGS, CHILL,
CHILL_FOR_TARGET and CHILL_LIB.
* configure.in (configdirs): Remove gdb.chill.
* configure: Regenerate.
* lib/gdb.exp: Obsolete references to chill.
* gdb.fortran/types.exp: Ditto.
* gdb.fortran/exprs.exp: Ditto.
@
text
@d552 1
d790 1
d833 1
d856 1
d875 1
d912 1
d1133 1
@


1.25
log
@Fix some K&R isms.
@
text
@d570 2
a571 2
    case language_chill:
      error ("Missing Chill support in function binop_result_check.");	/*FIXME */
d794 2
a795 2
    case language_chill:
      error ("Missing Chill support in function integral_type.");	/*FIXME */
d824 1
a824 1
    case language_chill:
d846 1
a846 1
    case language_chill:
d871 3
a873 2
      /* Might be more cleanly handled by having a TYPE_CODE_INT_NOT_BOOL
         for CHILL and such languages, or a TYPE_CODE_INT_OR_BOOL for C.  */
d919 2
a920 2
    case language_chill:
      error ("Missing Chill support in function structured_type.");	/*FIXME */
d934 4
a937 2
    case language_chill:
      return builtin_type_chill_bool;
d1167 3
a1169 3
#ifdef _LANG_chill
	case language_chill:
	  error ("Missing Chill support in function binop_type_check.");	/*FIXME */
@


1.24
log
@* language.c (local_hex_string_custom): Simplify.  Do not depend
on PRINTF_HAS_LONG_LONG or CC_HAS_LONG_LONG.

* memattr.c (mem_info_command): Replace calls to
longest_local_hex_string and longest_local_hex_string_custom.
* buildsym.c (make_blockvector): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* symtab.c (print_msymbol_info): Ditto.

* language.c (local_hex_string): Delete.
(local_hex_string_custom): Delete.
(longest_local_hex_string): Rename to local_hex_string.
(longest_local_hex_string_custom): Rename to
local_hex_string_custom.
* language.h (local_hex_string): Change parameter type to LONGEST.
(local_hex_string_custom): Ditto.
(longest_local_hex_string): Delete declaration.
(longest_local_hex_string_custom): Ditto.

* solib.c: Update copyright.
* memattr.c: Update copyright.
@
text
@d487 1
a487 1
set_case_str()
@


1.24.4.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d487 1
a487 1
set_case_str (void)
@


1.24.4.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d570 2
a571 2
      /* OBSOLETE case language_chill: */
      /* OBSOLETE    error ("Missing Chill support in function binop_result_check.");  */	/*FIXME */
d794 2
a795 2
      /* OBSOLETE case language_chill: */
      /* OBSOLETE   error ("Missing Chill support in function integral_type.");	*//*FIXME */
d824 1
a824 1
      /* OBSOLETE case language_chill: */
d846 1
a846 1
      /* OBSOLETE case language_chill: */
d871 2
a872 3
      /* Might be more cleanly handled by having a
         TYPE_CODE_INT_NOT_BOOL for (OBSOLETE) CHILL and such
         languages, or a TYPE_CODE_INT_OR_BOOL for C.  */
d918 2
a919 2
      /* OBSOLETE case language_chill: */
      /* OBSOLETE     error ("Missing Chill support in function structured_type.");	*//*FIXME */
d933 2
a934 4
#if 0
      /* OBSOLETE case language_chill: */
      /* OBSOLETE    return builtin_type_chill_bool; */
#endif
d1164 3
a1166 3
#ifdef _LANG_chill /* OBSOLETE */
	 /* OBSOLETE case language_chill: */
	 /* OBSOLETE   error ("Missing Chill support in function binop_type_check.");	*//*FIXME */
@


1.24.4.3
log
@merge from mainline
@
text
@a551 1
    case language_objc:
a788 1
    case language_objc:
a830 1
    case language_objc:
a852 1
    case language_objc:
a870 1
    case language_objc:
a906 1
    case language_objc:
a1126 1
	case language_objc:
@


1.23
log
@2002-03-27  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (_initialize_breakpoint): Clean up help string.
	* infcmd.c (_initialize_infcmd): Ditto.
	* language.c (_initialize_language): Ditto.
	* symfile.c (_initialize_symfile): Ditto.
	* top.c (_init_main): Ditto.
	* cli/cli-cmds.c (init_cli_cmds): Ditto.
@
text
@d598 1
a598 1
/* Converts a number to hexadecimal and stores it in a static
d601 1
a601 1
local_hex_string (unsigned long num)
d603 1
a603 23
  static char res[50];

  sprintf (res, local_hex_format (), num);
  return res;
}

/* Converts a LONGEST number to hexadecimal and stores it in a static
   string.  Returns a pointer to this string. */
char *
longest_local_hex_string (LONGEST num)
{
  return longest_local_hex_string_custom (num, "l");
}

/* Converts a number to custom hexadecimal and stores it in a static
   string.  Returns a pointer to this string. */
char *
local_hex_string_custom (unsigned long num, char *pre)
{
  static char res[50];

  sprintf (res, local_hex_format_custom (pre), num);
  return res;
d611 1
a611 1
longest_local_hex_string_custom (LONGEST num, char *width)
a615 1
#if !defined (PRINTF_HAS_LONG_LONG)
a622 1
#endif
a623 16
#ifndef CC_HAS_LONG_LONG
  /* If there is no long long, then LONGEST should be just long and we
     can use local_hex_string_custom 
   */
  return local_hex_string_custom ((unsigned long) num, width);
#elif defined (PRINTF_HAS_LONG_LONG)
  /* Just use printf.  */
  strcpy (format, local_hex_format_prefix ());	/* 0x */
  strcat (format, "%");
  strcat (format, width);	/* e.g. "08l" */
  strcat (format, "l");		/* need "ll" for long long */
  strcat (format, local_hex_format_specifier ());	/* "x" */
  strcat (format, local_hex_format_suffix ());	/* "" */
  sprintf (res2, format, num);
  return res2;
#else /* !defined (PRINTF_HAS_LONG_LONG) */
d650 1
a650 1
		    "longest_local_hex_string_custom: insufficient space to store result");
a670 1
#endif
d672 1
a672 1
}				/* longest_local_hex_string_custom */
@


1.22
log
@2002-02-13  Michael Chastain <mec@@shout.net>

	* defs.h: Kill CONST_PTR.
	* c-lang.h (c_builtin_types): Change CONST_PTR to simple "const".
	* c-lang.c (c_builtin_types): Likewise.
	* ch-lang.c (ch_builtin_types): Likewise.
	* f-lang.c (f_builtin_types): Likewise.
	* language.c (unknown_builtin_types): Likewise.
	* m2-lang.c (m2_builtin_types): Likewise.
	* p-lang.c (pascal_builtin_types): Likewise.
	* scm-lang.c (c_builtin_types): Likewise.
@
text
@d1562 1
a1562 1
		  "Set the status of the type/range checker",
d1568 1
a1568 1
		  "Show the status of the type/range checker",
@


1.21
log
@* cli/cli-decode.c (do_cfunc, set_cmd_cfunc): New functions.
(do_sfunc, set_cmd_sfunc): New functions.

* command.h (struct cmd_list_element): Add field func.
* cli/cli-decode.h (struct cmd_list_element): Ditto.
* command.h (set_cmd_sfunc, set_cmd_cfunc): Declare.
* cli/cli-decode.h: Ditto.

* cli/cli-decode.c (help_cmd): Test for func not cfunc/sfunc.
(help_all, help_cmd_list): Ditto.
(find_cmd, complete_on_cmdlist): Ditto.
* top.c (execute_command): Ditto.

* cli/cli-setshow.c (do_setshow_command): Call func instead of
function.sfunc.

* infcmd.c (notice_args_read): Fix function signature.

* cli/cli-cmds.c (init_cli_cmds): Use set_cmd_sfunc.
* cli/cli-decode.c (add_set_cmd): Ditto.
* utils.c (initialize_utils): Ditto.
* maint.c (_initialize_maint_cmds): Ditto.
* infrun.c (_initialize_infrun): Ditto.
* demangle.c (_initialize_demangler): Ditto.
* remote.c (add_packet_config_cmd): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* cris-tdep.c (_initialize_cris_tdep): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* kod.c (_initialize_kod): Ditto.
* valprint.c (_initialize_valprint): Ditto.
* top.c (init_main): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
* arm-tdep.c (_initialize_arm_tdep): Ditto.
* arch-utils.c (initialize_current_architecture): Ditto.
(_initialize_gdbarch_utils): Ditto.
* alpha-tdep.c (_initialize_alpha_tdep): Ditto.

* cli/cli-decode.c (add_cmd): Use set_cmd_cfunc.
* wince.c (_initialize_inftarg): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* language.c (_initialize_language): Ditto.
* arc-tdep.c (_initialize_arc_tdep): Ditto.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
d1447 1
a1447 1
static struct type **CONST_PTR (unknown_builtin_types[]) =
@


1.20
log
@* language.h (type_error, range_error): Make string parameter
constant.
* language.c (warning_pre_print): Delete extern declaration.
* dwarfread.c (warning_pre_print): Ditto.
* language.c (type_error, range_error): Rewrite to use verror and
vwarning instead of warning_begin.
@
text
@d1558 2
a1559 2
  set->function.cfunc = set_language_command;
  show->function.cfunc = show_language_command;
d1578 2
a1579 2
  set->function.cfunc = set_type_command;
  show->function.cfunc = show_type_command;
d1586 2
a1587 2
  set->function.cfunc = set_range_command;
  show->function.cfunc = show_range_command;
d1595 2
a1596 2
  set->function.cfunc = set_case_command;
  show->function.cfunc = show_case_command;
@


1.19
log
@Use phex_nz() not printf
@
text
@a102 1
extern char *warning_pre_print;
d1236 6
a1241 6
/* These are called when a language fails a type- or range-check.
   The first argument should be a printf()-style format string, and
   the rest of the arguments should be its arguments.  If
   [type|range]_check is [type|range]_check_on, then return_to_top_level()
   is called in the style of error ().  Otherwise, the message is prefixed
   by the value of warning_pre_print and we do not return to the top level. */
d1244 1
a1244 1
type_error (char *string,...)
d1249 17
a1265 7
  if (type_check == type_check_warn)
    fprintf_filtered (gdb_stderr, warning_pre_print);
  else
    error_begin ();

  vfprintf_filtered (gdb_stderr, string, args);
  fprintf_filtered (gdb_stderr, "\n");
a1266 2
  if (type_check == type_check_on)
    return_to_top_level (RETURN_ERROR);
d1270 1
a1270 1
range_error (char *string,...)
d1275 17
a1291 7
  if (range_check == range_check_warn)
    fprintf_filtered (gdb_stderr, warning_pre_print);
  else
    error_begin ();

  vfprintf_filtered (gdb_stderr, string, args);
  fprintf_filtered (gdb_stderr, "\n");
a1292 2
  if (range_check == range_check_on)
    return_to_top_level (RETURN_ERROR);
@


1.18
log
@* language.c (longest_raw_hex_string): Delete unused function.
@
text
@d665 1
a665 1
  /* Use strcat_address_numeric to print the number into a string, then
d668 1
a668 12

  temp_nbr_buf[0] = 0;
  /* With use_local == 0, we don't get the leading "0x" prefix. */
  /* MERGEBUG ?? As a quick fix I am replacing this call to
     strcat_address_numeric with sprintf
     strcat_address_numeric(num, 0, temp_nbr_buf, RESULT_BUF_LEN);
   */

  {
    long long ll = num;
    sprintf (temp_nbr_buf, "%llx", ll);
  }
@


1.17
log
@s/value_ptr/struct value */
@
text
@a598 23
#if 0
/* FIXME: cagney/2000-03-04: This function does not appear to be used.
   It can be deleted once 5.0 has been released. */
/* FIXME: cagney/2000-03-04: This code assumes that the compiler
   supports ``long long''. */
/* Converts a number to hexadecimal (without leading "0x") and stores it in a
   static string.  Returns a pointer to this string. */

char *
longest_raw_hex_string (LONGEST num)
{
  static char res_longest_raw_hex_string[50];
  long long ll = num;		/* MERGEBUG ?? see below */
  res_longest_raw_hex_string[0] = 0;
  /* MERGEBUG ?? As a quick fix I am replacing this with sprintf 
     strcat_address_numeric (num, 0, res_longest_raw_hex_string, 50); 
   */

  sprintf (res_longest_raw_hex_string, "%llx", ll);
  return res_longest_raw_hex_string;
}
#endif

@


1.16
log
@2001-05-08  Michael Snyder  <msnyder@@redhat.com>

	* language.c (longest_local_hex_string_custom): Strlen test is
	inverted -- reverse the sense of the test.
@
text
@d99 1
a99 1
static int unk_lang_value_print (value_ptr, struct ui_file *, int, enum val_prettyprint);
d540 1
a540 1
binop_result_type (value_ptr v1, value_ptr v2)
d1052 1
a1052 1
value_true (value_ptr val)
d1069 1
a1069 1
binop_type_check (value_ptr arg1, value_ptr arg2, int op)
d1460 1
a1460 1
unk_lang_value_print (value_ptr val, struct ui_file *stream, int format,
@


1.15
log
@* arch-utils.c (#include "gdbthread.h"): Removed.
(#include "symfile.h"): Removed.
(XMALLOC): Removed unused macro.
* breakpoint.c (tbreak_command): Removed local declaration.
(awatch_command, do_enable_breakpoint, set_breakpoint_count):
Remove duplicate declarations.
(bpstat_should_step, bpstat_have_active_hw_watchpoints)
(remove_solib_event_breakpoints): Fix indentation botch.
* c-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* ch-exp.c (ch_terminal_match_float_literal, parse_expr)
(parse_primval, parse_untyped_expr, parse_opt_untyped_expr):
Removed duplicate declarations.
* ch-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* corefile.c (#include "frame.h"): Removed
(#include "symfile.h"): Removed.
(#include "language.h"): Removed.
* dbxread.c (#include "command.h"): Removed.
* environ.c (#include "gdbcore.h"): Removed.
* event-loop.c (#include "top.h"): Removed.
* f-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
(#include "typeprint.h"): Removed.
(#include "frame.h"): Removed.
* gdbtypes.h (print_type_scalar): Removed declaration.
* infcmd.c (#include "completer.h"): Removed.
* language.c (#include "frame.h"): Removed.
* m2-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
* m2-valprint.c (#include "valprint.h"): Removed.
* p-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* p-valprint.c (#include "typeprint.h"): Removed.
* parse.c (#include "linespec.h"): Removed.
* regcache.c (#include "frame.h"): Removed.
* remote.c (#include "frame.h"): Removed.
(getpkt_sane): Make static.
* source.c (#include "completer.h"): Removed.
* stack.c (#include "symfile.h"): Removed.
(#include "objfiles.h"): Removed.
* symfile.c (#include "completer.h"): Removed.
* tracepoint.c (#include "completer.h"): Removed.
* values.c (#include "frame.h"): Removed.
* varobj.c (#include "valprint.h"): Removed.
* wrapper.c (#include "frame.h"): Removed.

* memattr.c (create_mem_region): Removed unused variable.
* remote-nrom.c: Removed spurious semicolon after init_nrom_ops.
-------------------------------------------------------------------
@
text
@d723 1
a723 1
      < RESULT_BUF_LEN)		/* paranoia */
@


1.14
log
@Update/correct copyright notices.
@
text
@a39 1
#include "frame.h"
@


1.13
log
@Replace calls to abort() with calls to internal_error().
@
text
@d2 2
a3 1
   Copyright 1991, 1992, 2000, 2001 Free Software Foundation, Inc.
@


1.12
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d574 1
a574 1
  abort ();
d1387 1
a1387 1
      abort ();
@


1.11
log
@Replace free() with xfree().
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 2000 Free Software Foundation, Inc.
d724 2
a725 1
    internal_error ("longest_local_hex_string_custom: insufficient space to store result");
@


1.10
log
@Protoization.
@
text
@d234 1
a234 1
  make_cleanup (free, err_lang);	/* Free it after error */
d424 1
a424 1
    free (language);
d437 1
a437 1
    free (type);
d483 1
a483 1
    free (range);
d507 1
a507 1
   free (case_sensitive);
@


1.9
log
@2000-08-10	Jimmy Guo	<guo@@cup.hp.com>

	* c-lang.c: Set case sensitivity on for c_language_defn,
	cplus_language_defn, and asm_language_defn.
	* ch-lang.c: Set case sensitivity on for chill_language_defn.
	* f-lang.c: Set case sensivitity off for f_language_defn.
	* jv-lang.c: Set case sensitivity on for java_language_defn.
	* language.h: Add enum case_mode, case_sensitivity.
	* language.c: Define case_mode, case_sensitivity.  Set case
	sensitivity on for unknown_language_defn, auto_language_defn,
	and local_language_defn.
	(show_case_command,set_case_command,set_case_str): New static func.
	(set_type_range_case): New static func, replaces set_type_range ().
	(set_language_command,set_type_command,set_range_command,set_language):
	Call set_type_range_case ().
	(language_info): Print case sensitivity setting.
	(_initialize_language): Add set/show commands for 'case-sensitive'.
	Set default case mode 'auto'.  Set default language 'auto'.
	* m2-lang.c: Set case sensitivity on for m2_language_defn.
	* p-lang.c: Set case sensitivity on for pascal_language_defn.
	* scm-lang.c: Set case sensitivity off for scm_language_defn.
	* symtab.c (lookup_symbol): Downcase symbol name if case sensivitity
	is off.
@
text
@d333 1
a333 3
show_case_command(ignore, from_tty)
   char *ignore;
   int from_tty;
d342 1
a342 3
set_case_command(ignore, from_tty)
   char *ignore;
   int from_tty;
@


1.8
log
@Protoization.
@
text
@d60 6
d80 1
a80 1
static void set_type_range (void);
d114 2
d143 1
d223 1
a223 1
	      set_type_range ();
d271 1
a271 1
      set_type_range ();
d273 1
a273 1
         did it in set_type_range. */
d317 1
a317 1
      set_type_range ();
d319 1
a319 1
         did it in set_type_range. */
d330 45
a374 1
/* Set the status of range and type checking based on
d379 1
a379 1
set_type_range (void)
d388 3
d393 1
d411 1
a411 1
	  set_type_range ();
d491 23
d534 2
d1485 1
d1515 1
d1544 1
d1611 9
a1624 2
  set_language_command (language, 0);

d1626 2
a1627 1
  set_type_command (NULL, 0);
d1629 2
a1630 2
  range = savestring ("auto", strlen ("auto"));
  set_range_command (NULL, 0);
@


1.7
log
@	* language.c: Include jv-lang.h.
	(lang_bool_type): Add case for java booleans.

And in testsuite...

	* gdb.java/jv-exp.exp: New file.
@
text
@d148 1
a148 3
show_language_command (ignore, from_tty)
     char *ignore;
     int from_tty;
d161 1
a161 3
set_language_command (ignore, from_tty)
     char *ignore;
     int from_tty;
d233 1
a233 3
show_type_command (ignore, from_tty)
     char *ignore;
     int from_tty;
d242 1
a242 3
set_type_command (ignore, from_tty)
     char *ignore;
     int from_tty;
d278 1
a278 3
show_range_command (ignore, from_tty)
     char *ignore;
     int from_tty;
d288 1
a288 3
set_range_command (ignore, from_tty)
     char *ignore;
     int from_tty;
d326 1
a326 1
set_type_range ()
d342 1
a342 2
set_language (lang)
     enum language lang;
d366 1
a366 1
set_lang_str ()
d379 1
a379 1
set_type_str ()
d407 1
a407 1
set_range_str ()
d439 1
a439 2
language_info (quietly)
     int quietly;
d462 1
a462 2
binop_result_type (v1, v2)
     value_ptr v1, v2;
d509 1
a509 2
local_hex_format_custom (pre)
     char *pre;
d530 1
a530 2
longest_raw_hex_string (num)
     LONGEST num;
d547 1
a547 2
local_hex_string (num)
     unsigned long num;
d558 1
a558 2
longest_local_hex_string (num)
     LONGEST num;
d566 1
a566 3
local_hex_string_custom (num, pre)
     unsigned long num;
     char *pre;
d579 1
a579 3
longest_local_hex_string_custom (num, width)
     LONGEST num;
     char *width;
d674 1
a674 2
local_octal_format_custom (pre)
     char *pre;
d688 1
a688 2
local_decimal_format_custom (pre)
     char *pre;
d719 1
a719 2
simple_type (type)
     struct type *type;
d742 1
a742 2
ordered_type (type)
     struct type *type;
d761 1
a761 2
same_type (arg1, arg2)
     struct type *arg1, *arg2;
d779 1
a779 2
integral_type (type)
     struct type *type;
d800 1
a800 2
numeric_type (type)
     struct type *type;
d816 1
a816 2
character_type (type)
     struct type *type;
d838 1
a838 2
string_type (type)
     struct type *type;
d859 1
a859 2
boolean_type (type)
     struct type *type;
d880 1
a880 2
float_type (type)
     struct type *type;
d888 1
a888 2
pointer_type (type)
     struct type *type;
d896 1
a896 2
structured_type (type)
     struct type *type;
d924 1
a924 1
lang_bool_type ()
d973 1
a973 2
value_true (val)
     value_ptr val;
d990 1
a990 3
binop_type_check (arg1, arg2, op)
     value_ptr arg1, arg2;
     int op;
d1182 1
a1182 4
op_error (fmt, op, fatal)
     char *fmt;
     enum exp_opcode op;
     int fatal;
d1241 1
a1241 2
language_enum (str)
     char *str;
d1255 1
a1255 2
language_def (lang)
     enum language lang;
d1271 1
a1271 2
language_str (lang)
     enum language lang;
d1286 1
a1286 3
set_check (ignore, from_tty)
     char *ignore;
     int from_tty;
d1294 1
a1294 3
show_check (ignore, from_tty)
     char *ignore;
     int from_tty;
d1302 1
a1302 2
add_language (lang)
     const struct language_defn *lang;
d1329 1
a1329 1
unk_lang_parser ()
d1335 1
a1335 2
unk_lang_error (msg)
     char *msg;
d1341 1
a1341 4
unk_lang_emit_char (c, stream, quoter)
     register int c;
     struct ui_file *stream;
     int quoter;
d1347 1
a1347 3
unk_lang_printchar (c, stream)
     register int c;
     struct ui_file *stream;
d1353 2
a1354 6
unk_lang_printstr (stream, string, length, width, force_ellipses)
     struct ui_file *stream;
     char *string;
     unsigned int length;
     int width;
     int force_ellipses;
d1360 1
a1360 3
unk_lang_create_fundamental_type (objfile, typeid)
     struct objfile *objfile;
     int typeid;
d1366 2
a1367 6
unk_lang_print_type (type, varstring, stream, show, level)
     struct type *type;
     char *varstring;
     struct ui_file *stream;
     int show;
     int level;
d1373 3
a1375 11
unk_lang_val_print (type, valaddr, embedded_offset, address, stream, format, deref_ref,
		    recurse, pretty)
     struct type *type;
     char *valaddr;
     int embedded_offset;
     CORE_ADDR address;
     struct ui_file *stream;
     int format;
     int deref_ref;
     int recurse;
     enum val_prettyprint pretty;
d1381 2
a1382 5
unk_lang_value_print (val, stream, format, pretty)
     value_ptr val;
     struct ui_file *stream;
     int format;
     enum val_prettyprint pretty;
d1484 1
a1484 1
_initialize_language ()
@


1.6
log
@    * defs.h: define language_pascal in language enumeration.
    * language.h: define _LANG_pascal macro.
    * language.c: add language_pascal support in all language dependant functions.
@
text
@d44 1
d990 9
@


1.5
log
@PARAMS removal.
@
text
@d817 1
d853 1
d876 1
d941 5
d977 5
a981 1
      sym = lookup_symbol ("bool", NULL, VAR_NAMESPACE, NULL, NULL);
d1173 15
@


1.4
log
@
       * language.c (set_lang_str): Do not call `free' for a null pointer.
         (set_type_str, set_range_str): Ditto.
@
text
@d45 1
a45 1
extern void _initialize_language PARAMS ((void));
d47 1
a47 2
static void
show_language_command PARAMS ((char *, int));
d49 1
a49 2
static void
set_language_command PARAMS ((char *, int));
d51 1
a51 2
static void
show_type_command PARAMS ((char *, int));
d53 1
a53 2
static void
set_type_command PARAMS ((char *, int));
d55 1
a55 2
static void
show_range_command PARAMS ((char *, int));
d57 1
a57 2
static void
set_range_command PARAMS ((char *, int));
d59 1
a59 2
static void
set_range_str PARAMS ((void));
d61 1
a61 2
static void
set_type_str PARAMS ((void));
d63 1
a63 2
static void
set_lang_str PARAMS ((void));
d65 1
a65 2
static void
unk_lang_error PARAMS ((char *));
d67 1
a67 2
static int
unk_lang_parser PARAMS ((void));
d69 1
a69 2
static void
show_check PARAMS ((char *, int));
d71 1
a71 2
static void
set_check PARAMS ((char *, int));
d73 1
a73 2
static void
set_type_range PARAMS ((void));
d83 1
a83 2
static struct type *
  unk_lang_create_fundamental_type PARAMS ((struct objfile *, int));
@


1.3
log
@Don't use LONG_LONG when it isn't available.
@
text
@d397 2
a398 1
  free (language);
d410 2
a411 1
  free (type);
d456 2
a457 1
  free (range);
@


1.2
log
@Comment out longest_raw_hex_string.
@
text
@d633 1
a633 3
#endif

#if defined (PRINTF_HAS_LONG_LONG)
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1991, 1992 Free Software Foundation, Inc.
d6 1
a6 1
This file is part of GDB.
d8 14
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d45 2
d89 1
a89 2
static void
unk_lang_emit_char PARAMS ((int c, GDB_FILE *stream, int quoter));
d91 1
a91 2
static void
unk_lang_printchar PARAMS ((int c, GDB_FILE *stream));
d93 3
a95 2
static void
unk_lang_printstr PARAMS ((GDB_FILE *stream, char *string, unsigned int length, int width, int force_ellipses));
d98 1
a98 1
unk_lang_create_fundamental_type PARAMS ((struct objfile *, int));
d100 2
a101 2
static void
unk_lang_print_type PARAMS ((struct type *, char *, GDB_FILE *, int, int));
d103 3
a105 3
static int
unk_lang_val_print PARAMS ((struct type *, char *, int, CORE_ADDR, GDB_FILE *,
			    int, int, int, enum val_prettyprint));
d107 1
a107 2
static int
unk_lang_value_print PARAMS ((value_ptr, GDB_FILE *, int, enum val_prettyprint));
d112 1
a112 1
  
d114 3
a116 3
    (If the modes are set to "auto", though, these are changed based
    on the default language at startup, and then again based on the
    language of the first source file.  */
d153 2
a154 1
	"Warning: the current language does not match this frame.";
a155 1

d163 2
a164 2
   char *ignore;
   int from_tty;
d166 1
a166 1
   enum language flang;		/* The language of the current frame */
d168 5
a172 5
   flang = get_frame_language();
   if (flang != language_unknown &&
       language_mode == language_mode_manual &&
       current_language->la_language != flang)
     printf_filtered("%s\n",lang_frame_mismatch_warn);
d178 2
a179 2
   char *ignore;
   int from_tty;
d187 1
a187 1
      printf_unfiltered("The currently understood settings are:\n\n");
d201 2
a202 2
			     /* Capitalize first letter of language
				name.  */
d207 1
a207 1
      set_language(current_language->la_language);
d212 26
a237 20
  for (i = 0; i < languages_size; i++) {
    if (STREQ (languages[i]->la_name, language)) {
      /* Found it!  Go into manual mode, and use this language.  */
      if (languages[i]->la_language == language_auto) {
	/* Enter auto mode.  Set to the current frame's language, if known.  */
	language_mode = language_mode_auto;
  	flang = get_frame_language();
	if (flang!=language_unknown)
	  set_language(flang);
	expected_language = current_language;
	return;
      } else {
	/* Enter manual mode.  Set the specified language.  */
	language_mode = language_mode_manual;
	current_language = languages[i];
	set_type_range ();
	set_lang_str();
	expected_language = current_language;
	return;
      }
a238 1
  }
d242 1
a242 1
  err_lang=savestring(language,strlen(language));
d244 2
a245 2
  set_language(current_language->la_language);
  error ("Unknown language `%s'.",err_lang);
d251 7
a257 7
show_type_command(ignore, from_tty)
   char *ignore;
   int from_tty;
{
   if (type_check != current_language->la_type_check)
      printf_unfiltered(
"Warning: the current type check setting does not match the language.\n");
d262 3
a264 3
set_type_command(ignore, from_tty)
   char *ignore;
   int from_tty;
d266 2
a267 2
   if (STREQ(type,"on"))
   {
d270 3
a272 3
   }
   else if (STREQ(type,"warn"))
   {
d275 3
a277 3
   }
   else if (STREQ(type,"off"))
   {
d280 3
a282 3
   }
   else if (STREQ(type,"auto"))
   {
d284 1
a284 1
      set_type_range();
d288 7
a294 3
   }
   set_type_str();
   show_type_command((char *)NULL, from_tty);
d300 3
a302 3
show_range_command(ignore, from_tty)
   char *ignore;
   int from_tty;
d305 3
a307 3
   if (range_check != current_language->la_range_check)
      printf_unfiltered(
"Warning: the current range check setting does not match the language.\n");
d312 3
a314 3
set_range_command(ignore, from_tty)
   char *ignore;
   int from_tty;
d316 2
a317 2
   if (STREQ(range,"on"))
   {
d320 3
a322 3
   }
   else if (STREQ(range,"warn"))
   {
d325 3
a327 3
   }
   else if (STREQ(range,"off"))
   {
d330 3
a332 3
   }
   else if (STREQ(range,"auto"))
   {
d334 1
a334 1
      set_type_range();
d336 1
a336 1
	 did it in set_type_range. */
d338 7
a344 3
   }
   set_range_str();
   show_range_command((char *)0, from_tty);
d352 1
a352 1
set_type_range()
d361 2
a362 2
  set_type_str();
  set_range_str();
d368 2
a369 2
set_language(lang)
   enum language lang;
d376 9
a384 6
  for (i = 0; i < languages_size; i++) {
    if (languages[i]->la_language == lang) {
      current_language = languages[i];
      set_type_range ();
      set_lang_str();
      break;
a385 1
  }
d393 1
a393 1
set_lang_str()
d395 1
a395 1
   char *prefix = "";
d397 3
a399 3
   free (language);
   if (language_mode == language_mode_auto)
      prefix = "auto; currently ";
d401 1
a401 1
   language = concat(prefix, current_language->la_name, NULL);
d405 1
a405 1
set_type_str()
d407 1
a407 1
   char *tmp, *prefix = "";
d409 3
a411 3
   free (type);
   if (type_mode==type_mode_auto)
      prefix = "auto; currently ";
d413 3
a415 3
   switch(type_check)
   {
   case type_check_on:
d418 1
a418 1
   case type_check_off:
d421 1
a421 1
   case type_check_warn:
d424 1
a424 1
      default:
d426 1
a426 1
   }
d428 1
a428 1
   type = concat(prefix,tmp,NULL);
d432 1
a432 1
set_range_str()
d434 1
a434 1
   char *tmp, *pref = "";
d436 2
a437 3
   free (range);
   if (range_mode==range_mode_auto)
      pref = "auto; currently ";
d439 3
a441 3
   switch(range_check)
   {
   case range_check_on:
d444 1
a444 1
   case range_check_off:
d447 1
a447 1
   case range_check_warn:
d450 1
a450 1
      default:
d452 1
a452 1
   }
d454 2
a455 1
   range = concat(pref,tmp,NULL);
d470 2
a471 2
  printf_unfiltered("Current language:  %s\n",language);
  show_language_command((char *)0, 1);
d475 4
a478 4
       printf_unfiltered("Type checking:     %s\n",type);
       show_type_command((char *)0, 1);
       printf_unfiltered("Range checking:    %s\n",range);
       show_range_command((char *)0, 1);
d484 1
a484 1
#if 0	/* Currently unused */
d488 1
a488 1
   value_ptr v1, v2;
d490 23
a512 23
   int size,uns;
   struct type *t1 = check_typedef (VALUE_TYPE (v1));
   struct type *t2 = check_typedef (VALUE_TYPE (v2));

   int l1 = TYPE_LENGTH (t1);
   int l2 = TYPE_LENGTH (t2);

   switch(current_language->la_language)
   {
   case language_c:
   case language_cplus:
      if (TYPE_CODE (t1)==TYPE_CODE_FLT)
	 return TYPE_CODE(t2) == TYPE_CODE_FLT && l2 > l1 ?
	    VALUE_TYPE(v2) : VALUE_TYPE(v1);
      else if (TYPE_CODE(t2)==TYPE_CODE_FLT)
	 return TYPE_CODE(t1)) == TYPE_CODE_FLT && l1 > l2 ?
	    VALUE_TYPE(v1) : VALUE_TYPE(v2);
      else if (TYPE_UNSIGNED(t1) && l1 > l2)
	 return VALUE_TYPE(v1);
      else if (TYPE_UNSIGNED(t2) && l2 > l1)
	 return VALUE_TYPE(v2);
      else  /* Both are signed.  Result is the longer type */
	 return l1 > l2 ? VALUE_TYPE(v1) : VALUE_TYPE(v2);
d514 1
a514 1
   case language_m2:
d516 2
a517 2
	 not needed. */
      return l1 > l2 ? VALUE_TYPE(v1) : VALUE_TYPE(v2);
d519 5
a523 5
   case language_chill:
      error ("Missing Chill support in function binop_result_check.");/*FIXME*/
   }
   abort();
   return (struct type *)0;	/* For lint */
d526 2
a527 1
#endif	/* 0 */
a528 1

d535 24
a558 2
local_hex_format_custom(pre)
   char *pre;
d560 6
a565 1
   static char form[50];
d567 2
a568 6
   strcpy (form, local_hex_format_prefix ());
   strcat (form, "%");
   strcat (form, pre);
   strcat (form, local_hex_format_specifier ());
   strcat (form, local_hex_format_suffix ());
   return form;
d570 1
d576 1
a576 1
   unsigned long num;
d578 1
a578 1
   static char res[50];
d580 11
a590 2
   sprintf (res, local_hex_format(), num);
   return res;
d596 3
a598 3
local_hex_string_custom(num,pre)
   unsigned long num;
   char *pre;
d600 1
a600 1
   static char res[50];
d602 2
a603 2
   sprintf (res, local_hex_format_custom(pre), num);
   return res;
d606 101
d710 2
a711 2
local_octal_format_custom(pre)
   char *pre;
d713 1
a713 1
   static char form[50];
d715 6
a720 6
   strcpy (form, local_octal_format_prefix ());
   strcat (form, "%");
   strcat (form, pre);
   strcat (form, local_octal_format_specifier ());
   strcat (form, local_octal_format_suffix ());
   return form;
d725 2
a726 2
local_decimal_format_custom(pre)
   char *pre;
d728 1
a728 1
   static char form[50];
d730 6
a735 6
   strcpy (form, local_decimal_format_prefix ());
   strcat (form, "%");
   strcat (form, pre);
   strcat (form, local_decimal_format_specifier ());
   strcat (form, local_decimal_format_suffix ());
   return form;
d757 2
a758 2
simple_type(type)
    struct type *type;
d761 9
a769 8
  switch (TYPE_CODE (type)) {
  case TYPE_CODE_INT:
  case TYPE_CODE_CHAR:
  case TYPE_CODE_ENUM:
  case TYPE_CODE_FLT:
  case TYPE_CODE_RANGE:
  case TYPE_CODE_BOOL:
    return 1;
d771 3
a773 3
  default:
    return 0;
  }
d782 1
a782 1
   struct type *type;
d785 8
a792 7
  switch (TYPE_CODE (type)) {
  case TYPE_CODE_INT:
  case TYPE_CODE_CHAR:
  case TYPE_CODE_ENUM:
  case TYPE_CODE_FLT:
  case TYPE_CODE_RANGE:
    return 1;
d794 3
a796 3
  default:
    return 0;
  }
d802 1
a802 1
   struct type *arg1, *arg2;
d805 11
a815 11
   if (structured_type(arg1) ? !structured_type(arg2) : structured_type(arg2))
      /* One is structured and one isn't */
      return 0;
   else if (structured_type(arg1) && structured_type(arg2))
      return arg1 == arg2;
   else if (numeric_type(arg1) && numeric_type(arg2))
      return (TYPE_CODE(arg2) == TYPE_CODE(arg1)) &&
	 (TYPE_UNSIGNED(arg1) == TYPE_UNSIGNED(arg2))
	    ? 1 : 0;
   else
      return arg1==arg2;
d821 1
a821 1
   struct type *type;
d824 11
a834 11
   switch(current_language->la_language)
   {
   case language_c:
   case language_cplus:
      return (TYPE_CODE(type) != TYPE_CODE_INT) &&
	 (TYPE_CODE(type) != TYPE_CODE_ENUM) ? 0 : 1;
   case language_m2:
      return TYPE_CODE(type) != TYPE_CODE_INT ? 0 : 1;
   case language_chill:
      error ("Missing Chill support in function integral_type.");  /*FIXME*/
   default:
d836 1
a836 1
   }
d842 1
a842 1
   struct type *type;
d845 5
a849 4
  switch (TYPE_CODE (type)) {
  case TYPE_CODE_INT:
  case TYPE_CODE_FLT:
    return 1;
d851 3
a853 3
  default:
    return 0;
  }
d859 1
a859 1
   struct type *type;
d862 12
a873 12
  switch(current_language->la_language)
   {
   case language_chill:
   case language_m2:
      return TYPE_CODE(type) != TYPE_CODE_CHAR ? 0 : 1;

   case language_c:
   case language_cplus:
      return (TYPE_CODE(type) == TYPE_CODE_INT) &&
	 TYPE_LENGTH(type) == sizeof(char)
	 ? 1 : 0;
   default:
d875 1
a875 1
   }
d881 1
a881 1
   struct type *type;
d884 5
a888 5
  switch(current_language->la_language)
   {
   case language_chill:
   case language_m2:
      return TYPE_CODE(type) != TYPE_CODE_STRING ? 0 : 1;
d890 2
a891 2
   case language_c:
   case language_cplus:
d894 1
a894 1
   default:
d896 1
a896 1
   }
d902 1
a902 1
   struct type *type;
d907 1
a907 1
  switch(current_language->la_language)
d912 1
a912 1
	 for CHILL and such languages, or a TYPE_CODE_INT_OR_BOOL for C.  */
d915 1
a915 1
   default:
d917 1
a917 1
   }
d924 1
a924 1
   struct type *type;
d927 1
a927 1
  return TYPE_CODE(type) == TYPE_CODE_FLT;
d932 2
a933 2
pointer_type(type)
   struct type *type;
d935 2
a936 2
   return TYPE_CODE(type) == TYPE_CODE_PTR ||
      TYPE_CODE(type) == TYPE_CODE_REF;
d941 2
a942 2
structured_type(type)
   struct type *type;
d945 14
a958 14
   switch(current_language->la_language)
   {
   case language_c:
   case language_cplus:
      return (TYPE_CODE(type) == TYPE_CODE_STRUCT) ||
	 (TYPE_CODE(type) == TYPE_CODE_UNION) ||
	    (TYPE_CODE(type) == TYPE_CODE_ARRAY);
   case language_m2:
      return (TYPE_CODE(type) == TYPE_CODE_STRUCT) ||
	 (TYPE_CODE(type) == TYPE_CODE_SET) ||
	    (TYPE_CODE(type) == TYPE_CODE_ARRAY);
   case language_chill:
      error ("Missing Chill support in function structured_type.");  /*FIXME*/
   default:
d960 1
a960 1
   }
d969 1
a969 1
  switch(current_language->la_language)
d1016 1
a1016 1
#if 0	/* Currently unused */
d1019 3
a1021 3
binop_type_check(arg1,arg2,op)
   value_ptr arg1,arg2;
   int op;
d1023 1
a1023 1
   struct type *t1, *t2;
d1025 3
a1027 3
   /* If we're not checking types, always return success. */
   if (!STRICT_TYPE)
      return;
d1029 5
a1033 24
   t1=VALUE_TYPE(arg1);
   if (arg2 != NULL)
      t2=VALUE_TYPE(arg2);
   else
      t2=NULL;

   switch(op)
   {
   case BINOP_ADD:
   case BINOP_SUB:
      if ((numeric_type(t1) && pointer_type(t2)) ||
	 (pointer_type(t1) && numeric_type(t2)))
      {
	 warning ("combining pointer and integer.\n");
	 break;
      }
   case BINOP_MUL:
   case BINOP_LSH:
   case BINOP_RSH:
      if (!numeric_type(t1) || !numeric_type(t2))
	 type_op_error ("Arguments to %s must be numbers.",op);
      else if (!same_type(t1,t2))
	 type_op_error ("Arguments to %s must be of the same type.",op);
      break;
d1035 69
a1103 50
   case BINOP_LOGICAL_AND:
   case BINOP_LOGICAL_OR:
      if (!boolean_type(t1) || !boolean_type(t2))
	 type_op_error ("Arguments to %s must be of boolean type.",op);
      break;

   case BINOP_EQUAL:
      if ((pointer_type(t1) && !(pointer_type(t2) || integral_type(t2))) ||
	 (pointer_type(t2) && !(pointer_type(t1) || integral_type(t1))))
	 type_op_error ("A pointer can only be compared to an integer or pointer.",op);
      else if ((pointer_type(t1) && integral_type(t2)) ||
	 (integral_type(t1) && pointer_type(t2)))
      {
	 warning ("combining integer and pointer.\n");
	 break;
      }
      else if (!simple_type(t1) || !simple_type(t2))
	 type_op_error ("Arguments to %s must be of simple type.",op);
      else if (!same_type(t1,t2))
	 type_op_error ("Arguments to %s must be of the same type.",op);
      break;

   case BINOP_REM:
   case BINOP_MOD:
      if (!integral_type(t1) || !integral_type(t2))
	 type_op_error ("Arguments to %s must be of integral type.",op);
      break;

   case BINOP_LESS:
   case BINOP_GTR:
   case BINOP_LEQ:
   case BINOP_GEQ:
      if (!ordered_type(t1) || !ordered_type(t2))
	 type_op_error ("Arguments to %s must be of ordered type.",op);
      else if (!same_type(t1,t2))
	 type_op_error ("Arguments to %s must be of the same type.",op);
      break;

   case BINOP_ASSIGN:
      if (pointer_type(t1) && !integral_type(t2))
	 type_op_error ("A pointer can only be assigned an integer.",op);
      else if (pointer_type(t1) && integral_type(t2))
      {
	 warning ("combining integer and pointer.");
	 break;
      }
      else if (!simple_type(t1) || !simple_type(t2))
	 type_op_error ("Arguments to %s must be of simple type.",op);
      else if (!same_type(t1,t2))
	 type_op_error ("Arguments to %s must be of the same type.",op);
d1108 3
a1110 3
      if (!(string_type(t1) || character_type(t1) || integral_type(t1))
	  || !(string_type(t2) || character_type(t2) || integral_type(t2)))
	  type_op_error ("Arguments to %s must be strings or characters.", op);
d1113 1
a1113 1
   /* Unary checks -- arg2 is null */
d1115 3
a1117 3
   case UNOP_LOGICAL_NOT:
      if (!boolean_type(t1))
	 type_op_error ("Argument to %s must be of boolean type.",op);
d1120 4
a1123 4
   case UNOP_PLUS:
   case UNOP_NEG:
      if (!numeric_type(t1))
	 type_op_error ("Argument to %s must be of numeric type.",op);
d1126 8
a1133 8
   case UNOP_IND:
      if (integral_type(t1))
      {
	 warning ("combining pointer and integer.\n");
	 break;
      }
      else if (!pointer_type(t1))
	 type_op_error ("Argument to %s must be a pointer.",op);
d1136 6
a1141 6
   case UNOP_PREINCREMENT:
   case UNOP_POSTINCREMENT:
   case UNOP_PREDECREMENT:
   case UNOP_POSTDECREMENT:
      if (!ordered_type(t1))
	 type_op_error ("Argument to %s must be of an ordered type.",op);
d1144 1
a1144 1
   default:
d1146 3
a1148 3
	 different languages. */
      switch(current_language->la_language)
      {
d1150 10
a1159 10
      case language_c:
      case language_cplus:
	 switch(op)
	 {
	 case BINOP_DIV:
	    if (!numeric_type(t1) || !numeric_type(t2))
	       type_op_error ("Arguments to %s must be numbers.",op);
	    break;
	 }
	 break;
d1163 12
a1174 12
      case language_m2:
	 switch(op)
	 {
	 case BINOP_DIV:
	    if (!float_type(t1) || !float_type(t2))
	       type_op_error ("Arguments to %s must be floating point numbers.",op);
	    break;
	 case BINOP_INTDIV:
	    if (!integral_type(t1) || !integral_type(t2))
	       type_op_error ("Arguments to %s must be of integral type.",op);
	    break;
	 }
d1178 2
a1179 2
       case language_chill:
	 error ("Missing Chill support in function binop_type_check.");/*FIXME*/
d1182 2
a1183 2
      }
   }
d1186 2
a1187 1
#endif	/* 0 */
a1188 1

d1198 11
a1208 11
op_error (fmt,op,fatal)
   char *fmt;
   enum exp_opcode op;
   int fatal;
{
   if (fatal)
      error (fmt,op_string(op));
   else
   {
      warning (fmt,op_string(op));
   }
d1219 1
a1219 6
#ifdef ANSI_PROTOTYPES
type_error (char *string, ...)
#else
type_error (va_alist)
     va_dcl
#endif
d1221 2
a1222 8
   va_list args;
#ifdef ANSI_PROTOTYPES
   va_start (args, string);
#else
   char *string;
   va_start (args);
   string = va_arg (args, char *);
#endif
d1224 10
a1233 10
   if (type_check == type_check_warn)
     fprintf_filtered (gdb_stderr, warning_pre_print);
   else
     error_begin ();

   vfprintf_filtered (gdb_stderr, string, args);
   fprintf_filtered (gdb_stderr, "\n");
   va_end (args);
   if (type_check == type_check_on)
     return_to_top_level (RETURN_ERROR);
d1237 1
a1237 6
#ifdef ANSI_PROTOTYPES
range_error (char *string, ...)
#else
range_error (va_alist)
     va_dcl
#endif
d1239 2
a1240 8
   va_list args;
#ifdef ANSI_PROTOTYPES
   va_start (args, string);
#else
   char *string;
   va_start (args);
   string = va_arg (args, char *);
#endif
d1242 10
a1251 10
   if (range_check == range_check_warn)
     fprintf_filtered (gdb_stderr, warning_pre_print);
   else
     error_begin ();

   vfprintf_filtered (gdb_stderr, string, args);
   fprintf_filtered (gdb_stderr, "\n");
   va_end (args);
   if (range_check == range_check_on)
     return_to_top_level (RETURN_ERROR);
d1253 1
a1254 1

d1265 1
a1265 1
  for (i = 0; i < languages_size; i++) 
d1275 2
a1276 2
language_def(lang)
   enum language lang;
d1280 6
a1285 3
  for (i = 0; i < languages_size; i++) {
    if (languages[i]->la_language == lang) {
      return languages[i];
a1286 1
  }
d1292 2
a1293 2
language_str(lang)
   enum language lang;
d1297 6
a1302 3
  for (i = 0; i < languages_size; i++) {
    if (languages[i]->la_language == lang) {
      return languages[i]->la_name;
a1303 1
  }
d1309 2
a1310 2
   char *ignore;
   int from_tty;
d1312 3
a1314 3
   printf_unfiltered(
"\"set check\" must be followed by the name of a check subcommand.\n");
   help_list(setchecklist, "set check ", -1, gdb_stdout);
d1319 2
a1320 2
   char *ignore;
   int from_tty;
d1322 1
a1322 1
   cmd_show_list(showchecklist, from_tty, "");
d1333 3
a1335 3
      fprintf_unfiltered(gdb_stderr, "Magic number of %s language struct wrong\n",
	lang->la_name);
      abort();
d1348 1
a1348 1
	languages_allocsize * sizeof (*languages));
d1371 1
a1371 1
     GDB_FILE *stream;
d1380 1
a1380 1
     GDB_FILE *stream;
d1387 1
a1387 1
     GDB_FILE *stream;
d1408 1
a1408 1
     GDB_FILE *stream;
d1416 1
a1416 1
unk_lang_val_print (type, valaddr,  embedded_offset, address, stream, format, deref_ref,
d1422 1
a1422 1
     GDB_FILE *stream;
d1434 1
a1434 1
     GDB_FILE *stream;
d1441 7
a1447 3
static struct type ** CONST_PTR (unknown_builtin_types[]) = { 0 };
static const struct op_print unk_op_print_tab[] = {
    {NULL, OP_NULL, PREC_NULL, 0}
d1450 2
a1451 1
const struct language_defn unknown_language_defn = {
d1467 4
a1470 4
  {"",      "",    "",   ""},	/* Binary format info */
  {"0%lo",   "0",   "o",  ""},	/* Octal format info */
  {"%ld",    "",    "d",  ""},	/* Decimal format info */
  {"0x%lx",  "0x",  "x",  ""},	/* Hex format info */
d1474 1
a1474 1
  &builtin_type_char,		/* Type of string elements */ 
d1479 2
a1480 1
const struct language_defn auto_language_defn = {
d1496 4
a1499 4
  {"",      "",    "",   ""},	/* Binary format info */
  {"0%lo",   "0",   "o",  ""},	/* Octal format info */
  {"%ld",    "",    "d",  ""},	/* Decimal format info */
  {"0x%lx",  "0x",  "x",  ""},	/* Hex format info */
d1503 1
a1503 1
  &builtin_type_char,		/* Type of string elements */ 
d1507 2
a1508 1
const struct language_defn local_language_defn = {
d1524 4
a1527 4
  {"",      "",    "",   ""},	/* Binary format info */
  {"0%lo",   "0",   "o",  ""},	/* Octal format info */
  {"%ld",    "",    "d",  ""},	/* Decimal format info */
  {"0x%lx",  "0x",  "x",  ""},	/* Hex format info */
d1531 1
a1531 1
  &builtin_type_char,		/* Type of string elements */ 
d1538 1
a1538 1
_initialize_language()
d1540 46
a1585 1
   struct cmd_list_element *set, *show;
d1587 2
a1588 1
   /* GDB commands for language specific stuff */
d1590 2
a1591 49
   set = add_set_cmd ("language", class_support, var_string_noescape,
		      (char *)&language,
		      "Set the current source language.",
		      &setlist);
   show = add_show_from_set (set, &showlist);
   set->function.cfunc = set_language_command;
   show->function.cfunc = show_language_command;

   add_prefix_cmd ("check", no_class, set_check,
		   "Set the status of the type/range checker",
		   &setchecklist, "set check ", 0, &setlist);
   add_alias_cmd ("c", "check", no_class, 1, &setlist);
   add_alias_cmd ("ch", "check", no_class, 1, &setlist);

   add_prefix_cmd ("check", no_class, show_check,
		   "Show the status of the type/range checker",
		   &showchecklist, "show check ", 0, &showlist);
   add_alias_cmd ("c", "check", no_class, 1, &showlist);
   add_alias_cmd ("ch", "check", no_class, 1, &showlist);

   set = add_set_cmd ("type", class_support, var_string_noescape,
		      (char *)&type,
		      "Set type checking.  (on/warn/off/auto)",
		      &setchecklist);
   show = add_show_from_set (set, &showchecklist);
   set->function.cfunc = set_type_command;
   show->function.cfunc = show_type_command;

   set = add_set_cmd ("range", class_support, var_string_noescape,
		      (char *)&range,
		      "Set range checking.  (on/warn/off/auto)",
		      &setchecklist);
   show = add_show_from_set (set, &showchecklist);
   set->function.cfunc = set_range_command;
   show->function.cfunc = show_range_command;

   add_language (&unknown_language_defn);
   add_language (&local_language_defn);
   add_language (&auto_language_defn);

   language = savestring ("auto",strlen("auto"));
   range = savestring ("auto",strlen("auto"));
   type = savestring ("auto",strlen("auto"));

   /* Have the above take effect */

   set_language_command (language, 0);
   set_type_command (NULL, 0);
   set_range_command (NULL, 0);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-05-25 snapshot
@
text
@a43 2
extern void _initialize_language PARAMS ((void));

@


1.1.1.3
log
@import gdb-1999-07-07 pre reformat
@
text
@d491 1
a491 1
	 return TYPE_CODE(t1) == TYPE_CODE_FLT && l1 > l2 ?
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d6 1
a6 1
   This file is part of GDB.
d8 13
a20 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d89 1
a89 1
unk_lang_emit_char PARAMS ((int c, GDB_FILE * stream, int quoter));
d92 1
a92 1
unk_lang_printchar PARAMS ((int c, GDB_FILE * stream));
d95 1
a95 1
unk_lang_printstr PARAMS ((GDB_FILE * stream, char *string, unsigned int length, int width, int force_ellipses));
d98 1
a98 1
  unk_lang_create_fundamental_type PARAMS ((struct objfile *, int));
d113 1
a113 1

d115 3
a117 3
   (If the modes are set to "auto", though, these are changed based
   on the default language at startup, and then again based on the
   language of the first source file.  */
d154 2
a155 1
"Warning: the current language does not match this frame.";
a156 1

d164 2
a165 2
     char *ignore;
     int from_tty;
d167 1
a167 1
  enum language flang;		/* The language of the current frame */
d169 5
a173 5
  flang = get_frame_language ();
  if (flang != language_unknown &&
      language_mode == language_mode_manual &&
      current_language->la_language != flang)
    printf_filtered ("%s\n", lang_frame_mismatch_warn);
d179 2
a180 2
     char *ignore;
     int from_tty;
d188 1
a188 1
      printf_unfiltered ("The currently understood settings are:\n\n");
d202 2
a203 2
	  /* Capitalize first letter of language
	     name.  */
d208 1
a208 1
      set_language (current_language->la_language);
d213 20
a232 26
  for (i = 0; i < languages_size; i++)
    {
      if (STREQ (languages[i]->la_name, language))
	{
	  /* Found it!  Go into manual mode, and use this language.  */
	  if (languages[i]->la_language == language_auto)
	    {
	      /* Enter auto mode.  Set to the current frame's language, if known.  */
	      language_mode = language_mode_auto;
	      flang = get_frame_language ();
	      if (flang != language_unknown)
		set_language (flang);
	      expected_language = current_language;
	      return;
	    }
	  else
	    {
	      /* Enter manual mode.  Set the specified language.  */
	      language_mode = language_mode_manual;
	      current_language = languages[i];
	      set_type_range ();
	      set_lang_str ();
	      expected_language = current_language;
	      return;
	    }
	}
d234 1
d238 1
a238 1
  err_lang = savestring (language, strlen (language));
d240 2
a241 2
  set_language (current_language->la_language);
  error ("Unknown language `%s'.", err_lang);
d247 7
a253 7
show_type_command (ignore, from_tty)
     char *ignore;
     int from_tty;
{
  if (type_check != current_language->la_type_check)
    printf_unfiltered (
			"Warning: the current type check setting does not match the language.\n");
d258 3
a260 3
set_type_command (ignore, from_tty)
     char *ignore;
     int from_tty;
d262 2
a263 2
  if (STREQ (type, "on"))
    {
d266 3
a268 3
    }
  else if (STREQ (type, "warn"))
    {
d271 3
a273 3
    }
  else if (STREQ (type, "off"))
    {
d276 3
a278 3
    }
  else if (STREQ (type, "auto"))
    {
d280 1
a280 1
      set_type_range ();
d284 3
a286 3
    }
  set_type_str ();
  show_type_command ((char *) NULL, from_tty);
d292 3
a294 3
show_range_command (ignore, from_tty)
     char *ignore;
     int from_tty;
d297 3
a299 3
  if (range_check != current_language->la_range_check)
    printf_unfiltered (
			"Warning: the current range check setting does not match the language.\n");
d304 3
a306 3
set_range_command (ignore, from_tty)
     char *ignore;
     int from_tty;
d308 2
a309 2
  if (STREQ (range, "on"))
    {
d312 3
a314 3
    }
  else if (STREQ (range, "warn"))
    {
d317 3
a319 3
    }
  else if (STREQ (range, "off"))
    {
d322 3
a324 3
    }
  else if (STREQ (range, "auto"))
    {
d326 1
a326 1
      set_type_range ();
d328 1
a328 1
         did it in set_type_range. */
d330 3
a332 3
    }
  set_range_str ();
  show_range_command ((char *) 0, from_tty);
d340 1
a340 1
set_type_range ()
d349 2
a350 2
  set_type_str ();
  set_range_str ();
d356 2
a357 2
set_language (lang)
     enum language lang;
d364 6
a369 9
  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->la_language == lang)
	{
	  current_language = languages[i];
	  set_type_range ();
	  set_lang_str ();
	  break;
	}
d371 1
d379 1
a379 1
set_lang_str ()
d381 1
a381 1
  char *prefix = "";
d383 3
a385 3
  free (language);
  if (language_mode == language_mode_auto)
    prefix = "auto; currently ";
d387 1
a387 1
  language = concat (prefix, current_language->la_name, NULL);
d391 1
a391 1
set_type_str ()
d393 1
a393 1
  char *tmp, *prefix = "";
d395 3
a397 3
  free (type);
  if (type_mode == type_mode_auto)
    prefix = "auto; currently ";
d399 3
a401 3
  switch (type_check)
    {
    case type_check_on:
d404 1
a404 1
    case type_check_off:
d407 1
a407 1
    case type_check_warn:
d410 1
a410 1
    default:
d412 1
a412 1
    }
d414 1
a414 1
  type = concat (prefix, tmp, NULL);
d418 1
a418 1
set_range_str ()
d420 1
a420 1
  char *tmp, *pref = "";
d422 3
a424 3
  free (range);
  if (range_mode == range_mode_auto)
    pref = "auto; currently ";
d426 3
a428 3
  switch (range_check)
    {
    case range_check_on:
d431 1
a431 1
    case range_check_off:
d434 1
a434 1
    case range_check_warn:
d437 1
a437 1
    default:
d439 1
a439 1
    }
d441 1
a441 1
  range = concat (pref, tmp, NULL);
d456 2
a457 2
  printf_unfiltered ("Current language:  %s\n", language);
  show_language_command ((char *) 0, 1);
d461 4
a464 4
      printf_unfiltered ("Type checking:     %s\n", type);
      show_type_command ((char *) 0, 1);
      printf_unfiltered ("Range checking:    %s\n", range);
      show_range_command ((char *) 0, 1);
d470 1
a470 1
#if 0				/* Currently unused */
d474 1
a474 1
     value_ptr v1, v2;
d476 23
a498 23
  int size, uns;
  struct type *t1 = check_typedef (VALUE_TYPE (v1));
  struct type *t2 = check_typedef (VALUE_TYPE (v2));

  int l1 = TYPE_LENGTH (t1);
  int l2 = TYPE_LENGTH (t2);

  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
      if (TYPE_CODE (t1) == TYPE_CODE_FLT)
	return TYPE_CODE (t2) == TYPE_CODE_FLT && l2 > l1 ?
	  VALUE_TYPE (v2) : VALUE_TYPE (v1);
      else if (TYPE_CODE (t2) == TYPE_CODE_FLT)
	return TYPE_CODE (t1) == TYPE_CODE_FLT && l1 > l2 ?
	  VALUE_TYPE (v1) : VALUE_TYPE (v2);
      else if (TYPE_UNSIGNED (t1) && l1 > l2)
	return VALUE_TYPE (v1);
      else if (TYPE_UNSIGNED (t2) && l2 > l1)
	return VALUE_TYPE (v2);
      else			/* Both are signed.  Result is the longer type */
	return l1 > l2 ? VALUE_TYPE (v1) : VALUE_TYPE (v2);
d500 1
a500 1
    case language_m2:
d502 2
a503 2
         not needed. */
      return l1 > l2 ? VALUE_TYPE (v1) : VALUE_TYPE (v2);
d505 5
a509 5
    case language_chill:
      error ("Missing Chill support in function binop_result_check.");	/*FIXME */
    }
  abort ();
  return (struct type *) 0;	/* For lint */
d512 2
a513 1
#endif /* 0 */
a514 1

d521 2
a522 2
local_hex_format_custom (pre)
     char *pre;
d524 1
a524 1
  static char form[50];
d526 6
a531 6
  strcpy (form, local_hex_format_prefix ());
  strcat (form, "%");
  strcat (form, pre);
  strcat (form, local_hex_format_specifier ());
  strcat (form, local_hex_format_suffix ());
  return form;
d538 1
a538 1
     unsigned long num;
d540 1
a540 1
  static char res[50];
d542 2
a543 2
  sprintf (res, local_hex_format (), num);
  return res;
d549 3
a551 3
local_hex_string_custom (num, pre)
     unsigned long num;
     char *pre;
d553 1
a553 1
  static char res[50];
d555 2
a556 2
  sprintf (res, local_hex_format_custom (pre), num);
  return res;
d562 2
a563 2
local_octal_format_custom (pre)
     char *pre;
d565 1
a565 1
  static char form[50];
d567 6
a572 6
  strcpy (form, local_octal_format_prefix ());
  strcat (form, "%");
  strcat (form, pre);
  strcat (form, local_octal_format_specifier ());
  strcat (form, local_octal_format_suffix ());
  return form;
d577 2
a578 2
local_decimal_format_custom (pre)
     char *pre;
d580 1
a580 1
  static char form[50];
d582 6
a587 6
  strcpy (form, local_decimal_format_prefix ());
  strcat (form, "%");
  strcat (form, pre);
  strcat (form, local_decimal_format_specifier ());
  strcat (form, local_decimal_format_suffix ());
  return form;
d609 2
a610 2
simple_type (type)
     struct type *type;
d613 8
a620 9
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_FLT:
    case TYPE_CODE_RANGE:
    case TYPE_CODE_BOOL:
      return 1;
d622 3
a624 3
    default:
      return 0;
    }
d633 1
a633 1
     struct type *type;
d636 7
a642 8
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_FLT:
    case TYPE_CODE_RANGE:
      return 1;
d644 3
a646 3
    default:
      return 0;
    }
d652 1
a652 1
     struct type *arg1, *arg2;
d655 11
a665 11
  if (structured_type (arg1) ? !structured_type (arg2) : structured_type (arg2))
    /* One is structured and one isn't */
    return 0;
  else if (structured_type (arg1) && structured_type (arg2))
    return arg1 == arg2;
  else if (numeric_type (arg1) && numeric_type (arg2))
    return (TYPE_CODE (arg2) == TYPE_CODE (arg1)) &&
      (TYPE_UNSIGNED (arg1) == TYPE_UNSIGNED (arg2))
      ? 1 : 0;
  else
    return arg1 == arg2;
d671 1
a671 1
     struct type *type;
d674 11
a684 11
  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
      return (TYPE_CODE (type) != TYPE_CODE_INT) &&
	(TYPE_CODE (type) != TYPE_CODE_ENUM) ? 0 : 1;
    case language_m2:
      return TYPE_CODE (type) != TYPE_CODE_INT ? 0 : 1;
    case language_chill:
      error ("Missing Chill support in function integral_type.");	/*FIXME */
    default:
d686 1
a686 1
    }
d692 1
a692 1
     struct type *type;
d695 4
a698 5
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_FLT:
      return 1;
d700 3
a702 3
    default:
      return 0;
    }
d708 1
a708 1
     struct type *type;
d711 12
a722 12
  switch (current_language->la_language)
    {
    case language_chill:
    case language_m2:
      return TYPE_CODE (type) != TYPE_CODE_CHAR ? 0 : 1;

    case language_c:
    case language_cplus:
      return (TYPE_CODE (type) == TYPE_CODE_INT) &&
	TYPE_LENGTH (type) == sizeof (char)
      ? 1 : 0;
    default:
d724 1
a724 1
    }
d730 1
a730 1
     struct type *type;
d733 5
a737 5
  switch (current_language->la_language)
    {
    case language_chill:
    case language_m2:
      return TYPE_CODE (type) != TYPE_CODE_STRING ? 0 : 1;
d739 2
a740 2
    case language_c:
    case language_cplus:
d743 1
a743 1
    default:
d745 1
a745 1
    }
d751 1
a751 1
     struct type *type;
d756 1
a756 1
  switch (current_language->la_language)
d761 1
a761 1
         for CHILL and such languages, or a TYPE_CODE_INT_OR_BOOL for C.  */
d764 1
a764 1
    default:
d766 1
a766 1
    }
d773 1
a773 1
     struct type *type;
d776 1
a776 1
  return TYPE_CODE (type) == TYPE_CODE_FLT;
d781 2
a782 2
pointer_type (type)
     struct type *type;
d784 2
a785 2
  return TYPE_CODE (type) == TYPE_CODE_PTR ||
    TYPE_CODE (type) == TYPE_CODE_REF;
d790 2
a791 2
structured_type (type)
     struct type *type;
d794 14
a807 14
  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
      return (TYPE_CODE (type) == TYPE_CODE_STRUCT) ||
	(TYPE_CODE (type) == TYPE_CODE_UNION) ||
	(TYPE_CODE (type) == TYPE_CODE_ARRAY);
    case language_m2:
      return (TYPE_CODE (type) == TYPE_CODE_STRUCT) ||
	(TYPE_CODE (type) == TYPE_CODE_SET) ||
	(TYPE_CODE (type) == TYPE_CODE_ARRAY);
    case language_chill:
      error ("Missing Chill support in function structured_type.");	/*FIXME */
    default:
d809 1
a809 1
    }
d818 1
a818 1
  switch (current_language->la_language)
d865 1
a865 1
#if 0				/* Currently unused */
d868 3
a870 3
binop_type_check (arg1, arg2, op)
     value_ptr arg1, arg2;
     int op;
d872 36
a907 1
  struct type *t1, *t2;
d909 21
a929 3
  /* If we're not checking types, always return success. */
  if (!STRICT_TYPE)
    return;
d931 9
a939 5
  t1 = VALUE_TYPE (arg1);
  if (arg2 != NULL)
    t2 = VALUE_TYPE (arg2);
  else
    t2 = NULL;
d941 12
a952 69
  switch (op)
    {
    case BINOP_ADD:
    case BINOP_SUB:
      if ((numeric_type (t1) && pointer_type (t2)) ||
	  (pointer_type (t1) && numeric_type (t2)))
	{
	  warning ("combining pointer and integer.\n");
	  break;
	}
    case BINOP_MUL:
    case BINOP_LSH:
    case BINOP_RSH:
      if (!numeric_type (t1) || !numeric_type (t2))
	type_op_error ("Arguments to %s must be numbers.", op);
      else if (!same_type (t1, t2))
	type_op_error ("Arguments to %s must be of the same type.", op);
      break;

    case BINOP_LOGICAL_AND:
    case BINOP_LOGICAL_OR:
      if (!boolean_type (t1) || !boolean_type (t2))
	type_op_error ("Arguments to %s must be of boolean type.", op);
      break;

    case BINOP_EQUAL:
      if ((pointer_type (t1) && !(pointer_type (t2) || integral_type (t2))) ||
	  (pointer_type (t2) && !(pointer_type (t1) || integral_type (t1))))
	type_op_error ("A pointer can only be compared to an integer or pointer.", op);
      else if ((pointer_type (t1) && integral_type (t2)) ||
	       (integral_type (t1) && pointer_type (t2)))
	{
	  warning ("combining integer and pointer.\n");
	  break;
	}
      else if (!simple_type (t1) || !simple_type (t2))
	type_op_error ("Arguments to %s must be of simple type.", op);
      else if (!same_type (t1, t2))
	type_op_error ("Arguments to %s must be of the same type.", op);
      break;

    case BINOP_REM:
    case BINOP_MOD:
      if (!integral_type (t1) || !integral_type (t2))
	type_op_error ("Arguments to %s must be of integral type.", op);
      break;

    case BINOP_LESS:
    case BINOP_GTR:
    case BINOP_LEQ:
    case BINOP_GEQ:
      if (!ordered_type (t1) || !ordered_type (t2))
	type_op_error ("Arguments to %s must be of ordered type.", op);
      else if (!same_type (t1, t2))
	type_op_error ("Arguments to %s must be of the same type.", op);
      break;

    case BINOP_ASSIGN:
      if (pointer_type (t1) && !integral_type (t2))
	type_op_error ("A pointer can only be assigned an integer.", op);
      else if (pointer_type (t1) && integral_type (t2))
	{
	  warning ("combining integer and pointer.");
	  break;
	}
      else if (!simple_type (t1) || !simple_type (t2))
	type_op_error ("Arguments to %s must be of simple type.", op);
      else if (!same_type (t1, t2))
	type_op_error ("Arguments to %s must be of the same type.", op);
d957 3
a959 3
      if (!(string_type (t1) || character_type (t1) || integral_type (t1))
	|| !(string_type (t2) || character_type (t2) || integral_type (t2)))
	type_op_error ("Arguments to %s must be strings or characters.", op);
d962 1
a962 1
      /* Unary checks -- arg2 is null */
d964 3
a966 3
    case UNOP_LOGICAL_NOT:
      if (!boolean_type (t1))
	type_op_error ("Argument to %s must be of boolean type.", op);
d969 4
a972 4
    case UNOP_PLUS:
    case UNOP_NEG:
      if (!numeric_type (t1))
	type_op_error ("Argument to %s must be of numeric type.", op);
d975 8
a982 8
    case UNOP_IND:
      if (integral_type (t1))
	{
	  warning ("combining pointer and integer.\n");
	  break;
	}
      else if (!pointer_type (t1))
	type_op_error ("Argument to %s must be a pointer.", op);
d985 6
a990 6
    case UNOP_PREINCREMENT:
    case UNOP_POSTINCREMENT:
    case UNOP_PREDECREMENT:
    case UNOP_POSTDECREMENT:
      if (!ordered_type (t1))
	type_op_error ("Argument to %s must be of an ordered type.", op);
d993 1
a993 1
    default:
d995 3
a997 3
         different languages. */
      switch (current_language->la_language)
	{
d999 10
a1008 10
	case language_c:
	case language_cplus:
	  switch (op)
	    {
	    case BINOP_DIV:
	      if (!numeric_type (t1) || !numeric_type (t2))
		type_op_error ("Arguments to %s must be numbers.", op);
	      break;
	    }
	  break;
d1012 12
a1023 12
	case language_m2:
	  switch (op)
	    {
	    case BINOP_DIV:
	      if (!float_type (t1) || !float_type (t2))
		type_op_error ("Arguments to %s must be floating point numbers.", op);
	      break;
	    case BINOP_INTDIV:
	      if (!integral_type (t1) || !integral_type (t2))
		type_op_error ("Arguments to %s must be of integral type.", op);
	      break;
	    }
d1027 2
a1028 2
	case language_chill:
	  error ("Missing Chill support in function binop_type_check.");	/*FIXME */
d1031 2
a1032 2
	}
    }
d1035 2
a1036 1
#endif /* 0 */
a1037 1

d1047 11
a1057 11
op_error (fmt, op, fatal)
     char *fmt;
     enum exp_opcode op;
     int fatal;
{
  if (fatal)
    error (fmt, op_string (op));
  else
    {
      warning (fmt, op_string (op));
    }
d1069 1
a1069 1
type_error (char *string,...)
d1075 1
a1075 1
  va_list args;
d1077 1
a1077 1
  va_start (args, string);
d1079 3
a1081 3
  char *string;
  va_start (args);
  string = va_arg (args, char *);
d1084 10
a1093 10
  if (type_check == type_check_warn)
    fprintf_filtered (gdb_stderr, warning_pre_print);
  else
    error_begin ();

  vfprintf_filtered (gdb_stderr, string, args);
  fprintf_filtered (gdb_stderr, "\n");
  va_end (args);
  if (type_check == type_check_on)
    return_to_top_level (RETURN_ERROR);
d1098 1
a1098 1
range_error (char *string,...)
d1104 1
a1104 1
  va_list args;
d1106 1
a1106 1
  va_start (args, string);
d1108 3
a1110 3
  char *string;
  va_start (args);
  string = va_arg (args, char *);
d1113 10
a1122 10
  if (range_check == range_check_warn)
    fprintf_filtered (gdb_stderr, warning_pre_print);
  else
    error_begin ();

  vfprintf_filtered (gdb_stderr, string, args);
  fprintf_filtered (gdb_stderr, "\n");
  va_end (args);
  if (range_check == range_check_on)
    return_to_top_level (RETURN_ERROR);
d1124 1
a1125 1

d1136 1
a1136 1
  for (i = 0; i < languages_size; i++)
d1146 2
a1147 2
language_def (lang)
     enum language lang;
d1151 3
a1153 6
  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->la_language == lang)
	{
	  return languages[i];
	}
d1155 1
d1161 2
a1162 2
language_str (lang)
     enum language lang;
d1166 3
a1168 6
  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->la_language == lang)
	{
	  return languages[i]->la_name;
	}
d1170 1
d1176 2
a1177 2
     char *ignore;
     int from_tty;
d1179 3
a1181 3
  printf_unfiltered (
     "\"set check\" must be followed by the name of a check subcommand.\n");
  help_list (setchecklist, "set check ", -1, gdb_stdout);
d1186 2
a1187 2
     char *ignore;
     int from_tty;
d1189 1
a1189 1
  cmd_show_list (showchecklist, from_tty, "");
d1200 3
a1202 3
      fprintf_unfiltered (gdb_stderr, "Magic number of %s language struct wrong\n",
			  lang->la_name);
      abort ();
d1215 1
a1215 1
				 languages_allocsize * sizeof (*languages));
d1283 1
a1283 1
unk_lang_val_print (type, valaddr, embedded_offset, address, stream, format, deref_ref,
d1308 3
a1310 7
static struct type **CONST_PTR (unknown_builtin_types[]) =
{
  0
};
static const struct op_print unk_op_print_tab[] =
{
  {NULL, OP_NULL, PREC_NULL, 0}
d1313 1
a1313 2
const struct language_defn unknown_language_defn =
{
d1329 4
a1332 4
  {"", "", "", ""},		/* Binary format info */
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
d1336 1
a1336 1
  &builtin_type_char,		/* Type of string elements */
d1341 1
a1341 2
const struct language_defn auto_language_defn =
{
d1357 4
a1360 4
  {"", "", "", ""},		/* Binary format info */
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
d1364 1
a1364 1
  &builtin_type_char,		/* Type of string elements */
d1368 1
a1368 2
const struct language_defn local_language_defn =
{
d1384 4
a1387 4
  {"", "", "", ""},		/* Binary format info */
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
d1391 1
a1391 1
  &builtin_type_char,		/* Type of string elements */
d1398 1
a1398 1
_initialize_language ()
d1400 1
a1400 1
  struct cmd_list_element *set, *show;
d1402 1
a1402 1
  /* GDB commands for language specific stuff */
d1404 49
a1452 49
  set = add_set_cmd ("language", class_support, var_string_noescape,
		     (char *) &language,
		     "Set the current source language.",
		     &setlist);
  show = add_show_from_set (set, &showlist);
  set->function.cfunc = set_language_command;
  show->function.cfunc = show_language_command;

  add_prefix_cmd ("check", no_class, set_check,
		  "Set the status of the type/range checker",
		  &setchecklist, "set check ", 0, &setlist);
  add_alias_cmd ("c", "check", no_class, 1, &setlist);
  add_alias_cmd ("ch", "check", no_class, 1, &setlist);

  add_prefix_cmd ("check", no_class, show_check,
		  "Show the status of the type/range checker",
		  &showchecklist, "show check ", 0, &showlist);
  add_alias_cmd ("c", "check", no_class, 1, &showlist);
  add_alias_cmd ("ch", "check", no_class, 1, &showlist);

  set = add_set_cmd ("type", class_support, var_string_noescape,
		     (char *) &type,
		     "Set type checking.  (on/warn/off/auto)",
		     &setchecklist);
  show = add_show_from_set (set, &showchecklist);
  set->function.cfunc = set_type_command;
  show->function.cfunc = show_type_command;

  set = add_set_cmd ("range", class_support, var_string_noescape,
		     (char *) &range,
		     "Set range checking.  (on/warn/off/auto)",
		     &setchecklist);
  show = add_show_from_set (set, &showchecklist);
  set->function.cfunc = set_range_command;
  show->function.cfunc = show_range_command;

  add_language (&unknown_language_defn);
  add_language (&local_language_defn);
  add_language (&auto_language_defn);

  language = savestring ("auto", strlen ("auto"));
  range = savestring ("auto", strlen ("auto"));
  type = savestring ("auto", strlen ("auto"));

  /* Have the above take effect */

  set_language_command (language, 0);
  set_type_command (NULL, 0);
  set_range_command (NULL, 0);
@


1.1.1.5
log
@import gdb-1999-08-09 snapshot
@
text
@d1079 1
d1081 4
d1087 1
d1089 5
d1108 1
d1110 4
d1116 1
d1118 5
@


1.1.1.6
log
@import gdb-1999-12-13 snapshot
@
text
@a290 4
  else
    {
      warning ("Unrecognized type check setting: \"%s\"", type);
    }
a336 4
  else
    {
      warning ("Unrecognized range check setting: \"%s\"", range);
    }
d401 1
a401 1
  char *tmp = NULL, *prefix = "";
d430 1
a448 1
  free (range);
a541 18
/* Converts a number to hexadecimal (without leading "0x") and stores it in a
   static string.  Returns a pointer to this string. */

char *
longest_raw_hex_string (num)
     LONGEST num;
{
  static char res_longest_raw_hex_string[50];
  long long ll = num;		/* MERGEBUG ?? see below */
  res_longest_raw_hex_string[0] = 0;
  /* MERGEBUG ?? As a quick fix I am replacing this with sprintf 
     strcat_address_numeric (num, 0, res_longest_raw_hex_string, 50); 
   */

  sprintf (res_longest_raw_hex_string, "%llx", ll);
  return res_longest_raw_hex_string;
}

a553 9
/* Converts a LONGEST number to hexadecimal and stores it in a static
   string.  Returns a pointer to this string. */
char *
longest_local_hex_string (num)
     LONGEST num;
{
  return longest_local_hex_string_custom (num, "l");
}

a565 101

/* Converts a LONGEST number to custom hexadecimal and stores it in a static
   string.  Returns a pointer to this string. Note that the width parameter
   should end with "l", e.g. "08l" as with calls to local_hex_string_custom */

char *
longest_local_hex_string_custom (num, width)
     LONGEST num;
     char *width;
{
#define RESULT_BUF_LEN 50
  static char res2[RESULT_BUF_LEN];
  char format[RESULT_BUF_LEN];
#if !defined (PRINTF_HAS_LONG_LONG)
  int field_width;
  int num_len;
  int num_pad_chars;
  char *pad_char;		/* string with one character */
  int pad_on_left;
  char *parse_ptr;
  char temp_nbr_buf[RESULT_BUF_LEN];
#endif

#ifndef CC_HAS_LONG_LONG
  /* If there is no long long, then LONGEST should be just long and we
     can use local_hex_string_custom 
   */
  return local_hex_string_custom ((unsigned long) num, width);
#endif

#if defined (PRINTF_HAS_LONG_LONG)
  /* Just use printf.  */
  strcpy (format, local_hex_format_prefix ());	/* 0x */
  strcat (format, "%");
  strcat (format, width);	/* e.g. "08l" */
  strcat (format, "l");		/* need "ll" for long long */
  strcat (format, local_hex_format_specifier ());	/* "x" */
  strcat (format, local_hex_format_suffix ());	/* "" */
  sprintf (res2, format, num);
  return res2;
#else /* !defined (PRINTF_HAS_LONG_LONG) */
  /* Use strcat_address_numeric to print the number into a string, then
     build the result string from local_hex_format_prefix, padding and 
     the hex representation as indicated by "width".  */

  temp_nbr_buf[0] = 0;
  /* With use_local == 0, we don't get the leading "0x" prefix. */
  /* MERGEBUG ?? As a quick fix I am replacing this call to
     strcat_address_numeric with sprintf
     strcat_address_numeric(num, 0, temp_nbr_buf, RESULT_BUF_LEN);
   */

  {
    long long ll = num;
    sprintf (temp_nbr_buf, "%llx", ll);
  }
  /* parse width */
  parse_ptr = width;
  pad_on_left = 1;
  pad_char = " ";
  if (*parse_ptr == '-')
    {
      parse_ptr++;
      pad_on_left = 0;
    }
  if (*parse_ptr == '0')
    {
      parse_ptr++;
      if (pad_on_left)
	pad_char = "0";		/* If padding is on the right, it is blank */
    }
  field_width = atoi (parse_ptr);
  num_len = strlen (temp_nbr_buf);
  num_pad_chars = field_width - strlen (temp_nbr_buf);	/* possibly negative */

  if (strlen (local_hex_format_prefix ()) + num_len + num_pad_chars
      < RESULT_BUF_LEN)		/* paranoia */
    internal_error ("longest_local_hex_string_custom: insufficient space to store result");

  strcpy (res2, local_hex_format_prefix ());
  if (pad_on_left)
    {
      while (num_pad_chars > 0)
	{
	  strcat (res2, pad_char);
	  num_pad_chars--;
	}
    }
  strcat (res2, temp_nbr_buf);
  if (!pad_on_left)
    {
      while (num_pad_chars > 0)
	{
	  strcat (res2, pad_char);
	  num_pad_chars--;
	}
    }
  return res2;
#endif

}				/* longest_local_hex_string_custom */
@


1.1.1.7
log
@import gdb-1999-12-21 snapshot
@
text
@d1581 5
a1586 2

  type = savestring ("auto", strlen ("auto"));
a1587 2

  range = savestring ("auto", strlen ("auto"));
@


1.1.1.8
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 2000 Free Software Foundation, Inc.
d89 2
a90 1
static void unk_lang_emit_char (int c, struct ui_file *stream, int quoter);
d92 2
a93 1
static void unk_lang_printchar (int c, struct ui_file *stream);
d95 2
a96 3
static void unk_lang_printstr (struct ui_file * stream, char *string,
			       unsigned int length, int width,
			       int force_ellipses);
d101 2
a102 2
static void unk_lang_print_type (struct type *, char *, struct ui_file *,
				 int, int);
d104 3
a106 3
static int unk_lang_val_print (struct type *, char *, int, CORE_ADDR,
			       struct ui_file *, int, int, int,
			       enum val_prettyprint);
d108 2
a109 1
static int unk_lang_value_print (value_ptr, struct ui_file *, int, enum val_prettyprint);
d1367 1
a1367 1
     struct ui_file *stream;
d1376 1
a1376 1
     struct ui_file *stream;
d1383 1
a1383 1
     struct ui_file *stream;
d1404 1
a1404 1
     struct ui_file *stream;
d1418 1
a1418 1
     struct ui_file *stream;
d1430 1
a1430 1
     struct ui_file *stream;
@


