head	1.30;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.30
	gdb_7_6-2013-04-26-release:1.30
	gdb_7_6-branch:1.30.0.2
	gdb_7_6-2013-03-12-branchpoint:1.30
	gdb_7_5_1-2012-11-29-release:1.27
	gdb_7_5-2012-08-17-release:1.27
	gdb_7_5-branch:1.27.0.2
	gdb_7_5-2012-07-18-branchpoint:1.27
	gdb_7_4_1-2012-04-26-release:1.25.2.1
	gdb_7_4-2012-01-24-release:1.25.2.1
	gdb_7_4-branch:1.25.0.2
	gdb_7_4-2011-12-13-branchpoint:1.25
	gdb_7_3_1-2011-09-04-release:1.24
	gdb_7_3-2011-07-26-release:1.24
	gdb_7_3-branch:1.24.0.2
	gdb_7_3-2011-04-01-branchpoint:1.24
	gdb_7_2-2010-09-02-release:1.20
	gdb_7_2-branch:1.20.0.2
	gdb_7_2-2010-07-07-branchpoint:1.20
	gdb_7_1-2010-03-18-release:1.19
	gdb_7_1-branch:1.19.0.2
	gdb_7_1-2010-02-18-branchpoint:1.19
	gdb_7_0_1-2009-12-22-release:1.18
	gdb_7_0-2009-10-06-release:1.18
	gdb_7_0-branch:1.18.0.4
	gdb_7_0-2009-09-16-branchpoint:1.18
	arc-sim-20090309:1.15
	msnyder-checkpoint-072509-branch:1.18.0.2
	msnyder-checkpoint-072509-branchpoint:1.18
	arc-insight_6_8-branch:1.15.0.10
	arc-insight_6_8-branchpoint:1.15
	insight_6_8-branch:1.15.0.8
	insight_6_8-branchpoint:1.15
	reverse-20081226-branch:1.17.0.6
	reverse-20081226-branchpoint:1.17
	multiprocess-20081120-branch:1.17.0.4
	multiprocess-20081120-branchpoint:1.17
	reverse-20080930-branch:1.17.0.2
	reverse-20080930-branchpoint:1.17
	reverse-20080717-branch:1.15.0.6
	reverse-20080717-branchpoint:1.15
	msnyder-reverse-20080609-branch:1.15.0.4
	msnyder-reverse-20080609-branchpoint:1.15
	drow-reverse-20070409-branch:1.12.0.2
	drow-reverse-20070409-branchpoint:1.12
	gdb_6_8-2008-03-27-release:1.15
	gdb_6_8-branch:1.15.0.2
	gdb_6_8-2008-02-26-branchpoint:1.15
	gdb_6_7_1-2007-10-29-release:1.13
	gdb_6_7-2007-10-10-release:1.13
	gdb_6_7-branch:1.13.0.2
	gdb_6_7-2007-09-07-branchpoint:1.13
	insight_6_6-20070208-release:1.11
	gdb_6_6-2006-12-18-release:1.11
	gdb_6_6-branch:1.11.0.18
	gdb_6_6-2006-11-15-branchpoint:1.11
	insight_6_5-20061003-release:1.11
	gdb-csl-symbian-6_4_50_20060226-12:1.11
	gdb-csl-sourcerygxx-3_4_4-25:1.10
	nickrob-async-20060828-mergepoint:1.11
	gdb-csl-symbian-6_4_50_20060226-11:1.11
	gdb-csl-sourcerygxx-4_1-17:1.11
	gdb-csl-20060226-branch-local-2:1.11
	gdb-csl-sourcerygxx-4_1-14:1.11
	gdb-csl-sourcerygxx-4_1-13:1.11
	gdb-csl-sourcerygxx-4_1-12:1.11
	gdb-csl-sourcerygxx-3_4_4-21:1.11
	gdb_6_5-20060621-release:1.11
	gdb-csl-sourcerygxx-4_1-9:1.11
	gdb-csl-sourcerygxx-4_1-8:1.11
	gdb-csl-sourcerygxx-4_1-7:1.11
	gdb-csl-arm-2006q1-6:1.11
	gdb-csl-sourcerygxx-4_1-6:1.11
	gdb-csl-symbian-6_4_50_20060226-10:1.11
	gdb-csl-symbian-6_4_50_20060226-9:1.11
	gdb-csl-symbian-6_4_50_20060226-8:1.11
	gdb-csl-coldfire-4_1-11:1.11
	gdb-csl-sourcerygxx-3_4_4-19:1.11
	gdb-csl-coldfire-4_1-10:1.11
	gdb_6_5-branch:1.11.0.16
	gdb_6_5-2006-05-14-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-5:1.11
	nickrob-async-20060513-branch:1.11.0.14
	nickrob-async-20060513-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-4:1.11
	msnyder-reverse-20060502-branch:1.11.0.12
	msnyder-reverse-20060502-branchpoint:1.11
	gdb-csl-morpho-4_1-4:1.11
	gdb-csl-sourcerygxx-3_4_4-17:1.11
	readline_5_1-import-branch:1.11.0.10
	readline_5_1-import-branchpoint:1.11
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.11
	gdb-csl-symbian-20060226-branch:1.11.0.8
	gdb-csl-symbian-20060226-branchpoint:1.11
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.11
	msnyder-reverse-20060331-branch:1.11.0.6
	msnyder-reverse-20060331-branchpoint:1.11
	gdb-csl-available-20060303-branch:1.11.0.4
	gdb-csl-available-20060303-branchpoint:1.11
	gdb-csl-20060226-branch:1.11.0.2
	gdb-csl-20060226-branchpoint:1.11
	gdb_6_4-20051202-release:1.10
	msnyder-fork-checkpoint-branch:1.10.0.12
	msnyder-fork-checkpoint-branchpoint:1.10
	gdb-csl-gxxpro-6_3-branch:1.10.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.10
	gdb_6_4-branch:1.10.0.8
	gdb_6_4-2005-11-01-branchpoint:1.10
	gdb-csl-arm-20051020-branch:1.10.0.6
	gdb-csl-arm-20051020-branchpoint:1.10
	msnyder-tracepoint-checkpoint-branch:1.10.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.10
	gdb-csl-arm-20050325-2005-q1b:1.10
	gdb-csl-arm-20050325-2005-q1a:1.10
	csl-arm-20050325-branch:1.10.0.2
	csl-arm-20050325-branchpoint:1.10
	gdb-post-i18n-errorwarning-20050211:1.9
	gdb-pre-i18n-errorwarning-20050211:1.9
	gdb_6_3-20041109-release:1.9
	gdb_6_3-branch:1.9.0.16
	gdb_6_3-20041019-branchpoint:1.9
	drow_intercu-merge-20040921:1.9
	drow_intercu-merge-20040915:1.9
	jimb-gdb_6_2-e500-branch:1.9.0.18
	jimb-gdb_6_2-e500-branchpoint:1.9
	gdb_6_2-20040730-release:1.9
	gdb_6_2-branch:1.9.0.14
	gdb_6_2-2004-07-10-gmt-branchpoint:1.9
	gdb_6_1_1-20040616-release:1.9
	gdb_6_1-2004-04-05-release:1.9
	drow_intercu-merge-20040402:1.9
	drow_intercu-merge-20040327:1.9
	ezannoni_pie-20040323-branch:1.9.0.12
	ezannoni_pie-20040323-branchpoint:1.9
	cagney_tramp-20040321-mergepoint:1.9
	cagney_tramp-20040309-branch:1.9.0.10
	cagney_tramp-20040309-branchpoint:1.9
	gdb_6_1-branch:1.9.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.9
	drow_intercu-20040221-branch:1.9.0.6
	drow_intercu-20040221-branchpoint:1.9
	cagney_bfdfile-20040213-branch:1.9.0.4
	cagney_bfdfile-20040213-branchpoint:1.9
	drow-cplus-merge-20040208:1.9
	carlton_dictionary-20040126-merge:1.9
	cagney_bigcore-20040122-branch:1.9.0.2
	cagney_bigcore-20040122-branchpoint:1.9
	drow-cplus-merge-20040113:1.9
	drow-cplus-merge-20031224:1.9
	drow-cplus-merge-20031220:1.9
	carlton_dictionary-20031215-merge:1.9
	drow-cplus-merge-20031214:1.9
	carlton-dictionary-20031111-merge:1.9
	gdb_6_0-2003-10-04-release:1.8
	kettenis_sparc-20030918-branch:1.8.0.10
	kettenis_sparc-20030918-branchpoint:1.8
	carlton_dictionary-20030917-merge:1.8
	ezannoni_pie-20030916-branchpoint:1.8
	ezannoni_pie-20030916-branch:1.8.0.8
	cagney_x86i386-20030821-branch:1.8.0.6
	cagney_x86i386-20030821-branchpoint:1.8
	carlton_dictionary-20030805-merge:1.8
	carlton_dictionary-20030627-merge:1.8
	gdb_6_0-branch:1.8.0.4
	gdb_6_0-2003-06-23-branchpoint:1.8
	jimb-ppc64-linux-20030613-branch:1.8.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.8
	cagney_convert-20030606-branch:1.7.0.30
	cagney_convert-20030606-branchpoint:1.7
	cagney_writestrings-20030508-branch:1.7.0.28
	cagney_writestrings-20030508-branchpoint:1.7
	jimb-ppc64-linux-20030528-branch:1.7.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.7
	carlton_dictionary-20030523-merge:1.7
	cagney_fileio-20030521-branch:1.7.0.24
	cagney_fileio-20030521-branchpoint:1.7
	kettenis_i386newframe-20030517-mergepoint:1.7
	jimb-ppc64-linux-20030509-branch:1.7.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.7
	kettenis_i386newframe-20030504-mergepoint:1.7
	carlton_dictionary-20030430-merge:1.7
	kettenis_i386newframe-20030419-branch:1.7.0.20
	kettenis_i386newframe-20030419-branchpoint:1.7
	carlton_dictionary-20030416-merge:1.7
	cagney_frameaddr-20030409-mergepoint:1.7
	kettenis_i386newframe-20030406-branch:1.7.0.18
	kettenis_i386newframe-20030406-branchpoint:1.7
	cagney_frameaddr-20030403-branchpoint:1.7
	cagney_frameaddr-20030403-branch:1.7.0.16
	cagney_framebase-20030330-mergepoint:1.7
	cagney_framebase-20030326-branch:1.7.0.14
	cagney_framebase-20030326-branchpoint:1.7
	cagney_lazyid-20030317-branch:1.7.0.12
	cagney_lazyid-20030317-branchpoint:1.7
	kettenis-i386newframe-20030316-mergepoint:1.7
	offbyone-20030313-branch:1.7.0.10
	offbyone-20030313-branchpoint:1.7
	kettenis-i386newframe-20030308-branch:1.7.0.8
	kettenis-i386newframe-20030308-branchpoint:1.7
	carlton_dictionary-20030305-merge:1.7
	cagney_offbyone-20030303-branch:1.7.0.6
	cagney_offbyone-20030303-branchpoint:1.7
	carlton_dictionary-20030207-merge:1.7
	interps-20030203-mergepoint:1.7
	interps-20030202-branch:1.7.0.4
	interps-20030202-branchpoint:1.7
	cagney-unwind-20030108-branch:1.7.0.2
	cagney-unwind-20030108-branchpoint:1.7
	carlton_dictionary-20021223-merge:1.7
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.6
	kseitz_interps-20021105-merge:1.6
	kseitz_interps-20021103-merge:1.6
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.10
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.8
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.6
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.4
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.2
	readline_4_3-import-branchpoint:1.5
	kseitz_interps-20020528-branch:1.4.0.2
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.3.0.2
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.30
date	2013.02.03.16.25.55;	author jkratoch;	state Exp;
branches;
next	1.29;

1.29
date	2013.01.01.06.32.47;	author brobecke;	state Exp;
branches;
next	1.28;

1.28
date	2012.07.25.15.32.09;	author tromey;	state Exp;
branches;
next	1.27;

1.27
date	2012.05.16.20.31.09;	author tromey;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.04.08.17.06;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.21.15.13.29;	author ratmice;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2011.03.23.18.23.54;	author ktietz;	state Exp;
branches;
next	1.23;

1.23
date	2011.01.09.03.20.33;	author msnyder;	state Exp;
branches;
next	1.22;

1.22
date	2011.01.05.22.22.49;	author msnyder;	state Exp;
branches;
next	1.21;

1.21
date	2011.01.01.15.33.10;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2010.05.16.00.18.02;	author msnyder;	state Exp;
branches;
next	1.19;

1.19
date	2010.01.01.07.31.37;	author brobecke;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2008.09.30.17.21.27;	author tromey;	state Exp;
branches;
next	1.16;

1.16
date	2008.07.18.20.55.32;	author tromey;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.22.01.09.19;	author jimb;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.09.17.58.52;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.11.18.13.51;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.19.21.51.32;	author jimb;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.08.18.27.14;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.17.00.39.07;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.25.22.25.55;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.29.22.55.26;	author cagney;	state Exp;
branches
	1.5.8.1
	1.5.10.1;
next	1.4;

1.4
date	2002.05.23.23.27.42;	author jimb;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2002.05.14.21.31.05;	author jimb;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2002.05.13.18.13.07;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.08.18.26.26;	author jimb;	state dead;
branches
	1.1.2.1;
next	;

1.25.2.1
date	2012.01.06.04.43.20;	author brobecke;	state Exp;
branches;
next	;

1.5.8.1
date	2002.11.15.19.18.50;	author carlton;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2002.12.23.19.38.33;	author carlton;	state Exp;
branches;
next	1.5.8.3;

1.5.8.3
date	2003.06.27.21.50.05;	author carlton;	state Exp;
branches;
next	1.5.8.4;

1.5.8.4
date	2003.11.11.23.50.49;	author carlton;	state Exp;
branches;
next	;

1.5.10.1
date	2003.12.14.20.27.21;	author drow;	state Exp;
branches;
next	;

1.4.2.1
date	2002.08.09.18.34.25;	author kseitz;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.11.04.00.17.32;	author ezannoni;	state Exp;
branches;
next	;

1.3.2.1
date	2002.06.15.16.42.52;	author cagney;	state Exp;
branches;
next	;

1.1.2.1
date	2002.05.08.18.26.26;	author jimb;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.05.09.15.04.42;	author jimb;	state dead;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.05.09.15.18.33;	author jimb;	state Exp;
branches;
next	;


desc
@@


1.30
log
@gdb/
	* dwarf2read.c (file_file_name): New function with code from
	file_full_name.
	(file_full_name): Move most of the code to file_file_name.
	(macro_start_file): Rename variable full_name to file_name and use
	file_file_name for it.  Add comp_dir parameter to new_macro_table.
	* macrocmd.c (show_pp_source_pos): New variable fullname.  Replace any
	macro_source_file->filename access by macro_source_fullname call.
	* macroscope.c (_initialize_macroscope): Update the new_macro_table
	caller.
	* macrotab.c (struct macro_table): New field comp_dir.
	(macro_include): New variables link_fullname and source_fullname.
	Replace any macro_source_file->filename access by macro_source_fullname
	call.
	(macro_lookup_inclusion): Remove the partial filenames checking code.
	(check_for_redefinition): New variables source_fullname and
	found_key_fullname.  Replace any macro_source_file->filename access by
	macro_source_fullname call.
	(macro_undef): New variables source_fullname and key_fullname.  Replace
	any macro_source_file->filename access by macro_source_fullname call.
	(macro_lookup_definition): New variables retval and source_fullname.
	Replace any macro_source_file->filename access by macro_source_fullname
	call.
	(foreach_macro): New variable key_fullname.  Replace any
	macro_source_file->filename access by macro_source_fullname call.
	(foreach_macro_in_scope): New variable datum_fullname.  Replace any
	macro_source_file->filename access by macro_source_fullname call.
	(new_macro_table): Add parameter comp_dir.  Initialize T with it.
	(macro_source_fullname): New function.
	* macrotab.h (struct macro_source_file): Extent the filename field
	comment.
	(new_macro_table): New parameter comp_dir, add a comment for it.
	(macro_source_fullname): new declaration.

gdb/testsuite/
	* gdb.linespec/base/one/header.h: New file.
	* gdb.linespec/base/two/header.h: New file.
	* gdb.linespec/macro-relative.c: New file.
	* gdb.linespec/macro-relative.exp: New file.
@
text
@/* C preprocessor macro tables for GDB.
   Copyright (C) 2002-2013 Free Software Foundation, Inc.
   Contributed by Red Hat, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdb_obstack.h"
#include "splay-tree.h"
#include "filenames.h"
#include "symtab.h"
#include "symfile.h"
#include "objfiles.h"
#include "macrotab.h"
#include "gdb_assert.h"
#include "bcache.h"
#include "complaints.h"
#include "macroexp.h"


/* The macro table structure.  */

struct macro_table
{
  /* The obstack this table's data should be allocated in, or zero if
     we should use xmalloc.  */
  struct obstack *obstack;

  /* The bcache we should use to hold macro names, argument names, and
     definitions, or zero if we should use xmalloc.  */
  struct bcache *bcache;

  /* The main source file for this compilation unit --- the one whose
     name was given to the compiler.  This is the root of the
     #inclusion tree; everything else is #included from here.  */
  struct macro_source_file *main_source;

  /* Compilation directory for all files of this macro table.  It is allocated
     on objfile's obstack.  */
  const char *comp_dir;

  /* True if macros in this table can be redefined without issuing an
     error.  */
  int redef_ok;

  /* The table of macro definitions.  This is a splay tree (an ordered
     binary tree that stays balanced, effectively), sorted by macro
     name.  Where a macro gets defined more than once (presumably with
     an #undefinition in between), we sort the definitions by the
     order they would appear in the preprocessor's output.  That is,
     if `a.c' #includes `m.h' and then #includes `n.h', and both
     header files #define X (with an #undef somewhere in between),
     then the definition from `m.h' appears in our splay tree before
     the one from `n.h'.

     The splay tree's keys are `struct macro_key' pointers;
     the values are `struct macro_definition' pointers.

     The splay tree, its nodes, and the keys and values are allocated
     in obstack, if it's non-zero, or with xmalloc otherwise.  The
     macro names, argument names, argument name arrays, and definition
     strings are all allocated in bcache, if non-zero, or with xmalloc
     otherwise.  */
  splay_tree definitions;
};



/* Allocation and freeing functions.  */

/* Allocate SIZE bytes of memory appropriately for the macro table T.
   This just checks whether T has an obstack, or whether its pieces
   should be allocated with xmalloc.  */
static void *
macro_alloc (int size, struct macro_table *t)
{
  if (t->obstack)
    return obstack_alloc (t->obstack, size);
  else
    return xmalloc (size);
}


static void
macro_free (void *object, struct macro_table *t)
{
  if (t->obstack)
    /* There are cases where we need to remove entries from a macro
       table, even when reading debugging information.  This should be
       rare, and there's no easy way to free arbitrary data from an
       obstack, so we just leak it.  */
    ;
  else
    xfree (object);
}


/* If the macro table T has a bcache, then cache the LEN bytes at ADDR
   there, and return the cached copy.  Otherwise, just xmalloc a copy
   of the bytes, and return a pointer to that.  */
static const void *
macro_bcache (struct macro_table *t, const void *addr, int len)
{
  if (t->bcache)
    return bcache (addr, len, t->bcache);
  else
    {
      void *copy = xmalloc (len);

      memcpy (copy, addr, len);
      return copy;
    }
}


/* If the macro table T has a bcache, cache the null-terminated string
   S there, and return a pointer to the cached copy.  Otherwise,
   xmalloc a copy and return that.  */
static const char *
macro_bcache_str (struct macro_table *t, const char *s)
{
  return macro_bcache (t, s, strlen (s) + 1);
}


/* Free a possibly bcached object OBJ.  That is, if the macro table T
   has a bcache, do nothing; otherwise, xfree OBJ.  */
static void
macro_bcache_free (struct macro_table *t, void *obj)
{
  if (t->bcache)
    /* There are cases where we need to remove entries from a macro
       table, even when reading debugging information.  This should be
       rare, and there's no easy way to free data from a bcache, so we
       just leak it.  */
    ;
  else
    xfree (obj);
}



/* Macro tree keys, w/their comparison, allocation, and freeing functions.  */

/* A key in the splay tree.  */
struct macro_key
{
  /* The table we're in.  We only need this in order to free it, since
     the splay tree library's key and value freeing functions require
     that the key or value contain all the information needed to free
     themselves.  */
  struct macro_table *table;

  /* The name of the macro.  This is in the table's bcache, if it has
     one.  */
  const char *name;

  /* The source file and line number where the definition's scope
     begins.  This is also the line of the definition itself.  */
  struct macro_source_file *start_file;
  int start_line;

  /* The first source file and line after the definition's scope.
     (That is, the scope does not include this endpoint.)  If end_file
     is zero, then the definition extends to the end of the
     compilation unit.  */
  struct macro_source_file *end_file;
  int end_line;
};


/* Return the #inclusion depth of the source file FILE.  This is the
   number of #inclusions it took to reach this file.  For the main
   source file, the #inclusion depth is zero; for a file it #includes
   directly, the depth would be one; and so on.  */
static int
inclusion_depth (struct macro_source_file *file)
{
  int depth;

  for (depth = 0; file->included_by; depth++)
    file = file->included_by;

  return depth;
}


/* Compare two source locations (from the same compilation unit).
   This is part of the comparison function for the tree of
   definitions.

   LINE1 and LINE2 are line numbers in the source files FILE1 and
   FILE2.  Return a value:
   - less than zero if {LINE,FILE}1 comes before {LINE,FILE}2,
   - greater than zero if {LINE,FILE}1 comes after {LINE,FILE}2, or
   - zero if they are equal.

   When the two locations are in different source files --- perhaps
   one is in a header, while another is in the main source file --- we
   order them by where they would appear in the fully pre-processed
   sources, where all the #included files have been substituted into
   their places.  */
static int
compare_locations (struct macro_source_file *file1, int line1, 
                   struct macro_source_file *file2, int line2)
{
  /* We want to treat positions in an #included file as coming *after*
     the line containing the #include, but *before* the line after the
     include.  As we walk up the #inclusion tree toward the main
     source file, we update fileX and lineX as we go; includedX
     indicates whether the original position was from the #included
     file.  */
  int included1 = 0;
  int included2 = 0;

  /* If a file is zero, that means "end of compilation unit."  Handle
     that specially.  */
  if (! file1)
    {
      if (! file2)
        return 0;
      else
        return 1;
    }
  else if (! file2)
    return -1;

  /* If the two files are not the same, find their common ancestor in
     the #inclusion tree.  */
  if (file1 != file2)
    {
      /* If one file is deeper than the other, walk up the #inclusion
         chain until the two files are at least at the same *depth*.
         Then, walk up both files in synchrony until they're the same
         file.  That file is the common ancestor.  */
      int depth1 = inclusion_depth (file1);
      int depth2 = inclusion_depth (file2);

      /* Only one of these while loops will ever execute in any given
         case.  */
      while (depth1 > depth2)
        {
          line1 = file1->included_at_line;
          file1 = file1->included_by;
          included1 = 1;
          depth1--;
        }
      while (depth2 > depth1)
        {
          line2 = file2->included_at_line;
          file2 = file2->included_by;
          included2 = 1;
          depth2--;
        }

      /* Now both file1 and file2 are at the same depth.  Walk toward
         the root of the tree until we find where the branches meet.  */
      while (file1 != file2)
        {
          line1 = file1->included_at_line;
          file1 = file1->included_by;
          /* At this point, we know that the case the includedX flags
             are trying to deal with won't come up, but we'll just
             maintain them anyway.  */
          included1 = 1;

          line2 = file2->included_at_line;
          file2 = file2->included_by;
          included2 = 1;

          /* Sanity check.  If file1 and file2 are really from the
             same compilation unit, then they should both be part of
             the same tree, and this shouldn't happen.  */
          gdb_assert (file1 && file2);
        }
    }

  /* Now we've got two line numbers in the same file.  */
  if (line1 == line2)
    {
      /* They can't both be from #included files.  Then we shouldn't
         have walked up this far.  */
      gdb_assert (! included1 || ! included2);

      /* Any #included position comes after a non-#included position
         with the same line number in the #including file.  */
      if (included1)
        return 1;
      else if (included2)
        return -1;
      else
        return 0;
    }
  else
    return line1 - line2;
}


/* Compare a macro key KEY against NAME, the source file FILE, and
   line number LINE.

   Sort definitions by name; for two definitions with the same name,
   place the one whose definition comes earlier before the one whose
   definition comes later.

   Return -1, 0, or 1 if key comes before, is identical to, or comes
   after NAME, FILE, and LINE.  */
static int
key_compare (struct macro_key *key,
             const char *name, struct macro_source_file *file, int line)
{
  int names = strcmp (key->name, name);

  if (names)
    return names;

  return compare_locations (key->start_file, key->start_line,
                            file, line);
}


/* The macro tree comparison function, typed for the splay tree
   library's happiness.  */
static int
macro_tree_compare (splay_tree_key untyped_key1,
                    splay_tree_key untyped_key2)
{
  struct macro_key *key1 = (struct macro_key *) untyped_key1;
  struct macro_key *key2 = (struct macro_key *) untyped_key2;

  return key_compare (key1, key2->name, key2->start_file, key2->start_line);
}


/* Construct a new macro key node for a macro in table T whose name is
   NAME, and whose scope starts at LINE in FILE; register the name in
   the bcache.  */
static struct macro_key *
new_macro_key (struct macro_table *t,
               const char *name,
               struct macro_source_file *file,
               int line)
{
  struct macro_key *k = macro_alloc (sizeof (*k), t);

  memset (k, 0, sizeof (*k));
  k->table = t;
  k->name = macro_bcache_str (t, name);
  k->start_file = file;
  k->start_line = line;
  k->end_file = 0;

  return k;
}


static void
macro_tree_delete_key (void *untyped_key)
{
  struct macro_key *key = (struct macro_key *) untyped_key;

  macro_bcache_free (key->table, (char *) key->name);
  macro_free (key, key->table);
}



/* Building and querying the tree of #included files.  */


/* Allocate and initialize a new source file structure.  */
static struct macro_source_file *
new_source_file (struct macro_table *t,
                 const char *filename)
{
  /* Get space for the source file structure itself.  */
  struct macro_source_file *f = macro_alloc (sizeof (*f), t);

  memset (f, 0, sizeof (*f));
  f->table = t;
  f->filename = macro_bcache_str (t, filename);
  f->includes = 0;

  return f;
}


/* Free a source file, and all the source files it #included.  */
static void
free_macro_source_file (struct macro_source_file *src)
{
  struct macro_source_file *child, *next_child;

  /* Free this file's children.  */
  for (child = src->includes; child; child = next_child)
    {
      next_child = child->next_included;
      free_macro_source_file (child);
    }

  macro_bcache_free (src->table, (char *) src->filename);
  macro_free (src, src->table);
}


struct macro_source_file *
macro_set_main (struct macro_table *t,
                const char *filename)
{
  /* You can't change a table's main source file.  What would that do
     to the tree?  */
  gdb_assert (! t->main_source);

  t->main_source = new_source_file (t, filename);

  return t->main_source;
}


struct macro_source_file *
macro_main (struct macro_table *t)
{
  gdb_assert (t->main_source);

  return t->main_source;
}


void
macro_allow_redefinitions (struct macro_table *t)
{
  gdb_assert (! t->obstack);
  t->redef_ok = 1;
}


struct macro_source_file *
macro_include (struct macro_source_file *source,
               int line,
               const char *included)
{
  struct macro_source_file *new;
  struct macro_source_file **link;

  /* Find the right position in SOURCE's `includes' list for the new
     file.  Skip inclusions at earlier lines, until we find one at the
     same line or later --- or until the end of the list.  */
  for (link = &source->includes;
       *link && (*link)->included_at_line < line;
       link = &(*link)->next_included)
    ;

  /* Did we find another file already #included at the same line as
     the new one?  */
  if (*link && line == (*link)->included_at_line)
    {
      char *link_fullname, *source_fullname;

      /* This means the compiler is emitting bogus debug info.  (GCC
         circa March 2002 did this.)  It also means that the splay
         tree ordering function, macro_tree_compare, will abort,
         because it can't tell which #inclusion came first.  But GDB
         should tolerate bad debug info.  So:

         First, squawk.  */

      link_fullname = macro_source_fullname (*link);
      source_fullname = macro_source_fullname (source);
      complaint (&symfile_complaints,
		 _("both `%s' and `%s' allegedly #included at %s:%d"),
		 included, link_fullname, source_fullname, line);
      xfree (source_fullname);
      xfree (link_fullname);

      /* Now, choose a new, unoccupied line number for this
         #inclusion, after the alleged #inclusion line.  */
      while (*link && line == (*link)->included_at_line)
        {
          /* This line number is taken, so try the next line.  */
          line++;
          link = &(*link)->next_included;
        }
    }

  /* At this point, we know that LINE is an unused line number, and
     *LINK points to the entry an #inclusion at that line should
     precede.  */
  new = new_source_file (source->table, included);
  new->included_by = source;
  new->included_at_line = line;
  new->next_included = *link;
  *link = new;

  return new;
}


struct macro_source_file *
macro_lookup_inclusion (struct macro_source_file *source, const char *name)
{
  /* Is SOURCE itself named NAME?  */
  if (filename_cmp (name, source->filename) == 0)
    return source;

  /* It's not us.  Try all our children, and return the lowest.  */
  {
    struct macro_source_file *child;
    struct macro_source_file *best = NULL;
    int best_depth = 0;

    for (child = source->includes; child; child = child->next_included)
      {
        struct macro_source_file *result
          = macro_lookup_inclusion (child, name);

        if (result)
          {
            int result_depth = inclusion_depth (result);

            if (! best || result_depth < best_depth)
              {
                best = result;
                best_depth = result_depth;
              }
          }
      }

    return best;
  }
}



/* Registering and looking up macro definitions.  */


/* Construct a definition for a macro in table T.  Cache all strings,
   and the macro_definition structure itself, in T's bcache.  */
static struct macro_definition *
new_macro_definition (struct macro_table *t,
                      enum macro_kind kind,
                      int argc, const char **argv,
                      const char *replacement)
{
  struct macro_definition *d = macro_alloc (sizeof (*d), t);

  memset (d, 0, sizeof (*d));
  d->table = t;
  d->kind = kind;
  d->replacement = macro_bcache_str (t, replacement);
  d->argc = argc;

  if (kind == macro_function_like)
    {
      int i;
      const char **cached_argv;
      int cached_argv_size = argc * sizeof (*cached_argv);

      /* Bcache all the arguments.  */
      cached_argv = alloca (cached_argv_size);
      for (i = 0; i < argc; i++)
        cached_argv[i] = macro_bcache_str (t, argv[i]);

      /* Now bcache the array of argument pointers itself.  */
      d->argv = macro_bcache (t, cached_argv, cached_argv_size);
    }

  /* We don't bcache the entire definition structure because it's got
     a pointer to the macro table in it; since each compilation unit
     has its own macro table, you'd only get bcache hits for identical
     definitions within a compilation unit, which seems unlikely.

     "So, why do macro definitions have pointers to their macro tables
     at all?"  Well, when the splay tree library wants to free a
     node's value, it calls the value freeing function with nothing
     but the value itself.  It makes the (apparently reasonable)
     assumption that the value carries enough information to free
     itself.  But not all macro tables have bcaches, so not all macro
     definitions would be bcached.  There's no way to tell whether a
     given definition is bcached without knowing which table the
     definition belongs to.  ...  blah.  The thing's only sixteen
     bytes anyway, and we can still bcache the name, args, and
     definition, so we just don't bother bcaching the definition
     structure itself.  */
  return d;
}


/* Free a macro definition.  */
static void
macro_tree_delete_value (void *untyped_definition)
{
  struct macro_definition *d = (struct macro_definition *) untyped_definition;
  struct macro_table *t = d->table;

  if (d->kind == macro_function_like)
    {
      int i;

      for (i = 0; i < d->argc; i++)
        macro_bcache_free (t, (char *) d->argv[i]);
      macro_bcache_free (t, (char **) d->argv);
    }
  
  macro_bcache_free (t, (char *) d->replacement);
  macro_free (d, t);
}


/* Find the splay tree node for the definition of NAME at LINE in
   SOURCE, or zero if there is none.  */
static splay_tree_node
find_definition (const char *name,
                 struct macro_source_file *file,
                 int line)
{
  struct macro_table *t = file->table;
  splay_tree_node n;

  /* Construct a macro_key object, just for the query.  */
  struct macro_key query;

  query.name = name;
  query.start_file = file;
  query.start_line = line;
  query.end_file = NULL;

  n = splay_tree_lookup (t->definitions, (splay_tree_key) &query);
  if (! n)
    {
      /* It's okay for us to do two queries like this: the real work
         of the searching is done when we splay, and splaying the tree
         a second time at the same key is a constant time operation.
         If this still bugs you, you could always just extend the
         splay tree library with a predecessor-or-equal operation, and
         use that.  */
      splay_tree_node pred = splay_tree_predecessor (t->definitions,
                                                     (splay_tree_key) &query);
     
      if (pred)
        {
          /* Make sure this predecessor actually has the right name.
             We just want to search within a given name's definitions.  */
          struct macro_key *found = (struct macro_key *) pred->key;

          if (strcmp (found->name, name) == 0)
            n = pred;
        }
    }

  if (n)
    {
      struct macro_key *found = (struct macro_key *) n->key;

      /* Okay, so this definition has the right name, and its scope
         begins before the given source location.  But does its scope
         end after the given source location?  */
      if (compare_locations (file, line, found->end_file, found->end_line) < 0)
        return n;
      else
        return 0;
    }
  else
    return 0;
}


/* If NAME already has a definition in scope at LINE in SOURCE, return
   the key.  If the old definition is different from the definition
   given by KIND, ARGC, ARGV, and REPLACEMENT, complain, too.
   Otherwise, return zero.  (ARGC and ARGV are meaningless unless KIND
   is `macro_function_like'.)  */
static struct macro_key *
check_for_redefinition (struct macro_source_file *source, int line,
                        const char *name, enum macro_kind kind,
                        int argc, const char **argv,
                        const char *replacement)
{
  splay_tree_node n = find_definition (name, source, line);

  if (n)
    {
      struct macro_key *found_key = (struct macro_key *) n->key;
      struct macro_definition *found_def
        = (struct macro_definition *) n->value;
      int same = 1;

      /* Is this definition the same as the existing one?
         According to the standard, this comparison needs to be done
         on lists of tokens, not byte-by-byte, as we do here.  But
         that's too hard for us at the moment, and comparing
         byte-by-byte will only yield false negatives (i.e., extra
         warning messages), not false positives (i.e., unnoticed
         definition changes).  */
      if (kind != found_def->kind)
        same = 0;
      else if (strcmp (replacement, found_def->replacement))
        same = 0;
      else if (kind == macro_function_like)
        {
          if (argc != found_def->argc)
            same = 0;
          else
            {
              int i;

              for (i = 0; i < argc; i++)
                if (strcmp (argv[i], found_def->argv[i]))
                  same = 0;
            }
        }

      if (! same)
        {
	  char *source_fullname, *found_key_fullname;
	  
	  source_fullname = macro_source_fullname (source);
	  found_key_fullname = macro_source_fullname (found_key->start_file);
	  complaint (&symfile_complaints,
		     _("macro `%s' redefined at %s:%d; "
		       "original definition at %s:%d"),
		     name, source_fullname, line, found_key_fullname,
		     found_key->start_line);
	  xfree (found_key_fullname);
	  xfree (source_fullname);
        }

      return found_key;
    }
  else
    return 0;
}

/* A helper function to define a new object-like macro.  */

static void
macro_define_object_internal (struct macro_source_file *source, int line,
			      const char *name, const char *replacement,
			      enum macro_special_kind kind)
{
  struct macro_table *t = source->table;
  struct macro_key *k = NULL;
  struct macro_definition *d;

  if (! t->redef_ok)
    k = check_for_redefinition (source, line, 
				name, macro_object_like,
				0, 0,
				replacement);

  /* If we're redefining a symbol, and the existing key would be
     identical to our new key, then the splay_tree_insert function
     will try to delete the old definition.  When the definition is
     living on an obstack, this isn't a happy thing.

     Since this only happens in the presence of questionable debug
     info, we just ignore all definitions after the first.  The only
     case I know of where this arises is in GCC's output for
     predefined macros, and all the definitions are the same in that
     case.  */
  if (k && ! key_compare (k, name, source, line))
    return;

  k = new_macro_key (t, name, source, line);
  d = new_macro_definition (t, macro_object_like, kind, 0, replacement);
  splay_tree_insert (t->definitions, (splay_tree_key) k, (splay_tree_value) d);
}

void
macro_define_object (struct macro_source_file *source, int line,
		     const char *name, const char *replacement)
{
  macro_define_object_internal (source, line, name, replacement,
				macro_ordinary);
}

/* See macrotab.h.  */

void
macro_define_special (struct macro_table *table)
{
  macro_define_object_internal (table->main_source, -1, "__FILE__", "",
				macro_FILE);
  macro_define_object_internal (table->main_source, -1, "__LINE__", "",
				macro_LINE);
}

void
macro_define_function (struct macro_source_file *source, int line,
                       const char *name, int argc, const char **argv,
                       const char *replacement)
{
  struct macro_table *t = source->table;
  struct macro_key *k = NULL;
  struct macro_definition *d;

  if (! t->redef_ok)
    k = check_for_redefinition (source, line,
				name, macro_function_like,
				argc, argv,
				replacement);

  /* See comments about duplicate keys in macro_define_object.  */
  if (k && ! key_compare (k, name, source, line))
    return;

  /* We should also check here that all the argument names in ARGV are
     distinct.  */

  k = new_macro_key (t, name, source, line);
  d = new_macro_definition (t, macro_function_like, argc, argv, replacement);
  splay_tree_insert (t->definitions, (splay_tree_key) k, (splay_tree_value) d);
}


void
macro_undef (struct macro_source_file *source, int line,
             const char *name)
{
  splay_tree_node n = find_definition (name, source, line);

  if (n)
    {
      struct macro_key *key = (struct macro_key *) n->key;

      /* If we're removing a definition at exactly the same point that
         we defined it, then just delete the entry altogether.  GCC
         4.1.2 will generate DWARF that says to do this if you pass it
         arguments like '-DFOO -UFOO -DFOO=2'.  */
      if (source == key->start_file
          && line == key->start_line)
        splay_tree_remove (source->table->definitions, n->key);

      else
        {
          /* This function is the only place a macro's end-of-scope
             location gets set to anything other than "end of the
             compilation unit" (i.e., end_file is zero).  So if this
             macro already has its end-of-scope set, then we're
             probably seeing a second #undefinition for the same
             #definition.  */
          if (key->end_file)
            {
	      char *source_fullname, *key_fullname;

	      source_fullname = macro_source_fullname (source);
	      key_fullname = macro_source_fullname (key->end_file);
              complaint (&symfile_complaints,
                         _("macro '%s' is #undefined twice,"
                           " at %s:%d and %s:%d"),
			 name, source_fullname, line, key_fullname,
			 key->end_line);
	      xfree (key_fullname);
	      xfree (source_fullname);
            }

          /* Whether or not we've seen a prior #undefinition, wipe out
             the old ending point, and make this the ending point.  */
          key->end_file = source;
          key->end_line = line;
        }
    }
  else
    {
      /* According to the ISO C standard, an #undef for a symbol that
         has no macro definition in scope is ignored.  So we should
         ignore it too.  */
#if 0
      complaint (&symfile_complaints,
		 _("no definition for macro `%s' in scope to #undef at %s:%d"),
		 name, source->filename, line);
#endif
    }
}

/* A helper function that rewrites the definition of a special macro,
   when needed.  */

static struct macro_definition *
fixup_definition (const char *filename, int line, struct macro_definition *def)
{
  static char *saved_expansion;

  if (saved_expansion)
    {
      xfree (saved_expansion);
      saved_expansion = NULL;
    }

  if (def->kind == macro_object_like)
    {
      if (def->argc == macro_FILE)
	{
	  saved_expansion = macro_stringify (filename);
	  def->replacement = saved_expansion;
	}
      else if (def->argc == macro_LINE)
	{
	  saved_expansion = xstrprintf ("%d", line);
	  def->replacement = saved_expansion;
	}
    }

  return def;
}

struct macro_definition *
macro_lookup_definition (struct macro_source_file *source,
                         int line, const char *name)
{
  splay_tree_node n = find_definition (name, source, line);

  if (n)
    {
      struct macro_definition *retval;
      char *source_fullname;

      source_fullname = macro_source_fullname (source);
      retval = fixup_definition (source_fullname, line,
				 (struct macro_definition *) n->value);
      xfree (source_fullname);
      return retval;
    }
  else
    return 0;
}


struct macro_source_file *
macro_definition_location (struct macro_source_file *source,
                           int line,
                           const char *name,
                           int *definition_line)
{
  splay_tree_node n = find_definition (name, source, line);

  if (n)
    {
      struct macro_key *key = (struct macro_key *) n->key;

      *definition_line = key->start_line;
      return key->start_file;
    }
  else
    return 0;
}


/* The type for callback data for iterating the splay tree in
   macro_for_each and macro_for_each_in_scope.  Only the latter uses
   the FILE and LINE fields.  */
struct macro_for_each_data
{
  macro_callback_fn fn;
  void *user_data;
  struct macro_source_file *file;
  int line;
};

/* Helper function for macro_for_each.  */
static int
foreach_macro (splay_tree_node node, void *arg)
{
  struct macro_for_each_data *datum = (struct macro_for_each_data *) arg;
  struct macro_key *key = (struct macro_key *) node->key;
  struct macro_definition *def;
  char *key_fullname;

  key_fullname = macro_source_fullname (key->start_file);
  def = fixup_definition (key_fullname, key->start_line,
			  (struct macro_definition *) node->value);
  xfree (key_fullname);

  (*datum->fn) (key->name, def, key->start_file, key->start_line,
		datum->user_data);
  return 0;
}

/* Call FN for every macro in TABLE.  */
void
macro_for_each (struct macro_table *table, macro_callback_fn fn,
		void *user_data)
{
  struct macro_for_each_data datum;

  datum.fn = fn;
  datum.user_data = user_data;
  datum.file = NULL;
  datum.line = 0;
  splay_tree_foreach (table->definitions, foreach_macro, &datum);
}

static int
foreach_macro_in_scope (splay_tree_node node, void *info)
{
  struct macro_for_each_data *datum = (struct macro_for_each_data *) info;
  struct macro_key *key = (struct macro_key *) node->key;
  struct macro_definition *def;
  char *datum_fullname;

  datum_fullname = macro_source_fullname (datum->file);
  def = fixup_definition (datum_fullname, datum->line,
			  (struct macro_definition *) node->value);
  xfree (datum_fullname);

  /* See if this macro is defined before the passed-in line, and
     extends past that line.  */
  if (compare_locations (key->start_file, key->start_line,
			 datum->file, datum->line) < 0
      && (!key->end_file
	  || compare_locations (key->end_file, key->end_line,
				datum->file, datum->line) >= 0))
    (*datum->fn) (key->name, def, key->start_file, key->start_line,
		  datum->user_data);
  return 0;
}

/* Call FN for every macro is visible in SCOPE.  */
void
macro_for_each_in_scope (struct macro_source_file *file, int line,
			 macro_callback_fn fn, void *user_data)
{
  struct macro_for_each_data datum;

  datum.fn = fn;
  datum.user_data = user_data;
  datum.file = file;
  datum.line = line;
  splay_tree_foreach (file->table->definitions,
		      foreach_macro_in_scope, &datum);
}



/* Creating and freeing macro tables.  */


struct macro_table *
new_macro_table (struct obstack *obstack, struct bcache *b,
		 const char *comp_dir)
{
  struct macro_table *t;

  /* First, get storage for the `struct macro_table' itself.  */
  if (obstack)
    t = obstack_alloc (obstack, sizeof (*t));
  else
    t = xmalloc (sizeof (*t));

  memset (t, 0, sizeof (*t));
  t->obstack = obstack;
  t->bcache = b;
  t->main_source = NULL;
  t->comp_dir = comp_dir;
  t->redef_ok = 0;
  t->definitions = (splay_tree_new_with_allocator
                    (macro_tree_compare,
                     ((splay_tree_delete_key_fn) macro_tree_delete_key),
                     ((splay_tree_delete_value_fn) macro_tree_delete_value),
                     ((splay_tree_allocate_fn) macro_alloc),
                     ((splay_tree_deallocate_fn) macro_free),
                     t));
  
  return t;
}


void
free_macro_table (struct macro_table *table)
{
  /* Free the source file tree.  */
  free_macro_source_file (table->main_source);

  /* Free the table of macro definitions.  */
  splay_tree_delete (table->definitions);
}

/* See macrotab.h for the comment.  */

char *
macro_source_fullname (struct macro_source_file *file)
{
  if (file->table->comp_dir == NULL || IS_ABSOLUTE_PATH (file->filename))
    return xstrdup (file->filename);

  return concat (file->table->comp_dir, SLASH_STRING, file->filename, NULL);
}
@


1.29
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d51 4
d470 2
d479 3
d484 3
a486 1
		 included, (*link)->filename, source->filename, line);
a517 16
  /* The filename in the source structure is probably a full path, but
     NAME could be just the final component of the name.  */
  {
    int name_len = strlen (name);
    int src_name_len = strlen (source->filename);

    /* We do mean < here, and not <=; if the lengths are the same,
       then the filename_cmp above should have triggered, and we need to
       check for a slash here.  */
    if (name_len < src_name_len
        && IS_DIR_SEPARATOR (source->filename[src_name_len - name_len - 1])
        && filename_cmp (name,
			 source->filename + src_name_len - name_len) == 0)
      return source;
  }

d728 4
d735 4
a738 2
		     name, source->filename, line,
		     found_key->start_file->filename, found_key->start_line);
d857 4
d864 4
a867 3
                         name,
                         source->filename, line,
                         key->end_file->filename, key->end_line);
d927 10
a936 2
    return fixup_definition (source->filename, line,
			     (struct macro_definition *) n->value);
d979 7
a985 3
  struct macro_definition *def
    = fixup_definition (key->start_file->filename, key->start_line,
			(struct macro_definition *) node->value);
d1011 7
a1017 3
  struct macro_definition *def
    = fixup_definition (datum->file->filename, datum->line,
			(struct macro_definition *) node->value);
d1052 2
a1053 2
new_macro_table (struct obstack *obstack,
                 struct bcache *b)
d1067 1
d1090 11
@


1.28
log
@	* macrotab.c (macro_bcache_str): Remove cast.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2007-2012 Free Software Foundation, Inc.
@


1.27
log
@	PR macros/13205:
	* macrotab.h: (macro_define_special): Declare.
	(enum macro_special_kind): New.
	(struct macro_definition) <argc, replacement>: Update comments.
	* macrotab.c (new_macro_definition): Unconditionally set 'argc'.
	(macro_define_object_internal): New function.
	(macro_define_object): Use it.
	(macro_define_special): New function.
	(fixup_definition): New function.
	(macro_lookup_definition, foreach_macro_in_scope)
	(foreach_macro): Use fixup_definition.
	* macroexp.h (macro_stringify): Declare.
	* macroexp.c (free_buffer_return_text): New function.
	(stringify): Constify "arg".
	(macro_stringify): New function.
	* dwarf2read.c (macro_start_file): Call macro_define_special.
testsuite
	* gdb.base/macscp1.c (macscp_expr): Add comment.
	* gdb.base/macscp.exp: Test __FILE__ and __LINE__.
@
text
@d131 1
a131 1
  return (char *) macro_bcache (t, s, strlen (s) + 1);
@


1.26
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d31 1
d569 1
a583 1
      d->argc = argc;
d746 1
d748 4
a751 3
void
macro_define_object (struct macro_source_file *source, int line,
                     const char *name, const char *replacement)
d777 1
a777 1
  d = new_macro_definition (t, macro_object_like, 0, 0, replacement);
d781 18
d883 30
d921 2
a922 1
    return (struct macro_definition *) n->value;
d965 3
a967 1
  struct macro_definition *def = (struct macro_definition *) node->value;
d993 3
a995 1
  struct macro_definition *def = (struct macro_definition *) node->value;
@


1.25
log
@PR macros/12999
* macrotab.h (macro_callback_fn): Add new arguments to callback.
* macrotab.c (foreach_macro): Ditto.
(foreach_macro_in_scope): Ditto.
* macrocmd.c (print_macro_callback): New function.
(info_macro_command): Move some code to print_macro_definition.
(print_macro_definition): New function.
(print_one_macro): Add new arguments to callback.

testsuite/
* gdb.base/info-macros.c: New test sources.
* gdb.base/info-macros.exp: New tests.

docs/
* gdb.texinfo (Macros): Add info definitions and info macros commands.
Update text and cindex entries for info macro command.
@
text
@d2 1
a2 2
   Copyright (C) 2002, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.25.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 2002, 2007-2012 Free Software Foundation, Inc.
@


1.24
log
@2011-03-23  Kai Tietz  <ktietz@@redhat.com>

	* breakpoint.c (clear_command): Use filename_cmp
	instead of strcmp for comparison.
	* buildsym.c (watch_main_source_file_lossage): Likewise.
	(patch_subfile_names): Use IS_DIR_SEPARATOR instead of
	checking just for slash.
	* dbxread.c (read_dbx_symtab): Use lbasename instead of
	strrchr and filename_cmp instead of strcmp for filenames.
	(add_old_header_file): Use filename_cmp
	instead of strcmp for comparison.
	* exec.c (exec_set_section_address): Likewise.
	* macrotab.c (macro_lookup_inclusion): Likewise.
	(macro_lookup_inclusion): Likewise.
	* elfread.c (_initialize_elfread): Likewise.
	(elfstab_offset_sections): Likewise.
	(elfstab_offset_sections): Use lbasename instead of
	strrchr.
	* mdebugread.c (parse_partial_symbols): Likewise.
	(arse_partial_symbols): Use filename_(n)cmp instead of
	str(n)cmp for comparison.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* psymtab.c (read_psymtabs_with_filename): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	(reload_shared_libraries_1): Likewise.
	* symmisc.c (maintenance_print_symbols): Likewise.
	* symfile.c (separate_debug_file_exists): Likewise.
	(reread_symbols): Likewise.
	(find_separate_debug_file_by_debuglink): Likewise.
	* remote-fileio.c (remote_fileio_func_rename): Likewise.
	* source.c (add_path): Likewise.
	* symtab.c (filename_seen): Likewise.
	(file_matches): Likewise.
	(print_symbol_info): Likewise.
	(maybe_add_partial_symtab_filename): Likewise.
	(make_source_files_completion_list): Likewise.
	* xml-syscall.c (init_sysinfo): Likewise.
	* windows-nat.c (_initialize_check_for_gdb_ini): Use
	IS_DIR_SEPARATOR for checking for trailing path separator.
@
text
@d916 2
a917 1
  (*datum->fn) (key->name, def, datum->user_data);
d949 2
a950 1
    (*datum->fn) (key->name, def, datum->user_data);
@


1.23
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* m2-exp.y: Comment cleanup, mostly periods and spaces.
	* m2-lang.c: Ditto.
	* m2-typeprint.c: Ditto.
	* m2-valprint.c: Ditto.
	* m32c-tdep.c: Ditto.
	* m32r-linux-nat.c: Ditto.
	* m32r-rom.c: Ditto.
	* m32r-tdep.c: Ditto.
	* m32r-tdep.h: Ditto.
	* m68hc11-tdep.c: Ditto.
	* m58klinux-nat.c: Ditto.
	* m68k-tdep.c: Ditto.
	* m88k-tdep.c: Ditto.
	* m88k-tdep.h: Ditto.
	* machoread.c: Ditto.
	* macrocmd.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* mdebugread.h: Ditto.
	* memattr.c: Ditto.
	* memattr.h: Ditto.
	* memory-map.h: Ditto.
	* mep-tdep.c: Ditto.
	* microblaze-rom.c: Ditto.
	* microblaze-tdep.c: Ditto.
	* minsyms.c: Ditto.
	* mips-irix-tdep.c: Ditto.
	* mips-linux-nat.c: Ditto.
	* mips-linux-tdep.c: Ditto.
	* mips-linux-tdep.h: Ditto.
	* mipsnbsd-nat.c: Ditto.
	* mipsnbsd-tdep.c: Ditto.
	* mipsread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mips-tdep.h: Ditto.
	* mn10300-linux-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* mn10300-tdep.h: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* moxie-tdep.c: Ditto.
	* moxie-tdep.h: Ditto.
	* mt-tdep.c: Ditto.
@
text
@d24 1
d504 1
a504 1
  if (strcmp (name, source->filename) == 0)
d514 1
a514 1
       then the strcmp above should have triggered, and we need to
d517 3
a519 2
        && source->filename[src_name_len - name_len - 1] == '/'
        && strcmp (name, source->filename + src_name_len - name_len) == 0)
@


1.22
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d163 1
a163 1
     one. */
@


1.21
log
@run copyright.sh for 2011.
@
text
@d473 2
a474 2
		 _("both `%s' and `%s' allegedly #included at %s:%d"), included,
		 (*link)->filename, source->filename, line);
d732 2
a733 1
		     _("macro `%s' redefined at %s:%d; original definition at %s:%d"),
@


1.20
log
@2010-05-15  Michael Snyder  <msnyder@@vmware.com>

	* m2-lang.c: White space.
	* m2-valprint.c: White space.
	* macrocmd.c: White space.
	* macroexp.c: White space.
	* macroscope.c: White space.
	* macrotab.c: White space.
	* main.c: White space.
	* maint.c: White space.
	* mdebugread.c: White space.
	* memattr.c: White space.
	* minsyms.c: White space.
	* monitor.c: White space.
@
text
@d2 2
a3 1
   Copyright (C) 2002, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.19
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d116 1
d320 1
d884 1
d911 1
d922 1
d954 1
@


1.18
log
@        Updated copyright notices for most files.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.17
log
@gdb
	PR gdb/2484:
	* symtab.c (struct add_macro_name_data): New struct.
	(add_macro_name): New function.
	(default_make_symbol_completion_list): Complete macro names.
	* scm-lang.c (scm_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* macrotab.h (macro_callback_fn): Add user_data argument.
	(macro_for_each): Likewise.
	(macro_for_each_in_scope): Declare.
	* macrotab.c: (struct macro_for_each_data): New struct.
	(foreach_macro): Use it.
	(macro_for_each): Likewise.
	(foreach_macro_in_scope): New function.
	(macro_for_each_in_scope): Likewise.
	* macrocmd.c (print_one_macro): Add argument.
	(macro_list_command): Pass NULL to macro_for_each.
	* m2-lang.c (m2_language_defn): Update.
	* language.h (struct language_defn) <la_macro_expansion>: New
	field.
	(macro_expansion): New enum.
	* language.c (unknown_language_defn): Update.  Fix order of
	initializers.
	(auto_language_defn): Likewise.
	(local_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* c-lang.c (c_language_defn): Update.
	(cplus_language_defn): Likewise.
	(asm_language_defn): Likewise.
	(minimal_language_defn): Likewise.
	* ada-lang.c (ada_language_defn): Update.
gdb/testsuite
	* gdb.base/macscp.exp: Add completion tests.
	* gdb.base/macscp1.c (FIFTY_SEVEN): New macro.
	(TWENTY_THREE): Likewise.
	(FORTY_EIGHT): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2007, 2008 Free Software Foundation, Inc.
@


1.16
log
@gdb
	PR gdb/855:
	* NEWS: Add entry for macro commands.
	* Makefile.in (macrocmd.o): Add gdb_string.h.
	* macroscope.h (user_macro_scope): Declare.
	(default_macro_scope): Update documentation.
	(macro_user_macros): Declare.
	* c-lang.c (c_preprocess_and_parse): Always attempt macro lookup.
	Use user_macro_scope.
	(null_macro_lookup): Remove.
	* macrotab.h (macro_callback_fn): Declare.
	(macro_for_each): Likewise.
	(macro_allow_redefinitions): Likewise.
	* macrotab.c (foreach_macro): New function
	(macro_for_each): Likewise.
	(struct macro_table) <redef_ok>: New field.
	(macro_allow_redefinitions): New function.
	(new_macro_table): Update.
	(macro_define_function): Likewise.
	(macro_define_object): Likewise.
	* macroscope.c (user_macro_scope): New function.
	(default_macro_scope): Use it.
	(macro_user_macros): New global.
	(standard_macro_lookup): Look in macro_user_macros.
	(_initialize_macroscope): New function.
	* macroexp.h (macro_is_whitespace, macro_is_digit,
	macro_is_identifier_nondigit): Declare.
	* macroexp.c (macro_is_whitespace): Rename.  No longer static.
	(macro_is_digit): Likewise.
	(macro_is_identifier_nondigit): Likewise.
	(get_identifier): Update.
	(get_pp_number): Likewise.
	(get_token): Likewise.
	* macrocmd.c (skip_ws): New function.
	(extract_identifier): Likewise.
	(free_macro_definition_ptr): Likewise.
	(user_macros): Remove.
	(macro_define_command): Implement.
	(_initialize_macrocmd): Update.
	(macro_undef_command): Implement.
	(print_one_macro): New function.
	(macro_list_command): Implement.
gdb/doc
	* gdb.texinfo (Macros): Update.  Use @@code rather than @@command.
gdb/testsuite
	* gdb.base/macscp.exp: Add macro tests.
@
text
@d890 11
d903 1
a903 1
foreach_macro (splay_tree_node node, void *fnp)
d905 1
a905 1
  macro_callback_fn *fn = (macro_callback_fn *) fnp;
d908 1
a908 1
  (**fn) (key->name, def);
d914 33
a946 1
macro_for_each (struct macro_table *table, macro_callback_fn fn)
d948 7
a954 4
  /* Note that we pass in the address of 'fn' because, pedantically
     speaking, we can't necessarily cast a pointer-to-function to a
     void*.  */
  splay_tree_foreach (table->definitions, foreach_macro, &fn);
@


1.15
log
@	Updated copyright notices for most files.
@
text
@d49 4
d434 8
d746 1
a746 1
  struct macro_key *k;
d749 5
a753 4
  k = check_for_redefinition (source, line, 
                              name, macro_object_like,
                              0, 0,
                              replacement);
d780 1
a780 1
  struct macro_key *k;
d783 5
a787 4
  k = check_for_redefinition (source, line,
                              name, macro_function_like,
                              argc, argv,
                              replacement);
d890 22
d932 1
@


1.14
log
@* macrotab.h (new_macro_table): Document that removing information
from an obstack/bcache-managed macro table leaks memory.
* macrotab.c (macro_free, macro_bcache_free): Instead of asserting
that data is never freed in obstack/bcache-managed macro tables,
just leak the storage.
(macro_undef): If we're undefining a macro at exactly the same
source location that we defined it, simply remove the definition
altogether.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2007 Free Software Foundation, Inc.
@


1.13
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d90 8
a97 2
  gdb_assert (! t->obstack);
  xfree (object);
d129 1
a129 1
   has a bcache, it's an error; otherwise, xfree OBJ.  */
d133 8
a140 2
  gdb_assert (! t->bcache);
  xfree (obj);
a795 5
      /* This function is the only place a macro's end-of-scope
         location gets set to anything other than "end of the
         compilation unit" (i.e., end_file is zero).  So if this macro
         already has its end-of-scope set, then we're probably seeing
         a second #undefinition for the same #definition.  */
d798 9
a806 1
      if (key->end_file)
d808 20
a827 4
	  complaint (&symfile_complaints,
		     _("macro '%s' is #undefined twice, at %s:%d and %s:%d"), name,
		     source->filename, line, key->end_file->filename,
		     key->end_line);
a828 5

      /* Whatever the case, wipe out the old ending point, and 
         make this the ending point.  */
      key->end_file = source;
      key->end_line = line;
@


1.12
log
@Copyright updates for 2007.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.11
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d2 1
a2 1
   Copyright (C) 2002 Free Software Foundation, Inc.
@


1.10
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d2 1
a2 1
   Copyright 2002 Free Software Foundation, Inc.
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.9
log
@* macrotab.c (macro_include): Use the correct comparison to find
the appropriate place for this inclusion in the list.
@
text
@d448 1
a448 1
		 "both `%s' and `%s' allegedly #included at %s:%d", included,
d707 1
a707 1
		     "macro `%s' redefined at %s:%d; original definition at %s:%d",
d796 1
a796 1
		     "macro '%s' is #undefined twice, at %s:%d and %s:%d", name,
d813 1
a813 1
		 "no definition for macro `%s' in scope to #undef at %s:%d",
@


1.8
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@d429 2
a430 3
     file.  Scan until we find the first file we shouldn't follow ---
     which is therefore the file we should directly precede --- or
     reach the end of the list.  */
d432 1
a432 1
       *link && line < (*link)->included_at_line;
@


1.7
log
@Replace complain() with complaint().
@
text
@d126 1
a126 1
void
@


1.6
log
@2002-10-25  Andrew Cagney  <cagney@@redhat.com>

	* complaints.h (struct deprecated_complaint): Rename `struct
	complaint'.
	* complaints.c (complain): Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Delete
	incorrect comment indicating that "symfile.h" was being included
	for the `struct complaint' definition.
	* remote-vx.c: Update.
	* objc-lang.c: Update.
	* xcoffread.c: Update.
	* hpread.c: Update.
	* mdebugread.c: Update.
	* stabsread.c: Update.
	* dwarf2read.c: Update.
	* dwarfread.c: Update.
	* elfread.c: Update.
	* coffread.c: Update.
	* stabsread.h: Update.
	* dbxread.c: Update.
	* buildsym.c: Update.
	* gdbtypes.c: Update.
	* macrotab.c: Update.
@
text
@d448 3
a450 6
      static struct deprecated_complaint bogus_inclusion_line = {
        "both `%s' and `%s' allegedly #included at %s:%d", 0, 0
      };

      complain (&bogus_inclusion_line, 
                included, (*link)->filename, source->filename, line);
d707 4
a710 9
          static struct deprecated_complaint macro_redefined = {
            "macro `%s' redefined at %s:%d; original definition at %s:%d",
            0, 0
          };
          complain (&macro_redefined,
                    name,
                    source->filename, line,
                    found_key->start_file->filename,
                    found_key->start_line);
d796 4
a799 6
          static struct deprecated_complaint double_undef = {
            "macro '%s' is #undefined twice, at %s:%d and %s:%d",
            0, 0
          };
          complain (&double_undef, name, source->filename, line,
                    key->end_file->filename, key->end_line);
d813 3
a815 5
      static struct deprecated_complaint no_macro_to_undefine = {
        "no definition for macro `%s' in scope to #undef at %s:%d",
        0, 0
      };
      complain (&no_macro_to_undefine, name, source->filename, line);
@


1.5
log
@2002-07-29  Andrew Cagney  <ac131313@@redhat.com>

* gdb_obstack.h: New file.
* symtab.h: Include "gdb_obstack.h" instead of "obstack.h".
(obstack_chunk_alloc, obstack_chunk_free): Delete macros.
* objfiles.h: Include "gdb_obstack.h".
* Makefile.in (gdb_obstack_h): Define.
(symtab_h): Add $(gdb_obstack_h).
(objfiles_h): Add $(gdb_obstack_h).

* objfiles.c: Include "gdb_obstack.h" instead of "obstack.h".
* macrotab.c, cp-valprint.c, dbxread.c: Ditto.
* ch-typeprint.c, ch-valprint.c, dstread.c: Ditto.
* macroexp.c, p-typeprint.c, stabsread.c: Ditto.
* symtab.c, f-typeprint.c, mdebugread.c: Ditto.
* p-valprint.c, symmisc.c, typeprint.c: Ditto.
* symfile.c, coffread.c, c-typeprint.c: Ditto.
* buildsym.c, bcache.c, ada-typeprint.c: Ditto.

* Makefile.in (bcache.o): Update dependencies.
(buildsym.o, c-typeprint.o, ch-typeprint.o): Ditto.
(ch-valprint.o, coffread.o, cp-valprint.o): Ditto.
(dbxread.o, dstread.o, f-typeprint.o): Ditto.
(objfiles.o, p-typeprint.o, p-valprint.o): Ditto.
(stabsread.o, symfile.o, symmisc.o): Ditto.
(symtab.o, typeprint.o, macroexp.o): Ditto.
(macrotab.o, mdebugread.o): Ditto.
(f_lang_h, coff_sym_h, coff_symconst_h): Define.
(coff_ecoff_h, aout_aout64_h): Define.
(aout_stabs_gnu_h, libaout_h): Define.
@
text
@d448 1
a448 1
      static struct complaint bogus_inclusion_line = {
d710 1
a710 1
          static struct complaint macro_redefined = {
d804 1
a804 1
          static struct complaint double_undef = {
d823 1
a823 1
      static struct complaint no_macro_to_undefine = {
@


1.5.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d126 1
a126 1
static void
d429 3
a431 2
     file.  Skip inclusions at earlier lines, until we find one at the
     same line or later --- or until the end of the list.  */
d433 1
a433 1
       *link && (*link)->included_at_line < line;
d448 6
a453 3
      complaint (&symfile_complaints,
		 "both `%s' and `%s' allegedly #included at %s:%d", included,
		 (*link)->filename, source->filename, line);
d710 9
a718 4
	  complaint (&symfile_complaints,
		     "macro `%s' redefined at %s:%d; original definition at %s:%d",
		     name, source->filename, line,
		     found_key->start_file->filename, found_key->start_line);
d804 6
a809 4
	  complaint (&symfile_complaints,
		     "macro '%s' is #undefined twice, at %s:%d and %s:%d", name,
		     source->filename, line, key->end_file->filename,
		     key->end_line);
d823 5
a827 3
      complaint (&symfile_complaints,
		 "no definition for macro `%s' in scope to #undef at %s:%d",
		 name, source->filename, line);
@


1.5.8.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d448 1
a448 1
      static struct deprecated_complaint bogus_inclusion_line = {
d710 1
a710 1
          static struct deprecated_complaint macro_redefined = {
d804 1
a804 1
          static struct deprecated_complaint double_undef = {
d823 1
a823 1
      static struct deprecated_complaint no_macro_to_undefine = {
@


1.5.8.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d448 6
a453 3
      complaint (&symfile_complaints,
		 "both `%s' and `%s' allegedly #included at %s:%d", included,
		 (*link)->filename, source->filename, line);
d710 9
a718 4
	  complaint (&symfile_complaints,
		     "macro `%s' redefined at %s:%d; original definition at %s:%d",
		     name, source->filename, line,
		     found_key->start_file->filename, found_key->start_line);
d804 6
a809 4
	  complaint (&symfile_complaints,
		     "macro '%s' is #undefined twice, at %s:%d and %s:%d", name,
		     source->filename, line, key->end_file->filename,
		     key->end_line);
d823 5
a827 3
      complaint (&symfile_complaints,
		 "no definition for macro `%s' in scope to #undef at %s:%d",
		 name, source->filename, line);
@


1.5.8.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d126 1
a126 1
static void
@


1.5.8.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d429 3
a431 2
     file.  Skip inclusions at earlier lines, until we find one at the
     same line or later --- or until the end of the list.  */
d433 1
a433 1
       *link && (*link)->included_at_line < line;
@


1.4
log
@* macrotab.c (check_for_redefinition): Don't complain if the new
definition is the same as the previous one.  Take more arguments
to allow the comparison.
(macro_define_object, macro_define_function): Pass more arguments
to check_for_redefinition.
@
text
@d23 1
a23 1
#include "obstack.h"
@


1.4.2.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d23 1
a23 1
#include "gdb_obstack.h"
@


1.4.2.2
log
@merge from mainline
@
text
@d448 1
a448 1
      static struct deprecated_complaint bogus_inclusion_line = {
d710 1
a710 1
          static struct deprecated_complaint macro_redefined = {
d804 1
a804 1
          static struct deprecated_complaint double_undef = {
d823 1
a823 1
      static struct deprecated_complaint no_macro_to_undefine = {
@


1.3
log
@* macroexp.c (init_buffer, gather_arguments, expand): Use NULL, not 0.
* macrotab.c (macro_lookup_inclusion, find_definition,
new_macro_table): Same.

* macroexp.c (currently_rescanning, expand): Use `strcmp () == 0',
not `! strcmp ()'.  This is a dubious improvement.
* macrotab.c (macro_lookup_inclusion, find_definition): Same.

* macrotab.c (macro_lookup_inclusion): Initialize `best_depth',
although it's not necessary, to avoid a warning.
@
text
@d663 5
a667 2
/* If NAME already has a definition in scope at LINE in FILE, and
   return the key.  Otherwise, return zero.  */
d670 3
a672 1
                        const char *name)
a675 2
  /* This isn't really right.  There's nothing wrong with redefining a
     macro if the new replacement list is the same as the old one.  */
d679 42
a720 8
      static struct complaint macro_redefined = {
        "macro `%s' redefined at %s:%d;"
        "original definition at %s:%d", 0, 0
      };
      complain (&macro_redefined, name,
                source->filename, line,
                found_key->start_file->filename,
                found_key->start_line);
d736 4
a739 1
  k = check_for_redefinition (source, line, name);
d769 4
a772 1
  k = check_for_redefinition (source, line, name);
@


1.3.2.1
log
@merge from trunk
@
text
@d663 2
a664 5
/* If NAME already has a definition in scope at LINE in SOURCE, return
   the key.  If the old definition is different from the definition
   given by KIND, ARGC, ARGV, and REPLACEMENT, complain, too.
   Otherwise, return zero.  (ARGC and ARGV are meaningless unless KIND
   is `macro_function_like'.)  */
d667 1
a667 3
                        const char *name, enum macro_kind kind,
                        int argc, const char **argv,
                        const char *replacement)
d671 2
d676 8
a683 42
      struct macro_definition *found_def
        = (struct macro_definition *) n->value;
      int same = 1;

      /* Is this definition the same as the existing one?
         According to the standard, this comparison needs to be done
         on lists of tokens, not byte-by-byte, as we do here.  But
         that's too hard for us at the moment, and comparing
         byte-by-byte will only yield false negatives (i.e., extra
         warning messages), not false positives (i.e., unnoticed
         definition changes).  */
      if (kind != found_def->kind)
        same = 0;
      else if (strcmp (replacement, found_def->replacement))
        same = 0;
      else if (kind == macro_function_like)
        {
          if (argc != found_def->argc)
            same = 0;
          else
            {
              int i;

              for (i = 0; i < argc; i++)
                if (strcmp (argv[i], found_def->argv[i]))
                  same = 0;
            }
        }

      if (! same)
        {
          static struct complaint macro_redefined = {
            "macro `%s' redefined at %s:%d; original definition at %s:%d",
            0, 0
          };
          complain (&macro_redefined,
                    name,
                    source->filename, line,
                    found_key->start_file->filename,
                    found_key->start_line);
        }

d699 1
a699 4
  k = check_for_redefinition (source, line, 
                              name, macro_object_like,
                              0, 0,
                              replacement);
d729 1
a729 4
  k = check_for_redefinition (source, line,
                              name, macro_function_like,
                              argc, argv,
                              replacement);
@


1.2
log
@Add first preprocessor macro-expansion files.
* macroexp.c, macroexp.h, macrotab.c, macrotab.h: New files.
* Makefile.in (SFILES): Add macrotab.c, macroexp.c.
(splay_tree_h, macroexp_h, macrotab_h): New variable.
(HFILES_NO_SRCDIR): Add macrotab.h, macroexp.h.
(COMMON_OBS): Add macrotab.o, macroexp.o.
(macroexp.o, macrotab.o): New rules.
@
text
@d482 1
a482 1
  if (! strcmp (name, source->filename))
d496 1
a496 1
        && ! strcmp (name, source->filename + src_name_len - name_len))
d503 2
a504 2
    struct macro_source_file *best = 0;
    int best_depth;
d621 1
a621 1
  query.end_file = 0;
d641 1
a641 1
          if (! strcmp (found->name, name))
d841 1
a841 1
  t->main_source = 0;
@


1.1
log
@file macrotab.c was initially added on branch jimb-macro-020506-branch.
@
text
@d1 862
@


1.1.2.1
log
@Add first preprocessor macro-expansion files.
* macroexp.c, macroexp.h, macrotab.c, macrotab.h: New files.
* Makefile.in (SFILES): Add macrotab.c, macroexp.c.
(splay_tree_h, macroexp_h, macrotab_h): New variable.
(HFILES_NO_SRCDIR): Add macrotab.h, macroexp.h.
(COMMON_OBS): Add macrotab.o, macroexp.o.
(macroexp.o, macrotab.o): New rules.
@
text
@a0 862
/* C preprocessor macro tables for GDB.
   Copyright 2002 Free Software Foundation, Inc.
   Contributed by Red Hat, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "obstack.h"
#include "splay-tree.h"
#include "symtab.h"
#include "symfile.h"
#include "objfiles.h"
#include "macrotab.h"
#include "gdb_assert.h"
#include "bcache.h"
#include "complaints.h"


/* The macro table structure.  */

struct macro_table
{
  /* The obstack this table's data should be allocated in, or zero if
     we should use xmalloc.  */
  struct obstack *obstack;

  /* The bcache we should use to hold macro names, argument names, and
     definitions, or zero if we should use xmalloc.  */
  struct bcache *bcache;

  /* The main source file for this compilation unit --- the one whose
     name was given to the compiler.  This is the root of the
     #inclusion tree; everything else is #included from here.  */
  struct macro_source_file *main_source;

  /* The table of macro definitions.  This is a splay tree (an ordered
     binary tree that stays balanced, effectively), sorted by macro
     name.  Where a macro gets defined more than once (presumably with
     an #undefinition in between), we sort the definitions by the
     order they would appear in the preprocessor's output.  That is,
     if `a.c' #includes `m.h' and then #includes `n.h', and both
     header files #define X (with an #undef somewhere in between),
     then the definition from `m.h' appears in our splay tree before
     the one from `n.h'.

     The splay tree's keys are `struct macro_key' pointers;
     the values are `struct macro_definition' pointers.

     The splay tree, its nodes, and the keys and values are allocated
     in obstack, if it's non-zero, or with xmalloc otherwise.  The
     macro names, argument names, argument name arrays, and definition
     strings are all allocated in bcache, if non-zero, or with xmalloc
     otherwise.  */
  splay_tree definitions;
};



/* Allocation and freeing functions.  */

/* Allocate SIZE bytes of memory appropriately for the macro table T.
   This just checks whether T has an obstack, or whether its pieces
   should be allocated with xmalloc.  */
static void *
macro_alloc (int size, struct macro_table *t)
{
  if (t->obstack)
    return obstack_alloc (t->obstack, size);
  else
    return xmalloc (size);
}


static void
macro_free (void *object, struct macro_table *t)
{
  gdb_assert (! t->obstack);
  xfree (object);
}


/* If the macro table T has a bcache, then cache the LEN bytes at ADDR
   there, and return the cached copy.  Otherwise, just xmalloc a copy
   of the bytes, and return a pointer to that.  */
static const void *
macro_bcache (struct macro_table *t, const void *addr, int len)
{
  if (t->bcache)
    return bcache (addr, len, t->bcache);
  else
    {
      void *copy = xmalloc (len);
      memcpy (copy, addr, len);
      return copy;
    }
}


/* If the macro table T has a bcache, cache the null-terminated string
   S there, and return a pointer to the cached copy.  Otherwise,
   xmalloc a copy and return that.  */
static const char *
macro_bcache_str (struct macro_table *t, const char *s)
{
  return (char *) macro_bcache (t, s, strlen (s) + 1);
}


/* Free a possibly bcached object OBJ.  That is, if the macro table T
   has a bcache, it's an error; otherwise, xfree OBJ.  */
void
macro_bcache_free (struct macro_table *t, void *obj)
{
  gdb_assert (! t->bcache);
  xfree (obj);
}



/* Macro tree keys, w/their comparison, allocation, and freeing functions.  */

/* A key in the splay tree.  */
struct macro_key
{
  /* The table we're in.  We only need this in order to free it, since
     the splay tree library's key and value freeing functions require
     that the key or value contain all the information needed to free
     themselves.  */
  struct macro_table *table;

  /* The name of the macro.  This is in the table's bcache, if it has
     one. */
  const char *name;

  /* The source file and line number where the definition's scope
     begins.  This is also the line of the definition itself.  */
  struct macro_source_file *start_file;
  int start_line;

  /* The first source file and line after the definition's scope.
     (That is, the scope does not include this endpoint.)  If end_file
     is zero, then the definition extends to the end of the
     compilation unit.  */
  struct macro_source_file *end_file;
  int end_line;
};


/* Return the #inclusion depth of the source file FILE.  This is the
   number of #inclusions it took to reach this file.  For the main
   source file, the #inclusion depth is zero; for a file it #includes
   directly, the depth would be one; and so on.  */
static int
inclusion_depth (struct macro_source_file *file)
{
  int depth;

  for (depth = 0; file->included_by; depth++)
    file = file->included_by;

  return depth;
}


/* Compare two source locations (from the same compilation unit).
   This is part of the comparison function for the tree of
   definitions.

   LINE1 and LINE2 are line numbers in the source files FILE1 and
   FILE2.  Return a value:
   - less than zero if {LINE,FILE}1 comes before {LINE,FILE}2,
   - greater than zero if {LINE,FILE}1 comes after {LINE,FILE}2, or
   - zero if they are equal.

   When the two locations are in different source files --- perhaps
   one is in a header, while another is in the main source file --- we
   order them by where they would appear in the fully pre-processed
   sources, where all the #included files have been substituted into
   their places.  */
static int
compare_locations (struct macro_source_file *file1, int line1, 
                   struct macro_source_file *file2, int line2)
{
  /* We want to treat positions in an #included file as coming *after*
     the line containing the #include, but *before* the line after the
     include.  As we walk up the #inclusion tree toward the main
     source file, we update fileX and lineX as we go; includedX
     indicates whether the original position was from the #included
     file.  */
  int included1 = 0;
  int included2 = 0;

  /* If a file is zero, that means "end of compilation unit."  Handle
     that specially.  */
  if (! file1)
    {
      if (! file2)
        return 0;
      else
        return 1;
    }
  else if (! file2)
    return -1;

  /* If the two files are not the same, find their common ancestor in
     the #inclusion tree.  */
  if (file1 != file2)
    {
      /* If one file is deeper than the other, walk up the #inclusion
         chain until the two files are at least at the same *depth*.
         Then, walk up both files in synchrony until they're the same
         file.  That file is the common ancestor.  */
      int depth1 = inclusion_depth (file1);
      int depth2 = inclusion_depth (file2);

      /* Only one of these while loops will ever execute in any given
         case.  */
      while (depth1 > depth2)
        {
          line1 = file1->included_at_line;
          file1 = file1->included_by;
          included1 = 1;
          depth1--;
        }
      while (depth2 > depth1)
        {
          line2 = file2->included_at_line;
          file2 = file2->included_by;
          included2 = 1;
          depth2--;
        }

      /* Now both file1 and file2 are at the same depth.  Walk toward
         the root of the tree until we find where the branches meet.  */
      while (file1 != file2)
        {
          line1 = file1->included_at_line;
          file1 = file1->included_by;
          /* At this point, we know that the case the includedX flags
             are trying to deal with won't come up, but we'll just
             maintain them anyway.  */
          included1 = 1;

          line2 = file2->included_at_line;
          file2 = file2->included_by;
          included2 = 1;

          /* Sanity check.  If file1 and file2 are really from the
             same compilation unit, then they should both be part of
             the same tree, and this shouldn't happen.  */
          gdb_assert (file1 && file2);
        }
    }

  /* Now we've got two line numbers in the same file.  */
  if (line1 == line2)
    {
      /* They can't both be from #included files.  Then we shouldn't
         have walked up this far.  */
      gdb_assert (! included1 || ! included2);

      /* Any #included position comes after a non-#included position
         with the same line number in the #including file.  */
      if (included1)
        return 1;
      else if (included2)
        return -1;
      else
        return 0;
    }
  else
    return line1 - line2;
}


/* Compare a macro key KEY against NAME, the source file FILE, and
   line number LINE.

   Sort definitions by name; for two definitions with the same name,
   place the one whose definition comes earlier before the one whose
   definition comes later.

   Return -1, 0, or 1 if key comes before, is identical to, or comes
   after NAME, FILE, and LINE.  */
static int
key_compare (struct macro_key *key,
             const char *name, struct macro_source_file *file, int line)
{
  int names = strcmp (key->name, name);
  if (names)
    return names;

  return compare_locations (key->start_file, key->start_line,
                            file, line);
}


/* The macro tree comparison function, typed for the splay tree
   library's happiness.  */
static int
macro_tree_compare (splay_tree_key untyped_key1,
                    splay_tree_key untyped_key2)
{
  struct macro_key *key1 = (struct macro_key *) untyped_key1;
  struct macro_key *key2 = (struct macro_key *) untyped_key2;

  return key_compare (key1, key2->name, key2->start_file, key2->start_line);
}


/* Construct a new macro key node for a macro in table T whose name is
   NAME, and whose scope starts at LINE in FILE; register the name in
   the bcache.  */
static struct macro_key *
new_macro_key (struct macro_table *t,
               const char *name,
               struct macro_source_file *file,
               int line)
{
  struct macro_key *k = macro_alloc (sizeof (*k), t);

  memset (k, 0, sizeof (*k));
  k->table = t;
  k->name = macro_bcache_str (t, name);
  k->start_file = file;
  k->start_line = line;
  k->end_file = 0;

  return k;
}


static void
macro_tree_delete_key (void *untyped_key)
{
  struct macro_key *key = (struct macro_key *) untyped_key;

  macro_bcache_free (key->table, (char *) key->name);
  macro_free (key, key->table);
}



/* Building and querying the tree of #included files.  */


/* Allocate and initialize a new source file structure.  */
static struct macro_source_file *
new_source_file (struct macro_table *t,
                 const char *filename)
{
  /* Get space for the source file structure itself.  */
  struct macro_source_file *f = macro_alloc (sizeof (*f), t);

  memset (f, 0, sizeof (*f));
  f->table = t;
  f->filename = macro_bcache_str (t, filename);
  f->includes = 0;

  return f;
}


/* Free a source file, and all the source files it #included.  */
static void
free_macro_source_file (struct macro_source_file *src)
{
  struct macro_source_file *child, *next_child;

  /* Free this file's children.  */
  for (child = src->includes; child; child = next_child)
    {
      next_child = child->next_included;
      free_macro_source_file (child);
    }

  macro_bcache_free (src->table, (char *) src->filename);
  macro_free (src, src->table);
}


struct macro_source_file *
macro_set_main (struct macro_table *t,
                const char *filename)
{
  /* You can't change a table's main source file.  What would that do
     to the tree?  */
  gdb_assert (! t->main_source);

  t->main_source = new_source_file (t, filename);

  return t->main_source;
}


struct macro_source_file *
macro_main (struct macro_table *t)
{
  gdb_assert (t->main_source);

  return t->main_source;
}


struct macro_source_file *
macro_include (struct macro_source_file *source,
               int line,
               const char *included)
{
  struct macro_source_file *new;
  struct macro_source_file **link;

  /* Find the right position in SOURCE's `includes' list for the new
     file.  Scan until we find the first file we shouldn't follow ---
     which is therefore the file we should directly precede --- or
     reach the end of the list.  */
  for (link = &source->includes;
       *link && line < (*link)->included_at_line;
       link = &(*link)->next_included)
    ;

  /* Did we find another file already #included at the same line as
     the new one?  */
  if (*link && line == (*link)->included_at_line)
    {
      /* This means the compiler is emitting bogus debug info.  (GCC
         circa March 2002 did this.)  It also means that the splay
         tree ordering function, macro_tree_compare, will abort,
         because it can't tell which #inclusion came first.  But GDB
         should tolerate bad debug info.  So:

         First, squawk.  */
      static struct complaint bogus_inclusion_line = {
        "both `%s' and `%s' allegedly #included at %s:%d", 0, 0
      };

      complain (&bogus_inclusion_line, 
                included, (*link)->filename, source->filename, line);

      /* Now, choose a new, unoccupied line number for this
         #inclusion, after the alleged #inclusion line.  */
      while (*link && line == (*link)->included_at_line)
        {
          /* This line number is taken, so try the next line.  */
          line++;
          link = &(*link)->next_included;
        }
    }

  /* At this point, we know that LINE is an unused line number, and
     *LINK points to the entry an #inclusion at that line should
     precede.  */
  new = new_source_file (source->table, included);
  new->included_by = source;
  new->included_at_line = line;
  new->next_included = *link;
  *link = new;

  return new;
}


struct macro_source_file *
macro_lookup_inclusion (struct macro_source_file *source, const char *name)
{
  /* Is SOURCE itself named NAME?  */
  if (! strcmp (name, source->filename))
    return source;

  /* The filename in the source structure is probably a full path, but
     NAME could be just the final component of the name.  */
  {
    int name_len = strlen (name);
    int src_name_len = strlen (source->filename);

    /* We do mean < here, and not <=; if the lengths are the same,
       then the strcmp above should have triggered, and we need to
       check for a slash here.  */
    if (name_len < src_name_len
        && source->filename[src_name_len - name_len - 1] == '/'
        && ! strcmp (name, source->filename + src_name_len - name_len))
      return source;
  }

  /* It's not us.  Try all our children, and return the lowest.  */
  {
    struct macro_source_file *child;
    struct macro_source_file *best = 0;
    int best_depth;

    for (child = source->includes; child; child = child->next_included)
      {
        struct macro_source_file *result
          = macro_lookup_inclusion (child, name);

        if (result)
          {
            int result_depth = inclusion_depth (result);

            if (! best || result_depth < best_depth)
              {
                best = result;
                best_depth = result_depth;
              }
          }
      }

    return best;
  }
}



/* Registering and looking up macro definitions.  */


/* Construct a definition for a macro in table T.  Cache all strings,
   and the macro_definition structure itself, in T's bcache.  */
static struct macro_definition *
new_macro_definition (struct macro_table *t,
                      enum macro_kind kind,
                      int argc, const char **argv,
                      const char *replacement)
{
  struct macro_definition *d = macro_alloc (sizeof (*d), t);

  memset (d, 0, sizeof (*d));
  d->table = t;
  d->kind = kind;
  d->replacement = macro_bcache_str (t, replacement);

  if (kind == macro_function_like)
    {
      int i;
      const char **cached_argv;
      int cached_argv_size = argc * sizeof (*cached_argv);

      /* Bcache all the arguments.  */
      cached_argv = alloca (cached_argv_size);
      for (i = 0; i < argc; i++)
        cached_argv[i] = macro_bcache_str (t, argv[i]);

      /* Now bcache the array of argument pointers itself.  */
      d->argv = macro_bcache (t, cached_argv, cached_argv_size);
      d->argc = argc;
    }

  /* We don't bcache the entire definition structure because it's got
     a pointer to the macro table in it; since each compilation unit
     has its own macro table, you'd only get bcache hits for identical
     definitions within a compilation unit, which seems unlikely.

     "So, why do macro definitions have pointers to their macro tables
     at all?"  Well, when the splay tree library wants to free a
     node's value, it calls the value freeing function with nothing
     but the value itself.  It makes the (apparently reasonable)
     assumption that the value carries enough information to free
     itself.  But not all macro tables have bcaches, so not all macro
     definitions would be bcached.  There's no way to tell whether a
     given definition is bcached without knowing which table the
     definition belongs to.  ...  blah.  The thing's only sixteen
     bytes anyway, and we can still bcache the name, args, and
     definition, so we just don't bother bcaching the definition
     structure itself.  */
  return d;
}


/* Free a macro definition.  */
static void
macro_tree_delete_value (void *untyped_definition)
{
  struct macro_definition *d = (struct macro_definition *) untyped_definition;
  struct macro_table *t = d->table;

  if (d->kind == macro_function_like)
    {
      int i;

      for (i = 0; i < d->argc; i++)
        macro_bcache_free (t, (char *) d->argv[i]);
      macro_bcache_free (t, (char **) d->argv);
    }
  
  macro_bcache_free (t, (char *) d->replacement);
  macro_free (d, t);
}


/* Find the splay tree node for the definition of NAME at LINE in
   SOURCE, or zero if there is none.  */
static splay_tree_node
find_definition (const char *name,
                 struct macro_source_file *file,
                 int line)
{
  struct macro_table *t = file->table;
  splay_tree_node n;

  /* Construct a macro_key object, just for the query.  */
  struct macro_key query;

  query.name = name;
  query.start_file = file;
  query.start_line = line;
  query.end_file = 0;

  n = splay_tree_lookup (t->definitions, (splay_tree_key) &query);
  if (! n)
    {
      /* It's okay for us to do two queries like this: the real work
         of the searching is done when we splay, and splaying the tree
         a second time at the same key is a constant time operation.
         If this still bugs you, you could always just extend the
         splay tree library with a predecessor-or-equal operation, and
         use that.  */
      splay_tree_node pred = splay_tree_predecessor (t->definitions,
                                                     (splay_tree_key) &query);
     
      if (pred)
        {
          /* Make sure this predecessor actually has the right name.
             We just want to search within a given name's definitions.  */
          struct macro_key *found = (struct macro_key *) pred->key;

          if (! strcmp (found->name, name))
            n = pred;
        }
    }

  if (n)
    {
      struct macro_key *found = (struct macro_key *) n->key;

      /* Okay, so this definition has the right name, and its scope
         begins before the given source location.  But does its scope
         end after the given source location?  */
      if (compare_locations (file, line, found->end_file, found->end_line) < 0)
        return n;
      else
        return 0;
    }
  else
    return 0;
}


/* If NAME already has a definition in scope at LINE in FILE, and
   return the key.  Otherwise, return zero.  */
static struct macro_key *
check_for_redefinition (struct macro_source_file *source, int line,
                        const char *name)
{
  splay_tree_node n = find_definition (name, source, line);

  /* This isn't really right.  There's nothing wrong with redefining a
     macro if the new replacement list is the same as the old one.  */
  if (n)
    {
      struct macro_key *found_key = (struct macro_key *) n->key;
      static struct complaint macro_redefined = {
        "macro `%s' redefined at %s:%d;"
        "original definition at %s:%d", 0, 0
      };
      complain (&macro_redefined, name,
                source->filename, line,
                found_key->start_file->filename,
                found_key->start_line);
      return found_key;
    }
  else
    return 0;
}


void
macro_define_object (struct macro_source_file *source, int line,
                     const char *name, const char *replacement)
{
  struct macro_table *t = source->table;
  struct macro_key *k;
  struct macro_definition *d;

  k = check_for_redefinition (source, line, name);

  /* If we're redefining a symbol, and the existing key would be
     identical to our new key, then the splay_tree_insert function
     will try to delete the old definition.  When the definition is
     living on an obstack, this isn't a happy thing.

     Since this only happens in the presence of questionable debug
     info, we just ignore all definitions after the first.  The only
     case I know of where this arises is in GCC's output for
     predefined macros, and all the definitions are the same in that
     case.  */
  if (k && ! key_compare (k, name, source, line))
    return;

  k = new_macro_key (t, name, source, line);
  d = new_macro_definition (t, macro_object_like, 0, 0, replacement);
  splay_tree_insert (t->definitions, (splay_tree_key) k, (splay_tree_value) d);
}


void
macro_define_function (struct macro_source_file *source, int line,
                       const char *name, int argc, const char **argv,
                       const char *replacement)
{
  struct macro_table *t = source->table;
  struct macro_key *k;
  struct macro_definition *d;

  k = check_for_redefinition (source, line, name);

  /* See comments about duplicate keys in macro_define_object.  */
  if (k && ! key_compare (k, name, source, line))
    return;

  /* We should also check here that all the argument names in ARGV are
     distinct.  */

  k = new_macro_key (t, name, source, line);
  d = new_macro_definition (t, macro_function_like, argc, argv, replacement);
  splay_tree_insert (t->definitions, (splay_tree_key) k, (splay_tree_value) d);
}


void
macro_undef (struct macro_source_file *source, int line,
             const char *name)
{
  splay_tree_node n = find_definition (name, source, line);

  if (n)
    {
      /* This function is the only place a macro's end-of-scope
         location gets set to anything other than "end of the
         compilation unit" (i.e., end_file is zero).  So if this macro
         already has its end-of-scope set, then we're probably seeing
         a second #undefinition for the same #definition.  */
      struct macro_key *key = (struct macro_key *) n->key;

      if (key->end_file)
        {
          static struct complaint double_undef = {
            "macro '%s' is #undefined twice, at %s:%d and %s:%d",
            0, 0
          };
          complain (&double_undef, name, source->filename, line,
                    key->end_file->filename, key->end_line);
        }

      /* Whatever the case, wipe out the old ending point, and 
         make this the ending point.  */
      key->end_file = source;
      key->end_line = line;
    }
  else
    {
      /* According to the ISO C standard, an #undef for a symbol that
         has no macro definition in scope is ignored.  So we should
         ignore it too.  */
#if 0
      static struct complaint no_macro_to_undefine = {
        "no definition for macro `%s' in scope to #undef at %s:%d",
        0, 0
      };
      complain (&no_macro_to_undefine, name, source->filename, line);
#endif
    }
}


struct macro_definition *
macro_lookup_definition (struct macro_source_file *source,
                         int line, const char *name)
{
  splay_tree_node n = find_definition (name, source, line);

  if (n)
    return (struct macro_definition *) n->value;
  else
    return 0;
}


struct macro_source_file *
macro_definition_location (struct macro_source_file *source,
                           int line,
                           const char *name,
                           int *definition_line)
{
  splay_tree_node n = find_definition (name, source, line);

  if (n)
    {
      struct macro_key *key = (struct macro_key *) n->key;
      *definition_line = key->start_line;
      return key->start_file;
    }
  else
    return 0;
}



/* Creating and freeing macro tables.  */


struct macro_table *
new_macro_table (struct obstack *obstack,
                 struct bcache *b)
{
  struct macro_table *t;

  /* First, get storage for the `struct macro_table' itself.  */
  if (obstack)
    t = obstack_alloc (obstack, sizeof (*t));
  else
    t = xmalloc (sizeof (*t));

  memset (t, 0, sizeof (*t));
  t->obstack = obstack;
  t->bcache = b;
  t->main_source = 0;
  t->definitions = (splay_tree_new_with_allocator
                    (macro_tree_compare,
                     ((splay_tree_delete_key_fn) macro_tree_delete_key),
                     ((splay_tree_delete_value_fn) macro_tree_delete_value),
                     ((splay_tree_allocate_fn) macro_alloc),
                     ((splay_tree_deallocate_fn) macro_free),
                     t));
  
  return t;
}


void
free_macro_table (struct macro_table *table)
{
  /* Free the source file tree.  */
  free_macro_source_file (table->main_source);

  /* Free the table of macro definitions.  */
  splay_tree_delete (table->definitions);
}
@


1.1.2.2
log
@Revert 8 May change; it's going to be revised.
@
text
@@


1.1.2.3
log
@Add first preprocessor macro-expansion files.
* macroexp.c, macroexp.h, macrotab.c, macrotab.h: New files.
* Makefile.in (SFILES): Add macrotab.c, macroexp.c.
(splay_tree_h, macroexp_h, macrotab_h): New variable.
(HFILES_NO_SRCDIR): Add macrotab.h, macroexp.h.
(COMMON_OBS): Add macrotab.o, macroexp.o.
(macroexp.o, macrotab.o): New rules.
@
text
@@


