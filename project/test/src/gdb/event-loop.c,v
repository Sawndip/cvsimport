head	1.55;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.55
	gdb_7_6-2013-04-26-release:1.55
	gdb_7_6-branch:1.55.0.2
	gdb_7_6-2013-03-12-branchpoint:1.55
	gdb_7_5_1-2012-11-29-release:1.52
	gdb_7_5-2012-08-17-release:1.52
	gdb_7_5-branch:1.52.0.2
	gdb_7_5-2012-07-18-branchpoint:1.52
	gdb_7_4_1-2012-04-26-release:1.51.2.1
	gdb_7_4-2012-01-24-release:1.51.2.1
	gdb_7_4-branch:1.51.0.2
	gdb_7_4-2011-12-13-branchpoint:1.51
	gdb_7_3_1-2011-09-04-release:1.49
	gdb_7_3-2011-07-26-release:1.49
	gdb_7_3-branch:1.49.0.2
	gdb_7_3-2011-04-01-branchpoint:1.49
	gdb_7_2-2010-09-02-release:1.45
	gdb_7_2-branch:1.45.0.2
	gdb_7_2-2010-07-07-branchpoint:1.45
	gdb_7_1-2010-03-18-release:1.42
	gdb_7_1-branch:1.42.0.2
	gdb_7_1-2010-02-18-branchpoint:1.42
	gdb_7_0_1-2009-12-22-release:1.39
	gdb_7_0-2009-10-06-release:1.39
	gdb_7_0-branch:1.39.0.4
	gdb_7_0-2009-09-16-branchpoint:1.39
	arc-sim-20090309:1.34
	msnyder-checkpoint-072509-branch:1.39.0.2
	msnyder-checkpoint-072509-branchpoint:1.39
	arc-insight_6_8-branch:1.34.0.6
	arc-insight_6_8-branchpoint:1.34
	insight_6_8-branch:1.34.0.4
	insight_6_8-branchpoint:1.34
	reverse-20081226-branch:1.38.0.4
	reverse-20081226-branchpoint:1.38
	multiprocess-20081120-branch:1.38.0.2
	multiprocess-20081120-branchpoint:1.38
	reverse-20080930-branch:1.37.0.6
	reverse-20080930-branchpoint:1.37
	reverse-20080717-branch:1.37.0.4
	reverse-20080717-branchpoint:1.37
	msnyder-reverse-20080609-branch:1.37.0.2
	msnyder-reverse-20080609-branchpoint:1.37
	drow-reverse-20070409-branch:1.30.0.2
	drow-reverse-20070409-branchpoint:1.30
	gdb_6_8-2008-03-27-release:1.34
	gdb_6_8-branch:1.34.0.2
	gdb_6_8-2008-02-26-branchpoint:1.34
	gdb_6_7_1-2007-10-29-release:1.33
	gdb_6_7-2007-10-10-release:1.33
	gdb_6_7-branch:1.33.0.2
	gdb_6_7-2007-09-07-branchpoint:1.33
	insight_6_6-20070208-release:1.29
	gdb_6_6-2006-12-18-release:1.29
	gdb_6_6-branch:1.29.0.18
	gdb_6_6-2006-11-15-branchpoint:1.29
	insight_6_5-20061003-release:1.29
	gdb-csl-symbian-6_4_50_20060226-12:1.29
	gdb-csl-sourcerygxx-3_4_4-25:1.26.8.1
	nickrob-async-20060828-mergepoint:1.29
	gdb-csl-symbian-6_4_50_20060226-11:1.29
	gdb-csl-sourcerygxx-4_1-17:1.29
	gdb-csl-20060226-branch-local-2:1.29
	gdb-csl-sourcerygxx-4_1-14:1.29
	gdb-csl-sourcerygxx-4_1-13:1.29
	gdb-csl-sourcerygxx-4_1-12:1.29
	gdb-csl-sourcerygxx-3_4_4-21:1.29
	gdb_6_5-20060621-release:1.29
	gdb-csl-sourcerygxx-4_1-9:1.29
	gdb-csl-sourcerygxx-4_1-8:1.29
	gdb-csl-sourcerygxx-4_1-7:1.29
	gdb-csl-arm-2006q1-6:1.29
	gdb-csl-sourcerygxx-4_1-6:1.29
	gdb-csl-symbian-6_4_50_20060226-10:1.29
	gdb-csl-symbian-6_4_50_20060226-9:1.29
	gdb-csl-symbian-6_4_50_20060226-8:1.29
	gdb-csl-coldfire-4_1-11:1.29
	gdb-csl-sourcerygxx-3_4_4-19:1.29
	gdb-csl-coldfire-4_1-10:1.29
	gdb_6_5-branch:1.29.0.16
	gdb_6_5-2006-05-14-branchpoint:1.29
	gdb-csl-sourcerygxx-4_1-5:1.29
	nickrob-async-20060513-branch:1.29.0.14
	nickrob-async-20060513-branchpoint:1.29
	gdb-csl-sourcerygxx-4_1-4:1.29
	msnyder-reverse-20060502-branch:1.29.0.12
	msnyder-reverse-20060502-branchpoint:1.29
	gdb-csl-morpho-4_1-4:1.29
	gdb-csl-sourcerygxx-3_4_4-17:1.29
	readline_5_1-import-branch:1.29.0.10
	readline_5_1-import-branchpoint:1.29
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.29
	gdb-csl-symbian-20060226-branch:1.29.0.8
	gdb-csl-symbian-20060226-branchpoint:1.29
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.29
	msnyder-reverse-20060331-branch:1.29.0.6
	msnyder-reverse-20060331-branchpoint:1.29
	gdb-csl-available-20060303-branch:1.29.0.4
	gdb-csl-available-20060303-branchpoint:1.29
	gdb-csl-20060226-branch:1.29.0.2
	gdb-csl-20060226-branchpoint:1.29
	gdb_6_4-20051202-release:1.26
	msnyder-fork-checkpoint-branch:1.26.0.10
	msnyder-fork-checkpoint-branchpoint:1.26
	gdb-csl-gxxpro-6_3-branch:1.26.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.26
	gdb_6_4-branch:1.26.0.6
	gdb_6_4-2005-11-01-branchpoint:1.26
	gdb-csl-arm-20051020-branch:1.26.0.4
	gdb-csl-arm-20051020-branchpoint:1.26
	msnyder-tracepoint-checkpoint-branch:1.26.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.26
	gdb-csl-arm-20050325-2005-q1b:1.24.2.1
	gdb-csl-arm-20050325-2005-q1a:1.24.2.1
	csl-arm-20050325-branch:1.24.0.2
	csl-arm-20050325-branchpoint:1.24
	gdb-post-i18n-errorwarning-20050211:1.22
	gdb-pre-i18n-errorwarning-20050211:1.22
	gdb_6_3-20041109-release:1.21
	gdb_6_3-branch:1.21.0.56
	gdb_6_3-20041019-branchpoint:1.21
	drow_intercu-merge-20040921:1.21
	drow_intercu-merge-20040915:1.21
	jimb-gdb_6_2-e500-branch:1.21.0.58
	jimb-gdb_6_2-e500-branchpoint:1.21
	gdb_6_2-20040730-release:1.21
	gdb_6_2-branch:1.21.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.21
	gdb_6_1_1-20040616-release:1.21
	gdb_6_1-2004-04-05-release:1.21
	drow_intercu-merge-20040402:1.21
	drow_intercu-merge-20040327:1.21
	ezannoni_pie-20040323-branch:1.21.0.52
	ezannoni_pie-20040323-branchpoint:1.21
	cagney_tramp-20040321-mergepoint:1.21
	cagney_tramp-20040309-branch:1.21.0.50
	cagney_tramp-20040309-branchpoint:1.21
	gdb_6_1-branch:1.21.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.21
	drow_intercu-20040221-branch:1.21.0.46
	drow_intercu-20040221-branchpoint:1.21
	cagney_bfdfile-20040213-branch:1.21.0.44
	cagney_bfdfile-20040213-branchpoint:1.21
	drow-cplus-merge-20040208:1.21
	carlton_dictionary-20040126-merge:1.21
	cagney_bigcore-20040122-branch:1.21.0.42
	cagney_bigcore-20040122-branchpoint:1.21
	drow-cplus-merge-20040113:1.21
	drow-cplus-merge-20031224:1.21
	drow-cplus-merge-20031220:1.21
	carlton_dictionary-20031215-merge:1.21
	drow-cplus-merge-20031214:1.21
	carlton-dictionary-20031111-merge:1.21
	gdb_6_0-2003-10-04-release:1.21
	kettenis_sparc-20030918-branch:1.21.0.40
	kettenis_sparc-20030918-branchpoint:1.21
	carlton_dictionary-20030917-merge:1.21
	ezannoni_pie-20030916-branchpoint:1.21
	ezannoni_pie-20030916-branch:1.21.0.38
	cagney_x86i386-20030821-branch:1.21.0.36
	cagney_x86i386-20030821-branchpoint:1.21
	carlton_dictionary-20030805-merge:1.21
	carlton_dictionary-20030627-merge:1.21
	gdb_6_0-branch:1.21.0.34
	gdb_6_0-2003-06-23-branchpoint:1.21
	jimb-ppc64-linux-20030613-branch:1.21.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.21
	cagney_convert-20030606-branch:1.21.0.30
	cagney_convert-20030606-branchpoint:1.21
	cagney_writestrings-20030508-branch:1.21.0.28
	cagney_writestrings-20030508-branchpoint:1.21
	jimb-ppc64-linux-20030528-branch:1.21.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.21
	carlton_dictionary-20030523-merge:1.21
	cagney_fileio-20030521-branch:1.21.0.24
	cagney_fileio-20030521-branchpoint:1.21
	kettenis_i386newframe-20030517-mergepoint:1.21
	jimb-ppc64-linux-20030509-branch:1.21.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.21
	kettenis_i386newframe-20030504-mergepoint:1.21
	carlton_dictionary-20030430-merge:1.21
	kettenis_i386newframe-20030419-branch:1.21.0.20
	kettenis_i386newframe-20030419-branchpoint:1.21
	carlton_dictionary-20030416-merge:1.21
	cagney_frameaddr-20030409-mergepoint:1.21
	kettenis_i386newframe-20030406-branch:1.21.0.18
	kettenis_i386newframe-20030406-branchpoint:1.21
	cagney_frameaddr-20030403-branchpoint:1.21
	cagney_frameaddr-20030403-branch:1.21.0.16
	cagney_framebase-20030330-mergepoint:1.21
	cagney_framebase-20030326-branch:1.21.0.14
	cagney_framebase-20030326-branchpoint:1.21
	cagney_lazyid-20030317-branch:1.21.0.12
	cagney_lazyid-20030317-branchpoint:1.21
	kettenis-i386newframe-20030316-mergepoint:1.21
	offbyone-20030313-branch:1.21.0.10
	offbyone-20030313-branchpoint:1.21
	kettenis-i386newframe-20030308-branch:1.21.0.8
	kettenis-i386newframe-20030308-branchpoint:1.21
	carlton_dictionary-20030305-merge:1.21
	cagney_offbyone-20030303-branch:1.21.0.6
	cagney_offbyone-20030303-branchpoint:1.21
	carlton_dictionary-20030207-merge:1.21
	interps-20030203-mergepoint:1.21
	interps-20030202-branch:1.21.0.4
	interps-20030202-branchpoint:1.21
	cagney-unwind-20030108-branch:1.21.0.2
	cagney-unwind-20030108-branchpoint:1.21
	carlton_dictionary-20021223-merge:1.21
	gdb_5_3-2002-12-12-release:1.18.10.1
	carlton_dictionary-20021115-merge:1.21
	kseitz_interps-20021105-merge:1.20
	kseitz_interps-20021103-merge:1.20
	drow-cplus-merge-20021020:1.20
	drow-cplus-merge-20021025:1.20
	carlton_dictionary-20021025-merge:1.20
	carlton_dictionary-20021011-merge:1.20
	drow-cplus-branch:1.20.0.2
	drow-cplus-branchpoint:1.20
	kseitz_interps-20020930-merge:1.19
	carlton_dictionary-20020927-merge:1.19
	carlton_dictionary-branch:1.19.0.2
	carlton_dictionary-20020920-branchpoint:1.19
	gdb_5_3-branch:1.18.0.10
	gdb_5_3-2002-09-04-branchpoint:1.18
	kseitz_interps-20020829-merge:1.18
	cagney_sysregs-20020825-branch:1.18.0.8
	cagney_sysregs-20020825-branchpoint:1.18
	readline_4_3-import-branch:1.18.0.6
	readline_4_3-import-branchpoint:1.18
	gdb_5_2_1-2002-07-23-release:1.17
	kseitz_interps-20020528-branch:1.18.0.4
	kseitz_interps-20020528-branchpoint:1.18
	cagney_regbuf-20020515-branch:1.18.0.2
	cagney_regbuf-20020515-branchpoint:1.18
	jimb-macro-020506-branch:1.17.0.4
	jimb-macro-020506-branchpoint:1.17
	gdb_5_2-2002-04-29-release:1.17
	gdb_5_2-branch:1.17.0.2
	gdb_5_2-2002-03-03-branchpoint:1.17
	gdb_5_1_1-2002-01-24-release:1.16
	gdb_5_1_0_1-2002-01-03-release:1.16
	cygnus_cvs_20020108_pre:1.17
	gdb_5_1_0_1-2002-01-03-branchpoint:1.16
	gdb_5_1_0_1-2002-01-03-branch:1.16.0.8
	gdb_5_1-2001-11-21-release:1.16
	gdb_s390-2001-09-26-branch:1.16.0.6
	gdb_s390-2001-09-26-branchpoint:1.16
	gdb_5_1-2001-07-29-branch:1.16.0.4
	gdb_5_1-2001-07-29-branchpoint:1.16
	dberlin-typesystem-branch:1.16.0.2
	dberlin-typesystem-branchpoint:1.16
	gdb-post-ptid_t-2001-05-03:1.16
	gdb-pre-ptid_t-2001-05-03:1.16
	insight-precleanup-2001-01-01:1.9
	gdb-post-protoization-2000-07-29:1.7
	gdb-pre-protoization-2000-07-29:1.7
	gdb-premipsmulti-2000-06-06-branch:1.6.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.6
	gdb-post-params-removal-2000-06-04:1.6
	gdb-pre-params-removal-2000-06-04:1.6
	gdb-post-params-removal-2000-05-28:1.6
	gdb-pre-params-removal-2000-05-28:1.6
	gdb_5_0-2000-05-19-release:1.6
	gdb_4_18_2-2000-05-18-release:1.6
	gdb_4_95_1-2000-05-11-snapshot:1.6
	gdb_4_95_0-2000-04-27-snapshot:1.6
	gdb_5_0-2000-04-10-branch:1.6.0.2
	gdb_5_0-2000-04-10-branchpoint:1.6
	repo-unification-2000-02-06:1.1.1.15
	insight-2000-02-04:1.1.1.15
	gdb-2000-02-04:1.1.1.15
	gdb-2000-02-02:1.1.1.15
	gdb-2000-02-01:1.1.1.15
	gdb-2000-01-31:1.1.1.15
	gdb-2000-01-26:1.1.1.15
	gdb-2000-01-24:1.1.1.15
	gdb-2000-01-17:1.1.1.15
	gdb-2000-01-10:1.1.1.15
	gdb-2000-01-05:1.1.1.15
	gdb-1999-12-21:1.1.1.15
	gdb-1999-12-13:1.1.1.15
	gdb-1999-12-07:1.1.1.14
	gdb-1999-12-06:1.1.1.14
	gdb-1999-11-16:1.1.1.14
	gdb-1999-11-08:1.1.1.14
	gdb-1999-11-01:1.1.1.13
	gdb-1999-10-25:1.1.1.13
	gdb-1999-10-18:1.1.1.13
	gdb-1999-10-11:1.1.1.13
	gdb-1999-10-04:1.1.1.13
	gdb-1999-09-28:1.1.1.12
	gdb-1999-09-21:1.1.1.11
	gdb-1999-09-13:1.1.1.10
	gdb-1999-09-08:1.1.1.9
	gdb-1999-08-30:1.1.1.9
	gdb-1999-08-23:1.1.1.9
	gdb-1999-08-16:1.1.1.9
	gdb-1999-08-09:1.1.1.8
	gdb-1999-08-02:1.1.1.8
	gdb-1999-07-26:1.1.1.8
	gdb-1999-07-19:1.1.1.8
	gdb-1999-07-12:1.1.1.7
	gdb-post-reformat-19990707:1.1.1.7
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.7
	gdb-pre-reformat-19990707:1.1.1.6
	gdb-1999-07-07:1.1.1.6
	gdb-1999-07-05:1.1.1.6
	gdb-1999-06-28:1.1.1.5
	gdb-1999-06-21:1.1.1.4
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.55
date	2013.01.25.14.17.09;	author qiyao;	state Exp;
branches;
next	1.54;

1.54
date	2013.01.25.14.14.18;	author qiyao;	state Exp;
branches;
next	1.53;

1.53
date	2013.01.01.06.32.41;	author brobecke;	state Exp;
branches;
next	1.52;

1.52
date	2012.01.04.08.17.01;	author brobecke;	state Exp;
branches;
next	1.51;

1.51
date	2011.08.04.20.09.45;	author palves;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2011.05.25.07.59.04;	author schwab;	state Exp;
branches;
next	1.49;

1.49
date	2011.03.11.22.31.44;	author msnyder;	state Exp;
branches;
next	1.48;

1.48
date	2011.01.05.22.22.48;	author msnyder;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.01.15.33.03;	author brobecke;	state Exp;
branches;
next	1.46;

1.46
date	2010.12.29.00.58.14;	author msnyder;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.25.15.48.43;	author devans;	state Exp;
branches;
next	1.44;

1.44
date	2010.05.14.18.35.11;	author msnyder;	state Exp;
branches;
next	1.43;

1.43
date	2010.05.03.20.58.21;	author devans;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.19.09.39.11;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.01.07.31.31;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.06.23.27.05;	author muller;	state Exp;
branches;
next	1.39;

1.39
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.38;

1.38
date	2008.10.24.19.33.39;	author palves;	state Exp;
branches;
next	1.37;

1.37
date	2008.03.14.19.55.51;	author vprus;	state Exp;
branches;
next	1.36;

1.36
date	2008.03.14.18.57.43;	author vprus;	state Exp;
branches;
next	1.35;

1.35
date	2008.03.05.17.21.10;	author drow;	state Exp;
branches;
next	1.34;

1.34
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.33;

1.33
date	2007.08.23.18.08.28;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2007.08.18.20.05.48;	author msnyder;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.16.14.51.22;	author msnyder;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.29;

1.29
date	2006.02.10.22.01.43;	author drow;	state Exp;
branches
	1.29.14.1;
next	1.28;

1.28
date	2006.01.14.05.13.21;	author mmitchel;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.25.23.51.33;	author mmitchel;	state Exp;
branches
	1.26.8.1;
next	1.25;

1.25
date	2005.04.25.21.45.56;	author mmitchel;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.12.00.39.18;	author cagney;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2005.02.11.18.13.49;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.12.18.31.30;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.05.21.17.33;	author ezannoni;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.30.21.25.47;	author ezannoni;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2002.09.10.19.53.24;	author ciceron;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2002.05.14.15.21.10;	author kseitz;	state Exp;
branches
	1.18.4.1
	1.18.10.1;
next	1.17;

1.17
date	2001.11.27.04.15.09;	author tromey;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.27.20.36.23;	author jtc;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.26.11.37.51;	author eliz;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.20.00.54.42;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.07.02.57.08;	author jtc;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.06.08.21.07;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.08.06.03.52;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.31.15.46.35;	author dsmith;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.15.01.01.46;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.01.23.52.09;	author davea;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.05.10.25.43;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.23.03.48.13;	author ezannoni;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.23.03.45.13;	author ezannoni;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.20.19.59.38;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.06.17.07.03;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.15.56.37;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.05.11.20.29.07;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.51.2.1
date	2012.01.06.04.43.11;	author brobecke;	state Exp;
branches;
next	;

1.29.14.1
date	2006.05.12.07.40.23;	author nickrob;	state Exp;
branches;
next	;

1.26.8.1
date	2006.01.14.05.14.26;	author mmitchel;	state Exp;
branches;
next	;

1.24.2.1
date	2005.03.28.19.10.24;	author mmitchel;	state Exp;
branches;
next	;

1.20.2.1
date	2003.12.14.20.27.12;	author drow;	state Exp;
branches;
next	;

1.19.2.1
date	2002.10.11.22.22.53;	author carlton;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.11.15.19.18.42;	author carlton;	state Exp;
branches;
next	;

1.18.4.1
date	2002.05.28.23.47.01;	author kseitz;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2002.10.01.00.46.07;	author kseitz;	state Exp;
branches;
next	1.18.4.3;

1.18.4.3
date	2002.11.04.21.43.51;	author ezannoni;	state Exp;
branches;
next	1.18.4.4;

1.18.4.4
date	2002.11.05.21.12.24;	author ezannoni;	state Exp;
branches;
next	;

1.18.10.1
date	2002.09.10.19.55.43;	author ciceron;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.11.20.29.07;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.05.25.18.01.47;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.06.14.18.07.24;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.06.21.13.24.49;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.06.28.16.00.25;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.07.05.17.52.44;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.07.07.20.05.52;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.07.19.23.27.53;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.08.16.19.52.29;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.09.13.21.37.23;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.09.22.03.24.27;	author jsm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.09.28.21.52.05;	author jsm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.10.05.23.08.11;	author jsm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.11.09.01.23.03;	author jsm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.12.14.01.05.30;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.55
log
@gdb/
	* event-loop.c: Include "queue.h".
	(gdb_event_p): New typedef.
	(DECLARE_QUEUE_P): Use.
	(DEFINE_QUEUE_P): Use.
	(async_queue_event): Remove.
	(gdb_event_xfree): New.
	(initialize_event_loop): New.
	(process_event): Use QUEUE macros.
	(event_queue): Remove.
	(gdb_wait_for_event): Caller update.
	(check_async_event_handlers): Likewise.
	(poll_timers): Likewise.
	* event-loop.h (initialize_event_loop): Declare.
	* event-loop.c (gdb_event_xfree): New.
	* top.c (gdb_init): Call initialize_event_loop.
@
text
@/* Event loop machinery for GDB, the GNU debugger.
   Copyright (C) 1999-2013 Free Software Foundation, Inc.
   Written by Elena Zannoni <ezannoni@@cygnus.com> of Cygnus Solutions.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "event-loop.h"
#include "event-top.h"
#include "queue.h"

#ifdef HAVE_POLL
#if defined (HAVE_POLL_H)
#include <poll.h>
#elif defined (HAVE_SYS_POLL_H)
#include <sys/poll.h>
#endif
#endif

#include <sys/types.h>
#include "gdb_string.h"
#include <errno.h>
#include <sys/time.h>
#include "exceptions.h"
#include "gdb_assert.h"
#include "gdb_select.h"

/* Tell create_file_handler what events we are interested in.
   This is used by the select version of the event loop.  */

#define GDB_READABLE	(1<<1)
#define GDB_WRITABLE	(1<<2)
#define GDB_EXCEPTION	(1<<3)

/* Data point to pass to the event handler.  */
typedef union event_data
{
  void *ptr;
  int integer;
} event_data;

typedef struct gdb_event gdb_event;
typedef void (event_handler_func) (event_data);

/* Event for the GDB event system.  Events are queued by calling
   async_queue_event and serviced later on by gdb_do_one_event.  An
   event can be, for instance, a file descriptor becoming ready to be
   read.  Servicing an event simply means that the procedure PROC will
   be called.  We have 2 queues, one for file handlers that we listen
   to in the event loop, and one for the file handlers+events that are
   ready.  The procedure PROC associated with each event is dependant
   of the event source.  In the case of monitored file descriptors, it
   is always the same (handle_file_event).  Its duty is to invoke the
   handler associated with the file descriptor whose state change
   generated the event, plus doing other cleanups and such.  In the
   case of async signal handlers, it is
   invoke_async_signal_handler.  */

typedef struct gdb_event
  {
    /* Procedure to call to service this event.  */
    event_handler_func *proc;

    /* Data to pass to the event handler.  */
    event_data data;
  } *gdb_event_p;

/* Information about each file descriptor we register with the event
   loop.  */

typedef struct file_handler
  {
    int fd;			/* File descriptor.  */
    int mask;			/* Events we want to monitor: POLLIN, etc.  */
    int ready_mask;		/* Events that have been seen since
				   the last time.  */
    handler_func *proc;		/* Procedure to call when fd is ready.  */
    gdb_client_data client_data;	/* Argument to pass to proc.  */
    int error;			/* Was an error detected on this fd?  */
    struct file_handler *next_file;	/* Next registered file descriptor.  */
  }
file_handler;

/* PROC is a function to be invoked when the READY flag is set.  This
   happens when there has been a signal and the corresponding signal
   handler has 'triggered' this async_signal_handler for execution.
   The actual work to be done in response to a signal will be carried
   out by PROC at a later time, within process_event.  This provides a
   deferred execution of signal handlers.

   Async_init_signals takes care of setting up such an
   async_signal_handler for each interesting signal.  */

typedef struct async_signal_handler
  {
    int ready;			    /* If ready, call this handler
				       from the main event loop, using
				       invoke_async_handler.  */
    struct async_signal_handler *next_handler;	/* Ptr to next handler.  */
    sig_handler_func *proc;	    /* Function to call to do the work.  */
    gdb_client_data client_data;    /* Argument to async_handler_func.  */
  }
async_signal_handler;

/* PROC is a function to be invoked when the READY flag is set.  This
   happens when the event has been marked with
   MARK_ASYNC_EVENT_HANDLER.  The actual work to be done in response
   to an event will be carried out by PROC at a later time, within
   process_event.  This provides a deferred execution of event
   handlers.  */
typedef struct async_event_handler
  {
    /* If ready, call this handler from the main event loop, using
       invoke_event_handler.  */
    int ready;

    /* Point to next handler.  */
    struct async_event_handler *next_handler;

    /* Function to call to do the work.  */
    async_event_handler_func *proc;

    /* Argument to PROC.  */
    gdb_client_data client_data;
  }
async_event_handler;

DECLARE_QUEUE_P(gdb_event_p);
DEFINE_QUEUE_P(gdb_event_p);
static QUEUE(gdb_event_p) *event_queue = NULL;

/* Gdb_notifier is just a list of file descriptors gdb is interested in.
   These are the input file descriptor, and the target file
   descriptor.  We have two flavors of the notifier, one for platforms
   that have the POLL function, the other for those that don't, and
   only support SELECT.  Each of the elements in the gdb_notifier list is
   basically a description of what kind of events gdb is interested
   in, for each fd.  */

/* As of 1999-04-30 only the input file descriptor is registered with the
   event loop.  */

/* Do we use poll or select ? */
#ifdef HAVE_POLL
#define USE_POLL 1
#else
#define USE_POLL 0
#endif /* HAVE_POLL */

static unsigned char use_poll = USE_POLL;

#ifdef USE_WIN32API
#include <windows.h>
#include <io.h>
#endif

static struct
  {
    /* Ptr to head of file handler list.  */
    file_handler *first_file_handler;

#ifdef HAVE_POLL
    /* Ptr to array of pollfd structures.  */
    struct pollfd *poll_fds;

    /* Timeout in milliseconds for calls to poll().  */
    int poll_timeout;
#endif

    /* Masks to be used in the next call to select.
       Bits are set in response to calls to create_file_handler.  */
    fd_set check_masks[3];

    /* What file descriptors were found ready by select.  */
    fd_set ready_masks[3];

    /* Number of file descriptors to monitor (for poll).  */
    /* Number of valid bits (highest fd value + 1) (for select).  */
    int num_fds;

    /* Time structure for calls to select().  */
    struct timeval select_timeout;

    /* Flag to tell whether the timeout should be used.  */
    int timeout_valid;
  }
gdb_notifier;

/* Structure associated with a timer.  PROC will be executed at the
   first occasion after WHEN.  */
struct gdb_timer
  {
    struct timeval when;
    int timer_id;
    struct gdb_timer *next;
    timer_handler_func *proc;	    /* Function to call to do the work.  */
    gdb_client_data client_data;    /* Argument to async_handler_func.  */
  };

/* List of currently active timers.  It is sorted in order of
   increasing timers.  */
static struct
  {
    /* Pointer to first in timer list.  */
    struct gdb_timer *first_timer;

    /* Id of the last timer created.  */
    int num_timers;
  }
timer_list;

/* All the async_signal_handlers gdb is interested in are kept onto
   this list.  */
static struct
  {
    /* Pointer to first in handler list.  */
    async_signal_handler *first_handler;

    /* Pointer to last in handler list.  */
    async_signal_handler *last_handler;
  }
sighandler_list;

/* All the async_event_handlers gdb is interested in are kept onto
   this list.  */
static struct
  {
    /* Pointer to first in handler list.  */
    async_event_handler *first_handler;

    /* Pointer to last in handler list.  */
    async_event_handler *last_handler;
  }
async_event_handler_list;

static int invoke_async_signal_handlers (void);
static void create_file_handler (int fd, int mask, handler_func *proc,
				 gdb_client_data client_data);
static void handle_file_event (event_data data);
static void check_async_event_handlers (void);
static int gdb_wait_for_event (int);
static void poll_timers (void);


/* Create a generic event, to be enqueued in the event queue for
   processing.  PROC is the procedure associated to the event.  DATA
   is passed to PROC upon PROC invocation.  */

static gdb_event *
create_event (event_handler_func proc, event_data data)
{
  gdb_event *event;

  event = xmalloc (sizeof (*event));
  event->proc = proc;
  event->data = data;

  return event;
}

/* Create a file event, to be enqueued in the event queue for
   processing.  The procedure associated to this event is always
   handle_file_event, which will in turn invoke the one that was
   associated to FD when it was registered with the event loop.  */
static gdb_event *
create_file_event (int fd)
{
  event_data data;

  data.integer = fd;
  return create_event (handle_file_event, data);
}


/* Free EVENT.  */

static void
gdb_event_xfree (struct gdb_event *event)
{
  xfree (event);
}

/* Initialize the event queue.  */

void
initialize_event_loop (void)
{
  event_queue = QUEUE_alloc (gdb_event_p, gdb_event_xfree);
}

/* Process one event.
   The event can be the next one to be serviced in the event queue,
   or an asynchronous event handler can be invoked in response to
   the reception of a signal.
   If an event was processed (either way), 1 is returned otherwise
   0 is returned.
   Scan the queue from head to tail, processing therefore the high
   priority events first, by invoking the associated event handler
   procedure.  */
static int
process_event (void)
{
  /* First let's see if there are any asynchronous event handlers that
     are ready.  These would be the result of invoking any of the
     signal handlers.  */

  if (invoke_async_signal_handlers ())
    return 1;

  /* Look in the event queue to find an event that is ready
     to be processed.  */

  if (!QUEUE_is_empty (gdb_event_p, event_queue))
    {
      /* Let's get rid of the event from the event queue.  We need to
	 do this now because while processing the event, the proc
	 function could end up calling 'error' and therefore jump out
	 to the caller of this function, gdb_do_one_event.  In that
	 case, we would have on the event queue an event wich has been
	 processed, but not deleted.  */
      gdb_event *event_ptr = QUEUE_deque (gdb_event_p, event_queue);
      /* Call the handler for the event.  */
      event_handler_func *proc = event_ptr->proc;
      event_data data = event_ptr->data;

      gdb_event_xfree (event_ptr);

      /* Now call the procedure associated with the event.  */
      (*proc) (data);
      return 1;
    }

  /* This is the case if there are no event on the event queue.  */
  return 0;
}

/* Process one high level event.  If nothing is ready at this time,
   wait for something to happen (via gdb_wait_for_event), then process
   it.  Returns >0 if something was done otherwise returns <0 (this
   can happen if there are no event sources to wait for).  */

int
gdb_do_one_event (void)
{
  static int event_source_head = 0;
  const int number_of_sources = 3;
  int current = 0;

  /* Any events already waiting in the queue?  */
  if (process_event ())
    return 1;

  /* To level the fairness across event sources, we poll them in a
     round-robin fashion.  */
  for (current = 0; current < number_of_sources; current++)
    {
      switch (event_source_head)
	{
	case 0:
	  /* Are any timers that are ready? If so, put an event on the
	     queue.  */
	  poll_timers ();
	  break;
	case 1:
	  /* Are there events already waiting to be collected on the
	     monitored file descriptors?  */
	  gdb_wait_for_event (0);
	  break;
	case 2:
	  /* Are there any asynchronous event handlers ready?  */
	  check_async_event_handlers ();
	  break;
	}

      event_source_head++;
      if (event_source_head == number_of_sources)
	event_source_head = 0;
    }

  /* Handle any new events collected.  */
  if (process_event ())
    return 1;

  /* Block waiting for a new event.  If gdb_wait_for_event returns -1,
     we should get out because this means that there are no event
     sources left.  This will make the event loop stop, and the
     application exit.  */

  if (gdb_wait_for_event (1) < 0)
    return -1;

  /* Handle any new events occurred while waiting.  */
  if (process_event ())
    return 1;

  /* If gdb_wait_for_event has returned 1, it means that one event has
     been handled.  We break out of the loop.  */
  return 1;
}

/* Start up the event loop.  This is the entry point to the event loop
   from the command loop.  */

void
start_event_loop (void)
{
  /* Loop until there is nothing to do.  This is the entry point to
     the event loop engine.  gdb_do_one_event will process one event
     for each invocation.  It blocks waiting for an event and then
     processes it.  */
  while (1)
    {
      volatile struct gdb_exception ex;
      int result = 0;

      TRY_CATCH (ex, RETURN_MASK_ALL)
	{
	  result = gdb_do_one_event ();
	}
      if (ex.reason < 0)
	{
	  exception_print (gdb_stderr, ex);

	  /* If any exception escaped to here, we better enable
	     stdin.  Otherwise, any command that calls async_disable_stdin,
	     and then throws, will leave stdin inoperable.  */
	  async_enable_stdin ();
	  /* If we long-jumped out of do_one_event, we probably didn't
	     get around to resetting the prompt, which leaves readline
	     in a messed-up state.  Reset it here.  */
	  /* FIXME: this should really be a call to a hook that is
	     interface specific, because interfaces can display the
	     prompt in their own way.  */
	  display_gdb_prompt (0);
	  /* This call looks bizarre, but it is required.  If the user
	     entered a command that caused an error,
	     after_char_processing_hook won't be called from
	     rl_callback_read_char_wrapper.  Using a cleanup there
	     won't work, since we want this function to be called
	     after a new prompt is printed.  */
	  if (after_char_processing_hook)
	    (*after_char_processing_hook) ();
	  /* Maybe better to set a flag to be checked somewhere as to
	     whether display the prompt or not.  */
	}
      if (result < 0)
	break;
    }

  /* We are done with the event loop.  There are no more event sources
     to listen to.  So we exit GDB.  */
  return;
}


/* Wrapper function for create_file_handler, so that the caller
   doesn't have to know implementation details about the use of poll
   vs. select.  */
void
add_file_handler (int fd, handler_func * proc, gdb_client_data client_data)
{
#ifdef HAVE_POLL
  struct pollfd fds;
#endif

  if (use_poll)
    {
#ifdef HAVE_POLL
      /* Check to see if poll () is usable.  If not, we'll switch to
         use select.  This can happen on systems like
         m68k-motorola-sys, `poll' cannot be used to wait for `stdin'.
         On m68k-motorola-sysv, tty's are not stream-based and not
         `poll'able.  */
      fds.fd = fd;
      fds.events = POLLIN;
      if (poll (&fds, 1, 0) == 1 && (fds.revents & POLLNVAL))
	use_poll = 0;
#else
      internal_error (__FILE__, __LINE__,
		      _("use_poll without HAVE_POLL"));
#endif /* HAVE_POLL */
    }
  if (use_poll)
    {
#ifdef HAVE_POLL
      create_file_handler (fd, POLLIN, proc, client_data);
#else
      internal_error (__FILE__, __LINE__,
		      _("use_poll without HAVE_POLL"));
#endif
    }
  else
    create_file_handler (fd, GDB_READABLE | GDB_EXCEPTION, 
			 proc, client_data);
}

/* Add a file handler/descriptor to the list of descriptors we are
   interested in.

   FD is the file descriptor for the file/stream to be listened to.

   For the poll case, MASK is a combination (OR) of POLLIN,
   POLLRDNORM, POLLRDBAND, POLLPRI, POLLOUT, POLLWRNORM, POLLWRBAND:
   these are the events we are interested in.  If any of them occurs,
   proc should be called.

   For the select case, MASK is a combination of READABLE, WRITABLE,
   EXCEPTION.  PROC is the procedure that will be called when an event
   occurs for FD.  CLIENT_DATA is the argument to pass to PROC.  */

static void
create_file_handler (int fd, int mask, handler_func * proc, 
		     gdb_client_data client_data)
{
  file_handler *file_ptr;

  /* Do we already have a file handler for this file?  (We may be
     changing its associated procedure).  */
  for (file_ptr = gdb_notifier.first_file_handler; file_ptr != NULL;
       file_ptr = file_ptr->next_file)
    {
      if (file_ptr->fd == fd)
	break;
    }

  /* It is a new file descriptor.  Add it to the list.  Otherwise, just
     change the data associated with it.  */
  if (file_ptr == NULL)
    {
      file_ptr = (file_handler *) xmalloc (sizeof (file_handler));
      file_ptr->fd = fd;
      file_ptr->ready_mask = 0;
      file_ptr->next_file = gdb_notifier.first_file_handler;
      gdb_notifier.first_file_handler = file_ptr;

      if (use_poll)
	{
#ifdef HAVE_POLL
	  gdb_notifier.num_fds++;
	  if (gdb_notifier.poll_fds)
	    gdb_notifier.poll_fds =
	      (struct pollfd *) xrealloc (gdb_notifier.poll_fds,
					  (gdb_notifier.num_fds
					   * sizeof (struct pollfd)));
	  else
	    gdb_notifier.poll_fds =
	      (struct pollfd *) xmalloc (sizeof (struct pollfd));
	  (gdb_notifier.poll_fds + gdb_notifier.num_fds - 1)->fd = fd;
	  (gdb_notifier.poll_fds + gdb_notifier.num_fds - 1)->events = mask;
	  (gdb_notifier.poll_fds + gdb_notifier.num_fds - 1)->revents = 0;
#else
	  internal_error (__FILE__, __LINE__,
			  _("use_poll without HAVE_POLL"));
#endif /* HAVE_POLL */
	}
      else
	{
	  if (mask & GDB_READABLE)
	    FD_SET (fd, &gdb_notifier.check_masks[0]);
	  else
	    FD_CLR (fd, &gdb_notifier.check_masks[0]);

	  if (mask & GDB_WRITABLE)
	    FD_SET (fd, &gdb_notifier.check_masks[1]);
	  else
	    FD_CLR (fd, &gdb_notifier.check_masks[1]);

	  if (mask & GDB_EXCEPTION)
	    FD_SET (fd, &gdb_notifier.check_masks[2]);
	  else
	    FD_CLR (fd, &gdb_notifier.check_masks[2]);

	  if (gdb_notifier.num_fds <= fd)
	    gdb_notifier.num_fds = fd + 1;
	}
    }

  file_ptr->proc = proc;
  file_ptr->client_data = client_data;
  file_ptr->mask = mask;
}

/* Remove the file descriptor FD from the list of monitored fd's: 
   i.e. we don't care anymore about events on the FD.  */
void
delete_file_handler (int fd)
{
  file_handler *file_ptr, *prev_ptr = NULL;
  int i;
#ifdef HAVE_POLL
  int j;
  struct pollfd *new_poll_fds;
#endif

  /* Find the entry for the given file.  */

  for (file_ptr = gdb_notifier.first_file_handler; file_ptr != NULL;
       file_ptr = file_ptr->next_file)
    {
      if (file_ptr->fd == fd)
	break;
    }

  if (file_ptr == NULL)
    return;

  if (use_poll)
    {
#ifdef HAVE_POLL
      /* Create a new poll_fds array by copying every fd's information
         but the one we want to get rid of.  */

      new_poll_fds = (struct pollfd *) 
	xmalloc ((gdb_notifier.num_fds - 1) * sizeof (struct pollfd));

      for (i = 0, j = 0; i < gdb_notifier.num_fds; i++)
	{
	  if ((gdb_notifier.poll_fds + i)->fd != fd)
	    {
	      (new_poll_fds + j)->fd = (gdb_notifier.poll_fds + i)->fd;
	      (new_poll_fds + j)->events = (gdb_notifier.poll_fds + i)->events;
	      (new_poll_fds + j)->revents
		= (gdb_notifier.poll_fds + i)->revents;
	      j++;
	    }
	}
      xfree (gdb_notifier.poll_fds);
      gdb_notifier.poll_fds = new_poll_fds;
      gdb_notifier.num_fds--;
#else
      internal_error (__FILE__, __LINE__,
		      _("use_poll without HAVE_POLL"));
#endif /* HAVE_POLL */
    }
  else
    {
      if (file_ptr->mask & GDB_READABLE)
	FD_CLR (fd, &gdb_notifier.check_masks[0]);
      if (file_ptr->mask & GDB_WRITABLE)
	FD_CLR (fd, &gdb_notifier.check_masks[1]);
      if (file_ptr->mask & GDB_EXCEPTION)
	FD_CLR (fd, &gdb_notifier.check_masks[2]);

      /* Find current max fd.  */

      if ((fd + 1) == gdb_notifier.num_fds)
	{
	  gdb_notifier.num_fds--;
	  for (i = gdb_notifier.num_fds; i; i--)
	    {
	      if (FD_ISSET (i - 1, &gdb_notifier.check_masks[0])
		  || FD_ISSET (i - 1, &gdb_notifier.check_masks[1])
		  || FD_ISSET (i - 1, &gdb_notifier.check_masks[2]))
		break;
	    }
	  gdb_notifier.num_fds = i;
	}
    }

  /* Deactivate the file descriptor, by clearing its mask, 
     so that it will not fire again.  */

  file_ptr->mask = 0;

  /* Get rid of the file handler in the file handler list.  */
  if (file_ptr == gdb_notifier.first_file_handler)
    gdb_notifier.first_file_handler = file_ptr->next_file;
  else
    {
      for (prev_ptr = gdb_notifier.first_file_handler;
	   prev_ptr->next_file != file_ptr;
	   prev_ptr = prev_ptr->next_file)
	;
      prev_ptr->next_file = file_ptr->next_file;
    }
  xfree (file_ptr);
}

/* Handle the given event by calling the procedure associated to the
   corresponding file handler.  Called by process_event indirectly,
   through event_ptr->proc.  EVENT_FILE_DESC is file descriptor of the
   event in the front of the event queue.  */
static void
handle_file_event (event_data data)
{
  file_handler *file_ptr;
  int mask;
#ifdef HAVE_POLL
  int error_mask;
#endif
  int event_file_desc = data.integer;

  /* Search the file handler list to find one that matches the fd in
     the event.  */
  for (file_ptr = gdb_notifier.first_file_handler; file_ptr != NULL;
       file_ptr = file_ptr->next_file)
    {
      if (file_ptr->fd == event_file_desc)
	{
	  /* With poll, the ready_mask could have any of three events
	     set to 1: POLLHUP, POLLERR, POLLNVAL.  These events
	     cannot be used in the requested event mask (events), but
	     they can be returned in the return mask (revents).  We
	     need to check for those event too, and add them to the
	     mask which will be passed to the handler.  */

	  /* See if the desired events (mask) match the received
	     events (ready_mask).  */

	  if (use_poll)
	    {
#ifdef HAVE_POLL
	      /* POLLHUP means EOF, but can be combined with POLLIN to
		 signal more data to read.  */
	      error_mask = POLLHUP | POLLERR | POLLNVAL;
	      mask = file_ptr->ready_mask & (file_ptr->mask | error_mask);

	      if ((mask & (POLLERR | POLLNVAL)) != 0)
		{
		  /* Work in progress.  We may need to tell somebody
		     what kind of error we had.  */
		  if (mask & POLLERR)
		    printf_unfiltered (_("Error detected on fd %d\n"),
				       file_ptr->fd);
		  if (mask & POLLNVAL)
		    printf_unfiltered (_("Invalid or non-`poll'able fd %d\n"),
				       file_ptr->fd);
		  file_ptr->error = 1;
		}
	      else
		file_ptr->error = 0;
#else
	      internal_error (__FILE__, __LINE__,
			      _("use_poll without HAVE_POLL"));
#endif /* HAVE_POLL */
	    }
	  else
	    {
	      if (file_ptr->ready_mask & GDB_EXCEPTION)
		{
		  printf_unfiltered (_("Exception condition detected "
				       "on fd %d\n"), file_ptr->fd);
		  file_ptr->error = 1;
		}
	      else
		file_ptr->error = 0;
	      mask = file_ptr->ready_mask & file_ptr->mask;
	    }

	  /* Clear the received events for next time around.  */
	  file_ptr->ready_mask = 0;

	  /* If there was a match, then call the handler.  */
	  if (mask != 0)
	    (*file_ptr->proc) (file_ptr->error, file_ptr->client_data);
	  break;
	}
    }
}

/* Called by gdb_do_one_event to wait for new events on the monitored
   file descriptors.  Queue file events as they are detected by the
   poll.  If BLOCK and if there are no events, this function will
   block in the call to poll.  Return -1 if there are no file
   descriptors to monitor, otherwise return 0.  */
static int
gdb_wait_for_event (int block)
{
  file_handler *file_ptr;
  gdb_event *file_event_ptr;
  int num_found = 0;
  int i;

  /* Make sure all output is done before getting another event.  */
  gdb_flush (gdb_stdout);
  gdb_flush (gdb_stderr);

  if (gdb_notifier.num_fds == 0)
    return -1;

  if (use_poll)
    {
#ifdef HAVE_POLL
      int timeout;

      if (block)
	timeout = gdb_notifier.timeout_valid ? gdb_notifier.poll_timeout : -1;
      else
	timeout = 0;

      num_found = poll (gdb_notifier.poll_fds,
			(unsigned long) gdb_notifier.num_fds, timeout);

      /* Don't print anything if we get out of poll because of a
	 signal.  */
      if (num_found == -1 && errno != EINTR)
	perror_with_name (("poll"));
#else
      internal_error (__FILE__, __LINE__,
		      _("use_poll without HAVE_POLL"));
#endif /* HAVE_POLL */
    }
  else
    {
      struct timeval select_timeout;
      struct timeval *timeout_p;

      if (block)
	timeout_p = gdb_notifier.timeout_valid
	  ? &gdb_notifier.select_timeout : NULL;
      else
	{
	  memset (&select_timeout, 0, sizeof (select_timeout));
	  timeout_p = &select_timeout;
	}

      gdb_notifier.ready_masks[0] = gdb_notifier.check_masks[0];
      gdb_notifier.ready_masks[1] = gdb_notifier.check_masks[1];
      gdb_notifier.ready_masks[2] = gdb_notifier.check_masks[2];
      num_found = gdb_select (gdb_notifier.num_fds,
			      &gdb_notifier.ready_masks[0],
			      &gdb_notifier.ready_masks[1],
			      &gdb_notifier.ready_masks[2],
			      timeout_p);

      /* Clear the masks after an error from select.  */
      if (num_found == -1)
	{
	  FD_ZERO (&gdb_notifier.ready_masks[0]);
	  FD_ZERO (&gdb_notifier.ready_masks[1]);
	  FD_ZERO (&gdb_notifier.ready_masks[2]);

	  /* Dont print anything if we got a signal, let gdb handle
	     it.  */
	  if (errno != EINTR)
	    perror_with_name (("select"));
	}
    }

  /* Enqueue all detected file events.  */

  if (use_poll)
    {
#ifdef HAVE_POLL
      for (i = 0; (i < gdb_notifier.num_fds) && (num_found > 0); i++)
	{
	  if ((gdb_notifier.poll_fds + i)->revents)
	    num_found--;
	  else
	    continue;

	  for (file_ptr = gdb_notifier.first_file_handler;
	       file_ptr != NULL;
	       file_ptr = file_ptr->next_file)
	    {
	      if (file_ptr->fd == (gdb_notifier.poll_fds + i)->fd)
		break;
	    }

	  if (file_ptr)
	    {
	      /* Enqueue an event only if this is still a new event for
	         this fd.  */
	      if (file_ptr->ready_mask == 0)
		{
		  file_event_ptr = create_file_event (file_ptr->fd);
		  QUEUE_enque (gdb_event_p, event_queue, file_event_ptr);
		}
	      file_ptr->ready_mask = (gdb_notifier.poll_fds + i)->revents;
	    }
	}
#else
      internal_error (__FILE__, __LINE__,
		      _("use_poll without HAVE_POLL"));
#endif /* HAVE_POLL */
    }
  else
    {
      for (file_ptr = gdb_notifier.first_file_handler;
	   (file_ptr != NULL) && (num_found > 0);
	   file_ptr = file_ptr->next_file)
	{
	  int mask = 0;

	  if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[0]))
	    mask |= GDB_READABLE;
	  if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[1]))
	    mask |= GDB_WRITABLE;
	  if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[2]))
	    mask |= GDB_EXCEPTION;

	  if (!mask)
	    continue;
	  else
	    num_found--;

	  /* Enqueue an event only if this is still a new event for
	     this fd.  */

	  if (file_ptr->ready_mask == 0)
	    {
	      file_event_ptr = create_file_event (file_ptr->fd);
	      QUEUE_enque (gdb_event_p, event_queue, file_event_ptr);
	    }
	  file_ptr->ready_mask = mask;
	}
    }
  return 0;
}


/* Create an asynchronous handler, allocating memory for it.
   Return a pointer to the newly created handler.
   This pointer will be used to invoke the handler by 
   invoke_async_signal_handler.
   PROC is the function to call with CLIENT_DATA argument 
   whenever the handler is invoked.  */
async_signal_handler *
create_async_signal_handler (sig_handler_func * proc,
			     gdb_client_data client_data)
{
  async_signal_handler *async_handler_ptr;

  async_handler_ptr =
    (async_signal_handler *) xmalloc (sizeof (async_signal_handler));
  async_handler_ptr->ready = 0;
  async_handler_ptr->next_handler = NULL;
  async_handler_ptr->proc = proc;
  async_handler_ptr->client_data = client_data;
  if (sighandler_list.first_handler == NULL)
    sighandler_list.first_handler = async_handler_ptr;
  else
    sighandler_list.last_handler->next_handler = async_handler_ptr;
  sighandler_list.last_handler = async_handler_ptr;
  return async_handler_ptr;
}

/* Call the handler from HANDLER immediately.  This function runs
   signal handlers when returning to the event loop would be too
   slow.  */
void
call_async_signal_handler (struct async_signal_handler *handler)
{
  (*handler->proc) (handler->client_data);
}

/* Mark the handler (ASYNC_HANDLER_PTR) as ready.  This information
   will be used when the handlers are invoked, after we have waited
   for some event.  The caller of this function is the interrupt
   handler associated with a signal.  */
void
mark_async_signal_handler (async_signal_handler * async_handler_ptr)
{
  async_handler_ptr->ready = 1;
}

/* Call all the handlers that are ready.  Returns true if any was
   indeed ready.  */
static int
invoke_async_signal_handlers (void)
{
  async_signal_handler *async_handler_ptr;
  int any_ready = 0;

  /* Invoke ready handlers.  */

  while (1)
    {
      for (async_handler_ptr = sighandler_list.first_handler;
	   async_handler_ptr != NULL;
	   async_handler_ptr = async_handler_ptr->next_handler)
	{
	  if (async_handler_ptr->ready)
	    break;
	}
      if (async_handler_ptr == NULL)
	break;
      any_ready = 1;
      async_handler_ptr->ready = 0;
      (*async_handler_ptr->proc) (async_handler_ptr->client_data);
    }

  return any_ready;
}

/* Delete an asynchronous handler (ASYNC_HANDLER_PTR).
   Free the space allocated for it.  */
void
delete_async_signal_handler (async_signal_handler ** async_handler_ptr)
{
  async_signal_handler *prev_ptr;

  if (sighandler_list.first_handler == (*async_handler_ptr))
    {
      sighandler_list.first_handler = (*async_handler_ptr)->next_handler;
      if (sighandler_list.first_handler == NULL)
	sighandler_list.last_handler = NULL;
    }
  else
    {
      prev_ptr = sighandler_list.first_handler;
      while (prev_ptr && prev_ptr->next_handler != (*async_handler_ptr))
	prev_ptr = prev_ptr->next_handler;
      gdb_assert (prev_ptr);
      prev_ptr->next_handler = (*async_handler_ptr)->next_handler;
      if (sighandler_list.last_handler == (*async_handler_ptr))
	sighandler_list.last_handler = prev_ptr;
    }
  xfree ((*async_handler_ptr));
  (*async_handler_ptr) = NULL;
}

/* Create an asynchronous event handler, allocating memory for it.
   Return a pointer to the newly created handler.  PROC is the
   function to call with CLIENT_DATA argument whenever the handler is
   invoked.  */
async_event_handler *
create_async_event_handler (async_event_handler_func *proc,
			    gdb_client_data client_data)
{
  async_event_handler *h;

  h = xmalloc (sizeof (*h));
  h->ready = 0;
  h->next_handler = NULL;
  h->proc = proc;
  h->client_data = client_data;
  if (async_event_handler_list.first_handler == NULL)
    async_event_handler_list.first_handler = h;
  else
    async_event_handler_list.last_handler->next_handler = h;
  async_event_handler_list.last_handler = h;
  return h;
}

/* Mark the handler (ASYNC_HANDLER_PTR) as ready.  This information
   will be used by gdb_do_one_event.  The caller will be whoever
   created the event source, and wants to signal that the event is
   ready to be handled.  */
void
mark_async_event_handler (async_event_handler *async_handler_ptr)
{
  async_handler_ptr->ready = 1;
}

struct async_event_handler_data
{
  async_event_handler_func* proc;
  gdb_client_data client_data;
};

static void
invoke_async_event_handler (event_data data)
{
  struct async_event_handler_data *hdata = data.ptr;
  async_event_handler_func* proc = hdata->proc;
  gdb_client_data client_data = hdata->client_data;

  xfree (hdata);
  (*proc) (client_data);
}

/* Check if any asynchronous event handlers are ready, and queue
   events in the ready queue for any that are.  */
static void
check_async_event_handlers (void)
{
  async_event_handler *async_handler_ptr;
  struct async_event_handler_data *hdata;
  struct gdb_event *event_ptr;
  event_data data;

  for (async_handler_ptr = async_event_handler_list.first_handler;
       async_handler_ptr != NULL;
       async_handler_ptr = async_handler_ptr->next_handler)
    {
      if (async_handler_ptr->ready)
	{
	  async_handler_ptr->ready = 0;

	  hdata = xmalloc (sizeof (*hdata));

	  hdata->proc = async_handler_ptr->proc;
	  hdata->client_data = async_handler_ptr->client_data;

	  data.ptr = hdata;

	  event_ptr = create_event (invoke_async_event_handler, data);
	  QUEUE_enque (gdb_event_p, event_queue, event_ptr);
	}
    }
}

/* Delete an asynchronous handler (ASYNC_HANDLER_PTR).
   Free the space allocated for it.  */
void
delete_async_event_handler (async_event_handler **async_handler_ptr)
{
  async_event_handler *prev_ptr;

  if (async_event_handler_list.first_handler == *async_handler_ptr)
    {
      async_event_handler_list.first_handler
	= (*async_handler_ptr)->next_handler;
      if (async_event_handler_list.first_handler == NULL)
	async_event_handler_list.last_handler = NULL;
    }
  else
    {
      prev_ptr = async_event_handler_list.first_handler;
      while (prev_ptr && prev_ptr->next_handler != *async_handler_ptr)
	prev_ptr = prev_ptr->next_handler;
      gdb_assert (prev_ptr);
      prev_ptr->next_handler = (*async_handler_ptr)->next_handler;
      if (async_event_handler_list.last_handler == (*async_handler_ptr))
	async_event_handler_list.last_handler = prev_ptr;
    }
  xfree (*async_handler_ptr);
  *async_handler_ptr = NULL;
}

/* Create a timer that will expire in MILLISECONDS from now.  When the
   timer is ready, PROC will be executed.  At creation, the timer is
   aded to the timers queue.  This queue is kept sorted in order of
   increasing timers.  Return a handle to the timer struct.  */
int
create_timer (int milliseconds, timer_handler_func * proc, 
	      gdb_client_data client_data)
{
  struct gdb_timer *timer_ptr, *timer_index, *prev_timer;
  struct timeval time_now, delta;

  /* Compute seconds.  */
  delta.tv_sec = milliseconds / 1000;
  /* Compute microseconds.  */
  delta.tv_usec = (milliseconds % 1000) * 1000;

  gettimeofday (&time_now, NULL);

  timer_ptr = (struct gdb_timer *) xmalloc (sizeof (*timer_ptr));
  timer_ptr->when.tv_sec = time_now.tv_sec + delta.tv_sec;
  timer_ptr->when.tv_usec = time_now.tv_usec + delta.tv_usec;
  /* Carry?  */
  if (timer_ptr->when.tv_usec >= 1000000)
    {
      timer_ptr->when.tv_sec += 1;
      timer_ptr->when.tv_usec -= 1000000;
    }
  timer_ptr->proc = proc;
  timer_ptr->client_data = client_data;
  timer_list.num_timers++;
  timer_ptr->timer_id = timer_list.num_timers;

  /* Now add the timer to the timer queue, making sure it is sorted in
     increasing order of expiration.  */

  for (timer_index = timer_list.first_timer;
       timer_index != NULL;
       timer_index = timer_index->next)
    {
      /* If the seconds field is greater or if it is the same, but the
         microsecond field is greater.  */
      if ((timer_index->when.tv_sec > timer_ptr->when.tv_sec)
	  || ((timer_index->when.tv_sec == timer_ptr->when.tv_sec)
	      && (timer_index->when.tv_usec > timer_ptr->when.tv_usec)))
	break;
    }

  if (timer_index == timer_list.first_timer)
    {
      timer_ptr->next = timer_list.first_timer;
      timer_list.first_timer = timer_ptr;

    }
  else
    {
      for (prev_timer = timer_list.first_timer;
	   prev_timer->next != timer_index;
	   prev_timer = prev_timer->next)
	;

      prev_timer->next = timer_ptr;
      timer_ptr->next = timer_index;
    }

  gdb_notifier.timeout_valid = 0;
  return timer_ptr->timer_id;
}

/* There is a chance that the creator of the timer wants to get rid of
   it before it expires.  */
void
delete_timer (int id)
{
  struct gdb_timer *timer_ptr, *prev_timer = NULL;

  /* Find the entry for the given timer.  */

  for (timer_ptr = timer_list.first_timer; timer_ptr != NULL;
       timer_ptr = timer_ptr->next)
    {
      if (timer_ptr->timer_id == id)
	break;
    }

  if (timer_ptr == NULL)
    return;
  /* Get rid of the timer in the timer list.  */
  if (timer_ptr == timer_list.first_timer)
    timer_list.first_timer = timer_ptr->next;
  else
    {
      for (prev_timer = timer_list.first_timer;
	   prev_timer->next != timer_ptr;
	   prev_timer = prev_timer->next)
	;
      prev_timer->next = timer_ptr->next;
    }
  xfree (timer_ptr);

  gdb_notifier.timeout_valid = 0;
}

/* When a timer event is put on the event queue, it will be handled by
   this function.  Just call the associated procedure and delete the
   timer event from the event queue.  Repeat this for each timer that
   has expired.  */
static void
handle_timer_event (event_data dummy)
{
  struct timeval time_now;
  struct gdb_timer *timer_ptr, *saved_timer;

  gettimeofday (&time_now, NULL);
  timer_ptr = timer_list.first_timer;

  while (timer_ptr != NULL)
    {
      if ((timer_ptr->when.tv_sec > time_now.tv_sec)
	  || ((timer_ptr->when.tv_sec == time_now.tv_sec)
	      && (timer_ptr->when.tv_usec > time_now.tv_usec)))
	break;

      /* Get rid of the timer from the beginning of the list.  */
      timer_list.first_timer = timer_ptr->next;
      saved_timer = timer_ptr;
      timer_ptr = timer_ptr->next;
      /* Call the procedure associated with that timer.  */
      (*saved_timer->proc) (saved_timer->client_data);
      xfree (saved_timer);
    }

  gdb_notifier.timeout_valid = 0;
}

/* Check whether any timers in the timers queue are ready.  If at least
   one timer is ready, stick an event onto the event queue.  Even in
   case more than one timer is ready, one event is enough, because the
   handle_timer_event() will go through the timers list and call the
   procedures associated with all that have expired.l Update the
   timeout for the select() or poll() as well.  */
static void
poll_timers (void)
{
  struct timeval time_now, delta;
  gdb_event *event_ptr;

  if (timer_list.first_timer != NULL)
    {
      gettimeofday (&time_now, NULL);
      delta.tv_sec = timer_list.first_timer->when.tv_sec - time_now.tv_sec;
      delta.tv_usec = timer_list.first_timer->when.tv_usec - time_now.tv_usec;
      /* Borrow?  */
      if (delta.tv_usec < 0)
	{
	  delta.tv_sec -= 1;
	  delta.tv_usec += 1000000;
	}

      /* Oops it expired already.  Tell select / poll to return
         immediately.  (Cannot simply test if delta.tv_sec is negative
         because time_t might be unsigned.)  */
      if (timer_list.first_timer->when.tv_sec < time_now.tv_sec
	  || (timer_list.first_timer->when.tv_sec == time_now.tv_sec
	      && timer_list.first_timer->when.tv_usec < time_now.tv_usec))
	{
	  delta.tv_sec = 0;
	  delta.tv_usec = 0;
	}

      if (delta.tv_sec == 0 && delta.tv_usec == 0)
	{
	  event_ptr = (gdb_event *) xmalloc (sizeof (gdb_event));
	  event_ptr->proc = handle_timer_event;
	  event_ptr->data.integer = timer_list.first_timer->timer_id;
	  QUEUE_enque (gdb_event_p, event_queue, event_ptr);
	}

      /* Now we need to update the timeout for select/ poll, because
         we don't want to sit there while this timer is expiring.  */
      if (use_poll)
	{
#ifdef HAVE_POLL
	  gdb_notifier.poll_timeout = delta.tv_sec * 1000;
#else
	  internal_error (__FILE__, __LINE__,
			  _("use_poll without HAVE_POLL"));
#endif /* HAVE_POLL */
	}
      else
	{
	  gdb_notifier.select_timeout.tv_sec = delta.tv_sec;
	  gdb_notifier.select_timeout.tv_usec = delta.tv_usec;
	}
      gdb_notifier.timeout_valid = 1;
    }
  else
    gdb_notifier.timeout_valid = 0;
}
@


1.54
log
@gdb/
	* event-loop.c (async_queue_event): Remove one parameter
	'position'.  Remove code handling 'position' == TAIL.
	(gdb_wait_for_event): Caller update.
	(check_async_event_handlers): Caller update.
	(poll_timers): Caller update.
	* event-loop.h (enum queue_position): Remove.
@
text
@d23 1
d72 1
a72 1
struct gdb_event
d79 1
a79 4

    /* Next in list of events or NULL.  */
    struct gdb_event *next_event;
  };
d141 3
a143 20

/* Event queue:  
   - the first event in the queue is the head of the queue.
   It will be the next to be serviced.
   - the last event in the queue 

   Events can be inserted at the front of the queue or at the end of
   the queue.  Events will be extracted from the queue for processing
   starting from the head.  Therefore, events inserted at the head of
   the queue will be processed in a last in first out fashion, while
   those inserted at the tail of the queue will be processed in a first
   in first out manner.  All the fields are NULL if the queue is
   empty.  */

static struct
  {
    gdb_event *first_event;	/* First pending event.  */
    gdb_event *last_event;	/* Last pending event.  */
  }
event_queue;
a257 21
/* Insert an event object into the gdb event queue.
   EVENT_PTR points to the event to be inserted into the queue.
   The caller must allocate memory for the event.  It is freed
   after the event has ben handled.
   Events in the queue will be processed head to tail, therefore,
   events inserted at the head of the queue will be processed
   as last in first out.  Event appended at the tail of the queue
   will be processed first in first out.  */
static void
async_queue_event (gdb_event * event_ptr)
{
  /* The event will become the new last_event.  */

  event_ptr->next_event = NULL;
  if (event_queue.first_event == NULL)
    event_queue.first_event = event_ptr;
  else
    event_queue.last_event->next_event = event_ptr;
  event_queue.last_event = event_ptr;
}

d287 17
a315 4
  gdb_event *event_ptr, *prev_ptr;
  event_handler_func *proc;
  event_data data;

d326 1
a326 2
  for (event_ptr = event_queue.first_event; event_ptr != NULL;
       event_ptr = event_ptr->next_event)
d328 7
d336 2
d339 1
a339 27
      proc = event_ptr->proc;
      data = event_ptr->data;

      /* Let's get rid of the event from the event queue.  We need to
         do this now because while processing the event, the proc
         function could end up calling 'error' and therefore jump out
         to the caller of this function, gdb_do_one_event.  In that
         case, we would have on the event queue an event wich has been
         processed, but not deleted.  */

      if (event_queue.first_event == event_ptr)
	{
	  event_queue.first_event = event_ptr->next_event;
	  if (event_ptr->next_event == NULL)
	    event_queue.last_event = NULL;
	}
      else
	{
	  prev_ptr = event_queue.first_event;
	  while (prev_ptr->next_event != event_ptr)
	    prev_ptr = prev_ptr->next_event;

	  prev_ptr->next_event = event_ptr->next_event;
	  if (event_ptr->next_event == NULL)
	    event_queue.last_event = prev_ptr;
	}
      xfree (event_ptr);
d880 1
a880 1
		  async_queue_event (file_event_ptr);
d916 1
a916 1
	      async_queue_event (file_event_ptr);
d1102 1
a1102 1
	  async_queue_event (event_ptr);
d1309 1
a1309 1
	  async_queue_event (event_ptr);
@


1.53
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d277 1
a277 3
/* Insert an event object into the gdb event queue at 
   the specified position.
   POSITION can be head or tail, with values TAIL, HEAD.
d286 1
a286 1
async_queue_event (gdb_event * event_ptr, queue_position position)
d288 1
a288 3
  if (position == TAIL)
    {
      /* The event will become the new last_event.  */
d290 6
a295 16
      event_ptr->next_event = NULL;
      if (event_queue.first_event == NULL)
	event_queue.first_event = event_ptr;
      else
	event_queue.last_event->next_event = event_ptr;
      event_queue.last_event = event_ptr;
    }
  else if (position == HEAD)
    {
      /* The event becomes the new first_event.  */

      event_ptr->next_event = event_queue.first_event;
      if (event_queue.first_event == NULL)
	event_queue.last_event = event_ptr;
      event_queue.first_event = event_ptr;
    }
d925 1
a925 1
		  async_queue_event (file_event_ptr, TAIL);
d961 1
a961 1
	      async_queue_event (file_event_ptr, TAIL);
d1147 1
a1147 1
	  async_queue_event (event_ptr, TAIL);
d1354 1
a1354 1
	  async_queue_event (event_ptr, TAIL);
@


1.52
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
   Copyright (C) 1999-2002, 2005-2012 Free Software Foundation, Inc.
@


1.51
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* event-loop.c (gdb_do_one_event): Remove `data' parameter.
	(start_event_loop): Use TRY_CATCH instead of catch_errors.
	* event-loop.h (gdb_do_one_event): Remove `data' parameter.
	* top.c (gdb_readline_wrapper): Adjust.
	* tui/tui-interp.c (tui_command_loop):
	(_initialize_tui_interp): Don't install it.
@
text
@d2 1
a2 2
   Copyright (C) 1999, 2000, 2001, 2002, 2005, 2006, 2007, 2008, 2009, 2010,
   2011 Free Software Foundation, Inc.
@


1.51.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 1999-2002, 2005-2012 Free Software Foundation, Inc.
@


1.50
log
@PR gdb/8677
* event-loop.c (handle_file_event): Don't handle POLLHUP as error.
@
text
@d413 1
a413 2
   can happen if there are no event sources to wait for).  If an error
   occurs catch_errors() which calls this function returns zero.  */
d416 1
a416 1
gdb_do_one_event (void *data)
d480 4
a483 6
  /* Loop until there is nothing to do.  This is the entry point to the
     event loop engine.  gdb_do_one_event, called via catch_errors()
     will process one event for each invocation.  It blocks waits for
     an event and then processes it.  >0 when an event is processed, 0
     when catch_errors() caught an error and <0 when there are no
     longer any event sources registered.  */
d486 2
a487 1
      int gdb_result;
d489 7
a495 3
      gdb_result = catch_errors (gdb_do_one_event, 0, "", RETURN_MASK_ALL);
      if (gdb_result < 0)
	break;
a496 6
      /* If we long-jumped out of do_one_event, we probably
         didn't get around to resetting the prompt, which leaves
         readline in a messed-up state.  Reset it here.  */

      if (gdb_result == 0)
	{
d501 3
d519 2
@


1.49
log
@2011-03-11  Michael Snyder  <msnyder@@vmware.com>

	* event-loop-c (delete_async_signal_handler): Assert prev_ptr.
	(delete_async_event_handler): Ditto.
@
text
@a761 1
  int error_mask_returned;
d785 2
d788 1
a788 3
	      mask = (file_ptr->ready_mask & file_ptr->mask) |
		(file_ptr->ready_mask & error_mask);
	      error_mask_returned = mask & error_mask;
d790 1
a790 1
	      if (error_mask_returned != 0)
d794 1
a794 4
		  if (error_mask_returned & POLLHUP)
		    printf_unfiltered (_("Hangup detected on fd %d\n"),
				       file_ptr->fd);
		  if (error_mask_returned & POLLERR)
d797 1
a797 1
		  if (error_mask_returned & POLLNVAL)
@


1.48
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d1080 1
d1189 1
@


1.47
log
@run copyright.sh for 2011.
@
text
@d694 2
a695 1
	      (new_poll_fds + j)->revents = (gdb_notifier.poll_fds + i)->revents;
d796 2
a797 1
		    printf_unfiltered (_("Hangup detected on fd %d\n"), file_ptr->fd);
d799 2
a800 1
		    printf_unfiltered (_("Error detected on fd %d\n"), file_ptr->fd);
d802 2
a803 1
		    printf_unfiltered (_("Invalid or non-`poll'able fd %d\n"), file_ptr->fd);
d817 2
a818 1
		  printf_unfiltered (_("Exception condition detected on fd %d\n"), file_ptr->fd);
d995 2
a996 1
create_async_signal_handler (sig_handler_func * proc, gdb_client_data client_data)
d1178 2
a1179 1
      async_event_handler_list.first_handler = (*async_handler_ptr)->next_handler;
@


1.46
log
@2010-12-28  Michael Snyder  <msnyder@@vmware.com>

	* event-loop.c: Comment clean-up.
	* event-loop.h: Ditto.
	* event-top.c: Ditto.
	* gdb.c: Ditto.
	* gdb.h: Ditto.
	* main.c: Ditto.
	* top.c: Ditto.
	* top.h: Ditto.
@
text
@d2 2
a3 2
   Copyright (C) 1999, 2000, 2001, 2002, 2005, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
@


1.45
log
@	* event-loop.h (GDB_READABLE, GDB_WRITABLE, GDB_EXCEPTION): Move to ...
	* event-loop.c: ... here.
	* tui/tui-io.c (tui_readline_output): Rename parameter `code' to
	`error' for clarity.
	(tui_getc): Pass correct value for `error' parameter to
	tui_readline_output.
@
text
@d19 1
a19 1
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */
d41 2
a42 2
/* Tell create_file_handler what events we are interested in. 
   This is used by the select version of the event loop. */
d59 1
a59 1
   async_queue_event and serviced later on by gdb_do_one_event. An
d64 1
a64 1
   ready. The procedure PROC associated with each event is dependant
d85 1
a85 1
   loop. */
d89 2
a90 2
    int fd;			/* File descriptor. */
    int mask;			/* Events we want to monitor: POLLIN, etc. */
d92 5
a96 5
				   the last time. */
    handler_func *proc;		/* Procedure to call when fd is ready. */
    gdb_client_data client_data;	/* Argument to pass to proc. */
    int error;			/* Was an error detected on this fd? */
    struct file_handler *next_file;	/* Next registered file descriptor. */
d100 1
a100 1
/* PROC is a function to be invoked when the READY flag is set. This
d102 5
a106 4
   handler has 'triggered' this async_signal_handler for
   execution. The actual work to be done in response to a signal will
   be carried out by PROC at a later time, within process_event. This
   provides a deferred execution of signal handlers.
d108 2
a109 1
   async_signal_handler for each interesting signal. */
d112 6
a117 5
    int ready;			/* If ready, call this handler from the main event loop, 
				   using invoke_async_handler. */
    struct async_signal_handler *next_handler;	/* Ptr to next handler */
    sig_handler_func *proc;	/* Function to call to do the work */
    gdb_client_data client_data;	/* Argument to async_handler_func */
d146 1
a146 1
   - the first event in the queue is the head of the queue. 
d156 1
a156 1
   empty. */
d160 2
a161 2
    gdb_event *first_event;	/* First pending event */
    gdb_event *last_event;	/* Last pending event */
d167 1
a167 1
   descriptor. We have two flavors of the notifier, one for platforms
d169 1
a169 1
   only support SELECT. Each of the elements in the gdb_notifier list is
d171 1
a171 1
   in, for each fd. */
d174 1
a174 1
   event loop. */
d192 1
a192 1
    /* Ptr to head of file handler list. */
d196 1
a196 1
    /* Ptr to array of pollfd structures. */
d199 1
a199 1
    /* Timeout in milliseconds for calls to poll(). */
d204 1
a204 1
       Bits are set in response to calls to create_file_handler. */
d207 1
a207 1
    /* What file descriptors were found ready by select. */
d210 2
a211 2
    /* Number of file descriptors to monitor. (for poll) */
    /* Number of valid bits (highest fd value + 1). (for select) */
d214 1
a214 1
    /* Time structure for calls to select(). */
d217 1
a217 1
    /* Flag to tell whether the timeout should be used. */
d222 2
a223 2
/* Structure associated with a timer. PROC will be executed at the
   first occasion after WHEN. */
d229 2
a230 2
    timer_handler_func *proc;	/* Function to call to do the work */
    gdb_client_data client_data;	/* Argument to async_handler_func */
d233 2
a234 2
/* List of currently active timers. It is sorted in order of
   increasing timers. */
d237 1
a237 1
    /* Pointer to first in timer list. */
d240 1
a240 1
    /* Id of the last timer created. */
d246 1
a246 1
   this list. */
d249 1
a249 1
    /* Pointer to first in handler list. */
d252 1
a252 1
    /* Pointer to last in handler list. */
d258 1
a258 1
   this list. */
d261 1
a261 1
    /* Pointer to first in handler list. */
d264 1
a264 1
    /* Pointer to last in handler list. */
d282 1
a282 1
   The caller must allocate memory for the event. It is freed
d286 2
a287 2
   as last in first out. Event appended at the tail of the queue
   will be processed first in first out. */
d293 1
a293 1
      /* The event will become the new last_event. */
d304 1
a304 1
      /* The event becomes the new first_event. */
d330 1
a330 1
   processing. The procedure associated to this event is always
d332 1
a332 1
   associated to FD when it was registered with the event loop. */
d350 1
a350 1
   procedure. */
d359 2
a360 2
     are ready. These would be the result of invoking any of the
     signal handlers. */
d366 1
a366 1
     to be processed. */
d371 1
a371 1
      /* Call the handler for the event. */
d379 1
a379 1
         to the caller of this function, gdb_do_one_event. In that
d381 1
a381 1
         processed, but not deleted. */
d401 1
a401 1
      /* Now call the procedure associated with the event. */
d406 1
a406 1
  /* this is the case if there are no event on the event queue. */
d414 1
a414 1
   occurs catch_errors() which calls this function returns zero. */
d435 1
a435 1
	     queue. */
d475 2
a476 2
/* Start up the event loop. This is the entry point to the event loop
   from the command loop. */
d481 2
a482 2
  /* Loop until there is nothing to do. This is the entry point to the
     event loop engine. gdb_do_one_event, called via catch_errors()
d486 1
a486 1
     longer any event sources registered. */
d497 1
a497 1
         readline in a messed-up state.  Reset it here. */
d507 1
a507 1
	     prompt in their own way. */
d518 1
a518 1
	     whether display the prompt or not. */
d522 2
a523 2
  /* We are done with the event loop. There are no more event sources
     to listen to.  So we exit GDB. */
d530 1
a530 1
   vs. select. */
d541 2
a542 2
      /* Check to see if poll () is usable. If not, we'll switch to
         use select. This can happen on systems like
d545 1
a545 1
         `poll'able. */
d565 2
a566 1
    create_file_handler (fd, GDB_READABLE | GDB_EXCEPTION, proc, client_data);
d570 13
a582 9
   interested in.  
   FD is the file descriptor for the file/stream to be listened to.  
   For the poll case, MASK is a combination (OR) of
   POLLIN, POLLRDNORM, POLLRDBAND, POLLPRI, POLLOUT, POLLWRNORM,
   POLLWRBAND: these are the events we are interested in. If any of them 
   occurs, proc should be called.
   For the select case, MASK is a combination of READABLE, WRITABLE, EXCEPTION.
   PROC is the procedure that will be called when an event occurs for
   FD.  CLIENT_DATA is the argument to pass to PROC. */
d584 2
a585 1
create_file_handler (int fd, int mask, handler_func * proc, gdb_client_data client_data)
d589 2
a590 2
  /* Do we already have a file handler for this file? (We may be
     changing its associated procedure). */
d598 2
a599 2
  /* It is a new file descriptor. Add it to the list. Otherwise, just
     change the data associated with it. */
d656 1
a656 1
   i.e. we don't care anymore about events on the FD. */
d667 1
a667 1
  /* Find the entry for the given file. */
d682 2
a683 2
      /* Create a new poll_fds array by copying every fd's information but the
         one we want to get rid of. */
d685 2
a686 2
      new_poll_fds =
	(struct pollfd *) xmalloc ((gdb_notifier.num_fds - 1) * sizeof (struct pollfd));
d715 1
a715 1
      /* Find current max fd. */
d732 1
a732 1
     so that it will not fire again. */
d736 1
a736 1
  /* Get rid of the file handler in the file handler list. */
d753 1
a753 1
   event in the front of the event queue. */
d766 1
a766 1
     the event. */
d773 5
a777 5
	     set to 1: POLLHUP, POLLERR, POLLNVAL. These events cannot
	     be used in the requested event mask (events), but they
	     can be returned in the return mask (revents). We need to
	     check for those event too, and add them to the mask which
	     will be passed to the handler. */
d780 1
a780 1
	     events (ready_mask). */
d792 2
a793 2
		  /* Work in progress. We may need to tell somebody what
		     kind of error we had. */
d821 1
a821 1
	  /* Clear the received events for next time around. */
d824 1
a824 1
	  /* If there was a match, then call the handler. */
d835 2
a836 2
   block in the call to poll.  Return -1 if there are no files
   descriptors to monitor, otherwise return 0. */
d845 1
a845 1
  /* Make sure all output is done before getting another event. */
d897 1
a897 1
      /* Clear the masks after an error from select. */
d911 1
a911 1
  /* Enqueue all detected file events. */
d934 1
a934 1
	         this fd. */
d969 1
a969 1
	     this fd. */
d983 1
a983 1
/* Create an asynchronous handler, allocating memory for it. 
d988 1
a988 1
   whenever the handler is invoked. */
d1017 4
a1020 4
/* Mark the handler (ASYNC_HANDLER_PTR) as ready. This information will
   be used when the handlers are invoked, after we have waited for
   some event.  The caller of this function is the interrupt handler
   associated with a signal. */
d1056 1
a1056 1
/* Delete an asynchronous handler (ASYNC_HANDLER_PTR). 
d1189 2
a1190 2
/* Create a timer that will expire in MILLISECONDS from now. When the
   timer is ready, PROC will be executed. At creation, the timer is
d1192 1
a1192 1
   increasing timers. Return a handle to the timer struct. */
d1194 2
a1195 1
create_timer (int milliseconds, timer_handler_func * proc, gdb_client_data client_data)
d1200 1
a1200 1
  /* compute seconds */
d1202 1
a1202 1
  /* compute microseconds */
d1210 1
a1210 1
  /* carry? */
d1222 1
a1222 1
     increasing order of expiration. */
d1229 1
a1229 1
         microsecond field is greater. */
d1258 1
a1258 1
   it before it expires. */
d1264 1
a1264 1
  /* Find the entry for the given timer. */
d1275 1
a1275 1
  /* Get rid of the timer in the timer list. */
d1311 1
a1311 1
      /* Get rid of the timer from the beginning of the list. */
d1315 1
a1315 1
      /* Call the procedure associated with that timer. */
d1323 1
a1323 1
/* Check whether any timers in the timers queue are ready. If at least
d1327 2
a1328 2
   procedures associated with all that have expired. Update the
   timeout for the select() or poll() as well. */
d1340 1
a1340 1
      /* borrow? */
d1347 2
a1348 2
      /* Oops it expired already. Tell select / poll to return
         immediately. (Cannot simply test if delta.tv_sec is negative
d1366 2
a1367 2
      /* Now we need to update the timeout for select/ poll, because we
         don't want to sit there while this timer is expiring. */
@


1.44
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* elfread.c: White space.
	* environ.c: White space.
	* eval.c: White space.
	* event-loop.c: White space.
	* event-top.c: White space.
	* exceptions.c: White space.
	* exec.c: White space.
	* expprint.c: White space.
@
text
@d41 7
@


1.43
log
@	* event-loop.c (gdb_timer): Delete unused global.
	(create_timer): Update.
@
text
@d861 1
a862 1
      struct timeval *timeout_p;
@


1.42
log
@Delete unused or undefined functions.

        * breakpoint.c (ep_parse_optional_filename): Delete.
        * dcache.c (dcache_write_line): Remove declaration.
        * infrun.c (build_infrun): Remove declaration.
        * tracepoint.c (tracepoint_save_command): Remove declaration.
        * linux-nat.c (init_lwp_list): Delete. No longer used.
        * event-loop.c (check_async_signal_handlers): Delete declaration.
        * infrun.c (init_execution_control_state): Delete.
        (proceed): Update comment to avoid mentioning
        init_execution_control_state.
        * target.c (kill_or_be_killed, nosupport_runtime): Delete.
        * ada-lang.c (ada_to_static_fixed_value): Delete.
        * scm-lang.c (evaluate_subexp_scm): Delete declaration.
        * cp-namespace.c (cp_copy_usings): Delete.
        * xml-syscall.c (xml_number_of_syscalls): Delete.
        * progspace.c (find_program_space_by_num): Delete.
        * inflow.c (handle_sigio): Delete declaration.
        * hppa-tdep.c (hppa_alignof): Delete.
        * mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset)
        (mipsnbsd_core_osabi_sniffer): Delete.
@
text
@d221 1
a221 2
  }
gdb_timer;
d1190 1
a1190 1
  timer_ptr = (struct gdb_timer *) xmalloc (sizeof (gdb_timer));
@


1.41
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a264 1
static void check_async_signal_handlers (void);
@


1.40
log
@	ARI fix: OP eol rule.
	* doublest.c (floatformat_from_length): Avoid operator at end of line.
	* dwarf2-frame.c (dwarf2_build_frame_info): Idem.
	* dwarf2read.c (read_array_order, dwarf_decode_macros): Idem.
	* eval.c (evaluate_subexp_standard): Idem.
	* event-loop.c (create_timer, handle_timer_event): Idem.
	* expprint.c (print_subexp_standard): Idem.
	* f-exp.y (variable): Idem.
	* f-typeprint.c (f_print_type): Idem.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2005, 2006, 2007, 2008, 2009
@


1.39
log
@        Updated copyright notices for most files.
@
text
@d1215 3
a1217 3
      if ((timer_index->when.tv_sec > timer_ptr->when.tv_sec) ||
	  ((timer_index->when.tv_sec == timer_ptr->when.tv_sec)
	   && (timer_index->when.tv_usec > timer_ptr->when.tv_usec)))
d1291 3
a1293 3
      if ((timer_ptr->when.tv_sec > time_now.tv_sec) ||
	  ((timer_ptr->when.tv_sec == time_now.tv_sec) &&
	   (timer_ptr->when.tv_usec > time_now.tv_usec)))
@


1.38
log
@	* event-loop.h: Mention async_event_handlers.
	(async_event_handler): Forward declare.
	(async_event_handler_func): New typedef.
	(create_async_event_handler, delete_async_event_handler)
	(mark_async_event_handler): Declare.
	* event-loop.c (event_data): New.
	(event_handler_func): Take an event_data instead of an integer.
	(struct gdb_event): Replace the integer file descriptor by a
	generic event_data.
	(async_event_handler): New.
	(async_handler_ready): Delete.
	(async_event_handler_list): New.
	(create_event): New.
	(create_file_event): Use it.
	(process_event): Adjust.
	(gdb_do_one_event): Poll from the event sources in round-robin
	fashion across calls.  Be sure to consult all sources before
	blocking.
	(handle_file_event): Take an event_data instead of an integer.
	Adjust.
	(gdb_wait_for_event): Add `block' argument.  Handle it.
	(mark_async_signal_handler): Remove unneeded cast.
	(invoke_async_signal_handler): Rename to ...
	(invoke_async_signal_handlres): ... this.  Return true if any was
	handled.
	(check_async_ready): Delete
	(create_async_event_handler): New.
	(mark_async_event_handler): New.
	(struct async_event_handler_data): New.
	(invoke_async_event_handler): New.
	(check_async_event_handlers): New.
	(delete_async_event_handler): New.
	(handle_timer_event): Adjust.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2005, 2006, 2007, 2008
@


1.37
log
@	* defs.h (do_exec_error_cleanups, discard_exec_error_cleanups)
	(make_exec_error_cleanup): Remove declarations.
	* utils.c (exec_error_cleanup_chain): Remove.
	(do_exec_error_cleanups, discard_exec_error_cleanups)
	(make_exec_error_cleanup): Remove.
	* event-loop.c (start_event_loop): Adjust call to
	async_enable_stdin.
	* event-top.c (async_enable_stdin): Remove the paramater dummy.
	(async_disable_stdin): Don't register async_enable_stdin via
	cleanup.
	* inf-loop.c (inferior_event_handler): Don't
	call do_exec_error_cleanups.  Call async_enable_stdin instead.
	* event-loop.c (start_event_loop): Adjust call to
	async_enable_stdin.
	* tui/tui-interp.c (tui_command_loop): Adjust call to
	async_enable_stdin.
@
text
@d41 7
d49 1
a49 1
typedef void (event_handler_func) (int);
d54 1
a54 1
   read. Servicing an event simply means that the procedure PROC will
d57 7
a63 4
   ready. The procedure PROC associated with each event is always the
   same (handle_file_event).  Its duty is to invoke the handler
   associated with the file descriptor whose state change generated
   the event, plus doing other cleanups and such. */
d67 8
a74 3
    event_handler_func *proc;	/* Procedure to call to service this event. */
    int fd;			/* File descriptor that is ready. */
    struct gdb_event *next_event;	/* Next in list of events or NULL. */
d100 1
a100 1
   asyn_signal_handler for each interesting signal. */
d111 23
d248 19
a266 15
/* Are any of the handlers ready?  Check this variable using
   check_async_ready. This is used by process_event, to determine
   whether or not to invoke the invoke_async_signal_handler
   function. */
static int async_handler_ready = 0;

static void create_file_handler (int fd, int mask, handler_func * proc, gdb_client_data client_data);
static void invoke_async_signal_handler (void);
static void handle_file_event (int event_file_desc);
static int gdb_wait_for_event (void);
static int check_async_ready (void);
static void async_queue_event (gdb_event * event_ptr, queue_position position);
static gdb_event *create_file_event (int fd);
static int process_event (void);
static void handle_timer_event (int dummy);
d305 16
d328 1
a328 1
  gdb_event *file_event_ptr;
d330 2
a331 4
  file_event_ptr = (gdb_event *) xmalloc (sizeof (gdb_event));
  file_event_ptr->proc = handle_file_event;
  file_event_ptr->fd = fd;
  return (file_event_ptr);
d339 1
a339 1
   0 is returned.   
d348 1
a348 1
  int fd;
d354 2
a355 5
  if (check_async_ready ())
    {
      invoke_async_signal_handler ();
      return 1;
    }
d366 1
a366 1
      fd = event_ptr->fd;
d394 1
a394 1
      (*proc) (fd);
d411 5
a415 1
  /* Any events already waiting in the queue? */
d417 5
d423 21
a443 1
      return 1;
d446 3
a448 2
  /* Are any timers that are ready? If so, put an event on the queue. */
  poll_timers ();
d450 4
a453 4
  /* Wait for a new event.  If gdb_wait_for_event returns -1,
     we should get out because this means that there are no
     event sources left. This will make the event loop stop,
     and the application exit. */
d455 2
a456 4
  if (gdb_wait_for_event () < 0)
    {
      return -1;
    }
d458 1
a458 1
  /* Handle any new events occurred while waiting. */
d460 1
a460 3
    {
      return 1;
    }
d462 2
a463 2
  /* If gdb_wait_for_event has returned 1, it means that one
     event has been handled. We break out of the loop. */
d741 1
a741 1
handle_file_event (int event_file_desc)
d749 1
d818 5
a822 7
/* Called by gdb_do_one_event to wait for new events on the 
   monitored file descriptors. Queue file events as they are 
   detected by the poll. 
   If there are no events, this function will block in the 
   call to poll.
   Return -1 if there are no files descriptors to monitor, 
   otherwise return 0. */
d824 1
a824 1
gdb_wait_for_event (void)
d841 9
a849 4
      num_found =
	poll (gdb_notifier.poll_fds,
	      (unsigned long) gdb_notifier.num_fds,
	      gdb_notifier.timeout_valid ? gdb_notifier.poll_timeout : -1);
d852 1
a852 1
         signal. */
d862 12
d881 1
a881 2
			      gdb_notifier.timeout_valid
			      ? &gdb_notifier.select_timeout : NULL);
d889 3
a891 1
	  /* Dont print anything is we got a signal, let gdb handle it. */
d1010 1
a1010 2
  ((async_signal_handler *) async_handler_ptr)->ready = 1;
  async_handler_ready = 1;
d1013 4
a1016 3
/* Call all the handlers that are ready. */
static void
invoke_async_signal_handler (void)
d1019 1
d1021 1
a1021 5
  if (async_handler_ready == 0)
    return;
  async_handler_ready = 0;

  /* Invoke ready handlers. */
d1034 1
d1039 1
a1039 1
  return;
d1068 85
a1152 3
/* Is it necessary to call invoke_async_signal_handler? */
static int
check_async_ready (void)
d1154 19
a1172 1
  return async_handler_ready;
d1277 3
a1279 3
   this function.  Just call the assiciated procedure and delete the
   timer event from the event queue. Repeat this for each timer that
   has expired. */
d1281 1
a1281 1
handle_timer_event (int dummy)
d1347 1
a1347 1
	  event_ptr->fd = timer_list.first_timer->timer_id;
@


1.36
log
@	Async mode fixes.
        * Makefile.in (infcmd.o, inf-loop.o): Update dependencies.
        * breakpoint.c (bpstat_do_actions): In async mode,
        don't jump to top expecting stop_bpstat to be already
        updated.
        * event-loop.c (start_event_loop): Call async_enable_stdin
        on exception.
        * event-top.c (async_enable_stdin): Do nothing if sync_execution
        is not set.
        (command_handler): Do not setup continuation here.
        (command_line_handler_continuation): Move to...
        * top.c (command_line_handler_continuation): ... here.
        (execute_command): In async mode, register continuation.
        Don't check frame's language in running in async mode.
        * exceptions.c (throw_exception): Don't do exec_error_cleanups.
        * inf-loop.c (complete_execution): Inline into...
        (inferior_event_handler): ... here.  Clear target_executing before
        doing any cleanups.  Don't try to show prompt if the target was
        resumed.
        * infcmd.c (signal_command): Add support for async mode.
        (finish_command): Only add continuation if the target was
        successfully resumed.
        * remote.c (init_async_opts): Register to_get_thread_local_address
        handler.
        * mi/mi-interp.c (mi_cmd_interpreter_exec): Don't mess
        with sync_execution.
        * tui/tui-interp.c (tui_command_loop): Call async_enable_stdin
        on exception.
@
text
@d417 1
a417 1
	  async_enable_stdin ((void *) 0);
@


1.35
log
@	* Makefile.in (mingw-hdep.o, posix-hdep.o, remote-fileio.o): Update.
	* event-loop.c (call_async_signal_handler): New.
	* event-loop.h (call_async_signal_handler)
	(gdb_call_async_signal_handler): Declare.
	(mark_async_signal_handler): Add comments.
	* event-top.c (handle_sigint): Use gdb_call_async_signal_handler.
	* mingw-hdep.c (sigint_event, sigint_handler): New.
	(gdb_select): Use them.  Wait for the readline signal handler
	to finish.
	(gdb_call_async_signal_handler, _initialize_mingw_hdep): New functions.
	* posix-hdep.c (gdb_call_async_signal_handler): New function.
	* remote-fileio.c (sigint_fileio_token, async_remote_fileio_interrupt):
	New.
	(remote_fileio_ctrl_c_signal_handler): Use
	gdb_call_async_signal_handler.
	(initialize_remote_fileio): Initialize sigint_fileio_token.
	* remote.c (initialize_sigint_signal_handler, handle_remote_sigint): Do
	not initialize tokens here.
	(handle_remote_sigint_twice): Likewise.  Reinstall
	handle_remote_sigint.
	(async_remote_interrupt_twice): Just call interrupt_query.
	(cleanup_sigint_signal_handler): Do not delete tokens.
	(remote_interrupt, remote_interrupt_twice): Use
	gdb_call_async_signal_handler.
	(interrupt_query): Reinstall the default signal handler.
	(_initialize_remote): Initialize tokens here.
@
text
@d414 4
@


1.34
log
@	Updated copyright notices for most files.
@
text
@d894 9
@


1.33
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2005, 2006, 2007
@


1.32
log
@2007-08-18  Michael Snyder  <msnyder@@access-company.com>

	* event-loop.c (delete_async_signal_handler): Move pointer null
	test to before pointer dereference.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA. */
@


1.31
log
@event-loop.c (gdb_wait_for_event): Move statement into if block.
@
text
@d953 1
a953 1
      while (prev_ptr->next_handler != (*async_handler_ptr) && prev_ptr)
@


1.30
log
@Copyright updates for 2007.
@
text
@d828 1
a829 2

	  file_ptr->ready_mask = (gdb_notifier.poll_fds + i)->revents;
@


1.29
log
@	* NEWS: Mention native Windows support.
	* Makefile.in (gdb_select_h, ser_tcp_h): New.
	(ALLDEPFILES): Add ser-mingw.c.
	(event-loop.o, inflow.o, mingw-hdep.o, posix-hdep.o, ser-base.o)
	(ser-tcp.o, ser-unix.o): Update.
	(ser-mingw.o): New rule.
	* configure: Regenerated.
	* configure.ac: Add ser-mingw.o for mingw32.
	* ser-mingw.c: New file.
	* event-loop.c: Include "gdb_select.h".
	(gdb_select): Remove, moved to mingw-hdep.c and posix-hdep.c.
	* ser-base.c: Include "gdb_select.h".
	(ser_base_wait_for): Use gdb_select.
	* serial.c (serial_for_fd): New function.
	(serial_fdopen): Try "terminal" before "hardwire".  Initialize
	the allocated struct serial.
	(serial_wait_handle): New function.
	* serial.h (serial_for_fd, serial_wait_handle): New prototypes.
	(struct serial_ops) [USE_WIN32API]: Add wait_handle.
	* gdb_select.h: New file.
	* ser-tcp.c: Include "ser-tcp.h".  Remove unused "ser-unix.h" include.
	(net_close, net_read_prim, net_write_prim): Make global.
	(net_open): Likewise.  Pass an exception set to select.  Whitespace fix.
	Document why we can not use gdb_select.
	(_initialize_ser_tcp) [USE_WIN32API]: Do not register TCP support here.
	* ser-tcp.h: New file.
	* inflow.c (gdb_has_a_terminal): Don't initialize stdin_serial here.
	(handle_sigio): Use gdb_select.
	(initialize_stdin_serial): New function.
	* terminal.h (initialize_stdin_serial): New prototype.
	* top.c (gdb_init): Call initialize_stdin_serial.
	* mingw-hdep.c (gdb_select): New function, moved from gdb_select in
	event-loop.c.  Add exception condition support.  Use serial_for_fd
	and serial_wait_handle.  Fix timeout handling.
	* posix-hdep.c: Include "gdb_select.h".
	(gdb_select): New function.
	* remote-st.c (connect_command): Use gdb_select.
	* ser-unix.c: Include "gdb_select.h".
	(hardwire_send_break, wait_for): Use gdb_select.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2005, 2006
@


1.29.14.1
log
@2006-05-13    Changes based on Apple GDB (CVS repository 5th Sept 2005)

	* async-nat-inferior.c, async-nat-inferior.h,
	* async-nat-sigthread.c, async-nat-sigthread.h: New files

	* linux-nat.c: Include async-nat-inferior.h.
	(linux_nat_wait): Add extra argument.  If target_can_async_p
	do something completely different.

	* interps.h (interp_set, interp_set_quiet): New externs.

	* interps.c (interp_set): Make asynchronous.
	(interp_set_quiet): Don't make static.
	(current_interp_command_loop): Call functions with new arguments.

	* target.h (target_wait): Add extra argument.
	(gdb_override_async, gdb_set_async_override) New externs.
	(target_can_async_p): Make conditional on gdb_override_async.

	* target.c (gdb_override_async): New variable.
	(gdb_set_async_override, do_restore_target_async_mask):
	New functions.
	(debug_to_wait): Add extra argument.

	* linux-thread-db.c (thread_db_wait): Add extra argument.

	* wrapper.h (safe_execute_command): Declare structure.

	* top.c (*deprecated_target_wait_hook): Add extra argument.
	(read_command_file): Make asynchronous.

	* remote.c (remote_wait, remote_async_wait): Add extra argument.

	* infrun.c: Include event-top.h
	(wait_for_inferior, fetch_inferior_event): Add extra argument to
	target_wait.
	(proceed): Set target_executing = 0.
	(handle_inferior_event): Call async_disable_stdin if async.

	* inf-ptrace.c: Include inf-loop.h, async-nat-inferior.h.
	(inf_ptrace_him): Create a signal thread.
	(inf_ptrace_wait): Add extra argument to target_wait.

	* inf-loop.c (inferior_event_handler, complete_execution):
	Changes for asynchronous operation (copied verbatim).

	* inf-child.c: Include async-nat-inferior.h.
	(inf_child_target): Use methods async_terminal_inferior
	and async_terminal_ours.

	* i386-linux-nat.c: Include inf-loop.h, async-nat-inferior.h.
	(i386_linux_resume): Call gdb_process_events and then
	async methods.

	* exec.c: Include event-loop.h, async-nat-inferior.h.
	(async_file_handler, standard_async, standard_is_async_p)
	(standard_can_async_p): New functions.
	(init_exec_ops): Initialise above methods.

	* event-top.h (cli_command_loop): Make argument void*.

	* event-top.c (display_gdb_prompt, async_enable_stdin)
	(async_disable_stdin, handle_sigint, async_request_quit)
	(gdb_setup_readline, _initialize_event_loop):
	Changes for asynchronous operation (copied verbatim).
	(cli_command_loop): Make argument void*.

	* event-loop.h (gdb_client_data): Move typedef to defs.h.
	(gdb_create_event): Declare.
	(event_handler_func): Move typedef from event-loop.c.

	* event-loop.c (use_poll): Set to 0.
	(gdb_queue_event, gdb_create_event): New functions.
	(async_queue_event): Don't make static.
	(create_file_event): Use gdb_create_event.
	(gdb_event): Change component from int to void*.
	(process_event, handle_file_event, handle_timer_event):
	Change according to gdb_event.
	(event_handler_func): Move typedef to event-loop.c.

	* defs.h: (gdb_mi_run_status, event_loop_p): New externs.
	(gdb_client_data): Move typedef from event-loop.h.
	(*deprecated_command_loop_hook): Make argument void*.
	(*deprecated_target_wait_hook): Add argument.

	* cli-out.h (cli_quoted_out_new): Declare.

	* cli-out.c (cli_quoted_out_new): New function.
	Include mi/mi-console.h.

	* cli/cli-interp.c: Include inferior.h, mi/mi-console.h.
	(safe_execute_command): Make static.
	(cli_interpreter_resume, cli_interpreter_exec):
	Make asynchronous.
	(cli_quoted_interpreter_resume): New function.
	(_initialize_cli_interp): Add li_command_loop to procs.
	Initialize the console-quoted interpreter.

	* tui/tui-hooks.c (tui_target_wait_hook): Add extra argument.

	* mi/mi-main.h (mi_dont_register_continuation)
	(current_command_token,  mi_interp, mi_interpreter_exec_continuation)
	(mi_continuation_arg): New externs.
	(mi_setup_continuation_arg): Declare.

	* mi/mi-main.c: Include wrapper.h.
	(struct mi_continuation_arg): New structure.
	(mi_interpreter_exec_continuation): Move to mi-interp.c.
	(mi_execute_async_cli_command)
	(mi_exec_async_cli_cmd_continuation): Make asynchronous.
	(mi_setup_continuation_arg): New function.

	* mi/mi-interp.c (mi_interpreter_exec_continuation):
	Move from mi-main.c
	(mi_cmd_interpreter_exec): Switch interpreters.  Make
	asynchronous.
	(mi1_command_loop, mi2_command_loop, mi3_command_loop):
	Make argument void*.

	* Makefile.in (async_nat_inferior_h, async_nat_sigthread_h):
	New variables.
	(gdb$(EXEEXT), $(TUI)$(EXEEXT)): Link with libpthread.
	(async-nat-inferior.o, async-nat-sigthread.o): New rules.
	(COMMON_OBS): Add above object files.
	(exec.o, i386-linux-nat.o, inf-ptrace.o, linux-nat.o):
	Update dependencies.

2006-05-13  Nick Roberts  <nickrob@@snap.net.nz>

	* main.c: (event_loop_p): Re-instate variable.
	(captured_main): Re-instate async/noasync option.
	(print_gdb_help): Describe option again.

	* exec.c(init_exec_ops): Only initialise async methods with async
	option.

	* inf-ptrace.c (inf_ptrace_him): Only reate a signal thread with
	async option.

	* README.async, TODO.async, PROBLEMS.async: New files.
@
text
@d44 1
a44 2

/* async make globally visible */
d52 4
a55 10
   APPLE LOCAL begin async
   ready. 

   File events are all handled through the procedure
   handle_file_event.  Its duty is to invoke the handler associated
   with the file descriptor whose state change generated the event,
   plus doing other cleanups and such. 

   Other event types can be created, and added to the event queue by
   using gdb_queue_event.  */
d60 1
a60 1
    void *data;			/* The data for this event */
d137 1
a137 2
//static unsigned char use_poll = USE_POLL;
static unsigned char use_poll = 0;
d220 1
a220 1
static void handle_file_event (void *data);
d223 1
a223 3
void async_queue_event (gdb_event * event_ptr, queue_position position);
int sigint_taken_p(void);
static gdb_event *gdb_create_event (event_handler_func proc, void *data);
d226 1
a226 1
static void handle_timer_event (void *dummy);
a228 9
void
gdb_queue_event (event_handler_func proc, void *data, queue_position position)
{
  gdb_event *new_event;

  new_event = gdb_create_event (proc, data);
  async_queue_event (new_event, position);

}
d240 1
a240 1
void
a263 11
static gdb_event *
gdb_create_event (event_handler_func proc, void *data)
{
  gdb_event *new_event;
  
  new_event = (gdb_event *) xmalloc (sizeof (gdb_event));
  new_event->proc = proc;
  new_event->data = data;

  return new_event;
}
d272 6
a277 1
  return gdb_create_event (handle_file_event, (void *) fd);
d294 1
a294 1
  void *data;
d315 1
a315 1
      data = event_ptr->data;
d343 1
a343 1
      (*proc) (data);
d660 1
a660 1
handle_file_event (void *data)
a661 1
  int event_file_desc = (int) data;
d1077 1
a1077 1
handle_timer_event (void *dummy)
d1143 1
a1143 1
	  event_ptr->data = (void *) timer_list.first_timer->timer_id;
@


1.28
log
@	* event-loop.c (gdb_select): Detect file descriptors that have
	been closed.
@
text
@d2 2
a3 1
   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d41 1
a735 91
/* Wrapper for select.  This function is not yet exported from this
   file because it is not sufficiently general.  For example,
   ser-base.c uses select to check for socket activity, and this
   function does not support sockets under Windows, so we do not want
   to use gdb_select in ser-base.c.  */

static int 
gdb_select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
	    struct timeval *timeout)
{
#ifdef USE_WIN32API
  HANDLE handles[MAXIMUM_WAIT_OBJECTS];
  HANDLE h;
  DWORD event;
  DWORD num_handles;
  int fd;
  int num_ready;

  num_ready = 0;
  num_handles = 0;
  for (fd = 0; fd < n; ++fd)
    {
      /* There is no support yet for WRITEFDS.  At present, this isn't
	 used by GDB -- but we do not want to silently ignore WRITEFDS
	 if something starts using it.  */
      gdb_assert (!FD_ISSET (fd, writefds));
      if (!FD_ISSET (fd, readfds) 
	  && !FD_ISSET (fd, exceptfds))
	continue;
      h = (HANDLE) _get_osfhandle (fd);
      if (h == INVALID_HANDLE_VALUE)
	{
	  /* If the underlying handle is INVALID_HANDLE_VALUE, then
	     this descriptor is no more.  */
	  if (FD_ISSET (fd, exceptfds))
	    ++num_ready;
	  continue;
	}
      /* The only exceptional condition we recognize is a closed file
	 descriptor.  Since we have already checked for that
	 condition, clear the exceptional bit for this descriptor.  */
      FD_CLR (fd, exceptfds);
      if (FD_ISSET (fd, readfds))
      {
	gdb_assert (num_handles < MAXIMUM_WAIT_OBJECTS);
	handles[num_handles++] = h;
      }
    }
  /* If we don't need to wait for any handles, we are done.  */
  if (!num_handles)
    return num_ready;
  event = WaitForMultipleObjects (num_handles,
				  handles,
				  FALSE,
				  timeout 
				  ? (timeout->tv_sec * 1000 + timeout->tv_usec)
				  : INFINITE);
  /* EVENT can only be a value in the WAIT_ABANDONED_0 range if the
     HANDLES included an abandoned mutex.  Since GDB doesn't use
     mutexes, that should never occur.  */
  gdb_assert (!(WAIT_ABANDONED_0 <= event
		&& event < WAIT_ABANDONED_0 + num_handles));
  if (event == WAIT_FAILED)
    return -1;
  if (event == WAIT_TIMEOUT)
    return num_ready;
  /* Run through the READFDS, clearing bits corresponding to descriptors
     for which input is unavailable.  */
  num_ready += num_handles; 
  h = handles[event - WAIT_OBJECT_0];
  for (fd = 0; fd < n; ++fd)
    {
      HANDLE fd_h;
      if (!FD_ISSET (fd, readfds))
	continue;
      fd_h = (HANDLE) _get_osfhandle (fd);
      /* This handle might be ready, even though it wasn't the handle
	 returned by WaitForMultipleObjects.  */
      if (fd_h != h && WaitForSingleObject (fd_h, 0) != WAIT_OBJECT_0)
	{
	  FD_CLR (fd, readfds);
	  --num_ready;
	}
    }

  return num_ready;
#else
  return select (n, readfds, writefds, exceptfds, timeout);
#endif
}

@


1.27
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d752 1
a755 3
      /* EXCEPTFDS is silently ignored.  GDB always sets GDB_EXCEPTION
	 when calling add_file_handler, but there is no natural analog
	 under Windows.  */
d760 16
d777 8
a784 5
	{
	  gdb_assert (num_handles < MAXIMUM_WAIT_OBJECTS);
	  handles[num_handles++] = (HANDLE) _get_osfhandle (fd);
	}
    }
d799 1
a799 1
    return 0;
d802 1
a802 1
  num_ready = num_handles; 
a817 4
  /* We never report any descriptors available for writing or with
     exceptional conditions.  */ 
  FD_ZERO (writefds);
  FD_ZERO (exceptfds);
@


1.26
log
@	* event-loop.c (gdb_select): Program defensively.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA. */
@


1.26.8.1
log
@	Backport:
	2006-01-13  Mark Mitchell  <mark@@codesourcery.com>
	* event-loop.c (gdb_select): Detect file descriptors that have
	been closed.
@
text
@a751 1
  num_ready = 0;
d755 3
d762 1
a762 5
      if (!FD_ISSET (fd, readfds) 
	  && !FD_ISSET (fd, exceptfds))
	continue;
      h = (HANDLE) _get_osfhandle (fd);
      if (h == INVALID_HANDLE_VALUE)
d764 4
a767 19
	  /* If the underlying handle is INVALID_HANDLE_VALUE, then
	     this descriptor is no more.  */
	  if (FD_ISSET (fd, exceptfds))
	    ++num_ready;
	  continue;
	}
      /* The only exceptional condition we recognize is a closed file
	 descriptor.  Since we have already checked for that
	 condition, clear the exceptional bit for this descriptor.  */
      FD_CLR (fd, exceptfds);
      if (FD_ISSET (fd, readfds))
      {
	gdb_assert (num_handles < MAXIMUM_WAIT_OBJECTS);
	handles[num_handles++] = h;
      }
    }
  /* If we don't need to wait for any handles, we are done.  */
  if (!num_handles)
    return num_ready;
d782 1
a782 1
    return num_ready;
d785 1
a785 1
  num_ready += num_handles; 
d801 4
@


1.25
log
@	* event-loop.c (gdb_assert.h): Include.
	(<windows.h>): Include under Windows.
	(<io.h>): Likeiwse.
	(gdb_select): New function.
	(gdb_wait_for_event): Use it.
	* Makefile.in (event-loop.o): Depend on $(gdb_assert_h).
@
text
@d763 4
a766 1
	handles[num_handles++] = (HANDLE) _get_osfhandle (fd);
d785 1
a785 1
  num_ready = num_handlers; 
d789 4
a792 1
      HANDLE fd_h = (HANDLE) _get_osfhandle (fd);
d795 1
a795 2
      if (FD_ISSET (fd, readfds) && fd_h != h
	  && WaitForSingleObject (fd_h, 0) != WAIT_OBJECT_0)
@


1.24
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d39 1
d137 5
d734 73
d851 6
a856 6
      num_found = select (gdb_notifier.num_fds,
			  &gdb_notifier.ready_masks[0],
			  &gdb_notifier.ready_masks[1],
			  &gdb_notifier.ready_masks[2],
			  gdb_notifier.timeout_valid
			  ? &gdb_notifier.select_timeout : NULL);
@


1.24.2.1
log
@	* gdb/configure.ac: No tgetent on MinGW.
	* gdb/event-loop.c (struct gdb_notifier): Add "handles" for Windows.
	(create_file_handler): On Windows, update handles, rather than
	check_masks and ready_masks.
	(delete_file_handler): Likewise.
	(gdb_wait_for_event): Use WaitForMultipleObjects, not select, on
	Windows.
	* gdb/event-top.c (gdb_setup_readline): Put console into
	character-at-a-time mode under Windows.
@
text
@a135 5
#ifdef WINAPI
#include <windows.h>
#include <io.h>
#endif

a148 3
#ifdef WINAPI
    HANDLE handles[MAXIMUM_WAIT_OBJECTS];
#else
d155 1
a155 1
#endif
a157 1
    /* Number of handles (for Windows).  */
a526 4
#ifdef WINAPI
	  gdb_notifier.handles[gdb_notifier.num_fds++] 
	    = (HANDLE) _get_osfhandle (fd);
#else
a543 1
#endif
a604 10
#ifdef WINAPI
      HANDLE h = (HANDLE) _get_osfhandle (fd);
      for (i = 0; i < gdb_notifier.num_fds; ++i)
	if (gdb_notifier.handles[i] == h)
	  {
	    gdb_notifier.handles[i] =
	      gdb_notifier.handles[gdb_notifier.num_fds--];
	    break;
	  }
#else
a625 1
#endif
a739 3
#ifdef WINAPI
  DWORD event = 0;
#else
a740 1
#endif
a768 10
#ifdef WINAPI
      event
	= WaitForMultipleObjects(gdb_notifier.num_fds,
				 gdb_notifier.handles,
				 FALSE,
				 gdb_notifier.timeout_valid
				 ? (gdb_notifier.select_timeout.tv_sec * 1000
				    + gdb_notifier.select_timeout.tv_usec)
				 : INFINITE);
#else
a788 1
#endif
a830 14
#ifdef WINAPI
      HANDLE h;

      h = gdb_notifier.handles[event - WAIT_OBJECT_0];
      file_ptr = gdb_notifier.first_file_handler;
      while ((HANDLE) _get_osfhandle (file_ptr->fd) != h)
	file_ptr = file_ptr->next_file;
      if (file_ptr->ready_mask == 0)
	{
	  file_event_ptr = create_file_event (file_ptr->fd);
	  async_queue_event (file_event_ptr, TAIL);
	}
      file_ptr->ready_mask = GDB_READABLE;
#else      
a858 1
#endif
@


1.23
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d691 1
a691 1
		    printf_unfiltered ("Hangup detected on fd %d\n", file_ptr->fd);
d693 1
a693 1
		    printf_unfiltered ("Error detected on fd %d\n", file_ptr->fd);
d695 1
a695 1
		    printf_unfiltered ("Invalid or non-`poll'able fd %d\n", file_ptr->fd);
d709 1
a709 1
		  printf_unfiltered ("Exception condition detected on fd %d\n", file_ptr->fd);
@


1.22
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d455 1
a455 1
		      "use_poll without HAVE_POLL");
d464 1
a464 1
		      "use_poll without HAVE_POLL");
d522 1
a522 1
			  "use_poll without HAVE_POLL");
d600 1
a600 1
		      "use_poll without HAVE_POLL");
d702 1
a702 1
			      "use_poll without HAVE_POLL");
d761 1
a761 1
	perror_with_name ("Poll");
d764 1
a764 1
		      "use_poll without HAVE_POLL");
d787 1
a787 1
	    perror_with_name ("Select");
d826 1
a826 1
		      "use_poll without HAVE_POLL");
d1147 1
a1147 1
			  "use_poll without HAVE_POLL");
@


1.21
log
@2002-11-05  Elena Zannoni  <ezannoni@@redhat.com>

	* event-loop.c (start_event_loop): Add comment.
	Update copyright.
@
text
@d38 1
@


1.20
log
@2002-09-30  Elena Zannoni  <ezannoni@@redhat.com>

	* event-loop.c (start_event_loop): Rename variable 'result' to
	'gdb_result', to avoid conflicts with upcoming intepreters changes.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d400 5
@


1.20.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
a399 5

      /* If we long-jumped out of do_one_event, we probably
         didn't get around to resetting the prompt, which leaves
         readline in a messed-up state.  Reset it here. */

@


1.19
log
@	* event-loop.c (gdb_do_one_event): Make public.
	* event-loop.h (gdb_do_one_event): Declare.
@
text
@d395 4
a398 2
      int result = catch_errors (gdb_do_one_event, 0, "", RETURN_MASK_ALL);
      if (result < 0)
d400 1
a400 1
      if (result == 0)
@


1.19.2.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d395 2
a396 4
      int gdb_result;

      gdb_result = catch_errors (gdb_do_one_event, 0, "", RETURN_MASK_ALL);
      if (gdb_result < 0)
d398 1
a398 1
      if (gdb_result == 0)
@


1.19.2.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
a399 5

      /* If we long-jumped out of do_one_event, we probably
         didn't get around to resetting the prompt, which leaves
         readline in a messed-up state.  Reset it here. */

@


1.18
log
@        * event-loop.c (create_file_handler): Don't do anything but
        update data when we are given a fd which we are already
        monitoring.
@
text
@a212 1
static int gdb_do_one_event (void *data);
d348 1
a348 1
static int
@


1.18.10.1
log
@	* event-loop.c (gdb_do_one_event): Make public.
	* event-loop.h (gdb_do_one_event): Declare.
@
text
@d213 1
d349 1
a349 1
int
@


1.18.4.1
log
@Initial check-in of interpreter support from Apple. (Slightly massaged and
modified by me.)
@
text
@a24 1
#include "interps.h"
d396 2
a397 4
      int gdb_result, interp_result;

      gdb_result = catch_errors (gdb_do_one_event, 0, "", RETURN_MASK_ALL);
      if (gdb_result < 0)
d399 1
a399 12

      interp_result = catch_errors (interpreter_do_one_event, 0, "", RETURN_MASK_ALL);
      if (interp_result < 0)
        {
          /* FIXME - kill the interpreter */
        }

      /* If we long-jumped out of do_one_event, we probably
         didn't get around to resetting the prompt, which leaves
         readline in a messed-up state. Reset it here. */

      if (gdb_result == 0)
@


1.18.4.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d214 1
d350 1
a350 1
int
@


1.18.4.3
log
@2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* interps.h (struct gdb_interpreter_procs): Remove do_one_event_proc.
	(interp_do_one_event_ftype): Delete.
	* interps.c (gdb_new_interpreter): Remove setup of do_one_event
	procedure.
	(interpreter_do_one_event): Delete.
	* event-loop.c (start_event_loop): Remove no-op call to
	interpreter_do_one_event.
	* cli/cli-interps.c: (cli_interpreter_do_one_event): Delete.

2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-interp.c (mi_interpreter_do_one_event): Remove.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d396 1
a396 1
      int gdb_result;
d401 6
@


1.18.4.4
log
@2002-11-05  Elena Zannoni  <ezannoni@@redhat.com>

        * Makefile.in (event-loop.o): Remove dependency on interps.h.
        * event-loop.c: Remove include of interps.h.
@
text
@d25 1
@


1.17
log
@	* NEWS: Updated.
	* event-loop.c (start_event_loop): Call
	after_char_processing_hook.
	* event-top.h (after_char_processing_hook): Declare.
	* event-top.c (rl_callback_read_char_wrapper): Call
	after_char_processing_hook.
	(after_char_processing_hook): New global.
	* top.c (operate_saved_history): New global.
	(gdb_rl_operate_and_get_next): New function.
	(init_main): Add the operate-and-get-next defun.
	(gdb_rl_operate_and_get_next_completion): New function.
@
text
@a496 4
    }
  file_ptr->proc = proc;
  file_ptr->client_data = client_data;
  file_ptr->mask = mask;
d498 2
a499 2
  if (use_poll)
    {
d501 12
a512 12
      gdb_notifier.num_fds++;
      if (gdb_notifier.poll_fds)
	gdb_notifier.poll_fds =
	  (struct pollfd *) xrealloc (gdb_notifier.poll_fds,
				      (gdb_notifier.num_fds
				       * sizeof (struct pollfd)));
      else
	gdb_notifier.poll_fds =
	  (struct pollfd *) xmalloc (sizeof (struct pollfd));
      (gdb_notifier.poll_fds + gdb_notifier.num_fds - 1)->fd = fd;
      (gdb_notifier.poll_fds + gdb_notifier.num_fds - 1)->events = mask;
      (gdb_notifier.poll_fds + gdb_notifier.num_fds - 1)->revents = 0;
d514 2
a515 2
      internal_error (__FILE__, __LINE__,
		      "use_poll without HAVE_POLL");
d517 1
a517 5
    }
  else
    {
      if (mask & GDB_READABLE)
	FD_SET (fd, &gdb_notifier.check_masks[0]);
d519 5
a523 1
	FD_CLR (fd, &gdb_notifier.check_masks[0]);
d525 4
a528 4
      if (mask & GDB_WRITABLE)
	FD_SET (fd, &gdb_notifier.check_masks[1]);
      else
	FD_CLR (fd, &gdb_notifier.check_masks[1]);
d530 4
a533 4
      if (mask & GDB_EXCEPTION)
	FD_SET (fd, &gdb_notifier.check_masks[2]);
      else
	FD_CLR (fd, &gdb_notifier.check_masks[2]);
d535 3
a537 2
      if (gdb_notifier.num_fds <= fd)
	gdb_notifier.num_fds = fd + 1;
d539 4
@


1.16
log
@* arch-utils.c (#include "gdbthread.h"): Removed.
(#include "symfile.h"): Removed.
(XMALLOC): Removed unused macro.
* breakpoint.c (tbreak_command): Removed local declaration.
(awatch_command, do_enable_breakpoint, set_breakpoint_count):
Remove duplicate declarations.
(bpstat_should_step, bpstat_have_active_hw_watchpoints)
(remove_solib_event_breakpoints): Fix indentation botch.
* c-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* ch-exp.c (ch_terminal_match_float_literal, parse_expr)
(parse_primval, parse_untyped_expr, parse_opt_untyped_expr):
Removed duplicate declarations.
* ch-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* corefile.c (#include "frame.h"): Removed
(#include "symfile.h"): Removed.
(#include "language.h"): Removed.
* dbxread.c (#include "command.h"): Removed.
* environ.c (#include "gdbcore.h"): Removed.
* event-loop.c (#include "top.h"): Removed.
* f-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
(#include "typeprint.h"): Removed.
(#include "frame.h"): Removed.
* gdbtypes.h (print_type_scalar): Removed declaration.
* infcmd.c (#include "completer.h"): Removed.
* language.c (#include "frame.h"): Removed.
* m2-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
* m2-valprint.c (#include "valprint.h"): Removed.
* p-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* p-valprint.c (#include "typeprint.h"): Removed.
* parse.c (#include "linespec.h"): Removed.
* regcache.c (#include "frame.h"): Removed.
* remote.c (#include "frame.h"): Removed.
(getpkt_sane): Make static.
* source.c (#include "completer.h"): Removed.
* stack.c (#include "symfile.h"): Removed.
(#include "objfiles.h"): Removed.
* symfile.c (#include "completer.h"): Removed.
* tracepoint.c (#include "completer.h"): Removed.
* values.c (#include "frame.h"): Removed.
* varobj.c (#include "valprint.h"): Removed.
* wrapper.c (#include "frame.h"): Removed.

* memattr.c (create_mem_region): Removed unused variable.
* remote-nrom.c: Removed spurious semicolon after init_nrom_ops.
-------------------------------------------------------------------
@
text
@d405 8
@


1.15
log
@	* event-loop.c (toplevel) [!HAVE_POLL] [NO_FD_SET]: Remove unused
	definitions for SELECT, NBBY, FD_SETSIZE, NFDBITS, and MASK_SIZE.
@
text
@a22 1
#include "top.h"
@


1.14
log
@Move realoc() decl to utils.c.  s/realloc()/xrealloc()/.
@
text
@a39 46
/* Type of the mask arguments to select. */

#ifndef HAVE_POLL
#ifdef NO_FD_SET
/* All this stuff below is not required if select is used as God(tm)
   intended, with the FD_* macros.  Are there any implementations of
   select which don't have FD_SET and other standard FD_* macros?  I
   don't think there are, but if I'm wrong, we need to catch them.  */
#error FD_SET must be defined if select function is to be used!

#ifndef _AIX
typedef long fd_mask;
#endif
#if defined(_IBMR2)
#define SELECT_MASK void
#else
#define SELECT_MASK int
#endif /* !_IBMR2 */

/* Define "NBBY" (number of bits per byte) if it's not already defined. */

#ifndef NBBY
#define NBBY 8
#endif

/* Define the number of fd_masks in an fd_set */

#ifndef FD_SETSIZE
#ifdef OPEN_MAX
#define FD_SETSIZE OPEN_MAX
#else
#define FD_SETSIZE 256
#endif
#endif
#if !defined(howmany)
#define howmany(x, y) (((x)+((y)-1))/(y))
#endif
#ifndef NFDBITS
#define NFDBITS NBBY*sizeof(fd_mask)
#endif
#define MASK_SIZE howmany(FD_SETSIZE, NFDBITS)

#endif /* NO_FD_SET */
#endif /* !HAVE_POLL */


@


1.13
log
@2001-03-06  J.T. Conklin  <jtc@@redback.com>

        * symtab.h (decode_line_1): Removed declaration.

        * symfile.c (#include <assert.h>): Removed.

        * arch-utils.c (#include <ctype.h>): Removed.
        * c-typeprint.c: Likewise.
        * dbxread.c: Likewise.
        * gdbtypes.c: Likewise.
        * target.c: Likewise.
        * os9kread.c: Likewise.

        * c-valprint.c (#include "demangle.h"): Removed.
        * ch-typeprint.c: Likewise.
        * eval.c: Likewise.
        * f-typeprint.c: Likewise.
        * f-valprint.c: Likewise.
        * m2-typeprint.c: Likewise.
        * typeprint.c: Likewise.
        * p-typeprint.c: Likewise.
        * valarith.c: Likewise.
        * valprint.c: Likewise.

        * m2-typeprint.c (#include "gdb_string.h"): Removed.
        * nlmread.c: Likewise.

        * mdebugread.c (#include "gdb-stabs.h"): Removed.
        * minsyms.c: Likewise.
        * mipsread.c: Likewise.
        * nlmread.c: Likewise.

        * m2-typeprint.c (#include "obstack.h"): Removed.
        * m2-valprint.c: Likewise.

        * event-loop.c (#include <setjmp.h>): Removed.
@
text
@d547 3
a549 2
	  (struct pollfd *) realloc (gdb_notifier.poll_fds,
			   (gdb_notifier.num_fds) * sizeof (struct pollfd));
@


1.12
log
@Update/correct copyright notices.
@
text
@a37 1
#include <setjmp.h>
@


1.11
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d2 1
a2 1
   Copyright 1999, 2001 Free Software Foundation, Inc.
@


1.10
log
@2001-01-31  David Smith  <dsmith@@redhat.com>

	* event-loop.c: Change inclusion of string.h to gdb_string.h and
	updated the copyright notice.
	* ser-pipe.c: Ditto.
	* mi/mi-cmds.c: Ditto.
	* mi/mi-console.c: Ditto.
	* mi/mi-getopt.c: Ditto.
	* mi/mi-parse.c: Ditto.
@
text
@d487 2
a488 1
      internal_error ("event-loop.c : use_poll without HAVE_POLL");
d496 2
a497 1
      internal_error ("event-loop.c : use_poll without HAVE_POLL");
d557 2
a558 1
      internal_error ("event-loop.c : use_poll without HAVE_POLL");
d630 2
a631 1
      internal_error ("event-loop.c : use_poll without HAVE_POLL");
d732 2
a733 1
	      internal_error ("event-loop.c : use_poll without HAVE_POLL");
d794 2
a795 1
      internal_error ("event-loop.c : use_poll without HAVE_POLL");
d856 2
a857 1
      internal_error ("event-loop.c : use_poll without HAVE_POLL");
d1177 2
a1178 1
	  internal_error ("event-loop.c : use_poll without HAVE_POLL");
@


1.9
log
@Replace free() with xfree().
@
text
@d2 1
a2 1
   Copyright 1999 Free Software Foundation, Inc.
d36 1
a36 1
#include <string.h>
@


1.8
log
@
Corrected spelling errors in comments:
adn -> and, Is->Are,  occures->occurs
@
text
@d380 1
a380 1
      free ((char *) event_ptr);
d623 1
a623 1
      free (gdb_notifier.poll_fds);
d671 1
a671 1
  free ((char *) file_ptr);
d976 1
a976 1
  free ((char *) (*async_handler_ptr));
d1083 1
a1083 1
  free ((char *) timer_ptr);
d1114 1
a1114 1
      free (saved_timer);
@


1.7
log
@Check for <sys/poll.h>.
@
text
@d99 1
a99 1
   the event, plus doing other cleanups adn such. */
d251 1
a251 1
/* Is any of the handlers ready?  Check this variable using
d395 1
a395 1
   occures catch_errors() which calls this function returns zero. */
@


1.6
log
@2000-03-22  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* event-loop.c (handle_file_event): Run through indent.
@
text
@d26 1
d28 1
d30 2
d33 2
@


1.5
log
@2000-03-22  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        From  Philippe De Muyter  <phdm@@macqel.be>

	* event-loop.c (sys/types.h): File now included unconditionally.
	(use_poll): New variable..
	(gdb_notifier): poll- and select-versions merged.
	(add_file_handler): If HAVE_POLL, check whether poll is usable,
	and reset `use_poll' if not.
	(create_file_handler): Select poll- or select-version according to
	`use_poll'.
	(delete_file_handler, handle_file_event): Likewise.
	(gdb_wait_for_event, poll_timers): Likewise.
@
text
@d399 1
a399 1
  
d402 1
a402 1
  
d407 1
a407 1
  
d412 1
a412 1
  
d418 1
a418 1
  
d472 8
a479 8
	 use select. This can happen on systems like
	 m68k-motorola-sys, `poll' cannot be used to wait for `stdin'.
	 On m68k-motorola-sysv, tty's are not stream-based and not
	 `poll'able.*/
    fds.fd = fd;
    fds.events = POLLIN;
    if (poll (&fds, 1, 0) == 1 && (fds.revents & POLLNVAL))
      use_poll = 0;
d481 1
a481 1
    internal_error ("event-loop.c : use_poll without HAVE_POLL");
d541 1
a541 1
			       (gdb_notifier.num_fds) * sizeof (struct pollfd));
d602 1
a602 1
	 one we want to get rid of. */
d722 1
a722 1
      internal_error ("event-loop.c : use_poll without HAVE_POLL");
d779 1
a779 1
	 signal. */
d792 3
a794 3
			  & gdb_notifier.ready_masks[0],
			  & gdb_notifier.ready_masks[1],
			  & gdb_notifier.ready_masks[2],
d833 1
a833 1
		 this fd. */
d1140 1
a1140 1
	 because time_t might be unsigned.)  */
@


1.4
log
@2000-03-04  Eli Zaretskii  <eliz@@is.elta.co.il>

	* event-loop.c (top-level) [NO_FD_SET]: Deprecate this branch.
	Print an error at compile time if we are to use select, but FD_SET
	is not available.
	(SELECT_MASK, NBBY, FD_SETSIZE, NFDBITS, MASK_SIZE): Define only
	if HAVE_POLL is not defined and NO_FD_SET *is* defined.
	(create_file_handler) [!HAVE_POLL]: Use FD_SET and FD_CLR.
	(delete_file_handler) [!HAVE_POLL]: Use FD_CLR and FD_ISSET.
	(gdb_wait_for_event) [!HAVE_POLL]: Copy fd_set sets directly
	instead of using memcpy and memset.  Use FD_ISSET.

	* config/i386/xm-go32.h (fd_mask): Remove typedef.
@
text
@d28 1
a28 1
#else
a30 1
#endif
d168 1
d170 6
a175 1
/* Poll based implementation of the notifier. */
d182 1
a185 3
    /* Number of file descriptors to monitor. */
    int num_fds;

d187 2
a188 15
    int timeout;

    /* Flag to tell whether the timeout value shuld be used. */
    int timeout_valid;
  }
gdb_notifier;

#else /* ! HAVE_POLL */

/* Select based implementation of the notifier. */

static struct
  {
    /* Ptr to head of file handler list. */
    file_handler *first_file_handler;
d197 2
a198 1
    /* Number of valid bits (highest fd value + 1). */
d202 1
a202 1
    struct timeval timeout;
d204 1
a204 1
    /* Flag to tell whether the timeout struct should be used. */
a208 2
#endif /* HAVE_POLL */

d376 1
a376 1
      /* Now call the procedure associted with the event. */
d465 23
a487 1
  create_file_handler (fd, POLLIN, proc, client_data);
d489 1
a489 1
  create_file_handler (fd, GDB_READABLE | GDB_EXCEPTION, proc, client_data);
d491 3
a528 3
#ifdef HAVE_POLL
      gdb_notifier.num_fds++;
#endif
d534 2
d537 15
a551 5

  if (gdb_notifier.poll_fds)
    gdb_notifier.poll_fds =
      (struct pollfd *) realloc (gdb_notifier.poll_fds,
			   (gdb_notifier.num_fds) * sizeof (struct pollfd));
d553 5
a557 5
    gdb_notifier.poll_fds =
      (struct pollfd *) xmalloc (sizeof (struct pollfd));
  (gdb_notifier.poll_fds + gdb_notifier.num_fds - 1)->fd = fd;
  (gdb_notifier.poll_fds + gdb_notifier.num_fds - 1)->events = mask;
  (gdb_notifier.poll_fds + gdb_notifier.num_fds - 1)->revents = 0;
d559 4
a562 1
#else /* ! HAVE_POLL */
d564 4
a567 4
  if (mask & GDB_READABLE)
    FD_SET (fd, &gdb_notifier.check_masks[0]);
  else
    FD_CLR (fd, &gdb_notifier.check_masks[0]);
d569 3
a571 14
  if (mask & GDB_WRITABLE)
    FD_SET (fd, &gdb_notifier.check_masks[1]);
  else
    FD_CLR (fd, &gdb_notifier.check_masks[1]);

  if (mask & GDB_EXCEPTION)
    FD_SET (fd, &gdb_notifier.check_masks[2]);
  else
    FD_CLR (fd, &gdb_notifier.check_masks[2]);

  if (gdb_notifier.num_fds <= fd)
    gdb_notifier.num_fds = fd + 1;

#endif /* HAVE_POLL */
d598 2
d601 2
a602 2
  /* Create a new poll_fds array by copying every fd's information but the
     one we want to get rid of. */
d604 2
a605 2
  new_poll_fds =
    (struct pollfd *) xmalloc ((gdb_notifier.num_fds - 1) * sizeof (struct pollfd));
d607 1
a607 3
  for (i = 0, j = 0; i < gdb_notifier.num_fds; i++)
    {
      if ((gdb_notifier.poll_fds + i)->fd != fd)
d609 7
a615 4
	  (new_poll_fds + j)->fd = (gdb_notifier.poll_fds + i)->fd;
	  (new_poll_fds + j)->events = (gdb_notifier.poll_fds + i)->events;
	  (new_poll_fds + j)->revents = (gdb_notifier.poll_fds + i)->revents;
	  j++;
d617 6
d624 8
a631 12
  free (gdb_notifier.poll_fds);
  gdb_notifier.poll_fds = new_poll_fds;
  gdb_notifier.num_fds--;

#else /* ! HAVE_POLL */

  if (file_ptr->mask & GDB_READABLE)
    FD_CLR (fd, &gdb_notifier.check_masks[0]);
  if (file_ptr->mask & GDB_WRITABLE)
    FD_CLR (fd, &gdb_notifier.check_masks[1]);
  if (file_ptr->mask & GDB_EXCEPTION)
    FD_CLR (fd, &gdb_notifier.check_masks[2]);
d633 1
a633 1
  /* Find current max fd. */
d635 1
a635 4
  if ((fd + 1) == gdb_notifier.num_fds)
    {
      gdb_notifier.num_fds--;
      for (i = gdb_notifier.num_fds; i; i--)
d637 9
a645 4
	  if (FD_ISSET (i - 1, &gdb_notifier.check_masks[0])
	      || FD_ISSET (i - 1, &gdb_notifier.check_masks[1])
	      || FD_ISSET (i - 1, &gdb_notifier.check_masks[2]))
	    break;
a646 1
      gdb_notifier.num_fds = i;
a647 1
#endif /* HAVE_POLL */
d699 2
d702 22
a723 16
	  error_mask = POLLHUP | POLLERR | POLLNVAL;
	  mask = (file_ptr->ready_mask & file_ptr->mask) |
	    (file_ptr->ready_mask & error_mask);
	  error_mask_returned = mask & error_mask;

	  if (error_mask_returned != 0)
	    {
	      /* Work in progress. We may need to tell somebody what
	         kind of error we had. */
	      if (error_mask_returned & POLLHUP)
		printf_unfiltered ("Hangup detected on fd %d\n", file_ptr->fd);
	      if (error_mask_returned & POLLERR)
		printf_unfiltered ("Error detected on fd %d\n", file_ptr->fd);
	      if (error_mask_returned & POLLNVAL)
		printf_unfiltered ("Invalid or non-`poll'able fd %d\n", file_ptr->fd);
	      file_ptr->error = 1;
a725 3
	    file_ptr->error = 0;
#else /* ! HAVE_POLL */
	  if (file_ptr->ready_mask & GDB_EXCEPTION)
d727 8
a734 2
	      printf_unfiltered ("Exception condition detected on fd %d\n", file_ptr->fd);
	      file_ptr->error = 1;
a735 4
	  else
	    file_ptr->error = 0;
	  mask = file_ptr->ready_mask & file_ptr->mask;
#endif /* HAVE_POLL */
a760 1
#ifdef HAVE_POLL
a761 1
#endif
d770 2
d773 35
a807 32
  num_found =
    poll (gdb_notifier.poll_fds,
	  (unsigned long) gdb_notifier.num_fds,
	  gdb_notifier.timeout_valid ? gdb_notifier.timeout : -1);

  /* Don't print anything if we get out of poll because of a
     signal. */
  if (num_found == -1 && errno != EINTR)
    perror_with_name ("Poll");

#else /* ! HAVE_POLL */

  gdb_notifier.ready_masks[0] = gdb_notifier.check_masks[0];
  gdb_notifier.ready_masks[1] = gdb_notifier.check_masks[1];
  gdb_notifier.ready_masks[2] = gdb_notifier.check_masks[2];

  num_found = select (gdb_notifier.num_fds,
		      & gdb_notifier.ready_masks[0],
		      & gdb_notifier.ready_masks[1],
		      & gdb_notifier.ready_masks[2],
		      gdb_notifier.timeout_valid
		      ? &gdb_notifier.timeout : NULL);

  /* Clear the masks after an error from select. */
  if (num_found == -1)
    {
      FD_ZERO (&gdb_notifier.ready_masks[0]);
      FD_ZERO (&gdb_notifier.ready_masks[1]);
      FD_ZERO (&gdb_notifier.ready_masks[2]);
      /* Dont print anything is we got a signal, let gdb handle it. */
      if (errno != EINTR)
	perror_with_name ("Select");
a808 1
#endif /* HAVE_POLL */
d812 2
d815 6
d822 26
a847 1
  for (i = 0; (i < gdb_notifier.num_fds) && (num_found > 0); i++)
a848 5
      if ((gdb_notifier.poll_fds + i)->revents)
	num_found--;
      else
	continue;

d850 1
a850 1
	   file_ptr != NULL;
d853 13
a865 3
	  if (file_ptr->fd == (gdb_notifier.poll_fds + i)->fd)
	    break;
	}
a866 2
      if (file_ptr)
	{
d869 1
d875 1
a876 33

      file_ptr->ready_mask = (gdb_notifier.poll_fds + i)->revents;
    }

#else /* ! HAVE_POLL */

  for (file_ptr = gdb_notifier.first_file_handler;
       (file_ptr != NULL) && (num_found > 0);
       file_ptr = file_ptr->next_file)
    {
      int mask = 0;

      if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[0]))
	mask |= GDB_READABLE;
      if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[1]))
	mask |= GDB_WRITABLE;
      if (FD_ISSET (file_ptr->fd, &gdb_notifier.ready_masks[2]))
	mask |= GDB_EXCEPTION;

      if (!mask)
	continue;
      else
	num_found--;

      /* Enqueue an event only if this is still a new event for
         this fd. */

      if (file_ptr->ready_mask == 0)
	{
	  file_event_ptr = create_file_event (file_ptr->fd);
	  async_queue_event (file_event_ptr, TAIL);
	}
      file_ptr->ready_mask = mask;
a877 3

#endif /* HAVE_POLL */

d1159 2
d1162 1
a1162 1
      gdb_notifier.timeout = delta.tv_sec * 1000;
d1164 8
a1171 3
      gdb_notifier.timeout.tv_sec = delta.tv_sec;
      gdb_notifier.timeout.tv_usec = delta.tv_usec;
#endif
@


1.3
log
@2000-03-06  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        From  Eli Zaretskii  <eliz@@is.elta.co.il>:

	* event-loop.c (poll_timers): Don't compare delta.tv_sec with
	zero, since time_t might be unsigned.
@
text
@d30 1
d38 8
a45 3
#ifndef NO_FD_SET
#define SELECT_MASK fd_set
#else
d53 1
a53 2
#endif
#endif
a60 1

d78 3
d202 1
a202 1
    fd_mask check_masks[3 * MASK_SIZE];
d205 1
a205 1
    fd_mask ready_masks[3 * MASK_SIZE];
a496 4
#ifndef HAVE_POLL
  int index, bit;
#endif

a537 3
  index = fd / (NBBY * sizeof (fd_mask));
  bit = 1 << (fd % (NBBY * sizeof (fd_mask)));

d539 1
a539 1
    gdb_notifier.check_masks[index] |= bit;
d541 1
a541 1
    gdb_notifier.check_masks[index] &= ~bit;
d544 1
a544 1
    (gdb_notifier.check_masks + MASK_SIZE)[index] |= bit;
d546 1
a546 1
    (gdb_notifier.check_masks + MASK_SIZE)[index] &= ~bit;
d549 1
a549 1
    (gdb_notifier.check_masks + 2 * (MASK_SIZE))[index] |= bit;
d551 1
a551 1
    (gdb_notifier.check_masks + 2 * (MASK_SIZE))[index] &= ~bit;
d565 3
a567 1
  int i, j;
a568 3
#ifndef HAVE_POLL
  int index, bit;
  unsigned long flags;
a605 3
  index = fd / (NBBY * sizeof (fd_mask));
  bit = 1 << (fd % (NBBY * sizeof (fd_mask)));

d607 1
a607 1
    gdb_notifier.check_masks[index] &= ~bit;
d609 1
a609 1
    (gdb_notifier.check_masks + MASK_SIZE)[index] &= ~bit;
d611 1
a611 1
    (gdb_notifier.check_masks + 2 * (MASK_SIZE))[index] &= ~bit;
d617 2
a618 1
      for (gdb_notifier.num_fds = 0; index >= 0; index--)
d620 4
a623 13
	  flags = gdb_notifier.check_masks[index]
	    | (gdb_notifier.check_masks + MASK_SIZE)[index]
	    | (gdb_notifier.check_masks + 2 * (MASK_SIZE))[index];
	  if (flags)
	    {
	      for (i = (NBBY * sizeof (fd_mask)); i > 0; i--)
		{
		  if (flags & (((unsigned long) 1) << (i - 1)))
		    break;
		}
	      gdb_notifier.num_fds = index * (NBBY * sizeof (fd_mask)) + i;
	      break;
	    }
d625 1
d734 1
a735 3

#ifndef HAVE_POLL
  int mask, bit, index;
d757 5
a761 3
  memcpy (gdb_notifier.ready_masks,
	  gdb_notifier.check_masks,
	  3 * MASK_SIZE * sizeof (fd_mask));
d763 5
a767 4
		      (SELECT_MASK *) & gdb_notifier.ready_masks[0],
		      (SELECT_MASK *) & gdb_notifier.ready_masks[MASK_SIZE],
		  (SELECT_MASK *) & gdb_notifier.ready_masks[2 * MASK_SIZE],
		  gdb_notifier.timeout_valid ? &gdb_notifier.timeout : NULL);
d772 3
a774 2
      memset (gdb_notifier.ready_masks,
	      0, 3 * MASK_SIZE * sizeof (fd_mask));
d815 1
d820 1
a820 3
      index = file_ptr->fd / (NBBY * sizeof (fd_mask));
      bit = 1 << (file_ptr->fd % (NBBY * sizeof (fd_mask)));
      mask = 0;
d822 1
a822 1
      if (gdb_notifier.ready_masks[index] & bit)
d824 1
a824 1
      if ((gdb_notifier.ready_masks + MASK_SIZE)[index] & bit)
d826 1
a826 1
      if ((gdb_notifier.ready_masks + 2 * (MASK_SIZE))[index] & bit)
d844 1
@


1.2
log
@2000-02-21  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	From Philippe De Muyter  <phdm@@macqel.be>

	* event-loop.c (handle_file_event): In case of poll, enable
 	printing of informational message if an error/exception is
 	detected on the file descriptor.
@
text
@d1117 5
a1121 2
         immediately. */
      if (delta.tv_sec < 0)
@


1.1
log
@Initial revision
@
text
@d19 2
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d22 2
d25 7
a31 1
#include <readline/readline.h>
d33 23
a55 1
#include "top.h"
d57 1
a57 2
/* For config.h which may define HAVE_POLL */
#include "defs.h"
d59 12
a70 2
#ifdef HAVE_POLL
#include <sys/poll.h>
d72 58
a129 1
#include <errno.h>
d139 1
a139 1
   the queue will be processed in a last in first out fashoin, while
d159 1
a159 1
/* As of 4/30/99 only the input file descriptor is registered with the
d176 5
d203 5
d213 24
d242 2
a243 2
    async_signal_handler *first_handler;     
    
d245 1
a245 1
    async_signal_handler *last_handler;	     
d255 11
a265 4
static void invoke_async_signal_handler PARAMS ((void));
static int gdb_wait_for_event PARAMS ((void));
static int check_async_ready PARAMS ((void));
extern display_gdb_prompt PARAMS ((char *));
d279 1
a279 3
async_queue_event (event_ptr, position)
     gdb_event *event_ptr;
     queue_position position;
d303 15
d328 1
a328 1
process_event ()
d391 6
a396 4
   it.  Returns 1 if something was done otherwise returns 0 (this can
   happen if there are no event sources to wait for). */
int
gdb_do_one_event ()
d398 32
a429 1
  int result = 0;
d431 9
d442 4
a445 34
      if (!SET_TOP_LEVEL ())
	{
	  /* Any events already waiting in the queue? */
	  if (process_event ())
	    {
	      result = 1;
	      break;
	    }

	  /* Wait for a new event.  If gdb_wait_for_event returns -1,
	     we should get out because this means that there are no
	     event sources left. This will make the event loop stop,
	     and the application exit. */

	  result = gdb_wait_for_event ();
	  if (result < 0)
	    {
	      result = 0;
	      break;
	    }

	  /* Handle any new events occurred while waiting. */
	  if (process_event ())
	    {
	      result = 1;
	      break;
	    }

	  /* If gdb_wait_for_event has returned 1, it means that one
	     event has been handled. We break out of the loop. */
	  if (result)
	    break;
	}			/* end of if !set_top_level */
      else
d447 3
d455 4
a458 1
  return result;
d462 13
d485 2
a486 6
void
create_file_handler (fd, mask, proc, client_data)
     int fd;
     int mask;
     file_handler_func *proc;
     gdb_client_data client_data;
d503 2
a504 1
  /* It is a new file descriptor. */
d512 3
d522 3
a524 3
  gdb_notifier.num_fds++;
  gdb_notifier.poll_fds =
    (struct pollfd *) realloc (gdb_notifier.poll_fds,
d526 3
d562 1
a562 2
delete_file_handler (fd)
     int fd;
a583 5
  /* Deactivate the file descriptor, by clearing its mask, 
     so that it will not fire again. */

  file_ptr->mask = 0;

d640 5
d651 1
a651 1
	   prev_ptr->next_file == file_ptr;
d664 1
a664 2
handle_file_event (event_file_desc)
     int event_file_desc;
d667 5
a671 1
  int mask, error_mask;
d694 1
d696 14
d711 7
d726 1
a726 1
	    (*file_ptr->proc) (file_ptr->client_data, mask);
d740 1
a740 1
gdb_wait_for_event ()
d744 2
a745 1
  int num_found, i;
d751 4
d760 8
a767 1
    poll (gdb_notifier.poll_fds, (unsigned long) gdb_notifier.num_fds, -1);
d777 1
a777 1
		      NULL);
d781 7
a787 3
    memset (gdb_notifier.ready_masks,
	    0, 3 * MASK_SIZE * sizeof (fd_mask));

d815 1
a815 4
	      file_event_ptr =
		(gdb_event *) xmalloc (sizeof (gdb_event));
	      file_event_ptr->proc = handle_file_event;
	      file_event_ptr->fd = file_ptr->fd;
d849 1
a849 4
	  file_event_ptr =
	    (gdb_event *) xmalloc (sizeof (gdb_event));
	  file_event_ptr->proc = handle_file_event;
	  file_event_ptr->fd = file_ptr->fd;
d867 1
a867 3
create_async_signal_handler (proc, client_data)
     async_handler_func *proc;
     gdb_client_data client_data;
d890 1
a890 2
mark_async_signal_handler (async_handler_ptr)
     async_signal_handler *async_handler_ptr;
d898 1
a898 1
invoke_async_signal_handler ()
d910 1
a910 1
      for (async_handler_ptr = sighandler_list.first_handler; 
d929 1
a929 2
delete_async_signal_handler (async_handler_ptr)
     async_signal_handler *async_handler_ptr;
d933 1
a933 1
  if (sighandler_list.first_handler == async_handler_ptr)
d935 1
a935 1
      sighandler_list.first_handler = async_handler_ptr->next_handler;
d942 1
a942 1
      while (prev_ptr->next_handler != async_handler_ptr)
d944 2
a945 2
      prev_ptr->next_handler = async_handler_ptr->next_handler;
      if (sighandler_list.last_handler == async_handler_ptr)
d948 2
a949 1
  free ((char *) async_handler_ptr);
d954 1
a954 1
check_async_ready ()
d957 187
@


1.1.1.1
log
@import gdb-1999-05-10
@
text
@@


1.1.1.2
log
@import gdb-1999-05-25 snapshot
@
text
@d62 1
a62 1
/* As of 1999-04-30 only the input file descriptor is registered with the
d127 1
@


1.1.1.3
log
@import gdb-1999-06-14 snapshot
@
text
@d534 1
a534 2
  int num_found = 0;
  int i;
@


1.1.1.4
log
@import gdb-1999-06-21 snapshot
@
text
@d21 6
d28 1
a28 2
#include "top.h"
#include "event-loop.h"
d30 1
a30 3
#include <poll.h>
#else
#include <sys/types.h>
a32 1
#include <setjmp.h>
d340 3
a342 7
  if (gdb_notifier.poll_fds)
    gdb_notifier.poll_fds =
      (struct pollfd *) realloc (gdb_notifier.poll_fds,
				 (gdb_notifier.num_fds) * sizeof (struct pollfd));
  else
     gdb_notifier.poll_fds = 
       (struct pollfd *) xmalloc (sizeof (struct pollfd));
d466 1
a466 1
	   prev_ptr->next_file != file_ptr;
@


1.1.1.5
log
@import gdb-1999-06-28 snapshot
@
text
@a121 1
static void create_file_handler PARAMS ((int, int, file_handler_func *, gdb_client_data));
a123 1
static int gdb_do_one_event PARAMS ((void));
d239 1
a239 1
static int
a280 3
	  /* FIXME: this should really be a call to a hook that is
	     interface specific, because interfaces can display the
	     prompt in their own way. */
a287 18

/* Start up the event loop. This is the entry point to the event loop
   from the command loop. */
void 
start_event_loop ()
{
  /* Loop until there is something to do. This is the entry point to
     the event loop engine. gdb_do_one_event will process one event
     for each invocation.  It always returns 1, unless there are no
     more event sources registered. In this case it returns 0.  */
  while (gdb_do_one_event () != 0)
    ;

  /* We are done with the event loop. There are no more event sources
     to listen to.  So we exit GDB. */
  return;
}

a289 16
/* Wrapper function for create_file_handler, so that the caller
   doesn't have to know implementation details about the use of poll
   vs. select. */
void 
add_file_handler (fd, proc, client_data)
     int fd;
     file_handler_func *proc;
     gdb_client_data client_data;
{
#ifdef HAVE_POLL
  create_file_handler (fd, POLLIN, (file_handler_func *) proc, client_data);
#else
  create_file_handler (fd, GDB_READABLE, (file_handler_func *) proc, client_data);
#endif
}

d300 1
a300 1
static void
@


1.1.1.6
log
@import gdb-1999-07-05 snapshot
@
text
@a292 1

d755 1
a755 1
     async_signal_handler **async_handler_ptr;
d759 1
a759 1
  if (sighandler_list.first_handler == (*async_handler_ptr))
d761 1
a761 1
      sighandler_list.first_handler = (*async_handler_ptr)->next_handler;
d768 1
a768 1
      while (prev_ptr->next_handler != (*async_handler_ptr) && prev_ptr)
d770 2
a771 2
      prev_ptr->next_handler = (*async_handler_ptr)->next_handler;
      if (sighandler_list.last_handler == (*async_handler_ptr))
d774 1
a774 2
  free ((char *) (*async_handler_ptr));
  (*async_handler_ptr) = NULL;
@


1.1.1.7
log
@import gdb-1999-07-07 post reformat
@
text
@d19 1
a19 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA. */
d109 2
a110 2
    async_signal_handler *first_handler;

d112 1
a112 1
    async_signal_handler *last_handler;
d297 1
a297 1
void
d311 1
a313 1

d317 1
a317 1
void
d381 1
a381 1
			   (gdb_notifier.num_fds) * sizeof (struct pollfd));
d383 2
a384 2
    gdb_notifier.poll_fds =
      (struct pollfd *) xmalloc (sizeof (struct pollfd));
d736 1
a736 1
      for (async_handler_ptr = sighandler_list.first_handler;
@


1.1.1.8
log
@import gdb-1999-07-19 snapshot
@
text
@d41 1
a41 1
   the queue will be processed in a last in first out fashion, while
@


1.1.1.9
log
@import gdb-1999-08-16 snapshot
@
text
@d123 1
a123 1
static void create_file_handler PARAMS ((int, int, handler_func *, gdb_client_data));
d321 1
a321 1
     void (*proc) (void);
d325 1
a325 1
  create_file_handler (fd, POLLIN, (handler_func *) proc, client_data);
d327 1
a327 1
  create_file_handler (fd, GDB_READABLE, (handler_func *) proc, client_data);
d345 1
a345 1
     handler_func *proc;
d559 1
a559 1
	    (*file_ptr->proc) (file_ptr->client_data);
a583 4
  /* Make sure all output is done before getting another event. */
  gdb_flush (gdb_stdout);
  gdb_flush (gdb_stderr);

d692 1
a692 1
     handler_func *proc;
@


1.1.1.10
log
@import gdb-1999-09-13 snapshot
@
text
@a124 1
static void handle_file_event PARAMS ((int));
a166 16
/* Create a file event, to be enqueued in the event queue for
   processing. The procedure associated to this event is always
   handle_file_event, which will in turn invoke the one that was
   associated to FD when it was registered with the event loop. */
gdb_event *
create_file_event (fd)
     int fd;
{
  gdb_event *file_event_ptr;

  file_event_ptr = (gdb_event *) xmalloc (sizeof (gdb_event));
  file_event_ptr->proc = handle_file_event;
  file_event_ptr->fd = fd;
  return (file_event_ptr);
}

d442 5
a502 5
  /* Deactivate the file descriptor, by clearing its mask, 
     so that it will not fire again. */

  file_ptr->mask = 0;

d637 4
a640 1
	      file_event_ptr = create_file_event (file_ptr->fd);
d674 4
a677 1
	  file_event_ptr = create_file_event (file_ptr->fd);
@


1.1.1.11
log
@import gdb-1999-09-21
@
text
@a24 2
#include "event-top.h"
#include "inferior.h"   /* For fetch_inferior_event. */
a31 97
#include <sys/time.h>

/* Type of the mask arguments to select. */

#ifndef NO_FD_SET
#define SELECT_MASK fd_set
#else
#ifndef _AIX
typedef long fd_mask;
#endif
#if defined(_IBMR2)
#define SELECT_MASK void
#else
#define SELECT_MASK int
#endif
#endif

/* Define "NBBY" (number of bits per byte) if it's not already defined. */

#ifndef NBBY
#define NBBY 8
#endif


/* Define the number of fd_masks in an fd_set */

#ifndef FD_SETSIZE
#ifdef OPEN_MAX
#define FD_SETSIZE OPEN_MAX
#else
#define FD_SETSIZE 256
#endif
#endif
#if !defined(howmany)
#define howmany(x, y) (((x)+((y)-1))/(y))
#endif
#ifndef NFDBITS
#define NFDBITS NBBY*sizeof(fd_mask)
#endif
#define MASK_SIZE howmany(FD_SETSIZE, NFDBITS)


typedef struct gdb_event gdb_event;
typedef void (event_handler_func) (int);

/* Event for the GDB event system.  Events are queued by calling
   async_queue_event and serviced later on by gdb_do_one_event. An
   event can be, for instance, a file descriptor becoming ready to be
   read. Servicing an event simply means that the procedure PROC will
   be called.  We have 2 queues, one for file handlers that we listen
   to in the event loop, and one for the file handlers+events that are
   ready. The procedure PROC associated with each event is always the
   same (handle_file_event).  Its duty is to invoke the handler
   associated with the file descriptor whose state change generated
   the event, plus doing other cleanups adn such. */

struct gdb_event
  {
    event_handler_func *proc;	/* Procedure to call to service this event. */
    int fd;			/* File descriptor that is ready. */
    struct gdb_event *next_event;	/* Next in list of events or NULL. */
  };

/* Information about each file descriptor we register with the event
   loop. */

typedef struct file_handler
  {
    int fd;			/* File descriptor. */
    int mask;			/* Events we want to monitor: POLLIN, etc. */
    int ready_mask;		/* Events that have been seen since
				   the last time. */
    handler_func *proc;	        /* Procedure to call when fd is ready. */
    gdb_client_data client_data;	/* Argument to pass to proc. */
    int error;                          /* Was an error detected on this fd? */
    struct file_handler *next_file;	/* Next registered file descriptor. */
  }
file_handler;

/* PROC is a function to be invoked when the READY flag is set. This
   happens when there has been a signal and the corresponding signal
   handler has 'triggered' this async_signal_handler for
   execution. The actual work to be done in response to a signal will
   be carried out by PROC at a later time, within process_event. This
   provides a deferred execution of signal handlers.
   Async_init_signals takes care of setting up such an
   asyn_signal_handler for each interesting signal. */
typedef struct async_signal_handler
  {
    int ready;			/* If ready, call this handler from the main event loop, 
				   using invoke_async_handler. */
    struct async_signal_handler *next_handler;	/* Ptr to next handler */
    sig_handler_func *proc;	                /* Function to call to do the work */
    gdb_client_data client_data;	/* Argument to async_handler_func */
  }
async_signal_handler;

a77 5
    /* Timeout in milliseconds for calls to poll(). */
    int timeout;

    /* Flag to tell whether the timeout value shuld be used. */
    int timeout_valid;
d100 1
a100 6
    /* Time structure for calls to select(). */
    struct timeval timeout;

    /* Flag to tell whether the timeout struct should be used. */
    int timeout_valid;
   }
a104 24
/* Structure associated with a timer. PROC will be executed at the
   first occasion after WHEN. */
struct gdb_timer
  {
    struct timeval when;
    int timer_id;
    struct gdb_timer *next;
    timer_handler_func *proc;         /* Function to call to do the work */
    gdb_client_data client_data;      /* Argument to async_handler_func */
  }
gdb_timer;

/* List of currently active timers. It is sorted in order of
   increasing timers.*/
static struct
  {
    /* Pointer to first in timer list. */
    struct gdb_timer *first_timer;

    /* Length of timer list. */
    int num_timers;
  }
timer_list;

d123 6
a128 11
static void create_file_handler (int fd, int mask, handler_func *proc, gdb_client_data client_data);
static void invoke_async_signal_handler (void);
static void handle_file_event (int event_file_desc);
static int gdb_wait_for_event (void);
static int gdb_do_one_event (void);
static int check_async_ready (void);
static void async_queue_event (gdb_event *event_ptr, queue_position position);
static gdb_event * create_file_event (int fd);
static int process_event (void);
static void handle_timer_event (int dummy);
static void poll_timers (void);
d142 3
a144 1
async_queue_event (gdb_event *event_ptr, queue_position position)
d172 3
a174 2
static gdb_event *
create_file_event (int fd)
d194 1
a194 1
process_event (void)
d260 1
a260 1
gdb_do_one_event (void)
a274 3
	  /* Are any timers that are ready? If so, put an event on the queue.*/
	  poll_timers ();

d316 1
a316 1
start_event_loop (void)
d331 1
d336 4
a339 1
add_file_handler (int fd, handler_func *proc, gdb_client_data client_data)
d342 1
a342 1
  create_file_handler (fd, POLLIN, proc, client_data);
d344 1
a344 1
  create_file_handler (fd, GDB_READABLE | GDB_EXCEPTION, proc, client_data);
d359 5
a363 1
create_file_handler (int fd, int mask, handler_func *proc, gdb_client_data client_data)
d380 1
a380 2
  /* It is a new file descriptor. Add it to the list. Otherwise, just
     change the data associated with it.*/
a387 3
#ifdef HAVE_POLL
      gdb_notifier.num_fds++;
#endif
d395 1
d436 2
a437 1
delete_file_handler (int fd)
d539 2
a540 1
handle_file_event (int event_file_desc)
d543 1
a543 5
  int mask;
#ifdef HAVE_POLL
  int error_mask;
  int error_mask_returned;
#endif
a565 1
	  error_mask_returned = mask & error_mask;
a566 14
	  if (error_mask_returned != 0)
	    {
	      /* Work in progress. We may need to tell somebody what
                 kind of error we had. */
	      /*if (error_mask_returned & POLLHUP)
		printf_unfiltered ("Hangup detected on fd %d\n", file_ptr->fd);
	      if (error_mask_returned & POLLERR)
		printf_unfiltered ("Error detected on fd %d\n", file_ptr->fd);
	      if (error_mask_returned & POLLNVAL)
		printf_unfiltered ("Invalid fd %d\n", file_ptr->fd);*/
	      file_ptr->error = 1;
           }
	  else 
	    file_ptr->error = 0;
a567 7
	  if (file_ptr->ready_mask & GDB_EXCEPTION)
	    {
	      printf_unfiltered ("Exception condition detected on fd %d\n", file_ptr->fd);
	      file_ptr->error = 1;
	    }
	  else
	    file_ptr->error = 0;
d576 1
a576 1
	    (*file_ptr->proc) (file_ptr->error, file_ptr->fd, file_ptr->client_data);
d590 1
a590 1
gdb_wait_for_event (void)
d610 1
a610 8
    poll (gdb_notifier.poll_fds, 
	  (unsigned long) gdb_notifier.num_fds, 
	  gdb_notifier.timeout_valid ? gdb_notifier.timeout : -1);

  /* Don't print anything if we get out of poll because of a
     signal.*/
  if (num_found == -1 && errno != EINTR)
    perror_with_name ("Poll");
d619 2
a620 2
		      (SELECT_MASK *) & gdb_notifier.ready_masks[2 * MASK_SIZE],
		      gdb_notifier.timeout_valid ? gdb_notifier.timeout : NULL);
d624 3
a626 7
    {
      memset (gdb_notifier.ready_masks,
	      0, 3 * MASK_SIZE * sizeof (fd_mask));
      /* Dont print anything is we got a signal, let gdb handle it. */
      if (errno != EINTR)
	perror_with_name ("Select");
    }
d706 3
a708 1
create_async_signal_handler (sig_handler_func *proc, gdb_client_data client_data)
d731 2
a732 1
mark_async_signal_handler (async_signal_handler *async_handler_ptr)
d740 1
a740 1
invoke_async_signal_handler (void)
d771 2
a772 1
delete_async_signal_handler (async_signal_handler **async_handler_ptr)
d797 1
a797 1
check_async_ready (void)
a799 205
}

/* FIXME: where does this function belong? */
/* General function to handle events in the inferior. So far it just
   takes care of detecting errors reported by select() or poll(),
   otherwise it assumes that all is OK, and goes on reading data from
   the fd. This however may not always be what we want to do. */
void
inferior_event_handler (int error, gdb_client_data client_data, int fd)
{
  if (error == 1)
    {
      printf_unfiltered ("error detected on fd %d\n", fd);
      delete_file_handler (fd);
      discard_all_continuations ();
    }
  else
    fetch_inferior_event (client_data);
}

/* Create a timer that will expire in MILLISECONDS from now. When the
   timer is ready, PROC will be executed. At creation, the timer is
   aded to the timers queue.  This queue is kept sorted in order of
   increasing timers. Return a handle to the timer struct.*/
int
create_timer (int milliseconds, timer_handler_func *proc, gdb_client_data client_data)
{
  struct gdb_timer *timer_ptr, *timer_index, *prev_timer;
  struct timeval time_now, delta;

  /* compute seconds */
  delta.tv_sec = milliseconds / 1000;
  /* compute microseconds */
  delta.tv_usec = (milliseconds % 1000) * 1000; 
  
  gettimeofday (&time_now, NULL);

  timer_ptr = (struct gdb_timer *) xmalloc (sizeof (gdb_timer));
  timer_ptr->when.tv_sec = time_now.tv_sec + delta.tv_sec;
  timer_ptr->when.tv_usec = time_now.tv_usec + delta.tv_usec;
  /* carry? */
  if (timer_ptr->when.tv_usec >= 1000000 )
    {
      timer_ptr->when.tv_sec += 1;
      timer_ptr->when.tv_usec -= 1000000;
    }
  timer_ptr->proc = proc;
  timer_ptr->client_data = client_data;
  timer_list.num_timers ++;
  timer_ptr->timer_id = timer_list.num_timers;

  /* Now add the timer to the timer queue, making sure it is sorted in
     increasing order of expiration. */

  for (timer_index = timer_list.first_timer; 
       timer_index != NULL; 
       timer_index = timer_index->next)
    {
      /* If the seconds field is greater or if it is the same, but the
         microsecond field is greater. */
      if ((timer_index->when.tv_sec > timer_ptr->when.tv_sec) || 
	  ((timer_index->when.tv_sec == timer_ptr->when.tv_sec)
	   && (timer_index->when.tv_usec > timer_ptr->when.tv_usec)))
	break;
    }
  
  if (timer_index == timer_list.first_timer)
    {
      timer_ptr->next = timer_list.first_timer;
      timer_list.first_timer = timer_ptr;

    }
  else
    {
      for (prev_timer = timer_list.first_timer; 
	   prev_timer->next != timer_index; 
	   prev_timer = prev_timer->next)
	;
      
      prev_timer->next = timer_ptr;
      timer_ptr->next = timer_index;
    }

  gdb_notifier.timeout_valid = 0;
  return timer_ptr->timer_id;
}

/* There is a chance that the creator of the timer wants to get rid of
   it before it expires. */
void
delete_timer (int id)
{
  struct gdb_timer *timer_ptr, *prev_timer = NULL;

  /* Find the entry for the given timer. */

  for (timer_ptr = timer_list.first_timer; timer_ptr != NULL;
       timer_ptr = timer_ptr->next)
    {
      if (timer_ptr->timer_id == id)
	break;
    }

  if (timer_ptr == NULL)
    return;
  /* Get rid of the timer in the timer list. */
  if (timer_ptr == timer_list.first_timer)
    timer_list.first_timer = timer_ptr->next;
  else
    {
      for (prev_timer = timer_list.first_timer;
	   prev_timer->next != timer_ptr;
	   prev_timer = prev_timer->next)
	;
      prev_timer->next = timer_ptr->next;
    }
  free ((char *) timer_ptr);

  gdb_notifier.timeout_valid = 0;
}

/* When a timer event is put on the event queue, it will be handled by
   this function.  Just call the assiciated procedure and delete the
   timer event from the event queue. Repeat this for each timer that
   has expired.*/
static void
handle_timer_event (int dummy)
{
  struct timeval time_now;
  struct gdb_timer *timer_ptr, *saved_timer;
 
  gettimeofday (&time_now, NULL);
  timer_ptr = timer_list.first_timer;

  while (timer_ptr != NULL)
    {
      if ((timer_ptr->when.tv_sec > time_now.tv_sec) || 
	  ((timer_ptr->when.tv_sec == time_now.tv_sec) && 
	   (timer_ptr->when.tv_usec > time_now.tv_usec)))
	break;

      /* Get rid of the timer from the beginning of the list. */
      timer_list.first_timer = timer_ptr->next;
      saved_timer = timer_ptr;
      timer_ptr = timer_ptr->next;
      /* Call the procedure associated with that timer. */
      (*saved_timer->proc) (timer_ptr->client_data);
      free (saved_timer);
    }

  gdb_notifier.timeout_valid = 0;
}
 
/* Check whether any timers in the timers queue are ready. If at least
   one timer is ready, stick an event onto the event queue.  Even in
   case more than one timer is ready, one event is enough, because the
   handle_timer_event() will go through the timers list and call the
   procedures associated with all that have expired. Update the
   timeout for the select() or poll() as well.*/
static void
poll_timers (void)
{
  struct timeval time_now, delta;
  gdb_event *event_ptr;
 
  if (timer_list.num_timers)
    {
      gettimeofday (&time_now, NULL);
      delta.tv_sec = timer_list.first_timer->when.tv_sec - time_now.tv_sec;
      delta.tv_usec = timer_list.first_timer->when.tv_usec - time_now.tv_usec;
      /* borrow? */
      if (delta.tv_usec < 0)
	{
	  delta.tv_sec -= 1;
	  delta.tv_usec += 1000000;
	}
 
      /* Oops it expired already. Tell select / poll to return
	 immediately. */
      if (delta.tv_sec < 0)
	{
	  delta.tv_sec = 0;
	  delta.tv_usec = 0;
	}

      if (delta.tv_sec == 0 && delta.tv_usec == 0)
	{
	  event_ptr = (gdb_event *) xmalloc (sizeof (gdb_event));
	  event_ptr->proc = handle_timer_event;
	  event_ptr->fd = timer_list.first_timer->timer_id;
	  async_queue_event (event_ptr, TAIL);
	}

      /* Now we need to update the timeout for select/ poll, because we
	 don't want to sit there while this timer is expiring. */
#ifdef HAVE_POLL
      gdb_notifier.timeout = delta.tv_sec * 1000; 
#else
      gdb_notifier.timeout.sec = delta.tv_sec;
      gdb_notifier.timeout.usec = delta.tv_usec;
#endif
      gdb_notifier.timeout_valid = 1;
    }
  else 
    gdb_notifier.timeout_valid = 0;
@


1.1.1.12
log
@import gdb-1999-09-28 snapshot
@
text
@d26 1
a26 1
#include "inferior.h"		/* For fetch_inferior_event. */
d106 1
a106 1
    handler_func *proc;		/* Procedure to call when fd is ready. */
d108 1
a108 1
    int error;			/* Was an error detected on this fd? */
d126 1
a126 1
    sig_handler_func *proc;	/* Function to call to do the work */
d209 1
a209 1
  }
d221 2
a222 2
    timer_handler_func *proc;	/* Function to call to do the work */
    gdb_client_data client_data;	/* Argument to async_handler_func */
d227 1
a227 1
   increasing timers. */
d256 1
a256 1
static void create_file_handler (int fd, int mask, handler_func * proc, gdb_client_data client_data);
d262 2
a263 2
static void async_queue_event (gdb_event * event_ptr, queue_position position);
static gdb_event *create_file_event (int fd);
a266 1
static int fetch_inferior_event_wrapper (gdb_client_data client_data);
d280 1
a280 1
async_queue_event (gdb_event * event_ptr, queue_position position)
d410 1
a410 1
	  /* Are any timers that are ready? If so, put an event on the queue. */
d473 1
a473 1
add_file_handler (int fd, handler_func * proc, gdb_client_data client_data)
d493 1
a493 1
create_file_handler (int fd, int mask, handler_func * proc, gdb_client_data client_data)
d511 1
a511 1
     change the data associated with it. */
d706 1
a706 1
	         kind of error we had. */
d708 5
a712 5
	         printf_unfiltered ("Hangup detected on fd %d\n", file_ptr->fd);
	         if (error_mask_returned & POLLERR)
	         printf_unfiltered ("Error detected on fd %d\n", file_ptr->fd);
	         if (error_mask_returned & POLLNVAL)
	         printf_unfiltered ("Invalid fd %d\n", file_ptr->fd); */
d714 2
a715 2
	    }
	  else
d767 2
a768 2
    poll (gdb_notifier.poll_fds,
	  (unsigned long) gdb_notifier.num_fds,
d772 1
a772 1
     signal. */
d783 2
a784 2
		  (SELECT_MASK *) & gdb_notifier.ready_masks[2 * MASK_SIZE],
		  gdb_notifier.timeout_valid ? &gdb_notifier.timeout : NULL);
d874 1
a874 1
create_async_signal_handler (sig_handler_func * proc, gdb_client_data client_data)
d897 1
a897 1
mark_async_signal_handler (async_signal_handler * async_handler_ptr)
d936 1
a936 1
delete_async_signal_handler (async_signal_handler ** async_handler_ptr)
a977 1
      pop_target ();
d981 1
a981 18
    /* Use catch errors for now, until the inner layers of
       fetch_inferior_event (i.e. readchar) can return meaningful
       error status.  If an error occurs while getting an event from
       the target, just get rid of the target. */
    if (!catch_errors (fetch_inferior_event_wrapper, client_data, "", RETURN_MASK_ALL))
      {
	delete_file_handler (fd);
	discard_all_continuations ();
	pop_target ();
	display_gdb_prompt (0);
      }
}

static int 
fetch_inferior_event_wrapper (gdb_client_data client_data)
{
  fetch_inferior_event (client_data);
  return 1;
d987 1
a987 1
   increasing timers. Return a handle to the timer struct. */
d989 1
a989 1
create_timer (int milliseconds, timer_handler_func * proc, gdb_client_data client_data)
d997 2
a998 2
  delta.tv_usec = (milliseconds % 1000) * 1000;

d1005 1
a1005 1
  if (timer_ptr->when.tv_usec >= 1000000)
d1012 1
a1012 1
  timer_list.num_timers++;
d1018 2
a1019 2
  for (timer_index = timer_list.first_timer;
       timer_index != NULL;
d1024 1
a1024 1
      if ((timer_index->when.tv_sec > timer_ptr->when.tv_sec) ||
d1029 1
a1029 1

d1038 2
a1039 2
      for (prev_timer = timer_list.first_timer;
	   prev_timer->next != timer_index;
d1042 1
a1042 1

d1088 1
a1088 1
   has expired. */
d1094 1
a1094 1

d1100 2
a1101 2
      if ((timer_ptr->when.tv_sec > time_now.tv_sec) ||
	  ((timer_ptr->when.tv_sec == time_now.tv_sec) &&
d1116 1
a1116 1

d1122 1
a1122 1
   timeout for the select() or poll() as well. */
d1128 1
a1128 1

d1140 1
a1140 1

d1142 1
a1142 1
         immediately. */
d1158 1
a1158 1
         don't want to sit there while this timer is expiring. */
d1160 1
a1160 1
      gdb_notifier.timeout = delta.tv_sec * 1000;
d1162 2
a1163 2
      gdb_notifier.timeout.tv_sec = delta.tv_sec;
      gdb_notifier.timeout.tv_usec = delta.tv_usec;
d1167 1
a1167 1
  else
@


1.1.1.13
log
@import gdb-1999-10-04 snapshot
@
text
@d26 1
d233 1
a233 1
    /* Id of the last timer created. */
d267 1
d734 1
a734 1
	    (*file_ptr->proc) (file_ptr->error, file_ptr->client_data);
d967 36
d1148 1
a1148 1
  if (timer_list.first_timer != NULL)
@


1.1.1.14
log
@import gdb-1999-11-08 snapshot
@
text
@d259 1
a259 1
static int gdb_do_one_event (void *data);
d391 2
a392 4
   it.  Returns >0 if something was done otherwise returns <0 (this
   can happen if there are no event sources to wait for).  If an error
   occures catch_errors() which calls this function returns zero. */

d394 1
a394 1
gdb_do_one_event (void *data)
d396 1
a396 32
  /* Any events already waiting in the queue? */
  if (process_event ())
    {
      return 1;
    }
  
  /* Are any timers that are ready? If so, put an event on the queue. */
  poll_timers ();
  
  /* Wait for a new event.  If gdb_wait_for_event returns -1,
     we should get out because this means that there are no
     event sources left. This will make the event loop stop,
     and the application exit. */
  
  if (gdb_wait_for_event () < 0)
    {
      return -1;
    }
  
  /* Handle any new events occurred while waiting. */
  if (process_event ())
    {
      return 1;
    }
  
  /* If gdb_wait_for_event has returned 1, it means that one
     event has been handled. We break out of the loop. */
  return 1;
}

/* Start up the event loop. This is the entry point to the event loop
   from the command loop. */
a397 9
void
start_event_loop (void)
{
  /* Loop until there is nothing to do. This is the entry point to the
     event loop engine. gdb_do_one_event, called via catch_errors()
     will process one event for each invocation.  It blocks waits for
     an event and then processes it.  >0 when an event is processed, 0
     when catch_errors() caught an error and <0 when there are no
     longer any event sources registered. */
d400 37
a436 4
      int result = catch_errors (gdb_do_one_event, 0, "", RETURN_MASK_ALL);
      if (result < 0)
	break;
      if (result == 0)
d446 15
@


1.1.1.15
log
@import gdb-1999-12-13 snapshot
@
text
@d1085 1
a1085 1
      (*saved_timer->proc) (saved_timer->client_data);
@


