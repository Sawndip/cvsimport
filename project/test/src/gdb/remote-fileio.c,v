head	1.49;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.47
	gdb_7_6-2013-04-26-release:1.47
	gdb_7_6-branch:1.47.0.2
	gdb_7_6-2013-03-12-branchpoint:1.47
	gdb_7_5_1-2012-11-29-release:1.46
	gdb_7_5-2012-08-17-release:1.46
	gdb_7_5-branch:1.46.0.2
	gdb_7_5-2012-07-18-branchpoint:1.46
	gdb_7_4_1-2012-04-26-release:1.44.2.1
	gdb_7_4-2012-01-24-release:1.44.2.1
	gdb_7_4-branch:1.44.0.2
	gdb_7_4-2011-12-13-branchpoint:1.44
	gdb_7_3_1-2011-09-04-release:1.42
	gdb_7_3-2011-07-26-release:1.42
	gdb_7_3-branch:1.42.0.2
	gdb_7_3-2011-04-01-branchpoint:1.42
	gdb_7_2-2010-09-02-release:1.36
	gdb_7_2-branch:1.36.0.2
	gdb_7_2-2010-07-07-branchpoint:1.36
	gdb_7_1-2010-03-18-release:1.33
	gdb_7_1-branch:1.33.0.2
	gdb_7_1-2010-02-18-branchpoint:1.33
	gdb_7_0_1-2009-12-22-release:1.30
	gdb_7_0-2009-10-06-release:1.30
	gdb_7_0-branch:1.30.0.4
	gdb_7_0-2009-09-16-branchpoint:1.30
	arc-sim-20090309:1.27
	msnyder-checkpoint-072509-branch:1.30.0.2
	msnyder-checkpoint-072509-branchpoint:1.30
	arc-insight_6_8-branch:1.27.0.6
	arc-insight_6_8-branchpoint:1.27
	insight_6_8-branch:1.27.0.4
	insight_6_8-branchpoint:1.27
	reverse-20081226-branch:1.29.0.6
	reverse-20081226-branchpoint:1.29
	multiprocess-20081120-branch:1.29.0.4
	multiprocess-20081120-branchpoint:1.29
	reverse-20080930-branch:1.29.0.2
	reverse-20080930-branchpoint:1.29
	reverse-20080717-branch:1.28.0.4
	reverse-20080717-branchpoint:1.28
	msnyder-reverse-20080609-branch:1.28.0.2
	msnyder-reverse-20080609-branchpoint:1.28
	drow-reverse-20070409-branch:1.23.0.2
	drow-reverse-20070409-branchpoint:1.23
	gdb_6_8-2008-03-27-release:1.27
	gdb_6_8-branch:1.27.0.2
	gdb_6_8-2008-02-26-branchpoint:1.27
	gdb_6_7_1-2007-10-29-release:1.26
	gdb_6_7-2007-10-10-release:1.26
	gdb_6_7-branch:1.26.0.2
	gdb_6_7-2007-09-07-branchpoint:1.26
	insight_6_6-20070208-release:1.20
	gdb_6_6-2006-12-18-release:1.20
	gdb_6_6-branch:1.20.0.2
	gdb_6_6-2006-11-15-branchpoint:1.20
	insight_6_5-20061003-release:1.17
	gdb-csl-symbian-6_4_50_20060226-12:1.17
	gdb-csl-sourcerygxx-3_4_4-25:1.14
	nickrob-async-20060828-mergepoint:1.20
	gdb-csl-symbian-6_4_50_20060226-11:1.17
	gdb-csl-sourcerygxx-4_1-17:1.17.2.4
	gdb-csl-20060226-branch-local-2:1.17.2.4
	gdb-csl-sourcerygxx-4_1-14:1.17.2.3
	gdb-csl-sourcerygxx-4_1-13:1.17.2.3
	gdb-csl-sourcerygxx-4_1-12:1.17.2.3
	gdb-csl-sourcerygxx-3_4_4-21:1.17.2.3
	gdb_6_5-20060621-release:1.17
	gdb-csl-sourcerygxx-4_1-9:1.17.2.3
	gdb-csl-sourcerygxx-4_1-8:1.17.2.3
	gdb-csl-sourcerygxx-4_1-7:1.17.2.1
	gdb-csl-arm-2006q1-6:1.17.2.1
	gdb-csl-sourcerygxx-4_1-6:1.17.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.17
	gdb-csl-symbian-6_4_50_20060226-9:1.17
	gdb-csl-symbian-6_4_50_20060226-8:1.17
	gdb-csl-coldfire-4_1-11:1.17
	gdb-csl-sourcerygxx-3_4_4-19:1.17
	gdb-csl-coldfire-4_1-10:1.17
	gdb_6_5-branch:1.17.0.16
	gdb_6_5-2006-05-14-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-5:1.17
	nickrob-async-20060513-branch:1.17.0.14
	nickrob-async-20060513-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-4:1.17
	msnyder-reverse-20060502-branch:1.17.0.12
	msnyder-reverse-20060502-branchpoint:1.17
	gdb-csl-morpho-4_1-4:1.17
	gdb-csl-sourcerygxx-3_4_4-17:1.17
	readline_5_1-import-branch:1.17.0.10
	readline_5_1-import-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.17
	gdb-csl-symbian-20060226-branch:1.17.0.8
	gdb-csl-symbian-20060226-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.17
	msnyder-reverse-20060331-branch:1.17.0.6
	msnyder-reverse-20060331-branchpoint:1.17
	gdb-csl-available-20060303-branch:1.17.0.4
	gdb-csl-available-20060303-branchpoint:1.17
	gdb-csl-20060226-branch:1.17.0.2
	gdb-csl-20060226-branchpoint:1.17
	gdb_6_4-20051202-release:1.14
	msnyder-fork-checkpoint-branch:1.14.0.12
	msnyder-fork-checkpoint-branchpoint:1.14
	gdb-csl-gxxpro-6_3-branch:1.14.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.14
	gdb_6_4-branch:1.14.0.8
	gdb_6_4-2005-11-01-branchpoint:1.14
	gdb-csl-arm-20051020-branch:1.14.0.6
	gdb-csl-arm-20051020-branchpoint:1.14
	msnyder-tracepoint-checkpoint-branch:1.14.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.14
	gdb-csl-arm-20050325-2005-q1b:1.14
	gdb-csl-arm-20050325-2005-q1a:1.14
	csl-arm-20050325-branch:1.14.0.2
	csl-arm-20050325-branchpoint:1.14
	gdb-post-i18n-errorwarning-20050211:1.11
	gdb-pre-i18n-errorwarning-20050211:1.10
	gdb_6_3-20041109-release:1.6
	gdb_6_3-branch:1.6.0.14
	gdb_6_3-20041019-branchpoint:1.6
	drow_intercu-merge-20040921:1.6
	drow_intercu-merge-20040915:1.6
	jimb-gdb_6_2-e500-branch:1.6.0.16
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.12
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.10
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.8
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.4
	drow_intercu-20040221-branchpoint:1.6
	cagney_bfdfile-20040213-branch:1.6.0.2
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.2
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-branch:1.4.0.14
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.4.0.12
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.10
	cagney_x86i386-20030821-branch:1.4.0.8
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-branch:1.4.0.6
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.4
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.4;
locks; strict;
comment	@ * @;


1.49
date	2013.07.31.12.44.33;	author aburgess;	state Exp;
branches;
next	1.48;

1.48
date	2013.04.22.16.46.15;	author tromey;	state Exp;
branches;
next	1.47;

1.47
date	2013.01.01.06.32.49;	author brobecke;	state Exp;
branches;
next	1.46;

1.46
date	2012.05.18.21.02.50;	author sergiodj;	state Exp;
branches;
next	1.45;

1.45
date	2012.01.04.08.17.10;	author brobecke;	state Exp;
branches;
next	1.44;

1.44
date	2011.08.04.19.10.12;	author palves;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2011.04.07.22.24.17;	author muller;	state Exp;
branches;
next	1.42;

1.42
date	2011.03.23.18.23.55;	author ktietz;	state Exp;
branches;
next	1.41;

1.41
date	2011.03.03.18.35.32;	author msnyder;	state Exp;
branches;
next	1.40;

1.40
date	2011.01.25.11.54.00;	author palves;	state Exp;
branches;
next	1.39;

1.39
date	2011.01.10.20.38.51;	author msnyder;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.05.22.22.50;	author msnyder;	state Exp;
branches;
next	1.37;

1.37
date	2011.01.01.15.33.13;	author brobecke;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.16.21.11.14;	author msnyder;	state Exp;
branches;
next	1.35;

1.35
date	2010.03.10.16.39.20;	author muller;	state Exp;
branches;
next	1.34;

1.34
date	2010.03.01.09.09.24;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2010.01.01.07.31.40;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.13.22.36.30;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.12.21.01.00;	author drow;	state Exp;
branches;
next	1.30;

1.30
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.29;

1.29
date	2008.09.13.23.37.05;	author tromey;	state Exp;
branches;
next	1.28;

1.28
date	2008.03.05.17.21.10;	author drow;	state Exp;
branches;
next	1.27;

1.27
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches
	1.27.6.1;
next	1.26;

1.26
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2007.08.10.17.49.48;	author maxim2405;	state Exp;
branches;
next	1.24;

1.24
date	2007.08.05.01.04.31;	author msnyder;	state Exp;
branches;
next	1.23;

1.23
date	2007.01.09.17.58.56;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2007.01.03.19.01.25;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.15.23.17.56;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2006.07.19.06.21.23;	author nathan;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.13.08.55.21;	author nathan;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.08.19.08.22;	author nathan;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.17.14.47.31;	author drow;	state Exp;
branches
	1.17.2.1
	1.17.14.1;
next	1.16;

1.16
date	2006.01.17.14.11.16;	author drow;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.21.21.23.35;	author mmitchel;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.16.15.58.41;	author mmitchel;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.14.18.10.10;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.11.04.06.02;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.19.21.15.44;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.14.23.27.14;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.13.00.12.49;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.12.18.31.32;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.27.23.19.51;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.30.06.52.09;	author eliz;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.11.13.50.11;	author cagney;	state Exp;
branches
	1.4.6.1
	1.4.14.1;
next	1.3;

1.3
date	2003.06.11.10.24.53;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.10.19.29.57;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.10.14.37.04;	author corinna;	state Exp;
branches;
next	;

1.44.2.1
date	2012.01.06.04.43.26;	author brobecke;	state Exp;
branches;
next	;

1.27.6.1
date	2009.09.11.04.45.46;	author amylaar;	state Exp;
branches;
next	;

1.17.2.1
date	2006.05.24.08.00.02;	author nathan;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2006.06.09.20.25.24;	author nathan;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2006.06.10.17.56.57;	author drow;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2006.07.18.07.27.41;	author nathan;	state Exp;
branches;
next	;

1.17.14.1
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;

1.4.6.1
date	2003.06.27.21.50.07;	author carlton;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2004.01.26.19.11.29;	author carlton;	state Exp;
branches;
next	;

1.4.14.1
date	2003.12.14.20.27.28;	author drow;	state Exp;
branches;
next	1.4.14.2;

1.4.14.2
date	2004.01.13.16.11.58;	author drow;	state Exp;
branches;
next	1.4.14.3;

1.4.14.3
date	2004.02.09.19.43.46;	author drow;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Replace most uses of deprecated_throw_reason with quit.

  http://sourceware.org/ml/gdb-patches/2013-07/msg00778.html

gdb/ChangeLog

        * monitor.c (monitor_interrupt_query): Replace use of
        deprecated_throw_reason with quit.
        * nto-procfs.c (interrupt_query): Likewise.
        * remote-fileio.c (remote_fileio_sig_exit): Likewise.
        * remote-mips.c (mips_kill): Likewise.
        * remote.c (interrupt_query): Likewise.
@
text
@/* Remote File-I/O communications

   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* See the GDB User Guide for details of the GDB remote protocol.  */

#include "defs.h"
#include "gdb_string.h"
#include "gdbcmd.h"
#include "remote.h"
#include "gdb/fileio.h"
#include "gdb_wait.h"
#include "gdb_stat.h"
#include "exceptions.h"
#include "remote-fileio.h"
#include "event-loop.h"
#include "target.h"
#include "filenames.h"
#include "filestuff.h"

#include <fcntl.h>
#include <sys/time.h>
#ifdef __CYGWIN__
#include <sys/cygwin.h>		/* For cygwin_conv_path.  */
#endif
#include <signal.h>

static struct {
  int *fd_map;
  int fd_map_size;
} remote_fio_data;

#define FIO_FD_INVALID		-1
#define FIO_FD_CONSOLE_IN	-2
#define FIO_FD_CONSOLE_OUT	-3

static int remote_fio_system_call_allowed = 0;

static struct async_signal_handler *sigint_fileio_token;

static int
remote_fileio_init_fd_map (void)
{
  int i;

  if (!remote_fio_data.fd_map)
    {
      remote_fio_data.fd_map = (int *) xmalloc (10 * sizeof (int));
      remote_fio_data.fd_map_size = 10;
      remote_fio_data.fd_map[0] = FIO_FD_CONSOLE_IN;
      remote_fio_data.fd_map[1] = FIO_FD_CONSOLE_OUT;
      remote_fio_data.fd_map[2] = FIO_FD_CONSOLE_OUT;
      for (i = 3; i < 10; ++i)
        remote_fio_data.fd_map[i] = FIO_FD_INVALID;
    }
  return 3;
}

static int
remote_fileio_resize_fd_map (void)
{
  int i = remote_fio_data.fd_map_size;

  if (!remote_fio_data.fd_map)
    return remote_fileio_init_fd_map ();
  remote_fio_data.fd_map_size += 10;
  remote_fio_data.fd_map =
    (int *) xrealloc (remote_fio_data.fd_map,
		      remote_fio_data.fd_map_size * sizeof (int));
  for (; i < remote_fio_data.fd_map_size; i++)
    remote_fio_data.fd_map[i] = FIO_FD_INVALID;
  return remote_fio_data.fd_map_size - 10;
}

static int
remote_fileio_next_free_fd (void)
{
  int i;

  for (i = 0; i < remote_fio_data.fd_map_size; ++i)
    if (remote_fio_data.fd_map[i] == FIO_FD_INVALID)
      return i;
  return remote_fileio_resize_fd_map ();
}

static int
remote_fileio_fd_to_targetfd (int fd)
{
  int target_fd = remote_fileio_next_free_fd ();

  remote_fio_data.fd_map[target_fd] = fd;
  return target_fd;
}

static int
remote_fileio_map_fd (int target_fd)
{
  remote_fileio_init_fd_map ();
  if (target_fd < 0 || target_fd >= remote_fio_data.fd_map_size)
    return FIO_FD_INVALID;
  return remote_fio_data.fd_map[target_fd];
}

static void
remote_fileio_close_target_fd (int target_fd)
{
  remote_fileio_init_fd_map ();
  if (target_fd >= 0 && target_fd < remote_fio_data.fd_map_size)
    remote_fio_data.fd_map[target_fd] = FIO_FD_INVALID;
}

static int
remote_fileio_oflags_to_host (long flags)
{
  int hflags = 0;

  if (flags & FILEIO_O_CREAT)
    hflags |= O_CREAT;
  if (flags & FILEIO_O_EXCL)
    hflags |= O_EXCL;
  if (flags & FILEIO_O_TRUNC)
    hflags |= O_TRUNC;
  if (flags & FILEIO_O_APPEND)
    hflags |= O_APPEND;
  if (flags & FILEIO_O_RDONLY)
    hflags |= O_RDONLY;
  if (flags & FILEIO_O_WRONLY)
    hflags |= O_WRONLY;
  if (flags & FILEIO_O_RDWR)
    hflags |= O_RDWR;
/* On systems supporting binary and text mode, always open files in
   binary mode.  */
#ifdef O_BINARY
  hflags |= O_BINARY;
#endif
  return hflags;
}

static mode_t
remote_fileio_mode_to_host (long mode, int open_call)
{
  mode_t hmode = 0;

  if (!open_call)
    {
      if (mode & FILEIO_S_IFREG)
	hmode |= S_IFREG;
      if (mode & FILEIO_S_IFDIR)
	hmode |= S_IFDIR;
      if (mode & FILEIO_S_IFCHR)
	hmode |= S_IFCHR;
    }
  if (mode & FILEIO_S_IRUSR)
    hmode |= S_IRUSR;
  if (mode & FILEIO_S_IWUSR)
    hmode |= S_IWUSR;
  if (mode & FILEIO_S_IXUSR)
    hmode |= S_IXUSR;
#ifdef S_IRGRP
  if (mode & FILEIO_S_IRGRP)
    hmode |= S_IRGRP;
#endif
#ifdef S_IWGRP
  if (mode & FILEIO_S_IWGRP)
    hmode |= S_IWGRP;
#endif
#ifdef S_IXGRP
  if (mode & FILEIO_S_IXGRP)
    hmode |= S_IXGRP;
#endif
  if (mode & FILEIO_S_IROTH)
    hmode |= S_IROTH;
#ifdef S_IWOTH
  if (mode & FILEIO_S_IWOTH)
    hmode |= S_IWOTH;
#endif
#ifdef S_IXOTH
  if (mode & FILEIO_S_IXOTH)
    hmode |= S_IXOTH;
#endif
  return hmode;
}

static LONGEST
remote_fileio_mode_to_target (mode_t mode)
{
  mode_t tmode = 0;

  if (S_ISREG(mode))
    tmode |= FILEIO_S_IFREG;
  if (S_ISDIR(mode))
    tmode |= FILEIO_S_IFDIR;
  if (S_ISCHR(mode))
    tmode |= FILEIO_S_IFCHR;
  if (mode & S_IRUSR)
    tmode |= FILEIO_S_IRUSR;
  if (mode & S_IWUSR)
    tmode |= FILEIO_S_IWUSR;
  if (mode & S_IXUSR)
    tmode |= FILEIO_S_IXUSR;
#ifdef S_IRGRP
  if (mode & S_IRGRP)
    tmode |= FILEIO_S_IRGRP;
#endif
#ifdef S_IWRGRP
  if (mode & S_IWGRP)
    tmode |= FILEIO_S_IWGRP;
#endif
#ifdef S_IXGRP
  if (mode & S_IXGRP)
    tmode |= FILEIO_S_IXGRP;
#endif
  if (mode & S_IROTH)
    tmode |= FILEIO_S_IROTH;
#ifdef S_IWOTH
  if (mode & S_IWOTH)
    tmode |= FILEIO_S_IWOTH;
#endif
#ifdef S_IXOTH
  if (mode & S_IXOTH)
    tmode |= FILEIO_S_IXOTH;
#endif
  return tmode;
}

static int
remote_fileio_errno_to_target (int error)
{
  switch (error)
    {
      case EPERM:
        return FILEIO_EPERM;
      case ENOENT:
        return FILEIO_ENOENT;
      case EINTR:
        return FILEIO_EINTR;
      case EIO:
        return FILEIO_EIO;
      case EBADF:
        return FILEIO_EBADF;
      case EACCES:
        return FILEIO_EACCES;
      case EFAULT:
        return FILEIO_EFAULT;
      case EBUSY:
        return FILEIO_EBUSY;
      case EEXIST:
        return FILEIO_EEXIST;
      case ENODEV:
        return FILEIO_ENODEV;
      case ENOTDIR:
        return FILEIO_ENOTDIR;
      case EISDIR:
        return FILEIO_EISDIR;
      case EINVAL:
        return FILEIO_EINVAL;
      case ENFILE:
        return FILEIO_ENFILE;
      case EMFILE:
        return FILEIO_EMFILE;
      case EFBIG:
        return FILEIO_EFBIG;
      case ENOSPC:
        return FILEIO_ENOSPC;
      case ESPIPE:
        return FILEIO_ESPIPE;
      case EROFS:
        return FILEIO_EROFS;
      case ENOSYS:
        return FILEIO_ENOSYS;
      case ENAMETOOLONG:
        return FILEIO_ENAMETOOLONG;
    }
  return FILEIO_EUNKNOWN;
}

static int
remote_fileio_seek_flag_to_host (long num, int *flag)
{
  if (!flag)
    return 0;
  switch (num)
    {
      case FILEIO_SEEK_SET:
        *flag = SEEK_SET;
	break;
      case FILEIO_SEEK_CUR:
        *flag =  SEEK_CUR;
	break;
      case FILEIO_SEEK_END:
        *flag =  SEEK_END;
	break;
      default:
        return -1;
    }
  return 0;
}

static int
remote_fileio_extract_long (char **buf, LONGEST *retlong)
{
  char *c;
  int sign = 1;

  if (!buf || !*buf || !**buf || !retlong)
    return -1;
  c = strchr (*buf, ',');
  if (c)
    *c++ = '\0';
  else
    c = strchr (*buf, '\0');
  while (strchr ("+-", **buf))
    {
      if (**buf == '-')
	sign = -sign;
      ++*buf;
    }
  for (*retlong = 0; **buf; ++*buf)
    {
      *retlong <<= 4;
      if (**buf >= '0' && **buf <= '9')
        *retlong += **buf - '0';
      else if (**buf >= 'a' && **buf <= 'f')
        *retlong += **buf - 'a' + 10;
      else if (**buf >= 'A' && **buf <= 'F')
        *retlong += **buf - 'A' + 10;
      else
        return -1;
    }
  *retlong *= sign;
  *buf = c;
  return 0;
}

static int
remote_fileio_extract_int (char **buf, long *retint)
{
  int ret;
  LONGEST retlong;

  if (!retint)
    return -1;
  ret = remote_fileio_extract_long (buf, &retlong);
  if (!ret)
    *retint = (long) retlong;
  return ret;
}

static int
remote_fileio_extract_ptr_w_len (char **buf, CORE_ADDR *ptrval, int *length)
{
  char *c;
  LONGEST retlong;

  if (!buf || !*buf || !**buf || !ptrval || !length)
    return -1;
  c = strchr (*buf, '/');
  if (!c)
    return -1;
  *c++ = '\0';
  if (remote_fileio_extract_long (buf, &retlong))
    return -1;
  *ptrval = (CORE_ADDR) retlong;
  *buf = c;
  if (remote_fileio_extract_long (buf, &retlong))
    return -1;
  *length = (int) retlong;
  return 0;
}

/* Convert to big endian.  */
static void
remote_fileio_to_be (LONGEST num, char *buf, int bytes)
{
  int i;

  for (i = 0; i < bytes; ++i)
    buf[i] = (num >> (8 * (bytes - i - 1))) & 0xff;
}

static void
remote_fileio_to_fio_uint (long num, fio_uint_t fnum)
{
  remote_fileio_to_be ((LONGEST) num, (char *) fnum, 4);
}

static void
remote_fileio_to_fio_mode (mode_t num, fio_mode_t fnum)
{
  remote_fileio_to_be (remote_fileio_mode_to_target(num), (char *) fnum, 4);
}

static void
remote_fileio_to_fio_time (time_t num, fio_time_t fnum)
{
  remote_fileio_to_be ((LONGEST) num, (char *) fnum, 4);
}

static void
remote_fileio_to_fio_long (LONGEST num, fio_long_t fnum)
{
  remote_fileio_to_be (num, (char *) fnum, 8);
}

static void
remote_fileio_to_fio_ulong (LONGEST num, fio_ulong_t fnum)
{
  remote_fileio_to_be (num, (char *) fnum, 8);
}

static void
remote_fileio_to_fio_stat (struct stat *st, struct fio_stat *fst)
{
  LONGEST blksize;

  /* `st_dev' is set in the calling function.  */
  remote_fileio_to_fio_uint ((long) st->st_ino, fst->fst_ino);
  remote_fileio_to_fio_mode (st->st_mode, fst->fst_mode);
  remote_fileio_to_fio_uint ((long) st->st_nlink, fst->fst_nlink);
  remote_fileio_to_fio_uint ((long) st->st_uid, fst->fst_uid);
  remote_fileio_to_fio_uint ((long) st->st_gid, fst->fst_gid);
  remote_fileio_to_fio_uint ((long) st->st_rdev, fst->fst_rdev);
  remote_fileio_to_fio_ulong ((LONGEST) st->st_size, fst->fst_size);
#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE
  blksize = st->st_blksize;
#else
  blksize = 512;
#endif
  remote_fileio_to_fio_ulong (blksize, fst->fst_blksize);
#if HAVE_STRUCT_STAT_ST_BLOCKS
  remote_fileio_to_fio_ulong ((LONGEST) st->st_blocks, fst->fst_blocks);
#else
  /* FIXME: This is correct for DJGPP, but other systems that don't
     have st_blocks, if any, might prefer 512 instead of st_blksize.
     (eliz, 30-12-2003)  */
  remote_fileio_to_fio_ulong (((LONGEST) st->st_size + blksize - 1)
			      / blksize,
			      fst->fst_blocks);
#endif
  remote_fileio_to_fio_time (st->st_atime, fst->fst_atime);
  remote_fileio_to_fio_time (st->st_mtime, fst->fst_mtime);
  remote_fileio_to_fio_time (st->st_ctime, fst->fst_ctime);
}

static void
remote_fileio_to_fio_timeval (struct timeval *tv, struct fio_timeval *ftv)
{
  remote_fileio_to_fio_time (tv->tv_sec, ftv->ftv_sec);
  remote_fileio_to_fio_long (tv->tv_usec, ftv->ftv_usec);
}

static int remote_fio_ctrl_c_flag = 0;
static int remote_fio_no_longjmp = 0;

#if defined (HAVE_SIGACTION) && defined (SA_RESTART)
static struct sigaction remote_fio_sa;
static struct sigaction remote_fio_osa;
#else
static void (*remote_fio_ofunc)(int);
#endif

static void
remote_fileio_sig_init (void)
{
#if defined (HAVE_SIGACTION) && defined (SA_RESTART)
  remote_fio_sa.sa_handler = SIG_IGN;
  sigemptyset (&remote_fio_sa.sa_mask);
  remote_fio_sa.sa_flags = 0;
  sigaction (SIGINT, &remote_fio_sa, &remote_fio_osa);
#else
  remote_fio_ofunc = signal (SIGINT, SIG_IGN);
#endif
}

static void
remote_fileio_sig_set (void (*sigint_func)(int))
{
#if defined (HAVE_SIGACTION) && defined (SA_RESTART)
  remote_fio_sa.sa_handler = sigint_func;
  sigemptyset (&remote_fio_sa.sa_mask);
  remote_fio_sa.sa_flags = 0;
  sigaction (SIGINT, &remote_fio_sa, NULL);
#else
  signal (SIGINT, sigint_func);
#endif
}

static void
remote_fileio_sig_exit (void)
{
#if defined (HAVE_SIGACTION) && defined (SA_RESTART)
  sigaction (SIGINT, &remote_fio_osa, NULL);
#else
  signal (SIGINT, remote_fio_ofunc);
#endif
}

static void
async_remote_fileio_interrupt (gdb_client_data arg)
{
  quit ();
}

static void
remote_fileio_ctrl_c_signal_handler (int signo)
{
  remote_fileio_sig_set (SIG_IGN);
  remote_fio_ctrl_c_flag = 1;
  if (!remote_fio_no_longjmp)
    gdb_call_async_signal_handler (sigint_fileio_token, 1);
  remote_fileio_sig_set (remote_fileio_ctrl_c_signal_handler);
}

static void
remote_fileio_reply (int retcode, int error)
{
  char buf[32];

  remote_fileio_sig_set (SIG_IGN);
  strcpy (buf, "F");
  if (retcode < 0)
    {
      strcat (buf, "-");
      retcode = -retcode;
    }
  sprintf (buf + strlen (buf), "%x", retcode);
  if (error || remote_fio_ctrl_c_flag)
    {
      if (error && remote_fio_ctrl_c_flag)
        error = FILEIO_EINTR;
      if (error < 0)
        {
	  strcat (buf, "-");
	  error = -error;
	}
      sprintf (buf + strlen (buf), ",%x", error);
      if (remote_fio_ctrl_c_flag)
        strcat (buf, ",C");
    }
  remote_fileio_sig_set (remote_fileio_ctrl_c_signal_handler);
  putpkt (buf);
}

static void
remote_fileio_ioerror (void)
{
  remote_fileio_reply (-1, FILEIO_EIO);
}

static void
remote_fileio_badfd (void)
{
  remote_fileio_reply (-1, FILEIO_EBADF);
}

static void
remote_fileio_return_errno (int retcode)
{
  remote_fileio_reply (retcode, retcode < 0
		       ? remote_fileio_errno_to_target (errno) : 0);
}

static void
remote_fileio_return_success (int retcode)
{
  remote_fileio_reply (retcode, 0);
}

static void
remote_fileio_func_open (char *buf)
{
  CORE_ADDR ptrval;
  int length;
  long num;
  int flags, fd;
  mode_t mode;
  char *pathname;
  struct stat st;

  /* 1. Parameter: Ptr to pathname / length incl. trailing zero.  */
  if (remote_fileio_extract_ptr_w_len (&buf, &ptrval, &length))
    {
      remote_fileio_ioerror ();
      return;
    }
  /* 2. Parameter: open flags */
  if (remote_fileio_extract_int (&buf, &num))
    {
      remote_fileio_ioerror ();
      return;
    }
  flags = remote_fileio_oflags_to_host (num);
  /* 3. Parameter: open mode */
  if (remote_fileio_extract_int (&buf, &num))
    {
      remote_fileio_ioerror ();
      return;
    }
  mode = remote_fileio_mode_to_host (num, 1);

  /* Request pathname.  */
  pathname = alloca (length);
  if (target_read_memory (ptrval, (gdb_byte *) pathname, length) != 0)
    {
      remote_fileio_ioerror ();
      return;
    }

  /* Check if pathname exists and is not a regular file or directory.  If so,
     return an appropriate error code.  Same for trying to open directories
     for writing.  */
  if (!stat (pathname, &st))
    {
      if (!S_ISREG (st.st_mode) && !S_ISDIR (st.st_mode))
	{
	  remote_fileio_reply (-1, FILEIO_ENODEV);
	  return;
	}
      if (S_ISDIR (st.st_mode)
	  && ((flags & O_WRONLY) == O_WRONLY || (flags & O_RDWR) == O_RDWR))
	{
	  remote_fileio_reply (-1, FILEIO_EISDIR);
	  return;
	}
    }

  remote_fio_no_longjmp = 1;
  fd = gdb_open_cloexec (pathname, flags, mode);
  if (fd < 0)
    {
      remote_fileio_return_errno (-1);
      return;
    }

  fd = remote_fileio_fd_to_targetfd (fd);
  remote_fileio_return_success (fd);
}

static void
remote_fileio_func_close (char *buf)
{
  long num;
  int fd;

  /* Parameter: file descriptor */
  if (remote_fileio_extract_int (&buf, &num))
    {
      remote_fileio_ioerror ();
      return;
    }
  fd = remote_fileio_map_fd ((int) num);
  if (fd == FIO_FD_INVALID)
    {
      remote_fileio_badfd ();
      return;
    }

  remote_fio_no_longjmp = 1;
  if (fd != FIO_FD_CONSOLE_IN && fd != FIO_FD_CONSOLE_OUT && close (fd))
    remote_fileio_return_errno (-1);
  remote_fileio_close_target_fd ((int) num);
  remote_fileio_return_success (0);
}

static void
remote_fileio_func_read (char *buf)
{
  long target_fd, num;
  LONGEST lnum;
  CORE_ADDR ptrval;
  int fd, ret;
  gdb_byte *buffer;
  size_t length;
  off_t old_offset, new_offset;

  /* 1. Parameter: file descriptor */
  if (remote_fileio_extract_int (&buf, &target_fd))
    {
      remote_fileio_ioerror ();
      return;
    }
  fd = remote_fileio_map_fd ((int) target_fd);
  if (fd == FIO_FD_INVALID)
    {
      remote_fileio_badfd ();
      return;
    }
  /* 2. Parameter: buffer pointer */
  if (remote_fileio_extract_long (&buf, &lnum))
    {
      remote_fileio_ioerror ();
      return;
    }
  ptrval = (CORE_ADDR) lnum;
  /* 3. Parameter: buffer length */
  if (remote_fileio_extract_int (&buf, &num))
    {
      remote_fileio_ioerror ();
      return;
    }
  length = (size_t) num;

  switch (fd)
    {
      case FIO_FD_CONSOLE_OUT:
	remote_fileio_badfd ();
	return;
      case FIO_FD_CONSOLE_IN:
	{
	  static char *remaining_buf = NULL;
	  static int remaining_length = 0;

	  buffer = (gdb_byte *) xmalloc (16384);
	  if (remaining_buf)
	    {
	      remote_fio_no_longjmp = 1;
	      if (remaining_length > length)
		{
		  memcpy (buffer, remaining_buf, length);
		  memmove (remaining_buf, remaining_buf + length,
			   remaining_length - length);
		  remaining_length -= length;
		  ret = length;
		}
	      else
		{
		  memcpy (buffer, remaining_buf, remaining_length);
		  xfree (remaining_buf);
		  remaining_buf = NULL;
		  ret = remaining_length;
		}
	    }
	  else
	    {
	      /* Windows (at least XP and Server 2003) has difficulty
		 with large reads from consoles.  If a handle is
		 backed by a real console device, overly large reads
		 from the handle will fail and set errno == ENOMEM.
		 On a Windows Server 2003 system where I tested,
		 reading 26608 bytes from the console was OK, but
		 anything above 26609 bytes would fail.  The limit has
		 been observed to vary on different systems.  So, we
		 limit this read to something smaller than that - by a
		 safe margin, in case the limit depends on system
		 resources or version.  */
	      ret = ui_file_read (gdb_stdtargin, (char *) buffer, 16383);
	      remote_fio_no_longjmp = 1;
	      if (ret > 0 && (size_t)ret > length)
		{
		  remaining_buf = (char *) xmalloc (ret - length);
		  remaining_length = ret - length;
		  memcpy (remaining_buf, buffer + length, remaining_length);
		  ret = length;
		}
	    }
	}
	break;
      default:
	buffer = (gdb_byte *) xmalloc (length);
	/* POSIX defines EINTR behaviour of read in a weird way.  It's allowed
	   for read() to return -1 even if "some" bytes have been read.  It
	   has been corrected in SUSv2 but that doesn't help us much...
	   Therefore a complete solution must check how many bytes have been
	   read on EINTR to return a more reliable value to the target */
	old_offset = lseek (fd, 0, SEEK_CUR);
	remote_fio_no_longjmp = 1;
	ret = read (fd, buffer, length);
	if (ret < 0 && errno == EINTR)
	  {
	    new_offset = lseek (fd, 0, SEEK_CUR);
	    /* If some data has been read, return the number of bytes read.
	       The Ctrl-C flag is set in remote_fileio_reply() anyway.  */
	    if (old_offset != new_offset)
	      ret = new_offset - old_offset;
	  }
	break;
    }

  if (ret > 0)
    {
      errno = target_write_memory (ptrval, buffer, ret);
      if (errno != 0)
	ret = -1;
    }

  if (ret < 0)
    remote_fileio_return_errno (-1);
  else
    remote_fileio_return_success (ret);

  xfree (buffer);
}

static void
remote_fileio_func_write (char *buf)
{
  long target_fd, num;
  LONGEST lnum;
  CORE_ADDR ptrval;
  int fd, ret;
  gdb_byte *buffer;
  size_t length;

  /* 1. Parameter: file descriptor */
  if (remote_fileio_extract_int (&buf, &target_fd))
    {
      remote_fileio_ioerror ();
      return;
    }
  fd = remote_fileio_map_fd ((int) target_fd);
  if (fd == FIO_FD_INVALID)
    {
      remote_fileio_badfd ();
      return;
    }
  /* 2. Parameter: buffer pointer */
  if (remote_fileio_extract_long (&buf, &lnum))
    {
      remote_fileio_ioerror ();
      return;
    }
  ptrval = (CORE_ADDR) lnum;
  /* 3. Parameter: buffer length */
  if (remote_fileio_extract_int (&buf, &num))
    {
      remote_fileio_ioerror ();
      return;
    }
  length = (size_t) num;
    
  buffer = (gdb_byte *) xmalloc (length);
  if (target_read_memory (ptrval, buffer, length) != 0)
    {
      xfree (buffer);
      remote_fileio_ioerror ();
      return;
    }

  remote_fio_no_longjmp = 1;
  switch (fd)
    {
      case FIO_FD_CONSOLE_IN:
	remote_fileio_badfd ();
	xfree (buffer);
	return;
      case FIO_FD_CONSOLE_OUT:
	ui_file_write (target_fd == 1 ? gdb_stdtarg : gdb_stdtargerr,
		       (char *) buffer, length);
	gdb_flush (target_fd == 1 ? gdb_stdtarg : gdb_stdtargerr);
	ret = length;
	break;
      default:
	ret = write (fd, buffer, length);
	if (ret < 0 && errno == EACCES)
	  errno = EBADF; /* Cygwin returns EACCESS when writing to a
			    R/O file.  */
	break;
    }

  if (ret < 0)
    remote_fileio_return_errno (-1);
  else
    remote_fileio_return_success (ret);

  xfree (buffer);
}

static void
remote_fileio_func_lseek (char *buf)
{
  long num;
  LONGEST lnum;
  int fd, flag;
  off_t offset, ret;

  /* 1. Parameter: file descriptor */
  if (remote_fileio_extract_int (&buf, &num))
    {
      remote_fileio_ioerror ();
      return;
    }
  fd = remote_fileio_map_fd ((int) num);
  if (fd == FIO_FD_INVALID)
    {
      remote_fileio_badfd ();
      return;
    }
  else if (fd == FIO_FD_CONSOLE_IN || fd == FIO_FD_CONSOLE_OUT)
    {
      remote_fileio_reply (-1, FILEIO_ESPIPE);
      return;
    }

  /* 2. Parameter: offset */
  if (remote_fileio_extract_long (&buf, &lnum))
    {
      remote_fileio_ioerror ();
      return;
    }
  offset = (off_t) lnum;
  /* 3. Parameter: flag */
  if (remote_fileio_extract_int (&buf, &num))
    {
      remote_fileio_ioerror ();
      return;
    }
  if (remote_fileio_seek_flag_to_host (num, &flag))
    {
      remote_fileio_reply (-1, FILEIO_EINVAL);
      return;
    }
  
  remote_fio_no_longjmp = 1;
  ret = lseek (fd, offset, flag);

  if (ret == (off_t) -1)
    remote_fileio_return_errno (-1);
  else
    remote_fileio_return_success (ret);
}

static void
remote_fileio_func_rename (char *buf)
{
  CORE_ADDR old_ptr, new_ptr;
  int old_len, new_len;
  char *oldpath, *newpath;
  int ret, of, nf;
  struct stat ost, nst;

  /* 1. Parameter: Ptr to oldpath / length incl. trailing zero */
  if (remote_fileio_extract_ptr_w_len (&buf, &old_ptr, &old_len))
    {
      remote_fileio_ioerror ();
      return;
    }
  
  /* 2. Parameter: Ptr to newpath / length incl. trailing zero */
  if (remote_fileio_extract_ptr_w_len (&buf, &new_ptr, &new_len))
    {
      remote_fileio_ioerror ();
      return;
    }
  
  /* Request oldpath using 'm' packet */
  oldpath = alloca (old_len);
  if (target_read_memory (old_ptr, (gdb_byte *) oldpath, old_len) != 0)
    {
      remote_fileio_ioerror ();
      return;
    }
  
  /* Request newpath using 'm' packet */
  newpath = alloca (new_len);
  if (target_read_memory (new_ptr, (gdb_byte *) newpath, new_len) != 0)
    {
      remote_fileio_ioerror ();
      return;
    }
  
  /* Only operate on regular files and directories.  */
  of = stat (oldpath, &ost);
  nf = stat (newpath, &nst);
  if ((!of && !S_ISREG (ost.st_mode) && !S_ISDIR (ost.st_mode))
      || (!nf && !S_ISREG (nst.st_mode) && !S_ISDIR (nst.st_mode)))
    {
      remote_fileio_reply (-1, FILEIO_EACCES);
      return;
    }

  remote_fio_no_longjmp = 1;
  ret = rename (oldpath, newpath);

  if (ret == -1)
    {
      /* Special case: newpath is a non-empty directory.  Some systems
         return ENOTEMPTY, some return EEXIST.  We coerce that to be
	 always EEXIST.  */
      if (errno == ENOTEMPTY)
        errno = EEXIST;
#ifdef __CYGWIN__
      /* Workaround some Cygwin problems with correct errnos.  */
      if (errno == EACCES)
        {
	  if (!of && !nf && S_ISDIR (nst.st_mode))
	    {
	      if (S_ISREG (ost.st_mode))
		errno = EISDIR;
	      else
		{
		  char oldfullpath[PATH_MAX];
		  char newfullpath[PATH_MAX];
		  int len;

		  cygwin_conv_path (CCP_WIN_A_TO_POSIX, oldpath, oldfullpath,
				    PATH_MAX);
		  cygwin_conv_path (CCP_WIN_A_TO_POSIX, newpath, newfullpath,
				    PATH_MAX);
		  len = strlen (oldfullpath);
		  if (IS_DIR_SEPARATOR (newfullpath[len])
		      && !filename_ncmp (oldfullpath, newfullpath, len))
		    errno = EINVAL;
		  else
		    errno = EEXIST;
		}
	    }
	}
#endif

      remote_fileio_return_errno (-1);
    }
  else
    remote_fileio_return_success (ret);
}

static void
remote_fileio_func_unlink (char *buf)
{
  CORE_ADDR ptrval;
  int length;
  char *pathname;
  int ret;
  struct stat st;

  /* Parameter: Ptr to pathname / length incl. trailing zero */
  if (remote_fileio_extract_ptr_w_len (&buf, &ptrval, &length))
    {
      remote_fileio_ioerror ();
      return;
    }
  /* Request pathname using 'm' packet */
  pathname = alloca (length);
  if (target_read_memory (ptrval, (gdb_byte *) pathname, length) != 0)
    {
      remote_fileio_ioerror ();
      return;
    }

  /* Only operate on regular files (and directories, which allows to return
     the correct return code).  */
  if (!stat (pathname, &st) && !S_ISREG (st.st_mode) && !S_ISDIR (st.st_mode))
    {
      remote_fileio_reply (-1, FILEIO_ENODEV);
      return;
    }

  remote_fio_no_longjmp = 1;
  ret = unlink (pathname);

  if (ret == -1)
    remote_fileio_return_errno (-1);
  else
    remote_fileio_return_success (ret);
}

static void
remote_fileio_func_stat (char *buf)
{
  CORE_ADDR statptr, nameptr;
  int ret, namelength;
  char *pathname;
  LONGEST lnum;
  struct stat st;
  struct fio_stat fst;

  /* 1. Parameter: Ptr to pathname / length incl. trailing zero */
  if (remote_fileio_extract_ptr_w_len (&buf, &nameptr, &namelength))
    {
      remote_fileio_ioerror ();
      return;
    }

  /* 2. Parameter: Ptr to struct stat */
  if (remote_fileio_extract_long (&buf, &lnum))
    {
      remote_fileio_ioerror ();
      return;
    }
  statptr = (CORE_ADDR) lnum;
  
  /* Request pathname using 'm' packet */
  pathname = alloca (namelength);
  if (target_read_memory (nameptr, (gdb_byte *) pathname, namelength) != 0)
    {
      remote_fileio_ioerror ();
      return;
    }

  remote_fio_no_longjmp = 1;
  ret = stat (pathname, &st);

  if (ret == -1)
    {
      remote_fileio_return_errno (-1);
      return;
    }
  /* Only operate on regular files and directories.  */
  if (!ret && !S_ISREG (st.st_mode) && !S_ISDIR (st.st_mode))
    {
      remote_fileio_reply (-1, FILEIO_EACCES);
      return;
    }
  if (statptr)
    {
      remote_fileio_to_fio_stat (&st, &fst);
      remote_fileio_to_fio_uint (0, fst.fst_dev);

      errno = target_write_memory (statptr, (gdb_byte *) &fst, sizeof fst);
      if (errno != 0)
	{
	  remote_fileio_return_errno (-1);
	  return;
	}
    }
  remote_fileio_return_success (ret);
}

static void
remote_fileio_func_fstat (char *buf)
{
  CORE_ADDR ptrval;
  int fd, ret;
  long target_fd;
  LONGEST lnum;
  struct stat st;
  struct fio_stat fst;
  struct timeval tv;

  /* 1. Parameter: file descriptor */
  if (remote_fileio_extract_int (&buf, &target_fd))
    {
      remote_fileio_ioerror ();
      return;
    }
  fd = remote_fileio_map_fd ((int) target_fd);
  if (fd == FIO_FD_INVALID)
    {
      remote_fileio_badfd ();
      return;
    }
  /* 2. Parameter: Ptr to struct stat */
  if (remote_fileio_extract_long (&buf, &lnum))
    {
      remote_fileio_ioerror ();
      return;
    }
  ptrval = (CORE_ADDR) lnum;

  remote_fio_no_longjmp = 1;
  if (fd == FIO_FD_CONSOLE_IN || fd == FIO_FD_CONSOLE_OUT)
    {
      remote_fileio_to_fio_uint (1, fst.fst_dev);
      memset (&st, 0, sizeof (st));
      st.st_mode = S_IFCHR | (fd == FIO_FD_CONSOLE_IN ? S_IRUSR : S_IWUSR);
      st.st_nlink = 1;
#ifdef HAVE_GETUID
      st.st_uid = getuid ();
#endif
#ifdef HAVE_GETGID
      st.st_gid = getgid ();
#endif
#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE
      st.st_blksize = 512;
#endif
#if HAVE_STRUCT_STAT_ST_BLOCKS
      st.st_blocks = 0;
#endif
      if (!gettimeofday (&tv, NULL))
	st.st_atime = st.st_mtime = st.st_ctime = tv.tv_sec;
      else
        st.st_atime = st.st_mtime = st.st_ctime = (time_t) 0;
      ret = 0;
    }
  else
    ret = fstat (fd, &st);

  if (ret == -1)
    {
      remote_fileio_return_errno (-1);
      return;
    }
  if (ptrval)
    {
      remote_fileio_to_fio_stat (&st, &fst);

      errno = target_write_memory (ptrval, (gdb_byte *) &fst, sizeof fst);
      if (errno != 0)
	{
	  remote_fileio_return_errno (-1);
	  return;
	}
    }
  remote_fileio_return_success (ret);
}

static void
remote_fileio_func_gettimeofday (char *buf)
{
  LONGEST lnum;
  CORE_ADDR ptrval;
  int ret;
  struct timeval tv;
  struct fio_timeval ftv;

  /* 1. Parameter: struct timeval pointer */
  if (remote_fileio_extract_long (&buf, &lnum))
    {
      remote_fileio_ioerror ();
      return;
    }
  ptrval = (CORE_ADDR) lnum;
  /* 2. Parameter: some pointer value...  */
  if (remote_fileio_extract_long (&buf, &lnum))
    {
      remote_fileio_ioerror ();
      return;
    }
  /* ...which has to be NULL.  */
  if (lnum)
    {
      remote_fileio_reply (-1, FILEIO_EINVAL);
      return;
    }

  remote_fio_no_longjmp = 1;
  ret = gettimeofday (&tv, NULL);

  if (ret == -1)
    {
      remote_fileio_return_errno (-1);
      return;
    }

  if (ptrval)
    {
      remote_fileio_to_fio_timeval (&tv, &ftv);

      errno = target_write_memory (ptrval, (gdb_byte *) &ftv, sizeof ftv);
      if (errno != 0)
	{
	  remote_fileio_return_errno (-1);
	  return;
	}
    }
  remote_fileio_return_success (ret);
}

static void
remote_fileio_func_isatty (char *buf)
{
  long target_fd;
  int fd;

  /* Parameter: file descriptor */
  if (remote_fileio_extract_int (&buf, &target_fd))
    {
      remote_fileio_ioerror ();
      return;
    }
  remote_fio_no_longjmp = 1;
  fd = remote_fileio_map_fd ((int) target_fd);
  remote_fileio_return_success (fd == FIO_FD_CONSOLE_IN ||
  				fd == FIO_FD_CONSOLE_OUT ? 1 : 0);
}

static void
remote_fileio_func_system (char *buf)
{
  CORE_ADDR ptrval;
  int ret, length;
  char *cmdline = NULL;

  /* Parameter: Ptr to commandline / length incl. trailing zero */
  if (remote_fileio_extract_ptr_w_len (&buf, &ptrval, &length))
    {
      remote_fileio_ioerror ();
      return;
    }

  if (length)
    {
      /* Request commandline using 'm' packet */
      cmdline = alloca (length);
      if (target_read_memory (ptrval, (gdb_byte *) cmdline, length) != 0)
	{
	  remote_fileio_ioerror ();
	  return;
	}
    }
  
  /* Check if system(3) has been explicitely allowed using the
     `set remote system-call-allowed 1' command.  If length is 0,
     indicating a NULL parameter to the system call, return zero to
     indicate a shell is not available.  Otherwise fail with EPERM.  */
  if (!remote_fio_system_call_allowed)
    {
      if (!length)
	remote_fileio_return_success (0);
      else
	remote_fileio_reply (-1, FILEIO_EPERM);
      return;
    }

  remote_fio_no_longjmp = 1;
  ret = system (cmdline);

  if (!length)
    remote_fileio_return_success (ret);
  else if (ret == -1)
    remote_fileio_return_errno (-1);
  else
    remote_fileio_return_success (WEXITSTATUS (ret));
}

static struct {
  char *name;
  void (*func)(char *);
} remote_fio_func_map[] = {
  { "open", remote_fileio_func_open },
  { "close", remote_fileio_func_close },
  { "read", remote_fileio_func_read },
  { "write", remote_fileio_func_write },
  { "lseek", remote_fileio_func_lseek },
  { "rename", remote_fileio_func_rename },
  { "unlink", remote_fileio_func_unlink },
  { "stat", remote_fileio_func_stat },
  { "fstat", remote_fileio_func_fstat },
  { "gettimeofday", remote_fileio_func_gettimeofday },
  { "isatty", remote_fileio_func_isatty },
  { "system", remote_fileio_func_system },
  { NULL, NULL }
};

static int
do_remote_fileio_request (struct ui_out *uiout, void *buf_arg)
{
  char *buf = buf_arg;
  char *c;
  int idx;

  remote_fileio_sig_set (remote_fileio_ctrl_c_signal_handler);

  c = strchr (++buf, ',');
  if (c)
    *c++ = '\0';
  else
    c = strchr (buf, '\0');
  for (idx = 0; remote_fio_func_map[idx].name; ++idx)
    if (!strcmp (remote_fio_func_map[idx].name, buf))
      break;
  if (!remote_fio_func_map[idx].name)	/* ERROR: No such function.  */
    return RETURN_ERROR;
  remote_fio_func_map[idx].func (c);
  return 0;
}

/* Close any open descriptors, and reinitialize the file mapping.  */

void
remote_fileio_reset (void)
{
  int ix;

  for (ix = 0; ix != remote_fio_data.fd_map_size; ix++)
    {
      int fd = remote_fio_data.fd_map[ix];

      if (fd >= 0)
	close (fd);
    }
  if (remote_fio_data.fd_map)
    {
      xfree (remote_fio_data.fd_map);
      remote_fio_data.fd_map = NULL;
      remote_fio_data.fd_map_size = 0;
    }
}

/* Handle a file I/O request.  BUF points to the packet containing the
   request.  CTRLC_PENDING_P should be nonzero if the target has not
   acknowledged the Ctrl-C sent asynchronously earlier.  */

void
remote_fileio_request (char *buf, int ctrlc_pending_p)
{
  int ex;

  remote_fileio_sig_init ();

  if (ctrlc_pending_p)
    {
      /* If the target hasn't responded to the Ctrl-C sent
	 asynchronously earlier, take this opportunity to send the
	 Ctrl-C synchronously.  */
      remote_fio_ctrl_c_flag = 1;
      remote_fio_no_longjmp = 0;
      remote_fileio_reply (-1, FILEIO_EINTR);
    }
  else
    {
      remote_fio_ctrl_c_flag = 0;
      remote_fio_no_longjmp = 0;

      ex = catch_exceptions (current_uiout,
			     do_remote_fileio_request, (void *)buf,
			     RETURN_MASK_ALL);
      switch (ex)
	{
	case RETURN_ERROR:
	  remote_fileio_reply (-1, FILEIO_ENOSYS);
	  break;
	case RETURN_QUIT:
	  remote_fileio_reply (-1, FILEIO_EINTR);
	  break;
	default:
	  break;
	}
    }

  remote_fileio_sig_exit ();
}

static void
set_system_call_allowed (char *args, int from_tty)
{
  if (args)
    {
      char *arg_end;
      int val = strtoul (args, &arg_end, 10);

      if (*args && *arg_end == '\0')
        {
	  remote_fio_system_call_allowed = !!val;
	  return;
	}
    }
  error (_("Illegal argument for \"set remote system-call-allowed\" command"));
}

static void
show_system_call_allowed (char *args, int from_tty)
{
  if (args)
    error (_("Garbage after \"show remote "
	     "system-call-allowed\" command: `%s'"), args);
  printf_unfiltered ("Calling host system(3) call from target is %sallowed\n",
		     remote_fio_system_call_allowed ? "" : "not ");
}

void
initialize_remote_fileio (struct cmd_list_element *remote_set_cmdlist,
			  struct cmd_list_element *remote_show_cmdlist)
{
  sigint_fileio_token =
    create_async_signal_handler (async_remote_fileio_interrupt, NULL);

  add_cmd ("system-call-allowed", no_class,
	   set_system_call_allowed,
	   _("Set if the host system(3) call is allowed for the target."),
	   &remote_set_cmdlist);
  add_cmd ("system-call-allowed", no_class,
	   show_system_call_allowed,
	   _("Show if the host system(3) call is allowed for the target."),
	   &remote_show_cmdlist);
}
@


1.48
log
@	PR gdb/7912:
	* Makefile.in (SFILES): Add filestuff.c
	(COMMON_OBS): Add filestuff.o.
	(filestuff.o): New target.
	* auto-load.c (auto_load_objfile_script_1): Use
	gdb_fopen_cloexec.
	* auxv.c (procfs_xfer_auxv): Use gdb_open_cloexec.
	* cli/cli-cmds.c (shell_escape): Call close_most_fds.
	* cli/cli-dump.c (fopen_with_cleanup): Use gdb_fopen_cloexec.
	* common/agent.c (gdb_connect_sync_socket): Use
	gdb_socket_cloexec.
	* common/filestuff.c: New file.
	* common/filestuff.h: New file.
	* common/linux-osdata.c (linux_common_core_of_thread)
	(command_from_pid, commandline_from_pid, print_source_lines)
	(linux_xfer_osdata_shm, linux_xfer_osdata_sem)
	(linux_xfer_osdata_msg, linux_xfer_osdata_modules): Use
	gdb_fopen_cloexec.
	* common/linux-procfs.c (linux_proc_get_int)
	(linux_proc_pid_has_state): Use gdb_fopen_cloexec.
	* config.in, configure: Rebuild.
	* configure.ac: Don't check for sys/socket.h.  Check for
	fdwalk, pipe2.
	* corelow.c (core_open): Use gdb_open_cloexec.
	* dwarf2read.c (write_psymtabs_to_index): Use gdb_fopen_cloexec.
	* fork-child.c (fork_inferior): Call close_most_fds.
	* gdb_bfd.c (gdb_bfd_open): Use gdb_open_cloexec.
	* inf-child.c (inf_child_fileio_readlink): Use gdb_open_cloexec.
	* linux-nat.c (linux_nat_thread_name, linux_proc_pending_signals):
	Use gdb_fopen_cloexec.
	(linux_proc_xfer_partial, linux_proc_xfer_spu): Use
	gdb_open_cloexec.
	(linux_async_pipe): Use gdb_pipe_cloexec.
	* remote-fileio.c (remote_fileio_func_open): Use
	gdb_open_cloexec.
	* remote.c (remote_file_put, remote_file_get): Use
	gdb_fopen_cloexec.
	* ser-pipe.c (pipe_open): Use gdb_socketpair_cloexec,
	close_most_fds.
	* ser-tcp.c (net_open): Use gdb_socket_cloexec.
	* ser-unix.c (hardwire_open): Use gdb_open_cloexec.
	* solib.c (solib_find): Use gdb_open_cloexec.
	* source.c (openp, find_and_open_source): Use gdb_open_cloexec.
	* tracepoint.c (tfile_start): Use gdb_fopen_cloexec.
	(tfile_open): Use gdb_open_cloexec.
	* tui/tui-io.c (tui_initialize_io): Use gdb_pipe_cloexec.
	* ui-file.c (gdb_fopen): Use gdb_fopen_cloexec.
	* xml-support.c (xml_fetch_content_from_file): Use
	gdb_fopen_cloexec.
	* main.c (captured_main): Call notice_open_fds.
gdbserver
	* Makefile.in (SFILES): Add filestuff.c.
	(OBS): Add filestuff.o.
	(filestuff.o): New target.
	* config.in, configure: Rebuild.
	* configure.ac: Check for fdwalk, pipe2.
@
text
@d516 1
a516 1
  deprecated_throw_reason (RETURN_QUIT);
@


1.47
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d34 1
d643 1
a643 1
  fd = open (pathname, flags, mode);
@


1.46
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005-2012 Free Software Foundation, Inc.
@


1.45
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d685 1
a685 1
  int fd, ret, retlength;
d1136 1
a1136 1
  int fd, ret, retlength;
d1215 1
a1215 1
  int ret, retlength;
d1284 1
a1284 1
  int ret, length, retlength;
@


1.44
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* ui-out.h (uiout): Rename to ...
	(current_uiout): ... this.
	* ui-out.c (uiout): Rename to ...
	(current_uiout): ... this.
	* ada-lang.c (print_it_exception, print_one_exception)
	(print_mention_exception): Adjust.
	* breakpoint.c (watchpoint_check): Adjust.
	(print_breakpoint_location, print_one_breakpoint, breakpoint_1)
	(default_collect_info, watchpoints_info, print_one_catch_fork)
	(print_one_catch_vfork, print_one_catch_syscall)
	(print_one_catch_exec, mention, print_it_ranged_breakpoint)
	(print_one_ranged_breakpoint, print_mention_ranged_breakpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_it_masked_watchpoint, print_mention_masked_watchpoint)
	(print_it_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint, say_where, bkpt_print_it)
	(bkpt_print_mention, momentary_bkpt_print_it)
	(tracepoint_print_mention, update_static_tracepoint)
	(tracepoints_info, save_breakpoints): Adjust.
	* cli-out.c (field_separator): Adjust.
	* cp-abi.c (list_cp_abis, show_cp_abi_cmd): Adjust.
	* exceptions.c (catch_exceptions_with_msg, catch_errors): Adjust.
	* frame.c (get_current_frame): Adjust.
	* infcmd.c (run_command_1, print_return_value): Adjust.
	* inferior.c (inferior_command, info_inferiors_command): Adjust.
	* infrun.c (print_end_stepping_range_reason): Adjust.
	(print_signal_exited_reason, print_exited_reason): Adjust.
	(print_signal_received_reason, print_no_history_reason): Adjust.
	* interps.c (interp_set): Adjust.
	* osdata.c (info_osdata_command): Adjust.
	* progspace.c (maintenance_info_program_spaces_command): Adjust.
	* remote-fileio.c (remote_fileio_request): Adjust.
	* remote.c (show_remote_cmd): Adjust.
	* solib.c (info_sharedlibrary_command): Adjust.
	* source.c (print_source_lines_base): Adjust.
	* stack.c (print_stack_frame): Adjust.
	(do_gdb_disassembly, print_frame_info, print_frame): Adjust.
	* symfile-mem.c (add_vsyscall_page): Adjust.
	* symfile.c (load_progress, generic_load)
	(print_transfer_performance): Adjust.
	* thread.c (info_threads_command, restore_selected_frame)
	(thread_command): Adjust.
	* top.c (make_cleanup_restore_ui_file): Adjust.
	* tracepoint.c (tvariables_info_1, trace_status_mi, tfind_1)
	(print_one_static_tracepoint_marker): Adjust.
	* cli/cli-cmds.c (print_disassembly): Adjust.
	* cli/cli-decode.c (print_doc_line): Adjust.
	* cli/cli-interp.c (safe_execute_command): Adjust.
	* cli/cli-logging.c (set_logging_redirect, pop_output_files)
	(handle_redirections): Adjust.
	* cli/cli-script.c (show_user_1): Adjust.
	* cli/cli-setshow.c (do_setshow_command, cmd_show_list): Adjust.
	* mi/mi-cmd-break.c (breakpoint_notify): Adjust.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Adjust.
	* mi/mi-cmd-env.c (mi_cmd_env_pwd, mi_cmd_env_path)
	(mi_cmd_env_dir): Adjust.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(print_partial_file_name, mi_cmd_file_list_exec_source_files): Adjust.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_depth, mi_cmd_stack_list_args)
	(list_args_or_locals): Adjust.
	* mi/mi-cmd-var.c (print_varobj, mi_cmd_var_create)
	(mi_cmd_var_delete, mi_cmd_var_set_format, mi_cmd_var_set_frozen)
	(mi_cmd_var_show_format, mi_cmd_var_info_num_children)
	(mi_cmd_var_list_children, mi_cmd_var_info_type)
	(mi_cmd_var_info_path_expression, mi_cmd_var_info_expression)
	(mi_cmd_var_show_attributes, mi_cmd_var_evaluate_expression)
	(mi_cmd_var_assign, mi_cmd_var_update, varobj_update_one): Adjust.
	* mi/mi-interp.c (mi_on_normal_stop): Adjust.
	* mi/mi-main.c (mi_cmd_gdb_exit, mi_cmd_thread_select)
	(mi_cmd_thread_list_ids, mi_cmd_thread_info, print_one_inferior)
	(list_available_thread_groups, mi_cmd_list_thread_groups)
	(mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers)
	(mi_cmd_data_list_register_values, get_register)
	(mi_cmd_data_evaluate_expression, mi_cmd_data_read_memory)
	(mi_cmd_data_read_memory_bytes, mi_cmd_list_features)
	(mi_cmd_list_target_features, mi_cmd_add_inferior)
	(mi_execute_command, mi_load_progress): Adjust.
	* mi/mi-symbol-cmds.c (mi_cmd_symbol_list_lines): Adjust.
	* python/py-auto-load.c (print_script, info_auto_load_scripts):
	Adjust.
	* python/py-breakpoint.c (bppy_get_commands): Adjust.
	* tui/tui-interp.c (tui_command_loop): Adjust.
	* tui/tui-io.c (tui_setup_io, tui_initialize_io): Adjust.
@
text
@d3 1
a3 2
   Copyright (C) 2003, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.44.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2003, 2005-2012 Free Software Foundation, Inc.
@


1.43
log
@	Remove support for old Cygwin 1.5 versions.
	* remote-fileio.c: Remove macros used to emulate new cygwin_conv_path
	function on old Cygwin version.
	* windows-nat.c: Remove cygwin version check and always define
	__USEWIDE for Cygwin compilation.
@
text
@d1419 2
a1420 1
      ex = catch_exceptions (uiout, do_remote_fileio_request, (void *)buf,
@


1.42
log
@2011-03-23  Kai Tietz  <ktietz@@redhat.com>

	* breakpoint.c (clear_command): Use filename_cmp
	instead of strcmp for comparison.
	* buildsym.c (watch_main_source_file_lossage): Likewise.
	(patch_subfile_names): Use IS_DIR_SEPARATOR instead of
	checking just for slash.
	* dbxread.c (read_dbx_symtab): Use lbasename instead of
	strrchr and filename_cmp instead of strcmp for filenames.
	(add_old_header_file): Use filename_cmp
	instead of strcmp for comparison.
	* exec.c (exec_set_section_address): Likewise.
	* macrotab.c (macro_lookup_inclusion): Likewise.
	(macro_lookup_inclusion): Likewise.
	* elfread.c (_initialize_elfread): Likewise.
	(elfstab_offset_sections): Likewise.
	(elfstab_offset_sections): Use lbasename instead of
	strrchr.
	* mdebugread.c (parse_partial_symbols): Likewise.
	(arse_partial_symbols): Use filename_(n)cmp instead of
	str(n)cmp for comparison.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* psymtab.c (read_psymtabs_with_filename): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	(reload_shared_libraries_1): Likewise.
	* symmisc.c (maintenance_print_symbols): Likewise.
	* symfile.c (separate_debug_file_exists): Likewise.
	(reread_symbols): Likewise.
	(find_separate_debug_file_by_debuglink): Likewise.
	* remote-fileio.c (remote_fileio_func_rename): Likewise.
	* source.c (add_path): Likewise.
	* symtab.c (filename_seen): Likewise.
	(file_matches): Likewise.
	(print_symbol_info): Likewise.
	(maybe_add_partial_symtab_filename): Likewise.
	(make_source_files_completion_list): Likewise.
	* xml-syscall.c (init_sysinfo): Likewise.
	* windows-nat.c (_initialize_check_for_gdb_ini): Use
	IS_DIR_SEPARATOR for checking for trailing path separator.
@
text
@d39 1
a39 10
#include <sys/cygwin.h>		/* For cygwin_conv_to_full_posix_path.  */
#include <cygwin/version.h>
#if CYGWIN_VERSION_DLL_MAKE_COMBINED(CYGWIN_VERSION_API_MAJOR,CYGWIN_VERSION_API_MINOR) < 181
# define CCP_POSIX_TO_WIN_A 0
# define CCP_WIN_A_TO_POSIX 2
# define cygwin_conv_path(op, from, to, size)  \
         (op == CCP_WIN_A_TO_POSIX) ? \
         cygwin_conv_to_full_posix_path (from, to) : \
         cygwin_conv_to_win32_path (from, to)
#endif
@


1.41
log
@2011-03-03  Michael Snyder  <msnyder@@vmware.com>

	* remote-fileio.c (remote_fileio_func_fstat): Initialize all
	fields of struct 'st' to zero.
@
text
@d34 1
d1024 2
a1025 2
		  if (newfullpath[len] == '/'
		      && !strncmp (oldfullpath, newfullpath, len))
@


1.40
log
@	Stop remote_read_bytes from handling partial reads itself.

	* remote-fileio.c: Include target.h.
	(remote_fileio_write_bytes): Delete.
	(remote_fileio_func_open, remote_fileio_func_write)
	(remote_fileio_func_rename, remote_fileio_func_unlink): Use
	target_read_memory.
	(remote_fileio_func_stat): Use target_read_memory and
	target_write_memory.
	(remote_fileio_func_gettimeofday): Use target_write_memory.
	(remote_fileio_func_system): Use target_read_memory.
	* remote.c (remote_write_bytes): Make it static.
	(remote_read_bytes): Don't handle partial reads here.
	* remote.h (remote_read_bytes): Delete declaration.
@
text
@d1176 1
a1180 2
#else
      st.st_uid = 0;
a1183 2
#else
      st.st_gid = 0;
a1184 2
      st.st_rdev = 0;
      st.st_size = 0;
@


1.39
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d33 1
a591 18
/* Wrapper function for remote_write_bytes() which has the disadvantage to
   write only one packet, regardless of the requested number of bytes to
   transfer.  This wrapper calls remote_write_bytes() as often as needed.  */
static int
remote_fileio_write_bytes (CORE_ADDR memaddr, gdb_byte *myaddr, int len)
{
  int ret = 0, written;

  while (len > 0 && (written = remote_write_bytes (memaddr, myaddr, len)) > 0)
    {
      len -= written;
      memaddr += written;
      myaddr += written;
      ret += written;
    }
  return ret;
}

d596 1
a596 1
  int length, retlength;
d624 1
a624 1
  /* Request pathname using 'm' packet.  */
d626 1
a626 2
  retlength = remote_read_bytes (ptrval, (gdb_byte *) pathname, length);
  if (retlength != length)
d804 3
a806 4
      retlength = remote_fileio_write_bytes (ptrval, buffer, ret);
      if (retlength != ret)
	ret = -1; /* errno has been set to EIO in
		     remote_fileio_write_bytes().  */
d823 1
a823 1
  int fd, ret, retlength;
d855 1
a855 2
  retlength = remote_read_bytes (ptrval, buffer, length);
  if (retlength != length)
d949 1
a949 1
  int old_len, new_len, retlength;
d970 1
a970 2
  retlength = remote_read_bytes (old_ptr, (gdb_byte *) oldpath, old_len);
  if (retlength != old_len)
d978 1
a978 2
  retlength = remote_read_bytes (new_ptr, (gdb_byte *) newpath, new_len);
  if (retlength != new_len)
d1043 1
a1043 1
  int length, retlength;
d1056 1
a1056 2
  retlength = remote_read_bytes (ptrval, (gdb_byte *) pathname, length);
  if (retlength != length)
d1083 1
a1083 1
  int ret, namelength, retlength;
d1106 1
a1106 2
  retlength = remote_read_bytes (nameptr, (gdb_byte *) pathname, namelength);
  if (retlength != namelength)
d1130 3
a1132 4
      
      retlength = remote_fileio_write_bytes (statptr,
					     (gdb_byte *) &fst, sizeof fst);
      if (retlength != sizeof fst)
d1214 2
a1215 3
      retlength = remote_fileio_write_bytes (ptrval, (gdb_byte *) &fst,
					     sizeof fst);
      if (retlength != sizeof fst)
d1266 2
a1267 3
      retlength = remote_fileio_write_bytes (ptrval, (gdb_byte *) &ftv,
					     sizeof ftv);
      if (retlength != sizeof ftv)
d1312 1
a1312 2
      retlength = remote_read_bytes (ptrval, (gdb_byte *) cmdline, length);
      if (retlength != length)
@


1.38
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d21 1
a21 1
/* See the GDB User Guide for details of the GDB remote protocol. */
d154 1
a154 1
   binary mode. */
d393 1
a393 1
/* Convert to big endian */
d438 1
a438 1
  /* `st_dev' is set in the calling function */
d593 1
a593 1
   transfer.  This wrapper calls remote_write_bytes() as often as needed. */
d620 1
a620 1
  /* 1. Parameter: Ptr to pathname / length incl. trailing zero */
d641 1
a641 1
  /* Request pathname using 'm' packet */
d652 1
a652 1
     for writing. */
d813 1
a813 1
	       The Ctrl-C flag is set in remote_fileio_reply() anyway */
d825 1
a825 1
		     remote_fileio_write_bytes() */
d899 1
a899 1
			    R/O file.*/
d1006 1
a1006 1
  /* Only operate on regular files and directories */
d1023 1
a1023 1
	 always EEXIST. */
d1027 1
a1027 1
      /* Workaround some Cygwin problems with correct errnos. */
d1086 1
a1086 1
     the correct return code) */
d1144 1
a1144 1
  /* Only operate on regular files and directories */
d1266 1
a1266 1
  /* 2. Parameter: some pointer value... */
d1272 1
a1272 1
  /* ...which has to be NULL */
d1407 1
a1407 1
  if (!remote_fio_func_map[idx].name)	/* ERROR: No such function. */
d1435 2
a1436 2
/* Handle a file I/O request. BUF points to the packet containing the
   request. CTRLC_PENDING_P should be nonzero if the target has not
@


1.37
log
@run copyright.sh for 2011.
@
text
@d581 2
a582 2
  remote_fileio_reply (retcode,
		       retcode < 0 ? remote_fileio_errno_to_target (errno) : 0);
d824 2
a825 1
	ret = -1; /* errno has been set to EIO in remote_fileio_write_bytes() */
d898 2
a899 1
	  errno = EBADF; /* Cygwin returns EACCESS when writing to a R/O file.*/
d1239 2
a1240 1
      retlength = remote_fileio_write_bytes (ptrval, (gdb_byte *) &fst, sizeof fst);
d1292 2
a1293 1
      retlength = remote_fileio_write_bytes (ptrval, (gdb_byte *) &ftv, sizeof ftv);
d1499 2
a1500 1
    error (_("Garbage after \"show remote system-call-allowed\" command: `%s'"), args);
@


1.36
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* record.c: White space.
	* regcache.c: White space.
	* reggroups.c: White space.
	* remote-fileio.c: White space.
	* remote-m32r-sdi.c: White space.
	* remote-mips.c: White space.
	* remote-sim.c: White space.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005, 2006, 2007, 2008, 2009, 2010
@


1.35
log
@2010-03-10  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* remote-fileio.c (cygwin_conv_path): Define macro for old cygwin API.
@
text
@d112 1
d1481 1
@


1.34
log
@	* remote-fileio.c (remote_fileio_func_rename): Use Cygwin 1.7
	cygwin_conv_path API rather than the deprecated
	cygwin_conv_to_full_posix_path.
	* windows-nat.c:
	(GetModuleFileNameExA): Undefine for Cygwin.
	(GetModuleFileNameExW): Define for Cygwin.
	(get_module_name): Change size of pathbuf to PATH_MAX for Cygwin.
	Call GetModuleFileNameExW and convert path to POSIX using
	cygwin_conv_path.
	(windows_make_so): Always define p.  Drop unused variable m.
	Don't use Win32 functions to check file existance, rather use
	access on Cygwin.  Fetch system directory using GetSystemDirectoryW.
	Use canonicalize_file_name to get full path.
	(get_image_name): Use wcstombs, rather than WideCharToMultiByte
	to convert Unicode pathname to multibyte on Cygwin.  Otherwise,
	use correct target buffer size in call to WideCharToMultiByte.
	(handle_load_dll): Change size of dll_buf to PATH_MAX for Cygwin.
	(windows_pid_to_exec_file): Change size of path to PATH_MAX for Cygwin.
	(windows_create_inferior): Convert all paths and arguments to wchar_t
	and use CreateProcessW on Cygwin.
	(_initialize_windows_nat): Disable DOS-style path warning on Cygwin.
	(bad_GetModuleFileNameExA): Undefine for Cygwin.
	(bad_GetModuleFileNameExW): Define for Cygwin.
	(_initialize_loadable): Load GetModuleFileNameExW into
	dyn_GetModuleFileNameExW on Cygwin.  Don't load ANSI function on Cygwin.
@
text
@d38 9
@


1.33
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1024 2
a1025 2
		  char oldfullpath[PATH_MAX + 1];
		  char newfullpath[PATH_MAX + 1];
d1028 4
a1031 2
		  cygwin_conv_to_full_posix_path (oldpath, oldfullpath);
		  cygwin_conv_to_full_posix_path (newpath, newfullpath);
@


1.32
log
@2009-11-13  Kazu Hirata  <kazu@@codesourcery.com>
	    Maxim Kuvyrkov  <maxim@@codesourcery.com>

	* remote-fileio.c (remote_fileio_request): Send Ctrl-C if it is
	pending.
	* remote-fileio.h: Update the prototype for remote_fileio_request.
	* remote.c (struct remote_state): Add ctrlc_pending_p.
	(remote_open_1): Clear ctrlc_pending_p.
	(remote_stop_as): Set ctrlc_pending_p to 1.
	(remote_wait_as): Pass ctrlc_pending_p to remote_fileio_request.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005, 2006, 2007, 2008, 2009
@


1.31
log
@	* remote-fileio.c (remote_fileio_func_read): Limit console
	reads to 16K.
@
text
@d1419 4
d1424 1
a1424 1
remote_fileio_request (char *buf)
d1430 13
a1442 2
  remote_fio_ctrl_c_flag = 0;
  remote_fio_no_longjmp = 0;
d1444 13
a1456 12
  ex = catch_exceptions (uiout, do_remote_fileio_request, (void *)buf,
			 RETURN_MASK_ALL);
  switch (ex)
    {
      case RETURN_ERROR:
	remote_fileio_reply (-1, FILEIO_ENOSYS);
        break;
      case RETURN_QUIT:
        remote_fileio_reply (-1, FILEIO_EINTR);
	break;
      default:
        break;
@


1.30
log
@        Updated copyright notices for most files.
@
text
@d744 1
a744 1
	  buffer = (gdb_byte *) xmalloc (32768);
d766 12
a777 1
	      ret = ui_file_read (gdb_stdtargin, (char *) buffer, 32767);
@


1.29
log
@	* varobj.c (varobj_set_display_format): Use xfree.
	* tracepoint.c (stringify_collection_list): Use xfree.
	* remote-fileio.c (remote_fileio_reset): Use xfree.
	* mipsread.c (read_alphacoff_dynamic_symtab): Use xfree.
	* dfp.c (decimal_from_floating): Use xfree, xstrprintf.  Don't use
	asprintf.
	* cp-support.c (mangled_name_to_comp): Use xfree.
@
text
@d3 2
a4 1
   Copyright (C) 2003, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.28
log
@	* Makefile.in (mingw-hdep.o, posix-hdep.o, remote-fileio.o): Update.
	* event-loop.c (call_async_signal_handler): New.
	* event-loop.h (call_async_signal_handler)
	(gdb_call_async_signal_handler): Declare.
	(mark_async_signal_handler): Add comments.
	* event-top.c (handle_sigint): Use gdb_call_async_signal_handler.
	* mingw-hdep.c (sigint_event, sigint_handler): New.
	(gdb_select): Use them.  Wait for the readline signal handler
	to finish.
	(gdb_call_async_signal_handler, _initialize_mingw_hdep): New functions.
	* posix-hdep.c (gdb_call_async_signal_handler): New function.
	* remote-fileio.c (sigint_fileio_token, async_remote_fileio_interrupt):
	New.
	(remote_fileio_ctrl_c_signal_handler): Use
	gdb_call_async_signal_handler.
	(initialize_remote_fileio): Initialize sigint_fileio_token.
	* remote.c (initialize_sigint_signal_handler, handle_remote_sigint): Do
	not initialize tokens here.
	(handle_remote_sigint_twice): Likewise.  Reinstall
	handle_remote_sigint.
	(async_remote_interrupt_twice): Just call interrupt_query.
	(cleanup_sigint_signal_handler): Do not delete tokens.
	(remote_interrupt, remote_interrupt_twice): Use
	gdb_call_async_signal_handler.
	(interrupt_query): Reinstall the default signal handler.
	(_initialize_remote): Initialize tokens here.
@
text
@d1401 1
a1401 1
      free (remote_fio_data.fd_map);
@


1.27
log
@	Updated copyright notices for most files.
@
text
@d31 1
d51 2
d510 6
d521 1
a521 1
    deprecated_throw_reason (RETURN_QUIT);
d1463 3
@


1.27.6.1
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@d27 2
a30 1
#include "target-fileio.h"
d32 5
d39 420
d461 1
d511 1
a511 1
  if (!target_fio_no_longjmp)
d546 24
d589 96
d687 1
a687 1
set_ctrl_c_signal_handler(void)
d689 671
d1361 13
d1381 15
a1395 1
  target_fileio_reset();
d1401 1
a1401 7
  static struct file_io_operations operations =
  {
     remote_read_bytes,
     remote_fileio_write_bytes,
     remote_fileio_reply,
     set_ctrl_c_signal_handler
  };
d1404 18
a1421 1
  target_fileio_request(buf, &operations);
d1425 25
d1454 8
a1461 1
  initialize_target_fileio(remote_set_cmdlist, remote_show_cmdlist);
@


1.26
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.25
log
@2007-08-10  Maxim Grigoriev  <maxim2405@@gmail.com>

	* remote-fileio.c (remote_fileio_resize_fd_map): Initialize newly
	allocated file descriptors.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.24
log
@2007-08-04  Michael Snyder  <msnyder@@access-company.com>

	* remote-fileio.c (remote_fileio_func_write): Memory leak.
@
text
@d73 2
d81 2
@


1.23
log
@Copyright updates for 2007.
@
text
@d853 1
@


1.22
log
@	Warning fixes.
	* ada-lang.c (find_struct_field): Initialize *byte_offset_p.
	* breakpoint.c (do_enable_breakpoint): Ignore both mem_cnt and i.
	* c-typeprint.c (c_type_print_varspec_suffix): Don't test length
	greater than or equal to zero.
	* m2-typeprint.c (m2_array): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	* gdbtypes.c (copy_type_recursive): Correct == typo.
	* i386-tdep.c (i386_skip_prologue): Remove stray semicolon.
	* linux-nat.c (linux_nat_info_proc_cmd): Don't compare a pointer
	greater than zero.
	* macroscope.c (sal_macro_scope): Don't name a local variable "main".
	(default_macro_scope): Remove unused variable.
	* prologue-value.h (pv_area_find_reg): Don't name an argument
	"register".
	* remote-fileio.c (remote_fio_func_map): Add missing braces.
	* remote.c (sigint_remote_twice_token, sigint_remote_token): Change
	type.
	(cleanup_sigint_signal_handler): Remove casts.
	* valprint.c (val_print): Use a volatile local for the modified
	argument.
	* varobj.c (languages): Remove extra array dimension.
	(varobj_create): Correct access to languages array.
	* mi/mi-cmd-break.c (mi_cmd_break_insert, mi_cmd_break_watch): Add
	missing braces.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Likewise.
	* mi/mi-cmd-env.c (mi_cmd_env_path, mi_cmd_env_dir): Likewise.
	* mi/mi-getopt.c (mi_valid_noargs): Likewise.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	(mi_cmd_data_write_memory): Likewise.
	* signals/signals.c (target_signal_to_string): Cast to int before
	comparing.
	* tui/tui-layout.c (init_and_make_win): Take and return a void *.
	Update all callers.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005, 2006 Free Software Foundation, Inc.
@


1.21
log
@* remote-fileio.c (remote_fileio_mode_to_target): Use
S_ISREG/S_ISDIR/S_ISCHR macros instead of S_IFREG/S_IFDIR/S_IFCHR.
@
text
@d1335 13
a1347 13
  "open", remote_fileio_func_open,
  "close", remote_fileio_func_close,
  "read", remote_fileio_func_read,
  "write", remote_fileio_func_write,
  "lseek", remote_fileio_func_lseek,
  "rename", remote_fileio_func_rename,
  "unlink", remote_fileio_func_unlink,
  "stat", remote_fileio_func_stat,
  "fstat", remote_fileio_func_fstat,
  "gettimeofday", remote_fileio_func_gettimeofday,
  "isatty", remote_fileio_func_isatty,
  "system", remote_fileio_func_system,
  NULL, NULL
@


1.20
log
@	* remote-fileio.c (remote_fileio_func_rename): Reorder to process
	input buffer before reading memory.
	(remote_fileio_func_stat): Likewise.
@
text
@d195 1
a195 1
  if (mode & S_IFREG)
d197 1
a197 1
  if (mode & S_IFDIR)
d199 1
a199 1
  if (mode & S_IFCHR)
@


1.19
log
@	gdb/
	* remote-file.io.c (remote_fileio_func_system): Treat zero length
	string as NULL.  Adjust for NULL pointer argument.
	* doc/gdb.texinfo (system): Document behaviour with zero length
	string.

	gdb/testsuite/
	* gdb.base/fileio.c: Add system(NULL) test.
	* gdb.base/fileio.exp: Check it.
@
text
@d932 2
a933 2
  CORE_ADDR ptrval;
  int length, retlength;
d939 1
a939 1
  if (remote_fileio_extract_ptr_w_len (&buf, &ptrval, &length))
d944 3
a946 4
  /* Request oldpath using 'm' packet */
  oldpath = alloca (length);
  retlength = remote_read_bytes (ptrval, (gdb_byte *) oldpath, length);
  if (retlength != length)
d951 5
a955 2
  /* 2. Parameter: Ptr to newpath / length incl. trailing zero */
  if (remote_fileio_extract_ptr_w_len (&buf, &ptrval, &length))
d960 1
d962 3
a964 3
  newpath = alloca (length);
  retlength = remote_read_bytes (ptrval, (gdb_byte *) newpath, length);
  if (retlength != length)
d1067 2
a1068 2
  CORE_ADDR ptrval;
  int ret, length, retlength;
d1075 1
a1075 1
  if (remote_fileio_extract_ptr_w_len (&buf, &ptrval, &length))
d1080 3
a1082 4
  /* Request pathname using 'm' packet */
  pathname = alloca (length);
  retlength = remote_read_bytes (ptrval, (gdb_byte *) pathname, length);
  if (retlength != length)
d1087 6
a1092 3

  /* 2. Parameter: Ptr to struct stat */
  if (remote_fileio_extract_long (&buf, &lnum))
a1096 1
  ptrval = (CORE_ADDR) lnum;
d1112 1
a1112 1
  if (ptrval)
d1117 2
a1118 1
      retlength = remote_fileio_write_bytes (ptrval, (gdb_byte *) &fst, sizeof fst);
@


1.18
log
@	* remote-fileio.c (remote_fileio_reset): New.
	* remote-fileio.h (remote_fileio_reset): Prototype.
	* remote.c (extended_remote_restart, remote_open_1): Call it.
@
text
@d1281 1
a1281 1
  char *cmdline;
d1283 2
a1284 4
  /* Check if system(3) has been explicitely allowed using the
     `set remote system-call-allowed 1' command.  If not, return
     EPERM */
  if (!remote_fio_system_call_allowed)
d1286 1
a1286 1
      remote_fileio_reply (-1, FILEIO_EPERM);
d1290 1
a1290 2
  /* Parameter: Ptr to commandline / length incl. trailing zero */
  if (remote_fileio_extract_ptr_w_len (&buf, &ptrval, &length))
d1292 8
a1299 2
      remote_fileio_ioerror ();
      return;
d1301 6
a1306 4
  /* Request commandline using 'm' packet */
  cmdline = alloca (length);
  retlength = remote_read_bytes (ptrval, (gdb_byte *) cmdline, length);
  if (retlength != length)
d1308 4
a1311 1
      remote_fileio_ioerror ();
d1318 3
a1320 1
  if (ret == -1)
@


1.17
log
@	* dwarf2read.c, remote-fileio.c, remote.h: Update copyright
	notices.
@
text
@d1358 22
@


1.17.14.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d932 2
a933 2
  CORE_ADDR old_ptr, new_ptr;
  int old_len, new_len, retlength;
d939 1
a939 1
  if (remote_fileio_extract_ptr_w_len (&buf, &old_ptr, &old_len))
d944 4
a947 3
  
  /* 2. Parameter: Ptr to newpath / length incl. trailing zero */
  if (remote_fileio_extract_ptr_w_len (&buf, &new_ptr, &new_len))
d952 2
a953 5
  
  /* Request oldpath using 'm' packet */
  oldpath = alloca (old_len);
  retlength = remote_read_bytes (old_ptr, (gdb_byte *) oldpath, old_len);
  if (retlength != old_len)
a957 1
  
d959 3
a961 3
  newpath = alloca (new_len);
  retlength = remote_read_bytes (new_ptr, (gdb_byte *) newpath, new_len);
  if (retlength != new_len)
d1064 2
a1065 2
  CORE_ADDR statptr, nameptr;
  int ret, namelength, retlength;
d1072 1
a1072 1
  if (remote_fileio_extract_ptr_w_len (&buf, &nameptr, &namelength))
d1077 4
a1080 3

  /* 2. Parameter: Ptr to struct stat */
  if (remote_fileio_extract_long (&buf, &lnum))
d1085 3
a1087 6
  statptr = (CORE_ADDR) lnum;
  
  /* Request pathname using 'm' packet */
  pathname = alloca (namelength);
  retlength = remote_read_bytes (nameptr, (gdb_byte *) pathname, namelength);
  if (retlength != namelength)
d1092 1
d1108 1
a1108 1
  if (statptr)
d1113 1
a1113 2
      retlength = remote_fileio_write_bytes (statptr,
					     (gdb_byte *) &fst, sizeof fst);
d1281 10
a1290 1
  char *cmdline = NULL;
d1298 4
a1301 2

  if (length)
d1303 1
a1303 20
      /* Request commandline using 'm' packet */
      cmdline = alloca (length);
      retlength = remote_read_bytes (ptrval, (gdb_byte *) cmdline, length);
      if (retlength != length)
	{
	  remote_fileio_ioerror ();
	  return;
	}
    }
  
  /* Check if system(3) has been explicitely allowed using the
     `set remote system-call-allowed 1' command.  If length is 0,
     indicating a NULL parameter to the system call, return zero to
     indicate a shell is not available.  Otherwise fail with EPERM.  */
  if (!remote_fio_system_call_allowed)
    {
      if (!length)
	remote_fileio_return_success (0);
      else
	remote_fileio_reply (-1, FILEIO_EPERM);
d1310 1
a1310 3
  if (!length)
    remote_fileio_return_success (ret);
  else if (ret == -1)
a1357 22
/* Close any open descriptors, and reinitialize the file mapping.  */

void
remote_fileio_reset (void)
{
  int ix;

  for (ix = 0; ix != remote_fio_data.fd_map_size; ix++)
    {
      int fd = remote_fio_data.fd_map[ix];

      if (fd >= 0)
	close (fd);
    }
  if (remote_fio_data.fd_map)
    {
      free (remote_fio_data.fd_map);
      remote_fio_data.fd_map = NULL;
      remote_fio_data.fd_map_size = 0;
    }
}

@


1.17.2.1
log
@	* gdb/remote-fileio.c (remote_fileio_reset): New.
	* gdb/remote-fileio.h (remote_fileio_reset): Prototype.
	* gdb/remote.c (extended_remote_restart, remote_open_1): Call it.
@
text
@a1357 19
/* Close any open descriptors, and reinitialize the file mapping */

void
remote_fileio_reset (void)
{
  int ix;

  for (ix = 0; ix != remote_fio_data.fd_map_size; ix++)
    {
      int fd = remote_fio_data.fd_map[ix];

      if (fd >= 0)
	close (fd);
    }
  free (remote_fio_data.fd_map);
  remote_fio_data.fd_map = NULL;
  remote_fio_data.fd_map_size = 0;
}

@


1.17.2.2
log
@	gdb/
	* remote-file.io.c (remote_fileio_func_system): Treat zero length
	string as NULL.  Adjust for NULL pointer argument.
	* doc/gdb.texinfo (system): Document behaviour with zero length
	string.

	gdb/testsuite/
	* gdb.base/fileio.c: Add system(NULL) test.
	* gdb.base/fileio.exp: Check it.
@
text
@d1281 10
a1290 1
  char *cmdline = NULL;
d1298 4
a1301 17

  if (length)
    {
      /* Request commandline using 'm' packet */
      cmdline = alloca (length);
      retlength = remote_read_bytes (ptrval, (gdb_byte *) cmdline, length);
      if (retlength != length)
	{
	  remote_fileio_ioerror ();
	  return;
	}
    }
  
  /* Check if system(3) has been explicitely allowed using the
     `set remote system-call-allowed 1' command.  If not, return
     EPERM */
  if (!remote_fio_system_call_allowed)
d1303 1
a1303 4
      if (!length)
	remote_fileio_return_success (0);
      else
	remote_fileio_reply (-1, FILEIO_EPERM);
d1310 1
a1310 3
  if (!length)
    remote_fileio_return_success (ret);
  else if (ret == -1)
@


1.17.2.3
log
@	* remote-fileio.c (remote_fileio_func_read): Limit console
	reads to 8K.
@
text
@d754 1
a754 10
	      /* NOTE drow/2006-06-10: Windows (mingw32) has a truly
		 bizarre bug.  If a handle is backed by a real console
		 device, overly large reads from the console will fail
		 and set errno == ENOMEM.  On a Windows Server 2003
		 system where I tested, reading 26608 bytes from the
		 console was OK, but anything about 26609 bytes would
		 fail.  So, we limit this read to something smaller
		 than that - by a safe margin, in case the limit
		 depends on system resources or version.  */
	      ret = ui_file_read (gdb_stdtargin, (char *) buffer, 8191);
@


1.17.2.4
log
@	gdb/
	* remote-fileio.c (remote_fileio_func_rename): Reorder to process
	input buffer before reading memory.
	(remote_fileio_func_stat): Likewise.
@
text
@d941 2
a942 2
  CORE_ADDR old_ptr, new_ptr;
  int old_len, new_len, retlength;
d948 1
a948 1
  if (remote_fileio_extract_ptr_w_len (&buf, &old_ptr, &old_len))
d953 4
a956 3
  
  /* 2. Parameter: Ptr to newpath / length incl. trailing zero */
  if (remote_fileio_extract_ptr_w_len (&buf, &new_ptr, &new_len))
d961 2
a962 5
  
  /* Request oldpath using 'm' packet */
  oldpath = alloca (old_len);
  retlength = remote_read_bytes (old_ptr, (gdb_byte *) oldpath, old_len);
  if (retlength != old_len)
a966 1
  
d968 3
a970 3
  newpath = alloca (new_len);
  retlength = remote_read_bytes (new_ptr, (gdb_byte *) newpath, new_len);
  if (retlength != new_len)
d1073 2
a1074 2
  CORE_ADDR statptr, nameptr;
  int ret, namelength, retlength;
d1081 1
a1081 1
  if (remote_fileio_extract_ptr_w_len (&buf, &nameptr, &namelength))
d1086 4
a1089 3

  /* 2. Parameter: Ptr to struct stat */
  if (remote_fileio_extract_long (&buf, &lnum))
d1094 3
a1096 6
  statptr = (CORE_ADDR) lnum;
  
  /* Request pathname using 'm' packet */
  pathname = alloca (namelength);
  retlength = remote_read_bytes (nameptr, (gdb_byte *) pathname, namelength);
  if (retlength != namelength)
d1101 1
d1117 1
a1117 1
  if (statptr)
d1122 1
a1122 2
      retlength = remote_fileio_write_bytes (statptr,
					     (gdb_byte *) &fst, sizeof fst);
@


1.16
log
@	* remote-fileio.c (remote_fileio_return_success): Take a gdb_byte
	argument.
	(remote_fileio_func_open, remote_fileio_func_rename)
	(remote_fileio_func_unlink, remote_fileio_func_stat)
	(remote_fileio_func_fstat, remote_fileio_func_gettimeofday)
	(remote_fileio_func_system): Cast the arguments to
	remote_read_bytes and remote_write_bytes.
	(remote_fileio_func_read, remote_fileio_func_write): Use a
	gdb_byte buffer.
	* remote.h (remote_read_bytes, remote_write_bytes): Update
	prototypes.
	* remote.c (hex2bin, bin2hex): Use gdb_byte for the BIN argument.
	(threadref_to_int): Replace bogus char * cast.
	(remote_unpack_thread_info_response): Use int for tag.
	(remote_threads_extra_info, remote_check_symbols): Cast string
	arguments to hex2bin.
	(remote_wait): Use a char buffer for packets and a gdb_byte
	buffer for registers.
	(remote_async_wait): Likewise.
	(remote_prepare_to_store, store_register_using_P)
	(remote_store_registers): Use gdb_byte buffers.
	(remote_write_bytes, remote_read_bytes): Use a gdb_byte pointer
	for MYADDR and char buffers for strings.
	(remote_xfer_partial): Add casts for string operations on READBUF.
	(remote_rcmd): Cast strings passed to bin2hex.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005 Free Software Foundation, Inc.
@


1.15
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d573 1
a573 1
remote_fileio_write_bytes (CORE_ADDR memaddr, char *myaddr, int len)
d621 1
a621 1
  retlength = remote_read_bytes (ptrval, pathname, length);
d691 1
a691 1
  char *buffer;
d732 1
a732 1
	  buffer = (char *) xmalloc (32768);
d754 1
a754 1
	      ret = ui_file_read (gdb_stdtargin, buffer, 32767);
d767 1
a767 1
	buffer = (char *) xmalloc (length);
d809 1
a809 1
  char *buffer;
d839 1
a839 1
  buffer = (char *) xmalloc (length);
d855 2
a856 2
	ui_file_write (target_fd == 1 ? gdb_stdtarg : gdb_stdtargerr, buffer,
		       length);
d946 1
a946 1
  retlength = remote_read_bytes (ptrval, oldpath, length);
d960 1
a960 1
  retlength = remote_read_bytes (ptrval, newpath, length);
d1037 1
a1037 1
  retlength = remote_read_bytes (ptrval, pathname, length);
d1079 1
a1079 1
  retlength = remote_read_bytes (ptrval, pathname, length);
d1113 1
a1113 1
      retlength = remote_fileio_write_bytes (ptrval, (char *) &fst, sizeof fst);
d1196 1
a1196 1
      retlength = remote_fileio_write_bytes (ptrval, (char *) &fst, sizeof fst);
d1248 1
a1248 1
      retlength = remote_fileio_write_bytes (ptrval, (char *) &ftv, sizeof ftv);
d1300 1
a1300 1
  retlength = remote_read_bytes (ptrval, cmdline, length);
@


1.14
log
@	* configure.ac (stat.st_blksize): Check for it.
	(getuid): Likewise.
	(getgid): Likewise.
	* configure: Regenerated.
	* config.in: Likewise.
	* remote-fileio.c (remote_fileio_to_fio_stat): Check
	HAVE_STRUCT_STAT_ST_BLKSIZE.
@
text
@d3 1
a3 1
   Copyright 2003, 2005 Free Software Foundation, Inc.
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.13
log
@	* utils.c (internal_vproblem): Guard call to fork with
	HAVE_WORKING_FORK.
	* cli/cli-cmds.c (shell_escape): Guard call to vfork with
	HAVE_WORKING_VFORK and HAVE_WORKING_FORK.

	* remote-fileo.c (remote_fileio_mode_to_host): Accomodate lack of
	S_IRGRP and related macros.
	(remote_fileio_mode_to_target): Likewise.
@
text
@d420 2
d430 6
a435 1
  remote_fileio_to_fio_ulong ((LONGEST) st->st_blksize, fst->fst_blksize);
d442 2
a443 2
  remote_fileio_to_fio_ulong (((LONGEST) st->st_size + st->st_blksize - 1)
			      / (LONGEST) st->st_blksize,
d1160 1
d1162 4
d1167 3
d1172 1
d1174 1
@


1.12
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d3 1
a3 1
   Copyright 2003 Free Software Foundation, Inc.
d165 1
d168 2
d172 2
d176 1
d179 1
d182 2
d186 1
d207 1
d210 2
d214 2
d218 1
d221 1
d224 2
d228 1
@


1.11
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d1379 1
a1379 1
	   "Set if the host system(3) call is allowed for the target.\n",
d1383 1
a1383 1
	   "Show if the host system(3) call is allowed for the target.\n",
@


1.10
log
@2005-01-19  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (deprecated_throw_reason): Rename throw_reason.
	* exceptions.c (deprecated_throw_reason): Rename throw_reason.
	* utils.c (internal_verror, quit): Update.
	* remote-sds.c (interrupt_query): Update.
	* remote-mips.c (mips_error, mips_kill): Update.
	* remote-fileio.c (remote_fileio_ctrl_c_signal_handler): Update.
	* remote.c (interrupt_query): Update.
	* ocd.c (interrupt_query): Update.
	* nto-procfs.c (interrupt_query): Update.
	* monitor.c (monitor_interrupt_query): Update.
	* breakpoint.c (break_command_1): Update.
@
text
@d1361 1
a1361 1
  error ("Illegal argument for \"set remote system-call-allowed\" command");
d1368 1
a1368 1
    error ("Garbage after \"show remote system-call-allowed\" command: `%s'", args);
@


1.9
log
@2005-01-14  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (catch_exceptions): Delete errstring parameter.
	(catch_exceptions_with_msg): Ditto.
	* exceptions.c (catch_exceptions_with_msg): Update.
	(catch_exceptions): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* frame.c (get_current_frame): Update.
	* wrapper.c (gdb_value_struct_elt): Update.
	* exceptions.c (catch_exceptions): Update.
	* thread.c (gdb_list_thread_ids, gdb_thread_select): Update.
	* breakpoint.c (gdb_breakpoint_query, gdb_breakpoint): Update.
	* remote-fileio.c (remote_fileio_request): Update.
@
text
@d483 1
a483 1
    throw_reason (RETURN_QUIT);
@


1.8
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (throw_reason): Rename throw_exception.
	(enum errors, struct exception): Define.
	(catch_exception_ftype): Define.
	(catch_exception, throw_exception): Declare.
	* exceptions.c (throw_exception): Rewrite.
	(throw_reason): New function.
	(struct catcher, catcher_state_machine): Replace "reason" with
	"exception", delete "gdberrmsg".
	(catch_exception): New function.
	(catcher_init): Replace "gdberrmsg" parameter with "exception".
	(catch_errors, catch_exceptions_with_msg): Re-implement passing
	exception to catcher_init.
	* utils.c (error_silent, error_stream_1): Use throw_reason.
	(internal_verror, quit): Ditto.
	* breakpoint.c (insert_catchpoint, break_command_1): Ditto.
	* remote-fileio.c (remote_fileio_ctrl_c_signal_handler): Ditto.
	* remote.c (remote_open_1, interrupt_query): Ditto.
@
text
@d1332 1
a1332 1
			 NULL, RETURN_MASK_ALL);
@


1.7
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d483 1
a483 1
    throw_exception (RETURN_QUIT);
@


1.6
log
@2004-01-27  Andrew Cagney  <cagney@@redhat.com>

	* source.c (ambiguous_line_spec): Delete undefined declaration.
	* m32r-rom.c (m32r_set_board_address): Delete unused function.
	(m32r_set_server_address, m32r_set_download_path): Ditto.
	* remote-fileio.c (remote_fileio_to_fio_int): Ditto.
@
text
@d31 1
@


1.5
log
@	* remote-fileio.c (remote_fileio_to_fio_stat)
	(remote_fileio_func_fstat) [HAVE_STRUCT_STAT_ST_BLOCKS]: Support
	systems that don't have `st_blocks' member in `struct stat'.

	* configure.in (HAVE_STRUCT_STAT_ST_BLOCKS): Ditto.
@
text
@a366 6
remote_fileio_to_fio_int (long num, fio_int_t fnum)
{
  remote_fileio_to_be ((LONGEST) num, (char *) fnum, 4);
}

static void
@


1.4
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* remote-fileio.c: Include "remote-fileio.h".
	* Makefile.in (remote-fileio.o): Update dependencies.
	(remote_fileio_h): Fix typo.
@
text
@d414 1
d416 8
d1143 1
d1145 1
@


1.4.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.4.14.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@a413 1
#if HAVE_STRUCT_STAT_ST_BLOCKS
a414 8
#else
  /* FIXME: This is correct for DJGPP, but other systems that don't
     have st_blocks, if any, might prefer 512 instead of st_blksize.
     (eliz, 30-12-2003)  */
  remote_fileio_to_fio_ulong (((LONGEST) st->st_size + st->st_blksize - 1)
			      / (LONGEST) st->st_blksize,
			      fst->fst_blocks);
#endif
a1133 1
#if HAVE_STRUCT_STAT_ST_BLOCKS
a1134 1
#endif
@


1.4.14.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d367 6
@


1.4.6.1
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@@


1.4.6.2
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@a413 1
#if HAVE_STRUCT_STAT_ST_BLOCKS
a414 8
#else
  /* FIXME: This is correct for DJGPP, but other systems that don't
     have st_blocks, if any, might prefer 512 instead of st_blksize.
     (eliz, 30-12-2003)  */
  remote_fileio_to_fio_ulong (((LONGEST) st->st_size + st->st_blksize - 1)
			      / (LONGEST) st->st_blksize,
			      fst->fst_blocks);
#endif
a1133 1
#if HAVE_STRUCT_STAT_ST_BLOCKS
a1134 1
#endif
@


1.3
log
@	* remote-fileio.c: Make ari happy.
@
text
@d31 1
@


1.2
log
@2003-06-10  Andrew Cagney  <cagney@@redhat.com>

	* remote-fileio.h (REMOTE_FILEIO_H): Replace FILEIO_H.
	* Makefile.in (remote-fileio.o): Update dependencies.
	* remote-fileio.c: Include "gdb_wait.h" and "gdb_stat.h".  Do not
	include <setjmp.h>, or <sys/types.h> conditional on USG.
	(remote_fio_jmp_buf): Delete global variable.
@
text
@d51 1
a51 1
remote_fileio_init_fd_map ()
d69 1
a69 1
remote_fileio_resize_fd_map ()
d81 1
a81 1
remote_fileio_next_free_fd ()
d178 1
a178 1
static long long
d284 1
a284 1
remote_fileio_extract_long (char **buf, long long *retlong)
d323 1
a323 1
  long long retlong;
d327 2
a328 1
  if (!(ret = remote_fileio_extract_long (buf, &retlong)))
d337 1
a337 1
  long long retlong;
d357 1
a357 1
remote_fileio_to_be (long long num, char *buf, int bytes)
d368 1
a368 1
  remote_fileio_to_be ((long long) num, (char *) fnum, 4);
d374 1
a374 1
  remote_fileio_to_be ((long long) num, (char *) fnum, 4);
d386 1
a386 1
  remote_fileio_to_be ((long long) num, (char *) fnum, 4);
d390 1
a390 1
remote_fileio_to_fio_long (long long num, fio_long_t fnum)
d396 1
a396 1
remote_fileio_to_fio_ulong (long long num, fio_ulong_t fnum)
d411 3
a413 3
  remote_fileio_to_fio_ulong ((long long) st->st_size, fst->fst_size);
  remote_fileio_to_fio_ulong ((long long) st->st_blksize, fst->fst_blksize);
  remote_fileio_to_fio_ulong ((long long) st->st_blocks, fst->fst_blocks);
d437 1
a437 1
remote_fileio_sig_init ()
d463 1
a463 1
remote_fileio_sig_exit ()
d513 1
a513 1
remote_fileio_ioerror ()
d519 1
a519 1
remote_fileio_badfd ()
d638 2
a639 1
  if ((fd = remote_fileio_map_fd ((int) num)) == FIO_FD_INVALID)
d656 1
a656 1
  long long lnum;
d669 2
a670 1
  if ((fd = remote_fileio_map_fd ((int) target_fd)) == FIO_FD_INVALID)
d774 1
a774 1
  long long lnum;
d786 2
a787 1
  if ((fd = remote_fileio_map_fd ((int) target_fd)) == FIO_FD_INVALID)
d847 1
a847 1
  long long lnum;
d857 2
a858 1
  if ((fd = remote_fileio_map_fd ((int) num)) == FIO_FD_INVALID)
d936 4
a939 4
  if ((!(of = stat (oldpath, &ost))
       && !S_ISREG (ost.st_mode) && !S_ISDIR (ost.st_mode))
      || (!(nf = stat (newpath, &nst))
          && !S_ISREG (nst.st_mode) && !S_ISDIR (nst.st_mode)))
d1035 1
a1035 1
  long long lnum;
d1097 1
a1097 1
  long long lnum;
d1108 2
a1109 1
  if ((fd = remote_fileio_map_fd ((int) target_fd)) == FIO_FD_INVALID)
d1165 1
a1165 1
  long long lnum;
@


1.1
log
@	* Makefile.in: Add dependencies for remote-fileio.o.
	* remote-fileio.c: New file implementing the remote File-I/O protocol.
	* remote-fileio.h: New header file defining remote File-I/O interface.
	* remote.c (remote_write_bytes, remote_read_bytes): Remove
	static storage class.
	(remote_wait, remote_async_wait): Call remote_fileio_request() on
	'F' packet.
	(_initialize_remote): Call initialize_remote_fileio().
	* remote.h: Declare remote_write_bytes() and remote_read_bytes().

	* Makefile.in (REMOTE_OBS): Add remote-fileio.o
	(SFILES): Add remote-fileio.c.
	Add dependencies for building remote-fileio.o.  Add remote-fileio.h to
	dependencies for building remote.o.
	* defs.h: Declare gdb_stdin, gdb_stdtargerr and gdb_stdtargin.
	* main.c: New ui_file gdb_stdin, gdb_stdtargerr and gdb_stdtargin.
	(captured_main): Initialize new ui_files.
	* ui-file.c: Add read and fgets input functions.
	(ui_file_new): set ui_file_fputs and ui_file_read to null functions.
	(null_file_read): New function.
	(ui_file_read): New function.
	(set_ui_file_read): New function.
	(stdio_file_read): New function.
	* ui-file.h: New type ui_file_read_ftype.
	(set_ui_file_read): Declare.
	(ui_file_read): Declare.
@
text
@d29 2
a31 1
#include <ctype.h>
a33 4
#ifdef USG
#include <sys/types.h>
#endif
#include <sys/stat.h>
d35 1
a35 1
#include <sys/cygwin.h>
a36 1
#include <setjmp.h>
a426 1
jmp_buf remote_fio_jmp_buf;
@

