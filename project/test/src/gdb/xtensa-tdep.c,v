head	1.65;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.63
	gdb_7_6-2013-04-26-release:1.63
	gdb_7_6-branch:1.63.0.2
	gdb_7_6-2013-03-12-branchpoint:1.63
	gdb_7_5_1-2012-11-29-release:1.61
	gdb_7_5-2012-08-17-release:1.61
	gdb_7_5-branch:1.61.0.2
	gdb_7_5-2012-07-18-branchpoint:1.61
	gdb_7_4_1-2012-04-26-release:1.58.2.1
	gdb_7_4-2012-01-24-release:1.58.2.1
	gdb_7_4-branch:1.58.0.2
	gdb_7_4-2011-12-13-branchpoint:1.58
	gdb_7_3_1-2011-09-04-release:1.57
	gdb_7_3-2011-07-26-release:1.57
	gdb_7_3-branch:1.57.0.2
	gdb_7_3-2011-04-01-branchpoint:1.57
	gdb_7_2-2010-09-02-release:1.43
	gdb_7_2-branch:1.43.0.2
	gdb_7_2-2010-07-07-branchpoint:1.43
	gdb_7_1-2010-03-18-release:1.42
	gdb_7_1-branch:1.42.0.2
	gdb_7_1-2010-02-18-branchpoint:1.42
	gdb_7_0_1-2009-12-22-release:1.39.2.1
	gdb_7_0-2009-10-06-release:1.39.2.1
	gdb_7_0-branch:1.39.0.2
	gdb_7_0-2009-09-16-branchpoint:1.39
	arc-sim-20090309:1.22
	msnyder-checkpoint-072509-branch:1.38.0.2
	msnyder-checkpoint-072509-branchpoint:1.38
	arc-insight_6_8-branch:1.22.0.6
	arc-insight_6_8-branchpoint:1.22
	insight_6_8-branch:1.22.0.4
	insight_6_8-branchpoint:1.22
	reverse-20081226-branch:1.29.0.6
	reverse-20081226-branchpoint:1.29
	multiprocess-20081120-branch:1.29.0.4
	multiprocess-20081120-branchpoint:1.29
	reverse-20080930-branch:1.29.0.2
	reverse-20080930-branchpoint:1.29
	reverse-20080717-branch:1.27.0.4
	reverse-20080717-branchpoint:1.27
	msnyder-reverse-20080609-branch:1.27.0.2
	msnyder-reverse-20080609-branchpoint:1.27
	drow-reverse-20070409-branch:1.5.0.2
	drow-reverse-20070409-branchpoint:1.5
	gdb_6_8-2008-03-27-release:1.22
	gdb_6_8-branch:1.22.0.2
	gdb_6_8-2008-02-26-branchpoint:1.22
	gdb_6_7_1-2007-10-29-release:1.12
	gdb_6_7-2007-10-10-release:1.12
	gdb_6_7-branch:1.12.0.2
	gdb_6_7-2007-09-07-branchpoint:1.12
	insight_6_6-20070208-release:1.1
	gdb_6_6-2006-12-18-release:1.1
	gdb_6_6-branch:1.1.0.2
	gdb_6_6-2006-11-15-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.65
date	2013.04.19.15.23.52;	author palves;	state Exp;
branches;
next	1.64;

1.64
date	2013.04.19.15.09.46;	author palves;	state Exp;
branches;
next	1.63;

1.63
date	2013.01.01.06.41.29;	author brobecke;	state Exp;
branches;
next	1.62;

1.62
date	2012.08.02.09.36.40;	author qiyao;	state Exp;
branches;
next	1.61;

1.61
date	2012.05.18.21.02.51;	author sergiodj;	state Exp;
branches;
next	1.60;

1.60
date	2012.05.16.14.35.08;	author macro;	state Exp;
branches;
next	1.59;

1.59
date	2012.01.04.08.27.58;	author brobecke;	state Exp;
branches;
next	1.58;

1.58
date	2011.04.19.07.16.42;	author muller;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2011.03.18.18.52.32;	author palves;	state Exp;
branches;
next	1.56;

1.56
date	2011.03.18.18.38.44;	author palves;	state Exp;
branches;
next	1.55;

1.55
date	2011.03.11.18.37.45;	author maxim2405;	state Exp;
branches;
next	1.54;

1.54
date	2011.03.11.02.32.31;	author maxim2405;	state Exp;
branches;
next	1.53;

1.53
date	2011.03.11.00.21.42;	author maxim2405;	state Exp;
branches;
next	1.52;

1.52
date	2011.03.10.00.15.23;	author maxim2405;	state Exp;
branches;
next	1.51;

1.51
date	2011.03.09.03.28.36;	author maxim2405;	state Exp;
branches;
next	1.50;

1.50
date	2011.03.09.02.56.23;	author maxim2405;	state Exp;
branches;
next	1.49;

1.49
date	2011.03.09.02.25.12;	author maxim2405;	state Exp;
branches;
next	1.48;

1.48
date	2011.03.09.00.55.09;	author maxim2405;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.12.01.23.29;	author msnyder;	state Exp;
branches;
next	1.46;

1.46
date	2011.01.01.15.33.19;	author brobecke;	state Exp;
branches;
next	1.45;

1.45
date	2010.09.10.16.17.14;	author muller;	state Exp;
branches;
next	1.44;

1.44
date	2010.08.18.19.13.33;	author devans;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.01.15.36.18;	author palves;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.01.07.31.46;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.21.18.51.42;	author maxim2405;	state Exp;
branches;
next	1.40;

1.40
date	2009.09.19.03.56.31;	author maxim2405;	state Exp;
branches;
next	1.39;

1.39
date	2009.08.14.00.32.32;	author palves;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2009.07.10.15.27.02;	author tromey;	state Exp;
branches;
next	1.37;

1.37
date	2009.07.02.17.25.59;	author uweigand;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.02.12.55.30;	author uweigand;	state Exp;
branches;
next	1.35;

1.35
date	2009.07.02.12.46.19;	author uweigand;	state Exp;
branches;
next	1.34;

1.34
date	2009.05.06.00.37.22;	author maxim2405;	state Exp;
branches;
next	1.33;

1.33
date	2009.04.17.15.44.28;	author muller;	state Exp;
branches;
next	1.32;

1.32
date	2009.02.22.01.02.20;	author palves;	state Exp;
branches;
next	1.31;

1.31
date	2009.02.13.22.10.25;	author muller;	state Exp;
branches;
next	1.30;

1.30
date	2009.01.03.05.57.54;	author brobecke;	state Exp;
branches;
next	1.29;

1.29
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.28;

1.28
date	2008.09.11.14.20.50;	author uweigand;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.21.18.37.30;	author maxim2405;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.16.00.27.23;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.05.20.49.44;	author maxim2405;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.23.21.17.05;	author maxim2405;	state Exp;
branches;
next	1.23;

1.23
date	2008.04.22.11.03.42;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2008.02.11.21.58.41;	author maxim2405;	state Exp;
branches;
next	1.21;

1.21
date	2008.01.11.13.20.02;	author deuling;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.06.16.33.00;	author deuling;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.17.00.55.29;	author uweigand;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.12.06.43.16;	author deuling;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.07.06.33.01;	author deuling;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.02.14.27.15;	author uweigand;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.10.17.01.10;	author uweigand;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.09.19.54.04;	author uweigand;	state Exp;
branches;
next	1.12;

1.12
date	2007.08.23.18.08.47;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.17.21.53.29;	author maxim2405;	state Exp;
branches;
next	1.10;

1.10
date	2007.08.08.23.22.18;	author maxim2405;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.15.22.34.13;	author uweigand;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.31.20.57.41;	author uweigand;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.27.20.17.19;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.20.12.45.06;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.15.19.51.59;	author maxim2405;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.14.21.53.59;	author drow;	state Exp;
branches;
next	;

1.58.2.1
date	2012.01.06.04.54.35;	author brobecke;	state Exp;
branches;
next	;

1.39.2.1
date	2009.09.19.16.36.10;	author maxim2405;	state Exp;
branches;
next	;


desc
@@


1.65
log
@-Wpointer-sign: xtensa-tdep.c.

../../src/gdb/xtensa-tdep.c:2914:4: error: pointer targets in passing argument 7 of ‘xtensa_operand_get_field’ differ in signedness [-Werror=pointer-sign]
In file included from ../../src/gdb/xtensa-tdep.c:53:0:
../../src/gdb/../include/xtensa-isa.h:487:1: note: expected ‘unsigned int *’ but argument is of type ‘int *’
../../src/gdb/xtensa-tdep.c:2916:4: error: pointer targets in passing argument 4 of ‘xtensa_operand_decode’ differ in signedness [-Werror=pointer-sign]
In file included from ../../src/gdb/xtensa-tdep.c:53:0:
../../src/gdb/../include/xtensa-isa.h:507:1: note: expected ‘unsigned int *’ but argument is of type ‘int *’
../../src/gdb/xtensa-tdep.c:2918:4: error: pointer targets in passing argument 7 of ‘xtensa_operand_get_field’ differ in signedness [-Werror=pointer-sign]
In file included from ../../src/gdb/xtensa-tdep.c:53:0:
../../src/gdb/../include/xtensa-isa.h:487:1: note: expected ‘unsigned int *’ but argument is of type ‘int *’
../../src/gdb/xtensa-tdep.c:2920:4: error: pointer targets in passing argument 4 of ‘xtensa_operand_decode’ differ in signedness [-Werror=pointer-sign]
In file included from ../../src/gdb/xtensa-tdep.c:53:0:
../../src/gdb/../include/xtensa-isa.h:507:1: note: expected ‘unsigned int *’ but argument is of type ‘int *’
../../src/gdb/xtensa-tdep.c:2922:4: error: pointer targets in passing argument 7 of ‘xtensa_operand_get_field’ differ in signedness [-Werror=pointer-sign]
In file included from ../../src/gdb/xtensa-tdep.c:53:0:
../../src/gdb/../include/xtensa-isa.h:487:1: note: expected ‘unsigned int *’ but argument is of type ‘int *’
../../src/gdb/xtensa-tdep.c:2924:4: error: pointer targets in passing argument 4 of ‘xtensa_operand_decode’ differ in signedness [-Werror=pointer-sign]
In file included from ../../src/gdb/xtensa-tdep.c:53:0:
../../src/gdb/../include/xtensa-isa.h:507:1: note: expected ‘unsigned int *’ but argument is of type ‘int *’

Those bfd functions that decode instructions output uint32_t values.
Hence this fix:

2013-04-19  Pedro Alves  <palves@@redhat.com>

	* xtensa-tdep.c (execute_l32e, execute_s32e): Change type of
	parameters 'at', 'as' and 'offset' to uint32_t.
@
text
@/* Target-dependent code for the Xtensa port of GDB, the GNU debugger.

   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "frame.h"
#include "solib-svr4.h"
#include "symtab.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdbtypes.h"
#include "gdbcore.h"
#include "value.h"
#include "dis-asm.h"
#include "inferior.h"
#include "floatformat.h"
#include "regcache.h"
#include "reggroups.h"
#include "regset.h"

#include "dummy-frame.h"
#include "dwarf2.h"
#include "dwarf2-frame.h"
#include "dwarf2loc.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"

#include "arch-utils.h"
#include "gdbarch.h"
#include "remote.h"
#include "serial.h"

#include "command.h"
#include "gdbcmd.h"
#include "gdb_assert.h"

#include "xtensa-isa.h"
#include "xtensa-tdep.h"
#include "xtensa-config.h"


static unsigned int xtensa_debug_level = 0;

#define DEBUGWARN(args...) \
  if (xtensa_debug_level > 0) \
    fprintf_unfiltered (gdb_stdlog, "(warn ) " args)

#define DEBUGINFO(args...) \
  if (xtensa_debug_level > 1) \
    fprintf_unfiltered (gdb_stdlog, "(info ) " args)

#define DEBUGTRACE(args...) \
  if (xtensa_debug_level > 2) \
    fprintf_unfiltered (gdb_stdlog, "(trace) " args)

#define DEBUGVERB(args...) \
  if (xtensa_debug_level > 3) \
    fprintf_unfiltered (gdb_stdlog, "(verb ) " args)


/* According to the ABI, the SP must be aligned to 16-byte boundaries.  */
#define SP_ALIGNMENT 16


/* On Windowed ABI, we use a6 through a11 for passing arguments
   to a function called by GDB because CALL4 is used.  */
#define ARGS_NUM_REGS		6
#define REGISTER_SIZE		4


/* Extract the call size from the return address or PS register.  */
#define PS_CALLINC_SHIFT	16
#define PS_CALLINC_MASK		0x00030000
#define CALLINC(ps)		(((ps) & PS_CALLINC_MASK) >> PS_CALLINC_SHIFT)
#define WINSIZE(ra)		(4 * (( (ra) >> 30) & 0x3))

/* On TX,  hardware can be configured without Exception Option.
   There is no PS register in this case.  Inside XT-GDB,  let us treat
   it as a virtual read-only register always holding the same value.  */
#define TX_PS			0x20

/* ABI-independent macros.  */
#define ARG_NOF(gdbarch) \
  (gdbarch_tdep (gdbarch)->call_abi \
   == CallAbiCall0Only ? C0_NARGS : (ARGS_NUM_REGS))
#define ARG_1ST(gdbarch) \
  (gdbarch_tdep (gdbarch)->call_abi  == CallAbiCall0Only \
   ? (gdbarch_tdep (gdbarch)->a0_base + C0_ARGS) \
   : (gdbarch_tdep (gdbarch)->a0_base + 6))

/* XTENSA_IS_ENTRY tests whether the first byte of an instruction
   indicates that the instruction is an ENTRY instruction.  */

#define XTENSA_IS_ENTRY(gdbarch, op1) \
  ((gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG) \
   ? ((op1) == 0x6c) : ((op1) == 0x36))

#define XTENSA_ENTRY_LENGTH	3

/* windowing_enabled() returns true, if windowing is enabled.
   WOE must be set to 1; EXCM to 0.
   Note: We assume that EXCM is always 0 for XEA1.  */

#define PS_WOE			(1<<18)
#define PS_EXC			(1<<4)

static int
windowing_enabled (struct gdbarch *gdbarch, unsigned int ps)
{
  /* If we know CALL0 ABI is set explicitly,  say it is Call0.  */
  if (gdbarch_tdep (gdbarch)->call_abi == CallAbiCall0Only)
    return 0;

  return ((ps & PS_EXC) == 0 && (ps & PS_WOE) != 0);
}

/* Convert a live A-register number to the corresponding AR-register
   number.  */
static int
arreg_number (struct gdbarch *gdbarch, int a_regnum, ULONGEST wb)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int arreg;

  arreg = a_regnum - tdep->a0_base;
  arreg += (wb & ((tdep->num_aregs - 1) >> 2)) << WB_SHIFT;
  arreg &= tdep->num_aregs - 1;

  return arreg + tdep->ar_base;
}

/* Convert a live AR-register number to the corresponding A-register order
   number in a range [0..15].  Return -1, if AR_REGNUM is out of WB window.  */
static int
areg_number (struct gdbarch *gdbarch, int ar_regnum, unsigned int wb)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int areg;

  areg = ar_regnum - tdep->ar_base;
  if (areg < 0 || areg >= tdep->num_aregs)
    return -1;
  areg = (areg - wb * 4) & (tdep->num_aregs - 1);
  return (areg > 15) ? -1 : areg;
}

/* Read Xtensa register directly from the hardware.  */ 
static unsigned long
xtensa_read_register (int regnum)
{
  ULONGEST value;

  regcache_raw_read_unsigned (get_current_regcache (), regnum, &value);
  return (unsigned long) value;
}

/* Write Xtensa register directly to the hardware.  */ 
static void
xtensa_write_register (int regnum, ULONGEST value)
{
  regcache_raw_write_unsigned (get_current_regcache (), regnum, value);
}

/* Return the window size of the previous call to the function from which we
   have just returned.

   This function is used to extract the return value after a called function
   has returned to the caller.  On Xtensa, the register that holds the return
   value (from the perspective of the caller) depends on what call
   instruction was used.  For now, we are assuming that the call instruction
   precedes the current address, so we simply analyze the call instruction.
   If we are in a dummy frame, we simply return 4 as we used a 'pseudo-call4'
   method to call the inferior function.  */

static int
extract_call_winsize (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int winsize = 4;
  int insn;
  gdb_byte buf[4];

  DEBUGTRACE ("extract_call_winsize (pc = 0x%08x)\n", (int) pc);

  /* Read the previous instruction (should be a call[x]{4|8|12}.  */
  read_memory (pc-3, buf, 3);
  insn = extract_unsigned_integer (buf, 3, byte_order);

  /* Decode call instruction:
     Little Endian
       call{0,4,8,12}   OFFSET || {00,01,10,11} || 0101
       callx{0,4,8,12}  OFFSET || 11 || {00,01,10,11} || 0000
     Big Endian
       call{0,4,8,12}   0101 || {00,01,10,11} || OFFSET
       callx{0,4,8,12}  0000 || {00,01,10,11} || 11 || OFFSET.  */

  if (byte_order == BFD_ENDIAN_LITTLE)
    {
      if (((insn & 0xf) == 0x5) || ((insn & 0xcf) == 0xc0))
	winsize = (insn & 0x30) >> 2;   /* 0, 4, 8, 12.  */
    }
  else
    {
      if (((insn >> 20) == 0x5) || (((insn >> 16) & 0xf3) == 0x03))
	winsize = (insn >> 16) & 0xc;   /* 0, 4, 8, 12.  */
    }
  return winsize;
}


/* REGISTER INFORMATION */

/* Find register by name.  */
static int
xtensa_find_register_by_name (struct gdbarch *gdbarch, char *name)
{
  int i;

  for (i = 0; i < gdbarch_num_regs (gdbarch)
	 + gdbarch_num_pseudo_regs (gdbarch);
       i++)

    if (strcasecmp (gdbarch_tdep (gdbarch)->regmap[i].name, name) == 0)
      return i;

  return -1;
}

/* Returns the name of a register.  */
static const char *
xtensa_register_name (struct gdbarch *gdbarch, int regnum)
{
  /* Return the name stored in the register map.  */
  if (regnum >= 0 && regnum < gdbarch_num_regs (gdbarch)
			      + gdbarch_num_pseudo_regs (gdbarch))
    return gdbarch_tdep (gdbarch)->regmap[regnum].name;

  internal_error (__FILE__, __LINE__, _("invalid register %d"), regnum);
  return 0;
}

/* Return the type of a register.  Create a new type, if necessary.  */

static struct type *
xtensa_register_type (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* Return signed integer for ARx and Ax registers.  */
  if ((regnum >= tdep->ar_base
       && regnum < tdep->ar_base + tdep->num_aregs)
      || (regnum >= tdep->a0_base
	  && regnum < tdep->a0_base + 16))
    return builtin_type (gdbarch)->builtin_int;

  if (regnum == gdbarch_pc_regnum (gdbarch)
      || regnum == tdep->a0_base + 1)
    return builtin_type (gdbarch)->builtin_data_ptr;

  /* Return the stored type for all other registers.  */
  else if (regnum >= 0 && regnum < gdbarch_num_regs (gdbarch)
				   + gdbarch_num_pseudo_regs (gdbarch))
    {
      xtensa_register_t* reg = &tdep->regmap[regnum];

      /* Set ctype for this register (only the first time).  */

      if (reg->ctype == 0)
	{
	  struct ctype_cache *tp;
	  int size = reg->byte_size;

	  /* We always use the memory representation,
	     even if the register width is smaller.  */
	  switch (size)
	    {
	    case 1:
	      reg->ctype = builtin_type (gdbarch)->builtin_uint8;
	      break;

	    case 2:
	      reg->ctype = builtin_type (gdbarch)->builtin_uint16;
	      break;

	    case 4:
	      reg->ctype = builtin_type (gdbarch)->builtin_uint32;
	      break;

	    case 8:
	      reg->ctype = builtin_type (gdbarch)->builtin_uint64;
	      break;

	    case 16:
	      reg->ctype = builtin_type (gdbarch)->builtin_uint128;
	      break;

	    default:
	      for (tp = tdep->type_entries; tp != NULL; tp = tp->next)
		if (tp->size == size)
		  break;

	      if (tp == NULL)
		{
		  char *name = xstrprintf ("int%d", size * 8);
		  tp = xmalloc (sizeof (struct ctype_cache));
		  tp->next = tdep->type_entries;
		  tdep->type_entries = tp;
		  tp->size = size;
		  tp->virtual_type
		    = arch_integer_type (gdbarch, size * 8, 1, name);
		  xfree (name);
		}

	      reg->ctype = tp->virtual_type;
	    }
	}
      return reg->ctype;
    }

  internal_error (__FILE__, __LINE__, _("invalid register number %d"), regnum);
  return 0;
}


/* Return the 'local' register number for stubs, dwarf2, etc.
   The debugging information enumerates registers starting from 0 for A0
   to n for An.  So, we only have to add the base number for A0.  */

static int
xtensa_reg_to_regnum (struct gdbarch *gdbarch, int regnum)
{
  int i;

  if (regnum >= 0 && regnum < 16)
    return gdbarch_tdep (gdbarch)->a0_base + regnum;

  for (i = 0;
       i < gdbarch_num_regs (gdbarch) + gdbarch_num_pseudo_regs (gdbarch);
       i++)
    if (regnum == gdbarch_tdep (gdbarch)->regmap[i].target_number)
      return i;

  internal_error (__FILE__, __LINE__,
		  _("invalid dwarf/stabs register number %d"), regnum);
  return 0;
}


/* Write the bits of a masked register to the various registers.
   Only the masked areas of these registers are modified; the other
   fields are untouched.  The size of masked registers is always less
   than or equal to 32 bits.  */

static void
xtensa_register_write_masked (struct regcache *regcache,
			      xtensa_register_t *reg, const gdb_byte *buffer)
{
  unsigned int value[(MAX_REGISTER_SIZE + 3) / 4];
  const xtensa_mask_t *mask = reg->mask;

  int shift = 0;		/* Shift for next mask (mod 32).  */
  int start, size;		/* Start bit and size of current mask.  */

  unsigned int *ptr = value;
  unsigned int regval, m, mem = 0;

  int bytesize = reg->byte_size;
  int bitsize = bytesize * 8;
  int i, r;

  DEBUGTRACE ("xtensa_register_write_masked ()\n");

  /* Copy the masked register to host byte-order.  */
  if (gdbarch_byte_order (get_regcache_arch (regcache)) == BFD_ENDIAN_BIG)
    for (i = 0; i < bytesize; i++)
      {
	mem >>= 8;
	mem |= (buffer[bytesize - i - 1] << 24);
	if ((i & 3) == 3)
	  *ptr++ = mem;
      }
  else
    for (i = 0; i < bytesize; i++)
      {
	mem >>= 8;
	mem |= (buffer[i] << 24);
	if ((i & 3) == 3)
	  *ptr++ = mem;
      }

  /* We might have to shift the final value:
     bytesize & 3 == 0 -> nothing to do, we use the full 32 bits,
     bytesize & 3 == x -> shift (4-x) * 8.  */

  *ptr = mem >> (((0 - bytesize) & 3) * 8);
  ptr = value;
  mem = *ptr;

  /* Write the bits to the masked areas of the other registers.  */
  for (i = 0; i < mask->count; i++)
    {
      start = mask->mask[i].bit_start;
      size = mask->mask[i].bit_size;
      regval = mem >> shift;

      if ((shift += size) > bitsize)
	error (_("size of all masks is larger than the register"));

      if (shift >= 32)
	{
	  mem = *(++ptr);
	  shift -= 32;
	  bitsize -= 32;

	  if (shift > 0)
	    regval |= mem << (size - shift);
	}

      /* Make sure we have a valid register.  */
      r = mask->mask[i].reg_num;
      if (r >= 0 && size > 0)
	{
	  /* Don't overwrite the unmasked areas.  */
	  ULONGEST old_val;
	  regcache_cooked_read_unsigned (regcache, r, &old_val);
	  m = 0xffffffff >> (32 - size) << start;
	  regval <<= start;
	  regval = (regval & m) | (old_val & ~m);
	  regcache_cooked_write_unsigned (regcache, r, regval);
	}
    }
}


/* Read a tie state or mapped registers.  Read the masked areas
   of the registers and assemble them into a single value.  */

static enum register_status
xtensa_register_read_masked (struct regcache *regcache,
			     xtensa_register_t *reg, gdb_byte *buffer)
{
  unsigned int value[(MAX_REGISTER_SIZE + 3) / 4];
  const xtensa_mask_t *mask = reg->mask;

  int shift = 0;
  int start, size;

  unsigned int *ptr = value;
  unsigned int regval, mem = 0;

  int bytesize = reg->byte_size;
  int bitsize = bytesize * 8;
  int i;

  DEBUGTRACE ("xtensa_register_read_masked (reg \"%s\", ...)\n",
	      reg->name == 0 ? "" : reg->name);

  /* Assemble the register from the masked areas of other registers.  */
  for (i = 0; i < mask->count; i++)
    {
      int r = mask->mask[i].reg_num;
      if (r >= 0)
	{
	  enum register_status status;
	  ULONGEST val;

	  status = regcache_cooked_read_unsigned (regcache, r, &val);
	  if (status != REG_VALID)
	    return status;
	  regval = (unsigned int) val;
	}
      else
	regval = 0;

      start = mask->mask[i].bit_start;
      size = mask->mask[i].bit_size;

      regval >>= start;

      if (size < 32)
	regval &= (0xffffffff >> (32 - size));

      mem |= regval << shift;

      if ((shift += size) > bitsize)
	error (_("size of all masks is larger than the register"));

      if (shift >= 32)
	{
	  *ptr++ = mem;
	  bitsize -= 32;
	  shift -= 32;

	  if (shift == 0)
	    mem = 0;
	  else
	    mem = regval >> (size - shift);
	}
    }

  if (shift > 0)
    *ptr = mem;

  /* Copy value to target byte order.  */
  ptr = value;
  mem = *ptr;

  if (gdbarch_byte_order (get_regcache_arch (regcache)) == BFD_ENDIAN_BIG)
    for (i = 0; i < bytesize; i++)
      {
	if ((i & 3) == 0)
	  mem = *ptr++;
	buffer[bytesize - i - 1] = mem & 0xff;
	mem >>= 8;
      }
  else
    for (i = 0; i < bytesize; i++)
      {
	if ((i & 3) == 0)
	  mem = *ptr++;
	buffer[i] = mem & 0xff;
	mem >>= 8;
      }

  return REG_VALID;
}


/* Read pseudo registers.  */

static enum register_status
xtensa_pseudo_register_read (struct gdbarch *gdbarch,
			     struct regcache *regcache,
			     int regnum,
			     gdb_byte *buffer)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  DEBUGTRACE ("xtensa_pseudo_register_read (... regnum = %d (%s) ...)\n",
	      regnum, xtensa_register_name (gdbarch, regnum));

  if (regnum == gdbarch_num_regs (gdbarch)
		+ gdbarch_num_pseudo_regs (gdbarch) - 1)
     regnum = gdbarch_tdep (gdbarch)->a0_base + 1;

  /* Read aliases a0..a15, if this is a Windowed ABI.  */
  if (gdbarch_tdep (gdbarch)->isa_use_windowed_registers
      && (regnum >= gdbarch_tdep (gdbarch)->a0_base)
      && (regnum <= gdbarch_tdep (gdbarch)->a0_base + 15))
    {
      gdb_byte *buf = (gdb_byte *) alloca (MAX_REGISTER_SIZE);
      enum register_status status;

      status = regcache_raw_read (regcache,
				  gdbarch_tdep (gdbarch)->wb_regnum,
				  buf);
      if (status != REG_VALID)
	return status;
      regnum = arreg_number (gdbarch, regnum,
			     extract_unsigned_integer (buf, 4, byte_order));
    }

  /* We can always read non-pseudo registers.  */
  if (regnum >= 0 && regnum < gdbarch_num_regs (gdbarch))
    return regcache_raw_read (regcache, regnum, buffer);

  /* We have to find out how to deal with priveleged registers.
     Let's treat them as pseudo-registers, but we cannot read/write them.  */
     
  else if (regnum < gdbarch_tdep (gdbarch)->a0_base)
    {
      buffer[0] = (gdb_byte)0;
      buffer[1] = (gdb_byte)0;
      buffer[2] = (gdb_byte)0;
      buffer[3] = (gdb_byte)0;
      return REG_VALID;
    }
  /* Pseudo registers.  */
  else if (regnum >= 0
	    && regnum < gdbarch_num_regs (gdbarch)
			+ gdbarch_num_pseudo_regs (gdbarch))
    {
      xtensa_register_t *reg = &gdbarch_tdep (gdbarch)->regmap[regnum];
      xtensa_register_type_t type = reg->type;
      int flags = gdbarch_tdep (gdbarch)->target_flags;

      /* We cannot read Unknown or Unmapped registers.  */
      if (type == xtRegisterTypeUnmapped || type == xtRegisterTypeUnknown)
	{
	  if ((flags & xtTargetFlagsNonVisibleRegs) == 0)
	    {
	      warning (_("cannot read register %s"),
		       xtensa_register_name (gdbarch, regnum));
	      return REG_VALID;
	    }
	}

      /* Some targets cannot read TIE register files.  */
      else if (type == xtRegisterTypeTieRegfile)
        {
	  /* Use 'fetch' to get register?  */
	  if (flags & xtTargetFlagsUseFetchStore)
	    {
	      warning (_("cannot read register"));
	      return REG_VALID;
	    }

	  /* On some targets (esp. simulators), we can always read the reg.  */
	  else if ((flags & xtTargetFlagsNonVisibleRegs) == 0)
	    {
	      warning (_("cannot read register"));
	      return REG_VALID;
	    }
	}

      /* We can always read mapped registers.  */
      else if (type == xtRegisterTypeMapped || type == xtRegisterTypeTieState)
	return xtensa_register_read_masked (regcache, reg, buffer);

      /* Assume that we can read the register.  */
      return regcache_raw_read (regcache, regnum, buffer);
    }
  else
    internal_error (__FILE__, __LINE__,
		    _("invalid register number %d"), regnum);
}


/* Write pseudo registers.  */

static void
xtensa_pseudo_register_write (struct gdbarch *gdbarch,
			      struct regcache *regcache,
			      int regnum,
			      const gdb_byte *buffer)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  DEBUGTRACE ("xtensa_pseudo_register_write (... regnum = %d (%s) ...)\n",
	      regnum, xtensa_register_name (gdbarch, regnum));

  if (regnum == gdbarch_num_regs (gdbarch)
		+ gdbarch_num_pseudo_regs (gdbarch) -1)
     regnum = gdbarch_tdep (gdbarch)->a0_base + 1;

  /* Renumber register, if aliase a0..a15 on Windowed ABI.  */
  if (gdbarch_tdep (gdbarch)->isa_use_windowed_registers
      && (regnum >= gdbarch_tdep (gdbarch)->a0_base)
      && (regnum <= gdbarch_tdep (gdbarch)->a0_base + 15))
    {
      gdb_byte *buf = (gdb_byte *) alloca (MAX_REGISTER_SIZE);

      regcache_raw_read (regcache,
			 gdbarch_tdep (gdbarch)->wb_regnum, buf);
      regnum = arreg_number (gdbarch, regnum,
			     extract_unsigned_integer (buf, 4, byte_order));
    }

  /* We can always write 'core' registers.
     Note: We might have converted Ax->ARy.  */
  if (regnum >= 0 && regnum < gdbarch_num_regs (gdbarch))
    regcache_raw_write (regcache, regnum, buffer);

  /* We have to find out how to deal with priveleged registers.
     Let's treat them as pseudo-registers, but we cannot read/write them.  */

  else if (regnum < gdbarch_tdep (gdbarch)->a0_base)
    {
      return;
    }
  /* Pseudo registers.  */
  else if (regnum >= 0
	   && regnum < gdbarch_num_regs (gdbarch)
		       + gdbarch_num_pseudo_regs (gdbarch))
    {
      xtensa_register_t *reg = &gdbarch_tdep (gdbarch)->regmap[regnum];
      xtensa_register_type_t type = reg->type;
      int flags = gdbarch_tdep (gdbarch)->target_flags;

      /* On most targets, we cannot write registers
	 of type "Unknown" or "Unmapped".  */
      if (type == xtRegisterTypeUnmapped || type == xtRegisterTypeUnknown)
        {
	  if ((flags & xtTargetFlagsNonVisibleRegs) == 0)
	    {
	      warning (_("cannot write register %s"),
		       xtensa_register_name (gdbarch, regnum));
	      return;
	    }
	}

      /* Some targets cannot read TIE register files.  */
      else if (type == xtRegisterTypeTieRegfile)
        {
	  /* Use 'store' to get register?  */
	  if (flags & xtTargetFlagsUseFetchStore)
	    {
	      warning (_("cannot write register"));
	      return;
	    }

	  /* On some targets (esp. simulators), we can always write
	     the register.  */
	  else if ((flags & xtTargetFlagsNonVisibleRegs) == 0)
	    {
	      warning (_("cannot write register"));
	      return;
	    }
	}

      /* We can always write mapped registers.  */
      else if (type == xtRegisterTypeMapped || type == xtRegisterTypeTieState)
        {
	  xtensa_register_write_masked (regcache, reg, buffer);
	  return;
	}

      /* Assume that we can write the register.  */
      regcache_raw_write (regcache, regnum, buffer);
    }
  else
    internal_error (__FILE__, __LINE__,
		    _("invalid register number %d"), regnum);
}

static struct reggroup *xtensa_ar_reggroup;
static struct reggroup *xtensa_user_reggroup;
static struct reggroup *xtensa_vectra_reggroup;
static struct reggroup *xtensa_cp[XTENSA_MAX_COPROCESSOR];

static void
xtensa_init_reggroups (void)
{
  int i;
  char cpname[] = "cp0";

  xtensa_ar_reggroup = reggroup_new ("ar", USER_REGGROUP);
  xtensa_user_reggroup = reggroup_new ("user", USER_REGGROUP);
  xtensa_vectra_reggroup = reggroup_new ("vectra", USER_REGGROUP);

  for (i = 0; i < XTENSA_MAX_COPROCESSOR; i++)
    {
      cpname[2] = '0' + i;
      xtensa_cp[i] = reggroup_new (cpname, USER_REGGROUP);
    }
}

static void
xtensa_add_reggroups (struct gdbarch *gdbarch)
{
  int i;

  /* Predefined groups.  */
  reggroup_add (gdbarch, all_reggroup);
  reggroup_add (gdbarch, save_reggroup);
  reggroup_add (gdbarch, restore_reggroup);
  reggroup_add (gdbarch, system_reggroup);
  reggroup_add (gdbarch, vector_reggroup);
  reggroup_add (gdbarch, general_reggroup);
  reggroup_add (gdbarch, float_reggroup);

  /* Xtensa-specific groups.  */
  reggroup_add (gdbarch, xtensa_ar_reggroup);
  reggroup_add (gdbarch, xtensa_user_reggroup);
  reggroup_add (gdbarch, xtensa_vectra_reggroup);

  for (i = 0; i < XTENSA_MAX_COPROCESSOR; i++)
    reggroup_add (gdbarch, xtensa_cp[i]);
}

static int 
xtensa_coprocessor_register_group (struct reggroup *group)
{
  int i;

  for (i = 0; i < XTENSA_MAX_COPROCESSOR; i++)
    if (group == xtensa_cp[i])
      return i;

  return -1;
}

#define SAVE_REST_FLAGS	(XTENSA_REGISTER_FLAGS_READABLE \
			| XTENSA_REGISTER_FLAGS_WRITABLE \
			| XTENSA_REGISTER_FLAGS_VOLATILE)

#define SAVE_REST_VALID	(XTENSA_REGISTER_FLAGS_READABLE \
			| XTENSA_REGISTER_FLAGS_WRITABLE)

static int
xtensa_register_reggroup_p (struct gdbarch *gdbarch,
			    int regnum,
    			    struct reggroup *group)
{
  xtensa_register_t* reg = &gdbarch_tdep (gdbarch)->regmap[regnum];
  xtensa_register_type_t type = reg->type;
  xtensa_register_group_t rg = reg->group;
  int cp_number;

  if (group == save_reggroup)
    /* Every single register should be included into the list of registers
       to be watched for changes while using -data-list-changed-registers.  */
    return 1;

  /* First, skip registers that are not visible to this target
     (unknown and unmapped registers when not using ISS).  */

  if (type == xtRegisterTypeUnmapped || type == xtRegisterTypeUnknown)
    return 0;
  if (group == all_reggroup)
    return 1;
  if (group == xtensa_ar_reggroup)
    return rg & xtRegisterGroupAddrReg;
  if (group == xtensa_user_reggroup)
    return rg & xtRegisterGroupUser;
  if (group == float_reggroup)
    return rg & xtRegisterGroupFloat;
  if (group == general_reggroup)
    return rg & xtRegisterGroupGeneral;
  if (group == system_reggroup)
    return rg & xtRegisterGroupState;
  if (group == vector_reggroup || group == xtensa_vectra_reggroup)
    return rg & xtRegisterGroupVectra;
  if (group == restore_reggroup)
    return (regnum < gdbarch_num_regs (gdbarch)
	    && (reg->flags & SAVE_REST_FLAGS) == SAVE_REST_VALID);
  cp_number = xtensa_coprocessor_register_group (group);
  if (cp_number >= 0)
    return rg & (xtRegisterGroupCP0 << cp_number);
  else
    return 1;
}


/* Supply register REGNUM from the buffer specified by GREGS and LEN
   in the general-purpose register set REGSET to register cache
   REGCACHE.  If REGNUM is -1 do this for all registers in REGSET.  */

static void
xtensa_supply_gregset (const struct regset *regset,
		       struct regcache *rc,
		       int regnum,
		       const void *gregs,
		       size_t len)
{
  const xtensa_elf_gregset_t *regs = gregs;
  struct gdbarch *gdbarch = get_regcache_arch (rc);
  int i;

  DEBUGTRACE ("xtensa_supply_gregset (..., regnum==%d, ...)\n", regnum);

  if (regnum == gdbarch_pc_regnum (gdbarch) || regnum == -1)
    regcache_raw_supply (rc, gdbarch_pc_regnum (gdbarch), (char *) &regs->pc);
  if (regnum == gdbarch_ps_regnum (gdbarch) || regnum == -1)
    regcache_raw_supply (rc, gdbarch_ps_regnum (gdbarch), (char *) &regs->ps);
  if (regnum == gdbarch_tdep (gdbarch)->wb_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (gdbarch)->wb_regnum,
			 (char *) &regs->windowbase);
  if (regnum == gdbarch_tdep (gdbarch)->ws_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (gdbarch)->ws_regnum,
			 (char *) &regs->windowstart);
  if (regnum == gdbarch_tdep (gdbarch)->lbeg_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (gdbarch)->lbeg_regnum,
			 (char *) &regs->lbeg);
  if (regnum == gdbarch_tdep (gdbarch)->lend_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (gdbarch)->lend_regnum,
			 (char *) &regs->lend);
  if (regnum == gdbarch_tdep (gdbarch)->lcount_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (gdbarch)->lcount_regnum,
			 (char *) &regs->lcount);
  if (regnum == gdbarch_tdep (gdbarch)->sar_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (gdbarch)->sar_regnum,
			 (char *) &regs->sar);
  if (regnum >=gdbarch_tdep (gdbarch)->ar_base
      && regnum < gdbarch_tdep (gdbarch)->ar_base
		    + gdbarch_tdep (gdbarch)->num_aregs)
    regcache_raw_supply (rc, regnum,
			 (char *) &regs->ar[regnum - gdbarch_tdep
			   (gdbarch)->ar_base]);
  else if (regnum == -1)
    {
      for (i = 0; i < gdbarch_tdep (gdbarch)->num_aregs; ++i)
	regcache_raw_supply (rc, gdbarch_tdep (gdbarch)->ar_base + i,
			     (char *) &regs->ar[i]);
    }
}


/* Xtensa register set.  */

static struct regset
xtensa_gregset =
{
  NULL,
  xtensa_supply_gregset
};


/* Return the appropriate register set for the core
   section identified by SECT_NAME and SECT_SIZE.  */

static const struct regset *
xtensa_regset_from_core_section (struct gdbarch *core_arch,
				 const char *sect_name,
				 size_t sect_size)
{
  DEBUGTRACE ("xtensa_regset_from_core_section "
	      "(..., sect_name==\"%s\", sect_size==%x)\n",
	      sect_name, (unsigned int) sect_size);

  if (strcmp (sect_name, ".reg") == 0
      && sect_size >= sizeof(xtensa_elf_gregset_t))
    return &xtensa_gregset;

  return NULL;
}


/* Handling frames.  */

/* Number of registers to save in case of Windowed ABI.  */
#define XTENSA_NUM_SAVED_AREGS		12

/* Frame cache part for Windowed ABI.  */
typedef struct xtensa_windowed_frame_cache
{
  int wb;		/* WINDOWBASE of the previous frame.  */
  int callsize;		/* Call size of this frame.  */
  int ws;		/* WINDOWSTART of the previous frame.  It keeps track of
			   life windows only.  If there is no bit set for the
			   window,  that means it had been already spilled
			   because of window overflow.  */

   /* Addresses of spilled A-registers.
      AREGS[i] == -1, if corresponding AR is alive.  */
  CORE_ADDR aregs[XTENSA_NUM_SAVED_AREGS];
} xtensa_windowed_frame_cache_t;

/* Call0 ABI Definitions.  */

#define C0_MAXOPDS  3	/* Maximum number of operands for prologue
			   analysis.  */
#define C0_NREGS   16	/* Number of A-registers to track.  */
#define C0_CLESV   12	/* Callee-saved registers are here and up.  */
#define C0_SP	    1	/* Register used as SP.  */
#define C0_FP	   15	/* Register used as FP.  */
#define C0_RA	    0	/* Register used as return address.  */
#define C0_ARGS	    2	/* Register used as first arg/retval.  */
#define C0_NARGS    6	/* Number of A-regs for args/retvals.  */

/* Each element of xtensa_call0_frame_cache.c0_rt[] describes for each
   A-register where the current content of the reg came from (in terms
   of an original reg and a constant).  Negative values of c0_rt[n].fp_reg
   mean that the orignal content of the register was saved to the stack.
   c0_rt[n].fr.ofs is NOT the offset from the frame base because we don't 
   know where SP will end up until the entire prologue has been analyzed.  */

#define C0_CONST   -1	/* fr_reg value if register contains a constant.  */
#define C0_INEXP   -2	/* fr_reg value if inexpressible as reg + offset.  */
#define C0_NOSTK   -1	/* to_stk value if register has not been stored.  */

extern xtensa_isa xtensa_default_isa;

typedef struct xtensa_c0reg
{
  int fr_reg;  /* original register from which register content
		  is derived, or C0_CONST, or C0_INEXP.  */
  int fr_ofs;  /* constant offset from reg, or immediate value.  */
  int to_stk;  /* offset from original SP to register (4-byte aligned),
		  or C0_NOSTK if register has not been saved.  */
} xtensa_c0reg_t;

/* Frame cache part for Call0 ABI.  */
typedef struct xtensa_call0_frame_cache
{
  int c0_frmsz;			   /* Stack frame size.  */
  int c0_hasfp;			   /* Current frame uses frame pointer.  */
  int fp_regnum;		   /* A-register used as FP.  */
  int c0_fp;			   /* Actual value of frame pointer.  */
  int c0_fpalign;		   /* Dinamic adjustment for the stack
				      pointer. It's an AND mask. Zero,
				      if alignment was not adjusted.  */
  int c0_old_sp;		   /* In case of dynamic adjustment, it is
				      a register holding unaligned sp. 
				      C0_INEXP, when undefined.  */
  int c0_sp_ofs;		   /* If "c0_old_sp" was spilled it's a
				      stack offset. C0_NOSTK otherwise.  */
					   
  xtensa_c0reg_t c0_rt[C0_NREGS];  /* Register tracking information.  */
} xtensa_call0_frame_cache_t;

typedef struct xtensa_frame_cache
{
  CORE_ADDR base;	/* Stack pointer of this frame.  */
  CORE_ADDR pc;		/* PC of this frame at the function entry point.  */
  CORE_ADDR ra;		/* The raw return address of this frame.  */
  CORE_ADDR ps;		/* The PS register of the previous (older) frame.  */
  CORE_ADDR prev_sp;	/* Stack Pointer of the previous (older) frame.  */
  int call0;		/* It's a call0 framework (else windowed).  */
  union
    {
      xtensa_windowed_frame_cache_t	wd;	/* call0 == false.  */
      xtensa_call0_frame_cache_t       	c0;	/* call0 == true.  */
    };
} xtensa_frame_cache_t;


static struct xtensa_frame_cache *
xtensa_alloc_frame_cache (int windowed)
{
  xtensa_frame_cache_t *cache;
  int i;

  DEBUGTRACE ("xtensa_alloc_frame_cache ()\n");

  cache = FRAME_OBSTACK_ZALLOC (xtensa_frame_cache_t);

  cache->base = 0;
  cache->pc = 0;
  cache->ra = 0;
  cache->ps = 0;
  cache->prev_sp = 0;
  cache->call0 = !windowed;
  if (cache->call0)
    {
      cache->c0.c0_frmsz  = -1;
      cache->c0.c0_hasfp  =  0;
      cache->c0.fp_regnum = -1;
      cache->c0.c0_fp     = -1;
      cache->c0.c0_fpalign =  0;
      cache->c0.c0_old_sp  =  C0_INEXP;
      cache->c0.c0_sp_ofs  =  C0_NOSTK;

      for (i = 0; i < C0_NREGS; i++)
	{
	  cache->c0.c0_rt[i].fr_reg = i;
	  cache->c0.c0_rt[i].fr_ofs = 0;
	  cache->c0.c0_rt[i].to_stk = C0_NOSTK;
	}
    }
  else
    {
      cache->wd.wb = 0;
      cache->wd.ws = 0;
      cache->wd.callsize = -1;

      for (i = 0; i < XTENSA_NUM_SAVED_AREGS; i++)
	cache->wd.aregs[i] = -1;
    }
  return cache;
}


static CORE_ADDR
xtensa_frame_align (struct gdbarch *gdbarch, CORE_ADDR address)
{
  return address & ~15;
}


static CORE_ADDR
xtensa_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  gdb_byte buf[8];
  CORE_ADDR pc;

  DEBUGTRACE ("xtensa_unwind_pc (next_frame = %s)\n", 
		host_address_to_string (next_frame));

  frame_unwind_register (next_frame, gdbarch_pc_regnum (gdbarch), buf);
  pc = extract_typed_address (buf, builtin_type (gdbarch)->builtin_func_ptr);

  DEBUGINFO ("[xtensa_unwind_pc] pc = 0x%08x\n", (unsigned int) pc);

  return pc;
}


static struct frame_id
xtensa_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  CORE_ADDR pc, fp;

  /* THIS-FRAME is a dummy frame.  Return a frame ID of that frame.  */

  pc = get_frame_pc (this_frame);
  fp = get_frame_register_unsigned
	 (this_frame, gdbarch_tdep (gdbarch)->a0_base + 1);

  /* Make dummy frame ID unique by adding a constant.  */
  return frame_id_build (fp + SP_ALIGNMENT, pc);
}

/* Returns true,  if instruction to execute next is unique to Xtensa Window
   Interrupt Handlers.  It can only be one of L32E,  S32E,  RFWO,  or RFWU.  */

static int
xtensa_window_interrupt_insn (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  unsigned int insn = read_memory_integer (pc, 4, byte_order);
  unsigned int code;

  if (byte_order == BFD_ENDIAN_BIG)
    {
      /* Check, if this is L32E or S32E.  */
      code = insn & 0xf000ff00;
      if ((code == 0x00009000) || (code == 0x00009400))
	return 1;
      /* Check, if this is RFWU or RFWO.  */
      code = insn & 0xffffff00;
      return ((code == 0x00430000) || (code == 0x00530000));
    }
  else
    {
      /* Check, if this is L32E or S32E.  */
      code = insn & 0x00ff000f;
      if ((code == 0x090000) || (code == 0x490000))
	return 1;
      /* Check, if this is RFWU or RFWO.  */
      code = insn & 0x00ffffff;
      return ((code == 0x00003400) || (code == 0x00003500));
    }
}

/* Returns the best guess about which register is a frame pointer
   for the function containing CURRENT_PC.  */

#define XTENSA_ISA_BSZ		32		/* Instruction buffer size.  */
#define XTENSA_ISA_BADPC	((CORE_ADDR)0)	/* Bad PC value.  */

static unsigned int
xtensa_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR current_pc)
{
#define RETURN_FP goto done

  unsigned int fp_regnum = gdbarch_tdep (gdbarch)->a0_base + 1;
  CORE_ADDR start_addr;
  xtensa_isa isa;
  xtensa_insnbuf ins, slot;
  gdb_byte ibuf[XTENSA_ISA_BSZ];
  CORE_ADDR ia, bt, ba;
  xtensa_format ifmt;
  int ilen, islots, is;
  xtensa_opcode opc;
  const char *opcname;

  find_pc_partial_function (current_pc, NULL, &start_addr, NULL);
  if (start_addr == 0)
    return fp_regnum;

  if (!xtensa_default_isa)
    xtensa_default_isa = xtensa_isa_init (0, 0);
  isa = xtensa_default_isa;
  gdb_assert (XTENSA_ISA_BSZ >= xtensa_isa_maxlength (isa));
  ins = xtensa_insnbuf_alloc (isa);
  slot = xtensa_insnbuf_alloc (isa);
  ba = 0;

  for (ia = start_addr, bt = ia; ia < current_pc ; ia += ilen)
    {
      if (ia + xtensa_isa_maxlength (isa) > bt)
        {
	  ba = ia;
	  bt = (ba + XTENSA_ISA_BSZ) < current_pc
	    ? ba + XTENSA_ISA_BSZ : current_pc;
	  if (target_read_memory (ba, ibuf, bt - ba) != 0)
	    RETURN_FP;
	}

      xtensa_insnbuf_from_chars (isa, ins, &ibuf[ia-ba], 0);
      ifmt = xtensa_format_decode (isa, ins);
      if (ifmt == XTENSA_UNDEFINED)
	RETURN_FP;
      ilen = xtensa_format_length (isa, ifmt);
      if (ilen == XTENSA_UNDEFINED)
	RETURN_FP;
      islots = xtensa_format_num_slots (isa, ifmt);
      if (islots == XTENSA_UNDEFINED)
	RETURN_FP;
      
      for (is = 0; is < islots; ++is)
	{
	  if (xtensa_format_get_slot (isa, ifmt, is, ins, slot))
	    RETURN_FP;
	  
	  opc = xtensa_opcode_decode (isa, ifmt, is, slot);
	  if (opc == XTENSA_UNDEFINED) 
	    RETURN_FP;
	  
	  opcname = xtensa_opcode_name (isa, opc);

	  if (strcasecmp (opcname, "mov.n") == 0
	      || strcasecmp (opcname, "or") == 0)
	    {
	      unsigned int register_operand;

	      /* Possible candidate for setting frame pointer
		 from A1.  This is what we are looking for.  */

	      if (xtensa_operand_get_field (isa, opc, 1, ifmt, 
					    is, slot, &register_operand) != 0)
		RETURN_FP;
	      if (xtensa_operand_decode (isa, opc, 1, &register_operand) != 0)
		RETURN_FP;
	      if (register_operand == 1)  /* Mov{.n} FP A1.  */
		{
		  if (xtensa_operand_get_field (isa, opc, 0, ifmt, is, slot, 
						&register_operand) != 0)
		    RETURN_FP;
		  if (xtensa_operand_decode (isa, opc, 0,
					     &register_operand) != 0)
		    RETURN_FP;

		  fp_regnum
		    = gdbarch_tdep (gdbarch)->a0_base + register_operand;
		  RETURN_FP;
		}
	    }

	  if (
	      /* We have problems decoding the memory.  */
	      opcname == NULL 
	      || strcasecmp (opcname, "ill") == 0
	      || strcasecmp (opcname, "ill.n") == 0
	      /* Hit planted breakpoint.  */
	      || strcasecmp (opcname, "break") == 0
	      || strcasecmp (opcname, "break.n") == 0
	      /* Flow control instructions finish prologue.  */
	      || xtensa_opcode_is_branch (isa, opc) > 0
	      || xtensa_opcode_is_jump   (isa, opc) > 0
	      || xtensa_opcode_is_loop   (isa, opc) > 0
	      || xtensa_opcode_is_call   (isa, opc) > 0
	      || strcasecmp (opcname, "simcall") == 0
	      || strcasecmp (opcname, "syscall") == 0)
	    /* Can not continue analysis.  */
	    RETURN_FP;
	}
    }
done:
  xtensa_insnbuf_free(isa, slot);
  xtensa_insnbuf_free(isa, ins);
  return fp_regnum;
}

/* The key values to identify the frame using "cache" are 

	cache->base    = SP (or best guess about FP) of this frame;
	cache->pc      = entry-PC (entry point of the frame function);
	cache->prev_sp = SP of the previous frame.  */

static void
call0_frame_cache (struct frame_info *this_frame,
		   xtensa_frame_cache_t *cache, CORE_ADDR pc);

static void
xtensa_window_interrupt_frame_cache (struct frame_info *this_frame,
				     xtensa_frame_cache_t *cache,
				     CORE_ADDR pc);

static struct xtensa_frame_cache *
xtensa_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  xtensa_frame_cache_t *cache;
  CORE_ADDR ra, wb, ws, pc, sp, ps;
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  unsigned int fp_regnum;
  int  windowed, ps_regnum;

  if (*this_cache)
    return *this_cache;

  pc = get_frame_register_unsigned (this_frame, gdbarch_pc_regnum (gdbarch));
  ps_regnum = gdbarch_ps_regnum (gdbarch);
  ps = (ps_regnum >= 0
	? get_frame_register_unsigned (this_frame, ps_regnum) : TX_PS);

  windowed = windowing_enabled (gdbarch, ps);

  /* Get pristine xtensa-frame.  */
  cache = xtensa_alloc_frame_cache (windowed);
  *this_cache = cache;

  if (windowed)
    {
      char op1;

      /* Get WINDOWBASE, WINDOWSTART, and PS registers.  */
      wb = get_frame_register_unsigned (this_frame, 
					gdbarch_tdep (gdbarch)->wb_regnum);
      ws = get_frame_register_unsigned (this_frame,
					gdbarch_tdep (gdbarch)->ws_regnum);

      op1 = read_memory_integer (pc, 1, byte_order);
      if (XTENSA_IS_ENTRY (gdbarch, op1))
	{
	  int callinc = CALLINC (ps);
	  ra = get_frame_register_unsigned
	    (this_frame, gdbarch_tdep (gdbarch)->a0_base + callinc * 4);
	  
	  /* ENTRY hasn't been executed yet, therefore callsize is still 0.  */
	  cache->wd.callsize = 0;
	  cache->wd.wb = wb;
	  cache->wd.ws = ws;
	  cache->prev_sp = get_frame_register_unsigned
			     (this_frame, gdbarch_tdep (gdbarch)->a0_base + 1);

	  /* This only can be the outermost frame since we are
	     just about to execute ENTRY.  SP hasn't been set yet.
	     We can assume any frame size, because it does not
	     matter, and, let's fake frame base in cache.  */
	  cache->base = cache->prev_sp - 16;

	  cache->pc = pc;
	  cache->ra = (cache->pc & 0xc0000000) | (ra & 0x3fffffff);
	  cache->ps = (ps & ~PS_CALLINC_MASK)
	    | ((WINSIZE(ra)/4) << PS_CALLINC_SHIFT);

	  return cache;
	}
      else
	{
	  fp_regnum = xtensa_scan_prologue (gdbarch, pc);
	  ra = get_frame_register_unsigned (this_frame,
					    gdbarch_tdep (gdbarch)->a0_base);
	  cache->wd.callsize = WINSIZE (ra);
	  cache->wd.wb = (wb - cache->wd.callsize / 4)
			  & (gdbarch_tdep (gdbarch)->num_aregs / 4 - 1);
	  cache->wd.ws = ws & ~(1 << wb);

	  cache->pc = get_frame_func (this_frame);
	  cache->ra = (pc & 0xc0000000) | (ra & 0x3fffffff);
	  cache->ps = (ps & ~PS_CALLINC_MASK)
	    | ((WINSIZE(ra)/4) << PS_CALLINC_SHIFT);
	}

      if (cache->wd.ws == 0)
	{
	  int i;

	  /* Set A0...A3.  */
	  sp = get_frame_register_unsigned
	    (this_frame, gdbarch_tdep (gdbarch)->a0_base + 1) - 16;
	  
	  for (i = 0; i < 4; i++, sp += 4)
	    {
	      cache->wd.aregs[i] = sp;
	    }

	  if (cache->wd.callsize > 4)
	    {
	      /* Set A4...A7/A11.  */
	      /* Get the SP of the frame previous to the previous one.
	         To achieve this, we have to dereference SP twice.  */
	      sp = (CORE_ADDR) read_memory_integer (sp - 12, 4, byte_order);
	      sp = (CORE_ADDR) read_memory_integer (sp - 12, 4, byte_order);
	      sp -= cache->wd.callsize * 4;

	      for ( i = 4; i < cache->wd.callsize; i++, sp += 4)
		{
		  cache->wd.aregs[i] = sp;
		}
	    }
	}

      if ((cache->prev_sp == 0) && ( ra != 0 ))
	/* If RA is equal to 0 this frame is an outermost frame.  Leave
	   cache->prev_sp unchanged marking the boundary of the frame stack.  */
	{
	  if ((cache->wd.ws & (1 << cache->wd.wb)) == 0)
	    {
	      /* Register window overflow already happened.
		 We can read caller's SP from the proper spill loction.  */
	      sp = get_frame_register_unsigned
		(this_frame, gdbarch_tdep (gdbarch)->a0_base + 1);
	      cache->prev_sp = read_memory_integer (sp - 12, 4, byte_order);
	    }
	  else
	    {
	      /* Read caller's frame SP directly from the previous window.  */
	      int regnum = arreg_number
			     (gdbarch, gdbarch_tdep (gdbarch)->a0_base + 1,
			      cache->wd.wb);

	      cache->prev_sp = xtensa_read_register (regnum);
	    }
	}
    }
  else if (xtensa_window_interrupt_insn (gdbarch, pc))
    {
      /* Execution stopped inside Xtensa Window Interrupt Handler.  */

      xtensa_window_interrupt_frame_cache (this_frame, cache, pc);
      /* Everything was set already,  including cache->base.  */
      return cache;
    }
  else	/* Call0 framework.  */
    {
      call0_frame_cache (this_frame, cache, pc);  
      fp_regnum = cache->c0.fp_regnum;
    }

  cache->base = get_frame_register_unsigned (this_frame, fp_regnum);

  return cache;
}

static int xtensa_session_once_reported = 1;

/* Report a problem with prologue analysis while doing backtracing.
   But, do it only once to avoid annoyng repeated messages.  */

static void
warning_once (void)
{
  if (xtensa_session_once_reported == 0)
    warning (_("\
\nUnrecognised function prologue. Stack trace cannot be resolved. \
This message will not be repeated in this session.\n"));

  xtensa_session_once_reported = 1;
}


static void
xtensa_frame_this_id (struct frame_info *this_frame,
		      void **this_cache,
		      struct frame_id *this_id)
{
  struct xtensa_frame_cache *cache =
    xtensa_frame_cache (this_frame, this_cache);

  if (cache->prev_sp == 0)
    return;

  (*this_id) = frame_id_build (cache->prev_sp, cache->pc);
}

static struct value *
xtensa_frame_prev_register (struct frame_info *this_frame,
			    void **this_cache,
			    int regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct xtensa_frame_cache *cache;
  ULONGEST saved_reg = 0;
  int done = 1;

  if (*this_cache == NULL)
    *this_cache = xtensa_frame_cache (this_frame, this_cache);
  cache = *this_cache;

  if (regnum ==gdbarch_pc_regnum (gdbarch))
    saved_reg = cache->ra;
  else if (regnum == gdbarch_tdep (gdbarch)->a0_base + 1)
    saved_reg = cache->prev_sp;
  else if (!cache->call0)
    {
      if (regnum == gdbarch_tdep (gdbarch)->ws_regnum)
	saved_reg = cache->wd.ws;
      else if (regnum == gdbarch_tdep (gdbarch)->wb_regnum)
	saved_reg = cache->wd.wb;
      else if (regnum == gdbarch_ps_regnum (gdbarch))
	saved_reg = cache->ps;
      else
	done = 0;
    }
  else
    done = 0;

  if (done)
    return frame_unwind_got_constant (this_frame, regnum, saved_reg);

  if (!cache->call0) /* Windowed ABI.  */
    {
      /* Convert A-register numbers to AR-register numbers,
	 if we deal with A-register.  */
      if (regnum >= gdbarch_tdep (gdbarch)->a0_base
          && regnum <= gdbarch_tdep (gdbarch)->a0_base + 15)
	regnum = arreg_number (gdbarch, regnum, cache->wd.wb);

      /* Check, if we deal with AR-register saved on stack.  */
      if (regnum >= gdbarch_tdep (gdbarch)->ar_base
	  && regnum <= (gdbarch_tdep (gdbarch)->ar_base
			 + gdbarch_tdep (gdbarch)->num_aregs))
	{
	  int areg = areg_number (gdbarch, regnum, cache->wd.wb);

	  if (areg >= 0
	      && areg < XTENSA_NUM_SAVED_AREGS
	      && cache->wd.aregs[areg] != -1)
	    return frame_unwind_got_memory (this_frame, regnum,
					    cache->wd.aregs[areg]);
	}
    }
  else /* Call0 ABI.  */
    {
      int reg = (regnum >= gdbarch_tdep (gdbarch)->ar_base
		&& regnum <= (gdbarch_tdep (gdbarch)->ar_base
			       + C0_NREGS))
		  ? regnum - gdbarch_tdep (gdbarch)->ar_base : regnum;

      if (reg < C0_NREGS)
	{
	  CORE_ADDR spe;
	  int stkofs;

	  /* If register was saved in the prologue, retrieve it.  */
	  stkofs = cache->c0.c0_rt[reg].to_stk;
	  if (stkofs != C0_NOSTK)
	    {
	      /* Determine SP on entry based on FP.  */
	      spe = cache->c0.c0_fp
		- cache->c0.c0_rt[cache->c0.fp_regnum].fr_ofs;

	      return frame_unwind_got_memory (this_frame, regnum,
					      spe + stkofs);
	    }
	}
    }

  /* All other registers have been either saved to
     the stack or are still alive in the processor.  */

  return frame_unwind_got_register (this_frame, regnum, regnum);
}


static const struct frame_unwind
xtensa_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  xtensa_frame_this_id,
  xtensa_frame_prev_register,
  NULL,
  default_frame_sniffer
};

static CORE_ADDR
xtensa_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct xtensa_frame_cache *cache =
    xtensa_frame_cache (this_frame, this_cache);

  return cache->base;
}

static const struct frame_base
xtensa_frame_base =
{
  &xtensa_unwind,
  xtensa_frame_base_address,
  xtensa_frame_base_address,
  xtensa_frame_base_address
};


static void
xtensa_extract_return_value (struct type *type,
			     struct regcache *regcache,
			     void *dst)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  bfd_byte *valbuf = dst;
  int len = TYPE_LENGTH (type);
  ULONGEST pc, wb;
  int callsize, areg;
  int offset = 0;

  DEBUGTRACE ("xtensa_extract_return_value (...)\n");

  gdb_assert(len > 0);

  if (gdbarch_tdep (gdbarch)->call_abi != CallAbiCall0Only)
    {
      /* First, we have to find the caller window in the register file.  */
      regcache_raw_read_unsigned (regcache, gdbarch_pc_regnum (gdbarch), &pc);
      callsize = extract_call_winsize (gdbarch, pc);

      /* On Xtensa, we can return up to 4 words (or 2 for call12).  */
      if (len > (callsize > 8 ? 8 : 16))
	internal_error (__FILE__, __LINE__,
			_("cannot extract return value of %d bytes long"),
			len);

      /* Get the register offset of the return
	 register (A2) in the caller window.  */
      regcache_raw_read_unsigned
	(regcache, gdbarch_tdep (gdbarch)->wb_regnum, &wb);
      areg = arreg_number (gdbarch,
			  gdbarch_tdep (gdbarch)->a0_base + 2 + callsize, wb);
    }
  else
    {
      /* No windowing hardware - Call0 ABI.  */
      areg = gdbarch_tdep (gdbarch)->a0_base + C0_ARGS;
    }

  DEBUGINFO ("[xtensa_extract_return_value] areg %d len %d\n", areg, len);

  if (len < 4 && gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    offset = 4 - len;

  for (; len > 0; len -= 4, areg++, valbuf += 4)
    {
      if (len < 4)
	regcache_raw_read_part (regcache, areg, offset, len, valbuf);
      else
	regcache_raw_read (regcache, areg, valbuf);
    }
}


static void
xtensa_store_return_value (struct type *type,
			   struct regcache *regcache,
			   const void *dst)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  const bfd_byte *valbuf = dst;
  unsigned int areg;
  ULONGEST pc, wb;
  int callsize;
  int len = TYPE_LENGTH (type);
  int offset = 0;

  DEBUGTRACE ("xtensa_store_return_value (...)\n");

  if (gdbarch_tdep (gdbarch)->call_abi != CallAbiCall0Only)
    {
      regcache_raw_read_unsigned 
	(regcache, gdbarch_tdep (gdbarch)->wb_regnum, &wb);
      regcache_raw_read_unsigned (regcache, gdbarch_pc_regnum (gdbarch), &pc);
      callsize = extract_call_winsize (gdbarch, pc);

      if (len > (callsize > 8 ? 8 : 16))
	internal_error (__FILE__, __LINE__,
			_("unimplemented for this length: %d"),
			TYPE_LENGTH (type));
      areg = arreg_number (gdbarch,
			   gdbarch_tdep (gdbarch)->a0_base + 2 + callsize, wb);

      DEBUGTRACE ("[xtensa_store_return_value] callsize %d wb %d\n",
              callsize, (int) wb);
    }
  else
    {
      areg = gdbarch_tdep (gdbarch)->a0_base + C0_ARGS;
    }

  if (len < 4 && gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    offset = 4 - len;

  for (; len > 0; len -= 4, areg++, valbuf += 4)
    {
      if (len < 4)
	regcache_raw_write_part (regcache, areg, offset, len, valbuf);
      else
	regcache_raw_write (regcache, areg, valbuf);
    }
}


static enum return_value_convention
xtensa_return_value (struct gdbarch *gdbarch,
		     struct value *function,
		     struct type *valtype,
		     struct regcache *regcache,
		     gdb_byte *readbuf,
		     const gdb_byte *writebuf)
{
  /* Structures up to 16 bytes are returned in registers.  */

  int struct_return = ((TYPE_CODE (valtype) == TYPE_CODE_STRUCT
			|| TYPE_CODE (valtype) == TYPE_CODE_UNION
			|| TYPE_CODE (valtype) == TYPE_CODE_ARRAY)
		       && TYPE_LENGTH (valtype) > 16);

  if (struct_return)
    return RETURN_VALUE_STRUCT_CONVENTION;

  DEBUGTRACE ("xtensa_return_value(...)\n");

  if (writebuf != NULL)
    {
      xtensa_store_return_value (valtype, regcache, writebuf);
    }

  if (readbuf != NULL)
    {
      gdb_assert (!struct_return);
      xtensa_extract_return_value (valtype, regcache, readbuf);
    }
  return RETURN_VALUE_REGISTER_CONVENTION;
}


/* DUMMY FRAME */

static CORE_ADDR
xtensa_push_dummy_call (struct gdbarch *gdbarch,
			struct value *function,
			struct regcache *regcache,
			CORE_ADDR bp_addr,
			int nargs,
			struct value **args,
			CORE_ADDR sp,
			int struct_return,
			CORE_ADDR struct_addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int i;
  int size, onstack_size;
  gdb_byte *buf = (gdb_byte *) alloca (16);
  CORE_ADDR ra, ps;
  struct argument_info
  {
    const bfd_byte *contents;
    int length;
    int onstack;		/* onstack == 0 => in reg */
    int align;			/* alignment */
    union
    {
      int offset;		/* stack offset if on stack.  */
      int regno;		/* regno if in register.  */
    } u;
  };

  struct argument_info *arg_info =
    (struct argument_info *) alloca (nargs * sizeof (struct argument_info));

  CORE_ADDR osp = sp;

  DEBUGTRACE ("xtensa_push_dummy_call (...)\n");

  if (xtensa_debug_level > 3)
    {
      int i;
      DEBUGINFO ("[xtensa_push_dummy_call] nargs = %d\n", nargs);
      DEBUGINFO ("[xtensa_push_dummy_call] sp=0x%x, struct_return=%d, "
		 "struct_addr=0x%x\n",
		 (int) sp, (int) struct_return, (int) struct_addr);

      for (i = 0; i < nargs; i++)
        {
	  struct value *arg = args[i];
	  struct type *arg_type = check_typedef (value_type (arg));
	  fprintf_unfiltered (gdb_stdlog, "%2d: %s %3d ", i,
			      host_address_to_string (arg),
			      TYPE_LENGTH (arg_type));
	  switch (TYPE_CODE (arg_type))
	    {
	    case TYPE_CODE_INT:
	      fprintf_unfiltered (gdb_stdlog, "int");
	      break;
	    case TYPE_CODE_STRUCT:
	      fprintf_unfiltered (gdb_stdlog, "struct");
	      break;
	    default:
	      fprintf_unfiltered (gdb_stdlog, "%3d", TYPE_CODE (arg_type));
	      break;
	    }
	  fprintf_unfiltered (gdb_stdlog, " %s\n",
			      host_address_to_string (value_contents (arg)));
	}
    }

  /* First loop: collect information.
     Cast into type_long.  (This shouldn't happen often for C because
     GDB already does this earlier.)  It's possible that GDB could
     do it all the time but it's harmless to leave this code here.  */

  size = 0;
  onstack_size = 0;
  i = 0;

  if (struct_return)
    size = REGISTER_SIZE;

  for (i = 0; i < nargs; i++)
    {
      struct argument_info *info = &arg_info[i];
      struct value *arg = args[i];
      struct type *arg_type = check_typedef (value_type (arg));

      switch (TYPE_CODE (arg_type))
	{
	case TYPE_CODE_INT:
	case TYPE_CODE_BOOL:
	case TYPE_CODE_CHAR:
	case TYPE_CODE_RANGE:
	case TYPE_CODE_ENUM:

	  /* Cast argument to long if necessary as the mask does it too.  */
	  if (TYPE_LENGTH (arg_type)
	      < TYPE_LENGTH (builtin_type (gdbarch)->builtin_long))
	    {
	      arg_type = builtin_type (gdbarch)->builtin_long;
	      arg = value_cast (arg_type, arg);
	    }
	  /* Aligment is equal to the type length for the basic types.  */
	  info->align = TYPE_LENGTH (arg_type);
	  break;

	case TYPE_CODE_FLT:

	  /* Align doubles correctly.  */
	  if (TYPE_LENGTH (arg_type)
	      == TYPE_LENGTH (builtin_type (gdbarch)->builtin_double))
	    info->align = TYPE_LENGTH (builtin_type (gdbarch)->builtin_double);
	  else
	    info->align = TYPE_LENGTH (builtin_type (gdbarch)->builtin_long);
	  break;

	case TYPE_CODE_STRUCT:
	default:
	  info->align = TYPE_LENGTH (builtin_type (gdbarch)->builtin_long);
	  break;
	}
      info->length = TYPE_LENGTH (arg_type);
      info->contents = value_contents (arg);

      /* Align size and onstack_size.  */
      size = (size + info->align - 1) & ~(info->align - 1);
      onstack_size = (onstack_size + info->align - 1) & ~(info->align - 1);

      if (size + info->length > REGISTER_SIZE * ARG_NOF (gdbarch))
	{
	  info->onstack = 1;
	  info->u.offset = onstack_size;
	  onstack_size += info->length;
	}
      else
	{
	  info->onstack = 0;
	  info->u.regno = ARG_1ST (gdbarch) + size / REGISTER_SIZE;
	}
      size += info->length;
    }

  /* Adjust the stack pointer and align it.  */
  sp = align_down (sp - onstack_size, SP_ALIGNMENT);

  /* Simulate MOVSP, if Windowed ABI.  */
  if ((gdbarch_tdep (gdbarch)->call_abi != CallAbiCall0Only)
      && (sp != osp))
    {
      read_memory (osp - 16, buf, 16);
      write_memory (sp - 16, buf, 16);
    }

  /* Second Loop: Load arguments.  */

  if (struct_return)
    {
      store_unsigned_integer (buf, REGISTER_SIZE, byte_order, struct_addr);
      regcache_cooked_write (regcache, ARG_1ST (gdbarch), buf);
    }

  for (i = 0; i < nargs; i++)
    {
      struct argument_info *info = &arg_info[i];

      if (info->onstack)
	{
	  int n = info->length;
	  CORE_ADDR offset = sp + info->u.offset;

	  /* Odd-sized structs are aligned to the lower side of a memory
	     word in big-endian mode and require a shift.  This only
	     applies for structures smaller than one word.  */

	  if (n < REGISTER_SIZE
	      && gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	    offset += (REGISTER_SIZE - n);

	  write_memory (offset, info->contents, info->length);

	}
      else
	{
	  int n = info->length;
	  const bfd_byte *cp = info->contents;
	  int r = info->u.regno;

	  /* Odd-sized structs are aligned to the lower side of registers in
	     big-endian mode and require a shift.  The odd-sized leftover will
	     be at the end.  Note that this is only true for structures smaller
	     than REGISTER_SIZE; for larger odd-sized structures the excess
	     will be left-aligned in the register on both endiannesses.  */

	  if (n < REGISTER_SIZE && byte_order == BFD_ENDIAN_BIG)
	    {
	      ULONGEST v;
	      v = extract_unsigned_integer (cp, REGISTER_SIZE, byte_order);
	      v = v >> ((REGISTER_SIZE - n) * TARGET_CHAR_BIT);

	      store_unsigned_integer (buf, REGISTER_SIZE, byte_order, v);
	      regcache_cooked_write (regcache, r, buf);

	      cp += REGISTER_SIZE;
	      n -= REGISTER_SIZE;
	      r++;
	    }
	  else
	    while (n > 0)
	      {
		regcache_cooked_write (regcache, r, cp);

		cp += REGISTER_SIZE;
		n -= REGISTER_SIZE;
		r++;
	      }
	}
    }

  /* Set the return address of dummy frame to the dummy address.
     The return address for the current function (in A0) is
     saved in the dummy frame, so we can savely overwrite A0 here.  */

  if (gdbarch_tdep (gdbarch)->call_abi != CallAbiCall0Only)
    {
      ULONGEST val;

      ra = (bp_addr & 0x3fffffff) | 0x40000000;
      regcache_raw_read_unsigned (regcache, gdbarch_ps_regnum (gdbarch), &val);
      ps = (unsigned long) val & ~0x00030000;
      regcache_cooked_write_unsigned
	(regcache, gdbarch_tdep (gdbarch)->a0_base + 4, ra);
      regcache_cooked_write_unsigned (regcache,
				      gdbarch_ps_regnum (gdbarch),
				      ps | 0x00010000);

      /* All the registers have been saved.  After executing
	 dummy call, they all will be restored.  So it's safe
	 to modify WINDOWSTART register to make it look like there
	 is only one register window corresponding to WINDOWEBASE.  */

      regcache_raw_read (regcache, gdbarch_tdep (gdbarch)->wb_regnum, buf);
      regcache_cooked_write_unsigned
	(regcache, gdbarch_tdep (gdbarch)->ws_regnum,
	 1 << extract_unsigned_integer (buf, 4, byte_order));
    }
  else
    {
      /* Simulate CALL0: write RA into A0 register.  */
      regcache_cooked_write_unsigned
	(regcache, gdbarch_tdep (gdbarch)->a0_base, bp_addr);
    }

  /* Set new stack pointer and return it.  */
  regcache_cooked_write_unsigned (regcache,
				  gdbarch_tdep (gdbarch)->a0_base + 1, sp);
  /* Make dummy frame ID unique by adding a constant.  */
  return sp + SP_ALIGNMENT;
}


/* Return a breakpoint for the current location of PC.  We always use
   the density version if we have density instructions (regardless of the
   current instruction at PC), and use regular instructions otherwise.  */

#define BIG_BREAKPOINT { 0x00, 0x04, 0x00 }
#define LITTLE_BREAKPOINT { 0x00, 0x40, 0x00 }
#define DENSITY_BIG_BREAKPOINT { 0xd2, 0x0f }
#define DENSITY_LITTLE_BREAKPOINT { 0x2d, 0xf0 }

static const unsigned char *
xtensa_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr,
			   int *lenptr)
{
  static unsigned char big_breakpoint[] = BIG_BREAKPOINT;
  static unsigned char little_breakpoint[] = LITTLE_BREAKPOINT;
  static unsigned char density_big_breakpoint[] = DENSITY_BIG_BREAKPOINT;
  static unsigned char density_little_breakpoint[] = DENSITY_LITTLE_BREAKPOINT;

  DEBUGTRACE ("xtensa_breakpoint_from_pc (pc = 0x%08x)\n", (int) *pcptr);

  if (gdbarch_tdep (gdbarch)->isa_use_density_instructions)
    {
      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	{
	  *lenptr = sizeof (density_big_breakpoint);
	  return density_big_breakpoint;
	}
      else
	{
	  *lenptr = sizeof (density_little_breakpoint);
	  return density_little_breakpoint;
	}
    }
  else
    {
      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	{
	  *lenptr = sizeof (big_breakpoint);
	  return big_breakpoint;
	}
      else
	{
	  *lenptr = sizeof (little_breakpoint);
	  return little_breakpoint;
	}
    }
}

/* Call0 ABI support routines.  */

/* Return true, if PC points to "ret" or "ret.n".  */ 

static int
call0_ret (CORE_ADDR start_pc, CORE_ADDR finish_pc)
{
#define RETURN_RET goto done
  xtensa_isa isa;
  xtensa_insnbuf ins, slot;
  gdb_byte ibuf[XTENSA_ISA_BSZ];
  CORE_ADDR ia, bt, ba;
  xtensa_format ifmt;
  int ilen, islots, is;
  xtensa_opcode opc;
  const char *opcname;
  int found_ret = 0;

  isa = xtensa_default_isa;
  gdb_assert (XTENSA_ISA_BSZ >= xtensa_isa_maxlength (isa));
  ins = xtensa_insnbuf_alloc (isa);
  slot = xtensa_insnbuf_alloc (isa);
  ba = 0;

  for (ia = start_pc, bt = ia; ia < finish_pc ; ia += ilen)
    {
      if (ia + xtensa_isa_maxlength (isa) > bt)
        {
	  ba = ia;
	  bt = (ba + XTENSA_ISA_BSZ) < finish_pc
	    ? ba + XTENSA_ISA_BSZ : finish_pc;
	  if (target_read_memory (ba, ibuf, bt - ba) != 0 )
	    RETURN_RET;
	}

      xtensa_insnbuf_from_chars (isa, ins, &ibuf[ia-ba], 0);
      ifmt = xtensa_format_decode (isa, ins);
      if (ifmt == XTENSA_UNDEFINED)
	RETURN_RET;
      ilen = xtensa_format_length (isa, ifmt);
      if (ilen == XTENSA_UNDEFINED)
	RETURN_RET;
      islots = xtensa_format_num_slots (isa, ifmt);
      if (islots == XTENSA_UNDEFINED)
	RETURN_RET;
      
      for (is = 0; is < islots; ++is)
	{
	  if (xtensa_format_get_slot (isa, ifmt, is, ins, slot))
	    RETURN_RET;
	  
	  opc = xtensa_opcode_decode (isa, ifmt, is, slot);
	  if (opc == XTENSA_UNDEFINED) 
	    RETURN_RET;
	  
	  opcname = xtensa_opcode_name (isa, opc);
	  
	  if ((strcasecmp (opcname, "ret.n") == 0)
	      || (strcasecmp (opcname, "ret") == 0))
	    {
	      found_ret = 1;
	      RETURN_RET;
	    }
	}
    }
 done:
  xtensa_insnbuf_free(isa, slot);
  xtensa_insnbuf_free(isa, ins);
  return found_ret;
}

/* Call0 opcode class.  Opcodes are preclassified according to what they
   mean for Call0 prologue analysis, and their number of significant operands.
   The purpose of this is to simplify prologue analysis by separating 
   instruction decoding (libisa) from the semantics of prologue analysis.  */

typedef enum
{
  c0opc_illegal,       /* Unknown to libisa (invalid) or 'ill' opcode.  */
  c0opc_uninteresting, /* Not interesting for Call0 prologue analysis.  */
  c0opc_flow,	       /* Flow control insn.  */
  c0opc_entry,	       /* ENTRY indicates non-Call0 prologue.  */
  c0opc_break,	       /* Debugger software breakpoints.  */
  c0opc_add,	       /* Adding two registers.  */
  c0opc_addi,	       /* Adding a register and an immediate.  */
  c0opc_and,	       /* Bitwise "and"-ing two registers.  */
  c0opc_sub,	       /* Subtracting a register from a register.  */
  c0opc_mov,	       /* Moving a register to a register.  */
  c0opc_movi,	       /* Moving an immediate to a register.  */
  c0opc_l32r,	       /* Loading a literal.  */
  c0opc_s32i,	       /* Storing word at fixed offset from a base register.  */
  c0opc_rwxsr,	       /* RSR, WRS, or XSR instructions.  */
  c0opc_l32e,          /* L32E instruction.  */
  c0opc_s32e,          /* S32E instruction.  */
  c0opc_rfwo,          /* RFWO instruction.  */
  c0opc_rfwu,          /* RFWU instruction.  */
  c0opc_NrOf	       /* Number of opcode classifications.  */
} xtensa_insn_kind;

/* Return true,  if OPCNAME is RSR,  WRS,  or XSR instruction.  */

static int
rwx_special_register (const char *opcname)
{
  char ch = *opcname++;
  
  if ((ch != 'r') && (ch != 'w') && (ch != 'x'))
    return 0;
  if (*opcname++ != 's')
    return 0;
  if (*opcname++ != 'r')
    return 0;
  if (*opcname++ != '.')
    return 0;

  return 1;
}

/* Classify an opcode based on what it means for Call0 prologue analysis.  */

static xtensa_insn_kind
call0_classify_opcode (xtensa_isa isa, xtensa_opcode opc)
{
  const char *opcname;
  xtensa_insn_kind opclass = c0opc_uninteresting;

  DEBUGTRACE ("call0_classify_opcode (..., opc = %d)\n", opc);

  /* Get opcode name and handle special classifications.  */

  opcname = xtensa_opcode_name (isa, opc);

  if (opcname == NULL 
      || strcasecmp (opcname, "ill") == 0
      || strcasecmp (opcname, "ill.n") == 0)
    opclass = c0opc_illegal;
  else if (strcasecmp (opcname, "break") == 0
	   || strcasecmp (opcname, "break.n") == 0)
     opclass = c0opc_break;
  else if (strcasecmp (opcname, "entry") == 0)
    opclass = c0opc_entry;
  else if (strcasecmp (opcname, "rfwo") == 0)
    opclass = c0opc_rfwo;
  else if (strcasecmp (opcname, "rfwu") == 0)
    opclass = c0opc_rfwu;
  else if (xtensa_opcode_is_branch (isa, opc) > 0
	   || xtensa_opcode_is_jump   (isa, opc) > 0
	   || xtensa_opcode_is_loop   (isa, opc) > 0
	   || xtensa_opcode_is_call   (isa, opc) > 0
	   || strcasecmp (opcname, "simcall") == 0
	   || strcasecmp (opcname, "syscall") == 0)
    opclass = c0opc_flow;

  /* Also, classify specific opcodes that need to be tracked.  */
  else if (strcasecmp (opcname, "add") == 0 
	   || strcasecmp (opcname, "add.n") == 0)
    opclass = c0opc_add;
  else if (strcasecmp (opcname, "and") == 0)
    opclass = c0opc_and;
  else if (strcasecmp (opcname, "addi") == 0 
	   || strcasecmp (opcname, "addi.n") == 0
	   || strcasecmp (opcname, "addmi") == 0)
    opclass = c0opc_addi;
  else if (strcasecmp (opcname, "sub") == 0)
    opclass = c0opc_sub;
  else if (strcasecmp (opcname, "mov.n") == 0
	   || strcasecmp (opcname, "or") == 0) /* Could be 'mov' asm macro.  */
    opclass = c0opc_mov;
  else if (strcasecmp (opcname, "movi") == 0 
	   || strcasecmp (opcname, "movi.n") == 0)
    opclass = c0opc_movi;
  else if (strcasecmp (opcname, "l32r") == 0)
    opclass = c0opc_l32r;
  else if (strcasecmp (opcname, "s32i") == 0 
	   || strcasecmp (opcname, "s32i.n") == 0)
    opclass = c0opc_s32i;
  else if (strcasecmp (opcname, "l32e") == 0)
    opclass = c0opc_l32e;
  else if (strcasecmp (opcname, "s32e") == 0)
    opclass = c0opc_s32e;
  else if (rwx_special_register (opcname))
    opclass = c0opc_rwxsr;

  return opclass;
}

/* Tracks register movement/mutation for a given operation, which may
   be within a bundle.  Updates the destination register tracking info
   accordingly.  The pc is needed only for pc-relative load instructions
   (eg. l32r).  The SP register number is needed to identify stores to
   the stack frame.  Returns 0, if analysis was succesfull, non-zero
   otherwise.  */

static int
call0_track_op (struct gdbarch *gdbarch, xtensa_c0reg_t dst[], xtensa_c0reg_t src[],
		xtensa_insn_kind opclass, int nods, unsigned odv[],
		CORE_ADDR pc, int spreg, xtensa_frame_cache_t *cache)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  unsigned litbase, litaddr, litval;

  switch (opclass)
    {
    case c0opc_addi:
      /* 3 operands: dst, src, imm.  */
      gdb_assert (nods == 3);
      dst[odv[0]].fr_reg = src[odv[1]].fr_reg;
      dst[odv[0]].fr_ofs = src[odv[1]].fr_ofs + odv[2];
      break;
    case c0opc_add:
      /* 3 operands: dst, src1, src2.  */
      gdb_assert (nods == 3); 
      if      (src[odv[1]].fr_reg == C0_CONST)
        {
	  dst[odv[0]].fr_reg = src[odv[2]].fr_reg;
	  dst[odv[0]].fr_ofs = src[odv[2]].fr_ofs + src[odv[1]].fr_ofs;
	}
      else if (src[odv[2]].fr_reg == C0_CONST)
        {
	  dst[odv[0]].fr_reg = src[odv[1]].fr_reg;
	  dst[odv[0]].fr_ofs = src[odv[1]].fr_ofs + src[odv[2]].fr_ofs;
	}
      else dst[odv[0]].fr_reg = C0_INEXP;
      break;
    case c0opc_and:
      /* 3 operands:  dst, src1, src2.  */
      gdb_assert (nods == 3);
      if (cache->c0.c0_fpalign == 0)
	{
	  /* Handle dynamic stack alignment.  */
	  if ((src[odv[0]].fr_reg == spreg) && (src[odv[1]].fr_reg == spreg))
	    {
	      if (src[odv[2]].fr_reg == C0_CONST)
		cache->c0.c0_fpalign = src[odv[2]].fr_ofs;
	      break;
	    }
	  else if ((src[odv[0]].fr_reg == spreg)
		   && (src[odv[2]].fr_reg == spreg))
	    {
	      if (src[odv[1]].fr_reg == C0_CONST)
		cache->c0.c0_fpalign = src[odv[1]].fr_ofs;
	      break;
	    }
	  /* else fall through.  */
	}
      if      (src[odv[1]].fr_reg == C0_CONST)
        {
	  dst[odv[0]].fr_reg = src[odv[2]].fr_reg;
	  dst[odv[0]].fr_ofs = src[odv[2]].fr_ofs & src[odv[1]].fr_ofs;
	}
      else if (src[odv[2]].fr_reg == C0_CONST)
        {
	  dst[odv[0]].fr_reg = src[odv[1]].fr_reg;
	  dst[odv[0]].fr_ofs = src[odv[1]].fr_ofs & src[odv[2]].fr_ofs;
	}
      else dst[odv[0]].fr_reg = C0_INEXP;
      break;
    case c0opc_sub:
      /* 3 operands: dst, src1, src2.  */
      gdb_assert (nods == 3);
      if      (src[odv[2]].fr_reg == C0_CONST)
        {
	  dst[odv[0]].fr_reg = src[odv[1]].fr_reg;
	  dst[odv[0]].fr_ofs = src[odv[1]].fr_ofs - src[odv[2]].fr_ofs;
	}
      else dst[odv[0]].fr_reg = C0_INEXP;
      break;
    case c0opc_mov:
      /* 2 operands: dst, src [, src].  */
      gdb_assert (nods == 2);
      /* First, check if it's a special case of saving unaligned SP
	 to a spare register in case of dynamic stack adjustment.
	 But, only do it one time.  The second time could be initializing
	 frame pointer.  We don't want to overwrite the first one.  */
      if ((odv[1] == spreg) && (cache->c0.c0_old_sp == C0_INEXP))
	cache->c0.c0_old_sp = odv[0];

      dst[odv[0]].fr_reg = src[odv[1]].fr_reg;
      dst[odv[0]].fr_ofs = src[odv[1]].fr_ofs;
      break;
    case c0opc_movi:
      /* 2 operands: dst, imm.  */
      gdb_assert (nods == 2);
      dst[odv[0]].fr_reg = C0_CONST;
      dst[odv[0]].fr_ofs = odv[1];
      break;
    case c0opc_l32r:
      /* 2 operands: dst, literal offset.  */
      gdb_assert (nods == 2);
      /* litbase = xtensa_get_litbase (pc);  can be also used.  */
      litbase = (gdbarch_tdep (gdbarch)->litbase_regnum == -1)
	? 0 : xtensa_read_register
		(gdbarch_tdep (gdbarch)->litbase_regnum);
      litaddr = litbase & 1
		  ? (litbase & ~1) + (signed)odv[1]
		  : (pc + 3  + (signed)odv[1]) & ~3;
      litval = read_memory_integer (litaddr, 4, byte_order);
      dst[odv[0]].fr_reg = C0_CONST;
      dst[odv[0]].fr_ofs = litval;
      break;
    case c0opc_s32i:
      /* 3 operands: value, base, offset.  */
      gdb_assert (nods == 3 && spreg >= 0 && spreg < C0_NREGS);
      /* First, check if it's a spill for saved unaligned SP,
	 when dynamic stack adjustment was applied to this frame.  */
      if ((cache->c0.c0_fpalign != 0)		/* Dynamic stack adjustment.  */
	  && (odv[1] == spreg)			/* SP usage indicates spill.  */
	  && (odv[0] == cache->c0.c0_old_sp))	/* Old SP register spilled.  */
	cache->c0.c0_sp_ofs = odv[2];

      if (src[odv[1]].fr_reg == spreg	     /* Store to stack frame.  */
	  && (src[odv[1]].fr_ofs & 3) == 0   /* Alignment preserved.  */
	  &&  src[odv[0]].fr_reg >= 0	     /* Value is from a register.  */
	  &&  src[odv[0]].fr_ofs == 0	     /* Value hasn't been modified.  */
	  &&  src[src[odv[0]].fr_reg].to_stk == C0_NOSTK) /* First time.  */
        {
	  /* ISA encoding guarantees alignment.  But, check it anyway.  */
	  gdb_assert ((odv[2] & 3) == 0);
	  dst[src[odv[0]].fr_reg].to_stk = src[odv[1]].fr_ofs + odv[2];
	}
      break;
      /* If we end up inside Window Overflow / Underflow interrupt handler
	 report an error because these handlers should have been handled
	 already in a different way.  */
    case c0opc_l32e:
    case c0opc_s32e:
    case c0opc_rfwo:
    case c0opc_rfwu:
      return 1;
    default:
      return 1;
    }
  return 0;
}

/* Analyze prologue of the function at start address to determine if it uses
   the Call0 ABI, and if so track register moves and linear modifications
   in the prologue up to the PC or just beyond the prologue, whichever is
   first. An 'entry' instruction indicates non-Call0 ABI and the end of the
   prologue. The prologue may overlap non-prologue instructions but is
   guaranteed to end by the first flow-control instruction (jump, branch,
   call or return).  Since an optimized function may move information around
   and change the stack frame arbitrarily during the prologue, the information
   is guaranteed valid only at the point in the function indicated by the PC.
   May be used to skip the prologue or identify the ABI, w/o tracking.

   Returns:   Address of first instruction after prologue, or PC (whichever 
	      is first), or 0, if decoding failed (in libisa).
   Input args:
      start   Start address of function/prologue.
      pc      Program counter to stop at.  Use 0 to continue to end of prologue.
	      If 0, avoids infinite run-on in corrupt code memory by bounding
	      the scan to the end of the function if that can be determined.
      nregs   Number of general registers to track.
   InOut args:
      cache   Xtensa frame cache.

      Note that these may produce useful results even if decoding fails
      because they begin with default assumptions that analysis may change.  */

static CORE_ADDR
call0_analyze_prologue (struct gdbarch *gdbarch,
			CORE_ADDR start, CORE_ADDR pc,
			int nregs, xtensa_frame_cache_t *cache)
{
  CORE_ADDR ia;		    /* Current insn address in prologue.  */
  CORE_ADDR ba = 0;	    /* Current address at base of insn buffer.  */
  CORE_ADDR bt;		    /* Current address at top+1 of insn buffer.  */
  gdb_byte ibuf[XTENSA_ISA_BSZ];/* Instruction buffer for decoding prologue.  */
  xtensa_isa isa;	    /* libisa ISA handle.  */
  xtensa_insnbuf ins, slot; /* libisa handle to decoded insn, slot.  */
  xtensa_format ifmt;	    /* libisa instruction format.  */
  int ilen, islots, is;	    /* Instruction length, nbr slots, current slot.  */
  xtensa_opcode opc;	    /* Opcode in current slot.  */
  xtensa_insn_kind opclass; /* Opcode class for Call0 prologue analysis.  */
  int nods;		    /* Opcode number of operands.  */
  unsigned odv[C0_MAXOPDS]; /* Operand values in order provided by libisa.  */
  xtensa_c0reg_t *rtmp;	    /* Register tracking info snapshot.  */
  int j;		    /* General loop counter.  */
  int fail = 0;		    /* Set non-zero and exit, if decoding fails.  */
  CORE_ADDR body_pc;	    /* The PC for the first non-prologue insn.  */
  CORE_ADDR end_pc;	    /* The PC for the lust function insn.  */

  struct symtab_and_line prologue_sal;

  DEBUGTRACE ("call0_analyze_prologue (start = 0x%08x, pc = 0x%08x, ...)\n", 
	      (int)start, (int)pc);

  /* Try to limit the scan to the end of the function if a non-zero pc
     arg was not supplied to avoid probing beyond the end of valid memory.
     If memory is full of garbage that classifies as c0opc_uninteresting.
     If this fails (eg. if no symbols) pc ends up 0 as it was.
     Intialize the Call0 frame and register tracking info.
     Assume it's Call0 until an 'entry' instruction is encountered.
     Assume we may be in the prologue until we hit a flow control instr.  */

  rtmp = NULL;
  body_pc = UINT_MAX;
  end_pc = 0;

  /* Find out, if we have an information about the prologue from DWARF.  */
  prologue_sal = find_pc_line (start, 0);
  if (prologue_sal.line != 0) /* Found debug info.  */
    body_pc = prologue_sal.end;

  /* If we are going to analyze the prologue in general without knowing about
     the current PC, make the best assumtion for the end of the prologue.  */
  if (pc == 0)
    {
      find_pc_partial_function (start, 0, NULL, &end_pc);
      body_pc = min (end_pc, body_pc);
    }
  else
    body_pc = min (pc, body_pc);

  cache->call0 = 1;
  rtmp = (xtensa_c0reg_t*) alloca(nregs * sizeof(xtensa_c0reg_t));

  if (!xtensa_default_isa)
    xtensa_default_isa = xtensa_isa_init (0, 0);
  isa = xtensa_default_isa;
  gdb_assert (XTENSA_ISA_BSZ >= xtensa_isa_maxlength (isa));
  ins = xtensa_insnbuf_alloc (isa);
  slot = xtensa_insnbuf_alloc (isa);

  for (ia = start, bt = ia; ia < body_pc ; ia += ilen)
    {
      /* (Re)fill instruction buffer from memory if necessary, but do not
         read memory beyond PC to be sure we stay within text section
	 (this protection only works if a non-zero pc is supplied).  */

      if (ia + xtensa_isa_maxlength (isa) > bt)
        {
	  ba = ia;
	  bt = (ba + XTENSA_ISA_BSZ) < body_pc ? ba + XTENSA_ISA_BSZ : body_pc;
	  if (target_read_memory (ba, ibuf, bt - ba) != 0 )
	    error (_("Unable to read target memory ..."));
	}

      /* Decode format information.  */

      xtensa_insnbuf_from_chars (isa, ins, &ibuf[ia-ba], 0);
      ifmt = xtensa_format_decode (isa, ins);
      if (ifmt == XTENSA_UNDEFINED)
	{
	  fail = 1;
	  goto done;
	}
      ilen = xtensa_format_length (isa, ifmt);
      if (ilen == XTENSA_UNDEFINED)
	{
	  fail = 1;
	  goto done;
	}
      islots = xtensa_format_num_slots (isa, ifmt);
      if (islots == XTENSA_UNDEFINED)
	{
	  fail = 1;
	  goto done;
	}

      /* Analyze a bundle or a single instruction, using a snapshot of 
         the register tracking info as input for the entire bundle so that
	 register changes do not take effect within this bundle.  */

      for (j = 0; j < nregs; ++j)
	rtmp[j] = cache->c0.c0_rt[j];

      for (is = 0; is < islots; ++is)
        {
	  /* Decode a slot and classify the opcode.  */

	  fail = xtensa_format_get_slot (isa, ifmt, is, ins, slot);
	  if (fail)
	    goto done;

	  opc = xtensa_opcode_decode (isa, ifmt, is, slot);
	  DEBUGVERB ("[call0_analyze_prologue] instr addr = 0x%08x, opc = %d\n", 
		     (unsigned)ia, opc);
	  if (opc == XTENSA_UNDEFINED) 
	    opclass = c0opc_illegal;
	  else
	    opclass = call0_classify_opcode (isa, opc);

	  /* Decide whether to track this opcode, ignore it, or bail out.  */

	  switch (opclass)
	    {
	    case c0opc_illegal:
	    case c0opc_break:
	      fail = 1;
	      goto done;

	    case c0opc_uninteresting:
	      continue;

	    case c0opc_flow:  /* Flow control instructions stop analysis.  */
	    case c0opc_rwxsr: /* RSR, WSR, XSR instructions stop analysis.  */
	      goto done;

	    case c0opc_entry:
	      cache->call0 = 0;
	      ia += ilen;	       	/* Skip over 'entry' insn.  */
	      goto done;

	    default:
	      cache->call0 = 1;
	    }

	  /* Only expected opcodes should get this far.  */

	  /* Extract and decode the operands.  */
	  nods = xtensa_opcode_num_operands (isa, opc);
	  if (nods == XTENSA_UNDEFINED)
	    {
	      fail = 1;
	      goto done;
	    }

	  for (j = 0; j < nods && j < C0_MAXOPDS; ++j)
	    {
	      fail = xtensa_operand_get_field (isa, opc, j, ifmt, 
					       is, slot, &odv[j]);
	      if (fail)
		goto done;

	      fail = xtensa_operand_decode (isa, opc, j, &odv[j]);
	      if (fail)
		goto done;
	    }

	  /* Check operands to verify use of 'mov' assembler macro.  */
	  if (opclass == c0opc_mov && nods == 3)
	    {
	      if (odv[2] == odv[1])
		{
		  nods = 2;
		  if ((odv[0] == 1) && (odv[1] != 1))
		    /* OR  A1, An, An  , where n != 1.
		       This means we are inside epilogue already.  */
		    goto done;
		}
	      else
		{
		  opclass = c0opc_uninteresting;
		  continue;
		}
	    }

	  /* Track register movement and modification for this operation.  */
	  fail = call0_track_op (gdbarch, cache->c0.c0_rt, rtmp,
				 opclass, nods, odv, ia, 1, cache);
	  if (fail)
	    goto done;
	}
    }
done:
  DEBUGVERB ("[call0_analyze_prologue] stopped at instr addr 0x%08x, %s\n",
	     (unsigned)ia, fail ? "failed" : "succeeded");
  xtensa_insnbuf_free(isa, slot);
  xtensa_insnbuf_free(isa, ins);
  return fail ? XTENSA_ISA_BADPC : ia;
}

/* Initialize frame cache for the current frame in CALL0 ABI.  */

static void
call0_frame_cache (struct frame_info *this_frame,
		   xtensa_frame_cache_t *cache, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR start_pc;		/* The beginning of the function.  */
  CORE_ADDR body_pc=UINT_MAX;	/* PC, where prologue analysis stopped.  */
  CORE_ADDR sp, fp, ra;
  int fp_regnum = C0_SP, c0_hasfp = 0, c0_frmsz = 0, prev_sp = 0, to_stk;
 
  sp = get_frame_register_unsigned
    (this_frame, gdbarch_tdep (gdbarch)->a0_base + 1);
  fp = sp; /* Assume FP == SP until proven otherwise.  */

  /* Find the beginning of the prologue of the function containing the PC
     and analyze it up to the PC or the end of the prologue.  */

  if (find_pc_partial_function (pc, NULL, &start_pc, NULL))
    {
      body_pc = call0_analyze_prologue (gdbarch, start_pc, pc, C0_NREGS, cache);

      if (body_pc == XTENSA_ISA_BADPC)
	{
	  warning_once ();
	  ra = 0;
	  goto finish_frame_analysis;
	}
    }
  
  /* Get the frame information and FP (if used) at the current PC.
     If PC is in the prologue, the prologue analysis is more reliable
     than DWARF info.  We don't not know for sure, if PC is in the prologue,
     but we do know no calls have yet taken place, so we can almost
     certainly rely on the prologue analysis.  */

  if (body_pc <= pc)
    {
      /* Prologue analysis was successful up to the PC.
         It includes the cases when PC == START_PC.  */
      c0_hasfp = cache->c0.c0_rt[C0_FP].fr_reg == C0_SP;
      /* c0_hasfp == true means there is a frame pointer because
	 we analyzed the prologue and found that cache->c0.c0_rt[C0_FP]
	 was derived from SP.  Otherwise, it would be C0_FP.  */
      fp_regnum = c0_hasfp ? C0_FP : C0_SP;
      c0_frmsz = - cache->c0.c0_rt[fp_regnum].fr_ofs;
      fp_regnum += gdbarch_tdep (gdbarch)->a0_base;
    }
  else  /* No data from the prologue analysis.  */
    {
      c0_hasfp = 0;
      fp_regnum = gdbarch_tdep (gdbarch)->a0_base + C0_SP;
      c0_frmsz = 0;
      start_pc = pc;
   }

  if (cache->c0.c0_fpalign)
    {
      /* This frame has a special prologue with a dynamic stack adjustment
	 to force an alignment, which is bigger than standard 16 bytes.  */

      CORE_ADDR unaligned_sp;

      if (cache->c0.c0_old_sp == C0_INEXP)
	/* This can't be.  Prologue code should be consistent.
	   Unaligned stack pointer should be saved in a spare register.  */
	{
	  warning_once ();
	  ra = 0;
	  goto finish_frame_analysis;
	}

      if (cache->c0.c0_sp_ofs == C0_NOSTK)
	/* Saved unaligned value of SP is kept in a register.  */
	unaligned_sp = get_frame_register_unsigned
	  (this_frame, gdbarch_tdep (gdbarch)->a0_base + cache->c0.c0_old_sp);
      else
	/* Get the value from stack.  */
	unaligned_sp = (CORE_ADDR)
	  read_memory_integer (fp + cache->c0.c0_sp_ofs, 4, byte_order);

      prev_sp = unaligned_sp + c0_frmsz;
    }
  else
    prev_sp = fp + c0_frmsz;

  /* Frame size from debug info or prologue tracking does not account for 
     alloca() and other dynamic allocations.  Adjust frame size by FP - SP.  */
  if (c0_hasfp)
    {
      fp = get_frame_register_unsigned (this_frame, fp_regnum);

      /* Update the stack frame size.  */
      c0_frmsz += fp - sp;
    }

  /* Get the return address (RA) from the stack if saved,
     or try to get it from a register.  */

  to_stk = cache->c0.c0_rt[C0_RA].to_stk;
  if (to_stk != C0_NOSTK)
    ra = (CORE_ADDR) 
      read_memory_integer (sp + c0_frmsz + cache->c0.c0_rt[C0_RA].to_stk,
			   4, byte_order);

  else if (cache->c0.c0_rt[C0_RA].fr_reg == C0_CONST
	   && cache->c0.c0_rt[C0_RA].fr_ofs == 0)
    {
      /* Special case for terminating backtrace at a function that wants to
	 be seen as the outermost one.  Such a function will clear it's RA (A0)
	 register to 0 in the prologue instead of saving its original value.  */
      ra = 0;
    }
  else
    {
      /* RA was copied to another register or (before any function call) may
	 still be in the original RA register.  This is not always reliable:
	 even in a leaf function, register tracking stops after prologue, and
	 even in prologue, non-prologue instructions (not tracked) may overwrite
	 RA or any register it was copied to.  If likely in prologue or before
	 any call, use retracking info and hope for the best (compiler should
	 have saved RA in stack if not in a leaf function).  If not in prologue,
	 too bad.  */

      int i;
      for (i = 0;
	   (i < C0_NREGS)
	   && (i == C0_RA || cache->c0.c0_rt[i].fr_reg != C0_RA);
	   ++i);
      if (i >= C0_NREGS && cache->c0.c0_rt[C0_RA].fr_reg == C0_RA)
	i = C0_RA;
      if (i < C0_NREGS)
	{
	  ra = get_frame_register_unsigned
	    (this_frame,
	     gdbarch_tdep (gdbarch)->a0_base + cache->c0.c0_rt[i].fr_reg);
	}
      else ra = 0;
    }
  
 finish_frame_analysis:
  cache->pc = start_pc;
  cache->ra = ra;
  /* RA == 0 marks the outermost frame.  Do not go past it.  */
  cache->prev_sp = (ra != 0) ?  prev_sp : 0;
  cache->c0.fp_regnum = fp_regnum;
  cache->c0.c0_frmsz = c0_frmsz;
  cache->c0.c0_hasfp = c0_hasfp;
  cache->c0.c0_fp = fp;
}

static CORE_ADDR a0_saved;
static CORE_ADDR a7_saved;
static CORE_ADDR a11_saved;
static int a0_was_saved;
static int a7_was_saved;
static int a11_was_saved;

/* Simulate L32E instruction:  AT <-- ref (AS + offset).  */
static void
execute_l32e (struct gdbarch *gdbarch, int at, int as, int offset, CORE_ADDR wb)
{
  int atreg = arreg_number (gdbarch, gdbarch_tdep (gdbarch)->a0_base + at, wb);
  int asreg = arreg_number (gdbarch, gdbarch_tdep (gdbarch)->a0_base + as, wb);
  CORE_ADDR addr = xtensa_read_register (asreg) + offset;
  unsigned int spilled_value
    = read_memory_unsigned_integer (addr, 4, gdbarch_byte_order (gdbarch));

  if ((at == 0) && !a0_was_saved)
    {
      a0_saved = xtensa_read_register (atreg);
      a0_was_saved = 1;
    }
  else if ((at == 7) && !a7_was_saved)
    {
      a7_saved = xtensa_read_register (atreg);
      a7_was_saved = 1;
    }
  else if ((at == 11) && !a11_was_saved)
    {
      a11_saved = xtensa_read_register (atreg);
      a11_was_saved = 1;
    }

  xtensa_write_register (atreg, spilled_value);
}

/* Simulate S32E instruction:  AT --> ref (AS + offset).  */
static void
execute_s32e (struct gdbarch *gdbarch, int at, int as, int offset, CORE_ADDR wb)
{
  int atreg = arreg_number (gdbarch, gdbarch_tdep (gdbarch)->a0_base + at, wb);
  int asreg = arreg_number (gdbarch, gdbarch_tdep (gdbarch)->a0_base + as, wb);
  CORE_ADDR addr = xtensa_read_register (asreg) + offset;
  ULONGEST spilled_value = xtensa_read_register (atreg);

  write_memory_unsigned_integer (addr, 4,
				 gdbarch_byte_order (gdbarch),
				 spilled_value);
}

#define XTENSA_MAX_WINDOW_INTERRUPT_HANDLER_LEN  200

typedef enum
{
  xtWindowOverflow,
  xtWindowUnderflow,
  xtNoExceptionHandler
} xtensa_exception_handler_t;

/* Execute instruction stream from current PC until hitting RFWU or RFWO.
   Return type of Xtensa Window Interrupt Handler on success.  */
static xtensa_exception_handler_t
execute_code (struct gdbarch *gdbarch, CORE_ADDR current_pc, CORE_ADDR wb)
{
  xtensa_isa isa;
  xtensa_insnbuf ins, slot;
  gdb_byte ibuf[XTENSA_ISA_BSZ];
  CORE_ADDR ia, bt, ba;
  xtensa_format ifmt;
  int ilen, islots, is;
  xtensa_opcode opc;
  int insn_num = 0;
  int fail = 0;
  void (*func) (struct gdbarch *, int, int, int, CORE_ADDR);

  uint32_t at, as, offset;

  /* WindowUnderflow12 = true, when inside _WindowUnderflow12.  */ 
  int WindowUnderflow12 = (current_pc & 0x1ff) >= 0x140; 

  isa = xtensa_default_isa;
  gdb_assert (XTENSA_ISA_BSZ >= xtensa_isa_maxlength (isa));
  ins = xtensa_insnbuf_alloc (isa);
  slot = xtensa_insnbuf_alloc (isa);
  ba = 0;
  ia = current_pc;
  bt = ia;

  a0_was_saved = 0;
  a7_was_saved = 0;
  a11_was_saved = 0;

  while (insn_num++ < XTENSA_MAX_WINDOW_INTERRUPT_HANDLER_LEN)
    {
      if (ia + xtensa_isa_maxlength (isa) > bt)
        {
	  ba = ia;
	  bt = (ba + XTENSA_ISA_BSZ);
	  if (target_read_memory (ba, ibuf, bt - ba) != 0)
	    return xtNoExceptionHandler;
	}
      xtensa_insnbuf_from_chars (isa, ins, &ibuf[ia-ba], 0);
      ifmt = xtensa_format_decode (isa, ins);
      if (ifmt == XTENSA_UNDEFINED)
	return xtNoExceptionHandler;
      ilen = xtensa_format_length (isa, ifmt);
      if (ilen == XTENSA_UNDEFINED)
	return xtNoExceptionHandler;
      islots = xtensa_format_num_slots (isa, ifmt);
      if (islots == XTENSA_UNDEFINED)
	return xtNoExceptionHandler;
      for (is = 0; is < islots; ++is)
	{
	  if (xtensa_format_get_slot (isa, ifmt, is, ins, slot))
	    return xtNoExceptionHandler;
	  opc = xtensa_opcode_decode (isa, ifmt, is, slot);
	  if (opc == XTENSA_UNDEFINED) 
	    return xtNoExceptionHandler;
	  switch (call0_classify_opcode (isa, opc))
	    {
	    case c0opc_illegal:
	    case c0opc_flow:
	    case c0opc_entry:
	    case c0opc_break:
	      /* We expect none of them here.  */
	      return xtNoExceptionHandler;
	    case c0opc_l32e:
	      func = execute_l32e;
	      break;
	    case c0opc_s32e:
	      func = execute_s32e;
	      break;
	    case c0opc_rfwo: /* RFWO.  */
	      /* Here, we return from WindowOverflow handler and,
		 if we stopped at the very beginning, which means
		 A0 was saved, we have to restore it now.  */
	      if (a0_was_saved)
		{
		  int arreg = arreg_number (gdbarch,
					    gdbarch_tdep (gdbarch)->a0_base,
					    wb);
		  xtensa_write_register (arreg, a0_saved);
		}
	      return xtWindowOverflow;
	    case c0opc_rfwu: /* RFWU.  */
	      /* Here, we return from WindowUnderflow handler.
		 Let's see if either A7 or A11 has to be restored.  */
	      if (WindowUnderflow12)
		{
		  if (a11_was_saved)
		    {
		      int arreg = arreg_number (gdbarch,
						gdbarch_tdep (gdbarch)->a0_base + 11,
						wb);
		      xtensa_write_register (arreg, a11_saved);
		    }
		}
	      else if (a7_was_saved)
		{
		  int arreg = arreg_number (gdbarch,
					    gdbarch_tdep (gdbarch)->a0_base + 7,
					    wb);
		  xtensa_write_register (arreg, a7_saved);
		}
	      return xtWindowUnderflow;
 	    default: /* Simply skip this insns.  */
	      continue;
	    }

	  /* Decode arguments for L32E / S32E and simulate their execution.  */
	  if ( xtensa_opcode_num_operands (isa, opc) != 3 )
	    return xtNoExceptionHandler;
	  if (xtensa_operand_get_field (isa, opc, 0, ifmt, is, slot, &at))
	    return xtNoExceptionHandler;
	  if (xtensa_operand_decode (isa, opc, 0, &at))
	    return xtNoExceptionHandler;
	  if (xtensa_operand_get_field (isa, opc, 1, ifmt, is, slot, &as))
	    return xtNoExceptionHandler;
	  if (xtensa_operand_decode (isa, opc, 1, &as))
	    return xtNoExceptionHandler;
	  if (xtensa_operand_get_field (isa, opc, 2, ifmt, is, slot, &offset))
	    return xtNoExceptionHandler;
	  if (xtensa_operand_decode (isa, opc, 2, &offset))
	    return xtNoExceptionHandler;

	  (*func) (gdbarch, at, as, offset, wb);
	}

      ia += ilen;
    }
  return xtNoExceptionHandler;
}

/* Handle Window Overflow / Underflow exception frames.  */

static void
xtensa_window_interrupt_frame_cache (struct frame_info *this_frame,
				     xtensa_frame_cache_t *cache,
				     CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  CORE_ADDR ps, wb, ws, ra;
  int epc1_regnum, i, regnum;
  xtensa_exception_handler_t eh_type;

  /* Read PS, WB, and WS from the hardware. Note that PS register
     must be present, if Windowed ABI is supported.  */
  ps = xtensa_read_register (gdbarch_ps_regnum (gdbarch));
  wb = xtensa_read_register (gdbarch_tdep (gdbarch)->wb_regnum);
  ws = xtensa_read_register (gdbarch_tdep (gdbarch)->ws_regnum);

  /* Execute all the remaining instructions from Window Interrupt Handler
     by simulating them on the remote protocol level.  On return, set the
     type of Xtensa Window Interrupt Handler, or report an error.  */
  eh_type = execute_code (gdbarch, pc, wb);
  if (eh_type == xtNoExceptionHandler)
    error (_("\
Unable to decode Xtensa Window Interrupt Handler's code."));

  cache->ps = ps ^ PS_EXC;	/* Clear the exception bit in PS.  */
  cache->call0 = 0;		/* It's Windowed ABI.  */

  /* All registers for the cached frame will be alive.  */
  for (i = 0; i < XTENSA_NUM_SAVED_AREGS; i++)
    cache->wd.aregs[i] = -1;

  if (eh_type == xtWindowOverflow)
    cache->wd.ws = ws ^ (1 << wb);
  else /* eh_type == xtWindowUnderflow.  */
    cache->wd.ws = ws | (1 << wb);

  cache->wd.wb = (ps & 0xf00) >> 8; /* Set WB to OWB.  */
  regnum = arreg_number (gdbarch, gdbarch_tdep (gdbarch)->a0_base,
			 cache->wd.wb);
  ra = xtensa_read_register (regnum);
  cache->wd.callsize = WINSIZE (ra);
  cache->prev_sp = xtensa_read_register (regnum + 1);
  /* Set regnum to a frame pointer of the frame being cached.  */
  regnum = xtensa_scan_prologue (gdbarch, pc);
  regnum = arreg_number (gdbarch,
			 gdbarch_tdep (gdbarch)->a0_base + regnum,
			 cache->wd.wb);
  cache->base = get_frame_register_unsigned (this_frame, regnum);

  /* Read PC of interrupted function from EPC1 register.  */
  epc1_regnum = xtensa_find_register_by_name (gdbarch,"epc1");
  if (epc1_regnum < 0)
    error(_("Unable to read Xtensa register EPC1"));
  cache->ra = xtensa_read_register (epc1_regnum);
  cache->pc = get_frame_func (this_frame);
}


/* Skip function prologue.

   Return the pc of the first instruction after prologue.  GDB calls this to
   find the address of the first line of the function or (if there is no line
   number information) to skip the prologue for planting breakpoints on 
   function entries.  Use debug info (if present) or prologue analysis to skip 
   the prologue to achieve reliable debugging behavior.  For windowed ABI, 
   only the 'entry' instruction is skipped.  It is not strictly necessary to 
   skip the prologue (Call0) or 'entry' (Windowed) because xt-gdb knows how to
   backtrace at any point in the prologue, however certain potential hazards 
   are avoided and a more "normal" debugging experience is ensured by 
   skipping the prologue (can be disabled by defining DONT_SKIP_PROLOG).
   For example, if we don't skip the prologue:
   - Some args may not yet have been saved to the stack where the debug
     info expects to find them (true anyway when only 'entry' is skipped);
   - Software breakpoints ('break' instrs) may not have been unplanted 
     when the prologue analysis is done on initializing the frame cache, 
     and breaks in the prologue will throw off the analysis.

   If we have debug info ( line-number info, in particular ) we simply skip
   the code associated with the first function line effectively skipping
   the prologue code.  It works even in cases like

   int main()
   {	int local_var = 1;
   	....
   }

   because, for this source code, both Xtensa compilers will generate two
   separate entries ( with the same line number ) in dwarf line-number
   section to make sure there is a boundary between the prologue code and
   the rest of the function.

   If there is no debug info, we need to analyze the code.  */

/* #define DONT_SKIP_PROLOGUE  */

static CORE_ADDR
xtensa_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)
{
  struct symtab_and_line prologue_sal;
  CORE_ADDR body_pc;

  DEBUGTRACE ("xtensa_skip_prologue (start_pc = 0x%08x)\n", (int) start_pc);

#if DONT_SKIP_PROLOGUE
  return start_pc;
#endif

 /* Try to find first body line from debug info.  */

  prologue_sal = find_pc_line (start_pc, 0);
  if (prologue_sal.line != 0) /* Found debug info.  */
    {
      /* In Call0,  it is possible to have a function with only one instruction
	 ('ret') resulting from a one-line optimized function that does nothing.
	 In that case,  prologue_sal.end may actually point to the start of the
	 next function in the text section,  causing a breakpoint to be set at
	 the wrong place.  Check,  if the end address is within a different
	 function,  and if so return the start PC.  We know we have symbol
	 information.  */

      CORE_ADDR end_func;

      if ((gdbarch_tdep (gdbarch)->call_abi == CallAbiCall0Only)
	  && call0_ret (start_pc, prologue_sal.end))
	return start_pc;

      find_pc_partial_function (prologue_sal.end, NULL, &end_func, NULL);
      if (end_func != start_pc)
	return start_pc;

      return prologue_sal.end;
    }

  /* No debug line info.  Analyze prologue for Call0 or simply skip ENTRY.  */
  body_pc = call0_analyze_prologue (gdbarch, start_pc, 0, 0,
				    xtensa_alloc_frame_cache (0));
  return body_pc != 0 ? body_pc : start_pc;
}

/* Verify the current configuration.  */
static void
xtensa_verify_config (struct gdbarch *gdbarch)
{
  struct ui_file *log;
  struct cleanup *cleanups;
  struct gdbarch_tdep *tdep;
  long length;
  char *buf;

  tdep = gdbarch_tdep (gdbarch);
  log = mem_fileopen ();
  cleanups = make_cleanup_ui_file_delete (log);

  /* Verify that we got a reasonable number of AREGS.  */
  if ((tdep->num_aregs & -tdep->num_aregs) != tdep->num_aregs)
    fprintf_unfiltered (log, _("\
\n\tnum_aregs: Number of AR registers (%d) is not a power of two!"),
			tdep->num_aregs);

  /* Verify that certain registers exist.  */

  if (tdep->pc_regnum == -1)
    fprintf_unfiltered (log, _("\n\tpc_regnum: No PC register"));
  if (tdep->isa_use_exceptions && tdep->ps_regnum == -1)
    fprintf_unfiltered (log, _("\n\tps_regnum: No PS register"));

  if (tdep->isa_use_windowed_registers)
    {
      if (tdep->wb_regnum == -1)
	fprintf_unfiltered (log, _("\n\twb_regnum: No WB register"));
      if (tdep->ws_regnum == -1)
	fprintf_unfiltered (log, _("\n\tws_regnum: No WS register"));
      if (tdep->ar_base == -1)
	fprintf_unfiltered (log, _("\n\tar_base: No AR registers"));
    }

  if (tdep->a0_base == -1)
    fprintf_unfiltered (log, _("\n\ta0_base: No Ax registers"));

  buf = ui_file_xstrdup (log, &length);
  make_cleanup (xfree, buf);
  if (length > 0)
    internal_error (__FILE__, __LINE__,
		    _("the following are invalid: %s"), buf);
  do_cleanups (cleanups);
}


/* Derive specific register numbers from the array of registers.  */

static void
xtensa_derive_tdep (struct gdbarch_tdep *tdep)
{
  xtensa_register_t* rmap;
  int n, max_size = 4;

  tdep->num_regs = 0;
  tdep->num_nopriv_regs = 0;

/* Special registers 0..255 (core).  */
#define XTENSA_DBREGN_SREG(n)  (0x0200+(n))

  for (rmap = tdep->regmap, n = 0; rmap->target_number != -1; n++, rmap++)
    {
      if (rmap->target_number == 0x0020)
	tdep->pc_regnum = n;
      else if (rmap->target_number == 0x0100)
	tdep->ar_base = n;
      else if (rmap->target_number == 0x0000)
	tdep->a0_base = n;
      else if (rmap->target_number == XTENSA_DBREGN_SREG(72))
	tdep->wb_regnum = n;
      else if (rmap->target_number == XTENSA_DBREGN_SREG(73))
	tdep->ws_regnum = n;
      else if (rmap->target_number == XTENSA_DBREGN_SREG(233))
	tdep->debugcause_regnum = n;
      else if (rmap->target_number == XTENSA_DBREGN_SREG(232))
	tdep->exccause_regnum = n;
      else if (rmap->target_number == XTENSA_DBREGN_SREG(238))
	tdep->excvaddr_regnum = n;
      else if (rmap->target_number == XTENSA_DBREGN_SREG(0))
	tdep->lbeg_regnum = n;
      else if (rmap->target_number == XTENSA_DBREGN_SREG(1))
	tdep->lend_regnum = n;
      else if (rmap->target_number == XTENSA_DBREGN_SREG(2))
	tdep->lcount_regnum = n;
      else if (rmap->target_number == XTENSA_DBREGN_SREG(3))
	tdep->sar_regnum = n;
      else if (rmap->target_number == XTENSA_DBREGN_SREG(5))
	tdep->litbase_regnum = n;
      else if (rmap->target_number == XTENSA_DBREGN_SREG(230))
	tdep->ps_regnum = n;
#if 0
      else if (rmap->target_number == XTENSA_DBREGN_SREG(226))
	tdep->interrupt_regnum = n;
      else if (rmap->target_number == XTENSA_DBREGN_SREG(227))
	tdep->interrupt2_regnum = n;
      else if (rmap->target_number == XTENSA_DBREGN_SREG(224))
	tdep->cpenable_regnum = n;
#endif

      if (rmap->byte_size > max_size)
	max_size = rmap->byte_size;
      if (rmap->mask != 0 && tdep->num_regs == 0)
	tdep->num_regs = n;
      /* Find out out how to deal with priveleged registers.

         if ((rmap->flags & XTENSA_REGISTER_FLAGS_PRIVILEGED) != 0
              && tdep->num_nopriv_regs == 0)
           tdep->num_nopriv_regs = n;
      */
      if ((rmap->flags & XTENSA_REGISTER_FLAGS_PRIVILEGED) != 0
	  && tdep->num_regs == 0)
	tdep->num_regs = n;
    }

  /* Number of pseudo registers.  */
  tdep->num_pseudo_regs = n - tdep->num_regs;

  /* Empirically determined maximum sizes.  */
  tdep->max_register_raw_size = max_size;
  tdep->max_register_virtual_size = max_size;
}

/* Module "constructor" function.  */

extern struct gdbarch_tdep xtensa_tdep;

static struct gdbarch *
xtensa_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;
  struct xtensa_abi_handler *abi_handler;

  DEBUGTRACE ("gdbarch_init()\n");

  /* We have to set the byte order before we call gdbarch_alloc.  */
  info.byte_order = XCHAL_HAVE_BE ? BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;

  tdep = &xtensa_tdep;
  gdbarch = gdbarch_alloc (&info, tdep);
  xtensa_derive_tdep (tdep);

  /* Verify our configuration.  */
  xtensa_verify_config (gdbarch);
  xtensa_session_once_reported = 0;

  /* Pseudo-Register read/write.  */
  set_gdbarch_pseudo_register_read (gdbarch, xtensa_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, xtensa_pseudo_register_write);

  /* Set target information.  */
  set_gdbarch_num_regs (gdbarch, tdep->num_regs);
  set_gdbarch_num_pseudo_regs (gdbarch, tdep->num_pseudo_regs);
  set_gdbarch_sp_regnum (gdbarch, tdep->a0_base + 1);
  set_gdbarch_pc_regnum (gdbarch, tdep->pc_regnum);
  set_gdbarch_ps_regnum (gdbarch, tdep->ps_regnum);

  /* Renumber registers for known formats (stabs and dwarf2).  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, xtensa_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, xtensa_reg_to_regnum);

  /* We provide our own function to get register information.  */
  set_gdbarch_register_name (gdbarch, xtensa_register_name);
  set_gdbarch_register_type (gdbarch, xtensa_register_type);

  /* To call functions from GDB using dummy frame.  */
  set_gdbarch_push_dummy_call (gdbarch, xtensa_push_dummy_call);

  set_gdbarch_believe_pcc_promotion (gdbarch, 1);

  set_gdbarch_return_value (gdbarch, xtensa_return_value);

  /* Advance PC across any prologue instructions to reach "real" code.  */
  set_gdbarch_skip_prologue (gdbarch, xtensa_skip_prologue);

  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);

  /* Set breakpoints.  */
  set_gdbarch_breakpoint_from_pc (gdbarch, xtensa_breakpoint_from_pc);

  /* After breakpoint instruction or illegal instruction, pc still
     points at break instruction, so don't decrement.  */
  set_gdbarch_decr_pc_after_break (gdbarch, 0);

  /* We don't skip args.  */
  set_gdbarch_frame_args_skip (gdbarch, 0);

  set_gdbarch_unwind_pc (gdbarch, xtensa_unwind_pc);

  set_gdbarch_frame_align (gdbarch, xtensa_frame_align);

  set_gdbarch_dummy_id (gdbarch, xtensa_dummy_id);

  /* Frame handling.  */
  frame_base_set_default (gdbarch, &xtensa_frame_base);
  frame_unwind_append_unwinder (gdbarch, &xtensa_unwind);
  dwarf2_append_unwinders (gdbarch);

  set_gdbarch_print_insn (gdbarch, print_insn_xtensa);

  set_gdbarch_have_nonsteppable_watchpoint (gdbarch, 1);

  xtensa_add_reggroups (gdbarch);
  set_gdbarch_register_reggroup_p (gdbarch, xtensa_register_reggroup_p);

  set_gdbarch_regset_from_core_section (gdbarch,
					xtensa_regset_from_core_section);

  set_solib_svr4_fetch_link_map_offsets
    (gdbarch, svr4_ilp32_fetch_link_map_offsets);

  return gdbarch;
}

static void
xtensa_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)
{
  error (_("xtensa_dump_tdep(): not implemented"));
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_xtensa_tdep;

void
_initialize_xtensa_tdep (void)
{
  struct cmd_list_element *c;

  gdbarch_register (bfd_arch_xtensa, xtensa_gdbarch_init, xtensa_dump_tdep);
  xtensa_init_reggroups ();

  add_setshow_zuinteger_cmd ("xtensa",
			     class_maintenance,
			     &xtensa_debug_level,
			    _("Set Xtensa debugging."),
			    _("Show Xtensa debugging."), _("\
When non-zero, Xtensa-specific debugging is enabled. \
Can be 1, 2, 3, or 4 indicating the level of debugging."),
			     NULL,
			     NULL,
			     &setdebuglist, &showdebuglist);
}
@


1.64
log
@-Wpointer-sign: char -> gdb_byte.

-Wpointer-sign catches all these cases across the codebase that should
be using gdb_byte for raw target bytes.  I think these are all
obvious, hence I've collapsed into a single patch.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* aarch64-tdep.c (aarch64_default_breakpoint): Change type to
	gdb_byte[].
	(aarch64_breakpoint_from_pc): Change return type to gdb_byte *.
	* ada-lang.c (ada_value_assign): Use gdb_byte.
	* alphanbsd-tdep.c (sigtramp_retcode): Change type to gdb_byte[].
	(alphanbsd_sigtramp_offset): Use gdb_byte.
	* arm-linux-tdep.c (arm_linux_arm_le_breakpoint)
	(arm_linux_arm_be_breakpoint, eabi_linux_arm_le_breakpoint)
	(eabi_linux_arm_be_breakpoint, arm_linux_thumb_be_breakpoint)
	(arm_linux_thumb_le_breakpoint, arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): Change type to gdb_byte[].
	* arm-tdep.c (arm_stub_unwind_sniffer)
	(arm_displaced_init_closure): Use gdb_byte.
	(arm_default_arm_le_breakpoint, arm_default_arm_be_breakpoint)
	(arm_default_thumb_le_breakpoint)
	(arm_default_thumb_be_breakpoint): Change type to gdb_byte[].
	* arm-tdep.h (struct gdbarch_tdep) <arm_breakpoint,
	thumb_breakpoint, thumb2_breakpoint>: Change type to gdb_byte *.
	* arm-wince-tdep.c (arm_wince_le_breakpoint)
	(arm_wince_thumb_le_breakpoint): Change type to gdb_byte[].
	* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint)
	(arm_nbsd_arm_be_breakpoint, arm_nbsd_thumb_le_breakpoint)
	(arm_nbsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint)
	(arm_obsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* cris-tdep.c (push_stack_item, cris_push_dummy_call)
	(cris_store_return_value, cris_extract_return_value): Use
	gdb_byte.
	(constraint): Change type of parameter to char * from signed
	char*.  Use gdb_byte.
	* dwarf2loc.c (read_pieced_value, write_pieced_value): Change type
	of local buffer to gdb_byte *.
	* dwarf2read.c (read_index_from_section): Use gdb_byte.
	(create_dwp_hash_table): Change type of locals to gdb_byte *.
	(add_address_entry): Change type of local buffer to gdb_byte[].
	* frv-tdep.c (frv_adjust_breakpoint_address, find_func_descr)
	(frv_push_dummy_call): Use gdb_byte.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code)
	(hppa_hpux_supply_ss_fpblock, hppa_hpux_supply_ss_wide)
	(hppa_hpux_supply_save_state): Use gdb_byte.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_convert_code_addr_to_fptr): Use gdb_byte.
	* ia64-tdep.c (extract_bit_field, replace_bit_field)
	(slotN_contents, replace_slotN_contents): Change type of parameter
	to gdb_byte *.
	(fetch_instruction, ia64_pseudo_register_write)
	(ia64_register_to_value, ia64_value_to_register)
	(ia64_extract_return_value, ia64_store_return_value)
	(ia64_push_dummy_call): Use gdb_byte.
	* m32c-tdep.c (m32c_return_value): Remove cast.
	* m68hc11-tdep.c (m68hc11_pseudo_register_write)
	(m68hc11_push_dummy_call, m68hc11_store_return_value): Use
	gdb_byte.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use gdb_byte.
	* mn10300-tdep.c (mn10300_store_return_value)
	(mn10300_breakpoint_from_pc, mn10300_push_dummy_call): Use
	gdb_byte.
	* moxie-tdep.c (moxie_process_readu): Use gdb_byte.
	(moxie_process_record): Remove casts.
	* ppc-ravenscar-thread.c (supply_register_at_address)
	(ppc_ravenscar_generic_store_registers): Use gdb_byte.
	* ravenscar-thread.c (get_running_thread_id): Use gdb_byte.
	* remote-m32r-sdi.c (m32r_fetch_register): Use gdb_byte.
	* remote-mips.c (mips_xfer_memory): Use gdb_byte.
	* remote.c (compare_sections_command): Use gdb_byte.
	* score-tdep.c (score7_free_memblock): Change type of parameter to
	gdb_byte *.
	* sh-tdep.c (sh_justify_value_in_reg): Change return type to
	gdb_byte *.  Use gdb_byte.
	(sh_push_dummy_call_fpu): Use gdb_byte.
	(sh_extract_return_value_nofpu, sh_extract_return_value_fpu)
	(sh_store_return_value_nofpu, sh_store_return_value_fpu)
	(sh_register_convert_to_virtual, sh_register_convert_to_raw):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh_pseudo_register_read, sh_pseudo_register_write): Use gdb_byte.
	* sh64-tdep.c (sh64_push_dummy_call): Use gdb_byte.
	(sh64_store_return_value, sh64_register_convert_to_virtual):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh64_pseudo_register_write): Use gdb_byte.
	* solib-darwin.c (darwin_current_sos): Add casts to 'gdb_byte *'.
	* solib-irix.c (fetch_lm_info): Likewise.  Use gdb_byte for byte
	buffer.
	(irix_current_sos): Use gdb_byte.
	* solib-som.c (som_current_sos): Use gdb_byte.
	* sparc-ravenscar-thread.c (supply_register_at_address)
	(sparc_ravenscar_generic_store_registers): Use gdb_byte.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_get_overlay_table): Use gdb_byte.
	* tic6x-tdep.c (tic6x_breakpoint_from_pc): Change return type to
	'gdb_byte *'.
	* tic6x-tdep.h (struct gdbarch_tdep) <breakpoint>: Change type to
	'gdb_byte *'.
	* tracepoint.c (tfile_fetch_registers): Use gdb_byte.
	* xstormy16-tdep.c (xstormy16_extract_return_value)
	(xstormy16_store_return_value): Change parameter type to
	'gdb_byte *'.  Adjust.
	(xstormy16_push_dummy_call): Use gdb_byte.
	* xtensa-tdep.c (xtensa_scan_prologue, call0_ret)
	(call0_analyze_prologue, execute_code): Use gdb_byte.
@
text
@d2817 1
a2817 1
  int at, as, offset;
@


1.63
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1157 1
a1157 1
  char ibuf[XTENSA_ISA_BSZ];
d2035 1
a2035 1
  char ibuf[XTENSA_ISA_BSZ];
d2393 1
a2393 1
  char ibuf[XTENSA_ISA_BSZ];/* Instruction buffer for decoding prologue.  */
d2808 1
a2808 1
  char ibuf[XTENSA_ISA_BSZ];
@


1.62
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005-2012 Free Software Foundation, Inc.
@


1.61
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d58 1
a58 1
static int xtensa_debug_level = 0;
d3311 3
a3313 3
  add_setshow_zinteger_cmd ("xtensa",
			    class_maintenance,
			    &xtensa_debug_level,
d3318 3
a3320 3
			    NULL,
			    NULL,
			    &setdebuglist, &showdebuglist);
@


1.60
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@a667 1
      unsigned int wb;
a2817 1
  int num_operands;
@


1.59
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1685 1
a1685 1
		     struct type *func_type,
@


1.58
log
@	ARI cleanup.
	* xtensa-tdep.c (xtensa_register_type): Use xstrprintf instead of
	sprintf. Simplify code and avoid loosing memory.
	(xtensa_register_reggroup_p): Extract assignment out of IF clause.
	(call0_frame_cache): Remove && operator from end of line.
@
text
@d3 1
a3 2
   Copyright (C) 2003, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.58.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2003, 2005-2012 Free Software Foundation, Inc.
@


1.57
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d321 1
a321 1
		  char *name = xmalloc (16);
a325 2

		  sprintf (name, "int%d", size * 8);
d327 2
a328 1
		    = arch_integer_type (gdbarch, size * 8, 1, xstrdup (name));
d845 2
a846 1
  if ((cp_number = xtensa_coprocessor_register_group (group)) >= 0)
d2718 3
a2720 3
      for (i = 0; 
	   (i < C0_NREGS) &&
	     (i == C0_RA || cache->c0.c0_rt[i].fr_reg != C0_RA);
@


1.56
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d1552 1
@


1.55
log
@2011-03-11  Maxim Grigoriev  <maxim2405@@gmail.com>

	* xtensa-tdep.c (warning_once): Correct style issues.
@
text
@d456 1
a456 1
static void
d482 1
d484 4
a487 1
	  regcache_cooked_read_unsigned (regcache, r, &val);
d542 2
d549 1
a549 1
static void
d570 1
d572 5
a576 1
      regcache_raw_read (regcache, gdbarch_tdep (gdbarch)->wb_regnum, buf);
d583 1
a583 2
    regcache_raw_read (regcache, regnum, buffer);

d594 1
d612 1
a612 1
	      return;
d623 1
a623 1
	      return;
d630 1
a630 1
	      return;
d636 1
a636 4
        {
	  xtensa_register_read_masked (regcache, reg, buffer);
	  return;
	}
d639 1
a639 1
      regcache_raw_read (regcache, regnum, buffer);
@


1.54
log
@2011-03-10  Maxim Grigoriev  <maxim2405@@gmail.com>

	* xtensa-tdep.c (windowing_enabled): Remove inline attribute.
	(xtensa_write_register, xtensa_read_register): Likewise.
	(xtensa_hextochar): Removed.
	(xtensa_init_reggroups): Replace xtensa_hextochar () by explicit code.
@
text
@d1424 2
a1425 1
static void warning_once ()
@


1.53
log
@2011-03-10  Maxim Grigoriev  <maxim2405@@gmail.com>

	* xtensa-tdep.c (xtensa_c0reg_t): Update comments.
	(xtensa_call0_frame_cache_t): Update comments. New fields added.
	(xtensa_alloc_frame_cache): Add initialization for new fields.
	(xtensa_frame_cache): Change the way how call0_frame_cache () is called.
	(warning_once): New function.
	(xtensa_insn_kind): New item c0opc_and.
	(call0_classify_opcode): Add the case for AND instruction.
	(call0_track_op): Change arguments. New local variable litbase. Add the
	case to handle c0opc_and. Update algorithms for c0opc_mov, c0opc_l32r,
	c0opc_s32i to take into account dynamic stack adjustments in prologue.
	Add cases for c0opc_l32e, c0opc_s32e, c0opc_rfwo, c0opc_rfwu.
	(call0_analyze_prologue): Update the comments. Change arguments.
	Add the variety of updates to handle extended prologues, which now can
	conduct dynamic stack adjustments.
	(call0_frame_cache): Likewise.
	(xtensa_skip_prologue): Update call0_analyze_prologue () function call.
	(xtensa_gdbarch_init): Initialize xtensa_session_once_reported.
@
text
@d124 1
a124 1
static inline int
d165 1
a165 1
static inline unsigned long
d175 1
a175 1
static inline void
a736 9
/* Return a character representation of a hex-decimal digit.
   The value of "xdigit" is assumed to be in a range [0..15].  */

static inline
char xtensa_hextochar (int xdigit)
{
  return '0' + xdigit;
}

d754 1
a754 1
      cpname[2] = xtensa_hextochar (i);
d1424 1
a1424 1
static inline void warning_once ()
@


1.52
log
@2011-03-09  Maxim Grigoriev  <maxim2405@@gmail.com>

	* xtensa-tdep.c (xtensa_read_register: Add comment.
	(xtensa_write_register): Likewise.
	(xtensa_hextochar): Add comment and update to match coding conventions.
	(xtensa_frame_cache, xtensa_return_value): Follow coding conventions.
	(execute_l32e, execute_s32e, execute_code): Update comments.
	(xtensa_exception_handler_t): Update to match coding conventions.
	(xtensa_insn_kind): Likewise.
@
text
@d985 5
a989 6
    int	    fr_reg;	/* original register from which register content
			   is derived, or C0_CONST, or C0_INEXP.  */
    int	    fr_ofs;	/* constant offset from reg, or immediate value.  */
    int	    to_stk;	/* offset from original SP to register (4-byte
			   aligned), or C0_NOSTK if register has not
			   been saved.  */
a991 1

d995 14
a1008 6
  int c0_frmsz;				/* Stack frame size.  */
  int c0_hasfp;				/* Current frame uses frame
					   pointer.  */
  int fp_regnum;			/* A-register used as FP.  */
  int c0_fp;				/* Actual value of frame pointer.  */
  xtensa_c0reg_t c0_rt[C0_NREGS];	/* Register tracking information.  */
d1049 3
d1273 1
a1273 2
		   xtensa_frame_cache_t *cache,
		   CORE_ADDR pc, CORE_ADDR litbase);
d1419 1
a1419 5
      unsigned int litbase_regnum = gdbarch_tdep (gdbarch)->litbase_regnum;
      CORE_ADDR litbase = (litbase_regnum == -1)
	? 0 : get_frame_register_unsigned (this_frame, litbase_regnum);

      call0_frame_cache (this_frame, cache, pc, litbase);
d1428 16
d2111 1
d2183 2
d2216 2
a2217 1
   the stack frame.  */
d2219 2
a2220 3
static void
call0_track_op (struct gdbarch *gdbarch,
		xtensa_c0reg_t dst[], xtensa_c0reg_t src[],
d2222 1
a2222 1
		CORE_ADDR pc, CORE_ADDR litbase, int spreg)
d2225 1
a2225 1
  unsigned litaddr, litval;
d2250 33
d2296 7
d2315 4
d2329 7
d2347 8
d2356 1
a2356 1
	gdb_assert_not_reached ("unexpected instruction kind");
d2358 1
d2361 1
a2361 1
/* Analyze prologue of the function at start address to determine if it uses 
d2363 7
a2369 7
   in the prologue up to the PC or just beyond the prologue, whichever is first.
   An 'entry' instruction indicates non-Call0 ABI and the end of the prologue.
   The prologue may overlap non-prologue instructions but is guaranteed to end
   by the first flow-control instruction (jump, branch, call or return).
   Since an optimized function may move information around and change the
   stack frame arbitrarily during the prologue, the information is guaranteed
   valid only at the point in the function indicated by the PC.
d2379 1
a2379 1
      nregs   Number of general registers to track (size of rt[] array).
d2381 1
a2381 5
      rt[]    Array[nregs] of xtensa_c0reg structures for register tracking info.
	      If NULL, registers are not tracked.
   Output args:
      call0   If != NULL, *call0 is set non-zero if Call0 ABI used, else 0
	      (more accurately, non-zero until 'entry' insn is encountered).
d2388 2
a2389 2
			CORE_ADDR start, CORE_ADDR pc, CORE_ADDR litbase,
			int nregs, xtensa_c0reg_t rt[], int *call0)
d2441 2
a2442 9
  if (call0 != NULL)
      *call0 = 1;

  if (rt != NULL)
    {
      rtmp = (xtensa_c0reg_t*) alloca(nregs * sizeof(xtensa_c0reg_t));
      /* rt is already initialized in xtensa_alloc_frame_cache().  */
    }
  else nregs = 0;
d2461 2
a2462 3
	  read_memory (ba, ibuf, bt - ba);
	  /* If there is a memory reading error read_memory () will report it
	     and then throw an exception, stopping command execution.  */
d2492 1
a2492 1
	rtmp[j] = rt[j];
d2503 1
a2503 2
	  DEBUGVERB ("[call0_analyze_prologue] instr "
		     "addr = 0x%08x, opc = %d\n", 
d2522 2
a2523 1
	    case c0opc_flow:
d2527 1
a2527 2
	      if (call0 != NULL)
		*call0 = 0;
d2532 1
a2532 2
	      if (call0 != NULL)
		*call0 = 1;
a2535 2
	  if (rt == NULL)
	    continue;
d2561 7
a2567 1
		nods = 2;
d2576 4
a2579 2
	  call0_track_op (gdbarch, rt, rtmp, opclass,
			  nods, odv, ia, litbase, 1);
d2594 1
a2594 2
		   xtensa_frame_cache_t *cache,
		   CORE_ADDR pc, CORE_ADDR litbase)
d2601 1
a2601 1
  int fp_regnum, c0_hasfp, c0_frmsz, prev_sp, to_stk;
d2603 4
d2612 1
a2612 4
      body_pc = call0_analyze_prologue (gdbarch, start_pc, pc, litbase,
					C0_NREGS,
					&cache->c0.c0_rt[0],
					&cache->call0);
d2615 5
a2619 2
	error (_("Xtensa-specific internal error: CALL0 prologue \
analysis failed in this frame. GDB command execution stopped."));
a2621 4
  sp = get_frame_register_unsigned
    (this_frame, gdbarch_tdep (gdbarch)->a0_base + 1);
  fp = sp; /* Assume FP == SP until proven otherwise.  */

d2624 2
a2625 2
     than DWARF info.  We don't not know for sure if PC is in the prologue,
     but we know no calls have yet taken place, so we can almost
d2648 29
a2676 1
  prev_sp = fp + c0_frmsz;
a2683 2
      /* Recalculate previous SP.  */
      prev_sp = fp + c0_frmsz;
d2700 3
a2702 4
      /* Special case for terminating backtrace at a function that
	 wants to be seen as the outermost.  Such a function will
	 clear it's RA (A0) register to 0 in the prologue instead of
	 saving its original value.  */
d2707 8
a2714 9
      /* RA was copied to another register or (before any function
	 call) may still be in the original RA register.  This is not
	 always reliable: even in a leaf function, register tracking
	 stops after prologue, and even in prologue, non-prologue
	 instructions (not tracked) may overwrite RA or any register
	 it was copied to.  If likely in prologue or before any call,
	 use retracking info and hope for the best (compiler should
	 have saved RA in stack if not in a leaf function).  If not in
	 prologue, too bad.  */
d2732 1
d3073 2
a3074 1
  body_pc = call0_analyze_prologue (gdbarch, start_pc, 0, 0, 0, NULL, NULL);
d3225 1
@


1.51
log
@2011-03-08  Maxim Grigoriev  <maxim2405@@gmail.com>

	* xtensa-tdep.c (call0_ret): New function.
	(xtensa_skip_prologue): Speed up analysis.
@
text
@d164 1
d174 1
d737 5
a741 1
static inline char xtensa_hextochar (int xdigit)
d743 1
a743 3
  static char hex[]="0123456789abcdef";

  return hex[xdigit & 0x0f];
d1287 2
a1288 2
  ps = (ps_regnum >= 0)
    ? get_frame_register_unsigned (this_frame, ps_regnum) : TX_PS;
d1923 1
d2082 2
a2083 1
typedef enum {
d2651 1
a2651 1
/* Simulate L32E insn:  AT <-- ref (AS + offset).  */
d2680 1
a2680 1
/* Simulate S32E insn:  AT --> ref (AS + offset).  */
d2696 2
a2697 1
typedef enum {
d2703 1
a2703 1
/* Execute insn stream from current PC until hitting RFWU or RFWO.
@


1.50
log
@2011-03-08  Maxim Grigoriev  <maxim2405@@gmail.com>

	* xtensa-tdep.c (xtensa_register_reggroup_p): Count in all registers
	while executing MI command -data-list-changed-registers.
@
text
@d2003 69
d2945 7
a2951 6
      /* In Call0, it is possible to have a function with only one instruction
	 ('ret') resulting from a 1-line optimized function that does nothing.
	 In that case, prologue_sal.end may actually point to the start of the
	 next function in the text section, causing a breakpoint to be set at
	 the wrong place.  Check if the end address is in a different function,
	 and if so return the start PC.  We know we have symbol info.  */
d2955 4
@


1.49
log
@2011-03-08  Maxim Grigoriev  <maxim2405@@gmail.com>

	* xtensa-tdep.c (xtensa_read_register): New function.
	(xtensa_write_register): New function.
	(xtensa_find_register_by_name): New function.
	(xtensa_windowed_frame_cache): Update comments in type description.
	(xtensa_frame_cache): Likewise.
	(xtensa_window_interrupt_insn): New function.
	(xtensa_frame_cache): Add analysis for Xtensa Window Exception frames.
	(xtensa_insn_kind): Add new instructions.
	(rwx_special_register): New function.
	(call0_classify_opcode): Add new instructions to the analysis.
	(a0_saved, a7_saved, a11_saved): New variables.
	(a0_was_saved, a7_was_saved, a11_was_saved): New variables.
	(execute_l32e): New function.
	(execute_s32e): New function.
	(xtensa_exception_handler_t): New type.
	(execute_code): New function.
	(xtensa_window_interrupt_frame_cache): New function to conduct frame
	analysis for Xtensa Window Exception handlers.
@
text
@d816 5
a835 2
  if (group == float_reggroup)
    return rg & xtRegisterGroupFloat;
d840 1
a840 1
  if (group == save_reggroup || group == restore_reggroup)
@


1.48
log
@2011-03-08  Maxim Grigoriev  <maxim2405@@gmail.com>

	* xtensa-tdep.c (TX_PS): New.
	(windowing_enabled): Update to count for Call0 ABI.
	(xtensa_hextochar): New.
	(xtensa_init_reggroups): Make algorithm generic.
	(xtensa_frame_cache): Use TX_PS on Tiny Xtensa.
@
text
@d164 15
d228 16
d941 4
a944 5
  int ws;		/* WINDOWSTART of the previous frame.  It
			   keeps track of life windows only.  If there
			   is no bit set for the window, that means it
			   had been already spilled because of window
			   overflow.  */
d946 2
a947 2
  /* Spilled A-registers from the previous frame.
     AREGS[i] == -1, if corresponding AR is alive.  */
d1001 4
a1004 4
  CORE_ADDR pc;		/* PC at the entry point to the function.  */
  CORE_ADDR ra;		/* The raw return address (without CALLINC).  */
  CORE_ADDR ps;		/* The PS register of this frame.  */
  CORE_ADDR prev_sp;	/* Stack Pointer of the previous frame.  */
d1097 32
d1260 5
d1372 2
a1373 3
	/* If RA is equal to 0 this frame is an outermost frame.
	   Leave cache->prev_sp unchanged marking the boundary of the
	   frame stack.  */
d1390 1
a1390 2
	      cache->prev_sp = get_frame_register_unsigned (this_frame,
							    regnum);
d1394 8
d2017 6
a2022 2
  c0opc_s32i,	       /* Storing word at fixed offset from a base
			  register.  */
d2026 18
d2068 4
d2101 6
d2136 1
a2136 1
      gdb_assert (nods == 3);
d2566 252
@


1.47
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* ui-file.c: Comment cleanup, mostly periods and spaces.
	* ui-file.h: Ditto.
	* ui-out.c: Ditto.
	* ui-out.h: Ditto.
	* utils.c: Ditto.
	* v850-tdep.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* value.h: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vax-tdep.c: Ditto.
	* vec.c: Ditto.
	* vec.h: Ditto.
	* version.h: Ditto.
	* windows-nat.c: Ditto.
	* windows-tdep.c: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xml-support.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* xtensa-tdep.c: Ditto.
	* xtensa-tdep.h: Ditto.
@
text
@d94 5
d124 10
a163 6
static inline int
windowing_enabled (CORE_ADDR ps)
{
  return ((ps & PS_EXC) == 0 && (ps & PS_WOE) != 0);
}

d704 7
d719 3
d726 5
a730 8
  xtensa_cp[0] = reggroup_new ("cp0", USER_REGGROUP);
  xtensa_cp[1] = reggroup_new ("cp1", USER_REGGROUP);
  xtensa_cp[2] = reggroup_new ("cp2", USER_REGGROUP);
  xtensa_cp[3] = reggroup_new ("cp3", USER_REGGROUP);
  xtensa_cp[4] = reggroup_new ("cp4", USER_REGGROUP);
  xtensa_cp[5] = reggroup_new ("cp5", USER_REGGROUP);
  xtensa_cp[6] = reggroup_new ("cp6", USER_REGGROUP);
  xtensa_cp[7] = reggroup_new ("cp7", USER_REGGROUP);
d1206 1
a1206 2
  char op1;
  int  windowed;
d1211 6
a1216 2
  ps = get_frame_register_unsigned (this_frame, gdbarch_ps_regnum (gdbarch));
  windowed = windowing_enabled (ps);
a1221 2
  pc = get_frame_register_unsigned (this_frame, gdbarch_pc_regnum (gdbarch));

d1224 2
d1250 1
a1250 1
	  cache->base = cache->prev_sp + 16;
d1842 1
d1844 2
a1845 2
      regcache_raw_read (regcache, gdbarch_ps_regnum (gdbarch), buf);
      ps = extract_unsigned_integer (buf, 4, byte_order) & ~0x00030000;
@


1.46
log
@run copyright.sh for 2011.
@
text
@d119 2
a120 1
/* Convert a live A-register number to the corresponding AR-register number.  */
d894 5
a898 4
  int ws;		/* WINDOWSTART of the previous frame.  It keeps track of
			   life windows only.  If there is no bit set for the
			   window, that means it had been already spilled
			   because of window overflow.  */
d907 2
a908 1
#define C0_MAXOPDS  3	/* Maximum number of operands for prologue analysis.  */
d935 3
a937 2
    int	    to_stk;	/* offset from original SP to register (4-byte aligned),
			   or C0_NOSTK if register has not been saved.  */
d945 2
a946 1
  int c0_hasfp;				/* Current frame uses frame pointer.  */
d1124 1
a1124 1
		 from A1. This is what we are looking for.  */
d1140 2
a1141 1
		  fp_regnum = gdbarch_tdep (gdbarch)->a0_base + register_operand;
d1175 1
a1175 2
	cache->prev_sp = SP of the previous frame.
*/
d1286 3
a1288 2
	/* If RA is equal to 0 this frame is an outermost frame.  Leave
	   cache->prev_sp unchanged marking the boundary of the frame stack.  */
d1305 2
a1306 1
	      cache->prev_sp = get_frame_register_unsigned (this_frame, regnum);
d1416 2
a1417 1
	      return frame_unwind_got_memory (this_frame, regnum, spe + stkofs);
d1483 2
a1484 1
			_("cannot extract return value of %d bytes long"), len);
d1624 2
a1625 2
      int offset;		/* stack offset if on stack */
      int regno;		/* regno if in register */
d1924 2
a1925 1
  c0opc_s32i,	       /* Storing word at fixed offset from a base register.  */
d2229 2
a2230 1
	  DEBUGVERB ("[call0_analyze_prologue] instr addr = 0x%08x, opc = %d\n", 
d2316 2
a2317 1
		   xtensa_frame_cache_t *cache, CORE_ADDR pc, CORE_ADDR litbase)
d2397 4
a2400 3
      /* Special case for terminating backtrace at a function that wants to
	 be seen as the outermost.  Such a function will clear it's RA (A0)
	 register to 0 in the prologue instead of saving its original value.  */
d2405 9
a2413 8
      /* RA was copied to another register or (before any function call) may
	 still be in the original RA register.  This is not always reliable:
	 even in a leaf function, register tracking stops after prologue, and
	 even in prologue, non-prologue instructions (not tracked) may overwrite
	 RA or any register it was copied to.  If likely in prologue or before
	 any call, use retracking info and hope for the best (compiler should
	 have saved RA in stack if not in a leaf function).  If not in prologue,
	 too bad.  */
d2684 1
a2684 1
  /* To call functions from GDB using dummy frame */
d2753 3
a2755 3
			    &xtensa_debug_level, _("\
Set Xtensa debugging."), _("\
Show Xtensa debugging."), _("\
@


1.45
log
@	* hppa-tdep.c (unwind_command): Use host_address_to_string function
	to display a host address.
	* monitor.c (monitor_read_memory): Likewise.
	* xtensa-tdep.c (xtensa_push_dummy_call): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005, 2006, 2007, 2008, 2009, 2010
@


1.44
log
@	* gdb_assert.h (gdb_assert_not_reached): New macro.
	(gdb_assert_fail): Fix typo in comment.
	* avr-tdep.c (avr_return_value): Use gdb_assert_not_reached instead of
	gdb_assert (0).
	* darwin-nat.c (darwin_check_new_threads): Ditto.
	* dwarf2read.c (dwarf2_get_section_info): Ditto.
	(munmap_section_buffer): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	(m32c_decode_srcdest4, m32c_decode_sd23, m32c_frame_base): Ditto.
	* macroexp.c (get_character_constant): Ditto.
	(get_string_literal): Ditto.
	* mep-tdep.c (mep_pseudo_cr_size): Ditto.
	(mep_pseudo_cr_index, mep_register_type): Ditto.
	(mep_pseudo_register_read, mep_pseudo_register_write): Ditto.
	(mep_get_insn, mep_analyze_prologue): Ditto.
	* objfiles.c (qsort_cmp): Ditto.
	* prologue-value.c (pv_is_identical): Ditto.
	* record.c (record_get_loc): Ditto.
	* value.c (value_static_field): Ditto.
	* xtensa-tdep.c (call0_track_op): Ditto.
@
text
@d1639 3
a1641 2
	  fprintf_unfiltered (gdb_stdlog, "%2d: 0x%lx %3d ",
			      i, (unsigned long) arg, TYPE_LENGTH (arg_type));
d1654 2
a1655 2
	  fprintf_unfiltered (gdb_stdlog, " 0x%lx\n",
			      (unsigned long) value_contents (arg));
@


1.43
log
@	* breakpoint.c (update_watchpoint, _initialize_breakpoint): Remove
	unnecessary space in string.
	* filesystem.c (_initialize_filesystem): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* infcmd.c (step_once): Ditto.
	* infrun.c (_initialize_infrun): Ditto.
	* linux-nat.c (linux_child_follow_fork): Ditto.
	* maint.c (maintenance_deprecate): Ditto.
	* memattr.c (_initialize_mem): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* monitor.c (monitor_open): Ditto.
	* procfs.c (procfs_xfer_memory): Ditto.
	* reverse.c (bookmarks_info): Ditto.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Ditto.
	* stack.c (_initialize_stack): Ditto.
	* tracepoint.c (_initialize_tracepoint): Ditto.
	* xtensa-tdep.c (xtensa_supply_gregset,
	xtensa_regset_from_core_section): Ditto.
@
text
@d2060 1
a2060 1
	gdb_assert (0);
@


1.42
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d814 1
a814 1
  DEBUGTRACE ("xtensa_supply_gregset (..., regnum==%d, ...) \n", regnum);
d872 1
a872 1
	      "(..., sect_name==\"%s\", sect_size==%x) \n",
@


1.41
log
@2009-10-21  Maxim Grigoriev  <maxim2405@@gmail.com>

        * xtensa-tdep.c (XTENSA_ISA_BADPC): New.
	(xtensa_scan_prologue): Replace read_memory with target_read_memory.
	(call0_analyze_prologue): Use XTENSA_ISA_BADPC instead of "0".
	(call0_frame_cache): Check error conditions on call0_analyze_prologue.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005, 2006, 2007, 2008, 2009
@


1.40
log
@
2009-09-18  Maxim Grigoriev  <maxim2405@@gmail.com>

        * xtensa-tdep.c (call0_analyze_prologue): Replace INT_MAX by UNIT_MAX.
@
text
@d1049 2
a1050 1
#define XTENSA_ISA_BSZ 32	    /* Instruction buffer size.  */
d1087 2
a1088 1
	  read_memory (ba, ibuf, bt - ba);
d2176 2
d2297 1
a2297 1
  return fail ? 0 : ia;
d2322 4
@


1.39
log
@	* ui-file.h (ui_file_xstrdup): Mention that the length argument
	may be NULL.
	* ui-file.c (ui_file_xstrdup): Don't dereference LENGTH if it is
	NULL.
	* aix-thread.c (aix_thread_extra_thread_info): Pass NULL as length
	parameter to ui_file_xstrdup.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* infrun.c (print_target_wait_results): Ditto.
	* language.c (add_language): Ditto.
	* linespec.c (cplusplus_error): Ditto.
	* remote.c (escape_buffer): Ditto.
	* typeprint.c (type_to_string): Ditto.
	* utils.c (error_stream): Ditto.
	* varobj.c (value_get_print_value): Ditto.
	* xtensa-tdep.c (xtensa_verify_config): Replace `dummy' local with
	`length' local.  Pass it to ui_file_xstrdup, and avoid an strlen
	call.
	* gdbarch.sh (verify_gdbarch): Ditto.
	* gdbarch.c: Regenerate.
	* cli/cli-setshow.c (do_setshow_command): Pass NULL as length
	parameter to ui_file_xstrdup.
	* python/python-frame.c (frapy_str): Ditto.
	* python/python-type.c (typy_str): Use the length local instead of
	calling strlen.
	* python/python-value.c (valpy_str): Pass NULL as length parameter
	to ui_file_xstrdup.
@
text
@d2128 1
a2128 1
  body_pc = INT_MAX;
@


1.39.2.1
log
@2009-09-19  Maxim Grigoriev  <maxim2405@@gmail.com>

        * xtensa-tdep.c (call0_analyze_prologue): Replace INT_MAX by UNIT_MAX.
@
text
@d2128 1
a2128 1
  body_pc = UINT_MAX;
@


1.38
log
@bfd
	* Makefile.am (dwarf2.lo): Use dwarf2.h, not elf/dwarf2.h.
	(elf-eh-frame.lo): Likewise.
	(elf32-bfin.lo): Likewise.
	(elf32-frv.lo): Likewise.
	(elf32-xc16x.lo): Likewise.
	* Makefile.in: Rebuild.
	* dwarf2.c: Included dwarf.h, not elf/dwarf2.h.
	* elf-eh-frame.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-xc16x.c: Likewise.
binutils
	* Makefile.am (dwarf.o): Refer to dwarf2.h, not elf/dwarf2.h.
	* Makefile.in: Rebuild.
	* dwarf.c: Include dwarf2.h, not elf/dwarf2.h.
gas
	* Makefile.am (DEPTC_alpha_ecoff): Refer to dwarf2.h, not
	elf/dwarf2.h.
	(DEPTC_alpha_elf): Likewise.
	(DEPTC_alpha_evax): Likewise.
	(DEPTC_arm_elf): Likewise.
	(DEPTC_hppa_elf): Likewise.
	(DEPTC_i386_aout): Likewise.
	(DEPTC_i386_coff): Likewise.
	(DEPTC_i386_elf): Likewise.
	(DEPTC_m68k_aout): Likewise.
	(DEPTC_m68k_coff): Likewise.
	(DEPTC_m68k_elf): Likewise.
	(DEPTC_mips_coff): Likewise.
	(DEPTC_mips_ecoff): Likewise.
	(DEPTC_mips_elf): Likewise.
	(DEPTC_ppc_coff): Likewise.
	(DEPTC_ppc_elf): Likewise.
	(DEPTC_s390_elf): Likewise.
	(DEPTC_sh_coff): Likewise.
	(DEPTC_sh_elf): Likewise.
	(DEPTC_sh64_elf): Likewise.
	(DEPTC_sparc_aout): Likewise.
	(DEPTC_sparc_coff): Likewise.
	(DEPTC_sparc_elf): Likewise.
	(as.o): Likewise.
	(dwarf2dbg.o): Likewise.
	(dw2gencfi.o): Likewise.
	(ehopt.o): Likewise.
	(read.o): Likewise.
	* Makefile.in: Rebuild.
	* dw2gencfi.h: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
gdb
	* dwarf2-frame.c: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2expr.c: Likewise.
	* dwarf2loc.c: Likewise.
	* dwarf2read.c: Likewise.
	* sh-tdep.c: Likewise.
	* xtensa-tdep.c: Likewise.
include
	* dwarf2.h: New file, moved from elf/.
include/elf

	* dwarf2.h: Move to `..'.
@
text
@d2501 1
a2501 1
  long dummy;
d2534 1
a2534 1
  buf = ui_file_xstrdup (log, &dummy);
d2536 1
a2536 1
  if (strlen (buf) > 0)
@


1.37
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d38 1
a38 1
#include "elf/dwarf2.h"
@


1.36
log
@	* gdbtypes.h (TYPE_OBJFILE_OWNED, TYPE_OWNER): New macros.
	(TYPE_OBJFILE, TYPE_ALLOC, TYPE_ZALLOC): Reimplement.
	(alloc_type_arch): Add prototype.
	(alloc_type_copy): Likewise.
	(get_type_arch): Likewise.
	(arch_type): Likewise.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.

	* gdbtypes.c (alloc_type): No longer support NULL objfile.
	(init_type): Likewise.
	(alloc_type_arch): New function.
	(alloc_type_copy): New function.
	(get_type_arch): New function.

	(smash_type): Preserve type ownership information.
	(make_pointer_type, make_reference_type, make_function_type,
	smash_to_memberptr_type, smash_to_method_type): No longer
	preserve OBJFILE across smash_type calls.
	(make_pointer_type, make_reference_type, make_function_type,
	lookup_memberptr_type, lookup_methodptr_type, allocate_stub_method,
	create_range_type, create_array_type, create_set_type, copy_type):
	Use alloc_type_copy when allocating types.
	(check_typedef): Use alloc_type_arch.
	(copy_type_recursive): Likewise.  Preserve type ownership data
	after copying type.
	(recursive_dump_type): Dump type ownership data.
	(alloc_type_instance): Update type ownership check.
	(copy_type, copy_type_recursive): Likewise.

	(arch_type): New function.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(append_flags_type_flag): Move down.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.
	(append_composite_type_field_aligned,
	append_composite_type_field): Move down.

	* gdbarch.c (gdbtypes_post_init): Allocate all types
	using per-architecture routines.
	* ada-lang.c (ada_language_arch_info): Likewise.
	* f-lang.c (build_fortran_types): Likewise.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* scm-lang.c (build_scm_types): Likewise.

	* ada-lang.c (ada_type_of_array): Use alloc_type_copy.
	(packed_array_type): Likewise.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_variant_branch_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_fixed_range_type): Likewise.
	(empty_record): Use type instead of objfile argument.
	Use alloc_type_copy.
	(to_fixed_variant_branch_type): Update call to empty_record.
	* jv-lang.c (type_from_class): Use alloc_type_arch.

	* arm-tdep.c (arm_ext_type): Allocate per-architecture type.
	* i386-tdep.c (i386_eflags_type, i386_mxcsr_type, i387_ext_type,
	i386_mmx_type, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_ext_type): Likewise.
	* m32c-tdep.c (make_types): Likewise.
	* m68k-tdep.c (m68k_ps_type, m68881_ext_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* sparc-tdep.c (sparc_psr_type, sparc_fsr_type): Likewise.
	* sparc64-tdep.c (sparc64_pstate_type, sparc64_fsr_type,
	sparc64_fprs_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* target-descriptions.c (tdesc_gdb_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
@
text
@d168 1
d177 1
a177 1
  insn = extract_unsigned_integer (buf, 3);
d187 1
a187 1
  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
d506 2
d524 1
a524 1
			     extract_unsigned_integer (buf, 4));
d604 2
d624 1
a624 1
			     extract_unsigned_integer (buf, 4));
d1181 1
d1206 1
a1206 1
      op1 = read_memory_integer (pc, 1);
d1267 2
a1268 2
	      sp = (CORE_ADDR) read_memory_integer (sp - 12, 4);
	      sp = (CORE_ADDR) read_memory_integer (sp - 12, 4);
d1288 1
a1288 1
	      cache->prev_sp = read_memory_integer (sp - 12, 4); 
d1600 1
d1744 1
a1744 1
      store_unsigned_integer (buf, REGISTER_SIZE, struct_addr);
d1780 1
a1780 2
	  if (n < REGISTER_SIZE
	      && gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
d1782 2
a1783 1
	      ULONGEST v = extract_unsigned_integer (cp, REGISTER_SIZE);
d1786 1
a1786 1
	      store_unsigned_integer (buf, REGISTER_SIZE, v);
d1813 1
a1813 1
      ps = extract_unsigned_integer (buf, 4) & ~0x00030000;
d1826 3
a1828 3
      regcache_cooked_write_unsigned (regcache,
				      gdbarch_tdep (gdbarch)->ws_regnum,
				      1 << extract_unsigned_integer (buf, 4));
d1980 2
a1981 1
call0_track_op (xtensa_c0reg_t dst[], xtensa_c0reg_t src[],
d1985 1
d2039 1
a2039 1
      litval = read_memory_integer(litaddr, 4);
d2092 2
a2093 1
call0_analyze_prologue (CORE_ADDR start, CORE_ADDR pc, CORE_ADDR litbase,
d2284 2
a2285 1
	  call0_track_op (rt, rtmp, opclass, nods, odv, ia, litbase, 1);
d2303 1
d2314 2
a2315 1
      body_pc = call0_analyze_prologue (start_pc, pc, litbase, C0_NREGS,
d2370 2
a2371 1
      read_memory_integer (sp + c0_frmsz + cache->c0.c0_rt[C0_RA].to_stk, 4);
d2490 1
a2490 1
  body_pc = call0_analyze_prologue(start_pc, 0, 0, 0, NULL, NULL);
@


1.35
log
@	* gdbtypes.h (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(struct builtin_type): New members builtin_int0, builtin_int8,
	builtin_uint8, builtin_int16, builtin_uint16, builtin_int32,
	builtin_uint32, builtin_int64, builtin_uint64, builtin_int128,
	and builtin_uint128.
	* gdbtypes.c (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize fixed-size integer types.

	* dwarf2expr.c (unsigned_address_type, signed_address_type): Add
	GDBARCH argument.  Return platform-specific type.
	(dwarf2_read_address, execute_stack_op): Update calls.

	* target-descriptions.c (tdesc_gdb_type): Use platform-specific types
	instead of global builtin_int_... variables.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	* printcmd.c (do_examine): Likewise.
	* jv-exp.y (parse_number): Likewise.

	* alpha-tdep.c (alpha_register_type, alpha_push_dummy_call,
	alpha_store_return_value): Likewise.
	* amd64-linux-tdep.c (amd64_linux_register_type): Likewise.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c h8300_register_type): Likewise.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_register_type,
	hppa64_register_type): Likewise.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Likewise.
	* iq2000-tdep.c (iq2000_register_type): Likewise.
	* lm32-tdep.c (lm32_register_type, lm32_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68hc11-tdep.c (m68hc11_register_type, m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m88k-tdep.c (m88k_register_type, m88k_store_arguments): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_register_type, mips_pseudo_register_type,
	mips_print_fp_register): Likewise.
	* moxie-tdep.c (moxie_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type, mt_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* score-tdep.c (score_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type, sparc32_store_arguments):
	Likewise.
	* sparc64-tdep.c (sparc64_register_type, sparc64_store_arguments):
	Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* xstormy16-tdep.c (xstormy16_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* mt-tdep.c (struct gdbarch_tdep): New data structure.
	(mt_gdbarch_init): Alloc TDEP structures.
	(mt_register_type): Cache coprocessor type in TDEP instead of
	static global variable.

	* xtensa-tdep.h (struct gdbarch_tdep): Add type_entries member.
	* xtensa-tdep.c (type_entries): Remove.
	(xtensa_register_type): Cache fixed-size types in TDEP instead
	of in global variable.
@
text
@d284 2
a285 3
		  tp->virtual_type = init_type (TYPE_CODE_INT, size,
						TYPE_FLAG_UNSIGNED, name,
						NULL);
@


1.34
log
@2009-05-05  Maxim Grigoriev  <maxim2405@@gmail.com>

	* xtensa-tdep.c (xtensa_frame_cache): Use pc instead of cache->pc.
@
text
@a216 7
static struct ctype_cache
{
  struct ctype_cache *next;
  int size;
  struct type *virtual_type;
} *type_entries = NULL;

d220 2
d223 4
a226 5
  if ((regnum >= gdbarch_tdep (gdbarch)->ar_base
      && regnum < gdbarch_tdep (gdbarch)->ar_base
		    + gdbarch_tdep (gdbarch)->num_aregs)
      || (regnum >= gdbarch_tdep (gdbarch)->a0_base
      && regnum < gdbarch_tdep (gdbarch)->a0_base + 16))
d230 1
a230 1
      || regnum == gdbarch_tdep (gdbarch)->a0_base + 1)
d237 1
a237 1
      xtensa_register_t* reg = &gdbarch_tdep (gdbarch)->regmap[regnum];
d251 1
a251 1
	      reg->ctype = builtin_type_uint8;
d255 1
a255 1
	      reg->ctype = builtin_type_uint16;
d259 1
a259 1
	      reg->ctype = builtin_type_uint32;
d263 1
a263 1
	      reg->ctype = builtin_type_uint64;
d267 1
a267 1
	      reg->ctype = builtin_type_uint128;
d271 1
a271 1
	      for (tp = type_entries; tp != NULL; tp = tp->next)
d279 2
a280 2
		  tp->next = type_entries;
		  type_entries = tp;
@


1.33
log
@	ARI fix: Do not use %p, replace by call to host_address_to_string
	for host pointers.
	* darwin-nat.c (darwin_xfer_partial): Apply change.
	* gnu-nat.c (inf_continue, gnu_xfer_memory): Ditto.
	* gnu-nat.h (proc_debug): Ditto.
	* symmisc.c (maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* windows-nat.c (handle_load_dll): Ditto.
	(handle_unload_dll, info_w32_command, handle_exception): Ditto.
	* xtensa-tdep.c (xtensa_unwind_pc): Ditto.
@
text
@d1245 1
a1245 1
	  cache->ra = (cache->pc & 0xc0000000) | (ra & 0x3fffffff);
@


1.32
log
@	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
        * alpha-linux-tdep.c (alpha_linux_regset_from_core_section): Make
	it static.
        * alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Declare.
        * amd64fbsd-tdep.c (amd64fbsd_init_abi): Make it static.
        * amd64nbsd-tdep.c (_initialize_amd64nbsd_ndep): Rename to ...
	(_initialize_amd64nbsd_tdep): ... this.
	* arm-linux-tdep.c (arm_linux_software_single_step): Make it static.
	(_initialize_arm_linux_tdep): Declare.
	* armbsd-tdep.c (armbsd_fpreg_offset): Make it static.
	* armnbsd-tdep.c (_initialize_arm_netbsd_tdep): Declare.
	* armobsd-tdep.c (_initialize_armobsd_tdep): Declare.
	* avr-tdep.c (avr_return_value): Make it static.
	(avr_frame_unwind_cache): Ditto.
	* bsd-uthread.c (bsd_uthread_inferior_created): Ditto.
	(bsd_uthread_solib_loaded): Ditto.
	(bsd_uthread_solib_unloaded): Ditto.
	(bsd_uthread_target): Ditto.
	(_initialize_bsd_uthread): Declare.
	* cris-tdep.c (crisv32_single_step_through_delay): Make it static.
	(cris_frame_unwind_cache): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_use_struct_convention): Ditto.
	(h8300h_use_struct_convention): Ditto.
	* hppa-tdep.c (hppa_sign_extend, hppa_low_hppa_sign_extend):
	Ditto.
	* hppa-tdep.h (hppa_low_sign_extend, hppa_sign_extend): Delete
	declarations.
	* hppabsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_find_global_pointer): Make it static.
	* hppabsd-tdep.h: New.
	* hppanbsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Remove declaration.
	(_initialize_hppabsd_tdep): Remove declaration.
	(_initialize_hppanbsd_tdep): Declare.
	* hppaobsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Delete declaration.
	(hppaobsd_init_abi): Make it static.
	* i386-nto-tdep.c (_initialize_i386nto_tdep): Declare.
	* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Declare.
	* ia64-linux-tdep.c (_initialize_ia64_linux_tdep): Declare.
	* ia64-tdep.c (ia64_register_reggroup_p): Make it static.
	* iq2000-tdep.c (_initialize_iq2000_tdep): Declare.
	* m32c-tdep.c (m32c_register_reggroup_p): Make it static.
	(m32c_analyze_prologue, m32c_virtual_frame_pointer): Ditto.
	(_initialize_m32c_tdep): Declare.
	* m32r-rom.c (_initialize_m32r_rom): Declare.
	* m32r-tdep.c (m32r_skip_prologue): Make it static.
	(m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Make it static.
	(m68hc11_return_value): Ditto.
	* m68klinux-tdep.c (_initialize_m68k_linux_tdep): Declare.
	* m88k-tdep.c (m88k_frame_cache): Make it static.
	* mep-tdep.c (mep_gdb_print_insn): Ditto.
	(mep_return_value): Ditto.
	(_initialize_mep_tdep): Declare.
	* mips-irix-tdep.c (_initialize_mips_irix_tdep): Declare.
	* mips-linux-tdep.c (supply_64bit_reg): Make it static.
	(mips_linux_syscall_next_pc): Ditto.
	(_initialize_mips_linux_tdep): Declare.
	* mips-tdep.c (mips_single_step_through_delay): Make it static.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Declare.
	* mn10300-linux-tdep.c (_initialize_mn10300_linux_tdep): Declare.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Declare.
	* mt-tdep.c (_initialize_mt_tdep): Declare.
	* nbsd-tdep.c: Include nbsd-tdep.h.
	* nto-tdep.c (find_load_phdr): Make it static.
	(_initialize_nto_tdep): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Make it
	static.
	(_initialize_ppc_linux_tdep): Declare.
	* remote-m32r-sdi.c (m32r_can_use_hw_watchpoint)
	(m32r_insert_watchpoint, m32r_remove_watchpoint)
	(m32r_stopped_data_address, m32r_stopped_by_watchpoint): Make
	static.
	* rs6000-aix-tdep.c (_initialize_rs6000_aix_tdep): Declare.
	* rs6000-nat.c: Include xcoffread.h.
	(find_toc_address): Don't extern declare get_toc_offset.  Adjust
	to call xcoff_get_to_offset.
	* rs6000-tdep.c (ppc_vsx_support_p, ppc_displaced_step_fixup)
	(rs6000_skip_main_prologue, rs6000_in_solib_return_trampoline)
	(rs6000_skip_trampoline_code): Make static.
	* s390-tdep.c (s390_regset_from_core_section): Ditto.
	* sh-tdep.c (sh_register_reggroup_p): Ditto.
	* shnbsd-tdep.c (shnbsd_regset_from_core_section): Ditto.
	(_initialize_shnbsd_tdep): Declare.
	* solib-frv.c (displacement_from_map): Make static.
	(_initialize_frv_solib): Declare.
	* solib-irix.c (fetch_lm_info): Make static.
	(_initialize_irix_solib): Declare.
	* solib-som.c: Include solib-som.h.
	(som_solib_select): Line break.
	* sparc-tdep.c (sparc_regset_from_core_section): Make static.
	* sparcnbsd-tdep.c (_initialize_sparnbsd_tdep): Rename to ...
	(_initialize_sparcnbsd_tdep): ... this.
	* spu-tdep.c (spu_software_single_step): Make it static.
	(_initialize_spu_tdep): Declare.
	* vax-tdep.c (vax_frame_cache): Make it static.
	* xcoffread.c: Include xcoffread.h.
	(get_toc_offset): Rename to ...
	(xcoff_get_toc_offset): ... this.
	(_initialize_xcoffread): Declare.
	* xcoffread.h: New.
	* xtensa-linux-tdep.c (_initialize_xtensa_linux_tdep): Declare.
	* xtensa-tdep.c (xtensa_skip_prologue, xtensa_derive_tdep): Make
	static.
	(_initialize_xtensa_tdep): Declare.
@
text
@d1021 2
a1022 1
  DEBUGTRACE ("xtensa_unwind_pc (next_frame = %p)\n", next_frame);
@


1.31
log
@2009-02-13  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* xtensa-tdep.c (call0_analyze_prologue): Delete BSZ macro.
	Replace BSZ macro uses by XTENSA_ISA_BSZ macro.
@
text
@d2448 1
a2448 1
CORE_ADDR
d2537 1
a2537 1
void
d2709 3
@


1.30
log
@        Updated copyright notices for most files.
@
text
@d2095 1
a2095 2
  #define BSZ 32	    /* Instruction buffer size.  */
  char ibuf[BSZ];	    /* Instruction buffer for decoding prologue.  */
d2155 1
a2155 1
  gdb_assert (BSZ >= xtensa_isa_maxlength (isa));
d2168 1
a2168 1
	  bt = (ba + BSZ) < body_pc ? ba + BSZ : body_pc;
@


1.29
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d3 2
a4 1
   Copyright (C) 2003, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.28
log
@	* gdbtypes.h (builtin_type_void): Remove macro, add declaration.
	(builtin_type_f_void): Remove macro.
	* gdbtypes.c (builtin_type_void): New global variable.
	(_initialize_gdbtypes): Initialize it.

	* gnu-v3-abi.c (build_gdb_vtable_type): Do not call
	lookup_pointer_type or lookup_function_type on builtin_type_void.
	* printcmd.c (set_next_address): Likewise.
	* objc-lang.c (value_nsstring): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* symfile.c (syms_from_objfile): Remove special handling
	of builtin_type_void and builtin_type_char.
@
text
@d232 1
a232 1
    return builtin_type_int;
d1018 1
d1023 1
d1025 1
a1025 2
  DEBUGINFO ("[xtensa_unwind_pc] pc = 0x%08x\n", (unsigned int)
	     extract_typed_address (buf, builtin_type_void_func_ptr));
d1027 1
a1027 1
  return extract_typed_address (buf, builtin_type_void_func_ptr);
d1681 2
a1682 1
	  if (TYPE_LENGTH (arg_type) < TYPE_LENGTH (builtin_type_long))
d1684 1
a1684 1
	      arg_type = builtin_type_long;
d1694 3
a1696 2
	  if (TYPE_LENGTH (arg_type) == TYPE_LENGTH (builtin_type_double))
	    info->align = TYPE_LENGTH (builtin_type_double);
d1698 1
a1698 1
	    info->align = TYPE_LENGTH (builtin_type_long);
d1703 1
a1703 1
	  info->align = TYPE_LENGTH (builtin_type_long);
@


1.27
log
@2008-05-21 Markus Deuling  <deuling@@de.ibm.com>
	   Maxim Grigoriev  <maxim2405@@gmail.com>

	* xtensa-tdep.c (xtensa_read_register): Remove.
	(xtensa_frame_cache): Get rid of xtensa_read_register. Pass extra
	argument litbase to call0_frame_cache().
	(call0_track_op, call0_analyze_prologue)
	(call0_frame_cache): Use extra argument litbase.
@
text
@d236 1
a236 1
    return lookup_pointer_type (builtin_type_void);
@


1.26
log
@	* gdbarch.sh: Delete dwarf_reg_to_regnum.
	* gdbarch.c, gdbarch.h: Regenerated.
	* amd64-tdep.c, arm-tdep.c, h8300-tdep.c, hppa-linux-tdep.c,
	hppa-tdep.c, i386-tdep.c, m32c-tdep.c, m68k-tdep.c, mips-tdep.c,
	s390-tdep.c, xtensa-tdep.c: Do not set dwarf_reg_to_regnum.

	* gdbint.texinfo (Target Conditionals): Delete entry for
	gdbarch_dwarf_reg_to_regnum.
@
text
@a213 9
static unsigned long
xtensa_read_register (int regnum)
{
  ULONGEST value;

  regcache_raw_read_unsigned (get_current_regcache (), regnum, &value);
  return (unsigned long) value;
}

d953 1
a953 1
  CORE_ADDR ps;		/* The PS register of the previous frame.  */
d1172 1
a1172 1
		   CORE_ADDR pc);
a1179 1
  unsigned int ps_regnum = gdbarch_ps_regnum (gdbarch);
d1187 2
a1188 1
  windowed = windowing_enabled (xtensa_read_register (ps_regnum));
d1194 1
a1194 2
  pc = get_frame_register_unsigned (this_frame,
				    gdbarch_pc_regnum (gdbarch));
a1202 1
      ps = get_frame_register_unsigned (this_frame, ps_regnum);
d1295 1
a1295 1
	      cache->prev_sp = xtensa_read_register (regnum);
d1301 5
a1305 1
      call0_frame_cache (this_frame, cache, pc);
d1977 1
a1977 1
		CORE_ADDR pc, int spreg)
d1979 1
a1979 1
  unsigned litbase, litaddr, litval;
a2028 4
      /* litbase = xtensa_get_litbase (pc); can be also used.  */
      litbase = (gdbarch_tdep (current_gdbarch)->litbase_regnum == -1)
	? 0 : xtensa_read_register
		(gdbarch_tdep (current_gdbarch)->litbase_regnum);
d2085 1
a2085 1
call0_analyze_prologue (CORE_ADDR start, CORE_ADDR pc,
d2277 1
a2277 1
	  call0_track_op (rt, rtmp, opclass, nods, odv, ia, 1);
d2292 1
a2292 1
		   xtensa_frame_cache_t *cache, CORE_ADDR pc)
d2305 1
a2305 1
      body_pc = call0_analyze_prologue (start_pc, pc, C0_NREGS,
d2479 1
a2479 1
  body_pc = call0_analyze_prologue(start_pc, 0, 0, NULL, NULL);
@


1.25
log
@2008-05-05  Maxim Grigoriev  <maxim2405@@gmail.com>

	* xtensa-tdep.c: Update for unwinder changes.
@
text
@d2653 1
a2653 1
  /* Renumber registers for known formats (stab, dwarf, and dwarf2).  */
a2654 1
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, xtensa_reg_to_regnum);
@


1.24
log
@2008-04-23  Maxim Grigoriev  <maxim2405@@gmail.com>

	* Makefile.in (xtensa-tdep.o): Update dependencies.
	* configure.tgt (xtensa*): Update dependencies.
	* xtensa-tdep.c (arreg_number): Renamed from areg_number.
	Local variable areg renamed to arreg.
	(areg_number): New function.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_extract_return_value, xtensa_store_return_value): areg_number
	replaced by arreg_number.
	(xtensa_windowed_frame_cache, struct xtensa_frame_cache): New comments.
	(xtensa_alloc_frame_cache): Initialize cache->wd.ws.
	(xtensa_scan_prologue): New function.
	(xtensa_frame_cache): New local fp_regnum. Handle separately the case,
	when ENTRY instraction hasn't been executed yet. Get the frame pointer
	value based on prologue analysis. Fix the bugs preventing WS and
	AR4-AR7/A11 registers from getting right values for intermediate frames,
	whose registers have been already spilled.
	(xtensa_frame_prev_register): Fix WS register value. Use are_number
	and arreg_number appropriately.
	(xtensa_gdbarch_init): Set solib_svr4_fetch_link_map_offsets to
	svr4_ilp32_fetch_link_map_offsets.
@
text
@d1040 1
a1040 1
xtensa_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d1044 1
a1044 1
  /* next_frame->prev is a dummy frame.  Return a frame ID of that frame.  */
d1046 3
a1048 5
  DEBUGTRACE ("xtensa_unwind_dummy_id ()\n");

  pc = frame_pc_unwind (next_frame);
  fp = frame_unwind_register_unsigned
	 (next_frame, gdbarch_tdep (gdbarch)->a0_base + 1);
d1179 1
a1179 1
call0_frame_cache (struct frame_info *next_frame,
d1184 1
a1184 1
xtensa_frame_cache (struct frame_info *next_frame, void **this_cache)
d1188 1
a1188 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
a1193 3
  DEBUGTRACE ("xtensa_frame_cache (next_frame %p, *this_cache %p)\n",
	      next_frame, this_cache ? *this_cache : (void*)0xdeadbeef);

d1203 2
a1204 2
  pc = frame_unwind_register_unsigned (next_frame,
				       gdbarch_pc_regnum (gdbarch));
d1209 5
a1213 5
      wb = frame_unwind_register_unsigned
	     (next_frame, gdbarch_tdep (gdbarch)->wb_regnum);
      ws = frame_unwind_register_unsigned
	     (next_frame, gdbarch_tdep (gdbarch)->ws_regnum);
      ps = frame_unwind_register_unsigned (next_frame, ps_regnum);
d1219 2
a1220 5
	  ra = frame_unwind_register_unsigned
	    (next_frame, gdbarch_tdep (gdbarch)->a0_base + callinc * 4);
	  
	  DEBUGINFO("[xtensa_frame_cache] 'entry' at 0x%08x\n (callinc = %d)",
		    (int)pc, callinc);
d1226 2
a1227 2
	  cache->prev_sp = frame_unwind_register_unsigned
			     (next_frame, gdbarch_tdep (gdbarch)->a0_base + 1);
d1245 2
a1246 2
	  ra = frame_unwind_register_unsigned
		 (next_frame, gdbarch_tdep (gdbarch)->a0_base);
d1252 1
a1252 1
	  cache->pc = frame_func_unwind (next_frame, NORMAL_FRAME);
d1263 2
a1264 2
	  sp = frame_unwind_register_unsigned
		 (next_frame, gdbarch_tdep (gdbarch)->a0_base + 1) - 16;
d1295 2
a1296 2
	      sp = frame_unwind_register_unsigned (next_frame,
		     gdbarch_tdep (gdbarch)->a0_base + 1);
d1312 1
a1312 1
      call0_frame_cache (next_frame, cache, pc);
d1316 1
a1316 1
  cache->base = frame_unwind_register_unsigned (next_frame, fp_regnum);
d1322 1
a1322 1
xtensa_frame_this_id (struct frame_info *next_frame,
d1327 1
a1327 5
    xtensa_frame_cache (next_frame, this_cache);
  struct frame_id id;

  DEBUGTRACE ("xtensa_frame_this_id (next 0x%lx, *this 0x%lx)\n",
	      (unsigned long) next_frame, (unsigned long) *this_cache);
d1332 1
a1332 57
  id = frame_id_build (cache->prev_sp, cache->pc);
  if (frame_id_eq (id, get_frame_id(next_frame)))
    {
      warning(_("\
Frame stack is corrupted. That could happen because of \
setting register(s) from GDB or stopping execution \
inside exception handler. Frame backtracing has stopped. \
It can make some GDB commands work inappropriately.\n"));
      cache->prev_sp = 0;
      return;
    }
  (*this_id) = id;
}

static int
call0_frame_get_reg_at_entry (struct frame_info *next_frame,
			      struct xtensa_frame_cache *cache,
			      int regnum, 
			      CORE_ADDR *addrp,
			      enum lval_type *lval,
			      gdb_byte *valuep)
{
  CORE_ADDR fp, spe;
  int stkofs;
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  int reg = (regnum >= gdbarch_tdep (gdbarch)->ar_base
	    && regnum <= (gdbarch_tdep (gdbarch)->ar_base + C0_NREGS))
	      ? regnum - gdbarch_tdep (gdbarch)->ar_base : regnum;

  /* Determine stack pointer on entry to this function, based on FP.  */
  spe = cache->c0.c0_fp - cache->c0.c0_rt[cache->c0.fp_regnum].fr_ofs;

  /* If register was saved to the stack frame in the prologue, retrieve it.  */
  stkofs = cache->c0.c0_rt[reg].to_stk;
  if (stkofs != C0_NOSTK)
    {
      *lval = lval_memory;
      *addrp = spe + stkofs;

      if (valuep)
	read_memory (*addrp, valuep, register_size (gdbarch, regnum));

      return 1;
    }

  /* If not callee-saved or if known to have been overwritten, give up.  */
  if (reg < C0_CLESV 
      || cache->c0.c0_rt[reg].fr_reg != reg
      || cache->c0.c0_rt[reg].fr_ofs != 0)
    return 0;

  if (get_frame_type (next_frame) != NORMAL_FRAME)
    /* TODO: Do we need a special case for DUMMY_FRAME here?  */
    return 0;

  return call0_frame_get_reg_at_entry (get_next_frame(next_frame),
				       cache, regnum, addrp, lval, valuep);
d1335 2
a1336 2
static void
xtensa_frame_prev_register (struct frame_info *next_frame,
d1338 1
a1338 6
			    int regnum,
			    int *optimizedp,
			    enum lval_type *lvalp,
			    CORE_ADDR *addrp,
			    int *realnump,
			    gdb_byte *valuep)
d1340 3
a1342 4
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct xtensa_frame_cache *cache =
    xtensa_frame_cache (next_frame, this_cache);
  CORE_ADDR saved_reg = 0;
d1345 3
a1347 5
  DEBUGTRACE ("xtensa_frame_prev_register (next 0x%lx, "
	      "*this 0x%lx, regnum %d (%s), ...)\n",
	      (unsigned long) next_frame,
	      *this_cache ? (unsigned long) *this_cache : 0, regnum,
	      xtensa_register_name (gdbarch, regnum));
d1368 1
a1368 10
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	store_unsigned_integer (valuep, 4, saved_reg);

      return;
    }
d1388 2
a1389 13
	    {
	      *optimizedp = 0;
	      *lvalp = lval_memory;
	      *addrp = cache->wd.aregs[areg];
	      *realnump = -1;

	      if (valuep)
		read_memory (*addrp, valuep,
			     register_size (gdbarch, regnum));

	      DEBUGINFO ("[xtensa_frame_prev_register] register on stack\n");
	      return;
	    }
d1411 2
a1412 11
	      *optimizedp = 0;
	      *lvalp = lval_memory;
	      *addrp = spe + stkofs;
	      *realnump = -1;
	  
	      if (valuep)
		read_memory (*addrp, valuep,
			     register_size (gdbarch, regnum));
	  
	      DEBUGINFO ("[xtensa_frame_prev_register] register on stack\n");
	      return;
d1420 1
a1420 6
  *optimizedp = 0;
  *lvalp = lval_register;
  *addrp = 0;
  *realnump = regnum;
  if (valuep)
    frame_unwind_register (next_frame, (*realnump), valuep);
d1425 1
a1425 1
xtensa_frame_unwind =
d1429 3
a1431 1
  xtensa_frame_prev_register
a1433 6
static const struct frame_unwind *
xtensa_frame_sniffer (struct frame_info *next_frame)
{
  return &xtensa_frame_unwind;
}

d1435 1
a1435 1
xtensa_frame_base_address (struct frame_info *next_frame, void **this_cache)
d1438 1
a1438 1
    xtensa_frame_cache (next_frame, this_cache);
d1446 1
a1446 1
  &xtensa_frame_unwind,
d2299 1
a2299 3
/* Initialize frame cache for the current frame.  The "next_frame" is the next
   one relative to current frame.  "cache" is the pointer to the data structure
   we have to initialize.  "pc" is curretnt PC.  */
d2302 1
a2302 1
call0_frame_cache (struct frame_info *next_frame,
d2305 1
a2305 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d2321 2
a2322 2
  sp = frame_unwind_register_unsigned
	 (next_frame, gdbarch_tdep (gdbarch)->a0_base + 1);
d2357 1
a2357 1
      fp = frame_unwind_register_unsigned (next_frame, fp_regnum);
d2399 1
a2399 1
      if (i < C0_NREGS) /* Read from the next_frame.  */
d2401 3
a2403 3
	  ra = frame_unwind_register_unsigned
		 (next_frame,
		  gdbarch_tdep (gdbarch)->a0_base + cache->c0.c0_rt[i].fr_reg);
d2689 1
a2689 1
  set_gdbarch_unwind_dummy_id (gdbarch, xtensa_unwind_dummy_id);
d2693 2
a2694 1
  frame_unwind_append_sniffer (gdbarch, xtensa_frame_sniffer);
@


1.23
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d22 1
d118 1
a118 1
/* Convert a live Ax register number to the corresponding Areg number.  */
d120 16
a135 1
areg_number (struct gdbarch *gdbarch, int regnum, ULONGEST wb)
d140 5
a144 5
  areg = regnum - tdep->a0_base;
  areg += (wb & ((tdep->num_aregs - 1) >> 2)) << WB_SHIFT;
  areg &= tdep->num_aregs - 1;

  return areg + tdep->ar_base;
d535 2
a536 1
      regnum = areg_number (gdbarch, regnum, extract_unsigned_integer (buf, 4));
d633 2
a634 1
      regnum = areg_number (gdbarch, regnum, extract_unsigned_integer (buf, 4));
d901 9
a909 3
  int wb;		/* Base for this frame; -1 if not in regfile.  */
  int callsize;		/* Call size to next frame.  */
  int ws;
d959 1
a959 1
  CORE_ADDR base;	/* Stack pointer of the next frame.  */
d961 3
a963 3
  CORE_ADDR ra;		/* The raw return address.  */
  CORE_ADDR ps;		/* The PS register of the frame.  */
  CORE_ADDR prev_sp;	/* Stack Pointer of the frame.  */
d1006 1
d1056 117
d1175 1
a1175 1
	cache->base    = SP of this frame;
d1192 1
d1236 13
d1252 1
d1259 5
a1265 5
      cache->pc = frame_func_unwind (next_frame, NORMAL_FRAME);
      cache->ra = (cache->pc & 0xc0000000) | (ra & 0x3fffffff);
      cache->ps = (ps & ~PS_CALLINC_MASK)
	| ((WINSIZE(ra)/4) << PS_CALLINC_SHIFT);

d1282 2
a1283 1
	      /* Read an SP of the previous frame.  */
d1288 1
a1288 1
	      for ( /* i=4  */ ; i < cache->wd.callsize; i++, sp += 4)
d1299 1
a1299 1
	  if (cache->wd.ws == 0)
d1303 3
a1305 4
	      cache->prev_sp =
		read_memory_integer (cache->wd.aregs[1],
				     register_size (gdbarch,
				       gdbarch_tdep (gdbarch)->a0_base + 1));
d1310 1
a1310 1
	      int regnum = areg_number
d1321 1
d1324 1
a1324 2
  cache->base = frame_unwind_register_unsigned
		  (next_frame, gdbarch_tdep (gdbarch)->a0_base + 1);
d1432 1
a1432 6
	{
	  if (cache->wd.ws != 0)
	    saved_reg = cache->wd.ws;
	  else
	    saved_reg = 1 << cache->wd.wb;
	}
d1457 2
a1458 1
      /* Convert A-register numbers to AR-register numbers.  */
d1461 1
a1461 1
	regnum = areg_number (gdbarch, regnum, cache->wd.wb);
d1463 1
a1463 1
      /* Check if AR-register has been saved to stack.  */
d1468 1
a1468 2
	  int areg = regnum - gdbarch_tdep (gdbarch)->ar_base
		       - (cache->wd.wb * 4);
d1598 1
a1598 1
      areg = areg_number (gdbarch,
d1648 2
a1649 2
      areg = areg_number (gdbarch,
			  gdbarch_tdep (gdbarch)->a0_base + 2 + callsize, wb);
d2821 3
@


1.22
log
@2008-02-11  Maxim Grigoriev  <maxim2405@@gmail.com>

	* NEWS (New native configurations): Xtensa GNU/Linux.
	(New targets): Xtensa GNU/Linux.
	* Makefile.in (ALL_TARGET_OBS): Add xtensa-linux-nat.o and
	xtensa-linux-tdep.o
	(ALLDEPFILES): Add xtensa-linux-tdep.c and xtensa-linux-nat.c
	(xtensa-linux-nat.o, xtensa-linux-tdep.o): New dependencies.
	* configure.tgt (xtensa*-*-linux*): New entry.
	* xtensa-config.c (xtensa_tdep): New variable.
	(xtensa_config_byte_order, xtensa_config_tdep): Removed.
	(rmap): Change format based on new macro XTREG.
	(XTENSA_CONFIG_INSTANTIATE): Use new macro defined in xtensa-tdep.h.
	* xtensa-linux-nat.c: New.
	* xtensa-linux-tdep.c: New.
	* xtensa-xtregs.c: New.
	* xtensa-tdep.h (xtensa_elf_gregset_t): Update.
	(XTENSA_ELF_NGREG, XTREG, XTREG_END, XTENSA_GDBARCH_TDEP_INSTANTIATE)
	(XCHAL_NUM_CONTEXTS, XCHAL_HAVE_EXCEPTIONS): New macros.
	(xtensa_register_t): New field coprocessor.
	(XTENSA_REGISTER_FLAGS_PRIVILEGED): Name spelling corrected.
	* xtensa-tdep.c (xtensa_config_tdep, xtensa_config_byte_order): Removed.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write):
	Update to handle privileged registers.
	(xtensa_supply_gregset) Remove exccause and excvaddr registers.
	(xtensa_push_dummy_call): Set windowstart register correctly.
	(call0_analyze_prologue): Initialize xtensa_default_isa.
	(xtensa_derive_tdep): New.
	(xtensa_gdbarch_init): Get rid of xtensa_config_byte_order and
	xtensa_config_tdep, use XCHAL_HAVE_BE and xtensa_tdep instead.
	Call xtensa_derive_tdep().
	* config/xtensa/linux.mh: New.
	* regformats/reg-xtensa.dat: New.
@
text
@d1522 1
@


1.21
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d54 1
d98 1
a98 1
   ? (gdbarch_tdep (gdbarch)->a0_base + 0) + C0_ARGS \
a100 4
extern struct gdbarch_tdep *xtensa_config_tdep (struct gdbarch_info *);
extern int xtensa_config_byte_order (struct gdbarch_info *);


d508 1
a508 1
		+ gdbarch_num_pseudo_regs (gdbarch))
d513 1
a513 1
      && (regnum >= gdbarch_tdep (gdbarch)->a0_base + 0)
d526 11
d603 1
a603 1
		+ gdbarch_num_pseudo_regs (gdbarch))
d608 1
a608 1
      && (regnum >= gdbarch_tdep (gdbarch)->a0_base + 0)
d624 7
a829 6
  if (regnum == gdbarch_tdep (gdbarch)->exccause_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (gdbarch)->exccause_regnum,
			 (char *) &regs->exccause);
  if (regnum == gdbarch_tdep (gdbarch)->excvaddr_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (gdbarch)->excvaddr_regnum,
			 (char *) &regs->excvaddr);
d1082 1
a1082 1
	    (next_frame, gdbarch_tdep (gdbarch)->a0_base + 0 + callinc * 4);
d1097 1
a1097 1
		 (next_frame, gdbarch_tdep (gdbarch)->a0_base + 0);
d1127 1
d1306 1
a1306 1
      if (regnum >= gdbarch_tdep (gdbarch)->a0_base + 0
d1452 1
a1452 1
      areg = gdbarch_tdep (gdbarch)->a0_base + 0 + C0_ARGS;
d1504 1
a1504 1
      areg = gdbarch_tdep (gdbarch)->a0_base + 0 + C0_ARGS;
d1782 10
d1797 1
a1797 1
	(regcache, gdbarch_tdep (gdbarch)->a0_base + 0, bp_addr);
d2121 2
d2366 1
a2366 2
		  gdbarch_tdep (gdbarch)->a0_base + 0
		    + cache->c0.c0_rt[i].fr_reg);
d2505 77
d2584 2
d2596 1
a2596 1
  info.byte_order = xtensa_config_byte_order (&info);
d2598 1
a2598 1
  tdep = xtensa_config_tdep (&info);
d2600 1
@


1.20
log
@	Updated copyright notices for most files.
@
text
@d2399 1
a2399 1
xtensa_skip_prologue (CORE_ADDR start_pc)
@


1.19
log
@	* gdbarch.sh (stab_reg_to_regnum, dwarf_reg_to_regnum)
	( dwarf2_reg_to_regnum, sdb_reg_to_regnum, ecoff_reg_to_regnum): Add
	gdbarch as parameter.
	* gdbarch.{c,h}: Regenerate.

	* xtensa-tdep.c (xtensa_reg_to_regnum): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* s390-tdep.c (s390_dwarf_reg_to_regnum): Likewise.
	* rs6000-tdep.c (rs6000_stab_reg_to_regnum)
	(rs6000_dwarf2_reg_to_regnum): Likewise.
	* mips-tdep.c (mips_stab_reg_to_regnum)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum): Likewise.
	* mep-tdep.c (mep_debug_reg_to_regnum): Likewise.
	* m32c-tdep.c (m32c_debug_info_reg_to_regnum): Likewise.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise
	* h8300-tdep.c (h8300s_dbg_reg_to_regnum)
	(h8300_dbg_reg_to_regnum): Likewise.
	* amd64-tdep.c (amd64_dwarf_reg_to_regnum): Likewise.
	* arch-utils.c (no_op_reg_to_regnum): Likewise.
	* arch-utils.h (no_op_reg_to_regnum): Likewise.
	* arm-tdep.c (arm_dwarf_reg_to_regnum): Likewise.
	* cris-tdep.c (cris_dwarf2_reg_to_regnum): Likewise.
	* hppa-tdep.c (hppa64_dwarf_reg_to_regnum): Likewise.
	* ia64-tdep.c (ia64_dwarf_reg_to_regnum): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.18
log
@	* amd64fsdb-tdep.c (amd64fbsd_sigtramp_start_addr): Use ULL suffix.
	(amd64fbsd_sigtramp_end_addr): Likewise.

	* iq2000-tdep.c (iq2000_pointer_to_address): Fix argument type.
	(iq2000_address_to_pointer): Likewise.
	(iq2000_frame_prev_register): Likewise.
	(iq2000_extract_return_value): Use regcache_cooked_read_unsigned
	instead of regcache_cooked_read into CORE_ADDR variable.
	(iq2000_return_value): Fix argument types.

	* m32r-rom.c (m32r_load_section): Fix printf argument type.
	(m32r_load): Likewise.

	* m68kbsd-tdep.c: Include "gdbtypes.h".
	* Makefile.in: Update dependencies.

	* mn10300-tdep.c (mn10300_frame_unwind_cache): Fix aliasing violation.

	* nto-tdep.c (LM_ADDR): Do not refer to no-longer-existing
	lmo->l_addr_size element.

	* remote-m32r-sdi.c (m32r_xfer_memory): Use paddr to print address.
	(m32r_insert_breakpoint): Likewise.
	(m32r_remove_breakpoint): Likewise.
	(m32r_insert_watchpoint): Likewise.
	(m32r_remove_watchpoint): Likewise.
	(m32r_load): Fix printf argument type.

	* xtensa-tdep.c (xtensa_regset_from_core_section): Fix printf
	argument type.
	(xtensa_frame_this_id): Do not cast pointers to "int" for output.
	(xtensa_frame_prev_register): Likewise.
	(xtensa_push_dummy_call): Likewise.
@
text
@d306 1
a306 1
xtensa_reg_to_regnum (int regnum)
d311 1
a311 1
    return gdbarch_tdep (current_gdbarch)->a0_base + regnum;
d314 1
a314 2
       i < gdbarch_num_regs (current_gdbarch)
	   + gdbarch_num_pseudo_regs (current_gdbarch);
d316 1
a316 1
    if (regnum == gdbarch_tdep (current_gdbarch)->regmap[i].target_number)
@


1.17
log
@2007-11-12  Markus Deuling  <deuling@@de.ibm.com>

	* xtensa-tdep.c (ARG_1ST): Replace ARGS_FIRST_REG by its expression.
	(ARGS_FIRST_REG): Remove.
	(areg_numer): New function.
	(xtensa_pseudo_register_read, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value)
	(xtensa_frame_cache): Replace AREG_NUMBER by areg_number.
	(AREG_NUMBER): Remove.
	(XTENSA_IS_ENTRY, ARG_NOF, ARG_1ST): Add gdbarch as parameter.
	(xtensa_frame_cache): Update use of XTENSA_IS_ENTRY.
	(xtensa_push_dummy_call): Update use of ARG_NOF.
	(extract_call_winsize): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_extract_return_value, xtensa_store_return_value): Update call
	of extract_call_winsize.
@
text
@d857 1
a857 1
	      sect_name, sect_size);
d1172 2
a1173 2
  DEBUGTRACE ("xtensa_frame_this_id (next 0x%08x, *this 0x%08x)\n",
	      (unsigned int) next_frame, (unsigned int) *this_cache);
d1253 4
a1256 4
  DEBUGTRACE ("xtensa_frame_prev_register (next 0x%08x, "
	      "*this 0x%08x, regnum %d (%s), ...)\n",
	      (unsigned int) next_frame,
	      *this_cache ? (unsigned int) *this_cache : 0, regnum,
d1593 2
a1594 2
	  fprintf_unfiltered (gdb_stdlog, "%2d: 0x%08x %3d ",
			      i, (int) arg, TYPE_LENGTH (arg_type));
d1607 2
a1608 2
	  fprintf_unfiltered (gdb_stdlog, " 0x%08x\n",
			      (unsigned int) value_contents (arg));
@


1.16
log
@*** empty log message ***
@
text
@a80 1
#define ARGS_FIRST_REG		gdbarch_tdep (current_gdbarch)->a0_base + 6
a90 8

/* Convert a live Ax register number to the corresponding Areg number.  */
#define AREG_NUMBER(r, wb) \
  ((((r) - (gdbarch_tdep (current_gdbarch)->a0_base + 0) + (((wb) \
  & ((gdbarch_tdep (current_gdbarch)->num_aregs - 1) >> 2)) << WB_SHIFT)) & \
  (gdbarch_tdep (current_gdbarch)->num_aregs - 1)) \
  + gdbarch_tdep (current_gdbarch)->ar_base)

d92 7
a98 6
#define ARG_NOF	    (gdbarch_tdep (current_gdbarch)->call_abi \
		      == CallAbiCall0Only ? C0_NARGS : (ARGS_NUM_REGS))
#define ARG_1ST	    (gdbarch_tdep (current_gdbarch)->call_abi \
		      == CallAbiCall0Only \
		    ? (gdbarch_tdep (current_gdbarch)->a0_base + 0) + C0_ARGS \
		      : (ARGS_FIRST_REG))
d107 2
a108 2
#define XTENSA_IS_ENTRY(op1) \
  ((gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG) \
d120 14
d152 1
a152 1
extract_call_winsize (CORE_ADDR pc)
d172 1
a172 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
d523 1
a523 1
      regnum = AREG_NUMBER (regnum, extract_unsigned_integer (buf, 4));
d609 1
a609 1
      regnum = AREG_NUMBER (regnum, extract_unsigned_integer (buf, 4));
d1070 1
a1070 1
      if (XTENSA_IS_ENTRY (op1))
d1144 2
a1145 2
	      int regnum = AREG_NUMBER
			     (gdbarch_tdep (gdbarch)->a0_base + 1,
d1299 1
a1299 1
	regnum = AREG_NUMBER (regnum, cache->wd.wb);
d1426 1
a1426 1
      callsize = extract_call_winsize (pc);
d1437 2
a1438 1
      areg = AREG_NUMBER(gdbarch_tdep (gdbarch)->a0_base + 2 + callsize, wb);
d1481 1
a1481 1
      callsize = extract_call_winsize (pc);
d1487 2
a1488 1
      areg = AREG_NUMBER (gdbarch_tdep (gdbarch)->a0_base + 2 + callsize, wb);
d1669 1
a1669 1
      if (size + info->length > REGISTER_SIZE * ARG_NOF)
d1678 1
a1678 1
	  info->u.regno = ARG_1ST + size / REGISTER_SIZE;
d1699 1
a1699 1
      regcache_cooked_write (regcache, ARG_1ST, buf);
@


1.15
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d1791 2
a1792 1
xtensa_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
d1801 1
a1801 1
  if (gdbarch_tdep (current_gdbarch)->isa_use_density_instructions)
d1803 1
a1803 1
      if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d1816 1
a1816 1
      if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
@


1.14
log
@2007-10-10  Markus Deuling  <deuling@@de.ibm.com>

	* xtensa-tdep.c (xtensa_register_type, xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write, xtensa_register_reggroup_p)
	(xtensa_unwind_pc, xtensa_unwind_dummy_id, xtensa_push_dummy_call)
	(xtensa_dump_tdep): Replace current_gdbarch by gdbarch.
	(xtensa_register_write_masked, xtensa_register_read_masked)
	(xtensa_supply_gregset, xtensa_store_return_value)
	(xtensa_extract_return_value): Use get_regcache_arch to get at the
	current architecture by regcache.
	(xtensa_frame_cache, call0_frame_get_reg_at_entry, call0_frame_cache)
	(xtensa_frame_prev_register): Use get_frame_arch to get at the current
	architecture by frame_info.
@
text
@d184 1
a184 1
xtensa_register_name (int regnum)
d187 3
a189 3
  if (regnum >= 0 && regnum < gdbarch_num_regs (current_gdbarch)
			      + gdbarch_num_pseudo_regs (current_gdbarch))
    return gdbarch_tdep (current_gdbarch)->regmap[regnum].name;
d503 1
a503 1
	      regnum, xtensa_register_name (regnum));
d539 1
a539 1
		       xtensa_register_name (regnum));
d587 1
a587 1
	      regnum, xtensa_register_name (regnum));
d627 1
a627 1
		       xtensa_register_name (regnum));
d1251 1
a1251 1
	      xtensa_register_name (regnum));
@


1.13
log
@2007-10-09  Markus Deuling  <deuling@@de.ibm.com>

	* xtensa-tdep.c: Replace following current-gdbarch based macros by
	their expression:
	(xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write): XTENSA_TARGET_FLAGS.
	(ARG_NOF, ARG_1ST, xtensa_extract_return_value)
	(xtensa_store_return_value, xtensa_push_dummy_call): CALL_ABI.
	(xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write): ISA_USE_WINDOWED_REGISTERS.
	(xtensa_breakpoint_from_pc): ISA_USE_DENSITY_INSTRUCTIONS.
	(xtensa_register_type, xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register): NUM_AREGS.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write,
	(xtensa_supply_gregset, xtensa_frame_cache, xtensa_frame_prev_register,
	(xtensa_extract_return_value, xtensa_store_return_value): WB_REGNUM.
	(xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register): WS_REGNUM.
	(xtensa_supply_gregset): LBEG_REGNUM, LEND_REGNUM, LCOUNT_REGNUM,
	SAR_REGNUM, EXCCAUSE_REGNUM, EXCVADDR_REGNUM
	(xtensa_register_name, xtensa_register_type, xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_register_reggroup_p): REGMAP.
	(call0_track_op): LITBASE_REGNUM.
	(xtensa_register_type, xtensa_reg_to_regnum, call0_frame_cache):A0_BASE
	(xtensa_supply_gregset, call0_frame_get_reg_at_entry)
	(xtensa_frame_prev_register, AREG_NUMBER)
	(xtensa_register_type): AR_BASE.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write): FP_ALIAS.
	(AREG_NUMBER): AREGS_MASK, WB_MASK, A0_REGNUM.
	(ARG_1ST, xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value)
	(xtensa_push_dummy_call, call0_frame_cache): A0_REGNUM.
	(xtensa_register_type, xtensa_pseudo_register_read, xtensa_frame_cache)
	(xtensa_pseudo_register_write, xtensa_unwind_dummy_id)
	(xtensa_frame_prev_register, xtensa_push_dummy_call)
	(call0_frame_cache): A1_REGNUM.
	(xtensa_extract_return_value, xtensa_store_return_value): A2_REGNUM.
	(xtensa_push_dummy_call): A4_REGNUM.
	(ARGS_FIRST_REG): A6_REGNUM.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): A15_REGNUM.
	* xtensa-tdep.h: Delete current_gdbarch based macros after replacing
	them in the appropriate source file:
	XTENSA_TARGET_FLAGS, SPILL_LOCATION, SPILL_SIZE, CALL_ABI, NUM_AREGS,
	ISA_USE_WINDOWED_REGISTERS, ISA_USE_DENSITY_INSTRUCTIONS, WB_REGNUM,
	ISA_USE_EXCEPTIONS, ISA_USE_EXT_L32R, DEBUG_DATA_VADDR_TRAP_COUNT,
	DEBUG_INST_VADDR_TRAP_COUNT, ISA_MAX_INSN_SIZE, DEBUG_NUM_IBREAKS,
	DEBUG_NUM_DBREAKS, WS_REGNUM, LBEG_REGNUM, LEND_REGNUM, SAR_REGNUM,
	REGMAP, LITBASE_REGNUM, DEBUGCAUSE_REGNUM, EXCCAUSE_REGNUM, AR_BASE,
	EXCVADDR_REGNUM, NUM_IBREAKS, REGMAP_BYTES, NUM_CONTEXTS, FP_ALIAS,
	FP_LAYOUT, FP_LAYOUT_BYTES, GREGMAP, AREGS_MASK, WB_MASK, A0_REGNUM,
	A1_REGNUM, A2_REGNUM, A3_REGNUM, A4_REGNUM, A5_REGNUM, A6_REGNUM,
	A7_REGNUM, A8_REGNUM, A9_REGNUM, A10_REGNUM, A11_REGNUM, A12_REGNUM,
	A13_REGNUM, A14_REGNUM, A15_REGNUM.
@
text
@d217 5
a221 5
  if ((regnum >= gdbarch_tdep (current_gdbarch)->ar_base
      && regnum < gdbarch_tdep (current_gdbarch)->ar_base
		    + gdbarch_tdep (current_gdbarch)->num_aregs)
      || (regnum >= gdbarch_tdep (current_gdbarch)->a0_base
      && regnum < gdbarch_tdep (current_gdbarch)->a0_base + 16))
d224 2
a225 2
  if (regnum == gdbarch_pc_regnum (current_gdbarch)
      || regnum == gdbarch_tdep (current_gdbarch)->a0_base + 1)
d229 2
a230 2
  else if (regnum >= 0 && regnum < gdbarch_num_regs (current_gdbarch)
				   + gdbarch_num_pseudo_regs (current_gdbarch))
d232 1
a232 1
      xtensa_register_t* reg = &gdbarch_tdep (current_gdbarch)->regmap[regnum];
d345 1
a345 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d475 1
a475 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d505 3
a507 3
  if (regnum == gdbarch_num_regs (current_gdbarch)
		+ gdbarch_num_pseudo_regs (current_gdbarch))
     regnum = gdbarch_tdep (current_gdbarch)->a0_base + 1;
d510 3
a512 3
  if (gdbarch_tdep (current_gdbarch)->isa_use_windowed_registers
      && (regnum >= gdbarch_tdep (current_gdbarch)->a0_base + 0)
      && (regnum <= gdbarch_tdep (current_gdbarch)->a0_base + 15))
d516 1
a516 2
      regcache_raw_read (regcache,
			 gdbarch_tdep (current_gdbarch)->wb_regnum, buf);
d521 1
a521 1
  if (regnum >= 0 && regnum < gdbarch_num_regs (current_gdbarch))
d526 2
a527 2
	    && regnum < gdbarch_num_regs (current_gdbarch)
			+ gdbarch_num_pseudo_regs (current_gdbarch))
d529 1
a529 1
      xtensa_register_t *reg = &gdbarch_tdep (current_gdbarch)->regmap[regnum];
d531 1
a531 1
      int flags = gdbarch_tdep (current_gdbarch)->target_flags;
d589 3
a591 3
  if (regnum == gdbarch_num_regs (current_gdbarch)
		+ gdbarch_num_pseudo_regs (current_gdbarch))
     regnum = gdbarch_tdep (current_gdbarch)->a0_base + 1;
d594 3
a596 3
  if (gdbarch_tdep (current_gdbarch)->isa_use_windowed_registers
      && (regnum >= gdbarch_tdep (current_gdbarch)->a0_base + 0)
      && (regnum <= gdbarch_tdep (current_gdbarch)->a0_base + 15))
d602 1
a602 1
			 gdbarch_tdep (current_gdbarch)->wb_regnum, buf);
d608 1
a608 1
  if (regnum >= 0 && regnum < gdbarch_num_regs (current_gdbarch))
d613 2
a614 2
	   && regnum < gdbarch_num_regs (current_gdbarch)
		       + gdbarch_num_pseudo_regs (current_gdbarch))
d616 1
a616 1
      xtensa_register_t *reg = &gdbarch_tdep (current_gdbarch)->regmap[regnum];
d618 1
a618 1
      int flags = gdbarch_tdep (current_gdbarch)->target_flags;
d735 1
a735 1
  xtensa_register_t* reg = &gdbarch_tdep (current_gdbarch)->regmap[regnum];
d762 1
a762 1
    return (regnum < gdbarch_num_regs (current_gdbarch)
d783 1
d788 6
a793 9
  if (regnum == gdbarch_pc_regnum (current_gdbarch) || regnum == -1)
    regcache_raw_supply (rc,
			 gdbarch_pc_regnum (current_gdbarch),
			 (char *) &regs->pc);
  if (regnum == gdbarch_ps_regnum (current_gdbarch) || regnum == -1)
    regcache_raw_supply (rc, gdbarch_ps_regnum (current_gdbarch),
			 (char *) &regs->ps);
  if (regnum == gdbarch_tdep (current_gdbarch)->wb_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (current_gdbarch)->wb_regnum,
d795 2
a796 2
  if (regnum == gdbarch_tdep (current_gdbarch)->ws_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (current_gdbarch)->ws_regnum,
d798 2
a799 2
  if (regnum == gdbarch_tdep (current_gdbarch)->lbeg_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (current_gdbarch)->lbeg_regnum,
d801 2
a802 2
  if (regnum == gdbarch_tdep (current_gdbarch)->lend_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (current_gdbarch)->lend_regnum,
d804 2
a805 2
  if (regnum == gdbarch_tdep (current_gdbarch)->lcount_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (current_gdbarch)->lcount_regnum,
d807 2
a808 2
  if (regnum == gdbarch_tdep (current_gdbarch)->sar_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (current_gdbarch)->sar_regnum,
d810 2
a811 3
  if (regnum == gdbarch_tdep (current_gdbarch)->exccause_regnum
      || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (current_gdbarch)->exccause_regnum,
d813 2
a814 2
  if (regnum == gdbarch_tdep (current_gdbarch)->excvaddr_regnum || regnum == -1)
    regcache_raw_supply (rc, gdbarch_tdep (current_gdbarch)->excvaddr_regnum,
d816 3
a818 3
  if (regnum >=gdbarch_tdep (current_gdbarch)->ar_base
      && regnum < gdbarch_tdep (current_gdbarch)->ar_base
		    + gdbarch_tdep (current_gdbarch)->num_aregs)
d821 1
a821 1
			   (current_gdbarch)->ar_base]);
d824 2
a825 2
      for (i = 0; i < gdbarch_tdep (current_gdbarch)->num_aregs; ++i)
	regcache_raw_supply (rc, gdbarch_tdep (current_gdbarch)->ar_base + i,
d991 1
a991 1
  frame_unwind_register (next_frame, gdbarch_pc_regnum (current_gdbarch), buf);
d1011 1
a1011 1
	 (next_frame, gdbarch_tdep (current_gdbarch)->a0_base + 1);
d1034 2
a1035 1
  unsigned int ps_regnum = gdbarch_ps_regnum (current_gdbarch);
d1052 1
a1052 1
				       gdbarch_pc_regnum (current_gdbarch));
d1058 1
a1058 1
	     (next_frame, gdbarch_tdep (current_gdbarch)->wb_regnum);
d1060 1
a1060 1
	     (next_frame, gdbarch_tdep (current_gdbarch)->ws_regnum);
d1068 1
a1068 2
	    (next_frame,
	     gdbarch_tdep (current_gdbarch)->a0_base + 0 + callinc * 4);
d1078 1
a1078 2
			     (next_frame, gdbarch_tdep
					    (current_gdbarch)->a0_base + 1);
d1083 1
a1083 1
		 (next_frame, gdbarch_tdep (current_gdbarch)->a0_base + 0);
d1086 1
a1086 1
			  & (gdbarch_tdep (current_gdbarch)->num_aregs / 4 - 1);
d1101 1
a1101 1
		 (next_frame, gdbarch_tdep (current_gdbarch)->a0_base + 1) - 16;
d1132 2
a1133 3
				     register_size (current_gdbarch,
				       gdbarch_tdep (current_gdbarch)->a0_base
						     + 1));
d1139 1
a1139 1
			     (gdbarch_tdep (current_gdbarch)->a0_base + 1,
d1152 1
a1152 1
		  (next_frame, gdbarch_tdep (current_gdbarch)->a0_base + 1);
d1196 4
a1199 3
  int reg = (regnum >= gdbarch_tdep (current_gdbarch)->ar_base
	    && regnum <= (gdbarch_tdep (current_gdbarch)->ar_base + C0_NREGS))
	      ? regnum - gdbarch_tdep (current_gdbarch)->ar_base : regnum;
d1212 1
a1212 1
	read_memory (*addrp, valuep, register_size (current_gdbarch, regnum));
d1241 1
d1253 1
a1253 1
  if (regnum ==gdbarch_pc_regnum (current_gdbarch))
d1255 1
a1255 1
  else if (regnum == gdbarch_tdep (current_gdbarch)->a0_base + 1)
d1259 1
a1259 1
      if (regnum == gdbarch_tdep (current_gdbarch)->ws_regnum)
d1266 1
a1266 1
      else if (regnum == gdbarch_tdep (current_gdbarch)->wb_regnum)
d1268 1
a1268 1
      else if (regnum == gdbarch_ps_regnum (current_gdbarch))
d1291 2
a1292 2
      if (regnum >= gdbarch_tdep (current_gdbarch)->a0_base + 0
          && regnum <= gdbarch_tdep (current_gdbarch)->a0_base + 15)
d1296 3
a1298 3
      if (regnum >= gdbarch_tdep (current_gdbarch)->ar_base
	  && regnum <= (gdbarch_tdep (current_gdbarch)->ar_base
			 + gdbarch_tdep (current_gdbarch)->num_aregs))
d1300 1
a1300 1
	  int areg = regnum - gdbarch_tdep (current_gdbarch)->ar_base
d1314 1
a1314 1
			     register_size (current_gdbarch, regnum));
d1323 2
a1324 2
      int reg = (regnum >= gdbarch_tdep (current_gdbarch)->ar_base
		&& regnum <= (gdbarch_tdep (current_gdbarch)->ar_base
d1326 1
a1326 1
		  ? regnum - gdbarch_tdep (current_gdbarch)->ar_base : regnum;
d1347 1
a1347 1
			     register_size (current_gdbarch, regnum));
d1405 1
d1416 1
a1416 1
  if (gdbarch_tdep (current_gdbarch)->call_abi != CallAbiCall0Only)
d1419 1
a1419 2
      regcache_raw_read_unsigned (regcache,
			      gdbarch_pc_regnum (current_gdbarch), &pc);
d1430 2
a1431 3
	(regcache, gdbarch_tdep (current_gdbarch)->wb_regnum, &wb);
      areg = AREG_NUMBER(gdbarch_tdep (current_gdbarch)->a0_base + 2 + callsize,
			 wb);
d1436 1
a1436 1
      areg = gdbarch_tdep (current_gdbarch)->a0_base + 0 + C0_ARGS;
d1441 1
a1441 1
  if (len < 4 && gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d1459 1
d1469 1
a1469 1
  if (gdbarch_tdep (current_gdbarch)->call_abi != CallAbiCall0Only)
d1471 3
a1473 4
      regcache_raw_read_unsigned
	(regcache, gdbarch_tdep (current_gdbarch)->wb_regnum, &wb);
  regcache_raw_read_unsigned (regcache,
			      gdbarch_pc_regnum (current_gdbarch), &pc);
d1480 1
a1480 2
      areg = AREG_NUMBER
	       (gdbarch_tdep (current_gdbarch)->a0_base + 2 + callsize, wb);
d1487 1
a1487 1
      areg = gdbarch_tdep (current_gdbarch)->a0_base + 0 + C0_ARGS;
d1490 1
a1490 1
  if (len < 4 && gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d1679 1
a1679 1
  if ((gdbarch_tdep (current_gdbarch)->call_abi != CallAbiCall0Only)
d1708 1
a1708 1
	      && gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d1727 1
a1727 1
	      && gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d1755 1
a1755 1
  if (gdbarch_tdep (current_gdbarch)->call_abi != CallAbiCall0Only)
d1758 1
a1758 1
      regcache_raw_read (regcache, gdbarch_ps_regnum (current_gdbarch), buf);
d1761 1
a1761 1
	(regcache, gdbarch_tdep (current_gdbarch)->a0_base + 4, ra);
d1763 1
a1763 1
				      gdbarch_ps_regnum (current_gdbarch),
d1770 1
a1770 1
	(regcache, gdbarch_tdep (current_gdbarch)->a0_base + 0, bp_addr);
d1775 1
a1775 2
				  gdbarch_tdep (current_gdbarch)->a0_base + 1,
				  sp);
d2238 1
d2255 1
a2255 1
	 (next_frame, gdbarch_tdep (current_gdbarch)->a0_base + 1);
d2274 1
a2274 1
      fp_regnum += gdbarch_tdep (current_gdbarch)->a0_base;
d2279 1
a2279 1
      fp_regnum = gdbarch_tdep (current_gdbarch)->a0_base + C0_SP;
d2336 1
a2336 1
		  gdbarch_tdep (current_gdbarch)->a0_base + 0 
d2563 1
a2563 1
xtensa_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
@


1.12
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d81 1
a81 1
#define ARGS_FIRST_REG		A6_REGNUM
d95 4
a98 1
  ((((r) - A0_REGNUM + (((wb) & WB_MASK) << WB_SHIFT)) & AREGS_MASK) + AR_BASE)
d101 6
a106 3
#define ARG_NOF	    (CALL_ABI == CallAbiCall0Only ? C0_NARGS : (ARGS_NUM_REGS))
#define ARG_1ST	    (CALL_ABI == CallAbiCall0Only \
		     ? (A0_REGNUM) + C0_ARGS : (ARGS_FIRST_REG))
d189 1
a189 1
    return REGMAP[regnum].name;
d217 5
a221 2
  if ((regnum >= AR_BASE && regnum < AR_BASE + NUM_AREGS)
      || (regnum >= A0_BASE && regnum < A0_BASE + 16))
d224 2
a225 1
  if (regnum == gdbarch_pc_regnum (current_gdbarch) || regnum == A1_REGNUM)
d232 1
a232 1
      xtensa_register_t* reg = &REGMAP[regnum];
d305 1
a305 1
    return A0_BASE + regnum;
d311 1
a311 1
    if (regnum == REGMAP[i].target_number)
d505 3
a507 2
  if (regnum == FP_ALIAS)
     regnum = A1_REGNUM;
d510 3
a512 2
  if (ISA_USE_WINDOWED_REGISTERS
      && (regnum >= A0_REGNUM) && (regnum <= A15_REGNUM))
d516 2
a517 1
      regcache_raw_read (regcache, WB_REGNUM, buf);
d530 1
a530 1
      xtensa_register_t *reg = &REGMAP[regnum];
d532 1
a532 1
      int flags = XTENSA_TARGET_FLAGS;
d590 3
a592 2
  if (regnum == FP_ALIAS)
     regnum = A1_REGNUM;
d595 3
a597 2
  if (ISA_USE_WINDOWED_REGISTERS
      && (regnum >= A0_REGNUM) && (regnum <= A15_REGNUM))
d602 2
a603 1
      regcache_raw_read (regcache, WB_REGNUM, buf);
d617 1
a617 1
      xtensa_register_t *reg = &REGMAP[regnum];
d619 1
a619 1
      int flags = XTENSA_TARGET_FLAGS;
d736 1
a736 1
  xtensa_register_t* reg = &REGMAP[regnum];
d795 31
a825 18
  if (regnum == WB_REGNUM || regnum == -1)
    regcache_raw_supply (rc, WB_REGNUM, (char *) &regs->windowbase);
  if (regnum == WS_REGNUM || regnum == -1)
    regcache_raw_supply (rc, WS_REGNUM, (char *) &regs->windowstart);
  if (regnum == LBEG_REGNUM || regnum == -1)
    regcache_raw_supply (rc, LBEG_REGNUM, (char *) &regs->lbeg);
  if (regnum == LEND_REGNUM || regnum == -1)
    regcache_raw_supply (rc, LEND_REGNUM, (char *) &regs->lend);
  if (regnum == LCOUNT_REGNUM || regnum == -1)
    regcache_raw_supply (rc, LCOUNT_REGNUM, (char *) &regs->lcount);
  if (regnum == SAR_REGNUM || regnum == -1)
    regcache_raw_supply (rc, SAR_REGNUM, (char *) &regs->sar);
  if (regnum == EXCCAUSE_REGNUM || regnum == -1)
    regcache_raw_supply (rc, EXCCAUSE_REGNUM, (char *) &regs->exccause);
  if (regnum == EXCVADDR_REGNUM || regnum == -1)
    regcache_raw_supply (rc, EXCVADDR_REGNUM, (char *) &regs->excvaddr);
  if (regnum >= AR_BASE && regnum < AR_BASE + NUM_AREGS)
    regcache_raw_supply (rc, regnum, (char *) &regs->ar[regnum - AR_BASE]);
d828 3
a830 2
      for (i = 0; i < NUM_AREGS; ++i)
	regcache_raw_supply (rc, AR_BASE + i, (char *) &regs->ar[i]);
d1014 2
a1015 1
  fp = frame_unwind_register_unsigned (next_frame, A1_REGNUM);
d1060 4
a1063 2
      wb = frame_unwind_register_unsigned (next_frame, WB_REGNUM);
      ws = frame_unwind_register_unsigned (next_frame, WS_REGNUM);
d1070 3
a1072 2
	  ra = frame_unwind_register_unsigned (next_frame,
					       A0_REGNUM + callinc * 4);
d1081 3
a1083 2
	  cache->prev_sp = frame_unwind_register_unsigned (next_frame,
							   A1_REGNUM);
d1087 2
a1088 1
	  ra = frame_unwind_register_unsigned (next_frame, A0_REGNUM);
d1090 2
a1091 1
	  cache->wd.wb = (wb - cache->wd.callsize / 4) & (NUM_AREGS / 4 - 1);
d1105 2
a1106 1
	  sp = frame_unwind_register_unsigned (next_frame, A1_REGNUM) - 16;
d1138 2
a1139 1
						    A1_REGNUM));
d1144 3
a1146 1
	      int regnum = AREG_NUMBER (A1_REGNUM, cache->wd.wb);
d1157 2
a1158 1
  cache->base = frame_unwind_register_unsigned (next_frame,A1_REGNUM);
d1202 3
a1204 2
  int reg = (regnum >= AR_BASE && regnum <= (AR_BASE + C0_NREGS))
    		? regnum - AR_BASE : regnum;
d1259 1
a1259 1
  else if (regnum == A1_REGNUM)
d1263 1
a1263 1
      if (regnum == WS_REGNUM)
d1270 1
a1270 1
      else if (regnum == WB_REGNUM)
d1295 2
a1296 1
      if (regnum >= A0_REGNUM && regnum <= A15_REGNUM)
d1300 3
a1302 1
      if (regnum >= AR_BASE && regnum <= (AR_BASE + NUM_AREGS))
d1304 2
a1305 1
	  int areg = regnum - AR_BASE - (cache->wd.wb * 4);
d1327 4
a1330 2
      int reg = (regnum >= AR_BASE && regnum <= (AR_BASE + C0_NREGS))
			? regnum - AR_BASE : regnum;
d1419 1
a1419 1
  if (CALL_ABI != CallAbiCall0Only)
d1433 4
a1436 2
      regcache_raw_read_unsigned (regcache, WB_REGNUM, &wb);
      areg = AREG_NUMBER(A2_REGNUM + callsize, wb);
d1441 1
a1441 1
      areg = A0_REGNUM + C0_ARGS;
d1473 1
a1473 1
  if (CALL_ABI != CallAbiCall0Only)
d1475 2
a1476 1
      regcache_raw_read_unsigned (regcache, WB_REGNUM, &wb);
d1485 2
a1486 1
      areg = AREG_NUMBER (A2_REGNUM + callsize, wb);
d1493 1
a1493 1
      areg = A0_REGNUM + C0_ARGS;
d1685 2
a1686 1
  if ((CALL_ABI != CallAbiCall0Only) && (sp != osp))
d1761 1
a1761 1
  if (CALL_ABI != CallAbiCall0Only)
d1766 2
a1767 1
      regcache_cooked_write_unsigned (regcache, A4_REGNUM, ra);
d1775 2
a1776 1
      regcache_cooked_write_unsigned (regcache, A0_REGNUM, bp_addr);
d1780 3
a1782 1
  regcache_cooked_write_unsigned (regcache, A1_REGNUM, sp);
d1807 1
a1807 1
  if (ISA_USE_DENSITY_INSTRUCTIONS)
d1977 3
a1979 2
      litbase = (LITBASE_REGNUM == -1)
	? 0 : xtensa_read_register (LITBASE_REGNUM);
d2260 2
a2261 1
  sp = frame_unwind_register_unsigned (next_frame, A1_REGNUM);
d2280 1
a2280 1
      fp_regnum += A0_BASE;
d2285 1
a2285 1
      fp_regnum = A0_BASE + C0_SP;
d2340 4
a2343 2
	  ra = frame_unwind_register_unsigned (next_frame,
					       A0_REGNUM + cache->c0.c0_rt[i].fr_reg);
@


1.11
log
@2007-08-17  Maxim Grigoriev  <maxim2405@@gmail.com>

	* xtensa-tdep.c (ARG_NOF, ARG_1ST, PS_WOE, PS_EXC, C0_MAXOPDS)
	(C0_NREGS, C0_CLESV, C0_SP, C0_FP, C0_RA, C0_ARGS, C0_NARGS)
	(C0_CONST, C0_INEXP, C0_NOSTK): New macros.
	(xtensa_read_register): New function.
	(xtensa_windowed_frame_cache, xtensa_call0_frame_cache, xtensa_c0reg)
	(xtensa_insn_kind): New types.
	(xtensa_frame_cache, xtensa_alloc_frame_cache, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_return_value, xtensa_skip_prologue)
	(xtensa_verify_config, xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write, xtensa_extract_return_value)
	(xtensa_store_return_value)
	(xtensa_push_dummy_call): Extended to support Xtensa Call0 ABI.
	(windowing_enabled, extract_call_winsize, xtensa_unwind_dummy_id)
	(xtensa_frame_this_id, xtensa_frame_prev_register)
	(xtensa_register_type, xtensa_reg_to_regnum): Cosmetic changes.
	(call0_frame_cache, call0_frame_get_reg_at_entry)
	(call0_classify_opcode, call0_track_op)
	(call0_analyze_prologue, call0_frame_cache): New functions.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.10
log
@2007-08-08  Maxim Grigoriev  <maxim2405@@gmail.com>

	* xtensa-tdep.h (XTENSA_MAX_COPROCESSOR): New.
	(xtensa_register_group_t): Add entries for coprocessors.
	* xtensa-tdep.c (xtensa_init_reggroups): New register groups.
	(xtensa_add_reggroups): Likewise.
	(xtensa_register_reggroup_p): Likewise.
	(xtensa_coprocessor_register_group): New function.
	(xtensa_cp): New.
@
text
@d54 1
a77 1

d81 5
a85 5
/* We use a6 through a11 for passing arguments to a function called by GDB.  */

#define ARGS_FIRST_REG    A6_REGNUM
#define ARGS_NUM_REGS     6
#define REGISTER_SIZE	  4
d88 5
a92 6
/* Extract the call size from the return address or ps register.  */

#define PS_CALLINC_SHIFT 16
#define PS_CALLINC_MASK 0x00030000
#define CALLINC(ps) (((ps) & PS_CALLINC_MASK) >> PS_CALLINC_SHIFT)
#define WINSIZE(ra) (4 * (( (ra) >> 30) & 0x3))
a95 1

d97 1
a97 1
  ((((r) - A0_REGNUM + (((wb) & WB_MASK)<<WB_SHIFT)) & AREGS_MASK) + AR_BASE)
d99 4
a102 2

/* Define prototypes.  */
d115 1
a115 2
#define XTENSA_ENTRY_LENGTH  3

d121 3
d127 1
a127 1
  return ((ps & (1 << 4)) == 0 && (ps & (1 << 18)) != 0);
d134 1
a134 1
   has returned to the callee.  On Xtensa, the register that holds the return
d144 1
a144 1
  int winsize = 4;	/* Default: No call, e.g. dummy frame.  */
a161 3
  /* Lookup call insn.
     (Return the default value (4) if we can't find a valid call insn.  */

d165 1
a165 1
	winsize = (insn & 0x30) >> 2;   /* 0, 4, 8, 12  */
d170 1
a170 1
	winsize = (insn >> 16) & 0xc;   /* 0, 4, 8, 12  */
a178 1

a186 1
  /* Invalid register number.  */
d191 8
d226 1
a226 1
      /* Set ctype for this register (only the first time we ask for it).  */
d233 2
a234 2
	  /* We always use the memory representation, even if the register
	     width is smaller.  */
a281 1
  /* Invalid register number.  */
d287 1
a287 1
/* Returns the 'local' register number for stubs, dwarf2, etc.
a305 1
  /* Invalid register number.  */
d312 4
a315 6
/* Handle the special case of masked registers.  */

/* Write the bits of a masked register to the various registers that
   are combined into this register.  Only the masked areas of these
   registers are modified; the other fields are untouched.
   (Note: The size of masked registers is always less or equal 32 bits.)  */
a321 1

d398 2
a399 2
/* Read the masked areas of the registers and assemble it into a single
   register.  */
a405 1

a496 1
  /* Check if it is FP (renumber it in this case -> A0...A15).  */
d498 1
a498 1
    error (_("trying to read FP"));
d500 3
a502 2
  /* Read aliases a0..a15.  */
  if (regnum >= A0_REGNUM && regnum <= A15_REGNUM)
d510 1
a510 1
  /* We can always read 'regular' registers.  */
d523 1
a523 1
      /* Can we read Unknown or Unmapped registers?  */
a561 1

a578 1
  /* Check if this is FP.  */
d580 1
a580 1
    error (_("trying to write FP"));
d582 3
a584 2
  /* Renumber register, if aliase a0..a15.  */
  if (regnum >= A0_REGNUM && regnum <= A15_REGNUM)
d607 2
a608 2
      /* On most targets, we can't write registers of type "Unknown"
	 or "Unmapped".  */
a630 1

a647 1

a652 1

a757 2
/* CORE FILE SUPPORT */

d760 1
a760 1
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
d817 2
a818 2
/* Return the appropriate register set for the core section identified
   by SECT_NAME and SECT_SIZE.  */
d827 1
a827 1
	      sect_name, (int) sect_size);
d837 1
a837 4
/* F R A M E */

/* We currently don't support the call0-abi, so we have at max. 12 registers
   saved on the stack.  */
d839 2
a840 1
#define XTENSA_NUM_SAVED_AREGS 12
d842 2
a843 1
typedef struct xtensa_frame_cache
a844 4
  CORE_ADDR base;
  CORE_ADDR pc;
  CORE_ADDR ra;		/* The raw return address; use to compute call_inc.  */
  CORE_ADDR ps;
d849 59
a907 1
  CORE_ADDR prev_sp;
d912 1
a912 1
xtensa_alloc_frame_cache (void)
a923 1
  cache->wb = 0;
a924 1
  cache->callsize = -1;
d926 7
d934 11
a944 2
  for (i = 0; i < XTENSA_NUM_SAVED_AREGS; i++)
    cache->aregs[i] = -1;
d946 3
a979 1
  gdb_byte buf[4];
d981 1
a981 1
  /* next_frame->prev is a dummy frame. Return a frame ID of that frame.  */
d986 1
a986 2
  frame_unwind_register (next_frame, A1_REGNUM, buf);
  fp = extract_unsigned_integer (buf, 4);
d989 1
a989 1
  return frame_id_build (fp+SP_ALIGNMENT, pc);
d992 11
a1007 1
  char buf[4];
d1009 1
d1011 1
a1015 1
  /* Already cached?  */
d1019 2
d1022 1
a1022 1
  cache = xtensa_alloc_frame_cache ();
a1024 5
  /* Get windowbase, windowstart, ps, and pc.  */
  wb = frame_unwind_register_unsigned (next_frame, WB_REGNUM);
  ws = frame_unwind_register_unsigned (next_frame, WS_REGNUM);
  ps = frame_unwind_register_unsigned (next_frame,
				       gdbarch_ps_regnum (current_gdbarch));
d1028 1
a1028 17
  op1 = read_memory_integer (pc, 1);
  if (XTENSA_IS_ENTRY (op1) || !windowing_enabled (ps))
    {
      int callinc = CALLINC (ps);
      ra = frame_unwind_register_unsigned (next_frame,
					   A0_REGNUM + callinc * 4);

      DEBUGINFO("[xtensa_frame_cache] 'entry' at 0x%08x\n (callinc = %d)",
	  	(int)pc, callinc);

      /* ENTRY hasn't been executed yet, therefore callsize is still 0.  */
      cache->callsize = 0;
      cache->wb = wb;
      cache->ws = ws;
      cache->prev_sp = frame_unwind_register_unsigned (next_frame, A1_REGNUM);
    }
  else
d1030 4
a1033 5
      ra = frame_unwind_register_unsigned (next_frame, A0_REGNUM);
      cache->callsize = WINSIZE (ra);
      cache->wb = (wb - (cache->callsize / 4)) & ((NUM_AREGS / 4) - 1);
      cache->ws = ws & ~(1 << wb);
    }
d1035 24
a1058 3
  cache->pc = ((frame_func_unwind (next_frame, NORMAL_FRAME) & 0xc0000000)
	       | (ra & 0x3fffffff));
  cache->ps = (ps & ~PS_CALLINC_MASK) | ((WINSIZE(ra)/4) << PS_CALLINC_SHIFT);
d1060 4
d1065 3
a1067 3
  /* Note: We could also calculate the location on stack when we actually
     access the register.  However, this approach, saving the location
     in the cache frame, is probably easier to support the call0 ABI.  */
d1069 7
a1075 3
  if (cache->ws == 0)
    {
      int i;
d1077 6
a1082 2
      /* Set A0...A3.  */
      sp = frame_unwind_register_unsigned (next_frame, A1_REGNUM) - 16;
d1084 5
a1088 3
      for (i = 0; i < 4; i++, sp += 4)
	{
	  cache->aregs[i] = sp;
d1091 3
a1093 1
      if (cache->callsize > 4)
d1095 13
a1107 1
	  /* Set A4...A7/A11.  */
d1109 1
a1109 7
	  sp = (CORE_ADDR) read_memory_integer (sp - 12, 4);
	  sp = (CORE_ADDR) read_memory_integer (sp - 12, 4);
	  sp -= cache->callsize * 4;

	  for ( /* i=4  */ ; i < cache->callsize; i++, sp += 4)
	    {
	      cache->aregs[i] = sp;
d1113 1
a1113 2

  if (cache->prev_sp == 0) 
d1115 1
a1115 17
      if (cache->ws == 0)
	{
	  /* Register window overflow already happened.
	     We can read caller's frame SP from the proper spill loction.  */
	  cache->prev_sp =
		  read_memory_integer (cache->aregs[1],
				       register_size (current_gdbarch,
						      A1_REGNUM));
	}
      else
	{
	  /* Read caller's frame SP directly from the previous window.  */

	  int regnum = AREG_NUMBER (A1_REGNUM, cache->wb);

	  cache->prev_sp = frame_unwind_register_unsigned (next_frame, regnum);
	}
a1119 6
  DEBUGINFO ("[xtensa_frame_cache] base 0x%08x, wb %d, "
	     "ws 0x%08x, callsize %d, pc 0x%08x, ps 0x%08x, prev_sp 0x%08x\n",
	     (unsigned int) cache->base, (unsigned int) cache->wb,
	     cache->ws, cache->callsize, (unsigned int) cache->pc,
	     (unsigned int) cache->ps, (unsigned int) cache->prev_sp);

a1122 1

d1130 1
d1132 2
a1133 2
  DEBUGTRACE ("xtensa_frame_this_id (next %p, *this %p)\n",
	      next_frame, *this_cache);
d1138 12
a1149 1
  (*this_id) = frame_id_build (cache->prev_sp, cache->pc);
d1152 42
d1210 4
a1213 4
  DEBUGTRACE ("xtensa_frame_prev_register (next %p, "
	      "*this %p, regnum %d (%s), ...)\n",
	      next_frame,
	      *this_cache ? *this_cache : 0, regnum,
d1216 5
a1220 1
  if (regnum == WS_REGNUM)
d1222 11
a1232 2
      if (cache->ws != 0)
	saved_reg = cache->ws;
d1234 1
a1234 1
	saved_reg = 1 << cache->wb;
a1235 6
  else if (regnum == WB_REGNUM)
    saved_reg = cache->wb;
  else if (regnum == gdbarch_pc_regnum (current_gdbarch))
    saved_reg = cache->pc;
  else if (regnum == gdbarch_ps_regnum (current_gdbarch))
    saved_reg = cache->ps;
d1251 38
a1288 21
  /* Convert Ax register numbers to ARx register numbers.  */
  if (regnum >= A0_REGNUM && regnum <= A15_REGNUM)
    regnum = AREG_NUMBER (regnum, cache->wb);

  /* Check if ARx register has been saved to stack.  */
  if (regnum >= AR_BASE && regnum <= (AR_BASE + NUM_AREGS))
    {
      int areg = regnum - AR_BASE - (cache->wb * 4);

      if (areg >= 0
	  && areg < XTENSA_NUM_SAVED_AREGS
	  && cache->aregs[areg] != -1)
        {
    	  *optimizedp = 0;
	  *lvalp = lval_memory;
	  *addrp = cache->aregs[areg];
	  *realnump = -1;

	  if (valuep)
	    read_memory (*addrp, valuep,
			 register_size (current_gdbarch, regnum));
d1290 19
a1308 2
	  DEBUGINFO ("[xtensa_frame_prev_register] register on stack\n");
	  return;
d1312 2
a1313 2
  /* Note: All other registers have been either saved to the dummy stack
     or are still alive in the processor.  */
d1372 4
a1375 2
  /* First, we have to find the caller window in the register file.  */
  regcache_raw_read_unsigned (regcache,
d1377 1
a1377 1
  callsize = extract_call_winsize (pc);
d1379 15
a1393 9
  /* On Xtensa, we can return up to 4 words (or 2 when called by call12).  */
  if (len > (callsize > 8 ? 8 : 16))
    internal_error (__FILE__, __LINE__,
	            _("cannot extract return value of %d bytes long"), len);

  /* Get the register offset of the return register (A2) in the caller
     window.  */
  regcache_raw_read_unsigned (regcache, WB_REGNUM, &wb);
  areg = AREG_NUMBER(A2_REGNUM + callsize, wb);
d1424 3
a1426 1
  regcache_raw_read_unsigned (regcache, WB_REGNUM, &wb);
d1429 1
a1429 1
  callsize = extract_call_winsize (pc);
d1431 5
a1435 4
  if (len > (callsize > 8 ? 8 : 16))
    internal_error (__FILE__, __LINE__,
		    _("unimplemented for this length: %d"),
		    TYPE_LENGTH (type));
d1437 1
a1437 1
  DEBUGTRACE ("[xtensa_store_return_value] callsize %d wb %d\n",
d1439 5
a1447 2
  areg = AREG_NUMBER (A2_REGNUM + callsize, wb);

d1458 1
a1458 1
enum return_value_convention
d1465 1
a1465 1
  /* Note: Structures up to 16 bytes are returned in registers.  */
d1540 2
a1541 2
	  fprintf_unfiltered (gdb_stdlog, "%2d: %p %3d ",
			      i, arg, TYPE_LENGTH (arg_type));
d1554 2
a1555 2
	  fprintf_unfiltered (gdb_stdlog, " %p\n",
			      value_contents (arg));
d1591 2
a1592 1
	  info->align = TYPE_LENGTH (builtin_type_long);
d1616 1
a1616 1
      if (size + info->length > REGISTER_SIZE * ARGS_NUM_REGS)
d1625 1
a1625 1
	  info->u.regno = ARGS_FIRST_REG + size / REGISTER_SIZE;
d1633 2
a1634 2
  /* Simulate MOVSP.  */
  if (sp != osp)
d1645 1
a1645 1
      regcache_cooked_write (regcache, ARGS_FIRST_REG, buf);
a1695 1
	        /* ULONGEST v = extract_unsigned_integer (cp, REGISTER_SIZE);*/
a1697 1
		/* regcache_cooked_write_unsigned (regcache, r, v); */
a1704 1

d1706 1
a1706 1
     Note: The return address for the current function (in A0) is
d1709 15
a1723 7
  ra = (bp_addr & 0x3fffffff) | 0x40000000;
  regcache_raw_read (regcache, gdbarch_ps_regnum (current_gdbarch), buf);
  ps = extract_unsigned_integer (buf, 4) & ~0x00030000;
  regcache_cooked_write_unsigned (regcache, A4_REGNUM, ra);
  regcache_cooked_write_unsigned (regcache,
				  gdbarch_ps_regnum (current_gdbarch),
				  ps | 0x00010000);
d1741 1
a1741 1
const unsigned char *
d1779 519
d2299 18
a2316 2
/* Return the pc of the first real instruction.  We assume that this
   machine uses register windows.
d2320 1
a2320 1
   the prologue code. It works even in cases like
d2332 3
a2334 1
   If there is no debug info, we need to analyze the code. */
d2339 3
d2344 17
a2360 4
  if (ISA_USE_WINDOWED_REGISTERS)
    {
      unsigned char op1;
      struct symtab_and_line prologue_sal;
d2362 2
a2363 2
      op1 = read_memory_integer (start_pc, 1);
      if (!XTENSA_IS_ENTRY (op1))
d2366 1
a2366 11
      prologue_sal = find_pc_line (start_pc, 0);
      if (prologue_sal.line != 0)
	return prologue_sal.end;
      else
	return start_pc + XTENSA_ENTRY_LENGTH;
    }
  else
    {
      internal_error (__FILE__, __LINE__,
		      _("non-windowed configurations are not supported"));
      return start_pc;
d2368 4
a2373 3

/* CONFIGURATION CHECK */

a2374 1

d2390 3
a2392 2
    fprintf_unfiltered (log, "\n\tnum_aregs: Number of AR registers (%d) "
			"is not a power of two!", tdep->num_aregs);
d2395 1
d2397 14
a2410 9
    fprintf_unfiltered (log, "\n\tpc_regnum: No PC register");
  if (tdep->ps_regnum == -1)
    fprintf_unfiltered (log, "\n\tps_regnum: No PS register");
  if (tdep->wb_regnum == -1)
    fprintf_unfiltered (log, "\n\twb_regnum: No WB register");
  if (tdep->ws_regnum == -1)
    fprintf_unfiltered (log, "\n\tws_regnum: No WS register");
  if (tdep->ar_base == -1)
    fprintf_unfiltered (log, "\n\tar_base: No AR registers");
d2412 1
a2412 1
    fprintf_unfiltered (log, "\n\ta0_base: No Ax registers");
a2421 1

d2442 1
a2442 1
  /* Pseudo-Register read/write  */
a2507 3

/* Dump xtensa tdep structure.  */

a2513 1

@


1.9
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d661 1
d669 9
a679 1

d683 3
d690 11
a700 7
  reggroup_add (gdbarch, vector_reggroup);		/* vectra */
  reggroup_add (gdbarch, general_reggroup);		/* core */
  reggroup_add (gdbarch, float_reggroup);		/* float */

  reggroup_add (gdbarch, xtensa_ar_reggroup);		/* ar */
  reggroup_add (gdbarch, xtensa_user_reggroup);		/* user */
  reggroup_add (gdbarch, xtensa_vectra_reggroup);	/* vectra */
d703 11
d730 1
d756 2
@


1.8
log
@	* arm-tdep.c (arm_print_float_info): Use register value from FRAME
	instead of calling read_register.

	* avr-tdep.c (avr_push_dummy_call): Write to REGCACHE instead of
	calling write_register.

	* hppa-tdep.c (hppa32_push_dummy_call): Write to REGCACHE instead of
	calling write_register.

	* ia64-tdep.c (find_func_descr): Add REGCACHE parameter.  Use it
	instead of calling read_register.
	(ia64_push_dummy_call): Update call to find_func_descr.  Use REGCACHE
	instead of calling read_register and write_register.

	* m32r-tdep.c (m32r_linux_supply_gregset): Use REGCACHE parameter
	instead of current_regcache.

	* mn10300-tdep.c (mn10300_push_dummy_call): Write to REGCACHE instead
	of calling write_register.
	* mn10300-linux-tdep.c (am33_supply_fpregset_method): Use REGCACHE
	parameter instead of current_regcache.

	* mips-tdep.c (mips2_fp_compat): Add FRAME parameter.  Use it
	instead of calling read_register.
	(mips_read_fp_register_double, mips_print_fp_register): Update calls.
	(mips_eabi_push_dummy_call): Use REGCACHE instead of write_register.
	(mips_n32n64_push_dummy_call): Likewise.
	(mips_o32_push_dummy_call): Likewise.
	(mips_o64_push_dummy_call): Likewise.

	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Use REGCACHE
	parameter instead of current_regcache.

	* xtensa-tdep.c (xtensa_register_write_masked): Add REGCACHE parameter.
	Use it instead of read_register and write_register.
	(xtensa_register_read_masked): Likewise.
	(xtensa_pseudo_register_read): Update call.
	(xtensa_pseudo_register_write): Likewise.
	(xtensa_frame_cache): Use register values unwound from NEXT_FRAME
	instead of calling read_register.
	(xtensa_push_dummy_call): Update comment.
@
text
@d212 1
a212 1
  if (regnum == PC_REGNUM || regnum == A1_REGNUM)
d751 7
a757 4
  if (regnum == PC_REGNUM || regnum == -1)
    regcache_raw_supply (rc, PC_REGNUM, (char *) &regs->pc);
  if (regnum == PS_REGNUM || regnum == -1)
    regcache_raw_supply (rc, PS_REGNUM, (char *) &regs->ps);
d874 1
a874 1
  frame_unwind_register (next_frame, PC_REGNUM, buf);
d924 4
a927 2
  ps = frame_unwind_register_unsigned (next_frame, PS_REGNUM);
  pc = frame_unwind_register_unsigned (next_frame, PC_REGNUM);
d1070 1
a1070 1
  else if (regnum == PC_REGNUM)
d1072 1
a1072 1
  else if (regnum == PS_REGNUM)
d1177 2
a1178 1
  regcache_raw_read_unsigned (regcache, PC_REGNUM, &pc);
d1221 2
a1222 1
  regcache_raw_read_unsigned (regcache, PC_REGNUM, &pc);
d1502 1
a1502 1
  regcache_raw_read (regcache, PS_REGNUM, buf);
d1505 3
a1507 1
  regcache_cooked_write_unsigned (regcache, PS_REGNUM, ps | 0x00010000);
@


1.7
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* xtensa-tdep.c (XTENSA_IS_ENTRY, extract_call_winsize)
	(xtensa_register_write_masked, xtensa_register_read_masked)
	(xtensa_extract_return_value, xtensa_store_return_value
	(xtensa_push_dummy_call, xtensa_breakpoint_from_pc): Replace
	TARGET_BYTE_ORDER by gdbarch_byte_order.
	* sh-tdep.c (sh_breakpoint_from_pc, gdb_print_insn_sh)
	(sh_justify_value_in_reg, sh_next_flt_argreg, sh_push_dummy_call_fpu)
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_breakpoint_from_pc, gdb_print_insn_sh64)
	(sh64_push_dummy_call, sh64_extract_return_value)
	(sh64_store_return_value, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_pseudo_register_read)
	(sh64_pseudo_register_write, sh64_do_fp_register)
	(sh64_frame_prev_register): Likewise.
	* score-tdep.c (score_print_insn, score_breakpoint_from_pc)
	(score_return_value, score_push_dummy_call, score_fetch_inst): Likewise.
	* rs6000-tdep.c (rs6000_breakpoint_from_pc, rs6000_push_dummy_call)
	(e500_move_ev_register,gdb_print_insn_powerpc): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* ppc-linux-nat.c (store_register): Likewise.
	* nto-tdep.c (nto_find_and_open_solib)
	(nto_init_solib_absolute_prefix): Likewise.
	* mips-tdep.c (mips_pseudo_register_read, mips_pseudo_register_write)
	(mips_convert_register_p, mips_eabi_push_dummy_call)
	(mips_n32n64_push_dummy_call, mips_n32n64_return_value)
	(mips_o32_push_dummy_call, mips_o32_return_value)
	(mips_o64_push_dummy_call, mips_o64_return_value, mips_o64_return_value)
	(mips_read_fp_register_single, mips_read_fp_register_double)
	(mips_print_register, print_gp_register_row, gdb_print_insn_mips)
	(mips_breakpoint_from_pc): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Likewise.
	* mips-linux-tdep.c (mips64_supply_fpregset, mips64_fill_fpregset)
	(mips_linux_o32_sigframe_init): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint, m32r_breakpoint_from_pc): Likewise.
	* libunwind-frame.c (libunwind_frame_cache, libunwind_frame_sniffer)
	(libunwind_sigtramp_frame_sniffer, libunwind_get_reg_special): Likewise.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* arm-tdep.c (convert_from_extended, convert_to_extended)
	(gdb_print_insn_arm): Likewise.
@
text
@d317 2
a318 1
xtensa_register_write_masked (xtensa_register_t *reg, unsigned char *buffer)
d387 2
d391 2
a392 2
	  regval = (regval & m) | (read_register (r) & ~m);
	  write_register (r, regval);
d402 2
a403 1
xtensa_register_read_masked (xtensa_register_t *reg, unsigned char *buffer)
d426 9
a434 1
      regval = (r >= 0) ? read_register (r) : 0;
d556 1
a556 1
	  xtensa_register_read_masked (reg, (unsigned char *) buffer);
d644 1
a644 1
	  xtensa_register_write_masked (reg, (unsigned char *) buffer);
d925 1
a925 1
  if (XTENSA_IS_ENTRY (op1) || !windowing_enabled (read_register (PS_REGNUM)))
d927 1
a927 2
      int callinc = CALLINC (frame_unwind_register_unsigned (next_frame,
							     PS_REGNUM));
d938 1
a938 1
      cache->prev_sp = read_register (A1_REGNUM);
d1001 1
a1001 1
	  cache->prev_sp = read_register (regnum);
d1481 1
a1481 1
		/* write_register (r, v); */
@


1.6
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d112 2
a113 1
  ((TARGET_BYTE_ORDER == BFD_ENDIAN_BIG) ? ((op1) == 0x6c) : ((op1) == 0x36))
d163 1
a163 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
d336 1
a336 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d456 1
a456 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1176 1
a1176 1
  if (len < 4 && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1215 1
a1215 1
  if (len < 4 && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1432 2
a1433 1
	  if (n < REGISTER_SIZE && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1451 2
a1452 1
	  if (n < REGISTER_SIZE && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1517 1
a1517 1
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1530 1
a1530 1
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
@


1.5
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d184 2
a185 1
  if (regnum >= 0 && regnum < NUM_REGS + NUM_PSEUDO_REGS)
d215 2
a216 1
  else if (regnum >= 0 && regnum < NUM_REGS + NUM_PSEUDO_REGS)
d294 4
a297 1
  for (i = 0; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
d499 1
a499 1
  if (regnum >= 0 && regnum < NUM_REGS)
d503 3
a505 1
  else if (regnum >= 0 && regnum < NUM_REGS + NUM_PSEUDO_REGS)
d584 1
a584 1
  if (regnum >= 0 && regnum < NUM_REGS)
d588 3
a590 1
  else if (regnum >= 0 && regnum < NUM_REGS + NUM_PSEUDO_REGS)
d713 1
a713 1
    return (regnum < NUM_REGS
@


1.4
log
@gdb/
	* MAINTAINERS: Disable -Werror for cris simulator.  Build
	sparc64-solaris2.10 instead of the broken sparc-elf.
	* solib-frv.c: Include "solib.h".
	* Makefile.in (solib-frv.o): Update.
	* mt-tdep.c (mt_gdbarch_init): Correct typo in floatformats patch.
	* xtensa-tdep.c (xtensa_regset_from_core_section): Cast size_t to int.
	(xtensa_frame_this_id, xtensa_frame_prev_register)
	(xtensa_push_dummy_call): Use %p.
sim/v850/
	* Makefile.in (interp.o): Uncomment and update.
@
text
@d927 1
a927 1
  cache->pc = ((frame_func_unwind (next_frame) & 0xc0000000)
@


1.3
log
@	* xtensa-tdep.h (xtensa_reg_mask_t): New.
	(xtensa_mask_t): Change mask field to be a separate array.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write, xtensa_unwind_pc)
	(xtensa_unwind_dummy_id, xtensa_push_dummy_call)
	(xtensa_breakpoint_from_pc): Remove implicit type casting.
	* xtensa-config.c (mask0, mask1, mask2, mask3, mask4, mask5)
	(mask6, mask7, mask8, mask9, mask10, mask11, mask12, mask13)
	(mask14, mask15): Rename to
	(xtensa_mask0, xtensa_mask1, xtensa_mask2, xtensa_mask3)
	(xtensa_mask4, xtensa_mask5, xtensa_mask6, xtensa_mask7)
	(xtensa_mask8, xtensa_mask9, xtensa_mask10, xtensa_mask11)
	(xtensa_mask12, xtensa_mask13, xtensa_mask14, xtensa_mask15): this.
	(xtensa_submask0, xtensa_submask1, xtensa_submask2, xtensa_submask3)
	(xtensa_submask4, xtensa_submask5, xtensa_submask6, xtensa_submask7)
	(xtensa_submask8, xtensa_submask9, xtensa_submask10)
	(xtensa_submask11, xtensa_submask12, xtensa_submask13)
	(xtensa_submask14, xtensa_submask15): New.
	(rmap): Follow strict aliasing rules doing static initialization.
@
text
@d779 1
a779 1
	      sect_name, sect_size);
d1004 2
a1005 2
  DEBUGTRACE ("xtensa_frame_this_id (next 0x%08x, *this 0x%08x)\n",
	      (unsigned int) next_frame, (unsigned int) *this_cache);
d1029 4
a1032 4
  DEBUGTRACE ("xtensa_frame_prev_register (next 0x%08x, "
	      "*this 0x%08x, regnum %d (%s), ...)\n",
	      (unsigned int) next_frame,
	      *this_cache? (unsigned int) *this_cache : 0, regnum,
d1302 2
a1303 2
	  fprintf_unfiltered (gdb_stdlog, "%2d: 0x%08x %3d ",
			      i, (int) arg, TYPE_LENGTH (arg_type));
d1316 2
a1317 2
	  fprintf_unfiltered (gdb_stdlog, " 0x%08x\n",
			      (unsigned int) value_contents (arg));
@


1.2
log
@Copyright updates for 2007.
@
text
@d143 1
a143 1
  char buf[4];
d487 1
a487 1
      char *buf = (char *) alloca (MAX_REGISTER_SIZE);
d568 1
a568 1
      char *buf = (char *) alloca (MAX_REGISTER_SIZE);
d845 1
a845 1
  char buf[8];
d862 1
a862 1
  char buf[4];
d1268 1
a1268 1
  char *buf = (char *) alloca (16);
d1496 4
a1499 4
  static char big_breakpoint[] = BIG_BREAKPOINT;
  static char little_breakpoint[] = LITTLE_BREAKPOINT;
  static char density_big_breakpoint[] = DENSITY_BIG_BREAKPOINT;
  static char density_little_breakpoint[] = DENSITY_LITTLE_BREAKPOINT;
@


1.1
log
@2006-11-14  Maxim Grigoriev  <maxim@@tensilica.com>

	* NEWS: New port to Xtensa.
	* Makefile.in: Add dependencies for Xtensa files.
	* configure.tgt (xtensa*, xtensa*-*-elf*): New.
	* configure.host (xtensa*-*-elf*): New.
	* config/xtensa/xtensa.mt: New file.
	* xtensa-config.c: New file.
	* xtensa-tdep.h: New file.
	* xtensa-tdep.c: New file.

2006-11-14  Maxim Grigoriev  <maxim@@tensilica.com>

	* gdb.texinfo (Contributors): Add contributors of Xtensa port.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005, 2006 Free Software Foundation, Inc.
@

