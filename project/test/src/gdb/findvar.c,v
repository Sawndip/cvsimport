head	1.154;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.148
	gdb_7_6-2013-04-26-release:1.148
	gdb_7_6-branch:1.148.0.2
	gdb_7_6-2013-03-12-branchpoint:1.148
	gdb_7_5_1-2012-11-29-release:1.145
	gdb_7_5-2012-08-17-release:1.145
	gdb_7_5-branch:1.145.0.2
	gdb_7_5-2012-07-18-branchpoint:1.145
	gdb_7_4_1-2012-04-26-release:1.140.2.1
	gdb_7_4-2012-01-24-release:1.140.2.1
	gdb_7_4-branch:1.140.0.2
	gdb_7_4-2011-12-13-branchpoint:1.140
	gdb_7_3_1-2011-09-04-release:1.134
	gdb_7_3-2011-07-26-release:1.134
	gdb_7_3-branch:1.134.0.2
	gdb_7_3-2011-04-01-branchpoint:1.134
	gdb_7_2-2010-09-02-release:1.129
	gdb_7_2-branch:1.129.0.2
	gdb_7_2-2010-07-07-branchpoint:1.129
	gdb_7_1-2010-03-18-release:1.128
	gdb_7_1-branch:1.128.0.2
	gdb_7_1-2010-02-18-branchpoint:1.128
	gdb_7_0_1-2009-12-22-release:1.126
	gdb_7_0-2009-10-06-release:1.126
	gdb_7_0-branch:1.126.0.4
	gdb_7_0-2009-09-16-branchpoint:1.126
	arc-sim-20090309:1.109
	msnyder-checkpoint-072509-branch:1.126.0.2
	msnyder-checkpoint-072509-branchpoint:1.126
	arc-insight_6_8-branch:1.109.0.6
	arc-insight_6_8-branchpoint:1.109
	insight_6_8-branch:1.109.0.4
	insight_6_8-branchpoint:1.109
	reverse-20081226-branch:1.119.0.2
	reverse-20081226-branchpoint:1.119
	multiprocess-20081120-branch:1.118.0.4
	multiprocess-20081120-branchpoint:1.118
	reverse-20080930-branch:1.118.0.2
	reverse-20080930-branchpoint:1.118
	reverse-20080717-branch:1.115.0.2
	reverse-20080717-branchpoint:1.115
	msnyder-reverse-20080609-branch:1.114.0.2
	msnyder-reverse-20080609-branchpoint:1.114
	drow-reverse-20070409-branch:1.100.0.2
	drow-reverse-20070409-branchpoint:1.100
	gdb_6_8-2008-03-27-release:1.109
	gdb_6_8-branch:1.109.0.2
	gdb_6_8-2008-02-26-branchpoint:1.109
	gdb_6_7_1-2007-10-29-release:1.107
	gdb_6_7-2007-10-10-release:1.107
	gdb_6_7-branch:1.107.0.2
	gdb_6_7-2007-09-07-branchpoint:1.107
	insight_6_6-20070208-release:1.95.18.1
	gdb_6_6-2006-12-18-release:1.95.18.1
	gdb_6_6-branch:1.95.0.18
	gdb_6_6-2006-11-15-branchpoint:1.95
	insight_6_5-20061003-release:1.95
	gdb-csl-symbian-6_4_50_20060226-12:1.95
	gdb-csl-sourcerygxx-3_4_4-25:1.93
	nickrob-async-20060828-mergepoint:1.95
	gdb-csl-symbian-6_4_50_20060226-11:1.95
	gdb-csl-sourcerygxx-4_1-17:1.95
	gdb-csl-20060226-branch-local-2:1.95
	gdb-csl-sourcerygxx-4_1-14:1.95
	gdb-csl-sourcerygxx-4_1-13:1.95
	gdb-csl-sourcerygxx-4_1-12:1.95
	gdb-csl-sourcerygxx-3_4_4-21:1.95
	gdb_6_5-20060621-release:1.95
	gdb-csl-sourcerygxx-4_1-9:1.95
	gdb-csl-sourcerygxx-4_1-8:1.95
	gdb-csl-sourcerygxx-4_1-7:1.95
	gdb-csl-arm-2006q1-6:1.95
	gdb-csl-sourcerygxx-4_1-6:1.95
	gdb-csl-symbian-6_4_50_20060226-10:1.95
	gdb-csl-symbian-6_4_50_20060226-9:1.95
	gdb-csl-symbian-6_4_50_20060226-8:1.95
	gdb-csl-coldfire-4_1-11:1.95
	gdb-csl-sourcerygxx-3_4_4-19:1.95
	gdb-csl-coldfire-4_1-10:1.95
	gdb_6_5-branch:1.95.0.16
	gdb_6_5-2006-05-14-branchpoint:1.95
	gdb-csl-sourcerygxx-4_1-5:1.95
	nickrob-async-20060513-branch:1.95.0.14
	nickrob-async-20060513-branchpoint:1.95
	gdb-csl-sourcerygxx-4_1-4:1.95
	msnyder-reverse-20060502-branch:1.95.0.12
	msnyder-reverse-20060502-branchpoint:1.95
	gdb-csl-morpho-4_1-4:1.95
	gdb-csl-sourcerygxx-3_4_4-17:1.95
	readline_5_1-import-branch:1.95.0.10
	readline_5_1-import-branchpoint:1.95
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.95
	gdb-csl-symbian-20060226-branch:1.95.0.8
	gdb-csl-symbian-20060226-branchpoint:1.95
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.95
	msnyder-reverse-20060331-branch:1.95.0.6
	msnyder-reverse-20060331-branchpoint:1.95
	gdb-csl-available-20060303-branch:1.95.0.4
	gdb-csl-available-20060303-branchpoint:1.95
	gdb-csl-20060226-branch:1.95.0.2
	gdb-csl-20060226-branchpoint:1.95
	gdb_6_4-20051202-release:1.93
	msnyder-fork-checkpoint-branch:1.93.0.10
	msnyder-fork-checkpoint-branchpoint:1.93
	gdb-csl-gxxpro-6_3-branch:1.93.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.93
	gdb_6_4-branch:1.93.0.6
	gdb_6_4-2005-11-01-branchpoint:1.93
	gdb-csl-arm-20051020-branch:1.93.0.4
	gdb-csl-arm-20051020-branchpoint:1.93
	msnyder-tracepoint-checkpoint-branch:1.93.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.93
	gdb-csl-arm-20050325-2005-q1b:1.90
	gdb-csl-arm-20050325-2005-q1a:1.90
	csl-arm-20050325-branch:1.90.0.2
	csl-arm-20050325-branchpoint:1.90
	gdb-post-i18n-errorwarning-20050211:1.88
	gdb-pre-i18n-errorwarning-20050211:1.87
	gdb_6_3-20041109-release:1.77
	gdb_6_3-branch:1.77.0.2
	gdb_6_3-20041019-branchpoint:1.77
	drow_intercu-merge-20040921:1.77
	drow_intercu-merge-20040915:1.77
	jimb-gdb_6_2-e500-branch:1.75.0.6
	jimb-gdb_6_2-e500-branchpoint:1.75
	gdb_6_2-20040730-release:1.75
	gdb_6_2-branch:1.75.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.75
	gdb_6_1_1-20040616-release:1.74
	gdb_6_1-2004-04-05-release:1.74
	drow_intercu-merge-20040402:1.74
	drow_intercu-merge-20040327:1.74
	ezannoni_pie-20040323-branch:1.74.0.8
	ezannoni_pie-20040323-branchpoint:1.74
	cagney_tramp-20040321-mergepoint:1.74
	cagney_tramp-20040309-branch:1.74.0.6
	cagney_tramp-20040309-branchpoint:1.74
	gdb_6_1-branch:1.74.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.74
	drow_intercu-20040221-branch:1.74.0.2
	drow_intercu-20040221-branchpoint:1.74
	cagney_bfdfile-20040213-branch:1.70.0.2
	cagney_bfdfile-20040213-branchpoint:1.70
	drow-cplus-merge-20040208:1.69
	carlton_dictionary-20040126-merge:1.67
	cagney_bigcore-20040122-branch:1.67.0.2
	cagney_bigcore-20040122-branchpoint:1.67
	drow-cplus-merge-20040113:1.67
	drow-cplus-merge-20031224:1.67
	drow-cplus-merge-20031220:1.67
	carlton_dictionary-20031215-merge:1.67
	drow-cplus-merge-20031214:1.67
	carlton-dictionary-20031111-merge:1.67
	gdb_6_0-2003-10-04-release:1.60.2.2
	kettenis_sparc-20030918-branch:1.65.0.4
	kettenis_sparc-20030918-branchpoint:1.65
	carlton_dictionary-20030917-merge:1.65
	ezannoni_pie-20030916-branchpoint:1.65
	ezannoni_pie-20030916-branch:1.65.0.2
	cagney_x86i386-20030821-branch:1.62.0.2
	cagney_x86i386-20030821-branchpoint:1.62
	carlton_dictionary-20030805-merge:1.62
	carlton_dictionary-20030627-merge:1.60
	gdb_6_0-branch:1.60.0.2
	gdb_6_0-2003-06-23-branchpoint:1.60
	jimb-ppc64-linux-20030613-branch:1.59.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.59
	cagney_convert-20030606-branch:1.58.0.2
	cagney_convert-20030606-branchpoint:1.58
	cagney_writestrings-20030508-branch:1.54.0.4
	cagney_writestrings-20030508-branchpoint:1.54
	jimb-ppc64-linux-20030528-branch:1.56.0.2
	jimb-ppc64-linux-20030528-branchpoint:1.56
	carlton_dictionary-20030523-merge:1.56
	cagney_fileio-20030521-branch:1.55.0.2
	cagney_fileio-20030521-branchpoint:1.55
	kettenis_i386newframe-20030517-mergepoint:1.55
	jimb-ppc64-linux-20030509-branch:1.54.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.54
	kettenis_i386newframe-20030504-mergepoint:1.53
	carlton_dictionary-20030430-merge:1.53
	kettenis_i386newframe-20030419-branch:1.53.0.6
	kettenis_i386newframe-20030419-branchpoint:1.53
	carlton_dictionary-20030416-merge:1.53
	cagney_frameaddr-20030409-mergepoint:1.53
	kettenis_i386newframe-20030406-branch:1.53.0.4
	kettenis_i386newframe-20030406-branchpoint:1.53
	cagney_frameaddr-20030403-branchpoint:1.53
	cagney_frameaddr-20030403-branch:1.53.0.2
	cagney_framebase-20030330-mergepoint:1.52
	cagney_framebase-20030326-branch:1.52.0.4
	cagney_framebase-20030326-branchpoint:1.52
	cagney_lazyid-20030317-branch:1.52.0.2
	cagney_lazyid-20030317-branchpoint:1.52
	kettenis-i386newframe-20030316-mergepoint:1.52
	offbyone-20030313-branch:1.51.0.2
	offbyone-20030313-branchpoint:1.51
	kettenis-i386newframe-20030308-branch:1.50.0.4
	kettenis-i386newframe-20030308-branchpoint:1.50
	carlton_dictionary-20030305-merge:1.50
	cagney_offbyone-20030303-branch:1.50.0.2
	cagney_offbyone-20030303-branchpoint:1.50
	carlton_dictionary-20030207-merge:1.45
	interps-20030203-mergepoint:1.44
	interps-20030202-branch:1.44.0.2
	interps-20030202-branchpoint:1.44
	cagney-unwind-20030108-branch:1.43.0.2
	cagney-unwind-20030108-branchpoint:1.43
	carlton_dictionary-20021223-merge:1.42
	gdb_5_3-2002-12-12-release:1.35
	carlton_dictionary-20021115-merge:1.40
	kseitz_interps-20021105-merge:1.38
	kseitz_interps-20021103-merge:1.38
	drow-cplus-merge-20021020:1.35
	drow-cplus-merge-20021025:1.38
	carlton_dictionary-20021025-merge:1.38
	carlton_dictionary-20021011-merge:1.35
	drow-cplus-branch:1.35.0.10
	drow-cplus-branchpoint:1.35
	kseitz_interps-20020930-merge:1.35
	carlton_dictionary-20020927-merge:1.35
	carlton_dictionary-branch:1.35.0.8
	carlton_dictionary-20020920-branchpoint:1.35
	gdb_5_3-branch:1.35.0.6
	gdb_5_3-2002-09-04-branchpoint:1.35
	kseitz_interps-20020829-merge:1.35
	cagney_sysregs-20020825-branch:1.35.0.4
	cagney_sysregs-20020825-branchpoint:1.35
	readline_4_3-import-branch:1.35.0.2
	readline_4_3-import-branchpoint:1.35
	gdb_5_2_1-2002-07-23-release:1.28
	kseitz_interps-20020528-branch:1.34.0.4
	kseitz_interps-20020528-branchpoint:1.34
	cagney_regbuf-20020515-branch:1.34.0.2
	cagney_regbuf-20020515-branchpoint:1.34
	jimb-macro-020506-branch:1.32.0.2
	jimb-macro-020506-branchpoint:1.32
	gdb_5_2-2002-04-29-release:1.28
	gdb_5_2-branch:1.28.0.2
	gdb_5_2-2002-03-03-branchpoint:1.28
	gdb_5_1_1-2002-01-24-release:1.21
	gdb_5_1_0_1-2002-01-03-release:1.21
	cygnus_cvs_20020108_pre:1.27
	gdb_5_1_0_1-2002-01-03-branchpoint:1.21
	gdb_5_1_0_1-2002-01-03-branch:1.21.0.6
	gdb_5_1-2001-11-21-release:1.21
	gdb_s390-2001-09-26-branch:1.21.0.4
	gdb_s390-2001-09-26-branchpoint:1.21
	gdb_5_1-2001-07-29-branch:1.21.0.2
	gdb_5_1-2001-07-29-branchpoint:1.21
	dberlin-typesystem-branch:1.19.0.2
	dberlin-typesystem-branchpoint:1.19
	gdb-post-ptid_t-2001-05-03:1.19
	gdb-pre-ptid_t-2001-05-03:1.19
	insight-precleanup-2001-01-01:1.15
	gdb-post-protoization-2000-07-29:1.15
	gdb-pre-protoization-2000-07-29:1.14
	gdb-premipsmulti-2000-06-06-branch:1.13.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.13
	gdb-post-params-removal-2000-06-04:1.12
	gdb-pre-params-removal-2000-06-04:1.12
	gdb-post-params-removal-2000-05-28:1.12
	gdb-pre-params-removal-2000-05-28:1.11
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.5
	repo-unification-2000-02-06:1.1.1.9
	insight-2000-02-04:1.1.1.9
	gdb-2000-02-04:1.1.1.9
	gdb-2000-02-02:1.1.1.9
	gdb-2000-02-01:1.1.1.9
	gdb-2000-01-31:1.1.1.9
	gdb-2000-01-26:1.1.1.8
	gdb-2000-01-24:1.1.1.8
	gdb-2000-01-17:1.1.1.8
	gdb-2000-01-10:1.1.1.8
	gdb-2000-01-05:1.1.1.8
	gdb-1999-12-21:1.1.1.8
	gdb-1999-12-13:1.1.1.8
	gdb-1999-12-07:1.1.1.8
	gdb-1999-12-06:1.1.1.8
	gdb-1999-11-16:1.1.1.7
	gdb-1999-11-08:1.1.1.7
	gdb-1999-11-01:1.1.1.7
	gdb-1999-10-25:1.1.1.7
	gdb-1999-10-18:1.1.1.7
	gdb-1999-10-11:1.1.1.7
	gdb-1999-10-04:1.1.1.7
	gdb-1999-09-28:1.1.1.7
	gdb-1999-09-21:1.1.1.7
	gdb-1999-09-13:1.1.1.7
	gdb-1999-09-08:1.1.1.7
	gdb-1999-08-30:1.1.1.6
	gdb-1999-08-23:1.1.1.6
	gdb-1999-08-16:1.1.1.6
	gdb-1999-08-09:1.1.1.6
	gdb-1999-08-02:1.1.1.5
	gdb-1999-07-26:1.1.1.5
	gdb-1999-07-19:1.1.1.5
	gdb-1999-07-12:1.1.1.5
	gdb-post-reformat-19990707:1.1.1.5
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.5
	gdb-pre-reformat-19990707:1.1.1.4
	gdb-1999-07-07:1.1.1.4
	gdb-1999-07-05:1.1.1.4
	gdb-1999-06-28:1.1.1.4
	gdb-1999-06-21:1.1.1.4
	gdb-1999-06-14:1.1.1.4
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.154
date	2013.10.02.16.15.44;	author palves;	state Exp;
branches;
next	1.153;

1.153
date	2013.09.05.14.02.16;	author palves;	state Exp;
branches;
next	1.152;

1.152
date	2013.08.29.12.25.03;	author sagovic;	state Exp;
branches;
next	1.151;

1.151
date	2013.07.04.18.10.04;	author palves;	state Exp;
branches;
next	1.150;

1.150
date	2013.04.08.20.18.11;	author tromey;	state Exp;
branches;
next	1.149;

1.149
date	2013.03.20.18.35.22;	author tromey;	state Exp;
branches;
next	1.148;

1.148
date	2013.01.01.06.32.42;	author brobecke;	state Exp;
branches;
next	1.147;

1.147
date	2012.09.25.12.48.52;	author siddhesh;	state Exp;
branches;
next	1.146;

1.146
date	2012.09.21.17.17.19;	author aburgess;	state Exp;
branches;
next	1.145;

1.145
date	2012.06.05.13.50.49;	author brobecke;	state Exp;
branches;
next	1.144;

1.144
date	2012.06.05.13.50.40;	author brobecke;	state Exp;
branches;
next	1.143;

1.143
date	2012.05.10.16.24.40;	author brobecke;	state Exp;
branches;
next	1.142;

1.142
date	2012.03.02.19.29.00;	author brobecke;	state Exp;
branches;
next	1.141;

1.141
date	2012.01.04.08.17.02;	author brobecke;	state Exp;
branches;
next	1.140;

1.140
date	2011.11.18.20.03.42;	author uweigand;	state Exp;
branches
	1.140.2.1;
next	1.139;

1.139
date	2011.11.10.17.14.40;	author brobecke;	state Exp;
branches;
next	1.138;

1.138
date	2011.10.27.17.05.40;	author brobecke;	state Exp;
branches;
next	1.137;

1.137
date	2011.09.08.15.26.08;	author jkratoch;	state Exp;
branches;
next	1.136;

1.136
date	2011.07.22.15.31.50;	author tromey;	state Exp;
branches;
next	1.135;

1.135
date	2011.07.12.21.16.48;	author jkratoch;	state Exp;
branches;
next	1.134;

1.134
date	2011.03.18.18.42.41;	author palves;	state Exp;
branches;
next	1.133;

1.133
date	2011.03.18.18.41.36;	author palves;	state Exp;
branches;
next	1.132;

1.132
date	2011.01.12.16.10.04;	author jkratoch;	state Exp;
branches;
next	1.131;

1.131
date	2011.01.07.19.36.17;	author msnyder;	state Exp;
branches;
next	1.130;

1.130
date	2011.01.01.15.33.04;	author brobecke;	state Exp;
branches;
next	1.129;

1.129
date	2010.05.14.19.27.05;	author msnyder;	state Exp;
branches;
next	1.128;

1.128
date	2010.01.01.07.31.31;	author brobecke;	state Exp;
branches;
next	1.127;

1.127
date	2009.11.11.19.27.02;	author msnyder;	state Exp;
branches;
next	1.126;

1.126
date	2009.07.02.17.25.53;	author uweigand;	state Exp;
branches;
next	1.125;

1.125
date	2009.07.02.12.57.14;	author uweigand;	state Exp;
branches;
next	1.124;

1.124
date	2009.06.17.18.50.31;	author uweigand;	state Exp;
branches;
next	1.123;

1.123
date	2009.06.04.12.28.39;	author uweigand;	state Exp;
branches;
next	1.122;

1.122
date	2009.05.28.00.53.51;	author tromey;	state Exp;
branches;
next	1.121;

1.121
date	2009.01.15.15.38.07;	author uweigand;	state Exp;
branches;
next	1.120;

1.120
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.119;

1.119
date	2008.12.02.14.51.00;	author jkratoch;	state Exp;
branches;
next	1.118;

1.118
date	2008.09.05.11.37.17;	author uweigand;	state Exp;
branches;
next	1.117;

1.117
date	2008.08.21.20.29.00;	author uweigand;	state Exp;
branches;
next	1.116;

1.116
date	2008.08.21.18.14.38;	author drow;	state Exp;
branches;
next	1.115;

1.115
date	2008.07.15.17.53.11;	author drow;	state Exp;
branches;
next	1.114;

1.114
date	2008.05.27.19.29.51;	author schwab;	state Exp;
branches;
next	1.113;

1.113
date	2008.05.22.17.00.07;	author uweigand;	state Exp;
branches;
next	1.112;

1.112
date	2008.05.22.16.59.01;	author uweigand;	state Exp;
branches;
next	1.111;

1.111
date	2008.05.22.16.58.02;	author uweigand;	state Exp;
branches;
next	1.110;

1.110
date	2008.04.30.21.13.49;	author drow;	state Exp;
branches;
next	1.109;

1.109
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.108;

1.108
date	2007.10.08.12.44.09;	author uweigand;	state Exp;
branches;
next	1.107;

1.107
date	2007.08.23.18.08.31;	author brobecke;	state Exp;
branches;
next	1.106;

1.106
date	2007.06.12.16.51.13;	author uweigand;	state Exp;
branches;
next	1.105;

1.105
date	2007.06.09.13.42.15;	author uweigand;	state Exp;
branches;
next	1.104;

1.104
date	2007.06.06.15.23.05;	author uweigand;	state Exp;
branches;
next	1.103;

1.103
date	2007.05.31.17.32.20;	author uweigand;	state Exp;
branches;
next	1.102;

1.102
date	2007.05.31.17.00.06;	author uweigand;	state Exp;
branches;
next	1.101;

1.101
date	2007.05.06.19.37.30;	author uweigand;	state Exp;
branches;
next	1.100;

1.100
date	2007.02.27.19.46.04;	author drow;	state Exp;
branches;
next	1.99;

1.99
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.98;

1.98
date	2007.01.08.20.03.48;	author uweigand;	state Exp;
branches;
next	1.97;

1.97
date	2007.01.08.17.34.12;	author uweigand;	state Exp;
branches;
next	1.96;

1.96
date	2006.11.22.13.44.45;	author uweigand;	state Exp;
branches;
next	1.95;

1.95
date	2006.01.17.22.30.29;	author jimb;	state Exp;
branches
	1.95.18.1;
next	1.94;

1.94
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.93;

1.93
date	2005.05.22.14.53.33;	author cagney;	state Exp;
branches;
next	1.92;

1.92
date	2005.05.19.17.55.53;	author cagney;	state Exp;
branches;
next	1.91;

1.91
date	2005.05.14.06.07.41;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2005.03.07.22.38.04;	author drow;	state Exp;
branches;
next	1.89;

1.89
date	2005.02.11.18.13.49;	author cagney;	state Exp;
branches;
next	1.88;

1.88
date	2005.02.11.04.05.47;	author cagney;	state Exp;
branches;
next	1.87;

1.87
date	2005.02.08.02.29.17;	author cagney;	state Exp;
branches;
next	1.86;

1.86
date	2005.02.07.15.04.42;	author cagney;	state Exp;
branches;
next	1.85;

1.85
date	2005.02.07.04.50.27;	author cagney;	state Exp;
branches;
next	1.84;

1.84
date	2005.02.02.22.34.34;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2005.02.02.00.20.03;	author cagney;	state Exp;
branches;
next	1.82;

1.82
date	2004.11.15.22.17.59;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2004.11.13.02.29.48;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2004.11.13.00.53.09;	author cagney;	state Exp;
branches;
next	1.79;

1.79
date	2004.11.12.21.45.06;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2004.11.09.14.43.25;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2004.08.03.00.57.25;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2004.08.02.21.58.44;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2004.06.09.20.42.28;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2004.02.19.22.45.25;	author jimb;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2004.02.18.04.26.09;	author jimb;	state Exp;
branches;
next	1.72;

1.72
date	2004.02.18.03.12.11;	author jimb;	state Exp;
branches;
next	1.71;

1.71
date	2004.02.14.22.23.46;	author cagney;	state Exp;
branches;
next	1.70;

1.70
date	2004.02.12.00.17.52;	author fnf;	state Exp;
branches;
next	1.69;

1.69
date	2004.02.06.18.30.47;	author fnf;	state Exp;
branches;
next	1.68;

1.68
date	2004.01.26.20.36.32;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2003.10.02.20.28.29;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2003.09.30.19.12.18;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2003.09.14.16.32.12;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2003.09.08.18.56.03;	author drow;	state Exp;
branches;
next	1.62;

1.62
date	2003.07.22.15.41.59;	author ezannoni;	state Exp;
branches;
next	1.61;

1.61
date	2003.07.07.14.36.57;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.14.22.35.23;	author cagney;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2003.06.11.19.38.25;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.05.20.59.16;	author cagney;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2003.06.02.02.09.39;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2003.05.22.18.37.05;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2003.05.13.19.27.27;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2003.05.08.20.52.47;	author cagney;	state Exp;
branches
	1.54.4.1;
next	1.53;

1.53
date	2003.04.01.19.11.01;	author cagney;	state Exp;
branches
	1.53.6.1;
next	1.52;

1.52
date	2003.03.14.17.07.00;	author cagney;	state Exp;
branches
	1.52.4.1;
next	1.51;

1.51
date	2003.03.12.22.39.16;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2003.03.01.17.03.19;	author cagney;	state Exp;
branches
	1.50.4.1;
next	1.49;

1.49
date	2003.02.25.21.36.17;	author carlton;	state Exp;
branches;
next	1.48;

1.48
date	2003.02.21.15.24.17;	author drow;	state Exp;
branches;
next	1.47;

1.47
date	2003.02.20.17.17.23;	author carlton;	state Exp;
branches;
next	1.46;

1.46
date	2003.02.20.00.01.05;	author carlton;	state Exp;
branches;
next	1.45;

1.45
date	2003.02.04.22.04.08;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2003.01.14.00.49.03;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2003.01.06.18.49.08;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2002.11.29.19.15.14;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2002.11.24.19.48.12;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.13.18.13.17;	author jimb;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.12.02.39.40;	author ezannoni;	state Exp;
branches;
next	1.38;

1.38
date	2002.10.21.20.11.36;	author ezannoni;	state Exp;
branches;
next	1.37;

1.37
date	2002.10.21.19.11.50;	author ezannoni;	state Exp;
branches;
next	1.36;

1.36
date	2002.10.21.14.55.18;	author ezannoni;	state Exp;
branches;
next	1.35;

1.35
date	2002.07.24.22.46.48;	author cagney;	state Exp;
branches
	1.35.8.1
	1.35.10.1;
next	1.34;

1.34
date	2002.05.15.01.01.56;	author cagney;	state Exp;
branches
	1.34.4.1;
next	1.33;

1.33
date	2002.05.12.03.09.11;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.23.03.00.57;	author thorpej;	state Exp;
branches;
next	1.31;

1.31
date	2002.04.09.03.06.13;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2002.04.05.22.04.41;	author jimb;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.16.02.57.42;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.10.02.47.11;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.05.04.30.17;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.03.08.41.10;	author muller;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.10.21.34.56;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.16.01.58.07;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.24.19.46.15;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.01.18.39.23;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.16.22.57.50;	author nsd;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.10.21.24.48;	author jimb;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.06.08.21.07;	author kevinb;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.08.06.03.52;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.06.20.05.40;	author msnyder;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.10.06.16.51;	author msnyder;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.04.13.46.37;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.28.01.12.27;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.24.17.25.39;	author msnyder;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.02.09.36.56;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.27.15.33.01;	author msnyder;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.17.02.27.36;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.16.16.04.53;	author jimb;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.14.18.43.41;	author jimb;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.31.22.04.50;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.04.01.05.48;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.02.06.50.50;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.04.39.02;	author kingdon;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.00;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.140.2.1
date	2012.01.06.04.43.11;	author brobecke;	state Exp;
branches;
next	;

1.95.18.1
date	2006.11.24.19.59.57;	author uweigand;	state Exp;
branches;
next	;

1.74.2.1
date	2004.09.16.17.01.03;	author drow;	state Exp;
branches;
next	;

1.60.2.1
date	2003.07.22.15.44.10;	author ezannoni;	state Exp;
branches;
next	1.60.2.2;

1.60.2.2
date	2003.09.08.18.58.13;	author drow;	state Exp;
branches;
next	;

1.58.2.1
date	2003.06.06.18.02.28;	author cagney;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2003.06.08.22.14.41;	author cagney;	state Exp;
branches;
next	;

1.54.4.1
date	2003.06.03.20.54.35;	author cagney;	state Exp;
branches;
next	;

1.53.6.1
date	2003.05.18.09.44.06;	author kettenis;	state Exp;
branches;
next	;

1.52.4.1
date	2003.03.26.20.33.47;	author cagney;	state Exp;
branches;
next	;

1.50.4.1
date	2003.03.16.14.01.48;	author kettenis;	state Exp;
branches;
next	;

1.35.8.1
date	2002.10.18.23.42.58;	author carlton;	state Exp;
branches;
next	1.35.8.2;

1.35.8.2
date	2002.10.25.23.49.53;	author carlton;	state Exp;
branches;
next	1.35.8.3;

1.35.8.3
date	2002.11.15.19.18.43;	author carlton;	state Exp;
branches;
next	1.35.8.4;

1.35.8.4
date	2002.11.23.00.42.54;	author carlton;	state Exp;
branches;
next	1.35.8.5;

1.35.8.5
date	2002.12.21.00.17.43;	author carlton;	state Exp;
branches;
next	1.35.8.6;

1.35.8.6
date	2002.12.23.19.38.22;	author carlton;	state Exp;
branches;
next	1.35.8.7;

1.35.8.7
date	2003.02.07.19.17.48;	author carlton;	state Exp;
branches;
next	1.35.8.8;

1.35.8.8
date	2003.03.06.00.56.27;	author carlton;	state Exp;
branches;
next	1.35.8.9;

1.35.8.9
date	2003.03.07.22.52.53;	author carlton;	state Exp;
branches;
next	1.35.8.10;

1.35.8.10
date	2003.04.16.19.56.52;	author carlton;	state Exp;
branches;
next	1.35.8.11;

1.35.8.11
date	2003.05.23.18.40.37;	author carlton;	state Exp;
branches;
next	1.35.8.12;

1.35.8.12
date	2003.06.27.21.49.54;	author carlton;	state Exp;
branches;
next	1.35.8.13;

1.35.8.13
date	2003.08.05.17.13.05;	author carlton;	state Exp;
branches;
next	1.35.8.14;

1.35.8.14
date	2003.09.17.21.28.17;	author carlton;	state Exp;
branches;
next	1.35.8.15;

1.35.8.15
date	2003.11.11.23.50.43;	author carlton;	state Exp;
branches;
next	;

1.35.10.1
date	2002.10.26.17.12.06;	author drow;	state Exp;
branches;
next	1.35.10.2;

1.35.10.2
date	2003.12.14.20.27.12;	author drow;	state Exp;
branches;
next	1.35.10.3;

1.35.10.3
date	2004.02.09.19.43.36;	author drow;	state Exp;
branches;
next	;

1.34.4.1
date	2002.08.09.18.34.24;	author kseitz;	state Exp;
branches;
next	1.34.4.2;

1.34.4.2
date	2002.11.04.00.17.30;	author ezannoni;	state Exp;
branches;
next	;

1.19.2.1
date	2001.07.06.19.16.59;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.00;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.08;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.25.18.01.55;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.06.14.18.07.30;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.07.20.06.06;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.09.21.33.26;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.09.08.23.59.10;	author shebs;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.12.07.03.56.00;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2000.02.01.03.19.06;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.154
log
@Print registers not saved in the frame as "<not saved>" instead of "<optimized out>".

Currently, in some scenarios, GDB prints <optimized out> when printing
outer frame registers.  An <optimized out> register is a confusing
concept.  What this really means is that the register is
call-clobbered, or IOW, not saved by the callee.  This patch makes GDB
say that instead.

Before patch:

 (gdb) p/x $rax $1 = <optimized out>
 (gdb) info registers rax
 rax            <optimized out>

After patch:

 (gdb) p/x $rax
 $1 = <not saved>
 (gdb) info registers rax
 rax            <not saved>

However, if for some reason the debug info describes a variable as
being in such a register (**), we still want to print <optimized out>
when printing the variable.  IOW, <not saved> is reserved for
inspecting registers at the machine level.  The patch uses
lval_register+optimized_out to encode the not saved registers, and
makes it so that optimized out variables always end up in
!lval_register values.

** See <https://sourceware.org/ml/gdb-patches/2012-08/msg00787.html>.
Current/recent enough GCC doesn't mark variables/arguments as being in
call-clobbered registers in the ranges corresponding to function
calls, while older GCCs did.  Newer GCCs will just not say where the
variable is, so GDB will end up realizing the variable is optimized
out.

frame_unwind_got_optimized creates not_lval optimized out registers,
so by default, in most cases, we'll see <optimized out>.

value_of_register is the function eval.c uses for evaluating
OP_REGISTER (again, $pc, etc.), and related bits.  It isn't used for
anything else.  This function makes sure to return lval_register
values.  The patch makes "info registers" and the MI equivalent use it
too.  I think it just makes a lot of sense, as this makes it so that
when printing machine registers ($pc, etc.), we go through a central
function.

We're likely to need a different encoding at some point, if/when we
support partially saved registers.  Even then, I think
value_of_register will still be the spot to tag the intention to print
machine register values differently.

value_from_register however may also return optimized out
lval_register values, so at a couple places where we're computing a
variable's location from a dwarf expression, we convert the resulting
value away from lval_register to a regular optimized out value.

Tested on x86_64 Fedora 17

gdb/
2013-10-02  Pedro Alves  <palves@@redhat.com>

	* cp-valprint.c (cp_print_value_fields): Adjust calls to
	val_print_optimized_out.
	* jv-valprint.c (java_print_value_fields): Likewise.
	* p-valprint.c (pascal_object_print_value_fields): Likewise.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full)
	<DWARF_VALUE_REGISTER>: If the register was not saved, return a
	new optimized out value.
	* findvar.c (address_from_register): Likewise.
	* frame.c (put_frame_register): Tweak error string to say the
	register was not saved, rather than optimized out.
	* infcmd.c (default_print_one_register_info): Adjust call to
	val_print_optimized_out.  Use value_of_register instead of
	get_frame_register_value.
	* mi/mi-main.c (output_register): Use value_of_register instead of
	get_frame_register_value.
	* valprint.c (valprint_check_validity): Likewise.
	(val_print_optimized_out): New value parameter.  If the value is
	lval_register, print <not saved> instead.
	(value_check_printable, val_print_scalar_formatted): Adjust calls
	to val_print_optimized_out.
	* valprint.h (val_print_optimized_out): New value parameter.
	* value.c (struct value) <optimized_out>: Extend comment.
	(error_value_optimized_out): New function.
	(require_not_optimized_out): Use it.  Use a different string for
	lval_register values.
	* value.h (error_value_optimized_out): New declaration.
	* NEWS: Mention <not saved>.

gdb/testsuite/
2013-10-02  Pedro Alves  <palves@@redhat.com>

	* gdb.dwarf2/dw2-reg-undefined.exp <pattern_rax_rbx_rcx_print,
	pattern_rax_rbx_rcx_info>: Set to "<not saved>".
	* gdb.mi/mi-reg-undefined.exp (opt_out_pattern): Delete.
	(not_saved_pattern): New.
	Replace use of the former with the latter.

gdb/doc/
2013-10-02  Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo (Registers): Expand description of saved registers
	in frames.  Explain <not saved>.
@
text
@/* Find a variable's value in memory, for GDB, the GNU debugger.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "frame.h"
#include "value.h"
#include "gdbcore.h"
#include "inferior.h"
#include "target.h"
#include "gdb_string.h"
#include "gdb_assert.h"
#include "floatformat.h"
#include "symfile.h"		/* for overlay functions */
#include "regcache.h"
#include "user-regs.h"
#include "block.h"
#include "objfiles.h"
#include "language.h"

/* Basic byte-swapping routines.  All 'extract' functions return a
   host-format integer from a target-format integer at ADDR which is
   LEN bytes long.  */

#if TARGET_CHAR_BIT != 8 || HOST_CHAR_BIT != 8
  /* 8 bit characters are a pretty safe assumption these days, so we
     assume it throughout all these swapping routines.  If we had to deal with
     9 bit characters, we would need to make len be in bits and would have
     to re-write these routines...  */
you lose
#endif

LONGEST
extract_signed_integer (const gdb_byte *addr, int len,
			enum bfd_endian byte_order)
{
  LONGEST retval;
  const unsigned char *p;
  const unsigned char *startaddr = addr;
  const unsigned char *endaddr = startaddr + len;

  if (len > (int) sizeof (LONGEST))
    error (_("\
That operation is not available on integers of more than %d bytes."),
	   (int) sizeof (LONGEST));

  /* Start at the most significant end of the integer, and work towards
     the least significant.  */
  if (byte_order == BFD_ENDIAN_BIG)
    {
      p = startaddr;
      /* Do the sign extension once at the start.  */
      retval = ((LONGEST) * p ^ 0x80) - 0x80;
      for (++p; p < endaddr; ++p)
	retval = (retval << 8) | *p;
    }
  else
    {
      p = endaddr - 1;
      /* Do the sign extension once at the start.  */
      retval = ((LONGEST) * p ^ 0x80) - 0x80;
      for (--p; p >= startaddr; --p)
	retval = (retval << 8) | *p;
    }
  return retval;
}

ULONGEST
extract_unsigned_integer (const gdb_byte *addr, int len,
			  enum bfd_endian byte_order)
{
  ULONGEST retval;
  const unsigned char *p;
  const unsigned char *startaddr = addr;
  const unsigned char *endaddr = startaddr + len;

  if (len > (int) sizeof (ULONGEST))
    error (_("\
That operation is not available on integers of more than %d bytes."),
	   (int) sizeof (ULONGEST));

  /* Start at the most significant end of the integer, and work towards
     the least significant.  */
  retval = 0;
  if (byte_order == BFD_ENDIAN_BIG)
    {
      for (p = startaddr; p < endaddr; ++p)
	retval = (retval << 8) | *p;
    }
  else
    {
      for (p = endaddr - 1; p >= startaddr; --p)
	retval = (retval << 8) | *p;
    }
  return retval;
}

/* Sometimes a long long unsigned integer can be extracted as a
   LONGEST value.  This is done so that we can print these values
   better.  If this integer can be converted to a LONGEST, this
   function returns 1 and sets *PVAL.  Otherwise it returns 0.  */

int
extract_long_unsigned_integer (const gdb_byte *addr, int orig_len,
			       enum bfd_endian byte_order, LONGEST *pval)
{
  const gdb_byte *p;
  const gdb_byte *first_addr;
  int len;

  len = orig_len;
  if (byte_order == BFD_ENDIAN_BIG)
    {
      for (p = addr;
	   len > (int) sizeof (LONGEST) && p < addr + orig_len;
	   p++)
	{
	  if (*p == 0)
	    len--;
	  else
	    break;
	}
      first_addr = p;
    }
  else
    {
      first_addr = addr;
      for (p = addr + orig_len - 1;
	   len > (int) sizeof (LONGEST) && p >= addr;
	   p--)
	{
	  if (*p == 0)
	    len--;
	  else
	    break;
	}
    }

  if (len <= (int) sizeof (LONGEST))
    {
      *pval = (LONGEST) extract_unsigned_integer (first_addr,
						  sizeof (LONGEST),
						  byte_order);
      return 1;
    }

  return 0;
}


/* Treat the bytes at BUF as a pointer of type TYPE, and return the
   address it represents.  */
CORE_ADDR
extract_typed_address (const gdb_byte *buf, struct type *type)
{
  if (TYPE_CODE (type) != TYPE_CODE_PTR
      && TYPE_CODE (type) != TYPE_CODE_REF)
    internal_error (__FILE__, __LINE__,
		    _("extract_typed_address: "
		    "type is not a pointer or reference"));

  return gdbarch_pointer_to_address (get_type_arch (type), type, buf);
}

/* All 'store' functions accept a host-format integer and store a
   target-format integer at ADDR which is LEN bytes long.  */

void
store_signed_integer (gdb_byte *addr, int len,
		      enum bfd_endian byte_order, LONGEST val)
{
  gdb_byte *p;
  gdb_byte *startaddr = addr;
  gdb_byte *endaddr = startaddr + len;

  /* Start at the least significant end of the integer, and work towards
     the most significant.  */
  if (byte_order == BFD_ENDIAN_BIG)
    {
      for (p = endaddr - 1; p >= startaddr; --p)
	{
	  *p = val & 0xff;
	  val >>= 8;
	}
    }
  else
    {
      for (p = startaddr; p < endaddr; ++p)
	{
	  *p = val & 0xff;
	  val >>= 8;
	}
    }
}

void
store_unsigned_integer (gdb_byte *addr, int len,
			enum bfd_endian byte_order, ULONGEST val)
{
  unsigned char *p;
  unsigned char *startaddr = (unsigned char *) addr;
  unsigned char *endaddr = startaddr + len;

  /* Start at the least significant end of the integer, and work towards
     the most significant.  */
  if (byte_order == BFD_ENDIAN_BIG)
    {
      for (p = endaddr - 1; p >= startaddr; --p)
	{
	  *p = val & 0xff;
	  val >>= 8;
	}
    }
  else
    {
      for (p = startaddr; p < endaddr; ++p)
	{
	  *p = val & 0xff;
	  val >>= 8;
	}
    }
}

/* Store the address ADDR as a pointer of type TYPE at BUF, in target
   form.  */
void
store_typed_address (gdb_byte *buf, struct type *type, CORE_ADDR addr)
{
  if (TYPE_CODE (type) != TYPE_CODE_PTR
      && TYPE_CODE (type) != TYPE_CODE_REF)
    internal_error (__FILE__, __LINE__,
		    _("store_typed_address: "
		    "type is not a pointer or reference"));

  gdbarch_address_to_pointer (get_type_arch (type), type, buf, addr);
}



/* Return a `value' with the contents of (virtual or cooked) register
   REGNUM as found in the specified FRAME.  The register's type is
   determined by register_type().  */

struct value *
value_of_register (int regnum, struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct value *reg_val;

  /* User registers lie completely outside of the range of normal
     registers.  Catch them early so that the target never sees them.  */
  if (regnum >= gdbarch_num_regs (gdbarch)
		+ gdbarch_num_pseudo_regs (gdbarch))
    return value_of_user_reg (regnum, frame);

  reg_val = value_of_register_lazy (frame, regnum);
  value_fetch_lazy (reg_val);
  return reg_val;
}

/* Return a `value' with the contents of (virtual or cooked) register
   REGNUM as found in the specified FRAME.  The register's type is
   determined by register_type().  The value is not fetched.  */

struct value *
value_of_register_lazy (struct frame_info *frame, int regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct value *reg_val;

  gdb_assert (regnum < (gdbarch_num_regs (gdbarch)
			+ gdbarch_num_pseudo_regs (gdbarch)));

  /* We should have a valid (i.e. non-sentinel) frame.  */
  gdb_assert (frame_id_p (get_frame_id (frame)));

  reg_val = allocate_value_lazy (register_type (gdbarch, regnum));
  VALUE_LVAL (reg_val) = lval_register;
  VALUE_REGNUM (reg_val) = regnum;
  VALUE_FRAME_ID (reg_val) = get_frame_id (frame);
  return reg_val;
}

/* Given a pointer of type TYPE in target form in BUF, return the
   address it represents.  */
CORE_ADDR
unsigned_pointer_to_address (struct gdbarch *gdbarch,
			     struct type *type, const gdb_byte *buf)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  return extract_unsigned_integer (buf, TYPE_LENGTH (type), byte_order);
}

CORE_ADDR
signed_pointer_to_address (struct gdbarch *gdbarch,
			   struct type *type, const gdb_byte *buf)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  return extract_signed_integer (buf, TYPE_LENGTH (type), byte_order);
}

/* Given an address, store it as a pointer of type TYPE in target
   format in BUF.  */
void
unsigned_address_to_pointer (struct gdbarch *gdbarch, struct type *type,
			     gdb_byte *buf, CORE_ADDR addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  store_unsigned_integer (buf, TYPE_LENGTH (type), byte_order, addr);
}

void
address_to_signed_pointer (struct gdbarch *gdbarch, struct type *type,
			   gdb_byte *buf, CORE_ADDR addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  store_signed_integer (buf, TYPE_LENGTH (type), byte_order, addr);
}

/* Will calling read_var_value or locate_var_value on SYM end
   up caring what frame it is being evaluated relative to?  SYM must
   be non-NULL.  */
int
symbol_read_needs_frame (struct symbol *sym)
{
  if (SYMBOL_COMPUTED_OPS (sym) != NULL)
    return SYMBOL_COMPUTED_OPS (sym)->read_needs_frame (sym);

  switch (SYMBOL_CLASS (sym))
    {
      /* All cases listed explicitly so that gcc -Wall will detect it if
         we failed to consider one.  */
    case LOC_COMPUTED:
      gdb_assert_not_reached (_("LOC_COMPUTED variable missing a method"));

    case LOC_REGISTER:
    case LOC_ARG:
    case LOC_REF_ARG:
    case LOC_REGPARM_ADDR:
    case LOC_LOCAL:
      return 1;

    case LOC_UNDEF:
    case LOC_CONST:
    case LOC_STATIC:
    case LOC_TYPEDEF:

    case LOC_LABEL:
      /* Getting the address of a label can be done independently of the block,
         even if some *uses* of that address wouldn't work so well without
         the right frame.  */

    case LOC_BLOCK:
    case LOC_CONST_BYTES:
    case LOC_UNRESOLVED:
    case LOC_OPTIMIZED_OUT:
      return 0;
    }
  return 1;
}

/* Private data to be used with minsym_lookup_iterator_cb.  */

struct minsym_lookup_data
{
  /* The name of the minimal symbol we are searching for.  */
  const char *name;

  /* The field where the callback should store the minimal symbol
     if found.  It should be initialized to NULL before the search
     is started.  */
  struct minimal_symbol *result;

  /* The objfile in which the symbol was found.  */
  struct objfile *objfile;
};

/* A callback function for gdbarch_iterate_over_objfiles_in_search_order.
   It searches by name for a minimal symbol within the given OBJFILE.
   The arguments are passed via CB_DATA, which in reality is a pointer
   to struct minsym_lookup_data.  */

static int
minsym_lookup_iterator_cb (struct objfile *objfile, void *cb_data)
{
  struct minsym_lookup_data *data = (struct minsym_lookup_data *) cb_data;

  gdb_assert (data->result == NULL);

  data->result = lookup_minimal_symbol (data->name, NULL, objfile);
  data->objfile = objfile;

  /* The iterator should stop iff a match was found.  */
  return (data->result != NULL);
}

/* A default implementation for the "la_read_var_value" hook in
   the language vector which should work in most situations.  */

struct value *
default_read_var_value (struct symbol *var, struct frame_info *frame)
{
  struct value *v;
  struct type *type = SYMBOL_TYPE (var);
  CORE_ADDR addr;

  /* Call check_typedef on our type to make sure that, if TYPE is
     a TYPE_CODE_TYPEDEF, its length is set to the length of the target type
     instead of zero.  However, we do not replace the typedef type by the
     target type, because we want to keep the typedef in order to be able to
     set the returned value type description correctly.  */
  check_typedef (type);

  if (symbol_read_needs_frame (var))
    gdb_assert (frame);

  if (SYMBOL_COMPUTED_OPS (var) != NULL)
    return SYMBOL_COMPUTED_OPS (var)->read_variable (var, frame);

  switch (SYMBOL_CLASS (var))
    {
    case LOC_CONST:
      /* Put the constant back in target format.  */
      v = allocate_value (type);
      store_signed_integer (value_contents_raw (v), TYPE_LENGTH (type),
			    gdbarch_byte_order (get_type_arch (type)),
			    (LONGEST) SYMBOL_VALUE (var));
      VALUE_LVAL (v) = not_lval;
      return v;

    case LOC_LABEL:
      /* Put the constant back in target format.  */
      v = allocate_value (type);
      if (overlay_debugging)
	{
	  CORE_ADDR addr
	    = symbol_overlayed_address (SYMBOL_VALUE_ADDRESS (var),
					SYMBOL_OBJ_SECTION (SYMBOL_OBJFILE (var),
							    var));

	  store_typed_address (value_contents_raw (v), type, addr);
	}
      else
	store_typed_address (value_contents_raw (v), type,
			      SYMBOL_VALUE_ADDRESS (var));
      VALUE_LVAL (v) = not_lval;
      return v;

    case LOC_CONST_BYTES:
      v = allocate_value (type);
      memcpy (value_contents_raw (v), SYMBOL_VALUE_BYTES (var),
	      TYPE_LENGTH (type));
      VALUE_LVAL (v) = not_lval;
      return v;

    case LOC_STATIC:
      if (overlay_debugging)
	addr = symbol_overlayed_address (SYMBOL_VALUE_ADDRESS (var),
					 SYMBOL_OBJ_SECTION (SYMBOL_OBJFILE (var),
							     var));
      else
	addr = SYMBOL_VALUE_ADDRESS (var);
      break;

    case LOC_ARG:
      addr = get_frame_args_address (frame);
      if (!addr)
	error (_("Unknown argument list address for `%s'."),
	       SYMBOL_PRINT_NAME (var));
      addr += SYMBOL_VALUE (var);
      break;

    case LOC_REF_ARG:
      {
	struct value *ref;
	CORE_ADDR argref;

	argref = get_frame_args_address (frame);
	if (!argref)
	  error (_("Unknown argument list address for `%s'."),
		 SYMBOL_PRINT_NAME (var));
	argref += SYMBOL_VALUE (var);
	ref = value_at (lookup_pointer_type (type), argref);
	addr = value_as_address (ref);
	break;
      }

    case LOC_LOCAL:
      addr = get_frame_locals_address (frame);
      addr += SYMBOL_VALUE (var);
      break;

    case LOC_TYPEDEF:
      error (_("Cannot look up value of a typedef `%s'."),
	     SYMBOL_PRINT_NAME (var));
      break;

    case LOC_BLOCK:
      if (overlay_debugging)
	addr = symbol_overlayed_address
	  (BLOCK_START (SYMBOL_BLOCK_VALUE (var)), SYMBOL_OBJ_SECTION (SYMBOL_OBJFILE (var),
								       var));
      else
	addr = BLOCK_START (SYMBOL_BLOCK_VALUE (var));
      break;

    case LOC_REGISTER:
    case LOC_REGPARM_ADDR:
      {
	int regno = SYMBOL_REGISTER_OPS (var)
		      ->register_number (var, get_frame_arch (frame));
	struct value *regval;

	if (SYMBOL_CLASS (var) == LOC_REGPARM_ADDR)
	  {
	    regval = value_from_register (lookup_pointer_type (type),
					  regno,
					  frame);

	    if (regval == NULL)
	      error (_("Value of register variable not available for `%s'."),
	             SYMBOL_PRINT_NAME (var));

	    addr = value_as_address (regval);
	  }
	else
	  {
	    regval = value_from_register (type, regno, frame);

	    if (regval == NULL)
	      error (_("Value of register variable not available for `%s'."),
	             SYMBOL_PRINT_NAME (var));
	    return regval;
	  }
      }
      break;

    case LOC_COMPUTED:
      gdb_assert_not_reached (_("LOC_COMPUTED variable missing a method"));

    case LOC_UNRESOLVED:
      {
	struct minsym_lookup_data lookup_data;
	struct minimal_symbol *msym;
	struct obj_section *obj_section;

	memset (&lookup_data, 0, sizeof (lookup_data));
	lookup_data.name = SYMBOL_LINKAGE_NAME (var);

	gdbarch_iterate_over_objfiles_in_search_order
	  (get_objfile_arch (SYMBOL_SYMTAB (var)->objfile),
	   minsym_lookup_iterator_cb, &lookup_data,
	   SYMBOL_SYMTAB (var)->objfile);
	msym = lookup_data.result;

	if (msym == NULL)
	  error (_("No global symbol \"%s\"."), SYMBOL_LINKAGE_NAME (var));
	if (overlay_debugging)
	  addr = symbol_overlayed_address (SYMBOL_VALUE_ADDRESS (msym),
					   SYMBOL_OBJ_SECTION (lookup_data.objfile,
							       msym));
	else
	  addr = SYMBOL_VALUE_ADDRESS (msym);

	obj_section = SYMBOL_OBJ_SECTION (lookup_data.objfile, msym);
	if (obj_section
	    && (obj_section->the_bfd_section->flags & SEC_THREAD_LOCAL) != 0)
	  addr = target_translate_tls_address (obj_section->objfile, addr);
      }
      break;

    case LOC_OPTIMIZED_OUT:
      return allocate_optimized_out_value (type);

    default:
      error (_("Cannot look up value of a botched symbol `%s'."),
	     SYMBOL_PRINT_NAME (var));
      break;
    }

  v = value_at_lazy (type, addr);
  return v;
}

/* Calls VAR's language la_read_var_value hook with the given arguments.  */

struct value *
read_var_value (struct symbol *var, struct frame_info *frame)
{
  const struct language_defn *lang = language_def (SYMBOL_LANGUAGE (var));

  gdb_assert (lang != NULL);
  gdb_assert (lang->la_read_var_value != NULL);

  return lang->la_read_var_value (var, frame);
}

/* Install default attributes for register values.  */

struct value *
default_value_from_register (struct type *type, int regnum,
			     struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int len = TYPE_LENGTH (type);
  struct value *value = allocate_value (type);

  VALUE_LVAL (value) = lval_register;
  VALUE_FRAME_ID (value) = get_frame_id (frame);
  VALUE_REGNUM (value) = regnum;

  /* Any structure stored in more than one register will always be
     an integral number of registers.  Otherwise, you need to do
     some fiddling with the last register copied here for little
     endian machines.  */
  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG
      && len < register_size (gdbarch, regnum))
    /* Big-endian, and we want less than full size.  */
    set_value_offset (value, register_size (gdbarch, regnum) - len);
  else
    set_value_offset (value, 0);

  return value;
}

/* VALUE must be an lval_register value.  If regnum is the value's
   associated register number, and len the length of the values type,
   read one or more registers in FRAME, starting with register REGNUM,
   until we've read LEN bytes.

   If any of the registers we try to read are optimized out, then mark the
   complete resulting value as optimized out.  */

void
read_frame_register_value (struct value *value, struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int offset = 0;
  int reg_offset = value_offset (value);
  int regnum = VALUE_REGNUM (value);
  int len = TYPE_LENGTH (check_typedef (value_type (value)));

  gdb_assert (VALUE_LVAL (value) == lval_register);

  /* Skip registers wholly inside of REG_OFFSET.  */
  while (reg_offset >= register_size (gdbarch, regnum))
    {
      reg_offset -= register_size (gdbarch, regnum);
      regnum++;
    }

  /* Copy the data.  */
  while (len > 0)
    {
      struct value *regval = get_frame_register_value (frame, regnum);
      int reg_len = TYPE_LENGTH (value_type (regval)) - reg_offset;

      if (value_optimized_out (regval))
	{
	  set_value_optimized_out (value, 1);
	  break;
	}

      /* If the register length is larger than the number of bytes
         remaining to copy, then only copy the appropriate bytes.  */
      if (reg_len > len)
	reg_len = len;

      value_contents_copy (value, offset, regval, reg_offset, reg_len);

      offset += reg_len;
      len -= reg_len;
      reg_offset = 0;
      regnum++;
    }
}

/* Return a value of type TYPE, stored in register REGNUM, in frame FRAME.  */

struct value *
value_from_register (struct type *type, int regnum, struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct type *type1 = check_typedef (type);
  struct value *v;

  if (gdbarch_convert_register_p (gdbarch, regnum, type1))
    {
      int optim, unavail, ok;

      /* The ISA/ABI need to something weird when obtaining the
         specified value from this register.  It might need to
         re-order non-adjacent, starting with REGNUM (see MIPS and
         i386).  It might need to convert the [float] register into
         the corresponding [integer] type (see Alpha).  The assumption
         is that gdbarch_register_to_value populates the entire value
         including the location.  */
      v = allocate_value (type);
      VALUE_LVAL (v) = lval_register;
      VALUE_FRAME_ID (v) = get_frame_id (frame);
      VALUE_REGNUM (v) = regnum;
      ok = gdbarch_register_to_value (gdbarch, frame, regnum, type1,
				      value_contents_raw (v), &optim,
				      &unavail);

      if (!ok)
	{
	  if (optim)
	    set_value_optimized_out (v, 1);
	  if (unavail)
	    mark_value_bytes_unavailable (v, 0, TYPE_LENGTH (type));
	}
    }
  else
    {
      /* Construct the value.  */
      v = gdbarch_value_from_register (gdbarch, type, regnum, frame);

      /* Get the data.  */
      read_frame_register_value (v, frame);
    }

  return v;
}

/* Return contents of register REGNUM in frame FRAME as address,
   interpreted as value of type TYPE.   Will abort if register
   value is not available.  */

CORE_ADDR
address_from_register (struct type *type, int regnum, struct frame_info *frame)
{
  struct value *value;
  CORE_ADDR result;

  value = value_from_register (type, regnum, frame);
  gdb_assert (value);

  if (value_optimized_out (value))
    {
      /* This function is used while computing a location expression.
	 Complain about the value being optimized out, rather than
	 letting value_as_address complain about some random register
	 the expression depends on not being saved.  */
      error_value_optimized_out ();
    }

  result = value_as_address (value);
  release_value (value);
  value_free (value);

  return result;
}

@


1.153
log
@Rework value_of_register in terms of value_of_register_lazy.

I noticed that value_of_register (used for getting values _of_
registers ($pc, $rax, etc.), rather than variables _in_ registers),
kind of builds a franken-value, by propagating the lval and address of
the frame register value, but not the entire location, like necessary
for lval_computed (if some unwinder ever returns that, the resulting
value will misbehave).  This gets in the way of printing optimized out
(not saved) lval_registers differently from other optimized out
values, as it doesn't make sure the resulting value is lval_register.

I started out by just doing something like:

-  VALUE_LVAL (reg_val) = lval;
-  set_value_address (reg_val, addr);
+  VALUE_LVAL (reg_val) = lval_register;

... just like value_of_register_lazy below.  That's sufficient to fix
the issue.

Then I noticed this is using frame_register, which we should avoid
nowadays, for it returns elements of a value, but not all that's
sometimes necessary (unavailable-ness is all or nothing with it, for
instance), and considered using get_frame_register_value instead
(which returns a struct value), and value_contents_copy, just like
value_fetch_lazy's handling of lval_register.  But at that point, I
realized we might as well just defer all that work to
value_of_register_lazy/value_fetch_lazy...

Doing it this way adds a frame_find_by_id lookup (from within
value_fetch_lazy), while we already have a frame pointer handy in
value_of_register.  I considered factoring out the lazy register
fetching out of value_fetch_lazy, into a function that takes a frame
pointer and call that instead, avoiding the lookup, but then it looked
like too much complication for an early optimization, and went back to
keeping it simple.

Tested on x86_64 Fedora 17.

gdb/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* findvar.c (value_of_register): Rework in terms of
	value_of_register_lazy.
@
text
@d760 9
@


1.152
log
@cleanup: use value_lazy_at instead of allocate_value_lazy/attribute setter

I came across a pattern used to construct a value in the following way:

  struct value *val = allocate_value_lazy (type);
  VALUE_LVAL (val) = lval_memory;
  set_value_address (val, address);

Instead we fold the above call into:

  value_at_lazy (type, addr);

2013-08-27  Sanimir Agovic  <sanimir.agovic@@intel.com>

	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Use value_at_lazy instead
	of assembling value via allocate_value_lazy and attribute setter.
	* findvar.c (default_read_var_value): Use value_at_lazy instead of
	assembling value via allocate_value_lazy and attribute setter.
	* valops.c (do_search_struct_field): Use value_at_lazy instead of
	assembling value via allocate_value_lazy and attribute setter.
@
text
@a264 3
  CORE_ADDR addr;
  int optim;
  int unavail;
a265 4
  struct type *reg_type;
  int realnum;
  gdb_byte raw_buffer[MAX_REGISTER_SIZE];
  enum lval_type lval;
d273 2
a274 22
  frame_register (frame, regnum, &optim, &unavail,
		  &lval, &addr, &realnum, raw_buffer);

  reg_type = register_type (gdbarch, regnum);
  if (optim)
    reg_val = allocate_optimized_out_value (reg_type);
  else
    reg_val = allocate_value (reg_type);

  if (!optim && !unavail)
    memcpy (value_contents_raw (reg_val), raw_buffer,
	    register_size (gdbarch, regnum));
  else
    memset (value_contents_raw (reg_val), 0,
	    register_size (gdbarch, regnum));

  VALUE_LVAL (reg_val) = lval;
  set_value_address (reg_val, addr);
  VALUE_REGNUM (reg_val) = regnum;
  if (unavail)
    mark_value_bytes_unavailable (reg_val, 0, register_size (gdbarch, regnum));
  VALUE_FRAME_ID (reg_val) = get_frame_id (frame);
@


1.151
log
@Use allocate_optimized_out_value instead of set_value_optimized_out.

Allocate the value as optimized out from the start rather than allocating
a value with contents, and then marking it optimized out.

gdb/
2013-07-04  Pedro Alves  <palves@@redhat.com>

	* findvar.c (value_of_register): Use allocate_optimized_out_value
	if the register has been optimized out, instead of
	set_value_optimized_out.
	* frame-unwind.c (frame_unwind_got_optimized): Use
	allocate_optimized_out_value.
@
text
@a504 1
      v = allocate_value_lazy (type);
a518 1
      v = allocate_value_lazy (type);
a532 1
	v = allocate_value_lazy (type);
a538 1
      v = allocate_value_lazy (type);
a546 1
      v = allocate_value_lazy (type);
a572 1
	    v = allocate_value_lazy (type);
a616 1
	v = allocate_value_lazy (type);
d629 1
a629 2
  VALUE_LVAL (v) = lval_memory;
  set_value_address (v, addr);
@


1.150
log
@	PR symtab/8424:
	* blockframe.c (find_pc_partial_function_gnu_ifunc): Check
	SYMBOL_SECTION, not SYMBOL_OBJ_SECTION.
	* breakpoint.c (resolve_sal_pc): Update.
	* elfread.c (elf_gnu_ifunc_record_cache): Update.
	* findvar.c (struct minsym_lookup_data) <objfile>: New field.
	(minsym_lookup_iterator_cb): Use it.
	(default_read_var_value): Update.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline):
	Update.
	* infcmd.c (jump_command): Update.
	* linespec.c (minsym_found): Update.
	* maint.c (maintenance_translate_address): Update.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Update.
	(prim_record_minimal_symbol_full): Don't set SYMBOL_OBJ_SECTION.
	* parse.c (write_exp_msymbol): Update.
	* printcmd.c (address_info): Update.
	* psymtab.c (find_pc_sect_psymbol): Update.
	(fixup_psymbol_section): Check SYMBOL_SECTION, not
	SYMBOL_OBJ_SECTION.
	(add_psymbol_to_bcache): Correctly initialize SYMBOL_SECTION.
	Don't initialize SYMBOL_OBJ_SECTION.
	* spu-tdep.c (spu_catch_start): Update.
	* stabsread.c (define_symbol): Don't set SYMBOL_SECTION.
	* symmisc.c (dump_msymbols, print_symbol): Update.
	* symtab.c (fixup_section): Don't set 'obj_section'.  Change
	how fallback section is computed.
	(fixup_symbol_section): Update.
	(find_pc_sect_symtab, find_function_start_sal, skip_prologue_sal):
	Update.
	(allocate_symbol, initialize_symbol, allocate_template_symbol):
	Initialize SYMBOL_SECTION.
	* symtab.h (struct general_symbol_info) <section>: Update comment.
	<obj_section>: Remove.
	(SYMBOL_OBJ_SECTION): Add 'objfile' argument.  Rewrite.
	(SYMBOL_OBJFILE): New macro.
@
text
@d269 1
d283 5
a287 1
  reg_val = allocate_value (register_type (gdbarch, regnum));
a298 1
  set_value_optimized_out (reg_val, optim);
@


1.149
log
@	* ax-gdb.c (gen_var_ref): Unconditionally call via computed ops,
	if possible.
	* dwarf2read.c (read_func_scope): Remove old FIXME.
	* eval.c (evaluate_subexp_standard): Check SYMBOL_COMPUTED_OPS,
	not LOC_COMPUTED.
	* findvar.c (symbol_read_needs_frame, default_read_var_value):
	Unconditionally call via computed ops, if possible.
	* printcmd.c (address_info): Unconditionally call via computed ops,
	if possible.
	* stack.c (read_frame_arg): Unconditionally call via computed ops,
	if possible.
	* symtab.c (register_symbol_computed_impl): Sanity check 'ops'.
	* tracepoint.c (scope_info): Unconditionally call via computed ops,
	if possible.
@
text
@d417 3
d435 1
d482 2
a483 1
					SYMBOL_OBJ_SECTION (var));
d504 2
a505 1
					 SYMBOL_OBJ_SECTION (var));
d550 2
a551 1
	  (BLOCK_START (SYMBOL_BLOCK_VALUE (var)), SYMBOL_OBJ_SECTION (var));
d610 2
a611 1
					   SYMBOL_OBJ_SECTION (msym));
d615 1
a615 1
	obj_section = SYMBOL_OBJ_SECTION (msym);
@


1.148
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d370 3
d378 1
a378 6
      /* FIXME: cagney/2004-01-26: It should be possible to
	 unconditionally call the SYMBOL_COMPUTED_OPS method when available.
	 Unfortunately DWARF 2 stores the frame-base (instead of the
	 function) location in a function's symbol.  Oops!  For the
	 moment enable this when/where applicable.  */
      return SYMBOL_COMPUTED_OPS (sym)->read_needs_frame (sym);
d457 3
d582 1
a582 6
      /* FIXME: cagney/2004-01-26: It should be possible to
	 unconditionally call the SYMBOL_COMPUTED_OPS method when available.
	 Unfortunately DWARF 2 stores the frame-base (instead of the
	 function) location in a function's symbol.  Oops!  For the
	 moment enable this when/where applicable.  */
      return SYMBOL_COMPUTED_OPS (var)->read_variable (var, frame);
@


1.147
log
@	* ada-valprint.c (ada_val_print_1): Eliminate single-use
	variable LEN.
	* alpha-tdep.c (alpha_extract_return_value): Use TYPE_LENGTH
	directly.
	(alpha_store_return_value): Likewise.
	* amd64-tdep.c (amd64_classify_aggregate): Likewise.
	(amd64_push_arguments): Likewise.
	* ax-gdb.c (gen_trace_static_fields): Likewise.
	(gen_traced_pop): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* breakpoint.c (update_watchpoint): Likewise.
	* findcmd.c (parse_find_args): Use local variable for type
	instead of length.
	* findvar.c (default_read_var_value): Use TYPE_LENGTH directly.
	* h8300-tdep.c (h8300h_extract_return_value): Likewise.
	(h8300_store_return_value): Likewise.
	* i386-darwin-tdep.c (i386_darwin_push_dummy_call): Likewise.
	Use i386_darwin_arg_type_alignment directly.
	* infcall.c (call_function_by_hand): Use TYPE_LENGTH directly.
	* lm32-tdep.c (lm32_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	(m68hc11_extract_return_value): Likewise.
	* mep-tdep.c (mep_push_dummy_call): Likewise.
	* printcmd.c (float_type_from_length): Likewise.
	* s390-tdep.c (s390_value_from_register): Likewise.
	* stack.c (read_frame_arg): Likewise.
	* tracepoint.c (encode_actions_1): Likewise.
	* valops.c (value_fetch_lazy): Use local variable for type
	instead of length.  Use TYPE_LENGTH directly.
	* value.c (value_contents_equal): Use TYPE_LENGTH directly.
@
text
@d3 1
a3 2
   Copyright (C) 1986-2001, 2003-2005, 2007-2012 Free Software
   Foundation, Inc.
@


1.146
log
@http://sourceware.org/ml/gdb-patches/2012-08/msg00715.html

gdb/ChangeLog

        * findvar.c (read_frame_register_value): Mark the result value as
        optimized out if any of the input registers have been optimized out.

gdb/testsuite/ChangeLog

        * gdb.dwarf2/dw2-op-out-param.S: New file.
        * gdb.dwarf2/dw2-op-out-param.exp: New file.
@
text
@a448 1
  int len;
a456 2
  len = TYPE_LENGTH (type);

d465 1
a465 1
      store_signed_integer (value_contents_raw (v), len,
d490 2
a491 1
      memcpy (value_contents_raw (v), SYMBOL_VALUE_BYTES (var), len);
@


1.145
log
@New "iterate_over_objfiles_in_search_order" gdbarch method.

This patch introduces the "iterate_over_objfiles_in_search_order"
gdbarch method, as well as its default implementation, and converts
the areas where it will matter to using this gdbarch method.

The default method implementation is the only one installed, and
the changes should have no functional impact in terms of behavior.
This only paves the way for the architectures that will need their
own version.

gdb/ChangeLog:

        * gdbarch.sh: Add generation of
        "iterate_over_objfiles_in_search_order_cb_ftype" typedef in
        gdbarch.h.  Add include of "objfiles.h" in gdbarch.c.
        (iterate_over_objfiles_in_search_order): New gdbarch method.
        * gdbarch.h, gdbarch.c: Regenerate.
        * objfiles.h (default_iterate_over_objfiles_in_search_order):
        Add declaration.
        * objfiles.c (default_iterate_over_objfiles_in_search_order):
        New function.
        * symtab.c (lookup_symbol_aux_objfile): New function, extracted
        out of lookup_symbol_aux_symtabs.
        (lookup_symbol_aux_symtabs): Replace extracted-out code by
        call to lookup_symbol_aux_objfile.
        (struct global_sym_lookup_data): New type.
        (lookup_symbol_global_iterator_cb): New function.
        (lookup_symbol_global): Search for symbol using
        gdbarch_iterate_over_objfiles_in_search_order and
        lookup_symbol_global_iterator_cb.
        * findvar.c (struct minsym_lookup_data): New type.
        (minsym_lookup_iterator_cb): New function.
        (default_read_var_value) [case LOC_UNRESOLVED]: Resolve the
        symbol's address via gdbarch_iterate_over_objfiles_in_search_order
        and minsym_lookup_iterator_cb.
@
text
@d680 4
a683 1
   until we've read LEN bytes.  */
d709 6
@


1.144
log
@Revert "Search global symbols from the expression's block objfile first."

The search order used in this patch breaks global symbol lookups
for certain symbols when copy-relocation is used.  A slightly different
search order will be implemented later.

gdb/ChangeLog:

        Revert the following patch:
        * findvar.c (default_read_var_value): For LOC_UNRESOLVED symbols,
        try locating the symbol in the symbol's own objfile first, before
        extending the search to all objfiles.
        * symtab.c (lookup_symbol_aux_objfile): New function, extracted
        out of lookup_symbol_aux_symtabs.
        (lookup_symbol_aux_symtabs): Add new parameter "exclude_objfile".
        Replace extracted-out code by call to lookup_symbol_aux_objfile.
        Do not search EXCLUDE_OBJFILE.
        (lookup_static_symbol_aux): Update call to lookup_symbol_aux_symtabs.
        (lookup_symbol_global): Search for matches in the block's objfile
        first, before searching all other objfiles.
@
text
@d409 31
d593 1
d597 9
a605 1
	msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (var), NULL, NULL);
@


1.143
log
@Search global symbols from the expression's block objfile first.

gdb/ChangeLog:

        * findvar.c (default_read_var_value): For LOC_UNRESOLVED symbols,
        try locating the symbol in the symbol's own objfile first, before
        extending the search to all objfiles.
        * symtab.c (lookup_symbol_aux_objfile): New function, extracted
        out of lookup_symbol_aux_symtabs.
        (lookup_symbol_aux_symtabs): Add new parameter "exclude_objfile".
        Replace extracted-out code by call to lookup_symbol_aux_objfile.
        Do not search EXCLUDE_OBJFILE.
        (lookup_static_symbol_aux): Update call to lookup_symbol_aux_symtabs.
        (lookup_symbol_global): Search for matches in the block's objfile
        first, before searching all other objfiles.
@
text
@d565 1
a565 9
	/* First, try locating the associated minimal symbol within
	   the same objfile.  This prevents us from selecting another
	   symbol with the same name but located in a different objfile.  */
	msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (var), NULL,
				      SYMBOL_SYMTAB (var)->objfile);
	/* If the lookup failed, try expanding the search to all
	   objfiles.  */
	if (msym == NULL)
	  msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (var), NULL, NULL);
@


1.142
log
@language-specific read_var_value for Ada renamings

The purpose of this patch is to better support renamings in the
"info locals" command. Consider ...

    procedure Foo is
       GV : Integer renames Pck.Global_Variable;
    begin
       Increment (GV); -- STOP
    end Foo;

... Pck.Global_Variable is just an integer. After having stopped at
the "STOP" line, "info locals" yields:

    (gdb) info locals
    gv = <error reading variable gv (Cannot access memory at address 0xffffffffffffffff)>

In reality, two things are happening:

   (1) Variable "GV" does not exist, which is normal, since there is
       "GV" the renaming of another variable;

   (2) But to allow the user access to that renaming the same way
       the code has, the compiler produces an artificial variable
       whose name encodes the renaming:

        gv___XR_pck__global_variable___XE

       For practical reasons, the artificial variable itself is given
       irrelevant types and addresses.

But the "info locals" command does not act as if it was a short-cut
of "foreach VAR in locals, print VAR". Instead it gets the value of
each VAR directly, which does not work in this case, since the variable
is artificial and needs to be decoded first.

This patch makes the "read_var_value" routine language-specific.
The old implementation of "read_var_value" gets renamed to
"default_read_var_value" and all languages now use it (unchanged
behavior), except for Ada. In Ada, the new function ada_read_var_value
checks if we have a renaming, and if so, evaluates its value, or else
defers to default_read_var_value.

gdb/ChangeLog:

        * language.h (struct language_defn): New "method" la_read_var_value.
        * findvar.c: #include "language.h".
        (default_read_var_value): Renames read_var_value.  Rewrite
        function description.
        (read_var_value): New function.
        * value.h (default_read_var_value): Add prototype.
        * ada-lang.c (ada_read_renaming_var_value, ada_read_var_value):
        New functions.
        (ada_language_defn): Add entry for la_read_var_value.
        * c-lang.c, d-lang.c, f-lang.c, jv-lang.c, language.c,
        * m2-lang.c, objc-lang.c, opencl-lang.c, p-lang.c: Update
        language_defn structures to add entry for new la_read_var_value
        field.
@
text
@d565 9
a573 1
	msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (var), NULL, NULL);
@


1.141
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d37 1
d409 2
a410 4
/* Given a struct symbol for a variable,
   and a stack frame id, read the value of the variable
   and return a (pointer to a) struct value containing the value.
   If the variable cannot be found, throw error.  */
d413 1
a413 1
read_var_value (struct symbol *var, struct frame_info *frame)
d596 13
@


1.140
log
@	* findvar.c (read_frame_register_value): Respect value_offset
	of the register value.  Remove big-endian special case.
@
text
@d3 2
a4 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2007, 2008, 2009,
   2010, 2011 Free Software Foundation, Inc.
@


1.140.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 2
   Copyright (C) 1986-2001, 2003-2005, 2007-2012 Free Software
   Foundation, Inc.
@


1.139
log
@read_frame_register_value and big endian arches

The read_frame_register_value function as it was implemented introduced
a regression on big-endian targets. The problem appears when trying to
get the value of an entity stored inside a register, and when the size
of the entity is smaller than the size of the register. In that case,
we were always reading the first N bytes of the register, which is wrong
for big-endian architectures, where we need to read the last N bytes of
the register.

gdb/ChangeLog:

        * findvar.c (read_frame_register_value): Read correct bytes from
        register on big-endian architectures.

gdb/testsuite/ChangeLog:

        * gdb.ada/small_reg_param: New testcase.
@
text
@d634 1
d636 1
d638 1
a638 1
  const int len = TYPE_LENGTH (check_typedef (value_type (value)));
d642 9
a650 1
  while (offset < len)
d653 1
a653 2
      int reg_len = TYPE_LENGTH (value_type (regval));
      int reg_offset = 0;
d657 2
a658 6
      if (offset + reg_len > len)
	{
	  reg_len = len - offset;
	  if (gdbarch_byte_order (get_frame_arch (frame)) == BFD_ENDIAN_BIG)
	    reg_offset = TYPE_LENGTH (value_type (regval)) - reg_len;
	}
d660 1
a660 2
      value_contents_copy (value, offset, regval,
                           value_offset (regval) + reg_offset, reg_len);
d663 2
@


1.138
log
@handle variables stored in muliple consecutive registers

gdb/ChangeLog:

        * value.h (read_frame_register_value): Add declaration.
        * findvar.c (read_frame_register_value): New function.
        (value_from_register): Use read_frame_register_value
        instead of get_frame_register_value + value_contents_copy
        to get value contents.
@
text
@d644 1
d646 2
d649 8
a656 3
        reg_len = len - offset;
      value_contents_copy (value, offset, regval, value_offset (regval),
			   reg_len);
@


1.137
log
@gdb/
	* findvar.c (read_var_value): Never return NULL, throw an error
	instead.  Update the function comment.  State symbol name in the error
	messages.
	* python/py-frame.c (frapy_read_var): Remove handling of NULL from
	read_var_value.
	* stack.c (print_frame_args): Likewise.
	* valops.c (value_of_variable): Likewise.
@
text
@d626 29
a692 3
      int len = TYPE_LENGTH (type);
      struct value *v2;

d697 1
a697 3
      v2 = get_frame_register_value (frame, regnum);

      value_contents_copy (v, 0, v2, value_offset (v), len);
d722 1
@


1.136
log
@gdb
	* amd64-tdep.c (amd64_pseudo_register_read_value): Rename
	from amd64_pseudo_register_read.  Change arguments.  Call
	mark_value_bytes_unavailable when needed.
	(amd64_init_abi): Use set_gdbarch_pseudo_register_read_value, not
	set_gdbarch_pseudo_register_read.
	* sentinel-frame.c (sentinel_frame_prev_register): Use
	regcache_cooked_read_value.
	* regcache.h (regcache_cooked_read_value): Declare.
	* regcache.c (regcache_cooked_read_value): New function.
	(regcache_cooked_read): Call
	gdbarch_pseudo_register_read_value if available.
	* i386-tdep.h (i386_pseudo_register_read_value): Declare.
	(i386_pseudo_register_read): Remove.
	* i386-tdep.c (i386_pseudo_register_read_into_value): Rename from
	i386_pseudo_register_read.  Change arguments.  Call
	mark_value_bytes_unavailable when needed.
	(i386_pseudo_register_read_value): New function.
	(i386_gdbarch_init): Call set_gdbarch_pseudo_register_read_value,
	not set_gdbarch_pseudo_register_read.
	* gdbarch.sh (pseudo_register_read_value): New method.
	* gdbarch.c, gdbarch.h: Rebuild.
	* findvar.c (value_from_register): Call get_frame_register_value.
gdb/testsuite
	* gdb.dwarf2/typeddwarf.c: XFAIL 'z' on x86-64.
	* gdb.dwarf2/typeddwarf.exp (xfail-gdb-test): Add arch_pattern
	argument.
	* gdb.dwarf2/typeddwarf-amd64.S: New file.
@
text
@d412 1
a412 1
   If the variable cannot be found, return a zero pointer.  */
d480 2
a481 1
	return 0;
d493 2
a494 1
	  return 0;
d509 2
a510 1
      error (_("Cannot look up value of a typedef"));
d536 2
a537 1
	      error (_("Value of register variable not available."));
d547 2
a548 1
	      error (_("Value of register variable not available."));
d569 1
a569 1
	  return 0;
d588 2
a589 1
      error (_("Cannot look up value of a botched symbol."));
@


1.135
log
@gdb/
	Code cleanup making also optimized out values lazy.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Use
	allocate_optimized_out_value.  Twice.
	(loclist_read_variable)  Use allocate_optimized_out_value.  Once.
	* findvar.c (read_var_value): Likewise.
	* value.c (allocate_optimized_out_value): New function.
	* value.h (allocate_optimized_out_value): New declaration.
@
text
@a627 1
  int optim, unavail, ok;
d631 2
d647 8
d659 1
d665 1
a665 4
      ok = get_frame_register_bytes (frame, regnum, value_offset (v), len,
				     value_contents_raw (v),
				     &optim, &unavail);
    }
d667 1
a667 6
  if (!ok)
    {
      if (optim)
	set_value_optimized_out (v, 1);
      if (unavail)
	mark_value_bytes_unavailable (v, 0, TYPE_LENGTH (type));
@


1.134
log
@	gdb/
	* dwarf2loc.c (read_pieced_value): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	(write_pieced_value): Handle get_frame_register_bytes returning
	that the register piece is unavailable/optimized out when doing a
	read-modify write of a bitfield.
	* findvar.c (value_from_register): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	* frame.c (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.  Throw error on bad debug info.  Use
	frame_register instead of frame_register_read, to fill in the new
	arguments.
	* frame.h (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.
	* valops.c: (value_assign): Adjust, and handle
	get_frame_register_bytes failing.
	* spu-tdep.c: Include exceptions.h.
	(spu_software_single_step): Adjust, and handle
	get_frame_register_bytes failing.
	(spu_get_longjmp_target): Ditto.
	* gdbarch.sh (register_to_value): Change to return int.  New
	parameters `optimizedp' and `unavailablep'.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_register_to_value): Adjust to new
	gdbarch_register_to_value interface.
	* i387-tdep.c (i387_register_to_value): Ditto.
	* i387-tdep.h (i387_register_to_value): Ditto.
	* alpha-tdep.c (alpha_register_to_value): Ditto.
	* ia64-tdep.c (ia64_register_to_value): Ditto.
	* m68k-tdep.c (m68k_register_to_value): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* rs6000-tdep.c (rs6000_register_to_value): Ditto.
@
text
@d580 1
a580 4
      v = allocate_value_lazy (type);
      VALUE_LVAL (v) = not_lval;
      set_value_optimized_out (v, 1);
      return v;
@


1.133
log
@	gdb/
	* findvar.c (value_of_register): Mark the value as unavailable, if
	the register is unavailable.
	* frame.h (frame_register_unwind): New `unavailablep' parameter.
	(frame_register): New `unavailablep' parameter.
	(frame_register_read): Update comment.
	* frame.c (frame_register_unwind): New `unavailablep' parameter.
	Set it if the register is unavailable.  If the register is
	unavailable, clear the output buffer.
	(frame_register): New `unavailablep' parameter.  Pass it down.
	(frame_unwind_register): Adjust.
	(put_frame_register): Adjust.
	(frame_register_read): Adjust.  Also return false if the register
	is not available.
	(frame_register_unwind_location): Adjust.
	* sentinel-frame.c (sentinel_frame_prev_register): If the register
	is unavailable, mark the value accordingly.
	* stack.c (frame_info): Handle unavailable registers.

	gdb/testsuite/
	* gdb.trace/unavailable.exp (fpreg, spreg, pcreg): Define.
	(test_register, test_register_unavailable): New procedures.
	(gdb_unavailable_registers_test): New procedure.
	(gdb_trace_collection_test): Call it.
@
text
@d631 1
d646 3
a648 2
      gdbarch_register_to_value (gdbarch,
				 frame, regnum, type1, value_contents_raw (v));
d658 8
a665 2
      if (!get_frame_register_bytes (frame, regnum, value_offset (v), len,
				     value_contents_raw (v)))
d667 2
d670 1
@


1.132
log
@gdb/
	Make value allocations more lazy.
	* ada-lang.c (coerce_unspec_val_to_type): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy when possible.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy.
	* findvar.c (value_of_register_lazy): Likewise.
	(read_var_value): Remove V preallocation, call just check_typedef in
	advance.  Move allocate_value to LOC_CONST, LOC_LABEL,
	LOC_CONST_BYTES.  Use allocate_value_lazy in LOC_STATIC, LOC_ARG,
	LOC_REF_ARG, LOC_LOCAL, LOC_BLOCK.  Set ADDR instead of
	set_value_address and break in LOC_BLOCK.  Use allocate_value_lazy and
	remove lval_memory set in LOC_REGPARM_ADDR.  Use allocate_value_lazy
	in LOC_UNRESOLVED and LOC_OPTIMIZED_OUT.  Add setting lval_memory at
	the end, remove set_value_lazy there.
	* valarith.c (value_subscripted_rvalue): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy when possible.
	* valops.c (value_fetch_lazy): Do nop for value_optimized_out VAL.
	* value.c (allocate_computed_value): Use allocate_value_lazy instead
	of allocate_value and set_value_lazy.
	(value_from_contents_and_address): Use allocate_value_lazy instead of
	allocate_value and set_value_lazy when possible.
@
text
@d268 1
d280 2
a281 1
  frame_register (frame, regnum, &optim, &lval, &addr, &realnum, raw_buffer);
d285 7
a291 2
  memcpy (value_contents_raw (reg_val), raw_buffer,
	  register_size (gdbarch, regnum));
d296 2
@


1.131
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d309 1
a309 1
  reg_val = allocate_value (register_type (gdbarch, regnum));
a312 1
  set_value_lazy (reg_val, 1);
d413 6
a418 9
  if (SYMBOL_CLASS (var) == LOC_COMPUTED
      || SYMBOL_CLASS (var) == LOC_REGISTER)
    /* These cases do not use V.  */
    v = NULL;
  else
    {
      v = allocate_value (type);
      VALUE_LVAL (v) = lval_memory;	/* The most likely possibility.  */
    }
d429 1
d438 1
d454 1
d460 1
d473 1
d487 1
d494 1
d502 1
d504 2
a505 2
	set_value_address (v, symbol_overlayed_address
	  (BLOCK_START (SYMBOL_BLOCK_VALUE (var)), SYMBOL_OBJ_SECTION (var)));
d507 2
a508 2
	set_value_address (v, BLOCK_START (SYMBOL_BLOCK_VALUE (var)));
      return v;
d527 1
a527 1
	    VALUE_LVAL (v) = lval_memory;
d566 1
d571 1
d581 1
a582 1
  set_value_lazy (v, 1);
@


1.130
log
@run copyright.sh for 2011.
@
text
@d403 1
a403 1
   and return a (pointer to a) struct value containing the value. 
@


1.129
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* findcmd.c: White space.
	* findvar.c: White space.
	* fork-child.c: White space.
	* frame-base.c: White space.
	* frame.c: White space.
	* frame-unwind.c: White space.
	* f-valprint.c: White space.
@
text
@d5 1
a5 1
   2010 Free Software Foundation, Inc.
@


1.128
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d324 1
d333 1
d344 1
d353 1
d446 1
d456 3
a458 5
      {
	memcpy (value_contents_raw (v), SYMBOL_VALUE_BYTES (var), len);
	VALUE_LVAL (v) = not_lval;
	return v;
      }
d479 1
@


1.127
log
@2009-10-28  Michael Snyder  <msnyder@@vmware.com>

        * findvar.c (top level): Fix and add comments.
@
text
@d4 2
a5 2
   1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2007, 2008, 2009
   Free Software Foundation, Inc.
@


1.126
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d39 3
a41 2
/* Basic byte-swapping routines.  GDB has needed these for a long time...
   All extract a target-format integer at ADDR which is LEN bytes long.  */
d183 2
@


1.125
log
@	* gdbtypes.c (make_pointer_type, make_reference_type,
	smash_to_memberptr_type, lookup_array_range_type, check_stub_method):
	Use type architecture instead of current_gdbarch.

	* gdbtypes.h (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH paramter.
	* gdbtypes.c (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH parameter.   Use it instead of current_gdbarch.
	* c-typeprint.c (c_type_print_modifier): Update call.
	* parse.c (push_type_address_space): Likewise.

	* findvar.c (extract_typed_address, store_typed_address): Use type
	architecture instead of current_gdbarch.

	* value.c (value_as_address, unpack_field_as_long): Use type architecture
	instead of current_gdbarch.

	* doublest.c (floatformat_from_length): Add GDBARCH argument.  Use it
	instead of current_gdbarch.
	(floatformat_from_type): Pass type architecture.

	* infcall.c (find_function_addr): Use type architecture instead
	of current_gdbarch.

	* valarith.c (value_bitstring_subscript, value_x_binop, value_neg,
	value_bit_index): Use type architecture instead of current_gdbarch.
	* valops.c (value_cast, value_slice): Likewise.

	* value.h (modify_field): Add TYPE argument.
	* value.c (modify_field): Add TYPE argument.  Use type architecture
	instead of current_gdbarch.
	(set_internalvar_component): Likewise.
	* eval.c (evaluate_struct_tuple): Update call.
	* valops.c (value_assign): Likewise.
	* ada-lang.c (modify_general_field): Likewise.  Add TYPE argument.
	(make_array_descriptor): Update calls.
	(move_bits): Add BITS_BIG_ENDIAN_P argument.  Use it instead of
	current_gdbarch.
	(ada_value_assign, value_assign_to_component): Update calls.
	(decode_packed_array, ada_value_primitive_packed_val, ada_value_assign,
	value_assign_to_component): Use type arch instead of current_gdbarch.

	* printcmd.c (float_type_from_length): Remove GDBARCH argument,
	use type architecture instead.
	(print_scalar_formatted, printf_command): Update calls.  Use type
	architecture instead of current_gdbarch.
	* valprint.c (val_print_type_code_int): Use type architecture
	instead of current_gdbarch.
	* varobj.c (value_get_print_value): Likewise.
	* python/python-prettyprint.c (print_string_repr): Add GDBARCH
	argument.  Use it instead of current_gdbarch.
	(apply_val_pretty_printer): Update call.

	* ada-valprint.c (ada_val_print_1): Use type architecture instead
	of current_gdbarch.
	* c-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(c_val_print): Update calls passing type architecture.
	* f-valprint.c (f_val_print): Use type architecture instead of
	current_gdbarch.
	* jv-valprint (java_value_print): Likewise.
	* m2-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(print_unpacked_pointer): Update calls passing type architecture.
	* scm-valprint.c (scm_scmval_print): Use type architecture instead of
	current_gdbarch.

	* gnu-v3-abi.c (get_class_arch): Remove.
	(gnuv3_rtti_type): Use get_type_arch instead of get_class_arch.  Remove
	special-case check for Java classes.
	(gnuv3_virtual_fn_field, gnuv3_baseclass_offset, gnuv3_print_method_ptr,
	gnuv3_method_ptr_size, gnuv3_make_method_ptr, gnuv3_method_ptr_to_value):
	Use get_type_arch instead of get_class_arch.
@
text
@d51 2
a52 1
extract_signed_integer (const gdb_byte *addr, int len)
d66 1
a66 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d86 2
a87 1
extract_unsigned_integer (const gdb_byte *addr, int len)
d102 1
a102 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d122 1
a122 1
			       LONGEST *pval)
d129 1
a129 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d159 2
a160 1
						  sizeof (LONGEST));
d184 2
a185 1
store_signed_integer (gdb_byte *addr, int len, LONGEST val)
d193 1
a193 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d212 2
a213 1
store_unsigned_integer (gdb_byte *addr, int len, ULONGEST val)
d221 1
a221 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d320 2
a321 1
  return extract_unsigned_integer (buf, TYPE_LENGTH (type));
d328 2
a329 1
  return extract_signed_integer (buf, TYPE_LENGTH (type));
d338 2
a339 1
  store_unsigned_integer (buf, TYPE_LENGTH (type), addr);
d346 2
a347 1
  store_signed_integer (buf, TYPE_LENGTH (type), addr);
d427 1
@


1.124
log
@	* gdbarch.sh (pointer_to_address): Change to type 'm'.
	(address_to_pointer): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.

	* inferior.h (unsigned_pointer_to_address): Add GDBARCH argument.
	(signed_pointer_to_address): Likewise.
	(unsigned_address_to_pointer, address_to_signed_pointer): Likewise.
	* findvar.c (unsigned_pointer_to_address): Likewise.
	(signed_pointer_to_address): Likewise.
	(unsigned_address_to_pointer, address_to_signed_pointer): Likewise.

	* avr-tdep.c (avr_address_to_pointer): Likewise.
	(avr_pointer_to_address): Likewise.
	* iq2000-tdep.c (iq2000_pointer_to_address): Likewise.
	(iq2000_address_to_pointer): Likewise.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Likewise.
	(m32c_m16c_pointer_to_address): Likewise.
	* spu-tdep.c (spu_pointer_to_address): Likewise.
	* xstormy16-tdep.c (xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Likewise.
@
text
@d176 1
a176 1
  return gdbarch_pointer_to_address (current_gdbarch, type, buf);
d245 1
a245 1
  gdbarch_address_to_pointer (current_gdbarch, type, buf, addr);
@


1.123
log
@	* symtab.h: Rename SYMBOL_OPS to SYMBOL_COMPUTED_OPS.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value, symbol_read_needs_frame): Likewise.
	* printcmd.c (address_info): Likewise.
	* dwarf2loc.c (dwarf_expr_frame_base): Likewise.
	* dwarf2read.c (dwarf2_symbol_mark_computed): Likewise.
	* symtab.h: Rename struct symbol_ops to struct symbol_computed_ops.
	* dwarf2loc.h: Likewise.
	* dwarf2loc.c (dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Likewise.

	* symtab.h: (struct symbol_register_ops): New struct definition.
	(struct symbol): Make "ops" member a union of symbol_computed_ops and
	symbol_register_ops callback pointers.
	(SYMBOL_REGISTER_OPS): New macro.
	* tracepoint.c: Include "objfiles.h".
	(scope_info, collect_symbol): Use SYMBOL_REGISTER_OPS register_number
	callback to retrieve register numbers.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value): Likewise.
	* printcmd.c (address_info): Likewise.

	* coffread.c (coff_reg_to_regnum): New function.
	(coff_register_funcs): New static variable.
	(process_coff_symbol): Do not call gdbarch_sdb_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* mdebugread.c (mdebug_reg_to_regnum): New function.
	(mdebug_register_funcs): New static variable.
	(parse_symbol): Do not call gdbarch_ecoff_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* stabsread.c (stab_reg_to_regnum): New function.
	(stab_register_funcs): New static variable.
	(define_symbol): Do not call gdbarch_stab_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
@
text
@d312 2
a313 1
unsigned_pointer_to_address (struct type *type, const gdb_byte *buf)
d319 2
a320 1
signed_pointer_to_address (struct type *type, const gdb_byte *buf)
d328 2
a329 2
unsigned_address_to_pointer (struct type *type, gdb_byte *buf,
			     CORE_ADDR addr)
d335 2
a336 1
address_to_signed_pointer (struct type *type, gdb_byte *buf, CORE_ADDR addr)
@


1.122
log
@2009-05-27  Tom Tromey  <tromey@@redhat.com>
	    Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* mi/mi-main.c (mi_cmd_data_evaluate_expression): Use
	value_address.
	* cli/cli-dump.c (dump_value_to_file): Use value_address.
	* valprint.c (common_val_print): Likewise.
	* v850-tdep.c (v850_push_dummy_call): Use value_address.
	* tracepoint.c (encode_actions): Use value_address.
	* printcmd.c (print_formatted): Use value_address.
	(x_command): Likewise.
	* p-valprint.c (pascal_object_print_static_field): Use
	value_address.
	* mn10300-tdep.c (mn10300_push_dummy_call): Use value_address.
	* mips-tdep.c (mips_eabi_push_dummy_call): Use value_address.
	* m32r-tdep.c (m32r_push_dummy_call): Use value_address.
	* jv-valprint.c (java_value_print): Use value_address.
	* infcall.c (find_function_addr): Use value_address.
	* gnu-v3-abi.c (gnuv3_rtti_type): Use value_address.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Use value_address.
	* frv-tdep.c (frv_push_dummy_call): Use value_address.
	* frame.c (frame_register_unwind): Use value_address.
	(frame_unwind_register_value): Likewise.
	* darwin-nat-info.c (info_mach_region_command): Use
	value_address.
	* cp-valprint.c (cp_print_static_field): Use value_address.
	* c-valprint.c (c_value_print): Use value_address.
	* breakpoint.c (update_watchpoint): Use value_address.
	(can_use_hardware_watchpoint): Likewise.
	* ada-valprint.c (ada_val_print_1): Use value_address.
	(ada_value_print): Likewise.
	* ada-tasks.c (read_fat_string_value): Use value_address.
	* jv-lang.c (java_link_class_type): Use set_value_address.
	(java_link_class_type): Likewise.
	(get_java_utf8_name): Use value_address.
	(type_from_class): Likewise.
	(java_link_class_type): Likewise.
	* findvar.c (value_of_register): Use set_value_address.
	(read_var_value): Likewise.
	(read_var_value): Likewise.
	* eval.c (evaluate_subexp_standard): Use set_value_address.
	(evaluate_subexp_standard): Use value_address.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Use set_value_address.
	* ada-lang.c (coerce_unspec_val_to_type): Use set_value_address.
	(ada_value_primitive_packed_val): Likewise.
	(ensure_lval): Likewise.
	(thin_data_pntr): Use value_address.
	(desc_bounds): Likewise.
	(ada_value_primitive_packed_val): Likewise.
	(value_assign_to_component): Likewise.
	(ensure_lval): Likewise.
	(make_array_descriptor): Likewise.
	(ada_to_fixed_value): Likewise.
	(unwrap_value): Likewise.
	* value.c (deprecated_value_address_hack): Remove.
	(value_address): New function.
	(value_raw_address): Likewise.
	(set_value_address): Likewise.
	(value_fn_field): Use set_value_address.
	(value_from_contents_and_address): Likewise.
	(value_fn_field): Likewise.
	(allocate_value_lazy): Don't use VALUE_ADDRESS.
	(value_as_address): Use value_address.
	(value_static_field): Likewise.
	* valops.c (search_struct_field): Use set_value_address.
	(value_at): Likewise.
	(value_at_lazy): Likewise.
	(value_repeat): Likewise.
	(value_cast_structs): Use value_address.
	(value_cast): Likewise.
	(value_fetch_lazy): Likewise.
	(value_assign): Likewise.
	(value_repeat): Likewise.
	(address_of_variable): Likewise.
	(value_coerce_array): Likewise.
	(value_coerce_function): Likewise.
	(value_addr): Likewise.
	(search_struct_field): Likewise.
	(search_struct_method): Likewise.
	(find_method_list): Likewise.
	(value_struct_elt_for_reference): Likewise.
	(value_full_object): Likewise.
	* jv-valprint.c (java_value_print): Use set_value_address.
	* value.h (deprecated_value_address_hack): Remove.
	(VALUE_ADDRESS): Remove.
	(value_address): Declare.
	(value_raw_address): Declare.
	(set_value_address): Declare.
@
text
@d350 1
a350 1
	 unconditionally call the SYMBOL_OPS method when available.
d354 1
a354 1
      return SYMBOL_OPS (sym)->read_needs_frame (sym);
d489 2
a490 1
	int regno = SYMBOL_VALUE (var);
d518 1
a518 1
	 unconditionally call the SYMBOL_OPS method when available.
d522 1
a522 1
      return SYMBOL_OPS (var)->read_variable (var, frame);
@


1.121
log
@	* value.h (address_of_variable): Add prototype.
	(locate_var_value): Remove prototype.

	* findvar.c (read_var_value): Do not attempt to default frame
	to selected frame.
	(locate_var_value): Remove function.
	* valops.c (value_of_variable): Retrieve selected frame for
	symbols that require a frame when called with NULL block.
	* valops.c (address_of_variable): New function.

	* eval.c (evaluate_subexp_for_address): Call address_of_variable
	instead of calling locate_var_value.
	(evaluate_subexp_with_coercion): Likewise.
@
text
@d278 1
a278 1
  VALUE_ADDRESS (reg_val) = addr;
d480 2
a481 2
	VALUE_ADDRESS (v) = symbol_overlayed_address
	  (BLOCK_START (SYMBOL_BLOCK_VALUE (var)), SYMBOL_OBJ_SECTION (var));
d483 1
a483 1
	VALUE_ADDRESS (v) = BLOCK_START (SYMBOL_BLOCK_VALUE (var));
d554 1
a554 1
  VALUE_ADDRESS (v) = addr;
@


1.120
log
@        Updated copyright notices for most files.
@
text
@d385 1
a385 2
   If the variable cannot be found, return a zero pointer.
   If FRAME is NULL, use the selected frame.  */
d407 2
a408 4
  /* FIXME drow/2003-09-06: this call to the selected frame should be
     pushed upwards to the callers.  */
  if (frame == NULL)
    frame = deprecated_safe_get_selected_frame ();
a449 2
      if (frame == NULL)
	return 0;
a459 2
	if (frame == NULL)
	  return 0;
a469 2
      if (frame == NULL)
	return 0;
a491 3
	if (frame == NULL)
	  return 0;

a520 2
      if (frame == 0 && SYMBOL_OPS (var)->read_needs_frame (var))
	return 0;
a645 55


/* Given a struct symbol for a variable or function,
   and a stack frame id, 
   return a (pointer to a) struct value containing the properly typed
   address.  */

struct value *
locate_var_value (struct symbol *var, struct frame_info *frame)
{
  struct gdbarch *gdbarch;
  CORE_ADDR addr = 0;
  struct type *type = SYMBOL_TYPE (var);
  struct value *lazy_value;

  /* Evaluate it first; if the result is a memory address, we're fine.
     Lazy evaluation pays off here. */

  lazy_value = read_var_value (var, frame);
  if (lazy_value == 0)
    error (_("Address of \"%s\" is unknown."), SYMBOL_PRINT_NAME (var));

  if ((VALUE_LVAL (lazy_value) == lval_memory && value_lazy (lazy_value))
      || TYPE_CODE (type) == TYPE_CODE_FUNC)
    {
      struct value *val;

      addr = VALUE_ADDRESS (lazy_value);
      val = value_from_pointer (lookup_pointer_type (type), addr);
      return val;
    }

  /* Not a memory address; check what the problem was.  */
  switch (VALUE_LVAL (lazy_value))
    {
    case lval_register:
      gdb_assert (frame);
      gdbarch = get_frame_arch (frame);
      gdb_assert (gdbarch_register_name
		   (gdbarch, VALUE_REGNUM (lazy_value)) != NULL
		  && *gdbarch_register_name
		    (gdbarch, VALUE_REGNUM (lazy_value)) != '\0');
      error (_("Address requested for identifier "
	       "\"%s\" which is in register $%s"),
            SYMBOL_PRINT_NAME (var), 
	    gdbarch_register_name (gdbarch, VALUE_REGNUM (lazy_value)));
      break;

    default:
      error (_("Can't take address of \"%s\" which isn't an lvalue."),
	     SYMBOL_PRINT_NAME (var));
      break;
    }
  return 0;			/* For lint -- never reached */
}
@


1.119
log
@gdb/
	Fix resolving external references to TLS variables.
	* findvar.c: Include `objfiles.h'.
	(read_var_value <LOC_UNRESOLVED>): New variable `obj_section'.  Handle
	SEC_THREAD_LOCAL variables.
	* printcmd.c (address_info <LOC_UNRESOLVED>): Handle SEC_THREAD_LOCAL
	variables.

gdb/testsuite/
	Test resolving external references to TLS variables.
	* gdb.threads/tls.exp: New tests to examine A_THREAD_LOCAL and
	FILE2_THREAD_LOCAL.
	(testfile2, srcfile2): New variables.
	* gdb.threads/tls.c (file2_thread_local)
	(function_referencing_file2_thread_local): New.
	* gdb.threads/tls2.c: New file.
@
text
@d4 1
a4 1
   1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2007, 2008
@


1.118
log
@	* breakpoint.h (struct bp_location): Change type of section
	member to "struct obj_section *".
	* tracepoint.h (struct tracepoint): Likewise.
	* symtab.h (struct general_symbol_info): Replace bfd_section
	member with obj_section.
	(struct symtab_and_line): Change type of section member to
	"struct obj_section *".
	(SYMBOL_BFD_SECTION): Remove macro, replace by ...
	(SYMBOL_OBJ_SECTION): ... this.

	* minsym.c (prim_record_minimal_symbol_and_info): Record symbol
	section as obj_section instead of bfd_section.

	* ada-lang.c (ada_decode_symbol): Use gsymbol->obj_section
	directly instead of looking of obj_section from bfd_section.

	* objfiles.h (find_pc_sect_section): Remove.
	* objfiles.c (find_pc_sect_section): Remove.
	(find_pc_section): Inline find_pc_sect_section code.

	* symfile.h (find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(section_is_overlay, section_is_mapped): Change type of section
	argument to struct obj_section *.
	(pc_in_mapped_range, pc_in_unmapped_range): Likewise.
	(overlay_mapped_address, overlay_unmapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	* symtab.h (symbol_overlayed_address): Likewise.
	* symfile.c (overlay_is_mapped): Remove.
	(section_is_mapped): Inline overlay_is_mapped code.  Update.
	(overlay_invalidate_all): Update.
	(section_is_overlay): Change section argument to type
	"struct obj_section *".  Use bfd_ methods.
	(pc_in_unmapped_range): Likewise.  Handle relocated sections.
	(pc_in_mapped_range): Likewise.  Handle relocated sections.
	(sections_overlap): Likewise.
	(overlay_unmapped_address): Likewise.
	(overlay_mapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	(find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(list_overlays_command): Update.
	(map_overlay_command, unmap_overlay_command): Update.
	(simple_overlay_update): Update.

	* block.h (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* block.c (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* symtab.h (find_pc_sect_function, find_pc_sect_psymtab,
	find_pc_sect_symtab, find_pc_sect_psymbol, find_pc_sect_line,
	lookup_minimal_symbol_by_pc_section, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.
	* blockframe.c (find_pc_sect_function): Likewise.
	* breakpoint.c (describe_other_breakpoints): Likewise.
	(breakpoint_has_pc, check_duplicates_for): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_minimal_symbol_by_pc_section): Likewise.
	* symtab.c (find_pc_sect_psymtab_closer): Likewise.
	(find_pc_sect_psymtab, find_pc_sect_psymbol, find_pc_sect_symtab,
	find_pc_sect_line, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.

	* blockframe.c (find_pc_partial_function): Update to section
	type changes.  No longer call find_pc_sect_section.
	(cache_pc_function_section): Change to type "struct obj_section *".
	* breakpoint.c (resolve_sal_pc): Update to section type changes.
	* exec.c (xfer_memory): Likewise.
	* findvar.c (read_var_value): Likewise.
	* infcmd.c (jump_command): Likewise.
	* linespec.c (minsym_found): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_solib_trampoline_symbol_by_pc): Likewise.
	* parse.c (write_exp_msymbol): Likewise.
	* printcmd.c (build_address_symbolic): Likewise.
	(address_info, sym_info): Likewise.
	* symmisc.c (dump_msymbols, print_symbol): Likewise.
	* symtab.c (fixup_section): Likewise.
	(fixup_symbol_section, fixup_psymbol_section): Likewise.
	(find_pc_line, find_function_start_sal): Likewise.
	* target.c (memory_xfer_partial): Likewise.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline): Likewise.
	* spu-tdep.c (spu_overlay_update): Likewise.
@
text
@d37 1
d540 1
d550 5
@


1.117
log
@	* findvar.c (locate_var_value): Do not call get_frame_arch
	with a NULL frame argument.
@
text
@d427 1
a427 1
					SYMBOL_BFD_SECTION (var));
d446 1
a446 1
					 SYMBOL_BFD_SECTION (var));
d489 1
a489 1
	  (BLOCK_START (SYMBOL_BLOCK_VALUE (var)), SYMBOL_BFD_SECTION (var));
d545 1
a545 1
					   SYMBOL_BFD_SECTION (msym));
@


1.116
log
@	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME.
	* blockframe.c (find_pc_partial_function): Likewise.
	* buildsym.c (find_symbol_in_list): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* coffread.c (patch_opaque_types, process_coff_symbol): Likewise.
	(coff_read_enum_type): Likewise.  Use SYMBOL_SET_LINKAGE_NAME.
	* cp-support.c (cp_remove_params): Renamed from remove_params and
	made global.
	(overload_list_add_symbol): Update call to remove_params.
	* cp-support.h (cp_remove_params): Declare.
	* dwarf2read.c (process_enumeration_scope): Use SYMBOL_LINKAGE_NAME.
	(dwarf2_const_value): Use SYMBOL_PRINT_NAME.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* f-valprint.c (info_common_command, there_is_a_visible_common_named):
	Use SYMBOL_LINKAGE_NAME to find symbols and SYMBOL_PRINT_NAME
	for messages.
	* findvar.c (read_var_value): Use SYMBOL_LINKAGE_NAME.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Use SYMBOL_LINKAGE_NAME to find
	symbols and SYMBOL_PRINT_NAME for messages.
	* jv-lang.c (add_class_symbol): Use SYMBOL_SET_LINKAGE_NAME.
	* linespec.c (decode_line_2): Use SYMBOL_LINKAGE_NAME.
	* mdebugread.c (parse_symbol): Use SYMBOL_LINKAGE_NAME and
	SYMBOL_SET_LINKAGE_NAME.
	(mylookup_symbol): Use SYMBOL_LINKAGE_NAME.
	* minsyms.c (add_minsym_to_demangled_hash_table): Use
	SYMBOL_SEARCH_NAME.
	(lookup_minimal_symbol): Use SYMBOL_LINKAGE_NAME or
	SYMBOL_MATCHES_SEARCH_NAME, depending on the pass.
	* objfiles.h (ALL_OBJFILE_MSYMBOLS): Use SYMBOL_LINKAGE_NAME.
	* printcmd.c (build_address_symbolic): Use SYMBOL_LINKAGE_NAME.
	(address_info): Use SYMBOL_PRINT_NAME for messages and
	SYMBOL_LINKAGE_NAME for lookups.
	* sol-thread.c (info_cb): Use SYMBOL_PRINT_NAME for messages.
	* stabsread.c (patch_block_stabs, define_symbol)
	(read_type, read_enum_type, common_block_end)
	(cleanup_undefined_types_1, scan_file_globals): Use
	SYMBOL_LINKAGE_NAME, SYMBOL_SET_LINKAGE_NAME, ALL_OBJFILE_MSYMBOLS,
	and SYMBOL_PRINT_NAME.
	* stack.c (print_frame_args): Use SYMBOL_LINKAGE_NAME.
	(print_frame, frame_info): Use SYMBOL_PRINT_NAME for output.  Use
	cp_remove_params instead of cplus_demangle.
	(print_block_frame_labels, print_frame_arg_vars): Use
	SYMBOL_LINKAGE_NAME.
	* symmisc.c (dump_msymbols): Use ALL_OBJFILE_MSYMBOLS and
	SYMBOL_LINKAGE_NAME.
	(dump_symtab_1, print_symbol, print_partial_symbols)
	(maintenance_check_symtabs): Use SYMBOL_LINKAGE_NAME.
	* symtab.h (DEPRECATED_SYMBOL_NAME): Delete.
	(SYMBOL_SET_LINKAGE_NAME): New.
	(SYMBOL_SET_NAMES): Add a comment.
	* tracepoint.c (set_traceframe_context, validate_actionline)
	(collect_symbol, scope_info): Use SYMBOL_LINKAGE_NAME for
	lookups and SYMBOL_PRINT_NAME for output.
	* typeprint.c (typedef_print): Use SYMBOL_LINKAGE_NAME.
	* xcoffread.c (process_xcoff_symbol): Use SYMBOL_SET_LINKAGE_NAME.
@
text
@d663 1
a663 1
  struct gdbarch *gdbarch = get_frame_arch (frame);
d689 2
@


1.115
log
@	* findvar.c (read_var_value): Remove unused variable.
@
text
@d540 1
a540 1
	msym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (var), NULL, NULL);
@


1.114
log
@	* symtab.h (enum address_class): Remove LOC_REGPARM and
	LOC_COMPUTED_ARG.
	(struct symbol): Add is_argument.
	(SYMBOL_IS_ARGUMENT): Define.

	* ada-lang.c (ada_add_block_symbols): Use SYMBOL_IS_ARGUMENT.
	* buildsym.c (finish_block): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals)
	(print_frame_arg_vars): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (add_local_symbols): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.

	* coffread.c (process_coff_symbol): Set SYMBOL_IS_ARGUMENT.
	* dwarf2read.c (new_symbol): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.

	* ada-exp.y (select_possible_type_sym): Don't handle LOC_REGPARM
	and LOC_COMPUTED_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* eval.c (evaluate_subexp_for_address): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (collect_symbol, scope_info): Likewise.

testsuite/:
	* gdb.base/frame-args.exp: Handle arguments that are optimized
	out.
@
text
@a496 1
	struct block *b;
a501 1
	b = get_frame_block (frame, 0);
@


1.113
log
@	* symtab.h (enum address_class): Remove LOC_BASEREG and
	LOC_BASEREG_ARG.
	(struct symbol): Remove "basereg" member of "aux_value" union.
	(SYMBOL_BASEREG): Remove.

	* ada-exp.y (select_possible_type_sym): Do not handle LOC_BASEREG
	or LOC_BASEREG_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	(ada_add_block_symbols): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* buildsym.c (finish_block): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
	* printcmd.c (address_info): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals): Likewise.
	(print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (collect_symbol, add_local_symbols): Likewise.
	(scope_info): Likewise.
@
text
@a347 1
    case LOC_COMPUTED_ARG:
a357 1
    case LOC_REGPARM:
d396 1
a396 3
      || SYMBOL_CLASS (var) == LOC_COMPUTED_ARG
      || SYMBOL_CLASS (var) == LOC_REGISTER
      || SYMBOL_CLASS (var) == LOC_REGPARM)
a494 1
    case LOC_REGPARM:
a528 1
    case LOC_COMPUTED_ARG:
@


1.112
log
@	* symtab.h (enum address_class): Remove LOC_LOCAL_ARG.

	* ada-exp.y (select_possible_type_sym): Do not handle LOC_LOCAL_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	(ada_add_block_symbols): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* buildsyms.c (finish_block): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
	* printcmd.c (address_info): Likewise.
	* stack.c (print_frame_args, print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (collect_symbol, add_local_symbols): Likewise.
	(scope_info): Likewise.
@
text
@a361 2
    case LOC_BASEREG:
    case LOC_BASEREG_ARG:
a485 14
    case LOC_BASEREG:
    case LOC_BASEREG_ARG:
      {
	struct value *regval;

	regval = value_from_register (lookup_pointer_type (type),
				      SYMBOL_BASEREG (var), frame);
	if (regval == NULL)
	  error (_("Value of base register not available."));
	addr = value_as_address (regval);
	addr += SYMBOL_VALUE (var);
	break;
      }

@


1.111
log
@	* symtab.h (enum address_class): Remove LOC_INDIRECT and
	LOC_HP_THREAD_LOCAL_STATIC.

	* findvar.c (symbol_read_needs_frame, read_var_value): Do not
	handle LOC_INDIRECT or LOC_HP_THREAD_LOCAL_STATIC.
	(read_var_value): Likewise.
	* buildsym.c (finish_block): Likewise.
	* objfiles.c (objfile_relocate): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (scope_info): Likewise.
@
text
@a361 1
    case LOC_LOCAL_ARG:
a481 1
    case LOC_LOCAL_ARG:
@


1.110
log
@	* ada-lang.c (ada_value_primitive_packed_val): Only check
	value_lazy for memory lvals.
	* findvar.c (value_of_register_lazy): New function.
	(locate_var_value): Only check value_lazy for memory lvals.
	* valarith.c (value_subscripted_rvalue): Likewise.
	* valops.c (value_fetch_lazy): Handle both memory and register
	lvals.
	(search_struct_field, value_slice): Only check value_lazy for memory
	lvals.
	* value.c (struct value): Update comment for lazy.
	(value_primitive_field): Only check value_lazy for memory lvals.
	* value.h (value_lazy): Update comment.
	(value_of_register_lazy): Declare.
@
text
@a364 1
    case LOC_HP_THREAD_LOCAL_STATIC:
a369 1
    case LOC_INDIRECT:
a457 18
    case LOC_INDIRECT:
      {
	/* The import slot does not have a real address in it from the
	   dynamic loader (dld.sl on HP-UX), if the target hasn't
	   begun execution yet, so check for that. */
	CORE_ADDR locaddr;
	struct value *loc;
	if (!target_has_execution)
	  error (_("\
Attempt to access variable defined in different shared object or load module when\n\
addresses have not been bound by the dynamic loader. Try again when executable is running."));

	locaddr = SYMBOL_VALUE_ADDRESS (var);
	loc = value_at (lookup_pointer_type (type), locaddr);
	addr = value_as_address (loc);
	break;
      }

a491 1
    case LOC_HP_THREAD_LOCAL_STATIC:
@


1.109
log
@	Updated copyright notices for most files.
@
text
@d284 24
d722 1
a722 1
  if (value_lazy (lazy_value)
@


1.108
log
@2007-10-08  Markus Deuling  <deuling@@de.ibm.com>

	* findvar.c (value_of_register, locate_var_value): Use
	get_regcache_arch or get_frame_arch to get at the current architecture
	by regcache or by frame, respectively.
	* findvar.c (default_value_from_register, value_from_register): Replace
	current_gdbarch by gdbarch.
@
text
@d4 1
a4 1
   1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2007
@


1.107
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d256 1
d266 2
a267 2
  if (regnum >= gdbarch_num_regs (current_gdbarch)
		+ gdbarch_num_pseudo_regs (current_gdbarch))
d272 1
a272 1
  reg_val = allocate_value (register_type (current_gdbarch, regnum));
d275 1
a275 1
	  register_size (current_gdbarch, regnum));
d607 1
a607 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG
d626 1
a626 1
  if (gdbarch_convert_register_p (current_gdbarch, regnum, type1))
d639 1
a639 1
      gdbarch_register_to_value (current_gdbarch,
d686 1
d713 1
a713 1
		   (current_gdbarch, VALUE_REGNUM (lazy_value)) != NULL
d715 1
a715 1
		    (current_gdbarch, VALUE_REGNUM (lazy_value)) != '\0');
d719 1
a719 1
	    gdbarch_register_name (current_gdbarch, VALUE_REGNUM (lazy_value)));
@


1.106
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_TO_VALUE): Replace by gdbarch_register_to_value.
	* findvar.c (value_from_register): Likewise.
	* gdbarch.sh (VALUE_TO_REGISTER): Replace by gdbarch_value_to_register.
	* valops.c (value_assign): Likewise.
	* gdbarch.sh (CONVERT_REGISTER_P): Replace by
	gdbarch_convert_register_p.
	* findvar.c (value_from_register): Likewise.
	* valops.c (value_assign): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.105
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_NAME): Replace by gdbarch_register_name.
	* tracepoint.c (scope_info): Likewise.
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_register_reggroup_p): Likewise.
	* sh64-tdep.c (sh64_do_fp_register, sh64_do_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_reggroup_p): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* remote.c (packet_reg): Likewise (comment).
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* printcmd.c (address_info): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* mt-dep.c (mt_registers_info): Likewise.
	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Likewise (comment).
	* mips-tdep.c (mips_register_reggroup_p, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row, mips_print_registers_info)
	(mips_register_sim_regno): Likewise.
	* m68klinux-nat.c (regmap, fetch_register, store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register)
	(inf_ptrace_store_register): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_store_register): Likewise.
	* i386-linux-nat.c (fetch_register, store_register): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register)
	(hppa_hpux_store_register): Likewise.
	* findvar.c (locate_var_value): Likewise.
	* dwarf2loc.c (locexpr_describe_location): Likewise.
	* dwarf2-frame.c (execute_cfa_program): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* arch-utils.c (legacy_register_sim_regno): Likewise.
	* alpha-tdep.c (alpha_register_reggroup_p): Likewise.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers, mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d627 1
a627 1
  if (CONVERT_REGISTER_P (regnum, type1))
d634 1
a634 1
         is that REGISTER_TO_VALUE populates the entire value
d640 2
a641 1
      REGISTER_TO_VALUE (frame, regnum, type1, value_contents_raw (v));
@


1.104
log
@2007-06-06  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (ADDRESS_TO_POINTER): Replace by
	gdbarch_address_to_pointer.
	* findvar.c (store_typed_address): Likewise.
	* gdbtypes.c (make_pointer_type): Likewise (comment).
	* procfs.c (procfs_address_to_host_pointer): Likewise.
	* std-regs.c (value_of_builtin_frame_reg): Likewise.
	(value_of_builtin_frame_fp_reg): Likewise.
	(value_of_builtin_frame_pc_reg): Likewise.
	* utils.c (paddress): Likewise (comment).
	* gdbarch.sh (POINTER_TO_ADDRESS): Replace by
	gdbarch_pointer_to_address.
	* findvar.c (extract_typed_address): Likewise.
	* gdbtypes.c (make_pointer_type): Likewise (comment).
	* valops.c (value_cast): Likewise (comment).
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d711 4
a714 2
      gdb_assert (REGISTER_NAME (VALUE_REGNUM (lazy_value)) != NULL
		  && *REGISTER_NAME (VALUE_REGNUM (lazy_value)) != '\0');
d718 1
a718 1
	    REGISTER_NAME (VALUE_REGNUM (lazy_value)));
@


1.103
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d177 1
a177 1
  return POINTER_TO_ADDRESS (type, buf);
d246 1
a246 1
  ADDRESS_TO_POINTER (type, buf, addr);
@


1.102
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_BYTE_ORDER): Replace by gdbarch_byte_order.
	* ax-gdb.c (gen_bitfield_ref): Likewise.
	* mi/mi-main.c (get_register): Likewise.
	* findvar.c (default_value_from_register, extract_signed_integer)
	(extract_unsigned_integer, extract_long_unsigned_integer)
	(store_signed_integer, store_unsigned_integer): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* value.c (lookup_internalvar, value_of_internalvar)
	(set_internalvar): Likewise.
	* defs.h: Likewise.
	* valprint.c (print_binary_chars, print_octal_chars)
	(print_decimal_chars, print_hex_chars, print_char_chars): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* arch-utils.c (selected_byte_order, show_endian): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* doublest.c (floatformat_from_length, floatformat_from_type)
	(extract_typed_floating, store_typed_floating): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d267 2
a268 1
  if (regnum >= NUM_REGS + NUM_PSEUDO_REGS)
@


1.101
log
@	* regcache.c (regcache_invalidate): New function.
	(register_cached): Remove.
	(set_register_cached): Remove.
	(deprecated_registers_fetched): Remove.
	(registers_changed): Use regcache_invalidate instead
	of set_register_cached.
	(regcache_raw_read): Update comment.

	* regcache.h (regcache_invalidate): Add prototype.
	(register_cached): Remove.
	(set_register_cached): Remove.
	(deprecated_registers_fetched): Remove.

	* findvar.c (value_of_register): Do not call register_cached.
	* frame.c (frame_register): Likewise.
	* tui/tui-regs.c (tui_get_register): Likewise.

	* remote.c (fetch_register_using_p): Do not call set_register_cached.
	(process_g_packet): Likewise.
	(remote_fetch_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* mt-tdep.c (mt_select_coprocessor): Replace set_register_cached call
	by regcache_invalidate.
	(mt_pseudo_register_write): Likewise.
	* sh-tdep.c (sh_pseudo_register_write): Likewise.

	* corelow.c (get_core_registers): Replace deprecated_registers_fetched
	call by loop over regcache_raw_supply (..., NULL).
@
text
@d66 1
a66 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d101 1
a101 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d128 1
a128 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d190 1
a190 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d217 1
a217 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d607 1
a607 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
@


1.100
log
@	* frame.c (deprecated_selected_frame): Rename to...
	(selected_frame): ...this.  Make static.
	(get_selected_frame, select_frame): Update.
	* frame.h (deprected_select_frame): Delete.
	(deprecated_safe_get_selected_frame): Update comments.

	* breakpoint.c, cli/cli-cmds.c, f-valprint.c, infcmd.c, inflow.c,
	infrun.c, stack.c, tui/tui-disasm.c, tui/tui-source.c,
	tui/tui-winsource.c, valops.c, varobj.c, findvar.c, macroscope.c,
	parse.c, regcache.h, sh64-tdep.c, tui/tui-hooks.c, tui/tui-win.c,
	tui/tui.c: Replace references to deprecated_selected_frame.
@
text
@d253 1
a253 4
   determined by register_type().

   NOTE: returns NULL if register value is not available.  Caller will
   check return value or die!  */
a271 10
  /* FIXME: cagney/2002-05-15: This test is just bogus.

     It indicates that the target failed to supply a value for a
     register because it was "not available" at this time.  Problem
     is, the target still has the register and so get saved_register()
     may be returning a value saved on the stack.  */

  if (register_cached (regnum) < 0)
    return NULL;		/* register value not available */

@


1.99
log
@Copyright updates for 2007.
@
text
@d381 1
a381 1
   If FRAME is NULL, use the deprecated_selected_frame.  */
@


1.98
log
@	* gdbarch.sh (value_from_register): New gdbarch function.
	* gdbarch.c, gdbarch.h: Regenerate.
	* findvar.c (default_value_from_register): New function.
	(value_from_register): Use gdbarch_value_from_register.
	* value.h (default_value_from_register): Declare.
	* spu-tdep.c (spu_convert_register_p, spu_register_to_value,
	spu_value_to_register): Remove.
	(spu_value_from_register): New function.
	(spu_gdbarch_init): Do not call set_gdbarch_convert_register_p,
	set_gdbarch_register_to_value, set_gdbarch_value_to_register.
	Call set_gdbarch_value_from_register.
	* s390-tdep.c (s390_convert_register_p, s390_register_to_value,
	s390_value_to_register): Remove.
	(s390_value_from_register): New function.
	(s390_gdbarch_init): Do not call set_gdbarch_convert_register_p,
	set_gdbarch_register_to_value, set_gdbarch_value_to_register.
	Call set_gdbarch_value_from_register.
@
text
@d3 3
a5 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005 Free
   Software Foundation, Inc.
@


1.97
log
@	* frame.c (get_frame_register_bytes): New function.
	(put_frame_register_bytes): Likewise.
	* frame.h (get_frame_register_bytes): Declare.
	(put_frame_register_bytes): Likewise.
	* findvar.c (value_from_register): Always construct lval_register
	values.  Use get_frame_register_bytes.
	* valops.c (value_assign): Use get_frame_register_bytes and
	put_frame_register_bytes.
@
text
@d602 28
d636 2
a637 2
  struct value *v = allocate_value (type);
  CHECK_TYPEDEF (type);
d639 1
a639 5
  VALUE_LVAL (v) = lval_register;
  VALUE_FRAME_ID (v) = get_frame_id (frame);
  VALUE_REGNUM (v) = regnum;
      
  if (CONVERT_REGISTER_P (regnum, type))
d648 5
a652 1
      REGISTER_TO_VALUE (frame, regnum, type, value_contents_raw (v));
d658 2
a659 10
      /* Any structure stored in more than one register will always be
         an integral number of registers.  Otherwise, you need to do
         some fiddling with the last register copied here for little
         endian machines.  */
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && len < register_size (gdbarch, regnum))
	/* Big-endian, and we want less than full size.  */
	set_value_offset (v, register_size (gdbarch, regnum) - len);
      else
	set_value_offset (v, 0);
@


1.96
log
@	* findvar.c (address_from_register): New function.
	* value.h (address_from_register): Add prototype.
	* dwarf2loc.c (dwarf_expr_read_reg): Use address_from_register.
@
text
@d602 1
a602 5
/* Return a value of type TYPE, stored in register REGNUM, in frame
   FRAME.

   NOTE: returns NULL if register value is not available.
   Caller will check return value or die!  */
d611 5
a615 24
  if (TYPE_LENGTH (type) == 0)
    {
      /* It doesn't matter much what we return for this: since the
         length is zero, it could be anything.  But if allowed to see
         a zero-length type, the register-finding loop below will set
         neither mem_stor nor reg_stor, and then report an internal
         error.  

         Zero-length types can legitimately arise from declarations
         like 'struct {}' (a GCC extension, not valid ISO C).  GDB may
         also create them when it finds bogus debugging information;
         for example, in GCC 2.95.4 and binutils 2.11.93.0.2, the
         STABS BINCL->EXCL compression process can create bad type
         numbers.  GDB reads these as TYPE_CODE_UNDEF types, with zero
         length.  (That bug is actually the only known way to get a
         zero-length value allocated to a register --- which is what
         it takes to make it here.)

         We'll just attribute the value to the original register.  */
      VALUE_LVAL (v) = lval_register;
      VALUE_ADDRESS (v) = regnum;
      VALUE_REGNUM (v) = regnum;
    }
  else if (CONVERT_REGISTER_P (regnum, type))
a624 3
      VALUE_LVAL (v) = lval_register;
      VALUE_FRAME_ID (v) = get_frame_id (frame);
      VALUE_REGNUM (v) = regnum;
a627 6
      int local_regnum;
      int mem_stor = 0, reg_stor = 0;
      int mem_tracking = 1;
      CORE_ADDR last_addr = 0;
      CORE_ADDR first_addr = 0;
      int first_realnum = regnum;
d629 1
a629 55
      int value_bytes_copied;
      int optimized = 0;
      gdb_byte *value_bytes = alloca (len + MAX_REGISTER_SIZE);

      /* Copy all of the data out, whereever it may be.  */
      for (local_regnum = regnum, value_bytes_copied = 0;
	   value_bytes_copied < len;
	   (value_bytes_copied += register_size (current_gdbarch, local_regnum),
	    ++local_regnum))
	{
	  int realnum;
	  int optim;
	  enum lval_type lval;
	  CORE_ADDR addr;
	  frame_register (frame, local_regnum, &optim, &lval, &addr,
			  &realnum, value_bytes + value_bytes_copied);
	  optimized += optim;
	  if (register_cached (local_regnum) == -1)
	    return NULL;	/* register value not available */
	  
	  if (regnum == local_regnum)
	    {
	      first_addr = addr;
	      first_realnum = realnum;
	    }
	  if (lval == lval_register)
	    reg_stor++;
	  else
	    {
	      mem_stor++;
	      
	      /* FIXME: cagney/2004-11-12: I think this is trying to
		 check that the stored registers are adjacent in
		 memory.  It isn't doing a good job?  */
	      mem_tracking = (mem_tracking
			      && (regnum == local_regnum
				  || addr == last_addr));
	    }
	  last_addr = addr;
	}
      
      if (mem_tracking && mem_stor && !reg_stor)
	{
	  VALUE_LVAL (v) = lval_memory;
	  VALUE_ADDRESS (v) = first_addr;
	}
      else
	{
	  VALUE_LVAL (v) = lval_register;
	  VALUE_FRAME_ID (v) = get_frame_id (frame);
	  VALUE_REGNUM (v) = regnum;
	}
      
      set_value_optimized_out (v, optimized);
      
d635 1
a635 1
	  && len < register_size (current_gdbarch, regnum))
d637 1
a637 1
	set_value_offset (v, register_size (current_gdbarch, regnum) - len);
d640 5
a644 1
      memcpy (value_contents_raw (v), value_bytes + value_offset (v), len);
@


1.95
log
@gdb/ChangeLog:
2006-01-17  Jim Blandy  <jimb@@redhat.com>

	* symtab.h (struct general_symbol_info): Use gdb_byte for
	value.bytes.
	* stabsread.c (define_symbol): Use gdb_byte for the buffer holding
	a floating-point constant's value.
	* dwarf2read.c (dwarf2_const_value): Remove casts of value buffer
	to char *.
	* findvar.c (read_var_value): Eliminate needless temporary.
@
text
@d731 20
@


1.95.18.1
log
@	* findvar.c (address_from_register): New function.
	* value.h (address_from_register): Add prototype.
	* dwarf2loc.c (dwarf_expr_read_reg): Use address_from_register.
@
text
@a730 20
/* Return contents of register REGNUM in frame FRAME as address,
   interpreted as value of type TYPE.   Will abort if register
   value is not available.  */

CORE_ADDR
address_from_register (struct type *type, int regnum, struct frame_info *frame)
{
  struct value *value;
  CORE_ADDR result;

  value = value_from_register (type, regnum, frame);
  gdb_assert (value);

  result = value_as_address (value);
  release_value (value);
  value_free (value);

  return result;
}

@


1.94
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d436 1
a436 3
	char *bytes_addr;
	bytes_addr = SYMBOL_VALUE_BYTES (var);
	memcpy (value_contents_raw (v), bytes_addr, len);
@


1.93
log
@2005-05-22  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (frame_register_unwind, frame_unwind_register)
	(get_frame_register, frame_register, put_frame_register)
	(get_frame_memory, safe_frame_unwind_memory)
	(frame_register_read): Use gdb_byte for byte buffer parameters.
	* trad-frame.h (trad_frame_get_register)
	(frame_get_prev_register): Ditto.
	* frame-unwind.h (frame_prev_register_ftype): Ditto.
	* frame.c (frame_pop, frame_register, frame_unwind_register)
	(get_frame_register, frame_unwind_register_signed)
	(frame_unwind_register_unsigned, frame_unwind_unsigned_register)
	(frame_register_read, get_frame_memory): Update.
	* trad-frame.c (trad_frame_get_prev_register): Update.
	(trad_frame_get_register): Update.
	* gdbcore.h (deprecated_read_memory_nobpt, read_memory): Ditto.
	* breakpoint.c (deprecated_read_memory_nobpt): Update.
	* corefile.c (read_memory): Update.
	* tramp-frame.c (tramp_frame_prev_register): Update.
	* valops.c (value_assign): Update.
	* sentinel-frame.c (sentinel_frame_prev_register): Update.
	* std-regs.c (value_of_builtin_frame_fp_reg)
	(value_of_builtin_frame_pc_reg): Update.
	* infcmd.c (default_print_registers_info): Update
	* dummy-frame.c (dummy_frame_prev_register): Update.
	* findvar.c (value_of_register, value_from_register): Update.
	* tui/tui-regs.c (tui_register_format, tui_get_register): Update.
	* mi/mi-main.c (register_changed_p, get_register): Update.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.92
log
@2005-05-19  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (extract_signed_integer, extract_unsigned_integer)
	(extract_long_unsigned_integer, extract_typed_address)
	(store_signed_integer, store_unsigned_integer)
	(store_typed_address): Use gdb_byte for byte buffer parameters.
	(push_bytes, push_word): Delete declaration.
	* valops.c (push_bytes, push_word): Delete function.
	* findvar.c (extract_signed_integer, extract_unsigned_integer)
	(extract_typed_address, store_signed_integer)
	(store_unsigned_integer): Update.

Index: defs.h
===================================================================
RCS file: /cvs/src/src/gdb/defs.h,v
retrieving revision 1.185
diff -p -u -r1.185 defs.h
--- defs.h	9 May 2005 17:20:18 -0000	1.185
+++ defs.h	19 May 2005 17:54:12 -0000
@@@@ -1042,27 +1042,25 @@@@ enum { MAX_REGISTER_SIZE = 16 };

 /* In findvar.c.  */

-extern LONGEST extract_signed_integer (const void *, int);
+extern LONGEST extract_signed_integer (const gdb_byte *, int);

-extern ULONGEST extract_unsigned_integer (const void *, int);
+extern ULONGEST extract_unsigned_integer (const gdb_byte *, int);

-extern int extract_long_unsigned_integer (const void *, int, LONGEST *);
+extern int extract_long_unsigned_integer (const gdb_byte *, int, LONGEST *);

-extern CORE_ADDR extract_typed_address (const void *buf, struct type *type);
+extern CORE_ADDR extract_typed_address (const gdb_byte *buf,
+					struct type *type);

-extern void store_signed_integer (void *, int, LONGEST);
+extern void store_signed_integer (gdb_byte *, int, LONGEST);

-extern void store_unsigned_integer (void *, int, ULONGEST);
+extern void store_unsigned_integer (gdb_byte *, int, ULONGEST);

-extern void store_typed_address (void *buf, struct type *type, CORE_ADDR addr);
+extern void store_typed_address (gdb_byte *buf, struct type *type,
+				 CORE_ADDR addr);

 
 /* From valops.c */

-extern CORE_ADDR push_bytes (CORE_ADDR, char *, int);
-
-extern CORE_ADDR push_word (CORE_ADDR, ULONGEST);
-
 extern int watchdog;

 /* Hooks for alternate command interfaces.  */
Index: findvar.c
===================================================================
RCS file: /cvs/src/src/gdb/findvar.c,v
retrieving revision 1.91
diff -p -u -r1.91 findvar.c
--- findvar.c	14 May 2005 06:07:41 -0000	1.91
+++ findvar.c	19 May 2005 17:54:12 -0000
@@@@ -49,7 +49,7 @@@@ you lose
 #endif

 LONGEST
-extract_signed_integer (const void *addr, int len)
+extract_signed_integer (const gdb_byte *addr, int len)
 {
   LONGEST retval;
   const unsigned char *p;
@@@@ -83,7 +83,7 @@@@ That operation is not available on integ
 }

 ULONGEST
-extract_unsigned_integer (const void *addr, int len)
+extract_unsigned_integer (const gdb_byte *addr, int len)
 {
   ULONGEST retval;
   const unsigned char *p;
@@@@ -117,16 +117,18 @@@@ That operation is not available on integ
    function returns 1 and sets *PVAL.  Otherwise it returns 0.  */

 int
-extract_long_unsigned_integer (const void *addr, int orig_len, LONGEST *pval)
+extract_long_unsigned_integer (const gdb_byte *addr, int orig_len,
+			       LONGEST *pval)
 {
-  char *p, *first_addr;
+  const gdb_byte *p;
+  const gdb_byte *first_addr;
   int len;

   len = orig_len;
   if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
     {
-      for (p = (char *) addr;
-	   len > (int) sizeof (LONGEST) && p < (char *) addr + orig_len;
+      for (p = addr;
+	   len > (int) sizeof (LONGEST) && p < addr + orig_len;
 	   p++)
 	{
 	  if (*p == 0)
@@@@ -138,9 +140,9 @@@@ extract_long_unsigned_integer (const voi
     }
   else
     {
-      first_addr = (char *) addr;
-      for (p = (char *) addr + orig_len - 1;
-	   len > (int) sizeof (LONGEST) && p >= (char *) addr;
+      first_addr = addr;
+      for (p = addr + orig_len - 1;
+	   len > (int) sizeof (LONGEST) && p >= addr;
 	   p--)
 	{
 	  if (*p == 0)
@@@@ -164,7 +166,7 @@@@ extract_long_unsigned_integer (const voi
 /* Treat the bytes at BUF as a pointer of type TYPE, and return the
    address it represents.  */
 CORE_ADDR
-extract_typed_address (const void *buf, struct type *type)
+extract_typed_address (const gdb_byte *buf, struct type *type)
 {
   if (TYPE_CODE (type) != TYPE_CODE_PTR
       && TYPE_CODE (type) != TYPE_CODE_REF)
@@@@ -177,11 +179,11 @@@@ extract_typed_address (const void *buf,


 void
-store_signed_integer (void *addr, int len, LONGEST val)
+store_signed_integer (gdb_byte *addr, int len, LONGEST val)
 {
-  unsigned char *p;
-  unsigned char *startaddr = (unsigned char *) addr;
-  unsigned char *endaddr = startaddr + len;
+  gdb_byte *p;
+  gdb_byte *startaddr = addr;
+  gdb_byte *endaddr = startaddr + len;

   /* Start at the least significant end of the integer, and work towards
      the most significant.  */
@@@@ -204,7 +206,7 @@@@ store_signed_integer (void *addr, int le
 }

 void
-store_unsigned_integer (void *addr, int len, ULONGEST val)
+store_unsigned_integer (gdb_byte *addr, int len, ULONGEST val)
 {
   unsigned char *p;
   unsigned char *startaddr = (unsigned char *) addr;
@@@@ -233,7 +235,7 @@@@ store_unsigned_integer (void *addr, int
 /* Store the address ADDR as a pointer of type TYPE at BUF, in target
    form.  */
 void
-store_typed_address (void *buf, struct type *type, CORE_ADDR addr)
+store_typed_address (gdb_byte *buf, struct type *type, CORE_ADDR addr)
 {
   if (TYPE_CODE (type) != TYPE_CODE_PTR
       && TYPE_CODE (type) != TYPE_CODE_REF)
Index: valops.c
===================================================================
RCS file: /cvs/src/src/gdb/valops.c,v
retrieving revision 1.157
diff -p -u -r1.157 valops.c
--- valops.c	9 May 2005 21:20:35 -0000	1.157
+++ valops.c	19 May 2005 17:54:12 -0000
@@@@ -933,54 +933,6 @@@@ value_ind (struct value *arg1)
   return 0;			/* For lint -- never reached */
 }
 
-/* Pushing small parts of stack frames.  */
-
-/* Push one word (the size of object that a register holds).  */
-
-CORE_ADDR
-push_word (CORE_ADDR sp, ULONGEST word)
-{
-  int len = DEPRECATED_REGISTER_SIZE;
-  char buffer[MAX_REGISTER_SIZE];
-
-  store_unsigned_integer (buffer, len, word);
-  if (INNER_THAN (1, 2))
-    {
-      /* stack grows downward */
-      sp -= len;
-      write_memory (sp, buffer, len);
-    }
-  else
-    {
-      /* stack grows upward */
-      write_memory (sp, buffer, len);
-      sp += len;
-    }
-
-  return sp;
-}
-
-/* Push LEN bytes with data at BUFFER.  */
-
-CORE_ADDR
-push_bytes (CORE_ADDR sp, char *buffer, int len)
-{
-  if (INNER_THAN (1, 2))
-    {
-      /* stack grows downward */
-      sp -= len;
-      write_memory (sp, buffer, len);
-    }
-  else
-    {
-      /* stack grows upward */
-      write_memory (sp, buffer, len);
-      sp += len;
-    }
-
-  return sp;
-}
-
 /* Create a value for an array by allocating space in the inferior, copying
    the data into that space, and then setting up an array value.
@
text
@d265 1
a265 1
  char raw_buffer[MAX_REGISTER_SIZE];
d665 1
a665 1
      char *value_bytes = (char *) alloca (len + MAX_REGISTER_SIZE);
@


1.91
log
@2005-05-13  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (pseudo_register_read, pseudo_register_write)
	(value_to_register, register_to_value, pointer_to_address)
	(address_to_pointer, return_value, extract_return_value)
	(store_return_value): Instead of a void pointer, use gdb_byte.
	* gdbarch.h, gdbarch.c: Regenerate.
	* inferior.h (unsigned_address_to_pointer)
	(signed_pointer_to_address, address_to_signed_pointer)
	(unsigned_pointer_to_address): Update.
	* arch-utils.h (legacy_return_value):
	* arch-utils.c (legacy_extract_return_value)
	(legacy_return_value): Update.
	* findvar.c (unsigned_pointer_to_address)
	(signed_pointer_to_address, unsigned_address_to_pointer)
	(address_to_signed_pointer): Update.
@
text
@d52 1
a52 1
extract_signed_integer (const void *addr, int len)
d86 1
a86 1
extract_unsigned_integer (const void *addr, int len)
d120 2
a121 1
extract_long_unsigned_integer (const void *addr, int orig_len, LONGEST *pval)
d123 2
a124 1
  char *p, *first_addr;
d130 2
a131 2
      for (p = (char *) addr;
	   len > (int) sizeof (LONGEST) && p < (char *) addr + orig_len;
d143 3
a145 3
      first_addr = (char *) addr;
      for (p = (char *) addr + orig_len - 1;
	   len > (int) sizeof (LONGEST) && p >= (char *) addr;
d169 1
a169 1
extract_typed_address (const void *buf, struct type *type)
d182 1
a182 1
store_signed_integer (void *addr, int len, LONGEST val)
d184 3
a186 3
  unsigned char *p;
  unsigned char *startaddr = (unsigned char *) addr;
  unsigned char *endaddr = startaddr + len;
d209 1
a209 1
store_unsigned_integer (void *addr, int len, ULONGEST val)
d238 1
a238 1
store_typed_address (void *buf, struct type *type, CORE_ADDR addr)
@


1.90
log
@	* findvar.c (read_var_value): Don't allocate V when it will not
	be used.  Add missing break for LOC_INDIRECT.
@
text
@d298 1
a298 1
unsigned_pointer_to_address (struct type *type, const void *buf)
d304 1
a304 1
signed_pointer_to_address (struct type *type, const void *buf)
d312 2
a313 1
unsigned_address_to_pointer (struct type *type, void *buf, CORE_ADDR addr)
d319 1
a319 1
address_to_signed_pointer (struct type *type, void *buf, CORE_ADDR addr)
@


1.89
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d388 11
a398 2
  v = allocate_value (type);
  VALUE_LVAL (v) = lval_memory;	/* The most likely possibility.  */
a401 1

d463 1
@


1.88
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d172 2
a173 2
		    "extract_typed_address: "
		    "type is not a pointer or reference");
d241 2
a242 2
		    "store_typed_address: "
		    "type is not a pointer or reference");
@


1.87
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (set_value_offset): Declare.
	* value.c (set_value_offset): Declare.
	* gnu-v2-abi.c, jv-valprint.c, valarith.c, valops.c: Update.
	* findvar.c: Update.
@
text
@d60 2
a61 2
    error ("\
That operation is not available on integers of more than %d bytes.",
d94 2
a95 2
    error ("\
That operation is not available on integers of more than %d bytes.",
d448 1
a448 1
	  error ("\
d450 1
a450 1
addresses have not been bound by the dynamic loader. Try again when executable is running.");
d498 1
a498 1
	  error ("Value of base register not available.");
d505 1
a505 1
      error ("Cannot look up value of a typedef");
d535 1
a535 1
	      error ("Value of register variable not available.");
d545 1
a545 1
	      error ("Value of register variable not available.");
d583 1
a583 1
      error ("Cannot look up value of a botched symbol.");
d739 1
a739 1
    error ("Address of \"%s\" is unknown.", SYMBOL_PRINT_NAME (var));
d757 2
a758 2
      error("Address requested for identifier "
	    "\"%s\" which is in register $%s",
d764 1
a764 1
      error ("Can't take address of \"%s\" which isn't an lvalue.",
@


1.86
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_LAZY): Delete
	(set_value_lazy): Declare.
	* value.c (set_value_lazy): Define.
	* valops.c, valarith.c, jv-valprint.c, jv-lang.c: Update.
	* gnu-v2-abi.c, findvar.c, dwarf2loc.c, ada-lang.c: Update.
@
text
@d713 1
a713 1
	v->offset = register_size (current_gdbarch, regnum) - len;
d715 1
a715 1
	v->offset = 0;
@


1.85
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_OPTIMIZED_OUT): Delete.
	(value_optimized_out, set_value_optimized_out): Declare.
	* value.c (set_value_optimized_out, value_optimized_out): Define.
	* valprint.c, findvar.c, dwarf2loc.c: Update.
@
text
@d588 1
a588 1
  VALUE_LAZY (v) = 1;
@


1.84
log
@2005-02-02  Andrew Cagney  <cagney@@gnu.org>

	* value.h (value_lazy): Declare.
	* varobj.c, value.c, valops.c, valarith.c, printcmd.c: Update.
	* cp-valprint.c, breakpoint.c, ada-lang.c: Update.
@
text
@d290 1
a290 1
  VALUE_OPTIMIZED_OUT (reg_val) = optim;
d579 1
a579 1
      VALUE_OPTIMIZED_OUT (v) = 1;
d704 1
a704 1
      VALUE_OPTIMIZED_OUT (v) = optimized;
@


1.83
log
@2005-02-01  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents_all_raw)
	(value_contents_raw): New functions.
	* value.h (VALUE_CONTENTS_ALL_RAW, VALUE_CONTENTS_RAW): Delete.
	(value_contents_raw, value_contents_all_raw): Declare functions.
	(VALUE_CONTENTS, VALUE_CONTENTS_ALL): Update.
	* std-regs.c, valarith.c, valops.c, eval.c: Update.
	* tracepoint.c, findvar.c: Update.
@
text
@d741 1
a741 1
  if (VALUE_LAZY (lazy_value)
@


1.82
log
@2004-11-15  Andrew Cagney  <cagney@@gnu.org>

	* findvar.c (value_of_register): Set the frame ID.
	* value.c (value_primitive_field): Copy the frame ID.
	* valops.c (value_assign): Simplify lval_register case, there's
	always a frame.
@
text
@d4 2
a5 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004 Free Software
   Foundation, Inc.
d285 1
a285 1
  memcpy (VALUE_CONTENTS_RAW (reg_val), raw_buffer,
d403 1
a403 1
      store_signed_integer (VALUE_CONTENTS_RAW (v), len,
d415 1
a415 1
	  store_typed_address (VALUE_CONTENTS_RAW (v), type, addr);
d418 1
a418 1
	store_typed_address (VALUE_CONTENTS_RAW (v), type,
d427 1
a427 1
	memcpy (VALUE_CONTENTS_RAW (v), bytes_addr, len);
d637 1
a637 1
      REGISTER_TO_VALUE (frame, regnum, type, VALUE_CONTENTS_RAW (v));
d716 1
a716 1
      memcpy (VALUE_CONTENTS_RAW (v), value_bytes + value_offset (v), len);
@


1.81
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (enum lval_type): Delete lval_reg_frame_relative.
	* value.h (struct value): Update comment.
	* valops.c (value_assign): Fold lval_reg_fame_relative into
	lval_register.
	* findvar.c (value_from_register, locate_var_value): Ditto.
@
text
@d291 1
@


1.80
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	Merge VALUE_REGNO and VALUE_FRAME_REGNUM into VALUE_REGNUM.
	* value.h (VALUE_REGNO, VALUE_FRAME_REGNUM): Delete.
	(VALUE_REGNUM): Define.
	(struct value): Delete location.regnum, rename "regno" to
	"regnum".
	* value.c, valops.c, valarith.c, findvar.c: Update.
@
text
@d637 1
a637 1
      VALUE_LVAL (v) = lval_reg_frame_relative;
d681 3
d691 1
a691 14
      /* FIXME: cagney/2003-06-04: Shouldn't this always use
         lval_reg_frame_relative?  If it doesn't and the register's
         location changes (say after a resume) then this value is
         going to have wrong information.  */
      if ((reg_stor && mem_stor)
	  || (mem_stor && !mem_tracking))
	/* Mixed storage; all of the hassle we just went through was
	   for some good purpose.  */
	{
	  VALUE_LVAL (v) = lval_reg_frame_relative;
	  VALUE_FRAME_ID (v) = get_frame_id (frame);
	  VALUE_REGNUM (v) = regnum;
	}
      else if (mem_stor)
d696 1
a696 1
      else if (reg_stor)
d699 2
a700 2
	  VALUE_ADDRESS (v) = first_addr;
	  VALUE_REGNUM (v) = first_realnum;
a701 3
      else
	internal_error (__FILE__, __LINE__,
			"value_from_register: Value not stored anywhere!");
a761 9
    case lval_reg_frame_relative:
      gdb_assert (REGISTER_NAME (VALUE_REGNUM (lazy_value)) != NULL
		  && *REGISTER_NAME (VALUE_REGNUM (lazy_value)) != '\0');
      error("Address requested for identifier "
	    "\"%s\" which is in frame register $%s",
            SYMBOL_PRINT_NAME (var), 
	    REGISTER_NAME (VALUE_REGNUM (lazy_value)));
      break;

@


1.79
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_TYPE, VALUE_NEXT, VALUE_OFFSET, VALUE_BITSIZE)
	(VALUE_BITPOS): Delete.
	(value_type, value_offset, value_bitsize, value_bitpos): Declare.
	* value.c (value_type, value_offset, value_bitpos)
	(value_bitsize): New functions.  Update references.
	* arm-tdep.c, gnu-v3-abi.c, hpacc-abi.c, gnu-v2-abi.c: Update.
	* f-valprint.c, cp-valprint.c, c-valprint.c: Update.
	* ada-valprint.c, typeprint.c, scm-valprint.c, scm-exp.c: Update.
	* p-valprint.c, jv-valprint.c, jv-lang.c, varobj.c: Update.
	* objc-lang.c, ada-lang.c, std-regs.c, stack.c: Update.
	* infcall.c, linespec.c, printcmd.c, valarith.c: Update.
	* valops.c, eval.c, findvar.c, breakpoint.c: Update.
	* tracepoint.c, ax-gdb.c, mi/mi-main.c, cli/cli-dump.c:
	* rs6000-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d289 1
a289 1
  VALUE_REGNO (reg_val) = regnum;
d625 1
a625 1
      VALUE_REGNO (v) = regnum;
d639 1
a639 1
      VALUE_FRAME_REGNUM (v) = regnum;
d699 1
a699 1
	  VALUE_FRAME_REGNUM (v) = regnum;
d710 1
a710 1
	  VALUE_REGNO (v) = first_realnum;
d767 2
a768 2
	gdb_assert (REGISTER_NAME (VALUE_REGNO (lazy_value)) != NULL
	            && *REGISTER_NAME (VALUE_REGNO (lazy_value)) != '\0');
d772 1
a772 1
	    REGISTER_NAME (VALUE_REGNO (lazy_value)));
d776 2
a777 2
	gdb_assert (REGISTER_NAME (VALUE_FRAME_REGNUM (lazy_value)) != NULL
	            && *REGISTER_NAME (VALUE_FRAME_REGNUM (lazy_value)) != '\0');
d781 1
a781 1
	    REGISTER_NAME (VALUE_FRAME_REGNUM (lazy_value)));
@


1.78
log
@2004-11-09  Andrew Cagney  <cagney@@gnu.org>

	* value.h (struct value): Delete field bfd_section.
	(VALUE_BFD_SECTION): Delete macro.
	(COERCE_REF): Update.
	(value_at, value_at_lazy): Delete asection parameter.
	* printcmd.c (print_formatted, x_command): Update.
	(do_examine): Delete asection parameter.
	(next_section): Delete variable.
	* valops.c (value_cast, value_at, value_at_lazy)
	(value_coerce_function, value_addr, value_ind, value_string)
	(find_rt_vbase_offset, value_full_object): Update.
	* hpacc-abi.c (hpacc_virtual_fn_field)
	(hpacc_value_rtti_type): Update.
	* gnu-v3-abi.c (gnuv3_rtti_type, gnuv3_virtual_fn_field)
	(gnuv3_baseclass_offset): Update.
	* f-valprint.c (f_val_print): Update.
	* c-valprint.c (c_val_print): Update.
	* p-valprint.c (pascal_val_print): Update.
	* jv-valprint.c (java_value_print): Update.
	* jv-lang.c (java_class_from_object, evaluate_subexp_java): Update.
	* ada-lang.c (ada_value_primitive_packed_val)
	(ada_evaluate_subexp): Update.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Update.
	* expprint.c (print_subexp_standard): Update.
	* infcall.c (call_function_by_hand): Update.
	* valarith.c (value_add): Update.
	* eval.c (evaluate_subexp_standard): Update.
	* values.c (allocate_value, value_copy, value_static_field): Update.
	* findvar.c (read_var_value, locate_var_value): Update.
@
text
@d725 1
a725 1
	VALUE_OFFSET (v) = register_size (current_gdbarch, regnum) - len;
d727 2
a728 2
	VALUE_OFFSET (v) = 0;
      memcpy (VALUE_CONTENTS_RAW (v), value_bytes + VALUE_OFFSET (v), len);
@


1.77
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@a388 1
  VALUE_BFD_SECTION (v) = SYMBOL_BFD_SECTION (var);
d452 1
a452 1
	loc = value_at (lookup_pointer_type (type), locaddr, NULL);
d475 1
a475 1
	ref = value_at (lookup_pointer_type (type), argref, NULL);
a759 1
      VALUE_BFD_SECTION (val) = VALUE_BFD_SECTION (lazy_value);
@


1.76
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* regcache.h: Delete DEPRECATED_REGISTER_VIRTUAL_SIZE and
	DEPRECATED_REGISTER_RAW_SIZE from comments.
	* regcache.c (init_regcache_descr, regcache_dump): Do not check or
	use DEPRECATED_REGISTER_VIRTUAL_SIZE and
	DEPRECATED_REGISTER_RAW_SIZE.
	* findvar.c (value_of_register): Simplify by assuming that the
	registers raw and virtual sizes are identical.
	* regcache.h: Delete DEPRECATED_REGISTER_VIRTUAL_TYPE in
	comment.
	* arch-utils.c (generic_register_size): Simplify by assuming
	register_type.
@
text
@d658 1
a658 1
	   (value_bytes_copied += DEPRECATED_REGISTER_RAW_SIZE (local_regnum),
d724 1
a724 1
	  && len < DEPRECATED_REGISTER_RAW_SIZE (regnum))
d726 1
a726 1
	VALUE_OFFSET (v) = DEPRECATED_REGISTER_RAW_SIZE (regnum) - len;
@


1.75
log
@2004-06-09  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_REGISTER_CONVERT_TO_RAW)
	(DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL)
	(DEPRECATED_REGISTER_CONVERTIBLE): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcmd.c (default_print_registers_info): Simplify.
	* findvar.c (value_of_register): Simplify.
	* mi/mi-main.c (get_register): Simplify.
	* arch-utils.c (legacy_convert_register_p): Always return 0.
	(legacy_register_to_value, legacy_value_to_register): Always call
	internal_error.
@
text
@d285 2
a286 12
  /* Convert raw data to virtual format if necessary.  */

  if (DEPRECATED_REGISTER_RAW_SIZE (regnum) == DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum))
    memcpy (VALUE_CONTENTS_RAW (reg_val), raw_buffer,
	    DEPRECATED_REGISTER_RAW_SIZE (regnum));
  else
    internal_error (__FILE__, __LINE__,
		    "Register \"%s\" (%d) has conflicting raw (%d) and virtual (%d) size",
		    REGISTER_NAME (regnum),
		    regnum,
		    DEPRECATED_REGISTER_RAW_SIZE (regnum),
		    DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
@


1.74
log
@* findvar.c (value_from_register): Doc fix.
@
text
@d287 1
a287 7
  if (DEPRECATED_REGISTER_CONVERTIBLE_P ()
      && DEPRECATED_REGISTER_CONVERTIBLE (regnum))
    {
      DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL (regnum, register_type (current_gdbarch, regnum),
					      raw_buffer, VALUE_CONTENTS_RAW (reg_val));
    }
  else if (DEPRECATED_REGISTER_RAW_SIZE (regnum) == DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum))
@


1.74.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d285 18
a302 2
  memcpy (VALUE_CONTENTS_RAW (reg_val), raw_buffer,
	  register_size (current_gdbarch, regnum));
d674 1
a674 1
	   (value_bytes_copied += register_size (current_gdbarch, local_regnum),
d740 1
a740 1
	  && len < register_size (current_gdbarch, regnum))
d742 1
a742 1
	VALUE_OFFSET (v) = register_size (current_gdbarch, regnum) - len;
@


1.73
log
@* findvar.c (value_from_register): Doc fix.
@
text
@d630 8
a637 8
         like 'struct {}'.  GDB may also create them when it finds
         bogus debugging information; for example, in GCC 2.95.4 and
         binutils 2.11.93.0.2, the STABS BINCL->EXCL compression
         process can create bad type numbers.  GDB reads these as
         TYPE_CODE_UNDEF types, with zero length.  (That bug is
         actually the only known way to get a zero-length value
         allocated to a register --- which is what it takes to make it
         here.)
@


1.72
log
@* findvar.c (value_from_register): If the type has no length, just
return an acceptable value --- don't report an internal error.
@
text
@d631 1
a631 1
         bogus debugging information; for example, in GCC 2.94.4 and
@


1.71
log
@2004-02-14  Andrew Cagney  <cagney@@redhat.com>

	* arch-utils.c (legacy_convert_register_p): Check
	DEPRECATED_REGISTER_CONVERTIBLE_P.
	* findvar.c (value_of_register): Ditto.
@
text
@d621 24
a644 1
  if (CONVERT_REGISTER_P (regnum, type))
@


1.70
log
@Fix obvious typo (completly -> completely) and update copyrights as needed
@
text
@d287 2
a288 1
  if (DEPRECATED_REGISTER_CONVERTIBLE (regnum))
@


1.69
log
@Fix typo in comments (Unfortunatly)
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2003 Free Software
d266 1
a266 1
  /* User registers lie completly outside of the range of normal
@


1.68
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* dwarf2loc.c (dwarf_expr_frame_base): Use SYMBOL_OPS instead of
	SYMBOL_LOCATION_FUNCS
	(dwarf2_loclist_funcs, dwarf2_locexpr_funcs): Change type to
	"struct symbol_ops".
	* dwarf2loc.h (dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Change
	type to "struct symbol_ops".
	* symtab.h (struct symbol_ops): Rename "struct location_funcs".
	(struct symbol): Replace ".aux_value.loc.funcs" and
	".aux_value.loc.baton" with ".ops" and ".aux_value.ptr".
	(SYMBOL_OBJFILE): Delete macro.
	(SYMBOL_LOCATION_FUNCS): Delete macro.
	(SYMBOL_LOCATION_BATON): Update.
	* dwarf2read.c (dwarf2_symbol_mark_computed): Set SYMBOL_OPS
	intead of SYMBOL_LOCATION_FUNCS.
	* ax-gdb.c (gen_var_ref): Ditto.
	* printcmd.c (address_info): Ditto.
	* findvar.c (read_var_value): Ditto.
	(symbol_read_needs_frame): Ditto.
@
text
@d351 1
a351 1
	 Unfortunatly DWARF 2 stores the frame-base (instead of the
d570 1
a570 1
	 Unfortunatly DWARF 2 stores the frame-base (instead of the
@


1.67
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d349 6
a354 5
      {
	struct location_funcs *symfuncs = SYMBOL_LOCATION_FUNCS (sym);
	return (symfuncs->read_needs_frame) (sym);
      }
      break;
d568 8
a575 9
      {
	struct location_funcs *funcs = SYMBOL_LOCATION_FUNCS (var);

	if (frame == 0 && (funcs->read_needs_frame) (var))
	  return 0;
	return (funcs->read_variable) (var, frame);

      }
      break;
@


1.66
log
@2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_VIRTUAL_SIZE to
	DEPRECATED_REGISTER_VIRTUAL_SIZE.

2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_VIRTUAL_SIZE): Rename
	REGISTER_VIRTUAL_SIZE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* vax-tdep.h, sparc-tdep.c, regcache.h: Update.
	* regcache.c, mn10300-tdep.c, mips-tdep.c: Update.
	* infcmd.c, frame.c, findvar.c, cris-tdep.c: Update.

2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_VIRTUAL_SIZE to DEPRECATED_REGISTER_VIRTUAL_SIZE.
	(Target Architecture Definition):
@
text
@d292 1
a292 1
  else if (REGISTER_RAW_SIZE (regnum) == DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum))
d294 1
a294 1
	    REGISTER_RAW_SIZE (regnum));
d300 1
a300 1
		    REGISTER_RAW_SIZE (regnum),
d650 1
a650 1
	   (value_bytes_copied += REGISTER_RAW_SIZE (local_regnum),
d716 1
a716 1
	  && len < REGISTER_RAW_SIZE (regnum))
d718 1
a718 1
	VALUE_OFFSET (v) = REGISTER_RAW_SIZE (regnum) - len;
@


1.65
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@d292 1
a292 1
  else if (REGISTER_RAW_SIZE (regnum) == REGISTER_VIRTUAL_SIZE (regnum))
d301 1
a301 1
		    REGISTER_VIRTUAL_SIZE (regnum));
@


1.64
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d394 1
a394 1
read_var_value (register struct symbol *var, struct frame_info *frame)
d733 1
a733 1
locate_var_value (register struct symbol *var, struct frame_info *frame)
@


1.63
log
@	* frame.c (deprecated_safe_get_selected_frame): New function.
	* frame.h (deprecated_safe_get_selected_frame): Add prototype.
	* findvar.c (read_var_value): Call it.
@
text
@d396 1
a396 1
  register struct value *v;
d399 1
a399 1
  register int len;
@


1.62
log
@2003-07-22  Elena Zannoni  <ezannoni@@redhat.com>

	* findvar.c (read_var_value): Remove case for thread local storage
	variables.  It is now entirely handled by the dwarf2 location
	expression code.
	* printcmd.c (address_info): Ditto.
	* symtab.h (address_class): Remove LOC_THREAD_LOCAL_STATIC
	enumeration value.
	(struct symbol): Remove objfile field, which was used by
	LOC_THREAD_LOCAL_STATIC only.
	* dwarf2read.c (decode_locdesc): Remove is_thread_local variable.
	* dwarf2loc.h (struct dwarf2_loclist_baton): Add comment about
	usage of objfile pointer.
	* dwarf2loc.c (locexpr_describe_location): Add case to handle
	thread local variables.
	Add include of objfiles.h.
	* dwarf2expr.c (execute_stack_op): Add comments about thread local
	storage variables.
	* Makefile.in (dwarf2loc.o): Update dependencies.
@
text
@d407 3
d411 1
a411 1
    frame = deprecated_selected_frame;
@


1.61
log
@2003-07-07  Andrew Cagney  <cagney@@redhat.com>

	* expprint.c: Include "user-regs.h" instead of "frame.h".
	(print_subexp): Use user_reg_map_regnum_to_name, instead of
	frame_map_regnum_to_name.
	* frame.c: Include "user-regs.h" instead of "builtin-regs.h".
	(frame_map_name_to_regnum): Simplify, call
	user_reg_map_name_to_regnum.
	(frame_map_regnum_to_name): Simplify, call
	user_reg_map_regnum_to_name.
	(frame_register_unwind): Update.
	* std-regs.c: Include "user-regs.h" instead of "builtin-regs.h".
	(_initialize_frame_reg): Call user_reg_add_builtin.
	* findvar.c: Include "user-regs.h" instead of "builtin-regs.h".
	(value_of_register): Use value_of_user_reg.
	* eval.c (evaluate_subexp_standard): Update.
	* parse.c (write_dollar_variable): Update.
	* d10v-tdep.c (d10v_print_registers_info): Update.
	* infcmd.c (registers_info): Update.
	* Makefile.in (SFILES): Delete "builtin-regs.c", add "user-regs.c".
	(builtin_regs_h): Delete macro.
	(user_regs_h): Define.
	(COMMON_OBS): Delete "builtin-regs.o", add "user-regs.o".
	(builtin-regs.o): Delete target.
	(user-regs.o): Specify dependencies.
	(expprint.o): Update dependencies.
	(findvar.o): Update dependencies.
	(frame.o): Update dependencies.
	(std-regs.o): Update dependencies.
@
text
@a514 14
    case LOC_THREAD_LOCAL_STATIC:
      {
        if (target_get_thread_local_address_p ())
          addr = target_get_thread_local_address (inferior_ptid,
                                                  SYMBOL_OBJFILE (var),
                                                  SYMBOL_VALUE_ADDRESS (var));
        /* It wouldn't be wrong here to try a gdbarch method, too;
           finding TLS is an ABI-specific thing.  But we don't do that
           yet.  */
        else
          error ("Cannot find thread-local variables on this target");
        break;
      }

@


1.60
log
@2003-06-14  Andrew Cagney  <cagney@@redhat.com>
            Mark Kettenis  <kettenis@@gnu.org>

	* gdbarch.sh (CONVERT_REGISTER_P): Add "type" parameter.
	(REGISTER_TO_VALUE, VALUE_TO_REGISTER): Replace raw buffer
	parameter with "frame".
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h (put_frame_register): Declare.
	* frame.c (put_frame_register): New function.
	* arch-utils.c (legacy_convert_register_p): Add "type" parameter.
	(legacy_register_to_value): Rewrite, use "frame" to get the
	register value.
	(legacy_value_to_register): Rewrite, use "frame" to find the
	register's location before storing.
	* arch-utils.h (legacy_convert_register_p): Update.
	(legacy_register_to_value, legacy_value_to_register): Update.
	* findvar.c (value_from_register): Rewrite, eliminate use of
	REGISTER_CONVERT_TO_TYPE, pass "type" to CONVERT_REGISTER_P, pass
	"frame" to REGISTER_TO_VALUE.
	* valops.c (value_assign): Move the CONVERT_REGISTER code to the
	lval_reg_frame_relative + lval_register branch of the switch.  Do
	not use REGISTER_CONVERT_FROM_TYPE.  Use put_frame_register.
	* i386-tdep.c (I386_EBX_REGNUM, I386_ECX_REGNUM, I386_ESI_REGNUM,
	I386_EDI_REGNUM): New defines.
	(i386_next_regnum, i386_convert_register_p,
	i386_register_to_value, i386_value_to_register): New functions.
	(i386_register_convertible, i386_register_convert_to_virtual,
	i386_convert_to_raw): Remove functions.
	(i386_gdbarch_init): Set convert_register_p, register_to_value and
	value_to_register instead of register_convertible,
	register_convert_to_virtual and register_convert_to_raw.
	* mips-tdep.c (mips_convert_register_p): New function.
	(mips_value_to_register): Replace mips_register_convert_from_type.
	(mips_register_to_value): Replace mips_register_convert_to_type.
	(mips_gdbarch_init): Set conver_register_p, value_to_register and
	register_to_value.
	* alpha-tdep.c (alpha_convert_register_p): Update.
	(alpha_value_to_register): Update, store the register.
	(alpha_register_to_value): Update, fetch the register.
@
text
@d37 1
a37 1
#include "builtin-regs.h"
d266 1
a266 1
  /* Builtin registers lie completly outside of the range of normal
d269 1
a269 1
    return value_of_builtin_reg (regnum, frame);
@


1.60.2.1
log
@2003-07-22  Elena Zannoni  <ezannoni@@redhat.com>

	* findvar.c (read_var_value): Remove case for thread local storage
	variables.  It is now entirely handled by the dwarf2 location
	expression code.
	* printcmd.c (address_info): Ditto.
	* symtab.h (address_class): Remove LOC_THREAD_LOCAL_STATIC
	enumeration value.
	(struct symbol): Remove objfile field, which was used by
	LOC_THREAD_LOCAL_STATIC only.
	* dwarf2read.c (decode_locdesc): Remove is_thread_local variable.
	* dwarf2loc.h (struct dwarf2_loclist_baton): Add comment about
	usage of objfile pointer.
	* dwarf2loc.c (locexpr_describe_location): Add case to handle
	thread local variables.
	Add include of objfiles.h.
	* dwarf2expr.c (execute_stack_op): Add comments about thread local
	storage variables.
	* Makefile.in (dwarf2loc.o): Update dependencies.
@
text
@d515 14
@


1.60.2.2
log
@	* frame.c (deprecated_safe_get_selected_frame): New function.
	* frame.h (deprecated_safe_get_selected_frame): Add prototype.
	* findvar.c (read_var_value): Call it.
@
text
@a406 3

  /* FIXME drow/2003-09-06: this call to the selected frame should be
     pushed upwards to the callers.  */
d408 1
a408 1
    frame = deprecated_safe_get_selected_frame ();
@


1.59
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_CONVERTIBLE): Deprecate
	REGISTER_CONVERTIBLE.
	(DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL): Same.
	(DEPRECATED_REGISTER_CONVERT_TO_RAW): Same, make "from" constant.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (deprecated_register_convertible_not): Rename
	generic_register_convertible_not.
	* arch-utils.c (deprecated_register_convertible_not): Rename
	generic_register_convertible.
	(legacy_convert_register_p, legacy_register_to_value): Update.
	* sh-tdep.c (sh64_push_arguments): Update.
	* m68klinux-tdep.c (m68k_linux_extract_return_value): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_EXTRACT_RETURN_VALUE): Update.
	* m68klinux-tdep.c (m68k_linux_store_return_value): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Update.
	* arch-utils.c (legacy_value_to_register): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	(rs6000_register_convert_to_raw): Make parameter "from" const.
	* mips-tdep.c (mips_gdbarch_init): Update.
	(mips_register_convert_to_raw): Make  parameter"virt_buf" const.
	* infcmd.c (default_print_registers_info): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_register_convert_to_raw): Make parameter "from" const.
	* i386-tdep.c (i386_gdbarch_init): Update.
	(i386_register_convert_to_raw): Update.
@
text
@d627 1
a627 3
  char raw_buffer[MAX_REGISTER_SIZE];
  CORE_ADDR addr;
  int optim;
a628 6
  char *value_bytes = 0;
  int value_bytes_copied = 0;
  int num_storage_locs;
  enum lval_type lval;
  int len;

a629 1
  len = TYPE_LENGTH (type);
d631 15
a645 13
  VALUE_REGNO (v) = regnum;

  num_storage_locs = (len > REGISTER_VIRTUAL_SIZE (regnum) ?
		      ((len - 1) / REGISTER_RAW_SIZE (regnum)) + 1 :
		      1);

  if (num_storage_locs > 1
#if 0
      // OBSOLETE #ifdef GDB_TARGET_IS_H8500
      // OBSOLETE       || TYPE_CODE (type) == TYPE_CODE_PTR
      // OBSOLETE #endif
#endif
    )
a646 2
      /* Value spread across multiple storage locations.  */

d652 5
a656 2

      value_bytes = (char *) alloca (len + MAX_REGISTER_SIZE);
d659 17
a675 86

#if 0
      // OBSOLETE #ifdef GDB_TARGET_IS_H8500
      // OBSOLETE /* This piece of hideosity is required because the H8500 treats registers
      // OBSOLETE    differently depending upon whether they are used as pointers or not.  As a
      // OBSOLETE    pointer, a register needs to have a page register tacked onto the front.
      // OBSOLETE    An alternate way to do this would be to have gcc output different register
      // OBSOLETE    numbers for the pointer & non-pointer form of the register.  But, it
      // OBSOLETE    doesn't, so we're stuck with this.  */
      // OBSOLETE 
      // OBSOLETE       if (TYPE_CODE (type) == TYPE_CODE_PTR
      // OBSOLETE 	  && len > 2)
      // OBSOLETE 	{
      // OBSOLETE 	  int page_regnum;
      // OBSOLETE 
      // OBSOLETE 	  switch (regnum)
      // OBSOLETE 	    {
      // OBSOLETE 	    case R0_REGNUM:
      // OBSOLETE 	    case R1_REGNUM:
      // OBSOLETE 	    case R2_REGNUM:
      // OBSOLETE 	    case R3_REGNUM:
      // OBSOLETE 	      page_regnum = SEG_D_REGNUM;
      // OBSOLETE 	      break;
      // OBSOLETE 	    case R4_REGNUM:
      // OBSOLETE 	    case R5_REGNUM:
      // OBSOLETE 	      page_regnum = SEG_E_REGNUM;
      // OBSOLETE 	      break;
      // OBSOLETE 	    case R6_REGNUM:
      // OBSOLETE 	    case R7_REGNUM:
      // OBSOLETE 	      page_regnum = SEG_T_REGNUM;
      // OBSOLETE 	      break;
      // OBSOLETE 	    }
      // OBSOLETE 
      // OBSOLETE 	  value_bytes[0] = 0;
      // OBSOLETE 	  get_saved_register (value_bytes + 1,
      // OBSOLETE 			      &optim,
      // OBSOLETE 			      &addr,
      // OBSOLETE 			      frame,
      // OBSOLETE 			      page_regnum,
      // OBSOLETE 			      &lval);
      // OBSOLETE 
      // OBSOLETE 	  if (register_cached (page_regnum) == -1)
      // OBSOLETE 	    return NULL;	/* register value not available */
      // OBSOLETE 
      // OBSOLETE 	  if (lval == lval_register)
      // OBSOLETE 	    reg_stor++;
      // OBSOLETE 	  else
      // OBSOLETE 	    mem_stor++;
      // OBSOLETE 	  first_addr = addr;
      // OBSOLETE 	  last_addr = addr;
      // OBSOLETE 
      // OBSOLETE 	  get_saved_register (value_bytes + 2,
      // OBSOLETE 			      &optim,
      // OBSOLETE 			      &addr,
      // OBSOLETE 			      frame,
      // OBSOLETE 			      regnum,
      // OBSOLETE 			      &lval);
      // OBSOLETE 
      // OBSOLETE 	  if (register_cached (regnum) == -1)
      // OBSOLETE 	    return NULL;	/* register value not available */
      // OBSOLETE 
      // OBSOLETE 	  if (lval == lval_register)
      // OBSOLETE 	    reg_stor++;
      // OBSOLETE 	  else
      // OBSOLETE 	    {
      // OBSOLETE 	      mem_stor++;
      // OBSOLETE 	      mem_tracking = mem_tracking && (addr == last_addr);
      // OBSOLETE 	    }
      // OBSOLETE 	  last_addr = addr;
      // OBSOLETE 	}
      // OBSOLETE       else
      // OBSOLETE #endif /* GDB_TARGET_IS_H8500 */
#endif
	for (local_regnum = regnum;
	     value_bytes_copied < len;
	     (value_bytes_copied += REGISTER_RAW_SIZE (local_regnum),
	      ++local_regnum))
	  {
	    int realnum;
	    frame_register (frame, local_regnum, &optim, &lval, &addr,
			    &realnum, value_bytes + value_bytes_copied);

	    if (register_cached (local_regnum) == -1)
	      return NULL;	/* register value not available */

	    if (regnum == local_regnum)
d677 19
a695 14
	    if (lval == lval_register)
	      reg_stor++;
	    else
	      {
		mem_stor++;

		mem_tracking =
		  (mem_tracking
		   && (regnum == local_regnum
		       || addr == last_addr));
	      }
	    last_addr = addr;
	  }

d714 1
d719 3
a721 3

      VALUE_OPTIMIZED_OUT (v) = optim;

d723 1
a723 1
         an integral number of registers.  Otherwise, you'd need to do
d726 7
a732 34

      /* Copy into the contents section of the value.  */
      memcpy (VALUE_CONTENTS_RAW (v), value_bytes, len);

      /* Finally do any conversion necessary when extracting this
         type from more than one register.  */
#ifdef REGISTER_CONVERT_TO_TYPE
      REGISTER_CONVERT_TO_TYPE (regnum, type, VALUE_CONTENTS_RAW (v));
#endif
      return v;
    }

  /* Data is completely contained within a single register.  Locate the
     register's contents in a real register or in core;
     read the data in raw format.  */

  {
    int realnum;
    frame_register (frame, regnum, &optim, &lval, &addr, &realnum, raw_buffer);
  }

  if (register_cached (regnum) == -1)
    return NULL;		/* register value not available */

  VALUE_OPTIMIZED_OUT (v) = optim;
  VALUE_LVAL (v) = lval;
  VALUE_ADDRESS (v) = addr;

  /* Convert the raw register to the corresponding data value's memory
     format, if necessary.  */

  if (CONVERT_REGISTER_P (regnum))
    {
      REGISTER_TO_VALUE (regnum, type, raw_buffer, VALUE_CONTENTS_RAW (v));
a733 13
  else
    {
      /* Raw and virtual formats are the same for this register.  */

      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG && len < REGISTER_RAW_SIZE (regnum))
	{
	  /* Big-endian, and we want less than full size.  */
	  VALUE_OFFSET (v) = REGISTER_RAW_SIZE (regnum) - len;
	}

      memcpy (VALUE_CONTENTS_RAW (v), raw_buffer + VALUE_OFFSET (v), len);
    }

d736 1
@


1.58
log
@2003-06-05  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (value_h): Add $(frame_h).
	* value.h: Include "frame.h".
	(struct value): Replace "frame_addr" with "frame_id".
	(VALUE_FRAME_ID): Replace VALUE_FRAME.
	* values.c (allocate_value): Use VALUE_FRAME_ID.
	(value_copy): Use VALUE_FRAME_ID.
	* findvar.c (value_from_register): Use VALUE_FRAME_ID.
	* valops.c (value_assign): Update.  Use frame_find_by_id.
@
text
@d287 1
a287 1
  if (REGISTER_CONVERTIBLE (regnum))
d289 2
a290 2
      REGISTER_CONVERT_TO_VIRTUAL (regnum, register_type (current_gdbarch, regnum),
				   raw_buffer, VALUE_CONTENTS_RAW (reg_val));
@


1.58.2.1
log
@2003-06-06  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (put_frame_register): Declare.
	* frame.c (put_frame_register): New function.

	* arch-utils.c: Include "gdbcore.h".
	(legacy_convert_register_p): Add "type" parameter.
	(legacy_register_to_value): Rewrite, use "frame" to get the
	register value.
	(legacy_value_to_register): Rewrite, use "frame" to find the
	register's location before storing.
	* arch-utils.h (legacy_convert_register_p): Update.
	(legacy_register_to_value, legacy_value_to_register): Update.

	* Makefile.in (arch-utils.o): Update dependencies.

	* findvar.c (value_from_register): Rewrite, eliminate use of
	REGISTER_CONVERT_TO_TYPE, pass "type" to CONVERT_REGISTER_P, pass
	"frame" to REGISTER_TO_VALUE.

	* gdbarch.sh (CONVERT_REGISTER_P): Add "type" parameter.
	(REGISTER_TO_VALUE, VALUE_TO_REGISTER): Replace "type", "from" and
	"to" parameters with "frame" and "value".
	* gdbarch.h, gdbarch.c: Re-generate.

	* mips-tdep.c (mips_convert_register_p): New function.
	(mips_value_to_register): Replace mips_register_convert_from_type.
	(mips_register_to_value): Replace mips_register_convert_to_type.
	(mips_gdbarch_init): Set conver_register_p, value_to_register and
	register_to_value.

	* valops.c (value_assign): Move the CONVERT_REGISTER code to the
	lval_reg_frame_relative + lval_register branch of the switch.  Do
	not use REGISTER_CONVERT_FROM_TYPE.  Use put_frame_register.
@
text
@d627 3
a629 1
  struct gdbarch *gdbarch = get_frame_arch (frame);
d631 6
d638 7
d646 7
a652 16
  if (CONVERT_REGISTER_P (regnum, type))
    {
      int realnum;
      int optim;
      enum lval_type lval;
      CORE_ADDR addr;
      /* The ISA/ABI need to something weird when obtaining the
         specified value from this register.  It might need to
         re-order non-adjacent, starting with REGNUM (see MIPS and
         i386).  It might need to convert the [float] register into
         the corresponding [integer] type (see Alpha).  The assumption
         is that REGISTER_TO_VALUE populates the entire value
         including the location.  */
      REGISTER_TO_VALUE (frame, regnum, v);
    }
  else
d654 2
d661 2
a662 5
      int first_realnum = regnum;
      int len = TYPE_LENGTH (type);
      int value_bytes_copied;
      int optimized = 0;
      char *value_bytes = (char *) alloca (len + MAX_REGISTER_SIZE);
d665 86
a750 17
      for (local_regnum = regnum, value_bytes_copied = 0;
	   value_bytes_copied < len;
	   (value_bytes_copied += REGISTER_RAW_SIZE (local_regnum),
	    ++local_regnum))
	{
	  int realnum;
	  int optim;
	  enum lval_type lval;
	  CORE_ADDR addr;
	  frame_register (frame, local_regnum, &optim, &lval, &addr,
			  &realnum, value_bytes + value_bytes_copied);
	  optimized += optim;
	  if (register_cached (local_regnum) == -1)
	    return NULL;	/* register value not available */
	  
	  if (regnum == local_regnum)
	    {
d752 14
a765 19
	      first_realnum = realnum;
	    }
	  if (lval == lval_register)
	    reg_stor++;
	  else
	    {
	      mem_stor++;
	      
	      mem_tracking = (mem_tracking
			      && (regnum == local_regnum
				  || addr == last_addr));
	    }
	  last_addr = addr;
	}
      
      /* FIXME: cagney/2003-06-04: Shouldn't this always use
         lval_reg_frame_relative?  If it doesn't and the register's
         location changes (say after a resume) then this value is
         going to have wrong information.  */
a783 1
	  VALUE_REGNO (v) = first_realnum;
d788 3
a790 3
      
      VALUE_OPTIMIZED_OUT (v) = optimized;
      
d792 1
a792 1
         an integral number of registers.  Otherwise, you need to do
d795 46
a840 7
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && len < REGISTER_RAW_SIZE (regnum))
	/* Big-endian, and we want less than full size.  */
	VALUE_OFFSET (v) = REGISTER_RAW_SIZE (regnum) - len;
      else
	VALUE_OFFSET (v) = 0;
      memcpy (VALUE_CONTENTS_RAW (v), value_bytes + VALUE_OFFSET (v), len);
d842 1
a844 1

@


1.58.2.2
log
@2003-06-06  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (put_frame_register): Declare.
	* frame.c (put_frame_register): New function.

	* arch-utils.c: Include "gdbcore.h".
	(legacy_convert_register_p): Add "type" parameter.
	(legacy_register_to_value): Rewrite, use "frame" to get the
	register value.
	(legacy_value_to_register): Rewrite, use "frame" to find the
	register's location before storing.
	* arch-utils.h (legacy_convert_register_p): Update.
	(legacy_register_to_value, legacy_value_to_register): Update.

	* Makefile.in (arch-utils.o): Update dependencies.

	* findvar.c (value_from_register): Rewrite, eliminate use of
	REGISTER_CONVERT_TO_TYPE, pass "type" to CONVERT_REGISTER_P, pass
	"frame" to REGISTER_TO_VALUE.

	* gdbarch.sh (CONVERT_REGISTER_P): Add "type" parameter.
	(REGISTER_TO_VALUE, VALUE_TO_REGISTER): Replace raw buffer
	parameter with "frame".
	* gdbarch.h, gdbarch.c: Re-generate.

	* mips-tdep.c (mips_convert_register_p): New function.
	(mips_value_to_register): Replace mips_register_convert_from_type.
	(mips_register_to_value): Replace mips_register_convert_to_type.
	(mips_gdbarch_init): Set conver_register_p, value_to_register and
	register_to_value.

	* valops.c (value_assign): Move the CONVERT_REGISTER code to the
	lval_reg_frame_relative + lval_register branch of the switch.  Do
	not use REGISTER_CONVERT_FROM_TYPE.  Use put_frame_register.
@
text
@d633 4
d644 1
a644 4
      REGISTER_TO_VALUE (frame, regnum, type, VALUE_CONTENTS_RAW (v));
      VALUE_LVAL (v) = lval_reg_frame_relative;
      VALUE_FRAME_ID (v) = get_frame_id (frame);
      VALUE_FRAME_REGNUM (v) = regnum;
@


1.57
log
@2003-06-01  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (extract_address): Delete declaration.
	* findvar.c (extract_address): Delete function.
	* xstormy16-tdep.c (xstormy16_extract_return_value): Replace
	extract_address with the inline equivalent,
	extract_unsigned_integer.
	(xstormy16_extract_struct_value_address): Ditto.
	(xstormy16_pointer_to_address): Ditto.
	* vax-tdep.c (vax_extract_struct_value_address): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	(v850_extract_return_value): Ditto.
	(v850_extract_struct_value_address): Ditto.
	* sparcnbsd-tdep.c (sparcnbsd_get_longjmp_target_32): Ditto.
	(sparcnbsd_get_longjmp_target_64): Ditto.
	* sparc-tdep.c (sparc_frame_saved_pc): Ditto.
	(get_longjmp_target): Ditto.
	* sh-tdep.c (sh_extract_struct_value_address): Ditto.
	(sh64_extract_struct_value_address): Ditto.
	(sh_push_arguments): Ditto.
	(sh64_push_arguments): Ditto.
	* remote-vxsparc.c (vx_read_register): Ditto.
	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Ditto.
	* ns32k-tdep.c (ns32k_extract_struct_value_address): Ditto.
	* mn10300-tdep.c (mn10300_extract_struct_value_address): Ditto.
	* mipsv4-nat.c (get_longjmp_target): Ditto.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Ditto.
	* mips-nat.c (get_longjmp_target): Ditto.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target): Ditto.
	* mcore-tdep.c (mcore_extract_struct_value_address): Ditto.
	* m68k-tdep.c (m68k_get_longjmp_target): Ditto.
	* m68hc11-tdep.c (m68hc11_extract_struct_value_address): Ditto.
	* irix5-nat.c (get_longjmp_target): Ditto.
	* irix4-nat.c (get_longjmp_target): Ditto.
	* ia64-tdep.c (generic_elf_find_global_pointer): Ditto.
	(ia64_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_store_registers): Ditto.
	* h8300-tdep.c (h8300_push_arguments): Ditto.
	(h8300_store_return_value): Ditto.
	(h8300_extract_struct_value_address): Ditto.
	* frv-tdep.c (frv_extract_struct_value_address): Ditto.
	(frv_push_arguments): Ditto.
	* avr-tdep.c (avr_pointer_to_address): Ditto.
	(avr_push_arguments): Ditto.
	* arm-tdep.c (arm_push_dummy_call): Ditto.
	(arm_get_longjmp_target): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_extract_struct_value_address): Ditto.
	(alpha_get_longjmp_target): Ditto.
@
text
@d772 1
a772 1
	  VALUE_FRAME (v) = get_frame_base (frame);
@


1.56
log
@2003-05-22  Andrew Cagney  <cagney@@redhat.com>

	* stack.c (frame_info): Inline extract_address, replacing it with
	extract_unsigned_integer.
	* findvar.c (unsigned_pointer_to_address): Ditto.
	* dwarf2loc.c (dwarf_expr_read_reg): Ditto.
	* dwarf2expr.c (dwarf2_read_address): Ditto.
	* frame.c (frame_pc_unwind): Update comment.
	* dummy-frame.c (deprecated_read_register_dummy): Update comment.
@
text
@a163 22
/* Treat the LEN bytes at ADDR as a target-format address, and return
   that address.  ADDR is a buffer in the GDB process, not in the
   inferior.

   This function should only be used by target-specific code.  It
   assumes that a pointer has the same representation as that thing's
   address represented as an integer.  Some machines use word
   addresses, or similarly munged things, for certain types of
   pointers, so that assumption doesn't hold everywhere.

   Common code should use extract_typed_address instead, or something
   else based on POINTER_TO_ADDRESS.  */

CORE_ADDR
extract_address (const void *addr, int len)
{
  /* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure
     whether we want this to be true eventually.  */
  return (CORE_ADDR) extract_unsigned_integer (addr, len);
}


@


1.55
log
@2003-05-13  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (store_address): Delete declaration.
	findvar.c (store_address): Delete function.
	* arm-tdep.c (arm_push_dummy_call): Replace store_address with
	store_unsigned_integer.
	* xstormy16-tdep.c (xstormy16_address_to_pointer): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	* sparc-tdep.c (sparc_get_saved_register): Ditto.
	* sh-tdep.c (sh64_get_saved_register): Ditto.
	* rs6000-tdep.c (rs6000_push_arguments): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_arguments): Ditto.
	* mips-tdep.c (mips_eabi_push_arguments): Ditto.
	(mips_get_saved_register): Ditto.
	* ia64-tdep.c (ia64_get_saved_register): Ditto.
	(find_func_descr, ia64_push_arguments): Ditto.
	* i386-tdep.c (i386_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	* frv-tdep.c (frv_push_arguments): Ditto.
	* frame.c (legacy_saved_regs_prev_register): Ditto.
	(deprecated_generic_get_saved_register): Ditto.
	* findvar.c (unsigned_address_to_pointer): Ditto.
	* dwarf2read.c (dwarf2_const_value): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_push_arguments): Ditto.
@
text
@d336 1
a336 1
  return extract_address (buf, TYPE_LENGTH (type));
@


1.54
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@a254 18
/* Store the address VAL as a LEN-byte value in target byte order at
   ADDR.  ADDR is a buffer in the GDB process, not in the inferior.

   This function should only be used by target-specific code.  It
   assumes that a pointer has the same representation as that thing's
   address represented as an integer.  Some machines use word
   addresses, or similarly munged things, for certain types of
   pointers, so that assumption doesn't hold everywhere.

   Common code should use store_typed_address instead, or something else
   based on ADDRESS_TO_POINTER.  */
void
store_address (void *addr, int len, LONGEST val)
{
  store_unsigned_integer (addr, len, val);
}


d350 1
a350 1
  store_address (buf, TYPE_LENGTH (type), addr);
@


1.54.4.1
log
@Snap const char * mess.
@
text
@d255 18
d368 1
a368 1
  store_unsigned_integer (buf, TYPE_LENGTH (type), addr);
@


1.53
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	Add frame debug info addresses:
	* frame-base.c: New file.
	* frame-base.h: New file.
	* frame.h (struct frame_base): Add opaque declaration.
	(get_frame_base): Update comment.
	(get_frame_base_address): Declare.
	(get_frame_locals_address): Declare.
	(get_frame_args_address): Declare.
	(struct frame_info): Add "base" and "base_cache".  Update
	comments on the unwinder.
	* frame.c: Include "frame-base.h".
	(get_frame_locals_address): New function.
	(get_frame_base_address): New function.
	(get_frame_args_address): New function.
	* findvar.c (read_var_value): Use get_frame_locals_address and
	get_frame_args_address.
	* stack.c (frame_info): Use get_frame_locals_address and
	get_frame_args_address.
	(FRAME_ARGS_ADDRESS_CORRECT): Delete conditionally defined macro,
	moved to "frame-base.c".
	* printcmd.c (print_frame_nameless_args): Ditto.
	* symtab.h (address_class): Update comments.
	* dwarf2loc.c (dwarf_expr_frame_base): Add note about
	get_frame_base_address.
	* dwarf2expr.c (execute_stack_op): Ditto.
	* Makefile.in (frame_base_h): Define.
	(frame.o): Update dependencies.
	(frame-base.o): Add dependencies.
	(SFILES): Add frame-base.c.
	(COMMON_OBS): Add frame-base.o.
@
text
@d303 1
a303 1
  char *raw_buffer = (char*) alloca (MAX_REGISTER_RAW_SIZE);
d667 1
a667 1
  char *raw_buffer = (char*) alloca (MAX_REGISTER_RAW_SIZE);
d702 1
a702 1
      value_bytes = (char *) alloca (len + MAX_REGISTER_RAW_SIZE);
@


1.53.6.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d255 18
d303 1
a303 1
  char raw_buffer[MAX_REGISTER_SIZE];
d368 1
a368 1
  store_unsigned_integer (buf, TYPE_LENGTH (type), addr);
d667 1
a667 1
  char raw_buffer[MAX_REGISTER_SIZE];
d702 1
a702 1
      value_bytes = (char *) alloca (len + MAX_REGISTER_SIZE);
@


1.52
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_saved_register): Delete function.
	* xstormy16-tdep.c: Update comment.
	* regcache.h: Update comments.
	* sparc-tdep.c (sparc_init_extra_frame_info): Instead of
	get_saved_register and extract_address, use
	frame_read_unsigned_register.
	(sparc_frame_saved_pc): Ditto.
	(sparc_get_saved_register): Instead of get_saved_register, use
	frame_register.
	(sparc_pop_frame): Ditto.
	* frame.h (get_saved_register): Delete declaration.
	* findvar.c: Update comments.
	(value_of_register): Call frame_register instead of
	get_saved_register.
	(value_from_register): Ditto.
	* config/sparc/tm-sparc.h: Update comment.
	* breakpoint.c: Update comment.

Index: doc/ChangeLog
2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to get_saved_register.
@
text
@d511 1
a511 1
      addr = FRAME_ARGS_ADDRESS (frame);
d523 1
a523 1
	argref = FRAME_ARGS_ADDRESS (frame);
d536 1
a536 1
      addr = FRAME_LOCALS_ADDRESS (frame);
@


1.52.4.1
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	Add frame debug info addresses:
	* frame-base.c: New file.
	* frame-base.h: New file.
	* frame.h (struct frame_base): Add opaque declaration.
	(get_frame_base): Update comment.
	(get_frame_base_address): Declare.
	(get_frame_locals_address): Declare.
	(get_frame_args_address): Declare.
	(struct frame_info): Add "base" and "base_cache".  Update
	comments on the unwinder.
	* frame.c: Include "frame-base.h".
	(get_frame_locals_address): New function.
	(get_frame_base_address): New function.
	(get_frame_args_address): New function.
	* findvar.c (read_var_value): Use get_frame_locals_address.
	* stack.c (frame_info): Use get_frame_locals_address and
	get_frame_args_address.
	(FRAME_ARGS_ADDRESS_CORRECT): Delete conditionally defined macro,
	moved to "frame-base.c".
	* Makefile.in (frame_base_h): Define.
	(frame.o): Update dependencies.
	(d10v-tdep.o): Update dependencies.
	(frame-base.o): Add dependencies.
	(SFILES): Add frame-base.c.
	(COMMON_OBS): Add frame-base.o.
	* printcmd.c (print_frame_nameless_args): Ditto.
	* symtab.h (address_class): Update comments.
	* dwarf2loc.c (dwarf_expr_frame_base): Add note about
	get_frame_base_address.
	* dwarf2expr.c (execute_stack_op): Ditto.
	* d10v-tdep.c: Include "frame-base.h".
	(d10v_frame_unwind): Make constant.
	(d10v_frame_base_address): New function.
	(d10v_frame_base): New variable.
	(d10v_gdbarch_init): Set frame_base default.
@
text
@d536 1
a536 1
      addr = get_frame_locals_address (frame);
@


1.51
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_current_frame): Check target_has_registers before
	checking target_has_stack.
	* eval.c (evaluate_subexp_standard): Use get_selected_frame,
	instead of deprecated_selected_frame.
	* findvar.c (value_of_register): Pass "frame", not
	deprecated_selected_frame, to value_of_builtin_reg.
@
text
@d302 1
d311 1
a311 2
  get_saved_register (raw_buffer, &optim, &addr,
		      frame, regnum, &lval);
d783 3
a785 6
	    get_saved_register (value_bytes + value_bytes_copied,
				&optim,
				&addr,
				frame,
				local_regnum,
				&lval);
d851 4
a854 1
  get_saved_register (raw_buffer, &optim, &addr, frame, regnum, &lval);
@


1.50
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (ax-gdb.o): Update dependencies.
	* ax-gdb.c: Include "regcache.h".
	(gen_expr): Use register_type instead of REGISTER_VIRTUAL_TYPE.
	* findvar.c (value_of_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.

Index: mi/ChangeLog
2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (get_register): Use register_type instead of
	REGISTER_VIRTUAL_TYPE.
@
text
@d308 1
a308 1
    return value_of_builtin_reg (regnum, deprecated_selected_frame);
@


1.50.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@a301 1
  int realnum;
d308 1
a308 1
    return value_of_builtin_reg (regnum, frame);
d310 2
a311 1
  frame_register (frame, regnum, &optim, &lval, &addr, &realnum, raw_buffer);
d783 6
a788 3
	    int realnum;
	    frame_register (frame, local_regnum, &optim, &lval, &addr,
			    &realnum, value_bytes + value_bytes_copied);
d854 1
a854 4
  {
    int realnum;
    frame_register (frame, regnum, &optim, &lval, &addr, &realnum, raw_buffer);
  }
@


1.49
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d291 1
a291 1
   determined by REGISTER_VIRTUAL_TYPE.
d323 1
a323 1
  reg_val = allocate_value (REGISTER_VIRTUAL_TYPE (regnum));
d329 1
a329 1
      REGISTER_CONVERT_TO_VIRTUAL (regnum, REGISTER_VIRTUAL_TYPE (regnum),
@


1.48
log
@	Based on a patch from Daniel Berlin (dberlin@@dberlin.org).
	* symtab.h: Add opaque declarations of struct axs_value and
	struct agent_expr.
	(enum address_class): Add LOC_COMPUTED and LOC_COMPUTED_ARG.
	(struct location_funcs): New type.
	(struct symbol): Add "loc" to aux_value.
	(SYMBOL_LOCATION_BATON, SYMBOL_LOCATION_FUNCS): New macros.
	* dwarf2read.c: Include "dwarf2expr.h".
	(dwarf2_symbol_mark_computed): New function.
	(read_func_scope): Use it.
	(var_decode_location): New function.
	(new_symbol): Use it.
	* dwarf2expr.c, dwarf2expr.h, dwarf2loc.c, dwarf2loc.h: New files.

	* Makefile.in (SFILES): Add dwarf2loc.c and dwarf2expr.c.
	(dwarf2expr_h, dwarf2loc_h): New variables.
	(COMMON_OBS): Add dwarf2expr.o and dwarf2loc.o.
	(dwarf2expr.o, dwarf2loc.o): New rules.
	(dwarf2read.o): Add $(dwarf2expr_h) and $(dwarf2loc_h).
	* buildsym.c (finish_block): Handle LOC_COMPUTED and
	LOC_COMPUTED_ARG.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info, print_frame_args): Likewise.
	* stack.c (print_block_frame_locals, print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* ada-lang.c (ada_resolve_subexp, symtab_for_sym)
	(ada_add_block_symbols, fill_in_ada_prototype): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
@
text
@d632 1
a632 1
	msym = lookup_minimal_symbol (SYMBOL_NAME (var), NULL, NULL);
@


1.47
log
@2003-02-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME;
	expand comment.
	* ada-lang.c (user_select_syms, ada_finish_decode_line_1): Replace
	SYMBOL_PRINT_NAME with SYMBOL_SOURCE_NAME.
	* ada-typeprint.c (ada_typedef_print): Ditto.
	* ax-gdb.c (gen_var_ref): Ditto.
	* breakpoint.c (print_one_breakpoint): Ditto.
	* buildsym.c (finish_block): Ditto.
	* c-valprint.c (c_val_print): Ditto.
	* expprint.c (print_subexp): Ditto.
	* findvar.c (locate_var_value): Ditto.
	* infcmd.c (jump_command): Ditto.
	* linespec.c (decode_line_2, decode_compound): Ditto.
	* maint.c (maintenance_translate_address): Ditto.
	* objc-lang.c (compare_selectors, compare_classes): Ditto.
	* printcmd.c (build_address_symbolic, sym_info, print_frame_args):
	Ditto.
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* stack.c (print_frame, frame_info, print_block_frame_locals)
	(print_frame_arg_vars, return_command): Ditto.
	* symfile.c (compare_symbols, compare_psymbols): Ditto.
	* symmisc.c (print_symbol): Ditto.
	* symtab.c (lookup_partial_symbol, lookup_block_symbol)
	(compare_search_syms, print_symbol_info, print_msymbol_info)
	(rbreak_command): Ditto.
	* tracepoint.c (tracepoints_info): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* valops.c (value_of_variable, hand_function_call): Ditto.
	* cli/cli-cmds.c (edit_command, list_command): Ditto.
	* ada-typeprint.c: Update Copyright.
	* infcmd.c, objc-lang.c, p-valprint.c, symmisc.c: Ditto.
	* tracepoint.c, cli/cli-cmds.c: Ditto.
@
text
@d387 8
d613 12
@


1.46
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d883 1
a883 1
    error ("Address of \"%s\" is unknown.", SYMBOL_SOURCE_NAME (var));
d904 1
a904 1
            SYMBOL_SOURCE_NAME (var), 
d913 1
a913 1
            SYMBOL_SOURCE_NAME (var), 
d919 1
a919 1
	     SYMBOL_SOURCE_NAME (var));
@


1.45
log
@2003-02-04  Andrew Cagney  <ac131313@@redhat.com>

	* MAINTAINERS: Mark h8500 as obsolete.
	* configure.tgt (h8500-*-*): Mark h8500 code as obsolete.
	* findvar.c (value_from_register): Ditto.
	* h8500-tdep.c: Mark file as obsolete.
	* config/h8500/h8500.mt: Ditto.
	* config/h8500/tm-h8500.h: Ditto.
	* NEWS: Mention that h8500 is obsolete.
@
text
@d38 1
@


1.44
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d666 4
a669 2
#ifdef GDB_TARGET_IS_H8500
      || TYPE_CODE (type) == TYPE_CODE_PTR
d685 72
a756 70
#ifdef GDB_TARGET_IS_H8500
/* This piece of hideosity is required because the H8500 treats registers
   differently depending upon whether they are used as pointers or not.  As a
   pointer, a register needs to have a page register tacked onto the front.
   An alternate way to do this would be to have gcc output different register
   numbers for the pointer & non-pointer form of the register.  But, it
   doesn't, so we're stuck with this.  */

      if (TYPE_CODE (type) == TYPE_CODE_PTR
	  && len > 2)
	{
	  int page_regnum;

	  switch (regnum)
	    {
	    case R0_REGNUM:
	    case R1_REGNUM:
	    case R2_REGNUM:
	    case R3_REGNUM:
	      page_regnum = SEG_D_REGNUM;
	      break;
	    case R4_REGNUM:
	    case R5_REGNUM:
	      page_regnum = SEG_E_REGNUM;
	      break;
	    case R6_REGNUM:
	    case R7_REGNUM:
	      page_regnum = SEG_T_REGNUM;
	      break;
	    }

	  value_bytes[0] = 0;
	  get_saved_register (value_bytes + 1,
			      &optim,
			      &addr,
			      frame,
			      page_regnum,
			      &lval);

	  if (register_cached (page_regnum) == -1)
	    return NULL;	/* register value not available */

	  if (lval == lval_register)
	    reg_stor++;
	  else
	    mem_stor++;
	  first_addr = addr;
	  last_addr = addr;

	  get_saved_register (value_bytes + 2,
			      &optim,
			      &addr,
			      frame,
			      regnum,
			      &lval);

	  if (register_cached (regnum) == -1)
	    return NULL;	/* register value not available */

	  if (lval == lval_register)
	    reg_stor++;
	  else
	    {
	      mem_stor++;
	      mem_tracking = mem_tracking && (addr == last_addr);
	    }
	  last_addr = addr;
	}
      else
#endif /* GDB_TARGET_IS_H8500 */
@


1.43
log
@2003-01-06  Andrew Cagney  <cagney@@redhat.com>

	* MAINTAINERS (Target Instruction Set Architectures): Update
	arm-elf.  Can be built with -Werror, has been multiarched.

	* value.h (unpack_long): Make buffer parameter constant.
	(unpack_double, unpack_pointer, unpack_field_as_long): Ditto.
	* scm-lang.h (scm_parse): Ditto.
	* defs.h (extract_typed_address, extract_address): Ditto.
	(extract_long_unsigned_integer): Ditto.
	* inferior.h (unsigned_pointer_to_address): Ditto.
	(signed_pointer_to_address): Ditto.
	* gdbarch.sh (POINTER_TO_ADDRESS): Ditto.
	* gdbarch.h, gdbarch.c: Regenerate.
	* findvar.c (extract_long_unsigned_integer): Update.
	(extract_address): Update.
	(extract_typed_address): Update.
	(unsigned_pointer_to_address): Update.
	* values.c (unpack_long): Update.
	(unpack_double): Update.
	(unpack_pointer): Update.
	(unpack_field_as_long): Update.
	* d10v-tdep.c (d10v_pointer_to_address): Update.
	* avr-tdep.c (avr_pointer_to_address): Update.
	* scm-lang.c (scm_unpack): Update.
	* findvar.c (signed_pointer_to_address): Update.
@
text
@d2 4
a5 3
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.42
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d118 1
a118 1
extract_long_unsigned_integer (void *addr, int orig_len, LONGEST *pval)
d176 1
a176 1
extract_address (void *addr, int len)
d187 1
a187 1
extract_typed_address (void *buf, struct type *type)
d350 1
a350 1
unsigned_pointer_to_address (struct type *type, void *buf)
d356 1
a356 1
signed_pointer_to_address (struct type *type, void *buf)
@


1.41
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@d306 1
a306 1
    return value_of_builtin_reg (regnum, selected_frame);
d421 1
a421 1
   If FRAME is NULL, use the selected_frame.  */
d438 1
a438 1
    frame = selected_frame;
@


1.40
log
@* findvar.c (read_var_value): Doc fix.
@
text
@d789 1
a789 1
	  VALUE_FRAME (v) = FRAME_FP (frame);
@


1.39
log
@2002-11-11  Elena Zannoni  <ezannoni@@redhat.com>

        * findvar.c (read_var_value): Reenable TLS code.

2002-11-11  Elena Zannoni  <ezannoni@@redhat.com>
            Jim Blandy  <jimb@@redhat.com>

	* gdb_thread_db.h (enum): Add TD_NOTALLOC.
	* target.c (update_current_target): Add
	to_get_thread_local_address.
	* target.h (to_get_thread_local_address): Export.
	(target_get_thread_local_address): Define.
	(target_get_thread_local_address_p): Define.
	* thread-db.c: Include solib-svr4.h.
	(td_thr_tls_get_addr_p): Define.
	(thread_db_load): Get a pointer to td_thr_tls_get_addr.
	(thread_db_get_thread_local_address): New function.
	(init_thread_db_ops): Initialize to_get_thread_local_address.
	* configure.in: Add test for TD_NOTALLOC in thread_db.h.
	* configure: Regenerate.
	* config.in: Regenerate.
@
text
@a546 3
        /* We want to let the target / ABI-specific code construct
           this value for us, so we need to dispose of the value
           allocated for us above.  */
@


1.38
log
@2002-10-21  Elena Zannoni  <ezannoni@@redhat.com>

	* findvar.c (read_var_value): Temporarily disable TLS code, until
	complete TLS support is added.
@
text
@a546 5
#if 0
	/* FIXME: ezannoni 2002-10-21: Temporarly disable the code
           below, until the rest of the TLS support code is checked
           in.  */

a557 1
#endif
@


1.37
log
@2002-10-21  Jim Blandy  <jimb@@redhat.com>
	    Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (address_class): Re-add LOC_THREAD_LOCAL_STATIC
	for thread local storage locations.
	(struct symbol): Add objfile field.
	(SYMBOL_OBJFILE): Define.
	* dwarf2read.c (is_thread_local): New static variable.
	(new_symbol): If variable is in thread local fill in address class
	and objfile appropriately.
	(decode_locdesc): Recognize and handle DW_OP_GNU_push_tls_address
	stack operation.
	* printcmd.c (address_info): Print the information for thread
	local storage variable.
	* findvar.c (read_var_value): In case of thread local variable,
	defer to the target vector code to compute address.
@
text
@d547 5
d563 1
@


1.36
log
@2002-10-21  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (address_class):  Rename
	LOC_THREAD_LOCAL_STATIC to LOC_HP_THREAD_LOCAL_STATIC.
	* hpread.c (hpread_process_one_debug_symbol): Ditto.
	* printcmd.c (address_info): Ditto.
	* findvar.c (symbol_read_needs_frame, read_var_value): Ditto.
@
text
@d545 17
@


1.35
log
@2002-07-24  Andrew Cagney  <cagney@@redhat.com>
* findvar.c (extract_unsigned_integer): Make `addr' parameter
constant.  Same for local pointer variables.
(extract_signed_integer): Ditto.
* defs.h (extract_unsigned_integer): Update.
(extract_signed_integer): Update.
@
text
@d394 1
a394 1
    case LOC_THREAD_LOCAL_STATIC:
d532 1
a532 1
    case LOC_THREAD_LOCAL_STATIC:
@


1.35.10.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d394 1
a394 1
    case LOC_HP_THREAD_LOCAL_STATIC:
d532 1
a532 1
    case LOC_HP_THREAD_LOCAL_STATIC:
a542 23
      }

    case LOC_THREAD_LOCAL_STATIC:
      {
#if 0
	/* FIXME: ezannoni 2002-10-21: Temporarly disable the code
           below, until the rest of the TLS support code is checked
           in.  */

        /* We want to let the target / ABI-specific code construct
           this value for us, so we need to dispose of the value
           allocated for us above.  */
        if (target_get_thread_local_address_p ())
          addr = target_get_thread_local_address (inferior_ptid,
                                                  SYMBOL_OBJFILE (var),
                                                  SYMBOL_VALUE_ADDRESS (var));
        /* It wouldn't be wrong here to try a gdbarch method, too;
           finding TLS is an ABI-specific thing.  But we don't do that
           yet.  */
        else
#endif
          error ("Cannot find thread-local variables on this target");
        break;
@


1.35.10.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 3
a4 4

   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2003 Free Software
   Foundation, Inc.
d36 1
a36 2
#include "user-regs.h"
#include "block.h"
d118 1
a118 1
extract_long_unsigned_integer (const void *addr, int orig_len, LONGEST *pval)
d162 22
d187 1
a187 1
extract_typed_address (const void *buf, struct type *type)
d253 18
d289 1
a289 1
   determined by register_type().
d300 1
a300 2
  int realnum;
  char raw_buffer[MAX_REGISTER_SIZE];
d303 1
a303 1
  /* User registers lie completly outside of the range of normal
d306 1
a306 1
    return value_of_user_reg (regnum, frame);
d308 2
a309 1
  frame_register (frame, regnum, &optim, &lval, &addr, &realnum, raw_buffer);
d321 1
a321 1
  reg_val = allocate_value (register_type (current_gdbarch, regnum));
d325 1
a325 1
  if (DEPRECATED_REGISTER_CONVERTIBLE (regnum))
d327 2
a328 2
      DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL (regnum, register_type (current_gdbarch, regnum),
					      raw_buffer, VALUE_CONTENTS_RAW (reg_val));
d330 1
a330 1
  else if (DEPRECATED_REGISTER_RAW_SIZE (regnum) == DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum))
d332 1
a332 1
	    DEPRECATED_REGISTER_RAW_SIZE (regnum));
d338 2
a339 2
		    DEPRECATED_REGISTER_RAW_SIZE (regnum),
		    DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
d350 1
a350 1
unsigned_pointer_to_address (struct type *type, const void *buf)
d352 1
a352 1
  return extract_unsigned_integer (buf, TYPE_LENGTH (type));
d356 1
a356 1
signed_pointer_to_address (struct type *type, const void *buf)
d366 1
a366 1
  store_unsigned_integer (buf, TYPE_LENGTH (type), addr);
a384 8
    case LOC_COMPUTED:
    case LOC_COMPUTED_ARG:
      {
	struct location_funcs *symfuncs = SYMBOL_LOCATION_FUNCS (sym);
	return (symfuncs->read_needs_frame) (sym);
      }
      break;

d421 1
a421 1
   If FRAME is NULL, use the deprecated_selected_frame.  */
d424 1
a424 1
read_var_value (struct symbol *var, struct frame_info *frame)
d426 1
a426 1
  struct value *v;
d429 1
a429 1
  int len;
a436 3

  /* FIXME drow/2003-09-06: this call to the selected frame should be
     pushed upwards to the callers.  */
d438 1
a438 1
    frame = deprecated_safe_get_selected_frame ();
d501 1
a501 1
      addr = get_frame_args_address (frame);
d513 1
a513 1
	argref = get_frame_args_address (frame);
d526 1
a526 1
      addr = get_frame_locals_address (frame);
d545 23
a614 12
    case LOC_COMPUTED:
    case LOC_COMPUTED_ARG:
      {
	struct location_funcs *funcs = SYMBOL_LOCATION_FUNCS (var);

	if (frame == 0 && (funcs->read_needs_frame) (var))
	  return 0;
	return (funcs->read_variable) (var, frame);

      }
      break;

d619 1
a619 1
	msym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (var), NULL, NULL);
d654 3
a656 1
  struct gdbarch *gdbarch = get_frame_arch (frame);
d658 6
d665 3
d669 9
a677 15
  if (CONVERT_REGISTER_P (regnum, type))
    {
      /* The ISA/ABI need to something weird when obtaining the
         specified value from this register.  It might need to
         re-order non-adjacent, starting with REGNUM (see MIPS and
         i386).  It might need to convert the [float] register into
         the corresponding [integer] type (see Alpha).  The assumption
         is that REGISTER_TO_VALUE populates the entire value
         including the location.  */
      REGISTER_TO_VALUE (frame, regnum, type, VALUE_CONTENTS_RAW (v));
      VALUE_LVAL (v) = lval_reg_frame_relative;
      VALUE_FRAME_ID (v) = get_frame_id (frame);
      VALUE_FRAME_REGNUM (v) = regnum;
    }
  else
d679 2
d686 2
a687 5
      int first_realnum = regnum;
      int len = TYPE_LENGTH (type);
      int value_bytes_copied;
      int optimized = 0;
      char *value_bytes = (char *) alloca (len + MAX_REGISTER_SIZE);
d690 15
a704 16
      for (local_regnum = regnum, value_bytes_copied = 0;
	   value_bytes_copied < len;
	   (value_bytes_copied += DEPRECATED_REGISTER_RAW_SIZE (local_regnum),
	    ++local_regnum))
	{
	  int realnum;
	  int optim;
	  enum lval_type lval;
	  CORE_ADDR addr;
	  frame_register (frame, local_regnum, &optim, &lval, &addr,
			  &realnum, value_bytes + value_bytes_copied);
	  optimized += optim;
	  if (register_cached (local_regnum) == -1)
	    return NULL;	/* register value not available */
	  
	  if (regnum == local_regnum)
d706 14
a719 2
	      first_addr = addr;
	      first_realnum = realnum;
d721 29
d755 1
a755 4
	      
	      mem_tracking = (mem_tracking
			      && (regnum == local_regnum
				  || addr == last_addr));
d759 33
a791 5
      
      /* FIXME: cagney/2003-06-04: Shouldn't this always use
         lval_reg_frame_relative?  If it doesn't and the register's
         location changes (say after a resume) then this value is
         going to have wrong information.  */
d798 1
a798 1
	  VALUE_FRAME_ID (v) = get_frame_id (frame);
a809 1
	  VALUE_REGNO (v) = first_realnum;
d814 3
a816 3
      
      VALUE_OPTIMIZED_OUT (v) = optimized;
      
d818 1
a818 1
         an integral number of registers.  Otherwise, you need to do
d821 43
a863 7
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && len < DEPRECATED_REGISTER_RAW_SIZE (regnum))
	/* Big-endian, and we want less than full size.  */
	VALUE_OFFSET (v) = DEPRECATED_REGISTER_RAW_SIZE (regnum) - len;
      else
	VALUE_OFFSET (v) = 0;
      memcpy (VALUE_CONTENTS_RAW (v), value_bytes + VALUE_OFFSET (v), len);
d865 1
a867 1

d875 1
a875 1
locate_var_value (struct symbol *var, struct frame_info *frame)
d886 1
a886 1
    error ("Address of \"%s\" is unknown.", SYMBOL_PRINT_NAME (var));
d907 1
a907 1
            SYMBOL_PRINT_NAME (var), 
d916 1
a916 1
            SYMBOL_PRINT_NAME (var), 
d922 1
a922 1
	     SYMBOL_PRINT_NAME (var));
@


1.35.10.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d349 5
a353 6
      /* FIXME: cagney/2004-01-26: It should be possible to
	 unconditionally call the SYMBOL_OPS method when available.
	 Unfortunately DWARF 2 stores the frame-base (instead of the
	 function) location in a function's symbol.  Oops!  For the
	 moment enable this when/where applicable.  */
      return SYMBOL_OPS (sym)->read_needs_frame (sym);
d567 9
a575 8
      /* FIXME: cagney/2004-01-26: It should be possible to
	 unconditionally call the SYMBOL_OPS method when available.
	 Unfortunately DWARF 2 stores the frame-base (instead of the
	 function) location in a function's symbol.  Oops!  For the
	 moment enable this when/where applicable.  */
      if (frame == 0 && SYMBOL_OPS (var)->read_needs_frame (var))
	return 0;
      return SYMBOL_OPS (var)->read_variable (var, frame);
@


1.35.8.1
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a24 1
#include "block.h"
@


1.35.8.2
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d395 1
a395 1
    case LOC_HP_THREAD_LOCAL_STATIC:
d533 1
a533 1
    case LOC_HP_THREAD_LOCAL_STATIC:
a543 23
      }

    case LOC_THREAD_LOCAL_STATIC:
      {
#if 0
	/* FIXME: ezannoni 2002-10-21: Temporarly disable the code
           below, until the rest of the TLS support code is checked
           in.  */

        /* We want to let the target / ABI-specific code construct
           this value for us, so we need to dispose of the value
           allocated for us above.  */
        if (target_get_thread_local_address_p ())
          addr = target_get_thread_local_address (inferior_ptid,
                                                  SYMBOL_OBJFILE (var),
                                                  SYMBOL_VALUE_ADDRESS (var));
        /* It wouldn't be wrong here to try a gdbarch method, too;
           finding TLS is an ABI-specific thing.  But we don't do that
           yet.  */
        else
#endif
          error ("Cannot find thread-local variables on this target");
        break;
@


1.35.8.3
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d548 8
d564 1
@


1.35.8.4
log
@2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (examine_compound_token): Rewrite as switch
	statement, and add FIXME comment.
	* frame.h: Make arg of block_innermost_frame const.
	* blockframe.c (block_innermost_frame): Make arg const.
	* block.h: Make args to block_function, contained_in const.
	* block.c (block_function): Make arg const.
	(contained_in): Ditto.
	* value.h: Make arg of symbol_read_needs_frame const.
	* findvar.c (symbol_read_needs_frame): Make arg const.
	* symtab.h: Make first arg of symbol_demangled_name const.
	* symtab.c (symbol_demangled_name): Make arg const.
	* value.h: Make first arg of read_var_value const.
	* findvar.c (read_var_value): Make first arg const.
	* Makefile.in (valops.o): Depend on cp_support_h.
	* valops.c: #include "cp-support.h"
	* symtab.h: Add FIXME about name of namespace_enum.
	Add opaque declaration of struct using_direct_node.
	* symtab.c (lookup_symbol_namespace): Make extern; rename args.
	* symtab.h: Declare lookup_symbol_namespace.
	* valops.c (value_struct_elt_for_reference): Make 'name' a const
	char *.
	(value_namespace_elt): New function.
	* expprint.c (print_subexp): Ditto.
	(dump_subexp): Ditto.
	* parse.c (length_of_subexp): Ditto.
	(prefixify_subexp): Ditto.
	* expression.h: Update comment to reflect the block in OP_SCOPE.
	* c-exp.y: Set block in OP_SCOPE expression.
	* jv-exp.y (push_qualified_expression_name): Put a NULL block in
	OP_SCOPE expression.
	* objc-exp.y: Ditto.
	* p-exp.y: Ditto.
	* eval.c (evaluate_subexp_standard): Handle OP_SCOPE via
	value_aggregate_elt.
	* value.h: Add declaration for value_aggregate_elt; delete
	declaration for value_struct_elt_for_reference.
	* valops.c (value_aggregate_elt): New function.
	(value_struct_elt_for_reference): Make static.  Don't check type
	of curtype.
	* c-exp.y: Accept TYPE_CODE_NAMESPACE in qualified_name.
	* cp-support.c (cp_check_namespace_symbol): Set TYPE_NAME (type).

2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change a couple of tests to not use
	single quotes.
@
text
@d380 1
a380 1
symbol_read_needs_frame (const struct symbol *sym)
d425 1
a425 1
read_var_value (const struct symbol *var, struct frame_info *frame)
@


1.35.8.5
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@d878 1
a878 1
    error ("Address of \"%s\" is unknown.", SYMBOL_PRINT_NAME (var));
d899 1
a899 1
            SYMBOL_PRINT_NAME (var), 
d908 1
a908 1
            SYMBOL_PRINT_NAME (var), 
d914 1
a914 1
	     SYMBOL_PRINT_NAME (var));
@


1.35.8.6
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d307 1
a307 1
    return value_of_builtin_reg (regnum, deprecated_selected_frame);
d422 1
a422 1
   If FRAME is NULL, use the deprecated_selected_frame.  */
d439 1
a439 1
    frame = deprecated_selected_frame;
d790 1
a790 1
	  VALUE_FRAME (v) = get_frame_base (frame);
@


1.35.8.7
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 3
a4 4

   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2003 Free Software
   Foundation, Inc.
d119 1
a119 1
extract_long_unsigned_integer (const void *addr, int orig_len, LONGEST *pval)
d177 1
a177 1
extract_address (const void *addr, int len)
d188 1
a188 1
extract_typed_address (const void *buf, struct type *type)
d351 1
a351 1
unsigned_pointer_to_address (struct type *type, const void *buf)
d357 1
a357 1
signed_pointer_to_address (struct type *type, const void *buf)
d666 2
a667 4
#if 0
      // OBSOLETE #ifdef GDB_TARGET_IS_H8500
      // OBSOLETE       || TYPE_CODE (type) == TYPE_CODE_PTR
      // OBSOLETE #endif
d683 70
a752 72
#if 0
      // OBSOLETE #ifdef GDB_TARGET_IS_H8500
      // OBSOLETE /* This piece of hideosity is required because the H8500 treats registers
      // OBSOLETE    differently depending upon whether they are used as pointers or not.  As a
      // OBSOLETE    pointer, a register needs to have a page register tacked onto the front.
      // OBSOLETE    An alternate way to do this would be to have gcc output different register
      // OBSOLETE    numbers for the pointer & non-pointer form of the register.  But, it
      // OBSOLETE    doesn't, so we're stuck with this.  */
      // OBSOLETE 
      // OBSOLETE       if (TYPE_CODE (type) == TYPE_CODE_PTR
      // OBSOLETE 	  && len > 2)
      // OBSOLETE 	{
      // OBSOLETE 	  int page_regnum;
      // OBSOLETE 
      // OBSOLETE 	  switch (regnum)
      // OBSOLETE 	    {
      // OBSOLETE 	    case R0_REGNUM:
      // OBSOLETE 	    case R1_REGNUM:
      // OBSOLETE 	    case R2_REGNUM:
      // OBSOLETE 	    case R3_REGNUM:
      // OBSOLETE 	      page_regnum = SEG_D_REGNUM;
      // OBSOLETE 	      break;
      // OBSOLETE 	    case R4_REGNUM:
      // OBSOLETE 	    case R5_REGNUM:
      // OBSOLETE 	      page_regnum = SEG_E_REGNUM;
      // OBSOLETE 	      break;
      // OBSOLETE 	    case R6_REGNUM:
      // OBSOLETE 	    case R7_REGNUM:
      // OBSOLETE 	      page_regnum = SEG_T_REGNUM;
      // OBSOLETE 	      break;
      // OBSOLETE 	    }
      // OBSOLETE 
      // OBSOLETE 	  value_bytes[0] = 0;
      // OBSOLETE 	  get_saved_register (value_bytes + 1,
      // OBSOLETE 			      &optim,
      // OBSOLETE 			      &addr,
      // OBSOLETE 			      frame,
      // OBSOLETE 			      page_regnum,
      // OBSOLETE 			      &lval);
      // OBSOLETE 
      // OBSOLETE 	  if (register_cached (page_regnum) == -1)
      // OBSOLETE 	    return NULL;	/* register value not available */
      // OBSOLETE 
      // OBSOLETE 	  if (lval == lval_register)
      // OBSOLETE 	    reg_stor++;
      // OBSOLETE 	  else
      // OBSOLETE 	    mem_stor++;
      // OBSOLETE 	  first_addr = addr;
      // OBSOLETE 	  last_addr = addr;
      // OBSOLETE 
      // OBSOLETE 	  get_saved_register (value_bytes + 2,
      // OBSOLETE 			      &optim,
      // OBSOLETE 			      &addr,
      // OBSOLETE 			      frame,
      // OBSOLETE 			      regnum,
      // OBSOLETE 			      &lval);
      // OBSOLETE 
      // OBSOLETE 	  if (register_cached (regnum) == -1)
      // OBSOLETE 	    return NULL;	/* register value not available */
      // OBSOLETE 
      // OBSOLETE 	  if (lval == lval_register)
      // OBSOLETE 	    reg_stor++;
      // OBSOLETE 	  else
      // OBSOLETE 	    {
      // OBSOLETE 	      mem_stor++;
      // OBSOLETE 	      mem_tracking = mem_tracking && (addr == last_addr);
      // OBSOLETE 	    }
      // OBSOLETE 	  last_addr = addr;
      // OBSOLETE 	}
      // OBSOLETE       else
      // OBSOLETE #endif /* GDB_TARGET_IS_H8500 */
#endif
@


1.35.8.8
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d26 1
a38 1
#include "block.h"
d291 1
a291 1
   determined by register_type().
d323 1
a323 1
  reg_val = allocate_value (register_type (current_gdbarch, regnum));
d329 1
a329 1
      REGISTER_CONVERT_TO_VIRTUAL (regnum, register_type (current_gdbarch, regnum),
a386 8
    case LOC_COMPUTED:
    case LOC_COMPUTED_ARG:
      {
	struct location_funcs *symfuncs = SYMBOL_LOCATION_FUNCS (sym);
	return (symfuncs->read_needs_frame) (sym);
      }
      break;

a607 12
    case LOC_COMPUTED:
    case LOC_COMPUTED_ARG:
      {
	struct location_funcs *funcs = SYMBOL_LOCATION_FUNCS (var);

	if (frame == 0 && (funcs->read_needs_frame) (var))
	  return 0;
	return (funcs->read_variable) (var, frame);

      }
      break;

d612 1
a612 1
	msym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (var), NULL, NULL);
@


1.35.8.9
log
@2003-03-07  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Replace uses of
	SYMBOL_MATCHES_NATURAL_NAME by equivalent uses of
	SYMBOL_NATURAL_NAME, strcmp_iw.
	* symtab.h (SYMBOL_MATCHES_NATURAL_NAME): Delete.
	* minsyms.c (lookup_minimal_symbol_linkage): Make static.
	(lookup_minimal_symbol_natural): Ditto.
	(lookup_minimal_symbol): Only search on linkage names; rename
	first argument to 'linkage_name'.
	(lookup_minimal_symbol_linkage): Delete.
	(lookup_minimal_symbol_natural): Delete.
	(add_minsym_to_demangled_hash_table): Go back to using
	SYMBOL_DEMANGLED_NAME instead of SYMBOL_NATURAL_NAME.
	(lookup_minimal_symbol_aux): Don't use
	SYMBOL_MATCHES_NATURAL_NAME: do a strcmp_iw on
	SYMBOL_DEMANGLED_NAME instead.  Add comment.
	(build_minimal_symbol_hash_tables): Go back to only adding to
	demangled has table if SYMBOL_DEMANGLED_NAME is non-NULL.
	* symtab.h: Delete declarations for lookup_minimal_symbol_linkage
	and lookup_minimal_symbol_natural.
	* valops.c (find_function_in_inferior): Use lookup_symbol_linkage
	instead of lookup_symbol.  Change comment.
	* remote.c (remote_check_symbols): Use
	lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol, but add FIXME comment as well.
	* objc-lang.c: Ditto.
	* c-exp.y: Use lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol.
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y (push_expression_name): Ditto.
	* f-exp.y: Ditto.
	* printcmd.c (address_info): Ditto.
	* symtab.h: Declare lookup_minimal_symbol_linkage_or_natural.
	* minsyms.c (lookup_minimal_symbol_linkage_or_natural): New.
	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME instead of
	DEPRECATED_SYMBOL_NAME.
	* tracepoint.c (scope_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* sol-thread.c (info_cb): Ditto.
	* printcmd.c (address_info): Ditto.
	* hppa-tdep.c (hppa_fix_call_dummy): Ditto.
	(hppa_in_solib_call_trampoline): Ditto.
	* findvar.c (read_var_value): Ditto.
@
text
@d632 1
a632 1
	msym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (var), NULL, NULL);
@


1.35.8.10
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a301 1
  int realnum;
d308 1
a308 1
    return value_of_builtin_reg (regnum, frame);
d310 2
a311 1
  frame_register (frame, regnum, &optim, &lval, &addr, &realnum, raw_buffer);
d511 1
a511 1
      addr = get_frame_args_address (frame);
d523 1
a523 1
	argref = get_frame_args_address (frame);
d536 1
a536 1
      addr = get_frame_locals_address (frame);
d783 6
a788 3
	    int realnum;
	    frame_register (frame, local_regnum, &optim, &lval, &addr,
			    &realnum, value_bytes + value_bytes_copied);
d854 1
a854 4
  {
    int realnum;
    frame_register (frame, regnum, &optim, &lval, &addr, &realnum, raw_buffer);
  }
@


1.35.8.11
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d255 18
d303 1
a303 1
  char raw_buffer[MAX_REGISTER_SIZE];
d354 1
a354 1
  return extract_unsigned_integer (buf, TYPE_LENGTH (type));
d368 1
a368 1
  store_unsigned_integer (buf, TYPE_LENGTH (type), addr);
d667 1
a667 1
  char raw_buffer[MAX_REGISTER_SIZE];
d702 1
a702 1
      value_bytes = (char *) alloca (len + MAX_REGISTER_SIZE);
@


1.35.8.12
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d164 22
d309 1
a309 1
  if (DEPRECATED_REGISTER_CONVERTIBLE (regnum))
d311 2
a312 2
      DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL (regnum, register_type (current_gdbarch, regnum),
					      raw_buffer, VALUE_CONTENTS_RAW (reg_val));
d649 3
a651 1
  struct gdbarch *gdbarch = get_frame_arch (frame);
d653 6
d660 1
d662 13
a674 15
  if (CONVERT_REGISTER_P (regnum, type))
    {
      /* The ISA/ABI need to something weird when obtaining the
         specified value from this register.  It might need to
         re-order non-adjacent, starting with REGNUM (see MIPS and
         i386).  It might need to convert the [float] register into
         the corresponding [integer] type (see Alpha).  The assumption
         is that REGISTER_TO_VALUE populates the entire value
         including the location.  */
      REGISTER_TO_VALUE (frame, regnum, type, VALUE_CONTENTS_RAW (v));
      VALUE_LVAL (v) = lval_reg_frame_relative;
      VALUE_FRAME_ID (v) = get_frame_id (frame);
      VALUE_FRAME_REGNUM (v) = regnum;
    }
  else
d676 2
d683 2
a684 5
      int first_realnum = regnum;
      int len = TYPE_LENGTH (type);
      int value_bytes_copied;
      int optimized = 0;
      char *value_bytes = (char *) alloca (len + MAX_REGISTER_SIZE);
d687 86
a772 17
      for (local_regnum = regnum, value_bytes_copied = 0;
	   value_bytes_copied < len;
	   (value_bytes_copied += REGISTER_RAW_SIZE (local_regnum),
	    ++local_regnum))
	{
	  int realnum;
	  int optim;
	  enum lval_type lval;
	  CORE_ADDR addr;
	  frame_register (frame, local_regnum, &optim, &lval, &addr,
			  &realnum, value_bytes + value_bytes_copied);
	  optimized += optim;
	  if (register_cached (local_regnum) == -1)
	    return NULL;	/* register value not available */
	  
	  if (regnum == local_regnum)
	    {
d774 14
a787 19
	      first_realnum = realnum;
	    }
	  if (lval == lval_register)
	    reg_stor++;
	  else
	    {
	      mem_stor++;
	      
	      mem_tracking = (mem_tracking
			      && (regnum == local_regnum
				  || addr == last_addr));
	    }
	  last_addr = addr;
	}
      
      /* FIXME: cagney/2003-06-04: Shouldn't this always use
         lval_reg_frame_relative?  If it doesn't and the register's
         location changes (say after a resume) then this value is
         going to have wrong information.  */
d794 1
a794 1
	  VALUE_FRAME_ID (v) = get_frame_id (frame);
a805 1
	  VALUE_REGNO (v) = first_realnum;
d810 3
a812 3
      
      VALUE_OPTIMIZED_OUT (v) = optimized;
      
d814 1
a814 1
         an integral number of registers.  Otherwise, you need to do
d817 46
a862 7
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && len < REGISTER_RAW_SIZE (regnum))
	/* Big-endian, and we want less than full size.  */
	VALUE_OFFSET (v) = REGISTER_RAW_SIZE (regnum) - len;
      else
	VALUE_OFFSET (v) = 0;
      memcpy (VALUE_CONTENTS_RAW (v), value_bytes + VALUE_OFFSET (v), len);
d864 1
a866 1

@


1.35.8.13
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d37 1
a37 1
#include "user-regs.h"
d266 1
a266 1
  /* User registers lie completly outside of the range of normal
d269 1
a269 1
    return value_of_user_reg (regnum, frame);
d513 14
@


1.35.8.14
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d396 1
a396 1
  struct value *v;
d399 1
a399 1
  int len;
a406 3

  /* FIXME drow/2003-09-06: this call to the selected frame should be
     pushed upwards to the callers.  */
d408 1
a408 1
    frame = deprecated_safe_get_selected_frame ();
d730 1
a730 1
locate_var_value (struct symbol *var, struct frame_info *frame)
@


1.35.8.15
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d292 1
a292 1
  else if (DEPRECATED_REGISTER_RAW_SIZE (regnum) == DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum))
d294 1
a294 1
	    DEPRECATED_REGISTER_RAW_SIZE (regnum));
d300 2
a301 2
		    DEPRECATED_REGISTER_RAW_SIZE (regnum),
		    DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
d650 1
a650 1
	   (value_bytes_copied += DEPRECATED_REGISTER_RAW_SIZE (local_regnum),
d716 1
a716 1
	  && len < DEPRECATED_REGISTER_RAW_SIZE (regnum))
d718 1
a718 1
	VALUE_OFFSET (v) = DEPRECATED_REGISTER_RAW_SIZE (regnum) - len;
@


1.34
log
@* regcache.c (register_valid): Revise comments refering to "Not
available" and "unavailable".
* frame.c (frame_register_read): Ditto.
* findvar.c (value_of_register): Ditto.
@
text
@d50 1
a50 1
extract_signed_integer (void *addr, int len)
d53 3
a55 3
  unsigned char *p;
  unsigned char *startaddr = (unsigned char *) addr;
  unsigned char *endaddr = startaddr + len;
d84 1
a84 1
extract_unsigned_integer (void *addr, int len)
d87 3
a89 3
  unsigned char *p;
  unsigned char *startaddr = (unsigned char *) addr;
  unsigned char *endaddr = startaddr + len;
@


1.34.4.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d50 1
a50 1
extract_signed_integer (const void *addr, int len)
d53 3
a55 3
  const unsigned char *p;
  const unsigned char *startaddr = addr;
  const unsigned char *endaddr = startaddr + len;
d84 1
a84 1
extract_unsigned_integer (const void *addr, int len)
d87 3
a89 3
  const unsigned char *p;
  const unsigned char *startaddr = addr;
  const unsigned char *endaddr = startaddr + len;
@


1.34.4.2
log
@merge from mainline
@
text
@d394 1
a394 1
    case LOC_HP_THREAD_LOCAL_STATIC:
d532 1
a532 1
    case LOC_HP_THREAD_LOCAL_STATIC:
a542 23
      }

    case LOC_THREAD_LOCAL_STATIC:
      {
#if 0
	/* FIXME: ezannoni 2002-10-21: Temporarly disable the code
           below, until the rest of the TLS support code is checked
           in.  */

        /* We want to let the target / ABI-specific code construct
           this value for us, so we need to dispose of the value
           allocated for us above.  */
        if (target_get_thread_local_address_p ())
          addr = target_get_thread_local_address (inferior_ptid,
                                                  SYMBOL_OBJFILE (var),
                                                  SYMBOL_VALUE_ADDRESS (var));
        /* It wouldn't be wrong here to try a gdbarch method, too;
           finding TLS is an ABI-specific thing.  But we don't do that
           yet.  */
        else
#endif
          error ("Cannot find thread-local variables on this target");
        break;
@


1.33
log
@* arch-utils.h (legacy_register_to_value): Declare.
(legacy_value_to_register): Declare.
(legacy_convert_register_p): Declare.
* arch-utils.c (legacy_register_to_value): New function.
(legacy_value_to_register): New function.
(legacy_convert_register_p): New function.

* gdbarch.sh (REGISTER_TO_VALUE): Define.
(VALUE_TO_REGISTER): Define.
(CONVERT_REGISTER_P): Define.
* gdbarch.h, gdbarch.c: Regenerate.

* valops.c (value_assign): Use CONVERT_REGISTER_P and
VALUE_TO_REGISTER.
* findvar.c (value_from_register): Use REGISTER_TO_VALUE and
CONVERT_REGISTER_P.

* gdbint.texinfo (Target Architecture Definition): Document
REGISTER_TO_VALUE and VALUE_TO_REGISTER and CONVERT_REGISTER_P.
(Target Architecture Definition): Revise section `Using Different
Register and Memory Data Representations'.  Add section `Raw and
Virtual Register Representations'.
@
text
@d311 7
@


1.32
log
@* findvar.c (extract_signed_integer): Cast printf argument
to suppress format warning.
(extract_unsigned_integer): Likewise.
* infcmd.c (registers_info): Likewise.
* top.c (get_prompt_1): Likewise.
* valops.c (value_assign): Likewise.
* valprint.c (print_decimal): Likewise.
@
text
@d816 2
a817 1
  /* Convert raw data to virtual format if necessary.  */
d819 1
a819 1
  if (REGISTER_CONVERTIBLE (regnum))
d821 1
a821 2
      REGISTER_CONVERT_TO_VIRTUAL (regnum, type,
				   raw_buffer, VALUE_CONTENTS_RAW (v));
@


1.31
log
@* findvar.c: Include "builtin-regs.h".
(value_of_register): Call value_of_builtin_reg when applicable.
* parse.c: Include "builtin-regs.h" and "gdb_assert.h".
(target_map_name_to_register): Call
builtin_reg_map_name_to_regnum.
* Makefile.in (SFILES): Add builtin-regs.c and std-regs.c.
(COMMON_OBS): Add builtin-regs.o and std-regs.o.
(builtin_regs_h): Define.
(builtin-regs.o): New target.
(findvar.o): Add $(builtin_regs_h).
* builtin-regs.c, builtin-regs.h: New files.
* std-regs.c: New file.
Partial fix for PR gdb/251.
@
text
@d60 1
a60 1
	   sizeof (LONGEST));
d94 1
a94 1
	   sizeof (ULONGEST));
@


1.30
log
@gdb/ChangeLog:
* stack.c (get_selected_block): Add new argument `addr_in_block',
used to return the exact code address we used to select the block,
not just the block.
* blockframe.c (get_frame_block, get_current_block): Same.
* frame.h (get_frame_block, get_current_block,
get_selected_block): Update declarations.
* linespec.c, stack.c, blockframe.c, breakpoint.c, findvar.c,
linespec.c, varobj.c, printcmd.c, symtab.c: Callers changed.

gdb/mi/ChangeLog:
* mi-cmd-stack.c (list_args_or_locals): Pass new arg to
get_frame_block.  (See entry in gdb/ChangeLog.)
@
text
@d36 1
d302 5
@


1.29
log
@* eval.c (evaluate_subexp_standard): Pass ``selected_frame'' to
value_of_register.
* findvar.c (value_of_register): Add ``frame'' parameter.  Pass to
get_saved_register.
* value.h (value_of_register): Update.
@
text
@d554 1
a554 1
	b = get_frame_block (frame);
@


1.28
log
@* gdbarch.sh (TARGET_LONG_DOUBLE_FORMAT): Default to
default_double_format.
* gdbarch.h, gdbarch.c: Re-generate.
* findvar.c (floatformat_unknown): Delete variable definition.
* doublest.h (floatformat_unknown): Delete variable declaration.
@
text
@d286 3
a288 3
/* Return a `value' with the contents of register REGNUM
   in its virtual format, with the type specified by
   REGISTER_VIRTUAL_TYPE.  
d290 2
a291 2
   NOTE: returns NULL if register value is not available.
   Caller will check return value or die!  */
d294 1
a294 1
value_of_register (int regnum)
d303 1
a303 1
		      selected_frame, regnum, &lval);
@


1.27
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@a36 6
/* This is used to indicate that we don't know the format of the floating point
   number.  Typically, this is useful for native ports, where the actual format
   is irrelevant, since no conversions will be taking place.  */

const struct floatformat floatformat_unknown;

@


1.26
log
@2001-11-30  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* findvar.c (locate_var_value): Specify in which register a register
	variable is stored.
@
text
@d69 1
a69 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d104 1
a104 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d129 1
a129 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d213 1
a213 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d240 1
a240 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d827 1
a827 1
      if (TARGET_BYTE_ORDER == BIG_ENDIAN && len < REGISTER_RAW_SIZE (regnum))
@


1.25
log
@s/value_ptr/struct value */
@
text
@d32 1
d873 8
d882 6
a887 2
      error ("Address requested for identifier \"%s\" which is in a register.",
	     SYMBOL_SOURCE_NAME (var));
@


1.24
log
@* value.h (value_as_address): Rename value_as_pointer.
* eval.c, findvar.c, gnu-v2-abi.c, gnu-v3-abi.c, jv-lang.c,
jv-valprint.c, printcmd.c, stack.c, top.c, valarith.c, valops.c,
values.c: Update.
@
text
@d298 1
a298 1
value_ptr
d303 1
a303 1
  register value_ptr reg_val;
d415 1
a415 1
value_ptr
d418 1
a418 1
  register value_ptr v;
d526 1
a526 1
	value_ptr regval;
d555 1
a555 1
	value_ptr regval;
d620 1
a620 1
value_ptr
d626 1
a626 1
  value_ptr v = allocate_value (type);
d843 1
a843 1
value_ptr
d848 1
a848 1
  value_ptr lazy_value;
d860 1
a860 1
      value_ptr val;
@


1.23
log
@* findvar.c (read_var_value): For LOC_INDIRECT and LOC_REF_ARG
convert the pointer into a CORE_ADDRs.
@
text
@d487 1
a487 1
	addr = value_as_pointer (loc);
d510 1
a510 1
	addr = value_as_pointer (ref);
d532 1
a532 1
	addr = value_as_pointer (regval);
d570 1
a570 1
	    addr = value_as_pointer (regval);
@


1.22
log
@* defs.h (HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_LONG_DOUBLE_FORMAT, DOUBLEST)
(floatformat_to_doublest, floatformat_from_doublest)
(floatformat_is_negative, floatformat_is_nan)
(floatformat_mantissa, store_floating)
(extract_floating): Move declaration from here.
* doublest.h: To here.  New file.
* utils.c (get_field, floatformat_to_doublest, put_field)
(ldfrexp, floatformat_from_doublest, floatformat_is_negative)
(floatformat_is_nan, floatformat_mantissa)
(FLOATFORMAT_CHAR_BIT): Move from here.
* doublest.c: To here.  New file.
* findvar.c (store_floating, extract_floating): Move from here.
* doublest.c: To here.
* Makefile.in (SFILES): Add doublest.c.
(COMMON_OBS): Add doublest.o.
(doublest.o): Specify dependencies.
(doublest_h): Define.

* config/m88k/tm-m88k.h: Include "doublest.h".
* config/i960/tm-i960.h: Ditto.
* config/i386/tm-symmetry.h: Ditto.
* rs6000-tdep.c, valarith.c: Ditto.
* valprint.c, stabsread.c, sh-tdep.c: Ditto.
* ia64-tdep.c, i387-tdep.c, i386-tdep.c: Ditto.
* values.c, arm-tdep.c, arm-linux-tdep.c: Ditto.
* alpha-tdep.c, ax.h, expression.h: Ditto.
* sh-tdep.c, parse.c, top.c, value.h: Ditto.

* Makefile.in (arm-tdep.o): Add $(doublest_h).
(i386-tdep.o, i387-tdep.o, ia64-tdep.o): Ditto.
(rs6000-tdep.o, stabsread.o, valarith.o): Ditto.
(values.o, valprint.o, arm-linux-tdep.o): Ditto.
(alpha-tdep.o, ax_h, parse.o, top.o, value_h): Ditto.
(parser_defs_h): Ditto.
(expression_h): Add $(doublest_h) and $(symtab_h).
@
text
@d474 8
a481 5
      /* The import slot does not have a real address in it from the
         dynamic loader (dld.sl on HP-UX), if the target hasn't begun
         execution yet, so check for that. */
      if (!target_has_execution)
	error ("\
d485 4
a488 4
      addr = SYMBOL_VALUE_ADDRESS (var);
      addr = read_memory_unsigned_integer
	(addr, TARGET_PTR_BIT / TARGET_CHAR_BIT);
      break;
d500 13
a512 9
      if (frame == NULL)
	return 0;
      addr = FRAME_ARGS_ADDRESS (frame);
      if (!addr)
	return 0;
      addr += SYMBOL_VALUE (var);
      addr = read_memory_unsigned_integer
	(addr, TARGET_PTR_BIT / TARGET_CHAR_BIT);
      break;
@


1.21
log
@	* findvar.c (read_var_value): Apply value_as_pointer() to
	addresses retrieved from the target for LOC_BASEREG and
	LOC_BASEREG_ARG variables.
@
text
@a290 96

/* Extract a floating-point number from a target-order byte-stream at ADDR.
   Returns the value as type DOUBLEST.

   If the host and target formats agree, we just copy the raw data into the
   appropriate type of variable and return, letting the host increase precision
   as necessary.  Otherwise, we call the conversion routine and let it do the
   dirty work.  */

DOUBLEST
extract_floating (void *addr, int len)
{
  DOUBLEST dretval;

  if (len * TARGET_CHAR_BIT == TARGET_FLOAT_BIT)
    {
      if (HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT)
	{
	  float retval;

	  memcpy (&retval, addr, sizeof (retval));
	  return retval;
	}
      else
	floatformat_to_doublest (TARGET_FLOAT_FORMAT, addr, &dretval);
    }
  else if (len * TARGET_CHAR_BIT == TARGET_DOUBLE_BIT)
    {
      if (HOST_DOUBLE_FORMAT == TARGET_DOUBLE_FORMAT)
	{
	  double retval;

	  memcpy (&retval, addr, sizeof (retval));
	  return retval;
	}
      else
	floatformat_to_doublest (TARGET_DOUBLE_FORMAT, addr, &dretval);
    }
  else if (len * TARGET_CHAR_BIT == TARGET_LONG_DOUBLE_BIT)
    {
      if (HOST_LONG_DOUBLE_FORMAT == TARGET_LONG_DOUBLE_FORMAT)
	{
	  DOUBLEST retval;

	  memcpy (&retval, addr, sizeof (retval));
	  return retval;
	}
      else
	floatformat_to_doublest (TARGET_LONG_DOUBLE_FORMAT, addr, &dretval);
    }
  else
    {
      error ("Can't deal with a floating point number of %d bytes.", len);
    }

  return dretval;
}

void
store_floating (void *addr, int len, DOUBLEST val)
{
  if (len * TARGET_CHAR_BIT == TARGET_FLOAT_BIT)
    {
      if (HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT)
	{
	  float floatval = val;

	  memcpy (addr, &floatval, sizeof (floatval));
	}
      else
	floatformat_from_doublest (TARGET_FLOAT_FORMAT, &val, addr);
    }
  else if (len * TARGET_CHAR_BIT == TARGET_DOUBLE_BIT)
    {
      if (HOST_DOUBLE_FORMAT == TARGET_DOUBLE_FORMAT)
	{
	  double doubleval = val;

	  memcpy (addr, &doubleval, sizeof (doubleval));
	}
      else
	floatformat_from_doublest (TARGET_DOUBLE_FORMAT, &val, addr);
    }
  else if (len * TARGET_CHAR_BIT == TARGET_LONG_DOUBLE_BIT)
    {
      if (HOST_LONG_DOUBLE_FORMAT == TARGET_LONG_DOUBLE_FORMAT)
	memcpy (addr, &val, sizeof (val));
      else
	floatformat_from_doublest (TARGET_LONG_DOUBLE_FORMAT, &val, addr);
    }
  else
    {
      error ("Can't deal with a floating point number of %d bytes.", len);
    }
}

@


1.20
log
@Clean up the D10V port so that GDB and the target program no
longer disagree on how big pointers are.
* findvar.c (value_from_register): Remove special case code for D10V.
* printcmd.c (print_frame_args): Same.
* valops.c (value_at, value_fetch_lazy): Same.
* values.c (unpack_long): Same.
* gdbarch.sh: Changes to effect the following:
* gdbarch.h (GDB_TARGET_IS_D10V, D10V_MAKE_DADDR,
gdbarch_d10v_make_daddr_ftype, gdbarch_d10v_make_daddr,
set_gdbarch_d10v_make_daddr, D10V_MAKE_IADDR,
gdbarch_d10v_make_iaddr_ftype, gdbarch_d10v_make_iaddr,
set_gdbarch_d10v_make_iaddr, D10V_DADDR_P,
gdbarch_d10v_daddr_p_ftype, gdbarch_d10v_daddr_p,
set_gdbarch_d10v_daddr_p, D10V_IADDR_P,
gdbarch_d10v_iaddr_p_ftype, gdbarch_d10v_iaddr_p,
set_gdbarch_d10v_iaddr_p, D10V_CONVERT_DADDR_TO_RAW,
gdbarch_d10v_convert_daddr_to_raw_ftype,
gdbarch_d10v_convert_daddr_to_raw,
set_gdbarch_d10v_convert_daddr_to_raw, D10V_CONVERT_IADDR_TO_RAW,
gdbarch_d10v_convert_iaddr_to_raw_ftype,
gdbarch_d10v_convert_iaddr_to_raw,
set_gdbarch_d10v_convert_iaddr_to_raw): Delete declarations.
* gdbarch.c: Delete the corresponding definitions.
(struct gdbarch): Delete members d10v_make_daddr,
d10v_make_iaddr, d10v_daddr_p, d10v_iaddr_p,
d10v_convert_daddr_to_raw, and d10v_convert_iaddr_to_raw.
(startup_gdbarch): Remove initializers for the above.
(verify_gdbarch, gdbarch_dump): Don't verify or dump them any
more.
* d10v-tdep.c (d10v_register_virtual_type): Rather that
claiming the stack pointer and PC are 32 bits long (which they
aren't), say that the stack pointer is an int16_t, and the
program counter is a function pointer.  This allows the rest
of GDB to make the appropriate conversions between the code
pointer format and real addresses.
(d10v_register_convertible, d10v_register_convert_to_virtual,
d10v_register_convert_to_raw): Delete function; no registers
are convertible now, so we use
generic_register_convertible_not instead.
(d10v_address_to_pointer, d10v_pointer_to_address): New gdbarch
methods.
(d10v_push_arguments, d10v_extract_return_value): Remove special
cases for code and data pointers.
(d10v_gdbarch_init): Set gdbarch_ptr_bit to 16, so that GDB and
the target agree on how large pointers are.  Say that addresses
are 32 bits long.  Register the address_to_pointer and
pointer_to_address conversion functions.  Since no registers are
convertible now, register generic_register_convertible_not as the
gdbarch_register_convertible method instead of
d10v_register_convertible.  Remove registrations for
d10v_register_convert_to_virtual,
d10v_register_convert_to_raw, gdbarch_d10v_make_daddr,
gdbarch_d10v_make_iaddr, gdbarch_d10v_daddr_p,
gdbarch_d10v_iaddr_p, gdbarch_d10v_convert_daddr_to_raw, and
gdbarch_d10v_convert_iaddr_to_raw.
@
text
@a612 9
      {
	char *buf = (char*) alloca (MAX_REGISTER_RAW_SIZE);
	get_saved_register (buf, NULL, NULL, frame, SYMBOL_BASEREG (var),
			    NULL);
	addr = extract_address (buf, REGISTER_RAW_SIZE (SYMBOL_BASEREG (var)));
	addr += SYMBOL_VALUE (var);
	break;
      }

d615 1
a615 1
	char *buf = (char*) alloca (MAX_REGISTER_RAW_SIZE);
d617 5
a621 3
	get_saved_register (buf, NULL, NULL, frame, SYMBOL_BASEREG (var),
			    NULL);
	addr = extract_address (buf, REGISTER_RAW_SIZE (SYMBOL_BASEREG (var)));
@


1.19
log
@Update/correct copyright notices.
@
text
@a731 5
  /* Pointers on D10V are really only 16 bits, 
     but we lie to gdb elsewhere... */
  if (GDB_TARGET_IS_D10V && TYPE_CODE (type) == TYPE_CODE_PTR)
    len = 2;

a928 18
    }

  if (GDB_TARGET_IS_D10V
      && TYPE_CODE (type) == TYPE_CODE_PTR)
    {
      unsigned long num;
      unsigned short snum;

      snum = (unsigned short)
	extract_unsigned_integer (VALUE_CONTENTS_RAW (v), 2);

      if (TYPE_TARGET_TYPE (type)	  /* pointer to function */
	  && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC))
	num = D10V_MAKE_IADDR (snum);
      else 				  /* pointer to data */
	num = D10V_MAKE_DADDR (snum);

      store_address (VALUE_CONTENTS_RAW (v), 4, num);
@


1.19.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d504 1
d527 1
d945 2
a946 2
      if (POINTER_TARGET_TYPE (type)	  /* pointer to function */
	  && (TYPE_CODE (POINTER_TARGET_TYPE (type)) == TYPE_CODE_FUNC))
@


1.18
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1986, 87, 89, 91, 94, 95, 96, 1998, 2001
@


1.17
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d33 1
@


1.16
log
@2001-02-06  Michael Snyder  <msnyder@@makita.cygnus.com>
	Submitted by Paul Hilfinger (hilfingr@@gnat.com)
	and Andrei Petrov (and@@genesyslab.com).
	* findvar.c: Buffers of size MAX_REGISTER_RAW_SIZE or REGISTER_BYTES
	must be allocated dynamically, since these are no longer constants.
	* infcmd.c: Ditto.
	* regcache.c: Ditto.
	* remote.c: Ditto.
	* sol-thread.c: Ditto.
	* valops.c: Ditto.
	* config/sparc/sun4sol2.mh (MH_CFLAGS): Add -I/usr/include/v9, as a
	work-around for a missing Sun header file in solaris for sparc64.
@
text
@d2 1
a2 1
   Copyright 1986, 87, 89, 91, 94, 95, 96, 1998
d193 2
a194 1
    internal_error ("findvar.c (extract_typed_address): "
d280 2
a281 1
    internal_error ("findvar.c (store_typed_address): "
d420 2
a421 1
    internal_error ("Register \"%s\" (%d) has conflicting raw (%d) and virtual (%d) size",
d880 2
a881 1
	internal_error ("value_from_register: Value not stored anywhere!");
@


1.15
log
@Protoization.
@
text
@d396 1
a396 1
  char raw_buffer[MAX_REGISTER_RAW_SIZE];
d609 1
a609 1
	char buf[MAX_REGISTER_RAW_SIZE];
d619 1
a619 1
	char buf[MAX_REGISTER_RAW_SIZE];
d714 1
a714 1
  char raw_buffer[MAX_REGISTER_RAW_SIZE];
@


1.14
log
@2000-07-07  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * findvar.c (_initialize_findvar, build_findvar, write_fp, read_fp,
        generic_target_write_fp, generic_target_read_fp, write_sp, read_sp,
        generic_target_write_sp, generic_target_read_sp, write_pc, read_pc,
        generic_target_write_pc, generic_target_read_pc, write_pc_pid,
        read_pc_pid, supply_register, write_register_pid, write_register,
        read_register_pid, read_register, write_register_bytes,
        read_register_bytes, write_register_gen, read_register_gen,
        registers_fetched, registers_changed, find_saved_register,
        read_relative_register_raw_bytes, default_get_saved_register,
        read_relative_register_raw_bytes_for_frame, get_saved_register):
        Move from this file into new file regcache.c.
        (register_valid, registers_pid, registers): Ditto.
        * regcache.c: New file to hold the register cache.
        (register_cached): New function to read register_valid array.
        * value.h (register_cached): Declare.
        * defs.h (default_get_saved_register): Delete decl of static function.
        * Makefile.in: Add regcache module.
@
text
@d391 1
a391 2
value_of_register (regnum)
     int regnum;
d462 1
a462 2
symbol_read_needs_frame (sym)
     struct symbol *sym;
d507 1
a507 3
read_var_value (var, frame)
     register struct symbol *var;
     struct frame_info *frame;
d712 1
a712 4
value_from_register (type, regnum, frame)
     struct type *type;
     int regnum;
     struct frame_info *frame;
d957 1
a957 3
locate_var_value (var, frame)
     register struct symbol *var;
     struct frame_info *frame;
@


1.13
log
@Add host_pointer_to_address() and address_to_host_pointer().  Add
signed_pointer_to_address() etc.  Rename generic_pointer_to_address()
to unsigned_pointer_to_address() etc.
@
text
@a39 12
/* Registers we shouldn't try to store.  */
#if !defined (CANNOT_STORE_REGISTER)
#define CANNOT_STORE_REGISTER(regno) 0
#endif

void write_register_gen (int, char *);

static int
read_relative_register_raw_bytes_for_frame (int regnum,
					    char *myaddr,
					    struct frame_info *frame);

a381 194


/* Return the address in which frame FRAME's value of register REGNUM
   has been saved in memory.  Or return zero if it has not been saved.
   If REGNUM specifies the SP, the value we return is actually
   the SP value, not an address where it was saved.  */

CORE_ADDR
find_saved_register (frame, regnum)
     struct frame_info *frame;
     int regnum;
{
  register struct frame_info *frame1 = NULL;
  register CORE_ADDR addr = 0;

  if (frame == NULL)		/* No regs saved if want current frame */
    return 0;

#ifdef HAVE_REGISTER_WINDOWS
  /* We assume that a register in a register window will only be saved
     in one place (since the name changes and/or disappears as you go
     towards inner frames), so we only call get_frame_saved_regs on
     the current frame.  This is directly in contradiction to the
     usage below, which assumes that registers used in a frame must be
     saved in a lower (more interior) frame.  This change is a result
     of working on a register window machine; get_frame_saved_regs
     always returns the registers saved within a frame, within the
     context (register namespace) of that frame. */

  /* However, note that we don't want this to return anything if
     nothing is saved (if there's a frame inside of this one).  Also,
     callers to this routine asking for the stack pointer want the
     stack pointer saved for *this* frame; this is returned from the
     next frame.  */

  if (REGISTER_IN_WINDOW_P (regnum))
    {
      frame1 = get_next_frame (frame);
      if (!frame1)
	return 0;		/* Registers of this frame are active.  */

      /* Get the SP from the next frame in; it will be this
         current frame.  */
      if (regnum != SP_REGNUM)
	frame1 = frame;

      FRAME_INIT_SAVED_REGS (frame1);
      return frame1->saved_regs[regnum];	/* ... which might be zero */
    }
#endif /* HAVE_REGISTER_WINDOWS */

  /* Note that this next routine assumes that registers used in
     frame x will be saved only in the frame that x calls and
     frames interior to it.  This is not true on the sparc, but the
     above macro takes care of it, so we should be all right. */
  while (1)
    {
      QUIT;
      frame1 = get_prev_frame (frame1);
      if (frame1 == 0 || frame1 == frame)
	break;
      FRAME_INIT_SAVED_REGS (frame1);
      if (frame1->saved_regs[regnum])
	addr = frame1->saved_regs[regnum];
    }

  return addr;
}

/* Find register number REGNUM relative to FRAME and put its (raw,
   target format) contents in *RAW_BUFFER.  Set *OPTIMIZED if the
   variable was optimized out (and thus can't be fetched).  Set *LVAL
   to lval_memory, lval_register, or not_lval, depending on whether
   the value was fetched from memory, from a register, or in a strange
   and non-modifiable way (e.g. a frame pointer which was calculated
   rather than fetched).  Set *ADDRP to the address, either in memory
   on as a REGISTER_BYTE offset into the registers array.

   Note that this implementation never sets *LVAL to not_lval.  But
   it can be replaced by defining GET_SAVED_REGISTER and supplying
   your own.

   The argument RAW_BUFFER must point to aligned memory.  */

void
default_get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lval)
     char *raw_buffer;
     int *optimized;
     CORE_ADDR *addrp;
     struct frame_info *frame;
     int regnum;
     enum lval_type *lval;
{
  CORE_ADDR addr;

  if (!target_has_registers)
    error ("No registers.");

  /* Normal systems don't optimize out things with register numbers.  */
  if (optimized != NULL)
    *optimized = 0;
  addr = find_saved_register (frame, regnum);
  if (addr != 0)
    {
      if (lval != NULL)
	*lval = lval_memory;
      if (regnum == SP_REGNUM)
	{
	  if (raw_buffer != NULL)
	    {
	      /* Put it back in target format.  */
	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
			     (LONGEST) addr);
	    }
	  if (addrp != NULL)
	    *addrp = 0;
	  return;
	}
      if (raw_buffer != NULL)
	read_memory (addr, raw_buffer, REGISTER_RAW_SIZE (regnum));
    }
  else
    {
      if (lval != NULL)
	*lval = lval_register;
      addr = REGISTER_BYTE (regnum);
      if (raw_buffer != NULL)
	read_register_gen (regnum, raw_buffer);
    }
  if (addrp != NULL)
    *addrp = addr;
}

#if !defined (GET_SAVED_REGISTER)
#define GET_SAVED_REGISTER(raw_buffer, optimized, addrp, frame, regnum, lval) \
  default_get_saved_register(raw_buffer, optimized, addrp, frame, regnum, lval)
#endif
void
get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lval)
     char *raw_buffer;
     int *optimized;
     CORE_ADDR *addrp;
     struct frame_info *frame;
     int regnum;
     enum lval_type *lval;
{
  GET_SAVED_REGISTER (raw_buffer, optimized, addrp, frame, regnum, lval);
}

/* Copy the bytes of register REGNUM, relative to the input stack frame,
   into our memory at MYADDR, in target byte order.
   The number of bytes copied is REGISTER_RAW_SIZE (REGNUM).

   Returns 1 if could not be read, 0 if could.  */

static int
read_relative_register_raw_bytes_for_frame (regnum, myaddr, frame)
     int regnum;
     char *myaddr;
     struct frame_info *frame;
{
  int optim;
  if (regnum == FP_REGNUM && frame)
    {
      /* Put it back in target format. */
      store_address (myaddr, REGISTER_RAW_SIZE (FP_REGNUM),
		     (LONGEST) FRAME_FP (frame));

      return 0;
    }

  get_saved_register (myaddr, &optim, (CORE_ADDR *) NULL, frame,
		      regnum, (enum lval_type *) NULL);

  if (register_valid[regnum] < 0)
    return 1;			/* register value not available */

  return optim;
}

/* Copy the bytes of register REGNUM, relative to the current stack frame,
   into our memory at MYADDR, in target byte order.
   The number of bytes copied is REGISTER_RAW_SIZE (REGNUM).

   Returns 1 if could not be read, 0 if could.  */

int
read_relative_register_raw_bytes (regnum, myaddr)
     int regnum;
     char *myaddr;
{
  return read_relative_register_raw_bytes_for_frame (regnum, myaddr,
						     selected_frame);
}
d403 1
a403 1
  if (register_valid[regnum] < 0)
a429 573

/* Low level examining and depositing of registers.

   The caller is responsible for making
   sure that the inferior is stopped before calling the fetching routines,
   or it will get garbage.  (a change from GDB version 3, in which
   the caller got the value from the last stop).  */

/* Contents and state of the registers (in target byte order). */

char *registers;

/* VALID_REGISTER is non-zero if it has been fetched, -1 if the
   register value was not available. */

signed char *register_valid;

/* The thread/process associated with the current set of registers.  For now,
   -1 is special, and means `no current process'.  */
int registers_pid = -1;

/* Indicate that registers may have changed, so invalidate the cache.  */

void
registers_changed ()
{
  int i;
  int numregs = ARCH_NUM_REGS;

  registers_pid = -1;

  /* Force cleanup of any alloca areas if using C alloca instead of
     a builtin alloca.  This particular call is used to clean up
     areas allocated by low level target code which may build up
     during lengthy interactions between gdb and the target before
     gdb gives control to the user (ie watchpoints).  */
  alloca (0);

  for (i = 0; i < numregs; i++)
    register_valid[i] = 0;

  if (registers_changed_hook)
    registers_changed_hook ();
}

/* Indicate that all registers have been fetched, so mark them all valid.  */
void
registers_fetched ()
{
  int i;
  int numregs = ARCH_NUM_REGS;
  for (i = 0; i < numregs; i++)
    register_valid[i] = 1;
}

/* read_register_bytes and write_register_bytes are generally a *BAD*
   idea.  They are inefficient because they need to check for partial
   updates, which can only be done by scanning through all of the
   registers and seeing if the bytes that are being read/written fall
   inside of an invalid register.  [The main reason this is necessary
   is that register sizes can vary, so a simple index won't suffice.]
   It is far better to call read_register_gen and write_register_gen
   if you want to get at the raw register contents, as it only takes a
   regno as an argument, and therefore can't do a partial register
   update.

   Prior to the recent fixes to check for partial updates, both read
   and write_register_bytes always checked to see if any registers
   were stale, and then called target_fetch_registers (-1) to update
   the whole set.  This caused really slowed things down for remote
   targets.  */

/* Copy INLEN bytes of consecutive data from registers
   starting with the INREGBYTE'th byte of register data
   into memory at MYADDR.  */

void
read_register_bytes (inregbyte, myaddr, inlen)
     int inregbyte;
     char *myaddr;
     int inlen;
{
  int inregend = inregbyte + inlen;
  int regno;

  if (registers_pid != inferior_pid)
    {
      registers_changed ();
      registers_pid = inferior_pid;
    }

  /* See if we are trying to read bytes from out-of-date registers.  If so,
     update just those registers.  */

  for (regno = 0; regno < NUM_REGS; regno++)
    {
      int regstart, regend;

      if (register_valid[regno])
	continue;

      if (REGISTER_NAME (regno) == NULL || *REGISTER_NAME (regno) == '\0')
	continue;

      regstart = REGISTER_BYTE (regno);
      regend = regstart + REGISTER_RAW_SIZE (regno);

      if (regend <= inregbyte || inregend <= regstart)
	/* The range the user wants to read doesn't overlap with regno.  */
	continue;

      /* We've found an invalid register where at least one byte will be read.
         Update it from the target.  */
      target_fetch_registers (regno);

      if (!register_valid[regno])
	error ("read_register_bytes:  Couldn't update register %d.", regno);
    }

  if (myaddr != NULL)
    memcpy (myaddr, &registers[inregbyte], inlen);
}

/* Read register REGNO into memory at MYADDR, which must be large enough
   for REGISTER_RAW_BYTES (REGNO).  Target byte-order.
   If the register is known to be the size of a CORE_ADDR or smaller,
   read_register can be used instead.  */
void
read_register_gen (regno, myaddr)
     int regno;
     char *myaddr;
{
  if (registers_pid != inferior_pid)
    {
      registers_changed ();
      registers_pid = inferior_pid;
    }

  if (!register_valid[regno])
    target_fetch_registers (regno);
  memcpy (myaddr, &registers[REGISTER_BYTE (regno)],
	  REGISTER_RAW_SIZE (regno));
}

/* Write register REGNO at MYADDR to the target.  MYADDR points at
   REGISTER_RAW_BYTES(REGNO), which must be in target byte-order.  */

void
write_register_gen (regno, myaddr)
     int regno;
     char *myaddr;
{
  int size;

  /* On the sparc, writing %g0 is a no-op, so we don't even want to change
     the registers array if something writes to this register.  */
  if (CANNOT_STORE_REGISTER (regno))
    return;

  if (registers_pid != inferior_pid)
    {
      registers_changed ();
      registers_pid = inferior_pid;
    }

  size = REGISTER_RAW_SIZE (regno);

  /* If we have a valid copy of the register, and new value == old value,
     then don't bother doing the actual store. */

  if (register_valid[regno]
      && memcmp (&registers[REGISTER_BYTE (regno)], myaddr, size) == 0)
    return;

  target_prepare_to_store ();

  memcpy (&registers[REGISTER_BYTE (regno)], myaddr, size);

  register_valid[regno] = 1;

  target_store_registers (regno);
}

/* Copy INLEN bytes of consecutive data from memory at MYADDR
   into registers starting with the MYREGSTART'th byte of register data.  */

void
write_register_bytes (myregstart, myaddr, inlen)
     int myregstart;
     char *myaddr;
     int inlen;
{
  int myregend = myregstart + inlen;
  int regno;

  target_prepare_to_store ();

  /* Scan through the registers updating any that are covered by the range
     myregstart<=>myregend using write_register_gen, which does nice things
     like handling threads, and avoiding updates when the new and old contents
     are the same.  */

  for (regno = 0; regno < NUM_REGS; regno++)
    {
      int regstart, regend;

      regstart = REGISTER_BYTE (regno);
      regend = regstart + REGISTER_RAW_SIZE (regno);

      /* Is this register completely outside the range the user is writing?  */
      if (myregend <= regstart || regend <= myregstart)
	/* do nothing */ ;		

      /* Is this register completely within the range the user is writing?  */
      else if (myregstart <= regstart && regend <= myregend)
	write_register_gen (regno, myaddr + (regstart - myregstart));

      /* The register partially overlaps the range being written.  */
      else
	{
	  char regbuf[MAX_REGISTER_RAW_SIZE];
	  /* What's the overlap between this register's bytes and
             those the caller wants to write?  */
	  int overlapstart = max (regstart, myregstart);
	  int overlapend   = min (regend,   myregend);

	  /* We may be doing a partial update of an invalid register.
	     Update it from the target before scribbling on it.  */
	  read_register_gen (regno, regbuf);

	  memcpy (registers + overlapstart,
		  myaddr + (overlapstart - myregstart),
		  overlapend - overlapstart);

	  target_store_registers (regno);
	}
    }
}


/* Return the raw contents of register REGNO, regarding it as an integer.  */
/* This probably should be returning LONGEST rather than CORE_ADDR.  */

CORE_ADDR
read_register (regno)
     int regno;
{
  if (registers_pid != inferior_pid)
    {
      registers_changed ();
      registers_pid = inferior_pid;
    }

  if (!register_valid[regno])
    target_fetch_registers (regno);

  return ((CORE_ADDR)
	  extract_unsigned_integer (&registers[REGISTER_BYTE (regno)],
				    REGISTER_RAW_SIZE (regno)));
}

CORE_ADDR
read_register_pid (regno, pid)
     int regno, pid;
{
  int save_pid;
  CORE_ADDR retval;

  if (pid == inferior_pid)
    return read_register (regno);

  save_pid = inferior_pid;

  inferior_pid = pid;

  retval = read_register (regno);

  inferior_pid = save_pid;

  return retval;
}

/* Store VALUE, into the raw contents of register number REGNO.
   This should probably write a LONGEST rather than a CORE_ADDR */

void
write_register (regno, val)
     int regno;
     LONGEST val;
{
  PTR buf;
  int size;

  /* On the sparc, writing %g0 is a no-op, so we don't even want to change
     the registers array if something writes to this register.  */
  if (CANNOT_STORE_REGISTER (regno))
    return;

  if (registers_pid != inferior_pid)
    {
      registers_changed ();
      registers_pid = inferior_pid;
    }

  size = REGISTER_RAW_SIZE (regno);
  buf = alloca (size);
  store_signed_integer (buf, size, (LONGEST) val);

  /* If we have a valid copy of the register, and new value == old value,
     then don't bother doing the actual store. */

  if (register_valid[regno]
      && memcmp (&registers[REGISTER_BYTE (regno)], buf, size) == 0)
    return;

  target_prepare_to_store ();

  memcpy (&registers[REGISTER_BYTE (regno)], buf, size);

  register_valid[regno] = 1;

  target_store_registers (regno);
}

void
write_register_pid (regno, val, pid)
     int regno;
     CORE_ADDR val;
     int pid;
{
  int save_pid;

  if (pid == inferior_pid)
    {
      write_register (regno, val);
      return;
    }

  save_pid = inferior_pid;

  inferior_pid = pid;

  write_register (regno, val);

  inferior_pid = save_pid;
}

/* Record that register REGNO contains VAL.
   This is used when the value is obtained from the inferior or core dump,
   so there is no need to store the value there.

   If VAL is a NULL pointer, then it's probably an unsupported register.  We
   just set it's value to all zeros.  We might want to record this fact, and
   report it to the users of read_register and friends.
 */

void
supply_register (regno, val)
     int regno;
     char *val;
{
#if 1
  if (registers_pid != inferior_pid)
    {
      registers_changed ();
      registers_pid = inferior_pid;
    }
#endif

  register_valid[regno] = 1;
  if (val)
    memcpy (&registers[REGISTER_BYTE (regno)], val, REGISTER_RAW_SIZE (regno));
  else
    memset (&registers[REGISTER_BYTE (regno)], '\000', REGISTER_RAW_SIZE (regno));

  /* On some architectures, e.g. HPPA, there are a few stray bits in some
     registers, that the rest of the code would like to ignore.  */
#ifdef CLEAN_UP_REGISTER_VALUE
  CLEAN_UP_REGISTER_VALUE (regno, &registers[REGISTER_BYTE (regno)]);
#endif
}


/* This routine is getting awfully cluttered with #if's.  It's probably
   time to turn this into READ_PC and define it in the tm.h file.
   Ditto for write_pc.

   1999-06-08: The following were re-written so that it assumes the
   existance of a TARGET_READ_PC et.al. macro.  A default generic
   version of that macro is made available where needed.

   Since the ``TARGET_READ_PC'' et.al. macro is going to be controlled
   by the multi-arch framework, it will eventually be possible to
   eliminate the intermediate read_pc_pid().  The client would call
   TARGET_READ_PC directly. (cagney). */

#ifndef TARGET_READ_PC
#define TARGET_READ_PC generic_target_read_pc
#endif

CORE_ADDR
generic_target_read_pc (int pid)
{
#ifdef PC_REGNUM
  if (PC_REGNUM >= 0)
    {
      CORE_ADDR pc_val = ADDR_BITS_REMOVE ((CORE_ADDR) read_register_pid (PC_REGNUM, pid));
      return pc_val;
    }
#endif
  internal_error ("generic_target_read_pc");
  return 0;
}

CORE_ADDR
read_pc_pid (pid)
     int pid;
{
  int saved_inferior_pid;
  CORE_ADDR pc_val;

  /* In case pid != inferior_pid. */
  saved_inferior_pid = inferior_pid;
  inferior_pid = pid;

  pc_val = TARGET_READ_PC (pid);

  inferior_pid = saved_inferior_pid;
  return pc_val;
}

CORE_ADDR
read_pc ()
{
  return read_pc_pid (inferior_pid);
}

#ifndef TARGET_WRITE_PC
#define TARGET_WRITE_PC generic_target_write_pc
#endif

void
generic_target_write_pc (pc, pid)
     CORE_ADDR pc;
     int pid;
{
#ifdef PC_REGNUM
  if (PC_REGNUM >= 0)
    write_register_pid (PC_REGNUM, pc, pid);
  if (NPC_REGNUM >= 0)
    write_register_pid (NPC_REGNUM, pc + 4, pid);
  if (NNPC_REGNUM >= 0)
    write_register_pid (NNPC_REGNUM, pc + 8, pid);
#else
  internal_error ("generic_target_write_pc");
#endif
}

void
write_pc_pid (pc, pid)
     CORE_ADDR pc;
     int pid;
{
  int saved_inferior_pid;

  /* In case pid != inferior_pid. */
  saved_inferior_pid = inferior_pid;
  inferior_pid = pid;

  TARGET_WRITE_PC (pc, pid);

  inferior_pid = saved_inferior_pid;
}

void
write_pc (pc)
     CORE_ADDR pc;
{
  write_pc_pid (pc, inferior_pid);
}

/* Cope with strage ways of getting to the stack and frame pointers */

#ifndef TARGET_READ_SP
#define TARGET_READ_SP generic_target_read_sp
#endif

CORE_ADDR
generic_target_read_sp ()
{
#ifdef SP_REGNUM
  if (SP_REGNUM >= 0)
    return read_register (SP_REGNUM);
#endif
  internal_error ("generic_target_read_sp");
}

CORE_ADDR
read_sp ()
{
  return TARGET_READ_SP ();
}

#ifndef TARGET_WRITE_SP
#define TARGET_WRITE_SP generic_target_write_sp
#endif

void
generic_target_write_sp (val)
     CORE_ADDR val;
{
#ifdef SP_REGNUM
  if (SP_REGNUM >= 0)
    {
      write_register (SP_REGNUM, val);
      return;
    }
#endif
  internal_error ("generic_target_write_sp");
}

void
write_sp (val)
     CORE_ADDR val;
{
  TARGET_WRITE_SP (val);
}

#ifndef TARGET_READ_FP
#define TARGET_READ_FP generic_target_read_fp
#endif

CORE_ADDR
generic_target_read_fp ()
{
#ifdef FP_REGNUM
  if (FP_REGNUM >= 0)
    return read_register (FP_REGNUM);
#endif
  internal_error ("generic_target_read_fp");
}

CORE_ADDR
read_fp ()
{
  return TARGET_READ_FP ();
}

#ifndef TARGET_WRITE_FP
#define TARGET_WRITE_FP generic_target_write_fp
#endif

void
generic_target_write_fp (val)
     CORE_ADDR val;
{
#ifdef FP_REGNUM
  if (FP_REGNUM >= 0)
    {
      write_register (FP_REGNUM, val);
      return;
    }
#endif
  internal_error ("generic_target_write_fp");
}

void
write_fp (val)
     CORE_ADDR val;
{
  TARGET_WRITE_FP (val);
}

d802 1
a802 1
	  if (register_valid[page_regnum] == -1)
d819 1
a819 1
	  if (register_valid[regnum] == -1)
d845 1
a845 1
	    if (register_valid[local_regnum] == -1)
d910 1
a910 1
  if (register_valid[regnum] == -1)
a1004 26
}


static void build_findvar (void);
static void
build_findvar ()
{
  /* We allocate some extra slop since we do a lot of memcpy's around
     `registers', and failing-soft is better than failing hard.  */
  int sizeof_registers = REGISTER_BYTES + /* SLOP */ 256;
  int sizeof_register_valid = NUM_REGS * sizeof (*register_valid);
  registers = xmalloc (sizeof_registers);
  memset (registers, 0, sizeof_registers);
  register_valid = xmalloc (sizeof_register_valid);
  memset (register_valid, 0, sizeof_register_valid);
}

void _initialize_findvar (void);
void
_initialize_findvar ()
{
  build_findvar ();

  register_gdbarch_swap (&registers, sizeof (registers), NULL);
  register_gdbarch_swap (&register_valid, sizeof (register_valid), NULL);
  register_gdbarch_swap (NULL, 0, build_findvar);
@


1.12
log
@PARAMS removal.
@
text
@d1213 1
a1213 1
generic_pointer_to_address (struct type *type, char *buf)
d1218 5
d1227 1
a1227 1
generic_address_to_pointer (struct type *type, char *buf, CORE_ADDR addr)
d1232 5
@


1.11
log
@2000-05-24  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * findvar.c (value_from_register): Factor code, simplify logic.
@
text
@d45 1
a45 1
void write_register_gen PARAMS ((int, char *));
d47 4
a50 4
static int 
read_relative_register_raw_bytes_for_frame PARAMS ((int regnum, 
						    char *myaddr, 
						    struct frame_info *frame));
d1777 1
a1777 1
static void build_findvar PARAMS ((void));
d1791 1
a1791 1
void _initialize_findvar PARAMS ((void));
@


1.10
log
@Multi-arch NPC_REGNUM NNPC_REGNUM.
@
text
@d1479 1
a1479 1
   FRAME. 
d1503 2
a1504 1
  /* Pointers on D10V are really only 16 bits, but we lie to gdb elsewhere... */
d1707 1
a1707 3
      && TYPE_CODE (type) == TYPE_CODE_PTR
      && TYPE_TARGET_TYPE (type)
      && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC))
a1708 1
      /* pointer to function */
d1711 10
a1720 12
      snum = (unsigned short) extract_unsigned_integer (VALUE_CONTENTS_RAW (v), 2);
      num = D10V_MAKE_IADDR (snum);
      store_address (VALUE_CONTENTS_RAW (v), 4, num);
    }
  else if (GDB_TARGET_IS_D10V
	   && TYPE_CODE (type) == TYPE_CODE_PTR)
    {
      /* pointer to data */
      unsigned long num;
      unsigned short snum;
      snum = (unsigned short) extract_unsigned_integer (VALUE_CONTENTS_RAW (v), 2);
      num = D10V_MAKE_DADDR (snum);
@


1.9
log
@2000-04-27  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * jv-valprint.c (java_val_print): Add arg declaration,
        fix compiler warning.
        * corelow.c (core_open): Call set_gdbarch_from_file so that
        gdbarch becomes aware of the architecture encoded in the
        corefile.
        * findvar.c (write_register_gen): Export this useful interface.
        * value.h (write_register_gen): Declare.
@
text
@a1084 1
#ifdef NPC_REGNUM
a1086 1
#ifdef NNPC_REGNUM
a1088 2
#endif
#endif
@


1.8
log
@* remote.c (REMOTE_TRANSLATE_XFER_ADDRESS), mem-break.c
(MEMORY_INSERT_BREAKPOINT, MEMORY_REMOVE_BREAKPOINT), target.h
(BREAKPOINT_FROM_PC), valops.c (COERCE_FLOAT_TO_DOUBLE),
gdbarch.sh (D10V_MAKE_DADDR, D10V_MAKE_IADDR,
FRAMELESS_FUNCTION_INVOCATION, REGISTER_CONVERTIBLE,
REGISTER_CONVERT_TO_VIRTUAL, REGISTER_CONVERT_TO_RAW,
REGISTER_NAME), findvar.c (POINTER_TO_ADDRESS,
ADDRESS_TO_POINTER): Delete default definition.  Handled by
gdbarch.

* gdbarch.sh: Make multi-arch defaults, defaults for non-
multi-arch targets.
(REGISTER_NAME, COERCE_FLOAT_TO_DOUBLE, REGISTER_CONVERTIBLE,
REGISTER_CONVERT_TO_VIRTUAL, REGISTER_CONVERT_TO_RAW,
D10V_MAKE_DADDR, D10V_MAKE_IADDR, BREAKPOINT_FROM_PC,
MEMORY_INSERT_BREAKPOINT, MEMORY_REMOVE_BREAKPOINT,
REMOTE_TRANSLATE_XFER_ADDRESS, FRAMELESS_FUNCTION_INVOCATION):
Provide default/legacy implementation.
(REGISTER_NAMES, CALL_DUMMY): Allow legacy definition.
* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d45 1
a45 1
static void write_register_gen PARAMS ((int, char *));
d47 4
a50 1
static int read_relative_register_raw_bytes_for_frame PARAMS ((int regnum, char *myaddr, struct frame_info * frame));
d783 1
a783 1
static void
@


1.7
log
@* findvar.c (store_typed_address, extract_typed_address): Fix
function names in error messages.
@
text
@a194 4
#ifndef POINTER_TO_ADDRESS
#define POINTER_TO_ADDRESS generic_pointer_to_address
#endif

a279 4

#ifndef ADDRESS_TO_POINTER
#define ADDRESS_TO_POINTER generic_address_to_pointer
#endif
@


1.6
log
@* gdbarch.sh (POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Two new
functions which architectures can redefine, defaulting to
generic_pointer_to_address and generic_address_to_pointer.
* findvar.c (extract_typed_address, store_typed_address,
generic_pointer_to_address, generic_address_to_pointer): New
functions.
(POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Provide default
definitions.
(extract_address, store_address): Doc fixes.
* values.c (value_as_pointer): Doc fix.
(value_from_pointer): New function.
* defs.h (extract_typed_address, store_typed_address): New
declarations.
* inferior.h (generic_address_to_pointer,
generic_pointer_to_address): New declarations.
* value.h (value_from_pointer): New declaration.

* ax-gdb.c (const_var_ref): Use value_from_pointer, not
value_from_longest.
* blockframe.c (generic_push_dummy_frame): Use read_pc and
read_sp, not read_register.
* c-valprint.c (c_val_print): Use extract_typed_address instead of
extract_address to extract vtable entries and references.
* cp-valprint.c (cp_print_value_fields): Use value_from_pointer
instead of value_from_longest to extract the vtable's address.
* eval.c (evaluate_subexp_standard): Use value_from_pointer
instead of value_from_longest to compute `this', and for doing
pointer-to-member dereferencing.
* findvar.c (read_register): Use extract_unsigned_integer, not
extract_address.
(read_var_value): Use store_typed_address instead of store_address
for building label values.
(locate_var_value): Use value_from_pointer instead of
value_from_longest.
* hppa-tdep.c (find_stub_with_shl_get): Use value_from_pointer,
instead of value_from_longest, to build arguments to __d_shl_get.
* printcmd.c (set_next_address): Use value_from_pointer, not
value_from_longest.
(x_command): Use value_from_pointer, not value_from_longest.
* tracepoint.c (set_traceframe_context): Use value_from_pointer,
not value_from_longest.
* valarith.c (value_add, value_sub): Use value_from_pointer, not
value_from_longest.
* valops.c (find_function_in_inferior, value_coerce_array,
value_coerce_function, value_addr, hand_function_call): Same.
* value.h (COERCE_REF): Use unpack_pointer, not unpack_long.
* values.c (unpack_long): Use extract_typed_address to produce
addresses from pointers and references, not extract_address.
(value_from_longest): Use store_typed_address instead of
store_address to produce pointer and reference values.
@
text
@d206 1
a206 1
    internal_error ("findvar.c (generic_pointer_to_address): "
d296 1
a296 1
    internal_error ("findvar.c (generic_address_to_pointer): "
@


1.5
log
@2000-03-29  Mark Kettenis  <kettenis@@gnu.org>

	* findvar.c (extract_floating): Remove reference to
	TARGET_EXTRACT_FLOATING.
	(store_floating): Remove reference to TARGET_STORE_FLOATING.
@
text
@d172 14
d194 19
d267 11
a277 3
/* Store the literal address "val" into
   gdb-local memory pointed to by "addr"
   for "len" bytes. */
d283 21
d510 2
a511 1
	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), (LONGEST) addr);
d897 3
a899 2
  return (CORE_ADDR) extract_address (&registers[REGISTER_BYTE (regno)],
				      REGISTER_RAW_SIZE (regno));
d1217 19
d1317 6
a1322 3
	store_address (VALUE_CONTENTS_RAW (v), len,
	     (LONGEST) symbol_overlayed_address (SYMBOL_VALUE_ADDRESS (var),
						 SYMBOL_BFD_SECTION (var)));
d1324 2
a1325 2
	store_address (VALUE_CONTENTS_RAW (v), len,
		       (LONGEST) SYMBOL_VALUE_ADDRESS (var));
d1767 1
a1767 1
      val = value_from_longest (lookup_pointer_type (type), (LONGEST) addr);
@


1.4
log
@Convert extract/store functions to ISO-C.
@
text
@a291 4
#ifdef TARGET_EXTRACT_FLOATING
  else if (TARGET_EXTRACT_FLOATING (addr, len, &dretval))
    return dretval;
#endif
a331 4
#ifdef TARGET_STORE_FLOATING
  else if (TARGET_STORE_FLOATING (addr, len, val))
    return;
#endif 
@


1.3
log
@Fixes for extract_floating() and store_floating().
@
text
@d60 2
a61 4
  LONGEST
extract_signed_integer (addr, len)
     PTR addr;
     int len;
d95 1
a95 3
extract_unsigned_integer (addr, len)
     PTR addr;
     int len;
d129 1
a129 4
extract_long_unsigned_integer (addr, orig_len, pval)
     PTR addr;
     int orig_len;
     LONGEST *pval;
d173 1
a173 3
extract_address (addr, len)
     PTR addr;
     int len;
d181 1
a181 4
store_signed_integer (addr, len, val)
     PTR addr;
     int len;
     LONGEST val;
d208 1
a208 4
store_unsigned_integer (addr, len, val)
     PTR addr;
     int len;
     ULONGEST val;
d238 1
a238 4
store_address (addr, len, val)
     PTR addr;
     int len;
     LONGEST val;
@


1.2
log
@	Clean up compiler warnings:
	* bcache.h, bcache.c, c-valprint.c, coffread.c, stabsread.c,
	stack.c, valprint.c: Change variables to unsigned.
	* bcache.c: Rearrange to avoid warnings about variables not being set.
	* c-lang.c, ch-lang.c, f-lang.c, m2-lang.c: Include valprint.h
	rather than declaring print_max and repeat_count_threashold
	ourselves (incorrectly).
	* valprint.h: Do declare repeat_count_threashold.
	* ch-exp.c: Use default case for internal error.
	* findvar.c: Don't omit argument type.
	* symtab.c: Remove unused variable.
@
text
@d270 1
a270 3
extract_floating (addr, len)
     PTR addr;
     int len;
d274 1
a274 1
  if (len == sizeof (float))
d286 1
a286 1
  else if (len == sizeof (double))
d298 1
a298 1
  else if (len == sizeof (DOUBLEST))
d323 1
a323 4
store_floating (addr, len, val)
     PTR addr;
     int len;
     DOUBLEST val;
d325 1
a325 1
  if (len == sizeof (float))
d336 1
a336 1
  else if (len == sizeof (double))
d347 1
a347 1
  else if (len == sizeof (DOUBLEST))
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d32 1
a32 1
#include "symfile.h"	/* for overlay functions */
d47 2
d57 1
a57 1
  you lose
d60 1
a60 1
LONGEST
d67 1
a67 1
  unsigned char *startaddr = (unsigned char *)addr;
d81 1
a81 1
      retval = ((LONGEST)*p ^ 0x80) - 0x80;
d89 1
a89 1
      retval = ((LONGEST)*p ^ 0x80) - 0x80;
d103 1
a103 1
  unsigned char *startaddr = (unsigned char *)addr;
d186 1
a186 1
  return (CORE_ADDR)extract_unsigned_integer (addr, len);
d196 1
a196 1
  unsigned char *startaddr = (unsigned char *)addr;
d226 1
a226 1
  unsigned char *startaddr = (unsigned char *)addr;
a257 19
  if( TARGET_BYTE_ORDER == BIG_ENDIAN
      &&  len != sizeof( LONGEST )) {
    /* On big-endian machines (e.g., HPPA 2.0, narrow mode)
     * just letting this fall through to the call below will
     * lead to the wrong bits being stored.
     *
     * Only the simplest case is fixed here, the others just
     * get the old behavior.
     */
    if( (len == sizeof( CORE_ADDR ))
	&&  (sizeof( LONGEST ) == 2 * sizeof( CORE_ADDR ))) {
      /* Watch out!  The high bits are garbage! */
      CORE_ADDR coerce[2];
      *(LONGEST*)&coerce = val;

      store_unsigned_integer (addr, len, coerce[1] ); /* BIG_ENDIAN code! */
      return;
    }
  }
a260 19
/* Swap LEN bytes at BUFFER between target and host byte-order.  */
#define SWAP_FLOATING(buffer,len) \
  do                                                                    \
    {                                                                   \
      if (TARGET_BYTE_ORDER != HOST_BYTE_ORDER)                         \
        {                                                               \
          char tmp;                                                     \
          char *p = (char *)(buffer);                                   \
          char *q = ((char *)(buffer)) + len - 1;                       \
          for (; p < q; p++, q--)                                       \
            {                                                           \
              tmp = *q;                                                 \
              *q = *p;                                                  \
              *p = tmp;                                                 \
            }                                                           \
        }                                                               \
    }                                                                   \
  while (0)

d312 4
d359 4
a368 1
#if !defined (GET_SAVED_REGISTER)
d402 2
a403 2
     
  if (REGISTER_IN_WINDOW_P(regnum))
d406 3
a408 2
      if (!frame1) return 0;	/* Registers of this frame are active.  */
      
d410 1
a410 1
	 current frame.  */
d412 2
a413 2
	frame1 = frame;	
	  
d453 1
a453 1
get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lval)
d479 1
a479 1
	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), (LONGEST)addr);
d499 16
a514 1
#endif /* GET_SAVED_REGISTER.  */
d522 1
a522 1
int
d532 2
a533 2
      store_address (myaddr, REGISTER_RAW_SIZE(FP_REGNUM),
		     (LONGEST)FRAME_FP(frame));
d539 1
a539 1
                      regnum, (enum lval_type *)NULL);
d541 2
a542 2
  if (register_valid [regnum] < 0)
    return 1;	/* register value not available */
d558 1
a558 1
  return read_relative_register_raw_bytes_for_frame (regnum, myaddr, 
d583 1
a583 1
    return NULL;	/* register value not available */
a588 1
#ifdef REGISTER_CONVERTIBLE
d594 3
d598 5
a602 8
#endif
    if (REGISTER_RAW_SIZE (regnum) == REGISTER_VIRTUAL_SIZE (regnum))
      memcpy (VALUE_CONTENTS_RAW (reg_val), raw_buffer,
	      REGISTER_RAW_SIZE (regnum));
    else
      fatal ("Register \"%s\" (%d) has conflicting raw (%d) and virtual (%d) size",
	     REGISTER_NAME (regnum), regnum,
	     REGISTER_RAW_SIZE (regnum), REGISTER_VIRTUAL_SIZE (regnum));
d617 8
a624 9
/* Contents of the registers in target byte order.
   We allocate some extra slop since we do a lot of memcpy's around 
   `registers', and failing-soft is better than failing hard.  */

char registers[REGISTER_BYTES + /* SLOP */ 256];

/* Nonzero if that register has been fetched,
   -1 if register value not available. */
SIGNED char register_valid[NUM_REGS];
d664 16
a679 14
/* read_register_bytes and write_register_bytes are generally a *BAD* idea.
   They are inefficient because they need to check for partial updates, which
   can only be done by scanning through all of the registers and seeing if the
   bytes that are being read/written fall inside of an invalid register.  [The
    main reason this is necessary is that register sizes can vary, so a simple
    index won't suffice.]  It is far better to call read_register_gen if you
   want to get at the raw register contents, as it only takes a regno as an
   argument, and therefore can't do a partial register update.  It would also
   be good to have a write_register_gen for similar reasons.

   Prior to the recent fixes to check for partial updates, both read and
   write_register_bytes always checked to see if any registers were stale, and
   then called target_fetch_registers (-1) to update the whole set.  This
   caused really slowed things down for remote targets.  */
a705 1
      int startin, endin;
d716 2
a717 4
      startin = regstart >= inregbyte && regstart < inregend;
      endin = regend > inregbyte && regend <= inregend;

      if (!startin && !endin)
d721 1
a721 2
	 Update it from the target.  */

d774 1
a774 1
  size = REGISTER_RAW_SIZE(regno);
d779 1
a779 1
  if (register_valid [regno]
d782 1
a782 1
  
d787 1
a787 1
  register_valid [regno] = 1;
a813 2
      int startin, endin;
      char regbuf[MAX_REGISTER_RAW_SIZE];
d818 7
a824 2
      startin = regstart >= myregstart && regstart < myregend;
      endin = regend > myregstart && regend <= myregend;
d826 16
a841 2
      if (!startin && !endin)
	continue;		/* Register is completely out of range */
d843 1
a843 4
      if (startin && endin)	/* register is completely in range */
	{
	  write_register_gen (regno, myaddr + (regstart - myregstart));
	  continue;
a844 14

      /* We may be doing a partial update of an invalid register.  Update it
	 from the target before scribbling on it.  */
      read_register_gen (regno, regbuf);

      if (startin)
	memcpy (registers + regstart,
		myaddr + regstart - myregstart,
		myregend - regstart);
      else			/* endin */
	memcpy (registers + myregstart,
		myaddr,
		regend - myregstart);
      target_store_registers (regno);
d848 1
d865 2
a866 2
  return (CORE_ADDR)extract_address (&registers[REGISTER_BYTE (regno)],
				     REGISTER_RAW_SIZE(regno));
d912 1
a912 1
  size = REGISTER_RAW_SIZE(regno);
d914 1
a914 1
  store_signed_integer (buf, size, (LONGEST)val);
d919 1
a919 1
  if (register_valid [regno]
d922 1
a922 1
  
d927 1
a927 1
  register_valid [regno] = 1;
d962 1
a962 1
*/
d986 1
a986 1
  CLEAN_UP_REGISTER_VALUE(regno, &registers[REGISTER_BYTE(regno)]);
d993 28
a1020 1
   Ditto for write_pc.  */
d1026 2
a1027 2
  int  saved_inferior_pid;
  CORE_ADDR  pc_val;
d1032 1
a1032 2
  
#ifdef TARGET_READ_PC
a1033 3
#else
  pc_val = ADDR_BITS_REMOVE ((CORE_ADDR) read_register_pid (PC_REGNUM, pid));
#endif
d1045 25
d1075 1
a1075 1
  int  saved_inferior_pid;
d1080 1
a1080 2
  
#ifdef TARGET_WRITE_PC
a1081 9
#else
  write_register_pid (PC_REGNUM, pc, pid);
#ifdef NPC_REGNUM
  write_register_pid (NPC_REGNUM, pc + 4, pid);
#ifdef NNPC_REGNUM
  write_register_pid (NNPC_REGNUM, pc + 8, pid);
#endif
#endif
#endif
d1095 14
a1111 1
#ifdef TARGET_READ_SP
d1113 16
a1128 2
#else
  return read_register (SP_REGNUM);
d1130 1
a1136 1
#ifdef TARGET_WRITE_SP
d1138 12
a1149 2
#else
  write_register (SP_REGNUM, val);
d1151 1
a1156 1
#ifdef TARGET_READ_FP
d1158 16
a1173 2
#else
  return read_register (FP_REGNUM);
d1175 1
a1181 1
#ifdef TARGET_WRITE_FP
a1182 3
#else
  write_register (FP_REGNUM, val);
#endif
d1195 1
a1195 1
	 we failed to consider one.  */
d1216 2
a1217 2
	 even if some *uses* of that address wouldn't work so well without
	 the right frame.  */
d1250 2
a1251 1
  if (frame == NULL) frame = selected_frame;
d1265 3
a1267 3
	store_address (VALUE_CONTENTS_RAW (v), len, 
		       (LONGEST)symbol_overlayed_address (SYMBOL_VALUE_ADDRESS (var),
							   SYMBOL_BFD_SECTION (var)));
d1270 1
a1270 1
		       (LONGEST)SYMBOL_VALUE_ADDRESS (var));
d1294 1
a1294 1
         execution yet, so check for that. */ 
d1296 1
a1296 1
        error ("\
d1299 1
a1299 1
      
d1343 1
a1343 1
			    
d1346 3
a1348 3
        char buf[MAX_REGISTER_RAW_SIZE];
        
        get_saved_register(buf, NULL, NULL, frame, SYMBOL_BASEREG (var),
d1350 3
a1352 3
        addr = extract_address (buf, REGISTER_RAW_SIZE (SYMBOL_BASEREG (var)));
        addr += SYMBOL_VALUE (var );
        break;
d1354 1
a1354 1
      
d1361 1
a1361 1
	VALUE_ADDRESS (v) = symbol_overlayed_address 
d1382 1
a1382 1
					  regno, 
d1388 1
a1388 1
	    addr   = value_as_pointer (regval);
d1444 1
a1444 1
  char raw_buffer [MAX_REGISTER_RAW_SIZE];
d1457 4
d1471 1
a1471 1
      )
d1474 1
a1474 1
      
d1500 4
a1503 1
	    case R0_REGNUM: case R1_REGNUM: case R2_REGNUM: case R3_REGNUM:
d1506 2
a1507 1
	    case R4_REGNUM: case R5_REGNUM:
d1510 2
a1511 1
	    case R6_REGNUM: case R7_REGNUM:
d1554 1
a1554 1
#endif				/* GDB_TARGET_IS_H8500 */
d1567 2
a1568 2
	  if (register_valid[local_regnum] == -1)
	    return NULL;	/* register value not available */
d1577 1
a1577 1
	      
d1606 1
a1606 1
	fatal ("value_from_register: Value not stored anywhere!");
d1611 3
a1613 3
	 an integral number of registers.  Otherwise, you'd need to do
	 some fiddling with the last register copied here for little
	 endian machines.  */
d1621 1
a1621 1
      REGISTER_CONVERT_TO_TYPE(regnum, type, VALUE_CONTENTS_RAW(v));
d1633 1
a1633 1
    return NULL;	/* register value not available */
d1640 1
a1640 2
  
#ifdef REGISTER_CONVERTIBLE
a1646 1
#endif
d1652 1
a1652 1
  	  /* Big-endian, and we want less than full size.  */
d1658 24
a1681 1
  
d1712 1
a1712 1
      val =  value_from_longest (lookup_pointer_type (type), (LONGEST) addr);
d1718 1
a1718 1
  switch (VALUE_LVAL (lazy_value)) 
d1731 27
a1757 1
  return 0;  /* For lint -- never reached */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a45 2
static int read_relative_register_raw_bytes_for_frame PARAMS ((int regnum, char *myaddr, struct frame_info *frame));

d255 19
d396 1
d480 1
a480 1
default_get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lval)
d526 1
a526 16

#if !defined (GET_SAVED_REGISTER)
#define GET_SAVED_REGISTER(raw_buffer, optimized, addrp, frame, regnum, lval) \
  default_get_saved_register(raw_buffer, optimized, addrp, frame, regnum, lval)
#endif
void
get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lval)
     char *raw_buffer;
     int *optimized;
     CORE_ADDR *addrp;
     struct frame_info *frame;
     int regnum;
     enum lval_type *lval;
{
  GET_SAVED_REGISTER (raw_buffer, optimized, addrp, frame, regnum, lval);
}
d534 1
a534 1
static int
d630 9
a638 8
/* Contents and state of the registers (in target byte order). */

char *registers;

/* VALID_REGISTER is non-zero if it has been fetched, -1 if the
   register value was not available. */

signed char *register_valid;
a1629 22
}


static void build_findvar PARAMS ((void));
static void
build_findvar ()
{
  /* We allocate some extra slop since we do a lot of memcpy's around
     `registers', and failing-soft is better than failing hard.  */
  int sizeof_registers = REGISTER_BYTES + /* SLOP */ 256;
  int sizeof_register_valid = NUM_REGS * sizeof (*register_valid);
  registers = xmalloc (sizeof_registers);
  memset (registers, 0, sizeof_registers);
  register_valid = xmalloc (sizeof_register_valid);
  memset (register_valid, 0, sizeof_register_valid);
}

void _initialize_findvar PARAMS ((void));
void
_initialize_findvar ()
{
  build_findvar ();
@


1.1.1.3
log
@import gdb-1999-05-25 snapshot
@
text
@d598 1
a603 3
  else if (REGISTER_RAW_SIZE (regnum) == REGISTER_VIRTUAL_SIZE (regnum))
    memcpy (VALUE_CONTENTS_RAW (reg_val), raw_buffer,
	    REGISTER_RAW_SIZE (regnum));
d605 8
a612 3
    fatal ("Register \"%s\" (%d) has conflicting raw (%d) and virtual (%d) size",
	   REGISTER_NAME (regnum), regnum,
	   REGISTER_RAW_SIZE (regnum), REGISTER_VIRTUAL_SIZE (regnum));
d1556 1
d1563 1
@


1.1.1.4
log
@import gdb-1999-06-14 snapshot
@
text
@d1001 1
a1001 28
   Ditto for write_pc.

   1999-06-08: The following were re-written so that it assumes the
   existance of a TARGET_READ_PC et.al. macro.  A default generic
   version of that macro is made available where needed.

   Since the ``TARGET_READ_PC'' et.al. macro is going to be controlled
   by the multi-arch framework, it will eventually be possible to
   eliminate the intermediate read_pc_pid().  The client would call
   TARGET_READ_PC directly. (cagney). */

#ifndef TARGET_READ_PC
#define TARGET_READ_PC generic_target_read_pc
#endif

CORE_ADDR
generic_target_read_pc (pid)
{
#ifdef PC_REGNUM
  if (PC_REGNUM >= 0)
    {
      CORE_ADDR pc_val = ADDR_BITS_REMOVE ((CORE_ADDR) read_register_pid (PC_REGNUM, pid));
      return pc_val;
    }
#endif
  fatal ("generic_target_read_pc");
  return 0;
}
d1014 1
d1016 3
a1029 25
#ifndef TARGET_WRITE_PC
#define TARGET_WRITE_PC generic_target_write_pc
#endif

void
generic_target_write_pc (pc, pid)
     CORE_ADDR pc;
     int pid;
{
#ifdef PC_REGNUM
  if (PC_REGNUM >= 0)
    write_register_pid (PC_REGNUM, pc, pid);
#ifdef NPC_REGNUM
  if (NPC_REGNUM >= 0)
    write_register_pid (NPC_REGNUM, pc + 4, pid);
#ifdef NNPC_REGNUM
  if (NNPC_REGNUM >= 0)
    write_register_pid (NNPC_REGNUM, pc + 8, pid);
#endif
#endif
#else
  fatal ("generic_target_write_pc");
#endif
}

d1041 1
d1043 9
a1064 14
#ifndef TARGET_READ_SP
#define TARGET_READ_SP generic_target_read_sp
#endif

CORE_ADDR
generic_target_read_sp ()
{
#ifdef SP_REGNUM
  if (SP_REGNUM >= 0)
    return read_register (SP_REGNUM);
#endif
  fatal ("generic_target_read_sp");
}

d1068 1
d1070 2
a1071 4
}

#ifndef TARGET_WRITE_SP
#define TARGET_WRITE_SP generic_target_write_sp
a1072 13

void
generic_target_write_sp (val)
     CORE_ADDR val;
{
#ifdef SP_REGNUM
  if (SP_REGNUM >= 0)
    {
      write_register (SP_REGNUM, val);
      return;
    }
#endif
  fatal ("generic_target_write_sp");
d1079 1
d1081 2
a1082 4
}

#ifndef TARGET_READ_FP
#define TARGET_READ_FP generic_target_read_fp
a1083 9

CORE_ADDR
generic_target_read_fp ()
{
#ifdef FP_REGNUM
  if (FP_REGNUM >= 0)
    return read_register (FP_REGNUM);
#endif
  fatal ("generic_target_read_fp");
d1089 1
d1091 2
a1092 4
}

#ifndef TARGET_WRITE_FP
#define TARGET_WRITE_FP generic_target_write_fp
a1093 13

void
generic_target_write_fp (val)
     CORE_ADDR val;
{
#ifdef FP_REGNUM
  if (FP_REGNUM >= 0)
    {
      write_register (FP_REGNUM, val);
      return;
    }
#endif
  fatal ("generic_target_write_fp");
d1100 1
d1102 3
a1642 4

  register_gdbarch_swap (&registers, sizeof (registers), NULL);
  register_gdbarch_swap (&register_valid, sizeof (register_valid), NULL);
  register_gdbarch_swap (NULL, 0, build_findvar);
@


1.1.1.5
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d31 1
a31 1
#include "symfile.h"		/* for overlay functions */
d46 1
a46 1
static int read_relative_register_raw_bytes_for_frame PARAMS ((int regnum, char *myaddr, struct frame_info * frame));
d56 1
a56 1
you lose
d59 1
a59 1
  LONGEST
d66 1
a66 1
  unsigned char *startaddr = (unsigned char *) addr;
d80 1
a80 1
      retval = ((LONGEST) * p ^ 0x80) - 0x80;
d88 1
a88 1
      retval = ((LONGEST) * p ^ 0x80) - 0x80;
d102 1
a102 1
  unsigned char *startaddr = (unsigned char *) addr;
d185 1
a185 1
  return (CORE_ADDR) extract_unsigned_integer (addr, len);
d195 1
a195 1
  unsigned char *startaddr = (unsigned char *) addr;
d225 1
a225 1
  unsigned char *startaddr = (unsigned char *) addr;
d412 2
a413 2

  if (REGISTER_IN_WINDOW_P (regnum))
d416 2
a417 3
      if (!frame1)
	return 0;		/* Registers of this frame are active.  */

d419 1
a419 1
         current frame.  */
d421 2
a422 2
	frame1 = frame;

d488 1
a488 1
	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), (LONGEST) addr);
d541 2
a542 2
      store_address (myaddr, REGISTER_RAW_SIZE (FP_REGNUM),
		     (LONGEST) FRAME_FP (frame));
d548 1
a548 1
		      regnum, (enum lval_type *) NULL);
d550 2
a551 2
  if (register_valid[regnum] < 0)
    return 1;			/* register value not available */
d567 1
a567 1
  return read_relative_register_raw_bytes_for_frame (regnum, myaddr,
d592 1
a592 1
    return NULL;		/* register value not available */
d675 2
a676 2
   main reason this is necessary is that register sizes can vary, so a simple
   index won't suffice.]  It is far better to call read_register_gen if you
d729 1
a729 1
         Update it from the target.  */
d783 1
a783 1
  size = REGISTER_RAW_SIZE (regno);
d788 1
a788 1
  if (register_valid[regno]
d791 1
a791 1

d796 1
a796 1
  register_valid[regno] = 1;
d842 1
a842 1
         from the target before scribbling on it.  */
d873 2
a874 2
  return (CORE_ADDR) extract_address (&registers[REGISTER_BYTE (regno)],
				      REGISTER_RAW_SIZE (regno));
d920 1
a920 1
  size = REGISTER_RAW_SIZE (regno);
d922 1
a922 1
  store_signed_integer (buf, size, (LONGEST) val);
d927 1
a927 1
  if (register_valid[regno]
d930 1
a930 1

d935 1
a935 1
  register_valid[regno] = 1;
d970 1
a970 1
 */
d994 1
a994 1
  CLEAN_UP_REGISTER_VALUE (regno, &registers[REGISTER_BYTE (regno)]);
d1034 2
a1035 2
  int saved_inferior_pid;
  CORE_ADDR pc_val;
d1040 1
a1040 1

d1083 1
a1083 1
  int saved_inferior_pid;
d1088 1
a1088 1

d1203 1
a1203 1
         we failed to consider one.  */
d1224 2
a1225 2
         even if some *uses* of that address wouldn't work so well without
         the right frame.  */
d1258 1
a1258 2
  if (frame == NULL)
    frame = selected_frame;
d1272 3
a1274 3
	store_address (VALUE_CONTENTS_RAW (v), len,
	     (LONGEST) symbol_overlayed_address (SYMBOL_VALUE_ADDRESS (var),
						 SYMBOL_BFD_SECTION (var)));
d1277 1
a1277 1
		       (LONGEST) SYMBOL_VALUE_ADDRESS (var));
d1301 1
a1301 1
         execution yet, so check for that. */
d1303 1
a1303 1
	error ("\
d1306 1
a1306 1

d1350 1
a1350 1

d1353 3
a1355 3
	char buf[MAX_REGISTER_RAW_SIZE];

	get_saved_register (buf, NULL, NULL, frame, SYMBOL_BASEREG (var),
d1357 3
a1359 3
	addr = extract_address (buf, REGISTER_RAW_SIZE (SYMBOL_BASEREG (var)));
	addr += SYMBOL_VALUE (var);
	break;
d1361 1
a1361 1

d1368 1
a1368 1
	VALUE_ADDRESS (v) = symbol_overlayed_address
d1389 1
a1389 1
					  regno,
d1395 1
a1395 1
	    addr = value_as_pointer (regval);
d1451 1
a1451 1
  char raw_buffer[MAX_REGISTER_RAW_SIZE];
d1474 1
a1474 1
    )
d1477 1
a1477 1

d1503 1
a1503 4
	    case R0_REGNUM:
	    case R1_REGNUM:
	    case R2_REGNUM:
	    case R3_REGNUM:
d1506 1
a1506 2
	    case R4_REGNUM:
	    case R5_REGNUM:
d1509 1
a1509 2
	    case R6_REGNUM:
	    case R7_REGNUM:
d1552 1
a1552 1
#endif /* GDB_TARGET_IS_H8500 */
d1565 2
a1566 2
	    if (register_valid[local_regnum] == -1)
	      return NULL;	/* register value not available */
d1575 1
a1575 1

d1609 3
a1611 3
         an integral number of registers.  Otherwise, you'd need to do
         some fiddling with the last register copied here for little
         endian machines.  */
d1619 1
a1619 1
      REGISTER_CONVERT_TO_TYPE (regnum, type, VALUE_CONTENTS_RAW (v));
d1631 1
a1631 1
    return NULL;		/* register value not available */
d1638 1
a1638 1

d1650 1
a1650 1
	  /* Big-endian, and we want less than full size.  */
d1656 1
a1656 1

d1687 1
a1687 1
      val = value_from_longest (lookup_pointer_type (type), (LONGEST) addr);
d1693 1
a1693 1
  switch (VALUE_LVAL (lazy_value))
d1706 1
a1706 1
  return 0;			/* For lint -- never reached */
d1708 1
a1709 1

@


1.1.1.6
log
@import gdb-1999-08-09 snapshot
@
text
@d609 3
a611 5
    internal_error ("Register \"%s\" (%d) has conflicting raw (%d) and virtual (%d) size",
		    REGISTER_NAME (regnum),
		    regnum,
		    REGISTER_RAW_SIZE (regnum),
		    REGISTER_VIRTUAL_SIZE (regnum));
d1028 1
a1028 1
  internal_error ("generic_target_read_pc");
d1076 1
a1076 1
  internal_error ("generic_target_write_pc");
d1116 1
a1116 1
  internal_error ("generic_target_read_sp");
d1140 1
a1140 1
  internal_error ("generic_target_write_sp");
d1161 1
a1161 1
  internal_error ("generic_target_read_fp");
d1185 1
a1185 1
  internal_error ("generic_target_write_fp");
d1612 1
a1612 1
	internal_error ("value_from_register: Value not stored anywhere!");
@


1.1.1.7
log
@import gdb-1999-09-08 snapshot
@
text
@a330 4
#ifdef TARGET_EXTRACT_FLOATING
  else if (TARGET_EXTRACT_FLOATING (addr, len, &dretval))
    return dretval;
#endif
a373 4
#ifdef TARGET_STORE_FLOATING
  else if (TARGET_STORE_FLOATING (addr, len, val))
    return;
#endif 
@


1.1.1.8
log
@import gdb-1999-12-06 snapshot
@
text
@d261 19
d683 14
a696 16
/* read_register_bytes and write_register_bytes are generally a *BAD*
   idea.  They are inefficient because they need to check for partial
   updates, which can only be done by scanning through all of the
   registers and seeing if the bytes that are being read/written fall
   inside of an invalid register.  [The main reason this is necessary
   is that register sizes can vary, so a simple index won't suffice.]
   It is far better to call read_register_gen and write_register_gen
   if you want to get at the raw register contents, as it only takes a
   regno as an argument, and therefore can't do a partial register
   update.

   Prior to the recent fixes to check for partial updates, both read
   and write_register_bytes always checked to see if any registers
   were stale, and then called target_fetch_registers (-1) to update
   the whole set.  This caused really slowed things down for remote
   targets.  */
d723 1
d734 4
a737 2
      if (regend <= inregbyte || inregend <= regstart)
	/* The range the user wants to read doesn't overlap with regno.  */
d742 1
d835 2
d841 5
a845 7
      /* Is this register completely outside the range the user is writing?  */
      if (myregend <= regstart || regend <= myregstart)
	/* do nothing */ ;		

      /* Is this register completely within the range the user is writing?  */
      else if (myregstart <= regstart && regend <= myregend)
	write_register_gen (regno, myaddr + (regstart - myregstart));
d847 1
a847 2
      /* The register partially overlaps the range being written.  */
      else
d849 3
a851 13
	  char regbuf[MAX_REGISTER_RAW_SIZE];
	  /* What's the overlap between this register's bytes and
             those the caller wants to write?  */
	  int overlapstart = max (regstart, myregstart);
	  int overlapend   = min (regend,   myregend);

	  /* We may be doing a partial update of an invalid register.
	     Update it from the target before scribbling on it.  */
	  read_register_gen (regno, regbuf);

	  memcpy (registers + overlapstart,
		  myaddr + (overlapstart - myregstart),
		  overlapend - overlapstart);
d853 13
a865 2
	  target_store_registers (regno);
	}
a867 1

@


1.1.1.9
log
@import gdb-2000-01-31 snapshot
@
text
@a1456 4
  /* Pointers on D10V are really only 16 bits, but we lie to gdb elsewhere... */
  if (GDB_TARGET_IS_D10V && TYPE_CODE (type) == TYPE_CODE_PTR)
    len = 2;

a1652 23
    }

  if (GDB_TARGET_IS_D10V
      && TYPE_CODE (type) == TYPE_CODE_PTR
      && TYPE_TARGET_TYPE (type)
      && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC))
    {
      /* pointer to function */
      unsigned long num;
      unsigned short snum;
      snum = (unsigned short) extract_unsigned_integer (VALUE_CONTENTS_RAW (v), 2);
      num = D10V_MAKE_IADDR (snum);
      store_address (VALUE_CONTENTS_RAW (v), 4, num);
    }
  else if (GDB_TARGET_IS_D10V
	   && TYPE_CODE (type) == TYPE_CODE_PTR)
    {
      /* pointer to data */
      unsigned long num;
      unsigned short snum;
      snum = (unsigned short) extract_unsigned_integer (VALUE_CONTENTS_RAW (v), 2);
      num = D10V_MAKE_DADDR (snum);
      store_address (VALUE_CONTENTS_RAW (v), 4, num);
@


