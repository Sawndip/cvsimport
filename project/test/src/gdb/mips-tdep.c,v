head	1.577;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.567
	gdb_7_6-2013-04-26-release:1.567
	gdb_7_6-branch:1.567.0.2
	gdb_7_6-2013-03-12-branchpoint:1.567
	gdb_7_5_1-2012-11-29-release:1.557
	gdb_7_5-2012-08-17-release:1.557
	gdb_7_5-branch:1.557.0.2
	gdb_7_5-2012-07-18-branchpoint:1.557
	gdb_7_4_1-2012-04-26-release:1.528.2.1
	gdb_7_4-2012-01-24-release:1.528.2.1
	gdb_7_4-branch:1.528.0.2
	gdb_7_4-2011-12-13-branchpoint:1.528
	gdb_7_3_1-2011-09-04-release:1.521
	gdb_7_3-2011-07-26-release:1.521
	gdb_7_3-branch:1.521.0.2
	gdb_7_3-2011-04-01-branchpoint:1.521
	gdb_7_2-2010-09-02-release:1.506
	gdb_7_2-branch:1.506.0.2
	gdb_7_2-2010-07-07-branchpoint:1.506
	gdb_7_1-2010-03-18-release:1.505
	gdb_7_1-branch:1.505.0.2
	gdb_7_1-2010-02-18-branchpoint:1.505
	gdb_7_0_1-2009-12-22-release:1.500
	gdb_7_0-2009-10-06-release:1.500
	gdb_7_0-branch:1.500.0.4
	gdb_7_0-2009-09-16-branchpoint:1.500
	arc-sim-20090309:1.469
	msnyder-checkpoint-072509-branch:1.500.0.2
	msnyder-checkpoint-072509-branchpoint:1.500
	arc-insight_6_8-branch:1.469.0.6
	arc-insight_6_8-branchpoint:1.469
	insight_6_8-branch:1.469.0.4
	insight_6_8-branchpoint:1.469
	reverse-20081226-branch:1.488.0.4
	reverse-20081226-branchpoint:1.488
	multiprocess-20081120-branch:1.488.0.2
	multiprocess-20081120-branchpoint:1.488
	reverse-20080930-branch:1.484.0.2
	reverse-20080930-branchpoint:1.484
	reverse-20080717-branch:1.476.0.2
	reverse-20080717-branchpoint:1.476
	msnyder-reverse-20080609-branch:1.475.0.2
	msnyder-reverse-20080609-branchpoint:1.475
	drow-reverse-20070409-branch:1.407.0.2
	drow-reverse-20070409-branchpoint:1.407
	gdb_6_8-2008-03-27-release:1.469
	gdb_6_8-branch:1.469.0.2
	gdb_6_8-2008-02-26-branchpoint:1.469
	gdb_6_7_1-2007-10-29-release:1.443.2.1
	gdb_6_7-2007-10-10-release:1.443.2.1
	gdb_6_7-branch:1.443.0.2
	gdb_6_7-2007-09-07-branchpoint:1.443
	insight_6_6-20070208-release:1.398
	gdb_6_6-2006-12-18-release:1.398
	gdb_6_6-branch:1.398.0.2
	gdb_6_6-2006-11-15-branchpoint:1.398
	insight_6_5-20061003-release:1.391
	gdb-csl-symbian-6_4_50_20060226-12:1.385.2.1.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.384
	nickrob-async-20060828-mergepoint:1.398
	gdb-csl-symbian-6_4_50_20060226-11:1.385.2.1.2.1
	gdb-csl-sourcerygxx-4_1-17:1.385.2.1
	gdb-csl-20060226-branch-local-2:1.385.2.1
	gdb-csl-sourcerygxx-4_1-14:1.385.2.1
	gdb-csl-sourcerygxx-4_1-13:1.385.2.1
	gdb-csl-sourcerygxx-4_1-12:1.385.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.385.2.1
	gdb_6_5-20060621-release:1.391
	gdb-csl-sourcerygxx-4_1-9:1.385.2.1
	gdb-csl-sourcerygxx-4_1-8:1.385.2.1
	gdb-csl-sourcerygxx-4_1-7:1.385.2.1
	gdb-csl-arm-2006q1-6:1.385.2.1
	gdb-csl-sourcerygxx-4_1-6:1.385.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.385.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.385.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.385.2.1.2.1
	gdb-csl-coldfire-4_1-11:1.385.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.385.2.1
	gdb-csl-coldfire-4_1-10:1.385.2.1
	gdb_6_5-branch:1.391.0.4
	gdb_6_5-2006-05-14-branchpoint:1.391
	gdb-csl-sourcerygxx-4_1-5:1.385.2.1
	nickrob-async-20060513-branch:1.391.0.2
	nickrob-async-20060513-branchpoint:1.391
	gdb-csl-sourcerygxx-4_1-4:1.385.2.1
	msnyder-reverse-20060502-branch:1.389.0.4
	msnyder-reverse-20060502-branchpoint:1.389
	gdb-csl-morpho-4_1-4:1.385.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.385.2.1
	readline_5_1-import-branch:1.389.0.2
	readline_5_1-import-branchpoint:1.389
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.385.2.1
	gdb-csl-symbian-20060226-branch:1.385.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.385.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.385.2.1
	msnyder-reverse-20060331-branch:1.388.0.2
	msnyder-reverse-20060331-branchpoint:1.388
	gdb-csl-available-20060303-branch:1.385.0.4
	gdb-csl-available-20060303-branchpoint:1.385
	gdb-csl-20060226-branch:1.385.0.2
	gdb-csl-20060226-branchpoint:1.385
	gdb_6_4-20051202-release:1.384
	msnyder-fork-checkpoint-branch:1.384.0.8
	msnyder-fork-checkpoint-branchpoint:1.384
	gdb-csl-gxxpro-6_3-branch:1.384.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.384
	gdb_6_4-branch:1.384.0.4
	gdb_6_4-2005-11-01-branchpoint:1.384
	gdb-csl-arm-20051020-branch:1.384.0.2
	gdb-csl-arm-20051020-branchpoint:1.384
	msnyder-tracepoint-checkpoint-branch:1.381.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.381
	gdb-csl-arm-20050325-2005-q1b:1.379
	gdb-csl-arm-20050325-2005-q1a:1.379
	csl-arm-20050325-branch:1.379.0.2
	csl-arm-20050325-branchpoint:1.379
	gdb-post-i18n-errorwarning-20050211:1.370
	gdb-pre-i18n-errorwarning-20050211:1.369
	gdb_6_3-20041109-release:1.335
	gdb_6_3-branch:1.335.0.2
	gdb_6_3-20041019-branchpoint:1.335
	drow_intercu-merge-20040921:1.324
	drow_intercu-merge-20040915:1.323
	jimb-gdb_6_2-e500-branch:1.300.0.6
	jimb-gdb_6_2-e500-branchpoint:1.300
	gdb_6_2-20040730-release:1.300
	gdb_6_2-branch:1.300.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.300
	gdb_6_1_1-20040616-release:1.283.4.1
	gdb_6_1-2004-04-05-release:1.283.4.1
	drow_intercu-merge-20040402:1.287
	drow_intercu-merge-20040327:1.286
	ezannoni_pie-20040323-branch:1.285.0.2
	ezannoni_pie-20040323-branchpoint:1.285
	cagney_tramp-20040321-mergepoint:1.283
	cagney_tramp-20040309-branch:1.283.0.6
	cagney_tramp-20040309-branchpoint:1.283
	gdb_6_1-branch:1.283.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.283
	drow_intercu-20040221-branch:1.283.0.2
	drow_intercu-20040221-branchpoint:1.283
	cagney_bfdfile-20040213-branch:1.282.0.2
	cagney_bfdfile-20040213-branchpoint:1.282
	drow-cplus-merge-20040208:1.276
	carlton_dictionary-20040126-merge:1.275
	cagney_bigcore-20040122-branch:1.275.0.2
	cagney_bigcore-20040122-branchpoint:1.275
	drow-cplus-merge-20040113:1.270
	drow-cplus-merge-20031224:1.262
	drow-cplus-merge-20031220:1.262
	carlton_dictionary-20031215-merge:1.262
	drow-cplus-merge-20031214:1.262
	carlton-dictionary-20031111-merge:1.243
	gdb_6_0-2003-10-04-release:1.221.2.3
	kettenis_sparc-20030918-branch:1.233.0.2
	kettenis_sparc-20030918-branchpoint:1.233
	carlton_dictionary-20030917-merge:1.233
	ezannoni_pie-20030916-branchpoint:1.232
	ezannoni_pie-20030916-branch:1.232.0.2
	cagney_x86i386-20030821-branch:1.225.0.2
	cagney_x86i386-20030821-branchpoint:1.225
	carlton_dictionary-20030805-merge:1.224
	carlton_dictionary-20030627-merge:1.222
	gdb_6_0-branch:1.221.0.2
	gdb_6_0-2003-06-23-branchpoint:1.221
	jimb-ppc64-linux-20030613-branch:1.214.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.214
	cagney_convert-20030606-branch:1.207.0.2
	cagney_convert-20030606-branchpoint:1.207
	cagney_writestrings-20030508-branch:1.197.0.4
	cagney_writestrings-20030508-branchpoint:1.197
	jimb-ppc64-linux-20030528-branch:1.201.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.201
	carlton_dictionary-20030523-merge:1.201
	cagney_fileio-20030521-branch:1.201.0.2
	cagney_fileio-20030521-branchpoint:1.201
	kettenis_i386newframe-20030517-mergepoint:1.201
	jimb-ppc64-linux-20030509-branch:1.197.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.197
	kettenis_i386newframe-20030504-mergepoint:1.194
	carlton_dictionary-20030430-merge:1.194
	kettenis_i386newframe-20030419-branch:1.191.0.2
	kettenis_i386newframe-20030419-branchpoint:1.191
	carlton_dictionary-20030416-merge:1.191
	cagney_frameaddr-20030409-mergepoint:1.187
	kettenis_i386newframe-20030406-branch:1.184.0.4
	kettenis_i386newframe-20030406-branchpoint:1.184
	cagney_frameaddr-20030403-branchpoint:1.184
	cagney_frameaddr-20030403-branch:1.184.0.2
	cagney_framebase-20030330-mergepoint:1.180
	cagney_framebase-20030326-branch:1.177.0.2
	cagney_framebase-20030326-branchpoint:1.177
	cagney_lazyid-20030317-branch:1.172.0.2
	cagney_lazyid-20030317-branchpoint:1.172
	kettenis-i386newframe-20030316-mergepoint:1.172
	offbyone-20030313-branch:1.170.0.2
	offbyone-20030313-branchpoint:1.170
	kettenis-i386newframe-20030308-branch:1.168.0.4
	kettenis-i386newframe-20030308-branchpoint:1.168
	carlton_dictionary-20030305-merge:1.168
	cagney_offbyone-20030303-branch:1.168.0.2
	cagney_offbyone-20030303-branchpoint:1.168
	carlton_dictionary-20030207-merge:1.161
	interps-20030203-mergepoint:1.161
	interps-20030202-branch:1.161.0.2
	interps-20030202-branchpoint:1.161
	cagney-unwind-20030108-branch:1.159.0.2
	cagney-unwind-20030108-branchpoint:1.159
	carlton_dictionary-20021223-merge:1.148
	gdb_5_3-2002-12-12-release:1.119.6.1
	carlton_dictionary-20021115-merge:1.133
	kseitz_interps-20021105-merge:1.132
	kseitz_interps-20021103-merge:1.132
	drow-cplus-merge-20021020:1.130
	drow-cplus-merge-20021025:1.130
	carlton_dictionary-20021025-merge:1.130
	carlton_dictionary-20021011-merge:1.130
	drow-cplus-branch:1.129.0.2
	drow-cplus-branchpoint:1.129
	kseitz_interps-20020930-merge:1.127
	carlton_dictionary-20020927-merge:1.127
	carlton_dictionary-branch:1.126.0.2
	carlton_dictionary-20020920-branchpoint:1.126
	gdb_5_3-branch:1.119.0.6
	gdb_5_3-2002-09-04-branchpoint:1.119
	kseitz_interps-20020829-merge:1.119
	cagney_sysregs-20020825-branch:1.119.0.4
	cagney_sysregs-20020825-branchpoint:1.119
	readline_4_3-import-branch:1.119.0.2
	readline_4_3-import-branchpoint:1.119
	gdb_5_2_1-2002-07-23-release:1.66
	kseitz_interps-20020528-branch:1.74.0.2
	kseitz_interps-20020528-branchpoint:1.74
	cagney_regbuf-20020515-branch:1.73.0.2
	cagney_regbuf-20020515-branchpoint:1.73
	jimb-macro-020506-branch:1.71.0.2
	jimb-macro-020506-branchpoint:1.71
	gdb_5_2-2002-04-29-release:1.66
	gdb_5_2-branch:1.66.0.2
	gdb_5_2-2002-03-03-branchpoint:1.66
	gdb_5_1_1-2002-01-24-release:1.59
	gdb_5_1_0_1-2002-01-03-release:1.59
	cygnus_cvs_20020108_pre:1.63
	gdb_5_1_0_1-2002-01-03-branchpoint:1.59
	gdb_5_1_0_1-2002-01-03-branch:1.59.0.6
	gdb_5_1-2001-11-21-release:1.59
	gdb_s390-2001-09-26-branch:1.59.0.4
	gdb_s390-2001-09-26-branchpoint:1.59
	gdb_5_1-2001-07-29-branch:1.59.0.2
	gdb_5_1-2001-07-29-branchpoint:1.59
	dberlin-typesystem-branch:1.56.0.2
	dberlin-typesystem-branchpoint:1.56
	gdb-post-ptid_t-2001-05-03:1.48
	gdb-pre-ptid_t-2001-05-03:1.47
	insight-precleanup-2001-01-01:1.37
	gdb-post-protoization-2000-07-29:1.29
	gdb-pre-protoization-2000-07-29:1.28
	gdb-premipsmulti-2000-06-06-branch:1.11.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.11
	gdb-post-params-removal-2000-06-04:1.11
	gdb-pre-params-removal-2000-06-04:1.11
	gdb-post-params-removal-2000-05-28:1.11
	gdb-pre-params-removal-2000-05-28:1.10
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3
	repo-unification-2000-02-06:1.1.1.14
	insight-2000-02-04:1.1.1.14
	gdb-2000-02-04:1.1.1.14
	gdb-2000-02-02:1.1.1.14
	gdb-2000-02-01:1.1.1.14
	gdb-2000-01-31:1.1.1.14
	gdb-2000-01-26:1.1.1.14
	gdb-2000-01-24:1.1.1.14
	gdb-2000-01-17:1.1.1.14
	gdb-2000-01-10:1.1.1.14
	gdb-2000-01-05:1.1.1.14
	gdb-1999-12-21:1.1.1.14
	gdb-1999-12-13:1.1.1.13
	gdb-1999-12-07:1.1.1.12
	gdb-1999-12-06:1.1.1.12
	gdb-1999-11-16:1.1.1.11
	gdb-1999-11-08:1.1.1.11
	gdb-1999-11-01:1.1.1.11
	gdb-1999-10-25:1.1.1.11
	gdb-1999-10-18:1.1.1.11
	gdb-1999-10-11:1.1.1.11
	gdb-1999-10-04:1.1.1.11
	gdb-1999-09-28:1.1.1.10
	gdb-1999-09-21:1.1.1.10
	gdb-1999-09-13:1.1.1.10
	gdb-1999-09-08:1.1.1.10
	gdb-1999-08-30:1.1.1.9
	gdb-1999-08-23:1.1.1.9
	gdb-1999-08-16:1.1.1.8
	gdb-1999-08-09:1.1.1.8
	gdb-1999-08-02:1.1.1.8
	gdb-1999-07-26:1.1.1.8
	gdb-1999-07-19:1.1.1.8
	gdb-1999-07-12:1.1.1.8
	gdb-post-reformat-19990707:1.1.1.7
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.7
	gdb-pre-reformat-19990707:1.1.1.6
	gdb-1999-07-07:1.1.1.6
	gdb-1999-07-05:1.1.1.5
	gdb-1999-06-28:1.1.1.5
	gdb-1999-06-21:1.1.1.5
	gdb-1999-06-14:1.1.1.5
	gdb-1999-06-07:1.1.1.4
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.577
date	2013.07.24.22.23.12;	author macro;	state Exp;
branches;
next	1.576;

1.576
date	2013.07.15.15.07.29;	author macro;	state Exp;
branches;
next	1.575;

1.575
date	2013.06.26.15.37.49;	author macro;	state Exp;
branches;
next	1.574;

1.574
date	2013.06.26.15.10.33;	author macro;	state Exp;
branches;
next	1.573;

1.573
date	2013.06.26.15.00.10;	author macro;	state Exp;
branches;
next	1.572;

1.572
date	2013.06.24.23.55.45;	author macro;	state Exp;
branches;
next	1.571;

1.571
date	2013.06.24.22.18.31;	author macro;	state Exp;
branches;
next	1.570;

1.570
date	2013.04.19.15.21.24;	author palves;	state Exp;
branches;
next	1.569;

1.569
date	2013.04.19.15.15.21;	author palves;	state Exp;
branches;
next	1.568;

1.568
date	2013.04.08.19.59.09;	author tromey;	state Exp;
branches;
next	1.567;

1.567
date	2013.02.24.12.54.04;	author macro;	state Exp;
branches;
next	1.566;

1.566
date	2013.01.01.06.32.47;	author brobecke;	state Exp;
branches;
next	1.565;

1.565
date	2012.12.19.20.57.55;	author andreast;	state Exp;
branches;
next	1.564;

1.564
date	2012.11.12.21.59.07;	author brobecke;	state Exp;
branches;
next	1.563;

1.563
date	2012.11.09.19.58.00;	author tromey;	state Exp;
branches;
next	1.562;

1.562
date	2012.09.17.08.52.18;	author siddhesh;	state Exp;
branches;
next	1.561;

1.561
date	2012.08.19.22.22.49;	author pinskia;	state Exp;
branches;
next	1.560;

1.560
date	2012.08.19.22.21.21;	author pinskia;	state Exp;
branches;
next	1.559;

1.559
date	2012.08.19.22.20.29;	author pinskia;	state Exp;
branches;
next	1.558;

1.558
date	2012.08.02.09.36.39;	author qiyao;	state Exp;
branches;
next	1.557;

1.557
date	2012.06.11.10.11.14;	author macro;	state Exp;
branches;
next	1.556;

1.556
date	2012.06.06.21.34.12;	author macro;	state Exp;
branches;
next	1.555;

1.555
date	2012.06.06.21.27.37;	author macro;	state Exp;
branches;
next	1.554;

1.554
date	2012.06.06.19.34.31;	author macro;	state Exp;
branches;
next	1.553;

1.553
date	2012.05.18.23.53.19;	author macro;	state Exp;
branches;
next	1.552;

1.552
date	2012.05.18.23.46.40;	author macro;	state Exp;
branches;
next	1.551;

1.551
date	2012.05.18.21.02.49;	author sergiodj;	state Exp;
branches;
next	1.550;

1.550
date	2012.05.18.12.43.05;	author macro;	state Exp;
branches;
next	1.549;

1.549
date	2012.05.18.12.30.26;	author macro;	state Exp;
branches;
next	1.548;

1.548
date	2012.05.16.14.35.06;	author macro;	state Exp;
branches;
next	1.547;

1.547
date	2012.05.14.09.32.03;	author macro;	state Exp;
branches;
next	1.546;

1.546
date	2012.05.09.14.29.02;	author brobecke;	state Exp;
branches;
next	1.545;

1.545
date	2012.04.26.16.56.16;	author macro;	state Exp;
branches;
next	1.544;

1.544
date	2012.04.24.19.56.02;	author macro;	state Exp;
branches;
next	1.543;

1.543
date	2012.04.24.19.44.16;	author macro;	state Exp;
branches;
next	1.542;

1.542
date	2012.04.23.16.00.19;	author macro;	state Exp;
branches;
next	1.541;

1.541
date	2012.04.20.23.31.39;	author macro;	state Exp;
branches;
next	1.540;

1.540
date	2012.04.20.23.01.51;	author macro;	state Exp;
branches;
next	1.539;

1.539
date	2012.04.10.23.06.57;	author macro;	state Exp;
branches;
next	1.538;

1.538
date	2012.04.10.22.54.24;	author macro;	state Exp;
branches;
next	1.537;

1.537
date	2012.03.02.19.14.30;	author brobecke;	state Exp;
branches;
next	1.536;

1.536
date	2012.03.01.23.35.46;	author macro;	state Exp;
branches;
next	1.535;

1.535
date	2012.03.01.22.52.03;	author macro;	state Exp;
branches;
next	1.534;

1.534
date	2012.03.01.22.37.51;	author macro;	state Exp;
branches;
next	1.533;

1.533
date	2012.03.01.22.19.45;	author macro;	state Exp;
branches;
next	1.532;

1.532
date	2012.02.27.23.05.40;	author macro;	state Exp;
branches;
next	1.531;

1.531
date	2012.02.02.20.19.16;	author devans;	state Exp;
branches;
next	1.530;

1.530
date	2012.01.28.18.08.18;	author jkratoch;	state Exp;
branches;
next	1.529;

1.529
date	2012.01.04.08.17.08;	author brobecke;	state Exp;
branches;
next	1.528;

1.528
date	2011.12.08.19.03.24;	author macro;	state Exp;
branches
	1.528.2.1;
next	1.527;

1.527
date	2011.12.08.18.55.48;	author macro;	state Exp;
branches;
next	1.526;

1.526
date	2011.12.07.00.17.23;	author macro;	state Exp;
branches;
next	1.525;

1.525
date	2011.12.06.23.49.56;	author macro;	state Exp;
branches;
next	1.524;

1.524
date	2011.12.06.23.36.58;	author macro;	state Exp;
branches;
next	1.523;

1.523
date	2011.12.06.23.19.43;	author macro;	state Exp;
branches;
next	1.522;

1.522
date	2011.11.24.15.56.25;	author macro;	state Exp;
branches;
next	1.521;

1.521
date	2011.03.18.18.52.31;	author palves;	state Exp;
branches;
next	1.520;

1.520
date	2011.03.18.18.42.41;	author palves;	state Exp;
branches;
next	1.519;

1.519
date	2011.03.18.18.38.43;	author palves;	state Exp;
branches;
next	1.518;

1.518
date	2011.02.26.02.07.08;	author msnyder;	state Exp;
branches;
next	1.517;

1.517
date	2011.01.28.15.42.01;	author palves;	state Exp;
branches;
next	1.516;

1.516
date	2011.01.09.03.20.33;	author msnyder;	state Exp;
branches;
next	1.515;

1.515
date	2011.01.01.15.33.11;	author brobecke;	state Exp;
branches;
next	1.514;

1.514
date	2010.12.28.16.00.13;	author teawater;	state Exp;
branches;
next	1.513;

1.513
date	2010.12.27.08.17.34;	author teawater;	state Exp;
branches;
next	1.512;

1.512
date	2010.12.17.21.39.27;	author kevinb;	state Exp;
branches;
next	1.511;

1.511
date	2010.12.16.22.50.48;	author kevinb;	state Exp;
branches;
next	1.510;

1.510
date	2010.12.15.20.53.08;	author kevinb;	state Exp;
branches;
next	1.509;

1.509
date	2010.12.14.21.07.50;	author kevinb;	state Exp;
branches;
next	1.508;

1.508
date	2010.11.28.04.31.24;	author jkratoch;	state Exp;
branches;
next	1.507;

1.507
date	2010.08.05.03.03.36;	author teawater;	state Exp;
branches;
next	1.506;

1.506
date	2010.07.01.15.36.16;	author palves;	state Exp;
branches
	1.506.2.1;
next	1.505;

1.505
date	2010.01.09.04.42.53;	author brobecke;	state Exp;
branches;
next	1.504;

1.504
date	2010.01.09.04.38.29;	author brobecke;	state Exp;
branches;
next	1.503;

1.503
date	2010.01.01.07.31.37;	author brobecke;	state Exp;
branches;
next	1.502;

1.502
date	2009.11.13.22.48.11;	author drow;	state Exp;
branches;
next	1.501;

1.501
date	2009.10.19.09.51.41;	author palves;	state Exp;
branches;
next	1.500;

1.500
date	2009.07.02.17.25.55;	author uweigand;	state Exp;
branches;
next	1.499;

1.499
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.498;

1.498
date	2009.07.02.17.12.25;	author uweigand;	state Exp;
branches;
next	1.497;

1.497
date	2009.07.02.12.48.54;	author uweigand;	state Exp;
branches;
next	1.496;

1.496
date	2009.07.02.12.46.19;	author uweigand;	state Exp;
branches;
next	1.495;

1.495
date	2009.06.17.18.43.24;	author uweigand;	state Exp;
branches;
next	1.494;

1.494
date	2009.05.28.00.53.51;	author tromey;	state Exp;
branches;
next	1.493;

1.493
date	2009.05.11.11.13.08;	author muller;	state Exp;
branches;
next	1.492;

1.492
date	2009.05.05.13.24.49;	author uweigand;	state Exp;
branches;
next	1.491;

1.491
date	2009.04.01.19.13.42;	author aristovski;	state Exp;
branches;
next	1.490;

1.490
date	2009.02.22.01.02.17;	author palves;	state Exp;
branches;
next	1.489;

1.489
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.488;

1.488
date	2008.10.28.17.19.56;	author tromey;	state Exp;
branches;
next	1.487;

1.487
date	2008.10.21.19.34.44;	author jkratoch;	state Exp;
branches;
next	1.486;

1.486
date	2008.10.02.15.48.06;	author drow;	state Exp;
branches;
next	1.485;

1.485
date	2008.10.01.16.41.27;	author tromey;	state Exp;
branches;
next	1.484;

1.484
date	2008.09.22.15.20.08;	author palves;	state Exp;
branches;
next	1.483;

1.483
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.482;

1.482
date	2008.09.05.11.46.12;	author uweigand;	state Exp;
branches;
next	1.481;

1.481
date	2008.09.05.11.43.10;	author uweigand;	state Exp;
branches;
next	1.480;

1.480
date	2008.09.05.11.42.31;	author uweigand;	state Exp;
branches;
next	1.479;

1.479
date	2008.08.26.17.21.29;	author uweigand;	state Exp;
branches;
next	1.478;

1.478
date	2008.07.27.20.52.42;	author drow;	state Exp;
branches;
next	1.477;

1.477
date	2008.07.26.01.19.34;	author jsm28;	state Exp;
branches;
next	1.476;

1.476
date	2008.07.14.11.25.11;	author deuling;	state Exp;
branches;
next	1.475;

1.475
date	2008.06.03.10.53.34;	author jsm28;	state Exp;
branches;
next	1.474;

1.474
date	2008.05.16.00.27.23;	author drow;	state Exp;
branches;
next	1.473;

1.473
date	2008.04.30.21.25.16;	author drow;	state Exp;
branches;
next	1.472;

1.472
date	2008.04.22.11.03.42;	author corinna;	state Exp;
branches;
next	1.471;

1.471
date	2008.03.15.00.00.48;	author kevinb;	state Exp;
branches;
next	1.470;

1.470
date	2008.03.13.12.22.13;	author drow;	state Exp;
branches;
next	1.469;

1.469
date	2008.02.20.14.34.43;	author deuling;	state Exp;
branches;
next	1.468;

1.468
date	2008.01.11.13.20.02;	author deuling;	state Exp;
branches;
next	1.467;

1.467
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.466;

1.466
date	2007.12.20.17.13.57;	author macro;	state Exp;
branches;
next	1.465;

1.465
date	2007.12.07.15.07.12;	author macro;	state Exp;
branches;
next	1.464;

1.464
date	2007.12.06.16.33.00;	author deuling;	state Exp;
branches;
next	1.463;

1.463
date	2007.11.20.13.47.42;	author macro;	state Exp;
branches;
next	1.462;

1.462
date	2007.11.19.05.06.24;	author deuling;	state Exp;
branches;
next	1.461;

1.461
date	2007.11.17.00.57.41;	author uweigand;	state Exp;
branches;
next	1.460;

1.460
date	2007.11.09.05.32.19;	author deuling;	state Exp;
branches;
next	1.459;

1.459
date	2007.11.08.00.08.47;	author jsm28;	state Exp;
branches;
next	1.458;

1.458
date	2007.11.07.06.58.31;	author deuling;	state Exp;
branches;
next	1.457;

1.457
date	2007.11.07.06.33.00;	author deuling;	state Exp;
branches;
next	1.456;

1.456
date	2007.11.02.14.27.14;	author uweigand;	state Exp;
branches;
next	1.455;

1.455
date	2007.10.23.13.11.47;	author drow;	state Exp;
branches;
next	1.454;

1.454
date	2007.10.18.15.25.41;	author drow;	state Exp;
branches;
next	1.453;

1.453
date	2007.10.15.19.45.30;	author drow;	state Exp;
branches;
next	1.452;

1.452
date	2007.10.10.17.03.36;	author uweigand;	state Exp;
branches;
next	1.451;

1.451
date	2007.10.08.13.15.00;	author macro;	state Exp;
branches;
next	1.450;

1.450
date	2007.10.02.15.17.44;	author drow;	state Exp;
branches;
next	1.449;

1.449
date	2007.09.26.11.36.30;	author macro;	state Exp;
branches;
next	1.448;

1.448
date	2007.09.25.16.08.17;	author macro;	state Exp;
branches;
next	1.447;

1.447
date	2007.09.21.15.54.58;	author macro;	state Exp;
branches;
next	1.446;

1.446
date	2007.09.20.15.34.19;	author macro;	state Exp;
branches;
next	1.445;

1.445
date	2007.09.19.14.45.39;	author drow;	state Exp;
branches;
next	1.444;

1.444
date	2007.09.10.21.14.11;	author drow;	state Exp;
branches;
next	1.443;

1.443
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches
	1.443.2.1;
next	1.442;

1.442
date	2007.08.22.15.16.56;	author drow;	state Exp;
branches;
next	1.441;

1.441
date	2007.08.22.15.13.04;	author drow;	state Exp;
branches;
next	1.440;

1.440
date	2007.07.20.17.29.59;	author macro;	state Exp;
branches;
next	1.439;

1.439
date	2007.07.20.15.31.56;	author macro;	state Exp;
branches;
next	1.438;

1.438
date	2007.07.20.15.19.39;	author macro;	state Exp;
branches;
next	1.437;

1.437
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.436;

1.436
date	2007.06.16.17.16.25;	author uweigand;	state Exp;
branches;
next	1.435;

1.435
date	2007.06.15.22.44.56;	author uweigand;	state Exp;
branches;
next	1.434;

1.434
date	2007.06.15.22.39.52;	author uweigand;	state Exp;
branches;
next	1.433;

1.433
date	2007.06.15.22.37.34;	author uweigand;	state Exp;
branches;
next	1.432;

1.432
date	2007.06.15.22.34.13;	author uweigand;	state Exp;
branches;
next	1.431;

1.431
date	2007.06.15.22.32.02;	author uweigand;	state Exp;
branches;
next	1.430;

1.430
date	2007.06.15.22.29.52;	author uweigand;	state Exp;
branches;
next	1.429;

1.429
date	2007.06.13.18.47.58;	author drow;	state Exp;
branches;
next	1.428;

1.428
date	2007.06.13.18.26.59;	author drow;	state Exp;
branches;
next	1.427;

1.427
date	2007.06.13.17.38.43;	author uweigand;	state Exp;
branches;
next	1.426;

1.426
date	2007.06.13.17.25.16;	author drow;	state Exp;
branches;
next	1.425;

1.425
date	2007.06.09.13.49.20;	author uweigand;	state Exp;
branches;
next	1.424;

1.424
date	2007.06.09.13.42.15;	author uweigand;	state Exp;
branches;
next	1.423;

1.423
date	2007.06.06.15.32.25;	author uweigand;	state Exp;
branches;
next	1.422;

1.422
date	2007.05.31.20.57.41;	author uweigand;	state Exp;
branches;
next	1.421;

1.421
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.420;

1.420
date	2007.05.17.13.28.55;	author macro;	state Exp;
branches;
next	1.419;

1.419
date	2007.05.16.14.16.31;	author drow;	state Exp;
branches;
next	1.418;

1.418
date	2007.05.14.17.23.54;	author drow;	state Exp;
branches;
next	1.417;

1.417
date	2007.05.14.15.16.59;	author uweigand;	state Exp;
branches;
next	1.416;

1.416
date	2007.05.03.17.51.19;	author kevinb;	state Exp;
branches;
next	1.415;

1.415
date	2007.05.02.13.39.51;	author macro;	state Exp;
branches;
next	1.414;

1.414
date	2007.04.18.08.22.33;	author macro;	state Exp;
branches;
next	1.413;

1.413
date	2007.04.17.17.57.03;	author macro;	state Exp;
branches;
next	1.412;

1.412
date	2007.04.17.16.25.49;	author macro;	state Exp;
branches;
next	1.411;

1.411
date	2007.04.17.16.05.25;	author macro;	state Exp;
branches;
next	1.410;

1.410
date	2007.04.17.14.48.49;	author macro;	state Exp;
branches;
next	1.409;

1.409
date	2007.04.14.18.10.54;	author uweigand;	state Exp;
branches;
next	1.408;

1.408
date	2007.04.12.14.52.19;	author uweigand;	state Exp;
branches;
next	1.407;

1.407
date	2007.03.30.22.50.33;	author palves;	state Exp;
branches;
next	1.406;

1.406
date	2007.03.30.09.16.52;	author macro;	state Exp;
branches;
next	1.405;

1.405
date	2007.03.07.21.32.47;	author brobecke;	state Exp;
branches;
next	1.404;

1.404
date	2007.02.27.20.17.19;	author drow;	state Exp;
branches;
next	1.403;

1.403
date	2007.01.29.17.31.06;	author drow;	state Exp;
branches;
next	1.402;

1.402
date	2007.01.21.17.37.51;	author drow;	state Exp;
branches;
next	1.401;

1.401
date	2007.01.09.17.58.52;	author drow;	state Exp;
branches;
next	1.400;

1.400
date	2007.01.03.18.05.43;	author drow;	state Exp;
branches;
next	1.399;

1.399
date	2006.11.28.22.14.31;	author drow;	state Exp;
branches;
next	1.398;

1.398
date	2006.08.08.21.32.37;	author brobecke;	state Exp;
branches;
next	1.397;

1.397
date	2006.07.13.13.14.54;	author corinna;	state Exp;
branches;
next	1.396;

1.396
date	2006.06.19.18.50.09;	author msnyder;	state Exp;
branches;
next	1.395;

1.395
date	2006.06.13.18.17.20;	author fnf;	state Exp;
branches;
next	1.394;

1.394
date	2006.06.08.19.22.46;	author msnyder;	state Exp;
branches;
next	1.393;

1.393
date	2006.05.31.23.15.50;	author msnyder;	state Exp;
branches;
next	1.392;

1.392
date	2006.05.19.20.42.47;	author fnf;	state Exp;
branches;
next	1.391;

1.391
date	2006.05.05.18.04.04;	author fnf;	state Exp;
branches
	1.391.2.1;
next	1.390;

1.390
date	2006.05.05.17.50.33;	author fnf;	state Exp;
branches;
next	1.389;

1.389
date	2006.04.18.19.20.06;	author drow;	state Exp;
branches;
next	1.388;

1.388
date	2006.03.15.16.59.54;	author drow;	state Exp;
branches;
next	1.387;

1.387
date	2006.03.15.16.55.05;	author drow;	state Exp;
branches;
next	1.386;

1.386
date	2006.03.15.16.37.52;	author drow;	state Exp;
branches;
next	1.385;

1.385
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches
	1.385.2.1;
next	1.384;

1.384
date	2005.09.21.20.45.46;	author kettenis;	state Exp;
branches;
next	1.383;

1.383
date	2005.07.01.19.29.46;	author kettenis;	state Exp;
branches;
next	1.382;

1.382
date	2005.06.25.11.58.35;	author kettenis;	state Exp;
branches;
next	1.381;

1.381
date	2005.05.14.19.43.18;	author kettenis;	state Exp;
branches;
next	1.380;

1.380
date	2005.05.09.03.36.10;	author drow;	state Exp;
branches;
next	1.379;

1.379
date	2005.03.17.18.07.46;	author kettenis;	state Exp;
branches;
next	1.378;

1.378
date	2005.03.11.20.27.56;	author jimb;	state Exp;
branches;
next	1.377;

1.377
date	2005.02.21.04.31.58;	author cagney;	state Exp;
branches;
next	1.376;

1.376
date	2005.02.17.13.49.54;	author cagney;	state Exp;
branches;
next	1.375;

1.375
date	2005.02.16.17.20.58;	author cagney;	state Exp;
branches;
next	1.374;

1.374
date	2005.02.15.15.49.13;	author cagney;	state Exp;
branches;
next	1.373;

1.373
date	2005.02.14.18.10.08;	author cagney;	state Exp;
branches;
next	1.372;

1.372
date	2005.02.14.16.18.41;	author cagney;	state Exp;
branches;
next	1.371;

1.371
date	2005.02.11.18.13.51;	author cagney;	state Exp;
branches;
next	1.370;

1.370
date	2005.02.11.04.05.59;	author cagney;	state Exp;
branches;
next	1.369;

1.369
date	2005.02.10.17.32.49;	author cagney;	state Exp;
branches;
next	1.368;

1.368
date	2005.02.09.23.14.59;	author cagney;	state Exp;
branches;
next	1.367;

1.367
date	2005.02.07.00.09.54;	author cagney;	state Exp;
branches;
next	1.366;

1.366
date	2005.01.27.21.00.58;	author cagney;	state Exp;
branches;
next	1.365;

1.365
date	2005.01.05.15.43.44;	author cagney;	state Exp;
branches;
next	1.364;

1.364
date	2004.11.13.02.15.32;	author cagney;	state Exp;
branches;
next	1.363;

1.363
date	2004.11.10.17.48.23;	author kettenis;	state Exp;
branches;
next	1.362;

1.362
date	2004.10.31.21.51.58;	author cagney;	state Exp;
branches;
next	1.361;

1.361
date	2004.10.31.20.24.32;	author cagney;	state Exp;
branches;
next	1.360;

1.360
date	2004.10.31.19.25.49;	author cagney;	state Exp;
branches;
next	1.359;

1.359
date	2004.10.31.17.38.15;	author cagney;	state Exp;
branches;
next	1.358;

1.358
date	2004.10.31.16.14.00;	author cagney;	state Exp;
branches;
next	1.357;

1.357
date	2004.10.31.03.11.54;	author cagney;	state Exp;
branches;
next	1.356;

1.356
date	2004.10.31.02.59.21;	author cagney;	state Exp;
branches;
next	1.355;

1.355
date	2004.10.30.23.22.53;	author cagney;	state Exp;
branches;
next	1.354;

1.354
date	2004.10.30.23.08.17;	author cagney;	state Exp;
branches;
next	1.353;

1.353
date	2004.10.30.22.54.40;	author cagney;	state Exp;
branches;
next	1.352;

1.352
date	2004.10.30.22.36.34;	author cagney;	state Exp;
branches;
next	1.351;

1.351
date	2004.10.30.22.11.17;	author cagney;	state Exp;
branches;
next	1.350;

1.350
date	2004.10.30.21.16.09;	author cagney;	state Exp;
branches;
next	1.349;

1.349
date	2004.10.30.20.54.53;	author cagney;	state Exp;
branches;
next	1.348;

1.348
date	2004.10.30.20.26.25;	author cagney;	state Exp;
branches;
next	1.347;

1.347
date	2004.10.30.20.11.35;	author cagney;	state Exp;
branches;
next	1.346;

1.346
date	2004.10.30.19.58.11;	author cagney;	state Exp;
branches;
next	1.345;

1.345
date	2004.10.30.19.06.50;	author cagney;	state Exp;
branches;
next	1.344;

1.344
date	2004.10.30.17.53.46;	author cagney;	state Exp;
branches;
next	1.343;

1.343
date	2004.10.30.17.10.14;	author cagney;	state Exp;
branches;
next	1.342;

1.342
date	2004.10.30.16.53.22;	author cagney;	state Exp;
branches;
next	1.341;

1.341
date	2004.10.30.16.27.43;	author cagney;	state Exp;
branches;
next	1.340;

1.340
date	2004.10.30.15.55.36;	author cagney;	state Exp;
branches;
next	1.339;

1.339
date	2004.10.30.14.31.19;	author kettenis;	state Exp;
branches;
next	1.338;

1.338
date	2004.10.27.19.50.24;	author kettenis;	state Exp;
branches;
next	1.337;

1.337
date	2004.10.26.14.43.59;	author cagney;	state Exp;
branches;
next	1.336;

1.336
date	2004.10.26.14.24.37;	author cagney;	state Exp;
branches;
next	1.335;

1.335
date	2004.10.15.07.25.03;	author brobecke;	state Exp;
branches;
next	1.334;

1.334
date	2004.10.15.07.09.09;	author brobecke;	state Exp;
branches;
next	1.333;

1.333
date	2004.10.15.04.29.23;	author brobecke;	state Exp;
branches;
next	1.332;

1.332
date	2004.10.14.22.34.25;	author brobecke;	state Exp;
branches;
next	1.331;

1.331
date	2004.10.11.02.27.13;	author brobecke;	state Exp;
branches;
next	1.330;

1.330
date	2004.10.11.02.17.52;	author brobecke;	state Exp;
branches;
next	1.329;

1.329
date	2004.10.11.02.04.22;	author brobecke;	state Exp;
branches;
next	1.328;

1.328
date	2004.10.11.01.00.57;	author brobecke;	state Exp;
branches;
next	1.327;

1.327
date	2004.10.07.17.17.08;	author drow;	state Exp;
branches;
next	1.326;

1.326
date	2004.10.01.00.43.21;	author brobecke;	state Exp;
branches;
next	1.325;

1.325
date	2004.10.01.00.20.13;	author brobecke;	state Exp;
branches;
next	1.324;

1.324
date	2004.09.16.00.35.55;	author brobecke;	state Exp;
branches;
next	1.323;

1.323
date	2004.09.13.14.05.59;	author cagney;	state Exp;
branches;
next	1.322;

1.322
date	2004.09.05.20.15.40;	author brobecke;	state Exp;
branches;
next	1.321;

1.321
date	2004.09.05.00.19.29;	author brobecke;	state Exp;
branches;
next	1.320;

1.320
date	2004.09.04.00.16.56;	author cagney;	state Exp;
branches;
next	1.319;

1.319
date	2004.09.03.23.47.23;	author cagney;	state Exp;
branches;
next	1.318;

1.318
date	2004.09.03.23.00.18;	author cagney;	state Exp;
branches;
next	1.317;

1.317
date	2004.09.03.22.41.27;	author cagney;	state Exp;
branches;
next	1.316;

1.316
date	2004.09.03.22.31.23;	author cagney;	state Exp;
branches;
next	1.315;

1.315
date	2004.09.03.22.18.17;	author cagney;	state Exp;
branches;
next	1.314;

1.314
date	2004.09.03.22.00.44;	author cagney;	state Exp;
branches;
next	1.313;

1.313
date	2004.09.02.22.57.49;	author brobecke;	state Exp;
branches;
next	1.312;

1.312
date	2004.09.01.20.42.44;	author brobecke;	state Exp;
branches;
next	1.311;

1.311
date	2004.09.01.18.55.16;	author brobecke;	state Exp;
branches;
next	1.310;

1.310
date	2004.08.09.05.45.20;	author brobecke;	state Exp;
branches;
next	1.309;

1.309
date	2004.08.03.01.12.43;	author cagney;	state Exp;
branches;
next	1.308;

1.308
date	2004.08.01.18.47.58;	author cagney;	state Exp;
branches;
next	1.307;

1.307
date	2004.07.31.21.53.17;	author cagney;	state Exp;
branches;
next	1.306;

1.306
date	2004.07.28.19.42.00;	author cagney;	state Exp;
branches;
next	1.305;

1.305
date	2004.07.28.17.26.27;	author cagney;	state Exp;
branches;
next	1.304;

1.304
date	2004.07.26.14.53.02;	author cagney;	state Exp;
branches;
next	1.303;

1.303
date	2004.07.21.14.23.36;	author cagney;	state Exp;
branches;
next	1.302;

1.302
date	2004.07.20.19.45.06;	author cagney;	state Exp;
branches;
next	1.301;

1.301
date	2004.07.10.01.17.52;	author msnyder;	state Exp;
branches;
next	1.300;

1.300
date	2004.06.22.00.01.03;	author hunt;	state Exp;
branches;
next	1.299;

1.299
date	2004.06.20.17.18.05;	author cagney;	state Exp;
branches;
next	1.298;

1.298
date	2004.06.15.15.06.57;	author cagney;	state Exp;
branches;
next	1.297;

1.297
date	2004.06.11.19.34.28;	author hunt;	state Exp;
branches;
next	1.296;

1.296
date	2004.06.10.13.22.06;	author cagney;	state Exp;
branches;
next	1.295;

1.295
date	2004.06.07.02.02.52;	author tausq;	state Exp;
branches;
next	1.294;

1.294
date	2004.05.03.22.20.18;	author msnyder;	state Exp;
branches;
next	1.293;

1.293
date	2004.05.01.00.34.54;	author cagney;	state Exp;
branches;
next	1.292;

1.292
date	2004.04.30.00.43.09;	author cagney;	state Exp;
branches;
next	1.291;

1.291
date	2004.04.29.23.39.52;	author cagney;	state Exp;
branches;
next	1.290;

1.290
date	2004.04.29.19.42.01;	author cagney;	state Exp;
branches;
next	1.289;

1.289
date	2004.04.29.18.28.42;	author cagney;	state Exp;
branches;
next	1.288;

1.288
date	2004.04.22.21.10.56;	author msnyder;	state Exp;
branches;
next	1.287;

1.287
date	2004.03.29.17.58.05;	author drow;	state Exp;
branches;
next	1.286;

1.286
date	2004.03.25.01.27.26;	author drow;	state Exp;
branches;
next	1.285;

1.285
date	2004.03.23.14.47.56;	author cagney;	state Exp;
branches;
next	1.284;

1.284
date	2004.03.22.21.39.00;	author drow;	state Exp;
branches;
next	1.283;

1.283
date	2004.02.17.15.21.21;	author cagney;	state Exp;
branches
	1.283.2.1
	1.283.4.1;
next	1.282;

1.282
date	2004.02.11.18.47.26;	author drow;	state Exp;
branches;
next	1.281;

1.281
date	2004.02.11.15.40.28;	author cagney;	state Exp;
branches;
next	1.280;

1.280
date	2004.02.11.00.02.52;	author cagney;	state Exp;
branches;
next	1.279;

1.279
date	2004.02.09.05.29.53;	author cagney;	state Exp;
branches;
next	1.278;

1.278
date	2004.02.08.21.04.39;	author cagney;	state Exp;
branches;
next	1.277;

1.277
date	2004.02.08.17.36.26;	author cagney;	state Exp;
branches;
next	1.276;

1.276
date	2004.02.07.18.29.53;	author ezannoni;	state Exp;
branches;
next	1.275;

1.275
date	2004.01.17.16.40.42;	author cagney;	state Exp;
branches;
next	1.274;

1.274
date	2004.01.17.16.27.30;	author cagney;	state Exp;
branches;
next	1.273;

1.273
date	2004.01.17.15.34.12;	author cagney;	state Exp;
branches;
next	1.272;

1.272
date	2004.01.14.02.51.42;	author cagney;	state Exp;
branches;
next	1.271;

1.271
date	2004.01.13.21.38.46;	author cagney;	state Exp;
branches;
next	1.270;

1.270
date	2004.01.12.20.13.25;	author cagney;	state Exp;
branches;
next	1.269;

1.269
date	2004.01.09.00.09.53;	author cagney;	state Exp;
branches;
next	1.268;

1.268
date	2004.01.08.05.03.59;	author cagney;	state Exp;
branches;
next	1.267;

1.267
date	2004.01.08.04.57.38;	author cagney;	state Exp;
branches;
next	1.266;

1.266
date	2004.01.08.04.20.57;	author cagney;	state Exp;
branches;
next	1.265;

1.265
date	2004.01.08.02.27.22;	author cagney;	state Exp;
branches;
next	1.264;

1.264
date	2004.01.08.01.51.13;	author cagney;	state Exp;
branches;
next	1.263;

1.263
date	2004.01.05.23.09.45;	author cagney;	state Exp;
branches;
next	1.262;

1.262
date	2003.11.25.22.15.24;	author msnyder;	state Exp;
branches;
next	1.261;

1.261
date	2003.11.23.21.49.12;	author cagney;	state Exp;
branches;
next	1.260;

1.260
date	2003.11.23.02.48.40;	author cagney;	state Exp;
branches;
next	1.259;

1.259
date	2003.11.23.01.25.39;	author cagney;	state Exp;
branches;
next	1.258;

1.258
date	2003.11.22.23.24.16;	author cagney;	state Exp;
branches;
next	1.257;

1.257
date	2003.11.22.22.32.28;	author cagney;	state Exp;
branches;
next	1.256;

1.256
date	2003.11.22.21.12.24;	author cagney;	state Exp;
branches;
next	1.255;

1.255
date	2003.11.22.14.04.39;	author cagney;	state Exp;
branches;
next	1.254;

1.254
date	2003.11.16.22.46.49;	author cagney;	state Exp;
branches;
next	1.253;

1.253
date	2003.11.16.19.24.04;	author cagney;	state Exp;
branches;
next	1.252;

1.252
date	2003.11.16.16.13.50;	author cagney;	state Exp;
branches;
next	1.251;

1.251
date	2003.11.16.14.31.53;	author cagney;	state Exp;
branches;
next	1.250;

1.250
date	2003.11.16.05.57.08;	author cagney;	state Exp;
branches;
next	1.249;

1.249
date	2003.11.16.04.57.25;	author cagney;	state Exp;
branches;
next	1.248;

1.248
date	2003.11.15.23.34.55;	author cagney;	state Exp;
branches;
next	1.247;

1.247
date	2003.11.15.22.35.37;	author cagney;	state Exp;
branches;
next	1.246;

1.246
date	2003.11.15.22.09.06;	author cagney;	state Exp;
branches;
next	1.245;

1.245
date	2003.11.11.21.07.52;	author chastain;	state Exp;
branches;
next	1.244;

1.244
date	2003.11.11.20.04.52;	author chastain;	state Exp;
branches;
next	1.243;

1.243
date	2003.11.06.02.52.27;	author cagney;	state Exp;
branches;
next	1.242;

1.242
date	2003.11.05.16.42.34;	author cagney;	state Exp;
branches;
next	1.241;

1.241
date	2003.10.24.17.37.03;	author cagney;	state Exp;
branches;
next	1.240;

1.240
date	2003.10.02.20.28.29;	author cagney;	state Exp;
branches;
next	1.239;

1.239
date	2003.09.30.19.12.18;	author cagney;	state Exp;
branches;
next	1.238;

1.238
date	2003.09.28.22.32.19;	author cagney;	state Exp;
branches;
next	1.237;

1.237
date	2003.09.25.20.44.01;	author cagney;	state Exp;
branches;
next	1.236;

1.236
date	2003.09.22.17.45.01;	author cagney;	state Exp;
branches;
next	1.235;

1.235
date	2003.09.19.16.22.38;	author cagney;	state Exp;
branches;
next	1.234;

1.234
date	2003.09.18.22.39.21;	author cagney;	state Exp;
branches;
next	1.233;

1.233
date	2003.09.17.14.24.30;	author cagney;	state Exp;
branches;
next	1.232;

1.232
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.231;

1.231
date	2003.09.14.16.32.13;	author cagney;	state Exp;
branches;
next	1.230;

1.230
date	2003.09.13.23.25.41;	author kettenis;	state Exp;
branches;
next	1.229;

1.229
date	2003.09.12.18.40.17;	author cagney;	state Exp;
branches;
next	1.228;

1.228
date	2003.09.09.04.41.32;	author cagney;	state Exp;
branches;
next	1.227;

1.227
date	2003.09.04.18.04.25;	author cagney;	state Exp;
branches;
next	1.226;

1.226
date	2003.08.28.04.34.19;	author cagney;	state Exp;
branches;
next	1.225;

1.225
date	2003.08.07.23.41.57;	author cagney;	state Exp;
branches;
next	1.224;

1.224
date	2003.07.28.15.31.08;	author cagney;	state Exp;
branches;
next	1.223;

1.223
date	2003.07.07.17.36.26;	author brobecke;	state Exp;
branches;
next	1.222;

1.222
date	2003.06.26.18.01.58;	author cagney;	state Exp;
branches;
next	1.221;

1.221
date	2003.06.21.23.14.43;	author cagney;	state Exp;
branches
	1.221.2.1;
next	1.220;

1.220
date	2003.06.21.18.02.54;	author cagney;	state Exp;
branches;
next	1.219;

1.219
date	2003.06.21.16.51.47;	author cagney;	state Exp;
branches;
next	1.218;

1.218
date	2003.06.21.16.37.33;	author cagney;	state Exp;
branches;
next	1.217;

1.217
date	2003.06.16.16.47.42;	author cagney;	state Exp;
branches;
next	1.216;

1.216
date	2003.06.15.00.27.54;	author cagney;	state Exp;
branches;
next	1.215;

1.215
date	2003.06.14.22.35.25;	author cagney;	state Exp;
branches;
next	1.214;

1.214
date	2003.06.13.04.40.33;	author cagney;	state Exp;
branches;
next	1.213;

1.213
date	2003.06.13.04.19.08;	author cagney;	state Exp;
branches;
next	1.212;

1.212
date	2003.06.12.23.25.37;	author jimb;	state Exp;
branches;
next	1.211;

1.211
date	2003.06.11.19.38.26;	author cagney;	state Exp;
branches;
next	1.210;

1.210
date	2003.06.11.13.16.27;	author cagney;	state Exp;
branches;
next	1.209;

1.209
date	2003.06.09.22.20.43;	author cagney;	state Exp;
branches;
next	1.208;

1.208
date	2003.06.09.17.35.58;	author cagney;	state Exp;
branches;
next	1.207;

1.207
date	2003.06.01.19.02.19;	author cagney;	state Exp;
branches
	1.207.2.1;
next	1.206;

1.206
date	2003.06.01.15.45.57;	author cagney;	state Exp;
branches;
next	1.205;

1.205
date	2003.06.01.01.36.34;	author cagney;	state Exp;
branches;
next	1.204;

1.204
date	2003.05.31.22.56.29;	author cagney;	state Exp;
branches;
next	1.203;

1.203
date	2003.05.31.16.36.28;	author cagney;	state Exp;
branches;
next	1.202;

1.202
date	2003.05.31.15.17.05;	author cagney;	state Exp;
branches;
next	1.201;

1.201
date	2003.05.17.05.59.58;	author cagney;	state Exp;
branches
	1.201.4.1;
next	1.200;

1.200
date	2003.05.15.22.58.38;	author cagney;	state Exp;
branches;
next	1.199;

1.199
date	2003.05.14.17.43.18;	author ezannoni;	state Exp;
branches;
next	1.198;

1.198
date	2003.05.13.19.27.28;	author cagney;	state Exp;
branches;
next	1.197;

1.197
date	2003.05.08.20.52.47;	author cagney;	state Exp;
branches
	1.197.4.1;
next	1.196;

1.196
date	2003.05.08.20.38.06;	author cagney;	state Exp;
branches;
next	1.195;

1.195
date	2003.05.05.17.56.55;	author cagney;	state Exp;
branches;
next	1.194;

1.194
date	2003.04.30.22.01.37;	author cagney;	state Exp;
branches;
next	1.193;

1.193
date	2003.04.29.01.49.47;	author cagney;	state Exp;
branches;
next	1.192;

1.192
date	2003.04.28.16.17.28;	author cagney;	state Exp;
branches;
next	1.191;

1.191
date	2003.04.14.19.16.13;	author cagney;	state Exp;
branches
	1.191.2.1;
next	1.190;

1.190
date	2003.04.14.19.06.48;	author cagney;	state Exp;
branches;
next	1.189;

1.189
date	2003.04.12.00.31.30;	author aoliva;	state Exp;
branches;
next	1.188;

1.188
date	2003.04.11.18.15.38;	author cagney;	state Exp;
branches;
next	1.187;

1.187
date	2003.04.08.19.21.15;	author ezannoni;	state Exp;
branches;
next	1.186;

1.186
date	2003.04.08.18.52.04;	author ezannoni;	state Exp;
branches;
next	1.185;

1.185
date	2003.04.07.18.38.04;	author kevinb;	state Exp;
branches;
next	1.184;

1.184
date	2003.04.02.05.12.25;	author kevinb;	state Exp;
branches
	1.184.2.1;
next	1.183;

1.183
date	2003.04.01.17.17.29;	author cagney;	state Exp;
branches;
next	1.182;

1.182
date	2003.04.01.14.38.50;	author cagney;	state Exp;
branches;
next	1.181;

1.181
date	2003.03.31.19.01.20;	author cagney;	state Exp;
branches;
next	1.180;

1.180
date	2003.03.30.14.59.01;	author cagney;	state Exp;
branches;
next	1.179;

1.179
date	2003.03.30.14.32.09;	author cagney;	state Exp;
branches;
next	1.178;

1.178
date	2003.03.26.22.39.52;	author cagney;	state Exp;
branches;
next	1.177;

1.177
date	2003.03.25.20.38.46;	author cagney;	state Exp;
branches
	1.177.2.1;
next	1.176;

1.176
date	2003.03.25.18.54.15;	author cagney;	state Exp;
branches;
next	1.175;

1.175
date	2003.03.24.03.54.48;	author cagney;	state Exp;
branches;
next	1.174;

1.174
date	2003.03.19.06.49.17;	author kevinb;	state Exp;
branches;
next	1.173;

1.173
date	2003.03.19.06.21.13;	author kevinb;	state Exp;
branches;
next	1.172;

1.172
date	2003.03.14.16.05.35;	author cagney;	state Exp;
branches;
next	1.171;

1.171
date	2003.03.13.21.45.40;	author cagney;	state Exp;
branches;
next	1.170;

1.170
date	2003.03.12.16.50.45;	author cagney;	state Exp;
branches;
next	1.169;

1.169
date	2003.03.11.23.15.38;	author kevinb;	state Exp;
branches;
next	1.168;

1.168
date	2003.03.03.20.50.19;	author cagney;	state Exp;
branches
	1.168.4.1;
next	1.167;

1.167
date	2003.03.02.04.02.24;	author cagney;	state Exp;
branches;
next	1.166;

1.166
date	2003.03.02.00.11.42;	author cagney;	state Exp;
branches;
next	1.165;

1.165
date	2003.02.27.17.48.47;	author cagney;	state Exp;
branches;
next	1.164;

1.164
date	2003.02.27.01.14.53;	author kevinb;	state Exp;
branches;
next	1.163;

1.163
date	2003.02.20.16.35.51;	author kevinb;	state Exp;
branches;
next	1.162;

1.162
date	2003.02.20.00.01.05;	author carlton;	state Exp;
branches;
next	1.161;

1.161
date	2003.01.28.16.31.11;	author kevinb;	state Exp;
branches;
next	1.160;

1.160
date	2003.01.19.04.06.46;	author cagney;	state Exp;
branches;
next	1.159;

1.159
date	2003.01.08.19.45.23;	author cagney;	state Exp;
branches;
next	1.158;

1.158
date	2003.01.08.17.21.29;	author cagney;	state Exp;
branches;
next	1.157;

1.157
date	2003.01.08.15.56.37;	author cagney;	state Exp;
branches;
next	1.156;

1.156
date	2003.01.08.01.53.37;	author cagney;	state Exp;
branches;
next	1.155;

1.155
date	2003.01.07.14.51.10;	author cagney;	state Exp;
branches;
next	1.154;

1.154
date	2003.01.05.01.39.55;	author drow;	state Exp;
branches;
next	1.153;

1.153
date	2003.01.04.23.38.45;	author drow;	state Exp;
branches;
next	1.152;

1.152
date	2003.01.04.22.37.47;	author drow;	state Exp;
branches;
next	1.151;

1.151
date	2003.01.03.23.53.48;	author cagney;	state Exp;
branches;
next	1.150;

1.150
date	2003.01.03.18.23.00;	author cagney;	state Exp;
branches;
next	1.149;

1.149
date	2003.01.02.22.20.46;	author cagney;	state Exp;
branches;
next	1.148;

1.148
date	2002.12.21.06.36.02;	author kevinb;	state Exp;
branches;
next	1.147;

1.147
date	2002.12.13.18.09.30;	author kevinb;	state Exp;
branches;
next	1.146;

1.146
date	2002.12.11.02.26.36;	author cagney;	state Exp;
branches;
next	1.145;

1.145
date	2002.12.09.02.04.16;	author cagney;	state Exp;
branches;
next	1.144;

1.144
date	2002.12.06.19.26.04;	author cagney;	state Exp;
branches;
next	1.143;

1.143
date	2002.12.05.05.17.39;	author kevinb;	state Exp;
branches;
next	1.142;

1.142
date	2002.12.01.19.07.15;	author cagney;	state Exp;
branches;
next	1.141;

1.141
date	2002.11.29.19.15.14;	author cagney;	state Exp;
branches;
next	1.140;

1.140
date	2002.11.28.21.38.43;	author cagney;	state Exp;
branches;
next	1.139;

1.139
date	2002.11.28.18.15.58;	author cagney;	state Exp;
branches;
next	1.138;

1.138
date	2002.11.24.19.48.13;	author cagney;	state Exp;
branches;
next	1.137;

1.137
date	2002.11.23.17.17.29;	author cagney;	state Exp;
branches;
next	1.136;

1.136
date	2002.11.23.01.39.25;	author cagney;	state Exp;
branches;
next	1.135;

1.135
date	2002.11.21.18.54.44;	author cagney;	state Exp;
branches;
next	1.134;

1.134
date	2002.11.18.22.19.29;	author cagney;	state Exp;
branches;
next	1.133;

1.133
date	2002.11.14.00.25.03;	author cagney;	state Exp;
branches;
next	1.132;

1.132
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.131;

1.131
date	2002.10.26.17.19.27;	author cagney;	state Exp;
branches;
next	1.130;

1.130
date	2002.10.11.14.02.37;	author drow;	state Exp;
branches;
next	1.129;

1.129
date	2002.10.02.01.28.55;	author aoliva;	state Exp;
branches
	1.129.2.1;
next	1.128;

1.128
date	2002.10.01.01.30.10;	author cagney;	state Exp;
branches;
next	1.127;

1.127
date	2002.09.27.00.49.01;	author hunt;	state Exp;
branches;
next	1.126;

1.126
date	2002.09.18.15.37.18;	author cagney;	state Exp;
branches
	1.126.2.1;
next	1.125;

1.125
date	2002.09.17.23.26.01;	author cagney;	state Exp;
branches;
next	1.124;

1.124
date	2002.09.17.20.54.02;	author msnyder;	state Exp;
branches;
next	1.123;

1.123
date	2002.09.13.22.15.33;	author cagney;	state Exp;
branches;
next	1.122;

1.122
date	2002.09.13.17.58.22;	author cagney;	state Exp;
branches;
next	1.121;

1.121
date	2002.09.10.21.31.18;	author msnyder;	state Exp;
branches;
next	1.120;

1.120
date	2002.09.05.18.31.07;	author msnyder;	state Exp;
branches;
next	1.119;

1.119
date	2002.08.24.00.21.35;	author cagney;	state Exp;
branches
	1.119.6.1;
next	1.118;

1.118
date	2002.08.21.22.39.26;	author msnyder;	state Exp;
branches;
next	1.117;

1.117
date	2002.08.21.22.18.25;	author msnyder;	state Exp;
branches;
next	1.116;

1.116
date	2002.08.21.01.08.22;	author msnyder;	state Exp;
branches;
next	1.115;

1.115
date	2002.08.20.23.07.42;	author msnyder;	state Exp;
branches;
next	1.114;

1.114
date	2002.08.20.22.44.54;	author msnyder;	state Exp;
branches;
next	1.113;

1.113
date	2002.08.20.21.58.44;	author msnyder;	state Exp;
branches;
next	1.112;

1.112
date	2002.08.20.19.41.59;	author msnyder;	state Exp;
branches;
next	1.111;

1.111
date	2002.08.20.19.26.23;	author msnyder;	state Exp;
branches;
next	1.110;

1.110
date	2002.08.20.16.11.49;	author cagney;	state Exp;
branches;
next	1.109;

1.109
date	2002.08.20.13.17.54;	author cagney;	state Exp;
branches;
next	1.108;

1.108
date	2002.08.19.23.22.17;	author msnyder;	state Exp;
branches;
next	1.107;

1.107
date	2002.08.19.21.25.43;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2002.08.18.18.59.52;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2002.08.16.04.10.22;	author msnyder;	state Exp;
branches;
next	1.104;

1.104
date	2002.08.16.03.07.33;	author msnyder;	state Exp;
branches;
next	1.103;

1.103
date	2002.08.16.02.36.49;	author msnyder;	state Exp;
branches;
next	1.102;

1.102
date	2002.08.16.01.23.16;	author msnyder;	state Exp;
branches;
next	1.101;

1.101
date	2002.08.14.19.17.39;	author msnyder;	state Exp;
branches;
next	1.100;

1.100
date	2002.08.14.01.20.03;	author msnyder;	state Exp;
branches;
next	1.99;

1.99
date	2002.08.10.01.09.10;	author msnyder;	state Exp;
branches;
next	1.98;

1.98
date	2002.08.10.00.34.04;	author msnyder;	state Exp;
branches;
next	1.97;

1.97
date	2002.08.09.21.58.14;	author msnyder;	state Exp;
branches;
next	1.96;

1.96
date	2002.08.09.20.38.49;	author kevinb;	state Exp;
branches;
next	1.95;

1.95
date	2002.08.09.20.30.20;	author kevinb;	state Exp;
branches;
next	1.94;

1.94
date	2002.08.09.01.42.41;	author msnyder;	state Exp;
branches;
next	1.93;

1.93
date	2002.08.08.23.32.52;	author kevinb;	state Exp;
branches;
next	1.92;

1.92
date	2002.08.08.00.26.51;	author msnyder;	state Exp;
branches;
next	1.91;

1.91
date	2002.08.07.18.17.26;	author msnyder;	state Exp;
branches;
next	1.90;

1.90
date	2002.08.07.00.28.31;	author msnyder;	state Exp;
branches;
next	1.89;

1.89
date	2002.08.06.19.03.40;	author kevinb;	state Exp;
branches;
next	1.88;

1.88
date	2002.08.01.23.10.34;	author kevinb;	state Exp;
branches;
next	1.87;

1.87
date	2002.08.01.21.36.27;	author kevinb;	state Exp;
branches;
next	1.86;

1.86
date	2002.08.01.19.57.40;	author kevinb;	state Exp;
branches;
next	1.85;

1.85
date	2002.07.31.20.26.49;	author kevinb;	state Exp;
branches;
next	1.84;

1.84
date	2002.07.31.20.08.20;	author kevinb;	state Exp;
branches;
next	1.83;

1.83
date	2002.07.31.19.08.46;	author kevinb;	state Exp;
branches;
next	1.82;

1.82
date	2002.07.31.18.13.24;	author kevinb;	state Exp;
branches;
next	1.81;

1.81
date	2002.06.19.16.48.47;	author drow;	state Exp;
branches;
next	1.80;

1.80
date	2002.06.17.23.32.32;	author cagney;	state Exp;
branches;
next	1.79;

1.79
date	2002.06.15.22.05.32;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2002.06.15.18.45.31;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2002.06.13.19.16.25;	author drow;	state Exp;
branches;
next	1.76;

1.76
date	2002.06.11.17.51.54;	author drow;	state Exp;
branches;
next	1.75;

1.75
date	2002.06.09.19.36.15;	author drow;	state Exp;
branches;
next	1.74;

1.74
date	2002.05.21.15.36.03;	author thorpej;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2002.05.11.14.18.15;	author echristo;	state Exp;
branches
	1.73.2.1;
next	1.72;

1.72
date	2002.05.09.22.26.00;	author drow;	state Exp;
branches;
next	1.71;

1.71
date	2002.04.24.16.28.15;	author cagney;	state Exp;
branches;
next	1.70;

1.70
date	2002.04.18.18.09.02;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2002.04.12.18.18.57;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2002.04.06.00.02.50;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2002.03.10.17.00.27;	author drow;	state Exp;
branches;
next	1.66;

1.66
date	2002.02.20.22.51.41;	author drow;	state Exp;
branches;
next	1.65;

1.65
date	2002.02.05.04.37.21;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2002.01.20.18.05.51;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2002.01.05.04.30.17;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2001.12.10.04.58.30;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2001.11.19.23.15.31;	author drow;	state Exp;
branches;
next	1.60;

1.60
date	2001.10.15.18.18.29;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2001.07.24.16.28.36;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2001.07.15.20.10.02;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2001.07.12.17.34.33;	author drow;	state Exp;
branches;
next	1.56;

1.56
date	2001.07.06.05.35.17;	author drow;	state Exp;
branches;
next	1.55;

1.55
date	2001.07.05.23.30.43;	author drow;	state Exp;
branches;
next	1.54;

1.54
date	2001.06.16.20.00.24;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2001.06.15.23.10.55;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.15.22.10.21;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.07.15.57.57;	author eliz;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.04.07.53.07;	author eliz;	state Exp;
branches;
next	1.49;

1.49
date	2001.05.12.00.38.11;	author jimb;	state Exp;
branches;
next	1.48;

1.48
date	2001.05.04.04.15.25;	author kevinb;	state Exp;
branches;
next	1.47;

1.47
date	2001.03.28.21.42.31;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2001.03.26.04.01.53;	author jimb;	state Exp;
branches;
next	1.45;

1.45
date	2001.03.20.18.16.10;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2001.03.06.08.21.10;	author kevinb;	state Exp;
branches;
next	1.43;

1.43
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.21.00.05.34;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.20.03.38.32;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.31.01.24.01;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2001.01.04.23.22.45;	author msnyder;	state Exp;
branches;
next	1.37;

1.37
date	2000.12.15.01.01.48;	author kevinb;	state Exp;
branches;
next	1.36;

1.36
date	2000.12.04.04.01.15;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2000.12.02.13.25.26;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.30.21.50.57;	author jtc;	state Exp;
branches;
next	1.33;

1.33
date	2000.10.27.15.02.42;	author davea;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.25.20.06.30;	author fnf;	state Exp;
branches;
next	1.31;

1.31
date	2000.10.23.22.49.28;	author davea;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.19.05.32.23;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.11.11.02.11;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2000.07.11.10.24.25;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2000.07.11.09.25.22;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.10.15.09.23;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.07.09.19.02;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.06.23.17.32;	author msnyder;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.23.11.06.31;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.23.07.44.00;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.17.15.18.21;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.17.14.33.56;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.17.05.42.50;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.12.04.35.39;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.12.03.33.26;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.10.05.37.47;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.08.06.35.39;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.08.04.51.10;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.08.00.52.56;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.28.01.12.28;	author kevinb;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.05.16.03.03.13;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.12.09.21.30;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.12.04.51.22;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.11.03.40.08;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.08.02.53.04;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.27.04.25.45;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.13.22.58.42;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.09.14.35.35;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.22.19.17.27;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.528.2.1
date	2012.01.06.04.43.20;	author brobecke;	state Exp;
branches;
next	;

1.506.2.1
date	2010.12.28.02.29.26;	author teawater;	state Exp;
branches;
next	1.506.2.2;

1.506.2.2
date	2010.12.30.03.17.35;	author teawater;	state Exp;
branches;
next	;

1.443.2.1
date	2007.09.19.14.46.28;	author drow;	state Exp;
branches;
next	;

1.391.2.1
date	2006.08.28.07.48.48;	author nickrob;	state Exp;
branches;
next	;

1.385.2.1
date	2006.03.15.19.53.38;	author drow;	state Exp;
branches
	1.385.2.1.2.1;
next	;

1.385.2.1.2.1
date	2006.04.11.21.58.24;	author drow;	state Exp;
branches;
next	;

1.283.2.1
date	2004.03.27.17.37.50;	author drow;	state Exp;
branches;
next	1.283.2.2;

1.283.2.2
date	2004.04.02.16.47.47;	author drow;	state Exp;
branches;
next	1.283.2.3;

1.283.2.3
date	2004.09.16.17.01.13;	author drow;	state Exp;
branches;
next	1.283.2.4;

1.283.2.4
date	2004.09.21.20.44.17;	author drow;	state Exp;
branches;
next	;

1.283.4.1
date	2004.03.29.17.58.27;	author drow;	state Exp;
branches;
next	;

1.221.2.1
date	2003.06.26.18.01.47;	author cagney;	state Exp;
branches;
next	1.221.2.2;

1.221.2.2
date	2003.07.07.17.52.23;	author brobecke;	state Exp;
branches;
next	1.221.2.3;

1.221.2.3
date	2003.07.28.15.34.02;	author cagney;	state Exp;
branches;
next	;

1.207.2.1
date	2003.06.06.18.02.30;	author cagney;	state Exp;
branches;
next	1.207.2.2;

1.207.2.2
date	2003.06.08.22.14.42;	author cagney;	state Exp;
branches;
next	1.207.2.3;

1.207.2.3
date	2003.06.09.10.26.53;	author kettenis;	state Exp;
branches;
next	;

1.201.4.1
date	2003.06.11.06.40.14;	author jimb;	state Exp;
branches;
next	;

1.197.4.1
date	2003.06.03.20.54.38;	author cagney;	state Exp;
branches;
next	;

1.191.2.1
date	2003.05.04.11.37.44;	author kettenis;	state Exp;
branches;
next	1.191.2.2;

1.191.2.2
date	2003.05.18.09.44.17;	author kettenis;	state Exp;
branches;
next	;

1.184.2.1
date	2003.04.10.21.33.49;	author cagney;	state Exp;
branches;
next	;

1.177.2.1
date	2003.03.30.16.35.21;	author cagney;	state Exp;
branches;
next	;

1.168.4.1
date	2003.03.16.14.01.50;	author kettenis;	state Exp;
branches;
next	;

1.129.2.1
date	2002.10.26.17.12.08;	author drow;	state Exp;
branches;
next	1.129.2.2;

1.129.2.2
date	2003.12.14.20.27.21;	author drow;	state Exp;
branches;
next	1.129.2.3;

1.129.2.3
date	2004.01.13.16.11.58;	author drow;	state Exp;
branches;
next	1.129.2.4;

1.129.2.4
date	2004.02.09.19.43.44;	author drow;	state Exp;
branches;
next	;

1.126.2.1
date	2002.09.27.20.03.07;	author carlton;	state Exp;
branches;
next	1.126.2.2;

1.126.2.2
date	2002.10.11.22.22.55;	author carlton;	state Exp;
branches;
next	1.126.2.3;

1.126.2.3
date	2002.10.18.23.42.58;	author carlton;	state Exp;
branches;
next	1.126.2.4;

1.126.2.4
date	2002.11.15.19.18.50;	author carlton;	state Exp;
branches;
next	1.126.2.5;

1.126.2.5
date	2002.12.23.19.38.35;	author carlton;	state Exp;
branches;
next	1.126.2.6;

1.126.2.6
date	2003.02.07.19.17.51;	author carlton;	state Exp;
branches;
next	1.126.2.7;

1.126.2.7
date	2003.03.06.00.56.30;	author carlton;	state Exp;
branches;
next	1.126.2.8;

1.126.2.8
date	2003.04.16.19.56.53;	author carlton;	state Exp;
branches;
next	1.126.2.9;

1.126.2.9
date	2003.05.01.00.46.51;	author carlton;	state Exp;
branches;
next	1.126.2.10;

1.126.2.10
date	2003.05.23.18.40.42;	author carlton;	state Exp;
branches;
next	1.126.2.11;

1.126.2.11
date	2003.06.27.21.50.06;	author carlton;	state Exp;
branches;
next	1.126.2.12;

1.126.2.12
date	2003.08.05.17.13.11;	author carlton;	state Exp;
branches;
next	1.126.2.13;

1.126.2.13
date	2003.09.17.21.28.26;	author carlton;	state Exp;
branches;
next	1.126.2.14;

1.126.2.14
date	2003.11.11.23.50.49;	author carlton;	state Exp;
branches;
next	1.126.2.15;

1.126.2.15
date	2003.12.16.00.00.42;	author carlton;	state Exp;
branches;
next	1.126.2.16;

1.126.2.16
date	2004.01.26.19.11.28;	author carlton;	state Exp;
branches;
next	;

1.119.6.1
date	2002.10.02.01.29.29;	author aoliva;	state Exp;
branches;
next	;

1.74.2.1
date	2002.06.20.01.32.39;	author kseitz;	state Exp;
branches;
next	1.74.2.2;

1.74.2.2
date	2002.08.09.18.34.25;	author kseitz;	state Exp;
branches;
next	1.74.2.3;

1.74.2.3
date	2002.08.30.22.52.44;	author kseitz;	state Exp;
branches;
next	1.74.2.4;

1.74.2.4
date	2002.10.01.00.46.10;	author kseitz;	state Exp;
branches;
next	1.74.2.5;

1.74.2.5
date	2002.11.04.00.17.32;	author ezannoni;	state Exp;
branches;
next	;

1.73.2.1
date	2002.06.15.16.42.52;	author cagney;	state Exp;
branches;
next	1.73.2.2;

1.73.2.2
date	2002.06.21.16.19.27;	author cagney;	state Exp;
branches;
next	;

1.11.2.1
date	2000.06.09.10.21.57;	author cagney;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2000.06.12.03.33.56;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.49;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.11.13.29.17;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.06.07.19.17.38;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.06.14.18.07.49;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.07.07.17.22.14;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.07.07.20.08.08;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.07.12.11.06.35;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.08.23.22.35.30;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.09.08.23.59.22;	author shebs;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.10.05.23.08.31;	author jsm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.12.07.03.56.03;	author jsm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.12.14.01.05.34;	author jsm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.12.22.21.45.05;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.577
log
@	* mips-tdep.c (micromips_deal_with_atomic_sequence): Correct
	formatting.
@
text
@/* Target-dependent code for the MIPS architecture, for GDB, the GNU Debugger.

   Copyright (C) 1988-2013 Free Software Foundation, Inc.

   Contributed by Alessandro Forin(af@@cs.cmu.edu) at CMU
   and by Per Bothner(bothner@@cs.wisc.edu) at U.Wisconsin.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdb_string.h"
#include "gdb_assert.h"
#include "frame.h"
#include "inferior.h"
#include "symtab.h"
#include "value.h"
#include "gdbcmd.h"
#include "language.h"
#include "gdbcore.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdbtypes.h"
#include "target.h"
#include "arch-utils.h"
#include "regcache.h"
#include "osabi.h"
#include "mips-tdep.h"
#include "block.h"
#include "reggroups.h"
#include "opcode/mips.h"
#include "elf/mips.h"
#include "elf-bfd.h"
#include "symcat.h"
#include "sim-regno.h"
#include "dis-asm.h"
#include "frame-unwind.h"
#include "frame-base.h"
#include "trad-frame.h"
#include "infcall.h"
#include "floatformat.h"
#include "remote.h"
#include "target-descriptions.h"
#include "dwarf2-frame.h"
#include "user-regs.h"
#include "valprint.h"
#include "ax.h"

static const struct objfile_data *mips_pdr_data;

static struct type *mips_register_type (struct gdbarch *gdbarch, int regnum);

static int mips32_instruction_has_delay_slot (struct gdbarch *, CORE_ADDR);
static int micromips_instruction_has_delay_slot (struct gdbarch *, CORE_ADDR,
						 int);
static int mips16_instruction_has_delay_slot (struct gdbarch *, CORE_ADDR,
					      int);

/* A useful bit in the CP0 status register (MIPS_PS_REGNUM).  */
/* This bit is set if we are emulating 32-bit FPRs on a 64-bit chip.  */
#define ST0_FR (1 << 26)

/* The sizes of floating point registers.  */

enum
{
  MIPS_FPU_SINGLE_REGSIZE = 4,
  MIPS_FPU_DOUBLE_REGSIZE = 8
};

enum
{
  MIPS32_REGSIZE = 4,
  MIPS64_REGSIZE = 8
};

static const char *mips_abi_string;

static const char *const mips_abi_strings[] = {
  "auto",
  "n32",
  "o32",
  "n64",
  "o64",
  "eabi32",
  "eabi64",
  NULL
};

/* For backwards compatibility we default to MIPS16.  This flag is
   overridden as soon as unambiguous ELF file flags tell us the
   compressed ISA encoding used.  */
static const char mips_compression_mips16[] = "mips16";
static const char mips_compression_micromips[] = "micromips";
static const char *const mips_compression_strings[] =
{
  mips_compression_mips16,
  mips_compression_micromips,
  NULL
};

static const char *mips_compression_string = mips_compression_mips16;

/* The standard register names, and all the valid aliases for them.  */
struct register_alias
{
  const char *name;
  int regnum;
};

/* Aliases for o32 and most other ABIs.  */
const struct register_alias mips_o32_aliases[] = {
  { "ta0", 12 },
  { "ta1", 13 },
  { "ta2", 14 },
  { "ta3", 15 }
};

/* Aliases for n32 and n64.  */
const struct register_alias mips_n32_n64_aliases[] = {
  { "ta0", 8 },
  { "ta1", 9 },
  { "ta2", 10 },
  { "ta3", 11 }
};

/* Aliases for ABI-independent registers.  */
const struct register_alias mips_register_aliases[] = {
  /* The architecture manuals specify these ABI-independent names for
     the GPRs.  */
#define R(n) { "r" #n, n }
  R(0), R(1), R(2), R(3), R(4), R(5), R(6), R(7),
  R(8), R(9), R(10), R(11), R(12), R(13), R(14), R(15),
  R(16), R(17), R(18), R(19), R(20), R(21), R(22), R(23),
  R(24), R(25), R(26), R(27), R(28), R(29), R(30), R(31),
#undef R

  /* k0 and k1 are sometimes called these instead (for "kernel
     temp").  */
  { "kt0", 26 },
  { "kt1", 27 },

  /* This is the traditional GDB name for the CP0 status register.  */
  { "sr", MIPS_PS_REGNUM },

  /* This is the traditional GDB name for the CP0 BadVAddr register.  */
  { "bad", MIPS_EMBED_BADVADDR_REGNUM },

  /* This is the traditional GDB name for the FCSR.  */
  { "fsr", MIPS_EMBED_FP0_REGNUM + 32 }
};

const struct register_alias mips_numeric_register_aliases[] = {
#define R(n) { #n, n }
  R(0), R(1), R(2), R(3), R(4), R(5), R(6), R(7),
  R(8), R(9), R(10), R(11), R(12), R(13), R(14), R(15),
  R(16), R(17), R(18), R(19), R(20), R(21), R(22), R(23),
  R(24), R(25), R(26), R(27), R(28), R(29), R(30), R(31),
#undef R
};

#ifndef MIPS_DEFAULT_FPU_TYPE
#define MIPS_DEFAULT_FPU_TYPE MIPS_FPU_DOUBLE
#endif
static int mips_fpu_type_auto = 1;
static enum mips_fpu_type mips_fpu_type = MIPS_DEFAULT_FPU_TYPE;

static unsigned int mips_debug = 0;

/* Properties (for struct target_desc) describing the g/G packet
   layout.  */
#define PROPERTY_GP32 "internal: transfers-32bit-registers"
#define PROPERTY_GP64 "internal: transfers-64bit-registers"

struct target_desc *mips_tdesc_gp32;
struct target_desc *mips_tdesc_gp64;

const struct mips_regnum *
mips_regnum (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->regnum;
}

static int
mips_fpa0_regnum (struct gdbarch *gdbarch)
{
  return mips_regnum (gdbarch)->fp0 + 12;
}

/* Return 1 if REGNUM refers to a floating-point general register, raw
   or cooked.  Otherwise return 0.  */

static int
mips_float_register_p (struct gdbarch *gdbarch, int regnum)
{
  int rawnum = regnum % gdbarch_num_regs (gdbarch);

  return (rawnum >= mips_regnum (gdbarch)->fp0
	  && rawnum < mips_regnum (gdbarch)->fp0 + 32);
}

#define MIPS_EABI(gdbarch) (gdbarch_tdep (gdbarch)->mips_abi \
		     == MIPS_ABI_EABI32 \
		   || gdbarch_tdep (gdbarch)->mips_abi == MIPS_ABI_EABI64)

#define MIPS_LAST_FP_ARG_REGNUM(gdbarch) \
  (gdbarch_tdep (gdbarch)->mips_last_fp_arg_regnum)

#define MIPS_LAST_ARG_REGNUM(gdbarch) \
  (gdbarch_tdep (gdbarch)->mips_last_arg_regnum)

#define MIPS_FPU_TYPE(gdbarch) (gdbarch_tdep (gdbarch)->mips_fpu_type)

/* Return the MIPS ABI associated with GDBARCH.  */
enum mips_abi
mips_abi (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->mips_abi;
}

int
mips_isa_regsize (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* If we know how big the registers are, use that size.  */
  if (tdep->register_size_valid_p)
    return tdep->register_size;

  /* Fall back to the previous behavior.  */
  return (gdbarch_bfd_arch_info (gdbarch)->bits_per_word
	  / gdbarch_bfd_arch_info (gdbarch)->bits_per_byte);
}

/* Return the currently configured (or set) saved register size.  */

unsigned int
mips_abi_regsize (struct gdbarch *gdbarch)
{
  switch (mips_abi (gdbarch))
    {
    case MIPS_ABI_EABI32:
    case MIPS_ABI_O32:
      return 4;
    case MIPS_ABI_N32:
    case MIPS_ABI_N64:
    case MIPS_ABI_O64:
    case MIPS_ABI_EABI64:
      return 8;
    case MIPS_ABI_UNKNOWN:
    case MIPS_ABI_LAST:
    default:
      internal_error (__FILE__, __LINE__, _("bad switch"));
    }
}

/* MIPS16/microMIPS function addresses are odd (bit 0 is set).  Here
   are some functions to handle addresses associated with compressed
   code including but not limited to testing, setting, or clearing
   bit 0 of such addresses.  */

/* Return one iff compressed code is the MIPS16 instruction set.  */

static int
is_mips16_isa (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->mips_isa == ISA_MIPS16;
}

/* Return one iff compressed code is the microMIPS instruction set.  */

static int
is_micromips_isa (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->mips_isa == ISA_MICROMIPS;
}

/* Return one iff ADDR denotes compressed code.  */

static int
is_compact_addr (CORE_ADDR addr)
{
  return ((addr) & 1);
}

/* Return one iff ADDR denotes standard ISA code.  */

static int
is_mips_addr (CORE_ADDR addr)
{
  return !is_compact_addr (addr);
}

/* Return one iff ADDR denotes MIPS16 code.  */

static int
is_mips16_addr (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  return is_compact_addr (addr) && is_mips16_isa (gdbarch);
}

/* Return one iff ADDR denotes microMIPS code.  */

static int
is_micromips_addr (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  return is_compact_addr (addr) && is_micromips_isa (gdbarch);
}

/* Strip the ISA (compression) bit off from ADDR.  */

static CORE_ADDR
unmake_compact_addr (CORE_ADDR addr)
{
  return ((addr) & ~(CORE_ADDR) 1);
}

/* Add the ISA (compression) bit to ADDR.  */

static CORE_ADDR
make_compact_addr (CORE_ADDR addr)
{
  return ((addr) | (CORE_ADDR) 1);
}

/* Functions for setting and testing a bit in a minimal symbol that
   marks it as MIPS16 or microMIPS function.  The MSB of the minimal
   symbol's "info" field is used for this purpose.

   gdbarch_elf_make_msymbol_special tests whether an ELF symbol is
   "special", i.e. refers to a MIPS16 or microMIPS function, and sets
   one of the "special" bits in a minimal symbol to mark it accordingly.
   The test checks an ELF-private flag that is valid for true function
   symbols only; for synthetic symbols such as for PLT stubs that have
   no ELF-private part at all the MIPS BFD backend arranges for this
   information to be carried in the asymbol's udata field instead.

   msymbol_is_mips16 and msymbol_is_micromips test the "special" bit
   in a minimal symbol.  */

static void
mips_elf_make_msymbol_special (asymbol * sym, struct minimal_symbol *msym)
{
  elf_symbol_type *elfsym = (elf_symbol_type *) sym;
  unsigned char st_other;

  if ((sym->flags & BSF_SYNTHETIC) == 0)
    st_other = elfsym->internal_elf_sym.st_other;
  else if ((sym->flags & BSF_FUNCTION) != 0)
    st_other = sym->udata.i;
  else
    return;

  if (ELF_ST_IS_MICROMIPS (st_other))
    MSYMBOL_TARGET_FLAG_2 (msym) = 1;
  else if (ELF_ST_IS_MIPS16 (st_other))
    MSYMBOL_TARGET_FLAG_1 (msym) = 1;
}

/* Return one iff MSYM refers to standard ISA code.  */

static int
msymbol_is_mips (struct minimal_symbol *msym)
{
  return !(MSYMBOL_TARGET_FLAG_1 (msym) | MSYMBOL_TARGET_FLAG_2 (msym));
}

/* Return one iff MSYM refers to MIPS16 code.  */

static int
msymbol_is_mips16 (struct minimal_symbol *msym)
{
  return MSYMBOL_TARGET_FLAG_1 (msym);
}

/* Return one iff MSYM refers to microMIPS code.  */

static int
msymbol_is_micromips (struct minimal_symbol *msym)
{
  return MSYMBOL_TARGET_FLAG_2 (msym);
}

/* XFER a value from the big/little/left end of the register.
   Depending on the size of the value it might occupy the entire
   register or just part of it.  Make an allowance for this, aligning
   things accordingly.  */

static void
mips_xfer_register (struct gdbarch *gdbarch, struct regcache *regcache,
		    int reg_num, int length,
		    enum bfd_endian endian, gdb_byte *in,
		    const gdb_byte *out, int buf_offset)
{
  int reg_offset = 0;

  gdb_assert (reg_num >= gdbarch_num_regs (gdbarch));
  /* Need to transfer the left or right part of the register, based on
     the targets byte order.  */
  switch (endian)
    {
    case BFD_ENDIAN_BIG:
      reg_offset = register_size (gdbarch, reg_num) - length;
      break;
    case BFD_ENDIAN_LITTLE:
      reg_offset = 0;
      break;
    case BFD_ENDIAN_UNKNOWN:	/* Indicates no alignment.  */
      reg_offset = 0;
      break;
    default:
      internal_error (__FILE__, __LINE__, _("bad switch"));
    }
  if (mips_debug)
    fprintf_unfiltered (gdb_stderr,
			"xfer $%d, reg offset %d, buf offset %d, length %d, ",
			reg_num, reg_offset, buf_offset, length);
  if (mips_debug && out != NULL)
    {
      int i;
      fprintf_unfiltered (gdb_stdlog, "out ");
      for (i = 0; i < length; i++)
	fprintf_unfiltered (gdb_stdlog, "%02x", out[buf_offset + i]);
    }
  if (in != NULL)
    regcache_cooked_read_part (regcache, reg_num, reg_offset, length,
			       in + buf_offset);
  if (out != NULL)
    regcache_cooked_write_part (regcache, reg_num, reg_offset, length,
				out + buf_offset);
  if (mips_debug && in != NULL)
    {
      int i;
      fprintf_unfiltered (gdb_stdlog, "in ");
      for (i = 0; i < length; i++)
	fprintf_unfiltered (gdb_stdlog, "%02x", in[buf_offset + i]);
    }
  if (mips_debug)
    fprintf_unfiltered (gdb_stdlog, "\n");
}

/* Determine if a MIPS3 or later cpu is operating in MIPS{1,2} FPU
   compatiblity mode.  A return value of 1 means that we have
   physical 64-bit registers, but should treat them as 32-bit registers.  */

static int
mips2_fp_compat (struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  /* MIPS1 and MIPS2 have only 32 bit FPRs, and the FR bit is not
     meaningful.  */
  if (register_size (gdbarch, mips_regnum (gdbarch)->fp0) == 4)
    return 0;

#if 0
  /* FIXME drow 2002-03-10: This is disabled until we can do it consistently,
     in all the places we deal with FP registers.  PR gdb/413.  */
  /* Otherwise check the FR bit in the status register - it controls
     the FP compatiblity mode.  If it is clear we are in compatibility
     mode.  */
  if ((get_frame_register_unsigned (frame, MIPS_PS_REGNUM) & ST0_FR) == 0)
    return 1;
#endif

  return 0;
}

#define VM_MIN_ADDRESS (CORE_ADDR)0x400000

static CORE_ADDR heuristic_proc_start (struct gdbarch *, CORE_ADDR);

static void reinit_frame_cache_sfunc (char *, int, struct cmd_list_element *);

/* The list of available "set mips " and "show mips " commands.  */

static struct cmd_list_element *setmipscmdlist = NULL;
static struct cmd_list_element *showmipscmdlist = NULL;

/* Integer registers 0 thru 31 are handled explicitly by
   mips_register_name().  Processor specific registers 32 and above
   are listed in the following tables.  */

enum
{ NUM_MIPS_PROCESSOR_REGS = (90 - 32) };

/* Generic MIPS.  */

static const char *mips_generic_reg_names[NUM_MIPS_PROCESSOR_REGS] = {
  "sr", "lo", "hi", "bad", "cause", "pc",
  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
  "fsr", "fir",
};

/* Names of IDT R3041 registers.  */

static const char *mips_r3041_reg_names[] = {
  "sr", "lo", "hi", "bad", "cause", "pc",
  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
  "fsr", "fir", "", /*"fp" */ "",
  "", "", "bus", "ccfg", "", "", "", "",
  "", "", "port", "cmp", "", "", "epc", "prid",
};

/* Names of tx39 registers.  */

static const char *mips_tx39_reg_names[NUM_MIPS_PROCESSOR_REGS] = {
  "sr", "lo", "hi", "bad", "cause", "pc",
  "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "",
  "", "", "", "",
  "", "", "", "", "", "", "", "",
  "", "", "config", "cache", "debug", "depc", "epc",
};

/* Names of IRIX registers.  */
static const char *mips_irix_reg_names[NUM_MIPS_PROCESSOR_REGS] = {
  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
  "pc", "cause", "bad", "hi", "lo", "fsr", "fir"
};

/* Names of registers with Linux kernels.  */
static const char *mips_linux_reg_names[NUM_MIPS_PROCESSOR_REGS] = {
  "sr", "lo", "hi", "bad", "cause", "pc",
  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
  "fsr", "fir"
};


/* Return the name of the register corresponding to REGNO.  */
static const char *
mips_register_name (struct gdbarch *gdbarch, int regno)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  /* GPR names for all ABIs other than n32/n64.  */
  static char *mips_gpr_names[] = {
    "zero", "at", "v0", "v1", "a0", "a1", "a2", "a3",
    "t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7",
    "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
    "t8", "t9", "k0", "k1", "gp", "sp", "s8", "ra",
  };

  /* GPR names for n32 and n64 ABIs.  */
  static char *mips_n32_n64_gpr_names[] = {
    "zero", "at", "v0", "v1", "a0", "a1", "a2", "a3",
    "a4", "a5", "a6", "a7", "t0", "t1", "t2", "t3",
    "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
    "t8", "t9", "k0", "k1", "gp", "sp", "s8", "ra"
  };

  enum mips_abi abi = mips_abi (gdbarch);

  /* Map [gdbarch_num_regs .. 2*gdbarch_num_regs) onto the raw registers, 
     but then don't make the raw register names visible.  This (upper)
     range of user visible register numbers are the pseudo-registers.

     This approach was adopted accommodate the following scenario:
     It is possible to debug a 64-bit device using a 32-bit
     programming model.  In such instances, the raw registers are
     configured to be 64-bits wide, while the pseudo registers are
     configured to be 32-bits wide.  The registers that the user
     sees - the pseudo registers - match the users expectations
     given the programming model being used.  */
  int rawnum = regno % gdbarch_num_regs (gdbarch);
  if (regno < gdbarch_num_regs (gdbarch))
    return "";

  /* The MIPS integer registers are always mapped from 0 to 31.  The
     names of the registers (which reflects the conventions regarding
     register use) vary depending on the ABI.  */
  if (0 <= rawnum && rawnum < 32)
    {
      if (abi == MIPS_ABI_N32 || abi == MIPS_ABI_N64)
	return mips_n32_n64_gpr_names[rawnum];
      else
	return mips_gpr_names[rawnum];
    }
  else if (tdesc_has_registers (gdbarch_target_desc (gdbarch)))
    return tdesc_register_name (gdbarch, rawnum);
  else if (32 <= rawnum && rawnum < gdbarch_num_regs (gdbarch))
    {
      gdb_assert (rawnum - 32 < NUM_MIPS_PROCESSOR_REGS);
      if (tdep->mips_processor_reg_names[rawnum - 32])
	return tdep->mips_processor_reg_names[rawnum - 32];
      return "";
    }
  else
    internal_error (__FILE__, __LINE__,
		    _("mips_register_name: bad register number %d"), rawnum);
}

/* Return the groups that a MIPS register can be categorised into.  */

static int
mips_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			  struct reggroup *reggroup)
{
  int vector_p;
  int float_p;
  int raw_p;
  int rawnum = regnum % gdbarch_num_regs (gdbarch);
  int pseudo = regnum / gdbarch_num_regs (gdbarch);
  if (reggroup == all_reggroup)
    return pseudo;
  vector_p = TYPE_VECTOR (register_type (gdbarch, regnum));
  float_p = TYPE_CODE (register_type (gdbarch, regnum)) == TYPE_CODE_FLT;
  /* FIXME: cagney/2003-04-13: Can't yet use gdbarch_num_regs
     (gdbarch), as not all architectures are multi-arch.  */
  raw_p = rawnum < gdbarch_num_regs (gdbarch);
  if (gdbarch_register_name (gdbarch, regnum) == NULL
      || gdbarch_register_name (gdbarch, regnum)[0] == '\0')
    return 0;
  if (reggroup == float_reggroup)
    return float_p && pseudo;
  if (reggroup == vector_reggroup)
    return vector_p && pseudo;
  if (reggroup == general_reggroup)
    return (!vector_p && !float_p) && pseudo;
  /* Save the pseudo registers.  Need to make certain that any code
     extracting register values from a saved register cache also uses
     pseudo registers.  */
  if (reggroup == save_reggroup)
    return raw_p && pseudo;
  /* Restore the same pseudo register.  */
  if (reggroup == restore_reggroup)
    return raw_p && pseudo;
  return 0;
}

/* Return the groups that a MIPS register can be categorised into.
   This version is only used if we have a target description which
   describes real registers (and their groups).  */

static int
mips_tdesc_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
				struct reggroup *reggroup)
{
  int rawnum = regnum % gdbarch_num_regs (gdbarch);
  int pseudo = regnum / gdbarch_num_regs (gdbarch);
  int ret;

  /* Only save, restore, and display the pseudo registers.  Need to
     make certain that any code extracting register values from a
     saved register cache also uses pseudo registers.

     Note: saving and restoring the pseudo registers is slightly
     strange; if we have 64 bits, we should save and restore all
     64 bits.  But this is hard and has little benefit.  */
  if (!pseudo)
    return 0;

  ret = tdesc_register_in_reggroup_p (gdbarch, rawnum, reggroup);
  if (ret != -1)
    return ret;

  return mips_register_reggroup_p (gdbarch, regnum, reggroup);
}

/* Map the symbol table registers which live in the range [1 *
   gdbarch_num_regs .. 2 * gdbarch_num_regs) back onto the corresponding raw
   registers.  Take care of alignment and size problems.  */

static enum register_status
mips_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int cookednum, gdb_byte *buf)
{
  int rawnum = cookednum % gdbarch_num_regs (gdbarch);
  gdb_assert (cookednum >= gdbarch_num_regs (gdbarch)
	      && cookednum < 2 * gdbarch_num_regs (gdbarch));
  if (register_size (gdbarch, rawnum) == register_size (gdbarch, cookednum))
    return regcache_raw_read (regcache, rawnum, buf);
  else if (register_size (gdbarch, rawnum) >
	   register_size (gdbarch, cookednum))
    {
      if (gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p)
	return regcache_raw_read_part (regcache, rawnum, 0, 4, buf);
      else
	{
	  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
	  LONGEST regval;
	  enum register_status status;

	  status = regcache_raw_read_signed (regcache, rawnum, &regval);
	  if (status == REG_VALID)
	    store_signed_integer (buf, 4, byte_order, regval);
	  return status;
	}
    }
  else
    internal_error (__FILE__, __LINE__, _("bad register size"));
}

static void
mips_pseudo_register_write (struct gdbarch *gdbarch,
			    struct regcache *regcache, int cookednum,
			    const gdb_byte *buf)
{
  int rawnum = cookednum % gdbarch_num_regs (gdbarch);
  gdb_assert (cookednum >= gdbarch_num_regs (gdbarch)
	      && cookednum < 2 * gdbarch_num_regs (gdbarch));
  if (register_size (gdbarch, rawnum) == register_size (gdbarch, cookednum))
    regcache_raw_write (regcache, rawnum, buf);
  else if (register_size (gdbarch, rawnum) >
	   register_size (gdbarch, cookednum))
    {
      if (gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p)
	regcache_raw_write_part (regcache, rawnum, 0, 4, buf);
      else
	{
	  /* Sign extend the shortened version of the register prior
	     to placing it in the raw register.  This is required for
	     some mips64 parts in order to avoid unpredictable behavior.  */
	  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
	  LONGEST regval = extract_signed_integer (buf, 4, byte_order);
	  regcache_raw_write_signed (regcache, rawnum, regval);
	}
    }
  else
    internal_error (__FILE__, __LINE__, _("bad register size"));
}

static int
mips_ax_pseudo_register_collect (struct gdbarch *gdbarch,
				 struct agent_expr *ax, int reg)
{
  int rawnum = reg % gdbarch_num_regs (gdbarch);
  gdb_assert (reg >= gdbarch_num_regs (gdbarch)
	      && reg < 2 * gdbarch_num_regs (gdbarch));

  ax_reg_mask (ax, rawnum);

  return 0;
}

static int
mips_ax_pseudo_register_push_stack (struct gdbarch *gdbarch,
				    struct agent_expr *ax, int reg)
{
  int rawnum = reg % gdbarch_num_regs (gdbarch);
  gdb_assert (reg >= gdbarch_num_regs (gdbarch)
	      && reg < 2 * gdbarch_num_regs (gdbarch));
  if (register_size (gdbarch, rawnum) >= register_size (gdbarch, reg))
    {
      ax_reg (ax, rawnum);

      if (register_size (gdbarch, rawnum) > register_size (gdbarch, reg))
        {
	  if (!gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p
	      || gdbarch_byte_order (gdbarch) != BFD_ENDIAN_BIG)
	    {
	      ax_const_l (ax, 32);
	      ax_simple (ax, aop_lsh);
	    }
	  ax_const_l (ax, 32);
	  ax_simple (ax, aop_rsh_signed);
	}
    }
  else
    internal_error (__FILE__, __LINE__, _("bad register size"));

  return 0;
}

/* Table to translate 3-bit register field to actual register number.  */
static const signed char mips_reg3_to_reg[8] = { 16, 17, 2, 3, 4, 5, 6, 7 };

/* Heuristic_proc_start may hunt through the text section for a long
   time across a 2400 baud serial line.  Allows the user to limit this
   search.  */

static int heuristic_fence_post = 0;

/* Number of bytes of storage in the actual machine representation for
   register N.  NOTE: This defines the pseudo register type so need to
   rebuild the architecture vector.  */

static int mips64_transfers_32bit_regs_p = 0;

static void
set_mips64_transfers_32bit_regs (char *args, int from_tty,
				 struct cmd_list_element *c)
{
  struct gdbarch_info info;
  gdbarch_info_init (&info);
  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
     instead of relying on globals.  Doing that would let generic code
     handle the search for this specific architecture.  */
  if (!gdbarch_update_p (info))
    {
      mips64_transfers_32bit_regs_p = 0;
      error (_("32-bit compatibility mode not supported"));
    }
}

/* Convert to/from a register and the corresponding memory value.  */

/* This predicate tests for the case of an 8 byte floating point
   value that is being transferred to or from a pair of floating point
   registers each of which are (or are considered to be) only 4 bytes
   wide.  */
static int
mips_convert_register_float_case_p (struct gdbarch *gdbarch, int regnum,
				    struct type *type)
{
  return (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG
	  && register_size (gdbarch, regnum) == 4
	  && mips_float_register_p (gdbarch, regnum)
	  && TYPE_CODE (type) == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8);
}

/* This predicate tests for the case of a value of less than 8
   bytes in width that is being transfered to or from an 8 byte
   general purpose register.  */
static int
mips_convert_register_gpreg_case_p (struct gdbarch *gdbarch, int regnum,
				    struct type *type)
{
  int num_regs = gdbarch_num_regs (gdbarch);

  return (register_size (gdbarch, regnum) == 8
          && regnum % num_regs > 0 && regnum % num_regs < 32
          && TYPE_LENGTH (type) < 8);
}

static int
mips_convert_register_p (struct gdbarch *gdbarch,
			 int regnum, struct type *type)
{
  return (mips_convert_register_float_case_p (gdbarch, regnum, type)
	  || mips_convert_register_gpreg_case_p (gdbarch, regnum, type));
}

static int
mips_register_to_value (struct frame_info *frame, int regnum,
			struct type *type, gdb_byte *to,
			int *optimizedp, int *unavailablep)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);

  if (mips_convert_register_float_case_p (gdbarch, regnum, type))
    {
      get_frame_register (frame, regnum + 0, to + 4);
      get_frame_register (frame, regnum + 1, to + 0);

      if (!get_frame_register_bytes (frame, regnum + 0, 0, 4, to + 4,
				     optimizedp, unavailablep))
	return 0;

      if (!get_frame_register_bytes (frame, regnum + 1, 0, 4, to + 0,
				     optimizedp, unavailablep))
	return 0;
      *optimizedp = *unavailablep = 0;
      return 1;
    }
  else if (mips_convert_register_gpreg_case_p (gdbarch, regnum, type))
    {
      int len = TYPE_LENGTH (type);
      CORE_ADDR offset;

      offset = gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG ? 8 - len : 0;
      if (!get_frame_register_bytes (frame, regnum, offset, len, to,
				     optimizedp, unavailablep))
	return 0;

      *optimizedp = *unavailablep = 0;
      return 1;
    }
  else
    {
      internal_error (__FILE__, __LINE__,
                      _("mips_register_to_value: unrecognized case"));
    }
}

static void
mips_value_to_register (struct frame_info *frame, int regnum,
			struct type *type, const gdb_byte *from)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);

  if (mips_convert_register_float_case_p (gdbarch, regnum, type))
    {
      put_frame_register (frame, regnum + 0, from + 4);
      put_frame_register (frame, regnum + 1, from + 0);
    }
  else if (mips_convert_register_gpreg_case_p (gdbarch, regnum, type))
    {
      gdb_byte fill[8];
      int len = TYPE_LENGTH (type);
      
      /* Sign extend values, irrespective of type, that are stored to 
         a 64-bit general purpose register.  (32-bit unsigned values
	 are stored as signed quantities within a 64-bit register.
	 When performing an operation, in compiled code, that combines
	 a 32-bit unsigned value with a signed 64-bit value, a type
	 conversion is first performed that zeroes out the high 32 bits.)  */
      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	{
	  if (from[0] & 0x80)
	    store_signed_integer (fill, 8, BFD_ENDIAN_BIG, -1);
	  else
	    store_signed_integer (fill, 8, BFD_ENDIAN_BIG, 0);
	  put_frame_register_bytes (frame, regnum, 0, 8 - len, fill);
	  put_frame_register_bytes (frame, regnum, 8 - len, len, from);
	}
      else
	{
	  if (from[len-1] & 0x80)
	    store_signed_integer (fill, 8, BFD_ENDIAN_LITTLE, -1);
	  else
	    store_signed_integer (fill, 8, BFD_ENDIAN_LITTLE, 0);
	  put_frame_register_bytes (frame, regnum, 0, len, from);
	  put_frame_register_bytes (frame, regnum, len, 8 - len, fill);
	}
    }
  else
    {
      internal_error (__FILE__, __LINE__,
                      _("mips_value_to_register: unrecognized case"));
    }
}

/* Return the GDB type object for the "standard" data type of data in
   register REG.  */

static struct type *
mips_register_type (struct gdbarch *gdbarch, int regnum)
{
  gdb_assert (regnum >= 0 && regnum < 2 * gdbarch_num_regs (gdbarch));
  if (mips_float_register_p (gdbarch, regnum))
    {
      /* The floating-point registers raw, or cooked, always match
         mips_isa_regsize(), and also map 1:1, byte for byte.  */
      if (mips_isa_regsize (gdbarch) == 4)
	return builtin_type (gdbarch)->builtin_float;
      else
	return builtin_type (gdbarch)->builtin_double;
    }
  else if (regnum < gdbarch_num_regs (gdbarch))
    {
      /* The raw or ISA registers.  These are all sized according to
	 the ISA regsize.  */
      if (mips_isa_regsize (gdbarch) == 4)
	return builtin_type (gdbarch)->builtin_int32;
      else
	return builtin_type (gdbarch)->builtin_int64;
    }
  else
    {
      int rawnum = regnum - gdbarch_num_regs (gdbarch);

      /* The cooked or ABI registers.  These are sized according to
	 the ABI (with a few complications).  */
      if (rawnum == mips_regnum (gdbarch)->fp_control_status
	  || rawnum == mips_regnum (gdbarch)->fp_implementation_revision)
	return builtin_type (gdbarch)->builtin_int32;
      else if (gdbarch_osabi (gdbarch) != GDB_OSABI_IRIX
	       && gdbarch_osabi (gdbarch) != GDB_OSABI_LINUX
	       && rawnum >= MIPS_FIRST_EMBED_REGNUM
	       && rawnum <= MIPS_LAST_EMBED_REGNUM)
	/* The pseudo/cooked view of the embedded registers is always
	   32-bit.  The raw view is handled below.  */
	return builtin_type (gdbarch)->builtin_int32;
      else if (gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p)
	/* The target, while possibly using a 64-bit register buffer,
	   is only transfering 32-bits of each integer register.
	   Reflect this in the cooked/pseudo (ABI) register value.  */
	return builtin_type (gdbarch)->builtin_int32;
      else if (mips_abi_regsize (gdbarch) == 4)
	/* The ABI is restricted to 32-bit registers (the ISA could be
	   32- or 64-bit).  */
	return builtin_type (gdbarch)->builtin_int32;
      else
	/* 64-bit ABI.  */
	return builtin_type (gdbarch)->builtin_int64;
    }
}

/* Return the GDB type for the pseudo register REGNUM, which is the
   ABI-level view.  This function is only called if there is a target
   description which includes registers, so we know precisely the
   types of hardware registers.  */

static struct type *
mips_pseudo_register_type (struct gdbarch *gdbarch, int regnum)
{
  const int num_regs = gdbarch_num_regs (gdbarch);
  int rawnum = regnum % num_regs;
  struct type *rawtype;

  gdb_assert (regnum >= num_regs && regnum < 2 * num_regs);

  /* Absent registers are still absent.  */
  rawtype = gdbarch_register_type (gdbarch, rawnum);
  if (TYPE_LENGTH (rawtype) == 0)
    return rawtype;

  if (mips_float_register_p (gdbarch, rawnum))
    /* Present the floating point registers however the hardware did;
       do not try to convert between FPU layouts.  */
    return rawtype;

  /* Use pointer types for registers if we can.  For n32 we can not,
     since we do not have a 64-bit pointer type.  */
  if (mips_abi_regsize (gdbarch)
      == TYPE_LENGTH (builtin_type (gdbarch)->builtin_data_ptr))
    {
      if (rawnum == MIPS_SP_REGNUM
	  || rawnum == mips_regnum (gdbarch)->badvaddr)
	return builtin_type (gdbarch)->builtin_data_ptr;
      else if (rawnum == mips_regnum (gdbarch)->pc)
	return builtin_type (gdbarch)->builtin_func_ptr;
    }

  if (mips_abi_regsize (gdbarch) == 4 && TYPE_LENGTH (rawtype) == 8
      && ((rawnum >= MIPS_ZERO_REGNUM && rawnum <= MIPS_PS_REGNUM)
	  || rawnum == mips_regnum (gdbarch)->lo
	  || rawnum == mips_regnum (gdbarch)->hi
	  || rawnum == mips_regnum (gdbarch)->badvaddr
	  || rawnum == mips_regnum (gdbarch)->cause
	  || rawnum == mips_regnum (gdbarch)->pc
	  || (mips_regnum (gdbarch)->dspacc != -1
	      && rawnum >= mips_regnum (gdbarch)->dspacc
	      && rawnum < mips_regnum (gdbarch)->dspacc + 6)))
    return builtin_type (gdbarch)->builtin_int32;

  if (gdbarch_osabi (gdbarch) != GDB_OSABI_IRIX
      && gdbarch_osabi (gdbarch) != GDB_OSABI_LINUX
      && rawnum >= MIPS_EMBED_FP0_REGNUM + 32
      && rawnum <= MIPS_LAST_EMBED_REGNUM)
    {
      /* The pseudo/cooked view of embedded registers is always
	 32-bit, even if the target transfers 64-bit values for them.
	 New targets relying on XML descriptions should only transfer
	 the necessary 32 bits, but older versions of GDB expected 64,
	 so allow the target to provide 64 bits without interfering
	 with the displayed type.  */
      return builtin_type (gdbarch)->builtin_int32;
    }

  /* For all other registers, pass through the hardware type.  */
  return rawtype;
}

/* Should the upper word of 64-bit addresses be zeroed?  */
enum auto_boolean mask_address_var = AUTO_BOOLEAN_AUTO;

static int
mips_mask_address_p (struct gdbarch_tdep *tdep)
{
  switch (mask_address_var)
    {
    case AUTO_BOOLEAN_TRUE:
      return 1;
    case AUTO_BOOLEAN_FALSE:
      return 0;
      break;
    case AUTO_BOOLEAN_AUTO:
      return tdep->default_mask_address_p;
    default:
      internal_error (__FILE__, __LINE__,
		      _("mips_mask_address_p: bad switch"));
      return -1;
    }
}

static void
show_mask_address (struct ui_file *file, int from_tty,
		   struct cmd_list_element *c, const char *value)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (target_gdbarch ());

  deprecated_show_value_hack (file, from_tty, c, value);
  switch (mask_address_var)
    {
    case AUTO_BOOLEAN_TRUE:
      printf_filtered ("The 32 bit mips address mask is enabled\n");
      break;
    case AUTO_BOOLEAN_FALSE:
      printf_filtered ("The 32 bit mips address mask is disabled\n");
      break;
    case AUTO_BOOLEAN_AUTO:
      printf_filtered
	("The 32 bit address mask is set automatically.  Currently %s\n",
	 mips_mask_address_p (tdep) ? "enabled" : "disabled");
      break;
    default:
      internal_error (__FILE__, __LINE__, _("show_mask_address: bad switch"));
      break;
    }
}

/* Tell if the program counter value in MEMADDR is in a standard ISA
   function.  */

int
mips_pc_is_mips (CORE_ADDR memaddr)
{
  struct bound_minimal_symbol sym;

  /* Flags indicating that this is a MIPS16 or microMIPS function is
     stored by elfread.c in the high bit of the info field.  Use this
     to decide if the function is standard MIPS.  Otherwise if bit 0
     of the address is clear, then this is a standard MIPS function.  */
  sym = lookup_minimal_symbol_by_pc (memaddr);
  if (sym.minsym)
    return msymbol_is_mips (sym.minsym);
  else
    return is_mips_addr (memaddr);
}

/* Tell if the program counter value in MEMADDR is in a MIPS16 function.  */

int
mips_pc_is_mips16 (struct gdbarch *gdbarch, CORE_ADDR memaddr)
{
  struct bound_minimal_symbol sym;

  /* A flag indicating that this is a MIPS16 function is stored by
     elfread.c in the high bit of the info field.  Use this to decide
     if the function is MIPS16.  Otherwise if bit 0 of the address is
     set, then ELF file flags will tell if this is a MIPS16 function.  */
  sym = lookup_minimal_symbol_by_pc (memaddr);
  if (sym.minsym)
    return msymbol_is_mips16 (sym.minsym);
  else
    return is_mips16_addr (gdbarch, memaddr);
}

/* Tell if the program counter value in MEMADDR is in a microMIPS function.  */

int
mips_pc_is_micromips (struct gdbarch *gdbarch, CORE_ADDR memaddr)
{
  struct bound_minimal_symbol sym;

  /* A flag indicating that this is a microMIPS function is stored by
     elfread.c in the high bit of the info field.  Use this to decide
     if the function is microMIPS.  Otherwise if bit 0 of the address
     is set, then ELF file flags will tell if this is a microMIPS
     function.  */
  sym = lookup_minimal_symbol_by_pc (memaddr);
  if (sym.minsym)
    return msymbol_is_micromips (sym.minsym);
  else
    return is_micromips_addr (gdbarch, memaddr);
}

/* Tell the ISA type of the function the program counter value in MEMADDR
   is in.  */

static enum mips_isa
mips_pc_isa (struct gdbarch *gdbarch, CORE_ADDR memaddr)
{
  struct bound_minimal_symbol sym;

  /* A flag indicating that this is a MIPS16 or a microMIPS function
     is stored by elfread.c in the high bit of the info field.  Use
     this to decide if the function is MIPS16 or microMIPS or normal
     MIPS.  Otherwise if bit 0 of the address is set, then ELF file
     flags will tell if this is a MIPS16 or a microMIPS function.  */
  sym = lookup_minimal_symbol_by_pc (memaddr);
  if (sym.minsym)
    {
      if (msymbol_is_micromips (sym.minsym))
	return ISA_MICROMIPS;
      else if (msymbol_is_mips16 (sym.minsym))
	return ISA_MIPS16;
      else
	return ISA_MIPS;
    }
  else
    {
      if (is_mips_addr (memaddr))
	return ISA_MIPS;
      else if (is_micromips_addr (gdbarch, memaddr))
	return ISA_MICROMIPS;
      else
	return ISA_MIPS16;
    }
}

/* Various MIPS16 thunk (aka stub or trampoline) names.  */

static const char mips_str_mips16_call_stub[] = "__mips16_call_stub_";
static const char mips_str_mips16_ret_stub[] = "__mips16_ret_";
static const char mips_str_call_fp_stub[] = "__call_stub_fp_";
static const char mips_str_call_stub[] = "__call_stub_";
static const char mips_str_fn_stub[] = "__fn_stub_";

/* This is used as a PIC thunk prefix.  */

static const char mips_str_pic[] = ".pic.";

/* Return non-zero if the PC is inside a call thunk (aka stub or
   trampoline) that should be treated as a temporary frame.  */

static int
mips_in_frame_stub (CORE_ADDR pc)
{
  CORE_ADDR start_addr;
  const char *name;

  /* Find the starting address of the function containing the PC.  */
  if (find_pc_partial_function (pc, &name, &start_addr, NULL) == 0)
    return 0;

  /* If the PC is in __mips16_call_stub_*, this is a call/return stub.  */
  if (strncmp (name, mips_str_mips16_call_stub,
	       strlen (mips_str_mips16_call_stub)) == 0)
    return 1;
  /* If the PC is in __call_stub_*, this is a call/return or a call stub.  */
  if (strncmp (name, mips_str_call_stub, strlen (mips_str_call_stub)) == 0)
    return 1;
  /* If the PC is in __fn_stub_*, this is a call stub.  */
  if (strncmp (name, mips_str_fn_stub, strlen (mips_str_fn_stub)) == 0)
    return 1;

  return 0;			/* Not a stub.  */
}

/* MIPS believes that the PC has a sign extended value.  Perhaps the
   all registers should be sign extended for simplicity?  */

static CORE_ADDR
mips_read_pc (struct regcache *regcache)
{
  int regnum = gdbarch_pc_regnum (get_regcache_arch (regcache));
  LONGEST pc;

  regcache_cooked_read_signed (regcache, regnum, &pc);
  if (is_compact_addr (pc))
    pc = unmake_compact_addr (pc);
  return pc;
}

static CORE_ADDR
mips_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  CORE_ADDR pc;

  pc = frame_unwind_register_signed (next_frame, gdbarch_pc_regnum (gdbarch));
  if (is_compact_addr (pc))
    pc = unmake_compact_addr (pc);
  /* macro/2012-04-20: This hack skips over MIPS16 call thunks as
     intermediate frames.  In this case we can get the caller's address
     from $ra, or if $ra contains an address within a thunk as well, then
     it must be in the return path of __mips16_call_stub_{s,d}{f,c}_{0..10}
     and thus the caller's address is in $s2.  */
  if (frame_relative_level (next_frame) >= 0 && mips_in_frame_stub (pc))
    {
      pc = frame_unwind_register_signed
	     (next_frame, gdbarch_num_regs (gdbarch) + MIPS_RA_REGNUM);
      if (is_compact_addr (pc))
	pc = unmake_compact_addr (pc);
      if (mips_in_frame_stub (pc))
	{
	  pc = frame_unwind_register_signed
		 (next_frame, gdbarch_num_regs (gdbarch) + MIPS_S2_REGNUM);
	  if (is_compact_addr (pc))
	    pc = unmake_compact_addr (pc);
	}
    }
  return pc;
}

static CORE_ADDR
mips_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_signed
	   (next_frame, gdbarch_num_regs (gdbarch) + MIPS_SP_REGNUM);
}

/* Assuming THIS_FRAME is a dummy, return the frame ID of that
   dummy frame.  The frame ID's base needs to match the TOS value
   saved by save_dummy_frame_tos(), and the PC match the dummy frame's
   breakpoint.  */

static struct frame_id
mips_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  return frame_id_build
	   (get_frame_register_signed (this_frame,
				       gdbarch_num_regs (gdbarch)
				       + MIPS_SP_REGNUM),
	    get_frame_pc (this_frame));
}

/* Implement the "write_pc" gdbarch method.  */

void
mips_write_pc (struct regcache *regcache, CORE_ADDR pc)
{
  int regnum = gdbarch_pc_regnum (get_regcache_arch (regcache));

  if (mips_pc_is_mips (pc))
    regcache_cooked_write_unsigned (regcache, regnum, pc);
  else
    regcache_cooked_write_unsigned (regcache, regnum, make_compact_addr (pc));
}

/* Fetch and return instruction from the specified location.  Handle
   MIPS16/microMIPS as appropriate.  */

static ULONGEST
mips_fetch_instruction (struct gdbarch *gdbarch,
			enum mips_isa isa, CORE_ADDR addr, int *statusp)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[MIPS_INSN32_SIZE];
  int instlen;
  int status;

  switch (isa)
    {
    case ISA_MICROMIPS:
    case ISA_MIPS16:
      instlen = MIPS_INSN16_SIZE;
      addr = unmake_compact_addr (addr);
      break;
    case ISA_MIPS:
      instlen = MIPS_INSN32_SIZE;
      break;
    default:
      internal_error (__FILE__, __LINE__, _("invalid ISA"));
      break;
    }
  status = target_read_memory (addr, buf, instlen);
  if (statusp != NULL)
    *statusp = status;
  if (status)
    {
      if (statusp == NULL)
	memory_error (status, addr);
      return 0;
    }
  return extract_unsigned_integer (buf, instlen, byte_order);
}

/* These are the fields of 32 bit mips instructions.  */
#define mips32_op(x) (x >> 26)
#define itype_op(x) (x >> 26)
#define itype_rs(x) ((x >> 21) & 0x1f)
#define itype_rt(x) ((x >> 16) & 0x1f)
#define itype_immediate(x) (x & 0xffff)

#define jtype_op(x) (x >> 26)
#define jtype_target(x) (x & 0x03ffffff)

#define rtype_op(x) (x >> 26)
#define rtype_rs(x) ((x >> 21) & 0x1f)
#define rtype_rt(x) ((x >> 16) & 0x1f)
#define rtype_rd(x) ((x >> 11) & 0x1f)
#define rtype_shamt(x) ((x >> 6) & 0x1f)
#define rtype_funct(x) (x & 0x3f)

/* MicroMIPS instruction fields.  */
#define micromips_op(x) ((x) >> 10)

/* 16-bit/32-bit-high-part instruction formats, B and S refer to the lowest
   bit and the size respectively of the field extracted.  */
#define b0s4_imm(x) ((x) & 0xf)
#define b0s5_imm(x) ((x) & 0x1f)
#define b0s5_reg(x) ((x) & 0x1f)
#define b0s7_imm(x) ((x) & 0x7f)
#define b0s10_imm(x) ((x) & 0x3ff)
#define b1s4_imm(x) (((x) >> 1) & 0xf)
#define b1s9_imm(x) (((x) >> 1) & 0x1ff)
#define b2s3_cc(x) (((x) >> 2) & 0x7)
#define b4s2_regl(x) (((x) >> 4) & 0x3)
#define b5s5_op(x) (((x) >> 5) & 0x1f)
#define b5s5_reg(x) (((x) >> 5) & 0x1f)
#define b6s4_op(x) (((x) >> 6) & 0xf)
#define b7s3_reg(x) (((x) >> 7) & 0x7)

/* 32-bit instruction formats, B and S refer to the lowest bit and the size
   respectively of the field extracted.  */
#define b0s6_op(x) ((x) & 0x3f)
#define b0s11_op(x) ((x) & 0x7ff)
#define b0s12_imm(x) ((x) & 0xfff)
#define b0s16_imm(x) ((x) & 0xffff)
#define b0s26_imm(x) ((x) & 0x3ffffff)
#define b6s10_ext(x) (((x) >> 6) & 0x3ff)
#define b11s5_reg(x) (((x) >> 11) & 0x1f)
#define b12s4_op(x) (((x) >> 12) & 0xf)

/* Return the size in bytes of the instruction INSN encoded in the ISA
   instruction set.  */

static int
mips_insn_size (enum mips_isa isa, ULONGEST insn)
{
  switch (isa)
    {
    case ISA_MICROMIPS:
      if (micromips_op (insn) == 0x1f)
        return 3 * MIPS_INSN16_SIZE;
      else if (((micromips_op (insn) & 0x4) == 0x4)
	       || ((micromips_op (insn) & 0x7) == 0x0))
        return 2 * MIPS_INSN16_SIZE;
      else
        return MIPS_INSN16_SIZE;
    case ISA_MIPS16:
      if ((insn & 0xf800) == 0xf000)
	return 2 * MIPS_INSN16_SIZE;
      else
	return MIPS_INSN16_SIZE;
    case ISA_MIPS:
	return MIPS_INSN32_SIZE;
    }
  internal_error (__FILE__, __LINE__, _("invalid ISA"));
}

static LONGEST
mips32_relative_offset (ULONGEST inst)
{
  return ((itype_immediate (inst) ^ 0x8000) - 0x8000) << 2;
}

/* Determine the address of the next instruction executed after the INST
   floating condition branch instruction at PC.  COUNT specifies the
   number of the floating condition bits tested by the branch.  */

static CORE_ADDR
mips32_bc1_pc (struct gdbarch *gdbarch, struct frame_info *frame,
	       ULONGEST inst, CORE_ADDR pc, int count)
{
  int fcsr = mips_regnum (gdbarch)->fp_control_status;
  int cnum = (itype_rt (inst) >> 2) & (count - 1);
  int tf = itype_rt (inst) & 1;
  int mask = (1 << count) - 1;
  ULONGEST fcs;
  int cond;

  if (fcsr == -1)
    /* No way to handle; it'll most likely trap anyway.  */
    return pc;

  fcs = get_frame_register_unsigned (frame, fcsr);
  cond = ((fcs >> 24) & 0xfe) | ((fcs >> 23) & 0x01);

  if (((cond >> cnum) & mask) != mask * !tf)
    pc += mips32_relative_offset (inst);
  else
    pc += 4;

  return pc;
}

/* Return nonzero if the gdbarch is an Octeon series.  */

static int
is_octeon (struct gdbarch *gdbarch)
{
  const struct bfd_arch_info *info = gdbarch_bfd_arch_info (gdbarch);

  return (info->mach == bfd_mach_mips_octeon
         || info->mach == bfd_mach_mips_octeonp
         || info->mach == bfd_mach_mips_octeon2);
}

/* Return true if the OP represents the Octeon's BBIT instruction.  */

static int
is_octeon_bbit_op (int op, struct gdbarch *gdbarch)
{
  if (!is_octeon (gdbarch))
    return 0;
  /* BBIT0 is encoded as LWC2: 110 010.  */
  /* BBIT032 is encoded as LDC2: 110 110.  */
  /* BBIT1 is encoded as SWC2: 111 010.  */
  /* BBIT132 is encoded as SDC2: 111 110.  */
  if (op == 50 || op == 54 || op == 58 || op == 62)
    return 1;
  return 0;
}


/* Determine where to set a single step breakpoint while considering
   branch prediction.  */

static CORE_ADDR
mips32_next_pc (struct frame_info *frame, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  unsigned long inst;
  int op;
  inst = mips_fetch_instruction (gdbarch, ISA_MIPS, pc, NULL);
  op = itype_op (inst);
  if ((inst & 0xe0000000) != 0)		/* Not a special, jump or branch
					   instruction.  */
    {
      if (op >> 2 == 5)
	/* BEQL, BNEL, BLEZL, BGTZL: bits 0101xx */
	{
	  switch (op & 0x03)
	    {
	    case 0:		/* BEQL */
	      goto equal_branch;
	    case 1:		/* BNEL */
	      goto neq_branch;
	    case 2:		/* BLEZL */
	      goto less_branch;
	    case 3:		/* BGTZL */
	      goto greater_branch;
	    default:
	      pc += 4;
	    }
	}
      else if (op == 17 && itype_rs (inst) == 8)
	/* BC1F, BC1FL, BC1T, BC1TL: 010001 01000 */
	pc = mips32_bc1_pc (gdbarch, frame, inst, pc + 4, 1);
      else if (op == 17 && itype_rs (inst) == 9
	       && (itype_rt (inst) & 2) == 0)
	/* BC1ANY2F, BC1ANY2T: 010001 01001 xxx0x */
	pc = mips32_bc1_pc (gdbarch, frame, inst, pc + 4, 2);
      else if (op == 17 && itype_rs (inst) == 10
	       && (itype_rt (inst) & 2) == 0)
	/* BC1ANY4F, BC1ANY4T: 010001 01010 xxx0x */
	pc = mips32_bc1_pc (gdbarch, frame, inst, pc + 4, 4);
      else if (op == 29)
	/* JALX: 011101 */
	/* The new PC will be alternate mode.  */
	{
	  unsigned long reg;

	  reg = jtype_target (inst) << 2;
	  /* Add 1 to indicate 16-bit mode -- invert ISA mode.  */
	  pc = ((pc + 4) & ~(CORE_ADDR) 0x0fffffff) + reg + 1;
	}
      else if (is_octeon_bbit_op (op, gdbarch))
	{
	  int bit, branch_if;

	  branch_if = op == 58 || op == 62;
	  bit = itype_rt (inst);

	  /* Take into account the *32 instructions.  */
	  if (op == 54 || op == 62)
	    bit += 32;

	  if (((get_frame_register_signed (frame,
					   itype_rs (inst)) >> bit) & 1)
              == branch_if)
	    pc += mips32_relative_offset (inst) + 4;
          else
	    pc += 8;        /* After the delay slot.  */
	}

      else
	pc += 4;		/* Not a branch, next instruction is easy.  */
    }
  else
    {				/* This gets way messy.  */

      /* Further subdivide into SPECIAL, REGIMM and other.  */
      switch (op & 0x07)	/* Extract bits 28,27,26.  */
	{
	case 0:		/* SPECIAL */
	  op = rtype_funct (inst);
	  switch (op)
	    {
	    case 8:		/* JR */
	    case 9:		/* JALR */
	      /* Set PC to that address.  */
	      pc = get_frame_register_signed (frame, rtype_rs (inst));
	      break;
	    case 12:            /* SYSCALL */
	      {
		struct gdbarch_tdep *tdep;

		tdep = gdbarch_tdep (get_frame_arch (frame));
		if (tdep->syscall_next_pc != NULL)
		  pc = tdep->syscall_next_pc (frame);
		else
		  pc += 4;
	      }
	      break;
	    default:
	      pc += 4;
	    }

	  break;		/* end SPECIAL */
	case 1:			/* REGIMM */
	  {
	    op = itype_rt (inst);	/* branch condition */
	    switch (op)
	      {
	      case 0:		/* BLTZ */
	      case 2:		/* BLTZL */
	      case 16:		/* BLTZAL */
	      case 18:		/* BLTZALL */
	      less_branch:
		if (get_frame_register_signed (frame, itype_rs (inst)) < 0)
		  pc += mips32_relative_offset (inst) + 4;
		else
		  pc += 8;	/* after the delay slot */
		break;
	      case 1:		/* BGEZ */
	      case 3:		/* BGEZL */
	      case 17:		/* BGEZAL */
	      case 19:		/* BGEZALL */
		if (get_frame_register_signed (frame, itype_rs (inst)) >= 0)
		  pc += mips32_relative_offset (inst) + 4;
		else
		  pc += 8;	/* after the delay slot */
		break;
	      case 0x1c:	/* BPOSGE32 */
	      case 0x1e:	/* BPOSGE64 */
		pc += 4;
		if (itype_rs (inst) == 0)
		  {
		    unsigned int pos = (op & 2) ? 64 : 32;
		    int dspctl = mips_regnum (gdbarch)->dspctl;

		    if (dspctl == -1)
		      /* No way to handle; it'll most likely trap anyway.  */
		      break;

		    if ((get_frame_register_unsigned (frame,
						      dspctl) & 0x7f) >= pos)
		      pc += mips32_relative_offset (inst);
		    else
		      pc += 4;
		  }
		break;
		/* All of the other instructions in the REGIMM category */
	      default:
		pc += 4;
	      }
	  }
	  break;		/* end REGIMM */
	case 2:		/* J */
	case 3:		/* JAL */
	  {
	    unsigned long reg;
	    reg = jtype_target (inst) << 2;
	    /* Upper four bits get never changed...  */
	    pc = reg + ((pc + 4) & ~(CORE_ADDR) 0x0fffffff);
	  }
	  break;
	case 4:		/* BEQ, BEQL */
	equal_branch:
	  if (get_frame_register_signed (frame, itype_rs (inst)) ==
	      get_frame_register_signed (frame, itype_rt (inst)))
	    pc += mips32_relative_offset (inst) + 4;
	  else
	    pc += 8;
	  break;
	case 5:		/* BNE, BNEL */
	neq_branch:
	  if (get_frame_register_signed (frame, itype_rs (inst)) !=
	      get_frame_register_signed (frame, itype_rt (inst)))
	    pc += mips32_relative_offset (inst) + 4;
	  else
	    pc += 8;
	  break;
	case 6:		/* BLEZ, BLEZL */
	  if (get_frame_register_signed (frame, itype_rs (inst)) <= 0)
	    pc += mips32_relative_offset (inst) + 4;
	  else
	    pc += 8;
	  break;
	case 7:
	default:
	greater_branch:	/* BGTZ, BGTZL */
	  if (get_frame_register_signed (frame, itype_rs (inst)) > 0)
	    pc += mips32_relative_offset (inst) + 4;
	  else
	    pc += 8;
	  break;
	}			/* switch */
    }				/* else */
  return pc;
}				/* mips32_next_pc */

/* Extract the 7-bit signed immediate offset from the microMIPS instruction
   INSN.  */

static LONGEST
micromips_relative_offset7 (ULONGEST insn)
{
  return ((b0s7_imm (insn) ^ 0x40) - 0x40) << 1;
}

/* Extract the 10-bit signed immediate offset from the microMIPS instruction
   INSN.  */

static LONGEST
micromips_relative_offset10 (ULONGEST insn)
{
  return ((b0s10_imm (insn) ^ 0x200) - 0x200) << 1;
}

/* Extract the 16-bit signed immediate offset from the microMIPS instruction
   INSN.  */

static LONGEST
micromips_relative_offset16 (ULONGEST insn)
{
  return ((b0s16_imm (insn) ^ 0x8000) - 0x8000) << 1;
}

/* Return the size in bytes of the microMIPS instruction at the address PC.  */

static int
micromips_pc_insn_size (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  ULONGEST insn;

  insn = mips_fetch_instruction (gdbarch, ISA_MICROMIPS, pc, NULL);
  return mips_insn_size (ISA_MICROMIPS, insn);
}

/* Calculate the address of the next microMIPS instruction to execute
   after the INSN coprocessor 1 conditional branch instruction at the
   address PC.  COUNT denotes the number of coprocessor condition bits
   examined by the branch.  */

static CORE_ADDR
micromips_bc1_pc (struct gdbarch *gdbarch, struct frame_info *frame,
		  ULONGEST insn, CORE_ADDR pc, int count)
{
  int fcsr = mips_regnum (gdbarch)->fp_control_status;
  int cnum = b2s3_cc (insn >> 16) & (count - 1);
  int tf = b5s5_op (insn >> 16) & 1;
  int mask = (1 << count) - 1;
  ULONGEST fcs;
  int cond;

  if (fcsr == -1)
    /* No way to handle; it'll most likely trap anyway.  */
    return pc;

  fcs = get_frame_register_unsigned (frame, fcsr);
  cond = ((fcs >> 24) & 0xfe) | ((fcs >> 23) & 0x01);

  if (((cond >> cnum) & mask) != mask * !tf)
    pc += micromips_relative_offset16 (insn);
  else
    pc += micromips_pc_insn_size (gdbarch, pc);

  return pc;
}

/* Calculate the address of the next microMIPS instruction to execute
   after the instruction at the address PC.  */

static CORE_ADDR
micromips_next_pc (struct frame_info *frame, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  ULONGEST insn;

  insn = mips_fetch_instruction (gdbarch, ISA_MICROMIPS, pc, NULL);
  pc += MIPS_INSN16_SIZE;
  switch (mips_insn_size (ISA_MICROMIPS, insn))
    {
    /* 48-bit instructions.  */
    case 3 * MIPS_INSN16_SIZE: /* POOL48A: bits 011111 */
      /* No branch or jump instructions in this category.  */
      pc += 2 * MIPS_INSN16_SIZE;
      break;

    /* 32-bit instructions.  */
    case 2 * MIPS_INSN16_SIZE:
      insn <<= 16;
      insn |= mips_fetch_instruction (gdbarch, ISA_MICROMIPS, pc, NULL);
      pc += MIPS_INSN16_SIZE;
      switch (micromips_op (insn >> 16))
	{
	case 0x00: /* POOL32A: bits 000000 */
	  if (b0s6_op (insn) == 0x3c
				/* POOL32Axf: bits 000000 ... 111100 */
	      && (b6s10_ext (insn) & 0x2bf) == 0x3c)
				/* JALR, JALR.HB: 000000 000x111100 111100 */
				/* JALRS, JALRS.HB: 000000 010x111100 111100 */
	    pc = get_frame_register_signed (frame, b0s5_reg (insn >> 16));
	  break;

	case 0x10: /* POOL32I: bits 010000 */
	  switch (b5s5_op (insn >> 16))
	    {
	    case 0x00: /* BLTZ: bits 010000 00000 */
	    case 0x01: /* BLTZAL: bits 010000 00001 */
	    case 0x11: /* BLTZALS: bits 010000 10001 */
	      if (get_frame_register_signed (frame,
					     b0s5_reg (insn >> 16)) < 0)
		pc += micromips_relative_offset16 (insn);
	      else
		pc += micromips_pc_insn_size (gdbarch, pc);
	      break;

	    case 0x02: /* BGEZ: bits 010000 00010 */
	    case 0x03: /* BGEZAL: bits 010000 00011 */
	    case 0x13: /* BGEZALS: bits 010000 10011 */
	      if (get_frame_register_signed (frame,
					     b0s5_reg (insn >> 16)) >= 0)
		pc += micromips_relative_offset16 (insn);
	      else
		pc += micromips_pc_insn_size (gdbarch, pc);
	      break;

	    case 0x04: /* BLEZ: bits 010000 00100 */
	      if (get_frame_register_signed (frame,
					     b0s5_reg (insn >> 16)) <= 0)
		pc += micromips_relative_offset16 (insn);
	      else
		pc += micromips_pc_insn_size (gdbarch, pc);
	      break;

	    case 0x05: /* BNEZC: bits 010000 00101 */
	      if (get_frame_register_signed (frame,
					     b0s5_reg (insn >> 16)) != 0)
		pc += micromips_relative_offset16 (insn);
	      break;

	    case 0x06: /* BGTZ: bits 010000 00110 */
	      if (get_frame_register_signed (frame,
					     b0s5_reg (insn >> 16)) > 0)
		pc += micromips_relative_offset16 (insn);
	      else
		pc += micromips_pc_insn_size (gdbarch, pc);
	      break;

	    case 0x07: /* BEQZC: bits 010000 00111 */
	      if (get_frame_register_signed (frame,
					     b0s5_reg (insn >> 16)) == 0)
		pc += micromips_relative_offset16 (insn);
	      break;

	    case 0x14: /* BC2F: bits 010000 10100 xxx00 */
	    case 0x15: /* BC2T: bits 010000 10101 xxx00 */
	      if (((insn >> 16) & 0x3) == 0x0)
		/* BC2F, BC2T: don't know how to handle these.  */
		break;
	      break;

	    case 0x1a: /* BPOSGE64: bits 010000 11010 */
	    case 0x1b: /* BPOSGE32: bits 010000 11011 */
	      {
		unsigned int pos = (b5s5_op (insn >> 16) & 1) ? 32 : 64;
		int dspctl = mips_regnum (gdbarch)->dspctl;

		if (dspctl == -1)
		  /* No way to handle; it'll most likely trap anyway.  */
		  break;

		if ((get_frame_register_unsigned (frame,
						  dspctl) & 0x7f) >= pos)
		  pc += micromips_relative_offset16 (insn);
		else
		  pc += micromips_pc_insn_size (gdbarch, pc);
	      }
	      break;

	    case 0x1c: /* BC1F: bits 010000 11100 xxx00 */
		       /* BC1ANY2F: bits 010000 11100 xxx01 */
	    case 0x1d: /* BC1T: bits 010000 11101 xxx00 */
		       /* BC1ANY2T: bits 010000 11101 xxx01 */
	      if (((insn >> 16) & 0x2) == 0x0)
		pc = micromips_bc1_pc (gdbarch, frame, insn, pc,
				       ((insn >> 16) & 0x1) + 1);
	      break;

	    case 0x1e: /* BC1ANY4F: bits 010000 11110 xxx01 */
	    case 0x1f: /* BC1ANY4T: bits 010000 11111 xxx01 */
	      if (((insn >> 16) & 0x3) == 0x1)
		pc = micromips_bc1_pc (gdbarch, frame, insn, pc, 4);
	      break;
	    }
	  break;

	case 0x1d: /* JALS: bits 011101 */
	case 0x35: /* J: bits 110101 */
	case 0x3d: /* JAL: bits 111101 */
	    pc = ((pc | 0x7fffffe) ^ 0x7fffffe) | (b0s26_imm (insn) << 1);
	  break;

	case 0x25: /* BEQ: bits 100101 */
	    if (get_frame_register_signed (frame, b0s5_reg (insn >> 16))
		== get_frame_register_signed (frame, b5s5_reg (insn >> 16)))
	      pc += micromips_relative_offset16 (insn);
	    else
	      pc += micromips_pc_insn_size (gdbarch, pc);
	  break;

	case 0x2d: /* BNE: bits 101101 */
	    if (get_frame_register_signed (frame, b0s5_reg (insn >> 16))
		!= get_frame_register_signed (frame, b5s5_reg (insn >> 16)))
	      pc += micromips_relative_offset16 (insn);
	    else
	      pc += micromips_pc_insn_size (gdbarch, pc);
	  break;

	case 0x3c: /* JALX: bits 111100 */
	    pc = ((pc | 0xfffffff) ^ 0xfffffff) | (b0s26_imm (insn) << 2);
	  break;
	}
      break;

    /* 16-bit instructions.  */
    case MIPS_INSN16_SIZE:
      switch (micromips_op (insn))
	{
	case 0x11: /* POOL16C: bits 010001 */
	  if ((b5s5_op (insn) & 0x1c) == 0xc)
	    /* JR16, JRC, JALR16, JALRS16: 010001 011xx */
	    pc = get_frame_register_signed (frame, b0s5_reg (insn));
	  else if (b5s5_op (insn) == 0x18)
	    /* JRADDIUSP: bits 010001 11000 */
	    pc = get_frame_register_signed (frame, MIPS_RA_REGNUM);
	  break;

	case 0x23: /* BEQZ16: bits 100011 */
	  {
	    int rs = mips_reg3_to_reg[b7s3_reg (insn)];

	    if (get_frame_register_signed (frame, rs) == 0)
	      pc += micromips_relative_offset7 (insn);
	    else
	      pc += micromips_pc_insn_size (gdbarch, pc);
	  }
	  break;

	case 0x2b: /* BNEZ16: bits 101011 */
	  {
	    int rs = mips_reg3_to_reg[b7s3_reg (insn)];

	    if (get_frame_register_signed (frame, rs) != 0)
	      pc += micromips_relative_offset7 (insn);
	    else
	      pc += micromips_pc_insn_size (gdbarch, pc);
	  }
	  break;

	case 0x33: /* B16: bits 110011 */
	  pc += micromips_relative_offset10 (insn);
	  break;
	}
      break;
    }

  return pc;
}

/* Decoding the next place to set a breakpoint is irregular for the
   mips 16 variant, but fortunately, there fewer instructions.  We have
   to cope ith extensions for 16 bit instructions and a pair of actual
   32 bit instructions.  We dont want to set a single step instruction
   on the extend instruction either.  */

/* Lots of mips16 instruction formats */
/* Predicting jumps requires itype,ritype,i8type
   and their extensions      extItype,extritype,extI8type.  */
enum mips16_inst_fmts
{
  itype,			/* 0  immediate 5,10 */
  ritype,			/* 1   5,3,8 */
  rrtype,			/* 2   5,3,3,5 */
  rritype,			/* 3   5,3,3,5 */
  rrrtype,			/* 4   5,3,3,3,2 */
  rriatype,			/* 5   5,3,3,1,4 */
  shifttype,			/* 6   5,3,3,3,2 */
  i8type,			/* 7   5,3,8 */
  i8movtype,			/* 8   5,3,3,5 */
  i8mov32rtype,			/* 9   5,3,5,3 */
  i64type,			/* 10  5,3,8 */
  ri64type,			/* 11  5,3,3,5 */
  jalxtype,			/* 12  5,1,5,5,16 - a 32 bit instruction */
  exiItype,			/* 13  5,6,5,5,1,1,1,1,1,1,5 */
  extRitype,			/* 14  5,6,5,5,3,1,1,1,5 */
  extRRItype,			/* 15  5,5,5,5,3,3,5 */
  extRRIAtype,			/* 16  5,7,4,5,3,3,1,4 */
  EXTshifttype,			/* 17  5,5,1,1,1,1,1,1,5,3,3,1,1,1,2 */
  extI8type,			/* 18  5,6,5,5,3,1,1,1,5 */
  extI64type,			/* 19  5,6,5,5,3,1,1,1,5 */
  extRi64type,			/* 20  5,6,5,5,3,3,5 */
  extshift64type		/* 21  5,5,1,1,1,1,1,1,5,1,1,1,3,5 */
};
/* I am heaping all the fields of the formats into one structure and
   then, only the fields which are involved in instruction extension.  */
struct upk_mips16
{
  CORE_ADDR offset;
  unsigned int regx;		/* Function in i8 type.  */
  unsigned int regy;
};


/* The EXT-I, EXT-ri nad EXT-I8 instructions all have the same format
   for the bits which make up the immediate extension.  */

static CORE_ADDR
extended_offset (unsigned int extension)
{
  CORE_ADDR value;

  value = (extension >> 16) & 0x1f;	/* Extract 15:11.  */
  value = value << 6;
  value |= (extension >> 21) & 0x3f;	/* Extract 10:5.  */
  value = value << 5;
  value |= extension & 0x1f;		/* Extract 4:0.  */

  return value;
}

/* Only call this function if you know that this is an extendable
   instruction.  It won't malfunction, but why make excess remote memory
   references?  If the immediate operands get sign extended or something,
   do it after the extension is performed.  */
/* FIXME: Every one of these cases needs to worry about sign extension
   when the offset is to be used in relative addressing.  */

static unsigned int
fetch_mips_16 (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[8];

  pc = unmake_compact_addr (pc);	/* Clear the low order bit.  */
  target_read_memory (pc, buf, 2);
  return extract_unsigned_integer (buf, 2, byte_order);
}

static void
unpack_mips16 (struct gdbarch *gdbarch, CORE_ADDR pc,
	       unsigned int extension,
	       unsigned int inst,
	       enum mips16_inst_fmts insn_format, struct upk_mips16 *upk)
{
  CORE_ADDR offset;
  int regx;
  int regy;
  switch (insn_format)
    {
    case itype:
      {
	CORE_ADDR value;
	if (extension)
	  {
	    value = extended_offset ((extension << 16) | inst);
	    value = (value ^ 0x8000) - 0x8000;		/* Sign-extend.  */
	  }
	else
	  {
	    value = inst & 0x7ff;
	    value = (value ^ 0x400) - 0x400;		/* Sign-extend.  */
	  }
	offset = value;
	regx = -1;
	regy = -1;
      }
      break;
    case ritype:
    case i8type:
      {				/* A register identifier and an offset.  */
	/* Most of the fields are the same as I type but the
	   immediate value is of a different length.  */
	CORE_ADDR value;
	if (extension)
	  {
	    value = extended_offset ((extension << 16) | inst);
	    value = (value ^ 0x8000) - 0x8000;		/* Sign-extend.  */
	  }
	else
	  {
	    value = inst & 0xff;			/* 8 bits */
	    value = (value ^ 0x80) - 0x80;		/* Sign-extend.  */
	  }
	offset = value;
	regx = (inst >> 8) & 0x07;			/* i8 funct */
	regy = -1;
	break;
      }
    case jalxtype:
      {
	unsigned long value;
	unsigned int nexthalf;
	value = ((inst & 0x1f) << 5) | ((inst >> 5) & 0x1f);
	value = value << 16;
	nexthalf = mips_fetch_instruction (gdbarch, ISA_MIPS16, pc + 2, NULL);
						/* Low bit still set.  */
	value |= nexthalf;
	offset = value;
	regx = -1;
	regy = -1;
	break;
      }
    default:
      internal_error (__FILE__, __LINE__, _("bad switch"));
    }
  upk->offset = offset;
  upk->regx = regx;
  upk->regy = regy;
}


static CORE_ADDR
add_offset_16 (CORE_ADDR pc, int offset)
{
  return ((offset << 2) | ((pc + 2) & (~(CORE_ADDR) 0x0fffffff)));
}

static CORE_ADDR
extended_mips16_next_pc (struct frame_info *frame, CORE_ADDR pc,
			 unsigned int extension, unsigned int insn)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int op = (insn >> 11);
  switch (op)
    {
    case 2:			/* Branch */
      {
	struct upk_mips16 upk;
	unpack_mips16 (gdbarch, pc, extension, insn, itype, &upk);
	pc += (upk.offset << 1) + 2;
	break;
      }
    case 3:			/* JAL , JALX - Watch out, these are 32 bit
				   instructions.  */
      {
	struct upk_mips16 upk;
	unpack_mips16 (gdbarch, pc, extension, insn, jalxtype, &upk);
	pc = add_offset_16 (pc, upk.offset);
	if ((insn >> 10) & 0x01)	/* Exchange mode */
	  pc = pc & ~0x01;	/* Clear low bit, indicate 32 bit mode.  */
	else
	  pc |= 0x01;
	break;
      }
    case 4:			/* beqz */
      {
	struct upk_mips16 upk;
	int reg;
	unpack_mips16 (gdbarch, pc, extension, insn, ritype, &upk);
	reg = get_frame_register_signed (frame, mips_reg3_to_reg[upk.regx]);
	if (reg == 0)
	  pc += (upk.offset << 1) + 2;
	else
	  pc += 2;
	break;
      }
    case 5:			/* bnez */
      {
	struct upk_mips16 upk;
	int reg;
	unpack_mips16 (gdbarch, pc, extension, insn, ritype, &upk);
	reg = get_frame_register_signed (frame, mips_reg3_to_reg[upk.regx]);
	if (reg != 0)
	  pc += (upk.offset << 1) + 2;
	else
	  pc += 2;
	break;
      }
    case 12:			/* I8 Formats btez btnez */
      {
	struct upk_mips16 upk;
	int reg;
	unpack_mips16 (gdbarch, pc, extension, insn, i8type, &upk);
	/* upk.regx contains the opcode */
	reg = get_frame_register_signed (frame, 24);  /* Test register is 24 */
	if (((upk.regx == 0) && (reg == 0))	/* BTEZ */
	    || ((upk.regx == 1) && (reg != 0)))	/* BTNEZ */
	  /* pc = add_offset_16(pc,upk.offset) ; */
	  pc += (upk.offset << 1) + 2;
	else
	  pc += 2;
	break;
      }
    case 29:			/* RR Formats JR, JALR, JALR-RA */
      {
	struct upk_mips16 upk;
	/* upk.fmt = rrtype; */
	op = insn & 0x1f;
	if (op == 0)
	  {
	    int reg;
	    upk.regx = (insn >> 8) & 0x07;
	    upk.regy = (insn >> 5) & 0x07;
	    if ((upk.regy & 1) == 0)
	      reg = mips_reg3_to_reg[upk.regx];
	    else
	      reg = 31;		/* Function return instruction.  */
	    pc = get_frame_register_signed (frame, reg);
	  }
	else
	  pc += 2;
	break;
      }
    case 30:
      /* This is an instruction extension.  Fetch the real instruction
         (which follows the extension) and decode things based on
         that.  */
      {
	pc += 2;
	pc = extended_mips16_next_pc (frame, pc, insn,
				      fetch_mips_16 (gdbarch, pc));
	break;
      }
    default:
      {
	pc += 2;
	break;
      }
    }
  return pc;
}

static CORE_ADDR
mips16_next_pc (struct frame_info *frame, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  unsigned int insn = fetch_mips_16 (gdbarch, pc);
  return extended_mips16_next_pc (frame, pc, 0, insn);
}

/* The mips_next_pc function supports single_step when the remote
   target monitor or stub is not developed enough to do a single_step.
   It works by decoding the current instruction and predicting where a
   branch will go.  This isn't hard because all the data is available.
   The MIPS32, MIPS16 and microMIPS variants are quite different.  */
static CORE_ADDR
mips_next_pc (struct frame_info *frame, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);

  if (mips_pc_is_mips16 (gdbarch, pc))
    return mips16_next_pc (frame, pc);
  else if (mips_pc_is_micromips (gdbarch, pc))
    return micromips_next_pc (frame, pc);
  else
    return mips32_next_pc (frame, pc);
}

struct mips_frame_cache
{
  CORE_ADDR base;
  struct trad_frame_saved_reg *saved_regs;
};

/* Set a register's saved stack address in temp_saved_regs.  If an
   address has already been set for this register, do nothing; this
   way we will only recognize the first save of a given register in a
   function prologue.

   For simplicity, save the address in both [0 .. gdbarch_num_regs) and
   [gdbarch_num_regs .. 2*gdbarch_num_regs).
   Strictly speaking, only the second range is used as it is only second
   range (the ABI instead of ISA registers) that comes into play when finding
   saved registers in a frame.  */

static void
set_reg_offset (struct gdbarch *gdbarch, struct mips_frame_cache *this_cache,
		int regnum, CORE_ADDR offset)
{
  if (this_cache != NULL
      && this_cache->saved_regs[regnum].addr == -1)
    {
      this_cache->saved_regs[regnum + 0 * gdbarch_num_regs (gdbarch)].addr
        = offset;
      this_cache->saved_regs[regnum + 1 * gdbarch_num_regs (gdbarch)].addr
        = offset;
    }
}


/* Fetch the immediate value from a MIPS16 instruction.
   If the previous instruction was an EXTEND, use it to extend
   the upper bits of the immediate value.  This is a helper function
   for mips16_scan_prologue.  */

static int
mips16_get_imm (unsigned short prev_inst,	/* previous instruction */
		unsigned short inst,	/* current instruction */
		int nbits,	/* number of bits in imm field */
		int scale,	/* scale factor to be applied to imm */
		int is_signed)	/* is the imm field signed?  */
{
  int offset;

  if ((prev_inst & 0xf800) == 0xf000)	/* prev instruction was EXTEND? */
    {
      offset = ((prev_inst & 0x1f) << 11) | (prev_inst & 0x7e0);
      if (offset & 0x8000)	/* check for negative extend */
	offset = 0 - (0x10000 - (offset & 0xffff));
      return offset | (inst & 0x1f);
    }
  else
    {
      int max_imm = 1 << nbits;
      int mask = max_imm - 1;
      int sign_bit = max_imm >> 1;

      offset = inst & mask;
      if (is_signed && (offset & sign_bit))
	offset = 0 - (max_imm - offset);
      return offset * scale;
    }
}


/* Analyze the function prologue from START_PC to LIMIT_PC. Builds
   the associated FRAME_CACHE if not null.
   Return the address of the first instruction past the prologue.  */

static CORE_ADDR
mips16_scan_prologue (struct gdbarch *gdbarch,
		      CORE_ADDR start_pc, CORE_ADDR limit_pc,
                      struct frame_info *this_frame,
                      struct mips_frame_cache *this_cache)
{
  CORE_ADDR cur_pc;
  CORE_ADDR frame_addr = 0;	/* Value of $r17, used as frame pointer.  */
  CORE_ADDR sp;
  long frame_offset = 0;        /* Size of stack frame.  */
  long frame_adjust = 0;        /* Offset of FP from SP.  */
  int frame_reg = MIPS_SP_REGNUM;
  unsigned short prev_inst = 0;	/* saved copy of previous instruction.  */
  unsigned inst = 0;		/* current instruction */
  unsigned entry_inst = 0;	/* the entry instruction */
  unsigned save_inst = 0;	/* the save instruction */
  int reg, offset;

  int extend_bytes = 0;
  int prev_extend_bytes;
  CORE_ADDR end_prologue_addr = 0;

  /* Can be called when there's no process, and hence when there's no
     THIS_FRAME.  */
  if (this_frame != NULL)
    sp = get_frame_register_signed (this_frame,
				    gdbarch_num_regs (gdbarch)
				    + MIPS_SP_REGNUM);
  else
    sp = 0;

  if (limit_pc > start_pc + 200)
    limit_pc = start_pc + 200;

  for (cur_pc = start_pc; cur_pc < limit_pc; cur_pc += MIPS_INSN16_SIZE)
    {
      /* Save the previous instruction.  If it's an EXTEND, we'll extract
         the immediate offset extension from it in mips16_get_imm.  */
      prev_inst = inst;

      /* Fetch and decode the instruction.  */
      inst = (unsigned short) mips_fetch_instruction (gdbarch, ISA_MIPS16,
						      cur_pc, NULL);

      /* Normally we ignore extend instructions.  However, if it is
         not followed by a valid prologue instruction, then this
         instruction is not part of the prologue either.  We must
         remember in this case to adjust the end_prologue_addr back
         over the extend.  */
      if ((inst & 0xf800) == 0xf000)    /* extend */
        {
          extend_bytes = MIPS_INSN16_SIZE;
          continue;
        }

      prev_extend_bytes = extend_bytes;
      extend_bytes = 0;

      if ((inst & 0xff00) == 0x6300	/* addiu sp */
	  || (inst & 0xff00) == 0xfb00)	/* daddiu sp */
	{
	  offset = mips16_get_imm (prev_inst, inst, 8, 8, 1);
	  if (offset < 0)	/* Negative stack adjustment?  */
	    frame_offset -= offset;
	  else
	    /* Exit loop if a positive stack adjustment is found, which
	       usually means that the stack cleanup code in the function
	       epilogue is reached.  */
	    break;
	}
      else if ((inst & 0xf800) == 0xd000)	/* sw reg,n($sp) */
	{
	  offset = mips16_get_imm (prev_inst, inst, 8, 4, 0);
	  reg = mips_reg3_to_reg[(inst & 0x700) >> 8];
	  set_reg_offset (gdbarch, this_cache, reg, sp + offset);
	}
      else if ((inst & 0xff00) == 0xf900)	/* sd reg,n($sp) */
	{
	  offset = mips16_get_imm (prev_inst, inst, 5, 8, 0);
	  reg = mips_reg3_to_reg[(inst & 0xe0) >> 5];
	  set_reg_offset (gdbarch, this_cache, reg, sp + offset);
	}
      else if ((inst & 0xff00) == 0x6200)	/* sw $ra,n($sp) */
	{
	  offset = mips16_get_imm (prev_inst, inst, 8, 4, 0);
	  set_reg_offset (gdbarch, this_cache, MIPS_RA_REGNUM, sp + offset);
	}
      else if ((inst & 0xff00) == 0xfa00)	/* sd $ra,n($sp) */
	{
	  offset = mips16_get_imm (prev_inst, inst, 8, 8, 0);
	  set_reg_offset (gdbarch, this_cache, MIPS_RA_REGNUM, sp + offset);
	}
      else if (inst == 0x673d)	/* move $s1, $sp */
	{
	  frame_addr = sp;
	  frame_reg = 17;
	}
      else if ((inst & 0xff00) == 0x0100)	/* addiu $s1,sp,n */
	{
	  offset = mips16_get_imm (prev_inst, inst, 8, 4, 0);
	  frame_addr = sp + offset;
	  frame_reg = 17;
	  frame_adjust = offset;
	}
      else if ((inst & 0xFF00) == 0xd900)	/* sw reg,offset($s1) */
	{
	  offset = mips16_get_imm (prev_inst, inst, 5, 4, 0);
	  reg = mips_reg3_to_reg[(inst & 0xe0) >> 5];
	  set_reg_offset (gdbarch, this_cache, reg, frame_addr + offset);
	}
      else if ((inst & 0xFF00) == 0x7900)	/* sd reg,offset($s1) */
	{
	  offset = mips16_get_imm (prev_inst, inst, 5, 8, 0);
	  reg = mips_reg3_to_reg[(inst & 0xe0) >> 5];
	  set_reg_offset (gdbarch, this_cache, reg, frame_addr + offset);
	}
      else if ((inst & 0xf81f) == 0xe809
               && (inst & 0x700) != 0x700)	/* entry */
	entry_inst = inst;	/* Save for later processing.  */
      else if ((inst & 0xff80) == 0x6480)	/* save */
	{
	  save_inst = inst;	/* Save for later processing.  */
	  if (prev_extend_bytes)		/* extend */
	    save_inst |= prev_inst << 16;
	}
      else if ((inst & 0xf800) == 0x1800)	/* jal(x) */
	cur_pc += MIPS_INSN16_SIZE;	/* 32-bit instruction */
      else if ((inst & 0xff1c) == 0x6704)	/* move reg,$a0-$a3 */
        {
          /* This instruction is part of the prologue, but we don't
             need to do anything special to handle it.  */
        }
      else
        {
          /* This instruction is not an instruction typically found
             in a prologue, so we must have reached the end of the
             prologue.  */
          if (end_prologue_addr == 0)
            end_prologue_addr = cur_pc - prev_extend_bytes;
        }
    }

  /* The entry instruction is typically the first instruction in a function,
     and it stores registers at offsets relative to the value of the old SP
     (before the prologue).  But the value of the sp parameter to this
     function is the new SP (after the prologue has been executed).  So we
     can't calculate those offsets until we've seen the entire prologue,
     and can calculate what the old SP must have been.  */
  if (entry_inst != 0)
    {
      int areg_count = (entry_inst >> 8) & 7;
      int sreg_count = (entry_inst >> 6) & 3;

      /* The entry instruction always subtracts 32 from the SP.  */
      frame_offset += 32;

      /* Now we can calculate what the SP must have been at the
         start of the function prologue.  */
      sp += frame_offset;

      /* Check if a0-a3 were saved in the caller's argument save area.  */
      for (reg = 4, offset = 0; reg < areg_count + 4; reg++)
	{
	  set_reg_offset (gdbarch, this_cache, reg, sp + offset);
	  offset += mips_abi_regsize (gdbarch);
	}

      /* Check if the ra register was pushed on the stack.  */
      offset = -4;
      if (entry_inst & 0x20)
	{
	  set_reg_offset (gdbarch, this_cache, MIPS_RA_REGNUM, sp + offset);
	  offset -= mips_abi_regsize (gdbarch);
	}

      /* Check if the s0 and s1 registers were pushed on the stack.  */
      for (reg = 16; reg < sreg_count + 16; reg++)
	{
	  set_reg_offset (gdbarch, this_cache, reg, sp + offset);
	  offset -= mips_abi_regsize (gdbarch);
	}
    }

  /* The SAVE instruction is similar to ENTRY, except that defined by the
     MIPS16e ASE of the MIPS Architecture.  Unlike with ENTRY though, the
     size of the frame is specified as an immediate field of instruction
     and an extended variation exists which lets additional registers and
     frame space to be specified.  The instruction always treats registers
     as 32-bit so its usefulness for 64-bit ABIs is questionable.  */
  if (save_inst != 0 && mips_abi_regsize (gdbarch) == 4)
    {
      static int args_table[16] = {
	0, 0, 0, 0, 1, 1, 1, 1,
	2, 2, 2, 0, 3, 3, 4, -1,
      };
      static int astatic_table[16] = {
	0, 1, 2, 3, 0, 1, 2, 3,
	0, 1, 2, 4, 0, 1, 0, -1,
      };
      int aregs = (save_inst >> 16) & 0xf;
      int xsregs = (save_inst >> 24) & 0x7;
      int args = args_table[aregs];
      int astatic = astatic_table[aregs];
      long frame_size;

      if (args < 0)
	{
	  warning (_("Invalid number of argument registers encoded in SAVE."));
	  args = 0;
	}
      if (astatic < 0)
	{
	  warning (_("Invalid number of static registers encoded in SAVE."));
	  astatic = 0;
	}

      /* For standard SAVE the frame size of 0 means 128.  */
      frame_size = ((save_inst >> 16) & 0xf0) | (save_inst & 0xf);
      if (frame_size == 0 && (save_inst >> 16) == 0)
	frame_size = 16;
      frame_size *= 8;
      frame_offset += frame_size;

      /* Now we can calculate what the SP must have been at the
         start of the function prologue.  */
      sp += frame_offset;

      /* Check if A0-A3 were saved in the caller's argument save area.  */
      for (reg = MIPS_A0_REGNUM, offset = 0; reg < args + 4; reg++)
	{
	  set_reg_offset (gdbarch, this_cache, reg, sp + offset);
	  offset += mips_abi_regsize (gdbarch);
	}

      offset = -4;

      /* Check if the RA register was pushed on the stack.  */
      if (save_inst & 0x40)
	{
	  set_reg_offset (gdbarch, this_cache, MIPS_RA_REGNUM, sp + offset);
	  offset -= mips_abi_regsize (gdbarch);
	}

      /* Check if the S8 register was pushed on the stack.  */
      if (xsregs > 6)
	{
	  set_reg_offset (gdbarch, this_cache, 30, sp + offset);
	  offset -= mips_abi_regsize (gdbarch);
	  xsregs--;
	}
      /* Check if S2-S7 were pushed on the stack.  */
      for (reg = 18 + xsregs - 1; reg > 18 - 1; reg--)
	{
	  set_reg_offset (gdbarch, this_cache, reg, sp + offset);
	  offset -= mips_abi_regsize (gdbarch);
	}

      /* Check if the S1 register was pushed on the stack.  */
      if (save_inst & 0x10)
	{
	  set_reg_offset (gdbarch, this_cache, 17, sp + offset);
	  offset -= mips_abi_regsize (gdbarch);
	}
      /* Check if the S0 register was pushed on the stack.  */
      if (save_inst & 0x20)
	{
	  set_reg_offset (gdbarch, this_cache, 16, sp + offset);
	  offset -= mips_abi_regsize (gdbarch);
	}

      /* Check if A0-A3 were pushed on the stack.  */
      for (reg = MIPS_A0_REGNUM + 3; reg > MIPS_A0_REGNUM + 3 - astatic; reg--)
	{
	  set_reg_offset (gdbarch, this_cache, reg, sp + offset);
	  offset -= mips_abi_regsize (gdbarch);
	}
    }

  if (this_cache != NULL)
    {
      this_cache->base =
        (get_frame_register_signed (this_frame,
				    gdbarch_num_regs (gdbarch) + frame_reg)
         + frame_offset - frame_adjust);
      /* FIXME: brobecker/2004-10-10: Just as in the mips32 case, we should
         be able to get rid of the assignment below, evetually.  But it's
         still needed for now.  */
      this_cache->saved_regs[gdbarch_num_regs (gdbarch)
			     + mips_regnum (gdbarch)->pc]
        = this_cache->saved_regs[gdbarch_num_regs (gdbarch) + MIPS_RA_REGNUM];
    }

  /* If we didn't reach the end of the prologue when scanning the function
     instructions, then set end_prologue_addr to the address of the
     instruction immediately after the last one we scanned.  */
  if (end_prologue_addr == 0)
    end_prologue_addr = cur_pc;

  return end_prologue_addr;
}

/* Heuristic unwinder for 16-bit MIPS instruction set (aka MIPS16).
   Procedures that use the 32-bit instruction set are handled by the
   mips_insn32 unwinder.  */

static struct mips_frame_cache *
mips_insn16_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct mips_frame_cache *cache;

  if ((*this_cache) != NULL)
    return (*this_cache);
  cache = FRAME_OBSTACK_ZALLOC (struct mips_frame_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  /* Analyze the function prologue.  */
  {
    const CORE_ADDR pc = get_frame_address_in_block (this_frame);
    CORE_ADDR start_addr;

    find_pc_partial_function (pc, NULL, &start_addr, NULL);
    if (start_addr == 0)
      start_addr = heuristic_proc_start (gdbarch, pc);
    /* We can't analyze the prologue if we couldn't find the begining
       of the function.  */
    if (start_addr == 0)
      return cache;

    mips16_scan_prologue (gdbarch, start_addr, pc, this_frame, *this_cache);
  }
  
  /* gdbarch_sp_regnum contains the value and not the address.  */
  trad_frame_set_value (cache->saved_regs,
			gdbarch_num_regs (gdbarch) + MIPS_SP_REGNUM,
			cache->base);

  return (*this_cache);
}

static void
mips_insn16_frame_this_id (struct frame_info *this_frame, void **this_cache,
			   struct frame_id *this_id)
{
  struct mips_frame_cache *info = mips_insn16_frame_cache (this_frame,
							   this_cache);
  /* This marks the outermost frame.  */
  if (info->base == 0)
    return;
  (*this_id) = frame_id_build (info->base, get_frame_func (this_frame));
}

static struct value *
mips_insn16_frame_prev_register (struct frame_info *this_frame,
				 void **this_cache, int regnum)
{
  struct mips_frame_cache *info = mips_insn16_frame_cache (this_frame,
							   this_cache);
  return trad_frame_get_prev_register (this_frame, info->saved_regs, regnum);
}

static int
mips_insn16_frame_sniffer (const struct frame_unwind *self,
			   struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  CORE_ADDR pc = get_frame_pc (this_frame);
  if (mips_pc_is_mips16 (gdbarch, pc))
    return 1;
  return 0;
}

static const struct frame_unwind mips_insn16_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  mips_insn16_frame_this_id,
  mips_insn16_frame_prev_register,
  NULL,
  mips_insn16_frame_sniffer
};

static CORE_ADDR
mips_insn16_frame_base_address (struct frame_info *this_frame,
				void **this_cache)
{
  struct mips_frame_cache *info = mips_insn16_frame_cache (this_frame,
							   this_cache);
  return info->base;
}

static const struct frame_base mips_insn16_frame_base =
{
  &mips_insn16_frame_unwind,
  mips_insn16_frame_base_address,
  mips_insn16_frame_base_address,
  mips_insn16_frame_base_address
};

static const struct frame_base *
mips_insn16_frame_base_sniffer (struct frame_info *this_frame)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  CORE_ADDR pc = get_frame_pc (this_frame);
  if (mips_pc_is_mips16 (gdbarch, pc))
    return &mips_insn16_frame_base;
  else
    return NULL;
}

/* Decode a 9-bit signed immediate argument of ADDIUSP -- -2 is mapped
   to -258, -1 -- to -257, 0 -- to 256, 1 -- to 257 and other values are
   interpreted directly, and then multiplied by 4.  */

static int
micromips_decode_imm9 (int imm)
{
  imm = (imm ^ 0x100) - 0x100;
  if (imm > -3 && imm < 2)
    imm ^= 0x100;
  return imm << 2;
}

/* Analyze the function prologue from START_PC to LIMIT_PC.  Return
   the address of the first instruction past the prologue.  */

static CORE_ADDR
micromips_scan_prologue (struct gdbarch *gdbarch,
			 CORE_ADDR start_pc, CORE_ADDR limit_pc,
			 struct frame_info *this_frame,
			 struct mips_frame_cache *this_cache)
{
  CORE_ADDR end_prologue_addr = 0;
  int prev_non_prologue_insn = 0;
  int frame_reg = MIPS_SP_REGNUM;
  int this_non_prologue_insn;
  int non_prologue_insns = 0;
  long frame_offset = 0;	/* Size of stack frame.  */
  long frame_adjust = 0;	/* Offset of FP from SP.  */
  CORE_ADDR frame_addr = 0;	/* Value of $30, used as frame pointer.  */
  CORE_ADDR prev_pc;
  CORE_ADDR cur_pc;
  ULONGEST insn;		/* current instruction */
  CORE_ADDR sp;
  long offset;
  long sp_adj;
  long v1_off = 0;		/* The assumption is LUI will replace it.  */
  int reglist;
  int breg;
  int dreg;
  int sreg;
  int treg;
  int loc;
  int op;
  int s;
  int i;

  /* Can be called when there's no process, and hence when there's no
     THIS_FRAME.  */
  if (this_frame != NULL)
    sp = get_frame_register_signed (this_frame,
				    gdbarch_num_regs (gdbarch)
				    + MIPS_SP_REGNUM);
  else
    sp = 0;

  if (limit_pc > start_pc + 200)
    limit_pc = start_pc + 200;
  prev_pc = start_pc;

  /* Permit at most one non-prologue non-control-transfer instruction
     in the middle which may have been reordered by the compiler for
     optimisation.  */
  for (cur_pc = start_pc; cur_pc < limit_pc; cur_pc += loc)
    {
      this_non_prologue_insn = 0;
      sp_adj = 0;
      loc = 0;
      insn = mips_fetch_instruction (gdbarch, ISA_MICROMIPS, cur_pc, NULL);
      loc += MIPS_INSN16_SIZE;
      switch (mips_insn_size (ISA_MICROMIPS, insn))
	{
	/* 48-bit instructions.  */
	case 3 * MIPS_INSN16_SIZE:
	  /* No prologue instructions in this category.  */
	  this_non_prologue_insn = 1;
	  loc += 2 * MIPS_INSN16_SIZE;
	  break;

	/* 32-bit instructions.  */
	case 2 * MIPS_INSN16_SIZE:
	  insn <<= 16;
	  insn |= mips_fetch_instruction (gdbarch,
					  ISA_MICROMIPS, cur_pc + loc, NULL);
	  loc += MIPS_INSN16_SIZE;
	  switch (micromips_op (insn >> 16))
	    {
	    /* Record $sp/$fp adjustment.  */
	    /* Discard (D)ADDU $gp,$jp used for PIC code.  */
	    case 0x0: /* POOL32A: bits 000000 */
	    case 0x16: /* POOL32S: bits 010110 */
	      op = b0s11_op (insn);
	      sreg = b0s5_reg (insn >> 16);
	      treg = b5s5_reg (insn >> 16);
	      dreg = b11s5_reg (insn);
	      if (op == 0x1d0
				/* SUBU: bits 000000 00111010000 */
				/* DSUBU: bits 010110 00111010000 */
		  && dreg == MIPS_SP_REGNUM && sreg == MIPS_SP_REGNUM
		  && treg == 3)
				/* (D)SUBU $sp, $v1 */
		    sp_adj = v1_off;
	      else if (op != 0x150
				/* ADDU: bits 000000 00101010000 */
				/* DADDU: bits 010110 00101010000 */
		       || dreg != 28 || sreg != 28 || treg != MIPS_T9_REGNUM)
		this_non_prologue_insn = 1;
	      break;

	    case 0x8: /* POOL32B: bits 001000 */
	      op = b12s4_op (insn);
	      breg = b0s5_reg (insn >> 16);
	      reglist = sreg = b5s5_reg (insn >> 16);
	      offset = (b0s12_imm (insn) ^ 0x800) - 0x800;
	      if ((op == 0x9 || op == 0xc)
				/* SWP: bits 001000 1001 */
				/* SDP: bits 001000 1100 */
		  && breg == MIPS_SP_REGNUM && sreg < MIPS_RA_REGNUM)
				/* S[DW]P reg,offset($sp) */
		{
		  s = 4 << ((b12s4_op (insn) & 0x4) == 0x4);
		  set_reg_offset (gdbarch, this_cache,
				  sreg, sp + offset);
		  set_reg_offset (gdbarch, this_cache,
				  sreg + 1, sp + offset + s);
		}
	      else if ((op == 0xd || op == 0xf)
				/* SWM: bits 001000 1101 */
				/* SDM: bits 001000 1111 */
		       && breg == MIPS_SP_REGNUM
				/* SWM reglist,offset($sp) */
		       && ((reglist >= 1 && reglist <= 9)
			   || (reglist >= 16 && reglist <= 25)))
		{
		  int sreglist = min(reglist & 0xf, 8);

		  s = 4 << ((b12s4_op (insn) & 0x2) == 0x2);
		  for (i = 0; i < sreglist; i++)
		    set_reg_offset (gdbarch, this_cache, 16 + i, sp + s * i);
		  if ((reglist & 0xf) > 8)
		    set_reg_offset (gdbarch, this_cache, 30, sp + s * i++);
		  if ((reglist & 0x10) == 0x10)
		    set_reg_offset (gdbarch, this_cache,
				    MIPS_RA_REGNUM, sp + s * i++);
		}
	      else
		this_non_prologue_insn = 1;
	      break;

	    /* Record $sp/$fp adjustment.  */
	    /* Discard (D)ADDIU $gp used for PIC code.  */
	    case 0xc: /* ADDIU: bits 001100 */
	    case 0x17: /* DADDIU: bits 010111 */
	      sreg = b0s5_reg (insn >> 16);
	      dreg = b5s5_reg (insn >> 16);
	      offset = (b0s16_imm (insn) ^ 0x8000) - 0x8000;
	      if (sreg == MIPS_SP_REGNUM && dreg == MIPS_SP_REGNUM)
				/* (D)ADDIU $sp, imm */
		sp_adj = offset;
	      else if (sreg == MIPS_SP_REGNUM && dreg == 30)
				/* (D)ADDIU $fp, $sp, imm */
		{
		  frame_addr = sp + offset;
		  frame_adjust = offset;
		  frame_reg = 30;
		}
	      else if (sreg != 28 || dreg != 28)
				/* (D)ADDIU $gp, imm */
		this_non_prologue_insn = 1;
	      break;

	    /* LUI $v1 is used for larger $sp adjustments.  */
	    /* Discard LUI $gp used for PIC code.  */
	    case 0x10: /* POOL32I: bits 010000 */
	      if (b5s5_op (insn >> 16) == 0xd
				/* LUI: bits 010000 001101 */
		  && b0s5_reg (insn >> 16) == 3)
				/* LUI $v1, imm */
		v1_off = ((b0s16_imm (insn) << 16) ^ 0x80000000) - 0x80000000;
	      else if (b5s5_op (insn >> 16) != 0xd
				/* LUI: bits 010000 001101 */
		       || b0s5_reg (insn >> 16) != 28)
				/* LUI $gp, imm */
		this_non_prologue_insn = 1;
	      break;

	    /* ORI $v1 is used for larger $sp adjustments.  */
	    case 0x14: /* ORI: bits 010100 */
	      sreg = b0s5_reg (insn >> 16);
	      dreg = b5s5_reg (insn >> 16);
	      if (sreg == 3 && dreg == 3)
				/* ORI $v1, imm */
		v1_off |= b0s16_imm (insn);
	      else
		this_non_prologue_insn = 1;
	      break;

	    case 0x26: /* SWC1: bits 100110 */
	    case 0x2e: /* SDC1: bits 101110 */
	      breg = b0s5_reg (insn >> 16);
	      if (breg != MIPS_SP_REGNUM)
				/* S[DW]C1 reg,offset($sp) */
		this_non_prologue_insn = 1;
	      break;

	    case 0x36: /* SD: bits 110110 */
	    case 0x3e: /* SW: bits 111110 */
	      breg = b0s5_reg (insn >> 16);
	      sreg = b5s5_reg (insn >> 16);
	      offset = (b0s16_imm (insn) ^ 0x8000) - 0x8000;
	      if (breg == MIPS_SP_REGNUM)
				/* S[DW] reg,offset($sp) */
		set_reg_offset (gdbarch, this_cache, sreg, sp + offset);
	      else
		this_non_prologue_insn = 1;
	      break;

	    default:
	      this_non_prologue_insn = 1;
	      break;
	    }
	  break;

	/* 16-bit instructions.  */
	case MIPS_INSN16_SIZE:
	  switch (micromips_op (insn))
	    {
	    case 0x3: /* MOVE: bits 000011 */
	      sreg = b0s5_reg (insn);
	      dreg = b5s5_reg (insn);
	      if (sreg == MIPS_SP_REGNUM && dreg == 30)
				/* MOVE  $fp, $sp */
		{
		  frame_addr = sp;
		  frame_reg = 30;
		}
	      else if ((sreg & 0x1c) != 0x4)
				/* MOVE  reg, $a0-$a3 */
		this_non_prologue_insn = 1;
	      break;

	    case 0x11: /* POOL16C: bits 010001 */
	      if (b6s4_op (insn) == 0x5)
				/* SWM: bits 010001 0101 */
		{
		  offset = ((b0s4_imm (insn) << 2) ^ 0x20) - 0x20;
		  reglist = b4s2_regl (insn);
		  for (i = 0; i <= reglist; i++)
		    set_reg_offset (gdbarch, this_cache, 16 + i, sp + 4 * i);
		  set_reg_offset (gdbarch, this_cache,
				  MIPS_RA_REGNUM, sp + 4 * i++);
		}
	      else
		this_non_prologue_insn = 1;
	      break;

	    case 0x13: /* POOL16D: bits 010011 */
	      if ((insn & 0x1) == 0x1)
				/* ADDIUSP: bits 010011 1 */
		sp_adj = micromips_decode_imm9 (b1s9_imm (insn));
	      else if (b5s5_reg (insn) == MIPS_SP_REGNUM)
				/* ADDIUS5: bits 010011 0 */
				/* ADDIUS5 $sp, imm */
		sp_adj = (b1s4_imm (insn) ^ 8) - 8;
	      else
		this_non_prologue_insn = 1;
	      break;

	    case 0x32: /* SWSP: bits 110010 */
	      offset = b0s5_imm (insn) << 2;
	      sreg = b5s5_reg (insn);
	      set_reg_offset (gdbarch, this_cache, sreg, sp + offset);
	      break;

	    default:
	      this_non_prologue_insn = 1;
	      break;
	    }
	  break;
	}
      if (sp_adj < 0)
	frame_offset -= sp_adj;

      non_prologue_insns += this_non_prologue_insn;
      /* Enough non-prologue insns seen or positive stack adjustment? */
      if (end_prologue_addr == 0 && (non_prologue_insns > 1 || sp_adj > 0))
	{
	  end_prologue_addr = prev_non_prologue_insn ? prev_pc : cur_pc;
	  break;
	}
      prev_non_prologue_insn = this_non_prologue_insn;
      prev_pc = cur_pc;
    }

  if (this_cache != NULL)
    {
      this_cache->base =
	(get_frame_register_signed (this_frame,
				    gdbarch_num_regs (gdbarch) + frame_reg)
	 + frame_offset - frame_adjust);
      /* FIXME: brobecker/2004-10-10: Just as in the mips32 case, we should
	 be able to get rid of the assignment below, evetually. But it's
	 still needed for now.  */
      this_cache->saved_regs[gdbarch_num_regs (gdbarch)
			     + mips_regnum (gdbarch)->pc]
	= this_cache->saved_regs[gdbarch_num_regs (gdbarch) + MIPS_RA_REGNUM];
    }

  /* If we didn't reach the end of the prologue when scanning the function
     instructions, then set end_prologue_addr to the address of the
     instruction immediately after the last one we scanned.  Unless the
     last one looked like a non-prologue instruction (and we looked ahead),
     in which case use its address instead.  */
  if (end_prologue_addr == 0)
    end_prologue_addr = prev_non_prologue_insn ? prev_pc : cur_pc;

  return end_prologue_addr;
}

/* Heuristic unwinder for procedures using microMIPS instructions.
   Procedures that use the 32-bit instruction set are handled by the
   mips_insn32 unwinder.  Likewise MIPS16 and the mips_insn16 unwinder. */

static struct mips_frame_cache *
mips_micro_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct mips_frame_cache *cache;

  if ((*this_cache) != NULL)
    return (*this_cache);

  cache = FRAME_OBSTACK_ZALLOC (struct mips_frame_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  /* Analyze the function prologue.  */
  {
    const CORE_ADDR pc = get_frame_address_in_block (this_frame);
    CORE_ADDR start_addr;

    find_pc_partial_function (pc, NULL, &start_addr, NULL);
    if (start_addr == 0)
      start_addr = heuristic_proc_start (get_frame_arch (this_frame), pc);
    /* We can't analyze the prologue if we couldn't find the begining
       of the function.  */
    if (start_addr == 0)
      return cache;

    micromips_scan_prologue (gdbarch, start_addr, pc, this_frame, *this_cache);
  }

  /* gdbarch_sp_regnum contains the value and not the address.  */
  trad_frame_set_value (cache->saved_regs,
			gdbarch_num_regs (gdbarch) + MIPS_SP_REGNUM,
			cache->base);

  return (*this_cache);
}

static void
mips_micro_frame_this_id (struct frame_info *this_frame, void **this_cache,
			  struct frame_id *this_id)
{
  struct mips_frame_cache *info = mips_micro_frame_cache (this_frame,
							  this_cache);
  /* This marks the outermost frame.  */
  if (info->base == 0)
    return;
  (*this_id) = frame_id_build (info->base, get_frame_func (this_frame));
}

static struct value *
mips_micro_frame_prev_register (struct frame_info *this_frame,
				void **this_cache, int regnum)
{
  struct mips_frame_cache *info = mips_micro_frame_cache (this_frame,
							  this_cache);
  return trad_frame_get_prev_register (this_frame, info->saved_regs, regnum);
}

static int
mips_micro_frame_sniffer (const struct frame_unwind *self,
			  struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  CORE_ADDR pc = get_frame_pc (this_frame);

  if (mips_pc_is_micromips (gdbarch, pc))
    return 1;
  return 0;
}

static const struct frame_unwind mips_micro_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  mips_micro_frame_this_id,
  mips_micro_frame_prev_register,
  NULL,
  mips_micro_frame_sniffer
};

static CORE_ADDR
mips_micro_frame_base_address (struct frame_info *this_frame,
			       void **this_cache)
{
  struct mips_frame_cache *info = mips_micro_frame_cache (this_frame,
							  this_cache);
  return info->base;
}

static const struct frame_base mips_micro_frame_base =
{
  &mips_micro_frame_unwind,
  mips_micro_frame_base_address,
  mips_micro_frame_base_address,
  mips_micro_frame_base_address
};

static const struct frame_base *
mips_micro_frame_base_sniffer (struct frame_info *this_frame)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  CORE_ADDR pc = get_frame_pc (this_frame);

  if (mips_pc_is_micromips (gdbarch, pc))
    return &mips_micro_frame_base;
  else
    return NULL;
}

/* Mark all the registers as unset in the saved_regs array
   of THIS_CACHE.  Do nothing if THIS_CACHE is null.  */

static void
reset_saved_regs (struct gdbarch *gdbarch, struct mips_frame_cache *this_cache)
{
  if (this_cache == NULL || this_cache->saved_regs == NULL)
    return;

  {
    const int num_regs = gdbarch_num_regs (gdbarch);
    int i;

    for (i = 0; i < num_regs; i++)
      {
        this_cache->saved_regs[i].addr = -1;
      }
  }
}

/* Analyze the function prologue from START_PC to LIMIT_PC.  Builds
   the associated FRAME_CACHE if not null.  
   Return the address of the first instruction past the prologue.  */

static CORE_ADDR
mips32_scan_prologue (struct gdbarch *gdbarch,
		      CORE_ADDR start_pc, CORE_ADDR limit_pc,
                      struct frame_info *this_frame,
                      struct mips_frame_cache *this_cache)
{
  CORE_ADDR cur_pc;
  CORE_ADDR frame_addr = 0; /* Value of $r30. Used by gcc for
			       frame-pointer.  */
  CORE_ADDR sp;
  long frame_offset;
  int  frame_reg = MIPS_SP_REGNUM;

  CORE_ADDR end_prologue_addr = 0;
  int seen_sp_adjust = 0;
  int load_immediate_bytes = 0;
  int in_delay_slot = 0;
  int regsize_is_64_bits = (mips_abi_regsize (gdbarch) == 8);

  /* Can be called when there's no process, and hence when there's no
     THIS_FRAME.  */
  if (this_frame != NULL)
    sp = get_frame_register_signed (this_frame,
				    gdbarch_num_regs (gdbarch)
				    + MIPS_SP_REGNUM);
  else
    sp = 0;

  if (limit_pc > start_pc + 200)
    limit_pc = start_pc + 200;

restart:

  frame_offset = 0;
  for (cur_pc = start_pc; cur_pc < limit_pc; cur_pc += MIPS_INSN32_SIZE)
    {
      unsigned long inst, high_word, low_word;
      int reg;

      /* Fetch the instruction.  */
      inst = (unsigned long) mips_fetch_instruction (gdbarch, ISA_MIPS,
						     cur_pc, NULL);

      /* Save some code by pre-extracting some useful fields.  */
      high_word = (inst >> 16) & 0xffff;
      low_word = inst & 0xffff;
      reg = high_word & 0x1f;

      if (high_word == 0x27bd		/* addiu $sp,$sp,-i */
	  || high_word == 0x23bd	/* addi $sp,$sp,-i */
	  || high_word == 0x67bd)	/* daddiu $sp,$sp,-i */
	{
	  if (low_word & 0x8000)	/* Negative stack adjustment?  */
            frame_offset += 0x10000 - low_word;
	  else
	    /* Exit loop if a positive stack adjustment is found, which
	       usually means that the stack cleanup code in the function
	       epilogue is reached.  */
	    break;
          seen_sp_adjust = 1;
	}
      else if (((high_word & 0xFFE0) == 0xafa0) /* sw reg,offset($sp) */
               && !regsize_is_64_bits)
	{
	  set_reg_offset (gdbarch, this_cache, reg, sp + low_word);
	}
      else if (((high_word & 0xFFE0) == 0xffa0)	/* sd reg,offset($sp) */
               && regsize_is_64_bits)
	{
	  /* Irix 6.2 N32 ABI uses sd instructions for saving $gp and $ra.  */
	  set_reg_offset (gdbarch, this_cache, reg, sp + low_word);
	}
      else if (high_word == 0x27be)	/* addiu $30,$sp,size */
	{
	  /* Old gcc frame, r30 is virtual frame pointer.  */
	  if ((long) low_word != frame_offset)
	    frame_addr = sp + low_word;
	  else if (this_frame && frame_reg == MIPS_SP_REGNUM)
	    {
	      unsigned alloca_adjust;

	      frame_reg = 30;
	      frame_addr = get_frame_register_signed
		(this_frame, gdbarch_num_regs (gdbarch) + 30);
	      frame_offset = 0;

	      alloca_adjust = (unsigned) (frame_addr - (sp + low_word));
	      if (alloca_adjust > 0)
		{
                  /* FP > SP + frame_size.  This may be because of
                     an alloca or somethings similar.  Fix sp to
                     "pre-alloca" value, and try again.  */
		  sp += alloca_adjust;
                  /* Need to reset the status of all registers.  Otherwise,
                     we will hit a guard that prevents the new address
                     for each register to be recomputed during the second
                     pass.  */
                  reset_saved_regs (gdbarch, this_cache);
		  goto restart;
		}
	    }
	}
      /* move $30,$sp.  With different versions of gas this will be either
         `addu $30,$sp,$zero' or `or $30,$sp,$zero' or `daddu 30,sp,$0'.
         Accept any one of these.  */
      else if (inst == 0x03A0F021 || inst == 0x03a0f025 || inst == 0x03a0f02d)
	{
	  /* New gcc frame, virtual frame pointer is at r30 + frame_size.  */
	  if (this_frame && frame_reg == MIPS_SP_REGNUM)
	    {
	      unsigned alloca_adjust;

	      frame_reg = 30;
	      frame_addr = get_frame_register_signed
		(this_frame, gdbarch_num_regs (gdbarch) + 30);

	      alloca_adjust = (unsigned) (frame_addr - sp);
	      if (alloca_adjust > 0)
	        {
                  /* FP > SP + frame_size.  This may be because of
                     an alloca or somethings similar.  Fix sp to
                     "pre-alloca" value, and try again.  */
	          sp = frame_addr;
                  /* Need to reset the status of all registers.  Otherwise,
                     we will hit a guard that prevents the new address
                     for each register to be recomputed during the second
                     pass.  */
                  reset_saved_regs (gdbarch, this_cache);
	          goto restart;
	        }
	    }
	}
      else if ((high_word & 0xFFE0) == 0xafc0 	/* sw reg,offset($30) */
               && !regsize_is_64_bits)
	{
	  set_reg_offset (gdbarch, this_cache, reg, frame_addr + low_word);
	}
      else if ((high_word & 0xFFE0) == 0xE7A0 /* swc1 freg,n($sp) */
               || (high_word & 0xF3E0) == 0xA3C0 /* sx reg,n($s8) */
               || (inst & 0xFF9F07FF) == 0x00800021 /* move reg,$a0-$a3 */
               || high_word == 0x3c1c /* lui $gp,n */
               || high_word == 0x279c /* addiu $gp,$gp,n */
               || inst == 0x0399e021 /* addu $gp,$gp,$t9 */
               || inst == 0x033ce021 /* addu $gp,$t9,$gp */
              )
	{
	  /* These instructions are part of the prologue, but we don't
	     need to do anything special to handle them.  */
	}
      /* The instructions below load $at or $t0 with an immediate
         value in preparation for a stack adjustment via
         subu $sp,$sp,[$at,$t0].  These instructions could also
         initialize a local variable, so we accept them only before
         a stack adjustment instruction was seen.  */
      else if (!seen_sp_adjust
	       && (high_word == 0x3c01 /* lui $at,n */
		   || high_word == 0x3c08 /* lui $t0,n */
		   || high_word == 0x3421 /* ori $at,$at,n */
		   || high_word == 0x3508 /* ori $t0,$t0,n */
		   || high_word == 0x3401 /* ori $at,$zero,n */
		   || high_word == 0x3408 /* ori $t0,$zero,n */
		  ))
	{
	  if (end_prologue_addr == 0)
	    load_immediate_bytes += MIPS_INSN32_SIZE;		/* FIXME!  */
	}
      else
	{
	  /* This instruction is not an instruction typically found
	     in a prologue, so we must have reached the end of the
	     prologue.  */
	  /* FIXME: brobecker/2004-10-10: Can't we just break out of this
	     loop now?  Why would we need to continue scanning the function
	     instructions?  */
	  if (end_prologue_addr == 0)
	    end_prologue_addr = cur_pc;

	  /* Check for branches and jumps.  For now, only jump to
	     register are caught (i.e. returns).  */
	  if ((itype_op (inst) & 0x07) == 0 && rtype_funct (inst) == 8)
	    in_delay_slot = 1;
	}

      /* If the previous instruction was a jump, we must have reached
	 the end of the prologue by now.  Stop scanning so that we do
	 not go past the function return.  */
      if (in_delay_slot)
	break;
    }

  if (this_cache != NULL)
    {
      this_cache->base = 
        (get_frame_register_signed (this_frame,
				    gdbarch_num_regs (gdbarch) + frame_reg)
         + frame_offset);
      /* FIXME: brobecker/2004-09-15: We should be able to get rid of
         this assignment below, eventually.  But it's still needed
         for now.  */
      this_cache->saved_regs[gdbarch_num_regs (gdbarch)
			     + mips_regnum (gdbarch)->pc]
        = this_cache->saved_regs[gdbarch_num_regs (gdbarch)
				 + MIPS_RA_REGNUM];
    }

  /* If we didn't reach the end of the prologue when scanning the function
     instructions, then set end_prologue_addr to the address of the
     instruction immediately after the last one we scanned.  */
  /* brobecker/2004-10-10: I don't think this would ever happen, but
     we may as well be careful and do our best if we have a null
     end_prologue_addr.  */
  if (end_prologue_addr == 0)
    end_prologue_addr = cur_pc;
     
  /* In a frameless function, we might have incorrectly
     skipped some load immediate instructions.  Undo the skipping
     if the load immediate was not followed by a stack adjustment.  */
  if (load_immediate_bytes && !seen_sp_adjust)
    end_prologue_addr -= load_immediate_bytes;

  return end_prologue_addr;
}

/* Heuristic unwinder for procedures using 32-bit instructions (covers
   both 32-bit and 64-bit MIPS ISAs).  Procedures using 16-bit
   instructions (a.k.a. MIPS16) are handled by the mips_insn16
   unwinder.  Likewise microMIPS and the mips_micro unwinder. */

static struct mips_frame_cache *
mips_insn32_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct mips_frame_cache *cache;

  if ((*this_cache) != NULL)
    return (*this_cache);

  cache = FRAME_OBSTACK_ZALLOC (struct mips_frame_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  /* Analyze the function prologue.  */
  {
    const CORE_ADDR pc = get_frame_address_in_block (this_frame);
    CORE_ADDR start_addr;

    find_pc_partial_function (pc, NULL, &start_addr, NULL);
    if (start_addr == 0)
      start_addr = heuristic_proc_start (gdbarch, pc);
    /* We can't analyze the prologue if we couldn't find the begining
       of the function.  */
    if (start_addr == 0)
      return cache;

    mips32_scan_prologue (gdbarch, start_addr, pc, this_frame, *this_cache);
  }
  
  /* gdbarch_sp_regnum contains the value and not the address.  */
  trad_frame_set_value (cache->saved_regs,
			gdbarch_num_regs (gdbarch) + MIPS_SP_REGNUM,
			cache->base);

  return (*this_cache);
}

static void
mips_insn32_frame_this_id (struct frame_info *this_frame, void **this_cache,
			   struct frame_id *this_id)
{
  struct mips_frame_cache *info = mips_insn32_frame_cache (this_frame,
							   this_cache);
  /* This marks the outermost frame.  */
  if (info->base == 0)
    return;
  (*this_id) = frame_id_build (info->base, get_frame_func (this_frame));
}

static struct value *
mips_insn32_frame_prev_register (struct frame_info *this_frame,
				 void **this_cache, int regnum)
{
  struct mips_frame_cache *info = mips_insn32_frame_cache (this_frame,
							   this_cache);
  return trad_frame_get_prev_register (this_frame, info->saved_regs, regnum);
}

static int
mips_insn32_frame_sniffer (const struct frame_unwind *self,
			   struct frame_info *this_frame, void **this_cache)
{
  CORE_ADDR pc = get_frame_pc (this_frame);
  if (mips_pc_is_mips (pc))
    return 1;
  return 0;
}

static const struct frame_unwind mips_insn32_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  mips_insn32_frame_this_id,
  mips_insn32_frame_prev_register,
  NULL,
  mips_insn32_frame_sniffer
};

static CORE_ADDR
mips_insn32_frame_base_address (struct frame_info *this_frame,
				void **this_cache)
{
  struct mips_frame_cache *info = mips_insn32_frame_cache (this_frame,
							   this_cache);
  return info->base;
}

static const struct frame_base mips_insn32_frame_base =
{
  &mips_insn32_frame_unwind,
  mips_insn32_frame_base_address,
  mips_insn32_frame_base_address,
  mips_insn32_frame_base_address
};

static const struct frame_base *
mips_insn32_frame_base_sniffer (struct frame_info *this_frame)
{
  CORE_ADDR pc = get_frame_pc (this_frame);
  if (mips_pc_is_mips (pc))
    return &mips_insn32_frame_base;
  else
    return NULL;
}

static struct trad_frame_cache *
mips_stub_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  CORE_ADDR pc;
  CORE_ADDR start_addr;
  CORE_ADDR stack_addr;
  struct trad_frame_cache *this_trad_cache;
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  int num_regs = gdbarch_num_regs (gdbarch);

  if ((*this_cache) != NULL)
    return (*this_cache);
  this_trad_cache = trad_frame_cache_zalloc (this_frame);
  (*this_cache) = this_trad_cache;

  /* The return address is in the link register.  */
  trad_frame_set_reg_realreg (this_trad_cache,
			      gdbarch_pc_regnum (gdbarch),
			      num_regs + MIPS_RA_REGNUM);

  /* Frame ID, since it's a frameless / stackless function, no stack
     space is allocated and SP on entry is the current SP.  */
  pc = get_frame_pc (this_frame);
  find_pc_partial_function (pc, NULL, &start_addr, NULL);
  stack_addr = get_frame_register_signed (this_frame,
					  num_regs + MIPS_SP_REGNUM);
  trad_frame_set_id (this_trad_cache, frame_id_build (stack_addr, start_addr));

  /* Assume that the frame's base is the same as the
     stack-pointer.  */
  trad_frame_set_this_base (this_trad_cache, stack_addr);

  return this_trad_cache;
}

static void
mips_stub_frame_this_id (struct frame_info *this_frame, void **this_cache,
			 struct frame_id *this_id)
{
  struct trad_frame_cache *this_trad_cache
    = mips_stub_frame_cache (this_frame, this_cache);
  trad_frame_get_id (this_trad_cache, this_id);
}

static struct value *
mips_stub_frame_prev_register (struct frame_info *this_frame,
			       void **this_cache, int regnum)
{
  struct trad_frame_cache *this_trad_cache
    = mips_stub_frame_cache (this_frame, this_cache);
  return trad_frame_get_register (this_trad_cache, this_frame, regnum);
}

static int
mips_stub_frame_sniffer (const struct frame_unwind *self,
			 struct frame_info *this_frame, void **this_cache)
{
  gdb_byte dummy[4];
  struct obj_section *s;
  CORE_ADDR pc = get_frame_address_in_block (this_frame);
  struct bound_minimal_symbol msym;

  /* Use the stub unwinder for unreadable code.  */
  if (target_read_memory (get_frame_pc (this_frame), dummy, 4) != 0)
    return 1;

  if (in_plt_section (pc) || in_mips_stubs_section (pc))
    return 1;

  /* Calling a PIC function from a non-PIC function passes through a
     stub.  The stub for foo is named ".pic.foo".  */
  msym = lookup_minimal_symbol_by_pc (pc);
  if (msym.minsym != NULL
      && SYMBOL_LINKAGE_NAME (msym.minsym) != NULL
      && strncmp (SYMBOL_LINKAGE_NAME (msym.minsym), ".pic.", 5) == 0)
    return 1;

  return 0;
}

static const struct frame_unwind mips_stub_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  mips_stub_frame_this_id,
  mips_stub_frame_prev_register,
  NULL,
  mips_stub_frame_sniffer
};

static CORE_ADDR
mips_stub_frame_base_address (struct frame_info *this_frame,
			      void **this_cache)
{
  struct trad_frame_cache *this_trad_cache
    = mips_stub_frame_cache (this_frame, this_cache);
  return trad_frame_get_this_base (this_trad_cache);
}

static const struct frame_base mips_stub_frame_base =
{
  &mips_stub_frame_unwind,
  mips_stub_frame_base_address,
  mips_stub_frame_base_address,
  mips_stub_frame_base_address
};

static const struct frame_base *
mips_stub_frame_base_sniffer (struct frame_info *this_frame)
{
  if (mips_stub_frame_sniffer (&mips_stub_frame_unwind, this_frame, NULL))
    return &mips_stub_frame_base;
  else
    return NULL;
}

/* mips_addr_bits_remove - remove useless address bits  */

static CORE_ADDR
mips_addr_bits_remove (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (is_compact_addr (addr))
    addr = unmake_compact_addr (addr);

  if (mips_mask_address_p (tdep) && (((ULONGEST) addr) >> 32 == 0xffffffffUL))
    /* This hack is a work-around for existing boards using PMON, the
       simulator, and any other 64-bit targets that doesn't have true
       64-bit addressing.  On these targets, the upper 32 bits of
       addresses are ignored by the hardware.  Thus, the PC or SP are
       likely to have been sign extended to all 1s by instruction
       sequences that load 32-bit addresses.  For example, a typical
       piece of code that loads an address is this:

       lui $r2, <upper 16 bits>
       ori $r2, <lower 16 bits>

       But the lui sign-extends the value such that the upper 32 bits
       may be all 1s.  The workaround is simply to mask off these
       bits.  In the future, gcc may be changed to support true 64-bit
       addressing, and this masking will have to be disabled.  */
    return addr &= 0xffffffffUL;
  else
    return addr;
}


/* Checks for an atomic sequence of instructions beginning with a LL/LLD
   instruction and ending with a SC/SCD instruction.  If such a sequence
   is found, attempt to step through it.  A breakpoint is placed at the end of 
   the sequence.  */

/* Instructions used during single-stepping of atomic sequences, standard
   ISA version.  */
#define LL_OPCODE 0x30
#define LLD_OPCODE 0x34
#define SC_OPCODE 0x38
#define SCD_OPCODE 0x3c

static int
mips_deal_with_atomic_sequence (struct gdbarch *gdbarch,
 				struct address_space *aspace, CORE_ADDR pc)
{
  CORE_ADDR breaks[2] = {-1, -1};
  CORE_ADDR loc = pc;
  CORE_ADDR branch_bp; /* Breakpoint at branch instruction's destination.  */
  ULONGEST insn;
  int insn_count;
  int index;
  int last_breakpoint = 0; /* Defaults to 0 (no breakpoints placed).  */  
  const int atomic_sequence_length = 16; /* Instruction sequence length.  */

  insn = mips_fetch_instruction (gdbarch, ISA_MIPS, loc, NULL);
  /* Assume all atomic sequences start with a ll/lld instruction.  */
  if (itype_op (insn) != LL_OPCODE && itype_op (insn) != LLD_OPCODE)
    return 0;

  /* Assume that no atomic sequence is longer than "atomic_sequence_length" 
     instructions.  */
  for (insn_count = 0; insn_count < atomic_sequence_length; ++insn_count)
    {
      int is_branch = 0;
      loc += MIPS_INSN32_SIZE;
      insn = mips_fetch_instruction (gdbarch, ISA_MIPS, loc, NULL);

      /* Assume that there is at most one branch in the atomic
	 sequence.  If a branch is found, put a breakpoint in its
	 destination address.  */
      switch (itype_op (insn))
	{
	case 0: /* SPECIAL */
	  if (rtype_funct (insn) >> 1 == 4) /* JR, JALR */
	    return 0; /* fallback to the standard single-step code.  */
	  break;
	case 1: /* REGIMM */
	  is_branch = ((itype_rt (insn) & 0xc) == 0 /* B{LT,GE}Z* */
		       || ((itype_rt (insn) & 0x1e) == 0
			   && itype_rs (insn) == 0)); /* BPOSGE* */
	  break;
	case 2: /* J */
	case 3: /* JAL */
	  return 0; /* fallback to the standard single-step code.  */
	case 4: /* BEQ */
	case 5: /* BNE */
	case 6: /* BLEZ */
	case 7: /* BGTZ */
	case 20: /* BEQL */
	case 21: /* BNEL */
	case 22: /* BLEZL */
	case 23: /* BGTTL */
	  is_branch = 1;
	  break;
	case 17: /* COP1 */
	  is_branch = ((itype_rs (insn) == 9 || itype_rs (insn) == 10)
		       && (itype_rt (insn) & 0x2) == 0);
	  if (is_branch) /* BC1ANY2F, BC1ANY2T, BC1ANY4F, BC1ANY4T */
	    break;
	/* Fall through.  */
	case 18: /* COP2 */
	case 19: /* COP3 */
	  is_branch = (itype_rs (insn) == 8); /* BCzF, BCzFL, BCzT, BCzTL */
	  break;
	}
      if (is_branch)
	{
	  branch_bp = loc + mips32_relative_offset (insn) + 4;
	  if (last_breakpoint >= 1)
	    return 0; /* More than one branch found, fallback to the
			 standard single-step code.  */
	  breaks[1] = branch_bp;
	  last_breakpoint++;
	}

      if (itype_op (insn) == SC_OPCODE || itype_op (insn) == SCD_OPCODE)
	break;
    }

  /* Assume that the atomic sequence ends with a sc/scd instruction.  */
  if (itype_op (insn) != SC_OPCODE && itype_op (insn) != SCD_OPCODE)
    return 0;

  loc += MIPS_INSN32_SIZE;

  /* Insert a breakpoint right after the end of the atomic sequence.  */
  breaks[0] = loc;

  /* Check for duplicated breakpoints.  Check also for a breakpoint
     placed (branch instruction's destination) in the atomic sequence.  */
  if (last_breakpoint && pc <= breaks[1] && breaks[1] <= breaks[0])
    last_breakpoint = 0;

  /* Effectively inserts the breakpoints.  */
  for (index = 0; index <= last_breakpoint; index++)
    insert_single_step_breakpoint (gdbarch, aspace, breaks[index]);

  return 1;
}

static int
micromips_deal_with_atomic_sequence (struct gdbarch *gdbarch,
				     struct address_space *aspace,
				     CORE_ADDR pc)
{
  const int atomic_sequence_length = 16; /* Instruction sequence length.  */
  int last_breakpoint = 0; /* Defaults to 0 (no breakpoints placed).  */
  CORE_ADDR breaks[2] = {-1, -1};
  CORE_ADDR branch_bp = 0; /* Breakpoint at branch instruction's
			      destination.  */
  CORE_ADDR loc = pc;
  int sc_found = 0;
  ULONGEST insn;
  int insn_count;
  int index;

  /* Assume all atomic sequences start with a ll/lld instruction.  */
  insn = mips_fetch_instruction (gdbarch, ISA_MICROMIPS, loc, NULL);
  if (micromips_op (insn) != 0x18)	/* POOL32C: bits 011000 */
    return 0;
  loc += MIPS_INSN16_SIZE;
  insn <<= 16;
  insn |= mips_fetch_instruction (gdbarch, ISA_MICROMIPS, loc, NULL);
  if ((b12s4_op (insn) & 0xb) != 0x3)	/* LL, LLD: bits 011000 0x11 */
    return 0;
  loc += MIPS_INSN16_SIZE;

  /* Assume all atomic sequences end with an sc/scd instruction.  Assume
     that no atomic sequence is longer than "atomic_sequence_length"
     instructions.  */
  for (insn_count = 0;
       !sc_found && insn_count < atomic_sequence_length;
       ++insn_count)
    {
      int is_branch = 0;

      insn = mips_fetch_instruction (gdbarch, ISA_MICROMIPS, loc, NULL);
      loc += MIPS_INSN16_SIZE;

      /* Assume that there is at most one conditional branch in the
         atomic sequence.  If a branch is found, put a breakpoint in
         its destination address.  */
      switch (mips_insn_size (ISA_MICROMIPS, insn))
	{
	/* 48-bit instructions.  */
	case 3 * MIPS_INSN16_SIZE: /* POOL48A: bits 011111 */
	  loc += 2 * MIPS_INSN16_SIZE;
	  break;

	/* 32-bit instructions.  */
	case 2 * MIPS_INSN16_SIZE:
	  switch (micromips_op (insn))
	    {
	    case 0x10: /* POOL32I: bits 010000 */
	      if ((b5s5_op (insn) & 0x18) != 0x0
				/* BLTZ, BLTZAL, BGEZ, BGEZAL: 010000 000xx */
				/* BLEZ, BNEZC, BGTZ, BEQZC: 010000 001xx */
		  && (b5s5_op (insn) & 0x1d) != 0x11
				/* BLTZALS, BGEZALS: bits 010000 100x1 */
		  && ((b5s5_op (insn) & 0x1e) != 0x14
		      || (insn & 0x3) != 0x0)
				/* BC2F, BC2T: bits 010000 1010x xxx00 */
		  && (b5s5_op (insn) & 0x1e) != 0x1a
				/* BPOSGE64, BPOSGE32: bits 010000 1101x */
		  && ((b5s5_op (insn) & 0x1e) != 0x1c
		      || (insn & 0x3) != 0x0)
				/* BC1F, BC1T: bits 010000 1110x xxx00 */
		  && ((b5s5_op (insn) & 0x1c) != 0x1c
		      || (insn & 0x3) != 0x1))
				/* BC1ANY*: bits 010000 111xx xxx01 */
		break;
	      /* Fall through.  */

	    case 0x25: /* BEQ: bits 100101 */
	    case 0x2d: /* BNE: bits 101101 */
	      insn <<= 16;
	      insn |= mips_fetch_instruction (gdbarch,
					      ISA_MICROMIPS, loc, NULL);
	      branch_bp = (loc + MIPS_INSN16_SIZE
			   + micromips_relative_offset16 (insn));
	      is_branch = 1;
	      break;

	    case 0x00: /* POOL32A: bits 000000 */
	      insn <<= 16;
	      insn |= mips_fetch_instruction (gdbarch,
					      ISA_MICROMIPS, loc, NULL);
	      if (b0s6_op (insn) != 0x3c
				/* POOL32Axf: bits 000000 ... 111100 */
		  || (b6s10_ext (insn) & 0x2bf) != 0x3c)
				/* JALR, JALR.HB: 000000 000x111100 111100 */
				/* JALRS, JALRS.HB: 000000 010x111100 111100 */
		break;
	      /* Fall through.  */

	    case 0x1d: /* JALS: bits 011101 */
	    case 0x35: /* J: bits 110101 */
	    case 0x3d: /* JAL: bits 111101 */
	    case 0x3c: /* JALX: bits 111100 */
	      return 0; /* Fall back to the standard single-step code. */

	    case 0x18: /* POOL32C: bits 011000 */
	      if ((b12s4_op (insn) & 0xb) == 0xb)
				/* SC, SCD: bits 011000 1x11 */
		sc_found = 1;
	      break;
	    }
	  loc += MIPS_INSN16_SIZE;
	  break;

	/* 16-bit instructions.  */
	case MIPS_INSN16_SIZE:
	  switch (micromips_op (insn))
	    {
	    case 0x23: /* BEQZ16: bits 100011 */
	    case 0x2b: /* BNEZ16: bits 101011 */
	      branch_bp = loc + micromips_relative_offset7 (insn);
	      is_branch = 1;
	      break;

	    case 0x11: /* POOL16C: bits 010001 */
	      if ((b5s5_op (insn) & 0x1c) != 0xc
				/* JR16, JRC, JALR16, JALRS16: 010001 011xx */
	          && b5s5_op (insn) != 0x18)
				/* JRADDIUSP: bits 010001 11000 */
	        break;
	      return 0; /* Fall back to the standard single-step code. */

	    case 0x33: /* B16: bits 110011 */
	      return 0; /* Fall back to the standard single-step code. */
	    }
	  break;
	}
      if (is_branch)
	{
	  if (last_breakpoint >= 1)
	    return 0; /* More than one branch found, fallback to the
			 standard single-step code.  */
	  breaks[1] = branch_bp;
	  last_breakpoint++;
	}
    }
  if (!sc_found)
    return 0;

  /* Insert a breakpoint right after the end of the atomic sequence.  */
  breaks[0] = loc;

  /* Check for duplicated breakpoints.  Check also for a breakpoint
     placed (branch instruction's destination) in the atomic sequence */
  if (last_breakpoint && pc <= breaks[1] && breaks[1] <= breaks[0])
    last_breakpoint = 0;

  /* Effectively inserts the breakpoints.  */
  for (index = 0; index <= last_breakpoint; index++)
    insert_single_step_breakpoint (gdbarch, aspace, breaks[index]);

  return 1;
}

static int
deal_with_atomic_sequence (struct gdbarch *gdbarch,
			   struct address_space *aspace, CORE_ADDR pc)
{
  if (mips_pc_is_mips (pc))
    return mips_deal_with_atomic_sequence (gdbarch, aspace, pc);
  else if (mips_pc_is_micromips (gdbarch, pc))
    return micromips_deal_with_atomic_sequence (gdbarch, aspace, pc);
  else
    return 0;
}

/* mips_software_single_step() is called just before we want to resume
   the inferior, if we want to single-step it but there is no hardware
   or kernel single-step support (MIPS on GNU/Linux for example).  We find
   the target of the coming instruction and breakpoint it.  */

int
mips_software_single_step (struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct address_space *aspace = get_frame_address_space (frame);
  CORE_ADDR pc, next_pc;

  pc = get_frame_pc (frame);
  if (deal_with_atomic_sequence (gdbarch, aspace, pc))
    return 1;

  next_pc = mips_next_pc (frame, pc);

  insert_single_step_breakpoint (gdbarch, aspace, next_pc);
  return 1;
}

/* Test whether the PC points to the return instruction at the
   end of a function.  */

static int
mips_about_to_return (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  ULONGEST insn;
  ULONGEST hint;

  /* This used to check for MIPS16, but this piece of code is never
     called for MIPS16 functions.  And likewise microMIPS ones.  */
  gdb_assert (mips_pc_is_mips (pc));

  insn = mips_fetch_instruction (gdbarch, ISA_MIPS, pc, NULL);
  hint = 0x7c0;
  return (insn & ~hint) == 0x3e00008;			/* jr(.hb) $ra */
}


/* This fencepost looks highly suspicious to me.  Removing it also
   seems suspicious as it could affect remote debugging across serial
   lines.  */

static CORE_ADDR
heuristic_proc_start (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  CORE_ADDR start_pc;
  CORE_ADDR fence;
  int instlen;
  int seen_adjsp = 0;
  struct inferior *inf;

  pc = gdbarch_addr_bits_remove (gdbarch, pc);
  start_pc = pc;
  fence = start_pc - heuristic_fence_post;
  if (start_pc == 0)
    return 0;

  if (heuristic_fence_post == -1 || fence < VM_MIN_ADDRESS)
    fence = VM_MIN_ADDRESS;

  instlen = mips_pc_is_mips (pc) ? MIPS_INSN32_SIZE : MIPS_INSN16_SIZE;

  inf = current_inferior ();

  /* Search back for previous return.  */
  for (start_pc -= instlen;; start_pc -= instlen)
    if (start_pc < fence)
      {
	/* It's not clear to me why we reach this point when
	   stop_soon, but with this test, at least we
	   don't print out warnings for every child forked (eg, on
	   decstation).  22apr93 rich@@cygnus.com.  */
	if (inf->control.stop_soon == NO_STOP_QUIETLY)
	  {
	    static int blurb_printed = 0;

	    warning (_("GDB can't find the start of the function at %s."),
		     paddress (gdbarch, pc));

	    if (!blurb_printed)
	      {
		/* This actually happens frequently in embedded
		   development, when you first connect to a board
		   and your stack pointer and pc are nowhere in
		   particular.  This message needs to give people
		   in that situation enough information to
		   determine that it's no big deal.  */
		printf_filtered ("\n\
    GDB is unable to find the start of the function at %s\n\
and thus can't determine the size of that function's stack frame.\n\
This means that GDB may be unable to access that stack frame, or\n\
the frames below it.\n\
    This problem is most likely caused by an invalid program counter or\n\
stack pointer.\n\
    However, if you think GDB should simply search farther back\n\
from %s for code which looks like the beginning of a\n\
function, you can increase the range of the search using the `set\n\
heuristic-fence-post' command.\n",
			paddress (gdbarch, pc), paddress (gdbarch, pc));
		blurb_printed = 1;
	      }
	  }

	return 0;
      }
    else if (mips_pc_is_mips16 (gdbarch, start_pc))
      {
	unsigned short inst;

	/* On MIPS16, any one of the following is likely to be the
	   start of a function:
  	   extend save
	   save
	   entry
	   addiu sp,-n
	   daddiu sp,-n
	   extend -n followed by 'addiu sp,+n' or 'daddiu sp,+n'.  */
	inst = mips_fetch_instruction (gdbarch, ISA_MIPS16, start_pc, NULL);
	if ((inst & 0xff80) == 0x6480)		/* save */
	  {
	    if (start_pc - instlen >= fence)
	      {
		inst = mips_fetch_instruction (gdbarch, ISA_MIPS16,
					       start_pc - instlen, NULL);
		if ((inst & 0xf800) == 0xf000)	/* extend */
		  start_pc -= instlen;
	      }
	    break;
	  }
	else if (((inst & 0xf81f) == 0xe809
		  && (inst & 0x700) != 0x700)	/* entry */
		 || (inst & 0xff80) == 0x6380	/* addiu sp,-n */
		 || (inst & 0xff80) == 0xfb80	/* daddiu sp,-n */
		 || ((inst & 0xf810) == 0xf010 && seen_adjsp))	/* extend -n */
	  break;
	else if ((inst & 0xff00) == 0x6300	/* addiu sp */
		 || (inst & 0xff00) == 0xfb00)	/* daddiu sp */
	  seen_adjsp = 1;
	else
	  seen_adjsp = 0;
      }
    else if (mips_pc_is_micromips (gdbarch, start_pc))
      {
	ULONGEST insn;
	int stop = 0;
	long offset;
	int dreg;
	int sreg;

	/* On microMIPS, any one of the following is likely to be the
	   start of a function:
	   ADDIUSP -imm
	   (D)ADDIU $sp, -imm
	   LUI $gp, imm  */
	insn = mips_fetch_instruction (gdbarch, ISA_MICROMIPS, pc, NULL);
	switch (micromips_op (insn))
	  {
	  case 0xc: /* ADDIU: bits 001100 */
	  case 0x17: /* DADDIU: bits 010111 */
	    sreg = b0s5_reg (insn);
	    dreg = b5s5_reg (insn);
	    insn <<= 16;
	    insn |= mips_fetch_instruction (gdbarch, ISA_MICROMIPS,
					    pc + MIPS_INSN16_SIZE, NULL);
	    offset = (b0s16_imm (insn) ^ 0x8000) - 0x8000;
	    if (sreg == MIPS_SP_REGNUM && dreg == MIPS_SP_REGNUM
				/* (D)ADDIU $sp, imm */
		&& offset < 0)
	      stop = 1;
	    break;

	  case 0x10: /* POOL32I: bits 010000 */
	    if (b5s5_op (insn) == 0xd
				/* LUI: bits 010000 001101 */
		&& b0s5_reg (insn >> 16) == 28)
				/* LUI $gp, imm */
	      stop = 1;
	    break;

	  case 0x13: /* POOL16D: bits 010011 */
	    if ((insn & 0x1) == 0x1)
				/* ADDIUSP: bits 010011 1 */
	      {
		offset = micromips_decode_imm9 (b1s9_imm (insn));
		if (offset < 0)
				/* ADDIUSP -imm */
		  stop = 1;
	      }
	    else
				/* ADDIUS5: bits 010011 0 */
	      {
		dreg = b5s5_reg (insn);
		offset = (b1s4_imm (insn) ^ 8) - 8;
		if (dreg == MIPS_SP_REGNUM && offset < 0)
				/* ADDIUS5  $sp, -imm */
		  stop = 1;
	      }
	    break;
	  }
	if (stop)
	  break;
      }
    else if (mips_about_to_return (gdbarch, start_pc))
      {
	/* Skip return and its delay slot.  */
	start_pc += 2 * MIPS_INSN32_SIZE;
	break;
      }

  return start_pc;
}

struct mips_objfile_private
{
  bfd_size_type size;
  char *contents;
};

/* According to the current ABI, should the type be passed in a
   floating-point register (assuming that there is space)?  When there
   is no FPU, FP are not even considered as possible candidates for
   FP registers and, consequently this returns false - forces FP
   arguments into integer registers.  */

static int
fp_register_arg_p (struct gdbarch *gdbarch, enum type_code typecode,
		   struct type *arg_type)
{
  return ((typecode == TYPE_CODE_FLT
	   || (MIPS_EABI (gdbarch)
	       && (typecode == TYPE_CODE_STRUCT
		   || typecode == TYPE_CODE_UNION)
	       && TYPE_NFIELDS (arg_type) == 1
	       && TYPE_CODE (check_typedef (TYPE_FIELD_TYPE (arg_type, 0))) 
	       == TYPE_CODE_FLT))
	  && MIPS_FPU_TYPE(gdbarch) != MIPS_FPU_NONE);
}

/* On o32, argument passing in GPRs depends on the alignment of the type being
   passed.  Return 1 if this type must be aligned to a doubleword boundary.  */

static int
mips_type_needs_double_align (struct type *type)
{
  enum type_code typecode = TYPE_CODE (type);

  if (typecode == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8)
    return 1;
  else if (typecode == TYPE_CODE_STRUCT)
    {
      if (TYPE_NFIELDS (type) < 1)
	return 0;
      return mips_type_needs_double_align (TYPE_FIELD_TYPE (type, 0));
    }
  else if (typecode == TYPE_CODE_UNION)
    {
      int i, n;

      n = TYPE_NFIELDS (type);
      for (i = 0; i < n; i++)
	if (mips_type_needs_double_align (TYPE_FIELD_TYPE (type, i)))
	  return 1;
      return 0;
    }
  return 0;
}

/* Adjust the address downward (direction of stack growth) so that it
   is correctly aligned for a new stack frame.  */
static CORE_ADDR
mips_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  return align_down (addr, 16);
}

/* Implement the "push_dummy_code" gdbarch method.  */

static CORE_ADDR
mips_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp,
		      CORE_ADDR funaddr, struct value **args,
		      int nargs, struct type *value_type,
		      CORE_ADDR *real_pc, CORE_ADDR *bp_addr,
		      struct regcache *regcache)
{
  static gdb_byte nop_insn[] = { 0, 0, 0, 0 };
  CORE_ADDR nop_addr;
  CORE_ADDR bp_slot;

  /* Reserve enough room on the stack for our breakpoint instruction.  */
  bp_slot = sp - sizeof (nop_insn);

  /* Return to microMIPS mode if calling microMIPS code to avoid
     triggering an address error exception on processors that only
     support microMIPS execution.  */
  *bp_addr = (mips_pc_is_micromips (gdbarch, funaddr)
	      ? make_compact_addr (bp_slot) : bp_slot);

  /* The breakpoint layer automatically adjusts the address of
     breakpoints inserted in a branch delay slot.  With enough
     bad luck, the 4 bytes located just before our breakpoint
     instruction could look like a branch instruction, and thus
     trigger the adjustement, and break the function call entirely.
     So, we reserve those 4 bytes and write a nop instruction
     to prevent that from happening.  */
  nop_addr = bp_slot - sizeof (nop_insn);
  write_memory (nop_addr, nop_insn, sizeof (nop_insn));
  sp = mips_frame_align (gdbarch, nop_addr);

  /* Inferior resumes at the function entry point.  */
  *real_pc = funaddr;

  return sp;
}

static CORE_ADDR
mips_eabi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
			   struct regcache *regcache, CORE_ADDR bp_addr,
			   int nargs, struct value **args, CORE_ADDR sp,
			   int struct_return, CORE_ADDR struct_addr)
{
  int argreg;
  int float_argreg;
  int argnum;
  int len = 0;
  int stack_offset = 0;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR func_addr = find_function_addr (function, NULL);
  int regsize = mips_abi_regsize (gdbarch);

  /* For shared libraries, "t9" needs to point at the function
     address.  */
  regcache_cooked_write_signed (regcache, MIPS_T9_REGNUM, func_addr);

  /* Set the return address register to point to the entry point of
     the program, where a breakpoint lies in wait.  */
  regcache_cooked_write_signed (regcache, MIPS_RA_REGNUM, bp_addr);

  /* First ensure that the stack and structure return address (if any)
     are properly aligned.  The stack has to be at least 64-bit
     aligned even on 32-bit machines, because doubles must be 64-bit
     aligned.  For n32 and n64, stack frames need to be 128-bit
     aligned, so we round to this widest known alignment.  */

  sp = align_down (sp, 16);
  struct_addr = align_down (struct_addr, 16);

  /* Now make space on the stack for the args.  We allocate more
     than necessary for EABI, because the first few arguments are
     passed in registers, but that's OK.  */
  for (argnum = 0; argnum < nargs; argnum++)
    len += align_up (TYPE_LENGTH (value_type (args[argnum])), regsize);
  sp -= align_up (len, 16);

  if (mips_debug)
    fprintf_unfiltered (gdb_stdlog,
			"mips_eabi_push_dummy_call: sp=%s allocated %ld\n",
			paddress (gdbarch, sp), (long) align_up (len, 16));

  /* Initialize the integer and float register pointers.  */
  argreg = MIPS_A0_REGNUM;
  float_argreg = mips_fpa0_regnum (gdbarch);

  /* The struct_return pointer occupies the first parameter-passing reg.  */
  if (struct_return)
    {
      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "mips_eabi_push_dummy_call: "
			    "struct_return reg=%d %s\n",
			    argreg, paddress (gdbarch, struct_addr));
      regcache_cooked_write_unsigned (regcache, argreg++, struct_addr);
    }

  /* Now load as many as possible of the first arguments into
     registers, and push the rest onto the stack.  Loop thru args
     from first to last.  */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      const gdb_byte *val;
      gdb_byte valbuf[MAX_REGISTER_SIZE];
      struct value *arg = args[argnum];
      struct type *arg_type = check_typedef (value_type (arg));
      int len = TYPE_LENGTH (arg_type);
      enum type_code typecode = TYPE_CODE (arg_type);

      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "mips_eabi_push_dummy_call: %d len=%d type=%d",
			    argnum + 1, len, (int) typecode);

      /* Function pointer arguments to mips16 code need to be made into
         mips16 pointers.  */
      if (typecode == TYPE_CODE_PTR
          && TYPE_CODE (TYPE_TARGET_TYPE (arg_type)) == TYPE_CODE_FUNC)
	{
	  CORE_ADDR addr = extract_signed_integer (value_contents (arg),
						   len, byte_order);
	  if (mips_pc_is_mips (addr))
	    val = value_contents (arg);
	  else
	    {
	      store_signed_integer (valbuf, len, byte_order, 
				    make_compact_addr (addr));
	      val = valbuf;
	    }
	}
      /* The EABI passes structures that do not fit in a register by
         reference.  */
      else if (len > regsize
	  && (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION))
	{
	  store_unsigned_integer (valbuf, regsize, byte_order,
				  value_address (arg));
	  typecode = TYPE_CODE_PTR;
	  len = regsize;
	  val = valbuf;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stdlog, " push");
	}
      else
	val = value_contents (arg);

      /* 32-bit ABIs always start floating point arguments in an
         even-numbered floating point register.  Round the FP register
         up before the check to see if there are any FP registers
         left.  Non MIPS_EABI targets also pass the FP in the integer
         registers so also round up normal registers.  */
      if (regsize < 8 && fp_register_arg_p (gdbarch, typecode, arg_type))
	{
	  if ((float_argreg & 1))
	    float_argreg++;
	}

      /* Floating point arguments passed in registers have to be
         treated specially.  On 32-bit architectures, doubles
         are passed in register pairs; the even register gets
         the low word, and the odd register gets the high word.
         On non-EABI processors, the first two floating point arguments are
         also copied to general registers, because MIPS16 functions
         don't use float registers for arguments.  This duplication of
         arguments in general registers can't hurt non-MIPS16 functions
         because those registers are normally skipped.  */
      /* MIPS_EABI squeezes a struct that contains a single floating
         point value into an FP register instead of pushing it onto the
         stack.  */
      if (fp_register_arg_p (gdbarch, typecode, arg_type)
	  && float_argreg <= MIPS_LAST_FP_ARG_REGNUM (gdbarch))
	{
	  /* EABI32 will pass doubles in consecutive registers, even on
	     64-bit cores.  At one time, we used to check the size of
	     `float_argreg' to determine whether or not to pass doubles
	     in consecutive registers, but this is not sufficient for
	     making the ABI determination.  */
	  if (len == 8 && mips_abi (gdbarch) == MIPS_ABI_EABI32)
	    {
	      int low_offset = gdbarch_byte_order (gdbarch)
			       == BFD_ENDIAN_BIG ? 4 : 0;
	      long regval;

	      /* Write the low word of the double to the even register(s).  */
	      regval = extract_signed_integer (val + low_offset,
					       4, byte_order);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg, phex (regval, 4));
	      regcache_cooked_write_signed (regcache, float_argreg++, regval);

	      /* Write the high word of the double to the odd register(s).  */
	      regval = extract_signed_integer (val + 4 - low_offset,
					       4, byte_order);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg, phex (regval, 4));
	      regcache_cooked_write_signed (regcache, float_argreg++, regval);
	    }
	  else
	    {
	      /* This is a floating point value that fits entirely
	         in a single register.  */
	      /* On 32 bit ABI's the float_argreg is further adjusted
	         above to ensure that it is even register aligned.  */
	      LONGEST regval = extract_signed_integer (val, len, byte_order);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg, phex (regval, len));
	      regcache_cooked_write_signed (regcache, float_argreg++, regval);
	    }
	}
      else
	{
	  /* Copy the argument to general registers or the stack in
	     register-sized pieces.  Large arguments are split between
	     registers and stack.  */
	  /* Note: structs whose size is not a multiple of regsize
	     are treated specially: Irix cc passes
	     them in registers where gcc sometimes puts them on the
	     stack.  For maximum compatibility, we will put them in
	     both places.  */
	  int odd_sized_struct = (len > regsize && len % regsize != 0);

	  /* Note: Floating-point values that didn't fit into an FP
	     register are only written to memory.  */
	  while (len > 0)
	    {
	      /* Remember if the argument was written to the stack.  */
	      int stack_used_p = 0;
	      int partial_len = (len < regsize ? len : regsize);

	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " -- partial=%d",
				    partial_len);

	      /* Write this portion of the argument to the stack.  */
	      if (argreg > MIPS_LAST_ARG_REGNUM (gdbarch)
		  || odd_sized_struct
		  || fp_register_arg_p (gdbarch, typecode, arg_type))
		{
		  /* Should shorter than int integer values be
		     promoted to int before being stored?  */
		  int longword_offset = 0;
		  CORE_ADDR addr;
		  stack_used_p = 1;
		  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
		    {
		      if (regsize == 8
			  && (typecode == TYPE_CODE_INT
			      || typecode == TYPE_CODE_PTR
			      || typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = regsize - len;
		      else if ((typecode == TYPE_CODE_STRUCT
				|| typecode == TYPE_CODE_UNION)
			       && TYPE_LENGTH (arg_type) < regsize)
			longword_offset = regsize - len;
		    }

		  if (mips_debug)
		    {
		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=%s",
					  paddress (gdbarch, stack_offset));
		      fprintf_unfiltered (gdb_stdlog, " longword_offset=%s",
					  paddress (gdbarch, longword_offset));
		    }

		  addr = sp + stack_offset + longword_offset;

		  if (mips_debug)
		    {
		      int i;
		      fprintf_unfiltered (gdb_stdlog, " @@%s ",
					  paddress (gdbarch, addr));
		      for (i = 0; i < partial_len; i++)
			{
			  fprintf_unfiltered (gdb_stdlog, "%02x",
					      val[i] & 0xff);
			}
		    }
		  write_memory (addr, val, partial_len);
		}

	      /* Note!!! This is NOT an else clause.  Odd sized
	         structs may go thru BOTH paths.  Floating point
	         arguments will not.  */
	      /* Write this portion of the argument to a general
	         purpose register.  */
	      if (argreg <= MIPS_LAST_ARG_REGNUM (gdbarch)
		  && !fp_register_arg_p (gdbarch, typecode, arg_type))
		{
		  LONGEST regval =
		    extract_signed_integer (val, partial_len, byte_order);

		  if (mips_debug)
		    fprintf_filtered (gdb_stdlog, " - reg=%d val=%s",
				      argreg,
				      phex (regval, regsize));
		  regcache_cooked_write_signed (regcache, argreg, regval);
		  argreg++;
		}

	      len -= partial_len;
	      val += partial_len;

	      /* Compute the offset into the stack at which we will
	         copy the next parameter.

	         In the new EABI (and the NABI32), the stack_offset
	         only needs to be adjusted when it has been used.  */

	      if (stack_used_p)
		stack_offset += align_up (partial_len, regsize);
	    }
	}
      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog, "\n");
    }

  regcache_cooked_write_signed (regcache, MIPS_SP_REGNUM, sp);

  /* Return adjusted stack pointer.  */
  return sp;
}

/* Determine the return value convention being used.  */

static enum return_value_convention
mips_eabi_return_value (struct gdbarch *gdbarch, struct value *function,
			struct type *type, struct regcache *regcache,
			gdb_byte *readbuf, const gdb_byte *writebuf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int fp_return_type = 0;
  int offset, regnum, xfer;

  if (TYPE_LENGTH (type) > 2 * mips_abi_regsize (gdbarch))
    return RETURN_VALUE_STRUCT_CONVENTION;

  /* Floating point type?  */
  if (tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      if (TYPE_CODE (type) == TYPE_CODE_FLT)
	fp_return_type = 1;
      /* Structs with a single field of float type 
	 are returned in a floating point register.  */
      if ((TYPE_CODE (type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (type) == TYPE_CODE_UNION)
	  && TYPE_NFIELDS (type) == 1)
	{
	  struct type *fieldtype = TYPE_FIELD_TYPE (type, 0);

	  if (TYPE_CODE (check_typedef (fieldtype)) == TYPE_CODE_FLT)
	    fp_return_type = 1;
	}
    }

  if (fp_return_type)      
    {
      /* A floating-point value belongs in the least significant part
	 of FP0/FP1.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $fp0\n");
      regnum = mips_regnum (gdbarch)->fp0;
    }
  else 
    {
      /* An integer value goes in V0/V1.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return scalar in $v0\n");
      regnum = MIPS_V0_REGNUM;
    }
  for (offset = 0;
       offset < TYPE_LENGTH (type);
       offset += mips_abi_regsize (gdbarch), regnum++)
    {
      xfer = mips_abi_regsize (gdbarch);
      if (offset + xfer > TYPE_LENGTH (type))
	xfer = TYPE_LENGTH (type) - offset;
      mips_xfer_register (gdbarch, regcache,
			  gdbarch_num_regs (gdbarch) + regnum, xfer,
			  gdbarch_byte_order (gdbarch), readbuf, writebuf,
			  offset);
    }

  return RETURN_VALUE_REGISTER_CONVENTION;
}


/* N32/N64 ABI stuff.  */

/* Search for a naturally aligned double at OFFSET inside a struct
   ARG_TYPE.  The N32 / N64 ABIs pass these in floating point
   registers.  */

static int
mips_n32n64_fp_arg_chunk_p (struct gdbarch *gdbarch, struct type *arg_type,
			    int offset)
{
  int i;

  if (TYPE_CODE (arg_type) != TYPE_CODE_STRUCT)
    return 0;

  if (MIPS_FPU_TYPE (gdbarch) != MIPS_FPU_DOUBLE)
    return 0;

  if (TYPE_LENGTH (arg_type) < offset + MIPS64_REGSIZE)
    return 0;

  for (i = 0; i < TYPE_NFIELDS (arg_type); i++)
    {
      int pos;
      struct type *field_type;

      /* We're only looking at normal fields.  */
      if (field_is_static (&TYPE_FIELD (arg_type, i))
	  || (TYPE_FIELD_BITPOS (arg_type, i) % 8) != 0)
	continue;

      /* If we have gone past the offset, there is no double to pass.  */
      pos = TYPE_FIELD_BITPOS (arg_type, i) / 8;
      if (pos > offset)
	return 0;

      field_type = check_typedef (TYPE_FIELD_TYPE (arg_type, i));

      /* If this field is entirely before the requested offset, go
	 on to the next one.  */
      if (pos + TYPE_LENGTH (field_type) <= offset)
	continue;

      /* If this is our special aligned double, we can stop.  */
      if (TYPE_CODE (field_type) == TYPE_CODE_FLT
	  && TYPE_LENGTH (field_type) == MIPS64_REGSIZE)
	return 1;

      /* This field starts at or before the requested offset, and
	 overlaps it.  If it is a structure, recurse inwards.  */
      return mips_n32n64_fp_arg_chunk_p (gdbarch, field_type, offset - pos);
    }

  return 0;
}

static CORE_ADDR
mips_n32n64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
			     struct regcache *regcache, CORE_ADDR bp_addr,
			     int nargs, struct value **args, CORE_ADDR sp,
			     int struct_return, CORE_ADDR struct_addr)
{
  int argreg;
  int float_argreg;
  int argnum;
  int len = 0;
  int stack_offset = 0;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR func_addr = find_function_addr (function, NULL);

  /* For shared libraries, "t9" needs to point at the function
     address.  */
  regcache_cooked_write_signed (regcache, MIPS_T9_REGNUM, func_addr);

  /* Set the return address register to point to the entry point of
     the program, where a breakpoint lies in wait.  */
  regcache_cooked_write_signed (regcache, MIPS_RA_REGNUM, bp_addr);

  /* First ensure that the stack and structure return address (if any)
     are properly aligned.  The stack has to be at least 64-bit
     aligned even on 32-bit machines, because doubles must be 64-bit
     aligned.  For n32 and n64, stack frames need to be 128-bit
     aligned, so we round to this widest known alignment.  */

  sp = align_down (sp, 16);
  struct_addr = align_down (struct_addr, 16);

  /* Now make space on the stack for the args.  */
  for (argnum = 0; argnum < nargs; argnum++)
    len += align_up (TYPE_LENGTH (value_type (args[argnum])), MIPS64_REGSIZE);
  sp -= align_up (len, 16);

  if (mips_debug)
    fprintf_unfiltered (gdb_stdlog,
			"mips_n32n64_push_dummy_call: sp=%s allocated %ld\n",
			paddress (gdbarch, sp), (long) align_up (len, 16));

  /* Initialize the integer and float register pointers.  */
  argreg = MIPS_A0_REGNUM;
  float_argreg = mips_fpa0_regnum (gdbarch);

  /* The struct_return pointer occupies the first parameter-passing reg.  */
  if (struct_return)
    {
      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "mips_n32n64_push_dummy_call: "
			    "struct_return reg=%d %s\n",
			    argreg, paddress (gdbarch, struct_addr));
      regcache_cooked_write_unsigned (regcache, argreg++, struct_addr);
    }

  /* Now load as many as possible of the first arguments into
     registers, and push the rest onto the stack.  Loop thru args
     from first to last.  */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      const gdb_byte *val;
      struct value *arg = args[argnum];
      struct type *arg_type = check_typedef (value_type (arg));
      int len = TYPE_LENGTH (arg_type);
      enum type_code typecode = TYPE_CODE (arg_type);

      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "mips_n32n64_push_dummy_call: %d len=%d type=%d",
			    argnum + 1, len, (int) typecode);

      val = value_contents (arg);

      /* A 128-bit long double value requires an even-odd pair of
	 floating-point registers.  */
      if (len == 16
	  && fp_register_arg_p (gdbarch, typecode, arg_type)
	  && (float_argreg & 1))
	{
	  float_argreg++;
	  argreg++;
	}

      if (fp_register_arg_p (gdbarch, typecode, arg_type)
	  && argreg <= MIPS_LAST_ARG_REGNUM (gdbarch))
	{
	  /* This is a floating point value that fits entirely
	     in a single register or a pair of registers.  */
	  int reglen = (len <= MIPS64_REGSIZE ? len : MIPS64_REGSIZE);
	  LONGEST regval = extract_unsigned_integer (val, reglen, byte_order);
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				float_argreg, phex (regval, reglen));
	  regcache_cooked_write_unsigned (regcache, float_argreg, regval);

	  if (mips_debug)
	    fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				argreg, phex (regval, reglen));
	  regcache_cooked_write_unsigned (regcache, argreg, regval);
	  float_argreg++;
	  argreg++;
	  if (len == 16)
	    {
	      regval = extract_unsigned_integer (val + reglen,
						 reglen, byte_order);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg, phex (regval, reglen));
	      regcache_cooked_write_unsigned (regcache, float_argreg, regval);

	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				    argreg, phex (regval, reglen));
	      regcache_cooked_write_unsigned (regcache, argreg, regval);
	      float_argreg++;
	      argreg++;
	    }
	}
      else
	{
	  /* Copy the argument to general registers or the stack in
	     register-sized pieces.  Large arguments are split between
	     registers and stack.  */
	  /* For N32/N64, structs, unions, or other composite types are
	     treated as a sequence of doublewords, and are passed in integer
	     or floating point registers as though they were simple scalar
	     parameters to the extent that they fit, with any excess on the
	     stack packed according to the normal memory layout of the
	     object.
	     The caller does not reserve space for the register arguments;
	     the callee is responsible for reserving it if required.  */
	  /* Note: Floating-point values that didn't fit into an FP
	     register are only written to memory.  */
	  while (len > 0)
	    {
	      /* Remember if the argument was written to the stack.  */
	      int stack_used_p = 0;
	      int partial_len = (len < MIPS64_REGSIZE ? len : MIPS64_REGSIZE);

	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " -- partial=%d",
				    partial_len);

	      if (fp_register_arg_p (gdbarch, typecode, arg_type))
		gdb_assert (argreg > MIPS_LAST_ARG_REGNUM (gdbarch));

	      /* Write this portion of the argument to the stack.  */
	      if (argreg > MIPS_LAST_ARG_REGNUM (gdbarch))
		{
		  /* Should shorter than int integer values be
		     promoted to int before being stored?  */
		  int longword_offset = 0;
		  CORE_ADDR addr;
		  stack_used_p = 1;
		  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
		    {
		      if ((typecode == TYPE_CODE_INT
			   || typecode == TYPE_CODE_PTR)
			  && len <= 4)
			longword_offset = MIPS64_REGSIZE - len;
		    }

		  if (mips_debug)
		    {
		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=%s",
					  paddress (gdbarch, stack_offset));
		      fprintf_unfiltered (gdb_stdlog, " longword_offset=%s",
					  paddress (gdbarch, longword_offset));
		    }

		  addr = sp + stack_offset + longword_offset;

		  if (mips_debug)
		    {
		      int i;
		      fprintf_unfiltered (gdb_stdlog, " @@%s ",
					  paddress (gdbarch, addr));
		      for (i = 0; i < partial_len; i++)
			{
			  fprintf_unfiltered (gdb_stdlog, "%02x",
					      val[i] & 0xff);
			}
		    }
		  write_memory (addr, val, partial_len);
		}

	      /* Note!!! This is NOT an else clause.  Odd sized
	         structs may go thru BOTH paths.  */
	      /* Write this portion of the argument to a general
	         purpose register.  */
	      if (argreg <= MIPS_LAST_ARG_REGNUM (gdbarch))
		{
		  LONGEST regval;

		  /* Sign extend pointers, 32-bit integers and signed
		     16-bit and 8-bit integers; everything else is taken
		     as is.  */

		  if ((partial_len == 4
		       && (typecode == TYPE_CODE_PTR
			   || typecode == TYPE_CODE_INT))
		      || (partial_len < 4
			  && typecode == TYPE_CODE_INT
			  && !TYPE_UNSIGNED (arg_type)))
		    regval = extract_signed_integer (val, partial_len,
						     byte_order);
		  else
		    regval = extract_unsigned_integer (val, partial_len,
						       byte_order);

		  /* A non-floating-point argument being passed in a
		     general register.  If a struct or union, and if
		     the remaining length is smaller than the register
		     size, we have to adjust the register value on
		     big endian targets.

		     It does not seem to be necessary to do the
		     same for integral types.  */

		  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG
		      && partial_len < MIPS64_REGSIZE
		      && (typecode == TYPE_CODE_STRUCT
			  || typecode == TYPE_CODE_UNION))
		    regval <<= ((MIPS64_REGSIZE - partial_len)
				* TARGET_CHAR_BIT);

		  if (mips_debug)
		    fprintf_filtered (gdb_stdlog, " - reg=%d val=%s",
				      argreg,
				      phex (regval, MIPS64_REGSIZE));
		  regcache_cooked_write_unsigned (regcache, argreg, regval);

		  if (mips_n32n64_fp_arg_chunk_p (gdbarch, arg_type,
						  TYPE_LENGTH (arg_type) - len))
		    {
		      if (mips_debug)
			fprintf_filtered (gdb_stdlog, " - fpreg=%d val=%s",
					  float_argreg,
					  phex (regval, MIPS64_REGSIZE));
		      regcache_cooked_write_unsigned (regcache, float_argreg,
						      regval);
		    }

		  float_argreg++;
		  argreg++;
		}

	      len -= partial_len;
	      val += partial_len;

	      /* Compute the offset into the stack at which we will
	         copy the next parameter.

	         In N32 (N64?), the stack_offset only needs to be
	         adjusted when it has been used.  */

	      if (stack_used_p)
		stack_offset += align_up (partial_len, MIPS64_REGSIZE);
	    }
	}
      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog, "\n");
    }

  regcache_cooked_write_signed (regcache, MIPS_SP_REGNUM, sp);

  /* Return adjusted stack pointer.  */
  return sp;
}

static enum return_value_convention
mips_n32n64_return_value (struct gdbarch *gdbarch, struct value *function,
			  struct type *type, struct regcache *regcache,
			  gdb_byte *readbuf, const gdb_byte *writebuf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* From MIPSpro N32 ABI Handbook, Document Number: 007-2816-004

     Function results are returned in $2 (and $3 if needed), or $f0 (and $f2
     if needed), as appropriate for the type.  Composite results (struct,
     union, or array) are returned in $2/$f0 and $3/$f2 according to the
     following rules:

     * A struct with only one or two floating point fields is returned in $f0
     (and $f2 if necessary).  This is a generalization of the Fortran COMPLEX
     case.

     * Any other composite results of at most 128 bits are returned in
     $2 (first 64 bits) and $3 (remainder, if necessary).

     * Larger composite results are handled by converting the function to a
     procedure with an implicit first parameter, which is a pointer to an area
     reserved by the caller to receive the result.  [The o32-bit ABI requires
     that all composite results be handled by conversion to implicit first
     parameters.  The MIPS/SGI Fortran implementation has always made a
     specific exception to return COMPLEX results in the floating point
     registers.]  */

  if (TYPE_LENGTH (type) > 2 * MIPS64_REGSIZE)
    return RETURN_VALUE_STRUCT_CONVENTION;
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && TYPE_LENGTH (type) == 16
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A 128-bit floating-point value fills both $f0 and $f2.  The
	 two registers are used in the same as memory order, so the
	 eight bytes with the lower memory address are in $f0.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $f0 and $f2\n");
      mips_xfer_register (gdbarch, regcache,
			  (gdbarch_num_regs (gdbarch)
			   + mips_regnum (gdbarch)->fp0),
			  8, gdbarch_byte_order (gdbarch),
			  readbuf, writebuf, 0);
      mips_xfer_register (gdbarch, regcache,
			  (gdbarch_num_regs (gdbarch)
			   + mips_regnum (gdbarch)->fp0 + 2),
			  8, gdbarch_byte_order (gdbarch),
			  readbuf ? readbuf + 8 : readbuf,
			  writebuf ? writebuf + 8 : writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A single or double floating-point value that fits in FP0.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $fp0\n");
      mips_xfer_register (gdbarch, regcache,
			  (gdbarch_num_regs (gdbarch)
			   + mips_regnum (gdbarch)->fp0),
			  TYPE_LENGTH (type),
			  gdbarch_byte_order (gdbarch),
			  readbuf, writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   && TYPE_NFIELDS (type) <= 2
	   && TYPE_NFIELDS (type) >= 1
	   && ((TYPE_NFIELDS (type) == 1
		&& (TYPE_CODE (check_typedef (TYPE_FIELD_TYPE (type, 0)))
		    == TYPE_CODE_FLT))
	       || (TYPE_NFIELDS (type) == 2
		   && (TYPE_CODE (check_typedef (TYPE_FIELD_TYPE (type, 0)))
		       == TYPE_CODE_FLT)
		   && (TYPE_CODE (check_typedef (TYPE_FIELD_TYPE (type, 1)))
		       == TYPE_CODE_FLT))))
    {
      /* A struct that contains one or two floats.  Each value is part
         in the least significant part of their floating point
         register (or GPR, for soft float).  */
      int regnum;
      int field;
      for (field = 0, regnum = (tdep->mips_fpu_type != MIPS_FPU_NONE
				? mips_regnum (gdbarch)->fp0
				: MIPS_V0_REGNUM);
	   field < TYPE_NFIELDS (type); field++, regnum += 2)
	{
	  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])
			/ TARGET_CHAR_BIT);
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return float struct+%d\n",
				offset);
	  if (TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)) == 16)
	    {
	      /* A 16-byte long double field goes in two consecutive
		 registers.  */
	      mips_xfer_register (gdbarch, regcache,
				  gdbarch_num_regs (gdbarch) + regnum,
				  8,
				  gdbarch_byte_order (gdbarch),
				  readbuf, writebuf, offset);
	      mips_xfer_register (gdbarch, regcache,
				  gdbarch_num_regs (gdbarch) + regnum + 1,
				  8,
				  gdbarch_byte_order (gdbarch),
				  readbuf, writebuf, offset + 8);
	    }
	  else
	    mips_xfer_register (gdbarch, regcache,
				gdbarch_num_regs (gdbarch) + regnum,
				TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
				gdbarch_byte_order (gdbarch),
				readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (type) == TYPE_CODE_UNION
	   || TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      /* A composite type.  Extract the left justified value,
         regardless of the byte order.  I.e. DO NOT USE
         mips_xfer_lower.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = MIPS_V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += register_size (gdbarch, regnum), regnum++)
	{
	  int xfer = register_size (gdbarch, regnum);
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return struct+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (gdbarch, regcache,
			      gdbarch_num_regs (gdbarch) + regnum,
			      xfer, BFD_ENDIAN_UNKNOWN, readbuf, writebuf,
			      offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else
    {
      /* A scalar extract each part but least-significant-byte
         justified.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = MIPS_V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += register_size (gdbarch, regnum), regnum++)
	{
	  int xfer = register_size (gdbarch, regnum);
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return scalar+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (gdbarch, regcache,
			      gdbarch_num_regs (gdbarch) + regnum,
			      xfer, gdbarch_byte_order (gdbarch),
			      readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
}

/* Which registers to use for passing floating-point values between
   function calls, one of floating-point, general and both kinds of
   registers.  O32 and O64 use different register kinds for standard
   MIPS and MIPS16 code; to make the handling of cases where we may
   not know what kind of code is being used (e.g. no debug information)
   easier we sometimes use both kinds.  */

enum mips_fval_reg
{
  mips_fval_fpr,
  mips_fval_gpr,
  mips_fval_both
};

/* O32 ABI stuff.  */

static CORE_ADDR
mips_o32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
			  struct regcache *regcache, CORE_ADDR bp_addr,
			  int nargs, struct value **args, CORE_ADDR sp,
			  int struct_return, CORE_ADDR struct_addr)
{
  int argreg;
  int float_argreg;
  int argnum;
  int len = 0;
  int stack_offset = 0;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR func_addr = find_function_addr (function, NULL);

  /* For shared libraries, "t9" needs to point at the function
     address.  */
  regcache_cooked_write_signed (regcache, MIPS_T9_REGNUM, func_addr);

  /* Set the return address register to point to the entry point of
     the program, where a breakpoint lies in wait.  */
  regcache_cooked_write_signed (regcache, MIPS_RA_REGNUM, bp_addr);

  /* First ensure that the stack and structure return address (if any)
     are properly aligned.  The stack has to be at least 64-bit
     aligned even on 32-bit machines, because doubles must be 64-bit
     aligned.  For n32 and n64, stack frames need to be 128-bit
     aligned, so we round to this widest known alignment.  */

  sp = align_down (sp, 16);
  struct_addr = align_down (struct_addr, 16);

  /* Now make space on the stack for the args.  */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      struct type *arg_type = check_typedef (value_type (args[argnum]));

      /* Align to double-word if necessary.  */
      if (mips_type_needs_double_align (arg_type))
	len = align_up (len, MIPS32_REGSIZE * 2);
      /* Allocate space on the stack.  */
      len += align_up (TYPE_LENGTH (arg_type), MIPS32_REGSIZE);
    }
  sp -= align_up (len, 16);

  if (mips_debug)
    fprintf_unfiltered (gdb_stdlog,
			"mips_o32_push_dummy_call: sp=%s allocated %ld\n",
			paddress (gdbarch, sp), (long) align_up (len, 16));

  /* Initialize the integer and float register pointers.  */
  argreg = MIPS_A0_REGNUM;
  float_argreg = mips_fpa0_regnum (gdbarch);

  /* The struct_return pointer occupies the first parameter-passing reg.  */
  if (struct_return)
    {
      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "mips_o32_push_dummy_call: "
			    "struct_return reg=%d %s\n",
			    argreg, paddress (gdbarch, struct_addr));
      regcache_cooked_write_unsigned (regcache, argreg++, struct_addr);
      stack_offset += MIPS32_REGSIZE;
    }

  /* Now load as many as possible of the first arguments into
     registers, and push the rest onto the stack.  Loop thru args
     from first to last.  */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      const gdb_byte *val;
      struct value *arg = args[argnum];
      struct type *arg_type = check_typedef (value_type (arg));
      int len = TYPE_LENGTH (arg_type);
      enum type_code typecode = TYPE_CODE (arg_type);

      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "mips_o32_push_dummy_call: %d len=%d type=%d",
			    argnum + 1, len, (int) typecode);

      val = value_contents (arg);

      /* 32-bit ABIs always start floating point arguments in an
         even-numbered floating point register.  Round the FP register
         up before the check to see if there are any FP registers
         left.  O32 targets also pass the FP in the integer registers
         so also round up normal registers.  */
      if (fp_register_arg_p (gdbarch, typecode, arg_type))
	{
	  if ((float_argreg & 1))
	    float_argreg++;
	}

      /* Floating point arguments passed in registers have to be
         treated specially.  On 32-bit architectures, doubles are
         passed in register pairs; the even FP register gets the
         low word, and the odd FP register gets the high word.
         On O32, the first two floating point arguments are also
         copied to general registers, following their memory order,
         because MIPS16 functions don't use float registers for
         arguments.  This duplication of arguments in general
         registers can't hurt non-MIPS16 functions, because those
         registers are normally skipped.  */

      if (fp_register_arg_p (gdbarch, typecode, arg_type)
	  && float_argreg <= MIPS_LAST_FP_ARG_REGNUM (gdbarch))
	{
	  if (register_size (gdbarch, float_argreg) < 8 && len == 8)
	    {
	      int freg_offset = gdbarch_byte_order (gdbarch)
				== BFD_ENDIAN_BIG ? 1 : 0;
	      unsigned long regval;

	      /* First word.  */
	      regval = extract_unsigned_integer (val, 4, byte_order);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg + freg_offset,
				    phex (regval, 4));
	      regcache_cooked_write_unsigned (regcache,
					      float_argreg++ + freg_offset,
					      regval);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				    argreg, phex (regval, 4));
	      regcache_cooked_write_unsigned (regcache, argreg++, regval);

	      /* Second word.  */
	      regval = extract_unsigned_integer (val + 4, 4, byte_order);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg - freg_offset,
				    phex (regval, 4));
	      regcache_cooked_write_unsigned (regcache,
					      float_argreg++ - freg_offset,
					      regval);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				    argreg, phex (regval, 4));
	      regcache_cooked_write_unsigned (regcache, argreg++, regval);
	    }
	  else
	    {
	      /* This is a floating point value that fits entirely
	         in a single register.  */
	      /* On 32 bit ABI's the float_argreg is further adjusted
	         above to ensure that it is even register aligned.  */
	      LONGEST regval = extract_unsigned_integer (val, len, byte_order);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg, phex (regval, len));
	      regcache_cooked_write_unsigned (regcache,
					      float_argreg++, regval);
	      /* Although two FP registers are reserved for each
		 argument, only one corresponding integer register is
		 reserved.  */
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				    argreg, phex (regval, len));
	      regcache_cooked_write_unsigned (regcache, argreg++, regval);
	    }
	  /* Reserve space for the FP register.  */
	  stack_offset += align_up (len, MIPS32_REGSIZE);
	}
      else
	{
	  /* Copy the argument to general registers or the stack in
	     register-sized pieces.  Large arguments are split between
	     registers and stack.  */
	  /* Note: structs whose size is not a multiple of MIPS32_REGSIZE
	     are treated specially: Irix cc passes
	     them in registers where gcc sometimes puts them on the
	     stack.  For maximum compatibility, we will put them in
	     both places.  */
	  int odd_sized_struct = (len > MIPS32_REGSIZE
				  && len % MIPS32_REGSIZE != 0);
	  /* Structures should be aligned to eight bytes (even arg registers)
	     on MIPS_ABI_O32, if their first member has double precision.  */
	  if (mips_type_needs_double_align (arg_type))
	    {
	      if ((argreg & 1))
		{
		  argreg++;
		  stack_offset += MIPS32_REGSIZE;
		}
	    }
	  while (len > 0)
	    {
	      /* Remember if the argument was written to the stack.  */
	      int stack_used_p = 0;
	      int partial_len = (len < MIPS32_REGSIZE ? len : MIPS32_REGSIZE);

	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " -- partial=%d",
				    partial_len);

	      /* Write this portion of the argument to the stack.  */
	      if (argreg > MIPS_LAST_ARG_REGNUM (gdbarch)
		  || odd_sized_struct)
		{
		  /* Should shorter than int integer values be
		     promoted to int before being stored?  */
		  int longword_offset = 0;
		  CORE_ADDR addr;
		  stack_used_p = 1;

		  if (mips_debug)
		    {
		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=%s",
					  paddress (gdbarch, stack_offset));
		      fprintf_unfiltered (gdb_stdlog, " longword_offset=%s",
					  paddress (gdbarch, longword_offset));
		    }

		  addr = sp + stack_offset + longword_offset;

		  if (mips_debug)
		    {
		      int i;
		      fprintf_unfiltered (gdb_stdlog, " @@%s ",
					  paddress (gdbarch, addr));
		      for (i = 0; i < partial_len; i++)
			{
			  fprintf_unfiltered (gdb_stdlog, "%02x",
					      val[i] & 0xff);
			}
		    }
		  write_memory (addr, val, partial_len);
		}

	      /* Note!!! This is NOT an else clause.  Odd sized
	         structs may go thru BOTH paths.  */
	      /* Write this portion of the argument to a general
	         purpose register.  */
	      if (argreg <= MIPS_LAST_ARG_REGNUM (gdbarch))
		{
		  LONGEST regval = extract_signed_integer (val, partial_len,
							   byte_order);
		  /* Value may need to be sign extended, because
		     mips_isa_regsize() != mips_abi_regsize().  */

		  /* A non-floating-point argument being passed in a
		     general register.  If a struct or union, and if
		     the remaining length is smaller than the register
		     size, we have to adjust the register value on
		     big endian targets.

		     It does not seem to be necessary to do the
		     same for integral types.

		     Also don't do this adjustment on O64 binaries.

		     cagney/2001-07-23: gdb/179: Also, GCC, when
		     outputting LE O32 with sizeof (struct) <
		     mips_abi_regsize(), generates a left shift
		     as part of storing the argument in a register
		     (the left shift isn't generated when
		     sizeof (struct) >= mips_abi_regsize()).  Since
		     it is quite possible that this is GCC
		     contradicting the LE/O32 ABI, GDB has not been
		     adjusted to accommodate this.  Either someone
		     needs to demonstrate that the LE/O32 ABI
		     specifies such a left shift OR this new ABI gets
		     identified as such and GDB gets tweaked
		     accordingly.  */

		  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG
		      && partial_len < MIPS32_REGSIZE
		      && (typecode == TYPE_CODE_STRUCT
			  || typecode == TYPE_CODE_UNION))
		    regval <<= ((MIPS32_REGSIZE - partial_len)
				* TARGET_CHAR_BIT);

		  if (mips_debug)
		    fprintf_filtered (gdb_stdlog, " - reg=%d val=%s",
				      argreg,
				      phex (regval, MIPS32_REGSIZE));
		  regcache_cooked_write_unsigned (regcache, argreg, regval);
		  argreg++;

		  /* Prevent subsequent floating point arguments from
		     being passed in floating point registers.  */
		  float_argreg = MIPS_LAST_FP_ARG_REGNUM (gdbarch) + 1;
		}

	      len -= partial_len;
	      val += partial_len;

	      /* Compute the offset into the stack at which we will
	         copy the next parameter.

	         In older ABIs, the caller reserved space for
	         registers that contained arguments.  This was loosely
	         refered to as their "home".  Consequently, space is
	         always allocated.  */

	      stack_offset += align_up (partial_len, MIPS32_REGSIZE);
	    }
	}
      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog, "\n");
    }

  regcache_cooked_write_signed (regcache, MIPS_SP_REGNUM, sp);

  /* Return adjusted stack pointer.  */
  return sp;
}

static enum return_value_convention
mips_o32_return_value (struct gdbarch *gdbarch, struct value *function,
		       struct type *type, struct regcache *regcache,
		       gdb_byte *readbuf, const gdb_byte *writebuf)
{
  CORE_ADDR func_addr = function ? find_function_addr (function, NULL) : 0;
  int mips16 = mips_pc_is_mips16 (gdbarch, func_addr);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum mips_fval_reg fval_reg;

  fval_reg = readbuf ? mips16 ? mips_fval_gpr : mips_fval_fpr : mips_fval_both;
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      || TYPE_CODE (type) == TYPE_CODE_UNION
      || TYPE_CODE (type) == TYPE_CODE_ARRAY)
    return RETURN_VALUE_STRUCT_CONVENTION;
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && TYPE_LENGTH (type) == 4 && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A single-precision floating-point value.  If reading in or copying,
         then we get it from/put it to FP0 for standard MIPS code or GPR2
         for MIPS16 code.  If writing out only, then we put it to both FP0
         and GPR2.  We do not support reading in with no function known, if
         this safety check ever triggers, then we'll have to try harder.  */
      gdb_assert (function || !readbuf);
      if (mips_debug)
	switch (fval_reg)
	  {
	  case mips_fval_fpr:
	    fprintf_unfiltered (gdb_stderr, "Return float in $fp0\n");
	    break;
	  case mips_fval_gpr:
	    fprintf_unfiltered (gdb_stderr, "Return float in $2\n");
	    break;
	  case mips_fval_both:
	    fprintf_unfiltered (gdb_stderr, "Return float in $fp0 and $2\n");
	    break;
	  }
      if (fval_reg != mips_fval_gpr)
	mips_xfer_register (gdbarch, regcache,
			    (gdbarch_num_regs (gdbarch)
			     + mips_regnum (gdbarch)->fp0),
			    TYPE_LENGTH (type),
			    gdbarch_byte_order (gdbarch),
			    readbuf, writebuf, 0);
      if (fval_reg != mips_fval_fpr)
	mips_xfer_register (gdbarch, regcache,
			    gdbarch_num_regs (gdbarch) + 2,
			    TYPE_LENGTH (type),
			    gdbarch_byte_order (gdbarch),
			    readbuf, writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && TYPE_LENGTH (type) == 8 && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A double-precision floating-point value.  If reading in or copying,
         then we get it from/put it to FP1 and FP0 for standard MIPS code or
         GPR2 and GPR3 for MIPS16 code.  If writing out only, then we put it
         to both FP1/FP0 and GPR2/GPR3.  We do not support reading in with
         no function known, if this safety check ever triggers, then we'll
         have to try harder.  */
      gdb_assert (function || !readbuf);
      if (mips_debug)
	switch (fval_reg)
	  {
	  case mips_fval_fpr:
	    fprintf_unfiltered (gdb_stderr, "Return float in $fp1/$fp0\n");
	    break;
	  case mips_fval_gpr:
	    fprintf_unfiltered (gdb_stderr, "Return float in $2/$3\n");
	    break;
	  case mips_fval_both:
	    fprintf_unfiltered (gdb_stderr,
				"Return float in $fp1/$fp0 and $2/$3\n");
	    break;
	  }
      if (fval_reg != mips_fval_gpr)
	{
	  /* The most significant part goes in FP1, and the least significant
	     in FP0.  */
	  switch (gdbarch_byte_order (gdbarch))
	    {
	    case BFD_ENDIAN_LITTLE:
	      mips_xfer_register (gdbarch, regcache,
				  (gdbarch_num_regs (gdbarch)
				   + mips_regnum (gdbarch)->fp0 + 0),
				  4, gdbarch_byte_order (gdbarch),
				  readbuf, writebuf, 0);
	      mips_xfer_register (gdbarch, regcache,
				  (gdbarch_num_regs (gdbarch)
				   + mips_regnum (gdbarch)->fp0 + 1),
				  4, gdbarch_byte_order (gdbarch),
				  readbuf, writebuf, 4);
	      break;
	    case BFD_ENDIAN_BIG:
	      mips_xfer_register (gdbarch, regcache,
				  (gdbarch_num_regs (gdbarch)
				   + mips_regnum (gdbarch)->fp0 + 1),
				  4, gdbarch_byte_order (gdbarch),
				  readbuf, writebuf, 0);
	      mips_xfer_register (gdbarch, regcache,
				  (gdbarch_num_regs (gdbarch)
				   + mips_regnum (gdbarch)->fp0 + 0),
				  4, gdbarch_byte_order (gdbarch),
				  readbuf, writebuf, 4);
	      break;
	    default:
	      internal_error (__FILE__, __LINE__, _("bad switch"));
	    }
	}
      if (fval_reg != mips_fval_fpr)
	{
	  /* The two 32-bit parts are always placed in GPR2 and GPR3
	     following these registers' memory order.  */
	  mips_xfer_register (gdbarch, regcache,
			      gdbarch_num_regs (gdbarch) + 2,
			      4, gdbarch_byte_order (gdbarch),
			      readbuf, writebuf, 0);
	  mips_xfer_register (gdbarch, regcache,
			      gdbarch_num_regs (gdbarch) + 3,
			      4, gdbarch_byte_order (gdbarch),
			      readbuf, writebuf, 4);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
#if 0
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   && TYPE_NFIELDS (type) <= 2
	   && TYPE_NFIELDS (type) >= 1
	   && ((TYPE_NFIELDS (type) == 1
		&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		    == TYPE_CODE_FLT))
	       || (TYPE_NFIELDS (type) == 2
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		       == TYPE_CODE_FLT)
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 1))
		       == TYPE_CODE_FLT)))
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A struct that contains one or two floats.  Each value is part
         in the least significant part of their floating point
         register..  */
      gdb_byte reg[MAX_REGISTER_SIZE];
      int regnum;
      int field;
      for (field = 0, regnum = mips_regnum (gdbarch)->fp0;
	   field < TYPE_NFIELDS (type); field++, regnum += 2)
	{
	  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])
			/ TARGET_CHAR_BIT);
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return float struct+%d\n",
				offset);
	  mips_xfer_register (gdbarch, regcache,
			      gdbarch_num_regs (gdbarch) + regnum,
			      TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
			      gdbarch_byte_order (gdbarch),
			      readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
#endif
#if 0
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (type) == TYPE_CODE_UNION)
    {
      /* A structure or union.  Extract the left justified value,
         regardless of the byte order.  I.e. DO NOT USE
         mips_xfer_lower.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = MIPS_V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += register_size (gdbarch, regnum), regnum++)
	{
	  int xfer = register_size (gdbarch, regnum);
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return struct+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (gdbarch, regcache,
			      gdbarch_num_regs (gdbarch) + regnum, xfer,
			      BFD_ENDIAN_UNKNOWN, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
#endif
  else
    {
      /* A scalar extract each part but least-significant-byte
         justified.  o32 thinks registers are 4 byte, regardless of
         the ISA.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = MIPS_V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += MIPS32_REGSIZE, regnum++)
	{
	  int xfer = MIPS32_REGSIZE;
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return scalar+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (gdbarch, regcache,
			      gdbarch_num_regs (gdbarch) + regnum, xfer,
			      gdbarch_byte_order (gdbarch),
			      readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
}

/* O64 ABI.  This is a hacked up kind of 64-bit version of the o32
   ABI.  */

static CORE_ADDR
mips_o64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
			  struct regcache *regcache, CORE_ADDR bp_addr,
			  int nargs,
			  struct value **args, CORE_ADDR sp,
			  int struct_return, CORE_ADDR struct_addr)
{
  int argreg;
  int float_argreg;
  int argnum;
  int len = 0;
  int stack_offset = 0;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR func_addr = find_function_addr (function, NULL);

  /* For shared libraries, "t9" needs to point at the function
     address.  */
  regcache_cooked_write_signed (regcache, MIPS_T9_REGNUM, func_addr);

  /* Set the return address register to point to the entry point of
     the program, where a breakpoint lies in wait.  */
  regcache_cooked_write_signed (regcache, MIPS_RA_REGNUM, bp_addr);

  /* First ensure that the stack and structure return address (if any)
     are properly aligned.  The stack has to be at least 64-bit
     aligned even on 32-bit machines, because doubles must be 64-bit
     aligned.  For n32 and n64, stack frames need to be 128-bit
     aligned, so we round to this widest known alignment.  */

  sp = align_down (sp, 16);
  struct_addr = align_down (struct_addr, 16);

  /* Now make space on the stack for the args.  */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      struct type *arg_type = check_typedef (value_type (args[argnum]));

      /* Allocate space on the stack.  */
      len += align_up (TYPE_LENGTH (arg_type), MIPS64_REGSIZE);
    }
  sp -= align_up (len, 16);

  if (mips_debug)
    fprintf_unfiltered (gdb_stdlog,
			"mips_o64_push_dummy_call: sp=%s allocated %ld\n",
			paddress (gdbarch, sp), (long) align_up (len, 16));

  /* Initialize the integer and float register pointers.  */
  argreg = MIPS_A0_REGNUM;
  float_argreg = mips_fpa0_regnum (gdbarch);

  /* The struct_return pointer occupies the first parameter-passing reg.  */
  if (struct_return)
    {
      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "mips_o64_push_dummy_call: "
			    "struct_return reg=%d %s\n",
			    argreg, paddress (gdbarch, struct_addr));
      regcache_cooked_write_unsigned (regcache, argreg++, struct_addr);
      stack_offset += MIPS64_REGSIZE;
    }

  /* Now load as many as possible of the first arguments into
     registers, and push the rest onto the stack.  Loop thru args
     from first to last.  */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      const gdb_byte *val;
      gdb_byte valbuf[MAX_REGISTER_SIZE];
      struct value *arg = args[argnum];
      struct type *arg_type = check_typedef (value_type (arg));
      int len = TYPE_LENGTH (arg_type);
      enum type_code typecode = TYPE_CODE (arg_type);

      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "mips_o64_push_dummy_call: %d len=%d type=%d",
			    argnum + 1, len, (int) typecode);

      val = value_contents (arg);

      /* Function pointer arguments to mips16 code need to be made into
         mips16 pointers.  */
      if (typecode == TYPE_CODE_PTR
          && TYPE_CODE (TYPE_TARGET_TYPE (arg_type)) == TYPE_CODE_FUNC)
	{
	  CORE_ADDR addr = extract_signed_integer (value_contents (arg),
						   len, byte_order);
	  if (!mips_pc_is_mips (addr))
	    {
	      store_signed_integer (valbuf, len, byte_order, 
				    make_compact_addr (addr));
	      val = valbuf;
	    }
	}

      /* Floating point arguments passed in registers have to be
         treated specially.  On 32-bit architectures, doubles are
         passed in register pairs; the even FP register gets the
         low word, and the odd FP register gets the high word.
         On O64, the first two floating point arguments are also
         copied to general registers, because MIPS16 functions
         don't use float registers for arguments.  This duplication
         of arguments in general registers can't hurt non-MIPS16
         functions because those registers are normally skipped.  */

      if (fp_register_arg_p (gdbarch, typecode, arg_type)
	  && float_argreg <= MIPS_LAST_FP_ARG_REGNUM (gdbarch))
	{
	  LONGEST regval = extract_unsigned_integer (val, len, byte_order);
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				float_argreg, phex (regval, len));
	  regcache_cooked_write_unsigned (regcache, float_argreg++, regval);
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				argreg, phex (regval, len));
	  regcache_cooked_write_unsigned (regcache, argreg, regval);
	  argreg++;
	  /* Reserve space for the FP register.  */
	  stack_offset += align_up (len, MIPS64_REGSIZE);
	}
      else
	{
	  /* Copy the argument to general registers or the stack in
	     register-sized pieces.  Large arguments are split between
	     registers and stack.  */
	  /* Note: structs whose size is not a multiple of MIPS64_REGSIZE
	     are treated specially: Irix cc passes them in registers
	     where gcc sometimes puts them on the stack.  For maximum
	     compatibility, we will put them in both places.  */
	  int odd_sized_struct = (len > MIPS64_REGSIZE
				  && len % MIPS64_REGSIZE != 0);
	  while (len > 0)
	    {
	      /* Remember if the argument was written to the stack.  */
	      int stack_used_p = 0;
	      int partial_len = (len < MIPS64_REGSIZE ? len : MIPS64_REGSIZE);

	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " -- partial=%d",
				    partial_len);

	      /* Write this portion of the argument to the stack.  */
	      if (argreg > MIPS_LAST_ARG_REGNUM (gdbarch)
		  || odd_sized_struct)
		{
		  /* Should shorter than int integer values be
		     promoted to int before being stored?  */
		  int longword_offset = 0;
		  CORE_ADDR addr;
		  stack_used_p = 1;
		  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
		    {
		      if ((typecode == TYPE_CODE_INT
			   || typecode == TYPE_CODE_PTR
			   || typecode == TYPE_CODE_FLT)
			  && len <= 4)
			longword_offset = MIPS64_REGSIZE - len;
		    }

		  if (mips_debug)
		    {
		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=%s",
					  paddress (gdbarch, stack_offset));
		      fprintf_unfiltered (gdb_stdlog, " longword_offset=%s",
					  paddress (gdbarch, longword_offset));
		    }

		  addr = sp + stack_offset + longword_offset;

		  if (mips_debug)
		    {
		      int i;
		      fprintf_unfiltered (gdb_stdlog, " @@%s ",
					  paddress (gdbarch, addr));
		      for (i = 0; i < partial_len; i++)
			{
			  fprintf_unfiltered (gdb_stdlog, "%02x",
					      val[i] & 0xff);
			}
		    }
		  write_memory (addr, val, partial_len);
		}

	      /* Note!!! This is NOT an else clause.  Odd sized
	         structs may go thru BOTH paths.  */
	      /* Write this portion of the argument to a general
	         purpose register.  */
	      if (argreg <= MIPS_LAST_ARG_REGNUM (gdbarch))
		{
		  LONGEST regval = extract_signed_integer (val, partial_len,
							   byte_order);
		  /* Value may need to be sign extended, because
		     mips_isa_regsize() != mips_abi_regsize().  */

		  /* A non-floating-point argument being passed in a
		     general register.  If a struct or union, and if
		     the remaining length is smaller than the register
		     size, we have to adjust the register value on
		     big endian targets.

		     It does not seem to be necessary to do the
		     same for integral types.  */

		  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG
		      && partial_len < MIPS64_REGSIZE
		      && (typecode == TYPE_CODE_STRUCT
			  || typecode == TYPE_CODE_UNION))
		    regval <<= ((MIPS64_REGSIZE - partial_len)
				* TARGET_CHAR_BIT);

		  if (mips_debug)
		    fprintf_filtered (gdb_stdlog, " - reg=%d val=%s",
				      argreg,
				      phex (regval, MIPS64_REGSIZE));
		  regcache_cooked_write_unsigned (regcache, argreg, regval);
		  argreg++;

		  /* Prevent subsequent floating point arguments from
		     being passed in floating point registers.  */
		  float_argreg = MIPS_LAST_FP_ARG_REGNUM (gdbarch) + 1;
		}

	      len -= partial_len;
	      val += partial_len;

	      /* Compute the offset into the stack at which we will
	         copy the next parameter.

	         In older ABIs, the caller reserved space for
	         registers that contained arguments.  This was loosely
	         refered to as their "home".  Consequently, space is
	         always allocated.  */

	      stack_offset += align_up (partial_len, MIPS64_REGSIZE);
	    }
	}
      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog, "\n");
    }

  regcache_cooked_write_signed (regcache, MIPS_SP_REGNUM, sp);

  /* Return adjusted stack pointer.  */
  return sp;
}

static enum return_value_convention
mips_o64_return_value (struct gdbarch *gdbarch, struct value *function,
		       struct type *type, struct regcache *regcache,
		       gdb_byte *readbuf, const gdb_byte *writebuf)
{
  CORE_ADDR func_addr = function ? find_function_addr (function, NULL) : 0;
  int mips16 = mips_pc_is_mips16 (gdbarch, func_addr);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum mips_fval_reg fval_reg;

  fval_reg = readbuf ? mips16 ? mips_fval_gpr : mips_fval_fpr : mips_fval_both;
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      || TYPE_CODE (type) == TYPE_CODE_UNION
      || TYPE_CODE (type) == TYPE_CODE_ARRAY)
    return RETURN_VALUE_STRUCT_CONVENTION;
  else if (fp_register_arg_p (gdbarch, TYPE_CODE (type), type))
    {
      /* A floating-point value.  If reading in or copying, then we get it
         from/put it to FP0 for standard MIPS code or GPR2 for MIPS16 code.
         If writing out only, then we put it to both FP0 and GPR2.  We do
         not support reading in with no function known, if this safety
         check ever triggers, then we'll have to try harder.  */
      gdb_assert (function || !readbuf);
      if (mips_debug)
	switch (fval_reg)
	  {
	  case mips_fval_fpr:
	    fprintf_unfiltered (gdb_stderr, "Return float in $fp0\n");
	    break;
	  case mips_fval_gpr:
	    fprintf_unfiltered (gdb_stderr, "Return float in $2\n");
	    break;
	  case mips_fval_both:
	    fprintf_unfiltered (gdb_stderr, "Return float in $fp0 and $2\n");
	    break;
	  }
      if (fval_reg != mips_fval_gpr)
	mips_xfer_register (gdbarch, regcache,
			    (gdbarch_num_regs (gdbarch)
			     + mips_regnum (gdbarch)->fp0),
			    TYPE_LENGTH (type),
			    gdbarch_byte_order (gdbarch),
			    readbuf, writebuf, 0);
      if (fval_reg != mips_fval_fpr)
	mips_xfer_register (gdbarch, regcache,
			    gdbarch_num_regs (gdbarch) + 2,
			    TYPE_LENGTH (type),
			    gdbarch_byte_order (gdbarch),
			    readbuf, writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else
    {
      /* A scalar extract each part but least-significant-byte
         justified.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = MIPS_V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += MIPS64_REGSIZE, regnum++)
	{
	  int xfer = MIPS64_REGSIZE;
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return scalar+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (gdbarch, regcache,
			      gdbarch_num_regs (gdbarch) + regnum,
			      xfer, gdbarch_byte_order (gdbarch),
			      readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
}

/* Floating point register management.

   Background: MIPS1 & 2 fp registers are 32 bits wide.  To support
   64bit operations, these early MIPS cpus treat fp register pairs
   (f0,f1) as a single register (d0).  Later MIPS cpu's have 64 bit fp
   registers and offer a compatibility mode that emulates the MIPS2 fp
   model.  When operating in MIPS2 fp compat mode, later cpu's split
   double precision floats into two 32-bit chunks and store them in
   consecutive fp regs.  To display 64-bit floats stored in this
   fashion, we have to combine 32 bits from f0 and 32 bits from f1.
   Throw in user-configurable endianness and you have a real mess.

   The way this works is:
     - If we are in 32-bit mode or on a 32-bit processor, then a 64-bit
       double-precision value will be split across two logical registers.
       The lower-numbered logical register will hold the low-order bits,
       regardless of the processor's endianness.
     - If we are on a 64-bit processor, and we are looking for a
       single-precision value, it will be in the low ordered bits
       of a 64-bit GPR (after mfc1, for example) or a 64-bit register
       save slot in memory.
     - If we are in 64-bit mode, everything is straightforward.

   Note that this code only deals with "live" registers at the top of the
   stack.  We will attempt to deal with saved registers later, when
   the raw/cooked register interface is in place.  (We need a general
   interface that can deal with dynamic saved register sizes -- fp
   regs could be 32 bits wide in one frame and 64 on the frame above
   and below).  */

/* Copy a 32-bit single-precision value from the current frame
   into rare_buffer.  */

static void
mips_read_fp_register_single (struct frame_info *frame, int regno,
			      gdb_byte *rare_buffer)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int raw_size = register_size (gdbarch, regno);
  gdb_byte *raw_buffer = alloca (raw_size);

  if (!deprecated_frame_register_read (frame, regno, raw_buffer))
    error (_("can't read register %d (%s)"),
	   regno, gdbarch_register_name (gdbarch, regno));
  if (raw_size == 8)
    {
      /* We have a 64-bit value for this register.  Find the low-order
         32 bits.  */
      int offset;

      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	offset = 4;
      else
	offset = 0;

      memcpy (rare_buffer, raw_buffer + offset, 4);
    }
  else
    {
      memcpy (rare_buffer, raw_buffer, 4);
    }
}

/* Copy a 64-bit double-precision value from the current frame into
   rare_buffer.  This may include getting half of it from the next
   register.  */

static void
mips_read_fp_register_double (struct frame_info *frame, int regno,
			      gdb_byte *rare_buffer)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int raw_size = register_size (gdbarch, regno);

  if (raw_size == 8 && !mips2_fp_compat (frame))
    {
      /* We have a 64-bit value for this register, and we should use
         all 64 bits.  */
      if (!deprecated_frame_register_read (frame, regno, rare_buffer))
	error (_("can't read register %d (%s)"),
	       regno, gdbarch_register_name (gdbarch, regno));
    }
  else
    {
      int rawnum = regno % gdbarch_num_regs (gdbarch);

      if ((rawnum - mips_regnum (gdbarch)->fp0) & 1)
	internal_error (__FILE__, __LINE__,
			_("mips_read_fp_register_double: bad access to "
			"odd-numbered FP register"));

      /* mips_read_fp_register_single will find the correct 32 bits from
         each register.  */
      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	{
	  mips_read_fp_register_single (frame, regno, rare_buffer + 4);
	  mips_read_fp_register_single (frame, regno + 1, rare_buffer);
	}
      else
	{
	  mips_read_fp_register_single (frame, regno, rare_buffer);
	  mips_read_fp_register_single (frame, regno + 1, rare_buffer + 4);
	}
    }
}

static void
mips_print_fp_register (struct ui_file *file, struct frame_info *frame,
			int regnum)
{				/* Do values for FP (float) regs.  */
  struct gdbarch *gdbarch = get_frame_arch (frame);
  gdb_byte *raw_buffer;
  double doub, flt1;	/* Doubles extracted from raw hex data.  */
  int inv1, inv2;

  raw_buffer = alloca (2 * register_size (gdbarch,
					  mips_regnum (gdbarch)->fp0));

  fprintf_filtered (file, "%s:", gdbarch_register_name (gdbarch, regnum));
  fprintf_filtered (file, "%*s",
		    4 - (int) strlen (gdbarch_register_name (gdbarch, regnum)),
		    "");

  if (register_size (gdbarch, regnum) == 4 || mips2_fp_compat (frame))
    {
      struct value_print_options opts;

      /* 4-byte registers: Print hex and floating.  Also print even
         numbered registers as doubles.  */
      mips_read_fp_register_single (frame, regnum, raw_buffer);
      flt1 = unpack_double (builtin_type (gdbarch)->builtin_float,
			    raw_buffer, &inv1);

      get_formatted_print_options (&opts, 'x');
      print_scalar_formatted (raw_buffer,
			      builtin_type (gdbarch)->builtin_uint32,
			      &opts, 'w', file);

      fprintf_filtered (file, " flt: ");
      if (inv1)
	fprintf_filtered (file, " <invalid float> ");
      else
	fprintf_filtered (file, "%-17.9g", flt1);

      if ((regnum - gdbarch_num_regs (gdbarch)) % 2 == 0)
	{
	  mips_read_fp_register_double (frame, regnum, raw_buffer);
	  doub = unpack_double (builtin_type (gdbarch)->builtin_double,
				raw_buffer, &inv2);

	  fprintf_filtered (file, " dbl: ");
	  if (inv2)
	    fprintf_filtered (file, "<invalid double>");
	  else
	    fprintf_filtered (file, "%-24.17g", doub);
	}
    }
  else
    {
      struct value_print_options opts;

      /* Eight byte registers: print each one as hex, float and double.  */
      mips_read_fp_register_single (frame, regnum, raw_buffer);
      flt1 = unpack_double (builtin_type (gdbarch)->builtin_float,
			    raw_buffer, &inv1);

      mips_read_fp_register_double (frame, regnum, raw_buffer);
      doub = unpack_double (builtin_type (gdbarch)->builtin_double,
			    raw_buffer, &inv2);

      get_formatted_print_options (&opts, 'x');
      print_scalar_formatted (raw_buffer,
			      builtin_type (gdbarch)->builtin_uint64,
			      &opts, 'g', file);

      fprintf_filtered (file, " flt: ");
      if (inv1)
	fprintf_filtered (file, "<invalid float>");
      else
	fprintf_filtered (file, "%-17.9g", flt1);

      fprintf_filtered (file, " dbl: ");
      if (inv2)
	fprintf_filtered (file, "<invalid double>");
      else
	fprintf_filtered (file, "%-24.17g", doub);
    }
}

static void
mips_print_register (struct ui_file *file, struct frame_info *frame,
		     int regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct value_print_options opts;
  struct value *val;

  if (mips_float_register_p (gdbarch, regnum))
    {
      mips_print_fp_register (file, frame, regnum);
      return;
    }

  val = get_frame_register_value (frame, regnum);
  if (value_optimized_out (val))
    {
      fprintf_filtered (file, "%s: [Invalid]",
			gdbarch_register_name (gdbarch, regnum));
      return;
    }

  fputs_filtered (gdbarch_register_name (gdbarch, regnum), file);

  /* The problem with printing numeric register names (r26, etc.) is that
     the user can't use them on input.  Probably the best solution is to
     fix it so that either the numeric or the funky (a2, etc.) names
     are accepted on input.  */
  if (regnum < MIPS_NUMREGS)
    fprintf_filtered (file, "(r%d): ", regnum);
  else
    fprintf_filtered (file, ": ");

  get_formatted_print_options (&opts, 'x');
  val_print_scalar_formatted (value_type (val),
			      value_contents_for_printing (val),
			      value_embedded_offset (val),
			      val,
			      &opts, 0, file);
}

/* Replacement for generic do_registers_info.
   Print regs in pretty columns.  */

static int
print_fp_register_row (struct ui_file *file, struct frame_info *frame,
		       int regnum)
{
  fprintf_filtered (file, " ");
  mips_print_fp_register (file, frame, regnum);
  fprintf_filtered (file, "\n");
  return regnum + 1;
}


/* Print a row's worth of GP (int) registers, with name labels above.  */

static int
print_gp_register_row (struct ui_file *file, struct frame_info *frame,
		       int start_regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  /* Do values for GP (int) regs.  */
  gdb_byte raw_buffer[MAX_REGISTER_SIZE];
  int ncols = (mips_abi_regsize (gdbarch) == 8 ? 4 : 8);    /* display cols
							       per row.  */
  int col, byte;
  int regnum;

  /* For GP registers, we print a separate row of names above the vals.  */
  for (col = 0, regnum = start_regnum;
       col < ncols && regnum < gdbarch_num_regs (gdbarch)
			       + gdbarch_num_pseudo_regs (gdbarch);
       regnum++)
    {
      if (*gdbarch_register_name (gdbarch, regnum) == '\0')
	continue;		/* unused register */
      if (mips_float_register_p (gdbarch, regnum))
	break;			/* End the row: reached FP register.  */
      /* Large registers are handled separately.  */
      if (register_size (gdbarch, regnum) > mips_abi_regsize (gdbarch))
	{
	  if (col > 0)
	    break;		/* End the row before this register.  */

	  /* Print this register on a row by itself.  */
	  mips_print_register (file, frame, regnum);
	  fprintf_filtered (file, "\n");
	  return regnum + 1;
	}
      if (col == 0)
	fprintf_filtered (file, "     ");
      fprintf_filtered (file,
			mips_abi_regsize (gdbarch) == 8 ? "%17s" : "%9s",
			gdbarch_register_name (gdbarch, regnum));
      col++;
    }

  if (col == 0)
    return regnum;

  /* Print the R0 to R31 names.  */
  if ((start_regnum % gdbarch_num_regs (gdbarch)) < MIPS_NUMREGS)
    fprintf_filtered (file, "\n R%-4d",
		      start_regnum % gdbarch_num_regs (gdbarch));
  else
    fprintf_filtered (file, "\n      ");

  /* Now print the values in hex, 4 or 8 to the row.  */
  for (col = 0, regnum = start_regnum;
       col < ncols && regnum < gdbarch_num_regs (gdbarch)
			       + gdbarch_num_pseudo_regs (gdbarch);
       regnum++)
    {
      if (*gdbarch_register_name (gdbarch, regnum) == '\0')
	continue;		/* unused register */
      if (mips_float_register_p (gdbarch, regnum))
	break;			/* End row: reached FP register.  */
      if (register_size (gdbarch, regnum) > mips_abi_regsize (gdbarch))
	break;			/* End row: large register.  */

      /* OK: get the data in raw format.  */
      if (!deprecated_frame_register_read (frame, regnum, raw_buffer))
	error (_("can't read register %d (%s)"),
	       regnum, gdbarch_register_name (gdbarch, regnum));
      /* pad small registers */
      for (byte = 0;
	   byte < (mips_abi_regsize (gdbarch)
		   - register_size (gdbarch, regnum)); byte++)
	printf_filtered ("  ");
      /* Now print the register value in hex, endian order.  */
      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	for (byte =
	     register_size (gdbarch, regnum) - register_size (gdbarch, regnum);
	     byte < register_size (gdbarch, regnum); byte++)
	  fprintf_filtered (file, "%02x", raw_buffer[byte]);
      else
	for (byte = register_size (gdbarch, regnum) - 1;
	     byte >= 0; byte--)
	  fprintf_filtered (file, "%02x", raw_buffer[byte]);
      fprintf_filtered (file, " ");
      col++;
    }
  if (col > 0)			/* ie. if we actually printed anything...  */
    fprintf_filtered (file, "\n");

  return regnum;
}

/* MIPS_DO_REGISTERS_INFO(): called by "info register" command.  */

static void
mips_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,
			   struct frame_info *frame, int regnum, int all)
{
  if (regnum != -1)		/* Do one specified register.  */
    {
      gdb_assert (regnum >= gdbarch_num_regs (gdbarch));
      if (*(gdbarch_register_name (gdbarch, regnum)) == '\0')
	error (_("Not a valid register for the current processor type"));

      mips_print_register (file, frame, regnum);
      fprintf_filtered (file, "\n");
    }
  else
    /* Do all (or most) registers.  */
    {
      regnum = gdbarch_num_regs (gdbarch);
      while (regnum < gdbarch_num_regs (gdbarch)
		      + gdbarch_num_pseudo_regs (gdbarch))
	{
	  if (mips_float_register_p (gdbarch, regnum))
	    {
	      if (all)		/* True for "INFO ALL-REGISTERS" command.  */
		regnum = print_fp_register_row (file, frame, regnum);
	      else
		regnum += MIPS_NUMREGS;	/* Skip floating point regs.  */
	    }
	  else
	    regnum = print_gp_register_row (file, frame, regnum);
	}
    }
}

static int
mips_single_step_through_delay (struct gdbarch *gdbarch,
				struct frame_info *frame)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR pc = get_frame_pc (frame);
  struct address_space *aspace;
  enum mips_isa isa;
  ULONGEST insn;
  int status;
  int size;

  if ((mips_pc_is_mips (pc)
       && !mips32_instruction_has_delay_slot (gdbarch, pc))
      || (mips_pc_is_micromips (gdbarch, pc)
	  && !micromips_instruction_has_delay_slot (gdbarch, pc, 0))
      || (mips_pc_is_mips16 (gdbarch, pc)
	  && !mips16_instruction_has_delay_slot (gdbarch, pc, 0)))
    return 0;

  isa = mips_pc_isa (gdbarch, pc);
  /* _has_delay_slot above will have validated the read.  */
  insn = mips_fetch_instruction (gdbarch, isa, pc, NULL);
  size = mips_insn_size (isa, insn);
  aspace = get_frame_address_space (frame);
  return breakpoint_here_p (aspace, pc + size) != no_breakpoint_here;
}

/* To skip prologues, I use this predicate.  Returns either PC itself
   if the code at PC does not look like a function prologue; otherwise
   returns an address that (if we're lucky) follows the prologue.  If
   LENIENT, then we must skip everything which is involved in setting
   up the frame (it's OK to skip more, just so long as we don't skip
   anything which might clobber the registers which are being saved.
   We must skip more in the case where part of the prologue is in the
   delay slot of a non-prologue instruction).  */

static CORE_ADDR
mips_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  CORE_ADDR limit_pc;
  CORE_ADDR func_addr;

  /* See if we can determine the end of the prologue via the symbol table.
     If so, then return either PC, or the PC after the prologue, whichever
     is greater.  */
  if (find_pc_partial_function (pc, NULL, &func_addr, NULL))
    {
      CORE_ADDR post_prologue_pc
	= skip_prologue_using_sal (gdbarch, func_addr);
      if (post_prologue_pc != 0)
	return max (pc, post_prologue_pc);
    }

  /* Can't determine prologue from the symbol table, need to examine
     instructions.  */

  /* Find an upper limit on the function prologue using the debug
     information.  If the debug information could not be used to provide
     that bound, then use an arbitrary large number as the upper bound.  */
  limit_pc = skip_prologue_using_sal (gdbarch, pc);
  if (limit_pc == 0)
    limit_pc = pc + 100;          /* Magic.  */

  if (mips_pc_is_mips16 (gdbarch, pc))
    return mips16_scan_prologue (gdbarch, pc, limit_pc, NULL, NULL);
  else if (mips_pc_is_micromips (gdbarch, pc))
    return micromips_scan_prologue (gdbarch, pc, limit_pc, NULL, NULL);
  else
    return mips32_scan_prologue (gdbarch, pc, limit_pc, NULL, NULL);
}

/* Check whether the PC is in a function epilogue (32-bit version).
   This is a helper function for mips_in_function_epilogue_p.  */
static int
mips32_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  CORE_ADDR func_addr = 0, func_end = 0;

  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    {
      /* The MIPS epilogue is max. 12 bytes long.  */
      CORE_ADDR addr = func_end - 12;

      if (addr < func_addr + 4)
        addr = func_addr + 4;
      if (pc < addr)
        return 0;

      for (; pc < func_end; pc += MIPS_INSN32_SIZE)
	{
	  unsigned long high_word;
	  unsigned long inst;

	  inst = mips_fetch_instruction (gdbarch, ISA_MIPS, pc, NULL);
	  high_word = (inst >> 16) & 0xffff;

	  if (high_word != 0x27bd	/* addiu $sp,$sp,offset */
	      && high_word != 0x67bd	/* daddiu $sp,$sp,offset */
	      && inst != 0x03e00008	/* jr $ra */
	      && inst != 0x00000000)	/* nop */
	    return 0;
	}

      return 1;
    }

  return 0;
}

/* Check whether the PC is in a function epilogue (microMIPS version).
   This is a helper function for mips_in_function_epilogue_p.  */

static int
micromips_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  CORE_ADDR func_addr = 0;
  CORE_ADDR func_end = 0;
  CORE_ADDR addr;
  ULONGEST insn;
  long offset;
  int dreg;
  int sreg;
  int loc;

  if (!find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    return 0;

  /* The microMIPS epilogue is max. 12 bytes long.  */
  addr = func_end - 12;

  if (addr < func_addr + 2)
    addr = func_addr + 2;
  if (pc < addr)
    return 0;

  for (; pc < func_end; pc += loc)
    {
      loc = 0;
      insn = mips_fetch_instruction (gdbarch, ISA_MICROMIPS, pc, NULL);
      loc += MIPS_INSN16_SIZE;
      switch (mips_insn_size (ISA_MICROMIPS, insn))
	{
	/* 48-bit instructions.  */
	case 3 * MIPS_INSN16_SIZE:
	  /* No epilogue instructions in this category.  */
	  return 0;

	/* 32-bit instructions.  */
	case 2 * MIPS_INSN16_SIZE:
	  insn <<= 16;
	  insn |= mips_fetch_instruction (gdbarch,
					  ISA_MICROMIPS, pc + loc, NULL);
	  loc += MIPS_INSN16_SIZE;
	  switch (micromips_op (insn >> 16))
	    {
	    case 0xc: /* ADDIU: bits 001100 */
	    case 0x17: /* DADDIU: bits 010111 */
	      sreg = b0s5_reg (insn >> 16);
	      dreg = b5s5_reg (insn >> 16);
	      offset = (b0s16_imm (insn) ^ 0x8000) - 0x8000;
	      if (sreg == MIPS_SP_REGNUM && dreg == MIPS_SP_REGNUM
			    /* (D)ADDIU $sp, imm */
		  && offset >= 0)
		break;
	      return 0;

	    default:
	      return 0;
	    }
	  break;

	/* 16-bit instructions.  */
	case MIPS_INSN16_SIZE:
	  switch (micromips_op (insn))
	    {
	    case 0x3: /* MOVE: bits 000011 */
	      sreg = b0s5_reg (insn);
	      dreg = b5s5_reg (insn);
	      if (sreg == 0 && dreg == 0)
				/* MOVE $zero, $zero aka NOP */
		break;
	      return 0;

	    case 0x11: /* POOL16C: bits 010001 */
	      if (b5s5_op (insn) == 0x18
				/* JRADDIUSP: bits 010011 11000 */
		  || (b5s5_op (insn) == 0xd
				/* JRC: bits 010011 01101 */
		      && b0s5_reg (insn) == MIPS_RA_REGNUM))
				/* JRC $ra */
		break;
	      return 0;

	    case 0x13: /* POOL16D: bits 010011 */
	      offset = micromips_decode_imm9 (b1s9_imm (insn));
	      if ((insn & 0x1) == 0x1
				/* ADDIUSP: bits 010011 1 */
		  && offset > 0)
		break;
	      return 0;

	    default:
	      return 0;
	    }
	}
    }

  return 1;
}

/* Check whether the PC is in a function epilogue (16-bit version).
   This is a helper function for mips_in_function_epilogue_p.  */
static int
mips16_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  CORE_ADDR func_addr = 0, func_end = 0;

  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    {
      /* The MIPS epilogue is max. 12 bytes long.  */
      CORE_ADDR addr = func_end - 12;

      if (addr < func_addr + 4)
        addr = func_addr + 4;
      if (pc < addr)
        return 0;

      for (; pc < func_end; pc += MIPS_INSN16_SIZE)
	{
	  unsigned short inst;

	  inst = mips_fetch_instruction (gdbarch, ISA_MIPS16, pc, NULL);

	  if ((inst & 0xf800) == 0xf000)	/* extend */
	    continue;

	  if (inst != 0x6300		/* addiu $sp,offset */
	      && inst != 0xfb00		/* daddiu $sp,$sp,offset */
	      && inst != 0xe820		/* jr $ra */
	      && inst != 0xe8a0		/* jrc $ra */
	      && inst != 0x6500)	/* nop */
	    return 0;
	}

      return 1;
    }

  return 0;
}

/* The epilogue is defined here as the area at the end of a function,
   after an instruction which destroys the function's stack frame.  */
static int
mips_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  if (mips_pc_is_mips16 (gdbarch, pc))
    return mips16_in_function_epilogue_p (gdbarch, pc);
  else if (mips_pc_is_micromips (gdbarch, pc))
    return micromips_in_function_epilogue_p (gdbarch, pc);
  else
    return mips32_in_function_epilogue_p (gdbarch, pc);
}

/* Root of all "set mips "/"show mips " commands.  This will eventually be
   used for all MIPS-specific commands.  */

static void
show_mips_command (char *args, int from_tty)
{
  help_list (showmipscmdlist, "show mips ", all_commands, gdb_stdout);
}

static void
set_mips_command (char *args, int from_tty)
{
  printf_unfiltered
    ("\"set mips\" must be followed by an appropriate subcommand.\n");
  help_list (setmipscmdlist, "set mips ", all_commands, gdb_stdout);
}

/* Commands to show/set the MIPS FPU type.  */

static void
show_mipsfpu_command (char *args, int from_tty)
{
  char *fpu;

  if (gdbarch_bfd_arch_info (target_gdbarch ())->arch != bfd_arch_mips)
    {
      printf_unfiltered
	("The MIPS floating-point coprocessor is unknown "
	 "because the current architecture is not MIPS.\n");
      return;
    }

  switch (MIPS_FPU_TYPE (target_gdbarch ()))
    {
    case MIPS_FPU_SINGLE:
      fpu = "single-precision";
      break;
    case MIPS_FPU_DOUBLE:
      fpu = "double-precision";
      break;
    case MIPS_FPU_NONE:
      fpu = "absent (none)";
      break;
    default:
      internal_error (__FILE__, __LINE__, _("bad switch"));
    }
  if (mips_fpu_type_auto)
    printf_unfiltered ("The MIPS floating-point coprocessor "
		       "is set automatically (currently %s)\n",
		       fpu);
  else
    printf_unfiltered
      ("The MIPS floating-point coprocessor is assumed to be %s\n", fpu);
}


static void
set_mipsfpu_command (char *args, int from_tty)
{
  printf_unfiltered ("\"set mipsfpu\" must be followed by \"double\", "
		     "\"single\",\"none\" or \"auto\".\n");
  show_mipsfpu_command (args, from_tty);
}

static void
set_mipsfpu_single_command (char *args, int from_tty)
{
  struct gdbarch_info info;
  gdbarch_info_init (&info);
  mips_fpu_type = MIPS_FPU_SINGLE;
  mips_fpu_type_auto = 0;
  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
     instead of relying on globals.  Doing that would let generic code
     handle the search for this specific architecture.  */
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, _("set mipsfpu failed"));
}

static void
set_mipsfpu_double_command (char *args, int from_tty)
{
  struct gdbarch_info info;
  gdbarch_info_init (&info);
  mips_fpu_type = MIPS_FPU_DOUBLE;
  mips_fpu_type_auto = 0;
  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
     instead of relying on globals.  Doing that would let generic code
     handle the search for this specific architecture.  */
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, _("set mipsfpu failed"));
}

static void
set_mipsfpu_none_command (char *args, int from_tty)
{
  struct gdbarch_info info;
  gdbarch_info_init (&info);
  mips_fpu_type = MIPS_FPU_NONE;
  mips_fpu_type_auto = 0;
  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
     instead of relying on globals.  Doing that would let generic code
     handle the search for this specific architecture.  */
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, _("set mipsfpu failed"));
}

static void
set_mipsfpu_auto_command (char *args, int from_tty)
{
  mips_fpu_type_auto = 1;
}

/* Attempt to identify the particular processor model by reading the
   processor id.  NOTE: cagney/2003-11-15: Firstly it isn't clear that
   the relevant processor still exists (it dates back to '94) and
   secondly this is not the way to do this.  The processor type should
   be set by forcing an architecture change.  */

void
deprecated_mips_set_processor_regs_hack (void)
{
  struct regcache *regcache = get_current_regcache ();
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  ULONGEST prid;

  regcache_cooked_read_unsigned (regcache, MIPS_PRID_REGNUM, &prid);
  if ((prid & ~0xf) == 0x700)
    tdep->mips_processor_reg_names = mips_r3041_reg_names;
}

/* Just like reinit_frame_cache, but with the right arguments to be
   callable as an sfunc.  */

static void
reinit_frame_cache_sfunc (char *args, int from_tty,
			  struct cmd_list_element *c)
{
  reinit_frame_cache ();
}

static int
gdb_print_insn_mips (bfd_vma memaddr, struct disassemble_info *info)
{
  struct gdbarch *gdbarch = info->application_data;

  /* FIXME: cagney/2003-06-26: Is this even necessary?  The
     disassembler needs to be able to locally determine the ISA, and
     not rely on GDB.  Otherwize the stand-alone 'objdump -d' will not
     work.  */
  if (mips_pc_is_mips16 (gdbarch, memaddr))
    info->mach = bfd_mach_mips16;
  else if (mips_pc_is_micromips (gdbarch, memaddr))
    info->mach = bfd_mach_mips_micromips;

  /* Round down the instruction address to the appropriate boundary.  */
  memaddr &= (info->mach == bfd_mach_mips16
	      || info->mach == bfd_mach_mips_micromips) ? ~1 : ~3;

  /* Set the disassembler options.  */
  if (!info->disassembler_options)
    /* This string is not recognized explicitly by the disassembler,
       but it tells the disassembler to not try to guess the ABI from
       the bfd elf headers, such that, if the user overrides the ABI
       of a program linked as NewABI, the disassembly will follow the
       register naming conventions specified by the user.  */
    info->disassembler_options = "gpr-names=32";

  /* Call the appropriate disassembler based on the target endian-ness.  */
  if (info->endian == BFD_ENDIAN_BIG)
    return print_insn_big_mips (memaddr, info);
  else
    return print_insn_little_mips (memaddr, info);
}

static int
gdb_print_insn_mips_n32 (bfd_vma memaddr, struct disassemble_info *info)
{
  /* Set up the disassembler info, so that we get the right
     register names from libopcodes.  */
  info->disassembler_options = "gpr-names=n32";
  info->flavour = bfd_target_elf_flavour;

  return gdb_print_insn_mips (memaddr, info);
}

static int
gdb_print_insn_mips_n64 (bfd_vma memaddr, struct disassemble_info *info)
{
  /* Set up the disassembler info, so that we get the right
     register names from libopcodes.  */
  info->disassembler_options = "gpr-names=64";
  info->flavour = bfd_target_elf_flavour;

  return gdb_print_insn_mips (memaddr, info);
}

/* This function implements gdbarch_breakpoint_from_pc.  It uses the
   program counter value to determine whether a 16- or 32-bit breakpoint
   should be used.  It returns a pointer to a string of bytes that encode a
   breakpoint instruction, stores the length of the string to *lenptr, and
   adjusts pc (if necessary) to point to the actual memory location where
   the breakpoint should be inserted.  */

static const gdb_byte *
mips_breakpoint_from_pc (struct gdbarch *gdbarch,
			 CORE_ADDR *pcptr, int *lenptr)
{
  CORE_ADDR pc = *pcptr;

  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    {
      if (mips_pc_is_mips16 (gdbarch, pc))
	{
	  static gdb_byte mips16_big_breakpoint[] = { 0xe8, 0xa5 };
	  *pcptr = unmake_compact_addr (pc);
	  *lenptr = sizeof (mips16_big_breakpoint);
	  return mips16_big_breakpoint;
	}
      else if (mips_pc_is_micromips (gdbarch, pc))
	{
	  static gdb_byte micromips16_big_breakpoint[] = { 0x46, 0x85 };
	  static gdb_byte micromips32_big_breakpoint[] = { 0, 0x5, 0, 0x7 };
	  ULONGEST insn;
	  int status;
	  int size;

	  insn = mips_fetch_instruction (gdbarch, ISA_MICROMIPS, pc, &status);
	  size = status ? 2
			: mips_insn_size (ISA_MICROMIPS, insn) == 2 ? 2 : 4;
	  *pcptr = unmake_compact_addr (pc);
	  *lenptr = size;
	  return (size == 2) ? micromips16_big_breakpoint
			     : micromips32_big_breakpoint;
	}
      else
	{
	  /* The IDT board uses an unusual breakpoint value, and
	     sometimes gets confused when it sees the usual MIPS
	     breakpoint instruction.  */
	  static gdb_byte big_breakpoint[] = { 0, 0x5, 0, 0xd };
	  static gdb_byte pmon_big_breakpoint[] = { 0, 0, 0, 0xd };
	  static gdb_byte idt_big_breakpoint[] = { 0, 0, 0x0a, 0xd };
	  /* Likewise, IRIX appears to expect a different breakpoint,
	     although this is not apparent until you try to use pthreads.  */
	  static gdb_byte irix_big_breakpoint[] = { 0, 0, 0, 0xd };

	  *lenptr = sizeof (big_breakpoint);

	  if (strcmp (target_shortname, "mips") == 0)
	    return idt_big_breakpoint;
	  else if (strcmp (target_shortname, "ddb") == 0
		   || strcmp (target_shortname, "pmon") == 0
		   || strcmp (target_shortname, "lsi") == 0)
	    return pmon_big_breakpoint;
	  else if (gdbarch_osabi (gdbarch) == GDB_OSABI_IRIX)
	    return irix_big_breakpoint;
	  else
	    return big_breakpoint;
	}
    }
  else
    {
      if (mips_pc_is_mips16 (gdbarch, pc))
	{
	  static gdb_byte mips16_little_breakpoint[] = { 0xa5, 0xe8 };
	  *pcptr = unmake_compact_addr (pc);
	  *lenptr = sizeof (mips16_little_breakpoint);
	  return mips16_little_breakpoint;
	}
      else if (mips_pc_is_micromips (gdbarch, pc))
	{
	  static gdb_byte micromips16_little_breakpoint[] = { 0x85, 0x46 };
	  static gdb_byte micromips32_little_breakpoint[] = { 0x5, 0, 0x7, 0 };
	  ULONGEST insn;
	  int status;
	  int size;

	  insn = mips_fetch_instruction (gdbarch, ISA_MICROMIPS, pc, &status);
	  size = status ? 2
			: mips_insn_size (ISA_MICROMIPS, insn) == 2 ? 2 : 4;
	  *pcptr = unmake_compact_addr (pc);
	  *lenptr = size;
	  return (size == 2) ? micromips16_little_breakpoint
			     : micromips32_little_breakpoint;
	}
      else
	{
	  static gdb_byte little_breakpoint[] = { 0xd, 0, 0x5, 0 };
	  static gdb_byte pmon_little_breakpoint[] = { 0xd, 0, 0, 0 };
	  static gdb_byte idt_little_breakpoint[] = { 0xd, 0x0a, 0, 0 };

	  *lenptr = sizeof (little_breakpoint);

	  if (strcmp (target_shortname, "mips") == 0)
	    return idt_little_breakpoint;
	  else if (strcmp (target_shortname, "ddb") == 0
		   || strcmp (target_shortname, "pmon") == 0
		   || strcmp (target_shortname, "lsi") == 0)
	    return pmon_little_breakpoint;
	  else
	    return little_breakpoint;
	}
    }
}

/* Determine the remote breakpoint kind suitable for the PC.  The following
   kinds are used:

   * 2 -- 16-bit MIPS16 mode breakpoint,

   * 3 -- 16-bit microMIPS mode breakpoint,

   * 4 -- 32-bit standard MIPS mode breakpoint,

   * 5 -- 32-bit microMIPS mode breakpoint.  */

static void
mips_remote_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr,
				int *kindptr)
{
  CORE_ADDR pc = *pcptr;

  if (mips_pc_is_mips16 (gdbarch, pc))
    {
      *pcptr = unmake_compact_addr (pc);
      *kindptr = 2;
    }
  else if (mips_pc_is_micromips (gdbarch, pc))
    {
      ULONGEST insn;
      int status;
      int size;

      insn = mips_fetch_instruction (gdbarch, ISA_MICROMIPS, pc, &status);
      size = status ? 2 : mips_insn_size (ISA_MICROMIPS, insn) == 2 ? 2 : 4;
      *pcptr = unmake_compact_addr (pc);
      *kindptr = size | 1;
    }
  else
    *kindptr = 4;
}

/* Return non-zero if the ADDR instruction has a branch delay slot
   (i.e. it is a jump or branch instruction).  This function is based
   on mips32_next_pc.  */

static int
mips32_instruction_has_delay_slot (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  unsigned long inst;
  int status;
  int op;
  int rs;
  int rt;

  inst = mips_fetch_instruction (gdbarch, ISA_MIPS, addr, &status);
  if (status)
    return 0;

  op = itype_op (inst);
  if ((inst & 0xe0000000) != 0)
    {
      rs = itype_rs (inst);
      rt = itype_rt (inst);
      return (is_octeon_bbit_op (op, gdbarch) 
	      || op >> 2 == 5	/* BEQL, BNEL, BLEZL, BGTZL: bits 0101xx  */
	      || op == 29	/* JALX: bits 011101  */
	      || (op == 17
		  && (rs == 8
				/* BC1F, BC1FL, BC1T, BC1TL: 010001 01000  */
		      || (rs == 9 && (rt & 0x2) == 0)
				/* BC1ANY2F, BC1ANY2T: bits 010001 01001  */
		      || (rs == 10 && (rt & 0x2) == 0))));
				/* BC1ANY4F, BC1ANY4T: bits 010001 01010  */
    }
  else
    switch (op & 0x07)		/* extract bits 28,27,26  */
      {
      case 0:			/* SPECIAL  */
	op = rtype_funct (inst);
	return (op == 8		/* JR  */
		|| op == 9);	/* JALR  */
	break;			/* end SPECIAL  */
      case 1:			/* REGIMM  */
	rs = itype_rs (inst);
	rt = itype_rt (inst);	/* branch condition  */
	return ((rt & 0xc) == 0
				/* BLTZ, BLTZL, BGEZ, BGEZL: bits 000xx  */
				/* BLTZAL, BLTZALL, BGEZAL, BGEZALL: 100xx  */
		|| ((rt & 0x1e) == 0x1c && rs == 0));
				/* BPOSGE32, BPOSGE64: bits 1110x  */
	break;			/* end REGIMM  */
      default:			/* J, JAL, BEQ, BNE, BLEZ, BGTZ  */
	return 1;
	break;
      }
}

/* Return non-zero if the ADDR instruction, which must be a 32-bit
   instruction if MUSTBE32 is set or can be any instruction otherwise,
   has a branch delay slot (i.e. it is a non-compact jump instruction).  */

static int
micromips_instruction_has_delay_slot (struct gdbarch *gdbarch,
				      CORE_ADDR addr, int mustbe32)
{
  ULONGEST insn;
  int status;

  insn = mips_fetch_instruction (gdbarch, ISA_MICROMIPS, addr, &status);
  if (status)
    return 0;

  if (!mustbe32)		/* 16-bit instructions.  */
    return (micromips_op (insn) == 0x11
				/* POOL16C: bits 010001 */
	    && (b5s5_op (insn) == 0xc
				/* JR16: bits 010001 01100 */
		|| (b5s5_op (insn) & 0x1e) == 0xe))
				/* JALR16, JALRS16: bits 010001 0111x */
	   || (micromips_op (insn) & 0x37) == 0x23
				/* BEQZ16, BNEZ16: bits 10x011 */
	   || micromips_op (insn) == 0x33;
				/* B16: bits 110011 */

				/* 32-bit instructions.  */
  if (micromips_op (insn) == 0x0)
				/* POOL32A: bits 000000 */
    {
      insn <<= 16;
      insn |= mips_fetch_instruction (gdbarch, ISA_MICROMIPS, addr, &status);
      if (status)
	return 0;
      return b0s6_op (insn) == 0x3c
				/* POOL32Axf: bits 000000 ... 111100 */
	     && (b6s10_ext (insn) & 0x2bf) == 0x3c;
				/* JALR, JALR.HB: 000000 000x111100 111100 */
				/* JALRS, JALRS.HB: 000000 010x111100 111100 */
    }

  return (micromips_op (insn) == 0x10
				/* POOL32I: bits 010000 */
	  && ((b5s5_op (insn) & 0x1c) == 0x0
				/* BLTZ, BLTZAL, BGEZ, BGEZAL: 010000 000xx */
	      || (b5s5_op (insn) & 0x1d) == 0x4
				/* BLEZ, BGTZ: bits 010000 001x0 */
	      || (b5s5_op (insn) & 0x1d) == 0x11
				/* BLTZALS, BGEZALS: bits 010000 100x1 */
	      || ((b5s5_op (insn) & 0x1e) == 0x14
		  && (insn & 0x3) == 0x0)
				/* BC2F, BC2T: bits 010000 1010x xxx00 */
	      || (b5s5_op (insn) & 0x1e) == 0x1a
				/* BPOSGE64, BPOSGE32: bits 010000 1101x */
	      || ((b5s5_op (insn) & 0x1e) == 0x1c
		  && (insn & 0x3) == 0x0)
				/* BC1F, BC1T: bits 010000 1110x xxx00 */
	      || ((b5s5_op (insn) & 0x1c) == 0x1c
		  && (insn & 0x3) == 0x1)))
				/* BC1ANY*: bits 010000 111xx xxx01 */
	 || (micromips_op (insn) & 0x1f) == 0x1d
				/* JALS, JAL: bits x11101 */
	 || (micromips_op (insn) & 0x37) == 0x25
				/* BEQ, BNE: bits 10x101 */
	 || micromips_op (insn) == 0x35
				/* J: bits 110101 */
	 || micromips_op (insn) == 0x3c;
				/* JALX: bits 111100 */
}

static int
mips16_instruction_has_delay_slot (struct gdbarch *gdbarch, CORE_ADDR addr,
				   int mustbe32)
{
  unsigned short inst;
  int status;

  inst = mips_fetch_instruction (gdbarch, ISA_MIPS16, addr, &status);
  if (status)
    return 0;

  if (!mustbe32)
    return (inst & 0xf89f) == 0xe800;	/* JR/JALR (16-bit instruction)  */
  return (inst & 0xf800) == 0x1800;	/* JAL/JALX (32-bit instruction)  */
}

/* Calculate the starting address of the MIPS memory segment BPADDR is in.
   This assumes KSSEG exists.  */

static CORE_ADDR
mips_segment_boundary (CORE_ADDR bpaddr)
{
  CORE_ADDR mask = CORE_ADDR_MAX;
  int segsize;

  if (sizeof (CORE_ADDR) == 8)
    /* Get the topmost two bits of bpaddr in a 32-bit safe manner (avoid
       a compiler warning produced where CORE_ADDR is a 32-bit type even
       though in that case this is dead code).  */
    switch (bpaddr >> ((sizeof (CORE_ADDR) << 3) - 2) & 3)
      {
      case 3:
	if (bpaddr == (bfd_signed_vma) (int32_t) bpaddr)
	  segsize = 29;			/* 32-bit compatibility segment  */
	else
	  segsize = 62;			/* xkseg  */
	break;
      case 2:				/* xkphys  */
	segsize = 59;
	break;
      default:				/* xksseg (1), xkuseg/kuseg (0)  */
	segsize = 62;
	break;
      }
  else if (bpaddr & 0x80000000)		/* kernel segment  */
    segsize = 29;
  else
    segsize = 31;			/* user segment  */
  mask <<= segsize;
  return bpaddr & mask;
}

/* Move the breakpoint at BPADDR out of any branch delay slot by shifting
   it backwards if necessary.  Return the address of the new location.  */

static CORE_ADDR
mips_adjust_breakpoint_address (struct gdbarch *gdbarch, CORE_ADDR bpaddr)
{
  CORE_ADDR prev_addr;
  CORE_ADDR boundary;
  CORE_ADDR func_addr;

  /* If a breakpoint is set on the instruction in a branch delay slot,
     GDB gets confused.  When the breakpoint is hit, the PC isn't on
     the instruction in the branch delay slot, the PC will point to
     the branch instruction.  Since the PC doesn't match any known
     breakpoints, GDB reports a trap exception.

     There are two possible fixes for this problem.

     1) When the breakpoint gets hit, see if the BD bit is set in the
     Cause register (which indicates the last exception occurred in a
     branch delay slot).  If the BD bit is set, fix the PC to point to
     the instruction in the branch delay slot.

     2) When the user sets the breakpoint, don't allow him to set the
     breakpoint on the instruction in the branch delay slot.  Instead
     move the breakpoint to the branch instruction (which will have
     the same result).

     The problem with the first solution is that if the user then
     single-steps the processor, the branch instruction will get
     skipped (since GDB thinks the PC is on the instruction in the
     branch delay slot).

     So, we'll use the second solution.  To do this we need to know if
     the instruction we're trying to set the breakpoint on is in the
     branch delay slot.  */

  boundary = mips_segment_boundary (bpaddr);

  /* Make sure we don't scan back before the beginning of the current
     function, since we may fetch constant data or insns that look like
     a jump.  Of course we might do that anyway if the compiler has
     moved constants inline. :-(  */
  if (find_pc_partial_function (bpaddr, NULL, &func_addr, NULL)
      && func_addr > boundary && func_addr <= bpaddr)
    boundary = func_addr;

  if (mips_pc_is_mips (bpaddr))
    {
      if (bpaddr == boundary)
	return bpaddr;

      /* If the previous instruction has a branch delay slot, we have
         to move the breakpoint to the branch instruction. */
      prev_addr = bpaddr - 4;
      if (mips32_instruction_has_delay_slot (gdbarch, prev_addr))
	bpaddr = prev_addr;
    }
  else
    {
      int (*instruction_has_delay_slot) (struct gdbarch *, CORE_ADDR, int);
      CORE_ADDR addr, jmpaddr;
      int i;

      boundary = unmake_compact_addr (boundary);

      /* The only MIPS16 instructions with delay slots are JAL, JALX,
         JALR and JR.  An absolute JAL/JALX is always 4 bytes long,
         so try for that first, then try the 2 byte JALR/JR.
         The microMIPS ASE has a whole range of jumps and branches
         with delay slots, some of which take 4 bytes and some take
         2 bytes, so the idea is the same.
         FIXME: We have to assume that bpaddr is not the second half
         of an extended instruction.  */
      instruction_has_delay_slot = (mips_pc_is_micromips (gdbarch, bpaddr)
				     ? micromips_instruction_has_delay_slot
				     : mips16_instruction_has_delay_slot);

      jmpaddr = 0;
      addr = bpaddr;
      for (i = 1; i < 4; i++)
	{
	  if (unmake_compact_addr (addr) == boundary)
	    break;
	  addr -= MIPS_INSN16_SIZE;
	  if (i == 1 && instruction_has_delay_slot (gdbarch, addr, 0))
	    /* Looks like a JR/JALR at [target-1], but it could be
	       the second word of a previous JAL/JALX, so record it
	       and check back one more.  */
	    jmpaddr = addr;
	  else if (i > 1 && instruction_has_delay_slot (gdbarch, addr, 1))
	    {
	      if (i == 2)
		/* Looks like a JAL/JALX at [target-2], but it could also
		   be the second word of a previous JAL/JALX, record it,
		   and check back one more.  */
		jmpaddr = addr;
	      else
		/* Looks like a JAL/JALX at [target-3], so any previously
		   recorded JAL/JALX or JR/JALR must be wrong, because:

		   >-3: JAL
		    -2: JAL-ext (can't be JAL/JALX)
		    -1: bdslot (can't be JR/JALR)
		     0: target insn

		   Of course it could be another JAL-ext which looks
		   like a JAL, but in that case we'd have broken out
		   of this loop at [target-2]:

		    -4: JAL
		   >-3: JAL-ext
		    -2: bdslot (can't be jmp)
		    -1: JR/JALR
		     0: target insn  */
		jmpaddr = 0;
	    }
	  else
	    {
	      /* Not a jump instruction: if we're at [target-1] this
	         could be the second word of a JAL/JALX, so continue;
	         otherwise we're done.  */
	      if (i > 1)
		break;
	    }
	}

      if (jmpaddr)
	bpaddr = jmpaddr;
    }

  return bpaddr;
}

/* Return non-zero if SUFFIX is one of the numeric suffixes used for MIPS16
   call stubs, one of 1, 2, 5, 6, 9, 10, or, if ZERO is non-zero, also 0.  */

static int
mips_is_stub_suffix (const char *suffix, int zero)
{
  switch (suffix[0])
   {
   case '0':
     return zero && suffix[1] == '\0';
   case '1':
     return suffix[1] == '\0' || (suffix[1] == '0' && suffix[2] == '\0');
   case '2':
   case '5':
   case '6':
   case '9':
     return suffix[1] == '\0';
   default:
     return 0;
   }
}

/* Return non-zero if MODE is one of the mode infixes used for MIPS16
   call stubs, one of sf, df, sc, or dc.  */

static int
mips_is_stub_mode (const char *mode)
{
  return ((mode[0] == 's' || mode[0] == 'd')
	  && (mode[1] == 'f' || mode[1] == 'c'));
}

/* Code at PC is a compiler-generated stub.  Such a stub for a function
   bar might have a name like __fn_stub_bar, and might look like this:

      mfc1    $4, $f13
      mfc1    $5, $f12
      mfc1    $6, $f15
      mfc1    $7, $f14

   followed by (or interspersed with):

      j       bar

   or:

      lui     $25, %hi(bar)
      addiu   $25, $25, %lo(bar)
      jr      $25

   ($1 may be used in old code; for robustness we accept any register)
   or, in PIC code:

      lui     $28, %hi(_gp_disp)
      addiu   $28, $28, %lo(_gp_disp)
      addu    $28, $28, $25
      lw      $25, %got(bar)
      addiu   $25, $25, %lo(bar)
      jr      $25

   In the case of a __call_stub_bar stub, the sequence to set up
   arguments might look like this:

      mtc1    $4, $f13
      mtc1    $5, $f12
      mtc1    $6, $f15
      mtc1    $7, $f14

   followed by (or interspersed with) one of the jump sequences above.

   In the case of a __call_stub_fp_bar stub, JAL or JALR is used instead
   of J or JR, respectively, followed by:

      mfc1    $2, $f0
      mfc1    $3, $f1
      jr      $18

   We are at the beginning of the stub here, and scan down and extract
   the target address from the jump immediate instruction or, if a jump
   register instruction is used, from the register referred.  Return
   the value of PC calculated or 0 if inconclusive.

   The limit on the search is arbitrarily set to 20 instructions.  FIXME.  */

static CORE_ADDR
mips_get_mips16_fn_stub_pc (struct frame_info *frame, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int addrreg = MIPS_ZERO_REGNUM;
  CORE_ADDR start_pc = pc;
  CORE_ADDR target_pc = 0;
  CORE_ADDR addr = 0;
  CORE_ADDR gp = 0;
  int status = 0;
  int i;

  for (i = 0;
       status == 0 && target_pc == 0 && i < 20;
       i++, pc += MIPS_INSN32_SIZE)
    {
      ULONGEST inst = mips_fetch_instruction (gdbarch, ISA_MIPS, pc, NULL);
      CORE_ADDR imm;
      int rt;
      int rs;
      int rd;

      switch (itype_op (inst))
	{
	case 0:		/* SPECIAL */
	  switch (rtype_funct (inst))
	    {
	    case 8:		/* JR */
	    case 9:		/* JALR */
	      rs = rtype_rs (inst);
	      if (rs == MIPS_GP_REGNUM)
		target_pc = gp;				/* Hmm...  */
	      else if (rs == addrreg)
		target_pc = addr;
	      break;

	    case 0x21:		/* ADDU */
	      rt = rtype_rt (inst);
	      rs = rtype_rs (inst);
	      rd = rtype_rd (inst);
	      if (rd == MIPS_GP_REGNUM
		  && ((rs == MIPS_GP_REGNUM && rt == MIPS_T9_REGNUM)
		      || (rs == MIPS_T9_REGNUM && rt == MIPS_GP_REGNUM)))
		gp += start_pc;
	      break;
	    }
	  break;

	case 2:		/* J */
	case 3:		/* JAL */
	  target_pc = jtype_target (inst) << 2;
	  target_pc += ((pc + 4) & ~(CORE_ADDR) 0x0fffffff);
	  break;

	case 9:		/* ADDIU */
	  rt = itype_rt (inst);
	  rs = itype_rs (inst);
	  if (rt == rs)
	    {
	      imm = (itype_immediate (inst) ^ 0x8000) - 0x8000;
	      if (rt == MIPS_GP_REGNUM)
		gp += imm;
	      else if (rt == addrreg)
		addr += imm;
	    }
	  break;

	case 0xf:	/* LUI */
	  rt = itype_rt (inst);
	  imm = ((itype_immediate (inst) ^ 0x8000) - 0x8000) << 16;
	  if (rt == MIPS_GP_REGNUM)
	    gp = imm;
	  else if (rt != MIPS_ZERO_REGNUM)
	    {
	      addrreg = rt;
	      addr = imm;
	    }
	  break;

	case 0x23:	/* LW */
	  rt = itype_rt (inst);
	  rs = itype_rs (inst);
	  imm = (itype_immediate (inst) ^ 0x8000) - 0x8000;
	  if (gp != 0 && rs == MIPS_GP_REGNUM)
	    {
	      gdb_byte buf[4];

	      memset (buf, 0, sizeof (buf));
	      status = target_read_memory (gp + imm, buf, sizeof (buf));
	      addrreg = rt;
	      addr = extract_signed_integer (buf, sizeof (buf), byte_order);
	    }
	  break;
	}
    }

  return target_pc;
}

/* If PC is in a MIPS16 call or return stub, return the address of the
   target PC, which is either the callee or the caller.  There are several
   cases which must be handled:

   * If the PC is in __mips16_ret_{d,s}{f,c}, this is a return stub
     and the target PC is in $31 ($ra).
   * If the PC is in __mips16_call_stub_{1..10}, this is a call stub
     and the target PC is in $2.
   * If the PC at the start of __mips16_call_stub_{s,d}{f,c}_{0..10},
     i.e. before the JALR instruction, this is effectively a call stub
     and the target PC is in $2.  Otherwise this is effectively
     a return stub and the target PC is in $18.
   * If the PC is at the start of __call_stub_fp_*, i.e. before the
     JAL or JALR instruction, this is effectively a call stub and the
     target PC is buried in the instruction stream.  Otherwise this
     is effectively a return stub and the target PC is in $18.
   * If the PC is in __call_stub_* or in __fn_stub_*, this is a call
     stub and the target PC is buried in the instruction stream.

   See the source code for the stubs in gcc/config/mips/mips16.S, or the
   stub builder in gcc/config/mips/mips.c (mips16_build_call_stub) for the
   gory details.  */

static CORE_ADDR
mips_skip_mips16_trampoline_code (struct frame_info *frame, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  CORE_ADDR start_addr;
  const char *name;
  size_t prefixlen;

  /* Find the starting address and name of the function containing the PC.  */
  if (find_pc_partial_function (pc, &name, &start_addr, NULL) == 0)
    return 0;

  /* If the PC is in __mips16_ret_{d,s}{f,c}, this is a return stub
     and the target PC is in $31 ($ra).  */
  prefixlen = strlen (mips_str_mips16_ret_stub);
  if (strncmp (name, mips_str_mips16_ret_stub, prefixlen) == 0
      && mips_is_stub_mode (name + prefixlen)
      && name[prefixlen + 2] == '\0')
    return get_frame_register_signed
	     (frame, gdbarch_num_regs (gdbarch) + MIPS_RA_REGNUM);

  /* If the PC is in __mips16_call_stub_*, this is one of the call
     call/return stubs.  */
  prefixlen = strlen (mips_str_mips16_call_stub);
  if (strncmp (name, mips_str_mips16_call_stub, prefixlen) == 0)
    {
      /* If the PC is in __mips16_call_stub_{1..10}, this is a call stub
         and the target PC is in $2.  */
      if (mips_is_stub_suffix (name + prefixlen, 0))
	return get_frame_register_signed
		 (frame, gdbarch_num_regs (gdbarch) + MIPS_V0_REGNUM);

      /* If the PC at the start of __mips16_call_stub_{s,d}{f,c}_{0..10},
         i.e. before the JALR instruction, this is effectively a call stub
         and the target PC is in $2.  Otherwise this is effectively
         a return stub and the target PC is in $18.  */
      else if (mips_is_stub_mode (name + prefixlen)
	       && name[prefixlen + 2] == '_'
	       && mips_is_stub_suffix (name + prefixlen + 3, 0))
	{
	  if (pc == start_addr)
	    /* This is the 'call' part of a call stub.  The return
	       address is in $2.  */
	    return get_frame_register_signed
		     (frame, gdbarch_num_regs (gdbarch) + MIPS_V0_REGNUM);
	  else
	    /* This is the 'return' part of a call stub.  The return
	       address is in $18.  */
	    return get_frame_register_signed
		     (frame, gdbarch_num_regs (gdbarch) + MIPS_S2_REGNUM);
	}
      else
	return 0;		/* Not a stub.  */
    }

  /* If the PC is in __call_stub_* or __fn_stub*, this is one of the
     compiler-generated call or call/return stubs.  */
  if (strncmp (name, mips_str_fn_stub, strlen (mips_str_fn_stub)) == 0
      || strncmp (name, mips_str_call_stub, strlen (mips_str_call_stub)) == 0)
    {
      if (pc == start_addr)
	/* This is the 'call' part of a call stub.  Call this helper
	   to scan through this code for interesting instructions
	   and determine the final PC.  */
	return mips_get_mips16_fn_stub_pc (frame, pc);
      else
	/* This is the 'return' part of a call stub.  The return address
	   is in $18.  */
	return get_frame_register_signed
		 (frame, gdbarch_num_regs (gdbarch) + MIPS_S2_REGNUM);
    }

  return 0;			/* Not a stub.  */
}

/* Return non-zero if the PC is inside a return thunk (aka stub or trampoline).
   This implements the IN_SOLIB_RETURN_TRAMPOLINE macro.  */

static int
mips_in_return_stub (struct gdbarch *gdbarch, CORE_ADDR pc, const char *name)
{
  CORE_ADDR start_addr;
  size_t prefixlen;

  /* Find the starting address of the function containing the PC.  */
  if (find_pc_partial_function (pc, NULL, &start_addr, NULL) == 0)
    return 0;

  /* If the PC is in __mips16_call_stub_{s,d}{f,c}_{0..10} but not at
     the start, i.e. after the JALR instruction, this is effectively
     a return stub.  */
  prefixlen = strlen (mips_str_mips16_call_stub);
  if (pc != start_addr
      && strncmp (name, mips_str_mips16_call_stub, prefixlen) == 0
      && mips_is_stub_mode (name + prefixlen)
      && name[prefixlen + 2] == '_'
      && mips_is_stub_suffix (name + prefixlen + 3, 1))
    return 1;

  /* If the PC is in __call_stub_fp_* but not at the start, i.e. after
     the JAL or JALR instruction, this is effectively a return stub.  */
  prefixlen = strlen (mips_str_call_fp_stub);
  if (pc != start_addr
      && strncmp (name, mips_str_call_fp_stub, prefixlen) == 0)
    return 1;

  /* Consume the .pic. prefix of any PIC stub, this function must return
     true when the PC is in a PIC stub of a __mips16_ret_{d,s}{f,c} stub
     or the call stub path will trigger in handle_inferior_event causing
     it to go astray.  */
  prefixlen = strlen (mips_str_pic);
  if (strncmp (name, mips_str_pic, prefixlen) == 0)
    name += prefixlen;

  /* If the PC is in __mips16_ret_{d,s}{f,c}, this is a return stub.  */
  prefixlen = strlen (mips_str_mips16_ret_stub);
  if (strncmp (name, mips_str_mips16_ret_stub, prefixlen) == 0
      && mips_is_stub_mode (name + prefixlen)
      && name[prefixlen + 2] == '\0')
    return 1;

  return 0;			/* Not a stub.  */
}

/* If the current PC is the start of a non-PIC-to-PIC stub, return the
   PC of the stub target.  The stub just loads $t9 and jumps to it,
   so that $t9 has the correct value at function entry.  */

static CORE_ADDR
mips_skip_pic_trampoline_code (struct frame_info *frame, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct bound_minimal_symbol msym;
  int i;
  gdb_byte stub_code[16];
  int32_t stub_words[4];

  /* The stub for foo is named ".pic.foo", and is either two
     instructions inserted before foo or a three instruction sequence
     which jumps to foo.  */
  msym = lookup_minimal_symbol_by_pc (pc);
  if (msym.minsym == NULL
      || SYMBOL_VALUE_ADDRESS (msym.minsym) != pc
      || SYMBOL_LINKAGE_NAME (msym.minsym) == NULL
      || strncmp (SYMBOL_LINKAGE_NAME (msym.minsym), ".pic.", 5) != 0)
    return 0;

  /* A two-instruction header.  */
  if (MSYMBOL_SIZE (msym.minsym) == 8)
    return pc + 8;

  /* A three-instruction (plus delay slot) trampoline.  */
  if (MSYMBOL_SIZE (msym.minsym) == 16)
    {
      if (target_read_memory (pc, stub_code, 16) != 0)
	return 0;
      for (i = 0; i < 4; i++)
	stub_words[i] = extract_unsigned_integer (stub_code + i * 4,
						  4, byte_order);

      /* A stub contains these instructions:
	 lui	t9, %hi(target)
	 j	target
	  addiu	t9, t9, %lo(target)
	 nop

	 This works even for N64, since stubs are only generated with
	 -msym32.  */
      if ((stub_words[0] & 0xffff0000U) == 0x3c190000
	  && (stub_words[1] & 0xfc000000U) == 0x08000000
	  && (stub_words[2] & 0xffff0000U) == 0x27390000
	  && stub_words[3] == 0x00000000)
	return ((((stub_words[0] & 0x0000ffff) << 16)
		 + (stub_words[2] & 0x0000ffff)) ^ 0x8000) - 0x8000;
    }

  /* Not a recognized stub.  */
  return 0;
}

static CORE_ADDR
mips_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)
{
  CORE_ADDR requested_pc = pc;
  CORE_ADDR target_pc;
  CORE_ADDR new_pc;

  do
    {
      target_pc = pc;

      new_pc = mips_skip_mips16_trampoline_code (frame, pc);
      if (new_pc)
	{
	  pc = new_pc;
	  if (is_compact_addr (pc))
	    pc = unmake_compact_addr (pc);
	}

      new_pc = find_solib_trampoline_target (frame, pc);
      if (new_pc)
	{
	  pc = new_pc;
	  if (is_compact_addr (pc))
	    pc = unmake_compact_addr (pc);
	}

      new_pc = mips_skip_pic_trampoline_code (frame, pc);
      if (new_pc)
	{
	  pc = new_pc;
	  if (is_compact_addr (pc))
	    pc = unmake_compact_addr (pc);
	}
    }
  while (pc != target_pc);

  return pc != requested_pc ? pc : 0;
}

/* Convert a dbx stab register number (from `r' declaration) to a GDB
   [1 * gdbarch_num_regs .. 2 * gdbarch_num_regs) REGNUM.  */

static int
mips_stab_reg_to_regnum (struct gdbarch *gdbarch, int num)
{
  int regnum;
  if (num >= 0 && num < 32)
    regnum = num;
  else if (num >= 38 && num < 70)
    regnum = num + mips_regnum (gdbarch)->fp0 - 38;
  else if (num == 70)
    regnum = mips_regnum (gdbarch)->hi;
  else if (num == 71)
    regnum = mips_regnum (gdbarch)->lo;
  else if (mips_regnum (gdbarch)->dspacc != -1 && num >= 72 && num < 78)
    regnum = num + mips_regnum (gdbarch)->dspacc - 72;
  else
    /* This will hopefully (eventually) provoke a warning.  Should
       we be calling complaint() here?  */
    return gdbarch_num_regs (gdbarch) + gdbarch_num_pseudo_regs (gdbarch);
  return gdbarch_num_regs (gdbarch) + regnum;
}


/* Convert a dwarf, dwarf2, or ecoff register number to a GDB [1 *
   gdbarch_num_regs .. 2 * gdbarch_num_regs) REGNUM.  */

static int
mips_dwarf_dwarf2_ecoff_reg_to_regnum (struct gdbarch *gdbarch, int num)
{
  int regnum;
  if (num >= 0 && num < 32)
    regnum = num;
  else if (num >= 32 && num < 64)
    regnum = num + mips_regnum (gdbarch)->fp0 - 32;
  else if (num == 64)
    regnum = mips_regnum (gdbarch)->hi;
  else if (num == 65)
    regnum = mips_regnum (gdbarch)->lo;
  else if (mips_regnum (gdbarch)->dspacc != -1 && num >= 66 && num < 72)
    regnum = num + mips_regnum (gdbarch)->dspacc - 66;
  else
    /* This will hopefully (eventually) provoke a warning.  Should we
       be calling complaint() here?  */
    return gdbarch_num_regs (gdbarch) + gdbarch_num_pseudo_regs (gdbarch);
  return gdbarch_num_regs (gdbarch) + regnum;
}

static int
mips_register_sim_regno (struct gdbarch *gdbarch, int regnum)
{
  /* Only makes sense to supply raw registers.  */
  gdb_assert (regnum >= 0 && regnum < gdbarch_num_regs (gdbarch));
  /* FIXME: cagney/2002-05-13: Need to look at the pseudo register to
     decide if it is valid.  Should instead define a standard sim/gdb
     register numbering scheme.  */
  if (gdbarch_register_name (gdbarch,
			     gdbarch_num_regs (gdbarch) + regnum) != NULL
      && gdbarch_register_name (gdbarch,
			        gdbarch_num_regs (gdbarch)
				+ regnum)[0] != '\0')
    return regnum;
  else
    return LEGACY_SIM_REGNO_IGNORE;
}


/* Convert an integer into an address.  Extracting the value signed
   guarantees a correctly sign extended address.  */

static CORE_ADDR
mips_integer_to_address (struct gdbarch *gdbarch,
			 struct type *type, const gdb_byte *buf)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  return extract_signed_integer (buf, TYPE_LENGTH (type), byte_order);
}

/* Dummy virtual frame pointer method.  This is no more or less accurate
   than most other architectures; we just need to be explicit about it,
   because the pseudo-register gdbarch_sp_regnum will otherwise lead to
   an assertion failure.  */

static void
mips_virtual_frame_pointer (struct gdbarch *gdbarch, 
			    CORE_ADDR pc, int *reg, LONGEST *offset)
{
  *reg = MIPS_SP_REGNUM;
  *offset = 0;
}

static void
mips_find_abi_section (bfd *abfd, asection *sect, void *obj)
{
  enum mips_abi *abip = (enum mips_abi *) obj;
  const char *name = bfd_get_section_name (abfd, sect);

  if (*abip != MIPS_ABI_UNKNOWN)
    return;

  if (strncmp (name, ".mdebug.", 8) != 0)
    return;

  if (strcmp (name, ".mdebug.abi32") == 0)
    *abip = MIPS_ABI_O32;
  else if (strcmp (name, ".mdebug.abiN32") == 0)
    *abip = MIPS_ABI_N32;
  else if (strcmp (name, ".mdebug.abi64") == 0)
    *abip = MIPS_ABI_N64;
  else if (strcmp (name, ".mdebug.abiO64") == 0)
    *abip = MIPS_ABI_O64;
  else if (strcmp (name, ".mdebug.eabi32") == 0)
    *abip = MIPS_ABI_EABI32;
  else if (strcmp (name, ".mdebug.eabi64") == 0)
    *abip = MIPS_ABI_EABI64;
  else
    warning (_("unsupported ABI %s."), name + 8);
}

static void
mips_find_long_section (bfd *abfd, asection *sect, void *obj)
{
  int *lbp = (int *) obj;
  const char *name = bfd_get_section_name (abfd, sect);

  if (strncmp (name, ".gcc_compiled_long32", 20) == 0)
    *lbp = 32;
  else if (strncmp (name, ".gcc_compiled_long64", 20) == 0)
    *lbp = 64;
  else if (strncmp (name, ".gcc_compiled_long", 18) == 0)
    warning (_("unrecognized .gcc_compiled_longXX"));
}

static enum mips_abi
global_mips_abi (void)
{
  int i;

  for (i = 0; mips_abi_strings[i] != NULL; i++)
    if (mips_abi_strings[i] == mips_abi_string)
      return (enum mips_abi) i;

  internal_error (__FILE__, __LINE__, _("unknown ABI string"));
}

/* Return the default compressed instruction set, either of MIPS16
   or microMIPS, selected when none could have been determined from
   the ELF header of the binary being executed (or no binary has been
   selected.  */

static enum mips_isa
global_mips_compression (void)
{
  int i;

  for (i = 0; mips_compression_strings[i] != NULL; i++)
    if (mips_compression_strings[i] == mips_compression_string)
      return (enum mips_isa) i;

  internal_error (__FILE__, __LINE__, _("unknown compressed ISA string"));
}

static void
mips_register_g_packet_guesses (struct gdbarch *gdbarch)
{
  /* If the size matches the set of 32-bit or 64-bit integer registers,
     assume that's what we've got.  */
  register_remote_g_packet_guess (gdbarch, 38 * 4, mips_tdesc_gp32);
  register_remote_g_packet_guess (gdbarch, 38 * 8, mips_tdesc_gp64);

  /* If the size matches the full set of registers GDB traditionally
     knows about, including floating point, for either 32-bit or
     64-bit, assume that's what we've got.  */
  register_remote_g_packet_guess (gdbarch, 90 * 4, mips_tdesc_gp32);
  register_remote_g_packet_guess (gdbarch, 90 * 8, mips_tdesc_gp64);

  /* Otherwise we don't have a useful guess.  */
}

static struct value *
value_of_mips_user_reg (struct frame_info *frame, const void *baton)
{
  const int *reg_p = baton;
  return value_of_register (*reg_p, frame);
}

static struct gdbarch *
mips_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;
  int elf_flags;
  enum mips_abi mips_abi, found_abi, wanted_abi;
  int i, num_regs;
  enum mips_fpu_type fpu_type;
  struct tdesc_arch_data *tdesc_data = NULL;
  int elf_fpu_type = Val_GNU_MIPS_ABI_FP_ANY;
  const char **reg_names;
  struct mips_regnum mips_regnum, *regnum;
  enum mips_isa mips_isa;
  int dspacc;
  int dspctl;

  /* Fill in the OS dependent register numbers and names.  */
  if (info.osabi == GDB_OSABI_IRIX)
    {
      mips_regnum.fp0 = 32;
      mips_regnum.pc = 64;
      mips_regnum.cause = 65;
      mips_regnum.badvaddr = 66;
      mips_regnum.hi = 67;
      mips_regnum.lo = 68;
      mips_regnum.fp_control_status = 69;
      mips_regnum.fp_implementation_revision = 70;
      mips_regnum.dspacc = dspacc = -1;
      mips_regnum.dspctl = dspctl = -1;
      num_regs = 71;
      reg_names = mips_irix_reg_names;
    }
  else if (info.osabi == GDB_OSABI_LINUX)
    {
      mips_regnum.fp0 = 38;
      mips_regnum.pc = 37;
      mips_regnum.cause = 36;
      mips_regnum.badvaddr = 35;
      mips_regnum.hi = 34;
      mips_regnum.lo = 33;
      mips_regnum.fp_control_status = 70;
      mips_regnum.fp_implementation_revision = 71;
      mips_regnum.dspacc = -1;
      mips_regnum.dspctl = -1;
      dspacc = 72;
      dspctl = 78;
      num_regs = 79;
      reg_names = mips_linux_reg_names;
    }
  else
    {
      mips_regnum.lo = MIPS_EMBED_LO_REGNUM;
      mips_regnum.hi = MIPS_EMBED_HI_REGNUM;
      mips_regnum.badvaddr = MIPS_EMBED_BADVADDR_REGNUM;
      mips_regnum.cause = MIPS_EMBED_CAUSE_REGNUM;
      mips_regnum.pc = MIPS_EMBED_PC_REGNUM;
      mips_regnum.fp0 = MIPS_EMBED_FP0_REGNUM;
      mips_regnum.fp_control_status = 70;
      mips_regnum.fp_implementation_revision = 71;
      mips_regnum.dspacc = dspacc = -1;
      mips_regnum.dspctl = dspctl = -1;
      num_regs = MIPS_LAST_EMBED_REGNUM + 1;
      if (info.bfd_arch_info != NULL
          && info.bfd_arch_info->mach == bfd_mach_mips3900)
        reg_names = mips_tx39_reg_names;
      else
        reg_names = mips_generic_reg_names;
    }

  /* Check any target description for validity.  */
  if (tdesc_has_registers (info.target_desc))
    {
      static const char *const mips_gprs[] = {
	"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
	"r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
	"r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
	"r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31"
      };
      static const char *const mips_fprs[] = {
	"f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
	"f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
	"f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
	"f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
      };

      const struct tdesc_feature *feature;
      int valid_p;

      feature = tdesc_find_feature (info.target_desc,
				    "org.gnu.gdb.mips.cpu");
      if (feature == NULL)
	return NULL;

      tdesc_data = tdesc_data_alloc ();

      valid_p = 1;
      for (i = MIPS_ZERO_REGNUM; i <= MIPS_RA_REGNUM; i++)
	valid_p &= tdesc_numbered_register (feature, tdesc_data, i,
					    mips_gprs[i]);


      valid_p &= tdesc_numbered_register (feature, tdesc_data,
					  mips_regnum.lo, "lo");
      valid_p &= tdesc_numbered_register (feature, tdesc_data,
					  mips_regnum.hi, "hi");
      valid_p &= tdesc_numbered_register (feature, tdesc_data,
					  mips_regnum.pc, "pc");

      if (!valid_p)
	{
	  tdesc_data_cleanup (tdesc_data);
	  return NULL;
	}

      feature = tdesc_find_feature (info.target_desc,
				    "org.gnu.gdb.mips.cp0");
      if (feature == NULL)
	{
	  tdesc_data_cleanup (tdesc_data);
	  return NULL;
	}

      valid_p = 1;
      valid_p &= tdesc_numbered_register (feature, tdesc_data,
					  mips_regnum.badvaddr, "badvaddr");
      valid_p &= tdesc_numbered_register (feature, tdesc_data,
					  MIPS_PS_REGNUM, "status");
      valid_p &= tdesc_numbered_register (feature, tdesc_data,
					  mips_regnum.cause, "cause");

      if (!valid_p)
	{
	  tdesc_data_cleanup (tdesc_data);
	  return NULL;
	}

      /* FIXME drow/2007-05-17: The FPU should be optional.  The MIPS
	 backend is not prepared for that, though.  */
      feature = tdesc_find_feature (info.target_desc,
				    "org.gnu.gdb.mips.fpu");
      if (feature == NULL)
	{
	  tdesc_data_cleanup (tdesc_data);
	  return NULL;
	}

      valid_p = 1;
      for (i = 0; i < 32; i++)
	valid_p &= tdesc_numbered_register (feature, tdesc_data,
					    i + mips_regnum.fp0, mips_fprs[i]);

      valid_p &= tdesc_numbered_register (feature, tdesc_data,
					  mips_regnum.fp_control_status,
					  "fcsr");
      valid_p
	&= tdesc_numbered_register (feature, tdesc_data,
				    mips_regnum.fp_implementation_revision,
				    "fir");

      if (!valid_p)
	{
	  tdesc_data_cleanup (tdesc_data);
	  return NULL;
	}

      if (dspacc >= 0)
	{
	  feature = tdesc_find_feature (info.target_desc,
					"org.gnu.gdb.mips.dsp");
	  /* The DSP registers are optional; it's OK if they are absent.  */
	  if (feature != NULL)
	    {
	      i = 0;
	      valid_p = 1;
	      valid_p &= tdesc_numbered_register (feature, tdesc_data,
						  dspacc + i++, "hi1");
	      valid_p &= tdesc_numbered_register (feature, tdesc_data,
						  dspacc + i++, "lo1");
	      valid_p &= tdesc_numbered_register (feature, tdesc_data,
						  dspacc + i++, "hi2");
	      valid_p &= tdesc_numbered_register (feature, tdesc_data,
						  dspacc + i++, "lo2");
	      valid_p &= tdesc_numbered_register (feature, tdesc_data,
						  dspacc + i++, "hi3");
	      valid_p &= tdesc_numbered_register (feature, tdesc_data,
						  dspacc + i++, "lo3");

	      valid_p &= tdesc_numbered_register (feature, tdesc_data,
						  dspctl, "dspctl");

	      if (!valid_p)
		{
		  tdesc_data_cleanup (tdesc_data);
		  return NULL;
		}

	      mips_regnum.dspacc = dspacc;
	      mips_regnum.dspctl = dspctl;
	    }
	}

      /* It would be nice to detect an attempt to use a 64-bit ABI
	 when only 32-bit registers are provided.  */
      reg_names = NULL;
    }

  /* First of all, extract the elf_flags, if available.  */
  if (info.abfd && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
    elf_flags = elf_elfheader (info.abfd)->e_flags;
  else if (arches != NULL)
    elf_flags = gdbarch_tdep (arches->gdbarch)->elf_flags;
  else
    elf_flags = 0;
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog,
			"mips_gdbarch_init: elf_flags = 0x%08x\n", elf_flags);

  /* Check ELF_FLAGS to see if it specifies the ABI being used.  */
  switch ((elf_flags & EF_MIPS_ABI))
    {
    case E_MIPS_ABI_O32:
      found_abi = MIPS_ABI_O32;
      break;
    case E_MIPS_ABI_O64:
      found_abi = MIPS_ABI_O64;
      break;
    case E_MIPS_ABI_EABI32:
      found_abi = MIPS_ABI_EABI32;
      break;
    case E_MIPS_ABI_EABI64:
      found_abi = MIPS_ABI_EABI64;
      break;
    default:
      if ((elf_flags & EF_MIPS_ABI2))
	found_abi = MIPS_ABI_N32;
      else
	found_abi = MIPS_ABI_UNKNOWN;
      break;
    }

  /* GCC creates a pseudo-section whose name describes the ABI.  */
  if (found_abi == MIPS_ABI_UNKNOWN && info.abfd != NULL)
    bfd_map_over_sections (info.abfd, mips_find_abi_section, &found_abi);

  /* If we have no useful BFD information, use the ABI from the last
     MIPS architecture (if there is one).  */
  if (found_abi == MIPS_ABI_UNKNOWN && info.abfd == NULL && arches != NULL)
    found_abi = gdbarch_tdep (arches->gdbarch)->found_abi;

  /* Try the architecture for any hint of the correct ABI.  */
  if (found_abi == MIPS_ABI_UNKNOWN
      && info.bfd_arch_info != NULL
      && info.bfd_arch_info->arch == bfd_arch_mips)
    {
      switch (info.bfd_arch_info->mach)
	{
	case bfd_mach_mips3900:
	  found_abi = MIPS_ABI_EABI32;
	  break;
	case bfd_mach_mips4100:
	case bfd_mach_mips5000:
	  found_abi = MIPS_ABI_EABI64;
	  break;
	case bfd_mach_mips8000:
	case bfd_mach_mips10000:
	  /* On Irix, ELF64 executables use the N64 ABI.  The
	     pseudo-sections which describe the ABI aren't present
	     on IRIX.  (Even for executables created by gcc.)  */
	  if (bfd_get_flavour (info.abfd) == bfd_target_elf_flavour
	      && elf_elfheader (info.abfd)->e_ident[EI_CLASS] == ELFCLASS64)
	    found_abi = MIPS_ABI_N64;
	  else
	    found_abi = MIPS_ABI_N32;
	  break;
	}
    }

  /* Default 64-bit objects to N64 instead of O32.  */
  if (found_abi == MIPS_ABI_UNKNOWN
      && info.abfd != NULL
      && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour
      && elf_elfheader (info.abfd)->e_ident[EI_CLASS] == ELFCLASS64)
    found_abi = MIPS_ABI_N64;

  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog, "mips_gdbarch_init: found_abi = %d\n",
			found_abi);

  /* What has the user specified from the command line?  */
  wanted_abi = global_mips_abi ();
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog, "mips_gdbarch_init: wanted_abi = %d\n",
			wanted_abi);

  /* Now that we have found what the ABI for this binary would be,
     check whether the user is overriding it.  */
  if (wanted_abi != MIPS_ABI_UNKNOWN)
    mips_abi = wanted_abi;
  else if (found_abi != MIPS_ABI_UNKNOWN)
    mips_abi = found_abi;
  else
    mips_abi = MIPS_ABI_O32;
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog, "mips_gdbarch_init: mips_abi = %d\n",
			mips_abi);

  /* Determine the default compressed ISA.  */
  if ((elf_flags & EF_MIPS_ARCH_ASE_MICROMIPS) != 0
      && (elf_flags & EF_MIPS_ARCH_ASE_M16) == 0)
    mips_isa = ISA_MICROMIPS;
  else if ((elf_flags & EF_MIPS_ARCH_ASE_M16) != 0
	   && (elf_flags & EF_MIPS_ARCH_ASE_MICROMIPS) == 0)
    mips_isa = ISA_MIPS16;
  else
    mips_isa = global_mips_compression ();
  mips_compression_string = mips_compression_strings[mips_isa];

  /* Also used when doing an architecture lookup.  */
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog,
			"mips_gdbarch_init: "
			"mips64_transfers_32bit_regs_p = %d\n",
			mips64_transfers_32bit_regs_p);

  /* Determine the MIPS FPU type.  */
#ifdef HAVE_ELF
  if (info.abfd
      && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
    elf_fpu_type = bfd_elf_get_obj_attr_int (info.abfd, OBJ_ATTR_GNU,
					     Tag_GNU_MIPS_ABI_FP);
#endif /* HAVE_ELF */

  if (!mips_fpu_type_auto)
    fpu_type = mips_fpu_type;
  else if (elf_fpu_type != Val_GNU_MIPS_ABI_FP_ANY)
    {
      switch (elf_fpu_type)
	{
	case Val_GNU_MIPS_ABI_FP_DOUBLE:
	  fpu_type = MIPS_FPU_DOUBLE;
	  break;
	case Val_GNU_MIPS_ABI_FP_SINGLE:
	  fpu_type = MIPS_FPU_SINGLE;
	  break;
	case Val_GNU_MIPS_ABI_FP_SOFT:
	default:
	  /* Soft float or unknown.  */
	  fpu_type = MIPS_FPU_NONE;
	  break;
	}
    }
  else if (info.bfd_arch_info != NULL
	   && info.bfd_arch_info->arch == bfd_arch_mips)
    switch (info.bfd_arch_info->mach)
      {
      case bfd_mach_mips3900:
      case bfd_mach_mips4100:
      case bfd_mach_mips4111:
      case bfd_mach_mips4120:
	fpu_type = MIPS_FPU_NONE;
	break;
      case bfd_mach_mips4650:
	fpu_type = MIPS_FPU_SINGLE;
	break;
      default:
	fpu_type = MIPS_FPU_DOUBLE;
	break;
      }
  else if (arches != NULL)
    fpu_type = gdbarch_tdep (arches->gdbarch)->mips_fpu_type;
  else
    fpu_type = MIPS_FPU_DOUBLE;
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog,
			"mips_gdbarch_init: fpu_type = %d\n", fpu_type);

  /* Check for blatant incompatibilities.  */

  /* If we have only 32-bit registers, then we can't debug a 64-bit
     ABI.  */
  if (info.target_desc
      && tdesc_property (info.target_desc, PROPERTY_GP32) != NULL
      && mips_abi != MIPS_ABI_EABI32
      && mips_abi != MIPS_ABI_O32)
    {
      if (tdesc_data != NULL)
	tdesc_data_cleanup (tdesc_data);
      return NULL;
    }

  /* Try to find a pre-existing architecture.  */
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      /* MIPS needs to be pedantic about which ABI the object is
         using.  */
      if (gdbarch_tdep (arches->gdbarch)->elf_flags != elf_flags)
	continue;
      if (gdbarch_tdep (arches->gdbarch)->mips_abi != mips_abi)
	continue;
      /* Need to be pedantic about which register virtual size is
         used.  */
      if (gdbarch_tdep (arches->gdbarch)->mips64_transfers_32bit_regs_p
	  != mips64_transfers_32bit_regs_p)
	continue;
      /* Be pedantic about which FPU is selected.  */
      if (gdbarch_tdep (arches->gdbarch)->mips_fpu_type != fpu_type)
	continue;

      if (tdesc_data != NULL)
	tdesc_data_cleanup (tdesc_data);
      return arches->gdbarch;
    }

  /* Need a new architecture.  Fill in a target specific vector.  */
  tdep = (struct gdbarch_tdep *) xmalloc (sizeof (struct gdbarch_tdep));
  gdbarch = gdbarch_alloc (&info, tdep);
  tdep->elf_flags = elf_flags;
  tdep->mips64_transfers_32bit_regs_p = mips64_transfers_32bit_regs_p;
  tdep->found_abi = found_abi;
  tdep->mips_abi = mips_abi;
  tdep->mips_isa = mips_isa;
  tdep->mips_fpu_type = fpu_type;
  tdep->register_size_valid_p = 0;
  tdep->register_size = 0;
  tdep->gregset = NULL;
  tdep->gregset64 = NULL;
  tdep->fpregset = NULL;
  tdep->fpregset64 = NULL;

  if (info.target_desc)
    {
      /* Some useful properties can be inferred from the target.  */
      if (tdesc_property (info.target_desc, PROPERTY_GP32) != NULL)
	{
	  tdep->register_size_valid_p = 1;
	  tdep->register_size = 4;
	}
      else if (tdesc_property (info.target_desc, PROPERTY_GP64) != NULL)
	{
	  tdep->register_size_valid_p = 1;
	  tdep->register_size = 8;
	}
    }

  /* Initially set everything according to the default ABI/ISA.  */
  set_gdbarch_short_bit (gdbarch, 16);
  set_gdbarch_int_bit (gdbarch, 32);
  set_gdbarch_float_bit (gdbarch, 32);
  set_gdbarch_double_bit (gdbarch, 64);
  set_gdbarch_long_double_bit (gdbarch, 64);
  set_gdbarch_register_reggroup_p (gdbarch, mips_register_reggroup_p);
  set_gdbarch_pseudo_register_read (gdbarch, mips_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, mips_pseudo_register_write);

  set_gdbarch_ax_pseudo_register_collect (gdbarch,
					  mips_ax_pseudo_register_collect);
  set_gdbarch_ax_pseudo_register_push_stack
      (gdbarch, mips_ax_pseudo_register_push_stack);

  set_gdbarch_elf_make_msymbol_special (gdbarch,
					mips_elf_make_msymbol_special);

  regnum = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct mips_regnum);
  *regnum = mips_regnum;
  set_gdbarch_fp0_regnum (gdbarch, regnum->fp0);
  set_gdbarch_num_regs (gdbarch, num_regs);
  set_gdbarch_num_pseudo_regs (gdbarch, num_regs);
  set_gdbarch_register_name (gdbarch, mips_register_name);
  set_gdbarch_virtual_frame_pointer (gdbarch, mips_virtual_frame_pointer);
  tdep->mips_processor_reg_names = reg_names;
  tdep->regnum = regnum;

  switch (mips_abi)
    {
    case MIPS_ABI_O32:
      set_gdbarch_push_dummy_call (gdbarch, mips_o32_push_dummy_call);
      set_gdbarch_return_value (gdbarch, mips_o32_return_value);
      tdep->mips_last_arg_regnum = MIPS_A0_REGNUM + 4 - 1;
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 4 - 1;
      tdep->default_mask_address_p = 0;
      set_gdbarch_long_bit (gdbarch, 32);
      set_gdbarch_ptr_bit (gdbarch, 32);
      set_gdbarch_long_long_bit (gdbarch, 64);
      break;
    case MIPS_ABI_O64:
      set_gdbarch_push_dummy_call (gdbarch, mips_o64_push_dummy_call);
      set_gdbarch_return_value (gdbarch, mips_o64_return_value);
      tdep->mips_last_arg_regnum = MIPS_A0_REGNUM + 4 - 1;
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 4 - 1;
      tdep->default_mask_address_p = 0;
      set_gdbarch_long_bit (gdbarch, 32);
      set_gdbarch_ptr_bit (gdbarch, 32);
      set_gdbarch_long_long_bit (gdbarch, 64);
      break;
    case MIPS_ABI_EABI32:
      set_gdbarch_push_dummy_call (gdbarch, mips_eabi_push_dummy_call);
      set_gdbarch_return_value (gdbarch, mips_eabi_return_value);
      tdep->mips_last_arg_regnum = MIPS_A0_REGNUM + 8 - 1;
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
      tdep->default_mask_address_p = 0;
      set_gdbarch_long_bit (gdbarch, 32);
      set_gdbarch_ptr_bit (gdbarch, 32);
      set_gdbarch_long_long_bit (gdbarch, 64);
      break;
    case MIPS_ABI_EABI64:
      set_gdbarch_push_dummy_call (gdbarch, mips_eabi_push_dummy_call);
      set_gdbarch_return_value (gdbarch, mips_eabi_return_value);
      tdep->mips_last_arg_regnum = MIPS_A0_REGNUM + 8 - 1;
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
      tdep->default_mask_address_p = 0;
      set_gdbarch_long_bit (gdbarch, 64);
      set_gdbarch_ptr_bit (gdbarch, 64);
      set_gdbarch_long_long_bit (gdbarch, 64);
      break;
    case MIPS_ABI_N32:
      set_gdbarch_push_dummy_call (gdbarch, mips_n32n64_push_dummy_call);
      set_gdbarch_return_value (gdbarch, mips_n32n64_return_value);
      tdep->mips_last_arg_regnum = MIPS_A0_REGNUM + 8 - 1;
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
      tdep->default_mask_address_p = 0;
      set_gdbarch_long_bit (gdbarch, 32);
      set_gdbarch_ptr_bit (gdbarch, 32);
      set_gdbarch_long_long_bit (gdbarch, 64);
      set_gdbarch_long_double_bit (gdbarch, 128);
      set_gdbarch_long_double_format (gdbarch, floatformats_ibm_long_double);
      break;
    case MIPS_ABI_N64:
      set_gdbarch_push_dummy_call (gdbarch, mips_n32n64_push_dummy_call);
      set_gdbarch_return_value (gdbarch, mips_n32n64_return_value);
      tdep->mips_last_arg_regnum = MIPS_A0_REGNUM + 8 - 1;
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
      tdep->default_mask_address_p = 0;
      set_gdbarch_long_bit (gdbarch, 64);
      set_gdbarch_ptr_bit (gdbarch, 64);
      set_gdbarch_long_long_bit (gdbarch, 64);
      set_gdbarch_long_double_bit (gdbarch, 128);
      set_gdbarch_long_double_format (gdbarch, floatformats_ibm_long_double);
      break;
    default:
      internal_error (__FILE__, __LINE__, _("unknown ABI in switch"));
    }

  /* GCC creates a pseudo-section whose name specifies the size of
     longs, since -mlong32 or -mlong64 may be used independent of
     other options.  How those options affect pointer sizes is ABI and
     architecture dependent, so use them to override the default sizes
     set by the ABI.  This table shows the relationship between ABI,
     -mlongXX, and size of pointers:

     ABI		-mlongXX	ptr bits
     ---		--------	--------
     o32		32		32
     o32		64		32
     n32		32		32
     n32		64		64
     o64		32		32
     o64		64		64
     n64		32		32
     n64		64		64
     eabi32		32		32
     eabi32		64		32
     eabi64		32		32
     eabi64		64		64

    Note that for o32 and eabi32, pointers are always 32 bits
    regardless of any -mlongXX option.  For all others, pointers and
    longs are the same, as set by -mlongXX or set by defaults.  */

  if (info.abfd != NULL)
    {
      int long_bit = 0;

      bfd_map_over_sections (info.abfd, mips_find_long_section, &long_bit);
      if (long_bit)
	{
	  set_gdbarch_long_bit (gdbarch, long_bit);
	  switch (mips_abi)
	    {
	    case MIPS_ABI_O32:
	    case MIPS_ABI_EABI32:
	      break;
	    case MIPS_ABI_N32:
	    case MIPS_ABI_O64:
	    case MIPS_ABI_N64:
	    case MIPS_ABI_EABI64:
	      set_gdbarch_ptr_bit (gdbarch, long_bit);
	      break;
	    default:
	      internal_error (__FILE__, __LINE__, _("unknown ABI in switch"));
	    }
	}
    }

  /* FIXME: jlarmour/2000-04-07: There *is* a flag EF_MIPS_32BIT_MODE
     that could indicate -gp32 BUT gas/config/tc-mips.c contains the
     comment:

     ``We deliberately don't allow "-gp32" to set the MIPS_32BITMODE
     flag in object files because to do so would make it impossible to
     link with libraries compiled without "-gp32".  This is
     unnecessarily restrictive.

     We could solve this problem by adding "-gp32" multilibs to gcc,
     but to set this flag before gcc is built with such multilibs will
     break too many systems.''

     But even more unhelpfully, the default linker output target for
     mips64-elf is elf32-bigmips, and has EF_MIPS_32BIT_MODE set, even
     for 64-bit programs - you need to change the ABI to change this,
     and not all gcc targets support that currently.  Therefore using
     this flag to detect 32-bit mode would do the wrong thing given
     the current gcc - it would make GDB treat these 64-bit programs
     as 32-bit programs by default.  */

  set_gdbarch_read_pc (gdbarch, mips_read_pc);
  set_gdbarch_write_pc (gdbarch, mips_write_pc);

  /* Add/remove bits from an address.  The MIPS needs be careful to
     ensure that all 32 bit addresses are sign extended to 64 bits.  */
  set_gdbarch_addr_bits_remove (gdbarch, mips_addr_bits_remove);

  /* Unwind the frame.  */
  set_gdbarch_unwind_pc (gdbarch, mips_unwind_pc);
  set_gdbarch_unwind_sp (gdbarch, mips_unwind_sp);
  set_gdbarch_dummy_id (gdbarch, mips_dummy_id);

  /* Map debug register numbers onto internal register numbers.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, mips_stab_reg_to_regnum);
  set_gdbarch_ecoff_reg_to_regnum (gdbarch,
				   mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch,
				    mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_register_sim_regno (gdbarch, mips_register_sim_regno);

  /* MIPS version of CALL_DUMMY.  */

  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
  set_gdbarch_push_dummy_code (gdbarch, mips_push_dummy_code);
  set_gdbarch_frame_align (gdbarch, mips_frame_align);

  set_gdbarch_convert_register_p (gdbarch, mips_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, mips_register_to_value);
  set_gdbarch_value_to_register (gdbarch, mips_value_to_register);

  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_breakpoint_from_pc (gdbarch, mips_breakpoint_from_pc);
  set_gdbarch_remote_breakpoint_from_pc (gdbarch,
					 mips_remote_breakpoint_from_pc);
  set_gdbarch_adjust_breakpoint_address (gdbarch,
					 mips_adjust_breakpoint_address);

  set_gdbarch_skip_prologue (gdbarch, mips_skip_prologue);

  set_gdbarch_in_function_epilogue_p (gdbarch, mips_in_function_epilogue_p);

  set_gdbarch_pointer_to_address (gdbarch, signed_pointer_to_address);
  set_gdbarch_address_to_pointer (gdbarch, address_to_signed_pointer);
  set_gdbarch_integer_to_address (gdbarch, mips_integer_to_address);

  set_gdbarch_register_type (gdbarch, mips_register_type);

  set_gdbarch_print_registers_info (gdbarch, mips_print_registers_info);

  if (mips_abi == MIPS_ABI_N32)
    set_gdbarch_print_insn (gdbarch, gdb_print_insn_mips_n32);
  else if (mips_abi == MIPS_ABI_N64)
    set_gdbarch_print_insn (gdbarch, gdb_print_insn_mips_n64);
  else
    set_gdbarch_print_insn (gdbarch, gdb_print_insn_mips);

  /* FIXME: cagney/2003-08-29: The macros target_have_steppable_watchpoint,
     HAVE_NONSTEPPABLE_WATCHPOINT, and target_have_continuable_watchpoint
     need to all be folded into the target vector.  Since they are
     being used as guards for target_stopped_by_watchpoint, why not have
     target_stopped_by_watchpoint return the type of watchpoint that the code
     is sitting on?  */
  set_gdbarch_have_nonsteppable_watchpoint (gdbarch, 1);

  set_gdbarch_skip_trampoline_code (gdbarch, mips_skip_trampoline_code);

  /* NOTE drow/2012-04-25: We overload the core solib trampoline code
     to support MIPS16.  This is a bad thing.  Make sure not to do it
     if we have an OS ABI that actually supports shared libraries, since
     shared library support is more important.  If we have an OS someday
     that supports both shared libraries and MIPS16, we'll have to find
     a better place for these.
     macro/2012-04-25: But that applies to return trampolines only and
     currently no MIPS OS ABI uses shared libraries that have them.  */
  set_gdbarch_in_solib_return_trampoline (gdbarch, mips_in_return_stub);

  set_gdbarch_single_step_through_delay (gdbarch,
					 mips_single_step_through_delay);

  /* Virtual tables.  */
  set_gdbarch_vbit_in_delta (gdbarch, 1);

  mips_register_g_packet_guesses (gdbarch);

  /* Hook in OS ABI-specific overrides, if they have been registered.  */
  info.tdep_info = (void *) tdesc_data;
  gdbarch_init_osabi (info, gdbarch);

  /* The hook may have adjusted num_regs, fetch the final value and
     set pc_regnum and sp_regnum now that it has been fixed.  */
  num_regs = gdbarch_num_regs (gdbarch);
  set_gdbarch_pc_regnum (gdbarch, regnum->pc + num_regs);
  set_gdbarch_sp_regnum (gdbarch, MIPS_SP_REGNUM + num_regs);

  /* Unwind the frame.  */
  dwarf2_append_unwinders (gdbarch);
  frame_unwind_append_unwinder (gdbarch, &mips_stub_frame_unwind);
  frame_unwind_append_unwinder (gdbarch, &mips_insn16_frame_unwind);
  frame_unwind_append_unwinder (gdbarch, &mips_micro_frame_unwind);
  frame_unwind_append_unwinder (gdbarch, &mips_insn32_frame_unwind);
  frame_base_append_sniffer (gdbarch, dwarf2_frame_base_sniffer);
  frame_base_append_sniffer (gdbarch, mips_stub_frame_base_sniffer);
  frame_base_append_sniffer (gdbarch, mips_insn16_frame_base_sniffer);
  frame_base_append_sniffer (gdbarch, mips_micro_frame_base_sniffer);
  frame_base_append_sniffer (gdbarch, mips_insn32_frame_base_sniffer);

  if (tdesc_data)
    {
      set_tdesc_pseudo_register_type (gdbarch, mips_pseudo_register_type);
      tdesc_use_registers (gdbarch, info.target_desc, tdesc_data);

      /* Override the normal target description methods to handle our
	 dual real and pseudo registers.  */
      set_gdbarch_register_name (gdbarch, mips_register_name);
      set_gdbarch_register_reggroup_p (gdbarch,
				       mips_tdesc_register_reggroup_p);

      num_regs = gdbarch_num_regs (gdbarch);
      set_gdbarch_num_pseudo_regs (gdbarch, num_regs);
      set_gdbarch_pc_regnum (gdbarch, tdep->regnum->pc + num_regs);
      set_gdbarch_sp_regnum (gdbarch, MIPS_SP_REGNUM + num_regs);
    }

  /* Add ABI-specific aliases for the registers.  */
  if (mips_abi == MIPS_ABI_N32 || mips_abi == MIPS_ABI_N64)
    for (i = 0; i < ARRAY_SIZE (mips_n32_n64_aliases); i++)
      user_reg_add (gdbarch, mips_n32_n64_aliases[i].name,
		    value_of_mips_user_reg, &mips_n32_n64_aliases[i].regnum);
  else
    for (i = 0; i < ARRAY_SIZE (mips_o32_aliases); i++)
      user_reg_add (gdbarch, mips_o32_aliases[i].name,
		    value_of_mips_user_reg, &mips_o32_aliases[i].regnum);

  /* Add some other standard aliases.  */
  for (i = 0; i < ARRAY_SIZE (mips_register_aliases); i++)
    user_reg_add (gdbarch, mips_register_aliases[i].name,
		  value_of_mips_user_reg, &mips_register_aliases[i].regnum);

  for (i = 0; i < ARRAY_SIZE (mips_numeric_register_aliases); i++)
    user_reg_add (gdbarch, mips_numeric_register_aliases[i].name,
		  value_of_mips_user_reg, 
		  &mips_numeric_register_aliases[i].regnum);

  return gdbarch;
}

static void
mips_abi_update (char *ignore_args, int from_tty, struct cmd_list_element *c)
{
  struct gdbarch_info info;

  /* Force the architecture to update, and (if it's a MIPS architecture)
     mips_gdbarch_init will take care of the rest.  */
  gdbarch_info_init (&info);
  gdbarch_update_p (info);
}

/* Print out which MIPS ABI is in use.  */

static void
show_mips_abi (struct ui_file *file,
	       int from_tty,
	       struct cmd_list_element *ignored_cmd,
	       const char *ignored_value)
{
  if (gdbarch_bfd_arch_info (target_gdbarch ())->arch != bfd_arch_mips)
    fprintf_filtered
      (file, 
       "The MIPS ABI is unknown because the current architecture "
       "is not MIPS.\n");
  else
    {
      enum mips_abi global_abi = global_mips_abi ();
      enum mips_abi actual_abi = mips_abi (target_gdbarch ());
      const char *actual_abi_str = mips_abi_strings[actual_abi];

      if (global_abi == MIPS_ABI_UNKNOWN)
	fprintf_filtered
	  (file, 
	   "The MIPS ABI is set automatically (currently \"%s\").\n",
	   actual_abi_str);
      else if (global_abi == actual_abi)
	fprintf_filtered
	  (file,
	   "The MIPS ABI is assumed to be \"%s\" (due to user setting).\n",
	   actual_abi_str);
      else
	{
	  /* Probably shouldn't happen...  */
	  fprintf_filtered (file,
			    "The (auto detected) MIPS ABI \"%s\" is in use "
			    "even though the user setting was \"%s\".\n",
	     actual_abi_str, mips_abi_strings[global_abi]);
	}
    }
}

/* Print out which MIPS compressed ISA encoding is used.  */

static void
show_mips_compression (struct ui_file *file, int from_tty,
		       struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("The compressed ISA encoding used is %s.\n"),
		    value);
}

static void
mips_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  if (tdep != NULL)
    {
      int ef_mips_arch;
      int ef_mips_32bitmode;
      /* Determine the ISA.  */
      switch (tdep->elf_flags & EF_MIPS_ARCH)
	{
	case E_MIPS_ARCH_1:
	  ef_mips_arch = 1;
	  break;
	case E_MIPS_ARCH_2:
	  ef_mips_arch = 2;
	  break;
	case E_MIPS_ARCH_3:
	  ef_mips_arch = 3;
	  break;
	case E_MIPS_ARCH_4:
	  ef_mips_arch = 4;
	  break;
	default:
	  ef_mips_arch = 0;
	  break;
	}
      /* Determine the size of a pointer.  */
      ef_mips_32bitmode = (tdep->elf_flags & EF_MIPS_32BITMODE);
      fprintf_unfiltered (file,
			  "mips_dump_tdep: tdep->elf_flags = 0x%x\n",
			  tdep->elf_flags);
      fprintf_unfiltered (file,
			  "mips_dump_tdep: ef_mips_32bitmode = %d\n",
			  ef_mips_32bitmode);
      fprintf_unfiltered (file,
			  "mips_dump_tdep: ef_mips_arch = %d\n",
			  ef_mips_arch);
      fprintf_unfiltered (file,
			  "mips_dump_tdep: tdep->mips_abi = %d (%s)\n",
			  tdep->mips_abi, mips_abi_strings[tdep->mips_abi]);
      fprintf_unfiltered (file,
			  "mips_dump_tdep: "
			  "mips_mask_address_p() %d (default %d)\n",
			  mips_mask_address_p (tdep),
			  tdep->default_mask_address_p);
    }
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_DEFAULT_FPU_TYPE = %d (%s)\n",
		      MIPS_DEFAULT_FPU_TYPE,
		      (MIPS_DEFAULT_FPU_TYPE == MIPS_FPU_NONE ? "none"
		       : MIPS_DEFAULT_FPU_TYPE == MIPS_FPU_SINGLE ? "single"
		       : MIPS_DEFAULT_FPU_TYPE == MIPS_FPU_DOUBLE ? "double"
		       : "???"));
  fprintf_unfiltered (file, "mips_dump_tdep: MIPS_EABI = %d\n",
		      MIPS_EABI (gdbarch));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_FPU_TYPE = %d (%s)\n",
		      MIPS_FPU_TYPE (gdbarch),
		      (MIPS_FPU_TYPE (gdbarch) == MIPS_FPU_NONE ? "none"
		       : MIPS_FPU_TYPE (gdbarch) == MIPS_FPU_SINGLE ? "single"
		       : MIPS_FPU_TYPE (gdbarch) == MIPS_FPU_DOUBLE ? "double"
		       : "???"));
}

extern initialize_file_ftype _initialize_mips_tdep; /* -Wmissing-prototypes */

void
_initialize_mips_tdep (void)
{
  static struct cmd_list_element *mipsfpulist = NULL;
  struct cmd_list_element *c;

  mips_abi_string = mips_abi_strings[MIPS_ABI_UNKNOWN];
  if (MIPS_ABI_LAST + 1
      != sizeof (mips_abi_strings) / sizeof (mips_abi_strings[0]))
    internal_error (__FILE__, __LINE__, _("mips_abi_strings out of sync"));

  gdbarch_register (bfd_arch_mips, mips_gdbarch_init, mips_dump_tdep);

  mips_pdr_data = register_objfile_data ();

  /* Create feature sets with the appropriate properties.  The values
     are not important.  */
  mips_tdesc_gp32 = allocate_target_description ();
  set_tdesc_property (mips_tdesc_gp32, PROPERTY_GP32, "");

  mips_tdesc_gp64 = allocate_target_description ();
  set_tdesc_property (mips_tdesc_gp64, PROPERTY_GP64, "");

  /* Add root prefix command for all "set mips"/"show mips" commands.  */
  add_prefix_cmd ("mips", no_class, set_mips_command,
		  _("Various MIPS specific commands."),
		  &setmipscmdlist, "set mips ", 0, &setlist);

  add_prefix_cmd ("mips", no_class, show_mips_command,
		  _("Various MIPS specific commands."),
		  &showmipscmdlist, "show mips ", 0, &showlist);

  /* Allow the user to override the ABI.  */
  add_setshow_enum_cmd ("abi", class_obscure, mips_abi_strings,
			&mips_abi_string, _("\
Set the MIPS ABI used by this program."), _("\
Show the MIPS ABI used by this program."), _("\
This option can be set to one of:\n\
  auto  - the default ABI associated with the current binary\n\
  o32\n\
  o64\n\
  n32\n\
  n64\n\
  eabi32\n\
  eabi64"),
			mips_abi_update,
			show_mips_abi,
			&setmipscmdlist, &showmipscmdlist);

  /* Allow the user to set the ISA to assume for compressed code if ELF
     file flags don't tell or there is no program file selected.  This
     setting is updated whenever unambiguous ELF file flags are interpreted,
     and carried over to subsequent sessions.  */
  add_setshow_enum_cmd ("compression", class_obscure, mips_compression_strings,
			&mips_compression_string, _("\
Set the compressed ISA encoding used by MIPS code."), _("\
Show the compressed ISA encoding used by MIPS code."), _("\
Select the compressed ISA encoding used in functions that have no symbol\n\
information available.  The encoding can be set to either of:\n\
  mips16\n\
  micromips\n\
and is updated automatically from ELF file flags if available."),
			mips_abi_update,
			show_mips_compression,
			&setmipscmdlist, &showmipscmdlist);

  /* Let the user turn off floating point and set the fence post for
     heuristic_proc_start.  */

  add_prefix_cmd ("mipsfpu", class_support, set_mipsfpu_command,
		  _("Set use of MIPS floating-point coprocessor."),
		  &mipsfpulist, "set mipsfpu ", 0, &setlist);
  add_cmd ("single", class_support, set_mipsfpu_single_command,
	   _("Select single-precision MIPS floating-point coprocessor."),
	   &mipsfpulist);
  add_cmd ("double", class_support, set_mipsfpu_double_command,
	   _("Select double-precision MIPS floating-point coprocessor."),
	   &mipsfpulist);
  add_alias_cmd ("on", "double", class_support, 1, &mipsfpulist);
  add_alias_cmd ("yes", "double", class_support, 1, &mipsfpulist);
  add_alias_cmd ("1", "double", class_support, 1, &mipsfpulist);
  add_cmd ("none", class_support, set_mipsfpu_none_command,
	   _("Select no MIPS floating-point coprocessor."), &mipsfpulist);
  add_alias_cmd ("off", "none", class_support, 1, &mipsfpulist);
  add_alias_cmd ("no", "none", class_support, 1, &mipsfpulist);
  add_alias_cmd ("0", "none", class_support, 1, &mipsfpulist);
  add_cmd ("auto", class_support, set_mipsfpu_auto_command,
	   _("Select MIPS floating-point coprocessor automatically."),
	   &mipsfpulist);
  add_cmd ("mipsfpu", class_support, show_mipsfpu_command,
	   _("Show current use of MIPS floating-point coprocessor target."),
	   &showlist);

  /* We really would like to have both "0" and "unlimited" work, but
     command.c doesn't deal with that.  So make it a var_zinteger
     because the user can always use "999999" or some such for unlimited.  */
  add_setshow_zinteger_cmd ("heuristic-fence-post", class_support,
			    &heuristic_fence_post, _("\
Set the distance searched for the start of a function."), _("\
Show the distance searched for the start of a function."), _("\
If you are debugging a stripped executable, GDB needs to search through the\n\
program for the start of a function.  This command sets the distance of the\n\
search.  The only need to set it is when debugging a stripped executable."),
			    reinit_frame_cache_sfunc,
			    NULL, /* FIXME: i18n: The distance searched for
				     the start of a function is %s.  */
			    &setlist, &showlist);

  /* Allow the user to control whether the upper bits of 64-bit
     addresses should be zeroed.  */
  add_setshow_auto_boolean_cmd ("mask-address", no_class,
				&mask_address_var, _("\
Set zeroing of upper 32 bits of 64-bit addresses."), _("\
Show zeroing of upper 32 bits of 64-bit addresses."), _("\
Use \"on\" to enable the masking, \"off\" to disable it and \"auto\" to\n\
allow GDB to determine the correct value."),
				NULL, show_mask_address,
				&setmipscmdlist, &showmipscmdlist);

  /* Allow the user to control the size of 32 bit registers within the
     raw remote packet.  */
  add_setshow_boolean_cmd ("remote-mips64-transfers-32bit-regs", class_obscure,
			   &mips64_transfers_32bit_regs_p, _("\
Set compatibility with 64-bit MIPS target that transfers 32-bit quantities."),
			   _("\
Show compatibility with 64-bit MIPS target that transfers 32-bit quantities."),
			   _("\
Use \"on\" to enable backward compatibility with older MIPS 64 GDB+target\n\
that would transfer 32 bits for some registers (e.g. SR, FSR) and\n\
64 bits for others.  Use \"off\" to disable compatibility mode"),
			   set_mips64_transfers_32bit_regs,
			   NULL, /* FIXME: i18n: Compatibility with 64-bit
				    MIPS target that transfers 32-bit
				    quantities is %s.  */
			   &setlist, &showlist);

  /* Debug this files internals.  */
  add_setshow_zuinteger_cmd ("mips", class_maintenance,
			     &mips_debug, _("\
Set mips debugging."), _("\
Show mips debugging."), _("\
When non-zero, mips specific debugging is enabled."),
			     NULL,
			     NULL, /* FIXME: i18n: Mips debugging is
				      currently %s.  */
			     &setdebuglist, &showdebuglist);
}
@


1.576
log
@	include/elf/
	* mips.h (Tag_GNU_MIPS_ABI_FP): Remove comment.
	(Val_GNU_MIPS_ABI_FP_ANY, Val_GNU_MIPS_ABI_FP_DOUBLE,
	Val_GNU_MIPS_ABI_FP_SINGLE, Val_GNU_MIPS_ABI_FP_SOFT,
	Val_GNU_MIPS_ABI_FP_64): New enum.

	bfd/
	* elfxx-mips.c (mips_elf_merge_obj_attributes): Replace hardcoded
	magic numbers with enum values.

	binutils/
	* readelf.c (display_mips_gnu_attribute): Replace hardcoded magic
	numbers with enum values.

	gdb/
	* mips-tdep.c (mips_gdbarch_init): Replace hardcoded magic
	numbers with enum values.
@
text
@d3946 1
a3946 1
      insert_single_step_breakpoint (gdbarch, aspace, breaks[index]);
@


1.575
log
@	* mips-tdep.c (fetch_mips_16): Use unmake_compact_addr.
@
text
@d7913 1
a7913 1
  int elf_fpu_type = 0;
d8238 1
a8238 1
  else if (elf_fpu_type != 0)
d8242 1
a8242 1
	case 1:
d8245 1
a8245 1
	case 2:
d8248 1
a8248 1
	case 3:
@


1.574
log
@	* mips-tdep.c (mips_next_pc): Fix a typo.
@
text
@d2045 2
a2046 1
  pc &= 0xfffffffe;		/* Clear the low order bit.  */
@


1.573
log
@	* mips-tdep.c (micromips_scan_prologue): Fix a typo.
@
text
@d2245 1
a2245 1
   branch will go.  This isnt hard because all the data is available.
@


1.572
log
@	bfd/
	* elfxx-mips.h (_bfd_mips_elf_get_synthetic_symtab): New
	prototype.
	* elf32-mips.c (elf_backend_plt_sym_val): Remove macro.
	(bfd_elf32_get_synthetic_symtab): New macro.
	* elfxx-mips.c (plt_entry): New structure.
	(mips_elf_link_hash_entry): Add use_plt_entry member.
	(mips_elf_link_hash_table): Rename plt_entry_size member to
	plt_mips_entry_size.  Add plt_comp_entry_size, plt_mips_offset,
	plt_comp_offset, plt_got_index entries and plt_header_is_comp
	members.
	(STUB_LW_MICROMIPS, STUB_MOVE_MICROMIPS): New macros.
	(STUB_LUI_MICROMIPS, STUB_JALR_MICROMIPS): Likewise.
	(STUB_ORI_MICROMIPS, STUB_LI16U_MICROMIPS): Likewise.
	(STUB_LI16S_MICROMIPS): Likewise.
	(MICROMIPS_FUNCTION_STUB_NORMAL_SIZE): Likewise.
	(MICROMIPS_FUNCTION_STUB_BIG_SIZE): Likewise.
	(micromips_o32_exec_plt0_entry): New variable.
	(mips16_o32_exec_plt_entry): Likewise.
	(micromips_o32_exec_plt_entry): Likewise.
	(mips_elf_link_hash_newfunc): Initialize use_plt_entry.
	(mips_elf_output_extsym): Update to use gotplt_union's plist
	member rather than offset.
	(mips_elf_gotplt_index): Likewise.  Remove the VxWorks
	restriction.  Use MIPS_ELF_GOT_SIZE to calculate GOT address.
	(mips_elf_count_got_symbols): Update to use gotplt_union's plist
	member rather than offset.
	(mips_elf_calculate_relocation): Handle MIPS16/microMIPS PLT
	entries.
	(_bfd_mips_elf_create_dynamic_sections): Don't set PLT sizes
	here.
	(mips_elf_make_plt_record): New function.
	(_bfd_mips_elf_check_relocs): Update comment.  Record occurences
	of JAL relocations that might need a PLT entry.
	(_bfd_mips_elf_adjust_dynamic_symbol): Update to use
	gotplt_union's plist member rather than offset.  Set individual
	PLT entry sizes here.  Handle MIPS16/microMIPS PLT entries.
	Don't set the symbol's value in the symbol table for PLT
	references here.  Don't set the PLT or PLT GOT section sizes
	here.
	(mips_elf_estimate_stub_size): Handle microMIPS stubs.
	(mips_elf_allocate_lazy_stub): Likewise.
	(mips_elf_lay_out_lazy_stubs): Likewise.  Define a _MIPS_STUBS_
	magic symbol.
	(mips_elf_set_plt_sym_value): New function.
	(_bfd_mips_elf_size_dynamic_sections): Set PLT header size and
	PLT and PLT GOT section sizes here.  Set the symbol values in
	the symbol table for PLT references here.  Handle microMIPS
	annotation of the _PROCEDURE_LINKAGE_TABLE_ magic symbol.
	(_bfd_mips_elf_finish_dynamic_symbol): Update to use
	gotplt_union's plist member rather than offset.  Handle
	MIPS16/microMIPS PLT entries.  Handle microMIPS stubs.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Update to use
	gotplt_union's plist member rather than offset.  Use
	MIPS_ELF_GOT_SIZE to calculate GOT address.
	(mips_finish_exec_plt): Handle microMIPS PLT.  Return status.
	(_bfd_mips_elf_finish_dynamic_sections): Handle result from
	mips_finish_exec_plt.
	(_bfd_mips_elf_link_hash_table_create): Update to use
	gotplt_union's plist member rather than offset.
	(_bfd_mips_elf_get_synthetic_symtab): New function.

	include/elf/
	* mips.h (ELF_ST_IS_MIPS_PLT): Respect STO_MIPS16 setting.
	(ELF_ST_SET_MIPS_PLT): Likewise.

	gdb/
	* mips-tdep.c (mips_elf_make_msymbol_special): Handle MIPS16 and
	microMIPS synthetic symbols.

	ld/
	* emulparams/elf32btsmip.sh: Arrange for .got.plt to be placed
	as close to .plt as possible.
	* scripttempl/elf.sc: Handle $INITIAL_READWRITE_SECTIONS and
	$PLT_NEXT_DATA variables.

	ld/testsuite/
	* ld-mips-elf/jalx-2.dd: Update for microMIPS PLT support.
	* ld-mips-elf/pic-and-nonpic-3a.dd: Update for the _MIPS_STUBS_
	magic symbol.
	* ld-mips-elf/pic-and-nonpic-3b.dd: Likewise.
	* ld-mips-elf/pic-and-nonpic-6-n32.dd: Likewise.
	* ld-mips-elf/pic-and-nonpic-6-n64.dd: Likewise.
	* ld-mips-elf/pic-and-nonpic-6-o32.dd: Likewise.
	* ld-mips-elf/stub-dynsym-1-10000.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-2fe80.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-7fff.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-8000.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-fff0.d: Likewise.
	* ld-mips-elf/tlslib-o32.d: Likewise.

	opcodes/
	* mips-dis.c (is_mips16_plt_tail): New function.
	(print_insn_mips16): Handle MIPS16 PLT entry's GOT slot address
	word.
	(is_compressed_mode_p): Handle MIPS16/microMIPS PLT entries.
@
text
@d2914 1
a2914 1
	    /* Discard LUI $gp is used for PIC code.  */
@


1.571
log
@	* objfiles.h (pc_in_section): New prototype.
	(in_plt_section): Remove name argument, replace prototype with
	static inline function.
	* mips-tdep.h: Include "objfiles.h".
	(in_mips_stubs_section): New function.
	* hppa-tdep.h (gdbarch_tdep): Remove name argument of
	in_solib_call_trampoline member.
	(hppa_in_solib_call_trampoline): Remove name argument.
	* objfiles.c (pc_in_section): New function.
	(in_plt_section): Remove function.
	* mips-linux-tdep.c: Include "objfiles.h".
	(mips_linux_in_dynsym_stub): Call in_mips_stubs_section.  Remove
	name argument.  Return 1 rather than the low 16-bit halfword of
	any instruction examined.
	(mips_linux_in_dynsym_resolve_code): Update
	mips_linux_in_dynsym_stub call accordingly.
	* mips-tdep.c (mips_stub_frame_sniffer): Use in_mips_stubs_section
	rather than an equivalent hand-coded sequence.
	* hppa-hpux-tdep.c (in_opd_section): Remove function.
	(hppa32_hpux_in_solib_call_trampoline): Remove name argument.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.
	(hppa64_hpux_find_global_pointer): Use pc_in_section rather than
	in_opd_section.
	* hppa-tdep.c (hppa_stub_unwind_sniffer): Remove name argument
	on call to tdep->in_solib_call_trampoline.
	(hppa_in_solib_call_trampoline): Remove name argument, update
	according to in_plt_section change.
	(hppa_skip_trampoline_code): Update according to in_plt_section
	change.
	* aarch64-tdep.c (aarch64_stub_unwind_sniffer): Likewise.
	* arm-symbian-tdep.c (arm_symbian_skip_trampoline_code):
	Likewise.
	* arm-tdep.c (arm_stub_unwind_sniffer): Likewise.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Likewise.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Likewise.
	* nios2-tdep.c (nios2_stub_frame_sniffer): Likewise.
	* nto-tdep.c (nto_relocate_section_addresses): Likewise.
	* s390-tdep.c (s390_stub_frame_sniffer): Likewise.
	* sh-tdep.c (sh_stub_unwind_sniffer): Likewise.
	* solib-dsbt.c (dsbt_in_dynsym_resolve_code): Likewise.
	* solib-frv.c (frv_in_dynsym_resolve_code): Likewise.
	* solib-svr4.c (svr4_in_dynsym_resolve_code): Likewise.
	* solib-target.c (solib_target_in_dynsym_resolve_code): Likewise.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise.
	* tic6x-tdep.c (tic6x_stub_unwind_sniffer): Likewise.
@
text
@d346 3
a348 2
   symbols only; in particular synthetic symbols such as for PLT stubs
   have no ELF-private part at all.
d357 1
d359 5
a363 1
  if ((sym->flags & BSF_SYNTHETIC) != 0)
d366 1
a366 1
  if (ELF_ST_IS_MICROMIPS (elfsym->internal_elf_sym.st_other))
d368 1
a368 1
  else if (ELF_ST_IS_MIPS16 (elfsym->internal_elf_sym.st_other))
@


1.570
log
@mips-tdep.c: Wrong signness for local holding PC register.

Addresses on MIPS are signed, and we're indeed using
regcache_cooked_read_signed to read the PC, but, we're passing it the
address of an unsigned variable, which triggers a -Wpointer-sign
warning.  I've chosen to change the variable's type.  I believe this
will end up being the same (though I can't test it).

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* mips-tdep.c (mips_read_pc): Change local 'pc' type to LONGEST.
@
text
@d3591 1
a3591 9
  if (in_plt_section (pc, NULL))
    return 1;

  /* Binutils for MIPS puts lazy resolution stubs into .MIPS.stubs.  */
  s = find_pc_section (pc);

  if (s != NULL
      && strcmp (bfd_get_section_name (s->objfile->obfd, s->the_bfd_section),
		 ".MIPS.stubs") == 0)
@


1.569
log
@alpha-tdep.c/mips-tdep.c: "set heuristic-fence-post" is signed/zinteger.

These commands are currently var_zinteger, hence their control
variable is signed.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* alpha-tdep.c (heuristic_fence_post): Change type to int.
	(alpha_heuristic_proc_start): Adjust to check -1 instead of
	UINT_MAX.
	* mips-tdep.c (heuristic_fence_post): Change type to int.
	(heuristic_proc_start): Adjust to check -1 instead of UINT_MAX.
@
text
@d1248 1
a1248 1
  ULONGEST pc;
@


1.568
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d790 1
a790 1
static unsigned int heuristic_fence_post = 0;
d4024 1
a4024 1
  if (heuristic_fence_post == UINT_MAX || fence < VM_MIN_ADDRESS)
@


1.567
log
@	* mips-tdep.c (mips32_scan_prologue): Reset frame_offset to zero
	if $fp is used as the virtual frame pointer.
@
text
@d1118 1
a1118 1
  struct minimal_symbol *sym;
d1125 2
a1126 2
  if (sym)
    return msymbol_is_mips (sym);
d1136 1
a1136 1
  struct minimal_symbol *sym;
d1143 2
a1144 2
  if (sym)
    return msymbol_is_mips16 (sym);
d1154 1
a1154 1
  struct minimal_symbol *sym;
d1162 2
a1163 2
  if (sym)
    return msymbol_is_micromips (sym);
d1174 1
a1174 1
  struct minimal_symbol *sym;
d1182 1
a1182 1
  if (sym)
d1184 1
a1184 1
      if (msymbol_is_micromips (sym))
d1186 1
a1186 1
      else if (msymbol_is_mips16 (sym))
d3585 1
a3585 1
  struct minimal_symbol *msym;
d3605 3
a3607 3
  if (msym != NULL
      && SYMBOL_LINKAGE_NAME (msym) != NULL
      && strncmp (SYMBOL_LINKAGE_NAME (msym), ".pic.", 5) == 0)
d7629 1
a7629 1
  struct minimal_symbol *msym;
d7638 4
a7641 4
  if (msym == NULL
      || SYMBOL_VALUE_ADDRESS (msym) != pc
      || SYMBOL_LINKAGE_NAME (msym) == NULL
      || strncmp (SYMBOL_LINKAGE_NAME (msym), ".pic.", 5) != 0)
d7645 1
a7645 1
  if (MSYMBOL_SIZE (msym) == 8)
d7649 1
a7649 1
  if (MSYMBOL_SIZE (msym) == 16)
@


1.566
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d3276 1
@


1.565
log
@2012-12-19  Andreas Tobler  <andreast@@neon.andreas.nets>

        * mips-tdep.c (micromips_deal_with_atomic_sequence): Initialize
        branch_bp to keep gcc happy.
@
text
@d3 1
a3 1
   Copyright (C) 1988-2012 Free Software Foundation, Inc.
@


1.564
log
@rename frame_register_read into deprecated_frame_register_read.

gdb/ChangeLog:

        * frame.h (deprecated_frame_register_read): Renames
        frame_register_read.
        * frame.c (deprecated_frame_register_read): Renames
        frame_register_read.  Update all callers.
        * i386-tdep.c: Update all callers of frame_register_read.
        * infcmd.c: Likewise.
        * jit.c: Likewise.
        * mips-tdep.c: Likewise.
        * mt-tdep.c: Likewise.
        * sh64-tdep.c: Likewise.
@
text
@d3799 2
a3800 1
  CORE_ADDR branch_bp; /* Breakpoint at branch instruction's destination.  */
@


1.563
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d6035 1
a6035 1
  if (!frame_register_read (frame, regno, raw_buffer))
d6072 1
a6072 1
      if (!frame_register_read (frame, regno, rare_buffer))
d6305 1
a6305 1
      if (!frame_register_read (frame, regnum, raw_buffer))
@


1.562
log
@	* m2-valprint.c (m2_print_array_contents): Eliminate variable
	ELTLEN and use TYPE_LENGTH directly.
	(m2_val_print): Likewise.
	* m68k-tdep.c (m68k_svr4_extract_return_value): Eliminate
	variable LEN and use TYPE_LENGTH directly.
	(m68k_svr4_store_return_value): Likewise.
	* mips-tdep.c (mips_o32_push_dummy_call): Eliminate variable
	ARGLEN and use TYPE_LENGTH directly.
	(mips_o64_push_dummy_call): Likewise.
	* s390-tdep (s390_function_arg_pass_by_reference): Eliminate
	variable LENGTH and use TYPE_LENGTH directly.
	(s390_function_arg_float): Likewise.
	(s390_function_arg_integer): Likewise.
	(s390_push_dummy_call): Likewise.
	(s390_return_value_convention): Likewise.
	* spu-tdep.c (spu_push_dummy_call): Eliminate LEN and use
	TYPE_LENGTH directly.
@
text
@d1090 1
a1090 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (target_gdbarch);
d6655 1
a6655 1
  if (gdbarch_bfd_arch_info (target_gdbarch)->arch != bfd_arch_mips)
d6663 1
a6663 1
  switch (MIPS_FPU_TYPE (target_gdbarch))
d8684 1
a8684 1
  if (gdbarch_bfd_arch_info (target_gdbarch)->arch != bfd_arch_mips)
d8692 1
a8692 1
      enum mips_abi actual_abi = mips_abi (target_gdbarch);
@


1.561
log
@2012-08-19  Andrew Pinski  <apinski@@cavium.com>

	* mips-tdep.c (is_octeon): New function.
	(is_octeon_bbit_op): New function.
	(mips32_next_pc): Handle Octeon's bbit instructions.
	(mips32_instruction_has_delay_slot): Likewise.

012-08-19  Andrew Pinski  <apinski@@cavium.com>

        * gdb.arch/mips-octeon-bbit.c: New file.
        * gdb.arch/mips-octeon-bbit.exp: New Test.
@
text
@a5176 1
      int arglen = TYPE_LENGTH (arg_type);
d5182 1
a5182 1
      len += align_up (arglen, MIPS32_REGSIZE);
a5704 1
      int arglen = TYPE_LENGTH (arg_type);
d5707 1
a5707 1
      len += align_up (arglen, MIPS64_REGSIZE);
@


1.560
log
@2012-08-19  Andrew Pinski  <apinski@@cavium.com>

	* mips-tdep.c (mips32_next_pc): Fix line spacing of the comment
	before the function.
@
text
@d1469 29
d1550 19
d6998 2
a6999 1
      return (op >> 2 == 5	/* BEQL, BNEL, BLEZL, BGTZL: bits 0101xx  */
@


1.559
log
@2012-08-19  Andrew Pinski  <apinski@@cavium.com>

	* mips-tdep.c (mips32_next_pc): Consolidate calls to itype_op.
@
text
@d1471 1
@


1.558
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@d1478 1
d1482 1
a1482 1
      if (itype_op (inst) >> 2 == 5)
d1485 1
a1485 2
	  op = (itype_op (inst) & 0x03);
	  switch (op)
d1499 1
a1499 1
      else if (itype_op (inst) == 17 && itype_rs (inst) == 8)
d1502 1
a1502 1
      else if (itype_op (inst) == 17 && itype_rs (inst) == 9
d1506 1
a1506 1
      else if (itype_op (inst) == 17 && itype_rs (inst) == 10
d1510 1
a1510 1
      else if (itype_op (inst) == 29)
d1527 1
a1527 1
      switch (op = itype_op (inst) & 0x07)	/* Extract bits 28,27,26.  */
@


1.557
log
@	* mips-tdep.c (mips_push_dummy_code): Handle microMIPS code.
@
text
@d180 1
a180 1
static int mips_debug = 0;
d8882 2
a8883 2
  add_setshow_zinteger_cmd ("mips", class_maintenance,
			    &mips_debug, _("\
d8887 4
a8890 4
			    NULL,
			    NULL, /* FIXME: i18n: Mips debugging is
				     currently %s.  */
			    &setdebuglist, &showdebuglist);
@


1.556
log
@	* mips-tdep.c (mips_pseudo_register_type): Remove tdep local
	variable.
	(mips_eabi_push_dummy_call): Likewise.
	(mips_n32n64_push_dummy_call): Likewise.
	(mips_o32_push_dummy_call): Likewise.
	(mips_o64_push_dummy_call): Likewise.
@
text
@d4200 1
d4202 1
a4202 1
  static gdb_byte nop_insn[] = { 0, 0, 0, 0 };
d4205 7
a4211 1
  *bp_addr = sp - sizeof (nop_insn);
d4220 1
a4220 1
  nop_addr = *bp_addr - sizeof (nop_insn);
@


1.555
log
@	* mips-tdep.c (mips_convert_register_p): Correct coding style.
@
text
@a1006 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
a4233 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
a4640 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
a5096 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
a5625 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
@


1.554
log
@	* mips-tdep.c (mips_pseudo_register_type): Use
	mips_float_register_p.
@
text
@d848 2
a849 2
  return mips_convert_register_float_case_p (gdbarch, regnum, type)
      || mips_convert_register_gpreg_case_p (gdbarch, regnum, type);
@


1.553
log
@	* mips-tdep.c (mips_reg3_to_reg): Optimize storage.
@
text
@d1018 1
a1018 2
  if (rawnum >= mips_regnum (gdbarch)->fp0
      && rawnum < mips_regnum (gdbarch)->fp0 + 32)
@


1.552
log
@	gdb/
	* NEWS: Add microMIPS support and "set mips compression",
	"show mips compression" commands.
	* mips-tdep.h (mips_isa): New enum.
	(gdbarch_tdep): Add mips_isa.
	(mips_pc_is_mips16): Update prototype.
	(mips_pc_is_mips, mips_pc_is_micromips): New prototypes.
	* mips-tdep.c (mips_compression_mips16): New variable.
	(mips_compression_micromips): Likewise.
	(mips_compression_strings): Likewise.
	(mips_compression_string): Likewise.
	(is_mips16_isa, is_micromips_isa): New functions.
	(is_mips16_addr): Rename to...
	(is_compact_addr): ... this.
	(unmake_mips16_addr): Likewise to...
	(unmake_compact_addr): ... this.
	(make_mips16_addr): Likewise to...
	(make_compact_addr): ... this.
	(is_mips_addr, is_mips16_addr, is_micromips_addr): New
	functions.
	(mips_elf_make_msymbol_special): Handle microMIPS code.
	(msymbol_is_special): Rename to...
	(msymbol_is_mips16): ... this.
	(mips_make_symbol_special, mips_pc_is_mips16): Update
	accordingly.
	(msymbol_is_mips, msymbol_is_micromips): New functions.
	(mips16_to_32_reg): Rename to...
	(mips_reg3_to_reg): ... this.
	(mips_pc_is_mips, mips_pc_is_micromips): New functions.
	(mips_pc_isa): Likewise.
	(mips_read_pc, mips_unwind_pc, mips_write_pc): Handle microMIPS
	code.
	(mips_fetch_instruction): Pass return status instead of printing
	an error message if requested.  Handle microMIPS code.  Bail out
	on an invalid ISA.
	(micromips_op): New macro.
	(b0s4_imm, b0s5_imm, b0s5_reg, b0s7_imm, b0s10_imm): Likewise.
	(b1s9_imm, b2s3_cc, b4s2_regl, b5s5_op, b5s5_reg): Likewise.
	(b6s4_op, b7s3_reg): Likewise.
	(b0s6_op, b0s11_op, b0s12_imm, b0s16_imm, b0s26_imm): Likewise.
	(b6s10_ext, b11s5_reg, b12s4_op): Likewise.
	(mips_insn_size): New function.
	(mips32_next_pc): Update mips_fetch_instruction call.
	(micromips_relative_offset7): New function.
	(micromips_relative_offset10): Likewise.
	(micromips_relative_offset16): Likewise.
	(micromips_pc_insn_size): Likewise.
	(micromips_bc1_pc): Likewise.
	(micromips_next_pc): Likewise.
	(unpack_mips16): Update mips_fetch_instruction call.
	(extended_mips16_next_pc): Update according to change to
	mips16_to_32_reg.
	(mips_next_pc): Update mips_pc_is_mips16 call.  Handle microMIPS
	code.
	(mips16_scan_prologue): Update mips_fetch_instruction call.
	Update according to change to mips16_to_32_reg.
	(mips_insn16_frame_sniffer): Update mips_pc_is_mips16 call.
	(mips_insn16_frame_base_sniffer): Likewise.
	(micromips_decode_imm9): New function.
	(micromips_scan_prologue): Likewise.
	(mips_micro_frame_cache): Likewise.
	(mips_micro_frame_this_id): Likewise.
	(mips_micro_frame_prev_register): Likewise.
	(mips_micro_frame_sniffer): Likewise.
	(mips_micro_frame_unwind): New variable.
	(mips_micro_frame_base_address): New function.
	(mips_micro_frame_base): New variable.
	(mips_micro_frame_base_sniffer): New function.
	(mips32_scan_prologue): Update mips_fetch_instruction call.
	(mips_insn32_frame_sniffer): Check for the standard MIPS ISA
	rather than for MIPS16.
	(mips_insn32_frame_base_sniffer): Likewise.
	(mips_addr_bits_remove): Handle microMIPS code.
	(deal_with_atomic_sequence): Rename to...
	(mips_deal_with_atomic_sequence): ... this.  Update the type
	of the variable used to hold an instruction.  Remove the ISA bit
	check.  Update mips_fetch_instruction call.
	(micromips_deal_with_atomic_sequence): New function.
	(deal_with_atomic_sequence): Likewise.
	(mips_about_to_return): Handle microMIPS code.  Update
	mips_fetch_instruction call.
	(heuristic_proc_start): Check for the standard MIPS ISA rather
	than for MIPS16.  Update mips_pc_is_mips16 and
	mips_fetch_instruction calls.  Handle microMIPS code.
	(mips_push_dummy_code): Handle microMIPS code.
	(mips_eabi_push_dummy_call): Likewise.
	(mips_o32_return_value): Update mips_pc_is_mips16 call.
	(mips_o64_push_dummy_call): Handle microMIPS code.
	(mips_o64_return_value): Update mips_pc_is_mips16 call.
	(is_delayed): Remove function.
	(mips_single_step_through_delay): Replace the call to is_delayed
	with mips32_instruction_has_delay_slot.  Correct MIPS16 handling.
	Handle microMIPS code.
	(mips_skip_prologue): Update mips_pc_is_mips16 call.  Handle
	microMIPS code.
	(mips32_in_function_epilogue_p): Update mips_fetch_instruction
	call.
	(micromips_in_function_epilogue_p): New function.
	(mips16_in_function_epilogue_p): Update mips_fetch_instruction
	call.
	(mips_in_function_epilogue_p): Update mips_pc_is_mips16 call.
	Handle microMIPS.
	(gdb_print_insn_mips): Likewise.
	(mips_breakpoint_from_pc): Likewise.
	(mips_remote_breakpoint_from_pc): New function.
	(mips32_instruction_has_delay_slot): Simplify making use of the
	updated mips_fetch_instruction interface.
	(micromips_instruction_has_delay_slot): New function.
	(mips16_instruction_has_delay_slot): Simplify making use of the
	updated mips_fetch_instruction interface.
	(mips_adjust_breakpoint_address): Check for the standard MIPS
	ISA rather than for MIPS16 ISA.  Update for unmake_compact_addr
	calls.  Handle microMIPS code.
	(mips_get_mips16_fn_stub_pc): Update mips_fetch_instruction call.
	(mips_skip_trampoline_code): Handle microMIPS code.
	(global_mips_compression): New function.
	(mips_gdbarch_init): Handle the compressed ISA setting from ELF
	file flags.  Register the microMIPS remote breakpoint handler
	and heuristic frame unwinder.
	(show_mips_compression): New function.
	(_initialize_mips_tdep): Add the "set mips compression" and
	"show mips compression" commands.

	gdb/doc/
	* gdb.texinfo (MIPS): Document "set mips compression" and "show
	mips compression".
	(MIPS Breakpoint Kinds): New subsubsection.
@
text
@d784 1
a784 1
static int mips_reg3_to_reg[8] = { 16, 17, 2, 3, 4, 5, 6, 7 };
@


1.551
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d65 6
d102 14
d269 22
a290 2
/* MIPS16 function addresses are odd (bit 0 is set).  Here are some
   functions to test, set, or clear bit 0 of addresses.  */
d292 2
a293 2
static CORE_ADDR
is_mips16_addr (CORE_ADDR addr)
d298 26
d325 1
a325 1
unmake_mips16_addr (CORE_ADDR addr)
d330 2
d333 1
a333 1
make_mips16_addr (CORE_ADDR addr)
d339 2
a340 2
   marks it as 16-bit function.  The MSB of the minimal symbol's
   "info" field is used for this purpose.
d342 6
a347 3
   gdbarch_elf_make_msymbol_special tests whether an ELF symbol is "special",
   i.e. refers to a 16-bit function, and sets a "special" bit in a
   minimal symbol to mark it as a 16-bit function
d349 2
a350 1
   MSYMBOL_IS_SPECIAL   tests the "special" bit in a minimal symbol  */
d355 17
a371 5
  if (ELF_ST_IS_MIPS16 (((elf_symbol_type *)
			 (sym))->internal_elf_sym.st_other))
    {
      MSYMBOL_TARGET_FLAG_1 (msym) = 1;
    }
d374 2
d377 1
a377 1
msymbol_is_special (struct minimal_symbol *msym)
d382 8
d783 2
a784 2
/* Table to translate MIPS16 register field to actual register number.  */
static int mips16_to_32_reg[8] = { 16, 17, 2, 3, 4, 5, 6, 7 };
d1114 19
d1136 1
a1136 1
mips_pc_is_mips16 (CORE_ADDR memaddr)
d1142 41
a1182 2
     if the function is MIPS16 or normal MIPS.  Otherwise if bit 0 of
     the address is set, assume this is a MIPS16 address.  */
d1185 8
a1192 1
    return msymbol_is_special (sym);
d1194 8
a1201 1
    return is_mips16_addr (memaddr);
d1253 2
a1254 2
  if (is_mips16_addr (pc))
    pc = unmake_mips16_addr (pc);
d1264 2
a1265 2
  if (is_mips16_addr (pc))
    pc = unmake_mips16_addr (pc);
d1275 2
a1276 2
      if (is_mips16_addr (pc))
	pc = unmake_mips16_addr (pc);
d1281 2
a1282 2
	  if (is_mips16_addr (pc))
	    pc = unmake_mips16_addr (pc);
d1317 2
a1318 2
  if (mips_pc_is_mips16 (pc))
    regcache_cooked_write_unsigned (regcache, regnum, make_mips16_addr (pc));
d1320 1
a1320 1
    regcache_cooked_write_unsigned (regcache, regnum, pc);
d1323 2
a1324 2
/* Fetch and return instruction from the specified location.  If the PC
   is odd, assume it's a MIPS16 instruction; otherwise MIPS32.  */
d1327 2
a1328 1
mips_fetch_instruction (struct gdbarch *gdbarch, CORE_ADDR addr)
d1335 1
a1335 1
  if (mips_pc_is_mips16 (addr))
d1337 2
d1340 8
a1347 1
      addr = unmake_mips16_addr (addr);
a1348 2
  else
    instlen = MIPS_INSN32_SIZE;
d1350 2
d1353 5
a1357 1
    memory_error (status, addr);
d1378 57
d1479 1
a1479 1
  inst = mips_fetch_instruction (gdbarch, pc);
d1649 270
d2053 2
a2054 2
	nexthalf = mips_fetch_instruction (gdbarch, pc + 2);  /* low bit
								 still set.  */
d2108 1
a2108 1
	reg = get_frame_register_signed (frame, mips16_to_32_reg[upk.regx]);
d2120 1
a2120 1
	reg = get_frame_register_signed (frame, mips16_to_32_reg[upk.regx]);
d2153 1
a2153 1
	      reg = mips16_to_32_reg[upk.regx];
d2193 1
a2193 1
   The MIPS32 and MIPS16 variants are quite different.  */
d2197 3
a2199 1
  if (mips_pc_is_mips16 (pc))
d2201 2
d2319 2
a2320 1
      inst = (unsigned short) mips_fetch_instruction (gdbarch, cur_pc);
d2351 1
a2351 1
	  reg = mips16_to_32_reg[(inst & 0x700) >> 8];
d2357 1
a2357 1
	  reg = mips16_to_32_reg[(inst & 0xe0) >> 5];
d2385 1
a2385 1
	  reg = mips16_to_32_reg[(inst & 0xe0) >> 5];
d2391 1
a2391 1
	  reg = mips16_to_32_reg[(inst & 0xe0) >> 5];
d2543 425
a2967 3
	{
	  set_reg_offset (gdbarch, this_cache, 16, sp + offset);
	  offset -= mips_abi_regsize (gdbarch);
d2969 2
d2972 3
a2974 2
      /* Check if A0-A3 were pushed on the stack.  */
      for (reg = MIPS_A0_REGNUM + 3; reg > MIPS_A0_REGNUM + 3 - astatic; reg--)
d2976 2
a2977 2
	  set_reg_offset (gdbarch, this_cache, reg, sp + offset);
	  offset -= mips_abi_regsize (gdbarch);
d2979 2
d2986 1
a2986 1
        (get_frame_register_signed (this_frame,
d2988 1
a2988 1
         + frame_offset - frame_adjust);
d2990 2
a2991 2
         be able to get rid of the assignment below, evetually.  But it's
         still needed for now.  */
d2994 1
a2994 1
        = this_cache->saved_regs[gdbarch_num_regs (gdbarch) + MIPS_RA_REGNUM];
d2999 3
a3001 1
     instruction immediately after the last one we scanned.  */
d3003 1
a3003 1
    end_prologue_addr = cur_pc;
d3008 1
a3008 1
/* Heuristic unwinder for 16-bit MIPS instruction set (aka MIPS16).
d3010 1
a3010 1
   mips_insn32 unwinder.  */
d3013 1
a3013 1
mips_insn16_frame_cache (struct frame_info *this_frame, void **this_cache)
d3020 1
d3032 1
a3032 1
      start_addr = heuristic_proc_start (gdbarch, pc);
d3038 1
a3038 1
    mips16_scan_prologue (gdbarch, start_addr, pc, this_frame, *this_cache);
d3040 1
a3040 1
  
d3050 2
a3051 2
mips_insn16_frame_this_id (struct frame_info *this_frame, void **this_cache,
			   struct frame_id *this_id)
d3053 2
a3054 2
  struct mips_frame_cache *info = mips_insn16_frame_cache (this_frame,
							   this_cache);
d3062 2
a3063 2
mips_insn16_frame_prev_register (struct frame_info *this_frame,
				 void **this_cache, int regnum)
d3065 2
a3066 2
  struct mips_frame_cache *info = mips_insn16_frame_cache (this_frame,
							   this_cache);
d3071 2
a3072 2
mips_insn16_frame_sniffer (const struct frame_unwind *self,
			   struct frame_info *this_frame, void **this_cache)
d3074 1
d3076 2
a3077 1
  if (mips_pc_is_mips16 (pc))
d3082 1
a3082 1
static const struct frame_unwind mips_insn16_frame_unwind =
d3086 2
a3087 2
  mips_insn16_frame_this_id,
  mips_insn16_frame_prev_register,
d3089 1
a3089 1
  mips_insn16_frame_sniffer
d3093 2
a3094 2
mips_insn16_frame_base_address (struct frame_info *this_frame,
				void **this_cache)
d3096 2
a3097 2
  struct mips_frame_cache *info = mips_insn16_frame_cache (this_frame,
							   this_cache);
d3101 1
a3101 1
static const struct frame_base mips_insn16_frame_base =
d3103 4
a3106 4
  &mips_insn16_frame_unwind,
  mips_insn16_frame_base_address,
  mips_insn16_frame_base_address,
  mips_insn16_frame_base_address
d3110 1
a3110 1
mips_insn16_frame_base_sniffer (struct frame_info *this_frame)
d3112 1
d3114 3
a3116 2
  if (mips_pc_is_mips16 (pc))
    return &mips_insn16_frame_base;
d3185 2
a3186 1
      inst = (unsigned long) mips_fetch_instruction (gdbarch, cur_pc);
d3370 1
a3370 1
   unwinder.  */
d3435 1
a3435 1
  if (! mips_pc_is_mips16 (pc))
d3471 1
a3471 1
  if (! mips_pc_is_mips16 (pc))
d3608 2
a3609 2
  if (is_mips16_addr (addr))
    addr = unmake_mips16_addr (addr);
a3631 5
/* Instructions used during single-stepping of atomic sequences.  */
#define LL_OPCODE 0x30
#define LLD_OPCODE 0x34
#define SC_OPCODE 0x38
#define SCD_OPCODE 0x3c
d3638 7
d3646 2
a3647 2
deal_with_atomic_sequence (struct gdbarch *gdbarch,
			   struct address_space *aspace, CORE_ADDR pc)
d3652 1
a3652 1
  unsigned long insn;
d3658 1
a3658 4
  if (pc & 0x01)
    return 0;

  insn = mips_fetch_instruction (gdbarch, loc);
d3669 1
a3669 1
      insn = mips_fetch_instruction (gdbarch, loc);
d3744 171
d3947 2
a3948 2
     called for MIPS16 functions.  */
  gdb_assert (!mips_pc_is_mips16 (pc));
d3950 1
a3950 1
  insn = mips_fetch_instruction (gdbarch, pc);
d3978 1
a3978 1
  instlen = mips_pc_is_mips16 (pc) ? MIPS_INSN16_SIZE : MIPS_INSN32_SIZE;
d4023 1
a4023 1
    else if (mips_pc_is_mips16 (start_pc))
d4035 1
a4035 1
	inst = mips_fetch_instruction (gdbarch, start_pc);
d4040 2
a4041 1
		inst = mips_fetch_instruction (gdbarch, start_pc - instlen);
d4059 61
d4309 3
a4311 1
	  if (mips_pc_is_mips16 (addr))
d4314 1
a4314 1
				    make_mips16_addr (addr));
a4316 2
	  else
	    val = value_contents (arg);
d5408 1
a5409 1
  int mips16 = mips_pc_is_mips16 (func_addr);
d5710 1
a5710 1
	  if (mips_pc_is_mips16 (addr))
d5713 1
a5713 1
				    make_mips16_addr (addr));
d5876 1
a5877 1
  int mips16 = mips_pc_is_mips16 (func_addr);
a6318 16
/* Is this a branch with a delay slot?  */

static int
is_delayed (unsigned long insn)
{
  int i;
  for (i = 0; i < NUMOPCODES; ++i)
    if (mips_opcodes[i].pinfo != INSN_MACRO
	&& (insn & mips_opcodes[i].mask) == mips_opcodes[i].match)
      break;
  return (i < NUMOPCODES
	  && (mips_opcodes[i].pinfo & (INSN_UNCOND_BRANCH_DELAY
				       | INSN_COND_BRANCH_DELAY
				       | INSN_COND_BRANCH_LIKELY)));
}

d6325 5
a6329 1
  gdb_byte buf[MIPS_INSN32_SIZE];
d6331 6
a6336 2
  /* There is no branch delay slot on MIPS16.  */
  if (mips_pc_is_mips16 (pc))
d6339 6
a6344 8
  if (!breakpoint_here_p (get_frame_address_space (frame), pc + 4))
    return 0;

  if (!safe_frame_unwind_memory (frame, pc, buf, sizeof buf))
    /* If error reading memory, guess that it is not a delayed
       branch.  */
    return 0;
  return is_delayed (extract_unsigned_integer (buf, sizeof buf, byte_order));
d6383 1
a6383 1
  if (mips_pc_is_mips16 (pc))
d6385 2
d6413 1
a6413 1
	  inst = mips_fetch_instruction (gdbarch, pc);
d6429 101
d6551 1
a6551 1
	  inst = mips_fetch_instruction (gdbarch, pc);
d6575 1
a6575 1
  if (mips_pc_is_mips16 (pc))
d6577 2
d6727 2
d6733 1
a6733 1
  if (mips_pc_is_mips16 (memaddr))
d6735 2
d6739 2
a6740 1
  memaddr &= (info->mach == bfd_mach_mips16 ? ~1 : ~3);
d6791 2
d6795 1
a6795 1
      if (mips_pc_is_mips16 (*pcptr))
d6798 1
a6798 1
	  *pcptr = unmake_mips16_addr (*pcptr);
d6802 16
d6846 1
a6846 1
      if (mips_pc_is_mips16 (*pcptr))
d6849 1
a6849 1
	  *pcptr = unmake_mips16_addr (*pcptr);
d6853 16
d6889 37
a6932 1
  gdb_byte buf[MIPS_INSN32_SIZE];
d6939 1
a6939 1
  status = target_read_memory (addr, buf, MIPS_INSN32_SIZE);
a6942 1
  inst = mips_fetch_instruction (gdbarch, addr);
d6986 67
a7055 1
  gdb_byte buf[MIPS_INSN16_SIZE];
d7059 1
a7059 1
  status = target_read_memory (addr, buf, MIPS_INSN16_SIZE);
a7062 1
  inst = mips_fetch_instruction (gdbarch, addr);
d7151 1
a7151 1
  if (!mips_pc_is_mips16 (bpaddr))
d7164 1
d7168 1
a7168 1
      boundary = unmake_mips16_addr (boundary);
d7173 3
d7178 3
d7186 1
a7186 1
	  if (unmake_mips16_addr (addr) == boundary)
d7188 2
a7189 2
	  addr -= 2;
	  if (i == 1 && mips16_instruction_has_delay_slot (gdbarch, addr, 0))
d7194 1
a7194 2
	  else if (i > 1
		   && mips16_instruction_has_delay_slot (gdbarch, addr, 1))
d7339 1
a7339 1
      ULONGEST inst = mips_fetch_instruction (gdbarch, pc);
d7641 2
a7642 2
	  if (is_mips16_addr (pc))
	    pc = unmake_mips16_addr (pc);
d7649 2
a7650 2
	  if (is_mips16_addr (pc))
	    pc = unmake_mips16_addr (pc);
d7657 2
a7658 2
	  if (is_mips16_addr (pc))
	    pc = unmake_mips16_addr (pc);
d7812 17
d7866 1
d8160 11
d8276 1
d8502 2
d8568 1
d8573 1
d8667 10
d8793 17
@


1.550
log
@	* mips-tdep.h (mips_write_pc): New prototype.
	* mips-tdep.c (mips_write_pc): Make external, add description.
	* mips-linux-tdep.c (mips_linux_write_pc): Use mips_write_pc,
	add description.
@
text
@a1578 1
	CORE_ADDR offset;
a4960 1
  int offset;
d5697 1
a5697 1
  CORE_ADDR prev_addr, next_addr;
a5750 1
      struct minimal_symbol *sym;
@


1.549
log
@	* mips-tdep.c (mips_read_pc): Use gdbarch_pc_regnum instead of
	mips_regnum->pc.
	(mips_unwind_pc, mips_write_pc): Likewise.
	(mips_gdbarch_init): Remove a comment on gdbarch_pc_regnum and
	gdbarch_read_pc.
@
text
@d1144 3
a1146 1
static void
@


1.548
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@d1083 1
d1085 1
a1085 1
  int regnum = mips_regnum (get_regcache_arch (regcache))->pc;
d1097 1
a1097 2
  pc = frame_unwind_register_signed
	 (next_frame, gdbarch_num_regs (gdbarch) + mips_regnum (gdbarch)->pc);
d1147 2
a1148 1
  int regnum = mips_regnum (get_regcache_arch (regcache))->pc;
a7109 2
  /* FIXME: cagney/2003-11-15: For MIPS, hasn't gdbarch_pc_regnum been
     replaced by gdbarch_read_pc?  */
@


1.547
log
@	* mips-tdep.c (mips_push_dummy_code): Correct description typo.
@
text
@d3335 1
a3335 1
mips_eabi_return_value (struct gdbarch *gdbarch, struct type *func_type,
d3725 1
a3725 1
mips_n32n64_return_value (struct gdbarch *gdbarch, struct type *func_type,
d3893 14
d3997 2
a3998 2
         left.  O32/O64 targets also pass the FP in the integer
         registers so also round up normal registers.  */
d4006 9
a4014 8
         treated specially.  On 32-bit architectures, doubles
         are passed in register pairs; the even register gets
         the low word, and the odd register gets the high word.
         On O32/O64, the first two floating point arguments are
         also copied to general registers, because MIPS16 functions
         don't use float registers for arguments.  This duplication of
         arguments in general registers can't hurt non-MIPS16 functions
         because those registers are normally skipped.  */
d4021 2
a4022 2
	      int low_offset = gdbarch_byte_order (gdbarch)
			       == BFD_ENDIAN_BIG ? 4 : 0;
d4025 2
a4026 3
	      /* Write the low word of the double to the even register(s).  */
	      regval = extract_unsigned_integer (val + low_offset,
						 4, byte_order);
d4029 2
a4030 1
				    float_argreg, phex (regval, 4));
d4032 2
a4033 1
					      float_argreg++, regval);
d4039 2
a4040 3
	      /* Write the high word of the double to the odd register(s).  */
	      regval = extract_unsigned_integer (val + 4 - low_offset,
						 4, byte_order);
d4043 2
a4044 1
				    float_argreg, phex (regval, 4));
d4046 2
a4047 2
					      float_argreg++, regval);

d4222 1
a4222 1
mips_o32_return_value (struct gdbarch *gdbarch, struct type *func_type,
d4226 1
d4228 2
d4231 1
d4239 6
a4244 2
      /* A single-precision floating-point value.  It fits in the
         least significant part of FP0.  */
d4246 25
a4270 7
	fprintf_unfiltered (gdb_stderr, "Return float in $fp0\n");
      mips_xfer_register (gdbarch, regcache,
			  (gdbarch_num_regs (gdbarch)
			   + mips_regnum (gdbarch)->fp0),
			  TYPE_LENGTH (type),
			  gdbarch_byte_order (gdbarch),
			  readbuf, writebuf, 0);
d4276 7
a4282 3
      /* A double-precision floating-point value.  The most
         significant part goes in FP1, and the least significant in
         FP0.  */
d4284 14
a4297 2
	fprintf_unfiltered (gdb_stderr, "Return float in $fp1/$fp0\n");
      switch (gdbarch_byte_order (gdbarch))
d4299 36
a4334 13
	case BFD_ENDIAN_LITTLE:
	  mips_xfer_register (gdbarch, regcache,
			      (gdbarch_num_regs (gdbarch)
			       + mips_regnum (gdbarch)->fp0 + 0),
			      4, gdbarch_byte_order (gdbarch),
			      readbuf, writebuf, 0);
	  mips_xfer_register (gdbarch, regcache,
			      (gdbarch_num_regs (gdbarch)
			       + mips_regnum (gdbarch)->fp0 + 1),
			      4, gdbarch_byte_order (gdbarch),
			      readbuf, writebuf, 4);
	  break;
	case BFD_ENDIAN_BIG:
d4336 1
a4336 2
			      (gdbarch_num_regs (gdbarch)
			       + mips_regnum (gdbarch)->fp0 + 1),
d4340 1
a4340 2
			      (gdbarch_num_regs (gdbarch)
			       + mips_regnum (gdbarch)->fp0 + 0),
a4342 3
	  break;
	default:
	  internal_error (__FILE__, __LINE__, _("bad switch"));
d4538 8
a4545 8
         treated specially.  On 32-bit architectures, doubles
         are passed in register pairs; the even register gets
         the low word, and the odd register gets the high word.
         On O32/O64, the first two floating point arguments are
         also copied to general registers, because MIPS16 functions
         don't use float registers for arguments.  This duplication of
         arguments in general registers can't hurt non-MIPS16 functions
         because those registers are normally skipped.  */
d4690 1
a4690 1
mips_o64_return_value (struct gdbarch *gdbarch, struct type *func_type,
d4694 1
d4696 2
d4699 1
d4706 6
a4711 2
      /* A floating-point value.  It fits in the least significant
         part of FP0.  */
d4713 25
a4737 7
	fprintf_unfiltered (gdb_stderr, "Return float in $fp0\n");
      mips_xfer_register (gdbarch, regcache,
			  (gdbarch_num_regs (gdbarch)
			   + mips_regnum (gdbarch)->fp0),
			  TYPE_LENGTH (type),
			  gdbarch_byte_order (gdbarch),
			  readbuf, writebuf, 0);
@


1.546
log
@mips: Switch inferior function calls to ON_STACK method.

This patch switches the mips code to use the ON_STACK method
for function calls instead of AT_SYMBOL, which we want to remove.

gdb/ChangeLog:

        * mips-tdep.c (mips_push_dummy_code): New function.
        (mips_gdbarch_init): Set the gdbarch call_dummy_location to
        ON_STACK and install mips_push_dummy_code as our gdbarch
        push_dummy_code routine.
@
text
@d3012 1
a3012 1
/* Implement the "push_dummy_call" gdbarch method.  */
@


1.545
log
@	gdb/
	* infrun.c (handle_inferior_event): Move the check for return
	trampolines ahead of the check for function trampolines.
	* mips-tdep.h (MIPS_S2_REGNUM, MIPS_GP_REGNUM): New macros.
	* mips-tdep.c (mips_str_mips16_call_stub): New variable.
	(mips_str_mips16_ret_stub): Likewise.
	(mips_str_call_fp_stub): Likewise.
	(mips_str_call_stub): Likewise.
	(mips_str_fn_stub): Likewise.
	(mips_str_pic): Likewise.
	(mips_in_frame_stub): New function.
	(mips_unwind_pc): Return the return address rather than the PC
	if the PC of an intermediate frame is inside a call thunk.
	(mips_is_stub_suffix): New function.
	(mips_is_stub_mode): Likewise.
	(mips_get_mips16_fn_stub_pc): Likewise.
	(mips_skip_mips16_trampoline_code): Update to handle all the
	currently generated stub types.  Don't recurse into __fn_stub
	thunks.  Remove heuristics to handle stubs beyond etext/_etext.
	Use cooked register accesses.
	(mips_in_return_stub): Reintroduce function.
	(mips_skip_trampoline_code): Traverse trampolines recursively.
	(mips_gdbarch_init): Handle MIPS16 return trampolines.

	gdb/testsuite/
	* gdb.arch/mips16-thunks-inmain.c: New file.
	* gdb.arch/mips16-thunks-main.c: New file.
	* gdb.arch/mips16-thunks-sin.c: New file.
	* gdb.arch/mips16-thunks-sinfrob.c: New file.
	* gdb.arch/mips16-thunks-sinfrob16.c: New file.
	* gdb.arch/mips16-thunks-sinmain.c: New file.
	* gdb.arch/mips16-thunks-sinmips16.c: New file.
	* gdb.arch/mips16-thunks.exp: New file.
@
text
@d3012 32
d6941 2
a6942 4
  /* NOTE: cagney/2003-08-05: Eventually call dummy location will be
     replaced by a command, and all targets will default to on stack
     (regardless of the stack's execute status).  */
  set_gdbarch_call_dummy_location (gdbarch, AT_SYMBOL);
@


1.544
log
@	* mips-tdep.c (mips_about_to_return): Remove dead MIPS16 support
	code.  Handle JR.HB correctly.
@
text
@d1038 39
d1094 1
a1094 1
  ULONGEST pc;
d1100 19
d5685 186
a5870 2
/* If PC is in a mips16 call or return stub, return the address of the target
   PC, which is either the callee or the caller.  There are several
d5873 2
a5874 2
   * If the PC is in __mips16_ret_{d,s}f, this is a return stub and the
   target PC is in $31 ($ra).
d5876 11
a5886 5
   and the target PC is in $2.
   * If the PC at the start of __mips16_call_stub_{s,d}f_{0..10}, i.e.
   before the jal instruction, this is effectively a call stub
   and the target PC is in $2.  Otherwise this is effectively
   a return stub and the target PC is in $18.
d5888 2
a5889 1
   See the source code for the stubs in gcc/config/mips/mips16.S for
d5896 1
d5898 1
a5898 1
  CORE_ADDR start_addr;
d5904 13
a5916 7
  /* If the PC is in __mips16_ret_{d,s}f, this is a return stub and the
     target PC is in $31 ($ra).  */
  if (strcmp (name, "__mips16_ret_sf") == 0
      || strcmp (name, "__mips16_ret_df") == 0)
    return get_frame_register_signed (frame, MIPS_RA_REGNUM);

  if (strncmp (name, "__mips16_call_stub_", 19) == 0)
d5920 3
a5922 2
      if (name[19] >= '0' && name[19] <= '9')
	return get_frame_register_signed (frame, 2);
d5924 2
a5925 2
      /* If the PC at the start of __mips16_call_stub_{s,d}f_{0..10}, i.e.
         before the jal instruction, this is effectively a call stub
d5928 3
a5930 1
      else if (name[19] == 's' || name[19] == 'd')
d5933 4
a5936 44
	    {
	      /* Check if the target of the stub is a compiler-generated
	         stub.  Such a stub for a function bar might have a name
	         like __fn_stub_bar, and might look like this:
	         mfc1    $4,$f13
	         mfc1    $5,$f12
	         mfc1    $6,$f15
	         mfc1    $7,$f14
	         la      $1,bar   (becomes a lui/addiu pair)
	         jr      $1
	         So scan down to the lui/addi and extract the target
	         address from those two instructions.  */

	      CORE_ADDR target_pc = get_frame_register_signed (frame, 2);
	      int i;

	      /* See if the name of the target function is  __fn_stub_*.  */
	      if (find_pc_partial_function (target_pc, &name, NULL, NULL) ==
		  0)
		return target_pc;
	      if (strncmp (name, "__fn_stub_", 10) != 0
		  && strcmp (name, "etext") != 0
		  && strcmp (name, "_etext") != 0)
		return target_pc;

	      /* Scan through this _fn_stub_ code for the lui/addiu pair.
	         The limit on the search is arbitrarily set to 20
	         instructions.  FIXME.  */
	      for (i = 0, pc = 0; i < 20; i++, target_pc += MIPS_INSN32_SIZE)
		{
		  ULONGEST inst = mips_fetch_instruction (gdbarch, target_pc);
		  CORE_ADDR addr = inst;

		  if ((inst & 0xffff0000) == 0x3c010000)	/* lui $at */
		    pc = (((addr & 0xffff) ^ 0x8000) - 0x8000) << 16;
								/* high word */
		  else if ((inst & 0xffff0000) == 0x24210000)	/* addiu $at */
		    return pc + ((addr & 0xffff) ^ 0x8000) - 0x8000;
								/* low word */
		}

	      /* Couldn't find the lui/addui pair, so return stub address.  */
	      return target_pc;
	    }
d5939 3
a5941 2
	       address is in $r18.  */
	    return get_frame_register_signed (frame, 18);
d5943 2
d5946 68
a6013 1
  return 0;			/* not a stub */
d6076 1
d6078 13
d6092 17
a6108 11
  target_pc = mips_skip_mips16_trampoline_code (frame, pc);
  if (target_pc)
    return target_pc;

  target_pc = find_solib_trampoline_target (frame, pc);
  if (target_pc)
    return target_pc;

  target_pc = mips_skip_pic_trampoline_code (frame, pc);
  if (target_pc)
    return target_pc;
d6110 1
a6110 1
  return 0;
d6953 10
@


1.543
log
@	* mips-tdep.c
	(is_mips16_addr, unmake_mips16_addr, make_mips16_addr): Group
	with the other MIPS16 helpers.
@
text
@d2766 10
a2775 10
  if (mips_pc_is_mips16 (pc))
    /* This mips16 case isn't necessarily reliable.  Sometimes the compiler
       generates a "jr $ra"; other times it generates code to load
       the return address from the stack to an accessible register (such
       as $a3), then a "jr" using that register.  This second case
       is almost impossible to distinguish from an indirect jump
       used for switch statements, so we don't even try.  */
    return mips_fetch_instruction (gdbarch, pc) == 0xe820;	/* jr $ra */
  else
    return mips_fetch_instruction (gdbarch, pc) == 0x3e00008;	/* jr $ra */
@


1.542
log
@	* mips-tdep.c (mips_n32n64_return_value): Fix coding style.
	(mips_o32_return_value): Likewise.
	(mips_o64_return_value): Likewise.
@
text
@a205 21
/* MIPS16 function addresses are odd (bit 0 is set).  Here are some
   functions to test, set, or clear bit 0 of addresses.  */

static CORE_ADDR
is_mips16_addr (CORE_ADDR addr)
{
  return ((addr) & 1);
}

static CORE_ADDR
unmake_mips16_addr (CORE_ADDR addr)
{
  return ((addr) & ~(CORE_ADDR) 1);
}

static CORE_ADDR
make_mips16_addr (CORE_ADDR addr)
{
  return ((addr) | (CORE_ADDR) 1);
}

d249 21
@


1.541
log
@	* mips-tdep.c (mips_float_register_p): New function.
	(mips_convert_register_float_case_p): Use mips_float_register_p.
	(mips_register_type): Likewise.
	(mips_print_register): Likewise.
	(print_gp_register_row): Likewise.
	(mips_print_registers_info): Likewise.
@
text
@d3675 2
a3676 2
			  gdbarch_num_regs (gdbarch)
			  + mips_regnum (gdbarch)->fp0,
d3680 2
a3681 2
			  gdbarch_num_regs (gdbarch)
			  + mips_regnum (gdbarch)->fp0 + 2,
d3694 2
a3695 2
			  gdbarch_num_regs (gdbarch)
			  + mips_regnum (gdbarch)->fp0,
d4134 2
a4135 2
			  gdbarch_num_regs (gdbarch)
			    + mips_regnum (gdbarch)->fp0,
d4153 3
a4155 3
			      gdbarch_num_regs (gdbarch)
				+ mips_regnum (gdbarch)->fp0 +
			      0, 4, gdbarch_byte_order (gdbarch),
d4158 2
a4159 2
			      gdbarch_num_regs (gdbarch)
				+ mips_regnum (gdbarch)->fp0 + 1,
d4165 2
a4166 2
			      gdbarch_num_regs (gdbarch)
				+ mips_regnum (gdbarch)->fp0 + 1,
d4170 2
a4171 2
			      gdbarch_num_regs (gdbarch)
				+ mips_regnum (gdbarch)->fp0 + 0,
d4541 2
a4542 2
			  gdbarch_num_regs (gdbarch)
			    + mips_regnum (gdbarch)->fp0,
@


1.540
log
@	* mips-tdep.c (mips_elf_make_msymbol_special): Fix identification
	of mips16 symbols.
@
text
@d182 12
d732 1
a732 4
	  && (regnum % gdbarch_num_regs (gdbarch))
		>= mips_regnum (gdbarch)->fp0
	  && (regnum % gdbarch_num_regs (gdbarch))
		< mips_regnum (gdbarch)->fp0 + 32
d855 1
a855 3
  if ((regnum % gdbarch_num_regs (gdbarch)) >= mips_regnum (gdbarch)->fp0
      && (regnum % gdbarch_num_regs (gdbarch))
	 < mips_regnum (gdbarch)->fp0 + 32)
d4771 1
a4771 1
  if (TYPE_CODE (register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d4840 1
a4840 2
      if (TYPE_CODE (register_type (gdbarch, regnum)) ==
	  TYPE_CODE_FLT)
d4879 1
a4879 2
      if (TYPE_CODE (register_type (gdbarch, regnum)) ==
	  TYPE_CODE_FLT)
d4934 1
a4934 2
	  if (TYPE_CODE (register_type (gdbarch, regnum)) ==
	      TYPE_CODE_FLT)
@


1.539
log
@	* mips-tdep.c (mips_skip_pic_trampoline_code): Correct sign
	extension in jump target calculation.
@
text
@d271 2
a272 1
  if (((elf_symbol_type *) (sym))->internal_elf_sym.st_other == STO_MIPS16)
@


1.538
log
@	* mips-tdep.c (mips32_next_pc): Handle JALX.
@
text
@d5771 2
a5772 2
	return (((stub_words[0] & 0x0000ffff) << 16)
		+ (stub_words[2] & 0x0000ffff));
@


1.537
log
@Fix ARI violations in mips-linux-nat.c and mips-tdep.c

gdb/ChangeLog:

        * mips-linux-nat.c (mips_linux_read_description): Add missing i18n
        marker.
        * mips-tdep.c (mips_linux_reg_names): Improve comment to avoid ARI
        violation.
@
text
@d1206 10
a1307 8
	  /* FIXME case JALX : */
	  {
	    unsigned long reg;
	    reg = jtype_target (inst) << 2;
	    pc = reg + ((pc + 4) & ~(CORE_ADDR) 0x0fffffff) + 1;  /* yes, +1 */
	    /* Add 1 to indicate 16 bit mode - Invert ISA mode */
	  }
	  break;		/* The new PC will be alternate mode */
@


1.536
log
@	* mips-tdep.c (mips32_scan_prologue): Correct indentation.
@
text
@d431 1
a431 1
/* Names of Linux registers.  */
@


1.535
log
@	* mips-tdep.c (mips_gdbarch_init): Only set pc_regnum and
	sp_regnum once the gdbarch_init_osabi hook has been called.
@
text
@d2272 4
a2275 4
       {
         /* These instructions are part of the prologue, but we don't
            need to do anything special to handle them.  */
       }
d2282 11
a2292 11
               && (high_word == 0x3c01 /* lui $at,n */
                   || high_word == 0x3c08 /* lui $t0,n */
                   || high_word == 0x3421 /* ori $at,$at,n */
                   || high_word == 0x3508 /* ori $t0,$t0,n */
                   || high_word == 0x3401 /* ori $at,$zero,n */
                   || high_word == 0x3408 /* ori $t0,$zero,n */
                  ))
       {
	 if (end_prologue_addr == 0)
	   load_immediate_bytes += MIPS_INSN32_SIZE;		/* FIXME!  */
       }
d2294 15
a2308 15
       {
         /* This instruction is not an instruction typically found
            in a prologue, so we must have reached the end of the
            prologue.  */
         /* FIXME: brobecker/2004-10-10: Can't we just break out of this
            loop now?  Why would we need to continue scanning the function
            instructions?  */
         if (end_prologue_addr == 0)
           end_prologue_addr = cur_pc;

	 /* Check for branches and jumps.  For now, only jump to
	    register are caught (i.e. returns).  */
	 if ((itype_op (inst) & 0x07) == 0 && rtype_funct (inst) == 8)
	   in_delay_slot = 1;
       }
@


1.534
log
@	* mips-tdep.c (mips32_bc1_pc): New function.
	(mips32_next_pc): Handle BC1ANY2F, BC1ANY2T, BC1ANY4F, BC1ANY4T,
	BPOSGE32 and BPOSGE64 instructions.
	(deal_with_atomic_sequence): Likewise.
	(mips32_instruction_has_delay_slot): Likewise.
@
text
@a6420 4
  /* FIXME: cagney/2003-11-15: For MIPS, hasn't gdbarch_pc_regnum been
     replaced by gdbarch_read_pc?  */
  set_gdbarch_pc_regnum (gdbarch, regnum->pc + num_regs);
  set_gdbarch_sp_regnum (gdbarch, MIPS_SP_REGNUM + num_regs);
d6649 8
@


1.533
log
@	gdb/
	* features/mips-dsp.xml: New file.
	* features/mips64-dsp.xml: New file.
	* features/mips-dsp-linux.xml: New file.
	* features/mips64-dsp-linux.xml: New file.
	* features/Makefile (WHICH): Add mips-dsp-linux and
	mips64-dsp-linux.
	(mips-dsp-expedite, mips64-dsp-expedite): New variables.
	* features/mips-dsp-linux.c: New file.
	* features/mips64-dsp-linux.c: New file.
	* regformats/mips-dsp-linux.dat: New file.
	* regformats/mips64-dsp-linux.dat: New file.
	* mips-linux-nat.c (mips_linux_register_addr): Handle DSP
	registers.
	(mips64_linux_register_addr): Likewise.
	(mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Update call to
	mips64_linux_regsets_fetch_registers.
	(mips64_linux_store_registers): Update call to
	mips64_linux_regsets_store_registers.
	(mips_linux_read_description): Probe for DSP registers.
	(_initialize_mips_linux_nat): Call initialize_tdesc_mips_dsp_linux
	and initialize_tdesc_mips64_dsp_linux.
	* mips-linux-tdep.c (supply_gregset, mips64_supply_gregset):
	Remove padding of no longer used embedded register slots.
	* mips-linux-tdep.h (DSP_BASE, DSP_CONTROL): New macros.
	(MIPS_RESTART_REGNUM): Redefine enum value.
	* mips-tdep.c (mips_generic_reg_names): Remove trailing null
	strings.
	(mips_tx39_reg_names): Likewise.
	(mips_linux_reg_names): New array of register names for Linux
	targets.
	(mips_register_name): Check for a null pointer in
	mips_processor_reg_names and return an empty string.
	(mips_register_type): Exclude embedded registers for the IRIX
	and Linux ABIs.
	(mips_pseudo_register_type): Likewise.  Use dynamic numbers to
	refer to FP registers, LO, HI, BadVAddr, Cause and PC.  Handle
	DSP registers.
	(mips_stab_reg_to_regnum): Handle DSP accumulators.
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum): Likewise.
	(mips_gdbarch_init): Likewise.  Initialize internal register
	indices for the Linux ABI.  Use dynamic numbers to refer to
	registers, as applicable, while parsing the target description.
	* mips-tdep.h (struct mips_regnum): Add dspacc/dspctl offsets.

	gdb/doc/
	* gdb.texinfo (MIPS Features): Add org.gnu.gdb.mips.dsp.

	gdb/gdbserver/
	* linux-low.h (linux_target_ops): Add regset_bitmap member.
	* linux-low.c (use_linux_regsets): New macro.
	[!HAVE_LINUX_REGSETS] (regsets_fetch_inferior_registers): Likewise.
	[!HAVE_LINUX_REGSETS] (regsets_store_inferior_registers): Likewise.
	(linux_register_in_regsets): New function.
	(usr_fetch_inferior_registers): Skip registers covered by
	regsets.
	(usr_store_inferior_registers): Likewise.
	(usr_fetch_inferior_registers): New macro.
	(usr_store_inferior_registers): Likewise.
	(linux_fetch_registers): Handle mixed regset/non-regset targets.
	(linux_store_registers): Likewise.
	* linux-mips-low.c (init_registers_mips_dsp_linux): New
	prototype.
	(init_registers_mips64_dsp_linux): Likewise.
	(init_registers_mips_linux): New macro.
	(init_registers_mips_dsp_linux): Likewise.
	(mips_dsp_num_regs): Likewise.
	(DSP_BASE, DSP_CONTROL): New fallback macros.
	(mips_base_regs): New macro.
	(mips_regmap): Use it.  Fix the size.
	(mips_dsp_regmap): New variable.
	(mips_dsp_regset_bitmap): Likewise.
	(mips_arch_setup): New function.
	(mips_cannot_fetch_register): Use the_low_target.regmap rather
	than mips_regmap.
	(mips_cannot_store_register): Likewise.
	(the_low_target): Update .arch_setup, .num_regs and .regmap
	initializers.  Add .regset_bitmap initializer.
	* linux-arm-low.c (the_low_target): Add .regset_bitmap
	initializer.
	* linux-bfin-low.c (the_low_target): Likewise.
	* linux-cris-low.c (the_low_target): Likewise.
	* linux-crisv32-low.c (the_low_target): Likewise.
	* linux-ia64-low.c (the_low_target): Likewise.
	* linux-m32r-low.c (the_low_target): Likewise.
	* linux-m68k-low.c (the_low_target): Likewise.
	* linux-ppc-low.c (the_low_target): Likewise.
	* linux-s390-low.c (the_low_target): Likewise.
	* linux-sh-low.c (the_low_target): Likewise.
	* linux-sparc-low.c (the_low_target): Likewise.
	* linux-tic6x-low.c (the_low_target): Likewise.
	* linux-x86-low.c (the_low_target): Likewise.
	* linux-xtensa-low.c (the_low_target): Likewise.
	* configure.srv <mips*-*-linux*>: Add mips-dsp-linux.o and
	mips64-dsp-linux.o to srv_regobj.  Add mips-dsp-linux.xml,
	mips64-dsp-linux.xml, mips-dsp.xml and mips64-dsp.xml to
	srv_xmlfiles.
	* Makefile.in (mips-dsp-linux.o, mips-dsp-linux.c): New targets.
	(mips64-dsp-linux.o, mips64-dsp-linux.c): Likewise.

	gdb/testsuite/
	* gdb.xml/tdesc-regs.exp: Add "mips-dsp.xml" to the list of MIPS
	core registers.
@
text
@d1135 30
d1197 9
a1205 14
	{
	  int tf = itype_rt (inst) & 0x01;
	  int cnum = itype_rt (inst) >> 2;
	  int fcrcs =
	    get_frame_register_signed (frame,
				       mips_regnum (get_frame_arch (frame))->
						fp_control_status);
	  int cond = ((fcrcs >> 24) & 0xfe) | ((fcrcs >> 23) & 0x01);

	  if (((cond >> cnum) & 0x01) == tf)
	    pc += mips32_relative_offset (inst) + 4;
	  else
	    pc += 8;
	}
d1264 19
d2665 3
a2667 1
	  is_branch = ((itype_rt (insn) & 0xc) == 0); /* B{LT,GE}Z* */
d2683 5
d5387 2
d5397 7
a5403 3
    return (op >> 2 == 5	/* BEQL, BNEL, BLEZL, BGTZL: bits 0101xx  */
	    || op == 29		/* JALX: bits 011101  */
	    || (op == 17 && itype_rs (inst) == 8));
d5405 5
d5419 3
a5421 2
	op = itype_rt (inst);	/* branch condition  */
	return (op & 0xc) == 0;
d5424 2
@


1.532
log
@	* mips-tdep.c (mips32_instruction_has_delay_slot): New function.
	(mips16_instruction_has_delay_slot): Likewise.
	(mips_segment_boundary): Likewise.
	(mips_adjust_breakpoint_address): Likewise.
	(mips_gdbarch_init): Use mips_adjust_breakpoint_address.
@
text
@d393 1
a393 3
  "fsr", "fir", "" /*"fp" */ , "",
  "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "",
d419 1
a419 1
  "", "", "config", "cache", "debug", "depc", "epc", ""
d431 10
d495 3
a497 1
      return tdep->mips_processor_reg_names[rawnum - 32];
d867 2
d871 7
a877 3
      if (regnum >= (gdbarch_num_regs (gdbarch)
		     + mips_regnum (gdbarch)->fp_control_status)
	  && regnum <= gdbarch_num_regs (gdbarch) + MIPS_LAST_EMBED_REGNUM)
d916 2
a917 1
  if (rawnum >= MIPS_EMBED_FP0_REGNUM && rawnum < MIPS_EMBED_FP0_REGNUM + 32)
a921 11
  if (rawnum >= MIPS_EMBED_FP0_REGNUM + 32 && rawnum <= MIPS_LAST_EMBED_REGNUM)
    {
      /* The pseudo/cooked view of embedded registers is always
	 32-bit, even if the target transfers 64-bit values for them.
	 New targets relying on XML descriptions should only transfer
	 the necessary 32 bits, but older versions of GDB expected 64,
	 so allow the target to provide 64 bits without interfering
	 with the displayed type.  */
      return builtin_type (gdbarch)->builtin_int32;
    }

d927 2
a928 1
      if (rawnum == MIPS_SP_REGNUM || rawnum == MIPS_EMBED_BADVADDR_REGNUM)
d930 1
a930 1
      else if (rawnum == MIPS_EMBED_PC_REGNUM)
d935 9
a943 1
      && rawnum >= MIPS_ZERO_REGNUM && rawnum <= MIPS_EMBED_PC_REGNUM)
d946 14
d5747 2
d5772 2
d5913 57
d6004 1
a6004 1
					  MIPS_EMBED_LO_REGNUM, "lo");
d6006 1
a6006 1
					  MIPS_EMBED_HI_REGNUM, "hi");
d6008 1
a6008 1
					  MIPS_EMBED_PC_REGNUM, "pc");
d6026 1
a6026 2
					  MIPS_EMBED_BADVADDR_REGNUM,
					  "badvaddr");
d6030 1
a6030 1
					  MIPS_EMBED_CAUSE_REGNUM, "cause");
d6051 1
a6051 2
					    i + MIPS_EMBED_FP0_REGNUM,
					    mips_fprs[i]);
d6054 6
a6059 3
					  MIPS_EMBED_FP0_REGNUM + 32, "fcsr");
      valid_p &= tdesc_numbered_register (feature, tdesc_data,
					  MIPS_EMBED_FP0_REGNUM + 33, "fir");
d6067 36
d6105 1
d6354 13
a6366 60
  /* Fill in the OS dependant register numbers and names.  */
  {
    const char **reg_names;
    struct mips_regnum *regnum = GDBARCH_OBSTACK_ZALLOC (gdbarch,
							 struct mips_regnum);
    if (tdesc_has_registers (info.target_desc))
      {
	regnum->lo = MIPS_EMBED_LO_REGNUM;
	regnum->hi = MIPS_EMBED_HI_REGNUM;
	regnum->badvaddr = MIPS_EMBED_BADVADDR_REGNUM;
	regnum->cause = MIPS_EMBED_CAUSE_REGNUM;
	regnum->pc = MIPS_EMBED_PC_REGNUM;
	regnum->fp0 = MIPS_EMBED_FP0_REGNUM;
	regnum->fp_control_status = 70;
	regnum->fp_implementation_revision = 71;
	num_regs = MIPS_LAST_EMBED_REGNUM + 1;
	reg_names = NULL;
      }
    else if (info.osabi == GDB_OSABI_IRIX)
      {
	regnum->fp0 = 32;
	regnum->pc = 64;
	regnum->cause = 65;
	regnum->badvaddr = 66;
	regnum->hi = 67;
	regnum->lo = 68;
	regnum->fp_control_status = 69;
	regnum->fp_implementation_revision = 70;
	num_regs = 71;
	reg_names = mips_irix_reg_names;
      }
    else
      {
	regnum->lo = MIPS_EMBED_LO_REGNUM;
	regnum->hi = MIPS_EMBED_HI_REGNUM;
	regnum->badvaddr = MIPS_EMBED_BADVADDR_REGNUM;
	regnum->cause = MIPS_EMBED_CAUSE_REGNUM;
	regnum->pc = MIPS_EMBED_PC_REGNUM;
	regnum->fp0 = MIPS_EMBED_FP0_REGNUM;
	regnum->fp_control_status = 70;
	regnum->fp_implementation_revision = 71;
	num_regs = 90;
	if (info.bfd_arch_info != NULL
	    && info.bfd_arch_info->mach == bfd_mach_mips3900)
	  reg_names = mips_tx39_reg_names;
	else
	  reg_names = mips_generic_reg_names;
      }
    /* FIXME: cagney/2003-11-15: For MIPS, hasn't gdbarch_pc_regnum been
       replaced by gdbarch_read_pc?  */
    set_gdbarch_pc_regnum (gdbarch, regnum->pc + num_regs);
    set_gdbarch_sp_regnum (gdbarch, MIPS_SP_REGNUM + num_regs);
    set_gdbarch_fp0_regnum (gdbarch, regnum->fp0);
    set_gdbarch_num_regs (gdbarch, num_regs);
    set_gdbarch_num_pseudo_regs (gdbarch, num_regs);
    set_gdbarch_register_name (gdbarch, mips_register_name);
    set_gdbarch_virtual_frame_pointer (gdbarch, mips_virtual_frame_pointer);
    tdep->mips_processor_reg_names = reg_names;
    tdep->regnum = regnum;
  }
@


1.531
log
@	* blockframe.c (find_pc_partial_function_gnu_ifunc): Change type of
	"name" parameter to const char ** from char **.  All callers updated.
	(find_pc_partial_function): Ditto.
	(cache_pc_function_name): Change type to const char * from char *.
	* symtab.h ((find_pc_partial_function_gnu_ifunc): Update.
	(find_pc_partial_function): Update.
	* alpha-tdep.h (struct gdbarch_tdep, member pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	All uses updated.
	* arch-utils.c (generic_in_solib_return_trampoline): Change
	type of "name" parameter to const char * from char *.
	* arch-utils.h (generic_in_solib_return_trampoline): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* gdbarch.sh (in_solib_return_trampoline): Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Update.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Update.
	* m32r-linux-tdep.c (m32r_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* skip.c (skip_function_pc): Ditto.
	* sparc-sol2-tdep.c (sparc_sol2_pc_in_sigtramp): Ditto.
	* sparc-tdep.h (sparc_sol2_pc_in_sigtramp): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_pc_in_sigtramp): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_pc_in_sigtramp): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_pc_in_sigtramp): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_pc_in_sigtramp): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_pc_in_sigtramp): Ditto.
	* nbsd-tdep.c (nbsd_pc_in_sigtramp): Similary for "func_name".
	* nbsd-tdep.h (nbsd_pc_in_sigtramp): Update.
@
text
@d5296 230
d6463 2
@


1.530
log
@gdb/
	Code cleanup: Make 1440 bytes of data segment read-only.
	* arch-utils.c (endian_enum): Make it const char *const [].
	* arm-tdep.c (fp_model_strings, arm_abi_strings, arm_mode_strings):
	Likewise.
	* breakpoint.c (always_inserted_enums): Likewise.
	* cli/cli-cmds.c (script_ext_enums): Likewise.
	* cli/cli-decode.c (add_setshow_enum_cmd, complete_on_enum): Make the
	enumlist parameter const char *const *.
	* cli/cli-decode.h (struct cmd_list_element): Make the enums field
	const char *const *.
	* command.h (complete_on_enum, add_setshow_enum_cmd): Make the enumlist
	parameter const char *const *.
	* cris-tdep.c (cris_modes): Make it const char *const [].
	* filesystem.c (target_file_system_kinds): Likewise.
	* i386-tdep.c (valid_flavors, valid_conventions): Likewise.
	* infrun.c (follow_fork_mode_kind_names, follow_exec_mode_names)
	(can_use_displaced_stepping_enum, scheduler_enums)
	(exec_direction_names): Likewise.
	* language.c (_initialize_language): Make the type_or_range_names and
	case_sensitive_names variables const char *const [].
	* mips-tdep.c (mips_abi_strings): Make it const char *const [].
	* python/python.c (python_excp_enums): Likewise.
	* remote.c (interrupt_sequence_modes): Likewise.
	* rs6000-tdep.c (powerpc_vector_strings): Likewise.
	* serial.c (logbase_enums): Likewise.
	* sh-tdep.c (sh_cc_enum): Likewise.
	* stack.c (print_frame_arguments_choices, print_entry_values_choices):
	Likewise.
	* symtab.c (multiple_symbols_modes): Likewise.
	* tui/tui-win.c (tui_border_kind_enums, tui_border_mode_enums):
	Likewise.
	* utils.c (internal_problem_modes): Likewise.
@
text
@d5316 1
a5316 1
  char *name;
@


1.529
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d85 1
a85 1
static const char *mips_abi_strings[] = {
@


1.528
log
@	* mips-tdep.c (mips_skip_mips16_trampoline_code): Sign-extend
	address chunks retrieved from decoded lui/addiu pairs.
@
text
@d3 1
a3 3
   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011 Free Software Foundation, Inc.
@


1.528.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1988-2012 Free Software Foundation, Inc.
@


1.527
log
@	* mips-tdep.c (extended_offset): Correct calculation.
	(unpack_mips16): Correct bitfield positions used for extraction
	of the immediate argument; fix sign-extension of same.
	(extended_mips16_next_pc): Correct B instruction's offset
	calculation.  Correct register decoding of the BEQZ and BNEZ
	as well as jump-register instructions.  Handle compact jumps.
@
text
@a5358 1
	      ULONGEST inst;
d5375 3
a5377 1
		  inst = mips_fetch_instruction (gdbarch, target_pc);
d5379 2
a5380 1
		    pc = (inst << 16) & 0xffff0000;		/* high word */
d5382 2
a5383 1
		    return pc | (inst & 0xffff);		/* low word */
@


1.526
log
@	* mips-tdep.c (mips32_scan_prologue): Only update the immediate
	load adjustment if still within the prologue.
@
text
@d1322 1
a1322 1
  value = (extension >> 21) & 0x3f;	/* Extract 15:11.  */
d1324 1
a1324 1
  value |= (extension >> 16) & 0x1f;	/* Extract 10:5.  */
d1364 2
a1365 3
	    value = extended_offset (extension);
	    value = value << 11;	/* rom for the original value */
	    value |= inst & 0x7ff;	/* eleven bits from instruction */
d1370 1
a1370 1
	    /* FIXME : Consider sign extension.  */
d1385 2
a1386 9
	    value = extended_offset (extension);
	    value = value << 8;		/* from the original instruction */
	    value |= inst & 0xff;	/* eleven bits from instruction */
	    regx = (extension >> 8) & 0x07;	/* or i8 funct */
	    if (value & 0x4000)		/* Test the sign bit, bit 26.  */
	      {
		value &= ~0x3fff;	/* Remove the sign bit.  */
		value = -value;
	      }
d1390 2
a1391 8
	    value = inst & 0xff;	/* 8 bits */
	    regx = (inst >> 8) & 0x07;	/* or i8 funct */
	    /* FIXME: Do sign extension, this format needs it.  */
	    if (value & 0x80)	/* THIS CONFUSES ME.  */
	      {
		value &= 0xef;	/* Remove the sign bit.  */
		value = -value;
	      }
d1394 1
d1440 1
a1440 7
	offset = upk.offset;
	if (offset & 0x800)
	  {
	    offset &= 0xeff;
	    offset = -offset;
	  }
	pc += (offset << 1) + 2;
d1460 1
a1460 1
	reg = get_frame_register_signed (frame, upk.regx);
d1472 1
a1472 1
	reg = get_frame_register_signed (frame, upk.regx);
d1504 4
a1507 15
	    switch (upk.regy)
	      {
	      case 0:
		reg = upk.regx;
		break;
	      case 1:
		reg = 31;
		break;		/* Function return instruction.  */
	      case 2:
		reg = upk.regx;
		break;
	      default:
		reg = 31;
		break;		/* BOGUS Guess */
	      }
@


1.525
log
@	* mips-tdep.c (mips32_next_pc): Fix floating point condition
	code mask.
@
text
@d2249 2
a2250 1
          load_immediate_bytes += MIPS_INSN32_SIZE;     	/* FIXME!  */
@


1.524
log
@	* mips-tdep.c (deal_with_atomic_sequence): Fix the handling
	of BLTZ* and BGEZ* instructions.
@
text
@d1147 1
a1147 1
	  int cond = ((fcrcs >> 24) & 0x0e) | ((fcrcs >> 23) & 0x01);
@


1.523
log
@	* mips-tdep.c (mips_pc_is_mips16): Reverse the order of checks
	performed to determine whether an address refers to standard
	MIPS or MIPS16 code.
	(mips16_next_pc): Use mips_pc_is_mips16 instead of
	is_mips16_addr.
@
text
@d2623 1
a2623 1
	  is_branch = ((itype_rt (insn) & 0xc0) == 0); /* B{LT,GE}Z* */
@


1.522
log
@	* mips-tdep.c (extended_offset): Fix formatting.
@
text
@d992 4
a995 7
  /* If bit 0 of the address is set, assume this is a MIPS16 address.  */
  if (is_mips16_addr (memaddr))
    return 1;

  /* A flag indicating that this is a MIPS16 function is stored by elfread.c in
     the high bit of the info field.  Use this to decide if the function is
     MIPS16 or normal MIPS.  */
d1000 1
a1000 1
    return 0;
d1579 1
a1579 1
  if (is_mips16_addr (pc))
@


1.521
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d1324 2
a1325 1
  value = (extension >> 21) & 0x3f;	/* * extract 15:11 */
d1327 1
a1327 1
  value |= (extension >> 16) & 0x1f;	/* extract 10:5 */
d1329 2
a1330 1
  value |= extension & 0x01f;	/* extract 4:0 */
@


1.520
log
@	gdb/
	* dwarf2loc.c (read_pieced_value): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	(write_pieced_value): Handle get_frame_register_bytes returning
	that the register piece is unavailable/optimized out when doing a
	read-modify write of a bitfield.
	* findvar.c (value_from_register): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	* frame.c (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.  Throw error on bad debug info.  Use
	frame_register instead of frame_register_read, to fill in the new
	arguments.
	* frame.h (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.
	* valops.c: (value_assign): Adjust, and handle
	get_frame_register_bytes failing.
	* spu-tdep.c: Include exceptions.h.
	(spu_software_single_step): Adjust, and handle
	get_frame_register_bytes failing.
	(spu_get_longjmp_target): Ditto.
	* gdbarch.sh (register_to_value): Change to return int.  New
	parameters `optimizedp' and `unavailablep'.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_register_to_value): Adjust to new
	gdbarch_register_to_value interface.
	* i387-tdep.c (i387_register_to_value): Ditto.
	* i387-tdep.h (i387_register_to_value): Ditto.
	* alpha-tdep.c (alpha_register_to_value): Ditto.
	* ia64-tdep.c (ia64_register_to_value): Ditto.
	* m68k-tdep.c (m68k_register_to_value): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* rs6000-tdep.c (rs6000_register_to_value): Ditto.
@
text
@d2031 1
d2385 1
d2510 1
@


1.519
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d740 1
a740 1
static void
d742 2
a743 1
			struct type *type, gdb_byte *to)
d751 10
d765 9
a773 4
      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	get_frame_register_bytes (frame, regnum, 8 - len, len, to);
      else
	get_frame_register_bytes (frame, regnum, 0, len, to);
@


1.518
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d567 1
a567 1
static void
d575 1
a575 1
    regcache_raw_read (regcache, rawnum, buf);
d580 1
a580 1
	regcache_raw_read_part (regcache, rawnum, 0, 4, buf);
d585 6
a590 2
	  regcache_raw_read_signed (regcache, rawnum, &regval);
	  store_signed_integer (buf, 4, byte_order, regval);
@


1.517
log
@	gdb/
	* mips-tdep.c (mips_print_register): Use get_frame_register_value
	and val_print_scalar_formatted.
@
text
@d3141 2
a3142 2
	      /* Compute the the offset into the stack at which we
	         will copy the next parameter.
d3533 2
a3534 2
	      /* Compute the the offset into the stack at which we
	         will copy the next parameter.
d4013 2
a4014 2
	      /* Compute the the offset into the stack at which we
	         will copy the next parameter.
d4421 2
a4422 2
	      /* Compute the the offset into the stack at which we
	         will copy the next parameter.
d5315 1
a5315 1
   and the the target PC is in $2.  Otherwise this is effectively
d5347 1
a5347 1
         and the the target PC is in $2.  Otherwise this is effectively
@


1.516
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* m2-exp.y: Comment cleanup, mostly periods and spaces.
	* m2-lang.c: Ditto.
	* m2-typeprint.c: Ditto.
	* m2-valprint.c: Ditto.
	* m32c-tdep.c: Ditto.
	* m32r-linux-nat.c: Ditto.
	* m32r-rom.c: Ditto.
	* m32r-tdep.c: Ditto.
	* m32r-tdep.h: Ditto.
	* m68hc11-tdep.c: Ditto.
	* m58klinux-nat.c: Ditto.
	* m68k-tdep.c: Ditto.
	* m88k-tdep.c: Ditto.
	* m88k-tdep.h: Ditto.
	* machoread.c: Ditto.
	* macrocmd.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* mdebugread.h: Ditto.
	* memattr.c: Ditto.
	* memattr.h: Ditto.
	* memory-map.h: Ditto.
	* mep-tdep.c: Ditto.
	* microblaze-rom.c: Ditto.
	* microblaze-tdep.c: Ditto.
	* minsyms.c: Ditto.
	* mips-irix-tdep.c: Ditto.
	* mips-linux-nat.c: Ditto.
	* mips-linux-tdep.c: Ditto.
	* mips-linux-tdep.h: Ditto.
	* mipsnbsd-nat.c: Ditto.
	* mipsnbsd-tdep.c: Ditto.
	* mipsread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mips-tdep.h: Ditto.
	* mn10300-linux-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* mn10300-tdep.h: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* moxie-tdep.c: Ditto.
	* moxie-tdep.h: Ditto.
	* mt-tdep.c: Ditto.
@
text
@a4685 1
  gdb_byte raw_buffer[MAX_REGISTER_SIZE];
d4688 1
d4696 2
a4697 2
  /* Get the data in raw format.  */
  if (!frame_register_read (frame, regnum, raw_buffer))
a4714 6
  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    offset =
      register_size (gdbarch, regnum) - register_size (gdbarch, regnum);
  else
    offset = 0;

d4716 5
a4720 3
  print_scalar_formatted (raw_buffer + offset,
			  register_type (gdbarch, regnum), &opts, 0,
			  file);
@


1.515
log
@run copyright.sh for 2011.
@
text
@d188 2
a189 1
#define MIPS_LAST_FP_ARG_REGNUM(gdbarch) (gdbarch_tdep (gdbarch)->mips_last_fp_arg_regnum)
d191 2
a192 1
#define MIPS_LAST_ARG_REGNUM(gdbarch) (gdbarch_tdep (gdbarch)->mips_last_arg_regnum)
d238 1
a238 1
/* Return the currently configured (or set) saved register size. */
d375 1
a375 1
/* The list of available "set mips " and "show mips " commands */
d729 2
a730 1
mips_convert_register_p (struct gdbarch *gdbarch, int regnum, struct type *type)
d917 1
a917 1
/* Should the upper word of 64-bit addresses be zeroed? */
d933 2
a934 1
      internal_error (__FILE__, __LINE__, _("mips_mask_address_p: bad switch"));
d972 1
a972 1
  /* If bit 0 of the address is set, assume this is a MIPS16 address. */
d987 1
a987 1
   all registers should be sign extended for simplicity? */
d1068 1
a1068 1
/* These the fields of 32 bit mips instructions */
d1100 2
a1101 1
  if ((inst & 0xe0000000) != 0)	/* Not a special, jump or branch instruction */
d1138 1
a1138 1
	pc += 4;		/* Not a branch, next instruction is easy */
d1141 1
a1141 1
    {				/* This gets way messy */
d1143 2
a1144 2
      /* Further subdivide into SPECIAL, REGIMM and other */
      switch (op = itype_op (inst) & 0x07)	/* extract bits 28,27,26 */
d1152 1
a1152 1
	      /* Set PC to that address */
d1171 1
a1171 1
	case 1:		/* REGIMM */
d1206 1
a1206 1
	    /* Upper four bits get never changed... */
d1214 1
a1214 1
	    pc = reg + ((pc + 4) & ~(CORE_ADDR) 0x0fffffff) + 1;	/* yes, +1 */
d1254 4
a1257 5
   mips 16 variant, but fortunately, there fewer instructions. We have to cope
   ith extensions for 16 bit instructions and a pair of actual 32 bit instructions.
   We dont want to set a single step instruction on the extend instruction
   either.
 */
d1261 1
a1261 2
   and their extensions      extItype,extritype,extI8type
 */
d1288 1
a1288 1
   then, only the fields which are involved in instruction extension */
d1292 1
a1292 1
  unsigned int regx;		/* Function in i8 type */
d1306 1
a1306 1
  value |= (extension >> 16) & 0x1f;	/* extrace 10:5 */
d1324 1
a1324 1
  pc &= 0xfffffffe;		/* clear the low order bit */
d1352 1
a1352 1
	    /* FIXME : Consider sign extension */
d1361 1
a1361 1
      {				/* A register identifier and an offset */
d1363 1
a1363 1
	   immediate value is of a different length */
d1368 1
a1368 1
	    value = value << 8;	/* from the original instruction */
d1371 1
a1371 1
	    if (value & 0x4000)	/* test the sign bit , bit 26 */
d1373 1
a1373 1
		value &= ~0x3fff;	/* remove the sign bit */
d1381 2
a1382 2
	    /* FIXME: Do sign extension , this format needs it */
	    if (value & 0x80)	/* THIS CONFUSES ME */
d1384 1
a1384 1
		value &= 0xef;	/* remove the sign bit */
d1398 2
a1399 1
	nexthalf = mips_fetch_instruction (gdbarch, pc + 2);	/* low bit still set */
d1443 2
a1444 1
    case 3:			/* JAL , JALX - Watch out, these are 32 bit instruction */
d1450 1
a1450 1
	  pc = pc & ~0x01;	/* Clear low bit, indicate 32 bit mode */
d1511 1
a1511 1
		break;		/* Function return instruction */
d1528 1
a1528 1
         that. */
d1555 1
a1555 1
   branch will go. This isnt hard because all the data is available.
d1608 1
a1608 1
		int is_signed)	/* is the imm field signed? */
d1644 1
a1644 1
  CORE_ADDR frame_addr = 0;	/* Value of $r17, used as frame pointer */
d1649 1
a1649 1
  unsigned short prev_inst = 0;	/* saved copy of previous instruction */
d1677 1
a1677 1
      /* Fetch and decode the instruction.   */
d1698 1
a1698 1
	  if (offset < 0)	/* negative stack adjustment? */
d1754 1
a1754 1
	entry_inst = inst;	/* save for later processing */
d1757 1
a1757 1
	  save_inst = inst;	/* save for later processing */
d1783 1
a1783 1
     and can calculate what the old SP must have been. */
d1921 1
a1921 1
         be able to get rid of the assignment below, evetually. But it's
d2064 1
a2064 1
/* Analyze the function prologue from START_PC to LIMIT_PC. Builds
d2075 2
a2076 1
  CORE_ADDR frame_addr = 0; /* Value of $r30. Used by gcc for frame-pointer */
d2107 1
a2107 1
      /* Fetch the instruction.   */
d2115 1
a2115 1
      if (high_word == 0x27bd	/* addiu $sp,$sp,-i */
d2119 1
a2119 1
	  if (low_word & 0x8000)	/* negative stack adjustment? */
d2155 1
a2155 1
                  /* FP > SP + frame_size. This may be because of
d2185 1
a2185 1
                  /* FP > SP + frame_size. This may be because of
d2217 1
a2217 1
         subu $sp,$sp,[$at,$t0]. These instructions could also
d2280 1
a2280 1
     skipped some load immediate instructions. Undo the skipping
d2598 1
a2598 1
	    return 0; /* fallback to the standard single-step code. */
d2605 1
a2605 1
	  return 0; /* fallback to the standard single-step code. */
d2646 1
a2646 1
     placed (branch instruction's destination) in the atomic sequence */
d2680 1
a2680 1
   end of a function. */
d2724 1
a2724 1
  /* search back for previous return */
d2776 1
a2776 1
	   extend -n followed by 'addiu sp,+n' or 'daddiu sp,+n'  */
d2820 1
a2820 1
   arguments into integer registers. */
d2837 1
a2837 1
   passed.  Return 1 if this type must be aligned to a doubleword boundary. */
d2927 2
a2928 1
			    "mips_eabi_push_dummy_call: struct_return reg=%d %s\n",
d3078 1
a3078 1
		     promoted to int before being stored? */
d3332 2
a3333 1
			    "mips_n32n64_push_dummy_call: struct_return reg=%d %s\n",
d3433 1
a3433 1
		     promoted to int before being stored? */
d3784 2
a3785 1
			    "mips_o32_push_dummy_call: struct_return reg=%d %s\n",
d3845 2
a3846 1
	      regcache_cooked_write_unsigned (regcache, float_argreg++, regval);
d3858 2
a3859 1
	      regcache_cooked_write_unsigned (regcache, float_argreg++, regval);
d3876 2
a3877 1
	      regcache_cooked_write_unsigned (regcache, float_argreg++, regval);
d3926 1
a3926 1
		     promoted to int before being stored? */
d4249 2
a4250 1
			    "mips_o64_push_dummy_call: struct_return reg=%d %s\n",
d4342 1
a4342 1
		     promoted to int before being stored? */
d4397 1
a4397 1
		     same for integral types. */
d4470 1
a4470 1
         justified. */
d4517 1
a4517 1
   the raw/cooked register interface is in place. (We need a general
d4601 1
a4601 1
{				/* do values for FP (float) regs */
d4604 1
a4604 1
  double doub, flt1;	/* doubles extracted from raw hex data */
d4607 2
a4608 1
  raw_buffer = alloca (2 * register_size (gdbarch, mips_regnum (gdbarch)->fp0));
d4622 2
a4623 1
      flt1 = unpack_double (builtin_type (gdbarch)->builtin_float, raw_buffer, &inv1);
d4741 1
a4741 1
/* Print a row's worth of GP (int) registers, with name labels above */
d4748 1
a4748 1
  /* do values for GP (int) regs */
d4750 2
a4751 1
  int ncols = (mips_abi_regsize (gdbarch) == 8 ? 4 : 8);	/* display cols per row */
d4755 1
a4755 1
  /* For GP registers, we print a separate row of names above the vals */
d4765 1
a4765 1
	break;			/* end the row: reached FP register */
d4788 1
a4788 1
  /* print the R0 to R31 names */
d4795 1
a4795 1
  /* now print the values in hex, 4 or 8 to the row */
d4805 1
a4805 1
	break;			/* end row: reached FP register */
d4818 1
a4818 1
      /* Now print the register value in hex, endian order. */
d4831 1
a4831 1
  if (col > 0)			/* ie. if we actually printed anything... */
d4837 1
a4837 1
/* MIPS_DO_REGISTERS_INFO(): called by "info register" command */
d4843 1
a4843 1
  if (regnum != -1)		/* do one specified register */
d4853 1
a4853 1
    /* do all (or most) registers */
d4862 1
a4862 1
	      if (all)		/* true for "INFO ALL-REGISTERS" command */
d4865 1
a4865 1
		regnum += MIPS_NUMREGS;	/* skip floating point regs */
d5042 1
a5042 1
/* Root of all "set mips "/"show mips " commands. This will eventually be
d5089 3
a5091 3
    printf_unfiltered
      ("The MIPS floating-point coprocessor is set automatically (currently %s)\n",
       fpu);
d5101 2
a5102 2
  printf_unfiltered
    ("\"set mipsfpu\" must be followed by \"double\", \"single\",\"none\" or \"auto\".\n");
d5234 6
a5239 6
/* This function implements gdbarch_breakpoint_from_pc.  It uses the program
   counter value to determine whether a 16- or 32-bit breakpoint should be used.
   It returns a pointer to a string of bytes that encode a breakpoint
   instruction, stores the length of the string to *lenptr, and adjusts pc (if
   necessary) to point to the actual memory location where the breakpoint
   should be inserted.  */
d5242 2
a5243 1
mips_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr)
d5263 1
a5263 1
	     although this is not apparent until you try to use pthreads. */
d5389 1
a5389 1
		    pc = (inst << 16) & 0xffff0000;	/* high word */
d5391 1
a5391 1
		    return pc | (inst & 0xffff);	/* low word */
d5539 2
a5540 1
			        gdbarch_num_regs (gdbarch) + regnum)[0] != '\0')
d5863 2
a5864 1
			"mips_gdbarch_init: mips64_transfers_32bit_regs_p = %d\n",
d5933 1
a5933 1
  /* try to find a pre-existing architecture */
d6161 1
a6161 2
    longs are the same, as set by -mlongXX or set by defaults.
 */
d6229 1
a6229 1
  /* MIPS version of CALL_DUMMY */
d6273 2
a6274 1
  set_gdbarch_single_step_through_delay (gdbarch, mips_single_step_through_delay);
d6303 2
a6304 1
      set_gdbarch_register_reggroup_p (gdbarch, mips_tdesc_register_reggroup_p);
d6378 3
a6380 3
	  fprintf_filtered
	    (file,
	     "The (auto detected) MIPS ABI \"%s\" is in use even though the user setting was \"%s\".\n",
d6428 2
a6429 1
			  "mips_dump_tdep: mips_mask_address_p() %d (default %d)\n",
d6451 1
a6451 1
extern initialize_file_ftype _initialize_mips_tdep;	/* -Wmissing-prototypes */
d6476 1
a6476 1
  /* Add root prefix command for all "set mips"/"show mips" commands */
d6485 1
a6485 1
  /* Allow the user to override the ABI. */
d6540 2
a6541 1
			    NULL, /* FIXME: i18n: The distance searched for the start of a function is %s.  */
d6567 3
a6569 1
			   NULL, /* FIXME: i18n: Compatibility with 64-bit MIPS target that transfers 32-bit quantities is %s.  */
d6572 1
a6572 1
  /* Debug this files internals. */
d6579 2
a6580 1
			    NULL, /* FIXME: i18n: Mips debugging is currently %s.  */
@


1.514
log
@2010-12-28  Hui Zhu  <teawater@@gmail.com>

	* gdbarch.sh (ax_pseudo_register_collect,
	ax_pseudo_register_push_stack): new callbacks.
	(agent_expr): Forward declare.
	* gdbarch.h, gdbarch.c: Regenerate.
	* ax-gdb.c (gen_expr): Remove pseudo-register check code.
	* ax-general.c (user-regs.h): New include.
	(ax_reg): Call gdbarch_ax_pseudo_register_push_stack.
	(ax_reg_mask): Call gdbarch_ax_pseudo_register_collect.
	* mips-tdep.c (ax.h): New include.
	(mips_ax_pseudo_register_collect,
	mips_ax_pseudo_register_push_stack): New functions.
	(mips_gdbarch_init): Set mips_ax_pseudo_register_collect and
	mips_ax_pseudo_register_push_stack.
@
text
@d5 1
a5 1
   2010 Free Software Foundation, Inc.
@


1.513
log
@2010-12-27  Kevin Buettner  <kevinb@@redhat.com>
            Hui Zhu  <teawater@@gmail.com>

	* mips-tedp.c (mips_register_name): Add comments.
@
text
@d61 1
d620 42
d5979 5
@


1.512
log
@	* mips-tdep.c (make_mips16_addr): New function.
	(mips_elf_make_msymbol_special): Don't set the low bit in the
	symbol's address.
	(mips_read_pc, mips_unwind_pc, mips_addr_bits_remove): Strip bit
	indicating mips16 address, if present.
	(mips_write_pc): Set bit indicating mips16 address when in a mips16
	function.
	(mips_eabi_push_dummy_call, mips_o64_push_dummy_call): Likewise,
	but for each function pointer argument to inferior function call.
@
text
@d457 10
a466 1
     but then don't make the raw register names visible.  */
@


1.511
log
@	* mips-tdep.c (mips_convert_register_float_case_p)
	(mips_convert_register_gpreg_case_p): New functions.
	(mips_convert_register_p): Invoke new functions above.
	(mips_register_to_value): Add case for fetching value shorter
	than 64 bits from a 64-bit register.
	(mips_value_to_register): Add case for storing value shorter
	than 64 bits into a 64-bit register.
@
text
@d208 6
a272 1
      SYMBOL_VALUE_ADDRESS (msym) |= 1;
d939 2
d947 7
a953 2
  return frame_unwind_register_signed
	   (next_frame, gdbarch_num_regs (gdbarch) + mips_regnum (gdbarch)->pc);
d982 4
a985 1
  regcache_cooked_write_unsigned (regcache, regnum, pc);
d2468 4
d2891 16
d2909 1
a2909 1
      if (len > regsize
d4197 1
d4210 15
@


1.510
log
@	* mips-tdep.c (mips_pseudo_register_write): Sign extend 32-bit
	cooked values that are being transferred to 64-bit raw registers.
	(mips_pseudo_register_read): Revise to preserve symmetry with
	mips_pseudo_register_write().
@
text
@d638 4
d643 2
a644 1
mips_convert_register_p (struct gdbarch *gdbarch, int regnum, struct type *type)
d655 21
d680 20
a699 2
  get_frame_register (frame, regnum + 0, to + 4);
  get_frame_register (frame, regnum + 1, to + 0);
d706 42
a747 2
  put_frame_register (frame, regnum + 0, from + 4);
  put_frame_register (frame, regnum + 1, from + 0);
@


1.509
log
@	* mips-tdep.c (mips_eabi_push_dummy_call): Place signed, rather
	than unsigned, values in registers.
@
text
@d562 1
a562 2
      if (gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p
	  || gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
d565 6
a570 1
	regcache_raw_read_part (regcache, rawnum, 4, 4, buf);
d589 1
a589 2
      if (gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p
	  || gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
d592 8
a599 1
	regcache_raw_write_part (regcache, rawnum, 4, 4, buf);
@


1.508
log
@gdb/
	Rename and move inferior_thread_state and inferior_status.
	* gdbthread.h (struct thread_control_state): New struct, move fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step and stop_bpstat here from struct thread_info.
	(struct thread_suspend_state): New struct, move field stop_signal here
	from struct thread_info.
	(struct thread_info): Move the fields above from this struct.
	* inferior.h: Move the inferior_thread_state and inferior_status
	declarations comment to their definitions at infrun.c.
	(struct inferior_control_state): New struct, move field stop_soon from
	struct inferior here.
	(struct inferior_suspend_state): New empty struct.
	(struct inferior): New fields control and suspend.  Move out field
	stop_soon.
	* infrun.c (struct inferior_thread_state): Rename to ...
	(infcall_suspend_state): ... here.  Replace field stop_signal by
	fields thread_suspend and inferior_suspend.
	(save_inferior_thread_state): Rename to ...
	(save_infcall_suspend_state): ... here.  New variable inf.  Update the
	code for new fields.
	(restore_inferior_thread_state): Rename to ...
	(restore_infcall_suspend_state): ... here.  New variable inf.  Update
	the code for new fields.
	(do_restore_inferior_thread_state_cleanup): Rename to ...
	(do_restore_infcall_suspend_state_cleanup): ... here.
	(make_cleanup_restore_inferior_thread_state): Rename to ...
	(make_cleanup_restore_infcall_suspend_state): ... here.
	(discard_inferior_thread_state): Rename to ...
	(discard_infcall_suspend_state): ... here.
	(get_inferior_thread_state_regcache): Rename to ...
	(get_infcall_suspend_state_regcache): ... here.
	(struct inferior_status): Rename to ...
	(struct infcall_control_state): ... here.  Replace fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step, stop_bpstat and stop_soon by fields thread_control and
	inferior_control.
	(save_inferior_status): Rename to ...
	(save_infcall_control_state): ... here.  Update the code for new
	fields.
	(restore_inferior_status): Rename to ...
	(restore_infcall_control_state): ... here.  Update the code for new
	fields.
	(do_restore_inferior_status_cleanup): Rename to ...
	(do_restore_infcall_control_state_cleanup): ... here.
	(make_cleanup_restore_inferior_status): Rename to ...
	(make_cleanup_restore_infcall_control_state): ... here.
	(discard_inferior_status): Rename to ...
	(discard_infcall_control_state): ... here.
	* alpha-tdep.c, breakpoint.c, dummy-frame.c, dummy-frame.h,
	exceptions.c, fbsd-nat.c, gdbthread.h, infcall.c, infcmd.c,
	inferior.c, inferior.h, infrun.c, linux-nat.c, mi/mi-interp.c,
	mips-tdep.c, procfs.c, solib-irix.c, solib-osf.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, thread.c, windows-nat.c: Update all the
	references to the moved fields and renamed functions.
@
text
@d2829 1
a2829 1
	      unsigned long regval;
d2832 2
a2833 2
	      regval = extract_unsigned_integer (val + low_offset,
						 4, byte_order);
d2837 1
a2837 1
	      regcache_cooked_write_unsigned (regcache, float_argreg++, regval);
d2840 2
a2841 2
	      regval = extract_unsigned_integer (val + 4 - low_offset,
						 4, byte_order);
d2845 1
a2845 1
	      regcache_cooked_write_unsigned (regcache, float_argreg++, regval);
d2853 1
a2853 1
	      LONGEST regval = extract_unsigned_integer (val, len, byte_order);
d2857 1
a2857 1
	      regcache_cooked_write_unsigned (regcache, float_argreg++, regval);
d2940 1
a2940 1
		    extract_unsigned_integer (val, partial_len, byte_order);
d2946 1
a2946 1
		  regcache_cooked_write_unsigned (regcache, argreg, regval);
@


1.507
log
@2010-08-05  Hui Zhu  <teawater@@gmail.com>

	* mips-linux-tdep.c(regset.h): New include.
	(mips_supply_gregset_wrapper, mips_fill_gregset_wrapper,
	mips_supply_fpregset_wrapper, mips_fill_fpregset_wrapper,
	mips64_supply_gregset_wrapper, mips64_fill_gregset_wrapper,
	mips64_supply_fpregset_wrapper, mips64_fill_fpregset_wrapper,
	mips_linux_regset_from_core_section): New functions.
	(fetch_core_registers, regset_core_fns): Deleted.
	(mips_linux_init_abi): Add mips_linux_regset_from_core_section.
	Deleted regset_core_fns.
	* mips-tdep.c(mips_gdbarch_init): Initialize tdep->gregset,
	tdep->gregset64, tdep->fpregset and tdep->fpregset64.
	* mips-tdep.h(gdbarch_tdep): Add gregset, gregset64, fpregset
	and fpregset64.
@
text
@d2561 1
a2561 1
	if (inf->stop_soon == NO_STOP_QUIETLY)
@


1.506
log
@	* breakpoint.c (update_watchpoint, _initialize_breakpoint): Remove
	unnecessary space in string.
	* filesystem.c (_initialize_filesystem): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* infcmd.c (step_once): Ditto.
	* infrun.c (_initialize_infrun): Ditto.
	* linux-nat.c (linux_child_follow_fork): Ditto.
	* maint.c (maintenance_deprecate): Ditto.
	* memattr.c (_initialize_mem): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* monitor.c (monitor_open): Ditto.
	* procfs.c (procfs_xfer_memory): Ditto.
	* reverse.c (bookmarks_info): Ditto.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Ditto.
	* stack.c (_initialize_stack): Ditto.
	* tracepoint.c (_initialize_tracepoint): Ditto.
	* xtensa-tdep.c (xtensa_supply_gregset,
	xtensa_regset_from_core_section): Ditto.
@
text
@d5752 4
@


1.506.2.1
log
@* mips-tedp.c (mips_register_name): Add comments.
@
text
@d452 1
a452 10
     but then don't make the raw register names visible.  This (upper)
     range of user visible register numbers are the pseudo-registers.

     This approach was adopted accommodate the following scenario:
     It is possible to debug a 64-bit device using a 32-bit
     programming model.  In such instances, the raw registers are
     configured to be 64-bits wide, while the pseudo registers are
     configured to be 32-bits wide.  The registers that the user
     sees - the pseudo registers - match the users expectations
     given the programming model being used.  */
@


1.506.2.2
log
@Make tracepoint can trace pseudo register.
Add MIPS callbacks.
@
text
@a60 1
#include "ax.h"
a603 42
static int
mips_ax_pseudo_register_collect (struct gdbarch *gdbarch,
				 struct agent_expr *ax, int reg)
{
  int rawnum = reg % gdbarch_num_regs (gdbarch);
  gdb_assert (reg >= gdbarch_num_regs (gdbarch)
	      && reg < 2 * gdbarch_num_regs (gdbarch));

  ax_reg_mask (ax, rawnum);

  return 0;
}

static int
mips_ax_pseudo_register_push_stack (struct gdbarch *gdbarch,
				    struct agent_expr *ax, int reg)
{
  int rawnum = reg % gdbarch_num_regs (gdbarch);
  gdb_assert (reg >= gdbarch_num_regs (gdbarch)
	      && reg < 2 * gdbarch_num_regs (gdbarch));
  if (register_size (gdbarch, rawnum) >= register_size (gdbarch, reg))
    {
      ax_reg (ax, rawnum);

      if (register_size (gdbarch, rawnum) > register_size (gdbarch, reg))
        {
	  if (!gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p
	      || gdbarch_byte_order (gdbarch) != BFD_ENDIAN_BIG)
	    {
	      ax_const_l (ax, 32);
	      ax_simple (ax, aop_lsh);
	    }
	  ax_const_l (ax, 32);
	  ax_simple (ax, aop_rsh_signed);
	}
    }
  else
    internal_error (__FILE__, __LINE__, _("bad register size"));

  return 0;
}

a5786 5
  set_gdbarch_ax_pseudo_register_collect (gdbarch,
					  mips_ax_pseudo_register_collect);
  set_gdbarch_ax_pseudo_register_push_stack
      (gdbarch, mips_ax_pseudo_register_push_stack);

@


1.505
log
@Wrong return convention for arrays (mips-irix).

        * mips-tdep.c (mips_n32n64_return_value): Arrays whose size is
        128 bits or smaller are returned the same way as structs
        and unions of the the same size.
@
text
@d6322 1
a6322 1
Use \"on\" to enable the masking, \"off\" to disable it and \"auto\" to \n\
@


1.504
log
@        * mips-tdep.c (mips_breakpoint_from_pc): Add new static variable
        containing the correct breakpoint instruction to use on mips-irix.
        Use it when the osabi is GDB_OSABI_IRIX.
@
text
@d3382 1
a3382 1
     * Any other struct or union results of at most 128 bits are returned in
d3393 1
a3393 2
  if (TYPE_CODE (type) == TYPE_CODE_ARRAY
      || TYPE_LENGTH (type) > 2 * MIPS64_REGSIZE)
d3483 2
a3484 1
	   || TYPE_CODE (type) == TYPE_CODE_UNION)
d3486 1
a3486 1
      /* A structure or union.  Extract the left justified value,
@


1.503
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d5048 3
d5060 2
@


1.502
log
@2009-11-13  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-tdep.c (mips_insn16_frame_this_id): Mark the outermost
	frame.
	(mips_insn32_frame_this_id): Likewise.
@
text
@d4 2
a5 2
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
@


1.501
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d1817 3
d2169 3
@


1.500
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d2386 2
a2387 1
deal_with_atomic_sequence (struct gdbarch *gdbarch, CORE_ADDR pc)
d2475 1
a2475 1
      insert_single_step_breakpoint (gdbarch, breaks[index]);
d2489 1
d2493 1
a2493 1
  if (deal_with_atomic_sequence (gdbarch, pc))
d2498 1
a2498 1
  insert_single_step_breakpoint (gdbarch, next_pc);
d4682 1
a4682 1
  if (!breakpoint_here_p (pc + 4))
@


1.499
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d883 1
a883 1
mips_fetch_instruction (CORE_ADDR addr)
d885 1
d900 1
a900 1
  return extract_unsigned_integer (buf, instlen);
d931 1
d934 1
a934 1
  inst = mips_fetch_instruction (pc);
d1156 1
a1156 1
fetch_mips_16 (CORE_ADDR pc)
d1158 1
d1162 1
a1162 1
  return extract_unsigned_integer (buf, 2);
d1166 1
a1166 1
unpack_mips16 (CORE_ADDR pc,
d1234 1
a1234 1
	nexthalf = mips_fetch_instruction (pc + 2);	/* low bit still set */
d1260 1
d1268 1
a1268 1
	unpack_mips16 (pc, extension, insn, itype, &upk);
d1281 1
a1281 1
	unpack_mips16 (pc, extension, insn, jalxtype, &upk);
d1293 1
a1293 1
	unpack_mips16 (pc, extension, insn, ritype, &upk);
d1305 1
a1305 1
	unpack_mips16 (pc, extension, insn, ritype, &upk);
d1317 1
a1317 1
	unpack_mips16 (pc, extension, insn, i8type, &upk);
d1365 2
a1366 1
	pc = extended_mips16_next_pc (frame, pc, insn, fetch_mips_16 (pc));
d1381 2
a1382 1
  unsigned int insn = fetch_mips_16 (pc);
d1472 2
a1473 1
mips16_scan_prologue (CORE_ADDR start_pc, CORE_ADDR limit_pc,
a1491 1
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
d1512 1
a1512 1
      inst = (unsigned short) mips_fetch_instruction (cur_pc);
d1778 1
d1794 1
a1794 1
      start_addr = heuristic_proc_start (get_frame_arch (this_frame), pc);
d1800 1
a1800 1
    mips16_scan_prologue (start_addr, pc, this_frame, *this_cache);
d1805 1
a1805 2
			gdbarch_num_regs (get_frame_arch (this_frame))
			+ MIPS_SP_REGNUM,
d1900 2
a1901 1
mips32_scan_prologue (CORE_ADDR start_pc, CORE_ADDR limit_pc,
a1914 1
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
d1938 1
a1938 1
      inst = (unsigned long) mips_fetch_instruction (cur_pc);
d2126 1
d2143 1
a2143 1
      start_addr = heuristic_proc_start (get_frame_arch (this_frame), pc);
d2149 1
a2149 1
    mips32_scan_prologue (start_addr, pc, this_frame, *this_cache);
d2154 1
a2154 2
			gdbarch_num_regs (get_frame_arch (this_frame))
			+ MIPS_SP_REGNUM,
d2400 1
a2400 1
  insn = mips_fetch_instruction (loc);
d2411 1
a2411 1
      insn = mips_fetch_instruction (loc);
d2504 1
a2504 1
mips_about_to_return (CORE_ADDR pc)
d2513 1
a2513 1
    return mips_fetch_instruction (pc) == 0xe820;	/* jr $ra */
d2515 1
a2515 1
    return mips_fetch_instruction (pc) == 0x3e00008;	/* jr $ra */
d2598 1
a2598 1
	inst = mips_fetch_instruction (start_pc);
d2603 1
a2603 1
		inst = mips_fetch_instruction (start_pc - instlen);
d2621 1
a2621 1
    else if (mips_about_to_return (start_pc))
d2706 1
d2775 2
a2776 1
	  store_unsigned_integer (valbuf, regsize, value_address (arg));
d2824 2
a2825 1
	      regval = extract_unsigned_integer (val + low_offset, 4);
d2832 2
a2833 1
	      regval = extract_unsigned_integer (val + 4 - low_offset, 4);
d2845 1
a2845 1
	      LONGEST regval = extract_unsigned_integer (val, len);
d2932 1
a2932 1
		    extract_unsigned_integer (val, partial_len);
d3097 1
d3175 1
a3175 1
	  LONGEST regval = extract_unsigned_integer (val, reglen);
d3189 2
a3190 1
	      regval = extract_unsigned_integer (val + reglen, reglen);
d3290 2
a3291 1
		    regval = extract_signed_integer (val, partial_len);
d3293 2
a3294 1
		    regval = extract_unsigned_integer (val, partial_len);
d3539 1
d3642 2
a3643 1
	      regval = extract_unsigned_integer (val + low_offset, 4);
d3654 2
a3655 1
	      regval = extract_unsigned_integer (val + 4 - low_offset, 4);
d3672 1
a3672 1
	      LONGEST regval = extract_unsigned_integer (val, len);
d3760 2
a3761 1
		  LONGEST regval = extract_signed_integer (val, partial_len);
d4003 1
d4085 1
a4085 1
	  LONGEST regval = extract_unsigned_integer (val, len);
d4167 2
a4168 1
		  LONGEST regval = extract_signed_integer (val, partial_len);
d4672 1
d4687 1
a4687 1
  return is_delayed (extract_unsigned_integer (buf, sizeof buf));
d4727 1
a4727 1
    return mips16_scan_prologue (pc, limit_pc, NULL, NULL);
d4729 1
a4729 1
    return mips32_scan_prologue (pc, limit_pc, NULL, NULL);
d4735 1
a4735 1
mips32_in_function_epilogue_p (CORE_ADDR pc)
d4754 1
a4754 1
	  inst = mips_fetch_instruction (pc);
d4773 1
a4773 1
mips16_in_function_epilogue_p (CORE_ADDR pc)
d4791 1
a4791 1
	  inst = mips_fetch_instruction (pc);
d4816 1
a4816 1
    return mips16_in_function_epilogue_p (pc);
d4818 1
a4818 1
    return mips32_in_function_epilogue_p (pc);
d5101 1
d5160 1
a5160 1
		  inst = mips_fetch_instruction (target_pc);
d5186 2
d5213 2
a5214 1
	stub_words[i] = extract_unsigned_integer (stub_code + i * 4, 4);
d5326 2
a5327 1
  return (CORE_ADDR) extract_signed_integer (buf, TYPE_LENGTH (type));
@


1.498
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d2551 2
a2552 2
	    warning (_("GDB can't find the start of the function at 0x%s."),
		     paddr_nz (pc));
d2563 1
a2563 1
    GDB is unable to find the start of the function at 0x%s\n\
d2570 1
a2570 1
from 0x%s for code which looks like the beginning of a\n\
d2572 2
a2573 1
heuristic-fence-post' command.\n", paddr_nz (pc), paddr_nz (pc));
d2729 2
a2730 2
			"mips_eabi_push_dummy_call: sp=0x%s allocated %ld\n",
			paddr_nz (sp), (long) align_up (len, 16));
d2741 2
a2742 2
			    "mips_eabi_push_dummy_call: struct_return reg=%d 0x%s\n",
			    argreg, paddr_nz (struct_addr));
d2891 4
a2894 4
		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=0x%s",
					  paddr_nz (stack_offset));
		      fprintf_unfiltered (gdb_stdlog, " longword_offset=0x%s",
					  paddr_nz (longword_offset));
d2902 2
a2903 2
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ",
					  paddr_nz (addr));
d3113 2
a3114 2
			"mips_n32n64_push_dummy_call: sp=0x%s allocated %ld\n",
			paddr_nz (sp), (long) align_up (len, 16));
d3125 2
a3126 2
			    "mips_n32n64_push_dummy_call: struct_return reg=%d 0x%s\n",
			    argreg, paddr_nz (struct_addr));
d3238 4
a3241 4
		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=0x%s",
					  paddr_nz (stack_offset));
		      fprintf_unfiltered (gdb_stdlog, " longword_offset=0x%s",
					  paddr_nz (longword_offset));
d3249 2
a3250 2
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ",
					  paddr_nz (addr));
d3560 2
a3561 2
			"mips_o32_push_dummy_call: sp=0x%s allocated %ld\n",
			paddr_nz (sp), (long) align_up (len, 16));
d3572 2
a3573 2
			    "mips_o32_push_dummy_call: struct_return reg=%d 0x%s\n",
			    argreg, paddr_nz (struct_addr));
d3715 4
a3718 4
		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=0x%s",
					  paddr_nz (stack_offset));
		      fprintf_unfiltered (gdb_stdlog, " longword_offset=0x%s",
					  paddr_nz (longword_offset));
d3726 2
a3727 2
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ",
					  paddr_nz (addr));
d4017 2
a4018 2
			"mips_o64_push_dummy_call: sp=0x%s allocated %ld\n",
			paddr_nz (sp), (long) align_up (len, 16));
d4029 2
a4030 2
			    "mips_o64_push_dummy_call: struct_return reg=%d 0x%s\n",
			    argreg, paddr_nz (struct_addr));
d4120 4
a4123 4
		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=0x%s",
					  paddr_nz (stack_offset));
		      fprintf_unfiltered (gdb_stdlog, " longword_offset=0x%s",
					  paddr_nz (longword_offset));
d4131 2
a4132 2
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ",
					  paddr_nz (addr));
@


1.497
log
@	* gdbtypes.h (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(init_float_type, init_complex_type): Add prototypes.
	* gdbtypes.c (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(build_flt): Rename to ...
	(init_float_type): ... this.  Make global.
	(build_complex): Rename to ...
	(init_complex_type): ... this.  Make global.  Remove BIT argument.
	(gdbtypes_post_init): Update calls.

	* ada-lang.c (ada_language_arch_info): Use init_float_type.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* f-lang.c (build_fortran_types): Use init_float_type and
	init_complex_type.

	* target-descriptions.c (tdesc_gdb_type): Call init_float_type instead
	of using builtin_type_ieee_single, builtin_type_ieee_double, or
	builtin_type_arm_ext.

	* ia64-tdep.h (struct gdbarch_tdep): Add ia64_ext_type member.
	* ia64-tdep.c (builtin_type_ia64_ext): Remove.
	(_initialize_ia64_tdep): Do not initialize it.
	(floatformat_valid, floatformat_ia64_ext, floatformats_ia64_ext):
	Move up.
	(ia64_ext_type): New function.
	(ia64_register_reggroup_p, ia64_convert_register_p,
	ia64_register_to_value, ia64_value_to_register,
	ia64_extract_return_value, ia64_store_return_value): Use ia64_ext_type
	instead of builtin_type_ia64_ext.

	* i386-tdep.h (struct gdbarch_tdep): Add i387_ext_type member.
	(i387_ext_type): Add prototype.
	* i386-tdep.c (i387_ext_type): New function.
	(i386_extract_return_value, i386_store_return_value,
	i386_register_type): Use it instead of builtin_type_i387_ext.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* i387-tdep.c (print_i387_value, i387_register_to_value,
	i387_value_to_register): Likewise.
	(print_i387_value, print_i387_ext): Add GDBARCH argument.
	(print_i387_ext, i387_print_float_info): Pass to subroutines.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68881_ext_type member.
	* m68k-tdep.c (m68881_ext_type): New function.
	(m68k_register_type, m68k_convert_register_p): Use it instead
	of builtin_type_m68881_ext.

	* arm-tdep.h (struct gdbarch_tdep): Add arm_ext_type member.
	* arm-tdep.c (arm_ext_type): New function.
	(arm_register_type): Use it instead of builtin_type_arm_ext.

	* alpha-tdep.c (alpha_register_type): Use builtin types
	instead of builtin_type_ieee_double.

	* mips-tdep.c (mips_float_register_type, mips_double_register_type):
	Remove.
	(mips_register_type): Use builtin types instead of
	builtin_type_ieee_single and builtin_type_ieee_double.
	(mips_print_fp_register): Use builtin types instead of
	mips_float_register_type and mips_double_register_type.

	* hppa-tdep.c (hppa32_register_type, hppa64_register_type):
	Use builtin types instead of builtin_type_ieee_single and
	builtin_type_ieee_double.
@
text
@d2380 1
a2380 1
deal_with_atomic_sequence (CORE_ADDR pc)
d2468 1
a2468 1
      insert_single_step_breakpoint (breaks[index]);
d2481 1
d2485 1
a2485 1
  if (deal_with_atomic_sequence (pc))
d2490 1
a2490 1
  insert_single_step_breakpoint (next_pc);
@


1.496
log
@	* gdbtypes.h (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(struct builtin_type): New members builtin_int0, builtin_int8,
	builtin_uint8, builtin_int16, builtin_uint16, builtin_int32,
	builtin_uint32, builtin_int64, builtin_uint64, builtin_int128,
	and builtin_uint128.
	* gdbtypes.c (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize fixed-size integer types.

	* dwarf2expr.c (unsigned_address_type, signed_address_type): Add
	GDBARCH argument.  Return platform-specific type.
	(dwarf2_read_address, execute_stack_op): Update calls.

	* target-descriptions.c (tdesc_gdb_type): Use platform-specific types
	instead of global builtin_int_... variables.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	* printcmd.c (do_examine): Likewise.
	* jv-exp.y (parse_number): Likewise.

	* alpha-tdep.c (alpha_register_type, alpha_push_dummy_call,
	alpha_store_return_value): Likewise.
	* amd64-linux-tdep.c (amd64_linux_register_type): Likewise.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c h8300_register_type): Likewise.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_register_type,
	hppa64_register_type): Likewise.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Likewise.
	* iq2000-tdep.c (iq2000_register_type): Likewise.
	* lm32-tdep.c (lm32_register_type, lm32_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68hc11-tdep.c (m68hc11_register_type, m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m88k-tdep.c (m88k_register_type, m88k_store_arguments): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_register_type, mips_pseudo_register_type,
	mips_print_fp_register): Likewise.
	* moxie-tdep.c (moxie_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type, mt_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* score-tdep.c (score_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type, sparc32_store_arguments):
	Likewise.
	* sparc64-tdep.c (sparc64_register_type, sparc64_store_arguments):
	Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* xstormy16-tdep.c (xstormy16_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* mt-tdep.c (struct gdbarch_tdep): New data structure.
	(mt_gdbarch_init): Alloc TDEP structures.
	(mt_register_type): Cache coprocessor type in TDEP instead of
	static global variable.

	* xtensa-tdep.h (struct gdbarch_tdep): Add type_entries member.
	* xtensa-tdep.c (type_entries): Remove.
	(xtensa_register_type): Cache fixed-size types in TDEP instead
	of in global variable.
@
text
@a366 3
static struct type *mips_float_register_type (void);
static struct type *mips_double_register_type (void);

d670 1
a670 1
	return builtin_type_ieee_single;
d672 1
a672 1
	return builtin_type_ieee_double;
a4281 12
static struct type *
mips_float_register_type (void)
{
  return builtin_type_ieee_single;
}

static struct type *
mips_double_register_type (void)
{
  return builtin_type_ieee_double;
}

d4381 1
a4381 1
      flt1 = unpack_double (mips_float_register_type (), raw_buffer, &inv1);
d4397 2
a4398 2
	  doub = unpack_double (mips_double_register_type (), raw_buffer,
				&inv2);
d4413 2
a4414 1
      flt1 = unpack_double (mips_float_register_type (), raw_buffer, &inv1);
d4417 2
a4418 1
      doub = unpack_double (mips_double_register_type (), raw_buffer, &inv2);
@


1.495
log
@	* dummy-frame.c (deprecated_pc_in_call_dummy): Add GDBARCH parameter,
	use it instead of current_gdbarch.
	* frame.h (deprecated_pc_in_call_dummy): Add GDBARCH parameter.
	* arm-tdep.c (arm_skip_prologue): Pass architecture to
	deprecated_pc_in_call_dummy.

	* symtab.c (skip_prologue_using_sal): Add GDBARCH parameter.
	Use it instead of current_gdbarch.
	* symtab.h (skip_prologue_using_sal): Add GDBARCH parameter.
	* breakpoint.c (expand_line_sal_maybe): Pass architecture to
	skip_prologue_using_sal.
	* arm-tdep.c (skip_prologue_using_sal): Likewise.
	* lm32-tdep.c (lm32_skip_prologue): Likewise.
	* m32-tdep.c (m32c_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* moxie-tdep.c (moxie_skip_prologue): Likewise.
	* mt-tdep.c (mt_frame_unwind_cache): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* frv-tdep.c (frv_analyze_prologue): Add GDBARCH parameter, pass
	it to skip_prologue_using_sal.  Update call sites ...
	(frv_skip_prologue, frv_frame_unwind_cache): ... here.

	* mn10300-tdep.c (struct mn10300_prologue): Add GDBARCH member.
	(check_for_saved): Use it instead of current_gdbarch.
	(mn10300_analyze_prologue): Set it.

	* value.c (using_struct_return): Add GDBARCH parameter.  Use it
	instead of current_gdbarch.
	* value.h (using_struct_return): Add GDBARCH parameter.
	* eval.c (evaluate_subexp_standard): Pass architecture to
	using_struct_return.
	* infcall.c (call_function_by_hand): Likewise.
	* stack.c (return_command): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.

	* symtab.c (in_prologue): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.
	* symtab.h (in_prologue): Add GDBARCH parameter.
	* infrun.c (handle_inferior_event): Pass architecture to in_prologue.

	* eval.c (evaluate_subexp_standard): Use expression architecture
	instead of current_gdbarch.

	* c-lang.c (evaluate_subexp_c): Use expression architecture and
	language instead of current_gdbarch and current_language.

	* printcmd.c (do_one_display): Use expression architecture instead
	of current_gdbarch.

	* infcmd.c (print_return_value): Use architecture of stop_regcache
	instead of current_gdbarch.
	(print_vector_info, print_float_info): Remove GDBARCH argument,
	use frame architecture instead.
	(vector_info, float_info): Update calls.

	* objc-lang.c (objc_skip_trampoline): Use frame architecture
	instead of current_gdbarch.

	* parse.c (write_dollar_variable): Use parse architecture instead
	of current_gdbarch.

	* source.c (line_info): Use objfile architecture instead of
	current_gdbarch.

	* symtab.c (find_function_start_sal): Use gdbarch instead of
	current_gdbarch.
	(print_msymbol_info): Use objfile architecture instead of
	current_gdbarch.

	* valops.c (value_assign): Use frame architecture instead of
	current_gdbarch.
@
text
@d682 1
a682 1
	return builtin_type_int32;
d684 1
a684 1
	return builtin_type_int64;
d695 1
a695 1
	return builtin_type_int32;
d700 1
a700 1
	return builtin_type_int32;
d704 1
a704 1
	return builtin_type_int32;
d707 1
a707 1
	return builtin_type_int64;
d744 1
a744 1
      return builtin_type_int32;
d760 1
a760 1
    return builtin_type_int32;
d4399 3
a4401 2
      print_scalar_formatted (raw_buffer, builtin_type_uint32, &opts, 'w',
			      file);
d4434 3
a4436 2
      print_scalar_formatted (raw_buffer, builtin_type_uint64, &opts, 'g',
			      file);
@


1.494
log
@2009-05-27  Tom Tromey  <tromey@@redhat.com>
	    Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* mi/mi-main.c (mi_cmd_data_evaluate_expression): Use
	value_address.
	* cli/cli-dump.c (dump_value_to_file): Use value_address.
	* valprint.c (common_val_print): Likewise.
	* v850-tdep.c (v850_push_dummy_call): Use value_address.
	* tracepoint.c (encode_actions): Use value_address.
	* printcmd.c (print_formatted): Use value_address.
	(x_command): Likewise.
	* p-valprint.c (pascal_object_print_static_field): Use
	value_address.
	* mn10300-tdep.c (mn10300_push_dummy_call): Use value_address.
	* mips-tdep.c (mips_eabi_push_dummy_call): Use value_address.
	* m32r-tdep.c (m32r_push_dummy_call): Use value_address.
	* jv-valprint.c (java_value_print): Use value_address.
	* infcall.c (find_function_addr): Use value_address.
	* gnu-v3-abi.c (gnuv3_rtti_type): Use value_address.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Use value_address.
	* frv-tdep.c (frv_push_dummy_call): Use value_address.
	* frame.c (frame_register_unwind): Use value_address.
	(frame_unwind_register_value): Likewise.
	* darwin-nat-info.c (info_mach_region_command): Use
	value_address.
	* cp-valprint.c (cp_print_static_field): Use value_address.
	* c-valprint.c (c_value_print): Use value_address.
	* breakpoint.c (update_watchpoint): Use value_address.
	(can_use_hardware_watchpoint): Likewise.
	* ada-valprint.c (ada_val_print_1): Use value_address.
	(ada_value_print): Likewise.
	* ada-tasks.c (read_fat_string_value): Use value_address.
	* jv-lang.c (java_link_class_type): Use set_value_address.
	(java_link_class_type): Likewise.
	(get_java_utf8_name): Use value_address.
	(type_from_class): Likewise.
	(java_link_class_type): Likewise.
	* findvar.c (value_of_register): Use set_value_address.
	(read_var_value): Likewise.
	(read_var_value): Likewise.
	* eval.c (evaluate_subexp_standard): Use set_value_address.
	(evaluate_subexp_standard): Use value_address.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Use set_value_address.
	* ada-lang.c (coerce_unspec_val_to_type): Use set_value_address.
	(ada_value_primitive_packed_val): Likewise.
	(ensure_lval): Likewise.
	(thin_data_pntr): Use value_address.
	(desc_bounds): Likewise.
	(ada_value_primitive_packed_val): Likewise.
	(value_assign_to_component): Likewise.
	(ensure_lval): Likewise.
	(make_array_descriptor): Likewise.
	(ada_to_fixed_value): Likewise.
	(unwrap_value): Likewise.
	* value.c (deprecated_value_address_hack): Remove.
	(value_address): New function.
	(value_raw_address): Likewise.
	(set_value_address): Likewise.
	(value_fn_field): Use set_value_address.
	(value_from_contents_and_address): Likewise.
	(value_fn_field): Likewise.
	(allocate_value_lazy): Don't use VALUE_ADDRESS.
	(value_as_address): Use value_address.
	(value_static_field): Likewise.
	* valops.c (search_struct_field): Use set_value_address.
	(value_at): Likewise.
	(value_at_lazy): Likewise.
	(value_repeat): Likewise.
	(value_cast_structs): Use value_address.
	(value_cast): Likewise.
	(value_fetch_lazy): Likewise.
	(value_assign): Likewise.
	(value_repeat): Likewise.
	(address_of_variable): Likewise.
	(value_coerce_array): Likewise.
	(value_coerce_function): Likewise.
	(value_addr): Likewise.
	(search_struct_field): Likewise.
	(search_struct_method): Likewise.
	(find_method_list): Likewise.
	(value_struct_elt_for_reference): Likewise.
	(value_full_object): Likewise.
	* jv-valprint.c (java_value_print): Use set_value_address.
	* value.h (deprecated_value_address_hack): Remove.
	(VALUE_ADDRESS): Remove.
	(value_address): Declare.
	(value_raw_address): Declare.
	(set_value_address): Declare.
@
text
@d4698 2
a4699 1
      CORE_ADDR post_prologue_pc = skip_prologue_using_sal (func_addr);
d4710 1
a4710 1
  limit_pc = skip_prologue_using_sal (pc);
@


1.493
log
@	Unify target macros.

	* target.h (STOPPED_BY_WATCHPOINT): Delete, replaced by ...
	(target_stoppped_by_watchpoint): New macro.
	(HAVE_STEPPABLE_WATCHPOINT): Delete, replaced by ...
	(target_have_steppable_watchpoint): New macro.
	(HAVE_CONTINUABLE_WATCHPOINT): Delete, replace by ...
	(target_have_continuable_watchpoint): New macro.
	(TARGET_CAN_USE_HARDWARE_WATCHPOINT):Delete, replaced by ...
	(target_can_use_hardware_watchpoint): New macro.
	(TARGET_REGION_OK_FOR_HW_WATCHPOINT):Delete, replaced by ...
	(target_region_ok_for_hw_watchpoint): New macro.

	* breakpoint.c (update_watchpoint): Use new macros.
	(bpstat_alloc): Likewise.
	(create_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(can_use_hardware_watchpoint): Likewise.
	(do_enable_breakpoint): Likewise.
	* infrun.c (handle_inferior_event): Adapt to new macros.
	* mips-tdep.c (mips_gdbarch_init): Update comments.
	* procfs.c (procfs_set_watchpoint): Update comment.
	(procfs_insert_watchpoint): Adapt to new macros.
	* remote-m32r-sdi.c (m32r_stop):
	* remote-mips.c (mips_remove_breakpoint):
	* target.c (debug_to_region_ok_for_hw_watchpoint): Update to new macros.
	(debug_to_stopped_by_watchpoint): Likewise.
@
text
@d2769 1
a2769 1
	  store_unsigned_integer (valbuf, regsize, VALUE_ADDRESS (arg));
@


1.492
log
@	* inferior.h (read_pc, write_pc): Remove.
	* regcache.c (read_pc, write_pc): Remove.

	* infrun.c (displaced_step_fixup): Use regcache_read_pc instead
	of read_pc.
	(handle_inferior_event): Use regcache_read_pc instead of read_pc
	when determining value of stop_pc.  Replace subsequent uses of
	read_pc by inspecting already-retrieved stop_pc value.
	(keep_going): Use regcache_read_pc instead of read_pc.

	* breakpoint.c (watchpoint_check): Use current frame architecture
	and PC instead of current_gdbarch and read_pc ().
	* tracepoint.c (set_traceframe_context): Replace PC argument
	with FRAME argument.
	(trace_start_command, finish_tfind_command): Update calls.
	(finish_tfind_command): Compare frame IDs to identify transitions
	between frames.
	(trace_find_pc_command): Use regcache_read_pc instead of read_pc.
	* rs6000-nat.c (exec_one_dummy_insn): Pass in regcache instead
	of gdbarch.  Use regcache_read_pc and regcache_write_pc instead
	of read_pc and write_pc.
	(store_register): Make regcache argument non-const.  Update call
	to exec_one_dummy_insn.

	* thread.c (switch_to_thread): Use regcache_read_pc instead of read_pc.
	* infcmd.c (post_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (enable_break, svr4_relocate_main_executable): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* record.c (record_wait): Likewise.
	* procfs.c (procfs_wait): Likewise.
	* remote-mips.c (common_open, mips_wait): Likewise.
	* remote-m32r-sdi.c (m32r_resume): Likewise.

	* symfile.c (generic_load): Use regcache_write_pc instead of write_pc.
	* monitor.c (monitor_create_inferior, monitor_load): Likewise.
	* m32r-rom.c (m32r_load, m32r_upload_command): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior, m32r_load): Likewise.
	* remote-mips.c (mips_create_inferior, mips_load): Likewise.

	* solib-darwin.c: Include "regcache.h".
	* solib-pa64.c: Include "regcache.h".
	* solib-svr4.c: Include "regcache.h.".

	* symfile.c: Do not mention read_pc or write_pc in comments.
	* dink32-rom.c: Likewise.
	* m32r-rom.c: Likewise.
	* mips-tdep.c: Likewise.
@
text
@d6008 2
a6009 2
  /* FIXME: cagney/2003-08-29: The macros HAVE_STEPPABLE_WATCHPOINT,
     HAVE_NONSTEPPABLE_WATCHPOINT, and HAVE_CONTINUABLE_WATCHPOINT
d6011 2
a6012 2
     being used as guards for STOPPED_BY_WATCHPOINT, why not have
     STOPPED_BY_WATCHPOINT return the type of watchpoint that the code
@


1.491
log
@* mips-tdep.c (mips_numeric_register_alieses): New definition.
(mips_gdbarch_init): Add user registers from
mips_numeric_register_aliases.
@
text
@d5799 1
a5799 1
       replaced by read_pc?  */
@


1.490
log
@	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
        * alpha-linux-tdep.c (alpha_linux_regset_from_core_section): Make
	it static.
        * alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Declare.
        * amd64fbsd-tdep.c (amd64fbsd_init_abi): Make it static.
        * amd64nbsd-tdep.c (_initialize_amd64nbsd_ndep): Rename to ...
	(_initialize_amd64nbsd_tdep): ... this.
	* arm-linux-tdep.c (arm_linux_software_single_step): Make it static.
	(_initialize_arm_linux_tdep): Declare.
	* armbsd-tdep.c (armbsd_fpreg_offset): Make it static.
	* armnbsd-tdep.c (_initialize_arm_netbsd_tdep): Declare.
	* armobsd-tdep.c (_initialize_armobsd_tdep): Declare.
	* avr-tdep.c (avr_return_value): Make it static.
	(avr_frame_unwind_cache): Ditto.
	* bsd-uthread.c (bsd_uthread_inferior_created): Ditto.
	(bsd_uthread_solib_loaded): Ditto.
	(bsd_uthread_solib_unloaded): Ditto.
	(bsd_uthread_target): Ditto.
	(_initialize_bsd_uthread): Declare.
	* cris-tdep.c (crisv32_single_step_through_delay): Make it static.
	(cris_frame_unwind_cache): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_use_struct_convention): Ditto.
	(h8300h_use_struct_convention): Ditto.
	* hppa-tdep.c (hppa_sign_extend, hppa_low_hppa_sign_extend):
	Ditto.
	* hppa-tdep.h (hppa_low_sign_extend, hppa_sign_extend): Delete
	declarations.
	* hppabsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_find_global_pointer): Make it static.
	* hppabsd-tdep.h: New.
	* hppanbsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Remove declaration.
	(_initialize_hppabsd_tdep): Remove declaration.
	(_initialize_hppanbsd_tdep): Declare.
	* hppaobsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Delete declaration.
	(hppaobsd_init_abi): Make it static.
	* i386-nto-tdep.c (_initialize_i386nto_tdep): Declare.
	* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Declare.
	* ia64-linux-tdep.c (_initialize_ia64_linux_tdep): Declare.
	* ia64-tdep.c (ia64_register_reggroup_p): Make it static.
	* iq2000-tdep.c (_initialize_iq2000_tdep): Declare.
	* m32c-tdep.c (m32c_register_reggroup_p): Make it static.
	(m32c_analyze_prologue, m32c_virtual_frame_pointer): Ditto.
	(_initialize_m32c_tdep): Declare.
	* m32r-rom.c (_initialize_m32r_rom): Declare.
	* m32r-tdep.c (m32r_skip_prologue): Make it static.
	(m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Make it static.
	(m68hc11_return_value): Ditto.
	* m68klinux-tdep.c (_initialize_m68k_linux_tdep): Declare.
	* m88k-tdep.c (m88k_frame_cache): Make it static.
	* mep-tdep.c (mep_gdb_print_insn): Ditto.
	(mep_return_value): Ditto.
	(_initialize_mep_tdep): Declare.
	* mips-irix-tdep.c (_initialize_mips_irix_tdep): Declare.
	* mips-linux-tdep.c (supply_64bit_reg): Make it static.
	(mips_linux_syscall_next_pc): Ditto.
	(_initialize_mips_linux_tdep): Declare.
	* mips-tdep.c (mips_single_step_through_delay): Make it static.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Declare.
	* mn10300-linux-tdep.c (_initialize_mn10300_linux_tdep): Declare.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Declare.
	* mt-tdep.c (_initialize_mt_tdep): Declare.
	* nbsd-tdep.c: Include nbsd-tdep.h.
	* nto-tdep.c (find_load_phdr): Make it static.
	(_initialize_nto_tdep): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Make it
	static.
	(_initialize_ppc_linux_tdep): Declare.
	* remote-m32r-sdi.c (m32r_can_use_hw_watchpoint)
	(m32r_insert_watchpoint, m32r_remove_watchpoint)
	(m32r_stopped_data_address, m32r_stopped_by_watchpoint): Make
	static.
	* rs6000-aix-tdep.c (_initialize_rs6000_aix_tdep): Declare.
	* rs6000-nat.c: Include xcoffread.h.
	(find_toc_address): Don't extern declare get_toc_offset.  Adjust
	to call xcoff_get_to_offset.
	* rs6000-tdep.c (ppc_vsx_support_p, ppc_displaced_step_fixup)
	(rs6000_skip_main_prologue, rs6000_in_solib_return_trampoline)
	(rs6000_skip_trampoline_code): Make static.
	* s390-tdep.c (s390_regset_from_core_section): Ditto.
	* sh-tdep.c (sh_register_reggroup_p): Ditto.
	* shnbsd-tdep.c (shnbsd_regset_from_core_section): Ditto.
	(_initialize_shnbsd_tdep): Declare.
	* solib-frv.c (displacement_from_map): Make static.
	(_initialize_frv_solib): Declare.
	* solib-irix.c (fetch_lm_info): Make static.
	(_initialize_irix_solib): Declare.
	* solib-som.c: Include solib-som.h.
	(som_solib_select): Line break.
	* sparc-tdep.c (sparc_regset_from_core_section): Make static.
	* sparcnbsd-tdep.c (_initialize_sparnbsd_tdep): Rename to ...
	(_initialize_sparcnbsd_tdep): ... this.
	* spu-tdep.c (spu_software_single_step): Make it static.
	(_initialize_spu_tdep): Declare.
	* vax-tdep.c (vax_frame_cache): Make it static.
	* xcoffread.c: Include xcoffread.h.
	(get_toc_offset): Rename to ...
	(xcoff_get_toc_offset): ... this.
	(_initialize_xcoffread): Declare.
	* xcoffread.h: New.
	* xtensa-linux-tdep.c (_initialize_xtensa_linux_tdep): Declare.
	* xtensa-tdep.c (xtensa_skip_prologue, xtensa_derive_tdep): Make
	static.
	(_initialize_xtensa_tdep): Declare.
@
text
@d146 9
d6070 5
@


1.489
log
@        Updated copyright notices for most files.
@
text
@d4648 1
a4648 1
int
@


1.488
log
@gdb
	* varobj.c (value_get_print_value): Include valprint.h.
	(value_get_print_value): Use get_formatted_print_options.
	* value.h (struct value_print_options): Declare.
	(value_print, val_print, common_val_print, val_print_string):
	Update.
	* value.c: Include valprint.h.
	(show_values): Use get_user_print_options.
	(show_convenience): Likewise.
	* valprint.h (prettyprint_arrays, prettyprint_structs): Don't
	declare.
	(struct value_print_options): New type.
	(vtblprint, unionprint, addressprint, objectprint, print_max,
	inspect_it, repeat_count_threshold, output_format,
	stop_print_at_null): Don't declare.
	(user_print_options, get_user_print_options,
	get_raw_print_options, get_formatted_print_options): Declare.
	(print_array_indexes_p): Don't declare.
	(maybe_print_array_index, val_print_array_elements): Update.
	* valprint.c (print_max): Remove.
	(user_print_options): New global.
	(get_user_print_options, get_raw_print_options,
	get_formatted_print_options): New functions.
	(print_array_indexes, repeat_count_threshold, stop_print_at_null,
	prettyprint_structs, prettyprint_arrays, unionprint,
	addressprint): Remove.
	(val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(common_val_print): Likewise.
	(print_array_indexes_p): Remove.
	(maybe_print_array_index): Remove format, pretty arguments; add
	options.  Update.
	(val_print_array_elements): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(val_print_string): Add options argument.  Update.
	(_initialize_valprint): Use user_print_options.
	(output_format): Remove.
	(set_output_radix_1): Use user_print_options.
	* typeprint.c: Include valprint.h.
	(objectprint): Don't declare.
	(whatis_exp): Use get_user_print_options.
	* tui/tui-regs.c: Include valprint.h.
	(tui_register_format): Use get_formatted_print_options.
	* tracepoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(trace_mention): Use get_user_print_options.
	(tracepoints_info): Likewise.
	* stack.c (print_frame_args): Use get_raw_print_options.
	(print_frame_info): Use get_user_print_options.
	(print_frame): Likewise.
	* sh64-tdep.c: Include valprint.h
	(sh64_do_register): Use get_formatted_print_options.
	* scm-valprint.c (scm_inferior_print): Remove format, deref_ref,
	pretty arguments; add options.
	(scm_scmlist_print): Likewise.  Update.
	(scm_scmval_print): Likewise.
	(scm_val_print): Likewise.
	(scm_value_print): Remove format, pretty arguments; add options.
	Update.
	* scm-lang.h (scm_value_print, scm_val_print, scm_scmval_print):
	Update.
	* scm-lang.c (scm_printstr): Add options argument.
	* python/python-value.c: Include valprint.h.
	(valpy_str): Use get_user_print_options.
	* printcmd.c: Include valprint.h.
	(addressprint): Don't declare.
	(inspect_it): Remove.
	(print_formatted): Remove format option; add options.  Update.
	(print_scalar_formatted): Likewise.
	(print_address_demangle): Use get_user_print_options.
	(do_examine): Use get_formatted_print_options.
	(print_command_1): Likewise.
	(output_command): Use get_formatted_print_options.
	(do_one_display): Likewise.
	(print_variable_value): Use get_user_print_options.
	* p-valprint.c (pascal_val_print): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(pascal_value_print): Remove format, pretty arguments; add
	options.  Update.
	(vtblprint, objectprint): Don't declare.
	(pascal_static_field_print): Remove.
	(pascal_object_print_value_fields): Remove format, pretty
	arguments; add options.  Update.
	(pascal_object_print_static_field): Likewise.
	(_initialize_pascal_valprint): Use user_print_options.  Update.
	* p-lang.h (pascal_val_print, pascal_value_print,
	pascal_printstr, pascal_object_print_value_fields): Update.
	(vtblprint, static_field_print): Don't declare.
	* p-lang.c (pascal_printstr): Add options argument.  Update.
	* objc-lang.c (objc_printstr): Add options argument.  Update.
	* mt-tdep.c: Include valprint.h.
	(mt_registers_info): Use get_raw_print_options.
	* mips-tdep.c: Include valprint.h.
	(mips_print_fp_register): Use get_formatted_print_options.
	(mips_print_register): Likewise.
	* mi/mi-main.c: Include valprint.h.
	(get_register): Use get_user_print_options.
	(mi_cmd_data_evaluate_expression): Likewise.
	(mi_cmd_data_read_memory): Use get_formatted_print_options.
	* mi/mi-cmd-stack.c: Include valprint.h.
	(list_args_or_locals): Use get_raw_print_options.
	* m2-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(m2_print_long_set): Remove format, pretty arguments.
	(m2_print_unbounded_array): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(print_unpacked_pointer): Remove format argument; add options.
	Now static.  Update.
	(print_variable_at_address): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(m2_print_array_contents): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* m2-lang.c (m2_printstr): Add options argument. Update.
	* language.h (struct value_print_options): Declare.
	(struct language_defn) <la_printstr>: Add options argument.
	<la_val_print>: Remove format, deref_ref, pretty argument; add
	options.
	<la_value_print>: Remove format, pretty arguments; add options.
	<la_print_array_index>: Likewise.
	(LA_VAL_PRINT, LA_VALUE_PRINT, LA_PRINT_STRING,
	LA_PRINT_ARRAY_INDEX): Update.
	(default_print_array_index): Update.
	* language.c (default_print_array_index): Remove format, pretty
	arguments; add options.  Update.
	(unk_lang_printstr): Add options argument.
	(unk_lang_val_print): Remove format, deref_ref, pretty arguments;
	add options.
	(unk_lang_value_print): Remove format, pretty arguments; add
	options.
	* jv-valprint.c (java_value_print): Remove format, pretty
	arguments; add options.  Update.
	(java_print_value_fields): Likewise.
	(java_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	* jv-lang.h (java_val_print, java_value_print): Declare.
	* infcmd.c: Include valprint.h.
	(print_return_value): Use get_raw_print_options.
	(default_print_registers_info): Use get_user_print_options,
	get_formatted_print_options.
	(registers_info): Use get_formatted_print_options.
	* gdbtypes.h (struct value_print_options): Declare.
	(print_scalar_formatted): Update.
	* f-valprint.c (f77_print_array_1): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Update.
	* f-lang.c (f_printstr): Add options argument.  Update.
	(c_value_print): Update declaration.
	* expprint.c: Include valprint.h.
	(print_subexp_standard): Use get_raw_print_options,
	get_user_print_options.
	* eval.c: Include valprint.h.
	(objectprint): Don't declare.
	(evaluate_subexp_standard): Use get_user_print_options.
	* cp-valprint.c (vtblprint, objectprint, static_field_print):
	Remove.
	(cp_print_value_fields): Remove format, pretty arguments; add
	options.  Update.
	(cp_print_value): Likewise.
	(cp_print_static_field): Likewise.
	(_initialize_cp_valprint): Use user_print_options.  Update.
	* c-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(c_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(c_value_print): Add options argument.  Update.
	* c-lang.h (c_val_print, c_value_print, c_printstr): Update.
	(vtblprint, static_field_print): Don't declare.
	(cp_print_value_fields): Update.
	* c-lang.c (c_printstr): Add options argument.  Update.
	* breakpoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(watchpoint_value_print): Use get_user_print_options.
	(print_one_breakpoint_location): Likewise.
	(breakpoint_1, print_it_catch_fork, print_it_catch_vfork, mention,
	print_exception_catchpoint): Likewise.
	* auxv.c (fprint_target_auxv): Don't declare addressprint.  Use
	get_user_print_options.
	* ada-valprint.c (struct ada_val_print_args): Remove format,
	deref_ref, and pretty; add options.
	(print_optional_low_bound): Add options argument.
	(val_print_packed_array_elements): Remove format and pretty
	arguments; add options.  Update.
	(printstr): Add options argument.  Update.
	(ada_printstr): Likewise.
	(ada_val_print): Remove format, deref_ref, pretty arguments; add
	options argument.  Update.
	(ada_val_print_stub): Update.
	(ada_val_print_array): Remove format, deref_ref, pretty arguments;
	add options.  Update.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Remove format, pretty arguments; add options.
	Update.
	(print_record): Likewise.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print, ada_value_print, ada_printstr):
	Update.
	* ada-lang.c (ada_print_array_index): Add options argument; remove
	format and pretty arguments.
	(print_one_exception): Use get_user_print_options.
gdb/testsuite
	* gdb.base/exprs.exp (test_expr): Add enum formatting tests.
@
text
@d4 1
a4 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.487
log
@	* mips-tdep.c (mips_n32n64_fp_arg_chunk_p): Update TYPE_FIELD_STATIC
	removed before.
@
text
@d60 1
d4382 2
d4389 2
a4390 1
      print_scalar_formatted (raw_buffer, builtin_type_uint32, 'x', 'w',
d4414 2
d4423 2
a4424 2

      print_scalar_formatted (raw_buffer, builtin_type_uint64, 'x', 'g',
d4448 1
d4481 1
d4483 1
a4483 1
			  register_type (gdbarch, regnum), 'x', 0,
@


1.486
log
@	* mips-linux-tdep.c (mips_linux_in_dynsym_resolve_code): Update
	comments.
	(mips_linux_skip_resolver): Also use glibc_skip_solib_resolver.
	(mips_linux_init_abi): Do not override skip_trampoline_code.
	* configure.tgt (mips*-*-linux*): Add glibc-tdep.o.
	* mips-tdep.c (mips32_scan_prologue): Stop scanning at branches.
	(mips_stub_frame_sniffer): Use the stub frame sniffer for PIC stubs.
	(mips_skip_mips16_trampoline_code): Rename from
	mips_skip_trampoline_code.
	(mips_skip_pic_trampoline_code, mips_skip_trampoline_code): New.
	* infrun.c (handle_inferior_event): Do not pass zero to
	in_solib_dynsym_resolve_code.
@
text
@d3037 1
a3037 1
      if (TYPE_FIELD_STATIC (arg_type, i)
@


1.485
log
@	* xcoffread.c (RECORD_MINIMAL_SYMBOL): Update.
	(scan_xcoff_symtab): Update.
	* mdebugread.c (record_minimal_symbol): Update.
	(parse_partial_symbols): Update.
	* elfread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* coffread.c (record_minimal_symbol): Update.
	* sh64-tdep.c (MSYMBOL_IS_SPECIAL): Redefine.
	(sh64_elf_make_msymbol_special): Update.
	* mips-tdep.c (mips_elf_make_msymbol_special): Use
	MSYMBOL_TARGET_FLAG_1.
	(mips_elf_make_msymbol_special): Likewise.
	(msymbol_is_special): Likewise.
	* minsyms.c (prim_record_minimal_symbol_and_info): Update.
	(install_minimal_symbols): Likewise.
	(prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_and_info): Remove 'info' argument.
	* m68hc11-tdep.c (MSYMBOL_SET_RTC): Redefine.
	(MSYMBOL_SET_RTI): Redefine.
	(MSYMBOL_IS_RTC): Redefine.
	(MSYMBOL_IS_RTI): Redefine.
	* arm-tdep.c (MSYMBOL_SET_SPECIAL): Redefine.
	(MSYMBOL_IS_SPECIAL): Redefine.
	* symtab.h (struct minimal_symbol) <info>: Remove.
	<target_flag_1, target_flag_2>: New fields.
	(MSYMBOL_INFO): Remove.
	(MSYMBOL_TARGET_FLAG_1): New macro.
	(MSYMBOL_TARGET_FLAG_2): Likewise.
	(prim_record_minimal_symbol_and_info): Update.
@
text
@d1900 1
d2058 5
d2064 6
d2271 1
d2288 8
d5069 1
a5069 1
mips_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)
d5148 74
@


1.484
log
@	Make the stop_soon global be per-inferior instead.

	* infcmd.c (attach_command_post_wait): Adjust.
	(attach_command): Likewise.

	* inferior.h (stop_soon): Delete.
	(struct inferior): Add stop_soon member.

	* infrun.c (stop_soon): Delete.
	(clear_proceed_status, start_remote)
	(fetch_inferior_event, handle_inferior_event): Adjust.
	(signal_stop_state): Don't check stop_soon here.  Check in callers
	instead.
	(save_inferior_status, restore_inferior_status): Adjust.

	* linux-nat.c (linux_nat_resume, linux_nat_wait): Always pass
	signals to common code if starting up the inferior.

	* inferior.h (struct inferior_info): Added stop_soon member.
	* inferior.c (add_inferior) Clear stop_soon.

	* mips-tdep.c (heuristic_proc_start): Adjust.
	* nto-procfs.c (procfs_create_inferior): Adjust.
	* solib-irix.c (irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Adjust.

	* win32-nat.c (do_initial_win32_stuff): Adjust.

	* alpha-tdep.c (alpha_heuristic_proc_start): Adjust.
@
text
@d256 1
a256 2
      MSYMBOL_INFO (msym) = (char *)
	(((long) MSYMBOL_INFO (msym)) | 0x80000000);
d264 1
a264 1
  return (((long) MSYMBOL_INFO (msym) & 0x80000000) != 0);
@


1.483
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d2496 1
d2509 2
d2519 1
a2519 1
	if (stop_soon == NO_STOP_QUIETLY)
@


1.482
log
@	* mips-tdep.c (deprecated_mips_set_processor_regs_hack): Use
	regcache architecture instead of current_gdbarch.
@
text
@d740 2
a741 1
  if (mips_abi_regsize (gdbarch) == TYPE_LENGTH (builtin_type_void_data_ptr))
d744 1
a744 1
	return builtin_type_void_data_ptr;
d746 1
a746 1
	return builtin_type_void_func_ptr;
@


1.481
log
@	* m68hc11-tdep.c (gdb_print_insn_m68hc11): Use info->arch
	instead of current_gdbarch.

	* sh64-tdep.c (gdb_print_insn_sh64): Remove.
	(sh64_gdbarch_init): Install print_insn_sh64 directly.
	* sh-tdep.c (gdb_print_insn_sh): Remove.
	(sh_gdbarch_init): Install print_insn_sh directly.

	* mips-tdep.c (gdb_print_insn_mips): Do not check mips_abi
	from current_gdbarch.
	(gdb_print_insn_mips_n32, gdb_print_insn_mips_n64): New functions.
	(mips_gdbarch_init): Install them instead of gdb_print_insn_mips
	depending on mips_abi.
@
text
@d4888 3
a4890 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d4893 1
a4893 2
  regcache_cooked_read_unsigned (get_current_regcache (),
				 MIPS_PRID_REGNUM, &prid);
@


1.480
log
@	* gdbarch.sh (addr_bits_remove): Change type to 'm'.
	(smash_text_address): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.

	* arch-utils.c (core_addr_identity): Add gdbarch parameter.
	* arch-utils.h (core_addr_identity): Likewise.
	* arm-tdep.c (arm_addr_bits_remove): Likewise.
	(arm_smash_text_address): Likewise.
	* hppa-tdep.c (hppa_smash_text_address): Likewise.
	* m88k-tdep.c (m88k_addr_bits_remove): Likewise.
	* s390-tdep.c (s390_addr_bits_remove): Likewise.

	* mips-tdep.c (mips_addr_bits_remove): Add gdbarch parameter.
	Use it instead of current_gdbarch.

	* arm-tdep.c (arm_prologue_prev_register, arm_unwind_pc,
	arm_dwarf2_prev_register): Update calls.
	* m88k-tdep.c (m88k_unwind_pc): Update call.
@
text
@a4909 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

d4921 1
a4921 11
  if (tdep->mips_abi == MIPS_ABI_N32 || tdep->mips_abi == MIPS_ABI_N64)
    {
      /* Set up the disassembler info, so that we get the right
         register names from libopcodes.  */
      if (tdep->mips_abi == MIPS_ABI_N32)
	info->disassembler_options = "gpr-names=n32";
      else
	info->disassembler_options = "gpr-names=64";
      info->flavour = bfd_target_elf_flavour;
    }
  else
d4936 22
d5885 6
a5890 1
  set_gdbarch_print_insn (gdbarch, gdb_print_insn_mips);
@


1.479
log
@	* gdbarch.sh (target_gdbarch): New global variable.
	(deprecated_current_gdbarch_select_hack): Set it.
	* gdbarch.c, gdbarch.h: Regenerate.

	* arch-utils.c (gdbarch_update_p): Use target_gdbarch instead
	of current_gdbarch.
	* target-descriptions.c (target_find_description): Likewise.
	* arm-tdep.c (arm_update_current_architecture): Likewise.
	(show_fp_model, arm_show_abi, arm_show_fallback_mode,
	arm_show_force_mode): Likewise.
	* mips-tdep.c (show_mask_address, show_mipsfpu_command,
	show_mips_abi): Likewise.
	* mep-tdep.c (me_module_register_set, current_me_module): Likewise.

	* target.c (target_translate_tls_address): Use target_gdbarch
	instead of current_gdbarch.
	* remote.c (struct packet_reg): Likewise.
	(get_remote_arch_state, packet_reg_from_regnum,
	packet_reg_from_pnum, remote_check_symbols, remote_wait,
	remote_address_masked, remote_insert_breakpoint,
	remote_insert_hw_breakpoint, remote_read_description): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* remote-mips.c (mips_open, mips_common_breakpoint): Likewise.
	* cris-tdep.c (cris_can_use_hardware_watchpoint): Likewise.

	* solib.c (solib_open, solib_map_sections, solib_read_symbols,
	solib_add, info_sharedlibrary_command, solib_address,
	solib_create_inferior_hook, in_solib_dynsym_resolve_code,
	solib_global_lookup): Likewise.
	* solib-frv.c (enable_break2, frv_relocate_main_executable): Likewise.
	* solib-irix.c (irix_current_sos, irix_open_symbol_file_object):
	Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (exec_entry_point, enable_break, svr4_free_so,
	set_solib_svr4_fetch_link_map_offsets, svr4_fetch_link_map_offsets):
	Likewise.
	* nto-tdep.c (nto_find_and_open_solib, nto_init_solib_absolute_prefix,
	nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_in_dynsym_stub): Likewise.
@
text
@d2316 1
a2316 1
mips_addr_bits_remove (CORE_ADDR addr)
d2318 1
a2318 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.478
log
@	* mips-linux-tdep.c (mips_linux_syscall_next_pc): New function.
	(mips_linux_init_abi): Set tdep->syscall_next_pc.
	* mips-tdep.c (enum mips_fpu_type, struct gdbarch_tdep): Move to
	mips-tdep.h.
	(mips32_next_pc): Handle the syscall instruction.
	* mips-tdep.h (enum mips_fpu_type, struct gdbarch_tdep): New,
	from mips-tdep.c.  Add syscall_next_pc to gdbarch_tdep.
@
text
@d781 1
a781 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d4791 1
a4791 1
  if (gdbarch_bfd_arch_info (current_gdbarch)->arch != bfd_arch_mips)
d4799 1
a4799 1
  switch (MIPS_FPU_TYPE (current_gdbarch))
d5961 1
a5961 1
  if (gdbarch_bfd_arch_info (current_gdbarch)->arch != bfd_arch_mips)
d5969 1
a5969 1
      enum mips_abi actual_abi = mips_abi (current_gdbarch);
@


1.477
log
@	* mips-tdep.c (mips_n32n64_push_dummy_call): Handle passing
	128-bit long doubles in even-odd pairs of FPRs.  Do not
	right-align float arguments for big-endian.
	(mips_n32n64_return_value): Apply return value convention for
	structs containing one or two floating-point values to soft-float
	as well as hard-float.  Handle 128-bit long doubles in such
	structs.
	(mips_o32_push_dummy_call): Only skip one integer register for a
	float argument passed in an FPR.
@
text
@a144 10
/* Some MIPS boards don't support floating point while others only
   support single-precision floating-point operations.  */

enum mips_fpu_type
{
  MIPS_FPU_DOUBLE,		/* Full double precision floating point.  */
  MIPS_FPU_SINGLE,		/* Single precision floating point (R4650).  */
  MIPS_FPU_NONE			/* No floating point.  */
};

a160 31
/* MIPS specific per-architecture information */
struct gdbarch_tdep
{
  /* from the elf header */
  int elf_flags;

  /* mips options */
  enum mips_abi mips_abi;
  enum mips_abi found_abi;
  enum mips_fpu_type mips_fpu_type;
  int mips_last_arg_regnum;
  int mips_last_fp_arg_regnum;
  int default_mask_address_p;
  /* Is the target using 64-bit raw integer registers but only
     storing a left-aligned 32-bit value in each?  */
  int mips64_transfers_32bit_regs_p;
  /* Indexes for various registers.  IRIX and embedded have
     different values.  This contains the "public" fields.  Don't
     add any that do not need to be public.  */
  const struct mips_regnum *regnum;
  /* Register names table for the current register set.  */
  const char **mips_processor_reg_names;

  /* The size of register data available from the target, if known.
     This doesn't quite obsolete the manual
     mips64_transfers_32bit_regs_p, since that is documented to force
     left alignment even for big endian (very strange).  */
  int register_size_valid_p;
  int register_size;
};

d980 11
@


1.476
log
@
	* mips-tdep.c (fp_register_arg_p): Add gdbarch as paramter.
	(mips_n32n64_push_dummy_call, mips_o64_return_value)
	(mips_eabi_push_dummy_call): Update call to fp_register_arg_p.

	(MIPS_FPU_TYPE): Add gdbarch as parameter and replace current_gdbarch.
	(fp_register_arg_p, mips_dump_tdep, show_mipsfpu_command)
	(mips_n32n64_fp_arg_chunk_p): Update caller.

	(mips_n32n64_fp_arg_chunk_p): Add gdbarch as paramter.
	(mips_n32n64_push_dummy_call): Update caller.

	(MIPS_LAST_ARG_REGNUM): Add gdbarch as parameter and replace
	current_gdbarch.
	(mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Update caller.


	(MIPS_LAST_FP_ARG_REGNUM): Add gdbarch as parameter and replace
	current_gdbarch.
	(mips_eabi_push_dummy_call, mips_o32_push_dummy_call)
	(mips_o64_push_dummy_call): Update caller.

	(MIPS_EABI): Add gdbarch as parameter and replace current_gdbarch.
	(fp_register_arg_p, mips_dump_tdep): Update caller.

	(set_reg_offset): Add gdbarch as parameter and replace current_gdbarch.
	(mips16_scan_prologue, mips32_scan_prologue): Update caller.

	(reset_saved_regs): Make static.  Add gdbarch as parameter.  Replace
	current_gdbarch.
	(mips32_scan_prologue): Update caller.

	(heuristic_proc_start): Add gdbarch as parameter. Replace
	current_gdbarch.
	(mips_insn16_frame_cache, mips_insn32_frame_cache): Update caller.

	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Use get_regcache_arch to get at
	the current architecture. Update call to getregs_supplies.
	(getregs_supplies): Add gdbarch as parameter and replace
	current_gdbarch.

	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use get_frame_arch to
	get at the current architecture. Update call to NBSD_MIPS_JB_OFFSET and
	NBSD_MIPS_JB_ELEMENT_SIZE.
	(NBSD_MIPS_JB_ELEMENT_SIZE, NBSD_MIPS_JB_OFFSET): Add gdbarch and
	replace current_gdbarch.

	* remote-mips.c (mips_map_regno): Add gdbarch as parameter and replace
	current_gdbarch.
	(mips_fetch_registers, mips_store_registers): Update call
	to mips_map_regno.
	(mips_load): Use get_regcache_arch to get at the current_architecture
	and replace current_gdbarch.
@
text
@d3145 10
d3159 3
a3161 2
	     in a single register.  */
	  LONGEST regval = extract_unsigned_integer (val, len);
d3164 1
a3164 1
				float_argreg, phex (regval, len));
d3169 1
a3169 1
				argreg, phex (regval, len));
d3173 15
d3228 1
a3228 2
			   || typecode == TYPE_CODE_PTR
			   || typecode == TYPE_CODE_FLT)
d3417 1
a3417 2
		       == TYPE_CODE_FLT)))
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
d3421 1
a3421 1
         register..  */
d3424 3
a3426 1
      for (field = 0, regnum = mips_regnum (gdbarch)->fp0;
d3434 21
a3454 5
	  mips_xfer_register (gdbarch, regcache,
			      gdbarch_num_regs (gdbarch) + regnum,
			      TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
			      gdbarch_byte_order (gdbarch),
			      readbuf, writebuf, offset);
d3657 3
a3659 4
	      /* CAGNEY: 32 bit MIPS ABI's always reserve two FP
	         registers for each argument.  The below is (my
	         guess) to ensure that the corresponding integer
	         register has reserved the same space.  */
d3663 1
a3663 2
	      regcache_cooked_write_unsigned (regcache, argreg, regval);
	      argreg += 2;
@


1.475
log
@2008-06-03  Michael Snyder  <msnyder@@redhat.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* mips-tdep.c (mips_eabi_return_value): Replace stub that always
	returned RETURN_VALUE_STRUCT_CONVENTION with a real function.
@
text
@d214 3
a216 2
#define MIPS_EABI (gdbarch_tdep (current_gdbarch)->mips_abi == MIPS_ABI_EABI32 \
		   || gdbarch_tdep (current_gdbarch)->mips_abi == MIPS_ABI_EABI64)
d218 1
a218 1
#define MIPS_LAST_FP_ARG_REGNUM (gdbarch_tdep (current_gdbarch)->mips_last_fp_arg_regnum)
d220 1
a220 1
#define MIPS_LAST_ARG_REGNUM (gdbarch_tdep (current_gdbarch)->mips_last_arg_regnum)
d222 1
a222 1
#define MIPS_FPU_TYPE (gdbarch_tdep (current_gdbarch)->mips_fpu_type)
d395 1
a395 1
static CORE_ADDR heuristic_proc_start (CORE_ADDR);
d1435 2
a1436 2
set_reg_offset (struct mips_frame_cache *this_cache, int regnum,
		CORE_ADDR offset)
d1441 4
a1444 6
      this_cache->saved_regs[regnum
			     + 0 * gdbarch_num_regs (current_gdbarch)].addr
      = offset;
      this_cache->saved_regs[regnum
			     + 1 * gdbarch_num_regs (current_gdbarch)].addr
      = offset;
d1561 1
a1561 1
	  set_reg_offset (this_cache, reg, sp + offset);
d1567 1
a1567 1
	  set_reg_offset (this_cache, reg, sp + offset);
d1572 1
a1572 1
	  set_reg_offset (this_cache, MIPS_RA_REGNUM, sp + offset);
d1577 1
a1577 1
	  set_reg_offset (this_cache, MIPS_RA_REGNUM, sp + offset);
d1595 1
a1595 1
	  set_reg_offset (this_cache, reg, frame_addr + offset);
d1601 1
a1601 1
	  set_reg_offset (this_cache, reg, frame_addr + offset);
d1650 1
a1650 1
	  set_reg_offset (this_cache, reg, sp + offset);
d1658 1
a1658 1
	  set_reg_offset (this_cache, MIPS_RA_REGNUM, sp + offset);
d1665 1
a1665 1
	  set_reg_offset (this_cache, reg, sp + offset);
d1717 1
a1717 1
	  set_reg_offset (this_cache, reg, sp + offset);
d1726 1
a1726 1
	  set_reg_offset (this_cache, MIPS_RA_REGNUM, sp + offset);
d1733 1
a1733 1
	  set_reg_offset (this_cache, 30, sp + offset);
d1740 1
a1740 1
	  set_reg_offset (this_cache, reg, sp + offset);
d1747 1
a1747 1
	  set_reg_offset (this_cache, 17, sp + offset);
d1753 1
a1753 1
	  set_reg_offset (this_cache, 16, sp + offset);
d1760 1
a1760 1
	  set_reg_offset (this_cache, reg, sp + offset);
d1810 1
a1810 1
      start_addr = heuristic_proc_start (pc);
d1895 2
a1896 2
void
reset_saved_regs (struct mips_frame_cache *this_cache)
d1902 1
a1902 1
    const int num_regs = gdbarch_num_regs (current_gdbarch);
d1977 1
a1977 1
	  set_reg_offset (this_cache, reg, sp + low_word);
d1983 1
a1983 1
	  set_reg_offset (this_cache, reg, sp + low_word);
d2009 1
a2009 1
                  reset_saved_regs (this_cache);
d2039 1
a2039 1
                  reset_saved_regs (this_cache);
d2047 1
a2047 1
	  set_reg_offset (this_cache, reg, frame_addr + low_word);
d2147 1
a2147 1
      start_addr = heuristic_proc_start (pc);
d2519 1
a2519 1
heuristic_proc_start (CORE_ADDR pc)
d2526 1
a2526 1
  pc = gdbarch_addr_bits_remove (current_gdbarch, pc);
d2635 2
a2636 1
fp_register_arg_p (enum type_code typecode, struct type *arg_type)
d2639 1
a2639 1
	   || (MIPS_EABI
d2645 1
a2645 1
	  && MIPS_FPU_TYPE != MIPS_FPU_NONE);
d2780 1
a2780 1
      if (regsize < 8 && fp_register_arg_p (typecode, arg_type))
d2798 2
a2799 2
      if (fp_register_arg_p (typecode, arg_type)
	  && float_argreg <= MIPS_LAST_FP_ARG_REGNUM)
d2864 1
a2864 1
	      if (argreg > MIPS_LAST_ARG_REGNUM
d2866 1
a2866 1
		  || fp_register_arg_p (typecode, arg_type))
d2915 2
a2916 2
	      if (argreg <= MIPS_LAST_ARG_REGNUM
		  && !fp_register_arg_p (typecode, arg_type))
d3023 2
a3024 1
mips_n32n64_fp_arg_chunk_p (struct type *arg_type, int offset)
d3031 1
a3031 1
  if (MIPS_FPU_TYPE != MIPS_FPU_DOUBLE)
d3066 1
a3066 1
      return mips_n32n64_fp_arg_chunk_p (field_type, offset - pos);
d3145 2
a3146 2
      if (fp_register_arg_p (typecode, arg_type)
	  && argreg <= MIPS_LAST_ARG_REGNUM)
d3188 2
a3189 2
	      if (fp_register_arg_p (typecode, arg_type))
		gdb_assert (argreg > MIPS_LAST_ARG_REGNUM);
d3192 1
a3192 1
	      if (argreg > MIPS_LAST_ARG_REGNUM)
d3236 1
a3236 1
	      if (argreg <= MIPS_LAST_ARG_REGNUM)
d3276 1
a3276 1
		  if (mips_n32n64_fp_arg_chunk_p (arg_type,
d3556 1
a3556 1
      if (fp_register_arg_p (typecode, arg_type))
d3572 2
a3573 2
      if (fp_register_arg_p (typecode, arg_type)
	  && float_argreg <= MIPS_LAST_FP_ARG_REGNUM)
d3661 1
a3661 1
	      if (argreg > MIPS_LAST_ARG_REGNUM
d3698 1
a3698 1
	      if (argreg <= MIPS_LAST_ARG_REGNUM)
d3745 1
a3745 1
		  float_argreg = MIPS_LAST_FP_ARG_REGNUM + 1;
d4020 2
a4021 2
      if (fp_register_arg_p (typecode, arg_type)
	  && float_argreg <= MIPS_LAST_FP_ARG_REGNUM)
d4058 1
a4058 1
	      if (argreg > MIPS_LAST_ARG_REGNUM
d4103 1
a4103 1
	      if (argreg <= MIPS_LAST_ARG_REGNUM)
d4134 1
a4134 1
		  float_argreg = MIPS_LAST_FP_ARG_REGNUM + 1;
d4172 1
a4172 1
  else if (fp_register_arg_p (TYPE_CODE (type), type))
d4789 1
a4789 1
  switch (MIPS_FPU_TYPE)
d6036 2
a6037 1
  fprintf_unfiltered (file, "mips_dump_tdep: MIPS_EABI = %d\n", MIPS_EABI);
d6040 4
a6043 4
		      MIPS_FPU_TYPE,
		      (MIPS_FPU_TYPE == MIPS_FPU_NONE ? "none"
		       : MIPS_FPU_TYPE == MIPS_FPU_SINGLE ? "single"
		       : MIPS_FPU_TYPE == MIPS_FPU_DOUBLE ? "double"
@


1.474
log
@	* gdbarch.sh: Delete dwarf_reg_to_regnum.
	* gdbarch.c, gdbarch.h: Regenerated.
	* amd64-tdep.c, arm-tdep.c, h8300-tdep.c, hppa-linux-tdep.c,
	hppa-tdep.c, i386-tdep.c, m32c-tdep.c, m68k-tdep.c, mips-tdep.c,
	s390-tdep.c, xtensa-tdep.c: Do not set dwarf_reg_to_regnum.

	* gdbint.texinfo (Target Conditionals): Delete entry for
	gdbarch_dwarf_reg_to_regnum.
@
text
@d2959 4
d2965 47
a3011 2
  if (readbuf)
    memset (readbuf, 0, TYPE_LENGTH (type));
@


1.473
log
@	* mipsnbsd-tdep.c, mips64obsd-tdep.c, mips-linux-tdep.c: Update
	for unwinder changes.
	* mips-tdep.c: Likewise.
	(mips_stub_frame_cache): Unwind the ABI stack pointer, not the
	raw one.
@
text
@a5783 2
  set_gdbarch_dwarf_reg_to_regnum (gdbarch,
				   mips_dwarf_dwarf2_ecoff_reg_to_regnum);
@


1.472
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d890 1
a890 1
/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
d896 1
a896 1
mips_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d899 4
a902 4
	   (frame_unwind_register_signed (next_frame,
					  gdbarch_num_regs (gdbarch)
					  + MIPS_SP_REGNUM),
					  frame_pc_unwind (next_frame));
d1491 1
a1491 1
                      struct frame_info *next_frame,
d1509 1
a1509 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d1512 5
a1516 5
     NEXT_FRAME.  */
  if (next_frame != NULL)
    sp = frame_unwind_register_signed (next_frame,
				       gdbarch_num_regs (gdbarch)
				       + MIPS_SP_REGNUM);
d1769 2
a1770 2
        (frame_unwind_register_signed (next_frame,
				       gdbarch_num_regs (gdbarch) + frame_reg)
d1794 1
a1794 1
mips_insn16_frame_cache (struct frame_info *next_frame, void **this_cache)
d1802 1
a1802 1
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d1806 1
a1806 2
    const CORE_ADDR pc =
      frame_unwind_address_in_block (next_frame, NORMAL_FRAME);
d1817 1
a1817 1
    mips16_scan_prologue (start_addr, pc, next_frame, *this_cache);
d1822 2
a1823 2
			gdbarch_num_regs (get_frame_arch (next_frame))
			  + MIPS_SP_REGNUM,
d1830 1
a1830 1
mips_insn16_frame_this_id (struct frame_info *next_frame, void **this_cache,
d1833 1
a1833 1
  struct mips_frame_cache *info = mips_insn16_frame_cache (next_frame,
d1835 1
a1835 2
  (*this_id) = frame_id_build (info->base,
			       frame_func_unwind (next_frame, NORMAL_FRAME));
d1838 3
a1840 6
static void
mips_insn16_frame_prev_register (struct frame_info *next_frame,
				 void **this_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, gdb_byte *valuep)
d1842 1
a1842 1
  struct mips_frame_cache *info = mips_insn16_frame_cache (next_frame,
d1844 11
a1854 2
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
d1861 3
a1863 1
  mips_insn16_frame_prev_register
a1865 9
static const struct frame_unwind *
mips_insn16_frame_sniffer (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  if (mips_pc_is_mips16 (pc))
    return &mips_insn16_frame_unwind;
  return NULL;
}

d1867 1
a1867 1
mips_insn16_frame_base_address (struct frame_info *next_frame,
d1870 1
a1870 1
  struct mips_frame_cache *info = mips_insn16_frame_cache (next_frame,
d1884 1
a1884 1
mips_insn16_frame_base_sniffer (struct frame_info *next_frame)
d1886 2
a1887 1
  if (mips_insn16_frame_sniffer (next_frame) != NULL)
d1919 1
a1919 1
                      struct frame_info *next_frame,
d1931 1
a1931 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d1935 5
a1939 5
     NEXT_FRAME.  */
  if (next_frame != NULL)
    sp = frame_unwind_register_signed (next_frame,
				       gdbarch_num_regs (gdbarch)
				       + MIPS_SP_REGNUM);
d1991 1
a1991 1
	  else if (next_frame && frame_reg == MIPS_SP_REGNUM)
d1996 2
a1997 2
	      frame_addr = frame_unwind_register_signed
			     (next_frame, gdbarch_num_regs (gdbarch) + 30);
d2021 1
a2021 1
	  if (next_frame && frame_reg == MIPS_SP_REGNUM)
d2026 2
a2027 2
	      frame_addr = frame_unwind_register_signed
			     (next_frame, gdbarch_num_regs (gdbarch) + 30);
d2094 2
a2095 2
        (frame_unwind_register_signed (next_frame,
				       gdbarch_num_regs (gdbarch) + frame_reg)
d2130 1
a2130 1
mips_insn32_frame_cache (struct frame_info *next_frame, void **this_cache)
d2139 1
a2139 1
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d2143 1
a2143 2
    const CORE_ADDR pc =
      frame_unwind_address_in_block (next_frame, NORMAL_FRAME);
d2154 1
a2154 1
    mips32_scan_prologue (start_addr, pc, next_frame, *this_cache);
d2159 2
a2160 2
			gdbarch_num_regs (get_frame_arch (next_frame))
			  + MIPS_SP_REGNUM,
d2167 1
a2167 1
mips_insn32_frame_this_id (struct frame_info *next_frame, void **this_cache,
d2170 1
a2170 1
  struct mips_frame_cache *info = mips_insn32_frame_cache (next_frame,
d2172 1
a2172 2
  (*this_id) = frame_id_build (info->base,
			       frame_func_unwind (next_frame, NORMAL_FRAME));
d2175 3
a2177 6
static void
mips_insn32_frame_prev_register (struct frame_info *next_frame,
				 void **this_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, gdb_byte *valuep)
d2179 1
a2179 1
  struct mips_frame_cache *info = mips_insn32_frame_cache (next_frame,
d2181 11
a2191 2
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
d2198 3
a2200 1
  mips_insn32_frame_prev_register
a2202 9
static const struct frame_unwind *
mips_insn32_frame_sniffer (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  if (! mips_pc_is_mips16 (pc))
    return &mips_insn32_frame_unwind;
  return NULL;
}

d2204 1
a2204 1
mips_insn32_frame_base_address (struct frame_info *next_frame,
d2207 1
a2207 1
  struct mips_frame_cache *info = mips_insn32_frame_cache (next_frame,
d2221 1
a2221 1
mips_insn32_frame_base_sniffer (struct frame_info *next_frame)
d2223 2
a2224 1
  if (mips_insn32_frame_sniffer (next_frame) != NULL)
d2231 1
a2231 1
mips_stub_frame_cache (struct frame_info *next_frame, void **this_cache)
d2237 2
a2238 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d2242 1
a2242 1
  this_trad_cache = trad_frame_cache_zalloc (next_frame);
d2248 1
a2248 1
			      (gdbarch_num_regs (gdbarch) + MIPS_RA_REGNUM));
d2252 1
a2252 1
  pc = frame_pc_unwind (next_frame);
d2254 2
a2255 1
  stack_addr = frame_unwind_register_signed (next_frame, MIPS_SP_REGNUM);
d2266 1
a2266 1
mips_stub_frame_this_id (struct frame_info *next_frame, void **this_cache,
d2270 1
a2270 1
    = mips_stub_frame_cache (next_frame, this_cache);
d2274 3
a2276 6
static void
mips_stub_frame_prev_register (struct frame_info *next_frame,
				 void **this_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, gdb_byte *valuep)
d2279 2
a2280 3
    = mips_stub_frame_cache (next_frame, this_cache);
  trad_frame_get_register (this_trad_cache, next_frame, regnum, optimizedp,
			   lvalp, addrp, realnump, valuep);
d2283 3
a2285 9
static const struct frame_unwind mips_stub_frame_unwind =
{
  NORMAL_FRAME,
  mips_stub_frame_this_id,
  mips_stub_frame_prev_register
};

static const struct frame_unwind *
mips_stub_frame_sniffer (struct frame_info *next_frame)
d2289 1
a2289 1
  CORE_ADDR pc = frame_unwind_address_in_block (next_frame, NORMAL_FRAME);
d2292 2
a2293 2
  if (target_read_memory (frame_pc_unwind (next_frame), dummy, 4) != 0)
    return &mips_stub_frame_unwind;
d2296 1
a2296 1
    return &mips_stub_frame_unwind;
d2304 1
a2304 1
    return &mips_stub_frame_unwind;
d2306 1
a2306 1
  return NULL;
d2309 9
d2319 1
a2319 1
mips_stub_frame_base_address (struct frame_info *next_frame,
d2323 1
a2323 1
    = mips_stub_frame_cache (next_frame, this_cache);
d2336 1
a2336 1
mips_stub_frame_base_sniffer (struct frame_info *next_frame)
d2338 1
a2338 1
  if (mips_stub_frame_sniffer (next_frame) != NULL)
d5778 1
a5778 1
  set_gdbarch_unwind_dummy_id (gdbarch, mips_unwind_dummy_id);
d5841 4
a5844 4
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, mips_stub_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, mips_insn16_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, mips_insn32_frame_sniffer);
@


1.471
log
@	* mips-tdep.c (mips32_scan_prologue): Use the ABI register size
	to decide whether to match instruction patterns using "sw" and "sd".
@
text
@d2958 1
a2958 1
mips_eabi_return_value (struct gdbarch *gdbarch,
d3268 1
a3268 1
mips_n32n64_return_value (struct gdbarch *gdbarch,
d3726 2
a3727 2
mips_o32_return_value (struct gdbarch *gdbarch, struct type *type,
		       struct regcache *regcache,
d4115 1
a4115 1
mips_o64_return_value (struct gdbarch *gdbarch,
@


1.470
log
@	* breakpoint.h (breakpoint_restore_shadows): New
	declaration.
	* breakpoint.c (breakpoint_restore_shadows): New.
	(read_memory_nobpt): Delete.
	* gdbcore.h (read_memory_nobpt): Delete declaration.
	* target.c (memory_xfer_partial): Call
	breakpoint_restore_shadows.
	(restore_show_memory_breakpoints)
	(make_show_memory_beakpoints_cleanup): New.
	(show_memory_breakpoints): New.
	* target.h (make_show_memory_beakpoints_cleanup): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint):
	Make sure we see memory breakpoints when checking if
	breakpoint is still there.
	* alpha-tdep.c, alphanbsd-tdep.c, frame.c, frv-tdep.c,
	hppa-linux-tdep.c, hppa-tdep.c, i386-linux-nat.c, i386-tdep.c,
	m68klinux-tdep.c, mips-tdep.c, mn10300-tdep.c, s390-tdep.c,
	sparc-tdep.c: Use target_read_memory instead of read_memory_nobpt.
@
text
@d1934 1
d1977 2
a1978 1
      else if ((high_word & 0xFFE0) == 0xafa0)	/* sw reg,offset($sp) */
d1982 2
a1983 1
      else if ((high_word & 0xFFE0) == 0xffa0)	/* sd reg,offset($sp) */
d2047 2
a2048 1
      else if ((high_word & 0xFFE0) == 0xafc0)	/* sw reg,offset($30) */
@


1.469
log
@
	* rs6000-tdep.c (gdb_print_insn_powerpc): Get the current endianess
	from disassemble_info instead of gdbarch_byte_order.

	* mips-tdep.c (gdb_print_insn_mips): Likewise.
	* arm-tdep.c (gdb_print_insn_arm): Likewise.
@
text
@d929 1
a929 1
  status = read_memory_nobpt (addr, buf, instlen);
@


1.468
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d4881 1
a4881 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
@


1.467
log
@	Updated copyright notices for most files.
@
text
@d4586 1
a4586 1
mips_skip_prologue (CORE_ADDR pc)
@


1.466
log
@* mips-tdep.c (mips_n32n64_push_dummy_call): Sign-extend
integers and 32-bit pointers as required by the ABI.
@
text
@d4 1
a4 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.465
log
@* mips-tdep.c (extended_offset): Fix a comment.
@
text
@d3187 15
a3201 2
		  LONGEST regval =
		    extract_unsigned_integer (val, partial_len);
@


1.464
log
@	* gdbarch.sh (stab_reg_to_regnum, dwarf_reg_to_regnum)
	( dwarf2_reg_to_regnum, sdb_reg_to_regnum, ecoff_reg_to_regnum): Add
	gdbarch as parameter.
	* gdbarch.{c,h}: Regenerate.

	* xtensa-tdep.c (xtensa_reg_to_regnum): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* s390-tdep.c (s390_dwarf_reg_to_regnum): Likewise.
	* rs6000-tdep.c (rs6000_stab_reg_to_regnum)
	(rs6000_dwarf2_reg_to_regnum): Likewise.
	* mips-tdep.c (mips_stab_reg_to_regnum)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum): Likewise.
	* mep-tdep.c (mep_debug_reg_to_regnum): Likewise.
	* m32c-tdep.c (m32c_debug_info_reg_to_regnum): Likewise.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise
	* h8300-tdep.c (h8300s_dbg_reg_to_regnum)
	(h8300_dbg_reg_to_regnum): Likewise.
	* amd64-tdep.c (amd64_dwarf_reg_to_regnum): Likewise.
	* arch-utils.c (no_op_reg_to_regnum): Likewise.
	* arch-utils.h (no_op_reg_to_regnum): Likewise.
	* arm-tdep.c (arm_dwarf_reg_to_regnum): Likewise.
	* cris-tdep.c (cris_dwarf2_reg_to_regnum): Likewise.
	* hppa-tdep.c (hppa64_dwarf_reg_to_regnum): Likewise.
	* ia64-tdep.c (ia64_dwarf_reg_to_regnum): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
@
text
@d1154 1
a1154 1
   for the bits which make up the immediatate extension.  */
@


1.463
log
@* mips-tdep.c (mips16_scan_prologue): Handle the MIPS16e SAVE
instruction.
@
text
@d5043 1
a5043 1
mips_stab_reg_to_regnum (int num)
d5049 1
a5049 1
    regnum = num + mips_regnum (current_gdbarch)->fp0 - 38;
d5051 1
a5051 1
    regnum = mips_regnum (current_gdbarch)->hi;
d5053 1
a5053 1
    regnum = mips_regnum (current_gdbarch)->lo;
d5057 2
a5058 3
    return gdbarch_num_regs (current_gdbarch)
	   + gdbarch_num_pseudo_regs (current_gdbarch);
  return gdbarch_num_regs (current_gdbarch) + regnum;
d5066 1
a5066 1
mips_dwarf_dwarf2_ecoff_reg_to_regnum (int num)
d5072 1
a5072 1
    regnum = num + mips_regnum (current_gdbarch)->fp0 - 32;
d5074 1
a5074 1
    regnum = mips_regnum (current_gdbarch)->hi;
d5076 1
a5076 1
    regnum = mips_regnum (current_gdbarch)->lo;
d5080 2
a5081 3
    return gdbarch_num_regs (current_gdbarch)
	   + gdbarch_num_pseudo_regs (current_gdbarch);
  return gdbarch_num_regs (current_gdbarch) + regnum;
@


1.462
log
@2007-11-19  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_sim_regno): Add gdbarch as parameter.
	* gdbarch.{c,h}: Regenerate.

	* arch-utils.h (legacy_register_sim_regno): Add gdbarch as parameter.
	* score-tdep.c (score_register_sim_regno): Likewise.
	* sim-regno.h (one2one_register_sim_regno): Likewise.

	* arch-utils.c (legacy_register_sim_regno): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* sh-tdep.c (sh_sh2a_register_sim_regno)
	(sh_dsp_register_sim_regno): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* mips-tdep.c (mips_register_sim_regno): Likewise.
	* m32c-tdep.c (m32c_register_sim_regno): Likewise.
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* arm-tdep.c (arm_register_sim_regno): Likewise.
	* remote-sim.c (one2one_register_sim_regno): Likewise.
@
text
@d1503 1
d1607 6
d1671 95
@


1.461
log
@	* mips-tdep.c (show_mipsfpu_command): Do not crash if called when
	current architecture is not MIPS.
@
text
@d4985 1
a4985 1
mips_register_sim_regno (int regnum)
d4988 1
a4988 1
  gdb_assert (regnum >= 0 && regnum < gdbarch_num_regs (current_gdbarch));
d4992 4
a4995 6
  if (gdbarch_register_name (current_gdbarch,
			     gdbarch_num_regs
			       (current_gdbarch) + regnum) != NULL
      && gdbarch_register_name (current_gdbarch,
			        gdbarch_num_regs
				  (current_gdbarch) + regnum)[0] != '\0')
@


1.460
log
@	* gdbarch.sh (convert_register_p): Add gdbarch as parameter.
	* ia64-tdep.c (ia64_convert_register_p): Likewise.
	* i387-tdep.c (i387_convert_register_p): Likewise.
	* i387-tdep.h (i387_convert_register_p): Likewise.
	* alpha-tdep.c (alpha_convert_register_p): Likewise.
	* gdbarch.{c,h}: Regenerate.

	* rs6000-tdep.c (rs6000_convert_register_p): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* mips-tdep.c (mips_convert_register_p): Likewise.
	* m68k-tdep.c (m68k_convert_register_p): Likewise.
	* i386-tdep.c (i386_convert_register_p): Likewise.
@
text
@d4614 9
@


1.459
log
@include:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* floatformat.h (struct floatformat): Add split_half field.
	(floatformat_ibm_long_double): New.

libiberty:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* floatformat.c (mant_bits_set): New.
	(floatformat_to_double): Use it.  Note no special handling of
	split formats.
	(floatformat_from_double): Note no special handing of split
	formats.
	(floatformat_ibm_long_double_is_valid,
	floatformat_ibm_long_double): New.
	(floatformat_ieee_single_big, floatformat_ieee_single_little,
	floatformat_ieee_double_big, floatformat_ieee_double_little,
	floatformat_ieee_double_littlebyte_bigword, floatformat_vax_f,
	floatformat_vax_d, floatformat_vax_g, floatformat_i387_ext,
	floatformat_m68881_ext, floatformat_i960_ext,
	floatformat_m88110_ext, floatformat_m88110_harris_ext,
	floatformat_arm_ext_big, floatformat_arm_ext_littlebyte_bigword,
	floatformat_ia64_spill_big, floatformat_ia64_spill_little,
	floatformat_ia64_quad_big, floatformat_ia64_quad_little): Update
	for addition of split_half field.

gdb:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdbtypes.c (floatformats_ibm_long_double): New.
	* gdbtypes.h (floatformats_ibm_long_double): Declare.
	* ia64-tdep.c (floatformat_ia64_ext): Update for addition of
	split_half field.
	* mips-tdep.c (n32n64_floatformat_always_valid,
	floatformat_n32n64_long_double_big, floatformats_n32n64_long):
	Remove.
	(mips_gdbarch_init): Use floatformats_ibm_long_double instead of
	floatformats_n32n64_long.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Use 128-bit IBM long
	double.
	* doublest.c (convert_floatformat_to_doublest,
	convert_doublest_to_floatformat): Handle split floating-point
	formats.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Handle IBM long
	double arguments.
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	(do_ppc_sysv_return_value): Handle IBM long double return.
@
text
@d663 1
a663 1
mips_convert_register_p (int regnum, struct type *type)
d665 6
a670 6
  return (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG
	  && register_size (current_gdbarch, regnum) == 4
	  && (regnum % gdbarch_num_regs (current_gdbarch))
		>= mips_regnum (current_gdbarch)->fp0
	  && (regnum % gdbarch_num_regs (current_gdbarch))
		< mips_regnum (current_gdbarch)->fp0 + 32
@


1.458
log
@2007-11-07  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (legacy_virtual_frame_pointer): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.
	* arch-utils.c (legacy_virtual_frame_pointer): Add gdbarch parameter.
	Replace current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* mips-tdep.c (mips_virtual_frame_pointer): Likewise.
	* spu-tdep.c (spu_virtual_frame_pointer): Likewise.
@
text
@a201 32
static int
n32n64_floatformat_always_valid (const struct floatformat *fmt,
                                 const void *from)
{
  return 1;
}

/* FIXME: brobecker/2004-08-08: Long Double values are 128 bit long.
   They are implemented as a pair of 64bit doubles where the high
   part holds the result of the operation rounded to double, and
   the low double holds the difference between the exact result and
   the rounded result.  So "high" + "low" contains the result with
   added precision.  Unfortunately, the floatformat structure used
   by GDB is not powerful enough to describe this format.  As a temporary
   measure, we define a 128bit floatformat that only uses the high part.
   We lose a bit of precision but that's probably the best we can do
   for now with the current infrastructure.  */

static const struct floatformat floatformat_n32n64_long_double_big =
{
  floatformat_big, 128, 0, 1, 11, 1023, 2047, 12, 52,
  floatformat_intbit_no,
  "floatformat_n32n64_long_double_big",
  n32n64_floatformat_always_valid
};

static const struct floatformat *floatformats_n32n64_long[BFD_ENDIAN_UNKNOWN] =
{
  &floatformat_n32n64_long_double_big,
  &floatformat_n32n64_long_double_big
};

d5556 1
a5556 1
      set_gdbarch_long_double_format (gdbarch, floatformats_n32n64_long);
d5568 1
a5568 1
      set_gdbarch_long_double_format (gdbarch, floatformats_n32n64_long);
@


1.457
log
@*** empty log message ***
@
text
@d5043 2
a5044 1
mips_virtual_frame_pointer (CORE_ADDR pc, int *reg, LONGEST *offset)
@


1.456
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d4803 1
a4803 1
mips_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
d4805 1
a4805 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
@


1.455
log
@2007-10-23  Atsushi Nemoto  <anemo@@mba.ocn.ne.jp>

	* mips-tdep.c (LL_OPCODE, LLD_OPCODE, SC_OPCODE, SCD_OPCODE): Define.
	(deal_with_atomic_sequence): New.
	(mips_software_single_step): Use it.
@
text
@d496 1
a496 1
mips_register_name (int regno)
d498 1
a498 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d515 1
a515 1
  enum mips_abi abi = mips_abi (current_gdbarch);
d519 2
a520 2
  int rawnum = regno % gdbarch_num_regs (current_gdbarch);
  if (regno < gdbarch_num_regs (current_gdbarch))
d533 3
a535 3
  else if (tdesc_has_registers (gdbarch_target_desc (current_gdbarch)))
    return tdesc_register_name (rawnum);
  else if (32 <= rawnum && rawnum < gdbarch_num_regs (current_gdbarch))
@


1.454
log
@	* mips-tdep.c (mips_xfer_register): Take a gdbarch argument.
	(mips_n32n64_return_value, mips_o32_return_value)
	(mips_o64_return_value): Update calls to mips_xfer_register.
@
text
@d2300 105
d2416 3
@


1.453
log
@	* NEWS: Document target described register support for PowerPC.
	* ppc-tdep.h: Remove ppc_spr constants.
	(struct gdbarch_tdep): Remove regs, ppc_sr0_regnum, and
	ppc_builtin_type_vec128 members.
	(PPC_R0_REGNUM, PPC_F0_REGNUM, PPC_PC_REGNUM, PPC_MSR_REGNUM)
	(PPC_CR_REGNUM, PPC_LR_REGNUM, PPC_CTR_REGNUM, PPC_XER_REGNUM)
	(PPC_FPSCR_REGNUM, PPC_MQ_REGNUM, PPC_SPE_UPPER_GP0_REGNUM)
	(PPC_SPE_ACC_REGNUM, PPC_SPE_FSCR_REGNUM, PPC_VR0_REGNUM)
	(PPC_VSCR_REGNUM, PPC_VRSAVE_REGNUM, PPC_NUM_REGS): New constants.
	* rs6000-tdep.c: Include preparsed descriptions.
	(init_sim_regno_table): Do not iterate over pseudo registers.
	Look up segment registers by name.  Use sim_spr_register_name
	for SPRs.
	(rs6000_register_sim_regno): Call init_sim_regno_table here.
	(rs6000_builtin_type_vec128): Delete.
	(rs6000_register_name): Only handle SPE pseudo registers and upper
	halves.  Call tdesc_register_name for everything else.
	(rs6000_register_type): Delete.  Replace with...
	(rs6000_pseudo_register_type): ...this new function.  Only handle
	SPE pseudo registers.
	(rs6000_register_reggroup_p): Delete.  Replace with...
	(rs6000_pseudo_register_reggroup_p): ...this new function.  Only
	handle SPE pseudo registers.
	(rs6000_convert_register_p): Use ppc_fp0_regnum instead of
	"struct reg".
	(rs6000_register_to_value, rs6000_value_to_register): Remove check
	of reg->fpr.
	(e500_register_reggroup_p): Delete.
	(STR, R, R4, R8, R16, F, P8, R32, R64, R0, A4, S, S4, SN4, S64)
	(COMMON_UISA_REGS, PPC_UISA_SPRS, PPC_UISA_NOFP_SPRS)
	(PPC_SEGMENT_REGS, PPC_OEA_SPRS, PPC_ALTIVEC_REGS, PPC_SPE_GP_REGS)
	(PPC_SPE_UPPER_GP_REGS, PPC_EV_PSEUDO_REGS): Delete macros.
	(registers_powerpc, registers_403, registers_403GC, registers_505)
	(registers_860, registers_601, registers_602, registers_603)
	(registers_604, registers_750, registers_7400, registers_e500): Delete
	variables.
	(struct variant): Delete nregs, npregs, num_tot_regs, and regs.  Add
	tdesc.
	(tot_num_registers, num_registers, num_pseudo_registers): Delete.
	(variants): Delete outdated comment.  Use standard target descriptions
	instead of "struct reg" arrays.
	(init_variants): Delete.
	(rs6000_gdbarch_init): Do not guess word size from the BFD
	architecture if we have a target description.  Select a variant
	before creating a new architecture.  Use the variant's target
	description if the target did not define a register layout.
	Validate target-supplied registers.  Reject mismatches.  Use
	fixed register numbers and new constants instead of magic
	numbers.  Call set_gdbarch_ps_regnum.  Call tdesc_use_registers.
	(_initialize_rs6000_tdep): Initialize the preparsed target
	descriptions.
	* target-descriptions.c (tdesc_predefined_types): Add int128 and
	uint128.
	(tdesc_find_register_early): New function.
	(tdesc_numbered_register): Use it.
	(tdesc_register_size): New function.
	(tdesc_use_registers): Take a target_desc argument.  Do not use
	gdbarch_target_desc.
	* target-descriptions.h (tdesc_use_registers): Update prototype
	and comment.
	(tdesc_register_size): New prototype.
	* Makefile.in (powerpc_32_c, powerpc_403_c, powerpc_403gc_c)
	(powerpc_505_c, powerpc_601_c, powerpc_602_c, powerpc_603_c)
	(powerpc_604_c, powerpc_64_c, powerpc_7400_c, powerpc_750_c)
	(powerpc_860_c, powerpc_e500_c, rs6000_c): New macros.
	(rs6000-tdep.o): Update.
	* arm-tdep.c (arm_gdbarch_init): Update call to tdesc_use_registers.
	* m68k-tdep.c (m68k_gdbarch_init): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.

	* gdb.texinfo (Predefined Target Types): Add int128
	and uint128.
	(Standard Target Features): Add PowerPC features.

	* gdb.xml/tdesc-regs.exp: Add PowerPC support.

	* sim-ppc.h (sim_spr_register_name): New prototype.

	* gdb-sim.c (regnum2spr): Rename to...
	(sim_spr_register_name): ... this.  Make global.
@
text
@d346 2
a347 1
mips_xfer_register (struct regcache *regcache, int reg_num, int length,
a351 1
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
d3113 1
a3113 1
      mips_xfer_register (regcache,
d3118 1
a3118 1
      mips_xfer_register (regcache,
d3132 1
a3132 1
      mips_xfer_register (regcache,
d3166 2
a3167 2
	  mips_xfer_register (regcache, gdbarch_num_regs (gdbarch)
					+ regnum,
d3192 2
a3193 1
	  mips_xfer_register (regcache, gdbarch_num_regs (gdbarch) + regnum,
d3215 2
a3216 1
	  mips_xfer_register (regcache, gdbarch_num_regs (gdbarch) + regnum,
d3548 1
a3548 1
      mips_xfer_register (regcache,
d3567 1
a3567 1
	  mips_xfer_register (regcache,
d3572 1
a3572 1
	  mips_xfer_register (regcache,
d3579 1
a3579 1
	  mips_xfer_register (regcache,
d3584 1
a3584 1
	  mips_xfer_register (regcache,
d3623 2
a3624 2
	  mips_xfer_register (regcache, gdbarch_num_regs (gdbarch)
					+ regnum,
d3651 2
a3652 2
	  mips_xfer_register (regcache, gdbarch_num_regs (gdbarch)
					+ regnum, xfer,
d3675 2
a3676 2
	  mips_xfer_register (regcache, gdbarch_num_regs (gdbarch)
					+ regnum, xfer,
d3936 1
a3936 1
      mips_xfer_register (regcache,
d3960 2
a3961 1
	  mips_xfer_register (regcache, gdbarch_num_regs (gdbarch) + regnum,
@


1.452
log
@2007-10-10  Markus Deuling  <deuling@@de.ibm.com>

	* mips-tdep.c (mips_xfer_register): Use get_regcache_arch to get at the
	current architecture by regcache.
	(mips2_fp_compat, mips32_next_pc, mips16_scan_prologue)
	(mips_insn16_frame_cache, mips32_scan_prologue, mips_insn32_frame_cache)
	(mips_stub_frame_cache, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row): Use get_frame_arch to get
	at the current architecture by frame_info.
	(mips_register_reggroup_p, mips_pseudo_register_read, mips_unwind_sp)
	(mips_pseudo_register_write, mips_register_type, mips_unwind_pc)
	(mips_unwind_dummy_id, mips_eabi_push_dummy_call)
	(mips_n32n64_push_dummy_call, mips_n32n64_return_value)
	(mips_o32_push_dummy_call, mips_o32_return_value)
	(mips_o64_push_dummy_call, mips_o64_return_value)
	(mips_print_registers_info, mips_dump_tdep): Replace current_gdbarch by
	gdbarch.
@
text
@d5652 1
a5652 1
      tdesc_use_registers (gdbarch, tdesc_data);
@


1.451
log
@* mips-tdep.c (mips32_next_pc): Fix a typo in BGTZL.
@
text
@d351 3
a353 1
  gdb_assert (reg_num >= gdbarch_num_regs (current_gdbarch));
d359 1
a359 1
      reg_offset = register_size (current_gdbarch, reg_num) - length;
d405 1
d408 1
a408 2
  if (register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0) ==
      4)
d554 2
a555 2
  int rawnum = regnum % gdbarch_num_regs (current_gdbarch);
  int pseudo = regnum / gdbarch_num_regs (current_gdbarch);
d562 3
a564 3
  raw_p = rawnum < gdbarch_num_regs (current_gdbarch);
  if (gdbarch_register_name (current_gdbarch, regnum) == NULL
      || gdbarch_register_name (current_gdbarch, regnum)[0] == '\0')
d620 3
a622 3
  int rawnum = cookednum % gdbarch_num_regs (current_gdbarch);
  gdb_assert (cookednum >= gdbarch_num_regs (current_gdbarch)
	      && cookednum < 2 * gdbarch_num_regs (current_gdbarch));
d629 1
a629 1
	  || gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
d643 3
a645 3
  int rawnum = cookednum % gdbarch_num_regs (current_gdbarch);
  gdb_assert (cookednum >= gdbarch_num_regs (current_gdbarch)
	      && cookednum < 2 * gdbarch_num_regs (current_gdbarch));
d652 1
a652 1
	  || gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
d728 4
a731 5
  gdb_assert (regnum >= 0 && regnum < 2 * gdbarch_num_regs (current_gdbarch));
  if ((regnum % gdbarch_num_regs (current_gdbarch))
	>= mips_regnum (current_gdbarch)->fp0
      && (regnum % gdbarch_num_regs (current_gdbarch))
	< mips_regnum (current_gdbarch)->fp0 + 32)
d740 1
a740 1
  else if (regnum < gdbarch_num_regs (current_gdbarch))
d753 3
a755 4
      if (regnum >= (gdbarch_num_regs (current_gdbarch)
		     + mips_regnum (current_gdbarch)->fp_control_status)
	  && regnum <= gdbarch_num_regs (current_gdbarch)
		       + MIPS_LAST_EMBED_REGNUM)
d911 2
a912 3
  return frame_unwind_register_signed (next_frame,
				       gdbarch_num_regs (current_gdbarch)
				       + mips_regnum (gdbarch)->pc);
d918 2
a919 3
  return frame_unwind_register_signed (next_frame,
				       gdbarch_num_regs (current_gdbarch)
				       + MIPS_SP_REGNUM);
d932 1
a932 1
					  gdbarch_num_regs (current_gdbarch)
d1024 2
a1025 1
	    get_frame_register_signed (frame, mips_regnum (current_gdbarch)->
d1540 1
d1546 1
a1546 1
				       gdbarch_num_regs (current_gdbarch)
d1677 1
a1677 1
	  offset += mips_abi_regsize (current_gdbarch);
d1685 1
a1685 1
	  offset -= mips_abi_regsize (current_gdbarch);
d1692 1
a1692 1
	  offset -= mips_abi_regsize (current_gdbarch);
d1700 1
a1700 2
				       gdbarch_num_regs (current_gdbarch)
				       + frame_reg)
d1705 3
a1707 4
      this_cache->saved_regs[gdbarch_num_regs (current_gdbarch)
			     + mips_regnum (current_gdbarch)->pc]
        = this_cache->saved_regs[gdbarch_num_regs (current_gdbarch)
				 + MIPS_RA_REGNUM];
d1752 4
a1755 2
  trad_frame_set_value (cache->saved_regs, gdbarch_num_regs (current_gdbarch)
					   + MIPS_SP_REGNUM, cache->base);
d1863 1
d1869 1
a1869 1
				       gdbarch_num_regs (current_gdbarch)
d1926 1
a1926 2
			     (next_frame,
			      gdbarch_num_regs (current_gdbarch) + 30);
d1956 1
a1956 2
			     (next_frame,
			      gdbarch_num_regs (current_gdbarch) + 30);
d2023 1
a2023 2
				       gdbarch_num_regs (current_gdbarch)
				       + frame_reg)
d2028 3
a2030 3
      this_cache->saved_regs[gdbarch_num_regs (current_gdbarch)
			     + mips_regnum (current_gdbarch)->pc]
        = this_cache->saved_regs[gdbarch_num_regs (current_gdbarch)
d2088 2
a2089 1
			gdbarch_num_regs (current_gdbarch) + MIPS_SP_REGNUM,
d2167 1
d2176 2
a2177 3
			      gdbarch_pc_regnum (current_gdbarch),
			      (gdbarch_num_regs (current_gdbarch)
			       + MIPS_RA_REGNUM));
d2552 1
a2552 1
  float_argreg = mips_fpa0_regnum (current_gdbarch);
d2629 1
a2629 1
	      int low_offset = gdbarch_byte_order (current_gdbarch)
d2694 1
a2694 1
		  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d2886 1
a2886 1
  float_argreg = mips_fpa0_regnum (current_gdbarch);
d2970 1
a2970 1
		  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d3021 1
a3021 1
		  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG
d3077 1
a3077 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d3114 3
a3116 3
			  gdbarch_num_regs (current_gdbarch)
			  + mips_regnum (current_gdbarch)->fp0,
			  8, gdbarch_byte_order (current_gdbarch),
d3119 3
a3121 3
			  gdbarch_num_regs (current_gdbarch)
			  + mips_regnum (current_gdbarch)->fp0 + 2,
			  8, gdbarch_byte_order (current_gdbarch),
d3133 2
a3134 2
			  gdbarch_num_regs (current_gdbarch)
			  + mips_regnum (current_gdbarch)->fp0,
d3136 1
a3136 1
			  gdbarch_byte_order (current_gdbarch),
d3158 1
a3158 1
      for (field = 0, regnum = mips_regnum (current_gdbarch)->fp0;
d3166 1
a3166 1
	  mips_xfer_register (regcache, gdbarch_num_regs (current_gdbarch)
d3169 1
a3169 1
			      gdbarch_byte_order (current_gdbarch),
d3184 1
a3184 1
	   offset += register_size (current_gdbarch, regnum), regnum++)
d3186 1
a3186 1
	  int xfer = register_size (current_gdbarch, regnum);
d3192 3
a3194 3
	  mips_xfer_register (regcache, gdbarch_num_regs (current_gdbarch)
					+ regnum, xfer,
			      BFD_ENDIAN_UNKNOWN, readbuf, writebuf, offset);
d3206 1
a3206 1
	   offset += register_size (current_gdbarch, regnum), regnum++)
d3208 1
a3208 1
	  int xfer = register_size (current_gdbarch, regnum);
d3214 2
a3215 3
	  mips_xfer_register (regcache, gdbarch_num_regs (current_gdbarch)
					+ regnum, xfer,
			      gdbarch_byte_order (current_gdbarch),
d3276 1
a3276 1
  float_argreg = mips_fpa0_regnum (current_gdbarch);
d3333 1
a3333 1
	      int low_offset = gdbarch_byte_order (current_gdbarch)
d3485 1
a3485 1
		  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG
d3533 1
a3533 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d3547 2
a3548 2
			  gdbarch_num_regs (current_gdbarch)
			    + mips_regnum (current_gdbarch)->fp0,
d3550 1
a3550 1
			  gdbarch_byte_order (current_gdbarch),
d3562 1
a3562 1
      switch (gdbarch_byte_order (current_gdbarch))
d3566 3
a3568 3
			      gdbarch_num_regs (current_gdbarch)
				+ mips_regnum (current_gdbarch)->fp0 +
			      0, 4, gdbarch_byte_order (current_gdbarch),
d3571 3
a3573 3
			      gdbarch_num_regs (current_gdbarch)
				+ mips_regnum (current_gdbarch)->fp0 + 1,
			      4, gdbarch_byte_order (current_gdbarch),
d3578 3
a3580 3
			      gdbarch_num_regs (current_gdbarch)
				+ mips_regnum (current_gdbarch)->fp0 + 1,
			      4, gdbarch_byte_order (current_gdbarch),
d3583 3
a3585 3
			      gdbarch_num_regs (current_gdbarch)
				+ mips_regnum (current_gdbarch)->fp0 + 0,
			      4, gdbarch_byte_order (current_gdbarch),
d3613 1
a3613 1
      for (field = 0, regnum = mips_regnum (current_gdbarch)->fp0;
d3621 1
a3621 1
	  mips_xfer_register (regcache, gdbarch_num_regs (current_gdbarch)
d3624 1
a3624 1
			      gdbarch_byte_order (current_gdbarch),
d3641 1
a3641 1
	   offset += register_size (current_gdbarch, regnum), regnum++)
d3643 1
a3643 1
	  int xfer = register_size (current_gdbarch, regnum);
d3649 1
a3649 1
	  mips_xfer_register (regcache, gdbarch_num_regs (current_gdbarch)
d3673 1
a3673 1
	  mips_xfer_register (regcache, gdbarch_num_regs (current_gdbarch)
d3675 1
a3675 1
			      gdbarch_byte_order (current_gdbarch),
d3735 1
a3735 1
  float_argreg = mips_fpa0_regnum (current_gdbarch);
d3822 1
a3822 1
		  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d3874 1
a3874 1
		  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG
d3922 1
a3922 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d3935 2
a3936 2
			  gdbarch_num_regs (current_gdbarch)
			    + mips_regnum (current_gdbarch)->fp0,
d3938 1
a3938 1
			  gdbarch_byte_order (current_gdbarch),
d3958 2
a3959 3
	  mips_xfer_register (regcache, gdbarch_num_regs (current_gdbarch)
					+ regnum, xfer,
			      gdbarch_byte_order (current_gdbarch),
d4015 2
a4016 1
  int raw_size = register_size (current_gdbarch, regno);
d4021 1
a4021 1
	   regno, gdbarch_register_name (current_gdbarch, regno));
d4028 1
a4028 1
      if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d4049 2
a4050 1
  int raw_size = register_size (current_gdbarch, regno);
d4058 1
a4058 1
	       regno, gdbarch_register_name (current_gdbarch, regno));
d4062 1
a4062 1
      int rawnum = regno % gdbarch_num_regs (current_gdbarch);
d4064 1
a4064 1
      if ((rawnum - mips_regnum (current_gdbarch)->fp0) & 1)
d4071 1
a4071 1
      if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d4088 1
d4093 1
a4093 2
  raw_buffer = alloca (2 * register_size (current_gdbarch,
					  mips_regnum (current_gdbarch)->fp0));
d4095 1
a4095 2
  fprintf_filtered (file, "%s:",
		    gdbarch_register_name (current_gdbarch, regnum));
d4097 1
a4097 2
		    4 - (int) strlen (gdbarch_register_name
					(current_gdbarch, regnum)),
d4100 1
a4100 1
  if (register_size (current_gdbarch, regnum) == 4 || mips2_fp_compat (frame))
d4116 1
a4116 1
      if ((regnum - gdbarch_num_regs (current_gdbarch)) % 2 == 0)
d4174 1
a4174 1
			gdbarch_register_name (current_gdbarch, regnum));
d4178 1
a4178 1
  fputs_filtered (gdbarch_register_name (current_gdbarch, regnum), file);
d4189 1
a4189 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d4191 1
a4191 2
      register_size (current_gdbarch,
		     regnum) - register_size (current_gdbarch, regnum);
d4229 2
a4230 2
       col < ncols && regnum < gdbarch_num_regs (current_gdbarch)
			       + gdbarch_num_pseudo_regs (current_gdbarch);
d4233 1
a4233 1
      if (*gdbarch_register_name (current_gdbarch, regnum) == '\0')
d4239 1
a4239 2
      if (register_size (current_gdbarch, regnum)
	  > mips_abi_regsize (current_gdbarch))
d4252 2
a4253 2
			mips_abi_regsize (current_gdbarch) == 8 ? "%17s" : "%9s",
			gdbarch_register_name (current_gdbarch, regnum));
d4261 1
a4261 1
  if ((start_regnum % gdbarch_num_regs (current_gdbarch)) < MIPS_NUMREGS)
d4263 1
a4263 1
		      start_regnum % gdbarch_num_regs (current_gdbarch));
d4269 2
a4270 2
       col < ncols && regnum < gdbarch_num_regs (current_gdbarch)
			       + gdbarch_num_pseudo_regs (current_gdbarch);
d4273 1
a4273 1
      if (*gdbarch_register_name (current_gdbarch, regnum) == '\0')
d4278 1
a4278 2
      if (register_size (current_gdbarch, regnum)
	  > mips_abi_regsize (current_gdbarch))
d4284 1
a4284 1
	       regnum, gdbarch_register_name (current_gdbarch, regnum));
d4287 2
a4288 2
	   byte < (mips_abi_regsize (current_gdbarch)
		   - register_size (current_gdbarch, regnum)); byte++)
d4291 1
a4291 1
      if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d4293 2
a4294 3
	     register_size (current_gdbarch,
			    regnum) - register_size (current_gdbarch, regnum);
	     byte < register_size (current_gdbarch, regnum); byte++)
d4297 1
a4297 1
	for (byte = register_size (current_gdbarch, regnum) - 1;
d4317 2
a4318 2
      gdb_assert (regnum >= gdbarch_num_regs (current_gdbarch));
      if (*(gdbarch_register_name (current_gdbarch, regnum)) == '\0')
d4327 3
a4329 3
      regnum = gdbarch_num_regs (current_gdbarch);
      while (regnum < gdbarch_num_regs (current_gdbarch)
		      + gdbarch_num_pseudo_regs (current_gdbarch))
d5735 1
a5735 1
mips_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
d5737 1
a5737 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.450
log
@	* mips-tdep.c (mips_read_fp_register_double): Correct check for
	odd FP registers.
	(mips_print_fp_register): Correct check for even FP registers.
	(mips_virtual_frame_pointer): New function.
	(mips_gdbarch_init): Call set_gdbarch_virtual_frame_pointer.
@
text
@d1014 1
a1014 1
	    case 3:		/* BGTZ */
@


1.449
log
@* mips-tdep.c (mips_n32n64_return_value): Fix a comment.
@
text
@d4063 3
a4065 1
      if ((regno - mips_regnum (current_gdbarch)->fp0) & 1)
d4119 1
a4119 1
      if (regnum % 2 == 0)
d4933 12
d5426 1
@


1.448
log
@* mips-tdep.c (mips_n32n64_return_value): Per N32/N64 ABI
rules return composite types in registers as appropriate.
@
text
@d3130 1
a3130 2
      /* A floating-point value belongs in the least significant part
         of FP0.  */
@


1.447
log
@* mips-tdep.c (mips_n32n64_push_dummy_call): Per N32/N64 ABI
rules do not treat composite types specially.
@
text
@d3079 24
a3102 3
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      || TYPE_CODE (type) == TYPE_CODE_UNION
      || TYPE_CODE (type) == TYPE_CODE_ARRAY
d3146 1
a3146 1
		&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
d3149 1
a3149 1
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
d3151 1
a3151 1
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 1))
@


1.446
log
@* mips-tdep.c (mips32_in_function_epilogue_p): New function.
(mips16_in_function_epilogue_p): Likewise.
(mips_in_function_epilogue_p): Likewise.
(mips_gdbarch_init): Register mips_in_function_epilogue_p().
@
text
@d2940 8
a2947 6
	  /* Note: structs whose size is not a multiple of MIPS64_REGSIZE
	     are treated specially: Irix cc passes them in registers
	     where gcc sometimes puts them on the stack.  For maximum
	     compatibility, we will put them in both places.  */
	  int odd_sized_struct = (len > MIPS64_REGSIZE
				  && len % MIPS64_REGSIZE != 0);
d2964 1
a2964 2
	      if (argreg > MIPS_LAST_ARG_REGNUM
		  || odd_sized_struct)
@


1.445
log
@	* mips-tdep.c (mips_stub_frame_cache): Correct the saved return
	address register.  Correct the call to frame_id_build.
	(mips_stub_frame_sniffer): Use the stub unwinder when the PC
	is invalid.
@
text
@d4407 89
d5577 2
@


1.444
log
@	* arch-utils.c (gdbarch_info_fill): Also try core_bfd.
	* corelow.c (core_read_description): New.
	(init_core_ops): Set to_read_description.
	* gdbarch.sh: Add gdbarch_core_read_description.
	* mips-linux-tdep.c (mips_linux_core_read_description): New.
	(mips_linux_init_abi): Call set_gdbarch_core_read_description.
	* mips-tdep.c (mips_tdesc_gp32, mips_tdesc_gp64): New.
	(mips_register_g_packet_guesses): Use them.
	(_initialize_mips_tdep): Initialize them.
	* mips-tdep.h (mips_tdesc_gp32, mips_tdesc_gp64): Declare.
	* gdbarch.h, gdbarch.c: Regenerated.
@
text
@d2177 2
a2178 1
			      MIPS_RA_REGNUM);
d2185 1
a2185 1
  trad_frame_set_id (this_trad_cache, frame_id_build (start_addr, stack_addr));
d2226 1
d2230 4
@


1.443
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d168 3
a4871 14
  static struct target_desc *tdesc_gp32, *tdesc_gp64;

  if (tdesc_gp32 == NULL)
    {
      /* Create feature sets with the appropriate properties.  The values
	 are not important.  */

      tdesc_gp32 = allocate_target_description ();
      set_tdesc_property (tdesc_gp32, PROPERTY_GP32, "");

      tdesc_gp64 = allocate_target_description ();
      set_tdesc_property (tdesc_gp64, PROPERTY_GP64, "");
    }

d4874 2
a4875 2
  register_remote_g_packet_guess (gdbarch, 38 * 4, tdesc_gp32);
  register_remote_g_packet_guess (gdbarch, 38 * 8, tdesc_gp64);
d4880 2
a4881 2
  register_remote_g_packet_guess (gdbarch, 90 * 4, tdesc_gp32);
  register_remote_g_packet_guess (gdbarch, 90 * 8, tdesc_gp64);
d5688 8
@


1.443.2.1
log
@	* mips-tdep.c (mips_stub_frame_cache): Correct the saved return
	address register.  Correct the call to frame_id_build.
	(mips_stub_frame_sniffer): Use the stub unwinder when the PC
	is invalid.
@
text
@d2174 1
a2174 2
			      (gdbarch_num_regs (current_gdbarch)
			       + MIPS_RA_REGNUM));
d2181 1
a2181 1
  trad_frame_set_id (this_trad_cache, frame_id_build (stack_addr, start_addr));
a2221 1
  gdb_byte dummy[4];
a2224 4
  /* Use the stub unwinder for unreadable code.  */
  if (target_read_memory (frame_pc_unwind (next_frame), dummy, 4) != 0)
    return &mips_stub_frame_unwind;

@


1.442
log
@	* mips-tdep.c (mips_gdbarch_init): Use Tag_GNU_MIPS_ABI_FP to
	determine the file's FPU type.
@
text
@d14 1
a14 1
   the Free Software Foundation; either version 2 of the License, or
d23 1
a23 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.441
log
@	gdb/testsuite/
	* gdb.base/callfuncs.exp (do_function_calls): Use t_double_int
	and t_int_double.
	* gdb.base/callfuncs.c (t_double_int, t_int_double): New.

	gdb/
	* mips-tdep.c (mips_n32n64_fp_arg_chunk_p): New.
	(mips_n32n64_push_dummy_call): Always increment float_argreg along
	with argreg.  Use mips_n32n64_fp_arg_chunk_p.
@
text
@d4916 1
d5124 7
d5133 17
@


1.440
log
@* mips-tdep.c (heuristic_proc_start): Add more MIPS16 function
prologue instructions.
@
text
@d2784 53
d2911 1
a2911 1
	  && float_argreg <= MIPS_LAST_FP_ARG_REGNUM)
a2914 2
	  /* On 32 bit ABI's the float_argreg is further adjusted
	     above to ensure that it is even register aligned.  */
d2919 1
a2919 1
	  regcache_cooked_write_unsigned (regcache, float_argreg++, regval);
d2925 2
a2926 1
	  argreg += 1;
d2951 3
d2956 1
a2956 2
		  || odd_sized_struct
		  || fp_register_arg_p (typecode, arg_type))
d2997 1
a2997 2
	         structs may go thru BOTH paths.  Floating point
	         arguments will not.  */
d3000 1
a3000 2
	      if (argreg <= MIPS_LAST_ARG_REGNUM
		  && !fp_register_arg_p (typecode, arg_type))
d3026 13
@


1.439
log
@* mips-tdep.c (mips_next_pc): Use is_mips16_addr() instead of
a direct test.
@
text
@d2399 2
d2406 15
a2420 4
	if (((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)	/* entry */
	    || (inst & 0xff80) == 0x6380	/* addiu sp,-n */
	    || (inst & 0xff80) == 0xfb80	/* daddiu sp,-n */
	    || ((inst & 0xf810) == 0xf010 && seen_adjsp))	/* extend -n */
@


1.438
log
@* mips-tdep.c (fetch_mips_16): Fix typos and reformat the
description.
@
text
@d1438 1
a1438 1
   The MIPS32 and MIPS16 variants are quite different */
d1442 1
a1442 1
  if (pc & 0x01)
@


1.437
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1201 3
a1203 4
   instruction, It wont malfunction, but why make excess remote memory references?
   If the immediate operands get sign extended or somthing, do it after
   the extension is performed.
 */
d1205 1
a1205 2
   when the offset is to be used in relative addressing */

@


1.436
log
@	* regcache.c (struct regcache): Add ptid_t member.
	(regcache_xmalloc): Initialize it.
	(regcache_cpy_no_passthrough): Do not refer to current_regcache.
	(regcache_dup): Likewise.
	(regcache_dup_no_passthrough): Likewise.
	(current_regcache): Make static.
	(registers_ptid): Remove variable.
	(get_thread_regcache): New function.
	(get_current_regcache): New function.
	(registers_changed): Implement by freeing current regcache.
	(regcache_raw_read): Do not refer to current_regcache.  Set
	inferior_ptid to regcache->ptid while calling target routines.
	(regcache_raw_write): Likewise.
	(regcache_raw_supply): Do not refer to current_regcache.
	(read_pc_pid): Use thread regcache.  Do not modify inferior_ptid.
	(write_pc_pid): Likewise.
	(build_regcache): Remove.
	(_initialize_regcache): Do not call DEPRECATED_REGISTER_GDBARCH_SWAP
	or deprecated_register_gdbarch_swap.  Do not initialize
	registers_ptid.
	* regcache.h (get_current_regcache): Add prototype.
	(get_thread_regcache): Likewise.
	(current_regcache): Remove declaration.

	* corelow.c (core_open): Replace current_regcache by
	get_current_regcache ().
	* frame.c (frame_pop): Likewise.
	(put_frame_register): Likewise.
	(get_current_frame, create_new_frame): Likewise.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Likewise.
	* stack.c (return_command): Likewise.
	* infcall.c (call_function_by_hand): Likewise.
	* infrun.c (resume): Likewise.
	(save_inferior_status, restore_inferior_status): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	(fork_save_infrun_state): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* i386fbsd-nat.c (i386fbsd_resume): Likewise.
	* monitor.c (monitor_wait): Likewise.
	* remote.c (remote_wait): Likewise.
	* remote-mips.c (mips_wait): Likewise.

	* bsd-kvm.c (bsd_kvm_open): Likewise
	(bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Likewise.
	* fbsd-nat.c (fbsd_make_corefile_notes): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint): Likewise.
	(ia64_linux_stopped_data_address): Likewise.

	* frv-tdep.c (frv_fdpic_loadmap_addresses): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* mep-tdep.c (current_me_module, current_options): Likewise.
	* mips-tdep.c (deprecated_mips_set_processor_regs_hack): Likewise.

	* linux-nat.c (linux_nat_do_thread_registers): Use thread
	regcache instead of current_regcache.  Call target_fetch_registers.
	(linux_nat_corefile_thread_callback): Update call site.
	(linux_nat_do_registers): Likewise.
	* procfs.c (procfs_do_thread_registers): Use thread regcache instead
	of current_regcache.
	(procfs_make_note_section): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
@
text
@d1754 1
a1754 1
  /* SP_REGNUM, contains the value and not the address.  */
d2089 1
a2089 1
  /* SP_REGNUM, contains the value and not the address.  */
d2176 3
a2178 1
  trad_frame_set_reg_realreg (this_trad_cache, PC_REGNUM, MIPS_RA_REGNUM);
d5200 1
a5200 1
    /* FIXME: cagney/2003-11-15: For MIPS, hasn't PC_REGNUM been
@


1.435
log
@	* gdbarch.sh (read_pc): Add REGCACHE argument.  Remove PTID argument.
	(write_pc): Likewise.  Remove default implementation, add predicate.
	* gdbarch.c, gdbarch.h: Regenerate.
	* regcache.c (read_pc_pid): Use current regcache instead of calling
	read_register_pid.
	(write_pc_pid): Check gdbarch_write_pc predicate, implement default
	case inline.
	(generic_target_write_pc): Remove.
	* inferior.h (generic_target_write_pc): Remove.
	* frv-tdep.c (frv_gdbarch_init): Do not install it.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Likewise.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	* sh64-tdep.c (sh64_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.

	* avr-tdep.c (avr_read_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling read_register_pid.
	* hppa-hpux-tdep.c (hppa_hpux_read_pc): Likewise.
	* hppa-tdep.c (hppa_read_pc): Likewise.
	* hppa-tdep.h (hppa_read_pc): Likewise.
	* ia64-tdep.c (ia64_read_pc): Likewise.
	* m32r-tdep.c (m32r_read_pc): Likewise.
	* mep-tdep.c (mep_read_pc): Likewise.
	* mn10300-tdep.c (mn10300_read_pc): Likewise.
	* spu-tdep.c (spu_read_pc): Likewise.

	* arm-tdep.c (arm_write_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling write_register_pid.
	* avr-tdep.c (avr_write_pc): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_write_pc): Likewise.
	* hppa-tdep.c (hppa_write_pc): Likewise.
	* hppa-tdep.h (hppa_write_pc): Likewise.
	* i386-linux-tdep.c (i386_linux_write_pc): Likewise.
	* amd64-linux-tdep.c (amd64_linux_write_pc): Likewise.
	* ia64-linux-tdep.c (ia64_linux_write_pc): Likewise.
	* ia64-tdep.c (ia64_write_pc): Likewise.
	* ia64-tdep.h (ia64_write_pc): Likewise.
	* m32r-tdep.c (m32r_write_pc): Likewise.
	* m88k-tdep.c (m88k_write_pc): Likewise.
	* mep-tdep.c (mep_write_pc): Likewise.
	* mips-tdep.c (mips_write_pc): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.
	* mn10300-tdep.c (mn10300_write_pc): Likewise.
	* sparc-tdep.c (sparc_write_pc): Likewise.
	* spu-tdep.c (spu_write_pc): Likewise.

	* mips-tdep.c (read_signed_register): Remove.
	(read_signed_register_pid): Likewise.
	(mips_read_pc): Add REGCACHE argument.  Remove PTID argument.
	Use REGCACHE instead of calling read_signed_register_pid.
@
text
@d4437 1
a4437 1
  regcache_cooked_read_unsigned (current_regcache,
@


1.434
log
@	* gdbarch.sh (skip_trampoline_code): Add FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (generic_skip_trampoline_code): Add FRAME argument.
	* arch-utils.h (generic_skip_trampoline_code): Likewise.
	* infrun.c (handle_inferior_event): Pass current frame to
	gdbarch_skip_trampoline_code and skip_language_trampoline.

	* language.c (unk_lang_trampoline): Add FRAME argument.
	(skip_language_trampoline): Add FRAME argument.  Pass it to
	skip_trampoline callback.
	* language.h: Add forward declaration of struct frame_info.
	(struct language_defn): Add FRAME argument to skip_trampoline.
	(skip_language_trampoline): Add FRAME argument.
	* cp-abi.c (cplus_skip_trampoline): Add FRAME argument.  Pass it
	to skip_trampoline callback.
	* cp-abi.h: Add forward declaration of struct frame_info.
	(cplus_skip_trampoline): Add FRAME argument.
	(struct cp_abi_ops): Add FRAME argument to skip_trampoline callback.
	* gnu-v3-abi.c (gnuv3_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.
	* objc-lang.c (objc_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.

	* minsyms.c (find_solib_trampoline_target): Add FRAME argument.
	* symtab.h (find_solib_trampoline_target): Likewise.
	* obsd-tdep.c (obsd_skip_solib_resolver): Pass current frame to
	find_solib_trampoline_target.

	* arm-tdep.c (arm_skip_stub): Add FRAME argument.  Read registers
	from FRAME instead of calling read_register.

	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code): Add FRAME
	argument.  Read registers from FRAME instead of using read_register.
	* hppa-tdep.c (hppa_skip_trampoline_code): Likewise.
	* hppa-tdep.h (hppa_skip_trampoline_code): Add FRAME argument.

	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Add FRAME
	argument.

	* m32c-tdep.c (m32c_skip_trampoline_code): Add FRAME argument.

	* mips-tdep.c (mips_skip_trampoline_code): Add FRAME argument.  Read
	registers from FRAME instead of using read_signed_register.

	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Add FRAME
	argument.
	(ppc64_standard_linkage_target): Likewise.  Read registers from FRAME
	instead of using read_register.
	(ppc64_skip_trampoline_code): Add FRAME argument.  Pass it to
	ppc64_standard_linkage_target.
	* rs6000-tdep.c (rs6000_skip_trampoline_code): Add FRAME argument.
	Pass it to find_solib_trampoline_target.  Read registers from FRAME
	instead of using read_register.

	* xstormy16-tdep.c (xstormy16_skip_trampoline_code): Add FRAME
	argument.
@
text
@a268 30
/* Return the contents of register REGNUM as a signed integer.  */

static LONGEST
read_signed_register (int regnum)
{
  LONGEST val;
  regcache_cooked_read_signed (current_regcache, regnum, &val);
  return val;
}

static LONGEST
read_signed_register_pid (int regnum, ptid_t ptid)
{
  ptid_t save_ptid;
  LONGEST retval;

  if (ptid_equal (ptid, inferior_ptid))
    return read_signed_register (regnum);

  save_ptid = inferior_ptid;

  inferior_ptid = ptid;

  retval = read_signed_register (regnum);

  inferior_ptid = save_ptid;

  return retval;
}

d899 1
a899 1
mips_read_pc (ptid_t ptid)
d901 4
a904 1
  return read_signed_register_pid (mips_regnum (current_gdbarch)->pc, ptid);
d939 1
a939 1
mips_write_pc (CORE_ADDR pc, ptid_t ptid)
d941 2
a942 1
  write_register_pid (mips_regnum (current_gdbarch)->pc, pc, ptid);
@


1.433
log
@	* gdbarch.sh (software_single_step): Replace REGCACHE argument by
	FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* infrun.c (resume): Pass current frame to SOFTWARE_SINGLE_STEP.

	* alpha-tdep.c (alpha_next_pc): Add FRAME argument.  Retrieve
	registers from FRAME instead of using read_register.
	(alpha_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to alpha_next_pc.  Use get_frame_pc instead of read_pc.
	* alpha-tdep.h (alpha_software_single_step): Replace REGCACHE
	argument by FRAME.

	* arm-tdep.c (shifted_reg_val): Add FRAME argument.  Read registers
	from FRAME instead of using read_register.
	(thumb_get_next_pc): Likewise.
	(arm_get_next_pc): Likewise.
	(arm_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to arm_get_next_pc.  Use get_frame_pc instead of read_register.
	* arm-tdep.h (arm_software_single_step): Replace REGCACHE
	argument by FRAME.

	* cris-tdep.c (find_step_target): Add FRAME argument.  Read registers
	from FRAME instead of using read_register.
	(cris_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to find_step_target.

	* mips-tdep.c (mips32_next_pc): Add FRAME argument.  Read registers
	from FRAME instead of using read_register / read_signed_register.
	(extended_mips16_next_pc): Likewise.
	(mips16_next_pc): Likewise.
	(mips_next_pc): Likewise.
	(mips_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to mips_next_pc.  Use get_frame_pc instead of read_pc.
	* mips-tdep.h (mips_software_single_step): Replace REGCACHE
	argument by FRAME.

	* rs6000-tdep.c (branch_dest): Add FRAME argument.  Use it instead
	of current frame.  Read registers from FRAME.
	(deal_with_atomic_sequence): Add FRAME argument.  Pass it to
	branch_dest.  Use get_frame_pc instead of read_pc.
	(rs6000_software_single_step): Likewise.
	(bl_to_blrl_insn_p): Do not call branch_dest.
	* rs6000-tdep.h (rs6000_software_single_step): Replace REGCACHE
	argument by FRAME.

	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Add FRAME argument.
	Read registers from FRAME instead of current regcache.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Likewise.
	* sparcnbsd-tdep.c (sparcnbsd_step_trap): Likewise.
	* sparc-tdep.c (sparc_address_from_register): Remove.
	(sparc_analyze_control_transfer): Pass FRAME argument instead of
	GDBARCH.  Pass FRAME to step_trap callback.
	(sparc_step_trap): Add FRAME argument.
	(space_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to sparc_analyze_control_transfer.  Read registers from FRAME instead
	of calling sparc_address_from_register.
	* sparc-tdep.h (struct gdbarch_tdep): Add FRAME argument to
	step_trap callback.
	(sparc_address_from_register): Remove prototype.
	(sparc_software_single_step): Replace REGCACHE argument by FRAME.
	(sparcnbsd_step_trap): Add FRAME argument.

	* spu-tdep.c (spu_software_single_step): Replace REGCACHE argument
	by FRAME.  Read registers from FRAME instead of REGCACHE.
@
text
@d4606 1
a4606 1
mips_skip_trampoline_code (CORE_ADDR pc)
d4619 1
a4619 1
    return read_signed_register (MIPS_RA_REGNUM);
d4626 1
a4626 1
	return read_signed_register (2);
d4648 1
a4648 1
	      CORE_ADDR target_pc = read_signed_register (2);
d4679 1
a4679 1
	    return read_signed_register (18);
@


1.432
log
@	* arm-tdep.c (arm_print_float_info): Use register value from FRAME
	instead of calling read_register.

	* avr-tdep.c (avr_push_dummy_call): Write to REGCACHE instead of
	calling write_register.

	* hppa-tdep.c (hppa32_push_dummy_call): Write to REGCACHE instead of
	calling write_register.

	* ia64-tdep.c (find_func_descr): Add REGCACHE parameter.  Use it
	instead of calling read_register.
	(ia64_push_dummy_call): Update call to find_func_descr.  Use REGCACHE
	instead of calling read_register and write_register.

	* m32r-tdep.c (m32r_linux_supply_gregset): Use REGCACHE parameter
	instead of current_regcache.

	* mn10300-tdep.c (mn10300_push_dummy_call): Write to REGCACHE instead
	of calling write_register.
	* mn10300-linux-tdep.c (am33_supply_fpregset_method): Use REGCACHE
	parameter instead of current_regcache.

	* mips-tdep.c (mips2_fp_compat): Add FRAME parameter.  Use it
	instead of calling read_register.
	(mips_read_fp_register_double, mips_print_fp_register): Update calls.
	(mips_eabi_push_dummy_call): Use REGCACHE instead of write_register.
	(mips_n32n64_push_dummy_call): Likewise.
	(mips_o32_push_dummy_call): Likewise.
	(mips_o64_push_dummy_call): Likewise.

	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Use REGCACHE
	parameter instead of current_regcache.

	* xtensa-tdep.c (xtensa_register_write_masked): Add REGCACHE parameter.
	Use it instead of read_register and write_register.
	(xtensa_register_read_masked): Likewise.
	(xtensa_pseudo_register_read): Update call.
	(xtensa_pseudo_register_write): Likewise.
	(xtensa_frame_cache): Use register values unwound from NEXT_FRAME
	instead of calling read_register.
	(xtensa_push_dummy_call): Update comment.
@
text
@d1020 1
a1020 1
mips32_next_pc (CORE_ADDR pc)
d1051 2
a1052 2
	    read_signed_register (mips_regnum (current_gdbarch)->
				  fp_control_status);
d1076 1
a1076 1
	      pc = read_signed_register (rtype_rs (inst));
d1093 1
a1093 1
		if (read_signed_register (itype_rs (inst)) < 0)
d1102 1
a1102 1
		if (read_signed_register (itype_rs (inst)) >= 0)
d1132 2
a1133 2
	  if (read_signed_register (itype_rs (inst)) ==
	      read_signed_register (itype_rt (inst)))
d1140 2
a1141 2
	  if (read_signed_register (itype_rs (inst)) !=
	      read_signed_register (itype_rt (inst)))
d1147 1
a1147 1
	  if (read_signed_register (itype_rs (inst)) <= 0)
d1155 1
a1155 1
	  if (read_signed_register (itype_rs (inst)) > 0)
d1336 1
a1336 1
extended_mips16_next_pc (CORE_ADDR pc,
d1372 1
a1372 1
	reg = read_signed_register (upk.regx);
d1384 1
a1384 1
	reg = read_signed_register (upk.regx);
d1397 1
a1397 1
	reg = read_signed_register (24);	/* Test register is 24 */
d1431 1
a1431 1
	    pc = read_signed_register (reg);
d1443 1
a1443 1
	pc = extended_mips16_next_pc (pc, insn, fetch_mips_16 (pc));
d1456 1
a1456 1
mips16_next_pc (CORE_ADDR pc)
d1459 1
a1459 1
  return extended_mips16_next_pc (pc, 0, insn);
d1468 1
a1468 1
mips_next_pc (CORE_ADDR pc)
d1471 1
a1471 1
    return mips16_next_pc (pc);
d1473 1
a1473 1
    return mips32_next_pc (pc);
d2326 1
a2326 1
mips_software_single_step (struct regcache *regcache)
d2330 2
a2331 2
  pc = read_register (mips_regnum (current_gdbarch)->pc);
  next_pc = mips_next_pc (pc);
@


1.431
log
@	* mips-tdep.c (mips16_scan_prologue): Replace read_next_frame_reg
	by frame_unwind_register_signed calls.
	(mips32_scan_prologue): Likewise.  Skip analysis of alloca stack
	frame allocations when called with NULL NEXT_FRAME parameter.
	(read_next_frame_reg): Remove.

	* sh-tdep.c (sh_analyze_prologue): Add FPSCR parameter.  Use it
	instead of reading the FPSCR register.
	(sh_frame_cache): Pass unwound FPSCR register value to
	sh_analyze_prologue.
	(sh_skip_prologue): Pass dummy FPSCR value to sh_analyze_prologue.

	* v850-tdep.c (v850_analyze_prologue): Add CTBP parameter.  Use it
	instead of reading the CTBP register.
	(v850_frame_cache): Pass unwound CTBP register value to
	v850_analyze_prologue.
@
text
@d430 1
a430 1
mips2_fp_compat (void)
d444 1
a444 1
  if ((read_register (MIPS_PS_REGNUM) & ST0_FR) == 0)
d2568 1
a2568 1
      write_register (argreg++, struct_addr);
d2645 1
a2645 1
	      write_register (float_argreg++, regval);
d2652 1
a2652 1
	      write_register (float_argreg++, regval);
d2664 1
a2664 1
	      write_register (float_argreg++, regval);
d2753 1
a2753 1
		  write_register (argreg, regval);
d2849 1
a2849 1
      write_register (argreg++, struct_addr);
d2881 1
a2881 1
	  write_register (float_argreg++, regval);
d2886 1
a2886 1
	  write_register (argreg, regval);
d2986 1
a2986 1
		  write_register (argreg, regval);
d3207 1
a3207 1
      write_register (argreg++, struct_addr);
d3264 1
a3264 1
	      write_register (float_argreg++, regval);
d3268 1
a3268 1
	      write_register (argreg++, regval);
d3275 1
a3275 1
	      write_register (float_argreg++, regval);
d3280 1
a3280 1
	      write_register (argreg++, regval);
d3292 1
a3292 1
	      write_register (float_argreg++, regval);
d3300 1
a3300 1
	      write_register (argreg, regval);
d3418 1
a3418 1
		  write_register (argreg, regval);
d3666 1
a3666 1
      write_register (argreg++, struct_addr);
d3705 1
a3705 1
	  write_register (float_argreg++, regval);
d3709 1
a3709 1
	  write_register (argreg, regval);
d3807 1
a3807 1
		  write_register (argreg, regval);
d3973 1
a3973 1
  if (raw_size == 8 && !mips2_fp_compat ())
d4021 1
a4021 1
  if (register_size (current_gdbarch, regnum) == 4 || mips2_fp_compat ())
@


1.430
log
@	* mips-tdep.c (deprecated_mips_set_processor_regs_hack): Read from
	current regcache instead of calling read_register.
@
text
@a454 2
static CORE_ADDR read_next_frame_reg (struct frame_info *, int);

d1572 3
a1574 2
    sp = read_next_frame_reg (next_frame, gdbarch_num_regs (current_gdbarch)
					   + MIPS_SP_REGNUM);
d1894 3
a1896 2
    sp = read_next_frame_reg (next_frame, gdbarch_num_regs (current_gdbarch)
					  + MIPS_SP_REGNUM);
d1946 1
a1946 1
	  else if (frame_reg == MIPS_SP_REGNUM)
d1951 4
a1954 3
	      frame_addr = read_next_frame_reg (next_frame,
						gdbarch_num_regs
						  (current_gdbarch) + 30);
d1977 1
a1977 1
	  if (frame_reg == MIPS_SP_REGNUM)
d1982 4
a1985 3
	      frame_addr = read_next_frame_reg (next_frame,
						gdbarch_num_regs 
						  (current_gdbarch) + 30);
a2292 16
static CORE_ADDR
read_next_frame_reg (struct frame_info *fi, int regno)
{
  /* Always a pseudo.  */
  gdb_assert (regno >= gdbarch_num_regs (current_gdbarch));
  if (fi == NULL)
    {
      LONGEST val;
      regcache_cooked_read_signed (current_regcache, regno, &val);
      return val;
    }
  else
    return frame_unwind_register_signed (fi, regno);

}

@


1.429
log
@	* config/mips/linux.mh (TDEP_XML): New.
	* features/mips-linux.xml, features/mips64-linux.xml: New files.
	* mips-linux-nat.c (mips_linux_register_addr): Handle
	MIPS_RESTART_REGNUM.
	(mips64_linux_register_addr): Likewise.
	(super_xfer_partial, mips_linux_xfer_partial): New.
	(_initialize_mips_linux_nat): Add them to the target_ops.
	* mips-linux-tdep.c (mips_supply_gregset): Handle MIPS_RESTART_REGNUM.
	(mips_fill_gregset, mips64_supply_gregset, mips64_fill_gregset)
	(mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	(mips_linux_write_pc, mips_linux_restart_reg_p): New.
	(mips_linux_init_abi): Use mips_linux_write_pc.  Check for the
	"org.gnu.gdb.mips.linux" feature.
	* mips-linux-tdep.h (MIPS_RESTART_REGNUM): New constant.
	(mips_linux_restart_reg_p): New prototype.
	* mips-tdep.c (mips_gdbarch_init): Pass tdesc_data to the OS/ABI
	initialization routine.
	* Makefile.in (mips-linux-tdep.o, mips-linux-nat.o): Update.

	* gdb.texinfo (MIPS Features): Document org.gnu.gdb.mips.linux.
@
text
@d4475 1
a4475 3
  CORE_ADDR prid;

  prid = read_register (MIPS_PRID_REGNUM);
d4477 2
@


1.428
log
@	* Makefile.in (mips-tdep.o): Update.
	* mips-tdep.c (struct register_alias, mips_o32_aliases)
	(mips_n32_n64_aliases, mips_register_aliases): New.
	(mips_register_name): Call tdesc_register_name.
	(mips_tdesc_register_reggroup_p): New.
	(mips_pseudo_register_type, value_of_mips_user_reg): New.
	(mips_gdbarch_init): Add target-described register support.
	Register aliases for register names.
	* target-descriptions.c (tdesc_register_name): Make global.
	(tdesc_register_in_reggroup_p): New function, broken out from
	tdesc_register_reggroup_p.
	(tdesc_register_reggroup_p): Use it.
	* target-descriptions.h (tdesc_register_name)
	(tdesc_register_in_reggroup_p): New prototypes.
	* NEWS: Correct formatting.  Mention MIPS register support.
	* features/mips-cp0.xml, features/mips-fpu.xml,
	features/mips64-cp0.xml, gdb/features/mips64-fpu.xml, mips-cpu.xml,
	features/mips64-cpu.xml: New files.

	* gdb.xml/tdesc-regs.exp: Add MIPS support.  Allow multiple
	required features to be included.

	* gdb.texinfo (MIPS Features): New subsection.
@
text
@d5460 1
@


1.427
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (BREAKPOINT_FROM_PC): Replace by
	gdbarch_breakpoint_from_pc.
	* s390-tdep.c (s390_gdbarch_init): Likewise (comment).
	* remote.c (remote_insert_breakpoint)
	(remote_insert_hw_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* mips-tdep.c (mips_breakpoint_from_pc): Likewise (comment).
	* breakpoint.h (bp_target_info): Likewise (comment).
	* breakpoint.c (read_memory_nobpt): Likewise.
	* mem-break.c (default_memory_insert_breakpoint): Likewise.
	(symtab.h, breakpoint.h): Remove include. Remove unnecessary comment.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d61 1
d98 49
d562 2
d612 29
d805 53
d4861 7
d4875 1
a4875 1
  int num_regs;
d4877 100
d5120 5
a5124 1
    return NULL;
d5145 3
d5195 14
a5208 1
    if (info.osabi == GDB_OSABI_IRIX)
d5472 31
@


1.426
log
@	* mips-tdep.c (mips_print_register): Remove unused ALL argument.
	(print_gp_register_row): Stop before printing a register bigger
	than the ABI register size.
	(mips_print_registers_info): Update call to mips_print_register.
@
text
@d4400 6
a4405 6
/* This function implements the BREAKPOINT_FROM_PC macro.  It uses the program
   counter value to determine whether a 16- or 32-bit breakpoint should be
   used.  It returns a pointer to a string of bytes that encode a breakpoint
   instruction, stores the length of the string to *lenptr, and adjusts pc
   (if necessary) to point to the actual memory location where the
   breakpoint should be inserted.  */
@


1.425
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (ADDR_BITS_REMOVE): Replace by gdbarch_addr_bits_remove.
	* value.c (value_as_address): Likewise (comment).
	* remote-mips.c (common_breakpoint): Likewise.
	* regcache.c (read_pc_pid): Likewise.
	* printcmd.c (do_one_display): Likewise.
	* monitor.c (monitor_write_memory, monitor_read_memory)
	(monitor_insert_breakpoint): Likewise.
	* mips-tdep.c (heuristic_proc_start): Likewise.
	* infrun.c (insert_step_resume_breakpoint_at_frame)
	(insert_step_resume_breakpoint_at_caller): Likewise.
	* buildsym.c (record_line): Likewise.
	* arm-tdep.c (arm_scan_prologue, thumb_get_next_pc)
	(arm_get_next_pc): Likewise.
	* armnbsd-nat.c (arm_supply_gregset, fetch_register, store_register)
	(store_regs): Likewise.
	* arm-linux-tdep.c (arm_linux_supply_gregset): Likewise.
	* arm-linux-nat.c (fetch_register, fetch_regs): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d3959 1
a3959 1
		     int regnum, int all)
d4040 12
d4081 4
d4126 1
a4126 1
      mips_print_register (file, frame, regnum, 0);
@


1.424
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_NAME): Replace by gdbarch_register_name.
	* tracepoint.c (scope_info): Likewise.
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_register_reggroup_p): Likewise.
	* sh64-tdep.c (sh64_do_fp_register, sh64_do_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_reggroup_p): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* remote.c (packet_reg): Likewise (comment).
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* printcmd.c (address_info): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* mt-dep.c (mt_registers_info): Likewise.
	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Likewise (comment).
	* mips-tdep.c (mips_register_reggroup_p, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row, mips_print_registers_info)
	(mips_register_sim_regno): Likewise.
	* m68klinux-nat.c (regmap, fetch_register, store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register)
	(inf_ptrace_store_register): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_store_register): Likewise.
	* i386-linux-nat.c (fetch_register, store_register): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register)
	(hppa_hpux_store_register): Likewise.
	* findvar.c (locate_var_value): Likewise.
	* dwarf2loc.c (locexpr_describe_location): Likewise.
	* dwarf2-frame.c (execute_cfa_program): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* arch-utils.c (legacy_register_sim_regno): Likewise.
	* alpha-tdep.c (alpha_register_reggroup_p): Likewise.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers, mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d2248 1
a2248 1
  pc = ADDR_BITS_REMOVE (pc);
@


1.423
log
@2007-06-06  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (COFF_MAKE_MSYMBOL_SPECIAL): Replace by
	gdbarch_coff_make_msymbol_special.
	* coffread.c (coff_symtab_read): Likewise.
	* gdbarch.sh (ELF_MAKE_MSYMBOL_SPECIAL): Replace by
	gdbarch_elf_make_msymbol_special.
	* elfread.c (elf_symtab_read): Likewise.
	* mips-tdep.c (mips_elf_make_msymbol_special): Likewise (comment).
	* sh64-tdep.c (MSYMBOL_IS_SPECIAL): Likewise (comment).
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d540 2
a541 1
  if (REGISTER_NAME (regnum) == NULL || REGISTER_NAME (regnum)[0] == '\0')
d3822 2
a3823 1
    error (_("can't read register %d (%s)"), regno, REGISTER_NAME (regno));
d3858 2
a3859 1
	error (_("can't read register %d (%s)"), regno, REGISTER_NAME (regno));
d3894 5
a3898 2
  fprintf_filtered (file, "%s:", REGISTER_NAME (regnum));
  fprintf_filtered (file, "%*s", 4 - (int) strlen (REGISTER_NAME (regnum)),
d3974 2
a3975 1
      fprintf_filtered (file, "%s: [Invalid]", REGISTER_NAME (regnum));
d3979 1
a3979 1
  fputs_filtered (REGISTER_NAME (regnum), file);
d4035 1
a4035 1
      if (*REGISTER_NAME (regnum) == '\0')
d4044 1
a4044 1
			REGISTER_NAME (regnum));
d4064 1
a4064 1
      if (*REGISTER_NAME (regnum) == '\0')
d4071 2
a4072 1
	error (_("can't read register %d (%s)"), regnum, REGISTER_NAME (regnum));
d4107 1
a4107 1
      if (*(REGISTER_NAME (regnum)) == '\0')
d4604 6
a4609 2
  if (REGISTER_NAME (gdbarch_num_regs (current_gdbarch) + regnum) != NULL
      && REGISTER_NAME (gdbarch_num_regs (current_gdbarch) + regnum)[0] != '\0')
@


1.422
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* xtensa-tdep.c (XTENSA_IS_ENTRY, extract_call_winsize)
	(xtensa_register_write_masked, xtensa_register_read_masked)
	(xtensa_extract_return_value, xtensa_store_return_value
	(xtensa_push_dummy_call, xtensa_breakpoint_from_pc): Replace
	TARGET_BYTE_ORDER by gdbarch_byte_order.
	* sh-tdep.c (sh_breakpoint_from_pc, gdb_print_insn_sh)
	(sh_justify_value_in_reg, sh_next_flt_argreg, sh_push_dummy_call_fpu)
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_breakpoint_from_pc, gdb_print_insn_sh64)
	(sh64_push_dummy_call, sh64_extract_return_value)
	(sh64_store_return_value, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_pseudo_register_read)
	(sh64_pseudo_register_write, sh64_do_fp_register)
	(sh64_frame_prev_register): Likewise.
	* score-tdep.c (score_print_insn, score_breakpoint_from_pc)
	(score_return_value, score_push_dummy_call, score_fetch_inst): Likewise.
	* rs6000-tdep.c (rs6000_breakpoint_from_pc, rs6000_push_dummy_call)
	(e500_move_ev_register,gdb_print_insn_powerpc): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* ppc-linux-nat.c (store_register): Likewise.
	* nto-tdep.c (nto_find_and_open_solib)
	(nto_init_solib_absolute_prefix): Likewise.
	* mips-tdep.c (mips_pseudo_register_read, mips_pseudo_register_write)
	(mips_convert_register_p, mips_eabi_push_dummy_call)
	(mips_n32n64_push_dummy_call, mips_n32n64_return_value)
	(mips_o32_push_dummy_call, mips_o32_return_value)
	(mips_o64_push_dummy_call, mips_o64_return_value, mips_o64_return_value)
	(mips_read_fp_register_single, mips_read_fp_register_double)
	(mips_print_register, print_gp_register_row, gdb_print_insn_mips)
	(mips_breakpoint_from_pc): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Likewise.
	* mips-linux-tdep.c (mips64_supply_fpregset, mips64_fill_fpregset)
	(mips_linux_o32_sigframe_init): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint, m32r_breakpoint_from_pc): Likewise.
	* libunwind-frame.c (libunwind_frame_cache, libunwind_frame_sniffer)
	(libunwind_sigtramp_frame_sniffer, libunwind_get_reg_special): Likewise.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* arm-tdep.c (convert_from_extended, convert_to_extended)
	(gdb_print_insn_arm): Likewise.
@
text
@d296 1
a296 1
   ELF_MAKE_MSYMBOL_SPECIAL tests whether an ELF symbol is "special",
@


1.421
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d576 1
a576 1
	  || TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
d599 1
a599 1
	  || TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
d644 1
a644 1
  return (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
d2515 2
a2516 1
	      int low_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 4 : 0;
d2580 1
a2580 1
		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d2801 1
a2801 1
		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d2854 1
a2854 1
		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
d2915 2
a2916 1
			  8, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
d2920 2
a2921 1
			  8, TARGET_BYTE_ORDER, readbuf ? readbuf + 8 : readbuf,
d2936 2
a2937 1
			  TARGET_BYTE_ORDER, readbuf, writebuf, 0);
d2969 2
a2970 1
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
d3016 2
a3017 1
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
d3134 2
a3135 1
	      int low_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 4 : 0;
d3286 1
a3286 1
		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
d3351 2
a3352 1
			  TARGET_BYTE_ORDER, readbuf, writebuf, 0);
d3363 1
a3363 1
      switch (TARGET_BYTE_ORDER)
d3369 2
a3370 1
			      0, 4, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
d3374 2
a3375 1
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 4);
d3381 2
a3382 1
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
d3386 2
a3387 1
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 4);
d3425 2
a3426 1
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
d3476 2
a3477 1
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
d3623 1
a3623 1
		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d3675 1
a3675 1
		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
d3739 2
a3740 1
			  TARGET_BYTE_ORDER, readbuf, writebuf, 0);
d3761 2
a3762 1
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
d3828 1
a3828 1
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d3867 1
a3867 1
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d3983 1
a3983 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d4071 1
a4071 1
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d4370 1
a4370 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d4386 1
a4386 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
@


1.420
log
@* mips-tdep.c (mips_n32n64_push_dummy_call): Fix and reformat a
comment.
(mips_o64_push_dummy_call): Reformat a comment.
@
text
@d330 1
a330 1
  gdb_assert (reg_num >= NUM_REGS);
d496 4
a499 4
  /* Map [NUM_REGS .. 2*NUM_REGS) onto the raw registers, but then
     don't make the raw register names visible.  */
  int rawnum = regno % NUM_REGS;
  if (regno < NUM_REGS)
d512 1
a512 1
  else if (32 <= rawnum && rawnum < NUM_REGS)
d531 2
a532 2
  int rawnum = regnum % NUM_REGS;
  int pseudo = regnum / NUM_REGS;
d539 1
a539 1
  raw_p = rawnum < NUM_REGS;
d560 1
a560 1
   NUM_REGS .. 2 * NUM_REGS) back onto the corresponding raw
d567 3
a569 2
  int rawnum = cookednum % NUM_REGS;
  gdb_assert (cookednum >= NUM_REGS && cookednum < 2 * NUM_REGS);
d590 3
a592 2
  int rawnum = cookednum % NUM_REGS;
  gdb_assert (cookednum >= NUM_REGS && cookednum < 2 * NUM_REGS);
d646 4
a649 2
	  && (regnum % NUM_REGS) >= mips_regnum (current_gdbarch)->fp0
	  && (regnum % NUM_REGS) < mips_regnum (current_gdbarch)->fp0 + 32
d675 5
a679 3
  gdb_assert (regnum >= 0 && regnum < 2 * NUM_REGS);
  if ((regnum % NUM_REGS) >= mips_regnum (current_gdbarch)->fp0
      && (regnum % NUM_REGS) < mips_regnum (current_gdbarch)->fp0 + 32)
d688 1
a688 1
  else if (regnum < NUM_REGS)
d701 1
a701 1
      if (regnum >= (NUM_REGS
d703 2
a704 1
	  && regnum <= NUM_REGS + MIPS_LAST_EMBED_REGNUM)
d805 2
a806 1
				       NUM_REGS + mips_regnum (gdbarch)->pc);
d812 3
a814 1
  return frame_unwind_register_signed (next_frame, NUM_REGS + MIPS_SP_REGNUM);
d825 5
a829 2
  return frame_id_build (frame_unwind_register_signed (next_frame, NUM_REGS + MIPS_SP_REGNUM),
			 frame_pc_unwind (next_frame));
d1354 5
a1358 5
   For simplicity, save the address in both [0 .. NUM_REGS) and
   [NUM_REGS .. 2*NUM_REGS).  Strictly speaking, only the second range
   is used as it is only second range (the ABI instead of ISA
   registers) that comes into play when finding saved registers in a
   frame.  */
d1367 6
a1372 2
      this_cache->saved_regs[regnum + 0 * NUM_REGS].addr = offset;
      this_cache->saved_regs[regnum + 1 * NUM_REGS].addr = offset;
d1439 2
a1440 1
    sp = read_next_frame_reg (next_frame, NUM_REGS + MIPS_SP_REGNUM);
d1592 3
a1594 1
        (frame_unwind_register_signed (next_frame, NUM_REGS + frame_reg)
d1599 4
a1602 2
      this_cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->pc]
        = this_cache->saved_regs[NUM_REGS + MIPS_RA_REGNUM];
d1647 2
a1648 1
  trad_frame_set_value (cache->saved_regs, NUM_REGS + MIPS_SP_REGNUM, cache->base);
d1728 1
a1728 1
    const int num_regs = NUM_REGS;
d1760 2
a1761 1
    sp = read_next_frame_reg (next_frame, NUM_REGS + MIPS_SP_REGNUM);
d1816 3
a1818 1
	      frame_addr = read_next_frame_reg (next_frame, NUM_REGS + 30);
d1846 3
a1848 1
	      frame_addr = read_next_frame_reg (next_frame, NUM_REGS + 30);
d1913 3
a1915 1
        (frame_unwind_register_signed (next_frame, NUM_REGS + frame_reg)
d1920 4
a1923 2
      this_cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->pc]
        = this_cache->saved_regs[NUM_REGS + MIPS_RA_REGNUM];
d1979 3
a1981 1
  trad_frame_set_value (cache->saved_regs, NUM_REGS + MIPS_SP_REGNUM, cache->base);
d2160 1
a2160 1
  gdb_assert (regno >= NUM_REGS);
d2912 2
a2913 1
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
d2916 2
a2917 1
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 2,
d2930 2
a2931 1
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
d2962 2
a2963 1
	  mips_xfer_register (regcache, NUM_REGS + regnum,
d2987 2
a2988 1
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
d3009 2
a3010 1
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
d3341 2
a3342 1
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
d3359 2
a3360 1
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 +
d3363 3
a3365 2
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 +
			      1, 4, TARGET_BYTE_ORDER, readbuf, writebuf, 4);
d3369 3
a3371 2
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 +
			      1, 4, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
d3373 3
a3375 2
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 +
			      0, 4, TARGET_BYTE_ORDER, readbuf, writebuf, 4);
d3410 2
a3411 1
	  mips_xfer_register (regcache, NUM_REGS + regnum,
d3437 2
a3438 1
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
d3461 2
a3462 1
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
d3722 2
a3723 1
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
d3744 2
a3745 1
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
d4008 3
a4010 1
       col < ncols && regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
d4029 3
a4031 2
  if ((start_regnum % NUM_REGS) < MIPS_NUMREGS)
    fprintf_filtered (file, "\n R%-4d", start_regnum % NUM_REGS);
d4037 3
a4039 1
       col < ncols && regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
d4082 1
a4082 1
      gdb_assert (regnum >= NUM_REGS);
d4092 3
a4094 2
      regnum = NUM_REGS;
      while (regnum < NUM_REGS + NUM_PSEUDO_REGS)
d4526 1
a4526 1
   [1 * NUM_REGS .. 2 * NUM_REGS) REGNUM.  */
d4543 3
a4545 2
    return NUM_REGS + NUM_PSEUDO_REGS;
  return NUM_REGS + regnum;
d4550 1
a4550 1
   NUM_REGS .. 2 * NUM_REGS) REGNUM.  */
d4567 3
a4569 2
    return NUM_REGS + NUM_PSEUDO_REGS;
  return NUM_REGS + regnum;
d4576 1
a4576 1
  gdb_assert (regnum >= 0 && regnum < NUM_REGS);
d4580 2
a4581 2
  if (REGISTER_NAME (NUM_REGS + regnum) != NULL
      && REGISTER_NAME (NUM_REGS + regnum)[0] != '\0')
@


1.419
log
@	* NEWS: Mention removed "set mips stack-arg-size" and "set mips
	saved-gpreg-size".

	* mips-tdep.c (MIPS32_REGSIZE, MIPS64_REGSIZE): New constants.
	(size_auto, size_32, size_64, size_enums, mips_abi_regsize_string)
	(mips_stack_argsize_string, mips_stack_argsize): Delete.
	(mips_abi_regsize): Simplify.
	(mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_n32n64_return_value, mips_o32_push_dummy_call)
	(mips_o32_return_value, mips_o64_push_dummy_call)
	(mips_o64_return_value): Propogate constant register sizes.  Use the
	ABI register size instead of mips_stack_argsize.
	(mips_dump_tdep): Don't print mips_stack_argsize.
	(_initialize_mips_tdep): Remove saved-gpreg-size and stack-arg-size
	settings.

	* gdb.texinfo (MIPS): Remove documentation for set mips saved-gpreg-size,
	show mips saved-gpreg-size, and set mips stack-arg-size.
@
text
@d2739 3
a2741 4
	     mips_abi_regsize() are treated specially: Irix cc passes
	     them in registers where gcc sometimes puts them on the
	     stack.  For maximum compatibility, we will put them in
	     both places.  */
d3537 3
a3539 4
	     are treated specially: Irix cc passes
	     them in registers where gcc sometimes puts them on the
	     stack.  For maximum compatibility, we will put them in
	     both places.  */
@


1.418
log
@	* Makefile.in (mips-tdep.o): Update.
	* mips-tdep.c (mips_gdbarch_init): Register the dwarf2 CFI
	unwinder.
@
text
@d78 5
a96 15
/* Various MIPS ISA options (related to stack analysis) can be
   overridden dynamically.  Establish an enum/array for managing
   them. */

static const char size_auto[] = "auto";
static const char size_32[] = "32";
static const char size_64[] = "64";

static const char *size_enums[] = {
  size_auto,
  size_32,
  size_64,
  0
};

a271 2
static const char *mips_abi_regsize_string = size_auto;

d275 15
a289 20
  if (mips_abi_regsize_string == size_auto)
    switch (mips_abi (gdbarch))
      {
      case MIPS_ABI_EABI32:
      case MIPS_ABI_O32:
	return 4;
      case MIPS_ABI_N32:
      case MIPS_ABI_N64:
      case MIPS_ABI_O64:
      case MIPS_ABI_EABI64:
	return 8;
      case MIPS_ABI_UNKNOWN:
      case MIPS_ABI_LAST:
      default:
	internal_error (__FILE__, __LINE__, _("bad switch"));
      }
  else if (mips_abi_regsize_string == size_64)
    return 8;
  else				/* if (mips_abi_regsize_string == size_32) */
    return 4;
a400 17
/* The amount of space reserved on the stack for registers. This is
   different to MIPS_ABI_REGSIZE as it determines the alignment of
   data allocated after the registers have run out. */

static const char *mips_stack_argsize_string = size_auto;

static unsigned int
mips_stack_argsize (struct gdbarch *gdbarch)
{
  if (mips_stack_argsize_string == size_auto)
    return mips_abi_regsize (gdbarch);
  else if (mips_stack_argsize_string == size_64)
    return 8;
  else				/* if (mips_stack_argsize_string == size_32) */
    return 4;
}

d2371 1
d2394 1
a2394 2
    len += align_up (TYPE_LENGTH (value_type (args[argnum])),
		     mips_stack_argsize (gdbarch));
d2435 1
a2435 1
      if (len > mips_abi_regsize (gdbarch)
d2438 1
a2438 2
	  store_unsigned_integer (valbuf, mips_abi_regsize (gdbarch),
				  VALUE_ADDRESS (arg));
d2440 1
a2440 1
	  len = mips_abi_regsize (gdbarch);
d2453 1
a2453 2
      if (mips_abi_regsize (gdbarch) < 8
	  && fp_register_arg_p (typecode, arg_type))
d2516 2
a2517 2
	  /* Note: structs whose size is not a multiple of
	     mips_abi_regsize() are treated specially: Irix cc passes
d2521 1
a2521 2
	  int odd_sized_struct = ((len > mips_abi_regsize (gdbarch))
				  && (len % mips_abi_regsize (gdbarch) != 0));
d2529 1
a2529 2
	      int partial_len = (len < mips_abi_regsize (gdbarch)
				 ? len : mips_abi_regsize (gdbarch));
d2547 1
a2547 1
		      if (mips_stack_argsize (gdbarch) == 8
d2551 1
a2551 1
			longword_offset = mips_stack_argsize (gdbarch) - len;
d2554 2
a2555 3
			       && (TYPE_LENGTH (arg_type)
				   < mips_stack_argsize (gdbarch)))
			longword_offset = mips_stack_argsize (gdbarch) - len;
d2596 1
a2596 2
				      phex (regval,
					    mips_abi_regsize (gdbarch)));
d2611 1
a2611 2
		stack_offset += align_up (partial_len,
					  mips_stack_argsize (gdbarch));
d2674 1
a2674 2
    len += align_up (TYPE_LENGTH (value_type (args[argnum])),
		     mips_stack_argsize (gdbarch));
d2738 1
a2738 1
	  /* Note: structs whose size is not a multiple of
d2743 2
a2744 2
	  int odd_sized_struct = ((len > mips_abi_regsize (gdbarch))
				  && (len % mips_abi_regsize (gdbarch) != 0));
d2751 1
a2751 2
	      int partial_len = (len < mips_abi_regsize (gdbarch)
				 ? len : mips_abi_regsize (gdbarch));
d2769 5
a2773 5
		      if (mips_stack_argsize (gdbarch) == 8
			  && (typecode == TYPE_CODE_INT
			      || typecode == TYPE_CODE_PTR
			      || typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = mips_stack_argsize (gdbarch) - len;
d2818 1
a2818 15
		     same for integral types.

		     cagney/2001-07-23: gdb/179: Also, GCC, when
		     outputting LE O32 with sizeof (struct) <
		     mips_abi_regsize(), generates a left shift
		     as part of storing the argument in a register
		     (the left shift isn't generated when
		     sizeof (struct) >= mips_abi_regsize()).  Since
		     it is quite possible that this is GCC
		     contradicting the LE/O32 ABI, GDB has not been
		     adjusted to accommodate this.  Either someone
		     needs to demonstrate that the LE/O32 ABI
		     specifies such a left shift OR this new ABI gets
		     identified as such and GDB gets tweaked
		     accordingly.  */
d2821 1
a2821 1
		      && partial_len < mips_abi_regsize (gdbarch)
d2824 1
a2824 1
		    regval <<= ((mips_abi_regsize (gdbarch) - partial_len)
d2830 1
a2830 2
				      phex (regval,
					    mips_abi_regsize (gdbarch)));
d2845 1
a2845 2
		stack_offset += align_up (partial_len,
					  mips_stack_argsize (gdbarch));
d2867 1
a2867 1
      || TYPE_LENGTH (type) > 2 * mips_abi_regsize (gdbarch))
d3019 1
a3019 1
	len = align_up (len, mips_stack_argsize (gdbarch) * 2);
d3021 1
a3021 1
      len += align_up (arglen, mips_stack_argsize (gdbarch));
d3042 1
a3042 1
      stack_offset += mips_stack_argsize (gdbarch);
d3137 1
a3137 1
	  stack_offset += align_up (len, mips_stack_argsize (gdbarch));
d3144 2
a3145 2
	  /* Note: structs whose size is not a multiple of
	     mips_abi_regsize() are treated specially: Irix cc passes
d3149 2
a3150 2
	  int odd_sized_struct = ((len > mips_abi_regsize (gdbarch))
				  && (len % mips_abi_regsize (gdbarch) != 0));
d3158 1
a3158 1
		  stack_offset += mips_abi_regsize (gdbarch);
d3165 1
a3165 2
	      int partial_len = (len < mips_abi_regsize (gdbarch)
				 ? len : mips_abi_regsize (gdbarch));
a3179 8
		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		    {
		      if (mips_stack_argsize (gdbarch) == 8
			  && (typecode == TYPE_CODE_INT
			      || typecode == TYPE_CODE_PTR
			      || typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = mips_stack_argsize (gdbarch) - len;
		    }
d3241 1
a3241 1
		      && partial_len < mips_abi_regsize (gdbarch)
d3244 1
a3244 1
		    regval <<= ((mips_abi_regsize (gdbarch) - partial_len)
d3250 1
a3250 2
				      phex (regval,
					    mips_abi_regsize (gdbarch)));
d3270 1
a3270 2
	      stack_offset += align_up (partial_len,
					mips_stack_argsize (gdbarch));
d3402 1
a3402 1
         the ISA.  mips_stack_argsize controls this.  */
d3407 1
a3407 1
	   offset += mips_stack_argsize (gdbarch), regnum++)
d3409 1
a3409 1
	  int xfer = mips_stack_argsize (gdbarch);
d3464 1
a3464 1
      len += align_up (arglen, mips_stack_argsize (gdbarch));
d3485 1
a3485 1
      stack_offset += mips_stack_argsize (gdbarch);
d3530 1
a3530 1
	  stack_offset += align_up (len, mips_stack_argsize (gdbarch));
d3537 2
a3538 2
	  /* Note: structs whose size is not a multiple of
	     mips_abi_regsize() are treated specially: Irix cc passes
d3542 2
a3543 2
	  int odd_sized_struct = ((len > mips_abi_regsize (gdbarch))
				  && (len % mips_abi_regsize (gdbarch) != 0));
d3548 1
a3548 2
	      int partial_len = (len < mips_abi_regsize (gdbarch)
				 ? len : mips_abi_regsize (gdbarch));
d3565 5
a3569 5
		      if (mips_stack_argsize (gdbarch) == 8
			  && (typecode == TYPE_CODE_INT
			      || typecode == TYPE_CODE_PTR
			      || typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = mips_stack_argsize (gdbarch) - len;
d3616 1
a3616 1
		      && partial_len < mips_abi_regsize (gdbarch)
d3619 1
a3619 1
		    regval <<= ((mips_abi_regsize (gdbarch) - partial_len)
d3625 1
a3625 2
				      phex (regval,
					    mips_abi_regsize (gdbarch)));
d3645 1
a3645 2
	      stack_offset += align_up (partial_len,
					mips_stack_argsize (gdbarch));
d3689 1
a3689 1
	   offset += mips_stack_argsize (gdbarch), regnum++)
d3691 1
a3691 1
	  int xfer = mips_stack_argsize (gdbarch);
a5225 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: mips_stack_argsize() = %d\n",
		      mips_stack_argsize (current_gdbarch));
a5253 29
  /* Allow the user to override the saved register size. */
  add_setshow_enum_cmd ("saved-gpreg-size", class_obscure,
			size_enums, &mips_abi_regsize_string, _("\
Set size of general purpose registers saved on the stack."), _("\
Show size of general purpose registers saved on the stack."), _("\
This option can be set to one of:\n\
  32    - Force GDB to treat saved GP registers as 32-bit\n\
  64    - Force GDB to treat saved GP registers as 64-bit\n\
  auto  - Allow GDB to use the target's default setting or autodetect the\n\
          saved GP register size from information contained in the\n\
          executable (default)."),
			NULL,
			NULL, /* FIXME: i18n: Size of general purpose registers saved on the stack is %s.  */
			&setmipscmdlist, &showmipscmdlist);

  /* Allow the user to override the argument stack size. */
  add_setshow_enum_cmd ("stack-arg-size", class_obscure,
			size_enums, &mips_stack_argsize_string, _("\
Set the amount of stack space reserved for each argument."), _("\
Show the amount of stack space reserved for each argument."), _("\
This option can be set to one of:\n\
  32    - Force GDB to allocate 32-bit chunks per argument\n\
  64    - Force GDB to allocate 64-bit chunks per argument\n\
  auto  - Allow GDB to determine the correct setting from the current\n\
          target and executable (default)"),
			NULL,
			NULL, /* FIXME: i18n: The amount of stack space reserved for each argument is %s.  */
			&setmipscmdlist, &showmipscmdlist);

@


1.417
log
@	* gdbarch.sh (read_sp): Remove.
	* gdbarch.c, gdbarch.h: Regenerate.
	* frame.c (frame_sp_unwind): Do not call TARGET_READ_SP.

	* avr-tdep.c (avr_read_sp): Remove.
	(avr_unwind_sp): New function.
	(avr_gdbarch_init): Install unwind_sp instead of read_sp callback.
	* mips-tdep.c (mips_read_sp): Remove.
	(mips_unwind_sp): New function.
	(mips_gdbarch_init): Install unwind_sp instead of read_sp callback.
	* score-tdep.c (score_read_unsigned_register): Remove.
	(score_read_sp): Remove.
	(score_unwind_sp): New function.
	(score_gdbarch_init): Install unwind_sp instead of read_sp callback.
@
text
@d60 1
d5175 1
d5179 1
@


1.416
log
@	* mips-tdep.c (mips_eabi_push_dummy_call): When pushing floating
	point arguments, test explicitly for use of the EABI32 ABI
	instead of inferring this condition from tests on register
	sizes.
@
text
@a748 7
/* TARGET_READ_SP -- Remove useless bits from the stack pointer.  */

static CORE_ADDR
mips_read_sp (void)
{
  return read_signed_register (MIPS_SP_REGNUM);
}
d834 6
a5105 1
  set_gdbarch_read_sp (gdbarch, mips_read_sp);
d5113 1
@


1.415
log
@* mips-tdep.c (mips_o32_push_dummy_call): Remove conditions
based on mips_abi_regsize() whose result is known in advance.
(mips_o64_push_dummy_call): Likewise.
@
text
@d2510 6
a2515 1
	  if (register_size (gdbarch, float_argreg) < 8 && len == 8)
@


1.414
log
@* mips-tdep.c (mips_eabi_push_dummy_call): Revert the last
change to rearrange some brackets.
(mips_n32n64_push_dummy_call): Likewise.
(mips_o32_push_dummy_call): Likewise.
(mips_o64_push_dummy_call): Likewise.
@
text
@d3072 1
a3072 2
      if (mips_abi_regsize (gdbarch) < 8
	  && mips_type_needs_double_align (arg_type))
d3122 1
a3122 2
      if (mips_abi_regsize (gdbarch) < 8
	  && fp_register_arg_p (typecode, arg_type))
d3188 1
a3188 1
	      argreg += (mips_abi_regsize (gdbarch) == 8) ? 1 : 2;
d3207 1
a3207 2
	  if (mips_abi_regsize (gdbarch) < 8
	      && mips_type_needs_double_align (arg_type))
d3303 1
a3303 2
		  if (mips_abi_regsize (gdbarch) < 8
		      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
a3527 4
      /* Align to double-word if necessary.  */
      if (mips_abi_regsize (gdbarch) < 8
	  && mips_type_needs_double_align (arg_type))
	len = align_up (len, mips_stack_argsize (gdbarch) * 2);
a3570 12
      /* 32-bit ABIs always start floating point arguments in an
         even-numbered floating point register.  Round the FP register
         up before the check to see if there are any FP registers
         left.  O32/O64 targets also pass the FP in the integer
         registers so also round up normal registers.  */
      if (mips_abi_regsize (gdbarch) < 8
	  && fp_register_arg_p (typecode, arg_type))
	{
	  if ((float_argreg & 1))
	    float_argreg++;
	}

d3584 10
a3593 49
	  if (mips_abi_regsize (gdbarch) < 8 && len == 8)
	    {
	      int low_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 4 : 0;
	      unsigned long regval;

	      /* Write the low word of the double to the even register(s).  */
	      regval = extract_unsigned_integer (val + low_offset, 4);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg, phex (regval, 4));
	      write_register (float_argreg++, regval);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				    argreg, phex (regval, 4));
	      write_register (argreg++, regval);

	      /* Write the high word of the double to the odd register(s).  */
	      regval = extract_unsigned_integer (val + 4 - low_offset, 4);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg, phex (regval, 4));
	      write_register (float_argreg++, regval);

	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				    argreg, phex (regval, 4));
	      write_register (argreg++, regval);
	    }
	  else
	    {
	      /* This is a floating point value that fits entirely
	         in a single register.  */
	      /* On 32 bit ABI's the float_argreg is further adjusted
	         above to ensure that it is even register aligned.  */
	      LONGEST regval = extract_unsigned_integer (val, len);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg, phex (regval, len));
	      write_register (float_argreg++, regval);
	      /* CAGNEY: 32 bit MIPS ABI's always reserve two FP
	         registers for each argument.  The below is (my
	         guess) to ensure that the corresponding integer
	         register has reserved the same space.  */
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				    argreg, phex (regval, len));
	      write_register (argreg, regval);
	      argreg += (mips_abi_regsize (gdbarch) == 8) ? 1 : 2;
	    }
a3608 11
	  /* Structures should be aligned to eight bytes (even arg registers)
	     on MIPS_ABI_O32, if their first member has double precision.  */
	  if (mips_abi_regsize (gdbarch) < 8
	      && mips_type_needs_double_align (arg_type))
	    {
	      if ((argreg & 1))
		{
		  argreg++;
		  stack_offset += mips_abi_regsize (gdbarch);
		}
	    }
@


1.413
log
@* mips-tdep.c (mips_eabi_push_dummy_call): Rearrange some
brackets.
(mips_n32n64_push_dummy_call): Likewise.  Reformat some
expressions.
(mips_o32_push_dummy_call): Likewise.
(mips_o64_push_dummy_call): Likewise.
@
text
@d2561 2
a2562 2
	      int partial_len = (len < mips_abi_regsize (gdbarch))
				? len : mips_abi_regsize (gdbarch);
d2788 2
a2789 2
	      int partial_len = (len < mips_abi_regsize (gdbarch))
				? len : mips_abi_regsize (gdbarch);
d2876 2
a2877 2
		    regval <<= (mips_abi_regsize (gdbarch) - partial_len)
			       * TARGET_CHAR_BIT;
d3222 2
a3223 2
	      int partial_len = (len < mips_abi_regsize (gdbarch))
				? len : mips_abi_regsize (gdbarch);
d3311 2
a3312 2
		    regval <<= (mips_abi_regsize (gdbarch) - partial_len)
			       * TARGET_CHAR_BIT;
d3683 2
a3684 2
	      int partial_len = (len < mips_abi_regsize (gdbarch))
				? len : mips_abi_regsize (gdbarch);
d3755 2
a3756 2
		    regval <<= (mips_abi_regsize (gdbarch) - partial_len)
			       * TARGET_CHAR_BIT;
@


1.412
log
@* mips-tdep.c (mips_n32n64_push_dummy_call): Fix a typo in a
comment.
@
text
@d2561 2
a2562 2
	      int partial_len = (len < mips_abi_regsize (gdbarch)
				 ? len : mips_abi_regsize (gdbarch));
d2788 2
a2789 2
	      int partial_len = (len < mips_abi_regsize (gdbarch)
				 ? len : mips_abi_regsize (gdbarch));
d2874 4
a2877 4
		      && (typecode == TYPE_CODE_STRUCT ||
			  typecode == TYPE_CODE_UNION))
		    regval <<= ((mips_abi_regsize (gdbarch) - partial_len) *
				TARGET_CHAR_BIT);
d3222 2
a3223 2
	      int partial_len = (len < mips_abi_regsize (gdbarch)
				 ? len : mips_abi_regsize (gdbarch));
d3309 4
a3312 4
		      && (typecode == TYPE_CODE_STRUCT ||
			  typecode == TYPE_CODE_UNION))
		    regval <<= ((mips_abi_regsize (gdbarch) - partial_len) *
				TARGET_CHAR_BIT);
d3683 2
a3684 2
	      int partial_len = (len < mips_abi_regsize (gdbarch)
				 ? len : mips_abi_regsize (gdbarch));
d3753 4
a3756 4
		      && (typecode == TYPE_CODE_STRUCT ||
			  typecode == TYPE_CODE_UNION))
		    regval <<= ((mips_abi_regsize (gdbarch) - partial_len) *
				TARGET_CHAR_BIT);
@


1.411
log
@* mips-tdep.c (mips_n32n64_push_dummy_call): Fix a typo in a
comment.
(mips_o32_push_dummy_call): Likewise.
@
text
@d2786 1
a2786 1
	      /* Rememer if the argument was written to the stack.  */
@


1.410
log
@* mips-tdep.c (mips_o32_push_dummy_call): Take account of
argument alignment requirements when calculating stack space
required.  When aligning an arg register to eight bytes
boundary, align stack_offset too.  Write floating-point
arguments to the appropriate integer register if need go there.
(mips_o64_push_dummy_call): Likewise.
@
text
@d2860 3
a2862 3
		     mips_abi_regsize(), generates a left shift as
		     part of storing the argument in a register a
		     register (the left shift isn't generated when
d3294 3
a3296 3
		     mips_abi_regsize(), generates a left shift as
		     part of storing the argument in a register a
		     register (the left shift isn't generated when
@


1.409
log
@	* gdbarch.sh (software_single_step): Remove "insert_breakpoints_p" and
	"sig" arguments, add "regcache" argument.
	* gdbarch.c, gdbarch.h: Regenerate.

	* infrun.c (resume): Update SOFTWARE_SINGLE_STEP call arguments.
	(handle_inferior_event): Call remove_single_step_breakpoints directly
	instead of calling SOFTWARE_SINGLE_STEP to remove breakpoints.

	* alpha-tdep.c (alpha_software_single_step): Update argument list.
	Remove handling of !insert_breakpoints_p case.
	* arm-tdep.c (arm_software_single_step): Likewise.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* spu-tdep.c (spu_software_single_step): Likewise.

	* alpha-tdep.h (alpha_software_single_step): Update prototype.
	* mips-tdep.h (mips_software_single_step): Likewise.
	* rs6000-tdep.h (rs6000_software_single_step): Likewise.
	* sparc-tdep.h (sparc_software_single_step): Likewise.
@
text
@d3067 11
a3077 2
    len += align_up (TYPE_LENGTH (value_type (args[argnum])),
		     mips_stack_argsize (gdbarch));
d3213 4
a3216 1
		argreg++;
a3217 2
	  /* Note: Floating-point values that didn't fit into an FP
	     register are only written to memory.  */
d3231 1
a3231 2
		  || odd_sized_struct
		  || fp_register_arg_p (typecode, arg_type))
d3272 1
a3272 2
	         structs may go thru BOTH paths.  Floating point
	         arguments will not.  */
d3275 1
a3275 2
	      if (argreg <= MIPS_LAST_ARG_REGNUM
		  && !fp_register_arg_p (typecode, arg_type))
d3528 11
a3538 2
    len += align_up (TYPE_LENGTH (value_type (args[argnum])),
		     mips_stack_argsize (gdbarch));
d3674 4
a3677 1
		argreg++;
a3678 2
	  /* Note: Floating-point values that didn't fit into an FP
	     register are only written to memory.  */
d3692 1
a3692 2
		  || odd_sized_struct
		  || fp_register_arg_p (typecode, arg_type))
d3733 1
a3733 2
	         structs may go thru BOTH paths.  Floating point
	         arguments will not.  */
d3736 1
a3736 2
	      if (argreg <= MIPS_LAST_ARG_REGNUM
		  && !fp_register_arg_p (typecode, arg_type))
@


1.408
log
@2007-04-12  Luis Machado  <luisgpm@@br.ibm.com>

	* gdbarch.sh (software_single_step): Change the return type
	from void to int and reformatted some comments to <= 80
	columns.
	* gdbarch.c, gdbarch.h: Regenerated.
	* alpha-tdep.c (alpha_software_single_step): Likewise.
	* alpha-tdep.h (alpha_software_single_step): Likewise.
	* arm-tdep.c (arm_software_single_step): Likewise.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* mips-tdep.h (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* rs6000-tdep.h (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* sparc-tdep.h (sparc_software_single_step): Likewise.
	* spu-tdep.c (spu_software_single_step): Likewise.
	* infrun.c (resume): Check the return value from SOFTWARE_SINGLE_STEP
	and act accordingly.
@
text
@d2202 1
a2202 4
   the target of the coming instruction and breakpoint it.

   single_step is also called just after the inferior stops.  If we had
   set up a simulated single-step, we undo our damage.  */
d2205 1
a2205 1
mips_software_single_step (enum target_signal sig, int insert_breakpoints_p)
d2209 2
a2210 9
  if (insert_breakpoints_p)
    {
      pc = read_register (mips_regnum (current_gdbarch)->pc);
      next_pc = mips_next_pc (pc);

      insert_single_step_breakpoint (next_pc);
    }
  else
    remove_single_step_breakpoints ();
d2212 1
@


1.407
log
@gdb/

	* configure.tgt: Move mips*-*-pe and sh*-*-pe to
	the obsoletion stanza.
	* NEWS: Mention deleted targets.

	* config/sh/tm-wince.h: Remove.
	* config/sh/wince.mt: Remove.
	* config/mips/tm-wince.h: Remove.
	* config/mips/wince.mt: Remove.

	* wince.c: Remove.
	* wince-stub.c: Remove.
	* wince-stub.h: Remove.
	* Makefile.in (wince.o): Remove rule.
	(wince-stub.o): Likewise.

	* mips-tdep.c (mips_next_pc): Make static.
	* mips-tdep.h (mips_next_pc): Remove declaration.
	* arm-tdep.c (arm_pc_is_thumb): Make static.
	(thumb_get_next_pc): Likewise.
	(arm_get_next_pc): Likewise.
	* arm-tdep.h (arm_pc_is_thumb_dummy): Remove declaration.
	(arm_pc_is_thumb): Likewise.
	(thumb_get_next_pc): Likewise.
	(arm_get_next_pc): Likewise.

gdb/doc/

	* gdb.texinfo (WinCE): Delete obsolete subsection.
@
text
@d2207 1
a2207 1
void
d2221 2
@


1.406
log
@* mips-tdep.c: Comment typo.
@
text
@d1355 1
a1355 1
CORE_ADDR
@


1.405
log
@        * mips-tdep.c (mips_insn16_frame_cache, mips_insn32_frame_sniffer):
        Revert the previous change that had some unexpected side-effects
        on mips32.
        (mips_insn16_frame_cache, mips_insn32_frame_cache): Use the proper
        function to get the address of the calling instruction.
@
text
@d452 1
a452 1
   are listed in the followign tables.  */
@


1.404
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d1643 2
a1644 1
    const CORE_ADDR pc = frame_pc_unwind (next_frame);
d1697 1
a1697 1
  CORE_ADDR pc = frame_unwind_address_in_block (next_frame, NORMAL_FRAME);
d1965 2
a1966 1
    const CORE_ADDR pc = frame_pc_unwind (next_frame);
d2019 1
a2019 1
  CORE_ADDR pc = frame_unwind_address_in_block (next_frame, NORMAL_FRAME);
@


1.403
log
@	* doublest.c (floatformat_from_length): Use the right element from
	gdbarch floatformats.
	(floatformat_from_type, extract_typed_floating)
	(store_typed_floating): Likewise.
	* doublest.h: Remove declarations for undefined floatformat arrays.
	* gdbarch.sh (float_format, double_format, long_double_format): Change
	to pairs.
	(pformat): Update for pairs.
	* gdbarch.c, gdbarch.h: Regenerated.
	* gdbtypes.c (floatformats_ieee_single, floatformats_ieee_double)
	(floatformats_ieee_double_littlebyte_bigword)
	(floatformats_i387_ext, floatformats_m68881_ext, floatformats_arm_ext)
	(floatformats_ia64_spill, floatformats_ia64_quad, floatformats_vax_f)
	(floatformats_vax_d): New variables.
	(builtin_type_ieee_single, builtin_type_ieee_double)
	(builtin_type_arm_ext, builtin_type_ia64_spill)
	(builtin_type_ia64_quad): Replace arrays with individual types.
	(builtin_type_ieee_single_big, builtin_type_ieee_single_little)
	(builtin_type_ieee_double_big, builtin_type_ieee_double_little)
	(builtin_type_ieee_double_littlebyte_bigword, builtin_type_i960_ext)
	(builtin_type_m88110_ext, builtin_type_m88110_harris_ext)
	(builtin_type_arm_ext_big, builtin_type_arm_ext_littlebyte_bigword)
	(builtin_type_ia64_spill_big, builtin_type_ia64_spill_little)
	(builtin_type_ia64_quad_big, builtin_type_ia64_quad_little): Delete
	unused and endian-specific types.
	(recursive_dump_type): Update for floatformat pairs.
	(build_flt): Move higher.  Handle bit == -1.  Take a floatformat pair.
	(build_gdbtypes): Use build_flt.
	(_initialize_gdbtypes): Update set of initialized types.
	* gdbtypes.h: Update declarations to match gdbtypes.c.
	(struct main_type): Store a pointer to two floatformats.
	* arch-utils.c (default_float_format, default_double_format): Delete.
	* arch-utils.h (default_float_format, default_double_format): Delete.

	* arm-tdep.c, avr-tdep.c, hppa-tdep.c, hppabsd-tdep.c, i386-tdep.c,
	ia64-tdep.c,  iq2000-tdep.c, m68k-tdep.c, m88k-tdep.c,
	mips-linux-tdep.c, mips-tdep.c, mt-tdep.c, ppcobsd-tdep.c,
	sparc-linux-tdep.c, sparc-tdep.c, sparcnbsd-tdep.c, spu-tdep.c,
	vax-tdep.c, alpha-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d1669 2
a1670 1
  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
d1696 1
a1696 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d1990 2
a1991 1
  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
d2017 1
a2017 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d2112 1
a2112 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
@


1.402
log
@	* gdbarch.sh (register_type): Update comment.
	* gdbarch.h: Regenerated.
	* arch-utils.c (generic_register_size): Call register_type.
	* ia64-tdep.c (ia64_extract_return_value): Likewise.
	* m32c-tdep.c (check_for_saved): Likewise.
	* mips-tdep.c (mips_print_register, print_gp_register_row)
	(mips_print_registers_info): Likewise.
	* sh-tdep.c (sh_pseudo_register_read, sh_pseudo_register_write):
	Likewise.
	* sh64-tdep.c (sh64_pseudo_register_read, sh64_pseudo_register_write)
	(sh64_do_register, sh64_print_register)
	(sh64_media_print_registers_info): Likewise.
	* tui/tui-regs.c (tui_register_format): Likewise.
@
text
@d182 1
a182 1
  "floatformat_ieee_double_big",
d186 6
d710 4
a713 16
      switch (gdbarch_byte_order (gdbarch))
	{
	case BFD_ENDIAN_BIG:
	  if (mips_isa_regsize (gdbarch) == 4)
	    return builtin_type_ieee_single_big;
	  else
	    return builtin_type_ieee_double_big;
	case BFD_ENDIAN_LITTLE:
	  if (mips_isa_regsize (gdbarch) == 4)
	    return builtin_type_ieee_single_little;
	  else
	    return builtin_type_ieee_double_little;
	case BFD_ENDIAN_UNKNOWN:
	default:
	  internal_error (__FILE__, __LINE__, _("bad switch"));
	}
d3864 1
a3864 4
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    return builtin_type_ieee_single_big;
  else
    return builtin_type_ieee_single_little;
d3870 1
a3870 4
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    return builtin_type_ieee_double_big;
  else
    return builtin_type_ieee_double_little;
d5068 1
a5068 2
      set_gdbarch_long_double_format (gdbarch,
                                      &floatformat_n32n64_long_double_big);
d5080 1
a5080 2
      set_gdbarch_long_double_format (gdbarch,
                                      &floatformat_n32n64_long_double_big);
@


1.401
log
@Copyright updates for 2007.
@
text
@d4034 1
a4034 1
  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d4066 1
a4066 1
			  gdbarch_register_type (gdbarch, regnum), 'x', 0,
d4103 1
a4103 1
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
d4129 1
a4129 1
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
d4181 1
a4181 1
	  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
@


1.400
log
@	* NEWS: Mention pointer to member improvements.
	* Makefile.in (gnu-v3-abi.o): Delete special rule.
	(eval.o, gnu-v3-abi.o, ia64-tdep.o): Update.
	* ada-valprint.c (ada_print_scalar): Update for new type codes.
	* c-typeprint.c (c_print_type): Update for new type codes.
	(c_type_print_varspec_prefix, c_type_print_varspec_suffix)
	(c_type_print_base): Likewise.
	(c_type_print_args): Rewrite.
	* c-valprint.c (c_val_print): Update for new type codes.  Remove
	support for references to members.  Treat methods like functions.
	* cp-abi.c (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New.
	* cp-abi.h (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New prototypes.
	(struct cp_abi_ops): Add corresponding members.
	* cp-valprint.c (cp_print_class_method): Delete.
	(cp_find_class_member): New function.
	(cp_print_class_member): Use it.  Simplify support for bogus
	member pointers.
	* dwarf2read.c (quirk_gcc_member_function_pointer): Use
	lookup_methodptr_type.
	(read_tag_ptr_to_member_type): Likewise, and lookup_memberptr_type.
	* eval.c (evaluate_subexp_standard): Implement EVAL_SKIP for
	OP_SCOPE.  Update call to value_aggregate_elt.  Rewrite member
	pointer support.
	(evaluate_subexp_for_address): Handle OP_SCOPE explicitly.  Handle
	references returned by user defined operators.
	* f-typeprint.c (f_print_type, f_type_print_varspec_prefix)
	(f_type_print_varspec_suffix): Remove support for member pointers.
	* gdbtypes.c (lookup_memberptr_type): Renamed from lookup_member_type
	and adjusted.
	(smash_to_memberptr_type): Likewise, from smash_to_member_type.
	(lookup_methodptr_type): New.
	(rank_one_type): Adjust for TYPE_CODE_MEMBERPTR.
	(recursive_dump_type): Update for new types.
	* gdbtypes.h (enum type_code): Replace TYPE_CODE_MEMBER with
	TYPE_CODE_MEMBERPTR and TYPE_CODE_METHODPTR.
	(lookup_memberptr_type, lookup_methodptr_type)
	(smash_to_memberptr_type): New prototypes.
	(smash_to_method_type): Formatting fix.
	(lookup_member_type, smash_to_member_type): Delete prototypes.
	* gnu-v3-abi.c (gnuv3_get_vtable, gnuv3_get_virtual_fn): New.
	Do not rely on debug information for the vptr or the method's
	enclosing type.  Handle function descriptors for IA64.
	(gnuv3_virtual_fn_field): Rewrite using the new functions.
	(gnuv3_find_method_in, gnuv3_print_method_ptr)
	(gnuv3_method_ptr_size, gnuv3_make_method_ptr)
	(gnuv3_method_ptr_to_value): New.
	(init_gnuv3_ops): Set new members of gnu_v3_abi_ops.
	* hpread.c (hpread_type_lookup): Update for new types.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-typeprint.c (m2_print_type): Remove explicit support
	for member pointers.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix)
	(pascal_type_print_varspec_suffix, pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_object_print_class_method, pascal_object_print_class_member):
	Delete.
	* p-lang.h (pascal_object_print_class_method)
	(pascal_object_print_class_member): Delete prototypes.
	* stabsread.c (read_type): Update for new types.
	* typeprint.c (print_type_scalar): Likewise.
	* valops.c (value_struct_elt_for_reference, value_namespace_elt)
	(value_maybe_namespace_elt, value_aggregate_elt): Add want_address
	argument.  Construct a pointer to member if the address of a
	function or data member is requested.
	(value_cast_pointers): Don't modify the input value.
	(value_cast): Adjust pointer to member handling for new types.
	Allow null pointer to member constants.  Don't modify the input
	value.
	(value_ind): Remove pointer to member check.  Handle function
	descriptors for function pointers.
	(value_struct_elt, value_find_oload_method_list, check_field):
	Remove pointer to member checks.
	* value.c (unpack_long): Allow pointers to data members.
	(value_from_longest): Allow member pointers.
	* value.h (value_aggregate_elt): Add want_address.
	* varobj.c (c_variable_editable): Remove check for members.
	* gdbarch.sh: Add vtable_function_descriptors and vbit_in_delta.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Handle descriptors
	in virtual tables.
	(ia64_gdbarch_init): Call set_gdbarch_vtable_function_descriptors.
	* c-lang.h (cp_print_class_method): Delete prototype.
	* arm-tdep.c (arm_gdbarch_init): Call set_gdbarch_vbit_in_delta.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	* gdbarch.c, gdbarch.h: Regenerated.

	* gdb.cp/classes.exp (test_pointers_to_class_members): Update expected
	output.  Test the types of members and member pointers.
	* gdb.cp/inherit.exp (test_print_mi_member_types): Remove KFAILs for
	gdb/2092.
	* gdb.cp/member-ptr.exp: Search for a comment instead of a
	statement.  Enable for GCC.  Update expected output for some tests
	and add new tests.  Remove obsolete GCC KFAILs.  Allow GCC's class
	layout.
	* gdb.cp/member-ptr.cc (Padding, Padding::vspacer, Base, Base::get_x)
	(Base::vget_base, Left, Left::vget, Right, Right::vget, Diamond)
	(Diamond::vget_base): New.
	(main): Add new tests.
	* gdb.cp/printmethod.exp: Update expected output for member functions.
	* gdb.cp/virtfunc.exp (test_virtual_calls): Add a KFAIL for
	print pEe->D::vg().
@
text
@d3 2
a4 2
   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
@


1.399
log
@	* Makefile.in (mips-tdep.o, target-descriptions.o): Update.
	* target-descriptions.c (struct property): New.
	(struct target_desc): Add properties member.
	(tdesc_property, set_tdesc_property): New.
	* target-descriptions.h (tdesc_property, set_tdesc_property):
	Declare.
	* mips-tdep.c (PROPERTY_GP32, PROPERTY_GP64): New constants.
	(struct gdbarch_tdep): Add register_size_valid_p and register_size.
	(mips_isa_regsize): Use them.
	(mips_register_g_packet_guesses): New.
	(mips_gdbarch_init): Call it.  If a target description is supplied,
	check for internal properties.  Check for register size mismatches.
	* remote.c (send_g_packet, process_g_packet): New functions, split
	out from fetch_registers_using_g.
	(fetch_registers_using_g): Use them.
	(struct remote_g_packet_guess, remote_g_packet_guess_s)
	(struct remote_g_packet_data, remote_g_packet_data_handle)
	(remote_g_packet_data_init, register_remote_g_packet_guess)
	(remote_read_description): New.
	(init_remote_ops, init_remote_async_ops): Set to_read_description.
	(_initialize_remote): Register remote_g_packet_data_handle.
	* remote.h (register_remote_g_packet_guess): Declare.
@
text
@d5234 3
@


1.398
log
@        * gdbcore.h (read_memory_nobpt): New function name instead of
        deprecated_read_memory_nobpt.
        * breakpoint.c (read_memory_nobpt): New function name instead
        of deprecated_read_memory_nobpt.
        Adjust calls to old deprecated_read_memory_nobpt accordingly.
        * alpha-tdep.c: Adjust calls to deprecated_read_memory_nobpt
        accordingly.
        * alphanbsd-tdep.c: Likewise.
        * frame.c: Likewise.
        * frv-tdep.c: Likewise.
        * hppa-linux-tdep.c: Likewise.
        * hppa-tdep.c: Likewise.
        * i386-linux-nat.c: Likewise.
        * m68klinux-tdep.c: Likewise.
        * mips-tdep.c: Likewise.
        * s390-tdep.c: Likewise.
@
text
@d58 2
d124 5
d151 7
d262 7
d4735 31
d4910 10
d4950 17
d5234 2
@


1.397
log
@	* mips-tdep.c (mips_integer_to_address): Simplify be calling
	extract_signed_integer directly.  Fix comment.
@
text
@d861 1
a861 1
  status = deprecated_read_memory_nobpt (addr, buf, instlen);
@


1.396
log
@2006-06-19  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (mips_eabi_push_dummy_call): For 32 bit ABI, to
	decide how many registers it takes to pass a floating point
	argument, what matters is the size of a floating point register
	(not the size of a general purpose register).
	(mips_o32_push_dummy_call): Ditto.
@
text
@d4650 2
a4651 3
/* Convert an integer into an address.  By first converting the value
   into a pointer and then extracting it signed, the address is
   guarenteed to be correctly sign extended.  */
d4657 1
a4657 5
  gdb_byte *tmp = alloca (TYPE_LENGTH (builtin_type_void_data_ptr));
  LONGEST val = unpack_long (type, buf);
  store_signed_integer (tmp, TYPE_LENGTH (builtin_type_void_data_ptr), val);
  return extract_signed_integer (tmp,
				 TYPE_LENGTH (builtin_type_void_data_ptr));
@


1.395
log
@Approved by Daniel Jacobowitz.

	2006-06-13  Fred Fish  <fnf@@specifix.com>
	* mips-tdep.c (mips_find_long_section): New function.
	(mips_gdbarch_init): Use it to set long and pointer sizes.
@
text
@d2498 1
a2498 1
	  if (mips_abi_regsize (gdbarch) < 8 && len == 8)
d3122 1
a3122 1
	  if (mips_abi_regsize (gdbarch) < 8 && len == 8)
@


1.394
log
@2006-06-08  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (fp_register_arg_p): Recognize floating point typedefs.
@
text
@d4693 14
d5026 52
@


1.393
log
@2006-05-31  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c: Comment tweaks.
@
text
@d2338 2
a2339 1
	       && TYPE_CODE (TYPE_FIELD_TYPE (arg_type, 0)) == TYPE_CODE_FLT))
@


1.392
log
@Checked in under the 'obvious fix rule'

	2006-05-19  Fred Fish  <fnf@@specifix.com>
	* Makefile.in: Fix spelling of 'explicitly' and 'explicit'.
	* dwarfread.c: Fix spelling of 'unexpected'.
	* mips-tdep.c: Fix spelling of 'possible' and 'Determine'.
	* stack.c: Fix spelling of 'RETURN_VALUE'.
@
text
@d890 2
a891 2
/* Determine whate to set a single step breakpoint while considering
   branch prediction */
d5166 1
a5166 1
      /* determine the ISA */
d5185 1
a5185 1
      /* determine the size of a pointer */
@


1.391
log
@Approved by Daniel Jacobowitz <drow@@false.org>

	2006-05-06  Fred Fish  <fnf@@specifix.com>
	* mips-tdep.c (mips_o64_push_dummy_call): Left shift big endian
	structs or unions independent of ABI register size.
@
text
@d2326 1
a2326 1
   is no FPU, FP are not even considered as possibile candidates for
d2647 1
a2647 1
/* Determin the return value convention being used.  */
@


1.391.2.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d861 1
a861 1
  status = read_memory_nobpt (addr, buf, instlen);
d890 2
a891 2
/* Determine where to set a single step breakpoint while considering
   branch prediction.  */
d2326 1
a2326 1
   is no FPU, FP are not even considered as possible candidates for
d2338 1
a2338 2
	       && TYPE_CODE (check_typedef (TYPE_FIELD_TYPE (arg_type, 0))) 
	       == TYPE_CODE_FLT))
d2497 1
a2497 1
	  if (register_size (gdbarch, float_argreg) < 8 && len == 8)
d2647 1
a2647 1
/* Determine the return value convention being used.  */
d3121 1
a3121 1
	  if (register_size (gdbarch, float_argreg) < 8 && len == 8)
d4649 3
a4651 2
/* Convert an integer into an address.  Extracting the value signed
   guarantees a correctly sign extended address.  */
d4657 5
a4661 1
  return (CORE_ADDR) extract_signed_integer (buf, TYPE_LENGTH (type));
a4691 14
static void
mips_find_long_section (bfd *abfd, asection *sect, void *obj)
{
  int *lbp = (int *) obj;
  const char *name = bfd_get_section_name (abfd, sect);

  if (strncmp (name, ".gcc_compiled_long32", 20) == 0)
    *lbp = 32;
  else if (strncmp (name, ".gcc_compiled_long64", 20) == 0)
    *lbp = 64;
  else if (strncmp (name, ".gcc_compiled_long", 18) == 0)
    warning (_("unrecognized .gcc_compiled_longXX"));
}

a5010 52
  /* GCC creates a pseudo-section whose name specifies the size of
     longs, since -mlong32 or -mlong64 may be used independent of
     other options.  How those options affect pointer sizes is ABI and
     architecture dependent, so use them to override the default sizes
     set by the ABI.  This table shows the relationship between ABI,
     -mlongXX, and size of pointers:

     ABI		-mlongXX	ptr bits
     ---		--------	--------
     o32		32		32
     o32		64		32
     n32		32		32
     n32		64		64
     o64		32		32
     o64		64		64
     n64		32		32
     n64		64		64
     eabi32		32		32
     eabi32		64		32
     eabi64		32		32
     eabi64		64		64

    Note that for o32 and eabi32, pointers are always 32 bits
    regardless of any -mlongXX option.  For all others, pointers and
    longs are the same, as set by -mlongXX or set by defaults.
 */

  if (info.abfd != NULL)
    {
      int long_bit = 0;

      bfd_map_over_sections (info.abfd, mips_find_long_section, &long_bit);
      if (long_bit)
	{
	  set_gdbarch_long_bit (gdbarch, long_bit);
	  switch (mips_abi)
	    {
	    case MIPS_ABI_O32:
	    case MIPS_ABI_EABI32:
	      break;
	    case MIPS_ABI_N32:
	    case MIPS_ABI_O64:
	    case MIPS_ABI_N64:
	    case MIPS_ABI_EABI64:
	      set_gdbarch_ptr_bit (gdbarch, long_bit);
	      break;
	    default:
	      internal_error (__FILE__, __LINE__, _("unknown ABI in switch"));
	    }
	}
    }

d5166 1
a5166 1
      /* Determine the ISA.  */
d5185 1
a5185 1
      /* Determine the size of a pointer.  */
@


1.390
log
@	2006-05-06  Fred Fish  <fnf@@specifix.com>
	* mips-tdep.c (mips_o64_return_value): Replace stub that always
	returned RETURN_VALUE_STRUCT_CONVENTION with a real function.
@
text
@d3722 1
a3722 1
		     same for integral types.
d3724 1
a3724 18
		     Also don't do this adjustment on O64 binaries.

		     cagney/2001-07-23: gdb/179: Also, GCC, when
		     outputting LE O32 with sizeof (struct) <
		     mips_abi_regsize(), generates a left shift as
		     part of storing the argument in a register a
		     register (the left shift isn't generated when
		     sizeof (struct) >= mips_abi_regsize()).  Since
		     it is quite possible that this is GCC
		     contradicting the LE/O32 ABI, GDB has not been
		     adjusted to accommodate this.  Either someone
		     needs to demonstrate that the LE/O32 ABI
		     specifies such a left shift OR this new ABI gets
		     identified as such and GDB gets tweaked
		     accordingly.  */

		  if (mips_abi_regsize (gdbarch) < 8
		      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
@


1.389
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@d3791 39
a3829 1
  return RETURN_VALUE_STRUCT_CONVENTION;
@


1.388
log
@	* mips-tdep.c (mips_gdbarch_init): Default 64-bit ELF files to N64.
@
text
@d2191 1
a2191 4
  static CORE_ADDR next_pc;
  typedef char binsn_quantum[BREAKPOINT_MAX];
  static binsn_quantum break_mem;
  CORE_ADDR pc;
d2198 1
a2198 1
      target_insert_breakpoint (next_pc, break_mem);
d2201 1
a2201 1
    target_remove_breakpoint (next_pc, break_mem);
@


1.387
log
@	* mips-tdep.c (is_mips16_addr, mips32_next_pc, add_offset_16):
	Correct arithmetic for 64-bit CORE_ADDR.
@
text
@d4767 7
@


1.386
log
@	* mips-linux-tdep.c: Include "floatformat.h".
	(mips_linux_init_abi): Use 128-bit long double for N32 and N64.
	(mips_n32n64_return_value): Support 128-bit long double.
	(print_gp_register_row): Don't print spaces before ignored
	or floating point registers.
@
text
@d205 1
a205 1
  return ((addr) & ~1);
d992 1
a992 1
	    pc = reg + ((pc + 4) & 0xf0000000);
d999 1
a999 1
	    pc = reg + ((pc + 4) & 0xf0000000) + 1;	/* yes, +1 */
d1205 1
a1205 1
  return ((offset << 2) | ((pc + 2) & (0xf0000000)));
@


1.385
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d2914 18
a4057 1
  fprintf_filtered (file, "     ");
d4066 2
d4073 4
@


1.385.2.1
log
@Merge ten gdb and gdbserver patches for MIPS/MIPS64 support.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d205 1
a205 1
  return ((addr) & ~(CORE_ADDR) 1);
d992 1
a992 1
	    pc = reg + ((pc + 4) & ~(CORE_ADDR) 0x0fffffff);
d999 1
a999 1
	    pc = reg + ((pc + 4) & ~(CORE_ADDR) 0x0fffffff) + 1;	/* yes, +1 */
d1205 1
a1205 1
  return ((offset << 2) | ((pc + 2) & (~(CORE_ADDR) 0x0fffffff)));
a2913 18
	   && TYPE_LENGTH (type) == 16
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A 128-bit floating-point value fills both $f0 and $f2.  The
	 two registers are used in the same as memory order, so the
	 eight bytes with the lower memory address are in $f0.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $f0 and $f2\n");
      mips_xfer_register (regcache,
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
			  8, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
      mips_xfer_register (regcache,
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 2,
			  8, TARGET_BYTE_ORDER, readbuf ? readbuf + 8 : readbuf,
			  writebuf ? writebuf + 8 : writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
d4040 1
a4048 2
      if (col == 0)
	fprintf_filtered (file, "     ");
a4053 4

  if (col == 0)
    return regnum;

a4743 7
  /* Default 64-bit objects to N64 instead of O32.  */
  if (found_abi == MIPS_ABI_UNKNOWN
      && info.abfd != NULL
      && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour
      && elf_elfheader (info.abfd)->e_ident[EI_CLASS] == ELFCLASS64)
    found_abi = MIPS_ABI_N64;

@


1.385.2.1.2.1
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d2191 4
a2194 1
  CORE_ADDR pc, next_pc;
d2201 1
a2201 1
      insert_single_step_breakpoint (next_pc);
d2204 1
a2204 1
    remove_single_step_breakpoints ();
@


1.384
log
@* mips-tdep.c (n32n64_floatformat_always_valid): Use 'const void
*' for second argument instead of 'const char *'.
@
text
@d3 1
a3 1
   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
d24 2
a25 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.383
log
@* mips-tdep.c (mips_insn16_frame_prev_register)
(mips_insn32_frame_prev_register, mips_stub_frame_prev_register):
Change type of last argument to `gdb_byte *'.
@
text
@d148 1
a148 1
                                 const char *from)
@


1.382
log
@* mips-tdep.c (mips_xfer_register, mips_o32_return_value)
(mips_integer_to_address): Use gdb_byte instead of bfd_byte.
@
text
@d1662 1
a1662 1
				 int *realnump, void *valuep)
d1982 1
a1982 1
				 int *realnump, void *valuep)
d2076 1
a2076 1
				 int *realnump, void *valuep)
@


1.381
log
@* mips-tdep.c (mips_pseudo_register_read)
(mips_pseudo_register_write): Change type of last argument to
`gdb_byte *'.
(mips_register_to_value, mips_value_to_register): Change type of
last argument to `gdb_byte *'.  Remove casts that are no longer
needed.
(mips_fetch_instruction, fetch_mips_16): Use gdb_byte for buf.
(mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
(mips_o32_push_dummy_call, mips_o32_return_value): Use `const
gdb_byte *' for val and gdb_byte for valbuf.  Remove casts that
are no longer needed.
(mips_eabi_return_value, mips_n32n64_return_value)
(mips_o32_return_value, mips_o64_return_value): Change type of
readbuf and writebuf arguments to `gdb_byte *'.
(mips_read_fp_register_single): Change type of last argument to
`gdb_byte *'.  Use `gdb_byte *' for raw_buffer.
(mips_read_fp_register_double): Change type of last argument to
`gdb_byte *'.
(mips_print_fp_register): Use `gdb_byte *' for raw_buffer.  Remove
casts that are no longer needed.
(mips_print_register, print_gp_register_row): Use gdb_byte for
raw_buffer.  Remove casts that are no longer needed.
(mips_single_step_through_delay): Use gdb_byte for buf.
(mips_breakpoint_from_pc): Change return type to `const gdb_byte
*'.  Use gdb_byte for mips16_big_breakpoint, big_breakpoint,
pmon_big_breakpoint, idt_big_breakpoint, mips16_little_breakpoint,
little_breakpoint, pmon_little_breakpoint and
idt_little_breakpoint.
(mips_integer_to_address): Use `gdb_byte *' for tmp.
@
text
@d315 2
a316 2
		    enum bfd_endian endian, bfd_byte * in,
		    const bfd_byte * out, int buf_offset)
d3389 1
a3389 1
      bfd_byte reg[MAX_REGISTER_SIZE];
d4614 1
a4614 1
			 struct type *type, const bfd_byte *buf)
@


1.380
log
@	* mips-tdep.c (mips_stub_frame_sniffer): Handle .MIPS.stubs
	section like .plt.
@
text
@d4 2
a5 2
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software
   Foundation, Inc.
d571 1
a571 1
			   int cookednum, void *buf)
d593 1
a593 1
			    const void *buf)
d657 1
a657 1
			struct type *type, void *to)
d659 2
a660 2
  get_frame_register (frame, regnum + 0, (char *) to + 4);
  get_frame_register (frame, regnum + 1, (char *) to + 0);
d665 1
a665 1
			struct type *type, const void *from)
d667 2
a668 2
  put_frame_register (frame, regnum + 0, (const char *) from + 4);
  put_frame_register (frame, regnum + 1, (const char *) from + 0);
d850 1
a850 1
  char buf[MIPS_INSN32_SIZE];
d1111 1
a1111 1
  char buf[8];
d2445 2
a2446 2
      char *val;
      char valbuf[MAX_REGISTER_SIZE];
d2471 1
a2471 1
	val = (char *) value_contents (arg);
d2655 1
a2655 1
			void *readbuf, const void *writebuf)
d2728 1
a2728 1
      char *val;
d2739 1
a2739 1
      val = (char *) value_contents (arg);
d2905 1
a2905 1
			  void *readbuf, const void *writebuf)
d3068 1
a3068 1
      char *val;
d3079 1
a3079 1
      val = (char *) value_contents (arg);
d3320 1
a3320 1
		       void *readbuf, const void *writebuf)
d3522 1
a3522 1
      char *val;
d3533 1
a3533 1
      val = (char *) value_contents (arg);
d3774 1
a3774 1
		       void *readbuf, const void *writebuf)
d3832 1
a3832 1
			      char *rare_buffer)
d3835 1
a3835 1
  char *raw_buffer = alloca (raw_size);
d3864 1
a3864 1
			      char *rare_buffer)
d3901 1
a3901 1
  char *raw_buffer;
d3905 2
a3906 4
  raw_buffer =
    (char *) alloca (2 *
		     register_size (current_gdbarch,
				    mips_regnum (current_gdbarch)->fp0));
d3973 1
a3973 1
  char raw_buffer[MAX_REGISTER_SIZE];
d4034 1
a4034 1
  char raw_buffer[MAX_REGISTER_SIZE];
d4083 1
a4083 1
	  fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[byte]);
d4087 1
a4087 1
	  fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[byte]);
d4153 1
a4153 1
  char buf[MIPS_INSN32_SIZE];
d4389 1
a4389 1
static const unsigned char *
d4396 1
a4396 1
	  static unsigned char mips16_big_breakpoint[] = { 0xe8, 0xa5 };
d4406 3
a4408 3
	  static unsigned char big_breakpoint[] = { 0, 0x5, 0, 0xd };
	  static unsigned char pmon_big_breakpoint[] = { 0, 0, 0, 0xd };
	  static unsigned char idt_big_breakpoint[] = { 0, 0, 0x0a, 0xd };
d4426 1
a4426 1
	  static unsigned char mips16_little_breakpoint[] = { 0xa5, 0xe8 };
d4433 3
a4435 3
	  static unsigned char little_breakpoint[] = { 0xd, 0, 0x5, 0 };
	  static unsigned char pmon_little_breakpoint[] = { 0xd, 0, 0, 0 };
	  static unsigned char idt_little_breakpoint[] = { 0xd, 0x0a, 0, 0 };
d4616 1
a4616 1
  char *tmp = alloca (TYPE_LENGTH (builtin_type_void_data_ptr));
@


1.379
log
@* mips-tdep.c (mips_single_step_through_delay): Put back check for
breakpoint lost with the introduction of this function.
@
text
@d2094 1
d2096 1
d2099 10
a2108 2
  else
    return NULL;
@


1.378
log
@* mips-tdep.c (show_mips_abi): Change calling conventions to match
those expected by add_setshow_enum_cmd.  Use 'file' argument as
appropriate.
@
text
@d4151 3
@


1.377
log
@2005-02-20  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_enum_cmd through out.
	* arch-utils.c, charset.c, demangle.c, i386-tdep.c: Update.
	* infrun.c, mips-tdep.c, osabi.c, serial.c, tui/tui-win.c: Update.
@
text
@d5062 4
a5065 1
show_mips_abi (char *ignore_args, int from_tty)
d5068 4
a5071 2
    printf_filtered
      ("The MIPS ABI is unknown because the current architecture is not MIPS.\n");
d5079 3
a5081 2
	printf_filtered
	  ("The MIPS ABI is set automatically (currently \"%s\").\n",
d5084 3
a5086 2
	printf_filtered
	  ("The MIPS ABI is assumed to be \"%s\" (due to user setting).\n",
d5091 3
a5093 2
	  printf_filtered
	    ("The (auto detected) MIPS ABI \"%s\" is in use even though the user setting was \"%s\".\n",
@


1.376
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* command.h (fprint_setshow_ftype): Delete.
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* complaints.c, cris-tdep.c, dwarf2read.c, frame.c: Update.
	* hppa-tdep.c, infcall.c, m32r-rom.c, maint.c: Update.
	* mips-tdep.c, nto-tdep.c, observer.c, remote-rdi.c: Update
	* remote.c, target.c, cli/cli-logging.c: Update.
@
text
@d5213 15
a5227 10
  c = add_set_enum_cmd
    ("abi", class_obscure, mips_abi_strings, &mips_abi_string,
     "Set the ABI used by this program.\n"
     "This option can be set to one of:\n"
     "  auto  - the default ABI associated with the current binary\n"
     "  o32\n"
     "  o64\n" "  n32\n" "  n64\n" "  eabi32\n" "  eabi64", &setmipscmdlist);
  set_cmd_sfunc (c, mips_abi_update);
  add_cmd ("abi", class_obscure, show_mips_abi,
	   _("Show ABI in use by MIPS target"), &showmipscmdlist);
@


1.375
log
@2005-02-16  Andrew Cagney  <cagney@@gnu.org>

	Merge setshow print and show parameters.
	* command.h (show_value_ftype): Define.
	(deprecated_show_value_hack): Declare.
	(add_setshow_enum_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_filename_cmd)
	(add_setshow_string_cmd, add_setshow_uinteger_cmd)
	(add_setshow_zinteger_cmd): Change type of show_func to
	show_value_ftype.
	* cli/cli-decode.h (struct cmd_list_element): Replace
	fprint_setshow with show_value_func.
	* cli/cli-decode.c (add_setshow_cmd_full): Update show_func
	parameter.  Set show_value_func.  Do not set cmd_sfunc.
	(add_setshow_enum_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_filename_cmd)
	(add_setshow_string_cmd, add_setshow_uinteger_cmd)
	(add_setshow_zinteger_cmd): Update.
	* complaints.c (complaints_show_value): Replace
	fprint_setshow_complaints.
	(_initialize_complaints): Update.
	* mips-tdep.c (show_mask_address): Update.
	* arm-tdep.c (show_fp_model): Update.
	* cli/cli-setshow.c (do_setshow_command): Call show_value_func
	instead of fprint_setshow.  Use deprecated_show_value_hack.
	(deprecated_show_value_hack): New function.
	* remote.c (add_packet_config_cmd, show_remote_cmd):
	(show_remote_protocol_P_packet_cmd)
	(show_remote_protocol_P_packet_cmd)
	(show_remote_protocol_Z_access_wp_packet_cmd)
	(show_remote_protocol_Z_hardware_bp_packet_cmd)
	(show_remote_protocol_Z_packet_cmd)
	(show_remote_protocol_Z_read_wp_packet_cmd)
	(show_remote_protocol_Z_software_bp_packet_cmd)
	(show_remote_protocol_Z_write_wp_packet_cmd)
	(show_remote_protocol_binary_download_cmd)
	(show_remote_protocol_p_packet_cmd)
	(show_remote_protocol_qPart_auxv_packet_cmd)
	(show_remote_protocol_qSymbol_packet_cmd)
	(show_remote_protocol_vcont_packet_cmd): Update.
@
text
@d5194 1
d5196 1
a5196 1
			NULL, NULL, &setmipscmdlist, &showmipscmdlist);
d5208 1
d5210 1
a5210 1
			NULL, NULL, &setmipscmdlist, &showmipscmdlist);
d5261 1
a5262 1
			    reinit_frame_cache_sfunc, NULL,
a5272 1
				NULL, /* FIXME: i18n: Zerroing of upper 32 bits of 64-bit address is %s.  */
d5287 1
a5288 1
			   set_mips64_transfers_32bit_regs, NULL,
d5297 1
a5298 1
			    NULL, NULL,
@


1.374
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d764 2
a765 1
show_mask_address (char *cmd, int from_tty, struct cmd_list_element *c)
d768 2
d5272 2
a5273 1
				NULL, show_mask_address, &setmipscmdlist, &showmipscmdlist);
@


1.373
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d5173 1
a5173 1
		  "Various MIPS specific commands.",
d5177 1
a5177 1
		  "Various MIPS specific commands.",
d5223 1
a5223 1
		  "Set use of MIPS floating-point coprocessor.",
@


1.372
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_setshow functions, replace "PRINT:" comment prefix
	with "FIXME: i18n:".
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* cris-tdep.c, dwarf2read.c, frame.c, hppa-tdep.c: Update.
	* infcall.c, m32r-rom.c, maint.c, mips-tdep.c: Update.
	* nto-tdep.c, observer.c, remote-rdi.c, remote.c: Update.
	* target.c, cli/cli-logging.c: Update.
@
text
@d5217 1
a5217 1
	   "Show ABI in use by MIPS target", &showmipscmdlist);
d5226 1
a5226 1
	   "Select single-precision MIPS floating-point coprocessor.",
d5229 1
a5229 1
	   "Select double-precision MIPS floating-point coprocessor.",
d5235 1
a5235 1
	   "Select no MIPS floating-point coprocessor.", &mipsfpulist);
d5240 1
a5240 1
	   "Select MIPS floating-point coprocessor automatically.",
d5243 1
a5243 1
	   "Show current use of MIPS floating-point coprocessor target.",
@


1.371
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d5182 3
a5184 3
			size_enums, &mips_abi_regsize_string, "\
Set size of general purpose registers saved on the stack.\n", "\
Show size of general purpose registers saved on the stack.\n", "\
d5189 3
a5191 3
          saved GP register size from information contained in the executable.\n\
          (default: auto)",
			NULL, /* PRINT: Size of general purpose registers saved on the stack is %s.  */
d5196 3
a5198 3
		       size_enums, &mips_stack_argsize_string, "\
Set the amount of stack space reserved for each argument.\n", "\
Show the amount of stack space reserved for each argument.\n", "\
d5203 2
a5204 2
          target and executable (default)",
			NULL, /* PRINT: The amount of stack space reserved for each argument is %s.  */
d5250 3
a5252 3
			    &heuristic_fence_post, "\
Set the distance searched for the start of a function.\n", "\
Show the distance searched for the start of a function.\n", "\
d5255 2
a5256 2
search.  The only need to set it is when debugging a stripped executable.",
			    NULL, /* PRINT: The distance searched for the start of a function is %s.  */
d5262 4
a5265 3
  add_setshow_auto_boolean_cmd ("mask-address", no_class, &mask_address_var, "\
Set zeroing of upper 32 bits of 64-bit addresses.", "\
Show zeroing of upper 32 bits of 64-bit addresses.", "\
d5267 2
a5268 2
allow GDB to determine the correct value.\n",
				NULL, /* PRINT: Zerroing of upper 32 bits of 64-bit address is %s.  */
d5274 5
a5278 3
			   &mips64_transfers_32bit_regs_p, "\
Set compatibility with 64-bit MIPS target that transfers 32-bit quantities.", "\
Show compatibility with 64-bit MIPS target that transfers 32-bit quantities.", "\
d5281 4
a5284 3
64 bits for others.  Use \"off\" to disable compatibility mode",
			   NULL, /* PRINT: Compatibility with 64-bit MIPS target that transfers 32-bit quantities is %s.  */
 set_mips64_transfers_32bit_regs, NULL, &setlist, &showlist);
d5288 5
a5292 5
			    &mips_debug, "\
Set mips debugging.\n", "\
Show mips debugging.\n", "\
When non-zero, mips specific debugging is enabled.\n",
			    NULL, /* PRINT: Mips debugging is currently %s.  */
@


1.370
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d273 1
a273 1
	internal_error (__FILE__, __LINE__, "bad switch");
d334 1
a334 1
      internal_error (__FILE__, __LINE__, "bad switch");
d525 1
a525 1
		    "mips_register_name: bad register number %d", rawnum);
d587 1
a587 1
    internal_error (__FILE__, __LINE__, "bad register size");
d609 1
a609 1
    internal_error (__FILE__, __LINE__, "bad register size");
d697 1
a697 1
	  internal_error (__FILE__, __LINE__, "bad switch");
d758 1
a758 1
      internal_error (__FILE__, __LINE__, "mips_mask_address_p: bad switch");
d781 1
a781 1
      internal_error (__FILE__, __LINE__, "show_mask_address: bad switch");
d1191 1
a1191 1
      internal_error (__FILE__, __LINE__, "bad switch");
d3355 1
a3355 1
	  internal_error (__FILE__, __LINE__, "bad switch");
d3866 2
a3867 2
			"mips_read_fp_register_double: bad access to "
			"odd-numbered FP register");
d4231 1
a4231 1
      internal_error (__FILE__, __LINE__, "bad switch");
d4262 1
a4262 1
    internal_error (__FILE__, __LINE__, "set mipsfpu failed");
d4276 1
a4276 1
    internal_error (__FILE__, __LINE__, "set mipsfpu failed");
d4290 1
a4290 1
    internal_error (__FILE__, __LINE__, "set mipsfpu failed");
d4646 1
a4646 1
  internal_error (__FILE__, __LINE__, "unknown ABI string");
d4946 1
a4946 1
      internal_error (__FILE__, __LINE__, "unknown ABI in switch");
d5165 1
a5165 1
    internal_error (__FILE__, __LINE__, "mips_abi_strings out of sync");
@


1.369
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd, add_setshow_cmd_full)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Replace
	print string parameter with fprint_setshow function.
	* command.h (fprint_setshow_ftype): Define.  Update declarations.
	* cli/cli-setshow.c (do_setshow_command): When fprint_setshow is
	available, use that.
	* cli/cli-decode.h (struct cmd_list_element): Add field
	fprint_setshow.
	* complaints.c (fprint_setshow_complaints): New function.
	(_initialize_complaints): Pass to add_setshow_zinteger_cmd.
	* hppa-tdep.c (_initialize_hppa_tdep): Replace "print" parameter
	with NULL.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* cris-tdep.c (_initialize_cris_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* target.c (initialize_targets): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* breakpoint.c (_initialize_breakpoint): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
@
text
@d639 1
a639 1
      error ("32-bit compatibility mode not supported");
d2248 1
a2248 1
	    warning ("GDB can't find the start of the function at 0x%s.",
d3825 1
a3825 1
    error ("can't read register %d (%s)", regno, REGISTER_NAME (regno));
d3860 1
a3860 1
	error ("can't read register %d (%s)", regno, REGISTER_NAME (regno));
d4060 1
a4060 1
	error ("can't read register %d (%s)", regnum, REGISTER_NAME (regnum));
d4096 1
a4096 1
	error ("Not a valid register for the current processor type");
d4634 1
a4634 1
    warning ("unsupported ABI %s.", name + 8);
@


1.368
log
@2005-02-09  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd): Drop set_result and
	show_result parameters.
	* mips-tdep.c (_initialize_mips_tdep): Update calls.
	* command.h: Update declaration.
	* arm-tdep.c (_initialize_arm_tdep, _initialize_arm_tdep): Update
	calls.
@
text
@d5190 2
a5191 2
          (default: auto)", "\
Size of general purpose registers saved on the stack is %s.\n",
d5203 2
a5204 2
          target and executable (default)", "\
The amount of stack space reserved for each argument is %s.\n",
d5255 2
a5256 2
search.  The only need to set it is when debugging a stripped executable.", "\
The distance searched for the start of a function is %s.\n",
d5266 2
a5267 2
allow GDB to determine the correct value.\n", "\
Zerroing of upper 32 bits of 64-bit address is %s.",
d5278 2
a5279 2
64 bits for others.  Use \"off\" to disable compatibility mode", "\
Compatibility with 64-bit MIPS target that transfers 32-bit quantities is %s.",
d5287 2
a5288 2
When non-zero, mips specific debugging is enabled.\n", "\
Mips debugging is currently %s.\n",
@


1.367
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d5192 1
a5192 2
			NULL, NULL, &setmipscmdlist, &showmipscmdlist,
			NULL, NULL);
d5205 1
a5205 2
			NULL, NULL, &setmipscmdlist, &showmipscmdlist,
			NULL, NULL);
@


1.366
log
@2005-01-27  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (integer_to_address): Change buf parameter to a const
	bfd_byte, make pure-multi-arch.
	* gdbarch.h, gdbarch.c: Regenerate.
	* mips-tdep.c (mips_integer_to_address): Update.
	* value.c (value_as_address): Update.
@
text
@d2458 1
a2458 1
	val = (char *) VALUE_CONTENTS (arg);
d2726 1
a2726 1
      val = (char *) VALUE_CONTENTS (arg);
d3066 1
a3066 1
      val = (char *) VALUE_CONTENTS (arg);
d3520 1
a3520 1
      val = (char *) VALUE_CONTENTS (arg);
@


1.365
log
@2005-01-05  Baurjan Ismagulov  <ibr@@ata.cs.hun.edu.tr>

	Committed by Andrew Cagney.
	* ada-valprint.c, aix-thread.c, alpha-nat.c: I18n markup.
	* alphabsd-nat.c, alphanbsd-tdep.c, amd64-linux-nat.c: I18n markup.
	* amd64-tdep.c,	amd64bsd-nat.c, amd64fbsd-nat.c: I18n markup.
	* arch-utils.c, arm-linux-nat.c, arm-tdep.c: I18n markup.
	* armnbsd-nat.c, armnbsd-tdep.c, auxv.c, avr-tdep.c: I18n markup.
	* aix-thread.c (_initialize_aix_thread): Get rid of the
	deprecated_add_show_from_set call.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* command.h (add_setshow_enum_cmd): Add arguments for returning
	new list elements.
	* cli/cli-decode.c (add_setshow_enum_cmd): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Modify calls to
	add_setshow_enum_cmd.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
d4599 2
a4600 1
mips_integer_to_address (struct type *type, void *buf)
@


1.364
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* sparc-tdep.c: Replace VALUE_TYPE with value_type.
	* v850-tdep.c, sparc64-tdep.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, s390-tdep.c, mcore-tdep.c: Ditto.
	* h8300-tdep.c, arm-linux-tdep.c, amd64-tdep.c: Ditto.
	* hppa-tdep.c, mips-tdep.c, m88k-tdep.c: Ditto.
	* m68hc11-tdep.c, m32r-tdep.c, ia64-tdep.c: Ditto.
	* frv-tdep.c, cris-tdep.c, avr-tdep.c, alpha-tdep.c: Ditto.
@
text
@d5191 2
a5192 1
			NULL, NULL, &setmipscmdlist, &showmipscmdlist);
d5205 2
a5206 1
			NULL, NULL, &setmipscmdlist, &showmipscmdlist);
@


1.363
log
@* mips-tdep.c (mips32_relative_offset): Change return type to
LONGEST, change argument type to ULONGEST.  Fix sign-extension.
@
text
@d2404 1
a2404 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])),
d2435 1
a2435 1
      struct type *arg_type = check_typedef (VALUE_TYPE (arg));
d2687 1
a2687 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])),
d2717 1
a2717 1
      struct type *arg_type = check_typedef (VALUE_TYPE (arg));
d3026 1
a3026 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])),
d3057 1
a3057 1
      struct type *arg_type = check_typedef (VALUE_TYPE (arg));
d3480 1
a3480 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])),
d3511 1
a3511 1
      struct type *arg_type = check_typedef (VALUE_TYPE (arg));
@


1.362
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (mips_in_solib_return_trampoline): Delete.
	(mips_gdbarch_init): Do not set same.
@
text
@d881 2
a882 2
static CORE_ADDR
mips32_relative_offset (unsigned long inst)
d884 1
a884 8
  long x;
  x = itype_immediate (inst);
  if (x & 0x8000)		/* sign bit set */
    {
      x |= 0xffff0000;		/* sign extension */
    }
  x = x << 2;
  return x;
@


1.361
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* armnbsd-tdep.c (arm_netbsd_aout_init_abi)
	(arm_netbsd_aout_in_solib_call_trampoline): Do not set
	in_solib_call_trampoline, delete corresponding unused function.
	* vaxnbsd-tdep.c (vaxnbsd_aout_in_solib_call_trampoline)
	(vaxnbsd_aout_init_abi): Ditto.
	* sparcnbsd-tdep.c (sparcnbsd_aout_in_solib_call_trampoline)
	(sparc32nbsd_aout_init_abi): Ditto.
	* ppc-linux-tdep.c (ppc64_in_solib_call_trampoline)
	(ppc_linux_init_abi): Ditto.
	* ns32knbsd-tdep.c (ns32knbsd_aout_in_solib_call_trampoline)
	(ns32knbsd_init_abi_aout): Ditto.
	* mips-tdep.c (mips_in_call_stub, mips_gdbarch_init): Ditto.
	* mips-linux-tdep.c (mips_linux_init_abi): Ditto.
	* m68kbsd-tdep.c (m68kbsd_aout_in_solib_call_trampoline)
	(m68kbsd_aout_init_abi): Ditto.
	* i386-cygwin-tdep.c (i386_cygwin_in_solib_call_trampoline)
	(i386_cygwin_init_abi): Ditto.
	* i386bsd-tdep.c (i386bsd_aout_in_solib_call_trampoline)
	(i386bsd_init_abi): Ditto.
@
text
@a4539 26
/* Return non-zero if the PC is inside a return thunk (aka stub or
   trampoline).  */

static int
mips_in_solib_return_trampoline (CORE_ADDR pc, char *name)
{
  CORE_ADDR start_addr;

  /* Find the starting address of the function containing the PC.  */
  if (find_pc_partial_function (pc, NULL, &start_addr, NULL) == 0)
    return 0;

  /* If the PC is in __mips16_ret_{d,s}f, this is a return stub.  */
  if (strcmp (name, "__mips16_ret_sf") == 0
      || strcmp (name, "__mips16_ret_df") == 0)
    return 1;

  /* If the PC is in __mips16_call_stub_{s,d}f_{0..10} but not at the start,
     i.e. after the jal instruction, this is effectively a return stub.  */
  if (strncmp (name, "__mips16_call_stub_", 19) == 0
      && (name[19] == 's' || name[19] == 'd') && pc != start_addr)
    return 1;

  return 0;			/* not a stub */
}

a5034 9
  /* NOTE drow/2004-02-11: We overload the core solib trampoline code
     to support MIPS16.  This is a bad thing.  Make sure not to do it
     if we have an OS ABI that actually supports shared libraries, since
     shared library support is more important.  If we have an OS someday
     that supports both shared libraries and MIPS16, we'll have to find
     a better place for these.  */
  if (info.osabi == GDB_OSABI_UNKNOWN)
    set_gdbarch_in_solib_return_trampoline (gdbarch, mips_in_solib_return_trampoline);

@


1.360
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (mips_dump_tdep): Don't print any of the macros.
@
text
@a4539 30

/* Return non-zero if the PC is inside a call thunk (aka stub or trampoline).
   This implements the IN_SOLIB_CALL_TRAMPOLINE macro.  */

static int
mips_in_call_stub (CORE_ADDR pc, char *name)
{
  CORE_ADDR start_addr;

  /* Find the starting address of the function containing the PC.  If the
     caller didn't give us a name, look it up at the same time.  */
  if (find_pc_partial_function (pc, name ? NULL : &name, &start_addr, NULL) ==
      0)
    return 0;

  if (strncmp (name, "__mips16_call_stub_", 19) == 0)
    {
      /* If the PC is in __mips16_call_stub_{1..10}, this is a call stub.  */
      if (name[19] >= '0' && name[19] <= '9')
	return 1;
      /* If the PC at the start of __mips16_call_stub_{s,d}f_{0..10}, i.e.
         before the jal instruction, this is effectively a call stub.  */
      else if (name[19] == 's' || name[19] == 'd')
	return pc == start_addr;
    }

  return 0;			/* not a stub */
}


d5068 1
a5068 4
    {
      set_gdbarch_in_solib_call_trampoline (gdbarch, mips_in_call_stub);
      set_gdbarch_in_solib_return_trampoline (gdbarch, mips_in_solib_return_trampoline);
    }
@


1.359
log
@2004-10-31  Orjan Friberg <organ.friberg@@axis.com>
	    Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (single_step_through_delay): Add.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/mips/tm-mips.h (STEP_SKIPS_DELAY_P, STEP_SKIPS_DELAY)
	(mips_step_skips_delay): Delete.
	* mips-tdep.c (mips_single_step_through_delay): Replace
	mips_step_skips_delay.
	(mips_gdbarch_init): Set single_step_through_delay.
	(mips_dump_tdep): Do not print STEP_SKIPS_DELAY.
@
text
@a5225 117
  fprintf_unfiltered (file,
		      "mips_dump_tdep: ADDR_BITS_REMOVE # %s\n",
		      XSTRING (ADDR_BITS_REMOVE (ADDR)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: ATTACH_DETACH # %s\n",
		      XSTRING (ATTACH_DETACH));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: DWARF_REG_TO_REGNUM # %s\n",
		      XSTRING (DWARF_REG_TO_REGNUM (REGNUM)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: ECOFF_REG_TO_REGNUM # %s\n",
		      XSTRING (ECOFF_REG_TO_REGNUM (REGNUM)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: DEPRECATED_IGNORE_HELPER_CALL # %s\n",
		      XSTRING (DEPRECATED_IGNORE_HELPER_CALL (PC)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: IN_SOLIB_CALL_TRAMPOLINE # %s\n",
		      XSTRING (IN_SOLIB_CALL_TRAMPOLINE (PC, NAME)));
#ifdef MACHINE_CPROC_FP_OFFSET
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MACHINE_CPROC_FP_OFFSET = %d\n",
		      MACHINE_CPROC_FP_OFFSET);
#endif
#ifdef MACHINE_CPROC_PC_OFFSET
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MACHINE_CPROC_PC_OFFSET = %d\n",
		      MACHINE_CPROC_PC_OFFSET);
#endif
#ifdef MACHINE_CPROC_SP_OFFSET
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MACHINE_CPROC_SP_OFFSET = %d\n",
		      MACHINE_CPROC_SP_OFFSET);
#endif
  fprintf_unfiltered (file, "mips_dump_tdep: MIPS_DEFAULT_ABI = FIXME!\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_LAST_ARG_REGNUM = %d (%d regs)\n",
		      MIPS_LAST_ARG_REGNUM,
		      MIPS_LAST_ARG_REGNUM - MIPS_A0_REGNUM + 1);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_NUMREGS = %d\n", MIPS_NUMREGS);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: mips_abi_regsize() = %d\n",
		      mips_abi_regsize (current_gdbarch));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_FRAME_ADJUST = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_FRAME_OFFSET = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_FRAME_REG = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_FREG_MASK = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_FREG_OFFSET = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_HIGH_ADDR = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_LOW_ADDR = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_PC_REG = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_REG_MASK = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_REG_OFFSET = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_SYMBOL = function?\n");
#ifdef SAVED_BYTES
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SAVED_BYTES = %d\n", SAVED_BYTES);
#endif
#ifdef SAVED_FP
  fprintf_unfiltered (file, "mips_dump_tdep: SAVED_FP = %d\n", SAVED_FP);
#endif
#ifdef SAVED_PC
  fprintf_unfiltered (file, "mips_dump_tdep: SAVED_PC = %d\n", SAVED_PC);
#endif
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SETUP_ARBITRARY_FRAME # %s\n",
		      XSTRING (SETUP_ARBITRARY_FRAME (NUMARGS, ARGS)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SOFTWARE_SINGLE_STEP # %s\n",
		      XSTRING (SOFTWARE_SINGLE_STEP (SIG, BP_P)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SOFTWARE_SINGLE_STEP_P () = %d\n",
		      SOFTWARE_SINGLE_STEP_P ());
  fprintf_unfiltered (file,
		      "mips_dump_tdep: STAB_REG_TO_REGNUM # %s\n",
		      XSTRING (STAB_REG_TO_REGNUM (REGNUM)));
#ifdef STACK_END_ADDR
  fprintf_unfiltered (file,
		      "mips_dump_tdep: STACK_END_ADDR = %d\n",
		      STACK_END_ADDR);
#endif
  fprintf_unfiltered (file,
		      "mips_dump_tdep: STEP_SKIPS_DELAY # %s\n",
		      XSTRING (STEP_SKIPS_DELAY (PC)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: STOPPED_BY_WATCHPOINT # %s\n",
		      XSTRING (STOPPED_BY_WATCHPOINT (WS)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TABULAR_REGISTER_OUTPUT = used?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TARGET_CAN_USE_HARDWARE_WATCHPOINT # %s\n",
		      XSTRING (TARGET_CAN_USE_HARDWARE_WATCHPOINT
			       (TYPE, CNT, OTHERTYPE)));
#ifdef TRACE_CLEAR
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TRACE_CLEAR # %s\n",
		      XSTRING (TRACE_CLEAR (THREAD, STATE)));
#endif
#ifdef TRACE_FLAVOR
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TRACE_FLAVOR = %d\n", TRACE_FLAVOR);
#endif
#ifdef TRACE_FLAVOR_SIZE
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TRACE_FLAVOR_SIZE = %d\n",
		      TRACE_FLAVOR_SIZE);
#endif
#ifdef TRACE_SET
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TRACE_SET # %s\n",
		      XSTRING (TRACE_SET (X, STATE)));
#endif
  fprintf_unfiltered (file,
		      "mips_dump_tdep: VM_MIN_ADDRESS = %ld\n",
		      (long) VM_MIN_ADDRESS);
@


1.358
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (mips_ignore_helper): Delete.
	* config/mips/tm-mips.h (DEPRECATED_IGNORE_HELPER_CALL): Delete.
	* infrun.c (handle_inferior_event): Delete #ifdef
	DEPRECATED_IGNORE_HELPER_CALL code.
@
text
@d4145 2
a4146 1
mips_step_skips_delay (CORE_ADDR pc)
d4148 1
d4155 3
a4157 2
  if (target_read_memory (pc, buf, sizeof buf) != 0)
    /* If error reading memory, guess that it is not a delayed branch.  */
d5103 2
a5312 3
		      "mips_dump_tdep: STEP_SKIPS_DELAY_P = %d\n",
		      STEP_SKIPS_DELAY_P);
  fprintf_unfiltered (file,
@


1.357
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (struct frame_extra_info): Delete.
	(temp_proc_desc): Delete.
@
text
@a4592 21

/* Return non-zero if the PC is in a library helper function that
   should be ignored.  This implements the
   DEPRECATED_IGNORE_HELPER_CALL macro.  */

int
mips_ignore_helper (CORE_ADDR pc)
{
  char *name;

  /* Find the starting address and name of the function containing the PC.  */
  if (find_pc_partial_function (pc, &name, NULL, NULL) == 0)
    return 0;

  /* If the PC is in __mips16_ret_{d,s}f, this is a library helper function
     that we want to ignore.  */
  return (strcmp (name, "__mips16_ret_sf") == 0
	  || strcmp (name, "__mips16_ret_df") == 0);
}


@


1.356
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* config/alpha/tm-alpha.h (MDEBUG_EFI_SYMBOL_NAME): Rename
	MIPS_EFI_SYMBOL_NAME.
	(mips_extra_func_info_t, mips_extra_func_info): Delete.
	(struct mdebug_extra_func_info): Replace struct
	alpha_extra_func_info and alpha_extra_func_info_t.
	* config/mips/tm-mips.h (MDEBUG_EFI_SYMBOL_NAME): Rename
	MIPS_EFI_SYMBOL_NAME.
	(struct mdebug_extra_func_info): Replace struct
	alpha_extra_func_info and alpha_extra_func_info_t.
	* objfiles.c, mips-tdep.c, mips-mdebug-tdep.c: Update.
	* mdebugread.c, alpha-mdebug-tdep.c:
@
text
@a88 6
struct frame_extra_info
{
  struct mdebug_extra_func_info *proc_desc;
  int num_args;
};

a2200 2
static struct mdebug_extra_func_info temp_proc_desc;

@


1.355
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.h (MIPS_PRID_REGNUM): Add.
	* config/mips/tm-mips.h (PRID_REGNUM): Delete.
	* mips-tdep.c: Update.
@
text
@d91 1
a91 1
  mips_extra_func_info_t proc_desc;
d2207 1
a2207 1
static struct mips_extra_func_info temp_proc_desc;
a5284 2
		      "mips_dump_tdep: MIPS_EFI_SYMBOL_NAME = multi-arch!!\n");
  fprintf_unfiltered (file,
@


1.354
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.h (MIPS_FIRST_EMBED_REGNUM)
	(MIPS_LAST_EMBED_REGNUM): Add.
	* config/mips/tm-mips.h (FIRST_EMBED_REGNUM)
	(LAST_EMBED_REGNUM): Delete.
	* mipsv4-nat.c, mips-tdep.c, mips-linux-tdep.c: Update.
@
text
@d4323 1
a4323 1
  prid = read_register (PRID_REGNUM);
a5295 2
		      "mips_dump_tdep: PRID_REGNUM = %d\n", PRID_REGNUM);
  fprintf_unfiltered (file,
@


1.353
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* config/mips/tm-mips.h (PS_REGNUM): Delete.
	* mips-tdep.h (MIPS_PS_REGNUM): Add.
	* remote-vxmips.c, mipsv4-nat.c, mips-tdep.c: Update.
	* mips-linux-nat.c: Update.
@
text
@d721 1
a721 1
	  && regnum <= NUM_REGS + LAST_EMBED_REGNUM)
a5262 3
		      "mips_dump_tdep: FIRST_EMBED_REGNUM = %d\n",
		      FIRST_EMBED_REGNUM);
  fprintf_unfiltered (file,
a5267 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: LAST_EMBED_REGNUM = %d\n",
		      LAST_EMBED_REGNUM);
@


1.352
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.h: Add comments on registers.
	(MIPS_UNUSED_REGNUM): Define.
	* config/mips/tm-mips.h (ZERO_REGNUM, UNUSED_REGNUM)
	(T9_REGNUM, V0_REGNUM, A0_REGNUM): Delete.
	* irix5-nat.c, mipsv4-nat.c, mips-linux-tdep.c: Update.
	* mips-linux-nat.c, remote-mips.c: Update.
@
text
@d63 1
a63 1
/* A useful bit in the CP0 status register (PS_REGNUM).  */
d389 1
a389 1
  if ((read_register (PS_REGNUM) & ST0_FR) == 0)
a5315 1
  fprintf_unfiltered (file, "mips_dump_tdep: PS_REGNUM = %d\n", PS_REGNUM);
@


1.351
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* config/mips/tm-mips.h (t_insn): Delete.
	* mips-tdep.c (mips_fetch_instruction, mips_skip_trampoline_code):
	Replace t_insn with ULONGEST.
@
text
@a5377 4
#ifdef UNUSED_REGNUM
  fprintf_unfiltered (file,
		      "mips_dump_tdep: UNUSED_REGNUM = %d\n", UNUSED_REGNUM);
#endif
@


1.350
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* alpha-tdep.c (alpha_setup_arbitrary_frame): Delete.
	* config/alpha/tm-alpha.h (SETUP_ARBITRARY_FRAME): Delete.
	(alpha_setup_arbitrary_frame): Delete.
	* mips-tdep.c (setup_arbitrary_frame): Delete.
	* config/mips/tm-mips.h (SETUP_ARBITRARY_FRAME): Delete.
	(setup_arbitrary_frame): Delete.
	* stack.c (parse_frame_specification_1): When specified, call
	create_new_frame with two parameters.  Delete #ifdef
	SETUP_ARBITRARY_FRAME.
@
text
@d850 1
a850 1
static t_inst
d4509 1
a4509 1
	      t_inst inst;
@


1.349
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* config/mips/tm-mips.h (MIPS16_INSTLEN, MIPS_NUMREGS)
	(MIPS_INSTLEN): Delete.
	* mips-tdep.h (enum mips_insn_size): Rename MIPS32_INSN_SIZE and
	MIPS16_INSN_SIZE to MIPS_INSN32_SIZE and MIPS_INSN16_SIZE.
	* remote-mips.c, mips-tdep.c: Update.
@
text
@a2328 24
/* MIPS stack frames are almost impenetrable.  When execution stops,
   we basically have to look at symbol information for the function
   that we stopped in, which tells us *which* register (if any) is
   the base of the frame pointer, and what offset from that register
   the frame itself is at.

   This presents a problem when trying to examine a stack in memory
   (that isn't executing at the moment), using the "frame" command.  We
   don't have a PC, nor do we have any registers except SP.

   This routine takes two arguments, SP and PC, and tries to make the
   cached frames look as if these two arguments defined a frame on the
   cache.  This allows the rest of info frame to extract the important
   arguments without difficulty.  */

struct frame_info *
setup_arbitrary_frame (int argc, CORE_ADDR *argv)
{
  if (argc != 2)
    error ("MIPS frame specifications require two arguments: sp and pc");

  return create_new_frame (argv[0], argv[1]);
}

@


1.348
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* config/mips/embed.mt (TDEPFILES): Add mips-mdebug-tdep.o.
	* mips-mdebug-tdep.h, mips-mdebug-tdep.c: New files.
	* mips-tdep.c (mips_mdebug_frame_cache)
	(mips_mdebug_frame_this_id, mips_mdebug_frame_prev_register)
	(mips_mdebug_frame_unwind, mips_mdebug_frame_sniffer)
	(mips_mdebug_frame_base_address, mips_mdebug_frame_sniffer)
	(mips_mdebug_frame_base_sniffer, non_heuristic_proc_desc)
	(compare_pdr_entries, the_bfd, mips16_fetch_instruction): Delete.
	(mips_gdbarch_init): Do not append mdebug sniffers.
	(PROC_LOW_ADDR, PROC_HIGH_ADDR, PROC_FRAME_OFFSET)
	(PROC_FRAME_REG, PROC_FRAME_ADJUST, PROC_REG_MASK)
	(PROC_FREG_MASK, PROC_REG_OFFSET, PROC_FREG_OFFSET, PROC_PC_REG)
	(PROC_SYMBOL, _PROC_MAGIC_): Delete.
	* Makefile.in: Update dependencies.
@
text
@d853 1
a853 1
  char buf[MIPS32_INSN_SIZE];
d859 1
a859 1
      instlen = MIPS16_INSN_SIZE;
d863 1
a863 1
    instlen = MIPS32_INSN_SIZE;
d1458 1
a1458 1
  for (cur_pc = start_pc; cur_pc < limit_pc; cur_pc += MIPS16_INSN_SIZE)
d1474 1
a1474 1
          extend_bytes = MIPS16_INSN_SIZE;
d1543 1
a1543 1
	cur_pc += MIPS16_INSN_SIZE;	/* 32-bit instruction */
d1774 1
a1774 1
  for (cur_pc = start_pc; cur_pc < limit_pc; cur_pc += MIPS32_INSN_SIZE)
d1894 1
a1894 1
          load_immediate_bytes += MIPS32_INSN_SIZE;     	/* FIXME!  */
d2249 1
a2249 1
  instlen = mips_pc_is_mips16 (pc) ? MIPS16_INSN_SIZE : MIPS32_INSN_SIZE;
d2316 1
a2316 1
	start_pc += 2 * MIPS32_INSN_SIZE;
d4179 1
a4179 1
  char buf[MIPS32_INSN_SIZE];
d4548 1
a4548 1
	      for (i = 0, pc = 0; i < 20; i++, target_pc += MIPS32_INSN_SIZE)
@


1.347
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.h (mips_abi_regsize): Declare.
	* mips-tdep.c (mips_abi_regsize): Make non-static.
@
text
@a414 4
struct mips_frame_cache;
static mips_extra_func_info_t non_heuristic_proc_desc (CORE_ADDR pc,
						       CORE_ADDR *addrptr);

a626 15
#define PROC_LOW_ADDR(proc) ((proc)->pdr.adr)	/* least address */
#define PROC_HIGH_ADDR(proc) ((proc)->high_addr)	/* upper address bound */
#define PROC_FRAME_OFFSET(proc) ((proc)->pdr.frameoffset)
#define PROC_FRAME_REG(proc) ((proc)->pdr.framereg)
#define PROC_FRAME_ADJUST(proc)  ((proc)->frame_adjust)
#define PROC_REG_MASK(proc) ((proc)->pdr.regmask)
#define PROC_FREG_MASK(proc) ((proc)->pdr.fregmask)
#define PROC_REG_OFFSET(proc) ((proc)->pdr.regoffset)
#define PROC_FREG_OFFSET(proc) ((proc)->pdr.fregoffset)
#define PROC_PC_REG(proc) ((proc)->pdr.pcreg)
/* FIXME drow/2002-06-10: If a pointer on the host is bigger than a long,
   this will corrupt pdr.iline.  Fortunately we don't use it.  */
#define PROC_SYMBOL(proc) (*(struct symbol**)&(proc)->pdr.isym)
#define _PROC_MAGIC_ 0x0F0F0F0F

a869 13
static ULONGEST
mips16_fetch_instruction (CORE_ADDR addr)
{
  char buf[MIPS16_INSN_SIZE];
  int status;

  addr = unmake_mips16_addr (addr);
  status = deprecated_read_memory_nobpt (addr, buf, sizeof (buf));
  if (status)
    memory_error (status, addr);
  return extract_unsigned_integer (buf, sizeof (buf));
}

a1364 232

static struct mips_frame_cache *
mips_mdebug_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  CORE_ADDR startaddr = 0;
  mips_extra_func_info_t proc_desc;
  struct mips_frame_cache *cache;
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  /* r0 bit means kernel trap */
  int kernel_trap;
  /* What registers have been saved?  Bitmasks.  */
  unsigned long gen_mask, float_mask;

  if ((*this_cache) != NULL)
    return (*this_cache);
  cache = FRAME_OBSTACK_ZALLOC (struct mips_frame_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  /* Get the mdebug proc descriptor.  */
  proc_desc = non_heuristic_proc_desc (frame_pc_unwind (next_frame),
				       &startaddr);
  /* Must be true.  This is only called when the sniffer detected a
     proc descriptor.  */
  gdb_assert (proc_desc != NULL);

  /* Extract the frame's base.  */
  cache->base = (frame_unwind_register_signed (next_frame, NUM_REGS + PROC_FRAME_REG (proc_desc))
		 + PROC_FRAME_OFFSET (proc_desc) - PROC_FRAME_ADJUST (proc_desc));

  kernel_trap = PROC_REG_MASK (proc_desc) & 1;
  gen_mask = kernel_trap ? 0xFFFFFFFF : PROC_REG_MASK (proc_desc);
  float_mask = kernel_trap ? 0xFFFFFFFF : PROC_FREG_MASK (proc_desc);
  
  /* Must be true.  The in_prologue case is left for the heuristic
     unwinder.  This is always used on kernel traps.  */
  gdb_assert (!in_prologue (frame_pc_unwind (next_frame), PROC_LOW_ADDR (proc_desc))
	      || kernel_trap);

  /* Fill in the offsets for the registers which gen_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (cache->base + PROC_REG_OFFSET (proc_desc));
    int ireg;

    for (ireg = MIPS_NUMREGS - 1; gen_mask; --ireg, gen_mask <<= 1)
      if (gen_mask & 0x80000000)
	{
	  cache->saved_regs[NUM_REGS + ireg].addr = reg_position;
	  reg_position -= mips_abi_regsize (gdbarch);
	}
  }

  /* The MIPS16 entry instruction saves $s0 and $s1 in the reverse
     order of that normally used by gcc.  Therefore, we have to fetch
     the first instruction of the function, and if it's an entry
     instruction that saves $s0 or $s1, correct their saved addresses.  */
  if (mips_pc_is_mips16 (PROC_LOW_ADDR (proc_desc)))
    {
      ULONGEST inst = mips16_fetch_instruction (PROC_LOW_ADDR (proc_desc));
      if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)
	/* entry */
	{
	  int reg;
	  int sreg_count = (inst >> 6) & 3;

	  /* Check if the ra register was pushed on the stack.  */
	  CORE_ADDR reg_position = (cache->base
				    + PROC_REG_OFFSET (proc_desc));
	  if (inst & 0x20)
	    reg_position -= mips_abi_regsize (gdbarch);

	  /* Check if the s0 and s1 registers were pushed on the
	     stack.  */
	  /* NOTE: cagney/2004-02-08: Huh?  This is doing no such
             check.  */
	  for (reg = 16; reg < sreg_count + 16; reg++)
	    {
	      cache->saved_regs[NUM_REGS + reg].addr = reg_position;
	      reg_position -= mips_abi_regsize (gdbarch);
	    }
	}
    }

  /* Fill in the offsets for the registers which float_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (cache->base
			      + PROC_FREG_OFFSET (proc_desc));
    int ireg;
    /* Fill in the offsets for the float registers which float_mask
       says were saved.  */
    for (ireg = MIPS_NUMREGS - 1; float_mask; --ireg, float_mask <<= 1)
      if (float_mask & 0x80000000)
	{
	  if (mips_abi_regsize (gdbarch) == 4
	      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    {
	      /* On a big endian 32 bit ABI, floating point registers
	         are paired to form doubles such that the most
	         significant part is in $f[N+1] and the least
	         significant in $f[N] vis: $f[N+1] ||| $f[N].  The
	         registers are also spilled as a pair and stored as a
	         double.

	         When little-endian the least significant part is
	         stored first leading to the memory order $f[N] and
	         then $f[N+1].

	         Unfortunately, when big-endian the most significant
	         part of the double is stored first, and the least
	         significant is stored second.  This leads to the
	         registers being ordered in memory as firt $f[N+1] and
	         then $f[N].

	         For the big-endian case make certain that the
	         addresses point at the correct (swapped) locations
	         $f[N] and $f[N+1] pair (keep in mind that
	         reg_position is decremented each time through the
	         loop).  */
	      if ((ireg & 1))
		cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
		  .addr = reg_position - mips_abi_regsize (gdbarch);
	      else
		cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
		  .addr = reg_position + mips_abi_regsize (gdbarch);
	    }
	  else
	    cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
	      .addr = reg_position;
	  reg_position -= mips_abi_regsize (gdbarch);
	}

    cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->pc]
      = cache->saved_regs[NUM_REGS + MIPS_RA_REGNUM];
  }

  /* SP_REGNUM, contains the value and not the address.  */
  trad_frame_set_value (cache->saved_regs, NUM_REGS + MIPS_SP_REGNUM, cache->base);

  return (*this_cache);
}

static void
mips_mdebug_frame_this_id (struct frame_info *next_frame, void **this_cache,
			   struct frame_id *this_id)
{
  struct mips_frame_cache *info = mips_mdebug_frame_cache (next_frame,
							   this_cache);
  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
}

static void
mips_mdebug_frame_prev_register (struct frame_info *next_frame,
				 void **this_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *valuep)
{
  struct mips_frame_cache *info = mips_mdebug_frame_cache (next_frame,
							   this_cache);
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind mips_mdebug_frame_unwind =
{
  NORMAL_FRAME,
  mips_mdebug_frame_this_id,
  mips_mdebug_frame_prev_register
};

static const struct frame_unwind *
mips_mdebug_frame_sniffer (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  CORE_ADDR startaddr = 0;
  mips_extra_func_info_t proc_desc;
  int kernel_trap;

  /* Only use the mdebug frame unwinder on mdebug frames where all the
     registers have been saved.  Leave hard cases such as no mdebug or
     in prologue for the heuristic unwinders.  */

  proc_desc = non_heuristic_proc_desc (pc, &startaddr);
  if (proc_desc == NULL)
    return NULL;

  /* Not sure exactly what kernel_trap means, but if it means the
     kernel saves the registers without a prologue doing it, we better
     not examine the prologue to see whether registers have been saved
     yet.  */
  kernel_trap = PROC_REG_MASK (proc_desc) & 1;
  if (kernel_trap)
    return &mips_mdebug_frame_unwind;

  /* In any frame other than the innermost or a frame interrupted by a
     signal, we assume that all registers have been saved.  This
     assumes that all register saves in a function happen before the
     first function call.  */
  if (!in_prologue (pc, PROC_LOW_ADDR (proc_desc)))
    return &mips_mdebug_frame_unwind;

  return NULL;
}

static CORE_ADDR
mips_mdebug_frame_base_address (struct frame_info *next_frame,
				void **this_cache)
{
  struct mips_frame_cache *info = mips_mdebug_frame_cache (next_frame,
							   this_cache);
  return info->base;
}

static const struct frame_base mips_mdebug_frame_base = {
  &mips_mdebug_frame_unwind,
  mips_mdebug_frame_base_address,
  mips_mdebug_frame_base_address,
  mips_mdebug_frame_base_address
};

static const struct frame_base *
mips_mdebug_frame_base_sniffer (struct frame_info *next_frame)
{
  if (mips_mdebug_frame_sniffer (next_frame) != NULL)
    return &mips_mdebug_frame_base;
  else
    return NULL;
}

a2328 208
/* Global used to communicate between non_heuristic_proc_desc and
   compare_pdr_entries within qsort ().  */
static bfd *the_bfd;

static int
compare_pdr_entries (const void *a, const void *b)
{
  CORE_ADDR lhs = bfd_get_32 (the_bfd, (bfd_byte *) a);
  CORE_ADDR rhs = bfd_get_32 (the_bfd, (bfd_byte *) b);

  if (lhs < rhs)
    return -1;
  else if (lhs == rhs)
    return 0;
  else
    return 1;
}

static mips_extra_func_info_t
non_heuristic_proc_desc (CORE_ADDR pc, CORE_ADDR *addrptr)
{
  CORE_ADDR startaddr;
  mips_extra_func_info_t proc_desc;
  struct block *b = block_for_pc (pc);
  struct symbol *sym;
  struct obj_section *sec;
  struct mips_objfile_private *priv;

  find_pc_partial_function (pc, NULL, &startaddr, NULL);
  if (addrptr)
    *addrptr = startaddr;

  priv = NULL;

  sec = find_pc_section (pc);
  if (sec != NULL)
    {
      priv = (struct mips_objfile_private *) objfile_data (sec->objfile, mips_pdr_data);

      /* Search the ".pdr" section generated by GAS.  This includes most of
         the information normally found in ECOFF PDRs.  */

      the_bfd = sec->objfile->obfd;
      if (priv == NULL
	  && (the_bfd->format == bfd_object
	      && bfd_get_flavour (the_bfd) == bfd_target_elf_flavour
	      && elf_elfheader (the_bfd)->e_ident[EI_CLASS] == ELFCLASS64))
	{
	  /* Right now GAS only outputs the address as a four-byte sequence.
	     This means that we should not bother with this method on 64-bit
	     targets (until that is fixed).  */

	  priv = obstack_alloc (&sec->objfile->objfile_obstack,
				sizeof (struct mips_objfile_private));
	  priv->size = 0;
	  set_objfile_data (sec->objfile, mips_pdr_data, priv);
	}
      else if (priv == NULL)
	{
	  asection *bfdsec;

	  priv = obstack_alloc (&sec->objfile->objfile_obstack,
				sizeof (struct mips_objfile_private));

	  bfdsec = bfd_get_section_by_name (sec->objfile->obfd, ".pdr");
	  if (bfdsec != NULL)
	    {
	      priv->size = bfd_section_size (sec->objfile->obfd, bfdsec);
	      priv->contents = obstack_alloc (&sec->objfile->objfile_obstack,
					      priv->size);
	      bfd_get_section_contents (sec->objfile->obfd, bfdsec,
					priv->contents, 0, priv->size);

	      /* In general, the .pdr section is sorted.  However, in the
	         presence of multiple code sections (and other corner cases)
	         it can become unsorted.  Sort it so that we can use a faster
	         binary search.  */
	      qsort (priv->contents, priv->size / 32, 32,
		     compare_pdr_entries);
	    }
	  else
	    priv->size = 0;

	  set_objfile_data (sec->objfile, mips_pdr_data, priv);
	}
      the_bfd = NULL;

      if (priv->size != 0)
	{
	  int low, mid, high;
	  char *ptr;
	  CORE_ADDR pdr_pc;

	  low = 0;
	  high = priv->size / 32;

	  /* We've found a .pdr section describing this objfile.  We want to
	     find the entry which describes this code address.  The .pdr
	     information is not very descriptive; we have only a function
	     start address.  We have to look for the closest entry, because
	     the local symbol at the beginning of this function may have
	     been stripped - so if we ask the symbol table for the start
	     address we may get a preceding global function.  */

	  /* First, find the last .pdr entry starting at or before PC.  */
	  do
	    {
	      mid = (low + high) / 2;

	      ptr = priv->contents + mid * 32;
	      pdr_pc = bfd_get_signed_32 (sec->objfile->obfd, ptr);
	      pdr_pc += ANOFFSET (sec->objfile->section_offsets,
				  SECT_OFF_TEXT (sec->objfile));

	      if (pdr_pc > pc)
		high = mid;
	      else
		low = mid + 1;
	    }
	  while (low != high);

	  /* Both low and high point one past the PDR of interest.  If
	     both are zero, that means this PC is before any region
	     covered by a PDR, i.e. pdr_pc for the first PDR entry is
	     greater than PC.  */
	  if (low > 0)
	    {
	      ptr = priv->contents + (low - 1) * 32;
	      pdr_pc = bfd_get_signed_32 (sec->objfile->obfd, ptr);
	      pdr_pc += ANOFFSET (sec->objfile->section_offsets,
				  SECT_OFF_TEXT (sec->objfile));
	    }

	  /* We don't have a range, so we have no way to know for sure
	     whether we're in the correct PDR or a PDR for a preceding
	     function and the current function was a stripped local
	     symbol.  But if the PDR's PC is at least as great as the
	     best guess from the symbol table, assume that it does cover
	     the right area; if a .pdr section is present at all then
	     nearly every function will have an entry.  The biggest exception
	     will be the dynamic linker stubs; conveniently these are
	     placed before .text instead of after.  */

	  if (pc >= pdr_pc && pdr_pc >= startaddr)
	    {
	      struct symbol *sym = find_pc_function (pc);

	      if (addrptr)
		*addrptr = pdr_pc;

	      /* Fill in what we need of the proc_desc.  */
	      proc_desc = (mips_extra_func_info_t)
		obstack_alloc (&sec->objfile->objfile_obstack,
			       sizeof (struct mips_extra_func_info));
	      PROC_LOW_ADDR (proc_desc) = pdr_pc;

	      /* Only used for dummy frames.  */
	      PROC_HIGH_ADDR (proc_desc) = 0;

	      PROC_FRAME_OFFSET (proc_desc)
		= bfd_get_32 (sec->objfile->obfd, ptr + 20);
	      PROC_FRAME_REG (proc_desc) = bfd_get_32 (sec->objfile->obfd,
						       ptr + 24);
	      PROC_FRAME_ADJUST (proc_desc) = 0;
	      PROC_REG_MASK (proc_desc) = bfd_get_32 (sec->objfile->obfd,
						      ptr + 4);
	      PROC_FREG_MASK (proc_desc) = bfd_get_32 (sec->objfile->obfd,
						       ptr + 12);
	      PROC_REG_OFFSET (proc_desc) = bfd_get_32 (sec->objfile->obfd,
							ptr + 8);
	      PROC_FREG_OFFSET (proc_desc)
		= bfd_get_32 (sec->objfile->obfd, ptr + 16);
	      PROC_PC_REG (proc_desc) = bfd_get_32 (sec->objfile->obfd,
						    ptr + 28);
	      proc_desc->pdr.isym = (long) sym;

	      return proc_desc;
	    }
	}
    }

  if (b == NULL)
    return NULL;

  if (startaddr > BLOCK_START (b))
    {
      /* This is the "pathological" case referred to in a comment in
         print_frame_info.  It might be better to move this check into
         symbol reading.  */
      return NULL;
    }

  sym = lookup_symbol (MIPS_EFI_SYMBOL_NAME, b, LABEL_DOMAIN, 0, NULL);

  /* If we never found a PDR for this function in symbol reading, then
     examine prologues to find the information.  */
  if (sym)
    {
      proc_desc = (mips_extra_func_info_t) SYMBOL_VALUE (sym);
      if (PROC_FRAME_REG (proc_desc) == -1)
	return NULL;
      else
	return proc_desc;
    }
  else
    return NULL;
}

a5157 1
  frame_unwind_append_sniffer (gdbarch, mips_mdebug_frame_sniffer);
a5160 1
  frame_base_append_sniffer (gdbarch, mips_mdebug_frame_base_sniffer);
@


1.346
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (gdb_print_insn_mips): Simplify.
	(make_mips16_addr): Delete.
@
text
@d262 1
a262 1
static unsigned int
@


1.345
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	Total breakage identified by Joel Brobecker.
	* mips-tdep.c (after_prologue): Delete.
	(mips_skip_prologue): Use skip_prologue_using_sal.
	(heuristic_proc_desc): Delete, unused.
@
text
@a208 6
make_mips16_addr (CORE_ADDR addr)
{
  return ((addr) | 1);
}

static CORE_ADDR
a4838 1
  mips_extra_func_info_t proc_desc;
a4839 12
  /* Search for the function containing this address.  Set the low bit
     of the address when searching, in case we were given an even address
     that is the start of a 16-bit function.  If we didn't do this,
     the search would fail because the symbol table says the function
     starts at an odd address, i.e. 1 byte past the given address.  */
  memaddr = ADDR_BITS_REMOVE (memaddr);
  proc_desc = non_heuristic_proc_desc (make_mips16_addr (memaddr), NULL);

  /* Make an attempt to determine if this is a 16-bit function.  If
     the procedure descriptor exists and the address therein is odd,
     it's definitely a 16-bit function.  Otherwise, we have to just
     guess that if the address passed in is odd, it's 16-bits.  */
d4844 2
a4845 10
  if (proc_desc)
    {
      if (mips_pc_is_mips16 (PROC_LOW_ADDR (proc_desc)))
	info->mach = bfd_mach_mips16;
    }
  else
    {
      if (mips_pc_is_mips16 (memaddr))
	info->mach = bfd_mach_mips16;
    }
@


1.344
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.h (mips_pc_is_mips16): Declare.
	* mips-tdep.c (mips_pc_is_mips16): Rename pc_is_mips16, make
	non-static.  Update calls.
@
text
@a421 3
static mips_extra_func_info_t heuristic_proc_desc (CORE_ADDR, CORE_ADDR,
						   struct frame_info *,
						   struct mips_frame_cache *);
a430 2
static CORE_ADDR after_prologue (CORE_ADDR pc);

a871 70
/* This returns the PC of the first inst after the prologue.  If we can't
   find the prologue, then return 0.  */

static CORE_ADDR
after_prologue (CORE_ADDR pc)
{
  mips_extra_func_info_t proc_desc;
  struct symtab_and_line sal;
  CORE_ADDR func_addr, func_end;
  CORE_ADDR startaddr = 0;

  /* Pass a NULL next_frame to heuristic_proc_desc.  We should not
     attempt to read the stack pointer from the current machine state,
     because the current machine state has nothing to do with the
     information we need from the proc_desc; and the process may or
     may not exist right now.  */
  proc_desc = non_heuristic_proc_desc (pc, &startaddr);
  if (proc_desc)
    {
      /* IF this is the topmost frame AND (this proc does not have
	 debugging information OR the PC is in the procedure prologue)
	 THEN create a "heuristic" proc_desc (by analyzing the actual
	 code) to replace the "official" proc_desc.  */
      struct symtab_and_line val;
      if (PROC_SYMBOL (proc_desc))
	{
	  val = find_pc_line (BLOCK_START
			      (SYMBOL_BLOCK_VALUE (PROC_SYMBOL (proc_desc))),
			      0);
	  val.pc = val.end ? val.end : pc;
	}
      if (!PROC_SYMBOL (proc_desc) || pc < val.pc)
	{
	  mips_extra_func_info_t found_heuristic =
	    heuristic_proc_desc (PROC_LOW_ADDR (proc_desc), pc, NULL, NULL);
	  if (found_heuristic)
	    proc_desc = found_heuristic;
	}
    }
  else
    {
      if (startaddr == 0)
	startaddr = heuristic_proc_start (pc);

      proc_desc = heuristic_proc_desc (startaddr, pc, NULL, NULL);
    }

  if (proc_desc)
    {
      /* If function is frameless, then we need to do it the hard way.  I
         strongly suspect that frameless always means prologueless... */
      if (PROC_FRAME_REG (proc_desc) == MIPS_SP_REGNUM
	  && PROC_FRAME_OFFSET (proc_desc) == 0)
	return 0;
    }

  if (!find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    return 0;			/* Unknown */

  sal = find_pc_line (func_addr, 0);

  if (sal.end < func_end)
    return sal.end;

  /* The line after the prologue is after the end of the function.  In this
     case, tell the caller to find the prologue the hard way.  */

  return 0;
}

a2592 21
static mips_extra_func_info_t
heuristic_proc_desc (CORE_ADDR start_pc, CORE_ADDR limit_pc,
		     struct frame_info *next_frame,
		     struct mips_frame_cache *this_cache)
{
  if (start_pc == 0)
    return NULL;

  memset (&temp_proc_desc, '\0', sizeof (temp_proc_desc));
  PROC_LOW_ADDR (&temp_proc_desc) = start_pc;
  PROC_FRAME_REG (&temp_proc_desc) = MIPS_SP_REGNUM;
  PROC_PC_REG (&temp_proc_desc) = MIPS_RA_REGNUM;

  if (mips_pc_is_mips16 (start_pc))
    mips16_scan_prologue (start_pc, limit_pc, next_frame, this_cache);
  else
    mips32_scan_prologue (start_pc, limit_pc, next_frame, this_cache);

  return &temp_proc_desc;
}

d4681 3
d4687 6
a4692 6

  CORE_ADDR post_prologue_pc = after_prologue (pc);
  CORE_ADDR limit_pc;

  if (post_prologue_pc != 0)
    return max (pc, post_prologue_pc);
@


1.343
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd): New function.
	* command.h (add_setshow_enum_cmd): Declare.
	* mips-tdep.c (_initialize_mips_tdep): Use add_setshow_enum_cmd.
@
text
@d824 2
a825 2
static int
pc_is_mips16 (bfd_vma memaddr)
d957 1
a957 1
  if (pc_is_mips16 (addr))
d1536 1
a1536 1
  if (pc_is_mips16 (PROC_LOW_ADDR (proc_desc)))
d2036 1
a2036 1
  if (pc_is_mips16 (pc))
d2356 1
a2356 1
  if (! pc_is_mips16 (pc))
d2560 1
a2560 1
  if (pc_is_mips16 (pc))
d2594 1
a2594 1
  instlen = pc_is_mips16 (pc) ? MIPS16_INSN_SIZE : MIPS32_INSN_SIZE;
d2636 1
a2636 1
    else if (pc_is_mips16 (start_pc))
d2681 1
a2681 1
  if (pc_is_mips16 (start_pc))
d4756 1
a4756 1
  if (pc_is_mips16 (pc))
d4797 1
a4797 1
  if (pc_is_mips16 (pc))
d4958 1
a4958 1
      if (pc_is_mips16 (PROC_LOW_ADDR (proc_desc)))
d4963 1
a4963 1
      if (pc_is_mips16 (memaddr))
d5008 1
a5008 1
      if (pc_is_mips16 (*pcptr))
d5038 1
a5038 1
      if (pc_is_mips16 (*pcptr))
@


1.342
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (_initialize_mips_tdep): Use
	add_setshow_zinteger_cmd.
@
text
@d6032 4
a6035 5
  deprecated_add_show_from_set (add_set_enum_cmd ("saved-gpreg-size",
						  class_obscure,
						  size_enums,
						  &mips_abi_regsize_string, "\
Set size of general purpose registers saved on the stack.\n\
d6041 3
a6043 1
          (default: auto)", &setmipscmdlist), &showmipscmdlist);
d6046 4
a6049 6
  deprecated_add_show_from_set
    (add_set_enum_cmd ("stack-arg-size",
		       class_obscure,
		       size_enums,
		       &mips_stack_argsize_string, "\
Set the amount of stack space reserved for each argument.\n\
d6054 3
a6056 2
          target and executable (default)", &setmipscmdlist),
     &showmipscmdlist);
@


1.341
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (mips_eabi_extract_return_value)
	(mips_o64_extract_return_value, mips_o64_store_return_value)
	(return_value_location, mips_eabi_reg_struct_has_addr)
	(mips_eabi_use_struct_convention)
	(mips_eabi_store_return_value): Delete.
	(mips_eabi_store_return_value): New function.
	(mips_eabi_return_value): New function.
	(mips_gdbarch_init): For O64 and EABI, delete
	extract_return_value, store_return_value, use_struct_convention
	and reg_struct_has_addr, add return_value.
@
text
@d6100 4
a6103 3
  c = add_set_cmd ("heuristic-fence-post", class_support, var_zinteger,
		   (char *) &heuristic_fence_post, "\
Set the distance searched for the start of a function.\n\
d6106 4
a6109 5
search.  The only need to set it is when debugging a stripped executable.", &setlist);
  /* We need to throw away the frame cache when we set this, since it
     might change our ability to get backtraces.  */
  set_cmd_sfunc (c, reinit_frame_cache_sfunc);
  deprecated_add_show_from_set (c, &showlist);
d6134 8
a6141 5
  deprecated_add_show_from_set
    (add_set_cmd ("mips", class_maintenance, var_zinteger,
		  &mips_debug, "Set mips debugging.\n\
When non-zero, mips specific debugging is enabled.", &setdebuglist),
     &showdebuglist);
@


1.340
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (read_signed_register): Use
	regcache_cooked_read_signed.
@
text
@a2981 139
/* Determine how a return value is stored within the MIPS register
   file, given the return type `valtype'. */

struct return_value_word
{
  int len;
  int reg;
  int reg_offset;
  int buf_offset;
};

static void
return_value_location (struct type *valtype,
		       struct return_value_word *hi,
		       struct return_value_word *lo)
{
  int len = TYPE_LENGTH (valtype);
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (TYPE_CODE (valtype) == TYPE_CODE_FLT
      && ((MIPS_FPU_TYPE == MIPS_FPU_DOUBLE && (len == 4 || len == 8))
	  || (MIPS_FPU_TYPE == MIPS_FPU_SINGLE && len == 4)))
    {
      if (mips_abi_regsize (current_gdbarch) < 8 && len == 8)
	{
	  /* We need to break a 64bit float in two 32 bit halves and
	     spread them across a floating-point register pair.  */
	  lo->buf_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 4 : 0;
	  hi->buf_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 0 : 4;
	  lo->reg_offset = ((TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
			     && register_size (current_gdbarch,
					       mips_regnum (current_gdbarch)->
					       fp0) == 8) ? 4 : 0);
	  hi->reg_offset = lo->reg_offset;
	  lo->reg = mips_regnum (current_gdbarch)->fp0 + 0;
	  hi->reg = mips_regnum (current_gdbarch)->fp0 + 1;
	  lo->len = 4;
	  hi->len = 4;
	}
      else
	{
	  /* The floating point value fits in a single floating-point
	     register. */
	  lo->reg_offset = ((TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
			     && register_size (current_gdbarch,
					       mips_regnum (current_gdbarch)->
					       fp0) == 8
			     && len == 4) ? 4 : 0);
	  lo->reg = mips_regnum (current_gdbarch)->fp0;
	  lo->len = len;
	  lo->buf_offset = 0;
	  hi->len = 0;
	  hi->reg_offset = 0;
	  hi->buf_offset = 0;
	  hi->reg = 0;
	}
    }
  else
    {
      /* Locate a result possibly spread across two registers. */
      int regnum = 2;
      lo->reg = regnum + 0;
      hi->reg = regnum + 1;
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && len < mips_abi_regsize (current_gdbarch))
	{
	  /* "un-left-justify" the value in the low register */
	  lo->reg_offset = mips_abi_regsize (current_gdbarch) - len;
	  lo->len = len;
	  hi->reg_offset = 0;
	  hi->len = 0;
	}
      else if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG && len > mips_abi_regsize (current_gdbarch)	/* odd-size structs */
	       && len < mips_abi_regsize (current_gdbarch) * 2
	       && (TYPE_CODE (valtype) == TYPE_CODE_STRUCT ||
		   TYPE_CODE (valtype) == TYPE_CODE_UNION))
	{
	  /* "un-left-justify" the value spread across two registers. */
	  lo->reg_offset = 2 * mips_abi_regsize (current_gdbarch) - len;
	  lo->len = mips_abi_regsize (current_gdbarch) - lo->reg_offset;
	  hi->reg_offset = 0;
	  hi->len = len - lo->len;
	}
      else
	{
	  /* Only perform a partial copy of the second register. */
	  lo->reg_offset = 0;
	  hi->reg_offset = 0;
	  if (len > mips_abi_regsize (current_gdbarch))
	    {
	      lo->len = mips_abi_regsize (current_gdbarch);
	      hi->len = len - mips_abi_regsize (current_gdbarch);
	    }
	  else
	    {
	      lo->len = len;
	      hi->len = 0;
	    }
	}
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && register_size (current_gdbarch, regnum) == 8
	  && mips_abi_regsize (current_gdbarch) == 4)
	{
	  /* Account for the fact that only the least-signficant part
	     of the register is being used */
	  lo->reg_offset += 4;
	  hi->reg_offset += 4;
	}
      lo->buf_offset = 0;
      hi->buf_offset = lo->len;
    }
}

/* Should call_function allocate stack space for a struct return?  */

static int
mips_eabi_use_struct_convention (int gcc_p, struct type *type)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  return (TYPE_LENGTH (type) > 2 * mips_abi_regsize (current_gdbarch));
}

/* Should call_function pass struct by reference? 
   For each architecture, structs are passed either by
   value or by reference, depending on their size.  */

static int
mips_eabi_reg_struct_has_addr (int gcc_p, struct type *type)
{
  enum type_code typecode = TYPE_CODE (check_typedef (type));
  int len = TYPE_LENGTH (check_typedef (type));
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION)
    return (len > mips_abi_regsize (current_gdbarch));

  return 0;
}

d3250 1
a3250 2
/* Given a return value in `regbuf' with a type `valtype', extract and
   copy its value into `valbuf'. */
d3252 4
a3255 3
static void
mips_eabi_extract_return_value (struct type *valtype,
				char regbuf[], char *valbuf)
d3257 5
a3261 12
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memcpy (valbuf + lo.buf_offset,
	  regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + lo.reg) +
	  lo.reg_offset, lo.len);

  if (hi.len > 0)
    memcpy (valbuf + hi.buf_offset,
	    regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + hi.reg) +
	    hi.reg_offset, hi.len);
a3263 27
/* Given a return value in `valbuf' with a type `valtype', write it's
   value into the appropriate register. */

static void
mips_eabi_store_return_value (struct type *valtype, char *valbuf)
{
  char raw_buffer[MAX_REGISTER_SIZE];
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memset (raw_buffer, 0, sizeof (raw_buffer));
  memcpy (raw_buffer + lo.reg_offset, valbuf + lo.buf_offset, lo.len);
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (lo.reg),
				   raw_buffer, register_size (current_gdbarch,
							      lo.reg));

  if (hi.len > 0)
    {
      memset (raw_buffer, 0, sizeof (raw_buffer));
      memcpy (raw_buffer + hi.reg_offset, valbuf + hi.buf_offset, hi.len);
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (hi.reg),
				       raw_buffer,
				       register_size (current_gdbarch,
						      hi.reg));
    }
}
d4371 4
a4374 3
static void
mips_o64_extract_return_value (struct type *valtype,
			       char regbuf[], char *valbuf)
d4376 1
a4376 37
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memcpy (valbuf + lo.buf_offset,
	  regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + lo.reg) +
	  lo.reg_offset, lo.len);

  if (hi.len > 0)
    memcpy (valbuf + hi.buf_offset,
	    regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + hi.reg) +
	    hi.reg_offset, hi.len);
}

static void
mips_o64_store_return_value (struct type *valtype, char *valbuf)
{
  char raw_buffer[MAX_REGISTER_SIZE];
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memset (raw_buffer, 0, sizeof (raw_buffer));
  memcpy (raw_buffer + lo.reg_offset, valbuf + lo.buf_offset, lo.len);
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (lo.reg),
				   raw_buffer, register_size (current_gdbarch,
							      lo.reg));

  if (hi.len > 0)
    {
      memset (raw_buffer, 0, sizeof (raw_buffer));
      memcpy (raw_buffer + hi.reg_offset, valbuf + hi.buf_offset, hi.len);
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (hi.reg),
				       raw_buffer,
				       register_size (current_gdbarch,
						      hi.reg));
    }
d5595 1
a5595 4
      set_gdbarch_deprecated_store_return_value (gdbarch,
						 mips_o64_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch,
						   mips_o64_extract_return_value);
a5601 1
      set_gdbarch_deprecated_use_struct_convention (gdbarch, always_use_struct_convention);
d5605 1
a5605 4
      set_gdbarch_deprecated_store_return_value (gdbarch,
						 mips_eabi_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch,
						   mips_eabi_extract_return_value);
a5611 3
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_eabi_reg_struct_has_addr);
      set_gdbarch_deprecated_use_struct_convention (gdbarch, mips_eabi_use_struct_convention);
d5615 1
a5615 4
      set_gdbarch_deprecated_store_return_value (gdbarch,
						 mips_eabi_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch,
						   mips_eabi_extract_return_value);
a5621 3
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_eabi_reg_struct_has_addr);
      set_gdbarch_deprecated_use_struct_convention (gdbarch, mips_eabi_use_struct_convention);
@


1.339
log
@* mips-tdep.c (mips_fetch_instruction, mips16_fetch_instruction)
(mips_mdebug_frame_cache, mips16_scan_prologue)
(mips32_scan_prologue, mips_stub_frame_cache)
(heuristic_proc_start, heuristic_proc_desc)
(mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
(mips_n32n64_return_value, mips_o32_push_dummy_call)
(mips_o32_return_value, mips_o64_push_dummy_call)
(mips_step_skips_delay, mips_skip_trampoline_code)
(mips_gdbarch_init): Use MIPS_A0_REGNUM instead of A0_REGNUM,
MIPS_RA_REGNUM instead of RA_REGNUM, MIPS_T9_REGNUM instead of
T9_REGNUM, MIPS_V0_REGNUM instead of V0_REGNUM, MIPS_ZERO_REGNUM
instead of ZERO_REGNUM, MIPS32_SIZE_INSN instead of MIPS_INSTLEN
and MIPS16_INSN_SIZE instead of MIPS16_INSTLEN.
(mips_dump_tdep): Don't print A0_REGNUM, RA_REGNUM,
T9_REGNUM, V0_REGNUM, ZERO_REGNUM, MIPS_INSTLEN and
MIPS16_INSTLEN.  Use MIPS_A0_REGNUM instead of A0_REGNUM.
* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
(mips_linux_n32n64_sigframe_init): Use MIPS_ZERO_REGNUM instead of
ZERO_REGNUM.
* mipsnbsd-tdep.c (mipsnbsd_cannot_fetch_register)
(mipsnbsd_cannot_store_register): Use MIPS_ZERO_REGNUM instead of
ZERO_REGNUM.
(mipsnbsd_get_longjmp_target): Use MIPS_A0_REGNUM instead of
A0_REGNUM.
* mipsnbsd-nat.c: Include "mips-tdep.h".
(getregs_supplies): Use MIPS_ZERO_REGNUM instead of ZERO_REGNUM.
* Makefile.in (mipsnbsd-nat.o): Update dependencies.
@
text
@d225 3
a227 4
  void *buf = alloca (register_size (current_gdbarch, regnum));
  deprecated_read_register_gen (regnum, buf);
  return (extract_signed_integer
	  (buf, register_size (current_gdbarch, regnum)));
@


1.338
log
@* mips-tdep.c (id_delayed): Remove prototype.
@
text
@d954 1
a954 1
  char buf[MIPS_INSTLEN];
d960 1
a960 1
      instlen = MIPS16_INSTLEN;
d964 1
a964 1
    instlen = MIPS_INSTLEN;
d974 1
a974 2
  char buf[MIPS_INSTLEN];
  int instlen;
a976 1
  instlen = MIPS16_INSTLEN;
d978 1
a978 1
  status = deprecated_read_memory_nobpt (addr, buf, instlen);
d981 1
a981 1
  return extract_unsigned_integer (buf, instlen);
d1614 1
a1614 1
      = cache->saved_regs[NUM_REGS + RA_REGNUM];
d1804 1
a1804 1
  for (cur_pc = start_pc; cur_pc < limit_pc; cur_pc += MIPS16_INSTLEN)
d1820 1
a1820 1
          extend_bytes = MIPS16_INSTLEN;
d1854 1
a1854 1
	  set_reg_offset (this_cache, RA_REGNUM, sp + offset);
d1859 1
a1859 1
	  set_reg_offset (this_cache, RA_REGNUM, sp + offset);
d1889 1
a1889 1
	cur_pc += MIPS16_INSTLEN;	/* 32-bit instruction */
d1934 1
a1934 1
	  set_reg_offset (this_cache, RA_REGNUM, sp + offset);
d1955 1
a1955 1
        = this_cache->saved_regs[NUM_REGS + RA_REGNUM];
d2120 1
a2120 1
  for (cur_pc = start_pc; cur_pc < limit_pc; cur_pc += MIPS_INSTLEN)
d2240 1
a2240 1
          load_immediate_bytes += MIPS_INSTLEN;     /* FIXME!! */
d2264 1
a2264 1
        = this_cache->saved_regs[NUM_REGS + RA_REGNUM];
d2402 1
a2402 1
  trad_frame_set_reg_realreg (this_trad_cache, PC_REGNUM, RA_REGNUM);
d2408 1
a2408 1
  stack_addr = frame_unwind_register_signed (next_frame, SP_REGNUM);
d2595 1
a2595 1
  instlen = pc_is_mips16 (pc) ? MIPS16_INSTLEN : MIPS_INSTLEN;
d2661 2
a2662 1
	start_pc += 2 * MIPS_INSTLEN;	/* skip return, and its delay slot */
d2680 1
a2680 1
  PROC_PC_REG (&temp_proc_desc) = RA_REGNUM;
d3138 1
a3138 1
  regcache_cooked_write_signed (regcache, T9_REGNUM, func_addr);
d3142 1
a3142 1
  regcache_cooked_write_signed (regcache, RA_REGNUM, bp_addr);
d3167 1
a3167 1
  argreg = A0_REGNUM;
d3457 1
a3457 1
  regcache_cooked_write_signed (regcache, T9_REGNUM, func_addr);
d3461 1
a3461 1
  regcache_cooked_write_signed (regcache, RA_REGNUM, bp_addr);
d3484 1
a3484 1
  argreg = A0_REGNUM;
d3740 1
a3740 1
      for (offset = 0, regnum = V0_REGNUM;
d3761 1
a3761 1
      for (offset = 0, regnum = V0_REGNUM;
d3796 1
a3796 1
  regcache_cooked_write_signed (regcache, T9_REGNUM, func_addr);
d3800 1
a3800 1
  regcache_cooked_write_signed (regcache, RA_REGNUM, bp_addr);
d3823 1
a3823 1
  argreg = A0_REGNUM;
d4190 1
a4190 1
      for (offset = 0, regnum = V0_REGNUM;
d4213 1
a4213 1
      for (offset = 0, regnum = V0_REGNUM;
d4250 1
a4250 1
  regcache_cooked_write_signed (regcache, T9_REGNUM, func_addr);
d4254 1
a4254 1
  regcache_cooked_write_signed (regcache, RA_REGNUM, bp_addr);
d4277 1
a4277 1
  argreg = A0_REGNUM;
d4962 1
a4962 1
  char buf[MIPS_INSTLEN];
d4968 1
a4968 1
  if (target_read_memory (pc, buf, MIPS_INSTLEN) != 0)
d4971 1
a4971 2
  return is_delayed ((unsigned long)
		     extract_unsigned_integer (buf, MIPS_INSTLEN));
d5304 1
a5304 1
    return read_signed_register (RA_REGNUM);
d5349 1
a5349 1
	      for (i = 0, pc = 0; i < 20; i++, target_pc += MIPS_INSTLEN)
d5795 1
a5795 1
      tdep->mips_last_arg_regnum = A0_REGNUM + 4 - 1;
d5808 1
a5808 1
      tdep->mips_last_arg_regnum = A0_REGNUM + 4 - 1;
d5822 1
a5822 1
      tdep->mips_last_arg_regnum = A0_REGNUM + 8 - 1;
d5838 1
a5838 1
      tdep->mips_last_arg_regnum = A0_REGNUM + 8 - 1;
d5851 1
a5851 1
      tdep->mips_last_arg_regnum = A0_REGNUM + 8 - 1;
d5864 1
a5864 1
      tdep->mips_last_arg_regnum = A0_REGNUM + 8 - 1;
a6092 1
  fprintf_unfiltered (file, "mips_dump_tdep: A0_REGNUM = %d\n", A0_REGNUM);
a6131 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS16_INSTLEN = %d\n",
		      MIPS16_INSTLEN);
a6135 2
		      "mips_dump_tdep: MIPS_INSTLEN = %d\n", MIPS_INSTLEN);
  fprintf_unfiltered (file,
d6138 1
a6138 1
		      MIPS_LAST_ARG_REGNUM - A0_REGNUM + 1);
a6159 1
  fprintf_unfiltered (file, "mips_dump_tdep: RA_REGNUM = %d\n", RA_REGNUM);
a6195 1
  fprintf_unfiltered (file, "mips_dump_tdep: T9_REGNUM = %d\n", T9_REGNUM);
a6224 1
  fprintf_unfiltered (file, "mips_dump_tdep: V0_REGNUM = %d\n", V0_REGNUM);
a6227 2
  fprintf_unfiltered (file,
		      "mips_dump_tdep: ZERO_REGNUM = %d\n", ZERO_REGNUM);
@


1.337
log
@2004-10-26  Andrew Cagney  <cagney@@gnu.org>

	* config/mips/tm-linux.h: Delete #undef SKIP_TRAMPOLINE_CODE.
	* mips-tdep.c (mips_skip_trampoline_code): Rename mips_skip_stub.
	(mips_gdbarch_init): Update.
	(mips_dump_tdep): Do not print SKIP_TRAMPOLINE_CODE.
@
text
@a4945 2
static int is_delayed (unsigned long);

@


1.336
log
@2004-10-26  Andrew Cagney  <cagney@@gnu.org>

	* config/arm/tm-linux.h (IN_SOLIB_RETURN_TRAMPOLINE): Delete.
	* config/mips/tm-nbsd.h, config/mips/tm-linux.h: Delete #undef
	IN_SOLIB_RETURN_TRAMPOLINE.
	* mips-tdep.c (mips_dump_tdep): Do not print
	IN_SOLIB_RETURN_TRAMPOLINE.
	(mips_in_solib_return_trampoline): Rename mips_in_return_stub.
	(mips_gdbarch_init): Update.
@
text
@d5292 1
a5292 4
   gory details.

   This function implements the SKIP_TRAMPOLINE_CODE macro.
 */
d5295 1
a5295 1
mips_skip_stub (CORE_ADDR pc)
d5960 1
a5960 1
  set_gdbarch_skip_trampoline_code (gdbarch, mips_skip_stub);
a6184 3
		      "mips_dump_tdep: SKIP_TRAMPOLINE_CODE # %s\n",
		      XSTRING (SKIP_TRAMPOLINE_CODE (PC)));
  fprintf_unfiltered (file,
@


1.335
log
@        * mips-tdep.c (mips32_scan_prologue): Move the implementation up
        a bit to avoid the necessity of an advance declaration. Remove
        declaration.
        (set_reg_offset): Move implemenation up.
        (mips16_get_imm): Likewise.
        (mips16_scan_prologue): Likewise.
        (reset_saved_regs): Likewise.
        (mips32_scan_prologue): Likewise.
@
text
@d5407 2
a5408 2
/* Return non-zero if the PC is inside a return thunk (aka stub or trampoline).
   This implements the IN_SOLIB_RETURN_TRAMPOLINE macro.  */
d5411 1
a5411 1
mips_in_return_stub (CORE_ADDR pc, char *name)
d5974 1
a5974 1
      set_gdbarch_in_solib_return_trampoline (gdbarch, mips_in_return_stub);
a6122 3
		      "mips_dump_tdep: IN_SOLIB_RETURN_TRAMPOLINE # %s\n",
		      XSTRING (IN_SOLIB_RETURN_TRAMPOLINE (PC, NAME)));
  fprintf_unfiltered (file,
@


1.334
log
@        * mips-tdep.c (mips32_scan_prologue): Add advance declaration.
        Remove sp as a parameter, compute it internally instead. Move
        prologue scanning limit from heuristic_proc_desc to here.
        (mips16_scan_prologue): Likewise.
        (mips_insn16_frame_cache): Replace call to heuristic_proc_desc
        by call to mips16_scan_prologue.
        (mips_insn32_frame_cache): Replace call to heuristic_proc_desc
        by call to mips32_scan_prologue.
        (heuristic_proc_desc): Remove code that's no longer necessary.
        Update calls to mips16_scan_prologue and mips32_scan_prologue.
        (mips_skip_prologue): Update calls to mips16_scan_prologue
        and mips32_scan_prologue.
@
text
@a444 11
/* FIXME: brobecker/2004-10-15: I suspect these two declarations can
   be removed by a better ordering of the functions below.  But I want
   to do that as a separate change later in order to separate real
   changes and changes that just move some code around.  */
static CORE_ADDR mips32_scan_prologue (CORE_ADDR start_pc, CORE_ADDR limit_pc,
                                       struct frame_info *next_frame,
                                       struct mips_frame_cache *this_cache);
static CORE_ADDR mips16_scan_prologue (CORE_ADDR start_pc, CORE_ADDR limit_pc,
                                       struct frame_info *next_frame,
                                       struct mips_frame_cache *this_cache);

d1713 4
a1716 3
/* Heuristic unwinder for 16-bit MIPS instruction set (aka MIPS16).
   Procedures that use the 32-bit instruction set are handled by the
   mips_insn32 unwinder.  */
d1718 5
a1722 32
static struct mips_frame_cache *
mips_insn16_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct mips_frame_cache *cache;

  if ((*this_cache) != NULL)
    return (*this_cache);
  cache = FRAME_OBSTACK_ZALLOC (struct mips_frame_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  /* Analyze the function prologue.  */
  {
    const CORE_ADDR pc = frame_pc_unwind (next_frame);
    CORE_ADDR start_addr;

    find_pc_partial_function (pc, NULL, &start_addr, NULL);
    if (start_addr == 0)
      start_addr = heuristic_proc_start (pc);
    /* We can't analyze the prologue if we couldn't find the begining
       of the function.  */
    if (start_addr == 0)
      return cache;

    mips16_scan_prologue (start_addr, pc, next_frame, *this_cache);
  }
  
  /* SP_REGNUM, contains the value and not the address.  */
  trad_frame_set_value (cache->saved_regs, NUM_REGS + MIPS_SP_REGNUM, cache->base);

  return (*this_cache);
}
d1725 2
a1726 2
mips_insn16_frame_this_id (struct frame_info *next_frame, void **this_cache,
			   struct frame_id *this_id)
d1728 6
a1733 3
  struct mips_frame_cache *info = mips_insn16_frame_cache (next_frame,
							   this_cache);
  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
a1735 12
static void
mips_insn16_frame_prev_register (struct frame_info *next_frame,
				 void **this_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *valuep)
{
  struct mips_frame_cache *info = mips_insn16_frame_cache (next_frame,
							   this_cache);
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
}
d1737 11
a1747 1
static const struct frame_unwind mips_insn16_frame_unwind =
d1749 1
a1749 4
  NORMAL_FRAME,
  mips_insn16_frame_this_id,
  mips_insn16_frame_prev_register
};
d1751 12
a1762 8
static const struct frame_unwind *
mips_insn16_frame_sniffer (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  if (pc_is_mips16 (pc))
    return &mips_insn16_frame_unwind;
  return NULL;
}
d1764 5
a1768 7
static CORE_ADDR
mips_insn16_frame_base_address (struct frame_info *next_frame,
				void **this_cache)
{
  struct mips_frame_cache *info = mips_insn16_frame_cache (next_frame,
							   this_cache);
  return info->base;
a1770 7
static const struct frame_base mips_insn16_frame_base =
{
  &mips_insn16_frame_unwind,
  mips_insn16_frame_base_address,
  mips_insn16_frame_base_address,
  mips_insn16_frame_base_address
};
d1772 3
a1774 8
static const struct frame_base *
mips_insn16_frame_base_sniffer (struct frame_info *next_frame)
{
  if (mips_insn16_frame_sniffer (next_frame) != NULL)
    return &mips_insn16_frame_base;
  else
    return NULL;
}
d1776 4
a1779 7
/* Heuristic unwinder for procedures using 32-bit instructions (covers
   both 32-bit and 64-bit MIPS ISAs).  Procedures using 16-bit
   instructions (a.k.a. MIPS16) are handled by the mips_insn16
   unwinder.  */

static struct mips_frame_cache *
mips_insn32_frame_cache (struct frame_info *next_frame, void **this_cache)
d1781 10
a1790 1
  struct mips_frame_cache *cache;
d1792 3
a1794 2
  if ((*this_cache) != NULL)
    return (*this_cache);
d1796 6
a1801 3
  cache = FRAME_OBSTACK_ZALLOC (struct mips_frame_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d1803 2
a1804 4
  /* Analyze the function prologue.  */
  {
    const CORE_ADDR pc = frame_pc_unwind (next_frame);
    CORE_ADDR start_addr;
d1806 5
a1810 7
    find_pc_partial_function (pc, NULL, &start_addr, NULL);
    if (start_addr == 0)
      start_addr = heuristic_proc_start (pc);
    /* We can't analyze the prologue if we couldn't find the begining
       of the function.  */
    if (start_addr == 0)
      return cache;
d1812 2
a1813 5
    mips32_scan_prologue (start_addr, pc, next_frame, *this_cache);
  }
  
  /* SP_REGNUM, contains the value and not the address.  */
  trad_frame_set_value (cache->saved_regs, NUM_REGS + MIPS_SP_REGNUM, cache->base);
d1815 10
a1824 2
  return (*this_cache);
}
d1826 2
a1827 8
static void
mips_insn32_frame_this_id (struct frame_info *next_frame, void **this_cache,
			   struct frame_id *this_id)
{
  struct mips_frame_cache *info = mips_insn32_frame_cache (next_frame,
							   this_cache);
  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
}
d1829 102
a1930 12
static void
mips_insn32_frame_prev_register (struct frame_info *next_frame,
				 void **this_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *valuep)
{
  struct mips_frame_cache *info = mips_insn32_frame_cache (next_frame,
							   this_cache);
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
}
d1932 7
a1938 6
static const struct frame_unwind mips_insn32_frame_unwind =
{
  NORMAL_FRAME,
  mips_insn32_frame_this_id,
  mips_insn32_frame_prev_register
};
d1940 7
a1946 8
static const struct frame_unwind *
mips_insn32_frame_sniffer (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  if (! pc_is_mips16 (pc))
    return &mips_insn32_frame_unwind;
  return NULL;
}
d1948 11
a1958 8
static CORE_ADDR
mips_insn32_frame_base_address (struct frame_info *next_frame,
				void **this_cache)
{
  struct mips_frame_cache *info = mips_insn32_frame_cache (next_frame,
							   this_cache);
  return info->base;
}
d1960 5
a1964 7
static const struct frame_base mips_insn32_frame_base =
{
  &mips_insn32_frame_unwind,
  mips_insn32_frame_base_address,
  mips_insn32_frame_base_address,
  mips_insn32_frame_base_address
};
d1966 1
a1966 7
static const struct frame_base *
mips_insn32_frame_base_sniffer (struct frame_info *next_frame)
{
  if (mips_insn32_frame_sniffer (next_frame) != NULL)
    return &mips_insn32_frame_base;
  else
    return NULL;
d1969 6
a1974 2
static struct trad_frame_cache *
mips_stub_frame_cache (struct frame_info *next_frame, void **this_cache)
d1976 1
a1976 4
  CORE_ADDR pc;
  CORE_ADDR start_addr;
  CORE_ADDR stack_addr;
  struct trad_frame_cache *this_trad_cache;
d1980 3
a1982 2
  this_trad_cache = trad_frame_cache_zalloc (next_frame);
  (*this_cache) = this_trad_cache;
d1984 4
a1987 2
  /* The return address is in the link register.  */
  trad_frame_set_reg_realreg (this_trad_cache, PC_REGNUM, RA_REGNUM);
d1989 7
a1995 6
  /* Frame ID, since it's a frameless / stackless function, no stack
     space is allocated and SP on entry is the current SP.  */
  pc = frame_pc_unwind (next_frame);
  find_pc_partial_function (pc, NULL, &start_addr, NULL);
  stack_addr = frame_unwind_register_signed (next_frame, SP_REGNUM);
  trad_frame_set_id (this_trad_cache, frame_id_build (start_addr, stack_addr));
d1997 5
a2001 3
  /* Assume that the frame's base is the same as the
     stack-pointer.  */
  trad_frame_set_this_base (this_trad_cache, stack_addr);
d2003 1
a2003 1
  return this_trad_cache;
d2007 2
a2008 2
mips_stub_frame_this_id (struct frame_info *next_frame, void **this_cache,
			 struct frame_id *this_id)
d2010 3
a2012 3
  struct trad_frame_cache *this_trad_cache
    = mips_stub_frame_cache (next_frame, this_cache);
  trad_frame_get_id (this_trad_cache, this_id);
d2016 1
a2016 1
mips_stub_frame_prev_register (struct frame_info *next_frame,
d2022 4
a2025 4
  struct trad_frame_cache *this_trad_cache
    = mips_stub_frame_cache (next_frame, this_cache);
  trad_frame_get_register (this_trad_cache, next_frame, regnum, optimizedp,
			   lvalp, addrp, realnump, valuep);
d2028 1
a2028 1
static const struct frame_unwind mips_stub_frame_unwind =
d2031 2
a2032 2
  mips_stub_frame_this_id,
  mips_stub_frame_prev_register
d2036 1
a2036 1
mips_stub_frame_sniffer (struct frame_info *next_frame)
d2039 3
a2041 4
  if (in_plt_section (pc, NULL))
    return &mips_stub_frame_unwind;
  else
    return NULL;
d2045 2
a2046 2
mips_stub_frame_base_address (struct frame_info *next_frame,
			      void **this_cache)
d2048 3
a2050 3
  struct trad_frame_cache *this_trad_cache
    = mips_stub_frame_cache (next_frame, this_cache);
  return trad_frame_get_this_base (this_trad_cache);
d2053 1
a2053 1
static const struct frame_base mips_stub_frame_base =
d2055 4
a2058 4
  &mips_stub_frame_unwind,
  mips_stub_frame_base_address,
  mips_stub_frame_base_address,
  mips_stub_frame_base_address
d2062 1
a2062 1
mips_stub_frame_base_sniffer (struct frame_info *next_frame)
d2064 2
a2065 2
  if (mips_stub_frame_sniffer (next_frame) != NULL)
    return &mips_stub_frame_base;
d2070 5
a2074 2
static CORE_ADDR
read_next_frame_reg (struct frame_info *fi, int regno)
d2076 6
a2081 10
  /* Always a pseudo.  */
  gdb_assert (regno >= NUM_REGS);
  if (fi == NULL)
    {
      LONGEST val;
      regcache_cooked_read_signed (current_regcache, regno, &val);
      return val;
    }
  else
    return frame_unwind_register_signed (fi, regno);
d2083 5
d2090 3
a2092 1
/* mips_addr_bits_remove - remove useless address bits  */
d2095 3
a2097 1
mips_addr_bits_remove (CORE_ADDR addr)
d2099 5
a2103 9
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  if (mips_mask_address_p (tdep) && (((ULONGEST) addr) >> 32 == 0xffffffffUL))
    /* This hack is a work-around for existing boards using PMON, the
       simulator, and any other 64-bit targets that doesn't have true
       64-bit addressing.  On these targets, the upper 32 bits of
       addresses are ignored by the hardware.  Thus, the PC or SP are
       likely to have been sign extended to all 1s by instruction
       sequences that load 32-bit addresses.  For example, a typical
       piece of code that loads an address is this:
d2105 3
a2107 2
       lui $r2, <upper 16 bits>
       ori $r2, <lower 16 bits>
d2109 4
a2112 5
       But the lui sign-extends the value such that the upper 32 bits
       may be all 1s.  The workaround is simply to mask off these
       bits.  In the future, gcc may be changed to support true 64-bit
       addressing, and this masking will have to be disabled.  */
    return addr &= 0xffffffffUL;
d2114 1
a2114 2
    return addr;
}
d2116 2
a2117 4
/* mips_software_single_step() is called just before we want to resume
   the inferior, if we want to single-step it but there is no hardware
   or kernel single-step support (MIPS on GNU/Linux for example).  We find
   the target of the coming instruction and breakpoint it.
d2119 1
a2119 2
   single_step is also called just after the inferior stops.  If we had
   set up a simulated single-step, we undo our damage.  */
d2121 5
a2125 7
void
mips_software_single_step (enum target_signal sig, int insert_breakpoints_p)
{
  static CORE_ADDR next_pc;
  typedef char binsn_quantum[BREAKPOINT_MAX];
  static binsn_quantum break_mem;
  CORE_ADDR pc;
d2127 2
a2128 4
  if (insert_breakpoints_p)
    {
      pc = read_register (mips_regnum (current_gdbarch)->pc);
      next_pc = mips_next_pc (pc);
d2130 4
a2133 5
      target_insert_breakpoint (next_pc, break_mem);
    }
  else
    target_remove_breakpoint (next_pc, break_mem);
}
d2135 30
a2164 1
static struct mips_extra_func_info temp_proc_desc;
d2166 27
a2192 4
/* Set a register's saved stack address in temp_saved_regs.  If an
   address has already been set for this register, do nothing; this
   way we will only recognize the first save of a given register in a
   function prologue.
d2194 62
a2255 5
   For simplicity, save the address in both [0 .. NUM_REGS) and
   [NUM_REGS .. 2*NUM_REGS).  Strictly speaking, only the second range
   is used as it is only second range (the ABI instead of ISA
   registers) that comes into play when finding saved registers in a
   frame.  */
d2257 1
a2257 6
static void
set_reg_offset (struct mips_frame_cache *this_cache, int regnum,
		CORE_ADDR offset)
{
  if (this_cache != NULL
      && this_cache->saved_regs[regnum].addr == -1)
d2259 8
a2266 2
      this_cache->saved_regs[regnum + 0 * NUM_REGS].addr = offset;
      this_cache->saved_regs[regnum + 1 * NUM_REGS].addr = offset;
a2267 1
}
d2269 14
d2284 1
a2284 16
/* Test whether the PC points to the return instruction at the
   end of a function. */

static int
mips_about_to_return (CORE_ADDR pc)
{
  if (pc_is_mips16 (pc))
    /* This mips16 case isn't necessarily reliable.  Sometimes the compiler
       generates a "jr $ra"; other times it generates code to load
       the return address from the stack to an accessible register (such
       as $a3), then a "jr" using that register.  This second case
       is almost impossible to distinguish from an indirect jump
       used for switch statements, so we don't even try.  */
    return mips_fetch_instruction (pc) == 0xe820;	/* jr $ra */
  else
    return mips_fetch_instruction (pc) == 0x3e00008;	/* jr $ra */
d2287 4
d2292 4
a2295 3
/* This fencepost looks highly suspicious to me.  Removing it also
   seems suspicious as it could affect remote debugging across serial
   lines.  */
d2297 2
a2298 7
static CORE_ADDR
heuristic_proc_start (CORE_ADDR pc)
{
  CORE_ADDR start_pc;
  CORE_ADDR fence;
  int instlen;
  int seen_adjsp = 0;
d2300 3
a2302 5
  pc = ADDR_BITS_REMOVE (pc);
  start_pc = pc;
  fence = start_pc - heuristic_fence_post;
  if (start_pc == 0)
    return 0;
d2304 4
a2307 2
  if (heuristic_fence_post == UINT_MAX || fence < VM_MIN_ADDRESS)
    fence = VM_MIN_ADDRESS;
d2309 7
a2315 1
  instlen = pc_is_mips16 (pc) ? MIPS16_INSTLEN : MIPS_INSTLEN;
d2317 5
a2321 11
  /* search back for previous return */
  for (start_pc -= instlen;; start_pc -= instlen)
    if (start_pc < fence)
      {
	/* It's not clear to me why we reach this point when
	   stop_soon, but with this test, at least we
	   don't print out warnings for every child forked (eg, on
	   decstation).  22apr93 rich@@cygnus.com.  */
	if (stop_soon == NO_STOP_QUIETLY)
	  {
	    static int blurb_printed = 0;
d2323 2
a2324 2
	    warning ("GDB can't find the start of the function at 0x%s.",
		     paddr_nz (pc));
d2326 8
a2333 22
	    if (!blurb_printed)
	      {
		/* This actually happens frequently in embedded
		   development, when you first connect to a board
		   and your stack pointer and pc are nowhere in
		   particular.  This message needs to give people
		   in that situation enough information to
		   determine that it's no big deal.  */
		printf_filtered ("\n\
    GDB is unable to find the start of the function at 0x%s\n\
and thus can't determine the size of that function's stack frame.\n\
This means that GDB may be unable to access that stack frame, or\n\
the frames below it.\n\
    This problem is most likely caused by an invalid program counter or\n\
stack pointer.\n\
    However, if you think GDB should simply search farther back\n\
from 0x%s for code which looks like the beginning of a\n\
function, you can increase the range of the search using the `set\n\
heuristic-fence-post' command.\n", paddr_nz (pc), paddr_nz (pc));
		blurb_printed = 1;
	      }
	  }
d2335 12
a2346 5
	return 0;
      }
    else if (pc_is_mips16 (start_pc))
      {
	unsigned short inst;
d2348 6
a2353 23
	/* On MIPS16, any one of the following is likely to be the
	   start of a function:
	   entry
	   addiu sp,-n
	   daddiu sp,-n
	   extend -n followed by 'addiu sp,+n' or 'daddiu sp,+n'  */
	inst = mips_fetch_instruction (start_pc);
	if (((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)	/* entry */
	    || (inst & 0xff80) == 0x6380	/* addiu sp,-n */
	    || (inst & 0xff80) == 0xfb80	/* daddiu sp,-n */
	    || ((inst & 0xf810) == 0xf010 && seen_adjsp))	/* extend -n */
	  break;
	else if ((inst & 0xff00) == 0x6300	/* addiu sp */
		 || (inst & 0xff00) == 0xfb00)	/* daddiu sp */
	  seen_adjsp = 1;
	else
	  seen_adjsp = 0;
      }
    else if (mips_about_to_return (start_pc))
      {
	start_pc += 2 * MIPS_INSTLEN;	/* skip return, and its delay slot */
	break;
      }
d2355 7
a2361 1
  return start_pc;
d2364 8
a2371 4
/* Fetch the immediate value from a MIPS16 instruction.
   If the previous instruction was an EXTEND, use it to extend
   the upper bits of the immediate value.  This is a helper function
   for mips16_scan_prologue.  */
d2373 1
a2373 6
static int
mips16_get_imm (unsigned short prev_inst,	/* previous instruction */
		unsigned short inst,	/* current instruction */
		int nbits,	/* number of bits in imm field */
		int scale,	/* scale factor to be applied to imm */
		int is_signed)	/* is the imm field signed? */
d2375 5
a2379 1
  int offset;
d2381 5
a2385 7
  if ((prev_inst & 0xf800) == 0xf000)	/* prev instruction was EXTEND? */
    {
      offset = ((prev_inst & 0x1f) << 11) | (prev_inst & 0x7e0);
      if (offset & 0x8000)	/* check for negative extend */
	offset = 0 - (0x10000 - (offset & 0xffff));
      return offset | (inst & 0x1f);
    }
d2387 1
a2387 10
    {
      int max_imm = 1 << nbits;
      int mask = max_imm - 1;
      int sign_bit = max_imm >> 1;

      offset = inst & mask;
      if (is_signed && (offset & sign_bit))
	offset = 0 - (max_imm - offset);
      return offset * scale;
    }
d2390 7
d2398 4
a2401 3
/* Analyze the function prologue from START_PC to LIMIT_PC. Builds
   the associated FRAME_CACHE if not null.
   Return the address of the first instruction past the prologue.  */
d2403 2
a2404 15
static CORE_ADDR
mips16_scan_prologue (CORE_ADDR start_pc, CORE_ADDR limit_pc,
                      struct frame_info *next_frame,
                      struct mips_frame_cache *this_cache)
{
  CORE_ADDR cur_pc;
  CORE_ADDR frame_addr = 0;	/* Value of $r17, used as frame pointer */
  CORE_ADDR sp;
  long frame_offset = 0;        /* Size of stack frame.  */
  long frame_adjust = 0;        /* Offset of FP from SP.  */
  int frame_reg = MIPS_SP_REGNUM;
  unsigned short prev_inst = 0;	/* saved copy of previous instruction */
  unsigned inst = 0;		/* current instruction */
  unsigned entry_inst = 0;	/* the entry instruction */
  int reg, offset;
d2406 6
a2411 3
  int extend_bytes = 0;
  int prev_extend_bytes;
  CORE_ADDR end_prologue_addr = 0;
d2413 3
a2415 6
  /* Can be called when there's no process, and hence when there's no
     NEXT_FRAME.  */
  if (next_frame != NULL)
    sp = read_next_frame_reg (next_frame, NUM_REGS + MIPS_SP_REGNUM);
  else
    sp = 0;
d2417 2
a2418 2
  if (limit_pc > start_pc + 200)
    limit_pc = start_pc + 200;
d2420 8
a2427 5
  for (cur_pc = start_pc; cur_pc < limit_pc; cur_pc += MIPS16_INSTLEN)
    {
      /* Save the previous instruction.  If it's an EXTEND, we'll extract
         the immediate offset extension from it in mips16_get_imm.  */
      prev_inst = inst;
d2429 12
a2440 2
      /* Fetch and decode the instruction.   */
      inst = (unsigned short) mips_fetch_instruction (cur_pc);
d2442 6
a2447 10
      /* Normally we ignore extend instructions.  However, if it is
         not followed by a valid prologue instruction, then this
         instruction is not part of the prologue either.  We must
         remember in this case to adjust the end_prologue_addr back
         over the extend.  */
      if ((inst & 0xf800) == 0xf000)    /* extend */
        {
          extend_bytes = MIPS16_INSTLEN;
          continue;
        }
d2449 9
a2457 2
      prev_extend_bytes = extend_bytes;
      extend_bytes = 0;
d2459 8
a2466 77
      if ((inst & 0xff00) == 0x6300	/* addiu sp */
	  || (inst & 0xff00) == 0xfb00)	/* daddiu sp */
	{
	  offset = mips16_get_imm (prev_inst, inst, 8, 8, 1);
	  if (offset < 0)	/* negative stack adjustment? */
	    frame_offset -= offset;
	  else
	    /* Exit loop if a positive stack adjustment is found, which
	       usually means that the stack cleanup code in the function
	       epilogue is reached.  */
	    break;
	}
      else if ((inst & 0xf800) == 0xd000)	/* sw reg,n($sp) */
	{
	  offset = mips16_get_imm (prev_inst, inst, 8, 4, 0);
	  reg = mips16_to_32_reg[(inst & 0x700) >> 8];
	  set_reg_offset (this_cache, reg, sp + offset);
	}
      else if ((inst & 0xff00) == 0xf900)	/* sd reg,n($sp) */
	{
	  offset = mips16_get_imm (prev_inst, inst, 5, 8, 0);
	  reg = mips16_to_32_reg[(inst & 0xe0) >> 5];
	  set_reg_offset (this_cache, reg, sp + offset);
	}
      else if ((inst & 0xff00) == 0x6200)	/* sw $ra,n($sp) */
	{
	  offset = mips16_get_imm (prev_inst, inst, 8, 4, 0);
	  set_reg_offset (this_cache, RA_REGNUM, sp + offset);
	}
      else if ((inst & 0xff00) == 0xfa00)	/* sd $ra,n($sp) */
	{
	  offset = mips16_get_imm (prev_inst, inst, 8, 8, 0);
	  set_reg_offset (this_cache, RA_REGNUM, sp + offset);
	}
      else if (inst == 0x673d)	/* move $s1, $sp */
	{
	  frame_addr = sp;
	  frame_reg = 17;
	}
      else if ((inst & 0xff00) == 0x0100)	/* addiu $s1,sp,n */
	{
	  offset = mips16_get_imm (prev_inst, inst, 8, 4, 0);
	  frame_addr = sp + offset;
	  frame_reg = 17;
	  frame_adjust = offset;
	}
      else if ((inst & 0xFF00) == 0xd900)	/* sw reg,offset($s1) */
	{
	  offset = mips16_get_imm (prev_inst, inst, 5, 4, 0);
	  reg = mips16_to_32_reg[(inst & 0xe0) >> 5];
	  set_reg_offset (this_cache, reg, frame_addr + offset);
	}
      else if ((inst & 0xFF00) == 0x7900)	/* sd reg,offset($s1) */
	{
	  offset = mips16_get_imm (prev_inst, inst, 5, 8, 0);
	  reg = mips16_to_32_reg[(inst & 0xe0) >> 5];
	  set_reg_offset (this_cache, reg, frame_addr + offset);
	}
      else if ((inst & 0xf81f) == 0xe809
               && (inst & 0x700) != 0x700)	/* entry */
	entry_inst = inst;	/* save for later processing */
      else if ((inst & 0xf800) == 0x1800)	/* jal(x) */
	cur_pc += MIPS16_INSTLEN;	/* 32-bit instruction */
      else if ((inst & 0xff1c) == 0x6704)	/* move reg,$a0-$a3 */
        {
          /* This instruction is part of the prologue, but we don't
             need to do anything special to handle it.  */
        }
      else
        {
          /* This instruction is not an instruction typically found
             in a prologue, so we must have reached the end of the
             prologue.  */
          if (end_prologue_addr == 0)
            end_prologue_addr = cur_pc - prev_extend_bytes;
        }
    }
d2468 7
a2474 10
  /* The entry instruction is typically the first instruction in a function,
     and it stores registers at offsets relative to the value of the old SP
     (before the prologue).  But the value of the sp parameter to this
     function is the new SP (after the prologue has been executed).  So we
     can't calculate those offsets until we've seen the entire prologue,
     and can calculate what the old SP must have been. */
  if (entry_inst != 0)
    {
      int areg_count = (entry_inst >> 8) & 7;
      int sreg_count = (entry_inst >> 6) & 3;
d2476 8
a2483 2
      /* The entry instruction always subtracts 32 from the SP.  */
      frame_offset += 32;
d2485 6
a2490 28
      /* Now we can calculate what the SP must have been at the
         start of the function prologue.  */
      sp += frame_offset;

      /* Check if a0-a3 were saved in the caller's argument save area.  */
      for (reg = 4, offset = 0; reg < areg_count + 4; reg++)
	{
	  set_reg_offset (this_cache, reg, sp + offset);
	  offset += mips_abi_regsize (current_gdbarch);
	}

      /* Check if the ra register was pushed on the stack.  */
      offset = -4;
      if (entry_inst & 0x20)
	{
	  set_reg_offset (this_cache, RA_REGNUM, sp + offset);
	  offset -= mips_abi_regsize (current_gdbarch);
	}

      /* Check if the s0 and s1 registers were pushed on the stack.  */
      for (reg = 16; reg < sreg_count + 16; reg++)
	{
	  set_reg_offset (this_cache, reg, sp + offset);
	  offset -= mips_abi_regsize (current_gdbarch);
	}
    }

  if (this_cache != NULL)
d2492 3
a2494 8
      this_cache->base =
        (frame_unwind_register_signed (next_frame, NUM_REGS + frame_reg)
         + frame_offset - frame_adjust);
      /* FIXME: brobecker/2004-10-10: Just as in the mips32 case, we should
         be able to get rid of the assignment below, evetually. But it's
         still needed for now.  */
      this_cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->pc]
        = this_cache->saved_regs[NUM_REGS + RA_REGNUM];
d2496 2
a2498 7
  /* If we didn't reach the end of the prologue when scanning the function
     instructions, then set end_prologue_addr to the address of the
     instruction immediately after the last one we scanned.  */
  if (end_prologue_addr == 0)
    end_prologue_addr = cur_pc;

  return end_prologue_addr;
d2501 1
a2501 2
/* Mark all the registers as unset in the saved_regs array
   of THIS_CACHE.  Do nothing if THIS_CACHE is null.  */
d2503 2
a2504 2
void
reset_saved_regs (struct mips_frame_cache *this_cache)
d2506 9
a2514 2
  if (this_cache == NULL || this_cache->saved_regs == NULL)
    return;
d2516 2
a2517 3
  {
    const int num_regs = NUM_REGS;
    int i;
d2519 7
a2525 5
    for (i = 0; i < num_regs; i++)
      {
        this_cache->saved_regs[i].addr = -1;
      }
  }
d2528 7
a2534 3
/* Analyze the function prologue from START_PC to LIMIT_PC. Builds
   the associated FRAME_CACHE if not null.  
   Return the address of the first instruction past the prologue.  */
d2536 2
a2537 4
static CORE_ADDR
mips32_scan_prologue (CORE_ADDR start_pc, CORE_ADDR limit_pc,
                      struct frame_info *next_frame,
                      struct mips_frame_cache *this_cache)
d2539 17
a2555 5
  CORE_ADDR cur_pc;
  CORE_ADDR frame_addr = 0; /* Value of $r30. Used by gcc for frame-pointer */
  CORE_ADDR sp;
  long frame_offset;
  int  frame_reg = MIPS_SP_REGNUM;
d2557 2
a2558 3
  CORE_ADDR end_prologue_addr = 0;
  int seen_sp_adjust = 0;
  int load_immediate_bytes = 0;
d2560 11
a2570 4
  /* Can be called when there's no process, and hence when there's no
     NEXT_FRAME.  */
  if (next_frame != NULL)
    sp = read_next_frame_reg (next_frame, NUM_REGS + MIPS_SP_REGNUM);
d2572 3
a2574 1
    sp = 0;
d2576 3
a2578 2
  if (limit_pc > start_pc + 200)
    limit_pc = start_pc + 200;
d2580 7
a2586 1
restart:
d2588 5
a2592 5
  frame_offset = 0;
  for (cur_pc = start_pc; cur_pc < limit_pc; cur_pc += MIPS_INSTLEN)
    {
      unsigned long inst, high_word, low_word;
      int reg;
d2594 2
a2595 2
      /* Fetch the instruction.   */
      inst = (unsigned long) mips_fetch_instruction (cur_pc);
d2597 1
a2597 4
      /* Save some code by pre-extracting some useful fields.  */
      high_word = (inst >> 16) & 0xffff;
      low_word = inst & 0xffff;
      reg = high_word & 0x1f;
d2599 11
a2609 30
      if (high_word == 0x27bd	/* addiu $sp,$sp,-i */
	  || high_word == 0x23bd	/* addi $sp,$sp,-i */
	  || high_word == 0x67bd)	/* daddiu $sp,$sp,-i */
	{
	  if (low_word & 0x8000)	/* negative stack adjustment? */
            frame_offset += 0x10000 - low_word;
	  else
	    /* Exit loop if a positive stack adjustment is found, which
	       usually means that the stack cleanup code in the function
	       epilogue is reached.  */
	    break;
          seen_sp_adjust = 1;
	}
      else if ((high_word & 0xFFE0) == 0xafa0)	/* sw reg,offset($sp) */
	{
	  set_reg_offset (this_cache, reg, sp + low_word);
	}
      else if ((high_word & 0xFFE0) == 0xffa0)	/* sd reg,offset($sp) */
	{
	  /* Irix 6.2 N32 ABI uses sd instructions for saving $gp and $ra.  */
	  set_reg_offset (this_cache, reg, sp + low_word);
	}
      else if (high_word == 0x27be)	/* addiu $30,$sp,size */
	{
	  /* Old gcc frame, r30 is virtual frame pointer.  */
	  if ((long) low_word != frame_offset)
	    frame_addr = sp + low_word;
	  else if (frame_reg == MIPS_SP_REGNUM)
	    {
	      unsigned alloca_adjust;
d2611 2
a2612 27
	      frame_reg = 30;
	      frame_addr = read_next_frame_reg (next_frame, NUM_REGS + 30);
	      alloca_adjust = (unsigned) (frame_addr - (sp + low_word));
	      if (alloca_adjust > 0)
		{
                  /* FP > SP + frame_size. This may be because of
                     an alloca or somethings similar.  Fix sp to
                     "pre-alloca" value, and try again.  */
		  sp += alloca_adjust;
                  /* Need to reset the status of all registers.  Otherwise,
                     we will hit a guard that prevents the new address
                     for each register to be recomputed during the second
                     pass.  */
                  reset_saved_regs (this_cache);
		  goto restart;
		}
	    }
	}
      /* move $30,$sp.  With different versions of gas this will be either
         `addu $30,$sp,$zero' or `or $30,$sp,$zero' or `daddu 30,sp,$0'.
         Accept any one of these.  */
      else if (inst == 0x03A0F021 || inst == 0x03a0f025 || inst == 0x03a0f02d)
	{
	  /* New gcc frame, virtual frame pointer is at r30 + frame_size.  */
	  if (frame_reg == MIPS_SP_REGNUM)
	    {
	      unsigned alloca_adjust;
d2614 22
a2635 62
	      frame_reg = 30;
	      frame_addr = read_next_frame_reg (next_frame, NUM_REGS + 30);
	      alloca_adjust = (unsigned) (frame_addr - sp);
	      if (alloca_adjust > 0)
	        {
                  /* FP > SP + frame_size. This may be because of
                     an alloca or somethings similar.  Fix sp to
                     "pre-alloca" value, and try again.  */
	          sp = frame_addr;
                  /* Need to reset the status of all registers.  Otherwise,
                     we will hit a guard that prevents the new address
                     for each register to be recomputed during the second
                     pass.  */
                  reset_saved_regs (this_cache);
	          goto restart;
	        }
	    }
	}
      else if ((high_word & 0xFFE0) == 0xafc0)	/* sw reg,offset($30) */
	{
	  set_reg_offset (this_cache, reg, frame_addr + low_word);
	}
      else if ((high_word & 0xFFE0) == 0xE7A0 /* swc1 freg,n($sp) */
               || (high_word & 0xF3E0) == 0xA3C0 /* sx reg,n($s8) */
               || (inst & 0xFF9F07FF) == 0x00800021 /* move reg,$a0-$a3 */
               || high_word == 0x3c1c /* lui $gp,n */
               || high_word == 0x279c /* addiu $gp,$gp,n */
               || inst == 0x0399e021 /* addu $gp,$gp,$t9 */
               || inst == 0x033ce021 /* addu $gp,$t9,$gp */
              )
       {
         /* These instructions are part of the prologue, but we don't
            need to do anything special to handle them.  */
       }
      /* The instructions below load $at or $t0 with an immediate
         value in preparation for a stack adjustment via
         subu $sp,$sp,[$at,$t0]. These instructions could also
         initialize a local variable, so we accept them only before
         a stack adjustment instruction was seen.  */
      else if (!seen_sp_adjust
               && (high_word == 0x3c01 /* lui $at,n */
                   || high_word == 0x3c08 /* lui $t0,n */
                   || high_word == 0x3421 /* ori $at,$at,n */
                   || high_word == 0x3508 /* ori $t0,$t0,n */
                   || high_word == 0x3401 /* ori $at,$zero,n */
                   || high_word == 0x3408 /* ori $t0,$zero,n */
                  ))
       {
          load_immediate_bytes += MIPS_INSTLEN;     /* FIXME!! */
       }
      else
       {
         /* This instruction is not an instruction typically found
            in a prologue, so we must have reached the end of the
            prologue.  */
         /* FIXME: brobecker/2004-10-10: Can't we just break out of this
            loop now?  Why would we need to continue scanning the function
            instructions?  */
         if (end_prologue_addr == 0)
           end_prologue_addr = cur_pc;
       }
    }
d2637 5
a2641 11
  if (this_cache != NULL)
    {
      this_cache->base = 
        (frame_unwind_register_signed (next_frame, NUM_REGS + frame_reg)
         + frame_offset);
      /* FIXME: brobecker/2004-09-15: We should be able to get rid of
         this assignment below, eventually.  But it's still needed
         for now.  */
      this_cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->pc]
        = this_cache->saved_regs[NUM_REGS + RA_REGNUM];
    }
d2643 23
a2665 14
  /* If we didn't reach the end of the prologue when scanning the function
     instructions, then set end_prologue_addr to the address of the
     instruction immediately after the last one we scanned.  */
  /* brobecker/2004-10-10: I don't think this would ever happen, but
     we may as well be careful and do our best if we have a null
     end_prologue_addr.  */
  if (end_prologue_addr == 0)
    end_prologue_addr = cur_pc;
     
  /* In a frameless function, we might have incorrectly
     skipped some load immediate instructions. Undo the skipping
     if the load immediate was not followed by a stack adjustment.  */
  if (load_immediate_bytes && !seen_sp_adjust)
    end_prologue_addr -= load_immediate_bytes;
d2667 1
a2667 1
  return end_prologue_addr;
@


1.333
log
@        * mips-tdep.c (mips16_scan_prologue): Merge code from
        mips16_skip_prologue.  Now return the address of the first
        instruction past the function prologue.
        (mips16_skip_prologue): Remove, no longer necessary.
        (mips_skip_prologue): Replace call to mips16_skip_prologue
        by call to mips16_scan_prologue.
@
text
@d445 11
d1752 1
a1752 1
    heuristic_proc_desc (start_addr, pc, next_frame, *this_cache);
d1855 1
a1855 1
    heuristic_proc_desc (start_addr, pc, next_frame, *this_cache);
d2272 1
a2272 1
mips16_scan_prologue (CORE_ADDR start_pc, CORE_ADDR limit_pc, CORE_ADDR sp,
d2278 1
d2291 10
d2489 1
a2489 1
mips32_scan_prologue (CORE_ADDR start_pc, CORE_ADDR limit_pc, CORE_ADDR sp,
d2495 1
d2503 10
a2685 9
  CORE_ADDR sp;

  /* Can be called when there's no process, and hence when there's no
     NEXT_FRAME.  */
  if (next_frame != NULL)
    sp = read_next_frame_reg (next_frame, NUM_REGS + MIPS_SP_REGNUM);
  else
    sp = 0;

d2688 1
a2693 2
  if (start_pc + 200 < limit_pc)
    limit_pc = start_pc + 200;
d2695 1
a2695 1
    mips16_scan_prologue (start_pc, limit_pc, sp, next_frame, this_cache);
d2697 2
a2698 1
    mips32_scan_prologue (start_pc, limit_pc, sp, next_frame, this_cache);
d5022 1
a5022 1
    return mips16_scan_prologue (pc, limit_pc, 0, NULL, NULL);
d5024 1
a5024 1
    return mips32_scan_prologue (pc, limit_pc, 0, NULL, NULL);
@


1.332
log
@        * mips-tdep.c (mips32_scan_prologue): Merge code from
        mips32_skip_prologue.  Now return the address of the first
        instruction past the function prologue.
        (mips32_skip_prologue): Remove.  No longer necessary.
        (mips16_skip_prologue): Add parameter end_pc instead of
        computing it.
        (mips_skip_prologue): Compute the upper limit for the
        prologue scanning. Update call to mips16_skip_prologue.
        Replace call to mips32_skip_prologue by call to
        mips32_scan_prologue.
@
text
@d2257 2
a2258 1
   the associated FRAME_CACHE if not null.  */
d2260 1
a2260 1
static void
d2275 4
d2287 15
d2365 13
d2432 8
a4964 93
/* Skip the PC past function prologue instructions (16-bit version).
   This is a helper function for mips_skip_prologue.  */

static CORE_ADDR
mips16_skip_prologue (CORE_ADDR pc, CORE_ADDR end_pc)
{
  int extend_bytes = 0;
  int prev_extend_bytes;

  /* Table of instructions likely to be found in a function prologue.  */
  static struct
  {
    unsigned short inst;
    unsigned short mask;
  }
  table[] =
  {
    {
    0x6300, 0xff00}
    ,				/* addiu $sp,offset */
    {
    0xfb00, 0xff00}
    ,				/* daddiu $sp,offset */
    {
    0xd000, 0xf800}
    ,				/* sw reg,n($sp) */
    {
    0xf900, 0xff00}
    ,				/* sd reg,n($sp) */
    {
    0x6200, 0xff00}
    ,				/* sw $ra,n($sp) */
    {
    0xfa00, 0xff00}
    ,				/* sd $ra,n($sp) */
    {
    0x673d, 0xffff}
    ,				/* move $s1,sp */
    {
    0xd980, 0xff80}
    ,				/* sw $a0-$a3,n($s1) */
    {
    0x6704, 0xff1c}
    ,				/* move reg,$a0-$a3 */
    {
    0xe809, 0xf81f}
    ,				/* entry pseudo-op */
    {
    0x0100, 0xff00}
    ,				/* addiu $s1,$sp,n */
    {
    0, 0}			/* end of table marker */
  };

  /* Skip the typical prologue instructions. These are the stack adjustment
     instruction and the instructions that save registers on the stack
     or in the gcc frame.  */
  for (; pc < end_pc; pc += MIPS16_INSTLEN)
    {
      unsigned short inst;
      int i;

      inst = mips_fetch_instruction (pc);

      /* Normally we ignore an extend instruction.  However, if it is
         not followed by a valid prologue instruction, we must adjust
         the pc back over the extend so that it won't be considered
         part of the prologue.  */
      if ((inst & 0xf800) == 0xf000)	/* extend */
	{
	  extend_bytes = MIPS16_INSTLEN;
	  continue;
	}
      prev_extend_bytes = extend_bytes;
      extend_bytes = 0;

      /* Check for other valid prologue instructions besides extend.  */
      for (i = 0; table[i].mask != 0; i++)
	if ((inst & table[i].mask) == table[i].inst)	/* found, get out */
	  break;
      if (table[i].mask != 0)	/* it was in table? */
	continue;		/* ignore it */
      else
	/* non-prologue */
	{
	  /* Return the current pc, adjusted backwards by 2 if
	     the previous instruction was an extend.  */
	  return pc - prev_extend_bytes;
	}
    }
  return pc;
}

d4998 1
a4998 1
    return mips16_skip_prologue (pc, limit_pc);
@


1.331
log
@        * mips-tdep.c (mips16_scan_prologue): Remove redundant code.
@
text
@d2422 2
a2423 1
   the associated FRAME_CACHE if not null.  */
d2425 1
a2425 1
static void
d2435 4
d2466 1
d2474 1
a2474 2
	  /* Irix 6.2 N32 ABI uses sd instructions for saving $gp and
	     $ra.  */
d2536 39
d2588 17
a4923 94
/* Skip the PC past function prologue instructions (32-bit version).
   This is a helper function for mips_skip_prologue.  */

static CORE_ADDR
mips32_skip_prologue (CORE_ADDR pc)
{
  t_inst inst;
  CORE_ADDR end_pc;
  int seen_sp_adjust = 0;
  int load_immediate_bytes = 0;

  /* Find an upper bound on the prologue.  */
  end_pc = skip_prologue_using_sal (pc);
  if (end_pc == 0)
    end_pc = pc + 100;		/* Magic.  */

  /* Skip the typical prologue instructions. These are the stack adjustment
     instruction and the instructions that save registers on the stack
     or in the gcc frame.  */
  for (; pc < end_pc; pc += MIPS_INSTLEN)
    {
      unsigned long high_word;

      inst = mips_fetch_instruction (pc);
      high_word = (inst >> 16) & 0xffff;

      if (high_word == 0x27bd	/* addiu $sp,$sp,offset */
	  || high_word == 0x67bd)	/* daddiu $sp,$sp,offset */
	seen_sp_adjust = 1;
      else if (inst == 0x03a1e823 ||	/* subu $sp,$sp,$at */
	       inst == 0x03a8e823)	/* subu $sp,$sp,$t0 */
	seen_sp_adjust = 1;
      else if (((inst & 0xFFE00000) == 0xAFA00000	/* sw reg,n($sp) */
		|| (inst & 0xFFE00000) == 0xFFA00000)	/* sd reg,n($sp) */
	       && (inst & 0x001F0000))	/* reg != $zero */
	continue;

      else if ((inst & 0xFFE00000) == 0xE7A00000)	/* swc1 freg,n($sp) */
	continue;
      else if ((inst & 0xF3E00000) == 0xA3C00000 && (inst & 0x001F0000))
	/* sx reg,n($s8) */
	continue;		/* reg != $zero */

      /* move $s8,$sp.  With different versions of gas this will be either
         `addu $s8,$sp,$zero' or `or $s8,$sp,$zero' or `daddu s8,sp,$0'.
         Accept any one of these.  */
      else if (inst == 0x03A0F021 || inst == 0x03a0f025 || inst == 0x03a0f02d)
	continue;

      else if ((inst & 0xFF9F07FF) == 0x00800021)	/* move reg,$a0-$a3 */
	continue;
      else if (high_word == 0x3c1c)	/* lui $gp,n */
	continue;
      else if (high_word == 0x279c)	/* addiu $gp,$gp,n */
	continue;
      else if (inst == 0x0399e021	/* addu $gp,$gp,$t9 */
	       || inst == 0x033ce021)	/* addu $gp,$t9,$gp */
	continue;
      /* The following instructions load $at or $t0 with an immediate
         value in preparation for a stack adjustment via
         subu $sp,$sp,[$at,$t0]. These instructions could also initialize
         a local variable, so we accept them only before a stack adjustment
         instruction was seen.  */
      else if (!seen_sp_adjust)
	{
	  if (high_word == 0x3c01 ||	/* lui $at,n */
	      high_word == 0x3c08)	/* lui $t0,n */
	    {
	      load_immediate_bytes += MIPS_INSTLEN;	/* FIXME!! */
	      continue;
	    }
	  else if (high_word == 0x3421 ||	/* ori $at,$at,n */
		   high_word == 0x3508 ||	/* ori $t0,$t0,n */
		   high_word == 0x3401 ||	/* ori $at,$zero,n */
		   high_word == 0x3408)	/* ori $t0,$zero,n */
	    {
	      load_immediate_bytes += MIPS_INSTLEN;	/* FIXME!! */
	      continue;
	    }
	  else
	    break;
	}
      else
	break;
    }

  /* In a frameless function, we might have incorrectly
     skipped some load immediate instructions. Undo the skipping
     if the load immediate was not followed by a stack adjustment.  */
  if (load_immediate_bytes && !seen_sp_adjust)
    pc -= load_immediate_bytes;
  return pc;
}

d4928 1
a4928 1
mips16_skip_prologue (CORE_ADDR pc)
a4929 1
  CORE_ADDR end_pc;
a4977 5
  /* Find an upper bound on the prologue.  */
  end_pc = skip_prologue_using_sal (pc);
  if (end_pc == 0)
    end_pc = pc + 100;		/* Magic.  */

d5034 1
d5042 7
d5050 1
a5050 1
    return mips16_skip_prologue (pc);
d5052 1
a5052 1
    return mips32_skip_prologue (pc);
@


1.330
log
@        * mips-tdep.c (mips16_scan_prologue): Renames
        mips16_heuristic_proc_desc. Update comment.
        (mips32_scan_prologue): Renames mips32_heuristic_proc_desc.
        (heuristic_proc_desc): Update calls to the 2 functions above.
@
text
@a2398 30

  /* The MIPS16 entry instruction saves $s0 and $s1 in the reverse
     order of that normally used by gcc.  Therefore, we have to fetch
     the first instruction of the function, and if it's an entry
     instruction that saves $s0 or $s1, correct their saved addresses.  */
  /* FIXME: brobecker/2004-10-10: This code was moved here from
     mips_insn16_frame_cache(), but can be merged with the block above
     handling entry_inst.  Will be done in a separate pass, to make changes
     more atomic.  Actually, this code seems completely redundant!  */
    {
      ULONGEST inst = mips16_fetch_instruction (start_pc);
      if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700) /* entry */
	{
	  int reg;
	  int sreg_count = (inst >> 6) & 3;
	  CORE_ADDR reg_position = (this_cache->base);

	  /* Check if the ra register was pushed on the stack.  */
	  if (inst & 0x20)
	    reg_position -= mips_abi_regsize (current_gdbarch);

	  /* Check if the s0 and s1 registers were pushed on the stack.  */
	  /* NOTE: cagney/2004-02-08: Huh?  This is doing no such check.  */
	  for (reg = 16; reg < sreg_count + 16; reg++)
	    {
	      this_cache->saved_regs[NUM_REGS + reg].addr = reg_position;
	      reg_position -= mips_abi_regsize (current_gdbarch);
	    }
	}
    }
@


1.329
log
@        * mips-tdep.c (mips_insn16_frame_cache): Remove unused variables.
        Update comments. Also immediately return empty cache when the start
        address of our function could not be found.
        (mips_insn32_frame_cache): Likewise.
@
text
@d2224 1
a2224 1
   for mips16_heuristic_proc_desc.  */
d2256 2
a2257 2
/* Fill in values in temp_proc_desc based on the MIPS16 instruction
   stream from start_pc to limit_pc.  */
d2260 3
a2262 4
mips16_heuristic_proc_desc (CORE_ADDR start_pc, CORE_ADDR limit_pc,
			    CORE_ADDR sp,
			    struct frame_info *next_frame,
			    struct mips_frame_cache *this_cache)
d2451 3
d2455 3
a2457 3
mips32_heuristic_proc_desc (CORE_ADDR start_pc, CORE_ADDR limit_pc,
			    CORE_ADDR sp, struct frame_info *next_frame,
			    struct mips_frame_cache *this_cache)
d2460 1
a2460 1
  CORE_ADDR frame_addr = 0;	/* Value of $r30. Used by gcc for frame-pointer */
d2600 1
a2600 2
    mips16_heuristic_proc_desc (start_pc, limit_pc, sp,
				next_frame, this_cache);
d2602 1
a2602 2
    mips32_heuristic_proc_desc (start_pc, limit_pc, sp,
				next_frame, this_cache);
@


1.328
log
@        * mips-tdep.c (mips16_decode_reg_save): Delete, no longer used.
        (mips_insn16_frame_cache): Pass frame cache in call to
        heuristic_proc_desc. Move some code to mips16_heuristic_proc_desc.
        Remove code that became redundant as a consequence.
        (mips32_heuristic_proc_desc): No longer compute a fake
        procedure descriptor. Compute the full frame cache instead.
        Some minor comment reformatting.
@
text
@a1719 1
  mips_extra_func_info_t proc_desc;
a1720 6
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  /* r0 bit means kernel trap */
  int kernel_trap;
  /* What registers have been saved?  Bitmasks.  */
  unsigned long gen_mask, float_mask;
d1728 1
a1728 1
  /* Synthesize a proc descriptor.  */
d1736 4
d1741 1
a1741 1
    proc_desc = heuristic_proc_desc (start_addr, pc, next_frame, *this_cache);
a1821 1
  mips_extra_func_info_t proc_desc;
a1822 6
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  /* r0 bit means kernel trap */
  int kernel_trap;
  /* What registers have been saved?  Bitmasks.  */
  unsigned long gen_mask, float_mask;
d1831 1
a1831 1
  /* Synthesize a proc descriptor.  */
d1839 4
d1844 1
a1844 1
    proc_desc = heuristic_proc_desc (start_addr, pc, next_frame, *this_cache);
a1846 6
  if (proc_desc == NULL)
    /* I'm not sure how/whether this can happen.  Normally when we
       can't find a proc_desc, we "synthesize" one using
       heuristic_proc_desc and set the saved_regs right away.  */
    return cache;

@


1.327
log
@	From Maciej W. Rozycki  <macro@@mips.com>:
	* mips-tdep.c (mips32_next_pc): Check the register's contents,
	not its number for BLEZ/BLEZL and BGTZ/BGTZL.
@
text
@a947 24
/* Decode a MIPS16 instruction that saves a register in the stack, and
   set the appropriate bit in the general register or float register mask
   to indicate which register is saved.  This is a helper function
   for mips_find_saved_regs.  */

static void
mips16_decode_reg_save (t_inst inst, unsigned long *gen_mask)
{
  if ((inst & 0xf800) == 0xd000)	/* sw reg,n($sp) */
    {
      int reg = mips16_to_32_reg[(inst & 0x700) >> 8];
      *gen_mask |= (1 << reg);
    }
  else if ((inst & 0xff00) == 0xf900)	/* sd reg,n($sp) */
    {
      int reg = mips16_to_32_reg[(inst & 0xe0) >> 5];
      *gen_mask |= (1 << reg);
    }
  else if ((inst & 0xff00) == 0x6200	/* sw $ra,n($sp) */
	   || (inst & 0xff00) == 0xfa00)	/* sd $ra,n($sp) */
    *gen_mask |= (1 << RA_REGNUM);
}


a1743 1
#ifdef NOT_YET
a1744 3
#else
    proc_desc = heuristic_proc_desc (start_addr, pc, next_frame, NULL);
#endif
a1746 141
  /* Extract the frame's base.  */
  cache->base = (frame_unwind_register_signed (next_frame, NUM_REGS + PROC_FRAME_REG (proc_desc))
		 + PROC_FRAME_OFFSET (proc_desc) - PROC_FRAME_ADJUST (proc_desc));

  kernel_trap = PROC_REG_MASK (proc_desc) & 1;
  gen_mask = kernel_trap ? 0xFFFFFFFF : PROC_REG_MASK (proc_desc);
  float_mask = kernel_trap ? 0xFFFFFFFF : PROC_FREG_MASK (proc_desc);
  
  /* In any frame other than the innermost or a frame interrupted by a
     signal, we assume that all registers have been saved.  This
     assumes that all register saves in a function happen before the
     first function call.  */
  if (in_prologue (frame_pc_unwind (next_frame), PROC_LOW_ADDR (proc_desc))
      /* Not sure exactly what kernel_trap means, but if it means the
	 kernel saves the registers without a prologue doing it, we
	 better not examine the prologue to see whether registers
	 have been saved yet.  */
      && !kernel_trap)
    {
      /* We need to figure out whether the registers that the
         proc_desc claims are saved have been saved yet.  */

      CORE_ADDR addr;

      /* Bitmasks; set if we have found a save for the register.  */
      unsigned long gen_save_found = 0;
      unsigned long float_save_found = 0;
      int mips16;

      /* If the address is odd, assume this is MIPS16 code.  */
      addr = PROC_LOW_ADDR (proc_desc);

      /* Scan through this function's instructions preceding the
         current PC, and look for those that save registers.  */
      while (addr < frame_pc_unwind (next_frame))
	{
          mips16_decode_reg_save (mips16_fetch_instruction (addr),
                                  &gen_save_found);
          addr += MIPS16_INSTLEN;
	}
      gen_mask = gen_save_found;
      float_mask = float_save_found;
    }

  /* Fill in the offsets for the registers which gen_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (cache->base
			      + PROC_REG_OFFSET (proc_desc));
    int ireg;
    for (ireg = MIPS_NUMREGS - 1; gen_mask; --ireg, gen_mask <<= 1)
      if (gen_mask & 0x80000000)
	{
	  cache->saved_regs[NUM_REGS + ireg].addr = reg_position;
	  reg_position -= mips_abi_regsize (gdbarch);
	}
  }

  /* The MIPS16 entry instruction saves $s0 and $s1 in the reverse
     order of that normally used by gcc.  Therefore, we have to fetch
     the first instruction of the function, and if it's an entry
     instruction that saves $s0 or $s1, correct their saved addresses.  */
    {
      ULONGEST inst = mips16_fetch_instruction (PROC_LOW_ADDR (proc_desc));
      if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)
	/* entry */
	{
	  int reg;
	  int sreg_count = (inst >> 6) & 3;

	  /* Check if the ra register was pushed on the stack.  */
	  CORE_ADDR reg_position = (cache->base
				    + PROC_REG_OFFSET (proc_desc));
	  if (inst & 0x20)
	    reg_position -= mips_abi_regsize (gdbarch);

	  /* Check if the s0 and s1 registers were pushed on the
	     stack.  */
	  /* NOTE: cagney/2004-02-08: Huh?  This is doing no such
             check.  */
	  for (reg = 16; reg < sreg_count + 16; reg++)
	    {
	      cache->saved_regs[NUM_REGS + reg].addr = reg_position;
	      reg_position -= mips_abi_regsize (gdbarch);
	    }
	}
    }

  /* Fill in the offsets for the registers which float_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (cache->base
			      + PROC_FREG_OFFSET (proc_desc));
    int ireg;
    /* Fill in the offsets for the float registers which float_mask
       says were saved.  */
    for (ireg = MIPS_NUMREGS - 1; float_mask; --ireg, float_mask <<= 1)
      if (float_mask & 0x80000000)
	{
	  if (mips_abi_regsize (gdbarch) == 4
	      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    {
	      /* On a big endian 32 bit ABI, floating point registers
	         are paired to form doubles such that the most
	         significant part is in $f[N+1] and the least
	         significant in $f[N] vis: $f[N+1] ||| $f[N].  The
	         registers are also spilled as a pair and stored as a
	         double.

	         When little-endian the least significant part is
	         stored first leading to the memory order $f[N] and
	         then $f[N+1].

	         Unfortunately, when big-endian the most significant
	         part of the double is stored first, and the least
	         significant is stored second.  This leads to the
	         registers being ordered in memory as firt $f[N+1] and
	         then $f[N].

	         For the big-endian case make certain that the
	         addresses point at the correct (swapped) locations
	         $f[N] and $f[N+1] pair (keep in mind that
	         reg_position is decremented each time through the
	         loop).  */
	      if ((ireg & 1))
		cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
		  .addr = reg_position - mips_abi_regsize (gdbarch);
	      else
		cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
		  .addr = reg_position + mips_abi_regsize (gdbarch);
	    }
	  else
	    cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
	      .addr = reg_position;
	  reg_position -= mips_abi_regsize (gdbarch);
	}

    cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->pc]
      = cache->saved_regs[NUM_REGS + RA_REGNUM];
  }

d2279 3
a2285 4
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  PROC_FRAME_OFFSET (&temp_proc_desc) = 0;	/* size of stack frame */
  PROC_FRAME_ADJUST (&temp_proc_desc) = 0;	/* offset of FP from SP */
d2300 1
a2300 1
	    PROC_FRAME_OFFSET (&temp_proc_desc) -= offset;
a2310 1
	  PROC_REG_MASK (&temp_proc_desc) |= (1 << reg);
a2316 1
	  PROC_REG_MASK (&temp_proc_desc) |= (1 << reg);
a2321 1
	  PROC_REG_MASK (&temp_proc_desc) |= (1 << RA_REGNUM);
a2326 1
	  PROC_REG_MASK (&temp_proc_desc) |= (1 << RA_REGNUM);
d2332 1
a2332 1
	  PROC_FRAME_REG (&temp_proc_desc) = 17;
d2338 2
a2339 2
	  PROC_FRAME_REG (&temp_proc_desc) = 17;
	  PROC_FRAME_ADJUST (&temp_proc_desc) = offset;
a2344 1
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << reg;
a2350 1
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << reg;
d2353 2
a2354 1
      else if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)	/* entry */
d2372 1
a2372 1
      PROC_FRAME_OFFSET (&temp_proc_desc) += 32;
d2376 1
a2376 1
      sp += PROC_FRAME_OFFSET (&temp_proc_desc);
a2380 1
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << reg;
a2388 1
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << RA_REGNUM;
a2395 1
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << reg;
d2400 42
@


1.326
log
@        * mips-tdep.c (mips32_decode_reg_save): Remove, unused.
        (mips32_fetch_instruction): Remove, unused.
@
text
@d1170 1
a1170 1
	  if (read_signed_register (itype_rs (inst) <= 0))
d1178 1
a1178 1
	  if (read_signed_register (itype_rs (inst) > 0))
@


1.325
log
@        * mips-tdep.c (mips_insn16_frame_cache): Remove dead code or
        conditions that will always be true.
@
text
@a947 33
/* Decode a MIPS32 instruction that saves a register in the stack, and
   set the appropriate bit in the general register mask or float register mask
   to indicate which register is saved.  This is a helper function
   for mips_find_saved_regs.  */

static void
mips32_decode_reg_save (t_inst inst, unsigned long *gen_mask,
			unsigned long *float_mask)
{
  int reg;

  if ((inst & 0xffe00000) == 0xafa00000	/* sw reg,n($sp) */
      || (inst & 0xffe00000) == 0xafc00000	/* sw reg,n($r30) */
      || (inst & 0xffe00000) == 0xffa00000)	/* sd reg,n($sp) */
    {
      /* It might be possible to use the instruction to
         find the offset, rather than the code below which
         is based on things being in a certain order in the
         frame, but figuring out what the instruction's offset
         is relative to might be a little tricky.  */
      reg = (inst & 0x001f0000) >> 16;
      *gen_mask |= (1 << reg);
    }
  else if ((inst & 0xffe00000) == 0xe7a00000	/* swc1 freg,n($sp) */
	   || (inst & 0xffe00000) == 0xe7c00000	/* swc1 freg,n($r30) */
	   || (inst & 0xffe00000) == 0xf7a00000)	/* sdc1 freg,n($sp) */

    {
      reg = ((inst & 0x001f0000) >> 16);
      *float_mask |= (1 << reg);
    }
}

a1009 14
static ULONGEST
mips32_fetch_instruction (CORE_ADDR addr)
{
  char buf[MIPS_INSTLEN];
  int instlen;
  int status;
  instlen = MIPS_INSTLEN;
  status = deprecated_read_memory_nobpt (addr, buf, instlen);
  if (status)
    memory_error (status, addr);
  return extract_unsigned_integer (buf, instlen);
}


@


1.324
log
@        * mips-tdep.c (mips_insn32_frame_cache): Pass frame cache in
        call to heuristic_proc_desc. Remove code that became redundant
        as a consequence.
        (read_next_frame_reg): Remove special case for SP_REGNUM.
        (set_reg_offset): Fix small typo.
        (reset_saved_regs): New procedure.
        (mips32_heuristic_proc_desc): No longer compute a fake
        procedure descriptor. Compute the full frame cache instead.
        Some minor comment reformatting.
@
text
@a1852 1
      mips16 = pc_is_mips16 (addr);
d1858 3
a1860 12
	  if (mips16)
	    {
	      mips16_decode_reg_save (mips16_fetch_instruction (addr),
				      &gen_save_found);
	      addr += MIPS16_INSTLEN;
	    }
	  else
	    {
	      mips32_decode_reg_save (mips32_fetch_instruction (addr),
				      &gen_save_found, &float_save_found);
	      addr += MIPS_INSTLEN;
	    }
a1883 1
  if (pc_is_mips16 (PROC_LOW_ADDR (proc_desc)))
@


1.323
log
@2004-09-13  Andrew Cagney  <cagney@@gnu.org>

	* config/i386/nm-i386.h (TARGET_HAS_HARDWARE_WATCHPOINTS): Delete.
	* config/s390/nm-linux.h (TARGET_HAS_HARDWARE_WATCHPOINTS): Delete.
	* config/pa/nm-hppah.h (TARGET_HAS_HARDWARE_WATCHPOINTS): Delete.
	* config/ia64/nm-linux.h (TARGET_HAS_HARDWARE_WATCHPOINTS): Delete.
	* config/frv/tm-frv.h (TARGET_HAS_HARDWARE_WATCHPOINTS): Delete.
	* mips-tdep.c (mips_dump_tdep): Do not print same.
@
text
@d2063 1
a2076 1
#ifdef NOT_YET
a2077 3
#else
    proc_desc = heuristic_proc_desc (start_addr, pc, next_frame, NULL);
#endif
a2085 111
  /* Extract the frame's base.  */
  cache->base = (frame_unwind_register_signed (next_frame, NUM_REGS + PROC_FRAME_REG (proc_desc))
		 + PROC_FRAME_OFFSET (proc_desc) - PROC_FRAME_ADJUST (proc_desc));

  kernel_trap = PROC_REG_MASK (proc_desc) & 1;
  gen_mask = kernel_trap ? 0xFFFFFFFF : PROC_REG_MASK (proc_desc);
  float_mask = kernel_trap ? 0xFFFFFFFF : PROC_FREG_MASK (proc_desc);
  
  /* In any frame other than the innermost or a frame interrupted by a
     signal, we assume that all registers have been saved.  This
     assumes that all register saves in a function happen before the
     first function call.  */
  if (in_prologue (frame_pc_unwind (next_frame), PROC_LOW_ADDR (proc_desc))
      /* Not sure exactly what kernel_trap means, but if it means the
	 kernel saves the registers without a prologue doing it, we
	 better not examine the prologue to see whether registers
	 have been saved yet.  */
      && !kernel_trap)
    {
      /* We need to figure out whether the registers that the
         proc_desc claims are saved have been saved yet.  */

      CORE_ADDR addr;

      /* Bitmasks; set if we have found a save for the register.  */
      unsigned long gen_save_found = 0;
      unsigned long float_save_found = 0;

      addr = PROC_LOW_ADDR (proc_desc);

      /* Scan through this function's instructions preceding the
         current PC, and look for those that save registers.  */
      while (addr < frame_pc_unwind (next_frame))
	{
          mips32_decode_reg_save (mips32_fetch_instruction (addr),
                                  &gen_save_found, &float_save_found);
          addr += MIPS_INSTLEN;
	}
      gen_mask = gen_save_found;
      float_mask = float_save_found;
    }

  /* Fill in the offsets for the registers which gen_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (cache->base
			      + PROC_REG_OFFSET (proc_desc));
    int ireg;
    for (ireg = MIPS_NUMREGS - 1; gen_mask; --ireg, gen_mask <<= 1)
      if (gen_mask & 0x80000000)
	{
	  cache->saved_regs[NUM_REGS + ireg].addr = reg_position;
	  reg_position -= mips_abi_regsize (gdbarch);
	}
  }

  /* Fill in the offsets for the registers which float_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (cache->base + PROC_FREG_OFFSET (proc_desc));
    int ireg;

    /* Fill in the offsets for the float registers which float_mask
       says were saved.  */
    for (ireg = MIPS_NUMREGS - 1; float_mask; --ireg, float_mask <<= 1)
      if (float_mask & 0x80000000)
	{
          const int regno =
            NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg;

	  if (mips_abi_regsize (gdbarch) == 4
	      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    {
	      /* On a big endian 32 bit ABI, floating point registers
	         are paired to form doubles such that the most
	         significant part is in $f[N+1] and the least
	         significant in $f[N] vis: $f[N+1] ||| $f[N].  The
	         registers are also spilled as a pair and stored as a
	         double.

	         When little-endian the least significant part is
	         stored first leading to the memory order $f[N] and
	         then $f[N+1].

	         Unfortunately, when big-endian the most significant
	         part of the double is stored first, and the least
	         significant is stored second.  This leads to the
	         registers being ordered in memory as firt $f[N+1] and
	         then $f[N].

	         For the big-endian case make certain that the
	         addresses point at the correct (swapped) locations
	         $f[N] and $f[N+1] pair (keep in mind that
	         reg_position is decremented each time through the
	         loop).  */
	      if ((ireg & 1))
		cache->saved_regs[regno].addr =
                  reg_position - mips_abi_regsize (gdbarch);
	      else
		cache->saved_regs[regno].addr =
                 reg_position + mips_abi_regsize (gdbarch);
	    }
	  else
	    cache->saved_regs[regno].addr = reg_position;
	  reg_position -= mips_abi_regsize (gdbarch);
	}

    cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->pc]
      = cache->saved_regs[NUM_REGS + RA_REGNUM];
  }

a2261 6
  else if ((regno % NUM_REGS) == MIPS_SP_REGNUM)
    /* MIPS_SP_REGNUM is special, its value is stored in saved_regs.
       In fact, it is so special that it can even only be fetched
       using a raw register number!  Once this code as been converted
       to frame-unwind the problem goes away.  */
    return frame_unwind_register_signed (fi, regno % NUM_REGS);
d2339 1
a2339 1
      && this_cache->saved_regs[regnum].addr == 0)
d2638 20
d2665 3
d2669 2
a2670 2
  PROC_FRAME_OFFSET (&temp_proc_desc) = 0;
  PROC_FRAME_ADJUST (&temp_proc_desc) = 0;	/* offset of FP from SP */
d2689 1
a2689 1
	    PROC_FRAME_OFFSET (&temp_proc_desc) += 0x10000 - low_word;
a2697 1
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << reg;
a2703 1
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << reg;
d2709 1
a2709 1
	  if ((long) low_word != PROC_FRAME_OFFSET (&temp_proc_desc))
d2711 1
a2711 1
	  else if (PROC_FRAME_REG (&temp_proc_desc) == MIPS_SP_REGNUM)
d2714 2
a2715 1
	      PROC_FRAME_REG (&temp_proc_desc) = 30;
d2720 3
a2722 4
		  /* FP > SP + frame_size. This may be because
		   * of an alloca or somethings similar.
		   * Fix sp to "pre-alloca" value, and try again.
		   */
d2724 5
d2739 1
a2739 1
	  if (PROC_FRAME_REG (&temp_proc_desc) == MIPS_SP_REGNUM)
d2742 2
a2743 1
	      PROC_FRAME_REG (&temp_proc_desc) = 30;
d2747 12
a2758 8
		{
		  /* FP > SP + frame_size. This may be because
		   * of an alloca or somethings similar.
		   * Fix sp to "pre-alloca" value, and try again.
		   */
		  sp += alloca_adjust;
		  goto restart;
		}
a2762 1
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << reg;
d2766 12
@


1.322
log
@        * mips-tdep.c (mips_insn16_frame_cache): Fix parameter in call to
        heuristic_proc_desc.
        (mips_insn32_frame_cache): Likewise.
@
text
@a6606 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TARGET_HAS_HARDWARE_WATCHPOINTS # %s\n",
		      XSTRING (TARGET_HAS_HARDWARE_WATCHPOINTS));
@


1.321
log
@        * mips-tdep.c (mips32_heuristic_proc_desc): Remove code that was
        left behind by error.
@
text
@d1816 1
a1816 1
    proc_desc = heuristic_proc_desc (start_addr, pc, next_frame, this_cache);
d2077 1
a2077 1
    proc_desc = heuristic_proc_desc (start_addr, pc, next_frame, this_cache);
@


1.320
log
@2004-09-03  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (PROC_DESC_IS_DUMMY, SET_PROC_DESC_IS_DUMMY)
	(_PROC_MAGIC_, after_prologue, mips_dump_tdep): Delete macros and
	only use.
@
text
@a2765 2
  this_cache = xrealloc (this_cache, SIZEOF_FRAME_SAVED_REGS);
  memset (this_cache, '\0', SIZEOF_FRAME_SAVED_REGS);
@


1.319
log
@2004-09-03  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (temp_saved_regs): Delete.
	(set_reg_offset): Replace saved_regs parameter with this_cache.
	(heuristic_proc_desc, mips16_heuristic_proc_desc)
	(mips32_heuristic_proc_desc): Add this_cache parameter.
	(mips_insn32_frame_cache, mips_insn16_frame_cache)
	(after_prologue): Pass a NULL this_cache.
@
text
@a656 2
#define PROC_DESC_IS_DUMMY(proc) ((proc)->pdr.isym == _PROC_MAGIC_)
#define SET_PROC_DESC_IS_DUMMY(proc) ((proc)->pdr.isym = _PROC_MAGIC_)
d902 1
a902 4
      struct symbol *proc_symbol =
	PROC_DESC_IS_DUMMY (proc_desc) ? 0 : PROC_SYMBOL (proc_desc);

      if (proc_symbol)
d905 2
a906 1
			      (SYMBOL_BLOCK_VALUE (proc_symbol)), 0);
d909 1
a909 1
      if (!proc_symbol || pc < val.pc)
a6548 2
		      "mips_dump_tdep: PROC_DESC_IS_DUMMY = function?\n");
  fprintf_unfiltered (file,
a6576 2
		      "mips_dump_tdep: SET_PROC_DESC_IS_DUMMY = function?\n");
  fprintf_unfiltered (file,
a6640 2
  fprintf_unfiltered (file,
		      "mips_dump_tdep: _PROC_MAGIC_ = %d\n", _PROC_MAGIC_);
@


1.318
log
@2004-09-03  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (mips_mdebug_frame_cache): Delete code handling
	non-kernel trap prologues.
@
text
@a60 1
static void set_reg_offset (CORE_ADDR *saved_regs, int regnum, CORE_ADDR off);
d422 1
d424 2
a425 1
						   struct frame_info *);
d916 1
a916 1
	    heuristic_proc_desc (PROC_LOW_ADDR (proc_desc), pc, NULL);
d926 1
a926 1
      proc_desc = heuristic_proc_desc (startaddr, pc, NULL);
d1819 5
a1823 1
    proc_desc = heuristic_proc_desc (start_addr, pc, next_frame);
d2080 5
a2084 1
    proc_desc = heuristic_proc_desc (start_addr, pc, next_frame);
a2446 7
/* This hack will go away once the get_prev_frame() code has been
   modified to set the frame's type first.  That is BEFORE init extra
   frame info et.al.  is called.  This is because it will become
   possible to skip the init extra info call for sigtramp and dummy
   frames.  */
static CORE_ADDR *temp_saved_regs;

d2459 2
a2460 1
set_reg_offset (CORE_ADDR *saved_regs, int regno, CORE_ADDR offset)
d2462 2
a2463 1
  if (saved_regs[regno] == 0)
d2465 2
a2466 2
      saved_regs[regno + 0 * NUM_REGS] = offset;
      saved_regs[regno + 1 * NUM_REGS] = offset;
d2624 3
a2626 1
			    struct frame_info *next_frame, CORE_ADDR sp)
d2664 1
a2664 1
	  set_reg_offset (temp_saved_regs, reg, sp + offset);
d2671 1
a2671 1
	  set_reg_offset (temp_saved_regs, reg, sp + offset);
d2677 1
a2677 1
	  set_reg_offset (temp_saved_regs, RA_REGNUM, sp + offset);
d2683 1
a2683 1
	  set_reg_offset (temp_saved_regs, RA_REGNUM, sp + offset);
d2702 1
a2702 1
	  set_reg_offset (temp_saved_regs, reg, frame_addr + offset);
d2709 1
a2709 1
	  set_reg_offset (temp_saved_regs, reg, frame_addr + offset);
d2739 1
a2739 1
	  set_reg_offset (temp_saved_regs, reg, sp + offset);
d2748 1
a2748 1
	  set_reg_offset (temp_saved_regs, RA_REGNUM, sp + offset);
d2756 1
a2756 1
	  set_reg_offset (temp_saved_regs, reg, sp + offset);
d2764 2
a2765 1
			    struct frame_info *next_frame, CORE_ADDR sp)
d2770 2
a2771 2
  temp_saved_regs = xrealloc (temp_saved_regs, SIZEOF_FRAME_SAVED_REGS);
  memset (temp_saved_regs, '\0', SIZEOF_FRAME_SAVED_REGS);
d2802 1
a2802 1
	  set_reg_offset (temp_saved_regs, reg, sp + low_word);
d2809 1
a2809 1
	  set_reg_offset (temp_saved_regs, reg, sp + low_word);
d2859 1
a2859 1
	  set_reg_offset (temp_saved_regs, reg, frame_addr + low_word);
d2866 2
a2867 1
		     struct frame_info *next_frame)
a2880 2
  temp_saved_regs = xrealloc (temp_saved_regs, SIZEOF_FRAME_SAVED_REGS);
  memset (temp_saved_regs, '\0', SIZEOF_FRAME_SAVED_REGS);
d2888 2
a2889 1
    mips16_heuristic_proc_desc (start_pc, limit_pc, next_frame, sp);
d2891 2
a2892 1
    mips32_heuristic_proc_desc (start_pc, limit_pc, next_frame, sp);
@


1.317
log
@2004-09-03  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (find_proc_desc): Delete function.
	(mips_mdebug_frame_cache): Inline call to find_proc_desc,
	simplify.
	(mips_insn16_frame_cache): Replace find_proc_desc with code from
	mips_insn32_frame_cache.
@
text
@d1590 4
a1593 45
  /* In any frame other than the innermost or a frame interrupted by a
     signal, we assume that all registers have been saved.  This
     assumes that all register saves in a function happen before the
     first function call.  */
  if (in_prologue (frame_pc_unwind (next_frame), PROC_LOW_ADDR (proc_desc))
      /* Not sure exactly what kernel_trap means, but if it means the
	 kernel saves the registers without a prologue doing it, we
	 better not examine the prologue to see whether registers
	 have been saved yet.  */
      && !kernel_trap)
    {
      /* We need to figure out whether the registers that the
         proc_desc claims are saved have been saved yet.  */

      CORE_ADDR addr;

      /* Bitmasks; set if we have found a save for the register.  */
      unsigned long gen_save_found = 0;
      unsigned long float_save_found = 0;
      int mips16;

      /* If the address is odd, assume this is MIPS16 code.  */
      addr = PROC_LOW_ADDR (proc_desc);
      mips16 = pc_is_mips16 (addr);

      /* Scan through this function's instructions preceding the
         current PC, and look for those that save registers.  */
      while (addr < frame_pc_unwind (next_frame))
	{
	  if (mips16)
	    {
	      mips16_decode_reg_save (mips16_fetch_instruction (addr),
				      &gen_save_found);
	      addr += MIPS16_INSTLEN;
	    }
	  else
	    {
	      mips32_decode_reg_save (mips32_fetch_instruction (addr),
				      &gen_save_found, &float_save_found);
	      addr += MIPS_INSTLEN;
	    }
	}
      gen_mask = gen_save_found;
      float_mask = float_save_found;
    }
@


1.316
log
@
	* mips-tdep.c (find_proc_desc): Inline call to find_proc_desc.
	Simplify as NEXT_FRAME is NULL.
	(find_proc_desc): Simplify as NEXT_FRAME is non-NULL.
@
text
@a433 3
static mips_extra_func_info_t find_proc_desc (CORE_ADDR pc,
					      struct frame_info *next_frame);

d1559 1
d1576 5
a1580 6
  proc_desc = find_proc_desc (frame_pc_unwind (next_frame), next_frame);
  if (proc_desc == NULL)
    /* I'm not sure how/whether this can happen.  Normally when we
       can't find a proc_desc, we "synthesize" one using
       heuristic_proc_desc and set the saved_regs right away.  */
    return cache;
d1850 8
a1857 7
  /* Get the mdebug proc descriptor.  */
  proc_desc = find_proc_desc (frame_pc_unwind (next_frame), next_frame);
  if (proc_desc == NULL)
    /* I'm not sure how/whether this can happen.  Normally when we
       can't find a proc_desc, we "synthesize" one using
       heuristic_proc_desc and set the saved_regs right away.  */
    return cache;
d1859 3
a3142 18

static mips_extra_func_info_t
find_proc_desc (CORE_ADDR pc, struct frame_info *next_frame)
{
  mips_extra_func_info_t proc_desc;
  CORE_ADDR startaddr = 0;

  proc_desc = non_heuristic_proc_desc (pc, &startaddr);
  if (proc_desc == NULL)
    {
      if (startaddr == 0)
	startaddr = heuristic_proc_start (pc);

      proc_desc = heuristic_proc_desc (startaddr, pc, next_frame);
    }
  return proc_desc;
}

@


1.315
log
@2004-09-03  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (after_prologue): Replace proc_desc parameter with
	local variable.
	(mips_skip_prologue): Update.
@
text
@d891 36
d928 2
a929 6
  /* Pass a NULL next_frame to find_proc_desc.  We should not attempt
     to read the stack pointer from the current machine state, because
     the current machine state has nothing to do with the information
     we need from the proc_desc; and the process may or may not exist
     right now.  */
  proc_desc = find_proc_desc (pc, NULL);
d3150 1
a3150 32

  if (proc_desc)
    {
      /* IF this is the topmost frame AND
       * (this proc does not have debugging information OR
       * the PC is in the procedure prologue)
       * THEN create a "heuristic" proc_desc (by analyzing
       * the actual code) to replace the "official" proc_desc.
       */
      if (next_frame == NULL)
	{
	  struct symtab_and_line val;
	  struct symbol *proc_symbol =
	    PROC_DESC_IS_DUMMY (proc_desc) ? 0 : PROC_SYMBOL (proc_desc);

	  if (proc_symbol)
	    {
	      val = find_pc_line (BLOCK_START
				  (SYMBOL_BLOCK_VALUE (proc_symbol)), 0);
	      val.pc = val.end ? val.end : pc;
	    }
	  if (!proc_symbol || pc < val.pc)
	    {
	      mips_extra_func_info_t found_heuristic =
		heuristic_proc_desc (PROC_LOW_ADDR (proc_desc),
				     pc, next_frame);
	      if (found_heuristic)
		proc_desc = found_heuristic;
	    }
	}
    }
  else
@


1.314
log
@2004-09-03  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (find_proc_desc, heuristic_proc_desc): Delete
	"cur_frame" parameter.
	(after_prologue, mips_mdebug_frame_cache, mips_insn16_frame_cache):
@
text
@d437 1
a437 2
static CORE_ADDR after_prologue (CORE_ADDR pc,
				 mips_extra_func_info_t proc_desc);
d886 1
a886 1
after_prologue (CORE_ADDR pc, mips_extra_func_info_t proc_desc)
d888 1
d897 1
a897 2
  if (!proc_desc)
    proc_desc = find_proc_desc (pc, NULL);
d5441 1
a5441 1
  CORE_ADDR post_prologue_pc = after_prologue (pc, NULL);
@


1.313
log
@        * mips-tdep.c (mips_insn32_frame_cache): Remove some dead code.
        Minor reformatting. Some code factoring.
@
text
@d424 1
a424 1
						   struct frame_info *, int);
d435 1
a435 2
					      struct frame_info *next_frame,
					      int cur_frame);
d892 1
a892 1
  /* Pass cur_frame == 0 to find_proc_desc.  We should not attempt
d898 1
a898 1
    proc_desc = find_proc_desc (pc, NULL, 0);
d1547 1
a1547 1
  proc_desc = find_proc_desc (frame_pc_unwind (next_frame), next_frame, 1);
d1823 1
a1823 1
  proc_desc = find_proc_desc (frame_pc_unwind (next_frame), next_frame, 1);
d2084 1
a2084 1
    proc_desc = heuristic_proc_desc (start_addr, pc, next_frame, 1);
d2868 1
a2868 1
		     struct frame_info *next_frame, int cur_frame)
d2872 3
a2874 1
  if (cur_frame)
d3113 1
a3113 1
find_proc_desc (CORE_ADDR pc, struct frame_info *next_frame, int cur_frame)
d3144 1
a3144 1
				     pc, next_frame, cur_frame);
d3155 1
a3155 1
      proc_desc = heuristic_proc_desc (startaddr, pc, next_frame, cur_frame);
@


1.312
log
@        * mips-tdep.c (linked_proc_desc_table): Delete, not used.
        (mips_insn32_frame_cache): Inline call to find_proc_desc.
        (find_proc_desc): Remove dead code.
@
text
@a2120 1
      int mips16;
a2121 1
      /* If the address is odd, assume this is MIPS16 code.  */
a2122 1
      mips16 = pc_is_mips16 (addr);
d2128 3
a2130 12
	  if (mips16)
	    {
	      mips16_decode_reg_save (mips16_fetch_instruction (addr),
				      &gen_save_found);
	      addr += MIPS16_INSTLEN;
	    }
	  else
	    {
	      mips32_decode_reg_save (mips32_fetch_instruction (addr),
				      &gen_save_found, &float_save_found);
	      addr += MIPS_INSTLEN;
	    }
a2149 31
  /* The MIPS16 entry instruction saves $s0 and $s1 in the reverse
     order of that normally used by gcc.  Therefore, we have to fetch
     the first instruction of the function, and if it's an entry
     instruction that saves $s0 or $s1, correct their saved addresses.  */
  if (pc_is_mips16 (PROC_LOW_ADDR (proc_desc)))
    {
      ULONGEST inst = mips16_fetch_instruction (PROC_LOW_ADDR (proc_desc));
      if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)
	/* entry */
	{
	  int reg;
	  int sreg_count = (inst >> 6) & 3;

	  /* Check if the ra register was pushed on the stack.  */
	  CORE_ADDR reg_position = (cache->base
				    + PROC_REG_OFFSET (proc_desc));
	  if (inst & 0x20)
	    reg_position -= mips_abi_regsize (gdbarch);

	  /* Check if the s0 and s1 registers were pushed on the
	     stack.  */
	  /* NOTE: cagney/2004-02-08: Huh?  This is doing no such
             check.  */
	  for (reg = 16; reg < sreg_count + 16; reg++)
	    {
	      cache->saved_regs[NUM_REGS + reg].addr = reg_position;
	      reg_position -= mips_abi_regsize (gdbarch);
	    }
	}
    }

d2153 1
a2153 2
    CORE_ADDR reg_position = (cache->base
			      + PROC_FREG_OFFSET (proc_desc));
d2155 1
d2161 3
d2190 2
a2191 2
		cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
		  .addr = reg_position - mips_abi_regsize (gdbarch);
d2193 2
a2194 2
		cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
		  .addr = reg_position + mips_abi_regsize (gdbarch);
d2197 1
a2197 2
	    cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
	      .addr = reg_position;
@


1.311
log
@        * mips-tdep.c (mips_mdebug_frame_cache): Minor reformatting.
@
text
@a663 7
struct linked_proc_info
{
  struct mips_extra_func_info info;
  struct linked_proc_info *next;
}
 *linked_proc_desc_table = NULL;

d2076 12
a2087 2
  /* Get the mdebug proc descriptor.  */
  proc_desc = find_proc_desc (frame_pc_unwind (next_frame), next_frame, 1);
a3191 12
      /* Is linked_proc_desc_table really necessary?  It only seems to be used
         by procedure call dummys.  However, the procedures being called ought
         to have their own proc_descs, and even if they don't,
         heuristic_proc_desc knows how to create them! */

      struct linked_proc_info *link;

      for (link = linked_proc_desc_table; link; link = link->next)
	if (PROC_LOW_ADDR (&link->info) <= pc
	    && PROC_HIGH_ADDR (&link->info) > pc)
	  return &link->info;

@


1.310
log
@        * mips-tdep.c: Include "floatformat.h".
        (n32n64_floatformat_always_valid): New function.
        (floatformat_n32n64_long_double_big): New constant.
        (mips_gdbarch_init): Set size and format of long double
        for N32 and N64 ABIs.
        * Makefile.in (mips-tdep.o): Update dependencies.
@
text
@d1619 1
a1619 2
    CORE_ADDR reg_position = (cache->base
			      + PROC_REG_OFFSET (proc_desc));
d1621 1
@


1.309
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (mips_gdbarch_init, mips_insn16_frame_cache)
	(mips_insn16_frame_this_id, mips_insn16_frame_prev_register)
	(mips_insn16_frame_unwind, mips_insn16_frame_sniffer)
	(mips_insn16_frame_base_address, mips_insn16_frame_base)
	(mips_insn16_frame_base_sniffer, mips_insn32_frame_cache)
	(mips_insn32_frame_this_id, mips_insn32_frame_prev_register)
	(mips_insn32_frame_unwind, mips_insn32_frame_sniffer)
	(mips_insn32_frame_base_address, mips_insn32_frame_base)
	(mips_insn32_frame_base_sniffer): Replace mips16 / mips32 prefix
	with mips_insn16 and mips_insn32.
@
text
@d57 1
d153 26
d6353 3
d6366 3
@


1.308
log
@2004-08-01  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (mips16_frame_cache)
	(mips16_frame_this_id, mips16_frame_prev_register)
	(mips16_frame_unwind, mips16_frame_sniffer)
	(mips16_frame_base_address, mips16_frame_base)
	(mips16_frame_base_sniffer, mips32_frame_cache)
	(mips32_frame_this_id, mips32_frame_prev_register)
	(mips32_frame_unwind, mips32_frame_sniffer)
	(mips32_frame_base_address, mips32_frame_base)
	(mips32_frame_base_sniffer): Clone the mdebug unwinder into
	separate heuristic mips16 and mips32 unwinders.
	(mips_stub_frame_cache, mips_stub_frame_this_id)
	(mips_stub_frame_prev_register)
	(mips_stub_frame_unwind, mips_stub_frame_sniffer)
	(mips_stub_frame_base_address, mips_stub_frame_base)
	(mips_stub_frame_base_sniffer): Add a simple stub unwinder.
	(mips_mdebug_frame_base_sniffer, mips_mdebug_frame_sniffer): Only
	match true mdebug frames.
	(non_heuristic_proc_desc): Add forward declaration.
@
text
@d1781 4
d1786 1
a1786 1
mips16_frame_cache (struct frame_info *next_frame, void **this_cache)
d1970 1
a1970 1
mips16_frame_this_id (struct frame_info *next_frame, void **this_cache,
d1973 1
a1973 1
  struct mips_frame_cache *info = mips16_frame_cache (next_frame,
d1979 1
a1979 1
mips16_frame_prev_register (struct frame_info *next_frame,
d1985 1
a1985 1
  struct mips_frame_cache *info = mips16_frame_cache (next_frame,
d1991 1
a1991 1
static const struct frame_unwind mips16_frame_unwind =
d1994 2
a1995 2
  mips16_frame_this_id,
  mips16_frame_prev_register
d1999 1
a1999 1
mips16_frame_sniffer (struct frame_info *next_frame)
d2003 1
a2003 1
    return &mips16_frame_unwind;
d2008 1
a2008 1
mips16_frame_base_address (struct frame_info *next_frame,
d2011 1
a2011 1
  struct mips_frame_cache *info = mips16_frame_cache (next_frame,
d2016 1
a2016 1
static const struct frame_base mips16_frame_base =
d2018 4
a2021 4
  &mips16_frame_unwind,
  mips16_frame_base_address,
  mips16_frame_base_address,
  mips16_frame_base_address
d2025 1
a2025 1
mips16_frame_base_sniffer (struct frame_info *next_frame)
d2027 2
a2028 2
  if (mips16_frame_sniffer (next_frame) != NULL)
    return &mips16_frame_base;
d2033 5
d2039 1
a2039 1
mips32_frame_cache (struct frame_info *next_frame, void **this_cache)
d2223 1
a2223 1
mips32_frame_this_id (struct frame_info *next_frame, void **this_cache,
d2226 1
a2226 1
  struct mips_frame_cache *info = mips32_frame_cache (next_frame,
d2232 1
a2232 1
mips32_frame_prev_register (struct frame_info *next_frame,
d2238 1
a2238 1
  struct mips_frame_cache *info = mips32_frame_cache (next_frame,
d2244 1
a2244 1
static const struct frame_unwind mips32_frame_unwind =
d2247 2
a2248 2
  mips32_frame_this_id,
  mips32_frame_prev_register
d2252 1
a2252 1
mips32_frame_sniffer (struct frame_info *next_frame)
d2256 1
a2256 1
    return &mips32_frame_unwind;
d2261 1
a2261 1
mips32_frame_base_address (struct frame_info *next_frame,
d2264 1
a2264 1
  struct mips_frame_cache *info = mips32_frame_cache (next_frame,
d2269 1
a2269 1
static const struct frame_base mips32_frame_base =
d2271 4
a2274 4
  &mips32_frame_unwind,
  mips32_frame_base_address,
  mips32_frame_base_address,
  mips32_frame_base_address
d2278 1
a2278 1
mips32_frame_base_sniffer (struct frame_info *next_frame)
d2280 2
a2281 2
  if (mips32_frame_sniffer (next_frame) != NULL)
    return &mips32_frame_base;
d6439 2
a6440 2
  frame_unwind_append_sniffer (gdbarch, mips16_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, mips32_frame_sniffer);
d6443 2
a6444 2
  frame_base_append_sniffer (gdbarch, mips16_frame_base_sniffer);
  frame_base_append_sniffer (gdbarch, mips32_frame_base_sniffer);
@


1.307
log
@2004-07-31  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Rename
	trad_frame_get_prev_register.
	* vax-tdep.c (vax_frame_prev_register): Update.
	* trad-frame.h: Update.
	* trad-frame.c (trad_frame_get_register): Update.
	* sparcobsd-tdep.c (sparc32obsd_frame_prev_register): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64obsd-tdep.c (sparc64obsd_frame_prev_register): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_prev_register):
	Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-linux-tdep.c (sparc32_linux_sigtramp_frame_prev_register):
	Update.
	* s390-tdep.c (s390_frame_prev_register)
	(s390_stub_frame_prev_register)
	(s390_sigtramp_frame_prev_register): Update.
	* rs6000-tdep.c (rs6000_frame_prev_register): Update.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_prev_register): Update.
	* mips-tdep.c (mips_mdebug_frame_prev_register): Update.
	* m88k-tdep.c (m88k_frame_prev_register)
	* m68hc11-tdep.c (m68hc11_frame_prev_register)
	* m32r-tdep.c (m32r_frame_prev_register): Update.
	* hppa-tdep.c (hppa_frame_prev_register_helper)
	* frv-tdep.c (frv_frame_prev_register): Update.
	* d10v-tdep.c (d10v_frame_prev_register): Update.
	* cris-tdep.c (cris_frame_prev_register): Update.
	* avr-tdep.c (avr_frame_prev_register): Update.
	* arm-tdep.c (arm_prologue_prev_register)
	(arm_sigtramp_prev_register): Update.
@
text
@d398 2
d1725 29
a1753 1
  return &mips_mdebug_frame_unwind;
d1775 595
a2369 1
  return &mips_mdebug_frame_base;
d6428 1
d6430 3
d6434 2
@


1.306
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd): Delete function.
	(add_setshow_cmd_full): Make static.
	* command.h (add_setshow_cmd, add_setshow_cmd_full): Delete.
	(add_setshow_filename_cmd, add_setshow_string_cmd): Declare.
	* cli/cli-decode.c (add_setshow_filename_cmd)
	(add_setshow_string_cmd): New functions.
	* nto-tdep.c (_initialize_nto_tdep): Update.  Fix parameters.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* m32r-rom.c (_initialize_m32r_rom): Update.  Update copyright.
	* cli/cli-logging.c (_initialize_cli_logging): Update.
	* complaints.c (_initialize_complaints): Update.
	* remote.c (_initialize_remote): Update.
@
text
@d1709 2
a1710 2
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
@


1.305
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_zinteger_cmd)
	(add_setshow_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_cmd_full): Add help_doc and
	print parameters.  Make string parameters constant.
	* command.h: Update.  Update copyright.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* complaints.c (_initialize_complaints): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* target.c (initialize_targets): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* d10v-tdep.c (_initialize_d10v_tdep): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
@
text
@d6198 2
a6199 2
  add_setshow_cmd ("remote-mips64-transfers-32bit-regs", class_obscure,
		   var_boolean, &mips64_transfers_32bit_regs_p, "\
@


1.304
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d6189 2
a6190 1
Set zeroing of upper 32 bits of 64-bit addresses.\n\
d6193 1
a6193 1
Show zeroing of upper 32 bits of 64-bit addresses.",
d6200 2
a6201 1
Set compatibility with 64-bit MIPS targets that transfer 32-bit quantities.\n\
d6205 2
a6206 4
Show compatibility with 64-bit MIPS targets that transfer 32-bit quantities.\n\
Use \"on\" to enable backward compatibility with older MIPS 64 GDB+target\n\
that would transfer 32 bits for some registers (e.g. SR, FSR) and\n\
64 bits for others.  Use \"off\" to disable compatibility mode", set_mips64_transfers_32bit_regs, NULL, &setlist, &showlist);
@


1.303
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	* config/mips/tm-mips.h (DEPRECATED_IGNORE_HELPER_CALL): Deprecate.
	* mips-tdep.c (mips_dump_tdep, mips_ignore_helper): Update.
	* infrun.c (DEPRECATED_IGNORE_HELPER_CALL): Delete macro.
	(handle_inferior_event): Wrap call to deprecated
	IGNORE_HELPER_CALL in #ifdef.
	* config/mips/tm-nbsd.h: Update.
@
text
@d6107 4
a6110 4
  add_show_from_set (add_set_enum_cmd ("saved-gpreg-size",
				       class_obscure,
				       size_enums,
				       &mips_abi_regsize_string, "\
d6120 5
a6124 4
  add_show_from_set (add_set_enum_cmd ("stack-arg-size",
				       class_obscure,
				       size_enums,
				       &mips_stack_argsize_string, "\
d6130 2
a6131 1
          target and executable (default)", &setmipscmdlist), &showmipscmdlist);
d6184 1
a6184 1
  add_show_from_set (c, &showlist);
d6209 5
a6213 3
  add_show_from_set (add_set_cmd ("mips", class_maintenance, var_zinteger,
				  &mips_debug, "Set mips debugging.\n\
When non-zero, mips specific debugging is enabled.", &setdebuglist), &showdebuglist);
@


1.302
log
@2004-07-20  Andrew Cagney  <cagney@@gnu.org>

	* breakpoint.c (deprecated_read_memory_nobpt): Rename
	read_memory_nobpt.
	* sparc-linux-tdep.c (sparc_linux_sigtramp_start): Update.
	* s390-tdep.c (s390_readinstruction, s390_in_function_epilogue_p)
	(s390_sigtramp_frame_sniffer): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue): Update.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Update.
	* mips-tdep.c (mips_fetch_instruction, mips16_fetch_instruction)
	(mips32_fetch_instruction): Update.
	* mcore-tdep.c (get_insn): Update.
	* m68klinux-tdep.c (m68k_linux_pc_in_sigtramp): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_offset): Update.
	* i386ly-tdep.c (i386lynx_saved_pc_after_call): Update.
	* i386-linux-tdep.c (i386_linux_sigtramp_start)
	(i386_linux_rt_sigtramp_start): Update.
	* i386-linux-nat.c (child_resume): Update.
	* hppa-tdep.c (skip_prologue_hard_way, hppa_frame_cache): Update.
	* hppa-linux-tdep.c (insns_match_pattern): Update.
	* gdbcore.h: Update.
	* frv-tdep.c (frv_gdbarch_adjust_breakpoint_address): Update.
	* frame.c (safe_frame_unwind_memory): Update.
	* amd64-linux-tdep.c (amd64_linux_sigtramp_start): Update.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Update.
	* alpha-tdep.c (alpha_read_insn): Update.
@
text
@d5263 3
a5265 2
/* Return non-zero if the PC is in a library helper function that should
   be ignored.  This implements the IGNORE_HELPER_CALL macro.  */
d5934 2
a5935 2
		      "mips_dump_tdep: IGNORE_HELPER_CALL # %s\n",
		      XSTRING (IGNORE_HELPER_CALL (PC)));
@


1.301
log
@2004-07-10  Michael Snyder  <msnyder@@redhat.com>

        * symfile.c (generic_load): Comment typo.
        * stack.c (get_selected_block): Ditto.
        * regcache.c (regcache_cooked_read): Ditto.
        * monitor.c (monitor_debug): Ditto.
        * mips-tdep.c (mips_read_pc): Ditto.
        * i386-linux-nat.c (ps_get_thread_area): Ditto.
        * gdb_mbuild.sh: Ditto.
        * gdbarch.sh: Ditto.
        * gdbarch.h: Ditto.
@
text
@d976 1
a976 1
  status = read_memory_nobpt (addr, buf, instlen);
d991 1
a991 1
  status = read_memory_nobpt (addr, buf, instlen);
d1004 1
a1004 1
  status = read_memory_nobpt (addr, buf, instlen);
@


1.300
log
@2004-06-21  Martin Hunt  <hunt@@redhat.com>
	Kevin Buettner <kevinb@@redhat.com>

        * config/mips/tm-mips.h (SP_REGNUM): Delete define.
	* mips-tdep.h (MIPS_SP_REGNUM): Define.
	* mips-tdep.c (mips_gdbarch_init): Set SP_REGNUM via call
	to set_gdbarch_sp_regnum().  Use cooked register number.
        (SP_REGNUM): Replace all occurrences with MIPS_SP_REGNUM.
@
text
@d828 1
a828 1
/* MIPS believes that the PC has a sign extended value.  Perhaphs the
@


1.299
log
@2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_USE_STRUCT_CONVENTION): Deprecated.
	* gdbarch.h, gdbarch.c: Re-generate.
	* values.c (using_struct_return): Update call.
	* mcore-tdep.c: Update comment.
	* infcall.c (call_function_by_hand): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* arch-utils.h (always_use_struct_convention): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	USE_STRUCT_CONVENTION.
@
text
@d760 1
a760 1
  return read_signed_register (SP_REGNUM);
d852 1
a852 1
  return frame_id_build (frame_unwind_register_signed (next_frame, NUM_REGS + SP_REGNUM),
d883 1
a883 1
      if (PROC_FRAME_REG (proc_desc) == SP_REGNUM
d1686 1
a1686 1
  trad_frame_set_value (cache->saved_regs, NUM_REGS + SP_REGNUM, cache->base);
d1759 2
a1760 2
  else if ((regno % NUM_REGS) == SP_REGNUM)
    /* The SP_REGNUM is special, its value is stored in saved_regs.
d2197 1
a2197 1
	  else if (PROC_FRAME_REG (&temp_proc_desc) == SP_REGNUM)
d2220 1
a2220 1
	  if (PROC_FRAME_REG (&temp_proc_desc) == SP_REGNUM)
d2252 1
a2252 1
    sp = read_next_frame_reg (next_frame, NUM_REGS + SP_REGNUM);
d2262 1
a2262 1
  PROC_FRAME_REG (&temp_proc_desc) = SP_REGNUM;
d3029 1
a3029 1
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);
d3315 1
a3315 1
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);
d3730 1
a3730 1
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);
d4184 1
a4184 1
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);
d5615 2
a5616 1
    set_gdbarch_pc_regnum (gdbarch, regnum->pc);
@


1.298
log
@2004-06-15  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (non_heuristic_proc_desc): Delete call to
	deprecated_pc_in_call_dummy.
@
text
@d5648 1
a5648 2
      set_gdbarch_use_struct_convention (gdbarch,
					 always_use_struct_convention);
d5664 1
a5664 2
      set_gdbarch_use_struct_convention (gdbarch,
					 mips_eabi_use_struct_convention);
d5680 1
a5680 2
      set_gdbarch_use_struct_convention (gdbarch,
					 mips_eabi_use_struct_convention);
@


1.297
log
@2004-06-11  Martin Hunt  <hunt@@redhat.com>

	* mips-tdep.c (mips_gdbarch_init): Recognize vr4120
	has no fpu.
@
text
@a2307 3
  if (deprecated_pc_in_call_dummy (pc))
    return NULL;

@


1.296
log
@2004-06-10  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h (deprecated_pc_in_call_dummy): Delete "sp" and "fp"
	parameters.
	* dummy-frame.c (deprecated_pc_in_call_dummy): Update.
	* arm-tdep.c (arm_pc_is_thumb_dummy): Call
	deprecated_pc_in_call_dummy instead of
	DEPRECATED_PC_IN_CALL_DUMMY.
	(arm_skip_prologue): Ditto.
	* xstormy16-tdep.c (xstormy16_pop_frame, xstormy16_scan_prologue)
	(xstormy16_frame_saved_pc, xstormy16_frame_chain): Ditto.
	* v850-tdep.c (v850_find_callers_reg, v850_frame_chain)
	(v850_pop_frame, v850_frame_saved_pc, v850_frame_init_saved_regs):
	Ditto.
	* sh64-tdep.c (sh64_frame_chain, sh64_get_saved_pr)
	(sh64_init_extra_frame_info, sh64_get_saved_register)
	(sh64_pop_frame): Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* mcore-tdep.c (mcore_find_callers_reg, mcore_frame_saved_pc)
	(mcore_pop_frame, mcore_init_extra_frame_info): Ditto.
	* h8300-tdep.c (h8300_frame_chain, h8300_frame_saved_pc)
	(h8300_pop_frame): Ditto.
	* blockframe.c (legacy_inside_entry_func)
	(legacy_frame_chain_valid): Ditto.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update call
	to deprecated_pc_in_call_dummy.
@
text
@d5519 1
@


1.295
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d2308 1
a2308 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (pc, 0, 0))
@


1.294
log
@2004-05-03  Michael Snyder  <msnyder@@redhat.com>

        * mips-tdep.c (mips_gdbarch_init): Fix typo in comment.
        (heuristic_proc_start): Whitespace cleanup.
@
text
@d56 1
d2771 1
a2771 1
mips_eabi_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
d2782 1
d3090 1
a3090 1
mips_n32n64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
d3101 1
d3429 1
a3429 1
mips_o32_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
d3440 1
d3882 1
a3882 1
mips_o64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
d3894 1
@


1.293
log
@2004-04-30  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_pc_in_sigtramp): Delete.
	(mips_gdbarch_init): Do not set pc_in_sigtramp.
	* mipsread.c (sigtramp_address): Delete extern variable.
	(mipscoff_new_init): Delete reference.
	* mdebugread.c (sigtramp_address, sigtramp_end): Delete variables.
	(fixup_sigtramp): Delete function.
	* config/mips/tm-mips.h (sigtramp_address, sigtramp_end)
	(fixup_sigtramp): Delete declarations.
@
text
@d1908 2
a1909 3
	    warning
	      ("GDB can't find the start of the function at 0x%s.",
	       paddr_nz (pc));
d5443 1
a5443 1
  /* If we have no usefu BFD information, use the ABI from the last
@


1.292
log
@2004-04-29  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_register_type): Re-write, handle 32-bit ABI
	registers correctly.
	(print_gp_register_row, mips32_heuristic_proc_desc)
	(mips_n32n64_push_dummy_call, mips_o32_push_dummy_call)
	(mips_o64_push_dummy_call, mips_eabi_push_dummy_call): Eliminate
	references to mips_isa_regsize.
@
text
@a4843 10
/* Exported procedure: Is PC in the signal trampoline code */

static int
mips_pc_in_sigtramp (CORE_ADDR pc, char *ignore)
{
  if (sigtramp_address == 0)
    fixup_sigtramp ();
  return (pc >= sigtramp_address && pc < sigtramp_end);
}

a5773 1
  set_gdbarch_deprecated_pc_in_sigtramp (gdbarch, mips_pc_in_sigtramp);
@


1.291
log
@2004-04-29  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (struct gdbarch_tdep): Delete
	mips_fp_register_double.
	(FP_REGISTER_DOUBLE): Delete macro, replace with test for
	mips_abi_regsize.
	(mips_gdbarch_init): Do not set mips_fp_register_double.
	(mips_dump_tdep): Do not print FP_REGISTER_DOUBLE.
@
text
@d720 9
a728 15
  else if (regnum >=
	   (NUM_REGS + mips_regnum (current_gdbarch)->fp_control_status)
	   && regnum <= NUM_REGS + LAST_EMBED_REGNUM)
    /* The pseudo/cooked view of the embedded registers is always
       32-bit.  The raw view is handled below.  */
    return builtin_type_int32;
  else if (regnum >= NUM_REGS && mips_isa_regsize (gdbarch)
	   && gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p)
    /* The target, while using a 64-bit register buffer, is only
       transfering 32-bits of each integer register.  Reflect this in
       the cooked/pseudo register value.  */
    return builtin_type_int32;
  else if (mips_isa_regsize (gdbarch) == 8)
    /* 64-bit ISA.  */
    return builtin_type_int64;
d730 22
a751 2
    /* 32-bit ISA.  */
    return builtin_type_int32;
d2187 2
a2188 3
	  /* Irix 6.2 N32 ABI uses sd instructions for saving $gp and $ra,
	     but the register size used is only 32 bits. Make the address
	     for the saved register point to the lower 32 bits.  */
d2190 1
a2190 2
	  set_reg_offset (temp_saved_regs, reg,
			  sp + low_word + 8 - mips_isa_regsize (current_gdbarch));
d2925 4
a2928 4
	     mips_isa_regsize() are treated specially: Irix cc passes them
	     in registers where gcc sometimes puts them on the stack.
	     For maximum compatibility, we will put them in both
	     places.  */
d3186 4
a3189 4
	     mips_isa_regsize() are treated specially: Irix cc passes them
	     in registers where gcc sometimes puts them on the stack.
	     For maximum compatibility, we will put them in both
	     places.  */
d3583 4
a3586 4
	     mips_isa_regsize() are treated specially: Irix cc passes them
	     in registers where gcc sometimes puts them on the stack.
	     For maximum compatibility, we will put them in both
	     places.  */
d4036 4
a4039 4
	     mips_isa_regsize() are treated specially: Irix cc passes them
	     in registers where gcc sometimes puts them on the stack.
	     For maximum compatibility, we will put them in both
	     places.  */
d4490 1
a4490 1
  int ncols = (mips_isa_regsize (gdbarch) == 8 ? 4 : 8);	/* display cols per row */
d4505 1
a4505 1
			mips_isa_regsize (current_gdbarch) == 8 ? "%17s" : "%9s",
d4529 1
a4529 1
	   byte < (mips_isa_regsize (current_gdbarch)
@


1.290
log
@2004-04-29  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_abi_regsize): Replace tdep parameter with
	gdbarch, use mips_abi, update callers.
	(mips_stack_argsize): Replace tdep parameter with gdbarch, use
	mips_abi_regsize, update callers.
	(struct gdbarch_tdep): Delete mips_default_stack_argsize and
	mips_default_abi_regsize.
	(mips_gdbarch_init): Do not set mips_default_stack_argsize and
	mips_default_abi_regsize.
@
text
@d110 1
a110 2
   support single-precision floating-point operations.  See also
   FP_REGISTER_DOUBLE. */
a138 1
  int mips_fp_register_double;
a375 5
/* Indicate that the ABI makes use of double-precision registers
   provided by the FPU (rather than combining pairs of registers to
   form double-precision values).  See also MIPS_FPU_TYPE.  */
#define FP_REGISTER_DOUBLE (gdbarch_tdep (current_gdbarch)->mips_fp_register_double)

d2642 1
a2642 1
      if (!FP_REGISTER_DOUBLE && len == 8)
d2645 1
a2645 1
	     spread them across a floating-point register pair. */
d2853 2
a2854 1
      if (!FP_REGISTER_DOUBLE && fp_register_arg_p (typecode, arg_type))
d2875 1
a2875 1
	  if (!FP_REGISTER_DOUBLE && len == 8)
d3493 2
a3494 1
      if (!FP_REGISTER_DOUBLE && fp_register_arg_p (typecode, arg_type))
d3513 1
a3513 1
	  if (!FP_REGISTER_DOUBLE && len == 8)
d3560 1
a3560 1
	      argreg += FP_REGISTER_DOUBLE ? 1 : 2;
d3946 2
a3947 1
      if (!FP_REGISTER_DOUBLE && fp_register_arg_p (typecode, arg_type))
d3966 1
a3966 1
	  if (!FP_REGISTER_DOUBLE && len == 8)
d4013 1
a4013 1
	      argreg += FP_REGISTER_DOUBLE ? 1 : 2;
a5624 1
      tdep->mips_fp_register_double = 0;
a5637 1
      tdep->mips_fp_register_double = 1;
a5652 1
      tdep->mips_fp_register_double = 0;
a5669 1
      tdep->mips_fp_register_double = 1;
a5683 1
      tdep->mips_fp_register_double = 1;
a5693 1
      tdep->mips_fp_register_double = 1;
a5897 3
		      "mips_dump_tdep: FP_REGISTER_DOUBLE = %d\n",
		      FP_REGISTER_DOUBLE);
  fprintf_unfiltered (file,
a5911 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: FP_REGISTER_DOUBLE = %d\n",
		      FP_REGISTER_DOUBLE);
@


1.289
log
@2004-04-29  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_abi_regsize): Rename mips_saved_regsize.
	(mips_abi_regsize_string): Rename mips_saved_regsize_string.
	(struct gdbarch_tdep): Rename mips_default_saved_regsize to
	mips_default_abi_regsize.
	(mips_isa_regsize): Rename mips_regisze.
	* mipsnbsd-tdep.c: Update.
	* mips-linux-tdep.c: Update.
	* irix5-nat.c: Update.
	* mips-tdep.h (mips_isa_regsize): Update.
@
text
@a139 1
  int mips_default_abi_regsize;
a140 1
  int mips_default_stack_argsize;
d245 1
a245 1
mips_abi_regsize (struct gdbarch_tdep *tdep)
d248 15
a262 1
    return tdep->mips_default_abi_regsize;
d390 1
a390 1
mips_stack_argsize (struct gdbarch_tdep *tdep)
d393 1
a393 1
    return tdep->mips_default_stack_argsize;
d1589 1
a1589 1
	  reg_position -= mips_abi_regsize (tdep);
d1610 1
a1610 1
	    reg_position -= mips_abi_regsize (tdep);
d1619 1
a1619 1
	      reg_position -= mips_abi_regsize (tdep);
d1635 1
a1635 1
	  if (mips_abi_regsize (tdep) == 4
d1662 1
a1662 1
		  .addr = reg_position - mips_abi_regsize (tdep);
d1665 1
a1665 1
		  .addr = reg_position + mips_abi_regsize (tdep);
d1670 1
a1670 1
	  reg_position -= mips_abi_regsize (tdep);
d2115 1
a2115 1
	  offset += mips_abi_regsize (tdep);
d2124 1
a2124 1
	  offset -= mips_abi_regsize (tdep);
d2132 1
a2132 1
	  offset -= mips_abi_regsize (tdep);
d2690 1
a2690 1
	  && len < mips_abi_regsize (tdep))
d2693 1
a2693 1
	  lo->reg_offset = mips_abi_regsize (tdep) - len;
d2698 2
a2699 2
      else if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG && len > mips_abi_regsize (tdep)	/* odd-size structs */
	       && len < mips_abi_regsize (tdep) * 2
d2704 2
a2705 2
	  lo->reg_offset = 2 * mips_abi_regsize (tdep) - len;
	  lo->len = mips_abi_regsize (tdep) - lo->reg_offset;
d2714 1
a2714 1
	  if (len > mips_abi_regsize (tdep))
d2716 2
a2717 2
	      lo->len = mips_abi_regsize (tdep);
	      hi->len = len - mips_abi_regsize (tdep);
d2727 1
a2727 1
	  && mips_abi_regsize (tdep) == 4)
d2745 1
a2745 1
  return (TYPE_LENGTH (type) > 2 * mips_abi_regsize (tdep));
d2760 1
a2760 1
    return (len > mips_abi_regsize (tdep));
d2800 1
a2800 1
		     mips_stack_argsize (tdep));
d2841 1
a2841 1
      if (len > mips_abi_regsize (tdep)
d2844 1
a2844 1
	  store_unsigned_integer (valbuf, mips_abi_regsize (tdep),
d2847 1
a2847 1
	  len = mips_abi_regsize (tdep);
d2923 2
a2924 2
	  int odd_sized_struct = ((len > mips_abi_regsize (tdep))
				  && (len % mips_abi_regsize (tdep) != 0));
d2932 2
a2933 2
	      int partial_len = (len < mips_abi_regsize (tdep)
				 ? len : mips_abi_regsize (tdep));
d2951 1
a2951 1
		      if (mips_stack_argsize (tdep) == 8
d2955 1
a2955 1
			longword_offset = mips_stack_argsize (tdep) - len;
d2959 2
a2960 2
				   < mips_stack_argsize (tdep)))
			longword_offset = mips_stack_argsize (tdep) - len;
d3002 1
a3002 1
					    mips_abi_regsize (tdep)));
d3018 1
a3018 1
					  mips_stack_argsize (tdep));
d3115 1
a3115 1
		     mips_stack_argsize (tdep));
d3184 2
a3185 2
	  int odd_sized_struct = ((len > mips_abi_regsize (tdep))
				  && (len % mips_abi_regsize (tdep) != 0));
d3192 2
a3193 2
	      int partial_len = (len < mips_abi_regsize (tdep)
				 ? len : mips_abi_regsize (tdep));
d3211 1
a3211 1
		      if (mips_stack_argsize (tdep) == 8
d3215 1
a3215 1
			longword_offset = mips_stack_argsize (tdep) - len;
d3277 1
a3277 1
		      && partial_len < mips_abi_regsize (tdep)
d3280 1
a3280 1
		    regval <<= ((mips_abi_regsize (tdep) - partial_len) *
d3287 1
a3287 1
					    mips_abi_regsize (tdep)));
d3303 1
a3303 1
					  mips_stack_argsize (tdep));
d3325 1
a3325 1
      || TYPE_LENGTH (type) > 2 * mips_abi_regsize (tdep))
d3453 1
a3453 1
		     mips_stack_argsize (tdep));
d3473 1
a3473 1
      stack_offset += mips_stack_argsize (tdep);
d3568 1
a3568 1
	  stack_offset += align_up (len, mips_stack_argsize (tdep));
d3580 2
a3581 2
	  int odd_sized_struct = ((len > mips_abi_regsize (tdep))
				  && (len % mips_abi_regsize (tdep) != 0));
d3584 1
a3584 1
	  if (mips_abi_regsize (tdep) < 8
d3596 2
a3597 2
	      int partial_len = (len < mips_abi_regsize (tdep)
				 ? len : mips_abi_regsize (tdep));
d3615 1
a3615 1
		      if (mips_stack_argsize (tdep) == 8
d3619 1
a3619 1
			longword_offset = mips_stack_argsize (tdep) - len;
d3683 1
a3683 1
		  if (mips_abi_regsize (tdep) < 8
d3685 1
a3685 1
		      && partial_len < mips_abi_regsize (tdep)
d3688 1
a3688 1
		    regval <<= ((mips_abi_regsize (tdep) - partial_len) *
d3695 1
a3695 1
					    mips_abi_regsize (tdep)));
d3716 1
a3716 1
					mips_stack_argsize (tdep));
d3853 1
a3853 1
	   offset += mips_stack_argsize (tdep), regnum++)
d3855 1
a3855 1
	  int xfer = mips_stack_argsize (tdep);
d3905 1
a3905 1
		     mips_stack_argsize (tdep));
d3925 1
a3925 1
      stack_offset += mips_stack_argsize (tdep);
d4020 1
a4020 1
	  stack_offset += align_up (len, mips_stack_argsize (tdep));
d4032 2
a4033 2
	  int odd_sized_struct = ((len > mips_abi_regsize (tdep))
				  && (len % mips_abi_regsize (tdep) != 0));
d4036 1
a4036 1
	  if (mips_abi_regsize (tdep) < 8
d4048 2
a4049 2
	      int partial_len = (len < mips_abi_regsize (tdep)
				 ? len : mips_abi_regsize (tdep));
d4067 1
a4067 1
		      if (mips_stack_argsize (tdep) == 8
d4071 1
a4071 1
			longword_offset = mips_stack_argsize (tdep) - len;
d4135 1
a4135 1
		  if (mips_abi_regsize (tdep) < 8
d4137 1
a4137 1
		      && partial_len < mips_abi_regsize (tdep)
d4140 1
a4140 1
		    regval <<= ((mips_abi_regsize (tdep) - partial_len) *
d4147 1
a4147 1
					    mips_abi_regsize (tdep)));
d4168 1
a4168 1
					mips_stack_argsize (tdep));
a5628 2
      tdep->mips_default_abi_regsize = 4;
      tdep->mips_default_stack_argsize = 4;
a5642 2
      tdep->mips_default_abi_regsize = 8;
      tdep->mips_default_stack_argsize = 8;
a5658 2
      tdep->mips_default_abi_regsize = 4;
      tdep->mips_default_stack_argsize = 4;
a5676 2
      tdep->mips_default_abi_regsize = 8;
      tdep->mips_default_stack_argsize = 8;
a5691 2
      tdep->mips_default_abi_regsize = 8;
      tdep->mips_default_stack_argsize = 8;
a5702 2
      tdep->mips_default_abi_regsize = 8;
      tdep->mips_default_stack_argsize = 8;
d5930 1
a5930 1
		      mips_stack_argsize (tdep));
d5990 1
a5990 1
		      mips_abi_regsize (tdep));
@


1.288
log
@2004-04-21  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (heuristic_proc_start):
	Warning() already prefixes "Warning: ".
@
text
@d140 1
a140 1
  int mips_default_saved_regsize;
d236 1
a236 1
mips_regsize (struct gdbarch *gdbarch)
d244 1
a244 1
static const char *mips_saved_regsize_string = size_auto;
d247 1
a247 1
mips_saved_regsize (struct gdbarch_tdep *tdep)
d249 3
a251 3
  if (mips_saved_regsize_string == size_auto)
    return tdep->mips_default_saved_regsize;
  else if (mips_saved_regsize_string == size_64)
d253 1
a253 1
  else				/* if (mips_saved_regsize_string == size_32) */
d372 1
a372 1
   different to MIPS_SAVED_REGSIZE as it determines the alignment of
d697 1
a697 1
         mips_regsize(), and also map 1:1, byte for byte.  */
d701 1
a701 1
	  if (mips_regsize (gdbarch) == 4)
d706 1
a706 1
	  if (mips_regsize (gdbarch) == 4)
d721 1
a721 1
  else if (regnum >= NUM_REGS && mips_regsize (gdbarch)
d727 1
a727 1
  else if (mips_regsize (gdbarch) == 8)
d1577 1
a1577 1
	  reg_position -= mips_saved_regsize (tdep);
d1598 1
a1598 1
	    reg_position -= mips_saved_regsize (tdep);
d1607 1
a1607 1
	      reg_position -= mips_saved_regsize (tdep);
d1623 1
a1623 1
	  if (mips_saved_regsize (tdep) == 4
d1650 1
a1650 1
		  .addr = reg_position - mips_saved_regsize (tdep);
d1653 1
a1653 1
		  .addr = reg_position + mips_saved_regsize (tdep);
d1658 1
a1658 1
	  reg_position -= mips_saved_regsize (tdep);
d2103 1
a2103 1
	  offset += mips_saved_regsize (tdep);
d2112 1
a2112 1
	  offset -= mips_saved_regsize (tdep);
d2120 1
a2120 1
	  offset -= mips_saved_regsize (tdep);
d2173 1
a2173 1
			  sp + low_word + 8 - mips_regsize (current_gdbarch));
d2678 1
a2678 1
	  && len < mips_saved_regsize (tdep))
d2681 1
a2681 1
	  lo->reg_offset = mips_saved_regsize (tdep) - len;
d2686 2
a2687 2
      else if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG && len > mips_saved_regsize (tdep)	/* odd-size structs */
	       && len < mips_saved_regsize (tdep) * 2
d2692 2
a2693 2
	  lo->reg_offset = 2 * mips_saved_regsize (tdep) - len;
	  lo->len = mips_saved_regsize (tdep) - lo->reg_offset;
d2702 1
a2702 1
	  if (len > mips_saved_regsize (tdep))
d2704 2
a2705 2
	      lo->len = mips_saved_regsize (tdep);
	      hi->len = len - mips_saved_regsize (tdep);
d2715 1
a2715 1
	  && mips_saved_regsize (tdep) == 4)
d2733 1
a2733 1
  return (TYPE_LENGTH (type) > 2 * mips_saved_regsize (tdep));
d2748 1
a2748 1
    return (len > mips_saved_regsize (tdep));
d2829 1
a2829 1
      if (len > mips_saved_regsize (tdep)
d2832 1
a2832 1
	  store_unsigned_integer (valbuf, mips_saved_regsize (tdep),
d2835 1
a2835 1
	  len = mips_saved_regsize (tdep);
d2907 1
a2907 1
	     mips_regsize() are treated specially: Irix cc passes them
d2911 2
a2912 2
	  int odd_sized_struct = ((len > mips_saved_regsize (tdep))
				  && (len % mips_saved_regsize (tdep) != 0));
d2920 2
a2921 2
	      int partial_len = (len < mips_saved_regsize (tdep)
				 ? len : mips_saved_regsize (tdep));
d2990 1
a2990 1
					    mips_saved_regsize (tdep)));
d3168 1
a3168 1
	     mips_regsize() are treated specially: Irix cc passes them
d3172 2
a3173 2
	  int odd_sized_struct = ((len > mips_saved_regsize (tdep))
				  && (len % mips_saved_regsize (tdep) != 0));
d3180 2
a3181 2
	      int partial_len = (len < mips_saved_regsize (tdep)
				 ? len : mips_saved_regsize (tdep));
d3252 1
a3252 1
		     mips_saved_regsize(), generates a left shift as
d3255 1
a3255 1
		     sizeof (struct) >= mips_saved_regsize()).  Since
d3265 1
a3265 1
		      && partial_len < mips_saved_regsize (tdep)
d3268 1
a3268 1
		    regval <<= ((mips_saved_regsize (tdep) - partial_len) *
d3275 1
a3275 1
					    mips_saved_regsize (tdep)));
d3313 1
a3313 1
      || TYPE_LENGTH (type) > 2 * mips_saved_regsize (tdep))
d3564 1
a3564 1
	     mips_regsize() are treated specially: Irix cc passes them
d3568 2
a3569 2
	  int odd_sized_struct = ((len > mips_saved_regsize (tdep))
				  && (len % mips_saved_regsize (tdep) != 0));
d3572 1
a3572 1
	  if (mips_saved_regsize (tdep) < 8
d3584 2
a3585 2
	      int partial_len = (len < mips_saved_regsize (tdep)
				 ? len : mips_saved_regsize (tdep));
d3644 1
a3644 1
		     mips_regsize() != mips_saved_regsize().  */
d3659 1
a3659 1
		     mips_saved_regsize(), generates a left shift as
d3662 1
a3662 1
		     sizeof (struct) >= mips_saved_regsize()).  Since
d3671 1
a3671 1
		  if (mips_saved_regsize (tdep) < 8
d3673 1
a3673 1
		      && partial_len < mips_saved_regsize (tdep)
d3676 1
a3676 1
		    regval <<= ((mips_saved_regsize (tdep) - partial_len) *
d3683 1
a3683 1
					    mips_saved_regsize (tdep)));
d4016 1
a4016 1
	     mips_regsize() are treated specially: Irix cc passes them
d4020 2
a4021 2
	  int odd_sized_struct = ((len > mips_saved_regsize (tdep))
				  && (len % mips_saved_regsize (tdep) != 0));
d4024 1
a4024 1
	  if (mips_saved_regsize (tdep) < 8
d4036 2
a4037 2
	      int partial_len = (len < mips_saved_regsize (tdep)
				 ? len : mips_saved_regsize (tdep));
d4096 1
a4096 1
		     mips_regsize() != mips_saved_regsize().  */
d4111 1
a4111 1
		     mips_saved_regsize(), generates a left shift as
d4114 1
a4114 1
		     sizeof (struct) >= mips_saved_regsize()).  Since
d4123 1
a4123 1
		  if (mips_saved_regsize (tdep) < 8
d4125 1
a4125 1
		      && partial_len < mips_saved_regsize (tdep)
d4128 1
a4128 1
		    regval <<= ((mips_saved_regsize (tdep) - partial_len) *
d4135 1
a4135 1
					    mips_saved_regsize (tdep)));
d4470 1
a4470 1
  int ncols = (mips_regsize (gdbarch) == 8 ? 4 : 8);	/* display cols per row */
d4485 1
a4485 1
			mips_regsize (current_gdbarch) == 8 ? "%17s" : "%9s",
d4509 1
a4509 1
	   byte < (mips_regsize (current_gdbarch)
d5617 1
a5617 1
      tdep->mips_default_saved_regsize = 4;
d5633 1
a5633 1
      tdep->mips_default_saved_regsize = 8;
d5651 1
a5651 1
      tdep->mips_default_saved_regsize = 4;
d5671 1
a5671 1
      tdep->mips_default_saved_regsize = 8;
d5688 1
a5688 1
      tdep->mips_default_saved_regsize = 8;
d5701 1
a5701 1
      tdep->mips_default_saved_regsize = 8;
d5989 2
a5990 2
		      "mips_dump_tdep: mips_saved_regsize() = %d\n",
		      mips_saved_regsize (tdep));
d6124 1
a6124 1
				       &mips_saved_regsize_string, "\
@


1.287
log
@	* mips-tdep.c (mips_pdr_data): New.
	(non_heuristic_proc_desc): Use objfile_data and set_objfile_data.
	(_initialize_mips_tdep): Initialize mips_pdr_data.
@
text
@d1890 1
a1890 1
	      ("Warning: GDB can't find the start of the function at 0x%s.",
@


1.286
log
@	* Makefile.in (mips-linux-tdep.o): Update dependencies.
	* mips-tdep.c (mips_gdbarch_init): Move frame predicates
	to after osabi initialization.
	* mips-linux-tdep.c: Include "trad-frame.h" and "tramp-frame.h".
	(mips_linux_o32_sigframe_init, mips_linux_n32n64_sigframe_init): New
	functions.
	(mips_linux_o32_sigframe, mips_linux_o32_rt_sigframe)
	(mips_linux_n32_rt_sigframe, mips_linux_n64_rt_sigframe): New
	variables.
	(mips_linux_init_abi): Append signal trampoline unwinders.
@
text
@d57 2
d2303 1
a2303 1
      priv = (struct mips_objfile_private *) sec->objfile->obj_private;
d2321 1
a2321 1
	  sec->objfile->obj_private = priv;
d2349 1
a2349 1
	  sec->objfile->obj_private = priv;
d6108 2
@


1.285
log
@2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PC_IN_SIGTRAMP): Change to a function with
	predicate, deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-linux-tdep.c (alpha_linux_init_abi): Update.
	* alpha-osf1-tdep.c (alpha_osf1_init_abi): Update.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Update.
	* alphafbsd-tdep.c (alphafbsd_init_abi): Update.
	* alphanbsd-tdep.c (alphanbsd_init_abi): Update.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Update.
	* amd64-tdep.c (amd64_sigtramp_frame_sniffer): Update.
	* amd64nbsd-tdep.c (amd64nbsd_init_abi): Update.
	* amd64obsd-tdep.c (amd64obsd_init_abi): Update.
	* arm-tdep.c (arm_sigtramp_unwind_sniffer): Update.
	* blockframe.c (find_pc_partial_function): Update.
	* breakpoint.c (bpstat_what): Update.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update.
	* frv-linux-tdep.c (frv_linux_init_abi): Update.
	* frv-tdep.c (frv_sigtramp_frame_sniffer): Update.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* i386-nto-tdep.c (i386nto_init_abi): Update.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Update.
	* i386-tdep.c (i386_sigtramp_frame_sniffer)
	(i386_svr4_init_abi, i386_go32_init_abi, i386_gdbarch_init): Update.
	* i386bsd-tdep.c (i386bsd_init_abi): Update.
	* i386nbsd-tdep.c (i386nbsd_init_abi): Update.
	* i386obsd-tdep.c (i386obsd_init_abi): Update.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Update.
	* infrun.c (pc_in_sigtramp): Update.
	* m68k-tdep.c (m68k_sigtramp_frame_sniffer): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mipsnbsd-tdep.c (mipsnbsd_init_abi): Update.
	* ppc-linux-tdep.c: Update comment.
	* ppcnbsd-tdep.c (ppcnbsd_init_abi): Update.
	* shnbsd-tdep.c (shnbsd_init_abi): Update.
	* sparc-linux-tdep.c (sparc32_linux_init_abi): Update.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Update.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Update.
	* sparcobsd-tdep.c (sparc32obsd_init_abi): Update.

Index: doc/ChangeLog
2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	references to PC_IN_SIGTRAMP.
@
text
@a5743 1
  frame_unwind_append_sniffer (gdbarch, mips_mdebug_frame_sniffer);
a5744 1
  frame_base_append_sniffer (gdbarch, mips_mdebug_frame_base_sniffer);
d5808 4
@


1.284
log
@	* mips-tdep.c (non_heuristic_proc_desc): Search using the specified
	PC rather than the partial function start address.  Use the start
	address to sanity check the found PDR.
@
text
@d5782 1
a5782 1
  set_gdbarch_pc_in_sigtramp (gdbarch, mips_pc_in_sigtramp);
@


1.283
log
@2004-02-17  Andrew Cagney  <cagney@@redhat.com>

	* symtab.c (skip_prologue_using_sal): New function.
	* symtab.h (skip_prologue_using_sal): Declare.
	* frv-tdep.c: Include "symtab.h".
	(skip_prologue_using_sal): Delete function.
	* mips-tdep.c (skip_prologue_using_sal): Delete function.
	* rs6000-tdep.c (refine_prologue_limit): Mention
	skip_prologue_using_sal.
	* ia64-tdep.c (refine_prologue_limit): Ditto.
	* Makefile.in: Update dependencies.
@
text
@d2355 1
d2360 9
a2370 2
	      CORE_ADDR pdr_pc;

d2377 2
a2378 3
	      if (pdr_pc == startaddr)
		break;
	      if (pdr_pc > startaddr)
d2385 23
a2407 1
	  if (low != high)
d2411 3
d2418 1
a2418 1
	      PROC_LOW_ADDR (proc_desc) = startaddr;
@


1.283.4.1
log
@	* mips-tdep.c (mips_pdr_data): New.
	(non_heuristic_proc_desc): Use objfile_data and set_objfile_data.
	(_initialize_mips_tdep): Initialize mips_pdr_data.
@
text
@a56 2
static const struct objfile_data *mips_pdr_data;

d2301 1
a2301 1
      priv = (struct mips_objfile_private *) objfile_data (sec->objfile, mips_pdr_data);
d2319 1
a2319 1
	  set_objfile_data (sec->objfile, mips_pdr_data, priv);
d2347 1
a2347 1
	  set_objfile_data (sec->objfile, mips_pdr_data, priv);
a6071 2

  mips_pdr_data = register_objfile_data ();
@


1.283.2.1
log
@Merge mainline to intercu branch.
@
text
@a2354 1
	  CORE_ADDR pdr_pc;
a2358 9
	  /* We've found a .pdr section describing this objfile.  We want to
	     find the entry which describes this code address.  The .pdr
	     information is not very descriptive; we have only a function
	     start address.  We have to look for the closest entry, because
	     the local symbol at the beginning of this function may have
	     been stripped - so if we ask the symbol table for the start
	     address we may get a preceding global function.  */

	  /* First, find the last .pdr entry starting at or before PC.  */
d2361 2
d2369 3
a2371 2

	      if (pdr_pc > pc)
d2378 1
a2378 23
	  /* Both low and high point one past the PDR of interest.  If
	     both are zero, that means this PC is before any region
	     covered by a PDR, i.e. pdr_pc for the first PDR entry is
	     greater than PC.  */
	  if (low > 0)
	    {
	      ptr = priv->contents + (low - 1) * 32;
	      pdr_pc = bfd_get_signed_32 (sec->objfile->obfd, ptr);
	      pdr_pc += ANOFFSET (sec->objfile->section_offsets,
				  SECT_OFF_TEXT (sec->objfile));
	    }

	  /* We don't have a range, so we have no way to know for sure
	     whether we're in the correct PDR or a PDR for a preceding
	     function and the current function was a stripped local
	     symbol.  But if the PDR's PC is at least as great as the
	     best guess from the symbol table, assume that it does cover
	     the right area; if a .pdr section is present at all then
	     nearly every function will have an entry.  The biggest exception
	     will be the dynamic linker stubs; conveniently these are
	     placed before .text instead of after.  */

	  if (pc >= pdr_pc && pdr_pc >= startaddr)
a2381 3
	      if (addrptr)
		*addrptr = pdr_pc;

d2386 1
a2386 1
	      PROC_LOW_ADDR (proc_desc) = pdr_pc;
d5712 1
d5714 1
d5750 1
a5750 1
  set_gdbarch_deprecated_pc_in_sigtramp (gdbarch, mips_pc_in_sigtramp);
a5777 4

  /* Unwind the frame.  */
  frame_unwind_append_sniffer (gdbarch, mips_mdebug_frame_sniffer);
  frame_base_append_sniffer (gdbarch, mips_mdebug_frame_base_sniffer);
@


1.283.2.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@a56 2
static const struct objfile_data *mips_pdr_data;

d2301 1
a2301 1
      priv = (struct mips_objfile_private *) objfile_data (sec->objfile, mips_pdr_data);
d2319 1
a2319 1
	  set_objfile_data (sec->objfile, mips_pdr_data, priv);
d2347 1
a2347 1
	  set_objfile_data (sec->objfile, mips_pdr_data, priv);
a6105 2

  mips_pdr_data = register_objfile_data ();
@


1.283.2.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a55 2
#include "infcall.h"
#include "floatformat.h"
d59 1
d110 2
a111 1
   support single-precision floating-point operations.  */
d140 3
a154 26
static int
n32n64_floatformat_always_valid (const struct floatformat *fmt,
                                 const char *from)
{
  return 1;
}

/* FIXME: brobecker/2004-08-08: Long Double values are 128 bit long.
   They are implemented as a pair of 64bit doubles where the high
   part holds the result of the operation rounded to double, and
   the low double holds the difference between the exact result and
   the rounded result.  So "high" + "low" contains the result with
   added precision.  Unfortunately, the floatformat structure used
   by GDB is not powerful enough to describe this format.  As a temporary
   measure, we define a 128bit floatformat that only uses the high part.
   We lose a bit of precision but that's probably the best we can do
   for now with the current infrastructure.  */

static const struct floatformat floatformat_n32n64_long_double_big =
{
  floatformat_big, 128, 0, 1, 11, 1023, 2047, 12, 52,
  floatformat_intbit_no,
  "floatformat_ieee_double_big",
  n32n64_floatformat_always_valid
};

d236 1
a236 1
mips_isa_regsize (struct gdbarch *gdbarch)
d244 1
a244 1
static const char *mips_abi_regsize_string = size_auto;
d247 1
a247 1
mips_abi_regsize (struct gdbarch *gdbarch)
d249 3
a251 17
  if (mips_abi_regsize_string == size_auto)
    switch (mips_abi (gdbarch))
      {
      case MIPS_ABI_EABI32:
      case MIPS_ABI_O32:
	return 4;
      case MIPS_ABI_N32:
      case MIPS_ABI_N64:
      case MIPS_ABI_O64:
      case MIPS_ABI_EABI64:
	return 8;
      case MIPS_ABI_UNKNOWN:
      case MIPS_ABI_LAST:
      default:
	internal_error (__FILE__, __LINE__, "bad switch");
      }
  else if (mips_abi_regsize_string == size_64)
d253 1
a253 1
  else				/* if (mips_abi_regsize_string == size_32) */
d366 5
d372 1
a372 1
   different to MIPS_ABI_REGSIZE as it determines the alignment of
d378 1
a378 1
mips_stack_argsize (struct gdbarch *gdbarch)
d381 1
a381 1
    return mips_abi_regsize (gdbarch);
a389 1
struct mips_frame_cache;
d391 1
a391 4
						   struct frame_info *,
						   struct mips_frame_cache *);
static mips_extra_func_info_t non_heuristic_proc_desc (CORE_ADDR pc,
						       CORE_ADDR *addrptr);
d399 6
a404 1
static CORE_ADDR after_prologue (CORE_ADDR pc);
d626 9
d697 1
a697 1
         mips_isa_regsize(), and also map 1:1, byte for byte.  */
d701 1
a701 1
	  if (mips_isa_regsize (gdbarch) == 4)
d706 1
a706 1
	  if (mips_isa_regsize (gdbarch) == 4)
d715 15
a729 9
  else if (regnum < NUM_REGS)
    {
      /* The raw or ISA registers.  These are all sized according to
	 the ISA regsize.  */
      if (mips_isa_regsize (gdbarch) == 4)
	return builtin_type_int32;
      else
	return builtin_type_int64;
    }
d731 2
a732 22
    {
      /* The cooked or ABI registers.  These are sized according to
	 the ABI (with a few complications).  */
      if (regnum >= (NUM_REGS
		     + mips_regnum (current_gdbarch)->fp_control_status)
	  && regnum <= NUM_REGS + LAST_EMBED_REGNUM)
	/* The pseudo/cooked view of the embedded registers is always
	   32-bit.  The raw view is handled below.  */
	return builtin_type_int32;
      else if (gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p)
	/* The target, while possibly using a 64-bit register buffer,
	   is only transfering 32-bits of each integer register.
	   Reflect this in the cooked/pseudo (ABI) register value.  */
	return builtin_type_int32;
      else if (mips_abi_regsize (gdbarch) == 4)
	/* The ABI is restricted to 32-bit registers (the ISA could be
	   32- or 64-bit).  */
	return builtin_type_int32;
      else
	/* 64-bit ABI.  */
	return builtin_type_int64;
    }
d740 1
a740 1
  return read_signed_register (MIPS_SP_REGNUM);
d808 1
a808 1
/* MIPS believes that the PC has a sign extended value.  Perhaps the
d832 1
a832 1
  return frame_id_build (frame_unwind_register_signed (next_frame, NUM_REGS + MIPS_SP_REGNUM),
d846 1
a846 1
after_prologue (CORE_ADDR pc)
a847 1
  mips_extra_func_info_t proc_desc;
a849 1
  CORE_ADDR startaddr = 0;
d851 7
a857 35
  /* Pass a NULL next_frame to heuristic_proc_desc.  We should not
     attempt to read the stack pointer from the current machine state,
     because the current machine state has nothing to do with the
     information we need from the proc_desc; and the process may or
     may not exist right now.  */
  proc_desc = non_heuristic_proc_desc (pc, &startaddr);
  if (proc_desc)
    {
      /* IF this is the topmost frame AND (this proc does not have
	 debugging information OR the PC is in the procedure prologue)
	 THEN create a "heuristic" proc_desc (by analyzing the actual
	 code) to replace the "official" proc_desc.  */
      struct symtab_and_line val;
      if (PROC_SYMBOL (proc_desc))
	{
	  val = find_pc_line (BLOCK_START
			      (SYMBOL_BLOCK_VALUE (PROC_SYMBOL (proc_desc))),
			      0);
	  val.pc = val.end ? val.end : pc;
	}
      if (!PROC_SYMBOL (proc_desc) || pc < val.pc)
	{
	  mips_extra_func_info_t found_heuristic =
	    heuristic_proc_desc (PROC_LOW_ADDR (proc_desc), pc, NULL, NULL);
	  if (found_heuristic)
	    proc_desc = found_heuristic;
	}
    }
  else
    {
      if (startaddr == 0)
	startaddr = heuristic_proc_start (pc);

      proc_desc = heuristic_proc_desc (startaddr, pc, NULL, NULL);
    }
d863 1
a863 1
      if (PROC_FRAME_REG (proc_desc) == MIPS_SP_REGNUM
d956 1
a956 1
  status = deprecated_read_memory_nobpt (addr, buf, instlen);
d971 1
a971 1
  status = deprecated_read_memory_nobpt (addr, buf, instlen);
d984 1
a984 1
  status = deprecated_read_memory_nobpt (addr, buf, instlen);
d1459 2
a1460 458
static CORE_ADDR
mips16_next_pc (CORE_ADDR pc)
{
  unsigned int insn = fetch_mips_16 (pc);
  return extended_mips16_next_pc (pc, 0, insn);
}

/* The mips_next_pc function supports single_step when the remote
   target monitor or stub is not developed enough to do a single_step.
   It works by decoding the current instruction and predicting where a
   branch will go. This isnt hard because all the data is available.
   The MIPS32 and MIPS16 variants are quite different */
CORE_ADDR
mips_next_pc (CORE_ADDR pc)
{
  if (pc & 0x01)
    return mips16_next_pc (pc);
  else
    return mips32_next_pc (pc);
}

struct mips_frame_cache
{
  CORE_ADDR base;
  struct trad_frame_saved_reg *saved_regs;
};


static struct mips_frame_cache *
mips_mdebug_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  CORE_ADDR startaddr = 0;
  mips_extra_func_info_t proc_desc;
  struct mips_frame_cache *cache;
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  /* r0 bit means kernel trap */
  int kernel_trap;
  /* What registers have been saved?  Bitmasks.  */
  unsigned long gen_mask, float_mask;

  if ((*this_cache) != NULL)
    return (*this_cache);
  cache = FRAME_OBSTACK_ZALLOC (struct mips_frame_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  /* Get the mdebug proc descriptor.  */
  proc_desc = non_heuristic_proc_desc (frame_pc_unwind (next_frame),
				       &startaddr);
  /* Must be true.  This is only called when the sniffer detected a
     proc descriptor.  */
  gdb_assert (proc_desc != NULL);

  /* Extract the frame's base.  */
  cache->base = (frame_unwind_register_signed (next_frame, NUM_REGS + PROC_FRAME_REG (proc_desc))
		 + PROC_FRAME_OFFSET (proc_desc) - PROC_FRAME_ADJUST (proc_desc));

  kernel_trap = PROC_REG_MASK (proc_desc) & 1;
  gen_mask = kernel_trap ? 0xFFFFFFFF : PROC_REG_MASK (proc_desc);
  float_mask = kernel_trap ? 0xFFFFFFFF : PROC_FREG_MASK (proc_desc);
  
  /* Must be true.  The in_prologue case is left for the heuristic
     unwinder.  This is always used on kernel traps.  */
  gdb_assert (!in_prologue (frame_pc_unwind (next_frame), PROC_LOW_ADDR (proc_desc))
	      || kernel_trap);

  /* Fill in the offsets for the registers which gen_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (cache->base + PROC_REG_OFFSET (proc_desc));
    int ireg;

    for (ireg = MIPS_NUMREGS - 1; gen_mask; --ireg, gen_mask <<= 1)
      if (gen_mask & 0x80000000)
	{
	  cache->saved_regs[NUM_REGS + ireg].addr = reg_position;
	  reg_position -= mips_abi_regsize (gdbarch);
	}
  }

  /* The MIPS16 entry instruction saves $s0 and $s1 in the reverse
     order of that normally used by gcc.  Therefore, we have to fetch
     the first instruction of the function, and if it's an entry
     instruction that saves $s0 or $s1, correct their saved addresses.  */
  if (pc_is_mips16 (PROC_LOW_ADDR (proc_desc)))
    {
      ULONGEST inst = mips16_fetch_instruction (PROC_LOW_ADDR (proc_desc));
      if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)
	/* entry */
	{
	  int reg;
	  int sreg_count = (inst >> 6) & 3;

	  /* Check if the ra register was pushed on the stack.  */
	  CORE_ADDR reg_position = (cache->base
				    + PROC_REG_OFFSET (proc_desc));
	  if (inst & 0x20)
	    reg_position -= mips_abi_regsize (gdbarch);

	  /* Check if the s0 and s1 registers were pushed on the
	     stack.  */
	  /* NOTE: cagney/2004-02-08: Huh?  This is doing no such
             check.  */
	  for (reg = 16; reg < sreg_count + 16; reg++)
	    {
	      cache->saved_regs[NUM_REGS + reg].addr = reg_position;
	      reg_position -= mips_abi_regsize (gdbarch);
	    }
	}
    }

  /* Fill in the offsets for the registers which float_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (cache->base
			      + PROC_FREG_OFFSET (proc_desc));
    int ireg;
    /* Fill in the offsets for the float registers which float_mask
       says were saved.  */
    for (ireg = MIPS_NUMREGS - 1; float_mask; --ireg, float_mask <<= 1)
      if (float_mask & 0x80000000)
	{
	  if (mips_abi_regsize (gdbarch) == 4
	      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    {
	      /* On a big endian 32 bit ABI, floating point registers
	         are paired to form doubles such that the most
	         significant part is in $f[N+1] and the least
	         significant in $f[N] vis: $f[N+1] ||| $f[N].  The
	         registers are also spilled as a pair and stored as a
	         double.

	         When little-endian the least significant part is
	         stored first leading to the memory order $f[N] and
	         then $f[N+1].

	         Unfortunately, when big-endian the most significant
	         part of the double is stored first, and the least
	         significant is stored second.  This leads to the
	         registers being ordered in memory as firt $f[N+1] and
	         then $f[N].

	         For the big-endian case make certain that the
	         addresses point at the correct (swapped) locations
	         $f[N] and $f[N+1] pair (keep in mind that
	         reg_position is decremented each time through the
	         loop).  */
	      if ((ireg & 1))
		cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
		  .addr = reg_position - mips_abi_regsize (gdbarch);
	      else
		cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
		  .addr = reg_position + mips_abi_regsize (gdbarch);
	    }
	  else
	    cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
	      .addr = reg_position;
	  reg_position -= mips_abi_regsize (gdbarch);
	}

    cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->pc]
      = cache->saved_regs[NUM_REGS + RA_REGNUM];
  }

  /* SP_REGNUM, contains the value and not the address.  */
  trad_frame_set_value (cache->saved_regs, NUM_REGS + MIPS_SP_REGNUM, cache->base);

  return (*this_cache);
}

static void
mips_mdebug_frame_this_id (struct frame_info *next_frame, void **this_cache,
			   struct frame_id *this_id)
{
  struct mips_frame_cache *info = mips_mdebug_frame_cache (next_frame,
							   this_cache);
  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
}

static void
mips_mdebug_frame_prev_register (struct frame_info *next_frame,
				 void **this_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *valuep)
{
  struct mips_frame_cache *info = mips_mdebug_frame_cache (next_frame,
							   this_cache);
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind mips_mdebug_frame_unwind =
{
  NORMAL_FRAME,
  mips_mdebug_frame_this_id,
  mips_mdebug_frame_prev_register
};

static const struct frame_unwind *
mips_mdebug_frame_sniffer (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  CORE_ADDR startaddr = 0;
  mips_extra_func_info_t proc_desc;
  int kernel_trap;

  /* Only use the mdebug frame unwinder on mdebug frames where all the
     registers have been saved.  Leave hard cases such as no mdebug or
     in prologue for the heuristic unwinders.  */

  proc_desc = non_heuristic_proc_desc (pc, &startaddr);
  if (proc_desc == NULL)
    return NULL;

  /* Not sure exactly what kernel_trap means, but if it means the
     kernel saves the registers without a prologue doing it, we better
     not examine the prologue to see whether registers have been saved
     yet.  */
  kernel_trap = PROC_REG_MASK (proc_desc) & 1;
  if (kernel_trap)
    return &mips_mdebug_frame_unwind;

  /* In any frame other than the innermost or a frame interrupted by a
     signal, we assume that all registers have been saved.  This
     assumes that all register saves in a function happen before the
     first function call.  */
  if (!in_prologue (pc, PROC_LOW_ADDR (proc_desc)))
    return &mips_mdebug_frame_unwind;

  return NULL;
}

static CORE_ADDR
mips_mdebug_frame_base_address (struct frame_info *next_frame,
				void **this_cache)
{
  struct mips_frame_cache *info = mips_mdebug_frame_cache (next_frame,
							   this_cache);
  return info->base;
}

static const struct frame_base mips_mdebug_frame_base = {
  &mips_mdebug_frame_unwind,
  mips_mdebug_frame_base_address,
  mips_mdebug_frame_base_address,
  mips_mdebug_frame_base_address
};

static const struct frame_base *
mips_mdebug_frame_base_sniffer (struct frame_info *next_frame)
{
  if (mips_mdebug_frame_sniffer (next_frame) != NULL)
    return &mips_mdebug_frame_base;
  else
    return NULL;
}

/* Heuristic unwinder for 16-bit MIPS instruction set (aka MIPS16).
   Procedures that use the 32-bit instruction set are handled by the
   mips_insn32 unwinder.  */

static struct mips_frame_cache *
mips_insn16_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  mips_extra_func_info_t proc_desc;
  struct mips_frame_cache *cache;
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  /* r0 bit means kernel trap */
  int kernel_trap;
  /* What registers have been saved?  Bitmasks.  */
  unsigned long gen_mask, float_mask;

  if ((*this_cache) != NULL)
    return (*this_cache);
  cache = FRAME_OBSTACK_ZALLOC (struct mips_frame_cache);
  (*this_cache) = cache;
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  /* Synthesize a proc descriptor.  */
  {
    const CORE_ADDR pc = frame_pc_unwind (next_frame);
    CORE_ADDR start_addr;

    find_pc_partial_function (pc, NULL, &start_addr, NULL);
    if (start_addr == 0)
      start_addr = heuristic_proc_start (pc);

#ifdef NOT_YET
    proc_desc = heuristic_proc_desc (start_addr, pc, next_frame, *this_cache);
#else
    proc_desc = heuristic_proc_desc (start_addr, pc, next_frame, NULL);
#endif
  }
  
  /* Extract the frame's base.  */
  cache->base = (frame_unwind_register_signed (next_frame, NUM_REGS + PROC_FRAME_REG (proc_desc))
		 + PROC_FRAME_OFFSET (proc_desc) - PROC_FRAME_ADJUST (proc_desc));

  kernel_trap = PROC_REG_MASK (proc_desc) & 1;
  gen_mask = kernel_trap ? 0xFFFFFFFF : PROC_REG_MASK (proc_desc);
  float_mask = kernel_trap ? 0xFFFFFFFF : PROC_FREG_MASK (proc_desc);
  
  /* In any frame other than the innermost or a frame interrupted by a
     signal, we assume that all registers have been saved.  This
     assumes that all register saves in a function happen before the
     first function call.  */
  if (in_prologue (frame_pc_unwind (next_frame), PROC_LOW_ADDR (proc_desc))
      /* Not sure exactly what kernel_trap means, but if it means the
	 kernel saves the registers without a prologue doing it, we
	 better not examine the prologue to see whether registers
	 have been saved yet.  */
      && !kernel_trap)
    {
      /* We need to figure out whether the registers that the
         proc_desc claims are saved have been saved yet.  */

      CORE_ADDR addr;

      /* Bitmasks; set if we have found a save for the register.  */
      unsigned long gen_save_found = 0;
      unsigned long float_save_found = 0;
      int mips16;

      /* If the address is odd, assume this is MIPS16 code.  */
      addr = PROC_LOW_ADDR (proc_desc);
      mips16 = pc_is_mips16 (addr);

      /* Scan through this function's instructions preceding the
         current PC, and look for those that save registers.  */
      while (addr < frame_pc_unwind (next_frame))
	{
	  if (mips16)
	    {
	      mips16_decode_reg_save (mips16_fetch_instruction (addr),
				      &gen_save_found);
	      addr += MIPS16_INSTLEN;
	    }
	  else
	    {
	      mips32_decode_reg_save (mips32_fetch_instruction (addr),
				      &gen_save_found, &float_save_found);
	      addr += MIPS_INSTLEN;
	    }
	}
      gen_mask = gen_save_found;
      float_mask = float_save_found;
    }

  /* Fill in the offsets for the registers which gen_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (cache->base
			      + PROC_REG_OFFSET (proc_desc));
    int ireg;
    for (ireg = MIPS_NUMREGS - 1; gen_mask; --ireg, gen_mask <<= 1)
      if (gen_mask & 0x80000000)
	{
	  cache->saved_regs[NUM_REGS + ireg].addr = reg_position;
	  reg_position -= mips_abi_regsize (gdbarch);
	}
  }

  /* The MIPS16 entry instruction saves $s0 and $s1 in the reverse
     order of that normally used by gcc.  Therefore, we have to fetch
     the first instruction of the function, and if it's an entry
     instruction that saves $s0 or $s1, correct their saved addresses.  */
  if (pc_is_mips16 (PROC_LOW_ADDR (proc_desc)))
    {
      ULONGEST inst = mips16_fetch_instruction (PROC_LOW_ADDR (proc_desc));
      if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)
	/* entry */
	{
	  int reg;
	  int sreg_count = (inst >> 6) & 3;

	  /* Check if the ra register was pushed on the stack.  */
	  CORE_ADDR reg_position = (cache->base
				    + PROC_REG_OFFSET (proc_desc));
	  if (inst & 0x20)
	    reg_position -= mips_abi_regsize (gdbarch);

	  /* Check if the s0 and s1 registers were pushed on the
	     stack.  */
	  /* NOTE: cagney/2004-02-08: Huh?  This is doing no such
             check.  */
	  for (reg = 16; reg < sreg_count + 16; reg++)
	    {
	      cache->saved_regs[NUM_REGS + reg].addr = reg_position;
	      reg_position -= mips_abi_regsize (gdbarch);
	    }
	}
    }

  /* Fill in the offsets for the registers which float_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (cache->base
			      + PROC_FREG_OFFSET (proc_desc));
    int ireg;
    /* Fill in the offsets for the float registers which float_mask
       says were saved.  */
    for (ireg = MIPS_NUMREGS - 1; float_mask; --ireg, float_mask <<= 1)
      if (float_mask & 0x80000000)
	{
	  if (mips_abi_regsize (gdbarch) == 4
	      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    {
	      /* On a big endian 32 bit ABI, floating point registers
	         are paired to form doubles such that the most
	         significant part is in $f[N+1] and the least
	         significant in $f[N] vis: $f[N+1] ||| $f[N].  The
	         registers are also spilled as a pair and stored as a
	         double.

	         When little-endian the least significant part is
	         stored first leading to the memory order $f[N] and
	         then $f[N+1].

	         Unfortunately, when big-endian the most significant
	         part of the double is stored first, and the least
	         significant is stored second.  This leads to the
	         registers being ordered in memory as firt $f[N+1] and
	         then $f[N].

	         For the big-endian case make certain that the
	         addresses point at the correct (swapped) locations
	         $f[N] and $f[N+1] pair (keep in mind that
	         reg_position is decremented each time through the
	         loop).  */
	      if ((ireg & 1))
		cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
		  .addr = reg_position - mips_abi_regsize (gdbarch);
	      else
		cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
		  .addr = reg_position + mips_abi_regsize (gdbarch);
	    }
	  else
	    cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg]
	      .addr = reg_position;
	  reg_position -= mips_abi_regsize (gdbarch);
	}

    cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->pc]
      = cache->saved_regs[NUM_REGS + RA_REGNUM];
  }

  /* SP_REGNUM, contains the value and not the address.  */
  trad_frame_set_value (cache->saved_regs, NUM_REGS + MIPS_SP_REGNUM, cache->base);

  return (*this_cache);
}

static void
mips_insn16_frame_this_id (struct frame_info *next_frame, void **this_cache,
			   struct frame_id *this_id)
d1462 2
a1463 3
  struct mips_frame_cache *info = mips_insn16_frame_cache (next_frame,
							   this_cache);
  (*this_id) = frame_id_build (info->base, frame_func_unwind (next_frame));
d1466 7
a1472 6
static void
mips_insn16_frame_prev_register (struct frame_info *next_frame,
				 void **this_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *valuep)
d1474 4
a1477 4
  struct mips_frame_cache *info = mips_insn16_frame_cache (next_frame,
							   this_cache);
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
d1480 1
a1480 1
static const struct frame_unwind mips_insn16_frame_unwind =
d1482 2
a1483 29
  NORMAL_FRAME,
  mips_insn16_frame_this_id,
  mips_insn16_frame_prev_register
};

static const struct frame_unwind *
mips_insn16_frame_sniffer (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  if (pc_is_mips16 (pc))
    return &mips_insn16_frame_unwind;
  return NULL;
}

static CORE_ADDR
mips_insn16_frame_base_address (struct frame_info *next_frame,
				void **this_cache)
{
  struct mips_frame_cache *info = mips_insn16_frame_cache (next_frame,
							   this_cache);
  return info->base;
}

static const struct frame_base mips_insn16_frame_base =
{
  &mips_insn16_frame_unwind,
  mips_insn16_frame_base_address,
  mips_insn16_frame_base_address,
  mips_insn16_frame_base_address
a1485 13
static const struct frame_base *
mips_insn16_frame_base_sniffer (struct frame_info *next_frame)
{
  if (mips_insn16_frame_sniffer (next_frame) != NULL)
    return &mips_insn16_frame_base;
  else
    return NULL;
}

/* Heuristic unwinder for procedures using 32-bit instructions (covers
   both 32-bit and 64-bit MIPS ISAs).  Procedures using 16-bit
   instructions (a.k.a. MIPS16) are handled by the mips_insn16
   unwinder.  */
d1488 1
a1488 1
mips_insn32_frame_cache (struct frame_info *next_frame, void **this_cache)
d1505 2
a1506 16
  /* Synthesize a proc descriptor.  */
  {
    const CORE_ADDR pc = frame_pc_unwind (next_frame);
    CORE_ADDR start_addr;

    find_pc_partial_function (pc, NULL, &start_addr, NULL);
    if (start_addr == 0)
      start_addr = heuristic_proc_start (pc);

#ifdef NOT_YET
    proc_desc = heuristic_proc_desc (start_addr, pc, next_frame, *this_cache);
#else
    proc_desc = heuristic_proc_desc (start_addr, pc, next_frame, NULL);
#endif
  }
  
d1540 1
d1542 1
d1544 1
d1550 12
a1561 3
          mips32_decode_reg_save (mips32_fetch_instruction (addr),
                                  &gen_save_found, &float_save_found);
          addr += MIPS_INSTLEN;
d1577 1
a1577 1
	  reg_position -= mips_abi_regsize (gdbarch);
d1581 31
d1615 2
a1616 1
    CORE_ADDR reg_position = (cache->base + PROC_FREG_OFFSET (proc_desc));
a1617 1

d1623 1
a1623 4
          const int regno =
            NUM_REGS + mips_regnum (current_gdbarch)->fp0 + ireg;

	  if (mips_abi_regsize (gdbarch) == 4
d1649 2
a1650 2
		cache->saved_regs[regno].addr =
                  reg_position - mips_abi_regsize (gdbarch);
d1652 2
a1653 2
		cache->saved_regs[regno].addr =
                 reg_position + mips_abi_regsize (gdbarch);
d1656 3
a1658 2
	    cache->saved_regs[regno].addr = reg_position;
	  reg_position -= mips_abi_regsize (gdbarch);
d1666 1
a1666 1
  trad_frame_set_value (cache->saved_regs, NUM_REGS + MIPS_SP_REGNUM, cache->base);
d1672 1
a1672 1
mips_insn32_frame_this_id (struct frame_info *next_frame, void **this_cache,
d1675 1
a1675 1
  struct mips_frame_cache *info = mips_insn32_frame_cache (next_frame,
d1681 1
a1681 1
mips_insn32_frame_prev_register (struct frame_info *next_frame,
d1687 1
a1687 1
  struct mips_frame_cache *info = mips_insn32_frame_cache (next_frame,
d1689 2
a1690 2
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
d1693 1
a1693 1
static const struct frame_unwind mips_insn32_frame_unwind =
d1696 2
a1697 2
  mips_insn32_frame_this_id,
  mips_insn32_frame_prev_register
d1701 1
a1701 1
mips_insn32_frame_sniffer (struct frame_info *next_frame)
d1703 1
a1703 4
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  if (! pc_is_mips16 (pc))
    return &mips_insn32_frame_unwind;
  return NULL;
d1707 1
a1707 1
mips_insn32_frame_base_address (struct frame_info *next_frame,
d1710 1
a1710 1
  struct mips_frame_cache *info = mips_insn32_frame_cache (next_frame,
d1715 5
a1719 6
static const struct frame_base mips_insn32_frame_base =
{
  &mips_insn32_frame_unwind,
  mips_insn32_frame_base_address,
  mips_insn32_frame_base_address,
  mips_insn32_frame_base_address
d1723 1
a1723 87
mips_insn32_frame_base_sniffer (struct frame_info *next_frame)
{
  if (mips_insn32_frame_sniffer (next_frame) != NULL)
    return &mips_insn32_frame_base;
  else
    return NULL;
}

static struct trad_frame_cache *
mips_stub_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  CORE_ADDR pc;
  CORE_ADDR start_addr;
  CORE_ADDR stack_addr;
  struct trad_frame_cache *this_trad_cache;

  if ((*this_cache) != NULL)
    return (*this_cache);
  this_trad_cache = trad_frame_cache_zalloc (next_frame);
  (*this_cache) = this_trad_cache;

  /* The return address is in the link register.  */
  trad_frame_set_reg_realreg (this_trad_cache, PC_REGNUM, RA_REGNUM);

  /* Frame ID, since it's a frameless / stackless function, no stack
     space is allocated and SP on entry is the current SP.  */
  pc = frame_pc_unwind (next_frame);
  find_pc_partial_function (pc, NULL, &start_addr, NULL);
  stack_addr = frame_unwind_register_signed (next_frame, SP_REGNUM);
  trad_frame_set_id (this_trad_cache, frame_id_build (start_addr, stack_addr));

  /* Assume that the frame's base is the same as the
     stack-pointer.  */
  trad_frame_set_this_base (this_trad_cache, stack_addr);

  return this_trad_cache;
}

static void
mips_stub_frame_this_id (struct frame_info *next_frame, void **this_cache,
			 struct frame_id *this_id)
{
  struct trad_frame_cache *this_trad_cache
    = mips_stub_frame_cache (next_frame, this_cache);
  trad_frame_get_id (this_trad_cache, this_id);
}

static void
mips_stub_frame_prev_register (struct frame_info *next_frame,
				 void **this_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *valuep)
{
  struct trad_frame_cache *this_trad_cache
    = mips_stub_frame_cache (next_frame, this_cache);
  trad_frame_get_register (this_trad_cache, next_frame, regnum, optimizedp,
			   lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind mips_stub_frame_unwind =
{
  NORMAL_FRAME,
  mips_stub_frame_this_id,
  mips_stub_frame_prev_register
};

static const struct frame_unwind *
mips_stub_frame_sniffer (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  if (in_plt_section (pc, NULL))
    return &mips_stub_frame_unwind;
  else
    return NULL;
}

static CORE_ADDR
mips_stub_frame_base_address (struct frame_info *next_frame,
			      void **this_cache)
{
  struct trad_frame_cache *this_trad_cache
    = mips_stub_frame_cache (next_frame, this_cache);
  return trad_frame_get_this_base (this_trad_cache);
}

static const struct frame_base mips_stub_frame_base =
d1725 1
a1725 13
  &mips_stub_frame_unwind,
  mips_stub_frame_base_address,
  mips_stub_frame_base_address,
  mips_stub_frame_base_address
};

static const struct frame_base *
mips_stub_frame_base_sniffer (struct frame_info *next_frame)
{
  if (mips_stub_frame_sniffer (next_frame) != NULL)
    return &mips_stub_frame_base;
  else
    return NULL;
d1739 2
a1740 2
  else if ((regno % NUM_REGS) == MIPS_SP_REGNUM)
    /* MIPS_SP_REGNUM is special, its value is stored in saved_regs.
d1806 7
d1825 1
a1825 2
set_reg_offset (struct mips_frame_cache *this_cache, int regnum,
		CORE_ADDR offset)
d1827 1
a1827 2
  if (this_cache != NULL
      && this_cache->saved_regs[regnum].addr == 0)
d1829 2
a1830 2
      this_cache->saved_regs[regnum + 0 * NUM_REGS].addr = offset;
      this_cache->saved_regs[regnum + 1 * NUM_REGS].addr = offset;
d1889 3
a1891 2
	    warning ("GDB can't find the start of the function at 0x%s.",
		     paddr_nz (pc));
d1989 1
a1989 3
			    CORE_ADDR sp,
			    struct frame_info *next_frame,
			    struct mips_frame_cache *this_cache)
d2027 1
a2027 1
	  set_reg_offset (this_cache, reg, sp + offset);
d2034 1
a2034 1
	  set_reg_offset (this_cache, reg, sp + offset);
d2040 1
a2040 1
	  set_reg_offset (this_cache, RA_REGNUM, sp + offset);
d2046 1
a2046 1
	  set_reg_offset (this_cache, RA_REGNUM, sp + offset);
d2065 1
a2065 1
	  set_reg_offset (this_cache, reg, frame_addr + offset);
d2072 1
a2072 1
	  set_reg_offset (this_cache, reg, frame_addr + offset);
d2102 2
a2103 2
	  set_reg_offset (this_cache, reg, sp + offset);
	  offset += mips_abi_regsize (current_gdbarch);
d2111 2
a2112 2
	  set_reg_offset (this_cache, RA_REGNUM, sp + offset);
	  offset -= mips_abi_regsize (current_gdbarch);
d2119 2
a2120 2
	  set_reg_offset (this_cache, reg, sp + offset);
	  offset -= mips_abi_regsize (current_gdbarch);
d2127 1
a2127 2
			    CORE_ADDR sp, struct frame_info *next_frame,
			    struct mips_frame_cache *this_cache)
d2132 2
d2164 1
a2164 1
	  set_reg_offset (this_cache, reg, sp + low_word);
d2168 3
a2170 2
	  /* Irix 6.2 N32 ABI uses sd instructions for saving $gp and
	     $ra.  */
d2172 2
a2173 1
	  set_reg_offset (this_cache, reg, sp + low_word);
d2180 1
a2180 1
	  else if (PROC_FRAME_REG (&temp_proc_desc) == MIPS_SP_REGNUM)
d2203 1
a2203 1
	  if (PROC_FRAME_REG (&temp_proc_desc) == MIPS_SP_REGNUM)
d2223 1
a2223 1
	  set_reg_offset (this_cache, reg, frame_addr + low_word);
d2230 1
a2230 2
		     struct frame_info *next_frame,
		     struct mips_frame_cache *this_cache)
d2234 2
a2235 4
  /* Can be called when there's no process, and hence when there's no
     NEXT_FRAME.  */
  if (next_frame != NULL)
    sp = read_next_frame_reg (next_frame, NUM_REGS + MIPS_SP_REGNUM);
d2242 2
d2245 1
a2245 1
  PROC_FRAME_REG (&temp_proc_desc) = MIPS_SP_REGNUM;
d2251 1
a2251 2
    mips16_heuristic_proc_desc (start_pc, limit_pc, sp,
				next_frame, this_cache);
d2253 1
a2253 2
    mips32_heuristic_proc_desc (start_pc, limit_pc, sp,
				next_frame, this_cache);
d2291 3
d2474 61
d2637 1
a2637 1
      if (mips_abi_regsize (current_gdbarch) < 8 && len == 8)
d2640 1
a2640 1
	     spread them across a floating-point register pair.  */
d2678 1
a2678 1
	  && len < mips_abi_regsize (current_gdbarch))
d2681 1
a2681 1
	  lo->reg_offset = mips_abi_regsize (current_gdbarch) - len;
d2686 2
a2687 2
      else if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG && len > mips_abi_regsize (current_gdbarch)	/* odd-size structs */
	       && len < mips_abi_regsize (current_gdbarch) * 2
d2692 2
a2693 2
	  lo->reg_offset = 2 * mips_abi_regsize (current_gdbarch) - len;
	  lo->len = mips_abi_regsize (current_gdbarch) - lo->reg_offset;
d2702 1
a2702 1
	  if (len > mips_abi_regsize (current_gdbarch))
d2704 2
a2705 2
	      lo->len = mips_abi_regsize (current_gdbarch);
	      hi->len = len - mips_abi_regsize (current_gdbarch);
d2715 1
a2715 1
	  && mips_abi_regsize (current_gdbarch) == 4)
d2733 1
a2733 1
  return (TYPE_LENGTH (type) > 2 * mips_abi_regsize (current_gdbarch));
d2748 1
a2748 1
    return (len > mips_abi_regsize (current_gdbarch));
d2754 1
a2754 1
mips_eabi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
a2764 1
  CORE_ADDR func_addr = find_function_addr (function, NULL);
d2788 1
a2788 1
		     mips_stack_argsize (gdbarch));
d2829 1
a2829 1
      if (len > mips_abi_regsize (gdbarch)
d2832 1
a2832 1
	  store_unsigned_integer (valbuf, mips_abi_regsize (gdbarch),
d2835 1
a2835 1
	  len = mips_abi_regsize (gdbarch);
d2848 1
a2848 2
      if (mips_abi_regsize (gdbarch) < 8
	  && fp_register_arg_p (typecode, arg_type))
d2869 1
a2869 1
	  if (mips_abi_regsize (gdbarch) < 8 && len == 8)
d2907 6
a2912 6
	     mips_abi_regsize() are treated specially: Irix cc passes
	     them in registers where gcc sometimes puts them on the
	     stack.  For maximum compatibility, we will put them in
	     both places.  */
	  int odd_sized_struct = ((len > mips_abi_regsize (gdbarch))
				  && (len % mips_abi_regsize (gdbarch) != 0));
d2920 2
a2921 2
	      int partial_len = (len < mips_abi_regsize (gdbarch)
				 ? len : mips_abi_regsize (gdbarch));
d2939 1
a2939 1
		      if (mips_stack_argsize (gdbarch) == 8
d2943 1
a2943 1
			longword_offset = mips_stack_argsize (gdbarch) - len;
d2947 2
a2948 2
				   < mips_stack_argsize (gdbarch)))
			longword_offset = mips_stack_argsize (gdbarch) - len;
d2990 1
a2990 1
					    mips_abi_regsize (gdbarch)));
d3006 1
a3006 1
					  mips_stack_argsize (gdbarch));
d3013 1
a3013 1
  regcache_cooked_write_signed (regcache, MIPS_SP_REGNUM, sp);
d3071 1
a3071 1
mips_n32n64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
a3081 1
  CORE_ADDR func_addr = find_function_addr (function, NULL);
d3103 1
a3103 1
		     mips_stack_argsize (gdbarch));
d3168 6
a3173 6
	     mips_abi_regsize() are treated specially: Irix cc passes
	     them in registers where gcc sometimes puts them on the
	     stack.  For maximum compatibility, we will put them in
	     both places.  */
	  int odd_sized_struct = ((len > mips_abi_regsize (gdbarch))
				  && (len % mips_abi_regsize (gdbarch) != 0));
d3180 2
a3181 2
	      int partial_len = (len < mips_abi_regsize (gdbarch)
				 ? len : mips_abi_regsize (gdbarch));
d3199 1
a3199 1
		      if (mips_stack_argsize (gdbarch) == 8
d3203 1
a3203 1
			longword_offset = mips_stack_argsize (gdbarch) - len;
d3252 1
a3252 1
		     mips_abi_regsize(), generates a left shift as
d3255 1
a3255 1
		     sizeof (struct) >= mips_abi_regsize()).  Since
d3265 1
a3265 1
		      && partial_len < mips_abi_regsize (gdbarch)
d3268 1
a3268 1
		    regval <<= ((mips_abi_regsize (gdbarch) - partial_len) *
d3275 1
a3275 1
					    mips_abi_regsize (gdbarch)));
d3291 1
a3291 1
					  mips_stack_argsize (gdbarch));
d3298 1
a3298 1
  regcache_cooked_write_signed (regcache, MIPS_SP_REGNUM, sp);
d3313 1
a3313 1
      || TYPE_LENGTH (type) > 2 * mips_abi_regsize (gdbarch))
d3409 1
a3409 1
mips_o32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
a3419 1
  CORE_ADDR func_addr = find_function_addr (function, NULL);
d3441 1
a3441 1
		     mips_stack_argsize (gdbarch));
d3461 1
a3461 1
      stack_offset += mips_stack_argsize (gdbarch);
d3487 1
a3487 2
      if (mips_abi_regsize (gdbarch) < 8
	  && fp_register_arg_p (typecode, arg_type))
d3506 1
a3506 1
	  if (mips_abi_regsize (gdbarch) < 8 && len == 8)
d3553 1
a3553 1
	      argreg += (mips_abi_regsize (gdbarch) == 8) ? 1 : 2;
d3556 1
a3556 1
	  stack_offset += align_up (len, mips_stack_argsize (gdbarch));
d3564 6
a3569 6
	     mips_abi_regsize() are treated specially: Irix cc passes
	     them in registers where gcc sometimes puts them on the
	     stack.  For maximum compatibility, we will put them in
	     both places.  */
	  int odd_sized_struct = ((len > mips_abi_regsize (gdbarch))
				  && (len % mips_abi_regsize (gdbarch) != 0));
d3572 1
a3572 1
	  if (mips_abi_regsize (gdbarch) < 8
d3584 2
a3585 2
	      int partial_len = (len < mips_abi_regsize (gdbarch)
				 ? len : mips_abi_regsize (gdbarch));
d3603 1
a3603 1
		      if (mips_stack_argsize (gdbarch) == 8
d3607 1
a3607 1
			longword_offset = mips_stack_argsize (gdbarch) - len;
d3644 1
a3644 1
		     mips_isa_regsize() != mips_abi_regsize().  */
d3659 1
a3659 1
		     mips_abi_regsize(), generates a left shift as
d3662 1
a3662 1
		     sizeof (struct) >= mips_abi_regsize()).  Since
d3671 1
a3671 1
		  if (mips_abi_regsize (gdbarch) < 8
d3673 1
a3673 1
		      && partial_len < mips_abi_regsize (gdbarch)
d3676 1
a3676 1
		    regval <<= ((mips_abi_regsize (gdbarch) - partial_len) *
d3683 1
a3683 1
					    mips_abi_regsize (gdbarch)));
d3704 1
a3704 1
					mips_stack_argsize (gdbarch));
d3711 1
a3711 1
  regcache_cooked_write_signed (regcache, MIPS_SP_REGNUM, sp);
d3841 1
a3841 1
	   offset += mips_stack_argsize (gdbarch), regnum++)
d3843 1
a3843 1
	  int xfer = mips_stack_argsize (gdbarch);
d3860 1
a3860 1
mips_o64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
a3871 1
  CORE_ADDR func_addr = find_function_addr (function, NULL);
d3893 1
a3893 1
		     mips_stack_argsize (gdbarch));
d3913 1
a3913 1
      stack_offset += mips_stack_argsize (gdbarch);
d3939 1
a3939 2
      if (mips_abi_regsize (gdbarch) < 8
	  && fp_register_arg_p (typecode, arg_type))
d3958 1
a3958 1
	  if (mips_abi_regsize (gdbarch) < 8 && len == 8)
d4005 1
a4005 1
	      argreg += (mips_abi_regsize (gdbarch) == 8) ? 1 : 2;
d4008 1
a4008 1
	  stack_offset += align_up (len, mips_stack_argsize (gdbarch));
d4016 6
a4021 6
	     mips_abi_regsize() are treated specially: Irix cc passes
	     them in registers where gcc sometimes puts them on the
	     stack.  For maximum compatibility, we will put them in
	     both places.  */
	  int odd_sized_struct = ((len > mips_abi_regsize (gdbarch))
				  && (len % mips_abi_regsize (gdbarch) != 0));
d4024 1
a4024 1
	  if (mips_abi_regsize (gdbarch) < 8
d4036 2
a4037 2
	      int partial_len = (len < mips_abi_regsize (gdbarch)
				 ? len : mips_abi_regsize (gdbarch));
d4055 1
a4055 1
		      if (mips_stack_argsize (gdbarch) == 8
d4059 1
a4059 1
			longword_offset = mips_stack_argsize (gdbarch) - len;
d4096 1
a4096 1
		     mips_isa_regsize() != mips_abi_regsize().  */
d4111 1
a4111 1
		     mips_abi_regsize(), generates a left shift as
d4114 1
a4114 1
		     sizeof (struct) >= mips_abi_regsize()).  Since
d4123 1
a4123 1
		  if (mips_abi_regsize (gdbarch) < 8
d4125 1
a4125 1
		      && partial_len < mips_abi_regsize (gdbarch)
d4128 1
a4128 1
		    regval <<= ((mips_abi_regsize (gdbarch) - partial_len) *
d4135 1
a4135 1
					    mips_abi_regsize (gdbarch)));
d4156 1
a4156 1
					mips_stack_argsize (gdbarch));
d4163 1
a4163 1
  regcache_cooked_write_signed (regcache, MIPS_SP_REGNUM, sp);
d4470 1
a4470 1
  int ncols = (mips_abi_regsize (gdbarch) == 8 ? 4 : 8);	/* display cols per row */
d4485 1
a4485 1
			mips_abi_regsize (current_gdbarch) == 8 ? "%17s" : "%9s",
d4509 1
a4509 1
	   byte < (mips_abi_regsize (current_gdbarch)
d4810 1
a4810 1
  CORE_ADDR post_prologue_pc = after_prologue (pc);
d4824 10
d5252 2
a5253 3
/* Return non-zero if the PC is in a library helper function that
   should be ignored.  This implements the
   DEPRECATED_IGNORE_HELPER_CALL macro.  */
d5434 1
a5434 1
  /* If we have no useful BFD information, use the ABI from the last
a5504 1
      case bfd_mach_mips4120:
d5603 1
a5603 2
    set_gdbarch_pc_regnum (gdbarch, regnum->pc + num_regs);
    set_gdbarch_sp_regnum (gdbarch, MIPS_SP_REGNUM + num_regs);
d5617 3
d5633 3
d5642 2
a5643 1
      set_gdbarch_deprecated_use_struct_convention (gdbarch, always_use_struct_convention);
d5651 3
d5662 2
a5663 1
      set_gdbarch_deprecated_use_struct_convention (gdbarch, mips_eabi_use_struct_convention);
d5671 3
d5682 2
a5683 1
      set_gdbarch_deprecated_use_struct_convention (gdbarch, mips_eabi_use_struct_convention);
d5688 3
a5696 3
      set_gdbarch_long_double_bit (gdbarch, 128);
      set_gdbarch_long_double_format (gdbarch,
                                      &floatformat_n32n64_long_double_big);
d5701 3
a5709 3
      set_gdbarch_long_double_bit (gdbarch, 128);
      set_gdbarch_long_double_format (gdbarch,
                                      &floatformat_n32n64_long_double_big);
d5782 1
a5811 1
  frame_unwind_append_sniffer (gdbarch, mips_stub_frame_sniffer);
a5812 3
  frame_unwind_append_sniffer (gdbarch, mips_insn16_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, mips_insn32_frame_sniffer);
  frame_base_append_sniffer (gdbarch, mips_stub_frame_base_sniffer);
a5813 2
  frame_base_append_sniffer (gdbarch, mips_insn16_frame_base_sniffer);
  frame_base_append_sniffer (gdbarch, mips_insn32_frame_base_sniffer);
d5908 3
d5926 3
d5930 1
a5930 1
		      mips_stack_argsize (current_gdbarch));
d5948 2
a5949 2
		      "mips_dump_tdep: DEPRECATED_IGNORE_HELPER_CALL # %s\n",
		      XSTRING (DEPRECATED_IGNORE_HELPER_CALL (PC)));
d5989 2
a5990 2
		      "mips_dump_tdep: mips_abi_regsize() = %d\n",
		      mips_abi_regsize (current_gdbarch));
d5994 2
d6024 2
d6058 3
d6090 2
d6121 4
a6124 4
  deprecated_add_show_from_set (add_set_enum_cmd ("saved-gpreg-size",
						  class_obscure,
						  size_enums,
						  &mips_abi_regsize_string, "\
d6134 4
a6137 5
  deprecated_add_show_from_set
    (add_set_enum_cmd ("stack-arg-size",
		       class_obscure,
		       size_enums,
		       &mips_stack_argsize_string, "\
d6143 1
a6143 2
          target and executable (default)", &setmipscmdlist),
     &showmipscmdlist);
d6196 1
a6196 1
  deprecated_add_show_from_set (c, &showlist);
d6201 1
a6201 2
Set zeroing of upper 32 bits of 64-bit addresses.", "\
Show zeroing of upper 32 bits of 64-bit addresses.", "\
d6204 1
a6204 1
Zerroing of upper 32 bits of 64-bit address is %s.",
d6209 3
a6211 4
  add_setshow_boolean_cmd ("remote-mips64-transfers-32bit-regs", class_obscure,
			   &mips64_transfers_32bit_regs_p, "\
Set compatibility with 64-bit MIPS target that transfers 32-bit quantities.", "\
Show compatibility with 64-bit MIPS target that transfers 32-bit quantities.", "\
d6215 4
a6218 2
Compatibility with 64-bit MIPS target that transfers 32-bit quantities is %s.",
 set_mips64_transfers_32bit_regs, NULL, &setlist, &showlist);
d6221 3
a6223 5
  deprecated_add_show_from_set
    (add_set_cmd ("mips", class_maintenance, var_zinteger,
		  &mips_debug, "Set mips debugging.\n\
When non-zero, mips specific debugging is enabled.", &setdebuglist),
     &showdebuglist);
@


1.283.2.4
log
@Merge from mainline.
@
text
@a2062 1

d2076 1
d2078 3
d2089 111
d2376 6
d2459 1
a2459 1
      && this_cache->saved_regs[regnum].addr == -1)
a2757 20
/* Mark all the registers as unset in the saved_regs array
   of THIS_CACHE.  Do nothing if THIS_CACHE is null.  */

void
reset_saved_regs (struct mips_frame_cache *this_cache)
{
  if (this_cache == NULL || this_cache->saved_regs == NULL)
    return;

  {
    const int num_regs = NUM_REGS;
    int i;

    for (i = 0; i < num_regs; i++)
      {
        this_cache->saved_regs[i].addr = -1;
      }
  }
}

a2764 3
  long frame_offset;
  int  frame_reg = MIPS_SP_REGNUM;

d2766 2
a2767 2

  frame_offset = 0;
d2786 1
a2786 1
            frame_offset += 0x10000 - low_word;
d2795 1
d2802 1
d2808 1
a2808 1
	  if ((long) low_word != frame_offset)
d2810 1
a2810 1
	  else if (frame_reg == MIPS_SP_REGNUM)
d2813 1
a2813 2

	      frame_reg = 30;
d2818 4
a2821 3
                  /* FP > SP + frame_size. This may be because of
                     an alloca or somethings similar.  Fix sp to
                     "pre-alloca" value, and try again.  */
a2822 5
                  /* Need to reset the status of all registers.  Otherwise,
                     we will hit a guard that prevents the new address
                     for each register to be recomputed during the second
                     pass.  */
                  reset_saved_regs (this_cache);
d2833 1
a2833 1
	  if (frame_reg == MIPS_SP_REGNUM)
d2836 1
a2836 2

	      frame_reg = 30;
d2840 8
a2847 12
	        {
                  /* FP > SP + frame_size. This may be because of
                     an alloca or somethings similar.  Fix sp to
                     "pre-alloca" value, and try again.  */
	          sp = frame_addr;
                  /* Need to reset the status of all registers.  Otherwise,
                     we will hit a guard that prevents the new address
                     for each register to be recomputed during the second
                     pass.  */
                  reset_saved_regs (this_cache);
	          goto restart;
	        }
d2852 1
a2855 12

  if (this_cache != NULL)
    {
      this_cache->base = 
        (frame_unwind_register_signed (next_frame, NUM_REGS + frame_reg)
         + frame_offset);
      /* FIXME: brobecker/2004-09-15: We should be able to get rid of
         this assignment below, eventually.  But it's still needed
         for now.  */
      this_cache->saved_regs[NUM_REGS + mips_regnum (current_gdbarch)->pc]
        = this_cache->saved_regs[NUM_REGS + RA_REGNUM];
    }
@


1.282
log
@	* mips-linux-tdep.c: Include "frame.h".
	(mips_linux_in_dynsym_stub, mips_linux_in_dynsym_resolve_code)
	(mips_linux_skip_resolver): New functions.
	(mips_linux_init_abi): Call set_gdbarch_skip_solib_resolver
	and set_gdbarch_in_solib_call_trampoline.
	* mips-tdep.c (mips_gdbarch_init): Move gdbarch_init_osabi call
	to after set_gdbarch_in_solib_return_trampoline.  Only set the
	solib hooks to mips16 functions if the OS ABI is unknown.
	* config/mips/tm-linux.h (IN_SOLIB_CALL_TRAMPOLINE): Undefine after
	including "config/tm-linux.h".
	(IN_SOLIB_DYNSYM_RESOLVE_CODE): Define.
	* Makefile.in (mips-linux-tdep.o): Update.
@
text
@a4566 56

/* Given PC at the function's start address, attempt to find the
   prologue end using SAL information.  Return zero if the skip fails.

   A non-optimized prologue traditionally has one SAL for the function
   and a second for the function body.  A single line function has
   them both pointing at the same line.

   An optimized prologue is similar but the prologue may contain
   instructions (SALs) from the instruction body.  Need to skip those
   while not getting into the function body.

   The functions end point and an increasing SAL line are used as
   indicators of the prologue's endpoint.

   This code is based on the function refine_prologue_limit (versions
   found in both ia64 and ppc).  */

static CORE_ADDR
skip_prologue_using_sal (CORE_ADDR func_addr)
{
  struct symtab_and_line prologue_sal;
  CORE_ADDR start_pc;
  CORE_ADDR end_pc;

  /* Get an initial range for the function.  */
  find_pc_partial_function (func_addr, NULL, &start_pc, &end_pc);
  start_pc += FUNCTION_START_OFFSET;

  prologue_sal = find_pc_line (start_pc, 0);
  if (prologue_sal.line != 0)
    {
      while (prologue_sal.end < end_pc)
	{
	  struct symtab_and_line sal;

	  sal = find_pc_line (prologue_sal.end, 0);
	  if (sal.line == 0)
	    break;
	  /* Assume that a consecutive SAL for the same (or larger)
	     line mark the prologue -> body transition.  */
	  if (sal.line >= prologue_sal.line)
	    break;
	  /* The case in which compiler's optimizer/scheduler has
	     moved instructions into the prologue.  We look ahead in
	     the function looking for address ranges whose
	     corresponding line number is less the first one that we
	     found for the function.  This is more conservative then
	     refine_prologue_limit which scans a large number of SALs
	     looking for any in the prologue */
	  prologue_sal = sal;
	}
    }
  return prologue_sal.end;
}

@


1.281
log
@2004-02-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_SKIP): Default to 0.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d5818 14
a5833 5

  set_gdbarch_skip_trampoline_code (gdbarch, mips_skip_stub);

  set_gdbarch_in_solib_call_trampoline (gdbarch, mips_in_call_stub);
  set_gdbarch_in_solib_return_trampoline (gdbarch, mips_in_return_stub);
@


1.280
log
@2004-02-10  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_gdbarch_init): Delete deprecated frame code.
	(mips_init_frame_pc_first): Delete function.
	(mips_frame_saved_pc): Delete function.
	(mips_frame_chain): Delete function.
	(mips_init_extra_frame_info): Delete function.
	(mips_xfer_register): Delete unused variable "reg".
	(mips_n32n64_push_dummy_call): Delete unused variable "valbuf".
	(mips_n32n64_return_value): Delete unused variable "reg".
	(mips_n32n64_return_value): Delete unused variable "pos".
	(mips_o32_push_dummy_call): Delete unused variable "valbuf".
	(mips_o32_return_value): Delete unused variable "pos".
	(mips_o64_push_dummy_call): Delete unused variable "valbuf".
	(mips_print_fp_register): Delete unused variable "namelen"
	(mips_print_fp_register): Delete unused variable "flt2"
	(get_frame_pointer): Delete function.
	(cached_proc_desc): Delete static variable.
	(mips_pop_frame): Delete function.
	(mips_find_saved_regs): Delete function.
	(mips_get_saved_register): Delete function.
	(mips_saved_pc_after_call): Delete function.
	(SIGFRAME_BASE): Delete macro.
	(SIGFRAME_FPREGSAVE_OFF): Delete macro.
	(SIGFRAME_PC_OFF): Delete macro.
	(SIGFRAME_REGSAVE_OFF): Delete macro.
	(mips_dump_tdep): Do not print deleted macro definitions.
@
text
@a5793 2
  set_gdbarch_frame_args_skip (gdbarch, 0);

@


1.279
log
@2004-02-09  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (mips-tdep.o): Update dependencies.
	* mips-tdep.c: Include "frame-unwind.h", "frame-base.h" and
	"trad-frame.h".
	(mips_unwind_pc): Return the pseudo PC register.
	(mips_unwind_dummy_id): New function.
	(mips16_fetch_instruction): New function.
	(mips32_fetch_instruction): New function.
	(struct mips_frame_cache): Define.
	(mips_mdebug_frame_cache): New function.
	(mips_mdebug_frame_this_id): New function.
	(mips_mdebug_frame_prev_register): New function.
	(mips_mdebug_frame_unwind): Define.
	(mips_mdebug_frame_sniffer): New function.
	(mips_mdebug_frame_base_address): New function.
	(mips_mdebug_frame_base): Define.
	(mips_mdebug_frame_base_sniffer): New function.
	(mips_gdbarch_init): Append unwind and base sniffers.  Set
	unwind_dummy_id.
@
text
@a291 1
  bfd_byte reg[MAX_REGISTER_SIZE];
a1477 224
/* Set up the 'saved_regs' array.  This is a data structure containing
   the addresses on the stack where each register has been saved, for
   each stack frame.  Registers that have not been saved will have
   zero here.  The stack pointer register is special: rather than the
   address where the stack register has been saved,
   saved_regs[SP_REGNUM] will have the actual value of the previous
   frame's stack register.  */

static void
mips_find_saved_regs (struct frame_info *fci)
{
  int ireg;
  /* r0 bit means kernel trap */
  int kernel_trap;
  /* What registers have been saved?  Bitmasks.  */
  unsigned long gen_mask, float_mask;
  mips_extra_func_info_t proc_desc;
  t_inst inst;
  CORE_ADDR *saved_regs;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (deprecated_get_frame_saved_regs (fci) != NULL)
    return;
  saved_regs = frame_saved_regs_zalloc (fci);

  /* If it is the frame for sigtramp, the saved registers are located
     in a sigcontext structure somewhere on the stack.  If the stack
     layout for sigtramp changes we might have to change these
     constants and the companion fixup_sigtramp in mdebugread.c */
#ifndef SIGFRAME_BASE
  /* To satisfy alignment restrictions, sigcontext is located 4 bytes
     above the sigtramp frame.  */
#define SIGFRAME_BASE		mips_regsize (current_gdbarch)
/* FIXME!  Are these correct?? */
#define SIGFRAME_PC_OFF		(SIGFRAME_BASE + 2 * mips_regsize (current_gdbarch))
#define SIGFRAME_REGSAVE_OFF	(SIGFRAME_BASE + 3 * mips_regsize (current_gdbarch))
#define SIGFRAME_FPREGSAVE_OFF	\
        (SIGFRAME_REGSAVE_OFF + MIPS_NUMREGS * mips_regsize (current_gdbarch) + 3 * mips_regsize (current_gdbarch))
#endif
  if ((get_frame_type (fci) == SIGTRAMP_FRAME))
    {
      for (ireg = 0; ireg < MIPS_NUMREGS; ireg++)
	{
	  CORE_ADDR reg_position =
	    (get_frame_base (fci) + SIGFRAME_REGSAVE_OFF +
	     ireg * mips_regsize (current_gdbarch));
	  set_reg_offset (saved_regs, ireg, reg_position);
	}
      for (ireg = 0; ireg < MIPS_NUMREGS; ireg++)
	{
	  CORE_ADDR reg_position = (get_frame_base (fci)
				    + SIGFRAME_FPREGSAVE_OFF
				    + ireg * mips_regsize (current_gdbarch));
	  set_reg_offset (saved_regs,
			  mips_regnum (current_gdbarch)->fp0 + ireg,
			  reg_position);
	}

      set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->pc,
		      get_frame_base (fci) + SIGFRAME_PC_OFF);
      /* SP_REGNUM, contains the value and not the address.  */
      set_reg_offset (saved_regs, SP_REGNUM, get_frame_base (fci));
      return;
    }

  proc_desc = get_frame_extra_info (fci)->proc_desc;
  if (proc_desc == NULL)
    /* I'm not sure how/whether this can happen.  Normally when we
       can't find a proc_desc, we "synthesize" one using
       heuristic_proc_desc and set the saved_regs right away.  */
    return;

  kernel_trap = PROC_REG_MASK (proc_desc) & 1;
  gen_mask = kernel_trap ? 0xFFFFFFFF : PROC_REG_MASK (proc_desc);
  float_mask = kernel_trap ? 0xFFFFFFFF : PROC_FREG_MASK (proc_desc);

  if (				/* In any frame other than the innermost or a frame interrupted
				   by a signal, we assume that all registers have been saved.
				   This assumes that all register saves in a function happen
				   before the first function call.  */
       (get_next_frame (fci) == NULL
	|| (get_frame_type (get_next_frame (fci)) == SIGTRAMP_FRAME))
       /* In a dummy frame we know exactly where things are saved.  */
       && !PROC_DESC_IS_DUMMY (proc_desc)
       /* Don't bother unless we are inside a function prologue.
          Outside the prologue, we know where everything is. */
       && in_prologue (get_frame_pc (fci), PROC_LOW_ADDR (proc_desc))
       /* Not sure exactly what kernel_trap means, but if it means the
          kernel saves the registers without a prologue doing it, we
          better not examine the prologue to see whether registers
          have been saved yet.  */
       && !kernel_trap)
    {
      /* We need to figure out whether the registers that the
         proc_desc claims are saved have been saved yet.  */

      CORE_ADDR addr;

      /* Bitmasks; set if we have found a save for the register.  */
      unsigned long gen_save_found = 0;
      unsigned long float_save_found = 0;
      int instlen;

      /* If the address is odd, assume this is MIPS16 code.  */
      addr = PROC_LOW_ADDR (proc_desc);
      instlen = pc_is_mips16 (addr) ? MIPS16_INSTLEN : MIPS_INSTLEN;

      /* Scan through this function's instructions preceding the
         current PC, and look for those that save registers.  */
      while (addr < get_frame_pc (fci))
	{
	  inst = mips_fetch_instruction (addr);
	  if (pc_is_mips16 (addr))
	    mips16_decode_reg_save (inst, &gen_save_found);
	  else
	    mips32_decode_reg_save (inst, &gen_save_found, &float_save_found);
	  addr += instlen;
	}
      gen_mask = gen_save_found;
      float_mask = float_save_found;
    }

  /* Fill in the offsets for the registers which gen_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (get_frame_base (fci)
			      + PROC_REG_OFFSET (proc_desc));
    for (ireg = MIPS_NUMREGS - 1; gen_mask; --ireg, gen_mask <<= 1)
      if (gen_mask & 0x80000000)
	{
	  set_reg_offset (saved_regs, ireg, reg_position);
	  reg_position -= mips_saved_regsize (tdep);
	}
  }

  /* The MIPS16 entry instruction saves $s0 and $s1 in the reverse
     order of that normally used by gcc.  Therefore, we have to fetch
     the first instruction of the function, and if it's an entry
     instruction that saves $s0 or $s1, correct their saved addresses.  */
  if (pc_is_mips16 (PROC_LOW_ADDR (proc_desc)))
    {
      inst = mips_fetch_instruction (PROC_LOW_ADDR (proc_desc));
      if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)
	/* entry */
	{
	  int reg;
	  int sreg_count = (inst >> 6) & 3;

	  /* Check if the ra register was pushed on the stack.  */
	  CORE_ADDR reg_position = (get_frame_base (fci)
				    + PROC_REG_OFFSET (proc_desc));
	  if (inst & 0x20)
	    reg_position -= mips_saved_regsize (tdep);

	  /* Check if the s0 and s1 registers were pushed on the
	     stack.  */
	  for (reg = 16; reg < sreg_count + 16; reg++)
	    {
	      set_reg_offset (saved_regs, reg, reg_position);
	      reg_position -= mips_saved_regsize (tdep);
	    }
	}
    }

  /* Fill in the offsets for the registers which float_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (get_frame_base (fci)
			      + PROC_FREG_OFFSET (proc_desc));

    /* Fill in the offsets for the float registers which float_mask
       says were saved.  */
    for (ireg = MIPS_NUMREGS - 1; float_mask; --ireg, float_mask <<= 1)
      if (float_mask & 0x80000000)
	{
	  if (mips_saved_regsize (tdep) == 4
	      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    {
	      /* On a big endian 32 bit ABI, floating point registers
	         are paired to form doubles such that the most
	         significant part is in $f[N+1] and the least
	         significant in $f[N] vis: $f[N+1] ||| $f[N].  The
	         registers are also spilled as a pair and stored as a
	         double.

	         When little-endian the least significant part is
	         stored first leading to the memory order $f[N] and
	         then $f[N+1].

	         Unfortunately, when big-endian the most significant
	         part of the double is stored first, and the least
	         significant is stored second.  This leads to the
	         registers being ordered in memory as firt $f[N+1] and
	         then $f[N].

	         For the big-endian case make certain that the
	         addresses point at the correct (swapped) locations
	         $f[N] and $f[N+1] pair (keep in mind that
	         reg_position is decremented each time through the
	         loop).  */
	      if ((ireg & 1))
		set_reg_offset (saved_regs,
				mips_regnum (current_gdbarch)->fp0 + ireg,
				reg_position - mips_saved_regsize (tdep));
	      else
		set_reg_offset (saved_regs,
				mips_regnum (current_gdbarch)->fp0 + ireg,
				reg_position + mips_saved_regsize (tdep));
	    }
	  else
	    set_reg_offset (saved_regs,
			    mips_regnum (current_gdbarch)->fp0 + ireg,
			    reg_position);
	  reg_position -= mips_saved_regsize (tdep);
	}

    set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->pc,
		    saved_regs[RA_REGNUM]);
  }

  /* SP_REGNUM, contains the value and not the address.  */
  set_reg_offset (saved_regs, SP_REGNUM, get_frame_base (fci));
}

a1801 46
static CORE_ADDR
mips_init_frame_pc_first (int fromleaf, struct frame_info *prev)
{
  CORE_ADDR pc, tmp;

  pc = ((fromleaf)
	? DEPRECATED_SAVED_PC_AFTER_CALL (get_next_frame (prev))
	: get_next_frame (prev)
	? DEPRECATED_FRAME_SAVED_PC (get_next_frame (prev)) : read_pc ());
  tmp = SKIP_TRAMPOLINE_CODE (pc);
  return tmp ? tmp : pc;
}


static CORE_ADDR
mips_frame_saved_pc (struct frame_info *frame)
{
  CORE_ADDR saved_pc;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), 0, 0))
    {
      /* Always unwind the cooked PC register value.  */
      saved_pc = frame_unwind_register_signed (frame, NUM_REGS + mips_regnum (current_gdbarch)->pc);
    }
  else
    {
      mips_extra_func_info_t proc_desc
	= get_frame_extra_info (frame)->proc_desc;
      if (proc_desc && PROC_DESC_IS_DUMMY (proc_desc))
	saved_pc = read_memory_integer ((get_frame_base (frame)
					 - mips_saved_regsize (tdep)),
					mips_saved_regsize (tdep));
      else
	{
	  /* We have to get the saved pc from the sigcontext if it is
	     a signal handler frame.  */
	  int pcreg = (get_frame_type (frame) == SIGTRAMP_FRAME
		       ? mips_regnum (current_gdbarch)->pc
		       : proc_desc ? PROC_PC_REG (proc_desc) : RA_REGNUM);
	  saved_pc = read_next_frame_reg (frame, NUM_REGS + pcreg);
	}
    }
  return ADDR_BITS_REMOVE (saved_pc);
}

a2500 148
static CORE_ADDR
get_frame_pointer (struct frame_info *frame, mips_extra_func_info_t proc_desc)
{
  return (read_next_frame_reg (frame, NUM_REGS + PROC_FRAME_REG (proc_desc))
	  + PROC_FRAME_OFFSET (proc_desc) - PROC_FRAME_ADJUST (proc_desc));
}

static mips_extra_func_info_t cached_proc_desc;

static CORE_ADDR
mips_frame_chain (struct frame_info *frame)
{
  mips_extra_func_info_t proc_desc;
  CORE_ADDR tmp;
  CORE_ADDR saved_pc = DEPRECATED_FRAME_SAVED_PC (frame);

  /* Check if the PC is inside a call stub.  If it is, fetch the
     PC of the caller of that stub.  */
  if ((tmp = SKIP_TRAMPOLINE_CODE (saved_pc)) != 0)
    saved_pc = tmp;

  if (DEPRECATED_PC_IN_CALL_DUMMY (saved_pc, 0, 0))
    {
      /* A dummy frame, uses SP not FP.  Get the old SP value.  If all
         is well, frame->frame the bottom of the current frame will
         contain that value.  */
      return get_frame_base (frame);
    }

  /* Look up the procedure descriptor for this PC.  */
  proc_desc = find_proc_desc (saved_pc, frame, 1);
  if (!proc_desc)
    return 0;

  cached_proc_desc = proc_desc;

  /* If no frame pointer and frame size is zero, we must be at end
     of stack (or otherwise hosed).  If we don't check frame size,
     we loop forever if we see a zero size frame.  */
  if (PROC_FRAME_REG (proc_desc) == SP_REGNUM
      && PROC_FRAME_OFFSET (proc_desc) == 0
      /* The previous frame from a sigtramp frame might be frameless
         and have frame size zero.  */
      && !(get_frame_type (frame) == SIGTRAMP_FRAME)
      /* For a generic dummy frame, let get_frame_pointer() unwind a
         register value saved as part of the dummy frame call.  */
      && !(DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), 0, 0)))
    return 0;
  else
    return get_frame_pointer (frame, proc_desc);
}

static void
mips_init_extra_frame_info (int fromleaf, struct frame_info *fci)
{
  int regnum;
  mips_extra_func_info_t proc_desc;

  if (get_frame_type (fci) == DUMMY_FRAME)
    return;

  /* Use proc_desc calculated in frame_chain.  When there is no
     next frame, i.e, get_next_frame (fci) == NULL, we call
     find_proc_desc () to calculate it, passing an explicit
     NULL as the frame parameter.  */
  proc_desc =
    get_next_frame (fci)
    ? cached_proc_desc
    : find_proc_desc (get_frame_pc (fci),
		      NULL /* i.e, get_next_frame (fci) */ ,
		      1);

  frame_extra_info_zalloc (fci, sizeof (struct frame_extra_info));

  get_frame_extra_info (fci)->proc_desc =
    proc_desc == &temp_proc_desc ? 0 : proc_desc;
  if (proc_desc)
    {
      /* Fixup frame-pointer - only needed for top frame */
      /* This may not be quite right, if proc has a real frame register.
         Get the value of the frame relative sp, procedure might have been
         interrupted by a signal at it's very start.  */
      if (get_frame_pc (fci) == PROC_LOW_ADDR (proc_desc)
	  && !PROC_DESC_IS_DUMMY (proc_desc))
	deprecated_update_frame_base_hack (fci,
					   read_next_frame_reg (get_next_frame
								(fci),
								NUM_REGS +
								SP_REGNUM));
      else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fci), 0, 0))
	/* Do not ``fix'' fci->frame.  It will have the value of the
	   generic dummy frame's top-of-stack (since the draft
	   fci->frame is obtained by returning the unwound stack
	   pointer) and that is what we want.  That way the fci->frame
	   value will match the top-of-stack value that was saved as
	   part of the dummy frames data.  */
	/* Do nothing.  */ ;
      else
	deprecated_update_frame_base_hack (fci,
					   get_frame_pointer (get_next_frame
							      (fci),
							      proc_desc));

      if (proc_desc == &temp_proc_desc)
	{
	  char *name;

	  /* Do not set the saved registers for a sigtramp frame,
	     mips_find_saved_registers will do that for us.  We can't
	     use (get_frame_type (fci) == SIGTRAMP_FRAME), it is not
	     yet set.  */
	  /* FIXME: cagney/2002-11-18: This problem will go away once
	     frame.c:get_prev_frame() is modified to set the frame's
	     type before calling functions like this.  */
	  find_pc_partial_function (get_frame_pc (fci), &name,
				    (CORE_ADDR *) NULL, (CORE_ADDR *) NULL);
	  if (!PC_IN_SIGTRAMP (get_frame_pc (fci), name))
	    {
	      frame_saved_regs_zalloc (fci);
	      /* Set value of previous frame's stack pointer.
	         Remember that saved_regs[SP_REGNUM] is special in
	         that it contains the value of the stack pointer
	         register.  The other saved_regs values are addresses
	         (in the inferior) at which a given register's value
	         may be found.  */
	      set_reg_offset (temp_saved_regs, SP_REGNUM,
			      get_frame_base (fci));
	      set_reg_offset (temp_saved_regs, mips_regnum (current_gdbarch)->pc,
			      temp_saved_regs[RA_REGNUM]);
	      memcpy (deprecated_get_frame_saved_regs (fci), temp_saved_regs,
		      SIZEOF_FRAME_SAVED_REGS);
	    }
	}

      /* hack: if argument regs are saved, guess these contain args */
      /* assume we can't tell how many args for now */
      get_frame_extra_info (fci)->num_args = -1;
      for (regnum = MIPS_LAST_ARG_REGNUM; regnum >= A0_REGNUM; regnum--)
	{
	  if (PROC_REG_MASK (proc_desc) & (1 << regnum))
	    {
	      get_frame_extra_info (fci)->num_args = regnum - A0_REGNUM + 1;
	      break;
	    }
	}
    }
}

a3096 1
      char valbuf[MAX_REGISTER_SIZE];
a3309 1
      bfd_byte reg[MAX_REGISTER_SIZE];
a3359 1
	  int pos = 0;
a3435 1
      char valbuf[MAX_REGISTER_SIZE];
a3809 1
	  int pos = 0;
a3887 1
      char valbuf[MAX_REGISTER_SIZE];
a4177 81
static void
mips_pop_frame (void)
{
  int regnum;
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR new_sp = get_frame_base (frame);
  mips_extra_func_info_t proc_desc;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), 0, 0))
    {
      generic_pop_dummy_frame ();
      flush_cached_frames ();
      return;
    }

  proc_desc = get_frame_extra_info (frame)->proc_desc;
  write_register (mips_regnum (current_gdbarch)->pc,
		  DEPRECATED_FRAME_SAVED_PC (frame));
  mips_find_saved_regs (frame);
  for (regnum = 0; regnum < NUM_REGS; regnum++)
    if (regnum != SP_REGNUM && regnum != mips_regnum (current_gdbarch)->pc
	&& deprecated_get_frame_saved_regs (frame)[regnum])
      {
	/* Floating point registers must not be sign extended, in case
	   mips_saved_regsize() = 4 but sizeof (FP0_REGNUM) == 8.  */

	if (mips_regnum (current_gdbarch)->fp0 <= regnum
	    && regnum < mips_regnum (current_gdbarch)->fp0 + 32)
	  write_register (regnum,
			  read_memory_unsigned_integer
			  (deprecated_get_frame_saved_regs (frame)[regnum],
			   mips_saved_regsize (tdep)));
	else
	  write_register (regnum,
			  read_memory_integer (deprecated_get_frame_saved_regs
					       (frame)[regnum],
					       mips_saved_regsize (tdep)));
      }

  write_register (SP_REGNUM, new_sp);
  flush_cached_frames ();

  if (proc_desc && PROC_DESC_IS_DUMMY (proc_desc))
    {
      struct linked_proc_info *pi_ptr, *prev_ptr;

      for (pi_ptr = linked_proc_desc_table, prev_ptr = NULL;
	   pi_ptr != NULL; prev_ptr = pi_ptr, pi_ptr = pi_ptr->next)
	{
	  if (&pi_ptr->info == proc_desc)
	    break;
	}

      if (pi_ptr == NULL)
	error ("Can't locate dummy extra frame info\n");

      if (prev_ptr != NULL)
	prev_ptr->next = pi_ptr->next;
      else
	linked_proc_desc_table = pi_ptr->next;

      xfree (pi_ptr);

      write_register (mips_regnum (current_gdbarch)->hi,
		      read_memory_integer ((new_sp
					    - 2 * mips_saved_regsize (tdep)),
					   mips_saved_regsize (tdep)));
      write_register (mips_regnum (current_gdbarch)->lo,
		      read_memory_integer ((new_sp
					    - 3 * mips_saved_regsize (tdep)),
					   mips_saved_regsize (tdep)));
      if (MIPS_FPU_TYPE != MIPS_FPU_NONE)
	write_register (mips_regnum (current_gdbarch)->fp_control_status,
			read_memory_integer ((new_sp
					      -
					      4 * mips_saved_regsize (tdep)),
					     mips_saved_regsize (tdep)));
    }
}

d4301 2
a4302 2
  double doub, flt1, flt2;	/* doubles extracted from raw hex data */
  int inv1, inv2, namelen;
a5292 59
/* When debugging a 64 MIPS target running a 32 bit ABI, the size of
   the register stored on the stack (32) is different to its real raw
   size (64).  The below ensures that registers are fetched from the
   stack using their ABI size and then stored into the RAW_BUFFER
   using their raw size.

   The alternative to adding this function would be to add an ABI
   macro - REGISTER_STACK_SIZE(). */

static void
mips_get_saved_register (char *raw_buffer,
			 int *optimizedp,
			 CORE_ADDR *addrp,
			 struct frame_info *frame,
			 int regnum, enum lval_type *lvalp)
{
  CORE_ADDR addrx;
  enum lval_type lvalx;
  int optimizedx;
  int realnumx;

  /* Always a pseudo.  */
  gdb_assert (regnum >= NUM_REGS);

  /* Make certain that all needed parameters are present.  */
  if (addrp == NULL)
    addrp = &addrx;
  if (lvalp == NULL)
    lvalp = &lvalx;
  if (optimizedp == NULL)
    optimizedp = &optimizedx;

  if ((regnum % NUM_REGS) == SP_REGNUM)
    /* The SP_REGNUM is special, its value is stored in saved_regs.
       In fact, it is so special that it can even only be fetched
       using a raw register number!  Once this code as been converted
       to frame-unwind the problem goes away.  */
    frame_register_unwind (deprecated_get_next_frame_hack (frame),
			   regnum % NUM_REGS, optimizedp, lvalp, addrp,
			   &realnumx, raw_buffer);
  else
    /* Get it from the next frame.  */
    frame_register_unwind (deprecated_get_next_frame_hack (frame),
			   regnum, optimizedp, lvalp, addrp,
			   &realnumx, raw_buffer);
}

/* Immediately after a function call, return the saved pc.
   Can't always go through the frames for this because on some machines
   the new frame is not set up until the new function executes
   some instructions.  */

static CORE_ADDR
mips_saved_pc_after_call (struct frame_info *frame)
{
  return read_signed_register (RA_REGNUM);
}


a5765 1
#if 1
a5770 23
#else
  set_gdbarch_deprecated_target_read_fp (gdbarch, mips_read_sp);	/* Draft FRAME base.  */
  /* Initialize a frame */
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch,
						mips_find_saved_regs);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch,
						mips_init_extra_frame_info);
  /* There's a mess in stack frame creation.  See comments in
     blockframe.c near reference to DEPRECATED_INIT_FRAME_PC_FIRST.  */
  set_gdbarch_deprecated_init_frame_pc_first (gdbarch,
					      mips_init_frame_pc_first);
  set_gdbarch_deprecated_pop_frame (gdbarch, mips_pop_frame);
  set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch,
					       generic_save_dummy_frame_tos);
  set_gdbarch_deprecated_frame_chain (gdbarch, mips_frame_chain);
  set_gdbarch_frameless_function_invocation (gdbarch,
					     generic_frameless_function_invocation_not);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, mips_frame_saved_pc);
  set_gdbarch_deprecated_get_saved_register (gdbarch,
					     mips_get_saved_register);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch,
					      mips_saved_pc_after_call);
#endif
a6037 11
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SIGFRAME_BASE = %d\n", SIGFRAME_BASE);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SIGFRAME_FPREGSAVE_OFF = %d\n",
		      SIGFRAME_FPREGSAVE_OFF);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SIGFRAME_PC_OFF = %d\n",
		      SIGFRAME_PC_OFF);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SIGFRAME_REGSAVE_OFF = %d\n",
		      SIGFRAME_REGSAVE_OFF);
@


1.278
log
@2004-02-08  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_unwind_pc): New function.
	(mips_gdbarch_init): Set mips_unwind_pc.
@
text
@d53 3
d819 14
a832 1
  return frame_unwind_register_signed (next_frame, mips_regnum (gdbarch)->pc);
d961 28
d1703 248
d6331 1
d6334 3
a6336 1
#if 0
@


1.277
log
@2004-02-08  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_gdbarch_init): Group deprecated frame unwind
	methods.
@
text
@d813 6
d6039 2
@


1.276
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (dbx_symfile_init, start_psymtab, end_psymtab,
	coffstab_build_psymtabs, elfstab_build_psymtabs)
	(stabsect_build_psymtabs): Replace psymbol_obstack with
	objfile_obstack.
	* dwarf2-frame.c (decode_frame_entry_1): Ditto.
	* dwarf2read.c (dwarf2_build_psymtabs_hard, dwarf2_read_section):
	Ditto.
	* dwarfread.c (scan_compilation_units): Ditto.
	* elfread.c (elfstab_offset_sections): Ditto.
	* hppa-tdep.c (read_unwind_info): Ditto.
	* hpread.c (hpread_build_psymtabs, hpread_start_psymtab)
	(hpread_end_psymtab): Ditto.
	* mdebugread.c (mdebug_build_psymtabs, add_pending)
	(parse_partial_symbols, new_psymtab, elfmdebug_build_psymtabs):
	Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* objfiles.c (add_to_objfile_sections)
	(build_objfile_section_table): Ditto.
	(allocate_objfile): Remove init of psymbol_obstack.
	(free_objfile): Remove freeing of psymbol_obstack.
	* objfiles.h (struct objfile): Remove field
	psymbol_obstack. Update comments.
	* pa64solib.c (pa64_solib_add_solib_objfile): Replace
	psymbol_obstack with objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
        psymbol_obstack.
	* somread.c (som_symfile_offsets, init_import_symbols)
	(init_export_symbols): Replace psymbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
	* symfile.c (default_symfile_offsets, syms_from_objfile)
	(reread_symbols): Remove freeing and init of psymbol_obstack.
	(cashier_psymtab): Update comment.
	* symmisc.c (print_objfile_statistics): Don't report stats for
	psymbol obstack.
	* symtab.h (struct general_symbol_info, struct partial_symtab):
	Update comments.
	* xcoffread.c (xcoff_start_psymtab, xcoff_end_psymtab, swap_sym)
	(xcoff_symfile_offsets): Replace psymbol_obstack with
	objfile_obstack.
@
text
@a6026 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, mips_read_sp);	/* Draft FRAME base.  */
d6033 8
d6045 12
a6067 6
  /* Initialize a frame */
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch,
						mips_find_saved_regs);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch,
						mips_init_extra_frame_info);

a6073 1
  set_gdbarch_deprecated_pop_frame (gdbarch, mips_pop_frame);
a6074 2
  set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch,
					       generic_save_dummy_frame_tos);
a6079 4
  set_gdbarch_deprecated_frame_chain (gdbarch, mips_frame_chain);
  set_gdbarch_frameless_function_invocation (gdbarch,
					     generic_frameless_function_invocation_not);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, mips_frame_saved_pc);
a6081 3
  set_gdbarch_deprecated_get_saved_register (gdbarch,
					     mips_get_saved_register);

a6085 2
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch,
					      mips_saved_pc_after_call);
@


1.275
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_write_pc): New function.
	(mips_gdbarch_init): Set "write_pc" to "mips_write_pc".
	(mips_read_pc): Use mips_regnum instead of PC_REGNUM.
	(mips_find_saved_regs, mips_software_single_step: Ditto.
	(mips_frame_saved_pc, mips_frame_saved_pc): Ditto.
	mips_init_extra_frame_info, mips_pop_frame): Ditto.
@
text
@d2289 1
a2289 1
	  priv = obstack_alloc (&sec->objfile->psymbol_obstack,
d2298 1
a2298 1
	  priv = obstack_alloc (&sec->objfile->psymbol_obstack,
d2305 1
a2305 1
	      priv->contents = obstack_alloc (&sec->objfile->psymbol_obstack,
d2357 1
a2357 1
		obstack_alloc (&sec->objfile->psymbol_obstack,
@


1.274
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c: Re-indent.  Group functions by ABI.
@
text
@d810 7
a816 1
  return read_signed_register_pid (PC_REGNUM, ptid);
d1487 1
a1487 1
      set_reg_offset (saved_regs, PC_REGNUM,
d1645 2
a1646 1
    set_reg_offset (saved_regs, PC_REGNUM, saved_regs[RA_REGNUM]);
d1720 1
a1720 1
      pc = read_register (PC_REGNUM);
d1752 1
a1752 1
      saved_pc = frame_unwind_register_signed (frame, NUM_REGS + PC_REGNUM);
d1766 2
a1767 1
	  int pcreg = (get_frame_type (frame) == SIGTRAMP_FRAME ? PC_REGNUM
d2601 1
a2601 1
	      set_reg_offset (temp_saved_regs, PC_REGNUM,
d4322 2
a4323 1
  write_register (PC_REGNUM, DEPRECATED_FRAME_SAVED_PC (frame));
d4326 1
a4326 1
    if (regnum != SP_REGNUM && regnum != PC_REGNUM
d6026 1
a6026 1
  set_gdbarch_write_pc (gdbarch, generic_target_write_pc);
@


1.273
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DECR_PC_AFTER_BREAK): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	DECR_PC_AFTER_BREAK to zero.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* i386-nto-tdep.c (i386nto_init_abi): Add comment.
@
text
@d84 4
a87 4
  {
    mips_extra_func_info_t proc_desc;
    int num_args;
  };
d109 5
a113 5
  {
    MIPS_FPU_DOUBLE,		/* Full double precision floating point.  */
    MIPS_FPU_SINGLE,		/* Single precision floating point (R4650).  */
    MIPS_FPU_NONE		/* No floating point.  */
  };
d125 3
a127 3
  {
    /* from the elf header */
    int elf_flags;
d129 20
a148 20
    /* mips options */
    enum mips_abi mips_abi;
    enum mips_abi found_abi;
    enum mips_fpu_type mips_fpu_type;
    int mips_last_arg_regnum;
    int mips_last_fp_arg_regnum;
    int mips_default_saved_regsize;
    int mips_fp_register_double;
    int mips_default_stack_argsize;
    int default_mask_address_p;
    /* Is the target using 64-bit raw integer registers but only
       storing a left-aligned 32-bit value in each?  */
    int mips64_transfers_32bit_regs_p;
    /* Indexes for various registers.  IRIX and embedded have
       different values.  This contains the "public" fields.  Don't
       add any that do not need to be public.  */
    const struct mips_regnum *regnum;
    /* Register names table for the current register set.  */
    const char **mips_processor_reg_names;
  };
d199 2
a200 1
  return (extract_signed_integer (buf, register_size (current_gdbarch, regnum)));
d248 1
a248 1
  else /* if (mips_saved_regsize_string == size_32) */
d263 1
a263 1
mips_elf_make_msymbol_special (asymbol *sym, struct minimal_symbol *msym)
d265 6
a270 6
  if (((elf_symbol_type *)(sym))->internal_elf_sym.st_other == STO_MIPS16) 
    { 
      MSYMBOL_INFO (msym) = (char *) 
	(((long) MSYMBOL_INFO (msym)) | 0x80000000); 
      SYMBOL_VALUE_ADDRESS (msym) |= 1; 
    } 
d286 2
a287 2
		    enum bfd_endian endian, bfd_byte *in, const bfd_byte *out,
		    int buf_offset)
d302 1
a302 1
    case BFD_ENDIAN_UNKNOWN: /* Indicates no alignment.  */
d320 2
a321 1
    regcache_cooked_read_part (regcache, reg_num, reg_offset, length, in + buf_offset);
d323 2
a324 1
    regcache_cooked_write_part (regcache, reg_num, reg_offset, length, out + buf_offset);
d345 2
a346 1
  if (register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0) == 4)
d380 1
a380 1
  else /* if (mips_stack_argsize_string == size_32) */
d414 2
a415 1
enum { NUM_MIPS_PROCESSOR_REGS = (90 - 32) };
d420 8
a427 8
  "sr",	"lo",	"hi",	"bad",	"cause","pc",
  "f0",   "f1",   "f2",   "f3",   "f4",   "f5",   "f6",   "f7",
  "f8",   "f9",   "f10",  "f11",  "f12",  "f13",  "f14",  "f15",
  "f16",  "f17",  "f18",  "f19",  "f20",  "f21",  "f22",  "f23",
  "f24",  "f25",  "f26",  "f27",  "f28",  "f29",  "f30",  "f31",
  "fsr",  "fir",  ""/*"fp"*/,	"",
  "",	"",	"",	"",	"",	"",	"",	"",
  "",	"",	"",	"",	"",	"",	"",	"",
d433 8
a440 8
  "sr",	"lo",	"hi",	"bad",	"cause","pc",
  "f0",   "f1",   "f2",   "f3",   "f4",   "f5",   "f6",   "f7",
  "f8",   "f9",   "f10",  "f11",  "f12",  "f13",  "f14",  "f15",
  "f16",  "f17",  "f18",  "f19",  "f20",  "f21",  "f22",  "f23",
  "f24",  "f25",  "f26",  "f27",  "f28",  "f29",  "f30",  "f31",
  "fsr",  "fir",  "",/*"fp"*/	"",
  "",	"",	"bus",	"ccfg",	"",	"",	"",	"",
  "",	"",	"port",	"cmp",	"",	"",	"epc",	"prid",
d446 8
a453 8
  "sr",	"lo",	"hi",	"bad",	"cause","pc",
  "",   "",   	"",   	"",   	"",   	"",   	"",   	"",
  "",   "",   	"",  	"",  	"",  	"",  	"",  	"",
  "",  	"",  	"",  	"",  	"",  	"",  	"",  	"",
  "",  	"",  	"",  	"",  	"",  	"",  	"",  	"",
  "",  	"",  	"",	"",
  "",	"",	"",	"",	"",	"",	"",	"",
  "",	"", "config", "cache", "debug", "depc", "epc",	""
d458 5
a462 5
  "f0",   "f1",   "f2",   "f3",   "f4",   "f5",   "f6",   "f7",
  "f8",   "f9",   "f10",  "f11",  "f12",  "f13",  "f14",  "f15",
  "f16",  "f17",  "f18",  "f19",  "f20",  "f21",  "f22",  "f23",
  "f24",  "f25",  "f26",  "f27",  "f28",  "f29",  "f30",  "f31",
  "pc",	"cause", "bad",	"hi",	"lo",	"fsr",  "fir"
d473 4
a476 4
    "zero", "at",   "v0",   "v1",   "a0",   "a1",   "a2",   "a3",
    "t0",   "t1",   "t2",   "t3",   "t4",   "t5",   "t6",   "t7",
    "s0",   "s1",   "s2",   "s3",   "s4",   "s5",   "s6",   "s7",
    "t8",   "t9",   "k0",   "k1",   "gp",   "sp",   "s8",   "ra",
d481 4
a484 4
    "zero", "at",   "v0",   "v1",   "a0",   "a1",   "a2",   "a3", 
    "a4",   "a5",   "a6",   "a7",   "t0",   "t1",   "t2",   "t3", 
    "s0",   "s1",   "s2",   "s3",   "s4",   "s5",   "s6",   "s7", 
    "t8",   "t9",   "k0",   "k1",   "gp",   "sp",   "s8",   "ra"
d533 1
a533 2
  if (REGISTER_NAME (regnum) == NULL
      || REGISTER_NAME (regnum)[0] == '\0')
d549 1
a549 1
  return 0;   
d564 2
a565 1
  else if (register_size (gdbarch, rawnum) > register_size (gdbarch, cookednum))
d578 3
a580 2
mips_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int cookednum, const void *buf)
d586 2
a587 1
  else if (register_size (gdbarch, rawnum) > register_size (gdbarch, cookednum))
d600 1
a600 2
static int mips16_to_32_reg[8] =
{16, 17, 2, 3, 4, 5, 6, 7};
d626 4
a629 4
  {
    struct mips_extra_func_info info;
    struct linked_proc_info *next;
  }
d663 1
a663 2
	  && TYPE_CODE(type) == TYPE_CODE_FLT
	  && TYPE_LENGTH(type) == 8);
d711 2
a712 1
  else if (regnum >= (NUM_REGS + mips_regnum (current_gdbarch)->fp_control_status)
d755 1
a755 2
      internal_error (__FILE__, __LINE__,
		      "mips_mask_address_p: bad switch");
d773 3
a775 2
      printf_filtered ("The 32 bit address mask is set automatically.  Currently %s\n",
		       mips_mask_address_p (tdep) ? "enabled" : "disabled");
d778 1
a778 2
      internal_error (__FILE__, __LINE__,
		      "show_mask_address: bad switch");
a782 26
/* Should call_function allocate stack space for a struct return?  */

static int
mips_eabi_use_struct_convention (int gcc_p, struct type *type)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  return (TYPE_LENGTH (type) > 2 * mips_saved_regsize (tdep));
}

/* Should call_function pass struct by reference? 
   For each architecture, structs are passed either by
   value or by reference, depending on their size.  */

static int
mips_eabi_reg_struct_has_addr (int gcc_p, struct type *type)
{
  enum type_code typecode = TYPE_CODE (check_typedef (type));
  int len = TYPE_LENGTH (check_typedef (type));
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION)
    return (len > mips_saved_regsize (tdep));

  return 0;
}

d817 1
a817 2
after_prologue (CORE_ADDR pc,
		mips_extra_func_info_t proc_desc)
d864 1
a864 1
  if ((inst & 0xffe00000) == 0xafa00000		/* sw reg,n($sp) */
d877 1
a877 1
	   || (inst & 0xffe00000) == 0xe7c00000		/* swc1 freg,n($r30) */
d975 1
a975 1
				/* BEQL, BNEL, BLEZL, BGTZL: bits 0101xx */
d993 1
a993 1
				/* BC1F, BC1FL, BC1T, BC1TL: 010001 01000 */
d997 3
a999 1
	  int fcrcs = read_signed_register (mips_regnum (current_gdbarch)->fp_control_status);
d1029 1
a1029 1
	  break;	/* end SPECIAL */
d1059 1
a1059 1
	  break;	/* end REGIMM */
d1151 5
a1155 5
  {
    CORE_ADDR offset;
    unsigned int regx;		/* Function in i8 type */
    unsigned int regy;
  };
d1195 1
a1195 2
	       enum mips16_inst_fmts insn_format,
	       struct upk_mips16 *upk)
d1209 1
a1209 1
	    value |= inst & 0x7ff;		/* eleven bits from instruction */
d1268 1
a1268 2
      internal_error (__FILE__, __LINE__,
		      "bad switch");
d1284 1
a1284 2
			 unsigned int extension,
			 unsigned int insn)
d1289 1
a1289 1
    case 2:		/* Branch */
d1303 1
a1303 1
    case 3:		/* JAL , JALX - Watch out, these are 32 bit instruction */
d1314 1
a1314 1
    case 4:		/* beqz */
d1326 1
a1326 1
    case 5:		/* bnez */
d1338 1
a1338 1
    case 12:		/* I8 Formats btez btnez */
d1353 1
a1353 1
    case 29:		/* RR Formats JR, JALR, JALR-RA */
d1370 1
a1370 1
		break;	/* Function return instruction */
d1376 1
a1376 1
		break;	/* BOGUS Guess */
d1466 3
a1468 2
	  CORE_ADDR reg_position = (get_frame_base (fci) + SIGFRAME_REGSAVE_OFF
				    + ireg * mips_regsize (current_gdbarch));
d1476 3
a1478 1
	  set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->fp0 + ireg, reg_position);
d1481 2
a1482 1
      set_reg_offset (saved_regs, PC_REGNUM, get_frame_base (fci) + SIGFRAME_PC_OFF);
d1499 4
a1502 4
  if (/* In any frame other than the innermost or a frame interrupted
	 by a signal, we assume that all registers have been saved.
	 This assumes that all register saves in a function happen
	 before the first function call.  */
a1504 1

a1506 1

d1508 1
a1508 2
	  Outside the prologue, we know where everything is. */

a1509 1

d1511 3
a1513 3
	  kernel saves the registers without a prologue doing it, we
	  better not examine the prologue to see whether registers
	  have been saved yet.  */
d1578 1
a1578 1
             stack.  */
d1602 5
a1606 5
		 are paired to form doubles such that the most
		 significant part is in $f[N+1] and the least
		 significant in $f[N] vis: $f[N+1] ||| $f[N].  The
		 registers are also spilled as a pair and stored as a
		 double.
d1612 11
a1622 11
		 Unfortunately, when big-endian the most significant
		 part of the double is stored first, and the least
		 significant is stored second.  This leads to the
		 registers being ordered in memory as firt $f[N+1] and
		 then $f[N].

		 For the big-endian case make certain that the
		 addresses point at the correct (swapped) locations
		 $f[N] and $f[N+1] pair (keep in mind that
		 reg_position is decremented each time through the
		 loop).  */
d1624 2
a1625 1
		set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->fp0 + ireg,
d1628 2
a1629 1
		set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->fp0 + ireg,
d1633 3
a1635 1
	    set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->fp0 + ireg, reg_position);
d1674 1
a1674 2
  if (mips_mask_address_p (tdep)
      && (((ULONGEST) addr) >> 32 == 0xffffffffUL))
d1730 1
a1730 2
	? DEPRECATED_FRAME_SAVED_PC (get_next_frame (prev))
	: read_pc ());
d1753 2
a1754 2
					 - mips_saved_regsize (tdep))
					, mips_saved_regsize (tdep));
d1835 1
a1835 2
  if (heuristic_fence_post == UINT_MAX
      || fence < VM_MIN_ADDRESS)
d1852 3
a1854 2
	    warning ("Warning: GDB can't find the start of the function at 0x%s.",
		     paddr_nz (pc));
d1874 1
a1874 2
heuristic-fence-post' command.\n",
				 paddr_nz (pc), paddr_nz (pc));
d1920 3
a1922 3
		int nbits,		/* number of bits in imm field */
		int scale,		/* scale factor to be applied to imm */
		int is_signed)		/* is the imm field signed? */
d1974 1
a1974 1
	  || (inst & 0xff00) == 0xfb00)		/* daddiu sp */
d2135 2
a2136 1
	  set_reg_offset (temp_saved_regs, reg, sp + low_word + 8 - mips_regsize (current_gdbarch));
d2269 1
a2269 1
	 the information normally found in ECOFF PDRs.  */
d2281 1
a2281 1
	  priv = obstack_alloc (& sec->objfile->psymbol_obstack,
d2290 1
a2290 1
	  priv = obstack_alloc (& sec->objfile->psymbol_obstack,
d2297 1
a2297 1
	      priv->contents = obstack_alloc (& sec->objfile->psymbol_obstack,
d2303 5
a2307 4
		 presence of multiple code sections (and other corner cases)
		 it can become unsorted.  Sort it so that we can use a faster
		 binary search.  */
	      qsort (priv->contents, priv->size / 32, 32, compare_pdr_entries);
d2384 2
a2385 2
	 print_frame_info.  It might be better to move this check into
	 symbol reading.  */
d2431 1
a2431 2
				  (SYMBOL_BLOCK_VALUE (proc_symbol)),
				  0);
d2461 1
a2461 2
      proc_desc =
	heuristic_proc_desc (startaddr, pc, next_frame, cur_frame);
d2467 1
a2467 2
get_frame_pointer (struct frame_info *frame,
		   mips_extra_func_info_t proc_desc)
d2470 1
a2470 2
	  + PROC_FRAME_OFFSET (proc_desc)
	  - PROC_FRAME_ADJUST (proc_desc));
d2508 1
a2508 1
	 and have frame size zero.  */
d2535 1
a2535 1
                      NULL /* i.e, get_next_frame (fci) */,
d2550 5
a2554 1
	deprecated_update_frame_base_hack (fci, read_next_frame_reg (get_next_frame (fci), NUM_REGS + SP_REGNUM));
d2557 6
a2562 6
           generic dummy frame's top-of-stack (since the draft
           fci->frame is obtained by returning the unwound stack
           pointer) and that is what we want.  That way the fci->frame
           value will match the top-of-stack value that was saved as
           part of the dummy frames data.  */
	/* Do nothing.  */;
d2564 4
a2567 1
	deprecated_update_frame_base_hack (fci, get_frame_pointer (get_next_frame (fci), proc_desc));
d2578 2
a2579 2
             frame.c:get_prev_frame() is modified to set the frame's
             type before calling functions like this.  */
d2649 2
a2650 1
	       && (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION)
d2693 139
d2834 3
a2836 3
			   struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
			   struct value **args, CORE_ADDR sp, int struct_return,
			   CORE_ADDR struct_addr)
d2866 1
a2866 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d2871 1
a2871 1
    fprintf_unfiltered (gdb_stdlog, 
d2927 1
a2927 2
      if (!FP_REGISTER_DOUBLE
	  && fp_register_arg_p (typecode, arg_type))
d2972 1
a2972 1
                 above to ensure that it is even register aligned.  */
d2994 1
a2994 1
             register are only written to memory.  */
d3021 1
a3021 2
			      || typecode == TYPE_CODE_FLT)
			  && len <= 4)
d3043 1
a3043 1
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ", 
d3047 1
a3047 1
			  fprintf_unfiltered (gdb_stdlog, "%02x", 
d3058 1
a3058 1
                 purpose register.  */
d3062 2
a3063 1
		  LONGEST regval = extract_unsigned_integer (val, partial_len);
d3068 2
a3069 1
				      phex (regval, mips_saved_regsize (tdep)));
d3078 1
a3078 1
		 will copy the next parameter.
d3098 50
a3147 1
/* N32/N64 version of push_dummy_call.  */
d3151 3
a3153 3
			     struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
			     struct value **args, CORE_ADDR sp, int struct_return,
			     CORE_ADDR struct_addr)
d3181 1
a3181 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d3186 1
a3186 1
    fprintf_unfiltered (gdb_stdlog, 
d3255 1
a3255 1
             register are only written to memory.  */
d3282 1
a3282 2
			      || typecode == TYPE_CODE_FLT)
			  && len <= 4)
d3299 1
a3299 1
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ", 
d3303 1
a3303 1
			  fprintf_unfiltered (gdb_stdlog, "%02x", 
d3314 1
a3314 1
                 purpose register.  */
d3318 2
a3319 1
		  LONGEST regval = extract_unsigned_integer (val, partial_len);
d3354 2
a3355 1
				      phex (regval, mips_saved_regsize (tdep)));
d3364 1
a3364 1
		 will copy the next parameter.
d3384 111
a3494 7
/* O32 version of push_dummy_call.  */

static CORE_ADDR
mips_o32_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			  struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
			  struct value **args, CORE_ADDR sp, int struct_return,
			  CORE_ADDR struct_addr)
d3522 1
a3522 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d3527 1
a3527 1
    fprintf_unfiltered (gdb_stdlog, 
d3570 1
a3570 2
      if (!FP_REGISTER_DOUBLE
	  && fp_register_arg_p (typecode, arg_type))
d3622 1
a3622 1
                 above to ensure that it is even register aligned.  */
d3629 3
a3631 3
		 registers for each argument.  The below is (my
		 guess) to ensure that the corresponding integer
		 register has reserved the same space.  */
d3659 1
a3659 1
	        argreg++;
d3662 1
a3662 1
             register are only written to memory.  */
d3689 1
a3689 2
			      || typecode == TYPE_CODE_FLT)
			  && len <= 4)
d3706 1
a3706 1
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ", 
d3710 1
a3710 1
			  fprintf_unfiltered (gdb_stdlog, "%02x", 
d3721 1
a3721 1
                 purpose register.  */
d3765 2
a3766 1
				      phex (regval, mips_saved_regsize (tdep)));
d3779 1
a3779 1
		 will copy the next parameter.
d3781 4
a3784 4
		 In older ABIs, the caller reserved space for
		 registers that contained arguments.  This was loosely
		 refered to as their "home".  Consequently, space is
		 always allocated.  */
d3800 142
a3941 1
/* O64 version of push_dummy_call.  */
d3945 4
a3948 3
			  struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
			  struct value **args, CORE_ADDR sp, int struct_return,
			  CORE_ADDR struct_addr)
d3976 1
a3976 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d3981 1
a3981 1
    fprintf_unfiltered (gdb_stdlog, 
d4024 1
a4024 2
      if (!FP_REGISTER_DOUBLE
	  && fp_register_arg_p (typecode, arg_type))
d4076 1
a4076 1
                 above to ensure that it is even register aligned.  */
d4083 3
a4085 3
		 registers for each argument.  The below is (my
		 guess) to ensure that the corresponding integer
		 register has reserved the same space.  */
d4113 1
a4113 1
	        argreg++;
d4116 1
a4116 1
             register are only written to memory.  */
d4143 1
a4143 2
			      || typecode == TYPE_CODE_FLT)
			  && len <= 4)
d4160 1
a4160 1
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ", 
d4164 1
a4164 1
			  fprintf_unfiltered (gdb_stdlog, "%02x", 
d4175 1
a4175 1
                 purpose register.  */
d4219 2
a4220 1
				      phex (regval, mips_saved_regsize (tdep)));
d4233 1
a4233 1
		 will copy the next parameter.
d4235 4
a4238 4
		 In older ABIs, the caller reserved space for
		 registers that contained arguments.  This was loosely
		 refered to as their "home".  Consequently, space is
		 always allocated.  */
d4255 43
d4323 2
a4324 1
	if (mips_regnum (current_gdbarch)->fp0 <= regnum && regnum < mips_regnum (current_gdbarch)->fp0 + 32)
d4326 3
a4328 2
			  read_memory_unsigned_integer (deprecated_get_frame_saved_regs (frame)[regnum],
							mips_saved_regsize (tdep)));
d4331 2
a4332 1
			  read_memory_integer (deprecated_get_frame_saved_regs (frame)[regnum],
d4344 1
a4344 2
	   pi_ptr != NULL;
	   prev_ptr = pi_ptr, pi_ptr = pi_ptr->next)
d4371 2
a4372 1
					      - 4 * mips_saved_regsize (tdep)),
d4440 1
a4440 1
	 32 bits.  */
d4469 1
a4469 1
	 all 64 bits.  */
d4481 1
a4481 1
	 each register.  */
d4503 4
a4506 1
  raw_buffer = (char *) alloca (2 * register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0));
d4519 2
a4520 1
      print_scalar_formatted (raw_buffer, builtin_type_uint32, 'x', 'w', file);
d4532 1
a4532 1
	                        &inv2);
d4551 2
a4552 1
      print_scalar_formatted (raw_buffer, builtin_type_uint64, 'x', 'g', file);
d4601 3
a4603 1
    offset = register_size (current_gdbarch, regnum) - register_size (current_gdbarch, regnum);
d4607 3
a4609 2
  print_scalar_formatted (raw_buffer + offset, gdbarch_register_type (gdbarch, regnum),
			  'x', 0, file);
d4642 1
a4642 2
       col < ncols && regnum < NUM_REGS + NUM_PSEUDO_REGS;
       regnum++)
d4646 2
a4647 1
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d4649 2
a4650 1
      fprintf_filtered (file, mips_regsize (current_gdbarch) == 8 ? "%17s" : "%9s",
d4662 1
a4662 2
       col < ncols && regnum < NUM_REGS + NUM_PSEUDO_REGS;
       regnum++)
d4666 2
a4667 1
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d4675 1
a4675 2
		   - register_size (current_gdbarch, regnum));
	   byte++)
d4679 4
a4682 3
	for (byte = register_size (current_gdbarch, regnum) - register_size (current_gdbarch, regnum);
	     byte < register_size (current_gdbarch, regnum);
	     byte++)
d4686 1
a4686 2
	     byte >= 0;
	     byte--)
d4718 2
a4719 1
	  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d4762 2
a4763 1
  return is_delayed ((unsigned long) extract_unsigned_integer (buf, MIPS_INSTLEN));
d4806 1
a4806 1
             line mark the prologue -> body transition.  */
d4836 1
a4836 1
    end_pc = pc + 100; /* Magic.  */
d4887 16
a4902 509
	  if (high_word == 0x3c01 ||	/* lui $at,n */
	      high_word == 0x3c08)	/* lui $t0,n */
	    {
	      load_immediate_bytes += MIPS_INSTLEN;	/* FIXME!! */
	      continue;
	    }
	  else if (high_word == 0x3421 ||	/* ori $at,$at,n */
		   high_word == 0x3508 ||	/* ori $t0,$t0,n */
		   high_word == 0x3401 ||	/* ori $at,$zero,n */
		   high_word == 0x3408)		/* ori $t0,$zero,n */
	    {
	      load_immediate_bytes += MIPS_INSTLEN;	/* FIXME!! */
	      continue;
	    }
	  else
	    break;
	}
      else
	break;
    }

  /* In a frameless function, we might have incorrectly
     skipped some load immediate instructions. Undo the skipping
     if the load immediate was not followed by a stack adjustment.  */
  if (load_immediate_bytes && !seen_sp_adjust)
    pc -= load_immediate_bytes;
  return pc;
}

/* Skip the PC past function prologue instructions (16-bit version).
   This is a helper function for mips_skip_prologue.  */

static CORE_ADDR
mips16_skip_prologue (CORE_ADDR pc)
{
  CORE_ADDR end_pc;
  int extend_bytes = 0;
  int prev_extend_bytes;

  /* Table of instructions likely to be found in a function prologue.  */
  static struct
    {
      unsigned short inst;
      unsigned short mask;
    }
  table[] =
  {
    {
      0x6300, 0xff00
    }
    ,				/* addiu $sp,offset */
    {
      0xfb00, 0xff00
    }
    ,				/* daddiu $sp,offset */
    {
      0xd000, 0xf800
    }
    ,				/* sw reg,n($sp) */
    {
      0xf900, 0xff00
    }
    ,				/* sd reg,n($sp) */
    {
      0x6200, 0xff00
    }
    ,				/* sw $ra,n($sp) */
    {
      0xfa00, 0xff00
    }
    ,				/* sd $ra,n($sp) */
    {
      0x673d, 0xffff
    }
    ,				/* move $s1,sp */
    {
      0xd980, 0xff80
    }
    ,				/* sw $a0-$a3,n($s1) */
    {
      0x6704, 0xff1c
    }
    ,				/* move reg,$a0-$a3 */
    {
      0xe809, 0xf81f
    }
    ,				/* entry pseudo-op */
    {
      0x0100, 0xff00
    }
    ,				/* addiu $s1,$sp,n */
    {
      0, 0
    }				/* end of table marker */
  };

  /* Find an upper bound on the prologue.  */
  end_pc = skip_prologue_using_sal (pc);
  if (end_pc == 0)
    end_pc = pc + 100; /* Magic.  */

  /* Skip the typical prologue instructions. These are the stack adjustment
     instruction and the instructions that save registers on the stack
     or in the gcc frame.  */
  for (; pc < end_pc; pc += MIPS16_INSTLEN)
    {
      unsigned short inst;
      int i;

      inst = mips_fetch_instruction (pc);

      /* Normally we ignore an extend instruction.  However, if it is
         not followed by a valid prologue instruction, we must adjust
         the pc back over the extend so that it won't be considered
         part of the prologue.  */
      if ((inst & 0xf800) == 0xf000)	/* extend */
	{
	  extend_bytes = MIPS16_INSTLEN;
	  continue;
	}
      prev_extend_bytes = extend_bytes;
      extend_bytes = 0;

      /* Check for other valid prologue instructions besides extend.  */
      for (i = 0; table[i].mask != 0; i++)
	if ((inst & table[i].mask) == table[i].inst)	/* found, get out */
	  break;
      if (table[i].mask != 0)	/* it was in table? */
	continue;		/* ignore it */
      else
	/* non-prologue */
	{
	  /* Return the current pc, adjusted backwards by 2 if
	     the previous instruction was an extend.  */
	  return pc - prev_extend_bytes;
	}
    }
  return pc;
}

/* To skip prologues, I use this predicate.  Returns either PC itself
   if the code at PC does not look like a function prologue; otherwise
   returns an address that (if we're lucky) follows the prologue.  If
   LENIENT, then we must skip everything which is involved in setting
   up the frame (it's OK to skip more, just so long as we don't skip
   anything which might clobber the registers which are being saved.
   We must skip more in the case where part of the prologue is in the
   delay slot of a non-prologue instruction).  */

static CORE_ADDR
mips_skip_prologue (CORE_ADDR pc)
{
  /* See if we can determine the end of the prologue via the symbol table.
     If so, then return either PC, or the PC after the prologue, whichever
     is greater.  */

  CORE_ADDR post_prologue_pc = after_prologue (pc, NULL);

  if (post_prologue_pc != 0)
    return max (pc, post_prologue_pc);

  /* Can't determine prologue from the symbol table, need to examine
     instructions.  */

  if (pc_is_mips16 (pc))
    return mips16_skip_prologue (pc);
  else
    return mips32_skip_prologue (pc);
}

/* Determine how a return value is stored within the MIPS register
   file, given the return type `valtype'. */

struct return_value_word
{
  int len;
  int reg;
  int reg_offset;
  int buf_offset;
};

static void
return_value_location (struct type *valtype,
		       struct return_value_word *hi,
		       struct return_value_word *lo)
{
  int len = TYPE_LENGTH (valtype);
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (TYPE_CODE (valtype) == TYPE_CODE_FLT
      && ((MIPS_FPU_TYPE == MIPS_FPU_DOUBLE && (len == 4 || len == 8))
	  || (MIPS_FPU_TYPE == MIPS_FPU_SINGLE && len == 4)))
    {
      if (!FP_REGISTER_DOUBLE && len == 8)
	{
	  /* We need to break a 64bit float in two 32 bit halves and
	     spread them across a floating-point register pair. */
	  lo->buf_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 4 : 0;
	  hi->buf_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 0 : 4;
	  lo->reg_offset = ((TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
			     && register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0) == 8)
			    ? 4 : 0);
	  hi->reg_offset = lo->reg_offset;
	  lo->reg = mips_regnum (current_gdbarch)->fp0 + 0;
	  hi->reg = mips_regnum (current_gdbarch)->fp0 + 1;
	  lo->len = 4;
	  hi->len = 4;
	}
      else
	{
	  /* The floating point value fits in a single floating-point
	     register. */
	  lo->reg_offset = ((TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
			     && register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0) == 8
			     && len == 4)
			    ? 4 : 0);
	  lo->reg = mips_regnum (current_gdbarch)->fp0;
	  lo->len = len;
	  lo->buf_offset = 0;
	  hi->len = 0;
	  hi->reg_offset = 0;
	  hi->buf_offset = 0;
	  hi->reg = 0;
	}
    }
  else
    {
      /* Locate a result possibly spread across two registers. */
      int regnum = 2;
      lo->reg = regnum + 0;
      hi->reg = regnum + 1;
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && len < mips_saved_regsize (tdep))
	{
	  /* "un-left-justify" the value in the low register */
	  lo->reg_offset = mips_saved_regsize (tdep) - len;
	  lo->len = len;
	  hi->reg_offset = 0;
	  hi->len = 0;
	}
      else if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	       && len > mips_saved_regsize (tdep)	/* odd-size structs */
	       && len < mips_saved_regsize (tdep) * 2
	       && (TYPE_CODE (valtype) == TYPE_CODE_STRUCT ||
		   TYPE_CODE (valtype) == TYPE_CODE_UNION))
	{
	  /* "un-left-justify" the value spread across two registers. */
	  lo->reg_offset = 2 * mips_saved_regsize (tdep) - len;
	  lo->len = mips_saved_regsize (tdep) - lo->reg_offset;
	  hi->reg_offset = 0;
	  hi->len = len - lo->len;
	}
      else
	{
	  /* Only perform a partial copy of the second register. */
	  lo->reg_offset = 0;
	  hi->reg_offset = 0;
	  if (len > mips_saved_regsize (tdep))
	    {
	      lo->len = mips_saved_regsize (tdep);
	      hi->len = len - mips_saved_regsize (tdep);
	    }
	  else
	    {
	      lo->len = len;
	      hi->len = 0;
	    }
	}
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && register_size (current_gdbarch, regnum) == 8
	  && mips_saved_regsize (tdep) == 4)
	{
	  /* Account for the fact that only the least-signficant part
	     of the register is being used */
	  lo->reg_offset += 4;
	  hi->reg_offset += 4;
	}
      lo->buf_offset = 0;
      hi->buf_offset = lo->len;
    }
}

/* Given a return value in `regbuf' with a type `valtype', extract and
   copy its value into `valbuf'. */

static void
mips_eabi_extract_return_value (struct type *valtype,
				char regbuf[],
				char *valbuf)
{
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memcpy (valbuf + lo.buf_offset,
	  regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + lo.reg) + lo.reg_offset,
	  lo.len);

  if (hi.len > 0)
    memcpy (valbuf + hi.buf_offset,
	    regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + hi.reg) + hi.reg_offset,
	    hi.len);
}

static void
mips_o64_extract_return_value (struct type *valtype,
			       char regbuf[],
			       char *valbuf)
{
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memcpy (valbuf + lo.buf_offset,
	  regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + lo.reg) + lo.reg_offset,
	  lo.len);

  if (hi.len > 0)
    memcpy (valbuf + hi.buf_offset,
	    regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + hi.reg) + hi.reg_offset,
	    hi.len);
}

/* Given a return value in `valbuf' with a type `valtype', write it's
   value into the appropriate register. */

static void
mips_eabi_store_return_value (struct type *valtype, char *valbuf)
{
  char raw_buffer[MAX_REGISTER_SIZE];
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memset (raw_buffer, 0, sizeof (raw_buffer));
  memcpy (raw_buffer + lo.reg_offset, valbuf + lo.buf_offset, lo.len);
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (lo.reg), raw_buffer,
				   register_size (current_gdbarch, lo.reg));

  if (hi.len > 0)
    {
      memset (raw_buffer, 0, sizeof (raw_buffer));
      memcpy (raw_buffer + hi.reg_offset, valbuf + hi.buf_offset, hi.len);
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (hi.reg), raw_buffer,
				       register_size (current_gdbarch, hi.reg));
    }
}

static void
mips_o64_store_return_value (struct type *valtype, char *valbuf)
{
  char raw_buffer[MAX_REGISTER_SIZE];
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memset (raw_buffer, 0, sizeof (raw_buffer));
  memcpy (raw_buffer + lo.reg_offset, valbuf + lo.buf_offset, lo.len);
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (lo.reg), raw_buffer,
				   register_size (current_gdbarch, lo.reg));

  if (hi.len > 0)
    {
      memset (raw_buffer, 0, sizeof (raw_buffer));
      memcpy (raw_buffer + hi.reg_offset, valbuf + hi.buf_offset, hi.len);
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (hi.reg), raw_buffer,
				       register_size (current_gdbarch, hi.reg));
    }
}

/* O32 ABI stuff.  */

static enum return_value_convention
mips_o32_return_value (struct gdbarch *gdbarch, struct type *type,
		       struct regcache *regcache,
		       void *readbuf, const void *writebuf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (TYPE_CODE (type)== TYPE_CODE_STRUCT
      || TYPE_CODE (type)== TYPE_CODE_UNION
      || TYPE_CODE (type)== TYPE_CODE_ARRAY)
    return RETURN_VALUE_STRUCT_CONVENTION;
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && TYPE_LENGTH (type) == 4
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A single-precision floating-point value.  It fits in the
         least significant part of FP0.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $fp0\n");
      mips_xfer_register (regcache,
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
			  TYPE_LENGTH (type),
			  TARGET_BYTE_ORDER, readbuf, writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && TYPE_LENGTH (type) == 8
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A double-precision floating-point value.  The most
         significant part goes in FP1, and the least significant in
         FP0.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $fp1/$fp0\n");
      switch (TARGET_BYTE_ORDER)
	{
	case BFD_ENDIAN_LITTLE:
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 0,
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 1,
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 4);
	  break;
	case BFD_ENDIAN_BIG:
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 1,
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 0,
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 4);
	  break;
	default:
	  internal_error (__FILE__, __LINE__, "bad switch");
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
#if 0
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   && TYPE_NFIELDS (type) <= 2
	   && TYPE_NFIELDS (type) >= 1
	   && ((TYPE_NFIELDS (type) == 1
		&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		    == TYPE_CODE_FLT))
	       || (TYPE_NFIELDS (type) == 2
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		       == TYPE_CODE_FLT)
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 1))
		       == TYPE_CODE_FLT)))
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A struct that contains one or two floats.  Each value is part
         in the least significant part of their floating point
         register..  */
      bfd_byte reg[MAX_REGISTER_SIZE];
      int regnum;
      int field;
      for (field = 0, regnum = mips_regnum (current_gdbarch)->fp0;
	   field < TYPE_NFIELDS (type);
	   field++, regnum += 2)
	{
	  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])
			/ TARGET_CHAR_BIT);
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return float struct+%d\n", offset);
	  mips_xfer_register (regcache, NUM_REGS + regnum,
			      TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
#endif
#if 0
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (type) == TYPE_CODE_UNION)
    {
      /* A structure or union.  Extract the left justified value,
         regardless of the byte order.  I.e. DO NOT USE
         mips_xfer_lower.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += register_size (current_gdbarch, regnum), regnum++)
	{
	  int xfer = register_size (current_gdbarch, regnum);
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return struct+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      BFD_ENDIAN_UNKNOWN, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
#endif
  else
    {
      /* A scalar extract each part but least-significant-byte
         justified.  o32 thinks registers are 4 byte, regardless of
         the ISA.  mips_stack_argsize controls this.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += mips_stack_argsize (tdep), regnum++)
	{
	  int xfer = mips_stack_argsize (tdep);
	  int pos = 0;
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return scalar+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
d4904 2
a4905 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d4907 7
d4916 2
a4917 1
/* N32/N44 ABI stuff.  */
d4919 2
a4920 4
static enum return_value_convention
mips_n32n64_return_value (struct gdbarch *gdbarch,
			  struct type *type, struct regcache *regcache,
			  void *readbuf, const void *writebuf)
d4922 45
a4966 8
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  if (TYPE_CODE (type)== TYPE_CODE_STRUCT
      || TYPE_CODE (type)== TYPE_CODE_UNION
      || TYPE_CODE (type)== TYPE_CODE_ARRAY
      || TYPE_LENGTH (type) > 2 * mips_saved_regsize (tdep))
    return RETURN_VALUE_STRUCT_CONVENTION;
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
d4968 12
a4979 22
      /* A floating-point value belongs in the least significant part
         of FP0.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $fp0\n");
      mips_xfer_register (regcache,
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
			  TYPE_LENGTH (type),
			  TARGET_BYTE_ORDER, readbuf, writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   && TYPE_NFIELDS (type) <= 2
	   && TYPE_NFIELDS (type) >= 1
	   && ((TYPE_NFIELDS (type) == 1
		&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		    == TYPE_CODE_FLT))
	       || (TYPE_NFIELDS (type) == 2
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		       == TYPE_CODE_FLT)
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 1))
		       == TYPE_CODE_FLT)))
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
d4981 10
a4990 9
      /* A struct that contains one or two floats.  Each value is part
         in the least significant part of their floating point
         register..  */
      bfd_byte reg[MAX_REGISTER_SIZE];
      int regnum;
      int field;
      for (field = 0, regnum = mips_regnum (current_gdbarch)->fp0;
	   field < TYPE_NFIELDS (type);
	   field++, regnum += 2)
d4992 2
a4993 7
	  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])
			/ TARGET_CHAR_BIT);
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return float struct+%d\n", offset);
	  mips_xfer_register (regcache, NUM_REGS + regnum,
			      TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
d4995 11
a5005 13
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (type) == TYPE_CODE_UNION)
    {
      /* A structure or union.  Extract the left justified value,
         regardless of the byte order.  I.e. DO NOT USE
         mips_xfer_lower.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += register_size (current_gdbarch, regnum), regnum++)
d5007 3
a5009 8
	  int xfer = register_size (current_gdbarch, regnum);
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return struct+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      BFD_ENDIAN_UNKNOWN, readbuf, writebuf, offset);
a5010 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d5012 29
d5042 1
a5042 21
    {
      /* A scalar extract each part but least-significant-byte
         justified.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += register_size (current_gdbarch, regnum), regnum++)
	{
	  int xfer = register_size (current_gdbarch, regnum);
	  int pos = 0;
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return scalar+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
d5067 2
a5068 1
  printf_unfiltered ("\"set mips\" must be followed by an appropriate subcommand.\n");
d5093 3
a5095 2
    printf_unfiltered ("The MIPS floating-point coprocessor is set automatically (currently %s)\n",
		       fpu);
d5097 2
a5098 2
    printf_unfiltered ("The MIPS floating-point coprocessor is assumed to be %s\n",
		       fpu);
d5105 2
a5106 1
  printf_unfiltered ("\"set mipsfpu\" must be followed by \"double\", \"single\",\"none\" or \"auto\".\n");
d5211 1
a5211 1
	info->mach =  bfd_mach_mips16;
d5216 2
a5217 2
       info->mach = bfd_mach_mips16;
    } 
d5223 1
a5223 2
  if (tdep->mips_abi == MIPS_ABI_N32
      || tdep->mips_abi == MIPS_ABI_N64)
d5226 1
a5226 1
	 register names from libopcodes.  */
d5256 1
a5256 1
mips_breakpoint_from_pc (CORE_ADDR * pcptr, int *lenptr)
d5262 1
a5262 1
	  static unsigned char mips16_big_breakpoint[] = {0xe8, 0xa5};
d5272 3
a5274 3
	  static unsigned char big_breakpoint[] = {0, 0x5, 0, 0xd};
	  static unsigned char pmon_big_breakpoint[] = {0, 0, 0, 0xd};
	  static unsigned char idt_big_breakpoint[] = {0, 0, 0x0a, 0xd};
d5292 1
a5292 1
	  static unsigned char mips16_little_breakpoint[] = {0xa5, 0xe8};
d5299 3
a5301 3
	  static unsigned char little_breakpoint[] = {0xd, 0, 0x5, 0};
	  static unsigned char pmon_little_breakpoint[] = {0xd, 0, 0, 0};
	  static unsigned char idt_little_breakpoint[] = {0xd, 0x0a, 0, 0};
d5384 2
a5385 1
	      if (find_pc_partial_function (target_pc, &name, NULL, NULL) == 0)
d5427 2
a5428 1
  if (find_pc_partial_function (pc, name ? NULL : &name, &start_addr, NULL) == 0)
d5466 1
a5466 2
      && (name[19] == 's' || name[19] == 'd')
      && pc != start_addr)
d5506 1
a5506 2
			 int regnum,
			 enum lval_type *lvalp)
d5608 1
a5608 1
    return LEGACY_SIM_REGNO_IGNORE;    
d5663 1
a5663 2
  internal_error (__FILE__, __LINE__,
		  "unknown ABI string");
d5667 1
a5667 2
mips_gdbarch_init (struct gdbarch_info info,
		   struct gdbarch_list *arches)
d5685 1
a5685 2
			"mips_gdbarch_init: elf_flags = 0x%08x\n",
			elf_flags);
d5800 1
a5800 2
			"mips_gdbarch_init: fpu_type = %d\n",
			fpu_type);
d5843 1
a5843 1
  set_gdbarch_elf_make_msymbol_special (gdbarch, 
d5909 4
a5912 2
      set_gdbarch_deprecated_store_return_value (gdbarch, mips_o64_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch, mips_o64_extract_return_value);
d5922 2
a5923 1
      set_gdbarch_use_struct_convention (gdbarch, always_use_struct_convention);
d5927 4
a5930 2
      set_gdbarch_deprecated_store_return_value (gdbarch, mips_eabi_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch, mips_eabi_extract_return_value);
d5942 1
a5942 1
      set_gdbarch_use_struct_convention (gdbarch, 
d5947 4
a5950 2
      set_gdbarch_deprecated_store_return_value (gdbarch, mips_eabi_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch, mips_eabi_extract_return_value);
d5962 1
a5962 1
      set_gdbarch_use_struct_convention (gdbarch, 
d5992 1
a5992 2
      internal_error (__FILE__, __LINE__,
		      "unknown ABI in switch");
d6018 1
a6018 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, mips_read_sp); /* Draft FRAME base.  */
d6027 2
a6028 1
  set_gdbarch_deprecated_init_frame_pc_first (gdbarch, mips_init_frame_pc_first);
d6032 6
a6037 3
  set_gdbarch_ecoff_reg_to_regnum (gdbarch, mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, mips_dwarf_dwarf2_ecoff_reg_to_regnum);
d6041 4
a6044 2
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, mips_find_saved_regs);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, mips_init_extra_frame_info);
d6054 2
a6055 1
  set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
d6062 1
a6062 1
  set_gdbarch_frameless_function_invocation (gdbarch, 
d6067 2
a6068 1
  set_gdbarch_deprecated_get_saved_register (gdbarch, mips_get_saved_register);
d6074 2
a6075 1
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, mips_saved_pc_after_call);
d6108 1
a6108 2
mips_abi_update (char *ignore_args, int from_tty, 
		 struct cmd_list_element *c)
d6124 2
a6125 2
    printf_filtered (
      "The MIPS ABI is unknown because the current architecture is not MIPS.\n");
d6133 3
a6135 2
	printf_filtered ("The MIPS ABI is set automatically (currently \"%s\").\n",
	                 actual_abi_str);
d6137 3
a6139 3
	printf_filtered (
	  "The MIPS ABI is assumed to be \"%s\" (due to user setting).\n",
	  actual_abi_str);
d6143 3
a6145 4
	  printf_filtered (
	    "The (auto detected) MIPS ABI \"%s\" is in use even though the user setting was \"%s\".\n",
	    actual_abi_str,
	    mips_abi_strings[global_abi]);
d6190 1
a6190 2
			  tdep->mips_abi,
			  mips_abi_strings[tdep->mips_abi]);
d6206 1
a6206 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_EABI = %d\n",
		      MIPS_EABI);
d6220 1
a6220 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: A0_REGNUM = %d\n",
		      A0_REGNUM);
d6223 1
a6223 1
		      XSTRING (ADDR_BITS_REMOVE(ADDR)));
d6266 1
a6266 2
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_DEFAULT_ABI = FIXME!\n");
d6270 1
a6270 2
		      "mips_dump_tdep: MIPS_INSTLEN = %d\n",
		      MIPS_INSTLEN);
d6276 1
a6276 2
		      "mips_dump_tdep: MIPS_NUMREGS = %d\n",
		      MIPS_NUMREGS);
d6281 1
a6281 2
		      "mips_dump_tdep: PRID_REGNUM = %d\n",
		      PRID_REGNUM);
d6288 11
a6298 24
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_FRAME_REG = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_FREG_MASK = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_FREG_OFFSET = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_HIGH_ADDR = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_LOW_ADDR = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_PC_REG = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_REG_MASK = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_REG_OFFSET = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_SYMBOL = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PS_REGNUM = %d\n",
		      PS_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: RA_REGNUM = %d\n",
		      RA_REGNUM);
d6301 1
a6301 2
		      "mips_dump_tdep: SAVED_BYTES = %d\n",
		      SAVED_BYTES);
d6304 1
a6304 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SAVED_FP = %d\n",
		      SAVED_FP);
d6307 1
a6307 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SAVED_PC = %d\n",
		      SAVED_PC);
d6315 1
a6315 2
		      "mips_dump_tdep: SIGFRAME_BASE = %d\n",
		      SIGFRAME_BASE);
d6351 1
a6351 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: T9_REGNUM = %d\n",
		      T9_REGNUM);
d6356 2
a6357 1
		      XSTRING (TARGET_CAN_USE_HARDWARE_WATCHPOINT (TYPE,CNT,OTHERTYPE)));
d6368 1
a6368 2
		      "mips_dump_tdep: TRACE_FLAVOR = %d\n",
		      TRACE_FLAVOR);
d6378 1
a6378 1
		      XSTRING (TRACE_SET (X,STATE)));
d6382 1
a6382 2
		      "mips_dump_tdep: UNUSED_REGNUM = %d\n",
		      UNUSED_REGNUM);
d6384 1
a6384 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: V0_REGNUM = %d\n",
		      V0_REGNUM);
d6389 1
a6389 2
		      "mips_dump_tdep: ZERO_REGNUM = %d\n",
		      ZERO_REGNUM);
d6391 1
a6391 2
		      "mips_dump_tdep: _PROC_MAGIC_ = %d\n",
		      _PROC_MAGIC_);
d6394 1
a6394 1
extern initialize_file_ftype _initialize_mips_tdep; /* -Wmissing-prototypes */
d6402 1
a6402 1
  mips_abi_string = mips_abi_strings [MIPS_ABI_UNKNOWN];
d6429 1
a6429 3
          (default: auto)",
				       &setmipscmdlist),
		     &showmipscmdlist);
d6441 1
a6441 3
          target and executable (default)",
				       &setmipscmdlist),
		     &showmipscmdlist);
d6450 1
a6450 6
     "  o64\n"
     "  n32\n"
     "  n64\n"
     "  eabi32\n"
     "  eabi64",
     &setmipscmdlist);
d6453 1
a6453 1
           "Show ABI in use by MIPS target", &showmipscmdlist);
d6471 1
a6471 2
	   "Select no MIPS floating-point coprocessor.",
	   &mipsfpulist);
d6486 1
a6486 2
		   (char *) &heuristic_fence_post,
		   "\
d6490 1
a6490 2
search.  The only need to set it is when debugging a stripped executable.",
		   &setlist);
d6503 1
a6503 2
				NULL, show_mask_address,
				&setmipscmdlist, &showmipscmdlist);
d6512 1
a6512 1
64 bits for others.  Use \"off\" to disable compatibility mode",  "\
d6516 1
a6516 3
64 bits for others.  Use \"off\" to disable compatibility mode",
		   set_mips64_transfers_32bit_regs, NULL,
		   &setlist, &showlist);
d6521 1
a6521 2
When non-zero, mips specific debugging is enabled.", &setdebuglist),
		     &showdebuglist);
@


1.272
log
@2004-01-12  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_convert_register_p): Handle both raw and
	cooked floating-point registers.
	(mips_gdbarch_init): Set convert_register_p, register_to_value,
	and value_to_register.
@
text
@a6048 1
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
@


1.271
log
@2004-01-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FUNCTION_START_OFFSET): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	FUNCTION_START_OFFSET.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d655 2
a656 1
	  && (regnum) >= mips_regnum (current_gdbarch)->fp0 && (regnum) < mips_regnum (current_gdbarch)->fp0 + 32
d6034 4
@


1.270
log
@2004-01-12  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_pseudo_register_read): Don't return a value,
	the function is void.
	(mips_pseudo_register_write): Ditto.
@
text
@a6052 2
  set_gdbarch_function_start_offset (gdbarch, 0);

@


1.269
log
@2004-01-08  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_n32n64_reg_struct_has_addr): Delete function.
	(mips_o32_reg_struct_has_addr): Delete function.
	(mips_gdbarch_init): Update.
	(mips_extract_struct_value_address): Delete function.
@
text
@d559 1
a559 1
    return regcache_raw_read (regcache, rawnum, buf);
d579 1
a579 1
    return regcache_raw_write (regcache, rawnum, buf);
@


1.268
log
@2004-01-07  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_gdbarch_init): Set elf_flags to the previous
	architecture's elf flags (when available).
@
text
@a802 12
static int
mips_n32n64_reg_struct_has_addr (int gcc_p, struct type *type)
{
  return 0;	/* Assumption: N32/N64 never passes struct by ref.  */
}

static int
mips_o32_reg_struct_has_addr (int gcc_p, struct type *type)
{
  return 0;	/* Assumption: O32/O64 never passes struct by ref.  */
}

a5032 12
static CORE_ADDR
mips_extract_struct_value_address (struct regcache *regcache)
{
  /* FIXME: This will only work at random.  The caller passes the
     struct_return address in V0, but it is not preserved.  It may
     still be there, or this may be a random value.  */
  LONGEST val;

  regcache_cooked_read_signed (regcache, V0_REGNUM, &val);
  return val;
}

a5895 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_o32_reg_struct_has_addr);
a5909 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_o32_reg_struct_has_addr);
a5959 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_n32n64_reg_struct_has_addr);
a5972 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_n32n64_reg_struct_has_addr);
a6072 3
  set_gdbarch_extract_struct_value_address (gdbarch, 
					    mips_extract_struct_value_address);
  
@


1.267
log
@2004-01-07  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_gdbarch_init): Move code determining the MIPS
	FPU to the start, check the MIPS FPU when looking for an old
	architecture.
	(set_mipsfpu_single_command): Update the architecture.
	(set_mipsfpu_double_command, set_mipsfpu_none_command): Ditto.
@
text
@d5691 2
@


1.266
log
@2004-01-07  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (MIPS_DEFAULT_MASK_ADDRESS_P): Delete macro.
	(mips_mask_address_p): Add "tdep" parameter.
	(show_mask_address, mips_addr_bits_remove): Update.
	(mips_dump_tdep): Update.
	(MIPS_DEFAULT_STACK_ARGSIZE): Delete macro.
	(MIPS_STACK_ARGSIZE): Delete macro.
	(mips_stack_argsize, mips_eabi_push_dummy_call): Update.
	(mips_n32n64_push_dummy_call, mips_o32_push_dummy_call): Update.
	(mips_o64_push_dummy_call, mips_o32_return_value): Update.
	(mips_dump_tdep): Update.
	(MIPS_SAVED_REGSIZE): Delete macro.
	(MIPS_DEFAULT_SAVED_REGSIZE): Delete macro.
	(mips_saved_regsize, mips_eabi_use_struct_convention): Update.
	(mips_eabi_reg_struct_has_addr, mips_find_saved_regs): Update.
	(mips_frame_saved_pc, mips16_heuristic_proc_desc): Update.
	(mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call): Update.
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Update.
	(mips_pop_frame, return_value_location): Update.
	(mips_n32n64_return_value, mips_dump_tdep): Update.
@
text
@d5122 2
d5126 5
a5130 1
  gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_SINGLE;
d5136 2
d5140 5
a5144 1
  gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_DOUBLE;
d5150 2
d5154 5
a5158 1
  gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_NONE;
d5686 1
d5786 28
d5830 3
d5843 1
a6028 22

  /* enable/disable the MIPS FPU */
  if (!mips_fpu_type_auto)
    tdep->mips_fpu_type = mips_fpu_type;
  else if (info.bfd_arch_info != NULL
	   && info.bfd_arch_info->arch == bfd_arch_mips)
    switch (info.bfd_arch_info->mach)
      {
      case bfd_mach_mips3900:
      case bfd_mach_mips4100:
      case bfd_mach_mips4111:
	tdep->mips_fpu_type = MIPS_FPU_NONE;
	break;
      case bfd_mach_mips4650:
	tdep->mips_fpu_type = MIPS_FPU_SINGLE;
	break;
      default:
	tdep->mips_fpu_type = MIPS_FPU_DOUBLE;
	break;
      }
  else
    tdep->mips_fpu_type = MIPS_FPU_DOUBLE;
@


1.265
log
@2004-01-07  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_gdbarch_init): Clean up code selecting the
	MIPS ABI.
@
text
@a170 8
/* Return the currently configured (or set) saved register size. */

#define MIPS_DEFAULT_SAVED_REGSIZE (gdbarch_tdep (current_gdbarch)->mips_default_saved_regsize)

static const char *mips_saved_regsize_string = size_auto;

#define MIPS_SAVED_REGSIZE (mips_saved_regsize())

d236 4
d241 1
a241 1
mips_saved_regsize (void)
d244 1
a244 1
    return MIPS_DEFAULT_SAVED_REGSIZE;
a366 4
#define MIPS_DEFAULT_STACK_ARGSIZE (gdbarch_tdep (current_gdbarch)->mips_default_stack_argsize)

#define MIPS_STACK_ARGSIZE (mips_stack_argsize ())

d370 1
a370 1
mips_stack_argsize (void)
d373 1
a373 1
    return MIPS_DEFAULT_STACK_ARGSIZE;
a379 2
#define MIPS_DEFAULT_MASK_ADDRESS_P (gdbarch_tdep (current_gdbarch)->default_mask_address_p)

d736 1
a736 1
mips_mask_address_p (void)
d746 1
a746 1
      return MIPS_DEFAULT_MASK_ADDRESS_P;
d757 1
d768 1
a768 1
		       mips_mask_address_p () ? "enabled" : "disabled");
d782 2
a783 1
  return (TYPE_LENGTH (type) > 2 * MIPS_SAVED_REGSIZE);
d795 1
d798 1
a798 1
    return (len > MIPS_SAVED_REGSIZE);
d1476 1
d1588 1
a1588 1
	  reg_position -= MIPS_SAVED_REGSIZE;
d1609 1
a1609 1
	    reg_position -= MIPS_SAVED_REGSIZE;
d1616 1
a1616 1
	      reg_position -= MIPS_SAVED_REGSIZE;
d1632 2
a1633 1
	  if (MIPS_SAVED_REGSIZE == 4 && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1659 1
a1659 1
				reg_position - MIPS_SAVED_REGSIZE);
d1662 1
a1662 1
				reg_position + MIPS_SAVED_REGSIZE);
d1666 1
a1666 1
	  reg_position -= MIPS_SAVED_REGSIZE;
d1703 2
a1704 1
  if (mips_mask_address_p ()
d1772 1
d1784 3
a1786 1
	saved_pc = read_memory_integer (get_frame_base (frame) - MIPS_SAVED_REGSIZE, MIPS_SAVED_REGSIZE);
d1993 1
d2099 1
a2099 1
	  offset += MIPS_SAVED_REGSIZE;
d2108 1
a2108 1
	  offset -= MIPS_SAVED_REGSIZE;
d2116 1
a2116 1
	  offset -= MIPS_SAVED_REGSIZE;
d2731 1
d2755 1
a2755 1
		     MIPS_STACK_ARGSIZE);
d2796 1
a2796 1
      if (len > MIPS_SAVED_REGSIZE
d2799 2
a2800 1
	  store_unsigned_integer (valbuf, MIPS_SAVED_REGSIZE, VALUE_ADDRESS (arg));
d2802 1
a2802 1
	  len = MIPS_SAVED_REGSIZE;
d2879 2
a2880 2
	  int odd_sized_struct = ((len > MIPS_SAVED_REGSIZE) &&
				  (len % MIPS_SAVED_REGSIZE != 0));
d2888 2
a2889 2
	      int partial_len = 
		len < MIPS_SAVED_REGSIZE ? len : MIPS_SAVED_REGSIZE;
d2907 11
a2917 9
		      if (MIPS_STACK_ARGSIZE == 8 &&
			  (typecode == TYPE_CODE_INT ||
			   typecode == TYPE_CODE_PTR ||
			   typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = MIPS_STACK_ARGSIZE - len;
		      else if ((typecode == TYPE_CODE_STRUCT ||
				typecode == TYPE_CODE_UNION) &&
			       TYPE_LENGTH (arg_type) < MIPS_STACK_ARGSIZE)
			longword_offset = MIPS_STACK_ARGSIZE - len;
d2957 1
a2957 1
				      phex (regval, MIPS_SAVED_REGSIZE));
d2972 2
a2973 1
		stack_offset += align_up (partial_len, MIPS_STACK_ARGSIZE);
d2999 1
d3021 1
a3021 1
		     MIPS_STACK_ARGSIZE);
d3091 2
a3092 2
	  int odd_sized_struct = ((len > MIPS_SAVED_REGSIZE) &&
				  (len % MIPS_SAVED_REGSIZE != 0));
d3099 2
a3100 2
	      int partial_len = len < MIPS_SAVED_REGSIZE ? 
		len : MIPS_SAVED_REGSIZE;
d3118 6
a3123 5
		      if (MIPS_STACK_ARGSIZE == 8 &&
			  (typecode == TYPE_CODE_INT ||
			   typecode == TYPE_CODE_PTR ||
			   typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = MIPS_STACK_ARGSIZE - len;
d3171 1
a3171 1
		     MIPS_SAVED_REGSIZE, generates a left shift as
d3174 8
a3181 7
		     sizeof (struct) >= MIPS_SAVED_REGSIZE).  Since it
		     is quite possible that this is GCC contradicting
		     the LE/O32 ABI, GDB has not been adjusted to
		     accommodate this.  Either someone needs to
		     demonstrate that the LE/O32 ABI specifies such a
		     left shift OR this new ABI gets identified as
		     such and GDB gets tweaked accordingly.  */
d3184 1
a3184 1
		      && partial_len < MIPS_SAVED_REGSIZE
d3187 1
a3187 1
		    regval <<= ((MIPS_SAVED_REGSIZE - partial_len) *
d3193 1
a3193 1
				      phex (regval, MIPS_SAVED_REGSIZE));
d3208 2
a3209 1
		stack_offset += align_up (partial_len, MIPS_STACK_ARGSIZE);
d3235 1
d3257 1
a3257 1
		     MIPS_STACK_ARGSIZE);
d3277 1
a3277 1
      stack_offset += MIPS_STACK_ARGSIZE;
d3374 1
a3374 1
	  stack_offset += align_up (len, MIPS_STACK_ARGSIZE);
d3386 2
a3387 2
	  int odd_sized_struct = ((len > MIPS_SAVED_REGSIZE) &&
				  (len % MIPS_SAVED_REGSIZE != 0));
d3390 1
a3390 1
	  if (MIPS_SAVED_REGSIZE < 8
d3402 2
a3403 2
	      int partial_len = 
		len < MIPS_SAVED_REGSIZE ? len : MIPS_SAVED_REGSIZE;
d3421 6
a3426 5
		      if (MIPS_STACK_ARGSIZE == 8 &&
			  (typecode == TYPE_CODE_INT ||
			   typecode == TYPE_CODE_PTR ||
			   typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = MIPS_STACK_ARGSIZE - len;
d3463 1
a3463 1
		     mips_regsize() != MIPS_SAVED_REGSIZE.  */
d3478 1
a3478 1
		     MIPS_SAVED_REGSIZE, generates a left shift as
d3481 8
a3488 7
		     sizeof (struct) >= MIPS_SAVED_REGSIZE).  Since it
		     is quite possible that this is GCC contradicting
		     the LE/O32 ABI, GDB has not been adjusted to
		     accommodate this.  Either someone needs to
		     demonstrate that the LE/O32 ABI specifies such a
		     left shift OR this new ABI gets identified as
		     such and GDB gets tweaked accordingly.  */
d3490 1
a3490 1
		  if (MIPS_SAVED_REGSIZE < 8
d3492 1
a3492 1
		      && partial_len < MIPS_SAVED_REGSIZE
d3495 1
a3495 1
		    regval <<= ((MIPS_SAVED_REGSIZE - partial_len) *
d3501 1
a3501 1
				      phex (regval, MIPS_SAVED_REGSIZE));
d3521 2
a3522 1
	      stack_offset += align_up (partial_len, MIPS_STACK_ARGSIZE);
d3548 1
d3570 1
a3570 1
		     MIPS_STACK_ARGSIZE);
d3590 1
a3590 1
      stack_offset += MIPS_STACK_ARGSIZE;
d3687 1
a3687 1
	  stack_offset += align_up (len, MIPS_STACK_ARGSIZE);
d3699 2
a3700 2
	  int odd_sized_struct = ((len > MIPS_SAVED_REGSIZE) &&
				  (len % MIPS_SAVED_REGSIZE != 0));
d3703 1
a3703 1
	  if (MIPS_SAVED_REGSIZE < 8
d3715 2
a3716 2
	      int partial_len = 
		len < MIPS_SAVED_REGSIZE ? len : MIPS_SAVED_REGSIZE;
d3734 6
a3739 5
		      if (MIPS_STACK_ARGSIZE == 8 &&
			  (typecode == TYPE_CODE_INT ||
			   typecode == TYPE_CODE_PTR ||
			   typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = MIPS_STACK_ARGSIZE - len;
d3776 1
a3776 1
		     mips_regsize() != MIPS_SAVED_REGSIZE.  */
d3791 1
a3791 1
		     MIPS_SAVED_REGSIZE, generates a left shift as
d3794 8
a3801 7
		     sizeof (struct) >= MIPS_SAVED_REGSIZE).  Since it
		     is quite possible that this is GCC contradicting
		     the LE/O32 ABI, GDB has not been adjusted to
		     accommodate this.  Either someone needs to
		     demonstrate that the LE/O32 ABI specifies such a
		     left shift OR this new ABI gets identified as
		     such and GDB gets tweaked accordingly.  */
d3803 1
a3803 1
		  if (MIPS_SAVED_REGSIZE < 8
d3805 1
a3805 1
		      && partial_len < MIPS_SAVED_REGSIZE
d3808 1
a3808 1
		    regval <<= ((MIPS_SAVED_REGSIZE - partial_len) *
d3814 1
a3814 1
				      phex (regval, MIPS_SAVED_REGSIZE));
d3834 2
a3835 1
	      stack_offset += align_up (partial_len, MIPS_STACK_ARGSIZE);
d3855 1
d3871 2
a3872 2
	/* Floating point registers must not be sign extended, 
	   in case MIPS_SAVED_REGSIZE = 4 but sizeof (FP0_REGNUM) == 8.  */
d3877 1
a3877 1
							MIPS_SAVED_REGSIZE));
d3881 1
a3881 1
					       MIPS_SAVED_REGSIZE));
d3910 3
a3912 2
		      read_memory_integer (new_sp - 2 * MIPS_SAVED_REGSIZE,
					   MIPS_SAVED_REGSIZE));
d3914 3
a3916 2
		      read_memory_integer (new_sp - 3 * MIPS_SAVED_REGSIZE,
					   MIPS_SAVED_REGSIZE));
d3919 3
a3921 2
			read_memory_integer (new_sp - 4 * MIPS_SAVED_REGSIZE,
					     MIPS_SAVED_REGSIZE));
d4612 1
d4657 1
a4657 1
	  && len < MIPS_SAVED_REGSIZE)
d4660 1
a4660 1
	  lo->reg_offset = MIPS_SAVED_REGSIZE - len;
d4666 2
a4667 2
	       && len > MIPS_SAVED_REGSIZE	/* odd-size structs */
	       && len < MIPS_SAVED_REGSIZE * 2
d4672 2
a4673 2
	  lo->reg_offset = 2 * MIPS_SAVED_REGSIZE - len;
	  lo->len = MIPS_SAVED_REGSIZE - lo->reg_offset;
d4682 1
a4682 1
	  if (len > MIPS_SAVED_REGSIZE)
d4684 2
a4685 2
	      lo->len = MIPS_SAVED_REGSIZE;
	      hi->len = len - MIPS_SAVED_REGSIZE;
d4695 1
a4695 1
	  && MIPS_SAVED_REGSIZE == 4)
d4923 1
a4923 1
	   offset += mips_stack_argsize (), regnum++)
d4925 1
a4925 1
	  int xfer = mips_stack_argsize ();
d4950 1
a4950 1
      || TYPE_LENGTH (type) > 2 * MIPS_SAVED_REGSIZE)
d6173 1
a6173 1
			  mips_mask_address_p (),
a6196 3
		      "mips_dump_tdep: MIPS_DEFAULT_SAVED_REGSIZE = %d\n",
		      MIPS_DEFAULT_SAVED_REGSIZE);
  fprintf_unfiltered (file,
d6200 2
a6201 5
		      "mips_dump_tdep: MIPS_DEFAULT_STACK_ARGSIZE = %d\n",
		      MIPS_DEFAULT_STACK_ARGSIZE);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_STACK_ARGSIZE = %d\n",
		      MIPS_STACK_ARGSIZE);
d6265 2
a6266 2
		      "mips_dump_tdep: MIPS_SAVED_REGSIZE = %d\n",
		      MIPS_SAVED_REGSIZE);
@


1.264
log
@2004-01-07  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c: Update copyright.
	(mips_gdbarch_init): Merge two code blocks handling the register
	name and number layout.
@
text
@d5647 9
a5655 8
  elf_flags = 0;

  if (info.abfd)
    {
      /* First of all, extract the elf_flags, if available.  */
      if (bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
	elf_flags = elf_elfheader (info.abfd)->e_flags;
    }
d5661 1
a5661 1
      mips_abi = MIPS_ABI_O32;
d5664 1
a5664 1
      mips_abi = MIPS_ABI_O64;
d5667 1
a5667 1
      mips_abi = MIPS_ABI_EABI32;
d5670 1
a5670 1
      mips_abi = MIPS_ABI_EABI64;
d5674 1
a5674 1
	mips_abi = MIPS_ABI_N32;
d5676 1
a5676 1
	mips_abi = MIPS_ABI_UNKNOWN;
d5681 2
a5682 2
  if (mips_abi == MIPS_ABI_UNKNOWN && info.abfd != NULL)
    bfd_map_over_sections (info.abfd, mips_find_abi_section, &mips_abi);
d5684 4
a5687 4
  /* If we have no bfd, then mips_abi will still be MIPS_ABI_UNKNOWN.
     Use the ABI from the last architecture if there is one.  */
  if (info.abfd == NULL && arches != NULL)
    mips_abi = gdbarch_tdep (arches->gdbarch)->found_abi;
d5690 1
a5690 1
  if (mips_abi == MIPS_ABI_UNKNOWN
d5697 1
a5697 1
	  mips_abi = MIPS_ABI_EABI32;
d5701 1
a5701 1
	  mips_abi = MIPS_ABI_EABI64;
d5710 1
a5710 1
	    mips_abi = MIPS_ABI_N64;
d5712 1
a5712 1
	    mips_abi = MIPS_ABI_N32;
d5717 9
a5725 2
  if (mips_abi == MIPS_ABI_UNKNOWN)
    mips_abi = MIPS_ABI_O32;
a5728 2
  found_abi = mips_abi;
  wanted_abi = global_mips_abi ();
d5731 7
d5739 1
d5741 3
a5743 11
    {
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: elf_flags = 0x%08x\n",
			  elf_flags);
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: mips_abi = %d\n",
			  mips_abi);
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: found_mips_abi = %d\n",
			  found_abi);
    }
d5769 2
a5780 2
  tdep->found_abi = found_abi;
  tdep->mips_abi = mips_abi;
@


1.263
log
@2004-01-05  Andrew Cagney  <cagney@@redhat.com>

	* ser-unix.c (ser_unix_async): Fix tipo, "NOTHING_SECHEDULED"
	should be a switch case and not a label.
	* mips-tdep.c (mips32_next_pc): Delete unused labels
	"greater_equal_branch" and "less_zero_branch".
	* jv-valprint.c (java_print_value_fields): Delete unused label
	"flush_it".
@
text
@d4 2
a5 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d5779 1
a5779 1
  /* Fill in the OS dependant register numbers.  */
d5781 1
a5783 1
    tdep->regnum = regnum;
d5795 1
d5808 5
d5820 3
a5972 8
  /* MIPS version of register names.  */
  set_gdbarch_register_name (gdbarch, mips_register_name);
  if (info.osabi == GDB_OSABI_IRIX)
    tdep->mips_processor_reg_names = mips_irix_reg_names;
  else if (info.bfd_arch_info != NULL && info.bfd_arch_info->mach == bfd_mach_mips3900)
    tdep->mips_processor_reg_names = mips_tx39_reg_names;
  else
    tdep->mips_processor_reg_names = mips_generic_reg_names;
@


1.262
log
@2003-11-25  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (mips_o64_extract_return_value): Correct for
	NUM_REGS (see changes 2003-06-21).
	(mips_eabi_extract_return_value): Ditto.
@
text
@a1085 1
	      greater_equal_branch:
a1130 1
	less_zero_branch:
@


1.261
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_unwind_signed_register): Delete function.
	* frame.h (frame_unwind_register_signed): Delete declaration.
	* mips-tdep.c (mips_frame_saved_pc): Use frame_unwind_register_signed.
@
text
@d4699 1
a4699 1
	  regbuf + DEPRECATED_REGISTER_BYTE (lo.reg) + lo.reg_offset,
d4704 1
a4704 1
	    regbuf + DEPRECATED_REGISTER_BYTE (hi.reg) + hi.reg_offset,
d4718 1
a4718 1
	  regbuf + DEPRECATED_REGISTER_BYTE (lo.reg) + lo.reg_offset,
d4723 1
a4723 1
	    regbuf + DEPRECATED_REGISTER_BYTE (hi.reg) + hi.reg_offset,
@


1.260
log
@2003-11-22  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_frame_xmalloc): Delete function.
	(deprecated_set_frame_extra_info_hack): Delete function.
	(deprecated_set_frame_saved_regs_hack): Delete function.
	* frame.h (deprecated_frame_xmalloc): Delete declaration.
	(deprecated_set_frame_extra_info_hack): Delete declaration.
	(deprecated_set_frame_saved_regs_hack): Delete declaration.
	* mcore-tdep.c (analyze_dummy_frame): Instead of
	deprecated_frame_xmalloc, deprecated_set_frame_saved_regs_hack,
	and deprecated_set_frame_extra_info_hack use
	deprecated_frame_xmalloc_with_cleanup.
	* mn10300-tdep.c (analyze_dummy_frame): Ditto.
	* mips-tdep.c (mips_init_extra_frame_info): Delete call to
	deprecated_set_frame_saved_regs_hack.
@
text
@a1779 1
      LONGEST tmp;
d1781 1
a1781 2
      frame_unwind_signed_register (frame, NUM_REGS + PC_REGNUM, &tmp);
      saved_pc = tmp;
@


1.259
log
@2003-11-22  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_frame_chain): Delete call to
	deprecated_inside_entry_file.
@
text
@a2577 1
  deprecated_set_frame_saved_regs_hack (fci, NULL);
@


1.258
log
@2003-11-22  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_register_convertible): Delete function.
	(mips_register_convert_to_virtual): Delete function.
	(mips_register_convert_to_raw): Delete function.
	(mips_gdbarch_init): Do not set "deprecated_register_convertible",
	"deprecated_register_convert_to_virtual", or
	"deprecated_register_convert_to_raw".
	(mips_pseudo_register_write, mips_pseudo_register_read): Handle
	32/64 cooked to raw register conversions.
@
text
@a2519 3
  if (saved_pc == 0 || deprecated_inside_entry_file (saved_pc))
    return 0;

@


1.257
log
@2003-11-22  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (SIGFRAME_REG_SIZE): Delete macro.
	(mips_find_saved_regs): Replace SIGFRAME_REG_SIZE with
	mips_regsize.
	(mips_dump_tdep): Do not print SIGFRAME_REG_SIZE.
	* config/mips/tm-irix6.h (SIGFRAME_REG_SIZE): Delete macro.
	* config/mips/tm-irix5.h: Update copyright.
	(SIGFRAME_REG_SIZE): Delete macro.
@
text
@d559 1
a559 1
   registers.  */
d565 1
d567 12
a578 1
  return regcache_raw_read (regcache, cookednum % NUM_REGS, buf);
d585 1
d587 12
a598 1
  return regcache_raw_write (regcache, cookednum % NUM_REGS, buf);
d657 1
a657 40
/* Convert between RAW and VIRTUAL registers.  The RAW register size
   defines the remote-gdb packet. */

static int
mips_register_convertible (int reg_nr)
{
  if (gdbarch_tdep (current_gdbarch)->mips64_transfers_32bit_regs_p)
    return 0;
  else
    return (register_size (current_gdbarch, reg_nr) > register_size (current_gdbarch, reg_nr));
}

static void
mips_register_convert_to_virtual (int n, struct type *virtual_type,
				  char *raw_buf, char *virt_buf)
{
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    memcpy (virt_buf,
	    raw_buf + (register_size (current_gdbarch, n) - TYPE_LENGTH (virtual_type)),
	    TYPE_LENGTH (virtual_type));
  else
    memcpy (virt_buf,
	    raw_buf,
	    TYPE_LENGTH (virtual_type));
}

static void
mips_register_convert_to_raw (struct type *virtual_type, int n,
			      const char *virt_buf, char *raw_buf)
{
  memset (raw_buf, 0, register_size (current_gdbarch, n));
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    memcpy (raw_buf + (register_size (current_gdbarch, n) - TYPE_LENGTH (virtual_type)),
	    virt_buf,
	    TYPE_LENGTH (virtual_type));
  else
    memcpy (raw_buf,
	    virt_buf,
	    TYPE_LENGTH (virtual_type));
}
a6011 3
  set_gdbarch_deprecated_register_convertible (gdbarch, mips_register_convertible);
  set_gdbarch_deprecated_register_convert_to_virtual (gdbarch, mips_register_convert_to_virtual);
  set_gdbarch_deprecated_register_convert_to_raw (gdbarch, mips_register_convert_to_raw);
@


1.256
log
@2003-11-22  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (skip_prologue_using_sal): New function.
	(mips32_skip_prologue, mips16_skip_prologue): Use
	skip_prologue_using_sal to get an upper bound on the search.
@
text
@a1517 4
#ifndef SIGFRAME_REG_SIZE
  /* FIXME!  Is this correct?? */
#define SIGFRAME_REG_SIZE	mips_regsize (current_gdbarch)
#endif
d1523 1
a1523 1
				    + ireg * SIGFRAME_REG_SIZE);
d1530 1
a1530 1
				    + ireg * SIGFRAME_REG_SIZE);
a6333 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SIGFRAME_REG_SIZE = %d\n",
		      SIGFRAME_REG_SIZE);
@


1.255
log
@2003-11-22  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_o32_store_return_value): Delete function.
	(mips_o32_return_value): Replace mips_o32_xfer_return_value.
	(mips_o32_extract_return_value): Delete function.
	(mips_n32n64_return_value): Replace mips_n32n64_xfer_return_value.
	(mips_n32n64_extract_return_value): Delete function.
	(mips_n32n64_store_return_value): Delete function.
	(mips_gdbarch_init): For o32 and n32n64, set "return_value"
	instead of "store_return_value", "extract_return_value", and
	"use_struct_convention".
	(mips_n32n64_use_struct_convention): Delete function.
@
text
@d4310 55
d4376 5
d4384 1
a4384 1
  for (end_pc = pc + 100; pc < end_pc; pc += MIPS_INSTLEN)
d4526 5
d4534 1
a4534 1
  for (end_pc = pc + 100; pc < end_pc; pc += MIPS16_INSTLEN)
@


1.254
log
@2003-11-16  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.h (deprecated_mips_set_processor_regs_hack): Declare.
	* remote-mips.c (common_open): Instead of
	"mips_read_register_type" and "mips_set_processor_type_command"
	call "deprecated_mips_set_processor_regs_hack".
	* config/mips/tm-mips.h (mips_read_processor_type): Delete
	declaration.
	(mips_set_processor_type_command): Delete declaration.
	* mips-tdep.c (mips_gdbarch_init): Update comment.
	(mips_dump_tdep): Do not print MIPS_REGISTER_NAMES.
	(mips_set_processor_type): Delete function.
	(NUM_MIPS_PROCESSOR_REGS): Define.
	(mips_show_processor_type_command): Delete function.
	(mips_set_processor_type_command): Delete function.
	(tmp_mips_processor_type): Delete.
	(mips_processor_type): Delete.
	(mips_processor_type_table): Delete.
	(mips_r3051_reg_names): Delete.
	(mips_r3081_reg_names): Delete.
	(mips_lsi33k_reg_names): Delete.
	(mips_processor_reg_names): Delete.
	(mips_read_processor_type): Delete function.
	(deprecated_mips_set_processor_regs_hack): New function.
	(struct gdbarch_tdep): Add member "mips_processor_reg_names".
	(mips_register_name): Get the processor names from the tdep.
	(mips_tx39_reg_names): New array.
	(mips_generic_reg_names): Wire to a standard set of names.
	(mips_gdbarch_init): Set "mips_processor_reg_names".
	* config/mips/tm-irix5.h (MIPS_REGISTER_NAMES): Delete macro.
	* config/mips/tm-mips.h (MIPS_REGISTER_NAMES): Delete macro.
	* config/mips/tm-tx39.h (MIPS_REGISTER_NAMES): Delete macro.
@
text
@a807 6
static int
mips_n32n64_use_struct_convention (int gcc_p, struct type *type)
{
  return (TYPE_LENGTH (type) > 2 * MIPS_SAVED_REGSIZE);
}

d4736 4
a4739 4
static void
mips_o32_xfer_return_value (struct type *type,
			    struct regcache *regcache,
			    bfd_byte *in, const bfd_byte *out)
d4742 8
a4749 3
  if (TYPE_CODE (type) == TYPE_CODE_FLT
      && TYPE_LENGTH (type) == 4
      && tdep->mips_fpu_type != MIPS_FPU_NONE)
d4755 5
a4759 2
      mips_xfer_register (regcache, NUM_REGS + mips_regnum (current_gdbarch)->fp0, TYPE_LENGTH (type),
			  TARGET_BYTE_ORDER, in, out, 0);
d4773 6
a4778 4
	  mips_xfer_register (regcache, NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 0, 4,
			      TARGET_BYTE_ORDER, in, out, 0);
	  mips_xfer_register (regcache, NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 1, 4,
			      TARGET_BYTE_ORDER, in, out, 4);
d4781 6
a4786 4
	  mips_xfer_register (regcache, NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 1, 4,
			      TARGET_BYTE_ORDER, in, out, 0);
	  mips_xfer_register (regcache, NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 0, 4,
			      TARGET_BYTE_ORDER, in, out, 4);
d4791 1
d4823 1
a4823 1
			      TARGET_BYTE_ORDER, in, out, offset);
d4825 1
d4848 1
a4848 1
			      BFD_ENDIAN_UNKNOWN, in, out, offset);
d4850 1
d4872 1
a4872 1
			      TARGET_BYTE_ORDER, in, out, offset);
d4874 1
a4877 14
static void
mips_o32_extract_return_value (struct type *type,
			       struct regcache *regcache,
			       void *valbuf)
{
  mips_o32_xfer_return_value (type, regcache, valbuf, NULL); 
}

static void
mips_o32_store_return_value (struct type *type, char *valbuf)
{
  mips_o32_xfer_return_value (type, current_regcache, NULL, valbuf); 
}

d4880 4
a4883 4
static void
mips_n32n64_xfer_return_value (struct type *type,
			       struct regcache *regcache,
			       bfd_byte *in, const bfd_byte *out)
d4886 7
a4892 2
  if (TYPE_CODE (type) == TYPE_CODE_FLT
      && tdep->mips_fpu_type != MIPS_FPU_NONE)
d4898 5
a4902 2
      mips_xfer_register (regcache, NUM_REGS + mips_regnum (current_gdbarch)->fp0, TYPE_LENGTH (type),
			  TARGET_BYTE_ORDER, in, out, 0);
d4933 1
a4933 1
			      TARGET_BYTE_ORDER, in, out, offset);
d4935 1
d4956 1
a4956 1
			      BFD_ENDIAN_UNKNOWN, in, out, offset);
d4958 1
d4978 1
a4978 1
			      TARGET_BYTE_ORDER, in, out, offset);
d4980 1
a4983 14
static void
mips_n32n64_extract_return_value (struct type *type,
				  struct regcache *regcache,
				  void *valbuf)
{
  mips_n32n64_xfer_return_value (type, regcache, valbuf, NULL);
}

static void
mips_n32n64_store_return_value (struct type *type, char *valbuf)
{
  mips_n32n64_xfer_return_value (type, current_regcache, NULL, valbuf);
}

d5781 1
a5781 2
      set_gdbarch_deprecated_store_return_value (gdbarch, mips_o32_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, mips_o32_extract_return_value);
a5792 2
      set_gdbarch_use_struct_convention (gdbarch, 
					 always_use_struct_convention);
d5849 1
a5849 2
      set_gdbarch_deprecated_store_return_value (gdbarch, mips_n32n64_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, mips_n32n64_extract_return_value);
a5858 2
      set_gdbarch_use_struct_convention (gdbarch, 
					 mips_n32n64_use_struct_convention);
d5864 1
a5864 2
      set_gdbarch_deprecated_store_return_value (gdbarch, mips_n32n64_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, mips_n32n64_extract_return_value);
a5873 2
      set_gdbarch_use_struct_convention (gdbarch, 
					 mips_n32n64_use_struct_convention);
@


1.253
log
@2003-11-16  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (struct gdbarch_tdep): Add field "regnum".
	(mips_fpa0_regnum, mips_regnum): New function.
	(mips_gdbarch_init): Fill in the "regnum" fields.
	* mips-tdep.h (struct mips_regnum): Define.
	(mips_regnum): Declare.
	* config/mips/tm-mips.h (BADVADDR_REGNUM): Delete macro.
	(LO_REGNUM, HI_REGNUM, BADVADDR_REGNUM): Ditto.
	(CAUSE_REGNUM, PC_REGNUM, FP0_REGNUM): Ditto.
	(FCRCS_REGNUM, FCRIR_REGNUM, FPA0_REGNUM): Ditto.
	* config/mips/tm-irix6.h (FP0_REGNUM): Delete macro.
	(PC_REGNUM, CAUSE_REGNUM, BADVADDR_REGNUM): Ditto.
	(HI_REGNUM, LO_REGNUM, FCRCS_REGNUM, FCRIR_REGNUM): Ditto.
	* config/mips/tm-irix5.h (FP0_REGNUM): Delete macro.
	(PC_REGNUM, CAUSE_REGNUM, BADVADDR_REGNUM): Ditto.
	(HI_REGNUM, LO_REGNUM, FCRCS_REGNUM, FCRIR_REGNUM): Ditto.
	* remote-mips.c: Include "mips-tdep.h".  Update.
	* mipsnbsd-tdep.c: Update.
	* mipsv4-nat.c: Update.
	* mips-tdep.c: Update.
	* mips-nat.c: Update.
	* mips-linux-tdep.c: Update.
	* mips-linux-nat.c: Update.
	* irix5-nat.c: Update.
	* dve3900-rom.c: Include "mips-tdep.h".  Update.
	(ignore_packet): Supress GCC warning.
	* config/mips/nm-riscos.h: Update.
	* Makefile.in (dve3900-rom.o, remote-mips.o): Update dependencies.
@
text
@d145 2
a397 4
static int mips_set_processor_type (char *);

static void mips_show_processor_type_command (char *, int);

a409 7
/* This value is the model of MIPS in use.  It is derived from the value
   of the PrID register.  */

char *mips_processor_type;

char *tmp_mips_processor_type;

a414 4
/* A set of original names, to be used when restoring back to generic
   registers from a specific set.  */
static char *mips_generic_reg_names[] = MIPS_REGISTER_NAMES;

d417 52
a468 3
   are listed in the sets of register names assigned to
   mips_processor_reg_names.  */
static char **mips_processor_reg_names = mips_generic_reg_names;
d474 1
d510 4
a513 1
    return mips_processor_reg_names[rawnum - 32];
a518 67
/* *INDENT-OFF* */
/* Names of IDT R3041 registers.  */

char *mips_r3041_reg_names[] = {
	"sr",	"lo",	"hi",	"bad",	"cause","pc",
	"f0",   "f1",   "f2",   "f3",   "f4",   "f5",   "f6",   "f7",
	"f8",   "f9",   "f10",  "f11",  "f12",  "f13",  "f14",  "f15",
	"f16",  "f17",  "f18",  "f19",  "f20",  "f21",  "f22",  "f23",
	"f24",  "f25",  "f26",  "f27",  "f28",  "f29",  "f30",  "f31",
	"fsr",  "fir",  "",/*"fp"*/	"",
	"",	"",	"bus",	"ccfg",	"",	"",	"",	"",
	"",	"",	"port",	"cmp",	"",	"",	"epc",	"prid",
};

/* Names of IDT R3051 registers.  */

char *mips_r3051_reg_names[] = {
	"sr",	"lo",	"hi",	"bad",	"cause","pc",
	"f0",   "f1",   "f2",   "f3",   "f4",   "f5",   "f6",   "f7",
	"f8",   "f9",   "f10",  "f11",  "f12",  "f13",  "f14",  "f15",
	"f16",  "f17",  "f18",  "f19",  "f20",  "f21",  "f22",  "f23",
	"f24",  "f25",  "f26",  "f27",  "f28",  "f29",  "f30",  "f31",
	"fsr",  "fir",  ""/*"fp"*/,	"",
	"inx",	"rand",	"elo",	"",	"ctxt",	"",	"",	"",
	"",	"",	"ehi",	"",	"",	"",	"epc",	"prid",
};

/* Names of IDT R3081 registers.  */

char *mips_r3081_reg_names[] = {
	"sr",	"lo",	"hi",	"bad",	"cause","pc",
	"f0",   "f1",   "f2",   "f3",   "f4",   "f5",   "f6",   "f7",
	"f8",   "f9",   "f10",  "f11",  "f12",  "f13",  "f14",  "f15",
	"f16",  "f17",  "f18",  "f19",  "f20",  "f21",  "f22",  "f23",
	"f24",  "f25",  "f26",  "f27",  "f28",  "f29",  "f30",  "f31",
	"fsr",  "fir",  ""/*"fp"*/,	"",
	"inx",	"rand",	"elo",	"cfg",	"ctxt",	"",	"",	"",
	"",	"",	"ehi",	"",	"",	"",	"epc",	"prid",
};

/* Names of LSI 33k registers.  */

char *mips_lsi33k_reg_names[] = {
	"epc",	"hi",	"lo",	"sr",	"cause","badvaddr",
	"dcic", "bpc",  "bda",  "",     "",     "",     "",      "",
	"",     "",     "",     "",     "",     "",     "",      "",
	"",     "",     "",     "",     "",     "",     "",      "",
	"",     "",     "",     "",     "",     "",     "",      "",
	"",     "",     "",	"",
	"",	"",	"",	"",	"",	"",	"",	 "",
	"",	"",	"",	"",	"",	"",	"",	 "",
};

struct {
  char *name;
  char **regnames;
} mips_processor_type_table[] = {
  { "generic", mips_generic_reg_names },
  { "r3041", mips_r3041_reg_names },
  { "r3051", mips_r3051_reg_names },
  { "r3071", mips_r3081_reg_names },
  { "r3081", mips_r3081_reg_names },
  { "lsi33k", mips_lsi33k_reg_names },
  { NULL, NULL }
};
/* *INDENT-ON* */

d5095 5
a5099 1
/* Command to set the processor type.  */
d5102 1
a5102 58
mips_set_processor_type_command (char *args, int from_tty)
{
  int i;

  if (tmp_mips_processor_type == NULL || *tmp_mips_processor_type == '\0')
    {
      printf_unfiltered ("The known MIPS processor types are as follows:\n\n");
      for (i = 0; mips_processor_type_table[i].name != NULL; ++i)
	printf_unfiltered ("%s\n", mips_processor_type_table[i].name);

      /* Restore the value.  */
      tmp_mips_processor_type = xstrdup (mips_processor_type);

      return;
    }

  if (!mips_set_processor_type (tmp_mips_processor_type))
    {
      error ("Unknown processor type `%s'.", tmp_mips_processor_type);
      /* Restore its value.  */
      tmp_mips_processor_type = xstrdup (mips_processor_type);
    }
}

static void
mips_show_processor_type_command (char *args, int from_tty)
{
}

/* Modify the actual processor type. */

static int
mips_set_processor_type (char *str)
{
  int i;

  if (str == NULL)
    return 0;

  for (i = 0; mips_processor_type_table[i].name != NULL; ++i)
    {
      if (strcasecmp (str, mips_processor_type_table[i].name) == 0)
	{
	  mips_processor_type = str;
	  mips_processor_reg_names = mips_processor_type_table[i].regnames;
	  return 1;
	  /* FIXME tweak fpu flag too */
	}
    }

  return 0;
}

/* Attempt to identify the particular processor model by reading the
   processor id.  */

char *
mips_read_processor_type (void)
d5104 1
d5110 1
a5110 3
    return savestring ("r3041", strlen ("r3041"));

  return NULL;
d5941 1
a5941 4
  /* MIPS version of register names.  NOTE: At present the MIPS
     register name management is part way between the old -
     #undef/#define MIPS_REGISTER_NAMES and the new REGISTER_NAME(nr).
     Further work on it is required.  */
d5943 6
a6220 2
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_REGISTER_NAMES = delete?\n");
@


1.252
log
@2003-11-16  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c: Replace DEPRECATED_REGISTER_RAW_SIZE with
	register_size.
	(mips_register_raw_size): Delete function.
	(mips_register_type): Handle "mips64_transfers_32bit_regs_p".
	(mips_gdbarch_init): Do not set "deprecated_register_raw_size".
	Check and set "mips64_transfers_32bit_regs_p".
	(struct gdbarch_tdep): Add "mips64_transfers_32bit_regs_p".
	(mips_register_convertible): Check the architecture's
	"mips64_transfers_32bit_regs_p".
	(set_mips64_transfers_32bit_regs): New function.
	(_initialize_mips_tdep): Use "add_setshow_cmd" when adding the
	"set remote-mips64-transfers-32bit-regs" command.  Specify
	set_mips64_transfers_32bit_regs as the set function.
@
text
@d141 4
d147 12
d343 1
a343 1
  if (register_size (current_gdbarch, FP0_REGNUM) == 4)
d706 1
a706 1
	  && (regnum) >= FP0_REGNUM && (regnum) < FP0_REGNUM + 32
d734 2
a735 2
  if ((regnum % NUM_REGS) >= FP0_REGNUM
      && (regnum % NUM_REGS) < FP0_REGNUM + 32)
d756 1
a756 1
  else if (regnum >= (NUM_REGS + FCRCS_REGNUM)
d1084 1
a1084 1
	  int fcrcs = read_signed_register (FCRCS_REGNUM);
d1568 1
a1568 1
	  set_reg_offset (saved_regs, FP0_REGNUM + ireg, reg_position);
d1716 1
a1716 1
		set_reg_offset (saved_regs, FP0_REGNUM + ireg,
d1719 1
a1719 1
		set_reg_offset (saved_regs, FP0_REGNUM + ireg,
d1723 1
a1723 1
	    set_reg_offset (saved_regs, FP0_REGNUM + ireg, reg_position);
d2823 1
a2823 1
  float_argreg = FPA0_REGNUM;
d3084 1
a3084 1
  float_argreg = FPA0_REGNUM;
d3316 1
a3316 1
  float_argreg = FPA0_REGNUM;
d3625 1
a3625 1
  float_argreg = FPA0_REGNUM;
d3915 1
a3915 1
	if (FP0_REGNUM <= regnum && regnum < FP0_REGNUM + 32)
d3950 1
a3950 1
      write_register (HI_REGNUM,
d3953 1
a3953 1
      write_register (LO_REGNUM,
d3957 1
a3957 1
	write_register (FCRCS_REGNUM,
d4061 1
a4061 1
      if ((regno - FP0_REGNUM) & 1)
d4089 1
a4089 1
  raw_buffer = (char *) alloca (2 * register_size (current_gdbarch, FP0_REGNUM));
d4597 1
a4597 1
			     && register_size (current_gdbarch, FP0_REGNUM) == 8)
d4600 2
a4601 2
	  lo->reg = FP0_REGNUM + 0;
	  hi->reg = FP0_REGNUM + 1;
d4610 1
a4610 1
			     && register_size (current_gdbarch, FP0_REGNUM) == 8
d4613 1
a4613 1
	  lo->reg = FP0_REGNUM;
d4783 1
a4783 1
      mips_xfer_register (regcache, NUM_REGS + FP0_REGNUM, TYPE_LENGTH (type),
d4798 1
a4798 1
	  mips_xfer_register (regcache, NUM_REGS + FP0_REGNUM + 0, 4,
d4800 1
a4800 1
	  mips_xfer_register (regcache, NUM_REGS + FP0_REGNUM + 1, 4,
d4804 1
a4804 1
	  mips_xfer_register (regcache, NUM_REGS + FP0_REGNUM + 1, 4,
d4806 1
a4806 1
	  mips_xfer_register (regcache, NUM_REGS + FP0_REGNUM + 0, 4,
d4833 1
a4833 1
      for (field = 0, regnum = FP0_REGNUM;
d4924 1
a4924 1
      mips_xfer_register (regcache, NUM_REGS + FP0_REGNUM, TYPE_LENGTH (type),
d4946 1
a4946 1
      for (field = 0, regnum = FP0_REGNUM;
d5580 1
a5580 1
    regnum = num + FP0_REGNUM - 38;
d5582 1
a5582 1
    regnum = HI_REGNUM;
d5584 1
a5584 1
    regnum = LO_REGNUM;
d5603 1
a5603 1
    regnum = num + FP0_REGNUM - 32;
d5605 1
a5605 1
    regnum = HI_REGNUM;
d5607 1
a5607 1
    regnum = LO_REGNUM;
d5828 36
a5863 7

  if (info.osabi == GDB_OSABI_IRIX)
    num_regs = 71;
  else
    num_regs = 90;
  set_gdbarch_num_regs (gdbarch, num_regs);
  set_gdbarch_num_pseudo_regs (gdbarch, num_regs);
d5875 1
a5875 1
      tdep->mips_last_fp_arg_regnum = FPA0_REGNUM + 4 - 1;
d5893 1
a5893 1
      tdep->mips_last_fp_arg_regnum = FPA0_REGNUM + 4 - 1;
d5910 1
a5910 1
      tdep->mips_last_fp_arg_regnum = FPA0_REGNUM + 8 - 1;
d5928 1
a5928 1
      tdep->mips_last_fp_arg_regnum = FPA0_REGNUM + 8 - 1;
d5946 1
a5946 1
      tdep->mips_last_fp_arg_regnum = FPA0_REGNUM + 8 - 1;
d5964 1
a5964 1
      tdep->mips_last_fp_arg_regnum = FPA0_REGNUM + 8 - 1;
a6218 4
		      "mips_dump_tdep: MIPS_LAST_FP_ARG_REGNUM = %d (%d regs)\n",
		      MIPS_LAST_FP_ARG_REGNUM,
		      MIPS_LAST_FP_ARG_REGNUM - FPA0_REGNUM + 1);
  fprintf_unfiltered (file,
a6246 6
		      "mips_dump_tdep: BADVADDR_REGNUM = %d\n",
		      BADVADDR_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: CAUSE_REGNUM = %d\n",
		      CAUSE_REGNUM);
  fprintf_unfiltered (file,
a6252 6
		      "mips_dump_tdep: FCRCS_REGNUM = %d\n",
		      FCRCS_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: FCRIR_REGNUM = %d\n",
		      FCRIR_REGNUM);
  fprintf_unfiltered (file,
a6255 6
		      "mips_dump_tdep: FPA0_REGNUM = %d\n",
		      FPA0_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep:  HI_REGNUM = %d\n",
		      HI_REGNUM);
  fprintf_unfiltered (file,
a6266 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: LO_REGNUM = %d\n",
		      LO_REGNUM);
@


1.251
log
@2003-11-16  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_register_byte): Delete function.
	(mips_gdbarch_init): Do not set "deprecated_register_byte".
	* config/mips/tm-mips.h (MIPS_REGISTER_BYTE): Delete macro.
	* config/mips/tm-irix6.h (MIPS_REGISTER_BYTE): Delete macro.
	* config/mips/tm-irix5.h (MIPS_REGISTER_BYTE): Delete macro.
@
text
@d138 3
d186 1
a186 1
  void *buf = alloca (DEPRECATED_REGISTER_RAW_SIZE (regnum));
d188 1
a188 1
  return (extract_signed_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regnum)));
d281 1
a281 1
      reg_offset = DEPRECATED_REGISTER_RAW_SIZE (reg_num) - length;
d327 1
a327 1
  if (DEPRECATED_REGISTER_RAW_SIZE (FP0_REGNUM) == 4)
d623 2
a624 2
   register N.  NOTE: This indirectly defines the register size
   transfered by the GDB protocol.  */
d628 3
a630 2
static int
mips_register_raw_size (int regnum)
d632 6
a637 2
  gdb_assert (regnum >= 0);
  if (regnum < NUM_REGS)
d639 2
a640 17
      /* For compatibility with old code, implemnt the broken register raw
	 size map for the raw registers.

	 NOTE: cagney/2003-06-15: This is so bogus.  The register's
	 raw size is changing according to the ABI
	 (FP_REGISTER_DOUBLE).  Also, GDB's protocol is defined by a
	 combination of DEPRECATED_REGISTER_RAW_SIZE and
	 DEPRECATED_REGISTER_BYTE.  */
      if (mips64_transfers_32bit_regs_p)
	return register_size (current_gdbarch, regnum);
      else if (regnum >= FP0_REGNUM && regnum < FP0_REGNUM + 32
	       && FP_REGISTER_DOUBLE)
	/* For MIPS_ABI_N32 (for example) we need 8 byte floating point
	   registers.  */
	return 8;
      else
	return mips_regsize (current_gdbarch);
a641 8
  else if (regnum < 2 * NUM_REGS)
    {
      /* For the moment map [NUM_REGS .. 2*NUM_REGS) onto the same raw
	 registers, but return the register's virtual size.  */
      return TYPE_LENGTH (gdbarch_register_type (current_gdbarch, regnum));
    }
  else
    internal_error (__FILE__, __LINE__, "Register %d out of range", regnum);
d650 1
a650 1
  if (mips64_transfers_32bit_regs_p)
d653 1
a653 1
    return (DEPRECATED_REGISTER_RAW_SIZE (reg_nr) > register_size (current_gdbarch, reg_nr));
d662 1
a662 1
	    raw_buf + (DEPRECATED_REGISTER_RAW_SIZE (n) - TYPE_LENGTH (virtual_type)),
d674 1
a674 1
  memset (raw_buf, 0, DEPRECATED_REGISTER_RAW_SIZE (n));
d676 1
a676 1
    memcpy (raw_buf + (DEPRECATED_REGISTER_RAW_SIZE (n) - TYPE_LENGTH (virtual_type)),
d689 1
a689 1
	  && DEPRECATED_REGISTER_RAW_SIZE (regnum) == 4
d745 6
d4002 1
a4002 1
  int raw_size = DEPRECATED_REGISTER_RAW_SIZE (regno);
d4034 1
a4034 1
  int raw_size = DEPRECATED_REGISTER_RAW_SIZE (regno);
d4073 1
a4073 1
  raw_buffer = (char *) alloca (2 * DEPRECATED_REGISTER_RAW_SIZE (FP0_REGNUM));
d4079 1
a4079 1
  if (DEPRECATED_REGISTER_RAW_SIZE (regnum) == 4 || mips2_fp_compat ())
d4166 1
a4166 1
    offset = DEPRECATED_REGISTER_RAW_SIZE (regnum) - register_size (current_gdbarch, regnum);
d4241 2
a4242 2
	for (byte = DEPRECATED_REGISTER_RAW_SIZE (regnum) - register_size (current_gdbarch, regnum);
	     byte < DEPRECATED_REGISTER_RAW_SIZE (regnum);
d4581 1
a4581 1
			     && DEPRECATED_REGISTER_RAW_SIZE (FP0_REGNUM) == 8)
d4594 1
a4594 1
			     && DEPRECATED_REGISTER_RAW_SIZE (FP0_REGNUM) == 8
d4650 1
a4650 1
	  && DEPRECATED_REGISTER_RAW_SIZE (regnum) == 8
d4718 1
a4718 1
				   DEPRECATED_REGISTER_RAW_SIZE (lo.reg));
d4725 1
a4725 1
				       DEPRECATED_REGISTER_RAW_SIZE (hi.reg));
d4740 1
a4740 1
				   DEPRECATED_REGISTER_RAW_SIZE (lo.reg));
d4747 1
a4747 1
				       DEPRECATED_REGISTER_RAW_SIZE (hi.reg));
d4842 1
a4842 1
	   offset += DEPRECATED_REGISTER_RAW_SIZE (regnum), regnum++)
d4844 1
a4844 1
	  int xfer = DEPRECATED_REGISTER_RAW_SIZE (regnum);
d4953 1
a4953 1
	   offset += DEPRECATED_REGISTER_RAW_SIZE (regnum), regnum++)
d4955 1
a4955 1
	  int xfer = DEPRECATED_REGISTER_RAW_SIZE (regnum);
d4973 1
a4973 1
	   offset += DEPRECATED_REGISTER_RAW_SIZE (regnum), regnum++)
d4975 1
a4975 1
	  int xfer = DEPRECATED_REGISTER_RAW_SIZE (regnum);
d5783 5
d5795 1
a5802 1
  set_gdbarch_deprecated_register_raw_size (gdbarch, mips_register_raw_size);
d6554 7
a6560 5
  add_show_from_set (add_set_cmd ("remote-mips64-transfers-32bit-regs",
				  class_obscure,
				  var_boolean,
				  (char *)&mips64_transfers_32bit_regs_p, "\
Set compatibility with MIPS targets that transfers 32 and 64 bit quantities.\n\
d6564 2
a6565 2
				  &setlist),
		     &showlist);
@


1.250
log
@2003-11-16  Andrew Cagney  <cagney@@redhat.com>

	* config/mips/linux64.mt: Delete file.
	* config/mips/tm-linux64.h: Delete file.
	* config/mips/tm-mips64.h: Delete file.
	* config/mips/embed64.mt: Delete file.
	* config/djgpp/fnchange.lst: Update.
	* configure.tgt: Delete explicit patterns for mipsisa64*-*-linux*,
	mips64*-*-linux*, mips64*-*-*, and mipsisa64*-*-*.
	* config/mips/tm-irix6.h: Update copyright.  Include
	"mips/tm-mips.h" instead of "mips/tm-mips64.h".
	* mips-tdep.c (mips_dump_tdep): Do not print "OP_LDFPR" or
	"OP_LDGPR".
@
text
@a658 31
/* Register offset in a buffer for each register.

   FIXME: cagney/2003-06-15: This is so bogus.  Instead REGISTER_TYPE
   should strictly return the layout of the buffer.  Unfortunately
   remote.c and the MIPS have come to rely on a custom layout that
   doesn't 1:1 map onto the register type.  */

static int
mips_register_byte (int regnum)
{
  gdb_assert (regnum >= 0);
  if (regnum < NUM_REGS)
    /* Pick up the relevant per-tm file register byte method.  */
    return MIPS_REGISTER_BYTE (regnum);
  else if (regnum < 2 * NUM_REGS)
    {
      int reg;
      int byte;
      /* Start with the end of the raw register buffer - assum that
	 MIPS_REGISTER_BYTE (NUM_REGS) returns that end.  */
      byte = MIPS_REGISTER_BYTE (NUM_REGS);
      /* Add space for all the proceeding registers based on their
         real size.  */
      for (reg = NUM_REGS; reg < regnum; reg++)
	byte += TYPE_LENGTH (gdbarch_register_type (current_gdbarch, reg));
      return byte;
    }
  else
    internal_error (__FILE__, __LINE__, "Register %d out of range", regnum);
}

a5806 1
  set_gdbarch_deprecated_register_byte (gdbarch, mips_register_byte);
@


1.249
log
@2003-11-15  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_register_type): Simplify.  Eliminate reference
	to MIPS_REGISTER_TYPE.  Make integer registers signed.  Make IRIX
	n32 registers 64 bit.
	(mips_register_raw_size, mips_register_byte): For pseudo
	registers, use the register's pseudo size and not the
	corresponding raw register's size.
	* config/mips/tm-mips64.h (MIPS_REGISTER_TYPE): Delete macro.
	* config/mips/tm-mips.h (MIPS_REGISTER_TYPE): Delete macro.
	* config/mips/tm-irix6.h: Don't #undef MIPS_REGISTER_TYPE.
	* config/mips/tm-irix5.h (MIPS_REGISTER_TYPE): Delete macro.
@
text
@a6320 4
		      "mips_dump_tdep: OP_LDFPR = used?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: OP_LDGPR = used?\n");
  fprintf_unfiltered (file,
@


1.248
log
@2003-11-15  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (struct gdbarch_tdep): Delete member
	gdb_target_is_mips64.
	(GDB_TARGET_IS_MIPS64): Delete macro.
	(mips_gdbarch_init): Do not set tdep's gdb_target_is_mips64.
	(mips_dump_tdep): Do not print GDB_TARGET_IS_MIPS64.
	(mips_addr_bits_remove): Simplify.
@
text
@d652 2
a653 3
	 registers, but always return the virtual size.  */
      int rawnum = regnum % NUM_REGS;
      return TYPE_LENGTH (gdbarch_register_type (current_gdbarch, rawnum));
d683 1
a683 2
	byte += TYPE_LENGTH (gdbarch_register_type (current_gdbarch,
                                                    (reg % NUM_REGS)));
d763 3
a765 8
  /* For moment, map [NUM_REGS .. 2*NUM_REGS) onto the same raw
     registers.  Even return the same type.  */
  int rawnum = regnum % NUM_REGS;
  gdb_assert (rawnum >= 0 && rawnum < NUM_REGS);
#ifdef MIPS_REGISTER_TYPE
  return MIPS_REGISTER_TYPE (rawnum);
#else
  if (FP0_REGNUM <= rawnum && rawnum < FP0_REGNUM + 32)
d767 18
a784 5
      /* Floating point registers...  */
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	return builtin_type_ieee_double_big;
      else
	return builtin_type_ieee_double_little;
d786 8
a793 4
  else if (rawnum == PS_REGNUM /* CR */)
    return builtin_type_uint32;
  else if (FCRCS_REGNUM <= rawnum && rawnum <= LAST_EMBED_REGNUM)
    return builtin_type_uint32;
d795 2
a796 9
    {
      /* Everything else...
         Return type appropriate for width of register.  */
      if (mips_regsize (current_gdbarch) == TYPE_LENGTH (builtin_type_uint64))
	return builtin_type_uint64;
      else
	return builtin_type_uint32;
    }
#endif
@


1.247
log
@2003-11-15  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c: Replace DEPRECATED_REGISTER_VIRTUAL_SIZE with
	register_size.
@
text
@a136 1
    int gdb_target_is_mips64;
d342 1
a342 3
   form double-precision values).  Do not use "TARGET_IS_MIPS64" to
   determine if the ABI is using double-precision registers.  See also
   MIPS_FPU_TYPE. */
a365 2
#define GDB_TARGET_IS_MIPS64 (gdbarch_tdep (current_gdbarch)->gdb_target_is_mips64 + 0)

d1782 20
a1801 34
  if (GDB_TARGET_IS_MIPS64)
    {
      if (mips_mask_address_p () && (addr >> 32 == (CORE_ADDR) 0xffffffff))
	{
	  /* This hack is a work-around for existing boards using
	     PMON, the simulator, and any other 64-bit targets that
	     doesn't have true 64-bit addressing.  On these targets,
	     the upper 32 bits of addresses are ignored by the
	     hardware.  Thus, the PC or SP are likely to have been
	     sign extended to all 1s by instruction sequences that
	     load 32-bit addresses.  For example, a typical piece of
	     code that loads an address is this:
	         lui $r2, <upper 16 bits>
	         ori $r2, <lower 16 bits>
	     But the lui sign-extends the value such that the upper 32
	     bits may be all 1s.  The workaround is simply to mask off
	     these bits.  In the future, gcc may be changed to support
	     true 64-bit addressing, and this masking will have to be
	     disabled.  */
	  addr &= (CORE_ADDR) 0xffffffff;
	}
    }
  else if (mips_mask_address_p ())
    {
      /* FIXME: This is wrong!  mips_addr_bits_remove() shouldn't be
         masking off bits, instead, the actual target should be asking
         for the address to be converted to a valid pointer. */
      /* Even when GDB is configured for some 32-bit targets
	 (e.g. mips-elf), BFD is configured to handle 64-bit targets,
	 so CORE_ADDR is 64 bits.  So we still have to mask off
	 useless bits from addresses.  */
      addr &= (CORE_ADDR) 0xffffffff;
    }
  return addr;
a5863 1
      tdep->gdb_target_is_mips64 = 0;
a5881 1
      tdep->gdb_target_is_mips64 = 1;
a5898 1
      tdep->gdb_target_is_mips64 = 0;
a5916 1
      tdep->gdb_target_is_mips64 = 1;
a5934 1
      tdep->gdb_target_is_mips64 = 1;
a5952 1
      tdep->gdb_target_is_mips64 = 1;
a6261 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: GDB_TARGET_IS_MIPS64 = %d\n",
		      GDB_TARGET_IS_MIPS64);
@


1.246
log
@2003-11-15  Andrew Cagney  <cagney@@redhat.com>

	Replace MIPS_REGSIZE with mips_regsize.
	* mips-tdep.c (mips_regsize): New function.
	* mips-tdep.h (mips_regsize): Declare.
	* mipsnbsd-tdep.h (SIZEOF_STRUCT_FPREG): Update.
	(SIZEOF_STRUCT_REG): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg): Update.
	(mipsnbsd_fill_reg): Update.
	(mipsnbsd_supply_fpreg): Update.
	(mipsnbsd_fill_fpreg): Update.
	(NBSD_MIPS_JB_ELEMENT_SIZE): Update.
	* mips-tdep.c (mips_register_raw_size): Update.
	(mips_register_type): Update.
	(SIGFRAME_BASE): Update.
	(SIGFRAME_PC_OFF): Update.
	(SIGFRAME_REGSAVE_OFF): Update.
	(SIGFRAME_FPREGSAVE_OFF): Update.
	(SIGFRAME_REG_SIZE): Update.
	(mips32_heuristic_proc_desc): Update.
	(print_gp_register_row): Update.
	(mips_dump_tdep): Do not print MIPS_REGSIZE.
	* irix5-nat.c (supply_gregset): Update.
	(fetch_core_registers): Update.
	* config/mips/tm-mips64.h (MIPS_REGSIZE): Delete macro.
	* config/mips/tm-irix6.h (MIPS_REGISTER_BYTE): Update.
	* config/mips/tm-mips.h (MIPS_REGSIZE): Delete macro.
	(MIPS_REGISTER_BYTE): Update.
	* config/mips/tm-irix5.h (MIPS_REGISTER_BYTE): Update.
@
text
@d642 2
a643 1
	 combination of DEPRECATED_REGISTER_RAW_SIZE and DEPRECATED_REGISTER_BYTE.  */
d645 1
a645 1
	return DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum);
d706 1
a706 1
    return (DEPRECATED_REGISTER_RAW_SIZE (reg_nr) > DEPRECATED_REGISTER_VIRTUAL_SIZE (reg_nr));
d4222 1
a4222 1
    offset = DEPRECATED_REGISTER_RAW_SIZE (regnum) - DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum);
d4292 1
a4292 1
		   - DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
d4297 1
a4297 1
	for (byte = DEPRECATED_REGISTER_RAW_SIZE (regnum) - DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum);
d4302 1
a4302 1
	for (byte = DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum) - 1;
@


1.245
log
@2003-11-11  Michael Chastain  <mec.gnu@@mindspring.com>

	* mips-tdep.c (msymbol_size): Delete.
@
text
@d216 7
d651 1
a651 1
	return MIPS_REGSIZE;
d792 1
a792 1
      if (MIPS_REGSIZE == TYPE_LENGTH (builtin_type_uint64))
d1569 1
a1569 1
#define SIGFRAME_BASE		MIPS_REGSIZE
d1571 2
a1572 2
#define SIGFRAME_PC_OFF		(SIGFRAME_BASE + 2 * MIPS_REGSIZE)
#define SIGFRAME_REGSAVE_OFF	(SIGFRAME_BASE + 3 * MIPS_REGSIZE)
d1574 1
a1574 1
        (SIGFRAME_REGSAVE_OFF + MIPS_NUMREGS * MIPS_REGSIZE + 3 * MIPS_REGSIZE)
d1578 1
a1578 1
#define SIGFRAME_REG_SIZE	MIPS_REGSIZE
d2262 1
a2262 1
	  set_reg_offset (temp_saved_regs, reg, sp + low_word + 8 - MIPS_REGSIZE);
d2970 5
a2974 4
	  /* Note: structs whose size is not a multiple of MIPS_REGSIZE
	     are treated specially: Irix cc passes them in registers
	     where gcc sometimes puts them on the stack.  For maximum
	     compatibility, we will put them in both places.  */
d3178 5
a3182 4
	  /* Note: structs whose size is not a multiple of MIPS_REGSIZE
	     are treated specially: Irix cc passes them in registers
	     where gcc sometimes puts them on the stack.  For maximum
	     compatibility, we will put them in both places.  */
d3469 5
a3473 4
	  /* Note: structs whose size is not a multiple of MIPS_REGSIZE
	     are treated specially: Irix cc passes them in registers
	     where gcc sometimes puts them on the stack.  For maximum
	     compatibility, we will put them in both places.  */
d3549 2
a3550 2
		  /* Value may need to be sign extended, because 
		     MIPS_REGSIZE != MIPS_SAVED_REGSIZE.  */
d3778 5
a3782 4
	  /* Note: structs whose size is not a multiple of MIPS_REGSIZE
	     are treated specially: Irix cc passes them in registers
	     where gcc sometimes puts them on the stack.  For maximum
	     compatibility, we will put them in both places.  */
d3858 2
a3859 2
		  /* Value may need to be sign extended, because 
		     MIPS_REGSIZE != MIPS_SAVED_REGSIZE.  */
d4252 1
a4252 1
  int ncols = (MIPS_REGSIZE == 8 ? 4 : 8);	/* display cols per row */
d4266 1
a4266 1
      fprintf_filtered (file, MIPS_REGSIZE == 8 ? "%17s" : "%9s",
d4289 4
a4292 1
      for (byte = 0; byte < (MIPS_REGSIZE - DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum)); byte++)
a6252 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_REGSIZE = %d\n",
		      MIPS_REGSIZE);
@


1.244
log
@2003-11-07  Michael Chastain  <mec@@shout.net>

	* symtab.h (struct minimal_symbol): Add size.
	* dbxread.c: Use it.
	* elfread.c: (record_minimal_symbol_and_info): Do not use info.
	Rename to record_minimal_symbol.
	(elf_symtab_read): Set MSYMBOL_SIZE explicitly.
	* minsyms.c (prim_record_minimal_symbol_and_info): Initialize MSYMBOL_SIZE.
	(install_minimal_symbols): Ditto.
	* objfiles.c (terminate_minimal_symbol_table): Ditto.
	* arm-tdep.c: Delete unused MSYMBOL_SIZE.
	* m68hc11-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
@
text
@a253 6
static long
msymbol_size (struct minimal_symbol *msym)
{
  return ((long) MSYMBOL_INFO (msym) & 0x7fffffff);
}

@


1.243
log
@2003-11-05  Andrew Cagney  <cagney@@redhat.com>

	* xcoffread.c (find_linenos): Replace "sec_ptr" and "bfd" with
	"struct bfd_section" and "struct bfd".
	* target.h (struct section_table): Ditto.
	* rs6000-nat.c (xcoff_relocate_core): Ditto.
	* solib-svr4.c (elf_locate_base): Ditto.
	* pa64solib.c (dld_cache_t): Ditto.
	* objfiles.h (struct obj_section): Ditto.
	* objfiles.c (add_to_objfile_sections): Ditto.
	* exec.c (bfdsec_to_vmap): Ditto.
	(add_to_section_table): Ditto.
	(build_section_table): Ditto.
	* corelow.c (get_core_register_section): Ditto.
	* coffread.c (find_linenos): Ditto.
	* elfread.c (elf_interpreter): Delete #if0'd function.

	* mips-tdep.c (mips_dump_tdep): Delete code prinint VX_NUM_REGS.
	* config/sparc/tm-vxsparc.h (VX_NUM_REGS): Delete macro.
	* config/mips/tm-vxmips.h (VX_NUM_REGS): Delete macro.
	* config/m68k/tm-vx68.h (VX_NUM_REGS): Delete macro.

	* arch-utils.h (generic_cannot_extract_struct_value_address):
	Delete declaration.
	* wince.c (_initialize_wince): Fix multi-line string.
	* ia64-tdep.c (floatformat_valid): Convert to ISO C.
@
text
@d229 1
a229 3
   "info" field is used for this purpose. This field is already
   being used to store the symbol size, so the assumption is
   that the symbol size cannot exceed 2^31.
d235 1
a235 3
   MSYMBOL_IS_SPECIAL   tests the "special" bit in a minimal symbol
   MSYMBOL_SIZE         returns the size of the minimal symbol, i.e.
   the "info" field with the "special" bit masked out */
@


1.242
log
@2003-11-05  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_dump_tdep): Do not print
	PRINT_EXTRA_FRAME_INFO.
	* config/sparc/tm-sparc.h (DEPRECATED_PRINT_EXTRA_FRAME_INFO):
	Rename PRINT_EXTRA_FRAME_INFO.
	* mips-tdep.c (mips_print_extra_frame_info): Delete function.
	* config/mips/tm-mips.h (PRINT_EXTRA_FRAME_INFO): Delete macro.
	(mips_print_extra_frame_info): Delete declaration.
	* stack.c (frame_info): Use DEPRECATED_PRINT_EXTRA_FRAME_INFO.
@
text
@a6482 5
#ifdef VX_NUM_REGS
  fprintf_unfiltered (file,
		      "mips_dump_tdep: VX_NUM_REGS = %d (used?)\n",
		      VX_NUM_REGS);
#endif
@


1.241
log
@Index: mi/ChangeLog
2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* tui-out.c: Fix "fortunatly"[sic].

Index: doc/ChangeLog
2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* annotate.texinfo: Fix "fortunatly"[sic].

2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* osabi.c (gdbarch_init_osabi): Fix typos, and "fortunatly"[sic].
	* PROBLEMS, arch-utils.c, cli-out.c, command.h: Ditto.
	* complaints.c, cris-tdep.c, disasm.c, dwarf2-frame.c: Ditto.
	* frame.c, frame.h, infcall.c, infcmd.c, infrun.c: Ditto.
	* kod.c, mips-tdep.c, regcache.c, regcache.h, remote.c: Ditto.
@
text
@a626 12
void
mips_print_extra_frame_info (struct frame_info *fi)
{
  if (fi
      && get_frame_extra_info (fi)
      && get_frame_extra_info (fi)->proc_desc
      && get_frame_extra_info (fi)->proc_desc->pdr.framereg < NUM_REGS)
    printf_filtered (" frame pointer is at %s+%s\n",
		     REGISTER_NAME (get_frame_extra_info (fi)->proc_desc->pdr.framereg),
		     paddr_d (get_frame_extra_info (fi)->proc_desc->pdr.frameoffset));
}

a6349 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PRINT_EXTRA_FRAME_INFO # %s\n",
		      XSTRING (PRINT_EXTRA_FRAME_INFO (FRAME)));
@


1.240
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d682 1
a682 1
   should strictly return the layout of the buffer.  Unfortunatly
d1744 1
a1744 1
		 Unfortunatly, when big-endian the most significant
@


1.239
log
@2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_VIRTUAL_SIZE to
	DEPRECATED_REGISTER_VIRTUAL_SIZE.

2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_VIRTUAL_SIZE): Rename
	REGISTER_VIRTUAL_SIZE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* vax-tdep.h, sparc-tdep.c, regcache.h: Update.
	* regcache.c, mn10300-tdep.c, mips-tdep.c: Update.
	* infcmd.c, frame.c, findvar.c, cris-tdep.c: Update.

2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_VIRTUAL_SIZE to DEPRECATED_REGISTER_VIRTUAL_SIZE.
	(Target Architecture Definition):
@
text
@d184 1
a184 1
  void *buf = alloca (REGISTER_RAW_SIZE (regnum));
d186 1
a186 1
  return (extract_signed_integer (buf, REGISTER_RAW_SIZE (regnum)));
d282 1
a282 1
      reg_offset = REGISTER_RAW_SIZE (reg_num) - length;
d328 1
a328 1
  if (REGISTER_RAW_SIZE (FP0_REGNUM) == 4)
d657 1
a657 1
	 combination of REGISTER_RAW_SIZE and DEPRECATED_REGISTER_BYTE.  */
d720 1
a720 1
    return (REGISTER_RAW_SIZE (reg_nr) > DEPRECATED_REGISTER_VIRTUAL_SIZE (reg_nr));
d729 1
a729 1
	    raw_buf + (REGISTER_RAW_SIZE (n) - TYPE_LENGTH (virtual_type)),
d741 1
a741 1
  memset (raw_buf, 0, REGISTER_RAW_SIZE (n));
d743 1
a743 1
    memcpy (raw_buf + (REGISTER_RAW_SIZE (n) - TYPE_LENGTH (virtual_type)),
d756 1
a756 1
	  && REGISTER_RAW_SIZE (regnum) == 4
d4068 1
a4068 1
  int raw_size = REGISTER_RAW_SIZE (regno);
d4100 1
a4100 1
  int raw_size = REGISTER_RAW_SIZE (regno);
d4139 1
a4139 1
  raw_buffer = (char *) alloca (2 * REGISTER_RAW_SIZE (FP0_REGNUM));
d4145 1
a4145 1
  if (REGISTER_RAW_SIZE (regnum) == 4 || mips2_fp_compat ())
d4232 1
a4232 1
    offset = REGISTER_RAW_SIZE (regnum) - DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum);
d4304 2
a4305 2
	for (byte = REGISTER_RAW_SIZE (regnum) - DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum);
	     byte < REGISTER_RAW_SIZE (regnum);
d4644 1
a4644 1
			     && REGISTER_RAW_SIZE (FP0_REGNUM) == 8)
d4657 1
a4657 1
			     && REGISTER_RAW_SIZE (FP0_REGNUM) == 8
d4713 1
a4713 1
	  && REGISTER_RAW_SIZE (regnum) == 8
d4781 1
a4781 1
				   REGISTER_RAW_SIZE (lo.reg));
d4788 1
a4788 1
				       REGISTER_RAW_SIZE (hi.reg));
d4803 1
a4803 1
				   REGISTER_RAW_SIZE (lo.reg));
d4810 1
a4810 1
				       REGISTER_RAW_SIZE (hi.reg));
d4905 1
a4905 1
	   offset += REGISTER_RAW_SIZE (regnum), regnum++)
d4907 1
a4907 1
	  int xfer = REGISTER_RAW_SIZE (regnum);
d5016 1
a5016 1
	   offset += REGISTER_RAW_SIZE (regnum), regnum++)
d5018 1
a5018 1
	  int xfer = REGISTER_RAW_SIZE (regnum);
d5036 1
a5036 1
	   offset += REGISTER_RAW_SIZE (regnum), regnum++)
d5038 1
a5038 1
	  int xfer = REGISTER_RAW_SIZE (regnum);
@


1.238
log
@2003-09-28  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_read_unsigned_register): Delete function.
	* frame.h (frame_read_unsigned_register): Delete declaration.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	get_frame_register_unsigned.
	(sparc_frame_saved_pc, sparc_pop_frame): Ditto.
	* m68hc11-tdep.c (m68hc11_print_register): Ditto.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.

	* frame.h (frame_read_register): Delete declaration.
	* frame.c (frame_read_register): Delete function.
	* arch-utils.c (legacy_register_to_value): Use get_frame_register.
	* sparc-tdep.c (sparc_fetch_pointer_argument): Ditto.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* hppa-tdep.c (hppa_fetch_pointer_argument): Ditto.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.

	* frame.c (frame_read_signed_register): Delete function.
	(frame_read_unsigned_register): Update comments.
	* frame.h (frame_read_signed_register): Delete declaration.
	* h8300-tdep.c (h8300_print_register): Use
	get_frame_register_signed.
	* m68hc11-tdep.c (m68hc11_print_register): Ditto.
@
text
@d659 1
a659 1
	return REGISTER_VIRTUAL_SIZE (regnum);
d720 1
a720 1
    return (REGISTER_RAW_SIZE (reg_nr) > REGISTER_VIRTUAL_SIZE (reg_nr));
d4232 1
a4232 1
    offset = REGISTER_RAW_SIZE (regnum) - REGISTER_VIRTUAL_SIZE (regnum);
d4300 1
a4300 1
      for (byte = 0; byte < (MIPS_REGSIZE - REGISTER_VIRTUAL_SIZE (regnum)); byte++)
d4304 1
a4304 1
	for (byte = REGISTER_RAW_SIZE (regnum) - REGISTER_VIRTUAL_SIZE (regnum);
d4309 1
a4309 1
	for (byte = REGISTER_VIRTUAL_SIZE (regnum) - 1;
@


1.237
log
@2003-09-25  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_frame_saved_regs): Rename
	get_frame_saved_regs.
	* cris-tdep.c, frame.c, h8300-tdep.c, hppa-tdep.c: Update.
	* mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, ppc-linux-tdep.c, rs6000-tdep.c: Update.
	* s390-tdep.c, sh64-tdep.c, stack.c: Update.
	* v850-tdep.c, vax-tdep.c, xstormy16-tdep.c: Update.
@
text
@d766 2
a767 2
  frame_read_register (frame, regnum + 0, (char *) to + 4);
  frame_read_register (frame, regnum + 1, (char *) to + 0);
@


1.236
log
@2003-09-22  Andrew Cagney  <cagney@@redhat.com>

	* arch-utils.h (init_frame_pc_noop): Delete declaration.
	* arch-utils.c (init_frame_pc_noop): Delete function.
	* mn10300-tdep.c (mn10300_gdbarch_init): Do not set
	"init_frame_pc".
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* config/sparc/tm-sparc.h (init_frame_pc_noop): Delete
	declaration.
	(DEPRECATED_INIT_FRAME_PC): Delete macro.
	* config/rs6000/tm-rs6000.h (init_frame_pc_noop): Delete
	declaration.
	(DEPRECATED_INIT_FRAME_PC): Delete macro.
@
text
@d1573 1
a1573 1
  if (get_frame_saved_regs (fci) != NULL)
d2736 1
a2736 1
	      memcpy (get_frame_saved_regs (fci), temp_saved_regs,
d3960 1
a3960 1
	&& get_frame_saved_regs (frame)[regnum])
d3967 1
a3967 1
			  read_memory_unsigned_integer (get_frame_saved_regs (frame)[regnum],
d3971 1
a3971 1
			  read_memory_integer (get_frame_saved_regs (frame)[regnum],
@


1.235
log
@2003-09-19  Andrew Cagney  <cagney@@redhat.com>

	* utils.c (align_up, align_down): New functions.
	* defs.h (align_up, align_down): Declare.
	* ppc-sysv-tdep.c (align_up, align_down): Delete functions.
	* s390-tdep.c: Replace "round_up" and "round_down" with "align_up"
	and "align_down".
	(round_up, round_down): Delete functions.
	* mips-tdep.c: Replace ROUND_UP and ROUND_DOWN with "align_up" and
	"align_down".
	(ROUND_DOWN, ROUND_UP): Delete macros.
	(mips_dump_tdep): Do not print "ROUND_UP" or "ROUND_DOWN".
	* h8300-tdep.c: Replace "round_up" and "round_down" with
	"align_up" and "align_down".
	(round_up, round_down): Delete macros.
	* frv-tdep.c: Replace ROUND_UP and ROUND_DOWN with "align_up" and
	"align_down".
	(ROUND_UP, ROUND_DOWN): Delete macros.
@
text
@a6058 1
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_noop);
@


1.234
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* sparc-tdep.c (legacy_register_name): Delete function.
	* mips-tdep.c (mips_dump_tdep): Do not print REGISTER_NAME.
	(mips_gdbarch_init): Refer to MIPS_REGISTER_NAME in comments.
	* infcmd.c (gdb_register_name): Delete variable.
	* gdbarch.sh (SDB_REG_TO_REGNUM): Delete reference to
	REGISTER_NAME and "tm.h".
	* gdbarch.h, gdbarch.c: Regenerate.
	* dpx2-nat.c (regmap): Refer to REGISTER_NAME and not
	REGISTER_NAMES in comments.
	* remote-st.c (get_reg_name), i386b-nat.c (tregmap): Ditto.
	* m68klinux-nat.c (regmap): Ditto.

2003-09-18  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	documentation on REGISTER_NAMES.
@
text
@a2824 6
/* Macros to round N up or down to the next A boundary; 
   A must be a power of two.  */

#define ROUND_DOWN(n,a) ((n) & ~((a)-1))
#define ROUND_UP(n,a) (((n)+(a)-1) & ~((a)-1))

d2830 1
a2830 1
  return ROUND_DOWN (addr, 16);
d2859 2
a2860 2
  sp = ROUND_DOWN (sp, 16);
  struct_addr = ROUND_DOWN (struct_addr, 16);
d2866 1
a2866 1
    len += ROUND_UP (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d2868 1
a2868 1
  sp -= ROUND_UP (len, 16);
d2872 2
a2873 2
			"mips_eabi_push_dummy_call: sp=0x%s allocated %d\n",
			paddr_nz (sp), ROUND_UP (len, 16));
d3080 1
a3080 1
		stack_offset += ROUND_UP (partial_len, MIPS_STACK_ARGSIZE);
d3121 2
a3122 2
  sp = ROUND_DOWN (sp, 16);
  struct_addr = ROUND_DOWN (struct_addr, 16);
d3126 1
a3126 1
    len += ROUND_UP (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d3128 1
a3128 1
  sp -= ROUND_UP (len, 16);
d3132 2
a3133 2
			"mips_n32n64_push_dummy_call: sp=0x%s allocated %d\n",
			paddr_nz (sp), ROUND_UP (len, 16));
d3311 1
a3311 1
		stack_offset += ROUND_UP (partial_len, MIPS_STACK_ARGSIZE);
d3352 2
a3353 2
  sp = ROUND_DOWN (sp, 16);
  struct_addr = ROUND_DOWN (struct_addr, 16);
d3357 1
a3357 1
    len += ROUND_UP (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d3359 1
a3359 1
  sp -= ROUND_UP (len, 16);
d3363 2
a3364 2
			"mips_o32_push_dummy_call: sp=0x%s allocated %d\n",
			paddr_nz (sp), ROUND_UP (len, 16));
d3475 1
a3475 1
	  stack_offset += ROUND_UP (len, MIPS_STACK_ARGSIZE);
d3619 1
a3619 1
	      stack_offset += ROUND_UP (partial_len, MIPS_STACK_ARGSIZE);
d3660 2
a3661 2
  sp = ROUND_DOWN (sp, 16);
  struct_addr = ROUND_DOWN (struct_addr, 16);
d3665 1
a3665 1
    len += ROUND_UP (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d3667 1
a3667 1
  sp -= ROUND_UP (len, 16);
d3671 2
a3672 2
			"mips_o64_push_dummy_call: sp=0x%s allocated %d\n",
			paddr_nz (sp), ROUND_UP (len, 16));
d3783 1
a3783 1
	  stack_offset += ROUND_UP (len, MIPS_STACK_ARGSIZE);
d3927 1
a3927 1
	      stack_offset += ROUND_UP (partial_len, MIPS_STACK_ARGSIZE);
a6395 4
  fprintf_unfiltered (file,
		      "mips_dump_tdep: ROUND_DOWN = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: ROUND_UP = function?\n");
@


1.233
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTE): Rename REGISTER_BYTE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-linux-tdep.c, core-sol2.c, cris-tdep.c: Update.
	* d10v-tdep.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, irix5-nat.c, lynx-nat.c, m68knbsd-nat.c: Update.
	* mcore-tdep.c, mips-linux-tdep.c, mips-tdep.c: Update.
	* mipsv4-nat.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* ns32knbsd-nat.c, ppc-bdm.c, regcache.c, remote-sds.c: Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh64-tdep.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, v850-tdep.c: Update.
	* v850ice.c, vax-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-cisco.h, config/m68k/tm-delta68.h: Update.
	* config/pa/nm-hppah.h: Update.

2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* mi/mi-main.c: Rename REGISTER_BYTE to DEPRECATED_REGISTER_BYTE.
@
text
@d6050 1
a6050 1
     #undef/#define REGISTER_NAMES and the new REGISTER_NAME(nr).
a6051 3
  /* NOTE: many targets (esp. embedded) do not go thru the
     gdbarch_register_name vector at all, instead bypassing it
     by defining REGISTER_NAMES.  */
a6401 2
  fprintf_unfiltered (file,
		      "mips_dump_tdep: REGISTER_NAMES = delete?\n");
@


1.232
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@d657 1
a657 1
	 combination of REGISTER_RAW_SIZE and REGISTER_BYTE.  */
d4745 1
a4745 1
	  regbuf + REGISTER_BYTE (lo.reg) + lo.reg_offset,
d4750 1
a4750 1
	    regbuf + REGISTER_BYTE (hi.reg) + hi.reg_offset,
d4764 1
a4764 1
	  regbuf + REGISTER_BYTE (lo.reg) + lo.reg_offset,
d4769 1
a4769 1
	    regbuf + REGISTER_BYTE (hi.reg) + hi.reg_offset,
d4786 1
a4786 1
  deprecated_write_register_bytes (REGISTER_BYTE (lo.reg), raw_buffer,
d4793 1
a4793 1
      deprecated_write_register_bytes (REGISTER_BYTE (hi.reg), raw_buffer,
d4808 1
a4808 1
  deprecated_write_register_bytes (REGISTER_BYTE (lo.reg), raw_buffer,
d4815 1
a4815 1
      deprecated_write_register_bytes (REGISTER_BYTE (hi.reg), raw_buffer,
@


1.231
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d2592 1
a2592 1
      register struct linked_proc_info *link;
@


1.230
log
@* cris-tdep.c (cris_gdbarch_init): Set
deprecated_reg_struct_has_addr instead of reg_struct_has_addr.
* hppa-tdep.c (hppa_gdbarch_init): Likewise.
* mcore-tdep.c (mcore_gdbarch_init): Likewise.
* mips-tdep.c (mips_gdbarch_init): Likewise.
* mn10300-tdep.c (mn10300_gdbarch_init): Likewise.
* sparc-tdep.c (sparc_gdbarch_init): Likewise.
@
text
@d3949 1
a3949 1
  register int regnum;
@


1.229
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d5901 2
a5902 2
      set_gdbarch_reg_struct_has_addr (gdbarch, 
				       mips_o32_reg_struct_has_addr);
d5920 2
a5921 2
      set_gdbarch_reg_struct_has_addr (gdbarch, 
				       mips_o32_reg_struct_has_addr);
d5938 2
a5939 2
      set_gdbarch_reg_struct_has_addr (gdbarch, 
				       mips_eabi_reg_struct_has_addr);
d5957 2
a5958 2
      set_gdbarch_reg_struct_has_addr (gdbarch, 
				       mips_eabi_reg_struct_has_addr);
d5978 2
a5979 2
      set_gdbarch_reg_struct_has_addr (gdbarch, 
				       mips_n32n64_reg_struct_has_addr);
d5997 2
a5998 2
      set_gdbarch_reg_struct_has_addr (gdbarch, 
				       mips_n32n64_reg_struct_has_addr);
@


1.228
log
@2003-09-04  Andrew Cagney  <cagney@@redhat.com>

	* avr-tdep.c: Include "dis-asm.h".
	* cris-tdep.c: Include "dis-asm.h".
	(cris_delayed_get_disassembler): Use "struct disassemble_info"
	instead of corresponding typedef.
	* h8300-tdep.c: Include "dis-asm.h".
	* ia64-tdep.c: Include "dis-asm.h".
	* i386-tdep.c: Include "dis-asm.h".
	(i386_print_insn): Use "struct disassemble_info" instead of
	corresponding typedef.
	* m68k-tdep.c: Include "dis-asm.h".
	* mcore-tdep.c: Include "dis-asm.h".
	* mips-tdep.c: Include "dis-asm.h".
	(gdb_print_insn_mips): Make static, use "struct disassemble_info"
	instead of corresponding typedef.
	* ns32k-tdep.c: Include "dis-asm.h".
	* s390-tdep.c: Include "dis-asm.h".
	* sparc-tdep.c: Include "dis-asm.h".
	* vax-tdep.c: Include "dis-asm.h".
	* v850-tdep.c: Include "dis-asm.h".
	* mn10300-tdep.c: Include "dis-asm.h".
	* rs6000-tdep.c: Include "dis-asm.h".
	* xstormy16-tdep.c: Include "dis-asm.h".
	(_initialize_xstormy16_tdep): Delete "extern" declaration of
	print_insn_xstormy16.
	* Makefile.in (v850-tdep.o): Update dependencies.
	(vax-tdep.o, sparc-tdep.o, s390-tdep.o): Ditto.
	(ns32k-tdep.o, mips-tdep.o, mcore-tdep.o): Ditto.
	(m68k-tdep.o, ia64-tdep.o, i386-tdep.o): Ditto.
	(h8300-tdep.o, cris-tdep.o, avr-tdep.o): Ditto.
	(mn10300-tdep.o, xstormy16-tdep.o, disasm.o): Ditto.
	(gdbarch_h): Remove $(dis_asm_h).
	* disasm.c: Include "dis-asm.h".
	(dis_asm_read_memory): Use "struct disassemble_info" instead of
	corresponding typedef.
	(dis_asm_memory_error, dump_insns, do_assembly_only): Ditto.
	(gdb_disassemble_info, gdb_disassembly, gdb_print_insn): Ditto.
	* gdbarch.sh: Do not include "dis-asm.h".
	(struct disassemble_info): Declare opaque.
	(TARGET_PRINT_INSN): Update declaration.
	* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d2626 1
a2626 1
  if (saved_pc == 0 || inside_entry_file (saved_pc))
@


1.227
log
@2003-09-04  Andrew Cagney  <cagney@@redhat.com>

	* hppa-tdep.c (hppa_gdbarch_init): Set
	"have_nonsteppable_watchpoint".
	* config/pa/nm-hppah.h (HAVE_NONSTEPPABLE_WATCHPOINT): Delete.
	* mips-tdep.c (mips_dump_tdep): Do not print
	HAVE_NONSTEPPABLE_WATCHPOINT.
	(mips_gdbarch_init): Set "have_nonsteppable_watchpoint".
	* config/mips/tm-embed.h (HAVE_NONSTEPPABLE_WATCHPOINT): Delete.
	* config/mips/nm-irix5.h (HAVE_NONSTEPPABLE_WATCHPOINT): Delete.
	* config/mips/nm-irix4.h (HAVE_NONSTEPPABLE_WATCHPOINT): Delete.
@
text
@d51 1
a377 2
int gdb_print_insn_mips (bfd_vma, disassemble_info *);

d5257 2
a5258 2
int
gdb_print_insn_mips (bfd_vma memaddr, disassemble_info *info)
@


1.226
log
@2003-08-28  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (gdb_print_insn_mips): Set the disassembler's
	flavour and disassembler options.
	(_initialize_mips_tdep): Do not set deprecated_tm_print_insn.
	(mips_gdbarch_init): Set "print_insn".  Delete initialization of
	deprecated_tm_print_insn_info.
@
text
@d6123 8
a6310 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: HAVE_NONSTEPPABLE_WATCHPOINT # %s\n",
		      XSTRING (HAVE_NONSTEPPABLE_WATCHPOINT));
@


1.225
log
@2003-08-07  Andrew Cagney  <cagney@@redhat.com>

	* inferior.h (AT_SYMBOL): Define.
	* blockframe.c (inside_entry_file): Check for AT_SYMBOL.
	* infcall.c (call_function_by_hand): Add code to handle AT_SYMBOL.
	* mips-tdep.c (mips_call_dummy_address): Delete function.
	(mips_gdbarch_init): Set call_dummy_location to AT_SYMBOL, do not
	set call_dummy_address.
@
text
@d5261 1
d5294 20
a5749 6
  /* Reset the disassembly info, in case it was set to something
     non-default.  */
  deprecated_tm_print_insn_info.flavour = bfd_target_unknown_flavour;
  deprecated_tm_print_insn_info.arch = bfd_arch_unknown;
  deprecated_tm_print_insn_info.mach = 0;

a5828 28
  /* We have to set deprecated_tm_print_insn_info before looking for a
     pre-existing architecture, otherwise we may return before we get
     a chance to set it up.  */
  if (mips_abi == MIPS_ABI_N32 || mips_abi == MIPS_ABI_N64)
    {
      /* Set up the disassembler info, so that we get the right
	 register names from libopcodes.  */
      if (mips_abi == MIPS_ABI_N32)
	deprecated_tm_print_insn_info.disassembler_options = "gpr-names=n32";
      else
	deprecated_tm_print_insn_info.disassembler_options = "gpr-names=64";
      deprecated_tm_print_insn_info.flavour = bfd_target_elf_flavour;
      deprecated_tm_print_insn_info.arch = bfd_arch_mips;
      if (info.bfd_arch_info != NULL
	  && info.bfd_arch_info->arch == bfd_arch_mips
	  && info.bfd_arch_info->mach)
	deprecated_tm_print_insn_info.mach = info.bfd_arch_info->mach;
      else
	deprecated_tm_print_insn_info.mach = bfd_mach_mips8000;
    }
  else
    /* This string is not recognized explicitly by the disassembler,
       but it tells the disassembler to not try to guess the ABI from
       the bfd elf headers, such that, if the user overrides the ABI
       of a program linked as NewABI, the disassembly will follow the
       register naming conventions specified by the user.  */
    deprecated_tm_print_insn_info.disassembler_options = "gpr-names=32";

d6121 2
a6536 2
  if (!deprecated_tm_print_insn)	 /* Someone may have already set it */
    deprecated_tm_print_insn = gdb_print_insn_mips;
@


1.224
log
@2003-07-28  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (print_gp_register_row): Print the GPR's register
	MOD NUM_REGS.
@
text
@a5542 19
/* Return a location where we can set a breakpoint that will be hit
   when an inferior function call returns.  This is normally the
   program's entry point.  Executables that don't have an entry
   point (e.g. programs in ROM) should define a symbol __CALL_DUMMY_ADDRESS
   whose address is the location where the breakpoint should be placed.  */

static CORE_ADDR
mips_call_dummy_address (void)
{
  struct minimal_symbol *sym;

  sym = lookup_minimal_symbol ("__CALL_DUMMY_ADDRESS", NULL, NULL);
  if (sym)
    return SYMBOL_VALUE_ADDRESS (sym);
  else
    return entry_point_address ();
}


d6097 4
a6100 1
  set_gdbarch_call_dummy_address (gdbarch, mips_call_dummy_address);
@


1.223
log
@        * mips-tdep.c (mips_register_raw_size): Fix compilation failure.
        (mips_register_byte): Likewise.
@
text
@d4289 4
a4292 4
  fprintf_filtered (file,
		    (start_regnum % NUM_REGS) < MIPS_NUMREGS
		    ? "\n R%-4d" : "\n      ",
		    start_regnum);
@


1.222
log
@2003-06-26  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (gdb_print_insn_mips): Only explicitly set
	info->mach when MIPS16.  Patch suggested by Fred Fish.
@
text
@d53 1
d674 1
a674 1
      return TYPE_LENGTH (MIPS_REGISTER_TYPE (rawnum));
d704 2
a705 1
	byte += TYPE_LENGTH (MIPS_REGISTER_TYPE ((reg % NUM_REGS)));
@


1.221
log
@2003-06-21  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c: Include "reggroups.h" and "sim-regno.h".
	(mips_register_name): Return names for NUM_REGS..2*NUM_REGS
	instead of 0..NUM_REGS.
	(mips_register_reggroup_p): New function.
	(mips_pseudo_register_write): New function.
	(mips_pseudo_register_read): New function.
	(mips_register_raw_size): For NUM_REGS..2*NUM_REGS return the size
	based on the register's type.
	(read_next_frame_reg): Simplify.  Assert that REGNO is a pseudo /
	cooked.
	(mips_get_saved_register): Simplify.  Assert that REGNO is a
	pseudo / cooked.
	(mips_register_byte): New function.  Use MIPS_REGISTER_BYTE.
	(mips_register_type): Replace mips_register_virtual_type.  Map
	NUM_REGS..2*NUM_REGS onto 0..NUM_REGS.  Use MIPS_REGISTER_TYPE
	when available.
	(read_next_frame_reg): Simplify, but handle SP_REGNUM.  Assert
	that the register is cooked / virtual.
	(mips_frame_saved_pc): Fetch the cooked PC, and not the raw PC.
	Only get the extra info when needed.
	(set_reg_offset): Save the offset in NUM_REGS..2*NUM_REGS as well.
	(mips32_heuristic_proc_desc): Fetch the cooked register.
	(heuristic_proc_desc, mips_pop_frame, get_frame_pointer): Ditto.
	(mips_init_extra_frame_info, get_frame_pointer): Ditto.
	(mips_print_register): Use gdbarch_register_type, instead of
	REGISTER_VIRTUAL_TYPE.
	(print_gp_register_row): Use gdbarch_register_type, instead of
	REGISTER_VIRTUAL_TYPE.  Allow for a pseudo / cooked REGNUM.
	(mips_print_registers_info): Assert REGNO is pseodo / cooked.
	Print the pseudo / cooked registers.
	(mips_print_registers_info): Assert REGNO is pseodo / cooked.
	Print the pseudo / cooked registers.
	(mips_xfer_register): Use regcache_cooked_read_part.  Assert that
	REG_NUM is pseudo / cooked.
	(mips_o32_xfer_return_value): Xfer the pseudo / cooked register.
	(mips_n32n64_xfer_return_value): Ditto.
	(mips_stab_reg_to_regnum): Map onto NUM_REGS..2*NUM_REGS.
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum): Ditto.
	(mips_register_sim_regno): New function.
	(mips_gdbarch_init): Set deprecated_register_byte,
	register_group_p, pseudo_register_write, pseudo_register_read,
	register_sim_regno, and num_pseudo_regs.  Set register_type,
	instead of register_virtual_type.
	* Makefile.in (mips-tdep.o): Update dependencies.
	* config/mips/tm-mips64.h (MIPS_REGISTER_TYPE): Rename
	REGISTER_VIRTUAL_TYPE.
	* config/mips/tm-mips.h	(MIPS_REGISTER_TYPE): Ditto.
	* config/mips/tm-irix5.h (MIPS_REGISTER_TYPE): Ditto.
	* config/mips/tm-mips.h (MIPS_REGISTER_BYTE): Rename REGISTER_BYTE.
	* config/mips/tm-irix6.h (MIPS_REGISTER_BYTE): Ditto.
	* config/mips/tm-irix5.h (MIPS_REGISTER_BYTE): Ditto.
@
text
@d5273 4
d5278 4
a5281 2
    info->mach = pc_is_mips16 (PROC_LOW_ADDR (proc_desc)) ?
      bfd_mach_mips16 : 0;
d5283 4
a5286 2
    info->mach = pc_is_mips16 (memaddr) ?
      bfd_mach_mips16 : 0;
@


1.221.2.1
log
@2003-06-26  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (gdb_print_insn_mips): Only explicitly set
	info->mach when MIPS16.  Patch suggested by Fred Fish.
@
text
@a5272 4
  /* FIXME: cagney/2003-06-26: Is this even necessary?  The
     disassembler needs to be able to locally determine the ISA, and
     not rely on GDB.  Otherwize the stand-alone 'objdump -d' will not
     work.  */
d5274 2
a5275 4
    {
      if (pc_is_mips16 (PROC_LOW_ADDR (proc_desc)))
	info->mach =  bfd_mach_mips16;
    }
d5277 2
a5278 4
    {
      if (pc_is_mips16 (memaddr))
       info->mach = bfd_mach_mips16;
    } 
@


1.221.2.2
log
@        * mips-tdep.c (mips_register_raw_size): Fix compilation failure.
        (mips_register_byte): Likewise.
@
text
@a52 1
static struct type *mips_register_type (struct gdbarch *gdbarch, int regnum);
d673 1
a673 1
      return TYPE_LENGTH (gdbarch_register_type (current_gdbarch, rawnum));
d703 1
a703 2
	byte += TYPE_LENGTH (gdbarch_register_type (current_gdbarch,
                                                    (reg % NUM_REGS)));
@


1.221.2.3
log
@2003-07-28  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (print_gp_register_row): Print the GPR's register
	MOD NUM_REGS.
@
text
@d4289 4
a4292 4
  if ((start_regnum % NUM_REGS) < MIPS_NUMREGS)
    fprintf_filtered (file, "\n R%-4d", start_regnum % NUM_REGS);
  else
    fprintf_filtered (file, "\n      ");
@


1.220
log
@2003-06-21  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_find_saved_regs): Rewrite mdebug code handling
	32 bit floating-point register saves.
@
text
@d45 1
a45 1

d50 1
d274 1
d303 1
a303 1
    regcache_raw_read_part (regcache, reg_num, reg_offset, length, in + buf_offset);
d305 1
a305 1
    regcache_raw_write_part (regcache, reg_num, reg_offset, length, out + buf_offset);
d445 6
d454 1
a454 1
  if (0 <= regno && regno < 32)
d457 1
a457 1
	return mips_n32_n64_gpr_names[regno];
d459 1
a459 1
	return mips_gpr_names[regno];
d461 2
a462 2
  else if (32 <= regno && regno < NUM_REGS)
    return mips_processor_reg_names[regno - 32];
d465 1
a465 1
		    "mips_register_name: bad register number %d", regno);
d535 37
d573 3
d577 15
d641 1
a641 1
   transfered by the GDB protocol. */
d646 42
a687 1
mips_register_raw_size (int reg_nr)
d689 17
a705 7
  if (mips64_transfers_32bit_regs_p)
    return REGISTER_VIRTUAL_SIZE (reg_nr);
  else if (reg_nr >= FP0_REGNUM && reg_nr < FP0_REGNUM + 32
	   && FP_REGISTER_DOUBLE)
    /* For MIPS_ABI_N32 (for example) we need 8 byte floating point
       registers.  */
    return 8;
d707 1
a707 1
    return MIPS_REGSIZE;
d777 2
a778 9
/* Return the GDB type object for the "standard" data type
   of data in register REG.  
   
   Note: kevinb/2002-08-01: The definition below should faithfully
   reproduce the behavior of each of the REGISTER_VIRTUAL_TYPE
   definitions found in config/mips/tm-*.h.  I'm concerned about the
   ``FCRCS_REGNUM <= reg && reg <= LAST_EMBED_REGNUM'' clause though.
   In some cases DEPRECATED_FP_REGNUM is in this range, and I doubt
   that this code is correct for the 64-bit case.  */
d781 1
a781 1
mips_register_virtual_type (int reg)
d783 8
a790 1
  if (FP0_REGNUM <= reg && reg < FP0_REGNUM + 32)
d798 1
a798 1
  else if (reg == PS_REGNUM /* CR */)
d800 1
a800 1
  else if (FCRCS_REGNUM <= reg && reg <= LAST_EMBED_REGNUM)
d811 1
d1776 2
a1777 6
  int optimized;
  CORE_ADDR addr;
  int realnum;
  enum lval_type lval;
  char raw_buffer[MAX_REGISTER_SIZE];

d1780 10
a1789 2
      regcache_cooked_read (current_regcache, regno, raw_buffer);
    }
d1791 1
a1791 18
    {
      frame_register_unwind (fi, regno, &optimized, &lval, &addr, &realnum,
			     raw_buffer);
      /* FIXME: cagney/2002-09-13: This is just soooo bad.  The MIPS
	 should have a pseudo register range that correspons to the ABI's,
	 rather than the ISA's, view of registers.  These registers would
	 then implicitly describe their size and hence could be used
	 without the below munging.  */
      if (lval == lval_memory)
	{
	  if (regno < 32)
	    {
	      /* Only MIPS_SAVED_REGSIZE bytes of GP registers are
		 saved. */
	      return read_memory_integer (addr, MIPS_SAVED_REGSIZE);
	    }
	}
    }
a1792 1
  return extract_signed_integer (raw_buffer, REGISTER_VIRTUAL_SIZE (regno));
a1881 5
  mips_extra_func_info_t proc_desc = get_frame_extra_info (frame)->proc_desc;
  /* We have to get the saved pc from the sigcontext
     if it is a signal handler frame.  */
  int pcreg = (get_frame_type (frame) == SIGTRAMP_FRAME) ? PC_REGNUM
  : (proc_desc ? PROC_PC_REG (proc_desc) : RA_REGNUM);
d1886 2
a1887 1
      frame_unwind_signed_register (frame, PC_REGNUM, &tmp);
a1889 2
  else if (proc_desc && PROC_DESC_IS_DUMMY (proc_desc))
    saved_pc = read_memory_integer (get_frame_base (frame) - MIPS_SAVED_REGSIZE, MIPS_SAVED_REGSIZE);
d1891 14
a1904 2
    saved_pc = read_next_frame_reg (frame, pcreg);

d1920 7
a1926 1
   function prologue.  */
d1932 4
a1935 1
    saved_regs[regno] = offset;
d2287 1
a2287 1
	      frame_addr = read_next_frame_reg (next_frame, 30);
d2310 1
a2310 1
	      frame_addr = read_next_frame_reg (next_frame, 30);
d2338 1
a2338 1
    sp = read_next_frame_reg (next_frame, SP_REGNUM);
d2611 1
a2611 1
  return (read_next_frame_reg (frame, PROC_FRAME_REG (proc_desc))
d2697 1
a2697 1
	deprecated_update_frame_base_hack (fci, read_next_frame_reg (get_next_frame (fci), SP_REGNUM));
d4208 1
d4212 1
a4212 1
  if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (regnum)) == TYPE_CODE_FLT)
d4241 1
a4241 2
  print_scalar_formatted (raw_buffer + offset,
			  REGISTER_VIRTUAL_TYPE (regnum),
d4263 1
a4263 1
		       int regnum)
d4265 1
d4270 1
a4270 3
  int start_regnum = regnum;
  int numregs = NUM_REGS;

d4274 3
a4276 1
  for (col = 0; col < ncols && regnum < numregs; regnum++)
d4280 1
a4280 1
      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (regnum)) == TYPE_CODE_FLT)
d4286 1
d4288 3
a4290 2
		    start_regnum < MIPS_NUMREGS ? "\n R%-4d" : "\n      ",
		    start_regnum);	/* print the R0 to R31 names */
a4291 1
  regnum = start_regnum;	/* go back to start of row */
d4293 3
a4295 1
  for (col = 0; col < ncols && regnum < numregs; regnum++)
d4299 1
a4299 1
      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (regnum)) == TYPE_CODE_FLT)
d4335 1
d4345 2
a4346 2
      regnum = 0;
      while (regnum < NUM_REGS)
d4348 1
a4348 1
	  if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (regnum)) == TYPE_CODE_FLT)
d4835 1
a4835 1
      mips_xfer_register (regcache, FP0_REGNUM, TYPE_LENGTH (type),
d4842 3
a4844 3
      /* A double-precision floating-point value.  It fits in the
         least significant part of FP0/FP1 but with byte ordering
         based on the target (???).  */
d4846 1
a4846 1
	fprintf_unfiltered (gdb_stderr, "Return float in $fp0/$fp1\n");
d4850 1
a4850 1
	  mips_xfer_register (regcache, FP0_REGNUM + 0, 4,
d4852 1
a4852 1
	  mips_xfer_register (regcache, FP0_REGNUM + 1, 4,
d4856 1
a4856 1
	  mips_xfer_register (regcache, FP0_REGNUM + 1, 4,
d4858 1
a4858 1
	  mips_xfer_register (regcache, FP0_REGNUM + 0, 4,
d4893 2
a4894 1
	  mips_xfer_register (regcache, regnum, TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
d4918 2
a4919 2
	  mips_xfer_register (regcache, regnum, xfer, BFD_ENDIAN_UNKNOWN,
			      in, out, offset);
d4941 2
a4942 2
	  mips_xfer_register (regcache, regnum, xfer, TARGET_BYTE_ORDER,
			      in, out, offset);
d4976 1
a4976 1
      mips_xfer_register (regcache, FP0_REGNUM, TYPE_LENGTH (type),
d5006 2
a5007 1
	  mips_xfer_register (regcache, regnum, TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
d5029 2
a5030 2
	  mips_xfer_register (regcache, regnum, xfer, BFD_ENDIAN_UNKNOWN,
			      in, out, offset);
d5050 2
a5051 2
	  mips_xfer_register (regcache, regnum, xfer, TARGET_BYTE_ORDER,
			      in, out, offset);
d5574 2
a5575 2
  if (!target_has_registers)
    error ("No registers.");
d5584 14
a5597 22
  frame_register_unwind (deprecated_get_next_frame_hack (frame),
			 regnum, optimizedp, lvalp, addrp,
			 &realnumx, raw_buffer);

  /* FIXME: cagney/2002-09-13: This is just so bad.  The MIPS should
     have a pseudo register range that correspons to the ABI's, rather
     than the ISA's, view of registers.  These registers would then
     implicitly describe their size and hence could be used without
     the below munging.  */
  if ((*lvalp) == lval_memory)
    {
      if (raw_buffer != NULL)
	{
	  if (regnum < 32)
	    {
	      /* Only MIPS_SAVED_REGSIZE bytes of GP registers are
		 saved. */
	      LONGEST val = read_memory_integer ((*addrp), MIPS_SAVED_REGSIZE);
	      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), val);
	    }
	}
    }
d5612 2
a5613 2
/* Convert a dbx stab register number (from `r' declaration) to a gdb
   REGNUM */
d5618 1
d5620 1
a5620 1
    return num;
d5622 1
a5622 1
    return num + FP0_REGNUM - 38;
d5624 1
a5624 1
    return HI_REGNUM;
d5626 1
a5626 1
    return LO_REGNUM;
d5628 4
a5631 5
    {
      /* This will hopefully (eventually) provoke a warning.  Should
         we be calling complaint() here?  */
      return NUM_REGS + NUM_PSEUDO_REGS;
    }
d5635 2
a5636 1
/* Convert a dwarf, dwarf2, or ecoff register number to a gdb REGNUM */
d5641 1
d5643 1
a5643 1
    return num;
d5645 1
a5645 1
    return num + FP0_REGNUM - 32;
d5647 1
a5647 1
    return HI_REGNUM;
d5649 1
a5649 1
    return LO_REGNUM;
d5651 19
a5669 5
    {
      /* This will hopefully (eventually) provoke a warning.  Should
         we be calling complaint() here?  */
      return NUM_REGS + NUM_PSEUDO_REGS;
    }
d5736 1
d5890 4
d5900 1
d5902 1
a5902 1
    set_gdbarch_num_regs (gdbarch, 71);
d5904 3
a5906 1
    set_gdbarch_num_regs (gdbarch, 90);
d6098 1
d6135 1
a6135 3
  /* There are MIPS targets which do not yet use this since they still
     define REGISTER_VIRTUAL_TYPE.  */
  set_gdbarch_deprecated_register_virtual_type (gdbarch, mips_register_virtual_type);
@


1.219
log
@2003-06-21  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_unwind_get_saved_register): Delete.
	* frame.c (deprecated_unwind_get_saved_register): Delete function.
	* mips-tdep.c (mips_get_saved_register): Use frame_register_unwind
	and deprecated_get_next_frame_hack instead of
	deprecated_unwind_get_saved_register.
@
text
@a1609 16
    /* Apparently, the freg_offset gives the offset to the first 64
       bit saved.

       When the ABI specifies 64 bit saved registers, the FREG_OFFSET
       designates the first saved 64 bit register.

       When the ABI specifies 32 bit saved registers, the ``64 bit
       saved DOUBLE'' consists of two adjacent 32 bit registers, Hence
       FREG_OFFSET, designates the address of the lower register of
       the register pair.  Adjust the offset so that it designates the
       upper register of the pair -- i.e., the address of the first
       saved 32 bit register.  */

    if (MIPS_SAVED_REGSIZE == 4)
      reg_position += MIPS_SAVED_REGSIZE;

d1615 33
a1647 1
	  set_reg_offset (saved_regs, FP0_REGNUM + ireg, reg_position);
@


1.218
log
@2003-06-21  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_dump_tdep): Do not print
	REGISTER_CONVERT_FROM_TYPE or REGISTER_CONVERT_TO_TYPE.
@
text
@d5433 1
d5445 4
a5448 2
  deprecated_unwind_get_saved_register (raw_buffer, optimizedp, addrp, frame,
					regnum, lvalp);
@


1.217
log
@2003-06-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (SAVE_DUMMY_FRAME_TOS): Deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* infcall.c (call_function_by_hand): Update.
	* ia64-tdep.c (ia64_push_arguments): Update comment.
	* frame.c (legacy_get_prev_frame): Do not assume
	SAVE_DUMMY_FRAME_TOS_P.
	* dummy-frame.c (find_dummy_frame): Update comment.
@
text
@a6261 6
		      "mips_dump_tdep: REGISTER_CONVERT_FROM_TYPE # %s\n",
		      XSTRING (REGISTER_CONVERT_FROM_TYPE (REGNUM, VALTYPE, RAW_BUFFER)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: REGISTER_CONVERT_TO_TYPE # %s\n",
		      XSTRING (REGISTER_CONVERT_TO_TYPE (REGNUM, VALTYPE, RAW_BUFFER)));
  fprintf_unfiltered (file,
@


1.216
log
@2003-06-14  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_register_to_value): Make static.
	(mips_value_to_register): Make static.
	* i386-tdep.c (i386_fetch_pointer_argument): Make static.
	* ia64-tdep.c (ia64_register_raw_size): Make static.
	(ia64_register_virtual_size): Make static.
	(ia64_register_byte): Make static.
	* i387-tdep.c: Include "i387-tdep.h".
	(print_387_control_word): Delete function.
	(print_387_status_word): Delete function.
	(print_387_status_bits): Delete function.
	(print_387_control_bits): Delete function.
	* Makefile.in (i387-tdep.o): Update dependencies.
	* rdi-share/host.h (Fail): Declare.
	* remote-rdi.c (Fail): Update to match declaration.
@
text
@d5950 1
a5950 1
  set_gdbarch_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
@


1.215
log
@2003-06-14  Andrew Cagney  <cagney@@redhat.com>
            Mark Kettenis  <kettenis@@gnu.org>

	* gdbarch.sh (CONVERT_REGISTER_P): Add "type" parameter.
	(REGISTER_TO_VALUE, VALUE_TO_REGISTER): Replace raw buffer
	parameter with "frame".
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h (put_frame_register): Declare.
	* frame.c (put_frame_register): New function.
	* arch-utils.c (legacy_convert_register_p): Add "type" parameter.
	(legacy_register_to_value): Rewrite, use "frame" to get the
	register value.
	(legacy_value_to_register): Rewrite, use "frame" to find the
	register's location before storing.
	* arch-utils.h (legacy_convert_register_p): Update.
	(legacy_register_to_value, legacy_value_to_register): Update.
	* findvar.c (value_from_register): Rewrite, eliminate use of
	REGISTER_CONVERT_TO_TYPE, pass "type" to CONVERT_REGISTER_P, pass
	"frame" to REGISTER_TO_VALUE.
	* valops.c (value_assign): Move the CONVERT_REGISTER code to the
	lval_reg_frame_relative + lval_register branch of the switch.  Do
	not use REGISTER_CONVERT_FROM_TYPE.  Use put_frame_register.
	* i386-tdep.c (I386_EBX_REGNUM, I386_ECX_REGNUM, I386_ESI_REGNUM,
	I386_EDI_REGNUM): New defines.
	(i386_next_regnum, i386_convert_register_p,
	i386_register_to_value, i386_value_to_register): New functions.
	(i386_register_convertible, i386_register_convert_to_virtual,
	i386_convert_to_raw): Remove functions.
	(i386_gdbarch_init): Set convert_register_p, register_to_value and
	value_to_register instead of register_convertible,
	register_convert_to_virtual and register_convert_to_raw.
	* mips-tdep.c (mips_convert_register_p): New function.
	(mips_value_to_register): Replace mips_register_convert_from_type.
	(mips_register_to_value): Replace mips_register_convert_to_type.
	(mips_gdbarch_init): Set conver_register_p, value_to_register and
	register_to_value.
	* alpha-tdep.c (alpha_convert_register_p): Update.
	(alpha_value_to_register): Update, store the register.
	(alpha_register_to_value): Update, fetch the register.
@
text
@d647 1
a647 1
void
d655 1
a655 1
void
@


1.214
log
@2003-06-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Update comments on registers, re-order.
	(deprecated_register_byte): Rename register_byte.
	(deprecated_register_raw_size): Rename register_raw_size.
	(deprecated_register_virtual_size): Rename register_virtual_size.
	(deprecated_register_virtual_type): Rename register_virtual_type.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c: Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
@
text
@d637 10
d648 2
a649 1
mips_register_convert_to_type (int regnum, struct type *type, char *buffer)
d651 2
a652 11
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
      && REGISTER_RAW_SIZE (regnum) == 4
      && (regnum) >= FP0_REGNUM && (regnum) < FP0_REGNUM + 32
      && TYPE_CODE(type) == TYPE_CODE_FLT
      && TYPE_LENGTH(type) == 8) 
    {
      char temp[4];
      memcpy (temp, ((char *)(buffer))+4, 4);
      memcpy (((char *)(buffer))+4, (buffer), 4);
      memcpy (((char *)(buffer)), temp, 4); 
    }
d656 2
a657 1
mips_register_convert_from_type (int regnum, struct type *type, char *buffer)
d659 2
a660 11
if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
    && REGISTER_RAW_SIZE (regnum) == 4
    && (regnum) >= FP0_REGNUM && (regnum) < FP0_REGNUM + 32
    && TYPE_CODE(type) == TYPE_CODE_FLT
    && TYPE_LENGTH(type) == 8) 
  {
    char temp[4];
    memcpy (temp, ((char *)(buffer))+4, 4);
    memcpy (((char *)(buffer))+4, (buffer), 4);
    memcpy (((char *)(buffer)), temp, 4);
  }
@


1.213
log
@2003-06-13  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_gdbarch_init): Replace remaining instances of
	mips_o32_use_struct_convention with always_use_struct_convention.
@
text
@d5744 1
a5744 1
  set_gdbarch_register_raw_size (gdbarch, mips_register_raw_size);
d5984 1
a5984 1
  set_gdbarch_register_virtual_type (gdbarch, mips_register_virtual_type);
@


1.212
log
@* arch-utils.c (always_use_struct_convention): New function.
* arch-utils.h (always_use_struct_convention): New prototype.
* alpha-tdep.c (alpha_use_struct_convention): Delete.
(alpha_gdbarch_init): Register always_use_struct_convention,
instead of alpha_use_struct_convention.
* cris-tdep.c (cris_use_struct_convention): Delete.
(cris_gdbarch_init): Register always_use_struct_convention,
instead of cris_use_struct_convention.
* frv-tdep.c (frv_use_struct_convention): Delete.
(frv_gdbarch_init): Register always_use_struct_convention,
instead of frv_use_struct_convention.
* h8300-tdep.c (h8300_use_struct_convention): Delete.
(h8300_gdbarch_init): Register always_use_struct_convention,
instead of h8300_use_struct_convention.
* mips_o32-tdep.c (mips_o32_use_struct_convention): Delete.
(mips_o32_gdbarch_init): Register always_use_struct_convention,
instead of mips_o32_use_struct_convention.
@
text
@d5793 1
a5793 2
      set_gdbarch_use_struct_convention (gdbarch, 
					 mips_o32_use_struct_convention);
@


1.211
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_CONVERTIBLE): Deprecate
	REGISTER_CONVERTIBLE.
	(DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL): Same.
	(DEPRECATED_REGISTER_CONVERT_TO_RAW): Same, make "from" constant.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (deprecated_register_convertible_not): Rename
	generic_register_convertible_not.
	* arch-utils.c (deprecated_register_convertible_not): Rename
	generic_register_convertible.
	(legacy_convert_register_p, legacy_register_to_value): Update.
	* sh-tdep.c (sh64_push_arguments): Update.
	* m68klinux-tdep.c (m68k_linux_extract_return_value): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_EXTRACT_RETURN_VALUE): Update.
	* m68klinux-tdep.c (m68k_linux_store_return_value): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Update.
	* arch-utils.c (legacy_value_to_register): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	(rs6000_register_convert_to_raw): Make parameter "from" const.
	* mips-tdep.c (mips_gdbarch_init): Update.
	(mips_register_convert_to_raw): Make  parameter"virt_buf" const.
	* infcmd.c (default_print_registers_info): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_register_convert_to_raw): Make parameter "from" const.
	* i386-tdep.c (i386_gdbarch_init): Update.
	(i386_register_convert_to_raw): Update.
@
text
@a770 6
static int
mips_o32_use_struct_convention (int gcc_p, struct type *type)
{
  return 1;	/* Structures are returned by ref in extra arg0.  */
}

d5775 1
a5775 1
					 mips_o32_use_struct_convention);
@


1.210
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_push_return_address): Make static.
	(xstormy16_save_dummy_frame_tos): Make static.
	(_initialize_xstormy16_tdep): Add declaration.
	* vax-tdep.c (_initialize_vax_tdep): Add declaration.
	* v850-tdep.c: Make local functions static.
	(_initialize_v850_tdep): Add declaration.
	* sparc-tdep.c: Make local functions static.
	(_initialize_sparc_tdep): Add declaration.
	* sh-tdep.c: Make local functions static.
	(_initialize_sh_tdep): Add declaration.
	* sh3-rom.c (_initialize_sh3_rom): Add declaration.
	* s390-tdep.c: Make local functions static.
	(_initialize_s390_tdep): Add declaration.
	* dbxread.c (find_stab_function_addr): Make static.
	* ppc-bdm.c (_initialize_bdm_ppc): Add declaration.
	* ocd.c (_initialize_remote_ocd): Add declaration.
	* dink32-rom.c (_initialize_dink32_rom): Add declaration.
	* ppcbug-rom.c (_initialize_ppcbug_rom): Add declaration.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Add declaration.
	* ns32knbsd-tdep.c (_initialize_ns32knbsd_tdep): Add declaration.
	* mips-tdep.c (_initialize_mips_tdep): Add declaration.
	* remote-array.c (_initialize_array): Add declaration.
	(_initialize_remote_monitors): Add declaration.
	* remote-mips.c: Make local functions static.
	(_initialize_remote_mips): Add declaration.
	* mcore-tdep.c: Make all local functions static.
	(_initialize_mcore_tdep): Add declaration.
	* dbug-rom.c (_initialize_dbug_rom): Add declaration.
	* abug-rom.c (_initialize_abug_rom): Add declaration.
	* rom68k-rom.c (_initialize_rom68k): Add declaration.
	* cpu32bug-rom.c (_initialize_cpu32bug_rom): Add declaration.
	* m68k-tdep.c (_initialize_m68k_tdep): Add declaration.
	* remote-est.c (_initialize_est): Add declaration.
	* m68hc11-tdep.c (_initialize_m68hc11_tdep): Add declaration.
	(m68hc11_call_dummy_address): Make static.
	* ia64-tdep.c: Make local functions static.
	(_initialize_ia64_tdep): Add declaration.
	* solib-legacy.c (_initialize_svr4_lm): Add declaration.
	* monitor.c (monitor_wait_filter): Make static.
	(_initialize_remote_monitors): Add declaration.
	* remote-hms.c (_initialize_remote_hms): Add declaration.
	* remote-e7000.c (fetch_regs_from_dump): Make static.
	(expect_n): Make static.
	(_initialize_remote_e7000): Add declaration.
	* ser-e7kpc.c: Always include "defs.h".
	(_initialize_ser_e7000pc): Add declaration.
	* h8300-tdep.c (_initialize_h8300_tdep): Add declaration.
	* cris-tdep.c: Make all but one function static.
	(_initialize_cris_tdep): Add declaration.
	* solib-svr4.c (_initialize_svr4_solib): Add declaration.
	* solib.c (update_solib_list): Make static.
	(_initialize_solib): Add declaration.
	* avr-tdep.c (avr_breakpoint_from_pc): Make static.
	(_initialize_avr_tdep): Add declaration.
	* remote-rdi.c (voiddummy): Make static.
	(_initialize_remote_rdi): Add declaration.
	* arm-tdep.c (_initialize_arm_tdep): Add declaration.
	* remote-rdp.c (send_rdp): Make static.
	(_initialize_remote_rdp): Add declaration.
	* alpha-tdep.c (_initialize_alpha_tdep): Add declaration.
@
text
@d624 1
a624 1
			      char *virt_buf, char *raw_buf)
d5964 3
a5966 5
  set_gdbarch_register_convertible (gdbarch, mips_register_convertible);
  set_gdbarch_register_convert_to_virtual (gdbarch, 
					   mips_register_convert_to_virtual);
  set_gdbarch_register_convert_to_raw (gdbarch, 
				       mips_register_convert_to_raw);
@


1.209
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_unwind_get_saved_register): Rename
	generic_unwind_get_saved_register, update comments.
	* mips-tdep.c (mips_get_saved_register): Update.
	* frame.c (deprecated_unwind_get_saved_register): Update.
@
text
@d6404 2
@


1.208
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_NUM_ARGS): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (frame_num_args_unknown): Delete both declarations.
	* arch-utils.c (frame_num_args_unknown): Delete function.
	* stack.c (print_args_stub): Use FRAME_NUM_ARGS_P.
	(frame_info): Use FRAME_NUM_ARGS_P.
	* arm-tdep.c (arm_frame_num_args): Delete function.
	(arm_gdbarch_init): Do not set frame_num_args.
	* config/pa/tm-hppa64.h (FRAME_NUM_ARGS): Delete.
	* hppa-tdep.c (hppa_frame_num_args): Delete function.
	(hppa_gdbarch_init): Do not set frame_num_args.
	* config/sparc/tm-sparc.h (FRAME_NUM_ARGS): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	frame_num_args to default frame_num_args_unknown.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d5456 2
a5457 2
  generic_unwind_get_saved_register (raw_buffer, optimizedp, addrp, frame,
                                     regnum, lvalp);
@


1.207
log
@2003-06-01  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c (call_function_by_hand): Update comment on
	DEPRECATED_DUMMY_WRITE_SP.

	* mips-tdep.c (mips_gdbarch_init): Do not set
	deprecated_dummy_write_sp.
	(mips_eabi_push_dummy_call): Set the SP register.
	(mips_o64_push_dummy_call): Set the SP register.
	(mips_o32_push_dummy_call): Set the SP register.
	(mips_n32n64_push_dummy_call): Set the SP register.
@
text
@a5973 1
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
@


1.207.2.1
log
@2003-06-06  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (put_frame_register): Declare.
	* frame.c (put_frame_register): New function.

	* arch-utils.c: Include "gdbcore.h".
	(legacy_convert_register_p): Add "type" parameter.
	(legacy_register_to_value): Rewrite, use "frame" to get the
	register value.
	(legacy_value_to_register): Rewrite, use "frame" to find the
	register's location before storing.
	* arch-utils.h (legacy_convert_register_p): Update.
	(legacy_register_to_value, legacy_value_to_register): Update.

	* Makefile.in (arch-utils.o): Update dependencies.

	* findvar.c (value_from_register): Rewrite, eliminate use of
	REGISTER_CONVERT_TO_TYPE, pass "type" to CONVERT_REGISTER_P, pass
	"frame" to REGISTER_TO_VALUE.

	* gdbarch.sh (CONVERT_REGISTER_P): Add "type" parameter.
	(REGISTER_TO_VALUE, VALUE_TO_REGISTER): Replace "type", "from" and
	"to" parameters with "frame" and "value".
	* gdbarch.h, gdbarch.c: Re-generate.

	* mips-tdep.c (mips_convert_register_p): New function.
	(mips_value_to_register): Replace mips_register_convert_from_type.
	(mips_register_to_value): Replace mips_register_convert_to_type.
	(mips_gdbarch_init): Set conver_register_p, value_to_register and
	register_to_value.

	* valops.c (value_assign): Move the CONVERT_REGISTER code to the
	lval_reg_frame_relative + lval_register branch of the switch.  Do
	not use REGISTER_CONVERT_FROM_TYPE.  Use put_frame_register.
@
text
@a636 10
static int
mips_convert_register_p (int regnum, struct type *type)
{
  return (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && REGISTER_RAW_SIZE (regnum) == 4
	  && (regnum) >= FP0_REGNUM && (regnum) < FP0_REGNUM + 32
	  && TYPE_CODE(type) == TYPE_CODE_FLT
	  && TYPE_LENGTH(type) == 8);
}

d638 1
a638 2
mips_register_to_value (struct frame_info *frame, int regnum,
			struct value *v)
d640 11
a650 5
  frame_read_register (frame, regnum + 0, VALUE_CONTENTS_RAW (v) + 4);
  frame_read_register (frame, regnum + 1, VALUE_CONTENTS_RAW (v) + 0);
  VALUE_LVAL (v) = lval_reg_frame_relative;
  VALUE_FRAME_ID (v) = get_frame_id (frame);
  VALUE_FRAME_REGNUM (v) = regnum;
d654 1
a654 1
mips_value_to_register (struct frame_info *frame, struct value *v)
d656 11
a666 3
  int regnum = VALUE_FRAME_REGNUM (v);
  put_frame_register (frame, regnum + 0, VALUE_CONTENTS (v) + 4);
  put_frame_register (frame, regnum + 1, VALUE_CONTENTS (v) + 0);
a5968 3
  set_gdbarch_convert_register_p (gdbarch, mips_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, mips_register_to_value);
  set_gdbarch_value_to_register (gdbarch, mips_value_to_register);
@


1.207.2.2
log
@2003-06-06  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (put_frame_register): Declare.
	* frame.c (put_frame_register): New function.

	* arch-utils.c: Include "gdbcore.h".
	(legacy_convert_register_p): Add "type" parameter.
	(legacy_register_to_value): Rewrite, use "frame" to get the
	register value.
	(legacy_value_to_register): Rewrite, use "frame" to find the
	register's location before storing.
	* arch-utils.h (legacy_convert_register_p): Update.
	(legacy_register_to_value, legacy_value_to_register): Update.

	* Makefile.in (arch-utils.o): Update dependencies.

	* findvar.c (value_from_register): Rewrite, eliminate use of
	REGISTER_CONVERT_TO_TYPE, pass "type" to CONVERT_REGISTER_P, pass
	"frame" to REGISTER_TO_VALUE.

	* gdbarch.sh (CONVERT_REGISTER_P): Add "type" parameter.
	(REGISTER_TO_VALUE, VALUE_TO_REGISTER): Replace raw buffer
	parameter with "frame".
	* gdbarch.h, gdbarch.c: Re-generate.

	* mips-tdep.c (mips_convert_register_p): New function.
	(mips_value_to_register): Replace mips_register_convert_from_type.
	(mips_register_to_value): Replace mips_register_convert_to_type.
	(mips_gdbarch_init): Set conver_register_p, value_to_register and
	register_to_value.

	* valops.c (value_assign): Move the CONVERT_REGISTER code to the
	lval_reg_frame_relative + lval_register branch of the switch.  Do
	not use REGISTER_CONVERT_FROM_TYPE.  Use put_frame_register.
@
text
@d649 1
a649 1
			struct type *type, void *to)
d651 5
a655 2
  frame_read_register (frame, regnum + 0, (char *) to + 4);
  frame_read_register (frame, regnum + 1, (char *) to + 0);
d659 1
a659 2
mips_value_to_register (struct frame_info *frame, int regnum,
			struct type *type, const void *from)
d661 3
a663 2
  put_frame_register (frame, regnum + 0, (const char *) + 4);
  put_frame_register (frame, regnum + 1, (const char *) + 0);
@


1.207.2.3
log
@* mips-tdep.c (mips_value_to_register): Fix.
@
text
@d659 2
a660 2
  put_frame_register (frame, regnum + 0, (const char *) from + 4);
  put_frame_register (frame, regnum + 1, (const char *) from + 0);
@


1.206
log
@2003-06-01  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (is_mips16_addr): New function.
	(make_mips16_addr, unmake_mips16_addr): New functions.
	(pc_is_mips16, mips_fetch_instruction): Use.
	(gdb_print_insn_mips, mips_breakpoint_from_pc): Use.
	(gdb_print_insn_mips): Eliminate TM_PRINT_INSN_MACH.
	(mips_dump_tdep): Delete print of TM_PRINT_INSN_MACH,
	UNMAKE_MIPS16_ADDR, MAKE_MIPS16_ADDR, IS_MIPS16_ADDR and
	TARGET_MIPS.
	* config/mips/tm-mips.h: Update copyright.
	(TARGET_MIPS, TM_PRINT_INSN_MACH): Delete.
	(DEPRECATED_REGISTER_SIZE, DEPRECATED_REGISTER_BYTES): Delete.
	(IS_MIPS16_ADDR, MAKE_MIPS16_ADDR, UNMAKE_MIPS16_ADDR): Delete.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Delete.
	(TM_PRINT_INSN_MACH): Delete.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Delete.
@
text
@d2972 2
d3203 2
d3511 2
d3819 2
a5937 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
@


1.205
log
@2003-05-31  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (set_reg_offset): Add saved_regs parameter.  Add
	forward declaration.
	(mips16_heuristic_proc_desc): Pass temp_saved_regs.
	(mips16_heuristic_proc_desc): Pass temp_saved_regs.
	(mips_find_saved_regs): Use set_reg_offset.
	(mips_frame_init_saved_regs): Delete function.
	(mips_pop_frame): Call mips_find_saved_regs instead of
	DEPRECATED_FRAME_INIT_SAVED_REGS.
@
text
@d155 21
d813 1
a813 1
  if (IS_MIPS16_ADDR (memaddr))
d946 1
a946 1
      addr = UNMAKE_MIPS16_ADDR (addr);
d5132 1
a5132 1
  proc_desc = non_heuristic_proc_desc (MAKE_MIPS16_ADDR (memaddr), NULL);
d5140 1
a5140 1
      bfd_mach_mips16 : TM_PRINT_INSN_MACH;
d5143 1
a5143 1
      bfd_mach_mips16 : TM_PRINT_INSN_MACH;
d5170 1
a5170 1
	  *pcptr = UNMAKE_MIPS16_ADDR (*pcptr);
d5200 1
a5200 1
	  *pcptr = UNMAKE_MIPS16_ADDR (*pcptr);
a6187 2
		      "mips_dump_tdep: IS_MIPS16_ADDR = FIXME!\n");
  fprintf_unfiltered (file,
a6208 2
		      "mips_dump_tdep: MAKE_MIPS16_ADDR = FIXME!\n");
  fprintf_unfiltered (file,
a6353 5
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TARGET_MIPS = used?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TM_PRINT_INSN_MACH # %s\n",
		      XSTRING (TM_PRINT_INSN_MACH));
a6373 2
  fprintf_unfiltered (file,
		      "mips_dump_tdep: UNMAKE_MIPS16_ADDR = function?\n");
@


1.204
log
@2003-05-31  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_gdbarch_init): Do not set
	deprecated_max_register_raw_size, register_virtual_size, and
	deprecated_max_register_virtual_size.
@
text
@d51 2
d1428 7
a1434 10
/* Guaranteed to set fci->saved_regs to some values (it never leaves it
   NULL).

   Note: kevinb/2002-08-09: The only caller of this function is (and
   should remain) mips_frame_init_saved_regs().  In fact,
   aside from calling mips_find_saved_regs(), mips_frame_init_saved_regs()
   does nothing more than set frame->saved_regs[SP_REGNUM].  These two
   functions should really be combined and now that there is only one
   caller, it should be straightforward.  (Watch out for multiple returns
   though.)  */
a1439 1
  CORE_ADDR reg_position;
d1446 1
d1448 3
a1450 1
  frame_saved_regs_zalloc (fci);
d1453 3
a1455 3
     in a sigcontext structure somewhere on the stack.
     If the stack layout for sigtramp changes we might have to change these
     constants and the companion fixup_sigtramp in mdebugread.c  */
d1457 2
a1458 2
/* To satisfy alignment restrictions, sigcontext is located 4 bytes
   above the sigtramp frame.  */
d1467 1
a1467 1
/* FIXME!  Is this correct?? */
d1474 3
a1476 3
	  reg_position = get_frame_base (fci) + SIGFRAME_REGSAVE_OFF
	    + ireg * SIGFRAME_REG_SIZE;
	  get_frame_saved_regs (fci)[ireg] = reg_position;
d1480 4
a1483 3
	  reg_position = get_frame_base (fci) + SIGFRAME_FPREGSAVE_OFF
	    + ireg * SIGFRAME_REG_SIZE;
	  get_frame_saved_regs (fci)[FP0_REGNUM + ireg] = reg_position;
d1485 4
a1488 1
      get_frame_saved_regs (fci)[PC_REGNUM] = get_frame_base (fci) + SIGFRAME_PC_OFF;
d1494 3
a1496 3
    /* I'm not sure how/whether this can happen.  Normally when we can't
       find a proc_desc, we "synthesize" one using heuristic_proc_desc
       and set the saved_regs right away.  */
d1503 4
a1506 4
  if (				/* In any frame other than the innermost or a frame interrupted by
				   a signal, we assume that all registers have been saved.
				   This assumes that all register saves in a function happen before
				   the first function call.  */
d1510 1
a1510 1
  /* In a dummy frame we know exactly where things are saved.  */
d1513 2
a1514 2
  /* Don't bother unless we are inside a function prologue.  Outside the
     prologue, we know where everything is. */
d1518 4
a1521 4
  /* Not sure exactly what kernel_trap means, but if it means
     the kernel saves the registers without a prologue doing it,
     we better not examine the prologue to see whether registers
     have been saved yet.  */
d1524 2
a1525 2
      /* We need to figure out whether the registers that the proc_desc
         claims are saved have been saved yet.  */
d1538 2
a1539 2
      /* Scan through this function's instructions preceding the current
         PC, and look for those that save registers.  */
d1553 12
a1564 9
  /* Fill in the offsets for the registers which gen_mask says
     were saved.  */
  reg_position = get_frame_base (fci) + PROC_REG_OFFSET (proc_desc);
  for (ireg = MIPS_NUMREGS - 1; gen_mask; --ireg, gen_mask <<= 1)
    if (gen_mask & 0x80000000)
      {
	get_frame_saved_regs (fci)[ireg] = reg_position;
	reg_position -= MIPS_SAVED_REGSIZE;
      }
d1566 4
a1569 4
  /* The MIPS16 entry instruction saves $s0 and $s1 in the reverse order
     of that normally used by gcc.  Therefore, we have to fetch the first
     instruction of the function, and if it's an entry instruction that
     saves $s0 or $s1, correct their saved addresses.  */
d1573 2
a1574 1
      if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)		/* entry */
d1580 2
a1581 1
	  reg_position = get_frame_base (fci) + PROC_REG_OFFSET (proc_desc);
d1585 2
a1586 1
	  /* Check if the s0 and s1 registers were pushed on the stack.  */
d1589 1
a1589 1
	      get_frame_saved_regs (fci)[reg] = reg_position;
d1595 21
a1615 28
  /* Fill in the offsets for the registers which float_mask says
     were saved.  */
  reg_position = get_frame_base (fci) + PROC_FREG_OFFSET (proc_desc);

  /* Apparently, the freg_offset gives the offset to the first 64 bit
     saved.

     When the ABI specifies 64 bit saved registers, the FREG_OFFSET
     designates the first saved 64 bit register.

     When the ABI specifies 32 bit saved registers, the ``64 bit saved
     DOUBLE'' consists of two adjacent 32 bit registers, Hence
     FREG_OFFSET, designates the address of the lower register of the
     register pair.  Adjust the offset so that it designates the upper
     register of the pair -- i.e., the address of the first saved 32
     bit register.  */

  if (MIPS_SAVED_REGSIZE == 4)
    reg_position += MIPS_SAVED_REGSIZE;

  /* Fill in the offsets for the float registers which float_mask says
     were saved.  */
  for (ireg = MIPS_NUMREGS - 1; float_mask; --ireg, float_mask <<= 1)
    if (float_mask & 0x80000000)
      {
	get_frame_saved_regs (fci)[FP0_REGNUM + ireg] = reg_position;
	reg_position -= MIPS_SAVED_REGSIZE;
      }
d1617 8
a1624 2
  get_frame_saved_regs (fci)[PC_REGNUM] = get_frame_saved_regs (fci)[RA_REGNUM];
}
d1626 2
a1627 6
/* Set up the 'saved_regs' array.  This is a data structure containing
   the addresses on the stack where each register has been saved, for
   each stack frame.  Registers that have not been saved will have
   zero here.  The stack pointer register is special:  rather than the
   address where the stack register has been saved, saved_regs[SP_REGNUM]
   will have the actual value of the previous frame's stack register.  */
d1629 2
a1630 8
static void
mips_frame_init_saved_regs (struct frame_info *frame)
{
  if (get_frame_saved_regs (frame) == NULL)
    {
      mips_find_saved_regs (frame);
    }
  get_frame_saved_regs (frame)[SP_REGNUM] = get_frame_base (frame);
d1785 4
a1788 4
/* Set a register's saved stack address in temp_saved_regs.  If an address
   has already been set for this register, do nothing; this way we will
   only recognize the first save of a given register in a function prologue.
   This is a helper function for mips{16,32}_heuristic_proc_desc.  */
d1791 1
a1791 1
set_reg_offset (int regno, CORE_ADDR offset)
d1793 2
a1794 2
  if (temp_saved_regs[regno] == 0)
    temp_saved_regs[regno] = offset;
d1990 1
a1990 1
	  set_reg_offset (reg, sp + offset);
d1997 1
a1997 1
	  set_reg_offset (reg, sp + offset);
d2003 1
a2003 1
	  set_reg_offset (RA_REGNUM, sp + offset);
d2009 1
a2009 1
	  set_reg_offset (RA_REGNUM, sp + offset);
d2028 1
a2028 1
	  set_reg_offset (reg, frame_addr + offset);
d2035 1
a2035 1
	  set_reg_offset (reg, frame_addr + offset);
d2065 1
a2065 1
	  set_reg_offset (reg, sp + offset);
d2074 1
a2074 1
	  set_reg_offset (RA_REGNUM, sp + offset);
d2082 1
a2082 1
	  set_reg_offset (reg, sp + offset);
d2127 1
a2127 1
	  set_reg_offset (reg, sp + low_word);
d2135 1
a2135 1
	  set_reg_offset (reg, sp + low_word + 8 - MIPS_REGSIZE);
d2185 1
a2185 1
	  set_reg_offset (reg, frame_addr + low_word);
d2584 12
a2595 9
	      memcpy (get_frame_saved_regs (fci), temp_saved_regs, SIZEOF_FRAME_SAVED_REGS);
	      get_frame_saved_regs (fci)[PC_REGNUM]
		= get_frame_saved_regs (fci)[RA_REGNUM];
	      /* Set value of previous frame's stack pointer.  Remember that
	         saved_regs[SP_REGNUM] is special in that it contains the
		 value of the stack pointer register.  The other saved_regs
		 values are addresses (in the inferior) at which a given
		 register's value may be found.  */
	      get_frame_saved_regs (fci)[SP_REGNUM] = get_frame_base (fci);
d3813 1
a3813 2
  if (get_frame_saved_regs (frame) == NULL)
    DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
d5927 1
a5927 1
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, mips_frame_init_saved_regs);
@


1.203
log
@2003-05-31  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (print_gp_register_row): Replace do_gp_register_row.
	(print_fp_register_row): Replace do_fp_register_row.
	(mips_print_fp_register): Add "file" and "frame" parameters.
	(mips_print_register): Add "file" and "frame" parameters.
	(mips_print_registers_info): Replace mips_do_registers_info.
	(mips_gdbarch_init): Set print_registers_info instead of
	deprecated_do_registers_info.
	(mips_read_fp_register_single): Add "frame" parameter.
	(mips_read_fp_register_double): Add "frame" parameter.
@
text
@a5719 2
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 8);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 8);
a5964 1
  set_gdbarch_register_virtual_size (gdbarch, generic_register_size);
@


1.202
log
@2003-05-31  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_gdbarch_init): Do not set the deprecated
	architecture methods call_dummy_words, sizeof_call_dummy_words,
	push_return_address, store_struct_return, and fix_call_dummy.  Set
	push_dummy_call instead of deprecated_push_arguments.
	(mips_store_struct_return): Delete function.
	(mips_fix_call_dummy): Delete function.
	(mips_push_return_address): Delete function.
	(mips_eabi_push_dummy_call): Replace mips_eabi_push_arguments, set
	RA_REGNUM and T9_REGNUM.
	(mips_n32n64_push_dummy_call): Ditto for
	mips_n32n64_push_arguments.
	(mips_o32_push_dummy_call): Ditto for mips_o32_push_arguments.
	(mips_o64_push_dummy_call): Ditto for mips_o64_push_arguments.
@
text
@a352 2
static void mips_print_register (int, int);

a372 3
static void mips_read_fp_register_single (int regno, char *rare_buffer);
static void mips_read_fp_register_double (int regno, char *rare_buffer);

d3919 2
a3920 1
mips_read_fp_register_single (int regno, char *rare_buffer)
d3925 1
a3925 1
  if (!frame_register_read (deprecated_selected_frame, regno, raw_buffer))
d3951 2
a3952 1
mips_read_fp_register_double (int regno, char *rare_buffer)
d3960 1
a3960 1
      if (!frame_register_read (deprecated_selected_frame, regno, rare_buffer))
d3974 2
a3975 2
	  mips_read_fp_register_single (regno, rare_buffer + 4);
	  mips_read_fp_register_single (regno + 1, rare_buffer);
d3979 2
a3980 2
	  mips_read_fp_register_single (regno, rare_buffer);
	  mips_read_fp_register_single (regno + 1, rare_buffer + 4);
d3986 2
a3987 1
mips_print_fp_register (int regnum)
d3995 3
a3997 2
  printf_filtered ("%s:", REGISTER_NAME (regnum));
  printf_filtered ("%*s", 4 - (int) strlen (REGISTER_NAME (regnum)), "");
d4003 1
a4003 1
      mips_read_fp_register_single (regnum, raw_buffer);
d4006 1
a4006 2
      print_scalar_formatted (raw_buffer, builtin_type_uint32, 'x', 'w',
                              gdb_stdout);
d4008 1
a4008 1
      printf_filtered (" flt: ");
d4010 1
a4010 1
	printf_filtered (" <invalid float> ");
d4012 1
a4012 1
	printf_filtered ("%-17.9g", flt1);
d4016 1
a4016 1
	  mips_read_fp_register_double (regnum, raw_buffer);
d4020 1
a4020 1
	  printf_filtered (" dbl: ");
d4022 1
a4022 1
	    printf_filtered ("<invalid double>");
d4024 1
a4024 1
	    printf_filtered ("%-24.17g", doub);
d4030 1
a4030 1
      mips_read_fp_register_single (regnum, raw_buffer);
d4033 1
a4033 1
      mips_read_fp_register_double (regnum, raw_buffer);
d4037 1
a4037 2
      print_scalar_formatted (raw_buffer, builtin_type_uint64, 'x', 'g',
                              gdb_stdout);
d4039 1
a4039 1
      printf_filtered (" flt: ");
d4041 1
a4041 1
	printf_filtered ("<invalid float>");
d4043 1
a4043 1
	printf_filtered ("%-17.9g", flt1);
d4045 1
a4045 1
      printf_filtered (" dbl: ");
d4047 1
a4047 1
	printf_filtered ("<invalid double>");
d4049 1
a4049 1
	printf_filtered ("%-24.17g", doub);
d4054 2
a4055 1
mips_print_register (int regnum, int all)
d4062 1
a4062 1
      mips_print_fp_register (regnum);
d4067 1
a4067 1
  if (!frame_register_read (deprecated_selected_frame, regnum, raw_buffer))
d4069 1
a4069 1
      printf_filtered ("%s: [Invalid]", REGISTER_NAME (regnum));
d4073 1
a4073 1
  fputs_filtered (REGISTER_NAME (regnum), gdb_stdout);
d4080 1
a4080 1
    printf_filtered ("(r%d): ", regnum);
d4082 1
a4082 1
    printf_filtered (": ");
d4091 1
a4091 1
			  'x', 0, gdb_stdout);
d4098 2
a4099 1
do_fp_register_row (int regnum)
d4101 3
a4103 3
  printf_filtered (" ");
  mips_print_fp_register (regnum);
  printf_filtered ("\n");
d4111 2
a4112 1
do_gp_register_row (int regnum)
d4123 1
a4123 1
  printf_filtered ("     ");
d4130 2
a4131 2
      printf_filtered (MIPS_REGSIZE == 8 ? "%17s" : "%9s",
		       REGISTER_NAME (regnum));
d4134 3
a4136 2
  printf_filtered (start_regnum < MIPS_NUMREGS ? "\n R%-4d" : "\n      ",
		   start_regnum);	/* print the R0 to R31 names */
d4147 1
a4147 1
      if (!frame_register_read (deprecated_selected_frame, regnum, raw_buffer))
d4157 1
a4157 1
	  printf_filtered ("%02x", (unsigned char) raw_buffer[byte]);
d4162 2
a4163 2
	  printf_filtered ("%02x", (unsigned char) raw_buffer[byte]);
      printf_filtered (" ");
d4167 1
a4167 1
    printf_filtered ("\n");
d4175 2
a4176 1
mips_do_registers_info (int regnum, int fpregs)
d4183 2
a4184 2
      mips_print_register (regnum, 0);
      printf_filtered ("\n");
d4193 6
a4198 4
	    if (fpregs)		/* true for "INFO ALL-REGISTERS" command */
	      regnum = do_fp_register_row (regnum);	/* FP regs */
	    else
	      regnum += MIPS_NUMREGS;	/* skip floating point regs */
d4200 1
a4200 1
	    regnum = do_gp_register_row (regnum);	/* GP (int) regs */
d5969 1
a5969 1
  set_gdbarch_deprecated_do_registers_info (gdbarch, mips_do_registers_info);
@


1.201
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@d2700 4
a2703 5
mips_eabi_push_arguments (int nargs,
			  struct value **args,
			  CORE_ADDR sp,
			  int struct_return,
			  CORE_ADDR struct_addr)
d2711 8
d2738 1
a2738 1
			"mips_eabi_push_arguments: sp=0x%s allocated %d\n",
d2750 1
a2750 1
			    "mips_eabi_push_arguments: struct_return reg=%d 0x%s\n",
d2769 1
a2769 1
			    "mips_eabi_push_arguments: %d len=%d type=%d",
d2957 1
a2957 1
/* N32/N64 version of push_arguments.  */
d2960 4
a2963 5
mips_n32n64_push_arguments (int nargs,
			    struct value **args,
			    CORE_ADDR sp,
			    int struct_return,
			    CORE_ADDR struct_addr)
d2971 8
d2996 1
a2996 1
			"mips_n32n64_push_arguments: sp=0x%s allocated %d\n",
d3008 1
a3008 1
			    "mips_n32n64_push_arguments: struct_return reg=%d 0x%s\n",
d3027 1
a3027 1
			    "mips_n32n64_push_arguments: %d len=%d type=%d",
d3186 1
a3186 1
/* O32 version of push_arguments.  */
d3189 4
a3192 5
mips_o32_push_arguments (int nargs,
			 struct value **args,
			 CORE_ADDR sp,
			 int struct_return,
			 CORE_ADDR struct_addr)
d3200 8
d3225 1
a3225 1
			"mips_o32_push_arguments: sp=0x%s allocated %d\n",
d3237 1
a3237 1
			    "mips_o32_push_arguments: struct_return reg=%d 0x%s\n",
d3257 1
a3257 1
			    "mips_o32_push_arguments: %d len=%d type=%d",
d3492 1
a3492 1
/* O64 version of push_arguments.  */
d3495 4
a3498 5
mips_o64_push_arguments (int nargs,
			 struct value **args,
			 CORE_ADDR sp,
			 int struct_return,
			 CORE_ADDR struct_addr)
d3506 8
d3531 1
a3531 1
			"mips_o64_push_arguments: sp=0x%s allocated %d\n",
d3543 1
a3543 1
			    "mips_o64_push_arguments: struct_return reg=%d 0x%s\n",
d3563 1
a3563 1
			    "mips_o64_push_arguments: %d len=%d type=%d",
a3797 9
static CORE_ADDR
mips_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
{
  /* Set the return address register to point to the entry
     point of the program, where a breakpoint lies in wait.  */
  write_register (RA_REGNUM, CALL_DUMMY_ADDRESS ());
  return sp;
}

a3871 7
static void
mips_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs, 
		     struct value **args, struct type *type, int gcc_p)
{
  write_register(T9_REGNUM, fun);
}

a4907 6
static void
mips_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  /* Nothing to do -- push_arguments does all the work.  */
}

a5558 2
  static LONGEST mips_call_dummy_words[] =
  {0};
d5732 1
a5732 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_o32_push_arguments);
d5751 1
a5751 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_o64_push_arguments);
d5770 1
a5770 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_eabi_push_arguments);
d5789 1
a5789 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_eabi_push_arguments);
d5808 1
a5808 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_n32n64_push_arguments);
d5827 1
a5827 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_n32n64_push_arguments);
a5928 1
  set_gdbarch_deprecated_push_return_address (gdbarch, mips_push_return_address);
a5929 4
  set_gdbarch_deprecated_fix_call_dummy (gdbarch, mips_fix_call_dummy);
  set_gdbarch_deprecated_call_dummy_words (gdbarch, mips_call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (mips_call_dummy_words));
  set_gdbarch_deprecated_push_return_address (gdbarch, mips_push_return_address);
a5970 1
  set_gdbarch_deprecated_store_struct_return (gdbarch, mips_store_struct_return);
@


1.201.4.1
log
@* arch-utils.c (always_use_struct_convention): New function.
* arch-utils.h (always_use_struct_convention): New prototype.
* alpha-tdep.c (alpha_use_struct_convention): Delete.
(alpha_gdbarch_init): Register always_use_struct_convention,
instead of alpha_use_struct_convention.
* cris-tdep.c (cris_use_struct_convention): Delete.
(cris_gdbarch_init): Register always_use_struct_convention,
instead of cris_use_struct_convention.
* frv-tdep.c (frv_use_struct_convention): Delete.
(frv_gdbarch_init): Register always_use_struct_convention,
instead of frv_use_struct_convention.
* h8300-tdep.c (h8300_use_struct_convention): Delete.
(h8300_gdbarch_init): Register always_use_struct_convention,
instead of h8300_use_struct_convention.
* mips_o32-tdep.c (mips_o32_use_struct_convention): Delete.
(mips_o32_gdbarch_init): Register always_use_struct_convention,
instead of mips_o32_use_struct_convention.
@
text
@d753 6
d5744 1
a5744 1
					 always_use_struct_convention);
@


1.200
log
@2003-05-15  Andrew Cagney  <cagney@@redhat.com>

	* arch-utils.h (legacy_breakpoint_from_pc): Delete declaration.
	* target.h (memory_breakpoint_from_pc): Delete declaration.
	* mem-break.c (memory_breakpoint_from_pc): Delete function.
	* arch-utils.c (legacy_breakpoint_from_pc): Delete function.
	* monitor.c (monitor_insert_breakpoint): Use
	gdbarch_breakpoint_from_pc instead of memory_breakpoint_from_pc.
	* gdbarch.sh (BREAKPOINT_FROM_PC): Do not provide a default.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sparc-tdep.c (sparc_breakpoint_from_pc): New function.
	(sparc_gdbarch_init): Set breakpoint_from_pc to
	sparc_breakpoint_from_pc.
	* config/sparc/tm-sparc.h (BREAKPOINT): Delete macro.
	(BREAKPOINT_FROM_PC): Define.
	(sparc_breakpoint_from_pc): Declare.
	* hppa-tdep.c (hppa_breakpoint_from_pc): New function.
	* config/pa/tm-hppa.h (hppa_breakpoint_from_pc): Declare.
	(BREAKPOINT_FROM_PC): Define.
	(BREAKPOINT): Delete macro.
	* target.h: Update comment.
	* s390-tdep.c (s390_gdbarch_init): Update comments.
	* remote.c: Update comments.
	* remote-mips.c: Update comments.
	* proc-api.c (write_with_trace): Do not check for a breakpoint.
	* mem-break.c: Update comment.
	* ia64-tdep.c (IA64_BREAKPOINT): Rename BREAKPOINT.
	(ia64_memory_insert_breakpoint): Update.
	* config/sparc/tm-sparc.h: Update comment.
	* config/pa/tm-hppa64.h: Update comment.
	* rs6000-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(rs6000_breakpoint_from_pc): Update.
	* mips-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(PMON_BIG_BREAKPOINT, PMON_LITTLE_BREAKPOINT): Delete macro.
	(IDT_LITTLE_BREAKPOINT, IDT_LITTLE_BREAKPOINT): Delete macro.
	(MIPS16_LITTLE_BREAKPOINT, MIPS16_BIG_BREAKPOINT): Delete macro.
	(mips_breakpoint_from_pc): Update.
	(mips_dump_tdep): Update.
@
text
@d4564 1
a4564 1
				char regbuf[REGISTER_BYTES],
d4583 1
a4583 1
			       char regbuf[REGISTER_BYTES],
@


1.199
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@a5121 13
/* Old-style breakpoint macros.
   The IDT board uses an unusual breakpoint value, and sometimes gets
   confused when it sees the usual MIPS breakpoint instruction.  */

#define BIG_BREAKPOINT {0, 0x5, 0, 0xd}
#define LITTLE_BREAKPOINT {0xd, 0, 0x5, 0}
#define PMON_BIG_BREAKPOINT {0, 0, 0, 0xd}
#define PMON_LITTLE_BREAKPOINT {0xd, 0, 0, 0}
#define IDT_BIG_BREAKPOINT {0, 0, 0x0a, 0xd}
#define IDT_LITTLE_BREAKPOINT {0xd, 0x0a, 0, 0}
#define MIPS16_BIG_BREAKPOINT {0xe8, 0xa5}
#define MIPS16_LITTLE_BREAKPOINT {0xa5, 0xe8}

d5136 1
a5136 2
	  static unsigned char mips16_big_breakpoint[] =
	    MIPS16_BIG_BREAKPOINT;
d5143 6
a5148 3
	  static unsigned char big_breakpoint[] = BIG_BREAKPOINT;
	  static unsigned char pmon_big_breakpoint[] = PMON_BIG_BREAKPOINT;
	  static unsigned char idt_big_breakpoint[] = IDT_BIG_BREAKPOINT;
d5166 1
a5166 2
	  static unsigned char mips16_little_breakpoint[] =
	    MIPS16_LITTLE_BREAKPOINT;
d5173 3
a5175 5
	  static unsigned char little_breakpoint[] = LITTLE_BREAKPOINT;
	  static unsigned char pmon_little_breakpoint[] =
	    PMON_LITTLE_BREAKPOINT;
	  static unsigned char idt_little_breakpoint[] =
	    IDT_LITTLE_BREAKPOINT;
a6126 2
		      "mips_dump_tdep: BIG_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
a6156 4
		      "mips_dump_tdep: IDT_BIG_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: IDT_LITTLE_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
a6170 2
		      "mips_dump_tdep: LITTLE_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
a6190 2
		      "mips_dump_tdep: MIPS16_BIG_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
a6193 2
		      "mips_dump_tdep: MIPS16_LITTLE_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
a6215 4
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PMON_BIG_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PMON_LITTLE_BREAKPOINT = delete?\n");
@


1.198
log
@2003-05-13  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (store_address): Delete declaration.
	findvar.c (store_address): Delete function.
	* arm-tdep.c (arm_push_dummy_call): Replace store_address with
	store_unsigned_integer.
	* xstormy16-tdep.c (xstormy16_address_to_pointer): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	* sparc-tdep.c (sparc_get_saved_register): Ditto.
	* sh-tdep.c (sh64_get_saved_register): Ditto.
	* rs6000-tdep.c (rs6000_push_arguments): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_arguments): Ditto.
	* mips-tdep.c (mips_eabi_push_arguments): Ditto.
	(mips_get_saved_register): Ditto.
	* ia64-tdep.c (ia64_get_saved_register): Ditto.
	(find_func_descr, ia64_push_arguments): Ditto.
	* i386-tdep.c (i386_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	* frv-tdep.c (frv_push_arguments): Ditto.
	* frame.c (legacy_saved_regs_prev_register): Ditto.
	(deprecated_generic_get_saved_register): Ditto.
	* findvar.c (unsigned_address_to_pointer): Ditto.
	* dwarf2read.c (dwarf2_const_value): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_push_arguments): Ditto.
@
text
@d2392 1
a2392 1
  sym = lookup_symbol (MIPS_EFI_SYMBOL_NAME, b, LABEL_NAMESPACE, 0, NULL);
@


1.197
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@d2770 1
a2770 1
	  store_address (valbuf, MIPS_SAVED_REGSIZE, VALUE_ADDRESS (arg));
d5445 1
a5445 1
	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), val);
@


1.197.4.1
log
@Snap const char * mess.
@
text
@d2770 1
a2770 1
	  store_unsigned_integer (valbuf, MIPS_SAVED_REGSIZE, VALUE_ADDRESS (arg));
d5445 1
a5445 1
	      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), val);
@


1.196
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (read_signed_register): New function, moved to here
	from "regcache.c".
	(read_signed_register_pid): Ditto.
	* regcache.c (read_signed_register_pid): Delete function, moved to
	"mips-tdep.c".
	(read_signed_register): Ditto.
	* regcache.h (read_signed_register): Delete declaration.
	(read_signed_register_pid): Delete declaration.
@
text
@d248 1
a248 1
  bfd_byte *reg = alloca (MAX_REGISTER_RAW_SIZE);
d1645 1
a1645 1
  void *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
d2754 1
a2754 1
      char *valbuf = alloca (MAX_REGISTER_RAW_SIZE);
d3005 1
a3005 1
      char *valbuf = alloca (MAX_REGISTER_RAW_SIZE);
d3228 1
a3228 1
      char *valbuf = alloca (MAX_REGISTER_RAW_SIZE);
d3527 1
a3527 1
      char *valbuf = alloca (MAX_REGISTER_RAW_SIZE);
d4047 1
a4047 1
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
d4103 1
a4103 1
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
d4606 1
a4606 1
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
d4628 1
a4628 1
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
d4710 1
a4710 1
      bfd_byte *reg = alloca (MAX_REGISTER_RAW_SIZE);
d4822 1
a4822 1
      bfd_byte *reg = alloca (MAX_REGISTER_RAW_SIZE);
@


1.195
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d153 30
@


1.194
log
@2003-04-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_tm_print_insn_info): Rename
	"tm_print_insn_info".
	(TARGET_PRINT_INSN_INFO): Delete macro.
	(dis_asm_read_memory): Delete function declaration.
	(dis_asm_memory_error, dis_asm_print_address): Ditto.
	(tm_print_insn_info): Delete variable definition.
	(_initialize_gdbarch): Do not initialize "tm_print_insn_info".
	* gdbarch.h, gdbarch.c: Re-generate.
	* d10v-tdep.c (display_trace): Replace "tm_print_insn_info" with
	"deprecated_tm_print_insn_info".
	* mcore-tdep.c (mcore_dump_insn): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* sparc-tdep.c (_initialize_sparc_tdep): Ditto.
	* v850-tdep.c (v850_scan_prologue, v850_gdbarch_init): Ditto.
	* ia64-tdep.c (_initialize_ia64_tdep): Ditto.
	* printcmd.c (print_insn): Use "deprecated_tm_print_insn_info"
	instead of TARGET_PRINT_INSN_INFO, add comment.
	* s390-tdep.c (s390_get_frame_info): Instead of
	"dis_asm_read_memory", use "deprecated_tm_print_insn_info".
	(s390_check_function_end, s390_is_sigreturn): Ditto.
	* corefile.c (dis_asm_read_memory): Move to "disasm.c".
	(dis_asm_memory_error, dis_asm_print_address): Ditto.
	* disasm.c: Include "gdbcore.h".
	(_initialize_disasm): New function, initialize
	"deprecated_tm_print_insn_info".
	(deprecated_tm_print_insn_info): New variable.
	(dis_asm_read_memory): Moved from "corefile.c", made static.
	(dis_asm_print_address, dis_asm_memory_error): Ditto.
	* Makefile.in (disasm.o): Update dependencies.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d5911 3
a5913 3
  set_gdbarch_fix_call_dummy (gdbarch, mips_fix_call_dummy);
  set_gdbarch_call_dummy_words (gdbarch, mips_call_dummy_words);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, sizeof (mips_call_dummy_words));
@


1.193
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d5546 3
a5548 3
  tm_print_insn_info.flavour = bfd_target_unknown_flavour;
  tm_print_insn_info.arch = bfd_arch_unknown;
  tm_print_insn_info.mach = 0;
d5629 1
a5629 1
  /* We have to set tm_print_insn_info before looking for a
d5637 1
a5637 1
	tm_print_insn_info.disassembler_options = "gpr-names=n32";
d5639 3
a5641 3
	tm_print_insn_info.disassembler_options = "gpr-names=64";
      tm_print_insn_info.flavour = bfd_target_elf_flavour;
      tm_print_insn_info.arch = bfd_arch_mips;
d5645 1
a5645 1
	tm_print_insn_info.mach = info.bfd_arch_info->mach;
d5647 1
a5647 1
	tm_print_insn_info.mach = bfd_mach_mips8000;
d5655 1
a5655 1
    tm_print_insn_info.disassembler_options = "gpr-names=32";
@


1.192
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_tm_print_insn): Rename tm_print_insn.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (_initialize_xstormy16_tdep): Update.
	* vax-tdep.c (_initialize_vax_tdep): Update.
	* v850-tdep.c (_initialize_v850_tdep): Update.
	* sparc-tdep.c (_initialize_sparc_tdep): Update.
	* s390-tdep.c (_initialize_s390_tdep): Update.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Update.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* m68k-tdep.c (_initialize_m68k_tdep): Update.
	* ia64-tdep.c (_initialize_ia64_tdep): Update.
	* hppa-tdep.c (_initialize_hppa_tdep): Update.
	* h8300-tdep.c (_initialize_h8300_tdep): Update.
	* frv-tdep.c (_initialize_frv_tdep): Update.
	* cris-tdep.c (cris_delayed_get_disassembler): Update.
	(_initialize_cris_tdep): Update.
	* arch-utils.c (legacy_print_insn): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	"tm_print_insn" to "deprecated_tm_print_insn".
@
text
@d626 3
a628 3
   definitions found in config/mips/tm-*.h.  I'm concerned about
   the ``FCRCS_REGNUM <= reg && reg <= LAST_EMBED_REGNUM'' clause
   though.  In some cases FP_REGNUM is in this range, and I doubt
d5883 1
a5883 1
  set_gdbarch_read_fp (gdbarch, mips_read_sp); /* Draft FRAME base.  */
@


1.191
log
@2003-04-14  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_read_sp): Do not apply ADDR_BITS_REMOVE,
	return the fully sign-extended register value.
	(get_frame_pointer): Ditto.
	(mips_pop_frame): Initialize "proc_desc" after checking for a
	dummy frame.
@
text
@d6399 2
a6400 2
  if (!tm_print_insn)		/* Someone may have already set it */
    tm_print_insn = gdb_print_insn_mips;
@


1.191.2.1
log
@Merge from mainline.
@
text
@d626 3
a628 3
   definitions found in config/mips/tm-*.h.  I'm concerned about the
   ``FCRCS_REGNUM <= reg && reg <= LAST_EMBED_REGNUM'' clause though.
   In some cases DEPRECATED_FP_REGNUM is in this range, and I doubt
d5546 3
a5548 3
  deprecated_tm_print_insn_info.flavour = bfd_target_unknown_flavour;
  deprecated_tm_print_insn_info.arch = bfd_arch_unknown;
  deprecated_tm_print_insn_info.mach = 0;
d5629 1
a5629 1
  /* We have to set deprecated_tm_print_insn_info before looking for a
d5637 1
a5637 1
	deprecated_tm_print_insn_info.disassembler_options = "gpr-names=n32";
d5639 3
a5641 3
	deprecated_tm_print_insn_info.disassembler_options = "gpr-names=64";
      deprecated_tm_print_insn_info.flavour = bfd_target_elf_flavour;
      deprecated_tm_print_insn_info.arch = bfd_arch_mips;
d5645 1
a5645 1
	deprecated_tm_print_insn_info.mach = info.bfd_arch_info->mach;
d5647 1
a5647 1
	deprecated_tm_print_insn_info.mach = bfd_mach_mips8000;
d5655 1
a5655 1
    deprecated_tm_print_insn_info.disassembler_options = "gpr-names=32";
d5883 1
a5883 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, mips_read_sp); /* Draft FRAME base.  */
d6399 2
a6400 2
  if (!deprecated_tm_print_insn)	 /* Someone may have already set it */
    deprecated_tm_print_insn = gdb_print_insn_mips;
@


1.191.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@a152 30
/* Return the contents of register REGNUM as a signed integer.  */

static LONGEST
read_signed_register (int regnum)
{
  void *buf = alloca (REGISTER_RAW_SIZE (regnum));
  deprecated_read_register_gen (regnum, buf);
  return (extract_signed_integer (buf, REGISTER_RAW_SIZE (regnum)));
}

static LONGEST
read_signed_register_pid (int regnum, ptid_t ptid)
{
  ptid_t save_ptid;
  LONGEST retval;

  if (ptid_equal (ptid, inferior_ptid))
    return read_signed_register (regnum);

  save_ptid = inferior_ptid;

  inferior_ptid = ptid;

  retval = read_signed_register (regnum);

  inferior_ptid = save_ptid;

  return retval;
}

d218 1
a218 1
  bfd_byte reg[MAX_REGISTER_SIZE];
d1615 1
a1615 1
  char raw_buffer[MAX_REGISTER_SIZE];
d2362 1
a2362 1
  sym = lookup_symbol (MIPS_EFI_SYMBOL_NAME, b, LABEL_DOMAIN, 0, NULL);
d2724 1
a2724 1
      char valbuf[MAX_REGISTER_SIZE];
d2740 1
a2740 1
	  store_unsigned_integer (valbuf, MIPS_SAVED_REGSIZE, VALUE_ADDRESS (arg));
d2975 1
a2975 1
      char valbuf[MAX_REGISTER_SIZE];
d3198 1
a3198 1
      char valbuf[MAX_REGISTER_SIZE];
d3497 1
a3497 1
      char valbuf[MAX_REGISTER_SIZE];
d4017 1
a4017 1
  char raw_buffer[MAX_REGISTER_SIZE];
d4073 1
a4073 1
  char raw_buffer[MAX_REGISTER_SIZE];
d4534 1
a4534 1
				char regbuf[],
d4553 1
a4553 1
			       char regbuf[],
d4576 1
a4576 1
  char raw_buffer[MAX_REGISTER_SIZE];
d4598 1
a4598 1
  char raw_buffer[MAX_REGISTER_SIZE];
d4680 1
a4680 1
      bfd_byte reg[MAX_REGISTER_SIZE];
d4792 1
a4792 1
      bfd_byte reg[MAX_REGISTER_SIZE];
d5092 13
d5119 2
a5120 1
	  static unsigned char mips16_big_breakpoint[] = {0xe8, 0xa5};
d5127 3
a5129 6
	  /* The IDT board uses an unusual breakpoint value, and
	     sometimes gets confused when it sees the usual MIPS
	     breakpoint instruction.  */
	  static unsigned char big_breakpoint[] = {0, 0x5, 0, 0xd};
	  static unsigned char pmon_big_breakpoint[] = {0, 0, 0, 0xd};
	  static unsigned char idt_big_breakpoint[] = {0, 0, 0x0a, 0xd};
d5147 2
a5148 1
	  static unsigned char mips16_little_breakpoint[] = {0xa5, 0xe8};
d5155 5
a5159 3
	  static unsigned char little_breakpoint[] = {0xd, 0, 0x5, 0};
	  static unsigned char pmon_little_breakpoint[] = {0xd, 0, 0, 0};
	  static unsigned char idt_little_breakpoint[] = {0xd, 0x0a, 0, 0};
d5415 1
a5415 1
	      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), val);
d5911 3
a5913 3
  set_gdbarch_deprecated_fix_call_dummy (gdbarch, mips_fix_call_dummy);
  set_gdbarch_deprecated_call_dummy_words (gdbarch, mips_call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (mips_call_dummy_words));
d6111 2
d6143 4
d6161 2
d6183 2
d6188 2
d6212 4
@


1.190
log
@2003-04-14  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_push_dummy_frame): Delete function.
	(MASK, PUSH_FP_REGNUM, GEN_REG_SAVE_MASK): Delete macros.
	(FLOAT_REG_SAVE_MASK, FLOAT_SINGLE_REG_SAVE_MASK): Delete macro.
	(mips_push_register): Delete function.
	(mips_dump_tdep): Delete references to GEN_REG_SAVE_MASK and
	PUSH_FP_REGNUM.
@
text
@d662 1
a662 1
  return ADDR_BITS_REMOVE (read_register (SP_REGNUM));
d2445 3
a2447 4
  return ADDR_BITS_REMOVE (read_next_frame_reg (frame, 
						PROC_FRAME_REG (proc_desc)) +
			   PROC_FRAME_OFFSET (proc_desc) - 
			   PROC_FRAME_ADJUST (proc_desc));
d3755 1
a3755 1
  mips_extra_func_info_t proc_desc = get_frame_extra_info (frame)->proc_desc;
d3764 1
@


1.189
log
@* Makefile.in (libbfd_h): Added missing setting.
* mips-tdep.c (mips_gdbarch_init): Set disassembler_options
according to the selected ABI.
@
text
@a3750 105
mips_push_register (CORE_ADDR * sp, int regno)
{
  char *buffer = alloca (MAX_REGISTER_RAW_SIZE);
  int regsize;
  int offset;
  if (MIPS_SAVED_REGSIZE < REGISTER_RAW_SIZE (regno))
    {
      regsize = MIPS_SAVED_REGSIZE;
      offset = (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
		? REGISTER_RAW_SIZE (regno) - MIPS_SAVED_REGSIZE
		: 0);
    }
  else
    {
      regsize = REGISTER_RAW_SIZE (regno);
      offset = 0;
    }
  *sp -= regsize;
  deprecated_read_register_gen (regno, buffer);
  write_memory (*sp, buffer + offset, regsize);
}

/* MASK(i,j) == (1<<i) + (1<<(i+1)) + ... + (1<<j)). Assume i<=j<(MIPS_NUMREGS-1). */
#define MASK(i,j) (((1 << ((j)+1))-1) ^ ((1 << (i))-1))

static void
mips_push_dummy_frame (void)
{
  int ireg;
  struct linked_proc_info *link = (struct linked_proc_info *)
  xmalloc (sizeof (struct linked_proc_info));
  mips_extra_func_info_t proc_desc = &link->info;
  CORE_ADDR sp = ADDR_BITS_REMOVE (read_signed_register (SP_REGNUM));
  CORE_ADDR old_sp = sp;
  link->next = linked_proc_desc_table;
  linked_proc_desc_table = link;

/* FIXME!   are these correct ? */
#define PUSH_FP_REGNUM 16	/* must be a register preserved across calls */
#define GEN_REG_SAVE_MASK MASK(1,16)|MASK(24,28)|(1<<(MIPS_NUMREGS-1))
#define FLOAT_REG_SAVE_MASK MASK(0,19)
#define FLOAT_SINGLE_REG_SAVE_MASK \
  ((1<<18)|(1<<16)|(1<<14)|(1<<12)|(1<<10)|(1<<8)|(1<<6)|(1<<4)|(1<<2)|(1<<0))
  /*
   * The registers we must save are all those not preserved across
   * procedure calls. Dest_Reg (see tm-mips.h) must also be saved.
   * In addition, we must save the PC, PUSH_FP_REGNUM, MMLO/-HI
   * and FP Control/Status registers.
   *
   *
   * Dummy frame layout:
   *  (high memory)
   *    Saved PC
   *    Saved MMHI, MMLO, FPC_CSR
   *    Saved R31
   *    Saved R28
   *    ...
   *    Saved R1
   *    Saved D18 (i.e. F19, F18)
   *    ...
   *    Saved D0 (i.e. F1, F0)
   *    Argument build area and stack arguments written via mips_push_arguments
   *  (low memory)
   */

  /* Save special registers (PC, MMHI, MMLO, FPC_CSR) */
  PROC_FRAME_REG (proc_desc) = PUSH_FP_REGNUM;
  PROC_FRAME_OFFSET (proc_desc) = 0;
  PROC_FRAME_ADJUST (proc_desc) = 0;
  mips_push_register (&sp, PC_REGNUM);
  mips_push_register (&sp, HI_REGNUM);
  mips_push_register (&sp, LO_REGNUM);
  mips_push_register (&sp, MIPS_FPU_TYPE == MIPS_FPU_NONE ? 0 : FCRCS_REGNUM);

  /* Save general CPU registers */
  PROC_REG_MASK (proc_desc) = GEN_REG_SAVE_MASK;
  /* PROC_REG_OFFSET is the offset of the first saved register from FP.  */
  PROC_REG_OFFSET (proc_desc) = sp - old_sp - MIPS_SAVED_REGSIZE;
  for (ireg = 32; --ireg >= 0;)
    if (PROC_REG_MASK (proc_desc) & (1 << ireg))
      mips_push_register (&sp, ireg);

  /* Save floating point registers starting with high order word */
  PROC_FREG_MASK (proc_desc) =
    MIPS_FPU_TYPE == MIPS_FPU_DOUBLE ? FLOAT_REG_SAVE_MASK
    : MIPS_FPU_TYPE == MIPS_FPU_SINGLE ? FLOAT_SINGLE_REG_SAVE_MASK : 0;
  /* PROC_FREG_OFFSET is the offset of the first saved *double* register
     from FP.  */
  PROC_FREG_OFFSET (proc_desc) = sp - old_sp - 8;
  for (ireg = 32; --ireg >= 0;)
    if (PROC_FREG_MASK (proc_desc) & (1 << ireg))
      mips_push_register (&sp, ireg + FP0_REGNUM);

  /* Update the frame pointer for the call dummy and the stack pointer.
     Set the procedure's starting and ending addresses to point to the
     call dummy address at the entry point.  */
  write_register (PUSH_FP_REGNUM, old_sp);
  write_register (SP_REGNUM, sp);
  PROC_LOW_ADDR (proc_desc) = CALL_DUMMY_ADDRESS ();
  PROC_HIGH_ADDR (proc_desc) = CALL_DUMMY_ADDRESS () + 4;
  SET_PROC_DESC_IS_DUMMY (proc_desc);
  PROC_PC_REG (proc_desc) = RA_REGNUM;
}

static void
a6136 3
		      "mips_dump_tdep: GEN_REG_SAVE_MASK = %d\n",
		      GEN_REG_SAVE_MASK);
  fprintf_unfiltered (file,
a6248 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PUSH_FP_REGNUM = %d\n",
		      PUSH_FP_REGNUM);
@


1.188
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_SAVED_PC_AFTER_CALL): Deprecate
	SAVED_PC_AFTER_CALL.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_saved_pc_after_call): Update declaration.
	* i386ly-tdep.c (i386lynx_init_abi): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	* infrun.c (step_over_function): Update.
	* i386-linux-tdep.c (skip_hurd_resolver): Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	* arm-linux-tdep.c (skip_hurd_resolver): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	* x86-64-tdep.h (x86_64_linux_saved_pc_after_call): Update
	declaration.
@
text
@d5734 28
a5905 12

      /* Set up the disassembler info, so that we get the right
	 register names from libopcodes.  */
      tm_print_insn_info.flavour = bfd_target_elf_flavour;
      tm_print_insn_info.arch = bfd_arch_mips;
      if (info.bfd_arch_info != NULL
	  && info.bfd_arch_info->arch == bfd_arch_mips
	  && info.bfd_arch_info->mach)
	tm_print_insn_info.mach = info.bfd_arch_info->mach;
      else
	tm_print_insn_info.mach = bfd_mach_mips8000;

a5924 12

      /* Set up the disassembler info, so that we get the right
	 register names from libopcodes.  */
      tm_print_insn_info.flavour = bfd_target_elf_flavour;
      tm_print_insn_info.arch = bfd_arch_mips;
      if (info.bfd_arch_info != NULL
	  && info.bfd_arch_info->arch == bfd_arch_mips
	  && info.bfd_arch_info->mach)
	tm_print_insn_info.mach = info.bfd_arch_info->mach;
      else
	tm_print_insn_info.mach = bfd_mach_mips8000;

@


1.187
log
@2003-04-08  Elena Zannoni  <ezannoni@@redhat.com>

        * infrun.c (stop_soon): Rename from stop_soon_quietly.
	(struct inferior_status): Rename stop_soon_quietly field to stop_soon.
	(clear_proceed_status): Rename stop_soon_quietly to stop_soon.
	(start_remote): Ditto.
	(handle_inferior_event): Ditto.
	(save_inferior_status): Ditto.
	(restore_inferior_status): Ditto.
	* infcmd.c (attach_command): Ditto.
	* fork-child.c (startup_inferior): Ditto.
        * inferior.h (stop_soon): Rename from stop_soon_quietly.
	* alpha-tdep.c (heuristic_proc_start): Ditto.
	* mips-tdep.c (heuristic_proc_start): Ditto.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Ditto.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Ditto.
	* solib-osf.c (osf_solib_create_inferior_hook): Ditto.
	* solib-irix.c (irix_solib_create_inferior_hook): Ditto.
	* remote-vx.c (vx_create_inferior): Ditto.
@
text
@d1718 1
a1718 1
	? SAVED_PC_AFTER_CALL (get_next_frame (prev))
d6038 1
a6038 1
  set_gdbarch_saved_pc_after_call (gdbarch, mips_saved_pc_after_call);
@


1.186
log
@2003-04-08  Elena Zannoni  <ezannoni@@redhat.com>

	* infrun.c (stop_soon_quietly): Make it an enum, to better
	override the default behavior of handle_inferior_event.
	(clear_proceed_status): Update uses of stop_soon_quietly to
	reflect that it is now an enum.
	(start_remote): Ditto.
	(handle_inferior_event): Change logic a bit if stop_soon_quietly
	is set to handle the new GNU/Linux kernel behavior for
	attach/sigstop.  Update uses of stop_soon_quietly.
	* inferior.h (enum stop_kind): New enum.
	* infcmd.c (attach_command): Use STOP_QUIETLY_NO_SIGSTOP.
	Reset normal handle_inferior_event behavior, afterwards.
	* fork-child.c (startup_inferior): Update.
	* alpha-tdep.c (heuristic_proc_start): Update.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Update.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Update.
	* solib-osf.c (osf_solib_create_inferior_hook): Update.
	* solib-irix.c (irix_solib_create_inferior_hook): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* mips-tdep.c (heuristic_proc_start): Update.
@
text
@d1821 1
a1821 1
	   stop_soon_quietly, but with this test, at least we
d1824 1
a1824 1
	if (stop_soon_quietly == NO_STOP_QUIETLY)
@


1.185
log
@	* mips-tdep.c (mips_print_fp_register): New function, created from
	do_fp_register_row().  Registers are now (also) printed as hex.
	Only one register is printed per row.
	(mips_print_register, do_fp_register_row): Print floating point
	registers with mips_print_fp_register().
@
text
@d1824 1
a1824 1
	if (!stop_soon_quietly)
@


1.184
log
@	* mips-tdep.c (mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Add mappings for HI_REGNUM and LO_REGNUM.
@
text
@d4052 1
a4052 78
mips_print_register (int regnum, int all)
{
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);

  /* Get the data in raw format.  */
  if (!frame_register_read (deprecated_selected_frame, regnum, raw_buffer))
    {
      printf_filtered ("%s: [Invalid]", REGISTER_NAME (regnum));
      return;
    }

  /* If we have a actual 32-bit floating point register (or we are in
     32-bit compatibility mode), and the register is even-numbered,
     also print it as a double (spanning two registers).  */
  if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (regnum)) == TYPE_CODE_FLT
      && (REGISTER_RAW_SIZE (regnum) == 4
	  || mips2_fp_compat ())
      && !((regnum - FP0_REGNUM) & 1))
    {
      char *dbuffer = alloca (2 * MAX_REGISTER_RAW_SIZE);

      mips_read_fp_register_double (regnum, dbuffer);

      printf_filtered ("(d%d: ", regnum - FP0_REGNUM);
      val_print (mips_double_register_type (), dbuffer, 0, 0,
		 gdb_stdout, 0, 1, 0, Val_pretty_default);
      printf_filtered ("); ");
    }
  fputs_filtered (REGISTER_NAME (regnum), gdb_stdout);

  /* The problem with printing numeric register names (r26, etc.) is that
     the user can't use them on input.  Probably the best solution is to
     fix it so that either the numeric or the funky (a2, etc.) names
     are accepted on input.  */
  if (regnum < MIPS_NUMREGS)
    printf_filtered ("(r%d): ", regnum);
  else
    printf_filtered (": ");

  /* If virtual format is floating, print it that way.  */
  if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (regnum)) == TYPE_CODE_FLT)
    if (REGISTER_RAW_SIZE (regnum) == 8 && !mips2_fp_compat ())
      {
	/* We have a meaningful 64-bit value in this register.  Show
	   it as a 32-bit float and a 64-bit double.  */
	int offset = 4 * (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG);

	printf_filtered (" (float) ");
	val_print (mips_float_register_type (), raw_buffer + offset, 0, 0,
		   gdb_stdout, 0, 1, 0, Val_pretty_default);
	printf_filtered (", (double) ");
	val_print (mips_double_register_type (), raw_buffer, 0, 0,
		   gdb_stdout, 0, 1, 0, Val_pretty_default);
      }
    else
      val_print (REGISTER_VIRTUAL_TYPE (regnum), raw_buffer, 0, 0,
		 gdb_stdout, 0, 1, 0, Val_pretty_default);
  /* Else print as integer in hex.  */
  else
    {
      int offset;

      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
        offset = REGISTER_RAW_SIZE (regnum) - REGISTER_VIRTUAL_SIZE (regnum);
      else
	offset = 0;

      print_scalar_formatted (raw_buffer + offset,
			      REGISTER_VIRTUAL_TYPE (regnum),
			      'x', 0, gdb_stdout);
    }
}

/* Replacement for generic do_registers_info.
   Print regs in pretty columns.  */

static int
do_fp_register_row (int regnum)
d4056 1
a4056 1
  int inv1, inv2, inv3;
d4060 3
d4065 2
a4066 2
      /* 4-byte registers: we can fit two registers per row.  */
      /* Also print every pair of 4-byte regs as an 8-byte double.  */
d4070 2
a4071 2
      mips_read_fp_register_single (regnum + 1, raw_buffer);
      flt2 = unpack_double (mips_float_register_type (), raw_buffer, &inv2);
d4073 1
a4073 4
      mips_read_fp_register_double (regnum, raw_buffer);
      doub = unpack_double (mips_double_register_type (), raw_buffer, &inv3);

      printf_filtered (" %-5s", REGISTER_NAME (regnum));
d4075 1
a4075 1
	printf_filtered (": <invalid float>");
d4079 12
a4090 15
      printf_filtered (" %-5s", REGISTER_NAME (regnum + 1));
      if (inv2)
	printf_filtered (": <invalid float>");
      else
	printf_filtered ("%-17.9g", flt2);

      printf_filtered (" dbl: ");
      if (inv3)
	printf_filtered ("<invalid double>");
      else
	printf_filtered ("%-24.17g", doub);
      printf_filtered ("\n");

      /* may want to do hex display here (future enhancement) */
      regnum += 2;
d4094 1
a4094 1
      /* Eight byte registers: print each one as float AND as double.  */
d4099 5
a4103 1
      doub = unpack_double (mips_double_register_type (), raw_buffer, &inv3);
d4105 1
a4105 1
      printf_filtered (" %-5s: ", REGISTER_NAME (regnum));
d4109 1
a4109 1
	printf_filtered ("flt: %-17.9g", flt1);
d4112 1
a4112 1
      if (inv3)
d4116 14
d4131 5
a4135 3
      printf_filtered ("\n");
      /* may want to do hex display here (future enhancement) */
      regnum++;
d4137 20
a4156 1
  return regnum;
d4158 13
@


1.184.2.1
log
@Merge with mainline.
@
text
@d1821 1
a1821 1
	   stop_soon, but with this test, at least we
d1824 1
a1824 1
	if (stop_soon == NO_STOP_QUIETLY)
d4052 78
a4129 1
mips_print_fp_register (int regnum)
d4133 1
a4133 1
  int inv1, inv2, namelen;
a4136 3
  printf_filtered ("%s:", REGISTER_NAME (regnum));
  printf_filtered ("%*s", 4 - (int) strlen (REGISTER_NAME (regnum)), "");

d4139 2
a4140 2
      /* 4-byte registers: Print hex and floating.  Also print even
         numbered registers as doubles.  */
d4144 5
a4148 2
      print_scalar_formatted (raw_buffer, builtin_type_uint32, 'x', 'w',
                              gdb_stdout);
d4150 1
a4150 1
      printf_filtered (" flt: ");
d4152 1
a4152 1
	printf_filtered (" <invalid float> ");
d4156 15
a4170 12
      if (regnum % 2 == 0)
	{
	  mips_read_fp_register_double (regnum, raw_buffer);
	  doub = unpack_double (mips_double_register_type (), raw_buffer,
	                        &inv2);

	  printf_filtered (" dbl: ");
	  if (inv2)
	    printf_filtered ("<invalid double>");
	  else
	    printf_filtered ("%-24.17g", doub);
	}
d4174 1
a4174 1
      /* Eight byte registers: print each one as hex, float and double.  */
d4179 1
a4179 5
      doub = unpack_double (mips_double_register_type (), raw_buffer, &inv2);


      print_scalar_formatted (raw_buffer, builtin_type_uint64, 'x', 'g',
                              gdb_stdout);
d4181 1
a4181 1
      printf_filtered (" flt: ");
d4185 1
a4185 1
	printf_filtered ("%-17.9g", flt1);
d4188 1
a4188 1
      if (inv2)
a4191 8
    }
}

static void
mips_print_register (int regnum, int all)
{
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  int offset;
d4193 3
a4195 4
  if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (regnum)) == TYPE_CODE_FLT)
    {
      mips_print_fp_register (regnum);
      return;
d4197 1
a4197 39

  /* Get the data in raw format.  */
  if (!frame_register_read (deprecated_selected_frame, regnum, raw_buffer))
    {
      printf_filtered ("%s: [Invalid]", REGISTER_NAME (regnum));
      return;
    }

  fputs_filtered (REGISTER_NAME (regnum), gdb_stdout);

  /* The problem with printing numeric register names (r26, etc.) is that
     the user can't use them on input.  Probably the best solution is to
     fix it so that either the numeric or the funky (a2, etc.) names
     are accepted on input.  */
  if (regnum < MIPS_NUMREGS)
    printf_filtered ("(r%d): ", regnum);
  else
    printf_filtered (": ");

  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    offset = REGISTER_RAW_SIZE (regnum) - REGISTER_VIRTUAL_SIZE (regnum);
  else
    offset = 0;

  print_scalar_formatted (raw_buffer + offset,
			  REGISTER_VIRTUAL_TYPE (regnum),
			  'x', 0, gdb_stdout);
}

/* Replacement for generic do_registers_info.
   Print regs in pretty columns.  */

static int
do_fp_register_row (int regnum)
{
  printf_filtered (" ");
  mips_print_fp_register (regnum);
  printf_filtered ("\n");
  return regnum + 1;
a4198 1

@


1.183
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_START_OFFSET): Default to zero.
	CALL_DUMMY_LENGTH): Ditto.
	* gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_START_OFFSET): Delete macro.
	(CALL_DUMMY_LENGTH): Delete macro.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set above when zero.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@d5576 4
d5598 4
@


1.182
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_BREAKPOINT_OFFSET): Default to zero.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sp64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* config/pa/tm-hppa64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* inferior.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET): Delete.
	* infcmd.c (run_stack_dummy): Simplify assuming
	CALL_DUMMY_BREAKPOINT_OFFSET_P.
	* infrun.c (handle_inferior_event): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	call_dummy_breakpoint_offset or call_dummy_breakpoint_offset_p.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@a6031 2
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
  set_gdbarch_call_dummy_length (gdbarch, 0);
@


1.181
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_P): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* dummy-frame.c (dummy_frame_this_id): Update comments.
	* rs6000-tdep.c (rs6000_extract_struct_value_address): Ditto.
	* frame.c (legacy_get_prev_frame): Ditto.
	* valops.c (call_function_by_hand): Delete function.
	(hand_function_call): Rename to call_function_by_hand

2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to CALL_DUMMY_P.
@
text
@a6032 2
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
@


1.180
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_DUMMY_WRITE_SP): Replace TARGET_WRITE_SP.
	* gdbarch.h, gdbarch.c: Regenerate.
	* v850-tdep.c (v850_gdbarch_init): Set deprecated_dummy_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_push_dummy_frame, sparc_pop_frame): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_DUMMY_WRITE_SP): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* valops.c (hand_function_call): Replace TARGET_WRITE_SP with
	DEPRECATED_DUMMY_WRITE_SP.  Call when the method is available,
	instead of when push_dummy_call is not available.

2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Remove
	reference to TARGET_WRITE_SP.
@
text
@a6028 1
  set_gdbarch_call_dummy_p (gdbarch, 1);
@


1.179
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_RETURN_ADDRESS): Replace
	PUSH_RETURN_ADDRESS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* valops.c (hand_function_call): Update.
@
text
@d6006 1
a6006 1
  set_gdbarch_write_sp (gdbarch, generic_target_write_sp);
@


1.178
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_ARGUMENTS): Rename PUSH_ARGUMENTS.
	(push_dummy_call): New pure multi-arch replacement with gdbarch,
	regcache and dummy_addr parameters.
	* gdbarch.h, gdbarch.c: Re-generate.
	* valops.c (hand_function_call): Use gdbarch_push_dummy_call when
	available; assume it will handle stack alignment and return
	address issues.  Fall back to DEPRECATED_PUSH_ARGUMENTS and
	legacy_push_arguments.
	(legacy_push_arguments): Rename default_push_arguments.
	* value.h (legacy_push_arguments): Rename default_push_arguments.
	* i386-tdep.c (i386_push_arguments): Call legacy_push_arguments.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/i386/tm-symmetry.h: Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* arm-linux-tdep.c (arm_linux_init_abi): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	PUSH_ARGUMENTS with push_dummy_call, add gdbarch, regcache and
	dummy_addr parameters.
@
text
@d6031 1
a6031 1
  set_gdbarch_push_return_address (gdbarch, mips_push_return_address);
d6040 1
a6040 1
  set_gdbarch_push_return_address (gdbarch, mips_push_return_address);
@


1.177
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STORE_STRUCT_RETURN): Replace
	STORE_STRUCT_RETURN.
	* gdbarch.h, gdbarch.c: Regenerate.
	* d10v-tdep.c (d10v_store_struct_return): Delete function.
	(d10v_push_arguments): Set the struct return register.
	(d10v_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d5809 1
a5809 1
      set_gdbarch_push_arguments (gdbarch, mips_o32_push_arguments);
d5828 1
a5828 1
      set_gdbarch_push_arguments (gdbarch, mips_o64_push_arguments);
d5847 1
a5847 1
      set_gdbarch_push_arguments (gdbarch, mips_eabi_push_arguments);
d5866 1
a5866 1
      set_gdbarch_push_arguments (gdbarch, mips_eabi_push_arguments);
d5885 1
a5885 1
      set_gdbarch_push_arguments (gdbarch, mips_n32n64_push_arguments);
d5916 1
a5916 1
      set_gdbarch_push_arguments (gdbarch, mips_n32n64_push_arguments);
@


1.177.2.1
log
@Merge with mainline.
@
text
@d5809 1
a5809 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_o32_push_arguments);
d5828 1
a5828 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_o64_push_arguments);
d5847 1
a5847 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_eabi_push_arguments);
d5866 1
a5866 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_eabi_push_arguments);
d5885 1
a5885 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_n32n64_push_arguments);
d5916 1
a5916 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_n32n64_push_arguments);
d6006 1
a6006 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
d6031 1
a6031 1
  set_gdbarch_deprecated_push_return_address (gdbarch, mips_push_return_address);
d6040 1
a6040 1
  set_gdbarch_deprecated_push_return_address (gdbarch, mips_push_return_address);
@


1.176
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_STACK_ADJUST_P): Delete.
	(DEPRECATED_CALL_DUMMY_STACK_ADJUST): Replace
	CALL_DUMMY_STACK_ADJUST with a predicate variable.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_stack_adjust_p.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sparc.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.  Do not set
	call_dummy_stack_adjust_p.
	* inferior.h (CALL_DUMMY_STACK_ADJUST_P): Delete macro.
	(CALL_DUMMY_STACK_ADJUST): Delete macro.
	* sparc-tdep.c (sparc32_push_arguments): Update.
	* valops.c (hand_function_call): Update.

2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	reference to CALL_DUMMY_STACK_ADJUST_P.  Rename
	CALL_DUMMY_STACK_ADJUST to DEPRECATED_CALL_DUMMY_STACK_ADJUST.
	Add reference to PUSH_ARGUMENTS.
@
text
@d6082 1
a6082 1
  set_gdbarch_store_struct_return (gdbarch, mips_store_struct_return);
@


1.175
log
@Index: ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_CHAIN): Replace FRAME_CHAIN.
	(DEPRECATED_FRAME_CHAIN_VALID): Replace FRAME_CHAIN_VALID.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update.
	* objfiles.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame, get_prev_frame, legacy_frame_p): Update.
	* dummy-frame.h: Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* config/m68k/tm-vx68.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-os68k.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-sun3.h: Update.
	* blockframe.c (inside_main_func, frame_chain_valid): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_frame_chain, sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	(rs6000_gdbarch_init, rs6000_frame_saved_pc): Update.
	(frame_get_saved_regs): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_frame_num_args, i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	(i386_interix_back_one_frame): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	(hppa_init_extra_frame_info): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Algorithms, Target Architecture Definition):
	Deprecate FRAME_CHAIN and FRAME_CHAIN_VALID.
@
text
@a6029 1
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
@


1.174
log
@	* mips-tdep.c (mips_register_name): Fix fencepost error involving
	NUM_REGS bounds check.
@
text
@d6050 1
a6050 1
  set_gdbarch_frame_chain (gdbarch, mips_frame_chain);
@


1.173
log
@Print correct register names for MIPS targets using n32/n64 ABIs.
@
text
@d405 1
a405 1
  else if (32 <= regno && regno <= NUM_REGS)
@


1.172
log
@2003-03-14  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_GET_SAVED_REGISTER): Replace
	GET_SAVED_REGISTER.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h: Update comments.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frame.c (frame_register): Update.
	(get_saved_register): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_GET_SAVED_REGISTER): Update.
@
text
@d28 1
d365 1
d367 5
a371 2
char *mips_generic_reg_names[] = MIPS_REGISTER_NAMES;
char **mips_processor_reg_names = mips_generic_reg_names;
d373 1
d375 1
a375 1
mips_register_name (int i)
d377 33
a409 1
  return mips_processor_reg_names[i];
d411 1
a415 4
	"zero",	"at",	"v0",	"v1",	"a0",	"a1",	"a2",	"a3",
	"t0",	"t1",	"t2",	"t3",	"t4",	"t5",	"t6",	"t7",
	"s0",	"s1",	"s2",	"s3",	"s4",	"s5",	"s6",	"s7",
	"t8",	"t9",	"k0",	"k1",	"gp",	"sp",	"s8",	"ra",
a428 4
	"zero",	"at",	"v0",	"v1",	"a0",	"a1",	"a2",	"a3",
	"t0",	"t1",	"t2",	"t3",	"t4",	"t5",	"t6",	"t7",
	"s0",	"s1",	"s2",	"s3",	"s4",	"s5",	"s6",	"s7",
	"t8",	"t9",	"k0",	"k1",	"gp",	"sp",	"s8",	"ra",
a441 4
	"zero",	"at",	"v0",	"v1",	"a0",	"a1",	"a2",	"a3",
	"t0",	"t1",	"t2",	"t3",	"t4",	"t5",	"t6",	"t7",
	"s0",	"s1",	"s2",	"s3",	"s4",	"s5",	"s6",	"s7",
	"t8",	"t9",	"k0",	"k1",	"gp",	"sp",	"s8",	"ra",
a454 4
	"zero",	"at",	"v0",	"v1",	"a0",	"a1",	"a2",	"a3",
	"t0",	"t1",	"t2",	"t3",	"t4",	"t5",	"t6",	"t7",
	"s0",	"s1",	"s2",	"s3",	"s4",	"s5",	"s6",	"s7",
	"t8",	"t9",	"k0",	"k1",	"gp",	"sp",	"s8",	"ra",
@


1.171
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_POP_FRAME): Replace POP_FRAME.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update comment.
	* stack.c (return_command): Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_POP_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_POP_FRAME): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	POP_FRAME with DEPRECATED_POP_FRAME.  Update description.
@
text
@d6034 1
a6034 1
  set_gdbarch_get_saved_register (gdbarch, mips_get_saved_register);
@


1.170
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_SAVED_PC): Replace FRAME_SAVED_PC.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.h: Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* sh-tdep.c (sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Update.
	* xstormy16-tdep.c (xstormy16_pop_frame): Update.
	(xstormy16_frame_chain_valid): Update.
	* vax-tdep.c (vax_saved_pc_after_call): Update.
	* v850-tdep.c (v850_frame_chain): Update.
	(v850_pop_frame): Update.
	(v850_init_extra_frame_info): Update.
	* sparc-tdep.c (setup_arbitrary_frame): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* s390-tdep.c (s390_pop_frame_regular): Update.
	* mn10300-tdep.c (mn10300_frame_chain): Update.
	(mn10300_pop_frame_regular): Update.
	(mn10300_init_extra_frame_info): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	(mips_frame_chain): Update.
	(mips_pop_frame): Update.
	* mcore-tdep.c (mcore_frame_chain): Update.
	(mcore_pop_frame): Update.
	(mcore_init_extra_frame_info): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* m68k-tdep.c (isi_frame_num_args): Update.
	(delta68_frame_num_args): Update.
	(news_frame_num_args): Update.
	* ia64-tdep.c (ia64_pop_frame_regular): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	(alpha_frame_chain): Update.
	(alpha_pop_frame): Update.
	* hppa-tdep.c (hppa_saved_pc_after_call): Update.
	(hppa_init_extra_frame_info): Update.
	(hppa_frame_chain): Update.
	(hppa_frame_chain_valid): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_init_extra_frame_info): Update.
	* arm-tdep.c (arm_frame_chain_valid): Update.
	(arm_init_extra_frame_info): Update.
	(arm_pop_frame): Update.
	* frame.c (frame_pc_unwind): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_SAVED_PC): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-linux.h (DEPRECATED_FRAME_SAVED_PC): Update.

2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_SAVED_PC to DEPRECATED_FRAME_SAVED_PC.
@
text
@d6010 1
a6010 1
  set_gdbarch_pop_frame (gdbarch, mips_pop_frame);
@


1.169
log
@	* mips-tdep.c (mips_ecoff_reg_to_regnum): Rename to
	mips_dwarf_dwarf2_ecoff_reg_to_regnum().
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum, mips_stab_reg_to_regnum):
	Do range checks on register number obtained from debugging info.
	(mips_gdbarch_init): Call set_gdbarch_dwarf_reg_to_regnum() and
	set_gdbarch_dwarf2_reg_to_regnum().  Adjust call of
	set_gdbarch_ecoff_reg_to_regnum() to account for new name of
	mapping function.
	(do_fp_register_row): Fix typo which caused double type to be
	used when attempting to unpack a float.
@
text
@d1697 1
a1697 1
	? FRAME_SAVED_PC (get_next_frame (prev))
d2435 1
a2435 1
  CORE_ADDR saved_pc = FRAME_SAVED_PC (frame);
d3847 1
a3847 1
  write_register (PC_REGNUM, FRAME_SAVED_PC (frame));
d6030 1
a6030 1
  set_gdbarch_frame_saved_pc (gdbarch, mips_frame_saved_pc);
@


1.168
log
@2003-03-03  Andrew Cagney  <cagney@@redhat.com>

	Make MAX_REGISTER_RAW_SIZE and MAX_REGISTER_VIRTUAL_SIZE optional.
	* gdbarch.sh (DEPRECATED_MAX_REGISTER_RAW_SIZE): Variable with
	predicate.  Replace MAX_REGISTER_RAW_SIZE.
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto for
	MAX_REGISTER_VIRTUAL_SIZE.
	* regcache.c (legacy_max_register_raw_size): New function.
	(legacy_max_register_virtual_size): New function.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Define.
	(MAX_REGISTER_RAW_SIZE): Define.
	(legacy_max_register_raw_size): Declare.
	(legacy_max_register_virtual_size): Declare.
	* config/sparc/tm-sparc.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/i386/tm-ptx.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Do not set
	max_register_raw_size or max_register_virtual_size.
@
text
@d4153 1
a4153 1
      flt1 = unpack_double (mips_double_register_type (), raw_buffer, &inv1);
d5549 1
a5549 1
  if (num < 32)
d5551 2
d5554 5
a5558 1
    return num + FP0_REGNUM - 38;
d5561 2
a5562 1
/* Convert a ecoff register number to a gdb REGNUM */
d5565 1
a5565 1
mips_ecoff_reg_to_regnum (int num)
d5567 1
a5567 1
  if (num < 32)
d5569 2
d5572 5
a5576 1
    return num + FP0_REGNUM - 32;
d5579 1
d5996 3
a5998 1
  set_gdbarch_ecoff_reg_to_regnum (gdbarch, mips_ecoff_reg_to_regnum);
@


1.168.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d1697 1
a1697 1
	? DEPRECATED_FRAME_SAVED_PC (get_next_frame (prev))
d2435 1
a2435 1
  CORE_ADDR saved_pc = DEPRECATED_FRAME_SAVED_PC (frame);
d3847 1
a3847 1
  write_register (PC_REGNUM, DEPRECATED_FRAME_SAVED_PC (frame));
d4153 1
a4153 1
      flt1 = unpack_double (mips_float_register_type (), raw_buffer, &inv1);
d5549 1
a5549 1
  if (num >= 0 && num < 32)
d5551 1
a5551 1
  else if (num >= 38 && num < 70)
a5552 6
  else
    {
      /* This will hopefully (eventually) provoke a warning.  Should
         we be calling complaint() here?  */
      return NUM_REGS + NUM_PSEUDO_REGS;
    }
d5555 1
a5555 2

/* Convert a dwarf, dwarf2, or ecoff register number to a gdb REGNUM */
d5558 1
a5558 1
mips_dwarf_dwarf2_ecoff_reg_to_regnum (int num)
d5560 1
a5560 1
  if (num >= 0 && num < 32)
d5562 1
a5562 1
  else if (num >= 32 && num < 64)
a5563 6
  else
    {
      /* This will hopefully (eventually) provoke a warning.  Should
         we be calling complaint() here?  */
      return NUM_REGS + NUM_PSEUDO_REGS;
    }
a5565 1

d5982 1
a5982 3
  set_gdbarch_ecoff_reg_to_regnum (gdbarch, mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, mips_dwarf_dwarf2_ecoff_reg_to_regnum);
d5994 1
a5994 1
  set_gdbarch_deprecated_pop_frame (gdbarch, mips_pop_frame);
d6014 1
a6014 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, mips_frame_saved_pc);
d6018 1
a6018 1
  set_gdbarch_deprecated_get_saved_register (gdbarch, mips_get_saved_register);
@


1.167
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_INIT_SAVED_REGS): Rename
	FRAME_INIT_SAVED_REGS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* stack.c (frame_info): Update.
	* sh-tdep.c (sh_find_callers_reg, sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info, sh64_init_extra_frame_info): Update.
	(sh64_get_saved_register, sh_pop_frame, sh64_pop_frame): Update.
	* ns32k-tdep.c (ns32k_pop_frame): Update.
	* mips-tdep.c (mips_pop_frame): Update.
	* m68hc11-tdep.c (m68hc11_pop_frame): Update.
	* ia64-tdep.c (ia64_frame_chain): Update.
	(ia64_frame_saved_pc, ia64_get_saved_register): Update.
	(ia64_frameless_function_invocation): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_pop_frame_regular): Update.
	* frame.h (struct frame_info): Update comment.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Rename macro.
	* frame.c (frame_saved_regs_register_unwind): Update.
	(frame_saved_regs_register_unwind): Update.
	(deprecated_generic_get_saved_register): Update.
	* cris-tdep.c: Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_INIT_SAVED_REGS):
	Rename macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_INIT_SAVED_REGS to DEPRECATED_FRAME_INIT_SAVED_REGS.
@
text
@d5756 2
a5757 2
  set_gdbarch_max_register_raw_size (gdbarch, 8);
  set_gdbarch_max_register_virtual_size (gdbarch, 8);
@


1.166
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename
	INIT_EXTRA_FRAME_INFO.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-tdep.c: Update comments.
	* sh-tdep.c, mcore-tdep.c, m68hc11-tdep.c: Ditto.
	* i386-interix-tdep.c, hppa-tdep.c, h8300-tdep.c: Ditto.
	* frame.h, avr-tdep.c: Ditto.
	* frame.c (get_prev_frame): DEPRECATED_INIT_EXTRA_FRAME_INFO.
	(create_new_frame, legacy_get_prev_frame): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* config/pa/tm-hppa.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Initialize
	deprecated_init_extra_frame_info instead of init_extra_frame_info.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.

Index: doc/ChangeLog
2003-02-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo: Rename INIT_EXTRA_FRAME_INFO to
	DEPRECATED_INIT_EXTRA_FRAME_INFO.
@
text
@d3849 1
a3849 1
    FRAME_INIT_SAVED_REGS (frame);
d5985 1
a5986 1
  set_gdbarch_frame_init_saved_regs (gdbarch, mips_frame_init_saved_regs);
@


1.165
log
@2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_DUMMY_FRAME): Procedure with
	predicate.  Replaces PUSH_DUMMY_FRAME.
	* gdbarch.h, gdbarch.c: Regnerate.
	* valops.c (hand_function_call): Update.  Call
	generic_push_dummy_frame directly.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* inferior.h (PUSH_DUMMY_FRAME): Delete definition.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Don't set
	push_dummy_frame to generic_push_dummy_frame.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@d5985 1
a5985 1
  set_gdbarch_init_extra_frame_info (gdbarch, mips_init_extra_frame_info);
@


1.164
log
@Make ``show mips abi'' actually show the abi in use.
@
text
@a5993 1
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
@


1.163
log
@	* frame.c (generic_unwind_get_saved_register): Make non-static.
	* frame.h (generic_unwind_get_saved_register): Declare.
	* mips-tdep.c (read_next_frame_reg): Fetch register from
	current regcache when frame is NULL.
	(mips_init_extra_frame_info): Pass NULL explicitly for parameter
	that must be NULL.
	(mips_get_saved_register): Call generic_unwind_get_saved_register()
	instead of frame_register_unwind().
@
text
@d6069 32
a6547 1
  add_show_from_set (c, &showmipscmdlist);
d6549 2
@


1.162
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d1593 22
a1614 14
  frame_register_unwind (fi, regno, &optimized, &lval, &addr, &realnum,
			 raw_buffer);
  /* FIXME: cagney/2002-09-13: This is just soooo bad.  The MIPS
     should have a pseudo register range that correspons to the ABI's,
     rather than the ISA's, view of registers.  These registers would
     then implicitly describe their size and hence could be used
     without the below munging.  */
  if (lval == lval_memory)
    {
      if (regno < 32)
	{
	  /* Only MIPS_SAVED_REGSIZE bytes of GP registers are
	     saved. */
	  return read_memory_integer (addr, MIPS_SAVED_REGSIZE);
d2485 4
a2488 1
  /* Use proc_desc calculated in frame_chain */
d2492 3
a2494 1
    : find_proc_desc (get_frame_pc (fci), get_next_frame (fci), 1);
a5497 1
  int realnum;
d5509 2
a5510 2
  frame_register_unwind (get_next_frame (frame), regnum, optimizedp, lvalp,
			 addrp, &realnum, raw_buffer);
@


1.161
log
@	* mips-tdep.c (mips_init_extra_frame_info): Return early for
	dummy frames.
@
text
@d43 1
@


1.160
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* cris-tdep.c: Fix function declaration indentation.
	* dwarfread.c, gdbcore.h, gdbtypes.h, i386v-nat.c: Ditto.
	* mips-tdep.c, monitor.h, parse.c, proc-utils.h: Ditto.
	* rs6000-nat.c, ser-go32.c, somread.c, stabsread.c: Ditto.
	* symfile.h, symtab.h, target.c, target.h, value.h: Ditto.
	* xcoffread.c, config/pa/tm-hppa.h: Ditto.
	* config/sparc/tm-sp64.h, config/sparc/tm-sparc.h: Ditto.
@
text
@d2471 4
d2477 1
a2477 1
  mips_extra_func_info_t proc_desc =
@


1.159
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* cris-tdep.c (cris_frame_init_saved_regs): Use
	get_frame_saved_regs and SIZEOF_FRAME_SAVED_REGS when copying a
	saved_regs buffer.
	* sh-tdep.c (sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* arm-tdep.c: Use deprecated_set_frame_saved_regs_hack.
	* mips-tdep.c (mips_init_extra_frame_info): Ditto.
	* mcore-tdep.c (analyze_dummy_frame): Ditto.
	* mn10300-tdep.c (analyze_dummy_frame): Ditto.
@
text
@d323 2
a324 2
static mips_extra_func_info_t
heuristic_proc_desc (CORE_ADDR, CORE_ADDR, struct frame_info *, int);
d336 3
a338 2
static mips_extra_func_info_t
find_proc_desc (CORE_ADDR pc, struct frame_info *next_frame, int cur_frame);
@


1.158
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_extra_info.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, ia64-tdep.c, m68hc11-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10300-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@d2479 1
a2479 1
  fci->saved_regs = NULL;
@


1.157
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_next_frame.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10200-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, sparc-tdep.c: Ditto.
	* v850-tdep.c, vax-tdep.c, x86-64-linux-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
@
text
@d495 3
a497 3
      && fi->extra_info
      && fi->extra_info->proc_desc
      && fi->extra_info->proc_desc->pdr.framereg < NUM_REGS)
d499 2
a500 2
		     REGISTER_NAME (fi->extra_info->proc_desc->pdr.framereg),
		     paddr_d (fi->extra_info->proc_desc->pdr.frameoffset));
d1437 1
a1437 1
  proc_desc = fci->extra_info->proc_desc;
d1698 1
a1698 1
  mips_extra_func_info_t proc_desc = frame->extra_info->proc_desc;
d2480 1
a2480 1
  fci->extra_info->proc_desc =
d2532 1
a2532 1
      fci->extra_info->num_args = -1;
d2537 1
a2537 1
	      fci->extra_info->num_args = regnum - A0_REGNUM + 1;
d3819 1
a3819 1
  mips_extra_func_info_t proc_desc = frame->extra_info->proc_desc;
@


1.156
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_base.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* mn10300-tdep.c, ns32k-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c: Ditto.
	* x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* config/h8500/tm-h8500.h, config/mn10200/tm-mn10200.h: Ditto.
	* config/sparc/tm-sparc.h: Ditto.
@
text
@d1452 2
a1453 1
       (fci->next == NULL || (get_frame_type (fci->next) == SIGTRAMP_FRAME))
d1684 5
a1688 2
  pc = ((fromleaf) ? SAVED_PC_AFTER_CALL (prev->next) :
	prev->next ? FRAME_SAVED_PC (prev->next) : read_pc ());
d2473 3
a2475 1
    fci->next ? cached_proc_desc : find_proc_desc (get_frame_pc (fci), fci->next, 1);
d2490 1
a2490 1
	deprecated_update_frame_base_hack (fci, read_next_frame_reg (fci->next, SP_REGNUM));
d2500 1
a2500 1
	deprecated_update_frame_base_hack (fci, get_frame_pointer (fci->next, proc_desc));
@


1.155
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_init_extra_frame_info): Allocate
	extra_info using frame_extra_info_zalloc.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	* sh-tdep.c (sh_init_extra_frame_info): Ditto.
	(sh64_init_extra_frame_info): Ditto.
	* mn10300-tdep.c (mn10300_init_extra_frame_info): Ditto.
	* s390-tdep.c (s390_init_extra_frame_info): Ditto.
	* mips-tdep.c (mips_init_extra_frame_info): Ditto.
	* mcore-tdep.c (mcore_init_extra_frame_info): Ditto.
	* frv-tdep.c (frv_init_extra_frame_info): Ditto.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Ditto.
	* ia64-tdep.c (ia64_init_extra_frame_info): Ditto.
	* h8300-tdep.c (h8300_init_extra_frame_info): Ditto.
	* d10v-tdep.c (d10v_init_extra_frame_info): Ditto.
	* cris-tdep.c (cris_init_extra_frame_info): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.
	* alpha-tdep.c (alpha_init_extra_frame_info): Ditto.

	* mn10300-tdep.c (analyze_dummy_frame): Use
	deprecated_set_frame_extra_info_hack.
	* mcore-tdep.c (analyze_dummy_frame): Ditto.
@
text
@d1423 1
a1423 1
	  reg_position = fci->frame + SIGFRAME_REGSAVE_OFF
d1429 1
a1429 1
	  reg_position = fci->frame + SIGFRAME_FPREGSAVE_OFF
d1433 1
a1433 1
      get_frame_saved_regs (fci)[PC_REGNUM] = fci->frame + SIGFRAME_PC_OFF;
d1499 1
a1499 1
  reg_position = fci->frame + PROC_REG_OFFSET (proc_desc);
d1520 1
a1520 1
	  reg_position = fci->frame + PROC_REG_OFFSET (proc_desc);
d1535 1
a1535 1
  reg_position = fci->frame + PROC_FREG_OFFSET (proc_desc);
d1579 1
a1579 1
  get_frame_saved_regs (frame)[SP_REGNUM] = frame->frame;
d1707 1
a1707 1
    saved_pc = read_memory_integer (frame->frame - MIPS_SAVED_REGSIZE, MIPS_SAVED_REGSIZE);
d2436 1
a2436 1
      return frame->frame;
d2520 1
a2520 1
	      get_frame_saved_regs (fci)[SP_REGNUM] = fci->frame;
@


1.154
log
@	* arm-tdep.c (arm_frame_chain_valid):  Remove unnecessary test.
	* d10v-tdep.c (d10v_frame_chain_valid): Remove unnecessary tests.
	* hppa-tdep.c (hppa_frame_chain_valid): Remove unnecessary test.

	* blockframe.c: Include "gdbcmd.h" and "command.h".
	(backtrace_below_main): New variable.
	(file_frame_chain_valid, func_frame_chain_valid)
	(nonnull_frame_chain_valid, generic_file_frame_chain_valid)
	(generic_func_frame_chain_valid): Remove functions.
	(frame_chain_valid, do_flush_frames_sfunc): New functions.
	(_initialize_blockframe): New function.
	* Makefile.in (blockframe.o): Update dependencies.
	* frame.c (frame_saved_regs_id_unwind, get_prev_frame): Remove FIXME
	comment.  Call frame_chain_valid ().
	* frame.h: Remove old prototypes.  Add prototype for
	frame_chain_valid and update comments to match.
	* gdbarch.sh: Change FRAME_CHAIN_VALID into a predicated function.
	Remove old comment.
	* gdbarch.h: Regenerated.
	* gdbarch.c: Regenerated.

Plus updates to all other targets not to provide a FRAME_CHAIN_VALID.
@
text
@d2471 1
a2471 2
  fci->extra_info = (struct frame_extra_info *)
    frame_obstack_alloc (sizeof (struct frame_extra_info));
@


1.153
log
@	* arch-utils.c (gdbarch_info_init): Set osabi to
	GDB_OSABI_UNINITIALIZED.
	* gdbarch.sh: Add osabi to struct gdbarch and to struct
	gdbarch_info.  Include "osabi.h" in gdbarch.c.  Check osabi
	in gdbarch_list_lookup_by_info and in gdbarch_update_p.
	* gdbarch.c: Regenerated.
	* gdbarch.h: Regenerated.
	* osabi.c (gdbarch_lookup_osabi): Return GDB_OSABI_UNINITIALIZED if
	there's no BFD.
	(gdbarch_init_osabi): Remove osabi argument; use info.osabi.
	* osabi.h (enum gdb_osabi): Move to defs.h.
	(gdbarch_init_osabi): Update prototype.
	* defs.h (enum gdb_osabi): Moved here.
	* Makefile.in: Update dependencies.

Plus updates to alpha, arm, hppa, i386, mips, ns32k, ppc, sh, sparc, and vax
ports to match.
@
text
@a5989 1
  set_gdbarch_frame_chain_valid (gdbarch, func_frame_chain_valid);
@


1.152
log
@gdb/
	* buildsym.h (processing_hp_compilation): Remove obsolete variable.
	* gdbarch.sh Remove include of "value.h" in gdbarch.h.
	(COERCE_FLOAT_TO_DOUBLE): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* Makefile.in: Remove value_h from gdbarch_h.
	* valops.c (coerce_float_to_double): New variable.
	(default_coerce_float_to_double): Remove.
	(standard_coerce_float_to_double): Remove.
	(value_arg_coerce): Use coerce_float_to_double.
	(_initialize_valops): Add "set coerce-float-to-double".
	* value.h (default_coerce_float_to_double): Remove prototype.
	(standard_coerce_float_to_double): Remove prototype.

	* hpread.c (hpread_process_one_debug_symbol): Mark C++ functions as
	prototyped.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Mark all functions as prototyped.

	* hppa-tdep.c (hppa_coerce_float_to_double): Remove.
	* alpha-tdep.c (alpha_gdbarch_init): Remove call to
	set_gdbarch_coerce_float_to_double.
	* arm-tdep.c (arm_gdbarch_init): Likewise.
	* frv-tdep.c (frv_gdbarch_init): Likewise.
	* h8300-tdep.c (h8300_gdbarch_init): Likewise (commented out).
	* i386-sol2-tdep.c (i386_sol2_init_abi): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	(mips_coerce_float_to_double): Remove.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	(rs6000_coerce_float_to_double): Remove.
	* s390-tdep.c (s390_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	(sh_coerce_float_to_double): Remove.
	* sparc-tdep.c (sparc_gdbarch_init): Likewise.
	(sparc_coerce_float_to_double): Remove.
	* v850-tdep.c (v850_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.
	* config/m32r/tm-m32r.h (COERCE_FLOAT_TO_DOUBLE): Remove.
	* config/pa/tm-hppa.h: (COERCE_FLOAT_TO_DOUBLE): Remove.
	(hppa_coerce_float_to_double): Remove prototype.
	* config/sparc/tm-sparc.h (COERCE_FLOAT_TO_DOUBLE): Remove.
doc/
	* gdb.texinfo (Controlling GDB): Add ABI section.  Document
	"set coerce-float-to-double".
	* gdbint.texinfo (COERCE_FLOAT_TO_DOUBLE): Remove documentation.
testsuite/
	* gdb.base/callfuncs.exp: Don't XFAIL unprototyped functions for
	stabs.
	* gdb.base/completion.exp: Allow marker1(void) as well as marker1().
	* gdb.base/whatis.exp: Always allow (void) after function names.
@
text
@a131 2

    enum gdb_osabi osabi;
a5607 1
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
a5621 4

      /* Try to determine the OS ABI of the object we are loading.  If
	 we end up with `unknown', just leave it that way.  */
      osabi = gdbarch_lookup_osabi (info.abfd);
d5718 1
a5718 2
      if (gdbarch_tdep (arches->gdbarch)->osabi == osabi)
        return arches->gdbarch;
a5724 1
  tdep->osabi = osabi;
d5741 1
a5741 1
  if (osabi == GDB_OSABI_IRIX)
d6021 1
a6021 1
  gdbarch_init_osabi (info, gdbarch, osabi);
a6425 4

  fprintf_unfiltered (file,
		      "mips_dump_tdep: OS ABI = %s\n",
		      gdbarch_osabi_name (tdep->osabi));
@


1.151
log
@2003-01-03  Andrew Cagney  <ac131313@@redhat.com>

	* alpha-tdep.c: Use get_frame_saved_regs.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
a5455 18
/* If the current gcc for this target does not produce correct debugging
   information for float parameters, both prototyped and unprototyped, then
   define this macro.  This forces gdb to  always assume that floats are
   passed as doubles and then converted in the callee.

   For the mips chip, it appears that the debug info marks the parameters as
   floats regardless of whether the function is prototyped, but the actual
   values are passed as doubles for the non-prototyped case and floats for
   the prototyped case.  Thus we choose to make the non-prototyped case work
   for C and break the prototyped case, since the non-prototyped case is
   probably much more common.  (FIXME). */

static int
mips_coerce_float_to_double (struct type *formal, struct type *actual)
{
  return current_language->la_language == language_c;
}

a5996 2

  set_gdbarch_coerce_float_to_double (gdbarch, mips_coerce_float_to_double);
@


1.150
log
@2003-01-03  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use deprecated_update_frame_base_hack.
	* avr-tdep.c, cris-tdep.c: Ditto.
	* mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
@
text
@d1427 1
a1427 1
	  fci->saved_regs[ireg] = reg_position;
d1433 1
a1433 1
	  fci->saved_regs[FP0_REGNUM + ireg] = reg_position;
d1435 1
a1435 1
      fci->saved_regs[PC_REGNUM] = fci->frame + SIGFRAME_PC_OFF;
d1505 1
a1505 1
	fci->saved_regs[ireg] = reg_position;
d1529 1
a1529 1
	      fci->saved_regs[reg] = reg_position;
d1560 1
a1560 1
	fci->saved_regs[FP0_REGNUM + ireg] = reg_position;
d1564 1
a1564 1
  fci->saved_regs[PC_REGNUM] = fci->saved_regs[RA_REGNUM];
d1577 1
a1577 1
  if (frame->saved_regs == NULL)
d1581 1
a1581 1
  frame->saved_regs[SP_REGNUM] = frame->frame;
d2515 3
a2517 3
	      memcpy (fci->saved_regs, temp_saved_regs, SIZEOF_FRAME_SAVED_REGS);
	      fci->saved_regs[PC_REGNUM]
		= fci->saved_regs[RA_REGNUM];
d2523 1
a2523 1
	      fci->saved_regs[SP_REGNUM] = fci->frame;
d3826 1
a3826 1
  if (frame->saved_regs == NULL)
d3830 1
a3830 1
	&& frame->saved_regs[regnum])
d3837 1
a3837 1
			  read_memory_unsigned_integer (frame->saved_regs[regnum],
d3841 1
a3841 1
			  read_memory_integer (frame->saved_regs[regnum],
@


1.149
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c: Use get_frame_pc and deprecated_update_frame_pc_hack
	frame accessor methods.
	* alpha-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Ditto.
	* s390-tdep.c, sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* z8k-tdep.c: Ditto.
@
text
@d2487 1
a2487 1
	fci->frame = read_next_frame_reg (fci->next, SP_REGNUM);
d2497 1
a2497 1
	fci->frame = get_frame_pointer (fci->next, proc_desc);
@


1.148
log
@Fix bug introduced when multiarching NUM_REGS.
@
text
@d1462 1
a1462 1
       && in_prologue (fci->pc, PROC_LOW_ADDR (proc_desc))
d1486 1
a1486 1
      while (addr < fci->pc)
d1702 1
a1702 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, 0, 0))
d2458 1
a2458 1
      && !(DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, 0, 0)))
d2471 1
a2471 1
    fci->next ? cached_proc_desc : find_proc_desc (fci->pc, fci->next, 1);
d2485 1
a2485 1
      if (fci->pc == PROC_LOW_ADDR (proc_desc)
d2488 1
a2488 1
      else if (DEPRECATED_PC_IN_CALL_DUMMY (fci->pc, 0, 0))
d2510 1
a2510 1
	  find_pc_partial_function (fci->pc, &name,
d2512 1
a2512 1
	  if (!PC_IN_SIGTRAMP (fci->pc, name))
d3818 1
a3818 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, 0, 0))
@


1.147
log
@Multiarch NUM_REGS for MIPS.
@
text
@d2145 1
a2145 1
  memset (&temp_saved_regs, '\0', SIZEOF_FRAME_SAVED_REGS);
@


1.146
log
@2002-12-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
	Change to a function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Update.  Test
	DEPRECATED_INIT_FRAME_PC_P.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/mn10200/tm-mn10200.h (DEPRECATED_INIT_FRAME_PC): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* arm-tdep.c: Update comments.
	* h8300-tdep.c (h8300_gdbarch_init): Explicitly set init_frame_pc.
	* config/m32r/tm-m32r.h (DEPRECATED_INIT_FRAME_PC): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC_FIRST): Delete macro.
	(DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
@
text
@d1717 7
a1723 1
static CORE_ADDR temp_saved_regs[NUM_REGS];
d2035 1
d2144 1
d5767 5
@


1.145
log
@2002-12-08  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (INIT_FRAME_PC_FIRST, INIT_FRAME_PC_DEFAULT): Convert
	to pure functions.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Explictly assign prev's pc with value
	returned by INIT_FRAME_PC_FIRST and INIT_EXTRA_FRAME_INFO.

	* arch-utils.h (init_frame_pc_default, init_frame_pc_noop): Change
	declaration to a function returning a CORE_ADDR.
	* x86-64-tdep.h (x86_64_init_frame_pc): Ditto.
	* arch-utils.c (init_frame_pc_noop): Return the PC value.
	(init_frame_pc_default): Ditto.
	* x86-64-linux-tdep.c (x86_64_init_frame_pc): Ditto.
	* s390-tdep.c (s390_init_frame_pc_first): Ditto.
	* mips-tdep.c (mips_init_frame_pc_first): Ditto.
	* dwarf2cfi.h (cfi_init_frame_pc): Ditto.
	* dwarf2cfi.c (cfi_init_frame_pc): Ditto.
	* alpha-tdep.c (alpha_init_frame_pc_first): Ditto.

	* i386-interix-tdep.c (i386_interix_init_abi): Set init_frame_pc
	to init_frame_pc_noop.
	(i386_interix_init_frame_pc): Delete function.
	* z8k-tdep.c (init_frame_pc): Delete function.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC): Define as init_frame_pc_noop.
	(INIT_FRAME_PC_FIRST): Ditto.
	* config/mn10200/tm-mn10200.h (INIT_FRAME_PC): Ditto.
	(INIT_FRAME_PC_FIRST): Ditto.
	* config/sparc/tm-sparc.h (INIT_FRAME_PC): Ditto.
	* config/rs6000/tm-rs6000.h (INIT_FRAME_PC): Redefine as
	init_frame_pc_noop.
	(INIT_FRAME_PC_FIRST): Convert to an expression.
	* config/sparc/tm-sparc.h (INIT_FRAME_PC_FIRST): Ditto.
@
text
@d5969 1
a5969 1
  set_gdbarch_init_frame_pc (gdbarch, init_frame_pc_noop);
@


1.144
log
@2002-12-06  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC_FIRST): Rename
	INIT_FRAME_PC_FIRST.  Change to a function with predicate.  Do not
	provide a default value.
	* gdbarch.h, gdbarch.c: Regenerate.
	* frame.c (get_prev_frame): Update.  Check
	DEPRECATED_INIT_FRAME_PC_FIRST_P.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d1680 1
a1680 1
static void
d1688 1
a1688 1
  prev->pc = tmp ? tmp : pc;
@


1.143
log
@Create new file mips-tdep.h.
@
text
@d5967 2
a5968 2
     blockframe.c near reference to INIT_FRAME_PC_FIRST.  */
  set_gdbarch_init_frame_pc_first (gdbarch, mips_init_frame_pc_first);
@


1.142
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d42 1
a60 13
/* All the possible MIPS ABIs. */

enum mips_abi
  {
    MIPS_ABI_UNKNOWN = 0,
    MIPS_ABI_N32,
    MIPS_ABI_O32,
    MIPS_ABI_N64,
    MIPS_ABI_O64,
    MIPS_ABI_EABI32,
    MIPS_ABI_EABI64,
    MIPS_ABI_LAST
  };
d152 7
@


1.141
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d1707 1
a1707 1
  if (PC_IN_CALL_DUMMY (frame->pc, 0, 0))
d2190 1
a2190 1
  if (PC_IN_CALL_DUMMY (pc, 0, 0))
d2430 1
a2430 1
  if (PC_IN_CALL_DUMMY (saved_pc, 0, 0))
d2455 1
a2455 1
      && !(PC_IN_CALL_DUMMY (frame->pc, 0, 0)))
d2485 1
a2485 1
      else if (PC_IN_CALL_DUMMY (fci->pc, 0, 0))
d3815 1
a3815 1
  if (PC_IN_CALL_DUMMY (frame->pc, 0, 0))
@


1.140
log
@2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_USE_GENERIC_DUMMY_FRAMES): Rename
	USE_GENERIC_DUMMY_FRAMES.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c, frame.c: Update.
	* config/z8k/tm-z8k.h, config/mn10200/tm-mn10200.h: Update.
	* config/m32r/tm-m32r.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, blockframe.c: Update.
	* vax-tdep.c, sparc-tdep.c, ns32k-tdep.c: Ditto.
	* m68k-tdep.c, alpha-tdep.c: Ditto.

	* arm-tdep.c: Eliminate USE_GENERIC_DUMMY_FRAMES as always 1.
	* mips-tdep.c: Ditto.

Index: doc/ChangeLog
2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Host Definition): Delete documentation on
	USE_GENERIC_DUMMY_FRAMES.
@
text
@d3944 1
a3944 1
  if (!frame_register_read (selected_frame, regno, raw_buffer))
d3978 1
a3978 1
      if (!frame_register_read (selected_frame, regno, rare_buffer))
d4009 1
a4009 1
  if (!frame_register_read (selected_frame, regnum, raw_buffer))
d4189 1
a4189 1
      if (!frame_register_read (selected_frame, regnum, raw_buffer))
@


1.139
log
@2002-11-27  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_LOCATION): Default to AT_ENTRY_POINT.
	(USE_GENERIC_DUMMY_FRAMES): Default to true.
	(PC_IN_CALL_DUMMY): Default to generic_pc_in_call_dummy.
	* gdbarch.c, gdbarch.h: Re-generate.
	* inferior.h (USE_GENERIC_DUMMY_FRAMES): Delete macro definition.
	(CALL_DUMMY_LOCATION): Delete macro definition.
	(PC_IN_CALL_DUMMY): Delete macro definitions.

	* arm-tdep.c (arm_gdbarch_init): Do not set pc_in_call_dummy,
	default is already generic_pc_in_call_dummy.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* arm-tdep.c (arm_gdbarch_init): Do not set
	use_generic_dummy_frames, default is already 1.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_location, default is already AT_ENTRY_POINT.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d1707 1
a1707 2
  if (USE_GENERIC_DUMMY_FRAMES
      && PC_IN_CALL_DUMMY (frame->pc, 0, 0))
d2430 1
a2430 2
  if (USE_GENERIC_DUMMY_FRAMES
      && PC_IN_CALL_DUMMY (saved_pc, 0, 0))
d2455 1
a2455 2
      && !(USE_GENERIC_DUMMY_FRAMES
	   && PC_IN_CALL_DUMMY (frame->pc, 0, 0)))
d2485 1
a2485 2
      else if (USE_GENERIC_DUMMY_FRAMES
	       && PC_IN_CALL_DUMMY (fci->pc, 0, 0))
d3815 1
a3815 2
  if (USE_GENERIC_DUMMY_FRAMES
      && PC_IN_CALL_DUMMY (frame->pc, 0, 0))
@


1.138
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@a5992 2
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
a6001 1
  set_gdbarch_pc_in_call_dummy (gdbarch, generic_pc_in_call_dummy);
@


1.137
log
@2002-11-23  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c (arm_gdbarch_init): Remove old style non-generic
	dummy frame initialization code.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
@
text
@d3816 1
a3816 1
  CORE_ADDR new_sp = FRAME_FP (frame);
@


1.136
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_ADDRESS, FRAME_LOCALS_ADDRESS): Default
	to default_frame_address.
	* gdbarch.h, gdbarch.c: Re-generate.

	* d10v-tdep.c (d10v_gdbarch_init): Do not set frame_args_address
	or frame_locals_address to default_frame_address.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.

	* cris-tdep.c (cris_frame_args_address): Delete function.
	(cris_frame_locals_address): Delete function.
	(cris_gdbarch_init): Do not set frame_args_address or
	frame_locals_address.
@
text
@a5992 3
#if OLD_STYLE_MIPS_DUMMY_FRAMES
  set_gdbarch_use_generic_dummy_frames (gdbarch, 0);
#else
a5993 1
#endif
a5996 3
#if OLD_STYLE_MIPS_DUMMY_FRAMES
  set_gdbarch_push_dummy_frame (gdbarch, mips_push_dummy_frame);
#else
a5997 1
#endif
a6003 3
#if OLD_STYLE_MIPS_DUMMY_FRAMES
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_at_entry_point);
#else
a6004 1
#endif
a6008 2
#if OLD_STYLE_MIPS_DUMMY_FRAMES
#else
a6009 1
#endif
@


1.135
log
@2002-11-21  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_dump_tdep): Delete references to
	GDB_TARGET_UNMASK_DISAS_PC and GDB_TARGET_MASK_DISAS_PC.
	* config/mips/tm-mips.h (GDB_TARGET_MASK_DISAS_PC): Delete macro.
	(GDB_TARGET_UNMASK_DISAS_PC): Delete macro.
	* printcmd.c (build_address_symbolic): Delete calls to
	GDB_TARGET_UNMASK_DISAS_PC and GDB_TARGET_MASK_DISAS_PC.
	(address_info): Ditto.
	Fix PR gdb/773.
@
text
@a6037 2
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);
@


1.134
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (enum frame_type): Define.
	(get_frame_type): Declare.
	(struct frame_info): Add field `type'.  Delete field
	signal_handler_caller.
	(deprecated_set_frame_signal_handler_caller): Declare.
	* frame.c (get_frame_type): New function.
	(deprecated_set_frame_type): New function.
	(create_new_frame): Set the frame's type.
	(get_prev_frame): Similar.
	* sparc-tdep.c: Use get_frame_type instead of signal_handler_caller.
	* s390-tdep.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* x86-64-linux-tdep.c: Ditto.
	* vax-tdep.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* i386-interix-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* m68k-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* cris-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* i386-tdep.c: Ditto.
	* stack.c: Ditto.
	* ada-lang.c: Ditto.
	* blockframe.c: Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Use
	deprecated_set_frame_type instead of signal_handler_caller.
	* ppc-linux-tdep.c (ppc_linux_init_extra_frame_info): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	* breakpoint.h: Delete FIXME suggesting get_frame_type.

Index: tui/ChangeLog
2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	signal_handler_caller.
@
text
@a6217 6
		      "mips_dump_tdep: GDB_TARGET_MASK_DISAS_PC # %s\n",
		      XSTRING (GDB_TARGET_MASK_DISAS_PC (PC)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: GDB_TARGET_UNMASK_DISAS_PC # %s\n",
		      XSTRING (GDB_TARGET_UNMASK_DISAS_PC (PC)));
  fprintf_unfiltered (file,
@


1.133
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@d1426 1
a1426 1
  if (fci->signal_handler_caller)
d1459 1
a1459 1
       (fci->next == NULL || fci->next->signal_handler_caller)
d1704 1
a1704 1
  int pcreg = frame->signal_handler_caller ? PC_REGNUM
d2454 1
a2454 1
      && !frame->signal_handler_caller
d2505 6
a2510 2
	     mips_find_saved_registers will do that for us.
	     We can't use fci->signal_handler_caller, it is not yet set.  */
@


1.132
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d4669 2
a4670 3
  write_register_bytes (REGISTER_BYTE (lo.reg),
			raw_buffer,
			REGISTER_RAW_SIZE (lo.reg));
d4676 2
a4677 3
      write_register_bytes (REGISTER_BYTE (hi.reg),
			    raw_buffer,
			    REGISTER_RAW_SIZE (hi.reg));
d4691 2
a4692 3
  write_register_bytes (REGISTER_BYTE (lo.reg),
			raw_buffer,
			REGISTER_RAW_SIZE (lo.reg));
d4698 2
a4699 3
      write_register_bytes (REGISTER_BYTE (hi.reg),
			    raw_buffer,
			    REGISTER_RAW_SIZE (hi.reg));
@


1.131
log
@2002-10-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	definition of DO_REGISTERS_INFO.

2002-10-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_DO_REGISTERS_INFO): Rename
	DO_REGISTERS_INFO.
	gdbarch.h, gdbarch.c: Re-generate.
	* infcmd.c (default_print_registers_info): Update reference.
	* mips-tdep.c (mips_gdbarch_init): Set deprecated_do_registers_info.
	(mips_dump_tdep): Do not print DO_REGISTERS_INFO.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
@
text
@d3721 1
a3721 1
  read_register_gen (regno, buffer);
@


1.130
log
@        * c-exp.y (THIS): Delete token and grammar rule.
        (yylex): Don't return THIS.
        * cp-valprint.c (vtbl_ptr_name_old): Delete.
        (cp_is_vtbl_ptr_type): Don't check vtbl_ptr_name_old.
        * demangle.c (cplus_markers): Update comment.  Put '$'
        first.  Remove CPLUS_MARKER.
        (_initialize_demangler): Don't call set_cplus_marker_for_demangling.
        * jv-exp.y (THIS): Delete token and grammar rule.
        (yylex): Don't return THIS.
        * mips-tdep.c (mips_dump_tdep): Don't dump CPLUS_MARKER.
        * objc-exp.y (THIS): Delete token and grammar rule.
        (yylex): Don't return THIS.
        * p-exp.y (yylex): Remove reference to CPLUS_MARKER.
        * stabsread.c (vptr_name, vb_name): Replace CPLUS_MARKER with '$'.
        (read_member_functions): Likewise for opname.
        (read_tilde_fields): Use is_cplus_marker.

        * defs.h (CPLUS_MARKER): Don't define.
        * config/tm-sysv4.h (CPLUS_MARKER): Likewise.
        * config/i386/xm-i386sco.h (CPLUS_MARKER): Likewise.
        * config/mips/tm-irix3.h (CPLUS_MARKER): Likewise.
        * config/mips/tm-irix6.h (CPLUS_MARKER): Likewise.
        * config/rs6000/tm-rs6000.h (CPLUS_MARKER): Likewise.

        * config/i386/tm-i386v4.h: Delete file.
        * config/djgpp/fnchange.lst: Delete tm-i386v4.h.
        * config/i386/tm-i386sol2.h: Include "i386/tm-i386.h" instead.
        * config/i386/tm-i386v42mp.h: Include "i386/tm-i386.h" instead.
        * config/i386/tm-ptx.h: Include "i386/tm-i386.h" instead.
        * config/i386/i386gnu.mt (TM_FILE): Use tm-i386.h.
        * config/i386/i386sco5.mt (TM_FILE): Likewise.
        * config/i386/i386v4.mt (TM_FILE): Likewise.
        * config/i386/ncr3000.mt (TM_FILE): Likewise.
@
text
@d6063 1
a6063 1
  set_gdbarch_do_registers_info (gdbarch, mips_do_registers_info);
a6195 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: DO_REGISTERS_INFO # %s\n",
		      XSTRING (DO_REGISTERS_INFO));
@


1.129
log
@* mips-tdep.c (mips_find_abi_section): .mdebug.abi64 is the name
of the section for the N64 ABI, fixed.
@
text
@a6196 3
		      "mips_dump_tdep: CPLUS_MARKER = %c\n",
		      CPLUS_MARKER);
  fprintf_unfiltered (file,
@


1.129.2.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d6197 3
@


1.129.2.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a27 1
#include "gdb_assert.h"
d42 1
a42 3
#include "mips-tdep.h"
#include "block.h"
#include "reggroups.h"
a46 5
#include "sim-regno.h"
#include "dis-asm.h"

static void set_reg_offset (CORE_ADDR *saved_regs, int regnum, CORE_ADDR off);
static struct type *mips_register_type (struct gdbarch *gdbarch, int regnum);
d60 13
d142 1
d144 2
a145 9
    /* Is the target using 64-bit raw integer registers but only
       storing a left-aligned 32-bit value in each?  */
    int mips64_transfers_32bit_regs_p;
    /* Indexes for various registers.  IRIX and embedded have
       different values.  This contains the "public" fields.  Don't
       add any that do not need to be public.  */
    const struct mips_regnum *regnum;
    /* Register names table for the current register set.  */
    const char **mips_processor_reg_names;
a147 12
const struct mips_regnum *
mips_regnum (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->regnum;
}

static int
mips_fpa0_regnum (struct gdbarch *gdbarch)
{
  return mips_regnum (gdbarch)->fp0 + 12;
}

a164 65
/* MIPS16 function addresses are odd (bit 0 is set).  Here are some
   functions to test, set, or clear bit 0 of addresses.  */

static CORE_ADDR
is_mips16_addr (CORE_ADDR addr)
{
  return ((addr) & 1);
}

static CORE_ADDR
make_mips16_addr (CORE_ADDR addr)
{
  return ((addr) | 1);
}

static CORE_ADDR
unmake_mips16_addr (CORE_ADDR addr)
{
  return ((addr) & ~1);
}

/* Return the contents of register REGNUM as a signed integer.  */

static LONGEST
read_signed_register (int regnum)
{
  void *buf = alloca (register_size (current_gdbarch, regnum));
  deprecated_read_register_gen (regnum, buf);
  return (extract_signed_integer (buf, register_size (current_gdbarch, regnum)));
}

static LONGEST
read_signed_register_pid (int regnum, ptid_t ptid)
{
  ptid_t save_ptid;
  LONGEST retval;

  if (ptid_equal (ptid, inferior_ptid))
    return read_signed_register (regnum);

  save_ptid = inferior_ptid;

  inferior_ptid = ptid;

  retval = read_signed_register (regnum);

  inferior_ptid = save_ptid;

  return retval;
}

/* Return the MIPS ABI associated with GDBARCH.  */
enum mips_abi
mips_abi (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->mips_abi;
}

int
mips_regsize (struct gdbarch *gdbarch)
{
  return (gdbarch_bfd_arch_info (gdbarch)->bits_per_word
	  / gdbarch_bfd_arch_info (gdbarch)->bits_per_byte);
}

d178 3
a180 1
   "info" field is used for this purpose.
d186 3
a188 1
   MSYMBOL_IS_SPECIAL   tests the "special" bit in a minimal symbol  */
d207 6
d223 1
a223 1
  bfd_byte reg[MAX_REGISTER_SIZE];
a224 1
  gdb_assert (reg_num >= NUM_REGS);
d230 1
a230 1
      reg_offset = register_size (current_gdbarch, reg_num) - length;
d253 1
a253 1
    regcache_cooked_read_part (regcache, reg_num, reg_offset, length, in + buf_offset);
d255 1
a255 1
    regcache_cooked_write_part (regcache, reg_num, reg_offset, length, out + buf_offset);
d276 1
a276 1
  if (register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0) == 4)
d294 3
a296 1
   form double-precision values).  See also MIPS_FPU_TYPE.  */
d320 2
d326 6
a331 2
static mips_extra_func_info_t heuristic_proc_desc (CORE_ADDR, CORE_ADDR,
						   struct frame_info *, int);
d337 4
d343 2
a344 3
static mips_extra_func_info_t find_proc_desc (CORE_ADDR pc,
					      struct frame_info *next_frame,
					      int cur_frame);
d349 3
d355 7
d367 5
a371 18
/* Integer registers 0 thru 31 are handled explicitly by
   mips_register_name().  Processor specific registers 32 and above
   are listed in the followign tables.  */

enum { NUM_MIPS_PROCESSOR_REGS = (90 - 32) };

/* Generic MIPS.  */

static const char *mips_generic_reg_names[NUM_MIPS_PROCESSOR_REGS] = {
  "sr",	"lo",	"hi",	"bad",	"cause","pc",
  "f0",   "f1",   "f2",   "f3",   "f4",   "f5",   "f6",   "f7",
  "f8",   "f9",   "f10",  "f11",  "f12",  "f13",  "f14",  "f15",
  "f16",  "f17",  "f18",  "f19",  "f20",  "f21",  "f22",  "f23",
  "f24",  "f25",  "f26",  "f27",  "f28",  "f29",  "f30",  "f31",
  "fsr",  "fir",  ""/*"fp"*/,	"",
  "",	"",	"",	"",	"",	"",	"",	"",
  "",	"",	"",	"",	"",	"",	"",	"",
};
d373 6
d381 13
a393 9
static const char *mips_r3041_reg_names[] = {
  "sr",	"lo",	"hi",	"bad",	"cause","pc",
  "f0",   "f1",   "f2",   "f3",   "f4",   "f5",   "f6",   "f7",
  "f8",   "f9",   "f10",  "f11",  "f12",  "f13",  "f14",  "f15",
  "f16",  "f17",  "f18",  "f19",  "f20",  "f21",  "f22",  "f23",
  "f24",  "f25",  "f26",  "f27",  "f28",  "f29",  "f30",  "f31",
  "fsr",  "fir",  "",/*"fp"*/	"",
  "",	"",	"bus",	"ccfg",	"",	"",	"",	"",
  "",	"",	"port",	"cmp",	"",	"",	"epc",	"prid",
d396 1
a396 1
/* Names of tx39 registers.  */
d398 13
a410 9
static const char *mips_tx39_reg_names[NUM_MIPS_PROCESSOR_REGS] = {
  "sr",	"lo",	"hi",	"bad",	"cause","pc",
  "",   "",   	"",   	"",   	"",   	"",   	"",   	"",
  "",   "",   	"",  	"",  	"",  	"",  	"",  	"",
  "",  	"",  	"",  	"",  	"",  	"",  	"",  	"",
  "",  	"",  	"",  	"",  	"",  	"",  	"",  	"",
  "",  	"",  	"",	"",
  "",	"",	"",	"",	"",	"",	"",	"",
  "",	"", "config", "cache", "debug", "depc", "epc",	""
d413 15
a427 7
/* Names of IRIX registers.  */
static const char *mips_irix_reg_names[NUM_MIPS_PROCESSOR_REGS] = {
  "f0",   "f1",   "f2",   "f3",   "f4",   "f5",   "f6",   "f7",
  "f8",   "f9",   "f10",  "f11",  "f12",  "f13",  "f14",  "f15",
  "f16",  "f17",  "f18",  "f19",  "f20",  "f21",  "f22",  "f23",
  "f24",  "f25",  "f26",  "f27",  "f28",  "f29",  "f30",  "f31",
  "pc",	"cause", "bad",	"hi",	"lo",	"fsr",  "fir"
d430 1
d432 14
a445 12
/* Return the name of the register corresponding to REGNO.  */
static const char *
mips_register_name (int regno)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  /* GPR names for all ABIs other than n32/n64.  */
  static char *mips_gpr_names[] = {
    "zero", "at",   "v0",   "v1",   "a0",   "a1",   "a2",   "a3",
    "t0",   "t1",   "t2",   "t3",   "t4",   "t5",   "t6",   "t7",
    "s0",   "s1",   "s2",   "s3",   "s4",   "s5",   "s6",   "s7",
    "t8",   "t9",   "k0",   "k1",   "gp",   "sp",   "s8",   "ra",
  };
d447 13
a459 35
  /* GPR names for n32 and n64 ABIs.  */
  static char *mips_n32_n64_gpr_names[] = {
    "zero", "at",   "v0",   "v1",   "a0",   "a1",   "a2",   "a3", 
    "a4",   "a5",   "a6",   "a7",   "t0",   "t1",   "t2",   "t3", 
    "s0",   "s1",   "s2",   "s3",   "s4",   "s5",   "s6",   "s7", 
    "t8",   "t9",   "k0",   "k1",   "gp",   "sp",   "s8",   "ra"
  };

  enum mips_abi abi = mips_abi (current_gdbarch);

  /* Map [NUM_REGS .. 2*NUM_REGS) onto the raw registers, but then
     don't make the raw register names visible.  */
  int rawnum = regno % NUM_REGS;
  if (regno < NUM_REGS)
    return "";

  /* The MIPS integer registers are always mapped from 0 to 31.  The
     names of the registers (which reflects the conventions regarding
     register use) vary depending on the ABI.  */
  if (0 <= rawnum && rawnum < 32)
    {
      if (abi == MIPS_ABI_N32 || abi == MIPS_ABI_N64)
	return mips_n32_n64_gpr_names[rawnum];
      else
	return mips_gpr_names[rawnum];
    }
  else if (32 <= rawnum && rawnum < NUM_REGS)
    {
      gdb_assert (rawnum - 32 < NUM_MIPS_PROCESSOR_REGS);
      return tdep->mips_processor_reg_names[rawnum - 32];
    }
  else
    internal_error (__FILE__, __LINE__,
		    "mips_register_name: bad register number %d", rawnum);
}
a460 1
/* Return the groups that a MIPS register can be categorised into.  */
a461 59
static int
mips_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			  struct reggroup *reggroup)
{
  int vector_p;
  int float_p;
  int raw_p;
  int rawnum = regnum % NUM_REGS;
  int pseudo = regnum / NUM_REGS;
  if (reggroup == all_reggroup)
    return pseudo;
  vector_p = TYPE_VECTOR (register_type (gdbarch, regnum));
  float_p = TYPE_CODE (register_type (gdbarch, regnum)) == TYPE_CODE_FLT;
  /* FIXME: cagney/2003-04-13: Can't yet use gdbarch_num_regs
     (gdbarch), as not all architectures are multi-arch.  */
  raw_p = rawnum < NUM_REGS;
  if (REGISTER_NAME (regnum) == NULL
      || REGISTER_NAME (regnum)[0] == '\0')
    return 0;
  if (reggroup == float_reggroup)
    return float_p && pseudo;
  if (reggroup == vector_reggroup)
    return vector_p && pseudo;
  if (reggroup == general_reggroup)
    return (!vector_p && !float_p) && pseudo;
  /* Save the pseudo registers.  Need to make certain that any code
     extracting register values from a saved register cache also uses
     pseudo registers.  */
  if (reggroup == save_reggroup)
    return raw_p && pseudo;
  /* Restore the same pseudo register.  */
  if (reggroup == restore_reggroup)
    return raw_p && pseudo;
  return 0;   
}

/* Map the symbol table registers which live in the range [1 *
   NUM_REGS .. 2 * NUM_REGS) back onto the corresponding raw
   registers.  Take care of alignment and size problems.  */

static void
mips_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int cookednum, void *buf)
{
  int rawnum = cookednum % NUM_REGS;
  gdb_assert (cookednum >= NUM_REGS && cookednum < 2 * NUM_REGS);
  if (register_size (gdbarch, rawnum) == register_size (gdbarch, cookednum))
    return regcache_raw_read (regcache, rawnum, buf);
  else if (register_size (gdbarch, rawnum) > register_size (gdbarch, cookednum))
    {
      if (gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p
	  || TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
	regcache_raw_read_part (regcache, rawnum, 0, 4, buf);
      else
	regcache_raw_read_part (regcache, rawnum, 4, 4, buf);
    }
  else
    internal_error (__FILE__, __LINE__, "bad register size");
}
a462 19
static void
mips_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int cookednum, const void *buf)
{
  int rawnum = cookednum % NUM_REGS;
  gdb_assert (cookednum >= NUM_REGS && cookednum < 2 * NUM_REGS);
  if (register_size (gdbarch, rawnum) == register_size (gdbarch, cookednum))
    return regcache_raw_write (regcache, rawnum, buf);
  else if (register_size (gdbarch, rawnum) > register_size (gdbarch, cookednum))
    {
      if (gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p
	  || TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
	regcache_raw_write_part (regcache, rawnum, 0, 4, buf);
      else
	regcache_raw_write_part (regcache, rawnum, 4, 4, buf);
    }
  else
    internal_error (__FILE__, __LINE__, "bad register size");
}
d498 12
d511 2
a512 2
   register N.  NOTE: This defines the pseudo register type so need to
   rebuild the architecture vector.  */
d516 2
a517 3
static void
set_mips64_transfers_32bit_regs (char *args, int from_tty,
				 struct cmd_list_element *c)
d519 9
a527 10
  struct gdbarch_info info;
  gdbarch_info_init (&info);
  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
     instead of relying on globals.  Doing that would let generic code
     handle the search for this specific architecture.  */
  if (!gdbarch_update_p (info))
    {
      mips64_transfers_32bit_regs_p = 0;
      error ("32-bit compatibility mode not supported");
    }
d530 2
a531 1
/* Convert to/from a register and the corresponding memory value.  */
d534 1
a534 1
mips_convert_register_p (int regnum, struct type *type)
d536 4
a539 5
  return (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && register_size (current_gdbarch, regnum) == 4
	  && (regnum) >= mips_regnum (current_gdbarch)->fp0 && (regnum) < mips_regnum (current_gdbarch)->fp0 + 32
	  && TYPE_CODE(type) == TYPE_CODE_FLT
	  && TYPE_LENGTH(type) == 8);
d543 2
a544 2
mips_register_to_value (struct frame_info *frame, int regnum,
			struct type *type, void *to)
d546 8
a553 2
  get_frame_register (frame, regnum + 0, (char *) to + 4);
  get_frame_register (frame, regnum + 1, (char *) to + 0);
d557 16
a572 2
mips_value_to_register (struct frame_info *frame, int regnum,
			struct type *type, const void *from)
d574 27
a600 2
  put_frame_register (frame, regnum + 0, (const char *) from + 4);
  put_frame_register (frame, regnum + 1, (const char *) from + 0);
d603 9
a611 2
/* Return the GDB type object for the "standard" data type of data in
   register REG.  */
d614 1
a614 1
mips_register_type (struct gdbarch *gdbarch, int regnum)
d616 7
a622 22
  gdb_assert (regnum >= 0 && regnum < 2 * NUM_REGS);
  if ((regnum % NUM_REGS) >= mips_regnum (current_gdbarch)->fp0
      && (regnum % NUM_REGS) < mips_regnum (current_gdbarch)->fp0 + 32)
    {
      /* The floating-point registers raw, or cooked, always match
         mips_regsize(), and also map 1:1, byte for byte.  */
      switch (gdbarch_byte_order (gdbarch))
	{
	case BFD_ENDIAN_BIG:
	  if (mips_regsize (gdbarch) == 4)
	    return builtin_type_ieee_single_big;
	  else
	    return builtin_type_ieee_double_big;
	case BFD_ENDIAN_LITTLE:
	  if (mips_regsize (gdbarch) == 4)
	    return builtin_type_ieee_single_little;
	  else
	    return builtin_type_ieee_double_little;
	case BFD_ENDIAN_UNKNOWN:
	default:
	  internal_error (__FILE__, __LINE__, "bad switch");
	}
d624 4
a627 14
  else if (regnum >= (NUM_REGS + mips_regnum (current_gdbarch)->fp_control_status)
	   && regnum <= NUM_REGS + LAST_EMBED_REGNUM)
    /* The pseudo/cooked view of the embedded registers is always
       32-bit.  The raw view is handled below.  */
    return builtin_type_int32;
  else if (regnum >= NUM_REGS && mips_regsize (gdbarch)
	   && gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p)
    /* The target, while using a 64-bit register buffer, is only
       transfering 32-bits of each integer register.  Reflect this in
       the cooked/pseudo register value.  */
    return builtin_type_int32;
  else if (mips_regsize (gdbarch) == 8)
    /* 64-bit ISA.  */
    return builtin_type_int64;
d629 8
a636 2
    /* 32-bit ISA.  */
    return builtin_type_int32;
d644 1
a644 1
  return read_signed_register (SP_REGNUM);
d699 12
d747 1
a747 1
  if (is_mips16_addr (memaddr))
d880 1
a880 1
      addr = unmake_mips16_addr (addr);
d954 1
a954 1
	  int fcrcs = read_signed_register (mips_regnum (current_gdbarch)->fp_control_status);
d1383 10
a1392 7
/* Set up the 'saved_regs' array.  This is a data structure containing
   the addresses on the stack where each register has been saved, for
   each stack frame.  Registers that have not been saved will have
   zero here.  The stack pointer register is special: rather than the
   address where the stack register has been saved,
   saved_regs[SP_REGNUM] will have the actual value of the previous
   frame's stack register.  */
d1398 1
a1404 1
  CORE_ADDR *saved_regs;
d1406 1
a1406 3
  if (deprecated_get_frame_saved_regs (fci) != NULL)
    return;
  saved_regs = frame_saved_regs_zalloc (fci);
d1409 3
a1411 3
     in a sigcontext structure somewhere on the stack.  If the stack
     layout for sigtramp changes we might have to change these
     constants and the companion fixup_sigtramp in mdebugread.c */
d1413 3
a1415 3
  /* To satisfy alignment restrictions, sigcontext is located 4 bytes
     above the sigtramp frame.  */
#define SIGFRAME_BASE		mips_regsize (current_gdbarch)
d1417 2
a1418 2
#define SIGFRAME_PC_OFF		(SIGFRAME_BASE + 2 * mips_regsize (current_gdbarch))
#define SIGFRAME_REGSAVE_OFF	(SIGFRAME_BASE + 3 * mips_regsize (current_gdbarch))
d1420 5
a1424 1
        (SIGFRAME_REGSAVE_OFF + MIPS_NUMREGS * mips_regsize (current_gdbarch) + 3 * mips_regsize (current_gdbarch))
d1426 1
a1426 1
  if ((get_frame_type (fci) == SIGTRAMP_FRAME))
d1430 3
a1432 3
	  CORE_ADDR reg_position = (get_frame_base (fci) + SIGFRAME_REGSAVE_OFF
				    + ireg * mips_regsize (current_gdbarch));
	  set_reg_offset (saved_regs, ireg, reg_position);
d1436 3
a1438 4
	  CORE_ADDR reg_position = (get_frame_base (fci)
				    + SIGFRAME_FPREGSAVE_OFF
				    + ireg * mips_regsize (current_gdbarch));
	  set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->fp0 + ireg, reg_position);
d1440 1
a1440 4

      set_reg_offset (saved_regs, PC_REGNUM, get_frame_base (fci) + SIGFRAME_PC_OFF);
      /* SP_REGNUM, contains the value and not the address.  */
      set_reg_offset (saved_regs, SP_REGNUM, get_frame_base (fci));
d1444 1
a1444 1
  proc_desc = get_frame_extra_info (fci)->proc_desc;
d1446 3
a1448 3
    /* I'm not sure how/whether this can happen.  Normally when we
       can't find a proc_desc, we "synthesize" one using
       heuristic_proc_desc and set the saved_regs right away.  */
d1455 5
a1459 6
  if (/* In any frame other than the innermost or a frame interrupted
	 by a signal, we assume that all registers have been saved.
	 This assumes that all register saves in a function happen
	 before the first function call.  */
       (get_next_frame (fci) == NULL
	|| (get_frame_type (get_next_frame (fci)) == SIGTRAMP_FRAME))
d1461 1
a1461 1
       /* In a dummy frame we know exactly where things are saved.  */
d1464 2
a1465 2
       /* Don't bother unless we are inside a function prologue.
	  Outside the prologue, we know where everything is. */
d1467 1
a1467 1
       && in_prologue (get_frame_pc (fci), PROC_LOW_ADDR (proc_desc))
d1469 4
a1472 4
       /* Not sure exactly what kernel_trap means, but if it means the
	  kernel saves the registers without a prologue doing it, we
	  better not examine the prologue to see whether registers
	  have been saved yet.  */
d1475 2
a1476 2
      /* We need to figure out whether the registers that the
         proc_desc claims are saved have been saved yet.  */
d1489 3
a1491 3
      /* Scan through this function's instructions preceding the
         current PC, and look for those that save registers.  */
      while (addr < get_frame_pc (fci))
d1504 9
a1512 12
  /* Fill in the offsets for the registers which gen_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (get_frame_base (fci)
			      + PROC_REG_OFFSET (proc_desc));
    for (ireg = MIPS_NUMREGS - 1; gen_mask; --ireg, gen_mask <<= 1)
      if (gen_mask & 0x80000000)
	{
	  set_reg_offset (saved_regs, ireg, reg_position);
	  reg_position -= MIPS_SAVED_REGSIZE;
	}
  }
d1514 4
a1517 4
  /* The MIPS16 entry instruction saves $s0 and $s1 in the reverse
     order of that normally used by gcc.  Therefore, we have to fetch
     the first instruction of the function, and if it's an entry
     instruction that saves $s0 or $s1, correct their saved addresses.  */
d1521 1
a1521 2
      if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)
	/* entry */
d1527 1
a1527 2
	  CORE_ADDR reg_position = (get_frame_base (fci)
				    + PROC_REG_OFFSET (proc_desc));
d1531 1
a1531 2
	  /* Check if the s0 and s1 registers were pushed on the
             stack.  */
d1534 1
a1534 1
	      set_reg_offset (saved_regs, reg, reg_position);
d1540 28
a1567 5
  /* Fill in the offsets for the registers which float_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (get_frame_base (fci)
			      + PROC_FREG_OFFSET (proc_desc));
d1569 2
a1570 40
    /* Fill in the offsets for the float registers which float_mask
       says were saved.  */
    for (ireg = MIPS_NUMREGS - 1; float_mask; --ireg, float_mask <<= 1)
      if (float_mask & 0x80000000)
	{
	  if (MIPS_SAVED_REGSIZE == 4 && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    {
	      /* On a big endian 32 bit ABI, floating point registers
		 are paired to form doubles such that the most
		 significant part is in $f[N+1] and the least
		 significant in $f[N] vis: $f[N+1] ||| $f[N].  The
		 registers are also spilled as a pair and stored as a
		 double.

	         When little-endian the least significant part is
	         stored first leading to the memory order $f[N] and
	         then $f[N+1].

		 Unfortunately, when big-endian the most significant
		 part of the double is stored first, and the least
		 significant is stored second.  This leads to the
		 registers being ordered in memory as firt $f[N+1] and
		 then $f[N].

		 For the big-endian case make certain that the
		 addresses point at the correct (swapped) locations
		 $f[N] and $f[N+1] pair (keep in mind that
		 reg_position is decremented each time through the
		 loop).  */
	      if ((ireg & 1))
		set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->fp0 + ireg,
				reg_position - MIPS_SAVED_REGSIZE);
	      else
		set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->fp0 + ireg,
				reg_position + MIPS_SAVED_REGSIZE);
	    }
	  else
	    set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->fp0 + ireg, reg_position);
	  reg_position -= MIPS_SAVED_REGSIZE;
	}
d1572 6
a1577 2
    set_reg_offset (saved_regs, PC_REGNUM, saved_regs[RA_REGNUM]);
  }
d1579 8
a1586 2
  /* SP_REGNUM, contains the value and not the address.  */
  set_reg_offset (saved_regs, SP_REGNUM, get_frame_base (fci));
d1592 21
a1612 16
  /* Always a pseudo.  */
  gdb_assert (regno >= NUM_REGS);
  if (fi == NULL)
    {
      LONGEST val;
      regcache_cooked_read_signed (current_regcache, regno, &val);
      return val;
    }
  else if ((regno % NUM_REGS) == SP_REGNUM)
    /* The SP_REGNUM is special, its value is stored in saved_regs.
       In fact, it is so special that it can even only be fetched
       using a raw register number!  Once this code as been converted
       to frame-unwind the problem goes away.  */
    return frame_unwind_register_signed (fi, regno % NUM_REGS);
  else
    return frame_unwind_register_signed (fi, regno);
d1614 1
d1622 34
a1655 20
  if (mips_mask_address_p ()
      && (((ULONGEST) addr) >> 32 == 0xffffffffUL))
    /* This hack is a work-around for existing boards using PMON, the
       simulator, and any other 64-bit targets that doesn't have true
       64-bit addressing.  On these targets, the upper 32 bits of
       addresses are ignored by the hardware.  Thus, the PC or SP are
       likely to have been sign extended to all 1s by instruction
       sequences that load 32-bit addresses.  For example, a typical
       piece of code that loads an address is this:

       lui $r2, <upper 16 bits>
       ori $r2, <lower 16 bits>

       But the lui sign-extends the value such that the upper 32 bits
       may be all 1s.  The workaround is simply to mask off these
       bits.  In the future, gcc may be changed to support true 64-bit
       addressing, and this masking will have to be disabled.  */
    return addr &= 0xffffffffUL;
  else
    return addr;
d1685 1
a1685 1
static CORE_ADDR
d1690 2
a1691 5
  pc = ((fromleaf)
	? DEPRECATED_SAVED_PC_AFTER_CALL (get_next_frame (prev))
	: get_next_frame (prev)
	? DEPRECATED_FRAME_SAVED_PC (get_next_frame (prev))
	: read_pc ());
d1693 1
a1693 1
  return tmp ? tmp : pc;
d1701 12
a1712 5

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), 0, 0))
    {
      /* Always unwind the cooked PC register value.  */
      saved_pc = frame_unwind_register_signed (frame, NUM_REGS + PC_REGNUM);
d1714 2
d1717 2
a1718 14
    {
      mips_extra_func_info_t proc_desc
	= get_frame_extra_info (frame)->proc_desc;
      if (proc_desc && PROC_DESC_IS_DUMMY (proc_desc))
	saved_pc = read_memory_integer (get_frame_base (frame) - MIPS_SAVED_REGSIZE, MIPS_SAVED_REGSIZE);
      else
	{
	  /* We have to get the saved pc from the sigcontext if it is
	     a signal handler frame.  */
	  int pcreg = (get_frame_type (frame) == SIGTRAMP_FRAME ? PC_REGNUM
		       : proc_desc ? PROC_PC_REG (proc_desc) : RA_REGNUM);
	  saved_pc = read_next_frame_reg (frame, NUM_REGS + pcreg);
	}
    }
d1723 1
d1725 4
a1728 17
/* This hack will go away once the get_prev_frame() code has been
   modified to set the frame's type first.  That is BEFORE init extra
   frame info et.al.  is called.  This is because it will become
   possible to skip the init extra info call for sigtramp and dummy
   frames.  */
static CORE_ADDR *temp_saved_regs;

/* Set a register's saved stack address in temp_saved_regs.  If an
   address has already been set for this register, do nothing; this
   way we will only recognize the first save of a given register in a
   function prologue.

   For simplicity, save the address in both [0 .. NUM_REGS) and
   [NUM_REGS .. 2*NUM_REGS).  Strictly speaking, only the second range
   is used as it is only second range (the ABI instead of ISA
   registers) that comes into play when finding saved registers in a
   frame.  */
d1731 1
a1731 1
set_reg_offset (CORE_ADDR *saved_regs, int regno, CORE_ADDR offset)
d1733 2
a1734 5
  if (saved_regs[regno] == 0)
    {
      saved_regs[regno + 0 * NUM_REGS] = offset;
      saved_regs[regno + 1 * NUM_REGS] = offset;
    }
d1786 1
a1786 1
	   stop_soon, but with this test, at least we
d1789 1
a1789 1
	if (stop_soon == NO_STOP_QUIETLY)
d1930 1
a1930 1
	  set_reg_offset (temp_saved_regs, reg, sp + offset);
d1937 1
a1937 1
	  set_reg_offset (temp_saved_regs, reg, sp + offset);
d1943 1
a1943 1
	  set_reg_offset (temp_saved_regs, RA_REGNUM, sp + offset);
d1949 1
a1949 1
	  set_reg_offset (temp_saved_regs, RA_REGNUM, sp + offset);
d1968 1
a1968 1
	  set_reg_offset (temp_saved_regs, reg, frame_addr + offset);
d1975 1
a1975 1
	  set_reg_offset (temp_saved_regs, reg, frame_addr + offset);
d2005 1
a2005 1
	  set_reg_offset (temp_saved_regs, reg, sp + offset);
d2014 1
a2014 1
	  set_reg_offset (temp_saved_regs, RA_REGNUM, sp + offset);
d2022 1
a2022 1
	  set_reg_offset (temp_saved_regs, reg, sp + offset);
a2034 1
  temp_saved_regs = xrealloc (temp_saved_regs, SIZEOF_FRAME_SAVED_REGS);
d2066 1
a2066 1
	  set_reg_offset (temp_saved_regs, reg, sp + low_word);
d2074 1
a2074 1
	  set_reg_offset (temp_saved_regs, reg, sp + low_word + 8 - mips_regsize (current_gdbarch));
d2085 1
a2085 1
	      frame_addr = read_next_frame_reg (next_frame, NUM_REGS + 30);
d2108 1
a2108 1
	      frame_addr = read_next_frame_reg (next_frame, NUM_REGS + 30);
d2124 1
a2124 1
	  set_reg_offset (temp_saved_regs, reg, frame_addr + low_word);
d2136 1
a2136 1
    sp = read_next_frame_reg (next_frame, NUM_REGS + SP_REGNUM);
d2143 1
a2143 2
  temp_saved_regs = xrealloc (temp_saved_regs, SIZEOF_FRAME_SAVED_REGS);
  memset (temp_saved_regs, '\0', SIZEOF_FRAME_SAVED_REGS);
d2191 1
a2191 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (pc, 0, 0))
d2325 1
a2325 1
  sym = lookup_symbol (MIPS_EFI_SYMBOL_NAME, b, LABEL_DOMAIN, 0, NULL);
d2388 1
a2388 1
      struct linked_proc_info *link;
d2408 4
a2411 3
  return (read_next_frame_reg (frame, NUM_REGS + PROC_FRAME_REG (proc_desc))
	  + PROC_FRAME_OFFSET (proc_desc)
	  - PROC_FRAME_ADJUST (proc_desc));
d2421 4
a2424 1
  CORE_ADDR saved_pc = DEPRECATED_FRAME_SAVED_PC (frame);
d2431 2
a2432 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (saved_pc, 0, 0))
d2437 1
a2437 1
      return get_frame_base (frame);
d2454 1
a2454 1
      && !(get_frame_type (frame) == SIGTRAMP_FRAME)
d2457 2
a2458 1
      && !(DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), 0, 0)))
a2467 1
  mips_extra_func_info_t proc_desc;
d2469 3
a2471 13
  if (get_frame_type (fci) == DUMMY_FRAME)
    return;

  /* Use proc_desc calculated in frame_chain.  When there is no
     next frame, i.e, get_next_frame (fci) == NULL, we call
     find_proc_desc () to calculate it, passing an explicit
     NULL as the frame parameter.  */
  proc_desc =
    get_next_frame (fci)
    ? cached_proc_desc
    : find_proc_desc (get_frame_pc (fci),
                      NULL /* i.e, get_next_frame (fci) */,
		      1);
d2473 2
a2474 1
  frame_extra_info_zalloc (fci, sizeof (struct frame_extra_info));
d2476 2
a2477 1
  get_frame_extra_info (fci)->proc_desc =
d2485 1
a2485 1
      if (get_frame_pc (fci) == PROC_LOW_ADDR (proc_desc)
d2487 3
a2489 2
	deprecated_update_frame_base_hack (fci, read_next_frame_reg (get_next_frame (fci), NUM_REGS + SP_REGNUM));
      else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fci), 0, 0))
d2498 1
a2498 1
	deprecated_update_frame_base_hack (fci, get_frame_pointer (get_next_frame (fci), proc_desc));
d2505 3
a2507 7
	     mips_find_saved_registers will do that for us.  We can't
	     use (get_frame_type (fci) == SIGTRAMP_FRAME), it is not
	     yet set.  */
	  /* FIXME: cagney/2002-11-18: This problem will go away once
             frame.c:get_prev_frame() is modified to set the frame's
             type before calling functions like this.  */
	  find_pc_partial_function (get_frame_pc (fci), &name,
d2509 1
a2509 1
	  if (!PC_IN_SIGTRAMP (get_frame_pc (fci), name))
d2512 9
a2520 12
	      /* Set value of previous frame's stack pointer.
	         Remember that saved_regs[SP_REGNUM] is special in
	         that it contains the value of the stack pointer
	         register.  The other saved_regs values are addresses
	         (in the inferior) at which a given register's value
	         may be found.  */
	      set_reg_offset (temp_saved_regs, SP_REGNUM,
			      get_frame_base (fci));
	      set_reg_offset (temp_saved_regs, PC_REGNUM,
			      temp_saved_regs[RA_REGNUM]);
	      memcpy (deprecated_get_frame_saved_regs (fci), temp_saved_regs,
		      SIZEOF_FRAME_SAVED_REGS);
d2526 1
a2526 1
      get_frame_extra_info (fci)->num_args = -1;
d2531 1
a2531 1
	      get_frame_extra_info (fci)->num_args = regnum - A0_REGNUM + 1;
d2608 6
d2619 1
a2619 1
  return align_down (addr, 16);
d2623 5
a2627 4
mips_eabi_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			   struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
			   struct value **args, CORE_ADDR sp, int struct_return,
			   CORE_ADDR struct_addr)
a2634 8
  /* For shared libraries, "t9" needs to point at the function
     address.  */
  regcache_cooked_write_signed (regcache, T9_REGNUM, func_addr);

  /* Set the return address register to point to the entry point of
     the program, where a breakpoint lies in wait.  */
  regcache_cooked_write_signed (regcache, RA_REGNUM, bp_addr);

d2641 2
a2642 2
  sp = align_down (sp, 16);
  struct_addr = align_down (struct_addr, 16);
d2648 1
a2648 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d2650 1
a2650 1
  sp -= align_up (len, 16);
d2654 2
a2655 2
			"mips_eabi_push_dummy_call: sp=0x%s allocated %ld\n",
			paddr_nz (sp), (long) align_up (len, 16));
d2659 1
a2659 1
  float_argreg = mips_fpa0_regnum (current_gdbarch);
d2666 1
a2666 1
			    "mips_eabi_push_dummy_call: struct_return reg=%d 0x%s\n",
d2677 1
a2677 1
      char valbuf[MAX_REGISTER_SIZE];
d2685 1
a2685 1
			    "mips_eabi_push_dummy_call: %d len=%d type=%d",
d2693 1
a2693 1
	  store_unsigned_integer (valbuf, MIPS_SAVED_REGSIZE, VALUE_ADDRESS (arg));
d2767 4
a2770 5
	  /* Note: structs whose size is not a multiple of
	     mips_regsize() are treated specially: Irix cc passes them
	     in registers where gcc sometimes puts them on the stack.
	     For maximum compatibility, we will put them in both
	     places.  */
d2862 1
a2862 1
		stack_offset += align_up (partial_len, MIPS_STACK_ARGSIZE);
a2868 2
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);

d2873 1
a2873 1
/* N32/N64 version of push_dummy_call.  */
d2876 5
a2880 4
mips_n32n64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			     struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
			     struct value **args, CORE_ADDR sp, int struct_return,
			     CORE_ADDR struct_addr)
a2887 8
  /* For shared libraries, "t9" needs to point at the function
     address.  */
  regcache_cooked_write_signed (regcache, T9_REGNUM, func_addr);

  /* Set the return address register to point to the entry point of
     the program, where a breakpoint lies in wait.  */
  regcache_cooked_write_signed (regcache, RA_REGNUM, bp_addr);

d2894 2
a2895 2
  sp = align_down (sp, 16);
  struct_addr = align_down (struct_addr, 16);
d2899 1
a2899 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d2901 1
a2901 1
  sp -= align_up (len, 16);
d2905 2
a2906 2
			"mips_n32n64_push_dummy_call: sp=0x%s allocated %ld\n",
			paddr_nz (sp), (long) align_up (len, 16));
d2910 1
a2910 1
  float_argreg = mips_fpa0_regnum (current_gdbarch);
d2917 1
a2917 1
			    "mips_n32n64_push_dummy_call: struct_return reg=%d 0x%s\n",
d2928 1
a2928 1
      char valbuf[MAX_REGISTER_SIZE];
d2936 1
a2936 1
			    "mips_n32n64_push_dummy_call: %d len=%d type=%d",
d2965 4
a2968 5
	  /* Note: structs whose size is not a multiple of
	     mips_regsize() are treated specially: Irix cc passes them
	     in registers where gcc sometimes puts them on the stack.
	     For maximum compatibility, we will put them in both
	     places.  */
d3084 1
a3084 1
		stack_offset += align_up (partial_len, MIPS_STACK_ARGSIZE);
a3090 2
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);

d3095 1
a3095 1
/* O32 version of push_dummy_call.  */
d3098 5
a3102 4
mips_o32_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			  struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
			  struct value **args, CORE_ADDR sp, int struct_return,
			  CORE_ADDR struct_addr)
a3109 8
  /* For shared libraries, "t9" needs to point at the function
     address.  */
  regcache_cooked_write_signed (regcache, T9_REGNUM, func_addr);

  /* Set the return address register to point to the entry point of
     the program, where a breakpoint lies in wait.  */
  regcache_cooked_write_signed (regcache, RA_REGNUM, bp_addr);

d3116 2
a3117 2
  sp = align_down (sp, 16);
  struct_addr = align_down (struct_addr, 16);
d3121 1
a3121 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d3123 1
a3123 1
  sp -= align_up (len, 16);
d3127 2
a3128 2
			"mips_o32_push_dummy_call: sp=0x%s allocated %ld\n",
			paddr_nz (sp), (long) align_up (len, 16));
d3132 1
a3132 1
  float_argreg = mips_fpa0_regnum (current_gdbarch);
d3139 1
a3139 1
			    "mips_o32_push_dummy_call: struct_return reg=%d 0x%s\n",
d3151 1
a3151 1
      char valbuf[MAX_REGISTER_SIZE];
d3159 1
a3159 1
			    "mips_o32_push_dummy_call: %d len=%d type=%d",
d3239 1
a3239 1
	  stack_offset += align_up (len, MIPS_STACK_ARGSIZE);
d3246 4
a3249 5
	  /* Note: structs whose size is not a multiple of
	     mips_regsize() are treated specially: Irix cc passes them
	     in registers where gcc sometimes puts them on the stack.
	     For maximum compatibility, we will put them in both
	     places.  */
d3325 2
a3326 2
		  /* Value may need to be sign extended, because
		     mips_regsize() != MIPS_SAVED_REGSIZE.  */
d3383 1
a3383 1
	      stack_offset += align_up (partial_len, MIPS_STACK_ARGSIZE);
a3389 2
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);

d3394 1
a3394 1
/* O64 version of push_dummy_call.  */
d3397 5
a3401 4
mips_o64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			  struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
			  struct value **args, CORE_ADDR sp, int struct_return,
			  CORE_ADDR struct_addr)
a3408 8
  /* For shared libraries, "t9" needs to point at the function
     address.  */
  regcache_cooked_write_signed (regcache, T9_REGNUM, func_addr);

  /* Set the return address register to point to the entry point of
     the program, where a breakpoint lies in wait.  */
  regcache_cooked_write_signed (regcache, RA_REGNUM, bp_addr);

d3415 2
a3416 2
  sp = align_down (sp, 16);
  struct_addr = align_down (struct_addr, 16);
d3420 1
a3420 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d3422 1
a3422 1
  sp -= align_up (len, 16);
d3426 2
a3427 2
			"mips_o64_push_dummy_call: sp=0x%s allocated %ld\n",
			paddr_nz (sp), (long) align_up (len, 16));
d3431 1
a3431 1
  float_argreg = mips_fpa0_regnum (current_gdbarch);
d3438 1
a3438 1
			    "mips_o64_push_dummy_call: struct_return reg=%d 0x%s\n",
d3450 1
a3450 1
      char valbuf[MAX_REGISTER_SIZE];
d3458 1
a3458 1
			    "mips_o64_push_dummy_call: %d len=%d type=%d",
d3538 1
a3538 1
	  stack_offset += align_up (len, MIPS_STACK_ARGSIZE);
d3545 4
a3548 5
	  /* Note: structs whose size is not a multiple of
	     mips_regsize() are treated specially: Irix cc passes them
	     in registers where gcc sometimes puts them on the stack.
	     For maximum compatibility, we will put them in both
	     places.  */
d3624 2
a3625 2
		  /* Value may need to be sign extended, because
		     mips_regsize() != MIPS_SAVED_REGSIZE.  */
d3682 1
a3682 1
	      stack_offset += align_up (partial_len, MIPS_STACK_ARGSIZE);
d3689 3
a3691 1
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);
d3693 6
a3698 1
  /* Return adjusted stack pointer.  */
d3703 105
d3810 1
a3810 1
  int regnum;
d3812 2
a3813 2
  CORE_ADDR new_sp = get_frame_base (frame);
  mips_extra_func_info_t proc_desc;
d3815 2
a3816 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), 0, 0))
d3823 3
a3825 3
  proc_desc = get_frame_extra_info (frame)->proc_desc;
  write_register (PC_REGNUM, DEPRECATED_FRAME_SAVED_PC (frame));
  mips_find_saved_regs (frame);
d3828 1
a3828 1
	&& deprecated_get_frame_saved_regs (frame)[regnum])
d3833 1
a3833 1
	if (mips_regnum (current_gdbarch)->fp0 <= regnum && regnum < mips_regnum (current_gdbarch)->fp0 + 32)
d3835 1
a3835 1
			  read_memory_unsigned_integer (deprecated_get_frame_saved_regs (frame)[regnum],
d3839 1
a3839 1
			  read_memory_integer (deprecated_get_frame_saved_regs (frame)[regnum],
d3868 1
a3868 1
      write_register (mips_regnum (current_gdbarch)->hi,
d3871 1
a3871 1
      write_register (mips_regnum (current_gdbarch)->lo,
d3875 1
a3875 1
	write_register (mips_regnum (current_gdbarch)->fp_control_status,
d3881 7
d3940 1
a3940 2
mips_read_fp_register_single (struct frame_info *frame, int regno,
			      char *rare_buffer)
d3942 1
a3942 1
  int raw_size = register_size (current_gdbarch, regno);
d3945 1
a3945 1
  if (!frame_register_read (frame, regno, raw_buffer))
d3971 1
a3971 2
mips_read_fp_register_double (struct frame_info *frame, int regno,
			      char *rare_buffer)
d3973 1
a3973 1
  int raw_size = register_size (current_gdbarch, regno);
d3979 1
a3979 1
      if (!frame_register_read (frame, regno, rare_buffer))
d3984 1
a3984 1
      if ((regno - mips_regnum (current_gdbarch)->fp0) & 1)
d3993 2
a3994 2
	  mips_read_fp_register_single (frame, regno, rare_buffer + 4);
	  mips_read_fp_register_single (frame, regno + 1, rare_buffer);
d3998 2
a3999 2
	  mips_read_fp_register_single (frame, regno, rare_buffer);
	  mips_read_fp_register_single (frame, regno + 1, rare_buffer + 4);
d4005 3
a4007 6
mips_print_fp_register (struct ui_file *file, struct frame_info *frame,
			int regnum)
{				/* do values for FP (float) regs */
  char *raw_buffer;
  double doub, flt1, flt2;	/* doubles extracted from raw hex data */
  int inv1, inv2, namelen;
d4009 6
a4014 1
  raw_buffer = (char *) alloca (2 * register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0));
d4016 18
a4033 3
  fprintf_filtered (file, "%s:", REGISTER_NAME (regnum));
  fprintf_filtered (file, "%*s", 4 - (int) strlen (REGISTER_NAME (regnum)),
		    "");
d4035 29
a4063 1
  if (register_size (current_gdbarch, regnum) == 4 || mips2_fp_compat ())
d4065 12
a4076 4
      /* 4-byte registers: Print hex and floating.  Also print even
         numbered registers as doubles.  */
      mips_read_fp_register_single (frame, regnum, raw_buffer);
      flt1 = unpack_double (mips_float_register_type (), raw_buffer, &inv1);
d4078 2
a4079 1
      print_scalar_formatted (raw_buffer, builtin_type_uint32, 'x', 'w', file);
d4081 6
a4086 5
      fprintf_filtered (file, " flt: ");
      if (inv1)
	fprintf_filtered (file, " <invalid float> ");
      else
	fprintf_filtered (file, "%-17.9g", flt1);
d4088 1
a4088 5
      if (regnum % 2 == 0)
	{
	  mips_read_fp_register_double (frame, regnum, raw_buffer);
	  doub = unpack_double (mips_double_register_type (), raw_buffer,
	                        &inv2);
d4090 1
a4090 8
	  fprintf_filtered (file, " dbl: ");
	  if (inv2)
	    fprintf_filtered (file, "<invalid double>");
	  else
	    fprintf_filtered (file, "%-24.17g", doub);
	}
    }
  else
d4092 3
a4094 2
      /* Eight byte registers: print each one as hex, float and double.  */
      mips_read_fp_register_single (frame, regnum, raw_buffer);
d4097 2
a4098 2
      mips_read_fp_register_double (frame, regnum, raw_buffer);
      doub = unpack_double (mips_double_register_type (), raw_buffer, &inv2);
d4100 2
d4103 1
a4103 3
      print_scalar_formatted (raw_buffer, builtin_type_uint64, 'x', 'g', file);

      fprintf_filtered (file, " flt: ");
d4105 1
a4105 1
	fprintf_filtered (file, "<invalid float>");
d4107 1
a4107 1
	fprintf_filtered (file, "%-17.9g", flt1);
d4109 1
a4109 1
      fprintf_filtered (file, " dbl: ");
d4111 1
a4111 1
	fprintf_filtered (file, "<invalid double>");
d4113 1
a4113 3
	fprintf_filtered (file, "%-24.17g", doub);
    }
}
d4115 6
a4120 7
static void
mips_print_register (struct ui_file *file, struct frame_info *frame,
		     int regnum, int all)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  char raw_buffer[MAX_REGISTER_SIZE];
  int offset;
d4122 2
a4123 4
  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
    {
      mips_print_fp_register (file, frame, regnum);
      return;
d4125 1
a4125 3

  /* Get the data in raw format.  */
  if (!frame_register_read (frame, regnum, raw_buffer))
d4127 3
a4129 3
      fprintf_filtered (file, "%s: [Invalid]", REGISTER_NAME (regnum));
      return;
    }
d4131 2
a4132 1
  fputs_filtered (REGISTER_NAME (regnum), file);
d4134 5
a4138 8
  /* The problem with printing numeric register names (r26, etc.) is that
     the user can't use them on input.  Probably the best solution is to
     fix it so that either the numeric or the funky (a2, etc.) names
     are accepted on input.  */
  if (regnum < MIPS_NUMREGS)
    fprintf_filtered (file, "(r%d): ", regnum);
  else
    fprintf_filtered (file, ": ");
d4140 5
a4144 4
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    offset = register_size (current_gdbarch, regnum) - register_size (current_gdbarch, regnum);
  else
    offset = 0;
d4146 5
a4150 15
  print_scalar_formatted (raw_buffer + offset, gdbarch_register_type (gdbarch, regnum),
			  'x', 0, file);
}

/* Replacement for generic do_registers_info.
   Print regs in pretty columns.  */

static int
print_fp_register_row (struct ui_file *file, struct frame_info *frame,
		       int regnum)
{
  fprintf_filtered (file, " ");
  mips_print_fp_register (file, frame, regnum);
  fprintf_filtered (file, "\n");
  return regnum + 1;
a4152 1

d4156 1
a4156 2
print_gp_register_row (struct ui_file *file, struct frame_info *frame,
		       int start_regnum)
a4157 1
  struct gdbarch *gdbarch = get_frame_arch (frame);
d4159 2
a4160 2
  char raw_buffer[MAX_REGISTER_SIZE];
  int ncols = (mips_regsize (gdbarch) == 8 ? 4 : 8);	/* display cols per row */
d4162 3
a4164 1
  int regnum;
d4167 2
a4168 4
  fprintf_filtered (file, "     ");
  for (col = 0, regnum = start_regnum;
       col < ncols && regnum < NUM_REGS + NUM_PSEUDO_REGS;
       regnum++)
d4172 1
a4172 1
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d4174 2
a4175 2
      fprintf_filtered (file, mips_regsize (current_gdbarch) == 8 ? "%17s" : "%9s",
			REGISTER_NAME (regnum));
d4178 2
a4179 5
  /* print the R0 to R31 names */
  if ((start_regnum % NUM_REGS) < MIPS_NUMREGS)
    fprintf_filtered (file, "\n R%-4d", start_regnum % NUM_REGS);
  else
    fprintf_filtered (file, "\n      ");
d4181 1
d4183 1
a4183 3
  for (col = 0, regnum = start_regnum;
       col < ncols && regnum < NUM_REGS + NUM_PSEUDO_REGS;
       regnum++)
d4187 1
a4187 1
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d4190 1
a4190 1
      if (!frame_register_read (frame, regnum, raw_buffer))
d4193 1
a4193 4
      for (byte = 0;
	   byte < (mips_regsize (current_gdbarch)
		   - register_size (current_gdbarch, regnum));
	   byte++)
d4197 2
a4198 2
	for (byte = register_size (current_gdbarch, regnum) - register_size (current_gdbarch, regnum);
	     byte < register_size (current_gdbarch, regnum);
d4200 1
a4200 1
	  fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[byte]);
d4202 1
a4202 1
	for (byte = register_size (current_gdbarch, regnum) - 1;
d4205 2
a4206 2
	  fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[byte]);
      fprintf_filtered (file, " ");
d4210 1
a4210 1
    fprintf_filtered (file, "\n");
d4218 1
a4218 2
mips_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,
			   struct frame_info *frame, int regnum, int all)
a4221 1
      gdb_assert (regnum >= NUM_REGS);
d4225 2
a4226 2
      mips_print_register (file, frame, regnum, 0);
      fprintf_filtered (file, "\n");
d4231 2
a4232 2
      regnum = NUM_REGS;
      while (regnum < NUM_REGS + NUM_PSEUDO_REGS)
d4234 5
a4238 7
	  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
	    {
	      if (all)		/* true for "INFO ALL-REGISTERS" command */
		regnum = print_fp_register_row (file, frame, regnum);
	      else
		regnum += MIPS_NUMREGS;	/* skip floating point regs */
	    }
d4240 1
a4240 1
	    regnum = print_gp_register_row (file, frame, regnum);
a4278 55
/* Given PC at the function's start address, attempt to find the
   prologue end using SAL information.  Return zero if the skip fails.

   A non-optimized prologue traditionally has one SAL for the function
   and a second for the function body.  A single line function has
   them both pointing at the same line.

   An optimized prologue is similar but the prologue may contain
   instructions (SALs) from the instruction body.  Need to skip those
   while not getting into the function body.

   The functions end point and an increasing SAL line are used as
   indicators of the prologue's endpoint.

   This code is based on the function refine_prologue_limit (versions
   found in both ia64 and ppc).  */

static CORE_ADDR
skip_prologue_using_sal (CORE_ADDR func_addr)
{
  struct symtab_and_line prologue_sal;
  CORE_ADDR start_pc;
  CORE_ADDR end_pc;

  /* Get an initial range for the function.  */
  find_pc_partial_function (func_addr, NULL, &start_pc, &end_pc);
  start_pc += FUNCTION_START_OFFSET;

  prologue_sal = find_pc_line (start_pc, 0);
  if (prologue_sal.line != 0)
    {
      while (prologue_sal.end < end_pc)
	{
	  struct symtab_and_line sal;

	  sal = find_pc_line (prologue_sal.end, 0);
	  if (sal.line == 0)
	    break;
	  /* Assume that a consecutive SAL for the same (or larger)
             line mark the prologue -> body transition.  */
	  if (sal.line >= prologue_sal.line)
	    break;
	  /* The case in which compiler's optimizer/scheduler has
	     moved instructions into the prologue.  We look ahead in
	     the function looking for address ranges whose
	     corresponding line number is less the first one that we
	     found for the function.  This is more conservative then
	     refine_prologue_limit which scans a large number of SALs
	     looking for any in the prologue */
	  prologue_sal = sal;
	}
    }
  return prologue_sal.end;
}

a4289 5
  /* Find an upper bound on the prologue.  */
  end_pc = skip_prologue_using_sal (pc);
  if (end_pc == 0)
    end_pc = pc + 100; /* Magic.  */

d4293 1
a4293 1
  for (; pc < end_pc; pc += MIPS_INSTLEN)
a4434 5
  /* Find an upper bound on the prologue.  */
  end_pc = skip_prologue_using_sal (pc);
  if (end_pc == 0)
    end_pc = pc + 100; /* Magic.  */

d4438 1
a4438 1
  for (; pc < end_pc; pc += MIPS16_INSTLEN)
d4533 1
a4533 1
			     && register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0) == 8)
d4536 2
a4537 2
	  lo->reg = mips_regnum (current_gdbarch)->fp0 + 0;
	  hi->reg = mips_regnum (current_gdbarch)->fp0 + 1;
d4546 1
a4546 1
			     && register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0) == 8
d4549 1
a4549 1
	  lo->reg = mips_regnum (current_gdbarch)->fp0;
d4602 1
a4602 1
	  && register_size (current_gdbarch, regnum) == 8
d4620 1
a4620 1
				char regbuf[],
d4628 1
a4628 1
	  regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + lo.reg) + lo.reg_offset,
d4633 1
a4633 1
	    regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + hi.reg) + hi.reg_offset,
d4639 1
a4639 1
			       char regbuf[],
d4647 1
a4647 1
	  regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + lo.reg) + lo.reg_offset,
d4652 1
a4652 1
	    regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + hi.reg) + hi.reg_offset,
d4662 1
a4662 1
  char raw_buffer[MAX_REGISTER_SIZE];
d4669 3
a4671 2
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (lo.reg), raw_buffer,
				   register_size (current_gdbarch, lo.reg));
d4677 3
a4679 2
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (hi.reg), raw_buffer,
				       register_size (current_gdbarch, hi.reg));
d4686 1
a4686 1
  char raw_buffer[MAX_REGISTER_SIZE];
d4693 3
a4695 2
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (lo.reg), raw_buffer,
				   register_size (current_gdbarch, lo.reg));
d4701 3
a4703 2
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (hi.reg), raw_buffer,
				       register_size (current_gdbarch, hi.reg));
d4709 4
a4712 4
static enum return_value_convention
mips_o32_return_value (struct gdbarch *gdbarch, struct type *type,
		       struct regcache *regcache,
		       void *readbuf, const void *writebuf)
d4715 3
a4717 8

  if (TYPE_CODE (type)== TYPE_CODE_STRUCT
      || TYPE_CODE (type)== TYPE_CODE_UNION
      || TYPE_CODE (type)== TYPE_CODE_ARRAY)
    return RETURN_VALUE_STRUCT_CONVENTION;
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && TYPE_LENGTH (type) == 4
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
d4723 2
a4724 5
      mips_xfer_register (regcache,
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
			  TYPE_LENGTH (type),
			  TARGET_BYTE_ORDER, readbuf, writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
d4730 3
a4732 3
      /* A double-precision floating-point value.  The most
         significant part goes in FP1, and the least significant in
         FP0.  */
d4734 1
a4734 1
	fprintf_unfiltered (gdb_stderr, "Return float in $fp1/$fp0\n");
d4738 4
a4741 6
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 0,
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 1,
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 4);
d4744 4
a4747 6
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 1,
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 0,
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 4);
a4751 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d4770 1
a4770 1
      bfd_byte reg[MAX_REGISTER_SIZE];
d4773 1
a4773 1
      for (field = 0, regnum = mips_regnum (current_gdbarch)->fp0;
d4781 2
a4782 3
	  mips_xfer_register (regcache, NUM_REGS + regnum,
			      TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
a4783 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d4797 1
a4797 1
	   offset += register_size (current_gdbarch, regnum), regnum++)
d4799 1
a4799 1
	  int xfer = register_size (current_gdbarch, regnum);
d4805 2
a4806 2
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      BFD_ENDIAN_UNKNOWN, readbuf, writebuf, offset);
a4807 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d4828 2
a4829 2
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
a4830 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d4834 14
d4850 4
a4853 4
static enum return_value_convention
mips_n32n64_return_value (struct gdbarch *gdbarch,
			  struct type *type, struct regcache *regcache,
			  void *readbuf, const void *writebuf)
d4856 2
a4857 7
  if (TYPE_CODE (type)== TYPE_CODE_STRUCT
      || TYPE_CODE (type)== TYPE_CODE_UNION
      || TYPE_CODE (type)== TYPE_CODE_ARRAY
      || TYPE_LENGTH (type) > 2 * MIPS_SAVED_REGSIZE)
    return RETURN_VALUE_STRUCT_CONVENTION;
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
d4863 2
a4864 5
      mips_xfer_register (regcache,
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
			  TYPE_LENGTH (type),
			  TARGET_BYTE_ORDER, readbuf, writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
d4882 1
a4882 1
      bfd_byte reg[MAX_REGISTER_SIZE];
d4885 1
a4885 1
      for (field = 0, regnum = mips_regnum (current_gdbarch)->fp0;
d4893 2
a4894 3
	  mips_xfer_register (regcache, NUM_REGS + regnum,
			      TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
a4895 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d4907 1
a4907 1
	   offset += register_size (current_gdbarch, regnum), regnum++)
d4909 1
a4909 1
	  int xfer = register_size (current_gdbarch, regnum);
d4915 2
a4916 2
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      BFD_ENDIAN_UNKNOWN, readbuf, writebuf, offset);
a4917 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d4927 1
a4927 1
	   offset += register_size (current_gdbarch, regnum), regnum++)
d4929 1
a4929 1
	  int xfer = register_size (current_gdbarch, regnum);
d4936 2
a4937 2
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
a4938 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d4942 20
d5066 56
d5123 1
a5123 4
   processor id.  NOTE: cagney/2003-11-15: Firstly it isn't clear that
   the relevant processor still exists (it dates back to '94) and
   secondly this is not the way to do this.  The processor type should
   be set by forcing an architecture change.  */
d5125 2
a5126 2
void
deprecated_mips_set_processor_regs_hack (void)
a5127 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d5133 3
a5135 1
    tdep->mips_processor_reg_names = mips_r3041_reg_names;
d5148 2
a5149 2
static int
gdb_print_insn_mips (bfd_vma memaddr, struct disassemble_info *info)
a5150 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d5159 1
a5159 1
  proc_desc = non_heuristic_proc_desc (make_mips16_addr (memaddr), NULL);
a5164 4
  /* FIXME: cagney/2003-06-26: Is this even necessary?  The
     disassembler needs to be able to locally determine the ISA, and
     not rely on GDB.  Otherwize the stand-alone 'objdump -d' will not
     work.  */
d5166 2
a5167 4
    {
      if (pc_is_mips16 (PROC_LOW_ADDR (proc_desc)))
	info->mach =  bfd_mach_mips16;
    }
d5169 2
a5170 4
    {
      if (pc_is_mips16 (memaddr))
       info->mach = bfd_mach_mips16;
    } 
a5174 20
  /* Set the disassembler options.  */
  if (tdep->mips_abi == MIPS_ABI_N32
      || tdep->mips_abi == MIPS_ABI_N64)
    {
      /* Set up the disassembler info, so that we get the right
	 register names from libopcodes.  */
      if (tdep->mips_abi == MIPS_ABI_N32)
	info->disassembler_options = "gpr-names=n32";
      else
	info->disassembler_options = "gpr-names=64";
      info->flavour = bfd_target_elf_flavour;
    }
  else
    /* This string is not recognized explicitly by the disassembler,
       but it tells the disassembler to not try to guess the ABI from
       the bfd elf headers, such that, if the user overrides the ABI
       of a program linked as NewABI, the disassembly will follow the
       register naming conventions specified by the user.  */
    info->disassembler_options = "gpr-names=32";

d5182 13
d5209 3
a5211 2
	  static unsigned char mips16_big_breakpoint[] = {0xe8, 0xa5};
	  *pcptr = unmake_mips16_addr (*pcptr);
d5217 3
a5219 6
	  /* The IDT board uses an unusual breakpoint value, and
	     sometimes gets confused when it sees the usual MIPS
	     breakpoint instruction.  */
	  static unsigned char big_breakpoint[] = {0, 0x5, 0, 0xd};
	  static unsigned char pmon_big_breakpoint[] = {0, 0, 0, 0xd};
	  static unsigned char idt_big_breakpoint[] = {0, 0, 0x0a, 0xd};
d5237 3
a5239 2
	  static unsigned char mips16_little_breakpoint[] = {0xa5, 0xe8};
	  *pcptr = unmake_mips16_addr (*pcptr);
d5245 5
a5249 3
	  static unsigned char little_breakpoint[] = {0xd, 0, 0x5, 0};
	  static unsigned char pmon_little_breakpoint[] = {0xd, 0, 0, 0};
	  static unsigned char idt_little_breakpoint[] = {0xd, 0x0a, 0, 0};
d5439 37
d5496 1
a5496 1
  int realnumx;
d5498 2
a5499 2
  /* Always a pseudo.  */
  gdb_assert (regnum >= NUM_REGS);
d5508 20
a5527 14

  if ((regnum % NUM_REGS) == SP_REGNUM)
    /* The SP_REGNUM is special, its value is stored in saved_regs.
       In fact, it is so special that it can even only be fetched
       using a raw register number!  Once this code as been converted
       to frame-unwind the problem goes away.  */
    frame_register_unwind (deprecated_get_next_frame_hack (frame),
			   regnum % NUM_REGS, optimizedp, lvalp, addrp,
			   &realnumx, raw_buffer);
  else
    /* Get it from the next frame.  */
    frame_register_unwind (deprecated_get_next_frame_hack (frame),
			   regnum, optimizedp, lvalp, addrp,
			   &realnumx, raw_buffer);
d5542 2
a5543 2
/* Convert a dbx stab register number (from `r' declaration) to a GDB
   [1 * NUM_REGS .. 2 * NUM_REGS) REGNUM.  */
d5548 4
a5551 14
  int regnum;
  if (num >= 0 && num < 32)
    regnum = num;
  else if (num >= 38 && num < 70)
    regnum = num + mips_regnum (current_gdbarch)->fp0 - 38;
  else if (num == 70)
    regnum = mips_regnum (current_gdbarch)->hi;
  else if (num == 71)
    regnum = mips_regnum (current_gdbarch)->lo;
  else
    /* This will hopefully (eventually) provoke a warning.  Should
       we be calling complaint() here?  */
    return NUM_REGS + NUM_PSEUDO_REGS;
  return NUM_REGS + regnum;
d5554 1
a5554 22

/* Convert a dwarf, dwarf2, or ecoff register number to a GDB [1 *
   NUM_REGS .. 2 * NUM_REGS) REGNUM.  */

static int
mips_dwarf_dwarf2_ecoff_reg_to_regnum (int num)
{
  int regnum;
  if (num >= 0 && num < 32)
    regnum = num;
  else if (num >= 32 && num < 64)
    regnum = num + mips_regnum (current_gdbarch)->fp0 - 32;
  else if (num == 64)
    regnum = mips_regnum (current_gdbarch)->hi;
  else if (num == 65)
    regnum = mips_regnum (current_gdbarch)->lo;
  else
    /* This will hopefully (eventually) provoke a warning.  Should we
       be calling complaint() here?  */
    return NUM_REGS + NUM_PSEUDO_REGS;
  return NUM_REGS + regnum;
}
d5557 1
a5557 1
mips_register_sim_regno (int regnum)
d5559 2
a5560 8
  /* Only makes sense to supply raw registers.  */
  gdb_assert (regnum >= 0 && regnum < NUM_REGS);
  /* FIXME: cagney/2002-05-13: Need to look at the pseudo register to
     decide if it is valid.  Should instead define a standard sim/gdb
     register numbering scheme.  */
  if (REGISTER_NAME (NUM_REGS + regnum) != NULL
      && REGISTER_NAME (NUM_REGS + regnum)[0] != '\0')
    return regnum;
d5562 1
a5562 1
    return LEGACY_SIM_REGNO_IGNORE;    
a5564 1

d5624 2
d5630 7
a5636 1
  int num_regs;
d5645 4
d5745 2
a5746 6
      /* Need to be pedantic about which register virtual size is
         used.  */
      if (gdbarch_tdep (arches->gdbarch)->mips64_transfers_32bit_regs_p
	  != mips64_transfers_32bit_regs_p)
	continue;
      return arches->gdbarch;
d5753 1
a5753 1
  tdep->mips64_transfers_32bit_regs_p = mips64_transfers_32bit_regs_p;
d5761 3
a5763 3
  set_gdbarch_register_reggroup_p (gdbarch, mips_register_reggroup_p);
  set_gdbarch_pseudo_register_read (gdbarch, mips_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, mips_pseudo_register_write);
a5769 37
  /* Fill in the OS dependant register numbers.  */
  {
    struct mips_regnum *regnum = GDBARCH_OBSTACK_ZALLOC (gdbarch,
							 struct mips_regnum);
    tdep->regnum = regnum;
    if (info.osabi == GDB_OSABI_IRIX)
      {
	regnum->fp0 = 32;
	regnum->pc = 64;
	regnum->cause = 65;
	regnum->badvaddr = 66;
	regnum->hi = 67;
	regnum->lo = 68;
	regnum->fp_control_status = 69;
	regnum->fp_implementation_revision = 70;
	num_regs = 71;
      }
    else
      {
	regnum->lo = MIPS_EMBED_LO_REGNUM;
	regnum->hi = MIPS_EMBED_HI_REGNUM;
	regnum->badvaddr = MIPS_EMBED_BADVADDR_REGNUM;
	regnum->cause = MIPS_EMBED_CAUSE_REGNUM;
	regnum->pc = MIPS_EMBED_PC_REGNUM;
	regnum->fp0 = MIPS_EMBED_FP0_REGNUM;
	regnum->fp_control_status = 70;
	regnum->fp_implementation_revision = 71;
	num_regs = 90;
      }
    /* FIXME: cagney/2003-11-15: For MIPS, hasn't PC_REGNUM been
       replaced by read_pc?  */
    set_gdbarch_pc_regnum (gdbarch, regnum->pc);
    set_gdbarch_fp0_regnum (gdbarch, regnum->fp0);
    set_gdbarch_num_regs (gdbarch, num_regs);
    set_gdbarch_num_pseudo_regs (gdbarch, num_regs);
  }

d5773 3
a5775 2
      set_gdbarch_push_dummy_call (gdbarch, mips_o32_push_dummy_call);
      set_gdbarch_return_value (gdbarch, mips_o32_return_value);
d5780 2
a5781 1
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 4 - 1;
d5786 4
a5789 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_o32_reg_struct_has_addr);
d5792 1
a5792 1
      set_gdbarch_push_dummy_call (gdbarch, mips_o64_push_dummy_call);
d5799 2
a5800 1
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 4 - 1;
d5805 4
a5808 3
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_o32_reg_struct_has_addr);
      set_gdbarch_use_struct_convention (gdbarch, always_use_struct_convention);
d5811 1
a5811 1
      set_gdbarch_push_dummy_call (gdbarch, mips_eabi_push_dummy_call);
d5818 2
a5819 1
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
d5824 2
a5825 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_eabi_reg_struct_has_addr);
d5830 1
a5830 1
      set_gdbarch_push_dummy_call (gdbarch, mips_eabi_push_dummy_call);
d5837 2
a5838 1
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
d5843 2
a5844 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_eabi_reg_struct_has_addr);
d5849 3
a5851 2
      set_gdbarch_push_dummy_call (gdbarch, mips_n32n64_push_dummy_call);
      set_gdbarch_return_value (gdbarch, mips_n32n64_return_value);
d5856 2
a5857 1
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
d5862 16
a5877 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_n32n64_reg_struct_has_addr);
d5880 3
a5882 2
      set_gdbarch_push_dummy_call (gdbarch, mips_n32n64_push_dummy_call);
      set_gdbarch_return_value (gdbarch, mips_n32n64_return_value);
d5887 2
a5888 1
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
d5893 16
a5908 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_n32n64_reg_struct_has_addr);
d5958 7
a5964 1
  /* MIPS version of register names.  */
a5965 6
  if (info.osabi == GDB_OSABI_IRIX)
    tdep->mips_processor_reg_names = mips_irix_reg_names;
  else if (info.bfd_arch_info != NULL && info.bfd_arch_info->mach == bfd_mach_mips3900)
    tdep->mips_processor_reg_names = mips_tx39_reg_names;
  else
    tdep->mips_processor_reg_names = mips_generic_reg_names;
d5968 1
a5968 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, mips_read_sp); /* Draft FRAME base.  */
d5970 1
d5977 3
a5979 2
     blockframe.c near reference to DEPRECATED_INIT_FRAME_PC_FIRST.  */
  set_gdbarch_deprecated_init_frame_pc_first (gdbarch, mips_init_frame_pc_first);
d5983 1
a5983 4
  set_gdbarch_ecoff_reg_to_regnum (gdbarch, mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_register_sim_regno (gdbarch, mips_register_sim_regno);
d5986 2
a5987 2
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, mips_find_saved_regs);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, mips_init_extra_frame_info);
d5991 29
a6019 5
  /* NOTE: cagney/2003-08-05: Eventually call dummy location will be
     replaced by a command, and all targets will default to on stack
     (regardless of the stack's execute status).  */
  set_gdbarch_call_dummy_location (gdbarch, AT_SYMBOL);
  set_gdbarch_deprecated_pop_frame (gdbarch, mips_pop_frame);
d6021 9
a6029 1
  set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
d6031 4
a6034 1
  set_gdbarch_deprecated_frame_chain (gdbarch, mips_frame_chain);
d6037 4
a6040 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, mips_frame_saved_pc);
d6043 1
a6043 1
  set_gdbarch_deprecated_get_saved_register (gdbarch, mips_get_saved_register);
d6050 1
a6050 1
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, mips_saved_pc_after_call);
d6058 4
a6061 1
  set_gdbarch_register_type (gdbarch, mips_register_type);
d6063 1
a6063 1
  set_gdbarch_print_registers_info (gdbarch, mips_print_registers_info);
a6065 10
  set_gdbarch_print_insn (gdbarch, gdb_print_insn_mips);

  /* FIXME: cagney/2003-08-29: The macros HAVE_STEPPABLE_WATCHPOINT,
     HAVE_NONSTEPPABLE_WATCHPOINT, and HAVE_CONTINUABLE_WATCHPOINT
     need to all be folded into the target vector.  Since they are
     being used as guards for STOPPED_BY_WATCHPOINT, why not have
     STOPPED_BY_WATCHPOINT return the type of watchpoint that the code
     is sitting on?  */
  set_gdbarch_have_nonsteppable_watchpoint (gdbarch, 1);

d6067 1
a6067 1
  gdbarch_init_osabi (info, gdbarch);
d6069 1
a6092 32
/* Print out which MIPS ABI is in use.  */

static void
show_mips_abi (char *ignore_args, int from_tty)
{
  if (gdbarch_bfd_arch_info (current_gdbarch)->arch != bfd_arch_mips)
    printf_filtered (
      "The MIPS ABI is unknown because the current architecture is not MIPS.\n");
  else
    {
      enum mips_abi global_abi = global_mips_abi ();
      enum mips_abi actual_abi = mips_abi (current_gdbarch);
      const char *actual_abi_str = mips_abi_strings[actual_abi];

      if (global_abi == MIPS_ABI_UNKNOWN)
	printf_filtered ("The MIPS ABI is set automatically (currently \"%s\").\n",
	                 actual_abi_str);
      else if (global_abi == actual_abi)
	printf_filtered (
	  "The MIPS ABI is assumed to be \"%s\" (due to user setting).\n",
	  actual_abi_str);
      else
	{
	  /* Probably shouldn't happen...  */
	  printf_filtered (
	    "The (auto detected) MIPS ABI \"%s\" is in use even though the user setting was \"%s\".\n",
	    actual_abi_str,
	    mips_abi_strings[global_abi]);
	}
    }
}

d6154 4
d6177 3
d6189 11
d6206 6
d6215 25
d6249 2
d6253 5
d6274 4
d6281 2
d6297 2
d6302 8
d6313 3
d6343 3
d6348 12
d6393 3
d6432 5
d6457 2
d6470 5
d6481 4
a6486 2
extern initialize_file_ftype _initialize_mips_tdep; /* -Wmissing-prototypes */

d6499 2
d6553 1
a6554 2
  add_cmd ("abi", class_obscure, show_mips_abi,
           "Show ABI in use by MIPS target", &showmipscmdlist);
d6612 5
a6616 7
  add_setshow_cmd ("remote-mips64-transfers-32bit-regs", class_obscure,
		   var_boolean, &mips64_transfers_32bit_regs_p, "\
Set compatibility with 64-bit MIPS targets that transfer 32-bit quantities.\n\
Use \"on\" to enable backward compatibility with older MIPS 64 GDB+target\n\
that would transfer 32 bits for some registers (e.g. SR, FSR) and\n\
64 bits for others.  Use \"off\" to disable compatibility mode",  "\
Show compatibility with 64-bit MIPS targets that transfer 32-bit quantities.\n\
d6620 2
a6621 2
		   set_mips64_transfers_32bit_regs, NULL,
		   &setlist, &showlist);
@


1.129.2.3
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d4 1
a4 2
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d170 8
a242 4
/* Return the currently configured (or set) saved register size. */

static const char *mips_saved_regsize_string = size_auto;

d244 1
a244 1
mips_saved_regsize (struct gdbarch_tdep *tdep)
d247 1
a247 1
    return tdep->mips_default_saved_regsize;
d370 4
d377 1
a377 1
mips_stack_argsize (struct gdbarch_tdep *tdep)
d380 1
a380 1
    return tdep->mips_default_stack_argsize;
d387 2
d568 1
a568 1
    regcache_raw_read (regcache, rawnum, buf);
d588 1
a588 1
    regcache_raw_write (regcache, rawnum, buf);
d745 1
a745 1
mips_mask_address_p (struct gdbarch_tdep *tdep)
d755 1
a755 1
      return tdep->default_mask_address_p;
a765 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d776 1
a776 1
		       mips_mask_address_p (tdep) ? "enabled" : "disabled");
d790 1
a790 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  return (TYPE_LENGTH (type) > 2 * mips_saved_regsize (tdep));
a801 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d804 1
a804 1
    return (len > mips_saved_regsize (tdep));
d809 12
d1086 1
d1132 1
a1483 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1595 1
a1595 1
	  reg_position -= mips_saved_regsize (tdep);
d1616 1
a1616 1
	    reg_position -= mips_saved_regsize (tdep);
d1623 1
a1623 1
	      reg_position -= mips_saved_regsize (tdep);
d1639 1
a1639 2
	  if (mips_saved_regsize (tdep) == 4
	      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1665 1
a1665 1
				reg_position - mips_saved_regsize (tdep));
d1668 1
a1668 1
				reg_position + mips_saved_regsize (tdep));
d1672 1
a1672 1
	  reg_position -= mips_saved_regsize (tdep);
d1709 1
a1709 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  if (mips_mask_address_p (tdep)
a1776 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1788 1
a1788 3
	saved_pc = read_memory_integer ((get_frame_base (frame)
					 - mips_saved_regsize (tdep))
					, mips_saved_regsize (tdep));
a1994 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d2100 1
a2100 1
	  offset += mips_saved_regsize (tdep);
d2109 1
a2109 1
	  offset -= mips_saved_regsize (tdep);
d2117 1
a2117 1
	  offset -= mips_saved_regsize (tdep);
a2731 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d2755 1
a2755 1
		     mips_stack_argsize (tdep));
d2796 1
a2796 1
      if (len > mips_saved_regsize (tdep)
d2799 1
a2799 2
	  store_unsigned_integer (valbuf, mips_saved_regsize (tdep),
				  VALUE_ADDRESS (arg));
d2801 1
a2801 1
	  len = mips_saved_regsize (tdep);
d2878 2
a2879 2
	  int odd_sized_struct = ((len > mips_saved_regsize (tdep))
				  && (len % mips_saved_regsize (tdep) != 0));
d2887 2
a2888 2
	      int partial_len = (len < mips_saved_regsize (tdep)
				 ? len : mips_saved_regsize (tdep));
d2906 9
a2914 11
		      if (mips_stack_argsize (tdep) == 8
			  && (typecode == TYPE_CODE_INT
			      || typecode == TYPE_CODE_PTR
			      || typecode == TYPE_CODE_FLT)
			  && len <= 4)
			longword_offset = mips_stack_argsize (tdep) - len;
		      else if ((typecode == TYPE_CODE_STRUCT
				|| typecode == TYPE_CODE_UNION)
			       && (TYPE_LENGTH (arg_type)
				   < mips_stack_argsize (tdep)))
			longword_offset = mips_stack_argsize (tdep) - len;
d2954 1
a2954 1
				      phex (regval, mips_saved_regsize (tdep)));
d2969 1
a2969 2
		stack_offset += align_up (partial_len,
					  mips_stack_argsize (tdep));
a2994 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d3016 1
a3016 1
		     mips_stack_argsize (tdep));
d3086 2
a3087 2
	  int odd_sized_struct = ((len > mips_saved_regsize (tdep))
				  && (len % mips_saved_regsize (tdep) != 0));
d3094 2
a3095 2
	      int partial_len = (len < mips_saved_regsize (tdep)
				 ? len : mips_saved_regsize (tdep));
d3113 5
a3117 6
		      if (mips_stack_argsize (tdep) == 8
			  && (typecode == TYPE_CODE_INT
			      || typecode == TYPE_CODE_PTR
			      || typecode == TYPE_CODE_FLT)
			  && len <= 4)
			longword_offset = mips_stack_argsize (tdep) - len;
d3165 1
a3165 1
		     mips_saved_regsize(), generates a left shift as
d3168 7
a3174 8
		     sizeof (struct) >= mips_saved_regsize()).  Since
		     it is quite possible that this is GCC
		     contradicting the LE/O32 ABI, GDB has not been
		     adjusted to accommodate this.  Either someone
		     needs to demonstrate that the LE/O32 ABI
		     specifies such a left shift OR this new ABI gets
		     identified as such and GDB gets tweaked
		     accordingly.  */
d3177 1
a3177 1
		      && partial_len < mips_saved_regsize (tdep)
d3180 1
a3180 1
		    regval <<= ((mips_saved_regsize (tdep) - partial_len) *
d3186 1
a3186 1
				      phex (regval, mips_saved_regsize (tdep)));
d3201 1
a3201 2
		stack_offset += align_up (partial_len,
					  mips_stack_argsize (tdep));
a3226 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d3248 1
a3248 1
		     mips_stack_argsize (tdep));
d3268 1
a3268 1
      stack_offset += mips_stack_argsize (tdep);
d3365 1
a3365 1
	  stack_offset += align_up (len, mips_stack_argsize (tdep));
d3377 2
a3378 2
	  int odd_sized_struct = ((len > mips_saved_regsize (tdep))
				  && (len % mips_saved_regsize (tdep) != 0));
d3381 1
a3381 1
	  if (mips_saved_regsize (tdep) < 8
d3393 2
a3394 2
	      int partial_len = (len < mips_saved_regsize (tdep)
				 ? len : mips_saved_regsize (tdep));
d3412 5
a3416 6
		      if (mips_stack_argsize (tdep) == 8
			  && (typecode == TYPE_CODE_INT
			      || typecode == TYPE_CODE_PTR
			      || typecode == TYPE_CODE_FLT)
			  && len <= 4)
			longword_offset = mips_stack_argsize (tdep) - len;
d3453 1
a3453 1
		     mips_regsize() != mips_saved_regsize().  */
d3468 1
a3468 1
		     mips_saved_regsize(), generates a left shift as
d3471 7
a3477 8
		     sizeof (struct) >= mips_saved_regsize()).  Since
		     it is quite possible that this is GCC
		     contradicting the LE/O32 ABI, GDB has not been
		     adjusted to accommodate this.  Either someone
		     needs to demonstrate that the LE/O32 ABI
		     specifies such a left shift OR this new ABI gets
		     identified as such and GDB gets tweaked
		     accordingly.  */
d3479 1
a3479 1
		  if (mips_saved_regsize (tdep) < 8
d3481 1
a3481 1
		      && partial_len < mips_saved_regsize (tdep)
d3484 1
a3484 1
		    regval <<= ((mips_saved_regsize (tdep) - partial_len) *
d3490 1
a3490 1
				      phex (regval, mips_saved_regsize (tdep)));
d3510 1
a3510 2
	      stack_offset += align_up (partial_len,
					mips_stack_argsize (tdep));
a3535 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d3557 1
a3557 1
		     mips_stack_argsize (tdep));
d3577 1
a3577 1
      stack_offset += mips_stack_argsize (tdep);
d3674 1
a3674 1
	  stack_offset += align_up (len, mips_stack_argsize (tdep));
d3686 2
a3687 2
	  int odd_sized_struct = ((len > mips_saved_regsize (tdep))
				  && (len % mips_saved_regsize (tdep) != 0));
d3690 1
a3690 1
	  if (mips_saved_regsize (tdep) < 8
d3702 2
a3703 2
	      int partial_len = (len < mips_saved_regsize (tdep)
				 ? len : mips_saved_regsize (tdep));
d3721 5
a3725 6
		      if (mips_stack_argsize (tdep) == 8
			  && (typecode == TYPE_CODE_INT
			      || typecode == TYPE_CODE_PTR
			      || typecode == TYPE_CODE_FLT)
			  && len <= 4)
			longword_offset = mips_stack_argsize (tdep) - len;
d3762 1
a3762 1
		     mips_regsize() != mips_saved_regsize().  */
d3777 1
a3777 1
		     mips_saved_regsize(), generates a left shift as
d3780 7
a3786 8
		     sizeof (struct) >= mips_saved_regsize()).  Since
		     it is quite possible that this is GCC
		     contradicting the LE/O32 ABI, GDB has not been
		     adjusted to accommodate this.  Either someone
		     needs to demonstrate that the LE/O32 ABI
		     specifies such a left shift OR this new ABI gets
		     identified as such and GDB gets tweaked
		     accordingly.  */
d3788 1
a3788 1
		  if (mips_saved_regsize (tdep) < 8
d3790 1
a3790 1
		      && partial_len < mips_saved_regsize (tdep)
d3793 1
a3793 1
		    regval <<= ((mips_saved_regsize (tdep) - partial_len) *
d3799 1
a3799 1
				      phex (regval, mips_saved_regsize (tdep)));
d3819 1
a3819 2
	      stack_offset += align_up (partial_len,
					mips_stack_argsize (tdep));
a3838 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d3854 2
a3855 2
	/* Floating point registers must not be sign extended, in case
	   mips_saved_regsize() = 4 but sizeof (FP0_REGNUM) == 8.  */
d3860 1
a3860 1
							mips_saved_regsize (tdep)));
d3864 1
a3864 1
					       mips_saved_regsize (tdep)));
d3893 2
a3894 3
		      read_memory_integer ((new_sp
					    - 2 * mips_saved_regsize (tdep)),
					   mips_saved_regsize (tdep)));
d3896 2
a3897 3
		      read_memory_integer ((new_sp
					    - 3 * mips_saved_regsize (tdep)),
					   mips_saved_regsize (tdep)));
d3900 2
a3901 3
			read_memory_integer ((new_sp
					      - 4 * mips_saved_regsize (tdep)),
					     mips_saved_regsize (tdep)));
a4591 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d4636 1
a4636 1
	  && len < mips_saved_regsize (tdep))
d4639 1
a4639 1
	  lo->reg_offset = mips_saved_regsize (tdep) - len;
d4645 2
a4646 2
	       && len > mips_saved_regsize (tdep)	/* odd-size structs */
	       && len < mips_saved_regsize (tdep) * 2
d4651 2
a4652 2
	  lo->reg_offset = 2 * mips_saved_regsize (tdep) - len;
	  lo->len = mips_saved_regsize (tdep) - lo->reg_offset;
d4661 1
a4661 1
	  if (len > mips_saved_regsize (tdep))
d4663 2
a4664 2
	      lo->len = mips_saved_regsize (tdep);
	      hi->len = len - mips_saved_regsize (tdep);
d4674 1
a4674 1
	  && mips_saved_regsize (tdep) == 4)
d4902 1
a4902 1
	   offset += mips_stack_argsize (tdep), regnum++)
d4904 1
a4904 1
	  int xfer = mips_stack_argsize (tdep);
d4929 1
a4929 1
      || TYPE_LENGTH (type) > 2 * mips_saved_regsize (tdep))
d5024 12
a5100 2
  struct gdbarch_info info;
  gdbarch_info_init (&info);
d5103 1
a5103 5
  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
     instead of relying on globals.  Doing that would let generic code
     handle the search for this specific architecture.  */
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, "set mipsfpu failed");
a5108 2
  struct gdbarch_info info;
  gdbarch_info_init (&info);
d5111 1
a5111 5
  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
     instead of relying on globals.  Doing that would let generic code
     handle the search for this specific architecture.  */
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, "set mipsfpu failed");
a5116 2
  struct gdbarch_info info;
  gdbarch_info_init (&info);
d5119 1
a5119 5
  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
     instead of relying on globals.  Doing that would let generic code
     handle the search for this specific architecture.  */
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, "set mipsfpu failed");
a5646 1
  enum mips_fpu_type fpu_type;
d5648 8
a5655 11
  /* First of all, extract the elf_flags, if available.  */
  if (info.abfd && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
    elf_flags = elf_elfheader (info.abfd)->e_flags;
  else if (arches != NULL)
    elf_flags = gdbarch_tdep (arches->gdbarch)->elf_flags;
  else
    elf_flags = 0;
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog,
			"mips_gdbarch_init: elf_flags = 0x%08x\n",
			elf_flags);
d5661 1
a5661 1
      found_abi = MIPS_ABI_O32;
d5664 1
a5664 1
      found_abi = MIPS_ABI_O64;
d5667 1
a5667 1
      found_abi = MIPS_ABI_EABI32;
d5670 1
a5670 1
      found_abi = MIPS_ABI_EABI64;
d5674 1
a5674 1
	found_abi = MIPS_ABI_N32;
d5676 1
a5676 1
	found_abi = MIPS_ABI_UNKNOWN;
d5681 2
a5682 2
  if (found_abi == MIPS_ABI_UNKNOWN && info.abfd != NULL)
    bfd_map_over_sections (info.abfd, mips_find_abi_section, &found_abi);
d5684 4
a5687 4
  /* If we have no usefu BFD information, use the ABI from the last
     MIPS architecture (if there is one).  */
  if (found_abi == MIPS_ABI_UNKNOWN && info.abfd == NULL && arches != NULL)
    found_abi = gdbarch_tdep (arches->gdbarch)->found_abi;
d5690 1
a5690 1
  if (found_abi == MIPS_ABI_UNKNOWN
d5697 1
a5697 1
	  found_abi = MIPS_ABI_EABI32;
d5701 1
a5701 1
	  found_abi = MIPS_ABI_EABI64;
d5710 1
a5710 1
	    found_abi = MIPS_ABI_N64;
d5712 1
a5712 1
	    found_abi = MIPS_ABI_N32;
d5717 2
a5718 9
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog, "mips_gdbarch_init: found_abi = %d\n",
			found_abi);

  /* What has the user specified from the command line?  */
  wanted_abi = global_mips_abi ();
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog, "mips_gdbarch_init: wanted_abi = %d\n",
			wanted_abi);
d5722 2
a5725 7
  else if (found_abi != MIPS_ABI_UNKNOWN)
    mips_abi = found_abi;
  else
    mips_abi = MIPS_ABI_O32;
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog, "mips_gdbarch_init: mips_abi = %d\n",
			mips_abi);
a5726 1
  /* Also used when doing an architecture lookup.  */
d5728 11
a5738 31
    fprintf_unfiltered (gdb_stdlog,
			"mips_gdbarch_init: mips64_transfers_32bit_regs_p = %d\n",
			mips64_transfers_32bit_regs_p);

  /* Determine the MIPS FPU type.  */
  if (!mips_fpu_type_auto)
    fpu_type = mips_fpu_type;
  else if (info.bfd_arch_info != NULL
	   && info.bfd_arch_info->arch == bfd_arch_mips)
    switch (info.bfd_arch_info->mach)
      {
      case bfd_mach_mips3900:
      case bfd_mach_mips4100:
      case bfd_mach_mips4111:
	fpu_type = MIPS_FPU_NONE;
	break;
      case bfd_mach_mips4650:
	fpu_type = MIPS_FPU_SINGLE;
	break;
      default:
	fpu_type = MIPS_FPU_DOUBLE;
	break;
      }
  else if (arches != NULL)
    fpu_type = gdbarch_tdep (arches->gdbarch)->mips_fpu_type;
  else
    fpu_type = MIPS_FPU_DOUBLE;
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog,
			"mips_gdbarch_init: fpu_type = %d\n",
			fpu_type);
a5755 3
      /* Be pedantic about which FPU is selected.  */
      if (gdbarch_tdep (arches->gdbarch)->mips_fpu_type != fpu_type)
	continue;
a5763 3
  tdep->found_abi = found_abi;
  tdep->mips_abi = mips_abi;
  tdep->mips_fpu_type = fpu_type;
d5774 2
d5780 1
a5780 1
  /* Fill in the OS dependant register numbers and names.  */
a5781 1
    const char **reg_names;
d5784 1
a5795 1
	reg_names = mips_irix_reg_names;
a5807 5
	if (info.bfd_arch_info != NULL
	    && info.bfd_arch_info->mach == bfd_mach_mips3900)
	  reg_names = mips_tx39_reg_names;
	else
	  reg_names = mips_generic_reg_names;
a5814 3
    set_gdbarch_register_name (gdbarch, mips_register_name);
    tdep->mips_processor_reg_names = reg_names;
    tdep->regnum = regnum;
d5831 2
d5847 2
d5899 2
d5914 2
d5943 30
d6046 3
d6145 1
a6145 1
			  mips_mask_address_p (tdep),
d6169 3
d6175 5
a6179 2
		      "mips_dump_tdep: mips_stack_argsize() = %d\n",
		      mips_stack_argsize (tdep));
d6243 2
a6244 2
		      "mips_dump_tdep: mips_saved_regsize() = %d\n",
		      mips_saved_regsize (tdep));
@


1.129.2.4
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d84 4
a87 4
{
  mips_extra_func_info_t proc_desc;
  int num_args;
};
d109 5
a113 5
{
  MIPS_FPU_DOUBLE,		/* Full double precision floating point.  */
  MIPS_FPU_SINGLE,		/* Single precision floating point (R4650).  */
  MIPS_FPU_NONE			/* No floating point.  */
};
d125 3
a127 3
{
  /* from the elf header */
  int elf_flags;
d129 20
a148 20
  /* mips options */
  enum mips_abi mips_abi;
  enum mips_abi found_abi;
  enum mips_fpu_type mips_fpu_type;
  int mips_last_arg_regnum;
  int mips_last_fp_arg_regnum;
  int mips_default_saved_regsize;
  int mips_fp_register_double;
  int mips_default_stack_argsize;
  int default_mask_address_p;
  /* Is the target using 64-bit raw integer registers but only
     storing a left-aligned 32-bit value in each?  */
  int mips64_transfers_32bit_regs_p;
  /* Indexes for various registers.  IRIX and embedded have
     different values.  This contains the "public" fields.  Don't
     add any that do not need to be public.  */
  const struct mips_regnum *regnum;
  /* Register names table for the current register set.  */
  const char **mips_processor_reg_names;
};
d199 1
a199 2
  return (extract_signed_integer
	  (buf, register_size (current_gdbarch, regnum)));
d247 1
a247 1
  else				/* if (mips_saved_regsize_string == size_32) */
d262 1
a262 1
mips_elf_make_msymbol_special (asymbol * sym, struct minimal_symbol *msym)
d264 6
a269 6
  if (((elf_symbol_type *) (sym))->internal_elf_sym.st_other == STO_MIPS16)
    {
      MSYMBOL_INFO (msym) = (char *)
	(((long) MSYMBOL_INFO (msym)) | 0x80000000);
      SYMBOL_VALUE_ADDRESS (msym) |= 1;
    }
d285 2
a286 2
		    enum bfd_endian endian, bfd_byte * in,
		    const bfd_byte * out, int buf_offset)
d301 1
a301 1
    case BFD_ENDIAN_UNKNOWN:	/* Indicates no alignment.  */
d319 1
a319 2
    regcache_cooked_read_part (regcache, reg_num, reg_offset, length,
			       in + buf_offset);
d321 1
a321 2
    regcache_cooked_write_part (regcache, reg_num, reg_offset, length,
				out + buf_offset);
d342 1
a342 2
  if (register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0) ==
      4)
d376 1
a376 1
  else				/* if (mips_stack_argsize_string == size_32) */
d410 1
a410 2
enum
{ NUM_MIPS_PROCESSOR_REGS = (90 - 32) };
d415 8
a422 8
  "sr", "lo", "hi", "bad", "cause", "pc",
  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
  "fsr", "fir", "" /*"fp" */ , "",
  "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "",
d428 8
a435 8
  "sr", "lo", "hi", "bad", "cause", "pc",
  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
  "fsr", "fir", "", /*"fp" */ "",
  "", "", "bus", "ccfg", "", "", "", "",
  "", "", "port", "cmp", "", "", "epc", "prid",
d441 8
a448 8
  "sr", "lo", "hi", "bad", "cause", "pc",
  "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "",
  "", "", "", "",
  "", "", "", "", "", "", "", "",
  "", "", "config", "cache", "debug", "depc", "epc", ""
d453 5
a457 5
  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
  "pc", "cause", "bad", "hi", "lo", "fsr", "fir"
d468 4
a471 4
    "zero", "at", "v0", "v1", "a0", "a1", "a2", "a3",
    "t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7",
    "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
    "t8", "t9", "k0", "k1", "gp", "sp", "s8", "ra",
d476 4
a479 4
    "zero", "at", "v0", "v1", "a0", "a1", "a2", "a3",
    "a4", "a5", "a6", "a7", "t0", "t1", "t2", "t3",
    "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
    "t8", "t9", "k0", "k1", "gp", "sp", "s8", "ra"
d528 2
a529 1
  if (REGISTER_NAME (regnum) == NULL || REGISTER_NAME (regnum)[0] == '\0')
d545 1
a545 1
  return 0;
d560 1
a560 2
  else if (register_size (gdbarch, rawnum) >
	   register_size (gdbarch, cookednum))
d573 2
a574 3
mips_pseudo_register_write (struct gdbarch *gdbarch,
			    struct regcache *regcache, int cookednum,
			    const void *buf)
d580 1
a580 2
  else if (register_size (gdbarch, rawnum) >
	   register_size (gdbarch, cookednum))
d593 2
a594 1
static int mips16_to_32_reg[8] = { 16, 17, 2, 3, 4, 5, 6, 7 };
d620 4
a623 4
{
  struct mips_extra_func_info info;
  struct linked_proc_info *next;
}
d655 3
a657 3
	  && (regnum % NUM_REGS) >= mips_regnum (current_gdbarch)->fp0
	  && (regnum % NUM_REGS) < mips_regnum (current_gdbarch)->fp0 + 32
	  && TYPE_CODE (type) == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8);
d705 1
a705 2
  else if (regnum >=
	   (NUM_REGS + mips_regnum (current_gdbarch)->fp_control_status)
d748 2
a749 1
      internal_error (__FILE__, __LINE__, "mips_mask_address_p: bad switch");
d767 2
a768 3
      printf_filtered
	("The 32 bit address mask is set automatically.  Currently %s\n",
	 mips_mask_address_p (tdep) ? "enabled" : "disabled");
d771 2
a772 1
      internal_error (__FILE__, __LINE__, "show_mask_address: bad switch");
d777 26
d830 1
a830 7
  return read_signed_register_pid (mips_regnum (current_gdbarch)->pc, ptid);
}

static void
mips_write_pc (CORE_ADDR pc, ptid_t ptid)
{
  write_register_pid (mips_regnum (current_gdbarch)->pc, pc, ptid);
d837 2
a838 1
after_prologue (CORE_ADDR pc, mips_extra_func_info_t proc_desc)
d885 1
a885 1
  if ((inst & 0xffe00000) == 0xafa00000	/* sw reg,n($sp) */
d898 1
a898 1
	   || (inst & 0xffe00000) == 0xe7c00000	/* swc1 freg,n($r30) */
d996 1
a996 1
	/* BEQL, BNEL, BLEZL, BGTZL: bits 0101xx */
d1014 1
a1014 1
	/* BC1F, BC1FL, BC1T, BC1TL: 010001 01000 */
d1018 1
a1018 3
	  int fcrcs =
	    read_signed_register (mips_regnum (current_gdbarch)->
				  fp_control_status);
d1048 1
a1048 1
	  break;		/* end SPECIAL */
d1078 1
a1078 1
	  break;		/* end REGIMM */
d1170 5
a1174 5
{
  CORE_ADDR offset;
  unsigned int regx;		/* Function in i8 type */
  unsigned int regy;
};
d1214 2
a1215 1
	       enum mips16_inst_fmts insn_format, struct upk_mips16 *upk)
d1229 1
a1229 1
	    value |= inst & 0x7ff;	/* eleven bits from instruction */
d1288 2
a1289 1
      internal_error (__FILE__, __LINE__, "bad switch");
d1305 2
a1306 1
			 unsigned int extension, unsigned int insn)
d1311 1
a1311 1
    case 2:			/* Branch */
d1325 1
a1325 1
    case 3:			/* JAL , JALX - Watch out, these are 32 bit instruction */
d1336 1
a1336 1
    case 4:			/* beqz */
d1348 1
a1348 1
    case 5:			/* bnez */
d1360 1
a1360 1
    case 12:			/* I8 Formats btez btnez */
d1375 1
a1375 1
    case 29:			/* RR Formats JR, JALR, JALR-RA */
d1392 1
a1392 1
		break;		/* Function return instruction */
d1398 1
a1398 1
		break;		/* BOGUS Guess */
d1488 2
a1489 3
	  CORE_ADDR reg_position =
	    (get_frame_base (fci) + SIGFRAME_REGSAVE_OFF +
	     ireg * mips_regsize (current_gdbarch));
d1497 1
a1497 3
	  set_reg_offset (saved_regs,
			  mips_regnum (current_gdbarch)->fp0 + ireg,
			  reg_position);
d1500 1
a1500 2
      set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->pc,
		      get_frame_base (fci) + SIGFRAME_PC_OFF);
d1517 4
a1520 4
  if (				/* In any frame other than the innermost or a frame interrupted
				   by a signal, we assume that all registers have been saved.
				   This assumes that all register saves in a function happen
				   before the first function call.  */
d1523 1
d1526 1
d1528 2
a1529 1
          Outside the prologue, we know where everything is. */
d1531 1
d1533 3
a1535 3
          kernel saves the registers without a prologue doing it, we
          better not examine the prologue to see whether registers
          have been saved yet.  */
d1600 1
a1600 1
	     stack.  */
d1624 5
a1628 5
	         are paired to form doubles such that the most
	         significant part is in $f[N+1] and the least
	         significant in $f[N] vis: $f[N+1] ||| $f[N].  The
	         registers are also spilled as a pair and stored as a
	         double.
d1634 11
a1644 11
	         Unfortunately, when big-endian the most significant
	         part of the double is stored first, and the least
	         significant is stored second.  This leads to the
	         registers being ordered in memory as firt $f[N+1] and
	         then $f[N].

	         For the big-endian case make certain that the
	         addresses point at the correct (swapped) locations
	         $f[N] and $f[N+1] pair (keep in mind that
	         reg_position is decremented each time through the
	         loop).  */
d1646 1
a1646 2
		set_reg_offset (saved_regs,
				mips_regnum (current_gdbarch)->fp0 + ireg,
d1649 1
a1649 2
		set_reg_offset (saved_regs,
				mips_regnum (current_gdbarch)->fp0 + ireg,
d1653 1
a1653 3
	    set_reg_offset (saved_regs,
			    mips_regnum (current_gdbarch)->fp0 + ireg,
			    reg_position);
d1657 1
a1657 2
    set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->pc,
		    saved_regs[RA_REGNUM]);
d1692 2
a1693 1
  if (mips_mask_address_p (tdep) && (((ULONGEST) addr) >> 32 == 0xffffffffUL))
d1732 1
a1732 1
      pc = read_register (mips_regnum (current_gdbarch)->pc);
d1749 2
a1750 1
	? DEPRECATED_FRAME_SAVED_PC (get_next_frame (prev)) : read_pc ());
d1765 1
a1765 1
      saved_pc = frame_unwind_register_signed (frame, NUM_REGS + mips_regnum (current_gdbarch)->pc);
d1773 2
a1774 2
					 - mips_saved_regsize (tdep)),
					mips_saved_regsize (tdep));
d1779 1
a1779 2
	  int pcreg = (get_frame_type (frame) == SIGTRAMP_FRAME
		       ? mips_regnum (current_gdbarch)->pc
d1855 2
a1856 1
  if (heuristic_fence_post == UINT_MAX || fence < VM_MIN_ADDRESS)
d1873 2
a1874 3
	    warning
	      ("Warning: GDB can't find the start of the function at 0x%s.",
	       paddr_nz (pc));
d1894 2
a1895 1
heuristic-fence-post' command.\n", paddr_nz (pc), paddr_nz (pc));
d1941 3
a1943 3
		int nbits,	/* number of bits in imm field */
		int scale,	/* scale factor to be applied to imm */
		int is_signed)	/* is the imm field signed? */
d1995 1
a1995 1
	  || (inst & 0xff00) == 0xfb00)	/* daddiu sp */
d2156 1
a2156 2
	  set_reg_offset (temp_saved_regs, reg,
			  sp + low_word + 8 - mips_regsize (current_gdbarch));
d2289 1
a2289 1
         the information normally found in ECOFF PDRs.  */
d2301 1
a2301 1
	  priv = obstack_alloc (&sec->objfile->objfile_obstack,
d2310 1
a2310 1
	  priv = obstack_alloc (&sec->objfile->objfile_obstack,
d2317 1
a2317 1
	      priv->contents = obstack_alloc (&sec->objfile->objfile_obstack,
d2323 4
a2326 5
	         presence of multiple code sections (and other corner cases)
	         it can become unsorted.  Sort it so that we can use a faster
	         binary search.  */
	      qsort (priv->contents, priv->size / 32, 32,
		     compare_pdr_entries);
d2368 1
a2368 1
		obstack_alloc (&sec->objfile->objfile_obstack,
d2403 2
a2404 2
         print_frame_info.  It might be better to move this check into
         symbol reading.  */
d2450 2
a2451 1
				  (SYMBOL_BLOCK_VALUE (proc_symbol)), 0);
d2481 2
a2482 1
      proc_desc = heuristic_proc_desc (startaddr, pc, next_frame, cur_frame);
d2488 2
a2489 1
get_frame_pointer (struct frame_info *frame, mips_extra_func_info_t proc_desc)
d2492 2
a2493 1
	  + PROC_FRAME_OFFSET (proc_desc) - PROC_FRAME_ADJUST (proc_desc));
d2531 1
a2531 1
         and have frame size zero.  */
d2558 1
a2558 1
		      NULL /* i.e, get_next_frame (fci) */ ,
d2573 1
a2573 5
	deprecated_update_frame_base_hack (fci,
					   read_next_frame_reg (get_next_frame
								(fci),
								NUM_REGS +
								SP_REGNUM));
d2576 6
a2581 6
	   generic dummy frame's top-of-stack (since the draft
	   fci->frame is obtained by returning the unwound stack
	   pointer) and that is what we want.  That way the fci->frame
	   value will match the top-of-stack value that was saved as
	   part of the dummy frames data.  */
	/* Do nothing.  */ ;
d2583 1
a2583 4
	deprecated_update_frame_base_hack (fci,
					   get_frame_pointer (get_next_frame
							      (fci),
							      proc_desc));
d2594 2
a2595 2
	     frame.c:get_prev_frame() is modified to set the frame's
	     type before calling functions like this.  */
d2609 1
a2609 1
	      set_reg_offset (temp_saved_regs, mips_regnum (current_gdbarch)->pc,
d2665 1
a2665 2
	       && (typecode == TYPE_CODE_STRUCT
		   || typecode == TYPE_CODE_UNION)
a2707 139
/* Determine how a return value is stored within the MIPS register
   file, given the return type `valtype'. */

struct return_value_word
{
  int len;
  int reg;
  int reg_offset;
  int buf_offset;
};

static void
return_value_location (struct type *valtype,
		       struct return_value_word *hi,
		       struct return_value_word *lo)
{
  int len = TYPE_LENGTH (valtype);
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (TYPE_CODE (valtype) == TYPE_CODE_FLT
      && ((MIPS_FPU_TYPE == MIPS_FPU_DOUBLE && (len == 4 || len == 8))
	  || (MIPS_FPU_TYPE == MIPS_FPU_SINGLE && len == 4)))
    {
      if (!FP_REGISTER_DOUBLE && len == 8)
	{
	  /* We need to break a 64bit float in two 32 bit halves and
	     spread them across a floating-point register pair. */
	  lo->buf_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 4 : 0;
	  hi->buf_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 0 : 4;
	  lo->reg_offset = ((TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
			     && register_size (current_gdbarch,
					       mips_regnum (current_gdbarch)->
					       fp0) == 8) ? 4 : 0);
	  hi->reg_offset = lo->reg_offset;
	  lo->reg = mips_regnum (current_gdbarch)->fp0 + 0;
	  hi->reg = mips_regnum (current_gdbarch)->fp0 + 1;
	  lo->len = 4;
	  hi->len = 4;
	}
      else
	{
	  /* The floating point value fits in a single floating-point
	     register. */
	  lo->reg_offset = ((TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
			     && register_size (current_gdbarch,
					       mips_regnum (current_gdbarch)->
					       fp0) == 8
			     && len == 4) ? 4 : 0);
	  lo->reg = mips_regnum (current_gdbarch)->fp0;
	  lo->len = len;
	  lo->buf_offset = 0;
	  hi->len = 0;
	  hi->reg_offset = 0;
	  hi->buf_offset = 0;
	  hi->reg = 0;
	}
    }
  else
    {
      /* Locate a result possibly spread across two registers. */
      int regnum = 2;
      lo->reg = regnum + 0;
      hi->reg = regnum + 1;
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && len < mips_saved_regsize (tdep))
	{
	  /* "un-left-justify" the value in the low register */
	  lo->reg_offset = mips_saved_regsize (tdep) - len;
	  lo->len = len;
	  hi->reg_offset = 0;
	  hi->len = 0;
	}
      else if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG && len > mips_saved_regsize (tdep)	/* odd-size structs */
	       && len < mips_saved_regsize (tdep) * 2
	       && (TYPE_CODE (valtype) == TYPE_CODE_STRUCT ||
		   TYPE_CODE (valtype) == TYPE_CODE_UNION))
	{
	  /* "un-left-justify" the value spread across two registers. */
	  lo->reg_offset = 2 * mips_saved_regsize (tdep) - len;
	  lo->len = mips_saved_regsize (tdep) - lo->reg_offset;
	  hi->reg_offset = 0;
	  hi->len = len - lo->len;
	}
      else
	{
	  /* Only perform a partial copy of the second register. */
	  lo->reg_offset = 0;
	  hi->reg_offset = 0;
	  if (len > mips_saved_regsize (tdep))
	    {
	      lo->len = mips_saved_regsize (tdep);
	      hi->len = len - mips_saved_regsize (tdep);
	    }
	  else
	    {
	      lo->len = len;
	      hi->len = 0;
	    }
	}
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && register_size (current_gdbarch, regnum) == 8
	  && mips_saved_regsize (tdep) == 4)
	{
	  /* Account for the fact that only the least-signficant part
	     of the register is being used */
	  lo->reg_offset += 4;
	  hi->reg_offset += 4;
	}
      lo->buf_offset = 0;
      hi->buf_offset = lo->len;
    }
}

/* Should call_function allocate stack space for a struct return?  */

static int
mips_eabi_use_struct_convention (int gcc_p, struct type *type)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  return (TYPE_LENGTH (type) > 2 * mips_saved_regsize (tdep));
}

/* Should call_function pass struct by reference? 
   For each architecture, structs are passed either by
   value or by reference, depending on their size.  */

static int
mips_eabi_reg_struct_has_addr (int gcc_p, struct type *type)
{
  enum type_code typecode = TYPE_CODE (check_typedef (type));
  int len = TYPE_LENGTH (check_typedef (type));
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION)
    return (len > mips_saved_regsize (tdep));

  return 0;
}

d2710 3
a2712 3
			   struct regcache *regcache, CORE_ADDR bp_addr,
			   int nargs, struct value **args, CORE_ADDR sp,
			   int struct_return, CORE_ADDR struct_addr)
d2742 1
a2742 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])),
d2747 1
a2747 1
    fprintf_unfiltered (gdb_stdlog,
d2803 2
a2804 1
      if (!FP_REGISTER_DOUBLE && fp_register_arg_p (typecode, arg_type))
d2849 1
a2849 1
	         above to ensure that it is even register aligned.  */
d2871 1
a2871 1
	     register are only written to memory.  */
d2898 2
a2899 1
			      || typecode == TYPE_CODE_FLT) && len <= 4)
d2921 1
a2921 1
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ",
d2925 1
a2925 1
			  fprintf_unfiltered (gdb_stdlog, "%02x",
d2936 1
a2936 1
	         purpose register.  */
d2940 1
a2940 2
		  LONGEST regval =
		    extract_unsigned_integer (val, partial_len);
d2945 1
a2945 2
				      phex (regval,
					    mips_saved_regsize (tdep)));
d2954 1
a2954 1
	         will copy the next parameter.
d2974 1
a2974 50
/* Given a return value in `regbuf' with a type `valtype', extract and
   copy its value into `valbuf'. */

static void
mips_eabi_extract_return_value (struct type *valtype,
				char regbuf[], char *valbuf)
{
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memcpy (valbuf + lo.buf_offset,
	  regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + lo.reg) +
	  lo.reg_offset, lo.len);

  if (hi.len > 0)
    memcpy (valbuf + hi.buf_offset,
	    regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + hi.reg) +
	    hi.reg_offset, hi.len);
}

/* Given a return value in `valbuf' with a type `valtype', write it's
   value into the appropriate register. */

static void
mips_eabi_store_return_value (struct type *valtype, char *valbuf)
{
  char raw_buffer[MAX_REGISTER_SIZE];
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memset (raw_buffer, 0, sizeof (raw_buffer));
  memcpy (raw_buffer + lo.reg_offset, valbuf + lo.buf_offset, lo.len);
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (lo.reg),
				   raw_buffer, register_size (current_gdbarch,
							      lo.reg));

  if (hi.len > 0)
    {
      memset (raw_buffer, 0, sizeof (raw_buffer));
      memcpy (raw_buffer + hi.reg_offset, valbuf + hi.buf_offset, hi.len);
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (hi.reg),
				       raw_buffer,
				       register_size (current_gdbarch,
						      hi.reg));
    }
}

/* N32/N64 ABI stuff.  */
d2978 3
a2980 3
			     struct regcache *regcache, CORE_ADDR bp_addr,
			     int nargs, struct value **args, CORE_ADDR sp,
			     int struct_return, CORE_ADDR struct_addr)
d3008 1
a3008 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])),
d3013 1
a3013 1
    fprintf_unfiltered (gdb_stdlog,
d3082 1
a3082 1
	     register are only written to memory.  */
d3109 2
a3110 1
			      || typecode == TYPE_CODE_FLT) && len <= 4)
d3127 1
a3127 1
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ",
d3131 1
a3131 1
			  fprintf_unfiltered (gdb_stdlog, "%02x",
d3142 1
a3142 1
	         purpose register.  */
d3146 1
a3146 2
		  LONGEST regval =
		    extract_unsigned_integer (val, partial_len);
d3181 1
a3181 2
				      phex (regval,
					    mips_saved_regsize (tdep)));
d3190 1
a3190 1
	         will copy the next parameter.
d3210 7
a3216 4
static enum return_value_convention
mips_n32n64_return_value (struct gdbarch *gdbarch,
			  struct type *type, struct regcache *regcache,
			  void *readbuf, const void *writebuf)
d3218 17
a3234 124
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      || TYPE_CODE (type) == TYPE_CODE_UNION
      || TYPE_CODE (type) == TYPE_CODE_ARRAY
      || TYPE_LENGTH (type) > 2 * mips_saved_regsize (tdep))
    return RETURN_VALUE_STRUCT_CONVENTION;
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A floating-point value belongs in the least significant part
         of FP0.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $fp0\n");
      mips_xfer_register (regcache,
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
			  TYPE_LENGTH (type),
			  TARGET_BYTE_ORDER, readbuf, writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   && TYPE_NFIELDS (type) <= 2
	   && TYPE_NFIELDS (type) >= 1
	   && ((TYPE_NFIELDS (type) == 1
		&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		    == TYPE_CODE_FLT))
	       || (TYPE_NFIELDS (type) == 2
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		       == TYPE_CODE_FLT)
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 1))
		       == TYPE_CODE_FLT)))
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A struct that contains one or two floats.  Each value is part
         in the least significant part of their floating point
         register..  */
      bfd_byte reg[MAX_REGISTER_SIZE];
      int regnum;
      int field;
      for (field = 0, regnum = mips_regnum (current_gdbarch)->fp0;
	   field < TYPE_NFIELDS (type); field++, regnum += 2)
	{
	  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])
			/ TARGET_CHAR_BIT);
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return float struct+%d\n",
				offset);
	  mips_xfer_register (regcache, NUM_REGS + regnum,
			      TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (type) == TYPE_CODE_UNION)
    {
      /* A structure or union.  Extract the left justified value,
         regardless of the byte order.  I.e. DO NOT USE
         mips_xfer_lower.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += register_size (current_gdbarch, regnum), regnum++)
	{
	  int xfer = register_size (current_gdbarch, regnum);
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return struct+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      BFD_ENDIAN_UNKNOWN, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else
    {
      /* A scalar extract each part but least-significant-byte
         justified.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += register_size (current_gdbarch, regnum), regnum++)
	{
	  int xfer = register_size (current_gdbarch, regnum);
	  int pos = 0;
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return scalar+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
}

/* O32 ABI stuff.  */

static CORE_ADDR
mips_o32_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			  struct regcache *regcache, CORE_ADDR bp_addr,
			  int nargs, struct value **args, CORE_ADDR sp,
			  int struct_return, CORE_ADDR struct_addr)
{
  int argreg;
  int float_argreg;
  int argnum;
  int len = 0;
  int stack_offset = 0;
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* For shared libraries, "t9" needs to point at the function
     address.  */
  regcache_cooked_write_signed (regcache, T9_REGNUM, func_addr);

  /* Set the return address register to point to the entry point of
     the program, where a breakpoint lies in wait.  */
  regcache_cooked_write_signed (regcache, RA_REGNUM, bp_addr);

  /* First ensure that the stack and structure return address (if any)
     are properly aligned.  The stack has to be at least 64-bit
d3244 1
a3244 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])),
d3249 1
a3249 1
    fprintf_unfiltered (gdb_stdlog,
d3292 2
a3293 1
      if (!FP_REGISTER_DOUBLE && fp_register_arg_p (typecode, arg_type))
d3345 1
a3345 1
	         above to ensure that it is even register aligned.  */
d3352 3
a3354 3
	         registers for each argument.  The below is (my
	         guess) to ensure that the corresponding integer
	         register has reserved the same space.  */
d3382 1
a3382 1
		argreg++;
d3385 1
a3385 1
	     register are only written to memory.  */
d3412 2
a3413 1
			      || typecode == TYPE_CODE_FLT) && len <= 4)
d3430 1
a3430 1
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ",
d3434 1
a3434 1
			  fprintf_unfiltered (gdb_stdlog, "%02x",
d3445 1
a3445 1
	         purpose register.  */
d3489 1
a3489 2
				      phex (regval,
					    mips_saved_regsize (tdep)));
d3502 1
a3502 1
	         will copy the next parameter.
d3504 4
a3507 4
	         In older ABIs, the caller reserved space for
	         registers that contained arguments.  This was loosely
	         refered to as their "home".  Consequently, space is
	         always allocated.  */
d3523 1
a3523 142
static enum return_value_convention
mips_o32_return_value (struct gdbarch *gdbarch, struct type *type,
		       struct regcache *regcache,
		       void *readbuf, const void *writebuf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      || TYPE_CODE (type) == TYPE_CODE_UNION
      || TYPE_CODE (type) == TYPE_CODE_ARRAY)
    return RETURN_VALUE_STRUCT_CONVENTION;
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && TYPE_LENGTH (type) == 4 && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A single-precision floating-point value.  It fits in the
         least significant part of FP0.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $fp0\n");
      mips_xfer_register (regcache,
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
			  TYPE_LENGTH (type),
			  TARGET_BYTE_ORDER, readbuf, writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && TYPE_LENGTH (type) == 8 && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A double-precision floating-point value.  The most
         significant part goes in FP1, and the least significant in
         FP0.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $fp1/$fp0\n");
      switch (TARGET_BYTE_ORDER)
	{
	case BFD_ENDIAN_LITTLE:
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 +
			      0, 4, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 +
			      1, 4, TARGET_BYTE_ORDER, readbuf, writebuf, 4);
	  break;
	case BFD_ENDIAN_BIG:
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 +
			      1, 4, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 +
			      0, 4, TARGET_BYTE_ORDER, readbuf, writebuf, 4);
	  break;
	default:
	  internal_error (__FILE__, __LINE__, "bad switch");
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
#if 0
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   && TYPE_NFIELDS (type) <= 2
	   && TYPE_NFIELDS (type) >= 1
	   && ((TYPE_NFIELDS (type) == 1
		&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		    == TYPE_CODE_FLT))
	       || (TYPE_NFIELDS (type) == 2
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		       == TYPE_CODE_FLT)
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 1))
		       == TYPE_CODE_FLT)))
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A struct that contains one or two floats.  Each value is part
         in the least significant part of their floating point
         register..  */
      bfd_byte reg[MAX_REGISTER_SIZE];
      int regnum;
      int field;
      for (field = 0, regnum = mips_regnum (current_gdbarch)->fp0;
	   field < TYPE_NFIELDS (type); field++, regnum += 2)
	{
	  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])
			/ TARGET_CHAR_BIT);
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return float struct+%d\n",
				offset);
	  mips_xfer_register (regcache, NUM_REGS + regnum,
			      TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
#endif
#if 0
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (type) == TYPE_CODE_UNION)
    {
      /* A structure or union.  Extract the left justified value,
         regardless of the byte order.  I.e. DO NOT USE
         mips_xfer_lower.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += register_size (current_gdbarch, regnum), regnum++)
	{
	  int xfer = register_size (current_gdbarch, regnum);
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return struct+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      BFD_ENDIAN_UNKNOWN, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
#endif
  else
    {
      /* A scalar extract each part but least-significant-byte
         justified.  o32 thinks registers are 4 byte, regardless of
         the ISA.  mips_stack_argsize controls this.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += mips_stack_argsize (tdep), regnum++)
	{
	  int xfer = mips_stack_argsize (tdep);
	  int pos = 0;
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return scalar+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
}

/* O64 ABI.  This is a hacked up kind of 64-bit version of the o32
   ABI.  */
d3527 3
a3529 4
			  struct regcache *regcache, CORE_ADDR bp_addr,
			  int nargs,
			  struct value **args, CORE_ADDR sp,
			  int struct_return, CORE_ADDR struct_addr)
d3557 1
a3557 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])),
d3562 1
a3562 1
    fprintf_unfiltered (gdb_stdlog,
d3605 2
a3606 1
      if (!FP_REGISTER_DOUBLE && fp_register_arg_p (typecode, arg_type))
d3658 1
a3658 1
	         above to ensure that it is even register aligned.  */
d3665 3
a3667 3
	         registers for each argument.  The below is (my
	         guess) to ensure that the corresponding integer
	         register has reserved the same space.  */
d3695 1
a3695 1
		argreg++;
d3698 1
a3698 1
	     register are only written to memory.  */
d3725 2
a3726 1
			      || typecode == TYPE_CODE_FLT) && len <= 4)
d3743 1
a3743 1
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ",
d3747 1
a3747 1
			  fprintf_unfiltered (gdb_stdlog, "%02x",
d3758 1
a3758 1
	         purpose register.  */
d3802 1
a3802 2
				      phex (regval,
					    mips_saved_regsize (tdep)));
d3815 1
a3815 1
	         will copy the next parameter.
d3817 4
a3820 4
	         In older ABIs, the caller reserved space for
	         registers that contained arguments.  This was loosely
	         refered to as their "home".  Consequently, space is
	         always allocated.  */
d3837 1
a3837 2
mips_o64_extract_return_value (struct type *valtype,
			       char regbuf[], char *valbuf)
d3839 5
a3843 3
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);
d3845 5
a3849 49
  memcpy (valbuf + lo.buf_offset,
	  regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + lo.reg) +
	  lo.reg_offset, lo.len);

  if (hi.len > 0)
    memcpy (valbuf + hi.buf_offset,
	    regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + hi.reg) +
	    hi.reg_offset, hi.len);
}

static void
mips_o64_store_return_value (struct type *valtype, char *valbuf)
{
  char raw_buffer[MAX_REGISTER_SIZE];
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memset (raw_buffer, 0, sizeof (raw_buffer));
  memcpy (raw_buffer + lo.reg_offset, valbuf + lo.buf_offset, lo.len);
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (lo.reg),
				   raw_buffer, register_size (current_gdbarch,
							      lo.reg));

  if (hi.len > 0)
    {
      memset (raw_buffer, 0, sizeof (raw_buffer));
      memcpy (raw_buffer + hi.reg_offset, valbuf + hi.buf_offset, hi.len);
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (hi.reg),
				       raw_buffer,
				       register_size (current_gdbarch,
						      hi.reg));
    }
}

static void
mips_pop_frame (void)
{
  int regnum;
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR new_sp = get_frame_base (frame);
  mips_extra_func_info_t proc_desc;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), 0, 0))
    {
      generic_pop_dummy_frame ();
      flush_cached_frames ();
      return;
d3853 1
a3853 2
  write_register (mips_regnum (current_gdbarch)->pc,
		  DEPRECATED_FRAME_SAVED_PC (frame));
d3856 1
a3856 1
    if (regnum != SP_REGNUM && regnum != mips_regnum (current_gdbarch)->pc
d3862 1
a3862 2
	if (mips_regnum (current_gdbarch)->fp0 <= regnum
	    && regnum < mips_regnum (current_gdbarch)->fp0 + 32)
d3864 2
a3865 3
			  read_memory_unsigned_integer
			  (deprecated_get_frame_saved_regs (frame)[regnum],
			   mips_saved_regsize (tdep)));
d3868 1
a3868 2
			  read_memory_integer (deprecated_get_frame_saved_regs
					       (frame)[regnum],
d3880 2
a3881 1
	   pi_ptr != NULL; prev_ptr = pi_ptr, pi_ptr = pi_ptr->next)
d3908 1
a3908 2
					      -
					      4 * mips_saved_regsize (tdep)),
d3976 1
a3976 1
         32 bits.  */
d4005 1
a4005 1
         all 64 bits.  */
d4017 1
a4017 1
         each register.  */
d4039 1
a4039 4
  raw_buffer =
    (char *) alloca (2 *
		     register_size (current_gdbarch,
				    mips_regnum (current_gdbarch)->fp0));
d4052 1
a4052 2
      print_scalar_formatted (raw_buffer, builtin_type_uint32, 'x', 'w',
			      file);
d4064 1
a4064 1
				&inv2);
d4083 1
a4083 2
      print_scalar_formatted (raw_buffer, builtin_type_uint64, 'x', 'g',
			      file);
d4132 1
a4132 3
    offset =
      register_size (current_gdbarch,
		     regnum) - register_size (current_gdbarch, regnum);
d4136 2
a4137 3
  print_scalar_formatted (raw_buffer + offset,
			  gdbarch_register_type (gdbarch, regnum), 'x', 0,
			  file);
d4170 2
a4171 1
       col < ncols && regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
d4175 1
a4175 2
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
	  TYPE_CODE_FLT)
d4177 1
a4177 2
      fprintf_filtered (file,
			mips_regsize (current_gdbarch) == 8 ? "%17s" : "%9s",
d4189 2
a4190 1
       col < ncols && regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
d4194 1
a4194 2
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
	  TYPE_CODE_FLT)
d4202 2
a4203 1
		   - register_size (current_gdbarch, regnum)); byte++)
d4207 3
a4209 4
	for (byte =
	     register_size (current_gdbarch,
			    regnum) - register_size (current_gdbarch, regnum);
	     byte < register_size (current_gdbarch, regnum); byte++)
d4213 2
a4214 1
	     byte >= 0; byte--)
d4246 1
a4246 2
	  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
	      TYPE_CODE_FLT)
d4289 1
a4289 2
  return is_delayed ((unsigned long)
		     extract_unsigned_integer (buf, MIPS_INSTLEN));
d4332 1
a4332 1
	     line mark the prologue -> body transition.  */
d4362 1
a4362 1
    end_pc = pc + 100;		/* Magic.  */
d4401 511
a4911 11
      else if (high_word == 0x279c)	/* addiu $gp,$gp,n */
	continue;
      else if (inst == 0x0399e021	/* addu $gp,$gp,$t9 */
	       || inst == 0x033ce021)	/* addu $gp,$t9,$gp */
	continue;
      /* The following instructions load $at or $t0 with an immediate
         value in preparation for a stack adjustment via
         subu $sp,$sp,[$at,$t0]. These instructions could also initialize
         a local variable, so we accept them only before a stack adjustment
         instruction was seen.  */
      else if (!seen_sp_adjust)
d4913 9
a4921 16
	  if (high_word == 0x3c01 ||	/* lui $at,n */
	      high_word == 0x3c08)	/* lui $t0,n */
	    {
	      load_immediate_bytes += MIPS_INSTLEN;	/* FIXME!! */
	      continue;
	    }
	  else if (high_word == 0x3421 ||	/* ori $at,$at,n */
		   high_word == 0x3508 ||	/* ori $t0,$t0,n */
		   high_word == 0x3401 ||	/* ori $at,$zero,n */
		   high_word == 0x3408)	/* ori $t0,$zero,n */
	    {
	      load_immediate_bytes += MIPS_INSTLEN;	/* FIXME!! */
	      continue;
	    }
	  else
	    break;
d4923 1
a4923 2
      else
	break;
a4924 7

  /* In a frameless function, we might have incorrectly
     skipped some load immediate instructions. Undo the skipping
     if the load immediate was not followed by a stack adjustment.  */
  if (load_immediate_bytes && !seen_sp_adjust)
    pc -= load_immediate_bytes;
  return pc;
d4927 1
a4927 2
/* Skip the PC past function prologue instructions (16-bit version).
   This is a helper function for mips_skip_prologue.  */
d4929 4
a4932 2
static CORE_ADDR
mips16_skip_prologue (CORE_ADDR pc)
d4934 8
a4941 12
  CORE_ADDR end_pc;
  int extend_bytes = 0;
  int prev_extend_bytes;

  /* Table of instructions likely to be found in a function prologue.  */
  static struct
  {
    unsigned short inst;
    unsigned short mask;
  }
  table[] =
  {
d4943 22
a4964 2
    0x6300, 0xff00}
    ,				/* addiu $sp,offset */
d4966 22
a4987 2
    0xfb00, 0xff00}
    ,				/* daddiu $sp,offset */
d4989 8
a4996 50
    0xd000, 0xf800}
    ,				/* sw reg,n($sp) */
    {
    0xf900, 0xff00}
    ,				/* sd reg,n($sp) */
    {
    0x6200, 0xff00}
    ,				/* sw $ra,n($sp) */
    {
    0xfa00, 0xff00}
    ,				/* sd $ra,n($sp) */
    {
    0x673d, 0xffff}
    ,				/* move $s1,sp */
    {
    0xd980, 0xff80}
    ,				/* sw $a0-$a3,n($s1) */
    {
    0x6704, 0xff1c}
    ,				/* move reg,$a0-$a3 */
    {
    0xe809, 0xf81f}
    ,				/* entry pseudo-op */
    {
    0x0100, 0xff00}
    ,				/* addiu $s1,$sp,n */
    {
    0, 0}			/* end of table marker */
  };

  /* Find an upper bound on the prologue.  */
  end_pc = skip_prologue_using_sal (pc);
  if (end_pc == 0)
    end_pc = pc + 100;		/* Magic.  */

  /* Skip the typical prologue instructions. These are the stack adjustment
     instruction and the instructions that save registers on the stack
     or in the gcc frame.  */
  for (; pc < end_pc; pc += MIPS16_INSTLEN)
    {
      unsigned short inst;
      int i;

      inst = mips_fetch_instruction (pc);

      /* Normally we ignore an extend instruction.  However, if it is
         not followed by a valid prologue instruction, we must adjust
         the pc back over the extend so that it won't be considered
         part of the prologue.  */
      if ((inst & 0xf800) == 0xf000)	/* extend */
d4998 8
a5005 2
	  extend_bytes = MIPS16_INSTLEN;
	  continue;
d5007 11
a5017 11
      prev_extend_bytes = extend_bytes;
      extend_bytes = 0;

      /* Check for other valid prologue instructions besides extend.  */
      for (i = 0; table[i].mask != 0; i++)
	if ((inst & table[i].mask) == table[i].inst)	/* found, get out */
	  break;
      if (table[i].mask != 0)	/* it was in table? */
	continue;		/* ignore it */
      else
	/* non-prologue */
d5019 9
a5027 3
	  /* Return the current pc, adjusted backwards by 2 if
	     the previous instruction was an extend.  */
	  return pc - prev_extend_bytes;
d5029 1
a5030 31
  return pc;
}

/* To skip prologues, I use this predicate.  Returns either PC itself
   if the code at PC does not look like a function prologue; otherwise
   returns an address that (if we're lucky) follows the prologue.  If
   LENIENT, then we must skip everything which is involved in setting
   up the frame (it's OK to skip more, just so long as we don't skip
   anything which might clobber the registers which are being saved.
   We must skip more in the case where part of the prologue is in the
   delay slot of a non-prologue instruction).  */

static CORE_ADDR
mips_skip_prologue (CORE_ADDR pc)
{
  /* See if we can determine the end of the prologue via the symbol table.
     If so, then return either PC, or the PC after the prologue, whichever
     is greater.  */

  CORE_ADDR post_prologue_pc = after_prologue (pc, NULL);

  if (post_prologue_pc != 0)
    return max (pc, post_prologue_pc);

  /* Can't determine prologue from the symbol table, need to examine
     instructions.  */

  if (pc_is_mips16 (pc))
    return mips16_skip_prologue (pc);
  else
    return mips32_skip_prologue (pc);
d5055 1
a5055 2
  printf_unfiltered
    ("\"set mips\" must be followed by an appropriate subcommand.\n");
d5080 2
a5081 3
    printf_unfiltered
      ("The MIPS floating-point coprocessor is set automatically (currently %s)\n",
       fpu);
d5083 2
a5084 2
    printf_unfiltered
      ("The MIPS floating-point coprocessor is assumed to be %s\n", fpu);
d5091 1
a5091 2
  printf_unfiltered
    ("\"set mipsfpu\" must be followed by \"double\", \"single\",\"none\" or \"auto\".\n");
d5196 1
a5196 1
	info->mach = bfd_mach_mips16;
d5201 2
a5202 2
	info->mach = bfd_mach_mips16;
    }
d5208 2
a5209 1
  if (tdep->mips_abi == MIPS_ABI_N32 || tdep->mips_abi == MIPS_ABI_N64)
d5212 1
a5212 1
         register names from libopcodes.  */
d5242 1
a5242 1
mips_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
d5248 1
a5248 1
	  static unsigned char mips16_big_breakpoint[] = { 0xe8, 0xa5 };
d5258 3
a5260 3
	  static unsigned char big_breakpoint[] = { 0, 0x5, 0, 0xd };
	  static unsigned char pmon_big_breakpoint[] = { 0, 0, 0, 0xd };
	  static unsigned char idt_big_breakpoint[] = { 0, 0, 0x0a, 0xd };
d5278 1
a5278 1
	  static unsigned char mips16_little_breakpoint[] = { 0xa5, 0xe8 };
d5285 3
a5287 3
	  static unsigned char little_breakpoint[] = { 0xd, 0, 0x5, 0 };
	  static unsigned char pmon_little_breakpoint[] = { 0xd, 0, 0, 0 };
	  static unsigned char idt_little_breakpoint[] = { 0xd, 0x0a, 0, 0 };
d5370 1
a5370 2
	      if (find_pc_partial_function (target_pc, &name, NULL, NULL) ==
		  0)
d5412 1
a5412 2
  if (find_pc_partial_function (pc, name ? NULL : &name, &start_addr, NULL) ==
      0)
d5450 2
a5451 1
      && (name[19] == 's' || name[19] == 'd') && pc != start_addr)
d5491 2
a5492 1
			 int regnum, enum lval_type *lvalp)
d5594 1
a5594 1
    return LEGACY_SIM_REGNO_IGNORE;
d5649 2
a5650 1
  internal_error (__FILE__, __LINE__, "unknown ABI string");
d5654 2
a5655 1
mips_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
d5673 2
a5674 1
			"mips_gdbarch_init: elf_flags = 0x%08x\n", elf_flags);
d5789 2
a5790 1
			"mips_gdbarch_init: fpu_type = %d\n", fpu_type);
d5833 1
a5833 1
  set_gdbarch_elf_make_msymbol_special (gdbarch,
d5899 2
a5900 4
      set_gdbarch_deprecated_store_return_value (gdbarch,
						 mips_o64_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch,
						   mips_o64_extract_return_value);
d5910 1
a5910 2
      set_gdbarch_use_struct_convention (gdbarch,
					 always_use_struct_convention);
d5914 2
a5915 4
      set_gdbarch_deprecated_store_return_value (gdbarch,
						 mips_eabi_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch,
						   mips_eabi_extract_return_value);
d5927 1
a5927 1
      set_gdbarch_use_struct_convention (gdbarch,
d5932 2
a5933 4
      set_gdbarch_deprecated_store_return_value (gdbarch,
						 mips_eabi_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch,
						   mips_eabi_extract_return_value);
d5945 1
a5945 1
      set_gdbarch_use_struct_convention (gdbarch,
d5975 2
a5976 1
      internal_error (__FILE__, __LINE__, "unknown ABI in switch");
d6001 2
a6002 2
  set_gdbarch_write_pc (gdbarch, mips_write_pc);
  set_gdbarch_deprecated_target_read_fp (gdbarch, mips_read_sp);	/* Draft FRAME base.  */
d6011 1
a6011 2
  set_gdbarch_deprecated_init_frame_pc_first (gdbarch,
					      mips_init_frame_pc_first);
d6015 3
a6017 6
  set_gdbarch_ecoff_reg_to_regnum (gdbarch,
				   mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch,
				   mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch,
				    mips_dwarf_dwarf2_ecoff_reg_to_regnum);
d6021 2
a6022 4
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch,
						mips_find_saved_regs);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch,
						mips_init_extra_frame_info);
d6032 1
a6032 6
  set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch,
					       generic_save_dummy_frame_tos);

  set_gdbarch_convert_register_p (gdbarch, mips_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, mips_register_to_value);
  set_gdbarch_value_to_register (gdbarch, mips_value_to_register);
d6035 1
a6035 1
  set_gdbarch_frameless_function_invocation (gdbarch,
d6040 1
a6040 2
  set_gdbarch_deprecated_get_saved_register (gdbarch,
					     mips_get_saved_register);
d6044 1
d6047 1
a6047 2
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch,
					      mips_saved_pc_after_call);
d6053 2
d6082 2
a6083 1
mips_abi_update (char *ignore_args, int from_tty, struct cmd_list_element *c)
d6099 2
a6100 2
    printf_filtered
      ("The MIPS ABI is unknown because the current architecture is not MIPS.\n");
d6108 2
a6109 3
	printf_filtered
	  ("The MIPS ABI is set automatically (currently \"%s\").\n",
	   actual_abi_str);
d6111 3
a6113 3
	printf_filtered
	  ("The MIPS ABI is assumed to be \"%s\" (due to user setting).\n",
	   actual_abi_str);
d6117 4
a6120 3
	  printf_filtered
	    ("The (auto detected) MIPS ABI \"%s\" is in use even though the user setting was \"%s\".\n",
	     actual_abi_str, mips_abi_strings[global_abi]);
d6165 2
a6166 1
			  tdep->mips_abi, mips_abi_strings[tdep->mips_abi]);
d6182 3
a6184 1
  fprintf_unfiltered (file, "mips_dump_tdep: MIPS_EABI = %d\n", MIPS_EABI);
d6198 3
a6200 1
  fprintf_unfiltered (file, "mips_dump_tdep: A0_REGNUM = %d\n", A0_REGNUM);
d6203 1
a6203 1
		      XSTRING (ADDR_BITS_REMOVE (ADDR)));
d6246 2
a6247 1
  fprintf_unfiltered (file, "mips_dump_tdep: MIPS_DEFAULT_ABI = FIXME!\n");
d6251 2
a6252 1
		      "mips_dump_tdep: MIPS_INSTLEN = %d\n", MIPS_INSTLEN);
d6258 2
a6259 1
		      "mips_dump_tdep: MIPS_NUMREGS = %d\n", MIPS_NUMREGS);
d6264 2
a6265 1
		      "mips_dump_tdep: PRID_REGNUM = %d\n", PRID_REGNUM);
d6272 24
a6295 11
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_FRAME_REG = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_FREG_MASK = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_FREG_OFFSET = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_HIGH_ADDR = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_LOW_ADDR = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_PC_REG = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_REG_MASK = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_REG_OFFSET = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_SYMBOL = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PS_REGNUM = %d\n", PS_REGNUM);
  fprintf_unfiltered (file, "mips_dump_tdep: RA_REGNUM = %d\n", RA_REGNUM);
d6298 2
a6299 1
		      "mips_dump_tdep: SAVED_BYTES = %d\n", SAVED_BYTES);
d6302 3
a6304 1
  fprintf_unfiltered (file, "mips_dump_tdep: SAVED_FP = %d\n", SAVED_FP);
d6307 3
a6309 1
  fprintf_unfiltered (file, "mips_dump_tdep: SAVED_PC = %d\n", SAVED_PC);
d6317 2
a6318 1
		      "mips_dump_tdep: SIGFRAME_BASE = %d\n", SIGFRAME_BASE);
d6354 3
a6356 1
  fprintf_unfiltered (file, "mips_dump_tdep: T9_REGNUM = %d\n", T9_REGNUM);
d6361 1
a6361 2
		      XSTRING (TARGET_CAN_USE_HARDWARE_WATCHPOINT
			       (TYPE, CNT, OTHERTYPE)));
d6372 2
a6373 1
		      "mips_dump_tdep: TRACE_FLAVOR = %d\n", TRACE_FLAVOR);
d6383 1
a6383 1
		      XSTRING (TRACE_SET (X, STATE)));
d6387 2
a6388 1
		      "mips_dump_tdep: UNUSED_REGNUM = %d\n", UNUSED_REGNUM);
d6390 3
a6392 1
  fprintf_unfiltered (file, "mips_dump_tdep: V0_REGNUM = %d\n", V0_REGNUM);
d6397 2
a6398 1
		      "mips_dump_tdep: ZERO_REGNUM = %d\n", ZERO_REGNUM);
d6400 2
a6401 1
		      "mips_dump_tdep: _PROC_MAGIC_ = %d\n", _PROC_MAGIC_);
d6404 1
a6404 1
extern initialize_file_ftype _initialize_mips_tdep;	/* -Wmissing-prototypes */
d6412 1
a6412 1
  mips_abi_string = mips_abi_strings[MIPS_ABI_UNKNOWN];
d6439 3
a6441 1
          (default: auto)", &setmipscmdlist), &showmipscmdlist);
d6453 3
a6455 1
          target and executable (default)", &setmipscmdlist), &showmipscmdlist);
d6464 6
a6469 1
     "  o64\n" "  n32\n" "  n64\n" "  eabi32\n" "  eabi64", &setmipscmdlist);
d6472 1
a6472 1
	   "Show ABI in use by MIPS target", &showmipscmdlist);
d6490 2
a6491 1
	   "Select no MIPS floating-point coprocessor.", &mipsfpulist);
d6506 2
a6507 1
		   (char *) &heuristic_fence_post, "\
d6511 2
a6512 1
search.  The only need to set it is when debugging a stripped executable.", &setlist);
d6525 2
a6526 1
				NULL, show_mask_address, &setmipscmdlist, &showmipscmdlist);
d6535 1
a6535 1
64 bits for others.  Use \"off\" to disable compatibility mode", "\
d6539 3
a6541 1
64 bits for others.  Use \"off\" to disable compatibility mode", set_mips64_transfers_32bit_regs, NULL, &setlist, &showlist);
d6546 2
a6547 1
When non-zero, mips specific debugging is enabled.", &setdebuglist), &showdebuglist);
@


1.128
log
@2002-09-30  Andrew Cagney  <ac131313@@redhat.com>

	* mips-tdep.c (mips_frame_saved_pc): When a generic dummy frame,
	use frame_unwind_signed_register to obtain the PC.
	(mips_frame_chain): Handle a generic dummy frame.
	(mips_init_extra_frame_info): When a generic dummy frame, don't
	re-compute the frame base.
	(mips_pop_frame): Handle generic dummy frames.
	(mips_gdbarch_init): When generic dummy frames, set
	use_generic_dummy_frames, push_dummy_frame to
	generic_push_dummy_frame, pc_in_call_dummy to
	generic_pc_in_call_dummy, and save_dummy_frame_top_of_stack to
	generic_save_dummy_frame_tos.
@
text
@d5595 1
a5595 1
  else if (strcmp (name, ".mdebug.abiN64") == 0)
@


1.127
log
@2002-09-26Martin M. Hunt  <hunt@@redhat.com>

	* mips-tdep.c (find_proc_desc): Initialize startaddr.
@
text
@d1707 8
a1714 1
  if (proc_desc && PROC_DESC_IS_DUMMY (proc_desc))
d2431 9
d2455 4
a2458 2
      /* Check if this is a call dummy frame.  */
      && frame->pc != CALL_DUMMY_ADDRESS ())
d2488 9
d3813 1
d3815 7
a3821 1
  mips_extra_func_info_t proc_desc = frame->extra_info->proc_desc;
d5993 1
d5995 3
d6001 1
d6003 3
d6012 1
d6014 3
d6021 4
@


1.126
log
@2002-09-18  Andrew Cagney  <ac131313@@redhat.com>

	* valops.c (hand_function_call): Align the initial stack pointer
	and STRUCT_ADDR using frame_align.  When STRUCT_RETURN and
	FRAME_ALIGN_P, use STRUCT_ADDR to obtain the called function's
	return value.
	* mips-tdep.c (mips_frame_align): New function.
	(mips_gdbarch_init): Set frame_align.
	* gdbarch.sh (FRAME_ALIGN): New method.
	* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d2339 1
a2339 1
  CORE_ADDR startaddr;
@


1.126.2.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d2339 1
a2339 1
  CORE_ADDR startaddr = 0;
@


1.126.2.2
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d1707 1
a1707 8
  if (USE_GENERIC_DUMMY_FRAMES
      && PC_IN_CALL_DUMMY (frame->pc, 0, 0))
    {
      LONGEST tmp;
      frame_unwind_signed_register (frame, PC_REGNUM, &tmp);
      saved_pc = tmp;
    }
  else if (proc_desc && PROC_DESC_IS_DUMMY (proc_desc))
a2423 9
  if (USE_GENERIC_DUMMY_FRAMES
      && PC_IN_CALL_DUMMY (saved_pc, 0, 0))
    {
      /* A dummy frame, uses SP not FP.  Get the old SP value.  If all
         is well, frame->frame the bottom of the current frame will
         contain that value.  */
      return frame->frame;
    }

d2439 2
a2440 4
      /* For a generic dummy frame, let get_frame_pointer() unwind a
         register value saved as part of the dummy frame call.  */
      && !(USE_GENERIC_DUMMY_FRAMES
	   && PC_IN_CALL_DUMMY (frame->pc, 0, 0)))
a2469 9
      else if (USE_GENERIC_DUMMY_FRAMES
	       && PC_IN_CALL_DUMMY (fci->pc, 0, 0))
	/* Do not ``fix'' fci->frame.  It will have the value of the
           generic dummy frame's top-of-stack (since the draft
           fci->frame is obtained by returning the unwound stack
           pointer) and that is what we want.  That way the fci->frame
           value will match the top-of-stack value that was saved as
           part of the dummy frames data.  */
	/* Do nothing.  */;
d3786 1
a3788 8
  if (USE_GENERIC_DUMMY_FRAMES
      && PC_IN_CALL_DUMMY (frame->pc, 0, 0))
    {
      generic_pop_dummy_frame ();
      flush_cached_frames ();
      return;
    }

d5561 1
a5561 1
  else if (strcmp (name, ".mdebug.abi64") == 0)
a5958 1
#if OLD_STYLE_MIPS_DUMMY_FRAMES
a5959 3
#else
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);
#endif
a5962 1
#if OLD_STYLE_MIPS_DUMMY_FRAMES
a5963 3
#else
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
#endif
a5969 1
#if OLD_STYLE_MIPS_DUMMY_FRAMES
a5970 3
#else
  set_gdbarch_pc_in_call_dummy (gdbarch, generic_pc_in_call_dummy);
#endif
a5974 4
#if OLD_STYLE_MIPS_DUMMY_FRAMES
#else
  set_gdbarch_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
#endif
d6146 3
@


1.126.2.3
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a30 1
#include "block.h"
@


1.126.2.4
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d3722 1
a3722 1
  deprecated_read_register_gen (regno, buffer);
d4670 3
a4672 2
  deprecated_write_register_bytes (REGISTER_BYTE (lo.reg), raw_buffer,
				   REGISTER_RAW_SIZE (lo.reg));
d4678 3
a4680 2
      deprecated_write_register_bytes (REGISTER_BYTE (hi.reg), raw_buffer,
				       REGISTER_RAW_SIZE (hi.reg));
d4694 3
a4696 2
  deprecated_write_register_bytes (REGISTER_BYTE (lo.reg), raw_buffer,
				   REGISTER_RAW_SIZE (lo.reg));
d4702 3
a4704 2
      deprecated_write_register_bytes (REGISTER_BYTE (hi.reg), raw_buffer,
				       REGISTER_RAW_SIZE (hi.reg));
d6064 1
a6064 1
  set_gdbarch_deprecated_do_registers_info (gdbarch, mips_do_registers_info);
d6197 3
@


1.126.2.5
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a42 1
#include "mips-tdep.h"
d61 13
a165 7
/* Return the MIPS ABI associated with GDBARCH.  */
enum mips_abi
mips_abi (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->mips_abi;
}

d1427 1
a1427 1
  if ((get_frame_type (fci) == SIGTRAMP_FRAME))
d1460 1
a1460 1
       (fci->next == NULL || (get_frame_type (fci->next) == SIGTRAMP_FRAME))
d1686 1
a1686 1
static CORE_ADDR
d1694 1
a1694 1
  return tmp ? tmp : pc;
d1705 1
a1705 1
  int pcreg = (get_frame_type (frame) == SIGTRAMP_FRAME) ? PC_REGNUM
d1708 2
a1709 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, 0, 0))
d1724 1
a1724 7

/* This hack will go away once the get_prev_frame() code has been
   modified to set the frame's type first.  That is BEFORE init extra
   frame info et.al.  is called.  This is because it will become
   possible to skip the init extra info call for sigtramp and dummy
   frames.  */
static CORE_ADDR *temp_saved_regs;
a2035 1
  temp_saved_regs = xrealloc (temp_saved_regs, SIZEOF_FRAME_SAVED_REGS);
d2144 1
a2144 2
  temp_saved_regs = xrealloc (temp_saved_regs, SIZEOF_FRAME_SAVED_REGS);
  memset (temp_saved_regs, '\0', SIZEOF_FRAME_SAVED_REGS);
d2192 1
a2192 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (pc, 0, 0))
d2432 2
a2433 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (saved_pc, 0, 0))
d2455 1
a2455 1
      && !(get_frame_type (frame) == SIGTRAMP_FRAME)
d2458 2
a2459 1
      && !(DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, 0, 0)))
d2489 2
a2490 1
      else if (DEPRECATED_PC_IN_CALL_DUMMY (fci->pc, 0, 0))
d2506 2
a2507 6
	     mips_find_saved_registers will do that for us.  We can't
	     use (get_frame_type (fci) == SIGTRAMP_FRAME), it is not
	     yet set.  */
	  /* FIXME: cagney/2002-11-18: This problem will go away once
             frame.c:get_prev_frame() is modified to set the frame's
             type before calling functions like this.  */
d3813 1
a3813 1
  CORE_ADDR new_sp = get_frame_base (frame);
d3816 2
a3817 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, 0, 0))
d3946 1
a3946 1
  if (!frame_register_read (deprecated_selected_frame, regno, raw_buffer))
d3980 1
a3980 1
      if (!frame_register_read (deprecated_selected_frame, regno, rare_buffer))
d4011 1
a4011 1
  if (!frame_register_read (deprecated_selected_frame, regnum, raw_buffer))
d4191 1
a4191 1
      if (!frame_register_read (deprecated_selected_frame, regnum, raw_buffer))
a5766 5
  if (osabi == GDB_OSABI_IRIX)
    set_gdbarch_num_regs (gdbarch, 71);
  else
    set_gdbarch_num_regs (gdbarch, 90);

d5974 3
a5976 3
     blockframe.c near reference to DEPRECATED_INIT_FRAME_PC_FIRST.  */
  set_gdbarch_deprecated_init_frame_pc_first (gdbarch, mips_init_frame_pc_first);
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_noop);
d5990 6
d5998 3
d6002 1
d6009 5
d6018 2
d6021 1
d6035 2
d6214 6
@


1.126.2.6
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d133 2
d326 2
a327 2
static mips_extra_func_info_t heuristic_proc_desc (CORE_ADDR, CORE_ADDR,
						   struct frame_info *, int);
d339 2
a340 3
static mips_extra_func_info_t find_proc_desc (CORE_ADDR pc,
					      struct frame_info *next_frame,
					      int cur_frame);
d498 3
a500 3
      && get_frame_extra_info (fi)
      && get_frame_extra_info (fi)->proc_desc
      && get_frame_extra_info (fi)->proc_desc->pdr.framereg < NUM_REGS)
d502 2
a503 2
		     REGISTER_NAME (get_frame_extra_info (fi)->proc_desc->pdr.framereg),
		     paddr_d (get_frame_extra_info (fi)->proc_desc->pdr.frameoffset));
d1426 1
a1426 1
	  reg_position = get_frame_base (fci) + SIGFRAME_REGSAVE_OFF
d1428 1
a1428 1
	  get_frame_saved_regs (fci)[ireg] = reg_position;
d1432 1
a1432 1
	  reg_position = get_frame_base (fci) + SIGFRAME_FPREGSAVE_OFF
d1434 1
a1434 1
	  get_frame_saved_regs (fci)[FP0_REGNUM + ireg] = reg_position;
d1436 1
a1436 1
      get_frame_saved_regs (fci)[PC_REGNUM] = get_frame_base (fci) + SIGFRAME_PC_OFF;
d1440 1
a1440 1
  proc_desc = get_frame_extra_info (fci)->proc_desc;
d1455 1
a1455 2
       (get_next_frame (fci) == NULL
	|| (get_frame_type (get_next_frame (fci)) == SIGTRAMP_FRAME))
d1463 1
a1463 1
       && in_prologue (get_frame_pc (fci), PROC_LOW_ADDR (proc_desc))
d1487 1
a1487 1
      while (addr < get_frame_pc (fci))
d1502 1
a1502 1
  reg_position = get_frame_base (fci) + PROC_REG_OFFSET (proc_desc);
d1506 1
a1506 1
	get_frame_saved_regs (fci)[ireg] = reg_position;
d1523 1
a1523 1
	  reg_position = get_frame_base (fci) + PROC_REG_OFFSET (proc_desc);
d1530 1
a1530 1
	      get_frame_saved_regs (fci)[reg] = reg_position;
d1538 1
a1538 1
  reg_position = get_frame_base (fci) + PROC_FREG_OFFSET (proc_desc);
d1561 1
a1561 1
	get_frame_saved_regs (fci)[FP0_REGNUM + ireg] = reg_position;
d1565 1
a1565 1
  get_frame_saved_regs (fci)[PC_REGNUM] = get_frame_saved_regs (fci)[RA_REGNUM];
d1578 1
a1578 1
  if (get_frame_saved_regs (frame) == NULL)
d1582 1
a1582 1
  get_frame_saved_regs (frame)[SP_REGNUM] = get_frame_base (frame);
d1686 2
a1687 5
  pc = ((fromleaf)
	? SAVED_PC_AFTER_CALL (get_next_frame (prev))
	: get_next_frame (prev)
	? FRAME_SAVED_PC (get_next_frame (prev))
	: read_pc ());
d1697 1
a1697 1
  mips_extra_func_info_t proc_desc = get_frame_extra_info (frame)->proc_desc;
d1703 1
a1703 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), 0, 0))
d1710 1
a1710 1
    saved_pc = read_memory_integer (get_frame_base (frame) - MIPS_SAVED_REGSIZE, MIPS_SAVED_REGSIZE);
d2439 1
a2439 1
      return get_frame_base (frame);
d2459 1
a2459 1
      && !(DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), 0, 0)))
a2468 4
  mips_extra_func_info_t proc_desc;

  if (get_frame_type (fci) == DUMMY_FRAME)
    return;
d2471 2
a2472 4
  proc_desc =
    get_next_frame (fci)
    ? cached_proc_desc
    : find_proc_desc (get_frame_pc (fci), get_next_frame (fci), 1);
d2474 2
a2475 1
  frame_extra_info_zalloc (fci, sizeof (struct frame_extra_info));
d2477 2
a2478 2
  deprecated_set_frame_saved_regs_hack (fci, NULL);
  get_frame_extra_info (fci)->proc_desc =
d2486 1
a2486 1
      if (get_frame_pc (fci) == PROC_LOW_ADDR (proc_desc)
d2488 2
a2489 2
	deprecated_update_frame_base_hack (fci, read_next_frame_reg (get_next_frame (fci), SP_REGNUM));
      else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fci), 0, 0))
d2498 1
a2498 1
	deprecated_update_frame_base_hack (fci, get_frame_pointer (get_next_frame (fci), proc_desc));
d2511 1
a2511 1
	  find_pc_partial_function (get_frame_pc (fci), &name,
d2513 1
a2513 1
	  if (!PC_IN_SIGTRAMP (get_frame_pc (fci), name))
d2516 3
a2518 3
	      memcpy (get_frame_saved_regs (fci), temp_saved_regs, SIZEOF_FRAME_SAVED_REGS);
	      get_frame_saved_regs (fci)[PC_REGNUM]
		= get_frame_saved_regs (fci)[RA_REGNUM];
d2524 1
a2524 1
	      get_frame_saved_regs (fci)[SP_REGNUM] = get_frame_base (fci);
d2530 1
a2530 1
      get_frame_extra_info (fci)->num_args = -1;
d2535 1
a2535 1
	      get_frame_extra_info (fci)->num_args = regnum - A0_REGNUM + 1;
d3817 1
a3817 1
  mips_extra_func_info_t proc_desc = get_frame_extra_info (frame)->proc_desc;
d3819 1
a3819 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), 0, 0))
d3827 1
a3827 1
  if (get_frame_saved_regs (frame) == NULL)
d3831 1
a3831 1
	&& get_frame_saved_regs (frame)[regnum])
d3838 1
a3838 1
			  read_memory_unsigned_integer (get_frame_saved_regs (frame)[regnum],
d3842 1
a3842 1
			  read_memory_integer (get_frame_saved_regs (frame)[regnum],
d5457 18
d5629 1
d5644 4
d5744 2
a5745 1
      return arches->gdbarch;
d5752 1
d5769 1
a5769 1
  if (info.osabi == GDB_OSABI_IRIX)
d6017 2
d6020 1
d6051 1
a6051 1
  gdbarch_init_osabi (info, gdbarch);
d6456 4
@


1.126.2.7
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d31 1
a43 1
#include "block.h"
d1593 14
a1606 22

  if (fi == NULL)
    {
      regcache_cooked_read (current_regcache, regno, raw_buffer);
    }
  else
    {
      frame_register_unwind (fi, regno, &optimized, &lval, &addr, &realnum,
			     raw_buffer);
      /* FIXME: cagney/2002-09-13: This is just soooo bad.  The MIPS
	 should have a pseudo register range that correspons to the ABI's,
	 rather than the ISA's, view of registers.  These registers would
	 then implicitly describe their size and hence could be used
	 without the below munging.  */
      if (lval == lval_memory)
	{
	  if (regno < 32)
	    {
	      /* Only MIPS_SAVED_REGSIZE bytes of GP registers are
		 saved. */
	      return read_memory_integer (addr, MIPS_SAVED_REGSIZE);
	    }
d2477 1
a2477 4
  /* Use proc_desc calculated in frame_chain.  When there is no
     next frame, i.e, get_next_frame (fci) == NULL, we call
     find_proc_desc () to calculate it, passing an explicit
     NULL as the frame parameter.  */
d2481 1
a2481 3
    : find_proc_desc (get_frame_pc (fci),
                      NULL /* i.e, get_next_frame (fci) */,
		      1);
d3836 1
a3836 1
    DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
d5485 1
d5497 2
a5498 2
  generic_unwind_get_saved_register (raw_buffer, optimizedp, addrp, frame,
                                     regnum, lvalp);
d5744 2
a5745 2
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 8);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 8);
d5973 2
a5974 2
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, mips_frame_init_saved_regs);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, mips_init_extra_frame_info);
d5982 1
a6056 32
/* Print out which MIPS ABI is in use.  */

static void
show_mips_abi (char *ignore_args, int from_tty)
{
  if (gdbarch_bfd_arch_info (current_gdbarch)->arch != bfd_arch_mips)
    printf_filtered (
      "The MIPS ABI is unknown because the current architecture is not MIPS.\n");
  else
    {
      enum mips_abi global_abi = global_mips_abi ();
      enum mips_abi actual_abi = mips_abi (current_gdbarch);
      const char *actual_abi_str = mips_abi_strings[actual_abi];

      if (global_abi == MIPS_ABI_UNKNOWN)
	printf_filtered ("The MIPS ABI is set automatically (currently \"%s\").\n",
	                 actual_abi_str);
      else if (global_abi == actual_abi)
	printf_filtered (
	  "The MIPS ABI is assumed to be \"%s\" (due to user setting).\n",
	  actual_abi_str);
      else
	{
	  /* Probably shouldn't happen...  */
	  printf_filtered (
	    "The (auto detected) MIPS ABI \"%s\" is in use even though the user setting was \"%s\".\n",
	    actual_abi_str,
	    mips_abi_strings[global_abi]);
	}
    }
}

d6504 1
a6505 2
  add_cmd ("abi", class_obscure, show_mips_abi,
           "Show ABI in use by MIPS target", &showmipscmdlist);
@


1.126.2.8
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a27 1
#include "gdb_assert.h"
a363 1
static char *mips_generic_reg_names[] = MIPS_REGISTER_NAMES;
d365 2
a366 5
/* Integer registers 0 thru 31 are handled explicitly by
   mips_register_name().  Processor specific registers 32 and above
   are listed in the sets of register names assigned to
   mips_processor_reg_names.  */
static char **mips_processor_reg_names = mips_generic_reg_names;
a367 1
/* Return the name of the register corresponding to REGNO.  */
d369 1
a369 1
mips_register_name (int regno)
d371 1
a371 33
  /* GPR names for all ABIs other than n32/n64.  */
  static char *mips_gpr_names[] = {
    "zero", "at",   "v0",   "v1",   "a0",   "a1",   "a2",   "a3",
    "t0",   "t1",   "t2",   "t3",   "t4",   "t5",   "t6",   "t7",
    "s0",   "s1",   "s2",   "s3",   "s4",   "s5",   "s6",   "s7",
    "t8",   "t9",   "k0",   "k1",   "gp",   "sp",   "s8",   "ra",
  };

  /* GPR names for n32 and n64 ABIs.  */
  static char *mips_n32_n64_gpr_names[] = {
    "zero", "at",   "v0",   "v1",   "a0",   "a1",   "a2",   "a3", 
    "a4",   "a5",   "a6",   "a7",   "t0",   "t1",   "t2",   "t3", 
    "s0",   "s1",   "s2",   "s3",   "s4",   "s5",   "s6",   "s7", 
    "t8",   "t9",   "k0",   "k1",   "gp",   "sp",   "s8",   "ra"
  };

  enum mips_abi abi = mips_abi (current_gdbarch);

  /* The MIPS integer registers are always mapped from 0 to 31.  The
     names of the registers (which reflects the conventions regarding
     register use) vary depending on the ABI.  */
  if (0 <= regno && regno < 32)
    {
      if (abi == MIPS_ABI_N32 || abi == MIPS_ABI_N64)
	return mips_n32_n64_gpr_names[regno];
      else
	return mips_gpr_names[regno];
    }
  else if (32 <= regno && regno < NUM_REGS)
    return mips_processor_reg_names[regno - 32];
  else
    internal_error (__FILE__, __LINE__,
		    "mips_register_name: bad register number %d", regno);
a372 1

d377 4
d394 4
d411 4
d428 4
d639 1
a639 1
  return read_signed_register (SP_REGNUM);
d1695 1
a1695 1
	? DEPRECATED_SAVED_PC_AFTER_CALL (get_next_frame (prev))
d1697 1
a1697 1
	? DEPRECATED_FRAME_SAVED_PC (get_next_frame (prev))
d1798 1
a1798 1
	   stop_soon, but with this test, at least we
d1801 1
a1801 1
	if (stop_soon == NO_STOP_QUIETLY)
d2422 4
a2425 3
  return (read_next_frame_reg (frame, PROC_FRAME_REG (proc_desc))
	  + PROC_FRAME_OFFSET (proc_desc)
	  - PROC_FRAME_ADJUST (proc_desc));
d2435 1
a2435 1
  CORE_ADDR saved_pc = DEPRECATED_FRAME_SAVED_PC (frame);
d3728 105
d3838 1
a3838 1
  mips_extra_func_info_t proc_desc;
d3847 1
a3847 2
  proc_desc = get_frame_extra_info (frame)->proc_desc;
  write_register (PC_REGNUM, DEPRECATED_FRAME_SAVED_PC (frame));
d4029 78
a4106 1
mips_print_fp_register (int regnum)
d4110 1
a4110 1
  int inv1, inv2, namelen;
a4113 3
  printf_filtered ("%s:", REGISTER_NAME (regnum));
  printf_filtered ("%*s", 4 - (int) strlen (REGISTER_NAME (regnum)), "");

d4116 2
a4117 2
      /* 4-byte registers: Print hex and floating.  Also print even
         numbered registers as doubles.  */
d4121 5
a4125 2
      print_scalar_formatted (raw_buffer, builtin_type_uint32, 'x', 'w',
                              gdb_stdout);
d4127 1
a4127 1
      printf_filtered (" flt: ");
d4129 1
a4129 1
	printf_filtered (" <invalid float> ");
d4133 15
a4147 12
      if (regnum % 2 == 0)
	{
	  mips_read_fp_register_double (regnum, raw_buffer);
	  doub = unpack_double (mips_double_register_type (), raw_buffer,
	                        &inv2);

	  printf_filtered (" dbl: ");
	  if (inv2)
	    printf_filtered ("<invalid double>");
	  else
	    printf_filtered ("%-24.17g", doub);
	}
d4151 1
a4151 1
      /* Eight byte registers: print each one as hex, float and double.  */
d4153 1
a4153 1
      flt1 = unpack_double (mips_float_register_type (), raw_buffer, &inv1);
d4156 1
a4156 5
      doub = unpack_double (mips_double_register_type (), raw_buffer, &inv2);


      print_scalar_formatted (raw_buffer, builtin_type_uint64, 'x', 'g',
                              gdb_stdout);
d4158 1
a4158 1
      printf_filtered (" flt: ");
d4162 1
a4162 1
	printf_filtered ("%-17.9g", flt1);
d4165 1
a4165 1
      if (inv2)
a4168 2
    }
}
d4170 3
a4172 10
static void
mips_print_register (int regnum, int all)
{
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  int offset;

  if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (regnum)) == TYPE_CODE_FLT)
    {
      mips_print_fp_register (regnum);
      return;
d4174 1
a4174 27

  /* Get the data in raw format.  */
  if (!frame_register_read (deprecated_selected_frame, regnum, raw_buffer))
    {
      printf_filtered ("%s: [Invalid]", REGISTER_NAME (regnum));
      return;
    }

  fputs_filtered (REGISTER_NAME (regnum), gdb_stdout);

  /* The problem with printing numeric register names (r26, etc.) is that
     the user can't use them on input.  Probably the best solution is to
     fix it so that either the numeric or the funky (a2, etc.) names
     are accepted on input.  */
  if (regnum < MIPS_NUMREGS)
    printf_filtered ("(r%d): ", regnum);
  else
    printf_filtered (": ");

  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    offset = REGISTER_RAW_SIZE (regnum) - REGISTER_VIRTUAL_SIZE (regnum);
  else
    offset = 0;

  print_scalar_formatted (raw_buffer + offset,
			  REGISTER_VIRTUAL_TYPE (regnum),
			  'x', 0, gdb_stdout);
a4176 13
/* Replacement for generic do_registers_info.
   Print regs in pretty columns.  */

static int
do_fp_register_row (int regnum)
{
  printf_filtered (" ");
  mips_print_fp_register (regnum);
  printf_filtered ("\n");
  return regnum + 1;
}


d5549 1
a5549 1
  if (num >= 0 && num < 32)
d5551 1
a5551 1
  else if (num >= 38 && num < 70)
a5552 10
  else if (num == 70)
    return HI_REGNUM;
  else if (num == 71)
    return LO_REGNUM;
  else
    {
      /* This will hopefully (eventually) provoke a warning.  Should
         we be calling complaint() here?  */
      return NUM_REGS + NUM_PSEUDO_REGS;
    }
d5555 1
a5555 2

/* Convert a dwarf, dwarf2, or ecoff register number to a gdb REGNUM */
d5558 1
a5558 1
mips_dwarf_dwarf2_ecoff_reg_to_regnum (int num)
d5560 1
a5560 1
  if (num >= 0 && num < 32)
d5562 1
a5562 1
  else if (num >= 32 && num < 64)
a5563 10
  else if (num == 64)
    return HI_REGNUM;
  else if (num == 65)
    return LO_REGNUM;
  else
    {
      /* This will hopefully (eventually) provoke a warning.  Should
         we be calling complaint() here?  */
      return NUM_REGS + NUM_PSEUDO_REGS;
    }
a5565 1

a5716 28
  /* We have to set tm_print_insn_info before looking for a
     pre-existing architecture, otherwise we may return before we get
     a chance to set it up.  */
  if (mips_abi == MIPS_ABI_N32 || mips_abi == MIPS_ABI_N64)
    {
      /* Set up the disassembler info, so that we get the right
	 register names from libopcodes.  */
      if (mips_abi == MIPS_ABI_N32)
	tm_print_insn_info.disassembler_options = "gpr-names=n32";
      else
	tm_print_insn_info.disassembler_options = "gpr-names=64";
      tm_print_insn_info.flavour = bfd_target_elf_flavour;
      tm_print_insn_info.arch = bfd_arch_mips;
      if (info.bfd_arch_info != NULL
	  && info.bfd_arch_info->arch == bfd_arch_mips
	  && info.bfd_arch_info->mach)
	tm_print_insn_info.mach = info.bfd_arch_info->mach;
      else
	tm_print_insn_info.mach = bfd_mach_mips8000;
    }
  else
    /* This string is not recognized explicitly by the disassembler,
       but it tells the disassembler to not try to guess the ABI from
       the bfd elf headers, such that, if the user overrides the ABI
       of a program linked as NewABI, the disassembly will follow the
       register naming conventions specified by the user.  */
    tm_print_insn_info.disassembler_options = "gpr-names=32";

d5772 1
a5772 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_o32_push_arguments);
d5791 1
a5791 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_o64_push_arguments);
d5810 1
a5810 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_eabi_push_arguments);
d5829 1
a5829 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_eabi_push_arguments);
d5848 1
a5848 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_n32n64_push_arguments);
d5861 12
d5879 1
a5879 1
      set_gdbarch_deprecated_push_arguments (gdbarch, mips_n32n64_push_arguments);
d5892 12
d5969 1
a5969 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
d5982 1
a5982 3
  set_gdbarch_ecoff_reg_to_regnum (gdbarch, mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, mips_dwarf_dwarf2_ecoff_reg_to_regnum);
d5990 2
d5993 6
a5998 2
  set_gdbarch_deprecated_push_return_address (gdbarch, mips_push_return_address);
  set_gdbarch_deprecated_pop_frame (gdbarch, mips_pop_frame);
d6002 1
a6002 1
  set_gdbarch_deprecated_push_return_address (gdbarch, mips_push_return_address);
d6011 1
a6011 1
  set_gdbarch_deprecated_frame_chain (gdbarch, mips_frame_chain);
d6014 1
a6014 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, mips_frame_saved_pc);
d6018 1
a6018 1
  set_gdbarch_deprecated_get_saved_register (gdbarch, mips_get_saved_register);
d6025 1
a6025 1
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, mips_saved_pc_after_call);
d6044 1
a6044 1
  set_gdbarch_deprecated_store_struct_return (gdbarch, mips_store_struct_return);
d6225 3
d6340 3
@


1.126.2.9
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d626 3
a628 3
   definitions found in config/mips/tm-*.h.  I'm concerned about the
   ``FCRCS_REGNUM <= reg && reg <= LAST_EMBED_REGNUM'' clause though.
   In some cases DEPRECATED_FP_REGNUM is in this range, and I doubt
d5546 3
a5548 3
  deprecated_tm_print_insn_info.flavour = bfd_target_unknown_flavour;
  deprecated_tm_print_insn_info.arch = bfd_arch_unknown;
  deprecated_tm_print_insn_info.mach = 0;
d5629 1
a5629 1
  /* We have to set deprecated_tm_print_insn_info before looking for a
d5637 1
a5637 1
	deprecated_tm_print_insn_info.disassembler_options = "gpr-names=n32";
d5639 3
a5641 3
	deprecated_tm_print_insn_info.disassembler_options = "gpr-names=64";
      deprecated_tm_print_insn_info.flavour = bfd_target_elf_flavour;
      deprecated_tm_print_insn_info.arch = bfd_arch_mips;
d5645 1
a5645 1
	deprecated_tm_print_insn_info.mach = info.bfd_arch_info->mach;
d5647 1
a5647 1
	deprecated_tm_print_insn_info.mach = bfd_mach_mips8000;
d5655 1
a5655 1
    deprecated_tm_print_insn_info.disassembler_options = "gpr-names=32";
d5883 1
a5883 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, mips_read_sp); /* Draft FRAME base.  */
d6399 2
a6400 2
  if (!deprecated_tm_print_insn)	 /* Someone may have already set it */
    deprecated_tm_print_insn = gdb_print_insn_mips;
@


1.126.2.10
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a152 30
/* Return the contents of register REGNUM as a signed integer.  */

static LONGEST
read_signed_register (int regnum)
{
  void *buf = alloca (REGISTER_RAW_SIZE (regnum));
  deprecated_read_register_gen (regnum, buf);
  return (extract_signed_integer (buf, REGISTER_RAW_SIZE (regnum)));
}

static LONGEST
read_signed_register_pid (int regnum, ptid_t ptid)
{
  ptid_t save_ptid;
  LONGEST retval;

  if (ptid_equal (ptid, inferior_ptid))
    return read_signed_register (regnum);

  save_ptid = inferior_ptid;

  inferior_ptid = ptid;

  retval = read_signed_register (regnum);

  inferior_ptid = save_ptid;

  return retval;
}

d218 1
a218 1
  bfd_byte reg[MAX_REGISTER_SIZE];
d1615 1
a1615 1
  char raw_buffer[MAX_REGISTER_SIZE];
d2362 1
a2362 1
  sym = lookup_symbol (MIPS_EFI_SYMBOL_NAME, b, LABEL_DOMAIN, 0, NULL);
d2724 1
a2724 1
      char valbuf[MAX_REGISTER_SIZE];
d2740 1
a2740 1
	  store_unsigned_integer (valbuf, MIPS_SAVED_REGSIZE, VALUE_ADDRESS (arg));
d2975 1
a2975 1
      char valbuf[MAX_REGISTER_SIZE];
d3198 1
a3198 1
      char valbuf[MAX_REGISTER_SIZE];
d3497 1
a3497 1
      char valbuf[MAX_REGISTER_SIZE];
d4017 1
a4017 1
  char raw_buffer[MAX_REGISTER_SIZE];
d4073 1
a4073 1
  char raw_buffer[MAX_REGISTER_SIZE];
d4534 1
a4534 1
				char regbuf[],
d4553 1
a4553 1
			       char regbuf[],
d4576 1
a4576 1
  char raw_buffer[MAX_REGISTER_SIZE];
d4598 1
a4598 1
  char raw_buffer[MAX_REGISTER_SIZE];
d4680 1
a4680 1
      bfd_byte reg[MAX_REGISTER_SIZE];
d4792 1
a4792 1
      bfd_byte reg[MAX_REGISTER_SIZE];
d5092 13
d5119 2
a5120 1
	  static unsigned char mips16_big_breakpoint[] = {0xe8, 0xa5};
d5127 3
a5129 6
	  /* The IDT board uses an unusual breakpoint value, and
	     sometimes gets confused when it sees the usual MIPS
	     breakpoint instruction.  */
	  static unsigned char big_breakpoint[] = {0, 0x5, 0, 0xd};
	  static unsigned char pmon_big_breakpoint[] = {0, 0, 0, 0xd};
	  static unsigned char idt_big_breakpoint[] = {0, 0, 0x0a, 0xd};
d5147 2
a5148 1
	  static unsigned char mips16_little_breakpoint[] = {0xa5, 0xe8};
d5155 5
a5159 3
	  static unsigned char little_breakpoint[] = {0xd, 0, 0x5, 0};
	  static unsigned char pmon_little_breakpoint[] = {0xd, 0, 0, 0};
	  static unsigned char idt_little_breakpoint[] = {0xd, 0x0a, 0, 0};
d5415 1
a5415 1
	      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), val);
d5911 3
a5913 3
  set_gdbarch_deprecated_fix_call_dummy (gdbarch, mips_fix_call_dummy);
  set_gdbarch_deprecated_call_dummy_words (gdbarch, mips_call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (mips_call_dummy_words));
d6111 2
d6143 4
d6161 2
d6183 2
d6188 2
d6212 4
@


1.126.2.11
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d45 1
a45 1
#include "reggroups.h"
a49 3
#include "sim-regno.h"

static void set_reg_offset (CORE_ADDR *saved_regs, int regnum, CORE_ADDR off);
a152 21
/* MIPS16 function addresses are odd (bit 0 is set).  Here are some
   functions to test, set, or clear bit 0 of addresses.  */

static CORE_ADDR
is_mips16_addr (CORE_ADDR addr)
{
  return ((addr) & 1);
}

static CORE_ADDR
make_mips16_addr (CORE_ADDR addr)
{
  return ((addr) | 1);
}

static CORE_ADDR
unmake_mips16_addr (CORE_ADDR addr)
{
  return ((addr) & ~1);
}

a249 1
  gdb_assert (reg_num >= NUM_REGS);
d278 1
a278 1
    regcache_cooked_read_part (regcache, reg_num, reg_offset, length, in + buf_offset);
d280 1
a280 1
    regcache_cooked_write_part (regcache, reg_num, reg_offset, length, out + buf_offset);
d353 2
d375 3
a424 6
  /* Map [NUM_REGS .. 2*NUM_REGS) onto the raw registers, but then
     don't make the raw register names visible.  */
  int rawnum = regno % NUM_REGS;
  if (regno < NUM_REGS)
    return "";

d428 1
a428 1
  if (0 <= rawnum && rawnum < 32)
d431 1
a431 1
	return mips_n32_n64_gpr_names[rawnum];
d433 1
a433 1
	return mips_gpr_names[rawnum];
d435 2
a436 2
  else if (32 <= rawnum && rawnum < NUM_REGS)
    return mips_processor_reg_names[rawnum - 32];
d439 1
a439 1
		    "mips_register_name: bad register number %d", rawnum);
a508 41
/* Return the groups that a MIPS register can be categorised into.  */

static int
mips_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			  struct reggroup *reggroup)
{
  int vector_p;
  int float_p;
  int raw_p;
  int rawnum = regnum % NUM_REGS;
  int pseudo = regnum / NUM_REGS;
  if (reggroup == all_reggroup)
    return pseudo;
  vector_p = TYPE_VECTOR (register_type (gdbarch, regnum));
  float_p = TYPE_CODE (register_type (gdbarch, regnum)) == TYPE_CODE_FLT;
  /* FIXME: cagney/2003-04-13: Can't yet use gdbarch_num_regs
     (gdbarch), as not all architectures are multi-arch.  */
  raw_p = rawnum < NUM_REGS;
  if (REGISTER_NAME (regnum) == NULL
      || REGISTER_NAME (regnum)[0] == '\0')
    return 0;
  if (reggroup == float_reggroup)
    return float_p && pseudo;
  if (reggroup == vector_reggroup)
    return vector_p && pseudo;
  if (reggroup == general_reggroup)
    return (!vector_p && !float_p) && pseudo;
  /* Save the pseudo registers.  Need to make certain that any code
     extracting register values from a saved register cache also uses
     pseudo registers.  */
  if (reggroup == save_reggroup)
    return raw_p && pseudo;
  /* Restore the same pseudo register.  */
  if (reggroup == restore_reggroup)
    return raw_p && pseudo;
  return 0;   
}

/* Map the symbol table registers which live in the range [1 *
   NUM_REGS .. 2 * NUM_REGS) back onto the corresponding raw
   registers.  */
a509 7
static void
mips_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int cookednum, void *buf)
{
  gdb_assert (cookednum >= NUM_REGS && cookednum < 2 * NUM_REGS);
  return regcache_raw_read (regcache, cookednum % NUM_REGS, buf);
}
a510 7
static void
mips_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int cookednum, const void *buf)
{
  gdb_assert (cookednum >= NUM_REGS && cookednum < 2 * NUM_REGS);
  return regcache_raw_write (regcache, cookednum % NUM_REGS, buf);
}
d560 1
a560 1
   transfered by the GDB protocol.  */
d565 1
a565 1
mips_register_raw_size (int regnum)
d567 7
a573 58
  gdb_assert (regnum >= 0);
  if (regnum < NUM_REGS)
    {
      /* For compatibility with old code, implemnt the broken register raw
	 size map for the raw registers.

	 NOTE: cagney/2003-06-15: This is so bogus.  The register's
	 raw size is changing according to the ABI
	 (FP_REGISTER_DOUBLE).  Also, GDB's protocol is defined by a
	 combination of REGISTER_RAW_SIZE and REGISTER_BYTE.  */
      if (mips64_transfers_32bit_regs_p)
	return REGISTER_VIRTUAL_SIZE (regnum);
      else if (regnum >= FP0_REGNUM && regnum < FP0_REGNUM + 32
	       && FP_REGISTER_DOUBLE)
	/* For MIPS_ABI_N32 (for example) we need 8 byte floating point
	   registers.  */
	return 8;
      else
	return MIPS_REGSIZE;
    }
  else if (regnum < 2 * NUM_REGS)
    {
      /* For the moment map [NUM_REGS .. 2*NUM_REGS) onto the same raw
	 registers, but always return the virtual size.  */
      int rawnum = regnum % NUM_REGS;
      return TYPE_LENGTH (MIPS_REGISTER_TYPE (rawnum));
    }
  else
    internal_error (__FILE__, __LINE__, "Register %d out of range", regnum);
}

/* Register offset in a buffer for each register.

   FIXME: cagney/2003-06-15: This is so bogus.  Instead REGISTER_TYPE
   should strictly return the layout of the buffer.  Unfortunatly
   remote.c and the MIPS have come to rely on a custom layout that
   doesn't 1:1 map onto the register type.  */

static int
mips_register_byte (int regnum)
{
  gdb_assert (regnum >= 0);
  if (regnum < NUM_REGS)
    /* Pick up the relevant per-tm file register byte method.  */
    return MIPS_REGISTER_BYTE (regnum);
  else if (regnum < 2 * NUM_REGS)
    {
      int reg;
      int byte;
      /* Start with the end of the raw register buffer - assum that
	 MIPS_REGISTER_BYTE (NUM_REGS) returns that end.  */
      byte = MIPS_REGISTER_BYTE (NUM_REGS);
      /* Add space for all the proceeding registers based on their
         real size.  */
      for (reg = NUM_REGS; reg < regnum; reg++)
	byte += TYPE_LENGTH (MIPS_REGISTER_TYPE ((reg % NUM_REGS)));
      return byte;
    }
d575 1
a575 1
    internal_error (__FILE__, __LINE__, "Register %d out of range", regnum);
d606 1
a606 1
			      const char *virt_buf, char *raw_buf)
d619 2
a620 2
static int
mips_convert_register_p (int regnum, struct type *type)
d622 11
a632 5
  return (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && REGISTER_RAW_SIZE (regnum) == 4
	  && (regnum) >= FP0_REGNUM && (regnum) < FP0_REGNUM + 32
	  && TYPE_CODE(type) == TYPE_CODE_FLT
	  && TYPE_LENGTH(type) == 8);
d635 2
a636 3
static void
mips_register_to_value (struct frame_info *frame, int regnum,
			struct type *type, void *to)
d638 11
a648 2
  frame_read_register (frame, regnum + 0, (char *) to + 4);
  frame_read_register (frame, regnum + 1, (char *) to + 0);
d651 9
a659 10
static void
mips_value_to_register (struct frame_info *frame, int regnum,
			struct type *type, const void *from)
{
  put_frame_register (frame, regnum + 0, (const char *) from + 4);
  put_frame_register (frame, regnum + 1, (const char *) from + 0);
}

/* Return the GDB type object for the "standard" data type of data in
   register REG.  */
d662 1
a662 1
mips_register_type (struct gdbarch *gdbarch, int regnum)
d664 1
a664 8
  /* For moment, map [NUM_REGS .. 2*NUM_REGS) onto the same raw
     registers.  Even return the same type.  */
  int rawnum = regnum % NUM_REGS;
  gdb_assert (rawnum >= 0 && rawnum < NUM_REGS);
#ifdef MIPS_REGISTER_TYPE
  return MIPS_REGISTER_TYPE (rawnum);
#else
  if (FP0_REGNUM <= rawnum && rawnum < FP0_REGNUM + 32)
d672 1
a672 1
  else if (rawnum == PS_REGNUM /* CR */)
d674 1
a674 1
  else if (FCRCS_REGNUM <= rawnum && rawnum <= LAST_EMBED_REGNUM)
a684 1
#endif
d753 6
d795 1
a795 1
  if (is_mips16_addr (memaddr))
d928 1
a928 1
      addr = unmake_mips16_addr (addr);
d1431 10
a1440 7
/* Set up the 'saved_regs' array.  This is a data structure containing
   the addresses on the stack where each register has been saved, for
   each stack frame.  Registers that have not been saved will have
   zero here.  The stack pointer register is special: rather than the
   address where the stack register has been saved,
   saved_regs[SP_REGNUM] will have the actual value of the previous
   frame's stack register.  */
d1446 1
a1452 1
  CORE_ADDR *saved_regs;
d1454 1
a1454 3
  if (get_frame_saved_regs (fci) != NULL)
    return;
  saved_regs = frame_saved_regs_zalloc (fci);
d1457 3
a1459 3
     in a sigcontext structure somewhere on the stack.  If the stack
     layout for sigtramp changes we might have to change these
     constants and the companion fixup_sigtramp in mdebugread.c */
d1461 2
a1462 2
  /* To satisfy alignment restrictions, sigcontext is located 4 bytes
     above the sigtramp frame.  */
d1471 1
a1471 1
  /* FIXME!  Is this correct?? */
d1478 3
a1480 3
	  CORE_ADDR reg_position = (get_frame_base (fci) + SIGFRAME_REGSAVE_OFF
				    + ireg * SIGFRAME_REG_SIZE);
	  set_reg_offset (saved_regs, ireg, reg_position);
d1484 3
a1486 4
	  CORE_ADDR reg_position = (get_frame_base (fci)
				    + SIGFRAME_FPREGSAVE_OFF
				    + ireg * SIGFRAME_REG_SIZE);
	  set_reg_offset (saved_regs, FP0_REGNUM + ireg, reg_position);
d1488 1
a1488 4

      set_reg_offset (saved_regs, PC_REGNUM, get_frame_base (fci) + SIGFRAME_PC_OFF);
      /* SP_REGNUM, contains the value and not the address.  */
      set_reg_offset (saved_regs, SP_REGNUM, get_frame_base (fci));
d1494 3
a1496 3
    /* I'm not sure how/whether this can happen.  Normally when we
       can't find a proc_desc, we "synthesize" one using
       heuristic_proc_desc and set the saved_regs right away.  */
d1503 4
a1506 4
  if (/* In any frame other than the innermost or a frame interrupted
	 by a signal, we assume that all registers have been saved.
	 This assumes that all register saves in a function happen
	 before the first function call.  */
d1510 1
a1510 1
       /* In a dummy frame we know exactly where things are saved.  */
d1513 2
a1514 2
       /* Don't bother unless we are inside a function prologue.
	  Outside the prologue, we know where everything is. */
d1518 4
a1521 4
       /* Not sure exactly what kernel_trap means, but if it means the
	  kernel saves the registers without a prologue doing it, we
	  better not examine the prologue to see whether registers
	  have been saved yet.  */
d1524 2
a1525 2
      /* We need to figure out whether the registers that the
         proc_desc claims are saved have been saved yet.  */
d1538 2
a1539 2
      /* Scan through this function's instructions preceding the
         current PC, and look for those that save registers.  */
d1553 9
a1561 12
  /* Fill in the offsets for the registers which gen_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (get_frame_base (fci)
			      + PROC_REG_OFFSET (proc_desc));
    for (ireg = MIPS_NUMREGS - 1; gen_mask; --ireg, gen_mask <<= 1)
      if (gen_mask & 0x80000000)
	{
	  set_reg_offset (saved_regs, ireg, reg_position);
	  reg_position -= MIPS_SAVED_REGSIZE;
	}
  }
d1563 4
a1566 4
  /* The MIPS16 entry instruction saves $s0 and $s1 in the reverse
     order of that normally used by gcc.  Therefore, we have to fetch
     the first instruction of the function, and if it's an entry
     instruction that saves $s0 or $s1, correct their saved addresses.  */
d1570 1
a1570 2
      if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)
	/* entry */
d1576 1
a1576 2
	  CORE_ADDR reg_position = (get_frame_base (fci)
				    + PROC_REG_OFFSET (proc_desc));
d1580 1
a1580 2
	  /* Check if the s0 and s1 registers were pushed on the
             stack.  */
d1583 1
a1583 1
	      set_reg_offset (saved_regs, reg, reg_position);
d1589 28
a1616 5
  /* Fill in the offsets for the registers which float_mask says were
     saved.  */
  {
    CORE_ADDR reg_position = (get_frame_base (fci)
			      + PROC_FREG_OFFSET (proc_desc));
d1618 2
a1619 40
    /* Fill in the offsets for the float registers which float_mask
       says were saved.  */
    for (ireg = MIPS_NUMREGS - 1; float_mask; --ireg, float_mask <<= 1)
      if (float_mask & 0x80000000)
	{
	  if (MIPS_SAVED_REGSIZE == 4 && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    {
	      /* On a big endian 32 bit ABI, floating point registers
		 are paired to form doubles such that the most
		 significant part is in $f[N+1] and the least
		 significant in $f[N] vis: $f[N+1] ||| $f[N].  The
		 registers are also spilled as a pair and stored as a
		 double.

	         When little-endian the least significant part is
	         stored first leading to the memory order $f[N] and
	         then $f[N+1].

		 Unfortunatly, when big-endian the most significant
		 part of the double is stored first, and the least
		 significant is stored second.  This leads to the
		 registers being ordered in memory as firt $f[N+1] and
		 then $f[N].

		 For the big-endian case make certain that the
		 addresses point at the correct (swapped) locations
		 $f[N] and $f[N+1] pair (keep in mind that
		 reg_position is decremented each time through the
		 loop).  */
	      if ((ireg & 1))
		set_reg_offset (saved_regs, FP0_REGNUM + ireg,
				reg_position - MIPS_SAVED_REGSIZE);
	      else
		set_reg_offset (saved_regs, FP0_REGNUM + ireg,
				reg_position + MIPS_SAVED_REGSIZE);
	    }
	  else
	    set_reg_offset (saved_regs, FP0_REGNUM + ireg, reg_position);
	  reg_position -= MIPS_SAVED_REGSIZE;
	}
d1621 6
a1626 2
    set_reg_offset (saved_regs, PC_REGNUM, saved_regs[RA_REGNUM]);
  }
d1628 8
a1635 2
  /* SP_REGNUM, contains the value and not the address.  */
  set_reg_offset (saved_regs, SP_REGNUM, get_frame_base (fci));
d1641 6
a1646 2
  /* Always a pseudo.  */
  gdb_assert (regno >= NUM_REGS);
d1649 2
a1650 10
      LONGEST val;
      regcache_cooked_read_signed (current_regcache, regno, &val);
      return val;
    }
  else if ((regno % NUM_REGS) == SP_REGNUM)
    /* The SP_REGNUM is special, its value is stored in saved_regs.
       In fact, it is so special that it can even only be fetched
       using a raw register number!  Once this code as been converted
       to frame-unwind the problem goes away.  */
    return frame_unwind_register_signed (fi, regno % NUM_REGS);
d1652 18
a1669 1
    return frame_unwind_register_signed (fi, regno);
d1671 1
d1761 5
d1770 1
a1770 2
      /* Always unwind the cooked PC register value.  */
      frame_unwind_signed_register (frame, NUM_REGS + PC_REGNUM, &tmp);
d1773 2
d1776 2
a1777 14
    {
      mips_extra_func_info_t proc_desc
	= get_frame_extra_info (frame)->proc_desc;
      if (proc_desc && PROC_DESC_IS_DUMMY (proc_desc))
	saved_pc = read_memory_integer (get_frame_base (frame) - MIPS_SAVED_REGSIZE, MIPS_SAVED_REGSIZE);
      else
	{
	  /* We have to get the saved pc from the sigcontext if it is
	     a signal handler frame.  */
	  int pcreg = (get_frame_type (frame) == SIGTRAMP_FRAME ? PC_REGNUM
		       : proc_desc ? PROC_PC_REG (proc_desc) : RA_REGNUM);
	  saved_pc = read_next_frame_reg (frame, NUM_REGS + pcreg);
	}
    }
d1790 4
a1793 10
/* Set a register's saved stack address in temp_saved_regs.  If an
   address has already been set for this register, do nothing; this
   way we will only recognize the first save of a given register in a
   function prologue.

   For simplicity, save the address in both [0 .. NUM_REGS) and
   [NUM_REGS .. 2*NUM_REGS).  Strictly speaking, only the second range
   is used as it is only second range (the ABI instead of ISA
   registers) that comes into play when finding saved registers in a
   frame.  */
d1796 1
a1796 1
set_reg_offset (CORE_ADDR *saved_regs, int regno, CORE_ADDR offset)
d1798 2
a1799 5
  if (saved_regs[regno] == 0)
    {
      saved_regs[regno + 0 * NUM_REGS] = offset;
      saved_regs[regno + 1 * NUM_REGS] = offset;
    }
d1995 1
a1995 1
	  set_reg_offset (temp_saved_regs, reg, sp + offset);
d2002 1
a2002 1
	  set_reg_offset (temp_saved_regs, reg, sp + offset);
d2008 1
a2008 1
	  set_reg_offset (temp_saved_regs, RA_REGNUM, sp + offset);
d2014 1
a2014 1
	  set_reg_offset (temp_saved_regs, RA_REGNUM, sp + offset);
d2033 1
a2033 1
	  set_reg_offset (temp_saved_regs, reg, frame_addr + offset);
d2040 1
a2040 1
	  set_reg_offset (temp_saved_regs, reg, frame_addr + offset);
d2070 1
a2070 1
	  set_reg_offset (temp_saved_regs, reg, sp + offset);
d2079 1
a2079 1
	  set_reg_offset (temp_saved_regs, RA_REGNUM, sp + offset);
d2087 1
a2087 1
	  set_reg_offset (temp_saved_regs, reg, sp + offset);
d2132 1
a2132 1
	  set_reg_offset (temp_saved_regs, reg, sp + low_word);
d2140 1
a2140 1
	  set_reg_offset (temp_saved_regs, reg, sp + low_word + 8 - MIPS_REGSIZE);
d2151 1
a2151 1
	      frame_addr = read_next_frame_reg (next_frame, NUM_REGS + 30);
d2174 1
a2174 1
	      frame_addr = read_next_frame_reg (next_frame, NUM_REGS + 30);
d2190 1
a2190 1
	  set_reg_offset (temp_saved_regs, reg, frame_addr + low_word);
d2202 1
a2202 1
    sp = read_next_frame_reg (next_frame, NUM_REGS + SP_REGNUM);
d2475 1
a2475 1
  return (read_next_frame_reg (frame, NUM_REGS + PROC_FRAME_REG (proc_desc))
d2561 1
a2561 1
	deprecated_update_frame_base_hack (fci, read_next_frame_reg (get_next_frame (fci), NUM_REGS + SP_REGNUM));
d2589 9
a2597 12
	      /* Set value of previous frame's stack pointer.
	         Remember that saved_regs[SP_REGNUM] is special in
	         that it contains the value of the stack pointer
	         register.  The other saved_regs values are addresses
	         (in the inferior) at which a given register's value
	         may be found.  */
	      set_reg_offset (temp_saved_regs, SP_REGNUM,
			      get_frame_base (fci));
	      set_reg_offset (temp_saved_regs, PC_REGNUM,
			      temp_saved_regs[RA_REGNUM]);
	      memcpy (get_frame_saved_regs (fci), temp_saved_regs,
		      SIZEOF_FRAME_SAVED_REGS);
d2700 5
a2704 4
mips_eabi_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			   struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
			   struct value **args, CORE_ADDR sp, int struct_return,
			   CORE_ADDR struct_addr)
a2711 8
  /* For shared libraries, "t9" needs to point at the function
     address.  */
  regcache_cooked_write_signed (regcache, T9_REGNUM, func_addr);

  /* Set the return address register to point to the entry point of
     the program, where a breakpoint lies in wait.  */
  regcache_cooked_write_signed (regcache, RA_REGNUM, bp_addr);

d2731 1
a2731 1
			"mips_eabi_push_dummy_call: sp=0x%s allocated %d\n",
d2743 1
a2743 1
			    "mips_eabi_push_dummy_call: struct_return reg=%d 0x%s\n",
d2762 1
a2762 1
			    "mips_eabi_push_dummy_call: %d len=%d type=%d",
a2945 2
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);

d2950 1
a2950 1
/* N32/N64 version of push_dummy_call.  */
d2953 5
a2957 4
mips_n32n64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			     struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
			     struct value **args, CORE_ADDR sp, int struct_return,
			     CORE_ADDR struct_addr)
a2964 8
  /* For shared libraries, "t9" needs to point at the function
     address.  */
  regcache_cooked_write_signed (regcache, T9_REGNUM, func_addr);

  /* Set the return address register to point to the entry point of
     the program, where a breakpoint lies in wait.  */
  regcache_cooked_write_signed (regcache, RA_REGNUM, bp_addr);

d2982 1
a2982 1
			"mips_n32n64_push_dummy_call: sp=0x%s allocated %d\n",
d2994 1
a2994 1
			    "mips_n32n64_push_dummy_call: struct_return reg=%d 0x%s\n",
d3013 1
a3013 1
			    "mips_n32n64_push_dummy_call: %d len=%d type=%d",
a3167 2
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);

d3172 1
a3172 1
/* O32 version of push_dummy_call.  */
d3175 5
a3179 4
mips_o32_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			  struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
			  struct value **args, CORE_ADDR sp, int struct_return,
			  CORE_ADDR struct_addr)
a3186 8
  /* For shared libraries, "t9" needs to point at the function
     address.  */
  regcache_cooked_write_signed (regcache, T9_REGNUM, func_addr);

  /* Set the return address register to point to the entry point of
     the program, where a breakpoint lies in wait.  */
  regcache_cooked_write_signed (regcache, RA_REGNUM, bp_addr);

d3204 1
a3204 1
			"mips_o32_push_dummy_call: sp=0x%s allocated %d\n",
d3216 1
a3216 1
			    "mips_o32_push_dummy_call: struct_return reg=%d 0x%s\n",
d3236 1
a3236 1
			    "mips_o32_push_dummy_call: %d len=%d type=%d",
a3466 2
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);

d3471 1
a3471 1
/* O64 version of push_dummy_call.  */
d3474 5
a3478 4
mips_o64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			  struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
			  struct value **args, CORE_ADDR sp, int struct_return,
			  CORE_ADDR struct_addr)
a3485 8
  /* For shared libraries, "t9" needs to point at the function
     address.  */
  regcache_cooked_write_signed (regcache, T9_REGNUM, func_addr);

  /* Set the return address register to point to the entry point of
     the program, where a breakpoint lies in wait.  */
  regcache_cooked_write_signed (regcache, RA_REGNUM, bp_addr);

d3503 1
a3503 1
			"mips_o64_push_dummy_call: sp=0x%s allocated %d\n",
d3515 1
a3515 1
			    "mips_o64_push_dummy_call: struct_return reg=%d 0x%s\n",
d3535 1
a3535 1
			    "mips_o64_push_dummy_call: %d len=%d type=%d",
d3766 3
a3768 1
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);
d3770 6
a3775 1
  /* Return adjusted stack pointer.  */
d3796 2
a3797 1
  mips_find_saved_regs (frame);
d3853 7
d3912 1
a3912 2
mips_read_fp_register_single (struct frame_info *frame, int regno,
			      char *rare_buffer)
d3917 1
a3917 1
  if (!frame_register_read (frame, regno, raw_buffer))
d3943 1
a3943 2
mips_read_fp_register_double (struct frame_info *frame, int regno,
			      char *rare_buffer)
d3951 1
a3951 1
      if (!frame_register_read (frame, regno, rare_buffer))
d3965 2
a3966 2
	  mips_read_fp_register_single (frame, regno, rare_buffer + 4);
	  mips_read_fp_register_single (frame, regno + 1, rare_buffer);
d3970 2
a3971 2
	  mips_read_fp_register_single (frame, regno, rare_buffer);
	  mips_read_fp_register_single (frame, regno + 1, rare_buffer + 4);
d3977 1
a3977 2
mips_print_fp_register (struct ui_file *file, struct frame_info *frame,
			int regnum)
d3985 2
a3986 3
  fprintf_filtered (file, "%s:", REGISTER_NAME (regnum));
  fprintf_filtered (file, "%*s", 4 - (int) strlen (REGISTER_NAME (regnum)),
		    "");
d3992 1
a3992 1
      mips_read_fp_register_single (frame, regnum, raw_buffer);
d3995 2
a3996 1
      print_scalar_formatted (raw_buffer, builtin_type_uint32, 'x', 'w', file);
d3998 1
a3998 1
      fprintf_filtered (file, " flt: ");
d4000 1
a4000 1
	fprintf_filtered (file, " <invalid float> ");
d4002 1
a4002 1
	fprintf_filtered (file, "%-17.9g", flt1);
d4006 1
a4006 1
	  mips_read_fp_register_double (frame, regnum, raw_buffer);
d4010 1
a4010 1
	  fprintf_filtered (file, " dbl: ");
d4012 1
a4012 1
	    fprintf_filtered (file, "<invalid double>");
d4014 1
a4014 1
	    fprintf_filtered (file, "%-24.17g", doub);
d4020 1
a4020 1
      mips_read_fp_register_single (frame, regnum, raw_buffer);
d4023 1
a4023 1
      mips_read_fp_register_double (frame, regnum, raw_buffer);
d4027 2
a4028 1
      print_scalar_formatted (raw_buffer, builtin_type_uint64, 'x', 'g', file);
d4030 1
a4030 1
      fprintf_filtered (file, " flt: ");
d4032 1
a4032 1
	fprintf_filtered (file, "<invalid float>");
d4034 1
a4034 1
	fprintf_filtered (file, "%-17.9g", flt1);
d4036 1
a4036 1
      fprintf_filtered (file, " dbl: ");
d4038 1
a4038 1
	fprintf_filtered (file, "<invalid double>");
d4040 1
a4040 1
	fprintf_filtered (file, "%-24.17g", doub);
d4045 1
a4045 2
mips_print_register (struct ui_file *file, struct frame_info *frame,
		     int regnum, int all)
a4046 1
  struct gdbarch *gdbarch = get_frame_arch (frame);
d4050 1
a4050 1
  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d4052 1
a4052 1
      mips_print_fp_register (file, frame, regnum);
d4057 1
a4057 1
  if (!frame_register_read (frame, regnum, raw_buffer))
d4059 1
a4059 1
      fprintf_filtered (file, "%s: [Invalid]", REGISTER_NAME (regnum));
d4063 1
a4063 1
  fputs_filtered (REGISTER_NAME (regnum), file);
d4070 1
a4070 1
    fprintf_filtered (file, "(r%d): ", regnum);
d4072 1
a4072 1
    fprintf_filtered (file, ": ");
d4079 3
a4081 2
  print_scalar_formatted (raw_buffer + offset, gdbarch_register_type (gdbarch, regnum),
			  'x', 0, file);
d4088 1
a4088 2
print_fp_register_row (struct ui_file *file, struct frame_info *frame,
		       int regnum)
d4090 3
a4092 3
  fprintf_filtered (file, " ");
  mips_print_fp_register (file, frame, regnum);
  fprintf_filtered (file, "\n");
d4100 1
a4100 2
print_gp_register_row (struct ui_file *file, struct frame_info *frame,
		       int start_regnum)
a4101 1
  struct gdbarch *gdbarch = get_frame_arch (frame);
d4106 3
a4108 1
  int regnum;
d4111 2
a4112 4
  fprintf_filtered (file, "     ");
  for (col = 0, regnum = start_regnum;
       col < ncols && regnum < NUM_REGS + NUM_PSEUDO_REGS;
       regnum++)
d4116 1
a4116 1
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d4118 2
a4119 2
      fprintf_filtered (file, MIPS_REGSIZE == 8 ? "%17s" : "%9s",
			REGISTER_NAME (regnum));
d4122 2
a4123 5
  /* print the R0 to R31 names */
  fprintf_filtered (file,
		    (start_regnum % NUM_REGS) < MIPS_NUMREGS
		    ? "\n R%-4d" : "\n      ",
		    start_regnum);
d4125 1
d4127 1
a4127 3
  for (col = 0, regnum = start_regnum;
       col < ncols && regnum < NUM_REGS + NUM_PSEUDO_REGS;
       regnum++)
d4131 1
a4131 1
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d4134 1
a4134 1
      if (!frame_register_read (frame, regnum, raw_buffer))
d4144 1
a4144 1
	  fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[byte]);
d4149 2
a4150 2
	  fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[byte]);
      fprintf_filtered (file, " ");
d4154 1
a4154 1
    fprintf_filtered (file, "\n");
d4162 1
a4162 2
mips_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,
			   struct frame_info *frame, int regnum, int all)
a4165 1
      gdb_assert (regnum >= NUM_REGS);
d4169 2
a4170 2
      mips_print_register (file, frame, regnum, 0);
      fprintf_filtered (file, "\n");
d4175 2
a4176 2
      regnum = NUM_REGS;
      while (regnum < NUM_REGS + NUM_PSEUDO_REGS)
d4178 5
a4182 7
	  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
	    {
	      if (all)		/* true for "INFO ALL-REGISTERS" command */
		regnum = print_fp_register_row (file, frame, regnum);
	      else
		regnum += MIPS_NUMREGS;	/* skip floating point regs */
	    }
d4184 1
a4184 1
	    regnum = print_gp_register_row (file, frame, regnum);
d4663 1
a4663 1
      mips_xfer_register (regcache, NUM_REGS + FP0_REGNUM, TYPE_LENGTH (type),
d4670 3
a4672 3
      /* A double-precision floating-point value.  The most
         significant part goes in FP1, and the least significant in
         FP0.  */
d4674 1
a4674 1
	fprintf_unfiltered (gdb_stderr, "Return float in $fp1/$fp0\n");
d4678 1
a4678 1
	  mips_xfer_register (regcache, NUM_REGS + FP0_REGNUM + 0, 4,
d4680 1
a4680 1
	  mips_xfer_register (regcache, NUM_REGS + FP0_REGNUM + 1, 4,
d4684 1
a4684 1
	  mips_xfer_register (regcache, NUM_REGS + FP0_REGNUM + 1, 4,
d4686 1
a4686 1
	  mips_xfer_register (regcache, NUM_REGS + FP0_REGNUM + 0, 4,
d4721 1
a4721 2
	  mips_xfer_register (regcache, NUM_REGS + regnum,
			      TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
d4745 2
a4746 2
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      BFD_ENDIAN_UNKNOWN, in, out, offset);
d4768 2
a4769 2
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      TARGET_BYTE_ORDER, in, out, offset);
d4803 1
a4803 1
      mips_xfer_register (regcache, NUM_REGS + FP0_REGNUM, TYPE_LENGTH (type),
d4833 1
a4833 2
	  mips_xfer_register (regcache, NUM_REGS + regnum,
			      TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
d4855 2
a4856 2
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      BFD_ENDIAN_UNKNOWN, in, out, offset);
d4876 2
a4877 2
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      TARGET_BYTE_ORDER, in, out, offset);
d4896 6
d5099 1
a5099 1
  proc_desc = non_heuristic_proc_desc (make_mips16_addr (memaddr), NULL);
a5104 4
  /* FIXME: cagney/2003-06-26: Is this even necessary?  The
     disassembler needs to be able to locally determine the ISA, and
     not rely on GDB.  Otherwize the stand-alone 'objdump -d' will not
     work.  */
d5106 2
a5107 4
    {
      if (pc_is_mips16 (PROC_LOW_ADDR (proc_desc)))
	info->mach =  bfd_mach_mips16;
    }
d5109 2
a5110 4
    {
      if (pc_is_mips16 (memaddr))
       info->mach = bfd_mach_mips16;
    } 
d5137 1
a5137 1
	  *pcptr = unmake_mips16_addr (*pcptr);
d5167 1
a5167 1
	  *pcptr = unmake_mips16_addr (*pcptr);
a5403 1
  int realnumx;
d5405 2
a5406 2
  /* Always a pseudo.  */
  gdb_assert (regnum >= NUM_REGS);
d5415 20
a5434 14

  if ((regnum % NUM_REGS) == SP_REGNUM)
    /* The SP_REGNUM is special, its value is stored in saved_regs.
       In fact, it is so special that it can even only be fetched
       using a raw register number!  Once this code as been converted
       to frame-unwind the problem goes away.  */
    frame_register_unwind (deprecated_get_next_frame_hack (frame),
			   regnum % NUM_REGS, optimizedp, lvalp, addrp,
			   &realnumx, raw_buffer);
  else
    /* Get it from the next frame.  */
    frame_register_unwind (deprecated_get_next_frame_hack (frame),
			   regnum, optimizedp, lvalp, addrp,
			   &realnumx, raw_buffer);
d5449 2
a5450 2
/* Convert a dbx stab register number (from `r' declaration) to a GDB
   [1 * NUM_REGS .. 2 * NUM_REGS) REGNUM.  */
a5454 1
  int regnum;
d5456 1
a5456 1
    regnum = num;
d5458 1
a5458 1
    regnum = num + FP0_REGNUM - 38;
d5460 1
a5460 1
    regnum = HI_REGNUM;
d5462 1
a5462 1
    regnum = LO_REGNUM;
d5464 5
a5468 4
    /* This will hopefully (eventually) provoke a warning.  Should
       we be calling complaint() here?  */
    return NUM_REGS + NUM_PSEUDO_REGS;
  return NUM_REGS + regnum;
d5472 1
a5472 2
/* Convert a dwarf, dwarf2, or ecoff register number to a GDB [1 *
   NUM_REGS .. 2 * NUM_REGS) REGNUM.  */
a5476 1
  int regnum;
d5478 1
a5478 1
    regnum = num;
d5480 1
a5480 1
    regnum = num + FP0_REGNUM - 32;
d5482 1
a5482 1
    regnum = HI_REGNUM;
d5484 1
a5484 1
    regnum = LO_REGNUM;
d5486 5
a5490 19
    /* This will hopefully (eventually) provoke a warning.  Should we
       be calling complaint() here?  */
    return NUM_REGS + NUM_PSEUDO_REGS;
  return NUM_REGS + regnum;
}

static int
mips_register_sim_regno (int regnum)
{
  /* Only makes sense to supply raw registers.  */
  gdb_assert (regnum >= 0 && regnum < NUM_REGS);
  /* FIXME: cagney/2002-05-13: Need to look at the pseudo register to
     decide if it is valid.  Should instead define a standard sim/gdb
     register numbering scheme.  */
  if (REGISTER_NAME (NUM_REGS + regnum) != NULL
      && REGISTER_NAME (NUM_REGS + regnum)[0] != '\0')
    return regnum;
  else
    return LEGACY_SIM_REGNO_IGNORE;    
d5553 2
a5558 1
  int num_regs;
d5711 3
a5713 5
  set_gdbarch_deprecated_register_raw_size (gdbarch, mips_register_raw_size);
  set_gdbarch_deprecated_register_byte (gdbarch, mips_register_byte);
  set_gdbarch_register_reggroup_p (gdbarch, mips_register_reggroup_p);
  set_gdbarch_pseudo_register_read (gdbarch, mips_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, mips_pseudo_register_write);
a5719 1

d5721 1
a5721 1
    num_regs = 71;
d5723 1
a5723 3
    num_regs = 90;
  set_gdbarch_num_regs (gdbarch, num_regs);
  set_gdbarch_num_pseudo_regs (gdbarch, num_regs);
d5728 1
a5728 1
      set_gdbarch_push_dummy_call (gdbarch, mips_o32_push_dummy_call);
d5744 1
a5744 1
					 always_use_struct_convention);
d5747 1
a5747 1
      set_gdbarch_push_dummy_call (gdbarch, mips_o64_push_dummy_call);
d5762 2
a5763 1
      set_gdbarch_use_struct_convention (gdbarch, always_use_struct_convention);
d5766 1
a5766 1
      set_gdbarch_push_dummy_call (gdbarch, mips_eabi_push_dummy_call);
d5785 1
a5785 1
      set_gdbarch_push_dummy_call (gdbarch, mips_eabi_push_dummy_call);
d5804 1
a5804 1
      set_gdbarch_push_dummy_call (gdbarch, mips_n32n64_push_dummy_call);
d5823 1
a5823 1
      set_gdbarch_push_dummy_call (gdbarch, mips_n32n64_push_dummy_call);
d5901 1
a5916 1
  set_gdbarch_register_sim_regno (gdbarch, mips_register_sim_regno);
d5919 1
a5919 1
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, mips_find_saved_regs);
d5925 1
d5927 4
d5932 6
a5937 4
  set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
  set_gdbarch_deprecated_register_convertible (gdbarch, mips_register_convertible);
  set_gdbarch_deprecated_register_convert_to_virtual (gdbarch, mips_register_convert_to_virtual);
  set_gdbarch_deprecated_register_convert_to_raw (gdbarch, mips_register_convert_to_raw);
d5943 1
d5961 4
a5964 1
  set_gdbarch_register_type (gdbarch, mips_register_type);
d5966 1
a5966 1
  set_gdbarch_print_registers_info (gdbarch, mips_print_registers_info);
d5972 1
d6166 2
d6189 2
d6253 6
d6336 5
d6361 2
a6385 2

extern initialize_file_ftype _initialize_mips_tdep; /* -Wmissing-prototypes */
@


1.126.2.12
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a52 1
static struct type *mips_register_type (struct gdbarch *gdbarch, int regnum);
d673 1
a673 1
      return TYPE_LENGTH (gdbarch_register_type (current_gdbarch, rawnum));
d703 1
a703 2
	byte += TYPE_LENGTH (gdbarch_register_type (current_gdbarch,
                                                    (reg % NUM_REGS)));
d4287 4
a4290 4
  if ((start_regnum % NUM_REGS) < MIPS_NUMREGS)
    fprintf_filtered (file, "\n R%-4d", start_regnum % NUM_REGS);
  else
    fprintf_filtered (file, "\n      ");
@


1.126.2.13
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a50 1
#include "dis-asm.h"
d377 2
d658 1
a658 1
	 combination of REGISTER_RAW_SIZE and DEPRECATED_REGISTER_BYTE.  */
d2593 1
a2593 1
      struct linked_proc_info *link;
d2627 1
a2627 1
  if (saved_pc == 0 || deprecated_inside_entry_file (saved_pc))
d3950 1
a3950 1
  int regnum;
d4746 1
a4746 1
	  regbuf + DEPRECATED_REGISTER_BYTE (lo.reg) + lo.reg_offset,
d4751 1
a4751 1
	    regbuf + DEPRECATED_REGISTER_BYTE (hi.reg) + hi.reg_offset,
d4765 1
a4765 1
	  regbuf + DEPRECATED_REGISTER_BYTE (lo.reg) + lo.reg_offset,
d4770 1
a4770 1
	    regbuf + DEPRECATED_REGISTER_BYTE (hi.reg) + hi.reg_offset,
d4787 1
a4787 1
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (lo.reg), raw_buffer,
d4794 1
a4794 1
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (hi.reg), raw_buffer,
d4809 1
a4809 1
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (lo.reg), raw_buffer,
d4816 1
a4816 1
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (hi.reg), raw_buffer,
d5258 2
a5259 2
static int
gdb_print_insn_mips (bfd_vma memaddr, struct disassemble_info *info)
a5260 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
a5292 20
  /* Set the disassembler options.  */
  if (tdep->mips_abi == MIPS_ABI_N32
      || tdep->mips_abi == MIPS_ABI_N64)
    {
      /* Set up the disassembler info, so that we get the right
	 register names from libopcodes.  */
      if (tdep->mips_abi == MIPS_ABI_N32)
	info->disassembler_options = "gpr-names=n32";
      else
	info->disassembler_options = "gpr-names=64";
      info->flavour = bfd_target_elf_flavour;
    }
  else
    /* This string is not recognized explicitly by the disassembler,
       but it tells the disassembler to not try to guess the ABI from
       the bfd elf headers, such that, if the user overrides the ABI
       of a program linked as NewABI, the disassembly will follow the
       register naming conventions specified by the user.  */
    info->disassembler_options = "gpr-names=32";

d5543 19
d5748 6
d5833 28
d5934 2
a5935 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_o32_reg_struct_has_addr);
d5953 2
a5954 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_o32_reg_struct_has_addr);
d5971 2
a5972 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_eabi_reg_struct_has_addr);
d5990 2
a5991 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_eabi_reg_struct_has_addr);
d6011 2
a6012 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_n32n64_reg_struct_has_addr);
d6030 2
a6031 2
      set_gdbarch_deprecated_reg_struct_has_addr
	(gdbarch, mips_n32n64_reg_struct_has_addr);
d6116 1
a6116 4
  /* NOTE: cagney/2003-08-05: Eventually call dummy location will be
     replaced by a command, and all targets will default to on stack
     (regardless of the stack's execute status).  */
  set_gdbarch_call_dummy_location (gdbarch, AT_SYMBOL);
a6149 10
  set_gdbarch_print_insn (gdbarch, gdb_print_insn_mips);

  /* FIXME: cagney/2003-08-29: The macros HAVE_STEPPABLE_WATCHPOINT,
     HAVE_NONSTEPPABLE_WATCHPOINT, and HAVE_CONTINUABLE_WATCHPOINT
     need to all be folded into the target vector.  Since they are
     being used as guards for STOPPED_BY_WATCHPOINT, why not have
     STOPPED_BY_WATCHPOINT return the type of watchpoint that the code
     is sitting on?  */
  set_gdbarch_have_nonsteppable_watchpoint (gdbarch, 1);

d6331 3
d6564 2
@


1.126.2.14
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d184 1
a184 1
  void *buf = alloca (DEPRECATED_REGISTER_RAW_SIZE (regnum));
d186 1
a186 1
  return (extract_signed_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regnum)));
d282 1
a282 1
      reg_offset = DEPRECATED_REGISTER_RAW_SIZE (reg_num) - length;
d328 1
a328 1
  if (DEPRECATED_REGISTER_RAW_SIZE (FP0_REGNUM) == 4)
d627 12
d657 1
a657 1
	 combination of DEPRECATED_REGISTER_RAW_SIZE and DEPRECATED_REGISTER_BYTE.  */
d659 1
a659 1
	return DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum);
d682 1
a682 1
   should strictly return the layout of the buffer.  Unfortunately
d720 1
a720 1
    return (DEPRECATED_REGISTER_RAW_SIZE (reg_nr) > DEPRECATED_REGISTER_VIRTUAL_SIZE (reg_nr));
d729 1
a729 1
	    raw_buf + (DEPRECATED_REGISTER_RAW_SIZE (n) - TYPE_LENGTH (virtual_type)),
d741 1
a741 1
  memset (raw_buf, 0, DEPRECATED_REGISTER_RAW_SIZE (n));
d743 1
a743 1
    memcpy (raw_buf + (DEPRECATED_REGISTER_RAW_SIZE (n) - TYPE_LENGTH (virtual_type)),
d756 1
a756 1
	  && DEPRECATED_REGISTER_RAW_SIZE (regnum) == 4
d766 2
a767 2
  get_frame_register (frame, regnum + 0, (char *) to + 4);
  get_frame_register (frame, regnum + 1, (char *) to + 0);
d1573 1
a1573 1
  if (deprecated_get_frame_saved_regs (fci) != NULL)
d1744 1
a1744 1
		 Unfortunately, when big-endian the most significant
d2736 1
a2736 1
	      memcpy (deprecated_get_frame_saved_regs (fci), temp_saved_regs,
d2825 6
d2836 1
a2836 1
  return align_down (addr, 16);
d2865 2
a2866 2
  sp = align_down (sp, 16);
  struct_addr = align_down (struct_addr, 16);
d2872 1
a2872 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d2874 1
a2874 1
  sp -= align_up (len, 16);
d2878 2
a2879 2
			"mips_eabi_push_dummy_call: sp=0x%s allocated %ld\n",
			paddr_nz (sp), (long) align_up (len, 16));
d3086 1
a3086 1
		stack_offset += align_up (partial_len, MIPS_STACK_ARGSIZE);
d3127 2
a3128 2
  sp = align_down (sp, 16);
  struct_addr = align_down (struct_addr, 16);
d3132 1
a3132 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d3134 1
a3134 1
  sp -= align_up (len, 16);
d3138 2
a3139 2
			"mips_n32n64_push_dummy_call: sp=0x%s allocated %ld\n",
			paddr_nz (sp), (long) align_up (len, 16));
d3317 1
a3317 1
		stack_offset += align_up (partial_len, MIPS_STACK_ARGSIZE);
d3358 2
a3359 2
  sp = align_down (sp, 16);
  struct_addr = align_down (struct_addr, 16);
d3363 1
a3363 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d3365 1
a3365 1
  sp -= align_up (len, 16);
d3369 2
a3370 2
			"mips_o32_push_dummy_call: sp=0x%s allocated %ld\n",
			paddr_nz (sp), (long) align_up (len, 16));
d3481 1
a3481 1
	  stack_offset += align_up (len, MIPS_STACK_ARGSIZE);
d3625 1
a3625 1
	      stack_offset += align_up (partial_len, MIPS_STACK_ARGSIZE);
d3666 2
a3667 2
  sp = align_down (sp, 16);
  struct_addr = align_down (struct_addr, 16);
d3671 1
a3671 1
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
d3673 1
a3673 1
  sp -= align_up (len, 16);
d3677 2
a3678 2
			"mips_o64_push_dummy_call: sp=0x%s allocated %ld\n",
			paddr_nz (sp), (long) align_up (len, 16));
d3789 1
a3789 1
	  stack_offset += align_up (len, MIPS_STACK_ARGSIZE);
d3933 1
a3933 1
	      stack_offset += align_up (partial_len, MIPS_STACK_ARGSIZE);
d3966 1
a3966 1
	&& deprecated_get_frame_saved_regs (frame)[regnum])
d3973 1
a3973 1
			  read_memory_unsigned_integer (deprecated_get_frame_saved_regs (frame)[regnum],
d3977 1
a3977 1
			  read_memory_integer (deprecated_get_frame_saved_regs (frame)[regnum],
d4074 1
a4074 1
  int raw_size = DEPRECATED_REGISTER_RAW_SIZE (regno);
d4106 1
a4106 1
  int raw_size = DEPRECATED_REGISTER_RAW_SIZE (regno);
d4145 1
a4145 1
  raw_buffer = (char *) alloca (2 * DEPRECATED_REGISTER_RAW_SIZE (FP0_REGNUM));
d4151 1
a4151 1
  if (DEPRECATED_REGISTER_RAW_SIZE (regnum) == 4 || mips2_fp_compat ())
d4238 1
a4238 1
    offset = DEPRECATED_REGISTER_RAW_SIZE (regnum) - DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum);
d4306 1
a4306 1
      for (byte = 0; byte < (MIPS_REGSIZE - DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum)); byte++)
d4310 2
a4311 2
	for (byte = DEPRECATED_REGISTER_RAW_SIZE (regnum) - DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum);
	     byte < DEPRECATED_REGISTER_RAW_SIZE (regnum);
d4315 1
a4315 1
	for (byte = DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum) - 1;
d4650 1
a4650 1
			     && DEPRECATED_REGISTER_RAW_SIZE (FP0_REGNUM) == 8)
d4663 1
a4663 1
			     && DEPRECATED_REGISTER_RAW_SIZE (FP0_REGNUM) == 8
d4719 1
a4719 1
	  && DEPRECATED_REGISTER_RAW_SIZE (regnum) == 8
d4787 1
a4787 1
				   DEPRECATED_REGISTER_RAW_SIZE (lo.reg));
d4794 1
a4794 1
				       DEPRECATED_REGISTER_RAW_SIZE (hi.reg));
d4809 1
a4809 1
				   DEPRECATED_REGISTER_RAW_SIZE (lo.reg));
d4816 1
a4816 1
				       DEPRECATED_REGISTER_RAW_SIZE (hi.reg));
d4911 1
a4911 1
	   offset += DEPRECATED_REGISTER_RAW_SIZE (regnum), regnum++)
d4913 1
a4913 1
	  int xfer = DEPRECATED_REGISTER_RAW_SIZE (regnum);
d5022 1
a5022 1
	   offset += DEPRECATED_REGISTER_RAW_SIZE (regnum), regnum++)
d5024 1
a5024 1
	  int xfer = DEPRECATED_REGISTER_RAW_SIZE (regnum);
d5042 1
a5042 1
	   offset += DEPRECATED_REGISTER_RAW_SIZE (regnum), regnum++)
d5044 1
a5044 1
	  int xfer = DEPRECATED_REGISTER_RAW_SIZE (regnum);
d6050 1
a6050 1
     #undef/#define MIPS_REGISTER_NAMES and the new REGISTER_NAME(nr).
d6052 3
d6068 1
d6373 3
d6405 6
d6514 5
@


1.126.2.15
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d137 1
a138 9
    /* Is the target using 64-bit raw integer registers but only
       storing a left-aligned 32-bit value in each?  */
    int mips64_transfers_32bit_regs_p;
    /* Indexes for various registers.  IRIX and embedded have
       different values.  This contains the "public" fields.  Don't
       add any that do not need to be public.  */
    const struct mips_regnum *regnum;
    /* Register names table for the current register set.  */
    const char **mips_processor_reg_names;
a140 12
const struct mips_regnum *
mips_regnum (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->regnum;
}

static int
mips_fpa0_regnum (struct gdbarch *gdbarch)
{
  return mips_regnum (gdbarch)->fp0 + 12;
}

d184 1
a184 1
  void *buf = alloca (register_size (current_gdbarch, regnum));
d186 1
a186 1
  return (extract_signed_integer (buf, register_size (current_gdbarch, regnum)));
a215 7
int
mips_regsize (struct gdbarch *gdbarch)
{
  return (gdbarch_bfd_arch_info (gdbarch)->bits_per_word
	  / gdbarch_bfd_arch_info (gdbarch)->bits_per_byte);
}

d229 3
a231 1
   "info" field is used for this purpose.
d237 3
a239 1
   MSYMBOL_IS_SPECIAL   tests the "special" bit in a minimal symbol  */
d258 6
d282 1
a282 1
      reg_offset = register_size (current_gdbarch, reg_num) - length;
d328 1
a328 1
  if (register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0) == 4)
d346 3
a348 1
   form double-precision values).  See also MIPS_FPU_TYPE.  */
d372 2
d385 4
d401 7
d413 4
d419 3
a421 52
   are listed in the followign tables.  */

enum { NUM_MIPS_PROCESSOR_REGS = (90 - 32) };

/* Generic MIPS.  */

static const char *mips_generic_reg_names[NUM_MIPS_PROCESSOR_REGS] = {
  "sr",	"lo",	"hi",	"bad",	"cause","pc",
  "f0",   "f1",   "f2",   "f3",   "f4",   "f5",   "f6",   "f7",
  "f8",   "f9",   "f10",  "f11",  "f12",  "f13",  "f14",  "f15",
  "f16",  "f17",  "f18",  "f19",  "f20",  "f21",  "f22",  "f23",
  "f24",  "f25",  "f26",  "f27",  "f28",  "f29",  "f30",  "f31",
  "fsr",  "fir",  ""/*"fp"*/,	"",
  "",	"",	"",	"",	"",	"",	"",	"",
  "",	"",	"",	"",	"",	"",	"",	"",
};

/* Names of IDT R3041 registers.  */

static const char *mips_r3041_reg_names[] = {
  "sr",	"lo",	"hi",	"bad",	"cause","pc",
  "f0",   "f1",   "f2",   "f3",   "f4",   "f5",   "f6",   "f7",
  "f8",   "f9",   "f10",  "f11",  "f12",  "f13",  "f14",  "f15",
  "f16",  "f17",  "f18",  "f19",  "f20",  "f21",  "f22",  "f23",
  "f24",  "f25",  "f26",  "f27",  "f28",  "f29",  "f30",  "f31",
  "fsr",  "fir",  "",/*"fp"*/	"",
  "",	"",	"bus",	"ccfg",	"",	"",	"",	"",
  "",	"",	"port",	"cmp",	"",	"",	"epc",	"prid",
};

/* Names of tx39 registers.  */

static const char *mips_tx39_reg_names[NUM_MIPS_PROCESSOR_REGS] = {
  "sr",	"lo",	"hi",	"bad",	"cause","pc",
  "",   "",   	"",   	"",   	"",   	"",   	"",   	"",
  "",   "",   	"",  	"",  	"",  	"",  	"",  	"",
  "",  	"",  	"",  	"",  	"",  	"",  	"",  	"",
  "",  	"",  	"",  	"",  	"",  	"",  	"",  	"",
  "",  	"",  	"",	"",
  "",	"",	"",	"",	"",	"",	"",	"",
  "",	"", "config", "cache", "debug", "depc", "epc",	""
};

/* Names of IRIX registers.  */
static const char *mips_irix_reg_names[NUM_MIPS_PROCESSOR_REGS] = {
  "f0",   "f1",   "f2",   "f3",   "f4",   "f5",   "f6",   "f7",
  "f8",   "f9",   "f10",  "f11",  "f12",  "f13",  "f14",  "f15",
  "f16",  "f17",  "f18",  "f19",  "f20",  "f21",  "f22",  "f23",
  "f24",  "f25",  "f26",  "f27",  "f28",  "f29",  "f30",  "f31",
  "pc",	"cause", "bad",	"hi",	"lo",	"fsr",  "fir"
};

a426 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d462 1
a462 4
    {
      gdb_assert (rawnum - 32 < NUM_MIPS_PROCESSOR_REGS);
      return tdep->mips_processor_reg_names[rawnum - 32];
    }
d468 67
d575 1
a575 1
   registers.  Take care of alignment and size problems.  */
a580 1
  int rawnum = cookednum % NUM_REGS;
d582 1
a582 12
  if (register_size (gdbarch, rawnum) == register_size (gdbarch, cookednum))
    return regcache_raw_read (regcache, rawnum, buf);
  else if (register_size (gdbarch, rawnum) > register_size (gdbarch, cookednum))
    {
      if (gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p
	  || TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
	regcache_raw_read_part (regcache, rawnum, 0, 4, buf);
      else
	regcache_raw_read_part (regcache, rawnum, 4, 4, buf);
    }
  else
    internal_error (__FILE__, __LINE__, "bad register size");
a588 1
  int rawnum = cookednum % NUM_REGS;
d590 1
a590 12
  if (register_size (gdbarch, rawnum) == register_size (gdbarch, cookednum))
    return regcache_raw_write (regcache, rawnum, buf);
  else if (register_size (gdbarch, rawnum) > register_size (gdbarch, cookednum))
    {
      if (gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p
	  || TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
	regcache_raw_write_part (regcache, rawnum, 0, 4, buf);
      else
	regcache_raw_write_part (regcache, rawnum, 4, 4, buf);
    }
  else
    internal_error (__FILE__, __LINE__, "bad register size");
d628 2
a629 2
   register N.  NOTE: This defines the pseudo register type so need to
   rebuild the architecture vector.  */
d633 43
a675 3
static void
set_mips64_transfers_32bit_regs (char *args, int from_tty,
				 struct cmd_list_element *c)
d677 5
a681 6
  struct gdbarch_info info;
  gdbarch_info_init (&info);
  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
     instead of relying on globals.  Doing that would let generic code
     handle the search for this specific architecture.  */
  if (!gdbarch_update_p (info))
d683 11
a693 2
      mips64_transfers_32bit_regs_p = 0;
      error ("32-bit compatibility mode not supported");
d695 2
d699 40
a738 1
/* Convert to/from a register and the corresponding memory value.  */
d744 2
a745 2
	  && register_size (current_gdbarch, regnum) == 4
	  && (regnum) >= mips_regnum (current_gdbarch)->fp0 && (regnum) < mips_regnum (current_gdbarch)->fp0 + 32
d772 14
a785 22
  gdb_assert (regnum >= 0 && regnum < 2 * NUM_REGS);
  if ((regnum % NUM_REGS) >= mips_regnum (current_gdbarch)->fp0
      && (regnum % NUM_REGS) < mips_regnum (current_gdbarch)->fp0 + 32)
    {
      /* The floating-point registers raw, or cooked, always match
         mips_regsize(), and also map 1:1, byte for byte.  */
      switch (gdbarch_byte_order (gdbarch))
	{
	case BFD_ENDIAN_BIG:
	  if (mips_regsize (gdbarch) == 4)
	    return builtin_type_ieee_single_big;
	  else
	    return builtin_type_ieee_double_big;
	case BFD_ENDIAN_LITTLE:
	  if (mips_regsize (gdbarch) == 4)
	    return builtin_type_ieee_single_little;
	  else
	    return builtin_type_ieee_double_little;
	case BFD_ENDIAN_UNKNOWN:
	default:
	  internal_error (__FILE__, __LINE__, "bad switch");
	}
d787 4
a790 14
  else if (regnum >= (NUM_REGS + mips_regnum (current_gdbarch)->fp_control_status)
	   && regnum <= NUM_REGS + LAST_EMBED_REGNUM)
    /* The pseudo/cooked view of the embedded registers is always
       32-bit.  The raw view is handled below.  */
    return builtin_type_int32;
  else if (regnum >= NUM_REGS && mips_regsize (gdbarch)
	   && gdbarch_tdep (gdbarch)->mips64_transfers_32bit_regs_p)
    /* The target, while using a 64-bit register buffer, is only
       transfering 32-bits of each integer register.  Reflect this in
       the cooked/pseudo register value.  */
    return builtin_type_int32;
  else if (mips_regsize (gdbarch) == 8)
    /* 64-bit ISA.  */
    return builtin_type_int64;
d792 9
a800 2
    /* 32-bit ISA.  */
    return builtin_type_int32;
d863 6
d1112 1
a1112 1
	  int fcrcs = read_signed_register (mips_regnum (current_gdbarch)->fp_control_status);
d1572 1
a1572 1
#define SIGFRAME_BASE		mips_regsize (current_gdbarch)
d1574 2
a1575 2
#define SIGFRAME_PC_OFF		(SIGFRAME_BASE + 2 * mips_regsize (current_gdbarch))
#define SIGFRAME_REGSAVE_OFF	(SIGFRAME_BASE + 3 * mips_regsize (current_gdbarch))
d1577 5
a1581 1
        (SIGFRAME_REGSAVE_OFF + MIPS_NUMREGS * mips_regsize (current_gdbarch) + 3 * mips_regsize (current_gdbarch))
d1588 1
a1588 1
				    + ireg * mips_regsize (current_gdbarch));
d1595 2
a1596 2
				    + ireg * mips_regsize (current_gdbarch));
	  set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->fp0 + ireg, reg_position);
d1744 1
a1744 1
		set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->fp0 + ireg,
d1747 1
a1747 1
		set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->fp0 + ireg,
d1751 1
a1751 1
	    set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->fp0 + ireg, reg_position);
d1789 34
a1822 20
  if (mips_mask_address_p ()
      && (((ULONGEST) addr) >> 32 == 0xffffffffUL))
    /* This hack is a work-around for existing boards using PMON, the
       simulator, and any other 64-bit targets that doesn't have true
       64-bit addressing.  On these targets, the upper 32 bits of
       addresses are ignored by the hardware.  Thus, the PC or SP are
       likely to have been sign extended to all 1s by instruction
       sequences that load 32-bit addresses.  For example, a typical
       piece of code that loads an address is this:

       lui $r2, <upper 16 bits>
       ori $r2, <lower 16 bits>

       But the lui sign-extends the value such that the upper 32 bits
       may be all 1s.  The workaround is simply to mask off these
       bits.  In the future, gcc may be changed to support true 64-bit
       addressing, and this masking will have to be disabled.  */
    return addr &= 0xffffffffUL;
  else
    return addr;
d1874 1
d1876 2
a1877 1
      saved_pc = frame_unwind_register_signed (frame, NUM_REGS + PC_REGNUM);
d2265 1
a2265 1
	  set_reg_offset (temp_saved_regs, reg, sp + low_word + 8 - mips_regsize (current_gdbarch));
d2614 3
d2675 1
d2865 1
a2865 1
  float_argreg = mips_fpa0_regnum (current_gdbarch);
d2973 4
a2976 5
	  /* Note: structs whose size is not a multiple of
	     mips_regsize() are treated specially: Irix cc passes them
	     in registers where gcc sometimes puts them on the stack.
	     For maximum compatibility, we will put them in both
	     places.  */
d3125 1
a3125 1
  float_argreg = mips_fpa0_regnum (current_gdbarch);
d3180 4
a3183 5
	  /* Note: structs whose size is not a multiple of
	     mips_regsize() are treated specially: Irix cc passes them
	     in registers where gcc sometimes puts them on the stack.
	     For maximum compatibility, we will put them in both
	     places.  */
d3356 1
a3356 1
  float_argreg = mips_fpa0_regnum (current_gdbarch);
d3470 4
a3473 5
	  /* Note: structs whose size is not a multiple of
	     mips_regsize() are treated specially: Irix cc passes them
	     in registers where gcc sometimes puts them on the stack.
	     For maximum compatibility, we will put them in both
	     places.  */
d3549 2
a3550 2
		  /* Value may need to be sign extended, because
		     mips_regsize() != MIPS_SAVED_REGSIZE.  */
d3664 1
a3664 1
  float_argreg = mips_fpa0_regnum (current_gdbarch);
d3778 4
a3781 5
	  /* Note: structs whose size is not a multiple of
	     mips_regsize() are treated specially: Irix cc passes them
	     in registers where gcc sometimes puts them on the stack.
	     For maximum compatibility, we will put them in both
	     places.  */
d3857 2
a3858 2
		  /* Value may need to be sign extended, because
		     mips_regsize() != MIPS_SAVED_REGSIZE.  */
d3953 1
a3953 1
	if (mips_regnum (current_gdbarch)->fp0 <= regnum && regnum < mips_regnum (current_gdbarch)->fp0 + 32)
d3988 1
a3988 1
      write_register (mips_regnum (current_gdbarch)->hi,
d3991 1
a3991 1
      write_register (mips_regnum (current_gdbarch)->lo,
d3995 1
a3995 1
	write_register (mips_regnum (current_gdbarch)->fp_control_status,
d4056 1
a4056 1
  int raw_size = register_size (current_gdbarch, regno);
d4088 1
a4088 1
  int raw_size = register_size (current_gdbarch, regno);
d4099 1
a4099 1
      if ((regno - mips_regnum (current_gdbarch)->fp0) & 1)
d4127 1
a4127 1
  raw_buffer = (char *) alloca (2 * register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0));
d4133 1
a4133 1
  if (register_size (current_gdbarch, regnum) == 4 || mips2_fp_compat ())
d4220 1
a4220 1
    offset = register_size (current_gdbarch, regnum) - register_size (current_gdbarch, regnum);
d4251 1
a4251 1
  int ncols = (mips_regsize (gdbarch) == 8 ? 4 : 8);	/* display cols per row */
d4265 1
a4265 1
      fprintf_filtered (file, mips_regsize (current_gdbarch) == 8 ? "%17s" : "%9s",
d4288 1
a4288 4
      for (byte = 0;
	   byte < (mips_regsize (current_gdbarch)
		   - register_size (current_gdbarch, regnum));
	   byte++)
d4292 2
a4293 2
	for (byte = register_size (current_gdbarch, regnum) - register_size (current_gdbarch, regnum);
	     byte < register_size (current_gdbarch, regnum);
d4297 1
a4297 1
	for (byte = register_size (current_gdbarch, regnum) - 1;
a4377 55
/* Given PC at the function's start address, attempt to find the
   prologue end using SAL information.  Return zero if the skip fails.

   A non-optimized prologue traditionally has one SAL for the function
   and a second for the function body.  A single line function has
   them both pointing at the same line.

   An optimized prologue is similar but the prologue may contain
   instructions (SALs) from the instruction body.  Need to skip those
   while not getting into the function body.

   The functions end point and an increasing SAL line are used as
   indicators of the prologue's endpoint.

   This code is based on the function refine_prologue_limit (versions
   found in both ia64 and ppc).  */

static CORE_ADDR
skip_prologue_using_sal (CORE_ADDR func_addr)
{
  struct symtab_and_line prologue_sal;
  CORE_ADDR start_pc;
  CORE_ADDR end_pc;

  /* Get an initial range for the function.  */
  find_pc_partial_function (func_addr, NULL, &start_pc, &end_pc);
  start_pc += FUNCTION_START_OFFSET;

  prologue_sal = find_pc_line (start_pc, 0);
  if (prologue_sal.line != 0)
    {
      while (prologue_sal.end < end_pc)
	{
	  struct symtab_and_line sal;

	  sal = find_pc_line (prologue_sal.end, 0);
	  if (sal.line == 0)
	    break;
	  /* Assume that a consecutive SAL for the same (or larger)
             line mark the prologue -> body transition.  */
	  if (sal.line >= prologue_sal.line)
	    break;
	  /* The case in which compiler's optimizer/scheduler has
	     moved instructions into the prologue.  We look ahead in
	     the function looking for address ranges whose
	     corresponding line number is less the first one that we
	     found for the function.  This is more conservative then
	     refine_prologue_limit which scans a large number of SALs
	     looking for any in the prologue */
	  prologue_sal = sal;
	}
    }
  return prologue_sal.end;
}

a4388 5
  /* Find an upper bound on the prologue.  */
  end_pc = skip_prologue_using_sal (pc);
  if (end_pc == 0)
    end_pc = pc + 100; /* Magic.  */

d4392 1
a4392 1
  for (; pc < end_pc; pc += MIPS_INSTLEN)
a4533 5
  /* Find an upper bound on the prologue.  */
  end_pc = skip_prologue_using_sal (pc);
  if (end_pc == 0)
    end_pc = pc + 100; /* Magic.  */

d4537 1
a4537 1
  for (; pc < end_pc; pc += MIPS16_INSTLEN)
d4632 1
a4632 1
			     && register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0) == 8)
d4635 2
a4636 2
	  lo->reg = mips_regnum (current_gdbarch)->fp0 + 0;
	  hi->reg = mips_regnum (current_gdbarch)->fp0 + 1;
d4645 1
a4645 1
			     && register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0) == 8
d4648 1
a4648 1
	  lo->reg = mips_regnum (current_gdbarch)->fp0;
d4701 1
a4701 1
	  && register_size (current_gdbarch, regnum) == 8
d4727 1
a4727 1
	  regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + lo.reg) + lo.reg_offset,
d4732 1
a4732 1
	    regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + hi.reg) + hi.reg_offset,
d4746 1
a4746 1
	  regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + lo.reg) + lo.reg_offset,
d4751 1
a4751 1
	    regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + hi.reg) + hi.reg_offset,
d4769 1
a4769 1
				   register_size (current_gdbarch, lo.reg));
d4776 1
a4776 1
				       register_size (current_gdbarch, hi.reg));
d4791 1
a4791 1
				   register_size (current_gdbarch, lo.reg));
d4798 1
a4798 1
				       register_size (current_gdbarch, hi.reg));
d4804 4
a4807 4
static enum return_value_convention
mips_o32_return_value (struct gdbarch *gdbarch, struct type *type,
		       struct regcache *regcache,
		       void *readbuf, const void *writebuf)
d4810 3
a4812 8

  if (TYPE_CODE (type)== TYPE_CODE_STRUCT
      || TYPE_CODE (type)== TYPE_CODE_UNION
      || TYPE_CODE (type)== TYPE_CODE_ARRAY)
    return RETURN_VALUE_STRUCT_CONVENTION;
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && TYPE_LENGTH (type) == 4
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
d4818 2
a4819 5
      mips_xfer_register (regcache,
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
			  TYPE_LENGTH (type),
			  TARGET_BYTE_ORDER, readbuf, writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
d4833 4
a4836 6
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 0,
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 1,
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 4);
d4839 4
a4842 6
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 1,
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 + 0,
			      4, TARGET_BYTE_ORDER, readbuf, writebuf, 4);
a4846 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d4868 1
a4868 1
      for (field = 0, regnum = mips_regnum (current_gdbarch)->fp0;
d4878 1
a4878 1
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
a4879 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d4893 1
a4893 1
	   offset += register_size (current_gdbarch, regnum), regnum++)
d4895 1
a4895 1
	  int xfer = register_size (current_gdbarch, regnum);
d4902 1
a4902 1
			      BFD_ENDIAN_UNKNOWN, readbuf, writebuf, offset);
a4903 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d4925 1
a4925 1
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
a4926 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d4930 14
d4946 4
a4949 4
static enum return_value_convention
mips_n32n64_return_value (struct gdbarch *gdbarch,
			  struct type *type, struct regcache *regcache,
			  void *readbuf, const void *writebuf)
d4952 2
a4953 7
  if (TYPE_CODE (type)== TYPE_CODE_STRUCT
      || TYPE_CODE (type)== TYPE_CODE_UNION
      || TYPE_CODE (type)== TYPE_CODE_ARRAY
      || TYPE_LENGTH (type) > 2 * MIPS_SAVED_REGSIZE)
    return RETURN_VALUE_STRUCT_CONVENTION;
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
d4959 2
a4960 5
      mips_xfer_register (regcache,
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
			  TYPE_LENGTH (type),
			  TARGET_BYTE_ORDER, readbuf, writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
d4981 1
a4981 1
      for (field = 0, regnum = mips_regnum (current_gdbarch)->fp0;
d4991 1
a4991 1
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
a4992 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d5004 1
a5004 1
	   offset += register_size (current_gdbarch, regnum), regnum++)
d5006 1
a5006 1
	  int xfer = register_size (current_gdbarch, regnum);
d5013 1
a5013 1
			      BFD_ENDIAN_UNKNOWN, readbuf, writebuf, offset);
a5014 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d5024 1
a5024 1
	   offset += register_size (current_gdbarch, regnum), regnum++)
d5026 1
a5026 1
	  int xfer = register_size (current_gdbarch, regnum);
d5034 1
a5034 1
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
a5035 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d5039 14
d5157 56
d5214 1
a5214 4
   processor id.  NOTE: cagney/2003-11-15: Firstly it isn't clear that
   the relevant processor still exists (it dates back to '94) and
   secondly this is not the way to do this.  The processor type should
   be set by forcing an architecture change.  */
d5216 2
a5217 2
void
deprecated_mips_set_processor_regs_hack (void)
a5218 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d5224 3
a5226 1
    tdep->mips_processor_reg_names = mips_r3041_reg_names;
d5615 1
a5615 1
    regnum = num + mips_regnum (current_gdbarch)->fp0 - 38;
d5617 1
a5617 1
    regnum = mips_regnum (current_gdbarch)->hi;
d5619 1
a5619 1
    regnum = mips_regnum (current_gdbarch)->lo;
d5638 1
a5638 1
    regnum = num + mips_regnum (current_gdbarch)->fp0 - 32;
d5640 1
a5640 1
    regnum = mips_regnum (current_gdbarch)->hi;
d5642 1
a5642 1
    regnum = mips_regnum (current_gdbarch)->lo;
a5833 5
      /* Need to be pedantic about which register virtual size is
         used.  */
      if (gdbarch_tdep (arches->gdbarch)->mips64_transfers_32bit_regs_p
	  != mips64_transfers_32bit_regs_p)
	continue;
a5840 1
  tdep->mips64_transfers_32bit_regs_p = mips64_transfers_32bit_regs_p;
d5848 2
d5859 7
a5865 36
  /* Fill in the OS dependant register numbers.  */
  {
    struct mips_regnum *regnum = GDBARCH_OBSTACK_ZALLOC (gdbarch,
							 struct mips_regnum);
    tdep->regnum = regnum;
    if (info.osabi == GDB_OSABI_IRIX)
      {
	regnum->fp0 = 32;
	regnum->pc = 64;
	regnum->cause = 65;
	regnum->badvaddr = 66;
	regnum->hi = 67;
	regnum->lo = 68;
	regnum->fp_control_status = 69;
	regnum->fp_implementation_revision = 70;
	num_regs = 71;
      }
    else
      {
	regnum->lo = MIPS_EMBED_LO_REGNUM;
	regnum->hi = MIPS_EMBED_HI_REGNUM;
	regnum->badvaddr = MIPS_EMBED_BADVADDR_REGNUM;
	regnum->cause = MIPS_EMBED_CAUSE_REGNUM;
	regnum->pc = MIPS_EMBED_PC_REGNUM;
	regnum->fp0 = MIPS_EMBED_FP0_REGNUM;
	regnum->fp_control_status = 70;
	regnum->fp_implementation_revision = 71;
	num_regs = 90;
      }
    /* FIXME: cagney/2003-11-15: For MIPS, hasn't PC_REGNUM been
       replaced by read_pc?  */
    set_gdbarch_pc_regnum (gdbarch, regnum->pc);
    set_gdbarch_fp0_regnum (gdbarch, regnum->fp0);
    set_gdbarch_num_regs (gdbarch, num_regs);
    set_gdbarch_num_pseudo_regs (gdbarch, num_regs);
  }
d5871 2
a5872 1
      set_gdbarch_return_value (gdbarch, mips_o32_return_value);
d5877 2
a5878 1
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 4 - 1;
d5885 2
d5896 2
a5897 1
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 4 - 1;
d5914 2
a5915 1
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
d5933 2
a5934 1
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
d5946 2
a5947 1
      set_gdbarch_return_value (gdbarch, mips_n32n64_return_value);
d5952 2
a5953 1
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
d5958 2
d5965 2
a5966 1
      set_gdbarch_return_value (gdbarch, mips_n32n64_return_value);
d5971 2
a5972 1
      tdep->mips_last_fp_arg_regnum = tdep->regnum->fp0 + 12 + 8 - 1;
d5977 2
d6030 4
a6033 1
  /* MIPS version of register names.  */
a6034 6
  if (info.osabi == GDB_OSABI_IRIX)
    tdep->mips_processor_reg_names = mips_irix_reg_names;
  else if (info.bfd_arch_info != NULL && info.bfd_arch_info->mach == bfd_mach_mips3900)
    tdep->mips_processor_reg_names = mips_tx39_reg_names;
  else
    tdep->mips_processor_reg_names = mips_generic_reg_names;
d6068 3
d6227 4
d6250 3
d6262 6
d6274 6
d6283 9
d6303 3
d6339 2
d6344 4
d6413 3
d6617 5
a6621 7
  add_setshow_cmd ("remote-mips64-transfers-32bit-regs", class_obscure,
		   var_boolean, &mips64_transfers_32bit_regs_p, "\
Set compatibility with 64-bit MIPS targets that transfer 32-bit quantities.\n\
Use \"on\" to enable backward compatibility with older MIPS 64 GDB+target\n\
that would transfer 32 bits for some registers (e.g. SR, FSR) and\n\
64 bits for others.  Use \"off\" to disable compatibility mode",  "\
Show compatibility with 64-bit MIPS targets that transfer 32-bit quantities.\n\
d6625 2
a6626 2
		   set_mips64_transfers_32bit_regs, NULL,
		   &setlist, &showlist);
@


1.126.2.16
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d4 1
a4 2
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d83 4
a86 4
{
  mips_extra_func_info_t proc_desc;
  int num_args;
};
d108 5
a112 5
{
  MIPS_FPU_DOUBLE,		/* Full double precision floating point.  */
  MIPS_FPU_SINGLE,		/* Single precision floating point (R4650).  */
  MIPS_FPU_NONE			/* No floating point.  */
};
d124 3
a126 3
{
  /* from the elf header */
  int elf_flags;
d128 20
a147 20
  /* mips options */
  enum mips_abi mips_abi;
  enum mips_abi found_abi;
  enum mips_fpu_type mips_fpu_type;
  int mips_last_arg_regnum;
  int mips_last_fp_arg_regnum;
  int mips_default_saved_regsize;
  int mips_fp_register_double;
  int mips_default_stack_argsize;
  int default_mask_address_p;
  /* Is the target using 64-bit raw integer registers but only
     storing a left-aligned 32-bit value in each?  */
  int mips64_transfers_32bit_regs_p;
  /* Indexes for various registers.  IRIX and embedded have
     different values.  This contains the "public" fields.  Don't
     add any that do not need to be public.  */
  const struct mips_regnum *regnum;
  /* Register names table for the current register set.  */
  const char **mips_processor_reg_names;
};
d170 8
d206 1
a206 2
  return (extract_signed_integer
	  (buf, register_size (current_gdbarch, regnum)));
a242 4
/* Return the currently configured (or set) saved register size. */

static const char *mips_saved_regsize_string = size_auto;

d244 1
a244 1
mips_saved_regsize (struct gdbarch_tdep *tdep)
d247 1
a247 1
    return tdep->mips_default_saved_regsize;
d250 1
a250 1
  else				/* if (mips_saved_regsize_string == size_32) */
d265 1
a265 1
mips_elf_make_msymbol_special (asymbol * sym, struct minimal_symbol *msym)
d267 6
a272 6
  if (((elf_symbol_type *) (sym))->internal_elf_sym.st_other == STO_MIPS16)
    {
      MSYMBOL_INFO (msym) = (char *)
	(((long) MSYMBOL_INFO (msym)) | 0x80000000);
      SYMBOL_VALUE_ADDRESS (msym) |= 1;
    }
d288 2
a289 2
		    enum bfd_endian endian, bfd_byte * in,
		    const bfd_byte * out, int buf_offset)
d304 1
a304 1
    case BFD_ENDIAN_UNKNOWN:	/* Indicates no alignment.  */
d322 1
a322 2
    regcache_cooked_read_part (regcache, reg_num, reg_offset, length,
			       in + buf_offset);
d324 1
a324 2
    regcache_cooked_write_part (regcache, reg_num, reg_offset, length,
				out + buf_offset);
d345 1
a345 2
  if (register_size (current_gdbarch, mips_regnum (current_gdbarch)->fp0) ==
      4)
d370 4
d377 1
a377 1
mips_stack_argsize (struct gdbarch_tdep *tdep)
d380 1
a380 1
    return tdep->mips_default_stack_argsize;
d383 1
a383 1
  else				/* if (mips_stack_argsize_string == size_32) */
d387 2
d419 1
a419 2
enum
{ NUM_MIPS_PROCESSOR_REGS = (90 - 32) };
d424 8
a431 8
  "sr", "lo", "hi", "bad", "cause", "pc",
  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
  "fsr", "fir", "" /*"fp" */ , "",
  "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "",
d437 8
a444 8
  "sr", "lo", "hi", "bad", "cause", "pc",
  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
  "fsr", "fir", "", /*"fp" */ "",
  "", "", "bus", "ccfg", "", "", "", "",
  "", "", "port", "cmp", "", "", "epc", "prid",
d450 8
a457 8
  "sr", "lo", "hi", "bad", "cause", "pc",
  "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "",
  "", "", "", "",
  "", "", "", "", "", "", "", "",
  "", "", "config", "cache", "debug", "depc", "epc", ""
d462 5
a466 5
  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
  "pc", "cause", "bad", "hi", "lo", "fsr", "fir"
d477 4
a480 4
    "zero", "at", "v0", "v1", "a0", "a1", "a2", "a3",
    "t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7",
    "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
    "t8", "t9", "k0", "k1", "gp", "sp", "s8", "ra",
d485 4
a488 4
    "zero", "at", "v0", "v1", "a0", "a1", "a2", "a3",
    "a4", "a5", "a6", "a7", "t0", "t1", "t2", "t3",
    "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
    "t8", "t9", "k0", "k1", "gp", "sp", "s8", "ra"
d537 2
a538 1
  if (REGISTER_NAME (regnum) == NULL || REGISTER_NAME (regnum)[0] == '\0')
d554 1
a554 1
  return 0;
d568 2
a569 3
    regcache_raw_read (regcache, rawnum, buf);
  else if (register_size (gdbarch, rawnum) >
	   register_size (gdbarch, cookednum))
d582 2
a583 3
mips_pseudo_register_write (struct gdbarch *gdbarch,
			    struct regcache *regcache, int cookednum,
			    const void *buf)
d588 2
a589 3
    regcache_raw_write (regcache, rawnum, buf);
  else if (register_size (gdbarch, rawnum) >
	   register_size (gdbarch, cookednum))
d602 2
a603 1
static int mips16_to_32_reg[8] = { 16, 17, 2, 3, 4, 5, 6, 7 };
d629 4
a632 4
{
  struct mips_extra_func_info info;
  struct linked_proc_info *next;
}
d664 3
a666 3
	  && (regnum % NUM_REGS) >= mips_regnum (current_gdbarch)->fp0
	  && (regnum % NUM_REGS) < mips_regnum (current_gdbarch)->fp0 + 32
	  && TYPE_CODE (type) == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8);
d714 1
a714 2
  else if (regnum >=
	   (NUM_REGS + mips_regnum (current_gdbarch)->fp_control_status)
d745 1
a745 1
mips_mask_address_p (struct gdbarch_tdep *tdep)
d755 1
a755 1
      return tdep->default_mask_address_p;
d757 2
a758 1
      internal_error (__FILE__, __LINE__, "mips_mask_address_p: bad switch");
a765 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d775 2
a776 3
      printf_filtered
	("The 32 bit address mask is set automatically.  Currently %s\n",
	 mips_mask_address_p (tdep) ? "enabled" : "disabled");
d779 2
a780 1
      internal_error (__FILE__, __LINE__, "show_mask_address: bad switch");
d785 36
d848 1
a848 7
  return read_signed_register_pid (mips_regnum (current_gdbarch)->pc, ptid);
}

static void
mips_write_pc (CORE_ADDR pc, ptid_t ptid)
{
  write_register_pid (mips_regnum (current_gdbarch)->pc, pc, ptid);
d855 2
a856 1
after_prologue (CORE_ADDR pc, mips_extra_func_info_t proc_desc)
d903 1
a903 1
  if ((inst & 0xffe00000) == 0xafa00000	/* sw reg,n($sp) */
d916 1
a916 1
	   || (inst & 0xffe00000) == 0xe7c00000	/* swc1 freg,n($r30) */
d1014 1
a1014 1
	/* BEQL, BNEL, BLEZL, BGTZL: bits 0101xx */
d1032 1
a1032 1
	/* BC1F, BC1FL, BC1T, BC1TL: 010001 01000 */
d1036 1
a1036 3
	  int fcrcs =
	    read_signed_register (mips_regnum (current_gdbarch)->
				  fp_control_status);
d1066 1
a1066 1
	  break;		/* end SPECIAL */
d1086 1
d1097 1
a1097 1
	  break;		/* end REGIMM */
d1132 1
d1190 5
a1194 5
{
  CORE_ADDR offset;
  unsigned int regx;		/* Function in i8 type */
  unsigned int regy;
};
d1234 2
a1235 1
	       enum mips16_inst_fmts insn_format, struct upk_mips16 *upk)
d1249 1
a1249 1
	    value |= inst & 0x7ff;	/* eleven bits from instruction */
d1308 2
a1309 1
      internal_error (__FILE__, __LINE__, "bad switch");
d1325 2
a1326 1
			 unsigned int extension, unsigned int insn)
d1331 1
a1331 1
    case 2:			/* Branch */
d1345 1
a1345 1
    case 3:			/* JAL , JALX - Watch out, these are 32 bit instruction */
d1356 1
a1356 1
    case 4:			/* beqz */
d1368 1
a1368 1
    case 5:			/* bnez */
d1380 1
a1380 1
    case 12:			/* I8 Formats btez btnez */
d1395 1
a1395 1
    case 29:			/* RR Formats JR, JALR, JALR-RA */
d1412 1
a1412 1
		break;		/* Function return instruction */
d1418 1
a1418 1
		break;		/* BOGUS Guess */
a1483 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1507 2
a1508 3
	  CORE_ADDR reg_position =
	    (get_frame_base (fci) + SIGFRAME_REGSAVE_OFF +
	     ireg * mips_regsize (current_gdbarch));
d1516 1
a1516 3
	  set_reg_offset (saved_regs,
			  mips_regnum (current_gdbarch)->fp0 + ireg,
			  reg_position);
d1519 1
a1519 2
      set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->pc,
		      get_frame_base (fci) + SIGFRAME_PC_OFF);
d1536 4
a1539 4
  if (				/* In any frame other than the innermost or a frame interrupted
				   by a signal, we assume that all registers have been saved.
				   This assumes that all register saves in a function happen
				   before the first function call.  */
d1542 1
d1545 1
d1547 2
a1548 1
          Outside the prologue, we know where everything is. */
d1550 1
d1552 3
a1554 3
          kernel saves the registers without a prologue doing it, we
          better not examine the prologue to see whether registers
          have been saved yet.  */
d1595 1
a1595 1
	  reg_position -= mips_saved_regsize (tdep);
d1616 1
a1616 1
	    reg_position -= mips_saved_regsize (tdep);
d1619 1
a1619 1
	     stack.  */
d1623 1
a1623 1
	      reg_position -= mips_saved_regsize (tdep);
d1639 1
a1639 2
	  if (mips_saved_regsize (tdep) == 4
	      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1642 5
a1646 5
	         are paired to form doubles such that the most
	         significant part is in $f[N+1] and the least
	         significant in $f[N] vis: $f[N+1] ||| $f[N].  The
	         registers are also spilled as a pair and stored as a
	         double.
d1652 11
a1662 11
	         Unfortunately, when big-endian the most significant
	         part of the double is stored first, and the least
	         significant is stored second.  This leads to the
	         registers being ordered in memory as firt $f[N+1] and
	         then $f[N].

	         For the big-endian case make certain that the
	         addresses point at the correct (swapped) locations
	         $f[N] and $f[N+1] pair (keep in mind that
	         reg_position is decremented each time through the
	         loop).  */
d1664 2
a1665 3
		set_reg_offset (saved_regs,
				mips_regnum (current_gdbarch)->fp0 + ireg,
				reg_position - mips_saved_regsize (tdep));
d1667 2
a1668 3
		set_reg_offset (saved_regs,
				mips_regnum (current_gdbarch)->fp0 + ireg,
				reg_position + mips_saved_regsize (tdep));
d1671 2
a1672 4
	    set_reg_offset (saved_regs,
			    mips_regnum (current_gdbarch)->fp0 + ireg,
			    reg_position);
	  reg_position -= mips_saved_regsize (tdep);
d1675 1
a1675 2
    set_reg_offset (saved_regs, mips_regnum (current_gdbarch)->pc,
		    saved_regs[RA_REGNUM]);
d1709 2
a1710 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  if (mips_mask_address_p (tdep) && (((ULONGEST) addr) >> 32 == 0xffffffffUL))
d1749 1
a1749 1
      pc = read_register (mips_regnum (current_gdbarch)->pc);
d1766 2
a1767 1
	? DEPRECATED_FRAME_SAVED_PC (get_next_frame (prev)) : read_pc ());
a1776 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1781 1
a1781 1
      saved_pc = frame_unwind_register_signed (frame, NUM_REGS + mips_regnum (current_gdbarch)->pc);
d1788 1
a1788 3
	saved_pc = read_memory_integer ((get_frame_base (frame)
					 - mips_saved_regsize (tdep)),
					mips_saved_regsize (tdep));
d1793 1
a1793 2
	  int pcreg = (get_frame_type (frame) == SIGTRAMP_FRAME
		       ? mips_regnum (current_gdbarch)->pc
d1869 2
a1870 1
  if (heuristic_fence_post == UINT_MAX || fence < VM_MIN_ADDRESS)
d1887 2
a1888 3
	    warning
	      ("Warning: GDB can't find the start of the function at 0x%s.",
	       paddr_nz (pc));
d1908 2
a1909 1
heuristic-fence-post' command.\n", paddr_nz (pc), paddr_nz (pc));
d1955 3
a1957 3
		int nbits,	/* number of bits in imm field */
		int scale,	/* scale factor to be applied to imm */
		int is_signed)	/* is the imm field signed? */
a1994 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d2008 1
a2008 1
	  || (inst & 0xff00) == 0xfb00)	/* daddiu sp */
d2100 1
a2100 1
	  offset += mips_saved_regsize (tdep);
d2109 1
a2109 1
	  offset -= mips_saved_regsize (tdep);
d2117 1
a2117 1
	  offset -= mips_saved_regsize (tdep);
d2169 1
a2169 2
	  set_reg_offset (temp_saved_regs, reg,
			  sp + low_word + 8 - mips_regsize (current_gdbarch));
d2302 1
a2302 1
         the information normally found in ECOFF PDRs.  */
d2314 1
a2314 1
	  priv = obstack_alloc (&sec->objfile->psymbol_obstack,
d2323 1
a2323 1
	  priv = obstack_alloc (&sec->objfile->psymbol_obstack,
d2330 1
a2330 1
	      priv->contents = obstack_alloc (&sec->objfile->psymbol_obstack,
d2336 4
a2339 5
	         presence of multiple code sections (and other corner cases)
	         it can become unsorted.  Sort it so that we can use a faster
	         binary search.  */
	      qsort (priv->contents, priv->size / 32, 32,
		     compare_pdr_entries);
d2416 2
a2417 2
         print_frame_info.  It might be better to move this check into
         symbol reading.  */
d2463 2
a2464 1
				  (SYMBOL_BLOCK_VALUE (proc_symbol)), 0);
d2494 2
a2495 1
      proc_desc = heuristic_proc_desc (startaddr, pc, next_frame, cur_frame);
d2501 2
a2502 1
get_frame_pointer (struct frame_info *frame, mips_extra_func_info_t proc_desc)
d2505 2
a2506 1
	  + PROC_FRAME_OFFSET (proc_desc) - PROC_FRAME_ADJUST (proc_desc));
d2544 1
a2544 1
         and have frame size zero.  */
d2571 1
a2571 1
		      NULL /* i.e, get_next_frame (fci) */ ,
d2586 1
a2586 5
	deprecated_update_frame_base_hack (fci,
					   read_next_frame_reg (get_next_frame
								(fci),
								NUM_REGS +
								SP_REGNUM));
d2589 6
a2594 6
	   generic dummy frame's top-of-stack (since the draft
	   fci->frame is obtained by returning the unwound stack
	   pointer) and that is what we want.  That way the fci->frame
	   value will match the top-of-stack value that was saved as
	   part of the dummy frames data.  */
	/* Do nothing.  */ ;
d2596 1
a2596 4
	deprecated_update_frame_base_hack (fci,
					   get_frame_pointer (get_next_frame
							      (fci),
							      proc_desc));
d2607 2
a2608 2
	     frame.c:get_prev_frame() is modified to set the frame's
	     type before calling functions like this.  */
d2622 1
a2622 1
	      set_reg_offset (temp_saved_regs, mips_regnum (current_gdbarch)->pc,
d2678 1
a2678 2
	       && (typecode == TYPE_CODE_STRUCT
		   || typecode == TYPE_CODE_UNION)
a2720 139
/* Determine how a return value is stored within the MIPS register
   file, given the return type `valtype'. */

struct return_value_word
{
  int len;
  int reg;
  int reg_offset;
  int buf_offset;
};

static void
return_value_location (struct type *valtype,
		       struct return_value_word *hi,
		       struct return_value_word *lo)
{
  int len = TYPE_LENGTH (valtype);
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (TYPE_CODE (valtype) == TYPE_CODE_FLT
      && ((MIPS_FPU_TYPE == MIPS_FPU_DOUBLE && (len == 4 || len == 8))
	  || (MIPS_FPU_TYPE == MIPS_FPU_SINGLE && len == 4)))
    {
      if (!FP_REGISTER_DOUBLE && len == 8)
	{
	  /* We need to break a 64bit float in two 32 bit halves and
	     spread them across a floating-point register pair. */
	  lo->buf_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 4 : 0;
	  hi->buf_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 0 : 4;
	  lo->reg_offset = ((TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
			     && register_size (current_gdbarch,
					       mips_regnum (current_gdbarch)->
					       fp0) == 8) ? 4 : 0);
	  hi->reg_offset = lo->reg_offset;
	  lo->reg = mips_regnum (current_gdbarch)->fp0 + 0;
	  hi->reg = mips_regnum (current_gdbarch)->fp0 + 1;
	  lo->len = 4;
	  hi->len = 4;
	}
      else
	{
	  /* The floating point value fits in a single floating-point
	     register. */
	  lo->reg_offset = ((TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
			     && register_size (current_gdbarch,
					       mips_regnum (current_gdbarch)->
					       fp0) == 8
			     && len == 4) ? 4 : 0);
	  lo->reg = mips_regnum (current_gdbarch)->fp0;
	  lo->len = len;
	  lo->buf_offset = 0;
	  hi->len = 0;
	  hi->reg_offset = 0;
	  hi->buf_offset = 0;
	  hi->reg = 0;
	}
    }
  else
    {
      /* Locate a result possibly spread across two registers. */
      int regnum = 2;
      lo->reg = regnum + 0;
      hi->reg = regnum + 1;
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && len < mips_saved_regsize (tdep))
	{
	  /* "un-left-justify" the value in the low register */
	  lo->reg_offset = mips_saved_regsize (tdep) - len;
	  lo->len = len;
	  hi->reg_offset = 0;
	  hi->len = 0;
	}
      else if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG && len > mips_saved_regsize (tdep)	/* odd-size structs */
	       && len < mips_saved_regsize (tdep) * 2
	       && (TYPE_CODE (valtype) == TYPE_CODE_STRUCT ||
		   TYPE_CODE (valtype) == TYPE_CODE_UNION))
	{
	  /* "un-left-justify" the value spread across two registers. */
	  lo->reg_offset = 2 * mips_saved_regsize (tdep) - len;
	  lo->len = mips_saved_regsize (tdep) - lo->reg_offset;
	  hi->reg_offset = 0;
	  hi->len = len - lo->len;
	}
      else
	{
	  /* Only perform a partial copy of the second register. */
	  lo->reg_offset = 0;
	  hi->reg_offset = 0;
	  if (len > mips_saved_regsize (tdep))
	    {
	      lo->len = mips_saved_regsize (tdep);
	      hi->len = len - mips_saved_regsize (tdep);
	    }
	  else
	    {
	      lo->len = len;
	      hi->len = 0;
	    }
	}
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	  && register_size (current_gdbarch, regnum) == 8
	  && mips_saved_regsize (tdep) == 4)
	{
	  /* Account for the fact that only the least-signficant part
	     of the register is being used */
	  lo->reg_offset += 4;
	  hi->reg_offset += 4;
	}
      lo->buf_offset = 0;
      hi->buf_offset = lo->len;
    }
}

/* Should call_function allocate stack space for a struct return?  */

static int
mips_eabi_use_struct_convention (int gcc_p, struct type *type)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  return (TYPE_LENGTH (type) > 2 * mips_saved_regsize (tdep));
}

/* Should call_function pass struct by reference? 
   For each architecture, structs are passed either by
   value or by reference, depending on their size.  */

static int
mips_eabi_reg_struct_has_addr (int gcc_p, struct type *type)
{
  enum type_code typecode = TYPE_CODE (check_typedef (type));
  int len = TYPE_LENGTH (check_typedef (type));
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION)
    return (len > mips_saved_regsize (tdep));

  return 0;
}

d2723 3
a2725 3
			   struct regcache *regcache, CORE_ADDR bp_addr,
			   int nargs, struct value **args, CORE_ADDR sp,
			   int struct_return, CORE_ADDR struct_addr)
a2731 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d2754 2
a2755 2
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])),
		     mips_stack_argsize (tdep));
d2759 1
a2759 1
    fprintf_unfiltered (gdb_stdlog,
d2796 1
a2796 1
      if (len > mips_saved_regsize (tdep)
d2799 1
a2799 2
	  store_unsigned_integer (valbuf, mips_saved_regsize (tdep),
				  VALUE_ADDRESS (arg));
d2801 1
a2801 1
	  len = mips_saved_regsize (tdep);
d2814 2
a2815 1
      if (!FP_REGISTER_DOUBLE && fp_register_arg_p (typecode, arg_type))
d2860 1
a2860 1
	         above to ensure that it is even register aligned.  */
d2878 2
a2879 2
	  int odd_sized_struct = ((len > mips_saved_regsize (tdep))
				  && (len % mips_saved_regsize (tdep) != 0));
d2882 1
a2882 1
	     register are only written to memory.  */
d2887 2
a2888 2
	      int partial_len = (len < mips_saved_regsize (tdep)
				 ? len : mips_saved_regsize (tdep));
d2906 9
a2914 10
		      if (mips_stack_argsize (tdep) == 8
			  && (typecode == TYPE_CODE_INT
			      || typecode == TYPE_CODE_PTR
			      || typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = mips_stack_argsize (tdep) - len;
		      else if ((typecode == TYPE_CODE_STRUCT
				|| typecode == TYPE_CODE_UNION)
			       && (TYPE_LENGTH (arg_type)
				   < mips_stack_argsize (tdep)))
			longword_offset = mips_stack_argsize (tdep) - len;
d2930 1
a2930 1
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ",
d2934 1
a2934 1
			  fprintf_unfiltered (gdb_stdlog, "%02x",
d2945 1
a2945 1
	         purpose register.  */
d2949 1
a2949 2
		  LONGEST regval =
		    extract_unsigned_integer (val, partial_len);
d2954 1
a2954 2
				      phex (regval,
					    mips_saved_regsize (tdep)));
d2963 1
a2963 1
	         will copy the next parameter.
d2969 1
a2969 2
		stack_offset += align_up (partial_len,
					  mips_stack_argsize (tdep));
d2982 1
a2982 50
/* Given a return value in `regbuf' with a type `valtype', extract and
   copy its value into `valbuf'. */

static void
mips_eabi_extract_return_value (struct type *valtype,
				char regbuf[], char *valbuf)
{
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memcpy (valbuf + lo.buf_offset,
	  regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + lo.reg) +
	  lo.reg_offset, lo.len);

  if (hi.len > 0)
    memcpy (valbuf + hi.buf_offset,
	    regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + hi.reg) +
	    hi.reg_offset, hi.len);
}

/* Given a return value in `valbuf' with a type `valtype', write it's
   value into the appropriate register. */

static void
mips_eabi_store_return_value (struct type *valtype, char *valbuf)
{
  char raw_buffer[MAX_REGISTER_SIZE];
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memset (raw_buffer, 0, sizeof (raw_buffer));
  memcpy (raw_buffer + lo.reg_offset, valbuf + lo.buf_offset, lo.len);
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (lo.reg),
				   raw_buffer, register_size (current_gdbarch,
							      lo.reg));

  if (hi.len > 0)
    {
      memset (raw_buffer, 0, sizeof (raw_buffer));
      memcpy (raw_buffer + hi.reg_offset, valbuf + hi.buf_offset, hi.len);
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (hi.reg),
				       raw_buffer,
				       register_size (current_gdbarch,
						      hi.reg));
    }
}

/* N32/N64 ABI stuff.  */
d2986 3
a2988 3
			     struct regcache *regcache, CORE_ADDR bp_addr,
			     int nargs, struct value **args, CORE_ADDR sp,
			     int struct_return, CORE_ADDR struct_addr)
a2994 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d3015 2
a3016 2
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])),
		     mips_stack_argsize (tdep));
d3020 1
a3020 1
    fprintf_unfiltered (gdb_stdlog,
d3086 2
a3087 2
	  int odd_sized_struct = ((len > mips_saved_regsize (tdep))
				  && (len % mips_saved_regsize (tdep) != 0));
d3089 1
a3089 1
	     register are only written to memory.  */
d3094 2
a3095 2
	      int partial_len = (len < mips_saved_regsize (tdep)
				 ? len : mips_saved_regsize (tdep));
d3113 5
a3117 5
		      if (mips_stack_argsize (tdep) == 8
			  && (typecode == TYPE_CODE_INT
			      || typecode == TYPE_CODE_PTR
			      || typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = mips_stack_argsize (tdep) - len;
d3133 1
a3133 1
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ",
d3137 1
a3137 1
			  fprintf_unfiltered (gdb_stdlog, "%02x",
d3148 1
a3148 1
	         purpose register.  */
d3152 1
a3152 2
		  LONGEST regval =
		    extract_unsigned_integer (val, partial_len);
d3165 1
a3165 1
		     mips_saved_regsize(), generates a left shift as
d3168 7
a3174 8
		     sizeof (struct) >= mips_saved_regsize()).  Since
		     it is quite possible that this is GCC
		     contradicting the LE/O32 ABI, GDB has not been
		     adjusted to accommodate this.  Either someone
		     needs to demonstrate that the LE/O32 ABI
		     specifies such a left shift OR this new ABI gets
		     identified as such and GDB gets tweaked
		     accordingly.  */
d3177 1
a3177 1
		      && partial_len < mips_saved_regsize (tdep)
d3180 1
a3180 1
		    regval <<= ((mips_saved_regsize (tdep) - partial_len) *
d3186 1
a3186 2
				      phex (regval,
					    mips_saved_regsize (tdep)));
d3195 1
a3195 1
	         will copy the next parameter.
d3201 1
a3201 2
		stack_offset += align_up (partial_len,
					  mips_stack_argsize (tdep));
d3214 7
a3220 4
static enum return_value_convention
mips_n32n64_return_value (struct gdbarch *gdbarch,
			  struct type *type, struct regcache *regcache,
			  void *readbuf, const void *writebuf)
d3222 7
a3228 115
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      || TYPE_CODE (type) == TYPE_CODE_UNION
      || TYPE_CODE (type) == TYPE_CODE_ARRAY
      || TYPE_LENGTH (type) > 2 * mips_saved_regsize (tdep))
    return RETURN_VALUE_STRUCT_CONVENTION;
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A floating-point value belongs in the least significant part
         of FP0.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $fp0\n");
      mips_xfer_register (regcache,
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
			  TYPE_LENGTH (type),
			  TARGET_BYTE_ORDER, readbuf, writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   && TYPE_NFIELDS (type) <= 2
	   && TYPE_NFIELDS (type) >= 1
	   && ((TYPE_NFIELDS (type) == 1
		&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		    == TYPE_CODE_FLT))
	       || (TYPE_NFIELDS (type) == 2
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		       == TYPE_CODE_FLT)
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 1))
		       == TYPE_CODE_FLT)))
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A struct that contains one or two floats.  Each value is part
         in the least significant part of their floating point
         register..  */
      bfd_byte reg[MAX_REGISTER_SIZE];
      int regnum;
      int field;
      for (field = 0, regnum = mips_regnum (current_gdbarch)->fp0;
	   field < TYPE_NFIELDS (type); field++, regnum += 2)
	{
	  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])
			/ TARGET_CHAR_BIT);
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return float struct+%d\n",
				offset);
	  mips_xfer_register (regcache, NUM_REGS + regnum,
			      TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (type) == TYPE_CODE_UNION)
    {
      /* A structure or union.  Extract the left justified value,
         regardless of the byte order.  I.e. DO NOT USE
         mips_xfer_lower.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += register_size (current_gdbarch, regnum), regnum++)
	{
	  int xfer = register_size (current_gdbarch, regnum);
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return struct+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      BFD_ENDIAN_UNKNOWN, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else
    {
      /* A scalar extract each part but least-significant-byte
         justified.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += register_size (current_gdbarch, regnum), regnum++)
	{
	  int xfer = register_size (current_gdbarch, regnum);
	  int pos = 0;
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return scalar+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
}

/* O32 ABI stuff.  */

static CORE_ADDR
mips_o32_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			  struct regcache *regcache, CORE_ADDR bp_addr,
			  int nargs, struct value **args, CORE_ADDR sp,
			  int struct_return, CORE_ADDR struct_addr)
{
  int argreg;
  int float_argreg;
  int argnum;
  int len = 0;
  int stack_offset = 0;
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* For shared libraries, "t9" needs to point at the function
d3247 2
a3248 2
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])),
		     mips_stack_argsize (tdep));
d3252 1
a3252 1
    fprintf_unfiltered (gdb_stdlog,
d3268 1
a3268 1
      stack_offset += mips_stack_argsize (tdep);
d3295 2
a3296 1
      if (!FP_REGISTER_DOUBLE && fp_register_arg_p (typecode, arg_type))
d3348 1
a3348 1
	         above to ensure that it is even register aligned.  */
d3355 3
a3357 3
	         registers for each argument.  The below is (my
	         guess) to ensure that the corresponding integer
	         register has reserved the same space.  */
d3365 1
a3365 1
	  stack_offset += align_up (len, mips_stack_argsize (tdep));
d3377 2
a3378 2
	  int odd_sized_struct = ((len > mips_saved_regsize (tdep))
				  && (len % mips_saved_regsize (tdep) != 0));
d3381 1
a3381 1
	  if (mips_saved_regsize (tdep) < 8
d3385 1
a3385 1
		argreg++;
d3388 1
a3388 1
	     register are only written to memory.  */
d3393 2
a3394 2
	      int partial_len = (len < mips_saved_regsize (tdep)
				 ? len : mips_saved_regsize (tdep));
d3412 5
a3416 5
		      if (mips_stack_argsize (tdep) == 8
			  && (typecode == TYPE_CODE_INT
			      || typecode == TYPE_CODE_PTR
			      || typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = mips_stack_argsize (tdep) - len;
d3432 1
a3432 1
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ",
d3436 1
a3436 1
			  fprintf_unfiltered (gdb_stdlog, "%02x",
d3447 1
a3447 1
	         purpose register.  */
d3453 1
a3453 1
		     mips_regsize() != mips_saved_regsize().  */
d3468 1
a3468 1
		     mips_saved_regsize(), generates a left shift as
d3471 7
a3477 8
		     sizeof (struct) >= mips_saved_regsize()).  Since
		     it is quite possible that this is GCC
		     contradicting the LE/O32 ABI, GDB has not been
		     adjusted to accommodate this.  Either someone
		     needs to demonstrate that the LE/O32 ABI
		     specifies such a left shift OR this new ABI gets
		     identified as such and GDB gets tweaked
		     accordingly.  */
d3479 1
a3479 1
		  if (mips_saved_regsize (tdep) < 8
d3481 1
a3481 1
		      && partial_len < mips_saved_regsize (tdep)
d3484 1
a3484 1
		    regval <<= ((mips_saved_regsize (tdep) - partial_len) *
d3490 1
a3490 2
				      phex (regval,
					    mips_saved_regsize (tdep)));
d3503 1
a3503 1
	         will copy the next parameter.
d3505 4
a3508 4
	         In older ABIs, the caller reserved space for
	         registers that contained arguments.  This was loosely
	         refered to as their "home".  Consequently, space is
	         always allocated.  */
d3510 1
a3510 2
	      stack_offset += align_up (partial_len,
					mips_stack_argsize (tdep));
d3523 1
a3523 142
static enum return_value_convention
mips_o32_return_value (struct gdbarch *gdbarch, struct type *type,
		       struct regcache *regcache,
		       void *readbuf, const void *writebuf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      || TYPE_CODE (type) == TYPE_CODE_UNION
      || TYPE_CODE (type) == TYPE_CODE_ARRAY)
    return RETURN_VALUE_STRUCT_CONVENTION;
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && TYPE_LENGTH (type) == 4 && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A single-precision floating-point value.  It fits in the
         least significant part of FP0.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $fp0\n");
      mips_xfer_register (regcache,
			  NUM_REGS + mips_regnum (current_gdbarch)->fp0,
			  TYPE_LENGTH (type),
			  TARGET_BYTE_ORDER, readbuf, writebuf, 0);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && TYPE_LENGTH (type) == 8 && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A double-precision floating-point value.  The most
         significant part goes in FP1, and the least significant in
         FP0.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $fp1/$fp0\n");
      switch (TARGET_BYTE_ORDER)
	{
	case BFD_ENDIAN_LITTLE:
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 +
			      0, 4, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 +
			      1, 4, TARGET_BYTE_ORDER, readbuf, writebuf, 4);
	  break;
	case BFD_ENDIAN_BIG:
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 +
			      1, 4, TARGET_BYTE_ORDER, readbuf, writebuf, 0);
	  mips_xfer_register (regcache,
			      NUM_REGS + mips_regnum (current_gdbarch)->fp0 +
			      0, 4, TARGET_BYTE_ORDER, readbuf, writebuf, 4);
	  break;
	default:
	  internal_error (__FILE__, __LINE__, "bad switch");
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
#if 0
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   && TYPE_NFIELDS (type) <= 2
	   && TYPE_NFIELDS (type) >= 1
	   && ((TYPE_NFIELDS (type) == 1
		&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		    == TYPE_CODE_FLT))
	       || (TYPE_NFIELDS (type) == 2
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		       == TYPE_CODE_FLT)
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 1))
		       == TYPE_CODE_FLT)))
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A struct that contains one or two floats.  Each value is part
         in the least significant part of their floating point
         register..  */
      bfd_byte reg[MAX_REGISTER_SIZE];
      int regnum;
      int field;
      for (field = 0, regnum = mips_regnum (current_gdbarch)->fp0;
	   field < TYPE_NFIELDS (type); field++, regnum += 2)
	{
	  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])
			/ TARGET_CHAR_BIT);
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return float struct+%d\n",
				offset);
	  mips_xfer_register (regcache, NUM_REGS + regnum,
			      TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
#endif
#if 0
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (type) == TYPE_CODE_UNION)
    {
      /* A structure or union.  Extract the left justified value,
         regardless of the byte order.  I.e. DO NOT USE
         mips_xfer_lower.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += register_size (current_gdbarch, regnum), regnum++)
	{
	  int xfer = register_size (current_gdbarch, regnum);
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return struct+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      BFD_ENDIAN_UNKNOWN, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
#endif
  else
    {
      /* A scalar extract each part but least-significant-byte
         justified.  o32 thinks registers are 4 byte, regardless of
         the ISA.  mips_stack_argsize controls this.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += mips_stack_argsize (tdep), regnum++)
	{
	  int xfer = mips_stack_argsize (tdep);
	  int pos = 0;
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return scalar+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, NUM_REGS + regnum, xfer,
			      TARGET_BYTE_ORDER, readbuf, writebuf, offset);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
}

/* O64 ABI.  This is a hacked up kind of 64-bit version of the o32
   ABI.  */
d3527 3
a3529 4
			  struct regcache *regcache, CORE_ADDR bp_addr,
			  int nargs,
			  struct value **args, CORE_ADDR sp,
			  int struct_return, CORE_ADDR struct_addr)
a3535 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d3556 2
a3557 2
    len += align_up (TYPE_LENGTH (VALUE_TYPE (args[argnum])),
		     mips_stack_argsize (tdep));
d3561 1
a3561 1
    fprintf_unfiltered (gdb_stdlog,
d3577 1
a3577 1
      stack_offset += mips_stack_argsize (tdep);
d3604 2
a3605 1
      if (!FP_REGISTER_DOUBLE && fp_register_arg_p (typecode, arg_type))
d3657 1
a3657 1
	         above to ensure that it is even register aligned.  */
d3664 3
a3666 3
	         registers for each argument.  The below is (my
	         guess) to ensure that the corresponding integer
	         register has reserved the same space.  */
d3674 1
a3674 1
	  stack_offset += align_up (len, mips_stack_argsize (tdep));
d3686 2
a3687 2
	  int odd_sized_struct = ((len > mips_saved_regsize (tdep))
				  && (len % mips_saved_regsize (tdep) != 0));
d3690 1
a3690 1
	  if (mips_saved_regsize (tdep) < 8
d3694 1
a3694 1
		argreg++;
d3697 1
a3697 1
	     register are only written to memory.  */
d3702 2
a3703 2
	      int partial_len = (len < mips_saved_regsize (tdep)
				 ? len : mips_saved_regsize (tdep));
d3721 5
a3725 5
		      if (mips_stack_argsize (tdep) == 8
			  && (typecode == TYPE_CODE_INT
			      || typecode == TYPE_CODE_PTR
			      || typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = mips_stack_argsize (tdep) - len;
d3741 1
a3741 1
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ",
d3745 1
a3745 1
			  fprintf_unfiltered (gdb_stdlog, "%02x",
d3756 1
a3756 1
	         purpose register.  */
d3762 1
a3762 1
		     mips_regsize() != mips_saved_regsize().  */
d3777 1
a3777 1
		     mips_saved_regsize(), generates a left shift as
d3780 7
a3786 8
		     sizeof (struct) >= mips_saved_regsize()).  Since
		     it is quite possible that this is GCC
		     contradicting the LE/O32 ABI, GDB has not been
		     adjusted to accommodate this.  Either someone
		     needs to demonstrate that the LE/O32 ABI
		     specifies such a left shift OR this new ABI gets
		     identified as such and GDB gets tweaked
		     accordingly.  */
d3788 1
a3788 1
		  if (mips_saved_regsize (tdep) < 8
d3790 1
a3790 1
		      && partial_len < mips_saved_regsize (tdep)
d3793 1
a3793 1
		    regval <<= ((mips_saved_regsize (tdep) - partial_len) *
d3799 1
a3799 2
				      phex (regval,
					    mips_saved_regsize (tdep)));
d3812 1
a3812 1
	         will copy the next parameter.
d3814 4
a3817 4
	         In older ABIs, the caller reserved space for
	         registers that contained arguments.  This was loosely
	         refered to as their "home".  Consequently, space is
	         always allocated.  */
d3819 1
a3819 2
	      stack_offset += align_up (partial_len,
					mips_stack_argsize (tdep));
d3833 1
a3833 2
mips_o64_extract_return_value (struct type *valtype,
			       char regbuf[], char *valbuf)
d3835 11
a3845 3
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);
d3847 9
a3855 3
  memcpy (valbuf + lo.buf_offset,
	  regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + lo.reg) +
	  lo.reg_offset, lo.len);
d3857 9
a3865 5
  if (hi.len > 0)
    memcpy (valbuf + hi.buf_offset,
	    regbuf + DEPRECATED_REGISTER_BYTE (NUM_REGS + hi.reg) +
	    hi.reg_offset, hi.len);
}
d3867 1
a3867 66
static void
mips_o64_store_return_value (struct type *valtype, char *valbuf)
{
  char raw_buffer[MAX_REGISTER_SIZE];
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memset (raw_buffer, 0, sizeof (raw_buffer));
  memcpy (raw_buffer + lo.reg_offset, valbuf + lo.buf_offset, lo.len);
  deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (lo.reg),
				   raw_buffer, register_size (current_gdbarch,
							      lo.reg));

  if (hi.len > 0)
    {
      memset (raw_buffer, 0, sizeof (raw_buffer));
      memcpy (raw_buffer + hi.reg_offset, valbuf + hi.buf_offset, hi.len);
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (hi.reg),
				       raw_buffer,
				       register_size (current_gdbarch,
						      hi.reg));
    }
}

static void
mips_pop_frame (void)
{
  int regnum;
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR new_sp = get_frame_base (frame);
  mips_extra_func_info_t proc_desc;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), 0, 0))
    {
      generic_pop_dummy_frame ();
      flush_cached_frames ();
      return;
    }

  proc_desc = get_frame_extra_info (frame)->proc_desc;
  write_register (mips_regnum (current_gdbarch)->pc,
		  DEPRECATED_FRAME_SAVED_PC (frame));
  mips_find_saved_regs (frame);
  for (regnum = 0; regnum < NUM_REGS; regnum++)
    if (regnum != SP_REGNUM && regnum != mips_regnum (current_gdbarch)->pc
	&& deprecated_get_frame_saved_regs (frame)[regnum])
      {
	/* Floating point registers must not be sign extended, in case
	   mips_saved_regsize() = 4 but sizeof (FP0_REGNUM) == 8.  */

	if (mips_regnum (current_gdbarch)->fp0 <= regnum
	    && regnum < mips_regnum (current_gdbarch)->fp0 + 32)
	  write_register (regnum,
			  read_memory_unsigned_integer
			  (deprecated_get_frame_saved_regs (frame)[regnum],
			   mips_saved_regsize (tdep)));
	else
	  write_register (regnum,
			  read_memory_integer (deprecated_get_frame_saved_regs
					       (frame)[regnum],
					       mips_saved_regsize (tdep)));
      }

  write_register (SP_REGNUM, new_sp);
d3875 2
a3876 1
	   pi_ptr != NULL; prev_ptr = pi_ptr, pi_ptr = pi_ptr->next)
d3893 2
a3894 3
		      read_memory_integer ((new_sp
					    - 2 * mips_saved_regsize (tdep)),
					   mips_saved_regsize (tdep)));
d3896 2
a3897 3
		      read_memory_integer ((new_sp
					    - 3 * mips_saved_regsize (tdep)),
					   mips_saved_regsize (tdep)));
d3900 2
a3901 4
			read_memory_integer ((new_sp
					      -
					      4 * mips_saved_regsize (tdep)),
					     mips_saved_regsize (tdep)));
d3968 1
a3968 1
         32 bits.  */
d3997 1
a3997 1
         all 64 bits.  */
d4009 1
a4009 1
         each register.  */
d4031 1
a4031 4
  raw_buffer =
    (char *) alloca (2 *
		     register_size (current_gdbarch,
				    mips_regnum (current_gdbarch)->fp0));
d4044 1
a4044 2
      print_scalar_formatted (raw_buffer, builtin_type_uint32, 'x', 'w',
			      file);
d4056 1
a4056 1
				&inv2);
d4075 1
a4075 2
      print_scalar_formatted (raw_buffer, builtin_type_uint64, 'x', 'g',
			      file);
d4124 1
a4124 3
    offset =
      register_size (current_gdbarch,
		     regnum) - register_size (current_gdbarch, regnum);
d4128 2
a4129 3
  print_scalar_formatted (raw_buffer + offset,
			  gdbarch_register_type (gdbarch, regnum), 'x', 0,
			  file);
d4162 2
a4163 1
       col < ncols && regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
d4167 1
a4167 2
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
	  TYPE_CODE_FLT)
d4169 1
a4169 2
      fprintf_filtered (file,
			mips_regsize (current_gdbarch) == 8 ? "%17s" : "%9s",
d4181 2
a4182 1
       col < ncols && regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
d4186 1
a4186 2
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
	  TYPE_CODE_FLT)
d4194 2
a4195 1
		   - register_size (current_gdbarch, regnum)); byte++)
d4199 3
a4201 4
	for (byte =
	     register_size (current_gdbarch,
			    regnum) - register_size (current_gdbarch, regnum);
	     byte < register_size (current_gdbarch, regnum); byte++)
d4205 2
a4206 1
	     byte >= 0; byte--)
d4238 1
a4238 2
	  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
	      TYPE_CODE_FLT)
d4281 1
a4281 2
  return is_delayed ((unsigned long)
		     extract_unsigned_integer (buf, MIPS_INSTLEN));
d4324 1
a4324 1
	     line mark the prologue -> body transition.  */
d4354 1
a4354 1
    end_pc = pc + 100;		/* Magic.  */
d4414 1
a4414 1
		   high_word == 0x3408)	/* ori $t0,$zero,n */
d4422 554
a4975 2
      else
	break;
d4977 2
a4978 27

  /* In a frameless function, we might have incorrectly
     skipped some load immediate instructions. Undo the skipping
     if the load immediate was not followed by a stack adjustment.  */
  if (load_immediate_bytes && !seen_sp_adjust)
    pc -= load_immediate_bytes;
  return pc;
}

/* Skip the PC past function prologue instructions (16-bit version).
   This is a helper function for mips_skip_prologue.  */

static CORE_ADDR
mips16_skip_prologue (CORE_ADDR pc)
{
  CORE_ADDR end_pc;
  int extend_bytes = 0;
  int prev_extend_bytes;

  /* Table of instructions likely to be found in a function prologue.  */
  static struct
  {
    unsigned short inst;
    unsigned short mask;
  }
  table[] =
  {
d4980 8
a4987 56
    0x6300, 0xff00}
    ,				/* addiu $sp,offset */
    {
    0xfb00, 0xff00}
    ,				/* daddiu $sp,offset */
    {
    0xd000, 0xf800}
    ,				/* sw reg,n($sp) */
    {
    0xf900, 0xff00}
    ,				/* sd reg,n($sp) */
    {
    0x6200, 0xff00}
    ,				/* sw $ra,n($sp) */
    {
    0xfa00, 0xff00}
    ,				/* sd $ra,n($sp) */
    {
    0x673d, 0xffff}
    ,				/* move $s1,sp */
    {
    0xd980, 0xff80}
    ,				/* sw $a0-$a3,n($s1) */
    {
    0x6704, 0xff1c}
    ,				/* move reg,$a0-$a3 */
    {
    0xe809, 0xf81f}
    ,				/* entry pseudo-op */
    {
    0x0100, 0xff00}
    ,				/* addiu $s1,$sp,n */
    {
    0, 0}			/* end of table marker */
  };

  /* Find an upper bound on the prologue.  */
  end_pc = skip_prologue_using_sal (pc);
  if (end_pc == 0)
    end_pc = pc + 100;		/* Magic.  */

  /* Skip the typical prologue instructions. These are the stack adjustment
     instruction and the instructions that save registers on the stack
     or in the gcc frame.  */
  for (; pc < end_pc; pc += MIPS16_INSTLEN)
    {
      unsigned short inst;
      int i;

      inst = mips_fetch_instruction (pc);

      /* Normally we ignore an extend instruction.  However, if it is
         not followed by a valid prologue instruction, we must adjust
         the pc back over the extend so that it won't be considered
         part of the prologue.  */
      if ((inst & 0xf800) == 0xf000)	/* extend */
d4989 8
a4996 2
	  extend_bytes = MIPS16_INSTLEN;
	  continue;
d4998 11
a5008 11
      prev_extend_bytes = extend_bytes;
      extend_bytes = 0;

      /* Check for other valid prologue instructions besides extend.  */
      for (i = 0; table[i].mask != 0; i++)
	if ((inst & table[i].mask) == table[i].inst)	/* found, get out */
	  break;
      if (table[i].mask != 0)	/* it was in table? */
	continue;		/* ignore it */
      else
	/* non-prologue */
d5010 9
a5018 3
	  /* Return the current pc, adjusted backwards by 2 if
	     the previous instruction was an extend.  */
	  return pc - prev_extend_bytes;
d5020 1
a5021 1
  return pc;
a5023 9
/* To skip prologues, I use this predicate.  Returns either PC itself
   if the code at PC does not look like a function prologue; otherwise
   returns an address that (if we're lucky) follows the prologue.  If
   LENIENT, then we must skip everything which is involved in setting
   up the frame (it's OK to skip more, just so long as we don't skip
   anything which might clobber the registers which are being saved.
   We must skip more in the case where part of the prologue is in the
   delay slot of a non-prologue instruction).  */

d5025 1
a5025 1
mips_skip_prologue (CORE_ADDR pc)
d5027 4
a5030 11
  /* See if we can determine the end of the prologue via the symbol table.
     If so, then return either PC, or the PC after the prologue, whichever
     is greater.  */

  CORE_ADDR post_prologue_pc = after_prologue (pc, NULL);

  if (post_prologue_pc != 0)
    return max (pc, post_prologue_pc);

  /* Can't determine prologue from the symbol table, need to examine
     instructions.  */
d5032 2
a5033 4
  if (pc_is_mips16 (pc))
    return mips16_skip_prologue (pc);
  else
    return mips32_skip_prologue (pc);
d5058 1
a5058 2
  printf_unfiltered
    ("\"set mips\" must be followed by an appropriate subcommand.\n");
d5083 2
a5084 3
    printf_unfiltered
      ("The MIPS floating-point coprocessor is set automatically (currently %s)\n",
       fpu);
d5086 2
a5087 2
    printf_unfiltered
      ("The MIPS floating-point coprocessor is assumed to be %s\n", fpu);
d5094 1
a5094 2
  printf_unfiltered
    ("\"set mipsfpu\" must be followed by \"double\", \"single\",\"none\" or \"auto\".\n");
a5100 2
  struct gdbarch_info info;
  gdbarch_info_init (&info);
d5103 1
a5103 5
  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
     instead of relying on globals.  Doing that would let generic code
     handle the search for this specific architecture.  */
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, "set mipsfpu failed");
a5108 2
  struct gdbarch_info info;
  gdbarch_info_init (&info);
d5111 1
a5111 5
  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
     instead of relying on globals.  Doing that would let generic code
     handle the search for this specific architecture.  */
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, "set mipsfpu failed");
a5116 2
  struct gdbarch_info info;
  gdbarch_info_init (&info);
d5119 1
a5119 5
  /* FIXME: cagney/2003-11-15: Should be setting a field in "info"
     instead of relying on globals.  Doing that would let generic code
     handle the search for this specific architecture.  */
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, "set mipsfpu failed");
d5181 1
a5181 1
	info->mach = bfd_mach_mips16;
d5186 2
a5187 2
	info->mach = bfd_mach_mips16;
    }
d5193 2
a5194 1
  if (tdep->mips_abi == MIPS_ABI_N32 || tdep->mips_abi == MIPS_ABI_N64)
d5197 1
a5197 1
         register names from libopcodes.  */
d5227 1
a5227 1
mips_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
d5233 1
a5233 1
	  static unsigned char mips16_big_breakpoint[] = { 0xe8, 0xa5 };
d5243 3
a5245 3
	  static unsigned char big_breakpoint[] = { 0, 0x5, 0, 0xd };
	  static unsigned char pmon_big_breakpoint[] = { 0, 0, 0, 0xd };
	  static unsigned char idt_big_breakpoint[] = { 0, 0, 0x0a, 0xd };
d5263 1
a5263 1
	  static unsigned char mips16_little_breakpoint[] = { 0xa5, 0xe8 };
d5270 3
a5272 3
	  static unsigned char little_breakpoint[] = { 0xd, 0, 0x5, 0 };
	  static unsigned char pmon_little_breakpoint[] = { 0xd, 0, 0, 0 };
	  static unsigned char idt_little_breakpoint[] = { 0xd, 0x0a, 0, 0 };
d5355 1
a5355 2
	      if (find_pc_partial_function (target_pc, &name, NULL, NULL) ==
		  0)
d5397 1
a5397 2
  if (find_pc_partial_function (pc, name ? NULL : &name, &start_addr, NULL) ==
      0)
d5435 2
a5436 1
      && (name[19] == 's' || name[19] == 'd') && pc != start_addr)
d5476 2
a5477 1
			 int regnum, enum lval_type *lvalp)
d5579 1
a5579 1
    return LEGACY_SIM_REGNO_IGNORE;
d5634 2
a5635 1
  internal_error (__FILE__, __LINE__, "unknown ABI string");
d5639 2
a5640 1
mips_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
a5646 1
  enum mips_fpu_type fpu_type;
d5648 8
a5655 10
  /* First of all, extract the elf_flags, if available.  */
  if (info.abfd && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
    elf_flags = elf_elfheader (info.abfd)->e_flags;
  else if (arches != NULL)
    elf_flags = gdbarch_tdep (arches->gdbarch)->elf_flags;
  else
    elf_flags = 0;
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog,
			"mips_gdbarch_init: elf_flags = 0x%08x\n", elf_flags);
d5661 1
a5661 1
      found_abi = MIPS_ABI_O32;
d5664 1
a5664 1
      found_abi = MIPS_ABI_O64;
d5667 1
a5667 1
      found_abi = MIPS_ABI_EABI32;
d5670 1
a5670 1
      found_abi = MIPS_ABI_EABI64;
d5674 1
a5674 1
	found_abi = MIPS_ABI_N32;
d5676 1
a5676 1
	found_abi = MIPS_ABI_UNKNOWN;
d5681 2
a5682 2
  if (found_abi == MIPS_ABI_UNKNOWN && info.abfd != NULL)
    bfd_map_over_sections (info.abfd, mips_find_abi_section, &found_abi);
d5684 4
a5687 4
  /* If we have no usefu BFD information, use the ABI from the last
     MIPS architecture (if there is one).  */
  if (found_abi == MIPS_ABI_UNKNOWN && info.abfd == NULL && arches != NULL)
    found_abi = gdbarch_tdep (arches->gdbarch)->found_abi;
d5690 1
a5690 1
  if (found_abi == MIPS_ABI_UNKNOWN
d5697 1
a5697 1
	  found_abi = MIPS_ABI_EABI32;
d5701 1
a5701 1
	  found_abi = MIPS_ABI_EABI64;
d5710 1
a5710 1
	    found_abi = MIPS_ABI_N64;
d5712 1
a5712 1
	    found_abi = MIPS_ABI_N32;
d5717 2
a5718 9
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog, "mips_gdbarch_init: found_abi = %d\n",
			found_abi);

  /* What has the user specified from the command line?  */
  wanted_abi = global_mips_abi ();
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog, "mips_gdbarch_init: wanted_abi = %d\n",
			wanted_abi);
d5722 2
a5725 7
  else if (found_abi != MIPS_ABI_UNKNOWN)
    mips_abi = found_abi;
  else
    mips_abi = MIPS_ABI_O32;
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog, "mips_gdbarch_init: mips_abi = %d\n",
			mips_abi);
a5726 1
  /* Also used when doing an architecture lookup.  */
d5728 11
a5738 30
    fprintf_unfiltered (gdb_stdlog,
			"mips_gdbarch_init: mips64_transfers_32bit_regs_p = %d\n",
			mips64_transfers_32bit_regs_p);

  /* Determine the MIPS FPU type.  */
  if (!mips_fpu_type_auto)
    fpu_type = mips_fpu_type;
  else if (info.bfd_arch_info != NULL
	   && info.bfd_arch_info->arch == bfd_arch_mips)
    switch (info.bfd_arch_info->mach)
      {
      case bfd_mach_mips3900:
      case bfd_mach_mips4100:
      case bfd_mach_mips4111:
	fpu_type = MIPS_FPU_NONE;
	break;
      case bfd_mach_mips4650:
	fpu_type = MIPS_FPU_SINGLE;
	break;
      default:
	fpu_type = MIPS_FPU_DOUBLE;
	break;
      }
  else if (arches != NULL)
    fpu_type = gdbarch_tdep (arches->gdbarch)->mips_fpu_type;
  else
    fpu_type = MIPS_FPU_DOUBLE;
  if (gdbarch_debug)
    fprintf_unfiltered (gdb_stdlog,
			"mips_gdbarch_init: fpu_type = %d\n", fpu_type);
a5755 3
      /* Be pedantic about which FPU is selected.  */
      if (gdbarch_tdep (arches->gdbarch)->mips_fpu_type != fpu_type)
	continue;
a5763 3
  tdep->found_abi = found_abi;
  tdep->mips_abi = mips_abi;
  tdep->mips_fpu_type = fpu_type;
d5774 2
d5777 1
a5777 1
  set_gdbarch_elf_make_msymbol_special (gdbarch,
d5780 1
a5780 1
  /* Fill in the OS dependant register numbers and names.  */
a5781 1
    const char **reg_names;
d5784 1
a5795 1
	reg_names = mips_irix_reg_names;
a5807 5
	if (info.bfd_arch_info != NULL
	    && info.bfd_arch_info->mach == bfd_mach_mips3900)
	  reg_names = mips_tx39_reg_names;
	else
	  reg_names = mips_generic_reg_names;
a5814 3
    set_gdbarch_register_name (gdbarch, mips_register_name);
    tdep->mips_processor_reg_names = reg_names;
    tdep->regnum = regnum;
d5831 2
d5836 2
a5837 4
      set_gdbarch_deprecated_store_return_value (gdbarch,
						 mips_o64_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch,
						   mips_o64_extract_return_value);
d5847 3
a5849 2
      set_gdbarch_use_struct_convention (gdbarch,
					 always_use_struct_convention);
d5853 2
a5854 4
      set_gdbarch_deprecated_store_return_value (gdbarch,
						 mips_eabi_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch,
						   mips_eabi_extract_return_value);
d5866 1
a5866 1
      set_gdbarch_use_struct_convention (gdbarch,
d5871 2
a5872 4
      set_gdbarch_deprecated_store_return_value (gdbarch,
						 mips_eabi_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch,
						   mips_eabi_extract_return_value);
d5884 1
a5884 1
      set_gdbarch_use_struct_convention (gdbarch,
d5899 2
d5914 2
d5918 2
a5919 1
      internal_error (__FILE__, __LINE__, "unknown ABI in switch");
d5943 30
d5974 2
a5975 2
  set_gdbarch_write_pc (gdbarch, mips_write_pc);
  set_gdbarch_deprecated_target_read_fp (gdbarch, mips_read_sp);	/* Draft FRAME base.  */
d5984 1
a5984 2
  set_gdbarch_deprecated_init_frame_pc_first (gdbarch,
					      mips_init_frame_pc_first);
d5988 3
a5990 6
  set_gdbarch_ecoff_reg_to_regnum (gdbarch,
				   mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch,
				   mips_dwarf_dwarf2_ecoff_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch,
				    mips_dwarf_dwarf2_ecoff_reg_to_regnum);
d5994 2
a5995 4
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch,
						mips_find_saved_regs);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch,
						mips_init_extra_frame_info);
d6005 1
a6005 6
  set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch,
					       generic_save_dummy_frame_tos);

  set_gdbarch_convert_register_p (gdbarch, mips_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, mips_register_to_value);
  set_gdbarch_value_to_register (gdbarch, mips_value_to_register);
d6008 1
a6008 1
  set_gdbarch_frameless_function_invocation (gdbarch,
d6013 1
a6013 2
  set_gdbarch_deprecated_get_saved_register (gdbarch,
					     mips_get_saved_register);
d6017 1
d6020 1
a6020 2
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch,
					      mips_saved_pc_after_call);
d6026 2
d6046 3
d6058 2
a6059 1
mips_abi_update (char *ignore_args, int from_tty, struct cmd_list_element *c)
d6075 2
a6076 2
    printf_filtered
      ("The MIPS ABI is unknown because the current architecture is not MIPS.\n");
d6084 2
a6085 3
	printf_filtered
	  ("The MIPS ABI is set automatically (currently \"%s\").\n",
	   actual_abi_str);
d6087 3
a6089 3
	printf_filtered
	  ("The MIPS ABI is assumed to be \"%s\" (due to user setting).\n",
	   actual_abi_str);
d6093 4
a6096 3
	  printf_filtered
	    ("The (auto detected) MIPS ABI \"%s\" is in use even though the user setting was \"%s\".\n",
	     actual_abi_str, mips_abi_strings[global_abi]);
d6141 2
a6142 1
			  tdep->mips_abi, mips_abi_strings[tdep->mips_abi]);
d6145 1
a6145 1
			  mips_mask_address_p (tdep),
d6158 3
a6160 1
  fprintf_unfiltered (file, "mips_dump_tdep: MIPS_EABI = %d\n", MIPS_EABI);
d6169 3
d6175 8
a6182 3
		      "mips_dump_tdep: mips_stack_argsize() = %d\n",
		      mips_stack_argsize (tdep));
  fprintf_unfiltered (file, "mips_dump_tdep: A0_REGNUM = %d\n", A0_REGNUM);
d6185 1
a6185 1
		      XSTRING (ADDR_BITS_REMOVE (ADDR)));
d6228 2
a6229 1
  fprintf_unfiltered (file, "mips_dump_tdep: MIPS_DEFAULT_ABI = FIXME!\n");
d6233 2
a6234 1
		      "mips_dump_tdep: MIPS_INSTLEN = %d\n", MIPS_INSTLEN);
d6240 2
a6241 1
		      "mips_dump_tdep: MIPS_NUMREGS = %d\n", MIPS_NUMREGS);
d6243 2
a6244 2
		      "mips_dump_tdep: mips_saved_regsize() = %d\n",
		      mips_saved_regsize (tdep));
d6246 2
a6247 1
		      "mips_dump_tdep: PRID_REGNUM = %d\n", PRID_REGNUM);
d6254 24
a6277 11
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_FRAME_REG = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_FREG_MASK = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_FREG_OFFSET = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_HIGH_ADDR = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_LOW_ADDR = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_PC_REG = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_REG_MASK = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_REG_OFFSET = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PROC_SYMBOL = function?\n");
  fprintf_unfiltered (file, "mips_dump_tdep: PS_REGNUM = %d\n", PS_REGNUM);
  fprintf_unfiltered (file, "mips_dump_tdep: RA_REGNUM = %d\n", RA_REGNUM);
d6280 2
a6281 1
		      "mips_dump_tdep: SAVED_BYTES = %d\n", SAVED_BYTES);
d6284 3
a6286 1
  fprintf_unfiltered (file, "mips_dump_tdep: SAVED_FP = %d\n", SAVED_FP);
d6289 3
a6291 1
  fprintf_unfiltered (file, "mips_dump_tdep: SAVED_PC = %d\n", SAVED_PC);
d6299 2
a6300 1
		      "mips_dump_tdep: SIGFRAME_BASE = %d\n", SIGFRAME_BASE);
d6336 3
a6338 1
  fprintf_unfiltered (file, "mips_dump_tdep: T9_REGNUM = %d\n", T9_REGNUM);
d6343 1
a6343 2
		      XSTRING (TARGET_CAN_USE_HARDWARE_WATCHPOINT
			       (TYPE, CNT, OTHERTYPE)));
d6354 2
a6355 1
		      "mips_dump_tdep: TRACE_FLAVOR = %d\n", TRACE_FLAVOR);
d6365 1
a6365 1
		      XSTRING (TRACE_SET (X, STATE)));
d6369 2
a6370 1
		      "mips_dump_tdep: UNUSED_REGNUM = %d\n", UNUSED_REGNUM);
d6372 3
a6374 1
  fprintf_unfiltered (file, "mips_dump_tdep: V0_REGNUM = %d\n", V0_REGNUM);
d6379 2
a6380 1
		      "mips_dump_tdep: ZERO_REGNUM = %d\n", ZERO_REGNUM);
d6382 2
a6383 1
		      "mips_dump_tdep: _PROC_MAGIC_ = %d\n", _PROC_MAGIC_);
d6386 1
a6386 1
extern initialize_file_ftype _initialize_mips_tdep;	/* -Wmissing-prototypes */
d6394 1
a6394 1
  mips_abi_string = mips_abi_strings[MIPS_ABI_UNKNOWN];
d6421 3
a6423 1
          (default: auto)", &setmipscmdlist), &showmipscmdlist);
d6435 3
a6437 1
          target and executable (default)", &setmipscmdlist), &showmipscmdlist);
d6446 6
a6451 1
     "  o64\n" "  n32\n" "  n64\n" "  eabi32\n" "  eabi64", &setmipscmdlist);
d6454 1
a6454 1
	   "Show ABI in use by MIPS target", &showmipscmdlist);
d6472 2
a6473 1
	   "Select no MIPS floating-point coprocessor.", &mipsfpulist);
d6488 2
a6489 1
		   (char *) &heuristic_fence_post, "\
d6493 2
a6494 1
search.  The only need to set it is when debugging a stripped executable.", &setlist);
d6507 2
a6508 1
				NULL, show_mask_address, &setmipscmdlist, &showmipscmdlist);
d6517 1
a6517 1
64 bits for others.  Use \"off\" to disable compatibility mode", "\
d6521 3
a6523 1
64 bits for others.  Use \"off\" to disable compatibility mode", set_mips64_transfers_32bit_regs, NULL, &setlist, &showlist);
d6528 2
a6529 1
When non-zero, mips specific debugging is enabled.", &setdebuglist), &showdebuglist);
@


1.125
log
@2002-09-17  Andrew Cagney  <ac131313@@redhat.com>

	* NEWS: Mention that MIPS $fp behavior changed.
	* mipsnbsd-tdep.c (mipsnbsd_cannot_fetch_register): Delete
 	reference to FP_REGNUM.
	(mipsnbsd_cannot_store_register): Ditto.
	* mips-linux-nat.c: Update copyright.
 	(mips_linux_cannot_fetch_register): Delete reference to FP_REGNUM.
	(mips_linux_cannot_store_register): Ditto.
	* mips-linux-tdep.c (supply_gregset): Ditto.  Update copyright.
	* config/mips/tm-mips.h: Update copyright.
 	(FP_REGNUM): Delete macro.
	(MIPS_REGISTER_NAMES): Replace "fp" with "".
	* config/mips/tm-irix6.h (FP_REGNUM): Delete macro.
	* mips-tdep.c (mips_gdbarch_init): Set read_fp to mips_read_sp.
	(mips_r3041_reg_names, mips_r3051_reg_names)
 	(mips_r3081_reg_names): Replace "fp" with "".
	Fix PR gdb/480.
@
text
@d2587 8
d5974 1
@


1.124
log
@2002-08-13  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (mips_pop_frame): Read saved values of floating
	point registers without sign extension.
@
text
@d391 1
a391 1
	"fsr",  "fir",  "fp",	"",
d408 1
a408 1
	"fsr",  "fir",  "fp",	"",
d425 1
a425 1
	"fsr",  "fir",  "fp",	"",
d5926 1
a5926 1
  set_gdbarch_read_fp (gdbarch, generic_target_read_fp);
@


1.123
log
@Fri Sep 13 14:59:55 2002  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (read_next_frame_reg): Re-hack using
 	frame_register_unwind.
@
text
@d3785 15
a3799 7
    {
      if (regnum != SP_REGNUM && regnum != PC_REGNUM
	  && frame->saved_regs[regnum])
	write_register (regnum,
			read_memory_integer (frame->saved_regs[regnum],
					     MIPS_SAVED_REGSIZE));
    }
@


1.122
log
@Fri Sep 13 07:42:09 2002  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_get_saved_register): Re-hack using
 	frame_register_unwind.
@
text
@d1592 13
a1604 1
  for (; fi; fi = fi->next)
d1606 1
a1606 5
      /* We have to get the saved sp from the sigcontext
         if it is a signal handler frame.  */
      if (regno == SP_REGNUM && !fi->signal_handler_caller)
	return fi->frame;
      else
d1608 3
a1610 4
	  if (fi->saved_regs == NULL)
	    FRAME_INIT_SAVED_REGS (fi);
	  if (fi->saved_regs[regno])
	    return read_memory_integer (ADDR_BITS_REMOVE (fi->saved_regs[regno]), MIPS_SAVED_REGSIZE);
d1613 2
a1614 1
  return read_signed_register (regno);
@


1.121
log
@2002-09-10  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (mips_extract_struct_value_address): Make val a
	LONGEST, and use signed register read (addresses are sign-
	extended for mips).
@
text
@d5429 1
a5429 1
			 int *optimized,
d5433 1
a5433 1
			 enum lval_type *lval)
d5435 4
a5438 1
  CORE_ADDR addr;
d5443 15
a5457 5
  /* Normal systems don't optimize out things with register numbers.  */
  if (optimized != NULL)
    *optimized = 0;
  addr = find_saved_register (frame, regnum);
  if (addr != 0)
d5459 1
a5459 3
      if (lval != NULL)
	*lval = lval_memory;
      if (regnum == SP_REGNUM)
d5461 1
a5461 1
	  if (raw_buffer != NULL)
d5463 4
a5466 3
	      /* Put it back in target format.  */
	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
			     (LONGEST) addr);
a5467 3
	  if (addrp != NULL)
	    *addrp = 0;
	  return;
a5468 19
      if (raw_buffer != NULL)
	{
	  LONGEST val;
	  if (regnum < 32)
	    /* Only MIPS_SAVED_REGSIZE bytes of GP registers are
               saved. */
	    val = read_memory_integer (addr, MIPS_SAVED_REGSIZE);
	  else
	    val = read_memory_integer (addr, REGISTER_RAW_SIZE (regnum));
	  store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), val);
	}
    }
  else
    {
      if (lval != NULL)
	*lval = lval_register;
      addr = REGISTER_BYTE (regnum);
      if (raw_buffer != NULL)
	read_register_gen (regnum, raw_buffer);
a5469 2
  if (addrp != NULL)
    *addrp = addr;
@


1.120
log
@2002-09-05  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (mips_n32n64_push_arguments): Remove alignment
	adjustment that doesn't conform to the ABI.
	(mips_extract_struct_value_address): Retrieve V0_REGNUM from
	saved regcache, not from current regcache.
@
text
@d4910 3
a4912 2
  CORE_ADDR val;
  regcache_cooked_read_unsigned (regcache, V0_REGNUM, &val);
@


1.119
log
@Index: ChangeLog
===================================================================
RCS file: /cvs/src/src/gdb/ChangeLog,v
retrieving revision 1.3144
diff -u -r1.3144 ChangeLog
--- ChangeLog	23 Aug 2002 23:05:38 -0000	1.3144
+++ ChangeLog	23 Aug 2002 23:14:45 -0000
@@@@ -1,3 +1,53 @@@@
2002-08-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (STORE_RETURN_VALUE): Add regcache parameter.
	(DEPRECATED_STORE_RETURN_VALUE): New method.
	(EXTRACT_RETURN_VALUE): Make buffer parameter a void pointer.
	* gdbarch.h, gdbarch.c: Re-generate.

	* values.c (set_return_value): Pass current_regcache to
	STORE_RETURN_VALUE.
	* arch-utils.h (legacy_store_return_value): Declare.
	* arch-utils.c (legacy_store_return_value): New function.
	(legacy_extract_return_value): Update parameters.

	* config/pa/tm-hppa.h (DEPRECATED_STORE_RETURN_VALUE): Rename
	STORE_RETURN_VALUE.
	* config/pa/tm-hppa64.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/z8k/tm-z8k.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparclet.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/mn10200/tm-mn10200.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-linux.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m32r/tm-m32r.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8500/tm-h8500.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8300/tm-h8300.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.

	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* i386-tdep.c (i386_extract_return_value): Update.
	* arch-utils.c (legacy_extract_return_value): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.

Index: doc/ChangeLog
2002-08-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Update
	STORE_RETURN_VALUE, mention regcache.
@
text
@a2957 4
		      else if ((typecode == TYPE_CODE_STRUCT ||
				typecode == TYPE_CODE_UNION) &&
			       TYPE_LENGTH (arg_type) < MIPS_STACK_ARGSIZE)
			longword_offset = MIPS_STACK_ARGSIZE - len;
d4905 1
a4905 1
mips_extract_struct_value_address (struct regcache *ignore)
d4910 3
a4912 1
  return read_register (V0_REGNUM);
@


1.119.6.1
log
@* mips-tdep.c (mips_find_abi_section): .mdebug.abi64 is the name
of the section for the N64 ABI, fixed.
@
text
@d5550 1
a5550 1
  else if (strcmp (name, ".mdebug.abi64") == 0)
@


1.118
log
@2002-08-21  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (DEFAULT_MIPS_TYPE): Delete unused macro.
	* config/mips/tm-mips.h (DEFAULT_MIPS_TYPE): Delete unused macro.
	* config/mips/tm-embed.h (DEFAULT_MIPS_TYPE): Delete unused macro.
@
text
@d4783 1
a4783 1
			       char *valbuf)
d4891 1
a4891 1
				  char *valbuf)
d5729 1
a5729 1
      set_gdbarch_store_return_value (gdbarch, mips_o32_store_return_value);
d5748 1
a5748 1
      set_gdbarch_store_return_value (gdbarch, mips_o64_store_return_value);
d5767 1
a5767 1
      set_gdbarch_store_return_value (gdbarch, mips_eabi_store_return_value);
d5786 1
a5786 1
      set_gdbarch_store_return_value (gdbarch, mips_eabi_store_return_value);
d5805 1
a5805 1
      set_gdbarch_store_return_value (gdbarch, mips_n32n64_store_return_value);
d5836 1
a5836 1
      set_gdbarch_store_return_value (gdbarch, mips_n32n64_store_return_value);
@


1.117
log
@2002-08-21  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (MSYMBOL_IS_SPECIAL): Replace macro with function.
	(MSYMBOL_SIZE): Replace macro with function.
@
text
@d5917 3
a6136 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: DEFAULT_MIPS_TYPE = %s\n",
		      DEFAULT_MIPS_TYPE);
@


1.116
log
@2002-08-20  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (MSYMBOL_IS_SPECIAL, MSYMBOL_SIZE): These are only
	used locally, so move them from the target machine header to here.
	(mips_set_processor_type, mips_register_name, mips32_next_pc,
	mips16_next_pc, cached_proc_desc, mips_set_processor_type):
	Make static.
	* config/mips/tm-mips.h (MSYMBOL_IS_SPECIAL, MSYMBOL_SIZE): Delete.
@
text
@d176 1
a176 1
/* Macros for setting and testing a bit in a minimal symbol that
a189 5
#define MSYMBOL_IS_SPECIAL(msym) \
  (((long) MSYMBOL_INFO (msym) & 0x80000000) != 0)
#define MSYMBOL_SIZE(msym) \
  ((long) MSYMBOL_INFO (msym) & 0x7fffffff)

d201 12
d755 1
a755 1
    return MSYMBOL_IS_SPECIAL (sym);
a6146 3
		      "mips_dump_tdep: ELF_MAKE_MSYMBOL_SPECIAL # %s\n",
		      XSTRING (ELF_MAKE_MSYMBOL_SPECIAL (SYM, MSYM)));
  fprintf_unfiltered (file,
a6241 5
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MSYMBOL_IS_SPECIAL = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MSYMBOL_SIZE # %s\n",
		      XSTRING (MSYMBOL_SIZE (MSYM)));
@


1.115
log
@2002-08-20  Michael Snyder  <msnyder@@redhat.com>

        * mips-tdep.c (mips_in_return_stub): Make static.
	(mips_gdbarch_init): Set in_solib_return_trampoline.
	* config/mips/tm-mips.h (IN_SOLIB_RETURN_TRAMPOLINE): Delete.
@
text
@d176 30
d330 1
a330 1
int mips_set_processor_type (char *);
d366 1
a366 1
const char *
a752 32
/* ELF_MAKE_MSYMBOL_SPECIAL tests whether an ELF symbol is "special",
   i.e. refers to a 16-bit function, and sets a "special" bit in a
   minimal symbol to mark it as a 16-bit function.  */

static void
mips_elf_make_msymbol_special (asymbol *sym, struct minimal_symbol *msym)
{
  if (((elf_symbol_type *)(sym))->internal_elf_sym.st_other == STO_MIPS16) 
    { 
      MSYMBOL_INFO (msym) = (char *) 
	(((long) MSYMBOL_INFO (msym)) | 0x80000000); 
      SYMBOL_VALUE_ADDRESS (msym) |= 1; 
    } 
}

/* MSYMBOL_IS_SPECIAL tests the "special" bit in a minimal symbol.  */

int
mips_msymbol_is_special (struct minimal_symbol *msym) 
{
  return (((long) MSYMBOL_INFO (msym) & 0x80000000) != 0); 
}

/* MSYMBOL_SIZE returns the size of the minimal symbol, i.e.  the
   "info" field with the "special" bit masked out.  */

long
mips_msymbol_size (struct minimal_symbol *msym)
{
  return ((long) MSYMBOL_INFO (msym) & 0x7fffffff);
}

d916 1
a916 1
CORE_ADDR
d1355 1
a1355 1
CORE_ADDR
d1677 1
a1677 1
  tmp = mips_skip_stub (pc);
d2392 1
a2392 1
mips_extra_func_info_t cached_proc_desc;
d2406 1
a2406 1
  if ((tmp = mips_skip_stub (saved_pc)) != 0)
d5036 1
a5036 1
int
@


1.114
log
@2002-08-20  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (mips_skip_stub, mips_in_call_stub): Make static.
	(mips_gdbarch_init): Set skip_trampoline_code,
	in_solib_call_trampoline.
	* config/mips/tm-mips.h (REGISTER_NAME): Delete.
	(IN_SOLIB_CALL_TRAMPOLINE, SKIP_TRAMPOLINE_CODE): Delete.
@
text
@d3776 7
a3782 15
    if (regnum != SP_REGNUM && regnum != PC_REGNUM
	&& frame->saved_regs[regnum])
      {
	/* Floating point registers must not be sign extended, 
	   in case MIPS_SAVED_REGSIZE = 4 but sizeof (FP0_REGNUM) == 8.  */

	if (FP0_REGNUM <= regnum && regnum < FP0_REGNUM + 32)
	  write_register (regnum,
			  read_memory_unsigned_integer (frame->saved_regs[regnum],
							MIPS_SAVED_REGSIZE));
	else
	  write_register (regnum,
			  read_memory_integer (frame->saved_regs[regnum],
					       MIPS_SAVED_REGSIZE));
      }
d5333 1
a5333 1
int
d6006 1
a6006 1
  /* set_gdbarch_in_solib_return_trampoline (gdbarch, mips_in_return_stub); */
@


1.113
log
@2002-08-19  Michael Snyder  <msnyder@@redhat.com>

	* config/mips/tm-mips.h (ELF_MAKE_MSYMBOL_SPECIAL): Delete.
	(MSYMBOL_IS_SPECIAL, MSYMBOL_SIZE): Change into functions.
	(FIX_CALL_DUMMY, PUSH_RETURN_ADDRESS, PUSH_DUMMY_FRAME,
	POP_FRAME, INIT_EXTRA_FRAME_INFO): Delete.
	(CALL_DUMMY_START_OFFSET, CALL_DUMMY_BREAKPOINT_OFFSET,
	CALL_DUMMY_ADDRESS): Delete.
	* mips-tdep.c (mips_elf_make_msymbol_special, mips_msymbol_size,
	mips_msymbol_is_special, mips_fix_call_dummy): New functions.
	(mips_gdbarch_init): Set elf_make_msymbol_special, pop_frame,
	push_dummy_frame, fix_call_dummy, init_extra_frame_info,
	push_return_address.
	(mips_register_raw_size, mips_eabi_use_struct_convention,
	mips_n32n64_use_struct_convention, mips_o32_use_struct_convention,
	mips_o32_reg_struct_has_addr, mips_frame_saved_pc, mips_frame_chain,
	mips_init_extra_frame_info, mips_eabi_push_arguments,
	mips_n32n64_push_arguments, mips_push_return_address,
	mips_push_dummy_frame,	mips_pop_frame,	mips_skip_prologue,
	mips_breakpoint_from_pc, mips_call_dummy_address): Make	static.
@
text
@d3776 16
a3791 7
    {
      if (regnum != SP_REGNUM && regnum != PC_REGNUM
	  && frame->saved_regs[regnum])
	write_register (regnum,
			read_memory_integer (frame->saved_regs[regnum],
					     MIPS_SAVED_REGSIZE));
    }
d5230 1
a5230 1
CORE_ADDR
d5313 1
a5313 1
int
d6010 6
@


1.112
log
@2002-08-19  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (mips_frame_num_args): New function.
	(mips_gdbarch_init): Set frame_chain, frameless_function_invocation,
	frame_saved_pc, frame_args_address, frame_locals_address,
	frame_num_args, and frame_args_skip.
	* config/mips/tm-mips.h (FRAME_CHAIN, FRAMELESS_FUNCTION_INVOCATION,
	FRAME_SAVED_PC, FRAME_ARGS_ADDRESS, FRAME_LOCALS_ADDRESS,
	FRAME_NUM_ARGS, FRAME_ARGS_SKIP): Delete.
	* config/mips/tm-mipsv4.h (FRAME_CHAIN_VALID): Delete.
@
text
@d479 1
a479 1
int
d656 1
a656 1
int
d662 1
a662 1
int
d668 1
a668 1
int
d696 1
a696 1
int
d723 32
d1684 1
a1684 1
CORE_ADDR
d2396 1
a2396 1
CORE_ADDR
d2427 1
a2427 1
      && frame->pc != mips_call_dummy_address ())
d2433 1
a2433 1
void
d2574 1
a2574 1
CORE_ADDR
d2827 1
a2827 1
CORE_ADDR
d3649 1
a3649 1
CORE_ADDR
d3684 1
a3684 1
void
d3763 1
a3763 1
void
d3821 7
d4423 1
a4423 1
CORE_ADDR
d5139 1
a5139 1
const unsigned char *
d5382 1
a5382 1
CORE_ADDR
d5716 3
d5942 3
d5949 1
@


1.111
log
@2002-08-20  Michael Snyder  <msnyder@@redhat.com>

	* config/mips/tm-mips.h (STORE_STRUCT_RETURN): Delete.
	(EXTRACT_STRUCT_VALUE_ADDRESS): Delete.
	* mips-tdep.c (mips_store_struct_return): New function.
	(mips_extract_struct_value_address): New function.
	(mips_gdbarch_init): Set store_struct_return and
	extract_struct_value_address.
@
text
@a4145 9
/* Return number of args passed to a frame. described by FIP.
   Can return -1, meaning no way to tell.  */

int
mips_frame_num_args (struct frame_info *frame)
{
  return -1;
}

d5916 1
d5918 8
@


1.110
log
@2002-08-20  Andrew Cagney  <ac131313@@redhat.com>

* mips-tdep.c (mips_gdbarch_init): Update.
(mips_o32_extract_return_value): Rewrite.
(mips_o32_store_return_value): Rewrite.
(mips_o32_xfer_return_value): New function.
(mips_xfer_register): Tweak debug print message.  Allow for
buf_offset when dumping the value transfered.
@
text
@d4866 15
d5952 3
@


1.109
log
@2002-08-20  Andrew Cagney  <ac131313@@redhat.com>

* config/mips/tm-nbsd.h (MIPS_DEFAULT_ABI): Delete.
* config/mips/tm-linux.h (MIPS_DEFAULT_ABI): Delete.
* config/mips/tm-irix5.h (MIPS_DEFAULT_ABI): Delete.
* config/mips/tm-irix6.h (MIPS_DEFAULT_ABI): Delete.
* mips-tdep.c (mips_gdbarch_init) [MIPS_DEFAULT_ABI]: Delete code.
@
text
@d188 2
d205 3
a207 2
    fprintf_unfiltered (gdb_stderr, "xfer $%d[%d..%d] ",
			reg_num, reg_offset, reg_offset + length);
d211 1
a211 1
      fprintf_unfiltered (gdb_stdlog, "out: ");
d213 1
a213 1
	fprintf_unfiltered (gdb_stdlog, "%02x", out[i]);
d222 1
a222 1
      fprintf_unfiltered (gdb_stdlog, "in: ");
d224 1
a224 1
	fprintf_unfiltered (gdb_stdlog, "%02x", in[i]);
a4547 19
mips_o32_extract_return_value (struct type *valtype,
				char regbuf[REGISTER_BYTES],
				char *valbuf)
{
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memcpy (valbuf + lo.buf_offset,
	  regbuf + REGISTER_BYTE (lo.reg) + lo.reg_offset,
	  lo.len);

  if (hi.len > 0)
    memcpy (valbuf + hi.buf_offset,
	    regbuf + REGISTER_BYTE (hi.reg) + hi.reg_offset,
	    hi.len);
}

static void
d4594 1
a4594 1
mips_o32_store_return_value (struct type *valtype, char *valbuf)
d4617 2
d4620 3
a4622 1
mips_o64_store_return_value (struct type *valtype, char *valbuf)
d4624 119
a4742 4
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);
d4744 7
a4750 5
  memset (raw_buffer, 0, sizeof (raw_buffer));
  memcpy (raw_buffer + lo.reg_offset, valbuf + lo.buf_offset, lo.len);
  write_register_bytes (REGISTER_BYTE (lo.reg),
			raw_buffer,
			REGISTER_RAW_SIZE (lo.reg));
d4752 4
a4755 8
  if (hi.len > 0)
    {
      memset (raw_buffer, 0, sizeof (raw_buffer));
      memcpy (raw_buffer + hi.reg_offset, valbuf + hi.buf_offset, hi.len);
      write_register_bytes (REGISTER_BYTE (hi.reg),
			    raw_buffer,
			    REGISTER_RAW_SIZE (hi.reg));
    }
d4758 2
d5676 1
a5676 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, mips_o32_extract_return_value);
@


1.108
log
@2002-08-14  Michael Snyder  <msnyder@@redhat.com>

        * mips-tdep.c (mips_frame_chain): Check for call-dummy frames.
@
text
@a5511 5
#ifdef MIPS_DEFAULT_ABI
  if (mips_abi == MIPS_ABI_UNKNOWN)
    mips_abi = MIPS_DEFAULT_ABI;
#endif

@


1.107
log
@2002-08-19  Andrew Cagney  <ac131313@@redhat.com>

* mips-tdep.c (mips_xfer_register): New function.
(mips_n32n64_extract_return_value): Rewrite.
(mips_gdbarch_init): For N32 and N64, set extract_return_value
instead of deprecated_extract_return_value.
@
text
@d2388 5
a2392 3
  /* The previous frame from a sigtramp frame might be frameless
     and have frame size zero.  */
      && !frame->signal_handler_caller)
@


1.106
log
@2002-08-18  Andrew Cagney  <ac131313@@redhat.com>
* config/mips/tm-mips.h (STORE_RETURN_VALUE): Delete macro.
(DEPRECATED_EXTRACT_RETURN_VALUE): Delete macro.
* mips-tdep.c (mips_gdbarch_init): Set store_return_value and
deprecated_extract_return_value.
(mips_o32_push_arguments, mips_o64_push_arguments): Clone and
rename mips_o32o64_push_arguments.
(mips_gdbarch_init): Update.
(mips_extract_return_value): Delete.
(mips_o32_extract_return_value): Clone mips_extract_return_value.
(mips_o64_extract_return_value): Clone mips_extract_return_value.
(mips_eabi_extract_return_value): Clone mips_extract_return_value.
(mips_n32n64_extract_return_value): Clone
mips_extract_return_value.
(mips_store_return_value): Delete.
(mips_o32_store_return_value): Clone mips_store_return_value.
(mips_o64_store_return_value): Clone mips_store_return_value.
(mips_eabi_store_return_value): Clone mips_store_return_value.
(mips_n32n64_store_return_value): Clone mips_store_return_value.
@
text
@d176 51
a4579 19
static void
mips_n32n64_extract_return_value (struct type *valtype,
				  char regbuf[REGISTER_BYTES],
				  char *valbuf)
{
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memcpy (valbuf + lo.buf_offset,
	  regbuf + REGISTER_BYTE (lo.reg) + lo.reg_offset,
	  lo.len);

  if (hi.len > 0)
    memcpy (valbuf + hi.buf_offset,
	    regbuf + REGISTER_BYTE (hi.reg) + hi.reg_offset,
	    hi.len);
}

d4656 95
a4750 1
mips_n32n64_store_return_value (struct type *valtype, char *valbuf)
d4752 2
a4753 4
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);
d4755 4
a4758 14
  memset (raw_buffer, 0, sizeof (raw_buffer));
  memcpy (raw_buffer + lo.reg_offset, valbuf + lo.buf_offset, lo.len);
  write_register_bytes (REGISTER_BYTE (lo.reg),
			raw_buffer,
			REGISTER_RAW_SIZE (lo.reg));

  if (hi.len > 0)
    {
      memset (raw_buffer, 0, sizeof (raw_buffer));
      memcpy (raw_buffer + hi.reg_offset, valbuf + hi.buf_offset, hi.len);
      write_register_bytes (REGISTER_BYTE (hi.reg),
			    raw_buffer,
			    REGISTER_RAW_SIZE (hi.reg));
    }
d5652 1
a5652 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, mips_n32n64_extract_return_value);
d5683 1
a5683 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, mips_n32n64_extract_return_value);
@


1.105
log
@2002-08-15  Michael Snyder  <msnyder@@redhat.com>

	* config/mips/tm-mips.h (FUNCTION_START_OFFSET, IN_SIGTRAMP,
	REGISTER_VIRTUAL_SIZE): Delete.
	(REGISTER_CONVERT_FROM_TYPE, REGISTER_CONVERT_TO_TYPE): Convert
	from macros to functions.

	* mips-tdep.c (mips_register_convert_from_type,
        mips_register_convert_to_type): New functions.
        (mips_gdbarch_init): Set up function_start_offset,
	register_virtual_size, pc_in_sigtramp.
@
text
@d2963 1
a2963 1
/* O32/O64 version of push_arguments.  */
d2965 305
a3269 6
CORE_ADDR
mips_o32o64_push_arguments (int nargs,
			    struct value **args,
			    CORE_ADDR sp,
			    int struct_return,
			    CORE_ADDR struct_addr)
d3294 1
a3294 1
			"mips_o32o64_push_arguments: sp=0x%s allocated %d\n",
d3306 1
a3306 1
			    "mips_o32o64_push_arguments: struct_return reg=%d 0x%s\n",
d3326 1
a3326 1
			    "mips_o32o64_push_arguments: %d len=%d type=%d",
d4472 61
a4532 4
void
mips_extract_return_value (struct type *valtype,
			   char regbuf[REGISTER_BYTES],
			   char *valbuf)
d4551 74
a4624 2
void
mips_store_return_value (struct type *valtype, char *valbuf)
d5460 3
a5462 1
      set_gdbarch_push_arguments (gdbarch, mips_o32o64_push_arguments);
d5479 3
a5481 1
      set_gdbarch_push_arguments (gdbarch, mips_o32o64_push_arguments);
d5499 2
d5518 2
d5537 2
d5568 2
@


1.104
log
@2002-08-15  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (mips_do_registers_info): Make static.
        (mips_gdbarch_init): Insert mips_do_registers_info into gdbarch.
        * config/mips/tm-mips.h (DO_REGISTERS_INFO): Delete.
@
text
@d480 32
d4221 2
a4222 2
int
in_sigtramp (CORE_ADDR pc, char *ignore)
d4908 1
a4908 1
  /* Check ELF_FLAGS to see if it specifies the ABI being used. */
d5002 1
a5002 1
         using. */
d5011 1
a5011 1
  /* Need a new architecture. Fill in a target specific vector. */
d5017 1
a5017 1
  /* Initially set everything according to the default ABI/ISA. */
d5168 1
a5168 1
     link with libraries compiled without "-gp32". This is
d5178 1
a5178 1
     and not all gcc targets support that currently. Therefore using
d5181 1
a5181 1
     as 32-bit programs by default. */
d5208 1
a5208 1
     Further work on it is required. */
d5216 2
a5217 2
  /* Add/remove bits from an address. The MIPS needs be careful to
     ensure that all 32 bit addresses are sign extended to 64 bits. */
d5225 1
a5225 1
  /* Map debug register numbers onto internal register numbers. */
d5270 2
d5275 1
d5278 1
@


1.103
log
@2002-08-15  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (mips_gdbarch_init): Set gdbarch read_sp to
	mips_read_sp.
        * config/mips/tm-mips.h (TARGET_READ_SP): Delete.
@
text
@d2305 3
a2307 5
      /* The previous frame from a sigtramp frame might be frameless
	 and have frame size zero.  */
      && !frame->signal_handler_caller
      /* Check if this is a call dummy frame.  */
      && frame->pc != mips_call_dummy_address ())
d3357 7
a3363 16
    if (regnum != SP_REGNUM && regnum != PC_REGNUM
	&& frame->saved_regs[regnum])
      {
	/* Floating point registers must not be sign extended, 
	   in case MIPS_SAVED_REGSIZE = 4 but sizeof (FP0_REGNUM) == 8.  */

	if (FP0_REGNUM <= regnum && regnum < FP0_REGNUM + 32)
	  write_register (regnum,
			  read_memory_unsigned_integer (frame->saved_regs[regnum],
							MIPS_SAVED_REGSIZE));
	else
	  write_register (regnum,
			  read_memory_integer (frame->saved_regs[regnum],
					       MIPS_SAVED_REGSIZE));
      }

d3731 1
a3731 1
void
d4090 3
a4092 13
	  if ((gdbarch_tdep (current_gdbarch) -> mips_abi == MIPS_ABI_N32 
	       || gdbarch_tdep (current_gdbarch) -> mips_abi == MIPS_ABI_N64)
	      && (TYPE_CODE (valtype) == TYPE_CODE_STRUCT 
		  || TYPE_CODE (valtype) == TYPE_CODE_UNION))
	    {
	      /* Values are already aligned in the low register.  */
	      lo->reg_offset = 0;
	    }
	  else
	    {
	      /* "un-left-justify" the value in the low register */
	      lo->reg_offset = MIPS_SAVED_REGSIZE - len;
	    }
a4093 1
	  lo->len = len;
a4098 2
	       && gdbarch_tdep (current_gdbarch) -> mips_abi != MIPS_ABI_N32 
	       && gdbarch_tdep (current_gdbarch) -> mips_abi != MIPS_ABI_N64
a4935 1
#undef MIPS_DEFAULT_ABI
d5216 1
a5216 1
  set_gdbarch_register_convertible (gdbarch, generic_register_convertible_not);
d5241 2
@


1.102
log
@2002-08-15  Michael Snyder  <msnyder@@redhat.com>

	* config/mips/tm-mips.h (REGISTER_CONVERT_TO_VIRTUAL,
	REGISTER_CONVERT_TO_RAW, REGISTER_CONVERTIBLE,
	MAX_REGISTER_RAW_SIZE, MAX_REGISTER_VIRTUAL_SIZE): Delete.
	* mips-tdep.c (mips_gdbarch_init): Set the above in the gdbarch.
	(mips_register_convertible, mips_register_convert_to_virtual,
	mips_register_convert_to_raw): Make static.
@
text
@d516 8
d2305 5
a2309 3
  /* The previous frame from a sigtramp frame might be frameless
     and have frame size zero.  */
      && !frame->signal_handler_caller)
d2972 1
a2972 1
  /* the struct_return pointer occupies the first parameter-passing reg */
d3359 16
a3374 7
    {
      if (regnum != SP_REGNUM && regnum != PC_REGNUM
	  && frame->saved_regs[regnum])
	write_register (regnum,
			read_memory_integer (frame->saved_regs[regnum],
					     MIPS_SAVED_REGSIZE));
    }
d4101 14
a4114 2
	  /* "un-left-justify" the value in the low register */
	  lo->reg_offset = MIPS_SAVED_REGSIZE - len;
a4115 1
	  hi->reg_offset = 0;
d4121 2
d4960 1
d5206 1
a5206 1
  set_gdbarch_read_sp (gdbarch, generic_target_read_sp);
@


1.101
log
@2002-08-13  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (mips_push_arguments): Rename to
	mips_eabi_push_arguments, and tune for EABI.
	(MIPS_REGS_HAVE_HOME_P): Delete.
	(struct gdbarch_tdep): Remove mips_regs_have_home_p field.
	(mips_gdbarch_init): Set gdbarch push_arguments for eabi.
	Delete references to mips_regs_have_home_p.
@
text
@d442 1
a442 1
int
d451 1
a451 1
void
d465 1
a465 1
void
d4984 2
d5209 5
@


1.100
log
@2002-08-13  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (mips_o32o64_push_arguments):  New function,
	cloned from mips_push_arguments, tuned for o32/o64 ABI.
	(mips_gdbarch_init): Set gdbarch_push_arguments to new func.
@
text
@a140 1
    int mips_regs_have_home_p;
a207 5
/* Does the caller allocate a ``home'' for each register used in the
   function call?  The N32 ABI and MIPS_EABI do not, the others do. */

#define MIPS_REGS_HAVE_HOME_P (gdbarch_tdep (current_gdbarch)->mips_regs_have_home_p)

d2447 5
a2451 5
mips_push_arguments (int nargs,
		     struct value **args,
		     CORE_ADDR sp,
		     int struct_return,
		     CORE_ADDR struct_addr)
a2457 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d2468 1
a2468 1
  /* Now make space on the stack for the args. We allocate more
d2470 1
a2470 1
     passed in registers, but that's OK. */
d2472 2
a2473 1
    len += ROUND_UP (TYPE_LENGTH (VALUE_TYPE (args[argnum])), MIPS_STACK_ARGSIZE);
d2477 2
a2478 1
    fprintf_unfiltered (gdb_stdlog, "mips_push_arguments: sp=0x%s allocated %d\n",
d2485 1
a2485 1
  /* the struct_return pointer occupies the first parameter-passing reg */
d2490 1
a2490 1
			    "mips_push_arguments: struct_return reg=%d 0x%s\n",
a2492 2
      if (MIPS_REGS_HAVE_HOME_P)
	stack_offset += MIPS_STACK_ARGSIZE;
d2509 1
a2509 1
			    "mips_push_arguments: %d len=%d type=%d",
d2513 2
a2514 3
         reference. In all other cases, pass the structure by value.  */
      if (MIPS_EABI
	  && len > MIPS_SAVED_REGSIZE
d2530 2
a2531 2
         left. Non MIPS_EABI targets also pass the FP in the integer
         registers so also round up normal registers. */
d2550 1
a2550 1
         stack. */
a2564 7
	      if (!MIPS_EABI)
		{
		  if (mips_debug)
		    fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
					argreg, phex (regval, 4));
		  write_register (argreg++, regval);
		}
a2571 7
	      if (!MIPS_EABI)
		{
		  if (mips_debug)
		    fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
					argreg, phex (regval, 4));
		  write_register (argreg++, regval);
		}
d2578 1
a2578 1
                 above to ensure that it is even register aligned. */
a2583 12
	      if (!MIPS_EABI)
		{
		  /* CAGNEY: 32 bit MIPS ABI's always reserve two FP
                     registers for each argument.  The below is (my
                     guess) to ensure that the corresponding integer
                     register has reserved the same space. */
		  if (mips_debug)
		    fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
					argreg, phex (regval, len));
		  write_register (argreg, regval);
		  argreg += FP_REGISTER_DOUBLE ? 1 : 2;
		}
a2584 3
	  /* Reserve space for the FP register. */
	  if (MIPS_REGS_HAVE_HOME_P)
	    stack_offset += ROUND_UP (len, MIPS_STACK_ARGSIZE);
d2597 1
a2597 8
	  /* Structures should be aligned to eight bytes (even arg registers)
	     on MIPS_ABI_O32 if their first member has double precision. */
	  if (tdep->mips_abi == MIPS_ABI_O32
	      && mips_type_needs_double_align (arg_type))
	    {
	      if ((argreg & 1))
	        argreg++;
	    }
d2599 1
a2599 1
             register are only written to memory. */
d2604 2
a2605 1
	      int partial_len = len < MIPS_SAVED_REGSIZE ? len : MIPS_SAVED_REGSIZE;
d2660 1
a2660 1
	         arguments will not. */
d2662 1
a2662 1
                 purpose register. */
a2667 34
		  /* A non-floating-point argument being passed in a
		     general register.  If a struct or union, and if
		     the remaining length is smaller than the register
		     size, we have to adjust the register value on
		     big endian targets.

		     It does not seem to be necessary to do the
		     same for integral types.

		     Also don't do this adjustment on EABI and O64
		     binaries.

		     cagney/2001-07-23: gdb/179: Also, GCC, when
		     outputting LE O32 with sizeof (struct) <
		     MIPS_SAVED_REGSIZE, generates a left shift as
		     part of storing the argument in a register a
		     register (the left shift isn't generated when
		     sizeof (struct) >= MIPS_SAVED_REGSIZE).  Since it
		     is quite possible that this is GCC contradicting
		     the LE/O32 ABI, GDB has not been adjusted to
		     accommodate this.  Either someone needs to
		     demonstrate that the LE/O32 ABI specifies such a
		     left shift OR this new ABI gets identified as
		     such and GDB gets tweaked accordingly.  */

		  if (!MIPS_EABI
		      && MIPS_SAVED_REGSIZE < 8
		      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
		      && partial_len < MIPS_SAVED_REGSIZE
		      && (typecode == TYPE_CODE_STRUCT ||
			  typecode == TYPE_CODE_UNION))
		    regval <<= ((MIPS_SAVED_REGSIZE - partial_len) *
				TARGET_CHAR_BIT);

a2673 6

		  /* If this is the old ABI, prevent subsequent floating
		     point arguments from being passed in floating point
		     registers.  */
		  if (!MIPS_EABI)
		    float_argreg = MIPS_LAST_FP_ARG_REGNUM + 1;
a2681 5
		 In older ABIs, the caller reserved space for
		 registers that contained arguments.  This was loosely
		 refered to as their "home".  Consequently, space is
		 always allocated.

d2683 1
a2683 1
	         only needs to be adjusted when it has been used.. */
d2685 1
a2685 1
	      if (MIPS_REGS_HAVE_HOME_P || stack_used_p)
d2736 1
a2736 1
  /* the struct_return pointer occupies the first parameter-passing reg */
a2936 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
a4995 1
      tdep->mips_regs_have_home_p = 1;
a5012 1
      tdep->mips_regs_have_home_p = 1;
d5024 1
a5024 1
      set_gdbarch_push_arguments (gdbarch, mips_push_arguments);
a5029 1
      tdep->mips_regs_have_home_p = 0;
d5041 1
a5041 1
      set_gdbarch_push_arguments (gdbarch, mips_push_arguments);
a5046 1
      tdep->mips_regs_have_home_p = 0;
a5063 1
      tdep->mips_regs_have_home_p = 0;
a5092 1
      tdep->mips_regs_have_home_p = 0;
a5321 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_REGS_HAVE_HOME_P = %d\n",
		      MIPS_REGS_HAVE_HOME_P);
@


1.99
log
@Oversights in previous checkin.
@
text
@a2593 1

d2646 1
a2646 1
	      /* Rememer if the argument was written to the stack. */
d2785 2
d3011 300
d5079 1
a5079 1
      set_gdbarch_push_arguments (gdbarch, mips_push_arguments);
d5097 1
a5097 1
      set_gdbarch_push_arguments (gdbarch, mips_push_arguments);
@


1.98
log
@2002-08-09  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (ROUND_DOWN, ROUND_UP): Move to global scope.
	(mips_push_arguments): Correct some comments.  Use paddr_nz
	for printing addresses in debug output.  Replace static
	allocation using MAX_REGISTER_RAW_SIZE with alloca.
	(mips_n32n64_push_arguments): New function, cloned from
	mips_push_arguments and tuned for the n32/n64 ABI.
	(mips_push_register): Buffer needs dynamic allocation.
	(mips_print_register): Ditto.
	(do_gp_register_row): Ditto.
	(mips_store_return_value): Ditto.
	(mips_gdbarch_init): Set gdbarch_push_arguments per ABI.
@
text
@d3301 1
a3301 1
  char *raw_buffer (MAX_REGISTER_RAW_SIZE);
@


1.97
log
@2002-08-08  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c (mips_n32n64_use_struct_convention): N32 only
	returns structs by ref if they're too big to fit in two registers.
@
text
@d2446 6
d2466 5
a2470 4
  /* Macros to round N up or down to the next A boundary; A must be
     a power of two. */
#define ROUND_DOWN(n,a) ((n) & ~((a)-1))
#define ROUND_UP(n,a) (((n)+(a)-1) & ~((a)-1))
a2471 5
  /* First ensure that the stack and structure return address (if any)
     are properly aligned. The stack has to be at least 64-bit aligned
     even on 32-bit machines, because doubles must be 64-bit aligned.
     On at least one MIPS variant, stack frames need to be 128-bit
     aligned, so we round to this widest known alignment. */
d2483 2
a2484 2
    fprintf_unfiltered (gdb_stdlog, "mips_push_arguments: sp=0x%lx allocated %d\n",
			(long) sp, ROUND_UP (len, 16));
d2495 2
a2496 2
			    "mips_push_arguments: struct_return reg=%d 0x%lx\n",
			    argreg, (long) struct_addr);
d2508 1
a2508 1
      char valbuf[MAX_REGISTER_RAW_SIZE];
d2680 4
a2683 4
		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=0x%lx",
					  (long) stack_offset);
		      fprintf_unfiltered (gdb_stdlog, " longword_offset=0x%lx",
					  (long) longword_offset);
d2691 2
a2692 1
		      fprintf_unfiltered (gdb_stdlog, " @@0x%lx ", (long) addr);
d2695 2
a2696 1
			  fprintf_unfiltered (gdb_stdlog, "%02x", val[i] & 0xff);
d2787 224
d3022 1
a3022 1
  char buffer[MAX_REGISTER_RAW_SIZE];
d3301 1
a3301 1
  char raw_buffer[MAX_REGISTER_RAW_SIZE];
d3318 1
a3318 1
      char dbuffer[2 * MAX_REGISTER_RAW_SIZE];
d3453 1
a3453 1
  char raw_buffer[MAX_REGISTER_RAW_SIZE];
d3946 1
a3946 1
  char raw_buffer[MAX_REGISTER_RAW_SIZE];
d4778 1
d4796 1
d4814 1
d4832 1
d4850 1
d4880 1
a4999 1
  set_gdbarch_push_arguments (gdbarch, mips_push_arguments);
@


1.96
log
@Fix minor formatting problem in previous patch.
@
text
@d577 1
a577 1
  return 1;	/* Structures are returned by ref in extra arg0.  */
@


1.95
log
@	* mips-tdep.c (mips_init_extra_frame_info): Initialize SP_REGNUM's
	saved regs value.
	(read_next_frame_reg): Call FRAME_INIT_SAVED_REGS instead of
	mips_find_saved_regs().
	(mips_pop_frame): Likewise.
@
text
@d1267 1
a1267 2
   though.)
*/
@


1.94
log
@2002-08-08  Michael Snyder  <msnyder@@redhat.com>

	* mips-tdep.c: Minor whitespace and indentation clean-ups.
@
text
@d1259 10
a1268 1
   NULL).  */
d1477 1
a1477 1
	    mips_find_saved_regs (fi);
d2354 6
d2908 1
a2908 1
    mips_find_saved_regs (frame);
@


1.93
log
@	* mips-tdep.c (mips_find_saved_regs): Make static.
	(mips_frame_init_saved_regs): New function.
	(mips_gdbarch_init): Setup FRAME_INIT_SAVED_REGS method.
	* config/mips/tm-mips.h (FRAME_INIT_SAVED_REGS): Delete macro.
	(mips_find_saved_regs): Delete declaration.
@
text
@a1113 1

d2214 1
a2214 1
	  PROC_DESC_IS_DUMMY (proc_desc) ? 0 : PROC_SYMBOL (proc_desc);
d2226 2
a2227 2
	      heuristic_proc_desc (PROC_LOW_ADDR (proc_desc),
				   pc, next_frame, cur_frame);
d2260 4
a2263 3
  return ADDR_BITS_REMOVE (
		   read_next_frame_reg (frame, PROC_FRAME_REG (proc_desc)) +
	     PROC_FRAME_OFFSET (proc_desc) - PROC_FRAME_ADJUST (proc_desc));
d2310 1
a2310 1
  fci->next ? cached_proc_desc : find_proc_desc (fci->pc, fci->next, 1);
d2400 1
a2400 1
	   && MIPS_FPU_TYPE != MIPS_FPU_NONE);
@


1.92
log
@2002-08-06  Michael Snyder  <msnyder@@redhat.com>

        * config/mips/tm-mips.h: Remove #define USE_STRUCT_CONVENTION.
	* mips-tdep.c (mips_EABI_use_struct_convention,
	mips_OABI_use_struct_convention, mips_NABI_use_struct_convention):
	New functions.  (mips_use_struct_convention): Delete.
	(mips_gdbarch_init): set use_gdbarch_convention.
@
text
@d1262 1
a1262 1
void
d1440 17
d4735 1
@


1.91
log
@2002-08-06  Michael Snyder  <msnyder@@redhat.com>

	*  mips-tdep.c: gdbarch-ify reg_struct_has_addr.
	(mips_eabi_reg_struct_has_addr, mips_n32n64_reg_struct_has_addr,
	mips_o32_reg_struct_has_addr): New functions.
	(mips_gdbarch_init): Set gdbarch reg_struct_has_addr.
@
text
@d567 13
d581 1
a581 1
mips_use_struct_convention (int gcc_p, struct type *type)
d583 1
a583 4
  if (MIPS_EABI)
    return (TYPE_LENGTH (type) > 2 * MIPS_SAVED_REGSIZE);
  else
    return 1;			/* Structures are returned by ref in extra arg0 */
d4532 2
d4549 2
d4566 2
d4583 2
d4609 3
d4638 3
@


1.90
log
@2002-08-05  Michael Snyder  <msnyder@@redhat.com>

	*  mips-tdep.c (mips_find_saved_regs): Adjust stack according
	to MIPS_SAVED_REGSIZE, not GDB_TARGET_IS_MIPS64.  Enhance comment.
	(mips_gdbarch_init): Set N32 target to be mips64.
@
text
@d576 28
d4520 2
d4535 2
d4550 2
d4565 2
d4591 2
d4617 2
@


1.89
log
@	* mips-tdep.c (mips_gdbarch_init): For the N32 ABI, set
	mips_default_saved_regsize to 8.
@
text
@d1374 14
a1387 3
  /* The freg_offset points to where the first *double* register
     is saved.  So skip to the high-order word. */
  if (!GDB_TARGET_IS_MIPS64)
d4539 1
a4539 1
      tdep->gdb_target_is_mips64 = 0;
@


1.88
log
@	* mips-tdep.c (mips_register_virtual_type): Use architecture
	invariant return values.
@
text
@d4522 1
a4522 1
      tdep->mips_default_saved_regsize = 4;
@


1.87
log
@	* mips-tdep.c (mips_gdbarch_init): Add comments.  Fix typo in
	comment.
@
text
@d500 7
a506 1
    return builtin_type_double;
d513 4
a516 4
      /* Everything else... return ``long long'' when registers
         are 64-bits wide, ``int'' otherwise.  */
      if (MIPS_REGSIZE == TYPE_LENGTH (builtin_type_long_long))
	return builtin_type_long_long;
d518 1
a518 1
	return builtin_type_int;
@


1.86
log
@Multiarch REGISTER_VIRTUAL_TYPE for Irix 6.
@
text
@d4374 1
a4374 1
  /* Try the architecture for any hint of the corect ABI */
d4390 3
d4671 2
@


1.85
log
@	* mips-tdep.c (_initialize_mips_tdep): Add "n64" to "set mips abi"
	help message.
@
text
@d486 30
d4667 2
@


1.84
log
@	* mips-tdep.c (mips_push_arguments): Fetch gdbarch_tdep struct
	and save it in a local variable.  Use variable in later test.
@
text
@d5129 1
@


1.83
log
@	* mips-tdep.c (mips_find_abi_section): Add N64 ABI recognition
	test.  (Thanks to Daniel Jacobowitz.)
@
text
@d2342 1
d2519 1
a2519 1
	  if (gdbarch_tdep (current_gdbarch)->mips_abi == MIPS_ABI_O32
@


1.82
log
@	* mips-tdep.c (enum mips_abi): Add MIPS_ABI_N64.
	(mips_abi_strings): Add "n64".
	(mips_gdbarch_init): Add test for n64 abi.  Add MIPS_ABI_N64 case.
@
text
@d4255 2
@


1.81
log
@2002-06-19  Daniel Jacobowitz  <drow@@mvista.com>

        * mips-tdep.c (enum mips_abi): Explicitly start at 0.  Add
        MIPS_ABI_LAST.
        (mips_abi_string, mips_abi_strings): New.
        (struct gdbarch_tdep): Remove mips_abi_string, add found_abi.
        (mips_gdbarch_init): Set tdep->found_abi.  Don't set
        tdep->mips_abi_string.  Honor mips_abi_string.  Default to
        O32 if no ABI is found.
        (mips_dump_tdep): Use mips_abi_strings.
        (mips_abi_update): New function.
        (_initialize_mips_tdep): Initialize mips_abi_string.  Add
        ``set mips abi'' and ``show mips abi''.  Check the size of
        mips_abi_strings.
@
text
@d67 1
d80 1
d4357 5
a4361 1
	  mips_abi = MIPS_ABI_N32;
d4490 24
@


1.80
log
@* gdbarch.sh (REGISTER_NAME): Change return type a constant string
pointer.
* gdbarch.h, gdbarch.c: Regenerate.
* config/mips/tm-mips.h (mips_register_name): Update.
* i386-tdep.h (i386_register_name): Update.
* mips-tdep.c (mips_register_name): Update
* alpha-tdep.c (alpha_register_name): Update.
* arch-utils.c (legacy_register_name): Update.
* arch-utils.h (legacy_register_name): Update.
* avr-tdep.c (avr_register_name): Update.
* ia64-tdep.c (ia64_register_name): Update.
* i386-tdep.c (i386_register_name): Update.
* sparc-tdep.c (sparc32_register_name): Update.
(sparc64_register_name): Update.
(sparclite_register_name): Update.
(sparclet_register_name):
* sh-tdep.c (sh_generic_register_name): Update.
(sh_sh_register_name): Update.
(sh_sh3_register_name): Update.
(sh_sh3e_register_name): Update.
(sh_sh_dsp_register_name): Update.
(sh_sh3_dsp_register_name): Update.
(sh_sh4_register_name): Update.
(sh_sh64_register_name): Update.
* s390-tdep.c (s390_register_name): Update.
* rs6000-tdep.c (rs6000_register_name): Update.
* ns32k-tdep.c (ns32k_register_name_32082): Update.
(ns32k_register_name_32382): Update.
* d10v-tdep.c (d10v_ts2_register_name): Update.
(d10v_ts3_register_name): Update.
* xstormy16-tdep.c (xstormy16_register_name): Update.
* vax-tdep.c (vax_register_name): Update.
* v850-tdep.c (v850_register_name): Update.
* m68hc11-tdep.c (m68hc11_register_name): Update.
* mn10300-tdep.c (mn10300_generic_register_name): Update.
(am33_register_name): Update.
@
text
@d64 1
a64 1
    MIPS_ABI_UNKNOWN,
d69 2
a70 1
    MIPS_ABI_EABI64
d73 12
d133 1
a133 1
    const char *mips_abi_string;
d4263 13
d4285 1
a4285 1
  enum mips_abi mips_abi;
d4334 5
d4359 1
d4365 10
d4383 3
d4416 1
a4421 1
      tdep->mips_abi_string = "o32";
a4434 1
      tdep->mips_abi_string = "o64";
a4447 1
      tdep->mips_abi_string = "eabi32";
a4460 1
      tdep->mips_abi_string = "eabi64";
a4473 1
      tdep->mips_abi_string = "n32";
d4498 2
a4499 13
      tdep->mips_abi_string = "default";
      tdep->mips_default_saved_regsize = MIPS_REGSIZE;
      tdep->mips_default_stack_argsize = MIPS_REGSIZE;
      tdep->mips_fp_register_double = (REGISTER_VIRTUAL_SIZE (FP0_REGNUM) == 8);
      tdep->mips_last_arg_regnum = A0_REGNUM + 8 - 1;
      tdep->mips_last_fp_arg_regnum = FPA0_REGNUM + 8 - 1;
      tdep->mips_regs_have_home_p = 1;
      tdep->gdb_target_is_mips64 = 0;
      tdep->default_mask_address_p = 0;
      set_gdbarch_long_bit (gdbarch, 32);
      set_gdbarch_ptr_bit (gdbarch, 32);
      set_gdbarch_long_long_bit (gdbarch, 64);
      break;
d4612 12
d4664 1
a4664 1
			  tdep->mips_abi_string);
d5040 5
d5086 15
@


1.79
log
@* command.h (add_setshow_auto_boolean_cmd): Replace
add_set_auto_boolean_cmd.
* cli/cli-decode.c (add_setshow_auto_boolean_cmd): Replace
add_set_auto_boolean_cmd.
* cli/cli-decode.h (add_set_auto_boolean_cmd): Delete declaration.
* mips-tdep.c (_initialize_mips_tdep): Update ``set mips
mask-address'' command.
(show_mask_address): Add cmd parameter.
* remote.c (add_packet_config_cmd): Update.  Change type of
set_func and show_func to cmd_sfunc_ftype.
(_initialize_remote): Update `set remote Z-packet'
(show_remote_protocol_qSymbol_packet_cmd): Add cmd parameter.
(show_remote_protocol_e_packet_cmd): Ditto.
(show_remote_protocol_E_packet_cmd): Ditto.
(show_remote_protocol_P_packet_cmd): Ditto.
(show_remote_protocol_Z_software_bp_packet_cmd): Ditto.
(show_remote_protocol_Z_hardware_bp_packet_cmd): Ditto.
(show_remote_protocol_Z_write_wp_packet_cmd): Ditto.
(show_remote_protocol_Z_read_wp_packet_cmd): Ditto.
(show_remote_protocol_Z_access_wp_packet_cmd): Ditto.
(show_remote_protocol_Z_packet_cmd): Ditto.
(show_remote_protocol_binary_download_cmd): Ditto.
(show_remote_cmd): Pass NULL to all of above.
@
text
@d273 1
a273 1
char *
@


1.78
log
@* defs.h (auto_boolean): Declare enum.
* command.h (cmd_auto_boolean): Delete enum.
* mips-tdep.c (mask_address_var): Update.
(mips_mask_address_p): Update.
(show_mask_address): Update.
* remote.c (struct packet_config): Update.
(update_packet_config): Update.
(show_packet_config_cmd): Update.
(packet_ok): Update.
(add_packet_config_cmd): Update.
(_initialize_remote):
* command.h: Update.
* cli/cli-setshow.c (parse_auto_binary_operation): Update.
(do_setshow_command): Update.
* cli/cli-decode.c (add_set_auto_boolean_cmd): Update.
* cli/cli-decode.h: Update.
@
text
@d494 1
a494 1
show_mask_address (char *cmd, int from_tty)
d5086 7
a5092 7
  c = add_set_auto_boolean_cmd ("mask-address", no_class, &mask_address_var,
				"Set zeroing of upper 32 bits of 64-bit addresses.\n\
Use \"on\" to enable the masking, \"off\" to disable it and \"auto\" to allow GDB to determine\n\
the correct value.\n",
				&setmipscmdlist);
  add_cmd ("mask-address", no_class, show_mask_address,
	       "Show current mask-address value", &showmipscmdlist);
@


1.77
log
@2002-06-13  Daniel Jacobowitz  <drow@@mvista.com>

        * mips-tdep.c (PROC_SYMBOL): Add warning comment.
        (struct mips_objfile_private, compare_pdr_entries): New.
        (non_heuristic_proc_desc): Read the ".pdr" section if it
        is present.
@
text
@d472 1
a472 1
enum cmd_auto_boolean mask_address_var = CMD_AUTO_BOOLEAN_AUTO;
d479 1
a479 1
    case CMD_AUTO_BOOLEAN_TRUE:
d481 1
a481 1
    case CMD_AUTO_BOOLEAN_FALSE:
d484 1
a484 1
    case CMD_AUTO_BOOLEAN_AUTO:
d498 1
a498 1
    case CMD_AUTO_BOOLEAN_TRUE:
d501 1
a501 1
    case CMD_AUTO_BOOLEAN_FALSE:
d504 1
a504 1
    case CMD_AUTO_BOOLEAN_AUTO:
@


1.76
log
@2002-06-11  Daniel Jacobowitz  <drow@@mvista.com>

        * mips-tdep.c (MIPS_FPU_TYPE, FP_REGISTER_DOUBLE, MIPS_EABI)
        (MIPS_LAST_FP_ARG_REGNUM, MIPS_LAST_ARG_REGNUM)
        (MIPS_DEFAULT_SAVED_REGSIZE, MIPS_REGS_HAVE_HOME_P)
        (MIPS_DEFAULT_STACK_ARGSIZE, GDB_TARGET_IS_MIPS64)
        (MIPS_DEFAULT_MASK_ADDRESS_P): Remove obsolete definitions.  Define
        unconditionally.
        (set_mipsfpu_single_command, set_mipsfpu_double_command)
        (set_mipsfpu_none_command): Remove if (GDB_MULTI_ARCH).
        (_initialize_mips_tdep): Remove dead code.
        * config/mips/tm-irix5.h (MIPS_LAST_ARG_REGNUM)
        (MIPS_DEFAULT_STACK_ARGSIZE, MIPS_REGS_HAVE_HOME_P): Remove.
        * config/mips/tm-irix6.h (MIPS_LAST_ARG_REGNUM)
        (MIPS_DEFAULT_STACK_ARGSIZE, MIPS_REGS_HAVE_HOME_P): Remove.
        * config/mips/tm-mips.h (MIPS_EABI, MIPS_LAST_ARG_REGNUM,
        MIPS_LAST_FP_ARG_REGNUM): Remove.
@
text
@d384 2
d1893 24
d1924 5
d1933 121
a2053 3
  if (b == NULL || PC_IN_CALL_DUMMY (pc, 0, 0))
    sym = NULL;
  else
d2055 4
a2058 7
      if (startaddr > BLOCK_START (b))
	/* This is the "pathological" case referred to in a comment in
	   print_frame_info.  It might be better to move this check into
	   symbol reading.  */
	sym = NULL;
      else
	sym = lookup_symbol (MIPS_EFI_SYMBOL_NAME, b, LABEL_NAMESPACE, 0, NULL);
d2060 2
@


1.75
log
@2002-06-09  Daniel Jacobowitz  <drow@@mvista.com>

        * mips-tdep.c (mips_find_abi_section): New function.
        (mips_gdbarch_init): Call it.
@
text
@a108 6
#define MIPS_FPU_TYPE mips_fpu_type

/* Do not use "TARGET_IS_MIPS64" to test the size of floating point registers */
#ifndef FP_REGISTER_DOUBLE
#define FP_REGISTER_DOUBLE (REGISTER_VIRTUAL_SIZE(FP0_REGNUM) == 8)
#endif
a133 2
#if GDB_MULTI_ARCH
#undef MIPS_EABI
a135 1
#endif
a136 2
#if GDB_MULTI_ARCH
#undef MIPS_LAST_FP_ARG_REGNUM
a137 1
#endif
a138 2
#if GDB_MULTI_ARCH
#undef MIPS_LAST_ARG_REGNUM
a139 1
#endif
a140 2
#if GDB_MULTI_ARCH
#undef MIPS_FPU_TYPE
a141 1
#endif
a144 2
#if GDB_MULTI_ARCH
#undef MIPS_DEFAULT_SAVED_REGSIZE
a145 3
#elif !defined (MIPS_DEFAULT_SAVED_REGSIZE)
#define MIPS_DEFAULT_SAVED_REGSIZE MIPS_REGSIZE
#endif
a191 2
#if GDB_MULTI_ARCH
#undef FP_REGISTER_DOUBLE
a192 1
#endif
a196 2
#if GDB_MULTI_ARCH
#undef MIPS_REGS_HAVE_HOME_P
a197 3
#elif !defined (MIPS_REGS_HAVE_HOME_P)
#define MIPS_REGS_HAVE_HOME_P (!MIPS_EABI)
#endif
a202 2
#if GDB_MULTI_ARCH
#undef MIPS_DEFAULT_STACK_ARGSIZE
a203 3
#elif !defined (MIPS_DEFAULT_STACK_ARGSIZE)
#define MIPS_DEFAULT_STACK_ARGSIZE (MIPS_DEFAULT_SAVED_REGSIZE)
#endif
a219 2
#if GDB_MULTI_ARCH
#undef GDB_TARGET_IS_MIPS64
a220 1
#endif
a221 2
#if GDB_MULTI_ARCH
#undef MIPS_DEFAULT_MASK_ADDRESS_P
a222 3
#elif !defined (MIPS_DEFAULT_MASK_ADDRESS_P)
#define MIPS_DEFAULT_MASK_ADDRESS_P (0)
#endif
d3526 1
a3526 4
  if (GDB_MULTI_ARCH)
    {
      gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_SINGLE;
    }
d3534 1
a3534 4
  if (GDB_MULTI_ARCH)
    {
      gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_DOUBLE;
    }
d3542 1
a3542 4
  if (GDB_MULTI_ARCH)
    {
      gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_NONE;
    }
a4918 15

#if !GDB_MULTI_ARCH
  c = add_set_cmd ("processor", class_support, var_string_noescape,
		   (char *) &tmp_mips_processor_type,
		   "Set the type of MIPS processor in use.\n\
Set this to be able to access processor-type-specific registers.\n\
",
		   &setlist);
  set_cmd_cfunc (c, mips_set_processor_type_command);
  c = add_show_from_set (c, &showlist);
  set_cmd_cfunc (c, mips_show_processor_type_command);

  tmp_mips_processor_type = xstrdup (DEFAULT_MIPS_TYPE);
  mips_set_processor_type_command (xstrdup (DEFAULT_MIPS_TYPE), 0);
#endif
@


1.74
log
@* Makefile.in (SFILES): Add osabi.c.
(COMMON_OBS): Add osabi.o.
(osabi.o): New dependency list.
* osabi.c: New file.
* osabi.h: New file.
* doc/gdbint.texinfo: Document new generic OS ABI framework.

* Makefile.in (alpha_tdep_h): Define and use instead of
alpha-tdep.h.
* alpha-tdep.c (alpha_abi_names, process_note_abi_tag_sections,
get_elfosabi, alpha_abi_handler_list, alpha_gdbarch_register_os_abi):
Remove.
(alpha_gdbarch_init, alpha_dump_tdep): Use generic OS ABI framework.
* alpha-tdep.h: Include osabi.h.
(alpha_abi): Remove.
(gdbarch_tdep): Use generic OS ABI framework.
* alpha-linux-tdep.c (_initialize_alpha_linux_tdep): Use
gdbarch_register_osabi.
* alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Likewise.
* alphafbsd-tdep.c (_initialize_alphafbsd_tdep): Likewise.
* alphanbsd-tdep.c (_initialize_alphanbsd_tdep): Likewise.

* Makefile.in (sh_tdep_h): Add osabi.h.
* sh-tdep.h (sh_osabi): Remove.
(gdbarch_tdep): Use generic OS ABI framework.
* sh-tdep.c (sh_osabi_names, process_note_abi_tag_sections,
sh_osabi_handler_list, sh_gdbarch_register_os_abi): Remove.
(sh_gdbarch_init, sh_dump_tdep): Use generic OS ABI framework.
* shnbsd-tdep.c (_initialize_shnbsd_tdep): Use gdbarch_register_osabi.

* Makefile.in (arm_tdep_h): Define and use instead of arm-tdep.h.
* arm-linux-tdep.c (_initialize_arm_linux_tdep): Use
gdbarch_register_osabi.
* arm-tdep.c (arm_abi_names, process_note_abi_tag_sections,
arm_abi_handler_list, arm_gdbarch_register_os_abi): Remove.
(get_elfosabi): Rename to...
(arm_elf_osabi_sniffer): ...this.  Adjust to use generic OS
ABI framework support routines.
(arm_gdbarch_init): Use generic OS ABI framework.
(arm_dump_tdep): Likewise.
(_initialize_arm_tdep): Likewise.
* arm-tdep.h: Include osabi.h.
(arm_abi): Remove.
(gdbarch_tdep): Remove arm_abi and abi_name members.  Add
osabi member.
(arm_gdbarch_register_os_abi): Remove prototype.
* armnbsd-tdep.c (arm_netbsd_aout_osabi_sniffer): New function.
(_initialize_arm_netbsd_tdep): Use gdbarch_register_osabi.

* Makefile.in (mips-tdep.o): Add osabi.h to dependency list.
* mips-tdep.c: Include osabi.h.
(gdbarch_tdep, mips_gdbarch_init, mips_dump_tdep): Use generic
OS ABI framework.
@
text
@d4129 26
d4208 4
@


1.74.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d64 1
a64 1
    MIPS_ABI_UNKNOWN = 0,
d69 1
a69 2
    MIPS_ABI_EABI64,
    MIPS_ABI_LAST
a71 12
static const char *mips_abi_string;

static const char *mips_abi_strings[] = {
  "auto",
  "n32",
  "o32",
  "o64",
  "eabi32",
  "eabi64",
  NULL
};

d109 6
d126 1
a126 1
    enum mips_abi found_abi;
d140 2
d144 1
d146 2
d149 1
d151 2
d154 1
d156 2
d159 1
d163 2
d166 3
d215 2
d218 1
d223 2
d226 3
d234 2
d237 3
d256 2
d259 1
d261 2
d264 3
d317 1
a317 1
const char *
a427 2
/* FIXME drow/2002-06-10: If a pointer on the host is bigger than a long,
   this will corrupt pdr.iline.  Fortunately we don't use it.  */
d514 1
a514 1
enum auto_boolean mask_address_var = AUTO_BOOLEAN_AUTO;
d521 1
a521 1
    case AUTO_BOOLEAN_TRUE:
d523 1
a523 1
    case AUTO_BOOLEAN_FALSE:
d526 1
a526 1
    case AUTO_BOOLEAN_AUTO:
d536 1
a536 1
show_mask_address (char *cmd, int from_tty, struct cmd_list_element *c)
d540 1
a540 1
    case AUTO_BOOLEAN_TRUE:
d543 1
a543 1
    case AUTO_BOOLEAN_FALSE:
d546 1
a546 1
    case AUTO_BOOLEAN_AUTO:
a1934 24
struct mips_objfile_private
{
  bfd_size_type size;
  char *contents;
};

/* Global used to communicate between non_heuristic_proc_desc and
   compare_pdr_entries within qsort ().  */
static bfd *the_bfd;

static int
compare_pdr_entries (const void *a, const void *b)
{
  CORE_ADDR lhs = bfd_get_32 (the_bfd, (bfd_byte *) a);
  CORE_ADDR rhs = bfd_get_32 (the_bfd, (bfd_byte *) b);

  if (lhs < rhs)
    return -1;
  else if (lhs == rhs)
    return 0;
  else
    return 1;
}

a1941 5
  struct obj_section *sec;
  struct mips_objfile_private *priv;

  if (PC_IN_CALL_DUMMY (pc, 0, 0))
    return NULL;
d1946 3
a1948 5

  priv = NULL;

  sec = find_pc_section (pc);
  if (sec != NULL)
d1950 7
a1956 120
      priv = (struct mips_objfile_private *) sec->objfile->obj_private;

      /* Search the ".pdr" section generated by GAS.  This includes most of
	 the information normally found in ECOFF PDRs.  */

      the_bfd = sec->objfile->obfd;
      if (priv == NULL
	  && (the_bfd->format == bfd_object
	      && bfd_get_flavour (the_bfd) == bfd_target_elf_flavour
	      && elf_elfheader (the_bfd)->e_ident[EI_CLASS] == ELFCLASS64))
	{
	  /* Right now GAS only outputs the address as a four-byte sequence.
	     This means that we should not bother with this method on 64-bit
	     targets (until that is fixed).  */

	  priv = obstack_alloc (& sec->objfile->psymbol_obstack,
				sizeof (struct mips_objfile_private));
	  priv->size = 0;
	  sec->objfile->obj_private = priv;
	}
      else if (priv == NULL)
	{
	  asection *bfdsec;

	  priv = obstack_alloc (& sec->objfile->psymbol_obstack,
				sizeof (struct mips_objfile_private));

	  bfdsec = bfd_get_section_by_name (sec->objfile->obfd, ".pdr");
	  if (bfdsec != NULL)
	    {
	      priv->size = bfd_section_size (sec->objfile->obfd, bfdsec);
	      priv->contents = obstack_alloc (& sec->objfile->psymbol_obstack,
					      priv->size);
	      bfd_get_section_contents (sec->objfile->obfd, bfdsec,
					priv->contents, 0, priv->size);

	      /* In general, the .pdr section is sorted.  However, in the
		 presence of multiple code sections (and other corner cases)
		 it can become unsorted.  Sort it so that we can use a faster
		 binary search.  */
	      qsort (priv->contents, priv->size / 32, 32, compare_pdr_entries);
	    }
	  else
	    priv->size = 0;

	  sec->objfile->obj_private = priv;
	}
      the_bfd = NULL;

      if (priv->size != 0)
	{
	  int low, mid, high;
	  char *ptr;

	  low = 0;
	  high = priv->size / 32;

	  do
	    {
	      CORE_ADDR pdr_pc;

	      mid = (low + high) / 2;

	      ptr = priv->contents + mid * 32;
	      pdr_pc = bfd_get_signed_32 (sec->objfile->obfd, ptr);
	      pdr_pc += ANOFFSET (sec->objfile->section_offsets,
				  SECT_OFF_TEXT (sec->objfile));
	      if (pdr_pc == startaddr)
		break;
	      if (pdr_pc > startaddr)
		high = mid;
	      else
		low = mid + 1;
	    }
	  while (low != high);

	  if (low != high)
	    {
	      struct symbol *sym = find_pc_function (pc);

	      /* Fill in what we need of the proc_desc.  */
	      proc_desc = (mips_extra_func_info_t)
		obstack_alloc (&sec->objfile->psymbol_obstack,
			       sizeof (struct mips_extra_func_info));
	      PROC_LOW_ADDR (proc_desc) = startaddr;

	      /* Only used for dummy frames.  */
	      PROC_HIGH_ADDR (proc_desc) = 0;

	      PROC_FRAME_OFFSET (proc_desc)
		= bfd_get_32 (sec->objfile->obfd, ptr + 20);
	      PROC_FRAME_REG (proc_desc) = bfd_get_32 (sec->objfile->obfd,
						       ptr + 24);
	      PROC_FRAME_ADJUST (proc_desc) = 0;
	      PROC_REG_MASK (proc_desc) = bfd_get_32 (sec->objfile->obfd,
						      ptr + 4);
	      PROC_FREG_MASK (proc_desc) = bfd_get_32 (sec->objfile->obfd,
						       ptr + 12);
	      PROC_REG_OFFSET (proc_desc) = bfd_get_32 (sec->objfile->obfd,
							ptr + 8);
	      PROC_FREG_OFFSET (proc_desc)
		= bfd_get_32 (sec->objfile->obfd, ptr + 16);
	      PROC_PC_REG (proc_desc) = bfd_get_32 (sec->objfile->obfd,
						    ptr + 28);
	      proc_desc->pdr.isym = (long) sym;

	      return proc_desc;
	    }
	}
    }

  if (b == NULL)
    return NULL;

  if (startaddr > BLOCK_START (b))
    {
      /* This is the "pathological" case referred to in a comment in
	 print_frame_info.  It might be better to move this check into
	 symbol reading.  */
      return NULL;
a1958 2
  sym = lookup_symbol (MIPS_EFI_SYMBOL_NAME, b, LABEL_NAMESPACE, 0, NULL);

d3570 4
a3573 1
  gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_SINGLE;
d3581 4
a3584 1
  gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_DOUBLE;
d3592 4
a3595 1
  gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_NONE;
a4128 39
static void
mips_find_abi_section (bfd *abfd, asection *sect, void *obj)
{
  enum mips_abi *abip = (enum mips_abi *) obj;
  const char *name = bfd_get_section_name (abfd, sect);

  if (*abip != MIPS_ABI_UNKNOWN)
    return;

  if (strncmp (name, ".mdebug.", 8) != 0)
    return;

  if (strcmp (name, ".mdebug.abi32") == 0)
    *abip = MIPS_ABI_O32;
  else if (strcmp (name, ".mdebug.abiN32") == 0)
    *abip = MIPS_ABI_N32;
  else if (strcmp (name, ".mdebug.abiO64") == 0)
    *abip = MIPS_ABI_O64;
  else if (strcmp (name, ".mdebug.eabi32") == 0)
    *abip = MIPS_ABI_EABI32;
  else if (strcmp (name, ".mdebug.eabi64") == 0)
    *abip = MIPS_ABI_EABI64;
  else
    warning ("unsupported ABI %s.", name + 8);
}

static enum mips_abi
global_mips_abi (void)
{
  int i;

  for (i = 0; mips_abi_strings[i] != NULL; i++)
    if (mips_abi_strings[i] == mips_abi_string)
      return (enum mips_abi) i;

  internal_error (__FILE__, __LINE__,
		  "unknown ABI string");
}

d4138 1
a4138 1
  enum mips_abi mips_abi, found_abi, wanted_abi;
a4182 9
  /* GCC creates a pseudo-section whose name describes the ABI.  */
  if (mips_abi == MIPS_ABI_UNKNOWN && info.abfd != NULL)
    bfd_map_over_sections (info.abfd, mips_find_abi_section, &mips_abi);

  /* If we have no bfd, then mips_abi will still be MIPS_ABI_UNKNOWN.
     Use the ABI from the last architecture if there is one.  */
  if (info.abfd == NULL && arches != NULL)
    mips_abi = gdbarch_tdep (arches->gdbarch)->found_abi;

a4202 1

a4207 10
  if (mips_abi == MIPS_ABI_UNKNOWN)
    mips_abi = MIPS_ABI_O32;

  /* Now that we have found what the ABI for this binary would be,
     check whether the user is overriding it.  */
  found_abi = mips_abi;
  wanted_abi = global_mips_abi ();
  if (wanted_abi != MIPS_ABI_UNKNOWN)
    mips_abi = wanted_abi;

a4215 3
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: found_mips_abi = %d\n",
			  found_abi);
a4245 1
  tdep->found_abi = found_abi;
d4251 1
d4265 1
d4279 1
d4293 1
d4307 1
d4332 13
a4344 2
      internal_error (__FILE__, __LINE__,
		      "unknown ABI in switch");
a4456 12
mips_abi_update (char *ignore_args, int from_tty, 
		 struct cmd_list_element *c)
{
  struct gdbarch_info info;

  /* Force the architecture to update, and (if it's a MIPS architecture)
     mips_gdbarch_init will take care of the rest.  */
  gdbarch_info_init (&info);
  gdbarch_update_p (info);
}

static void
d4497 1
a4497 1
			  mips_abi_strings[tdep->mips_abi]);
a4872 5
  mips_abi_string = mips_abi_strings [MIPS_ABI_UNKNOWN];
  if (MIPS_ABI_LAST + 1
      != sizeof (mips_abi_strings) / sizeof (mips_abi_strings[0]))
    internal_error (__FILE__, __LINE__, "mips_abi_strings out of sync");

a4914 15
  /* Allow the user to override the ABI. */
  c = add_set_enum_cmd
    ("abi", class_obscure, mips_abi_strings, &mips_abi_string,
     "Set the ABI used by this program.\n"
     "This option can be set to one of:\n"
     "  auto  - the default ABI associated with the current binary\n"
     "  o32\n"
     "  o64\n"
     "  n32\n"
     "  eabi32\n"
     "  eabi64",
     &setmipscmdlist);
  add_show_from_set (c, &showmipscmdlist);
  set_cmd_sfunc (c, mips_abi_update);

d4943 15
d4976 7
a4982 7
  add_setshow_auto_boolean_cmd ("mask-address", no_class, &mask_address_var, "\
Set zeroing of upper 32 bits of 64-bit addresses.\n\
Use \"on\" to enable the masking, \"off\" to disable it and \"auto\" to \n\
allow GDB to determine the correct value.\n", "\
Show zeroing of upper 32 bits of 64-bit addresses.",
				NULL, show_mask_address,
				&setmipscmdlist, &showmipscmdlist);
@


1.74.2.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a66 1
    MIPS_ABI_N64,
a78 1
  "n64",
a483 36
/* Return the GDB type object for the "standard" data type
   of data in register REG.  
   
   Note: kevinb/2002-08-01: The definition below should faithfully
   reproduce the behavior of each of the REGISTER_VIRTUAL_TYPE
   definitions found in config/mips/tm-*.h.  I'm concerned about
   the ``FCRCS_REGNUM <= reg && reg <= LAST_EMBED_REGNUM'' clause
   though.  In some cases FP_REGNUM is in this range, and I doubt
   that this code is correct for the 64-bit case.  */

static struct type *
mips_register_virtual_type (int reg)
{
  if (FP0_REGNUM <= reg && reg < FP0_REGNUM + 32)
    {
      /* Floating point registers...  */
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	return builtin_type_ieee_double_big;
      else
	return builtin_type_ieee_double_little;
    }
  else if (reg == PS_REGNUM /* CR */)
    return builtin_type_uint32;
  else if (FCRCS_REGNUM <= reg && reg <= LAST_EMBED_REGNUM)
    return builtin_type_uint32;
  else
    {
      /* Everything else...
         Return type appropriate for width of register.  */
      if (MIPS_REGSIZE == TYPE_LENGTH (builtin_type_uint64))
	return builtin_type_uint64;
      else
	return builtin_type_uint32;
    }
}

a528 1

d530 1
a530 1
mips_eabi_use_struct_convention (int gcc_p, struct type *type)
d532 4
a535 41
  return (TYPE_LENGTH (type) > 2 * MIPS_SAVED_REGSIZE);
}

int
mips_n32n64_use_struct_convention (int gcc_p, struct type *type)
{
  return 1;	/* Structures are returned by ref in extra arg0.  */
}

int
mips_o32_use_struct_convention (int gcc_p, struct type *type)
{
  return 1;	/* Structures are returned by ref in extra arg0.  */
}

/* Should call_function pass struct by reference? 
   For each architecture, structs are passed either by
   value or by reference, depending on their size.  */

static int
mips_eabi_reg_struct_has_addr (int gcc_p, struct type *type)
{
  enum type_code typecode = TYPE_CODE (check_typedef (type));
  int len = TYPE_LENGTH (check_typedef (type));

  if (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION)
    return (len > MIPS_SAVED_REGSIZE);

  return 0;
}

static int
mips_n32n64_reg_struct_has_addr (int gcc_p, struct type *type)
{
  return 0;	/* Assumption: N32/N64 never passes struct by ref.  */
}

int
mips_o32_reg_struct_has_addr (int gcc_p, struct type *type)
{
  return 0;	/* Assumption: O32/O64 never passes struct by ref.  */
d1038 1
d1186 1
a1186 1
static void
d1336 3
a1338 14
  /* Apparently, the freg_offset gives the offset to the first 64 bit
     saved.

     When the ABI specifies 64 bit saved registers, the FREG_OFFSET
     designates the first saved 64 bit register.

     When the ABI specifies 32 bit saved registers, the ``64 bit saved
     DOUBLE'' consists of two adjacent 32 bit registers, Hence
     FREG_OFFSET, designates the address of the lower register of the
     register pair.  Adjust the offset so that it designates the upper
     register of the pair -- i.e., the address of the first saved 32
     bit register.  */

  if (MIPS_SAVED_REGSIZE == 4)
a1352 17
/* Set up the 'saved_regs' array.  This is a data structure containing
   the addresses on the stack where each register has been saved, for
   each stack frame.  Registers that have not been saved will have
   zero here.  The stack pointer register is special:  rather than the
   address where the stack register has been saved, saved_regs[SP_REGNUM]
   will have the actual value of the previous frame's stack register.  */

static void
mips_frame_init_saved_regs (struct frame_info *frame)
{
  if (frame->saved_regs == NULL)
    {
      mips_find_saved_regs (frame);
    }
  frame->saved_regs[SP_REGNUM] = frame->frame;
}

d2111 1
a2111 1
	    PROC_DESC_IS_DUMMY (proc_desc) ? 0 : PROC_SYMBOL (proc_desc);
d2123 2
a2124 2
		heuristic_proc_desc (PROC_LOW_ADDR (proc_desc),
				     pc, next_frame, cur_frame);
d2157 3
a2159 4
  return ADDR_BITS_REMOVE (read_next_frame_reg (frame, 
						PROC_FRAME_REG (proc_desc)) +
			   PROC_FRAME_OFFSET (proc_desc) - 
			   PROC_FRAME_ADJUST (proc_desc));
d2206 1
a2206 1
    fci->next ? cached_proc_desc : find_proc_desc (fci->pc, fci->next, 1);
d2296 1
a2296 1
	  && MIPS_FPU_TYPE != MIPS_FPU_NONE);
a2339 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d2516 1
a2516 1
	  if (tdep->mips_abi == MIPS_ABI_O32
a4252 2
  else if (strcmp (name, ".mdebug.abiN64") == 0)
    *abip = MIPS_ABI_N64;
d4339 1
a4339 1
  /* Try the architecture for any hint of the correct ABI.  */
d4355 1
a4355 8
	  /* On Irix, ELF64 executables use the N64 ABI.  The
	     pseudo-sections which describe the ABI aren't present
	     on IRIX.  (Even for executables created by gcc.)  */
	  if (bfd_get_flavour (info.abfd) == bfd_target_elf_flavour
	      && elf_elfheader (info.abfd)->e_ident[EI_CLASS] == ELFCLASS64)
	    mips_abi = MIPS_ABI_N64;
	  else
	    mips_abi = MIPS_ABI_N32;
a4432 4
      set_gdbarch_reg_struct_has_addr (gdbarch, 
				       mips_o32_reg_struct_has_addr);
      set_gdbarch_use_struct_convention (gdbarch, 
					 mips_o32_use_struct_convention);
a4445 4
      set_gdbarch_reg_struct_has_addr (gdbarch, 
				       mips_o32_reg_struct_has_addr);
      set_gdbarch_use_struct_convention (gdbarch, 
					 mips_o32_use_struct_convention);
a4458 4
      set_gdbarch_reg_struct_has_addr (gdbarch, 
				       mips_eabi_reg_struct_has_addr);
      set_gdbarch_use_struct_convention (gdbarch, 
					 mips_eabi_use_struct_convention);
a4471 4
      set_gdbarch_reg_struct_has_addr (gdbarch, 
				       mips_eabi_reg_struct_has_addr);
      set_gdbarch_use_struct_convention (gdbarch, 
					 mips_eabi_use_struct_convention);
d4474 1
a4474 1
      tdep->mips_default_saved_regsize = 8;
d4480 1
a4480 1
      tdep->gdb_target_is_mips64 = 1;
a4495 34

      set_gdbarch_use_struct_convention (gdbarch, 
					 mips_n32n64_use_struct_convention);
      set_gdbarch_reg_struct_has_addr (gdbarch, 
				       mips_n32n64_reg_struct_has_addr);
      break;
    case MIPS_ABI_N64:
      tdep->mips_default_saved_regsize = 8;
      tdep->mips_default_stack_argsize = 8;
      tdep->mips_fp_register_double = 1;
      tdep->mips_last_arg_regnum = A0_REGNUM + 8 - 1;
      tdep->mips_last_fp_arg_regnum = FPA0_REGNUM + 8 - 1;
      tdep->mips_regs_have_home_p = 0;
      tdep->gdb_target_is_mips64 = 1;
      tdep->default_mask_address_p = 0;
      set_gdbarch_long_bit (gdbarch, 64);
      set_gdbarch_ptr_bit (gdbarch, 64);
      set_gdbarch_long_long_bit (gdbarch, 64);

      /* Set up the disassembler info, so that we get the right
	 register names from libopcodes.  */
      tm_print_insn_info.flavour = bfd_target_elf_flavour;
      tm_print_insn_info.arch = bfd_arch_mips;
      if (info.bfd_arch_info != NULL
	  && info.bfd_arch_info->arch == bfd_arch_mips
	  && info.bfd_arch_info->mach)
	tm_print_insn_info.mach = info.bfd_arch_info->mach;
      else
	tm_print_insn_info.mach = bfd_mach_mips8000;

      set_gdbarch_use_struct_convention (gdbarch, 
					 mips_n32n64_use_struct_convention);
      set_gdbarch_reg_struct_has_addr (gdbarch, 
				       mips_n32n64_reg_struct_has_addr);
a4570 1
  set_gdbarch_frame_init_saved_regs (gdbarch, mips_frame_init_saved_regs);
a4604 4
  /* There are MIPS targets which do not yet use this since they still
     define REGISTER_VIRTUAL_TYPE.  */
  set_gdbarch_register_virtual_type (gdbarch, mips_register_virtual_type);

a5095 1
     "  n64\n"
@


1.74.2.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d141 1
a176 91
/* Functions for setting and testing a bit in a minimal symbol that
   marks it as 16-bit function.  The MSB of the minimal symbol's
   "info" field is used for this purpose. This field is already
   being used to store the symbol size, so the assumption is
   that the symbol size cannot exceed 2^31.

   ELF_MAKE_MSYMBOL_SPECIAL tests whether an ELF symbol is "special",
   i.e. refers to a 16-bit function, and sets a "special" bit in a
   minimal symbol to mark it as a 16-bit function

   MSYMBOL_IS_SPECIAL   tests the "special" bit in a minimal symbol
   MSYMBOL_SIZE         returns the size of the minimal symbol, i.e.
   the "info" field with the "special" bit masked out */

static void
mips_elf_make_msymbol_special (asymbol *sym, struct minimal_symbol *msym)
{
  if (((elf_symbol_type *)(sym))->internal_elf_sym.st_other == STO_MIPS16) 
    { 
      MSYMBOL_INFO (msym) = (char *) 
	(((long) MSYMBOL_INFO (msym)) | 0x80000000); 
      SYMBOL_VALUE_ADDRESS (msym) |= 1; 
    } 
}

static int
msymbol_is_special (struct minimal_symbol *msym)
{
  return (((long) MSYMBOL_INFO (msym) & 0x80000000) != 0);
}

static long
msymbol_size (struct minimal_symbol *msym)
{
  return ((long) MSYMBOL_INFO (msym) & 0x7fffffff);
}

/* XFER a value from the big/little/left end of the register.
   Depending on the size of the value it might occupy the entire
   register or just part of it.  Make an allowance for this, aligning
   things accordingly.  */

static void
mips_xfer_register (struct regcache *regcache, int reg_num, int length,
		    enum bfd_endian endian, bfd_byte *in, const bfd_byte *out,
		    int buf_offset)
{
  bfd_byte *reg = alloca (MAX_REGISTER_RAW_SIZE);
  int reg_offset = 0;
  /* Need to transfer the left or right part of the register, based on
     the targets byte order.  */
  switch (endian)
    {
    case BFD_ENDIAN_BIG:
      reg_offset = REGISTER_RAW_SIZE (reg_num) - length;
      break;
    case BFD_ENDIAN_LITTLE:
      reg_offset = 0;
      break;
    case BFD_ENDIAN_UNKNOWN: /* Indicates no alignment.  */
      reg_offset = 0;
      break;
    default:
      internal_error (__FILE__, __LINE__, "bad switch");
    }
  if (mips_debug)
    fprintf_unfiltered (gdb_stderr,
			"xfer $%d, reg offset %d, buf offset %d, length %d, ",
			reg_num, reg_offset, buf_offset, length);
  if (mips_debug && out != NULL)
    {
      int i;
      fprintf_unfiltered (gdb_stdlog, "out ");
      for (i = 0; i < length; i++)
	fprintf_unfiltered (gdb_stdlog, "%02x", out[buf_offset + i]);
    }
  if (in != NULL)
    regcache_raw_read_part (regcache, reg_num, reg_offset, length, in + buf_offset);
  if (out != NULL)
    regcache_raw_write_part (regcache, reg_num, reg_offset, length, out + buf_offset);
  if (mips_debug && in != NULL)
    {
      int i;
      fprintf_unfiltered (gdb_stdlog, "in ");
      for (i = 0; i < length; i++)
	fprintf_unfiltered (gdb_stdlog, "%02x", in[buf_offset + i]);
    }
  if (mips_debug)
    fprintf_unfiltered (gdb_stdlog, "\n");
}

d209 5
d252 1
a252 1
static int mips_set_processor_type (char *);
d288 1
a288 1
static const char *
d431 1
a431 1
static int
d448 1
a448 1
static int
d457 1
a457 1
static void
d471 1
a471 1
static void
a485 32
void
mips_register_convert_to_type (int regnum, struct type *type, char *buffer)
{
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
      && REGISTER_RAW_SIZE (regnum) == 4
      && (regnum) >= FP0_REGNUM && (regnum) < FP0_REGNUM + 32
      && TYPE_CODE(type) == TYPE_CODE_FLT
      && TYPE_LENGTH(type) == 8) 
    {
      char temp[4];
      memcpy (temp, ((char *)(buffer))+4, 4);
      memcpy (((char *)(buffer))+4, (buffer), 4);
      memcpy (((char *)(buffer)), temp, 4); 
    }
}

void
mips_register_convert_from_type (int regnum, struct type *type, char *buffer)
{
if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
    && REGISTER_RAW_SIZE (regnum) == 4
    && (regnum) >= FP0_REGNUM && (regnum) < FP0_REGNUM + 32
    && TYPE_CODE(type) == TYPE_CODE_FLT
    && TYPE_LENGTH(type) == 8) 
  {
    char temp[4];
    memcpy (temp, ((char *)(buffer))+4, 4);
    memcpy (((char *)(buffer))+4, (buffer), 4);
    memcpy (((char *)(buffer)), temp, 4);
  }
}

a521 8
/* TARGET_READ_SP -- Remove useless bits from the stack pointer.  */

static CORE_ADDR
mips_read_sp (void)
{
  return ADDR_BITS_REMOVE (read_register (SP_REGNUM));
}

d568 1
a568 1
static int
d574 1
a574 1
static int
d577 1
a577 1
  return (TYPE_LENGTH (type) > 2 * MIPS_SAVED_REGSIZE);
d580 1
a580 1
static int
d608 1
a608 1
static int
d630 1
a630 1
    return msymbol_is_special (sym);
d798 1
a798 1
static CORE_ADDR
d1237 1
a1237 1
static CORE_ADDR
d1259 1
a1259 9
   NULL).

   Note: kevinb/2002-08-09: The only caller of this function is (and
   should remain) mips_frame_init_saved_regs().  In fact,
   aside from calling mips_find_saved_regs(), mips_frame_init_saved_regs()
   does nothing more than set frame->saved_regs[SP_REGNUM].  These two
   functions should really be combined and now that there is only one
   caller, it should be straightforward.  (Watch out for multiple returns
   though.)  */
d1468 1
a1468 1
	    FRAME_INIT_SAVED_REGS (fi);
d1551 1
a1551 1
  tmp = SKIP_TRAMPOLINE_CODE (pc);
d1556 1
a1556 1
static CORE_ADDR
d2266 1
a2266 1
static mips_extra_func_info_t cached_proc_desc;
d2268 1
a2268 1
static CORE_ADDR
d2280 1
a2280 1
  if ((tmp = SKIP_TRAMPOLINE_CODE (saved_pc)) != 0)
d2295 3
a2297 5
      /* The previous frame from a sigtramp frame might be frameless
	 and have frame size zero.  */
      && !frame->signal_handler_caller
      /* Check if this is a call dummy frame.  */
      && frame->pc != CALL_DUMMY_ADDRESS ())
d2303 1
a2303 1
static void
a2344 6
	      /* Set value of previous frame's stack pointer.  Remember that
	         saved_regs[SP_REGNUM] is special in that it contains the
		 value of the stack pointer register.  The other saved_regs
		 values are addresses (in the inferior) at which a given
		 register's value may be found.  */
	      fci->saved_regs[SP_REGNUM] = fci->frame;
d2432 6
a2437 12
/* Macros to round N up or down to the next A boundary; 
   A must be a power of two.  */

#define ROUND_DOWN(n,a) ((n) & ~((a)-1))
#define ROUND_UP(n,a) (((n)+(a)-1) & ~((a)-1))

static CORE_ADDR
mips_eabi_push_arguments (int nargs,
			  struct value **args,
			  CORE_ADDR sp,
			  int struct_return,
			  CORE_ADDR struct_addr)
d2444 6
d2452 4
a2455 5
     are properly aligned.  The stack has to be at least 64-bit
     aligned even on 32-bit machines, because doubles must be 64-bit
     aligned.  For n32 and n64, stack frames need to be 128-bit
     aligned, so we round to this widest known alignment.  */

d2459 1
a2459 1
  /* Now make space on the stack for the args.  We allocate more
d2461 1
a2461 1
     passed in registers, but that's OK.  */
d2463 1
a2463 2
    len += ROUND_UP (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
		     MIPS_STACK_ARGSIZE);
d2467 2
a2468 3
    fprintf_unfiltered (gdb_stdlog, 
			"mips_eabi_push_arguments: sp=0x%s allocated %d\n",
			paddr_nz (sp), ROUND_UP (len, 16));
d2474 1
a2474 1
  /* The struct_return pointer occupies the first parameter-passing reg.  */
d2479 2
a2480 2
			    "mips_eabi_push_arguments: struct_return reg=%d 0x%s\n",
			    argreg, paddr_nz (struct_addr));
d2482 2
d2492 1
a2492 1
      char *valbuf = alloca (MAX_REGISTER_RAW_SIZE);
d2500 1
a2500 1
			    "mips_eabi_push_arguments: %d len=%d type=%d",
d2504 3
a2506 2
         reference.  */
      if (len > MIPS_SAVED_REGSIZE
d2522 2
a2523 2
         left.  Non MIPS_EABI targets also pass the FP in the integer
         registers so also round up normal registers.  */
d2542 1
a2542 1
         stack.  */
d2557 7
d2571 8
d2585 1
a2585 1
                 above to ensure that it is even register aligned.  */
d2591 1
a2591 81
	    }
	}
      else
	{
	  /* Copy the argument to general registers or the stack in
	     register-sized pieces.  Large arguments are split between
	     registers and stack.  */
	  /* Note: structs whose size is not a multiple of MIPS_REGSIZE
	     are treated specially: Irix cc passes them in registers
	     where gcc sometimes puts them on the stack.  For maximum
	     compatibility, we will put them in both places.  */
	  int odd_sized_struct = ((len > MIPS_SAVED_REGSIZE) &&
				  (len % MIPS_SAVED_REGSIZE != 0));

	  /* Note: Floating-point values that didn't fit into an FP
             register are only written to memory.  */
	  while (len > 0)
	    {
	      /* Remember if the argument was written to the stack.  */
	      int stack_used_p = 0;
	      int partial_len = 
		len < MIPS_SAVED_REGSIZE ? len : MIPS_SAVED_REGSIZE;

	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " -- partial=%d",
				    partial_len);

	      /* Write this portion of the argument to the stack.  */
	      if (argreg > MIPS_LAST_ARG_REGNUM
		  || odd_sized_struct
		  || fp_register_arg_p (typecode, arg_type))
		{
		  /* Should shorter than int integer values be
		     promoted to int before being stored? */
		  int longword_offset = 0;
		  CORE_ADDR addr;
		  stack_used_p = 1;
		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		    {
		      if (MIPS_STACK_ARGSIZE == 8 &&
			  (typecode == TYPE_CODE_INT ||
			   typecode == TYPE_CODE_PTR ||
			   typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = MIPS_STACK_ARGSIZE - len;
		      else if ((typecode == TYPE_CODE_STRUCT ||
				typecode == TYPE_CODE_UNION) &&
			       TYPE_LENGTH (arg_type) < MIPS_STACK_ARGSIZE)
			longword_offset = MIPS_STACK_ARGSIZE - len;
		    }

		  if (mips_debug)
		    {
		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=0x%s",
					  paddr_nz (stack_offset));
		      fprintf_unfiltered (gdb_stdlog, " longword_offset=0x%s",
					  paddr_nz (longword_offset));
		    }

		  addr = sp + stack_offset + longword_offset;

		  if (mips_debug)
		    {
		      int i;
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ", 
					  paddr_nz (addr));
		      for (i = 0; i < partial_len; i++)
			{
			  fprintf_unfiltered (gdb_stdlog, "%02x", 
					      val[i] & 0xff);
			}
		    }
		  write_memory (addr, val, partial_len);
		}

	      /* Note!!! This is NOT an else clause.  Odd sized
	         structs may go thru BOTH paths.  Floating point
	         arguments will not.  */
	      /* Write this portion of the argument to a general
                 purpose register.  */
	      if (argreg <= MIPS_LAST_ARG_REGNUM
		  && !fp_register_arg_p (typecode, arg_type))
d2593 4
a2596 2
		  LONGEST regval = extract_unsigned_integer (val, partial_len);

d2598 2
a2599 3
		    fprintf_filtered (gdb_stdlog, " - reg=%d val=%s",
				      argreg,
				      phex (regval, MIPS_SAVED_REGSIZE));
d2601 1
a2601 1
		  argreg++;
a2602 12

	      len -= partial_len;
	      val += partial_len;

	      /* Compute the the offset into the stack at which we
		 will copy the next parameter.

	         In the new EABI (and the NABI32), the stack_offset
	         only needs to be adjusted when it has been used.  */

	      if (stack_used_p)
		stack_offset += ROUND_UP (partial_len, MIPS_STACK_ARGSIZE);
d2604 3
a2606 95
	}
      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog, "\n");
    }

  /* Return adjusted stack pointer.  */
  return sp;
}

/* N32/N64 version of push_arguments.  */

static CORE_ADDR
mips_n32n64_push_arguments (int nargs,
			    struct value **args,
			    CORE_ADDR sp,
			    int struct_return,
			    CORE_ADDR struct_addr)
{
  int argreg;
  int float_argreg;
  int argnum;
  int len = 0;
  int stack_offset = 0;

  /* First ensure that the stack and structure return address (if any)
     are properly aligned.  The stack has to be at least 64-bit
     aligned even on 32-bit machines, because doubles must be 64-bit
     aligned.  For n32 and n64, stack frames need to be 128-bit
     aligned, so we round to this widest known alignment.  */

  sp = ROUND_DOWN (sp, 16);
  struct_addr = ROUND_DOWN (struct_addr, 16);

  /* Now make space on the stack for the args.  */
  for (argnum = 0; argnum < nargs; argnum++)
    len += ROUND_UP (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
		     MIPS_STACK_ARGSIZE);
  sp -= ROUND_UP (len, 16);

  if (mips_debug)
    fprintf_unfiltered (gdb_stdlog, 
			"mips_n32n64_push_arguments: sp=0x%s allocated %d\n",
			paddr_nz (sp), ROUND_UP (len, 16));

  /* Initialize the integer and float register pointers.  */
  argreg = A0_REGNUM;
  float_argreg = FPA0_REGNUM;

  /* The struct_return pointer occupies the first parameter-passing reg.  */
  if (struct_return)
    {
      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "mips_n32n64_push_arguments: struct_return reg=%d 0x%s\n",
			    argreg, paddr_nz (struct_addr));
      write_register (argreg++, struct_addr);
    }

  /* Now load as many as possible of the first arguments into
     registers, and push the rest onto the stack.  Loop thru args
     from first to last.  */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      char *val;
      char *valbuf = alloca (MAX_REGISTER_RAW_SIZE);
      struct value *arg = args[argnum];
      struct type *arg_type = check_typedef (VALUE_TYPE (arg));
      int len = TYPE_LENGTH (arg_type);
      enum type_code typecode = TYPE_CODE (arg_type);

      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "mips_n32n64_push_arguments: %d len=%d type=%d",
			    argnum + 1, len, (int) typecode);

      val = (char *) VALUE_CONTENTS (arg);

      if (fp_register_arg_p (typecode, arg_type)
	  && float_argreg <= MIPS_LAST_FP_ARG_REGNUM)
	{
	  /* This is a floating point value that fits entirely
	     in a single register.  */
	  /* On 32 bit ABI's the float_argreg is further adjusted
	     above to ensure that it is even register aligned.  */
	  LONGEST regval = extract_unsigned_integer (val, len);
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				float_argreg, phex (regval, len));
	  write_register (float_argreg++, regval);

	  if (mips_debug)
	    fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				argreg, phex (regval, len));
	  write_register (argreg, regval);
	  argreg += 1;
d2619 8
d2628 1
a2628 1
             register are only written to memory.  */
d2631 1
a2631 1
	      /* Rememer if the argument was written to the stack.  */
d2633 1
a2633 2
	      int partial_len = len < MIPS_SAVED_REGSIZE ? 
		len : MIPS_SAVED_REGSIZE;
d2664 4
a2667 4
		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=0x%s",
					  paddr_nz (stack_offset));
		      fprintf_unfiltered (gdb_stdlog, " longword_offset=0x%s",
					  paddr_nz (longword_offset));
d2675 1
a2675 2
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ", 
					  paddr_nz (addr));
d2678 1
a2678 2
			  fprintf_unfiltered (gdb_stdlog, "%02x", 
					      val[i] & 0xff);
d2686 1
a2686 1
	         arguments will not.  */
d2688 1
a2688 1
                 purpose register.  */
d2703 3
d2719 3
a2721 1
		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
d2734 6
d2748 7
a2754 2
	         In N32 (N64?), the stack_offset only needs to be
	         adjusted when it has been used.  */
d2756 1
a2756 1
	      if (stack_used_p)
d2768 3
a2770 601
/* O32 version of push_arguments.  */

static CORE_ADDR
mips_o32_push_arguments (int nargs,
			 struct value **args,
			 CORE_ADDR sp,
			 int struct_return,
			 CORE_ADDR struct_addr)
{
  int argreg;
  int float_argreg;
  int argnum;
  int len = 0;
  int stack_offset = 0;

  /* First ensure that the stack and structure return address (if any)
     are properly aligned.  The stack has to be at least 64-bit
     aligned even on 32-bit machines, because doubles must be 64-bit
     aligned.  For n32 and n64, stack frames need to be 128-bit
     aligned, so we round to this widest known alignment.  */

  sp = ROUND_DOWN (sp, 16);
  struct_addr = ROUND_DOWN (struct_addr, 16);

  /* Now make space on the stack for the args.  */
  for (argnum = 0; argnum < nargs; argnum++)
    len += ROUND_UP (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
		     MIPS_STACK_ARGSIZE);
  sp -= ROUND_UP (len, 16);

  if (mips_debug)
    fprintf_unfiltered (gdb_stdlog, 
			"mips_o32_push_arguments: sp=0x%s allocated %d\n",
			paddr_nz (sp), ROUND_UP (len, 16));

  /* Initialize the integer and float register pointers.  */
  argreg = A0_REGNUM;
  float_argreg = FPA0_REGNUM;

  /* The struct_return pointer occupies the first parameter-passing reg.  */
  if (struct_return)
    {
      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "mips_o32_push_arguments: struct_return reg=%d 0x%s\n",
			    argreg, paddr_nz (struct_addr));
      write_register (argreg++, struct_addr);
      stack_offset += MIPS_STACK_ARGSIZE;
    }

  /* Now load as many as possible of the first arguments into
     registers, and push the rest onto the stack.  Loop thru args
     from first to last.  */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      char *val;
      char *valbuf = alloca (MAX_REGISTER_RAW_SIZE);
      struct value *arg = args[argnum];
      struct type *arg_type = check_typedef (VALUE_TYPE (arg));
      int len = TYPE_LENGTH (arg_type);
      enum type_code typecode = TYPE_CODE (arg_type);

      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "mips_o32_push_arguments: %d len=%d type=%d",
			    argnum + 1, len, (int) typecode);

      val = (char *) VALUE_CONTENTS (arg);

      /* 32-bit ABIs always start floating point arguments in an
         even-numbered floating point register.  Round the FP register
         up before the check to see if there are any FP registers
         left.  O32/O64 targets also pass the FP in the integer
         registers so also round up normal registers.  */
      if (!FP_REGISTER_DOUBLE
	  && fp_register_arg_p (typecode, arg_type))
	{
	  if ((float_argreg & 1))
	    float_argreg++;
	}

      /* Floating point arguments passed in registers have to be
         treated specially.  On 32-bit architectures, doubles
         are passed in register pairs; the even register gets
         the low word, and the odd register gets the high word.
         On O32/O64, the first two floating point arguments are
         also copied to general registers, because MIPS16 functions
         don't use float registers for arguments.  This duplication of
         arguments in general registers can't hurt non-MIPS16 functions
         because those registers are normally skipped.  */

      if (fp_register_arg_p (typecode, arg_type)
	  && float_argreg <= MIPS_LAST_FP_ARG_REGNUM)
	{
	  if (!FP_REGISTER_DOUBLE && len == 8)
	    {
	      int low_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 4 : 0;
	      unsigned long regval;

	      /* Write the low word of the double to the even register(s).  */
	      regval = extract_unsigned_integer (val + low_offset, 4);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg, phex (regval, 4));
	      write_register (float_argreg++, regval);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				    argreg, phex (regval, 4));
	      write_register (argreg++, regval);

	      /* Write the high word of the double to the odd register(s).  */
	      regval = extract_unsigned_integer (val + 4 - low_offset, 4);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg, phex (regval, 4));
	      write_register (float_argreg++, regval);

	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				    argreg, phex (regval, 4));
	      write_register (argreg++, regval);
	    }
	  else
	    {
	      /* This is a floating point value that fits entirely
	         in a single register.  */
	      /* On 32 bit ABI's the float_argreg is further adjusted
                 above to ensure that it is even register aligned.  */
	      LONGEST regval = extract_unsigned_integer (val, len);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg, phex (regval, len));
	      write_register (float_argreg++, regval);
	      /* CAGNEY: 32 bit MIPS ABI's always reserve two FP
		 registers for each argument.  The below is (my
		 guess) to ensure that the corresponding integer
		 register has reserved the same space.  */
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				    argreg, phex (regval, len));
	      write_register (argreg, regval);
	      argreg += FP_REGISTER_DOUBLE ? 1 : 2;
	    }
	  /* Reserve space for the FP register.  */
	  stack_offset += ROUND_UP (len, MIPS_STACK_ARGSIZE);
	}
      else
	{
	  /* Copy the argument to general registers or the stack in
	     register-sized pieces.  Large arguments are split between
	     registers and stack.  */
	  /* Note: structs whose size is not a multiple of MIPS_REGSIZE
	     are treated specially: Irix cc passes them in registers
	     where gcc sometimes puts them on the stack.  For maximum
	     compatibility, we will put them in both places.  */
	  int odd_sized_struct = ((len > MIPS_SAVED_REGSIZE) &&
				  (len % MIPS_SAVED_REGSIZE != 0));
	  /* Structures should be aligned to eight bytes (even arg registers)
	     on MIPS_ABI_O32, if their first member has double precision.  */
	  if (MIPS_SAVED_REGSIZE < 8
	      && mips_type_needs_double_align (arg_type))
	    {
	      if ((argreg & 1))
	        argreg++;
	    }
	  /* Note: Floating-point values that didn't fit into an FP
             register are only written to memory.  */
	  while (len > 0)
	    {
	      /* Remember if the argument was written to the stack.  */
	      int stack_used_p = 0;
	      int partial_len = 
		len < MIPS_SAVED_REGSIZE ? len : MIPS_SAVED_REGSIZE;

	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " -- partial=%d",
				    partial_len);

	      /* Write this portion of the argument to the stack.  */
	      if (argreg > MIPS_LAST_ARG_REGNUM
		  || odd_sized_struct
		  || fp_register_arg_p (typecode, arg_type))
		{
		  /* Should shorter than int integer values be
		     promoted to int before being stored? */
		  int longword_offset = 0;
		  CORE_ADDR addr;
		  stack_used_p = 1;
		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		    {
		      if (MIPS_STACK_ARGSIZE == 8 &&
			  (typecode == TYPE_CODE_INT ||
			   typecode == TYPE_CODE_PTR ||
			   typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = MIPS_STACK_ARGSIZE - len;
		    }

		  if (mips_debug)
		    {
		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=0x%s",
					  paddr_nz (stack_offset));
		      fprintf_unfiltered (gdb_stdlog, " longword_offset=0x%s",
					  paddr_nz (longword_offset));
		    }

		  addr = sp + stack_offset + longword_offset;

		  if (mips_debug)
		    {
		      int i;
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ", 
					  paddr_nz (addr));
		      for (i = 0; i < partial_len; i++)
			{
			  fprintf_unfiltered (gdb_stdlog, "%02x", 
					      val[i] & 0xff);
			}
		    }
		  write_memory (addr, val, partial_len);
		}

	      /* Note!!! This is NOT an else clause.  Odd sized
	         structs may go thru BOTH paths.  Floating point
	         arguments will not.  */
	      /* Write this portion of the argument to a general
                 purpose register.  */
	      if (argreg <= MIPS_LAST_ARG_REGNUM
		  && !fp_register_arg_p (typecode, arg_type))
		{
		  LONGEST regval = extract_signed_integer (val, partial_len);
		  /* Value may need to be sign extended, because 
		     MIPS_REGSIZE != MIPS_SAVED_REGSIZE.  */

		  /* A non-floating-point argument being passed in a
		     general register.  If a struct or union, and if
		     the remaining length is smaller than the register
		     size, we have to adjust the register value on
		     big endian targets.

		     It does not seem to be necessary to do the
		     same for integral types.

		     Also don't do this adjustment on O64 binaries.

		     cagney/2001-07-23: gdb/179: Also, GCC, when
		     outputting LE O32 with sizeof (struct) <
		     MIPS_SAVED_REGSIZE, generates a left shift as
		     part of storing the argument in a register a
		     register (the left shift isn't generated when
		     sizeof (struct) >= MIPS_SAVED_REGSIZE).  Since it
		     is quite possible that this is GCC contradicting
		     the LE/O32 ABI, GDB has not been adjusted to
		     accommodate this.  Either someone needs to
		     demonstrate that the LE/O32 ABI specifies such a
		     left shift OR this new ABI gets identified as
		     such and GDB gets tweaked accordingly.  */

		  if (MIPS_SAVED_REGSIZE < 8
		      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
		      && partial_len < MIPS_SAVED_REGSIZE
		      && (typecode == TYPE_CODE_STRUCT ||
			  typecode == TYPE_CODE_UNION))
		    regval <<= ((MIPS_SAVED_REGSIZE - partial_len) *
				TARGET_CHAR_BIT);

		  if (mips_debug)
		    fprintf_filtered (gdb_stdlog, " - reg=%d val=%s",
				      argreg,
				      phex (regval, MIPS_SAVED_REGSIZE));
		  write_register (argreg, regval);
		  argreg++;

		  /* Prevent subsequent floating point arguments from
		     being passed in floating point registers.  */
		  float_argreg = MIPS_LAST_FP_ARG_REGNUM + 1;
		}

	      len -= partial_len;
	      val += partial_len;

	      /* Compute the the offset into the stack at which we
		 will copy the next parameter.

		 In older ABIs, the caller reserved space for
		 registers that contained arguments.  This was loosely
		 refered to as their "home".  Consequently, space is
		 always allocated.  */

	      stack_offset += ROUND_UP (partial_len, MIPS_STACK_ARGSIZE);
	    }
	}
      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog, "\n");
    }

  /* Return adjusted stack pointer.  */
  return sp;
}

/* O64 version of push_arguments.  */

static CORE_ADDR
mips_o64_push_arguments (int nargs,
			 struct value **args,
			 CORE_ADDR sp,
			 int struct_return,
			 CORE_ADDR struct_addr)
{
  int argreg;
  int float_argreg;
  int argnum;
  int len = 0;
  int stack_offset = 0;

  /* First ensure that the stack and structure return address (if any)
     are properly aligned.  The stack has to be at least 64-bit
     aligned even on 32-bit machines, because doubles must be 64-bit
     aligned.  For n32 and n64, stack frames need to be 128-bit
     aligned, so we round to this widest known alignment.  */

  sp = ROUND_DOWN (sp, 16);
  struct_addr = ROUND_DOWN (struct_addr, 16);

  /* Now make space on the stack for the args.  */
  for (argnum = 0; argnum < nargs; argnum++)
    len += ROUND_UP (TYPE_LENGTH (VALUE_TYPE (args[argnum])), 
		     MIPS_STACK_ARGSIZE);
  sp -= ROUND_UP (len, 16);

  if (mips_debug)
    fprintf_unfiltered (gdb_stdlog, 
			"mips_o64_push_arguments: sp=0x%s allocated %d\n",
			paddr_nz (sp), ROUND_UP (len, 16));

  /* Initialize the integer and float register pointers.  */
  argreg = A0_REGNUM;
  float_argreg = FPA0_REGNUM;

  /* The struct_return pointer occupies the first parameter-passing reg.  */
  if (struct_return)
    {
      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "mips_o64_push_arguments: struct_return reg=%d 0x%s\n",
			    argreg, paddr_nz (struct_addr));
      write_register (argreg++, struct_addr);
      stack_offset += MIPS_STACK_ARGSIZE;
    }

  /* Now load as many as possible of the first arguments into
     registers, and push the rest onto the stack.  Loop thru args
     from first to last.  */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      char *val;
      char *valbuf = alloca (MAX_REGISTER_RAW_SIZE);
      struct value *arg = args[argnum];
      struct type *arg_type = check_typedef (VALUE_TYPE (arg));
      int len = TYPE_LENGTH (arg_type);
      enum type_code typecode = TYPE_CODE (arg_type);

      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "mips_o64_push_arguments: %d len=%d type=%d",
			    argnum + 1, len, (int) typecode);

      val = (char *) VALUE_CONTENTS (arg);

      /* 32-bit ABIs always start floating point arguments in an
         even-numbered floating point register.  Round the FP register
         up before the check to see if there are any FP registers
         left.  O32/O64 targets also pass the FP in the integer
         registers so also round up normal registers.  */
      if (!FP_REGISTER_DOUBLE
	  && fp_register_arg_p (typecode, arg_type))
	{
	  if ((float_argreg & 1))
	    float_argreg++;
	}

      /* Floating point arguments passed in registers have to be
         treated specially.  On 32-bit architectures, doubles
         are passed in register pairs; the even register gets
         the low word, and the odd register gets the high word.
         On O32/O64, the first two floating point arguments are
         also copied to general registers, because MIPS16 functions
         don't use float registers for arguments.  This duplication of
         arguments in general registers can't hurt non-MIPS16 functions
         because those registers are normally skipped.  */

      if (fp_register_arg_p (typecode, arg_type)
	  && float_argreg <= MIPS_LAST_FP_ARG_REGNUM)
	{
	  if (!FP_REGISTER_DOUBLE && len == 8)
	    {
	      int low_offset = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? 4 : 0;
	      unsigned long regval;

	      /* Write the low word of the double to the even register(s).  */
	      regval = extract_unsigned_integer (val + low_offset, 4);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg, phex (regval, 4));
	      write_register (float_argreg++, regval);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				    argreg, phex (regval, 4));
	      write_register (argreg++, regval);

	      /* Write the high word of the double to the odd register(s).  */
	      regval = extract_unsigned_integer (val + 4 - low_offset, 4);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg, phex (regval, 4));
	      write_register (float_argreg++, regval);

	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				    argreg, phex (regval, 4));
	      write_register (argreg++, regval);
	    }
	  else
	    {
	      /* This is a floating point value that fits entirely
	         in a single register.  */
	      /* On 32 bit ABI's the float_argreg is further adjusted
                 above to ensure that it is even register aligned.  */
	      LONGEST regval = extract_unsigned_integer (val, len);
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - fpreg=%d val=%s",
				    float_argreg, phex (regval, len));
	      write_register (float_argreg++, regval);
	      /* CAGNEY: 32 bit MIPS ABI's always reserve two FP
		 registers for each argument.  The below is (my
		 guess) to ensure that the corresponding integer
		 register has reserved the same space.  */
	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " - reg=%d val=%s",
				    argreg, phex (regval, len));
	      write_register (argreg, regval);
	      argreg += FP_REGISTER_DOUBLE ? 1 : 2;
	    }
	  /* Reserve space for the FP register.  */
	  stack_offset += ROUND_UP (len, MIPS_STACK_ARGSIZE);
	}
      else
	{
	  /* Copy the argument to general registers or the stack in
	     register-sized pieces.  Large arguments are split between
	     registers and stack.  */
	  /* Note: structs whose size is not a multiple of MIPS_REGSIZE
	     are treated specially: Irix cc passes them in registers
	     where gcc sometimes puts them on the stack.  For maximum
	     compatibility, we will put them in both places.  */
	  int odd_sized_struct = ((len > MIPS_SAVED_REGSIZE) &&
				  (len % MIPS_SAVED_REGSIZE != 0));
	  /* Structures should be aligned to eight bytes (even arg registers)
	     on MIPS_ABI_O32, if their first member has double precision.  */
	  if (MIPS_SAVED_REGSIZE < 8
	      && mips_type_needs_double_align (arg_type))
	    {
	      if ((argreg & 1))
	        argreg++;
	    }
	  /* Note: Floating-point values that didn't fit into an FP
             register are only written to memory.  */
	  while (len > 0)
	    {
	      /* Remember if the argument was written to the stack.  */
	      int stack_used_p = 0;
	      int partial_len = 
		len < MIPS_SAVED_REGSIZE ? len : MIPS_SAVED_REGSIZE;

	      if (mips_debug)
		fprintf_unfiltered (gdb_stdlog, " -- partial=%d",
				    partial_len);

	      /* Write this portion of the argument to the stack.  */
	      if (argreg > MIPS_LAST_ARG_REGNUM
		  || odd_sized_struct
		  || fp_register_arg_p (typecode, arg_type))
		{
		  /* Should shorter than int integer values be
		     promoted to int before being stored? */
		  int longword_offset = 0;
		  CORE_ADDR addr;
		  stack_used_p = 1;
		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		    {
		      if (MIPS_STACK_ARGSIZE == 8 &&
			  (typecode == TYPE_CODE_INT ||
			   typecode == TYPE_CODE_PTR ||
			   typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = MIPS_STACK_ARGSIZE - len;
		    }

		  if (mips_debug)
		    {
		      fprintf_unfiltered (gdb_stdlog, " - stack_offset=0x%s",
					  paddr_nz (stack_offset));
		      fprintf_unfiltered (gdb_stdlog, " longword_offset=0x%s",
					  paddr_nz (longword_offset));
		    }

		  addr = sp + stack_offset + longword_offset;

		  if (mips_debug)
		    {
		      int i;
		      fprintf_unfiltered (gdb_stdlog, " @@0x%s ", 
					  paddr_nz (addr));
		      for (i = 0; i < partial_len; i++)
			{
			  fprintf_unfiltered (gdb_stdlog, "%02x", 
					      val[i] & 0xff);
			}
		    }
		  write_memory (addr, val, partial_len);
		}

	      /* Note!!! This is NOT an else clause.  Odd sized
	         structs may go thru BOTH paths.  Floating point
	         arguments will not.  */
	      /* Write this portion of the argument to a general
                 purpose register.  */
	      if (argreg <= MIPS_LAST_ARG_REGNUM
		  && !fp_register_arg_p (typecode, arg_type))
		{
		  LONGEST regval = extract_signed_integer (val, partial_len);
		  /* Value may need to be sign extended, because 
		     MIPS_REGSIZE != MIPS_SAVED_REGSIZE.  */

		  /* A non-floating-point argument being passed in a
		     general register.  If a struct or union, and if
		     the remaining length is smaller than the register
		     size, we have to adjust the register value on
		     big endian targets.

		     It does not seem to be necessary to do the
		     same for integral types.

		     Also don't do this adjustment on O64 binaries.

		     cagney/2001-07-23: gdb/179: Also, GCC, when
		     outputting LE O32 with sizeof (struct) <
		     MIPS_SAVED_REGSIZE, generates a left shift as
		     part of storing the argument in a register a
		     register (the left shift isn't generated when
		     sizeof (struct) >= MIPS_SAVED_REGSIZE).  Since it
		     is quite possible that this is GCC contradicting
		     the LE/O32 ABI, GDB has not been adjusted to
		     accommodate this.  Either someone needs to
		     demonstrate that the LE/O32 ABI specifies such a
		     left shift OR this new ABI gets identified as
		     such and GDB gets tweaked accordingly.  */

		  if (MIPS_SAVED_REGSIZE < 8
		      && TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
		      && partial_len < MIPS_SAVED_REGSIZE
		      && (typecode == TYPE_CODE_STRUCT ||
			  typecode == TYPE_CODE_UNION))
		    regval <<= ((MIPS_SAVED_REGSIZE - partial_len) *
				TARGET_CHAR_BIT);

		  if (mips_debug)
		    fprintf_filtered (gdb_stdlog, " - reg=%d val=%s",
				      argreg,
				      phex (regval, MIPS_SAVED_REGSIZE));
		  write_register (argreg, regval);
		  argreg++;

		  /* Prevent subsequent floating point arguments from
		     being passed in floating point registers.  */
		  float_argreg = MIPS_LAST_FP_ARG_REGNUM + 1;
		}

	      len -= partial_len;
	      val += partial_len;

	      /* Compute the the offset into the stack at which we
		 will copy the next parameter.

		 In older ABIs, the caller reserved space for
		 registers that contained arguments.  This was loosely
		 refered to as their "home".  Consequently, space is
		 always allocated.  */

	      stack_offset += ROUND_UP (partial_len, MIPS_STACK_ARGSIZE);
	    }
	}
      if (mips_debug)
	fprintf_unfiltered (gdb_stdlog, "\n");
    }

  /* Return adjusted stack pointer.  */
  return sp;
}

static CORE_ADDR
mips_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
{
d2780 1
a2780 1
  char *buffer = alloca (MAX_REGISTER_RAW_SIZE);
d2803 1
a2803 1
static void
d2882 1
a2882 1
static void
d2893 1
a2893 1
    FRAME_INIT_SAVED_REGS (frame);
a2901 1

a2939 7
static void
mips_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs, 
		     struct value **args, struct type *type, int gcc_p)
{
  write_register(T9_REGNUM, fun);
}

d3059 1
a3059 1
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
d3076 1
a3076 1
      char *dbuffer = alloca (2 * MAX_REGISTER_RAW_SIZE);
d3211 1
a3211 1
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
d3269 1
a3269 1
static void
d3297 9
d3544 1
a3544 1
static CORE_ADDR
d3679 4
a3682 23
static void
mips_eabi_extract_return_value (struct type *valtype,
				char regbuf[REGISTER_BYTES],
				char *valbuf)
{
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memcpy (valbuf + lo.buf_offset,
	  regbuf + REGISTER_BYTE (lo.reg) + lo.reg_offset,
	  lo.len);

  if (hi.len > 0)
    memcpy (valbuf + hi.buf_offset,
	    regbuf + REGISTER_BYTE (hi.reg) + hi.reg_offset,
	    hi.len);
}

static void
mips_o64_extract_return_value (struct type *valtype,
			       char regbuf[REGISTER_BYTES],
			       char *valbuf)
d3701 2
a3702 26
static void
mips_eabi_store_return_value (struct type *valtype, char *valbuf)
{
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &hi, &lo);

  memset (raw_buffer, 0, sizeof (raw_buffer));
  memcpy (raw_buffer + lo.reg_offset, valbuf + lo.buf_offset, lo.len);
  write_register_bytes (REGISTER_BYTE (lo.reg),
			raw_buffer,
			REGISTER_RAW_SIZE (lo.reg));

  if (hi.len > 0)
    {
      memset (raw_buffer, 0, sizeof (raw_buffer));
      memcpy (raw_buffer + hi.reg_offset, valbuf + hi.buf_offset, hi.len);
      write_register_bytes (REGISTER_BYTE (hi.reg),
			    raw_buffer,
			    REGISTER_RAW_SIZE (hi.reg));
    }
}

static void
mips_o64_store_return_value (struct type *valtype, char *valbuf)
d3704 1
a3704 1
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
a3724 264
/* O32 ABI stuff.  */

static void
mips_o32_xfer_return_value (struct type *type,
			    struct regcache *regcache,
			    bfd_byte *in, const bfd_byte *out)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  if (TYPE_CODE (type) == TYPE_CODE_FLT
      && TYPE_LENGTH (type) == 4
      && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A single-precision floating-point value.  It fits in the
         least significant part of FP0.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $fp0\n");
      mips_xfer_register (regcache, FP0_REGNUM, TYPE_LENGTH (type),
			  TARGET_BYTE_ORDER, in, out, 0);
    }
  else if (TYPE_CODE (type) == TYPE_CODE_FLT
	   && TYPE_LENGTH (type) == 8
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A double-precision floating-point value.  It fits in the
         least significant part of FP0/FP1 but with byte ordering
         based on the target (???).  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $fp0/$fp1\n");
      switch (TARGET_BYTE_ORDER)
	{
	case BFD_ENDIAN_LITTLE:
	  mips_xfer_register (regcache, FP0_REGNUM + 0, 4,
			      TARGET_BYTE_ORDER, in, out, 0);
	  mips_xfer_register (regcache, FP0_REGNUM + 1, 4,
			      TARGET_BYTE_ORDER, in, out, 4);
	  break;
	case BFD_ENDIAN_BIG:
	  mips_xfer_register (regcache, FP0_REGNUM + 1, 4,
			      TARGET_BYTE_ORDER, in, out, 0);
	  mips_xfer_register (regcache, FP0_REGNUM + 0, 4,
			      TARGET_BYTE_ORDER, in, out, 4);
	  break;
	default:
	  internal_error (__FILE__, __LINE__, "bad switch");
	}
    }
#if 0
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   && TYPE_NFIELDS (type) <= 2
	   && TYPE_NFIELDS (type) >= 1
	   && ((TYPE_NFIELDS (type) == 1
		&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		    == TYPE_CODE_FLT))
	       || (TYPE_NFIELDS (type) == 2
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		       == TYPE_CODE_FLT)
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 1))
		       == TYPE_CODE_FLT)))
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A struct that contains one or two floats.  Each value is part
         in the least significant part of their floating point
         register..  */
      bfd_byte *reg = alloca (MAX_REGISTER_RAW_SIZE);
      int regnum;
      int field;
      for (field = 0, regnum = FP0_REGNUM;
	   field < TYPE_NFIELDS (type);
	   field++, regnum += 2)
	{
	  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])
			/ TARGET_CHAR_BIT);
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return float struct+%d\n", offset);
	  mips_xfer_register (regcache, regnum, TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
			      TARGET_BYTE_ORDER, in, out, offset);
	}
    }
#endif
#if 0
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (type) == TYPE_CODE_UNION)
    {
      /* A structure or union.  Extract the left justified value,
         regardless of the byte order.  I.e. DO NOT USE
         mips_xfer_lower.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += REGISTER_RAW_SIZE (regnum), regnum++)
	{
	  int xfer = REGISTER_RAW_SIZE (regnum);
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return struct+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, regnum, xfer, BFD_ENDIAN_UNKNOWN,
			      in, out, offset);
	}
    }
#endif
  else
    {
      /* A scalar extract each part but least-significant-byte
         justified.  o32 thinks registers are 4 byte, regardless of
         the ISA.  mips_stack_argsize controls this.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += mips_stack_argsize (), regnum++)
	{
	  int xfer = mips_stack_argsize ();
	  int pos = 0;
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return scalar+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, regnum, xfer, TARGET_BYTE_ORDER,
			      in, out, offset);
	}
    }
}

static void
mips_o32_extract_return_value (struct type *type,
			       struct regcache *regcache,
			       void *valbuf)
{
  mips_o32_xfer_return_value (type, regcache, valbuf, NULL); 
}

static void
mips_o32_store_return_value (struct type *type, char *valbuf)
{
  mips_o32_xfer_return_value (type, current_regcache, NULL, valbuf); 
}

/* N32/N44 ABI stuff.  */

static void
mips_n32n64_xfer_return_value (struct type *type,
			       struct regcache *regcache,
			       bfd_byte *in, const bfd_byte *out)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  if (TYPE_CODE (type) == TYPE_CODE_FLT
      && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A floating-point value belongs in the least significant part
         of FP0.  */
      if (mips_debug)
	fprintf_unfiltered (gdb_stderr, "Return float in $fp0\n");
      mips_xfer_register (regcache, FP0_REGNUM, TYPE_LENGTH (type),
			  TARGET_BYTE_ORDER, in, out, 0);
    }
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   && TYPE_NFIELDS (type) <= 2
	   && TYPE_NFIELDS (type) >= 1
	   && ((TYPE_NFIELDS (type) == 1
		&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		    == TYPE_CODE_FLT))
	       || (TYPE_NFIELDS (type) == 2
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))
		       == TYPE_CODE_FLT)
		   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 1))
		       == TYPE_CODE_FLT)))
	   && tdep->mips_fpu_type != MIPS_FPU_NONE)
    {
      /* A struct that contains one or two floats.  Each value is part
         in the least significant part of their floating point
         register..  */
      bfd_byte *reg = alloca (MAX_REGISTER_RAW_SIZE);
      int regnum;
      int field;
      for (field = 0, regnum = FP0_REGNUM;
	   field < TYPE_NFIELDS (type);
	   field++, regnum += 2)
	{
	  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])
			/ TARGET_CHAR_BIT);
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return float struct+%d\n", offset);
	  mips_xfer_register (regcache, regnum, TYPE_LENGTH (TYPE_FIELD_TYPE (type, field)),
			      TARGET_BYTE_ORDER, in, out, offset);
	}
    }
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (type) == TYPE_CODE_UNION)
    {
      /* A structure or union.  Extract the left justified value,
         regardless of the byte order.  I.e. DO NOT USE
         mips_xfer_lower.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += REGISTER_RAW_SIZE (regnum), regnum++)
	{
	  int xfer = REGISTER_RAW_SIZE (regnum);
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return struct+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, regnum, xfer, BFD_ENDIAN_UNKNOWN,
			      in, out, offset);
	}
    }
  else
    {
      /* A scalar extract each part but least-significant-byte
         justified.  */
      int offset;
      int regnum;
      for (offset = 0, regnum = V0_REGNUM;
	   offset < TYPE_LENGTH (type);
	   offset += REGISTER_RAW_SIZE (regnum), regnum++)
	{
	  int xfer = REGISTER_RAW_SIZE (regnum);
	  int pos = 0;
	  if (offset + xfer > TYPE_LENGTH (type))
	    xfer = TYPE_LENGTH (type) - offset;
	  if (mips_debug)
	    fprintf_unfiltered (gdb_stderr, "Return scalar+%d:%d in $%d\n",
				offset, xfer, regnum);
	  mips_xfer_register (regcache, regnum, xfer, TARGET_BYTE_ORDER,
			      in, out, offset);
	}
    }
}

static void
mips_n32n64_extract_return_value (struct type *type,
				  struct regcache *regcache,
				  void *valbuf)
{
  mips_n32n64_xfer_return_value (type, regcache, valbuf, NULL);
}

static void
mips_n32n64_store_return_value (struct type *type, char *valbuf)
{
  mips_n32n64_xfer_return_value (type, current_regcache, NULL, valbuf);
}

static void
mips_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  /* Nothing to do -- push_arguments does all the work.  */
}

static CORE_ADDR
mips_extract_struct_value_address (struct regcache *ignore)
{
  /* FIXME: This will only work at random.  The caller passes the
     struct_return address in V0, but it is not preserved.  It may
     still be there, or this may be a random value.  */
  return read_register (V0_REGNUM);
}

d3727 2
a3728 2
static int
mips_pc_in_sigtramp (CORE_ADDR pc, char *ignore)
d3851 1
a3851 1
static int
d3953 1
a3953 1
static const unsigned char *
d4035 1
a4035 1
static CORE_ADDR
d4118 1
a4118 1
static int
d4146 1
a4146 1
static int
d4196 1
a4196 1
static CORE_ADDR
d4414 1
a4414 1
  /* Check ELF_FLAGS to see if it specifies the ABI being used.  */
d4474 5
d4508 1
a4508 1
         using.  */
d4517 1
a4517 1
  /* Need a new architecture.  Fill in a target specific vector.  */
d4523 1
a4523 1
  /* Initially set everything according to the default ABI/ISA.  */
a4529 2
  set_gdbarch_max_register_raw_size (gdbarch, 8);
  set_gdbarch_max_register_virtual_size (gdbarch, 8);
a4532 3
  set_gdbarch_elf_make_msymbol_special (gdbarch, 
					mips_elf_make_msymbol_special);

a4535 3
      set_gdbarch_push_arguments (gdbarch, mips_o32_push_arguments);
      set_gdbarch_deprecated_store_return_value (gdbarch, mips_o32_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, mips_o32_extract_return_value);
d4541 1
a4552 3
      set_gdbarch_push_arguments (gdbarch, mips_o64_push_arguments);
      set_gdbarch_deprecated_store_return_value (gdbarch, mips_o64_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch, mips_o64_extract_return_value);
d4558 1
a4569 3
      set_gdbarch_push_arguments (gdbarch, mips_eabi_push_arguments);
      set_gdbarch_deprecated_store_return_value (gdbarch, mips_eabi_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch, mips_eabi_extract_return_value);
d4575 1
a4586 3
      set_gdbarch_push_arguments (gdbarch, mips_eabi_push_arguments);
      set_gdbarch_deprecated_store_return_value (gdbarch, mips_eabi_store_return_value);
      set_gdbarch_deprecated_extract_return_value (gdbarch, mips_eabi_extract_return_value);
d4592 1
a4603 3
      set_gdbarch_push_arguments (gdbarch, mips_n32n64_push_arguments);
      set_gdbarch_deprecated_store_return_value (gdbarch, mips_n32n64_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, mips_n32n64_extract_return_value);
d4609 1
a4632 3
      set_gdbarch_push_arguments (gdbarch, mips_n32n64_push_arguments);
      set_gdbarch_deprecated_store_return_value (gdbarch, mips_n32n64_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, mips_n32n64_extract_return_value);
d4638 1
d4672 1
a4672 1
     link with libraries compiled without "-gp32".  This is
d4682 1
a4682 1
     and not all gcc targets support that currently.  Therefore using
d4685 1
a4685 1
     as 32-bit programs by default.  */
d4712 1
a4712 4
     Further work on it is required.  */
  /* NOTE: many targets (esp. embedded) do not go thru the
     gdbarch_register_name vector at all, instead bypassing it
     by defining REGISTER_NAMES.  */
d4717 1
a4717 1
  set_gdbarch_read_sp (gdbarch, mips_read_sp);
d4720 2
a4721 2
  /* Add/remove bits from an address.  The MIPS needs be careful to
     ensure that all 32 bit addresses are sign extended to 64 bits.  */
d4729 1
a4729 1
  /* Map debug register numbers onto internal register numbers.  */
a4743 3
  set_gdbarch_push_return_address (gdbarch, mips_push_return_address);
  set_gdbarch_push_dummy_frame (gdbarch, mips_push_dummy_frame);
  set_gdbarch_pop_frame (gdbarch, mips_pop_frame);
a4747 1
  set_gdbarch_fix_call_dummy (gdbarch, mips_fix_call_dummy);
d4752 2
a4753 6
  set_gdbarch_register_convertible (gdbarch, mips_register_convertible);
  set_gdbarch_register_convert_to_virtual (gdbarch, 
					   mips_register_convert_to_virtual);
  set_gdbarch_register_convert_to_raw (gdbarch, 
				       mips_register_convert_to_raw);

a4755 1
  set_gdbarch_frame_chain (gdbarch, mips_frame_chain);
a4756 8
  set_gdbarch_frameless_function_invocation (gdbarch, 
					     generic_frameless_function_invocation_not);
  set_gdbarch_frame_saved_pc (gdbarch, mips_frame_saved_pc);
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
  set_gdbarch_frame_args_skip (gdbarch, 0);

a4769 2
  set_gdbarch_function_start_offset (gdbarch, 0);

a4772 4
  set_gdbarch_register_virtual_size (gdbarch, generic_register_size);

  set_gdbarch_do_registers_info (gdbarch, mips_do_registers_info);
  set_gdbarch_pc_in_sigtramp (gdbarch, mips_pc_in_sigtramp);
a4776 9
  set_gdbarch_store_struct_return (gdbarch, mips_store_struct_return);
  set_gdbarch_extract_struct_value_address (gdbarch, 
					    mips_extract_struct_value_address);
  
  set_gdbarch_skip_trampoline_code (gdbarch, mips_skip_stub);

  set_gdbarch_in_solib_call_trampoline (gdbarch, mips_in_call_stub);
  set_gdbarch_in_solib_return_trampoline (gdbarch, mips_in_return_stub);

d4870 3
d4902 3
d4914 3
d5012 5
@


1.74.2.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d391 1
a391 1
	"fsr",  "fir",  "",/*"fp"*/	"",
d408 1
a408 1
	"fsr",  "fir",  ""/*"fp"*/,	"",
d425 1
a425 1
	"fsr",  "fir",  ""/*"fp"*/,	"",
d1592 12
a1603 19
  int optimized;
  CORE_ADDR addr;
  int realnum;
  enum lval_type lval;
  void *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  frame_register_unwind (fi, regno, &optimized, &lval, &addr, &realnum,
			 raw_buffer);
  /* FIXME: cagney/2002-09-13: This is just soooo bad.  The MIPS
     should have a pseudo register range that correspons to the ABI's,
     rather than the ISA's, view of registers.  These registers would
     then implicitly describe their size and hence could be used
     without the below munging.  */
  if (lval == lval_memory)
    {
      if (regno < 32)
	{
	  /* Only MIPS_SAVED_REGSIZE bytes of GP registers are
	     saved. */
	  return read_memory_integer (addr, MIPS_SAVED_REGSIZE);
d1606 1
a1606 2

  return extract_signed_integer (raw_buffer, REGISTER_VIRTUAL_SIZE (regno));
d2331 1
a2331 1
  CORE_ADDR startaddr = 0;
a2578 8
/* Adjust the address downward (direction of stack growth) so that it
   is correctly aligned for a new stack frame.  */
static CORE_ADDR
mips_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  return ROUND_DOWN (addr, 16);
}

d2958 4
d3781 7
a3787 15
    if (regnum != SP_REGNUM && regnum != PC_REGNUM
	&& frame->saved_regs[regnum])
      {
	/* Floating point registers must not be sign extended, 
	   in case MIPS_SAVED_REGSIZE = 4 but sizeof (FP0_REGNUM) == 8.  */

	if (FP0_REGNUM <= regnum && regnum < FP0_REGNUM + 32)
	  write_register (regnum,
			  read_memory_unsigned_integer (frame->saved_regs[regnum],
							MIPS_SAVED_REGSIZE));
	else
	  write_register (regnum,
			  read_memory_integer (frame->saved_regs[regnum],
					       MIPS_SAVED_REGSIZE));
      }
d4909 1
a4909 1
mips_extract_struct_value_address (struct regcache *regcache)
d4914 1
a4914 4
  LONGEST val;

  regcache_cooked_read_signed (regcache, V0_REGNUM, &val);
  return val;
d5430 1
a5430 1
			 int *optimizedp,
d5434 1
a5434 1
			 enum lval_type *lvalp)
d5436 1
a5436 4
  CORE_ADDR addrx;
  enum lval_type lvalx;
  int optimizedx;
  int realnum;
d5441 20
a5460 16
  /* Make certain that all needed parameters are present.  */
  if (addrp == NULL)
    addrp = &addrx;
  if (lvalp == NULL)
    lvalp = &lvalx;
  if (optimizedp == NULL)
    optimizedp = &optimizedx;
  frame_register_unwind (get_next_frame (frame), regnum, optimizedp, lvalp,
			 addrp, &realnum, raw_buffer);
  /* FIXME: cagney/2002-09-13: This is just so bad.  The MIPS should
     have a pseudo register range that correspons to the ABI's, rather
     than the ISA's, view of registers.  These registers would then
     implicitly describe their size and hence could be used without
     the below munging.  */
  if ((*lvalp) == lval_memory)
    {
d5463 1
d5465 6
a5470 6
	    {
	      /* Only MIPS_SAVED_REGSIZE bytes of GP registers are
		 saved. */
	      LONGEST val = read_memory_integer ((*addrp), MIPS_SAVED_REGSIZE);
	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), val);
	    }
d5473 10
d5923 1
a5923 1
  set_gdbarch_read_fp (gdbarch, mips_read_sp); /* Draft FRAME base.  */
a5962 1
  set_gdbarch_frame_align (gdbarch, mips_frame_align);
@


1.74.2.5
log
@merge from mainline
@
text
@d1707 1
a1707 8
  if (USE_GENERIC_DUMMY_FRAMES
      && PC_IN_CALL_DUMMY (frame->pc, 0, 0))
    {
      LONGEST tmp;
      frame_unwind_signed_register (frame, PC_REGNUM, &tmp);
      saved_pc = tmp;
    }
  else if (proc_desc && PROC_DESC_IS_DUMMY (proc_desc))
a2423 9
  if (USE_GENERIC_DUMMY_FRAMES
      && PC_IN_CALL_DUMMY (saved_pc, 0, 0))
    {
      /* A dummy frame, uses SP not FP.  Get the old SP value.  If all
         is well, frame->frame the bottom of the current frame will
         contain that value.  */
      return frame->frame;
    }

d2439 2
a2440 4
      /* For a generic dummy frame, let get_frame_pointer() unwind a
         register value saved as part of the dummy frame call.  */
      && !(USE_GENERIC_DUMMY_FRAMES
	   && PC_IN_CALL_DUMMY (frame->pc, 0, 0)))
a2469 9
      else if (USE_GENERIC_DUMMY_FRAMES
	       && PC_IN_CALL_DUMMY (fci->pc, 0, 0))
	/* Do not ``fix'' fci->frame.  It will have the value of the
           generic dummy frame's top-of-stack (since the draft
           fci->frame is obtained by returning the unwound stack
           pointer) and that is what we want.  That way the fci->frame
           value will match the top-of-stack value that was saved as
           part of the dummy frames data.  */
	/* Do nothing.  */;
d3694 1
a3694 1
  deprecated_read_register_gen (regno, buffer);
d3786 1
a3788 8
  if (USE_GENERIC_DUMMY_FRAMES
      && PC_IN_CALL_DUMMY (frame->pc, 0, 0))
    {
      generic_pop_dummy_frame ();
      flush_cached_frames ();
      return;
    }

d5561 1
a5561 1
  else if (strcmp (name, ".mdebug.abi64") == 0)
a5958 1
#if OLD_STYLE_MIPS_DUMMY_FRAMES
a5959 3
#else
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);
#endif
a5962 1
#if OLD_STYLE_MIPS_DUMMY_FRAMES
a5963 3
#else
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
#endif
a5969 1
#if OLD_STYLE_MIPS_DUMMY_FRAMES
a5970 3
#else
  set_gdbarch_pc_in_call_dummy (gdbarch, generic_pc_in_call_dummy);
#endif
a5974 4
#if OLD_STYLE_MIPS_DUMMY_FRAMES
#else
  set_gdbarch_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
#endif
d6013 1
a6013 1
  set_gdbarch_deprecated_do_registers_info (gdbarch, mips_do_registers_info);
d6146 6
@


1.73
log
@2002-05-11  Eric Christopher  <echristo@@redhat.com>

	* mips-tdep.c (mips_double_register_type): Fix thinko.
	(mips_single_register_type): Ditto.
	* MAINTAINERS: Add self.
@
text
@d41 1
d123 1
d136 2
d4139 1
d4147 12
a4158 6
  /* Extract the elf_flags if available */
  if (info.abfd != NULL
      && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
    elf_flags = elf_elfheader (info.abfd)->e_flags;
  else
    elf_flags = 0;
d4229 2
a4230 1
      return arches->gdbarch;
d4237 1
d4449 4
d4861 4
@


1.73.2.1
log
@merge from trunk
@
text
@a40 1
#include "osabi.h"
d108 6
a121 1

a133 2

    enum gdb_osabi osabi;
d136 2
d140 1
d142 2
d145 1
d147 2
d150 1
d152 2
d155 1
d159 2
d162 3
d211 2
d214 1
d219 2
d222 3
d230 2
d233 3
d252 2
d255 1
d257 2
d260 3
a423 2
/* FIXME drow/2002-06-10: If a pointer on the host is bigger than a long,
   this will corrupt pdr.iline.  Fortunately we don't use it.  */
a1930 24
struct mips_objfile_private
{
  bfd_size_type size;
  char *contents;
};

/* Global used to communicate between non_heuristic_proc_desc and
   compare_pdr_entries within qsort ().  */
static bfd *the_bfd;

static int
compare_pdr_entries (const void *a, const void *b)
{
  CORE_ADDR lhs = bfd_get_32 (the_bfd, (bfd_byte *) a);
  CORE_ADDR rhs = bfd_get_32 (the_bfd, (bfd_byte *) b);

  if (lhs < rhs)
    return -1;
  else if (lhs == rhs)
    return 0;
  else
    return 1;
}

a1937 5
  struct obj_section *sec;
  struct mips_objfile_private *priv;

  if (PC_IN_CALL_DUMMY (pc, 0, 0))
    return NULL;
d1942 3
a1944 5

  priv = NULL;

  sec = find_pc_section (pc);
  if (sec != NULL)
d1946 7
a1952 109
      priv = (struct mips_objfile_private *) sec->objfile->obj_private;

      /* Search the ".pdr" section generated by GAS.  This includes most of
	 the information normally found in ECOFF PDRs.  */

      the_bfd = sec->objfile->obfd;
      if (priv == NULL
	  && (the_bfd->format == bfd_object
	      && bfd_get_flavour (the_bfd) == bfd_target_elf_flavour
	      && elf_elfheader (the_bfd)->e_ident[EI_CLASS] == ELFCLASS64))
	{
	  /* Right now GAS only outputs the address as a four-byte sequence.
	     This means that we should not bother with this method on 64-bit
	     targets (until that is fixed).  */

	  priv = obstack_alloc (& sec->objfile->psymbol_obstack,
				sizeof (struct mips_objfile_private));
	  priv->size = 0;
	  sec->objfile->obj_private = priv;
	}
      else if (priv == NULL)
	{
	  asection *bfdsec;

	  priv = obstack_alloc (& sec->objfile->psymbol_obstack,
				sizeof (struct mips_objfile_private));

	  bfdsec = bfd_get_section_by_name (sec->objfile->obfd, ".pdr");
	  if (bfdsec != NULL)
	    {
	      priv->size = bfd_section_size (sec->objfile->obfd, bfdsec);
	      priv->contents = obstack_alloc (& sec->objfile->psymbol_obstack,
					      priv->size);
	      bfd_get_section_contents (sec->objfile->obfd, bfdsec,
					priv->contents, 0, priv->size);

	      /* In general, the .pdr section is sorted.  However, in the
		 presence of multiple code sections (and other corner cases)
		 it can become unsorted.  Sort it so that we can use a faster
		 binary search.  */
	      qsort (priv->contents, priv->size / 32, 32, compare_pdr_entries);
	    }
	  else
	    priv->size = 0;

	  sec->objfile->obj_private = priv;
	}
      the_bfd = NULL;

      if (priv->size != 0)
	{
	  int low, mid, high;
	  char *ptr;

	  low = 0;
	  high = priv->size / 32;

	  do
	    {
	      CORE_ADDR pdr_pc;

	      mid = (low + high) / 2;

	      ptr = priv->contents + mid * 32;
	      pdr_pc = bfd_get_signed_32 (sec->objfile->obfd, ptr);
	      pdr_pc += ANOFFSET (sec->objfile->section_offsets,
				  SECT_OFF_TEXT (sec->objfile));
	      if (pdr_pc == startaddr)
		break;
	      if (pdr_pc > startaddr)
		high = mid;
	      else
		low = mid + 1;
	    }
	  while (low != high);

	  if (low != high)
	    {
	      struct symbol *sym = find_pc_function (pc);

	      /* Fill in what we need of the proc_desc.  */
	      proc_desc = (mips_extra_func_info_t)
		obstack_alloc (&sec->objfile->psymbol_obstack,
			       sizeof (struct mips_extra_func_info));
	      PROC_LOW_ADDR (proc_desc) = startaddr;

	      /* Only used for dummy frames.  */
	      PROC_HIGH_ADDR (proc_desc) = 0;

	      PROC_FRAME_OFFSET (proc_desc)
		= bfd_get_32 (sec->objfile->obfd, ptr + 20);
	      PROC_FRAME_REG (proc_desc) = bfd_get_32 (sec->objfile->obfd,
						       ptr + 24);
	      PROC_FRAME_ADJUST (proc_desc) = 0;
	      PROC_REG_MASK (proc_desc) = bfd_get_32 (sec->objfile->obfd,
						      ptr + 4);
	      PROC_FREG_MASK (proc_desc) = bfd_get_32 (sec->objfile->obfd,
						       ptr + 12);
	      PROC_REG_OFFSET (proc_desc) = bfd_get_32 (sec->objfile->obfd,
							ptr + 8);
	      PROC_FREG_OFFSET (proc_desc)
		= bfd_get_32 (sec->objfile->obfd, ptr + 16);
	      PROC_PC_REG (proc_desc) = bfd_get_32 (sec->objfile->obfd,
						    ptr + 28);
	      proc_desc->pdr.isym = (long) sym;

	      return proc_desc;
	    }
	}
a1954 13
  if (b == NULL)
    return NULL;

  if (startaddr > BLOCK_START (b))
    {
      /* This is the "pathological" case referred to in a comment in
	 print_frame_info.  It might be better to move this check into
	 symbol reading.  */
      return NULL;
    }

  sym = lookup_symbol (MIPS_EFI_SYMBOL_NAME, b, LABEL_NAMESPACE, 0, NULL);

d3566 4
a3569 1
  gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_SINGLE;
d3577 4
a3580 1
  gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_DOUBLE;
d3588 4
a3591 1
  gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_NONE;
a4124 26
static void
mips_find_abi_section (bfd *abfd, asection *sect, void *obj)
{
  enum mips_abi *abip = (enum mips_abi *) obj;
  const char *name = bfd_get_section_name (abfd, sect);

  if (*abip != MIPS_ABI_UNKNOWN)
    return;

  if (strncmp (name, ".mdebug.", 8) != 0)
    return;

  if (strcmp (name, ".mdebug.abi32") == 0)
    *abip = MIPS_ABI_O32;
  else if (strcmp (name, ".mdebug.abiN32") == 0)
    *abip = MIPS_ABI_N32;
  else if (strcmp (name, ".mdebug.abiO64") == 0)
    *abip = MIPS_ABI_O64;
  else if (strcmp (name, ".mdebug.eabi32") == 0)
    *abip = MIPS_ABI_EABI32;
  else if (strcmp (name, ".mdebug.eabi64") == 0)
    *abip = MIPS_ABI_EABI64;
  else
    warning ("unsupported ABI %s.", name + 8);
}

a4134 1
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
d4142 6
a4147 12
  elf_flags = 0;

  if (info.abfd)
    {
      /* First of all, extract the elf_flags, if available.  */
      if (bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
	elf_flags = elf_elfheader (info.abfd)->e_flags;

      /* Try to determine the OS ABI of the object we are loading.  If
	 we end up with `unknown', just leave it that way.  */
      osabi = gdbarch_lookup_osabi (info.abfd);
    }
a4171 4
  /* GCC creates a pseudo-section whose name describes the ABI.  */
  if (mips_abi == MIPS_ABI_UNKNOWN && info.abfd != NULL)
    bfd_map_over_sections (info.abfd, mips_find_abi_section, &mips_abi);

d4218 1
a4218 2
      if (gdbarch_tdep (arches->gdbarch)->osabi == osabi)
        return arches->gdbarch;
a4224 1
  tdep->osabi = osabi;
a4435 4

  /* Hook in OS ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch, osabi);

a4843 4

  fprintf_unfiltered (file,
		      "mips_dump_tdep: OS ABI = %s\n",
		      gdbarch_osabi_name (tdep->osabi));
d4921 15
@


1.73.2.2
log
@Merge with trunk.
@
text
@d64 1
a64 1
    MIPS_ABI_UNKNOWN = 0,
d69 1
a69 2
    MIPS_ABI_EABI64,
    MIPS_ABI_LAST
a71 12
static const char *mips_abi_string;

static const char *mips_abi_strings[] = {
  "auto",
  "n32",
  "o32",
  "o64",
  "eabi32",
  "eabi64",
  NULL
};

d120 1
a120 1
    enum mips_abi found_abi;
d273 1
a273 1
const char *
d472 1
a472 1
enum auto_boolean mask_address_var = AUTO_BOOLEAN_AUTO;
d479 1
a479 1
    case AUTO_BOOLEAN_TRUE:
d481 1
a481 1
    case AUTO_BOOLEAN_FALSE:
d484 1
a484 1
    case AUTO_BOOLEAN_AUTO:
d494 1
a494 1
show_mask_address (char *cmd, int from_tty, struct cmd_list_element *c)
d498 1
a498 1
    case AUTO_BOOLEAN_TRUE:
d501 1
a501 1
    case AUTO_BOOLEAN_FALSE:
d504 1
a504 1
    case AUTO_BOOLEAN_AUTO:
a4249 13
static enum mips_abi
global_mips_abi (void)
{
  int i;

  for (i = 0; mips_abi_strings[i] != NULL; i++)
    if (mips_abi_strings[i] == mips_abi_string)
      return (enum mips_abi) i;

  internal_error (__FILE__, __LINE__,
		  "unknown ABI string");
}

d4259 1
a4259 1
  enum mips_abi mips_abi, found_abi, wanted_abi;
a4307 5
  /* If we have no bfd, then mips_abi will still be MIPS_ABI_UNKNOWN.
     Use the ABI from the last architecture if there is one.  */
  if (info.abfd == NULL && arches != NULL)
    mips_abi = gdbarch_tdep (arches->gdbarch)->found_abi;

a4327 1

a4332 10
  if (mips_abi == MIPS_ABI_UNKNOWN)
    mips_abi = MIPS_ABI_O32;

  /* Now that we have found what the ABI for this binary would be,
     check whether the user is overriding it.  */
  found_abi = mips_abi;
  wanted_abi = global_mips_abi ();
  if (wanted_abi != MIPS_ABI_UNKNOWN)
    mips_abi = wanted_abi;

a4340 3
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: found_mips_abi = %d\n",
			  found_abi);
a4370 1
  tdep->found_abi = found_abi;
d4376 1
d4390 1
d4404 1
d4418 1
d4432 1
d4457 13
a4469 2
      internal_error (__FILE__, __LINE__,
		      "unknown ABI in switch");
a4581 12
mips_abi_update (char *ignore_args, int from_tty, 
		 struct cmd_list_element *c)
{
  struct gdbarch_info info;

  /* Force the architecture to update, and (if it's a MIPS architecture)
     mips_gdbarch_init will take care of the rest.  */
  gdbarch_info_init (&info);
  gdbarch_update_p (info);
}

static void
d4622 1
a4622 1
			  mips_abi_strings[tdep->mips_abi]);
a4997 5
  mips_abi_string = mips_abi_strings [MIPS_ABI_UNKNOWN];
  if (MIPS_ABI_LAST + 1
      != sizeof (mips_abi_strings) / sizeof (mips_abi_strings[0]))
    internal_error (__FILE__, __LINE__, "mips_abi_strings out of sync");

a5039 15
  /* Allow the user to override the ABI. */
  c = add_set_enum_cmd
    ("abi", class_obscure, mips_abi_strings, &mips_abi_string,
     "Set the ABI used by this program.\n"
     "This option can be set to one of:\n"
     "  auto  - the default ABI associated with the current binary\n"
     "  o32\n"
     "  o64\n"
     "  n32\n"
     "  eabi32\n"
     "  eabi64",
     &setmipscmdlist);
  add_show_from_set (c, &showmipscmdlist);
  set_cmd_sfunc (c, mips_abi_update);

d5086 7
a5092 7
  add_setshow_auto_boolean_cmd ("mask-address", no_class, &mask_address_var, "\
Set zeroing of upper 32 bits of 64-bit addresses.\n\
Use \"on\" to enable the masking, \"off\" to disable it and \"auto\" to \n\
allow GDB to determine the correct value.\n", "\
Show zeroing of upper 32 bits of 64-bit addresses.",
				NULL, show_mask_address,
				&setmipscmdlist, &showmipscmdlist);
@


1.72
log
@H2002-05-09  Daniel Jacobowitz  <drow@@mvista.com>

        * mips-tdep.c (mips_float_register_type): New function.
        (mips_double_register_type): New function.
        (mips_print_register): Use them.
        (do_fp_register_row): Likewise.
@
text
@d202 1
a202 1
  
d528 1
a528 1
    }      
d550 1
a550 1
    }      
d2141 1
a2141 1
   the frame itself is at.  
d2185 1
a2185 1
  
d2196 1
a2196 1
      int i, n;    
d2443 1
a2443 1
		    
d2468 1
a2468 1
		  /* A non-floating-point argument being passed in a 
d2600 1
a2600 1
   * 
d2747 1
a2747 1
  if (TARGET_BYTE_ORDER == BFD_BIG_ENDIAN)
d2756 1
a2756 1
  if (TARGET_BYTE_ORDER == BFD_BIG_ENDIAN)
d2822 1
a2822 1
      else      
d2897 1
a2897 1
	
d2904 1
a2904 1
/* Replacement for generic do_registers_info.  
d2928 1
a2928 1
      
d2959 1
a2959 1
      
d3700 1
a3700 1
    info->mach = pc_is_mips16 (PROC_LOW_ADDR (proc_desc)) ? 
d3703 1
a3703 1
    info->mach = pc_is_mips16 (memaddr) ? 
d4096 1
a4096 1
  else 
d4260 1
a4260 1
      tdep->default_mask_address_p = 0; 
d4342 1
a4342 1
 
a4981 1

@


1.71
log
@* arch-utils.h: Update copyright.

* gdbarch.sh (PC_IN_SIGTRAMP): Add.
* gdbarch.h, gdbarch.c: Re-generate.

* inferior.h (IN_SIGTRAMP): Delete definition.
* arch-utils.c (legacy_pc_in_sigtramp): New function.
* arch-utils.h (legacy_pc_in_sigtramp): Declare.

* mips-tdep.c (mips_init_extra_frame_info): Use PC_IN_SIGTRAMP.
(mips_dump_tdep): Do not print value of IN_SIGTRAMP.
* hppa-tdep.c (pc_in_interrupt_handler):  Use PC_IN_SIGTRAMP.
(find_proc_framesize): Ditto.
* alpha-tdep.c (alpha_osf_skip_sigtramp_frame): Ditto.
(alpha_init_extra_frame_info): Ditto.
* infrun.c (handle_inferior_event): Ditto.
(handle_inferior_event): Ditto.
(check_sigtramp2): Ditto.
* blockframe.c (create_new_frame): Ditto.
(get_prev_frame): Ditto.
* ppc-linux-tdep.c: Update comments.
* i386-linux-tdep.c: Update comments.
* breakpoint.c (bpstat_what): Update comment.

* gdbint.texinfo (Target Architecture Definition): Replace
IN_SIGTRAMP with PC_IN_SIGTRAMP.
@
text
@d292 3
d2744 18
d2855 1
a2855 1
      val_print (builtin_type_double, dbuffer, 0, 0,
d2879 1
a2879 1
	val_print (builtin_type_float, raw_buffer + offset, 0, 0,
d2882 1
a2882 1
	val_print (builtin_type_double, raw_buffer, 0, 0,
d2921 1
a2921 1
      flt1 = unpack_double (builtin_type_float, raw_buffer, &inv1);
d2924 1
a2924 1
      flt2 = unpack_double (builtin_type_float, raw_buffer, &inv2);
d2927 1
a2927 1
      doub = unpack_double (builtin_type_double, raw_buffer, &inv3);
d2955 1
a2955 1
      flt1 = unpack_double (builtin_type_double, raw_buffer, &inv1);
d2958 1
a2958 1
      doub = unpack_double (builtin_type_double, raw_buffer, &inv3);
@


1.70
log
@* gdbarch.sh (BREAKPOINT_FROM_PC): Return a const buffer.
* gdbarch.h, gdbarch.c: Regenerate.

* defs.h (breakpoint_from_pc_fn): Delete type definition.
* target.h (memory_breakpoint_from_pc): Update declaration.
* config/mcore/tm-mcore.h (mcore_breakpoint_from_p): Ditto.

* arch-utils.c (legacy_breakpoint_from_pc): Update return type.
* mcore-tdep.c (mcore_breakpoint_from_pc): Ditto.
* mem-break.c (memory_breakpoint_from_pc): Ditto.
* rs6000-tdep.c (rs6000_breakpoint_from_pc): Ditto.
* s390-tdep.c (s390_breakpoint_from_pc): Ditto
* xstormy16-tdep.c (xstormy16_breakpoint_from_pc): Ditto.
* mn10300-tdep.c (mn10300_breakpoint_from_pc): Ditto.
* mips-tdep.c (mips_breakpoint_from_pc): Ditto.
* m68hc11-tdep.c (m68hc11_breakpoint_from_pc): Ditto.
* ia64-tdep.c (ia64_breakpoint_from_pc): Ditto.
* d10v-tdep.c (d10v_breakpoint_from_pc): Ditto.
* arch-utils.c (legacy_breakpoint_from_pc): Ditto..

* mem-break.c (default_memory_insert_breakpoint): Make `bp' a
const pointer.
* monitor.c (monitor_insert_breakpoint): Ditto.
* rs6000-tdep.c (rs6000_software_single_step): Ditto for `breakp'.

* config/mcore/tm-mcore.h: Update copyright.
* mem-break.c: Ditto.
* xstormy16-tdep.c: Ditto.
@
text
@d2111 1
a2111 1
	  if (!IN_SIGTRAMP (fci->pc, name))
a4578 3
  fprintf_unfiltered (file,
		      "mips_dump_tdep: IN_SIGTRAMP # %s\n",
		      XSTRING (IN_SIGTRAMP (PC, NAME)));
@


1.69
log
@* defs.h (read_relative_register_raw_bytes): Delete declaration.
* frame.c (frame_register_read): New function.  Return non-zero on
success.
(read_relative_register_raw_bytes_for_frame): Delete.
(read_relative_register_raw_bytes): Delete.
* frame.h (frame_register_read): Declare.
* d30v-tdep.c: Update Copyright.  Use frame_register_read.
* sh-tdep.c: Ditto.
* infcmd.c (do_registers_info): Ditto.
* hppa-tdep.c: Ditto.
* rs6000-tdep.c: Ditto.
* h8500-tdep.c: Ditto.
* mips-tdep.c: Ditto.
* h8300-tdep.c: Ditto.
* z8k-tdep.c: Ditto.
@
text
@d3715 1
a3715 1
unsigned char *
@


1.68
log
@* h8500-tdep.c (h8500_write_fp): Delete function.
* dwarf2cfi.c (cfi_write_fp): Document as not used.
* mips-tdep.c (mips_gdbarch_init): Do not set write_fp.
* ia64-tdep.c (ia64_gdbarch_init): Do not set write_fp.
* m68hc11-tdep.c (m68hc11_gdbarch_init): Do not set write_fp.
* rs6000-tdep.c (rs6000_gdbarch_init): Do not set write_fp.
* s390-tdep.c (s390_gdbarch_init): Do not set write_fp.
(s390_write_fp):
* sh-tdep.c (sh_gdbarch_init): Do not set write_fp.
* x86-64-tdep.c (i386_gdbarch_init): Do not set write_fp.
* d10v-tdep.c (d10v_gdbarch_init): Do not set write_fp.
(d10v_write_fp): Delete function.
* inferior.h (write_fp, generic_target_write_fp): Delete
declarations.
* regcache.c (generic_target_write_fp): Delete function.
(write_fp): Delete function.
* gdbarch.sh (TARGET_WRITE_FP): Delete.
* gdbarch.h, gdbarch.c: Regenerate.
* config/v850/tm-v850.h (TARGET_WRITE_FP): Delete macro.
* config/sparc/tm-sp64.h (TARGET_WRITE_FP): Delete macro.
(sparc64_write_fp): Delete declaration.
* config/h8500/tm-h8500.h (TARGET_WRITE_FP): Delete macro.
(h8500_write_fp): Delete declaration.
@
text
@d3 2
a4 2
   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d2750 1
a2750 1
  if (read_relative_register_raw_bytes (regno, raw_buffer))
d2784 1
a2784 1
      if (read_relative_register_raw_bytes (regno, rare_buffer))
d2815 1
a2815 1
  if (read_relative_register_raw_bytes (regnum, raw_buffer))
d2995 1
a2995 1
      if (read_relative_register_raw_bytes (regnum, raw_buffer))
@


1.67
log
@2002-03-10  Daniel Jacobowitz  <drow@@mvista.com>
            Don Howard <dhoward@@redhat.com>

        * mips-tdep.c (ST0_FR): Define.
        (mips2_fp_compat): New function, temporarily disabled.
        (mips_read_fp_register_single): New function.
        (mips_read_fp_register_double): New function.
        (mips_print_register): Use them.
        (do_fp_register_row): Likewise.
@
text
@a4363 1
  set_gdbarch_write_fp (gdbarch, generic_target_write_fp);
@


1.66
log
@2002-02-20  Daniel Jacobowitz  <drow@@mvista.com>

        * mips-linux-nat.c: Call the operating system GNU/Linux.
        * mips-linux-tdep.c: Likewise.
        * mips-tdep.c: Likewise.
@
text
@d47 4
d181 25
d289 3
d2711 98
d2821 3
a2823 1
  /* If an even floating point register, also print as double. */
d2825 2
d2828 2
a2829 3
    if (REGISTER_RAW_SIZE (regnum) == 4)	/* this would be silly on MIPS64 or N32 (Irix 6) */
      {
	char dbuffer[2 * MAX_REGISTER_RAW_SIZE];
d2831 1
a2831 3
	read_relative_register_raw_bytes (regnum, dbuffer);
	read_relative_register_raw_bytes (regnum + 1, dbuffer + MIPS_REGSIZE);
	REGISTER_CONVERT_TO_TYPE (regnum, builtin_type_double, dbuffer);
d2833 5
a2837 5
	printf_filtered ("(d%d: ", regnum - FP0_REGNUM);
	val_print (builtin_type_double, dbuffer, 0, 0,
		   gdb_stdout, 0, 1, 0, Val_pretty_default);
	printf_filtered ("); ");
      }
d2851 4
a2854 2
    if (FP_REGISTER_DOUBLE)
      {				/* show 8-byte floats as float AND double: */
d2889 1
a2889 5
  char *raw_buffer[2];
  char *dbl_buffer;
  /* use HI and LO to control the order of combining two flt regs */
  int HI = (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG);
  int LO = (TARGET_BYTE_ORDER != BFD_ENDIAN_BIG);
d2893 8
a2900 3
  raw_buffer[0] = (char *) alloca (REGISTER_RAW_SIZE (FP0_REGNUM));
  raw_buffer[1] = (char *) alloca (REGISTER_RAW_SIZE (FP0_REGNUM));
  dbl_buffer = (char *) alloca (2 * REGISTER_RAW_SIZE (FP0_REGNUM));
d2902 2
a2903 16
  /* Get the data in raw format.  */
  if (read_relative_register_raw_bytes (regnum, raw_buffer[HI]))
    error ("can't read register %d (%s)", regnum, REGISTER_NAME (regnum));
  if (REGISTER_RAW_SIZE (regnum) == 4)
    {
      /* 4-byte registers: we can fit two registers per row. */
      /* Also print every pair of 4-byte regs as an 8-byte double. */
      if (read_relative_register_raw_bytes (regnum + 1, raw_buffer[LO]))
	error ("can't read register %d (%s)",
	       regnum + 1, REGISTER_NAME (regnum + 1));

      /* copy the two floats into one double, and unpack both */
      memcpy (dbl_buffer, raw_buffer, 2 * REGISTER_RAW_SIZE (FP0_REGNUM));
      flt1 = unpack_double (builtin_type_float, raw_buffer[HI], &inv1);
      flt2 = unpack_double (builtin_type_float, raw_buffer[LO], &inv2);
      doub = unpack_double (builtin_type_double, dbl_buffer, &inv3);
d2905 3
d2931 8
a2938 8
    {				/* eight byte registers: print each one as float AND as double. */
      int offset = 4 * (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG);

      memcpy (dbl_buffer, raw_buffer[HI], 2 * REGISTER_RAW_SIZE (FP0_REGNUM));
      flt1 = unpack_double (builtin_type_float,
			    &raw_buffer[HI][offset], &inv1);
      doub = unpack_double (builtin_type_double, dbl_buffer, &inv3);

@


1.65
log
@* cli/cli-decode.c (do_cfunc, set_cmd_cfunc): New functions.
(do_sfunc, set_cmd_sfunc): New functions.

* command.h (struct cmd_list_element): Add field func.
* cli/cli-decode.h (struct cmd_list_element): Ditto.
* command.h (set_cmd_sfunc, set_cmd_cfunc): Declare.
* cli/cli-decode.h: Ditto.

* cli/cli-decode.c (help_cmd): Test for func not cfunc/sfunc.
(help_all, help_cmd_list): Ditto.
(find_cmd, complete_on_cmdlist): Ditto.
* top.c (execute_command): Ditto.

* cli/cli-setshow.c (do_setshow_command): Call func instead of
function.sfunc.

* infcmd.c (notice_args_read): Fix function signature.

* cli/cli-cmds.c (init_cli_cmds): Use set_cmd_sfunc.
* cli/cli-decode.c (add_set_cmd): Ditto.
* utils.c (initialize_utils): Ditto.
* maint.c (_initialize_maint_cmds): Ditto.
* infrun.c (_initialize_infrun): Ditto.
* demangle.c (_initialize_demangler): Ditto.
* remote.c (add_packet_config_cmd): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* cris-tdep.c (_initialize_cris_tdep): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* kod.c (_initialize_kod): Ditto.
* valprint.c (_initialize_valprint): Ditto.
* top.c (init_main): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
* arm-tdep.c (_initialize_arm_tdep): Ditto.
* arch-utils.c (initialize_current_architecture): Ditto.
(_initialize_gdbarch_utils): Ditto.
* alpha-tdep.c (_initialize_alpha_tdep): Ditto.

* cli/cli-decode.c (add_cmd): Use set_cmd_cfunc.
* wince.c (_initialize_inftarg): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* language.c (_initialize_language): Ditto.
* arc-tdep.c (_initialize_arc_tdep): Ditto.
@
text
@d1406 1
a1406 1
   or kernel single-step support (MIPS on Linux for example).  We find
@


1.64
log
@Eliminate IEEE_FLOAT.
@
text
@d4789 1
a4789 1
  c->function.cfunc = mips_set_processor_type_command;
d4791 1
a4791 1
  c->function.cfunc = mips_show_processor_type_command;
d4810 1
a4810 1
  c->function.sfunc = reinit_frame_cache_sfunc;
@


1.63
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@a4285 1
  set_gdbarch_ieee_float (gdbarch, 1);
@


1.62
log
@* arch-utils.c (generic_register_raw_size): New function.
* gdbarch.sh (REGISTER_RAW_SIZE): Use generic_register_raw_size as
the static default.
* gdbarch.c: Regenerate.
* arch-utils.h (generic_register_raw_size): Declare.

* config/mips/tm-mips.h (REGISTER_RAW_SIZE): Delete macro.
* mips-tdep.c (mips_register_raw_size): Make function static.
(mips_gdbarch_init): Initialize register_raw_size.
@
text
@d449 1
a449 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d464 1
a464 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d2287 1
a2287 1
	      int low_offset = TARGET_BYTE_ORDER == BIG_ENDIAN ? 4 : 0;
d2388 1
a2388 1
		  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d2460 1
a2460 1
		      && TARGET_BYTE_ORDER == BIG_ENDIAN
d2525 1
a2525 1
      offset = (TARGET_BYTE_ORDER == BIG_ENDIAN
d2722 1
a2722 1
	int offset = 4 * (TARGET_BYTE_ORDER == BIG_ENDIAN);
d2739 1
a2739 1
      if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d2759 2
a2760 2
  int HI = (TARGET_BYTE_ORDER == BIG_ENDIAN);
  int LO = (TARGET_BYTE_ORDER != BIG_ENDIAN);
d2809 1
a2809 1
      int offset = 4 * (TARGET_BYTE_ORDER == BIG_ENDIAN);
d2878 1
a2878 1
      if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d3221 3
a3223 3
	  lo->buf_offset = TARGET_BYTE_ORDER == BIG_ENDIAN ? 4 : 0;
	  hi->buf_offset = TARGET_BYTE_ORDER == BIG_ENDIAN ? 0 : 4;
	  lo->reg_offset = ((TARGET_BYTE_ORDER == BIG_ENDIAN
d3236 1
a3236 1
	  lo->reg_offset = ((TARGET_BYTE_ORDER == BIG_ENDIAN
d3255 1
a3255 1
      if (TARGET_BYTE_ORDER == BIG_ENDIAN
d3264 1
a3264 1
      else if (TARGET_BYTE_ORDER == BIG_ENDIAN
d3292 1
a3292 1
      if (TARGET_BYTE_ORDER == BIG_ENDIAN
d3566 1
a3566 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d3595 1
a3595 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
@


1.61
log
@        * mips-tdep.c (find_proc_desc): Add cur_frame argument.  Pass
        cur_frame to heuristic_proc_desc.
        (heuristic_proc_desc): Add cur_frame argument.  Do not read SP
        if cur_frame == 0.
        (after_prologue): Pass cur_frame == 0 to find_proc_desc.
        (mips_frame_chain): Pass cur_frame == 1 to find_proc_desc.
        (mips_init_extra_frame_info): Likewise.
@
text
@d413 3
a415 2
/* Convert between RAW and VIRTUAL registers.  The RAW register size
   defines the remote-gdb packet. */
d433 3
d4082 1
a4082 1
  /* Initially set everything according to the ABI. */
d4088 1
@


1.60
log
@Add INTEGER_TO_ADDRESS to hadle nasty harvard architectures that do
funnies to integer to address conversions.
@
text
@d242 1
a242 1
heuristic_proc_desc (CORE_ADDR, CORE_ADDR, struct frame_info *);
d255 1
a255 1
find_proc_desc (CORE_ADDR pc, struct frame_info *next_frame);
d564 5
d570 1
a570 1
    proc_desc = find_proc_desc (pc, NULL);
d1866 1
a1866 1
		     struct frame_info *next_frame)
d1868 6
a1873 1
  CORE_ADDR sp = read_next_frame_reg (next_frame, SP_REGNUM);
d1932 1
a1932 1
find_proc_desc (CORE_ADDR pc, struct frame_info *next_frame)
d1964 1
a1964 1
				   pc, next_frame);
d1988 1
a1988 1
	heuristic_proc_desc (startaddr, pc, next_frame);
d2020 1
a2020 1
  proc_desc = find_proc_desc (saved_pc, frame);
d2046 1
a2046 1
  fci->next ? cached_proc_desc : find_proc_desc (fci->pc, fci->next);
@


1.59
log
@Doco LE O32 sizeof(struct) < 4 problem.
@
text
@d3953 14
d4276 3
@


1.58
log
@s/value_ptr/struct value */
@
text
@d2429 14
a2442 1
		     binaries. */
@


1.57
log
@        * mips-tdep.c (mips_type_needs_double_align): New function.
        (mips_push_arguments): Align o32 structs to even argument
        registers if necessary.
@
text
@d2160 1
a2160 1
		     value_ptr *args,
d2218 1
a2218 1
      value_ptr arg = args[argnum];
@


1.56
log
@Branch prediction code cleanup
@
text
@d2129 29
d2344 8
@


1.55
log
@        * mips-tdep.c (mips_software_single_step): New function.
        * config/mips/tm-mips.h: Add prototype for
        mips_software_single_step.
@
text
@d672 3
a674 3
#define mips32_op(x) (x >> 25)
#define itype_op(x) (x >> 25)
#define itype_rs(x) ((x >> 21)& 0x1f)
d676 1
a676 1
#define itype_immediate(x) ( x & 0xffff)
d678 2
a679 2
#define jtype_op(x) (x >> 25)
#define jtype_target(x) ( x & 0x03fffff)
d681 6
a686 6
#define rtype_op(x) (x >>25)
#define rtype_rs(x) ((x>>21) & 0x1f)
#define rtype_rt(x) ((x>>16)  & 0x1f)
#define rtype_rd(x) ((x>>11) & 0x1f)
#define rtype_shamt(x) ((x>>6) & 0x1f)
#define rtype_funct(x) (x & 0x3f )
d709 1
a709 1
  if ((inst & 0xe0000000) != 0)	/* Not a special, junp or branch instruction */
d711 2
a712 1
      if ((inst >> 27) == 5)	/* BEQL BNEZ BLEZL BGTZE , bits 0101xx */
d714 1
a714 1
	  op = ((inst >> 25) & 0x03);
d717 8
a724 8
	    case 0:
	      goto equal_branch;	/* BEQL   */
	    case 1:
	      goto neq_branch;	/* BNEZ   */
	    case 2:
	      goto less_branch;	/* BLEZ   */
	    case 3:
	      goto greater_branch;	/* BGTZ */
d729 13
d749 1
a749 1
      switch (op = ((inst >> 26) & 0x07))	/* extract bits 28,27,26 */
d764 1
a764 1
	  break;		/* end special */
d767 2
a768 2
	    op = jtype_op (inst);	/* branch condition */
	    switch (jtype_op (inst))
d771 2
a772 2
	      case 2:		/* BLTXL */
	      case 16:		/* BLTZALL */
d780 1
a780 1
	      case 1:		/* GEZ */
d790 1
a790 1
		/* All of the other intructions in the REGIMM catagory */
d795 1
a795 1
	  break;		/* end REGIMM */
d801 1
a802 1
	    /* Whats this mysterious 0xf000000 adjustment ??? */
d813 1
a813 1
	case 4:		/* BEQ , BEQL */
d821 1
a821 1
	case 5:		/* BNE , BNEL */
d824 1
a824 1
	      read_signed_register (itype_rs (inst)))
d829 1
a829 1
	case 6:		/* BLEZ , BLEZL */
d837 2
a838 1
	greater_branch:	/* BGTZ BGTZL */
a843 2
	default:
	  pc += 8;
@


1.54
log
@* arch-utils.c (init_frame_pc_default): New function
* arch-utils.h (init_frame_pc_default): Declare.
* gdbarch.sh (INIT_FRAME_PC): Default to init_frame_pc_default and
not init_frame_pc_noop.
* gdbarch.h, gdbarch.c: Re-generate.
* blockframe.c (INIT_FRAME_PC): Delete macro definition.
* mips-tdep.c (mips_gdbarch_init): Set init_frame_pc to
init_frame_pc_noop.
@
text
@d1382 27
@


1.53
log
@Multi-arch INIT_FRAME_PC() and INIT_FRAME_PC_FIRST().
@
text
@d4133 1
@


1.52
log
@multi-arch ADDR_BITS_REMOVE.
@
text
@d1382 1
a1382 1
void
d4130 4
a4334 6
  fprintf_unfiltered (file,
		      "mips_dump_tdep: INIT_FRAME_PC # %s\n",
		      XSTRING (INIT_FRAME_PC (FROMLEAF, PREV)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: INIT_FRAME_PC_FIRST # %s\n",
		      XSTRING (INIT_FRAME_PC_FIRST (FROMLEAF, PREV)));
@


1.51
log
@	* config/mips/tm-irix6.h: New file.

	* config/mips/irix6.mh: New file.

	* config/mips/irix6.mt: New file.

	* config/mips/xm-irix6.h: New file.

	* config/mips/nm-irix6.h: New file.

	* mips-tdep.c (mips_gdbarch_init) <MIPS_ABI_N32>: Set up the
	disassembler info in tm_print_insn_info as appropriate for the N32
	ABI.  Force N32 ABI to be the default if the CPU is R8000 or
	R10000.

	* configure.tgt (mips*-sgi-irix6*): Map to irix6.

	* configure.host (mips*-sgi-irix6*): Ditto.
@
text
@d1343 1
a1343 1
CORE_ADDR
d4125 4
@


1.50
log
@	* mips-tdep.c (show_mipsfpu_command): Remove unused variable msg.
	(mips_set_processor_type_command): Remove unused variable j.
	(mips_breakpoint_from_pc): Declare breakpoint instruction
	sequences as unsigned char, to avoid compiler warnings.
@
text
@d3874 6
d3924 4
d3971 1
d4043 11
@


1.49
log
@* mips-tdep.c (mips_store_return_value,
mips_extract_return_value): Pass arguments to
return_value_location in the proper order.
@
text
@d2196 2
a2197 2
      /* MIPS_EABI squeeses a struct that contains a single floating
         point value into an FP register instead of pusing it onto the
a3281 1
  char *msg;
d3389 1
a3389 1
  int i, j;
d3495 2
a3496 1
	  static char mips16_big_breakpoint[] = MIPS16_BIG_BREAKPOINT;
d3503 3
a3505 3
	  static char big_breakpoint[] = BIG_BREAKPOINT;
	  static char pmon_big_breakpoint[] = PMON_BIG_BREAKPOINT;
	  static char idt_big_breakpoint[] = IDT_BIG_BREAKPOINT;
d3523 2
a3524 1
	  static char mips16_little_breakpoint[] = MIPS16_LITTLE_BREAKPOINT;
d3531 5
a3535 3
	  static char little_breakpoint[] = LITTLE_BREAKPOINT;
	  static char pmon_little_breakpoint[] = PMON_LITTLE_BREAKPOINT;
	  static char idt_little_breakpoint[] = IDT_LITTLE_BREAKPOINT;
@


1.48
log
@Phase 1 of the ptid_t changes.
@
text
@d3212 1
a3212 1
  return_value_location (valtype, &lo, &hi);
d3233 1
a3233 1
  return_value_location (valtype, &lo, &hi);
@


1.47
log
@Gag -Wuninitialized warnings.
Add -Wuninitialized to default warning list.
@
text
@d549 1
a549 1
mips_read_pc (int pid)
d551 1
a551 1
  return read_signed_register_pid (PC_REGNUM, pid);
@


1.46
log
@* mips-tdep.c (mips_gdbarch_init): Tweak indentation.
@
text
@d3295 2
d4162 1
a4162 1
	  ef_mips_arch = 0;
d4165 1
@


1.45
log
@Change SOFTWARE_SINGLE_STEP_P into SOFTWARE_SINGLE_STEP_P().
@
text
@d4001 1
a4001 1
       tdep->mips_abi_string = "eabi64";
@


1.44
log
@Update/correct copyright notices.
@
text
@d4473 2
a4474 5
		      "mips_dump_tdep: SOFTWARE_SINGLE_STEP_P = %d\n",
		      SOFTWARE_SINGLE_STEP_P);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SOFTWARE_SINGLE_STEP_P = %d\n",
		      SOFTWARE_SINGLE_STEP_P);
@


1.43
log
@Create new file regcache.h.  Update all uses.
@
text
@d3 2
a4 2
   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.42
log
@Fix printf fmt arguments.
@
text
@d40 1
@


1.41
log
@When the target h/w has 8byte registers, return 8 bytes for the raw buffer size
(from jim kingdon).
@
text
@d2680 19
a2698 6
      printf_filtered (inv1 ? " %-5s: <invalid float>" :
		       " %-5s%-17.9g", REGISTER_NAME (regnum), flt1);
      printf_filtered (inv2 ? " %-5s: <invalid float>" :
		       " %-5s%-17.9g", REGISTER_NAME (regnum + 1), flt2);
      printf_filtered (inv3 ? " dbl: <invalid double>\n" :
		       " dbl: %-24.17g\n", doub);
d2711 13
a2723 4
      printf_filtered (inv1 ? " %-5s: <invalid float>" :
		       " %-5s flt: %-17.9g", REGISTER_NAME (regnum), flt1);
      printf_filtered (inv3 ? " dbl: <invalid double>\n" :
		       " dbl: %-24.17g\n", doub);
@


1.40
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d422 5
@


1.39
log
@Replace strsave() with xstrdup().
@
text
@d480 2
a481 1
      internal_error ("mips_mask_address_p: bad switch");
d502 2
a503 1
      internal_error ("show_mask_address: bad switch");
d987 2
a988 1
      internal_error ("%s:%d: bad switch", __FILE__, __LINE__);
@


1.38
log
@2001-01-04  Michael Snyder  <msnyder@@mvstp600e.cygnus.com>

        * mips-tdep.c (mips_coerce_float_to_double): Fix typo in comment.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, Free Software Foundation, Inc.
d3334 1
a3334 1
      tmp_mips_processor_type = strsave (mips_processor_type);
d3343 1
a3343 1
      tmp_mips_processor_type = strsave (mips_processor_type);
d4613 2
a4614 2
  tmp_mips_processor_type = strsave (DEFAULT_MIPS_TYPE);
  mips_set_processor_type_command (strsave (DEFAULT_MIPS_TYPE), 0);
@


1.37
log
@Replace free() with xfree().
@
text
@d3708 1
a3708 1
/* If the current gcc for for this target does not produce correct debugging
@


1.36
log
@Multiarch STAB_REG_TO_REGNUM, ECOFF_REG_TO_REGNUM,
DWARF_REG_TO_REGNUM, SDB_REG_TO_REGNUM, DWARF2_REG_TO_REGNUM.
@
text
@d2551 1
a2551 1
      free (pi_ptr);
@


1.35
log
@* mips-tdep.c (struct upk_mips16): Delete fields ``inst'' and
``fmt''.  Make ``offset'' a CORE_ADDR.
(print_unpack): Delete.
(extended_offset): Construct and return a CORE_ADDR.
(fetch_mips_16): Return an int.  Don't assume short is 16 bits.
(unpack_mips16): Rewrite.  Add ``extension'' parameter instead of
incorrectly guessing if the instruction had an extension.
(map16): Delete array.
(mips16_op): Delete macro.
(extended_mips16_next_pc): Rewrite of old mips16_next_pc function.
When an extended instruction do a recursive call.
(mips16_next_pc): Call extended_mips16_next_pc.
(mips_next_pc): Cleanup.
@
text
@d3804 23
d4067 4
@


1.34
log
@* gdbarch.sh, hp-psymtab-read.c, hpread.c, m3-nat.c, mcore-tdep.c,
mips-tdep.c, monitor.c, regcache.c, remote-es.c, ser-unix.c,
somread.c, tracepoint.c: Fix spelling errors in comments.
* gdbarch.c: Regenerate.

* gnu-nat.c (S_exception_raise_request): Fix typos and spelling
errors in strings.
* m3-nat.c (intercept_exec_calls, mach_thread_parse_id): Likewise.
* mcore-tdep.c (mcore_analyze_prologue): Likewise.
* mips-tdep.c (mips16_next_pc, _initialize_mips_tdep): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-rdp.c (handle_swi): Likewise.
* remote-vx.c (vx_load_command): Likewise.
* sh-tdep.c (sh_do_pseudo_register): Likewise.
* sol-thread.c (td_err_string): Likewise.
* symtab.c (decode_line_2): Likewise.
-------------------------------------------------------------------
@
text
@d864 2
a865 2
/* I am heaping all the fields of the formats into one structure and then,
   only the fields which are involved in instruction extension */
d868 1
a868 3
    unsigned short inst;
    enum mips16_inst_fmts fmt;
    unsigned long offset;
d874 2
d877 2
a878 13
static void
print_unpack (char *comment,
	      struct upk_mips16 *u)
{
  printf ("%s %04x ,f(%d) off(%s) (x(%x) y(%x)\n",
	  comment, u->inst, u->fmt, paddr (u->offset), u->regx, u->regy);
}

/* The EXT-I, EXT-ri nad EXT-I8 instructions all have the same
   format for the bits which make up the immediatate extension.
 */
static unsigned long
extended_offset (unsigned long extension)
d880 1
a880 1
  unsigned long value;
d898 1
a898 1
static unsigned short
d909 3
d914 4
a917 12
  CORE_ADDR extpc;
  unsigned long extension;
  int extended;
  extpc = (pc - 4) & ~0x01;	/* Extensions are 32 bit instructions */
  /* Decrement to previous address and loose the 16bit mode flag */
  /* return if the instruction was extendable, but not actually extended */
  extended = ((mips32_op (extension) == 30) ? 1 : 0);
  if (extended)
    {
      extension = mips_fetch_instruction (extpc);
    }
  switch (upk->fmt)
d921 2
a922 2
	unsigned long value;
	if (extended)
d926 1
a926 1
	    value |= upk->inst & 0x7ff;		/* eleven bits from instruction */
d930 1
a930 1
	    value = upk->inst & 0x7ff;
d933 3
a935 1
	upk->offset = value;
d943 2
a944 2
	unsigned long value;
	if (extended)
d948 2
a949 2
	    value |= upk->inst & 0xff;	/* eleven bits from instruction */
	    upk->regx = (extension >> 8) & 0x07;	/* or i8 funct */
d958 2
a959 2
	    value = upk->inst & 0xff;	/* 8 bits */
	    upk->regx = (upk->inst >> 8) & 0x07;	/* or i8 funct */
a965 1

d967 2
a968 1
	upk->offset = value;
d974 2
a975 2
	unsigned short nexthalf;
	value = ((upk->inst & 0x1f) << 5) | ((upk->inst >> 5) & 0x1f);
d979 3
a981 1
	upk->offset = value;
d985 1
a985 2
      printf_filtered ("Decoding unimplemented instruction format type\n");
      break;
d987 3
a989 1
  /* print_unpack("UPK",upk) ; */
a992 10
#define mips16_op(x) (x >> 11)

/* This is a map of the opcodes which ae known to perform branches */
static unsigned char map16[32] =
{0, 0, 1, 1, 1, 1, 0, 0,
 0, 0, 0, 0, 1, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 1, 1, 0
};

d1000 4
a1003 6


static struct upk_mips16 upk;

CORE_ADDR
mips16_next_pc (CORE_ADDR pc)
d1005 2
a1006 7
  int op;
  t_inst inst;
  /* inst = mips_fetch_instruction(pc) ; - This doesnt always work */
  inst = fetch_mips_16 (pc);
  upk.inst = inst;
  op = mips16_op (upk.inst);
  if (map16[op])
d1008 70
a1077 6
      int reg;
      switch (op)
	{
	case 2:		/* Branch */
	  upk.fmt = itype;
	  unpack_mips16 (pc, &upk);
d1079 4
a1082 3
	    long offset;
	    offset = upk.offset;
	    if (offset & 0x800)
d1084 12
a1095 2
		offset &= 0xeff;
		offset = -offset;
d1097 1
a1097 1
	    pc += (offset << 1) + 2;
d1099 1
a1099 72
	  break;
	case 3:		/* JAL , JALX - Watch out, these are 32 bit instruction */
	  upk.fmt = jalxtype;
	  unpack_mips16 (pc, &upk);
	  pc = add_offset_16 (pc, upk.offset);
	  if ((upk.inst >> 10) & 0x01)	/* Exchange mode */
	    pc = pc & ~0x01;	/* Clear low bit, indicate 32 bit mode */
	  else
	    pc |= 0x01;
	  break;
	case 4:		/* beqz */
	  upk.fmt = ritype;
	  unpack_mips16 (pc, &upk);
	  reg = read_signed_register (upk.regx);
	  if (reg == 0)
	    pc += (upk.offset << 1) + 2;
	  else
	    pc += 2;
	  break;
	case 5:		/* bnez */
	  upk.fmt = ritype;
	  unpack_mips16 (pc, &upk);
	  reg = read_signed_register (upk.regx);
	  if (reg != 0)
	    pc += (upk.offset << 1) + 2;
	  else
	    pc += 2;
	  break;
	case 12:		/* I8 Formats btez btnez */
	  upk.fmt = i8type;
	  unpack_mips16 (pc, &upk);
	  /* upk.regx contains the opcode */
	  reg = read_signed_register (24);	/* Test register is 24 */
	  if (((upk.regx == 0) && (reg == 0))	/* BTEZ */
	      || ((upk.regx == 1) && (reg != 0)))	/* BTNEZ */
	    /* pc = add_offset_16(pc,upk.offset) ; */
	    pc += (upk.offset << 1) + 2;
	  else
	    pc += 2;
	  break;
	case 29:		/* RR Formats JR, JALR, JALR-RA */
	  upk.fmt = rrtype;
	  op = upk.inst & 0x1f;
	  if (op == 0)
	    {
	      upk.regx = (upk.inst >> 8) & 0x07;
	      upk.regy = (upk.inst >> 5) & 0x07;
	      switch (upk.regy)
		{
		case 0:
		  reg = upk.regx;
		  break;
		case 1:
		  reg = 31;
		  break;	/* Function return instruction */
		case 2:
		  reg = upk.regx;
		  break;
		default:
		  reg = 31;
		  break;	/* BOGUS Guess */
		}
	      pc = read_signed_register (reg);
	    }
	  else
	    pc += 2;
	  break;
	case 30:		/* This is an extend instruction */
	  pc += 4;		/* Dont be setting breakpoints on the second half */
	  break;
	default:
	  printf ("Filtered - next PC probably incorrect due to jump inst\n");
d1101 16
a1116 2
	  break;
	}
a1117 4
  else
    pc += 2;			/* just a good old instruction */
  /* See if we CAN actually break on the next instruction */
  /* printf("NXTm16PC %08x\n",(unsigned long)pc) ; */
d1119 8
a1126 1
}				/* mips16_next_pc */
d1128 1
a1128 1
/* The mips_next_pc function supports single_step when the remote 
d1130 3
a1132 4
   It works by decoding the current instruction and predicting where a branch
   will go. This isnt hard because all the data is available.
   The MIPS32 and MIPS16 variants are quite different
 */
a1135 3
  t_inst inst;
  /* inst = mips_fetch_instruction(pc) ; */
  /* if (pc_is_mips16) <----- This is failing */
d1140 1
a1140 1
}				/* mips_next_pc */
@


1.33
log
@
Corrected spelling errors in comments.
gdbarch.{c,sh} removed a word from a comment.
@
text
@d1120 1
a1120 1
	  pc += 4;		/* Dont be setting breakpints on the second half */
d1123 1
a1123 1
	  printf ("Filtered - next PC probably incorrrect due to jump inst\n");
d4568 1
a4568 1
	   "Select double-precision MIPS floating-point coprocessor .",
@


1.32
log
@	Approved by Andrew Cagney <ac131313@@cygnus.com>
	* mips-tdep.c (MIPS_DEFAULT_MASK_ADDRESS_P): Define using either
	the current arch or use zero.
@
text
@d1135 2
a1136 2
/* The mips_next_pc function supports single_tep when the remote target monitor or
   stub is not developed enough to so a single_step.
@


1.31
log
@
Corrected spelling errors in comments
@
text
@d227 7
d478 1
a478 1
      return gdbarch_tdep (current_gdbarch)->default_mask_address_p;
@


1.30
log
@Check arches->gdbarch and not current_gdbarch when looking for a match.
@
text
@d822 1
a822 1
   mips 16 variant, but fortunatly, there fewer instructions. We have to cope
@


1.29
log
@Protoization.
@
text
@d3887 1
a3887 1
      if (gdbarch_tdep (current_gdbarch)->elf_flags != elf_flags)
d3889 1
a3889 1
      if (gdbarch_tdep (current_gdbarch)->mips_abi != mips_abi)
@


1.28
log
@* mips-tdep.c: General cleanup.  Delete all #if 0 code.  Convert
all old style K&R function definitions to ISO-C.
(struct gdbarch_tdep): Add mips_abi_string.
(mips_gdbarch_init): Initialize.
(mips_dump_tdep): Print mips_abi_string and other values.
(mips_push_arguments): Add more detailed tracing.
@
text
@d271 1
a271 2
mips_register_name (i)
     int i;
d501 1
a501 3
mips_use_struct_convention (gcc_p, type)
     int gcc_p;
     struct type *type;
d1714 2
a1715 4
mips32_heuristic_proc_desc (start_pc, limit_pc, next_frame, sp)
     CORE_ADDR start_pc, limit_pc;
     struct frame_info *next_frame;
     CORE_ADDR sp;
@


1.27
log
@Force MIPS to sign-extend any addresses read from registers.
@
text
@d119 1
d166 1
a166 1
mips_saved_regsize ()
a228 4
#if 0
static int mips_in_lenient_prologue (CORE_ADDR, CORE_ADDR);
#endif

d259 5
a269 4
/* The list of available "set mips " and "show mips " commands */
static struct cmd_list_element *setmipscmdlist = NULL;
static struct cmd_list_element *showmipscmdlist = NULL;

d395 1
a395 2
mips_print_extra_frame_info (fi)
     struct frame_info *fi;
d412 1
a412 2
mips_register_raw_size (reg_nr)
     int reg_nr;
d421 1
a421 2
mips_register_convertible (reg_nr)
     int reg_nr;
d430 2
a431 5
mips_register_convert_to_virtual (n, virtual_type, raw_buf, virt_buf)
     int n;
     struct type *virtual_type;
     char *raw_buf;
     char *virt_buf;
d444 2
a445 5
mips_register_convert_to_raw (virtual_type, n, virt_buf, raw_buf)
     struct type *virtual_type;
     int n;
     char *virt_buf;
     char *raw_buf;
d546 2
a547 3
after_prologue (pc, proc_desc)
     CORE_ADDR pc;
     mips_extra_func_info_t proc_desc;
d584 2
a585 4
mips32_decode_reg_save (inst, gen_mask, float_mask)
     t_inst inst;
     unsigned long *gen_mask;
     unsigned long *float_mask;
d617 1
a617 3
mips16_decode_reg_save (inst, gen_mask)
     t_inst inst;
     unsigned long *gen_mask;
d639 1
a639 2
mips_fetch_instruction (addr)
     CORE_ADDR addr;
d1153 1
a1153 2
mips_find_saved_regs (fci)
     struct frame_info *fci;
d1320 1
a1320 3
read_next_frame_reg (fi, regno)
     struct frame_info *fi;
     int regno;
d1342 1
a1342 2
mips_addr_bits_remove (addr)
     CORE_ADDR addr;
d1381 1
a1381 3
mips_init_frame_pc_first (fromleaf, prev)
     int fromleaf;
     struct frame_info *prev;
d1393 1
a1393 2
mips_frame_saved_pc (frame)
     struct frame_info *frame;
d1419 1
a1419 3
set_reg_offset (regno, offset)
     int regno;
     CORE_ADDR offset;
d1430 1
a1430 2
mips_about_to_return (pc)
     CORE_ADDR pc;
d1450 1
a1450 2
heuristic_proc_start (pc)
     CORE_ADDR pc;
a1537 5
#if 0
  /* skip nops (usually 1) 0 - is this */
  while (start_pc < pc && read_memory_integer (start_pc, MIPS_INSTLEN) == 0)
    start_pc += MIPS_INSTLEN;
#endif
d1547 5
a1551 6
mips16_get_imm (prev_inst, inst, nbits, scale, is_signed)
     unsigned short prev_inst;	/* previous instruction */
     unsigned short inst;	/* current instruction */
     int nbits;			/* number of bits in imm field */
     int scale;			/* scale factor to be applied to imm */
     int is_signed;		/* is the imm field signed? */
d1580 2
a1581 4
mips16_heuristic_proc_desc (start_pc, limit_pc, next_frame, sp)
     CORE_ADDR start_pc, limit_pc;
     struct frame_info *next_frame;
     CORE_ADDR sp;
d1820 2
a1821 3
heuristic_proc_desc (start_pc, limit_pc, next_frame)
     CORE_ADDR start_pc, limit_pc;
     struct frame_info *next_frame;
d1843 1
a1843 3
non_heuristic_proc_desc (pc, addrptr)
     CORE_ADDR pc;
     CORE_ADDR *addrptr;
d1882 1
a1882 3
find_proc_desc (pc, next_frame)
     CORE_ADDR pc;
     struct frame_info *next_frame;
d1944 2
a1945 3
get_frame_pointer (frame, proc_desc)
     struct frame_info *frame;
     mips_extra_func_info_t proc_desc;
d1955 1
a1955 2
mips_frame_chain (frame)
     struct frame_info *frame;
d1990 1
a1990 3
mips_init_extra_frame_info (fromleaf, fci)
     int fromleaf;
     struct frame_info *fci;
d2064 1
a2064 3
setup_arbitrary_frame (argc, argv)
     int argc;
     CORE_ADDR *argv;
d2090 5
a2094 6
mips_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     int struct_return;
     CORE_ADDR struct_addr;
d2157 1
a2157 1
			    argnum, len, (int) typecode);
d2176 10
a2185 4
         even-numbered floating point register.   */
      if (!FP_REGISTER_DOUBLE && typecode == TYPE_CODE_FLT
	  && (float_argreg & 1))
	float_argreg++;
d2210 1
a2210 1
		fprintf_unfiltered (gdb_stdlog, " fpreg=%d val=%s",
d2216 1
a2216 1
		    fprintf_unfiltered (gdb_stdlog, " reg=%d val=%s",
d2224 1
a2224 1
		fprintf_unfiltered (gdb_stdlog, " fpreg=%d val=%s",
d2230 1
a2230 1
		    fprintf_unfiltered (gdb_stdlog, " reg=%d val=%s",
d2244 1
a2244 1
		fprintf_unfiltered (gdb_stdlog, " fpreg=%d val=%s",
d2254 1
a2254 1
		    fprintf_unfiltered (gdb_stdlog, " reg=%d val=%s",
d2283 4
d2312 1
a2312 1
		      fprintf_unfiltered (gdb_stdlog, " stack_offset=0x%lx",
d2364 1
a2364 1
		    fprintf_filtered (gdb_stdlog, " reg=%d val=%s",
d2404 1
a2404 3
mips_push_return_address (pc, sp)
     CORE_ADDR pc;
     CORE_ADDR sp;
d2439 1
a2439 1
mips_push_dummy_frame ()
d2518 1
a2518 1
mips_pop_frame ()
d2576 1
a2576 2
mips_print_register (regnum, all)
     int regnum, all;
d2650 1
a2650 2
do_fp_register_row (regnum)
     int regnum;
d2712 1
a2712 2
do_gp_register_row (regnum)
     int regnum;
d2774 1
a2774 3
mips_do_registers_info (regnum, fpregs)
     int regnum;
     int fpregs;
d2805 1
a2805 2
mips_frame_num_args (frame)
     struct frame_info *frame;
a2806 7
#if 0				/* FIXME Use or lose this! */
  struct chain_info_t *p;

  p = mips_find_cached_frame (FRAME_FP (frame));
  if (p->valid)
    return p->the_info.numargs;
#endif
d2815 1
a2815 2
is_delayed (insn)
     unsigned long insn;
d2829 1
a2829 2
mips_step_skips_delay (pc)
     CORE_ADDR pc;
a2864 5
#if 0
      if (lenient && is_delayed (inst))
	continue;
#endif

a3079 3
static void return_value_location (struct type *, struct return_value_word *,
				   struct return_value_word *);

d3081 3
a3083 4
return_value_location (valtype, hi, lo)
     struct type *valtype;
     struct return_value_word *hi;
     struct return_value_word *lo;
d3184 3
a3186 4
mips_extract_return_value (valtype, regbuf, valbuf)
     struct type *valtype;
     char regbuf[REGISTER_BYTES];
     char *valbuf;
a3199 26

#if 0
  int regnum;
  int offset = 0;
  int len = TYPE_LENGTH (valtype);

  regnum = 2;
  if (TYPE_CODE (valtype) == TYPE_CODE_FLT
      && (MIPS_FPU_TYPE == MIPS_FPU_DOUBLE
	  || (MIPS_FPU_TYPE == MIPS_FPU_SINGLE
	      && len <= MIPS_FPU_SINGLE_REGSIZE)))
    regnum = FP0_REGNUM;

  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
    {				/* "un-left-justify" the value from the register */
      if (len < REGISTER_RAW_SIZE (regnum))
	offset = REGISTER_RAW_SIZE (regnum) - len;
      if (len > REGISTER_RAW_SIZE (regnum) &&	/* odd-size structs */
	  len < REGISTER_RAW_SIZE (regnum) * 2 &&
	  (TYPE_CODE (valtype) == TYPE_CODE_STRUCT ||
	   TYPE_CODE (valtype) == TYPE_CODE_UNION))
	offset = 2 * REGISTER_RAW_SIZE (regnum) - len;
    }
  memcpy (valbuf, regbuf + REGISTER_BYTE (regnum) + offset, len);
  REGISTER_CONVERT_TO_TYPE (regnum, valtype, valbuf);
#endif
d3206 1
a3206 3
mips_store_return_value (valtype, valbuf)
     struct type *valtype;
     char *valbuf;
a3226 30

#if 0
  int regnum;
  int offset = 0;
  int len = TYPE_LENGTH (valtype);
  char raw_buffer[MAX_REGISTER_RAW_SIZE];

  regnum = 2;
  if (TYPE_CODE (valtype) == TYPE_CODE_FLT
      && (MIPS_FPU_TYPE == MIPS_FPU_DOUBLE
	  || (MIPS_FPU_TYPE == MIPS_FPU_SINGLE
	      && len <= MIPS_REGSIZE)))
    regnum = FP0_REGNUM;

  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
    {				/* "left-justify" the value in the register */
      if (len < REGISTER_RAW_SIZE (regnum))
	offset = REGISTER_RAW_SIZE (regnum) - len;
      if (len > REGISTER_RAW_SIZE (regnum) &&	/* odd-size structs */
	  len < REGISTER_RAW_SIZE (regnum) * 2 &&
	  (TYPE_CODE (valtype) == TYPE_CODE_STRUCT ||
	   TYPE_CODE (valtype) == TYPE_CODE_UNION))
	offset = 2 * REGISTER_RAW_SIZE (regnum) - len;
    }
  memcpy (raw_buffer + offset, valbuf, len);
  REGISTER_CONVERT_FROM_TYPE (regnum, valtype, raw_buffer);
  write_register_bytes (REGISTER_BYTE (regnum), raw_buffer,
			len > REGISTER_RAW_SIZE (regnum) ?
			len : REGISTER_RAW_SIZE (regnum));
#endif
d3232 1
a3232 3
in_sigtramp (pc, ignore)
     CORE_ADDR pc;
     char *ignore;		/* function name */
a3241 1
static void show_mips_command (char *, int);
d3243 1
a3243 3
show_mips_command (args, from_tty)
     char *args;
     int from_tty;
a3247 1
static void set_mips_command (char *, int);
d3249 1
a3249 3
set_mips_command (args, from_tty)
     char *args;
     int from_tty;
a3256 1
static void show_mipsfpu_command (char *, int);
d3258 1
a3258 3
show_mipsfpu_command (args, from_tty)
     char *args;
     int from_tty;
a3282 1
static void set_mipsfpu_command (char *, int);
d3284 1
a3284 3
set_mipsfpu_command (args, from_tty)
     char *args;
     int from_tty;
a3289 1
static void set_mipsfpu_single_command (char *, int);
d3291 1
a3291 3
set_mipsfpu_single_command (args, from_tty)
     char *args;
     int from_tty;
a3300 1
static void set_mipsfpu_double_command (char *, int);
d3302 1
a3302 3
set_mipsfpu_double_command (args, from_tty)
     char *args;
     int from_tty;
a3311 1
static void set_mipsfpu_none_command (char *, int);
d3313 1
a3313 3
set_mipsfpu_none_command (args, from_tty)
     char *args;
     int from_tty;
a3322 1
static void set_mipsfpu_auto_command (char *, int);
d3324 1
a3324 3
set_mipsfpu_auto_command (args, from_tty)
     char *args;
     int from_tty;
d3332 1
a3332 3
mips_set_processor_type_command (args, from_tty)
     char *args;
     int from_tty;
d3357 1
a3357 3
mips_show_processor_type_command (args, from_tty)
     char *args;
     int from_tty;
d3364 1
a3364 2
mips_set_processor_type (str)
     char *str;
d3389 1
a3389 1
mips_read_processor_type ()
d3405 2
a3406 4
reinit_frame_cache_sfunc (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
d3412 1
a3412 3
gdb_print_insn_mips (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
d3466 1
a3466 3
mips_breakpoint_from_pc (pcptr, lenptr)
     CORE_ADDR *pcptr;
     int *lenptr;
d3544 1
a3544 2
mips_skip_stub (pc)
     CORE_ADDR pc;
d3627 1
a3627 3
mips_in_call_stub (pc, name)
     CORE_ADDR pc;
     char *name;
d3655 1
a3655 3
mips_in_return_stub (pc, name)
     CORE_ADDR pc;
     char *name;
d3683 1
a3683 2
mips_ignore_helper (pc)
     CORE_ADDR pc;
d3705 1
a3705 1
mips_call_dummy_address ()
d3745 6
a3750 7
mips_get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lval)
     char *raw_buffer;
     int *optimized;
     CORE_ADDR *addrp;
     struct frame_info *frame;
     int regnum;
     enum lval_type *lval;
a3812 1
static gdbarch_init_ftype mips_gdbarch_init;
d3814 2
a3815 3
mips_gdbarch_init (info, arches)
     struct gdbarch_info info;
     struct gdbarch_list *arches;
a3821 6
#if 0
  int ef_mips_bitptrs;
#endif
#if 0
  int ef_mips_arch;
#endif
d3847 4
a3850 1
      mips_abi = MIPS_ABI_UNKNOWN;
d3853 1
a3879 10
#if 0
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: ef_mips_arch = %d\n",
			  ef_mips_arch);
#endif
#if 0
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: ef_mips_bitptrs = %d\n",
			  ef_mips_bitptrs);
#endif
d3914 1
d3918 2
a3919 2
      tdep->mips_last_arg_regnum = ZERO_REGNUM + 7;
      tdep->mips_last_fp_arg_regnum = FP0_REGNUM + 15;
d3928 1
d3932 2
a3933 2
      tdep->mips_last_arg_regnum = ZERO_REGNUM + 7;
      tdep->mips_last_fp_arg_regnum = FP0_REGNUM + 15;
d3942 1
d3946 2
a3947 2
      tdep->mips_last_arg_regnum = ZERO_REGNUM + 11;
      tdep->mips_last_fp_arg_regnum = FP0_REGNUM + 19;
d3956 1
d3960 2
a3961 2
      tdep->mips_last_arg_regnum = ZERO_REGNUM + 11;
      tdep->mips_last_fp_arg_regnum = FP0_REGNUM + 19;
d3970 1
d3974 2
a3975 2
      tdep->mips_last_arg_regnum = ZERO_REGNUM + 11;
      tdep->mips_last_fp_arg_regnum = FP0_REGNUM + 19;
d3984 1
d3988 2
a3989 2
      tdep->mips_last_arg_regnum = ZERO_REGNUM + 11;
      tdep->mips_last_fp_arg_regnum = FP0_REGNUM + 19;
a4019 37
#if 0
  /* determine the ISA */
  switch (elf_flags & EF_MIPS_ARCH)
    {
    case E_MIPS_ARCH_1:
      ef_mips_arch = 1;
      break;
    case E_MIPS_ARCH_2:
      ef_mips_arch = 2;
      break;
    case E_MIPS_ARCH_3:
      ef_mips_arch = 3;
      break;
    case E_MIPS_ARCH_4:
      ef_mips_arch = 0;
      break;
    default:
      break;
    }
#endif

#if 0
  /* determine the size of a pointer */
  if ((elf_flags & EF_MIPS_32BITPTRS))
    {
      ef_mips_bitptrs = 32;
    }
  else if ((elf_flags & EF_MIPS_64BITPTRS))
    {
      ef_mips_bitptrs = 64;
    }
  else
    {
      ef_mips_bitptrs = 0;
    }
#endif

d4096 22
d4122 9
a4130 2
			  "mips_dump_tdep: tdep->mips_abi = %d\n",
			  tdep->mips_abi);
d4150 3
a4152 2
		      "mips_dump_tdep: MIPS_LAST_FP_ARG_REGNUM = %d\n",
		      MIPS_LAST_FP_ARG_REGNUM);
d4307 3
a4309 2
		      "mips_dump_tdep: MIPS_LAST_ARG_REGNUM = %d\n",
		      MIPS_LAST_ARG_REGNUM);
d4509 1
a4509 1
_initialize_mips_tdep ()
@


1.26
log
@Move the ``set mask-address'' command to remote-mips.c.  Disable
address masking in mips-tdep.c.
@
text
@d544 8
d748 2
a749 1
	      pc = read_register (rtype_rs (inst));	/* Set PC to that address */
d766 1
a766 1
		if (read_register (itype_rs (inst)) < 0)
d776 1
a776 1
		if (read_register (itype_rs (inst)) >= 0)
d806 2
a807 2
	  if (read_register (itype_rs (inst)) ==
	      read_register (itype_rt (inst)))
d814 2
a815 2
	  if (read_register (itype_rs (inst)) !=
	      read_register (itype_rs (inst)))
d822 1
a822 1
	  if (read_register (itype_rs (inst) <= 0))
d829 1
a829 1
	  if (read_register (itype_rs (inst) > 0))
d1078 1
a1078 1
	  reg = read_register (upk.regx);
d1087 1
a1087 1
	  reg = read_register (upk.regx);
d1097 1
a1097 1
	  reg = read_register (24);	/* Test register is 24 */
d1127 1
a1127 1
	      pc = read_register (reg);
d1356 1
a1356 1
  return read_register (regno);
d2485 1
a2485 1
  CORE_ADDR sp = ADDR_BITS_REMOVE (read_register (SP_REGNUM));
d3718 1
a3718 1
    return read_register (RA_REGNUM);
d3725 1
a3725 1
	return read_register (2);
d3747 1
a3747 1
	      CORE_ADDR target_pc = read_register (2);
d3777 1
a3777 1
	    return read_register (18);
d3976 1
a3976 2

  return read_register (RA_REGNUM);
d4259 1
a4259 1
  set_gdbarch_read_pc (gdbarch, generic_target_read_pc);
@


1.25
log
@* mips-tdep.c (mips_push_arguments): Always align struct_addr on a
16 byte boundary. Align allocated argument space using
MIPS_STACK_ARGSIZE.  Reserve space on stack for the struct return
and floating-point registers.  Use fp_register_arg_p to determine
if float_argreg should be aligned.
@
text
@d127 1
d470 40
a509 1
static int mask_address_p = 1;
d1358 1
a1358 1
      if (mask_address_p && (addr >> 32 == (CORE_ADDR) 0xffffffff))
d1367 8
a1374 6
	     code that loads an address is this: lui $r2, <upper 16
	     bits> ori $r2, <lower 16 bits> But the lui sign-extends
	     the value such that the upper 32 bits may be all 1s.  The
	     workaround is simply to mask off these bits.  In the
	     future, gcc may be changed to support true 64-bit
	     addressing, and this masking will have to be disabled.  */
d1378 1
a1378 1
  else
d1380 3
d4094 1
d4107 1
d4120 1
d4133 1
d4146 1
d4159 1
d4306 4
d4790 7
a4796 6
  add_show_from_set
    (add_set_cmd ("mask-address", no_class, var_boolean, (char *) &mask_address_p,
		  "Set zeroing of upper 32 bits of 64-bit addresses.\n\
Use \"on\" to enable the masking, and \"off\" to disable it.\n\
Without an argument, zeroing of upper address bits is enabled.", &setlist),
     &showlist);
@


1.24
log
@More mult-arch conversions: IEEE_FLOAT, SKIP_PROLOGUE,
SAVED_PC_AFTER_CALL, DECR_PC_AFTER_BREAK, BREAKPOINT_FROM_PC,
INNER_THAN.
@
text
@d2107 1
a2107 1
  struct_addr = ROUND_DOWN (struct_addr, MIPS_SAVED_REGSIZE);
d2113 1
a2113 1
    len += ROUND_UP (TYPE_LENGTH (VALUE_TYPE (args[argnum])), MIPS_SAVED_REGSIZE);
d2129 1
a2129 1
			    "mips_push_arguments: struct_return at r%d 0x%lx\n",
d2132 2
d2248 3
@


1.23
log
@2000-07-06  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * mips-tdep.c: Replace '16' with bfd_mach_mips16 where appropriate.
@
text
@d2844 1
a2844 3
mips32_skip_prologue (pc, lenient)
     CORE_ADDR pc;		/* starting PC to search from */
     int lenient;
d2938 1
a2938 3
mips16_skip_prologue (pc, lenient)
     CORE_ADDR pc;		/* starting PC to search from */
     int lenient;
d3050 1
a3050 3
mips_skip_prologue (pc, lenient)
     CORE_ADDR pc;
     int lenient;
d3065 1
a3065 1
    return mips16_skip_prologue (pc, lenient);
d3067 1
a3067 18
    return mips32_skip_prologue (pc, lenient);
}

#if 0
/* The lenient prologue stuff should be superseded by the code in
   init_extra_frame_info which looks to see whether the stores mentioned
   in the proc_desc have actually taken place.  */

/* Is address PC in the prologue (loosely defined) for function at
   STARTADDR?  */

static int
mips_in_lenient_prologue (startaddr, pc)
     CORE_ADDR startaddr;
     CORE_ADDR pc;
{
  CORE_ADDR end_prologue = mips_skip_prologue (startaddr, 1);
  return pc >= startaddr && pc < end_prologue;
a3068 1
#endif
d3909 13
d4226 8
@


1.22
log
@For EABI, start allocting space on the stack when the registers are
full.  Not when the number of args == 8.
@
text
@d3552 2
a3553 1
    info->mach = pc_is_mips16 (PROC_LOW_ADDR (proc_desc)) ? 16 : TM_PRINT_INSN_MACH;
d3555 2
a3556 1
    info->mach = pc_is_mips16 (memaddr) ? 16 : TM_PRINT_INSN_MACH;
d3559 1
a3559 1
  memaddr &= (info->mach == 16 ? ~1 : ~3);
@


1.21
log
@When FP registers are full, store FP arguments on stack and not in
integer registers.
@
text
@d2262 2
d2266 1
a2270 1
		  /* Write this portion of the argument to the stack.  */
a2272 1

d2275 1
d2314 2
d2359 10
a2368 9
	      /* The offset onto the stack at which we will start
	         copying parameters (after the registers are used up) 
	         begins at (4 * MIPS_REGSIZE) in the old ABI.  This 
	         leaves room for the "home" area for register parameters.

	         In the new EABI (and the NABI32), the 8 register parameters 
	         do not have "home" stack space reserved for them, so the
	         stack offset does not get incremented until after
	         we have used up the 8 parameter registers.  */
d2370 1
a2370 1
	      if (MIPS_REGS_HAVE_HOME_P || argnum >= 8)
@


1.20
log
@Add ``set debug mips'' command.  Add much debugging.
@
text
@d2065 17
d2185 2
a2186 7
      if ((typecode == TYPE_CODE_FLT
	   || (MIPS_EABI
	       && (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION)
	       && TYPE_NFIELDS (arg_type) == 1
	       && TYPE_CODE (TYPE_FIELD_TYPE (arg_type, 0)) == TYPE_CODE_FLT))
	  && float_argreg <= MIPS_LAST_FP_ARG_REGNUM
	  && MIPS_FPU_TYPE != MIPS_FPU_NONE)
a2255 1

d2258 2
d2264 3
a2266 1
	      if (argreg > MIPS_LAST_ARG_REGNUM || odd_sized_struct)
d2309 5
a2313 3
	      /* Note!!! This is NOT an else clause.
	         Odd sized structs may go thru BOTH paths.  */
	      if (argreg <= MIPS_LAST_ARG_REGNUM)
@


1.19
log
@For MIPS_EABI, squeeze simple floating point structs into an FP register.
@
text
@d110 1
d2099 4
d2109 7
a2115 1
    write_register (argreg++, struct_addr);
d2129 5
d2136 3
a2138 2
      if (MIPS_EABI && len > MIPS_SAVED_REGSIZE &&
	  (typecode == TYPE_CODE_STRUCT || typecode == TYPE_CODE_UNION))
d2144 2
d2183 3
d2188 6
a2193 1
		write_register (argreg + 1, regval);
d2197 3
d2203 4
a2206 2
		  write_register (argreg, regval);
		  argreg += 2;
d2216 4
a2219 1
	      CORE_ADDR regval = extract_address (val, len);
d2227 3
d2258 1
d2272 20
a2291 2
		  write_memory (sp + stack_offset + longword_offset,
				val, partial_len);
d2298 1
a2298 1
		  CORE_ADDR regval = extract_address (val, partial_len);
d2321 4
d2352 2
d3920 1
d3922 2
d3925 1
d3978 1
a3978 1
			  "mips_gdbarch_init: elf_flags = %08x\n",
d3980 1
d3984 2
d3989 1
d4118 1
d4137 1
d4728 6
d4735 1
@


1.18
log
@EABI64 was selecting EABI32
@
text
@d2146 8
a2153 1
      if (typecode == TYPE_CODE_FLT
@


1.17
log
@Multi-arch GDB_TARGET_IS_MIPS64.
@
text
@d3874 1
a3874 1
      mips_abi = MIPS_ABI_EABI32;
@


1.16
log
@Print all known but not yet multi-arched values.
@
text
@d125 1
d219 4
a222 1

d1315 21
a1335 2
#if GDB_TARGET_IS_MIPS64
  if (mask_address_p && (addr >> 32 == (CORE_ADDR) 0xffffffff))
d1337 4
a1340 13
      /* This hack is a work-around for existing boards using PMON,
         the simulator, and any other 64-bit targets that doesn't have
         true 64-bit addressing.  On these targets, the upper 32 bits
         of addresses are ignored by the hardware.  Thus, the PC or SP
         are likely to have been sign extended to all 1s by instruction
         sequences that load 32-bit addresses.  For example, a typical
         piece of code that loads an address is this:
         lui $r2, <upper 16 bits>
         ori $r2, <lower 16 bits>
         But the lui sign-extends the value such that the upper 32 bits
         may be all 1s.  The workaround is simply to mask off these bits.
         In the future, gcc may be changed to support true 64-bit
         addressing, and this masking will have to be disabled.  */
a1342 7
#else
  /* Even when GDB is configured for some 32-bit targets (e.g. mips-elf),
     BFD is configured to handle 64-bit targets, so CORE_ADDR is 64 bits.
     So we still have to mask off useless bits from addresses.  */
  addr &= (CORE_ADDR) 0xffffffff;
#endif

d3952 1
d3964 1
d3976 1
d3988 1
d4000 1
d4012 1
@


1.15
log
@Re-implement gdbach_dump() so that it prints out the macro values.
Add ``maint print arch'' command.
Add ``gdbarch_register()'' function that also takes gdbarch_dump_tdep().
Use in mips-tdep.c.
@
text
@d44 1
a44 1

a4153 3
		      "mips_dump_tdep: MIPS_LAST_ARG_REGNUM = %d\n",
		      MIPS_LAST_ARG_REGNUM);
  fprintf_unfiltered (file,
a4163 3
		      "mips_dump_tdep: MIPS_SAVED_REGSIZE = %d\n",
		      MIPS_SAVED_REGSIZE);
  fprintf_unfiltered (file,
d4178 327
@


1.14
log
@MIPS is always multi-arch enabled.
@
text
@a3842 1
  char *ef_mips_abi;
d3893 16
a3908 2
  if (mips_abi == MIPS_ABI_UNKNOWN)
    mips_abi = MIPS_ABI_O32;
a3938 1
      ef_mips_abi = "o32";
a3949 1
      ef_mips_abi = "o64";
a3960 1
      ef_mips_abi = "eabi32";
a3971 1
      ef_mips_abi = "eabi64";
a3982 1
      ef_mips_abi = "n32";
a3993 1
      ef_mips_abi = "default";
d4121 8
a4128 1
  if (gdbarch_debug)
d4130 2
a4131 14
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: (info)ef_mips_abi = %s\n",
			  ef_mips_abi);
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: (info)ef_mips_arch = %d\n",
			  ef_mips_arch);
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: (info)ef_mips_bitptrs = %d\n",
			  ef_mips_bitptrs);
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: MIPS_REGSIZE = %d\n",
			  MIPS_REGSIZE);
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: tdep->elf_flags = 0x%x\n",
d4133 2
a4134 2
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: tdep->mips_abi = %d\n",
a4135 27
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: tdep->mips_fpu_type = %d (%s)\n",
			  tdep->mips_fpu_type,
			  (tdep->mips_fpu_type == MIPS_FPU_NONE ? "none"
			   : tdep->mips_fpu_type == MIPS_FPU_SINGLE ? "single"
			   : tdep->mips_fpu_type == MIPS_FPU_DOUBLE ? "double"
			   : "???"));
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: tdep->mips_last_arg_regnum = %d\n",
			  tdep->mips_last_arg_regnum);
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: tdep->mips_last_fp_arg_regnum = %d (%d)\n",
			  tdep->mips_last_fp_arg_regnum,
			  tdep->mips_last_fp_arg_regnum - FP0_REGNUM);
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: tdep->mips_default_saved_regsize = %d\n",
			  tdep->mips_default_saved_regsize);
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: tdep->mips_fp_register_double = %d (%s)\n",
			  tdep->mips_fp_register_double,
			  (tdep->mips_fp_register_double ? "true" : "false"));
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: tdep->mips_regs_have_home_p = %d\n",
			  tdep->mips_regs_have_home_p);
      fprintf_unfiltered (gdb_stdlog,
			  "mips_gdbarch_init: tdep->mips_default_stack_argsize = %d\n",
			  tdep->mips_default_stack_argsize);
d4137 47
a4183 2

  return gdbarch;
a4185 1

d4192 1
a4192 2
  if (GDB_MULTI_ARCH)
    register_gdbarch_init (bfd_arch_mips, mips_gdbarch_init);
@


1.13
log
@Delete MIPS_DEFAULT_FPU from config/mips/*.h
@
text
@d2 4
a5 1
   Copyright 1988-1999, Free Software Foundation, Inc.
d3874 16
d3894 2
d4066 3
@


1.12
log
@Change signature of function add_set_enum_cmd() so that it uses
constant character pointers.  Update everything.
As a consequence fix infrun's follow-fork plugging a small memory leak.
@
text
@d43 8
d4041 1
@


1.11
log
@PARAMS removal.
@
text
@d65 3
a67 3
static char size_auto[] = "auto";
static char size_32[] = "32";
static char size_64[] = "64";
d69 1
a69 1
static char *size_enums[] = {
d146 1
a146 1
static char *mips_saved_regsize_string = size_auto;
d194 1
a194 1
static char *mips_stack_argsize_string = size_auto;
@


1.11.2.1
log
@Import ``maint print arch'' from trunk.
Import dump of macro values from trunk.
@
text
@d3832 1
d3897 1
d3909 1
d3921 1
d3933 1
d3945 1
d3957 1
d4081 1
a4081 8
  return gdbarch;
}

static void
mips_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  if (tdep != NULL)
d4083 14
a4096 2
      fprintf_unfiltered (file,
			  "mips_dump_tdep: tdep->elf_flags = 0x%x\n",
d4098 2
a4099 2
      fprintf_unfiltered (file,
			  "mips_dump_tdep: tdep->mips_abi = %d\n",
d4101 27
d4129 2
a4130 47
  fprintf_unfiltered (file,
		      "mips_dump_tdep: FP_REGISTER_DOUBLE = %d\n",
		      FP_REGISTER_DOUBLE);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_DEFAULT_FPU_TYPE = %d (%s)\n",
		      MIPS_DEFAULT_FPU_TYPE,
		      (MIPS_DEFAULT_FPU_TYPE == MIPS_FPU_NONE ? "none"
		       : MIPS_DEFAULT_FPU_TYPE == MIPS_FPU_SINGLE ? "single"
		       : MIPS_DEFAULT_FPU_TYPE == MIPS_FPU_DOUBLE ? "double"
		       : "???"));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_EABI = %d\n",
		      MIPS_EABI);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_LAST_FP_ARG_REGNUM = %d\n",
		      MIPS_LAST_FP_ARG_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_LAST_ARG_REGNUM = %d\n",
		      MIPS_LAST_ARG_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_FPU_TYPE = %d (%s)\n",
		      MIPS_FPU_TYPE,
		      (MIPS_FPU_TYPE == MIPS_FPU_NONE ? "none"
		       : MIPS_FPU_TYPE == MIPS_FPU_SINGLE ? "single"
		       : MIPS_FPU_TYPE == MIPS_FPU_DOUBLE ? "double"
		       : "???"));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_DEFAULT_SAVED_REGSIZE = %d\n",
		      MIPS_DEFAULT_SAVED_REGSIZE);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_SAVED_REGSIZE = %d\n",
		      MIPS_SAVED_REGSIZE);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: FP_REGISTER_DOUBLE = %d\n",
		      FP_REGISTER_DOUBLE);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_REGS_HAVE_HOME_P = %d\n",
		      MIPS_REGS_HAVE_HOME_P);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_DEFAULT_STACK_ARGSIZE = %d\n",
		      MIPS_DEFAULT_STACK_ARGSIZE);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_STACK_ARGSIZE = %d\n",
		      MIPS_STACK_ARGSIZE);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_REGSIZE = %d\n",
		      MIPS_REGSIZE);
d4133 1
d4140 2
a4141 1
  gdbarch_register (bfd_arch_mips, mips_gdbarch_init, mips_dump_tdep);
@


1.11.2.2
log
@Print all known but not yet multi-arched values.
@
text
@d41 1
a41 1
#include "symcat.h"
d4107 3
d4120 3
a4136 327
  fprintf_unfiltered (file,
		      "mips_dump_tdep: A0_REGNUM = %d\n",
		      A0_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: ADDR_BITS_REMOVE # %s\n",
		      XSTRING (ADDR_BITS_REMOVE(ADDR)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: ATTACH_DETACH # %s\n",
		      XSTRING (ATTACH_DETACH));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: BADVADDR_REGNUM = %d\n",
		      BADVADDR_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: BIG_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: CAUSE_REGNUM = %d\n",
		      CAUSE_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: CPLUS_MARKER = %c\n",
		      CPLUS_MARKER);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: DEFAULT_MIPS_TYPE = %s\n",
		      DEFAULT_MIPS_TYPE);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: DO_REGISTERS_INFO # %s\n",
		      XSTRING (DO_REGISTERS_INFO));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: DWARF_REG_TO_REGNUM # %s\n",
		      XSTRING (DWARF_REG_TO_REGNUM (REGNUM)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: ECOFF_REG_TO_REGNUM # %s\n",
		      XSTRING (ECOFF_REG_TO_REGNUM (REGNUM)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: ELF_MAKE_MSYMBOL_SPECIAL # %s\n",
		      XSTRING (ELF_MAKE_MSYMBOL_SPECIAL (SYM, MSYM)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: FCRCS_REGNUM = %d\n",
		      FCRCS_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: FCRIR_REGNUM = %d\n",
		      FCRIR_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: FIRST_EMBED_REGNUM = %d\n",
		      FIRST_EMBED_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: FPA0_REGNUM = %d\n",
		      FPA0_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: GDB_TARGET_IS_MIPS64 = %d\n",
		      GDB_TARGET_IS_MIPS64);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: GDB_TARGET_MASK_DISAS_PC # %s\n",
		      XSTRING (GDB_TARGET_MASK_DISAS_PC (PC)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: GDB_TARGET_UNMASK_DISAS_PC # %s\n",
		      XSTRING (GDB_TARGET_UNMASK_DISAS_PC (PC)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: GEN_REG_SAVE_MASK = %d\n",
		      GEN_REG_SAVE_MASK);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: HAVE_NONSTEPPABLE_WATCHPOINT # %s\n",
		      XSTRING (HAVE_NONSTEPPABLE_WATCHPOINT));
  fprintf_unfiltered (file,
		      "mips_dump_tdep:  HI_REGNUM = %d\n",
		      HI_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: IDT_BIG_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: IDT_LITTLE_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: IGNORE_HELPER_CALL # %s\n",
		      XSTRING (IGNORE_HELPER_CALL (PC)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: INIT_FRAME_PC # %s\n",
		      XSTRING (INIT_FRAME_PC (FROMLEAF, PREV)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: INIT_FRAME_PC_FIRST # %s\n",
		      XSTRING (INIT_FRAME_PC_FIRST (FROMLEAF, PREV)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: IN_SIGTRAMP # %s\n",
		      XSTRING (IN_SIGTRAMP (PC, NAME)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: IN_SOLIB_CALL_TRAMPOLINE # %s\n",
		      XSTRING (IN_SOLIB_CALL_TRAMPOLINE (PC, NAME)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: IN_SOLIB_RETURN_TRAMPOLINE # %s\n",
		      XSTRING (IN_SOLIB_RETURN_TRAMPOLINE (PC, NAME)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: IS_MIPS16_ADDR = FIXME!\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: LAST_EMBED_REGNUM = %d\n",
		      LAST_EMBED_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: LITTLE_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: LO_REGNUM = %d\n",
		      LO_REGNUM);
#ifdef MACHINE_CPROC_FP_OFFSET
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MACHINE_CPROC_FP_OFFSET = %d\n",
		      MACHINE_CPROC_FP_OFFSET);
#endif
#ifdef MACHINE_CPROC_PC_OFFSET
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MACHINE_CPROC_PC_OFFSET = %d\n",
		      MACHINE_CPROC_PC_OFFSET);
#endif
#ifdef MACHINE_CPROC_SP_OFFSET
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MACHINE_CPROC_SP_OFFSET = %d\n",
		      MACHINE_CPROC_SP_OFFSET);
#endif
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MAKE_MIPS16_ADDR = FIXME!\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS16_BIG_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS16_INSTLEN = %d\n",
		      MIPS16_INSTLEN);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS16_LITTLE_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_DEFAULT_ABI = FIXME!\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_EFI_SYMBOL_NAME = multi-arch!!\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_INSTLEN = %d\n",
		      MIPS_INSTLEN);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_LAST_ARG_REGNUM = %d\n",
		      MIPS_LAST_ARG_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_NUMREGS = %d\n",
		      MIPS_NUMREGS);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_REGISTER_NAMES = delete?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MIPS_SAVED_REGSIZE = %d\n",
		      MIPS_SAVED_REGSIZE);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MSYMBOL_IS_SPECIAL = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: MSYMBOL_SIZE # %s\n",
		      XSTRING (MSYMBOL_SIZE (MSYM)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: OP_LDFPR = used?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: OP_LDGPR = used?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PMON_BIG_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PMON_LITTLE_BREAKPOINT = delete?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PRID_REGNUM = %d\n",
		      PRID_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PRINT_EXTRA_FRAME_INFO # %s\n",
		      XSTRING (PRINT_EXTRA_FRAME_INFO (FRAME)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_DESC_IS_DUMMY = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_FRAME_ADJUST = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_FRAME_OFFSET = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_FRAME_REG = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_FREG_MASK = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_FREG_OFFSET = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_HIGH_ADDR = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_LOW_ADDR = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_PC_REG = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_REG_MASK = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_REG_OFFSET = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PROC_SYMBOL = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PS_REGNUM = %d\n",
		      PS_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: PUSH_FP_REGNUM = %d\n",
		      PUSH_FP_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: RA_REGNUM = %d\n",
		      RA_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: REGISTER_CONVERT_FROM_TYPE # %s\n",
		      XSTRING (REGISTER_CONVERT_FROM_TYPE (REGNUM, VALTYPE, RAW_BUFFER)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: REGISTER_CONVERT_TO_TYPE # %s\n",
		      XSTRING (REGISTER_CONVERT_TO_TYPE (REGNUM, VALTYPE, RAW_BUFFER)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: REGISTER_NAMES = delete?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: ROUND_DOWN = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: ROUND_UP = function?\n");
#ifdef SAVED_BYTES
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SAVED_BYTES = %d\n",
		      SAVED_BYTES);
#endif
#ifdef SAVED_FP
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SAVED_FP = %d\n",
		      SAVED_FP);
#endif
#ifdef SAVED_PC
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SAVED_PC = %d\n",
		      SAVED_PC);
#endif
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SETUP_ARBITRARY_FRAME # %s\n",
		      XSTRING (SETUP_ARBITRARY_FRAME (NUMARGS, ARGS)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SET_PROC_DESC_IS_DUMMY = function?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SIGFRAME_BASE = %d\n",
		      SIGFRAME_BASE);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SIGFRAME_FPREGSAVE_OFF = %d\n",
		      SIGFRAME_FPREGSAVE_OFF);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SIGFRAME_PC_OFF = %d\n",
		      SIGFRAME_PC_OFF);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SIGFRAME_REGSAVE_OFF = %d\n",
		      SIGFRAME_REGSAVE_OFF);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SIGFRAME_REG_SIZE = %d\n",
		      SIGFRAME_REG_SIZE);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SKIP_TRAMPOLINE_CODE # %s\n",
		      XSTRING (SKIP_TRAMPOLINE_CODE (PC)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SOFTWARE_SINGLE_STEP # %s\n",
		      XSTRING (SOFTWARE_SINGLE_STEP (SIG, BP_P)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SOFTWARE_SINGLE_STEP_P = %d\n",
		      SOFTWARE_SINGLE_STEP_P);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: SOFTWARE_SINGLE_STEP_P = %d\n",
		      SOFTWARE_SINGLE_STEP_P);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: STAB_REG_TO_REGNUM # %s\n",
		      XSTRING (STAB_REG_TO_REGNUM (REGNUM)));
#ifdef STACK_END_ADDR
  fprintf_unfiltered (file,
		      "mips_dump_tdep: STACK_END_ADDR = %d\n",
		      STACK_END_ADDR);
#endif
  fprintf_unfiltered (file,
		      "mips_dump_tdep: STEP_SKIPS_DELAY # %s\n",
		      XSTRING (STEP_SKIPS_DELAY (PC)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: STEP_SKIPS_DELAY_P = %d\n",
		      STEP_SKIPS_DELAY_P);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: STOPPED_BY_WATCHPOINT # %s\n",
		      XSTRING (STOPPED_BY_WATCHPOINT (WS)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: T9_REGNUM = %d\n",
		      T9_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TABULAR_REGISTER_OUTPUT = used?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TARGET_CAN_USE_HARDWARE_WATCHPOINT # %s\n",
		      XSTRING (TARGET_CAN_USE_HARDWARE_WATCHPOINT (TYPE,CNT,OTHERTYPE)));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TARGET_HAS_HARDWARE_WATCHPOINTS # %s\n",
		      XSTRING (TARGET_HAS_HARDWARE_WATCHPOINTS));
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TARGET_MIPS = used?\n");
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TM_PRINT_INSN_MACH # %s\n",
		      XSTRING (TM_PRINT_INSN_MACH));
#ifdef TRACE_CLEAR
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TRACE_CLEAR # %s\n",
		      XSTRING (TRACE_CLEAR (THREAD, STATE)));
#endif
#ifdef TRACE_FLAVOR
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TRACE_FLAVOR = %d\n",
		      TRACE_FLAVOR);
#endif
#ifdef TRACE_FLAVOR_SIZE
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TRACE_FLAVOR_SIZE = %d\n",
		      TRACE_FLAVOR_SIZE);
#endif
#ifdef TRACE_SET
  fprintf_unfiltered (file,
		      "mips_dump_tdep: TRACE_SET # %s\n",
		      XSTRING (TRACE_SET (X,STATE)));
#endif
  fprintf_unfiltered (file,
		      "mips_dump_tdep: UNMAKE_MIPS16_ADDR = function?\n");
#ifdef UNUSED_REGNUM
  fprintf_unfiltered (file,
		      "mips_dump_tdep: UNUSED_REGNUM = %d\n",
		      UNUSED_REGNUM);
#endif
  fprintf_unfiltered (file,
		      "mips_dump_tdep: V0_REGNUM = %d\n",
		      V0_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: VM_MIN_ADDRESS = %ld\n",
		      (long) VM_MIN_ADDRESS);
#ifdef VX_NUM_REGS
  fprintf_unfiltered (file,
		      "mips_dump_tdep: VX_NUM_REGS = %d (used?)\n",
		      VX_NUM_REGS);
#endif
  fprintf_unfiltered (file,
		      "mips_dump_tdep: ZERO_REGNUM = %d\n",
		      ZERO_REGNUM);
  fprintf_unfiltered (file,
		      "mips_dump_tdep: _PROC_MAGIC_ = %d\n",
		      _PROC_MAGIC_);
@


1.10
log
@Fix signature of add_set_enum_cmd.  Change VAR parameter to char**.
Cleanup signature of add_set_cmd.  Change VAR parameter to void*.
@
text
@d212 1
a212 1
static int mips_in_lenient_prologue PARAMS ((CORE_ADDR, CORE_ADDR));
d215 1
a215 1
int gdb_print_insn_mips PARAMS ((bfd_vma, disassemble_info *));
d217 1
a217 1
static void mips_print_register PARAMS ((int, int));
d220 1
a220 1
  heuristic_proc_desc PARAMS ((CORE_ADDR, CORE_ADDR, struct frame_info *));
d222 1
a222 1
static CORE_ADDR heuristic_proc_start PARAMS ((CORE_ADDR));
d224 1
a224 1
static CORE_ADDR read_next_frame_reg PARAMS ((struct frame_info *, int));
d226 1
a226 1
int mips_set_processor_type PARAMS ((char *));
d228 1
a228 1
static void mips_show_processor_type_command PARAMS ((char *, int));
d230 1
a230 2
static void reinit_frame_cache_sfunc PARAMS ((char *, int,
					      struct cmd_list_element *));
d233 1
a233 1
  find_proc_desc PARAMS ((CORE_ADDR pc, struct frame_info * next_frame));
d235 2
a236 2
static CORE_ADDR after_prologue PARAMS ((CORE_ADDR pc,
					 mips_extra_func_info_t proc_desc));
d2696 1
a2696 1
static int is_delayed PARAMS ((unsigned long));
d2995 2
a2996 1
static void return_value_location PARAMS ((struct type *, struct return_value_word *, struct return_value_word *));
d3222 1
a3222 1
static void show_mips_command PARAMS ((char *, int));
d3231 1
a3231 1
static void set_mips_command PARAMS ((char *, int));
d3243 1
a3243 1
static void show_mipsfpu_command PARAMS ((char *, int));
d3272 1
a3272 1
static void set_mipsfpu_command PARAMS ((char *, int));
d3282 1
a3282 1
static void set_mipsfpu_single_command PARAMS ((char *, int));
d3296 1
a3296 1
static void set_mipsfpu_double_command PARAMS ((char *, int));
d3310 1
a3310 1
static void set_mipsfpu_none_command PARAMS ((char *, int));
d3324 1
a3324 1
static void set_mipsfpu_auto_command PARAMS ((char *, int));
@


1.9
log
@Handle case of 32 ABI saving 32 bit registers on stack when target
has 64 bit ISA.
@
text
@d4156 3
a4158 3
				  class_obscure,
			          size_enums,
				  (char *) &mips_saved_regsize_string, "\
d4166 1
a4166 1
				  &setmipscmdlist),
d4173 1
a4173 1
				       (char *) &mips_stack_argsize_string, "\
@


1.8
log
@Fix tipo 32->64 in MIPS_EABI.
@
text
@d3754 66
d4079 1
a4079 1
  set_gdbarch_get_saved_register (gdbarch, default_get_saved_register);
@


1.7
log
@Add preliminary support for IRIX's n32 abi to the MIPS's multi-arch code.
@
text
@d119 1
a119 1
		   || gdbarch_tdep (current_gdbarch)->mips_abi == MIPS_ABI_EABI32)
@


1.6
log
@Move some of the MIPS n32 ABI configuration options into the mips
multi-arch vector.
@
text
@d43 12
d106 1
a106 1
    int mips_eabi;
d118 2
a119 1
#define MIPS_EABI (gdbarch_tdep (current_gdbarch)->mips_eabi)
d187 1
a187 1
#define MIPS_DEFAULT_STACK_ARGSIZE (gdbarch_tdep (current_gdbarch)->mips_default_statck_argsize)
d3769 1
d3778 24
d3811 2
d3827 2
a3828 1
  switch ((elf_flags & EF_MIPS_ABI))
d3830 1
a3830 1
    case E_MIPS_ABI_O32:
a3831 1
      tdep->mips_eabi = 0;
d3833 1
d3835 3
d3842 1
a3842 1
    case E_MIPS_ABI_O64:
a3843 1
      tdep->mips_eabi = 0;
d3845 1
d3847 3
d3854 1
a3854 1
    case E_MIPS_ABI_EABI32:
a3855 1
      tdep->mips_eabi = 1;
d3857 1
d3859 3
d3866 1
a3866 1
    case E_MIPS_ABI_EABI64:
a3867 1
      tdep->mips_eabi = 1;
d3869 1
d3871 3
d3878 12
a3891 1
      tdep->mips_eabi = 0;
d3893 1
d3895 3
a3902 1
  tdep->mips_default_stack_argsize = tdep->mips_default_saved_regsize;
a3959 20
  /* Select either of the two alternative ABI's */
  if (tdep->mips_eabi)
    {
      /* EABI uses R4 through R11 for args */
      tdep->mips_last_arg_regnum = 11;
      /* EABI uses F12 through F19 for args */
      tdep->mips_last_fp_arg_regnum = FP0_REGNUM + 19;
      /* EABI does not reserve home space for registers */
      tdep->mips_regs_have_home_p = 0;
    }
  else
    {
      /* old ABI uses R4 through R7 for args */
      tdep->mips_last_arg_regnum = 7;
      /* old ABI uses F12 through F15 for args */
      tdep->mips_last_fp_arg_regnum = FP0_REGNUM + 15;
      /* Old ABI reserves home space for registers */
      tdep->mips_regs_have_home_p = 1;
    }

d4017 1
a4017 4
      fprintf_unfiltered (gdb_stderr,
			  "mips_gdbarch_init: (info)elf_flags = 0x%x\n",
			  elf_flags);
      fprintf_unfiltered (gdb_stderr,
d4020 1
a4020 1
      fprintf_unfiltered (gdb_stderr,
d4023 1
a4023 1
      fprintf_unfiltered (gdb_stderr,
d4026 18
a4043 5
      fprintf_unfiltered (gdb_stderr,
			  "mips_gdbarch_init: MIPS_EABI = %d\n",
			  tdep->mips_eabi);
      fprintf_unfiltered (gdb_stderr,
			  "mips_gdbarch_init: MIPS_LAST_ARG_REGNUM = %d\n",
d4045 2
a4046 2
      fprintf_unfiltered (gdb_stderr,
		   "mips_gdbarch_init: MIPS_LAST_FP_ARG_REGNUM = %d (%d)\n",
d4049 2
a4050 9
      fprintf_unfiltered (gdb_stderr,
		       "mips_gdbarch_init: tdep->mips_fpu_type = %d (%s)\n",
			  tdep->mips_fpu_type,
			  (tdep->mips_fpu_type == MIPS_FPU_NONE ? "none"
			 : tdep->mips_fpu_type == MIPS_FPU_SINGLE ? "single"
			 : tdep->mips_fpu_type == MIPS_FPU_DOUBLE ? "double"
			   : "???"));
      fprintf_unfiltered (gdb_stderr,
		       "mips_gdbarch_init: tdep->mips_default_saved_regsize = %d\n",
d4052 2
a4053 2
      fprintf_unfiltered (gdb_stderr,
	     "mips_gdbarch_init: tdep->mips_fp_register_double = %d (%s)\n",
d4055 7
a4061 1
			(tdep->mips_fp_register_double ? "true" : "false"));
@


1.5
log
@Include "arch-utils.h".
@
text
@d49 12
a60 10
/* We allow the user to override MIPS_SAVED_REGSIZE, so define
   the subcommand enum settings allowed. */
static char saved_gpreg_size_auto[] = "auto";
static char saved_gpreg_size_32[] = "32";
static char saved_gpreg_size_64[] = "64";

static char *saved_gpreg_size_enums[] = {
  saved_gpreg_size_auto,
  saved_gpreg_size_32,
  saved_gpreg_size_64,
a63 3
/* The current (string) value of saved_gpreg_size. */
static char *mips_saved_regsize_string = saved_gpreg_size_auto;

a81 6
#ifndef MIPS_DEFAULT_SAVED_REGSIZE
#define MIPS_DEFAULT_SAVED_REGSIZE MIPS_REGSIZE
#endif

#define MIPS_SAVED_REGSIZE (mips_saved_regsize())

d100 2
d124 2
d129 2
d133 15
d158 37
a379 13
/* Return the currently configured (or set) saved register size */

static unsigned int
mips_saved_regsize ()
{
  if (mips_saved_regsize_string == saved_gpreg_size_auto)
    return MIPS_DEFAULT_SAVED_REGSIZE;
  else if (mips_saved_regsize_string == saved_gpreg_size_64)
    return 8;
  else /* if (mips_saved_regsize_string == saved_gpreg_size_32) */
    return 4;
}

a2033 14
/*
 * STACK_ARGSIZE -- how many bytes does a pushed function arg take up on the stack?
 *
 * For n32 ABI, eight.
 * For all others, he same as the size of a general register.
 */
#if defined (_MIPS_SIM_NABI32) && _MIPS_SIM == _MIPS_SIM_NABI32
#define MIPS_NABI32   1
#define STACK_ARGSIZE 8
#else
#define MIPS_NABI32   0
#define STACK_ARGSIZE MIPS_SAVED_REGSIZE
#endif

d2185 1
a2185 1
		      if (STACK_ARGSIZE == 8 &&
d2189 1
a2189 1
			longword_offset = STACK_ARGSIZE - len;
d2192 2
a2193 2
			       TYPE_LENGTH (arg_type) < STACK_ARGSIZE)
			longword_offset = STACK_ARGSIZE - len;
d2250 2
a2251 3
	      if (!(MIPS_EABI || MIPS_NABI32) ||
		  argnum >= 8)
		stack_offset += ROUND_UP (partial_len, STACK_ARGSIZE);
d3835 1
d3900 2
d3909 2
d4035 1
a4035 1
			          saved_gpreg_size_enums,
d4045 14
@


1.4
log
@* mips-tdep.c (do_fp_register_row): copy the number of bytes
allocated, not the size of the pointer.
@
text
@d36 1
@


1.3
log
@Rename gdbarch-utils.[hc] to arch-utils.[hc].
@
text
@d2513 1
a2513 1
      memcpy (dbl_buffer, raw_buffer, sizeof (dbl_buffer));
d2531 1
a2531 1
      memcpy (dbl_buffer, raw_buffer[HI], sizeof (dbl_buffer));
@


1.2
log
@Bring COERCE_FLOAT_TO_DOUBLE under gdbarch's control.
* valops.c (COERCE_FLOAT_TO_DOUBLE): Rework definition to be
more function-like.
(default_coerce_float_to_double, standard_coerce_float_to_double):
New functions.
(value_arg_coerce): Adjust for new definition.
* value.h (default_coerce_float_to_double,
standard_coerce_float_to_double): New declarations for the above.
* gdbarch.sh (coerce_float_to_double): New entry, replacing macro.
* gdbarch.c, gdbarch.h: Regenerated.
* tm-alpha.h, tm-fr30.h, tm-m32r.h, tm-mips.h, tm-hppa.h,
tm-rs6000.h, tm-sh.h, tm-sparc.h (COERCE_FLOAT_TO_DOUBLE): Change
definitions.
* mips-tdep.c (mips_coerce_float_to_double): Supply our own custom
function here.
(mips_gdbarch_init): Install that as our coerce_float_to_double
function.
@
text
@d48 16
d82 2
a83 2
#ifndef MIPS_SAVED_REGSIZE
#define MIPS_SAVED_REGSIZE MIPS_REGSIZE
d86 2
d104 1
a104 1
    int mips_saved_regsize;
d129 2
a130 2
#undef MIPS_SAVED_REGSIZE
#define MIPS_SAVED_REGSIZE (gdbarch_tdep (current_gdbarch)->mips_saved_regsize)
d187 4
d328 13
d3182 22
d3768 1
a3768 1
      tdep->mips_saved_regsize = 4;
d3777 1
a3777 1
      tdep->mips_saved_regsize = 8;
d3786 1
a3786 1
      tdep->mips_saved_regsize = 4;
d3795 1
a3795 1
      tdep->mips_saved_regsize = 8;
d3804 1
a3804 1
      tdep->mips_saved_regsize = MIPS_REGSIZE;
d3812 21
d3971 2
a3972 2
		       "mips_gdbarch_init: tdep->mips_saved_regsize = %d\n",
			  tdep->mips_saved_regsize);
d3993 24
@


1.1
log
@Initial revision
@
text
@d2 1
a2 2
   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998
   Free Software Foundation, Inc.
d6 1
a6 1
This file is part of GDB.
d8 14
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d38 2
d41 10
a50 2
/* Some MIPS boards don't support floating point, so we permit the
   user to turn it off.  */
d53 5
a57 5
{
  MIPS_FPU_DOUBLE,	/* Full double precision floating point.  */
  MIPS_FPU_SINGLE,	/* Single precision floating point (R4650).  */
  MIPS_FPU_NONE		/* No floating point.  */
};
d66 3
a68 2

#define VM_MIN_ADDRESS (CORE_ADDR)0x400000
d71 1
d73 54
d137 1
a137 1
heuristic_proc_desc PARAMS ((CORE_ADDR, CORE_ADDR, struct frame_info *));
a142 2
void mips_set_processor_type_command PARAMS ((char *, int));

d151 1
a151 1
  find_proc_desc PARAMS ((CORE_ADDR pc, struct frame_info *next_frame));
d166 2
a167 1
char *mips_generic_reg_names[] = REGISTER_NAMES;
d169 7
d256 4
d262 2
a263 1
static int mips16_to_32_reg[8] = { 16, 17, 2, 3, 4, 5, 6, 7 };
d271 2
a272 2
#define PROC_LOW_ADDR(proc) ((proc)->pdr.adr) /* least address */
#define PROC_HIGH_ADDR(proc) ((proc)->high_addr) /* upper address bound */
d287 27
d315 5
a319 3
  struct mips_extra_func_info info;
  struct linked_proc_info *next;
} *linked_proc_desc_table = NULL;
d321 44
d376 1
a376 1
    return (TYPE_LENGTH (type) > 2 * MIPS_REGSIZE);
d378 1
a378 1
    return 1; /* Structures are returned by ref in extra arg0 */
d420 1
a420 1
	 strongly suspect that frameless always means prologueless... */
d458 4
a461 4
	 find the offset, rather than the code below which
	 is based on things being in a certain order in the
	 frame, but figuring out what the instruction's offset
	 is relative to might be a little tricky.  */
d466 2
a467 2
	   || (inst & 0xffe00000) == 0xe7c00000	/* swc1 freg,n($r30) */
	   || (inst & 0xffe00000) == 0xf7a00000)/* sdc1 freg,n($sp) */
d485 1
a485 1
  if ((inst & 0xf800) == 0xd000)		/* sw reg,n($sp) */
d490 1
a490 1
  else if ((inst & 0xff00) == 0xf900)		/* sd reg,n($sp) */
d495 1
a495 1
  else if ((inst & 0xff00) == 0x6200		/* sw $ra,n($sp) */
d506 1
a506 1
    CORE_ADDR addr;
d518 1
a518 1
      instlen = MIPS_INSTLEN;
d539 1
a539 1
#define rtype_rd(x) ((x>>11) & 0x1f) 
d544 5
a548 4
mips32_relative_offset(unsigned long inst)
{ long x ;
  x = itype_immediate(inst) ;
  if (x & 0x8000) /* sign bit set */
d550 1
a550 1
      x |= 0xffff0000 ; /* sign extension */
d552 2
a553 2
  x = x << 2 ;
  return x ;
d559 1
a559 1
mips32_next_pc(CORE_ADDR pc)
d561 8
a568 6
  unsigned long inst ;
  int op ;
  inst = mips_fetch_instruction(pc) ;
  if ((inst & 0xe0000000) != 0) /* Not a special, junp or branch instruction */
    { if ((inst >> 27) == 5) /* BEQL BNEZ BLEZL BGTZE , bits 0101xx */
	{ op = ((inst >> 25) & 0x03) ;
d571 10
a580 5
	    case 0 : goto equal_branch ; /* BEQL   */
	    case 1 : goto neq_branch ;   /* BNEZ   */
	    case 2 : goto less_branch ;  /* BLEZ   */
	    case 3 : goto greater_branch ; /* BGTZ */
	    default : pc += 4 ;
d583 2
a584 1
      else pc += 4 ; /* Not a branch, next instruction is easy */
d587 2
a588 2
    { /* This gets way messy */
      
d590 1
a590 1
      switch (op = ((inst >> 26) & 0x07))  /* extract bits 28,27,26 */
d592 14
a605 13
	  case 0 : /* SPECIAL */
	    op = rtype_funct(inst) ;
	    switch (op)
	      {
	      case 8 : /* JR */
	      case 9 : /* JALR */
		pc = read_register(rtype_rs(inst)) ; /* Set PC to that address */
		break ;
	      default: pc += 4 ;
	      }
	    
	    break ; /* end special */
	case 1 :  /* REGIMM */
d607 2
a608 2
	    op = jtype_op(inst) ; /* branch condition */
	    switch (jtype_op(inst))
d610 4
a613 4
	      case 0 : /* BLTZ */
	      case 2 : /* BLTXL */
	      case 16 : /* BLTZALL */
	      case 18 : /* BLTZALL */
d615 9
a623 8
		if (read_register(itype_rs(inst)) < 0)
		  pc += mips32_relative_offset(inst) + 4 ;
		else pc += 8 ;  /* after the delay slot */
	      break ;
	      case 1 : /* GEZ */
	      case 3 : /* BGEZL */
	      case 17 : /* BGEZAL */
	      case 19 : /* BGEZALL */
d625 8
a632 6
	      if (read_register(itype_rs(inst)) >= 0)
		  pc += mips32_relative_offset(inst) + 4 ;
	      else pc += 8 ; /* after the delay slot */
	      break ;
	      /* All of the other intructions in the REGIMM catagory */
	      default: pc += 4 ;
d635 7
a641 6
	  break ; /* end REGIMM */
	case 2 :  /* J */
	case 3 :  /* JAL */
	  { unsigned long reg ;
	    reg = jtype_target(inst) << 2 ;
	    pc = reg + ((pc+4) & 0xf0000000)  ;
d644 6
a649 5
	  break ;
	  /* FIXME case JALX :*/
	  { unsigned long reg ;
	    reg = jtype_target(inst) << 2 ;
	    pc = reg + ((pc+4) & 0xf0000000) + 1 ; /* yes, +1 */
d652 18
a669 16
	  break ; /* The new PC will be alternate mode */
	case 4 :     /* BEQ , BEQL */
	  equal_branch :
	   if (read_register(itype_rs(inst)) ==
	       read_register(itype_rt(inst)))
	     pc += mips32_relative_offset(inst) + 4 ;
	   else pc += 8 ;
	   break ;
	case 5 : /* BNE , BNEL */
	  neq_branch :
	  if (read_register(itype_rs(inst)) != 
	      read_register(itype_rs(inst)))
	    pc += mips32_relative_offset(inst) + 4 ;
	  else pc += 8 ;
	  break ;
	case 6 : /* BLEZ , BLEZL */
d671 18
a688 15
	  if (read_register(itype_rs(inst) <= 0))
	     pc += mips32_relative_offset(inst) + 4 ;
	  else pc += 8 ;
	  break ;
	case 7 :
	greater_branch :   /* BGTZ BGTZL */
	  if (read_register(itype_rs(inst) > 0))
	    pc += mips32_relative_offset(inst) + 4 ;
	  else pc += 8 ;
	break ;
	default : pc += 8 ;
	} /* switch */
    }  /* else */
  return pc ;
} /* mips32_next_pc */
d695 1
a695 1
   */
d700 1
a700 1
   */
d703 23
a725 23
  itype,          /* 0  immediate 5,10 */
  ritype,         /* 1   5,3,8 */
  rrtype,         /* 2   5,3,3,5 */
  rritype,        /* 3   5,3,3,5 */
  rrrtype,        /* 4   5,3,3,3,2 */ 
  rriatype,       /* 5   5,3,3,1,4 */ 
  shifttype,      /* 6   5,3,3,3,2 */
  i8type,         /* 7   5,3,8 */
  i8movtype,      /* 8   5,3,3,5 */
  i8mov32rtype,   /* 9   5,3,5,3 */
  i64type,        /* 10  5,3,8 */
  ri64type,       /* 11  5,3,3,5 */
  jalxtype,       /* 12  5,1,5,5,16 - a 32 bit instruction */
  exiItype,       /* 13  5,6,5,5,1,1,1,1,1,1,5 */
  extRitype,      /* 14  5,6,5,5,3,1,1,1,5 */
  extRRItype,     /* 15  5,5,5,5,3,3,5 */
  extRRIAtype,    /* 16  5,7,4,5,3,3,1,4 */
  EXTshifttype,   /* 17  5,5,1,1,1,1,1,1,5,3,3,1,1,1,2 */
  extI8type,      /* 18  5,6,5,5,3,1,1,1,5 */
  extI64type,     /* 19  5,6,5,5,3,1,1,1,5 */
  extRi64type,    /* 20  5,6,5,5,3,3,5 */
  extshift64type  /* 21  5,5,1,1,1,1,1,1,5,1,1,1,3,5 */
} ;
d729 7
a735 7
{
  unsigned short inst ;
  enum mips16_inst_fmts fmt ;
  unsigned long offset ;
  unsigned int regx ; /* Function in i8 type */
  unsigned int regy ;
} ;
d739 3
a741 2
static void print_unpack(char * comment,
			 struct upk_mips16 * u)
d743 2
a744 2
  printf("%s %04x ,f(%d) off(%08x) (x(%x) y(%x)\n",
	 comment,u->inst,u->fmt,u->offset,u->regx,u->regy) ;
d749 1
a749 1
   */
d751 1
a751 1
extended_offset(unsigned long extension)
d753 7
a759 7
  unsigned long value  ;
  value = (extension >> 21) & 0x3f ; /* * extract 15:11 */
  value = value << 6 ;
  value |= (extension >> 16) & 0x1f ; /* extrace 10:5 */
  value = value << 5 ;
  value |= extension & 0x01f ; 	/* extract 4:0 */
  return value ;
d766 1
a766 1
   */
d771 2
a772 1
static unsigned short fetch_mips_16(CORE_ADDR pc)
d774 4
a777 4
  char buf[8] ;
  pc &= 0xfffffffe ; /* clear the low order bit */
  target_read_memory(pc,buf,2) ;
  return extract_unsigned_integer(buf,2) ;
d781 2
a782 2
unpack_mips16(CORE_ADDR pc,
		  struct upk_mips16 * upk)
d784 4
a787 4
  CORE_ADDR extpc ;
  unsigned long extension ;
  int extended ;
  extpc = (pc - 4) & ~0x01 ; /* Extensions are 32 bit instructions */
d790 5
a794 2
  extended = ((mips32_op(extension) == 30) ? 1 : 0) ;
  if (extended) { extension = mips_fetch_instruction(extpc) ;}
d797 1
a797 1
    case itype :
d799 1
a799 1
	unsigned long value  ;
d801 4
a804 3
	  { value = extended_offset(extension) ;
	  value = value << 11 ;            /* rom for the original value */
	  value |= upk->inst & 0x7ff ;    /* eleven bits from instruction */
d807 3
a809 2
	  { value = upk->inst & 0x7ff ;
	  /* FIXME : Consider sign extension */
d811 1
a811 1
	upk->offset = value ;
d813 4
a816 4
      break ;
    case ritype :
    case i8type :
      { /* A register identifier and an offset */
d819 1
a819 1
	unsigned long value  ;
d822 19
a840 7
	    value = extended_offset(extension) ;
	    value = value << 8  ;          /* from the original instruction */
	    value |= upk->inst & 0xff ;    /* eleven bits from instruction */
	    upk->regx = (extension >> 8) & 0x07 ; /* or i8 funct */
	    if (value & 0x4000) /* test the sign bit , bit 26 */
	      {	value &= ~ 0x3fff ; /* remove the sign bit */
		value = -value ;
d842 1
d844 2
a845 12
	else {
	  value = upk->inst & 0xff ;  /* 8 bits */
	  upk->regx = (upk->inst >> 8) & 0x07 ; /* or i8 funct */
	  /* FIXME: Do sign extension , this format needs it */
	  if (value & 0x80)   /* THIS CONFUSES ME */
	    { value &= 0xef ; /* remove the sign bit */
	      value = -value ;
	    }
	  
	}
	upk->offset = value ;
	break ;
d847 1
a847 1
    case jalxtype :
d849 8
a856 8
	unsigned long value ;
	unsigned short nexthalf ;
	value = ((upk->inst & 0x1f)  << 5) | ((upk->inst >> 5) & 0x1f) ;
	value = value << 16 ;
	nexthalf = mips_fetch_instruction(pc+2) ; /* low bit still set */
	value |= nexthalf ;
	upk->offset = value ;
	break ;
d859 2
a860 2
      printf_filtered("Decoding unimplemented instruction format type\n") ;
      break ;
d870 5
a874 5
{ 0,0,1,1,1,1,0,0,
  0,0,0,0,1,0,0,0,
  0,0,0,0,0,0,0,0,
  0,0,0,0,0,1,1,0
} ;
d876 2
a877 1
static CORE_ADDR add_offset_16(CORE_ADDR pc, int offset)
d879 2
a880 2
  return ((offset << 2) | ((pc + 2) & (0xf0000000))) ;
  
d885 1
a885 1
static struct upk_mips16 upk ;
d887 2
a888 1
CORE_ADDR mips16_next_pc(CORE_ADDR pc)
d890 2
a891 2
  int op ;
  t_inst inst ;
d893 3
a895 3
  inst = fetch_mips_16(pc) ;
  upk.inst = inst ;
  op = mips16_op(upk.inst) ;
d898 1
a898 1
      int reg ;
d901 6
a906 5
	case 2 : /* Branch */
	  upk.fmt = itype ;
	  unpack_mips16(pc,&upk) ;
	  { long offset ;
	    offset = upk.offset ;
d908 3
a910 2
	      { offset &= 0xeff ;
		offset = - offset ;
d912 1
a912 1
	    pc += (offset << 1) + 2 ;
d914 43
a956 39
	  break ;
	case 3 : /* JAL , JALX - Watch out, these are 32 bit instruction*/
	   upk.fmt = jalxtype ;
	   unpack_mips16(pc,&upk) ;
	   pc = add_offset_16(pc,upk.offset) ;
	   if ((upk.inst >> 10) & 0x01) /* Exchange mode */
	     pc = pc & ~ 0x01 ; /* Clear low bit, indicate 32 bit mode */
	   else pc |= 0x01 ;
	  break ;
	case 4 : /* beqz */
	    upk.fmt = ritype ;
	    unpack_mips16(pc,&upk) ;
	    reg = read_register(upk.regx) ;
	    if (reg == 0) 
		pc += (upk.offset << 1) + 2 ;
	    else pc += 2 ;
	  break ;
	case 5 : /* bnez */
	    upk.fmt = ritype ;
	    unpack_mips16(pc,&upk) ;
	    reg = read_register(upk.regx) ;
	    if (reg != 0)
	       pc += (upk.offset << 1) + 2 ;
	    else pc += 2 ;
	  break ;
	case 12 : /* I8 Formats btez btnez */
	    upk.fmt = i8type ;
	    unpack_mips16(pc,&upk) ;
	    /* upk.regx contains the opcode */
	    reg = read_register(24) ; /* Test register is 24 */
	    if (((upk.regx == 0) && (reg == 0))        /* BTEZ */
		|| ((upk.regx == 1 ) && (reg != 0))) /* BTNEZ */
	      /* pc = add_offset_16(pc,upk.offset) ; */
	      pc += (upk.offset << 1) + 2 ; 
	    else pc += 2 ;
	  break ;
	case 29 : /* RR Formats JR, JALR, JALR-RA */
	  upk.fmt = rrtype ;
	  op = upk.inst & 0x1f ;
d958 3
a960 3
	    { 
	      upk.regx = (upk.inst >> 8) & 0x07 ;
	      upk.regy = (upk.inst >> 5) & 0x07 ;
d963 12
a974 4
		case 0 : reg = upk.regx ;   break ;
		case 1 :   reg = 31 ;       break ; /* Function return instruction*/
		case 2 :   reg = upk.regx ; break ;
		default:   reg = 31 ; break ; /* BOGUS Guess */
d976 1
a976 1
	      pc = read_register(reg) ;
d978 10
a987 9
	  else pc += 2 ;
	  break ;
	case 30 : /* This is an extend instruction */
	  pc += 4 ; /* Dont be setting breakpints on the second half */
	  break ;
	default :
	  printf("Filtered - next PC probably incorrrect due to jump inst\n");
	  pc += 2 ;
	  break ;
d990 2
a991 1
  else pc+= 2 ; /* just a good old instruction */
d994 2
a995 2
  return pc ;
} /* mips16_next_pc */
d1002 3
a1004 2
   */
CORE_ADDR mips_next_pc(CORE_ADDR pc)
d1006 1
a1006 1
  t_inst inst ;
d1009 5
a1013 4
  if (pc & 0x01) 
    return mips16_next_pc(pc) ;
  else return mips32_next_pc(pc) ;
} /* mips_next_pc */
d1055 3
a1057 3
 	  reg_position = fci->frame + SIGFRAME_REGSAVE_OFF
			 + ireg * SIGFRAME_REG_SIZE;
 	  fci->saved_regs[ireg] = reg_position;
d1061 3
a1063 3
 	  reg_position = fci->frame + SIGFRAME_FPREGSAVE_OFF
			 + ireg * SIGFRAME_REG_SIZE;
 	  fci->saved_regs[FP0_REGNUM + ireg] = reg_position;
d1069 1
a1069 1
  proc_desc = fci->proc_desc;
d1076 23
a1098 23
  kernel_trap = PROC_REG_MASK(proc_desc) & 1;
  gen_mask = kernel_trap ? 0xFFFFFFFF : PROC_REG_MASK(proc_desc);
  float_mask = kernel_trap ? 0xFFFFFFFF : PROC_FREG_MASK(proc_desc);

  if (/* In any frame other than the innermost or a frame interrupted by
	 a signal, we assume that all registers have been saved.
	 This assumes that all register saves in a function happen before
	 the first function call.  */
      (fci->next == NULL || fci->next->signal_handler_caller)

      /* In a dummy frame we know exactly where things are saved.  */
      && !PROC_DESC_IS_DUMMY (proc_desc)

      /* Don't bother unless we are inside a function prologue.  Outside the
	 prologue, we know where everything is. */

      && in_prologue (fci->pc, PROC_LOW_ADDR (proc_desc))

      /* Not sure exactly what kernel_trap means, but if it means
	 the kernel saves the registers without a prologue doing it,
	 we better not examine the prologue to see whether registers
	 have been saved yet.  */
      && !kernel_trap)
d1101 1
a1101 1
	 claims are saved have been saved yet.  */
d1132 1
a1132 1
  for (ireg= MIPS_NUMREGS-1; gen_mask; --ireg, gen_mask <<= 1)
d1136 1
a1136 1
	reg_position -= MIPS_REGSIZE;
d1146 1
a1146 1
      if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700) /* entry */
d1150 1
a1150 1
	  
d1154 1
a1154 1
	    reg_position -= MIPS_REGSIZE;
d1157 1
a1157 1
	  for (reg = 16; reg < sreg_count+16; reg++)
d1160 1
a1160 1
	      reg_position -= MIPS_REGSIZE;
d1171 2
a1172 2
  if (! GDB_TARGET_IS_MIPS64)
    reg_position += MIPS_REGSIZE;
d1176 1
a1176 1
  for (ireg = MIPS_NUMREGS-1; float_mask; --ireg, float_mask <<= 1)
d1179 2
a1180 2
	fci->saved_regs[FP0_REGNUM+ireg] = reg_position;
	reg_position -= MIPS_REGSIZE;
d1187 1
a1187 1
read_next_frame_reg(fi, regno)
d1194 1
a1194 1
	 if it is a signal handler frame.  */
d1202 1
a1202 1
	    return read_memory_integer(fi->saved_regs[regno], MIPS_REGSIZE);
d1212 1
a1212 1
    CORE_ADDR addr;
d1215 1
a1215 1
  if (mask_address_p && (addr >> 32 == (CORE_ADDR)0xffffffff))
d1218 13
a1230 13
	 the simulator, and any other 64-bit targets that doesn't have
	 true 64-bit addressing.  On these targets, the upper 32 bits
	 of addresses are ignored by the hardware.  Thus, the PC or SP
	 are likely to have been sign extended to all 1s by instruction
	 sequences that load 32-bit addresses.  For example, a typical
	 piece of code that loads an address is this:
		lui $r2, <upper 16 bits>
		ori $r2, <lower 16 bits>
	 But the lui sign-extends the value such that the upper 32 bits
	 may be all 1s.  The workaround is simply to mask off these bits.
	 In the future, gcc may be changed to support true 64-bit
	 addressing, and this masking will have to be disabled.  */
        addr &= (CORE_ADDR)0xffffffff;
d1236 1
a1236 1
  addr &= (CORE_ADDR)0xffffffff;
d1250 1
a1250 1
        prev->next ? FRAME_SAVED_PC (prev->next) : read_pc ());
d1252 1
a1252 1
  prev->pc =  tmp ? tmp : pc;
d1257 1
a1257 1
mips_frame_saved_pc(frame)
d1261 1
a1261 1
  mips_extra_func_info_t proc_desc = frame->proc_desc;
d1265 1
a1265 1
	      : (proc_desc ? PROC_PC_REG(proc_desc) : RA_REGNUM);
d1267 2
a1268 2
  if (proc_desc && PROC_DESC_IS_DUMMY(proc_desc))
    saved_pc = read_memory_integer(frame->frame - MIPS_REGSIZE, MIPS_REGSIZE);
d1270 1
a1270 1
    saved_pc = read_next_frame_reg(frame, pcreg);
d1276 1
a1276 1
static struct frame_saved_regs temp_saved_regs;
d1288 2
a1289 2
  if (temp_saved_regs.regs[regno] == 0)
    temp_saved_regs.regs[regno] = offset;
d1296 1
a1296 1
static int 
d1319 1
a1319 1
    CORE_ADDR pc;
d1321 26
a1346 19
    CORE_ADDR start_pc;
    CORE_ADDR fence;
    int instlen;
    int seen_adjsp = 0;

    pc = ADDR_BITS_REMOVE (pc);
    start_pc = pc;
    fence = start_pc - heuristic_fence_post;
    if (start_pc == 0)	return 0;

    if (heuristic_fence_post == UINT_MAX
	|| fence < VM_MIN_ADDRESS)
      fence = VM_MIN_ADDRESS;

    instlen = pc_is_mips16 (pc) ? MIPS16_INSTLEN : MIPS_INSTLEN;

    /* search back for previous return */
    for (start_pc -= instlen; ; start_pc -= instlen)
	if (start_pc < fence)
d1348 6
a1353 5
	    /* It's not clear to me why we reach this point when
	       stop_soon_quietly, but with this test, at least we
	       don't print out warnings for every child forked (eg, on
	       decstation).  22apr93 rich@@cygnus.com.  */
	    if (!stop_soon_quietly)
d1355 19
a1373 19
		static int blurb_printed = 0;

		if (fence == VM_MIN_ADDRESS)
		  warning("Hit beginning of text section without finding");
		else
		  warning("Hit heuristic-fence-post without finding");
		
		warning("enclosing function for address 0x%s", paddr_nz (pc));
		if (!blurb_printed)
		  {
		    printf_filtered ("\
This warning occurs if you are debugging a function without any symbols\n\
(for example, in a stripped executable).  In that case, you may wish to\n\
increase the size of the search with the `set heuristic-fence-post' command.\n\
\n\
Otherwise, you told GDB there was a function where there isn't one, or\n\
(more likely) you have encountered a bug in GDB.\n");
		    blurb_printed = 1;
		  }
d1375 1
d1377 5
a1381 5
	    return 0; 
	  }
	else if (pc_is_mips16 (start_pc))
	  {
	    unsigned short inst;
d1383 23
a1405 23
	    /* On MIPS16, any one of the following is likely to be the
	       start of a function:
		 entry
		 addiu sp,-n
		 daddiu sp,-n
		 extend -n followed by 'addiu sp,+n' or 'daddiu sp,+n'  */
	    inst = mips_fetch_instruction (start_pc);
	    if (((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700) /* entry */
		|| (inst & 0xff80) == 0x6380	/* addiu sp,-n */
		|| (inst & 0xff80) == 0xfb80	/* daddiu sp,-n */
		|| ((inst & 0xf810) == 0xf010 && seen_adjsp))	/* extend -n */
	      break;
	    else if ((inst & 0xff00) == 0x6300		/* addiu sp */
		     || (inst & 0xff00) == 0xfb00)	/* daddiu sp */
	      seen_adjsp = 1;
	    else
	      seen_adjsp = 0;
	  }
	else if (mips_about_to_return (start_pc))
	  {
	    start_pc += 2 * MIPS_INSTLEN; /* skip return, and its delay slot */
	    break;
	  }
d1408 3
a1410 3
    /* skip nops (usually 1) 0 - is this */
    while (start_pc < pc && read_memory_integer (start_pc, MIPS_INSTLEN) == 0)
	start_pc += MIPS_INSTLEN;
d1412 1
a1412 1
    return start_pc;
d1422 5
a1426 5
    unsigned short prev_inst;	/* previous instruction */
    unsigned short inst;	/* current instruction */
    int nbits;			/* number of bits in imm field */
    int scale;			/* scale factor to be applied to imm */
    int is_signed;		/* is the imm field signed? */
d1433 1
a1433 1
      if (offset & 0x8000)		/* check for negative extend */
d1455 4
a1458 4
mips16_heuristic_proc_desc(start_pc, limit_pc, next_frame, sp)
    CORE_ADDR start_pc, limit_pc;
    struct frame_info *next_frame;
    CORE_ADDR sp;
d1467 2
a1468 2
  PROC_FRAME_OFFSET(&temp_proc_desc) = 0;	/* size of stack frame */
  PROC_FRAME_ADJUST(&temp_proc_desc) = 0;	/* offset of FP from SP */
d1478 1
a1478 1
      if ((inst & 0xff00) == 0x6300		/* addiu sp */
d1482 2
a1483 2
	  if (offset < 0)			/* negative stack adjustment? */
	    PROC_FRAME_OFFSET(&temp_proc_desc) -= offset;
d1494 1
a1494 1
	  PROC_REG_MASK(&temp_proc_desc) |= (1 << reg);
d1501 1
a1501 1
	  PROC_REG_MASK(&temp_proc_desc) |= (1 << reg);
d1507 1
a1507 1
	  PROC_REG_MASK(&temp_proc_desc) |= (1 << RA_REGNUM);
d1513 1
a1513 1
	  PROC_REG_MASK(&temp_proc_desc) |= (1 << RA_REGNUM);
d1516 1
a1516 1
      else if (inst == 0x673d)			/* move $s1, $sp */
d1532 1
a1532 1
	  PROC_REG_MASK(&temp_proc_desc) |= 1 << reg;
d1539 1
a1539 1
	  PROC_REG_MASK(&temp_proc_desc) |= 1 << reg;
d1542 2
a1543 2
      else if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700) /* entry */
	entry_inst = inst;			/* save for later processing */
d1545 1
a1545 1
	cur_pc += MIPS16_INSTLEN;		/* 32-bit instruction */
d1548 10
a1557 10
    /* The entry instruction is typically the first instruction in a function,
       and it stores registers at offsets relative to the value of the old SP
       (before the prologue).  But the value of the sp parameter to this
       function is the new SP (after the prologue has been executed).  So we
       can't calculate those offsets until we've seen the entire prologue,
       and can calculate what the old SP must have been. */
    if (entry_inst != 0)
      {
	int areg_count = (entry_inst >> 8) & 7;
	int sreg_count = (entry_inst >> 6) & 3;
d1559 2
a1560 2
	/* The entry instruction always subtracts 32 from the SP.  */
	PROC_FRAME_OFFSET(&temp_proc_desc) += 32;
d1562 3
a1564 3
	/* Now we can calculate what the SP must have been at the
	   start of the function prologue.  */
	sp += PROC_FRAME_OFFSET(&temp_proc_desc);
d1566 7
a1572 7
	/* Check if a0-a3 were saved in the caller's argument save area.  */
	for (reg = 4, offset = 0; reg < areg_count+4; reg++)
	  {
	    PROC_REG_MASK(&temp_proc_desc) |= 1 << reg;
	    set_reg_offset (reg, sp + offset);
	    offset += MIPS_REGSIZE;
	  }
d1574 8
a1581 8
	/* Check if the ra register was pushed on the stack.  */
	offset = -4;
	if (entry_inst & 0x20)
	  {
	    PROC_REG_MASK(&temp_proc_desc) |= 1 << RA_REGNUM;
	    set_reg_offset (RA_REGNUM, sp + offset);
	    offset -= MIPS_REGSIZE;
	  }
d1583 8
a1590 8
	/* Check if the s0 and s1 registers were pushed on the stack.  */
	for (reg = 16; reg < sreg_count+16; reg++)
	  {
	    PROC_REG_MASK(&temp_proc_desc) |= 1 << reg;
	    set_reg_offset (reg, sp + offset);
	    offset -= MIPS_REGSIZE;
	  }
      }
d1594 4
a1597 4
mips32_heuristic_proc_desc(start_pc, limit_pc, next_frame, sp)
    CORE_ADDR start_pc, limit_pc;
    struct frame_info *next_frame;
    CORE_ADDR sp;
d1600 1
a1600 1
  CORE_ADDR frame_addr = 0; /* Value of $r30. Used by gcc for frame-pointer */
d1602 2
a1603 2
  memset (&temp_saved_regs, '\0', sizeof(struct frame_saved_regs));
  PROC_FRAME_OFFSET(&temp_proc_desc) = 0;
d1618 1
a1618 1
      if (high_word == 0x27bd		/* addiu $sp,$sp,-i */
d1623 1
a1623 1
	    PROC_FRAME_OFFSET(&temp_proc_desc) += 0x10000 - low_word;
d1632 1
a1632 1
	  PROC_REG_MASK(&temp_proc_desc) |= 1 << reg;
d1640 1
a1640 1
	  PROC_REG_MASK(&temp_proc_desc) |= 1 << reg;
d1643 1
a1643 1
      else if (high_word == 0x27be)			/* addiu $30,$sp,size */
d1646 2
a1647 2
	  if ((long)low_word != PROC_FRAME_OFFSET(&temp_proc_desc))
	      frame_addr = sp + low_word;
d1652 2
a1653 2
	      frame_addr = read_next_frame_reg(next_frame, 30);
	      alloca_adjust = (unsigned)(frame_addr - (sp + low_word));
d1665 3
a1667 3
     /* move $30,$sp.  With different versions of gas this will be either
       `addu $30,$sp,$zero' or `or $30,$sp,$zero' or `daddu 30,sp,$0'.
	Accept any one of these.  */
d1675 2
a1676 2
	      frame_addr = read_next_frame_reg(next_frame, 30);
	      alloca_adjust = (unsigned)(frame_addr - sp);
d1688 1
a1688 1
      else if ((high_word & 0xFFE0) == 0xafc0)		/* sw reg,offset($30) */
d1690 1
a1690 1
	  PROC_REG_MASK(&temp_proc_desc) |= 1 << reg;
d1697 3
a1699 3
heuristic_proc_desc(start_pc, limit_pc, next_frame)
    CORE_ADDR start_pc, limit_pc;
    struct frame_info *next_frame;
d1703 4
a1706 3
  if (start_pc == 0) return NULL;
  memset (&temp_proc_desc, '\0', sizeof(temp_proc_desc));
  memset (&temp_saved_regs, '\0', sizeof(struct frame_saved_regs));
d1727 1
a1727 1
  struct block *b = block_for_pc(pc);
d1783 1
a1783 1
	      PROC_DESC_IS_DUMMY(proc_desc) ? 0 : PROC_SYMBOL(proc_desc);
d1788 1
a1788 1
				  (SYMBOL_BLOCK_VALUE(proc_symbol)),
d1795 2
a1796 2
		heuristic_proc_desc (PROC_LOW_ADDR (proc_desc),
				     pc, next_frame);
d1805 3
a1807 3
	 by procedure call dummys.  However, the procedures being called ought
	 to have their own proc_descs, and even if they don't,
	 heuristic_proc_desc knows how to create them! */
d1812 2
a1813 2
	if (PROC_LOW_ADDR(&link->info) <= pc
	    && PROC_HIGH_ADDR(&link->info) > pc)
d1826 3
a1828 3
get_frame_pointer(frame, proc_desc)
    struct frame_info *frame;
    mips_extra_func_info_t proc_desc;
d1831 2
a1832 2
    read_next_frame_reg (frame, PROC_FRAME_REG (proc_desc)) +
      PROC_FRAME_OFFSET (proc_desc) - PROC_FRAME_ADJUST (proc_desc));
d1838 2
a1839 2
mips_frame_chain(frame)
    struct frame_info *frame;
d1843 1
a1843 1
  CORE_ADDR saved_pc = FRAME_SAVED_PC(frame);
d1854 1
a1854 1
  proc_desc = find_proc_desc(saved_pc, frame);
d1865 2
a1866 2
      /* The previous frame from a sigtramp frame might be frameless
	 and have frame size zero.  */
d1874 2
a1875 1
init_extra_frame_info(fci)
d1882 4
a1885 1
    fci->next ? cached_proc_desc : find_proc_desc(fci->pc, fci->next);
d1888 1
a1888 1
  fci->proc_desc =
d1894 2
a1895 2
	 Get the value of the frame relative sp, procedure might have been
	 interrupted by a signal at it's very start.  */
d1910 1
a1910 1
				    (CORE_ADDR *)NULL,(CORE_ADDR *)NULL);
d1913 2
a1914 3
	      fci->saved_regs = (CORE_ADDR*)
		frame_obstack_alloc (SIZEOF_FRAME_SAVED_REGS);
	      memcpy (fci->saved_regs, temp_saved_regs.regs, SIZEOF_FRAME_SAVED_REGS);
d1921 2
a1922 1
      fci->num_args = -1;	/* assume we can't tell how many args for now */
d1925 1
a1925 1
	  if (PROC_REG_MASK(proc_desc) & (1 << regnum))
d1927 1
a1927 1
	      fci->num_args = regnum - A0_REGNUM + 1;
d1930 1
a1930 1
	} 
d1971 1
a1971 1
#define STACK_ARGSIZE MIPS_REGSIZE
d1975 1
a1975 1
mips_push_arguments(nargs, args, sp, struct_return, struct_addr)
d1992 1
a1992 1
  
d1999 2
a2000 2
  struct_addr = ROUND_DOWN (struct_addr, MIPS_REGSIZE);
      
d2005 1
a2005 1
    len += ROUND_UP (TYPE_LENGTH(VALUE_TYPE(args[argnum])), MIPS_REGSIZE);
d2014 1
a2014 1
      write_register (argreg++, struct_addr);
d2029 2
a2030 2
	 reference. In all other cases, pass the structure by value.  */
      if (MIPS_EABI && len > MIPS_REGSIZE &&
d2033 1
a2033 1
	  store_address (valbuf, MIPS_REGSIZE, VALUE_ADDRESS (arg));
d2035 1
a2035 1
	  len = MIPS_REGSIZE;
d2039 1
a2039 1
	val = (char *)VALUE_CONTENTS (arg);
d2044 1
a2044 1
          && (float_argreg & 1))
d2049 7
a2055 7
	 are passed in register pairs; the even register gets
	 the low word, and the odd register gets the high word.
	 On non-EABI processors, the first two floating point arguments are
	 also copied to general registers, because MIPS16 functions
	 don't use float registers for arguments.  This duplication of
	 arguments in general registers can't hurt non-MIPS16 functions
	 because those registers are normally skipped.  */
d2066 1
a2066 1
	      regval = extract_unsigned_integer (val+low_offset, 4);
d2069 1
a2069 1
		write_register (argreg+1, regval);
d2072 1
a2072 1
	      regval = extract_unsigned_integer (val+4-low_offset, 4);
d2075 1
a2075 1
	        {
d2085 2
d2090 5
a2094 1
	        {
d2110 2
a2111 2
	  int odd_sized_struct = ((len > MIPS_REGSIZE) && 
				  (len % MIPS_REGSIZE != 0));
d2114 1
a2114 1
	      int partial_len = len < MIPS_REGSIZE ? len : MIPS_REGSIZE;
d2124 11
a2134 9
		    if (STACK_ARGSIZE == 8 &&
			(typecode == TYPE_CODE_INT ||
			 typecode == TYPE_CODE_PTR ||
			 typecode == TYPE_CODE_FLT) && len <= 4)
		      longword_offset = STACK_ARGSIZE - len;
		    else if ((typecode == TYPE_CODE_STRUCT ||
			      typecode == TYPE_CODE_UNION) &&
			     TYPE_LENGTH (arg_type) < STACK_ARGSIZE)
		      longword_offset = STACK_ARGSIZE - len;
d2136 1
a2136 1
		  write_memory (sp + stack_offset + longword_offset, 
d2141 1
a2141 1
		 Odd sized structs may go thru BOTH paths.  */
d2159 1
a2159 1
		      && (MIPS_REGSIZE < 8)
d2161 1
a2161 1
		      && (partial_len < MIPS_REGSIZE)
d2164 1
a2164 1
		    regval <<= ((MIPS_REGSIZE - partial_len) * 
d2169 1
a2169 1
    
d2176 1
a2176 1
    
d2181 8
a2188 8
		 copying parameters (after the registers are used up) 
		 begins at (4 * MIPS_REGSIZE) in the old ABI.  This 
		 leaves room for the "home" area for register parameters.

		 In the new EABI (and the NABI32), the 8 register parameters 
		 do not have "home" stack space reserved for them, so the
		 stack offset does not get incremented until after
		 we have used up the 8 parameter registers.  */
d2197 9
d2208 1
a2208 3
  write_register (RA_REGNUM, CALL_DUMMY_ADDRESS());

  /* Return adjusted stack pointer.  */
d2213 1
a2213 1
mips_push_register(CORE_ADDR *sp, int regno)
d2216 14
a2229 2
  int regsize = REGISTER_RAW_SIZE (regno);

d2232 1
a2232 1
  write_memory (*sp, buffer, regsize);
d2239 1
a2239 1
mips_push_dummy_frame()
d2242 2
a2243 2
  struct linked_proc_info *link = (struct linked_proc_info*)
      xmalloc(sizeof(struct linked_proc_info));
d2251 1
a2251 1
#define PUSH_FP_REGNUM 16 /* must be a register preserved across calls */
d2265 6
a2270 6
   * 	Saved PC
   *	Saved MMHI, MMLO, FPC_CSR
   *	Saved R31
   *	Saved R28
   *	...
   *	Saved R1
d2274 1
a2274 1
   *	Argument build area and stack arguments written via mips_push_arguments
d2279 3
a2281 3
  PROC_FRAME_REG(proc_desc) = PUSH_FP_REGNUM;
  PROC_FRAME_OFFSET(proc_desc) = 0;
  PROC_FRAME_ADJUST(proc_desc) = 0;
d2288 1
a2288 1
  PROC_REG_MASK(proc_desc) = GEN_REG_SAVE_MASK;
d2290 3
a2292 3
  PROC_REG_OFFSET(proc_desc) = sp - old_sp - MIPS_REGSIZE;
  for (ireg = 32; --ireg >= 0; )
    if (PROC_REG_MASK(proc_desc) & (1 << ireg))
d2296 1
a2296 1
  PROC_FREG_MASK(proc_desc) = 
d2301 3
a2303 3
  PROC_FREG_OFFSET(proc_desc) = sp - old_sp - 8;
  for (ireg = 32; --ireg >= 0; )
    if (PROC_FREG_MASK(proc_desc) & (1 << ireg))
d2311 4
a2314 4
  PROC_LOW_ADDR(proc_desc) = CALL_DUMMY_ADDRESS();
  PROC_HIGH_ADDR(proc_desc) =  CALL_DUMMY_ADDRESS() + 4;
  SET_PROC_DESC_IS_DUMMY(proc_desc);
  PROC_PC_REG(proc_desc) = RA_REGNUM;
d2318 1
a2318 1
mips_pop_frame()
d2324 1
a2324 1
  mips_extra_func_info_t proc_desc = frame->proc_desc;
d2326 1
a2326 1
  write_register (PC_REGNUM, FRAME_SAVED_PC(frame));
d2335 1
a2335 1
					     MIPS_REGSIZE)); 
d2340 1
a2340 1
  if (proc_desc && PROC_DESC_IS_DUMMY(proc_desc))
d2363 2
a2364 1
	        read_memory_integer (new_sp - 2*MIPS_REGSIZE, MIPS_REGSIZE));
d2366 2
a2367 1
	        read_memory_integer (new_sp - 3*MIPS_REGSIZE, MIPS_REGSIZE));
d2370 2
a2371 1
	        read_memory_integer (new_sp - 4*MIPS_REGSIZE, MIPS_REGSIZE));
d2390 2
a2391 2
      && !((regnum-FP0_REGNUM) & 1))
    if (REGISTER_RAW_SIZE(regnum) == 4)	/* this would be silly on MIPS64 or N32 (Irix 6) */
d2393 1
a2393 1
	char dbuffer[2 * MAX_REGISTER_RAW_SIZE]; 
d2396 1
a2396 1
	read_relative_register_raw_bytes (regnum+1, dbuffer+MIPS_REGSIZE);
d2399 1
a2399 1
	printf_filtered ("(d%d: ", regnum-FP0_REGNUM);
d2418 1
a2418 1
      { /* show 8-byte floats as float AND double: */
d2433 12
a2444 2
    print_scalar_formatted (raw_buffer, REGISTER_VIRTUAL_TYPE (regnum),
			    'x', 0, gdb_stdout);
d2453 1
a2453 1
{ /* do values for FP (float) regs */
d2461 1
a2461 1
   
d2469 1
a2469 1
  if (REGISTER_RAW_SIZE(regnum) == 4)
d2474 1
a2474 1
	error ("can't read register %d (%s)", 
d2478 8
a2485 8
      memcpy (dbl_buffer, raw_buffer, sizeof(dbl_buffer));
      flt1 = unpack_double (builtin_type_float,  raw_buffer[HI], &inv1);
      flt2 = unpack_double (builtin_type_float,  raw_buffer[LO], &inv2);
      doub = unpack_double (builtin_type_double, dbl_buffer,     &inv3);

      printf_filtered (inv1 ? " %-5s: <invalid float>" : 
		       " %-5s%-17.9g", REGISTER_NAME (regnum),     flt1);
      printf_filtered (inv2 ? " %-5s: <invalid float>" : 
d2487 1
a2487 1
      printf_filtered (inv3 ? " dbl: <invalid double>\n" : 
d2490 1
a2490 1
      regnum +=2;
d2493 1
a2493 1
    { /* eight byte registers: print each one as float AND as double. */
d2496 2
a2497 2
      memcpy (dbl_buffer, raw_buffer[HI], sizeof(dbl_buffer));
      flt1 = unpack_double (builtin_type_float, 
d2499 1
a2499 1
      doub = unpack_double (builtin_type_double, dbl_buffer,    &inv3);
d2501 1
a2501 1
      printf_filtered (inv1 ? " %-5s: <invalid float>" : 
d2503 1
a2503 1
      printf_filtered (inv3 ? " dbl: <invalid double>\n" : 
d2530 1
a2530 1
	continue;	/* unused register */
d2532 2
a2533 2
	break;	/* end the row: reached FP register */
      printf_filtered (MIPS_REGSIZE == 8 ? "%17s" : "%9s", 
d2537 1
a2537 1
  printf_filtered (start_regnum < MIPS_NUMREGS ? "\n R%-4d" : "\n      ", 
d2545 1
a2545 1
	continue;	/* unused register */
d2547 1
a2547 1
	break;	/* end row: reached FP register */
d2552 1
a2552 1
      for (byte = 0; byte < (MIPS_REGSIZE - REGISTER_RAW_SIZE (regnum)); byte++)
d2556 3
a2558 1
	for (byte = 0; byte < REGISTER_RAW_SIZE (regnum); byte++)
d2561 3
a2563 1
	for (byte = REGISTER_RAW_SIZE (regnum) - 1; byte >= 0; byte--)
d2568 1
a2568 1
  if (col > 0)	/* ie. if we actually printed anything... */
d2581 1
a2581 1
  if (regnum != -1)	/* do one specified register */
d2589 2
a2590 1
  else			/* do all (or most) registers */
d2595 2
a2596 2
	  if (TYPE_CODE(REGISTER_VIRTUAL_TYPE (regnum)) == TYPE_CODE_FLT)
	    if (fpregs)	/* true for "INFO ALL-REGISTERS" command */
d2611 1
a2611 1
	struct frame_info *frame;
d2613 1
a2613 1
#if 0 /* FIXME Use or lose this! */
d2655 1
a2655 1
  return is_delayed ((unsigned long)extract_unsigned_integer (buf, MIPS_INSTLEN));
d2664 1
a2664 1
     CORE_ADDR pc;	/* starting PC to search from */
d2667 11
a2677 11
    t_inst inst;
    CORE_ADDR end_pc;
    int seen_sp_adjust = 0;
    int load_immediate_bytes = 0;

    /* Skip the typical prologue instructions. These are the stack adjustment
       instruction and the instructions that save registers on the stack
       or in the gcc frame.  */
    for (end_pc = pc + 100; pc < end_pc; pc += MIPS_INSTLEN)
      {
	unsigned long high_word;
d2679 2
a2680 2
	inst = mips_fetch_instruction (pc);
	high_word = (inst >> 16) & 0xffff;
d2683 2
a2684 2
	if (lenient && is_delayed (inst))
	  continue;
d2687 58
a2744 58
	if (high_word == 0x27bd			/* addiu $sp,$sp,offset */
	    || high_word == 0x67bd)		/* daddiu $sp,$sp,offset */
	    seen_sp_adjust = 1;
	else if (inst == 0x03a1e823 || 	        /* subu $sp,$sp,$at */
		 inst == 0x03a8e823)   	        /* subu $sp,$sp,$t0 */
	    seen_sp_adjust = 1;
	else if (((inst & 0xFFE00000) == 0xAFA00000 /* sw reg,n($sp) */
		  || (inst & 0xFFE00000) == 0xFFA00000) /* sd reg,n($sp) */
		 && (inst & 0x001F0000))	/* reg != $zero */
	    continue;
						
	else if ((inst & 0xFFE00000) == 0xE7A00000) /* swc1 freg,n($sp) */
	    continue;
	else if ((inst & 0xF3E00000) == 0xA3C00000 && (inst & 0x001F0000))
						/* sx reg,n($s8) */
	    continue;				/* reg != $zero */
 
        /* move $s8,$sp.  With different versions of gas this will be either
           `addu $s8,$sp,$zero' or `or $s8,$sp,$zero' or `daddu s8,sp,$0'.
	    Accept any one of these.  */
        else if (inst == 0x03A0F021 || inst == 0x03a0f025 || inst == 0x03a0f02d)
	    continue;

	else if ((inst & 0xFF9F07FF) == 0x00800021) /* move reg,$a0-$a3 */
	    continue;
	else if (high_word == 0x3c1c) 		/* lui $gp,n */
	    continue;
	else if (high_word == 0x279c) 		/* addiu $gp,$gp,n */
	    continue;
	else if (inst == 0x0399e021		/* addu $gp,$gp,$t9 */
		 || inst == 0x033ce021)		/* addu $gp,$t9,$gp */
	  continue;
	/* The following instructions load $at or $t0 with an immediate
	   value in preparation for a stack adjustment via
	   subu $sp,$sp,[$at,$t0]. These instructions could also initialize
	   a local variable, so we accept them only before a stack adjustment
	   instruction was seen.  */
	else if (!seen_sp_adjust)
	  {
	    if (high_word == 0x3c01 ||	 	/* lui $at,n */
		high_word == 0x3c08)	  	/* lui $t0,n */
	      {
		load_immediate_bytes += MIPS_INSTLEN; /* FIXME!! */
		continue;
	      }
	    else if (high_word == 0x3421 || 	/* ori $at,$at,n */
		     high_word == 0x3508 || 	/* ori $t0,$t0,n */
		     high_word == 0x3401 || 	/* ori $at,$zero,n */
		     high_word == 0x3408)   	/* ori $t0,$zero,n */
	      {
		load_immediate_bytes += MIPS_INSTLEN; /* FIXME!! */
		continue;
	      }
	    else
	      break;
	  }
	else
	  break;
d2747 6
a2752 6
    /* In a frameless function, we might have incorrectly
       skipped some load immediate instructions. Undo the skipping
       if the load immediate was not followed by a stack adjustment.  */
    if (load_immediate_bytes && !seen_sp_adjust)
      pc -= load_immediate_bytes;
    return pc;
d2760 1
a2760 1
     CORE_ADDR pc;	/* starting PC to search from */
d2763 3
a2765 3
    CORE_ADDR end_pc;
    int extend_bytes = 0;
    int prev_extend_bytes;
d2767 2
a2768 2
    /* Table of instructions likely to be found in a function prologue.  */
    static struct
d2772 19
a2790 1
    } table[] =
d2792 39
a2830 21
      { 0x6300, 0xff00 },	/* addiu $sp,offset */
      { 0xfb00, 0xff00 },	/* daddiu $sp,offset */
      { 0xd000, 0xf800 },	/* sw reg,n($sp) */
      { 0xf900, 0xff00 },	/* sd reg,n($sp) */
      { 0x6200, 0xff00 },	/* sw $ra,n($sp) */
      { 0xfa00, 0xff00 },	/* sd $ra,n($sp) */
      { 0x673d, 0xffff },	/* move $s1,sp */
      { 0xd980, 0xff80 },	/* sw $a0-$a3,n($s1) */
      { 0x6704, 0xff1c },	/* move reg,$a0-$a3 */
      { 0xe809, 0xf81f },	/* entry pseudo-op */
      { 0x0100, 0xff00 },	/* addiu $s1,$sp,n */
      { 0, 0 }			/* end of table marker */
    };

    /* Skip the typical prologue instructions. These are the stack adjustment
       instruction and the instructions that save registers on the stack
       or in the gcc frame.  */
    for (end_pc = pc + 100; pc < end_pc; pc += MIPS16_INSTLEN)
      {
	unsigned short inst;
	int i;
d2832 1
a2832 1
	inst = mips_fetch_instruction (pc);
d2834 11
a2844 11
	/* Normally we ignore an extend instruction.  However, if it is
	   not followed by a valid prologue instruction, we must adjust
	   the pc back over the extend so that it won't be considered
	   part of the prologue.  */
	if ((inst & 0xf800) == 0xf000)		/* extend */
	  {
	    extend_bytes = MIPS16_INSTLEN;
	    continue;
	  }
	prev_extend_bytes = extend_bytes;
	extend_bytes = 0;
d2846 13
a2858 12
	/* Check for other valid prologue instructions besides extend.  */
	for (i = 0; table[i].mask != 0; i++)
	  if ((inst & table[i].mask) == table[i].inst)	/* found, get out */
	    break;
	if (table[i].mask != 0)			/* it was in table? */
	  continue;				/* ignore it */
	else					/* non-prologue */
	  {
	    /* Return the current pc, adjusted backwards by 2 if
	       the previous instruction was an extend.  */
	    return pc - prev_extend_bytes;
	  }
d2913 117
a3029 2
/* Given a return value in `regbuf' with a type `valtype', 
   extract and copy its value into `valbuf'.  */
d3032 18
a3049 4
    struct type *valtype;
    char regbuf[REGISTER_BYTES];
    char *valbuf;
{
d3053 1
a3053 1
  
d3062 1
a3062 1
    { /* "un-left-justify" the value from the register */
d3065 1
a3065 1
      if (len > REGISTER_RAW_SIZE (regnum)     &&	/* odd-size structs */
d3073 1
d3076 3
a3078 2
/* Given a return value in `regbuf' with a type `valtype', 
   write it's value into the appropriate register.  */
d3081 2
a3082 2
    struct type *valtype;
    char *valbuf;
d3084 21
d3109 1
a3109 1
  
d3118 1
a3118 1
    { /* "left-justify" the value in the register */
d3121 1
a3121 1
      if (len > REGISTER_RAW_SIZE (regnum)     &&	/* odd-size structs */
d3127 6
a3132 5
  memcpy(raw_buffer + offset, valbuf, len);
  REGISTER_CONVERT_FROM_TYPE(regnum, valtype, raw_buffer);
  write_register_bytes(REGISTER_BYTE (regnum), raw_buffer, 
		       len > REGISTER_RAW_SIZE (regnum) ? 
		       len : REGISTER_RAW_SIZE (regnum));
d3196 4
d3210 4
d3224 4
d3259 1
a3259 1
  
d3291 1
a3291 5

	  for (j = 0; j < NUM_REGS; ++j)
	    /* FIXME - MIPS should be defining REGISTER_NAME() instead */
	    gdb_register_names[j] = mips_processor_type_table[i].regnames[j];

a3292 1

d3311 1
a3311 1
    return savestring ("r3041", strlen("r3041"));
d3354 1
a3354 1
      
d3382 2
a3383 1
unsigned char *mips_breakpoint_from_pc (pcptr, lenptr)
d3393 1
a3393 1
	  *lenptr = sizeof(mips16_big_breakpoint);
d3402 1
a3402 1
	  *lenptr = sizeof(big_breakpoint);
d3420 1
a3420 1
	  *lenptr = sizeof(mips16_little_breakpoint);
d3429 1
a3429 1
	  *lenptr = sizeof(little_breakpoint);
d3448 1
a3448 1
     target PC is in $31 ($ra).
d3450 1
a3450 1
     and the target PC is in $2.
d3452 3
a3454 3
     before the jal instruction, this is effectively a call stub
     and the the target PC is in $2.  Otherwise this is effectively
     a return stub and the target PC is in $18.
d3460 1
a3460 1
*/
d3487 3
a3489 3
	 before the jal instruction, this is effectively a call stub
	 and the the target PC is in $2.  Otherwise this is effectively
	 a return stub and the target PC is in $18.  */
d3495 10
a3504 10
		 stub.  Such a stub for a function bar might have a name
		 like __fn_stub_bar, and might look like this:
		      mfc1    $4,$f13
		      mfc1    $5,$f12
		      mfc1    $6,$f15
		      mfc1    $7,$f14
		      la      $1,bar   (becomes a lui/addiu pair)
		      jr      $1
		 So scan down to the lui/addi and extract the target
		 address from those two instructions.  */
d3519 2
a3520 2
		 The limit on the search is arbitrarily set to 20
		 instructions.  FIXME.  */
d3523 5
a3527 5
		   inst = mips_fetch_instruction (target_pc);
		   if ((inst & 0xffff0000) == 0x3c010000)	/* lui $at */
		      pc = (inst << 16) & 0xffff0000;		/* high word */
		   else if ((inst & 0xffff0000) == 0x24210000)	/* addiu $at */
		      return pc | (inst & 0xffff);		/* low word */
d3539 1
a3539 1
  return 0;	/* not a stub */
d3564 1
a3564 1
	 before the jal instruction, this is effectively a call stub.  */
d3569 1
a3569 1
  return 0;	/* not a stub */
d3593 1
a3593 1
      i.e. after the jal instruction, this is effectively a return stub.  */
d3599 1
a3599 1
  return 0;	/* not a stub */
d3642 263
d3911 3
a3913 1
  if (!tm_print_insn) /* Someone may have already set it */
d3944 1
d3957 1
d3978 2
a3979 2
    (add_set_cmd ("mask-address", no_class, var_boolean, (char *)&mask_address_p,
	   "Set zeroing of upper 32 bits of 64-bit addresses.\n\
d3983 13
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d39 2
a40 3
/* Some MIPS boards don't support floating point while others only
   support single-precision floating-point operations.  See also
   FP_REGISTER_DOUBLE. */
d56 2
a57 3
#ifndef MIPS_SAVED_REGSIZE
#define MIPS_SAVED_REGSIZE MIPS_REGSIZE
#endif
a59 1
#ifndef FP_REGISTER_DOUBLE
a60 4
#endif


#define VM_MIN_ADDRESS (CORE_ADDR)0x400000
d226 1
a226 1
    return (TYPE_LENGTH (type) > 2 * MIPS_SAVED_REGSIZE);
d936 1
a936 1
	reg_position -= MIPS_SAVED_REGSIZE;
d954 1
a954 1
	    reg_position -= MIPS_SAVED_REGSIZE;
d960 1
a960 1
	      reg_position -= MIPS_SAVED_REGSIZE;
d972 1
a972 1
    reg_position += MIPS_SAVED_REGSIZE;
d980 1
a980 1
	reg_position -= MIPS_SAVED_REGSIZE;
d1002 1
a1002 1
	    return read_memory_integer(fi->saved_regs[regno], MIPS_SAVED_REGSIZE);
d1068 1
a1068 1
    saved_pc = read_memory_integer (frame->frame - MIPS_SAVED_REGSIZE, MIPS_SAVED_REGSIZE);
d1070 1
a1070 1
    saved_pc = read_next_frame_reg (frame, pcreg);
d1362 1
a1362 1
	    offset += MIPS_SAVED_REGSIZE;
d1371 1
a1371 1
	    offset -= MIPS_SAVED_REGSIZE;
d1379 1
a1379 1
	    offset -= MIPS_SAVED_REGSIZE;
d1757 1
a1757 1
#define STACK_ARGSIZE MIPS_SAVED_REGSIZE
d1785 1
a1785 1
  struct_addr = ROUND_DOWN (struct_addr, MIPS_SAVED_REGSIZE);
d1791 1
a1791 1
    len += ROUND_UP (TYPE_LENGTH(VALUE_TYPE(args[argnum])), MIPS_SAVED_REGSIZE);
d1816 1
a1816 1
      if (MIPS_EABI && len > MIPS_SAVED_REGSIZE &&
d1819 1
a1819 1
	  store_address (valbuf, MIPS_SAVED_REGSIZE, VALUE_ADDRESS (arg));
d1821 1
a1821 1
	  len = MIPS_SAVED_REGSIZE;
d1890 2
a1891 2
	  int odd_sized_struct = ((len > MIPS_SAVED_REGSIZE) && 
				  (len % MIPS_SAVED_REGSIZE != 0));
d1894 1
a1894 1
	      int partial_len = len < MIPS_SAVED_REGSIZE ? len : MIPS_SAVED_REGSIZE;
d1904 10
a1913 12
		    {
		      if (STACK_ARGSIZE == 8 &&
			  (typecode == TYPE_CODE_INT ||
			   typecode == TYPE_CODE_PTR ||
			   typecode == TYPE_CODE_FLT) && len <= 4)
			longword_offset = STACK_ARGSIZE - len;
		      else if ((typecode == TYPE_CODE_STRUCT ||
				typecode == TYPE_CODE_UNION) &&
			       TYPE_LENGTH (arg_type) < STACK_ARGSIZE)
			longword_offset = STACK_ARGSIZE - len;
		    }
		  
d1937 1
a1937 1
		      && MIPS_SAVED_REGSIZE < 8
d1939 1
a1939 1
		      && partial_len < MIPS_SAVED_REGSIZE
d1942 1
a1942 1
		    regval <<= ((MIPS_SAVED_REGSIZE - partial_len) * 
d1984 1
a1984 1
mips_push_register (CORE_ADDR *sp, int regno)
d1987 2
a1988 14
  int regsize;
  int offset;
  if (MIPS_SAVED_REGSIZE < REGISTER_RAW_SIZE (regno))
    {
      regsize = MIPS_SAVED_REGSIZE;
      offset = (TARGET_BYTE_ORDER == BIG_ENDIAN
		? REGISTER_RAW_SIZE (regno) - MIPS_SAVED_REGSIZE
		: 0);
    }
  else
    {
      regsize = REGISTER_RAW_SIZE (regno);
      offset = 0;
    }
d1991 1
a1991 1
  write_memory (*sp, buffer + offset, regsize);
d1998 1
a1998 1
mips_push_dummy_frame ()
d2049 1
a2049 1
  PROC_REG_OFFSET(proc_desc) = sp - old_sp - MIPS_SAVED_REGSIZE;
d2094 1
a2094 1
					     MIPS_SAVED_REGSIZE)); 
d2122 1
a2122 2
		      read_memory_integer (new_sp - 2*MIPS_SAVED_REGSIZE,
					   MIPS_SAVED_REGSIZE));
d2124 1
a2124 2
		      read_memory_integer (new_sp - 3*MIPS_SAVED_REGSIZE,
					   MIPS_SAVED_REGSIZE));
d2127 1
a2127 2
			read_memory_integer (new_sp - 4*MIPS_SAVED_REGSIZE,
					     MIPS_SAVED_REGSIZE));
d2617 2
a2618 117
/* Determine how a return value is stored within the MIPS register
   file, given the return type `valtype'. */

struct return_value_word
{
  int len;
  int reg;
  int reg_offset;
  int buf_offset;
};

static void return_value_location PARAMS ((struct type *, struct return_value_word *, struct return_value_word *));

static void
return_value_location (valtype, hi, lo)
     struct type *valtype;
     struct return_value_word *hi;
     struct return_value_word *lo;
{
  int len = TYPE_LENGTH (valtype);
  
  if (TYPE_CODE (valtype) == TYPE_CODE_FLT
      && ((MIPS_FPU_TYPE == MIPS_FPU_DOUBLE && (len == 4 || len == 8))
	  || (MIPS_FPU_TYPE == MIPS_FPU_SINGLE && len == 4)))
    {
      if (!FP_REGISTER_DOUBLE && len == 8)
	{
	  /* We need to break a 64bit float in two 32 bit halves and
             spread them across a floating-point register pair. */
	  lo->buf_offset = TARGET_BYTE_ORDER == BIG_ENDIAN ? 4 : 0;
	  hi->buf_offset = TARGET_BYTE_ORDER == BIG_ENDIAN ? 0 : 4;
	  lo->reg_offset = ((TARGET_BYTE_ORDER == BIG_ENDIAN
			     && REGISTER_RAW_SIZE (FP0_REGNUM) == 8)
			    ? 4 : 0);
	  hi->reg_offset = lo->reg_offset;
	  lo->reg = FP0_REGNUM + 0;
	  hi->reg = FP0_REGNUM + 1;
	  lo->len = 4;
	  hi->len = 4;
	}
      else
	{
	  /* The floating point value fits in a single floating-point
             register. */
	  lo->reg_offset = ((TARGET_BYTE_ORDER == BIG_ENDIAN
			     && REGISTER_RAW_SIZE (FP0_REGNUM) == 8
			     && len == 4)
			    ? 4 : 0);
	  lo->reg = FP0_REGNUM;
	  lo->len = len;
	  lo->buf_offset = 0;
	  hi->len = 0;
	  hi->reg_offset = 0;
	  hi->buf_offset = 0;
	  hi->reg = 0;
	}
    }
  else
    {
      /* Locate a result possibly spread across two registers. */
      int regnum = 2;
      lo->reg = regnum + 0;
      hi->reg = regnum + 1;
      if (TARGET_BYTE_ORDER == BIG_ENDIAN
	  && len < MIPS_SAVED_REGSIZE)
	{
	  /* "un-left-justify" the value in the low register */
	  lo->reg_offset = MIPS_SAVED_REGSIZE - len;
	  lo->len = len;
	  hi->reg_offset = 0;
	  hi->len = 0;
	}
      else if (TARGET_BYTE_ORDER == BIG_ENDIAN
	       && len > MIPS_SAVED_REGSIZE	/* odd-size structs */
	       && len < MIPS_SAVED_REGSIZE * 2
	       && (TYPE_CODE (valtype) == TYPE_CODE_STRUCT ||
		   TYPE_CODE (valtype) == TYPE_CODE_UNION))
	{
	  /* "un-left-justify" the value spread across two registers. */
	  lo->reg_offset = 2 * MIPS_SAVED_REGSIZE - len;
	  lo->len = MIPS_SAVED_REGSIZE - lo->reg_offset;
	  hi->reg_offset = 0;
	  hi->len = len - lo->len;
	}
      else
	{
	  /* Only perform a partial copy of the second register. */
	  lo->reg_offset = 0;
	  hi->reg_offset = 0;
	  if (len > MIPS_SAVED_REGSIZE)
	    {
	      lo->len = MIPS_SAVED_REGSIZE;
	      hi->len = len - MIPS_SAVED_REGSIZE;
	    }
	  else
	    {
	      lo->len = len;
	      hi->len = 0;
	    }
	}
      if (TARGET_BYTE_ORDER == BIG_ENDIAN
	  && REGISTER_RAW_SIZE (regnum) == 8
	  && MIPS_SAVED_REGSIZE == 4)
	{
	  /* Account for the fact that only the least-signficant part
             of the register is being used */
	  lo->reg_offset += 4;
	  hi->reg_offset += 4;
	}
      lo->buf_offset = 0;
      hi->buf_offset = lo->len;
    }
}

/* Given a return value in `regbuf' with a type `valtype', extract and
   copy its value into `valbuf'. */

a2624 14
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &lo, &hi);

  memcpy (valbuf + lo.buf_offset,
	  regbuf + REGISTER_BYTE (lo.reg) + lo.reg_offset,
	  lo.len);

  if (hi.len > 0)
    memcpy (valbuf + hi.buf_offset,
	    regbuf + REGISTER_BYTE (hi.reg) + hi.reg_offset,
	    hi.len);

#if 0
a2647 1
#endif
d2650 2
a2651 3
/* Given a return value in `valbuf' with a type `valtype', write it's
   value into the appropriate register. */

a2656 21
  char raw_buffer[MAX_REGISTER_RAW_SIZE];
  struct return_value_word lo;
  struct return_value_word hi;
  return_value_location (valtype, &lo, &hi);

  memset (raw_buffer, 0, sizeof (raw_buffer));
  memcpy (raw_buffer + lo.reg_offset, valbuf + lo.buf_offset, lo.len);
  write_register_bytes (REGISTER_BYTE (lo.reg),
			raw_buffer,
			REGISTER_RAW_SIZE (lo.reg));
  
  if (hi.len > 0)
    {
      memset (raw_buffer, 0, sizeof (raw_buffer));
      memcpy (raw_buffer + hi.reg_offset, valbuf + hi.buf_offset, hi.len);
      write_register_bytes (REGISTER_BYTE (hi.reg),
			    raw_buffer,
			    REGISTER_RAW_SIZE (hi.reg));
    }

#if 0
a2683 1
#endif
@


1.1.1.3
log
@import gdb-1999-05-10
@
text
@d1156 4
a1159 2
		warning ("Warning: GDB can't find the start of the function at 0x%s.", 
			 paddr_nz (pc));
d1161 1
d1164 7
a1170 18
		    /* This actually happens frequently in embedded
		       development, when you first connect to a board
		       and your stack pointer and pc are nowhere in
		       particular.  This message needs to give people
		       in that situation enough information to
		       determine that it's no big deal.  */
		    printf_filtered ("\n\
    GDB is unable to find the start of the function at 0x%s\n\
and thus can't determine the size of that function's stack frame.\n\
This means that GDB may be unable to access that stack frame, or\n\
the frames below it.\n\
    This problem is most likely caused by an invalid program counter or\n\
stack pointer.\n\
    However, if you think GDB should simply search farther back\n\
from 0x%s for code which looks like the beginning of a\n\
function, you can increase the range of the search using the `set\n\
heuristic-fence-post' command.\n",
				     paddr_nz (pc), paddr_nz (pc));
@


1.1.1.4
log
@import gdb-1999-06-07 snapshot
@
text
@a38 6
struct frame_extra_info
{
  mips_extra_func_info_t proc_desc;
  int num_args;
};

d109 1
a109 10
char *mips_generic_reg_names[] = MIPS_REGISTER_NAMES;
char **mips_processor_reg_names = mips_generic_reg_names;

char *
mips_register_name (i)
     int i;
{
  return mips_processor_reg_names[i];
}

a221 12
void
mips_print_extra_frame_info (fi)
     struct frame_info *fi;
{
  if (fi
      && fi->extra_info
      && fi->extra_info->proc_desc
      && fi->extra_info->proc_desc->pdr.framereg < NUM_REGS)
    printf_filtered (" frame pointer is at %s+%d\n",
		     REGISTER_NAME (fi->extra_info->proc_desc->pdr.framereg),
		     fi->extra_info->proc_desc->pdr.frameoffset);
}
d876 1
a876 1
  proc_desc = fci->extra_info->proc_desc;
d1068 1
a1068 1
  mips_extra_func_info_t proc_desc = frame->extra_info->proc_desc;
d1083 1
a1083 1
static CORE_ADDR temp_saved_regs[NUM_REGS];
d1095 2
a1096 2
  if (temp_saved_regs[regno] == 0)
    temp_saved_regs[regno] = offset;
d1408 1
a1408 1
  memset (temp_saved_regs, '\0', SIZEOF_FRAME_SAVED_REGS);
d1511 1
a1511 1
  memset (&temp_saved_regs, '\0', SIZEOF_FRAME_SAVED_REGS);
d1679 1
a1679 2
mips_init_extra_frame_info(fromleaf, fci)
     int fromleaf;
a1687 3
  fci->extra_info = (struct frame_extra_info *)
    frame_obstack_alloc (sizeof (struct frame_extra_info));

d1689 1
a1689 1
  fci->extra_info->proc_desc =
d1714 3
a1716 2
              frame_saved_regs_zalloc (fci);
	      memcpy (fci->saved_regs, temp_saved_regs, SIZEOF_FRAME_SAVED_REGS);
d1723 1
a1723 2
      /* assume we can't tell how many args for now */
      fci->extra_info->num_args = -1;
d1728 1
a1728 1
	      fci->extra_info->num_args = regnum - A0_REGNUM + 1;
d2112 1
a2112 1
  mips_extra_func_info_t proc_desc = frame->extra_info->proc_desc;
d3015 5
a3019 1
	  mips_processor_reg_names = mips_processor_type_table[i].regnames;
d3021 1
@


1.1.1.5
log
@import gdb-1999-06-14 snapshot
@
text
@a2022 9
  /* Return adjusted stack pointer.  */
  return sp;
}

CORE_ADDR
mips_push_return_address (pc, sp)
     CORE_ADDR pc;
     CORE_ADDR sp;
{
d2026 2
@


1.1.1.6
log
@import gdb-1999-07-07 pre reformat
@
text
@a125 1
/* *INDENT-OFF* */
a205 1
/* *INDENT-ON* */
@


1.1.1.7
log
@import gdb-1999-07-07 post reformat
@
text
@d7 1
a7 1
   This file is part of GDB.
d9 13
a21 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d40 4
a43 4
  {
    mips_extra_func_info_t proc_desc;
    int num_args;
  };
d50 5
a54 5
  {
    MIPS_FPU_DOUBLE,		/* Full double precision floating point.  */
    MIPS_FPU_SINGLE,		/* Single precision floating point (R4650).  */
    MIPS_FPU_NONE		/* No floating point.  */
  };
d84 1
a84 1
  heuristic_proc_desc PARAMS ((CORE_ADDR, CORE_ADDR, struct frame_info *));
d100 1
a100 1
  find_proc_desc PARAMS ((CORE_ADDR pc, struct frame_info * next_frame));
d124 2
a208 3



d210 1
a210 2
static int mips16_to_32_reg[8] =
{16, 17, 2, 3, 4, 5, 6, 7};
d218 2
a219 2
#define PROC_LOW_ADDR(proc) ((proc)->pdr.adr)	/* least address */
#define PROC_HIGH_ADDR(proc) ((proc)->high_addr)	/* upper address bound */
d234 4
a237 5
  {
    struct mips_extra_func_info info;
    struct linked_proc_info *next;
  }
 *linked_proc_desc_table = NULL;
d264 1
a264 1
    return 1;			/* Structures are returned by ref in extra arg0 */
d306 1
a306 1
         strongly suspect that frameless always means prologueless... */
d344 4
a347 4
         find the offset, rather than the code below which
         is based on things being in a certain order in the
         frame, but figuring out what the instruction's offset
         is relative to might be a little tricky.  */
d352 2
a353 2
	   || (inst & 0xffe00000) == 0xe7c00000		/* swc1 freg,n($r30) */
	   || (inst & 0xffe00000) == 0xf7a00000)	/* sdc1 freg,n($sp) */
d371 1
a371 1
  if ((inst & 0xf800) == 0xd000)	/* sw reg,n($sp) */
d376 1
a376 1
  else if ((inst & 0xff00) == 0xf900)	/* sd reg,n($sp) */
d381 1
a381 1
  else if ((inst & 0xff00) == 0x6200	/* sw $ra,n($sp) */
d392 1
a392 1
     CORE_ADDR addr;
d404 1
a404 1
    instlen = MIPS_INSTLEN;
d425 1
a425 1
#define rtype_rd(x) ((x>>11) & 0x1f)
d430 4
a433 5
mips32_relative_offset (unsigned long inst)
{
  long x;
  x = itype_immediate (inst);
  if (x & 0x8000)		/* sign bit set */
d435 1
a435 1
      x |= 0xffff0000;		/* sign extension */
d437 2
a438 2
  x = x << 2;
  return x;
d444 1
a444 1
mips32_next_pc (CORE_ADDR pc)
d446 6
a451 8
  unsigned long inst;
  int op;
  inst = mips_fetch_instruction (pc);
  if ((inst & 0xe0000000) != 0)	/* Not a special, junp or branch instruction */
    {
      if ((inst >> 27) == 5)	/* BEQL BNEZ BLEZL BGTZE , bits 0101xx */
	{
	  op = ((inst >> 25) & 0x03);
d454 5
a458 10
	    case 0:
	      goto equal_branch;	/* BEQL   */
	    case 1:
	      goto neq_branch;	/* BNEZ   */
	    case 2:
	      goto less_branch;	/* BLEZ   */
	    case 3:
	      goto greater_branch;	/* BGTZ */
	    default:
	      pc += 4;
d461 1
a461 2
      else
	pc += 4;		/* Not a branch, next instruction is easy */
d464 2
a465 2
    {				/* This gets way messy */

d467 1
a467 1
      switch (op = ((inst >> 26) & 0x07))	/* extract bits 28,27,26 */
d469 13
a481 14
	case 0:		/* SPECIAL */
	  op = rtype_funct (inst);
	  switch (op)
	    {
	    case 8:		/* JR */
	    case 9:		/* JALR */
	      pc = read_register (rtype_rs (inst));	/* Set PC to that address */
	      break;
	    default:
	      pc += 4;
	    }

	  break;		/* end special */
	case 1:		/* REGIMM */
d483 2
a484 2
	    op = jtype_op (inst);	/* branch condition */
	    switch (jtype_op (inst))
d486 4
a489 4
	      case 0:		/* BLTZ */
	      case 2:		/* BLTXL */
	      case 16:		/* BLTZALL */
	      case 18:		/* BLTZALL */
d491 8
a498 9
		if (read_register (itype_rs (inst)) < 0)
		  pc += mips32_relative_offset (inst) + 4;
		else
		  pc += 8;	/* after the delay slot */
		break;
	      case 1:		/* GEZ */
	      case 3:		/* BGEZL */
	      case 17:		/* BGEZAL */
	      case 19:		/* BGEZALL */
d500 6
a505 8
		if (read_register (itype_rs (inst)) >= 0)
		  pc += mips32_relative_offset (inst) + 4;
		else
		  pc += 8;	/* after the delay slot */
		break;
		/* All of the other intructions in the REGIMM catagory */
	      default:
		pc += 4;
d508 6
a513 7
	  break;		/* end REGIMM */
	case 2:		/* J */
	case 3:		/* JAL */
	  {
	    unsigned long reg;
	    reg = jtype_target (inst) << 2;
	    pc = reg + ((pc + 4) & 0xf0000000);
d516 5
a520 6
	  break;
	  /* FIXME case JALX : */
	  {
	    unsigned long reg;
	    reg = jtype_target (inst) << 2;
	    pc = reg + ((pc + 4) & 0xf0000000) + 1;	/* yes, +1 */
d523 16
a538 18
	  break;		/* The new PC will be alternate mode */
	case 4:		/* BEQ , BEQL */
	equal_branch:
	  if (read_register (itype_rs (inst)) ==
	      read_register (itype_rt (inst)))
	    pc += mips32_relative_offset (inst) + 4;
	  else
	    pc += 8;
	  break;
	case 5:		/* BNE , BNEL */
	neq_branch:
	  if (read_register (itype_rs (inst)) !=
	      read_register (itype_rs (inst)))
	    pc += mips32_relative_offset (inst) + 4;
	  else
	    pc += 8;
	  break;
	case 6:		/* BLEZ , BLEZL */
d540 15
a554 18
	  if (read_register (itype_rs (inst) <= 0))
	    pc += mips32_relative_offset (inst) + 4;
	  else
	    pc += 8;
	  break;
	case 7:
	greater_branch:	/* BGTZ BGTZL */
	  if (read_register (itype_rs (inst) > 0))
	    pc += mips32_relative_offset (inst) + 4;
	  else
	    pc += 8;
	  break;
	default:
	  pc += 8;
	}			/* switch */
    }				/* else */
  return pc;
}				/* mips32_next_pc */
d561 1
a561 1
 */
d566 1
a566 1
 */
d569 23
a591 23
  itype,			/* 0  immediate 5,10 */
  ritype,			/* 1   5,3,8 */
  rrtype,			/* 2   5,3,3,5 */
  rritype,			/* 3   5,3,3,5 */
  rrrtype,			/* 4   5,3,3,3,2 */
  rriatype,			/* 5   5,3,3,1,4 */
  shifttype,			/* 6   5,3,3,3,2 */
  i8type,			/* 7   5,3,8 */
  i8movtype,			/* 8   5,3,3,5 */
  i8mov32rtype,			/* 9   5,3,5,3 */
  i64type,			/* 10  5,3,8 */
  ri64type,			/* 11  5,3,3,5 */
  jalxtype,			/* 12  5,1,5,5,16 - a 32 bit instruction */
  exiItype,			/* 13  5,6,5,5,1,1,1,1,1,1,5 */
  extRitype,			/* 14  5,6,5,5,3,1,1,1,5 */
  extRRItype,			/* 15  5,5,5,5,3,3,5 */
  extRRIAtype,			/* 16  5,7,4,5,3,3,1,4 */
  EXTshifttype,			/* 17  5,5,1,1,1,1,1,1,5,3,3,1,1,1,2 */
  extI8type,			/* 18  5,6,5,5,3,1,1,1,5 */
  extI64type,			/* 19  5,6,5,5,3,1,1,1,5 */
  extRi64type,			/* 20  5,6,5,5,3,3,5 */
  extshift64type		/* 21  5,5,1,1,1,1,1,1,5,1,1,1,3,5 */
};
d595 7
a601 7
  {
    unsigned short inst;
    enum mips16_inst_fmts fmt;
    unsigned long offset;
    unsigned int regx;		/* Function in i8 type */
    unsigned int regy;
  };
d605 2
a606 3
static void
print_unpack (char *comment,
	      struct upk_mips16 *u)
d608 2
a609 2
  printf ("%s %04x ,f(%d) off(%08x) (x(%x) y(%x)\n",
	  comment, u->inst, u->fmt, u->offset, u->regx, u->regy);
d614 1
a614 1
 */
d616 1
a616 1
extended_offset (unsigned long extension)
d618 7
a624 7
  unsigned long value;
  value = (extension >> 21) & 0x3f;	/* * extract 15:11 */
  value = value << 6;
  value |= (extension >> 16) & 0x1f;	/* extrace 10:5 */
  value = value << 5;
  value |= extension & 0x01f;	/* extract 4:0 */
  return value;
d631 1
a631 1
 */
d636 1
a636 2
static unsigned short
fetch_mips_16 (CORE_ADDR pc)
d638 4
a641 4
  char buf[8];
  pc &= 0xfffffffe;		/* clear the low order bit */
  target_read_memory (pc, buf, 2);
  return extract_unsigned_integer (buf, 2);
d645 2
a646 2
unpack_mips16 (CORE_ADDR pc,
	       struct upk_mips16 *upk)
d648 4
a651 4
  CORE_ADDR extpc;
  unsigned long extension;
  int extended;
  extpc = (pc - 4) & ~0x01;	/* Extensions are 32 bit instructions */
d654 2
a655 5
  extended = ((mips32_op (extension) == 30) ? 1 : 0);
  if (extended)
    {
      extension = mips_fetch_instruction (extpc);
    }
d658 1
a658 1
    case itype:
d660 1
a660 1
	unsigned long value;
d662 3
a664 4
	  {
	    value = extended_offset (extension);
	    value = value << 11;	/* rom for the original value */
	    value |= upk->inst & 0x7ff;		/* eleven bits from instruction */
d667 2
a668 3
	  {
	    value = upk->inst & 0x7ff;
	    /* FIXME : Consider sign extension */
d670 1
a670 1
	upk->offset = value;
d672 4
a675 4
      break;
    case ritype:
    case i8type:
      {				/* A register identifier and an offset */
d678 1
a678 1
	unsigned long value;
d681 7
a687 8
	    value = extended_offset (extension);
	    value = value << 8;	/* from the original instruction */
	    value |= upk->inst & 0xff;	/* eleven bits from instruction */
	    upk->regx = (extension >> 8) & 0x07;	/* or i8 funct */
	    if (value & 0x4000)	/* test the sign bit , bit 26 */
	      {
		value &= ~0x3fff;	/* remove the sign bit */
		value = -value;
d690 12
a701 14
	else
	  {
	    value = upk->inst & 0xff;	/* 8 bits */
	    upk->regx = (upk->inst >> 8) & 0x07;	/* or i8 funct */
	    /* FIXME: Do sign extension , this format needs it */
	    if (value & 0x80)	/* THIS CONFUSES ME */
	      {
		value &= 0xef;	/* remove the sign bit */
		value = -value;
	      }

	  }
	upk->offset = value;
	break;
d703 1
a703 1
    case jalxtype:
d705 8
a712 8
	unsigned long value;
	unsigned short nexthalf;
	value = ((upk->inst & 0x1f) << 5) | ((upk->inst >> 5) & 0x1f);
	value = value << 16;
	nexthalf = mips_fetch_instruction (pc + 2);	/* low bit still set */
	value |= nexthalf;
	upk->offset = value;
	break;
d715 2
a716 2
      printf_filtered ("Decoding unimplemented instruction format type\n");
      break;
d726 5
a730 5
{0, 0, 1, 1, 1, 1, 0, 0,
 0, 0, 0, 0, 1, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 1, 1, 0
};
d732 1
a732 2
static CORE_ADDR
add_offset_16 (CORE_ADDR pc, int offset)
d734 2
a735 2
  return ((offset << 2) | ((pc + 2) & (0xf0000000)));

d740 1
a740 1
static struct upk_mips16 upk;
d742 1
a742 2
CORE_ADDR
mips16_next_pc (CORE_ADDR pc)
d744 2
a745 2
  int op;
  t_inst inst;
d747 3
a749 3
  inst = fetch_mips_16 (pc);
  upk.inst = inst;
  op = mips16_op (upk.inst);
d752 1
a752 1
      int reg;
d755 5
a759 6
	case 2:		/* Branch */
	  upk.fmt = itype;
	  unpack_mips16 (pc, &upk);
	  {
	    long offset;
	    offset = upk.offset;
d761 2
a762 3
	      {
		offset &= 0xeff;
		offset = -offset;
d764 1
a764 1
	    pc += (offset << 1) + 2;
d766 39
a804 43
	  break;
	case 3:		/* JAL , JALX - Watch out, these are 32 bit instruction */
	  upk.fmt = jalxtype;
	  unpack_mips16 (pc, &upk);
	  pc = add_offset_16 (pc, upk.offset);
	  if ((upk.inst >> 10) & 0x01)	/* Exchange mode */
	    pc = pc & ~0x01;	/* Clear low bit, indicate 32 bit mode */
	  else
	    pc |= 0x01;
	  break;
	case 4:		/* beqz */
	  upk.fmt = ritype;
	  unpack_mips16 (pc, &upk);
	  reg = read_register (upk.regx);
	  if (reg == 0)
	    pc += (upk.offset << 1) + 2;
	  else
	    pc += 2;
	  break;
	case 5:		/* bnez */
	  upk.fmt = ritype;
	  unpack_mips16 (pc, &upk);
	  reg = read_register (upk.regx);
	  if (reg != 0)
	    pc += (upk.offset << 1) + 2;
	  else
	    pc += 2;
	  break;
	case 12:		/* I8 Formats btez btnez */
	  upk.fmt = i8type;
	  unpack_mips16 (pc, &upk);
	  /* upk.regx contains the opcode */
	  reg = read_register (24);	/* Test register is 24 */
	  if (((upk.regx == 0) && (reg == 0))	/* BTEZ */
	      || ((upk.regx == 1) && (reg != 0)))	/* BTNEZ */
	    /* pc = add_offset_16(pc,upk.offset) ; */
	    pc += (upk.offset << 1) + 2;
	  else
	    pc += 2;
	  break;
	case 29:		/* RR Formats JR, JALR, JALR-RA */
	  upk.fmt = rrtype;
	  op = upk.inst & 0x1f;
d806 3
a808 3
	    {
	      upk.regx = (upk.inst >> 8) & 0x07;
	      upk.regy = (upk.inst >> 5) & 0x07;
d811 4
a814 12
		case 0:
		  reg = upk.regx;
		  break;
		case 1:
		  reg = 31;
		  break;	/* Function return instruction */
		case 2:
		  reg = upk.regx;
		  break;
		default:
		  reg = 31;
		  break;	/* BOGUS Guess */
d816 1
a816 1
	      pc = read_register (reg);
d818 9
a826 10
	  else
	    pc += 2;
	  break;
	case 30:		/* This is an extend instruction */
	  pc += 4;		/* Dont be setting breakpints on the second half */
	  break;
	default:
	  printf ("Filtered - next PC probably incorrrect due to jump inst\n");
	  pc += 2;
	  break;
d829 1
a829 2
  else
    pc += 2;			/* just a good old instruction */
d832 2
a833 2
  return pc;
}				/* mips16_next_pc */
d840 2
a841 3
 */
CORE_ADDR
mips_next_pc (CORE_ADDR pc)
d843 1
a843 1
  t_inst inst;
d846 4
a849 5
  if (pc & 0x01)
    return mips16_next_pc (pc);
  else
    return mips32_next_pc (pc);
}				/* mips_next_pc */
d891 3
a893 3
	  reg_position = fci->frame + SIGFRAME_REGSAVE_OFF
	    + ireg * SIGFRAME_REG_SIZE;
	  fci->saved_regs[ireg] = reg_position;
d897 3
a899 3
	  reg_position = fci->frame + SIGFRAME_FPREGSAVE_OFF
	    + ireg * SIGFRAME_REG_SIZE;
	  fci->saved_regs[FP0_REGNUM + ireg] = reg_position;
d912 23
a934 23
  kernel_trap = PROC_REG_MASK (proc_desc) & 1;
  gen_mask = kernel_trap ? 0xFFFFFFFF : PROC_REG_MASK (proc_desc);
  float_mask = kernel_trap ? 0xFFFFFFFF : PROC_FREG_MASK (proc_desc);

  if (				/* In any frame other than the innermost or a frame interrupted by
				   a signal, we assume that all registers have been saved.
				   This assumes that all register saves in a function happen before
				   the first function call.  */
       (fci->next == NULL || fci->next->signal_handler_caller)

  /* In a dummy frame we know exactly where things are saved.  */
       && !PROC_DESC_IS_DUMMY (proc_desc)

  /* Don't bother unless we are inside a function prologue.  Outside the
     prologue, we know where everything is. */

       && in_prologue (fci->pc, PROC_LOW_ADDR (proc_desc))

  /* Not sure exactly what kernel_trap means, but if it means
     the kernel saves the registers without a prologue doing it,
     we better not examine the prologue to see whether registers
     have been saved yet.  */
       && !kernel_trap)
d937 1
a937 1
         claims are saved have been saved yet.  */
d968 1
a968 1
  for (ireg = MIPS_NUMREGS - 1; gen_mask; --ireg, gen_mask <<= 1)
d982 1
a982 1
      if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)		/* entry */
d986 1
a986 1

d993 1
a993 1
	  for (reg = 16; reg < sreg_count + 16; reg++)
d1007 1
a1007 1
  if (!GDB_TARGET_IS_MIPS64)
d1012 1
a1012 1
  for (ireg = MIPS_NUMREGS - 1; float_mask; --ireg, float_mask <<= 1)
d1015 1
a1015 1
	fci->saved_regs[FP0_REGNUM + ireg] = reg_position;
d1023 1
a1023 1
read_next_frame_reg (fi, regno)
d1030 1
a1030 1
         if it is a signal handler frame.  */
d1038 1
a1038 1
	    return read_memory_integer (fi->saved_regs[regno], MIPS_SAVED_REGSIZE);
d1048 1
a1048 1
     CORE_ADDR addr;
d1051 1
a1051 1
  if (mask_address_p && (addr >> 32 == (CORE_ADDR) 0xffffffff))
d1054 13
a1066 13
         the simulator, and any other 64-bit targets that doesn't have
         true 64-bit addressing.  On these targets, the upper 32 bits
         of addresses are ignored by the hardware.  Thus, the PC or SP
         are likely to have been sign extended to all 1s by instruction
         sequences that load 32-bit addresses.  For example, a typical
         piece of code that loads an address is this:
         lui $r2, <upper 16 bits>
         ori $r2, <lower 16 bits>
         But the lui sign-extends the value such that the upper 32 bits
         may be all 1s.  The workaround is simply to mask off these bits.
         In the future, gcc may be changed to support true 64-bit
         addressing, and this masking will have to be disabled.  */
      addr &= (CORE_ADDR) 0xffffffff;
d1072 1
a1072 1
  addr &= (CORE_ADDR) 0xffffffff;
d1086 1
a1086 1
	prev->next ? FRAME_SAVED_PC (prev->next) : read_pc ());
d1088 1
a1088 1
  prev->pc = tmp ? tmp : pc;
d1093 1
a1093 1
mips_frame_saved_pc (frame)
d1101 1
a1101 1
  : (proc_desc ? PROC_PC_REG (proc_desc) : RA_REGNUM);
d1103 1
a1103 1
  if (proc_desc && PROC_DESC_IS_DUMMY (proc_desc))
d1132 1
a1132 1
static int
d1155 1
a1155 1
     CORE_ADDR pc;
d1157 19
a1175 26
  CORE_ADDR start_pc;
  CORE_ADDR fence;
  int instlen;
  int seen_adjsp = 0;

  pc = ADDR_BITS_REMOVE (pc);
  start_pc = pc;
  fence = start_pc - heuristic_fence_post;
  if (start_pc == 0)
    return 0;

  if (heuristic_fence_post == UINT_MAX
      || fence < VM_MIN_ADDRESS)
    fence = VM_MIN_ADDRESS;

  instlen = pc_is_mips16 (pc) ? MIPS16_INSTLEN : MIPS_INSTLEN;

  /* search back for previous return */
  for (start_pc -= instlen;; start_pc -= instlen)
    if (start_pc < fence)
      {
	/* It's not clear to me why we reach this point when
	   stop_soon_quietly, but with this test, at least we
	   don't print out warnings for every child forked (eg, on
	   decstation).  22apr93 rich@@cygnus.com.  */
	if (!stop_soon_quietly)
d1177 7
a1183 1
	    static int blurb_printed = 0;
d1185 12
a1196 12
	    warning ("Warning: GDB can't find the start of the function at 0x%s.",
		     paddr_nz (pc));

	    if (!blurb_printed)
	      {
		/* This actually happens frequently in embedded
		   development, when you first connect to a board
		   and your stack pointer and pc are nowhere in
		   particular.  This message needs to give people
		   in that situation enough information to
		   determine that it's no big deal.  */
		printf_filtered ("\n\
d1207 3
a1209 2
				 paddr_nz (pc), paddr_nz (pc));
		blurb_printed = 1;
d1211 2
d1214 3
d1218 23
a1240 29
	return 0;
      }
    else if (pc_is_mips16 (start_pc))
      {
	unsigned short inst;

	/* On MIPS16, any one of the following is likely to be the
	   start of a function:
	   entry
	   addiu sp,-n
	   daddiu sp,-n
	   extend -n followed by 'addiu sp,+n' or 'daddiu sp,+n'  */
	inst = mips_fetch_instruction (start_pc);
	if (((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)	/* entry */
	    || (inst & 0xff80) == 0x6380	/* addiu sp,-n */
	    || (inst & 0xff80) == 0xfb80	/* daddiu sp,-n */
	    || ((inst & 0xf810) == 0xf010 && seen_adjsp))	/* extend -n */
	  break;
	else if ((inst & 0xff00) == 0x6300	/* addiu sp */
		 || (inst & 0xff00) == 0xfb00)	/* daddiu sp */
	  seen_adjsp = 1;
	else
	  seen_adjsp = 0;
      }
    else if (mips_about_to_return (start_pc))
      {
	start_pc += 2 * MIPS_INSTLEN;	/* skip return, and its delay slot */
	break;
      }
d1243 3
a1245 3
  /* skip nops (usually 1) 0 - is this */
  while (start_pc < pc && read_memory_integer (start_pc, MIPS_INSTLEN) == 0)
    start_pc += MIPS_INSTLEN;
d1247 1
a1247 1
  return start_pc;
d1257 5
a1261 5
     unsigned short prev_inst;	/* previous instruction */
     unsigned short inst;	/* current instruction */
     int nbits;			/* number of bits in imm field */
     int scale;			/* scale factor to be applied to imm */
     int is_signed;		/* is the imm field signed? */
d1268 1
a1268 1
      if (offset & 0x8000)	/* check for negative extend */
d1290 4
a1293 4
mips16_heuristic_proc_desc (start_pc, limit_pc, next_frame, sp)
     CORE_ADDR start_pc, limit_pc;
     struct frame_info *next_frame;
     CORE_ADDR sp;
d1302 2
a1303 2
  PROC_FRAME_OFFSET (&temp_proc_desc) = 0;	/* size of stack frame */
  PROC_FRAME_ADJUST (&temp_proc_desc) = 0;	/* offset of FP from SP */
d1313 1
a1313 1
      if ((inst & 0xff00) == 0x6300	/* addiu sp */
d1317 2
a1318 2
	  if (offset < 0)	/* negative stack adjustment? */
	    PROC_FRAME_OFFSET (&temp_proc_desc) -= offset;
d1329 1
a1329 1
	  PROC_REG_MASK (&temp_proc_desc) |= (1 << reg);
d1336 1
a1336 1
	  PROC_REG_MASK (&temp_proc_desc) |= (1 << reg);
d1342 1
a1342 1
	  PROC_REG_MASK (&temp_proc_desc) |= (1 << RA_REGNUM);
d1348 1
a1348 1
	  PROC_REG_MASK (&temp_proc_desc) |= (1 << RA_REGNUM);
d1351 1
a1351 1
      else if (inst == 0x673d)	/* move $s1, $sp */
d1367 1
a1367 1
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << reg;
d1374 1
a1374 1
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << reg;
d1377 2
a1378 2
      else if ((inst & 0xf81f) == 0xe809 && (inst & 0x700) != 0x700)	/* entry */
	entry_inst = inst;	/* save for later processing */
d1380 1
a1380 1
	cur_pc += MIPS16_INSTLEN;	/* 32-bit instruction */
d1383 10
a1392 10
  /* The entry instruction is typically the first instruction in a function,
     and it stores registers at offsets relative to the value of the old SP
     (before the prologue).  But the value of the sp parameter to this
     function is the new SP (after the prologue has been executed).  So we
     can't calculate those offsets until we've seen the entire prologue,
     and can calculate what the old SP must have been. */
  if (entry_inst != 0)
    {
      int areg_count = (entry_inst >> 8) & 7;
      int sreg_count = (entry_inst >> 6) & 3;
d1394 2
a1395 2
      /* The entry instruction always subtracts 32 from the SP.  */
      PROC_FRAME_OFFSET (&temp_proc_desc) += 32;
d1397 3
a1399 3
      /* Now we can calculate what the SP must have been at the
         start of the function prologue.  */
      sp += PROC_FRAME_OFFSET (&temp_proc_desc);
d1401 7
a1407 7
      /* Check if a0-a3 were saved in the caller's argument save area.  */
      for (reg = 4, offset = 0; reg < areg_count + 4; reg++)
	{
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << reg;
	  set_reg_offset (reg, sp + offset);
	  offset += MIPS_SAVED_REGSIZE;
	}
d1409 8
a1416 8
      /* Check if the ra register was pushed on the stack.  */
      offset = -4;
      if (entry_inst & 0x20)
	{
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << RA_REGNUM;
	  set_reg_offset (RA_REGNUM, sp + offset);
	  offset -= MIPS_SAVED_REGSIZE;
	}
d1418 8
a1425 8
      /* Check if the s0 and s1 registers were pushed on the stack.  */
      for (reg = 16; reg < sreg_count + 16; reg++)
	{
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << reg;
	  set_reg_offset (reg, sp + offset);
	  offset -= MIPS_SAVED_REGSIZE;
	}
    }
d1429 4
a1432 4
mips32_heuristic_proc_desc (start_pc, limit_pc, next_frame, sp)
     CORE_ADDR start_pc, limit_pc;
     struct frame_info *next_frame;
     CORE_ADDR sp;
d1435 1
a1435 1
  CORE_ADDR frame_addr = 0;	/* Value of $r30. Used by gcc for frame-pointer */
d1438 1
a1438 1
  PROC_FRAME_OFFSET (&temp_proc_desc) = 0;
d1453 1
a1453 1
      if (high_word == 0x27bd	/* addiu $sp,$sp,-i */
d1458 1
a1458 1
	    PROC_FRAME_OFFSET (&temp_proc_desc) += 0x10000 - low_word;
d1467 1
a1467 1
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << reg;
d1475 1
a1475 1
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << reg;
d1478 1
a1478 1
      else if (high_word == 0x27be)	/* addiu $30,$sp,size */
d1481 2
a1482 2
	  if ((long) low_word != PROC_FRAME_OFFSET (&temp_proc_desc))
	    frame_addr = sp + low_word;
d1487 2
a1488 2
	      frame_addr = read_next_frame_reg (next_frame, 30);
	      alloca_adjust = (unsigned) (frame_addr - (sp + low_word));
d1500 3
a1502 3
      /* move $30,$sp.  With different versions of gas this will be either
         `addu $30,$sp,$zero' or `or $30,$sp,$zero' or `daddu 30,sp,$0'.
         Accept any one of these.  */
d1510 2
a1511 2
	      frame_addr = read_next_frame_reg (next_frame, 30);
	      alloca_adjust = (unsigned) (frame_addr - sp);
d1523 1
a1523 1
      else if ((high_word & 0xFFE0) == 0xafc0)	/* sw reg,offset($30) */
d1525 1
a1525 1
	  PROC_REG_MASK (&temp_proc_desc) |= 1 << reg;
d1532 3
a1534 3
heuristic_proc_desc (start_pc, limit_pc, next_frame)
     CORE_ADDR start_pc, limit_pc;
     struct frame_info *next_frame;
d1538 2
a1539 3
  if (start_pc == 0)
    return NULL;
  memset (&temp_proc_desc, '\0', sizeof (temp_proc_desc));
d1561 1
a1561 1
  struct block *b = block_for_pc (pc);
d1617 1
a1617 1
	  PROC_DESC_IS_DUMMY (proc_desc) ? 0 : PROC_SYMBOL (proc_desc);
d1622 1
a1622 1
				  (SYMBOL_BLOCK_VALUE (proc_symbol)),
d1629 2
a1630 2
	      heuristic_proc_desc (PROC_LOW_ADDR (proc_desc),
				   pc, next_frame);
d1639 3
a1641 3
         by procedure call dummys.  However, the procedures being called ought
         to have their own proc_descs, and even if they don't,
         heuristic_proc_desc knows how to create them! */
d1646 2
a1647 2
	if (PROC_LOW_ADDR (&link->info) <= pc
	    && PROC_HIGH_ADDR (&link->info) > pc)
d1660 3
a1662 3
get_frame_pointer (frame, proc_desc)
     struct frame_info *frame;
     mips_extra_func_info_t proc_desc;
d1665 2
a1666 2
		   read_next_frame_reg (frame, PROC_FRAME_REG (proc_desc)) +
	     PROC_FRAME_OFFSET (proc_desc) - PROC_FRAME_ADJUST (proc_desc));
d1672 2
a1673 2
mips_frame_chain (frame)
     struct frame_info *frame;
d1677 1
a1677 1
  CORE_ADDR saved_pc = FRAME_SAVED_PC (frame);
d1688 1
a1688 1
  proc_desc = find_proc_desc (saved_pc, frame);
d1699 2
a1700 2
  /* The previous frame from a sigtramp frame might be frameless
     and have frame size zero.  */
d1708 1
a1708 1
mips_init_extra_frame_info (fromleaf, fci)
d1716 1
a1716 1
  fci->next ? cached_proc_desc : find_proc_desc (fci->pc, fci->next);
d1728 2
a1729 2
         Get the value of the frame relative sp, procedure might have been
         interrupted by a signal at it's very start.  */
d1744 1
a1744 1
				    (CORE_ADDR *) NULL, (CORE_ADDR *) NULL);
d1747 1
a1747 1
	      frame_saved_regs_zalloc (fci);
d1759 1
a1759 1
	  if (PROC_REG_MASK (proc_desc) & (1 << regnum))
d1764 1
a1764 1
	}
d1809 1
a1809 1
mips_push_arguments (nargs, args, sp, struct_return, struct_addr)
d1826 1
a1826 1

d1834 1
a1834 1

d1839 1
a1839 1
    len += ROUND_UP (TYPE_LENGTH (VALUE_TYPE (args[argnum])), MIPS_SAVED_REGSIZE);
d1848 1
a1848 1
    write_register (argreg++, struct_addr);
d1863 1
a1863 1
         reference. In all other cases, pass the structure by value.  */
d1873 1
a1873 1
	val = (char *) VALUE_CONTENTS (arg);
d1878 1
a1878 1
	  && (float_argreg & 1))
d1883 7
a1889 7
         are passed in register pairs; the even register gets
         the low word, and the odd register gets the high word.
         On non-EABI processors, the first two floating point arguments are
         also copied to general registers, because MIPS16 functions
         don't use float registers for arguments.  This duplication of
         arguments in general registers can't hurt non-MIPS16 functions
         because those registers are normally skipped.  */
d1900 1
a1900 1
	      regval = extract_unsigned_integer (val + low_offset, 4);
d1903 1
a1903 1
		write_register (argreg + 1, regval);
d1906 1
a1906 1
	      regval = extract_unsigned_integer (val + 4 - low_offset, 4);
d1909 1
a1909 1
		{
d1922 1
a1922 1
		{
d1938 1
a1938 1
	  int odd_sized_struct = ((len > MIPS_SAVED_REGSIZE) &&
d1963 2
a1964 2

		  write_memory (sp + stack_offset + longword_offset,
d1969 1
a1969 1
	         Odd sized structs may go thru BOTH paths.  */
d1992 1
a1992 1
		    regval <<= ((MIPS_SAVED_REGSIZE - partial_len) *
d1997 1
a1997 1

d2004 1
a2004 1

d2009 8
a2016 8
	         copying parameters (after the registers are used up) 
	         begins at (4 * MIPS_REGSIZE) in the old ABI.  This 
	         leaves room for the "home" area for register parameters.

	         In the new EABI (and the NABI32), the 8 register parameters 
	         do not have "home" stack space reserved for them, so the
	         stack offset does not get incremented until after
	         we have used up the 8 parameter registers.  */
d2036 1
a2036 1
  write_register (RA_REGNUM, CALL_DUMMY_ADDRESS ());
d2041 1
a2041 1
mips_push_register (CORE_ADDR * sp, int regno)
d2070 2
a2071 2
  struct linked_proc_info *link = (struct linked_proc_info *)
  xmalloc (sizeof (struct linked_proc_info));
d2079 1
a2079 1
#define PUSH_FP_REGNUM 16	/* must be a register preserved across calls */
d2093 6
a2098 6
   *    Saved PC
   *    Saved MMHI, MMLO, FPC_CSR
   *    Saved R31
   *    Saved R28
   *    ...
   *    Saved R1
d2102 1
a2102 1
   *    Argument build area and stack arguments written via mips_push_arguments
d2107 3
a2109 3
  PROC_FRAME_REG (proc_desc) = PUSH_FP_REGNUM;
  PROC_FRAME_OFFSET (proc_desc) = 0;
  PROC_FRAME_ADJUST (proc_desc) = 0;
d2116 1
a2116 1
  PROC_REG_MASK (proc_desc) = GEN_REG_SAVE_MASK;
d2118 3
a2120 3
  PROC_REG_OFFSET (proc_desc) = sp - old_sp - MIPS_SAVED_REGSIZE;
  for (ireg = 32; --ireg >= 0;)
    if (PROC_REG_MASK (proc_desc) & (1 << ireg))
d2124 1
a2124 1
  PROC_FREG_MASK (proc_desc) =
d2129 3
a2131 3
  PROC_FREG_OFFSET (proc_desc) = sp - old_sp - 8;
  for (ireg = 32; --ireg >= 0;)
    if (PROC_FREG_MASK (proc_desc) & (1 << ireg))
d2139 4
a2142 4
  PROC_LOW_ADDR (proc_desc) = CALL_DUMMY_ADDRESS ();
  PROC_HIGH_ADDR (proc_desc) = CALL_DUMMY_ADDRESS () + 4;
  SET_PROC_DESC_IS_DUMMY (proc_desc);
  PROC_PC_REG (proc_desc) = RA_REGNUM;
d2146 1
a2146 1
mips_pop_frame ()
d2154 1
a2154 1
  write_register (PC_REGNUM, FRAME_SAVED_PC (frame));
d2163 1
a2163 1
					     MIPS_SAVED_REGSIZE));
d2168 1
a2168 1
  if (proc_desc && PROC_DESC_IS_DUMMY (proc_desc))
d2191 1
a2191 1
		      read_memory_integer (new_sp - 2 * MIPS_SAVED_REGSIZE,
d2194 1
a2194 1
		      read_memory_integer (new_sp - 3 * MIPS_SAVED_REGSIZE,
d2198 1
a2198 1
			read_memory_integer (new_sp - 4 * MIPS_SAVED_REGSIZE,
d2218 2
a2219 2
      && !((regnum - FP0_REGNUM) & 1))
    if (REGISTER_RAW_SIZE (regnum) == 4)	/* this would be silly on MIPS64 or N32 (Irix 6) */
d2221 1
a2221 1
	char dbuffer[2 * MAX_REGISTER_RAW_SIZE];
d2224 1
a2224 1
	read_relative_register_raw_bytes (regnum + 1, dbuffer + MIPS_REGSIZE);
d2227 1
a2227 1
	printf_filtered ("(d%d: ", regnum - FP0_REGNUM);
d2246 1
a2246 1
      {				/* show 8-byte floats as float AND double: */
d2271 1
a2271 1
{				/* do values for FP (float) regs */
d2279 1
a2279 1

d2287 1
a2287 1
  if (REGISTER_RAW_SIZE (regnum) == 4)
d2292 1
a2292 1
	error ("can't read register %d (%s)",
d2296 8
a2303 8
      memcpy (dbl_buffer, raw_buffer, sizeof (dbl_buffer));
      flt1 = unpack_double (builtin_type_float, raw_buffer[HI], &inv1);
      flt2 = unpack_double (builtin_type_float, raw_buffer[LO], &inv2);
      doub = unpack_double (builtin_type_double, dbl_buffer, &inv3);

      printf_filtered (inv1 ? " %-5s: <invalid float>" :
		       " %-5s%-17.9g", REGISTER_NAME (regnum), flt1);
      printf_filtered (inv2 ? " %-5s: <invalid float>" :
d2305 1
a2305 1
      printf_filtered (inv3 ? " dbl: <invalid double>\n" :
d2308 1
a2308 1
      regnum += 2;
d2311 1
a2311 1
    {				/* eight byte registers: print each one as float AND as double. */
d2314 2
a2315 2
      memcpy (dbl_buffer, raw_buffer[HI], sizeof (dbl_buffer));
      flt1 = unpack_double (builtin_type_float,
d2317 1
a2317 1
      doub = unpack_double (builtin_type_double, dbl_buffer, &inv3);
d2319 1
a2319 1
      printf_filtered (inv1 ? " %-5s: <invalid float>" :
d2321 1
a2321 1
      printf_filtered (inv3 ? " dbl: <invalid double>\n" :
d2348 1
a2348 1
	continue;		/* unused register */
d2350 2
a2351 2
	break;			/* end the row: reached FP register */
      printf_filtered (MIPS_REGSIZE == 8 ? "%17s" : "%9s",
d2355 1
a2355 1
  printf_filtered (start_regnum < MIPS_NUMREGS ? "\n R%-4d" : "\n      ",
d2363 1
a2363 1
	continue;		/* unused register */
d2365 1
a2365 1
	break;			/* end row: reached FP register */
d2382 1
a2382 1
  if (col > 0)			/* ie. if we actually printed anything... */
d2395 1
a2395 1
  if (regnum != -1)		/* do one specified register */
d2403 1
a2403 2
  else
    /* do all (or most) registers */
d2408 2
a2409 2
	  if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (regnum)) == TYPE_CODE_FLT)
	    if (fpregs)		/* true for "INFO ALL-REGISTERS" command */
d2424 1
a2424 1
     struct frame_info *frame;
d2426 1
a2426 1
#if 0				/* FIXME Use or lose this! */
d2468 1
a2468 1
  return is_delayed ((unsigned long) extract_unsigned_integer (buf, MIPS_INSTLEN));
d2477 1
a2477 1
     CORE_ADDR pc;		/* starting PC to search from */
d2480 11
a2490 11
  t_inst inst;
  CORE_ADDR end_pc;
  int seen_sp_adjust = 0;
  int load_immediate_bytes = 0;

  /* Skip the typical prologue instructions. These are the stack adjustment
     instruction and the instructions that save registers on the stack
     or in the gcc frame.  */
  for (end_pc = pc + 100; pc < end_pc; pc += MIPS_INSTLEN)
    {
      unsigned long high_word;
d2492 2
a2493 2
      inst = mips_fetch_instruction (pc);
      high_word = (inst >> 16) & 0xffff;
d2496 2
a2497 2
      if (lenient && is_delayed (inst))
	continue;
d2500 58
a2557 58
      if (high_word == 0x27bd	/* addiu $sp,$sp,offset */
	  || high_word == 0x67bd)	/* daddiu $sp,$sp,offset */
	seen_sp_adjust = 1;
      else if (inst == 0x03a1e823 ||	/* subu $sp,$sp,$at */
	       inst == 0x03a8e823)	/* subu $sp,$sp,$t0 */
	seen_sp_adjust = 1;
      else if (((inst & 0xFFE00000) == 0xAFA00000	/* sw reg,n($sp) */
		|| (inst & 0xFFE00000) == 0xFFA00000)	/* sd reg,n($sp) */
	       && (inst & 0x001F0000))	/* reg != $zero */
	continue;

      else if ((inst & 0xFFE00000) == 0xE7A00000)	/* swc1 freg,n($sp) */
	continue;
      else if ((inst & 0xF3E00000) == 0xA3C00000 && (inst & 0x001F0000))
	/* sx reg,n($s8) */
	continue;		/* reg != $zero */

      /* move $s8,$sp.  With different versions of gas this will be either
         `addu $s8,$sp,$zero' or `or $s8,$sp,$zero' or `daddu s8,sp,$0'.
         Accept any one of these.  */
      else if (inst == 0x03A0F021 || inst == 0x03a0f025 || inst == 0x03a0f02d)
	continue;

      else if ((inst & 0xFF9F07FF) == 0x00800021)	/* move reg,$a0-$a3 */
	continue;
      else if (high_word == 0x3c1c)	/* lui $gp,n */
	continue;
      else if (high_word == 0x279c)	/* addiu $gp,$gp,n */
	continue;
      else if (inst == 0x0399e021	/* addu $gp,$gp,$t9 */
	       || inst == 0x033ce021)	/* addu $gp,$t9,$gp */
	continue;
      /* The following instructions load $at or $t0 with an immediate
         value in preparation for a stack adjustment via
         subu $sp,$sp,[$at,$t0]. These instructions could also initialize
         a local variable, so we accept them only before a stack adjustment
         instruction was seen.  */
      else if (!seen_sp_adjust)
	{
	  if (high_word == 0x3c01 ||	/* lui $at,n */
	      high_word == 0x3c08)	/* lui $t0,n */
	    {
	      load_immediate_bytes += MIPS_INSTLEN;	/* FIXME!! */
	      continue;
	    }
	  else if (high_word == 0x3421 ||	/* ori $at,$at,n */
		   high_word == 0x3508 ||	/* ori $t0,$t0,n */
		   high_word == 0x3401 ||	/* ori $at,$zero,n */
		   high_word == 0x3408)		/* ori $t0,$zero,n */
	    {
	      load_immediate_bytes += MIPS_INSTLEN;	/* FIXME!! */
	      continue;
	    }
	  else
	    break;
	}
      else
	break;
d2560 6
a2565 6
  /* In a frameless function, we might have incorrectly
     skipped some load immediate instructions. Undo the skipping
     if the load immediate was not followed by a stack adjustment.  */
  if (load_immediate_bytes && !seen_sp_adjust)
    pc -= load_immediate_bytes;
  return pc;
d2573 1
a2573 1
     CORE_ADDR pc;		/* starting PC to search from */
d2576 3
a2578 3
  CORE_ADDR end_pc;
  int extend_bytes = 0;
  int prev_extend_bytes;
d2580 2
a2581 2
  /* Table of instructions likely to be found in a function prologue.  */
  static struct
d2585 1
a2585 3
    }
  table[] =
  {
d2587 21
a2607 47
      0x6300, 0xff00
    }
    ,				/* addiu $sp,offset */
    {
      0xfb00, 0xff00
    }
    ,				/* daddiu $sp,offset */
    {
      0xd000, 0xf800
    }
    ,				/* sw reg,n($sp) */
    {
      0xf900, 0xff00
    }
    ,				/* sd reg,n($sp) */
    {
      0x6200, 0xff00
    }
    ,				/* sw $ra,n($sp) */
    {
      0xfa00, 0xff00
    }
    ,				/* sd $ra,n($sp) */
    {
      0x673d, 0xffff
    }
    ,				/* move $s1,sp */
    {
      0xd980, 0xff80
    }
    ,				/* sw $a0-$a3,n($s1) */
    {
      0x6704, 0xff1c
    }
    ,				/* move reg,$a0-$a3 */
    {
      0xe809, 0xf81f
    }
    ,				/* entry pseudo-op */
    {
      0x0100, 0xff00
    }
    ,				/* addiu $s1,$sp,n */
    {
      0, 0
    }				/* end of table marker */
  };
d2609 1
a2609 7
  /* Skip the typical prologue instructions. These are the stack adjustment
     instruction and the instructions that save registers on the stack
     or in the gcc frame.  */
  for (end_pc = pc + 100; pc < end_pc; pc += MIPS16_INSTLEN)
    {
      unsigned short inst;
      int i;
d2611 11
a2621 1
      inst = mips_fetch_instruction (pc);
d2623 12
a2634 25
      /* Normally we ignore an extend instruction.  However, if it is
         not followed by a valid prologue instruction, we must adjust
         the pc back over the extend so that it won't be considered
         part of the prologue.  */
      if ((inst & 0xf800) == 0xf000)	/* extend */
	{
	  extend_bytes = MIPS16_INSTLEN;
	  continue;
	}
      prev_extend_bytes = extend_bytes;
      extend_bytes = 0;

      /* Check for other valid prologue instructions besides extend.  */
      for (i = 0; table[i].mask != 0; i++)
	if ((inst & table[i].mask) == table[i].inst)	/* found, get out */
	  break;
      if (table[i].mask != 0)	/* it was in table? */
	continue;		/* ignore it */
      else
	/* non-prologue */
	{
	  /* Return the current pc, adjusted backwards by 2 if
	     the previous instruction was an extend.  */
	  return pc - prev_extend_bytes;
	}
d2709 1
a2709 1

d2717 1
a2717 1
	     spread them across a floating-point register pair. */
d2732 1
a2732 1
	     register. */
d2794 1
a2794 1
	     of the register is being used */
d2808 3
a2810 3
     struct type *valtype;
     char regbuf[REGISTER_BYTES];
     char *valbuf;
d2829 1
a2829 1

d2838 1
a2838 1
    {				/* "un-left-justify" the value from the register */
d2841 1
a2841 1
      if (len > REGISTER_RAW_SIZE (regnum) &&	/* odd-size structs */
d2857 2
a2858 2
     struct type *valtype;
     char *valbuf;
d2870 1
a2870 1

d2885 1
a2885 1

d2894 1
a2894 1
    {				/* "left-justify" the value in the register */
d2897 1
a2897 1
      if (len > REGISTER_RAW_SIZE (regnum) &&	/* odd-size structs */
d2903 5
a2907 5
  memcpy (raw_buffer + offset, valbuf, len);
  REGISTER_CONVERT_FROM_TYPE (regnum, valtype, raw_buffer);
  write_register_bytes (REGISTER_BYTE (regnum), raw_buffer,
			len > REGISTER_RAW_SIZE (regnum) ?
			len : REGISTER_RAW_SIZE (regnum));
d3023 1
a3023 1

d3075 1
a3075 1
    return savestring ("r3041", strlen ("r3041"));
d3118 1
a3118 1

d3146 1
a3146 2
unsigned char *
mips_breakpoint_from_pc (pcptr, lenptr)
d3156 1
a3156 1
	  *lenptr = sizeof (mips16_big_breakpoint);
d3165 1
a3165 1
	  *lenptr = sizeof (big_breakpoint);
d3183 1
a3183 1
	  *lenptr = sizeof (mips16_little_breakpoint);
d3192 1
a3192 1
	  *lenptr = sizeof (little_breakpoint);
d3211 1
a3211 1
   target PC is in $31 ($ra).
d3213 1
a3213 1
   and the target PC is in $2.
d3215 3
a3217 3
   before the jal instruction, this is effectively a call stub
   and the the target PC is in $2.  Otherwise this is effectively
   a return stub and the target PC is in $18.
d3223 1
a3223 1
 */
d3250 3
a3252 3
         before the jal instruction, this is effectively a call stub
         and the the target PC is in $2.  Otherwise this is effectively
         a return stub and the target PC is in $18.  */
d3258 10
a3267 10
	         stub.  Such a stub for a function bar might have a name
	         like __fn_stub_bar, and might look like this:
	         mfc1    $4,$f13
	         mfc1    $5,$f12
	         mfc1    $6,$f15
	         mfc1    $7,$f14
	         la      $1,bar   (becomes a lui/addiu pair)
	         jr      $1
	         So scan down to the lui/addi and extract the target
	         address from those two instructions.  */
d3282 2
a3283 2
	         The limit on the search is arbitrarily set to 20
	         instructions.  FIXME.  */
d3286 5
a3290 5
		  inst = mips_fetch_instruction (target_pc);
		  if ((inst & 0xffff0000) == 0x3c010000)	/* lui $at */
		    pc = (inst << 16) & 0xffff0000;	/* high word */
		  else if ((inst & 0xffff0000) == 0x24210000)	/* addiu $at */
		    return pc | (inst & 0xffff);	/* low word */
d3302 1
a3302 1
  return 0;			/* not a stub */
d3327 1
a3327 1
         before the jal instruction, this is effectively a call stub.  */
d3332 1
a3332 1
  return 0;			/* not a stub */
d3356 1
a3356 1
     i.e. after the jal instruction, this is effectively a return stub.  */
d3362 1
a3362 1
  return 0;			/* not a stub */
d3411 1
a3411 1
  if (!tm_print_insn)		/* Someone may have already set it */
d3474 2
a3475 2
    (add_set_cmd ("mask-address", no_class, var_boolean, (char *) &mask_address_p,
		  "Set zeroing of upper 32 bits of 64-bit addresses.\n\
@


1.1.1.8
log
@import gdb-1999-07-12 snapshot
@
text
@a255 60
/* Convert between RAW and VIRTUAL registers.  The RAW register size
   defines the remote-gdb packet. */

static int mips64_transfers_32bit_regs_p = 0;

int
mips_register_raw_size (reg_nr)
     int reg_nr;
{
  if (mips64_transfers_32bit_regs_p)
    return REGISTER_VIRTUAL_SIZE (reg_nr);
  else
    return MIPS_REGSIZE;
}

int
mips_register_convertible (reg_nr)
     int reg_nr;
{
  if (mips64_transfers_32bit_regs_p)
    return 0;
  else
    return (REGISTER_RAW_SIZE (reg_nr) > REGISTER_VIRTUAL_SIZE (reg_nr));
}

void
mips_register_convert_to_virtual (n, virtual_type, raw_buf, virt_buf)
     int n;
     struct type *virtual_type;
     char *raw_buf;
     char *virt_buf;
{
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
    memcpy (virt_buf,
	    raw_buf + (REGISTER_RAW_SIZE (n) - TYPE_LENGTH (virtual_type)),
	    TYPE_LENGTH (virtual_type));
  else
    memcpy (virt_buf,
	    raw_buf,
	    TYPE_LENGTH (virtual_type));
}

void
mips_register_convert_to_raw (virtual_type, n, virt_buf, raw_buf)
     struct type *virtual_type;
     int n;
     char *virt_buf;
     char *raw_buf;
{
  memset (raw_buf, 0, REGISTER_RAW_SIZE (n));
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
    memcpy (raw_buf + (REGISTER_RAW_SIZE (n) - TYPE_LENGTH (virtual_type)),
	    virt_buf,
	    TYPE_LENGTH (virtual_type));
  else
    memcpy (raw_buf,
	    virt_buf,
	    TYPE_LENGTH (virtual_type));
}

d2426 1
a2426 1
      for (byte = 0; byte < (MIPS_REGSIZE - REGISTER_VIRTUAL_SIZE (regnum)); byte++)
d2430 1
a2430 3
	for (byte = REGISTER_RAW_SIZE (regnum) - REGISTER_VIRTUAL_SIZE (regnum);
	     byte < REGISTER_RAW_SIZE (regnum);
	     byte++)
d2433 1
a2433 3
	for (byte = REGISTER_VIRTUAL_SIZE (regnum) - 1;
	     byte >= 0;
	     byte--)
a3573 13

  /* Allow the user to control the size of 32 bit registers within the
     raw remote packet.  */
  add_show_from_set (add_set_cmd ("remote-mips64-transfers-32bit-regs",
				  class_obscure,
				  var_boolean,
				  (char *)&mips64_transfers_32bit_regs_p, "\
Set compatibility with MIPS targets that transfers 32 and 64 bit quantities.\n\
Use \"on\" to enable backward compatibility with older MIPS 64 GDB+target\n\
that would transfer 32 bits for some registers (e.g. SR, FSR) and\n\
64 bits for others.  Use \"off\" to disable compatibility mode",
				  &setlist),
		     &showlist);
@


1.1.1.9
log
@import gdb-1999-08-23 snapshot
@
text
@d2 2
a3 1
   Copyright 1988-1999, Free Software Foundation, Inc.
a2034 2
	      /* On 32 bit ABI's the float_argreg is further adjusted
                 above to ensure that it is even register aligned. */
a2038 4
		  /* CAGNEY: 32 bit MIPS ABI's always reserve two FP
                     registers for each argument.  The below is (my
                     guess) to ensure that the corresponding integer
                     register has reserved the same space. */
@


1.1.1.10
log
@import gdb-1999-09-08 snapshot
@
text
@d90 2
d250 1
a250 1
    printf_filtered (" frame pointer is at %s+%s\n",
d252 1
a252 1
		     paddr_d (fi->extra_info->proc_desc->pdr.frameoffset));
d692 2
a693 2
  printf ("%s %04x ,f(%d) off(%s) (x(%x) y(%x)\n",
	  comment, u->inst, u->fmt, paddr (u->offset), u->regx, u->regy);
@


1.1.1.11
log
@import gdb-1999-10-04 snapshot
@
text
@d1149 1
a1149 1
	    return read_memory_integer (ADDR_BITS_REMOVE (fi->saved_regs[regno]), MIPS_SAVED_REGSIZE);
a3564 1

@


1.1.1.12
log
@import gdb-1999-12-06 snapshot
@
text
@a37 3
#include "elf/mips.h"
#include "elf-bfd.h"

a72 50
/* MIPS specific per-architecture information */
struct gdbarch_tdep
  {
    /* from the elf header */
    int elf_flags;
    /* mips options */
    int mips_eabi;
    enum mips_fpu_type mips_fpu_type;
    int mips_last_arg_regnum;
    int mips_last_fp_arg_regnum;
    int mips_saved_regsize;
    int mips_fp_register_double;
  };

#if GDB_MULTI_ARCH
#undef MIPS_EABI
#define MIPS_EABI (gdbarch_tdep (current_gdbarch)->mips_eabi)
#endif

#if GDB_MULTI_ARCH
#undef MIPS_LAST_FP_ARG_REGNUM
#define MIPS_LAST_FP_ARG_REGNUM (gdbarch_tdep (current_gdbarch)->mips_last_fp_arg_regnum)
#endif

#if GDB_MULTI_ARCH
#undef MIPS_LAST_ARG_REGNUM
#define MIPS_LAST_ARG_REGNUM (gdbarch_tdep (current_gdbarch)->mips_last_arg_regnum)
#endif

#if GDB_MULTI_ARCH
#undef MIPS_FPU_TYPE
#define MIPS_FPU_TYPE (gdbarch_tdep (current_gdbarch)->mips_fpu_type)
#endif

#if GDB_MULTI_ARCH
#undef MIPS_SAVED_REGSIZE
#define MIPS_SAVED_REGSIZE (gdbarch_tdep (current_gdbarch)->mips_saved_regsize)
#endif

/* Indicate that the ABI makes use of double-precision registers
   provided by the FPU (rather than combining pairs of registers to
   form double-precision values).  Do not use "TARGET_IS_MIPS64" to
   determine if the ABI is using double-precision registers.  See also
   MIPS_FPU_TYPE. */
#if GDB_MULTI_ARCH
#undef FP_REGISTER_DOUBLE
#define FP_REGISTER_DOUBLE (gdbarch_tdep (current_gdbarch)->mips_fp_register_double)
#endif


a3132 4
  if (GDB_MULTI_ARCH)
    {
      gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_SINGLE;
    }
a3142 4
  if (GDB_MULTI_ARCH)
    {
      gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_DOUBLE;
    }
a3152 4
  if (GDB_MULTI_ARCH)
    {
      gdbarch_tdep (current_gdbarch)->mips_fpu_type = MIPS_FPU_NONE;
    }
a3567 242
static gdbarch_init_ftype mips_gdbarch_init;
static struct gdbarch *
mips_gdbarch_init (info, arches)
     struct gdbarch_info info;
     struct gdbarch_list *arches;
{
  static LONGEST mips_call_dummy_words[] =
  {0};
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;
  int elf_flags;
  char *ef_mips_abi;
  int ef_mips_bitptrs;
  int ef_mips_arch;

  /* Extract the elf_flags if available */
  if (info.abfd != NULL
      && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
    elf_flags = elf_elfheader (info.abfd)->e_flags;
  else
    elf_flags = 0;

  /* try to find a pre-existing architecture */
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      /* MIPS needs to be pedantic about which ABI the object is
         using. */
      if (gdbarch_tdep (current_gdbarch)->elf_flags != elf_flags)
	continue;
      return arches->gdbarch;
    }

  /* Need a new architecture. Fill in a target specific vector. */
  tdep = (struct gdbarch_tdep *) xmalloc (sizeof (struct gdbarch_tdep));
  gdbarch = gdbarch_alloc (&info, tdep);
  tdep->elf_flags = elf_flags;

  /* Initially set everything according to the ABI. */
  set_gdbarch_short_bit (gdbarch, 16);
  set_gdbarch_int_bit (gdbarch, 32);
  set_gdbarch_float_bit (gdbarch, 32);
  set_gdbarch_double_bit (gdbarch, 64);
  set_gdbarch_long_double_bit (gdbarch, 64);
  switch ((elf_flags & EF_MIPS_ABI))
    {
    case E_MIPS_ABI_O32:
      ef_mips_abi = "o32";
      tdep->mips_eabi = 0;
      tdep->mips_saved_regsize = 4;
      tdep->mips_fp_register_double = 0;
      set_gdbarch_long_bit (gdbarch, 32);
      set_gdbarch_ptr_bit (gdbarch, 32);
      set_gdbarch_long_long_bit (gdbarch, 64);
      break;
    case E_MIPS_ABI_O64:
      ef_mips_abi = "o64";
      tdep->mips_eabi = 0;
      tdep->mips_saved_regsize = 8;
      tdep->mips_fp_register_double = 1;
      set_gdbarch_long_bit (gdbarch, 32);
      set_gdbarch_ptr_bit (gdbarch, 32);
      set_gdbarch_long_long_bit (gdbarch, 64);
      break;
    case E_MIPS_ABI_EABI32:
      ef_mips_abi = "eabi32";
      tdep->mips_eabi = 1;
      tdep->mips_saved_regsize = 4;
      tdep->mips_fp_register_double = 0;
      set_gdbarch_long_bit (gdbarch, 32);
      set_gdbarch_ptr_bit (gdbarch, 32);
      set_gdbarch_long_long_bit (gdbarch, 64);
      break;
    case E_MIPS_ABI_EABI64:
      ef_mips_abi = "eabi64";
      tdep->mips_eabi = 1;
      tdep->mips_saved_regsize = 8;
      tdep->mips_fp_register_double = 1;
      set_gdbarch_long_bit (gdbarch, 64);
      set_gdbarch_ptr_bit (gdbarch, 64);
      set_gdbarch_long_long_bit (gdbarch, 64);
      break;
    default:
      ef_mips_abi = "default";
      tdep->mips_eabi = 0;
      tdep->mips_saved_regsize = MIPS_REGSIZE;
      tdep->mips_fp_register_double = (REGISTER_VIRTUAL_SIZE (FP0_REGNUM) == 8);
      set_gdbarch_long_bit (gdbarch, 32);
      set_gdbarch_ptr_bit (gdbarch, 32);
      set_gdbarch_long_long_bit (gdbarch, 64);
      break;
    }

  /* determine the ISA */
  switch (elf_flags & EF_MIPS_ARCH)
    {
    case E_MIPS_ARCH_1:
      ef_mips_arch = 1;
      break;
    case E_MIPS_ARCH_2:
      ef_mips_arch = 2;
      break;
    case E_MIPS_ARCH_3:
      ef_mips_arch = 3;
      break;
    case E_MIPS_ARCH_4:
      ef_mips_arch = 0;
      break;
    default:
      break;
    }

#if 0
  /* determine the size of a pointer */
  if ((elf_flags & EF_MIPS_32BITPTRS))
    {
      ef_mips_bitptrs = 32;
    }
  else if ((elf_flags & EF_MIPS_64BITPTRS))
    {
      ef_mips_bitptrs = 64;
    }
  else
    {
      ef_mips_bitptrs = 0;
    }
#endif

  /* Select either of the two alternative ABI's */
  if (tdep->mips_eabi)
    {
      /* EABI uses R4 through R11 for args */
      tdep->mips_last_arg_regnum = 11;
      /* EABI uses F12 through F19 for args */
      tdep->mips_last_fp_arg_regnum = FP0_REGNUM + 19;
    }
  else
    {
      /* old ABI uses R4 through R7 for args */
      tdep->mips_last_arg_regnum = 7;
      /* old ABI uses F12 through F15 for args */
      tdep->mips_last_fp_arg_regnum = FP0_REGNUM + 15;
    }

  /* enable/disable the MIPS FPU */
  if (!mips_fpu_type_auto)
    tdep->mips_fpu_type = mips_fpu_type;
  else if (info.bfd_arch_info != NULL
	   && info.bfd_arch_info->arch == bfd_arch_mips)
    switch (info.bfd_arch_info->mach)
      {
      case bfd_mach_mips4100:
	tdep->mips_fpu_type = MIPS_FPU_NONE;
	break;
      default:
	tdep->mips_fpu_type = MIPS_FPU_DOUBLE;
	break;
      }
  else
    tdep->mips_fpu_type = MIPS_FPU_DOUBLE;

  /* MIPS version of register names.  NOTE: At present the MIPS
     register name management is part way between the old -
     #undef/#define REGISTER_NAMES and the new REGISTER_NAME(nr).
     Further work on it is required. */
  set_gdbarch_register_name (gdbarch, mips_register_name);
  set_gdbarch_read_pc (gdbarch, generic_target_read_pc);
  set_gdbarch_write_pc (gdbarch, generic_target_write_pc);
  set_gdbarch_read_fp (gdbarch, generic_target_read_fp);
  set_gdbarch_write_fp (gdbarch, generic_target_write_fp);
  set_gdbarch_read_sp (gdbarch, generic_target_read_sp);
  set_gdbarch_write_sp (gdbarch, generic_target_write_sp);

  /* Initialize a frame */
  set_gdbarch_init_extra_frame_info (gdbarch, mips_init_extra_frame_info);

  /* MIPS version of CALL_DUMMY */

  set_gdbarch_call_dummy_p (gdbarch, 1);
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
  set_gdbarch_use_generic_dummy_frames (gdbarch, 0);
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
  set_gdbarch_call_dummy_address (gdbarch, mips_call_dummy_address);
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
  set_gdbarch_call_dummy_length (gdbarch, 0);
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_at_entry_point);
  set_gdbarch_call_dummy_words (gdbarch, mips_call_dummy_words);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, sizeof (mips_call_dummy_words));
  set_gdbarch_push_return_address (gdbarch, mips_push_return_address);
  set_gdbarch_push_arguments (gdbarch, mips_push_arguments);
  set_gdbarch_register_convertible (gdbarch, generic_register_convertible_not);

  set_gdbarch_frame_chain_valid (gdbarch, default_frame_chain_valid);
  set_gdbarch_get_saved_register (gdbarch, default_get_saved_register);

  if (gdbarch_debug)
    {
      fprintf_unfiltered (gdb_stderr,
			  "mips_gdbarch_init: (info)elf_flags = 0x%x\n",
			  elf_flags);
      fprintf_unfiltered (gdb_stderr,
			  "mips_gdbarch_init: (info)ef_mips_abi = %s\n",
			  ef_mips_abi);
      fprintf_unfiltered (gdb_stderr,
			  "mips_gdbarch_init: (info)ef_mips_arch = %d\n",
			  ef_mips_arch);
      fprintf_unfiltered (gdb_stderr,
			  "mips_gdbarch_init: (info)ef_mips_bitptrs = %d\n",
			  ef_mips_bitptrs);
      fprintf_unfiltered (gdb_stderr,
			  "mips_gdbarch_init: MIPS_EABI = %d\n",
			  tdep->mips_eabi);
      fprintf_unfiltered (gdb_stderr,
			  "mips_gdbarch_init: MIPS_LAST_ARG_REGNUM = %d\n",
			  tdep->mips_last_arg_regnum);
      fprintf_unfiltered (gdb_stderr,
		   "mips_gdbarch_init: MIPS_LAST_FP_ARG_REGNUM = %d (%d)\n",
			  tdep->mips_last_fp_arg_regnum,
			  tdep->mips_last_fp_arg_regnum - FP0_REGNUM);
      fprintf_unfiltered (gdb_stderr,
		       "mips_gdbarch_init: tdep->mips_fpu_type = %d (%s)\n",
			  tdep->mips_fpu_type,
			  (tdep->mips_fpu_type == MIPS_FPU_NONE ? "none"
			 : tdep->mips_fpu_type == MIPS_FPU_SINGLE ? "single"
			 : tdep->mips_fpu_type == MIPS_FPU_DOUBLE ? "double"
			   : "???"));
      fprintf_unfiltered (gdb_stderr,
		       "mips_gdbarch_init: tdep->mips_saved_regsize = %d\n",
			  tdep->mips_saved_regsize);
      fprintf_unfiltered (gdb_stderr,
	     "mips_gdbarch_init: tdep->mips_fp_register_double = %d (%s)\n",
			  tdep->mips_fp_register_double,
			(tdep->mips_fp_register_double ? "true" : "false"));
    }

  return gdbarch;
}


a3573 2
  if (GDB_MULTI_ARCH)
    register_gdbarch_init (bfd_arch_mips, mips_gdbarch_init);
a3604 1
#if !GDB_MULTI_ARCH
a3616 1
#endif
@


1.1.1.13
log
@import gdb-1999-12-13 snapshot
@
text
@d3828 1
a3828 1
  set_gdbarch_frame_chain_valid (gdbarch, func_frame_chain_valid);
@


1.1.1.14
log
@import gdb-1999-12-21 snapshot
@
text
@d2433 2
a2434 12
    {
      int offset;

      if (TARGET_BYTE_ORDER == BIG_ENDIAN)
        offset = REGISTER_RAW_SIZE (regnum) - REGISTER_VIRTUAL_SIZE (regnum);
      else
	offset = 0;
	
      print_scalar_formatted (raw_buffer + offset,
			      REGISTER_VIRTUAL_TYPE (regnum),
			      'x', 0, gdb_stdout);
    }
a3785 1
      case bfd_mach_mips4111:
@


