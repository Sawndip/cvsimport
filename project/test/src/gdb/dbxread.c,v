head	1.152;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.143
	gdb_7_6-2013-04-26-release:1.143
	gdb_7_6-branch:1.143.0.2
	gdb_7_6-2013-03-12-branchpoint:1.143
	gdb_7_5_1-2012-11-29-release:1.134
	gdb_7_5-2012-08-17-release:1.134
	gdb_7_5-branch:1.134.0.2
	gdb_7_5-2012-07-18-branchpoint:1.134
	gdb_7_4_1-2012-04-26-release:1.130.2.2
	gdb_7_4-2012-01-24-release:1.130.2.2
	gdb_7_4-branch:1.130.0.2
	gdb_7_4-2011-12-13-branchpoint:1.130
	gdb_7_3_1-2011-09-04-release:1.127
	gdb_7_3-2011-07-26-release:1.127
	gdb_7_3-branch:1.127.0.2
	gdb_7_3-2011-04-01-branchpoint:1.127
	gdb_7_2-2010-09-02-release:1.116
	gdb_7_2-branch:1.116.0.2
	gdb_7_2-2010-07-07-branchpoint:1.116
	gdb_7_1-2010-03-18-release:1.113
	gdb_7_1-branch:1.113.0.2
	gdb_7_1-2010-02-18-branchpoint:1.113
	gdb_7_0_1-2009-12-22-release:1.105
	gdb_7_0-2009-10-06-release:1.105
	gdb_7_0-branch:1.105.0.2
	gdb_7_0-2009-09-16-branchpoint:1.105
	arc-sim-20090309:1.94
	msnyder-checkpoint-072509-branch:1.104.0.2
	msnyder-checkpoint-072509-branchpoint:1.104
	arc-insight_6_8-branch:1.94.0.6
	arc-insight_6_8-branchpoint:1.94
	insight_6_8-branch:1.94.0.4
	insight_6_8-branchpoint:1.94
	reverse-20081226-branch:1.99.0.2
	reverse-20081226-branchpoint:1.99
	multiprocess-20081120-branch:1.98.0.2
	multiprocess-20081120-branchpoint:1.98
	reverse-20080930-branch:1.97.0.2
	reverse-20080930-branchpoint:1.97
	reverse-20080717-branch:1.96.0.4
	reverse-20080717-branchpoint:1.96
	msnyder-reverse-20080609-branch:1.96.0.2
	msnyder-reverse-20080609-branchpoint:1.96
	drow-reverse-20070409-branch:1.82.0.2
	drow-reverse-20070409-branchpoint:1.82
	gdb_6_8-2008-03-27-release:1.94
	gdb_6_8-branch:1.94.0.2
	gdb_6_8-2008-02-26-branchpoint:1.94
	gdb_6_7_1-2007-10-29-release:1.86
	gdb_6_7-2007-10-10-release:1.86
	gdb_6_7-branch:1.86.0.2
	gdb_6_7-2007-09-07-branchpoint:1.86
	insight_6_6-20070208-release:1.81
	gdb_6_6-2006-12-18-release:1.81
	gdb_6_6-branch:1.81.0.18
	gdb_6_6-2006-11-15-branchpoint:1.81
	insight_6_5-20061003-release:1.81
	gdb-csl-symbian-6_4_50_20060226-12:1.81
	gdb-csl-sourcerygxx-3_4_4-25:1.80
	nickrob-async-20060828-mergepoint:1.81
	gdb-csl-symbian-6_4_50_20060226-11:1.81
	gdb-csl-sourcerygxx-4_1-17:1.81
	gdb-csl-20060226-branch-local-2:1.81
	gdb-csl-sourcerygxx-4_1-14:1.81
	gdb-csl-sourcerygxx-4_1-13:1.81
	gdb-csl-sourcerygxx-4_1-12:1.81
	gdb-csl-sourcerygxx-3_4_4-21:1.81
	gdb_6_5-20060621-release:1.81
	gdb-csl-sourcerygxx-4_1-9:1.81
	gdb-csl-sourcerygxx-4_1-8:1.81
	gdb-csl-sourcerygxx-4_1-7:1.81
	gdb-csl-arm-2006q1-6:1.81
	gdb-csl-sourcerygxx-4_1-6:1.81
	gdb-csl-symbian-6_4_50_20060226-10:1.81
	gdb-csl-symbian-6_4_50_20060226-9:1.81
	gdb-csl-symbian-6_4_50_20060226-8:1.81
	gdb-csl-coldfire-4_1-11:1.81
	gdb-csl-sourcerygxx-3_4_4-19:1.81
	gdb-csl-coldfire-4_1-10:1.81
	gdb_6_5-branch:1.81.0.16
	gdb_6_5-2006-05-14-branchpoint:1.81
	gdb-csl-sourcerygxx-4_1-5:1.81
	nickrob-async-20060513-branch:1.81.0.14
	nickrob-async-20060513-branchpoint:1.81
	gdb-csl-sourcerygxx-4_1-4:1.81
	msnyder-reverse-20060502-branch:1.81.0.12
	msnyder-reverse-20060502-branchpoint:1.81
	gdb-csl-morpho-4_1-4:1.81
	gdb-csl-sourcerygxx-3_4_4-17:1.81
	readline_5_1-import-branch:1.81.0.10
	readline_5_1-import-branchpoint:1.81
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.81
	gdb-csl-symbian-20060226-branch:1.81.0.8
	gdb-csl-symbian-20060226-branchpoint:1.81
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.81
	msnyder-reverse-20060331-branch:1.81.0.6
	msnyder-reverse-20060331-branchpoint:1.81
	gdb-csl-available-20060303-branch:1.81.0.4
	gdb-csl-available-20060303-branchpoint:1.81
	gdb-csl-20060226-branch:1.81.0.2
	gdb-csl-20060226-branchpoint:1.81
	gdb_6_4-20051202-release:1.80
	msnyder-fork-checkpoint-branch:1.80.0.12
	msnyder-fork-checkpoint-branchpoint:1.80
	gdb-csl-gxxpro-6_3-branch:1.80.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.80
	gdb_6_4-branch:1.80.0.8
	gdb_6_4-2005-11-01-branchpoint:1.80
	gdb-csl-arm-20051020-branch:1.80.0.6
	gdb-csl-arm-20051020-branchpoint:1.80
	msnyder-tracepoint-checkpoint-branch:1.80.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.80
	gdb-csl-arm-20050325-2005-q1b:1.80
	gdb-csl-arm-20050325-2005-q1a:1.80
	csl-arm-20050325-branch:1.80.0.2
	csl-arm-20050325-branchpoint:1.80
	gdb-post-i18n-errorwarning-20050211:1.79
	gdb-pre-i18n-errorwarning-20050211:1.78
	gdb_6_3-20041109-release:1.74
	gdb_6_3-branch:1.74.0.2
	gdb_6_3-20041019-branchpoint:1.74
	drow_intercu-merge-20040921:1.74
	drow_intercu-merge-20040915:1.74
	jimb-gdb_6_2-e500-branch:1.69.0.6
	jimb-gdb_6_2-e500-branchpoint:1.69
	gdb_6_2-20040730-release:1.69
	gdb_6_2-branch:1.69.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.69
	gdb_6_1_1-20040616-release:1.64
	gdb_6_1-2004-04-05-release:1.64
	drow_intercu-merge-20040402:1.64
	drow_intercu-merge-20040327:1.64
	ezannoni_pie-20040323-branch:1.64.0.8
	ezannoni_pie-20040323-branchpoint:1.64
	cagney_tramp-20040321-mergepoint:1.64
	cagney_tramp-20040309-branch:1.64.0.6
	cagney_tramp-20040309-branchpoint:1.64
	gdb_6_1-branch:1.64.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.64
	drow_intercu-20040221-branch:1.64.0.2
	drow_intercu-20040221-branchpoint:1.64
	cagney_bfdfile-20040213-branch:1.63.0.2
	cagney_bfdfile-20040213-branchpoint:1.63
	drow-cplus-merge-20040208:1.63
	carlton_dictionary-20040126-merge:1.62
	cagney_bigcore-20040122-branch:1.62.0.2
	cagney_bigcore-20040122-branchpoint:1.62
	drow-cplus-merge-20040113:1.62
	drow-cplus-merge-20031224:1.61
	drow-cplus-merge-20031220:1.61
	carlton_dictionary-20031215-merge:1.61
	drow-cplus-merge-20031214:1.61
	carlton-dictionary-20031111-merge:1.59
	gdb_6_0-2003-10-04-release:1.48.4.1
	kettenis_sparc-20030918-branch:1.56.0.4
	kettenis_sparc-20030918-branchpoint:1.56
	carlton_dictionary-20030917-merge:1.56
	ezannoni_pie-20030916-branchpoint:1.56
	ezannoni_pie-20030916-branch:1.56.0.2
	cagney_x86i386-20030821-branch:1.48.0.6
	cagney_x86i386-20030821-branchpoint:1.48
	carlton_dictionary-20030805-merge:1.48
	carlton_dictionary-20030627-merge:1.48
	gdb_6_0-branch:1.48.0.4
	gdb_6_0-2003-06-23-branchpoint:1.48
	jimb-ppc64-linux-20030613-branch:1.48.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.48
	cagney_convert-20030606-branch:1.46.0.6
	cagney_convert-20030606-branchpoint:1.46
	cagney_writestrings-20030508-branch:1.45.0.20
	cagney_writestrings-20030508-branchpoint:1.45
	jimb-ppc64-linux-20030528-branch:1.46.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.46
	carlton_dictionary-20030523-merge:1.46
	cagney_fileio-20030521-branch:1.46.0.2
	cagney_fileio-20030521-branchpoint:1.46
	kettenis_i386newframe-20030517-mergepoint:1.46
	jimb-ppc64-linux-20030509-branch:1.45.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.45
	kettenis_i386newframe-20030504-mergepoint:1.45
	carlton_dictionary-20030430-merge:1.45
	kettenis_i386newframe-20030419-branch:1.45.0.16
	kettenis_i386newframe-20030419-branchpoint:1.45
	carlton_dictionary-20030416-merge:1.45
	cagney_frameaddr-20030409-mergepoint:1.45
	kettenis_i386newframe-20030406-branch:1.45.0.14
	kettenis_i386newframe-20030406-branchpoint:1.45
	cagney_frameaddr-20030403-branchpoint:1.45
	cagney_frameaddr-20030403-branch:1.45.0.12
	cagney_framebase-20030330-mergepoint:1.45
	cagney_framebase-20030326-branch:1.45.0.10
	cagney_framebase-20030326-branchpoint:1.45
	cagney_lazyid-20030317-branch:1.45.0.8
	cagney_lazyid-20030317-branchpoint:1.45
	kettenis-i386newframe-20030316-mergepoint:1.45
	offbyone-20030313-branch:1.45.0.6
	offbyone-20030313-branchpoint:1.45
	kettenis-i386newframe-20030308-branch:1.45.0.4
	kettenis-i386newframe-20030308-branchpoint:1.45
	carlton_dictionary-20030305-merge:1.45
	cagney_offbyone-20030303-branch:1.45.0.2
	cagney_offbyone-20030303-branchpoint:1.45
	carlton_dictionary-20030207-merge:1.41
	interps-20030203-mergepoint:1.41
	interps-20030202-branch:1.41.0.2
	interps-20030202-branchpoint:1.41
	cagney-unwind-20030108-branch:1.38.0.2
	cagney-unwind-20030108-branchpoint:1.38
	carlton_dictionary-20021223-merge:1.38
	gdb_5_3-2002-12-12-release:1.34.6.1
	carlton_dictionary-20021115-merge:1.36
	kseitz_interps-20021105-merge:1.36
	kseitz_interps-20021103-merge:1.36
	drow-cplus-merge-20021020:1.35
	drow-cplus-merge-20021025:1.35
	carlton_dictionary-20021025-merge:1.35
	carlton_dictionary-20021011-merge:1.35
	drow-cplus-branch:1.35.0.4
	drow-cplus-branchpoint:1.35
	kseitz_interps-20020930-merge:1.35
	carlton_dictionary-20020927-merge:1.35
	carlton_dictionary-branch:1.35.0.2
	carlton_dictionary-20020920-branchpoint:1.35
	gdb_5_3-branch:1.34.0.6
	gdb_5_3-2002-09-04-branchpoint:1.34
	kseitz_interps-20020829-merge:1.34
	cagney_sysregs-20020825-branch:1.34.0.4
	cagney_sysregs-20020825-branchpoint:1.34
	readline_4_3-import-branch:1.34.0.2
	readline_4_3-import-branchpoint:1.34
	gdb_5_2_1-2002-07-23-release:1.30.2.1
	kseitz_interps-20020528-branch:1.33.0.4
	kseitz_interps-20020528-branchpoint:1.33
	cagney_regbuf-20020515-branch:1.33.0.2
	cagney_regbuf-20020515-branchpoint:1.33
	jimb-macro-020506-branch:1.32.0.2
	jimb-macro-020506-branchpoint:1.32
	gdb_5_2-2002-04-29-release:1.30.2.1
	gdb_5_2-branch:1.30.0.2
	gdb_5_2-2002-03-03-branchpoint:1.30
	gdb_5_1_1-2002-01-24-release:1.19.2.2
	gdb_5_1_0_1-2002-01-03-release:1.19.2.2
	cygnus_cvs_20020108_pre:1.28
	gdb_5_1_0_1-2002-01-03-branchpoint:1.19.2.2
	gdb_5_1_0_1-2002-01-03-branch:1.19.2.2.0.2
	gdb_5_1-2001-11-21-release:1.19.2.2
	gdb_s390-2001-09-26-branch:1.19.2.1.0.2
	gdb_s390-2001-09-26-branchpoint:1.19.2.1
	gdb_5_1-2001-07-29-branch:1.19.0.2
	gdb_5_1-2001-07-29-branchpoint:1.19
	dberlin-typesystem-branch:1.18.0.2
	dberlin-typesystem-branchpoint:1.18
	gdb-post-ptid_t-2001-05-03:1.18
	gdb-pre-ptid_t-2001-05-03:1.18
	insight-precleanup-2001-01-01:1.11
	gdb-post-protoization-2000-07-29:1.7
	gdb-pre-protoization-2000-07-29:1.6
	gdb-premipsmulti-2000-06-06-branch:1.6.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.6
	gdb-post-params-removal-2000-06-04:1.6
	gdb-pre-params-removal-2000-06-04:1.5
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.4
	gdb_5_0-2000-05-19-release:1.1.1.10
	gdb_4_18_2-2000-05-18-release:1.1.1.10
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.10
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.10
	gdb_5_0-2000-04-10-branch:1.1.1.10.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.10
	repo-unification-2000-02-06:1.1.1.10
	insight-2000-02-04:1.1.1.10
	gdb-2000-02-04:1.1.1.10
	gdb-2000-02-02:1.1.1.10
	gdb-2000-02-01:1.1.1.10
	gdb-2000-01-31:1.1.1.10
	gdb-2000-01-26:1.1.1.10
	gdb-2000-01-24:1.1.1.10
	gdb-2000-01-17:1.1.1.10
	gdb-2000-01-10:1.1.1.10
	gdb-2000-01-05:1.1.1.10
	gdb-1999-12-21:1.1.1.9
	gdb-1999-12-13:1.1.1.9
	gdb-1999-12-07:1.1.1.9
	gdb-1999-12-06:1.1.1.9
	gdb-1999-11-16:1.1.1.8
	gdb-1999-11-08:1.1.1.8
	gdb-1999-11-01:1.1.1.8
	gdb-1999-10-25:1.1.1.8
	gdb-1999-10-18:1.1.1.8
	gdb-1999-10-11:1.1.1.8
	gdb-1999-10-04:1.1.1.8
	gdb-1999-09-28:1.1.1.8
	gdb-1999-09-21:1.1.1.8
	gdb-1999-09-13:1.1.1.7
	gdb-1999-09-08:1.1.1.7
	gdb-1999-08-30:1.1.1.6
	gdb-1999-08-23:1.1.1.6
	gdb-1999-08-16:1.1.1.6
	gdb-1999-08-09:1.1.1.6
	gdb-1999-08-02:1.1.1.5
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.152
date	2013.10.16.16.00.23;	author tromey;	state Exp;
branches;
next	1.151;

1.151
date	2013.09.25.22.48.18;	author devans;	state Exp;
branches;
next	1.150;

1.150
date	2013.09.24.13.57.36;	author jkratoch;	state Exp;
branches;
next	1.149;

1.149
date	2013.08.20.18.57.00;	author devans;	state Exp;
branches;
next	1.148;

1.148
date	2013.08.20.18.25.12;	author tromey;	state Exp;
branches;
next	1.147;

1.147
date	2013.05.30.17.34.18;	author tromey;	state Exp;
branches;
next	1.146;

1.146
date	2013.05.06.19.15.17;	author devans;	state Exp;
branches;
next	1.145;

1.145
date	2013.04.08.20.13.21;	author tromey;	state Exp;
branches;
next	1.144;

1.144
date	2013.03.13.18.38.11;	author palves;	state Exp;
branches;
next	1.143;

1.143
date	2013.01.25.17.55.24;	author tromey;	state Exp;
branches;
next	1.142;

1.142
date	2013.01.21.18.13.13;	author tromey;	state Exp;
branches;
next	1.141;

1.141
date	2013.01.21.18.05.13;	author tromey;	state Exp;
branches;
next	1.140;

1.140
date	2013.01.18.03.09.42;	author qiyao;	state Exp;
branches;
next	1.139;

1.139
date	2013.01.14.10.39.33;	author qiyao;	state Exp;
branches;
next	1.138;

1.138
date	2013.01.01.06.32.41;	author brobecke;	state Exp;
branches;
next	1.137;

1.137
date	2012.12.12.17.03.02;	author tromey;	state Exp;
branches;
next	1.136;

1.136
date	2012.12.12.15.57.01;	author tromey;	state Exp;
branches;
next	1.135;

1.135
date	2012.11.21.00.29.54;	author qiyao;	state Exp;
branches;
next	1.134;

1.134
date	2012.04.27.20.47.53;	author sergiodj;	state Exp;
branches;
next	1.133;

1.133
date	2012.02.07.04.48.18;	author devans;	state Exp;
branches;
next	1.132;

1.132
date	2012.01.04.08.17.00;	author brobecke;	state Exp;
branches;
next	1.131;

1.131
date	2012.01.02.15.37.33;	author brobecke;	state Exp;
branches;
next	1.130;

1.130
date	2011.06.27.19.21.50;	author tromey;	state Exp;
branches
	1.130.2.1;
next	1.129;

1.129
date	2011.06.14.18.53.13;	author tromey;	state Exp;
branches;
next	1.128;

1.128
date	2011.06.14.16.49.41;	author tromey;	state Exp;
branches;
next	1.127;

1.127
date	2011.03.23.18.23.54;	author ktietz;	state Exp;
branches;
next	1.126;

1.126
date	2011.03.17.13.19.23;	author brobecke;	state Exp;
branches;
next	1.125;

1.125
date	2011.03.15.19.03.52;	author msnyder;	state Exp;
branches;
next	1.124;

1.124
date	2011.03.07.16.17.28;	author tromey;	state Exp;
branches;
next	1.123;

1.123
date	2011.02.28.23.55.18;	author msnyder;	state Exp;
branches;
next	1.122;

1.122
date	2011.02.28.23.23.05;	author msnyder;	state Exp;
branches;
next	1.121;

1.121
date	2011.02.26.02.07.07;	author msnyder;	state Exp;
branches;
next	1.120;

1.120
date	2011.01.07.19.36.15;	author msnyder;	state Exp;
branches;
next	1.119;

1.119
date	2011.01.05.22.22.47;	author msnyder;	state Exp;
branches;
next	1.118;

1.118
date	2010.10.01.20.26.11;	author tromey;	state Exp;
branches;
next	1.117;

1.117
date	2010.09.30.19.14.30;	author tromey;	state Exp;
branches;
next	1.116;

1.116
date	2010.05.14.17.53.15;	author msnyder;	state Exp;
branches;
next	1.115;

1.115
date	2010.03.10.18.27.00;	author tromey;	state Exp;
branches;
next	1.114;

1.114
date	2010.03.10.18.20.06;	author tromey;	state Exp;
branches;
next	1.113;

1.113
date	2010.02.03.14.13.16;	author gingold;	state Exp;
branches;
next	1.112;

1.112
date	2010.01.19.09.47.47;	author brobecke;	state Exp;
branches;
next	1.111;

1.111
date	2009.12.07.09.47.40;	author gingold;	state Exp;
branches;
next	1.110;

1.110
date	2009.12.07.09.36.43;	author gingold;	state Exp;
branches;
next	1.109;

1.109
date	2009.12.02.11.34.37;	author gingold;	state Exp;
branches;
next	1.108;

1.108
date	2009.11.17.20.48.31;	author jkratoch;	state Exp;
branches;
next	1.107;

1.107
date	2009.11.16.18.40.21;	author tromey;	state Exp;
branches;
next	1.106;

1.106
date	2009.11.11.20.05.33;	author msnyder;	state Exp;
branches;
next	1.105;

1.105
date	2009.07.29.23.10.05;	author ppluzhnikov;	state Exp;
branches;
next	1.104;

1.104
date	2009.06.29.16.48.15;	author palves;	state Exp;
branches;
next	1.103;

1.103
date	2009.06.17.18.41.50;	author uweigand;	state Exp;
branches;
next	1.102;

1.102
date	2009.05.23.16.17.13;	author jkratoch;	state Exp;
branches;
next	1.101;

1.101
date	2009.05.02.09.41.52;	author eliz;	state Exp;
branches;
next	1.100;

1.100
date	2009.03.31.20.21.07;	author tromey;	state Exp;
branches;
next	1.99;

1.99
date	2008.12.16.05.06.05;	author ppluzhnikov;	state Exp;
branches;
next	1.98;

1.98
date	2008.10.01.16.41.27;	author tromey;	state Exp;
branches;
next	1.97;

1.97
date	2008.08.21.18.40.34;	author drow;	state Exp;
branches;
next	1.96;

1.96
date	2008.05.15.13.23.34;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2008.03.26.14.53.28;	author uweigand;	state Exp;
branches;
next	1.94;

1.94
date	2008.01.28.23.43.57;	author devans;	state Exp;
branches;
next	1.93;

1.93
date	2008.01.28.23.19.41;	author devans;	state Exp;
branches;
next	1.92;

1.92
date	2008.01.16.04.43.38;	author deuling;	state Exp;
branches;
next	1.91;

1.91
date	2008.01.08.17.14.28;	author devans;	state Exp;
branches;
next	1.90;

1.90
date	2007.10.19.12.26.31;	author uweigand;	state Exp;
branches;
next	1.89;

1.89
date	2007.10.19.12.23.20;	author uweigand;	state Exp;
branches;
next	1.88;

1.88
date	2007.10.11.19.01.42;	author drow;	state Exp;
branches;
next	1.87;

1.87
date	2007.09.21.18.01.23;	author brobecke;	state Exp;
branches;
next	1.86;

1.86
date	2007.08.23.18.08.28;	author brobecke;	state Exp;
branches;
next	1.85;

1.85
date	2007.08.22.01.57.05;	author msnyder;	state Exp;
branches;
next	1.84;

1.84
date	2007.06.18.15.46.38;	author drow;	state Exp;
branches;
next	1.83;

1.83
date	2007.06.12.16.55.32;	author uweigand;	state Exp;
branches;
next	1.82;

1.82
date	2007.04.03.00.09.54;	author palves;	state Exp;
branches;
next	1.81;

1.81
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.80;

1.80
date	2005.02.11.18.13.49;	author cagney;	state Exp;
branches;
next	1.79;

1.79
date	2005.02.11.04.05.45;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2004.11.20.12.38.38;	author kettenis;	state Exp;
branches;
next	1.77;

1.77
date	2004.11.20.10.20.33;	author kettenis;	state Exp;
branches;
next	1.76;

1.76
date	2004.11.18.22.37.22;	author kettenis;	state Exp;
branches;
next	1.75;

1.75
date	2004.10.23.16.18.08;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2004.09.11.10.24.46;	author hilfingr;	state Exp;
branches;
next	1.73;

1.73
date	2004.09.07.21.55.10;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2004.08.10.21.52.04;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2004.08.10.20.03.31;	author cagney;	state Exp;
branches;
next	1.70;

1.70
date	2004.08.10.19.37.47;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2004.07.01.20.25.53;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2004.06.30.19.44.22;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2004.06.10.20.05.43;	author bobbybrasko;	state Exp;
branches;
next	1.66;

1.66
date	2004.06.10.15.52.04;	author ford;	state Exp;
branches;
next	1.65;

1.65
date	2004.05.07.14.29.33;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2004.02.14.15.46.32;	author ezannoni;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2004.02.07.18.29.53;	author ezannoni;	state Exp;
branches;
next	1.62;

1.62
date	2004.01.09.16.26.17;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2003.11.23.20.41.16;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2003.11.11.20.04.52;	author chastain;	state Exp;
branches;
next	1.59;

1.59
date	2003.11.08.00.13.02;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2003.11.06.22.54.01;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2003.10.06.19.27.12;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2003.09.16.18.56.34;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2003.09.14.16.32.12;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2003.09.13.00.17.36;	author jimb;	state Exp;
branches;
next	1.53;

1.53
date	2003.09.13.00.00.32;	author jimb;	state Exp;
branches;
next	1.52;

1.52
date	2003.09.12.23.34.55;	author jimb;	state Exp;
branches;
next	1.51;

1.51
date	2003.09.12.22.49.25;	author jimb;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.12.18.40.16;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2003.09.08.19.22.30;	author jimb;	state Exp;
branches;
next	1.48;

1.48
date	2003.06.11.22.27.10;	author carlton;	state Exp;
branches
	1.48.4.1;
next	1.47;

1.47
date	2003.06.11.13.16.27;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2003.05.14.17.43.16;	author ezannoni;	state Exp;
branches;
next	1.45;

1.45
date	2003.02.26.21.41.18;	author jjohnstn;	state Exp;
branches
	1.45.16.1;
next	1.44;

1.44
date	2003.02.25.21.36.17;	author carlton;	state Exp;
branches;
next	1.43;

1.43
date	2003.02.20.18.31.14;	author drow;	state Exp;
branches;
next	1.42;

1.42
date	2003.02.18.15.41.29;	author ezannoni;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.31.19.22.17;	author drow;	state Exp;
branches;
next	1.40;

1.40
date	2003.01.18.15.55.51;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2003.01.14.00.15.05;	author ezannoni;	state Exp;
branches;
next	1.38;

1.38
date	2002.12.17.00.39.07;	author kevinb;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.18.19.14.10;	author kdienes;	state Exp;
branches;
next	1.36;

1.36
date	2002.10.25.22.25.55;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.18.20.47.39;	author jimb;	state Exp;
branches
	1.35.2.1
	1.35.4.1;
next	1.34;

1.34
date	2002.07.29.22.55.26;	author cagney;	state Exp;
branches
	1.34.6.1;
next	1.33;

1.33
date	2002.05.10.07.32.50;	author kevinb;	state Exp;
branches
	1.33.4.1;
next	1.32;

1.32
date	2002.04.24.08.00.54;	author davem;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.21.19.48.54;	author drow;	state Exp;
branches;
next	1.30;

1.30
date	2002.02.22.00.17.13;	author fnf;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2002.02.04.11.55.34;	author rearnsha;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.02.22.38.23;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.08.04.39.04;	author ezannoni;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.06.23.38.14;	author fnf;	state Exp;
branches;
next	1.25;

1.25
date	2001.10.24.17.10.18;	author jimb;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.20.03.03.39;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.06.20.50.48;	author kevinb;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.05.02.54.15;	author ezannoni;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.05.02.13.11;	author ezannoni;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.15.05.02.28;	author hjl;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.07.17.19.50;	author cagney;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.04.27.00.19.09;	author jimb;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.03.27.20.36.23;	author jtc;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.26.02.48.23;	author ezannoni;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.07.02.57.08;	author jtc;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.06.08.21.06;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.19.14.53.44;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.15.01.01.46;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.08.19.59.25;	author msnyder;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.01.23.45.13;	author davea;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.21.17.30.58;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.28.01.12.26;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.22.09.02.23;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.16.04.07.39;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.04.16.52.33;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.130.2.1
date	2012.01.06.04.18.54;	author brobecke;	state Exp;
branches;
next	1.130.2.2;

1.130.2.2
date	2012.01.06.04.43.06;	author brobecke;	state Exp;
branches;
next	;

1.64.2.1
date	2004.09.16.17.01.01;	author drow;	state Exp;
branches;
next	;

1.48.4.1
date	2003.09.21.01.44.39;	author jimb;	state Exp;
branches;
next	;

1.45.16.1
date	2003.05.18.09.44.02;	author kettenis;	state Exp;
branches;
next	;

1.35.2.1
date	2002.09.20.18.52.16;	author carlton;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2002.11.15.19.18.41;	author carlton;	state Exp;
branches;
next	1.35.2.3;

1.35.2.3
date	2002.12.23.19.38.19;	author carlton;	state Exp;
branches;
next	1.35.2.4;

1.35.2.4
date	2003.02.07.19.17.47;	author carlton;	state Exp;
branches;
next	1.35.2.5;

1.35.2.5
date	2003.02.22.01.33.13;	author carlton;	state Exp;
branches;
next	1.35.2.6;

1.35.2.6
date	2003.03.06.00.56.26;	author carlton;	state Exp;
branches;
next	1.35.2.7;

1.35.2.7
date	2003.05.23.18.40.36;	author carlton;	state Exp;
branches;
next	1.35.2.8;

1.35.2.8
date	2003.06.27.21.49.52;	author carlton;	state Exp;
branches;
next	1.35.2.9;

1.35.2.9
date	2003.09.17.21.28.13;	author carlton;	state Exp;
branches;
next	1.35.2.10;

1.35.2.10
date	2003.11.11.23.50.39;	author carlton;	state Exp;
branches;
next	1.35.2.11;

1.35.2.11
date	2003.12.16.00.00.25;	author carlton;	state Exp;
branches;
next	1.35.2.12;

1.35.2.12
date	2004.01.26.19.11.22;	author carlton;	state Exp;
branches;
next	;

1.35.4.1
date	2003.12.14.20.27.10;	author drow;	state Exp;
branches;
next	1.35.4.2;

1.35.4.2
date	2004.01.13.16.11.54;	author drow;	state Exp;
branches;
next	1.35.4.3;

1.35.4.3
date	2004.02.09.19.43.35;	author drow;	state Exp;
branches;
next	;

1.34.6.1
date	2002.09.25.03.52.31;	author jimb;	state Exp;
branches;
next	;

1.33.4.1
date	2002.08.09.18.34.23;	author kseitz;	state Exp;
branches;
next	1.33.4.2;

1.33.4.2
date	2002.10.01.00.46.06;	author kseitz;	state Exp;
branches;
next	1.33.4.3;

1.33.4.3
date	2002.11.04.00.17.30;	author ezannoni;	state Exp;
branches;
next	;

1.30.2.1
date	2002.04.04.22.33.49;	author drow;	state Exp;
branches;
next	;

1.19.2.1
date	2001.08.16.22.25.20;	author drow;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.10.15.20.38.13;	author kevinb;	state Exp;
branches;
next	;

1.18.2.1
date	2001.07.06.19.16.58;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.00;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.25.18.01.36;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.05.28;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.02.23.45.21;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.09.21.33.22;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.09.08.23.59.06;	author shebs;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.09.22.03.24.23;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.12.07.03.55.59;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2000.01.06.03.06.36;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.152
log
@	* dbxread.c (read_dbx_symtab) <bss_ext_symbol>: Remove unused
	label.
@
text
@/* Read dbx symbol tables and convert to internal format, for GDB.
   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This module provides three functions: dbx_symfile_init,
   which initializes to read a symbol file; dbx_new_init, which 
   discards existing cached information when all symbols are being
   discarded; and dbx_symfile_read, which reads a symbol table
   from a file.

   dbx_symfile_read only does the minimum work necessary for letting the
   user "name" things symbolically; it does not read the entire symtab.
   Instead, it reads the external and static symbols and puts them in partial
   symbol tables.  When more extensive information is requested of a
   file, the corresponding partial symbol table is mutated into a full
   fledged symbol table by going back and reading the symbols
   for real.  dbx_psymtab_to_symtab() is the function that does this */

#include "defs.h"
#include "gdb_string.h"

#if defined(__CYGNUSCLIB__)
#include <sys/types.h>
#include <fcntl.h>
#endif

#include "gdb_obstack.h"
#include "gdb_stat.h"
#include "symtab.h"
#include "breakpoint.h"
#include "target.h"
#include "gdbcore.h"		/* for bfd stuff */
#include "libaout.h"		/* FIXME Secret internal BFD stuff for a.out */
#include "filenames.h"
#include "objfiles.h"
#include "buildsym.h"
#include "stabsread.h"
#include "gdb-stabs.h"
#include "demangle.h"
#include "complaints.h"
#include "cp-abi.h"
#include "cp-support.h"
#include "psympriv.h"
#include "block.h"

#include "gdb_assert.h"
#include "gdb_string.h"

#include "aout/aout64.h"
#include "aout/stab_gnu.h"	/* We always use GNU stabs, not
				   native, now.  */


/* Key for dbx-associated data.  */

const struct objfile_data *dbx_objfile_data_key;

/* We put a pointer to this structure in the read_symtab_private field
   of the psymtab.  */

struct symloc
  {
    /* Offset within the file symbol table of first local symbol for this
       file.  */

    int ldsymoff;

    /* Length (in bytes) of the section of the symbol table devoted to
       this file's symbols (actually, the section bracketed may contain
       more than just this file's symbols).  If ldsymlen is 0, the only
       reason for this thing's existence is the dependency list.  Nothing
       else will happen when it is read in.  */

    int ldsymlen;

    /* The size of each symbol in the symbol file (in external form).  */

    int symbol_size;

    /* Further information needed to locate the symbols if they are in
       an ELF file.  */

    int symbol_offset;
    int string_offset;
    int file_string_offset;
  };

#define LDSYMOFF(p) (((struct symloc *)((p)->read_symtab_private))->ldsymoff)
#define LDSYMLEN(p) (((struct symloc *)((p)->read_symtab_private))->ldsymlen)
#define SYMLOC(p) ((struct symloc *)((p)->read_symtab_private))
#define SYMBOL_SIZE(p) (SYMLOC(p)->symbol_size)
#define SYMBOL_OFFSET(p) (SYMLOC(p)->symbol_offset)
#define STRING_OFFSET(p) (SYMLOC(p)->string_offset)
#define FILE_STRING_OFFSET(p) (SYMLOC(p)->file_string_offset)


/* The objfile we are currently reading.  */

static struct objfile *dbxread_objfile;

/* Remember what we deduced to be the source language of this psymtab.  */

static enum language psymtab_language = language_unknown;

/* The BFD for this file -- implicit parameter to next_symbol_text.  */

static bfd *symfile_bfd;

/* The size of each symbol in the symbol file (in external form).
   This is set by dbx_symfile_read when building psymtabs, and by
   dbx_psymtab_to_symtab when building symtabs.  */

static unsigned symbol_size;

/* This is the offset of the symbol table in the executable file.  */

static unsigned symbol_table_offset;

/* This is the offset of the string table in the executable file.  */

static unsigned string_table_offset;

/* For elf+stab executables, the n_strx field is not a simple index
   into the string table.  Instead, each .o file has a base offset in
   the string table, and the associated symbols contain offsets from
   this base.  The following two variables contain the base offset for
   the current and next .o files.  */

static unsigned int file_string_table_offset;
static unsigned int next_file_string_table_offset;

/* .o and NLM files contain unrelocated addresses which are based at
   0.  When non-zero, this flag disables some of the special cases for
   Solaris elf+stab text addresses at location 0.  */

static int symfile_relocatable = 0;

/* If this is nonzero, N_LBRAC, N_RBRAC, and N_SLINE entries are
   relative to the function start address.  */

static int block_address_function_relative = 0;

/* The lowest text address we have yet encountered.  This is needed
   because in an a.out file, there is no header field which tells us
   what address the program is actually going to be loaded at, so we
   need to make guesses based on the symbols (which *are* relocated to
   reflect the address it will be loaded at).  */

static CORE_ADDR lowest_text_address;

/* Non-zero if there is any line number info in the objfile.  Prevents
   end_psymtab from discarding an otherwise empty psymtab.  */

static int has_line_numbers;

/* Complaints about the symbols we have encountered.  */

static void
unknown_symtype_complaint (const char *arg1)
{
  complaint (&symfile_complaints, _("unknown symbol type %s"), arg1);
}

static void
lbrac_mismatch_complaint (int arg1)
{
  complaint (&symfile_complaints,
	     _("N_LBRAC/N_RBRAC symbol mismatch at symtab pos %d"), arg1);
}

static void
repeated_header_complaint (const char *arg1, int arg2)
{
  complaint (&symfile_complaints,
	     _("\"repeated\" header file %s not "
	       "previously seen, at symtab pos %d"),
	     arg1, arg2);
}

/* find_text_range --- find start and end of loadable code sections

   The find_text_range function finds the shortest address range that
   encloses all sections containing executable code, and stores it in
   objfile's text_addr and text_size members.

   dbx_symfile_read will use this to finish off the partial symbol
   table, in some cases.  */

static void
find_text_range (bfd * sym_bfd, struct objfile *objfile)
{
  asection *sec;
  int found_any = 0;
  CORE_ADDR start = 0;
  CORE_ADDR end = 0;

  for (sec = sym_bfd->sections; sec; sec = sec->next)
    if (bfd_get_section_flags (sym_bfd, sec) & SEC_CODE)
      {
	CORE_ADDR sec_start = bfd_section_vma (sym_bfd, sec);
	CORE_ADDR sec_end = sec_start + bfd_section_size (sym_bfd, sec);

	if (found_any)
	  {
	    if (sec_start < start)
	      start = sec_start;
	    if (sec_end > end)
	      end = sec_end;
	  }
	else
	  {
	    start = sec_start;
	    end = sec_end;
	  }

	found_any = 1;
      }

  if (!found_any)
    error (_("Can't find any code sections in symbol file"));

  DBX_TEXT_ADDR (objfile) = start;
  DBX_TEXT_SIZE (objfile) = end - start;
}



/* During initial symbol readin, we need to have a structure to keep
   track of which psymtabs have which bincls in them.  This structure
   is used during readin to setup the list of dependencies within each
   partial symbol table.  */

struct header_file_location
{
  char *name;			/* Name of header file */
  int instance;			/* See above */
  struct partial_symtab *pst;	/* Partial symtab that has the
				   BINCL/EINCL defs for this file.  */
};

/* The actual list and controling variables.  */
static struct header_file_location *bincl_list, *next_bincl;
static int bincls_allocated;

/* Local function prototypes.  */

extern void _initialize_dbxread (void);

static void read_ofile_symtab (struct objfile *, struct partial_symtab *);

static void dbx_read_symtab (struct partial_symtab *self,
			     struct objfile *objfile);

static void dbx_psymtab_to_symtab_1 (struct objfile *, struct partial_symtab *);

static void read_dbx_dynamic_symtab (struct objfile *objfile);

static void read_dbx_symtab (struct objfile *);

static void free_bincl_list (struct objfile *);

static struct partial_symtab *find_corresponding_bincl_psymtab (char *, int);

static void add_bincl_to_list (struct partial_symtab *, char *, int);

static void init_bincl_list (int, struct objfile *);

static char *dbx_next_symbol_text (struct objfile *);

static void fill_symbuf (bfd *);

static void dbx_symfile_init (struct objfile *);

static void dbx_new_init (struct objfile *);

static void dbx_symfile_read (struct objfile *, int);

static void dbx_symfile_finish (struct objfile *);

static void record_minimal_symbol (const char *, CORE_ADDR, int,
				   struct objfile *);

static void add_new_header_file (char *, int);

static void add_old_header_file (char *, int);

static void add_this_object_header_file (int);

static struct partial_symtab *start_psymtab (struct objfile *, char *,
					     CORE_ADDR, int,
					     struct partial_symbol **,
					     struct partial_symbol **);

/* Free up old header file tables.  */

void
free_header_files (void)
{
  if (this_object_header_files)
    {
      xfree (this_object_header_files);
      this_object_header_files = NULL;
    }
  n_allocated_this_object_header_files = 0;
}

/* Allocate new header file tables.  */

void
init_header_files (void)
{
  n_allocated_this_object_header_files = 10;
  this_object_header_files = (int *) xmalloc (10 * sizeof (int));
}

/* Add header file number I for this object file
   at the next successive FILENUM.  */

static void
add_this_object_header_file (int i)
{
  if (n_this_object_header_files == n_allocated_this_object_header_files)
    {
      n_allocated_this_object_header_files *= 2;
      this_object_header_files
	= (int *) xrealloc ((char *) this_object_header_files,
		       n_allocated_this_object_header_files * sizeof (int));
    }

  this_object_header_files[n_this_object_header_files++] = i;
}

/* Add to this file an "old" header file, one already seen in
   a previous object file.  NAME is the header file's name.
   INSTANCE is its instance code, to select among multiple
   symbol tables for the same header file.  */

static void
add_old_header_file (char *name, int instance)
{
  struct header_file *p = HEADER_FILES (dbxread_objfile);
  int i;

  for (i = 0; i < N_HEADER_FILES (dbxread_objfile); i++)
    if (filename_cmp (p[i].name, name) == 0 && instance == p[i].instance)
      {
	add_this_object_header_file (i);
	return;
      }
  repeated_header_complaint (name, symnum);
}

/* Add to this file a "new" header file: definitions for its types follow.
   NAME is the header file's name.
   Most often this happens only once for each distinct header file,
   but not necessarily.  If it happens more than once, INSTANCE has
   a different value each time, and references to the header file
   use INSTANCE values to select among them.

   dbx output contains "begin" and "end" markers for each new header file,
   but at this level we just need to know which files there have been;
   so we record the file when its "begin" is seen and ignore the "end".  */

static void
add_new_header_file (char *name, int instance)
{
  int i;
  struct header_file *hfile;

  /* Make sure there is room for one more header file.  */

  i = N_ALLOCATED_HEADER_FILES (dbxread_objfile);

  if (N_HEADER_FILES (dbxread_objfile) == i)
    {
      if (i == 0)
	{
	  N_ALLOCATED_HEADER_FILES (dbxread_objfile) = 10;
	  HEADER_FILES (dbxread_objfile) = (struct header_file *)
	    xmalloc (10 * sizeof (struct header_file));
	}
      else
	{
	  i *= 2;
	  N_ALLOCATED_HEADER_FILES (dbxread_objfile) = i;
	  HEADER_FILES (dbxread_objfile) = (struct header_file *)
	    xrealloc ((char *) HEADER_FILES (dbxread_objfile),
		      (i * sizeof (struct header_file)));
	}
    }

  /* Create an entry for this header file.  */

  i = N_HEADER_FILES (dbxread_objfile)++;
  hfile = HEADER_FILES (dbxread_objfile) + i;
  hfile->name = xstrdup (name);
  hfile->instance = instance;
  hfile->length = 10;
  hfile->vector
    = (struct type **) xmalloc (10 * sizeof (struct type *));
  memset (hfile->vector, 0, 10 * sizeof (struct type *));

  add_this_object_header_file (i);
}

#if 0
static struct type **
explicit_lookup_type (int real_filenum, int index)
{
  struct header_file *f = &HEADER_FILES (dbxread_objfile)[real_filenum];

  if (index >= f->length)
    {
      f->length *= 2;
      f->vector = (struct type **)
	xrealloc (f->vector, f->length * sizeof (struct type *));
      memset (&f->vector[f->length / 2],
	      '\0', f->length * sizeof (struct type *) / 2);
    }
  return &f->vector[index];
}
#endif

static void
record_minimal_symbol (const char *name, CORE_ADDR address, int type,
		       struct objfile *objfile)
{
  enum minimal_symbol_type ms_type;
  int section;

  switch (type)
    {
    case N_TEXT | N_EXT:
      ms_type = mst_text;
      section = SECT_OFF_TEXT (objfile);
      break;
    case N_DATA | N_EXT:
      ms_type = mst_data;
      section = SECT_OFF_DATA (objfile);
      break;
    case N_BSS | N_EXT:
      ms_type = mst_bss;
      section = SECT_OFF_BSS (objfile);
      break;
    case N_ABS | N_EXT:
      ms_type = mst_abs;
      section = -1;
      break;
#ifdef N_SETV
    case N_SETV | N_EXT:
      ms_type = mst_data;
      section = SECT_OFF_DATA (objfile);
      break;
    case N_SETV:
      /* I don't think this type actually exists; since a N_SETV is the result
         of going over many .o files, it doesn't make sense to have one
         file local.  */
      ms_type = mst_file_data;
      section = SECT_OFF_DATA (objfile);
      break;
#endif
    case N_TEXT:
    case N_NBTEXT:
    case N_FN:
    case N_FN_SEQ:
      ms_type = mst_file_text;
      section = SECT_OFF_TEXT (objfile);
      break;
    case N_DATA:
      ms_type = mst_file_data;

      /* Check for __DYNAMIC, which is used by Sun shared libraries. 
         Record it as global even if it's local, not global, so
         lookup_minimal_symbol can find it.  We don't check symbol_leading_char
         because for SunOS4 it always is '_'.  */
      if (name[8] == 'C' && strcmp ("__DYNAMIC", name) == 0)
	ms_type = mst_data;

      /* Same with virtual function tables, both global and static.  */
      {
	const char *tempstring = name;

	if (tempstring[0] == bfd_get_symbol_leading_char (objfile->obfd))
	  ++tempstring;
	if (is_vtable_name (tempstring))
	  ms_type = mst_data;
      }
      section = SECT_OFF_DATA (objfile);
      break;
    case N_BSS:
      ms_type = mst_file_bss;
      section = SECT_OFF_BSS (objfile);
      break;
    default:
      ms_type = mst_unknown;
      section = -1;
      break;
    }

  if ((ms_type == mst_file_text || ms_type == mst_text)
      && address < lowest_text_address)
    lowest_text_address = address;

  prim_record_minimal_symbol_and_info
    (name, address, ms_type, section, objfile);
}

/* Scan and build partial symbols for a symbol file.
   We have been initialized by a call to dbx_symfile_init, which 
   put all the relevant info into a "struct dbx_symfile_info",
   hung off the objfile structure.  */

static void
dbx_symfile_read (struct objfile *objfile, int symfile_flags)
{
  bfd *sym_bfd;
  int val;
  struct cleanup *back_to;

  sym_bfd = objfile->obfd;

  /* .o and .nlm files are relocatables with text, data and bss segs based at
     0.  This flag disables special (Solaris stabs-in-elf only) fixups for
     symbols with a value of 0.  */

  symfile_relocatable = bfd_get_file_flags (sym_bfd) & HAS_RELOC;

  /* This is true for Solaris (and all other systems which put stabs
     in sections, hopefully, since it would be silly to do things
     differently from Solaris), and false for SunOS4 and other a.out
     file formats.  */
  block_address_function_relative =
    ((0 == strncmp (bfd_get_target (sym_bfd), "elf", 3))
     || (0 == strncmp (bfd_get_target (sym_bfd), "som", 3))
     || (0 == strncmp (bfd_get_target (sym_bfd), "coff", 4))
     || (0 == strncmp (bfd_get_target (sym_bfd), "pe", 2))
     || (0 == strncmp (bfd_get_target (sym_bfd), "epoc-pe", 7))
     || (0 == strncmp (bfd_get_target (sym_bfd), "nlm", 3)));

  val = bfd_seek (sym_bfd, DBX_SYMTAB_OFFSET (objfile), SEEK_SET);
  if (val < 0)
    perror_with_name (objfile_name (objfile));

  /* Size the symbol table.  */
  if (objfile->global_psymbols.size == 0 && objfile->static_psymbols.size == 0)
    init_psymbol_list (objfile, DBX_SYMCOUNT (objfile));

  symbol_size = DBX_SYMBOL_SIZE (objfile);
  symbol_table_offset = DBX_SYMTAB_OFFSET (objfile);

  free_pending_blocks ();
  back_to = make_cleanup (really_free_pendings, 0);

  init_minimal_symbol_collection ();
  make_cleanup_discard_minimal_symbols ();

  /* Read stabs data from executable file and define symbols.  */

  read_dbx_symtab (objfile);

  /* Add the dynamic symbols.  */

  read_dbx_dynamic_symtab (objfile);

  /* Install any minimal symbols that have been collected as the current
     minimal symbols for this objfile.  */

  install_minimal_symbols (objfile);

  do_cleanups (back_to);
}

/* Initialize anything that needs initializing when a completely new
   symbol file is specified (not just adding some symbols from another
   file, e.g. a shared library).  */

static void
dbx_new_init (struct objfile *ignore)
{
  stabsread_new_init ();
  buildsym_new_init ();
  init_header_files ();
}


/* dbx_symfile_init ()
   is the dbx-specific initialization routine for reading symbols.
   It is passed a struct objfile which contains, among other things,
   the BFD for the file whose symbols are being read, and a slot for a pointer
   to "private data" which we fill with goodies.

   We read the string table into malloc'd space and stash a pointer to it.

   Since BFD doesn't know how to read debug symbols in a format-independent
   way (and may never do so...), we have to do it ourselves.  We will never
   be called unless this is an a.out (or very similar) file.
   FIXME, there should be a cleaner peephole into the BFD environment here.  */

#define DBX_STRINGTAB_SIZE_SIZE sizeof(long)	/* FIXME */

static void
dbx_symfile_init (struct objfile *objfile)
{
  int val;
  bfd *sym_bfd = objfile->obfd;
  char *name = bfd_get_filename (sym_bfd);
  asection *text_sect;
  unsigned char size_temp[DBX_STRINGTAB_SIZE_SIZE];
  struct dbx_symfile_info *dbx;

  /* Allocate struct to keep track of the symfile.  */
  dbx = XCNEW (struct dbx_symfile_info);
  set_objfile_data (objfile, dbx_objfile_data_key, dbx);

  DBX_TEXT_SECTION (objfile) = bfd_get_section_by_name (sym_bfd, ".text");
  DBX_DATA_SECTION (objfile) = bfd_get_section_by_name (sym_bfd, ".data");
  DBX_BSS_SECTION (objfile) = bfd_get_section_by_name (sym_bfd, ".bss");

  /* FIXME POKING INSIDE BFD DATA STRUCTURES.  */
#define	STRING_TABLE_OFFSET	(sym_bfd->origin + obj_str_filepos (sym_bfd))
#define	SYMBOL_TABLE_OFFSET	(sym_bfd->origin + obj_sym_filepos (sym_bfd))

  /* FIXME POKING INSIDE BFD DATA STRUCTURES.  */

  DBX_SYMFILE_INFO (objfile)->stab_section_info = NULL;

  text_sect = bfd_get_section_by_name (sym_bfd, ".text");
  if (!text_sect)
    error (_("Can't find .text section in symbol file"));
  DBX_TEXT_ADDR (objfile) = bfd_section_vma (sym_bfd, text_sect);
  DBX_TEXT_SIZE (objfile) = bfd_section_size (sym_bfd, text_sect);

  DBX_SYMBOL_SIZE (objfile) = obj_symbol_entry_size (sym_bfd);
  DBX_SYMCOUNT (objfile) = bfd_get_symcount (sym_bfd);
  DBX_SYMTAB_OFFSET (objfile) = SYMBOL_TABLE_OFFSET;

  /* Read the string table and stash it away in the objfile_obstack.
     When we blow away the objfile the string table goes away as well.
     Note that gdb used to use the results of attempting to malloc the
     string table, based on the size it read, as a form of sanity check
     for botched byte swapping, on the theory that a byte swapped string
     table size would be so totally bogus that the malloc would fail.  Now
     that we put in on the objfile_obstack, we can't do this since gdb gets
     a fatal error (out of virtual memory) if the size is bogus.  We can
     however at least check to see if the size is less than the size of
     the size field itself, or larger than the size of the entire file.
     Note that all valid string tables have a size greater than zero, since
     the bytes used to hold the size are included in the count.  */

  if (STRING_TABLE_OFFSET == 0)
    {
      /* It appears that with the existing bfd code, STRING_TABLE_OFFSET
         will never be zero, even when there is no string table.  This
         would appear to be a bug in bfd.  */
      DBX_STRINGTAB_SIZE (objfile) = 0;
      DBX_STRINGTAB (objfile) = NULL;
    }
  else
    {
      val = bfd_seek (sym_bfd, STRING_TABLE_OFFSET, SEEK_SET);
      if (val < 0)
	perror_with_name (name);

      memset (size_temp, 0, sizeof (size_temp));
      val = bfd_bread (size_temp, sizeof (size_temp), sym_bfd);
      if (val < 0)
	{
	  perror_with_name (name);
	}
      else if (val == 0)
	{
	  /* With the existing bfd code, STRING_TABLE_OFFSET will be set to
	     EOF if there is no string table, and attempting to read the size
	     from EOF will read zero bytes.  */
	  DBX_STRINGTAB_SIZE (objfile) = 0;
	  DBX_STRINGTAB (objfile) = NULL;
	}
      else
	{
	  /* Read some data that would appear to be the string table size.
	     If there really is a string table, then it is probably the right
	     size.  Byteswap if necessary and validate the size.  Note that
	     the minimum is DBX_STRINGTAB_SIZE_SIZE.  If we just read some
	     random data that happened to be at STRING_TABLE_OFFSET, because
	     bfd can't tell us there is no string table, the sanity checks may
	     or may not catch this.  */
	  DBX_STRINGTAB_SIZE (objfile) = bfd_h_get_32 (sym_bfd, size_temp);

	  if (DBX_STRINGTAB_SIZE (objfile) < sizeof (size_temp)
	      || DBX_STRINGTAB_SIZE (objfile) > bfd_get_size (sym_bfd))
	    error (_("ridiculous string table size (%d bytes)."),
		   DBX_STRINGTAB_SIZE (objfile));

	  DBX_STRINGTAB (objfile) =
	    (char *) obstack_alloc (&objfile->objfile_obstack,
				    DBX_STRINGTAB_SIZE (objfile));
	  OBJSTAT (objfile, sz_strtab += DBX_STRINGTAB_SIZE (objfile));

	  /* Now read in the string table in one big gulp.  */

	  val = bfd_seek (sym_bfd, STRING_TABLE_OFFSET, SEEK_SET);
	  if (val < 0)
	    perror_with_name (name);
	  val = bfd_bread (DBX_STRINGTAB (objfile),
			   DBX_STRINGTAB_SIZE (objfile),
			   sym_bfd);
	  if (val != DBX_STRINGTAB_SIZE (objfile))
	    perror_with_name (name);
	}
    }
}

/* Perform any local cleanups required when we are done with a particular
   objfile.  I.E, we are in the process of discarding all symbol information
   for an objfile, freeing up all memory held for it, and unlinking the
   objfile struct from the global list of known objfiles.  */

static void
dbx_symfile_finish (struct objfile *objfile)
{
  free_header_files ();
}

static void
dbx_free_symfile_info (struct objfile *objfile, void *arg)
{
  struct dbx_symfile_info *dbx = arg;

  if (dbx->header_files != NULL)
    {
      int i = dbx->n_header_files;
      struct header_file *hfiles = dbx->header_files;

      while (--i >= 0)
	{
	  xfree (hfiles[i].name);
	  xfree (hfiles[i].vector);
	}
      xfree (hfiles);
    }

  xfree (dbx);
}



/* Buffer for reading the symbol table entries.  */
static struct external_nlist symbuf[4096];
static int symbuf_idx;
static int symbuf_end;

/* Name of last function encountered.  Used in Solaris to approximate
   object file boundaries.  */
static char *last_function_name;

/* The address in memory of the string table of the object file we are
   reading (which might not be the "main" object file, but might be a
   shared library or some other dynamically loaded thing).  This is
   set by read_dbx_symtab when building psymtabs, and by
   read_ofile_symtab when building symtabs, and is used only by
   next_symbol_text.  FIXME: If that is true, we don't need it when
   building psymtabs, right?  */
static char *stringtab_global;

/* These variables are used to control fill_symbuf when the stabs
   symbols are not contiguous (as may be the case when a COFF file is
   linked using --split-by-reloc).  */
static struct stab_section_list *symbuf_sections;
static unsigned int symbuf_left;
static unsigned int symbuf_read;

/* This variable stores a global stabs buffer, if we read stabs into
   memory in one chunk in order to process relocations.  */
static bfd_byte *stabs_data;

/* Refill the symbol table input buffer
   and set the variables that control fetching entries from it.
   Reports an error if no data available.
   This function can read past the end of the symbol table
   (into the string table) but this does no harm.  */

static void
fill_symbuf (bfd *sym_bfd)
{
  unsigned int count;
  int nbytes;

  if (stabs_data)
    {
      nbytes = sizeof (symbuf);
      if (nbytes > symbuf_left)
        nbytes = symbuf_left;
      memcpy (symbuf, stabs_data + symbuf_read, nbytes);
    }
  else if (symbuf_sections == NULL)
    {
      count = sizeof (symbuf);
      nbytes = bfd_bread (symbuf, count, sym_bfd);
    }
  else
    {
      if (symbuf_left <= 0)
	{
	  file_ptr filepos = symbuf_sections->section->filepos;

	  if (bfd_seek (sym_bfd, filepos, SEEK_SET) != 0)
	    perror_with_name (bfd_get_filename (sym_bfd));
	  symbuf_left = bfd_section_size (sym_bfd, symbuf_sections->section);
	  symbol_table_offset = filepos - symbuf_read;
	  symbuf_sections = symbuf_sections->next;
	}

      count = symbuf_left;
      if (count > sizeof (symbuf))
	count = sizeof (symbuf);
      nbytes = bfd_bread (symbuf, count, sym_bfd);
    }

  if (nbytes < 0)
    perror_with_name (bfd_get_filename (sym_bfd));
  else if (nbytes == 0)
    error (_("Premature end of file reading symbol table"));
  symbuf_end = nbytes / symbol_size;
  symbuf_idx = 0;
  symbuf_left -= nbytes;
  symbuf_read += nbytes;
}

static void
stabs_seek (int sym_offset)
{
  if (stabs_data)
    {
      symbuf_read += sym_offset;
      symbuf_left -= sym_offset;
    }
  else
    bfd_seek (symfile_bfd, sym_offset, SEEK_CUR);
}

#define INTERNALIZE_SYMBOL(intern, extern, abfd)			\
  {									\
    (intern).n_strx = bfd_h_get_32 (abfd, (extern)->e_strx);		\
    (intern).n_type = bfd_h_get_8 (abfd, (extern)->e_type);		\
    (intern).n_other = 0;						\
    (intern).n_desc = bfd_h_get_16 (abfd, (extern)->e_desc);  		\
    if (bfd_get_sign_extend_vma (abfd))					\
      (intern).n_value = bfd_h_get_signed_32 (abfd, (extern)->e_value);	\
    else								\
      (intern).n_value = bfd_h_get_32 (abfd, (extern)->e_value);	\
  }

/* Invariant: The symbol pointed to by symbuf_idx is the first one
   that hasn't been swapped.  Swap the symbol at the same time
   that symbuf_idx is incremented.  */

/* dbx allows the text of a symbol name to be continued into the
   next symbol name!  When such a continuation is encountered
   (a \ at the end of the text of a name)
   call this function to get the continuation.  */

static char *
dbx_next_symbol_text (struct objfile *objfile)
{
  struct internal_nlist nlist;

  if (symbuf_idx == symbuf_end)
    fill_symbuf (symfile_bfd);

  symnum++;
  INTERNALIZE_SYMBOL (nlist, &symbuf[symbuf_idx], symfile_bfd);
  OBJSTAT (objfile, n_stabs++);

  symbuf_idx++;

  return nlist.n_strx + stringtab_global + file_string_table_offset;
}

/* Initialize the list of bincls to contain none and have some
   allocated.  */

static void
init_bincl_list (int number, struct objfile *objfile)
{
  bincls_allocated = number;
  next_bincl = bincl_list = (struct header_file_location *)
    xmalloc (bincls_allocated * sizeof (struct header_file_location));
}

/* Add a bincl to the list.  */

static void
add_bincl_to_list (struct partial_symtab *pst, char *name, int instance)
{
  if (next_bincl >= bincl_list + bincls_allocated)
    {
      int offset = next_bincl - bincl_list;

      bincls_allocated *= 2;
      bincl_list = (struct header_file_location *)
	xrealloc ((char *) bincl_list,
		  bincls_allocated * sizeof (struct header_file_location));
      next_bincl = bincl_list + offset;
    }
  next_bincl->pst = pst;
  next_bincl->instance = instance;
  next_bincl++->name = name;
}

/* Given a name, value pair, find the corresponding
   bincl in the list.  Return the partial symtab associated
   with that header_file_location.  */

static struct partial_symtab *
find_corresponding_bincl_psymtab (char *name, int instance)
{
  struct header_file_location *bincl;

  for (bincl = bincl_list; bincl < next_bincl; bincl++)
    if (bincl->instance == instance
	&& strcmp (name, bincl->name) == 0)
      return bincl->pst;

  repeated_header_complaint (name, symnum);
  return (struct partial_symtab *) 0;
}

/* Free the storage allocated for the bincl list.  */

static void
free_bincl_list (struct objfile *objfile)
{
  xfree (bincl_list);
  bincls_allocated = 0;
}

static void
do_free_bincl_list_cleanup (void *objfile)
{
  free_bincl_list (objfile);
}

static struct cleanup *
make_cleanup_free_bincl_list (struct objfile *objfile)
{
  return make_cleanup (do_free_bincl_list_cleanup, objfile);
}

/* Set namestring based on nlist.  If the string table index is invalid, 
   give a fake name, and print a single error message per symbol file read,
   rather than abort the symbol reading or flood the user with messages.  */

static char *
set_namestring (struct objfile *objfile, const struct internal_nlist *nlist)
{
  char *namestring;

  if (nlist->n_strx + file_string_table_offset
      >= DBX_STRINGTAB_SIZE (objfile)
      || nlist->n_strx + file_string_table_offset < nlist->n_strx)
    {
      complaint (&symfile_complaints,
		 _("bad string table offset in symbol %d"),
		 symnum);
      namestring = "<bad string table offset>";
    } 
  else
    namestring = (nlist->n_strx + file_string_table_offset
		  + DBX_STRINGTAB (objfile));
  return namestring;
}

/* Scan a SunOs dynamic symbol table for symbols of interest and
   add them to the minimal symbol table.  */

static void
read_dbx_dynamic_symtab (struct objfile *objfile)
{
  bfd *abfd = objfile->obfd;
  struct cleanup *back_to;
  int counter;
  long dynsym_size;
  long dynsym_count;
  asymbol **dynsyms;
  asymbol **symptr;
  arelent **relptr;
  long dynrel_size;
  long dynrel_count;
  arelent **dynrels;
  CORE_ADDR sym_value;
  const char *name;

  /* Check that the symbol file has dynamic symbols that we know about.
     bfd_arch_unknown can happen if we are reading a sun3 symbol file
     on a sun4 host (and vice versa) and bfd is not configured
     --with-target=all.  This would trigger an assertion in bfd/sunos.c,
     so we ignore the dynamic symbols in this case.  */
  if (bfd_get_flavour (abfd) != bfd_target_aout_flavour
      || (bfd_get_file_flags (abfd) & DYNAMIC) == 0
      || bfd_get_arch (abfd) == bfd_arch_unknown)
    return;

  dynsym_size = bfd_get_dynamic_symtab_upper_bound (abfd);
  if (dynsym_size < 0)
    return;

  dynsyms = (asymbol **) xmalloc (dynsym_size);
  back_to = make_cleanup (xfree, dynsyms);

  dynsym_count = bfd_canonicalize_dynamic_symtab (abfd, dynsyms);
  if (dynsym_count < 0)
    {
      do_cleanups (back_to);
      return;
    }

  /* Enter dynamic symbols into the minimal symbol table
     if this is a stripped executable.  */
  if (bfd_get_symcount (abfd) <= 0)
    {
      symptr = dynsyms;
      for (counter = 0; counter < dynsym_count; counter++, symptr++)
	{
	  asymbol *sym = *symptr;
	  asection *sec;
	  int type;

	  sec = bfd_get_section (sym);

	  /* BFD symbols are section relative.  */
	  sym_value = sym->value + sec->vma;

	  if (bfd_get_section_flags (abfd, sec) & SEC_CODE)
	    {
	      sym_value += ANOFFSET (objfile->section_offsets,
				     SECT_OFF_TEXT (objfile));
	      type = N_TEXT;
	    }
	  else if (bfd_get_section_flags (abfd, sec) & SEC_DATA)
	    {
	      sym_value	+= ANOFFSET (objfile->section_offsets,
				     SECT_OFF_DATA (objfile));
	      type = N_DATA;
	    }
	  else if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)
	    {
	      sym_value += ANOFFSET (objfile->section_offsets,
				     SECT_OFF_BSS (objfile));
	      type = N_BSS;
	    }
	  else
	    continue;

	  if (sym->flags & BSF_GLOBAL)
	    type |= N_EXT;

	  record_minimal_symbol (bfd_asymbol_name (sym), sym_value,
				 type, objfile);
	}
    }

  /* Symbols from shared libraries have a dynamic relocation entry
     that points to the associated slot in the procedure linkage table.
     We make a mininal symbol table entry with type mst_solib_trampoline
     at the address in the procedure linkage table.  */
  dynrel_size = bfd_get_dynamic_reloc_upper_bound (abfd);
  if (dynrel_size < 0)
    {
      do_cleanups (back_to);
      return;
    }

  dynrels = (arelent **) xmalloc (dynrel_size);
  make_cleanup (xfree, dynrels);

  dynrel_count = bfd_canonicalize_dynamic_reloc (abfd, dynrels, dynsyms);
  if (dynrel_count < 0)
    {
      do_cleanups (back_to);
      return;
    }

  for (counter = 0, relptr = dynrels;
       counter < dynrel_count;
       counter++, relptr++)
    {
      arelent *rel = *relptr;
      CORE_ADDR address =
	rel->address + ANOFFSET (objfile->section_offsets,
				 SECT_OFF_DATA (objfile));

      switch (bfd_get_arch (abfd))
	{
	case bfd_arch_sparc:
	  if (rel->howto->type != RELOC_JMP_SLOT)
	    continue;
	  break;
	case bfd_arch_m68k:
	  /* `16' is the type BFD produces for a jump table relocation.  */
	  if (rel->howto->type != 16)
	    continue;

	  /* Adjust address in the jump table to point to
	     the start of the bsr instruction.  */
	  address -= 2;
	  break;
	default:
	  continue;
	}

      name = bfd_asymbol_name (*rel->sym_ptr_ptr);
      prim_record_minimal_symbol (name, address, mst_solib_trampoline,
				  objfile);
    }

  do_cleanups (back_to);
}

static CORE_ADDR
find_stab_function_addr (char *namestring, const char *filename,
			 struct objfile *objfile)
{
  struct minimal_symbol *msym;
  char *p;
  int n;

  p = strchr (namestring, ':');
  if (p == NULL)
    p = namestring;
  n = p - namestring;
  p = alloca (n + 2);
  strncpy (p, namestring, n);
  p[n] = 0;

  msym = lookup_minimal_symbol (p, filename, objfile);
  if (msym == NULL)
    {
      /* Sun Fortran appends an underscore to the minimal symbol name,
         try again with an appended underscore if the minimal symbol
         was not found.  */
      p[n] = '_';
      p[n + 1] = 0;
      msym = lookup_minimal_symbol (p, filename, objfile);
    }

  if (msym == NULL && filename != NULL)
    {
      /* Try again without the filename.  */
      p[n] = 0;
      msym = lookup_minimal_symbol (p, NULL, objfile);
    }
  if (msym == NULL && filename != NULL)
    {
      /* And try again for Sun Fortran, but without the filename.  */
      p[n] = '_';
      p[n + 1] = 0;
      msym = lookup_minimal_symbol (p, NULL, objfile);
    }

  return msym == NULL ? 0 : SYMBOL_VALUE_ADDRESS (msym);
}

static void
function_outside_compilation_unit_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     _("function `%s' appears to be defined "
	       "outside of all compilation units"),
	     arg1);
}

/* Setup partial_symtab's describing each source file for which
   debugging information is available.  */

static void
read_dbx_symtab (struct objfile *objfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  struct external_nlist *bufp = 0;	/* =0 avoids gcc -Wall glitch.  */
  struct internal_nlist nlist;
  CORE_ADDR text_addr;
  int text_size;
  char *sym_name;
  int sym_len;

  char *namestring;
  int nsl;
  int past_first_source_file = 0;
  CORE_ADDR last_o_file_start = 0;
  CORE_ADDR last_function_start = 0;
  struct cleanup *back_to;
  bfd *abfd;
  int textlow_not_set;
  int data_sect_index;

  /* Current partial symtab.  */
  struct partial_symtab *pst;

  /* List of current psymtab's include files.  */
  const char **psymtab_include_list;
  int includes_allocated;
  int includes_used;

  /* Index within current psymtab dependency list.  */
  struct partial_symtab **dependency_list;
  int dependencies_used, dependencies_allocated;

  text_addr = DBX_TEXT_ADDR (objfile);
  text_size = DBX_TEXT_SIZE (objfile);

  /* FIXME.  We probably want to change stringtab_global rather than add this
     while processing every symbol entry.  FIXME.  */
  file_string_table_offset = 0;
  next_file_string_table_offset = 0;

  stringtab_global = DBX_STRINGTAB (objfile);

  pst = (struct partial_symtab *) 0;

  includes_allocated = 30;
  includes_used = 0;
  psymtab_include_list = (const char **) alloca (includes_allocated *
						 sizeof (const char *));

  dependencies_allocated = 30;
  dependencies_used = 0;
  dependency_list =
    (struct partial_symtab **) alloca (dependencies_allocated *
				       sizeof (struct partial_symtab *));

  /* Init bincl list */
  init_bincl_list (20, objfile);
  back_to = make_cleanup_free_bincl_list (objfile);

  set_last_source_file (NULL);

  lowest_text_address = (CORE_ADDR) -1;

  symfile_bfd = objfile->obfd;	/* For next_text_symbol.  */
  abfd = objfile->obfd;
  symbuf_end = symbuf_idx = 0;
  next_symbol_text_func = dbx_next_symbol_text;
  textlow_not_set = 1;
  has_line_numbers = 0;

  /* FIXME: jimb/2003-09-12: We don't apply the right section's offset
     to global and static variables.  The stab for a global or static
     variable doesn't give us any indication of which section it's in,
     so we can't tell immediately which offset in
     objfile->section_offsets we should apply to the variable's
     address.

     We could certainly find out which section contains the variable
     by looking up the variable's unrelocated address with
     find_pc_section, but that would be expensive; this is the
     function that constructs the partial symbol tables by examining
     every symbol in the entire executable, and it's
     performance-critical.  So that expense would not be welcome.  I'm
     not sure what to do about this at the moment.

     What we have done for years is to simply assume that the .data
     section's offset is appropriate for all global and static
     variables.  Recently, this was expanded to fall back to the .bss
     section's offset if there is no .data section, and then to the
     .rodata section's offset.  */
  data_sect_index = objfile->sect_index_data;
  if (data_sect_index == -1)
    data_sect_index = SECT_OFF_BSS (objfile);
  if (data_sect_index == -1)
    data_sect_index = SECT_OFF_RODATA (objfile);

  /* If data_sect_index is still -1, that's okay.  It's perfectly fine
     for the file to have no .data, no .bss, and no .text at all, if
     it also has no global or static variables.  If it does, we will
     get an internal error from an ANOFFSET macro below when we try to
     use data_sect_index.  */

  for (symnum = 0; symnum < DBX_SYMCOUNT (objfile); symnum++)
    {
      /* Get the symbol for this run and pull out some info.  */
      QUIT;			/* Allow this to be interruptable.  */
      if (symbuf_idx == symbuf_end)
	fill_symbuf (abfd);
      bufp = &symbuf[symbuf_idx++];

      /*
       * Special case to speed up readin.
       */
      if (bfd_h_get_8 (abfd, bufp->e_type) == N_SLINE)
	{
	  has_line_numbers = 1;
	  continue;
	}

      INTERNALIZE_SYMBOL (nlist, bufp, abfd);
      OBJSTAT (objfile, n_stabs++);

      /* Ok.  There is a lot of code duplicated in the rest of this
         switch statement (for efficiency reasons).  Since I don't
         like duplicating code, I will do my penance here, and
         describe the code which is duplicated:

         *) The assignment to namestring.
         *) The call to strchr.
         *) The addition of a partial symbol the two partial
         symbol lists.  This last is a large section of code, so
         I've imbedded it in the following macro.  */

      switch (nlist.n_type)
	{
	  /*
	   * Standard, external, non-debugger, symbols
	   */

	case N_TEXT | N_EXT:
	case N_NBTEXT | N_EXT:
	  nlist.n_value += ANOFFSET (objfile->section_offsets,
				     SECT_OFF_TEXT (objfile));
	  goto record_it;

	case N_DATA | N_EXT:
	case N_NBDATA | N_EXT:
	  nlist.n_value += ANOFFSET (objfile->section_offsets,
				     SECT_OFF_DATA (objfile));
	  goto record_it;

	case N_BSS:
	case N_BSS | N_EXT:
	case N_NBBSS | N_EXT:
	case N_SETV | N_EXT:		/* FIXME, is this in BSS? */
	  nlist.n_value += ANOFFSET (objfile->section_offsets,
				     SECT_OFF_BSS (objfile));
	  goto record_it;

	case N_ABS | N_EXT:
	  record_it:
	  namestring = set_namestring (objfile, &nlist);

	  record_minimal_symbol (namestring, nlist.n_value,
				 nlist.n_type, objfile);	/* Always */
	  continue;

	  /* Standard, local, non-debugger, symbols.  */

	case N_NBTEXT:

	  /* We need to be able to deal with both N_FN or N_TEXT,
	     because we have no way of knowing whether the sys-supplied ld
	     or GNU ld was used to make the executable.  Sequents throw
	     in another wrinkle -- they renumbered N_FN.  */

	case N_FN:
	case N_FN_SEQ:
	case N_TEXT:
	  nlist.n_value += ANOFFSET (objfile->section_offsets,
				     SECT_OFF_TEXT (objfile));
	  namestring = set_namestring (objfile, &nlist);

	  if ((namestring[0] == '-' && namestring[1] == 'l')
	      || (namestring[(nsl = strlen (namestring)) - 1] == 'o'
		  && namestring[nsl - 2] == '.'))
	    {
	      if (past_first_source_file && pst
		  /* The gould NP1 uses low values for .o and -l symbols
		     which are not the address.  */
		  && nlist.n_value >= pst->textlow)
		{
		  end_psymtab (objfile, pst, psymtab_include_list,
			       includes_used, symnum * symbol_size,
			       nlist.n_value > pst->texthigh
			       ? nlist.n_value : pst->texthigh,
			       dependency_list, dependencies_used,
			       textlow_not_set);
		  pst = (struct partial_symtab *) 0;
		  includes_used = 0;
		  dependencies_used = 0;
		  has_line_numbers = 0;
		}
	      else
		past_first_source_file = 1;
	      last_o_file_start = nlist.n_value;
	    }
	  else
	    goto record_it;
	  continue;

	case N_DATA:
	  nlist.n_value += ANOFFSET (objfile->section_offsets,
				     SECT_OFF_DATA (objfile));
	  goto record_it;

	case N_UNDF | N_EXT:
	  /* The case (nlist.n_value != 0) is a "Fortran COMMON" symbol.
	     We used to rely on the target to tell us whether it knows
	     where the symbol has been relocated to, but none of the
	     target implementations actually provided that operation.
	     So we just ignore the symbol, the same way we would do if
	     we had a target-side symbol lookup which returned no match.

	     All other symbols (with nlist.n_value == 0), are really
	     undefined, and so we ignore them too.  */
	  continue;

	case N_UNDF:
	  if (processing_acc_compilation && nlist.n_strx == 1)
	    {
	      /* Deal with relative offsets in the string table
		 used in ELF+STAB under Solaris.  If we want to use the
		 n_strx field, which contains the name of the file,
		 we must adjust file_string_table_offset *before* calling
		 set_namestring().  */
	      past_first_source_file = 1;
	      file_string_table_offset = next_file_string_table_offset;
	      next_file_string_table_offset =
		file_string_table_offset + nlist.n_value;
	      if (next_file_string_table_offset < file_string_table_offset)
		error (_("string table offset backs up at %d"), symnum);
	      /* FIXME -- replace error() with complaint.  */
	      continue;
	    }
	  continue;

	  /* Lots of symbol types we can just ignore.  */

	case N_ABS:
	case N_NBDATA:
	case N_NBBSS:
	  continue;

	  /* Keep going . . .  */

	  /*
	   * Special symbol types for GNU
	   */
	case N_INDR:
	case N_INDR | N_EXT:
	case N_SETA:
	case N_SETA | N_EXT:
	case N_SETT:
	case N_SETT | N_EXT:
	case N_SETD:
	case N_SETD | N_EXT:
	case N_SETB:
	case N_SETB | N_EXT:
	case N_SETV:
	  continue;

	  /*
	   * Debugger symbols
	   */

	case N_SO:
	  {
	    CORE_ADDR valu;
	    static int prev_so_symnum = -10;
	    static int first_so_symnum;
	    const char *p;
	    static char *dirname_nso;
	    int prev_textlow_not_set;

	    valu = nlist.n_value + ANOFFSET (objfile->section_offsets,
					     SECT_OFF_TEXT (objfile));

	    prev_textlow_not_set = textlow_not_set;

	    /* A zero value is probably an indication for the SunPRO 3.0
	       compiler.  end_psymtab explicitly tests for zero, so
	       don't relocate it.  */

	    if (nlist.n_value == 0
		&& gdbarch_sofun_address_maybe_missing (gdbarch))
	      {
		textlow_not_set = 1;
		valu = 0;
	      }
	    else
	      textlow_not_set = 0;

	    past_first_source_file = 1;

	    if (prev_so_symnum != symnum - 1)
	      {			/* Here if prev stab wasn't N_SO.  */
		first_so_symnum = symnum;

		if (pst)
		  {
		    end_psymtab (objfile, pst, psymtab_include_list,
				 includes_used, symnum * symbol_size,
				 valu > pst->texthigh ? valu : pst->texthigh,
				 dependency_list, dependencies_used,
				 prev_textlow_not_set);
		    pst = (struct partial_symtab *) 0;
		    includes_used = 0;
		    dependencies_used = 0;
		    has_line_numbers = 0;
		  }
	      }

	    prev_so_symnum = symnum;

	    /* End the current partial symtab and start a new one.  */

	    namestring = set_namestring (objfile, &nlist);

	    /* Null name means end of .o file.  Don't start a new one.  */
	    if (*namestring == '\000')
	      continue;

	    /* Some compilers (including gcc) emit a pair of initial N_SOs.
	       The first one is a directory name; the second the file name.
	       If pst exists, is empty, and has a filename ending in '/',
	       we assume the previous N_SO was a directory name.  */

	    p = lbasename (namestring);
	    if (p != namestring && *p == '\000')
	      {
		/* Save the directory name SOs locally, then save it into
		   the psymtab when it's created below.  */
	        dirname_nso = namestring;
	        continue;		
	      }

	    /* Some other compilers (C++ ones in particular) emit useless
	       SOs for non-existant .c files.  We ignore all subsequent SOs
	       that immediately follow the first.  */

	    if (!pst)
	      {
		pst = start_psymtab (objfile,
				     namestring, valu,
				     first_so_symnum * symbol_size,
				     objfile->global_psymbols.next,
				     objfile->static_psymbols.next);
		pst->dirname = dirname_nso;
		dirname_nso = NULL;
	      }
	    continue;
	  }

	case N_BINCL:
	  {
	    enum language tmp_language;

	    /* Add this bincl to the bincl_list for future EXCLs.  No
	       need to save the string; it'll be around until
	       read_dbx_symtab function returns.  */

	    namestring = set_namestring (objfile, &nlist);
	    tmp_language = deduce_language_from_filename (namestring);

	    /* Only change the psymtab's language if we've learned
	       something useful (eg. tmp_language is not language_unknown).
	       In addition, to match what start_subfile does, never change
	       from C++ to C.  */
	    if (tmp_language != language_unknown
		&& (tmp_language != language_c
		    || psymtab_language != language_cplus))
	      psymtab_language = tmp_language;

	    if (pst == NULL)
	      {
		/* FIXME: we should not get here without a PST to work on.
		   Attempt to recover.  */
		complaint (&symfile_complaints,
			   _("N_BINCL %s not in entries for "
			     "any file, at symtab pos %d"),
			   namestring, symnum);
		continue;
	      }
	    add_bincl_to_list (pst, namestring, nlist.n_value);

	    /* Mark down an include file in the current psymtab.  */

	    goto record_include_file;
	  }

	case N_SOL:
	  {
	    enum language tmp_language;

	    /* Mark down an include file in the current psymtab.  */
	    namestring = set_namestring (objfile, &nlist);
	    tmp_language = deduce_language_from_filename (namestring);

	    /* Only change the psymtab's language if we've learned
	       something useful (eg. tmp_language is not language_unknown).
	       In addition, to match what start_subfile does, never change
	       from C++ to C.  */
	    if (tmp_language != language_unknown
		&& (tmp_language != language_c
		    || psymtab_language != language_cplus))
	      psymtab_language = tmp_language;

	    /* In C++, one may expect the same filename to come round many
	       times, when code is coming alternately from the main file
	       and from inline functions in other files.  So I check to see
	       if this is a file we've seen before -- either the main
	       source file, or a previously included file.

	       This seems to be a lot of time to be spending on N_SOL, but
	       things like "break c-exp.y:435" need to work (I
	       suppose the psymtab_include_list could be hashed or put
	       in a binary tree, if profiling shows this is a major hog).  */
	    if (pst && filename_cmp (namestring, pst->filename) == 0)
	      continue;
	    {
	      int i;

	      for (i = 0; i < includes_used; i++)
		if (filename_cmp (namestring, psymtab_include_list[i]) == 0)
		  {
		    i = -1;
		    break;
		  }
	      if (i == -1)
		continue;
	    }

	  record_include_file:

	    psymtab_include_list[includes_used++] = namestring;
	    if (includes_used >= includes_allocated)
	      {
		const char **orig = psymtab_include_list;

		psymtab_include_list = (const char **)
		  alloca ((includes_allocated *= 2) * sizeof (const char *));
		memcpy (psymtab_include_list, orig,
			includes_used * sizeof (const char *));
	      }
	    continue;
	  }
	case N_LSYM:		/* Typedef or automatic variable.  */
	case N_STSYM:		/* Data seg var -- static.  */
	case N_LCSYM:		/* BSS      "  */
	case N_ROSYM:		/* Read-only data seg var -- static.  */
	case N_NBSTS:		/* Gould nobase.  */
	case N_NBLCS:		/* symbols.  */
	case N_FUN:
	case N_GSYM:		/* Global (extern) variable; can be
				   data or bss (sigh FIXME).  */

	  /* Following may probably be ignored; I'll leave them here
	     for now (until I do Pascal and Modula 2 extensions).  */

	case N_PC:		/* I may or may not need this; I
				   suspect not.  */
	case N_M2C:		/* I suspect that I can ignore this here.  */
	case N_SCOPE:		/* Same.   */
	{
	  char *p;

	  namestring = set_namestring (objfile, &nlist);

	  /* See if this is an end of function stab.  */
	  if (pst && nlist.n_type == N_FUN && *namestring == '\000')
	    {
	      CORE_ADDR valu;

	      /* It's value is the size (in bytes) of the function for
		 function relative stabs, or the address of the function's
		 end for old style stabs.  */
	      valu = nlist.n_value + last_function_start;
	      if (pst->texthigh == 0 || valu > pst->texthigh)
		pst->texthigh = valu;
	      break;
	    }

	  p = (char *) strchr (namestring, ':');
	  if (!p)
	    continue;		/* Not a debugging symbol.   */

 	  sym_len = 0;
	  sym_name = NULL;	/* pacify "gcc -Werror" */
 	  if (psymtab_language == language_cplus)
 	    {
 	      char *new_name, *name = xmalloc (p - namestring + 1);
 	      memcpy (name, namestring, p - namestring);

 	      name[p - namestring] = '\0';
 	      new_name = cp_canonicalize_string (name);
 	      if (new_name != NULL)
 		{
 		  sym_len = strlen (new_name);
 		  sym_name = obstack_copy0 (&objfile->objfile_obstack,
					    new_name, sym_len);
 		  xfree (new_name);
 		}
              xfree (name);
 	    }

 	  if (sym_len == 0)
 	    {
 	      sym_name = namestring;
 	      sym_len = p - namestring;
 	    }

	  /* Main processing section for debugging symbols which
	     the initial read through the symbol tables needs to worry
	     about.  If we reach this point, the symbol which we are
	     considering is definitely one we are interested in.
	     p must also contain the (valid) index into the namestring
	     which indicates the debugging type symbol.  */

	  switch (p[1])
	    {
	    case 'S':
	      nlist.n_value += ANOFFSET (objfile->section_offsets,
					 data_sect_index);

	      if (gdbarch_static_transform_name_p (gdbarch))
		gdbarch_static_transform_name (gdbarch, namestring);

	      add_psymbol_to_list (sym_name, sym_len, 1,
				   VAR_DOMAIN, LOC_STATIC,
				   &objfile->static_psymbols,
				   0, nlist.n_value,
				   psymtab_language, objfile);
	      continue;

	    case 'G':
	      nlist.n_value += ANOFFSET (objfile->section_offsets,
					 data_sect_index);
	      /* The addresses in these entries are reported to be
		 wrong.  See the code that reads 'G's for symtabs.  */
	      add_psymbol_to_list (sym_name, sym_len, 1,
				   VAR_DOMAIN, LOC_STATIC,
				   &objfile->global_psymbols,
				   0, nlist.n_value,
				   psymtab_language, objfile);
	      continue;

	    case 'T':
	      /* When a 'T' entry is defining an anonymous enum, it
		 may have a name which is the empty string, or a
		 single space.  Since they're not really defining a
		 symbol, those shouldn't go in the partial symbol
		 table.  We do pick up the elements of such enums at
		 'check_enum:', below.  */
	      if (p >= namestring + 2
		  || (p == namestring + 1
		      && namestring[0] != ' '))
		{
		  add_psymbol_to_list (sym_name, sym_len, 1,
				       STRUCT_DOMAIN, LOC_TYPEDEF,
				       &objfile->static_psymbols,
				       nlist.n_value, 0,
				       psymtab_language, objfile);
		  if (p[2] == 't')
		    {
		      /* Also a typedef with the same name.  */
		      add_psymbol_to_list (sym_name, sym_len, 1,
					   VAR_DOMAIN, LOC_TYPEDEF,
					   &objfile->static_psymbols,
					   nlist.n_value, 0,
					   psymtab_language, objfile);
		      p += 1;
		    }
		}
	      goto check_enum;

	    case 't':
	      if (p != namestring)	/* a name is there, not just :T...  */
		{
		  add_psymbol_to_list (sym_name, sym_len, 1,
				       VAR_DOMAIN, LOC_TYPEDEF,
				       &objfile->static_psymbols,
				       nlist.n_value, 0,
				       psymtab_language, objfile);
		}
	    check_enum:
	      /* If this is an enumerated type, we need to
		 add all the enum constants to the partial symbol
		 table.  This does not cover enums without names, e.g.
		 "enum {a, b} c;" in C, but fortunately those are
		 rare.  There is no way for GDB to find those from the
		 enum type without spending too much time on it.  Thus
		 to solve this problem, the compiler needs to put out the
		 enum in a nameless type.  GCC2 does this.  */

	      /* We are looking for something of the form
		 <name> ":" ("t" | "T") [<number> "="] "e"
		 {<constant> ":" <value> ","} ";".  */

	      /* Skip over the colon and the 't' or 'T'.  */
	      p += 2;
	      /* This type may be given a number.  Also, numbers can come
		 in pairs like (0,26).  Skip over it.  */
	      while ((*p >= '0' && *p <= '9')
		     || *p == '(' || *p == ',' || *p == ')'
		     || *p == '=')
		p++;

	      if (*p++ == 'e')
		{
		  /* The aix4 compiler emits extra crud before the members.  */
		  if (*p == '-')
		    {
		      /* Skip over the type (?).  */
		      while (*p != ':')
			p++;

		      /* Skip over the colon.  */
		      p++;
		    }

		  /* We have found an enumerated type.  */
		  /* According to comments in read_enum_type
		     a comma could end it instead of a semicolon.
		     I don't know where that happens.
		     Accept either.  */
		  while (*p && *p != ';' && *p != ',')
		    {
		      char *q;

		      /* Check for and handle cretinous dbx symbol name
			 continuation!  */
		      if (*p == '\\' || (*p == '?' && p[1] == '\0'))
			p = next_symbol_text (objfile);

		      /* Point to the character after the name
			 of the enum constant.  */
		      for (q = p; *q && *q != ':'; q++)
			;
		      /* Note that the value doesn't matter for
			 enum constants in psymtabs, just in symtabs.  */
		      add_psymbol_to_list (p, q - p, 1,
					   VAR_DOMAIN, LOC_CONST,
					   &objfile->static_psymbols, 0,
					   0, psymtab_language, objfile);
		      /* Point past the name.  */
		      p = q;
		      /* Skip over the value.  */
		      while (*p && *p != ',')
			p++;
		      /* Advance past the comma.  */
		      if (*p)
			p++;
		    }
		}
	      continue;

	    case 'c':
	      /* Constant, e.g. from "const" in Pascal.  */
	      add_psymbol_to_list (sym_name, sym_len, 1,
				   VAR_DOMAIN, LOC_CONST,
				   &objfile->static_psymbols, nlist.n_value,
				   0, psymtab_language, objfile);
	      continue;

	    case 'f':
	      if (! pst)
		{
		  int name_len = p - namestring;
		  char *name = xmalloc (name_len + 1);

		  memcpy (name, namestring, name_len);
		  name[name_len] = '\0';
		  function_outside_compilation_unit_complaint (name);
		  xfree (name);
		}
	      nlist.n_value += ANOFFSET (objfile->section_offsets, 
					 SECT_OFF_TEXT (objfile));
	      /* Kludges for ELF/STABS with Sun ACC.  */
	      last_function_name = namestring;
	      /* Do not fix textlow==0 for .o or NLM files, as 0 is a legit
		 value for the bottom of the text seg in those cases.  */
	      if (nlist.n_value == ANOFFSET (objfile->section_offsets, 
					     SECT_OFF_TEXT (objfile))
		  && gdbarch_sofun_address_maybe_missing (gdbarch))
		{
		  CORE_ADDR minsym_valu = 
		    find_stab_function_addr (namestring, 
					     pst ? pst->filename : NULL, 
					     objfile);

		  /* find_stab_function_addr will return 0 if the minimal
		     symbol wasn't found.  (Unfortunately, this might also
		     be a valid address.)  Anyway, if it *does* return 0,
		     it is likely that the value was set correctly to begin
		     with...  */
		  if (minsym_valu != 0)
		    nlist.n_value = minsym_valu;
		}
	      if (pst && textlow_not_set
		  && gdbarch_sofun_address_maybe_missing (gdbarch))
		{
		  pst->textlow = nlist.n_value;
		  textlow_not_set = 0;
		}
	      /* End kludge.  */

	      /* Keep track of the start of the last function so we
		 can handle end of function symbols.  */
	      last_function_start = nlist.n_value;

	      /* In reordered executables this function may lie outside
		 the bounds created by N_SO symbols.  If that's the case
		 use the address of this function as the low bound for
		 the partial symbol table.  */
	      if (pst
		  && (textlow_not_set
		      || (nlist.n_value < pst->textlow
			  && (nlist.n_value
			      != ANOFFSET (objfile->section_offsets,
					   SECT_OFF_TEXT (objfile))))))
		{
		  pst->textlow = nlist.n_value;
		  textlow_not_set = 0;
		}
	      add_psymbol_to_list (sym_name, sym_len, 1,
				   VAR_DOMAIN, LOC_BLOCK,
				   &objfile->static_psymbols,
				   0, nlist.n_value,
				   psymtab_language, objfile);
	      continue;

	      /* Global functions were ignored here, but now they
		 are put into the global psymtab like one would expect.
		 They're also in the minimal symbol table.  */
	    case 'F':
	      if (! pst)
		{
		  int name_len = p - namestring;
		  char *name = xmalloc (name_len + 1);

		  memcpy (name, namestring, name_len);
		  name[name_len] = '\0';
		  function_outside_compilation_unit_complaint (name);
		  xfree (name);
		}
	      nlist.n_value += ANOFFSET (objfile->section_offsets, 
					 SECT_OFF_TEXT (objfile));
	      /* Kludges for ELF/STABS with Sun ACC.  */
	      last_function_name = namestring;
	      /* Do not fix textlow==0 for .o or NLM files, as 0 is a legit
		 value for the bottom of the text seg in those cases.  */
	      if (nlist.n_value == ANOFFSET (objfile->section_offsets, 
					     SECT_OFF_TEXT (objfile))
		  && gdbarch_sofun_address_maybe_missing (gdbarch))
		{
		  CORE_ADDR minsym_valu = 
		    find_stab_function_addr (namestring, 
					     pst ? pst->filename : NULL, 
					     objfile);

		  /* find_stab_function_addr will return 0 if the minimal
		     symbol wasn't found.  (Unfortunately, this might also
		     be a valid address.)  Anyway, if it *does* return 0,
		     it is likely that the value was set correctly to begin
		     with...  */
		  if (minsym_valu != 0)
		    nlist.n_value = minsym_valu;
		}
	      if (pst && textlow_not_set
		  && gdbarch_sofun_address_maybe_missing (gdbarch))
		{
		  pst->textlow = nlist.n_value;
		  textlow_not_set = 0;
		}
	      /* End kludge.  */

	      /* Keep track of the start of the last function so we
		 can handle end of function symbols.  */
	      last_function_start = nlist.n_value;

	      /* In reordered executables this function may lie outside
		 the bounds created by N_SO symbols.  If that's the case
		 use the address of this function as the low bound for
		 the partial symbol table.  */
	      if (pst
		  && (textlow_not_set
		      || (nlist.n_value < pst->textlow
			  && (nlist.n_value
			      != ANOFFSET (objfile->section_offsets,
					   SECT_OFF_TEXT (objfile))))))
		{
		  pst->textlow = nlist.n_value;
		  textlow_not_set = 0;
		}
	      add_psymbol_to_list (sym_name, sym_len, 1,
				   VAR_DOMAIN, LOC_BLOCK,
				   &objfile->global_psymbols,
				   0, nlist.n_value,
				   psymtab_language, objfile);
	      continue;

	      /* Two things show up here (hopefully); static symbols of
		 local scope (static used inside braces) or extensions
		 of structure symbols.  We can ignore both.  */
	    case 'V':
	    case '(':
	    case '0':
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
	    case '9':
	    case '-':
	    case '#':	/* For symbol identification (used in live ranges).  */
	      continue;

	    case ':':
	      /* It is a C++ nested symbol.  We don't need to record it
		 (I don't think); if we try to look up foo::bar::baz,
		 then symbols for the symtab containing foo should get
		 read in, I think.  */
	      /* Someone says sun cc puts out symbols like
		 /foo/baz/maclib::/usr/local/bin/maclib,
		 which would get here with a symbol type of ':'.  */
	      continue;

	    default:
	      /* Unexpected symbol descriptor.  The second and subsequent stabs
		 of a continued stab can show up here.  The question is
		 whether they ever can mimic a normal stab--it would be
		 nice if not, since we certainly don't want to spend the
		 time searching to the end of every string looking for
		 a backslash.  */

	      complaint (&symfile_complaints,
			 _("unknown symbol descriptor `%c'"),
			 p[1]);

	      /* Ignore it; perhaps it is an extension that we don't
		 know about.  */
	      continue;
	    }
	}

	case N_EXCL:

	  namestring = set_namestring (objfile, &nlist);

	  /* Find the corresponding bincl and mark that psymtab on the
	     psymtab dependency list.  */
	  {
	    struct partial_symtab *needed_pst =
	      find_corresponding_bincl_psymtab (namestring, nlist.n_value);

	    /* If this include file was defined earlier in this file,
	       leave it alone.  */
	    if (needed_pst == pst)
	      continue;

	    if (needed_pst)
	      {
		int i;
		int found = 0;

		for (i = 0; i < dependencies_used; i++)
		  if (dependency_list[i] == needed_pst)
		    {
		      found = 1;
		      break;
		    }

		/* If it's already in the list, skip the rest.  */
		if (found)
		  continue;

		dependency_list[dependencies_used++] = needed_pst;
		if (dependencies_used >= dependencies_allocated)
		  {
		    struct partial_symtab **orig = dependency_list;

		    dependency_list =
		      (struct partial_symtab **)
		      alloca ((dependencies_allocated *= 2)
			      * sizeof (struct partial_symtab *));
		    memcpy (dependency_list, orig,
			    (dependencies_used
			     * sizeof (struct partial_symtab *)));
#ifdef DEBUG_INFO
		    fprintf_unfiltered (gdb_stderr,
					"Had to reallocate "
					"dependency list.\n");
		    fprintf_unfiltered (gdb_stderr,
					"New dependencies allocated: %d\n",
					dependencies_allocated);
#endif
		  }
	      }
	  }
	  continue;

	case N_ENDM:
	  /* Solaris 2 end of module, finish current partial symbol table.
	     end_psymtab will set pst->texthigh to the proper value, which
	     is necessary if a module compiled without debugging info
	     follows this module.  */
	  if (pst && gdbarch_sofun_address_maybe_missing (gdbarch))
	    {
	      end_psymtab (objfile, pst, psymtab_include_list, includes_used,
			   symnum * symbol_size,
			   (CORE_ADDR) 0, dependency_list,
			   dependencies_used, textlow_not_set);
	      pst = (struct partial_symtab *) 0;
	      includes_used = 0;
	      dependencies_used = 0;
	      has_line_numbers = 0;
	    }
	  continue;

	case N_RBRAC:
#ifdef HANDLE_RBRAC
	  HANDLE_RBRAC (nlist.n_value);
	  continue;
#endif
	case N_EINCL:
	case N_DSLINE:
	case N_BSLINE:
	case N_SSYM:		/* Claim: Structure or union element.
				   Hopefully, I can ignore this.  */
	case N_ENTRY:		/* Alternate entry point; can ignore.  */
	case N_MAIN:		/* Can definitely ignore this.   */
	case N_CATCH:		/* These are GNU C++ extensions */
	case N_EHDECL:		/* that can safely be ignored here.  */
	case N_LENG:
	case N_BCOMM:
	case N_ECOMM:
	case N_ECOML:
	case N_FNAME:
	case N_SLINE:
	case N_RSYM:
	case N_PSYM:
	case N_LBRAC:
	case N_NSYMS:		/* Ultrix 4.0: symbol count */
	case N_DEFD:		/* GNU Modula-2 */
	case N_ALIAS:		/* SunPro F77: alias name, ignore for now.  */

	case N_OBJ:		/* Useless types from Solaris.  */
	case N_OPT:
	case N_PATCH:
	  /* These symbols aren't interesting; don't worry about them.  */
	  continue;

	default:
	  /* If we haven't found it yet, ignore it.  It's probably some
	     new type we don't know about yet.  */
	  unknown_symtype_complaint (hex_string (nlist.n_type));
	  continue;
	}
    }

  /* If there's stuff to be cleaned up, clean it up.  */
  if (pst)
    {
      /* Don't set pst->texthigh lower than it already is.  */
      CORE_ADDR text_end =
	(lowest_text_address == (CORE_ADDR) -1
	 ? (text_addr + ANOFFSET (objfile->section_offsets,
				  SECT_OFF_TEXT (objfile)))
	 : lowest_text_address)
	+ text_size;

      end_psymtab (objfile, pst, psymtab_include_list, includes_used,
		   symnum * symbol_size,
		   text_end > pst->texthigh ? text_end : pst->texthigh,
		   dependency_list, dependencies_used, textlow_not_set);
    }

  do_cleanups (back_to);
}

/* Allocate and partially fill a partial symtab.  It will be
   completely filled at the end of the symbol list.

   SYMFILE_NAME is the name of the symbol-file we are reading from, and ADDR
   is the address relative to which its symbols are (incremental) or 0
   (normal).  */

static struct partial_symtab *
start_psymtab (struct objfile *objfile, char *filename, CORE_ADDR textlow,
	       int ldsymoff, struct partial_symbol **global_syms,
	       struct partial_symbol **static_syms)
{
  struct partial_symtab *result =
    start_psymtab_common (objfile, objfile->section_offsets,
			  filename, textlow, global_syms, static_syms);

  result->read_symtab_private = obstack_alloc (&objfile->objfile_obstack,
					       sizeof (struct symloc));
  LDSYMOFF (result) = ldsymoff;
  result->read_symtab = dbx_read_symtab;
  SYMBOL_SIZE (result) = symbol_size;
  SYMBOL_OFFSET (result) = symbol_table_offset;
  STRING_OFFSET (result) = string_table_offset;
  FILE_STRING_OFFSET (result) = file_string_table_offset;

#ifdef HAVE_ELF
  /* If we're handling an ELF file, drag some section-relocation info
     for this source file out of the ELF symbol table, to compensate for
     Sun brain death.  This replaces the section_offsets in this psymtab,
     if successful.  */
  elfstab_offset_sections (objfile, result);
#endif

  /* Deduce the source language from the filename for this psymtab.  */
  psymtab_language = deduce_language_from_filename (filename);

  return result;
}

/* Close off the current usage of PST.
   Returns PST or NULL if the partial symtab was empty and thrown away.

   FIXME:  List variables and peculiarities of same.  */

struct partial_symtab *
end_psymtab (struct objfile *objfile, struct partial_symtab *pst,
	     const char **include_list, int num_includes,
	     int capping_symbol_offset, CORE_ADDR capping_text,
	     struct partial_symtab **dependency_list, int number_dependencies,
	     int textlow_not_set)
{
  int i;
  struct gdbarch *gdbarch = get_objfile_arch (objfile);

  if (capping_symbol_offset != -1)
    LDSYMLEN (pst) = capping_symbol_offset - LDSYMOFF (pst);
  pst->texthigh = capping_text;

  /* Under Solaris, the N_SO symbols always have a value of 0,
     instead of the usual address of the .o file.  Therefore,
     we have to do some tricks to fill in texthigh and textlow.
     The first trick is: if we see a static
     or global function, and the textlow for the current pst
     is not set (ie: textlow_not_set), then we use that function's
     address for the textlow of the pst.  */

  /* Now, to fill in texthigh, we remember the last function seen
     in the .o file.  Also, there's a hack in
     bfd/elf.c and gdb/elfread.c to pass the ELF st_size field
     to here via the misc_info field.  Therefore, we can fill in
     a reliable texthigh by taking the address plus size of the
     last function in the file.  */

  if (pst->texthigh == 0 && last_function_name
      && gdbarch_sofun_address_maybe_missing (gdbarch))
    {
      char *p;
      int n;
      struct minimal_symbol *minsym;

      p = strchr (last_function_name, ':');
      if (p == NULL)
	p = last_function_name;
      n = p - last_function_name;
      p = alloca (n + 2);
      strncpy (p, last_function_name, n);
      p[n] = 0;

      minsym = lookup_minimal_symbol (p, pst->filename, objfile);
      if (minsym == NULL)
	{
	  /* Sun Fortran appends an underscore to the minimal symbol name,
	     try again with an appended underscore if the minimal symbol
	     was not found.  */
	  p[n] = '_';
	  p[n + 1] = 0;
	  minsym = lookup_minimal_symbol (p, pst->filename, objfile);
	}

      if (minsym)
	pst->texthigh = SYMBOL_VALUE_ADDRESS (minsym) + MSYMBOL_SIZE (minsym);

      last_function_name = NULL;
    }

  if (!gdbarch_sofun_address_maybe_missing (gdbarch))
    ;
  /* This test will be true if the last .o file is only data.  */
  else if (textlow_not_set)
    pst->textlow = pst->texthigh;
  else
    {
      struct partial_symtab *p1;

      /* If we know our own starting text address, then walk through all other
         psymtabs for this objfile, and if any didn't know their ending text
         address, set it to our starting address.  Take care to not set our
         own ending address to our starting address, nor to set addresses on
         `dependency' files that have both textlow and texthigh zero.  */

      ALL_OBJFILE_PSYMTABS (objfile, p1)
      {
	if (p1->texthigh == 0 && p1->textlow != 0 && p1 != pst)
	  {
	    p1->texthigh = pst->textlow;
	    /* If this file has only data, then make textlow match
	       texthigh.  */
	    if (p1->textlow == 0)
	      p1->textlow = p1->texthigh;
	  }
      }
    }

  /* End of kludge for patching Solaris textlow and texthigh.  */

  pst->n_global_syms =
    objfile->global_psymbols.next - (objfile->global_psymbols.list
				     + pst->globals_offset);
  pst->n_static_syms =
    objfile->static_psymbols.next - (objfile->static_psymbols.list
				     + pst->statics_offset);

  pst->number_of_dependencies = number_dependencies;
  if (number_dependencies)
    {
      pst->dependencies = (struct partial_symtab **)
	obstack_alloc (&objfile->objfile_obstack,
		       number_dependencies * sizeof (struct partial_symtab *));
      memcpy (pst->dependencies, dependency_list,
	      number_dependencies * sizeof (struct partial_symtab *));
    }
  else
    pst->dependencies = 0;

  for (i = 0; i < num_includes; i++)
    {
      struct partial_symtab *subpst =
	allocate_psymtab (include_list[i], objfile);

      /* Copy the sesction_offsets array from the main psymtab.  */
      subpst->section_offsets = pst->section_offsets;
      subpst->read_symtab_private =
	obstack_alloc (&objfile->objfile_obstack, sizeof (struct symloc));
      LDSYMOFF (subpst) =
	LDSYMLEN (subpst) =
	subpst->textlow =
	subpst->texthigh = 0;

      /* We could save slight bits of space by only making one of these,
         shared by the entire set of include files.  FIXME-someday.  */
      subpst->dependencies = (struct partial_symtab **)
	obstack_alloc (&objfile->objfile_obstack,
		       sizeof (struct partial_symtab *));
      subpst->dependencies[0] = pst;
      subpst->number_of_dependencies = 1;

      subpst->globals_offset =
	subpst->n_global_syms =
	subpst->statics_offset =
	subpst->n_static_syms = 0;

      subpst->readin = 0;
      subpst->symtab = 0;
      subpst->read_symtab = pst->read_symtab;
    }

  sort_pst_symbols (objfile, pst);

  if (num_includes == 0
      && number_dependencies == 0
      && pst->n_global_syms == 0
      && pst->n_static_syms == 0
      && has_line_numbers == 0)
    {
      /* Throw away this psymtab, it's empty.  We can't deallocate it, since
         it is on the obstack, but we can forget to chain it on the list.  */
      /* Empty psymtabs happen as a result of header files which don't have
         any symbols in them.  There can be a lot of them.  But this check
         is wrong, in that a psymtab with N_SLINE entries but nothing else
         is not empty, but we don't realize that.  Fixing that without slowing
         things down might be tricky.  */

      discard_psymtab (objfile, pst);

      /* Indicate that psymtab was thrown away.  */
      pst = (struct partial_symtab *) NULL;
    }
  return pst;
}

static void
dbx_psymtab_to_symtab_1 (struct objfile *objfile, struct partial_symtab *pst)
{
  struct cleanup *old_chain;
  int i;

  if (pst->readin)
    {
      fprintf_unfiltered (gdb_stderr, "Psymtab for %s already read in.  "
			  "Shouldn't happen.\n",
			  pst->filename);
      return;
    }

  /* Read in all partial symtabs on which this one is dependent.  */
  for (i = 0; i < pst->number_of_dependencies; i++)
    if (!pst->dependencies[i]->readin)
      {
	/* Inform about additional files that need to be read in.  */
	if (info_verbose)
	  {
	    fputs_filtered (" ", gdb_stdout);
	    wrap_here ("");
	    fputs_filtered ("and ", gdb_stdout);
	    wrap_here ("");
	    printf_filtered ("%s...", pst->dependencies[i]->filename);
	    wrap_here ("");	/* Flush output.  */
	    gdb_flush (gdb_stdout);
	  }
	dbx_psymtab_to_symtab_1 (objfile, pst->dependencies[i]);
      }

  if (LDSYMLEN (pst))		/* Otherwise it's a dummy.  */
    {
      /* Init stuff necessary for reading in symbols */
      stabsread_init ();
      buildsym_init ();
      old_chain = make_cleanup (really_free_pendings, 0);
      file_string_table_offset = FILE_STRING_OFFSET (pst);
      symbol_size = SYMBOL_SIZE (pst);

      /* Read in this file's symbols.  */
      bfd_seek (objfile->obfd, SYMBOL_OFFSET (pst), SEEK_SET);
      read_ofile_symtab (objfile, pst);

      do_cleanups (old_chain);
    }

  pst->readin = 1;
}

/* Read in all of the symbols for a given psymtab for real.
   Be verbose about it if the user wants that.  SELF is not NULL.  */

static void
dbx_read_symtab (struct partial_symtab *self, struct objfile *objfile)
{
  bfd *sym_bfd;

  if (self->readin)
    {
      fprintf_unfiltered (gdb_stderr, "Psymtab for %s already read in.  "
			  "Shouldn't happen.\n",
			  self->filename);
      return;
    }

  if (LDSYMLEN (self) || self->number_of_dependencies)
    {
      struct cleanup *back_to;

      /* Print the message now, before reading the string table,
         to avoid disconcerting pauses.  */
      if (info_verbose)
	{
	  printf_filtered ("Reading in symbols for %s...", self->filename);
	  gdb_flush (gdb_stdout);
	}

      sym_bfd = objfile->obfd;

      next_symbol_text_func = dbx_next_symbol_text;

      back_to = make_cleanup (null_cleanup, NULL);

      if (DBX_STAB_SECTION (objfile))
	{
	  stabs_data
	    = symfile_relocate_debug_section (objfile,
					      DBX_STAB_SECTION (objfile),
					      NULL);

	  if (stabs_data)
	    make_cleanup (free_current_contents, (void *) &stabs_data);
	}

      dbx_psymtab_to_symtab_1 (objfile, self);

      do_cleanups (back_to);

      /* Match with global symbols.  This only needs to be done once,
         after all of the symtabs and dependencies have been read in.   */
      scan_file_globals (objfile);

      /* Finish up the debug error message.  */
      if (info_verbose)
	printf_filtered ("done.\n");
    }
}

/* Read in a defined section of a specific object file's symbols.  */

static void
read_ofile_symtab (struct objfile *objfile, struct partial_symtab *pst)
{
  char *namestring;
  struct external_nlist *bufp;
  struct internal_nlist nlist;
  unsigned char type;
  unsigned max_symnum;
  bfd *abfd;
  int sym_offset;		/* Offset to start of symbols to read */
  int sym_size;			/* Size of symbols to read */
  CORE_ADDR text_offset;	/* Start of text segment for symbols */
  int text_size;		/* Size of text segment for symbols */
  struct section_offsets *section_offsets;

  sym_offset = LDSYMOFF (pst);
  sym_size = LDSYMLEN (pst);
  text_offset = pst->textlow;
  text_size = pst->texthigh - pst->textlow;
  /* This cannot be simply objfile->section_offsets because of
     elfstab_offset_sections() which initializes the psymtab section
     offsets information in a special way, and that is different from
     objfile->section_offsets.  */ 
  section_offsets = pst->section_offsets;

  dbxread_objfile = objfile;

  stringtab_global = DBX_STRINGTAB (objfile);
  set_last_source_file (NULL);

  abfd = objfile->obfd;
  symfile_bfd = objfile->obfd;	/* Implicit param to next_text_symbol.  */
  symbuf_end = symbuf_idx = 0;
  symbuf_read = 0;
  symbuf_left = sym_offset + sym_size;

  /* It is necessary to actually read one symbol *before* the start
     of this symtab's symbols, because the GCC_COMPILED_FLAG_SYMBOL
     occurs before the N_SO symbol.

     Detecting this in read_dbx_symtab
     would slow down initial readin, so we look for it here instead.  */
  if (!processing_acc_compilation && sym_offset >= (int) symbol_size)
    {
      stabs_seek (sym_offset - symbol_size);
      fill_symbuf (abfd);
      bufp = &symbuf[symbuf_idx++];
      INTERNALIZE_SYMBOL (nlist, bufp, abfd);
      OBJSTAT (objfile, n_stabs++);

      namestring = set_namestring (objfile, &nlist);

      processing_gcc_compilation = 0;
      if (nlist.n_type == N_TEXT)
	{
	  const char *tempstring = namestring;

	  if (strcmp (namestring, GCC_COMPILED_FLAG_SYMBOL) == 0)
	    processing_gcc_compilation = 1;
	  else if (strcmp (namestring, GCC2_COMPILED_FLAG_SYMBOL) == 0)
	    processing_gcc_compilation = 2;
	  if (tempstring[0] == bfd_get_symbol_leading_char (symfile_bfd))
	    ++tempstring;
	  if (strncmp (tempstring, "__gnu_compiled", 14) == 0)
	    processing_gcc_compilation = 2;
	}
    }
  else
    {
      /* The N_SO starting this symtab is the first symbol, so we
         better not check the symbol before it.  I'm not this can
         happen, but it doesn't hurt to check for it.  */
      stabs_seek (sym_offset);
      processing_gcc_compilation = 0;
    }

  if (symbuf_idx == symbuf_end)
    fill_symbuf (abfd);
  bufp = &symbuf[symbuf_idx];
  if (bfd_h_get_8 (abfd, bufp->e_type) != N_SO)
    error (_("First symbol in segment of executable not a source symbol"));

  max_symnum = sym_size / symbol_size;

  for (symnum = 0;
       symnum < max_symnum;
       symnum++)
    {
      QUIT;			/* Allow this to be interruptable.  */
      if (symbuf_idx == symbuf_end)
	fill_symbuf (abfd);
      bufp = &symbuf[symbuf_idx++];
      INTERNALIZE_SYMBOL (nlist, bufp, abfd);
      OBJSTAT (objfile, n_stabs++);

      type = bfd_h_get_8 (abfd, bufp->e_type);

      namestring = set_namestring (objfile, &nlist);

      if (type & N_STAB)
	{
	  if (sizeof (nlist.n_value) > 4
	      /* We are a 64-bit debugger debugging a 32-bit program.  */
	      && (type == N_LSYM || type == N_PSYM))
	      /* We have to be careful with the n_value in the case of N_LSYM
		 and N_PSYM entries, because they are signed offsets from frame
		 pointer, but we actually read them as unsigned 32-bit values.
		 This is not a problem for 32-bit debuggers, for which negative
		 values end up being interpreted correctly (as negative
		 offsets) due to integer overflow.
		 But we need to sign-extend the value for 64-bit debuggers,
		 or we'll end up interpreting negative values as very large
		 positive offsets.  */
	    nlist.n_value = (nlist.n_value ^ 0x80000000) - 0x80000000;
	  process_one_symbol (type, nlist.n_desc, nlist.n_value,
			      namestring, section_offsets, objfile);
	}
      /* We skip checking for a new .o or -l file; that should never
         happen in this routine.  */
      else if (type == N_TEXT)
	{
	  /* I don't think this code will ever be executed, because
	     the GCC_COMPILED_FLAG_SYMBOL usually is right before
	     the N_SO symbol which starts this source file.
	     However, there is no reason not to accept
	     the GCC_COMPILED_FLAG_SYMBOL anywhere.  */

	  if (strcmp (namestring, GCC_COMPILED_FLAG_SYMBOL) == 0)
	    processing_gcc_compilation = 1;
	  else if (strcmp (namestring, GCC2_COMPILED_FLAG_SYMBOL) == 0)
	    processing_gcc_compilation = 2;
	}
      else if (type & N_EXT || type == (unsigned char) N_TEXT
	       || type == (unsigned char) N_NBTEXT)
	{
	  /* Global symbol: see if we came across a dbx defintion for
	     a corresponding symbol.  If so, store the value.  Remove
	     syms from the chain when their values are stored, but
	     search the whole chain, as there may be several syms from
	     different files with the same name.  */
	  /* This is probably not true.  Since the files will be read
	     in one at a time, each reference to a global symbol will
	     be satisfied in each file as it appears.  So we skip this
	     section.  */
	  ;
	}
    }

  /* In a Solaris elf file, this variable, which comes from the
     value of the N_SO symbol, will still be 0.  Luckily, text_offset,
     which comes from pst->textlow is correct.  */
  if (last_source_start_addr == 0)
    last_source_start_addr = text_offset;

  /* In reordered executables last_source_start_addr may not be the
     lower bound for this symtab, instead use text_offset which comes
     from pst->textlow which is correct.  */
  if (last_source_start_addr > text_offset)
    last_source_start_addr = text_offset;

  pst->symtab = end_symtab (text_offset + text_size, objfile,
			    SECT_OFF_TEXT (objfile));

  end_stabs ();

  dbxread_objfile = NULL;
}


/* Record the namespace that the function defined by SYMBOL was
   defined in, if necessary.  BLOCK is the associated block; use
   OBSTACK for allocation.  */

static void
cp_set_block_scope (const struct symbol *symbol,
		    struct block *block,
		    struct obstack *obstack)
{
  if (SYMBOL_DEMANGLED_NAME (symbol) != NULL)
    {
      /* Try to figure out the appropriate namespace from the
	 demangled name.  */

      /* FIXME: carlton/2003-04-15: If the function in question is
	 a method of a class, the name will actually include the
	 name of the class as well.  This should be harmless, but
	 is a little unfortunate.  */

      const char *name = SYMBOL_DEMANGLED_NAME (symbol);
      unsigned int prefix_len = cp_entire_prefix_len (name);

      block_set_scope (block,
		       obstack_copy0 (obstack, name, prefix_len),
		       obstack);
    }
}

/* This handles a single symbol from the symbol-file, building symbols
   into a GDB symtab.  It takes these arguments and an implicit argument.

   TYPE is the type field of the ".stab" symbol entry.
   DESC is the desc field of the ".stab" entry.
   VALU is the value field of the ".stab" entry.
   NAME is the symbol name, in our address space.
   SECTION_OFFSETS is a set of amounts by which the sections of this
   object file were relocated when it was loaded into memory.  Note
   that these section_offsets are not the objfile->section_offsets but
   the pst->section_offsets.  All symbols that refer to memory
   locations need to be offset by these amounts.
   OBJFILE is the object file from which we are reading symbols.  It
   is used in end_symtab.  */

void
process_one_symbol (int type, int desc, CORE_ADDR valu, char *name,
		    const struct section_offsets *section_offsets,
		    struct objfile *objfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  struct context_stack *new;
  /* This remembers the address of the start of a function.  It is
     used because in Solaris 2, N_LBRAC, N_RBRAC, and N_SLINE entries
     are relative to the current function's start address.  On systems
     other than Solaris 2, this just holds the SECT_OFF_TEXT value,
     and is used to relocate these symbol types rather than
     SECTION_OFFSETS.  */
  static CORE_ADDR function_start_offset;

  /* This holds the address of the start of a function, without the
     system peculiarities of function_start_offset.  */
  static CORE_ADDR last_function_start;

  /* If this is nonzero, we've seen an N_SLINE since the start of the
     current function.  We use this to tell us to move the first sline
     to the beginning of the function regardless of what its given
     value is.  */
  static int sline_found_in_function = 1;

  /* If this is nonzero, we've seen a non-gcc N_OPT symbol for this
     source file.  Used to detect the SunPRO solaris compiler.  */
  static int n_opt_found;

  /* The stab type used for the definition of the last function.
     N_STSYM or N_GSYM for SunOS4 acc; N_FUN for other compilers.  */
  static int function_stab_type = 0;

  if (!block_address_function_relative)
    {
      /* N_LBRAC, N_RBRAC and N_SLINE entries are not relative to the
	 function start address, so just use the text offset.  */
      function_start_offset =
	ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));
    }

  /* Something is wrong if we see real data before seeing a source
     file name.  */

  if (get_last_source_file () == NULL && type != (unsigned char) N_SO)
    {
      /* Ignore any symbols which appear before an N_SO symbol.
         Currently no one puts symbols there, but we should deal
         gracefully with the case.  A complain()t might be in order,
         but this should not be an error ().  */
      return;
    }

  switch (type)
    {
    case N_FUN:
    case N_FNAME:

      if (*name == '\000')
	{
	  /* This N_FUN marks the end of a function.  This closes off
	     the current block.  */
	  struct block *block;

 	  if (context_stack_depth <= 0)
 	    {
	      lbrac_mismatch_complaint (symnum);
 	      break;
 	    }

	  /* The following check is added before recording line 0 at
	     end of function so as to handle hand-generated stabs
	     which may have an N_FUN stabs at the end of the function,
	     but no N_SLINE stabs.  */
	  if (sline_found_in_function)
	    {
	      CORE_ADDR addr = last_function_start + valu;

	      record_line (current_subfile, 0,
			   gdbarch_addr_bits_remove (gdbarch, addr));
	    }

	  within_function = 0;
	  new = pop_context ();

	  /* Make a block for the local symbols within.  */
	  block = finish_block (new->name, &local_symbols, new->old_blocks,
				new->start_addr, new->start_addr + valu,
				objfile);

	  /* For C++, set the block's scope.  */
	  if (SYMBOL_LANGUAGE (new->name) == language_cplus)
	    cp_set_block_scope (new->name, block, &objfile->objfile_obstack);

	  /* May be switching to an assembler file which may not be using
	     block relative stabs, so reset the offset.  */
	  if (block_address_function_relative)
	    function_start_offset = 0;

	  break;
	}

      sline_found_in_function = 0;

      /* Relocate for dynamic loading.  */
      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));
      valu = gdbarch_addr_bits_remove (gdbarch, valu);
      last_function_start = valu;

      goto define_a_symbol;

    case N_LBRAC:
      /* This "symbol" just indicates the start of an inner lexical
         context within a function.  */

      /* Ignore extra outermost context from SunPRO cc and acc.  */
      if (n_opt_found && desc == 1)
	break;

      if (block_address_function_relative)
	/* Relocate for Sun ELF acc fn-relative syms.  */
	valu += function_start_offset;
      else
	/* On most machines, the block addresses are relative to the
	   N_SO, the linker did not relocate them (sigh).  */
	valu += last_source_start_addr;

      push_context (desc, valu);
      break;

    case N_RBRAC:
      /* This "symbol" just indicates the end of an inner lexical
         context that was started with N_LBRAC.  */

      /* Ignore extra outermost context from SunPRO cc and acc.  */
      if (n_opt_found && desc == 1)
	break;

      if (block_address_function_relative)
	/* Relocate for Sun ELF acc fn-relative syms.  */
	valu += function_start_offset;
      else
	/* On most machines, the block addresses are relative to the
	   N_SO, the linker did not relocate them (sigh).  */
	valu += last_source_start_addr;

      if (context_stack_depth <= 0)
	{
	  lbrac_mismatch_complaint (symnum);
	  break;
	}

      new = pop_context ();
      if (desc != new->depth)
	lbrac_mismatch_complaint (symnum);

      if (local_symbols != NULL)
	{
	  /* GCC development snapshots from March to December of
	     2000 would output N_LSYM entries after N_LBRAC
	     entries.  As a consequence, these symbols are simply
	     discarded.  Complain if this is the case.  */
	  complaint (&symfile_complaints,
		     _("misplaced N_LBRAC entry; discarding local "
		       "symbols which have no enclosing block"));
	}
      local_symbols = new->locals;

      if (context_stack_depth > 1)
	{
	  /* This is not the outermost LBRAC...RBRAC pair in the
	     function, its local symbols preceded it, and are the ones
	     just recovered from the context stack.  Define the block
	     for them (but don't bother if the block contains no
	     symbols.  Should we complain on blocks without symbols?
	     I can't think of any useful purpose for them).  */
	  if (local_symbols != NULL)
	    {
	      /* Muzzle a compiler bug that makes end < start.

		 ??? Which compilers?  Is this ever harmful?.  */
	      if (new->start_addr > valu)
		{
		  complaint (&symfile_complaints,
			     _("block start larger than block end"));
		  new->start_addr = valu;
		}
	      /* Make a block for the local symbols within.  */
	      finish_block (0, &local_symbols, new->old_blocks,
			    new->start_addr, valu, objfile);
	    }
	}
      else
	{
	  /* This is the outermost LBRAC...RBRAC pair.  There is no
	     need to do anything; leave the symbols that preceded it
	     to be attached to the function's own block.  We need to
	     indicate that we just moved outside of the function.  */
	  within_function = 0;
	}

      break;

    case N_FN:
    case N_FN_SEQ:
      /* This kind of symbol indicates the start of an object file.
         Relocate for dynamic loading.  */
      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));
      break;

    case N_SO:
      /* This type of symbol indicates the start of data for one
         source file.  Finish the symbol table of the previous source
         file (if any) and start accumulating a new symbol table.
         Relocate for dynamic loading.  */
      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));

      n_opt_found = 0;

      if (get_last_source_file ())
	{
	  /* Check if previous symbol was also an N_SO (with some
	     sanity checks).  If so, that one was actually the
	     directory name, and the current one is the real file
	     name.  Patch things up.  */
	  if (previous_stab_code == (unsigned char) N_SO)
	    {
	      patch_subfile_names (current_subfile, name);
	      break;		/* Ignore repeated SOs.  */
	    }
	  end_symtab (valu, objfile, SECT_OFF_TEXT (objfile));
	  end_stabs ();
	}

      /* Null name means this just marks the end of text for this .o
         file.  Don't start a new symtab in this case.  */
      if (*name == '\000')
	break;

      if (block_address_function_relative)
	function_start_offset = 0;

      start_stabs ();
      start_symtab (name, NULL, valu);
      record_debugformat ("stabs");
      break;

    case N_SOL:
      /* This type of symbol indicates the start of data for a
         sub-source-file, one whose contents were copied or included
         in the compilation of the main source file (whose name was
         given in the N_SO symbol).  Relocate for dynamic loading.  */
      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));
      start_subfile (name, current_subfile->dirname);
      break;

    case N_BINCL:
      push_subfile ();
      add_new_header_file (name, valu);
      start_subfile (name, current_subfile->dirname);
      break;

    case N_EINCL:
      start_subfile (pop_subfile (), current_subfile->dirname);
      break;

    case N_EXCL:
      add_old_header_file (name, valu);
      break;

    case N_SLINE:
      /* This type of "symbol" really just records one line-number --
         core-address correspondence.  Enter it in the line list for
         this symbol table.  */

      /* Relocate for dynamic loading and for ELF acc
         function-relative symbols.  */
      valu += function_start_offset;

      /* GCC 2.95.3 emits the first N_SLINE stab somwehere in the
	 middle of the prologue instead of right at the start of the
	 function.  To deal with this we record the address for the
	 first N_SLINE stab to be the start of the function instead of
	 the listed location.  We really shouldn't to this.  When
	 compiling with optimization, this first N_SLINE stab might be
	 optimized away.  Other (non-GCC) compilers don't emit this
	 stab at all.  There is no real harm in having an extra
	 numbered line, although it can be a bit annoying for the
	 user.  However, it totally screws up our testsuite.

	 So for now, keep adjusting the address of the first N_SLINE
	 stab, but only for code compiled with GCC.  */

      if (within_function && sline_found_in_function == 0)
	{
	  CORE_ADDR addr = processing_gcc_compilation == 2 ?
			   last_function_start : valu;

	  record_line (current_subfile, desc,
		       gdbarch_addr_bits_remove (gdbarch, addr));
	  sline_found_in_function = 1;
	}
      else
	record_line (current_subfile, desc,
		     gdbarch_addr_bits_remove (gdbarch, valu));
      break;

    case N_BCOMM:
      common_block_start (name, objfile);
      break;

    case N_ECOMM:
      common_block_end (objfile);
      break;

      /* The following symbol types need to have the appropriate
         offset added to their value; then we process symbol
         definitions in the name.  */

    case N_STSYM:		/* Static symbol in data segment.  */
    case N_LCSYM:		/* Static symbol in BSS segment.  */
    case N_ROSYM:		/* Static symbol in read-only data segment.  */
      /* HORRID HACK DEPT.  However, it's Sun's furgin' fault.
         Solaris 2's stabs-in-elf makes *most* symbols relative but
         leaves a few absolute (at least for Solaris 2.1 and version
         2.0.1 of the SunPRO compiler).  N_STSYM and friends sit on
         the fence.  .stab "foo:S...",N_STSYM is absolute (ld
         relocates it) .stab "foo:V...",N_STSYM is relative (section
         base subtracted).  This leaves us no choice but to search for
         the 'S' or 'V'...  (or pass the whole section_offsets stuff
         down ONE MORE function call level, which we really don't want
         to do).  */
      {
	char *p;

	/* Normal object file and NLMs have non-zero text seg offsets,
	   but don't need their static syms offset in this fashion.
	   XXX - This is really a crock that should be fixed in the
	   solib handling code so that I don't have to work around it
	   here.  */

	if (!symfile_relocatable)
	  {
	    p = strchr (name, ':');
	    if (p != 0 && p[1] == 'S')
	      {
		/* The linker relocated it.  We don't want to add an
		   elfstab_offset_sections-type offset, but we *do*
		   want to add whatever solib.c passed to
		   symbol_file_add as addr (this is known to affect
		   SunOS 4, and I suspect ELF too).  Since
		   elfstab_offset_sections currently does not muck
		   with the text offset (there is no Ttext.text
		   symbol), we can get addr from the text offset.  If
		   elfstab_offset_sections ever starts dealing with
		   the text offset, and we still need to do this, we
		   need to invent a SECT_OFF_ADDR_KLUDGE or something.  */
		valu += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));
		goto define_a_symbol;
	      }
	  }
	/* Since it's not the kludge case, re-dispatch to the right
           handler.  */
	switch (type)
	  {
	  case N_STSYM:
	    goto case_N_STSYM;
	  case N_LCSYM:
	    goto case_N_LCSYM;
	  case N_ROSYM:
	    goto case_N_ROSYM;
	  default:
	    internal_error (__FILE__, __LINE__,
			    _("failed internal consistency check"));
	  }
      }

    case_N_STSYM:		/* Static symbol in data segment.  */
    case N_DSLINE:		/* Source line number, data segment.  */
      valu += ANOFFSET (section_offsets, SECT_OFF_DATA (objfile));
      goto define_a_symbol;

    case_N_LCSYM:		/* Static symbol in BSS segment.  */
    case N_BSLINE:		/* Source line number, BSS segment.  */
      /* N_BROWS: overlaps with N_BSLINE.  */
      valu += ANOFFSET (section_offsets, SECT_OFF_BSS (objfile));
      goto define_a_symbol;

    case_N_ROSYM:		/* Static symbol in read-only data segment.  */
      valu += ANOFFSET (section_offsets, SECT_OFF_RODATA (objfile));
      goto define_a_symbol;

    case N_ENTRY:		/* Alternate entry point.  */
      /* Relocate for dynamic loading.  */
      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));
      goto define_a_symbol;

      /* The following symbol types we don't know how to process.
         Handle them in a "default" way, but complain to people who
         care.  */
    default:
    case N_CATCH:		/* Exception handler catcher.  */
    case N_EHDECL:		/* Exception handler name.  */
    case N_PC:			/* Global symbol in Pascal.  */
    case N_M2C:			/* Modula-2 compilation unit.  */
      /* N_MOD2: overlaps with N_EHDECL.  */
    case N_SCOPE:		/* Modula-2 scope information.  */
    case N_ECOML:		/* End common (local name).  */
    case N_NBTEXT:		/* Gould Non-Base-Register symbols???  */
    case N_NBDATA:
    case N_NBBSS:
    case N_NBSTS:
    case N_NBLCS:
      unknown_symtype_complaint (hex_string (type));
      /* FALLTHROUGH */

      /* The following symbol types don't need the address field
         relocated, since it is either unused, or is absolute.  */
    define_a_symbol:
    case N_GSYM:		/* Global variable.  */
    case N_NSYMS:		/* Number of symbols (Ultrix).  */
    case N_NOMAP:		/* No map?  (Ultrix).  */
    case N_RSYM:		/* Register variable.  */
    case N_DEFD:		/* Modula-2 GNU module dependency.  */
    case N_SSYM:		/* Struct or union element.  */
    case N_LSYM:		/* Local symbol in stack.  */
    case N_PSYM:		/* Parameter variable.  */
    case N_LENG:		/* Length of preceding symbol type.  */
      if (name)
	{
	  int deftype;
	  char *colon_pos = strchr (name, ':');

	  if (colon_pos == NULL)
	    deftype = '\0';
	  else
	    deftype = colon_pos[1];

	  switch (deftype)
	    {
	    case 'f':
	    case 'F':
	      function_stab_type = type;

	      /* Deal with the SunPRO 3.0 compiler which omits the
	         address from N_FUN symbols.  */
	      if (type == N_FUN
		  && valu == ANOFFSET (section_offsets,
				       SECT_OFF_TEXT (objfile))
		  && gdbarch_sofun_address_maybe_missing (gdbarch))
		{
		  CORE_ADDR minsym_valu = 
		    find_stab_function_addr (name, get_last_source_file (),
					     objfile);

		  /* The function find_stab_function_addr will return
		     0 if the minimal symbol wasn't found.
		     (Unfortunately, this might also be a valid
		     address.)  Anyway, if it *does* return 0, it is
		     likely that the value was set correctly to begin
		     with...  */
		  if (minsym_valu != 0)
		    valu = minsym_valu;
		}

	      if (block_address_function_relative)
		/* For Solaris 2 compilers, the block addresses and
		   N_SLINE's are relative to the start of the
		   function.  On normal systems, and when using GCC on
		   Solaris 2, these addresses are just absolute, or
		   relative to the N_SO, depending on
		   BLOCK_ADDRESS_ABSOLUTE.  */
		function_start_offset = valu;

	      within_function = 1;

	      if (context_stack_depth > 1)
		{
		  complaint (&symfile_complaints,
			     _("unmatched N_LBRAC before symtab pos %d"),
			     symnum);
		  break;
		}

	      if (context_stack_depth > 0)
		{
		  struct block *block;

		  new = pop_context ();
		  /* Make a block for the local symbols within.  */
		  block = finish_block (new->name, &local_symbols,
					new->old_blocks, new->start_addr,
					valu, objfile);

		  /* For C++, set the block's scope.  */
		  if (SYMBOL_LANGUAGE (new->name) == language_cplus)
		    cp_set_block_scope (new->name, block,
					&objfile->objfile_obstack);
		}

	      new = push_context (0, valu);
	      new->name = define_symbol (valu, name, desc, type, objfile);
	      break;

	    default:
	      define_symbol (valu, name, desc, type, objfile);
	      break;
	    }
	}
      break;

      /* We use N_OPT to carry the gcc2_compiled flag.  Sun uses it
         for a bunch of other flags, too.  Someday we may parse their
         flags; for now we ignore theirs and hope they'll ignore ours.  */
    case N_OPT:			/* Solaris 2: Compiler options.  */
      if (name)
	{
	  if (strcmp (name, GCC2_COMPILED_FLAG_SYMBOL) == 0)
	    {
	      processing_gcc_compilation = 2;
	    }
	  else
	    n_opt_found = 1;
	}
      break;

    case N_MAIN:		/* Name of main routine.  */
      /* FIXME: If one has a symbol file with N_MAIN and then replaces
	 it with a symbol file with "main" and without N_MAIN.  I'm
	 not sure exactly what rule to follow but probably something
	 like: N_MAIN takes precedence over "main" no matter what
	 objfile it is in; If there is more than one N_MAIN, choose
	 the one in the symfile_objfile; If there is more than one
	 N_MAIN within a given objfile, complain() and choose
	 arbitrarily.  (kingdon) */
      if (name != NULL)
	set_main_name (name);
      break;

      /* The following symbol types can be ignored.  */
    case N_OBJ:			/* Solaris 2: Object file dir and name.  */
    case N_PATCH:		/* Solaris 2: Patch Run Time Checker.  */
      /* N_UNDF:                   Solaris 2: File separator mark.  */
      /* N_UNDF: -- we will never encounter it, since we only process
         one file's symbols at once.  */
    case N_ENDM:		/* Solaris 2: End of module.  */
    case N_ALIAS:		/* SunPro F77: alias name, ignore for now.  */
      break;
    }

  /* '#' is a GNU C extension to allow one symbol to refer to another
     related symbol.

     Generally this is used so that an alias can refer to its main
     symbol.  */
  gdb_assert (name);
  if (name[0] == '#')
    {
      /* Initialize symbol reference names and determine if this is a
         definition.  If a symbol reference is being defined, go ahead
         and add it.  Otherwise, just return.  */

      char *s = name;
      int refnum;

      /* If this stab defines a new reference ID that is not on the
         reference list, then put it on the reference list.

         We go ahead and advance NAME past the reference, even though
         it is not strictly necessary at this time.  */
      refnum = symbol_reference_defined (&s);
      if (refnum >= 0)
	if (!ref_search (refnum))
	  ref_add (refnum, 0, name, valu);
      name = s;
    }

  previous_stab_code = type;
}

/* FIXME: The only difference between this and elfstab_build_psymtabs
   is the call to install_minimal_symbols for elf, and the support for
   split sections.  If the differences are really that small, the code
   should be shared.  */

/* Scan and build partial symbols for an coff symbol file.
   The coff file has already been processed to get its minimal symbols.

   This routine is the equivalent of dbx_symfile_init and dbx_symfile_read
   rolled into one.

   OBJFILE is the object file we are reading symbols from.
   ADDR is the address relative to which the symbols are (e.g.
   the base address of the text segment).
   TEXTADDR is the address of the text section.
   TEXTSIZE is the size of the text section.
   STABSECTS is the list of .stab sections in OBJFILE.
   STABSTROFFSET and STABSTRSIZE define the location in OBJFILE where the
   .stabstr section exists.

   This routine is mostly copied from dbx_symfile_init and dbx_symfile_read,
   adjusted for coff details.  */

void
coffstab_build_psymtabs (struct objfile *objfile,
			 CORE_ADDR textaddr, unsigned int textsize,
			 struct stab_section_list *stabsects,
			 file_ptr stabstroffset, unsigned int stabstrsize)
{
  int val;
  bfd *sym_bfd = objfile->obfd;
  char *name = bfd_get_filename (sym_bfd);
  struct dbx_symfile_info *info;
  unsigned int stabsize;

  /* There is already a dbx_symfile_info allocated by our caller.
     It might even contain some info from the coff symtab to help us.  */
  info = DBX_SYMFILE_INFO (objfile);

  DBX_TEXT_ADDR (objfile) = textaddr;
  DBX_TEXT_SIZE (objfile) = textsize;

#define	COFF_STABS_SYMBOL_SIZE	12	/* XXX FIXME XXX */
  DBX_SYMBOL_SIZE (objfile) = COFF_STABS_SYMBOL_SIZE;
  DBX_STRINGTAB_SIZE (objfile) = stabstrsize;

  if (stabstrsize > bfd_get_size (sym_bfd))
    error (_("ridiculous string table size: %d bytes"), stabstrsize);
  DBX_STRINGTAB (objfile) = (char *)
    obstack_alloc (&objfile->objfile_obstack, stabstrsize + 1);
  OBJSTAT (objfile, sz_strtab += stabstrsize + 1);

  /* Now read in the string table in one big gulp.  */

  val = bfd_seek (sym_bfd, stabstroffset, SEEK_SET);
  if (val < 0)
    perror_with_name (name);
  val = bfd_bread (DBX_STRINGTAB (objfile), stabstrsize, sym_bfd);
  if (val != stabstrsize)
    perror_with_name (name);

  stabsread_new_init ();
  buildsym_new_init ();
  free_header_files ();
  init_header_files ();

  processing_acc_compilation = 1;

  /* In a coff file, we've already installed the minimal symbols that came
     from the coff (non-stab) symbol table, so always act like an
     incremental load here.  */
  if (stabsects->next == NULL)
    {
      stabsize = bfd_section_size (sym_bfd, stabsects->section);
      DBX_SYMCOUNT (objfile) = stabsize / DBX_SYMBOL_SIZE (objfile);
      DBX_SYMTAB_OFFSET (objfile) = stabsects->section->filepos;
    }
  else
    {
      struct stab_section_list *stabsect;

      DBX_SYMCOUNT (objfile) = 0;
      for (stabsect = stabsects; stabsect != NULL; stabsect = stabsect->next)
	{
	  stabsize = bfd_section_size (sym_bfd, stabsect->section);
	  DBX_SYMCOUNT (objfile) += stabsize / DBX_SYMBOL_SIZE (objfile);
	}

      DBX_SYMTAB_OFFSET (objfile) = stabsects->section->filepos;

      symbuf_sections = stabsects->next;
      symbuf_left = bfd_section_size (sym_bfd, stabsects->section);
      symbuf_read = 0;
    }

  dbx_symfile_read (objfile, 0);
}

/* Scan and build partial symbols for an ELF symbol file.
   This ELF file has already been processed to get its minimal symbols.

   This routine is the equivalent of dbx_symfile_init and dbx_symfile_read
   rolled into one.

   OBJFILE is the object file we are reading symbols from.
   ADDR is the address relative to which the symbols are (e.g.
   the base address of the text segment).
   STABSECT is the BFD section information for the .stab section.
   STABSTROFFSET and STABSTRSIZE define the location in OBJFILE where the
   .stabstr section exists.

   This routine is mostly copied from dbx_symfile_init and dbx_symfile_read,
   adjusted for elf details.  */

void
elfstab_build_psymtabs (struct objfile *objfile, asection *stabsect,
			file_ptr stabstroffset, unsigned int stabstrsize)
{
  int val;
  bfd *sym_bfd = objfile->obfd;
  char *name = bfd_get_filename (sym_bfd);
  struct dbx_symfile_info *info;
  struct cleanup *back_to = make_cleanup (null_cleanup, NULL);

  /* There is already a dbx_symfile_info allocated by our caller.
     It might even contain some info from the ELF symtab to help us.  */
  info = DBX_SYMFILE_INFO (objfile);

  /* Find the first and last text address.  dbx_symfile_read seems to
     want this.  */
  find_text_range (sym_bfd, objfile);

#define	ELF_STABS_SYMBOL_SIZE	12	/* XXX FIXME XXX */
  DBX_SYMBOL_SIZE (objfile) = ELF_STABS_SYMBOL_SIZE;
  DBX_SYMCOUNT (objfile)
    = bfd_section_size (objfile->obfd, stabsect) / DBX_SYMBOL_SIZE (objfile);
  DBX_STRINGTAB_SIZE (objfile) = stabstrsize;
  DBX_SYMTAB_OFFSET (objfile) = stabsect->filepos;
  DBX_STAB_SECTION (objfile) = stabsect;

  if (stabstrsize > bfd_get_size (sym_bfd))
    error (_("ridiculous string table size: %d bytes"), stabstrsize);
  DBX_STRINGTAB (objfile) = (char *)
    obstack_alloc (&objfile->objfile_obstack, stabstrsize + 1);
  OBJSTAT (objfile, sz_strtab += stabstrsize + 1);

  /* Now read in the string table in one big gulp.  */

  val = bfd_seek (sym_bfd, stabstroffset, SEEK_SET);
  if (val < 0)
    perror_with_name (name);
  val = bfd_bread (DBX_STRINGTAB (objfile), stabstrsize, sym_bfd);
  if (val != stabstrsize)
    perror_with_name (name);

  stabsread_new_init ();
  buildsym_new_init ();
  free_header_files ();
  init_header_files ();

  processing_acc_compilation = 1;

  symbuf_read = 0;
  symbuf_left = bfd_section_size (objfile->obfd, stabsect);
  stabs_data = symfile_relocate_debug_section (objfile, stabsect, NULL);
  if (stabs_data)
    make_cleanup (free_current_contents, (void *) &stabs_data);

  /* In an elf file, we've already installed the minimal symbols that came
     from the elf (non-stab) symbol table, so always act like an
     incremental load here.  dbx_symfile_read should not generate any new
     minimal symbols, since we will have already read the ELF dynamic symbol
     table and normal symbol entries won't be in the ".stab" section; but in
     case it does, it will install them itself.  */
  dbx_symfile_read (objfile, 0);

  do_cleanups (back_to);
}

/* Scan and build partial symbols for a file with special sections for stabs
   and stabstrings.  The file has already been processed to get its minimal
   symbols, and any other symbols that might be necessary to resolve GSYMs.

   This routine is the equivalent of dbx_symfile_init and dbx_symfile_read
   rolled into one.

   OBJFILE is the object file we are reading symbols from.
   ADDR is the address relative to which the symbols are (e.g. the base address
   of the text segment).
   STAB_NAME is the name of the section that contains the stabs.
   STABSTR_NAME is the name of the section that contains the stab strings.

   This routine is mostly copied from dbx_symfile_init and
   dbx_symfile_read.  */

void
stabsect_build_psymtabs (struct objfile *objfile, char *stab_name,
			 char *stabstr_name, char *text_name)
{
  int val;
  bfd *sym_bfd = objfile->obfd;
  char *name = bfd_get_filename (sym_bfd);
  asection *stabsect;
  asection *stabstrsect;
  asection *text_sect;
  struct dbx_symfile_info *dbx;

  stabsect = bfd_get_section_by_name (sym_bfd, stab_name);
  stabstrsect = bfd_get_section_by_name (sym_bfd, stabstr_name);

  if (!stabsect)
    return;

  if (!stabstrsect)
    error (_("stabsect_build_psymtabs:  Found stabs (%s), "
	     "but not string section (%s)"),
	   stab_name, stabstr_name);

  dbx = XCNEW (struct dbx_symfile_info);
  set_objfile_data (objfile, dbx_objfile_data_key, dbx);

  text_sect = bfd_get_section_by_name (sym_bfd, text_name);
  if (!text_sect)
    error (_("Can't find %s section in symbol file"), text_name);
  DBX_TEXT_ADDR (objfile) = bfd_section_vma (sym_bfd, text_sect);
  DBX_TEXT_SIZE (objfile) = bfd_section_size (sym_bfd, text_sect);

  DBX_SYMBOL_SIZE (objfile) = sizeof (struct external_nlist);
  DBX_SYMCOUNT (objfile) = bfd_section_size (sym_bfd, stabsect)
    / DBX_SYMBOL_SIZE (objfile);
  DBX_STRINGTAB_SIZE (objfile) = bfd_section_size (sym_bfd, stabstrsect);
  DBX_SYMTAB_OFFSET (objfile) = stabsect->filepos;	/* XXX - FIXME: POKING
							   INSIDE BFD DATA
							   STRUCTURES */

  if (DBX_STRINGTAB_SIZE (objfile) > bfd_get_size (sym_bfd))
    error (_("ridiculous string table size: %d bytes"),
	   DBX_STRINGTAB_SIZE (objfile));
  DBX_STRINGTAB (objfile) = (char *)
    obstack_alloc (&objfile->objfile_obstack,
		   DBX_STRINGTAB_SIZE (objfile) + 1);
  OBJSTAT (objfile, sz_strtab += DBX_STRINGTAB_SIZE (objfile) + 1);

  /* Now read in the string table in one big gulp.  */

  val = bfd_get_section_contents (sym_bfd,	/* bfd */
				  stabstrsect,	/* bfd section */
				  DBX_STRINGTAB (objfile), /* input buffer */
				  0,		/* offset into section */
				  DBX_STRINGTAB_SIZE (objfile)); /* amount to
								    read */

  if (!val)
    perror_with_name (name);

  stabsread_new_init ();
  buildsym_new_init ();
  free_header_files ();
  init_header_files ();

  /* Now, do an incremental load.  */

  processing_acc_compilation = 1;
  dbx_symfile_read (objfile, 0);
}

static const struct sym_fns aout_sym_fns =
{
  dbx_new_init,			/* init anything gbl to entire symtab */
  dbx_symfile_init,		/* read initial info, setup for sym_read() */
  dbx_symfile_read,		/* read a symbol file into symtab */
  NULL,				/* sym_read_psymbols */
  dbx_symfile_finish,		/* finished with file, cleanup */
  default_symfile_offsets, 	/* parse user's offsets to internal form */
  default_symfile_segments,	/* Get segment information from a file.  */
  NULL,
  default_symfile_relocate,	/* Relocate a debug section.  */
  NULL,				/* sym_probe_fns */
  &psym_functions
};

void
_initialize_dbxread (void)
{
  add_symtab_fns (bfd_target_aout_flavour, &aout_sym_fns);

  dbx_objfile_data_key
    = register_objfile_data_with_cleanup (NULL, dbx_free_symfile_info);
}
@


1.151
log
@	* symfile.h (struct sym_fns): Delete member "sym_flavour".
	All uses updated.
	(add_symtab_fns): Update prototype.
	* symfile.c (sym_fns_ptr): Delete.  Replace with ...
	(registered_sym_fns): ... this.
	(symtab_fns): Update.
	(add_symtab_fns): New arg "flavour".  All callers updated.
	(find_sym_fns): Rewrite to use new sym_fns registry.
@
text
@a1352 1
	bss_ext_symbol:
@


1.150
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@a3566 1
  bfd_target_aout_flavour,
d3583 1
a3583 1
  add_symtab_fns (&aout_sym_fns);
@


1.149
log
@	* buildsym.c (subfile_stack): Move here from buildsym.h.
	(pending_macros): Ditto.
	(get_macro_table): New function.
	(buildsym_init): Initialize subfile_stack.
	* coffread.c (type_vector,type_vector_length): Moved here from
	buildsym.h.
	(INITIAL_TYPE_VECTOR_LENGTH): Ditto.
	(coff_symtab_read): Use it.
	* dbxread.c (read_ofile_symtab): Delete init of subfile_stack.
	* dwarf2read.c (macro_start_file): Replace uses of pending_macros
	with call to get_macro_table.
	* stabsread.c (type_vector,type_vector_length): Moved here from
	buildsym.h.
	(INITIAL_TYPE_VECTOR_LENGTH): Ditto.
	* buildsym.h (get_macro_table): Declare.
@
text
@d556 1
a556 1
    perror_with_name (objfile->name);
@


1.148
log
@	* dbxread.c (record_minimal_symbol): Make 'name' argument const.
	Update.
	(read_dbx_dynamic_symtab): Make 'name' const.  Remove casts.
@
text
@a2532 1
  subfile_stack = NULL;
@


1.147
log
@fix dbxread.c

This is a stylistic change to make some code in dbxread.c analyzable
by the checker.

	* dbxread.c (dbx_read_symtab): Declare 'back_to' in a more
	inner scope.  Unconditionally call do_cleanups.
@
text
@d294 2
a295 1
static void record_minimal_symbol (char *, CORE_ADDR, int, struct objfile *);
d439 1
a439 1
record_minimal_symbol (char *name, CORE_ADDR address, int type,
d495 1
a495 1
	char *tempstring = name;
d1005 1
a1005 1
  char *name;
d1071 1
a1071 1
	  record_minimal_symbol ((char *) bfd_asymbol_name (sym), sym_value,
d1125 1
a1125 1
      name = (char *) bfd_asymbol_name (*rel->sym_ptr_ptr);
@


1.146
log
@	* dbxread.c (process_one_symbol): Constify section_offsets parameter.
	* stabsread.h (process_one_symbol): Update declaration.
	* dwarf2read.c (dw2_relocate): Constify new_offsets, delta parameters.
	* elfread.c (elf_symfile_relocate_probe): Ditto.
	* psymtab.c (relocate_psymtabs): Ditto.
	* objfiles.c (objfile_relocate1): Constify new_offsets parameter.
	(objfile_relocate): Ditto.
	* objfiles.h (objfile_relocate): Update declaration.
	* symfile.c (relative_addr_info_to_section_offsets): Constify
	addrs parameter.
	(default_symfile_offsets): Ditto.
	(syms_from_objfile_1): Constify offsets parameter.
	(syms_from_objfile): Ditto.
	(symbol_file_add_with_addrs_or_offsets): Ditto.
	(symfile_map_offsets_to_segments): Constify data parameter.
	* symfile.h (struct quick_symbol_functions): Constify new_offsets,
	delta parameters of member relocate.
	(struct sym_probe_fns): Constify new_offsets,
	delta parameters of member sym_relocate_probe.
	(struct sym_fns): Constify section_addr_info parameter of member
	sym_offsets.
	(relative_addr_info_to_section_offsets): Update declaration.
	(default_symfile_offsets): Ditto.
	(syms_from_objfile): Ditto.
	(symfile_map_offsets_to_segments): Ditto.
@
text
@a2451 1
  struct cleanup *back_to = NULL;
d2463 2
d2477 2
d2487 1
a2487 2
	    back_to = make_cleanup (free_current_contents,
				    (void *) &stabs_data);
d2492 1
a2492 2
      if (back_to)
	do_cleanups (back_to);
@


1.145
log
@	* coffread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* elfread.c (record_minimal_symbol): Update.
	* machoread.c (macho_symtab_add_minsym): Update.
	* mdebugread.c (record_minimal_symbol, parse_partial_symbols):
	Update.
	* minsyms.c (prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_full): Remove 'bfd_section'
	argument.
	(prim_record_minimal_symbol_and_info): Likewise.
	* minsyms.h (prim_record_minimal_symbol_full)
	(prim_record_minimal_symbol_and_info): Update.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): Initialize SYMBOL_SECTION.
	* xcoffread.c (record_minimal_symbol, scan_xcoff_symtab):
	Update.
@
text
@d2720 1
a2720 1
		    struct section_offsets *section_offsets,
@


1.144
log
@Fix completer.c FIXME, and invalid pointer to pointer conversion.

As mentioned in the previous patch, I grepped for "\*\*) &" and found
one hit in completer.c.

I was about to post a patch that simply made
current_demangling_style_string const, and cast away constness at the
xfree site.  However, looking deeper, it seem to be there's a lot of
dead code in the file.

First, all external callers of set_demangling_style are found in the
stabs reader, commented out for over 12 years:

  http://sourceware.org/ml/gdb-patches/2000-12/msg00214.html

I don't think it's likely we'll ever make the older mangling schemes
work for stabs.  If we do, we can rediscuss the approach then.

Then, set_demangling_command has special handling for unknown
demangling styles, but "set demangle-style" is an enum command, and
with those, the user can only specify a known enumeration value, by
design:

  (gdb) set demangle-style gangnam-style
  Undefined item: "gangnam-style".


This patch removes all that dead code, then makes
current_demangling_style_string point to an element of
demangling_style_names, as the FIXME suggests, and then makes
current_demangling_style_string, removing the need for the 'const char
**' cast.

gdb/
2013-03-13  Pedro Alves  <palves@@redhat.com>

	* dbxread.c (read_ofile_symtab, process_one_symbol): Remove
	commented out code.
	* demangle.c (current_demangling_style_string): Make it const.
	(set_demangling_command): Assert the demangling style is known.
	Remove all handling of unknown styles.  Set
	'current_demangling_style_string' to an element of the
	demangling_style_names array.
	(set_demangling_style): Delete.
	(_initialize_demangler): Set current_demangling_style_string to the
	element of the demangling_style_names array that corresponds to
	the default demangling style.  Remove FIXME note.  Don't call
	set_demangling_style.
	* gdb-demangle.h (set_demangling_style): Remove declaration.
@
text
@a442 1
  asection *bfd_section;
a448 1
      bfd_section = DBX_TEXT_SECTION (objfile);
a452 1
      bfd_section = DBX_DATA_SECTION (objfile);
a456 1
      bfd_section = DBX_BSS_SECTION (objfile);
a460 1
      bfd_section = NULL;
a465 1
      bfd_section = DBX_DATA_SECTION (objfile);
a472 1
      bfd_section = DBX_DATA_SECTION (objfile);
a480 1
      bfd_section = DBX_TEXT_SECTION (objfile);
a501 1
      bfd_section = DBX_DATA_SECTION (objfile);
a505 1
      bfd_section = DBX_BSS_SECTION (objfile);
a509 1
      bfd_section = NULL;
d518 1
a518 1
    (name, address, ms_type, section, bfd_section, objfile);
@


1.143
log
@	* cp-namespace.c (cp_set_block_scope): Remove.
	* cp-support.h (cp_set_block_scope): Remove.
	* dbxread.c: Include block.h.
	(cp_set_block_scope): New function.
	(process_one_symbol): Update.
	* dwarf2read.c (read_func_scope): Use block_set_scope.
@
text
@a2582 15

      /* Try to select a C++ demangling based on the compilation unit
         producer.  */

#if 0
      /* For now, stay with AUTO_DEMANGLING for g++ output, as we don't
	 know whether it will use the old style or v3 mangling.  */
      if (processing_gcc_compilation)
	{
	  if (AUTO_DEMANGLING)
	    {
	      set_demangling_style (GNU_DEMANGLING_STYLE_STRING);
	    }
	}
#endif
a2647 9

#if 0
	  /* For now, stay with AUTO_DEMANGLING for g++ output, as we don't
	     know whether it will use the old style or v3 mangling.  */
	  if (AUTO_DEMANGLING)
	    {
	      set_demangling_style (GNU_DEMANGLING_STYLE_STRING);
	    }
#endif
a3248 9
#if 0				/* Works, but is experimental.  -fnf */
	      /* For now, stay with AUTO_DEMANGLING for g++ output, as
		 we don't know whether it will use the old style or v3
		 mangling.  */
	      if (AUTO_DEMANGLING)
		{
		  set_demangling_style (GNU_DEMANGLING_STYLE_STRING);
		}
#endif
@


1.142
log
@	* symfile.h (obsavestring): Don't declare.
	* symfile.c (obsavestring): Remove.
	* ada-exp.y: Use obstack_copy0, not obsavestring.
	* ada-lang.c: Use obstack_copy0, not obsavestring.
	* coffread.c: Use obstack_copy0, not obsavestring.
	* cp-namespace.c: Use obstack_copy0, not obsavestring.
	* dbxread.c: Use obstack_copy0, not obsavestring.
	* dwarf2read.c: Use obstack_copy0, not obsavestring.
	* jit.c: Use obstack_copy0, not obsavestring.
	* mdebugread.c: Use obstack_copy0, not obsavestring.
	* psymtab.c: Use obstack_copy0, not obsavestring.
	* stabsread.c: Use obstack_copy0, not obsavestring.
	* xcoffread.c: Use obstack_copy0, not obsavestring.
@
text
@d58 1
d2710 28
d2845 1
a2845 2
	    cp_set_block_scope (new->name, block, &objfile->objfile_obstack,
				"", 0);
d3250 1
a3250 2
					&objfile->objfile_obstack,
					"", 0);
@


1.141
log
@	* buildsym.c (patch_subfile_names): Use set_last_source_file.
	(start_symtab): Make 'name' and 'dirname' const.  Use
	set_last_source_file.
	(restart_symtab, reset_symtab_globals): Use set_last_source_file.
	(last_source_file): Define.  Now static.
	(set_last_source_file, get_last_source_file): New functions.
	* buildsym.h (last_source_file): Don't declare.
	(start_symtab): Update.
	(set_last_source_file, get_last_source_file): Declare.
	* coffread.c (complete_symtab): Use set_last_source_file.
	(coff_end_symtab): Likewise.
	(coff_symtab_read): Use set_last_source_file, get_last_source_file.
	* dbxread.c (read_dbx_symtab, read_ofile_symtab): Use
	set_last_source_file.
	(process_one_symbol): Use get_last_source_file.
	* mdebugread.c (parse_partial_symbols): Use set_last_source_file.
	(psymtab_to_symtab_1): Use get_last_source_file.
	* xcoffread.c (process_linenos): Use get_last_source_file.
	(complete_symtab): Use set_last_source_file.
	(read_xcoff_symtab): Use set_last_source_file, get_last_source_file.
	(scan_xcoff_symtab): Use set_last_source_file.
@
text
@d1709 2
a1710 2
 		  sym_name = obsavestring (new_name, sym_len,
 					   &objfile->objfile_obstack);
@


1.140
log
@gdb/
	* dbxread.c (dbx_psymtab_to_symtab): Delete the declaration.
	(dbx_read_symtab): New declaration.
	(dbx_psymtab_to_symtab): Delete.
	(dbx_read_symtab): Rename from dbx_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(start_psymtab): Caller update.
	* dwarf2read.c (dwarf2_psymtab_to_symtab): Delete the declaration.
	(dwarf2_read_symtab): New declaration.
	(dwarf2_psymtab_to_symtab): Delete.
	(dwarf2_read_symtab): Rename from dwarf2_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(create_partial_symtab): Caller update.
	* mdebugread.c (mdebug_psymtab_to_symtab): Delete.
	(mdebug_read_symtab): Rename from mdebug_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(parse_partial_symbols, new_psymtab): Caller update.
	* psympriv.h (struct partial_symtab) <read_symtab>: Exchange
	two parameters.
	* psymtab.c (psymtab_to_symtab): Caller update.
	* xcoffread.c (xcoff_psymtab_to_symtab): Delete.
	(xcoff_read_symtab): Rename from xcoff_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(xcoff_start_psymtab): Caller update.
@
text
@d1258 1
a1258 1
  last_source_file = NULL;
d2544 1
a2544 1
  last_source_file = NULL;
d2768 1
a2768 1
  if (last_source_file == NULL && type != (unsigned char) N_SO)
d2944 1
a2944 1
      if (last_source_file)
d3177 2
a3178 1
		    find_stab_function_addr (name, last_source_file, objfile);
@


1.139
log
@gdb/
2013-01-14  Yao Qi  <yao@@codesourcery.com>

	* dbxread.c (dbx_psymtab_to_symtab_1): Don't check PST is NULL.
	(dbx_psymtab_to_symtab): Likewise.
	* dwarf2read.c (dwarf2_psymtab_to_symtab): Likewise.
	* mdebugread.c (mdebug_psymtab_to_symtab): Likewise.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Likewise.
@
text
@d264 2
a265 1
static void dbx_psymtab_to_symtab (struct objfile *, struct partial_symtab *);
d2213 1
a2213 1
  result->read_symtab = dbx_psymtab_to_symtab;
d2456 1
a2456 1
   Be verbose about it if the user wants that.  PST is not NULL.  */
d2459 1
a2459 1
dbx_psymtab_to_symtab (struct objfile *objfile, struct partial_symtab *pst)
d2464 1
a2464 1
  if (pst->readin)
d2468 1
a2468 1
			  pst->filename);
d2472 1
a2472 1
  if (LDSYMLEN (pst) || pst->number_of_dependencies)
d2478 1
a2478 1
	  printf_filtered ("Reading in symbols for %s...", pst->filename);
d2498 1
a2498 1
      dbx_psymtab_to_symtab_1 (objfile, pst);
@


1.138
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a2408 3
  if (!pst)
    return;

d2455 1
a2455 1
   Be verbose about it if the user wants that.  */
a2462 3
  if (!pst)
    return;

@


1.137
log
@	* dbxread.c (read_dbx_symtab): Update.
	(end_psymtab, dbx_psymtab_to_symtab_1, dbx_psymtab_to_symtab)
	(read_ofile_symtab): Add 'objfile' argument.
	* dwarf2read.c (process_psymtab_comp_unit_reader)
	(build_type_psymtabs_reader): Update.
	(dwarf2_psymtab_to_symtab): Add 'objfile' argument.
	* mdebugread.c (mdebug_psymtab_to_symtab): Add 'objfile'
	argument.
	(parse_procedure, parse_partial_symbols): Update.
	(psymtab_to_symtab_1): Add 'objfile' argument.
	* psympriv.h (struct partial_symtab) <objfile>: Remove.
	<read_symtab>: Add 'objfile' argument.
	(sort_pst_symbols, discard_psymtab): Update.
	* psymtab.c (partial_map_expand_apply): Update.
	(find_pc_sect_psymtab_closer): Add 'objfile' argument.
	(find_pc_sect_psymtab, find_pc_sect_symtab_from_partial): Update.
	(find_pc_sect_psymbol): Add 'objfile' argument.
	(lookup_symbol_aux_psymtabs): Update.
	(match_partial_symbol, lookup_partial_symbol, psymtab_to_symtab):
	Add 'objfile' argument.
	(find_last_source_symtab_from_partial, dump_psymtab)
	(dump_psymtabs_for_objfile, read_symtabs_for_function)
	(expand_partial_symbol_tables, read_psymtabs_with_filename)
	(find_symbol_file_from_partial, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial): Update.
	(sort_pst_symbols): Add 'objfile' argument.
	(allocate_psymtab): Update.
	(discard_psymtab): Add 'objfile' argument.
	(maintenance_info_psymtabs, maintenance_check_symtabs): Update.
	* stabsread.h (end_psymtab): Update.
	* xcoffread.c (this_symtab_objfile): New global.
	(process_linenos, enter_line_range, xcoff_next_symbol_text):
	Update.
	(read_xcoff_symtab): Add 'objfile' argument.
	(read_symbol, read_symbol_lineno): Update.
	(xcoff_psymtab_to_symtab_1, xcoff_psymtab_to_symtab)
	(xcoff_end_psymtab): Add 'objfile' argument.
	(scan_xcoff_symtab): Update.
@
text
@d2 1
a2 1
   Copyright (C) 1986-2004, 2008-2012 Free Software Foundation, Inc.
@


1.136
log
@	* coffread.c (coff_symfile_init): Use set_objfile_data.
	(coff_symfile_read): Use DBX_SYMFILE_INFO.
	* dbxread.c (dbx_objfile_data_key): New global.
	(dbx_symfile_init): Use set_objfile_data.
	(dbx_symfile_finish): Don't free deprecated_sym_stab_info.
	(dbx_free_symfile_info): New function.
	(coffstab_build_psymtabs, elfstab_build_psymtabs): Use
	DBX_SYMFILE_INFO.
	(stabsect_build_psymtabs): Use set_objfile_data.
	(_initialize_dbxreadb): Initialize dbx_objfile_data_key.
	* elfread.c (elf_symtab_read): Use DBX_SYMFILE_INFO,
	set_objfile_data.
	(free_elfinfo): Use DBX_SYMFILE_INFO.
	(elf_symfile_finish): Don't free deprecated_sym_stab_info.
	(elfstab_offset_sections): Use DBX_SYMFILE_INFO.
	* gdb-stabs.h (dbx_objfile_data_key): Declare.
	(DBX_SYMFILE_INFO): Rewrite to use objfile_data.
	* objfiles.h (struct objfile) <deprecated_sym_stab_info>: Remove.
	* somread.c (som_symfile_finish): Don't free
	deprecated_sym_stab_info.
@
text
@d262 1
a262 1
static void read_ofile_symtab (struct partial_symtab *);
d264 1
a264 1
static void dbx_psymtab_to_symtab (struct partial_symtab *);
d266 1
a266 1
static void dbx_psymtab_to_symtab_1 (struct partial_symtab *);
d1391 2
a1392 2
		  end_psymtab (pst, psymtab_include_list, includes_used,
			       symnum * symbol_size,
d1510 2
a1511 2
		    end_psymtab (pst, psymtab_include_list, includes_used,
				 symnum * symbol_size,
d2121 1
a2121 1
	      end_psymtab (pst, psymtab_include_list, includes_used,
d2184 1
a2184 1
      end_psymtab (pst, psymtab_include_list, includes_used,
d2238 1
a2238 1
end_psymtab (struct partial_symtab *pst,
a2244 1
  struct objfile *objfile = pst->objfile;
d2379 1
a2379 1
  sort_pst_symbols (pst);
d2395 1
a2395 1
      discard_psymtab (pst);
d2404 1
a2404 1
dbx_psymtab_to_symtab_1 (struct partial_symtab *pst)
d2435 1
a2435 1
	dbx_psymtab_to_symtab_1 (pst->dependencies[i]);
d2448 2
a2449 2
      bfd_seek (pst->objfile->obfd, SYMBOL_OFFSET (pst), SEEK_SET);
      read_ofile_symtab (pst);
d2461 1
a2461 1
dbx_psymtab_to_symtab (struct partial_symtab *pst)
d2487 1
a2487 1
      sym_bfd = pst->objfile->obfd;
d2491 1
a2491 1
      if (DBX_STAB_SECTION (pst->objfile))
d2494 2
a2495 2
	    = symfile_relocate_debug_section (pst->objfile,
					      DBX_STAB_SECTION (pst->objfile),
d2503 1
a2503 1
      dbx_psymtab_to_symtab_1 (pst);
d2510 1
a2510 1
      scan_file_globals (pst->objfile);
d2521 1
a2521 1
read_ofile_symtab (struct partial_symtab *pst)
a2528 1
  struct objfile *objfile;
a2534 1
  objfile = pst->objfile;
@


1.135
log
@gdb/
2012-11-21  Yao Qi  <yao@@codesourcery.com>

	PR tdep/7438
	* gdbarch.sh (smash_text_address): Remove.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arm-tdep.c (arm_smash_text_address): Remove.
	(arm_gdbarch_init): Don't call set_gdbarch_smash_text_address.
	* hppa-tdep.c (hppa_smash_text_address): Remove.
	(hppa_addr_bits_remove): Rename from hppa_smash_text_address.
	(hppa_gdbarch_init): Don't call set_gdbarch_smash_text_address.
	Caller update.
	* coffread.c (coff_symtab_read): Caller update.
	* dbxread.c (process_one_symbol): Likewise.
	* elfread.c (record_minimal_symbol): Likewise.
	* somread.c (som_symtab_read): Likewise.
@
text
@d67 4
d631 1
d634 2
a635 4
  objfile->deprecated_sym_stab_info = (struct dbx_symfile_info *)
    xmalloc (sizeof (struct dbx_symfile_info));
  memset (objfile->deprecated_sym_stab_info, 0,
	  sizeof (struct dbx_symfile_info));
d743 9
a751 1
  if (objfile->deprecated_sym_stab_info != NULL)
d753 4
a756 1
      if (HEADER_FILES (objfile) != NULL)
d758 2
a759 9
	  int i = N_HEADER_FILES (objfile);
	  struct header_file *hfiles = HEADER_FILES (objfile);

	  while (--i >= 0)
	    {
	      xfree (hfiles[i].name);
	      xfree (hfiles[i].vector);
	    }
	  xfree (hfiles);
d761 1
a761 1
      xfree (objfile->deprecated_sym_stab_info);
d763 2
a764 1
  free_header_files ();
d766 1
d3359 1
a3359 1
  info = objfile->deprecated_sym_stab_info;
d3448 1
a3448 1
  info = objfile->deprecated_sym_stab_info;
d3527 1
d3540 2
a3541 4
  objfile->deprecated_sym_stab_info = (struct dbx_symfile_info *)
    xmalloc (sizeof (struct dbx_symfile_info));
  memset (objfile->deprecated_sym_stab_info, 0,
	  sizeof (struct dbx_symfile_info));
d3608 3
@


1.134
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@d2830 1
a2830 1
      valu = gdbarch_smash_text_address (gdbarch, valu);
@


1.133
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d3592 1
@


1.132
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1213 1
a1213 1
  char **psymtab_include_list;
d1235 2
a1236 2
  psymtab_include_list = (char **) alloca (includes_allocated *
					   sizeof (char *));
d1638 1
a1638 1
		char **orig = psymtab_include_list;
d1640 2
a1641 2
		psymtab_include_list = (char **)
		  alloca ((includes_allocated *= 2) * sizeof (char *));
d1643 1
a1643 1
			includes_used * sizeof (char *));
d2229 2
a2230 1
end_psymtab (struct partial_symtab *pst, char **include_list, int num_includes,
@


1.131
log
@Update the copyright header of various files...

... to follow the correct syntax (according to the gospel of
gnulib's update-copyright). In other words:
  - no comma after the last year;
  - FSF spelled exactly "Free Software Foundation, Inc.", with
    the comma and the period at the end.

sim/common/ChangeLog:

	* dv-sockser.h, sim-assert.h, sim-fpu.c: Reformat the copyright
	header.

sim/m32c/ChangeLog:

	* blinky.S, gloss.S, sample.S: Reformat copyright header.

sim/mn10300/ChangeLog:

	* sim-main.h: Reformat copyright header.

sim/ppc/ChangeLog:

	* dp-bit.c: Reformat copyright header.

gdb/ChangeLog:

        * gdb/common/gdb_thread_db.h, gdb/dbxread.c, gdb/environ.c,
        gdb/gcore.h, gdb/rs6000-tdep.h, gdb/s390-nat.c, gdb/tic6x-tdep.c:
        Reformat the copyright header.

gdb/gdbserver/ChangeLog:

	* terminal.h: Reformat copyright header.

gdb/testsuite/ChangeLog:

	* dg-extract-results.sh, gdb.arch/gcore.c, gdb.arch/gdb1558.c,
	gdb.arch/i386-gnu-cfi.c, gdb.base/complex.c, gdb.base/cvexpr.c,
	gdb.base/gcore.c, gdb.base/gdb1555-main.c, gdb.base/gdb1555.c,
	gdb.base/gdb1821.c, gdb.base/long_long.c, gdb.base/restore.c,
	gdb.base/sepdebug.c, gdb.base/type-opaque-lib.c,
	gdb.base/type-opaque-main.c, gdb.cp/maint.exp, gdb.cp/namespace1.cc,
	gdb.cp/pr9631.cc, gdb.cp/psmang1.cc, gdb.cp/psmang2.cc,
	gdb.cp/try_catch.cc, gdb.cp/virtfunc.cc, gdb.hp/gdb.base-hp/reg.exp,
	gdb.mi/basics.c, gdb.mi/mi-stack.c, gdb.mi/mi-var-child.c,
	gdb.mi/mi2-var-child.exp, gdb.mi/var-cmd.c,
	gdb.threads/thread_check.c: Reformat copyright header.
@
text
@d2 1
a2 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.130
log
@	* valops.c (find_overload_match): Call do_cleanups before early
	return.
	* top.c (execute_command): Call do_cleanups before early return.
	(command_loop): Likewise.
	* stack.c (backtrace_command): Make a null cleanup early.  Don't
	conditionally call do_cleanups.
	* python/py-value.c (TRY_CATCH): Move cleanup handling into
	TRY_CATCH.
	* python/py-breakpoint.c (gdbpy_breakpoint_has_py_cond): Rearrange
	so cleanups are always run.
	* mi/mi-cmd-var.c (mi_cmd_var_delete): Reset old_cleanups.
	* findcmd.c (parse_find_args): Call do_cleanups on early return
	path.
	* dbxread.c (elfstab_build_psymtabs): Make a null cleanup early.
	Don't conditionally call do_cleanups.
	* cli/cli-script.c (execute_user_command): Initialize 'old_chain'
	later.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2008, 2009, 2010, 2011.
@


1.130.2.1
log
@Update the copyright header of various files...

... to follow the correct syntax (according to the gospel of
gnulib's update-copyright). In other words:
  - no comma after the last year;
  - FSF spelled exactly "Free Software Foundation, Inc.", with
    the comma and the period at the end.

sim/common/ChangeLog:

	* dv-sockser.h, sim-assert.h, sim-fpu.c: Reformat the copyright
	header.

sim/m32c/ChangeLog:

	* blinky.S, gloss.S, sample.S: Reformat copyright header.

sim/mn10300/ChangeLog:

	* sim-main.h: Reformat copyright header.

sim/ppc/ChangeLog:

	* dp-bit.c: Reformat copyright header.

gdb/ChangeLog:

        * gdb/common/gdb_thread_db.h, gdb/dbxread.c, gdb/environ.c,
        gdb/gcore.h, gdb/rs6000-tdep.h, gdb/s390-nat.c, gdb/tic6x-tdep.c:
        Reformat the copyright header.

gdb/gdbserver/ChangeLog:

	* terminal.h: Reformat copyright header.

gdb/testsuite/ChangeLog:

	* dg-extract-results.sh, gdb.arch/gcore.c, gdb.arch/gdb1558.c,
	gdb.arch/i386-gnu-cfi.c, gdb.base/complex.c, gdb.base/cvexpr.c,
	gdb.base/gcore.c, gdb.base/gdb1555-main.c, gdb.base/gdb1555.c,
	gdb.base/gdb1821.c, gdb.base/long_long.c, gdb.base/restore.c,
	gdb.base/sepdebug.c, gdb.base/type-opaque-lib.c,
	gdb.base/type-opaque-main.c, gdb.cp/maint.exp, gdb.cp/namespace1.cc,
	gdb.cp/pr9631.cc, gdb.cp/psmang1.cc, gdb.cp/psmang2.cc,
	gdb.cp/try_catch.cc, gdb.cp/virtfunc.cc, gdb.hp/gdb.base-hp/reg.exp,
	gdb.mi/basics.c, gdb.mi/mi-stack.c, gdb.mi/mi-var-child.c,
	gdb.mi/mi2-var-child.exp, gdb.mi/var-cmd.c,
	gdb.threads/thread_check.c: Reformat copyright header.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2008, 2009, 2010, 2011
@


1.130.2.2
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 3
a4 1
   Copyright (C) 1986-2004, 2008-2012 Free Software Foundation, Inc.
@


1.129
log
@	* coffread.c (coffread_objfile): Rename from current_objfile.
	* dbxread.c (dbxread_objfile): Rename from current_objfile.
	* mdebugread.c (mdebugread_objfile): Rename from current_objfile.
@
text
@d3436 1
a3436 1
  struct cleanup *back_to = NULL;
d3480 1
a3480 1
    back_to = make_cleanup (free_current_contents, (void *) &stabs_data);
d3490 1
a3490 2
  if (back_to)
    do_cleanups (back_to);
@


1.128
log
@	* symtab.h (current_objfile): Don't declare.
	* objfiles.h (current_objfile): Don't declare.
	* objfiles.c (current_objfile): Remove.
	* mdebugread.c (current_objfile): New file-scope global.
	* dbxread.c (current_objfile): New file-scope global.
	* coffread.c (current_objfile): New file-scope global.
@
text
@d110 1
a110 1
static struct objfile *current_objfile;
d350 1
a350 1
  struct header_file *p = HEADER_FILES (current_objfile);
d353 1
a353 1
  for (i = 0; i < N_HEADER_FILES (current_objfile); i++)
d381 1
a381 1
  i = N_ALLOCATED_HEADER_FILES (current_objfile);
d383 1
a383 1
  if (N_HEADER_FILES (current_objfile) == i)
d387 2
a388 2
	  N_ALLOCATED_HEADER_FILES (current_objfile) = 10;
	  HEADER_FILES (current_objfile) = (struct header_file *)
d394 3
a396 3
	  N_ALLOCATED_HEADER_FILES (current_objfile) = i;
	  HEADER_FILES (current_objfile) = (struct header_file *)
	    xrealloc ((char *) HEADER_FILES (current_objfile),
d403 2
a404 2
  i = N_HEADER_FILES (current_objfile)++;
  hfile = HEADER_FILES (current_objfile) + i;
d419 1
a419 1
  struct header_file *f = &HEADER_FILES (current_objfile)[real_filenum];
d2540 1
a2540 1
  current_objfile = objfile;
d2705 1
a2705 1
  current_objfile = NULL;
@


1.127
log
@2011-03-23  Kai Tietz  <ktietz@@redhat.com>

	* breakpoint.c (clear_command): Use filename_cmp
	instead of strcmp for comparison.
	* buildsym.c (watch_main_source_file_lossage): Likewise.
	(patch_subfile_names): Use IS_DIR_SEPARATOR instead of
	checking just for slash.
	* dbxread.c (read_dbx_symtab): Use lbasename instead of
	strrchr and filename_cmp instead of strcmp for filenames.
	(add_old_header_file): Use filename_cmp
	instead of strcmp for comparison.
	* exec.c (exec_set_section_address): Likewise.
	* macrotab.c (macro_lookup_inclusion): Likewise.
	(macro_lookup_inclusion): Likewise.
	* elfread.c (_initialize_elfread): Likewise.
	(elfstab_offset_sections): Likewise.
	(elfstab_offset_sections): Use lbasename instead of
	strrchr.
	* mdebugread.c (parse_partial_symbols): Likewise.
	(arse_partial_symbols): Use filename_(n)cmp instead of
	str(n)cmp for comparison.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* psymtab.c (read_psymtabs_with_filename): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	(reload_shared_libraries_1): Likewise.
	* symmisc.c (maintenance_print_symbols): Likewise.
	* symfile.c (separate_debug_file_exists): Likewise.
	(reread_symbols): Likewise.
	(find_separate_debug_file_by_debuglink): Likewise.
	* remote-fileio.c (remote_fileio_func_rename): Likewise.
	* source.c (add_path): Likewise.
	* symtab.c (filename_seen): Likewise.
	(file_matches): Likewise.
	(print_symbol_info): Likewise.
	(maybe_add_partial_symtab_filename): Likewise.
	(make_source_files_completion_list): Likewise.
	* xml-syscall.c (init_sysinfo): Likewise.
	* windows-nat.c (_initialize_check_for_gdb_ini): Use
	IS_DIR_SEPARATOR for checking for trailing path separator.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2008, 2009, 2010.
d108 4
@


1.126
log
@delete target_ops.to_lookup_symbol

gdb/ChangeLog:

        * target.h (struct target_ops): Remove to_lookup_symbol field.
        (target_lookup_symbol): Delete macro.
        * target.c (nosymbol, debug_to_lookup_symbol): Delete.
        (update_current_target, setup_target_debug): Remove handling
        of to_lookup_symbol target_ops field.
        * ada-tasks.c (get_known_tasks_addr): Remove use of
        target_lookup_symbol.
        * coffread.c (coff_symtab_read): Likewise.
        * dbxread.c (read_dbx_symtab): Ditto.
@
text
@d50 1
d350 1
a350 1
    if (strcmp (p[i].name, name) == 0 && instance == p[i].instance)
d1469 1
a1469 1
	    char *p;
d1526 2
a1527 2
	    p = strrchr (namestring, '/');
	    if (p && *(p + 1) == '\000')
d1616 1
a1616 1
	    if (pst && strcmp (namestring, pst->filename) == 0)
d1622 1
a1622 1
		if (strcmp (namestring, psymtab_include_list[i]) == 0)
@


1.125
log
@2011-03-04  Michael Snyder  <msnyder@@msnyder-server.eng.vmware.com>

	* dbxread.c (process_one_symbol): Assert 'name' is not null.
@
text
@d1404 6
a1409 4
	  if (nlist.n_value != 0)
	    {
	      /* This is a "Fortran COMMON" symbol.  See if the target
		 environment knows where it has been relocated to.  */
d1411 3
a1413 13
	      CORE_ADDR reladdr;

	      namestring = set_namestring (objfile, &nlist);
	      if (target_lookup_symbol (namestring, &reladdr))
		{
		  continue;	/* Error in lookup; ignore symbol for now.  */
		}
	      nlist.n_type ^= (N_BSS ^ N_UNDF);	/* Define it as a
						   bss-symbol.  */
	      nlist.n_value = reladdr;
	      goto bss_ext_symbol;
	    }
	  continue;		/* Just undefined, not COMMON.  */
@


1.124
log
@	* xcoffread.c (xcoff_sym_fns): Update.
	* symfile.h (struct sym_fns) <sym_read_psymbols>: New field.
	(enum symfile_add_flags) <SYMFILE_NO_READ>: New constant.
	* symfile.c (syms_from_objfile): Handle SYMFILE_NO_READ.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	(reread_symbols): Handle OBJF_PSYMTABS_READ.
	* somread.c (som_sym_fns): Update.
	* psymtab.h (require_partial_symbols): Declare.
	* psymtab.c (require_partial_symbols): New function.
	(ALL_OBJFILE_PSYMTABS_REQUIRED): New macro.
	(ALL_OBJFILE_PSYMTABS): Undef.
	(ALL_PSYMTABS): Move from psympriv.h.
	(lookup_partial_symtab, find_pc_sect_psymtab)
	(lookup_symbol_aux_psymtabs, relocate_psymtabs)
	(find_last_source_symtab_from_partial)
	(forget_cached_source_info_partial)
	(print_psymtab_stats_for_objfile, read_symtabs_for_function)
	(expand_partial_symbol_tables, read_psymtabs_with_filename)
	(map_symbol_names_psymtab, map_symbol_filenames_psymtab)
	(find_symbol_file_from_partial, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial, maintenance_info_psymtabs):
	Use ALL_OBJFILE_PSYMTABS_REQUIRED.
	* psympriv.h (ALL_PSYMTABS): Move to psymtab.c.
	* objfiles.h (OBJF_PSYMTABS_READ): New macro.
	* objfiles.c (objfile_has_partial_symbols): Handle lazily-read
	psymtabs.
	* mipsread.c (ecoff_sym_fns): Update.
	* machoread.c (macho_sym_fns): Update.
	* elfread.c (elf_symfile_read): Set up for lazy psymtab reading.
	(read_psyms): New function.
	(elf_sym_fns, elf_sym_fns_gdb_index): Update.
	(elf_sym_fns_lazy_psyms): New global.
	* dwarf2read.c (dwarf2_initialize_objfile): Don't call
	dwarf2_build_psymtabs.
	* dbxread.c (aout_sym_fns): Update.
	* coffread.c (coff_sym_fns): Update.
@
text
@d3292 1
@


1.123
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* dbxread.c (read_dbx_symtab): Discard unused value.
@
text
@d3590 1
@


1.122
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* dbxread.c (process_one_symbol): Discard unused value.
@
text
@d1731 1
a1731 2
		namestring = gdbarch_static_transform_name (gdbarch,
							    namestring);
@


1.121
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d2856 1
a2856 1
      new = push_context (desc, valu);
@


1.120
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d1315 1
a1315 1
         *) The addition of a partial symbol the the two partial
@


1.119
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d64 2
a65 1
#include "aout/stab_gnu.h"	/* We always use GNU stabs, not native, now */
d107 1
a107 1
/* Remember what we deduced to be the source language of this psymtab. */
d121 1
a121 1
/* This is the offset of the symbol table in the executable file. */
d125 1
a125 1
/* This is the offset of the string table in the executable file. */
d133 1
a133 1
   the current and next .o files. */
d140 1
a140 1
   Solaris elf+stab text addresses at location 0. */
d237 1
a237 1
   partial symbol table. */
d244 1
a244 1
				   BINCL/EINCL defs for this file */
d247 1
a247 1
/* The actual list and controling variables */
d251 1
a251 1
/* Local function prototypes */
d298 1
a298 1
/* Free up old header file tables */
d311 1
a311 1
/* Allocate new header file tables */
d572 1
a572 1
  /* Read stabs data from executable file and define symbols. */
d581 1
a581 1
     minimal symbols for this objfile. */
d611 1
a611 1
   be called unless this is an a.out (or very similar) file. 
d625 1
a625 1
  /* Allocate struct to keep track of the symfile */
d635 1
a635 1
  /* FIXME POKING INSIDE BFD DATA STRUCTURES */
d639 1
a639 1
  /* FIXME POKING INSIDE BFD DATA STRUCTURES */
d664 1
a664 1
     the bytes used to hold the size are included in the count. */
d670 1
a670 1
         would appear to be a bug in bfd. */
d690 1
a690 1
	     from EOF will read zero bytes. */
d702 1
a702 1
	     or may not catch this. */
d732 1
a732 1
   objfile struct from the global list of known objfiles. */
d1158 1
a1158 1
      /* Try again without the filename. */
d1164 1
a1164 1
      /* And try again for Sun Fortran, but without the filename. */
d1183 1
a1183 1
   debugging information is available. */
d1189 1
a1189 1
  struct external_nlist *bufp = 0;	/* =0 avoids gcc -Wall glitch */
d1206 1
a1206 1
  /* Current partial symtab */
d1209 1
a1209 1
  /* List of current psymtab's include files */
d1214 1
a1214 1
  /* Index within current psymtab dependency list */
d1249 1
a1249 1
  symfile_bfd = objfile->obfd;	/* For next_text_symbol */
d1290 2
a1291 2
      /* Get the symbol for this run and pull out some info */
      QUIT;			/* allow this to be interruptable */
d1317 1
a1317 2
         I've imbedded it in the following macro.
      */
d1354 1
a1354 1
	  /* Standard, local, non-debugger, symbols */
d1416 2
a1417 1
	      nlist.n_type ^= (N_BSS ^ N_UNDF);	/* Define it as a bss-symbol */
d1421 1
a1421 1
	  continue;			/* Just undefined, not COMMON */
d1449 1
a1449 1
	  /* Keep going . . . */
d1486 1
a1486 1
	       compiler. end_psymtab explicitly tests for zero, so
d1501 1
a1501 1
	      {			/* Here if prev stab wasn't N_SO */
d1520 1
a1520 1
	    /* End the current partial symtab and start a new one */
d1524 1
a1524 1
	    /* Null name means end of .o file.  Don't start a new one. */
d1531 1
a1531 1
	       we assume the previous N_SO was a directory name. */
d1537 1
a1537 1
		   the psymtab when it's created below. */
d1565 1
a1565 1
	       read_dbx_symtab function returns */
d1591 1
a1591 1
	    /* Mark down an include file in the current psymtab */
d1600 1
a1600 1
	    /* Mark down an include file in the current psymtab */
d1615 1
a1615 1
	       and from inline functions in other files. So I check to see
d1652 2
a1653 2
	case N_LSYM:		/* Typedef or automatic variable. */
	case N_STSYM:		/* Data seg var -- static  */
d1667 1
a1667 1
	case N_M2C:		/* I suspect that I can ignore this here. */
d1690 1
a1690 1
	    continue;			/* Not a debugging symbol.   */
d1745 1
a1745 1
		 wrong.  See the code that reads 'G's for symtabs. */
d1783 1
a1783 1
	      if (p != namestring)	/* a name is there, not just :T... */
d1884 1
a1884 1
	      /* Kludges for ELF/STABS with Sun ACC */
d1887 1
a1887 1
		 value for the bottom of the text seg in those cases. */
d1901 1
a1901 1
		     with... */
d1954 1
a1954 1
	      /* Kludges for ELF/STABS with Sun ACC */
d1957 1
a1957 1
		 value for the bottom of the text seg in those cases. */
d1971 1
a1971 1
		     with... */
d2024 1
a2024 1
	    case '#':	/* for symbol identification (used in live ranges) */
d2060 1
a2060 1
	     psymtab dependency list */
d2139 1
a2139 1
	case N_ENTRY:		/* Alternate entry point; can ignore. */
d2142 1
a2142 1
	case N_EHDECL:		/* that can safely be ignored here. */
d2156 1
a2156 1
	case N_OBJ:		/* useless types from Solaris */
d2159 1
a2159 2
	  /* These symbols aren't interesting; don't worry about them */

d2195 1
a2195 1
   (normal). */
d2223 1
a2223 1
  /* Deduce the source language from the filename for this psymtab. */
d2229 1
a2229 1
/* Close off the current usage of PST.  
d2297 1
a2297 1
  /* this test will be true if the last .o file is only data */
d2315 2
a2316 1
	    /* if this file has only data, then make textlow match texthigh */
d2349 1
a2349 1
      /* Copy the sesction_offsets array from the main psymtab. */
d2411 2
a2412 2
      fprintf_unfiltered (gdb_stderr, "Psymtab for %s already read in.  \
Shouldn't happen.\n",
d2417 1
a2417 1
  /* Read in all partial symtabs on which this one is dependent */
d2429 1
a2429 1
	    wrap_here ("");	/* Flush output */
d2435 1
a2435 1
  if (LDSYMLEN (pst))		/* Otherwise it's a dummy */
d2444 1
a2444 1
      /* Read in this file's symbols */
d2468 2
a2469 2
      fprintf_unfiltered (gdb_stderr, "Psymtab for %s already read in.  \
Shouldn't happen.\n",
d2515 1
a2515 1
/* Read in a defined section of a specific object file's symbols. */
d2541 1
a2541 1
     objfile->section_offsets. */ 
d2551 1
a2551 1
  symfile_bfd = objfile->obfd;	/* Implicit param to next_text_symbol */
d2588 1
a2588 1
         producer. */
d2623 1
a2623 1
      QUIT;			/* Allow this to be interruptable */
d2653 1
a2653 1
         happen in this routine. */
d2683 1
a2683 1
	     different files with the same name. */
d2686 2
a2687 2
	     be satisfied in each file as it appears. So we skip this
	     section. */
d2694 1
a2694 1
     which comes from pst->textlow is correct. */
d2750 1
a2750 1
     value is. */
d2953 1
a2953 1
	     name.  Patch things up. */
d2957 1
a2957 1
	      break;		/* Ignore repeated SOs */
d3272 1
a3272 1
	 arbitrarily. (kingdon) */
d3338 1
a3338 1
   adjusted for coff details. */
d3387 1
a3387 1
     incremental load here. */
d3429 1
a3429 1
   adjusted for elf details. */
d3510 2
a3511 1
   This routine is mostly copied from dbx_symfile_init and dbx_symfile_read. */
d3531 2
a3532 2
    error (_("stabsect_build_psymtabs:  Found stabs (%s), but not string \
section (%s)"),
d3579 1
a3579 1
  /* Now, do an incremental load */
d3588 8
a3595 10
  dbx_new_init,		/* sym_new_init: init anything gbl to entire symtab */
  dbx_symfile_init,	/* sym_init: read initial info, setup for sym_read() */
  dbx_symfile_read,		/* sym_read: read a symbol file into symtab */
  dbx_symfile_finish,		/* sym_finish: finished with file, cleanup */
  default_symfile_offsets, /* sym_offsets: parse user's offsets to
			      internal form */
  default_symfile_segments,	/* sym_segments: Get segment information from
				   a file.  */
  NULL,                         /* sym_read_linetable */
  default_symfile_relocate,	/* sym_relocate: Relocate a debug section.  */
@


1.118
log
@	* symfile.h (allocate_symtab): Update.
	* symfile.c (allocate_symtab): Make 'filename' const.
	* psymtab.c (add_psymbol_to_bcache): Make 'name' const.
	(add_psymbol_to_list): Likewise.
	* psympriv.h (struct partial_symtab) <filename, dirname>: Now
	const.
	(add_psymbol_to_list): Update.
	* mdebugread.c (new_symtab): Make 'name' const.
	(psymtab_to_symtab_1): Make 'filename' const.
	* elfread.c (elfstab_offset_sections): Update.
	* dwarf2read.c (dwarf_decode_lines): Make 'comp_dir' const.
	(dwarf2_start_subfile): Make 'dirname' and 'comp_dir' const.
	(psymtab_include_file_name): Update.
	* dbxread.c (find_stab_function_addr): Make 'filename' const.
	* buildsym.h (start_subfile): Update.
	* buildsym.c (start_subfile): Make arguments const.
@
text
@d180 2
a181 2
	     _("\"repeated\" header file %s not previously seen, at symtab \
pos %d"),
d971 2
a972 1
      complaint (&symfile_complaints, _("bad string table offset in symbol %d"),
d1176 2
a1177 2
	     _("function `%s' appears to be defined outside of all compilation \
units"),
d1583 2
a1584 2
			   _("N_BINCL %s not in entries for any file, at symtab \
pos %d"),
d2044 2
a2045 1
	      complaint (&symfile_complaints, _("unknown symbol descriptor `%c'"),
d2099 2
a2100 1
					"Had to reallocate dependency list.\n");
d2119 2
a2120 2
			   (CORE_ADDR) 0,
			   dependency_list, dependencies_used, textlow_not_set);
d2890 3
a2892 3
	  complaint (&symfile_complaints, _("\
misplaced N_LBRAC entry; discarding local symbols which have \
no enclosing block"));
d3548 3
a3550 1
  DBX_SYMTAB_OFFSET (objfile) = stabsect->filepos;	/* XXX - FIXME: POKING INSIDE BFD DATA STRUCTURES */
d3556 2
a3557 1
    obstack_alloc (&objfile->objfile_obstack, DBX_STRINGTAB_SIZE (objfile) + 1);
d3565 3
a3567 2
				  0,	/* offset into section */
				  DBX_STRINGTAB_SIZE (objfile)); /* amount to read */
@


1.117
log
@	* symfile.h (struct sym_fns) <next>: Remove.
	(add_symtab_fns): Update.
	* symfile.c (sym_fns_ptr): New typedef.
	(symtab_fns): Now a VEC.
	(add_symtab_fns): Update.  Change argument type.
	(find_sym_fns): Update.  Change return type.
	(get_symfile_segment_data): Update.
	* objfiles.h (struct objfile) <sf>: Now const.
	* somread.c (som_sym_fns): Now const.  Update.
	* xcoffread.c (xcoff_sym_fns): Now const.  Update.
	* mipsread.c (ecoff_sym_fns): Now const.  Update.
	* machoread.c (macho_sym_fns): Now const.  Update.
	* elfread.c (elf_sym_fns): Now const.  Update.
	(elf_sym_fns_gdb_index): Likewise.
	* dbxread.c (aout_sym_fns): Now const.  Update.
	* coffread.c (coff_sym_fns): Now const.  Update.
@
text
@d1128 1
a1128 1
find_stab_function_addr (char *namestring, char *filename,
@


1.116
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* dbxread.c: White space.
	* dcache.c: White space.
	* disasm.c: White space.
	* doublest.c: White space.
	* dsrec.c: White space.
	* dummy-frame.c: White space.
	* dwarf2expr.c: White space.
	* dwarf2-frame.c: White space.
	* dwarf2loc.c: White space.
	* dwarf2read.c: White space.
@
text
@d3576 1
a3576 1
static struct sym_fns aout_sym_fns =
d3589 1
a3589 2
  &psym_functions,
  NULL				/* next: pointer to next struct sym_fns */
@


1.115
log
@	* xcoffread.c (xcoff_start_psymtab): Update.
	(xcoff_end_psymtab): Update.
	* psymtab.c (allocate_psymtab): Remove dead code.
	* psympriv.h (struct partial_symtab) <read_symtab_private>: Now
	void*.
	* mdebugread.c (parse_partial_symbols): Update.
	(new_psymtab): Likewise.
	* dwarf2read.c (process_psymtab_comp_unit): Update.
	(psymtab_to_symtab_1): Update.
	* dbxread.c (start_psymtab): Update.
	(end_psymtab): Likewise.
@
text
@d493 1
d814 1
d907 1
d1097 2
a1098 2
      rel->address + ANOFFSET (objfile->section_offsets,
			       SECT_OFF_DATA (objfile));
d1560 1
d1597 1
a1598 1

d1625 1
d1696 1
d1874 1
d1894 1
d1944 1
d1964 1
d2087 1
d2200 2
a2201 2
  start_psymtab_common (objfile, objfile->section_offsets,
			filename, textlow, global_syms, static_syms);
d2343 1
a2343 1
      allocate_psymtab (include_list[i], objfile);
d2490 1
d2673 1
a2673 2
	       || type == (unsigned char) N_NBTEXT
	)
d2801 1
d3022 1
d3157 1
@


1.114
log
@gdb
	* xcoffread.c: Include psymtab.h.
	(xcoff_sym_fns): Update.
	* symtab.h (struct partial_symbol): Remove.
	(PSYMBOL_DOMAIN, PSYMBOL_CLASS): Remove.
	(struct partial_symtab): Remove.
	(PSYMTAB_TO_SYMTAB): Remove.
	(lookup_partial_symbol, lookup_partial_symtab, find_pc_psymtab)
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): Declare.
	(find_pc_psymtab, find_pc_sect_psymbol, psymtab_to_symtab)
	(find_main_psymtab): Remove.
	(find_main_filename): Declare.
	(fixup_psymbol_section): Remove.
	(fixup_section): Declare.
	* symtab.c: Include psymtab.h.
	(lookup_symtab): Use lookup_symtab method.
	(lookup_partial_symtab): Remove.
	(find_pc_sect_psymtab_closer): Remove.
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): New function.
	(find_pc_psymtab, find_pc_sect_psymbol, find_pc_psymbol): Remove.
	(fixup_section): No longer static.
	(fixup_psymbol_section): Remove.
	(lookup_symbol_aux): Use lookup_symbol_aux_quick.
	(lookup_global_symbol_from_objfile): Likewise.
	(lookup_symbol_aux_psymtabs): Remove.
	(lookup_symbol_aux_quick): New function.
	(lookup_symbol_global): Use lookup_symbol_aux_quick.
	(lookup_partial_symbol): Remove.
	(basic_lookup_transparent_type_quick): New function.
	(basic_lookup_transparent_type): Use it.
	(find_main_psymtab): Remove.
	(find_main_filename): New function.
	(find_pc_sect_symtab): Use find_pc_sect_symtab method.
	(find_line_symtab): Use expand_symtabs_with_filename method.
	(output_partial_symbol_filename): New function.
	(sources_info): Use map_partial_symbol_filenames.
	(struct search_symbols_data): New type.
	(search_symbols_file_matches): New function.
	(search_symbols_name_matches): Likewise.
	(search_symbols): Use expand_symtabs_matching method.
	(struct add_name_data): Rename from add_macro_name_data.
	(add_macro_name): Update.
	(add_partial_symbol_name): New function.
	(default_make_symbol_completion_list): Use
	map_partial_symbol_names.
	(struct add_partial_symbol_name): New type.
	(maybe_add_partial_symtab_filename): New function.
	(make_source_files_completion_list): Use
	map_partial_symbol_filenames.
	(expand_line_sal): Use expand_symtabs_with_filename method.
	* symmisc.c: Include psymtab.h.
	(print_objfile_statistics): Use print_stats method.
	(dump_objfile): Use dump method.
	(dump_psymtab, maintenance_print_psymbols)
	(maintenance_info_psymtabs, maintenance_check_symtabs)
	(extend_psymbol_list): Remove.
	* symfile.h (struct quick_symbol_functions): New struct.
	(struct sym_fns) <qf>: New field.
	(sort_pst_symbols): Remove.
	(increment_reading_symtab): Declare.
	* symfile.c: Include psymtab.h.
	(compare_psymbols, sort_pst_symbols): Remove.
	(psymtab_to_symtab): Remove.
	(increment_reading_symtab): New function.
	(symbol_file_add_with_addrs_or_offsets): Use expand_all_symtabs
	method.
	(set_initial_language): Use find_main_filename.
	(allocate_psymtab, discard_psymtab, cashier_psymtab): Remove.
	(free_named_symtabs): Remove unused code.
	(start_psymtab_common, add_psymbol_to_bcache)
	(append_psymbol_to_list, add_psymbol_to_list, init_psymbol_list):
	Remove.
	* stack.c: Include psymtab.h, symfile.h.
	(backtrace_command_1): Use find_pc_sect_symtab_via_partial.
	* source.h (psymtab_to_fullname): Don't declare.
	* source.c: Include psymtab.h.
	(select_source_symtab): Use find_last_source_symtab method.
	(forget_cached_source_info): Use forget_cached_source_info
	method.
	(find_and_open_source): No longer static.
	(psymtab_to_fullname): Remove.
	* somread.c: Include psymtab.h.
	(som_sym_fns): Update.
	* psympriv.h: New file.
	* psymtab.h: New file.
	* psymtab.c: New file.
	* objfiles.h: (ALL_OBJFILE_PSYMTABS): Remove.
	(ALL_PSYMTABS, ALL_PSPACE_PSYMTABS): Likewise.
	* objfiles.c: Include psymtab.h.
	(objfile_relocate1): Use relocate method.
	(objfile_has_partial_symbols): Use has_symbols method.
	* mipsread.c: Include psymtab.h.
	(ecoff_sym_fns): Update.
	* mi/mi-cmd-file.c: Include psymtab.h.
	(print_partial_file_name): New function.
	(mi_cmd_file_list_exec_source_files): Use
	map_partial_symbol_filenames.
	* mdebugread.c: Include psympriv.h.
	* machoread.c: Include psympriv.h.
	(macho_sym_fns): Update.
	* m2-exp.y (yylex): Use lookup_symtab.
	* elfread.c: Include psympriv.h.
	(elf_sym_fns): Update.
	* dwarf2read.c: Include psympriv.h.
	* dbxread.c: Include psympriv.h.
	(aout_sym_fns): Update.
	* cp-support.c: Include psymtab.h.
	(read_in_psymtabs): Remove.
	(make_symbol_overload_list_qualified): Use
	expand_symtabs_for_function method.
	* coffread.c: Include psympriv.h.
	(coff_sym_fns): Update.
	* blockframe.c: Include psymtab.h.
	(find_pc_partial_function): Use find_pc_sect_symtab method.
	* ada-lang.h (ada_update_initial_language): Update.
	* ada-lang.c: Include psymtab.h.
	(ada_update_initial_language): Remove 'main_pst' argument.
	(ada_lookup_partial_symbol): Remove.
	(struct ada_psym_data): New type.
	(ada_add_psyms): New function.
	(ada_add_non_local_symbols): Use map_ada_symtabs method.
	(struct add_partial_datum): New type.
	(ada_add_partial_symbol_completions): New function.
	(ada_make_symbol_completion_list): Use map_partial_symbol_names.
	(ada_exception_support_info_sniffer): Update.
	* Makefile.in (SFILES): Add psymtab.c.
	(COMMON_OBS): Add psymtab.o.
	(HFILES_NO_SRCDIR): Add psymtab.h, psympriv.h.
gdb/doc
	* gdbint.texinfo (Symbol Handling): Update.
@
text
@d2192 2
a2193 2
  result->read_symtab_private = (char *)
    obstack_alloc (&objfile->objfile_obstack, sizeof (struct symloc));
d2337 1
a2337 2
	(char *) obstack_alloc (&objfile->objfile_obstack,
				sizeof (struct symloc));
@


1.113
log
@2010-02-03  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct sym_fns): Add sym_relocate field.
	(default_symfile_relocate): New prototype.
	(symfile_relocate_debug_section): First argument is now an objfile.
	* symfile.c (default_symfile_relocate): Rename from
	symfile_relocate_debug_section, first argument is now an objfile.
	(symfile_relocate_debug_section): New function.
	* coffread.c (coff_sym_fns): Set sym_relocate field.
	* somread.c (som_sym_fns): Ditto.
	* mipsread.c (ecoff_sym_fns): Ditto.
	* machoread.c (macho_sym_fns): Ditto.
	* elfread.c (elf_sym_fns): Ditto.
	* dwarf2read.c (dwarf2_read_section): Ditto.
	* xcoffread.c (xcoff_sym_fns): Ditto.
	* dbxread.c (aout_sym_fns): Ditto.
	(dbx_psymtab_to_symtab): Adjust call to symfile_relocate_debug_section.
	(elfstab_build_psymtabs): Ditto.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2008, 2009.
d58 1
d3576 1
@


1.112
log
@Delete free_named_symtabs and associated cleanup.

        * symfile.h (free_named_symtabs): Delete declaration.
        * symfile.c: Remove some commented out code (clear_symtab_users_once).
        (cashier_psymtab): Comment function out.
        Delete declaration.
        (free_named_symtabs): Delete.
        * coffread.c (coff_end_symtab): Remove call to free_named_symtabs.
        * dbxread.c (end_psymtab): Likewise.
        * dwarf2read.c (process_psymtab_comp_unit): Ditto.
        * exec.c (exec_close_1): Ditto.
        * xcoffread.c (xcoff_end_psymtab): Likewise.
@
text
@d2476 1
a2476 1
	    = symfile_relocate_debug_section (pst->objfile->obfd,
d3463 1
a3463 1
  stabs_data = symfile_relocate_debug_section (objfile->obfd, stabsect, NULL);
d3574 1
@


1.111
log
@2009-12-07  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct sym_fns): Adjust comment on sym_read.
	* symfile.c (syms_from_objfile): Pass all symfile flags to sym_read.
	* dbxread.c (dbx_symfile_read): Rename mainline to symfile_flags,
	adjust header comment.
	* elfread.c (elf_symfile_read): Ditto.
	* somread.c (som_symfile_read): Ditto.
	* xcoffread.c (xcoff_initial_scan): Ditto.
	* coffread.c (coff_symfile_read): Rename mainline to symfile_flags.
	* machoread.c (macho_symfile_read): Ditto.
	* mipsread.c (mipscoff_symfile_read): Ditto.
@
text
@a2362 5
  /* If there is already a psymtab or symtab for a file of this name, remove it.
     (If there is a symtab, more drastic things also happen.)
     This happens in VxWorks.  */
  free_named_symtabs (pst->filename);

@


1.110
log
@2009-12-07  Tristan Gingold  <gingold@@adacore.com>

	* dbxread.c (dbx_symfile_read): No need to test mainline to call
	init_psymbol_list.
	* xcoffread.c (xcoff_initial_scan): Ditto;
	* coffread.c (coff_symfile_read): Remove call to init_psymbol_list.
	* elfread.c (elf_symfile_read): Ditto.
	* machoread.c (macho_symfile_read): Ditto.
@
text
@d523 1
a523 4
   hung off the objfile structure.

   MAINLINE is true if we are reading the main symbol
   table (as opposed to a shared lib or dynamically loaded file).  */
d526 1
a526 1
dbx_symfile_read (struct objfile *objfile, int mainline)
@


1.109
log
@2009-12-02  Tristan Gingold  <gingold@@adacore.com>

	* dwarf2read.c (dwarf2_build_psymtabs_easy): Remove mainline parameter.
	(dwarf2_build_psymtabs_hard): Ditto.
	(dwarf2_build_psymtabs): Ajust calls.
	* stabsread.h (elfstab_build_psymtabs): Remove mainline parameter on
	the prototype.
	(coffstab_build_psymtabs): Ditto.
	(stabsect_build_psymtabs): Ditto.
	* dbxread.c (coffstab_build_psymtabs): Remove mainline parameter on
	the definition.
	(elfstab_build_psymtabs): Ditto.
	(stabsect_build_psymtabs): Ditto.
	* coffread.c (coff_symfile_read): Adjust call.
	* elfread.c (elf_symfile_read): Ditto.
	* somread.c (som_symfile_read): Ditto.
@
text
@d559 2
a560 4
  /* If we are reinitializing, or if we have never loaded syms yet, init */
  if (mainline
      || (objfile->global_psymbols.size == 0
	  &&  objfile->static_psymbols.size == 0))
@


1.108
log
@	* dbxread.c (set_namestring): Remove cast to unsigned.  Check N_STRX
	overflow.
@
text
@a3322 2
   MAINLINE is true if we are reading the main symbol
   table (as opposed to a shared lib or dynamically loaded file).
d3333 1
a3333 1
coffstab_build_psymtabs (struct objfile *objfile, int mainline,
a3415 2
   MAINLINE is true if we are reading the main symbol
   table (as opposed to a shared lib or dynamically loaded file).
d3424 1
a3424 2
elfstab_build_psymtabs (struct objfile *objfile, int mainline,
			asection *stabsect,
a3498 2
   MAINLINE is true if we are reading the main symbol table (as opposed to a
   shared lib or dynamically loaded file).
d3505 1
a3505 1
stabsect_build_psymtabs (struct objfile *objfile, int mainline, char *stab_name,
@


1.107
log
@	* xcoffread.c (scan_xcoff_symtab): Update.
	* symfile.h (add_psymbol_to_list): Update prototype.
	* symfile.c (add_psymbol_to_bcache): Add copy_name argument.
	(add_psymbol_to_list): Likewise.
	* stabsread.c (define_symbol): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	(handle_psymbol_enumerators): Update.
	(new_symbol): Update.
	* dbxread.c (read_dbx_symtab): Update.
	* coffread.c (process_coff_symbol): Update.
	* symtab.h (prim_record_minimal_symbol_full): Declare.
	(SYMBOL_SET_NAMES): Add copy_name argument.
	* symtab.c (struct demangled_name_entry): New struct.
	(hash_demangled_name_entry): New function.
	(eq_demangled_name_entry): Likewise.
	(create_demangled_names_hash): Use new functions.
	(symbol_set_names): Use struct demangled_name_entry.  Add
	copy_name argument.
	* minsyms.c (prim_record_minimal_symbol_full): New function.
	(prim_record_minimal_symbol_and_info): Use it.
	* elfread.c (record_minimal_symbol): Add name_len and copy_name
	arguments.  Call prim_record_minimal_symbol_full.
	(elf_symtab_read): Add copy_names argument.
	(elf_symfile_read): Update calls to elf_symtab_read.
	* dwarf2read.c (add_partial_symbol): Don't copy symbol names.
	(load_partial_dies): Likewise.
	(new_symbol): Likewise.
	* cp-namespace.c (check_one_possible_namespace_symbol): Don't save
	name on the obstack.  Update call to SYMBOL_SET_NAMES.
@
text
@d968 3
a970 2
  if (((unsigned) nlist->n_strx + file_string_table_offset)
      >= DBX_STRINGTAB_SIZE (objfile))
@


1.106
log
@2009-11-11  Michael Snyder  <msnyder@@vmware.com>

	* darwin-nat-info.c: Update copyright.
	* dbxread.c: Ditto.
	* gdbarch.sh: Ditto.
	* gdbarch.c: Ditto.
	* gdbarch.h: Ditto.
	* inline-frame.c: Ditto.
	* inline-frame.h: Ditto.
@
text
@d1729 1
a1729 1
	      add_psymbol_to_list (sym_name, sym_len,
d1741 1
a1741 1
	      add_psymbol_to_list (sym_name, sym_len,
d1759 1
a1759 1
		  add_psymbol_to_list (sym_name, sym_len,
d1767 1
a1767 1
		      add_psymbol_to_list (sym_name, sym_len,
d1780 1
a1780 1
		  add_psymbol_to_list (sym_name, sym_len,
d1842 1
a1842 1
		      add_psymbol_to_list (p, q - p,
d1860 1
a1860 1
	      add_psymbol_to_list (sym_name, sym_len,
d1924 1
a1924 1
	      add_psymbol_to_list (sym_name, sym_len,
d1992 1
a1992 1
	      add_psymbol_to_list (sym_name, sym_len,
@


1.105
log
@2009-07-29  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	PR gdb/6817
	* dbxread.c (read_dbx_symtab): Reduce stack use.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2008.
@


1.104
log
@	* dbxread.c (read_dbx_symtab): Clear has_line_numbers when ending
	a psymtab.
@
text
@d1692 1
a1692 1
 	      char *new_name, *name = alloca (p - namestring + 1);
d1703 1
@


1.103
log
@	* buildsym.c (record_line): Remove call to gdbarch_addr_bits_remove.

	* coffread.c (coff_symtab_read): Call gdbarch_addr_bits_remove before
	calling record_line.
	(enter_linenos): Likewise.
	* dbxread.c (process_one_symbol): Likewise.
	* dwarf2read.c (dwarf_decode_lines): Likewise.
	* mdebugread.c (psymtab_to_symtab_1): Likewise.
	* xcoffread.c (enter_line_range): Likewise.
@
text
@d1387 1
d1512 1
d2112 1
@


1.102
log
@gdb/
	Replace the savestring calls by xstrdup calls where possible.
	* breakpoint.c (condition_command, set_raw_breakpoint)
	(create_catchpoint, update_breakpoint_locations): Replace the
	savestring calls by xstrdup calls where possible.
	* buildsym.c (start_subfile, patch_subfile_names, record_debugformat)
	(record_producer): Likewise.
	* coffread.c (coff_start_symtab, complete_symtab): Likewise.
	* corefile.c (set_gnutarget): Likewise.
	* dbxread.c (add_new_header_file): Likewise.
	* demangle.c (set_demangling_command, set_demangling_style): Likewise.
	* event-top.c (push_prompt, pop_prompt, command_line_handler)
	(set_async_prompt): Likewise.
	* infcmd.c (set_inferior_io_terminal, attach_command_post_wait):
	Likewise.
	* language.c (set_language_command, _initialize_language): Likewise.
	* linespec.c (decode_line_2): Likewise.
	* rs6000-nat.c (add_vmap): Likewise.
	* top.c (set_prompt, init_history, init_main): Likewise.
	* tracepoint.c (stringify_collection_list): Likewise.
	* varobj.c (varobj_create): Remove variable expr_len.  Replace the
	savestring calls by xstrdup calls where possible.
	(value_of_root, c_name_of_variable, c_describe_child): Replace the
	savestring calls by xstrdup calls where possible.
	* xcoffread.c (complete_symtab): Likewise.
	* cli/cli-script.c (build_command_line, define_command): Likewise.
	* cli/cli-setshow.c (do_setshow_command): Likewise.
@
text
@d2793 5
a2797 1
	    record_line (current_subfile, 0, last_function_start + valu);
d3013 4
a3016 4
	  if (processing_gcc_compilation == 2)
	    record_line (current_subfile, desc, last_function_start);
	  else
	    record_line (current_subfile, desc, valu);
d3020 2
a3021 1
	record_line (current_subfile, desc, valu);
@


1.101
log
@
	* dbxread.c (read_dbx_symtab): Avoid compiler warnings for
	sym_name.
	* infcall.c (find_function_addr): Avoid compiler warnings for
	funaddr.
@
text
@d398 1
a398 1
  hfile->name = savestring (name, strlen (name));
@


1.100
log
@gdb

2009-03-31  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Keith Seitz  <keiths@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR gdb/6817
	* Makefile.in (dbxread.o): Update.
	* dbxread.c (read_dbx_symtab): Use cp_canonicalize_string.
	* dwarf2read.c (GDB_FORM_cached_string): New.
	(read_partial_die): Use dwarf2_canonicalize_name.
	(dwarf2_linkage_name): Use dwarf2_name.
	(dwarf2_canonicalize_name): New.
	(dwarf2_name): Use dwarf2_canonicalize_name.
	(dwarf_form_name, dump_die): Handle GDB_FORM_cached_string.
	* stabsread.c (define_symbol, read_type): Use cp_canonicalize_string.
	* symtab.c (lookup_symbol_in_language): Canonicalize input before
	searching.
	* cp-name-parser.y: operator() requires two parameters,
	according to libiberty.
	* minsyms.c (lookup_minimal_symbol): Canonicalize input
	before searching.
	* NEWS: Update.

gdb/testsuite

2009-03-31  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR gdb/931
	* gdb.cp/gdb1355.exp (f_li, f_lui, f_si, f_sui): Allow canonical
	output.
	* gdb.cp/templates.exp: Allow canonical output.  Remove KFAILs
	for gdb/931.
	* dw2-strp.S (DW_AT_language): Change to C++.
	(DW_TAG_variable (name ""), Abbrev code 7, .Lemptyname): New.
@
text
@d1687 1
@


1.99
log
@2008-12-15  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* dbxread.c (read_ofile_symtab): Sign-extend 32-bit N_LSYM and
	N_PSYM STABS values for 64-bit GDB.
@
text
@d1191 2
d1686 22
d1725 1
a1725 1
	      add_psymbol_to_list (namestring, p - namestring,
d1737 1
a1737 1
	      add_psymbol_to_list (namestring, p - namestring,
d1755 1
a1755 1
		  add_psymbol_to_list (namestring, p - namestring,
d1763 1
a1763 1
		      add_psymbol_to_list (namestring, p - namestring,
d1776 1
a1776 1
		  add_psymbol_to_list (namestring, p - namestring,
d1856 1
a1856 1
	      add_psymbol_to_list (namestring, p - namestring,
d1920 1
a1920 1
	      add_psymbol_to_list (namestring, p - namestring,
d1988 1
a1988 1
	      add_psymbol_to_list (namestring, p - namestring,
@


1.98
log
@	* xcoffread.c (RECORD_MINIMAL_SYMBOL): Update.
	(scan_xcoff_symtab): Update.
	* mdebugread.c (record_minimal_symbol): Update.
	(parse_partial_symbols): Update.
	* elfread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* coffread.c (record_minimal_symbol): Update.
	* sh64-tdep.c (MSYMBOL_IS_SPECIAL): Redefine.
	(sh64_elf_make_msymbol_special): Update.
	* mips-tdep.c (mips_elf_make_msymbol_special): Use
	MSYMBOL_TARGET_FLAG_1.
	(mips_elf_make_msymbol_special): Likewise.
	(msymbol_is_special): Likewise.
	* minsyms.c (prim_record_minimal_symbol_and_info): Update.
	(install_minimal_symbols): Likewise.
	(prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_and_info): Remove 'info' argument.
	* m68hc11-tdep.c (MSYMBOL_SET_RTC): Redefine.
	(MSYMBOL_SET_RTI): Redefine.
	(MSYMBOL_IS_RTC): Redefine.
	(MSYMBOL_IS_RTI): Redefine.
	* arm-tdep.c (MSYMBOL_SET_SPECIAL): Redefine.
	(MSYMBOL_IS_SPECIAL): Redefine.
	* symtab.h (struct minimal_symbol) <info>: Remove.
	<target_flag_1, target_flag_2>: New fields.
	(MSYMBOL_INFO): Remove.
	(MSYMBOL_TARGET_FLAG_1): New macro.
	(MSYMBOL_TARGET_FLAG_2): Likewise.
	(prim_record_minimal_symbol_and_info): Update.
@
text
@d2600 13
@


1.97
log
@	* buildsym.c (add_symbol_to_list): Do not call
	cp_scan_for_anonymous_namespaces here.
	(finish_block): Do not call cp_set_block_scope here.
	* cp-namespace.c (processing_has_namespace_info)
	(processing_current_prefix): Delete.
	(cp_initialize_namespace): Do not initialize
	processing_has_namespace_info.
	(cp_scan_for_anonymous_namespaces): Use SYMBOL_DEMANGLED_NAME.  Do
	not check processing_has_namespace_info.
	(cp_set_block_scope): Take prefix and namespace info flag as
	arguments.  Honor namespaces regardless of a demangled name.
	* cp-support.h (processing_has_namespace_info)
	(processing_current_prefix): Delete declarations.
	(cp_set_block_scope): Update prototype.
	* dwarf2read.c (processing_has_namespace_info)
	(processing_current_prefix): New static variables.
	(read_file_scope): Initialize processing_has_namespace_info.
	(read_func_scope): Call cp_set_block_scope for C++.
	(new_symbol): Call cp_scan_for_anonymous_namespaces for C++.
	* symtab.c (symbol_demangled_name): Accept a const argument.
	* symtab.h (symbol_demangled_name): Update prototype.
@
text
@d517 1
a517 1
    (name, address, ms_type, NULL, section, bfd_section, objfile);
@


1.96
log
@	* dbxread.c: Formatting.
	(INTERNALIZE_SYMBOL): Init n_other.
	(set_namestring): Take pointer to nlist arg rather than struct
	copy.  Update all callers.
@
text
@d57 1
d2742 1
d2761 8
a2768 3
	  finish_block (new->name, &local_symbols, new->old_blocks,
			new->start_addr, new->start_addr + valu,
			objfile);
d3158 2
d3162 9
a3170 2
		  finish_block (new->name, &local_symbols, new->old_blocks,
				new->start_addr, valu, objfile);
@


1.95
log
@	* objfiles.h (struct objfile): New GDBARCH member.
	(get_objfile_arch): Add prototype.
	* objfiles.c: Include "arch-utils.h".
	(allocate_objfile): Look up gdbarch associated with bfd.
	(get_objfile_arch): New function.
	* Makefile (objfiles.o): Update dependencies.

	* dwarf2-frame.c (decode_frame_entry_1): Replace current_gdbarch
	by objfile arch.
	* dwarf2loc.c (dwarf_expr_read_reg): Replace current_gdbarch
	by frame arch.
	(locexpr_describe_location): Replace current_gdbarch by
	objfile arch.
	* dwarf2read.c (die_type): Replace current_gdbarch by objfile arch.
	(dwarf2_add_field): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_base_type): Likewise.
	(new_symbol): Likewise.

	* coffread.c (decode_type): Add OBJFILE argument.  Update callers.
	(decode_base_type, decode_function_type): Likewise.
	(coff_read_struct_type, coff_read_enum_type): Likewise.
	(coff_symtab_read): Replace current_gdbarch by objfile arch.
	(decode_base_type): Likewise.
	(coff_read_enum_type): Likewise.
	(coff_read_struct_type): Replace current_objfile by OBJFILE argument.
	(coff_read_enum_type): Likewise.

	* dbxread.c (read_dbx_symtab): Replace current_gdbarch by objfile arch.
	(end_psymtab): Likewise.
	(process_one_symbol): Likewise.

	* mdebugread.c (parse_symbol): Replace current_gdbarch by objfile arch.
	(parse_procedure): Likewise.
	(parse_partial_symbols): Likewise.

	* somread.c (som_symtab_read): Replace current_gdbarch by objfile arch.

	* stabsread.c (define_symbol): Replace current_gdbarch by objfile arch.
	Replace static pcc_promotion_type and pcc_unsigned_promotion_type by
	built-in types.
	(read_range_type): Replace current_gdbarch by objfile arch.  Replace
	static range_index_type by built-in type.
	(read_one_struct_field): Replace current_gdbarch by objfile arch.
	(read_enum_type): Likewise.

	* xcoffread.c (read_xcoff_symtab): Replace current_gdbarch by
	objfile arch.
@
text
@d853 1
d855 1
a855 1
    (intern).n_strx = bfd_h_get_32 (abfd, (extern)->e_strx);		\
d963 1
a963 1
set_namestring (struct objfile *objfile, struct internal_nlist nlist)
d967 2
a968 2
  if (((unsigned) nlist.n_strx + file_string_table_offset) >=
      DBX_STRINGTAB_SIZE (objfile))
d975 2
a976 2
    namestring = nlist.n_strx + file_string_table_offset +
      DBX_STRINGTAB (objfile);
d1343 1
a1343 1
	  namestring = set_namestring (objfile, nlist);
d1364 1
a1364 1
	  namestring = set_namestring (objfile, nlist);
d1406 1
a1406 1
	      namestring = set_namestring (objfile, nlist);
d1515 1
a1515 1
	    namestring = set_namestring (objfile, nlist);
d1559 1
a1559 1
	    namestring = set_namestring (objfile, nlist);
d1593 1
a1593 1
	    namestring = set_namestring (objfile, nlist);
d1637 1
a1637 2
		  alloca ((includes_allocated *= 2) *
			  sizeof (char *));
d1663 1
a1663 1
	  namestring = set_namestring (objfile, nlist);
d2018 1
a2018 1
	  namestring = set_namestring (objfile, nlist);
d2295 1
a2295 1
		    number_dependencies * sizeof (struct partial_symtab *));
d2533 1
a2533 1
      namestring = set_namestring (objfile, nlist);
d2595 1
a2595 1
      namestring = set_namestring (objfile, nlist);
@


1.94
log
@	* dbxread.c (read_dbx_symtab): Reformat comments to 80 columns.
	Move local var def closer to only use.
@
text
@d1184 1
d1483 1
a1483 1
		&& gdbarch_sofun_address_maybe_missing (current_gdbarch))
d1696 3
a1698 3
	      if (gdbarch_static_transform_name_p (current_gdbarch))
		namestring = gdbarch_static_transform_name
		  (current_gdbarch, namestring);
d1855 1
a1855 1
		  && gdbarch_sofun_address_maybe_missing (current_gdbarch))
d1870 1
a1870 1
		  && gdbarch_sofun_address_maybe_missing (current_gdbarch))
d1923 1
a1923 1
		  && gdbarch_sofun_address_maybe_missing (current_gdbarch))
d1938 1
a1938 1
		  && gdbarch_sofun_address_maybe_missing (current_gdbarch))
d2075 1
a2075 1
	  if (pst && gdbarch_sofun_address_maybe_missing (current_gdbarch))
d2201 1
d2223 1
a2223 1
      && gdbarch_sofun_address_maybe_missing (current_gdbarch))
d2254 1
a2254 1
  if (!gdbarch_sofun_address_maybe_missing (current_gdbarch))
d2684 1
d2775 1
a2775 1
      valu = gdbarch_smash_text_address (current_gdbarch, valu);
d3115 1
a3115 1
		  && gdbarch_sofun_address_maybe_missing (current_gdbarch))
@


1.93
log
@	* dbxread.c (read_dbx_symtab): Fix indentation.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004.
a1314 1
	char *p;
d1534 2
a1535 2
	       SOs for non-existant .c files.  We ignore all subsequent SOs that
	       immediately follow the first.  */
d1659 2
a1681 2


d1705 1
d1746 1
d1827 1
d2013 1
a2154 1

@


1.92
log
@
	* dbxread.c (repeated_header_complaint, dbx_symfile_init)
	(read_dbx_dynamic_symtab, function_outside_compilation_unit_complaint)
	(read_dbx_symtab, end_psymtab, dbx_psymtab_to_symtab_1)
	(dbx_psymtab_to_symtab, read_ofile_symtab, process_one_symbol)
	(stabsect_build_psymtabs): Fix indentation.
@
text
@d1315 1
a1315 1
	  char *p;
d1320 2
a1321 2
	  case N_TEXT | N_EXT:
	  case N_NBTEXT | N_EXT:
d1326 2
a1327 2
	  case N_DATA | N_EXT:
	  case N_NBDATA | N_EXT:
d1332 4
a1335 4
	  case N_BSS:
	  case N_BSS | N_EXT:
	  case N_NBBSS | N_EXT:
	  case N_SETV | N_EXT:		/* FIXME, is this in BSS? */
d1340 1
a1340 1
	  case N_ABS | N_EXT:
d1344 1
a1344 1
	  bss_ext_symbol:
d1351 1
a1351 1
	  case N_NBTEXT:
d1358 3
a1360 3
	  case N_FN:
	  case N_FN_SEQ:
	  case N_TEXT:
d1368 20
a1387 20
	  {
	    if (past_first_source_file && pst
		/* The gould NP1 uses low values for .o and -l symbols
		   which are not the address.  */
		&& nlist.n_value >= pst->textlow)
	      {
		end_psymtab (pst, psymtab_include_list, includes_used,
			     symnum * symbol_size,
			     nlist.n_value > pst->texthigh
			     ? nlist.n_value : pst->texthigh,
			     dependency_list, dependencies_used,
			     textlow_not_set);
		pst = (struct partial_symtab *) 0;
		includes_used = 0;
		dependencies_used = 0;
	      }
	    else
	      past_first_source_file = 1;
	    last_o_file_start = nlist.n_value;
	  }
d1389 1
a1389 1
	  goto record_it;
d1392 1
a1392 1
	  case N_DATA:
d1397 1
a1397 1
	  case N_UNDF | N_EXT:
d1399 3
a1401 3
	  {
	    /* This is a "Fortran COMMON" symbol.  See if the target
	       environment knows where it has been relocated to.  */
d1403 1
a1403 1
	    CORE_ADDR reladdr;
d1405 9
a1413 9
	    namestring = set_namestring (objfile, nlist);
	    if (target_lookup_symbol (namestring, &reladdr))
	      {
		continue;	/* Error in lookup; ignore symbol for now.  */
	      }
	    nlist.n_type ^= (N_BSS ^ N_UNDF);	/* Define it as a bss-symbol */
	    nlist.n_value = reladdr;
	    goto bss_ext_symbol;
	  }
d1416 1
a1416 1
	  case N_UNDF:
d1418 15
a1432 15
	  {
	    /* Deal with relative offsets in the string table
	       used in ELF+STAB under Solaris.  If we want to use the
	       n_strx field, which contains the name of the file,
	       we must adjust file_string_table_offset *before* calling
	       set_namestring().  */
	    past_first_source_file = 1;
	    file_string_table_offset = next_file_string_table_offset;
	    next_file_string_table_offset =
	      file_string_table_offset + nlist.n_value;
	    if (next_file_string_table_offset < file_string_table_offset)
	      error (_("string table offset backs up at %d"), symnum);
	    /* FIXME -- replace error() with complaint.  */
	    continue;
	  }
d1437 3
a1439 3
	  case N_ABS:
	  case N_NBDATA:
	  case N_NBBSS:
d1447 11
a1457 11
	  case N_INDR:
	  case N_INDR | N_EXT:
	  case N_SETA:
	  case N_SETA | N_EXT:
	  case N_SETT:
	  case N_SETT | N_EXT:
	  case N_SETD:
	  case N_SETD | N_EXT:
	  case N_SETB:
	  case N_SETB | N_EXT:
	  case N_SETV:
d1464 1
a1464 1
	  case N_SO:
d1540 5
a1544 5
	      pst = start_psymtab (objfile,
				   namestring, valu,
				   first_so_symnum * symbol_size,
				   objfile->global_psymbols.next,
				   objfile->static_psymbols.next);
d1551 1
a1551 1
	  case N_BINCL:
d1571 5
a1575 5
	    {
	      /* FIXME: we should not get here without a PST to work on.
		 Attempt to recover.  */
	      complaint (&symfile_complaints,
			 _("N_BINCL %s not in entries for any file, at symtab \
d1577 3
a1579 3
			 namestring, symnum);
	      continue;
	    }
d1587 1
a1587 1
	  case N_SOL:
d1615 1
a1615 1
	    continue;
d1628 1
a1628 1
	    record_include_file:
d1632 2
a1633 2
	    {
	      char **orig = psymtab_include_list;
d1635 6
a1640 6
	      psymtab_include_list = (char **)
		alloca ((includes_allocated *= 2) *
			sizeof (char *));
	      memcpy (psymtab_include_list, orig,
		      includes_used * sizeof (char *));
	    }
d1643 8
a1650 8
	  case N_LSYM:		/* Typedef or automatic variable. */
	  case N_STSYM:		/* Data seg var -- static  */
	  case N_LCSYM:		/* BSS      "  */
	  case N_ROSYM:		/* Read-only data seg var -- static.  */
	  case N_NBSTS:		/* Gould nobase.  */
	  case N_NBLCS:		/* symbols.  */
	  case N_FUN:
	  case N_GSYM:		/* Global (extern) variable; can be
d1656 1
a1656 1
	  case N_PC:		/* I may or may not need this; I
d1658 2
a1659 2
	  case N_M2C:		/* I suspect that I can ignore this here. */
	  case N_SCOPE:		/* Same.   */
d1665 2
a1666 2
	  {
	    CORE_ADDR valu;
d1668 8
a1675 8
	    /* It's value is the size (in bytes) of the function for
	       function relative stabs, or the address of the function's
	       end for old style stabs.  */
	    valu = nlist.n_value + last_function_start;
	    if (pst->texthigh == 0 || valu > pst->texthigh)
	      pst->texthigh = valu;
	    break;
	  }
d1679 1
a1679 1
	  continue;			/* Not a debugging symbol.   */
d1691 86
a1776 26
	  {
	  case 'S':
	    nlist.n_value += ANOFFSET (objfile->section_offsets,
				       data_sect_index);

	    if (gdbarch_static_transform_name_p (current_gdbarch))
	      namestring = gdbarch_static_transform_name
			     (current_gdbarch, namestring);

	    add_psymbol_to_list (namestring, p - namestring,
				 VAR_DOMAIN, LOC_STATIC,
				 &objfile->static_psymbols,
				 0, nlist.n_value,
				 psymtab_language, objfile);
	    continue;
	  case 'G':
	    nlist.n_value += ANOFFSET (objfile->section_offsets,
				       data_sect_index);
	    /* The addresses in these entries are reported to be
	       wrong.  See the code that reads 'G's for symtabs. */
	    add_psymbol_to_list (namestring, p - namestring,
				 VAR_DOMAIN, LOC_STATIC,
				 &objfile->global_psymbols,
				 0, nlist.n_value,
				 psymtab_language, objfile);
	    continue;
d1778 8
a1785 59
	  case 'T':
	    /* When a 'T' entry is defining an anonymous enum, it
	       may have a name which is the empty string, or a
	       single space.  Since they're not really defining a
	       symbol, those shouldn't go in the partial symbol
	       table.  We do pick up the elements of such enums at
	       'check_enum:', below.  */
	    if (p >= namestring + 2
		|| (p == namestring + 1
		    && namestring[0] != ' '))
	      {
		add_psymbol_to_list (namestring, p - namestring,
				     STRUCT_DOMAIN, LOC_TYPEDEF,
				     &objfile->static_psymbols,
				     nlist.n_value, 0,
				     psymtab_language, objfile);
		if (p[2] == 't')
		  {
		    /* Also a typedef with the same name.  */
		    add_psymbol_to_list (namestring, p - namestring,
					 VAR_DOMAIN, LOC_TYPEDEF,
					 &objfile->static_psymbols,
					 nlist.n_value, 0,
					 psymtab_language, objfile);
		    p += 1;
		  }
	      }
	    goto check_enum;
	  case 't':
	    if (p != namestring)	/* a name is there, not just :T... */
	      {
		add_psymbol_to_list (namestring, p - namestring,
				     VAR_DOMAIN, LOC_TYPEDEF,
				     &objfile->static_psymbols,
				     nlist.n_value, 0,
				     psymtab_language, objfile);
	      }
	  check_enum:
	    /* If this is an enumerated type, we need to
	       add all the enum constants to the partial symbol
	       table.  This does not cover enums without names, e.g.
	       "enum {a, b} c;" in C, but fortunately those are
	       rare.  There is no way for GDB to find those from the
	       enum type without spending too much time on it.  Thus
	       to solve this problem, the compiler needs to put out the
	       enum in a nameless type.  GCC2 does this.  */

	    /* We are looking for something of the form
	       <name> ":" ("t" | "T") [<number> "="] "e"
	       {<constant> ":" <value> ","} ";".  */

	    /* Skip over the colon and the 't' or 'T'.  */
	    p += 2;
	    /* This type may be given a number.  Also, numbers can come
	       in pairs like (0,26).  Skip over it.  */
	    while ((*p >= '0' && *p <= '9')
		   || *p == '(' || *p == ',' || *p == ')'
		   || *p == '=')
	      p++;
d1787 1
a1787 7
	    if (*p++ == 'e')
	      {
		/* The aix4 compiler emits extra crud before the members.  */
		if (*p == '-')
		  {
		    /* Skip over the type (?).  */
		    while (*p != ':')
d1789 1
d1791 8
a1798 3
		    /* Skip over the colon.  */
		    p++;
		  }
d1800 33
a1832 8
		/* We have found an enumerated type.  */
		/* According to comments in read_enum_type
		   a comma could end it instead of a semicolon.
		   I don't know where that happens.
		   Accept either.  */
		while (*p && *p != ';' && *p != ',')
		  {
		    char *q;
d1834 39
a1872 33
		    /* Check for and handle cretinous dbx symbol name
		       continuation!  */
		    if (*p == '\\' || (*p == '?' && p[1] == '\0'))
		      p = next_symbol_text (objfile);

		    /* Point to the character after the name
		       of the enum constant.  */
		    for (q = p; *q && *q != ':'; q++)
		      ;
		    /* Note that the value doesn't matter for
		       enum constants in psymtabs, just in symtabs.  */
		    add_psymbol_to_list (p, q - p,
					 VAR_DOMAIN, LOC_CONST,
					 &objfile->static_psymbols, 0,
					 0, psymtab_language, objfile);
		    /* Point past the name.  */
		    p = q;
		    /* Skip over the value.  */
		    while (*p && *p != ',')
		      p++;
		    /* Advance past the comma.  */
		    if (*p)
		      p++;
		  }
	      }
	    continue;
	  case 'c':
	    /* Constant, e.g. from "const" in Pascal.  */
	    add_psymbol_to_list (namestring, p - namestring,
				 VAR_DOMAIN, LOC_CONST,
				 &objfile->static_psymbols, nlist.n_value,
				 0, psymtab_language, objfile);
	    continue;
d1874 24
a1897 39
	  case 'f':
	    if (! pst)
	      {
		int name_len = p - namestring;
		char *name = xmalloc (name_len + 1);
		memcpy (name, namestring, name_len);
		name[name_len] = '\0';
		function_outside_compilation_unit_complaint (name);
		xfree (name);
	      }
	    nlist.n_value += ANOFFSET (objfile->section_offsets, 
				       SECT_OFF_TEXT (objfile));
	    /* Kludges for ELF/STABS with Sun ACC */
	    last_function_name = namestring;
	    /* Do not fix textlow==0 for .o or NLM files, as 0 is a legit
	       value for the bottom of the text seg in those cases. */
	    if (nlist.n_value == ANOFFSET (objfile->section_offsets, 
					   SECT_OFF_TEXT (objfile))
		&& gdbarch_sofun_address_maybe_missing (current_gdbarch))
	      {
		CORE_ADDR minsym_valu = 
		  find_stab_function_addr (namestring, 
					   pst ? pst->filename : NULL, 
					   objfile);
		/* find_stab_function_addr will return 0 if the minimal
		   symbol wasn't found.  (Unfortunately, this might also
		   be a valid address.)  Anyway, if it *does* return 0,
		   it is likely that the value was set correctly to begin
		   with... */
		if (minsym_valu != 0)
		  nlist.n_value = minsym_valu;
	      }
	    if (pst && textlow_not_set
		&& gdbarch_sofun_address_maybe_missing (current_gdbarch))
	      {
		pst->textlow = nlist.n_value;
		textlow_not_set = 0;
	      }
	    /* End kludge.  */
d1899 42
a1940 24
	    /* Keep track of the start of the last function so we
	       can handle end of function symbols.  */
	    last_function_start = nlist.n_value;

	    /* In reordered executables this function may lie outside
	       the bounds created by N_SO symbols.  If that's the case
	       use the address of this function as the low bound for
	       the partial symbol table.  */
	    if (pst
		&& (textlow_not_set
		    || (nlist.n_value < pst->textlow
			&& (nlist.n_value
			    != ANOFFSET (objfile->section_offsets,
					 SECT_OFF_TEXT (objfile))))))
	      {
		pst->textlow = nlist.n_value;
		textlow_not_set = 0;
	      }
	    add_psymbol_to_list (namestring, p - namestring,
				 VAR_DOMAIN, LOC_BLOCK,
				 &objfile->static_psymbols,
				 0, nlist.n_value,
				 psymtab_language, objfile);
	    continue;
d1942 24
a1965 42
	    /* Global functions were ignored here, but now they
	       are put into the global psymtab like one would expect.
	       They're also in the minimal symbol table.  */
	  case 'F':
	    if (! pst)
	      {
		int name_len = p - namestring;
		char *name = xmalloc (name_len + 1);
		memcpy (name, namestring, name_len);
		name[name_len] = '\0';
		function_outside_compilation_unit_complaint (name);
		xfree (name);
	      }
	    nlist.n_value += ANOFFSET (objfile->section_offsets, 
				       SECT_OFF_TEXT (objfile));
	    /* Kludges for ELF/STABS with Sun ACC */
	    last_function_name = namestring;
	    /* Do not fix textlow==0 for .o or NLM files, as 0 is a legit
	       value for the bottom of the text seg in those cases. */
	    if (nlist.n_value == ANOFFSET (objfile->section_offsets, 
					   SECT_OFF_TEXT (objfile))
		&& gdbarch_sofun_address_maybe_missing (current_gdbarch))
	      {
		CORE_ADDR minsym_valu = 
		  find_stab_function_addr (namestring, 
					   pst ? pst->filename : NULL, 
					   objfile);
		/* find_stab_function_addr will return 0 if the minimal
		   symbol wasn't found.  (Unfortunately, this might also
		   be a valid address.)  Anyway, if it *does* return 0,
		   it is likely that the value was set correctly to begin
		   with... */
		if (minsym_valu != 0)
		  nlist.n_value = minsym_valu;
	      }
	    if (pst && textlow_not_set
		&& gdbarch_sofun_address_maybe_missing (current_gdbarch))
	      {
		pst->textlow = nlist.n_value;
		textlow_not_set = 0;
	      }
	    /* End kludge.  */
d1967 18
a1984 24
	    /* Keep track of the start of the last function so we
	       can handle end of function symbols.  */
	    last_function_start = nlist.n_value;

	    /* In reordered executables this function may lie outside
	       the bounds created by N_SO symbols.  If that's the case
	       use the address of this function as the low bound for
	       the partial symbol table.  */
	    if (pst
		&& (textlow_not_set
		    || (nlist.n_value < pst->textlow
			&& (nlist.n_value
			    != ANOFFSET (objfile->section_offsets,
					 SECT_OFF_TEXT (objfile))))))
	      {
		pst->textlow = nlist.n_value;
		textlow_not_set = 0;
	      }
	    add_psymbol_to_list (namestring, p - namestring,
				 VAR_DOMAIN, LOC_BLOCK,
				 &objfile->global_psymbols,
				 0, nlist.n_value,
				 psymtab_language, objfile);
	    continue;
d1986 9
a1994 18
	    /* Two things show up here (hopefully); static symbols of
	       local scope (static used inside braces) or extensions
	       of structure symbols.  We can ignore both.  */
	  case 'V':
	  case '(':
	  case '0':
	  case '1':
	  case '2':
	  case '3':
	  case '4':
	  case '5':
	  case '6':
	  case '7':
	  case '8':
	  case '9':
	  case '-':
	  case '#':	/* for symbol identification (used in live ranges) */
	    continue;
d1996 7
a2002 9
	  case ':':
	    /* It is a C++ nested symbol.  We don't need to record it
	       (I don't think); if we try to look up foo::bar::baz,
	       then symbols for the symtab containing foo should get
	       read in, I think.  */
	    /* Someone says sun cc puts out symbols like
	       /foo/baz/maclib::/usr/local/bin/maclib,
	       which would get here with a symbol type of ':'.  */
	    continue;
d2004 2
a2005 7
	  default:
	    /* Unexpected symbol descriptor.  The second and subsequent stabs
	       of a continued stab can show up here.  The question is
	       whether they ever can mimic a normal stab--it would be
	       nice if not, since we certainly don't want to spend the
	       time searching to the end of every string looking for
	       a backslash.  */
d2007 4
a2010 2
	    complaint (&symfile_complaints, _("unknown symbol descriptor `%c'"),
		       p[1]);
d2012 1
a2012 6
	    /* Ignore it; perhaps it is an extension that we don't
	       know about.  */
	    continue;
	  }

	  case N_EXCL:
d2066 1
a2066 1
	  case N_ENDM:
d2072 9
a2080 9
	  {
	    end_psymtab (pst, psymtab_include_list, includes_used,
			 symnum * symbol_size,
			 (CORE_ADDR) 0,
			 dependency_list, dependencies_used, textlow_not_set);
	    pst = (struct partial_symtab *) 0;
	    includes_used = 0;
	    dependencies_used = 0;
	  }
d2083 1
a2083 1
	  case N_RBRAC:
d2088 4
a2091 4
	  case N_EINCL:
	  case N_DSLINE:
	  case N_BSLINE:
	  case N_SSYM:		/* Claim: Structure or union element.
d2093 20
a2112 20
	  case N_ENTRY:		/* Alternate entry point; can ignore. */
	  case N_MAIN:		/* Can definitely ignore this.   */
	  case N_CATCH:		/* These are GNU C++ extensions */
	  case N_EHDECL:	/* that can safely be ignored here. */
	  case N_LENG:
	  case N_BCOMM:
	  case N_ECOMM:
	  case N_ECOML:
	  case N_FNAME:
	  case N_SLINE:
	  case N_RSYM:
	  case N_PSYM:
	  case N_LBRAC:
	  case N_NSYMS:		/* Ultrix 4.0: symbol count */
	  case N_DEFD:		/* GNU Modula-2 */
	  case N_ALIAS:		/* SunPro F77: alias name, ignore for now.  */

	  case N_OBJ:		/* useless types from Solaris */
	  case N_OPT:
	  case N_PATCH:
d2117 1
a2117 1
	  default:
@


1.91
log
@	* dbxread.c (read_dbx_symtab): Fix indentation.
@
text
@d178 2
a179 1
	     _("\"repeated\" header file %s not previously seen, at symtab pos %d"),
d629 2
a630 1
  memset (objfile->deprecated_sym_stab_info, 0, sizeof (struct dbx_symfile_info));
d1041 2
a1042 1
	      sym_value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1047 2
a1048 1
	      sym_value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d1053 2
a1054 1
	      sym_value += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS (objfile));
d1095 2
a1096 1
      rel->address + ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d1173 2
a1174 1
	     _("function `%s' appears to be defined outside of all compilation units"),
d1322 2
a1323 1
	  nlist.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1328 2
a1329 1
	  nlist.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d1336 2
a1337 1
	  nlist.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS (objfile));
d1361 2
a1362 1
	  nlist.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1378 2
a1379 1
			     dependency_list, dependencies_used, textlow_not_set);
d1393 2
a1394 1
	  nlist.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d1408 1
a1408 1
		continue;		/* Error in lookup; ignore symbol for now.  */
d1473 2
a1474 1
	    valu = nlist.n_value + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1575 2
a1576 1
			 _("N_BINCL %s not in entries for any file, at symtab pos %d"),
d1643 1
a1643 1
	  case N_LSYM:			/* Typedef or automatic variable. */
d1650 2
a1651 2
	  case N_GSYM:			/* Global (extern) variable; can be
					   data or bss (sigh FIXME).  */
d1656 3
a1658 3
	  case N_PC:			/* I may or may not need this; I
					   suspect not.  */
	  case N_M2C:			/* I suspect that I can ignore this here. */
d1693 2
a1694 1
	    nlist.n_value += ANOFFSET (objfile->section_offsets, data_sect_index);
d1707 2
a1708 1
	    nlist.n_value += ANOFFSET (objfile->section_offsets, data_sect_index);
d1983 1
a1983 1
	  case '#':		/* for symbol identification (used in live ranges) */
d2055 4
a2058 2
		    fprintf_unfiltered (gdb_stderr, "Had to reallocate dependency list.\n");
		    fprintf_unfiltered (gdb_stderr, "New dependencies allocated: %d\n",
d2091 2
a2092 2
	  case N_SSYM:			/* Claim: Structure or union element.
					   Hopefully, I can ignore this.  */
d2094 1
a2094 1
	  case N_MAIN:			/* Can definitely ignore this.   */
d2096 1
a2096 1
	  case N_EHDECL:		/* that can safely be ignored here. */
d2107 1
a2107 1
	  case N_DEFD:			/* GNU Modula-2 */
d2110 1
a2110 1
	  case N_OBJ:			/* useless types from Solaris */
d2131 2
a2132 1
	 ? (text_addr + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile)))
d2280 2
a2281 1
    objfile->global_psymbols.next - (objfile->global_psymbols.list + pst->globals_offset);
d2283 2
a2284 1
    objfile->static_psymbols.next - (objfile->static_psymbols.list + pst->statics_offset);
d2371 2
a2372 1
      fprintf_unfiltered (gdb_stderr, "Psymtab for %s already read in.  Shouldn't happen.\n",
d2428 2
a2429 1
      fprintf_unfiltered (gdb_stderr, "Psymtab for %s already read in.  Shouldn't happen.\n",
d2455 2
a2456 1
	    back_to = make_cleanup (free_current_contents, (void *) &stabs_data);
d2651 2
a2652 1
  pst->symtab = end_symtab (text_offset + text_size, objfile, SECT_OFF_TEXT (objfile));
d3139 2
a3140 1
			     _("unmatched N_LBRAC before symtab pos %d"), symnum);
d3460 2
a3461 1
    error (_("stabsect_build_psymtabs:  Found stabs (%s), but not string section (%s)"),
d3466 2
a3467 1
  memset (objfile->deprecated_sym_stab_info, 0, sizeof (struct dbx_symfile_info));
d3482 2
a3483 1
    error (_("ridiculous string table size: %d bytes"), DBX_STRINGTAB_SIZE (objfile));
d3492 1
a3492 1
				  DBX_STRINGTAB (objfile),	/* input buffer */
d3494 1
a3494 1
				  DBX_STRINGTAB_SIZE (objfile));	/* amount to read */
d3513 2
a3514 2
  dbx_new_init,			/* sym_new_init: init anything gbl to entire symtab */
  dbx_symfile_init,		/* sym_init: read initial info, setup for sym_read() */
d3517 2
a3518 1
  default_symfile_offsets,	/* sym_offsets: parse user's offsets to internal form */
@


1.90
log
@
	* gdbarch.sh (sofun_address_maybe_missing): New gdbarch variable.
	* gdbarch.c, gdbarch.h: Regenerate.
	* dbxread.c (find_stab_function_addr): Define unconditionally.
	(read_dbx_symtab): Use gdbarch_sofun_address_maybe_missing
	instead of SOFUN_ADDRESS_MAYBE_MISSING.
	(end_psymtab): Likewise.
	(process_one_symbol): Likewise.
	* mdebugread.c (parse_partial_symbols): Likewise.

	* symtab.h (struct minimal_symbol): Always define "filename" member.
	* elfread.c (elf_symtab_read): Use msym->filename unconditionally.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* symmisc.c (dump_msymbols): Likewise.

	* config/i386/i386sol2.mt (DEPRECATED_TM_FILE): Remove.
	* config/i386/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/i386/tm-i386sol2.h: Remove file.
	* config/i386/tm-linux.h: Remove file.
	* i386-linux-tdep.c (i386_linux_init_abi): Add call to
	set_gdbarch_sofun_address_maybe_missing.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Likewise.

	* config/powerpc/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/nbsd.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/obsd.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/ppc-eabi.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/ppc-sim.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/tm-ppc-eabi.h: Remove file.
	* rs6000-tdep.c (rs6000_gdbarch_init): Add call to
	set_gdbarch_sofun_address_maybe_missing.

	* config/sparc/sol2-64.mt (DEPRECATED_TM_FILE): Remove.
	* config/sparc/sol2.mt (DEPRECATED_TM_FILE): Remove.
	* config/sparc/tm-sol2.h: Remove file.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Add call to
	set_gdbarch_sofun_address_maybe_missing.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Likewise.

doc/ChangeLog:

	* gdbarch.texi (Target Conditionals): Remove documentation of
	SOFUN_ADDRESS_MAYBE_MISSING, replaced by ...
	(Compiler Characteristics): ... documentation of
	set_gdbarch_sofun_address_maybe_missing.
@
text
@d1554 1
a1554 1
	    psymtab_language = tmp_language;
d1587 1
a1587 1
	    psymtab_language = tmp_language;
@


1.89
log
@	* gdbarch.sh (static_transform_name): New gdbarch callback.
	* gdbarch.c, gdbarch.h: Regenerate.
	* dbxread.c (read_dbx_symtab): Use gdbarch_static_transform_name
	instead of STATIC_TRANSFORM_NAME.
	* mdebugread.c (parse_partial_symbols): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* xcoffread.c (scan_xcoff_symtab): Likewise.

	* config/i368/tm-i386sol2.h (STATIC_TRANSFORM_NAME): Remove.
	(IS_STATIC_TRANSFORM_NAME): Remove.
	* i386-tdep.c (sunpro_static_transform_name): Remove, move to ...
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): ... here.
	(i386_sol2_init_abi): Install it.

	* config/sparc/tm-sol2.h (STATIC_TRANSFORM_NAME): Remove.
	(IS_STATIC_TRANSFORM_NAME): Remove.
	* sparc-tdep.c (sparc_stabs_unglobalize_name): Remove, move to ...
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): ... here.
	(sparc32_sol2_init_abi): Install it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Likewise.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Add prototype.
@
text
@a1118 1
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
a1161 1
#endif /* SOFUN_ADDRESS_MAYBE_MISSING */
a1463 1
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
d1468 2
a1469 1
	    if (nlist.n_value == 0)
d1476 1
a1476 3
#else
	    textlow_not_set = 0;
#endif
a1830 1
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
d1834 2
a1835 1
					   SECT_OFF_TEXT (objfile)))
d1849 2
a1850 1
	    if (pst && textlow_not_set)
a1854 1
#endif
a1898 1
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
d1902 2
a1903 1
					   SECT_OFF_TEXT (objfile)))
d1917 2
a1918 1
	    if (pst && textlow_not_set)
a1922 1
#endif
a2047 1
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
d2052 1
a2052 1
	  if (pst)
a2061 1
#endif
a2182 1
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
d2198 2
a2199 1
  if (pst->texthigh == 0 && last_function_name)
d2230 2
d2233 1
a2233 1
  if (textlow_not_set)
a2257 1
#endif /* SOFUN_ADDRESS_MAYBE_MISSING.  */
a3078 1
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
d3083 2
a3084 1
				       SECT_OFF_TEXT (objfile)))
a3097 1
#endif
@


1.88
log
@	* dbxread.c (process_one_symbol): Remove VARIABLES_INSIDE_BLOCK
	checks.
	* config/arm/embed.mt, config/arm/linux.mt, config/arm/wince.mt: Do
	not set DEPRECATED_TM_FILE.
	* config/arm/tm-arm.h: Delete file.

	* gdbint.texinfo (Target Conditionals): Remove VARIABLES_INSIDE_BLOCK.
@
text
@d1683 5
a1687 3
#ifdef STATIC_TRANSFORM_NAME
	    namestring = STATIC_TRANSFORM_NAME (namestring);
#endif
@


1.87
log
@        * symfile.h (struct sym_fns): Add new field sym_read_linetable.
        * coffread.c, dbxread.c, elfread.c, mipsread.c somread.c:
        Adjust the struct sym_fns object accordingly by setting
        the new field to NULL.
        * xcoffread.c (aix_process_linenos): Make static.
        (xcoff_sym_fns): Set new field to aix_process_linenos.
        * buildsym.c (end_symtab): Replace call to PROCESS_LINENUMBER_HOOK
        by call to new the new sym_fns sym_read_linetable function.
        * config/powerpc/aix.mt (DEPRECATED_TM_FILE): Delete.
        * config/rs6000/tm-rs6000.h: Delete.
@
text
@d2797 1
a2797 12
      /* Some compilers put the variable decls inside of an
         LBRAC/RBRAC block.  This macro should be nonzero if this is
         true.  DESC is N_DESC from the N_RBRAC symbol.  GCC_P is true
         if we've detected the GCC_COMPILED_SYMBOL or the
         GCC2_COMPILED_SYMBOL.  */
#if !defined (VARIABLES_INSIDE_BLOCK)
#define VARIABLES_INSIDE_BLOCK(desc, gcc_p) 0
#endif

      /* Can only use new->locals as local symbols here if we're in
         GCC or on a machine that puts them before the lbrack.  */
      if (!VARIABLES_INSIDE_BLOCK (desc, processing_gcc_compilation))
d2799 5
a2803 11
	  if (local_symbols != NULL)
	    {
	      /* GCC development snapshots from March to December of
		 2000 would output N_LSYM entries after N_LBRAC
		 entries.  As a consequence, these symbols are simply
		 discarded.  Complain if this is the case.  Note that
		 there are some compilers which legitimately put local
		 symbols within an LBRAC/RBRAC block; this complaint
		 might also help sort out problems in which
		 VARIABLES_INSIDE_BLOCK is incorrectly defined.  */
	      complaint (&symfile_complaints, _("\
a2805 2
	    }
	  local_symbols = new->locals;
d2807 1
d2809 1
a2809 2
      if (context_stack_depth
	  > !VARIABLES_INSIDE_BLOCK (desc, processing_gcc_compilation))
a2841 3
      if (VARIABLES_INSIDE_BLOCK (desc, processing_gcc_compilation))
	/* Now pop locals of block just finished.  */
	local_symbols = new->locals;
@


1.86
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d3516 1
@


1.85
log
@2007-08-21  Michael Snyder  <msnyder@@access-company.com>

	* dbxread.c (read_dbx_symtab): Guard null deref.
	Break up long line.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.84
log
@	* coffread.c (coff_sym_fns): Add default_symfile_segments.
	* dbxread.c (start_psymtab): Check HAVE_ELF.
	(aout_sym_fns): Likewise.
	* elfread.c (elf_symfile_segments): New.
	(elf_sym_fns): Add elf_symfile_segments.
	* mipsread.c (ecoff_sym_fns): Add default_symfile_segments.
	* remote.c (get_offsets): Use symfile_map_offsets_to_segments.
	Skip if there is no symfile_objfile.  Handle TextSeg and DataSeg.
	* somread.c (som_sym_fns): Use default_symfile_segments.
	* symfile.c (find_sym_fns): Take a BFD and return the sym_fns.
	(init_objfile_sect_indices): Call symfile_find_segment_sections.
	(default_symfile_segments): New function.
	(syms_from_objfile): Update call to find_sym_fns.
	(symfile_get_segment_data, free_symfile_segment_data): New.
	(symfile_map_offsets_to_segments): New.
	(symfile_find_segment_sections): New.
	* symfile.h (struct symfile_segment_data): New.
	(struct sym_fns): Add sym_segments.
	(default_symfile_segments, symfile_get_segment_data)
	(free_symfile_segment_data): New prototypes.
	(symfile_map_offsets_to_segments): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add default_symfile_segments.
	* Makefile.in (COMMON_OBS): Remove elfread.o.
	(elf_internal_h): New.
	(elfread.o): Update.
	* configure.ac: Add elfread.o to COMMON_OBS if bfd/elf.o was
	compiled.
	* config.in, configure: Regenerated.
	* NEWS: Mention qOffsets changes.

	* gdb.texinfo (General Query Packets): Document qOffsets changes.

	* Makefile.def: Add dependency from configure-gdb to all-bfd.
	* Makefile.in: Regenerated.
@
text
@d1831 2
a1832 1
	    nlist.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1842 3
a1844 1
		  find_stab_function_addr (namestring, pst->filename, objfile);
d1899 2
a1900 1
	    nlist.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1910 3
a1912 1
		  find_stab_function_addr (namestring, pst->filename, objfile);
@


1.83
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SMASH_TEXT_ADDRESS): Replace by
	gdbarch_smash_text_address.
	* somread.c (som_symtab_read): Likewise.
	* elfread.c (record_minimal_symbol): Likewise.
	* dbxread.c (process_one_symbol): Likewise.
	* coffread.c (coff_symtab_read): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d2151 1
d2157 1
d3510 2
@


1.82
log
@	* dbxread.c (read_ofile_symtab): Move current_objfile
	clearing to after end_stabs.
@
text
@d2741 1
a2741 1
      valu = SMASH_TEXT_ADDRESS (valu);
@


1.81
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@a2610 2
  current_objfile = NULL;

d2626 2
@


1.80
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d2 1
a2 1
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.79
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d166 1
a166 1
  complaint (&symfile_complaints, "unknown symbol type %s", arg1);
d173 1
a173 1
	     "N_LBRAC/N_RBRAC symbol mismatch at symtab pos %d", arg1);
d180 1
a180 1
	     "\"repeated\" header file %s not previously seen, at symtab pos %d",
d969 1
a969 1
      complaint (&symfile_complaints, "bad string table offset in symbol %d",
d1171 1
a1171 1
	     "function `%s' appears to be defined outside of all compilation units",
d1567 1
a1567 1
			 "N_BINCL %s not in entries for any file, at symtab pos %d",
d1985 1
a1985 1
	    complaint (&symfile_complaints, "unknown symbol descriptor `%c'",
d2814 1
a2814 1
	      complaint (&symfile_complaints, "\
d2816 1
a2816 1
no enclosing block");
d2838 1
a2838 1
			     "block start larger than block end");
d3028 1
a3028 1
			    "failed internal consistency check");
d3133 1
a3133 1
			     "unmatched N_LBRAC before symtab pos %d", symnum);
@


1.78
log
@* dbxread.c (process_one_symbol): Fix a few coding standard
issues.  Improve code formatting.
@
text
@d224 1
a224 1
    error ("Can't find any code sections in symbol file");
d646 1
a646 1
    error ("Can't find .text section in symbol file");
d708 1
a708 1
	    error ("ridiculous string table size (%d bytes).",
d832 1
a832 1
    error ("Premature end of file reading symbol table");
d1420 1
a1420 1
	      error ("string table offset backs up at %d", symnum);
d2546 1
a2546 1
    error ("First symbol in segment of executable not a source symbol");
d3282 1
a3282 1
    error ("ridiculous string table size: %d bytes", stabstrsize);
d3379 1
a3379 1
    error ("ridiculous string table size: %d bytes", stabstrsize);
d3453 1
a3453 1
    error ("stabsect_build_psymtabs:  Found stabs (%s), but not string section (%s)",
d3462 1
a3462 1
    error ("Can't find %s section in symbol file", text_name);
d3473 1
a3473 1
    error ("ridiculous string table size: %d bytes", DBX_STRINGTAB_SIZE (objfile));
@


1.77
log
@* dbxread.c: Include "gdb_string.h".
(record_minimal_symbol, read_ofile_symtab): Replace
DEPRECATED_STREQ and DEPRECATED_STREQN with strcmp and strncmp.
* Makefile.in (dbxread.o): Update dependencies.
@
text
@d2638 7
a2644 8
   SECTION_OFFSETS is a set of amounts by which the sections of this object
   file were relocated when it was loaded into memory.
   Note that these section_offsets are not the 
   objfile->section_offsets but the pst->section_offsets.
   All symbols that refer
   to memory locations need to be offset by these amounts.
   OBJFILE is the object file from which we are reading symbols.
   It is used in end_symtab.  */
d2652 6
a2657 5
  /* This remembers the address of the start of a function.  It is used
     because in Solaris 2, N_LBRAC, N_RBRAC, and N_SLINE entries are
     relative to the current function's start address.  On systems
     other than Solaris 2, this just holds the SECT_OFF_TEXT value, and is
     used to relocate these symbol types rather than SECTION_OFFSETS.  */
d2660 2
a2661 2
  /* This holds the address of the start of a function, without the system
     peculiarities of function_start_offset.  */
d2670 2
a2671 2
  /* If this is nonzero, we've seen a non-gcc N_OPT symbol for this source
     file.  Used to detect the SunPRO solaris compiler.  */
d2679 6
a2684 3
    /* N_LBRAC, N_RBRAC and N_SLINE entries are not relative to the
       function start address, so just use the text offset.  */
    function_start_offset = ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));
d2686 2
a2687 2
  /* Something is wrong if we see real data before
     seeing a source file name.  */
d2705 2
a2706 2
	  /* This N_FUN marks the end of a function.  This closes off the
	     current block.  */
d2716 2
a2717 2
	     which may have an N_FUN stabs at the end of the function, but
	     no N_SLINE stabs.  */
d2739 1
a2739 1
      /* Relocate for dynamic loading */
d2792 4
a2795 4
         LBRAC/RBRAC block.  This macro should be nonzero if this
         is true.  DESC is N_DESC from the N_RBRAC symbol.
         GCC_P is true if we've detected the GCC_COMPILED_SYMBOL
         or the GCC2_COMPILED_SYMBOL.  */
d2801 1
a2801 1
         gcc or on a machine that puts them before the lbrack.  */
d2814 3
a2816 2
	      complaint (&symfile_complaints,
			 "misplaced N_LBRAC entry; discarding local symbols which have no enclosing block");
d2824 6
a2829 6
	  /* This is not the outermost LBRAC...RBRAC pair in the function,
	     its local symbols preceded it, and are the ones just recovered
	     from the context stack.  Define the block for them (but don't
	     bother if the block contains no symbols.  Should we complain
	     on blocks without symbols?  I can't think of any useful purpose
	     for them).  */
d2832 3
a2834 2
	      /* Muzzle a compiler bug that makes end < start.  (which
	         compilers?  Is this ever harmful?).  */
d2862 2
a2863 2
      /* This kind of symbol indicates the start of an object file.  */
      /* Relocate for dynamic loading */
d2868 4
a2871 5
      /* This type of symbol indicates the start of data
         for one source file.
         Finish the symbol table of the previous source file
         (if any) and start accumulating a new symbol table.  */
      /* Relocate for dynamic loading */
d2879 3
a2881 3
	     sanity checks).  If so, that one was actually the directory
	     name, and the current one is the real file name.
	     Patch things up. */
d2891 2
a2892 2
      /* Null name means this just marks the end of text for this .o file.
         Don't start a new symtab in this case.  */
d2905 4
a2908 5
      /* This type of symbol indicates the start of data for
         a sub-source-file, one whose contents were copied or
         included in the compilation of the main source file
         (whose name was given in the N_SO symbol.)  */
      /* Relocate for dynamic loading */
d2928 3
a2930 3
      /* This type of "symbol" really just records
         one line-number -- core-address correspondence.
         Enter it in the line list for this symbol table.  */
d2932 2
a2933 1
      /* Relocate for dynamic loading and for ELF acc fn-relative syms.  */
d2970 7
a2976 6
      /* The following symbol types need to have the appropriate offset added
         to their value; then we process symbol definitions in the name.  */

    case N_STSYM:		/* Static symbol in data seg */
    case N_LCSYM:		/* Static symbol in BSS seg */
    case N_ROSYM:		/* Static symbol in Read-only data seg */
d2978 9
a2986 8
         Solaris2's stabs-in-elf makes *most* symbols relative
         but leaves a few absolute (at least for Solaris 2.1 and version
         2.0.1 of the SunPRO compiler).  N_STSYM and friends sit on the fence.
         .stab "foo:S...",N_STSYM        is absolute (ld relocates it)
         .stab "foo:V...",N_STSYM        is relative (section base subtracted).
         This leaves us no choice but to search for the 'S' or 'V'...
         (or pass the whole section_offsets stuff down ONE MORE function
         call level, which we really don't want to do).  */
d2990 5
a2994 4
	/* .o files and NLMs have non-zero text seg offsets, but don't need
	   their static syms offset in this fashion.  XXX - This is really a
	   crock that should be fixed in the solib handling code so that I
	   don't have to work around it here. */
d3002 6
a3007 5
		   elfstab_offset_sections-type offset, but we *do* want
		   to add whatever solib.c passed to symbol_file_add as
		   addr (this is known to affect SunOS4, and I suspect ELF
		   too).  Since elfstab_offset_sections currently does not
		   muck with the text offset (there is no Ttext.text
d3009 3
a3011 3
		   elfstab_offset_sections ever starts dealing with the
		   text offset, and we still need to do this, we need to
		   invent a SECT_OFF_ADDR_KLUDGE or something.  */
d3016 2
a3017 1
	/* Since it's not the kludge case, re-dispatch to the right handler. */
d3027 2
a3028 1
	    internal_error (__FILE__, __LINE__, "failed internal consistency check");
d3032 2
a3033 2
    case_N_STSYM:		/* Static symbol in data seg */
    case N_DSLINE:		/* Source line number, data seg */
d3037 3
a3039 3
    case_N_LCSYM:		/* Static symbol in BSS seg */
    case N_BSLINE:		/* Source line number, bss seg */
      /*   N_BROWS:       overlaps with N_BSLINE */
d3043 1
a3043 1
    case_N_ROSYM:		/* Static symbol in Read-only data seg */
d3047 2
a3048 2
    case N_ENTRY:		/* Alternate entry point */
      /* Relocate for dynamic loading */
d3052 3
a3054 2
      /* The following symbol types we don't know how to process.  Handle
         them in a "default" way, but complain to people who care.  */
d3056 8
a3063 8
    case N_CATCH:		/* Exception handler catcher */
    case N_EHDECL:		/* Exception handler name */
    case N_PC:			/* Global symbol in Pascal */
    case N_M2C:		/* Modula-2 compilation unit */
      /*   N_MOD2:        overlaps with N_EHDECL */
    case N_SCOPE:		/* Modula-2 scope information */
    case N_ECOML:		/* End common (local name) */
    case N_NBTEXT:		/* Gould Non-Base-Register symbols??? */
d3071 2
a3072 2
      /* The following symbol types don't need the address field relocated,
         since it is either unused, or is absolute.  */
d3074 9
a3082 9
    case N_GSYM:		/* Global variable */
    case N_NSYMS:		/* Number of symbols (ultrix) */
    case N_NOMAP:		/* No map?  (ultrix) */
    case N_RSYM:		/* Register variable */
    case N_DEFD:		/* Modula-2 GNU module dependency */
    case N_SSYM:		/* Struct or union element */
    case N_LSYM:		/* Local symbol in stack */
    case N_PSYM:		/* Parameter variable */
    case N_LENG:		/* Length of preceding symbol type */
d3099 2
a3100 2
	      /* Deal with the SunPRO 3.0 compiler which omits the address
	         from N_FUN symbols.  */
d3102 2
a3103 1
		  && valu == ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile)))
d3108 6
a3113 5
		  /* find_stab_function_addr will return 0 if the minimal
		     symbol wasn't found.  (Unfortunately, this might also
		     be a valid address.)  Anyway, if it *does* return 0,
		     it is likely that the value was set correctly to begin
		     with... */
d3120 1
a3120 1
		/* For Solaris 2.0 compilers, the block addresses and
d3122 2
a3123 2
		   function.  On normal systems, and when using gcc on
		   Solaris 2.0, these addresses are just absolute, or
d3159 1
a3159 1
    case N_OPT:		/* Solaris 2:  Compiler options */
d3166 3
a3168 2
	      /* For now, stay with AUTO_DEMANGLING for g++ output, as we don't
		 know whether it will use the old style or v3 mangling.  */
d3194 6
a3199 6
    case N_OBJ:		/* Solaris 2:  Object file dir and name */
    case N_PATCH:	/* Solaris2: Patch Run Time Checker.  */
      /*   N_UNDF:                   Solaris 2:  file separator mark */
      /*   N_UNDF: -- we will never encounter it, since we only process one
         file's symbols at once.  */
    case N_ENDM:		/* Solaris 2:  End of module */
d3211 3
a3213 3
      /* Initialize symbol reference names and determine if this is 
         a definition.  If symbol reference is being defined, go 
         ahead and add it.  Otherwise, just return sym. */
a3229 1

@


1.76
log
@* dbxread.c (process_one_symbol): Do not adjust address of first
N_SLINE stab for a function for code generated by non-GCC
compilers.
@
text
@d59 1
d61 1
d486 1
a486 1
      if (name[8] == 'C' && DEPRECATED_STREQ ("__DYNAMIC", name))
d2508 1
a2508 1
	  if (DEPRECATED_STREQ (namestring, GCC_COMPILED_FLAG_SYMBOL))
d2510 1
a2510 1
	  else if (DEPRECATED_STREQ (namestring, GCC2_COMPILED_FLAG_SYMBOL))
d2514 1
a2514 1
	  if (DEPRECATED_STREQN (tempstring, "__gnu_compiled", 14))
d2580 1
a2580 1
	  if (DEPRECATED_STREQ (namestring, GCC_COMPILED_FLAG_SYMBOL))
d2582 1
a2582 1
	  else if (DEPRECATED_STREQ (namestring, GCC2_COMPILED_FLAG_SYMBOL))
@


1.75
log
@2004-10-23  Andrew Cagney  <cagney@@gnu.org>

	* objfiles.h (struct objfile): Rename obj_private to
	deprecated_obj_private, sym_private to deprecated_sym_private, and
	sym_stab_info to deprecated_sym_stab_info.
	* gdb-stabs.h: Update.
	* elfread.c: Update.
	* dbxread.c: Update.
	* coffread.c: Update.
	* xcoffread.c: Update.
	* symfile.c: Update.
	* somread.c: Update.
	* nlmread.c: Update.
	* mdebugread.c: Update.
	* hpread.c: Update.
	* coffread.c: Update.
@
text
@d2930 14
a2943 2
      /* If this is the first SLINE note in the function, record it at
	 the start of the function instead of at the listed location.  */
d2946 4
a2949 1
	  record_line (current_subfile, desc, last_function_start);
@


1.74
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@d626 1
a626 1
  objfile->sym_stab_info = (struct dbx_symfile_info *)
d628 1
a628 1
  memset (objfile->sym_stab_info, 0, sizeof (struct dbx_symfile_info));
d736 1
a736 1
  if (objfile->sym_stab_info != NULL)
d750 1
a750 1
      xfree (objfile->sym_stab_info);
d3242 1
a3242 1
  info = objfile->sym_stab_info;
d3334 1
a3334 1
  info = objfile->sym_stab_info;
d3426 1
a3426 1
  objfile->sym_stab_info = (struct dbx_symfile_info *)
d3428 1
a3428 1
  memset (objfile->sym_stab_info, 0, sizeof (struct dbx_symfile_info));
@


1.73
log
@2004-09-07  Andrew Cagney  <cagney@@gnu.org>

	* vx-share/wait.h: Delete #ifdef USG.
	* utils.c (request_quit): Ditto.
	* tui/tui.c (tui_reset): Ditto.
	* remote.c: Ditto.
	* remote-sds.c: Ditto.
	* remote-rdi.c: Ditto.
	* mdebugread.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* infttrace.c: Ditto.
	* infptrace.c: Ditto.
	* i386v-nat.c: Ditto.
	* exec.c: Ditto.
	* dbxread.c: Ditto.
	* core-aout.c: Ditto.
@
text
@a56 1
#include "language.h"		/* Needed for local_hex_string */
d2099 1
a2099 1
	  unknown_symtype_complaint (local_hex_string (nlist.n_type));
d3040 1
a3040 1
      unknown_symtype_complaint (local_hex_string (type));
@


1.72
log
@2004-08-10  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (xmfree): Delete.
	* utils.c (xmfree): Delete function.
	(xfree): Inline calls to xmfree and mfree.
	* symmisc.c (free_symtab_block, free_symtab): Use xfree.
	* symfile.c (reread_symbols, init_psymbol_list): Ditto.
	* source.c (forget_cached_source_info, find_and_open_source): Ditto.
	* somread.c (som_symfile_finish): Ditto.
	* objfiles.c (allocate_objfile, free_objfile):
	* nlmread.c (nlm_symfile_finish): Ditto.
	* hpread.c (hpread_symfile_finish): Ditto.
	* elfread.c (free_elfinfo, elf_symfile_finish): Ditto.
	* dbxread.c (dbx_symfile_finish, free_bincl_list): Ditto.
	* coffread.c (coff_symfile_finish): Ditto.
@
text
@d40 1
a40 1
#if defined(USG) || defined(__CYGNUSCLIB__)
@


1.71
log
@2004-08-10  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (xmrealloc): Delete.
	* utils.c (xmrealloc): Delete.
	(xrealloc): Inline calls to xmrealloc, mmalloc and mrealloc.
	* symmisc.c (extend_psymbol_list): Use xrealloc.
	* source.c (find_source_lines): Ditto.
	* hpread.c (hpread_lookup_type): Ditto.
	* dbxread.c (add_bincl_to_list): Ditto.
@
text
@d751 1
a751 1
      xmfree (objfile->md, objfile->sym_stab_info);
d940 1
a940 1
  xmfree (objfile->md, bincl_list);
@


1.70
log
@2004-08-10  Andrew Cagney  <cagney@@gnu.org>

	* utils.c (xmmalloc): Delete.
	(xmalloc): Inline xmmalloc and mmalloc calls.
	(msavestring): Use xmalloc.
	* defs.h (xmmalloc): Delete declaration.
	* xcoffread.c (xcoff_symfile_init): Use xmalloc instead of
	xmmalloc.
	* symmisc.c (extend_psymbol_list): Ditto.
	* symfile.c (init_psymbol_list): Ditto.
	* source.c (find_source_lines): Ditto.
	* hpread.c (hpread_symfile_init, hpread_lookup_type): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* dbxread.c (dbx_symfile_init, init_bincl_list): Ditto.
	* coffread.c (coff_symfile_init): Ditto.
@
text
@d908 2
a909 2
	xmrealloc (pst->objfile->md, (char *) bincl_list,
		   bincls_allocated * sizeof (struct header_file_location));
@


1.69
log
@* dbxread.c (process_one_symbol) [PCC_SOL_BROKEN]: Remove dead
code.
@
text
@d628 1
a628 1
    xmmalloc (objfile->md, sizeof (struct dbx_symfile_info));
d895 1
a895 1
    xmmalloc (objfile->md, bincls_allocated * sizeof (struct header_file_location));
@


1.68
log
@* dbxread.c (process_one_symbol) [SUN_FIXED_LBRAC_BUG]: Remove
dead code.
@
text
@a2870 8
#ifdef PCC_SOL_BROKEN
      /* pcc bug, occasionally puts out SO for SOL.  */
      if (context_stack_depth > 0)
	{
	  start_subfile (name, NULL);
	  break;
	}
#endif
@


1.67
log
@Add the -file-list-exec-source-files command to MI.
@
text
@a2650 11
#ifdef SUN_FIXED_LBRAC_BUG
  /* If SUN_FIXED_LBRAC_BUG is defined, then it tells us whether we need
     to correct the address of N_LBRAC's.  If it is not defined, then
     we never need to correct the addresses.  */

  /* This records the last pc address we've seen.  We depend on there being
     an SLINE or FUN or SO before the first LBRAC, since the variable does
     not get reset in between reads of different symbol files.  */
  static CORE_ADDR last_pc_address;
#endif

a2757 8
#ifdef SUN_FIXED_LBRAC_BUG
      if (!SUN_FIXED_LBRAC_BUG && valu < last_pc_address)
	{
	  /* Patch current LBRAC pc value to match last handy pc value */
	  complaint (&symfile_complaints, "bad block start address patched");
	  valu = last_pc_address;
	}
#endif
a2870 4
#ifdef SUN_FIXED_LBRAC_BUG
      last_pc_address = valu;	/* Save for SunOS bug circumcision */
#endif

a2938 3
#ifdef SUN_FIXED_LBRAC_BUG
      last_pc_address = valu;	/* Save for SunOS bug circumcision */
#endif
a3097 50
#ifdef SUN_FIXED_LBRAC_BUG
	      /* The Sun acc compiler, under SunOS4, puts out
	         functions with N_GSYM or N_STSYM.  The problem is
	         that the address of the symbol is no good (for N_GSYM
	         it doesn't even attept an address; for N_STSYM it
	         puts out an address but then it gets relocated
	         relative to the data segment, not the text segment).
	         Currently we can't fix this up later as we do for
	         some types of symbol in scan_file_globals.
	         Fortunately we do have a way of finding the address -
	         we know that the value in last_pc_address is either
	         the one we want (if we're dealing with the first
	         function in an object file), or somewhere in the
	         previous function. This means that we can use the
	         minimal symbol table to get the address.  */

	      /* Starting with release 3.0, the Sun acc compiler,
	         under SunOS4, puts out functions with N_FUN and a value
	         of zero. This gets relocated to the start of the text
	         segment of the module, which is no good either.
	         Under SunOS4 we can deal with this as N_SLINE and N_SO
	         entries contain valid absolute addresses.
	         Release 3.0 acc also puts out N_OPT entries, which makes
	         it possible to discern acc from cc or gcc.  */

	      if (type == N_GSYM || type == N_STSYM
		  || (type == N_FUN
		      && n_opt_found && !block_address_function_relative))
		{
		  struct minimal_symbol *m;
		  int l = colon_pos - name;

		  m = lookup_minimal_symbol_by_pc (last_pc_address);
		  if (m && strncmp (DEPRECATED_SYMBOL_NAME (m), name, l) == 0
		      && DEPRECATED_SYMBOL_NAME (m)[l] == '\0')
		    /* last_pc_address was in this function */
		    valu = SYMBOL_VALUE (m);
		  else if (m && DEPRECATED_SYMBOL_NAME (m + 1)
			   && strncmp (DEPRECATED_SYMBOL_NAME (m + 1), name, l) == 0
			   && DEPRECATED_SYMBOL_NAME (m + 1)[l] == '\0')
		    /* last_pc_address was in last function */
		    valu = SYMBOL_VALUE (m + 1);
		  else
		    /* Not found - use last_pc_address (for finish_block) */
		    valu = last_pc_address;
		}

	      last_pc_address = valu;	/* Save for SunOS bug circumcision */
#endif

@


1.66
log
@* coffread.c (coff_symfile_read): Prevent mixed debugging formats
from corrupting/reinitializing the psymtab.  Support DWARF 2 frame
info.
* dbxread.c (elfstab_build_psymtabs): Remove bogus comment.
@
text
@d1460 1
d1518 6
a1523 1
	      continue;		/* Simply ignore directory name SOs */
d1530 1
d1536 3
@


1.65
log
@2004-05-07  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Delete unused fields
	deprecated_entry_file_lowpc and deprecated_entry_file_highpc.
	* objfiles.c (init_entry_point_info, objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab, read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d3379 1
a3379 2
   This ELF file has already been processed to get its minimal symbols,
   and any DWARF symbols that were in it.
@


1.64
log
@2004-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (init_entry_point_info, entry_point_address): Move
	from here...
	* objfiles.c (init_entry_point_info, entry_point_address):..to
	here.
	* symfile.h (init_entry_point_info, entry_point_address): Remove
	prototypes.
	* objfiles.h (init_entry_point_info, entry_point_address):Add
	prototypes.
	* cris-tdep.c: Remove include of symfile.h. Add include of
	objfiles.h.
	* infcall.c: Ditto.
	* mcore-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
 	* v850-tdep.c: Ditto.
	* arm-tdep.c: Remove include of symfile.h.
	* blockframe.c: Ditto.
	* coffread.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* frv-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* mipsread.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* s390-tdep.c: Ditto.
	* sh-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* gdbarch.sh: Remove include of symfile.h.
	* gdbarch.c: Regenerate.
	* solib-irix.c (enable_break): Use entry_point_address().
	Add comment about include file.
	* xcoffread.c: Add comment about include file.
	* Makefile.in (arm-tdep.o, blockframe.o, coffread.o, cris-tdep.o)
	(dbxread.o, dwarf2read.o, dwarfread.o, frv-tdep.o, gdbarch.o)
	(ia64-tdep.o, infcall.o, mcore-tdep.o, mdebugread.o, mipsread.o)
	(mn10300-tdep.o, rs6000-nat.o, s390-tdep.o, sh64-tdep.o)
	(sh-tdep.o, v850-tdep.o, xstormy16-tdep.o): Update dependencies.
@
text
@a1360 6
	    if (objfile->ei.entry_point < nlist.n_value &&
		objfile->ei.entry_point >= last_o_file_start)
	      {
		objfile->ei.deprecated_entry_file_lowpc = last_o_file_start;
		objfile->ei.deprecated_entry_file_highpc = nlist.n_value;
	      }
a2095 10
  if (DBX_SYMCOUNT (objfile) > 0	/* We have some syms */
      /*FIXME, does this have a bug at start address 0? */
      && last_o_file_start
      && objfile->ei.entry_point < nlist.n_value
      && objfile->ei.entry_point >= last_o_file_start)
    {
      objfile->ei.deprecated_entry_file_lowpc = last_o_file_start;
      objfile->ei.deprecated_entry_file_highpc = nlist.n_value;
    }

@


1.64.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d40 1
a40 1
#if defined(__CYGNUSCLIB__)
d57 1
d628 1
a628 1
    xmalloc (sizeof (struct dbx_symfile_info));
d751 1
a751 1
      xfree (objfile->sym_stab_info);
d895 1
a895 1
    xmalloc (bincls_allocated * sizeof (struct header_file_location));
d908 2
a909 2
	xrealloc ((char *) bincl_list,
		  bincls_allocated * sizeof (struct header_file_location));
d940 1
a940 1
  xfree (bincl_list);
d1361 6
a1465 1
	    static char *dirname_nso;
d1523 1
a1523 6
	      {
		/* Save the directory name SOs locally, then save it into
		   the psymtab when it's created below. */
	        dirname_nso = namestring;
	        continue;		
	      }
a1529 1
	      {
a1534 3
		pst->dirname = dirname_nso;
		dirname_nso = NULL;
	      }
d2096 1
a2096 1
	  unknown_symtype_complaint (hex_string (nlist.n_type));
d2102 10
d2657 11
d2775 8
d2896 12
d2968 3
d3081 1
a3081 1
      unknown_symtype_complaint (hex_string (type));
d3130 50
d3395 2
a3396 1
   This ELF file has already been processed to get its minimal symbols.
@


1.63
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (dbx_symfile_init, start_psymtab, end_psymtab,
	coffstab_build_psymtabs, elfstab_build_psymtabs)
	(stabsect_build_psymtabs): Replace psymbol_obstack with
	objfile_obstack.
	* dwarf2-frame.c (decode_frame_entry_1): Ditto.
	* dwarf2read.c (dwarf2_build_psymtabs_hard, dwarf2_read_section):
	Ditto.
	* dwarfread.c (scan_compilation_units): Ditto.
	* elfread.c (elfstab_offset_sections): Ditto.
	* hppa-tdep.c (read_unwind_info): Ditto.
	* hpread.c (hpread_build_psymtabs, hpread_start_psymtab)
	(hpread_end_psymtab): Ditto.
	* mdebugread.c (mdebug_build_psymtabs, add_pending)
	(parse_partial_symbols, new_psymtab, elfmdebug_build_psymtabs):
	Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* objfiles.c (add_to_objfile_sections)
	(build_objfile_section_table): Ditto.
	(allocate_objfile): Remove init of psymbol_obstack.
	(free_objfile): Remove freeing of psymbol_obstack.
	* objfiles.h (struct objfile): Remove field
	psymbol_obstack. Update comments.
	* pa64solib.c (pa64_solib_add_solib_objfile): Replace
	psymbol_obstack with objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
        psymbol_obstack.
	* somread.c (som_symfile_offsets, init_import_symbols)
	(init_export_symbols): Replace psymbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
	* symfile.c (default_symfile_offsets, syms_from_objfile)
	(reread_symbols): Remove freeing and init of psymbol_obstack.
	(cashier_psymtab): Update comment.
	* symmisc.c (print_objfile_statistics): Don't report stats for
	psymbol obstack.
	* symtab.h (struct general_symbol_info, struct partial_symtab):
	Update comments.
	* xcoffread.c (xcoff_start_psymtab, xcoff_end_psymtab, swap_sym)
	(xcoff_symfile_offsets): Replace psymbol_obstack with
	objfile_obstack.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003.
a51 1
#include "symfile.h"
@


1.62
log
@* dbxread.c (read_dbx_symtab): Ignore N_PATCH stabs instead of
complaining.
(process_one_symbol): Deal with N_PATCH stabs.
@
text
@d654 2
a655 3
  /* Read the string table and stash it away in the psymbol_obstack.  It is
     only needed as long as we need to expand psymbols into full symbols,
     so when we blow away the psymbol the string table goes away as well.
d660 1
a660 1
     that we put in on the psymbol_obstack, we can't do this since gdb gets
d712 1
a712 1
	    (char *) obstack_alloc (&objfile->psymbol_obstack,
d2149 1
a2149 1
    obstack_alloc (&objfile->psymbol_obstack, sizeof (struct symloc));
d2271 1
a2271 1
	obstack_alloc (&objfile->psymbol_obstack,
d2287 1
a2287 1
	(char *) obstack_alloc (&objfile->psymbol_obstack,
d2297 1
a2297 1
	obstack_alloc (&objfile->psymbol_obstack,
d3346 1
a3346 1
    obstack_alloc (&objfile->psymbol_obstack, stabstrsize + 1);
d3444 1
a3444 1
    obstack_alloc (&objfile->psymbol_obstack, stabstrsize + 1);
d3538 1
a3538 1
    obstack_alloc (&objfile->psymbol_obstack, DBX_STRINGTAB_SIZE (objfile) + 1);
@


1.61
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@d2090 1
d3257 1
@


1.60
log
@2003-11-07  Michael Chastain  <mec@@shout.net>

	* symtab.h (struct minimal_symbol): Add size.
	* dbxread.c: Use it.
	* elfread.c: (record_minimal_symbol_and_info): Do not use info.
	Rename to record_minimal_symbol.
	(elf_symtab_read): Set MSYMBOL_SIZE explicitly.
	* minsyms.c (prim_record_minimal_symbol_and_info): Initialize MSYMBOL_SIZE.
	(install_minimal_symbols): Ditto.
	* objfiles.c (terminate_minimal_symbol_table): Ditto.
	* arm-tdep.c: Delete unused MSYMBOL_SIZE.
	* m68hc11-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
@
text
@d486 1
a486 1
      if (name[8] == 'C' && STREQ ("__DYNAMIC", name))
d2514 1
a2514 1
	  if (STREQ (namestring, GCC_COMPILED_FLAG_SYMBOL))
d2516 1
a2516 1
	  else if (STREQ (namestring, GCC2_COMPILED_FLAG_SYMBOL))
d2520 1
a2520 1
	  if (STREQN (tempstring, "__gnu_compiled", 14))
d2586 1
a2586 1
	  if (STREQ (namestring, GCC_COMPILED_FLAG_SYMBOL))
d2588 1
a2588 1
	  else if (STREQ (namestring, GCC2_COMPILED_FLAG_SYMBOL))
@


1.59
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@a66 8
/* This macro returns the size field of a minimal symbol, which is normally
   stored in the "info" field.  The macro can be overridden for specific
   targets (e.g. MIPS16) that use the info field for other purposes.  */
#ifndef MSYMBOL_SIZE
#define MSYMBOL_SIZE(msym) ((long) MSYMBOL_INFO (msym))
#endif


@


1.58
log
@2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* valops.c (destructor_name_p): Replace STREQN with strncmp.
	* top.c (command_line_input): Ditto.
	* objc-exp.y (yylex): Ditto.
	* minsyms.c (prim_record_minimal_symbol_and_info): Ditto.
	* jv-exp.y (yylex): Ditto.
	* f-exp.y (yylex): Ditto.
	* event-top.c (command_line_handler): Ditto.
	* environ.c (get_in_environ): Ditto.
	(set_in_environ): Ditto.
	* dwarfread.c (handle_producer): Ditto.
	* dbxread.c (process_one_symbol): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* c-exp.y (yylex): Ditto.

2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* mi-cmd-var.c (mi_cmd_var_set_format): Replace STREQN with
	strncmp.
@
text
@d355 1
a355 1
    if (STREQ (p[i].name, name) && instance == p[i].instance)
d938 1
a938 1
	&& STREQ (name, bincl->name))
d1610 1
a1610 1
	    if (pst && STREQ (namestring, pst->filename))
d1615 1
a1615 1
		if (STREQ (namestring, psymtab_include_list[i]))
d3232 1
a3232 1
	  if (STREQ (name, GCC2_COMPILED_FLAG_SYMBOL))
@


1.57
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c, breakpoint.h: Remove obsolete code and comments.
	* buildsym.c, dbxread.c, gdbtypes.c, mdebugread.c: Ditto.
	* monitor.c, sparc-tdep.c, stabsread.c: Ditto.
	* stabsread.h, xcoffread.c: Ditto.
@
text
@d3172 1
a3172 1
		  if (m && STREQN (DEPRECATED_SYMBOL_NAME (m), name, l)
d3177 1
a3177 1
			   && STREQN (DEPRECATED_SYMBOL_NAME (m + 1), name, l)
@


1.56
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@a260 4
#if 0 /* OBSOLETE CFront */
// OBSOLETE static void process_now (struct objfile *);
#endif /* OBSOLETE CFront */

a771 101
#if 0 /* OBSOLETE CFront */
// OBSOLETE  /* cont_elem is used for continuing information in cfront.
// OBSOLETE     It saves information about which types need to be fixed up and 
// OBSOLETE     completed after all the stabs are read.  */
// OBSOLETE  struct cont_elem
// OBSOLETE    {
// OBSOLETE      /* sym and stabstring for continuing information in cfront */
// OBSOLETE      struct symbol *sym;
// OBSOLETE      char *stabs;
// OBSOLETE      /* state dependencies (statics that must be preserved) */
// OBSOLETE      int sym_idx;
// OBSOLETE      int sym_end;
// OBSOLETE      int symnum;
// OBSOLETE      int (*func) (struct objfile *, struct symbol *, char *);
// OBSOLETE      /* other state dependencies include:
// OBSOLETE         (assumption is that these will not change since process_now FIXME!!)
// OBSOLETE         stringtab_global
// OBSOLETE         n_stabs
// OBSOLETE         objfile
// OBSOLETE         symfile_bfd */
// OBSOLETE    };

// OBSOLETE  static struct cont_elem *cont_list = 0;
// OBSOLETE  static int cont_limit = 0;
// OBSOLETE  static int cont_count = 0;

// OBSOLETE  /* Arrange for function F to be called with arguments SYM and P later
// OBSOLETE     in the stabs reading process.  */
// OBSOLETE  void
// OBSOLETE  process_later (struct symbol *sym, char *p,
// OBSOLETE  	       int (*f) (struct objfile *, struct symbol *, char *))
// OBSOLETE  {

// OBSOLETE    /* Allocate more space for the deferred list.  */
// OBSOLETE    if (cont_count >= cont_limit - 1)
// OBSOLETE      {
// OBSOLETE        cont_limit += 32;		/* chunk size */

// OBSOLETE        cont_list
// OBSOLETE  	= (struct cont_elem *) xrealloc (cont_list,
// OBSOLETE  					 (cont_limit
// OBSOLETE  					  * sizeof (struct cont_elem)));
// OBSOLETE        if (!cont_list)
// OBSOLETE  	error ("Virtual memory exhausted\n");
// OBSOLETE      }

// OBSOLETE    /* Save state variables so we can process these stabs later.  */
// OBSOLETE    cont_list[cont_count].sym_idx = symbuf_idx;
// OBSOLETE    cont_list[cont_count].sym_end = symbuf_end;
// OBSOLETE    cont_list[cont_count].symnum = symnum;
// OBSOLETE    cont_list[cont_count].sym = sym;
// OBSOLETE    cont_list[cont_count].stabs = p;
// OBSOLETE    cont_list[cont_count].func = f;
// OBSOLETE    cont_count++;
// OBSOLETE  }

// OBSOLETE  /* Call deferred funtions in CONT_LIST.  */

// OBSOLETE  static void
// OBSOLETE  process_now (struct objfile *objfile)
// OBSOLETE  {
// OBSOLETE    int i;
// OBSOLETE    int save_symbuf_idx;
// OBSOLETE    int save_symbuf_end;
// OBSOLETE    int save_symnum;
// OBSOLETE    struct symbol *sym;
// OBSOLETE    char *stabs;
// OBSOLETE    int err;
// OBSOLETE    int (*func) (struct objfile *, struct symbol *, char *);

// OBSOLETE    /* Save the state of our caller, we'll want to restore it before
// OBSOLETE       returning.  */
// OBSOLETE    save_symbuf_idx = symbuf_idx;
// OBSOLETE    save_symbuf_end = symbuf_end;
// OBSOLETE    save_symnum = symnum;

// OBSOLETE    /* Iterate over all the deferred stabs.  */
// OBSOLETE    for (i = 0; i < cont_count; i++)
// OBSOLETE      {
// OBSOLETE        /* Restore the state for this deferred stab.  */
// OBSOLETE        symbuf_idx = cont_list[i].sym_idx;
// OBSOLETE        symbuf_end = cont_list[i].sym_end;
// OBSOLETE        symnum = cont_list[i].symnum;
// OBSOLETE        sym = cont_list[i].sym;
// OBSOLETE        stabs = cont_list[i].stabs;
// OBSOLETE        func = cont_list[i].func;

// OBSOLETE        /* Call the function to handle this deferrd stab.  */
// OBSOLETE        err = (*func) (objfile, sym, stabs);
// OBSOLETE        if (err)
// OBSOLETE  	error ("Internal error: unable to resolve stab.\n");
// OBSOLETE      }

// OBSOLETE    /* Restore our caller's state.  */
// OBSOLETE    symbuf_idx = save_symbuf_idx;
// OBSOLETE    symbuf_end = save_symbuf_end;
// OBSOLETE    symnum = save_symnum;
// OBSOLETE    cont_count = 0;
// OBSOLETE  }
#endif /* OBSOLETE CFront */

a1735 16
#if 0 /* OBSOLETE CFront */
// OBSOLETE  		/* The semantics of C++ state that "struct foo { ... }"
// OBSOLETE  		   also defines a typedef for "foo".  Unfortuantely, cfront
// OBSOLETE  		   never makes the typedef when translating from C++ to C.
// OBSOLETE  		   We make the typedef here so that "ptype foo" works as
// OBSOLETE  		   expected for cfront translated code.  */
// OBSOLETE  		else if (psymtab_language == language_cplus)
// OBSOLETE  		  {
// OBSOLETE  		    /* Also a typedef with the same name.  */
// OBSOLETE  		    add_psymbol_to_list (namestring, p - namestring,
// OBSOLETE  					 VAR_DOMAIN, LOC_TYPEDEF,
// OBSOLETE  					 &objfile->static_psymbols,
// OBSOLETE  					 nlist.n_value, 0,
// OBSOLETE  					 psymtab_language, objfile);
// OBSOLETE  		  }
#endif /* OBSOLETE CFront */
a1969 5
#if 0 /* OBSOLETE CFront */
// OBSOLETE  	    /* added to support cfront stabs strings */
// OBSOLETE  	  case 'Z':		/* for definition continuations */
// OBSOLETE  	  case 'P':		/* for prototypes */
#endif /* OBSOLETE CFront */
a2640 5
#if 0 /* OBSOLETE CFront */
// OBSOLETE    /* Process items which we had to "process_later" due to dependencies 
// OBSOLETE       on other stabs.  */
// OBSOLETE    process_now (objfile);
#endif /* OBSOLETE CFront */
@


1.55
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d755 2
a756 2
	  register int i = N_HEADER_FILES (objfile);
	  register struct header_file *hfiles = HEADER_FILES (objfile);
d1718 1
a1718 1
	      register int i;
@


1.54
log
@* dbxread.c (read_dbx_symtab): Don't report an internal error if
the file has no .data, .bss, or .rodata sections.  Instead wait
until we see a variable alleged to live in one of those sections.
@
text
@d355 2
a356 2
  register struct header_file *p = HEADER_FILES (current_objfile);
  register int i;
d381 2
a382 2
  register int i;
  register struct header_file *hfile;
d424 1
a424 1
  register struct header_file *f = &HEADER_FILES (current_objfile)[real_filenum];
d1295 1
a1295 1
  register struct external_nlist *bufp = 0;	/* =0 avoids gcc -Wall glitch */
d1300 1
a1300 1
  register char *namestring;
d2591 2
a2592 2
  register char *namestring;
  register struct external_nlist *bufp;
d2596 1
a2596 1
  register bfd *abfd;
d2808 1
a2808 1
  register struct context_stack *new;
@


1.53
log
@* dbxread.c (read_dbx_symtab): If we have no .data section and no
.bss section, presume that any variables we find live in the
.rodata section.
@
text
@d1385 6
a1390 1
  gdb_assert (data_sect_index != -1);
@


1.52
log
@* dbxread.c (read_dbx_symtab): Add FIXME about finding section
offsets for global and static variables.
@
text
@d1383 2
@


1.51
log
@* dbxread.c (read_dbx_symtab): The N_DATA and N_DATA | N_EXT
symbol types are, by definition, in the .data section, so it is
correct to use SECT_OFF_DATA (objfile) here, not data_sect_index.
If there is no .data section, there should be no N_DATA or N_DATA
| N_EXT symbols.
@
text
@d1360 20
a1379 1
  /* If the objfile has no .data section, try using the .bss section.  */
@


1.50
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d1412 1
a1412 1
	  nlist.n_value += ANOFFSET (objfile->section_offsets, data_sect_index);
d1479 1
a1479 1
	  nlist.n_value += ANOFFSET (objfile->section_offsets, data_sect_index);
@


1.49
log
@* Makefile.in (dbxread.o): Note new dependency on $(gdb_assert_h).
* dbxread.c: #include "gdb_assert.h".
(read_dbx_symtab): If the objfile has no .data section, use the
section index for the .bss section instead.
@
text
@d1453 2
a1454 2
		objfile->ei.entry_file_lowpc = last_o_file_start;
		objfile->ei.entry_file_highpc = nlist.n_value;
d2217 2
a2218 2
      objfile->ei.entry_file_lowpc = last_o_file_start;
      objfile->ei.entry_file_highpc = nlist.n_value;
@


1.48
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* block.h (BLOCK_SHOULD_SORT): Delete.
	* symtab.c (lookup_block_symbol): Don't worry about sorted linear
	blocks.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Ditto.
	* symfile.h: Delete sort_symtabs_syms and sort_block_syms
	declarations.
	* coffread.c (coff_symfile_read): Don't call sort_symtab_syms.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
@
text
@d61 1
d1308 1
d1360 6
d1412 1
a1412 1
	  nlist.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d1479 1
a1479 1
	  nlist.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d1768 1
a1768 1
	    nlist.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d1779 1
a1779 1
	    nlist.n_value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
@


1.48.4.1
log
@Merge from mainline:

2003-09-12  Jim Blandy  <jimb@@redhat.com>

* dbxread.c (read_dbx_symtab): Don't report an internal error if
the file has no .data, .bss, or .rodata sections.  Instead wait
until we see a variable alleged to live in one of those sections.

2003-09-12  Jim Blandy  <jimb@@redhat.com>

* dbxread.c (read_dbx_symtab): If we have no .data section and no
.bss section, presume that any variables we find live in the
.rodata section.

2003-09-12  Jim Blandy  <jimb@@redhat.com>

* dbxread.c (read_dbx_symtab): Add FIXME about finding section
offsets for global and static variables.

2003-09-09  Jim Blandy  <jimb@@redhat.com>

* dbxread.c (read_dbx_symtab): The N_DATA and N_DATA | N_EXT
symbol types are, by definition, in the .data section, so it is
correct to use SECT_OFF_DATA (objfile) here, not data_sect_index.
If there is no .data section, there should be no N_DATA or N_DATA
| N_EXT symbols.

2003-07-10  Jim Blandy  <jimb@@redhat.com>

* Makefile.in (dbxread.o): Note new dependency on $(gdb_assert_h).
* dbxread.c: #include "gdb_assert.h".
(read_dbx_symtab): If the objfile has no .data section, use the
section index for the .bss section instead.
@
text
@a60 1
#include "gdb_assert.h"
a1306 1
  int data_sect_index;
a1357 32
  /* FIXME: jimb/2003-09-12: We don't apply the right section's offset
     to global and static variables.  The stab for a global or static
     variable doesn't give us any indication of which section it's in,
     so we can't tell immediately which offset in
     objfile->section_offsets we should apply to the variable's
     address.

     We could certainly find out which section contains the variable
     by looking up the variable's unrelocated address with
     find_pc_section, but that would be expensive; this is the
     function that constructs the partial symbol tables by examining
     every symbol in the entire executable, and it's
     performance-critical.  So that expense would not be welcome.  I'm
     not sure what to do about this at the moment.

     What we have done for years is to simply assume that the .data
     section's offset is appropriate for all global and static
     variables.  Recently, this was expanded to fall back to the .bss
     section's offset if there is no .data section, and then to the
     .rodata section's offset.  */
  data_sect_index = objfile->sect_index_data;
  if (data_sect_index == -1)
    data_sect_index = SECT_OFF_BSS (objfile);
  if (data_sect_index == -1)
    data_sect_index = SECT_OFF_RODATA (objfile);

  /* If data_sect_index is still -1, that's okay.  It's perfectly fine
     for the file to have no .data, no .bss, and no .text at all, if
     it also has no global or static variables.  If it does, we will
     get an internal error from an ANOFFSET macro below when we try to
     use data_sect_index.  */

d1760 1
a1760 1
	    nlist.n_value += ANOFFSET (objfile->section_offsets, data_sect_index);
d1771 1
a1771 1
	    nlist.n_value += ANOFFSET (objfile->section_offsets, data_sect_index);
@


1.47
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_push_return_address): Make static.
	(xstormy16_save_dummy_frame_tos): Make static.
	(_initialize_xstormy16_tdep): Add declaration.
	* vax-tdep.c (_initialize_vax_tdep): Add declaration.
	* v850-tdep.c: Make local functions static.
	(_initialize_v850_tdep): Add declaration.
	* sparc-tdep.c: Make local functions static.
	(_initialize_sparc_tdep): Add declaration.
	* sh-tdep.c: Make local functions static.
	(_initialize_sh_tdep): Add declaration.
	* sh3-rom.c (_initialize_sh3_rom): Add declaration.
	* s390-tdep.c: Make local functions static.
	(_initialize_s390_tdep): Add declaration.
	* dbxread.c (find_stab_function_addr): Make static.
	* ppc-bdm.c (_initialize_bdm_ppc): Add declaration.
	* ocd.c (_initialize_remote_ocd): Add declaration.
	* dink32-rom.c (_initialize_dink32_rom): Add declaration.
	* ppcbug-rom.c (_initialize_ppcbug_rom): Add declaration.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Add declaration.
	* ns32knbsd-tdep.c (_initialize_ns32knbsd_tdep): Add declaration.
	* mips-tdep.c (_initialize_mips_tdep): Add declaration.
	* remote-array.c (_initialize_array): Add declaration.
	(_initialize_remote_monitors): Add declaration.
	* remote-mips.c: Make local functions static.
	(_initialize_remote_mips): Add declaration.
	* mcore-tdep.c: Make all local functions static.
	(_initialize_mcore_tdep): Add declaration.
	* dbug-rom.c (_initialize_dbug_rom): Add declaration.
	* abug-rom.c (_initialize_abug_rom): Add declaration.
	* rom68k-rom.c (_initialize_rom68k): Add declaration.
	* cpu32bug-rom.c (_initialize_cpu32bug_rom): Add declaration.
	* m68k-tdep.c (_initialize_m68k_tdep): Add declaration.
	* remote-est.c (_initialize_est): Add declaration.
	* m68hc11-tdep.c (_initialize_m68hc11_tdep): Add declaration.
	(m68hc11_call_dummy_address): Make static.
	* ia64-tdep.c: Make local functions static.
	(_initialize_ia64_tdep): Add declaration.
	* solib-legacy.c (_initialize_svr4_lm): Add declaration.
	* monitor.c (monitor_wait_filter): Make static.
	(_initialize_remote_monitors): Add declaration.
	* remote-hms.c (_initialize_remote_hms): Add declaration.
	* remote-e7000.c (fetch_regs_from_dump): Make static.
	(expect_n): Make static.
	(_initialize_remote_e7000): Add declaration.
	* ser-e7kpc.c: Always include "defs.h".
	(_initialize_ser_e7000pc): Add declaration.
	* h8300-tdep.c (_initialize_h8300_tdep): Add declaration.
	* cris-tdep.c: Make all but one function static.
	(_initialize_cris_tdep): Add declaration.
	* solib-svr4.c (_initialize_svr4_solib): Add declaration.
	* solib.c (update_solib_list): Make static.
	(_initialize_solib): Add declaration.
	* avr-tdep.c (avr_breakpoint_from_pc): Make static.
	(_initialize_avr_tdep): Add declaration.
	* remote-rdi.c (voiddummy): Make static.
	(_initialize_remote_rdi): Add declaration.
	* arm-tdep.c (_initialize_arm_tdep): Add declaration.
	* remote-rdp.c (send_rdp): Make static.
	(_initialize_remote_rdp): Add declaration.
	* alpha-tdep.c (_initialize_alpha_tdep): Add declaration.
@
text
@a2486 1
      sort_symtab_syms (pst->symtab);
@


1.46
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d1235 1
a1235 1
CORE_ADDR
@


1.45
log
@
2003-02-26  Jeff Johnston  <jjohnstn@@redhat.com>

        From Elena Zannoni  <ezannoni@@redhat.com>
        * dbxread.c (process_one_symbol): Only record line 0 if one or
        more sline entries have been seen for the function.
@
text
@d1765 1
a1765 1
				 VAR_NAMESPACE, LOC_STATIC,
d1775 1
a1775 1
				 VAR_NAMESPACE, LOC_STATIC,
d1793 1
a1793 1
				     STRUCT_NAMESPACE, LOC_TYPEDEF,
d1801 1
a1801 1
					 VAR_NAMESPACE, LOC_TYPEDEF,
d1817 1
a1817 1
// OBSOLETE  					 VAR_NAMESPACE, LOC_TYPEDEF,
d1829 1
a1829 1
				     VAR_NAMESPACE, LOC_TYPEDEF,
d1891 1
a1891 1
					 VAR_NAMESPACE, LOC_CONST,
d1908 1
a1908 1
				 VAR_NAMESPACE, LOC_CONST,
d1969 1
a1969 1
				 VAR_NAMESPACE, LOC_BLOCK,
d2034 1
a2034 1
				 VAR_NAMESPACE, LOC_BLOCK,
@


1.45.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1765 1
a1765 1
				 VAR_DOMAIN, LOC_STATIC,
d1775 1
a1775 1
				 VAR_DOMAIN, LOC_STATIC,
d1793 1
a1793 1
				     STRUCT_DOMAIN, LOC_TYPEDEF,
d1801 1
a1801 1
					 VAR_DOMAIN, LOC_TYPEDEF,
d1817 1
a1817 1
// OBSOLETE  					 VAR_DOMAIN, LOC_TYPEDEF,
d1829 1
a1829 1
				     VAR_DOMAIN, LOC_TYPEDEF,
d1891 1
a1891 1
					 VAR_DOMAIN, LOC_CONST,
d1908 1
a1908 1
				 VAR_DOMAIN, LOC_CONST,
d1969 1
a1969 1
				 VAR_DOMAIN, LOC_BLOCK,
d2034 1
a2034 1
				 VAR_DOMAIN, LOC_BLOCK,
@


1.44
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d2834 7
a2840 1
	  record_line (current_subfile, 0, last_function_start + valu);
@


1.43
log
@	* coffread.c (coff_symfile_read): Clean up minimal symbols earlier.
	* dbxread.c (elfstab_build_psymtabs): Don't call
	install_minimal_symbols.
	(stabsect_build_psymtabs): Likewise.
	* elfread.c (elf_symfile_read): Call install_minimal_symbols
	earlier.
	* somread.c (som_symfile_read): Call install_minimal_symbols
	and do_cleanups earlier.
	* nlmread.c (nlm_symfile_read): Likewise.
	* mdebugread.c (elfmdebug_build_psymtabs): Call
	install_minimal_symbols and make appropriate cleanups.
@
text
@d3264 2
a3265 2
		  if (m && STREQN (SYMBOL_NAME (m), name, l)
		      && SYMBOL_NAME (m)[l] == '\0')
d3268 3
a3270 3
		  else if (m && SYMBOL_NAME (m + 1)
			   && STREQN (SYMBOL_NAME (m + 1), name, l)
			   && SYMBOL_NAME (m + 1)[l] == '\0')
@


1.42
log
@2003-02-18  Elena Zannoni  <ezannoni@@redhat.com>

	From Jim Ingham   <jingham@@apple.com>:
        * dbxread.c (process_one_symbol): Use last_function_start rather
        than function_start_offset to find the real beginning of the
        current function.  The latter is just the text section offset on
        some systems, the former is always the real function start.
@
text
@a3558 1
  install_minimal_symbols (objfile);
d3570 4
a3573 1
     incremental load here. */
a3654 1
  install_minimal_symbols (objfile);
@


1.41
log
@	* dbxread.c (stabs_data): New static variable.
	(fill_symbuf): Support an in-memory buffer for stabs data.
	(stabs_seek): New function.
	(dbx_psymtab_to_symtab): Relocate the stabs data if necessary.
	(read_ofile_symtab): Use stabs_seek.
	(elfstab_build_psymtabs): Take an asection* instead of
	an offset and size.  Relocate the stabs data if necessary.
	Save the section* for dbx_psymtab_to_symtab.
	* dwarf2read.c: Add section variables for each debug section.
	(dwarf2_locate_sections): Fill them in.
	(dwarf2_read_section): Take an asection* argument.
	Relocate the section contents if necessary.
	(dwarf2_build_psymtabs, dwarf2_build_psymtabs_easy): Update callers.
	* dwarf2cfi.c (parse_frame_info): Take a section argument and pass
	it to dwarf2_read_section.
	(dwarf2_build_frame_info): Update callers.
	* elfread.c (elf_symfile_read): Update call to
	elfstab_build_psymtabs.
	* gdb-stabs.h (struct dbx_symfile_info): Add stab_section.
	(DBX_STAB_SECTION): New macro.
	* stabsread.h (elfstab_build_psymtabs): Update prototype.
	* symfile.c (symfile_dummy_outputs): New function.
	(symfile_relocate_debug_section): New function.
	* symfile.h (symfile_relocate_debug_section): Add prototype.
@
text
@d2787 4
a2790 3
  /* If this is nonzero, we've seen an N_SLINE since the start of the current
     function.  Initialized to nonzero to assure that last_function_start
     is never used uninitialized.  */
d2834 1
a2834 1
	  record_line (current_subfile, 0, function_start_offset + valu);
@


1.40
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d896 4
d912 12
a923 2
  if (symbuf_sections == NULL)
    count = sizeof (symbuf);
d939 1
a941 1
  nbytes = bfd_bread (symbuf, count, sym_bfd);
d952 12
d2502 1
d2528 10
d2540 3
d2591 2
d2602 1
a2602 1
      bfd_seek (symfile_bfd, sym_offset - symbol_size, SEEK_CUR);
d2645 1
a2645 1
      bfd_seek (symfile_bfd, sym_offset, SEEK_CUR);
d3505 1
a3505 2
   STABOFFSET and STABSIZE define the location in OBJFILE where the .stab
   section exists.
d3514 1
a3514 1
			file_ptr staboffset, unsigned int stabsize,
d3521 1
d3533 2
a3534 1
  DBX_SYMCOUNT (objfile) = stabsize / DBX_SYMBOL_SIZE (objfile);
d3536 2
a3537 1
  DBX_SYMTAB_OFFSET (objfile) = staboffset;
d3562 6
d3572 3
@


1.39
log
@2003-01-13  Elena Zannoni  <ezannoni@@redhat.com>

	* stabsread.h (process_later, resolve_cfront_continuation):
	Obsolete.
	Update copyright years.
	* buildsym.c (start_subfile): Obsolete comment pertinent to Cfront.
	Update copyright year.
	* dbxread.c(struct cont_elem): Obsolete.
	(process_later, process_now): Obsolete functions.
	(read_dbx_symtab, read_ofile_symtab): Obsolete cfront support.
	Update copyright year.
	* gdbtypes.c (INIT_EXTRA, ADD_EXTRA): Obsolete macros.
	(add_name, add_mangled_type, cfront_mangle_name): Obsolete functions.
	* mdebugread.c (parse_type): Obsolete comment pertinent to Cfront.
	(parse_partial_symbols): Obsolete cfront support.
	* stabsread.c
	(CFRONT_VISIBILITY_PRIVATE,CFRONT_VISIBILITY_PUBLIC): Obsolete
	macros.
	(get_substring, get_cfront_method_physname, msg_unknown_complaint,
	read_cfront_baseclasses, read_cfront_member_functions,
	resolve_cfront_continuation,read_cfront_static_fields,
	copy_cfront_struct_fields): Obsolete functions.
	(define_symbol, read_one_struct_field): Obsolete cfront support.
	* xcoffread.c (scan_xcoff_symtab): Obsolete CFront support.
	Update Copyright year.
@
text
@d641 1
a641 1
  memset ((PTR) objfile->sym_stab_info, 0, sizeof (struct dbx_symfile_info));
d693 2
a694 2
      memset ((PTR) size_temp, 0, sizeof (size_temp));
      val = bfd_bread ((PTR) size_temp, sizeof (size_temp), sym_bfd);
d927 1
a927 1
  nbytes = bfd_bread ((PTR) symbuf, count, sym_bfd);
d1028 1
a1028 1
  xmfree (objfile->md, (PTR) bincl_list);
d1679 1
a1679 1
	      memcpy ((PTR) psymtab_include_list, (PTR) orig,
d2103 1
a2103 1
		    memcpy ((PTR) dependency_list, (PTR) orig,
@


1.38
log
@Replace complain() with complaint().
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002
d260 3
a262 1
static void process_now (struct objfile *);
d775 100
a874 99
/* cont_elem is used for continuing information in cfront.
   It saves information about which types need to be fixed up and 
   completed after all the stabs are read.  */
struct cont_elem
  {
    /* sym and stabstring for continuing information in cfront */
    struct symbol *sym;
    char *stabs;
    /* state dependencies (statics that must be preserved) */
    int sym_idx;
    int sym_end;
    int symnum;
    int (*func) (struct objfile *, struct symbol *, char *);
    /* other state dependencies include:
       (assumption is that these will not change since process_now FIXME!!)
       stringtab_global
       n_stabs
       objfile
       symfile_bfd */
  };

static struct cont_elem *cont_list = 0;
static int cont_limit = 0;
static int cont_count = 0;

/* Arrange for function F to be called with arguments SYM and P later
   in the stabs reading process.  */
void
process_later (struct symbol *sym, char *p,
	       int (*f) (struct objfile *, struct symbol *, char *))
{

  /* Allocate more space for the deferred list.  */
  if (cont_count >= cont_limit - 1)
    {
      cont_limit += 32;		/* chunk size */

      cont_list
	= (struct cont_elem *) xrealloc (cont_list,
					 (cont_limit
					  * sizeof (struct cont_elem)));
      if (!cont_list)
	error ("Virtual memory exhausted\n");
    }

  /* Save state variables so we can process these stabs later.  */
  cont_list[cont_count].sym_idx = symbuf_idx;
  cont_list[cont_count].sym_end = symbuf_end;
  cont_list[cont_count].symnum = symnum;
  cont_list[cont_count].sym = sym;
  cont_list[cont_count].stabs = p;
  cont_list[cont_count].func = f;
  cont_count++;
}

/* Call deferred funtions in CONT_LIST.  */

static void
process_now (struct objfile *objfile)
{
  int i;
  int save_symbuf_idx;
  int save_symbuf_end;
  int save_symnum;
  struct symbol *sym;
  char *stabs;
  int err;
  int (*func) (struct objfile *, struct symbol *, char *);

  /* Save the state of our caller, we'll want to restore it before
     returning.  */
  save_symbuf_idx = symbuf_idx;
  save_symbuf_end = symbuf_end;
  save_symnum = symnum;

  /* Iterate over all the deferred stabs.  */
  for (i = 0; i < cont_count; i++)
    {
      /* Restore the state for this deferred stab.  */
      symbuf_idx = cont_list[i].sym_idx;
      symbuf_end = cont_list[i].sym_end;
      symnum = cont_list[i].symnum;
      sym = cont_list[i].sym;
      stabs = cont_list[i].stabs;
      func = cont_list[i].func;

      /* Call the function to handle this deferrd stab.  */
      err = (*func) (objfile, sym, stabs);
      if (err)
	error ("Internal error: unable to resolve stab.\n");
    }

  /* Restore our caller's state.  */
  symbuf_idx = save_symbuf_idx;
  symbuf_end = save_symbuf_end;
  symnum = save_symnum;
  cont_count = 0;
}

d1781 16
a1796 14
		/* The semantics of C++ state that "struct foo { ... }"
		   also defines a typedef for "foo".  Unfortuantely, cfront
		   never makes the typedef when translating from C++ to C.
		   We make the typedef here so that "ptype foo" works as
		   expected for cfront translated code.  */
		else if (psymtab_language == language_cplus)
		  {
		    /* Also a typedef with the same name.  */
		    add_psymbol_to_list (namestring, p - namestring,
					 VAR_NAMESPACE, LOC_TYPEDEF,
					 &objfile->static_psymbols,
					 nlist.n_value, 0,
					 psymtab_language, objfile);
		  }
d2031 5
a2035 3
	    /* added to support cfront stabs strings */
	  case 'Z':		/* for definition continuations */
	  case 'P':		/* for prototypes */
d2692 5
a2696 4
  /* Process items which we had to "process_later" due to dependencies 
     on other stabs.  */
  process_now (objfile);

@


1.37
log
@2002-11-18  Klee Dienes  <kdienes@@apple.com>

        * buildsym.h (pop_context): Convert to function, defined in
        buildsym.c.
        * buildsym.c: Include gdb_assert.h.
        (pop_context): Implement as C function.  Add check for stack
        underflow.
        * dbxread.c (process_one_symbol): Complain and stop processing
        that symbol if we are already at the top of the context stack for
        a function-end N_FUN (this would imply an umatched RBRAC).  Ditto
        when processing N_RBRAC.
@
text
@d170 5
a174 2
struct deprecated_complaint lbrac_complaint =
{"bad block start address patched", 0, 0};
d176 6
a181 2
struct deprecated_complaint string_table_offset_complaint =
{"bad string table offset in symbol %d", 0, 0};
d183 7
a189 5
struct deprecated_complaint unknown_symtype_complaint =
{"unknown symbol type %s", 0, 0};

struct deprecated_complaint unknown_symchar_complaint =
{"unknown symbol descriptor `%c'", 0, 0};
a190 18
struct deprecated_complaint lbrac_rbrac_complaint =
{"block start larger than block end", 0, 0};

struct deprecated_complaint lbrac_unmatched_complaint =
{"unmatched N_LBRAC before symtab pos %d", 0, 0};

struct deprecated_complaint lbrac_mismatch_complaint =
{"N_LBRAC/N_RBRAC symbol mismatch at symtab pos %d", 0, 0};

struct deprecated_complaint repeated_header_complaint =
{"\"repeated\" header file %s not previously seen, at symtab pos %d", 0, 0};

struct deprecated_complaint unclaimed_bincl_complaint =
{"N_BINCL %s not in entries for any file, at symtab pos %d", 0, 0};

struct deprecated_complaint discarding_local_symbols_complaint =
{"misplaced N_LBRAC entry; discarding local symbols which have no enclosing block", 0, 0};

d361 1
a361 1
  complain (&repeated_header_complaint, name, symnum);
d1016 1
a1016 1
  complain (&repeated_header_complaint, name, symnum);
d1053 2
a1054 1
      complain (&string_table_offset_complaint, symnum);
d1251 8
a1362 3
	  static struct deprecated_complaint function_outside_compilation_unit = {
	    "function `%s' appears to be defined outside of all compilation units", 0, 0
	  };
d1613 3
a1615 1
	      complain (&unclaimed_bincl_complaint, namestring, symnum);
d1889 1
a1889 1
		complain (&function_outside_compilation_unit, name);
d1954 1
a1954 1
		complain (&function_outside_compilation_unit, name);
d2049 2
a2050 1
	    complain (&unknown_symchar_complaint, p[1]);
d2164 1
a2164 2
	  complain (&unknown_symtype_complaint,
		    local_hex_string (nlist.n_type));
d2779 1
a2779 1
 	      complain (&lbrac_mismatch_complaint, symnum);
d2829 1
a2829 1
	  complain (&lbrac_complaint);
d2854 1
a2854 1
	  complain (&lbrac_mismatch_complaint, symnum);
d2860 1
a2860 1
	complain (&lbrac_mismatch_complaint, symnum);
d2885 2
a2886 1
	      complain (&discarding_local_symbols_complaint);
d2906 2
a2907 1
		  complain (&lbrac_rbrac_complaint);
d3131 1
a3131 1
      complain (&unknown_symtype_complaint, local_hex_string (type));
d3243 2
a3244 1
		  complain (&lbrac_unmatched_complaint, symnum);
@


1.36
log
@2002-10-25  Andrew Cagney  <cagney@@redhat.com>

	* complaints.h (struct deprecated_complaint): Rename `struct
	complaint'.
	* complaints.c (complain): Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Delete
	incorrect comment indicating that "symfile.h" was being included
	for the `struct complaint' definition.
	* remote-vx.c: Update.
	* objc-lang.c: Update.
	* xcoffread.c: Update.
	* hpread.c: Update.
	* mdebugread.c: Update.
	* stabsread.c: Update.
	* dwarf2read.c: Update.
	* dwarfread.c: Update.
	* elfread.c: Update.
	* coffread.c: Update.
	* stabsread.h: Update.
	* dbxread.c: Update.
	* buildsym.c: Update.
	* gdbtypes.c: Update.
	* macrotab.c: Update.
@
text
@d2777 7
d2852 6
@


1.35
log
@* dbxread.c, mdebugread.c: Revert my change of 2001-10-23.  Moving
texthigh and textlow to reader-specific structs caused
objfile_relocate to miss them.  This is fixable, but the work that
the change was supposed to prepare GDB for never got done anyway.
@
text
@d170 1
a170 1
struct complaint lbrac_complaint =
d173 1
a173 1
struct complaint string_table_offset_complaint =
d176 1
a176 1
struct complaint unknown_symtype_complaint =
d179 1
a179 1
struct complaint unknown_symchar_complaint =
d182 1
a182 1
struct complaint lbrac_rbrac_complaint =
d185 1
a185 1
struct complaint lbrac_unmatched_complaint =
d188 1
a188 1
struct complaint lbrac_mismatch_complaint =
d191 1
a191 1
struct complaint repeated_header_complaint =
d194 1
a194 1
struct complaint unclaimed_bincl_complaint =
d197 1
a197 1
struct complaint discarding_local_symbols_complaint =
d1363 1
a1363 1
	  static struct complaint function_outside_compilation_unit = {
@


1.35.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003.
a60 1
#include "gdb_assert.h"
d66 8
d170 20
a189 5
static void
unknown_symtype_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "unknown symbol type %s", arg1);
}
d191 2
a192 6
static void
lbrac_mismatch_complaint (int arg1)
{
  complaint (&symfile_complaints,
	     "N_LBRAC/N_RBRAC symbol mismatch at symtab pos %d", arg1);
}
d194 2
a195 7
static void
repeated_header_complaint (const char *arg1, int arg2)
{
  complaint (&symfile_complaints,
	     "\"repeated\" header file %s not previously seen, at symtab pos %d",
	     arg1, arg2);
}
d197 3
d269 2
d361 2
a362 2
  struct header_file *p = HEADER_FILES (current_objfile);
  int i;
d365 1
a365 1
    if (strcmp (p[i].name, name) == 0 && instance == p[i].instance)
d370 1
a370 1
  repeated_header_complaint (name, symnum);
d387 2
a388 2
  int i;
  struct header_file *hfile;
d430 1
a430 1
  struct header_file *f = &HEADER_FILES (current_objfile)[real_filenum];
d504 1
a504 1
      if (name[8] == 'C' && DEPRECATED_STREQ ("__DYNAMIC", name))
d648 1
a648 1
  memset (objfile->sym_stab_info, 0, sizeof (struct dbx_symfile_info));
d700 2
a701 2
      memset (size_temp, 0, sizeof (size_temp));
      val = bfd_bread (size_temp, sizeof (size_temp), sym_bfd);
d761 2
a762 2
	  int i = N_HEADER_FILES (objfile);
	  struct header_file *hfiles = HEADER_FILES (objfile);
d782 100
a901 4
/* This variable stores a global stabs buffer, if we read stabs into
   memory in one chunk in order to process relocations.  */
static bfd_byte *stabs_data;

d914 2
a915 12
  if (stabs_data)
    {
      nbytes = sizeof (symbuf);
      if (nbytes > symbuf_left)
        nbytes = symbuf_left;
      memcpy (symbuf, stabs_data + symbuf_read, nbytes);
    }
  else if (symbuf_sections == NULL)
    {
      count = sizeof (symbuf);
      nbytes = bfd_bread (symbuf, count, sym_bfd);
    }
a930 1
      nbytes = bfd_bread (symbuf, count, sym_bfd);
d933 1
a943 12
static void
stabs_seek (int sym_offset)
{
  if (stabs_data)
    {
      symbuf_read += sym_offset;
      symbuf_left -= sym_offset;
    }
  else
    bfd_seek (symfile_bfd, sym_offset, SEEK_CUR);
}

d1022 1
a1022 1
	&& strcmp (name, bincl->name) == 0)
d1025 1
a1025 1
  repeated_header_complaint (name, symnum);
d1034 1
a1034 1
  xmfree (objfile->md, bincl_list);
d1062 1
a1062 2
      complaint (&symfile_complaints, "bad string table offset in symbol %d",
		 symnum);
d1214 1
a1214 1
static CORE_ADDR
a1258 8
static void
function_outside_compilation_unit_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     "function `%s' appears to be defined outside of all compilation units",
	     arg1);
}

d1265 1
a1265 1
  struct external_nlist *bufp = 0;	/* =0 avoids gcc -Wall glitch */
d1270 1
a1270 1
  char *namestring;
a1277 1
  int data_sect_index;
a1328 32
  /* FIXME: jimb/2003-09-12: We don't apply the right section's offset
     to global and static variables.  The stab for a global or static
     variable doesn't give us any indication of which section it's in,
     so we can't tell immediately which offset in
     objfile->section_offsets we should apply to the variable's
     address.

     We could certainly find out which section contains the variable
     by looking up the variable's unrelocated address with
     find_pc_section, but that would be expensive; this is the
     function that constructs the partial symbol tables by examining
     every symbol in the entire executable, and it's
     performance-critical.  So that expense would not be welcome.  I'm
     not sure what to do about this at the moment.

     What we have done for years is to simply assume that the .data
     section's offset is appropriate for all global and static
     variables.  Recently, this was expanded to fall back to the .bss
     section's offset if there is no .data section, and then to the
     .rodata section's offset.  */
  data_sect_index = objfile->sect_index_data;
  if (data_sect_index == -1)
    data_sect_index = SECT_OFF_BSS (objfile);
  if (data_sect_index == -1)
    data_sect_index = SECT_OFF_RODATA (objfile);

  /* If data_sect_index is still -1, that's okay.  It's perfectly fine
     for the file to have no .data, no .bss, and no .text at all, if
     it also has no global or static variables.  If it does, we will
     get an internal error from an ANOFFSET macro below when we try to
     use data_sect_index.  */

d1363 3
d1419 2
a1420 2
		objfile->ei.deprecated_entry_file_lowpc = last_o_file_start;
		objfile->ei.deprecated_entry_file_highpc = nlist.n_value;
d1616 1
a1616 3
	      complaint (&symfile_complaints,
			 "N_BINCL %s not in entries for any file, at symtab pos %d",
			 namestring, symnum);
d1653 1
a1653 1
	    if (pst && strcmp (namestring, pst->filename) == 0)
d1656 1
a1656 1
	      int i;
d1658 1
a1658 1
		if (strcmp (namestring, psymtab_include_list[i]) == 0)
d1677 1
a1677 1
	      memcpy (psymtab_include_list, orig,
d1732 1
a1732 1
	    nlist.n_value += ANOFFSET (objfile->section_offsets, data_sect_index);
d1737 1
a1737 1
				 VAR_DOMAIN, LOC_STATIC,
d1743 1
a1743 1
	    nlist.n_value += ANOFFSET (objfile->section_offsets, data_sect_index);
d1747 1
a1747 1
				 VAR_DOMAIN, LOC_STATIC,
d1765 1
a1765 1
				     STRUCT_DOMAIN, LOC_TYPEDEF,
d1773 1
a1773 1
					 VAR_DOMAIN, LOC_TYPEDEF,
d1779 14
d1799 1
a1799 1
				     VAR_DOMAIN, LOC_TYPEDEF,
d1861 1
a1861 1
					 VAR_DOMAIN, LOC_CONST,
d1878 1
a1878 1
				 VAR_DOMAIN, LOC_CONST,
d1890 1
a1890 1
		function_outside_compilation_unit_complaint (name);
d1939 1
a1939 1
				 VAR_DOMAIN, LOC_BLOCK,
d1955 1
a1955 1
		function_outside_compilation_unit_complaint (name);
d2004 1
a2004 1
				 VAR_DOMAIN, LOC_BLOCK,
d2027 3
d2050 1
a2050 2
	    complaint (&symfile_complaints, "unknown symbol descriptor `%c'",
		       p[1]);
d2096 1
a2096 1
		    memcpy (dependency_list, orig,
d2164 2
a2165 1
	  unknown_symtype_complaint (local_hex_string (nlist.n_type));
d2177 2
a2178 2
      objfile->ei.deprecated_entry_file_lowpc = last_o_file_start;
      objfile->ei.deprecated_entry_file_highpc = nlist.n_value;
d2455 1
a2469 1
  struct cleanup *back_to = NULL;
a2494 10
      if (DBX_STAB_SECTION (pst->objfile))
	{
	  stabs_data
	    = symfile_relocate_debug_section (pst->objfile->obfd,
					      DBX_STAB_SECTION (pst->objfile),
					      NULL);
	  if (stabs_data)
	    back_to = make_cleanup (free_current_contents, (void *) &stabs_data);
	}

a2496 3
      if (back_to)
	do_cleanups (back_to);

d2512 2
a2513 2
  char *namestring;
  struct external_nlist *bufp;
d2517 1
a2517 1
  bfd *abfd;
a2544 2
  symbuf_read = 0;
  symbuf_left = sym_offset + sym_size;
d2554 1
a2554 1
      stabs_seek (sym_offset - symbol_size);
d2567 1
a2567 1
	  if (DEPRECATED_STREQ (namestring, GCC_COMPILED_FLAG_SYMBOL))
d2569 1
a2569 1
	  else if (DEPRECATED_STREQ (namestring, GCC2_COMPILED_FLAG_SYMBOL))
d2573 1
a2573 1
	  if (DEPRECATED_STREQN (tempstring, "__gnu_compiled", 14))
d2597 1
a2597 1
      stabs_seek (sym_offset);
d2639 1
a2639 1
	  if (DEPRECATED_STREQ (namestring, GCC_COMPILED_FLAG_SYMBOL))
d2641 1
a2641 1
	  else if (DEPRECATED_STREQ (namestring, GCC2_COMPILED_FLAG_SYMBOL))
d2686 4
d2726 1
a2726 1
  struct context_stack *new;
d2738 3
a2740 4
  /* If this is nonzero, we've seen an N_SLINE since the start of the
     current function.  We use this to tell us to move the first sline
     to the beginning of the function regardless of what its given
     value is. */
d2777 1
a2777 14

 	  if (context_stack_depth <= 0)
 	    {
	      lbrac_mismatch_complaint (symnum);
 	      break;
 	    }

	  /* The following check is added before recording line 0 at
	     end of function so as to handle hand-generated stabs
	     which may have an N_FUN stabs at the end of the function, but
	     no N_SLINE stabs.  */
	  if (sline_found_in_function)
	    record_line (current_subfile, 0, last_function_start + valu);

d2823 1
a2823 1
	  complaint (&symfile_complaints, "bad block start address patched");
a2845 6
      if (context_stack_depth <= 0)
	{
	  lbrac_mismatch_complaint (symnum);
	  break;
	}

d2848 1
a2848 1
	lbrac_mismatch_complaint (symnum);
d2873 1
a2873 2
	      complaint (&symfile_complaints,
			 "misplaced N_LBRAC entry; discarding local symbols which have no enclosing block");
d2893 1
a2893 2
		  complaint (&symfile_complaints,
			     "block start larger than block end");
d3117 1
a3117 1
      unknown_symtype_complaint (local_hex_string (type));
d3199 2
a3200 2
		  if (m && strncmp (DEPRECATED_SYMBOL_NAME (m), name, l) == 0
		      && DEPRECATED_SYMBOL_NAME (m)[l] == '\0')
d3203 3
a3205 3
		  else if (m && DEPRECATED_SYMBOL_NAME (m + 1)
			   && strncmp (DEPRECATED_SYMBOL_NAME (m + 1), name, l) == 0
			   && DEPRECATED_SYMBOL_NAME (m + 1)[l] == '\0')
d3229 1
a3229 2
		  complaint (&symfile_complaints,
			     "unmatched N_LBRAC before symtab pos %d", symnum);
d3258 1
a3258 1
	  if (strcmp (name, GCC2_COMPILED_FLAG_SYMBOL) == 0)
d3440 2
a3441 1
   STABSECT is the BFD section information for the .stab section.
d3450 1
a3450 1
			asection *stabsect,
a3456 1
  struct cleanup *back_to = NULL;
d3468 1
a3468 2
  DBX_SYMCOUNT (objfile)
    = bfd_section_size (objfile->obfd, stabsect) / DBX_SYMBOL_SIZE (objfile);
d3470 1
a3470 2
  DBX_SYMTAB_OFFSET (objfile) = stabsect->filepos;
  DBX_STAB_SECTION (objfile) = stabsect;
d3491 1
a3494 6
  symbuf_read = 0;
  symbuf_left = bfd_section_size (objfile->obfd, stabsect);
  stabs_data = symfile_relocate_debug_section (objfile->obfd, stabsect, NULL);
  if (stabs_data)
    back_to = make_cleanup (free_current_contents, (void *) &stabs_data);

d3497 1
a3497 4
     incremental load here.  dbx_symfile_read should not generate any new
     minimal symbols, since we will have already read the ELF dynamic symbol
     table and normal symbol entries won't be in the ".stab" section; but in
     case it does, it will install them itself.  */
a3498 3

  if (back_to)
    do_cleanups (back_to);
d3576 1
@


1.35.4.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@a2089 1
	  case N_PATCH:
a3255 1
    case N_PATCH:	/* Solaris2: Patch Run Time Checker.  */
@


1.35.4.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d654 3
a656 2
  /* Read the string table and stash it away in the objfile_obstack.
     When we blow away the objfile the string table goes away as well.
d661 1
a661 1
     that we put in on the objfile_obstack, we can't do this since gdb gets
d713 1
a713 1
	    (char *) obstack_alloc (&objfile->objfile_obstack,
d2150 1
a2150 1
    obstack_alloc (&objfile->objfile_obstack, sizeof (struct symloc));
d2272 1
a2272 1
	obstack_alloc (&objfile->objfile_obstack,
d2288 1
a2288 1
	(char *) obstack_alloc (&objfile->objfile_obstack,
d2298 1
a2298 1
	obstack_alloc (&objfile->objfile_obstack,
d3347 1
a3347 1
    obstack_alloc (&objfile->objfile_obstack, stabstrsize + 1);
d3445 1
a3445 1
    obstack_alloc (&objfile->objfile_obstack, stabstrsize + 1);
d3539 1
a3539 1
    obstack_alloc (&objfile->objfile_obstack, DBX_STRINGTAB_SIZE (objfile) + 1);
@


1.35.2.1
log
@2002-09-18  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h: Delete BLOCK_SHOULD_SORT.
	* symtab.c (lookup_block_symbol): Assume non-hashed blocks aren't
	sorted.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.h: Delete prototypes for sort_block_syms and
	sort_symtab_syms.
	* symfile.c: Delete functions sort_block_syms and
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Remove call to
	sort_symtab_syms.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.

2002-09-20  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (c-lang.o): Correct dependencies.
	(utils.o): Gather dependencies.
	(charset.o): Move.
@
text
@d2455 1
@


1.35.2.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d170 1
a170 1
struct deprecated_complaint lbrac_complaint =
d173 1
a173 1
struct deprecated_complaint string_table_offset_complaint =
d176 1
a176 1
struct deprecated_complaint unknown_symtype_complaint =
d179 1
a179 1
struct deprecated_complaint unknown_symchar_complaint =
d182 1
a182 1
struct deprecated_complaint lbrac_rbrac_complaint =
d185 1
a185 1
struct deprecated_complaint lbrac_unmatched_complaint =
d188 1
a188 1
struct deprecated_complaint lbrac_mismatch_complaint =
d191 1
a191 1
struct deprecated_complaint repeated_header_complaint =
d194 1
a194 1
struct deprecated_complaint unclaimed_bincl_complaint =
d197 1
a197 1
struct deprecated_complaint discarding_local_symbols_complaint =
d1363 1
a1363 1
	  static struct deprecated_complaint function_outside_compilation_unit = {
@


1.35.2.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d170 20
a189 5
static void
unknown_symtype_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "unknown symbol type %s", arg1);
}
d191 2
a192 6
static void
lbrac_mismatch_complaint (int arg1)
{
  complaint (&symfile_complaints,
	     "N_LBRAC/N_RBRAC symbol mismatch at symtab pos %d", arg1);
}
d194 2
a195 7
static void
repeated_header_complaint (const char *arg1, int arg2)
{
  complaint (&symfile_complaints,
	     "\"repeated\" header file %s not previously seen, at symtab pos %d",
	     arg1, arg2);
}
d197 3
d370 1
a370 1
  repeated_header_complaint (name, symnum);
d1025 1
a1025 1
  repeated_header_complaint (name, symnum);
d1062 1
a1062 2
      complaint (&symfile_complaints, "bad string table offset in symbol %d",
		 symnum);
a1258 8
static void
function_outside_compilation_unit_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     "function `%s' appears to be defined outside of all compilation units",
	     arg1);
}

d1363 3
d1616 1
a1616 3
	      complaint (&symfile_complaints,
			 "N_BINCL %s not in entries for any file, at symtab pos %d",
			 namestring, symnum);
d1890 1
a1890 1
		function_outside_compilation_unit_complaint (name);
d1955 1
a1955 1
		function_outside_compilation_unit_complaint (name);
d2050 1
a2050 2
	    complaint (&symfile_complaints, "unknown symbol descriptor `%c'",
		       p[1]);
d2164 2
a2165 1
	  unknown_symtype_complaint (local_hex_string (nlist.n_type));
a2775 7

 	  if (context_stack_depth <= 0)
 	    {
	      lbrac_mismatch_complaint (symnum);
 	      break;
 	    }

d2822 1
a2822 1
	  complaint (&symfile_complaints, "bad block start address patched");
a2844 6
      if (context_stack_depth <= 0)
	{
	  lbrac_mismatch_complaint (symnum);
	  break;
	}

d2847 1
a2847 1
	lbrac_mismatch_complaint (symnum);
d2872 1
a2872 2
	      complaint (&symfile_complaints,
			 "misplaced N_LBRAC entry; discarding local symbols which have no enclosing block");
d2892 1
a2892 2
		  complaint (&symfile_complaints,
			     "block start larger than block end");
d3116 1
a3116 1
      unknown_symtype_complaint (local_hex_string (type));
d3228 1
a3228 2
		  complaint (&symfile_complaints,
			     "unmatched N_LBRAC before symtab pos %d", symnum);
@


1.35.2.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003.
d260 1
a260 3
#if 0 /* OBSOLETE CFront */
// OBSOLETE static void process_now (struct objfile *);
#endif /* OBSOLETE CFront */
d639 1
a639 1
  memset (objfile->sym_stab_info, 0, sizeof (struct dbx_symfile_info));
d691 2
a692 2
      memset (size_temp, 0, sizeof (size_temp));
      val = bfd_bread (size_temp, sizeof (size_temp), sym_bfd);
d773 99
a871 100
#if 0 /* OBSOLETE CFront */
// OBSOLETE  /* cont_elem is used for continuing information in cfront.
// OBSOLETE     It saves information about which types need to be fixed up and 
// OBSOLETE     completed after all the stabs are read.  */
// OBSOLETE  struct cont_elem
// OBSOLETE    {
// OBSOLETE      /* sym and stabstring for continuing information in cfront */
// OBSOLETE      struct symbol *sym;
// OBSOLETE      char *stabs;
// OBSOLETE      /* state dependencies (statics that must be preserved) */
// OBSOLETE      int sym_idx;
// OBSOLETE      int sym_end;
// OBSOLETE      int symnum;
// OBSOLETE      int (*func) (struct objfile *, struct symbol *, char *);
// OBSOLETE      /* other state dependencies include:
// OBSOLETE         (assumption is that these will not change since process_now FIXME!!)
// OBSOLETE         stringtab_global
// OBSOLETE         n_stabs
// OBSOLETE         objfile
// OBSOLETE         symfile_bfd */
// OBSOLETE    };

// OBSOLETE  static struct cont_elem *cont_list = 0;
// OBSOLETE  static int cont_limit = 0;
// OBSOLETE  static int cont_count = 0;

// OBSOLETE  /* Arrange for function F to be called with arguments SYM and P later
// OBSOLETE     in the stabs reading process.  */
// OBSOLETE  void
// OBSOLETE  process_later (struct symbol *sym, char *p,
// OBSOLETE  	       int (*f) (struct objfile *, struct symbol *, char *))
// OBSOLETE  {

// OBSOLETE    /* Allocate more space for the deferred list.  */
// OBSOLETE    if (cont_count >= cont_limit - 1)
// OBSOLETE      {
// OBSOLETE        cont_limit += 32;		/* chunk size */

// OBSOLETE        cont_list
// OBSOLETE  	= (struct cont_elem *) xrealloc (cont_list,
// OBSOLETE  					 (cont_limit
// OBSOLETE  					  * sizeof (struct cont_elem)));
// OBSOLETE        if (!cont_list)
// OBSOLETE  	error ("Virtual memory exhausted\n");
// OBSOLETE      }

// OBSOLETE    /* Save state variables so we can process these stabs later.  */
// OBSOLETE    cont_list[cont_count].sym_idx = symbuf_idx;
// OBSOLETE    cont_list[cont_count].sym_end = symbuf_end;
// OBSOLETE    cont_list[cont_count].symnum = symnum;
// OBSOLETE    cont_list[cont_count].sym = sym;
// OBSOLETE    cont_list[cont_count].stabs = p;
// OBSOLETE    cont_list[cont_count].func = f;
// OBSOLETE    cont_count++;
// OBSOLETE  }

// OBSOLETE  /* Call deferred funtions in CONT_LIST.  */

// OBSOLETE  static void
// OBSOLETE  process_now (struct objfile *objfile)
// OBSOLETE  {
// OBSOLETE    int i;
// OBSOLETE    int save_symbuf_idx;
// OBSOLETE    int save_symbuf_end;
// OBSOLETE    int save_symnum;
// OBSOLETE    struct symbol *sym;
// OBSOLETE    char *stabs;
// OBSOLETE    int err;
// OBSOLETE    int (*func) (struct objfile *, struct symbol *, char *);

// OBSOLETE    /* Save the state of our caller, we'll want to restore it before
// OBSOLETE       returning.  */
// OBSOLETE    save_symbuf_idx = symbuf_idx;
// OBSOLETE    save_symbuf_end = symbuf_end;
// OBSOLETE    save_symnum = symnum;

// OBSOLETE    /* Iterate over all the deferred stabs.  */
// OBSOLETE    for (i = 0; i < cont_count; i++)
// OBSOLETE      {
// OBSOLETE        /* Restore the state for this deferred stab.  */
// OBSOLETE        symbuf_idx = cont_list[i].sym_idx;
// OBSOLETE        symbuf_end = cont_list[i].sym_end;
// OBSOLETE        symnum = cont_list[i].symnum;
// OBSOLETE        sym = cont_list[i].sym;
// OBSOLETE        stabs = cont_list[i].stabs;
// OBSOLETE        func = cont_list[i].func;

// OBSOLETE        /* Call the function to handle this deferrd stab.  */
// OBSOLETE        err = (*func) (objfile, sym, stabs);
// OBSOLETE        if (err)
// OBSOLETE  	error ("Internal error: unable to resolve stab.\n");
// OBSOLETE      }

// OBSOLETE    /* Restore our caller's state.  */
// OBSOLETE    symbuf_idx = save_symbuf_idx;
// OBSOLETE    symbuf_end = save_symbuf_end;
// OBSOLETE    symnum = save_symnum;
// OBSOLETE    cont_count = 0;
// OBSOLETE  }
#endif /* OBSOLETE CFront */
a892 4
/* This variable stores a global stabs buffer, if we read stabs into
   memory in one chunk in order to process relocations.  */
static bfd_byte *stabs_data;

d905 2
a906 12
  if (stabs_data)
    {
      nbytes = sizeof (symbuf);
      if (nbytes > symbuf_left)
        nbytes = symbuf_left;
      memcpy (symbuf, stabs_data + symbuf_read, nbytes);
    }
  else if (symbuf_sections == NULL)
    {
      count = sizeof (symbuf);
      nbytes = bfd_bread (symbuf, count, sym_bfd);
    }
a921 1
      nbytes = bfd_bread (symbuf, count, sym_bfd);
d924 1
a934 12
static void
stabs_seek (int sym_offset)
{
  if (stabs_data)
    {
      symbuf_read += sym_offset;
      symbuf_left -= sym_offset;
    }
  else
    bfd_seek (symfile_bfd, sym_offset, SEEK_CUR);
}

d1025 1
a1025 1
  xmfree (objfile->md, bincl_list);
d1676 1
a1676 1
	      memcpy (psymtab_include_list, orig,
d1778 14
a1791 16
#if 0 /* OBSOLETE CFront */
// OBSOLETE  		/* The semantics of C++ state that "struct foo { ... }"
// OBSOLETE  		   also defines a typedef for "foo".  Unfortuantely, cfront
// OBSOLETE  		   never makes the typedef when translating from C++ to C.
// OBSOLETE  		   We make the typedef here so that "ptype foo" works as
// OBSOLETE  		   expected for cfront translated code.  */
// OBSOLETE  		else if (psymtab_language == language_cplus)
// OBSOLETE  		  {
// OBSOLETE  		    /* Also a typedef with the same name.  */
// OBSOLETE  		    add_psymbol_to_list (namestring, p - namestring,
// OBSOLETE  					 VAR_NAMESPACE, LOC_TYPEDEF,
// OBSOLETE  					 &objfile->static_psymbols,
// OBSOLETE  					 nlist.n_value, 0,
// OBSOLETE  					 psymtab_language, objfile);
// OBSOLETE  		  }
#endif /* OBSOLETE CFront */
d2026 3
a2028 5
#if 0 /* OBSOLETE CFront */
// OBSOLETE  	    /* added to support cfront stabs strings */
// OBSOLETE  	  case 'Z':		/* for definition continuations */
// OBSOLETE  	  case 'P':		/* for prototypes */
#endif /* OBSOLETE CFront */
d2096 1
a2096 1
		    memcpy (dependency_list, orig,
a2467 1
  struct cleanup *back_to = NULL;
a2492 10
      if (DBX_STAB_SECTION (pst->objfile))
	{
	  stabs_data
	    = symfile_relocate_debug_section (pst->objfile->obfd,
					      DBX_STAB_SECTION (pst->objfile),
					      NULL);
	  if (stabs_data)
	    back_to = make_cleanup (free_current_contents, (void *) &stabs_data);
	}

a2494 3
      if (back_to)
	do_cleanups (back_to);

a2542 2
  symbuf_read = 0;
  symbuf_left = sym_offset + sym_size;
d2552 1
a2552 1
      stabs_seek (sym_offset - symbol_size);
d2595 1
a2595 1
      stabs_seek (sym_offset);
d2684 4
a2687 5
#if 0 /* OBSOLETE CFront */
// OBSOLETE    /* Process items which we had to "process_later" due to dependencies 
// OBSOLETE       on other stabs.  */
// OBSOLETE    process_now (objfile);
#endif /* OBSOLETE CFront */
d3454 2
a3455 1
   STABSECT is the BFD section information for the .stab section.
d3464 1
a3464 1
			asection *stabsect,
a3470 1
  struct cleanup *back_to = NULL;
d3482 1
a3482 2
  DBX_SYMCOUNT (objfile)
    = bfd_section_size (objfile->obfd, stabsect) / DBX_SYMBOL_SIZE (objfile);
d3484 1
a3484 2
  DBX_SYMTAB_OFFSET (objfile) = stabsect->filepos;
  DBX_STAB_SECTION (objfile) = stabsect;
a3508 6
  symbuf_read = 0;
  symbuf_left = bfd_section_size (objfile->obfd, stabsect);
  stabs_data = symfile_relocate_debug_section (objfile->obfd, stabsect, NULL);
  if (stabs_data)
    back_to = make_cleanup (free_current_contents, (void *) &stabs_data);

a3512 3

  if (back_to)
    do_cleanups (back_to);
@


1.35.2.5
log
@2003-02-21  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (locate_compound_sym): Update call to
	lookup_symbol_namespace.
	* symtab.c (make_symbol_overload_list): Delete namespace_len
	argument.
	* symtab.h: Update declaration for make_symbol_overload_list.
	* valops.c (find_oload_champ_namespace_loop): New format for
	make_symbol_overload_list.
	* symtab.c (lookup_symbol_namespace): Delete namespace_len
	argument.
	(lookup_symbol_aux_using_loop): Update call to
	lookup_symbol_namespace.
	(make_symbol_overload_list_using): Delete namespace_len argument.
	* linespec.c (decode_namespace): Update call to
	lookup_symbol_namespace.
	* valops.c (value_namespace_elt): Ditto.
	* symtab.c (lookup_nested_type): Ditto.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* block.c (block_all_usings): Delete.
	(block_using): Make static.
	(block_using_iterator_next): New using_direct format.
	(block_using_iterator_first): Ditto.
	* buildsym.c (scan_for_anonymous_namespaces): Rename variables.
	(add_using_directive): New using functions.
	(end_symtab): Use cp_copy_usings.
	(copy_usings_to_obstack): Delete.
	* block.c: Tweak initial comment.
	(struct namespace_info): Move here.
	(block_initialize_namespace): Set scope to NULL!
	* block.h: Add compilation guards.
	Reorder and update declarations.
	* cp-support.c (cp_find_first_component): Return unsigned int.
	(cp_entire_prefix_len): New.
	(cp_add_using_obstack): Delete.
	(cp_add_using_xmalloc): Delete.
	(cp_copy_usings): Rewrite.
	(cp_free_usings): Delete.
	(cp_add_using): New.
	(cp_is_anonymous): Delete second argument.
	(xstrndup): New.
	* cp-support.h: Add compilation guards.
	Update declarations.
	* coffread.c: New variable coff_source_file.
	(coff_start_symtab): Use coff_source_file.
	(complete_symtab): Ditto.
	(coff_end_symtab): Ditto.
	(coff_symtab_read): Ditto.
	* dbxread.c (find_stab_function_addr): Const fix.
	* buildsym.h: Const fix.
	* buildsym.c (start_symtab): Const fix.
	(start_subfile): Ditto.
	* cp-support.c (cp_add_using_xmalloc): Copy name.
	* dwarf2read.c (read_namespace): Loop through extensions
	correctly.
	(read_file_scope): Const fix.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(read_typedef): Ditto.
	* buildsym.c (finish_block): Update comments and simplify code
	when setting scope.
	* buildsym.h: Add opaque declaration of 'struct block'.
	Change comment before processing_current_prefix.
	* arm-tdep.c (arm_gdbarch_init): Add break; after default:.
@
text
@d1236 1
a1236 1
find_stab_function_addr (char *namestring, const char *filename,
@


1.35.2.6
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2786 3
a2788 4
  /* If this is nonzero, we've seen an N_SLINE since the start of the
     current function.  We use this to tell us to move the first sline
     to the beginning of the function regardless of what its given
     value is. */
d2832 1
a2832 7
	  /* The following check is added before recording line 0 at
	     end of function so as to handle hand-generated stabs
	     which may have an N_FUN stabs at the end of the function, but
	     no N_SLINE stabs.  */
	  if (sline_found_in_function)
	    record_line (current_subfile, 0, last_function_start + valu);

d3262 2
a3263 2
		  if (m && STREQN (DEPRECATED_SYMBOL_NAME (m), name, l)
		      && DEPRECATED_SYMBOL_NAME (m)[l] == '\0')
d3266 3
a3268 3
		  else if (m && DEPRECATED_SYMBOL_NAME (m + 1)
			   && STREQN (DEPRECATED_SYMBOL_NAME (m + 1), name, l)
			   && DEPRECATED_SYMBOL_NAME (m + 1)[l] == '\0')
d3557 1
d3569 1
a3569 4
     incremental load here.  dbx_symfile_read should not generate any new
     minimal symbols, since we will have already read the ELF dynamic symbol
     table and normal symbol entries won't be in the ".stab" section; but in
     case it does, it will install them itself.  */
d3651 1
@


1.35.2.7
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1765 1
a1765 1
				 VAR_DOMAIN, LOC_STATIC,
d1775 1
a1775 1
				 VAR_DOMAIN, LOC_STATIC,
d1793 1
a1793 1
				     STRUCT_DOMAIN, LOC_TYPEDEF,
d1801 1
a1801 1
					 VAR_DOMAIN, LOC_TYPEDEF,
d1817 1
a1817 1
// OBSOLETE  					 VAR_DOMAIN, LOC_TYPEDEF,
d1829 1
a1829 1
				     VAR_DOMAIN, LOC_TYPEDEF,
d1891 1
a1891 1
					 VAR_DOMAIN, LOC_CONST,
d1908 1
a1908 1
				 VAR_DOMAIN, LOC_CONST,
d1969 1
a1969 1
				 VAR_DOMAIN, LOC_BLOCK,
d2034 1
a2034 1
				 VAR_DOMAIN, LOC_BLOCK,
@


1.35.2.8
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d1235 1
a1235 1
static CORE_ADDR
@


1.35.2.9
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a60 1
#include "gdb_assert.h"
d354 2
a355 2
  struct header_file *p = HEADER_FILES (current_objfile);
  int i;
d380 2
a381 2
  int i;
  struct header_file *hfile;
d423 1
a423 1
  struct header_file *f = &HEADER_FILES (current_objfile)[real_filenum];
d754 2
a755 2
	  int i = N_HEADER_FILES (objfile);
	  struct header_file *hfiles = HEADER_FILES (objfile);
d1294 1
a1294 1
  struct external_nlist *bufp = 0;	/* =0 avoids gcc -Wall glitch */
d1299 1
a1299 1
  char *namestring;
a1306 1
  int data_sect_index;
a1357 32
  /* FIXME: jimb/2003-09-12: We don't apply the right section's offset
     to global and static variables.  The stab for a global or static
     variable doesn't give us any indication of which section it's in,
     so we can't tell immediately which offset in
     objfile->section_offsets we should apply to the variable's
     address.

     We could certainly find out which section contains the variable
     by looking up the variable's unrelocated address with
     find_pc_section, but that would be expensive; this is the
     function that constructs the partial symbol tables by examining
     every symbol in the entire executable, and it's
     performance-critical.  So that expense would not be welcome.  I'm
     not sure what to do about this at the moment.

     What we have done for years is to simply assume that the .data
     section's offset is appropriate for all global and static
     variables.  Recently, this was expanded to fall back to the .bss
     section's offset if there is no .data section, and then to the
     .rodata section's offset.  */
  data_sect_index = objfile->sect_index_data;
  if (data_sect_index == -1)
    data_sect_index = SECT_OFF_BSS (objfile);
  if (data_sect_index == -1)
    data_sect_index = SECT_OFF_RODATA (objfile);

  /* If data_sect_index is still -1, that's okay.  It's perfectly fine
     for the file to have no .data, no .bss, and no .text at all, if
     it also has no global or static variables.  If it does, we will
     get an internal error from an ANOFFSET macro below when we try to
     use data_sect_index.  */

d1445 2
a1446 2
		objfile->ei.deprecated_entry_file_lowpc = last_o_file_start;
		objfile->ei.deprecated_entry_file_highpc = nlist.n_value;
d1684 1
a1684 1
	      int i;
d1760 1
a1760 1
	    nlist.n_value += ANOFFSET (objfile->section_offsets, data_sect_index);
d1771 1
a1771 1
	    nlist.n_value += ANOFFSET (objfile->section_offsets, data_sect_index);
d2209 2
a2210 2
      objfile->ei.deprecated_entry_file_lowpc = last_o_file_start;
      objfile->ei.deprecated_entry_file_highpc = nlist.n_value;
d2557 2
a2558 2
  char *namestring;
  struct external_nlist *bufp;
d2562 1
a2562 1
  bfd *abfd;
d2774 1
a2774 1
  struct context_stack *new;
@


1.35.2.10
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d261 4
d359 1
a359 1
    if (strcmp (p[i].name, name) == 0 && instance == p[i].instance)
d776 101
d1043 1
a1043 1
	&& strcmp (name, bincl->name) == 0)
d1715 1
a1715 1
	    if (pst && strcmp (namestring, pst->filename) == 0)
d1720 1
a1720 1
		if (strcmp (namestring, psymtab_include_list[i]) == 0)
d1841 16
d2091 5
d2767 5
d3303 1
a3303 1
		  if (m && strncmp (DEPRECATED_SYMBOL_NAME (m), name, l) == 0
d3308 1
a3308 1
			   && strncmp (DEPRECATED_SYMBOL_NAME (m + 1), name, l) == 0
d3363 1
a3363 1
	  if (strcmp (name, GCC2_COMPILED_FLAG_SYMBOL) == 0)
@


1.35.2.11
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d67 8
d494 1
a494 1
      if (name[8] == 'C' && DEPRECATED_STREQ ("__DYNAMIC", name))
d2522 1
a2522 1
	  if (DEPRECATED_STREQ (namestring, GCC_COMPILED_FLAG_SYMBOL))
d2524 1
a2524 1
	  else if (DEPRECATED_STREQ (namestring, GCC2_COMPILED_FLAG_SYMBOL))
d2528 1
a2528 1
	  if (DEPRECATED_STREQN (tempstring, "__gnu_compiled", 14))
d2594 1
a2594 1
	  if (DEPRECATED_STREQ (namestring, GCC_COMPILED_FLAG_SYMBOL))
d2596 1
a2596 1
	  else if (DEPRECATED_STREQ (namestring, GCC2_COMPILED_FLAG_SYMBOL))
@


1.35.2.12
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@a2089 1
	  case N_PATCH:
a3255 1
    case N_PATCH:	/* Solaris2: Patch Run Time Checker.  */
@


1.34
log
@2002-07-29  Andrew Cagney  <ac131313@@redhat.com>

* gdb_obstack.h: New file.
* symtab.h: Include "gdb_obstack.h" instead of "obstack.h".
(obstack_chunk_alloc, obstack_chunk_free): Delete macros.
* objfiles.h: Include "gdb_obstack.h".
* Makefile.in (gdb_obstack_h): Define.
(symtab_h): Add $(gdb_obstack_h).
(objfiles_h): Add $(gdb_obstack_h).

* objfiles.c: Include "gdb_obstack.h" instead of "obstack.h".
* macrotab.c, cp-valprint.c, dbxread.c: Ditto.
* ch-typeprint.c, ch-valprint.c, dstread.c: Ditto.
* macroexp.c, p-typeprint.c, stabsread.c: Ditto.
* symtab.c, f-typeprint.c, mdebugread.c: Ditto.
* p-valprint.c, symmisc.c, typeprint.c: Ditto.
* symfile.c, coffread.c, c-typeprint.c: Ditto.
* buildsym.c, bcache.c, ada-typeprint.c: Ditto.

* Makefile.in (bcache.o): Update dependencies.
(buildsym.o, c-typeprint.o, ch-typeprint.o): Ditto.
(ch-valprint.o, coffread.o, cp-valprint.o): Ditto.
(dbxread.o, dstread.o, f-typeprint.o): Ditto.
(objfiles.o, p-typeprint.o, p-valprint.o): Ditto.
(stabsread.o, symfile.o, symmisc.o): Ditto.
(symtab.o, typeprint.o, macroexp.o): Ditto.
(macrotab.o, mdebugread.o): Ditto.
(f_lang_h, coff_sym_h, coff_symconst_h): Define.
(coff_ecoff_h, aout_aout64_h): Define.
(aout_stabs_gnu_h, libaout_h): Define.
@
text
@a78 8
    /* The start (inclusive) and end (exclusive) addresses for this
       partial symtab's text.  STABS doesn't reliably give us nice
       start and end addresses for each function.  Instead, we are
       told the addresses of various boundary points, and we have to
       gather those together to build ranges.  These are our running
       best guess as to the range of text addresses for this psymtab.  */
    CORE_ADDR textlow, texthigh;

a106 2
#define TEXTLOW(p) (SYMLOC(p)->textlow)
#define TEXTHIGH(p) (SYMLOC(p)->texthigh)
a599 13
  /* Take the text ranges the STABS partial symbol scanner computed
     for each of the psymtabs and convert it into the canonical form
     for psymtabs.  */
  {
    struct partial_symtab *p;

    ALL_OBJFILE_PSYMTABS (objfile, p)
      {
        p->textlow = TEXTLOW (p);
        p->texthigh = TEXTHIGH (p);
      }
  }

d1425 1
a1425 1
		&& nlist.n_value >= TEXTLOW (pst))
d1429 2
a1430 2
			     nlist.n_value > TEXTHIGH (pst)
			     ? nlist.n_value : TEXTHIGH (pst),
d1552 1
a1552 1
				 valu > TEXTHIGH (pst) ? valu : TEXTHIGH (pst),
d1711 2
a1712 2
	    if (TEXTHIGH (pst) == 0 || valu > TEXTHIGH (pst))
	      TEXTHIGH (pst) = valu;
d1914 1
a1914 1
		TEXTLOW (pst) = nlist.n_value;
d1930 1
a1930 1
		    || (nlist.n_value < TEXTLOW (pst)
d1935 1
a1935 1
		TEXTLOW (pst) = nlist.n_value;
d1979 1
a1979 1
		TEXTLOW (pst) = nlist.n_value;
d1995 1
a1995 1
		    || (nlist.n_value < TEXTLOW (pst)
d2000 1
a2000 1
		TEXTLOW (pst) = nlist.n_value;
d2112 1
a2112 1
	     end_psymtab will set TEXTHIGH (pst) to the proper value, which
d2192 1
a2192 1
		   text_end > TEXTHIGH (pst) ? text_end : TEXTHIGH (pst),
a2217 2
  TEXTLOW (result) = result->textlow;
  TEXTHIGH (result) = result->texthigh;
d2253 1
a2253 1
  TEXTHIGH (pst) = capping_text;
d2271 1
a2271 1
  if (TEXTHIGH (pst) == 0 && last_function_name)
d2297 1
a2297 1
	TEXTHIGH (pst) = SYMBOL_VALUE_ADDRESS (minsym) + MSYMBOL_SIZE (minsym);
d2304 1
a2304 1
    TEXTLOW (pst) = TEXTHIGH (pst);
d2317 1
a2317 1
	if (TEXTHIGH (p1) == 0 && TEXTLOW (p1) != 0 && p1 != pst)
d2319 1
a2319 1
	    TEXTHIGH (p1) = TEXTLOW (pst);
d2321 2
a2322 2
	    if (TEXTLOW (p1) == 0)
	      TEXTLOW (p1) = TEXTHIGH (p1);
d2359 2
a2360 2
	TEXTLOW (subpst) =
	TEXTHIGH (subpst) = 0;
d2528 2
a2529 2
  text_offset = TEXTLOW (pst);
  text_size = TEXTHIGH (pst) - TEXTLOW (pst);
d2674 1
a2674 1
     which comes from TEXTLOW (pst) is correct. */
d2680 1
a2680 1
     from TEXTLOW (pst) which is correct.  */
@


1.34.6.1
log
@* dbxread.c, mdebugread.c: Revert my change of 2001-10-23.  Moving
texthigh and textlow to reader-specific structs caused
objfile_relocate to miss them.  This is fixable, but the work that
the change was supposed to prepare GDB for never got done anyway.
@
text
@d79 8
d115 2
d610 13
d1448 1
a1448 1
		&& nlist.n_value >= pst->textlow)
d1452 2
a1453 2
			     nlist.n_value > pst->texthigh
			     ? nlist.n_value : pst->texthigh,
d1575 1
a1575 1
				 valu > pst->texthigh ? valu : pst->texthigh,
d1734 2
a1735 2
	    if (pst->texthigh == 0 || valu > pst->texthigh)
	      pst->texthigh = valu;
d1937 1
a1937 1
		pst->textlow = nlist.n_value;
d1953 1
a1953 1
		    || (nlist.n_value < pst->textlow
d1958 1
a1958 1
		pst->textlow = nlist.n_value;
d2002 1
a2002 1
		pst->textlow = nlist.n_value;
d2018 1
a2018 1
		    || (nlist.n_value < pst->textlow
d2023 1
a2023 1
		pst->textlow = nlist.n_value;
d2135 1
a2135 1
	     end_psymtab will set pst->texthigh to the proper value, which
d2215 1
a2215 1
		   text_end > pst->texthigh ? text_end : pst->texthigh,
d2241 2
d2278 1
a2278 1
  pst->texthigh = capping_text;
d2296 1
a2296 1
  if (pst->texthigh == 0 && last_function_name)
d2322 1
a2322 1
	pst->texthigh = SYMBOL_VALUE_ADDRESS (minsym) + MSYMBOL_SIZE (minsym);
d2329 1
a2329 1
    pst->textlow = pst->texthigh;
d2342 1
a2342 1
	if (p1->texthigh == 0 && p1->textlow != 0 && p1 != pst)
d2344 1
a2344 1
	    p1->texthigh = pst->textlow;
d2346 2
a2347 2
	    if (p1->textlow == 0)
	      p1->textlow = p1->texthigh;
d2384 2
a2385 2
	subpst->textlow =
	subpst->texthigh = 0;
d2553 2
a2554 2
  text_offset = pst->textlow;
  text_size = pst->texthigh - pst->textlow;
d2699 1
a2699 1
     which comes from pst->textlow is correct. */
d2705 1
a2705 1
     from pst->textlow which is correct.  */
@


1.33
log
@	* dbxread.c (discarding_local_symbols_complaint): New complaint.
	(process_one_symbol): Complain about discarding local symbols
	due to a misplaced N_LBRAC entry.
@
text
@d45 1
a45 1
#include "obstack.h"
@


1.33.4.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d45 1
a45 1
#include "gdb_obstack.h"
@


1.33.4.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d79 8
d115 2
d610 13
d1448 1
a1448 1
		&& nlist.n_value >= pst->textlow)
d1452 2
a1453 2
			     nlist.n_value > pst->texthigh
			     ? nlist.n_value : pst->texthigh,
d1575 1
a1575 1
				 valu > pst->texthigh ? valu : pst->texthigh,
d1734 2
a1735 2
	    if (pst->texthigh == 0 || valu > pst->texthigh)
	      pst->texthigh = valu;
d1937 1
a1937 1
		pst->textlow = nlist.n_value;
d1953 1
a1953 1
		    || (nlist.n_value < pst->textlow
d1958 1
a1958 1
		pst->textlow = nlist.n_value;
d2002 1
a2002 1
		pst->textlow = nlist.n_value;
d2018 1
a2018 1
		    || (nlist.n_value < pst->textlow
d2023 1
a2023 1
		pst->textlow = nlist.n_value;
d2135 1
a2135 1
	     end_psymtab will set pst->texthigh to the proper value, which
d2215 1
a2215 1
		   text_end > pst->texthigh ? text_end : pst->texthigh,
d2241 2
d2278 1
a2278 1
  pst->texthigh = capping_text;
d2296 1
a2296 1
  if (pst->texthigh == 0 && last_function_name)
d2322 1
a2322 1
	pst->texthigh = SYMBOL_VALUE_ADDRESS (minsym) + MSYMBOL_SIZE (minsym);
d2329 1
a2329 1
    pst->textlow = pst->texthigh;
d2342 1
a2342 1
	if (p1->texthigh == 0 && p1->textlow != 0 && p1 != pst)
d2344 1
a2344 1
	    p1->texthigh = pst->textlow;
d2346 2
a2347 2
	    if (p1->textlow == 0)
	      p1->textlow = p1->texthigh;
d2384 2
a2385 2
	subpst->textlow =
	subpst->texthigh = 0;
d2553 2
a2554 2
  text_offset = pst->textlow;
  text_size = pst->texthigh - pst->textlow;
d2699 1
a2699 1
     which comes from pst->textlow is correct. */
d2705 1
a2705 1
     from pst->textlow which is correct.  */
@


1.33.4.3
log
@merge from mainline
@
text
@d170 1
a170 1
struct deprecated_complaint lbrac_complaint =
d173 1
a173 1
struct deprecated_complaint string_table_offset_complaint =
d176 1
a176 1
struct deprecated_complaint unknown_symtype_complaint =
d179 1
a179 1
struct deprecated_complaint unknown_symchar_complaint =
d182 1
a182 1
struct deprecated_complaint lbrac_rbrac_complaint =
d185 1
a185 1
struct deprecated_complaint lbrac_unmatched_complaint =
d188 1
a188 1
struct deprecated_complaint lbrac_mismatch_complaint =
d191 1
a191 1
struct deprecated_complaint repeated_header_complaint =
d194 1
a194 1
struct deprecated_complaint unclaimed_bincl_complaint =
d197 1
a197 1
struct deprecated_complaint discarding_local_symbols_complaint =
d1363 1
a1363 1
	  static struct deprecated_complaint function_outside_compilation_unit = {
@


1.32
log
@2002-04-24  David S. Miller  <davem@@redhat.com>

	* symtab.h (find_stab_function_addr): Kill extern.
	* minsyms.c (find_stab_function_addr): Remove from here...
	* dbxread.c: ... to here, and mark it static.
@
text
@d206 3
d2887 15
a2901 1
	local_symbols = new->locals;
@


1.31
log
@2002-03-21  Daniel Jacobowitz  <drow@@mvista.com>

         * dbxread.c (process_one_symbol): Extend the first N_SLINE
         in a function to cover the entire beginning of the function
         as well if it does not already.
@
text
@d1233 46
@


1.30
log
@Approved by Jim Blandy (jimb@@redhat.com).

	2002-02-21  Fred Fish  <fnf@@redhat.com>
	* dbxread.c (process_one_symbol): When finding an N_FUN symbol
	that marks the end of the range of a function, enter a line number
	entry that has a line number of zero and a PC offset that matches
	the end of the function.  This starts a range of PC's for which no
	line number information is known.
	* symtab.c (find_pc_sect_line): If our best fit is in a range of
	PC's for which no line number info is found (line number is zero)
	then we didn't find any valid line information.
	* symtab.h: Document use of zero line number entry.
@
text
@d2710 9
d2770 2
d2775 2
d2969 9
a2977 1
      record_line (current_subfile, desc, valu);
@


1.30.2.1
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

        Merge from trunk:

        2002-03-17  Daniel Jacobowitz  <drow@@mvista.com>

        * dbxread.c (process_one_symbol): Extend the first N_SLINE
        in a function to cover the entire beginning of the function
        as well if it does not already.
@
text
@a2709 9
  /* This holds the address of the start of a function, without the system
     peculiarities of function_start_offset.  */
  static CORE_ADDR last_function_start;

  /* If this is nonzero, we've seen an N_SLINE since the start of the current
     function.  Initialized to nonzero to assure that last_function_start
     is never used uninitialized.  */
  static int sline_found_in_function = 1;

a2760 2
      sline_found_in_function = 0;

a2763 2
      last_function_start = valu;

d2956 1
a2956 9
      /* If this is the first SLINE note in the function, record it at
	 the start of the function instead of at the listed location.  */
      if (within_function && sline_found_in_function == 0)
	{
	  record_line (current_subfile, desc, last_function_start);
	  sline_found_in_function = 1;
	}
      else
	record_line (current_subfile, desc, valu);
@


1.29
log
@* gdbarch.sh (copyright): Update years in generated header.
(SMASH_TEXT_ADDRESS): Add rule.
*gdbarch.h, gdbarch.c: Re-generate.
* coffread.c: Multi-arch uses of SMASH_TEXT_ADDRESS.
* dbxread.c: Likewise.
* dwarfread.c: Likewise.
* elfread.c: Likewise.
* somread.c: Likewise.

* arm-tdep.c (arm_smash_text_address): New function.
* config/arm/tm-arm.h (SMASH_TEXT_ADDRESS): Define in terms of above.
@
text
@d2744 1
@


1.28
log
@mfree() -> xmfree().
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001
d2762 1
a2762 3
#ifdef SMASH_TEXT_ADDRESS
      SMASH_TEXT_ADDRESS (valu);
#endif
@


1.27
log
@2001-11-07  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (set_namestring): New function, replacing the
	SET_NAMESTRING macro.
	(SET_NAMESTRING, CUR_SYMBOL_TYPE, CUR_SYMBOL_VALUE,
	CUR_SYMBOL_STRX, DBXREAD_ONLY, START_PSYMTAB, END_PSYMTAB): Delete
	definitions.
	(read_dbx_symtab): Don't include partial-stab.h any more. Don't
	reuse code in partial-stab.h, include the code directly, instead.

        * Makefile.in (dbxread.o): Remove dependency on partial-stab.h.
	(HFILES_NO_SRCDIR): Remove partial-stab.h.
@
text
@d791 1
a791 1
      mfree (objfile->md, objfile->sym_stab_info);
d1054 1
a1054 1
  mfree (objfile->md, (PTR) bincl_list);
@


1.26
log
@	2001-11-06  Fred Fish  <fnf@@redhat.com>
	* complaints.c (info_verbose): Remove unneeded decl, is in defs.h.
	* dbxread.c: Ditto
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* exec.c: Ditto.
	* hpread.c: Ditto.
	* hpread.h: Ditto.
	* mdebugread.c: Ditto.
	* os9kread.c: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* tracepoint.c: Ditto.
@
text
@d58 1
a58 1
#include "language.h"		/* Needed inside partial-stab.h */
d1070 21
d1333 768
a2100 1
       */
d2102 30
a2131 3
/* Set namestring based on nlist.  If the string table index is invalid, 
   give a fake name, and print a single error message per symbol file read,
   rather than abort the symbol reading or flood the user with messages.  */
d2133 1
a2133 18
/*FIXME: Too many adds and indirections in here for the inner loop.  */
#define SET_NAMESTRING()\
  if (((unsigned)CUR_SYMBOL_STRX + file_string_table_offset) >=		\
      DBX_STRINGTAB_SIZE (objfile)) {					\
    complain (&string_table_offset_complaint, symnum);			\
    namestring = "<bad string table offset>";				\
  } else								\
    namestring = CUR_SYMBOL_STRX + file_string_table_offset +		\
		 DBX_STRINGTAB (objfile)

#define CUR_SYMBOL_TYPE nlist.n_type
#define CUR_SYMBOL_VALUE nlist.n_value
#define CUR_SYMBOL_STRX nlist.n_strx
#define DBXREAD_ONLY
#define START_PSYMTAB(ofile,fname,low,symoff,global_syms,static_syms)\
  start_psymtab(ofile, fname, low, symoff, global_syms, static_syms)
#define END_PSYMTAB(pst,ilist,ninc,c_off,c_text,dep_list,n_deps,textlow_not_set)\
  end_psymtab(pst,ilist,ninc,c_off,c_text,dep_list,n_deps,textlow_not_set)
d2135 7
a2141 1
#include "partial-stab.h"
d2146 1
a2146 1
/*FIXME, does this have a bug at start address 0? */
d2159 4
a2162 4
      (lowest_text_address == (CORE_ADDR) -1
       ? (text_addr + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile)))
       : lowest_text_address)
      + text_size;
d2235 1
a2235 1
     The first trick is in partial-stab.h: if we see a static
d2241 1
a2241 1
     in the .o file (also in partial-stab.h).  Also, there's a hack in
d2536 1
a2536 1
      SET_NAMESTRING ();
d2598 1
a2598 1
      SET_NAMESTRING ();
@


1.25
log
@Isolate STABS readers' use of the `textlow' and `texthigh' fields
of `struct partial_symtab' to only a few locations.  This change
is not supposed to affect the way the values are computed, only
where they live.

* dbxread.c (struct symloc): Add `textlow' and `texthigh' fields
to the reader-specific structure.
* mdebugread.c (struct symloc): Same.
* dbxread.c (TEXTLOW, TEXTHIGH): New accessor macros.
* mdebugread.c (TEXTLOW, TEXTHIGH): Same.
* dbxread.c (dbx_symfile_read): After we've built all our partial
symbol tables, set each partial symtab's `textlow' and `texthigh'
fields from our reader-specific structure.
* mdebugread.c (mdebug_build_psymtabs): Same.
* dbxread.c (start_psymtab): Initialize the reader-specific
structure's `textlow' and `texthigh' from the new psymtab's.
* mdebugread.c (parse_partial_symbols, new_psymtab): Same.
* dbxread.c (read_dbx_symtab, end_psymtab, read_ofile_symtab): Use
the reader-specific `textlow' and `texthigh', not the generic
psymtab fields.
* mdebugread.c (parse_lines, parse_partial_symbols,
psymtab_to_symtab_1): Same.
* partial-stab.h: Same.
@
text
@a126 4
/* Nonzero means give verbose info on gdb action.  From main.c.  */

extern int info_verbose;

@


1.24
log
@	* coffread.c: Replace all occurrences of bfd_read with bfd_bread.
	* dbxread.c: Likewise.
	* dwarf2read.c: Likewise.
	* dwarfread.c: Likewise.
	* somread.c: Likewise.
	* ultra3-nat.c: Likewise.
	* xcoffread.c: Likewise.
@
text
@d79 7
d115 2
d611 13
d1366 1
a1366 1
		   text_end > pst->texthigh ? text_end : pst->texthigh,
d1392 2
d1429 1
a1429 1
  pst->texthigh = capping_text;
d1447 1
a1447 1
  if (pst->texthigh == 0 && last_function_name)
d1473 1
a1473 1
	pst->texthigh = SYMBOL_VALUE_ADDRESS (minsym) + MSYMBOL_SIZE (minsym);
d1480 1
a1480 1
    pst->textlow = pst->texthigh;
d1493 1
a1493 1
	if (p1->texthigh == 0 && p1->textlow != 0 && p1 != pst)
d1495 1
a1495 1
	    p1->texthigh = pst->textlow;
d1497 2
a1498 2
	    if (p1->textlow == 0)
	      p1->textlow = p1->texthigh;
d1535 2
a1536 2
	subpst->textlow =
	subpst->texthigh = 0;
d1704 2
a1705 2
  text_offset = pst->textlow;
  text_size = pst->texthigh - pst->textlow;
d1850 1
a1850 1
     which comes from pst->textlow is correct. */
d1856 1
a1856 1
     from pst->textlow which is correct.  */
@


1.23
log
@Don't use error result from find_stab_function_addr().
@
text
@d703 1
a703 1
      val = bfd_read ((PTR) size_temp, sizeof (size_temp), 1, sym_bfd);
d742 3
a744 2
	  val = bfd_read (DBX_STRINGTAB (objfile), DBX_STRINGTAB_SIZE (objfile), 1,
			  sym_bfd);
d935 1
a935 1
  nbytes = bfd_read ((PTR) symbuf, count, 1, sym_bfd);
d2505 1
a2505 1
  val = bfd_read (DBX_STRINGTAB (objfile), stabstrsize, 1, sym_bfd);
d2601 1
a2601 1
  val = bfd_read (DBX_STRINGTAB (objfile), stabstrsize, 1, sym_bfd);
@


1.22
log
@2001-09-04  Elena Zannoni  <ezannoni@@redhat.com>

	From Daniel Jacobowitz  <drow@@mvista.com>
	* dbxread.c (free_header_files): Make global.
	(init_header_files): Likewise.
	* stabsread.h (free_header_files): Add prototype.
	(init_header_files): Likewise.
	* mdebugread.c (mdebug_build_psymtabs): Initialize
	properly before using the stabs debug reader.
@
text
@d2269 12
a2280 2
		valu = 
		  find_stab_function_addr (name, last_source_file, objfile);
@


1.21
log
@2001-09-04  Elena Zannoni  <ezannoni@@redhat.com>

	From Daniel Jacobowitz  <drow@@mvista.com>
	* dbxread.c (dbx_symfile_read): Only reinitialize
	the psymbol list if mainline or if both static
	and global lists are empty.
	* dwarf2read.c (dwarf2_build_psymtabs): Likewise.
	* dwarfread.c (dwarf_build_psymtabs): Likewise.
	* xcoffread.c (xcoff_initial_scan): Likewise.
	* os9kread.c (os9k_symfile_read): Likewise.
@
text
@a272 4
static void free_header_files (void);

static void init_header_files (void);

d318 1
a318 1
static void
d331 1
a331 1
static void
@


1.20
log
@2001-08-14  Daniel Jacobowitz  <drow@@mvista.com>
	    H.J. Lu  (hjl@@gnu.org)

	* partial-stab.h: valu should be a CORE_ADDR.

2001-08-14  H.J. Lu  (hjl@@gnu.org)

	* dbxread.c (SWAP_SYMBOL): Removed.
	(INTERNALIZE_SYMBOL): Check sign extended vma.
@
text
@d585 2
a586 2
      || objfile->global_psymbols.size == 0
      || objfile->static_psymbols.size == 0)
@


1.19
log
@* symtab.c (main_name): New function.
(set_main_name): New function.
* symtab.h: Declare.
* TODO: Update

From 2000-03-05 Anthony Green <green@@redhat.com>:
* dbxread.c (process_one_symbol): Handle the N_MAIN stab by
setting main_name.
* blockframe.c (inside_main_func): Use main_name instead of
"main".
* symtab.c (find_main_psymtab): Ditto.
* source.c (select_source_symtab): Ditto.
* nlmread.c (nlm_symfile_read): Ditto.
* rs6000-tdep.c (skip_prologue): Ditto.
@
text
@a948 10
#define SWAP_SYMBOL(symp, abfd) \
  { \
    (symp)->n_strx = bfd_h_get_32(abfd,			\
				(unsigned char *)&(symp)->n_strx);	\
    (symp)->n_desc = bfd_h_get_16 (abfd,			\
				(unsigned char *)&(symp)->n_desc);  	\
    (symp)->n_value = bfd_h_get_32 (abfd,			\
				(unsigned char *)&(symp)->n_value); 	\
  }

d954 4
a957 1
    (intern).n_value = bfd_h_get_32 (abfd, (extern)->e_value);		\
@


1.19.2.1
log
@2001-08-10  Daniel Jacobowitz  <drow@@mvista.com>
            H.J. Lu  (hjl@@gnu.org)

        * partial-stab.h: valu should be a CORE_ADDR.

2001-08-08  H.J. Lu  (hjl@@gnu.org)

        * dbxread.c (SWAP_SYMBOL): Removed.
        (INTERNALIZE_SYMBOL): Check sign extended vma.
@
text
@d949 10
d964 1
a964 4
    if (bfd_get_sign_extend_vma (abfd))					\
      (intern).n_value = bfd_h_get_signed_32 (abfd, (extern)->e_value);	\
    else								\
      (intern).n_value = bfd_h_get_32 (abfd, (extern)->e_value);	\
@


1.19.2.2
log
@	* dbxread.c (process_one_symbol): Don't use error result from
	find_stab_function_addr().
	* partial-stab.h (case 'F'): Likewise.

	* partial-stab.h (case 'f'): Make SOFUN_ADDRESS_MAYBE_MISSING
	code match that used for case 'F'.  This fixes the divergence
	that was introduced by my 1999-09-14 changes to partial-stab.h.
@
text
@d2273 2
a2274 12
		{
		  CORE_ADDR minsym_valu = 
		    find_stab_function_addr (name, last_source_file, objfile);

		  /* find_stab_function_addr will return 0 if the minimal
		     symbol wasn't found.  (Unfortunately, this might also
		     be a valid address.)  Anyway, if it *does* return 0,
		     it is likely that the value was set correctly to begin
		     with... */
		  if (minsym_valu != 0)
		    valu = minsym_valu;
		}
@


1.18
log
@(Changes from Daniel Berlin, with revisions by Jim Blandy.)

Abstract out operations specific to particular C++ ABI's, and
invoke them through a function table.  This removes the C++ ABI
dependencies scattered throughout the code, and allows us to
cleanly add support for new C++ ABI's.
* cp-abi.h, cp-abi.h, gnu-v2-abi.c, hpacc-abi.c: New files.
* c-typeprint.c, c-valprint.c, dbxread.c, eval.c, gdbtypes.c,
jv-typeprint.c, linespec.c, symtab.c, typeprint.c, valops.c:
#include "cp-abi.h".  These files all use functions now declared
there.
* symtab.h (OPNAME_PREFIX_P, VTBL_PREFIX_P, DESTRUCTOR_PREFIX_P):
Deleted.  These services are now provided by functions declared in
cp-abi.h.
* value.h (value_rtti_type, value_virtual_fn_field): Same.
* values.c (value_virtual_fn_field): Same, for this definition.
* valops.c (value_rtti_type): Same.
* c-typeprint.c (c_type_print_base): Use the functions from
"cp-abi.h", instead of the old macros, or hard-coded ABI-specific
tests.
* dbxread.c (record_minimal_symbol): Same.
* gdbtypes.c (get_destructor_fn_field, virtual_base_index,
virtual_base_index_skip_primaries): Same.
* jv-typeprint.c (java_type_print_base): Same.
* linespec.c (find_methods, decode_line_1): Same.
* symtab.c (gdb_mangle_name): Same.
* Makefile.in (SFILES): Add the new .c files mentioned above.
(cp_abi_h): New variable.
(COMMON_OBS): Add gnu-v2-abi.o, hpacc-abi.o, and cp-abi.o.
(cp-abi.o, gnu-v2-abi.o, hpacc-abi.o): New targets.
(c-typeprint.o, c-valprint.o, dbxread.o, eval.o, gdbtypes.o,
jv-typeprint.o, symtab.o, linespec.o, typeprint.o, valops.o): Add
dependency on $(cp_abi_h).
@
text
@d2393 13
a2411 1
    case N_MAIN:		/* Name of main routine.  */
@


1.18.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@a1022 6
static struct symtab *
find_corresponding_bincl_symtab (char *name, int instance)
{
  struct header_file_location *bincl;
  return lookup_symtab (name);
}
@


1.17
log
@* arch-utils.c (#include "gdbthread.h"): Removed.
(#include "symfile.h"): Removed.
(XMALLOC): Removed unused macro.
* breakpoint.c (tbreak_command): Removed local declaration.
(awatch_command, do_enable_breakpoint, set_breakpoint_count):
Remove duplicate declarations.
(bpstat_should_step, bpstat_have_active_hw_watchpoints)
(remove_solib_event_breakpoints): Fix indentation botch.
* c-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* ch-exp.c (ch_terminal_match_float_literal, parse_expr)
(parse_primval, parse_untyped_expr, parse_opt_untyped_expr):
Removed duplicate declarations.
* ch-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* corefile.c (#include "frame.h"): Removed
(#include "symfile.h"): Removed.
(#include "language.h"): Removed.
* dbxread.c (#include "command.h"): Removed.
* environ.c (#include "gdbcore.h"): Removed.
* event-loop.c (#include "top.h"): Removed.
* f-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
(#include "typeprint.h"): Removed.
(#include "frame.h"): Removed.
* gdbtypes.h (print_type_scalar): Removed declaration.
* infcmd.c (#include "completer.h"): Removed.
* language.c (#include "frame.h"): Removed.
* m2-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
* m2-valprint.c (#include "valprint.h"): Removed.
* p-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* p-valprint.c (#include "typeprint.h"): Removed.
* parse.c (#include "linespec.h"): Removed.
* regcache.c (#include "frame.h"): Removed.
* remote.c (#include "frame.h"): Removed.
(getpkt_sane): Make static.
* source.c (#include "completer.h"): Removed.
* stack.c (#include "symfile.h"): Removed.
(#include "objfiles.h"): Removed.
* symfile.c (#include "completer.h"): Removed.
* tracepoint.c (#include "completer.h"): Removed.
* values.c (#include "frame.h"): Removed.
* varobj.c (#include "valprint.h"): Removed.
* wrapper.c (#include "frame.h"): Removed.

* memattr.c (create_mem_region): Removed unused variable.
* remote-nrom.c: Removed spurious semicolon after init_nrom_ops.
-------------------------------------------------------------------
@
text
@d60 1
d518 1
a518 1
	if (VTBL_PREFIX_P ((tempstring)))
@


1.16
log
@2001-03-25  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	From  Andrew Cagney  <ac131313@@redhat.com>

        * coffread.c (coff_symtab_read): Initialize
 	``fcn_first_line_addr''.  Check that the ``.bf'' always preceeds
 	the ``.ef'' info.
	* dbxread.c (find_text_range): Initialize ``start'' and ``end''.
@
text
@a48 1
#include "command.h"
@


1.15
log
@2001-03-06  J.T. Conklin  <jtc@@redback.com>

        * symtab.h (decode_line_1): Removed declaration.

        * symfile.c (#include <assert.h>): Removed.

        * arch-utils.c (#include <ctype.h>): Removed.
        * c-typeprint.c: Likewise.
        * dbxread.c: Likewise.
        * gdbtypes.c: Likewise.
        * target.c: Likewise.
        * os9kread.c: Likewise.

        * c-valprint.c (#include "demangle.h"): Removed.
        * ch-typeprint.c: Likewise.
        * eval.c: Likewise.
        * f-typeprint.c: Likewise.
        * f-valprint.c: Likewise.
        * m2-typeprint.c: Likewise.
        * typeprint.c: Likewise.
        * p-typeprint.c: Likewise.
        * valarith.c: Likewise.
        * valprint.c: Likewise.

        * m2-typeprint.c (#include "gdb_string.h"): Removed.
        * nlmread.c: Likewise.

        * mdebugread.c (#include "gdb-stabs.h"): Removed.
        * minsyms.c: Likewise.
        * mipsread.c: Likewise.
        * nlmread.c: Likewise.

        * m2-typeprint.c (#include "obstack.h"): Removed.
        * m2-valprint.c: Likewise.

        * event-loop.c (#include <setjmp.h>): Removed.
@
text
@d216 2
a217 1
  CORE_ADDR start, end;
@


1.14
log
@Update/correct copyright notices.
@
text
@a46 1
#include <ctype.h>
@


1.13
log
@Replace calls to abort() with calls to internal_error().
@
text
@d2 2
a3 1
   Copyright 1986, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 1998
@


1.12
log
@        * dbxread.c (read_ofile_symtab): Stay with AUTO_DEMANGLING for G++.
        (process_one_symbol): Likewise.
        * dwarfread.c (handle_producer): Likewise.
@
text
@d2205 1
a2205 1
	    abort ();
@


1.11
log
@Replace free() with xfree().
@
text
@d1741 3
d1751 1
d1805 3
d1812 1
d2378 3
a2380 1
#if 1				/* Works, but is experimental.  -fnf */
@


1.10
log
@2000-12-08  Michael Snyder  <msnyder@@mvstp600e.cygnus.com>

        * alpha-tdep.c: Fix typo in comment.
        * dbxread.c: Fix typo in comment.
        * fr30-tdep.c: Fix typo: newline missing after comment.
        * mcore-tdep.c: Fix typo in comment.
@
text
@d326 1
a326 1
      free ((PTR) this_object_header_files);
d770 2
a771 2
	      free (hfiles[i].name);
	      free (hfiles[i].vector);
d773 1
a773 1
	  free ((PTR) hfiles);
d1096 1
a1096 1
  back_to = make_cleanup (free, dynsyms);
d1159 1
a1159 1
  make_cleanup (free, dynrels);
@


1.9
log
@
Spelling correction in comment:  dependant->dependent
@
text
@d791 1
a791 1
    /* sym and stabsstring for continuing information in cfront */
@


1.8
log
@Protoization.
@
text
@d794 1
a794 1
    /* state dependancies (statics that must be preserved) */
d799 1
a799 1
    /* other state dependancies include:
d1839 1
a1839 1
  /* Process items which we had to "process_later" due to dependancies 
@


1.7
log
@Protoization.
@
text
@d552 1
a552 3
dbx_symfile_read (objfile, mainline)
     struct objfile *objfile;
     int mainline;		/* FIXME comments above */
d814 2
a815 4
process_later (sym, p, f)
     struct symbol *sym;
     char *p;
     int (*f) (struct objfile *, struct symbol *, char *);
@


1.6
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d322 1
a322 1
free_header_files ()
d335 1
a335 1
init_header_files ()
d345 1
a345 2
add_this_object_header_file (i)
     int i;
d364 1
a364 3
add_old_header_file (name, instance)
     char *name;
     int instance;
d390 1
a390 3
add_new_header_file (name, instance)
     char *name;
     int instance;
d433 1
a433 2
explicit_lookup_type (real_filenum, index)
     int real_filenum, index;
d450 2
a451 5
record_minimal_symbol (name, address, type, objfile)
     char *name;
     CORE_ADDR address;
     int type;
     struct objfile *objfile;
d620 1
a620 2
dbx_new_init (ignore)
     struct objfile *ignore;
d644 1
a644 2
dbx_symfile_init (objfile)
     struct objfile *objfile;
d761 1
a761 2
dbx_symfile_finish (objfile)
     struct objfile *objfile;
d848 1
a848 2
process_now (objfile)
     struct objfile *objfile;
d917 1
a917 2
fill_symbuf (sym_bfd)
     bfd *sym_bfd;
d980 1
a980 2
dbx_next_symbol_text (objfile)
     struct objfile *objfile;
d1000 1
a1000 3
init_bincl_list (number, objfile)
     int number;
     struct objfile *objfile;
d1010 1
a1010 4
add_bincl_to_list (pst, name, instance)
     struct partial_symtab *pst;
     char *name;
     int instance;
d1031 1
a1031 3
find_corresponding_bincl_psymtab (name, instance)
     char *name;
     int instance;
d1047 1
a1047 2
free_bincl_list (objfile)
     struct objfile *objfile;
d1069 1
a1069 2
read_dbx_dynamic_symtab (objfile)
     struct objfile *objfile;
d1211 1
a1211 2
read_dbx_symtab (objfile)
     struct objfile *objfile;
d1373 3
a1375 7
start_psymtab (objfile, filename, textlow, ldsymoff, global_syms, static_syms)
     struct objfile *objfile;
     char *filename;
     CORE_ADDR textlow;
     int ldsymoff;
     struct partial_symbol **global_syms;
     struct partial_symbol **static_syms;
d1408 4
a1411 10
end_psymtab (pst, include_list, num_includes, capping_symbol_offset,
	capping_text, dependency_list, number_dependencies, textlow_not_set)
     struct partial_symtab *pst;
     char **include_list;
     int num_includes;
     int capping_symbol_offset;
     CORE_ADDR capping_text;
     struct partial_symtab **dependency_list;
     int number_dependencies;
     int textlow_not_set;
d1575 1
a1575 2
dbx_psymtab_to_symtab_1 (pst)
     struct partial_symtab *pst;
d1632 1
a1632 2
dbx_psymtab_to_symtab (pst)
     struct partial_symtab *pst;
d1675 1
a1675 2
read_ofile_symtab (pst)
     struct partial_symtab *pst;
d1868 3
a1870 6
process_one_symbol (type, desc, valu, name, section_offsets, objfile)
     int type, desc;
     CORE_ADDR valu;
     char *name;
     struct section_offsets *section_offsets;
     struct objfile *objfile;
d2453 4
a2456 10
coffstab_build_psymtabs (objfile, mainline,
			 textaddr, textsize, stabsects,
			 stabstroffset, stabstrsize)
     struct objfile *objfile;
     int mainline;
     CORE_ADDR textaddr;
     unsigned int textsize;
     struct stab_section_list *stabsects;
     file_ptr stabstroffset;
     unsigned int stabstrsize;
d2548 3
a2550 9
elfstab_build_psymtabs (objfile, mainline,
			staboffset, stabsize,
			stabstroffset, stabstrsize)
     struct objfile *objfile;
     int mainline;
     file_ptr staboffset;
     unsigned int stabsize;
     file_ptr stabstroffset;
     unsigned int stabstrsize;
d2618 2
a2619 7
stabsect_build_psymtabs (objfile, mainline, stab_name,
			 stabstr_name, text_name)
     struct objfile *objfile;
     int mainline;
     char *stab_name;
     char *stabstr_name;
     char *text_name;
d2695 1
a2695 1
_initialize_dbxread ()
@


1.5
log
@PARAMS removal.
@
text
@d812 1
a812 1
    int (*func) PARAMS ((struct objfile *, struct symbol *, char *));
d831 1
a831 1
     int (*f) PARAMS ((struct objfile *, struct symbol *, char *));
d870 1
a870 1
  int (*func) PARAMS ((struct objfile *, struct symbol *, char *));
@


1.4
log
@Purge (almost) make_cleanup_func.
@
text
@d268 1
a268 1
extern void _initialize_dbxread PARAMS ((void));
d270 1
a270 2
static void
process_now PARAMS ((struct objfile *));
d272 1
a272 2
static void
free_header_files PARAMS ((void));
d274 1
a274 2
static void
init_header_files PARAMS ((void));
d276 1
a276 2
static void
read_ofile_symtab PARAMS ((struct partial_symtab *));
d278 1
a278 2
static void
dbx_psymtab_to_symtab PARAMS ((struct partial_symtab *));
d280 1
a280 2
static void
dbx_psymtab_to_symtab_1 PARAMS ((struct partial_symtab *));
d282 1
a282 2
static void
read_dbx_dynamic_symtab PARAMS ((struct objfile * objfile));
d284 1
a284 2
static void
read_dbx_symtab PARAMS ((struct objfile *));
d286 1
a286 2
static void
free_bincl_list PARAMS ((struct objfile *));
d288 1
a288 2
static struct partial_symtab *
  find_corresponding_bincl_psymtab PARAMS ((char *, int));
d290 1
a290 2
static void
add_bincl_to_list PARAMS ((struct partial_symtab *, char *, int));
d292 1
a292 2
static void
init_bincl_list PARAMS ((int, struct objfile *));
d294 1
a294 2
static char *
  dbx_next_symbol_text PARAMS ((struct objfile *));
d296 1
a296 2
static void
fill_symbuf PARAMS ((bfd *));
d298 1
a298 2
static void
dbx_symfile_init PARAMS ((struct objfile *));
d300 1
a300 2
static void
dbx_new_init PARAMS ((struct objfile *));
d302 1
a302 2
static void
dbx_symfile_read PARAMS ((struct objfile *, int));
d304 1
a304 2
static void
dbx_symfile_finish PARAMS ((struct objfile *));
d306 1
a306 2
static void
record_minimal_symbol PARAMS ((char *, CORE_ADDR, int, struct objfile *));
d308 1
a308 2
static void
add_new_header_file PARAMS ((char *, int));
d310 1
a310 2
static void
add_old_header_file PARAMS ((char *, int));
d312 1
a312 2
static void
add_this_object_header_file PARAMS ((int));
d314 4
a317 3
static struct partial_symtab *
start_psymtab PARAMS ((struct objfile *, char *, CORE_ADDR, int,
		       struct partial_symbol **, struct partial_symbol **));
@


1.3
log
@Cleanup discard_minimal_symbols cleanup.
@
text
@d1097 12
d1310 1
a1310 1
  back_to = make_cleanup ((make_cleanup_func) free_bincl_list, objfile);
@


1.2
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d627 1
a627 1
  make_cleanup ((make_cleanup_func) discard_minimal_symbols, 0);
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d52 1
a52 1
#include "libaout.h"	 	/* FIXME Secret internal BFD stuff for a.out */
d64 1
a65 1

d77 2
a78 1
struct symloc {
d80 2
a81 2
  /* Offset within the file symbol table of first local symbol for this
     file.  */
d83 1
a83 1
  int ldsymoff;
d85 5
a89 5
  /* Length (in bytes) of the section of the symbol table devoted to
     this file's symbols (actually, the section bracketed may contain
     more than just this file's symbols).  If ldsymlen is 0, the only
     reason for this thing's existence is the dependency list.  Nothing
     else will happen when it is read in.  */
d91 1
a91 1
  int ldsymlen;
d93 1
a93 1
  /* The size of each symbol in the symbol file (in external form).  */
d95 1
a95 1
  int symbol_size;
d97 2
a98 2
  /* Further information needed to locate the symbols if they are in
     an ELF file.  */
d100 4
a103 4
  int symbol_offset;
  int string_offset;
  int file_string_offset;
};
d112 1
a113 1

d175 2
a176 2
struct complaint lbrac_complaint = 
  {"bad block start address patched", 0, 0};
d179 1
a179 1
  {"bad string table offset in symbol %d", 0, 0};
d182 1
a182 1
  {"unknown symbol type %s", 0, 0};
d185 1
a185 1
  {"unknown symbol descriptor `%c'", 0, 0};
d188 1
a188 1
  {"block start larger than block end", 0, 0};
d191 1
a191 1
  {"unmatched N_LBRAC before symtab pos %d", 0, 0};
d194 1
a194 1
  {"N_LBRAC/N_RBRAC symbol mismatch at symtab pos %d", 0, 0};
d197 1
a197 1
  {"\"repeated\" header file %s not previously seen, at symtab pos %d", 0, 0};
d200 46
a245 1
  {"N_BINCL %s not in entries for any file, at symtab pos %d", 0, 0};
d247 2
d268 3
a270 1
static void 
d289 1
a289 2
read_dbx_dynamic_symtab PARAMS ((struct section_offsets *,
				 struct objfile *objfile));
d292 1
a292 2
read_dbx_symtab PARAMS ((struct section_offsets *, struct objfile *,
			 CORE_ADDR, int));
d298 1
a298 1
find_corresponding_bincl_psymtab PARAMS ((char *, int));
d307 1
a307 1
dbx_next_symbol_text PARAMS ((struct objfile *));
d319 1
a319 1
dbx_symfile_read PARAMS ((struct objfile *, struct section_offsets *, int));
d336 4
d347 1
a347 1
      free ((PTR)this_object_header_files);
d374 1
a374 1
			    n_allocated_this_object_header_files * sizeof (int));
d447 1
a447 1
  hfile->name = savestring (name, strlen(name));
d470 1
a470 1
	     '\0', f->length * sizeof (struct type *) / 2);
d491 1
a491 1
      section = SECT_OFF_TEXT;
d496 1
a496 1
      section = SECT_OFF_DATA;
d501 1
a501 1
      section = SECT_OFF_BSS;
d512 1
a512 1
      section = SECT_OFF_DATA;
d517 2
a518 2
	 of going over many .o files, it doesn't make sense to have one
	 file local.  */
d520 1
a520 1
      section = SECT_OFF_DATA;
d529 1
a529 1
      section = SECT_OFF_TEXT;
d536 3
a538 3
	 Record it as global even if it's local, not global, so
	 lookup_minimal_symbol can find it.  We don't check symbol_leading_char
	 because for SunOS4 it always is '_'.  */
d550 1
a550 1
      section = SECT_OFF_DATA;
d555 1
a555 1
      section = SECT_OFF_BSS;
d563 1
a563 1
  }
a577 2
   SECTION_OFFSETS contains offsets relative to which the symbols in the
   various sections are (depending where the sections were actually loaded).
d582 1
a582 1
dbx_symfile_read (objfile, section_offsets, mainline)
d584 1
a584 2
     struct section_offsets *section_offsets;
     int mainline;	/* FIXME comments above */
a589 2
  val = strlen (objfile->name);

d607 1
d624 1
a624 1
  back_to = make_cleanup ((make_cleanup_func) really_free_pendings, 0);
d629 1
a629 2
  /* Now that the symbol table data of the executable file are all in core,
     process them and define symbols accordingly.  */
d631 1
a631 3
  read_dbx_symtab (section_offsets, objfile,
		   DBX_TEXT_ADDR (objfile),
		   DBX_TEXT_SIZE (objfile));
d635 1
a635 1
  read_dbx_dynamic_symtab (section_offsets, objfile);
d672 1
a672 1
#define DBX_STRINGTAB_SIZE_SIZE sizeof(long)   /* FIXME */
d686 1
a686 1
    xmmalloc (objfile -> md, sizeof (struct dbx_symfile_info));
d700 1
a700 1
  
d728 2
a729 2
	 will never be zero, even when there is no string table.  This
	 would appear to be a bug in bfd. */
d738 1
a738 1
      
d763 1
a763 1
	  
d768 1
a768 1
	  
d770 1
a770 1
	    (char *) obstack_alloc (&objfile -> psymbol_obstack,
d773 1
a773 1
	  
d775 1
a775 1
	  
d805 2
a806 2
	      free (hfiles [i].name);
	      free (hfiles [i].vector);
d810 1
a810 1
      mfree (objfile -> md, objfile->sym_stab_info);
d814 1
a815 1

d824 1
a824 1
struct cont_elem 
d827 2
a828 2
    struct symbol * sym;
    char * stabs;
d836 5
a840 5
        stringtab_global
        n_stabs
        objfile
        symfile_bfd */
};
d848 1
a848 1
void 
d850 3
a852 3
  struct symbol *sym;
  char *p;
  int (*f) PARAMS ((struct objfile *, struct symbol *, char *));
d858 1
a858 1
      cont_limit += 32;	/* chunk size */
d861 3
a863 3
	= (struct cont_elem *) xrealloc (cont_list, 
					  (cont_limit
					   * sizeof (struct cont_elem)));
d865 1
a865 1
        error ("Virtual memory exhausted\n");
d880 3
a882 3
static void 
process_now (objfile) 
  struct objfile *objfile;
d904 2
a905 2
      symbuf_end = cont_list[i].sym_end;  
      symnum = cont_list[i].symnum;  
d976 1
a976 1
  nbytes = bfd_read ((PTR)symbuf, count, 1, sym_bfd);
d1024 1
a1024 1
  INTERNALIZE_SYMBOL(nlist, &symbuf[symbuf_idx], symfile_bfd);
d1042 1
a1042 1
    xmmalloc (objfile -> md, bincls_allocated * sizeof(struct header_file_location));
d1058 2
a1059 2
	xmrealloc (pst->objfile->md, (char *)bincl_list,
		  bincls_allocated * sizeof (struct header_file_location));
d1093 1
a1093 1
  mfree (objfile -> md, (PTR)bincl_list);
d1101 1
a1101 2
read_dbx_dynamic_symtab (section_offsets, objfile)
     struct section_offsets *section_offsets;
d1160 1
a1160 1
	      sym_value += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d1165 1
a1165 1
	      sym_value += ANOFFSET (section_offsets, SECT_OFF_DATA);
d1170 1
a1170 1
	      sym_value += ANOFFSET (section_offsets, SECT_OFF_BSS);
d1194 1
a1194 1
  
d1211 1
a1211 1
	rel->address + ANOFFSET (section_offsets, SECT_OFF_DATA);
d1240 2
a1241 6
/* Given pointers to an a.out symbol table in core containing dbx
   style data, setup partial_symtab's describing each source file for
   which debugging information is available.
   SYMFILE_NAME is the name of the file we are reading from
   and SECTION_OFFSETS is the set of offsets for the various sections
   of the file (a set of zeros if the mainline program).  */
d1244 1
a1244 2
read_dbx_symtab (section_offsets, objfile, text_addr, text_size)
     struct section_offsets *section_offsets;
a1245 2
     CORE_ADDR text_addr;
     int text_size;
d1249 2
d1273 3
d1282 1
a1282 1
  
d1302 1
a1302 1
  lowest_text_address = (CORE_ADDR)-1;
d1314 1
a1314 1
      QUIT;	/* allow this to be interruptable */
d1336 7
a1342 7
	 *) The assignment to namestring.
	 *) The call to strchr.
	 *) The addition of a partial symbol the the two partial
	    symbol lists.  This last is a large section of code, so
	    I've imbedded it in the following macro.
	 */
      
d1361 2
a1362 2
#define START_PSYMTAB(ofile,secoff,fname,low,symoff,global_syms,static_syms)\
  start_psymtab(ofile, secoff, fname, low, symoff, global_syms, static_syms)
d1370 1
a1370 1
  if (DBX_SYMCOUNT (objfile) > 0			/* We have some syms */
d1373 2
a1374 2
      && objfile -> ei.entry_point < nlist.n_value
      && objfile -> ei.entry_point >= last_o_file_start)
d1376 2
a1377 2
      objfile -> ei.entry_file_lowpc = last_o_file_start;
      objfile -> ei.entry_file_highpc = nlist.n_value;
d1384 4
a1387 4
	(lowest_text_address == (CORE_ADDR)-1
	 ? (text_addr + section_offsets->offsets[SECT_OFF_TEXT])
	 : lowest_text_address)
	+ text_size;
d1406 2
a1407 3
struct partial_symtab *
start_psymtab (objfile, section_offsets,
	       filename, textlow, ldsymoff, global_syms, static_syms)
a1408 1
     struct section_offsets *section_offsets;
d1416 2
a1417 2
      start_psymtab_common(objfile, section_offsets,
			   filename, textlow, global_syms, static_syms);
d1420 2
a1421 2
    obstack_alloc (&objfile -> psymbol_obstack, sizeof (struct symloc));
  LDSYMOFF(result) = ldsymoff;
d1423 4
a1426 4
  SYMBOL_SIZE(result) = symbol_size;
  SYMBOL_OFFSET(result) = symbol_table_offset;
  STRING_OFFSET(result) = string_table_offset;
  FILE_STRING_OFFSET(result) = file_string_table_offset;
d1447 1
a1447 1
	     capping_text, dependency_list, number_dependencies, textlow_not_set)
d1458 1
a1458 1
  struct objfile *objfile = pst -> objfile;
d1461 1
a1461 1
    LDSYMLEN(pst) = capping_symbol_offset - LDSYMOFF(pst);
d1493 1
a1493 1
    
d1519 4
a1522 4
	 psymtabs for this objfile, and if any didn't know their ending text
	 address, set it to our starting address.  Take care to not set our
	 own ending address to our starting address, nor to set addresses on
	 `dependency' files that have both textlow and texthigh zero.  */
d1525 9
a1533 9
	{
	  if (p1->texthigh == 0  && p1->textlow != 0 && p1 != pst)
	    {
	      p1->texthigh = pst->textlow;
	      /* if this file has only data, then make textlow match texthigh */
	      if (p1->textlow == 0)
		p1->textlow = p1->texthigh;
	    }
	}
d1549 1
a1549 1
		       number_dependencies * sizeof (struct partial_symtab *));
d1551 1
a1551 1
	     number_dependencies * sizeof (struct partial_symtab *));
d1559 1
a1559 1
	allocate_psymtab (include_list[i], objfile);
d1561 1
d1564 6
a1569 6
	  (char *) obstack_alloc (&objfile->psymbol_obstack,
				  sizeof (struct symloc));
      LDSYMOFF(subpst) =
	LDSYMLEN(subpst) =
	  subpst->textlow =
	    subpst->texthigh = 0;
d1572 1
a1572 1
	 shared by the entire set of include files.  FIXME-someday.  */
d1581 2
a1582 2
	  subpst->statics_offset =
	    subpst->n_static_syms = 0;
d1603 1
a1603 1
	 it is on the obstack, but we can forget to chain it on the list.  */
d1605 4
a1608 4
	 any symbols in them.  There can be a lot of them.  But this check
	 is wrong, in that a psymtab with N_SLINE entries but nothing else
	 is not empty, but we don't realize that.  Fixing that without slowing
	 things down might be tricky.  */
d1613 1
a1613 1
      pst = (struct partial_symtab *)NULL;
d1624 1
a1624 1
  
d1631 1
a1631 1
	       pst->filename);
d1647 1
a1647 1
	    wrap_here ("");		/* Flush output */
d1653 1
a1653 1
  if (LDSYMLEN(pst))		/* Otherwise it's a dummy */
d1658 1
a1658 1
      old_chain = make_cleanup ((make_cleanup_func) really_free_pendings, 0);
d1688 1
a1688 1
	       pst->filename);
d1692 1
a1692 1
  if (LDSYMLEN(pst) || pst->number_of_dependencies)
d1695 1
a1695 1
	 to avoid disconcerting pauses.  */
d1719 1
a1719 1
  
d1738 2
a1739 2
  sym_offset = LDSYMOFF(pst);
  sym_size = LDSYMLEN(pst);
d1742 4
d1764 1
a1764 1
  if (!processing_acc_compilation && sym_offset >= (int)symbol_size)
d1790 1
a1790 1
	 producer. */
d1803 2
a1804 2
	 better not check the symbol before it.  I'm not this can
	 happen, but it doesn't hurt to check for it.  */
d1813 1
a1813 1
    error("First symbol in segment of executable not a source symbol");
d1823 1
a1823 1
	fill_symbuf(abfd);
d1832 2
a1833 1
      if (type & N_STAB) {
d1836 1
a1836 1
      }
d1857 4
a1860 3
      else if (type & N_EXT || type == (unsigned char)N_TEXT
	       || type == (unsigned char)N_NBTEXT
	       ) {
d1871 1
a1871 1
        }
d1888 1
a1888 1
  pst->symtab = end_symtab (text_offset + text_size, objfile, SECT_OFF_TEXT);
d1892 1
a1892 1
  process_now (objfile);	
d1896 1
a1897 1

d1906 5
a1910 3
          file were relocated when it was loaded into memory.
          All symbols that refer
	  to memory locations need to be offset by these amounts.
d1912 1
a1912 1
 	       It is used in end_symtab.  */
d1952 1
a1952 1
    function_start_offset = ANOFFSET (section_offsets, SECT_OFF_TEXT);
d1957 1
a1957 1
  if (last_source_file == NULL && type != (unsigned char)N_SO)
d1960 3
a1962 3
	 Currently no one puts symbols there, but we should deal
	 gracefully with the case.  A complain()t might be in order,
	 but this should not be an error ().  */
d1992 1
a1992 1
      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d2000 1
a2000 1
	 context within a function.  */
d2015 6
a2020 5
      if (!SUN_FIXED_LBRAC_BUG && valu < last_pc_address) {
	/* Patch current LBRAC pc value to match last handy pc value */
 	complain (&lbrac_complaint);
	valu = last_pc_address;
      }
d2027 1
a2027 1
	 context that was started with N_LBRAC.  */
d2041 1
a2041 1
      new = pop_context();
d2047 3
a2049 3
	 is true.  DESC is N_DESC from the N_RBRAC symbol.
	 GCC_P is true if we've detected the GCC_COMPILED_SYMBOL
	 or the GCC2_COMPILED_SYMBOL.  */
d2056 1
a2056 1
      if (!VARIABLES_INSIDE_BLOCK(desc, processing_gcc_compilation))
d2060 1
a2060 1
	  > !VARIABLES_INSIDE_BLOCK(desc, processing_gcc_compilation))
d2071 1
a2071 1
		 compilers?  Is this ever harmful?).  */
d2091 1
a2091 1
      if (VARIABLES_INSIDE_BLOCK(desc, processing_gcc_compilation))
d2100 1
a2100 1
      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d2105 3
a2107 3
	 for one source file.
	 Finish the symbol table of the previous source file
	 (if any) and start accumulating a new symbol table.  */
d2109 1
a2109 1
      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d2130 1
a2130 1
	     Patch things up. */	   
d2136 1
a2136 1
	  end_symtab (valu, objfile, SECT_OFF_TEXT);
d2141 1
a2141 1
	 Don't start a new symtab in this case.  */
d2146 1
a2146 1
        function_start_offset = 0;
d2155 3
a2157 3
	 a sub-source-file, one whose contents were copied or
	 included in the compilation of the main source file
	 (whose name was given in the N_SO symbol.)  */
d2159 1
a2159 1
      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d2179 2
a2180 2
	 one line-number -- core-address correspondence.
	 Enter it in the line list for this symbol table.  */
d2199 2
a2200 2
    /* The following symbol types need to have the appropriate offset added
       to their value; then we process symbol definitions in the name.  */
d2205 9
a2213 9
     /* HORRID HACK DEPT.  However, it's Sun's furgin' fault.
	Solaris2's stabs-in-elf makes *most* symbols relative
	but leaves a few absolute (at least for Solaris 2.1 and version
	2.0.1 of the SunPRO compiler).  N_STSYM and friends sit on the fence.
	.stab "foo:S...",N_STSYM 	is absolute (ld relocates it)
	.stab "foo:V...",N_STSYM	is relative (section base subtracted).
	This leaves us no choice but to search for the 'S' or 'V'...
	(or pass the whole section_offsets stuff down ONE MORE function
	call level, which we really don't want to do).  */
d2237 1
a2237 1
		valu += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d2242 11
a2252 6
	switch (type) {
	case N_STSYM: 	goto case_N_STSYM;
	case N_LCSYM:	goto case_N_LCSYM;
	case N_ROSYM:	goto case_N_ROSYM;
	default:	abort();
	}
d2257 1
a2257 1
      valu += ANOFFSET (section_offsets, SECT_OFF_DATA);
d2262 2
a2263 2
    /*   N_BROWS:	overlaps with N_BSLINE */
      valu += ANOFFSET (section_offsets, SECT_OFF_BSS);
d2267 1
a2267 1
      valu += ANOFFSET (section_offsets, SECT_OFF_RODATA);
d2272 1
a2272 1
      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d2275 2
a2276 2
    /* The following symbol types we don't know how to process.  Handle
       them in a "default" way, but complain to people who care.  */
d2281 2
a2282 2
    case N_M2C:			/* Modula-2 compilation unit */
    /*   N_MOD2:	overlaps with N_EHDECL */
d2293 2
a2294 2
    /* The following symbol types don't need the address field relocated,
       since it is either unused, or is absolute.  */
d2322 1
a2322 1
                 from N_FUN symbols.  */
d2324 3
a2326 29
		  && valu == ANOFFSET (section_offsets, SECT_OFF_TEXT))
		{
		  struct minimal_symbol *msym;
		  char *p;
		  int n;

		  p = strchr (name, ':');
		  if (p == NULL)
		    p = name;
		  n = p - name;
		  p = alloca (n + 2);
		  strncpy (p, name, n);
		  p[n] = 0;

		  msym = lookup_minimal_symbol (p, last_source_file,
						objfile);
		  if (msym == NULL)
		    {
		      /* Sun Fortran appends an underscore to the minimal
			 symbol name, try again with an appended underscore
			 if the minimal symbol was not found.  */
		      p[n] = '_';
		      p[n + 1] = 0;
		      msym = lookup_minimal_symbol (p, last_source_file,
						    objfile);
		    }
		  if (msym)
		    valu = SYMBOL_VALUE_ADDRESS (msym);
		}
d2331 13
a2343 13
		 functions with N_GSYM or N_STSYM.  The problem is
		 that the address of the symbol is no good (for N_GSYM
		 it doesn't even attept an address; for N_STSYM it
		 puts out an address but then it gets relocated
		 relative to the data segment, not the text segment).
		 Currently we can't fix this up later as we do for
		 some types of symbol in scan_file_globals.
		 Fortunately we do have a way of finding the address -
		 we know that the value in last_pc_address is either
		 the one we want (if we're dealing with the first
		 function in an object file), or somewhere in the
		 previous function. This means that we can use the
		 minimal symbol table to get the address.  */
d2346 7
a2352 7
		 under SunOS4, puts out functions with N_FUN and a value
		 of zero. This gets relocated to the start of the text
		 segment of the module, which is no good either.
		 Under SunOS4 we can deal with this as N_SLINE and N_SO
		 entries contain valid absolute addresses.
		 Release 3.0 acc also puts out N_OPT entries, which makes
		 it possible to discern acc from cc or gcc.  */
d2363 1
a2363 1
		      && SYMBOL_NAME (m) [l] == '\0')
d2366 3
a2368 3
		  else if (m && SYMBOL_NAME (m+1)
			   && STREQN (SYMBOL_NAME (m+1), name, l)
			   && SYMBOL_NAME (m+1) [l] == '\0')
d2370 1
a2370 1
		    valu = SYMBOL_VALUE (m+1);
d2386 1
a2386 1
		function_start_offset = valu;	
d2389 7
a2402 3
	      /* Stack must be empty now.  */
	      if (context_stack_depth != 0)
		complain (&lbrac_unmatched_complaint, symnum);
d2415 4
a2418 4
    /* We use N_OPT to carry the gcc2_compiled flag.  Sun uses it
       for a bunch of other flags, too.  Someday we may parse their
       flags; for now we ignore theirs and hope they'll ignore ours.  */
    case N_OPT:			/* Solaris 2:  Compiler options */
d2424 1
a2424 1
#if 1	      /* Works, but is experimental.  -fnf */
d2436 5
a2440 5
    /* The following symbol types can be ignored.  */
    case N_OBJ:			/* Solaris 2:  Object file dir and name */
    /*   N_UNDF: 		   Solaris 2:  file separator mark */
    /*   N_UNDF: -- we will never encounter it, since we only process one
		    file's symbols at once.  */
d2451 1
a2451 1
     symbol.  */  
d2462 1
a2462 1
	 reference list, then put it on the reference list.
d2464 2
a2465 2
	 We go ahead and advance NAME past the reference, even though
	 it is not strictly necessary at this time.  */
d2503 10
a2512 11
coffstab_build_psymtabs (objfile, section_offsets, mainline, 
			       textaddr, textsize, stabsects,
			       stabstroffset, stabstrsize)
      struct objfile *objfile;
      struct section_offsets *section_offsets;
      int mainline;
      CORE_ADDR textaddr;
      unsigned int textsize;
      struct stab_section_list *stabsects;
      file_ptr stabstroffset;
      unsigned int stabstrsize;
d2528 1
a2528 1
  DBX_SYMBOL_SIZE    (objfile) = COFF_STABS_SYMBOL_SIZE;
d2530 1
a2530 1
  
d2534 2
a2535 2
    obstack_alloc (&objfile->psymbol_obstack, stabstrsize+1);
  OBJSTAT (objfile, sz_strtab += stabstrsize+1);
d2580 1
a2580 1
  dbx_symfile_read (objfile, section_offsets, 0);
d2604 9
a2612 10
elfstab_build_psymtabs (objfile, section_offsets, mainline, 
			       staboffset, stabsize,
			       stabstroffset, stabstrsize)
      struct objfile *objfile;
      struct section_offsets *section_offsets;
      int mainline;
      file_ptr staboffset;
      unsigned int stabsize;
      file_ptr stabstroffset;
      unsigned int stabstrsize;
a2617 1
  asection *text_sect;
d2623 3
a2625 5
  text_sect = bfd_get_section_by_name (sym_bfd, ".text");
  if (!text_sect)
    error ("Can't find .text section in symbol file");
  DBX_TEXT_ADDR (objfile) = bfd_section_vma (sym_bfd, text_sect);
  DBX_TEXT_SIZE (objfile) = bfd_section_size (sym_bfd, text_sect);
d2628 2
a2629 2
  DBX_SYMBOL_SIZE    (objfile) = ELF_STABS_SYMBOL_SIZE;
  DBX_SYMCOUNT       (objfile) = stabsize / DBX_SYMBOL_SIZE (objfile);
d2631 2
a2632 2
  DBX_SYMTAB_OFFSET  (objfile) = staboffset;
  
d2636 2
a2637 2
    obstack_alloc (&objfile->psymbol_obstack, stabstrsize+1);
  OBJSTAT (objfile, sz_strtab += stabstrsize+1);
d2659 1
a2659 1
  dbx_symfile_read (objfile, section_offsets, 0);
d2671 1
a2671 1
	of the text segment).
d2673 1
a2673 1
	    shared lib or dynamically loaded file).
d2680 1
a2680 1
stabsect_build_psymtabs (objfile, section_offsets, mainline, stab_name,
a2682 1
     struct section_offsets *section_offsets;
d2715 2
a2716 2
  DBX_SYMBOL_SIZE    (objfile) = sizeof (struct external_nlist);
  DBX_SYMCOUNT       (objfile) = bfd_section_size (sym_bfd, stabsect)
d2719 2
a2720 2
  DBX_SYMTAB_OFFSET  (objfile) = stabsect->filepos; /* XXX - FIXME: POKING INSIDE BFD DATA STRUCTURES */
  
d2729 5
a2733 5
  val = bfd_get_section_contents (sym_bfd, /* bfd */
				  stabstrsect, /* bfd section */
				  DBX_STRINGTAB (objfile), /* input buffer */
				  0, /* offset into section */
				  DBX_STRINGTAB_SIZE (objfile)); /* amount to read */
d2747 1
a2747 1
  dbx_symfile_read (objfile, section_offsets, 0);
d2753 6
a2758 7
  dbx_new_init,		/* sym_new_init: init anything gbl to entire symtab */
  dbx_symfile_init,	/* sym_init: read initial info, setup for sym_read() */
  dbx_symfile_read,	/* sym_read: read a symbol file into symtab */
  dbx_symfile_finish,	/* sym_finish: finished with file, cleanup */
  default_symfile_offsets,
			/* sym_offsets: parse user's offsets to internal form */
  NULL			/* next: pointer to next struct sym_fns */
d2764 1
a2764 1
  add_symtab_fns(&aout_sym_fns);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a199 45
/* find_text_range --- find start and end of loadable code sections

   The find_text_range function finds the shortest address range that
   encloses all sections containing executable code, and stores it in
   objfile's text_addr and text_size members.

   dbx_symfile_read will use this to finish off the partial symbol
   table, in some cases.  */

static void
find_text_range (bfd *sym_bfd, struct objfile *objfile)
{
  asection *sec;
  int found_any = 0;
  CORE_ADDR start, end;
  
  for (sec = sym_bfd->sections; sec; sec = sec->next)
    if (bfd_get_section_flags (sym_bfd, sec) & SEC_CODE)
      {
	CORE_ADDR sec_start = bfd_section_vma (sym_bfd, sec);
	CORE_ADDR sec_end = sec_start + bfd_section_size (sym_bfd, sec);

	if (found_any)
	  {
	    if (sec_start < start) start = sec_start;
	    if (sec_end > end) end = sec_end;
	  }
	else
	  {
	    start = sec_start;
	    end = sec_end;
	  }

	found_any = 1;
      }

  if (! found_any)
    error ("Can't find any code sections in symbol file");

  DBX_TEXT_ADDR (objfile) = start;
  DBX_TEXT_SIZE (objfile) = end - start;
}



d2592 5
a2596 3
  /* Find the first and last text address.  dbx_symfile_read seems to
     want this.  */
  find_text_range (sym_bfd, objfile);
@


1.1.1.3
log
@import gdb-1999-05-25 snapshot
@
text
@a263 2
extern void _initialize_dbxread PARAMS ((void));

@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d51 1
a51 1
#include "libaout.h"		/* FIXME Secret internal BFD stuff for a.out */
d63 1
a64 1

d76 1
a76 2
struct symloc
  {
d78 2
a79 2
    /* Offset within the file symbol table of first local symbol for this
       file.  */
d81 1
a81 1
    int ldsymoff;
d83 5
a87 5
    /* Length (in bytes) of the section of the symbol table devoted to
       this file's symbols (actually, the section bracketed may contain
       more than just this file's symbols).  If ldsymlen is 0, the only
       reason for this thing's existence is the dependency list.  Nothing
       else will happen when it is read in.  */
d89 1
a89 1
    int ldsymlen;
d91 1
a91 1
    /* The size of each symbol in the symbol file (in external form).  */
d93 1
a93 1
    int symbol_size;
d95 2
a96 2
    /* Further information needed to locate the symbols if they are in
       an ELF file.  */
d98 4
a101 4
    int symbol_offset;
    int string_offset;
    int file_string_offset;
  };
d110 1
a111 1

d173 2
a174 2
struct complaint lbrac_complaint =
{"bad block start address patched", 0, 0};
d177 1
a177 1
{"bad string table offset in symbol %d", 0, 0};
d180 1
a180 1
{"unknown symbol type %s", 0, 0};
d183 1
a183 1
{"unknown symbol descriptor `%c'", 0, 0};
d186 1
a186 1
{"block start larger than block end", 0, 0};
d189 1
a189 1
{"unmatched N_LBRAC before symtab pos %d", 0, 0};
d192 1
a192 1
{"N_LBRAC/N_RBRAC symbol mismatch at symtab pos %d", 0, 0};
d195 1
a195 1
{"\"repeated\" header file %s not previously seen, at symtab pos %d", 0, 0};
d198 1
a198 1
{"N_BINCL %s not in entries for any file, at symtab pos %d", 0, 0};
d210 1
a210 1
find_text_range (bfd * sym_bfd, struct objfile *objfile)
d215 1
a215 1

d224 2
a225 4
	    if (sec_start < start)
	      start = sec_start;
	    if (sec_end > end)
	      end = sec_end;
d236 1
a236 1
  if (!found_any)
a241 1

d244 1
d266 1
a266 1
static void
d286 1
a286 1
				 struct objfile * objfile));
d296 1
a296 1
  find_corresponding_bincl_psymtab PARAMS ((char *, int));
d305 1
a305 1
  dbx_next_symbol_text PARAMS ((struct objfile *));
d341 1
a341 1
      free ((PTR) this_object_header_files);
d368 1
a368 1
		       n_allocated_this_object_header_files * sizeof (int));
d441 1
a441 1
  hfile->name = savestring (name, strlen (name));
d464 1
a464 1
	      '\0', f->length * sizeof (struct type *) / 2);
d511 2
a512 2
         of going over many .o files, it doesn't make sense to have one
         file local.  */
d530 3
a532 3
         Record it as global even if it's local, not global, so
         lookup_minimal_symbol can find it.  We don't check symbol_leading_char
         because for SunOS4 it always is '_'.  */
d557 1
a557 1
    }
d581 1
a581 1
     int mainline;		/* FIXME comments above */
d673 1
a673 1
#define DBX_STRINGTAB_SIZE_SIZE sizeof(long)	/* FIXME */
d687 1
a687 1
    xmmalloc (objfile->md, sizeof (struct dbx_symfile_info));
d701 1
a701 1

d729 2
a730 2
         will never be zero, even when there is no string table.  This
         would appear to be a bug in bfd. */
d739 1
a739 1

d764 1
a764 1

d769 1
a769 1

d771 1
a771 1
	    (char *) obstack_alloc (&objfile->psymbol_obstack,
d774 1
a774 1

d776 1
a776 1

d806 2
a807 2
	      free (hfiles[i].name);
	      free (hfiles[i].vector);
d811 1
a811 1
      mfree (objfile->md, objfile->sym_stab_info);
d815 1
a816 1

d825 1
a825 1
struct cont_elem
d828 2
a829 2
    struct symbol *sym;
    char *stabs;
d837 5
a841 5
       stringtab_global
       n_stabs
       objfile
       symfile_bfd */
  };
d849 1
a849 1
void
d851 3
a853 3
     struct symbol *sym;
     char *p;
     int (*f) PARAMS ((struct objfile *, struct symbol *, char *));
d859 1
a859 1
      cont_limit += 32;		/* chunk size */
d862 3
a864 3
	= (struct cont_elem *) xrealloc (cont_list,
					 (cont_limit
					  * sizeof (struct cont_elem)));
d866 1
a866 1
	error ("Virtual memory exhausted\n");
d881 3
a883 3
static void
process_now (objfile)
     struct objfile *objfile;
d905 2
a906 2
      symbuf_end = cont_list[i].sym_end;
      symnum = cont_list[i].symnum;
d977 1
a977 1
  nbytes = bfd_read ((PTR) symbuf, count, 1, sym_bfd);
d1025 1
a1025 1
  INTERNALIZE_SYMBOL (nlist, &symbuf[symbuf_idx], symfile_bfd);
d1043 1
a1043 1
    xmmalloc (objfile->md, bincls_allocated * sizeof (struct header_file_location));
d1059 2
a1060 2
	xmrealloc (pst->objfile->md, (char *) bincl_list,
		   bincls_allocated * sizeof (struct header_file_location));
d1094 1
a1094 1
  mfree (objfile->md, (PTR) bincl_list);
d1196 1
a1196 1

d1213 1
a1213 1
      rel->address + ANOFFSET (section_offsets, SECT_OFF_DATA);
d1286 1
a1286 1

d1306 1
a1306 1
  lowest_text_address = (CORE_ADDR) - 1;
d1318 1
a1318 1
      QUIT;			/* allow this to be interruptable */
d1340 7
a1346 7
         *) The assignment to namestring.
         *) The call to strchr.
         *) The addition of a partial symbol the the two partial
         symbol lists.  This last is a large section of code, so
         I've imbedded it in the following macro.
       */

d1374 1
a1374 1
  if (DBX_SYMCOUNT (objfile) > 0	/* We have some syms */
d1377 2
a1378 2
      && objfile->ei.entry_point < nlist.n_value
      && objfile->ei.entry_point >= last_o_file_start)
d1380 2
a1381 2
      objfile->ei.entry_file_lowpc = last_o_file_start;
      objfile->ei.entry_file_highpc = nlist.n_value;
d1388 4
a1391 4
      (lowest_text_address == (CORE_ADDR) - 1
       ? (text_addr + section_offsets->offsets[SECT_OFF_TEXT])
       : lowest_text_address)
      + text_size;
d1422 2
a1423 2
  start_psymtab_common (objfile, section_offsets,
			filename, textlow, global_syms, static_syms);
d1426 2
a1427 2
    obstack_alloc (&objfile->psymbol_obstack, sizeof (struct symloc));
  LDSYMOFF (result) = ldsymoff;
d1429 4
a1432 4
  SYMBOL_SIZE (result) = symbol_size;
  SYMBOL_OFFSET (result) = symbol_table_offset;
  STRING_OFFSET (result) = string_table_offset;
  FILE_STRING_OFFSET (result) = file_string_table_offset;
d1453 1
a1453 1
	capping_text, dependency_list, number_dependencies, textlow_not_set)
d1464 1
a1464 1
  struct objfile *objfile = pst->objfile;
d1467 1
a1467 1
    LDSYMLEN (pst) = capping_symbol_offset - LDSYMOFF (pst);
d1499 1
a1499 1

d1525 4
a1528 4
         psymtabs for this objfile, and if any didn't know their ending text
         address, set it to our starting address.  Take care to not set our
         own ending address to our starting address, nor to set addresses on
         `dependency' files that have both textlow and texthigh zero.  */
d1531 9
a1539 9
      {
	if (p1->texthigh == 0 && p1->textlow != 0 && p1 != pst)
	  {
	    p1->texthigh = pst->textlow;
	    /* if this file has only data, then make textlow match texthigh */
	    if (p1->textlow == 0)
	      p1->textlow = p1->texthigh;
	  }
      }
d1555 1
a1555 1
		    number_dependencies * sizeof (struct partial_symtab *));
d1557 1
a1557 1
	      number_dependencies * sizeof (struct partial_symtab *));
d1565 1
a1565 1
      allocate_psymtab (include_list[i], objfile);
d1569 6
a1574 6
	(char *) obstack_alloc (&objfile->psymbol_obstack,
				sizeof (struct symloc));
      LDSYMOFF (subpst) =
	LDSYMLEN (subpst) =
	subpst->textlow =
	subpst->texthigh = 0;
d1577 1
a1577 1
         shared by the entire set of include files.  FIXME-someday.  */
d1586 2
a1587 2
	subpst->statics_offset =
	subpst->n_static_syms = 0;
d1608 1
a1608 1
         it is on the obstack, but we can forget to chain it on the list.  */
d1610 4
a1613 4
         any symbols in them.  There can be a lot of them.  But this check
         is wrong, in that a psymtab with N_SLINE entries but nothing else
         is not empty, but we don't realize that.  Fixing that without slowing
         things down might be tricky.  */
d1618 1
a1618 1
      pst = (struct partial_symtab *) NULL;
d1629 1
a1629 1

d1636 1
a1636 1
			  pst->filename);
d1652 1
a1652 1
	    wrap_here ("");	/* Flush output */
d1658 1
a1658 1
  if (LDSYMLEN (pst))		/* Otherwise it's a dummy */
d1693 1
a1693 1
			  pst->filename);
d1697 1
a1697 1
  if (LDSYMLEN (pst) || pst->number_of_dependencies)
d1700 1
a1700 1
         to avoid disconcerting pauses.  */
d1724 1
a1724 1

d1743 2
a1744 2
  sym_offset = LDSYMOFF (pst);
  sym_size = LDSYMLEN (pst);
d1765 1
a1765 1
  if (!processing_acc_compilation && sym_offset >= (int) symbol_size)
d1791 1
a1791 1
         producer. */
d1804 2
a1805 2
         better not check the symbol before it.  I'm not this can
         happen, but it doesn't hurt to check for it.  */
d1814 1
a1814 1
    error ("First symbol in segment of executable not a source symbol");
d1824 1
a1824 1
	fill_symbuf (abfd);
d1833 1
a1833 2
      if (type & N_STAB)
	{
d1836 1
a1836 1
	}
d1857 3
a1859 4
      else if (type & N_EXT || type == (unsigned char) N_TEXT
	       || type == (unsigned char) N_NBTEXT
	)
	{
d1870 1
a1870 1
	}
d1891 1
a1891 1
  process_now (objfile);
d1895 1
a1896 1

d1905 3
a1907 3
   file were relocated when it was loaded into memory.
   All symbols that refer
   to memory locations need to be offset by these amounts.
d1909 1
a1909 1
   It is used in end_symtab.  */
d1954 1
a1954 1
  if (last_source_file == NULL && type != (unsigned char) N_SO)
d1957 3
a1959 3
         Currently no one puts symbols there, but we should deal
         gracefully with the case.  A complain()t might be in order,
         but this should not be an error ().  */
d1997 1
a1997 1
         context within a function.  */
d2012 5
a2016 6
      if (!SUN_FIXED_LBRAC_BUG && valu < last_pc_address)
	{
	  /* Patch current LBRAC pc value to match last handy pc value */
	  complain (&lbrac_complaint);
	  valu = last_pc_address;
	}
d2023 1
a2023 1
         context that was started with N_LBRAC.  */
d2037 1
a2037 1
      new = pop_context ();
d2043 3
a2045 3
         is true.  DESC is N_DESC from the N_RBRAC symbol.
         GCC_P is true if we've detected the GCC_COMPILED_SYMBOL
         or the GCC2_COMPILED_SYMBOL.  */
d2052 1
a2052 1
      if (!VARIABLES_INSIDE_BLOCK (desc, processing_gcc_compilation))
d2056 1
a2056 1
	  > !VARIABLES_INSIDE_BLOCK (desc, processing_gcc_compilation))
d2067 1
a2067 1
	         compilers?  Is this ever harmful?).  */
d2087 1
a2087 1
      if (VARIABLES_INSIDE_BLOCK (desc, processing_gcc_compilation))
d2101 3
a2103 3
         for one source file.
         Finish the symbol table of the previous source file
         (if any) and start accumulating a new symbol table.  */
d2126 1
a2126 1
	     Patch things up. */
d2137 1
a2137 1
         Don't start a new symtab in this case.  */
d2142 1
a2142 1
	function_start_offset = 0;
d2151 3
a2153 3
         a sub-source-file, one whose contents were copied or
         included in the compilation of the main source file
         (whose name was given in the N_SO symbol.)  */
d2175 2
a2176 2
         one line-number -- core-address correspondence.
         Enter it in the line list for this symbol table.  */
d2195 2
a2196 2
      /* The following symbol types need to have the appropriate offset added
         to their value; then we process symbol definitions in the name.  */
d2201 9
a2209 9
      /* HORRID HACK DEPT.  However, it's Sun's furgin' fault.
         Solaris2's stabs-in-elf makes *most* symbols relative
         but leaves a few absolute (at least for Solaris 2.1 and version
         2.0.1 of the SunPRO compiler).  N_STSYM and friends sit on the fence.
         .stab "foo:S...",N_STSYM        is absolute (ld relocates it)
         .stab "foo:V...",N_STSYM        is relative (section base subtracted).
         This leaves us no choice but to search for the 'S' or 'V'...
         (or pass the whole section_offsets stuff down ONE MORE function
         call level, which we really don't want to do).  */
d2238 6
a2243 11
	switch (type)
	  {
	  case N_STSYM:
	    goto case_N_STSYM;
	  case N_LCSYM:
	    goto case_N_LCSYM;
	  case N_ROSYM:
	    goto case_N_ROSYM;
	  default:
	    abort ();
	  }
d2253 1
a2253 1
      /*   N_BROWS:       overlaps with N_BSLINE */
d2266 2
a2267 2
      /* The following symbol types we don't know how to process.  Handle
         them in a "default" way, but complain to people who care.  */
d2272 2
a2273 2
    case N_M2C:		/* Modula-2 compilation unit */
      /*   N_MOD2:        overlaps with N_EHDECL */
d2284 2
a2285 2
      /* The following symbol types don't need the address field relocated,
         since it is either unused, or is absolute.  */
d2313 1
a2313 1
	         from N_FUN symbols.  */
d2334 2
a2335 2
		         symbol name, try again with an appended underscore
		         if the minimal symbol was not found.  */
d2348 13
a2360 13
	         functions with N_GSYM or N_STSYM.  The problem is
	         that the address of the symbol is no good (for N_GSYM
	         it doesn't even attept an address; for N_STSYM it
	         puts out an address but then it gets relocated
	         relative to the data segment, not the text segment).
	         Currently we can't fix this up later as we do for
	         some types of symbol in scan_file_globals.
	         Fortunately we do have a way of finding the address -
	         we know that the value in last_pc_address is either
	         the one we want (if we're dealing with the first
	         function in an object file), or somewhere in the
	         previous function. This means that we can use the
	         minimal symbol table to get the address.  */
d2363 7
a2369 7
	         under SunOS4, puts out functions with N_FUN and a value
	         of zero. This gets relocated to the start of the text
	         segment of the module, which is no good either.
	         Under SunOS4 we can deal with this as N_SLINE and N_SO
	         entries contain valid absolute addresses.
	         Release 3.0 acc also puts out N_OPT entries, which makes
	         it possible to discern acc from cc or gcc.  */
d2380 1
a2380 1
		      && SYMBOL_NAME (m)[l] == '\0')
d2383 3
a2385 3
		  else if (m && SYMBOL_NAME (m + 1)
			   && STREQN (SYMBOL_NAME (m + 1), name, l)
			   && SYMBOL_NAME (m + 1)[l] == '\0')
d2387 1
a2387 1
		    valu = SYMBOL_VALUE (m + 1);
d2403 1
a2403 1
		function_start_offset = valu;
d2428 4
a2431 4
      /* We use N_OPT to carry the gcc2_compiled flag.  Sun uses it
         for a bunch of other flags, too.  Someday we may parse their
         flags; for now we ignore theirs and hope they'll ignore ours.  */
    case N_OPT:		/* Solaris 2:  Compiler options */
d2437 1
a2437 1
#if 1				/* Works, but is experimental.  -fnf */
d2449 5
a2453 5
      /* The following symbol types can be ignored.  */
    case N_OBJ:		/* Solaris 2:  Object file dir and name */
      /*   N_UNDF:                   Solaris 2:  file separator mark */
      /*   N_UNDF: -- we will never encounter it, since we only process one
         file's symbols at once.  */
d2464 1
a2464 1
     symbol.  */
d2475 1
a2475 1
         reference list, then put it on the reference list.
d2477 2
a2478 2
         We go ahead and advance NAME past the reference, even though
         it is not strictly necessary at this time.  */
d2516 11
a2526 11
coffstab_build_psymtabs (objfile, section_offsets, mainline,
			 textaddr, textsize, stabsects,
			 stabstroffset, stabstrsize)
     struct objfile *objfile;
     struct section_offsets *section_offsets;
     int mainline;
     CORE_ADDR textaddr;
     unsigned int textsize;
     struct stab_section_list *stabsects;
     file_ptr stabstroffset;
     unsigned int stabstrsize;
d2542 1
a2542 1
  DBX_SYMBOL_SIZE (objfile) = COFF_STABS_SYMBOL_SIZE;
d2544 1
a2544 1

d2548 2
a2549 2
    obstack_alloc (&objfile->psymbol_obstack, stabstrsize + 1);
  OBJSTAT (objfile, sz_strtab += stabstrsize + 1);
d2618 10
a2627 10
elfstab_build_psymtabs (objfile, section_offsets, mainline,
			staboffset, stabsize,
			stabstroffset, stabstrsize)
     struct objfile *objfile;
     struct section_offsets *section_offsets;
     int mainline;
     file_ptr staboffset;
     unsigned int stabsize;
     file_ptr stabstroffset;
     unsigned int stabstrsize;
d2644 2
a2645 2
  DBX_SYMBOL_SIZE (objfile) = ELF_STABS_SYMBOL_SIZE;
  DBX_SYMCOUNT (objfile) = stabsize / DBX_SYMBOL_SIZE (objfile);
d2647 2
a2648 2
  DBX_SYMTAB_OFFSET (objfile) = staboffset;

d2652 2
a2653 2
    obstack_alloc (&objfile->psymbol_obstack, stabstrsize + 1);
  OBJSTAT (objfile, sz_strtab += stabstrsize + 1);
d2687 1
a2687 1
   of the text segment).
d2689 1
a2689 1
   shared lib or dynamically loaded file).
d2732 2
a2733 2
  DBX_SYMBOL_SIZE (objfile) = sizeof (struct external_nlist);
  DBX_SYMCOUNT (objfile) = bfd_section_size (sym_bfd, stabsect)
d2736 2
a2737 2
  DBX_SYMTAB_OFFSET (objfile) = stabsect->filepos;	/* XXX - FIXME: POKING INSIDE BFD DATA STRUCTURES */

d2746 5
a2750 5
  val = bfd_get_section_contents (sym_bfd,	/* bfd */
				  stabstrsect,	/* bfd section */
				  DBX_STRINGTAB (objfile),	/* input buffer */
				  0,	/* offset into section */
				  DBX_STRINGTAB_SIZE (objfile));	/* amount to read */
d2770 4
a2773 4
  dbx_new_init,			/* sym_new_init: init anything gbl to entire symtab */
  dbx_symfile_init,		/* sym_init: read initial info, setup for sym_read() */
  dbx_symfile_read,		/* sym_read: read a symbol file into symtab */
  dbx_symfile_finish,		/* sym_finish: finished with file, cleanup */
d2776 1
a2776 1
  NULL				/* next: pointer to next struct sym_fns */
d2782 1
a2782 1
  add_symtab_fns (&aout_sym_fns);
@


1.1.1.5
log
@import gdb-1999-08-02 snapshot
@
text
@d626 1
a626 1
  back_to = make_cleanup (really_free_pendings, 0);
d1667 1
a1667 1
      old_chain = make_cleanup (really_free_pendings, 0);
@


1.1.1.6
log
@import gdb-1999-08-09 snapshot
@
text
@d289 2
a290 1
read_dbx_dynamic_symtab PARAMS ((struct objfile * objfile));
d293 2
a294 1
read_dbx_symtab PARAMS ((struct objfile *, CORE_ADDR, int));
d321 1
a321 1
dbx_symfile_read PARAMS ((struct objfile *, int));
d582 1
a582 1
dbx_symfile_read (objfile, mainline)
d584 1
d634 1
a634 1
  read_dbx_symtab (objfile,
d640 1
a640 1
  read_dbx_dynamic_symtab (objfile);
d1106 2
a1107 1
read_dbx_dynamic_symtab (objfile)
d1166 1
a1166 1
	      sym_value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d1171 1
a1171 1
	      sym_value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d1176 1
a1176 1
	      sym_value += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS);
d1217 1
a1217 1
      rel->address + ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d1254 2
a1255 1
read_dbx_symtab (objfile, text_addr, text_size)
d1310 1
a1310 1
  lowest_text_address = (CORE_ADDR) -1;
d1392 2
a1393 2
      (lowest_text_address == (CORE_ADDR) -1
       ? (text_addr + objfile->section_offsets->offsets[SECT_OFF_TEXT])
d2528 1
a2528 1
coffstab_build_psymtabs (objfile, mainline,
d2532 1
d2606 1
a2606 1
  dbx_symfile_read (objfile, 0);
d2630 1
a2630 1
elfstab_build_psymtabs (objfile, mainline,
d2634 1
d2687 1
a2687 1
  dbx_symfile_read (objfile, 0);
d2708 1
a2708 1
stabsect_build_psymtabs (objfile, mainline, stab_name,
d2711 1
d2776 1
a2776 1
  dbx_symfile_read (objfile, 0);
d2786 2
a2787 1
  default_symfile_offsets,	/* sym_offsets: parse user's offsets to internal form */
@


1.1.1.7
log
@import gdb-1999-09-08 snapshot
@
text
@d292 1
a292 1
read_dbx_symtab PARAMS ((struct objfile *));
a335 4
static struct partial_symtab *
start_psymtab PARAMS ((struct objfile *, char *, CORE_ADDR, int,
		       struct partial_symbol **, struct partial_symbol **));

d574 2
d588 2
d628 2
a629 1
  /* Read stabs data from executable file and define symbols. */
d631 3
a633 1
  read_dbx_symtab (objfile);
d1242 6
a1247 2
/* Setup partial_symtab's describing each source file for which
   debugging information is available. */
d1250 1
a1250 1
read_dbx_symtab (objfile)
d1252 2
a1256 2
  CORE_ADDR text_addr;
  int text_size;
a1278 3
  text_addr = DBX_TEXT_ADDR (objfile);
  text_size = DBX_TEXT_SIZE (objfile);

d1364 2
a1365 2
#define START_PSYMTAB(ofile,fname,low,symoff,global_syms,static_syms)\
  start_psymtab(ofile, fname, low, symoff, global_syms, static_syms)
d1388 1
a1388 1
       ? (text_addr + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT))
d1409 3
a1411 2
static struct partial_symtab *
start_psymtab (objfile, filename, textlow, ldsymoff, global_syms, static_syms)
d1413 1
d1421 1
a1421 1
  start_psymtab_common (objfile, objfile->section_offsets,
d2638 1
@


1.1.1.8
log
@import gdb-1999-09-21
@
text
@d2317 28
a2344 2
		valu = 
		  find_stab_function_addr (name, last_source_file, objfile);
@


1.1.1.9
log
@import gdb-1999-12-06 snapshot
@
text
@a606 1
     || (0 == strncmp (bfd_get_target (sym_bfd), "epoc-pe", 7))
@


1.1.1.10
log
@import gdb-2000-01-05 snapshot
@
text
@a2381 7

	      if (context_stack_depth > 1)
		{
		  complain (&lbrac_unmatched_complaint, symnum);
		  break;
		}

d2389 3
@


