head	1.42;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.42
	gdb_7_6-2013-04-26-release:1.42
	gdb_7_6-branch:1.42.0.2
	gdb_7_6-2013-03-12-branchpoint:1.42
	gdb_7_5_1-2012-11-29-release:1.41
	gdb_7_5-2012-08-17-release:1.41
	gdb_7_5-branch:1.41.0.2
	gdb_7_5-2012-07-18-branchpoint:1.41
	gdb_7_4_1-2012-04-26-release:1.40.4.1
	gdb_7_4-2012-01-24-release:1.40.4.1
	gdb_7_4-branch:1.40.0.4
	gdb_7_4-2011-12-13-branchpoint:1.40
	gdb_7_3_1-2011-09-04-release:1.40
	gdb_7_3-2011-07-26-release:1.40
	gdb_7_3-branch:1.40.0.2
	gdb_7_3-2011-04-01-branchpoint:1.40
	gdb_7_2-2010-09-02-release:1.37
	gdb_7_2-branch:1.37.0.2
	gdb_7_2-2010-07-07-branchpoint:1.37
	gdb_7_1-2010-03-18-release:1.36
	gdb_7_1-branch:1.36.0.2
	gdb_7_1-2010-02-18-branchpoint:1.36
	gdb_7_0_1-2009-12-22-release:1.35
	gdb_7_0-2009-10-06-release:1.35
	gdb_7_0-branch:1.35.0.4
	gdb_7_0-2009-09-16-branchpoint:1.35
	arc-sim-20090309:1.32
	msnyder-checkpoint-072509-branch:1.35.0.2
	msnyder-checkpoint-072509-branchpoint:1.35
	arc-insight_6_8-branch:1.32.0.16
	arc-insight_6_8-branchpoint:1.32
	insight_6_8-branch:1.32.0.14
	insight_6_8-branchpoint:1.32
	reverse-20081226-branch:1.32.0.12
	reverse-20081226-branchpoint:1.32
	multiprocess-20081120-branch:1.32.0.10
	multiprocess-20081120-branchpoint:1.32
	reverse-20080930-branch:1.32.0.8
	reverse-20080930-branchpoint:1.32
	reverse-20080717-branch:1.32.0.6
	reverse-20080717-branchpoint:1.32
	msnyder-reverse-20080609-branch:1.32.0.4
	msnyder-reverse-20080609-branchpoint:1.32
	drow-reverse-20070409-branch:1.24.0.2
	drow-reverse-20070409-branchpoint:1.24
	gdb_6_8-2008-03-27-release:1.32
	gdb_6_8-branch:1.32.0.2
	gdb_6_8-2008-02-26-branchpoint:1.32
	gdb_6_7_1-2007-10-29-release:1.31
	gdb_6_7-2007-10-10-release:1.31
	gdb_6_7-branch:1.31.0.2
	gdb_6_7-2007-09-07-branchpoint:1.31
	insight_6_6-20070208-release:1.22
	gdb_6_6-2006-12-18-release:1.22
	gdb_6_6-branch:1.22.0.18
	gdb_6_6-2006-11-15-branchpoint:1.22
	insight_6_5-20061003-release:1.22
	gdb-csl-symbian-6_4_50_20060226-12:1.22
	gdb-csl-sourcerygxx-3_4_4-25:1.21
	nickrob-async-20060828-mergepoint:1.22
	gdb-csl-symbian-6_4_50_20060226-11:1.22
	gdb-csl-sourcerygxx-4_1-17:1.22
	gdb-csl-20060226-branch-local-2:1.22
	gdb-csl-sourcerygxx-4_1-14:1.22
	gdb-csl-sourcerygxx-4_1-13:1.22
	gdb-csl-sourcerygxx-4_1-12:1.22
	gdb-csl-sourcerygxx-3_4_4-21:1.22
	gdb_6_5-20060621-release:1.22
	gdb-csl-sourcerygxx-4_1-9:1.22
	gdb-csl-sourcerygxx-4_1-8:1.22
	gdb-csl-sourcerygxx-4_1-7:1.22
	gdb-csl-arm-2006q1-6:1.22
	gdb-csl-sourcerygxx-4_1-6:1.22
	gdb-csl-symbian-6_4_50_20060226-10:1.22
	gdb-csl-symbian-6_4_50_20060226-9:1.22
	gdb-csl-symbian-6_4_50_20060226-8:1.22
	gdb-csl-coldfire-4_1-11:1.22
	gdb-csl-sourcerygxx-3_4_4-19:1.22
	gdb-csl-coldfire-4_1-10:1.22
	gdb_6_5-branch:1.22.0.16
	gdb_6_5-2006-05-14-branchpoint:1.22
	gdb-csl-sourcerygxx-4_1-5:1.22
	nickrob-async-20060513-branch:1.22.0.14
	nickrob-async-20060513-branchpoint:1.22
	gdb-csl-sourcerygxx-4_1-4:1.22
	msnyder-reverse-20060502-branch:1.22.0.12
	msnyder-reverse-20060502-branchpoint:1.22
	gdb-csl-morpho-4_1-4:1.22
	gdb-csl-sourcerygxx-3_4_4-17:1.22
	readline_5_1-import-branch:1.22.0.10
	readline_5_1-import-branchpoint:1.22
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.22
	gdb-csl-symbian-20060226-branch:1.22.0.8
	gdb-csl-symbian-20060226-branchpoint:1.22
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.22
	msnyder-reverse-20060331-branch:1.22.0.6
	msnyder-reverse-20060331-branchpoint:1.22
	gdb-csl-available-20060303-branch:1.22.0.4
	gdb-csl-available-20060303-branchpoint:1.22
	gdb-csl-20060226-branch:1.22.0.2
	gdb-csl-20060226-branchpoint:1.22
	gdb_6_4-20051202-release:1.21
	msnyder-fork-checkpoint-branch:1.21.0.6
	msnyder-fork-checkpoint-branchpoint:1.21
	gdb-csl-gxxpro-6_3-branch:1.21.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.21
	gdb_6_4-branch:1.21.0.2
	gdb_6_4-2005-11-01-branchpoint:1.21
	gdb-csl-arm-20051020-branch:1.20.0.6
	gdb-csl-arm-20051020-branchpoint:1.20
	msnyder-tracepoint-checkpoint-branch:1.20.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.20
	gdb-csl-arm-20050325-2005-q1b:1.20
	gdb-csl-arm-20050325-2005-q1a:1.20
	csl-arm-20050325-branch:1.20.0.2
	csl-arm-20050325-branchpoint:1.20
	gdb-post-i18n-errorwarning-20050211:1.19
	gdb-pre-i18n-errorwarning-20050211:1.18
	gdb_6_3-20041109-release:1.18
	gdb_6_3-branch:1.18.0.8
	gdb_6_3-20041019-branchpoint:1.18
	drow_intercu-merge-20040921:1.18
	drow_intercu-merge-20040915:1.18
	jimb-gdb_6_2-e500-branch:1.18.0.10
	jimb-gdb_6_2-e500-branchpoint:1.18
	gdb_6_2-20040730-release:1.18
	gdb_6_2-branch:1.18.0.6
	gdb_6_2-2004-07-10-gmt-branchpoint:1.18
	gdb_6_1_1-20040616-release:1.17.4.1
	gdb_6_1-2004-04-05-release:1.17.4.1
	drow_intercu-merge-20040402:1.18
	drow_intercu-merge-20040327:1.18
	ezannoni_pie-20040323-branch:1.18.0.4
	ezannoni_pie-20040323-branchpoint:1.18
	ezannoni_pie-20030916-branch:1.18.0.2
	cagney_tramp-20040321-mergepoint:1.18
	cagney_tramp-20040309-branch:1.17.0.6
	cagney_tramp-20040309-branchpoint:1.17
	gdb_6_1-branch:1.17.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.17
	drow_intercu-20040221-branch:1.17.0.2
	drow_intercu-20040221-branchpoint:1.17
	cagney_bfdfile-20040213-branch:1.16.0.2
	cagney_bfdfile-20040213-branchpoint:1.16
	drow-cplus-branch:1.15.0.2
	drow-cplus-merge-20040208:1.13
	carlton_dictionary-branch:1.4.0.2
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.3.0.2
	cagney_bigcore-20040122-branchpoint:1.3;
locks; strict;
comment	@ * @;


1.42
date	2013.01.01.06.41.30;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2012.01.04.08.27.59;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2011.01.07.20.24.18;	author msnyder;	state Exp;
branches
	1.40.4.1;
next	1.39;

1.39
date	2011.01.06.00.57.05;	author msnyder;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.01.15.33.53;	author brobecke;	state Exp;
branches;
next	1.37;

1.37
date	2010.03.20.05.17.10;	author drow;	state Exp;
branches;
next	1.36;

1.36
date	2010.01.01.07.32.07;	author brobecke;	state Exp;
branches;
next	1.35;

1.35
date	2009.07.02.17.17.42;	author uweigand;	state Exp;
branches;
next	1.34;

1.34
date	2009.02.21.16.14.50;	author palves;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.03.05.58.08;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.01.22.53.22;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.23.18.08.50;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2007.08.15.00.19.44;	author msnyder;	state Exp;
branches;
next	1.29;

1.29
date	2007.08.14.23.50.39;	author msnyder;	state Exp;
branches;
next	1.28;

1.28
date	2007.08.14.21.39.22;	author msnyder;	state Exp;
branches;
next	1.27;

1.27
date	2007.08.14.21.20.09;	author msnyder;	state Exp;
branches;
next	1.26;

1.26
date	2007.08.14.20.23.29;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2007.08.08.18.39.50;	author msnyder;	state Exp;
branches;
next	1.24;

1.24
date	2007.01.09.17.59.14;	author drow;	state Exp;
branches;
next	1.23;

1.23
date	2007.01.03.19.01.25;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.23.19.10.02;	author eliz;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.01.17.40.25;	author ams;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.15.15.49.27;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.11.04.06.14;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.13.14.14.01;	author ciceron;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2004.02.16.21.05.09;	author cagney;	state Exp;
branches
	1.17.2.1
	1.17.4.1
	1.17.6.1;
next	1.16;

1.16
date	2004.02.10.19.08.16;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.08.01.32.26;	author cagney;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2004.02.08.00.05.16;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.07.20.57.02;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.07.17.46.14;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.07.16.31.22;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.07.04.40.36;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.07.01.02.54;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.07.00.23.56;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.06.23.55.34;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.06.22.42.18;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.28.23.16.50;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.23.23.25.17;	author cagney;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2004.01.20.21.56.22;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.19.16.06.04;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.19.04.31.50;	author cagney;	state Exp;
branches;
next	;

1.40.4.1
date	2012.01.06.04.54.35;	author brobecke;	state Exp;
branches;
next	;

1.18.2.1
date	2004.03.23.20.09.16;	author ezannoni;	state Exp;
branches;
next	;

1.17.2.1
date	2004.03.27.17.38.05;	author drow;	state Exp;
branches;
next	;

1.17.4.1
date	2004.03.13.14.21.00;	author ciceron;	state Exp;
branches;
next	;

1.17.6.1
date	2004.03.21.23.57.42;	author cagney;	state Exp;
branches;
next	;

1.15.2.1
date	2004.02.09.19.43.56;	author drow;	state Exp;
branches;
next	;

1.4.2.1
date	2004.01.26.19.11.45;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* TUI layout window management.

   Copyright (C) 1998-2013 Free Software Foundation, Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "command.h"
#include "symtab.h"
#include "frame.h"
#include "source.h"
#include <ctype.h>

#include "tui/tui.h"
#include "tui/tui-data.h"
#include "tui/tui-windata.h"
#include "tui/tui-wingeneral.h"
#include "tui/tui-stack.h"
#include "tui/tui-regs.h"
#include "tui/tui-win.h"
#include "tui/tui-winsource.h"
#include "tui/tui-disasm.h"
#include "tui/tui-layout.h"

#include "gdb_string.h"
#include "gdb_curses.h"

/*******************************
** Static Local Decls
********************************/
static void show_layout (enum tui_layout_type);
static void init_gen_win_info (struct tui_gen_win_info *, 
			       enum tui_win_type, 
			       int, int, int, int);
static void *init_and_make_win (void *, enum tui_win_type, 
				int, int, int, int, int);
static void show_source_or_disasm_and_command (enum tui_layout_type);
static void make_source_or_disasm_window (struct tui_win_info **, 
					  enum tui_win_type, 
					  int, int);
static void make_command_window (struct tui_win_info **, int, int);
static void make_source_window (struct tui_win_info **, int, int);
static void make_disasm_window (struct tui_win_info **, int, int);
static void make_data_window (struct tui_win_info **, int, int);
static void show_source_command (void);
static void show_disasm_command (void);
static void show_source_disasm_command (void);
static void show_data (enum tui_layout_type);
static enum tui_layout_type next_layout (void);
static enum tui_layout_type prev_layout (void);
static void tui_layout_command (char *, int);
static void tui_toggle_layout_command (char *, int);
static void tui_toggle_split_layout_command (char *, int);
static void extract_display_start_addr (struct gdbarch **, CORE_ADDR *);
static void tui_handle_xdb_layout (struct tui_layout_def *);


/***************************************
** DEFINITIONS
***************************************/

#define LAYOUT_USAGE     "Usage: layout prev | next | <layout_name> \n"

/* Show the screen layout defined.  */
static void
show_layout (enum tui_layout_type layout)
{
  enum tui_layout_type cur_layout = tui_current_layout ();

  if (layout != cur_layout)
    {
      /* Since the new layout may cause changes in window size, we
         should free the content and reallocate on next display of
         source/asm.  */
      tui_free_all_source_wins_content ();
      tui_clear_source_windows ();
      if (layout == SRC_DATA_COMMAND 
	  || layout == DISASSEM_DATA_COMMAND)
	{
	  show_data (layout);
	  tui_refresh_all (tui_win_list);
	}
      else
	{
	  /* First make the current layout be invisible.  */
	  tui_make_all_invisible ();
	  tui_make_invisible (tui_locator_win_info_ptr ());

	  switch (layout)
	    {
	      /* Now show the new layout.  */
	    case SRC_COMMAND:
	      show_source_command ();
	      tui_add_to_source_windows (TUI_SRC_WIN);
	      break;
	    case DISASSEM_COMMAND:
	      show_disasm_command ();
	      tui_add_to_source_windows (TUI_DISASM_WIN);
	      break;
	    case SRC_DISASSEM_COMMAND:
	      show_source_disasm_command ();
	      tui_add_to_source_windows (TUI_SRC_WIN);
	      tui_add_to_source_windows (TUI_DISASM_WIN);
	      break;
	    default:
	      break;
	    }
	}
    }
}


/* Function to set the layout to SRC_COMMAND, DISASSEM_COMMAND,
   SRC_DISASSEM_COMMAND, SRC_DATA_COMMAND, or DISASSEM_DATA_COMMAND.
   If the layout is SRC_DATA_COMMAND, DISASSEM_DATA_COMMAND, or
   UNDEFINED_LAYOUT, then the data window is populated according to
   regs_display_type.  */
enum tui_status
tui_set_layout (enum tui_layout_type layout_type,
		enum tui_register_display_type regs_display_type)
{
  enum tui_status status = TUI_SUCCESS;

  if (layout_type != UNDEFINED_LAYOUT 
      || regs_display_type != TUI_UNDEFINED_REGS)
    {
      enum tui_layout_type cur_layout = tui_current_layout (),
	new_layout = UNDEFINED_LAYOUT;
      int regs_populate = FALSE;
      struct gdbarch *gdbarch;
      CORE_ADDR addr;
      struct tui_win_info *win_with_focus = tui_win_with_focus ();
      struct tui_layout_def *layout_def = tui_layout_def ();

      extract_display_start_addr (&gdbarch, &addr);

      if (layout_type == UNDEFINED_LAYOUT
	  && regs_display_type != TUI_UNDEFINED_REGS)
	{
	  if (cur_layout == SRC_DISASSEM_COMMAND)
	    new_layout = DISASSEM_DATA_COMMAND;
	  else if (cur_layout == SRC_COMMAND 
		   || cur_layout == SRC_DATA_COMMAND)
	    new_layout = SRC_DATA_COMMAND;
	  else if (cur_layout == DISASSEM_COMMAND 
		   || cur_layout == DISASSEM_DATA_COMMAND)
	    new_layout = DISASSEM_DATA_COMMAND;
	}
      else
	new_layout = layout_type;

      regs_populate = (new_layout == SRC_DATA_COMMAND 
		       || new_layout == DISASSEM_DATA_COMMAND 
		       || regs_display_type != TUI_UNDEFINED_REGS);
      if (new_layout != cur_layout
	  || regs_display_type != TUI_UNDEFINED_REGS)
	{
	  if (new_layout != cur_layout)
	    {
	      show_layout (new_layout);

	      /* Now determine where focus should be.  */
	      if (win_with_focus != TUI_CMD_WIN)
		{
		  switch (new_layout)
		    {
		    case SRC_COMMAND:
		      tui_set_win_focus_to (TUI_SRC_WIN);
		      layout_def->display_mode = SRC_WIN;
		      layout_def->split = FALSE;
		      break;
		    case DISASSEM_COMMAND:
		      /* The previous layout was not showing code.
		         This can happen if there is no source
		         available:

		         1. if the source file is in another dir OR
		         2. if target was compiled without -g
		         We still want to show the assembly though!  */

		      tui_get_begin_asm_address (&gdbarch, &addr);
		      tui_set_win_focus_to (TUI_DISASM_WIN);
		      layout_def->display_mode = DISASSEM_WIN;
		      layout_def->split = FALSE;
		      break;
		    case SRC_DISASSEM_COMMAND:
		      /* The previous layout was not showing code.
		         This can happen if there is no source
		         available:

		         1. if the source file is in another dir OR
		         2. if target was compiled without -g
		         We still want to show the assembly though!  */

		      tui_get_begin_asm_address (&gdbarch, &addr);
		      if (win_with_focus == TUI_SRC_WIN)
			tui_set_win_focus_to (TUI_SRC_WIN);
		      else
			tui_set_win_focus_to (TUI_DISASM_WIN);
		      layout_def->split = TRUE;
		      break;
		    case SRC_DATA_COMMAND:
		      if (win_with_focus != TUI_DATA_WIN)
			tui_set_win_focus_to (TUI_SRC_WIN);
		      else
			tui_set_win_focus_to (TUI_DATA_WIN);
		      layout_def->display_mode = SRC_WIN;
		      layout_def->split = FALSE;
		      break;
		    case DISASSEM_DATA_COMMAND:
		      /* The previous layout was not showing code.
		         This can happen if there is no source
		         available:

			 1. if the source file is in another dir OR
		         2. if target was compiled without -g
		         We still want to show the assembly though!  */

		      tui_get_begin_asm_address (&gdbarch, &addr);
		      if (win_with_focus != TUI_DATA_WIN)
			tui_set_win_focus_to (TUI_DISASM_WIN);
		      else
			tui_set_win_focus_to (TUI_DATA_WIN);
		      layout_def->display_mode = DISASSEM_WIN;
		      layout_def->split = FALSE;
		      break;
		    default:
		      break;
		    }
		}
	      /*
	       * Now update the window content.
	       */
	      if (!regs_populate 
		  && (new_layout == SRC_DATA_COMMAND 
		      || new_layout == DISASSEM_DATA_COMMAND))
		tui_display_all_data ();

	      tui_update_source_windows_with_addr (gdbarch, addr);
	    }
	  if (regs_populate)
	    {
              tui_show_registers (TUI_DATA_WIN->detail.data_display_info.current_group);
	    }
	}
    }
  else
    status = TUI_FAILURE;

  return status;
}

/* Add the specified window to the layout in a logical way.  This
   means setting up the most logical layout given the window to be
   added.  */
void
tui_add_win_to_layout (enum tui_win_type type)
{
  enum tui_layout_type cur_layout = tui_current_layout ();

  switch (type)
    {
    case SRC_WIN:
      if (cur_layout != SRC_COMMAND
	  && cur_layout != SRC_DISASSEM_COMMAND
	  && cur_layout != SRC_DATA_COMMAND)
	{
	  tui_clear_source_windows_detail ();
	  if (cur_layout == DISASSEM_DATA_COMMAND)
	    show_layout (SRC_DATA_COMMAND);
	  else
	    show_layout (SRC_COMMAND);
	}
      break;
    case DISASSEM_WIN:
      if (cur_layout != DISASSEM_COMMAND
	  && cur_layout != SRC_DISASSEM_COMMAND
	  && cur_layout != DISASSEM_DATA_COMMAND)
	{
	  tui_clear_source_windows_detail ();
	  if (cur_layout == SRC_DATA_COMMAND)
	    show_layout (DISASSEM_DATA_COMMAND);
	  else
	    show_layout (DISASSEM_COMMAND);
	}
      break;
    case DATA_WIN:
      if (cur_layout != SRC_DATA_COMMAND
	  && cur_layout != DISASSEM_DATA_COMMAND)
	{
	  if (cur_layout == DISASSEM_COMMAND)
	    show_layout (DISASSEM_DATA_COMMAND);
	  else
	    show_layout (SRC_DATA_COMMAND);
	}
      break;
    default:
      break;
    }
}


/* Answer the height of a window.  If it hasn't been created yet,
   answer what the height of a window would be based upon its type and
   the layout.  */
int
tui_default_win_height (enum tui_win_type type, 
			enum tui_layout_type layout)
{
  int h;

  if (tui_win_list[type] != (struct tui_win_info *) NULL)
    h = tui_win_list[type]->generic.height;
  else
    {
      switch (layout)
	{
	case SRC_COMMAND:
	case DISASSEM_COMMAND:
	  if (TUI_CMD_WIN == NULL)
	    h = tui_term_height () / 2;
	  else
	    h = tui_term_height () - TUI_CMD_WIN->generic.height;
	  break;
	case SRC_DISASSEM_COMMAND:
	case SRC_DATA_COMMAND:
	case DISASSEM_DATA_COMMAND:
	  if (TUI_CMD_WIN == NULL)
	    h = tui_term_height () / 3;
	  else
	    h = (tui_term_height () - TUI_CMD_WIN->generic.height) / 2;
	  break;
	default:
	  h = 0;
	  break;
	}
    }

  return h;
}


/* Answer the height of a window.  If it hasn't been created yet,
   answer what the height of a window would be based upon its type and
   the layout.  */
int
tui_default_win_viewport_height (enum tui_win_type type,
				 enum tui_layout_type layout)
{
  int h;

  h = tui_default_win_height (type, layout);

  if (tui_win_list[type] == TUI_CMD_WIN)
    h -= 1;
  else
    h -= 2;

  return h;
}


/* Function to initialize gdb commands, for tui window layout
   manipulation.  */

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_tui_layout;

void
_initialize_tui_layout (void)
{
  add_com ("layout", class_tui, tui_layout_command, _("\
Change the layout of windows.\n\
Usage: layout prev | next | <layout_name> \n\
Layout names are:\n\
   src   : Displays source and command windows.\n\
   asm   : Displays disassembly and command windows.\n\
   split : Displays source, disassembly and command windows.\n\
   regs  : Displays register window. If existing layout\n\
           is source/command or assembly/command, the \n\
           register window is displayed. If the\n\
           source/assembly/command (split) is displayed, \n\
           the register window is displayed with \n\
           the window that has current logical focus.\n"));
  if (xdb_commands)
    {
      add_com ("td", class_tui, tui_toggle_layout_command, _("\
Toggle between Source/Command and Disassembly/Command layouts.\n"));
      add_com ("ts", class_tui, tui_toggle_split_layout_command, _("\
Toggle between Source/Command or Disassembly/Command and \n\
Source/Disassembly/Command layouts.\n"));
    }
}


/*************************
** STATIC LOCAL FUNCTIONS
**************************/


/* Function to set the layout to SRC, ASM, SPLIT, NEXT, PREV, DATA,
   REGS, $REGS, $GREGS, $FREGS, $SREGS.  */
enum tui_status
tui_set_layout_for_display_command (const char *layout_name)
{
  enum tui_status status = TUI_SUCCESS;

  if (layout_name != (char *) NULL)
    {
      int i;
      char *buf_ptr;
      enum tui_layout_type new_layout = UNDEFINED_LAYOUT;
      enum tui_register_display_type dpy_type = TUI_UNDEFINED_REGS;
      enum tui_layout_type cur_layout = tui_current_layout ();

      buf_ptr = (char *) xstrdup (layout_name);
      for (i = 0; (i < strlen (layout_name)); i++)
	buf_ptr[i] = toupper (buf_ptr[i]);

      /* First check for ambiguous input.  */
      if (strlen (buf_ptr) <= 1 
	  && (*buf_ptr == 'S' || *buf_ptr == '$'))
	{
	  warning (_("Ambiguous command input."));
	  status = TUI_FAILURE;
	}
      else
	{
	  if (subset_compare (buf_ptr, "SRC"))
	    new_layout = SRC_COMMAND;
	  else if (subset_compare (buf_ptr, "ASM"))
	    new_layout = DISASSEM_COMMAND;
	  else if (subset_compare (buf_ptr, "SPLIT"))
	    new_layout = SRC_DISASSEM_COMMAND;
	  else if (subset_compare (buf_ptr, "REGS") 
		   || subset_compare (buf_ptr, TUI_GENERAL_SPECIAL_REGS_NAME)
		   || subset_compare (buf_ptr, TUI_GENERAL_REGS_NAME)
		   || subset_compare (buf_ptr, TUI_FLOAT_REGS_NAME)
		   || subset_compare (buf_ptr, TUI_SPECIAL_REGS_NAME))
	    {
	      if (cur_layout == SRC_COMMAND 
		  || cur_layout == SRC_DATA_COMMAND)
		new_layout = SRC_DATA_COMMAND;
	      else
		new_layout = DISASSEM_DATA_COMMAND;

	      /* Could ifdef out the following code. when compile with
		 -z, there are null pointer references that cause a
		 core dump if 'layout regs' is the first layout
		 command issued by the user. HP has asked us to hook
		 up this code.  - edie epstein  */
	      if (subset_compare (buf_ptr, TUI_FLOAT_REGS_NAME))
		{
		  if (TUI_DATA_WIN->detail.data_display_info.regs_display_type
		      != TUI_SFLOAT_REGS
		      && TUI_DATA_WIN->detail.data_display_info.regs_display_type
		      != TUI_DFLOAT_REGS)
		    dpy_type = TUI_SFLOAT_REGS;
		  else
		    dpy_type =
		      TUI_DATA_WIN->detail.data_display_info.regs_display_type;
		}
	      else if (subset_compare (buf_ptr,
				      TUI_GENERAL_SPECIAL_REGS_NAME))
		dpy_type = TUI_GENERAL_AND_SPECIAL_REGS;
	      else if (subset_compare (buf_ptr, TUI_GENERAL_REGS_NAME))
		dpy_type = TUI_GENERAL_REGS;
	      else if (subset_compare (buf_ptr, TUI_SPECIAL_REGS_NAME))
		dpy_type = TUI_SPECIAL_REGS;
	      else if (TUI_DATA_WIN)
		{
		  if (TUI_DATA_WIN->detail.data_display_info.regs_display_type
		      != TUI_UNDEFINED_REGS)
		    dpy_type
		      = TUI_DATA_WIN->detail.data_display_info.regs_display_type;
		  else
		    dpy_type = TUI_GENERAL_REGS;
		}

	      /* End of potential ifdef.
	       */

	      /* If ifdefed out code above, then assume that the user
		 wishes to display the general purpose registers .
	      */

	      /* dpy_type = TUI_GENERAL_REGS; */
	    }
	  else if (subset_compare (buf_ptr, "NEXT"))
	    new_layout = next_layout ();
	  else if (subset_compare (buf_ptr, "PREV"))
	    new_layout = prev_layout ();
	  else
	    status = TUI_FAILURE;

	  tui_set_layout (new_layout, dpy_type);
	}
      xfree (buf_ptr);
    }
  else
    status = TUI_FAILURE;

  return status;
}


static void
extract_display_start_addr (struct gdbarch **gdbarch_p, CORE_ADDR *addr_p)
{
  enum tui_layout_type cur_layout = tui_current_layout ();
  struct gdbarch *gdbarch = get_current_arch ();
  CORE_ADDR addr;
  CORE_ADDR pc;
  struct symtab_and_line cursal = get_current_source_symtab_and_line ();

  switch (cur_layout)
    {
    case SRC_COMMAND:
    case SRC_DATA_COMMAND:
      gdbarch = TUI_SRC_WIN->detail.source_info.gdbarch;
      find_line_pc (cursal.symtab,
		    TUI_SRC_WIN->detail.source_info.start_line_or_addr.u.line_no,
		    &pc);
      addr = pc;
      break;
    case DISASSEM_COMMAND:
    case SRC_DISASSEM_COMMAND:
    case DISASSEM_DATA_COMMAND:
      gdbarch = TUI_DISASM_WIN->detail.source_info.gdbarch;
      addr = TUI_DISASM_WIN->detail.source_info.start_line_or_addr.u.addr;
      break;
    default:
      addr = 0;
      break;
    }

  *gdbarch_p = gdbarch;
  *addr_p = addr;
}


static void
tui_handle_xdb_layout (struct tui_layout_def *layout_def)
{
  if (layout_def->split)
    {
      tui_set_layout (SRC_DISASSEM_COMMAND, TUI_UNDEFINED_REGS);
      tui_set_win_focus_to (tui_win_list[layout_def->display_mode]);
    }
  else
    {
      if (layout_def->display_mode == SRC_WIN)
	tui_set_layout (SRC_COMMAND, TUI_UNDEFINED_REGS);
      else
	tui_set_layout (DISASSEM_DATA_COMMAND, layout_def->regs_display_type);
    }
}


static void
tui_toggle_layout_command (char *arg, int from_tty)
{
  struct tui_layout_def *layout_def = tui_layout_def ();

  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  if (layout_def->display_mode == SRC_WIN)
    layout_def->display_mode = DISASSEM_WIN;
  else
    layout_def->display_mode = SRC_WIN;

  if (!layout_def->split)
    tui_handle_xdb_layout (layout_def);
}


static void
tui_toggle_split_layout_command (char *arg, int from_tty)
{
  struct tui_layout_def *layout_def = tui_layout_def ();

  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  layout_def->split = (!layout_def->split);
  tui_handle_xdb_layout (layout_def);
}


static void
tui_layout_command (char *arg, int from_tty)
{
  /* Make sure the curses mode is enabled.  */
  tui_enable ();

  /* Switch to the selected layout.  */
  if (tui_set_layout_for_display_command (arg) != TUI_SUCCESS)
    warning (_("Invalid layout specified.\n%s"), LAYOUT_USAGE);

}

/* Answer the previous layout to cycle to.  */
static enum tui_layout_type
next_layout (void)
{
  enum tui_layout_type new_layout;

  new_layout = tui_current_layout ();
  if (new_layout == UNDEFINED_LAYOUT)
    new_layout = SRC_COMMAND;
  else
    {
      new_layout++;
      if (new_layout == UNDEFINED_LAYOUT)
	new_layout = SRC_COMMAND;
    }

  return new_layout;
}


/* Answer the next layout to cycle to.  */
static enum tui_layout_type
prev_layout (void)
{
  enum tui_layout_type new_layout;

  new_layout = tui_current_layout ();
  if (new_layout == SRC_COMMAND)
    new_layout = DISASSEM_DATA_COMMAND;
  else
    {
      new_layout--;
      if (new_layout == UNDEFINED_LAYOUT)
	new_layout = DISASSEM_DATA_COMMAND;
    }

  return new_layout;
}



static void
make_command_window (struct tui_win_info **win_info_ptr, 
		     int height, int origin_y)
{
  *win_info_ptr = init_and_make_win (*win_info_ptr,
				     CMD_WIN,
				     height,
				     tui_term_width (),
				     0,
				     origin_y,
				     DONT_BOX_WINDOW);

  (*win_info_ptr)->can_highlight = FALSE;
}


/* make_source_window().
 */
static void
make_source_window (struct tui_win_info **win_info_ptr, 
		    int height, int origin_y)
{
  make_source_or_disasm_window (win_info_ptr, SRC_WIN, height, origin_y);

  return;
}				/* make_source_window */


/* make_disasm_window().
 */
static void
make_disasm_window (struct tui_win_info **win_info_ptr, 
		    int height, int origin_y)
{
  make_source_or_disasm_window (win_info_ptr, DISASSEM_WIN, height, origin_y);

  return;
}				/* make_disasm_window */


static void
make_data_window (struct tui_win_info **win_info_ptr, 
		  int height, int origin_y)
{
  *win_info_ptr = init_and_make_win (*win_info_ptr,
				     DATA_WIN,
				     height,
				     tui_term_width (),
				     0,
				     origin_y,
				     BOX_WINDOW);
}



/* Show the Source/Command layout.  */
static void
show_source_command (void)
{
  show_source_or_disasm_and_command (SRC_COMMAND);
}


/* Show the Dissassem/Command layout.  */
static void
show_disasm_command (void)
{
  show_source_or_disasm_and_command (DISASSEM_COMMAND);
}


/* Show the Source/Disassem/Command layout.  */
static void
show_source_disasm_command (void)
{
  if (tui_current_layout () != SRC_DISASSEM_COMMAND)
    {
      int cmd_height, src_height, asm_height;

      if (TUI_CMD_WIN != NULL)
	cmd_height = TUI_CMD_WIN->generic.height;
      else
	cmd_height = tui_term_height () / 3;

      src_height = (tui_term_height () - cmd_height) / 2;
      asm_height = tui_term_height () - (src_height + cmd_height);

      if (TUI_SRC_WIN == NULL)
	make_source_window (&TUI_SRC_WIN, src_height, 0);
      else
	{
	  init_gen_win_info (&TUI_SRC_WIN->generic,
			     TUI_SRC_WIN->generic.type,
			     src_height,
			     TUI_SRC_WIN->generic.width,
			     TUI_SRC_WIN->detail.source_info.execution_info->width,
			     0);
	  TUI_SRC_WIN->can_highlight = TRUE;
	  init_gen_win_info (TUI_SRC_WIN->detail.source_info.execution_info,
			     EXEC_INFO_WIN,
			     src_height,
			     3,
			     0,
			     0);
	  tui_make_visible (&TUI_SRC_WIN->generic);
	  tui_make_visible (TUI_SRC_WIN->detail.source_info.execution_info);
	  TUI_SRC_WIN->detail.source_info.has_locator = FALSE;;
	}
      if (TUI_SRC_WIN != NULL)
	{
	  struct tui_gen_win_info *locator = tui_locator_win_info_ptr ();

	  tui_show_source_content (TUI_SRC_WIN);
	  if (TUI_DISASM_WIN == NULL)
	    {
	      make_disasm_window (&TUI_DISASM_WIN, asm_height, src_height - 1);
	      locator = init_and_make_win (locator,
					   LOCATOR_WIN,
					   2 /* 1 */ ,
					   tui_term_width (),
					   0,
					   (src_height + asm_height) - 1,
					   DONT_BOX_WINDOW);
	    }
	  else
	    {
	      init_gen_win_info (locator,
				 LOCATOR_WIN,
				 2 /* 1 */ ,
				 tui_term_width (),
				 0,
				 (src_height + asm_height) - 1);
	      TUI_DISASM_WIN->detail.source_info.has_locator = TRUE;
	      init_gen_win_info (&TUI_DISASM_WIN->generic,
				 TUI_DISASM_WIN->generic.type,
				 asm_height,
				 TUI_DISASM_WIN->generic.width,
				 TUI_DISASM_WIN->detail.source_info.execution_info->width,
				 src_height - 1);
	      init_gen_win_info (TUI_DISASM_WIN->detail.source_info.execution_info,
				 EXEC_INFO_WIN,
				 asm_height,
				 3,
				 0,
				 src_height - 1);
	      TUI_DISASM_WIN->can_highlight = TRUE;
	      tui_make_visible (&TUI_DISASM_WIN->generic);
	      tui_make_visible (TUI_DISASM_WIN->detail.source_info.execution_info);
	    }
	  if (TUI_DISASM_WIN != NULL)
	    {
	      TUI_SRC_WIN->detail.source_info.has_locator = FALSE;
	      TUI_DISASM_WIN->detail.source_info.has_locator = TRUE;
	      tui_make_visible (locator);
	      tui_show_locator_content ();
	      tui_show_source_content (TUI_DISASM_WIN);

	      if (TUI_CMD_WIN == NULL)
		make_command_window (&TUI_CMD_WIN,
				     cmd_height,
				     tui_term_height () - cmd_height);
	      else
		{
		  init_gen_win_info (&TUI_CMD_WIN->generic,
				     TUI_CMD_WIN->generic.type,
				     TUI_CMD_WIN->generic.height,
				     TUI_CMD_WIN->generic.width,
				     0,
				     TUI_CMD_WIN->generic.origin.y);
		  TUI_CMD_WIN->can_highlight = FALSE;
		  tui_make_visible (&TUI_CMD_WIN->generic);
		}
	      if (TUI_CMD_WIN != NULL)
		tui_refresh_win (&TUI_CMD_WIN->generic);
	    }
	}
      tui_set_current_layout_to (SRC_DISASSEM_COMMAND);
    }
}


/* Show the Source/Data/Command or the Dissassembly/Data/Command
   layout.  */
static void
show_data (enum tui_layout_type new_layout)
{
  int total_height = (tui_term_height () - TUI_CMD_WIN->generic.height);
  int src_height, data_height;
  enum tui_win_type win_type;
  struct tui_gen_win_info *locator = tui_locator_win_info_ptr ();


  data_height = total_height / 2;
  src_height = total_height - data_height;
  tui_make_all_invisible ();
  tui_make_invisible (locator);
  make_data_window (&TUI_DATA_WIN, data_height, 0);
  TUI_DATA_WIN->can_highlight = TRUE;
  if (new_layout == SRC_DATA_COMMAND)
    win_type = SRC_WIN;
  else
    win_type = DISASSEM_WIN;
  if (tui_win_list[win_type] == NULL)
    {
      if (win_type == SRC_WIN)
	make_source_window (&tui_win_list[win_type], src_height, data_height - 1);
      else
	make_disasm_window (&tui_win_list[win_type], src_height, data_height - 1);
      locator = init_and_make_win (locator,
				   LOCATOR_WIN,
				   2 /* 1 */ ,
				   tui_term_width (),
				   0,
				   total_height - 1,
				   DONT_BOX_WINDOW);
    }
  else
    {
      init_gen_win_info (&tui_win_list[win_type]->generic,
			 tui_win_list[win_type]->generic.type,
			 src_height,
			 tui_win_list[win_type]->generic.width,
			 tui_win_list[win_type]->detail.source_info.execution_info->width,
			 data_height - 1);
      init_gen_win_info (tui_win_list[win_type]->detail.source_info.execution_info,
			 EXEC_INFO_WIN,
			 src_height,
			 3,
			 0,
			 data_height - 1);
      tui_make_visible (&tui_win_list[win_type]->generic);
      tui_make_visible (tui_win_list[win_type]->detail.source_info.execution_info);
      init_gen_win_info (locator,
			 LOCATOR_WIN,
			 2 /* 1 */ ,
			 tui_term_width (),
			 0,
			 total_height - 1);
    }
  tui_win_list[win_type]->detail.source_info.has_locator = TRUE;
  tui_make_visible (locator);
  tui_show_locator_content ();
  tui_add_to_source_windows (tui_win_list[win_type]);
  tui_set_current_layout_to (new_layout);
}

/* init_gen_win_info().
 */
static void
init_gen_win_info (struct tui_gen_win_info *win_info, 
		   enum tui_win_type type,
		   int height, int width, 
		   int origin_x, int origin_y)
{
  int h = height;

  win_info->type = type;
  win_info->width = width;
  win_info->height = h;
  if (h > 1)
    {
      win_info->viewport_height = h - 1;
      if (win_info->type != CMD_WIN)
	win_info->viewport_height--;
    }
  else
    win_info->viewport_height = 1;
  win_info->origin.x = origin_x;
  win_info->origin.y = origin_y;

  return;
}				/* init_gen_win_info */

/* init_and_make_win().
 */
static void *
init_and_make_win (void *opaque_win_info, 
		   enum tui_win_type win_type,
		   int height, int width, 
		   int origin_x, int origin_y,
		   int box_it)
{
  struct tui_gen_win_info *generic;

  if (opaque_win_info == NULL)
    {
      if (tui_win_is_auxillary (win_type))
	opaque_win_info = (void *) tui_alloc_generic_win_info ();
      else
	opaque_win_info = (void *) tui_alloc_win_info (win_type);
    }
  if (tui_win_is_auxillary (win_type))
    generic = (struct tui_gen_win_info *) opaque_win_info;
  else
    generic = &((struct tui_win_info *) opaque_win_info)->generic;

  if (opaque_win_info != NULL)
    {
      init_gen_win_info (generic, win_type, height, width, origin_x, origin_y);
      if (!tui_win_is_auxillary (win_type))
	{
	  if (generic->type == CMD_WIN)
	    ((struct tui_win_info *) opaque_win_info)->can_highlight = FALSE;
	  else
	    ((struct tui_win_info *) opaque_win_info)->can_highlight = TRUE;
	}
      tui_make_window (generic, box_it);
    }
  return opaque_win_info;
}


static void
make_source_or_disasm_window (struct tui_win_info **win_info_ptr, 
			      enum tui_win_type type,
			      int height, int origin_y)
{
  struct tui_gen_win_info *execution_info = (struct tui_gen_win_info *) NULL;

  /* Create the exeuction info window.  */
  if (type == SRC_WIN)
    execution_info = tui_source_exec_info_win_ptr ();
  else
    execution_info = tui_disassem_exec_info_win_ptr ();
  execution_info = init_and_make_win (execution_info,
				      EXEC_INFO_WIN,
				      height,
				      3,
				      0,
				      origin_y,
				      DONT_BOX_WINDOW);

  /* Now create the source window.  */
  *win_info_ptr = init_and_make_win (*win_info_ptr,
				     type,
				     height,
				     tui_term_width () - execution_info->width,
				     execution_info->width,
				     origin_y,
				     BOX_WINDOW);

  (*win_info_ptr)->detail.source_info.execution_info = execution_info;
}


/* Show the Source/Command or the Disassem layout.  */
static void
show_source_or_disasm_and_command (enum tui_layout_type layout_type)
{
  if (tui_current_layout () != layout_type)
    {
      struct tui_win_info **win_info_ptr;
      int src_height, cmd_height;
      struct tui_gen_win_info *locator = tui_locator_win_info_ptr ();

      if (TUI_CMD_WIN != NULL)
	cmd_height = TUI_CMD_WIN->generic.height;
      else
	cmd_height = tui_term_height () / 3;
      src_height = tui_term_height () - cmd_height;

      if (layout_type == SRC_COMMAND)
	win_info_ptr = &TUI_SRC_WIN;
      else
	win_info_ptr = &TUI_DISASM_WIN;

      if ((*win_info_ptr) == NULL)
	{
	  if (layout_type == SRC_COMMAND)
	    make_source_window (win_info_ptr, src_height - 1, 0);
	  else
	    make_disasm_window (win_info_ptr, src_height - 1, 0);
	  locator = init_and_make_win (locator,
				       LOCATOR_WIN,
				       2 /* 1 */ ,
				       tui_term_width (),
				       0,
				       src_height - 1,
				       DONT_BOX_WINDOW);
	}
      else
	{
	  init_gen_win_info (locator,
			     LOCATOR_WIN,
			     2 /* 1 */ ,
			     tui_term_width (),
			     0,
			     src_height - 1);
	  (*win_info_ptr)->detail.source_info.has_locator = TRUE;
	  init_gen_win_info (&(*win_info_ptr)->generic,
			     (*win_info_ptr)->generic.type,
			     src_height - 1,
			     (*win_info_ptr)->generic.width,
			     (*win_info_ptr)->detail.source_info.execution_info->width,
			     0);
	  init_gen_win_info ((*win_info_ptr)->detail.source_info.execution_info,
			     EXEC_INFO_WIN,
			     src_height - 1,
			     3,
			     0,
			     0);
	  (*win_info_ptr)->can_highlight = TRUE;
	  tui_make_visible (&(*win_info_ptr)->generic);
	  tui_make_visible ((*win_info_ptr)->detail.source_info.execution_info);
	}
      if ((*win_info_ptr) != NULL)
	{
	  (*win_info_ptr)->detail.source_info.has_locator = TRUE;
	  tui_make_visible (locator);
	  tui_show_locator_content ();
	  tui_show_source_content (*win_info_ptr);

	  if (TUI_CMD_WIN == NULL)
	    {
	      make_command_window (&TUI_CMD_WIN, cmd_height, src_height);
	      tui_refresh_win (&TUI_CMD_WIN->generic);
	    }
	  else
	    {
	      init_gen_win_info (&TUI_CMD_WIN->generic,
				 TUI_CMD_WIN->generic.type,
				 TUI_CMD_WIN->generic.height,
				 TUI_CMD_WIN->generic.width,
				 TUI_CMD_WIN->generic.origin.x,
				 TUI_CMD_WIN->generic.origin.y);
	      TUI_CMD_WIN->can_highlight = FALSE;
	      tui_make_visible (&TUI_CMD_WIN->generic);
	    }
	}
      tui_set_current_layout_to (layout_type);
    }
}
@


1.41
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright (C) 1998-2004, 2007-2012 Free Software Foundation, Inc.
@


1.40
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Mark up error message
	for i18n.
	* tui/tui-layout.c (tui_set_layout_for_display_command):
	Split line so that operator goes to beginning of line.
	* tui/tui-winsource.c (tui_horizontal_source_scroll): Move
	assignment out of if statement.
@
text
@d3 1
a3 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009,
   2010, 2011 Free Software Foundation, Inc.
@


1.40.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 1998-2004, 2007-2012 Free Software Foundation, Inc.
@


1.39
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* cli/cli-cmds.c: Shorten lines of >= 80 columns.
	* cli/cli-decode.c: Ditto.
	* cli/cli-dump.c: Ditto.
	* cli/cli-logging.c: Ditto.
	* cli/cli-script.c: Ditto.
	* cli/cli-setshow.c: Ditto.
	* common/signals.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-disas.c: Ditto.
	* mi/mi-cmd-stack.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-cmds.c: Ditto.
	* mi/mi-common.h: Ditto.
	* mi/mi-console.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
	* osf-share/cma_attr.c: Ditto.
	* osf-share/cma_deb_core.h: Ditto.
	* osf-share/cma_debug_client.h: Ditto.
	* osf-share/cma_handle.h: Ditto.
	* osf-share/cma_mutex.h: Ditto.
	* osf-share/cma_stack_int.h: Ditto.
	* osf-share/cma_tcb_defs.h: Ditto.
	* python/py-auto-load.c: Ditto.
	* python/py-breakpoint.c: Ditto.
	* python/py-cmd.c: Ditto.
	* python/py-frame.c: Ditto.
	* python/py-objfile.c: Ditto.
	* python/py-param.c: Ditto.
	* python/py-progspace.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-value.c: Ditto.
	* python/python-internal.h: Ditto.
	* python/python.c: Ditto.
	* tui/tui-data.c: Ditto.
	* tui/tui-disasm.c: Ditto.
	* tui/tui-hooks.c: Ditto.
	* tui/tui-io.c: Ditto.
	* tui/tui-layout.c: Ditto.
	* tui/tui-regs.c: Ditto.
	* tui/tui-source.c: Ditto.
	* tui/tui-stack.c: Ditto.
	* tui/tui-win.c: Ditto.
	* tui/tui-windata.c: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d491 2
a492 2
		    dpy_type =
		      TUI_DATA_WIN->detail.data_display_info.regs_display_type;
@


1.38
log
@run copyright.sh for 2011.
@
text
@d471 4
a474 2
		  if (TUI_DATA_WIN->detail.data_display_info.regs_display_type != TUI_SFLOAT_REGS
		      && TUI_DATA_WIN->detail.data_display_info.regs_display_type != TUI_DFLOAT_REGS)
d489 2
a490 2
		  if (TUI_DATA_WIN->detail.data_display_info.regs_display_type !=
		      TUI_UNDEFINED_REGS)
@


1.37
log
@	* tui/tui-disasm.c (tui_get_begin_asm_address): Default to
	get_current_arch.
	* tui/tui-layout.c (extract_display_start_addr): Likewise.
@
text
@d4 1
a4 1
   2010 Free Software Foundation, Inc.
@


1.36
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d24 1
d526 1
a526 1
  struct gdbarch *gdbarch = NULL;
@


1.35
log
@	* disasm.h (gdb_disassembly): Add GDBARCH parameter.
	(gdb_print_insn): Likewise.
	* disasm.c (dump_insns): Add GDBARCH parameter.  Use it instead
	of current_gdbarch.
	(do_mixed_source_and_assembly): Add GDBARCH parameter.  Pass to
	dump_insns.
	(do_assembly_only): Likewise.
	(gdb_disassembly): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.  Pass to subroutines.
	(gdb_print_insn): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.

	* stack.c (struct gdb_disassembly_stub_args): Add GDBARCH member.
	(gdb_disassembly_stub): Pass architecture to gdb_disassembly.
	(do_gdb_disassembly): Add GDBARCH argument.  Store into args.
	(print_frame_info): Pass architecture to do_gdb_disassembly.

	* printcmd.c (print_formatted): Pass architecture to gdb_print_insn.

	* mi/mi-cmd-disas.c: Include "arch-utils.h"
	(mi_cmd_disassemble): Pass architecture to gdb_disassembly.

	* cli/cli-cmds.c: Include "arch-utils.h".
	(print_disassembly): Add GDBARCH parameter.  Pass to gdb_disassembly
	and tui_show_assembly.
	(disassemble_current_function): Pass architecture to
	tui_get_low_disassembly_address and print_disassembly.
	(disassemble_command): Pass architecture to
	tui_get_low_disassembly_address and print_disassembly.

	* tui/tui.c (tui_show_assembly): Add GDBARCH parameter.  Pass to
	tui_update_source_windows_with_addr.

	* tui/tui-data.h (struct tui_locator_element): Add GDBARCH member.
	(struct tui_source_info): Likewise.
	* tui/tui-data.c (tui_clear_win_detail): Clear source_info.gdbarch.

	* tui/tui-disasm.c (tui_disassemble): Add GDBARCH parameter.
	Pass to gdb_print_insn.
	(tui_find_disassembly_address): Add GDBARCH parameter.  Pass to
	tui_disassemble.
	(tui_set_disassem_content): Add GDBARCH parameter.  Install into
	source_info.gdbarch.  Pass to tui_disassemble.
	(tui_show_disassem): Add GDBARCH parameter.  Pass to
	tui_update_source_window.
	(tui_show_disassem_and_update_source): Add GDBARCH parameter.  Pass to
	tui_show_disassem and tui_update_source_window.

	(tui_get_begin_asm_address): Return locator architecture in addition
	to locator PC value.

	(tui_get_low_disassembly_address): Add GDBARCH parameter.   Pass to
	tui_get_low_disassembly_address.

	(tui_vertical_disassem_scroll): Pass architecture to subroutines.

	* tui/tui-disasm.h (tui_set_disassem_content): Add GDBARCH parameter.
	(tui_show_disassem): Likewise.
	(tui_show_disassem_and_update_source): Likewise.
	(tui_get_begin_asm_address): Return architecture and PC value.

	* tui/tui.h (tui_get_low_disassembly_address): Add GDBARCH parameter.
	(tui_show_assembly): Add GDBARCH parameter.

	* tui/tui-layout.c (extract_display_start_addr): Return current window
	architecture in addition to current PC value.

	(tui_set_layout): Update calls to tui_get_low_disassembly_address and
	extract_display_start_addr.  Pass architecture to
	tui_update_source_windows_with_addr.

	* tui/tui-source.c: Include "objfiles.h".
	(tui_set_source_content): Initialize window architecture.
	(tui_show_symtab_source): Add GDBARCH parameter.  Pass to
	tui_update_source_window_as_is

	* tui/tui-source.h (tui_show_symtab_source): Add GDBARCH parameter.

	* tui/tui-stack.c (tui_set_locator_info): Add GDBARCH parameter.
	Install locator architecture.
	(tui_set_locator_filename): Update call.
	(tui_show_frame_info): Pass architecture to tui_set_locator_info
	and subroutines.

	* tui/tui-win.c (make_visible_with_new_height): Pass architecture
	to tui_update_source_window.

	* tui/tui-winsource.c: Include "objfiles.h".
	(tui_display_main): Update call to tui_get_begin_asm_address.
	Pass architecture to tui_update_source_windows_with_addr.
	(tui_update_source_window): Add GDBARCH parameter.  Pass to
	tui_update_source_window_as_is.
	(tui_update_source_window_as_is): Add GDBARCH parameter.
	Pass to tui_set_disassem_content.
	(tui_update_source_windows_with_addr): Add GDBARCH parameter.
	Pass to subroutines.
	(tui_update_source_windows_with_line): Pass objfile architecture
	to subroutines.
	(tui_horizontal_source_scroll): Pass architecture to
	tui_update_source_window_as_is.

	* tui/tui-winsource.h (tui_update_source_window): Add GDBARCH
	parameter.
	(tui_update_source_window_as_is): Likewise.
	(tui_update_source_windows_with_addr): Likewise.
@
text
@d3 2
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009
   Free Software Foundation, Inc.
@


1.34
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d70 1
a70 1
static CORE_ADDR extract_display_start_addr (void);
d146 2
a147 1
      CORE_ADDR addr = extract_display_start_addr ();
d151 1
d197 1
a197 1
		      addr = tui_get_begin_asm_address ();
d211 1
a211 1
		      addr = tui_get_begin_asm_address ();
d235 1
a235 1
		      addr = tui_get_begin_asm_address ();
d255 1
a255 1
	      tui_update_source_windows_with_addr (addr);
d521 2
a522 2
static CORE_ADDR
extract_display_start_addr (void)
d525 1
d534 1
d543 1
d551 2
a552 1
  return addr;
@


1.33
log
@        Updated copyright notices for most files.
@
text
@d39 1
d379 4
@


1.32
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008
@


1.31
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007
@


1.30
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-disasm.c, tui-file.c, tui-io.c,
	tui-layout.c, tui-regs.c, tui-source.c, tui-win.c, tui-windata.c,
	tui-wingeneral.c, tui-winsource.c: Coding standard, && and ||
	go at beginning of new line.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.29
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-data.c, tui-data.h, tui-disasm.c, tui-disasm.h, tui-hooks.c,
	tui-io.c, tui-layout.c, tui-layout.h, tui-out.c, tui-regs.c,
	tui-source.c, tui-source.h, tui-stack.c, tui-win.c, tui-win.h,
	tui-windata.c, tui-windata.h, tui-wingeneral.c, tui-winsource.c,
	tui-winsource.h, tui.c, tui.h: Function declarations and
	definitions, wrap long lines.
@
text
@d94 2
a95 1
      if (layout == SRC_DATA_COMMAND || layout == DISASSEM_DATA_COMMAND)
d141 2
a142 1
  if (layout_type != UNDEFINED_LAYOUT || regs_display_type != TUI_UNDEFINED_REGS)
d144 2
a145 1
      enum tui_layout_type cur_layout = tui_current_layout (), new_layout = UNDEFINED_LAYOUT;
d152 2
a153 2
      if (layout_type == UNDEFINED_LAYOUT &&
	  regs_display_type != TUI_UNDEFINED_REGS)
d157 2
a158 1
	  else if (cur_layout == SRC_COMMAND || cur_layout == SRC_DATA_COMMAND)
d160 2
a161 2
	  else if (cur_layout == DISASSEM_COMMAND ||
		   cur_layout == DISASSEM_DATA_COMMAND)
d167 5
a171 4
      regs_populate = (new_layout == SRC_DATA_COMMAND ||
		      new_layout == DISASSEM_DATA_COMMAND ||
		      regs_display_type != TUI_UNDEFINED_REGS);
      if (new_layout != cur_layout || regs_display_type != TUI_UNDEFINED_REGS)
d249 3
a251 3
	      if (!regs_populate &&
		  (new_layout == SRC_DATA_COMMAND ||
		   new_layout == DISASSEM_DATA_COMMAND))
d279 3
a281 3
      if (cur_layout != SRC_COMMAND &&
	  cur_layout != SRC_DISASSEM_COMMAND &&
	  cur_layout != SRC_DATA_COMMAND)
d291 3
a293 3
      if (cur_layout != DISASSEM_COMMAND &&
	  cur_layout != SRC_DISASSEM_COMMAND &&
	  cur_layout != DISASSEM_DATA_COMMAND)
d303 2
a304 2
      if (cur_layout != SRC_DATA_COMMAND &&
	  cur_layout != DISASSEM_DATA_COMMAND)
d432 2
a433 1
      if (strlen (buf_ptr) <= 1 && (*buf_ptr == 'S' || *buf_ptr == '$'))
d446 5
a450 5
	  else if (subset_compare (buf_ptr, "REGS") ||
		   subset_compare (buf_ptr, TUI_GENERAL_SPECIAL_REGS_NAME) ||
		   subset_compare (buf_ptr, TUI_GENERAL_REGS_NAME) ||
		   subset_compare (buf_ptr, TUI_FLOAT_REGS_NAME) ||
		   subset_compare (buf_ptr, TUI_SPECIAL_REGS_NAME))
d452 2
a453 1
	      if (cur_layout == SRC_COMMAND || cur_layout == SRC_DATA_COMMAND)
d465 2
a466 4
		  if (TUI_DATA_WIN->detail.data_display_info.regs_display_type !=
		      TUI_SFLOAT_REGS &&
		      TUI_DATA_WIN->detail.data_display_info.regs_display_type !=
		      TUI_DFLOAT_REGS)
@


1.28
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-disasm.c, tui-layout.c,
	tui-regs.c, tui-win.c, tui-windata.c, tui-winsource.c, tui.c:
	Reformat block comments to GNU standard.
@
text
@d49 5
a53 2
static void init_gen_win_info (struct tui_gen_win_info *, enum tui_win_type, int, int, int, int);
static void *init_and_make_win (void *, enum tui_win_type, int, int, int, int, int);
d55 3
a57 1
static void make_source_or_disasm_window (struct tui_win_info **, enum tui_win_type, int, int);
d317 2
a318 1
tui_default_win_height (enum tui_win_type type, enum tui_layout_type layout)
d643 2
a644 1
make_command_window (struct tui_win_info **win_info_ptr, int height, int origin_y)
d661 2
a662 1
make_source_window (struct tui_win_info **win_info_ptr, int height, int origin_y)
d673 2
a674 1
make_disasm_window (struct tui_win_info **win_info_ptr, int height, int origin_y)
d683 2
a684 1
make_data_window (struct tui_win_info **win_info_ptr, int height, int origin_y)
d734 5
a738 5
			   TUI_SRC_WIN->generic.type,
			   src_height,
			   TUI_SRC_WIN->generic.width,
			   TUI_SRC_WIN->detail.source_info.execution_info->width,
			   0);
d741 5
a745 5
			   EXEC_INFO_WIN,
			   src_height,
			   3,
			   0,
			   0);
d769 5
a773 5
			       LOCATOR_WIN,
			       2 /* 1 */ ,
			       tui_term_width (),
			       0,
			       (src_height + asm_height) - 1);
d775 6
a780 7
	      init_gen_win_info (
				&TUI_DISASM_WIN->generic,
				TUI_DISASM_WIN->generic.type,
				asm_height,
				TUI_DISASM_WIN->generic.width,
			TUI_DISASM_WIN->detail.source_info.execution_info->width,
				src_height - 1);
d782 5
a786 5
			       EXEC_INFO_WIN,
			       asm_height,
			       3,
			       0,
			       src_height - 1);
d801 2
a802 2
				    cmd_height,
				    tui_term_height () - cmd_height);
d806 5
a810 5
				   TUI_CMD_WIN->generic.type,
				   TUI_CMD_WIN->generic.height,
				   TUI_CMD_WIN->generic.width,
				   0,
				   TUI_CMD_WIN->generic.origin.y);
d861 5
a865 5
		       tui_win_list[win_type]->generic.type,
		       src_height,
		       tui_win_list[win_type]->generic.width,
		   tui_win_list[win_type]->detail.source_info.execution_info->width,
		       data_height - 1);
d867 5
a871 5
		       EXEC_INFO_WIN,
		       src_height,
		       3,
		       0,
		       data_height - 1);
d875 5
a879 5
		       LOCATOR_WIN,
		       2 /* 1 */ ,
		       tui_term_width (),
		       0,
		       total_height - 1);
d891 4
a894 2
init_gen_win_info (struct tui_gen_win_info *win_info, enum tui_win_type type,
                 int height, int width, int origin_x, int origin_y)
d918 4
a921 2
init_and_make_win (void *opaque_win_info, enum tui_win_type win_type,
		   int height, int width, int origin_x, int origin_y,
d955 3
a957 2
make_source_or_disasm_window (struct tui_win_info **win_info_ptr, enum tui_win_type type,
                             int height, int origin_y)
a1002 1

d1025 5
a1029 5
			   LOCATOR_WIN,
			   2 /* 1 */ ,
			   tui_term_width (),
			   0,
			   src_height - 1);
d1031 6
a1036 7
	  init_gen_win_info (
			    &(*win_info_ptr)->generic,
			    (*win_info_ptr)->generic.type,
			    src_height - 1,
			    (*win_info_ptr)->generic.width,
		      (*win_info_ptr)->detail.source_info.execution_info->width,
			    0);
d1038 5
a1042 5
			   EXEC_INFO_WIN,
			   src_height - 1,
			   3,
			   0,
			   0);
d1062 5
a1066 5
			       TUI_CMD_WIN->generic.type,
			       TUI_CMD_WIN->generic.height,
			       TUI_CMD_WIN->generic.width,
			       TUI_CMD_WIN->generic.origin.x,
			       TUI_CMD_WIN->generic.origin.y);
@


1.27
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-data.h, tui-disasm.c, tui-file.c,
	tui-hooks.c, tui-interp.c, tui-io.c, tui-layout.c, tui-out.c,
	tui-regs.c, tui-regs.h, tui-source.c, tui-stack.c, tui-win.c,
	tui-windata.c, tui-wingeneral.c, tui-winsource.c, tui-winsource.h,
	tui.c, tui.h: Comment reformatting to coding standard (capitals,
	spaces after periods, etc).
@
text
@d84 3
a86 5
      /*
         ** Since the new layout may cause changes in window size, we
         ** should free the content and reallocate on next display of
         ** source/asm.
       */
d166 2
a167 3
	      /*
	         ** Now determine where focus should be.
	       */
d178 8
a185 7
		      /* The previous layout was not showing
		         ** code. this can happen if there is no
		         ** source available:
		         ** 1. if the source file is in another dir OR
		         ** 2. if target was compiled without -g
		         ** We still want to show the assembly though!
		       */
d192 8
a199 7
		      /* The previous layout was not showing
		         ** code. this can happen if there is no
		         ** source available:
		         ** 1. if the source file is in another dir OR
		         ** 2. if target was compiled without -g
		         ** We still want to show the assembly though!
		       */
d216 8
a223 7
		      /* The previous layout was not showing
		         ** code. this can happen if there is no
		         ** source available:
		         ** 1. if the source file is in another dir OR
		         ** 2. if target was compiled without -g
		         ** We still want to show the assembly though!
		       */
d651 1
a651 2
/*
   ** make_source_window().
d662 1
a662 2
/*
   ** make_disasm_window().
d879 1
a879 2
/*
   ** init_gen_win_info().
d904 1
a904 2
/*
   ** init_and_make_win().
d947 1
a947 3
  /*
     ** Create the exeuction info window.
   */
d959 2
a960 3
  /*
     ** Now create the source window.
   */
@


1.26
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-data.c, tui-data.h, tui-disasm.c, tui-hooks.c, tui-layout.c,
	tui-regs.c, tui-source.c, tui-stack.c, tui-win.c, tui-windata.c,
	tui-wingeneral.c, tui-wingeneral.h, tui-winsource.c, tui.c,
	tui-winsource.h: Whitespace changes, fix pointer declarations
	to be consistant.
@
text
@d87 1
a87 1
         ** source/asm
d98 1
a98 1
	  /* First make the current layout be invisible */
d104 1
a104 1
	      /* Now show the new layout */
d169 1
a169 1
	         ** Now determine where focus should be
d181 1
a181 1
		      /* the previous layout was not showing
d194 1
a194 1
		      /* the previous layout was not showing
d217 1
a217 1
		      /* the previous layout was not showing
d420 1
a420 1
      /* First check for ambiguous input */
d445 5
a449 5
/* could ifdef out the following code. when compile with -z, there are null 
   pointer references that cause a core dump if 'layout regs' is the first 
   layout command issued by the user. HP has asked us to hook up this code 
   - edie epstein
 */
d478 2
a479 2
/* end of potential ifdef 
 */
d481 3
a483 3
/* if ifdefed out code above, then assume that the user wishes to display the 
   general purpose registers 
 */
d485 1
a485 2
/*              dpy_type = TUI_GENERAL_REGS; 
 */
d980 1
a980 1
/* Show the Source/Command or the Disassem layout.   */
@


1.25
log
@2007-08-08  Michael Snyder  <msnyder@@access-company.com>

	* tui/tui-layout.c (tui_set_layout): Dead code, dead variable.
@
text
@d52 5
a56 5
static void make_source_or_disasm_window (struct tui_win_info * *, enum tui_win_type, int, int);
static void make_command_window (struct tui_win_info * *, int, int);
static void make_source_window (struct tui_win_info * *, int, int);
static void make_disasm_window (struct tui_win_info * *, int, int);
static void make_data_window (struct tui_win_info * *, int, int);
d142 2
a143 2
      struct tui_win_info * win_with_focus = tui_win_with_focus ();
      struct tui_layout_def * layout_def = tui_layout_def ();
d538 1
a538 1
tui_handle_xdb_layout (struct tui_layout_def * layout_def)
d558 1
a558 1
  struct tui_layout_def * layout_def = tui_layout_def ();
d575 1
a575 1
  struct tui_layout_def * layout_def = tui_layout_def ();
d638 1
a638 1
make_command_window (struct tui_win_info * * win_info_ptr, int height, int origin_y)
d656 1
a656 1
make_source_window (struct tui_win_info * * win_info_ptr, int height, int origin_y)
d668 1
a668 1
make_disasm_window (struct tui_win_info * * win_info_ptr, int height, int origin_y)
d677 1
a677 1
make_data_window (struct tui_win_info * * win_info_ptr, int height, int origin_y)
d745 1
a745 1
	  struct tui_gen_win_info * locator = tui_locator_win_info_ptr ();
d825 1
a825 1
  struct tui_gen_win_info * locator = tui_locator_win_info_ptr ();
d886 1
a886 1
init_gen_win_info (struct tui_gen_win_info * win_info, enum tui_win_type type,
d916 1
a916 1
  struct tui_gen_win_info * generic;
d947 1
a947 1
make_source_or_disasm_window (struct tui_win_info * * win_info_ptr, enum tui_win_type type,
d950 1
a950 1
  struct tui_gen_win_info * execution_info = (struct tui_gen_win_info *) NULL;
d987 1
a987 1
      struct tui_win_info * *win_info_ptr;
d989 1
a989 1
      struct tui_gen_win_info * locator = tui_locator_win_info_ptr ();
@


1.24
log
@Copyright updates for 2007.
@
text
@a141 1
      struct tui_win_info * new_win_with_focus = (struct tui_win_info *) NULL;
a235 2
	      if (new_win_with_focus != (struct tui_win_info *) NULL)
		tui_set_win_focus_to (new_win_with_focus);
d237 1
a237 1
	         ** Now update the window content
a493 1
	  xfree (buf_ptr);
d497 1
@


1.23
log
@	Warning fixes.
	* ada-lang.c (find_struct_field): Initialize *byte_offset_p.
	* breakpoint.c (do_enable_breakpoint): Ignore both mem_cnt and i.
	* c-typeprint.c (c_type_print_varspec_suffix): Don't test length
	greater than or equal to zero.
	* m2-typeprint.c (m2_array): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	* gdbtypes.c (copy_type_recursive): Correct == typo.
	* i386-tdep.c (i386_skip_prologue): Remove stray semicolon.
	* linux-nat.c (linux_nat_info_proc_cmd): Don't compare a pointer
	greater than zero.
	* macroscope.c (sal_macro_scope): Don't name a local variable "main".
	(default_macro_scope): Remove unused variable.
	* prologue-value.h (pv_area_find_reg): Don't name an argument
	"register".
	* remote-fileio.c (remote_fio_func_map): Add missing braces.
	* remote.c (sigint_remote_twice_token, sigint_remote_token): Change
	type.
	(cleanup_sigint_signal_handler): Remove casts.
	* valprint.c (val_print): Use a volatile local for the modified
	argument.
	* varobj.c (languages): Remove extra array dimension.
	(varobj_create): Correct access to languages array.
	* mi/mi-cmd-break.c (mi_cmd_break_insert, mi_cmd_break_watch): Add
	missing braces.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Likewise.
	* mi/mi-cmd-env.c (mi_cmd_env_path, mi_cmd_env_dir): Likewise.
	* mi/mi-getopt.c (mi_valid_noargs): Likewise.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	(mi_cmd_data_write_memory): Likewise.
	* signals/signals.c (target_signal_to_string): Cast to int before
	comparing.
	* tui/tui-layout.c (init_and_make_win): Take and return a void *.
	Update all callers.
@
text
@d3 2
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
@


1.22
log
@	* tui/tui-file.c:
	* tui/tui-disasm.c:
	* tui/tui-data.h:
	* tui/tui-data.c:
	* tui/tui-command.h:
	* tui/tui-command.c:
	* tui/tui-win.h:
	* tui/tui-win.h:
	* tui/tui-win.c:
	* tui/tui-stack.h:
	* tui/tui-stack.c:
	* tui/tui-source.h:
	* tui/tui-source.c:
	* tui/tui-regs.h:
	* tui/tui-regs.c:
	* tui/tui-out.c:
	* tui/tui-main.c:
	* tui/tui-layout.h:
	* tui/tui-layout.c:
	* tui/tui-io.h:
	* tui/tui-io.c:
	* tui/tui-interp.c:
	* tui/tui-hooks.h:
	* tui/tui-hooks.c:
	* tui/tui-file.h:
	* tui/tui.h:
	* tui/tui.c:
	* tui/tui-winsource.h:
	* tui/tui-winsource.c:
	* tui/tui-wingeneral.h:
	* tui/tui-wingeneral.c:
	* tui/tui-windata.h:
	* tui/tui-windata.c: Add (C) after Copyright.  Update the FSF
	address.
@
text
@d50 1
a50 1
static void init_and_make_win (void **, enum tui_win_type, int, int, int, int, int);
d643 7
a649 7
  init_and_make_win ((void **) win_info_ptr,
		   CMD_WIN,
		   height,
		   tui_term_width (),
		   0,
		   origin_y,
		   DONT_BOX_WINDOW);
d682 7
a688 7
  init_and_make_win ((void **) win_info_ptr,
		   DATA_WIN,
		   height,
		   tui_term_width (),
		   0,
		   origin_y,
		   BOX_WINDOW);
d754 7
a760 7
	      init_and_make_win ((void **) & locator,
			       LOCATOR_WIN,
			       2 /* 1 */ ,
			       tui_term_width (),
			       0,
			       (src_height + asm_height) - 1,
			       DONT_BOX_WINDOW);
d847 7
a853 7
      init_and_make_win ((void **) & locator,
		       LOCATOR_WIN,
		       2 /* 1 */ ,
		       tui_term_width (),
		       0,
		       total_height - 1,
		       DONT_BOX_WINDOW);
d914 4
a917 3
static void
init_and_make_win (void ** win_info_ptr, enum tui_win_type win_type,
                 int height, int width, int origin_x, int origin_y, int box_it)
a918 1
  void *opaque_win_info = *win_info_ptr;
d945 1
a945 1
  *win_info_ptr = opaque_win_info;
d962 7
a968 7
  init_and_make_win ((void **) & execution_info,
		   EXEC_INFO_WIN,
		   height,
		   3,
		   0,
		   origin_y,
		   DONT_BOX_WINDOW);
d972 7
a978 7
  init_and_make_win ((void **) win_info_ptr,
		   type,
		   height,
		   tui_term_width () - execution_info->width,
		   execution_info->width,
		   origin_y,
		   BOX_WINDOW);
d1012 7
a1018 7
	  init_and_make_win ((void **) & locator,
			   LOCATOR_WIN,
			   2 /* 1 */ ,
			   tui_term_width (),
			   0,
			   src_height - 1,
			   DONT_BOX_WINDOW);
@


1.21
log
@2005-11-01  Andrew Stubbs  <andrew.stubbs@@st.com>

	* tui/tui-data.h (tui_line_or_address): Encapsulate the union in a
	struct with a tag.
	(tui_source_element, tui_source_info): Update.
	* tui/tui-disasm.c, tui/tui-source.c: Update to use the tagged union.
	* tui/tui-source.h, tui/tui-stack.c, tui/tui-win.c: Likewise.
	* tui/tui-winsource.c, tui/tui-data.c, tui/tui-layout.c: Likewise.
	* tui/tui-winsource.h: Likewise.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.20
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d522 1
a522 1
		    TUI_SRC_WIN->detail.source_info.start_line_or_addr.line_no,
d529 1
a529 1
      addr = TUI_DISASM_WIN->detail.source_info.start_line_or_addr.addr;
@


1.19
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d375 2
a376 2
  add_com ("layout", class_tui, tui_layout_command,
           "Change the layout of windows.\n\
d387 1
a387 1
           the window that has current logical focus.\n");
d390 5
a394 5
      add_com ("td", class_tui, tui_toggle_layout_command,
               "Toggle between Source/Command and Disassembly/Command layouts.\n");
      add_com ("ts", class_tui, tui_toggle_split_layout_command,
               "Toggle between Source/Command or Disassembly/Command and \n\
Source/Disassembly/Command layouts.\n");
@


1.18
log
@	* tui/tui-win.h (tui_get_cmd_list): Declare.
	* tui/tui-win.c (tui_command): New function.
	(tui_get_cmd_list): New function.
	(_initialize_tui_win): Moved initialization of tui command in
	tui_get_cmd_list.

	* tui/tui-data.c (init_content_element): Setup new data members.
	(init_win_info): Likewise.
	(free_content_elements): Free it.
	* tui/tui-data.h (struct tui_data_element): Store the register
	content to print.
	(struct tui_data_info): Keep the current register group.

	* tui/tui-layout.c (tui_set_layout): Update call to tui_show_registers.

	* tui/tui-regs.h (tui_show_registers): Update prototype.
	(tui_toggle_float_regs, tui_calculate_regs_column_count): Remove.
	(tui_resize_all): No need to calculate anything for register window.
	* tui/tui-regs.c (tui_calculate_regs_column_count): Remove.
	(tui_set_register_element, tui_set_general_regs_content): Remove.
	(tui_set_special_regs_content): Remove.
	(tui_set_general_and_special_regs_content): Remove.
	(tui_set_float_regs_content): Remove.
	(tui_reg_value_has_changed, tui_get_register_raw_value): Remove.
	(tui_set_regs_content): Remove.
	(tui_toggle_float_regs, _tui_toggle_float_regs_command): Remove.
	(tui_v_show_registers_command_support): Remove.
	(tui_show_registers): Use a reggroup to specify the registers to show.
	(tui_show_register_group): New function.
	(tui_display_registers_from): Compute the layout of register window
	and refresh with new API; be sure to delete old register windows.
	(tui_check_register_values): Update to use tui_get_register and
	tui_display_data.
	(tui_display_register): Just refresh the register window part.
	(tui_register_format): Format registers and save in tui_data_element.
	(tui_get_register): New to combine tui_reg_value_has_changed and
	tui_get_register_raw_value; fix to use the new gdb API.
	(tui_show_float_command): Renamed tui_reg_float_command.
	(tui_show_general_command): Renamed tui_reg_general_command.
	(tui_show_special_command): Renamed tui_reg_system_command.
	(_initialize_tui_regs): Remove unused commands.
@
text
@d426 1
a426 1
	  warning ("Ambiguous command input.\n");
d595 1
a595 1
    warning ("Invalid layout specified.\n%s", LAYOUT_USAGE);
@


1.18.2.1
log
@merge mainline changes to branch
@
text
@@


1.17
log
@2004-02-16  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-windata.c: Include "gdb_string.h".
	* tui/tui-source.c, tui/tui-winsource.c: Ditto.
	* tui/tui-layout.c, tui/tui-command.c: Ditto.
	* Makefile.in: Update dependencies.
@
text
@d251 1
a251 4
	      layout_def->regs_display_type =
		(regs_display_type == TUI_UNDEFINED_REGS ?
		 TUI_GENERAL_REGS : regs_display_type);
	      tui_show_registers (layout_def->regs_display_type);
@


1.17.2.1
log
@Merge mainline to intercu branch.
@
text
@d251 4
a254 1
              tui_show_registers (TUI_DATA_WIN->detail.data_display_info.current_group);
@


1.17.6.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d251 4
a254 1
              tui_show_registers (TUI_DATA_WIN->detail.data_display_info.current_group);
@


1.17.4.1
log
@	* tui/tui-win.h (tui_get_cmd_list): Declare.
	* tui/tui-win.c (tui_command): New function.
	(tui_get_cmd_list): New function.
	(_initialize_tui_win): Moved initialization of tui command in
	tui_get_cmd_list.

	* tui/tui-data.c (init_content_element): Setup new data members.
	(init_win_info): Likewise.
	(free_content_elements): Free it.
	* tui/tui-data.h (struct tui_data_element): Store the register
	content to print.
	(struct tui_data_info): Keep the current register group.

	* tui/tui-layout.c (tui_set_layout): Update call to tui_show_registers.

	* tui/tui-regs.h (tui_show_registers): Update prototype.
	(tui_toggle_float_regs, tui_calculate_regs_column_count): Remove.
	(tui_resize_all): No need to calculate anything for register window.
	* tui/tui-regs.c (tui_calculate_regs_column_count): Remove.
	(tui_set_register_element, tui_set_general_regs_content): Remove.
	(tui_set_special_regs_content): Remove.
	(tui_set_general_and_special_regs_content): Remove.
	(tui_set_float_regs_content): Remove.
	(tui_reg_value_has_changed, tui_get_register_raw_value): Remove.
	(tui_set_regs_content): Remove.
	(tui_toggle_float_regs, _tui_toggle_float_regs_command): Remove.
	(tui_v_show_registers_command_support): Remove.
	(tui_show_registers): Use a reggroup to specify the registers to show.
	(tui_show_register_group): New function.
	(tui_display_registers_from): Compute the layout of register window
	and refresh with new API; be sure to delete old register windows.
	(tui_check_register_values): Update to use tui_get_register and
	tui_display_data.
	(tui_display_register): Just refresh the register window part.
	(tui_register_format): Format registers and save in tui_data_element.
	(tui_get_register): New to combine tui_reg_value_has_changed and
	tui_get_register_raw_value; fix to use the new gdb API.
	(tui_show_float_command): Renamed tui_reg_float_command.
	(tui_show_general_command): Renamed tui_reg_general_command.
	(tui_show_special_command): Renamed tui_reg_system_command.
	(_initialize_tui_regs): Remove unused commands.
@
text
@d251 4
a254 1
              tui_show_registers (TUI_DATA_WIN->detail.data_display_info.current_group);
@


1.16
log
@2004-02-10  Andrew Cagney  <cagney@@redhat.com>

	* defs.h: Do not include "tui.h".
	* gdb_curses.h: New file.
	* tui/tui-hooks.h: New file.
	* tui/tui.h (tui_update_all_exec_infos): Delete declaration.
	(tui_install_hooks, tui_remove_hooks): Delete declarations.
	(tui_initialize_io): Delete declaration.
	(tui_initialize_readline: Delete redundant declaration.
	(struct tui_point): Delete definition.
	* tui/tui-data.h (struct tui_point): Define.
	* cli/cli-decode.c [TUI]: Include "tui/tui.h".
	* utils.c: Include "tui/tui.h".
	* tui/tui-data.h: Include "tui/tui.h" and "gdb_curses.h".
	* printcmd.c [TUI]: Include "tui/tui.h".
	* cli/cli-cmds.c [TUI]: Include "tui/tui.h".
	* tui/tui-command.c: Include "gdb_curses.h".
	* tui/tui.c, tui/tui-winsource.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-windata.c, tui/tui-win.c, tui/tui-stack.c: Ditto.
	* tui/tui-source.c, tui/tui-regs.c, tui/tui-layout.c: Ditto.
	* tui/tui-io.c, tui/tui-disasm.c, tui/tui-data.c: : Ditto.
	* tui/tui-hooks.c: Include "tui-hooks.h" and "gdb_curses.h".
	* Makefile.in: Update all dependencies.
	(tui_hooks_h, gdb_curses_h): Define.
	(SUBDIR_TUI_CFLAGS): Remove -I${srcdir}/tui.
@
text
@d42 1
@


1.15
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Include "gdb_string.h", delete register
	attribute, use ISO-C function signatures.
	* tui/tui-disasm.c, tui/tui-file.c, tui/tui-io.c: Ditto.
	* tui/tui-layout.c, tui/tui-regs.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-win.c, tui/tui-winsource.c: Ditto.
	* tui/tui.c: Ditto.
@
text
@d42 1
a42 7
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
@


1.15.2.1
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d53 20
a72 20
static void showLayout (enum tui_layout_type);
static void _initGenWinInfo (struct tui_gen_win_info *, enum tui_win_type, int, int, int, int);
static void _initAndMakeWin (void **, enum tui_win_type, int, int, int, int, int);
static void _showSourceOrDisassemAndCommand (enum tui_layout_type);
static void _makeSourceOrDisassemWindow (struct tui_win_info * *, enum tui_win_type, int, int);
static void _makeCommandWindow (struct tui_win_info * *, int, int);
static void _makeSourceWindow (struct tui_win_info * *, int, int);
static void _makeDisassemWindow (struct tui_win_info * *, int, int);
static void _makeDataWindow (struct tui_win_info * *, int, int);
static void _showSourceCommand (void);
static void _showDisassemCommand (void);
static void _showSourceDisassemCommand (void);
static void _showData (enum tui_layout_type);
static enum tui_layout_type _nextLayout (void);
static enum tui_layout_type _prevLayout (void);
static void _tuiLayout_command (char *, int);
static void _tuiToggleLayout_command (char *, int);
static void _tuiToggleSplitLayout_command (char *, int);
static CORE_ADDR _extractDisplayStartAddr (void);
static void _tuiHandleXDBLayout (struct tui_layout_def *);
d83 1
a83 1
showLayout (enum tui_layout_type layout)
d85 1
a85 1
  enum tui_layout_type curLayout = tui_current_layout ();
d87 1
a87 1
  if (layout != curLayout)
d98 1
a98 1
	  _showData (layout);
d111 1
a111 1
	      _showSourceCommand ();
d115 1
a115 1
	      _showDisassemCommand ();
d119 1
a119 1
	      _showSourceDisassemCommand ();
d137 1
a137 1
tui_set_layout (enum tui_layout_type layoutType,
d142 1
a142 1
  if (layoutType != UNDEFINED_LAYOUT || regs_display_type != TUI_UNDEFINED_REGS)
d144 6
a149 6
      enum tui_layout_type curLayout = tui_current_layout (), newLayout = UNDEFINED_LAYOUT;
      int regsPopulate = FALSE;
      CORE_ADDR addr = _extractDisplayStartAddr ();
      struct tui_win_info * newWinWithFocus = (struct tui_win_info *) NULL;
      struct tui_win_info * winWithFocus = tui_win_with_focus ();
      struct tui_layout_def * layoutDef = tui_layout_def ();
d152 1
a152 1
      if (layoutType == UNDEFINED_LAYOUT &&
d155 7
a161 7
	  if (curLayout == SRC_DISASSEM_COMMAND)
	    newLayout = DISASSEM_DATA_COMMAND;
	  else if (curLayout == SRC_COMMAND || curLayout == SRC_DATA_COMMAND)
	    newLayout = SRC_DATA_COMMAND;
	  else if (curLayout == DISASSEM_COMMAND ||
		   curLayout == DISASSEM_DATA_COMMAND)
	    newLayout = DISASSEM_DATA_COMMAND;
d164 1
a164 1
	newLayout = layoutType;
d166 2
a167 2
      regsPopulate = (newLayout == SRC_DATA_COMMAND ||
		      newLayout == DISASSEM_DATA_COMMAND ||
d169 1
a169 1
      if (newLayout != curLayout || regs_display_type != TUI_UNDEFINED_REGS)
d171 1
a171 1
	  if (newLayout != curLayout)
d173 1
a173 1
	      showLayout (newLayout);
d177 1
a177 1
	      if (winWithFocus != TUI_CMD_WIN)
d179 1
a179 1
		  switch (newLayout)
d183 2
a184 2
		      layoutDef->display_mode = SRC_WIN;
		      layoutDef->split = FALSE;
d196 2
a197 2
		      layoutDef->display_mode = DISASSEM_WIN;
		      layoutDef->split = FALSE;
d208 1
a208 1
		      if (winWithFocus == TUI_SRC_WIN)
d212 1
a212 1
		      layoutDef->split = TRUE;
d215 1
a215 1
		      if (winWithFocus != TUI_DATA_WIN)
d219 2
a220 2
		      layoutDef->display_mode = SRC_WIN;
		      layoutDef->split = FALSE;
d231 1
a231 1
		      if (winWithFocus != TUI_DATA_WIN)
d235 2
a236 2
		      layoutDef->display_mode = DISASSEM_WIN;
		      layoutDef->split = FALSE;
d242 2
a243 2
	      if (newWinWithFocus != (struct tui_win_info *) NULL)
		tui_set_win_focus_to (newWinWithFocus);
d247 3
a249 3
	      if (!regsPopulate &&
		  (newLayout == SRC_DATA_COMMAND ||
		   newLayout == DISASSEM_DATA_COMMAND))
d254 1
a254 1
	  if (regsPopulate)
d256 1
a256 1
	      layoutDef->regs_display_type =
d259 1
a259 1
	      tui_show_registers (layoutDef->regs_display_type);
d275 1
a275 1
  enum tui_layout_type curLayout = tui_current_layout ();
d280 3
a282 3
      if (curLayout != SRC_COMMAND &&
	  curLayout != SRC_DISASSEM_COMMAND &&
	  curLayout != SRC_DATA_COMMAND)
d285 2
a286 2
	  if (curLayout == DISASSEM_DATA_COMMAND)
	    showLayout (SRC_DATA_COMMAND);
d288 1
a288 1
	    showLayout (SRC_COMMAND);
d292 3
a294 3
      if (curLayout != DISASSEM_COMMAND &&
	  curLayout != SRC_DISASSEM_COMMAND &&
	  curLayout != DISASSEM_DATA_COMMAND)
d297 2
a298 2
	  if (curLayout == SRC_DATA_COMMAND)
	    showLayout (DISASSEM_DATA_COMMAND);
d300 1
a300 1
	    showLayout (DISASSEM_COMMAND);
d304 2
a305 2
      if (curLayout != SRC_DATA_COMMAND &&
	  curLayout != DISASSEM_DATA_COMMAND)
d307 2
a308 2
	  if (curLayout == DISASSEM_COMMAND)
	    showLayout (DISASSEM_DATA_COMMAND);
d310 1
a310 1
	    showLayout (SRC_DATA_COMMAND);
d316 1
a317 2
  return;
}				/* tuiAddWinToLayout */
d319 3
a321 7

/*
   ** tuiDefaultWinHeight().
   **        Answer the height of a window.  If it hasn't been created yet,
   **        answer what the height of a window would be based upon its
   **        type and the layout.
 */
d323 1
a323 1
tuiDefaultWinHeight (enum tui_win_type type, enum tui_layout_type layout)
d355 1
a355 1
}				/* tuiDefaultWinHeight */
d367 1
a367 1
  h = tuiDefaultWinHeight (type, layout);
d375 1
a375 1
}				/* tuiDefaultWinViewportHeight */
d378 2
a379 5
/*
   ** _initialize_tuiLayout().
   **        Function to initialize gdb commands, for tui window layout
   **        manipulation.
 */
d381 1
a381 1
_initialize_tuiLayout (void)
d383 1
a383 1
  add_com ("layout", class_tui, _tuiLayout_command,
d398 1
a398 1
      add_com ("td", class_tui, _tuiToggleLayout_command,
d400 1
a400 1
      add_com ("ts", class_tui, _tuiToggleSplitLayout_command,
d412 2
a413 5
/*
   ** _tuiSetLayoutTo()
   **    Function to set the layout to SRC, ASM, SPLIT, NEXT, PREV, DATA, REGS,
   **        $REGS, $GREGS, $FREGS, $SREGS.
 */
d415 1
a415 1
tui_set_layout_for_display_command (const char *layoutName)
d419 1
a419 1
  if (layoutName != (char *) NULL)
d421 9
a429 9
      register int i;
      register char *bufPtr;
      enum tui_layout_type newLayout = UNDEFINED_LAYOUT;
      enum tui_register_display_type dpyType = TUI_UNDEFINED_REGS;
      enum tui_layout_type curLayout = tui_current_layout ();

      bufPtr = (char *) xstrdup (layoutName);
      for (i = 0; (i < strlen (layoutName)); i++)
	bufPtr[i] = toupper (bufPtr[i]);
d432 1
a432 1
      if (strlen (bufPtr) <= 1 && (*bufPtr == 'S' || *bufPtr == '$'))
d439 11
a449 11
	  if (subset_compare (bufPtr, "SRC"))
	    newLayout = SRC_COMMAND;
	  else if (subset_compare (bufPtr, "ASM"))
	    newLayout = DISASSEM_COMMAND;
	  else if (subset_compare (bufPtr, "SPLIT"))
	    newLayout = SRC_DISASSEM_COMMAND;
	  else if (subset_compare (bufPtr, "REGS") ||
		   subset_compare (bufPtr, TUI_GENERAL_SPECIAL_REGS_NAME) ||
		   subset_compare (bufPtr, TUI_GENERAL_REGS_NAME) ||
		   subset_compare (bufPtr, TUI_FLOAT_REGS_NAME) ||
		   subset_compare (bufPtr, TUI_SPECIAL_REGS_NAME))
d451 2
a452 2
	      if (curLayout == SRC_COMMAND || curLayout == SRC_DATA_COMMAND)
		newLayout = SRC_DATA_COMMAND;
d454 1
a454 1
		newLayout = DISASSEM_DATA_COMMAND;
d461 1
a461 1
	      if (subset_compare (bufPtr, TUI_FLOAT_REGS_NAME))
d467 1
a467 1
		    dpyType = TUI_SFLOAT_REGS;
d469 1
a469 1
		    dpyType =
d472 1
a472 1
	      else if (subset_compare (bufPtr,
d474 5
a478 5
		dpyType = TUI_GENERAL_AND_SPECIAL_REGS;
	      else if (subset_compare (bufPtr, TUI_GENERAL_REGS_NAME))
		dpyType = TUI_GENERAL_REGS;
	      else if (subset_compare (bufPtr, TUI_SPECIAL_REGS_NAME))
		dpyType = TUI_SPECIAL_REGS;
d483 1
a483 1
		    dpyType =
d486 1
a486 1
		    dpyType = TUI_GENERAL_REGS;
d496 1
a496 1
/*              dpyType = TUI_GENERAL_REGS; 
d499 4
a502 4
	  else if (subset_compare (bufPtr, "NEXT"))
	    newLayout = _nextLayout ();
	  else if (subset_compare (bufPtr, "PREV"))
	    newLayout = _prevLayout ();
d505 1
a505 1
	  xfree (bufPtr);
d507 1
a507 1
	  tui_set_layout (newLayout, dpyType);
d518 1
a518 1
_extractDisplayStartAddr (void)
d520 1
a520 1
  enum tui_layout_type curLayout = tui_current_layout ();
d525 1
a525 1
  switch (curLayout)
d545 1
a545 1
}				/* _extractDisplayStartAddr */
d549 1
a549 1
_tuiHandleXDBLayout (struct tui_layout_def * layoutDef)
d551 1
a551 1
  if (layoutDef->split)
d554 1
a554 1
      tui_set_win_focus_to (tui_win_list[layoutDef->display_mode]);
d558 1
a558 1
      if (layoutDef->display_mode == SRC_WIN)
d561 1
a561 1
	tui_set_layout (DISASSEM_DATA_COMMAND, layoutDef->regs_display_type);
d563 1
a563 4


  return;
}				/* _tuiHandleXDBLayout */
d567 1
a567 1
_tuiToggleLayout_command (char *arg, int fromTTY)
d569 1
a569 1
  struct tui_layout_def * layoutDef = tui_layout_def ();
d573 2
a574 2
  if (layoutDef->display_mode == SRC_WIN)
    layoutDef->display_mode = DISASSEM_WIN;
d576 1
a576 4
    layoutDef->display_mode = SRC_WIN;

  if (!layoutDef->split)
    _tuiHandleXDBLayout (layoutDef);
d578 2
d584 1
a584 1
_tuiToggleSplitLayout_command (char *arg, int fromTTY)
d586 1
a586 1
  struct tui_layout_def * layoutDef = tui_layout_def ();
d590 2
a591 3
  layoutDef->split = (!layoutDef->split);
  _tuiHandleXDBLayout (layoutDef);

d596 1
a596 1
_tuiLayout_command (char *arg, int fromTTY)
d607 1
a607 4
/*
   ** _nextLayout().
   **        Answer the previous layout to cycle to.
 */
d609 1
a609 1
_nextLayout (void)
d611 1
a611 1
  enum tui_layout_type newLayout;
d613 3
a615 3
  newLayout = tui_current_layout ();
  if (newLayout == UNDEFINED_LAYOUT)
    newLayout = SRC_COMMAND;
d618 3
a620 3
      newLayout++;
      if (newLayout == UNDEFINED_LAYOUT)
	newLayout = SRC_COMMAND;
d623 2
a624 2
  return newLayout;
}				/* _nextLayout */
d627 1
a627 4
/*
   ** _prevLayout().
   **        Answer the next layout to cycle to.
 */
d629 1
a629 1
_prevLayout (void)
d631 1
a631 1
  enum tui_layout_type newLayout;
d633 3
a635 3
  newLayout = tui_current_layout ();
  if (newLayout == SRC_COMMAND)
    newLayout = DISASSEM_DATA_COMMAND;
d638 3
a640 3
      newLayout--;
      if (newLayout == UNDEFINED_LAYOUT)
	newLayout = DISASSEM_DATA_COMMAND;
d643 2
a644 2
  return newLayout;
}				/* _prevLayout */
a647 3
/*
   ** _makeCommandWindow().
 */
d649 1
a649 1
_makeCommandWindow (struct tui_win_info * * winInfoPtr, int height, int originY)
d651 1
a651 1
  _initAndMakeWin ((void **) winInfoPtr,
d656 1
a656 1
		   originY,
d659 2
a660 4
  (*winInfoPtr)->can_highlight = FALSE;

  return;
}				/* _makeCommandWindow */
d664 1
a664 1
   ** _makeSourceWindow().
d667 1
a667 1
_makeSourceWindow (struct tui_win_info * * winInfoPtr, int height, int originY)
d669 1
a669 1
  _makeSourceOrDisassemWindow (winInfoPtr, SRC_WIN, height, originY);
d672 1
a672 1
}				/* _makeSourceWindow */
d676 1
a676 1
   ** _makeDisassemWindow().
d679 1
a679 1
_makeDisassemWindow (struct tui_win_info * * winInfoPtr, int height, int originY)
d681 1
a681 1
  _makeSourceOrDisassemWindow (winInfoPtr, DISASSEM_WIN, height, originY);
d684 1
a684 1
}				/* _makeDisassemWindow */
a686 3
/*
   ** _makeDataWindow().
 */
d688 1
a688 1
_makeDataWindow (struct tui_win_info * * winInfoPtr, int height, int originY)
d690 1
a690 1
  _initAndMakeWin ((void **) winInfoPtr,
d695 1
a695 1
		   originY,
d697 1
a697 3

  return;
}				/* _makeDataWindow */
d701 1
a701 4
/*
   **    _showSourceCommand().
   **        Show the Source/Command layout
 */
d703 1
a703 1
_showSourceCommand (void)
d705 2
a706 4
  _showSourceOrDisassemAndCommand (SRC_COMMAND);

  return;
}				/* _showSourceCommand */
d709 1
a709 4
/*
   **    _showDisassemCommand().
   **        Show the Dissassem/Command layout
 */
d711 1
a711 1
_showDisassemCommand (void)
d713 2
a714 4
  _showSourceOrDisassemAndCommand (DISASSEM_COMMAND);

  return;
}				/* _showDisassemCommand */
d717 1
a717 4
/*
   **    _showSourceDisassemCommand().
   **        Show the Source/Disassem/Command layout
 */
d719 1
a719 1
_showSourceDisassemCommand (void)
d723 1
a723 1
      int cmdHeight, srcHeight, asmHeight;
d726 1
a726 1
	cmdHeight = TUI_CMD_WIN->generic.height;
d728 1
a728 1
	cmdHeight = tui_term_height () / 3;
d730 2
a731 2
      srcHeight = (tui_term_height () - cmdHeight) / 2;
      asmHeight = tui_term_height () - (srcHeight + cmdHeight);
d734 1
a734 1
	_makeSourceWindow (&TUI_SRC_WIN, srcHeight, 0);
d737 1
a737 1
	  _initGenWinInfo (&TUI_SRC_WIN->generic,
d739 1
a739 1
			   srcHeight,
d744 1
a744 1
	  _initGenWinInfo (TUI_SRC_WIN->detail.source_info.execution_info,
d746 1
a746 1
			   srcHeight,
d761 2
a762 2
	      _makeDisassemWindow (&TUI_DISASM_WIN, asmHeight, srcHeight - 1);
	      _initAndMakeWin ((void **) & locator,
d767 1
a767 1
			       (srcHeight + asmHeight) - 1,
d772 1
a772 1
	      _initGenWinInfo (locator,
d777 1
a777 1
			       (srcHeight + asmHeight) - 1);
d779 1
a779 1
	      _initGenWinInfo (
d782 1
a782 1
				asmHeight,
d785 2
a786 2
				srcHeight - 1);
	      _initGenWinInfo (TUI_DISASM_WIN->detail.source_info.execution_info,
d788 1
a788 1
			       asmHeight,
d791 1
a791 1
			       srcHeight - 1);
d805 3
a807 3
		_makeCommandWindow (&TUI_CMD_WIN,
				    cmdHeight,
				    tui_term_height () - cmdHeight);
d810 1
a810 1
		  _initGenWinInfo (&TUI_CMD_WIN->generic,
d825 1
a826 2
  return;
}				/* _showSourceDisassemCommand */
d828 2
a829 5

/*
   **    _showData().
   **        Show the Source/Data/Command or the Dissassembly/Data/Command layout
 */
d831 1
a831 1
_showData (enum tui_layout_type newLayout)
d833 3
a835 3
  int totalHeight = (tui_term_height () - TUI_CMD_WIN->generic.height);
  int srcHeight, dataHeight;
  enum tui_win_type winType;
d839 2
a840 2
  dataHeight = totalHeight / 2;
  srcHeight = totalHeight - dataHeight;
d843 1
a843 1
  _makeDataWindow (&TUI_DATA_WIN, dataHeight, 0);
d845 2
a846 2
  if (newLayout == SRC_DATA_COMMAND)
    winType = SRC_WIN;
d848 2
a849 2
    winType = DISASSEM_WIN;
  if (tui_win_list[winType] == NULL)
d851 2
a852 2
      if (winType == SRC_WIN)
	_makeSourceWindow (&tui_win_list[winType], srcHeight, dataHeight - 1);
d854 2
a855 2
	_makeDisassemWindow (&tui_win_list[winType], srcHeight, dataHeight - 1);
      _initAndMakeWin ((void **) & locator,
d860 1
a860 1
		       totalHeight - 1,
d865 7
a871 7
      _initGenWinInfo (&tui_win_list[winType]->generic,
		       tui_win_list[winType]->generic.type,
		       srcHeight,
		       tui_win_list[winType]->generic.width,
		   tui_win_list[winType]->detail.source_info.execution_info->width,
		       dataHeight - 1);
      _initGenWinInfo (tui_win_list[winType]->detail.source_info.execution_info,
d873 1
a873 1
		       srcHeight,
d876 4
a879 4
		       dataHeight - 1);
      tui_make_visible (&tui_win_list[winType]->generic);
      tui_make_visible (tui_win_list[winType]->detail.source_info.execution_info);
      _initGenWinInfo (locator,
d884 1
a884 1
		       totalHeight - 1);
d886 1
a886 1
  tui_win_list[winType]->detail.source_info.has_locator = TRUE;
d889 3
a891 5
  tui_add_to_source_windows (tui_win_list[winType]);
  tui_set_current_layout_to (newLayout);

  return;
}				/* _showData */
d894 1
a894 1
   ** _initGenWinInfo().
d897 2
a898 2
_initGenWinInfo (struct tui_gen_win_info * winInfo, enum tui_win_type type,
                 int height, int width, int originX, int originY)
d902 3
a904 3
  winInfo->type = type;
  winInfo->width = width;
  winInfo->height = h;
d907 3
a909 3
      winInfo->viewport_height = h - 1;
      if (winInfo->type != CMD_WIN)
	winInfo->viewport_height--;
d912 3
a914 3
    winInfo->viewport_height = 1;
  winInfo->origin.x = originX;
  winInfo->origin.y = originY;
d917 1
a917 1
}				/* _initGenWinInfo */
d920 1
a920 1
   ** _initAndMakeWin().
d923 2
a924 2
_initAndMakeWin (void ** winInfoPtr, enum tui_win_type winType,
                 int height, int width, int originX, int originY, int boxIt)
d926 1
a926 1
  void *opaqueWinInfo = *winInfoPtr;
d929 1
a929 1
  if (opaqueWinInfo == NULL)
d931 2
a932 2
      if (tui_win_is_auxillary (winType))
	opaqueWinInfo = (void *) tui_alloc_generic_win_info ();
d934 1
a934 1
	opaqueWinInfo = (void *) tui_alloc_win_info (winType);
d936 2
a937 2
  if (tui_win_is_auxillary (winType))
    generic = (struct tui_gen_win_info *) opaqueWinInfo;
d939 1
a939 1
    generic = &((struct tui_win_info *) opaqueWinInfo)->generic;
d941 1
a941 1
  if (opaqueWinInfo != NULL)
d943 2
a944 2
      _initGenWinInfo (generic, winType, height, width, originX, originY);
      if (!tui_win_is_auxillary (winType))
d947 1
a947 1
	    ((struct tui_win_info *) opaqueWinInfo)->can_highlight = FALSE;
d949 1
a949 1
	    ((struct tui_win_info *) opaqueWinInfo)->can_highlight = TRUE;
d951 1
a951 1
      tui_make_window (generic, boxIt);
d953 1
a953 1
  *winInfoPtr = opaqueWinInfo;
a956 3
/*
   ** _makeSourceOrDisassemWindow().
 */
d958 2
a959 2
_makeSourceOrDisassemWindow (struct tui_win_info * * winInfoPtr, enum tui_win_type type,
                             int height, int originY)
d970 1
a970 1
  _initAndMakeWin ((void **) & execution_info,
d975 1
a975 1
		   originY,
d980 1
a980 1
  _initAndMakeWin ((void **) winInfoPtr,
d985 1
a985 1
		   originY,
d988 2
a989 4
  (*winInfoPtr)->detail.source_info.execution_info = execution_info;

  return;
}				/* _makeSourceOrDisassemWindow */
d992 1
a992 4
/*
   **    _showSourceOrDisassemAndCommand().
   **        Show the Source/Command or the Disassem layout
 */
d994 1
a994 1
_showSourceOrDisassemAndCommand (enum tui_layout_type layoutType)
d996 1
a996 1
  if (tui_current_layout () != layoutType)
d998 2
a999 2
      struct tui_win_info * *winInfoPtr;
      int srcHeight, cmdHeight;
d1003 1
a1003 1
	cmdHeight = TUI_CMD_WIN->generic.height;
d1005 2
a1006 2
	cmdHeight = tui_term_height () / 3;
      srcHeight = tui_term_height () - cmdHeight;
d1009 2
a1010 2
      if (layoutType == SRC_COMMAND)
	winInfoPtr = &TUI_SRC_WIN;
d1012 1
a1012 1
	winInfoPtr = &TUI_DISASM_WIN;
d1014 1
a1014 1
      if ((*winInfoPtr) == NULL)
d1016 2
a1017 2
	  if (layoutType == SRC_COMMAND)
	    _makeSourceWindow (winInfoPtr, srcHeight - 1, 0);
d1019 2
a1020 2
	    _makeDisassemWindow (winInfoPtr, srcHeight - 1, 0);
	  _initAndMakeWin ((void **) & locator,
d1025 1
a1025 1
			   srcHeight - 1,
d1030 1
a1030 1
	  _initGenWinInfo (locator,
d1035 8
a1042 8
			   srcHeight - 1);
	  (*winInfoPtr)->detail.source_info.has_locator = TRUE;
	  _initGenWinInfo (
			    &(*winInfoPtr)->generic,
			    (*winInfoPtr)->generic.type,
			    srcHeight - 1,
			    (*winInfoPtr)->generic.width,
		      (*winInfoPtr)->detail.source_info.execution_info->width,
d1044 1
a1044 1
	  _initGenWinInfo ((*winInfoPtr)->detail.source_info.execution_info,
d1046 1
a1046 1
			   srcHeight - 1,
d1050 3
a1052 3
	  (*winInfoPtr)->can_highlight = TRUE;
	  tui_make_visible (&(*winInfoPtr)->generic);
	  tui_make_visible ((*winInfoPtr)->detail.source_info.execution_info);
d1054 1
a1054 1
      if ((*winInfoPtr) != NULL)
d1056 1
a1056 1
	  (*winInfoPtr)->detail.source_info.has_locator = TRUE;
d1059 1
a1059 1
	  tui_show_source_content (*winInfoPtr);
d1063 1
a1063 1
	      _makeCommandWindow (&TUI_CMD_WIN, cmdHeight, srcHeight);
d1068 1
a1068 1
	      _initGenWinInfo (&TUI_CMD_WIN->generic,
d1078 1
a1078 1
      tui_set_current_layout_to (layoutType);
d1080 1
a1080 3

  return;
}				/* _showSourceOrDisassemAndCommand */
@


1.14
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Change variable and function names to lower
	case.
	* tui/tui-data.c, tui/tui-disasm.c: Ditto.
	* tui/tui-hooks.c, tui/tui-io.c, tui/tui-layout.c: Ditto.
	* tui/tui-regs.c, tui/tui-source.c, tui/tui-stack.c: Ditto.
	* tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d421 2
a422 2
      register int i;
      register char *buf_ptr;
@


1.13
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui.h: Do not include <stdarg.h>, <string.h>, and
	"ansidecl.h".  Do not undef "reg" and "chtype".  Fix case of
	fields and variables.
	* tui/tui-wingeneral.h (m_beVisible): Delete macro.
	(m_beInvisible): Delete macro.
	* tui/tui-data.h: Fix case case fields and variables.
	(m_genWinPtrIsNull): Delete macro.
	(tui_win_list): Rename winList.
	(TUI_SRC_WIN): Rename srcWin.
	(TUI_DISASM_WIN): Rename disassemWin.
	(TUI_DATA_WIN): Rename dataWin.
	(TUI_CMD_WIN): Rename cmdWin.
	(m_genWinPtrNotNull): Delete macro.
	(m_winPtrIsNull): Delete macro.
	(m_winPtrNotNull): Delete macro.
	(tui_win_is_source_type): Replace m_winIsSourceType
	(tui_win_is_auxillary): Replace m_winIsAuzillary.
	(tui_win_has_locator): Replace m_hasLocator.
	(tui_set_win_highlight): Replace m_setWinHighlightOn and
	m_setWinHighlightOff.
	* tui/tui-data.c: Update references.
	(tui_win_is_source_type, tui_set_win_highlight): New functions.
	(tui_win_has_locator, tui_win_is_auxillary): New functions.
	* tui/tui-command.c, tui/tui-disasm.c: Update references.
	* tui/tui-io.c, tui/tui-layout.c, tui/tui-regs.c: Ditto.
	* tui/tui-regs.h, tui/tui-source.c, tui/tui-stack.c: Ditto.
	* tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d53 20
a72 20
static void showLayout (enum tui_layout_type);
static void _initGenWinInfo (struct tui_gen_win_info *, enum tui_win_type, int, int, int, int);
static void _initAndMakeWin (void **, enum tui_win_type, int, int, int, int, int);
static void _showSourceOrDisassemAndCommand (enum tui_layout_type);
static void _makeSourceOrDisassemWindow (struct tui_win_info * *, enum tui_win_type, int, int);
static void _makeCommandWindow (struct tui_win_info * *, int, int);
static void _makeSourceWindow (struct tui_win_info * *, int, int);
static void _makeDisassemWindow (struct tui_win_info * *, int, int);
static void _makeDataWindow (struct tui_win_info * *, int, int);
static void _showSourceCommand (void);
static void _showDisassemCommand (void);
static void _showSourceDisassemCommand (void);
static void _showData (enum tui_layout_type);
static enum tui_layout_type _nextLayout (void);
static enum tui_layout_type _prevLayout (void);
static void _tuiLayout_command (char *, int);
static void _tuiToggleLayout_command (char *, int);
static void _tuiToggleSplitLayout_command (char *, int);
static CORE_ADDR _extractDisplayStartAddr (void);
static void _tuiHandleXDBLayout (struct tui_layout_def *);
d83 1
a83 1
showLayout (enum tui_layout_type layout)
d85 1
a85 1
  enum tui_layout_type curLayout = tui_current_layout ();
d87 1
a87 1
  if (layout != curLayout)
d98 1
a98 1
	  _showData (layout);
d111 1
a111 1
	      _showSourceCommand ();
d115 1
a115 1
	      _showDisassemCommand ();
d119 1
a119 1
	      _showSourceDisassemCommand ();
d137 1
a137 1
tui_set_layout (enum tui_layout_type layoutType,
d142 1
a142 1
  if (layoutType != UNDEFINED_LAYOUT || regs_display_type != TUI_UNDEFINED_REGS)
d144 6
a149 6
      enum tui_layout_type curLayout = tui_current_layout (), newLayout = UNDEFINED_LAYOUT;
      int regsPopulate = FALSE;
      CORE_ADDR addr = _extractDisplayStartAddr ();
      struct tui_win_info * newWinWithFocus = (struct tui_win_info *) NULL;
      struct tui_win_info * winWithFocus = tui_win_with_focus ();
      struct tui_layout_def * layoutDef = tui_layout_def ();
d152 1
a152 1
      if (layoutType == UNDEFINED_LAYOUT &&
d155 7
a161 7
	  if (curLayout == SRC_DISASSEM_COMMAND)
	    newLayout = DISASSEM_DATA_COMMAND;
	  else if (curLayout == SRC_COMMAND || curLayout == SRC_DATA_COMMAND)
	    newLayout = SRC_DATA_COMMAND;
	  else if (curLayout == DISASSEM_COMMAND ||
		   curLayout == DISASSEM_DATA_COMMAND)
	    newLayout = DISASSEM_DATA_COMMAND;
d164 1
a164 1
	newLayout = layoutType;
d166 2
a167 2
      regsPopulate = (newLayout == SRC_DATA_COMMAND ||
		      newLayout == DISASSEM_DATA_COMMAND ||
d169 1
a169 1
      if (newLayout != curLayout || regs_display_type != TUI_UNDEFINED_REGS)
d171 1
a171 1
	  if (newLayout != curLayout)
d173 1
a173 1
	      showLayout (newLayout);
d177 1
a177 1
	      if (winWithFocus != TUI_CMD_WIN)
d179 1
a179 1
		  switch (newLayout)
d183 2
a184 2
		      layoutDef->display_mode = SRC_WIN;
		      layoutDef->split = FALSE;
d196 2
a197 2
		      layoutDef->display_mode = DISASSEM_WIN;
		      layoutDef->split = FALSE;
d208 1
a208 1
		      if (winWithFocus == TUI_SRC_WIN)
d212 1
a212 1
		      layoutDef->split = TRUE;
d215 1
a215 1
		      if (winWithFocus != TUI_DATA_WIN)
d219 2
a220 2
		      layoutDef->display_mode = SRC_WIN;
		      layoutDef->split = FALSE;
d231 1
a231 1
		      if (winWithFocus != TUI_DATA_WIN)
d235 2
a236 2
		      layoutDef->display_mode = DISASSEM_WIN;
		      layoutDef->split = FALSE;
d242 2
a243 2
	      if (newWinWithFocus != (struct tui_win_info *) NULL)
		tui_set_win_focus_to (newWinWithFocus);
d247 3
a249 3
	      if (!regsPopulate &&
		  (newLayout == SRC_DATA_COMMAND ||
		   newLayout == DISASSEM_DATA_COMMAND))
d254 1
a254 1
	  if (regsPopulate)
d256 1
a256 1
	      layoutDef->regs_display_type =
d259 1
a259 1
	      tui_show_registers (layoutDef->regs_display_type);
d275 1
a275 1
  enum tui_layout_type curLayout = tui_current_layout ();
d280 3
a282 3
      if (curLayout != SRC_COMMAND &&
	  curLayout != SRC_DISASSEM_COMMAND &&
	  curLayout != SRC_DATA_COMMAND)
d285 2
a286 2
	  if (curLayout == DISASSEM_DATA_COMMAND)
	    showLayout (SRC_DATA_COMMAND);
d288 1
a288 1
	    showLayout (SRC_COMMAND);
d292 3
a294 3
      if (curLayout != DISASSEM_COMMAND &&
	  curLayout != SRC_DISASSEM_COMMAND &&
	  curLayout != DISASSEM_DATA_COMMAND)
d297 2
a298 2
	  if (curLayout == SRC_DATA_COMMAND)
	    showLayout (DISASSEM_DATA_COMMAND);
d300 1
a300 1
	    showLayout (DISASSEM_COMMAND);
d304 2
a305 2
      if (curLayout != SRC_DATA_COMMAND &&
	  curLayout != DISASSEM_DATA_COMMAND)
d307 2
a308 2
	  if (curLayout == DISASSEM_COMMAND)
	    showLayout (DISASSEM_DATA_COMMAND);
d310 1
a310 1
	    showLayout (SRC_DATA_COMMAND);
d316 1
a317 2
  return;
}				/* tuiAddWinToLayout */
d319 3
a321 7

/*
   ** tuiDefaultWinHeight().
   **        Answer the height of a window.  If it hasn't been created yet,
   **        answer what the height of a window would be based upon its
   **        type and the layout.
 */
d323 1
a323 1
tuiDefaultWinHeight (enum tui_win_type type, enum tui_layout_type layout)
d355 1
a355 1
}				/* tuiDefaultWinHeight */
d367 1
a367 1
  h = tuiDefaultWinHeight (type, layout);
d375 1
a375 1
}				/* tuiDefaultWinViewportHeight */
d378 2
a379 5
/*
   ** _initialize_tuiLayout().
   **        Function to initialize gdb commands, for tui window layout
   **        manipulation.
 */
d381 1
a381 1
_initialize_tuiLayout (void)
d383 1
a383 1
  add_com ("layout", class_tui, _tuiLayout_command,
d398 1
a398 1
      add_com ("td", class_tui, _tuiToggleLayout_command,
d400 1
a400 1
      add_com ("ts", class_tui, _tuiToggleSplitLayout_command,
d412 2
a413 5
/*
   ** _tuiSetLayoutTo()
   **    Function to set the layout to SRC, ASM, SPLIT, NEXT, PREV, DATA, REGS,
   **        $REGS, $GREGS, $FREGS, $SREGS.
 */
d415 1
a415 1
tui_set_layout_for_display_command (const char *layoutName)
d419 1
a419 1
  if (layoutName != (char *) NULL)
d422 8
a429 8
      register char *bufPtr;
      enum tui_layout_type newLayout = UNDEFINED_LAYOUT;
      enum tui_register_display_type dpyType = TUI_UNDEFINED_REGS;
      enum tui_layout_type curLayout = tui_current_layout ();

      bufPtr = (char *) xstrdup (layoutName);
      for (i = 0; (i < strlen (layoutName)); i++)
	bufPtr[i] = toupper (bufPtr[i]);
d432 1
a432 1
      if (strlen (bufPtr) <= 1 && (*bufPtr == 'S' || *bufPtr == '$'))
d439 11
a449 11
	  if (subset_compare (bufPtr, "SRC"))
	    newLayout = SRC_COMMAND;
	  else if (subset_compare (bufPtr, "ASM"))
	    newLayout = DISASSEM_COMMAND;
	  else if (subset_compare (bufPtr, "SPLIT"))
	    newLayout = SRC_DISASSEM_COMMAND;
	  else if (subset_compare (bufPtr, "REGS") ||
		   subset_compare (bufPtr, TUI_GENERAL_SPECIAL_REGS_NAME) ||
		   subset_compare (bufPtr, TUI_GENERAL_REGS_NAME) ||
		   subset_compare (bufPtr, TUI_FLOAT_REGS_NAME) ||
		   subset_compare (bufPtr, TUI_SPECIAL_REGS_NAME))
d451 2
a452 2
	      if (curLayout == SRC_COMMAND || curLayout == SRC_DATA_COMMAND)
		newLayout = SRC_DATA_COMMAND;
d454 1
a454 1
		newLayout = DISASSEM_DATA_COMMAND;
d461 1
a461 1
	      if (subset_compare (bufPtr, TUI_FLOAT_REGS_NAME))
d467 1
a467 1
		    dpyType = TUI_SFLOAT_REGS;
d469 1
a469 1
		    dpyType =
d472 1
a472 1
	      else if (subset_compare (bufPtr,
d474 5
a478 5
		dpyType = TUI_GENERAL_AND_SPECIAL_REGS;
	      else if (subset_compare (bufPtr, TUI_GENERAL_REGS_NAME))
		dpyType = TUI_GENERAL_REGS;
	      else if (subset_compare (bufPtr, TUI_SPECIAL_REGS_NAME))
		dpyType = TUI_SPECIAL_REGS;
d483 1
a483 1
		    dpyType =
d486 1
a486 1
		    dpyType = TUI_GENERAL_REGS;
d496 1
a496 1
/*              dpyType = TUI_GENERAL_REGS; 
d499 4
a502 4
	  else if (subset_compare (bufPtr, "NEXT"))
	    newLayout = _nextLayout ();
	  else if (subset_compare (bufPtr, "PREV"))
	    newLayout = _prevLayout ();
d505 1
a505 1
	  xfree (bufPtr);
d507 1
a507 1
	  tui_set_layout (newLayout, dpyType);
d518 1
a518 1
_extractDisplayStartAddr (void)
d520 1
a520 1
  enum tui_layout_type curLayout = tui_current_layout ();
d525 1
a525 1
  switch (curLayout)
d545 1
a545 1
}				/* _extractDisplayStartAddr */
d549 1
a549 1
_tuiHandleXDBLayout (struct tui_layout_def * layoutDef)
d551 1
a551 1
  if (layoutDef->split)
d554 1
a554 1
      tui_set_win_focus_to (tui_win_list[layoutDef->display_mode]);
d558 1
a558 1
      if (layoutDef->display_mode == SRC_WIN)
d561 1
a561 1
	tui_set_layout (DISASSEM_DATA_COMMAND, layoutDef->regs_display_type);
d563 1
a563 4


  return;
}				/* _tuiHandleXDBLayout */
d567 1
a567 1
_tuiToggleLayout_command (char *arg, int fromTTY)
d569 1
a569 1
  struct tui_layout_def * layoutDef = tui_layout_def ();
d573 2
a574 2
  if (layoutDef->display_mode == SRC_WIN)
    layoutDef->display_mode = DISASSEM_WIN;
d576 1
a576 4
    layoutDef->display_mode = SRC_WIN;

  if (!layoutDef->split)
    _tuiHandleXDBLayout (layoutDef);
d578 2
d584 1
a584 1
_tuiToggleSplitLayout_command (char *arg, int fromTTY)
d586 1
a586 1
  struct tui_layout_def * layoutDef = tui_layout_def ();
d590 2
a591 3
  layoutDef->split = (!layoutDef->split);
  _tuiHandleXDBLayout (layoutDef);

d596 1
a596 1
_tuiLayout_command (char *arg, int fromTTY)
d607 1
a607 4
/*
   ** _nextLayout().
   **        Answer the previous layout to cycle to.
 */
d609 1
a609 1
_nextLayout (void)
d611 1
a611 1
  enum tui_layout_type newLayout;
d613 3
a615 3
  newLayout = tui_current_layout ();
  if (newLayout == UNDEFINED_LAYOUT)
    newLayout = SRC_COMMAND;
d618 3
a620 3
      newLayout++;
      if (newLayout == UNDEFINED_LAYOUT)
	newLayout = SRC_COMMAND;
d623 2
a624 2
  return newLayout;
}				/* _nextLayout */
d627 1
a627 4
/*
   ** _prevLayout().
   **        Answer the next layout to cycle to.
 */
d629 1
a629 1
_prevLayout (void)
d631 1
a631 1
  enum tui_layout_type newLayout;
d633 3
a635 3
  newLayout = tui_current_layout ();
  if (newLayout == SRC_COMMAND)
    newLayout = DISASSEM_DATA_COMMAND;
d638 3
a640 3
      newLayout--;
      if (newLayout == UNDEFINED_LAYOUT)
	newLayout = DISASSEM_DATA_COMMAND;
d643 2
a644 2
  return newLayout;
}				/* _prevLayout */
a647 3
/*
   ** _makeCommandWindow().
 */
d649 1
a649 1
_makeCommandWindow (struct tui_win_info * * winInfoPtr, int height, int originY)
d651 1
a651 1
  _initAndMakeWin ((void **) winInfoPtr,
d656 1
a656 1
		   originY,
d659 2
a660 4
  (*winInfoPtr)->can_highlight = FALSE;

  return;
}				/* _makeCommandWindow */
d664 1
a664 1
   ** _makeSourceWindow().
d667 1
a667 1
_makeSourceWindow (struct tui_win_info * * winInfoPtr, int height, int originY)
d669 1
a669 1
  _makeSourceOrDisassemWindow (winInfoPtr, SRC_WIN, height, originY);
d672 1
a672 1
}				/* _makeSourceWindow */
d676 1
a676 1
   ** _makeDisassemWindow().
d679 1
a679 1
_makeDisassemWindow (struct tui_win_info * * winInfoPtr, int height, int originY)
d681 1
a681 1
  _makeSourceOrDisassemWindow (winInfoPtr, DISASSEM_WIN, height, originY);
d684 1
a684 1
}				/* _makeDisassemWindow */
a686 3
/*
   ** _makeDataWindow().
 */
d688 1
a688 1
_makeDataWindow (struct tui_win_info * * winInfoPtr, int height, int originY)
d690 1
a690 1
  _initAndMakeWin ((void **) winInfoPtr,
d695 1
a695 1
		   originY,
d697 1
a697 3

  return;
}				/* _makeDataWindow */
d701 1
a701 4
/*
   **    _showSourceCommand().
   **        Show the Source/Command layout
 */
d703 1
a703 1
_showSourceCommand (void)
d705 2
a706 4
  _showSourceOrDisassemAndCommand (SRC_COMMAND);

  return;
}				/* _showSourceCommand */
d709 1
a709 4
/*
   **    _showDisassemCommand().
   **        Show the Dissassem/Command layout
 */
d711 1
a711 1
_showDisassemCommand (void)
d713 2
a714 4
  _showSourceOrDisassemAndCommand (DISASSEM_COMMAND);

  return;
}				/* _showDisassemCommand */
d717 1
a717 4
/*
   **    _showSourceDisassemCommand().
   **        Show the Source/Disassem/Command layout
 */
d719 1
a719 1
_showSourceDisassemCommand (void)
d723 1
a723 1
      int cmdHeight, srcHeight, asmHeight;
d726 1
a726 1
	cmdHeight = TUI_CMD_WIN->generic.height;
d728 1
a728 1
	cmdHeight = tui_term_height () / 3;
d730 2
a731 2
      srcHeight = (tui_term_height () - cmdHeight) / 2;
      asmHeight = tui_term_height () - (srcHeight + cmdHeight);
d734 1
a734 1
	_makeSourceWindow (&TUI_SRC_WIN, srcHeight, 0);
d737 1
a737 1
	  _initGenWinInfo (&TUI_SRC_WIN->generic,
d739 1
a739 1
			   srcHeight,
d744 1
a744 1
	  _initGenWinInfo (TUI_SRC_WIN->detail.source_info.execution_info,
d746 1
a746 1
			   srcHeight,
d761 2
a762 2
	      _makeDisassemWindow (&TUI_DISASM_WIN, asmHeight, srcHeight - 1);
	      _initAndMakeWin ((void **) & locator,
d767 1
a767 1
			       (srcHeight + asmHeight) - 1,
d772 1
a772 1
	      _initGenWinInfo (locator,
d777 1
a777 1
			       (srcHeight + asmHeight) - 1);
d779 1
a779 1
	      _initGenWinInfo (
d782 1
a782 1
				asmHeight,
d785 2
a786 2
				srcHeight - 1);
	      _initGenWinInfo (TUI_DISASM_WIN->detail.source_info.execution_info,
d788 1
a788 1
			       asmHeight,
d791 1
a791 1
			       srcHeight - 1);
d805 3
a807 3
		_makeCommandWindow (&TUI_CMD_WIN,
				    cmdHeight,
				    tui_term_height () - cmdHeight);
d810 1
a810 1
		  _initGenWinInfo (&TUI_CMD_WIN->generic,
d825 1
a826 2
  return;
}				/* _showSourceDisassemCommand */
d828 2
a829 5

/*
   **    _showData().
   **        Show the Source/Data/Command or the Dissassembly/Data/Command layout
 */
d831 1
a831 1
_showData (enum tui_layout_type newLayout)
d833 3
a835 3
  int totalHeight = (tui_term_height () - TUI_CMD_WIN->generic.height);
  int srcHeight, dataHeight;
  enum tui_win_type winType;
d839 2
a840 2
  dataHeight = totalHeight / 2;
  srcHeight = totalHeight - dataHeight;
d843 1
a843 1
  _makeDataWindow (&TUI_DATA_WIN, dataHeight, 0);
d845 2
a846 2
  if (newLayout == SRC_DATA_COMMAND)
    winType = SRC_WIN;
d848 2
a849 2
    winType = DISASSEM_WIN;
  if (tui_win_list[winType] == NULL)
d851 2
a852 2
      if (winType == SRC_WIN)
	_makeSourceWindow (&tui_win_list[winType], srcHeight, dataHeight - 1);
d854 2
a855 2
	_makeDisassemWindow (&tui_win_list[winType], srcHeight, dataHeight - 1);
      _initAndMakeWin ((void **) & locator,
d860 1
a860 1
		       totalHeight - 1,
d865 7
a871 7
      _initGenWinInfo (&tui_win_list[winType]->generic,
		       tui_win_list[winType]->generic.type,
		       srcHeight,
		       tui_win_list[winType]->generic.width,
		   tui_win_list[winType]->detail.source_info.execution_info->width,
		       dataHeight - 1);
      _initGenWinInfo (tui_win_list[winType]->detail.source_info.execution_info,
d873 1
a873 1
		       srcHeight,
d876 4
a879 4
		       dataHeight - 1);
      tui_make_visible (&tui_win_list[winType]->generic);
      tui_make_visible (tui_win_list[winType]->detail.source_info.execution_info);
      _initGenWinInfo (locator,
d884 1
a884 1
		       totalHeight - 1);
d886 1
a886 1
  tui_win_list[winType]->detail.source_info.has_locator = TRUE;
d889 3
a891 5
  tui_add_to_source_windows (tui_win_list[winType]);
  tui_set_current_layout_to (newLayout);

  return;
}				/* _showData */
d894 1
a894 1
   ** _initGenWinInfo().
d897 2
a898 2
_initGenWinInfo (struct tui_gen_win_info * winInfo, enum tui_win_type type,
                 int height, int width, int originX, int originY)
d902 3
a904 3
  winInfo->type = type;
  winInfo->width = width;
  winInfo->height = h;
d907 3
a909 3
      winInfo->viewport_height = h - 1;
      if (winInfo->type != CMD_WIN)
	winInfo->viewport_height--;
d912 3
a914 3
    winInfo->viewport_height = 1;
  winInfo->origin.x = originX;
  winInfo->origin.y = originY;
d917 1
a917 1
}				/* _initGenWinInfo */
d920 1
a920 1
   ** _initAndMakeWin().
d923 2
a924 2
_initAndMakeWin (void ** winInfoPtr, enum tui_win_type winType,
                 int height, int width, int originX, int originY, int boxIt)
d926 1
a926 1
  void *opaqueWinInfo = *winInfoPtr;
d929 1
a929 1
  if (opaqueWinInfo == NULL)
d931 2
a932 2
      if (tui_win_is_auxillary (winType))
	opaqueWinInfo = (void *) tui_alloc_generic_win_info ();
d934 1
a934 1
	opaqueWinInfo = (void *) tui_alloc_win_info (winType);
d936 2
a937 2
  if (tui_win_is_auxillary (winType))
    generic = (struct tui_gen_win_info *) opaqueWinInfo;
d939 1
a939 1
    generic = &((struct tui_win_info *) opaqueWinInfo)->generic;
d941 1
a941 1
  if (opaqueWinInfo != NULL)
d943 2
a944 2
      _initGenWinInfo (generic, winType, height, width, originX, originY);
      if (!tui_win_is_auxillary (winType))
d947 1
a947 1
	    ((struct tui_win_info *) opaqueWinInfo)->can_highlight = FALSE;
d949 1
a949 1
	    ((struct tui_win_info *) opaqueWinInfo)->can_highlight = TRUE;
d951 1
a951 1
      tui_make_window (generic, boxIt);
d953 1
a953 1
  *winInfoPtr = opaqueWinInfo;
a956 3
/*
   ** _makeSourceOrDisassemWindow().
 */
d958 2
a959 2
_makeSourceOrDisassemWindow (struct tui_win_info * * winInfoPtr, enum tui_win_type type,
                             int height, int originY)
d970 1
a970 1
  _initAndMakeWin ((void **) & execution_info,
d975 1
a975 1
		   originY,
d980 1
a980 1
  _initAndMakeWin ((void **) winInfoPtr,
d985 1
a985 1
		   originY,
d988 2
a989 4
  (*winInfoPtr)->detail.source_info.execution_info = execution_info;

  return;
}				/* _makeSourceOrDisassemWindow */
d992 1
a992 4
/*
   **    _showSourceOrDisassemAndCommand().
   **        Show the Source/Command or the Disassem layout
 */
d994 1
a994 1
_showSourceOrDisassemAndCommand (enum tui_layout_type layoutType)
d996 1
a996 1
  if (tui_current_layout () != layoutType)
d998 2
a999 2
      struct tui_win_info * *winInfoPtr;
      int srcHeight, cmdHeight;
d1003 1
a1003 1
	cmdHeight = TUI_CMD_WIN->generic.height;
d1005 2
a1006 2
	cmdHeight = tui_term_height () / 3;
      srcHeight = tui_term_height () - cmdHeight;
d1009 2
a1010 2
      if (layoutType == SRC_COMMAND)
	winInfoPtr = &TUI_SRC_WIN;
d1012 1
a1012 1
	winInfoPtr = &TUI_DISASM_WIN;
d1014 1
a1014 1
      if ((*winInfoPtr) == NULL)
d1016 2
a1017 2
	  if (layoutType == SRC_COMMAND)
	    _makeSourceWindow (winInfoPtr, srcHeight - 1, 0);
d1019 2
a1020 2
	    _makeDisassemWindow (winInfoPtr, srcHeight - 1, 0);
	  _initAndMakeWin ((void **) & locator,
d1025 1
a1025 1
			   srcHeight - 1,
d1030 1
a1030 1
	  _initGenWinInfo (locator,
d1035 8
a1042 8
			   srcHeight - 1);
	  (*winInfoPtr)->detail.source_info.has_locator = TRUE;
	  _initGenWinInfo (
			    &(*winInfoPtr)->generic,
			    (*winInfoPtr)->generic.type,
			    srcHeight - 1,
			    (*winInfoPtr)->generic.width,
		      (*winInfoPtr)->detail.source_info.execution_info->width,
d1044 1
a1044 1
	  _initGenWinInfo ((*winInfoPtr)->detail.source_info.execution_info,
d1046 1
a1046 1
			   srcHeight - 1,
d1050 3
a1052 3
	  (*winInfoPtr)->can_highlight = TRUE;
	  tui_make_visible (&(*winInfoPtr)->generic);
	  tui_make_visible ((*winInfoPtr)->detail.source_info.execution_info);
d1054 1
a1054 1
      if ((*winInfoPtr) != NULL)
d1056 1
a1056 1
	  (*winInfoPtr)->detail.source_info.has_locator = TRUE;
d1059 1
a1059 1
	  tui_show_source_content (*winInfoPtr);
d1063 1
a1063 1
	      _makeCommandWindow (&TUI_CMD_WIN, cmdHeight, srcHeight);
d1068 1
a1068 1
	      _initGenWinInfo (&TUI_CMD_WIN->generic,
d1078 1
a1078 1
      tui_set_current_layout_to (layoutType);
d1080 1
a1080 3

  return;
}				/* _showSourceOrDisassemAndCommand */
@


1.12
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui.h (Opaque, OpaquePtr OpaqueList): Delete definition.
	(TuiPoint, TuiPointPtr): Ditto.
	(TuiStatus, TuiStatusPtr): Ditto.
	(TuiWinType, TuiWinTypePtr): Ditto.
	(struct tui_point): Rename _TuiPoint.
	(tui_get_low_disassembly_address): Rename
	tuiGetLowDisassemblyAddress.
	(tui_update_all_exec_infos): Rename tuiUpdateAllExecInfos.
	(tuiFree): Delete declaration.
	(OpaqueFuncPtr, TuiOpaqueFuncPtr): Delete definitions.
	(TuiVoidFuncPtr, TuiIntFuncPtr): Delete definitions.
	* tui/tui.c (tuiFree): Delete function.
	* cli/cli-cmds.c (disassemble_command): Update references.
	* tui/tui-data.c, tui/tui-data.h, tui/tui-disasm.c: Ditto.
	* tui/tui-layout.c, tui/tui-regs.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-win.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d99 1
a99 1
	  tui_refresh_all (winList);
d112 1
a112 1
	      tui_add_to_source_windows (srcWin);
d116 1
a116 1
	      tui_add_to_source_windows (disassemWin);
d120 2
a121 2
	      tui_add_to_source_windows (srcWin);
	      tui_add_to_source_windows (disassemWin);
d135 1
a135 1
   regsDisplayType.  */
d138 1
a138 1
		enum tui_register_display_type regsDisplayType)
d142 1
a142 1
  if (layoutType != UNDEFINED_LAYOUT || regsDisplayType != TUI_UNDEFINED_REGS)
d153 1
a153 1
	  regsDisplayType != TUI_UNDEFINED_REGS)
d168 2
a169 2
		      regsDisplayType != TUI_UNDEFINED_REGS);
      if (newLayout != curLayout || regsDisplayType != TUI_UNDEFINED_REGS)
d177 1
a177 1
	      if (winWithFocus != cmdWin)
d182 2
a183 2
		      tui_set_win_focus_to (srcWin);
		      layoutDef->displayMode = SRC_WIN;
d195 2
a196 2
		      tui_set_win_focus_to (disassemWin);
		      layoutDef->displayMode = DISASSEM_WIN;
d208 2
a209 2
		      if (winWithFocus == srcWin)
			tui_set_win_focus_to (srcWin);
d211 1
a211 1
			tui_set_win_focus_to (disassemWin);
d215 2
a216 2
		      if (winWithFocus != dataWin)
			tui_set_win_focus_to (srcWin);
d218 2
a219 2
			tui_set_win_focus_to (dataWin);
		      layoutDef->displayMode = SRC_WIN;
d231 2
a232 2
		      if (winWithFocus != dataWin)
			tui_set_win_focus_to (disassemWin);
d234 2
a235 2
			tui_set_win_focus_to (dataWin);
		      layoutDef->displayMode = DISASSEM_WIN;
d256 4
a259 4
	      layoutDef->regsDisplayType =
		(regsDisplayType == TUI_UNDEFINED_REGS ?
		 TUI_GENERAL_REGS : regsDisplayType);
	      tui_show_registers (layoutDef->regsDisplayType);
d332 2
a333 2
  if (winList[type] != (struct tui_win_info *) NULL)
    h = winList[type]->generic.height;
d340 1
a340 1
	  if (m_winPtrIsNull (cmdWin))
d343 1
a343 1
	    h = tui_term_height () - cmdWin->generic.height;
d348 1
a348 1
	  if (m_winPtrIsNull (cmdWin))
d351 1
a351 1
	    h = (tui_term_height () - cmdWin->generic.height) / 2;
d374 1
a374 1
  if (winList[type] == cmdWin)
d474 1
a474 1
		  if (dataWin->detail.dataDisplayInfo.regsDisplayType !=
d476 1
a476 1
		      dataWin->detail.dataDisplayInfo.regsDisplayType !=
d481 1
a481 1
		      dataWin->detail.dataDisplayInfo.regsDisplayType;
d490 1
a490 1
	      else if (dataWin)
d492 1
a492 1
		  if (dataWin->detail.dataDisplayInfo.regsDisplayType !=
d495 1
a495 1
		      dataWin->detail.dataDisplayInfo.regsDisplayType;
d541 1
a541 1
		    srcWin->detail.sourceInfo.startLineOrAddr.lineNo,
d548 1
a548 1
      addr = disassemWin->detail.sourceInfo.startLineOrAddr.addr;
d565 1
a565 1
      tui_set_win_focus_to (winList[layoutDef->displayMode]);
d569 1
a569 1
      if (layoutDef->displayMode == SRC_WIN)
d572 1
a572 1
	tui_set_layout (DISASSEM_DATA_COMMAND, layoutDef->regsDisplayType);
d587 2
a588 2
  if (layoutDef->displayMode == SRC_WIN)
    layoutDef->displayMode = DISASSEM_WIN;
d590 1
a590 1
    layoutDef->displayMode = SRC_WIN;
d684 1
a684 1
  (*winInfoPtr)->canHighlight = FALSE;
d770 2
a771 2
      if (m_winPtrNotNull (cmdWin))
	cmdHeight = cmdWin->generic.height;
d778 2
a779 2
      if (m_winPtrIsNull (srcWin))
	_makeSourceWindow (&srcWin, srcHeight, 0);
d782 2
a783 2
	  _initGenWinInfo (&srcWin->generic,
			   srcWin->generic.type,
d785 2
a786 2
			   srcWin->generic.width,
			   srcWin->detail.sourceInfo.executionInfo->width,
d788 2
a789 2
	  srcWin->canHighlight = TRUE;
	  _initGenWinInfo (srcWin->detail.sourceInfo.executionInfo,
d795 3
a797 3
	  tui_make_visible (&srcWin->generic);
	  tui_make_visible (srcWin->detail.sourceInfo.executionInfo);
	  srcWin->detail.sourceInfo.hasLocator = FALSE;;
d799 1
a799 1
      if (m_winPtrNotNull (srcWin))
d803 2
a804 2
	  tui_show_source_content (srcWin);
	  if (m_winPtrIsNull (disassemWin))
d806 1
a806 1
	      _makeDisassemWindow (&disassemWin, asmHeight, srcHeight - 1);
d823 1
a823 1
	      disassemWin->detail.sourceInfo.hasLocator = TRUE;
d825 2
a826 2
				&disassemWin->generic,
				disassemWin->generic.type,
d828 2
a829 2
				disassemWin->generic.width,
			disassemWin->detail.sourceInfo.executionInfo->width,
d831 1
a831 1
	      _initGenWinInfo (disassemWin->detail.sourceInfo.executionInfo,
d837 3
a839 3
	      disassemWin->canHighlight = TRUE;
	      tui_make_visible (&disassemWin->generic);
	      tui_make_visible (disassemWin->detail.sourceInfo.executionInfo);
d841 1
a841 1
	  if (m_winPtrNotNull (disassemWin))
d843 2
a844 2
	      srcWin->detail.sourceInfo.hasLocator = FALSE;
	      disassemWin->detail.sourceInfo.hasLocator = TRUE;
d847 1
a847 1
	      tui_show_source_content (disassemWin);
d849 2
a850 2
	      if (m_winPtrIsNull (cmdWin))
		_makeCommandWindow (&cmdWin,
d855 4
a858 4
		  _initGenWinInfo (&cmdWin->generic,
				   cmdWin->generic.type,
				   cmdWin->generic.height,
				   cmdWin->generic.width,
d860 3
a862 3
				   cmdWin->generic.origin.y);
		  cmdWin->canHighlight = FALSE;
		  tui_make_visible (&cmdWin->generic);
d864 2
a865 2
	      if (m_winPtrNotNull (cmdWin))
		tui_refresh_win (&cmdWin->generic);
d882 1
a882 1
  int totalHeight = (tui_term_height () - cmdWin->generic.height);
d892 2
a893 2
  _makeDataWindow (&dataWin, dataHeight, 0);
  dataWin->canHighlight = TRUE;
d898 1
a898 1
  if (m_winPtrIsNull (winList[winType]))
d901 1
a901 1
	_makeSourceWindow (&winList[winType], srcHeight, dataHeight - 1);
d903 1
a903 1
	_makeDisassemWindow (&winList[winType], srcHeight, dataHeight - 1);
d914 2
a915 2
      _initGenWinInfo (&winList[winType]->generic,
		       winList[winType]->generic.type,
d917 2
a918 2
		       winList[winType]->generic.width,
		   winList[winType]->detail.sourceInfo.executionInfo->width,
d920 1
a920 1
      _initGenWinInfo (winList[winType]->detail.sourceInfo.executionInfo,
d926 2
a927 2
      tui_make_visible (&winList[winType]->generic);
      tui_make_visible (winList[winType]->detail.sourceInfo.executionInfo);
d935 1
a935 1
  winList[winType]->detail.sourceInfo.hasLocator = TRUE;
d938 1
a938 1
  tui_add_to_source_windows (winList[winType]);
d958 1
a958 1
      winInfo->viewportHeight = h - 1;
d960 1
a960 1
	winInfo->viewportHeight--;
d963 1
a963 1
    winInfo->viewportHeight = 1;
d982 1
a982 1
      if (m_winIsAuxillary (winType))
d987 1
a987 1
  if (m_winIsAuxillary (winType))
d995 1
a995 1
      if (!m_winIsAuxillary (winType))
d998 1
a998 1
	    ((struct tui_win_info *) opaqueWinInfo)->canHighlight = FALSE;
d1000 1
a1000 1
	    ((struct tui_win_info *) opaqueWinInfo)->canHighlight = TRUE;
d1015 1
a1015 1
  struct tui_gen_win_info * executionInfo = (struct tui_gen_win_info *) NULL;
d1021 1
a1021 1
    executionInfo = tui_source_exec_info_win_ptr ();
d1023 2
a1024 2
    executionInfo = tui_disassem_exec_info_win_ptr ();
  _initAndMakeWin ((void **) & executionInfo,
d1037 2
a1038 2
		   tui_term_width () - executionInfo->width,
		   executionInfo->width,
d1042 1
a1042 1
  (*winInfoPtr)->detail.sourceInfo.executionInfo = executionInfo;
d1061 2
a1062 2
      if (m_winPtrNotNull (cmdWin))
	cmdHeight = cmdWin->generic.height;
d1069 1
a1069 1
	winInfoPtr = &srcWin;
d1071 1
a1071 1
	winInfoPtr = &disassemWin;
d1073 1
a1073 1
      if (m_winPtrIsNull (*winInfoPtr))
d1095 1
a1095 1
	  (*winInfoPtr)->detail.sourceInfo.hasLocator = TRUE;
d1101 1
a1101 1
		      (*winInfoPtr)->detail.sourceInfo.executionInfo->width,
d1103 1
a1103 1
	  _initGenWinInfo ((*winInfoPtr)->detail.sourceInfo.executionInfo,
d1109 1
a1109 1
	  (*winInfoPtr)->canHighlight = TRUE;
d1111 1
a1111 1
	  tui_make_visible ((*winInfoPtr)->detail.sourceInfo.executionInfo);
d1113 1
a1113 1
      if (m_winPtrNotNull (*winInfoPtr))
d1115 1
a1115 1
	  (*winInfoPtr)->detail.sourceInfo.hasLocator = TRUE;
d1120 1
a1120 1
	  if (m_winPtrIsNull (cmdWin))
d1122 2
a1123 2
	      _makeCommandWindow (&cmdWin, cmdHeight, srcHeight);
	      tui_refresh_win (&cmdWin->generic);
d1127 8
a1134 8
	      _initGenWinInfo (&cmdWin->generic,
			       cmdWin->generic.type,
			       cmdWin->generic.height,
			       cmdWin->generic.width,
			       cmdWin->generic.origin.x,
			       cmdWin->generic.origin.y);
	      cmdWin->canHighlight = FALSE;
	      tui_make_visible (&cmdWin->generic);
@


1.11
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

        * tui/tui-data.h (tui_win_element): Rename TuiWinElement.
        (tui_exec_info_content): Rename TuiExecInfoContent.
        (TuiGenWinInfo, TuiGenWinInfoPtr): Delete definitions.
        (TuiWinInfo, TuiWinInfoPtr): Ditto.
        (TuiScrollDirection, TuiScrollDirectionPtr): Ditto.
        (TuiList, TuiListPtr): Ditto.
        (TuiLayoutType, TuiLayoutTypePtr): Ditto.
        (TuiDataType, TuiDataTypePtr): Ditto.
        (TuiRegisterDisplayType, TuiRegisterDisplayTypePtr): Ditto.
        (TuiLineOrAddress, TuiLineOrAddressPtr): Ditto.
        (TuiLayoutDef, TuiLayoutDefPtr): Ditto.
        (TuiSourceElement, TuiSourceElementPtr): Ditto.
        (TuiDataElement, TuiDataElementPtr): Ditto.
        (TuiWinElement, TuiWinElementPtr): Ditto.
        (TuiDataInfo, TuiDataInfoPtr): Ditto.
        (TuiCommandElement, TuiCommandElementPtr): Ditto.
        (TuiLocatorElement, TuiLocatorElementPtr): Ditto.
        (TuiWhichElement, TuiWhichElementPtr): Ditto.
        (TuiSourceInfo, TuiSourceInfoPtr): Ditto.
        (TuiCommandInfo, TuiCommandInfoPtr): Ditto.
        * tui/tui-command.c, tui/tui-data.c: Update references.
        * tui/tui-data.h, tui/tui-disasm.c, tui/tui-layout.c: Ditto.
        * tui/tui-regs.c, tui/tui-source.c, tui/tui-stack.c: Ditto.
        * tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
        * tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d54 2
a55 2
static void _initGenWinInfo (struct tui_gen_win_info *, TuiWinType, int, int, int, int);
static void _initAndMakeWin (Opaque *, TuiWinType, int, int, int, int, int);
d57 1
a57 1
static void _makeSourceOrDisassemWindow (struct tui_win_info * *, TuiWinType, int, int);
d140 1
a140 1
  TuiStatus status = TUI_SUCCESS;
d328 1
a328 1
tuiDefaultWinHeight (TuiWinType type, enum tui_layout_type layout)
d425 1
a425 1
TuiStatus
d428 1
a428 1
  TuiStatus status = TUI_SUCCESS;
d676 1
a676 1
  _initAndMakeWin ((Opaque *) winInfoPtr,
d720 1
a720 1
  _initAndMakeWin ((Opaque *) winInfoPtr,
d807 1
a807 1
	      _initAndMakeWin ((Opaque *) & locator,
d884 1
a884 1
  TuiWinType winType;
d904 1
a904 1
      _initAndMakeWin ((Opaque *) & locator,
d948 1
a948 1
_initGenWinInfo (struct tui_gen_win_info * winInfo, TuiWinType type,
d974 1
a974 1
_initAndMakeWin (Opaque * winInfoPtr, TuiWinType winType,
d977 1
a977 1
  Opaque opaqueWinInfo = *winInfoPtr;
d980 1
a980 1
  if (opaqueWinInfo == (Opaque) NULL)
d983 1
a983 1
	opaqueWinInfo = (Opaque) tui_alloc_generic_win_info ();
d985 1
a985 1
	opaqueWinInfo = (Opaque) tui_alloc_win_info (winType);
d992 1
a992 1
  if (opaqueWinInfo != (Opaque) NULL)
d1012 1
a1012 1
_makeSourceOrDisassemWindow (struct tui_win_info * * winInfoPtr, TuiWinType type,
d1024 1
a1024 1
  _initAndMakeWin ((Opaque *) & executionInfo,
d1034 1
a1034 1
  _initAndMakeWin ((Opaque *) winInfoPtr,
d1079 1
a1079 1
	  _initAndMakeWin ((Opaque *) & locator,
@


1.10
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-data.h (struct tui_list): Rename _TuiList.
	(enum tui_data_type): Rename _TuiDataType.
	(struct tui_layout_def): Rename _TuiLayoutDef.
	(struct tui_source_element): Rename _TuiSourceElement.
	(struct tui_data_element): Rename _TuiDataElement.
	(struct tui_command_element): Rename _TuiCommandElement.
	(struct tui_locator_element): Rename _TuiLocatorElement.
	(union tui_which_element): Define.
	(struct tui_win_element): Rename _TuiWinElement.
	(struct tui_data_info): Rename _TuiDataInfo.
	(struct tui_source_info): Rename _TuiSourceInfo.
	(struct tui_command_info): Rename _TuiCommandInfo.
	(tui_initialize_static_data): Rename initializeStaticData.
	(tui_alloc_generic_win_info): Rename allocGenericWinInfo.
	(tui_alloc_win_info): Rename allocWinInfo.
	(tui_init_generic_part): Rename initGenericPart.
	(tui_init_win_info): Rename initWinInfo.
	(tui_alloc_content): Rename allocContent.
	(tui_add_content_elements): Rename addContentElements.
	(tui_init_content_element): Rename initContentElement.
	(tui_free_window): Rename freeWindow.
	(tui_free_win_content): Rename freeWinContent.
	(tui_free_data_content): Rename freeDataContent.
	(tui_free_all_source_wins_content): Rename
	freeAllSourceWinsContent.
	(tui_del_window): Rename tuiDelWindow.
	(tui_del_data_windows): Rename tuiDelDataWindows.
	(tui_partial_win_by_name): Rename partialWinByName.
	(tui_win_name): Rename winName.
	(tui_current_layout): Rename currentLayout.
	(tui_set_current_layout_to): Rename setCurrentLayoutTo.
	(tui_term_height): Rename termHeight.
	(tui_set_term_height_to): Rename setTermHeightTo.
	(tui_term_width): Rename termWidth.
	(tui_set_term_width_to): Rename setTermWidthTo.
	(tui_set_gen_win_origin): Rename setGenWinOrigin.
	(tui_locator_win_info_ptr): Rename locatorWinInfoPtr.
	(tui_source_exec_info_win_ptr): Rename tui_gen_win_info.
	(tui_disassem_exec_info_win_ptr): Rename disassemExecInfoWinPtr.
	(tui_source_windows): Rename sourceWindows.
	(tui_clear_source_windows): Rename clearSourceWindows.
	(tui_clear_source_windows_detail): Rename
	clearSourceWindowsDetail.
	(tui_clear_win_detail): Rename clearWinDetail.
	(tui_add_to_source_windows): Rename tuiAddToSourceWindows.
	(tui_default_tab_len): Rename tuiDefaultTabLen.
	(tui_set_default_tab_len): Rename tuiSetDefaultTabLen.
	(tui_win_with_focus): Rename tuiWinWithFocus.
	(tui_set_win_with_focus): Rename tuiSetWinWithFocus.
	(tui_layout_def): Rename tuiLayoutDef.
	(tui_win_resized): Rename tuiWinResized.
	(tui_set_win_resized_to): Rename tuiSetWinResizedTo.
	(tui_next_win): Rename tuiNextWin.
	(tui_prev_win): Rename tuiPrevWin.
	(tui_add_to_source_windows): Rename addToSourceWindows.
	* tui/tui-winsource.c, tui/tui-win.c: Update references.
	* tui/tui-layout.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-io.c: Ditto.
	* tui/tui.c, tui/tui-data.c: Ditto.
	* tui/tui-interp.c, tui/tui-data.c: Ditto.
	* tui/tui-disasm.c, tui/tui-command.c: Ditto.
@
text
@d53 2
a54 2
static void showLayout (TuiLayoutType);
static void _initGenWinInfo (TuiGenWinInfoPtr, TuiWinType, int, int, int, int);
d56 6
a61 6
static void _showSourceOrDisassemAndCommand (TuiLayoutType);
static void _makeSourceOrDisassemWindow (TuiWinInfoPtr *, TuiWinType, int, int);
static void _makeCommandWindow (TuiWinInfoPtr *, int, int);
static void _makeSourceWindow (TuiWinInfoPtr *, int, int);
static void _makeDisassemWindow (TuiWinInfoPtr *, int, int);
static void _makeDataWindow (TuiWinInfoPtr *, int, int);
d65 3
a67 3
static void _showData (TuiLayoutType);
static TuiLayoutType _nextLayout (void);
static TuiLayoutType _prevLayout (void);
d72 1
a72 1
static void _tuiHandleXDBLayout (TuiLayoutDefPtr);
d83 1
a83 1
showLayout (TuiLayoutType layout)
d85 1
a85 1
  TuiLayoutType curLayout = tui_current_layout ();
d144 1
a144 1
      TuiLayoutType curLayout = tui_current_layout (), newLayout = UNDEFINED_LAYOUT;
d147 3
a149 2
      TuiWinInfoPtr newWinWithFocus = (TuiWinInfoPtr) NULL, winWithFocus = tui_win_with_focus ();
      TuiLayoutDefPtr layoutDef = tui_layout_def ();
d242 1
a242 1
	      if (newWinWithFocus != (TuiWinInfoPtr) NULL)
d275 1
a275 1
  TuiLayoutType curLayout = tui_current_layout ();
d328 1
a328 1
tuiDefaultWinHeight (TuiWinType type, TuiLayoutType layout)
d332 1
a332 1
  if (winList[type] != (TuiWinInfoPtr) NULL)
d434 3
a436 3
      TuiLayoutType newLayout = UNDEFINED_LAYOUT;
      TuiRegisterDisplayType dpyType = TUI_UNDEFINED_REGS;
      TuiLayoutType curLayout = tui_current_layout ();
d531 1
a531 1
  TuiLayoutType curLayout = tui_current_layout ();
d560 1
a560 1
_tuiHandleXDBLayout (TuiLayoutDefPtr layoutDef)
d583 1
a583 1
  TuiLayoutDefPtr layoutDef = tui_layout_def ();
d601 1
a601 1
  TuiLayoutDefPtr layoutDef = tui_layout_def ();
d627 1
a627 1
static TuiLayoutType
d630 1
a630 1
  TuiLayoutType newLayout;
d650 1
a650 1
static TuiLayoutType
d653 1
a653 1
  TuiLayoutType newLayout;
d674 1
a674 1
_makeCommandWindow (TuiWinInfoPtr * winInfoPtr, int height, int originY)
d694 1
a694 1
_makeSourceWindow (TuiWinInfoPtr * winInfoPtr, int height, int originY)
d706 1
a706 1
_makeDisassemWindow (TuiWinInfoPtr * winInfoPtr, int height, int originY)
d718 1
a718 1
_makeDataWindow (TuiWinInfoPtr * winInfoPtr, int height, int originY)
d801 1
a801 1
	  TuiGenWinInfoPtr locator = tui_locator_win_info_ptr ();
d880 1
a880 1
_showData (TuiLayoutType newLayout)
d885 1
a885 1
  TuiGenWinInfoPtr locator = tui_locator_win_info_ptr ();
d948 1
a948 1
_initGenWinInfo (TuiGenWinInfoPtr winInfo, TuiWinType type,
d978 1
a978 1
  TuiGenWinInfoPtr generic;
d988 1
a988 1
    generic = (TuiGenWinInfoPtr) opaqueWinInfo;
d990 1
a990 1
    generic = &((TuiWinInfoPtr) opaqueWinInfo)->generic;
d998 1
a998 1
	    ((TuiWinInfoPtr) opaqueWinInfo)->canHighlight = FALSE;
d1000 1
a1000 1
	    ((TuiWinInfoPtr) opaqueWinInfo)->canHighlight = TRUE;
d1012 1
a1012 1
_makeSourceOrDisassemWindow (TuiWinInfoPtr * winInfoPtr, TuiWinType type,
d1015 1
a1015 1
  TuiGenWinInfoPtr executionInfo = (TuiGenWinInfoPtr) NULL;
d1053 1
a1053 1
_showSourceOrDisassemAndCommand (TuiLayoutType layoutType)
d1057 1
a1057 1
      TuiWinInfoPtr *winInfoPtr;
d1059 1
a1059 1
      TuiGenWinInfoPtr locator = tui_locator_win_info_ptr ();
@


1.9
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-win.h: Update copyright.  Include "tui-data.h".
	(struct tui_win_info): Declare.
	(tui_scroll_forward): Rename tuiScrollForward.
	(tui_scroll_backward): Rename tuiScrollBackward.
	(tui_scroll_left): Rename tuiScrollLeft.
	(tui_scroll_right): Rename tuiScrollRight.
	(tui_set_win_focus_to): Rename tuiSetWinFocusTo.
	(tui_resize_all): Rename tuiResizeAll.
	(tui_refresh_all_win): Rename tuiRefreshAll.
	(tui_sigwinch_handler): Rename tuiSigwinchHandler.
	* tui/tui-layout.c, * tui/tui-io.c: Update references.
	* tui/tui-wingeneral.h, * tui/tui.c: Update references.
	* tui/tui-disasm.c, * tui/tui-command.c: Update references.
@
text
@d85 1
a85 1
  TuiLayoutType curLayout = currentLayout ();
d94 2
a95 2
      freeAllSourceWinsContent ();
      clearSourceWindows ();
d105 1
a105 1
	  tui_make_invisible (locatorWinInfoPtr ());
d112 1
a112 1
	      addToSourceWindows (srcWin);
d116 1
a116 1
	      addToSourceWindows (disassemWin);
d120 2
a121 2
	      addToSourceWindows (srcWin);
	      addToSourceWindows (disassemWin);
d144 1
a144 1
      TuiLayoutType curLayout = currentLayout (), newLayout = UNDEFINED_LAYOUT;
d147 2
a148 2
      TuiWinInfoPtr newWinWithFocus = (TuiWinInfoPtr) NULL, winWithFocus = tuiWinWithFocus ();
      TuiLayoutDefPtr layoutDef = tuiLayoutDef ();
d274 1
a274 1
  TuiLayoutType curLayout = currentLayout ();
d283 1
a283 1
	  clearSourceWindowsDetail ();
d295 1
a295 1
	  clearSourceWindowsDetail ();
d340 1
a340 1
	    h = termHeight () / 2;
d342 1
a342 1
	    h = termHeight () - cmdWin->generic.height;
d348 1
a348 1
	    h = termHeight () / 3;
d350 1
a350 1
	    h = (termHeight () - cmdWin->generic.height) / 2;
d435 1
a435 1
      TuiLayoutType curLayout = currentLayout ();
d530 1
a530 1
  TuiLayoutType curLayout = currentLayout ();
d582 1
a582 1
  TuiLayoutDefPtr layoutDef = tuiLayoutDef ();
d600 1
a600 1
  TuiLayoutDefPtr layoutDef = tuiLayoutDef ();
d631 1
a631 1
  newLayout = currentLayout ();
d654 1
a654 1
  newLayout = currentLayout ();
d678 1
a678 1
		   termWidth (),
d722 1
a722 1
		   termWidth (),
d765 1
a765 1
  if (currentLayout () != SRC_DISASSEM_COMMAND)
d772 1
a772 1
	cmdHeight = termHeight () / 3;
d774 2
a775 2
      srcHeight = (termHeight () - cmdHeight) / 2;
      asmHeight = termHeight () - (srcHeight + cmdHeight);
d800 1
a800 1
	  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
d809 1
a809 1
			       termWidth (),
d819 1
a819 1
			       termWidth (),
d851 1
a851 1
				    termHeight () - cmdHeight);
d867 1
a867 1
      setCurrentLayoutTo (SRC_DISASSEM_COMMAND);
d881 1
a881 1
  int totalHeight = (termHeight () - cmdWin->generic.height);
d884 1
a884 1
  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
d906 1
a906 1
		       termWidth (),
d930 1
a930 1
		       termWidth (),
d937 2
a938 2
  addToSourceWindows (winList[winType]);
  setCurrentLayoutTo (newLayout);
d982 1
a982 1
	opaqueWinInfo = (Opaque) allocGenericWinInfo ();
d984 1
a984 1
	opaqueWinInfo = (Opaque) allocWinInfo (winType);
d1020 1
a1020 1
    executionInfo = sourceExecInfoWinPtr ();
d1022 1
a1022 1
    executionInfo = disassemExecInfoWinPtr ();
d1036 1
a1036 1
		   termWidth () - executionInfo->width,
d1054 1
a1054 1
  if (currentLayout () != layoutType)
d1058 1
a1058 1
      TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
d1063 2
a1064 2
	cmdHeight = termHeight () / 3;
      srcHeight = termHeight () - cmdHeight;
d1081 1
a1081 1
			   termWidth (),
d1091 1
a1091 1
			   termWidth (),
d1136 1
a1136 1
      setCurrentLayoutTo (layoutType);
@


1.8
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-windata.h: Update copyright.  Include "tui-data.h".
	(tui_erase_data_content): Rename tuiEraseDataContent.
	(tui_display_all_data): Rename tuiDisplayAllData.
	(tui_check_data_values): Rename tuiCheckDataValues.
	(tui_display_data_from_line): Rename tuiDisplayDataFromLine.
	(tui_first_data_item_displayed): Rename tuiFirstDataItemDisplayed.
	(tui_first_data_element_no_in_line): Rename
	tuiFirstDataElementNoInLine.
	(tui_delete_data_content_windows): Rename
	tuiDeleteDataContentWindows.
	(tui_refresh_data_win): Rename tuiRefreshDataWin.
	(tui_display_data_from): Rename tuiDisplayDataFrom.
	(tui_vertical_data_scroll): Rename tuiVerticalDataScroll.
	* tui/tui-windata.c, tui/tui-hooks.c: Update references.
	* tui/tui-win.c, tui/tui-regs.c: Update references.
	* tui/tui-layout.c, tui/tui.c: Update references.
@
text
@d181 1
a181 1
		      tuiSetWinFocusTo (srcWin);
d194 1
a194 1
		      tuiSetWinFocusTo (disassemWin);
d208 1
a208 1
			tuiSetWinFocusTo (srcWin);
d210 1
a210 1
			tuiSetWinFocusTo (disassemWin);
d215 1
a215 1
			tuiSetWinFocusTo (srcWin);
d217 1
a217 1
			tuiSetWinFocusTo (dataWin);
d231 1
a231 1
			tuiSetWinFocusTo (disassemWin);
d233 1
a233 1
			tuiSetWinFocusTo (dataWin);
d242 1
a242 1
		tuiSetWinFocusTo (newWinWithFocus);
d564 1
a564 1
      tuiSetWinFocusTo (winList[layoutDef->displayMode]);
@


1.7
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-wingeneral.h: Update copyright.
	(m_allBeVisible): Delete macro.
	(m_allBeInvisible): Delete macro.
	(struct tui_gen_win_info): Declare.
	(struct tui_win_info): Declare.
	(tui_unhighlight_win): Rename unhighlightWin.
	(tui_make_visible, tui_make_invisible): Replace makeVisible.
	(tui_make_all_visible, tui_make_all_invisible): Replace makeAllVisible.
	(tui_make_window): Rename makeWindow.
	(tui_copy_win): Rename copyWin.
	(tui_box_win): Rename boxWin.
	(tui_highlight_win): Rename highlightWin.
	(tui_check_and_display_highlight_if_needed): Rename
	checkAndDisplayHighlightIfNeeded.
	(tui_refresh_all): Rename refreshAll.
	(tui_delete_win): Rename tuiDelwin.
	(tui_refresh_win): Rename tuiRefreshWin.
	* tui/tui-wingeneral.c (make_visible): Rename makeVisible.
	(tui_make_visible, tui_make_invisible): New functions.
	(tui_make_all_visible, tui_make_all_invisible): New functions.
	(make_all_visible): Rename makeAllVisible.
	* tui/tui-winsource.c, tui/tui-windata.c: Update references.
	* tui/tui-data.c, tui/tui-winsource.c: Update references.
	* tui/tui-windata.c, tui/tui-win.c: Update references.
	* tui/tui-regs.c, tui/tui-layout.c: Update references.
	* tui/tui-data.h (struct tui_gen_win_info): Rename _TuiGenWinInfo.
@
text
@d249 1
a249 1
		tuiDisplayAllData ();
@


1.6
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-source.h: Do not include "defs.h".
	(struct tui_win_info): Declare.
	(tui_set_source_content_nil): Declare.
	* tui/tui-data.h (struct tui_win_info): Rename _TuiWinInfo.
	(union tui_line_or_address): Rename _TuiLineOrAddress.
	* tui/tui-winsource.h: Update copyright.  Include "tui-data.h".
	(tui_update_source_window): Rename tuiUpdateSourceWindow.
	(tui_update_source_window_as_is): Rename
	tuiUpdateSourceWindowAsIs.
	(tui_update_source_windows_with_addr): Rename
	tuiUpdateSourceWindowsWithAddr.
	(tui_update_source_windows_with_line): Rename
	tuiUpdateSourceWindowsWithLine.
	(tui_clear_source_content): Rename tuiClearSourceContent.
	(tui_erase_source_content): Rename tuiEraseSourceContent.
	(tui_set_source_content_nil): Rename tuiSetSourceContentNil.
	(tui_show_source_content): Rename tuiShowSourceContent.
	(tui_horizontal_source_scroll): Rename tuiHorizontalSourceScroll.
	(tui_set_exec_info_content): Rename tuiSetExecInfoContent.
	(tui_show_exec_info_content): Rename tuiShowExecInfoContent.
	(tui_erase_exec_info_content): Rename tuiEraseExecInfoContent.
	(tui_clear_exec_info_content): Rename tuiClearExecInfoContent.
	(tui_update_exec_info): Rename tuiUpdateExecInfo.
	(tui_set_is_exec_point_at): Rename tuiSetIsExecPointAt.
	(tui_alloc_source_buffer): Rename tuiAllocSourceBuffer.
	(tui_line_is_displayed): Rename tuiLineIsDisplayed.
	(tui_addr_is_displayed): Rename tuiAddrIsDisplayed.
	(struct tui_win_info): Declare.
	* tui/tui-stack.c: Update references.
	* tui/tui-layout.c, tui/tui-winsource.c: Ditto.
	* tui/tui-win.c, tui/tui-source.c: Ditto.
	* tui/tui.c, tui/tui-disasm.c: Ditto.
@
text
@d99 1
a99 1
	  refreshAll (winList);
d104 2
a105 2
	  m_allBeInvisible ();
	  m_beInvisible (locatorWinInfoPtr ());
d794 2
a795 2
	  m_beVisible (srcWin);
	  m_beVisible (srcWin->detail.sourceInfo.executionInfo);
d837 2
a838 2
	      m_beVisible (disassemWin);
	      m_beVisible (disassemWin->detail.sourceInfo.executionInfo);
d844 1
a844 1
	      m_beVisible (locator);
d861 1
a861 1
		  m_beVisible (cmdWin);
d864 1
a864 1
		tuiRefreshWin (&cmdWin->generic);
d889 2
a890 2
  m_allBeInvisible ();
  m_beInvisible (locator);
d925 2
a926 2
      m_beVisible (winList[winType]);
      m_beVisible (winList[winType]->detail.sourceInfo.executionInfo);
d935 1
a935 1
  m_beVisible (locator);
d1001 1
a1001 1
      makeWindow (generic, boxIt);
d1109 2
a1110 2
	  m_beVisible (*winInfoPtr);
	  m_beVisible ((*winInfoPtr)->detail.sourceInfo.executionInfo);
d1115 1
a1115 1
	  m_beVisible (locator);
d1122 1
a1122 1
	      tuiRefreshWin (&cmdWin->generic);
d1133 1
a1133 1
	      m_beVisible (cmdWin);
@


1.5
log
@2004-01-28  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-stack.h: Update copyright.
	(struct frame_info): Add opaque declaration.
	(tui_update_locator_filename): Rename tuiUpdateLocatorFilename.
	(tui_show_locator_content): Rename tuiShowLocatorContent.
	(tui_show_frame_info): Rename tuiShowFrameInfo.
	* tui/tui-stack.c: Update copyright.  Update references.
	* tui/tui-winsource.c: Update references.
	* tui/tui-win.c: Update references.
	* tui/tui-layout.c: Update references.
	* tui/tui-hooks.c: Update copyright, update references.
	* tui/tui.c: Update copyright, update references.
	* tui/tui-disasm.c: Update references.
@
text
@d251 1
a251 1
	      tuiUpdateSourceWindowsWithAddr (addr);
d802 1
a802 1
	  tuiShowSourceContent (srcWin);
d846 1
a846 1
	      tuiShowSourceContent (disassemWin);
d1117 1
a1117 1
	  tuiShowSourceContent (*winInfoPtr);
@


1.4
log
@2004-01-23  Andrew Cagney  <cagney@@redhat.com>

	* printcmd.c (display_command): Replace tui_set_display call with
	tui_set_layout_for_display_command.
	* tui/tui.h (enum tui_win_type): Define.
	(tui_set_layout): Delete declaration.
	(tui_set_layout_for_display_command): Rename set_tui_layout.
	* tui/tui-data.h (enum tui_layout_type): Define.
	* tui/tui-layout.h: Update copyright.  Include "tui-data.h" and
	"tui.h".
	(tui_add_win_to_layout): Rename tuiAddWinToLayout.
	(tui_default_win_height): Rename tuiDefaultWinHeight.
	(tui_default_win_viewport_height): Rename
	tuiDefaultWinViewportHeight.
	(tui_set_layout): RenametuiSetLayout.
	* tui/tui-layout.c: Update references.
	* tui/tui.c: Update references.
	* tui/tui-disasm.c: Update references.
@
text
@d845 1
a845 1
	      tuiShowLocatorContent ();
d936 1
a936 1
  tuiShowLocatorContent ();
d1116 1
a1116 1
	  tuiShowLocatorContent ();
@


1.4.2.1
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@


1.3
log
@2004-01-20  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-disasm.h: Update copyright.  Include "tui.h" and
	"tui-data.h".
	(tui_set_disassem_content): Rename tuiSetDisassemContent.
	(tui_show_disassem): Rename tuiShowDisassem.
	(tui_show_disassem_and_update_source): Rename
	tuiVerticalDisassemScroll.
	(tui_vertical_disassem_scroll): Rename tuiVerticalDisassemScroll.
	(tui_get_begin_asm_address): Rename tuiGetBeginAsmAddress.
	* tui/tui.h: Update copyright.
	(enum tui_status): Define.
	* tui/tui-data.h (enum tui_scroll_direction): Define.
	* tui/tui-disasm.c: Update copyright.  Update references.
	* tui/tui-winsource.c: 	Update copyright.  Update references.
	* tui/tui-win.c: Update references.
	* tui/tui-layout.c: Update references.
@
text
@d131 8
a138 11
/*
   ** tuiSetLayout()
   **    Function to set the layout to SRC_COMMAND, DISASSEM_COMMAND,
   **    SRC_DISASSEM_COMMAND, SRC_DATA_COMMAND, or DISASSEM_DATA_COMMAND.
   **    If the layout is SRC_DATA_COMMAND, DISASSEM_DATA_COMMAND, or
   **    UNDEFINED_LAYOUT, then the data window is populated according
   **    to regsDisplayType.
 */
TuiStatus
tuiSetLayout (TuiLayoutType layoutType,
              TuiRegisterDisplayType regsDisplayType)
d268 3
a270 6
/*
   ** tuiAddWinToLayout().
   **        Add the specified window to the layout in a logical way.
   **        This means setting up the most logical layout given the
   **        window to be added.
 */
d272 1
a272 1
tuiAddWinToLayout (TuiWinType type)
d362 3
a364 6
/*
   ** tuiDefaultWinViewportHeight().
   **        Answer the height of a window.  If it hasn't been created yet,
   **        answer what the height of a window would be based upon its
   **        type and the layout.
 */
d366 2
a367 1
tuiDefaultWinViewportHeight (TuiWinType type, TuiLayoutType layout)
d425 1
a425 1
tui_set_layout (const char *layoutName)
d517 1
a517 1
	  tuiSetLayout (newLayout, dpyType);
d563 1
a563 1
      tuiSetLayout (SRC_DISASSEM_COMMAND, TUI_UNDEFINED_REGS);
d569 1
a569 1
	tuiSetLayout (SRC_COMMAND, TUI_UNDEFINED_REGS);
d571 1
a571 1
	tuiSetLayout (DISASSEM_DATA_COMMAND, layoutDef->regsDisplayType);
d617 1
a617 1
  if (tui_set_layout (arg) != TUI_SUCCESS)
@


1.2
log
@2004-01-19  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-regs.h: Include "tui-data.h".
	(tuiFirstRegElementNoInLine): Delete declaration.
	(tui_display_registers_from): Rename tuiDisplayRegistersFrom.
	(tui_last_regs_line_no): Rename tuiLastRegsLineNo.
	(tui_line_from_reg_element_no): Rename tuiLineFromRegElementNo.
	(tui_calculate_regs_column_count): Rename
	tuiCalculateRegsColumnCount.
	(tui_check_register_values): Rename tuiCheckRegisterValues.
	(tui_show_registers): Rename tuiShowRegisters.
	(tui_display_registers_from_line): Rename
	tuiDisplayRegistersFromLine.
	(tui_first_reg_element_inline): Rename tuiFirstRegElementInLine.
	(tui_toggle_float_regs): Rename tuiToggleFloatRegs.
	(tui_first_reg_element_no_inline): Rename
	tuiFirstRegElementNoInLine.
	* tui/tui-data.h: Update copyright.
	(enum tui_register_display_type): Rename _TuiRegisterDisplayType.
	* tui/tui-windata.c: Update copyright, update references.
	* tui/tui-regs.c: Update copyright, update references.
	* tui/tui-win.c: Update copyright, update references.
	* tui/tui-layout.c: Update copyright, update references.
@
text
@d196 1
a196 1
		      addr = tuiGetBeginAsmAddress ();
d209 1
a209 1
		      addr = tuiGetBeginAsmAddress ();
d232 1
a232 1
		      addr = tuiGetBeginAsmAddress ();
@


1.1
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.
d261 1
a261 1
	      tuiShowRegisters (layoutDef->regsDisplayType);
@

